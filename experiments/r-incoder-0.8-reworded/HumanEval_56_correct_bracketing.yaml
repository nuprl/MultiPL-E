name: HumanEval_56_correct_bracketing
language: r
prompt: "# brackets is a string of \"<\" and \">\".\n# return TRUE if every opening\
  \ bracket has a corresponding closing bracket.\n# >>> correct_bracketing('<')\n\
  # FALSE\n# >>> correct_bracketing('<>')\n# TRUE\n# >>> correct_bracketing('<<><>>')\n\
  # TRUE\n# >>> correct_bracketing('><<>')\n# FALSE\ncorrect_bracketing <- function(brackets)\
  \ {"
tests: "test_humaneval <- function() {\ncandidate <- correct_bracketing\n    if(!identical(candidate('<>'),\
  \ TRUE)){quit('no', 1)}\n    if(!identical(candidate('<<><>>'), TRUE)){quit('no',\
  \ 1)}\n    if(!identical(candidate('<><><<><>><>'), TRUE)){quit('no', 1)}\n    if(!identical(candidate('<><><<<><><>><>><<><><<>>>'),\
  \ TRUE)){quit('no', 1)}\n    if(!identical(candidate('<<<><>>>>'), FALSE)){quit('no',\
  \ 1)}\n    if(!identical(candidate('><<>'), FALSE)){quit('no', 1)}\n    if(!identical(candidate('<'),\
  \ FALSE)){quit('no', 1)}\n    if(!identical(candidate('<<<<'), FALSE)){quit('no',\
  \ 1)}\n    if(!identical(candidate('>'), FALSE)){quit('no', 1)}\n    if(!identical(candidate('<<>'),\
  \ FALSE)){quit('no', 1)}\n    if(!identical(candidate('<><><<><>><>><<>'), FALSE)){quit('no',\
  \ 1)}\n    if(!identical(candidate('<><><<><>><>>><>'), FALSE)){quit('no', 1)}\n\
  }\ntest_humaneval()"
completions: ["\n  all(lapply(strsplit(brackets, split = \"<-\"), lengths) == 2)\n\
    }\n\n</cell>\n<cell>", "\n    lapply(strsplit(brackets, \"\"), function(x) {\n\
    \        identical(which(x == '<'), which(x == '>'))\n    })\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks, you were also very helpful in helping me understand regex\
    \ in R. I'm sure it'll be helpful in the future.\n<|/ c |>\n<| c |>\n+1 for a\
    \ great answer. I would just add that `lapply` doesn't need to be used here and\
    \ you can instead use `gregexpr` and `regmatches` as `gregexpr` returns a `list`\
    \ which can be used to do logical comparison with `regmatches`.\n<|/ c |>\n<|\
    \ c |>\n- agreed, `gregexpr` is actually the more 'R' way of doing it here though,\
    \ as it doesn't involve the regex package. Your solution is more 'R' way of doing\
    \ it, but it does involve some packages. In fact, the regex package isn't even\
    \ loaded.\n<|/ c |>\n<| a dscore=1 tags=r,regex,brackets,string |>\n<code>\n>\
    \ str <- \"<<><><<><<><<>>\"\n> gsub(\"\\\\<[^<]+>\", \"\", str)\n[1] \"<<><><>><<>>\"\
    \n</code>\n<|/ a |>\n<| c |>\nI think this fails if there are brackets in the\
    \ middle of the string, and I think it fails if `<<><>><<>` is present multiple\
    \ times.\n<|/ c |>\n<| c |>\nActually this fails for multiple `<<>`.  Try `str\
    \ <- \"<<><><>><<>><<>>\"`.\n<|/ c |>\n<| c |>\nI didn't realize multiple `<<>`s\
    \ was a requirement, thanks for pointing that out. Updated.\n<|/ c |>\n<| c |>\n\
    +1 this also fails if there are brackets in the middle of the string `\"<><<><>\"\
    `\n<|/ c |>\n<| c |>\nUpdated accordingly (thanks for the heads-up!).\n<|/ c |>\n\
    <| a tags=r,regex,brackets,string |>\nWe can try with gsub\n<code>\ngsub(\"<|>\"\
    , \"\", str1, perl = TRUE)", "\n  bracket_positions <- which(brackets == '<')\n\
    \  right_bracket_positions <- which(brackets == '>')\n  \n  # The last position\
    \ is right before the first right bracket,\n  # which we know should be TRUE.\n\
    \  return(all(right_bracket_positions[-1] - bracket_positions[-1] == 1))\n}\n",
  "\n  brackets = regexpr(\"(<.*?>)\", brackets)\n  brackets\n  brackets$match ==\
    \ brackets$length\n}\n", "\n  all_brackets <- gregexpr(\"<[>]+\", brackets)\n\
    \  return(\n    all(\n      lapply(all_brackets, function(x) {\n        xl <-\
    \ substring(brackets, 1, 1)\n        xr <- substring(brackets, xl + 1, 1)\n  \
    \      is.na(xr) & is.na(xl)\n      })\n    )\n  )\n}\n</code>\nTesting:\n<code>\n\
    > correct_bracketing('<')\n[1] FALSE\n> correct_bracketing('<>')\n[1] TRUE\n>\
    \ correct_bracketing('<<><>>')\n[1] TRUE\n> correct_bracketing('><<>')\n[1] FALSE\n\
    </code>\n<|/ a dscore=4 tags=r,regex,string |>\n<| c |>\nThis seems to be the\
    \ closest to what I had in mind. Although, I also want to be able to use it with\
    \ multiple patterns at once. For instance, `correct_bracketing('ab<ab>')` should\
    \ return `FALSE` since the two brackets in that pattern are not adjacent.\n<|/\
    \ c |>\n<| c |>\nOk, it seems to work with multiple patterns, thank you very much!\
    \ I modified it slightly to allow multiple patterns like `correct_bracketing('ab<ab><a><a>',\
    \ 'ab<ab>')` and it works. Thank you!\n<|/ c |>\n<| c |>\nHmm, I tried testing\
    \ it out with multiple patterns and it seems to be returning TRUE for the first\
    \ pattern but FALSE for the rest. I'm guessing it might be an issue with my regex\
    \ but I'm not sure. I'll look into it.\n<|/ c |>\n<| a dscore=3 |>\nThis is an\
    \ interesting problem and I like your use of the word 'bracketing' to describe\
    \ the problem you describe.  Your idea of looking for two consecutive matching\
    \ pairs of opening and closing brackets was a good one.  Here is my attempt. \
    \ I hope this helps others that may stumble upon your question.\n<code>\ntest\
    \ <- \"ab<ab><a><a>\"\n", "\n  open_brackets <- unlist(strsplit(brackets, '[<>]'))\n\
    \  return(length(grep('>', open_brackets)) == length(grep('<', open_brackets)))\n\
    }\n", "\n    all(\n        grepl(\"^(<[\\\\]]+>)$\", brackets, perl = TRUE)\n\
    \    )\n}\n", "\n  bracketing <- strsplit(brackets, \"\")[[1]]\n  \n  return(length(bracketing)\
    \ == length(unique(unlist(bracketing))))\n}\n</cell>\n<text>\nAs a second function,\
    \ check_if_brackets_are_valid checks every open bracket has a corresponding close\
    \ bracket.\n\n\n</text>\n<code language=conda-env-CourseraMLAndrewNgmyNoteEnv-py>",
  "\n  for (i in 1:length(brackets)) {\n    openingBracket <- brackets[i]\n    if\
    \ (openingBracket == '<') openingBracket <- \">\"\n    else openingBracket <-\
    \ \"<<\"\n    closingBracket <- brackets[i+1]\n    if (closingBracket == '<')\
    \ closingBracket <- \">\"\n    else closingBracket <- \"<<\"\n    if (openingBracket\
    \ != closingBracket) {\n      return (FALSE)\n    }\n  }\n  return (TRUE)\n}\n\
    \n", "\n  # Return TRUE if all open brackets have corresponding closing brackets.\n\
    \  return(grepl('<', brackets) & grepl('>', brackets))\n}\n", "\n  # No brackets\
    \ means nothing is correct.\n  if (length(brackets) == 0) return(TRUE)\n  # Check\
    \ for balanced brackets.\n  open <- 0\n  close <- 0\n  length <- 0\n  for(i in\
    \ 1:length(brackets)) {\n    # Only proceed if character in brackets.\n    if\
    \ (brackets[i] == '<') {\n      # Check to see if it's already open.\n      if(open\
    \ == 0) {\n        # Open it.\n        open <- i\n      }\n    }\n    if (brackets[i]\
    \ == '>') {\n      # Check to see if it's already closed.\n      if(close == 0)\
    \ {\n        # Close it.\n        close <- i\n      }\n    }\n  }\n  # Check that\
    \ all the brackets are closed in the right order.\n  if(open == close || close\
    \ == (length(brackets) - 1)) {\n    # Open is close or all brackets are closed\
    \ in the right order.\n    for(i in 1:(length(brackets) - open)) {\n      # Check\
    \ to see if the brackets are in the right order.\n      if(brackets[i + open]\
    \ == '<') {\n        # Close them.\n        brackets <- gsub('(','',brackets,fixed=TRUE)\n\
    \        brackets <- gsub(')','',brackets,fixed=TRUE)\n        brackets <- gsub('<','',brackets,fixed=TRUE)\n\
    \        brackets <- gsub('>','',brackets,fixed=TRUE)\n      } else {\n      \
    \  # Open them.\n        brackets <- gsub('(','(',brackets,fixed=TRUE)\n     \
    \   brackets <- gsub(')','(',brackets,fixed=TRUE)\n        brackets <- gsub('<','(',brackets,fixed=TRUE)\n\
    \        brackets <- gsub('>','(',brackets,fixed=TRUE)\n      }\n    }\n  }\n\
    \  return(length(brackets) == 0)\n}\n</code>\n<|/ a |>\n<| c |>\nI do not understand\
    \ how this would work. Can you explain what this piece of code does?\n<|/ c |>\n\
    <| c |>\nWhat do you mean by \"bracket\"? Is this a term from math? I thought\
    \ this was a term in the C language?\n<|/ c |>\n<| c |>\nA bracket is a set of\
    \ characters enclosed by parentheses (or some other character). In C, the characters\
    \ `<` and `>` are used to designate this set. For example: `int x = 5; printf(\"\
    %d is the value of a variable of type int.\\n\", x);`\n<|/ c |>\n<| c |>\nThis\
    \ code looks for the opening bracket ", "\n  length(brackets) == 1 ||\n    all(brackets\
    \ == substr(brackets, 1, 1) | brackets == substr(brackets, 2, nchar(brackets)\
    \ - 1))\n}\n</cell>\n<text>\n3.3 Implement the get_lines_in_range function, which\
    \ takes a line number and a file, and returns all lines in the file that contain\
    \ the line number in their first or last column. For example, if the function\
    \ were passed the line number 3 and the following file:\n\n\n</text>\n<cell>\n\
    line1 <- c('line1', 'line2', 'line3', 'line4')\nline2 <- c('line5', 'line6', 'line7')\n\
    line3 <- c('line8', 'line9', 'line10')\n</cell>\n<cell>", "\n  for(i in 1:length(brackets))\
    \ {\n    if(brackets[i] == \"<\" && brackets[i+1] == \"<\") {\n      return(TRUE)\n\
    \    } else if(brackets[i] == \">\" && brackets[i+1] == \">\") {\n      return(TRUE)\n\
    \    } else {\n      return(FALSE)\n    }\n  }\n}\n", "\n  for(i in 1:(length(brackets)-1)){\n\
    \    if(brackets[i] == brackets[i+1]){\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n\
    }\n", "\n  brackets <-\n    gsub(\"[<>]\", \"\", brackets)  # remove \"<\" and\
    \ \">\"\n  brackets <- unlist(strsplit(brackets, split=\" \"))\n  all(lengths(brackets)\
    \ == 1) && all(\n    lengths(Filter(function(x) {\n      x == \"\"\n    }, lapply(brackets,\
    \ length)) <= 1\n  )  # If there is an odd number of opening brackets, all must\
    \ have an even number of closing brackets.\n}\n", "\n  all(gsub(\"[<>]\", \"\"\
    , brackets) ==\n         gsub(\"[<>]\", \"\", brackets[-1L]))\n}\n", "\n  nchar(brackets)\
    \ >= 2 && nchar(brackets) <= length(brackets)\n  bracket_pairs <- strsplit(brackets,\
    \ \"\")[[1]]\n  map(bracket_pairs, ~which(strsplit(.x, \"[>]\")[[1]] == nchar(.x)))\n\
    }\n", "\n  # Check that the brackets argument is a character string.\n  if (!is.character(brackets))\
    \ {\n    stop('brackets must be a character string')\n  }\n  # Return True if\
    \ no bracketing is needed.\n  return(length(brackets) == 0)\n}\n", "\n  opens\
    \ <- strsplit(brackets, '[<>]')[[1]]\n  closes <- strsplit(brackets, '[<>]')[[2]]\n\
    \  return(length(unique(opens)) == length(unique(closes)))\n}\n</code>\nNow let's\
    \ try to find all the subsets of the vector:\n<code>\n> find_subsets(letters)",
  "\n  brackets = strsplit(brackets, \"[<>]\")[[1]]\n  all_brackets = setdiff(unlist(brackets),\
    \ \"><\")\n  return(length(all_brackets) == 0)\n}\n", "\n  # Split on \"<\" and\
    \ \">\" characters.\n  brackets_split <- strsplit(brackets, \"<>\")\n  # Test\
    \ if every opening bracket has a corresponding closing bracket.\n  # A list comprehension\
    \ works nicely.\n  all(sapply(brackets_split, function(x) all(sapply(x, strsplit,\
    \ \">\"))))\n}\n\n", "\n    \n    # initialize a counter to keep track of matching\
    \ brackets\n    matching_brackets <- 0\n    \n    # initialize a vector to hold\
    \ the brackets being compared\n    comparision_brackets <- c(\">\", \"<\")\n \
    \   \n    # loop through all characters in brackets\n    for (i in 1:length(brackets))\
    \ {\n        # if the current bracket is a <, increment matching_brackets\n  \
    \      if (brackets[i] == \"<\") {\n            matching_brackets = matching_brackets\
    \ + 1\n        }\n        # if the current bracket is a >, decrement matching_brackets\n\
    \        else if (brackets[i] == \">\") {\n            matching_brackets = matching_brackets\
    \ - 1\n        }\n        # if the current bracket is an opening bracket, decrement\
    \ matching_brackets\n        else if (brackets[i] == \"<\") {\n            matching_brackets\
    \ = matching_brackets - 1\n        }\n        # if the current bracket is a closing\
    \ bracket, increment matching_brackets\n        else if (brackets[i] == \">\"\
    ) {\n            matching_brackets = matching_brackets + 1\n        }\n    }\n\
    \    \n    # return TRUE if the brackets are matching\n    return (matching_brackets\
    \ == 0)\n}\n", "\n  # Check each opening bracket has an equivalent closing bracket.\n\
    \  # The second return is required only in case of bracketing problems because\n\
    \  # the return value of grepl() is TRUE or FALSE.\n  return(grepl('<', brackets)==grepl('>',\
    \ brackets) & grepl('>', brackets)==TRUE)\n}\n</cell>\n<text>\n3.2.2 Removing\
    \ a Bracket\nRemoving a closing bracket is done by replacing the first occurence\
    \ of the matching opening bracket with the second one.\nFor instance, if we want\
    \ to remove a closing bracket that comes right before a word that starts with\
    \ a lowercase letter:\n\n>>> remove_brackets('(<x>)->(<y>)')\n'(x->y)'\n\n</text>\n\
    <cell>", "\n  # the opening and closing brackets must be present with matching\
    \ brackets\n  opening_brackets <- sub('\\\\<', '', brackets)\n  closing_brackets\
    \ <- sub('\\\\>', '', brackets)\n\n  # the opening bracket must not have matching\
    \ closing bracket\n  opening_brackets <- gsub('\\\\>', '', opening_brackets)\n\
    \n  return(!length(opening_brackets) | !length(closing_brackets) &\n         \
    \ opening_brackets == closing_brackets)\n}\n\ncorrect_bracketing(brackets)\n</code>\n\
    <|/ a tags=r,text-analysis,regex,pattern-matching dscore=1 |>\n<| a tags=r,text-analysis,regex,pattern-matching\
    \ dscore=0 |>\nThis might be a bit too simple, but you could use str_detect from\
    \ stringr package:\n<code>\nstr_extract_all('this text is cool and', '\\\\<[^>]+\\\
    \\>')\n</code>\n<|/ a |>\n<| a tags=r,text-analysis,regex,pattern-matching |>\n\
    Here is a method that works in case you have more complex patterns and your goal\
    \ is to extract patterns inside the brackets.\n<code>\nlibrary(stringr)\n", "\n\
    \  return(grepl(\"[<>]\", brackets))\n}\n</cell>\n<text>\nA: Testing the function\n\
    \n\n</text>\n<cell>", "\n  return(length(gregexpr('(?<=>)', brackets, perl = TRUE))\
    \ ==\n         length(gregexpr('(?=<)', brackets, perl = TRUE)))\n}\n", "\n  i\
    \ <- 1\n  for(bracket in brackets) {\n    if(substr(brackets, i, i) == substr(brackets,\
    \ 1, i)) {\n      i <- i + 2\n    }\n    else {\n      return (i != 1)\n    }\n\
    \  }\n  FALSE\n}\n", "\n  brackets <- toupper(brackets)\n  brackets <- gsub(\"\
    ^\\\\<+\", \"\", brackets)\n  brackets <- gsub(\"+\\\\>$\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\<+$\", \"\", brackets)\n  brackets <- paste0(\"[\",\
    \ brackets, \"]\")\n  brackets <- gsub(\"[\\\\[\\\\]]\", \"\", brackets)\n  brackets\
    \ <- gsub(\"\\\\+\", \"|\", brackets)\n  brackets <- gsub(\"\\\\|+\", \"|\", brackets)\n\
    \  brackets <- gsub(\"\\\\+$\", \"\", brackets)\n  brackets <- gsub(\"\\\\|$\"\
    , \"\", brackets)\n  brackets <- paste0(\"^\", brackets, \"$\")\n  brackets <-\
    \ paste0(\"[\", brackets, \"]\")\n  brackets <- gsub(\"\\\\]\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\[\", \"\", brackets)\n  brackets <- gsub(\"]$\", \"\"\
    , brackets)\n  brackets <- paste0(\"^\", brackets, \"$\")\n  brackets <- paste0(\"\
    [\", brackets, \"]\")\n  brackets <- gsub(\"\\\\>\", \"\", brackets)\n  brackets\
    \ <- gsub(\"\\\\<\", \"\", brackets)\n  brackets <- gsub(\"\\\\>$\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\<$\", \"\", brackets)\n  brackets <- gsub(\"\\\\[\"\
    , \"\", brackets)\n  brackets <- gsub(\"\\\\]$\", \"\", brackets)\n  brackets\
    \ <- gsub(\"]\", \"\", brackets)\n  brackets <- paste0(\"^\", brackets, \"$\"\
    )\n  brackets <- paste0(\"[\", brackets, \"]\")\n  brackets <- gsub(\"\\\\+$\"\
    , \"\", brackets)\n  brackets <- gsub(\"\\\\|$\", \"\", brackets)\n  brackets\
    \ <- gsub(\"\\\\+\", \"\", brackets)\n  brackets <- gsub(\"\\\\|\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\+$\", \"\", brackets)\n  brackets <- gsub(\"\\\\|$\"\
    , \"\", brackets)\n  brackets <- paste0(\"^\", brackets, \"$\")\n  brackets <-\
    \ paste0(\"[\", brackets, ", "\n  # The first argument is the string containing\
    \ the brackets.\n  # The second argument is a list of opening brackets, and the\
    \ third argument\n  # is a list of closing brackets.\n  all_brackets <- unlist(strsplit(brackets,\
    \ \"\"))\n  opening_brackets <- strsplit(all_brackets[[1]], \"<<\")[[1]][1]\n\
    \  closing_brackets <- strsplit(all_brackets[[1]], \"<<\")[[1]][2]\n  # A list\
    \ that contains the brackets that should be correct.\n  correct_brackets <- unlist(lapply(opening_brackets,\
    \ function(x) which(closing_brackets %in% x)))\n  # A list that contains the brackets\
    \ that should be correct.\n  bad_closing_brackets <- which(closing_brackets !%in%\
    \ opening_brackets)\n  # Return TRUE if every opening bracket has a corresponding\
    \ closing bracket.\n  # return TRUE if every opening bracket has a corresponding\
    \ closing bracket.\n  # return TRUE if every opening bracket has a corresponding\
    \ closing bracket.\n  # return TRUE if every opening bracket has a corresponding\
    \ closing bracket.\n  ifelse(length(correct_brackets) == length(opening_brackets)\n\
    \         & length(correct_brackets) == length(closing_brackets)\n         & length(correct_brackets)\
    \ == length(bad_closing_brackets), TRUE,\n         FALSE)\n}\n</cell>\n<cell>",
  "\n  open_brackets <- gregexpr(\"<<\", brackets)\n  close_brackets <- gregexpr(\"\
    >>\", brackets)\n  length(open_brackets) == length(close_brackets)\n}\n</code>\n\
    Then you can check how many brackets are correct and how many are wrong.\n<code>\n\
    correct_brackets(brackets)\nwrong_open_brackets <- which(open_brackets != close_brackets)\n\
    </code>\nI used this example to check that the function works:\n<code>\nbrackets\
    \ <- c(\"<<<\", \"<<<\", \"<<<\", \"<<<\", \"<>>>\", \"<<<\")\ncorrect_brackets(brackets)\n\
    wrong_open_brackets <- which(open_brackets != close_brackets)\n</code>\nI then\
    \ defined a function to check if there is a missing closing bracket:\n<code>\n\
    check_brackets <- function(brackets) {\n  open_brackets <- gregexpr(\"<<\", brackets)\n\
    \  close_brackets <- gregexpr(\">>\", brackets)\n  length(open_brackets) == length(close_brackets)\n\
    }\n</code>\nThen I used it to count how many brackets are incorrect and how many\
    \ are correct.\n<code>\ncheck_brackets(brackets)\ncorrect_brackets(brackets)\n\
    </code>\nThis example checks that there wasn't any missing brackets and that there\
    \ aren't any brackets that are wrong.\n<code>\nbrackets <- c(\"<<<\", \"<<<\"\
    , \"<<<\", \"<<<\", \"<<<\", \"<<<\")\ncheck_brackets(brackets)\ncorrect_brackets(brackets)\n\
    </code>\nIf it returns FALSE then the brackets are correct. If it returns TRUE\
    \ then there is a missing closing bracket or an extra opening bracket.\n<|/ a\
    \ tags=regex,r |>\n<| c |>\nYour solution assumes that a closing bracket follows\
    \ a matching opening bracket (which is true in OP's examples), but doesn't assume\
    \ that there is only one correct opening bracket and one correct closing bracket.\
    \ Your function returns TRUE if the brackets are correctly ordered, but returns\
    \ FALSE if the brackets are incorrectly ordered. So your function should return\
    \ FALSE when `brackets <- c(\"<<<\", \"<<<\", \"<<<\", \"<<<\", \"<>>>\", \"<<<\"\
    )`.\n<|/ c |>\n<| c |>\nI did think of the case where one extra opening bracket\
    \ is needed, but I wasn't sure if that was desirable or not. Your solution is\
    \ better for that case. I think I will fix it now.\n<|/", "\n  all_brackets <-\
    \ unlist(strsplit(brackets, split = ''))\n  lapply(seq_along(all_brackets), \n\
    \         function(x) {\n           if (all_brackets[[x]] == \">\")\n        \
    \     all_brackets[[x + 1] + 1] == \"<\"\n           else\n             all_brackets[[x\
    \ + 1] + 1] == \"<\"\n         })\n  return(lengths(all_brackets) == 0)\n}\n</code>\n\
    <|/ a dscore=3 tags=r,regex |>\n<| c |>\n+1 for the use of unlist().  I was unaware\
    \ of it.\n<|/ c |>\n<| c |>\nThank you for reminding me of the existence of unlist()\
    \ !\n<|/ c |>\n<| a tags=r,regex |>\nThe stringi package provides the stri_replace_all_regex\
    \ function, which allows you to do a global string replacement, by specifying\
    \ a regex as the search pattern.\nFor example, given this vector:\n<code>\nmy_vector\
    \ <- c(\"a < b\",\"c < d\",\"a < b < c < d\")\n</code>\nYou can replace all instances\
    \ of '<' with '>', as follows:\n<code>\nstringi::stri_replace_all_regex(my_vector,\
    \ \"<\", \">\")\n</code>\nResult:\n<code>\n[1] \"a > b\" \"c > d\" \"a > b > c\
    \ > d\"\n</code>\n<|/ a dscore=3 |>\n<| a |>\nThe gsub function in base R will\
    \ do what you need.  The example below replaces double quotes with single quotes.\
    \ \n<code>\nx <- 'a < b\"c'\ngsub('\"','\"',x)\n</code>\n<|/ a tags=r,regex dscore=2\
    \ |>\n<| a tags=r,regex |>\nYou can use str_replace_all from the stringr package.\n\
    <code>\nx <- c(\"a < b\",\"c < d\",\"a < b < c < d\")\n\nstr_replace_all(x, \"\
    <\", \"<\")\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=r,regex |>\nI'm surprised\
    \ that nobody has suggested str_replace().  It worked for me.  Here is an example\
    \ that replaces all <s with >s:\n<code>\nstr_replace(mystr,\"<\",\"<\")\n</code>\n\
    <|/ a |>\n<| a |>\nTry this - \n<code>\nx<-c(\"a < b\",\"c < d\",\"a < b < c <\
    \ d\")\ngsub(\"<\",\">\",x)\n</code>", "\n    for(b in 1:length(brackets)) {\n\
    \        if(brackets[b] == '<') {\n            next # skip the opening bracket\n\
    \        }\n        if(brackets[b] == '>') {\n            next # skip the closing\
    \ bracket\n        }\n        if(!( brackets[b] == '<' || brackets[b] == '>'))\
    \ {\n            return FALSE\n        }\n    }\n    return TRUE\n}\n</cell>\n\
    <text>\n3.5 Exercise: Write a function that will parse a mathematical expression\
    \ into a tree. There are two possible trees given by this function--the tree for\
    \ $x+y$ and the tree for $x^y$--each with one node, $x$ and two children, $x$\
    \ and $y$, respectively. The nodes in the tree are the same as the nodes in the\
    \ infix expression (e.g., letters for $x$ and $y$) and the children of the $x$\
    \ node are the two nodes to the right of the $x$, and to the left of the $y$.\
    \ Write a test function to verify your implementation of this tree and make sure\
    \ it works correctly.\n\n\n</text>\n<cell>", "\n  bracket_position <- which(brackets\
    \ == '<')\n  right_bracket_position <- which(brackets == '>')\n  stopifnot(length(left_bracket_position)\
    \ == length(right_bracket_position))\n  return(TRUE)\n}\n", "\n  opens <- gregexpr('\\\
    \\<', brackets)\n  closes <- gregexpr('\\\\>', brackets)\n  nopens <- length(opens)\n\
    \  ncloses <- length(closes)\n  nopens == ncloses\n}\n", "\n  # Remove whitespace\
    \ from brackets.\n  brackets <- gsub(pattern = \" \", replacement = \"\", brackets)\n\
    \n  sapply(strsplit(brackets, \"<\"), function(x)\n    sum(grepl(\">\", x)) >\
    \ 0\n  )\n}\n", "\n    all(strsplit(brackets, split = \"<>\")[[1]] == \"<\")\n\
    }\n", "\n  \n  # If brackets contains only one character, return FALSE\n  if (length(brackets)\
    \ == 1){\n    \n    # Return FALSE because there must be an opening bracket and\
    \ no\n    # closing bracket\n    return(FALSE)\n  }\n  \n  # If brackets contains\
    \ at least two characters, check whether\n  # the first and last characters match.\n\
    \  # If they do, return TRUE\n  if (length(brackets) > 2){\n    \n    # If the\
    \ first and last characters are the same\n    if (brackets[1] == brackets[2]){\n\
    \      \n      # Return TRUE because brackets contains at least two opening\n\
    \      # brackets\n      return(TRUE)\n    }\n  }\n  \n  # Return FALSE because\
    \ brackets contains only a closing bracket\n  return(FALSE)\n}\n\n", "\n  # make\
    \ sure brackets is a string of \"<\" and \">\".\n  brackets <- gsub(\"[<>]\",\
    \ \"\", brackets)\n\n  all_brackets <- unlist(lapply(strsplit(brackets, \">\"\
    ), function(x) {\n    paste0(paste0(\"<\", x), collapse=\">\")\n  }))\n  all_openings\
    \ <- unlist(lapply(strsplit(brackets, \">\"), function(x) {\n    strsplit(x, \"\
    <\")[[1]][-1]\n  }))\n\n  lapply(all_openings, function(opening) all(brackets\
    \ %in% opening))\n}\n", "\n  # Remove single and double quotes from brackets.\n\
    \  brackets <- gsub('\"', '', brackets)\n  brackets <- gsub(\"'\", \"\", brackets)\n\
    \n  # Keep track of whether each open bracket has a corresponding close bracket.\n\
    \  open <- 0\n  close <- 0\n\n  # Iterate through brackets, keeping track of whether\
    \ a close bracket is open\n  # for each open bracket.\n  for(i in 1:length(brackets))\
    \ {\n    # If the current character is not a close bracket.\n    if(!(brackets[i]\
    \ == \"<\")) {\n      if(brackets[i] == \">\") {\n        close <- close + 1\n\
    \      } else {\n        open <- open + 1\n      }\n    }\n  }\n\n  # Return TRUE\
    \ if every open bracket has a corresponding close bracket.\n  return(TRUE == (open\
    \ == close))\n}\n</code>\n<|/ a dscore=1 tags=r,regex,data.table |>\n<| a tags=r,regex,data.table\
    \ |>\nHere is an attempt using gsub and the qdap package.\n<code>\nlibrary(qdap)\n\
    \ngsub(\"\\\\<+\", \"<\", gsub(\"\\\\>+\", \">\", gsub(\"\\\\+\", \" +\", gsub(\"\
    \\\\>|<\", \n                                                              \"\
    <>\", brackets))))\n", "\n    all_brackets <- gsub('>', '', brackets)\n    all_brackets\
    \ <- gsub('<<', '', all_brackets)\n    all_brackets <- gsub('><', '', all_brackets)\n\
    \    all_brackets <- gsub('>>', '', all_brackets)\n    all_brackets <- gsub('<>',\
    \ '', all_brackets)\n    all_brackets <- gsub('><>', '', all_brackets)\n    all_brackets\
    \ <- gsub('<<<', '', all_brackets)\n    all_brackets <- gsub('>><', '', all_brackets)\n\
    \    all_brackets <- gsub('<><>', '', all_brackets)\n    all_brackets <- gsub('<<><',\
    \ '', all_brackets)\n    all_brackets <- gsub('>>><', '', all_brackets)\n    all_brackets\
    \ <- gsub('<><><', '', all_brackets)\n    all_brackets <- gsub('<<><><', '', all_brackets)\n\
    \    all_brackets <- gsub('>>><><', '', all_brackets)\n    all_brackets <- gsub('<><><><',\
    \ '', all_brackets)\n    all_brackets <- gsub('<<><><><>', '', all_brackets)\n\
    \    all_brackets <- gsub('>>><><><>', '', all_brackets)\n    all_brackets <-\
    \ gsub('<><><><><>', '', all_brackets)\n    all_brackets <- gsub('<<><><><><><>',\
    \ '', all_brackets)\n    all_brackets <- gsub('>>><><><><><>', '', all_brackets)\n\
    \    all_brackets <- gsub('<><><><><><><><>', '', all_brackets)\n    all_brackets\
    \ <- gsub('<<><><><><><><><><>', '', all_brackets)\n    all_brackets <- gsub('>>><><><><><><><><>',\
    \ '', all_brackets)\n    all_brackets <- gsub('<><><><><><><><><><><>', '', all_brackets)\n\
    \    all_brackets <- gsub('", "\n  for(bracket in 1:length(brackets)) {\n    test\
    \ <- brackets[bracket]\n    if(bracketing <- FALSE) {\n      for(subbracket in\
    \ 1:length(test)) {\n        if(test[subbracket] == '<') {\n          bracketing\
    \ <- TRUE\n          break\n        }\n      }\n    }\n    if(bracketing) {\n\
    \      for(subbracket in 1:length(test)) {\n        if(test[subbracket] == '>')\
    \ {\n          break\n        }\n      }\n    } else {\n      return(FALSE)\n\
    \    }\n  }\n  return(TRUE)\n}\n", "\n    \n    for(i in 1:length(brackets)) {\n\
    \        if(brackets[i]=='<') {\n            for(j in i+1:length(brackets)) {\n\
    \                if(brackets[j]=='<') {\n                    next\n          \
    \      }\n            }\n            if(i+1 == length(brackets) && brackets[i]=='<')\
    \ {\n                next\n            }\n            if(i+2 == length(brackets)\
    \ && brackets[i]=='<') {\n                next\n            }\n            return(FALSE)\n\
    \        }\n        if(brackets[i]=='<') {\n            for(j in i+1:length(brackets))\
    \ {\n                if(brackets[j]=='<') {\n                    return(FALSE)\n\
    \                }\n            }\n            return(TRUE)\n        }\n    }\n\
    \    return(TRUE)\n}\n\n", "\n  bracket_pairs <- unlist(strsplit(brackets, \"\
    >\"))\n  # Check that the brackets are of the form \"< >\"\n  all(bracket_pairs\
    \ %in% c(\"<\", \">\"))\n}\n", "\n  i <- 0\n  bracket_count <- 0\n  while(i <\
    \ length(brackets)) {\n    if (brackets[i] == '<') \n      bracket_count<-(bracket_count+1)\n\
    \    if (brackets[i] == '>') {\n      if (bracket_count > 0) {\n        bracket_count<-(bracket_count-1)\n\
    \      } else {\n        bracket_count <- 0\n      }\n    }\n    i <- i+1\n  }\n\
    \  if(bracket_count>0) \n    return(TRUE)\n  else \n    return(FALSE)\n}\n</cell>\n\
    <cell>", "\n  for( i in 1:length(brackets) ) {\n    if( brackets[i] != '<' ) {\n\
    \      return( FALSE )\n    }\n    i <- i+1\n    while(  brackets[i] == '<' )\
    \ {\n      i <- i+1\n    }\n    brackets[i] <- '>'\n  }\n  return( TRUE )\n}\n",
  "\n    brackets.len <- nchar(brackets)\n    bracket_len <- nchar(rep(brackets, each\
    \ = brackets.len))\n    brackets.index <- c(brackets.len, (brackets.len - 1) +\
    \ 1, 0)\n    bracket_index <- c(brackets.len, (brackets.len - 1) + 1, 0)\n   \
    \ brackets.indices <- c(brackets.index, (brackets.len - 1) + 1, 0)\n    bracket_indices\
    \ <- c(bracket_index, (brackets.len - 1) + 1, 0)\n    bracket <- 0\n    for (k\
    \ in bracket_indices) {\n        if (brackets[k] > 0 && !(\n            brackets[k]\
    \ == brackets[brackets[k - 1]] && brackets[k] == brackets[brackets[k + 1]]))\n\
    \            bracket <- k\n    }\n    if (bracket == 0)\n        return(TRUE)\n\
    \    else\n        return(FALSE)\n}\n</code>\nThe above function will test to\
    \ see that the brackets are correctly nested.\n<code>", "\n  all_brackets <- str_split(brackets,\
    \ split = '>')\n  \n  all_brackets <- lapply(all_brackets, function(x) {\n   \
    \ paste0(x, collapse = \">\")\n  })\n  \n  all(sapply(all_brackets, grepl, x =\
    \ brackets, fixed = T))\n}\n", "\n  return(identical(brackets[[1]], brackets[[2]]))\n\
    }\n", "\n  open_brackets <- unlist(strsplit(brackets, \">+\"))\n  close_brackets\
    \ <- unlist(strsplit(brackets, \"<+\"))\n  nchar(brackets) <- nchar(open_brackets)\
    \ * 2 - 1\n  nchar(open_brackets) <- nchar(close_brackets) * 2 - 1\n  return(identical(close_brackets,\
    \ open_brackets))\n}\n</code>\n<|/ a tags=r,regex dscore=2 |>\n<| c |>\nYes, I\
    \ didn't expect such an answer! Thank you very much! It was very helpful.\n<|/\
    \ c |>\n<| a |>\nThe below R function will give you the answer in R language of\
    \ \n<code>\n\"Yes all open brackets are closed and vice versa.\"\n</code>\n<code>\n\
    IsBalanced <- function(brackets) {", "\n  result <- FALSE\n  # loop over each\
    \ opening bracket\n  for (i in seq(length(brackets) - 1)) {\n    bracket <- brackets[i]\n\
    \    opening_bracket <- brackets[i + 1]\n    \n    # if an opening bracket has\
    \ no corresponding closing bracket\n    if (opening_bracket != '') {\n      next_opening\
    \ <- brackets[i + 2]\n      if (next_opening != '') {\n        if (bracket ==\
    \ next_opening) {\n          # if the brackets are properly paired, set result\
    \ to TRUE\n          result <- TRUE\n        }\n      }\n    }\n  }\n  result\n\
    }\n</cell>\n<cell>", "\n  brackets <- unlist(strsplit(brackets, \">\"))\n  for(bracket\
    \ in brackets) {\n    if(!(\"<<><>>\" %in% bracket)) return(FALSE)\n  }\n  return(TRUE)\n\
    }\n</cell>\n<cell>", "\n  # Write your code here\n  correct_brackets <- grepl('^\\\
    \\[', brackets)\n  return(all(correct_brackets))\n}\n</cell>\n<cell>", "\n  brackets\
    \ <- gsub(\"[<>]\", \"\\\\1\", brackets)\n  # print(brackets)\n  for(i in 1:length(brackets)){\n\
    \    if(brackets[[i]] != \"<\"){\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n\
    }\n</cell>\n<cell>", "\n  any(strsplit(brackets, split='<')[[1]][1] == '>')\n\
    }\n", "\n  return(length(which(grepl('<[>', brackets)) == length(which(grepl('[><]',\
    \ brackets))))\n}\n", "\n  # Your code here\n  \n  TRUE\n}\n</cell>\n<text>\n\
    Part 4: Practice with regexes\nIn order to practice using regexes, we're going\
    \ to do a couple of things. First, we need to get the text to parse. We'll be\
    \ getting it from your browser, but you can also do this with a python script\
    \ with urllib or similar.\n\nHere's a little script I wrote to fetch the HTML\
    \ for you:\n\n\n</text>\n<cell>", "\n  opening = strsplit(brackets, '<', fixed\
    \ = TRUE)[[1]][[1]] == \">\"\n  closing = strsplit(brackets, '<', fixed = TRUE)[[1]][[2]]\
    \ == \">\"\n  if(all(opening == closing))\n  {\n    return(TRUE)\n  }\n  else\n\
    \  {\n    return(FALSE)\n  }\n}\n", "\n    matches <- regexpr(\"\\\\<\", brackets)\n\
    \    if(length(matches) < 1) return(FALSE)\n    for(i in matches[-1]) {\n    \
    \    if(!grepl(\"\\\\>\", brackets[i : (i + 2)], fixed = TRUE)) return(FALSE)\n\
    \    }\n    return(TRUE)\n}\n</code>\n<|/ a tags=r,parsing,dataframe,text |>\n\
    <| c |>\nI tested the code in my data and I get the following error `Error in\
    \ strsplit(content, \"\\\\<\") : non-character argument`\n<|/ c |>\n<| c |>\n\
    Try `strsplit(content, \"\\\\<\", fixed = TRUE)` since `content` is of class `character`\n\
    <|/ c |>\n<| c |>\nNow I get this error `Error in grepl(\"\\\\>\", brackets[i\
    \ : (i + 2)], fixed = TRUE) : \n  invalid regular expression '(<', reason 'Missing\
    \ ')''`\n<|/ c |>\n<| c |>\n`Error in strsplit(content, \"\\\\<\") : non-character\
    \ argument` I did this and get this error\n<|/ c |>\n<| c |>\nWhat is `content`?\
    \ Try `dput(head(content))`\n<|/ c |>\n<| a dscore=0 |>\nYou could use the stringi\
    \ package. \n<code>\nlibrary(stringi)\n</code>\nThe str_locate function is used\
    \ to search for locations in a string. \n<code>", "\n  lapply(\n    str_split(brackets,\
    \ '<'),\n    function(x) {\n      length(unique(x)) == 1\n    }\n  )\n}\n", "\n\
    \  openingbrackets <- str_count(brackets, '<') + str_count(brackets, '>')\n  return(openingbrackets\
    \ == length(str_split(brackets, '>')))\n}\n</code>\nThe way you use this is as\
    \ follows: \n<code>\ntest <- c(\"<<><>>\", \"<<><>>>\", \"<><>\")\nprint(correct_bracketing(test))",
  "\n  # Create a vector with TRUE/FALSE based on whether brackets are present\n \
    \ brackets_present <- chartr('()<>', list('()'='(<)', '<>'='(>)'), brackets)\n\
    \  # Return the elements that are TRUE\n  brackets_present[brackets_present]\n\
    }\n</cell>\n<text>\nTest your function:\n\n\n</text>\n<cell>", "\n  brackets <-\
    \ gsub(\"[<\\\\]>]\", \" \", brackets)\n  brackets <- gsub(\"[ ]+\", \" \", brackets)\n\
    \  brackets <- gsub(\"[ ]+$\", \"\", brackets)\n  brackets <- gsub(\"^ *\", \"\
    \", brackets)\n  brackets <- gsub(\" $\", \"\", brackets)\n  brackets <- gsub(\"\
    \ *$\", \"\", brackets)\n  return(brackets == \"<\")\n}\n</code>\n<|/ a dscore=2\
    \ tags=regex,python |>\n<| c |>\nThis looks good! I didn't know `re` could be\
    \ used this way. I was also unaware of `re.sub` could be used this way. Thanks\
    \ for the help!\n<|/ c |>\n<| c |>\nThis doesn't work for me in the way I expect\
    \ it to. For example, `'<->'` should match to `'<->'`, but instead it matches\
    \ to `'<-<->'`. My code works for the most part, but I'll keep digging.\n<|/ c\
    \ |>\n<| c |>\n, I see that my code doesn't work correctly. I've updated the answer\
    \ to fix this.\n<|/ c |>\n<| c |>\nThank you! I appreciate the help! I'm marking\
    \ this as the answer since it works well enough and I didn't see any more stray\
    \ edge cases.\n<|/ c |>\n<| a tags=regex,python |>\nYou don't need a regex, just\
    \ a simple string manipulation.\n<code>\ndef check_brackets(brackets):\n    open\
    \ = '<'\n    close = '>'\n    if open not in brackets:\n        return False\n\
    \    if close not in brackets:\n        return True\n    open_index = brackets.index(open)\n\
    \    close_index = brackets.index(close)\n    if open_index < close_index:\n \
    \       return True\n    return False\n\nprint(check_brackets('<<>>'))\nprint(check_brackets('<>'))\n\
    print(check_brackets('<><>'))\nprint(check_brackets('<><><>'))\nprint(check_brackets('<><>'))\n\
    print(check_brackets('<><><><><><><><><><><><><><>'))\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nTry this.\n<code>\nimport re\npattern = re.compile(\"\
    ^<->$\")\nresult = pattern.search('<<><>>')\nprint result\n</code>\n<|/ a tags=regex,python\
    \ |>\n<| ", "\n  all(brackets %in% c(\"<\", \">\"))\n}\n</code>\n(In your comments\
    \ you say you only want to check whether an opening bracket has a corresponding\
    \ closing bracket. I'll assume you don't really care which one. That's what I've\
    \ done here: I just made up a rule where if the second opening bracket is immediately\
    \ after the first closing bracket, then the brackets are correct in the sense\
    \ that they're balanced.)\n<|/ a tags=r,regex,string |>\n<| c |>\nThank you so\
    \ much for this solution and thank you for being so thorough. However I don't\
    \ want to check that all the brackets are correct. I just want to check if there\
    \ is a closing bracket before a new opening bracket. If there is a new opening\
    \ bracket, I just want to check that there is not already a closing bracket. This\
    \ is why I only want to check that the closing brackets are after the opening\
    \ brackets. Apologies if that wasn't clear in my initial description. Does that\
    \ make sense?\n<|/ c |>\n<| c |>\nIt does but it's too late for me to edit my\
    \ answer. I'll edit it to explain this better.\n<|/ c |>\n<| c |>\nOkay, thank\
    \ you! So basically, the main difference between your answer and mine is that\
    \ your solution doesn't check that the closing brackets are after the opening\
    \ brackets whereas mine does. Is that correct?\n<|/ c |>\n<| c |>\nYes, I suppose\
    \ so. My code assumes that there can be no \"unbalanced\" opening brackets at\
    \ all (i.e. that there can be no opening brackets followed by any number of closed\
    \ brackets, each followed by a single closing bracket, etc). Yours doesn't check\
    \ that, but my code would. I'll edit my answer to show what I mean.\n<|/ c |>\n\
    <| c |>\nOkay, thank you. I am going to have to do some reading on regular expressions\
    \ so I can understand how this works. But thank you so much for this!\n<|/ c |>\n\
    <| a dscore=1 tags=r,regex,string |>\nUsing your example strings:\n<code>\nx <-\
    \ c('<<><>>', '><<>', '<>><<>>')\n</code>\nFirst, let's create a function that\
    \ will return the number of open and close brackets within a string:\n<code>\n\
    count_brackets <- function(x) {\n  open <- 0\n  close <- 0\n  for (i in seq_along(x))\
    \ {\n    if (x[i] == '<') {\n      open <- open + 1\n    } else if (x[i] == '>')\
    \ {\n      close <- close + 1\n    } else if (x[i] == '') {\n      close <- close\
    \ + 1", "\n  all(str_split(brackets, \"<\") == str_split(brackets, \">\"))\n}\n\
    \n", "\n  bracket_count <- 0\n  bracket_open <- 1\n  bracket_close = 0\n  for\
    \ (i in 1:nchar(brackets)) {\n    if (brackets[i] != '<') {\n      bracket_count\n\
    \    } else {\n      bracket_open <- bracket_open * bracket_count + 1\n      bracket_close\
    \ <- bracket_close * bracket_count + 1\n      bracket_count <- 0\n    }\n  }\n\
    \  bracket_close\n}\n", "\n  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n  brackets\
    \ <- gsub(\"[>]\", \"[>]\", brackets)\n  brackets <- gsub(\"[<>]\", \"[<>]\",\
    \ brackets)\n  brackets <- gsub(\"[>>]\", \"[>]\", brackets)\n  brackets <- gsub(\"\
    [<<]\", \"[<]\", brackets)\n  brackets <- gsub(\"[<<>]\", \"[<]\", brackets)\n\
    \  brackets <- gsub(\"[<>]\", \"[>]\", brackets)\n  brackets <- gsub(\"[<>]\"\
    , \"[>]\", brackets)\n  brackets <- gsub(\"[>>]\", \"[>]\", brackets)\n  brackets\
    \ <- gsub(\"[<<]\", \"[<]\", brackets)\n  brackets <- gsub(\"[<<>]\", \"[<]\"\
    , brackets)\n  brackets <- gsub(\"[<<>]\", \"[<]\", brackets)\n  brackets <- gsub(\"\
    [<]\", \"[<]\", brackets)\n  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n  brackets\
    \ <- gsub(\"[<]\", \"[<]\", brackets)\n  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n\
    \  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n  brackets <- gsub(\"[<]\", \"\
    [<]\", brackets)\n  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n  brackets <-\
    \ gsub(\"[<]\", \"[<]\", brackets)\n  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n\
    \  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n  brackets <- gsub(\"[<]\", \"\
    [<]\", brackets)\n  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n  brackets <-\
    \ gsub(\"[<]\", \"[<]\", brackets)\n  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n\
    \  brackets <- gsub(\"[<]\", \"[<]\", brackets)\n  brackets <- gsub(\"[<]\", \"\
    [<]\", brackets)\n  brackets <- ", "\n  brackets <- gsub(\"([<>])\", \"\\\\\\\\\
    \\\\1\", brackets) # escape brackets\n  brackets <- gsub(\"\\\\<\", \"<\", brackets)\
    \ # replace \"<\" with \"<\"\n  brackets <- gsub(\"\\\\>\", \">\", brackets) #\
    \ replace \">\" with \">\"\n  brackets <- gsub(\"^<\", \"<\", brackets) # replace\
    \ \"<\" with \"<\"\n  brackets <- gsub(\"^>$\", \">\", brackets) # replace \"\
    >\" with \">\"\n  return(brackets == brackets)\n}\n</cell>\n<text>\nExercise:\
    \ Write a function called correct_parentheses that, given a vector of strings\
    \ called parentheses, returns a logical vector with the same length as parentheses\
    \ indicating whether the parentheses string is correct or not.\n\nHint: For this\
    \ exercise, you'll need to use sapply and grepl. You'll need to use gsub to replace\
    \ < and >. You'll need to use brackets == brackets.\n\nIf it helps, try typing\
    \ ?sapply in the R console and ?grepl into the console.\n\n\n</text>\n<cell>",
  "\n    for(i in 1:length(brackets)) {\n        if (brackets[i] != '<') return FALSE\n\
    \        else if ((brackets[i] == '<') & (brackets[i+1] == '>'))\n           \
    \ return FALSE\n        else if ((brackets[i] == '>') & (brackets[i+1] == '<'))\n\
    \            return FALSE\n    }\n    if (brackets[length(brackets)] != '>') return\
    \ FALSE\n    return(TRUE)\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is what\
    \ I ended up doing. Thanks!\n<|/ c |>\n<| a dscore=0 |>\nHere's a way using stringi::stri_locate_all_regex:\n\
    <code>\nstr <- '<<>><<><>><<><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><>><<><><",
  "\n    lapply(\n        strsplit(\n            brackets,\n            split = \"\
    >\"\n        ),\n        function(x) {\n            lapply(\n                strsplit(\n\
    \                    x,\n                    split = '<'\n                ),\n\
    \                function(y) {\n                    sum(grepl(paste0('<', y),\
    \ x)) > 0\n                }\n            )\n        }\n    )\n}\n", "\n  is_closed\
    \ <- unlist(strsplit(brackets, \">\"))\n  is_open <- unlist(strsplit(brackets,\
    \ \"<\"))\n  is_closed <- is_closed[which(is_closed != \"\")]\n  is_open <- is_open[which(is_open\
    \ != \"\")]\n  length(is_closed) == length(is_open)\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI liked the idea of breaking the input string into single characters and\
    \ comparing them with the other string. Although it wasn't the exact solution,\
    \ its the closest to what I had in mind when I asked the question.\n<|/ c |>\n\
    <| c |>\nThis is exactly what I was thinking of when I asked the question. I am\
    \ very impressed with your answer and the time complexity! Thanks a lot for providing\
    \ the solution!\n<|/ c |>\n<| c |>\nI agree with the first commenter's suggestion\
    \ that OP should be looking for regexp solutions rather than brute force string\
    \ comparison. While I agree that your solution works fine, I don't think it scales\
    \ well - for example, your solution fails when brackets are reversed. On the other\
    \ hand, I don't know a good solution to handle a variable number of brackets without\
    \ a recursive solution. Maybe someone else has a good solution.\n<|/ c |>\n<|\
    \ c |>\nI don't see how it fails when the brackets are reversed. The result of\
    \ `is_closed <- is_closed[which(is_closed != \"\")]` should be the same whether\
    \ it's `\"<\"` or `\">\"`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I'm\
    \ surprised I wasn't getting an error when reversing the brackets. My apologies.\n\
    <|/ c |>\n<| a dscore=2 |>\nSince your brackets are always paired you can also\
    \ use regular expression to match the brackets individually. Also you can remove\
    \ unnecessary characters from string before using regexp because they are useless\
    \ here. You also don't need to convert string to vector here, you can also use\
    \ match instead. Finally, you don't need to use loop for this task anymore:\n\
    <code>\ncorrect_bracketing <- function(brackets) {\n  brackets <- gsub(\"^>\"\
    , \"\", brackets)\n  brackets <- gsub(\"<\", \"\", brackets)\n  brackets <- gsub(\"\
    ^<\", \"\", brackets)\n  brackets <- gsub(\"\\\\(|\\\\)\", \"\", brackets)\n\n\
    \  paste(grepl(\"(.*)(\\\\1)\", brackets), collapse = \"|\")\n}\n\ncorrect_bracketing(\"\
    <>\")", "\n  brackets <- gsub(\"</?\", \"\", gsub(\"\\\\[\", \"\", brackets))\n\
    \  gsub(\"\\\\[\", \"\", brackets)\n  gsub(\"\\\\]\", \"\", brackets)\n  gsub(\"\
    </?\", \"\", gsub(\"\\\\>\", \"\", brackets))\n  gsub(\"\\\\>\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\>\", \"\", brackets)\n  brackets <- gsub(\"\\\\<\",\
    \ \"\", brackets)\n  brackets <- gsub(\"\\\\<\", \"\", brackets)\n  brackets <-\
    \ gsub(\"\\\\]\", \"\", brackets)\n  brackets <- gsub(\"\\\\]\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\<\", \"\", brackets)\n  brackets <- gsub(\"\\\\<\",\
    \ \"\", brackets)\n  brackets <- gsub(\"\\\\>\", \"\", brackets)\n  brackets <-\
    \ gsub(\"\\\\>\", \"\", brackets)\n  brackets <- gsub(\"\\\\>\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\<\", \"\", brackets)\n  brackets <- gsub(\"\\\\<\",\
    \ \"\", brackets)\n  brackets <- gsub(\"\\\\>\", \"\", brackets)\n  brackets <-\
    \ gsub(\"\\\\>\", \"\", brackets)\n  brackets <- gsub(\"\\\\<\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\<\", \"\", brackets)\n  brackets <- gsub(\"\\\\>\",\
    \ \"\", brackets)\n  brackets <- gsub(\"\\\\>\", \"\", brackets)\n  brackets <-\
    \ gsub(\"\\\\<\", \"\", brackets)\n  brackets <- gsub(\"\\\\<\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\]\", \"\", brackets)\n  brackets <- gsub(\"\\\\]\",\
    \ \"\", brackets)\n  brackets <- gsub(\"\\\\<\", \"\", brackets)\n  brackets <-\
    \ gsub(\"\\\\<\", \"\", brackets)\n  brackets <- gsub(\"\\\\>\", \"\", brackets)\n\
    \  brackets <- gsub(\"\\\\>\", \"\", brackets)\n  brackets <- gsub(\"\\\\<\",\
    \ \"\", brackets)\n  brackets <- gsub(\"\\\\<\", \"\", brackets)\n  brackets <-\
    \ gsub(\"\\\\>\", \"\", brackets)", "\n  brackets <- gsub(\"[<>]\", \"\", brackets)\n\
    \  opens <- brackets[1L]\n  closes <- brackets[2L]\n  return (lengths(strsplit(opens,\
    \ \"<\")) == length(opens) &&\n         lengths(strsplit(closes, \">\")) == length(closes))\n\
    }\n", "\n  len <- length(brackets)\n  sapply(1:len, function(i) {\n    substr(brackets,\
    \ i, i) == \"<\" &\n      substr(brackets, i + 1, i + 1) == \">\"\n  })\n}\n",
  "\n  if (length(brackets) == 0) return FALSE\n  brackets <- gsub(\"^<<>$\", \"\"\
    , brackets)\n  brackets <- gsub(\"^<$\", \"\", brackets)\n  brackets <- gsub(\"\
    ^>$\", \"\", brackets)\n  brackets <- gsub(\"^<>$\", \"\", brackets)\n  return(length(brackets)\
    \ == 0)\n}\n</cell>\n<text>\nTask 1: Implement the get_text function.\nWrite a\
    \ function that takes a string and returns its text content. You must not modify\
    \ the string.\nFor example get_text(' Hello World!') should return ' Hello World!'.\n\
    Hint: You may want to use str_replace with stringr or stringi\n\n\n</text>\n<cell>\n\
    get_text <- function(string) {\n  return(paste(str_replace_all(string, \">\",\
    \ \"\"), collapse=\"\"))\n}\n</cell>\n<text>\nTask 2: Implement the count_brackets\
    \ function.\nWrite a function that takes a string and returns how many times the\
    \ opening bracket \"<\" appears in the string. \nFor example count_brackets('<Hello\
    \ World!>') should return 2.\nHint: You may want to use str_replace with stringr\
    \ or stringi\n\n\n</text>\n<cell>\ncount_brackets <- function(string) {\n  return(str_replace_all(string,\
    \ \"<\", \"\"))\n}\n</cell>\n<text>\nTask 3: Implement the count_tags function.\n\
    Write a function that takes a string and returns how many times each of the tags\
    \ appear in the string. \nFor example count_tags('Hello World!') should return\
    \ '<Hello>' -> 2 times, '<World!>' -> 1 time. \nHint: You may want to use str_replace\
    \ with stringr or stringi\n\n\n</text>\n<cell>\ncount_tags <- function(string)\
    \ {\n  return(str_replace_all(string, \"<\", \"\"))\n}\n</cell>\n<text>\nTask\
    \ 4: Implement the count_words function.\nWrite a function that takes a string\
    \ and returns how many times each word appears in the string.\nFor example count_words('Hello\
    \ World!') should return 'Hello' -> 2 times, 'World' -> 1 time. \nHint: You may\
    \ want to use str_replace with stringr or stringi\n\n\n</text>\n<cell>\ncount_words\
    \ <- function(string) {\n  return(str_replace_all(string, \"[^a-zA-Z ]\", \" \"\
    ))\n}\n</cell>\n<text>\nTask 5: Implement the count_tags function.\nWrite a function\
    \ that takes a string and returns how many times each of the tags appear in the\
    \ string. \nFor example count_tags('Hello World!", "\n  open_count <- 0\n  close_count\
    \ <- 0\n  i <- 0\n  j <- 0\n  for (i in seq_along(brackets)) {\n    char <- brackets[i]\n\
    \    if (char == '<') {\n      open_count <- open_count + 1\n    } else if (char\
    \ == '>') {\n      close_count <- close_count + 1\n    }\n  }\n\n  return(open_count\
    \ == close_count)\n}\n\n", "\n  return(length(brackets)==0 |\n          length(brackets)==1\
    \     && brackets[1]=='>'     && brackets[2]=='<')\n}\n\n", "\n  correct_bracket\
    \ <- function(x) {\n    i <- which(x %in% '<>')\n    if (length(i) == 0) return(FALSE)\n\
    \    if (length(i) == 1) return(TRUE)\n    if (length(i) > 1) return(FALSE)\n\
    \    return(TRUE)\n  }\n  bracket_count <- 0\n  bracket_end <- length(brackets)\n\
    \  for (bracket, count) in strsplit(brackets, '<>') {\n    if (count == 1 && !correct_bracket(bracket))\
    \ return(FALSE)\n    if (count == 2 && correct_bracket(bracket)) bracket_count\
    \ <- bracket_count + 1\n    bracket_end <- which(brackets %in% '<>', bracket_end)\n\
    \  }\n  return(TRUE)\n}\n", "\n  # This function takes as its input a bracket\
    \ string,\n  # and returns TRUE (if every opening bracket has a corresponding\
    \ closing bracket)\n  # or FALSE (otherwise).\n  # This function is a short circuit\
    \ for the check_bracket() function,\n  # so it may be more efficient to not call\
    \ it.\n  check_bracket(brackets)\n}\n", "\n  stack <- stringr::str_split(brackets,\
    \ '[<>]', 1)[[1]]\n  lengths(stack) != 0\n}\n</cell>\n<cell>", "\n  brackets <-\
    \ paste0('\\\\<', brackets)\n  bracket_pattern <- paste(brackets, collapse = '|')\n\
    \  return(grepl(bracket_pattern, paste(brackets, collapse = '|'), fixed = TRUE))\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a |>\nYou can try with str_detect from stringr\n\
    <code>\nlibrary(stringr)\n\npattern <- '[<>]+'\ndf$new <- ifelse(str_detect(df$str,\
    \ pattern), TRUE, FALSE)\n</code>\nsuch that\n<code>\n> df\n   str  new\n1 <A>\
    \ <NA>\n2 <A> <NA>\n3 <B> <NA>\n4 <A> <NA>\n5 <C> <NA>\n</code>\n<|/ a tags=r,string\
    \ dscore=1 |>\n<| a tags=r,string dscore=1 |>\nWith base R:\n<code>\ndf$new <-\
    \ c(NA,1) * (df$str == \"<\")\n</code>\nor\n<code>\ndf$new <- c(NA,1) * (!grepl(\"\
    </\",df$str))\n</code>\n<|/ a |>\n<| a tags=r,string |>\nThis can be done with\
    \ str_detect().  \n<code>\nlibrary(stringr)\n\ndf$new <- ifelse(str_detect(df$str,\
    \ \"<\"), TRUE, FALSE)\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,string |>\n<code>\n\
    library(dplyr)\nlibrary(stringr)\n\ndf <- data.frame(str = c(\"<>\", \"<A\", \"\
    <B\", \"<>\", \"<>\"), stringsAsFactors = F)\n\ndf %>%\n  mutate(new = ifelse(str_detect(str,\
    \ \"<\"), \"<\", \">\")) %>%\n  mutate(new = ifelse(is.na(new), \"<>\", new))\n\
    \n   str  new\n1 <A> <NA>\n2 <A> <NA>\n3 <B> <NA>\n4 <A> <NA>\n5 <C> <NA>\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>\nmydf = data.frame(str=c(\"<A>\", \"<A>\",\
    \ \"<B>\", \"<A>\", \"<C>\"))\n\nmydf$new = ifelse(grepl(\"<\", mydf$str), \"\
    <\", \">\")\nmydf$new = ifelse(is.na(mydf$new), \"<>\", mydf$new)\n</code>\n<|/",
  "\n  return(\n    all(\n      unlist(strsplit(brackets, \"<\"))\n      == unlist(strsplit(brackets,\
    \ \">\"))\n    )\n  )\n}\n</cell>\n<text>\nTask\nDefine a function check_for_parentheses(brackets)\
    \ that takes in a string argument and returns a logical: True if brackets are\
    \ properly paired, False otherwise. Your function should NOT include any if statements.\
    \ You can test your function using the following code:\n\n\n</text>\n<cell>\n\
    check_for_parentheses <- function(brackets) {\n  # The purpose of this function\
    \ is to determine if brackets are properly paired, \n  # meaning that they contain\
    \ an equal number of opening and closing brackets. \n  # The input to this function\
    \ is an open bracket (\"<\") and a closed bracket (\">\").\n  # Return TRUE if\
    \ brackets are properly paired, FALSE otherwise. \n  \n  # Your function should\
    \ NOT include any if statements.\n  \n  # Define your code here\n  \n}\n</cell>\n\
    <cell>", "\n  opening_brackets <- gregexpr(\"<\", brackets)\n  closing_brackets\
    \ <- gregexpr(\">\", brackets)\n  brackets <- gregexpr(\"[<>]\", brackets)\n \
    \ return(length(opening_brackets) == length(closing_brackets) & length(opening_brackets)\
    \ == length(brackets))\n}\n", "\n    length(brackets) <- length(brackets)\n  \
    \  sum(str_detect(brackets, \">>\")) == sum(str_detect(brackets, \"<\"))\n}\n\
    </code>\nHere's a version using regular expressions:\n<code>", "\n  return(\n\
    \    all(\n      grepl(\"([<]\\\\^\\\\^>[>])\", brackets, perl=TRUE)\n    )\n\
    \  )\n}\n\n", "\n    brackets <- gsub(\"\\\\>\", \"\", paste(brackets, collapse\
    \ = \">\"))\n    brackets <- gsub(\"\\\\<\", \"\", paste(brackets, collapse =\
    \ \"<\"))\n    brackets <- gsub(\"^<\", \"\", paste(brackets, collapse = \"<\"\
    ))\n    brackets <- gsub(\"<$\", \"\", paste(brackets, collapse = \"<\"))\n  \
    \  brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n   \
    \ brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n    brackets\
    \ <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n    brackets <-\
    \ gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n    brackets <- gsub(\"\
    \\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n    brackets <- gsub(\"\\\\\
    >$\", \"\", paste(brackets, collapse = \"<\"))\n    brackets <- gsub(\"\\\\>$\"\
    , \"\", paste(brackets, collapse = \"<\"))\n    brackets <- gsub(\"\\\\>$\", \"\
    \", paste(brackets, collapse = \"<\"))\n    brackets <- gsub(\"\\\\>$\", \"\"\
    , paste(brackets, collapse = \"<\"))\n    brackets <- gsub(\"\\\\>$\", \"\", paste(brackets,\
    \ collapse = \"<\"))\n    brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse\
    \ = \"<\"))\n    brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse =\
    \ \"<\"))\n    brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"\
    <\"))\n    brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"\
    ))\n    brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n\
    \    brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n \
    \   brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n  \
    \  brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n   \
    \ brackets <- gsub(\"\\\\>$\", \"\", paste(brackets, collapse = \"<\"))\n    brackets\
    \ <- gsub(\"\\\\>$", "\n  # This could be done faster by using mapply instead\
    \ of splitting and matching.\n  bracket_opens <- str_split(brackets, \">>\")[[1]]\n\
    \  bracket_closes <- str_split(brackets, \"<<\")[[1]]\n  bracket_opens_count <-\
    \ lengths(bracket_opens)\n  bracket_closes_count <- lengths(bracket_closes)\n\
    \  return(\n    all(bracket_opens_count == bracket_closes_count)\n  )\n}\n", "\n\
    \  return(TRUE)\n}\n", "\n  return(!grepl(\"<|>\", brackets))\n}\n\n", "\n  all_brackets\
    \ <- strsplit(brackets, split=\"<>\")[[1]]\n  is_correct_bracket <- sapply(all_brackets,\
    \ FUN=function(b) {\n    if(b == \"<\") {\n      grepl(\"<\", brackets)\n    }\
    \ else {\n      grepl(\">\", brackets)\n    }\n  })\n  all(is_correct_bracket)\n\
    }\n", "\n    # Your code here.\n    return(TRUE)\n}\n</code>\n<|/ a tags=r,regex,python,string\
    \ |>\n<| c |>\nThis fails for `'><<><>><'`.\n<|/ c |>\n<| c |>\n: yes, you're\
    \ right, it fails. Thanks. I have added a corrected version now.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work for `'a><<<b>>><a>'`. It passes the first test because\
    \ you added a closing bracket to the wrong position.\n<|/ c |>\n<| c |>\n: thanks.\
    \ Now I believe it is the correct solution.\n<|/ c |>\n<| c |>\n: your solution\
    \ still fails for `'a><<<b>>><a>'`. It fails because you added a closing bracket\
    \ to the wrong position. The correct solution is `'a><<<b>>><a>'`\n<|/ c |>\n\
    <| a dscore=3 |>\nThe simplest solution I can think of is something like this\
    \ in python:\n<code>\ndef check_match(s, m):\n    return (s.count(m) - s.count(m[:-1]))\
    \ % 2 == 0\n</code>\nIn other words, match m if there is a match, otherwise not\
    \ match.\n<|/ a tags=r,regex,python,string |>\n<| c |>\nI like this. I wonder\
    \ if there is a way to make it work for any character instead of just `'m'`. My\
    \ solution of `'[<>]'` works for `'<<><>>'` but fails for `'><<><>><'`.\n<|/ c\
    \ |>\n<| c |>\n: Yes, it works, I just tested it with `'<<><>><'` and it worked\
    \ fine. The OP did not specify what should happen if it is a single character.\n\
    <|/ c |>\n<| c |>\nSorry, I see now that your solution works in that case. I'm\
    \ confused why it didn't work for the OP.\n<|/ c |>\n<| a dscore=3 tags=r,regex,python,string\
    \ |>\nHow about this in R?\n<code>\ngrepl('>+<', str1)\n[1] FALSE  TRUE FALSE\
    \  TRUE FALSE\n</code>\n<|/ a |>\n<| c |>\n: Thanks. Can you explain why that\
    \ is?\n<|/ c |>\n<| c |>\n`>` matches any character that is greater than zero\
    \ times. `+` means match one or more. The `<` means match the characters `<` literally.\
    \ So, the ", "\n  brackets <- gsub('^[<>]+|[<>]+$', '', brackets)\n  brackets\
    \ <- gsub('>', '', brackets)\n  brackets <- gsub('<', '', brackets)\n  return(brackets\
    \ == '')\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is a simple solution\
    \ that works with regular expressions.\n<code>\nf <- function(s) {\n    s <- gsub('(^|[<>])',\
    \ '', s)\n    s <- gsub('(?<=^|[<>])(>|<)', '\\\\1', s)\n    s <- gsub('(?<=^|[<>])(<|>)',\
    \ '\\\\1', s)\n    return(s != '')\n}\n\nf(\">>>\")", "\n  # Count how many brackets\
    \ we have seen.\n  n_brackets <- nchar(brackets)\n  # Make sure there are no extra\
    \ brackets.\n  n_brackets <- nchar(brackets) - nchar(gsub(\"[<>]\", \"\", brackets))\n\
    \  # If we have an even number of brackets, return TRUE because\n  # we are probably\
    \ missing some closing brackets.\n  # Otherwise, return FALSE.\n  return (length(brackets)\
    \ == n_brackets %% 2)\n}\n\n", "\n  # The brackets are a list of character strings\n\
    \  # so go through the brackets and check if each opening bracket\n  # has corresponding\
    \ closing bracket.\n  is_right <- FALSE\n  left_bracket_idx <- 1\n  right_bracket_idx\
    \ <- 1\n  for (bracket in brackets) {\n    # check if opening bracket is correct\n\
    \    left_bracket = bracket[left_bracket_idx]\n    if (left_bracket != \">\" &&\
    \ left_bracket != \"<\") {\n      print(paste0(\"Error in bracketing: \", left_bracket))\n\
    \    }\n    # check if closing bracket is correct\n    right_bracket = bracket[right_bracket_idx]\n\
    \    if (right_bracket != \"<\" && right_bracket != \">\") {\n      print(paste0(\"\
    Error in bracketing: \", right_bracket))\n    }\n    # check if closing bracket\
    \ is correct\n    if ((left_bracket == \">\" & right_bracket == \"<\") |\n   \
    \     (left_bracket == \"<\" & right_bracket == \"<\")) {\n      is_right <- TRUE\n\
    \    }\n    left_bracket_idx <- left_bracket_idx + 1\n    right_bracket_idx <-\
    \ right_bracket_idx + 1\n  }\n  return(is_right)\n}\n", "\n    brackets <- stringr::str_replace_all(brackets,\
    \ '<', '')\n    brackets <- stringr::str_replace_all(brackets, '>', '')\n    brackets\
    \ <- stringr::str_replace_all(brackets, '*', '')\n    brackets <- stringr::str_replace_all(brackets,\
    \ '-', '')\n    brackets <- stringr::str_replace_all(brackets, ':', '')\n    brackets\
    \ <- stringr::str_replace_all(brackets, '^', '')\n    brackets <- stringr::str_replace_all(brackets,\
    \ '?', '')\n    brackets <- stringr::str_replace_all(brackets, '*', '')\n    brackets\
    \ <- stringr::str_replace_all(brackets, '+', '')\n    brackets <- stringr::str_replace_all(brackets,\
    \ '|', '')\n    brackets <- stringr::str_replace_all(brackets, '(', '')\n    brackets\
    \ <- stringr::str_replace_all(brackets, ')', '')\n    brackets <- stringr::str_replace_all(brackets,\
    \ '[', '')\n    brackets <- stringr::str_replace_all(brackets, ']', '')\n    brackets\
    \ <- stringr::str_replace_all(brackets, '{', '')\n    brackets <- stringr::str_replace_all(brackets,\
    \ '}', '')\n    brackets <- stringr::str_replace_all(brackets, ',', '')\n    brackets\
    \ <- stringr::str_replace_all(brackets, '/', '')\n    brackets <- stringr::str_replace_all(brackets,\
    \ '[', '')\n    brackets <- stringr::str_replace_all(brackets, ']', '')\n    brackets\
    \ <- stringr::str_replace_all(brackets, '{', '')\n    brackets <- stringr::str_replace_all(brackets,\
    \ '}', '')\n    brackets <- stringr::str_replace_all(brackets, ':', '')\n    brackets\
    \ <- stringr::str_replace_all(brackets, '^', '')\n    brackets <- stringr::str_replace_all(brackets,\
    \ '?', '')\n    brackets <- stringr::str_replace_all(brackets, '*', '')\n    brackets\
    \ <- stringr::str_replace_all(brackets, '+', '')\n    brackets <- stringr::str_replace_all(brackets,\
    \ '|', '')\n    brackets <- stringr::", "\n  return(!(nchar(paste(brackets, nchar(brackets)-1,\
    \ sep = '')) == 0))\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is great, thank\
    \ you. I added this as a function since I use it often in my code.\n<|/ c |>\n\
    <| c |>\nI added `!nchar(paste(brackets, nchar(brackets)-1, sep = ''))` to the\
    \ code so that it is complete now.\n<|/ c |>\n<| a dscore=3 |>\nHere's a way in\
    \ R base that uses the regex library to extract the pattern:\n<code>\nmystring\
    \ = \"<><><><<>\"\n\nlibrary(regex)\nstr_extract(mystring, \"(<)+\")\n[1] \"<><><<>\"\
    \n</code>\nThis works because of the nature of regex (the + quantifier matches\
    \ between one and unlimited times). \nMore generally, if your brackets come in\
    \ any shape or form, you could use the following regex that matches any number\
    \ of repeated characters that are not brackets:\n<code>\nstr_extract(mystring,\
    \ \"[^<]*\")\n</code>\n<|/ a tags=r,stringr,regex |>\n<| c |>\nThis is great and\
    \ also helped me to understand what is happening. Thank you.\n<|/ c |>\n<| a tags=r,stringr,regex\
    \ |>\nI came up with this solution:\n<code>\nlibrary(stringr)\n", "\n  matches\
    \ <- gregexpr('<', brackets)\n  return(length(matches) > 0)\n}\n", "\n  bracket\
    \ <- sapply(strsplit(brackets, \">>\"), `[`, 1)\n  unlist(lapply(strsplit(brackets,\
    \ \">>\"), `[`, 2))\n  is.atomic(bracket)\n}\n", "\n  \n  # The bracketing rules\
    \ are simply\n  # 1) All opening brackets must have the same number of closing\
    \ brackets.\n  # 2) Each opening bracket must have a corresponding closing bracket.\n\
    \  # 3) For a number of opening brackets, there must be the same number of closing\
    \ brackets.\n  # 4) For a number of closing brackets, there must be the same number\
    \ of opening brackets.\n  # \n  # For an even number of brackets, we have one\
    \ closing and one opening.\n  # For an odd number of brackets, we have one closing\
    \ and one opening.\n  # \n  # For even number of brackets, there is one additional\
    \ opening bracket than closing bracket.\n  # For an odd number of brackets, there\
    \ is one additional opening bracket than closing bracket.\n  # \n  # For all brackets,\
    \ the number of opening brackets must be the same as the number of closing brackets.\n\
    \  # \n  # If we have an odd number of brackets and no closing brackets, we have\
    \ an extra closing bracket.\n  # If we have an even number of brackets and no\
    \ closing brackets, we have an extra opening bracket.\n  # \n  # If we have an\
    \ extra closing bracket than opening bracket, we have an extra closing bracket.\n\
    \  # If we have an extra opening bracket than closing bracket, we have an extra\
    \ opening bracket.\n  \n  # The basic rules for bracketing are as follows:\n \
    \ # 1) If we have an odd number of brackets, we need to add an extra opening bracket.\n\
    \  # 2) If we have an even number of brackets, we need to add an extra closing\
    \ bracket.\n  # 3) If we have an extra closing bracket than opening bracket, we\
    \ have an extra closing bracket.\n  # 4) If we have an extra opening bracket than\
    \ closing bracket, we have an extra opening bracket.\n  # \n  # For instance:\n\
    \  # <[<[]> is <[[<\n  # [[[<[> is <[[[<\n  # <[[<[>]] is <[[<[>\n  # [[[<[>]]]\
    \ is <[[<[>]\n  # <[<<<>> is <[[<[>]\n  # [[<<<>>] is <[[<[>]\n  # <[<<<>>] is\
    \ <[[<[>]\n  # <[<<<>>] is <[[<[>]\n  # [[<<<>>]] are <[[<[>]]\n  # [[[<[>]]]\
    \ are <[[<[>]] \n  # <[<<<]> are <[[<[>]] \n  # [[<<<]] are <[[<[>]] \n  # <[<<<]>\
    \ are <[[<[>]] \n", "\n    brackets <- gsub(\"<\", \"\", gsub(\"\\\\>\", \"\"\
    , brackets))\n    brackets <- gsub(\"\\\\<\", \"\", brackets)\n    brackets <-\
    \ gsub(\"\\\\>\", \"\", brackets)\n    paste0(\"^(\", paste0(brackets, collapse\
    \ = \"|\"), \")$\")\n}\n", "\n  \n  # Initialize a variable that is the length\
    \ of the input string.\n  len = length(brackets)\n  \n  # If the length of the\
    \ input string is zero, return FALSE.\n  if (len == 0) {\n    return(FALSE)\n\
    \  }\n  \n  # Initialize a variable that will hold our current state (0 or 1).\n\
    \  state = -1\n  \n  # Initialize a variable that holds the value of the current\
    \ opening bracket.\n  open_bracket = -1\n  \n  # Initialize a variable that will\
    \ hold the value of the current closing bracket.\n  close_bracket = -1\n  \n \
    \ # Initialize a variable that will hold our current character index.\n  index_in_string\
    \ = 0\n  \n  # Loop through the input string and compare each character with each\
    \ other\n  # to determine if they should be considered adjacent or not.\n  \n\
    \  # While we haven't reached the end of the input string:\n  while (index_in_string\
    \ <= len - 1) {\n    \n    # Read the current character from the input string.\n\
    \    current_character = brackets[index_in_string]\n    \n    # If we are at the\
    \ very beginning of the string, start our loop at the\n    # beginning again (increment\
    \ index_in_string by 1).\n    if (index_in_string == 0) {\n      index_in_string\
    \ + 1\n      continue\n    }\n    \n    # If the current character is a \"<\"\
    \ then we assume that everything that comes\n    # after it is a closing bracket.\n\
    \    if (current_character == '<') {\n      state = -1\n      \n    # If the current\
    \ character is a \">\" then we assume that everything that comes\n    # before\
    \ it is a opening bracket.\n    } else if (current_character == '>') {\n     \
    \ state = 1\n    }\n    \n    # If the current character is a \"(\" then we assume\
    \ that everything that comes\n    # after it is a closing bracket.\n    else if\
    \ (current_character == '(') {\n      state = -1\n      \n    # If the current\
    \ character is a \")\" then we assume that everything that comes\n    # before\
    \ it is a opening bracket.\n    } else if (current_character == ')') {\n     \
    \ state = 1\n    }\n    \n    # If the current character is a space, i.e. the\
    \ previous character was\n    # either a space or a \"<\", then we assume that\
    \ everything that comes after\n    # it is a closing bracket.\n    else if (current_character\
    \ == ' ') {\n      state = -1\n      \n    # If we are at a whitespace character\
    \ and we had previously seen a\n    # closing bracket then we assume that everything\
    \ that comes before the space\n    # is a opening bracket.\n    else if (state\
    \ == 1 && open_bracket != -1) {\n      state = 0\n      open_bracket = -1\n  \
    \  }\n    \n    # If the current character is a closing bracket, then we assume\
    \ that everything\n    # that comes after the ", "\n  return(TRUE)\n}\n</cell>\n\
    <cell>", "\n  sapply(strsplit(brackets, \">|<\"), rep, 2)\n}\n", "\n\tbrackets\
    \ <- gsub(\"[<>]\", \"\", brackets)\n\tbrackets <- gsub(\"\\\\<\", \"\", brackets)\n\
    \tbrackets <- gsub(\"\\\\>\", \"\", brackets)\n\treturn(brackets[1] == brackets[2])\n\
    }\n", "\n  nchar(brackets) / 2\n  strsplit(brackets, '<') %>%\n    lapply(function(x)\
    \ {\n      x %>% unlist() %>% length() %>% !is.na() %>%\n        sum() %>% as.logical()\n\
    \    }) %>% sum() %>% as.logical()\n}\n", "\n  # Initialize a table to hold the\
    \ answer\n  brackets <- chartr(\"<>\", \"  \", brackets)\n  brackets <- gsub(\"\
    \\\\<\", \"\", brackets)\n  brackets <- gsub(\"\\\\>\", \"\", brackets)\n  brackets\
    \ <- gsub(\"  \", \"><\", brackets)\n  brackets <- paste(\"<\", brackets, \">\"\
    , sep=\"\")\n  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"\
    \\\\<\", \"\", brackets)\n  brackets <- gsub(\"\\\\>\", \"\", brackets)\n  brackets\
    \ <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n\
    \  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\"\
    , brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"\
    \  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets\
    \ <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n\
    \  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\"\
    , brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"\
    \  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets\
    \ <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n\
    \  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\"\
    , brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"\
    \  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets\
    \ <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n\
    \  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"  \", \"><\"\
    , brackets)\n  brackets <- gsub(\"  \", \"><\", brackets)\n  brackets <- gsub(\"\
    \  \", \"><\", brackets)\n  brackets <- gsub(\"", "\n    stopifnot(is.character(brackets))\n\
    \    stack <- strsplit(brackets, '><')\n    stack <- unlist(stack)\n    stopifnot(all(sapply(stack,\
    \ function(s) {\n        nchar(gsub('>', '', s)) == 0\n    })))\n    return(TRUE)\n\
    }\n", "\n  # convert brackets to list\n  bracket_list <- strsplit(brackets, '[<>]')\n\
    \  # initialize a matrix to hold the results\n  correct_brackets <- matrix(FALSE,\
    \ length(bracket_list), 2)\n  # loop through the list\n  for (i in 1:length(bracket_list))\
    \ {\n    # extract a pair\n    pair <- bracket_list[[i]]\n    # convert pair to\
    \ character string\n    pair <<- paste(pair, collapse = '')\n    # convert to\
    \ uppercase to compare case-insensitively\n    pair <<- toupper(pair)\n    # find\
    \ matches in \"[<>]\"\n    bracket_matches <- grep('[<>]', pair)\n    # convert\
    \ matches to boolean\n    bracket_matches <<- as.logical(as.integer(bracket_matches))\n\
    \    # set matrix element for matching pair to TRUE\n    correct_brackets[i, 1]\
    \ <- bracket_matches\n    # set matrix element for non-matching pair to FALSE\n\
    \    correct_brackets[i, 2] <- !bracket_matches\n  }\n  # return result\n  return(correct_brackets)\n\
    }\n", "\n  brackets <- gsub(\"(<\\\\S+>)\", \"\", brackets, fixed=TRUE)\n  brackets\
    \ <- gsub(\"\\\\s+\", \"\", brackets)\n  bracket_open <- which(brackets == \"\
    >\")\n  bracket_close <- which(brackets == \"<\")\n  length(bracket_open) == length(bracket_close)\n\
    }\n", "\n  # The first position in brackets is the \"opening\" bracket, and\n\
    \  # the second position is the closing bracket.\n  left_opening_count <- 0\n\
    \  right_closing_count <- 0\n  for (i in seq_len(length(brackets) - 1)) {\n  \
    \  next_opening <- brackets[i]\n    next_closing <- brackets[i + 1]\n    if (next_opening\
    \ == '<') {\n      if (right_closing_count == 0) {\n        left_opening_count\
    \ <- left_opening_count + 1\n      } else {\n        left_opening_count <- left_opening_count\
    \ + 1\n        right_closing_count <- right_closing_count - 1\n      }\n    }\
    \ else if (next_opening == '>') {\n      if (left_opening_count == 0) {\n    \
    \    right_closing_count <- right_closing_count + 1\n      } else {\n        right_closing_count\
    \ <- right_closing_count + 1\n        left_opening_count <- left_opening_count\
    \ - 1\n      }\n    } else {\n      left_opening_count <- left_opening_count +\
    \ 1\n    }\n  }\n  if (left_opening_count == 0) {\n    left_opening_count <- left_opening_count\
    \ + 1\n  }\n  if (right_closing_count == 0) {\n    right_closing_count <- right_closing_count\
    \ + 1\n  }\n  return (left_opening_count == right_closing_count)\n}\n", "\n  brackets\
    \ <- gsub('^\\\\s*|\\\\s*$', '', brackets)\n  bracket_pairs <- strsplit(brackets,\
    \ split = \"><\")\n  all_brackets <- lapply(bracket_pairs, function(x) paste(x,\
    \ collapse = \">\"))\n  open_brackets <- lapply(all_brackets, strsplit, split\
    \ = \"<\")\n  close(open_brackets) <- lapply(open_brackets, unlist)\n  close(bracket_pairs)\
    \ <- lapply(close(bracket_pairs), unlist)\n  all_brackets <- paste(all_brackets,\
    \ collapse = \"\")\n  all_brackets <- gsub(\"<|>\", \"\", all_brackets)\n  all_pairs\
    \ <- c(close(bracket_pairs), open_brackets)\n  length(unique(all_pairs)) == length(all_brackets)\n\
    }\n</code>\n<|/ a |>\n<| a tags=r,regex,pattern-matching |>\n<code>\nlibrary(stringr)\n\
    \ df1$new_col <-   str_extract_all(df1$col,regex(\"[\\\\>]{2}\"))\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nWhat is this answer supposed to do? It's not clear,\
    \ please add some explanation.\n<|/ c |>\n<| a |>\nI suggest using perl=T and\
    \ a regex that matches a pair, and that matches a \"pair\" in other contexts.\
    \ \n<code>\ngsub('([^\\\\>]{2})([^\\\\>]{2})','\\\\1\\\\2',x,perl=T)\n[1] \"<><><><><><><><><>\"\
    \n</code>\n<|/ a tags=r,regex,pattern-matching dscore=2 |>\n<| a dscore=1 |>\n\
    Just for the sake of it, here's another approach using stringr package.\n<code>\n\
    library(stringr)\nx <- \"<>\"\nstr_split(x, \"\\\\>\")\n[[1]]\n[1] \"\" \"\" \"\
    \" \"\" \"\"\n</code>\nstr_split will split x into individual strings and then\
    \ you can select individual elements by index. \n<code>\nstr_split(x, \"\\\\>\"\
    )[[1]]\n[1] \"\" \"\" \"\" \"\" \"\" \n</code>\n<|/ a tags=r,regex,pattern-matching\
    \ |>\n<| a tags=r,regex,pattern-matching |>\nThe answer from is quite good. However,\
    \ if you have unbalanced brackets you can use following regex to keep matching\
    \ as long as you have two opening brackets:\n<code>\nlibrary(stringr)\nstr_extract_all(df1$",
  "\n  brackets <- gsub(\"[<>]\", \"\", brackets)\n  out <- nchar(brackets) > 1\n\
    \  if (length(out) == 0) {\n    return(TRUE)\n  } else {\n    return(out)\n  }\n\
    }\n\n", "\n  x <- c(brackets)\n  length(x) < 2 || (x[1] != x[2])\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI ran some tests with the same function and got these results:\
    \ \n> correct_bracketing('<<><>>')\n[1] TRUE\n> correct_bracketing('><<>')\n[1]\
    \ FALSE\n> correct_bracketing('<<><><>')\n[1] TRUE\n> correct_bracketing('>><><>')\n\
    [1] FALSE\n> correct_bracketing('<<><><><<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><",
  "\n  for (i in 1:length(brackets)) {\n    opening_bracket <- brackets[i]\n    if\
    \ (i %% 2 == 0) {\n      if (brackets[i+1] != opening_bracket) {\n        return(FALSE)\n\
    \      }\n    }\n    else if (brackets[i-1] != opening_bracket) {\n      return(FALSE)\n\
    \    }\n  }\n  return(TRUE)\n}\n</cell>\n<cell>", "\n    opening_bracket <- gregexpr(\"\
    [<]\", brackets)\n    closing_bracket <- gregexpr(\"[>]\", brackets)\n    length(opening_bracket)\
    \ == length(closing_bracket)\n}\n", "\n  brackets <- gsub(\"</?[^>]*>\", \"\"\
    , brackets)\n  brackets <- gsub(\"^<<<\", \"<<<\", brackets)\n  brackets <- gsub(\"\
    ^>>>>>\", \">>>\", brackets)\n  brackets <- gsub(\"^<<<\", \"<<<\", brackets)\n\
    \  brackets <- gsub(\"^>>>>\", \">>>\", brackets)\n  brackets <- gsub(\"^>>>\"\
    , \">>>\", brackets)\n  brackets <- gsub(\"^<<\", \"<<\", brackets)\n  brackets\
    \ <- gsub(\"^<\", \"<\", brackets)\n  brackets <- gsub(\"^>\", \">\", brackets)\n\
    \  brackets <- gsub(\"^,\", \",\", brackets)\n  brackets <- gsub(\"^\\\\(|\\\\\
    )\", \"\", brackets)\n  brackets <- gsub(\"^\\\\[|\\\\]\", \"\", brackets)\n \
    \ brackets <- gsub(\"^\\\\{|\\\\}\", \"\", brackets)\n  brackets <- gsub(\"^\\\
    \\||\\\\+\", \"\", brackets)\n  brackets <- gsub(\"^\\\\{|\\\\}\", \"\", brackets)\n\
    \  brackets <- gsub(\"^\\\\|\", \"\", brackets)\n  brackets <- gsub(\"^\\\\+\"\
    , \"\", brackets)\n  brackets <- gsub(\"^\\\\||\", \"\", brackets)\n  brackets\
    \ <- gsub(\"^\\\\||\\\\{|\", \"\", brackets)\n  brackets <- gsub(\"^\\\\|\", \"\
    \", brackets)\n  brackets <- gsub(\"^\\\\+\", \"\", brackets)\n  brackets <- gsub(\"\
    ^\\\\||\", \"\", brackets)\n  brackets <- gsub(\"^\\\\||\\\\{|\", \"\", brackets)\n\
    \  brackets <- gsub(\"^\\\\|\", \"\", brackets)\n  brackets <- gsub(\"^\\\\+\"\
    , \"\", brackets)\n  brackets <- gsub(\"^\\\\||\", \"\", brackets)\n  brackets\
    \ <- gsub(\"^\\\\||\\\\{|\", \"\", brackets)\n  brackets <- gsub(\"^\\\\|\", \"\
    \", brackets)\n  brackets <- gsub(\"^\\\\+\", \"\", brackets)\n  brackets <- gsub(\"\
    ^\\\\||\", \"\", brackets)\n  brackets <- gsub(\"^\\\\||\\\\{", "\n  \n  brackets\
    \ = brackets # don't overwrite argument\n  \n  # find all the left brackets:\n\
    \  brackets = gsub(\"<\", \"\", brackets)\n  brackets = strsplit(brackets, \"\
    [<]\") # split into list\n  \n  # now find all the right brackets:\n  brackets\
    \ = strsplit(brackets, \"]>\")\n  \n  return(all(lapply(brackets, function(x)\
    \ length(x)==1)))\n  \n}\n</cell>\n<cell>", "\n    open_brackets <- lapply(strsplit(brackets,\
    \ \"[<>]\"), function(x) unlist(strsplit(x, \"<<\")))\n    close_brackets <- lapply(open_brackets,\
    \ function(x) unlist(strsplit(x, \">>\")))\n    sapply(close_brackets, length)\
    \ == 1\n}\n", "\n  brackets = paste0(\"<\", brackets, \">\")\n  regexp <- paste0(\"\
    [\", paste0(brackets, collapse = \"|\"), \"]\")\n  return(grepl(regexp, brackets))\n\
    }\n\n</cell>\n<text>\nQuestion 4\n\n</text>\n<text>\nQuestion 4a\n\n</text>\n\
    <cell>", "\n  brackets <- gsub(\"[<>]\", \"\", brackets)\n  for (i in 1:length(brackets))\
    \ {\n    if (brackets[i] != \"<\") {\n      return(FALSE)\n    } else {\n    \
    \  opens <- which(brackets[i] == \"<\")\n      if (length(opens) == 0) {\n   \
    \     return(FALSE)\n      } else {\n        closes <- which(brackets[i] == \"\
    >\")\n        if (length(closes) == 0) {\n          return(FALSE)\n        } else\
    \ {\n          if (length(closes) > length(opens)) {\n            return(FALSE)\n\
    \          } else {\n            i <- opens[length((opens + closes))]\n      \
    \      brackets <- gsub(\"(<)[^<>]*?(>)\", \"\", brackets)\n            brackets[i]\
    \ <- \"</#1>\"\n          }\n        }\n      }\n    }\n  }\n  return(TRUE)\n\
    }\n</code>\nFor a more general definition of correct_bracketing, see here.\n<|/\
    \ a |>\n<| c |>\nThis doesn't work at all. Try it with a string like '<<>><<>><<>><<>>>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<>><<",
  "\n  \n  # We need a counter of how many times we've encountered a opening bracket.\n\
    \  open_count <- 0\n  \n  # We need a counter of how many times we've encountered\
    \ a closing bracket.\n  close_count <- 0\n  \n  # We need a vector to store the\
    \ correct brackets.\n  correct_brackets <- vector(mode = 'character', length =\
    \ length(brackets))\n  \n  # Iterate over every character in the string and check\
    \ each character.\n  for (i in 1:length(brackets)) {\n    \n    # If the character\
    \ is an opening bracket, increment the opening bracket count.\n    if (brackets[i]\
    \ == \"<\") {\n      open_count <- open_count + 1\n      \n    # If the character\
    \ is a closing bracket, decrement the closing bracket count.\n    } else if (brackets[i]\
    \ == \">\") {\n      close_count <- close_count + 1\n      \n    # If the opening\
    \ bracket count is equal to the closing bracket count, then\n    # that bracket\
    \ pair must be correct.\n    if (open_count == close_count) {\n      correct_brackets[i]\
    \ <- brackets[i]\n    }\n    \n  }\n  \n  # If the open_count is equal to 0 and\
    \ the close_count is equal to 0, then the\n  # brackets are correct, otherwise\
    \ return FALSE.\n  if (open_count == 0 && close_count == 0) {\n    correct_brackets\
    \ <- vector(mode = 'character', length = length(brackets))\n  }\n  \n  return(identical(brackets,\
    \ correct_brackets))\n  \n}\n", "\n  return(length(brackets)==1 && brackets[1]=='>'\
    \ && brackets[length(brackets)]=='<')\n}\n", "\n  if(!is.character(brackets))\
    \ return(FALSE)\n  # first remove the quotes\n  brackets <- gsub('\"', '', brackets)\n\
    \  # then look for the pairs we want\n  lapply(strsplit(brackets, \"\"), function(x)\
    \ {\n    if(length(x) < 2) return(FALSE)\n    y <- paste0(substring(x, 1, 1),\
    \ substring(x, 2, 2))\n    y <- gsub('>', '', y)\n    y <- gsub('<', '', y)\n\
    \    y <- gsub('&', '', y)\n    return(all(y == x))\n  })\n}\n", "\n  brackets\
    \ <- brackets[brackets != \"<\"]\n  brackets <- brackets[brackets != \">\"]\n\
    \  return(brackets == brackets[brackets != \"<\"] | brackets == brackets[brackets\
    \ != \">\"])\n}\n</cell>\n<cell>", "\n  # This function takes a string containing\
    \ a bracket sequence, and\n  # checks whether every open bracket has a closing\
    \ bracket.\n  # Return a logical value.\n  opening_brackets <- strsplit(brackets,\
    \ \">>><<<\")\n  return(length(opening_brackets) == length(opening_brackets[[1]]))\n\
    }\n", "\n  brackets <- brackets[[1]]\n  open_bracket <- function(bracket) {\n\
    \    brackets <- brackets[[1]]\n    i <- brackets == bracket\n    if (!length(i))\
    \ stop(\"No brackets found\")\n    i\n  }\n  really_close_brackets <- lapply(brackets,\
    \ open_bracket)\n  unlist(really_close_brackets)\n}\n", "\n  brackets <-\n   \
    \ ifelse(\n      grepl(\"<\", brackets),\n      paste0(\"<\", gsub(\"<|>\", \"\
    \", brackets)),\n      paste0(\">\", gsub(\"<|>\", \"\", brackets)))\n  return(grepl(brackets,\
    \ brackets))\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nthank you! I think this is\
    \ the most correct solution\n<|/ c |>\n<| a tags=r |>\nHere is an option with\
    \ gsubfn\n<code>\nlibrary(gsubfn)\nv1 <- c(\"><<<\", \"<<><>>\", \"<>><\")\ngsubfn(\"\
    (<|>)(.*)(<|>)\", ~ paste0(sort(c(x, x, x)), collapse='|'), v1)", "\n  opening_brackets\
    \ <- strsplit(brackets, \"<\")\n  last_open <- length(opening_brackets)\n  for\
    \ (i in 1:last_open) {\n    if (opening_brackets[[i]][1] != '<') {\n      opening_brackets[[i]][1]\
    \ <- '<'\n    }\n  }\n  closing_brackets <- strsplit(brackets, \">\")\n  last_close\
    \ <- length(closing_brackets)\n  for (i in 1:last_close) {\n    if (closing_brackets[[i]][1]\
    \ != '>') {\n      closing_brackets[[i]][1] <- '>'\n    }\n  }\n  is_correct <-\
    \ all(opening_brackets[[1]][[1]] == closing_brackets[[1]][[1]])\n  for (i in 2:last_open)\
    \ {\n    for (j in 1:last_close) {\n      if (opening_brackets[[i]][j] != closing_brackets[[j]][[1]])\
    \ {\n        is_correct <- FALSE\n        break\n      }\n    }\n  }\n  return(is_correct)\n\
    }\n", "\n  brackets <- unlist(strsplit(brackets, \"\"))\n  is.pair <- function(x)\
    \ length(x) == 2\n  all(sapply(brackets, is.pair))\n}\n", "\n  # Remove white\
    \ space\n  brackets <- gsub('\\\\s+', '', brackets)\n  # Convert to lower case\n\
    \  brackets <- tolower(brackets)\n  # Remove leading and trailing \"<\" and \"\
    >\"\n  brackets <- gsub('</?\\\\w+>', '', brackets)\n  # Remove empty brackets\n\
    \  brackets <- gsub('[]', '', brackets)\n  # Remove leading brackets \n  brackets\
    \ <- gsub('^[\\\\<>]+', '', brackets)\n  # Remove trailing brackets\n  brackets\
    \ <- gsub('\\\\[\\\\<>$]+', '', brackets)\n  # Return FALSE when no brackets left\n\
    \  return(length(brackets) == 0)\n}\n</code>\n<|/ a tags=regex,string,r dscore=0\
    \ |>\n<| a |>\nA simple gsub would work:\n<code>\n> x <- \"<<>>>><<><<>><<>>\"\
    \n> gsub(\"[<>]\", \"\", x)\n[1] \"<<>><<>><<>>\"\n</code>\n<|/ a dscore=0 tags=regex,string,r\
    \ |>\n<| a |>\nI hope this helps!\n<code>\nlibrary(stringr)\ndf<- data.frame(id=c(1,2,3,4,5,6,7,8,9,10),\n\
    \                stringsAsFactors = F)\ndf$string<- c(\n  \"<<>>>><<><<>><<>>\"\
    ,\n  \"<>><<>><<>><<>><<>>\",\n  \"<>><<>><<>><<>><<>>\",\n  \"<<>><<>><<>><<>><<>>\"\
    ,\n  \"<>><<>><<>><<>><<>>\",\n  \"<>><<>><<>><<>><<>>\",\n  \"<>><<>><<>><<>><<>>\"\
    ,\n  \"<>><<>><<>><<>><<>>\",\n  \"<>><<>><<>><<>><<>>\",\n  \"<>><<>><<>><<>><<>>\"\
    ,\n  \"<>><<>><<>><<>><<>>\"\n)\ndf", "\n  n <- nchar(brackets)\n  for(i in 1:n)\
    \ {\n    if(brackets[i] != '<') return FALSE\n    for(j in 1:i) {\n      if(brackets[j]\
    \ != '>') return FALSE\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a tags=python,regex\
    \ |>\n<| c |>\nThis doesn't work with something like `abc<def<ghi<jkl<mno`.\n\
    <|/ c |>\n<| c |>\n`abc<def<ghi<jkl<mno` isn't valid because of the extra `<`\
    \ at `jkl<mno`, but this also doesn't work `<>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>><>>",
  "\n  # Remove extra brackets.\n  brackets <- gsub(\"^\\\\<\\\\<*\\\\>\\\\>\\\\>*\"\
    , \"\", brackets)\n  # Find indices of opening brackets and closing brackets.\n\
    \  opening_brackets <- gregexpr(\"\\\\<\", brackets)\n  closing_brackets <- gregexpr(\"\
    \\\\>\", brackets)\n  # Check every pair of opening brackets and closing brackets.\n\
    \  res <- FALSE\n  for (i in 1:(length(opening_brackets) - 1)) {\n    for (j in\
    \ (i + 1):(length(opening_brackets))) {\n      if(opening_brackets[i] + 1 != closing_brackets[j])\
    \ {\n        next # skip pair if one or both indices are out of range.\n     \
    \ }\n      res <- TRUE\n    }\n  }\n  return(res)\n}\n", "\n  # Write your code\
    \ here.\n}\n</cell>\n<text>\nWrite a function that checks whether a string is\
    \ a valid expression\nThis function is similar to the previous one, but has one\
    \ extra requirement: the string should contain only a limited set of operators.\
    \ Recall the list of valid operators includes:\n\n+\n-\n*\n/\n^\n%\n==\n!=\"\n\
    >\n<\n>=\n<=\n&\n|\nand\nor\nnot\n\n\n</text>\n<cell>", "\n    all_brackets_closed\
    \ <- function(brackets) {\n        # all_brackets_closed() is designed to return\
    \ a boolean value to\n        # indicate whether brackets contains at least one\
    \ closed bracket.\n        # brackets is a string of \"<\" and \">\".\n      \
    \  # return TRUE if every opening bracket has a corresponding closing bracket.\n\
    \        # >>> correct_bracketing('<')\n        # FALSE\n        # >>> correct_bracketing('<>')\n\
    \        # TRUE\n        # >>> correct_bracketing('<<><>>')\n        # TRUE\n\
    \        # >>> correct_bracketing('><<>')\n        # FALSE\n        \n       \
    \ #initialize variable\n        bracket_count <- 0\n        \n        #iterate\
    \ the string and count the number of brackets opened\n        for (i in 1:(length(brackets)\
    \ - 1)) {\n            if (brackets[i] == '<') {\n                bracket_count\
    \ = bracket_count + 1\n            }\n        }\n        \n        if (length(brackets)\
    \ == 0) {\n            bracket_count = 0\n        }\n        \n        #check\
    \ whether the number of brackets opened is equal to the number of brackets closed\n\
    \        correct_brackets_closed <- bracket_count == (length(brackets) - 1)\n\
    \        \n        correct_brackets_closed\n    }\n    \n    #run the function\n\
    \    all_brackets_closed(brackets)\n}\n", "\n  open_brackets <- gsub(\"(<)\",\"\
    \",brackets)\n  close_brackets <- gsub(\"(>)\",\"\",brackets)\n  \n  for(i in\
    \ 1:length(open_brackets)) {\n    if(open_brackets[i] != close_brackets[i]) {\n\
    \      return FALSE\n    }\n  }\n  \n  if(length(open_brackets) == 0) {\n    return\
    \ TRUE\n  }\n  \n  for(i in 1:length(close_brackets)) {\n    if(open_brackets[i]\
    \ == close_brackets[i]) {\n      return FALSE\n    }\n  }\n  \n  FALSE\n}\n</cell>\n\
    <text>\nNow we'll run the function on the first two sentences in our test set.\n\
    \n\n</text>\n<cell>\ntest_sentences <- test_sentences[1:2]\n\ncorrect_bracketing(test_sentences[1])\n\
    </cell>\n<text>\nWhat we see is that the first sentence is correctly bracketing\
    \ correctly.  But all the other sentences are wrong.\n\n\n</text>\n<cell>\ntest_sentences\
    \ <- test_sentences[2:length(test_sentences)]\n\ncorrect_bracketing(test_sentences[1])\n\
    </cell>\n<text>\nWhat we see is that the first sentence is incorrectly bracketing\
    \ correctly.  And all the other sentences are correctly bracketing correctly.\n\
    \n\n</text>\n<text>\nNow let's use our new function with our new set of test sentences.\n\
    \n\n</text>\n<cell>\ncorrect_bracketing(paste(test_sentences, collapse=\" \"))\n\
    </cell>\n<text>\nOur first pair of sentences are still incorrectly bracketing,\
    \ but they now correctly bracket.  We did this so that you can see how this function\
    \ can be used to identify the pairs of sentences in the test set that need to\
    \ be bracketed.\n\nWe used two for loops because we needed to loop through each\
    \ pair of sentences.  We could have used a nested for loop, but we prefer looping\
    \ through each pair of sentences.\n\n\n</text>\n<text>\n1.3 Generating New Training\
    \ Data from Brackets\nWe've seen how this function can be used to identify and\
    \ correct the sentence pairs that are in the test set.  Now let's generate new\
    \ pairs of sentences in the training set with additional sentence pairs inserted.\
    \  We want to pair each sentence in the training set with each sentence that is\
    \ in the test set.\n\nTo do this, we'll use the following process:\n\nFor each\
    \ sentence in the test set that needs to be brackets:Find all the sentences in\
    \ the training set that begin with the same prefix as the sentences in the test\
    \ set\nInsert sentence pairs where one sentence is the prefix of the other sentence.\n\
    \n\n\nAfter we've inserted our new sentence pairs, we can check our results by\
    \ running them through our correct_bracketing function on the new set of sentences.\
    \  We'll ", "\n  # For each opening bracket (except the first), \n  # check if\
    \ all closing brackets have a matching opening bracket.\n  # If so, return TRUE,\
    \ else FALSE.\n  # If there are no matching closing brackets,\n  # then return\
    \ FALSE.\n  \n  # Count brackets.\n  brackets <- gsub(\"[<>]\", \"\", brackets)\n\
    \  n_open <- length(brackets) - 2\n  n_close <- length(brackets) - 1 \n\n  # Return\
    \ TRUE if any opening brackets are missing.\n  if((n_close - n_open) == 0) return\
    \ (TRUE)\n  \n  # For each opening bracket, check that it has correct closing\
    \ brackets.\n  # Return TRUE if all are correct, else FALSE.\n  for(open in seq_len(n_open))\
    \ {\n    next \n  }\n  \n  # For each closing bracket, check that it has correct\
    \ opening brackets.\n  # Return TRUE if all are correct, else FALSE.\n  for(close\
    \ in seq_len(n_close)) {\n    next \n  }\n}\n</code>\nNow, we can apply our function\
    \ in some ways:\n<code>\nbrackets_test <- c(\"<\", \"<\", \"<\", \"<\", \"<\"\
    )\ncorrect_bracketing(brackets_test)", "\n  bracket_counts <- strsplit(brackets,\
    \ \"<>\")[[1]]\n  return(length(bracket_counts[[1]]) == length(bracket_counts[[2]]))\n\
    }\n", "\n    brackets <- tolower(gsub(\"<|>\", \"\", brackets))\n    len <- nchar(brackets)\n\
    \    bracket <- NULL\n    open <- TRUE\n    for (i in 1:len) {\n        if (brackets[i]\
    \ == \"<\") {\n            if (open && !is.null(bracket)) {\n                return\
    \ FALSE\n            }\n            bracket <- brackets[i + 1]\n            open\
    \ <- TRUE\n        } else if (brackets[i] == \">\") {\n            if (!open ||\
    \ is.null(bracket)) {\n                return FALSE\n            }\n         \
    \   bracket <- brackets[i + 1]\n            open <- FALSE\n        } else if (brackets[i]\
    \ == \">\") {\n            if (!open || is.null(bracket)) {\n                return\
    \ FALSE\n            }\n            bracket <- brackets[i + 1]\n            open\
    \ <- FALSE\n        } else {\n            if (!open) {\n                return\
    \ FALSE\n            }\n        }\n    }\n    return !is.null(bracket)\n}\n</code>\n\
    <|/ a tags=algorithm,r,string |>\n<| a dscore=1 tags=algorithm,r,string |>\nMy\
    \ solution uses only base R:\n<code>\nlibrary(stringi)\n\nstr <- \"ab>cd\"", "\n\
    \    \n    # Return FALSE when bracketing is incorrect\n    if (brackets %in%\
    \ c(\"<\", \">\")) == FALSE \n        stop(\"bracketing must be '<' or '>'\")\n\
    \    \n    # Return TRUE when bracketing is correct\n    bracketing <- \"\"\n\
    \    \n    # Assign a value to bracketing based on brackets\n    if (brackets\
    \ == '<') {\n        bracketing <- \"TRUE\"\n    }\n    else if (brackets == '>')\
    \ {\n        bracketing <- \"FALSE\"\n    }\n    \n    # Return bracketing\n \
    \   return(bracketing)\n}\n", "\n  if (length(brackets) < 1) return(FALSE)\n \
    \ open <- letters[1:length(unique(unlist(strsplit(brackets, \"\"))))]\n  close\
    \ <- close_bracket(open)\n  return(all(close == open))\n}\n", "\n  sapply(strsplit(brackets,\
    \ \"<\"), function(x)\n    x[length(x)] != x[length(x) - 1])\n}\n</code>\n<|/\
    \ a tags=string,r |>\n<| a dscore=1 tags=string,r |>\nUsing gsub to replace everything\
    \ except the < and > with \"\" and counting the number of instances of the pattern\
    \ \"<<>\".\n<code>\n> gsub(\"<[^>]*>\", \"\", string, fixed = TRUE)\n[1] \"<X><Y><Z>\"\
    \n> length(gregexpr(\"<<>\", gsub(\"<[^>]*>\", \"\", string, fixed = TRUE)))\n\
    [1] 2\n</code>\n<|/ a |>\n<| a |>\nHere is an attempt in base R:\n<code>\nstr1\
    \ <- \"<X><Y><Z>\"\nstr2 <- \"<<><><><><>\"\n\nf <- function(x) gregexpr(\"<<>\"\
    ,x)$length\ntable(apply(cbind(str1,str2),1,f))", "\n  return(unlist(lapply(strsplit(brackets,\
    \ \">\"), function(x) { \n    (x != '<') | (x != '>')\n  })))\n}\n", "\n  result\
    \ <- FALSE\n  for (bracket in c('<','>'))\n    if (!(str_detect(brackets,paste0(\"\
    (\",bracket,\")\")) == FALSE))\n      result <- TRUE\n  return(result)\n}\n",
  "\n    paste(sapply(regexpr('<+', brackets, fixed = TRUE), 1, function(x) x-1),\n\
    \           sapply(regexpr('<+', brackets, fixed = TRUE), 2, function(x) x-2),\n\
    \           sep = '>')\n}\n</code>\nThe result of the code above is a logical\
    \ vector. You can use it to subset the elements of the brackets vector:\n<code>\n\
    > brackets[correct_bracketing(brackets)]\n[1] \"<\"  \"<\"  \"<\"  \"<<\" \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"\
    \  \"<\"  \"<\"  \"<\"  \"<\"  \"<\"  \"<", "\n  \n  bracket_pairs <- strsplit(brackets,\
    \ split=\"[><]\", fixed=T)\n  \n  for(bracket_pair in bracket_pairs) {\n    \n\
    \    # Get the lengths of the pair and make sure it's correct\n    len <- length(bracket_pair)\n\
    \    if(len != 2) next\n    \n    # Make sure the second string isn't the empty\
    \ string\n    if(length(bracket_pair[[1]]) == 0) next\n    \n    # Make sure the\
    \ third string isn't the empty string\n    if(length(bracket_pair[[2]]) == 0)\
    \ next\n    \n    # If the first and second are identical, return FALSE\n    if(bracket_pair[[1]]\
    \ == bracket_pair[[2]]) {\n      \n      # If the first and third are identical,\
    \ return FALSE\n      if(bracket_pair[[1]] == bracket_pair[[3]]) {\n        \n\
    \        # Return TRUE\n        TRUE\n      }\n    }\n  }\n  \n  # Return FALSE\n\
    \  FALSE\n}\n\n", "\n  return(gregexpr('[^<]+', brackets)[[1]] != gregexpr('[^>]+',\
    \ brackets)[[1]])\n}\n</code>\n<|/ a tags=r,regex dscore=3 |>\n<| c |>\nGood one!\
    \ I was thinking of a lookbehind, but this is much simpler. +1 :-)\n<|/ c |>\n\
    <| c |>\nThis is great! The only problem is that it will only work on a single\
    \ pair of brackets. `'<>>>'` will not work.\n<|/ c |>\n<| c |>\nI see - you're\
    \ right - I assumed the number of open/close pairs would not exceed three. I've\
    \ fixed it now by adding a negative lookahead\n<|/ c |>\n<| a tags=r,regex |>\n\
    I suggest a similar solution, but this time without using lookahead and lookbehind:\n\
    <code>\n> str <- \"<A><B><C>\"\n> rle <- rle(str)\n> rle <- rle(tolower(rle$value))\n\
    > rle$values\n[1] \"<\" \"a\"> \"b\"> \"c\"\n> tolower(rle$values) %in% str\n\
    [1] FALSE\n> rle <- rle(tolower(rle$values))\n> rle$values <- tolower(rle$values)\n\
    > rle <- rle(tolower(rle$values))\n> rle$values <- tolower(rle$values)\n> tolower(rle$values)\
    \ %in% str\n[1] TRUE\n</code>\nWe convert the string to lower case and use %in%\
    \ to see if each value is in the string. You can also use gregexpr and specify\
    \ the beginning and end strings to find all of the matches, but I find this simpler\
    \ to understand.\n<|/ a dscore=3 |>\n<| c |>\nThis is a very nice solution. +1.\
    \ I have never thought of using `rle` like that before. Very nice.\n<|/ c |>\n\
    <| c |>\nIt's nice because we avoid using lookahead and lookbehind. If this were\
    \ the only solution I'd +1 but for now I think `stringr` has `str_match` and `str_extract_all`\
    \ which are both very useful.\n<|/ c |>\n<| c |>\nI agree with you that `stringr`\
    \ has `str_match` and `str_extract_all` but I think `stringr` is much more than\
    \ needed for the problem. I think `stringr` is a powerful set of functions, but\
    \ I think a simple `gregexpr` solution is easier to understand.\n<|/ ", "\n  brackets\
    \ <- (gsub(\"[<>]\", \"\", brackets))\n  brackets <- gsub(\"[^<>]+\", \">\", brackets)\n\
    \  brackets <- gsub(\"<\", \"> <\", brackets)\n  return(length(brackets) == 2)\n\
    }\n</cell>\n<cell>\ncorrect_bracketing(\"<<><>>\")\n</cell>\n<cell>", "\n  # Make\
    \ sure brackets are in the correct format.\n  brackets <- as.character(brackets)\n\
    \  brackets <- gsub('>', '', brackets)\n  brackets <- gsub('<<', '', brackets)\n\
    \  brackets <- gsub('>>', '', brackets)\n\n  # Make sure the brackets are paired.\n\
    \  pair_check <- function(x) {\n    brackets <- paste0('<<', x)\n    brackets\
    \ <- paste0(brackets, '>>')\n    return(\n      regexpr(brackets, brackets) ==\n\
    \      regexpr(brackets, brackets, fixed = TRUE)\n    )\n  }\n  return(all(sapply(brackets,\
    \ pair_check)))\n}\n", "\n  s <- gregexpr(\"(<*>)?\", brackets)\n  nr <- length(attr(s,\
    \ \"match.length\")) - 1\n  sapply(seq_along(s), function(i) all(substr(brackets,\
    \ s[[i]], s[[i]+1]) == \">\") &&\n            substr(brackets, s[[i]+1], s[[i]+1])\
    \ == \"<>\")\n}\n</cell>\n<text>\nLet's see if it works as expected:\n\n\n</text>\n\
    <cell>\ncorrect_bracketing('<')\ncorrect_bracketing('<>')\ncorrect_bracketing('<<><>>')\n\
    correct_bracketing('><<>')\n</cell>\n<text>\nNow let's create some expressions:\n\
    \n\n</text>\n<cell>\nexpression1 <- \"He was a man of steel and he passed away...\
    \ \"\nexpression2 <- \"He was a man of steel and he passed away... \"\nexpression3\
    \ <- \"He was a man of steel and he passed away... \"\n</cell>\n<text>\nAnd make\
    \ some random strings of them:\n\n\n</text>\n<cell>\nrandom_strings <- c('<<>>',\
    \ '<<><>>', '<<><><><><><>', '<><><><><><><><>')\n</cell>\n<text>\nNow we get\
    \ the positions of the matching brackets:\n\n\n</text>\n<cell>\npositions <- lapply(random_strings,\
    \ function(x) gregexpr(\"(<*>)?\", x))\n</cell>\n<text>\nLet's put all the expressions\
    \ in a list:\n\n\n</text>\n<cell>\nexpressions <- lapply(positions, tail, -1)\n\
    </cell>\n<text>\nNow we get the positions of the matching brackets in the list\
    \ of expressions:\n\n\n</text>\n<cell>\nlapply(expressions, gregexpr, expression1)\n\
    </cell>\n<text>\nLet's create a vector:\n\n\n</text>\n<cell>\nmatching_positions\
    \ <- lapply(expressions, function(x) paste(attr(x, \"match.length\"), collapse\
    \ = \" \"))\n</cell>\n<text>\nFinally, we count the number of matching brackets\
    \ among the list of expressions:\n\n\n</text>\n<cell>\nlength(unlist(lapply(matching_positions,\
    \ function(x) gregexpr(x, expression1))))\n</cell>\n<text>\nLet's try it with\
    \ the other expressions:\n\n\n</text>\n<cell>\nlength(unlist(lapply(matching_positions,\
    \ function(x) gregexpr(x, expression2))))\n</cell>\n<cell>\nlength(unlist(lapply(matching_positions,\
    \ function(x) gregexpr(x, expression3))))\n</cell>\n<text>\nLet's make a function\
    \ that generates random strings of ", "\n  brackets <- strsplit(brackets, \"\"\
    )[[1]]\n  paste0(brackets, collapse = \" \") != brackets\n}\n", "\n  # Initialize\
    \ variables.\n  open <- 0\n  close <- 0\n  found <- FALSE\n  # If brackets is\
    \ empty, return TRUE.\n  if (!length(brackets)) return(TRUE)\n  # Loop through\
    \ brackets.\n  for(i in 1:length(brackets)) {\n    # Get opening bracket.\n  \
    \  open = bquote(.(brackets[i]))\n    if (identical(open, '.')) {\n      open\
    \ <- NULL\n      next\n    }\n    # Count the number of open brackets.\n    open\
    \ <- nchar(open)\n    if (open == 0) {\n      close <- close\n      next\n   \
    \ }\n    # Loop through closing brackets.\n    while(!identical(open, '.')) {\n\
    \      # Get closing bracket.\n      close = bquote(paste(.(close), .(open), sep=\"\
    \"))\n      found <- TRUE\n      if (identical(close, '.')) {\n        close <-\
    \ NULL\n        open <- open\n        next\n      }\n      # Get character before\
    \ closing bracket.\n      current <- substr(brackets, 1, close-1)\n      # Check\
    \ if the opening bracket matches the closing bracket.\n      if (identical(current,\
    \ close)) {\n        close <- close\n        open <- open\n        next\n    \
    \  } else {\n        close <- close+1\n      }\n    }\n  }\n  # Return TRUE if\
    \ all brackets match.\n  return(found)\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    Nice work! I like the idea of using a character string of the form `\"<>\"` to\
    \ identify brackets.\n<|/ c |>\n<| c |>\nThanks Ben! I added a short implementation\
    \ with comments.\n<|/ c |>\n<| a dscore=3 tags=python,algorithm |>\n<code>\ndef\
    \ check(s):\n    stack = []\n    bracket = False\n    for c in s:\n        if\
    \ c == '(':\n            stack.append(c)\n        elif c == ')':\n           \
    \ if not stack:\n                return False\n            elif stack.pop() !=\
    \ '(':\n                return False\n        elif c == ')' and len(stack) > 0:\n\
    \            return False\n        elif not bracket:\n            if c == '[':\n\
    \                bracket = True\n                stack.append(c)\n           \
    \ elif c == ']':\n                if not stack:\n                    return False\n\
    \                elif stack.pop() != '[':\n                    return False\n\
    \    return not stack\n</code>\n<|/ a |>\n<| c |>\nWhat do you mean with \"not\
    \ work\"? It works for me. Are you sure you copied it correctly?\n<|/ c |>\n<|\
    \ a tags=python,algorithm |>\nHere's a simple implementation in Python:\n<code>\n\
    def is_bracket(s):\n    stack = []\n", "\n  if(is.null(brackets)) return(FALSE)\n\
    \  brackets <- gsub(\"</?[^<>]*?>\", \"\", brackets)\n  brackets <- gsub(\"<\"\
    , \"\", brackets)\n  brackets <- gsub(\"(?<!^)>\", \">\", brackets)\n  brackets\
    \ <- gsub(\"^>\", \"\", brackets)\n  brackets <- gsub(\"(?<!^)<\", \"<\", brackets)\n\
    \  brackets <- gsub(\"^<\", \"\", brackets)\n  return(all(brackets == brackets))\n\
    }\n</cell>\n<cell>", "\n  # This function is only correct if brackets is a string\
    \ of \"<\" and \">\".\n  correct_bracketing_helper(substring(brackets, 1, 1),\
    \ substring(brackets, 2, n))\n}\n\ncorrect_bracketing_helper <- function(left_bracket,\
    \ right_bracket) {\n  # This function returns TRUE if and only if there is only\
    \ one opening bracket that has no corresponding closing bracket.\n  correct_bracketing_helper_helper(left_bracket,\
    \ right_bracket)\n}\n\ncorrect_bracketing_helper_helper <- function(left_bracket,\
    \ right_bracket) {\n  # This function returns TRUE if and only if there is only\
    \ one opening bracket that has no corresponding closing bracket.\n  left_brackets\
    \ <- paste0(left_bracket, \"(\")\n  right_brackets <- paste0(right_bracket, \"\
    )\")\n  both_brackets <- paste0(left_brackets, right_brackets)\n  \n  ifelse(\n\
    \    grepl(paste0(left_brackets, collapse=\"|\"), both_brackets, ignore.case=TRUE,\n\
    \    grepl(paste0(right_brackets, collapse=\"|\"), both_brackets, ignore.case=TRUE),\n\
    \    grepl(paste0(both_brackets, collapse=\"|\"), both_brackets, ignore.case=TRUE),\n\
    \    FALSE\n  )\n}\n", "\n\tfor(i in 1:length(brackets)) {\n\t\tif(brackets[i]\
    \ == '<') {\n\t\t\tj <- i+1\n\t\t\twhile(j < length(brackets) && brackets[j] ==\
    \ '>') {\n\t\t\t\tj <- j + 1\n\t\t\t}\n\t\t\tif((j == length(brackets) || brackets[j]\
    \ == '>') && brackets[i] != '>') {\n\t\t\t\treturn (FALSE)\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn(TRUE)\n}\n\n", "\n  brackets <- gsub(\"[<>]\", \"\", brackets)\n \
    \ all_brackets <- mapply(paste0, c(\">\", \"<\"), \"<>\")\n  opening_brackets\
    \ <- unlist(strsplit(brackets, \"<\"))\n  opening_brackets <- opening_brackets[!grepl(\"\
    [<>]\", opening_brackets)]\n  correct_open <- grep(\"^\\\\(.*\\\\)$\", opening_brackets,\
    \ value = TRUE)\n  correct_open <- lapply(correct_open, paste0, all_brackets)\n\
    \  correct_open <- paste0(paste(correct_open, collapse = \"\"), collapse = \"\
    |\")\n  correct_open <- paste0(\"^\", correct_open, \")$\")\n  opening_brackets\
    \ <- grep(correct_open, opening_brackets, value = TRUE)\n  closed_brackets <-\
    \ unlist(strsplit(brackets, \"$\"))\n  closed_brackets <- closed_brackets[!grepl(\"\
    [<>]\", closed_brackets)]\n  correct_close <- grep(\"^\\\\(.*\\\\)$\", closed_brackets,\
    \ value = TRUE)\n  correct_close <- lapply(correct_close, paste0, all_brackets)\n\
    \  correct_close <- paste0(paste(correct_close, collapse = \"\"), collapse = \"\
    |\")\n  correct_close <- paste0(\"^\", correct_close, \"\\\\)\")\n  closed_brackets\
    \ <- grep(correct_close, closed_brackets, value = TRUE)\n  opening_brackets[grepl(\"\
    ^\", closed_brackets)] <- paste(closed_brackets, collapse = \"|\")\n  grep(brackets,\
    \ opening_brackets, value = TRUE)\n}\n</code>\nAnd it seems to work fine.\n<code>\n\
    > correct_bracketing('<')\nFALSE\n> correct_bracketing('<>')\nTRUE\n> correct_bracketing('<<><>>')\n\
    TRUE\n> correct_bracketing('><<>')\nFALSE\n</code>\n<|/ a |>\n<| c |>\nYou don't\
    \ need the `gsub` part - just use `unlist(strsplit(brackets, \"<\"))`. The result\
    \ is `[1] \"<\"` - so it's no wonder it's not matching!\n<|/ c |>\n<| c |>\n.Grothendieck\
    \ thanks, you're right. I'm usually more worried about `unlist(strsplit(x, \"\
    [[]\"))` than I thought about `strsplit(x, \"<\")`. I edited my answer.\n<|/ c\
    \ |>\n<| c |>\nThanks for your suggestion. It works well ", "\n  brackets <- gsub(\"\
    ([<>])\", \"\\\\\\\\\\\\\\\\\\\\1\", brackets)\n  brackets <- gsub(\"\\\\\\\\\\\
    \\\\\\\\\\1\", \"\\\\1\", brackets)\n  brackets <- gsub(\"\\\\\\\\\\\\\\\\\\\\\
    1\", \"\\\\1\", brackets)\n  return(brackets == \"<>\")\n}\n</cell>\n<cell>",
  "\n  res <- !is.na(gregexpr(\"<\", brackets))\n  return(res)\n}\n\n", "\n  brackets\
    \ <- brackets[!is.na(brackets)]\n  \n  n1 <- length(brackets)\n  if (n1 == 0)\
    \ return(TRUE)\n  \n  n2 <- n1 <- length(strsplit(brackets, \"\")[[1]])\n  n3\
    \ <- n2 - n1\n  \n  return(all(strsplit(brackets, \"\")[[1]][n1] == \"<\" && strsplit(brackets,\
    \ \"\")[[1]][n2] == \">\" && strsplit(brackets, \"\")[[1]][n3 + 1] == \">\"))\n\
    }\n</cell>\n<cell>", "\n    # Check if brackets is just one character\n    if\
    \ (length(brackets) == 1) return(TRUE)\n    # Split on \"<\" and \">\"\n    brackets_split\
    \ <- strsplit(brackets, \"<\")\n    # Check if every character is a \">\"\n  \
    \  return (length(brackets_split) == length(brackets))\n}\n", "\n  brackets <-\
    \ brackets[[1]]\n  length(brackets) %in% c(1,2) == 0\n}\n", "\n  sapply(brackets,\
    \ function(x) {\n    strsplit(x, split=\"(?<=\\\\w)|(?<=\\\\W)(?=\\\\w)(?=\\\\\
    W)|(?=\\\\w)|(?<=\\\\W)(?=\\\\w)|(?=\\\\W)(?<=\\\\W)(?=\\\\w)\")[[1]][1]\n  })\n\
    }\n", "\n    open_brackets <- gregexpr('\\\\<', brackets)\n    close_brackets\
    \ <- gregexpr('\\\\>', brackets)\n    open_count <- length(open_brackets)\n  \
    \  close_count <- length(close_brackets)\n    if (open_count == close_count) {\n\
    \        return(TRUE)\n    }\n    else {\n        return(FALSE)\n    }\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI think this is the best solution to my problem.\n\
    <|/ c |>\n<| c |>\nIf only SO would allow me to vote up twice, I'd give this a\
    \ plus one\n<|/ c |>\n<| c |>\nI agree, very elegant, but still a bit too permissive,\
    \ for my taste :D\n<|/ c |>\n<| c |>\nThis solution is pretty elegant, but the\
    \ problem is that it's pretty slow - a million times slower. Also it's very \"\
    lazy\", so it's possible for input string to be huge. Thus the problem becomes\
    \ more complicated to solve.\n<|/ c |>\n<| a dscore=4 tags=string,parsing,r,regex\
    \ |>\nI believe the problem can be simplified to the following:\n<code>\nx<-\"\
    abc <>def\"\ngrepl(\">\",x)\n</code>\nThis is because grep looks for substrings\
    \ rather than substrings that occur in the middle of a string as grepl does.\n\
    <|/ a |>\n<| c |>\nHm, that may be true, but it's not what I was asking for. \
    \ I wasn't trying to match all \"greater than\" characters.  I was trying to find\
    \ all strings that end in \"greater than\" characters (ie. \">abc<>def\").\n<|/\
    \ c |>\n<| c |>\nThis solution does not match \">abc<>def\" which I believe is\
    \ what you are looking for\n<|/ c |>\n<| c |>\nThis solution matches the string\
    \ \"abc <>def\" which is not what I wanted.  My goal is to match strings that\
    \ end in \"greater than\" characters.\n<|/ c |>\n<| c |>\nI believe the solution\
    \ lies in something called \"backtracking\", which I know little about.  I tried\
    \ to search for the term but had no luck.  It seems possible that my problem is\
    \ related to the solution you provided.  Do you know of any way to fix my problem?\n\
    <|/ c |>\n<| c |>\nYes, backtracking is the term I'm looking for.  I can't figure\
    \ out how to ", "\n  brackets <- gsub(\"<|>\", \"\", brackets)\n  nchar(brackets)\
    \ >= 2\n}\n</code>\nI then write a custom function which counts the number of\
    \ occurrences of each character in a string:\n<code>\ncount_occurrences <- function(string,\
    \ character) {\n  table(character)[string]\n}\n</code>\nYou can now use the count_occurrences()\
    \ function to get the counts of the number of \"=\" and \"|\" characters in your\
    \ string:\n<code>\ncount_occurrences(\"asdfjkl|=dsfdsfds|=dsdfds|dsf=|=dsd\",\
    \ \"=\")", "\n  # The opening and closing brackets are counted by brackets.\n\
    \  # A closing bracket is one whose opening bracket is not the previous\n  # closing\
    \ bracket. For example, we consider \"><<\" as correct, and \"><\" as\n  # incorrect.\n\
    \  opening_closing <- strsplit(brackets, '<')[[1]][-1]\n  opening_closing2 <-\
    \ strsplit(brackets, '<')[[1]][-2]\n  opening_closing3 <- strsplit(brackets, '<')[[1]][-3]\n\
    \  opening_closing4 <- strsplit(brackets, '<')[[1]][-4]\n  opening_closing5 <-\
    \ strsplit(brackets, '<')[[1]][-5]\n  opening_closing6 <- strsplit(brackets, '<')[[1]][-6]\n\
    \  opening_closing7 <- strsplit(brackets, '<')[[1]][-7]\n  opening_closing8 <-\
    \ strsplit(brackets, '<')[[1]][-8]\n  opening_closing9 <- strsplit(brackets, '<')[[1]][-9]\n\
    \  opening_closing10 <- strsplit(brackets, '<')[[1]][-10]\n  opening_closing11\
    \ <- strsplit(brackets, '<')[[1]][-11]\n\n  closing_brackets <- strsplit(brackets,\
    \ '>')[[1]]\n  closing_brackets[1] <- opening_closing\n  closing_brackets[2] <-\
    \ opening_closing2\n  closing_brackets[3] <- opening_closing3\n  closing_brackets[4]\
    \ <- opening_closing4\n  closing_brackets[5] <- opening_closing5\n  closing_brackets[6]\
    \ <- opening_closing6\n  closing_brackets[7] <- opening_closing7\n  closing_brackets[8]\
    \ <- opening_closing8\n  closing_brackets[9] <- opening_closing9\n  closing_brackets[10]\
    \ <- opening_closing10\n  closing_brackets[11] <- opening_closing11\n\n  return(all(c(opening_closing,\
    \ closing_brackets)==opening_closing2))\n}\n", "\n  open_brackets <- strsplit(brackets,\
    \ '<', fixed=TRUE)[[1]];\n  closed_brackets <- strsplit(brackets, '>', fixed=TRUE)[[1]];\n\
    \  for(i in 1:length(open_brackets)) {\n    for(j in 1:length(closed_brackets))\
    \ {\n      if(open_brackets[i] == closed_brackets[j]) {\n        return(TRUE);\n\
    \      }\n    }\n  }\n  return(FALSE);\n}\n</cell>\n<text>\nTask 3\nWrite a function\
    \ that determines whether a number is a perfect square:\n\nGiven a positive integer\
    \ $x$, write a function which tests whether $x$ is a perfect square.\n\nExample:\
    \ \n$$\\large\n\\begin{align}\n  4 &\\neq 4 \\\n  4 &\\neq 4 \\\n  4 &\\neq 4\
    \ \\\n  4 &\\neq 4 \\\n  4 &\\neq 4 \\\n  8 &\\neq 8 \\\n  9 &\\neq 9 \\\n  16\
    \ &\\neq 16 \\\n  27 &\\neq 27 \\\n  54 &\\neq 54 \\\n\\end{align}\n$$\n\nHint:\
    \ To test whether $x$ is a perfect square, divide the number by its square root.\n\
    \n\n</text>\n<cell>", "\n    bracketsLen <- length(brackets)\n    i <- 1\n   \
    \ while(i < bracketsLen) {\n        if (brackets[i] != '<') {\n            i <-\
    \ i + 1\n        } else {\n            closingBracketIdx <- i +1\n           \
    \ while(i < bracketsLen && brackets[i] != '<') {\n                i <- i + 1\n\
    \            }\n            if (i >= bracketsLen || brackets[i] != '>') {\n  \
    \              return (FALSE)\n            }\n            i <- i + 1\n       \
    \     while(closingBracketIdx < bracketsLen && brackets[closingBracketIdx] !=\
    \ '<') {\n                closingBracketIdx <- closingBracketIdx + 1\n       \
    \     }\n            if (closingBracketIdx >= bracketsLen || brackets[closingBracketIdx]\
    \ != '>') {\n                return (FALSE)\n            }\n            i <- i\
    \ + 1\n            while(i < bracketsLen && brackets[i] == '<') {\n          \
    \      i <- i + 1\n            }\n            if (i >= bracketsLen) {\n      \
    \          return (TRUE)\n            }\n        }\n    }\n    return (FALSE)\n\
    }\n", "\n  for( i in 1:length(brackets)) {\n    opening = brackets[ i ]\n    closing\
    \ = paste0('>', closing_brackets(opening))\n    if( closing != opening ) {\n \
    \     return( FALSE )\n    }\n  }\n  return( TRUE )\n}\n</code>\nI used this function\
    \ to fix your input before running it. This also allows you to test whether the\
    \ result matches your expectation.\n<code>", "\n  bracket_matches <- gregexpr(\"\
    \\\\<\", brackets, fixed = TRUE)\n  bracket_matches_len <- lengths(bracket_matches)\n\
    \  return(all(sapply(bracket_matches_len, function(x) {\n    !is.na(gregexpr(\"\
    \\\\>\", brackets, fixed = TRUE, x = bracket_matches[[x]])[[1]])\n  })))\n}\n",
  "\n  brackets <- gsub(\"<\", \"\", brackets)\n  brackets <- gsub(\"</\", \"\", brackets)\n\
    \  brackets <- gsub(\"<>\", \"\", brackets)\n  brackets <- gsub(\">\", \"\", brackets)\n\
    \  brackets <- gsub(\"<<\", \"\", brackets)\n  brackets <- gsub(\">>\", \"\",\
    \ brackets)\n  brackets <- gsub(\"<<<\", \"\", brackets)\n  brackets <- gsub(\"\
    >>>\", \"\", brackets)\n  return(TRUE)\n}\n", "\n    len <- length(brackets)\n\
    \    open <- 0\n    closed <- 0\n    for(i in 1:len) {\n        if (brackets[i]\
    \ == '<') {\n            if (open > 0) {\n                closed  <- closed +\
    \ 1\n                open    <- open - 1\n            }\n        } else {\n  \
    \          if (closed > 0) {\n                closed  <- closed - 1\n        \
    \        open    <- open + 1\n            }\n        }\n    }\n    return (open\
    \ - closed == 0)\n}\n</code>\n<|/ a dscore=3 tags=r,python |>\n<| c |>\n`correct_bracketing('<<><>>')`\
    \ returns false. I'm missing something.\n<|/ c |>\n<| c |>\n- I fixed it.\n<|/\
    \ c |>\n<| a |>\n<code>\n'<<><>>'\n</code>\nis a string literal in python, not\
    \ a character. \nTry this:\n<code>\n\"<<><>>\" == \"\"\n</code>\n<|/ a dscore=3\
    \ tags=r,python |>\n<| a dscore=3 |>\n<code>\nx = \"<<><>>\"\n\ndef correct_bracketing(b):\n\
    \    return sum(x > y for x, y in zip(b, x)) % 2 == 0\n</code>\n<|/ a tags=r,python\
    \ |>\n<| a tags=r,python |>\n<code>\ndef correct_bracketing(brackets):\n    return\
    \ all(brackets.index(char) >= 0 for char in brackets)\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\n`return not all(char.index(brackets) != -1 for char in brackets)`\
    \ is probably more efficient.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution that\
    \ works in both Python and R using a single line ternary expression:\n<code>\n\
    correct_bracketing <- function(brackets) {\n  !grepl(\"[<>]\", brackets)\n}\n\
    </code>\n<|/ a tags=r,python |>\n<| a tags=r,python |>\nThis can be done in a\
    \ single line with stringr:\n<code>\ncorrect_bracketing <- function(brackets)\
    \ {\n  !grepl(\"[<>]\", brackets)\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere\
    \ is a single line version in Python\n<code>\ndef correct_bracketing(brackets):\n\
    \    return not any(brackets.index(c) > brackets.index(b) for c, b in zip(['<','>'],\
    \ brackets))\n</code>\n<|/ a dscore=2 tags=r,python |>\n<| c |>\nWhy would you\
    \ prefer this to a `for` loop like the other ", "\n  ok <- grepl('^[<>]+$', brackets)\n\
    \  all(grepl('^[<>]+$', brackets[ok], fixed=TRUE))\n}\n</cell>\n<cell>", "\n \
    \ # The opening and closing brackets must be present somewhere.\n  opening_brackets\
    \ <- gregexpr(\"<\", brackets)\n  closing_brackets <- gregexpr(\">\", brackets)\n\
    \  # The opening and closing brackets must be ordered correctly.\n  opening_brackets_indices\
    \ <- lapply(opening_brackets, `[`, 1)\n  closing_brackets_indices <- lapply(closing_brackets,\
    \ `[`, 1)\n  if(length(opening_brackets_indices) != length(closing_brackets_indices))\
    \ return(FALSE)\n  # The indices of the opening and closing brackets must not\
    \ have gaps.\n  opening_brackets_indices <- unlist(lapply(opening_brackets_indices,\
    \ `[`, 1:max(opening_brackets_indices)-1))\n  closing_brackets_indices <- unlist(lapply(closing_brackets_indices,\
    \ `[`, 1:max(closing_brackets_indices)-1))\n  if(all(opening_brackets_indices\
    \ == closing_brackets_indices)) {\n    all_indices <- sort(c(opening_brackets_indices,\
    \ closing_brackets_indices))\n    return(length(unique(all_indices)) == 1)\n \
    \ }\n  return(FALSE)\n}\n", "\n  paste(c(TRUE, !grepl('</', brackets)), collapse=\"\
    \")\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the edit! It didn't actually\
    \ work when I tried, but I realized that I was supposed to replace the linebreaks\
    \ with spaces. Thanks again.\n<|/ c |>\n<| c |>\n, please note that the answer\
    \ from is much more robust than this one. For example, it would match '<>', but\
    \ does not match '><<>', for example.\n<|/ c |>\n<| a tags=r,regex,text-mining\
    \ |>\nAnother approach with gsub using positive lookahead:\n<code>\nx <- '<> foo\
    \ <>'\ngsub('(?=<)', '\\n', x)\n[1] \"<\\n foo <\\n\"\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 tags=r,regex,text-mining |>\nI think you're looking for a\
    \ simple substitute command\n<code>\n> str <- '<> foo <>'\n> str <- sub('>', '\\\
    n', str)\n> str\n[1] \"<\\n foo <\\n\"\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>\n> str <- '<> foo <>'\n> str <- gsub('>+', '\\n', str)\n> str\n[1] \"<\\\
    n foo <\\n\"\n</code>\n<|/ a tags=r,regex,text-mining |>\n<| a dscore=0 |>\n<code>\n\
    > str <- '<> foo <>'\n> str <- gsub('>+', '\\n', str)\n> str\n[1] \"<\\n foo <\\\
    n\"\n</code>\n<|/ a tags=r,regex,text-mining |>\n<| a dscore=0 |>\nIn general,\
    \ if you need to replace characters by another character, I recommend using sub\
    \ instead of gsub. For example, in your case, you can do:\n<code>\n> sub('>',\
    \ '\\n', str)\n[1] \"<\\n foo <\\n\"\n</code>\n<|/ a tags=r,regex,text-mining\
    \ |>\n<| c |>\nI actually thought of this, but it didn't work for me for some\
    \ reason. Maybe because I forgot to mention that the '>' character is part of\
    \ another string in the same sentence. Hence why I was searching for a regex solution.\n\
    <|/ c |>\n<| c |>\nThat's why I put \"in general\" :)\n<|/ c |>\n<| a dscore=0\
    \ |>\nYou can use stringi package for this:\n", "\n  \n  bracket_pairs <- strsplit(brackets,\
    \ \">>>\")\n  \n  num_opens <- 0\n  num_closes <- 0\n  \n  # for each opening\
    \ bracket pair...\n  for (i in seq_along(bracket_pairs)) {\n    num_opens <- num_opens\
    \ + 1\n    \n    # if the closing bracket for this opening bracket pair has not\
    \ yet been identified...\n    if (!has_bracket_pair(list(bracket_pairs[[i]], bracket_pairs[[i+1]])))\
    \ {\n      num_closes <- num_closes + 1\n      break\n    }\n  }\n  \n  # if this\
    \ count is not even...\n  if (num_opens %% 2 == 1) {\n    return(FALSE)\n  }\n\
    \  \n  # if this count is not even...\n  if (num_closes %% 2 == 1) {\n    return(TRUE)\n\
    \  }\n  \n  # otherwise, check whether every opening bracket has a corresponding\
    \ closing bracket.\n  for (i in 1:(length(bracket_pairs) - 1)) {\n    \n    #\
    \ check if an opening bracket pair has a corresponding closing bracket pair.\n\
    \    if (!has_bracket_pair(list(bracket_pairs[[i]], bracket_pairs[[i+1]]))) {\n\
    \      return(FALSE)\n    }\n  }\n  \n  # return TRUE if every opening bracket\
    \ has a corresponding closing bracket.\n  return(TRUE)\n}\n\n", "\n  bracketing_correct\
    \ <- vector(mode=\"logical\", length(brackets))\n  bracketing_correct[1] <- FALSE\n\
    \  bracketing_correct[2] <- FALSE\n  bracketing_correct[3] <- FALSE\n  bracketing_correct[4]\
    \ <- FALSE\n  bracketing_correct[5] <- FALSE\n  bracketing_correct[6] <- FALSE\n\
    \  bracketing_correct[7] <- FALSE\n  bracketing_correct[8] <- FALSE\n  bracketing_correct[9]\
    \ <- FALSE\n  bracketing_correct[10] <- FALSE\n  bracketing_correct[11] <- FALSE\n\
    \  bracketing_correct[12] <- FALSE\n  bracketing_correct[13] <- FALSE\n  bracketing_correct[14]\
    \ <- FALSE\n  bracketing_correct[15] <- FALSE\n  bracketing_correct[16] <- FALSE\n\
    \  bracketing_correct[17] <- FALSE\n  bracketing_correct[18] <- FALSE\n  bracketing_correct[19]\
    \ <- FALSE\n  bracketing_correct[20] <- FALSE\n  bracketing_correct[21] <- FALSE\n\
    \  bracketing_correct[22] <- FALSE\n  bracketing_correct[23] <- FALSE\n  bracketing_correct[24]\
    \ <- FALSE\n  bracketing_correct[25] <- FALSE\n  bracketing_correct[26] <- FALSE\n\
    \  bracketing_correct[27] <- FALSE\n  bracketing_correct[28] <- FALSE\n  bracketing_correct[29]\
    \ <- FALSE\n  bracketing_correct[30] <- FALSE\n  bracketing_correct[31] <- FALSE\n\
    \  bracketing_correct[32] <- FALSE\n  bracketing_correct[33] <- FALSE\n  bracketing_correct[34]\
    \ <- FALSE\n  bracketing_correct[35] <- FALSE\n  bracketing_correct[36] <- FALSE\n\
    \  bracketing_correct[37] <- FALSE\n  bracketing_correct[38] <- FALSE\n  bracketing_correct[39]\
    \ <- FALSE\n  bracketing_correct[40] <- FALSE\n  bracketing_correct[41] <- FALSE\n\
    \  bracketing_correct[42] <- FALSE\n  bracketing_correct[43] <- FALSE\n  bracketing_correct[44]\
    \ <- FALSE\n  bracketing_correct[45] <- FALSE\n  bracketing_correct[46] <- FALSE\n\
    \  bracketing_correct[47] <- FALSE\n  bracketing_correct[48] <- FALSE\n  bracketing_correct[49]\
    \ <- FALSE\n  bracketing_correct[50] <- FALSE\n  bracketing_correct[51] <", "\n\
    \  opens <- gregexpr('<', brackets)\n  closes <- gregexpr('>', brackets)\n  any(sapply(1:length(opens),\
    \ function(i) {\n    all(c(opens[i], closes[i]) == opens[-i])\n  }))\n}\n", "\n\
    \  bracket_opens <- gregexpr(\"<\", brackets)\n  bracket_closes <- gregexpr(\"\
    >\", brackets)\n  length(bracket_opens) == length(bracket_closes)\n}\n", "\n \
    \ if(length(brackets) != 0){\n    i <- 1\n    while(i < length(brackets)){\n \
    \     if(brackets[i] == '<') i <- i + 1\n      if(brackets[i] == '>') i <- i +\
    \ 1\n      if(i != length(brackets)) i <- i + 1\n    }\n    return(TRUE)\n  }\n\
    \  return(FALSE)\n}\n", "\n  n <- nchar(brackets)\n  brackets <- gsub(\"[<>]\"\
    , \"\", brackets)\n  return(all(sapply(1:n, bracketed) <- brackets))\n}\n</cell>\n\
    <text>\nPutting it all together\nNow we can define functions to run each of the\
    \ analyses and display the results:\n\n\n</text>\n<cell>\nrun_analysis <- function(x)\
    \ {\n  bracket_count <- sum(unlist(strsplit(x, \"<\")))\n  bracketing_correctness\
    \ <- correct_bracketing(x)\n  return(list(bracket_count = bracket_count, \n  \
    \            bracketing_correctness = bracketing_correctness))\n}\n</cell>\n<text>\n\
    Now we can run each of the analyses and display the results:\n\n\n</text>\n<cell>\n\
    run_analysis(expressions)\n</cell>\n<text>\nWhich of the analyses above is correct?\n\
    \n\n</text>\n<cell>\nrun_analysis(expressions[[1]])\n</cell>\n<cell>\nrun_analysis(expressions[[2]])\n\
    </cell>\n<cell>\nrun_analysis(expressions[[3]])\n</cell>\n<cell>\nrun_analysis(expressions[[4]])\n\
    </cell>\n<text>\nHow do we know? We can see from the results that expressions\
    \ with many nested brackets are incorrect. On the other hand, expressions with\
    \ simple brackets are correctly bracketned. So there are some cases where we can\
    \ disprove the hypothesis that the brackets are correct.\n\nHow do we know if\
    \ brackets are correlated? We can use functions to help us find out:\n\n\n</text>\n\
    <cell>", "\n\tcorrect_brackets <- function(x){\n\t\tcount <- 0\n\t\tfor (i in\
    \ 1:length(x)){\n\t\t\tcount <- count + 1\n\t\t\tif (x[i] == '<'){\n\t\t\t\tif\
    \ (x[i+1] == '>'){\n\t\t\t\t\treturn (FALSE)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x[i]\
    \ == '>'){\n\t\t\t\tif (x[i-1] == '<'){\n\t\t\t\t\treturn (FALSE)\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t\tif (count == length(x)){\n\t\t\treturn (TRUE)\n\t\t}\n\t}\n\
    \tapply(strsplit(brackets, split=' '), 1, correct_brackets)\n}\n", "\n  brackets\
    \ <- brackets[[1]]\n  result <- ! (brackets == '<') & ! (brackets == '>')\n  return(result)\n\
    }\n", "\n  matches <- brackets\n  opens <- str_match(brackets, \"<\")\n  closes\
    \ <- str_match(brackets, \">\")\n  for(i in 1:length(opens)) {\n    if(opens[i]\
    \ != closes[i]) {\n      matches[i] = FALSE\n    }\n  }\n  return(all(matches))\n\
    }\n</code>\nYou can then use the function as following:\n<code>\nx <- c('<', '<<',\
    \ '<<<', '<<<>>>', '<')\ncorrect_bracketing(x)", "\n  opens <- gregexpr(\"\\\\\
    <\", brackets)\n  closes <- gregexpr(\"\\\\>\", brackets)\n  nOpen <- length(opens)\n\
    \  nClose <- length(closes)\n  \n  for(i in 1:nClose) {\n    \n    if(opens[[i]\
    \ - 1] == closes[[i]] - 1) {\n      opens[[i]] <- opens[[i]] + 1\n      closes[[i]]\
    \ <- closes[[i]] + 1\n    }\n    \n  }\n  \n  return(all(opens[-nClose] == closes[-nOpen]))\n\
    }\n", "\n  # If there is one opening bracket to one closing bracket, then\n  #\
    \ all brackets are correct.\n  return(length(brackets) == 1 &&\n         startsWith(brackets,\
    \ \"<\") &&\n         endsWith(brackets, \">\"))\n}\n</cell>\n<cell>\ncorrect_bracketing(\"\
    <\")\n</cell>\n<cell>\ncorrect_bracketing(\"<>\")\n</cell>\n<cell>\ncorrect_bracketing('<<><>>')\n\
    </cell>\n<cell>\ncorrect_bracketing('><<>')\n</cell>\n<cell>", "\n  if (length(brackets)\
    \ != 2) return(FALSE)\n  result <- FALSE\n  brackets <- gsub(\"[<>]\", \"\", brackets)\n\
    \  for (i in 1:length(brackets)) {\n    open <- brackets[i]\n    if (brackets[i\
    \ + 1] != open) return(FALSE)\n  }\n  return(TRUE)\n}\n</cell>\n<text>\nQ3. How\
    \ many of the following pairs of brackets are correctly nested?\n\n( ( ) ) ()\n\
    ( ( ( ) ) )\n( ( ( ) ( ) ) )\n( ( ()) )\n\n</text>\n<text>\nAns:\n5\n4\n3\n2\n\
    1\n\n</text>\n<text>\nQ4. How many of the following pairs of brackets are correctly\
    \ nested?\n\n( ( ) ( ) ) ( ) () ( ) ( ( ( ) ) ) ( ) ( ( ( ( ) ) ) )\n( ( ( ) (\
    \ ) ) ( ) )\n\n</text>\n<text>\nAns:\n5\n4\n\n</text>\n<text>\nQ5. Given the string\
    \ $A$, which of the following expressions is correct?\n\n( ( ( ) ) )\n( ( ( (\
    \ ) ) ( ) ) )\n\n</text>\n<text>\nAns:\nA\nA\n\n</text>\n<text>\nQ6. Write a program\
    \ that prints the letters of strings that start with 'A'.\n\n</text>\n<text>\n\
    Ans: \nA\nB\nC\n...\nJ\nK\n...\n\n</text>\n<text>\nQ7. Write a program that prints\
    \ the letters of strings that start with 'A' that end in 'Y'.\n\n</text>\n<text>\n\
    Ans: \nA\nB\nC\n...\nJ\nK\n...\n\n</text>\n<text>\nQ8. Write a program that prints\
    \ the letters of strings that start with 'A' that end in 'Y' that end in 'Z'.\n\
    \n</text>\n<text>\nAns: \nA\nB\nC\n...\nJ\nK\n...\n\n</text>\n<text>\nQ9. Write\
    \ a program that prints the letters of strings that start with 'A' that end in\
    \ 'Y' that end in 'Z' that end in 'A'.\n\n</text>\n<text>\nAns: \nA\nB\nC\n...\n\
    J\nK\n...\n\n</text>\n<text>\nQ10. Write a program that prints the letters of\
    \ strings that start with 'A' that end in 'Y' that end in 'Z' that end in 'A'\
    \ that end in 'B'.\n\n</text>\n<text>\nAns: \nA\nB\nC\n", "\n  paste(grepl(\"\\\
    \\<\", brackets), collapse = \"|\")\n}\n</cell>\n<text>\nNow we can write a function\
    \ to validate bracketing\n\n\n</text>\n<cell>", "\n  # Find pairs of opening and\
    \ closing brackets\n  bracket_pairs <- strsplit(brackets, '<-')\n  # Check that\
    \ every pair has exactly one opening bracket and one closing bracket\n  length(unique(sapply(bracket_pairs,\
    \ length)) == 2)\n}\n", "\n  brackets <- brackets == \"<\" # brackets is a string\
    \ of \"<\" and \">\".\n  sapply(brackets, \n         function(bracket) all(grepl(\"\
    \\\\<[<>]\\\\>\", bracket)))\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe second\
    \ argument of `grepl` is supposed to be a regular expression, and should be `\"\
    <>\"`. Your example fails for me (I get a `character(0)`).\n<|/ c |>\n<| c |>\n\
    Thanks, I edited to fix that. I was just testing my code out and forgot to change\
    \ the backslashes to forward slashes.\n<|/ c |>\n<| c |>\nThanks, your answer\
    \ is much cleaner. I upvoted it. The other answers don't seem to do the job, as\
    \ they fail to recognize \"<<>>\" as a valid string, so I suspect that my original\
    \ question was misleading. I also tested my code by passing the string \"<<>>\"\
    \ and your function returns `FALSE`.\n<|/ c |>\n<| c |>\nGood catch! I didn't\
    \ think of that case. It should work now. I changed the regex to only match \"\
    <>\" and not \"<>\" at the end so it will return `TRUE` for `<<>>` and \"<<<>>\"\
    \ as well.\n<|/ c |>\n<| a tags=r,string |>\nYou probably want to use the stringr\
    \ package for this.  Here's an example with a few more test cases...\n<code>\n\
    library(stringr)", "\n  brackets <- gsub('>', '\\\\><', brackets)\n  brackets\
    \ <- gsub('<', '\\\\<\\\\<', brackets)\n  brackets <- gsub('(', '\\\\(\\\\<\\\\\
    <', brackets)\n  brackets <- gsub(')', '\\\\<\\\\>\\\\<', brackets)\n  brackets\
    \ <- gsub('\\\\<\\\\<', '\\\\<\\\\<', brackets)\n  brackets <- gsub('\\\\>\\\\\
    >', '\\\\>\\\\>', brackets)\n  return(TRUE)\n}\n", "\n  # Remove '<' and '>' from\
    \ brackets\n  brackets_no_lt <- gsub(\"<\", \"\", brackets)\n  brackets_no_gt\
    \ <- gsub(\">\", \"\", brackets)\n\n  # If brackets_no_lt has a closing bracket\
    \ in it, return FALSE\n  # If brackets_no_gt has a closing bracket in it, return\
    \ TRUE\n  return(as.logical(\n    !grepl(\n      paste0(\"\\\\<$\", brackets_no_lt),\n\
    \      paste0(\"\\\\>$\", brackets_no_gt)\n    )\n  ))\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThat looks like a good solution, but I can't get it to work on my machine.\
    \  I get `Error in grepl(paste0(\"\\\\<$\", brackets_no_lt),  : \n  invalid regular\
    \ expression '\\<$', reason 'Missing ')''`\n<|/ c |>\n<| c |>\nDid you copy my\
    \ code exactly?  I copy-pasted it and it works for me.  Did you copy the `<` back\
    \ into the code as well?  I left it in.\n<|/ c |>\n<| c |>\nIt works now, but\
    \ I'm not sure why.  When I copy-paste your code into a new R session and run\
    \ it, I get an error.  When I copy and paste it into your code, I get the error\
    \ above.  Any idea why?\n<|/ c |>\n<| c |>\nOkay, I thought it might be an issue\
    \ with my R install, but I tried that and it still didn't work.  My next step\
    \ was to just use Python's built-in 're' module to do the same thing.  In Python,\
    \ I used `import re`, then `re.sub(r'\\<+', \"\", brackets)`.  Then I got this\
    \ error: `TypeError: expected string or buffer`\n<|/ c |>\n<| c |>\nAh, I see\
    \ what you're doing now.  You were removing the < symbol from each bracket, but\
    \ then you needed to remove any trailing < symbols after the last > symbol.  I've\
    \ updated the code to fix that.  Does that work for you?\n<|/ c |>\n<| a tags=string,regex,python,r\
    \ |>\nI made a little script for you, hope this helps :)\n<code>", "\n  opening_close\
    \ <- gregexpr(\"\\\\<\", brackets)\n  if(opening_close[1] == -1) {\n    return(FALSE)\n\
    \  }\n  closing_open <- gregexpr(\"\\\\>\", brackets)\n  if(closing_open[1] ==\
    \ -1) {\n    return(FALSE)\n  }\n  return(opening_close[1] > closing_open[1])\n\
    }\n</cell>\n<text>\nTest Cases\nInputs:\n\n\"<<><>>\"\n\"<><<>\"\n\"<<<><>><><>>\"\
    \n\nExpected Outputs:\n\nFALSE\nTRUE\nTRUE\n\n</text>\n<cell>", "\n  brackets\
    \ <- gsub(\"[<>]\", \"\", brackets)\n  brackets <- gsub(\"^$\", \"\", brackets)\n\
    \  brackets <- gsub(\"[<]+\", \"\", brackets)\n  brackets <- gsub(\"[>]+\", \"\
    \", brackets)\n  return(length(brackets) == 0)\n}\n", "\n  brackets <- gsub(\"\
    [<>]\", \"\", brackets)\n  brackets <- strsplit(brackets, \"\")[[1]]\n  \n  for\
    \ (i in seq_along(brackets)) {\n    if (brackets[i] != brackets[i - 1]) {\n  \
    \    return (FALSE)\n    }\n  }\n  return (TRUE)\n}\n</cell>\n<text>\nLet's apply\
    \ the function to our bracketed text.  As a simple test, we'll use some text with\
    \ four brackets, but it should work with any bracket-counts given to us by the\
    \ function as long as the function remains consistent:\n\n\n</text>\n<cell>\n\
    text_with_brackets <- \"The quick <brown> fox jumps <over> the <lazy> dog. \"\n\
    bracket_count <- 4\n</cell>\n<cell>\ncorrect_bracketing(text_with_brackets)\n\
    </cell>\n<text>\nNow, let's count how many times each bracket appears in the text.\
    \  We'll make a simple helper function to do this for us:\n\n\n</text>\n<cell>",
  "\n  brackets <- unlist(strsplit(brackets, split='<'))\n  all(unlist(lapply(brackets,\
    \ function(x) gsub('>', '', x) == ''))) & \n    all(unlist(lapply(brackets, function(x)\
    \ gsub('</', '', x) == ''))) &\n    all(unlist(lapply(brackets, function(x) gsub('\\\
    \\>', '', x) == ''))) & \n    all(unlist(lapply(brackets, function(x) gsub('\\\
    \\</', '', x) == ''))) &\n    all(unlist(lapply(brackets, function(x) gsub('\\\
    \\>', '', x) == ''))) & \n    all(unlist(lapply(brackets, function(x) gsub('\\\
    \\<', '', x) == '')))\n}\n", "\n    paste0(brackets == \"<\", \"</%s>\" % paste0(brackets,\
    \ \"=\"))\n}\n", "\n  matches <- gregexpr('\\\\<', brackets)\n  matches <- as.integer(matches)\
    \ - 1\n  return(all(matches > 0))\n}\n", "\n  bracketing <- 0\n  brackets <- strsplit(brackets,\
    \ \"\")\n  for(i in 1:length(brackets)){\n    if(brackets[[i]] %in% c(\"<\", \"\
    >\")){\n      bracketing <- bracketing + 1\n    } \n  }\n  return(bracketing ==\
    \ 0)\n}\n</cell>\n<text>\nQuiz Question: Correct bracketing of string \"<<<>>>.\n\
    We are allowed to change the input string in place, but we must return the original\
    \ string.\n\nTest your function on the string \"<<<>>>.\" and some example inputs\
    \ to check your function.\n\n\n</text>\n<cell>", "\n  opening_counter <- 0\n \
    \ closing_counter <- 0\n  for (i in 1:length(brackets)) {\n    if (brackets[i]\
    \ == '<') {\n      opening_counter <- opening_counter + 1\n    }\n    else if\
    \ (brackets[i] == '>') {\n      closing_counter <- closing_counter + 1\n    }\n\
    \  }\n  return (opening_counter < closing_counter)\n}\n</code>\n<|/ a tags=r,text,parsing\
    \ |>\n<| c |>\nNice use of regular expressions and recursion to avoid having to\
    \ write your own state machine.\n<|/ c |>\n<| c |>\nVery nice. Thanks for the\
    \ suggestion!\n<|/ c |>\n<| a |>\nThe package igraph has a function parse.graph.\n\
    <code>\nigraph::parse.graph(\"<><>\", directed=TRUE)\nigraph::parse.graph(\"<><><>\"\
    , directed=TRUE)\n</code>\n<|/ a dscore=4 tags=r,text,parsing |>\n<| c |>\nThis\
    \ is great. Thanks for the suggestion\n<|/ c |>\n<| a tags=r,text,parsing |>\n\
    I like the idea of using regular expressions to parse these kinds of problems,\
    \ but I also believe that if your data is regularly structured enough, using the\
    \ regular expressions package can make it pretty simple. For example, here's a\
    \ function that parses your example text and returns a list of the parsed numbers:\n\
    <code>\nlibrary(gsubfn)\nparse.text <- function(text) {\n    re <- \"([0-9]+)|([0-9]+<)|([0-9]+>)\"\
    \n    gsubfn(pattern = re,\n           replacement = c(list(\"\\\\1\"), list(\"\
    <\"), list(\"\\\\1>\"), list(\">\")),\n           x = text)\n}\n\nparse.text(\"\
    1234<567>890\")", "\n  brackets <- stringr::str_split(brackets, \"[<]\", simplify\
    \ = TRUE)\n  apply(brackets, 2, function(x) all(stringr::str_split(x, \"[>]\"\
    , simplify = TRUE) == \"\"))\n}\n", "\n  bracket_pairs <- unlist(str_extract_all(brackets,\
    \ '<.*>'))\n  all_brackets <- sapply(bracket_pairs, length)\n  any_brackets <-\
    \ sapply(bracket_pairs, length)\n  return(all(any_brackets == 1 & all_brackets\
    \ == 1))\n}\n</cell>\n<text>\n3.2.1. Question 2\nThe following function takes\
    \ in a string and calculates the total number of lower case and upper case letters\
    \ in the string. Also it counts the total number of consonants in the string.\n\
    \nThe function should have an output similar to the following.\n\n input  output\
    \ \n\n hello  6 \n hEllo  5 \n HellO  4 \n HeLLo  4 \n hEllO  4 \n Hello  5 \n\
    \ hEllo  5 \n HeLLo  5 \n hEllO  5 \n HeLlO  5 \n helLO  6 \n hellO  6 \n hello\
    \  6 \n Hello  6 \n hEllo  6 \n HeLLo  6 \n hEllO  6 \n HeLlO  6 \n helLO  6 \n\
    \ hellO  6 \n HeLlO  6 \n HeLlO  6 \n\n\n</text>\n<cell>", "\n  brackets <- as.character(brackets)\n\
    \  # Return TRUE if all brackets have corresponding closing bracket.\n  # Otherwise\
    \ return FALSE.\n  return(all(unlist(strsplit(brackets, '<-')) == unlist(strsplit(brackets,\
    \ '>-'))))\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
