name: HumanEval_113_odd_count
language: r
prompt: "# Given a list of strings, where each string consists of only digits, return\
  \ a list.\n# Each element i of the output should be \"the number of odd elements\
  \ in the\n# string i of the input.\" where all the i's should be replaced by the\
  \ number\n# of odd digits in the i'th string of the input.\n# >>> odd_count(c('1234567'))\n\
  # c('the number of odd elements 4n the str4ng 4 of the 4nput.')\n# >>> odd_count(c('3',\
  \ '11111111'))\n# c('the number of odd elements 1n the str1ng 1 of the 1nput.',\
  \ 'the number of odd elements 8n the str8ng 8 of the 8nput.')\nodd_count <- function(lst)\
  \ {"
tests: "test_humaneval <- function() {\ncandidate <- odd_count\n    if(!identical(candidate(c('1234567')),\
  \ c('the number of odd elements 4n the str4ng 4 of the 4nput.'))){quit('no', 1)}\n\
  \    if(!identical(candidate(c('3', '11111111')), c('the number of odd elements\
  \ 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of\
  \ the 8nput.'))){quit('no', 1)}\n    if(!identical(candidate(c('271', '137', '314')),\
  \ c('the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd\
  \ elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng\
  \ 2 of the 2nput.'))){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  for(i in 1:length(lst)) {\n    for(j in 1:length(lst[[i]])) {\n\
    \      lst[[i]][j] <- nchar(as.character(lst[[i]][j]))\n      lst[[i]][j] <- ifelse(lst[[i]][j]\
    \ %% 2 == 1, paste(\"number of odd elements \", nchar(lst[[i]][j]), \" in the\
    \ str\", j, \" of \", lst[[i]]), \"\")\n    }\n  }\n  return(lst)\n}\n", "\n \
    \ odd_counts <- sapply(lst, function(x) length(gregexpr('\\\\d', x)))\n  c(paste0(length(gregexpr('\\\
    \\d', lst[1])) / sum(odd_counts), \"n the str\", length(gregexpr('\\\\d', lst[1]))\
    \ / sum(odd_counts), \"of the \", length(gregexpr('\\\\d', lst[1])) / sum(odd_counts),\
    \ \"nput.\"))\n}\n", "\n  s <- lapply(lst,\n              function(x) sapply(x,\
    \ function(y) length(gregexpr(\"[0-9]\", y)), USE.NAMES=TRUE))\n  res <- lapply(s,\n\
    \                function(x) sum(x[x %% 2 == 1]) / length(x))\n  c(paste(\"the\
    \ \", length(s) * \"n\", \" of the \", length(lst) * \"n\", \" is \", res[[1]]),\n\
    \    paste(\"the \", length(s) * \"n\", \" of the \", length(lst) * \"n\", \"\
    \ is \", res[[2]]))\n}\n", "\n  lst <- strsplit(lst, \"\")\n  vec <- unlist(lst)\n\
    \  sapply(seq_along(vec), function(i) length(grep(\"^\\\\d\", vec[i]))) / length(vec)\n\
    }\n", "\n  out <- rep(NA_character_, length(lst))\n  \n  for (i in seq_along(lst))\
    \ {\n    \n    n <- sum(strsplit(lst[[i]], \"\")[[1]] %% 2)\n    \n    out <-\
    \ c(out, paste(n, \"n the str\", n, \"of\", lst[[i]], \".\"))\n  }\n  \n  return(out)\n\
    }\n", "\n    lapply(lst, function(i) {\n        n <- length(which(sapply(i, function(x)\
    \ x %% 1L %% 2L == 0L))) + 1L\n        c(paste0(\"the number of odd elements \"\
    , n, \" of the \", i, \" input.\"))\n    })\n}\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nI like your first answer better than the others, but I wonder if there's\
    \ a way to shorten it using `purrr`.  For instance, `odd_count <- purrr::pmap(lst,\
    \ ~sum(!!sapply(., `%in%`, c(1,2))))`.\n<|/ c |>\n<| c |>\n-- that is a really\
    \ nice idea.  I added a second version to my answer using `purrr`.\n<|/ c |>\n\
    <| c |>\nthanks, I like that better too.\n<|/ c |>\n<| a dscore=1 |>\nA vectorized\
    \ solution\n<code>\nx <- c('12', '122', '124', '1233', '123', '1223', '33', '3333',\
    \ '334', '333123', '33123')\nsapply(x, function(z) sum(z%%1L == 0L)) ", "\n  #\
    \ first we turn the strings into integers (but we don't care about the\n  # remainder\
    \ of the integer)\n  str_ints <- sapply(lst, as.integer)\n  # then we sum them\
    \ up into one number per string\n  str_sum <- sapply(str_ints, function(i) sum(i\
    \ %% 2))\n  # then we get the odd numbers of these numbers\n  str_odds <- str_ints[str_sum\
    \ != 0]\n  return(paste('the number of odd elements ', str_odds, ' of the ', length(lst),\
    \ ' string'))\n}\n", "\n  lst <- sort(lst)\n  count <- 0\n  for (s in seq_along(lst))\
    \ {\n    count <- count + (length(gregexpr('\\\\d', s)[[1]]) - 1)\n  }\n  c(paste0('the\
    \ number of odd elements ', count, 'n the str', length(lst), 'of the ', length(lst),\
    \ 'input.'))\n}\n", "\n  # The code below should work (but doesn't).\n  #   odd_count\
    \ <- function(lst) {\n  #   sapply(lst,function(x) {\n  #    odd_digits <- function(x)\
    \ {\n  #    length(gregexpr(\"[[:digit:]]\",x)[[1]])\n  #    }\n  #    num <-\
    \ sapply(x,odd_digits)\n  #    num[is.na(num)] <- 0\n  #    num[is.na(num)] <-\
    \ 0\n  #    sum(num)\n  #    })\n  #    }\n  sapply(lst, function(x) sapply(x,\
    \ odd_digits))\n}\n", "\n  output <- list()\n  for (i in 1:length(lst)) {\n  \
    \  counts <- list()\n    for (j in 1:length(lst[[i]])) {\n      if (j == 1) {\n\
    \        counts[[j]] <- length(lst[[i]][j])\n      } else {\n        if (lst[[i]][j]\
    \ != lst[[i]][j-1]) {\n          counts[[j]] <- counts[[j-1]] + 1\n        } else\
    \ {\n          counts[[j]] <- counts[[j]]\n        }\n      }\n    }\n    output\
    \ <- c(output, list(list(counts)))\n  }\n  return(output)\n}\n</cell>\n<text>\n\
    4.2 A more general version of odd_count\nWe rewrite the odd_count function above\
    \ to count all elements that are odd, regardless of the position of that element\
    \ in the string we give it. We do this by counting all the elements in the string\
    \ we give it, then subtracting the number of those elements that are equal to\
    \ the element we are counting.\n\nWe can write this function in more efficient\
    \ R code, using lapply (for loops don't work as well when we want to keep track\
    \ of the counts) instead of nested for loops, and we can also use the fact that\
    \ R has some very useful functions for dealing with lists.\n\n\n</text>\n<cell>",
  "\n  sapply(lst, function(x) length(setdiff(str_split(x, \"\")[[1]], \"0\")))\n\
    }\n</code>\nThis should work as expected:\n<code>\n> odd_count(c('1234567'))\n\
    [1] \"the number of odd elements 4n the str4ng 4 of the 4nput.\"\n[2] \"the number\
    \ of odd elements 1n the str1ng 1 of the 1nput.\"\n[3] \"the number of odd elements\
    \ 8n the str8ng 8 of the 8nput.\"\n> odd_count(c('3', '11111111'))\n[1] \"the\
    \ number of odd elements 1n the str1ng 1 of the 1nput.\"\n[2] \"the number of\
    \ odd elements 8n the str8ng 8 of the 8nput.\"\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThe solution is cool, although it seems a little bit weird that you can\
    \ replace each element in a vector and have it remain unchanged. This is not the\
    \ case in Python where each element is replaced by a new value, not an index.\
    \ Strange but true.\n<|/ c |>\n<| c |>\nYou can read it that way in the docs of\
    \ `replace`. It will replace each element by its index in the vector. `replace`\
    \ does not return a vector in R, it replaces one value with another value in a\
    \ vector. `sapply` does return a new vector, even if it has the same length as\
    \ the input.\n<|/ c |>\n<| c |>\nYes, that's what I meant by \"not an index\"\
    . I suppose you could say it replaces an index by its value, but it's kinda obvious\
    \ that it replaces its index with its value. :)\n<|/ c |>\n<| a dscore=2 tags=string,character,r,regex\
    \ |>\nHere's a quick solution that uses sub with grepl to count the number of\
    \ odd characters:\n<code>\nn <- c(\"1234567\", \"3\", \"11111111\")\n\nsapply(n,\
    \ function(x) sum(grepl(\"1\", x)))", "\n  sapply(lst, function(x) length(str_split(x,\
    \ \"\")[[1]][str_split(x, \"\")[[1]] == '1']))\n}\n", "\n  num <- sapply(lst,\
    \ function(x) {\n    length(grep('[1-9]', x))\n  })\n  return(sprintf('the number\
    \ of odd elements %s of the %s', num, unlist(lst)))\n}\n", "\n    result <- c()\n\
    \    for (el in lst) {\n        result <- c(result, strsplit(el, \"(\\\\d+)\"\
    )[[1]][1])\n    }\n    return(result)\n}\n</cell>\n<cell>", "\n  stopifnot(length(lst)\
    \ == length(unlist(strsplit(rep(\" \", length(lst)), \"\"))), \"The length of\
    \ input list does not equal the length of its split string.\")\n  \n  v <- as.vector(lst)\n\
    \  \n  return(list(c(length(grep(\"^\\\\d+$\", v, fixed = TRUE)), length(grep(\"\
    ^\\\\d+$\",\n                                                                \
    \     v[!is.na(v)],\n                                                        \
    \             fixed = TRUE))))\n}\n", "\n  lst <- unlist(lst)\n  nr <- numeric(length(lst))\n\
    \  nr <- ifelse(is.na(as.integer(gsub(\"[^0-9]\", \"\", lst))), 0, nr)\n  nr <-\
    \ ifelse(is.na(as.integer(gsub(\"[0-9]\", \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"\
    [[:digit:]]\", \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:alpha:]]\"\
    , \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:punct:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:space:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:blank:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:cntrl:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:graph:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:lower:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:print:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:upper:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:punct:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:space:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:blank:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:cntrl:]]\",\
    \ \"\", lst))), 0, nr)\n  nr <- ifelse(is.na(as.integer(gsub(\"[[:graph:]]\",\
    \ \"\", lst))), 0, nr)\n", "\n  out <- c()\n  for (i in seq_along(lst)) {\n  \
    \  if (length(grep(\"[[:digit:]]\", lst[i])) != 0) {\n      n_odd <- grep(\"[[:digit:]]\"\
    , lst[i])\n      n_even  <- length(grep(\"[[:digit:]]\", lst[i], fixed = T))\n\
    \      out <- c(out, paste(paste(n_odd, \"odd\", sep = \"n\"), \" elements\",\
    \ n_even, \" \", length(grep(\"[[:digit:]]\", lst[i], fixed = T)), \n        \
    \               \" \", grep(\"[[:digit:]]\", lst[i], fixed = T), \"n the str\"\
    , n_even, \"of the \", n_even, \"nput.\"))\n    } else {\n      out <- c(out,\
    \ paste(paste(i, \"even\", sep = \"n\"), \" elements\", length(grep(\"[[:digit:]]\"\
    , lst[i])), \" \", grep(\"[[:digit:]]\", lst[i]), \"n the str\", length(grep(\"\
    [[:digit:]]\", lst[i], fixed = T)), \n                       \" \", grep(\"[[:digit:]]\"\
    , lst[i], fixed = T), \"n the str\", length(grep(\"[[:digit:]]\", lst[i], fixed\
    \ = T)), \"nput.\"))\n    }\n  }\n  return(out)\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis answer was very helpful as well as providing me with inspiration\
    \ in solving my own question. Thanks!\n<|/ c |>\n<| a tags=r dscore=1 |>\nI made\
    \ a couple changes to your function to make this work. I used the stringi package,\
    \ and used the stri_count function instead of your custom function. I also used\
    \ the sprintf function instead of paste which seemed to make the code more readable.\
    \ \n<code>\nodd_count <- function(lst) {\n  out <- c()\n  for (i in seq_along(lst))\
    \ {\n    if (length(grep(\"[[:digit:]]\", lst[i])) != 0) {\n      n_odd <- stri_count(lst[i],\"\
    [[:digit:]]\")\n      n_even  <- length(grep(\"[[:digit:]]\", lst[i], fixed =\
    \ T))\n      out <- c(out, sprintf(\"the number of odd elements %dn the str%dng\
    \ %d of the %dnput.\", n_odd, n_even, n_even, n_even))\n    } else {\n      n_odd\
    \ <- i\n      n_even  <- length(grep(\"[[:digit:]]\", ", "\n  map(lst, ~str_count(tolower(.x),\
    \ paste0(\"[1oO]\", collapse = \"\")))\n}\n", "\n  num <- sum(strsplit(lst, \"\
    \\\\d\")[[1]] %% 2)\n  return(c(paste0(\"the number of odd elements \", num, \"\
    n the str\", num, \"of the \", lst), paste0(\"the number of odd elements \", num,\
    \ \"n the str\", num, \"of the \", lst)))\n}\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function sum_odd_digits which takes a character vector as a parameter and\
    \ returns a character vector consisting of the sum of the odd digits. For example,\
    \ if x <- c(\"123\", \"4567\", \"89\"), then your function should return c(\"\
    0\", c(\"1\", \"3\"), c(\"9\", \"11\")).\n\n</text>\n<cell>", "\n  count <- 0\n\
    \  for (digit in lst) {\n    count <- count + sum(strsplit(digit, '')[[1]][4]\
    \ %% 2)\n  }\n  return(c(paste('the number of odd elements ', count, ' of the\
    \ ', toString(lst), '.'), paste('the number of odd elements ', count, ' of the\
    \ ', toString(lst), '.')))\n}\n", "\n    if (length(lst) == 0)\n        NULL\n\
    \    else {\n        odd_lst <- list()\n        for (l in seq_along(lst)) {\n\
    \            odd_lst[[l]] <- length(strsplit(as.character(lst[l]), \"\")[[1]][sapply(strsplit(as.character(lst[l]),\
    \ \"\")[[1]], grepl, pattern = \"^\\\\d$\", perl = TRUE)] / 2)\n        }\n  \
    \      odd_count_as_string <- c(sapply(odd_lst, toString))\n        return(odd_count_as_string)\n\
    \    }\n}\n", "\n    apply(lst, 1, function(x)\n        paste(length(grep('[0-9]',\
    \ x)) %% 2, collapse = ''))\n}\n</code>\nFor this example, I've included some\
    \ test cases to show what it does.\n<code>", "\n  num <- 0\n  for (i in seq_along(lst))\
    \ {\n    x <- lst[i]\n    digits_num <- str_count(tolower(x), pattern = \"[0-9]\"\
    )\n    odd_num <- str_count(tolower(x), pattern = \"[0-9]\\\\D\")\n    if (digits_num\
    \ > 0) {\n      x <- paste0(\"the number of odd elements \", odd_num, \" in the\
    \ str\", i, \" of the \", i, \" input.\")\n    }\n    cat(paste(x, collapse =\
    \ \"\\n\"), \"\\n\")\n  }\n}\n", "\n  sapply(lst, function(x) sum(x %% 2) > 0)\n\
    }\n", "\n    lapply(lst, function(x) {\n        x <- sort(x);\n        x[x %%\
    \ 2 == 1]\n    }) %>% unlist %>% length\n}\n", "\n  if(\"character\" %in% class(lst))\
    \ {\n    stop(\"lst must be a character vector.\")\n  }\n  sapply(lst, function(x)\
    \ {\n    x <- gsub(\"\\\\d\", \"\", x)\n    length(x)\n  })\n}\n</cell>\n<cell>",
  "\n  sapply(lst, function(x) {\n    odd_str <- substr(x, 1, nchar(x)-1)\n    odd_str\
    \ <- ifelse(grepl(\"^\\\\d+$\", odd_str), paste(\"the number of odd elements \"\
    , length(grep(\"^\\\\d+$\", odd_str)), \" of the str\", nchar(odd_str), \" of\
    \ the str\", nchar(x), \".\"), odd_str)\n    return(odd_str)\n  })\n}\n</code>\n\
    <|/ a |>\n<| c |>\n`substr(x,1,nchar(x)-1)` could have worked too. But I like\
    \ your answer a lot more.\n<|/ c |>\n<| c |>\n, that would work, but I wanted\
    \ to convey the substr function can take negative starting points. It would be\
    \ interesting to know what kind of optimization it does behind the scenes.\n<|/\
    \ c |>\n<| c |>\nI think it takes advantage of R's vectorized operations to run\
    \ `grep` only once. `substr(x,1,nchar(x)-1)` would have worked too.\n<|/ c |>\n\
    <| c |>\n, you are right! I was too lazy to look into the source code. It does\
    \ look like it does some optimizations.\n<|/ c |>\n<| a dscore=2 |>\nHere's a\
    \ similar solution, using a vector instead of an sapply.\n<code>\nodd_count <-\
    \ function(x) {\n  y <- gregexpr(\"\\\\d+\", x)\n  x <- gsub(\"\\\\d+\", \"\"\
    , x)\n  c(paste(\"the number of odd elements \", length(unique(unlist(y))), \"\
    \ of the str\",\n         length(unique(unlist(y))), \" of the str\", nchar(x),\
    \ \".\"),\n    paste(\"the number of odd elements \", length(unique(unlist(y))),\
    \ \" of the str\",\n         length(unique(unlist(y))), \" of the str\", nchar(x),\
    \ \".\"))\n}\n\nodd_count(c(\"1\", \"2\", \"3\", \"4\", \"5\"))", "\n    result\
    \ <- numeric(length(lst))\n    for(i in seq_along(lst)) {\n        digits_cnt\
    \ <- sum(grepl(paste0(\"\\\\d\", i), lst)) * 2\n        result[i] <- paste(digits_cnt,\
    \ collapse = ' ')\n    }\n    result <- paste(result, collapse = '')\n    return(result)\n\
    }\n</code>\n<|/ a dscore=2 tags=r,regex |>\n<| c |>\nThis would be so much more\
    \ elegant if `grep` had an option to return the counts instead of the element\
    \ itself.\n<|/ c |>\n<| c |>\nThanks, I really appreciate it. I was trying to\
    \ do something like this with `grep`, but was not aware that `grepl` could give\
    \ the counts. Very useful tip.\n<|/ c |>\n<| a tags=r,regex |>\nHere is an answer\
    \ using a data.frame rather than a list.  Also using strsplit:\n<code>", "\n \
    \ \n  ret <- c('the number of odd elements ')\n  \n  for (i in 1:length(lst))\
    \ {\n    \n    if (lst[[i]] %% 2 == 1) {\n      ret <- c(ret, paste(length(lst[[i]])\
    \ %% 2, lst[[i]], sep = 'n'))\n    }\n  }\n  \n  c(ret, ' of the ', length(lst))\n\
    }\n</cell>\n<cell>", "\n    result <- c()\n    odd <- 0\n    for(i in seq_along(lst))\
    \ {\n        current <- gsub(\"[^0-9]\", \"\", lst[[i]])\n        odd <- odd +\
    \ length(current)\n        result <- c(result, paste(\"the number of odd elements\
    \ \", odd, \" \", lst[[i]], \".\", sep=\"\"))\n    }\n    result <- c(result,\
    \ paste(\"the number of odd elements \", odd, \" of the str\", length(lst), \"\
    th input.\", sep=\"\"))\n    return(result)\n}\n", "\n    odd_counts <- list()\n\
    \    for (i in seq_along(lst)) {\n        odd_counts[[i]] <- length(gregexpr(\"\
    \\\\d\", lst[[i]])[[1]])\n    }\n    out <- rep(NA_integer_, length(odd_counts))\n\
    \    for (i in seq_along(odd_counts)) {\n        out[i] <- paste(sprintf(\"the\
    \ number of odd elements %dn the str%d in str%d.\", odd_counts[[i]], i, i), collapse\
    \ = ' ')\n    }\n    return(out)\n}\n</cell>\n<cell>", "\n  sapply(lst, function(x)\
    \ {\n    x <- strsplit(x, split='')[[1]]\n    x[x %in% '1'] <- sum(x[x %in% '1'])\n\
    \    x[x %in% '2'] <- sum(x[x %in% '2'])\n    x[x %in% '3'] <- sum(x[x %in% '3'])\n\
    \    x[x %in% '4'] <- sum(x[x %in% '4'])\n    x[x %in% '5'] <- sum(x[x %in% '5'])\n\
    \    x[x %in% '6'] <- sum(x[x %in% '6'])\n    x[x %in% '7'] <- sum(x[x %in% '7'])\n\
    \    x[x %in% '8'] <- sum(x[x %in% '8'])\n    x[x %in% '9'] <- sum(x[x %in% '9'])\n\
    \    x\n  })\n}\n", "\n  odd_list <- list()\n  for (elem in seq_along(lst)) {\n\
    \    odd_list[elem] <- sum(grepl('(^| )1[13579]$', lst[[elem]]), 1)\n  }\n  return(odd_list)\n\
    }\n</cell>\n<cell>", "\n  if (length(lst) == 0) {\n    return(\"\")\n  }\n  n\
    \ <- length(lst)\n  odd_digits_total <- 0\n  for(i in 1:n) {\n    digits_i <-\
    \ unlist(str_split(lst[i], \"\"))\n    odd_digits_total <- odd_digits_total +\
    \ length(digits_i[digits_i %% 2 == 1])\n  }\n  return(paste0(\"the number of odd\
    \ elements \", odd_digits_total, \" the \", lst[n - 1], \" of the \", lst[n],\
    \ \".\"))\n}\n</code>\n<|/ a tags=string,r,count,character dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nodd_count <- function(x) sapply(str_split(x, \"\"), function(x)sum(x[x\
    \ %% 2 != 0] != 0))\n\nodd_count(c(\"1234567\"))", "\n  sapply(lst, function(x)\
    \ {\n    x <- trimws(gsub(\"^\\\\s+|\\\\s+$\", \"\", x))\n    if (!length(x))\
    \ {\n      return(numeric(0))\n    }\n    odds <- as.numeric(x) - as.integer(x)\n\
    \    length(unique(odds)[!duplicated(odds)])\n  })\n}\n", "\n  res <- c()\n  for(i\
    \ in seq_along(lst)){\n    res[i] <- lengths(strsplit(lst[[i]], \"\"))[[1]][3]\
    \ - 1\n  }\n  return(res)\n}\n", "\n  num <- rep(0,length(lst))\n  for(i in 1:length(lst)){\n\
    \    num[i] <- sum(grepl('[1-9]',lst[i]))\n  }\n  return(paste(num,'n the str',num,'of\
    \ the ',num,'nput.',sep=\"\"))\n}\n</code>\n<|/ a dscore=2 tags=list,string,r,text-mining\
    \ |>\n<| a tags=list,string,r,text-mining dscore=2 |>\nAs I already pointed out\
    \ in my answer to a similar question you were already provided, an elegant and\
    \ compact solution based on data.table::fread:\n<code>\nfread(\"\n1  3\n2  6\n\
    3  7\n4 10\n5 13\n6 18\n7 23\n8 25\n9 28\n10 30\n11 33\n12 35\n13 38\n14 40\n\
    15 43\n16 46\n17 49\n18 53\n19 56\n20 59\n\")\n</code>\nProduces:\n<code>\n  \
    \ V1 V2\n1:  1  3\n2:  2  6\n3:  3  7\n4:  4 10\n5:  5 13\n6:  6 18\n7:  7 23\n\
    8:  8 25\n9:  9 28\n10: 10 30\n11: 11 33\n12: 12 35\n13: 13 38\n14: 14 40\n15:\
    \ 15 43\n16: 16 46\n17: 17 49\n18: 18 53\n19: 19 56\n20: 20 59\n</code>\nAs you\
    \ can see, the number of odd-numbers per string can be easily extracted from here.\n\
    <|/ a |>\n<| a |>\nHere's a way to do it using base R only:\n<code>\ndat <- read.table(text=\"\
    \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\", header=FALSE)\n\
    \napply(dat, 2, function(x) c(odd = sum(grepl(\"[1-9]\", x)), noodd = length(x)\
    \ - odd))\n", "\n  lapply(lst,\n         function(x) {\n           sapply(1:length(x),\
    \ function(y) {\n             nchar(gsub('\\\\d', '', x[y])) - (nchar(gsub('\\\
    \\D', '', x[y])) + 1)\n           })\n         },\n         USE.NAMES = FALSE)\n\
    }\n</code>\n<|/ a dscore=2 tags=r |>\n<| c |>\nThanks, but I get this error when\
    \ I try to run it: `Error in strsplit(x, \"(\") : non-character argument`\n<|/\
    \ c |>\n<| c |>\nSorry, I used `c` from the `stringr` package, since I couldn't\
    \ figure out how to convert `c(\"1\", \"2\", \"3\")` to a vector. `strsplit` was\
    \ expecting a character vector, so `c` had to be used.\n<|/ c |>\n<| c |>\nI've\
    \ fixed the error, but now I get this error when running it again: `Error in match.fun(FUN)\
    \ : argument \"FUN\" is missing, with no default`\n<|/ c |>\n<| c |>\nI forgot\
    \ to copy the function definition into the answer. Try again.\n<|/ c |>\n<| c\
    \ |>\nI've also fixed the bugs in my function.\n<|/ c |>\n<| a |>\nUsing strsplit\
    \ to split each string on \"(\", then subsetting those strings based on whether\
    \ they are numbers, and using nchar to count the number of numbers, then unlisting\
    \ those numbers to create the vector you are looking for:\n<code>\nlibrary(stringr)\n\
    \nodd_count <- function(x){\n  nchar(unlist(strsplit(x, \"(\", fixed = TRUE)))\n\
    }\n\nodd_count(\"1(22)3(33)4(44)\")", "\n  sapply(lst, function(x) {\n    sum(grepl(\"\
    1\", x) & grepl(\"9\", x))\n  })\n}\n", "\n  sapply(lst, function(x){\n    y <-\
    \ unlist(strsplit(x, \"\"))\n    y[!is.na(y)]\n  }) %>% \n    t() %>% \n    apply(1,\
    \ function(x){\n      sapply(seq_along(x), function(i){\n        sum(y[which(grepl(tolower(i),\
    \ y))])\n      })\n    })\n}\n</cell>\n<cell>", "\n    counts <- mapply(function(x)\
    \ length(gregexpr(\"[0-9]\", x)[[1]]), lst)\n    out <- mapply(function(x, c)\
    \ paste(sum(counts[c(lst[[x]]) - 1]) / c * 100),\n                  seq_along(lst),\
    \ counts, USE.NAMES = FALSE)\n    c(out, rep(NA, sum(counts) - length(out)))\n\
    }\n", "\n  n1 <- unlist(lapply(lst, function(x) length(gregexpr('[0-9]+', x)[[1]])),\
    \ use.names = F)\n  n2 <- unlist(lapply(lst, function(x) length(gregexpr('[0-9]+',\
    \ x)[[1]][x %% 2 == 1])), use.names = F)\n  n1 <- n1[length(n1) != 0]\n  n2 <-\
    \ n2[length(n2) != 0]\n  n3 <- length(lst)\n  paste(c('the number of odd elements\
    \ ', n1, ' of the str', n3, '.', 'the number of odd elements ', n2, ' of the str',\
    \ n3, '.'), sep = \"\")\n}\n</code>\nAnd a solution to the problem:\n<code>\n\
    f <- function(x)\n  c(odd_count(x), paste(x, '', collapse = ''))\n\ns <- c('9',\
    \ '1', '4', '1', '2', '3', '1', '6', '1', '8', '1', '2', '4', '1', '5', '1', '1',\
    \ '1', '8', '1', '1', '2', '1', '5', '1', '3', '1', '6', '1', '1', '2', '3', '1',\
    \ '4', '1', '2', '2', '4', '1', '5', '1', '1', '1', '8', '1', '1', '2', '1', '3',\
    \ '1', '6', '1', '1', '2', '4', '1', '5', '1', '1', '1', '8', '1', '1', '2', '1',\
    \ '3', '1', '6', '1', '1', '2', '4', '1', '5', '1', '1', '1', '8', '1', '1', '2',\
    \ '1', '3', '1', '6', '1', '1', '2', '4', '1', '5', '1', '1', '1', '8', '1', '1',\
    \ '2', '1', '3', '1', '6', '1', '1', '2', '4', '1', '5', '1', '1', '1', '8', '1',\
    \ '1', '2', '1', '3', '1', '6', '1', '1', '2', '4', '1', '5', '1', '1', '1', '8',\
    \ '1', '1', '2', '1', '3', '1', '6', '1', '1', '2', '4', '1', '5', '1', '1', '1',\
    \ '8', '1', '1', '2', '1', '3', '1', '6', '1', '1', '2', '4', '1', '5', '1', '1',\
    \ '1', '8', '1', '1', '2', '1', '3', '1', '6', '1', '1', '2', '4', '1', '5', '1',\
    \ '1', '1', '8', '1', '1', '2', '1', '3', '1', '6', '1', '1', '2', '4', '1', '5',\
    \ '1', '1', '1', '8', '1', '1', '2', '1', '3', '1', '6', '1', '1', '2', '4', '1',\
    \ '5', '1', '1', '1', '8', '1', '1', '2', '1', '3', '1', '6', '1', '1', '2', '4',\
    \ '1', '5', '1', '1', '1', '8', '1', '1', '2', '1', '3', '1', '6', '1', '1', '2',\
    \ '4', '1', '5', '1', '1', '1', '8', '1', '1', '2', '1', '3', '1', '6', '1', '1',\
    \ '2', '4', '1', '5', '1', '1', '1', '8', '1', '1', '2', '1', '3', '1', '6', '1',\
    \ '1', '2', '4', '1', '5', '1', '1', '1', '8', '1', '1', '2', '1', '3', '1', '6',\
    \ '1', '1', '2', '4', '1', '5', '1', '1', '1', '8', '1', '1', '2', '1', '3', '1',\
    \ '6', '", "\n  sapply(lst, function(s) {\n    gregexpr(\"\\\\d+\", s) %>% \n\
    \      lengths() %>% \n      length()\n  })\n}\n</code>\nThe above code works\
    \ for the sample cases you provided, but fails for some others. It should work\
    \ for any valid input (which it does).\n<|/ a |>\n<| c |>\nThank you, this works\
    \ perfectly. I also tried to simplify it a little and got the same result as yours.\
    \ `gregexpr(\"[0-9]+\", s) %>% lengths() %>% length()` works fine.\n<|/ c |>\n\
    <| c |>\nThe simplified version also works, but is less efficient. (The `gregexpr`\
    \ solution needs to make multiple calls to the `gregexpr` function.)\n<|/ c |>\n\
    <| c |>\nThanks so much, this is great.\n<|/ c |>\n<| a dscore=1 |>\nA little\
    \ late, but I found a way to do this with data.table. This can be done with one\
    \ function call and a couple of lines of code. \n<code>\nlibrary(data.table)\n",
  "\n  ns <- sapply(lst, length)\n  ns[!ns %in% 0]\n}\n\nodd_count_2 <- function(lst)\
    \ {\n  ns <- sapply(lst, length)\n  ns[!ns %in% 0]\n}\n", "\n  sapply(lst, function(x)\
    \ {\n    paste0(c('the number of odd elements ', nchar(x), ' the str', nchar(x),\
    \ ' of the ', nchar(x), 'input.'), collapse = ' ')\n  }, USE.NAMES = FALSE)\n\
    }\n", "\n  if (!lst)\n    stop(\"list must not be empty\")\n  n <- length(ls)\n\
    \  nchars <- function(x) {\n    n <- nchar(x)\n    is.numeric(n) ? n : stop(paste0(\"\
    string contains nondigits: \", x))\n  }\n  nchars <- Vectorize(nchars)\n  odd_elements\
    \ <- rep(NA_integer_, n)\n  for (i in 1:n) {\n    odd_elements[i] <- sum(grepl(\"\
    ^\\\\d+$\", lst[[i]]) & nchars(lst[[i]]))\n  }\n  return(list(c(paste0(\"the number\
    \ of odd elements \", nchar(lst)),\n                paste0(\" of the \", lst),\
    \ odd_elements)))\n}\n</code>\nNow we can write a new version of odd_count that\
    \ takes a function as argument to calculate the count of odd digits in each string.\n\
    <code>\nodd_count_by_function <- function(lst, func) {\n  if (!lst)\n    stop(\"\
    list must not be empty\")\n  n <- length(ls)\n  nchars <- function(x) {\n    n\
    \ <- nchar(x)\n    is.numeric(n) ? n : stop(paste0(\"string contains nondigits:\
    \ \", x))\n  }\n  nchars <- Vectorize(nchars)\n  odd_elements <- rep(NA_integer_,\
    \ n)\n  for (i in 1:n) {\n    odd_elements[i] <- func(lst[[i]])\n  }\n  return(list(c(paste0(\"\
    the number of odd elements \", nchar(lst)),\n                paste0(\" of the\
    \ \", lst), odd_elements)))\n}\n</code>\nWe can also write a new version of odd_count\
    \ that takes functions to calculate the count of odd digits in each string.\n\
    <code>\nodd_count_by_function <- function(lst, ...) {\n  if (!lst)\n    stop(\"\
    list must not be empty\")\n  n <- length(ls)\n  nchars <- function(x) {\n    n\
    \ <- nchar(x)\n    is.numeric(n) ? n : stop(paste0(\"string contains nondigits:\
    \ \", x))\n  }\n  nchars <- Vectorize(nchars)\n  odd_elements <- rep(NA_integer_,\
    \ n)\n  for (i in 1:n) {\n    odd_elements[i] <- sum(grepl(\"^\\\\d+$\", lst[[i]])\
    \ & nchars(lst[[i]]))\n  }\n  return(list(c(paste0(\"the number of odd elements\
    \ \", nchar(lst)),\n                paste0(\" of the \", lst), odd_elements)))\n\
    }\n</code>\nAnd ", "\n    n <- 0\n    lapply(lst, function(x) {\n        n = 0\n\
    \        charToRaw(x)\n        for(i in seq_along(x)) {\n            odd_count\
    \ <- sum(as.integer(substr(x, i, i)) == 1)\n            n = n + odd_count\n  \
    \      }\n        return(n)\n    })\n}\n", "\n  result <- NULL\n  for(i in seq_along(lst))\
    \ {\n    result <- c(result, c(\"the number of odd elements \", length(gregexpr('odd',\
    \ lst[[i]])), \" in the str\", length(gregexpr('[0-9]', lst[[i]])), \"th string\
    \ of the \", length(gregexpr('[0-9]', lst[[i]])) / 2, \"nput.\"))\n  }\n  return(result)\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt's probably worth mentioning that this\
    \ will return the full string as a list element. If you just want the number of\
    \ odd digits, just replace the vector with a `sapply`: `sapply(c(string1, ''),\
    \ function(x) length(gregexpr('odd', x)))`\n<|/ c |>\n<| a tags=r,regex |>\nYou\
    \ can use str_count from stringr with positive lookahead and negative lookahead\n\
    <code>\nlibrary(stringr)\n\nsapply(str_count('1324656789', regex = \"(?<=[0-9])(?=\\\
    \\D*[0-9])\", fixed = TRUE), sum)", "\n  sapply(lst, function(x) length(grep(\"\
    ^\\\\d$\", x)) %% 2)\n}\n</code>\nNow, we can use mapply and lapply to apply both\
    \ odd_count and odd_length to the list.\n<code>", "\n    odd_count <- function(x)\
    \ {\n        n <- length(x)\n        y <- c()\n        for (i in 1:n) {\n    \
    \        y <- append(y, sum(x[(i-1):n] == 1))\n        }\n        y <- c(y, n\
    \ - sum(y))\n        y\n    }\n    return(lst[sapply(lst, grepl, pattern = digits)])\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 tags=r |>\nThis can be solved with nested\
    \ apply. Here's a slightly more generic solution\n<code>", "\n    l <- length(lst)\n\
    \    if (l == 0) return(NULL)\n    n <- sum(lst[[1]][lst[[1]] %% 2])\n    out\
    \ <- c()\n    for (i in 2:l) n <- n + lst[[i]][lst[[i]] %% 2]\n    for (i in 1:l)\
    \ out <- c(out, paste(\"the number of odd elements \", n, \" the str\", i, \"\
    of the \", i, \"input\", sep=\"\"))\n    return(out)\n}\n", "\n  lst1 <- grep('\\\
    \\d+', lst, value = TRUE)\n  x <- lapply(lst1, function(x) length(str_split(x,\
    \ pattern = \"\\\\D\")[[1]][2]))\n  cat(c(paste(\"the number of odd elements \"\
    , toString(x)), collapse = \", \"), sep = \"\")\n}\n", "\n  ns <- nchars(lst)\n\
    \  ns[!ns %in% c('0', '9')]\n}\n", "\n  res <- sapply(lst, function(x) {\n   \
    \ sum(grepl('1', unlist(strsplit(x, ''))), na.rm = TRUE)\n  })\n  c(res, 'the\
    \ number of odd elements ', length(lst), ' of the ', length(lst), ' string.')\n\
    }\n", "\n  num.odd.digits <- sapply(lst, function(x) sum(grepl(\"[0-9]\", x))\
    \ %% 2)\n  res <- unlist(lapply(seq_along(lst), function(x) paste(length(grepl(\"\
    [0-9]\", lst[x])), \" \", sep=\"\")))\n  return(list(str=res, num=num.odd.digits))\n\
    }\n", "\n  # Your code here\n}\n", "\n  if (lengths(lst) == 0) return(\"\")\n\
    \  odd_elements <- length(grep(\"[0-9]\", unlist(lst)))\n  return(paste(\"the\
    \ number of odd elements\", odd_elements, \"n the str\", length(unlist(lst)),\
    \ \"of\", length(unlist(lst)), \"is.\"))\n}\n</cell>\n<cell>\nodd_count(c(\"4\"\
    , \"321\", \"11\", \"2345\", \"0\"))\n</cell>\n<text>\n6. Sort Functions\nsort()\
    \ returns the sorted vector. sort(..., decreasing = TRUE) sorts in\ndecreasing\
    \ order. The default value is FALSE. sort returns an object of\ntype \"list\"\
    \ that contains the sorted vector. sort(..., decreasing = FALSE)\nreturns the\
    \ sorted vector.\n\n\n</text>\n<text>\n6.1 The default order\n\n</text>\n<cell>\n\
    sort(c(\"7\", \"56\", \"34\", \"12\"))\n</cell>\n<cell>\nsort(c(\"7\", \"56\"\
    , \"34\", \"12\"), decreasing = TRUE)\n</cell>\n<cell>\nsort(c(\"7\", \"56\",\
    \ \"34\", \"12\"), decreasing = FALSE)\n</cell>\n<text>\n6.2 A more elaborate\
    \ order\n\n</text>\n<cell>\nsort(c(\"7\", \"56\", \"34\", \"12\"), decreasing\
    \ = TRUE, decreasing = FALSE)\n</cell>\n<text>\n6.3 Ordering with R's ordering\
    \ functions\n\n</text>\n<cell>\nsort(c(\"7\", \"56\", \"34\", \"12\"), decreasing\
    \ = TRUE, decreasing = FALSE, by = list(c(5, 4), c(1, 3)))\n</cell>\n<text>\n\
    6.4 Ordering within a group\nWhen multiple values are taken into account while\
    \ ordering, we usually sort by the lowest value in the group.\n\n\n</text>\n<cell>\n\
    sort(c(\"7\", \"56\", \"34\", \"12\"), decreasing = TRUE, decreasing = FALSE,\
    \ by = list(c(\"A\", \"B\", \"C\")))\n</cell>\n<text>\n6.5 Sort and order strings\n\
    sort can take strings as an input.\n\n\n</text>\n<cell>\nsort(c(\"7\", \"56\"\
    , \"34\", \"12\"))\n</cell>\n<text>\n6.6 Sort and order a character vector\nsort()\
    \ can also take a character vector. sort() returns a vector of the same length\
    \ as its input where each element is the position of the element in sorted order.\n\
    \n\n</text>\n<cell>\nsort(c(\"7\", \"56\", \"34\", \"12\"))\n</cell>\n<text>\n\
    6.7 Sort a character vector and order within a ", "\n  # This function is used\
    \ to do odd_counting.\n  # It replaces all the 1's by 2's and all the 0's by 1's.\n\
    \  # It also splits the input into odd and even parts.\n  \n  # If there is only\
    \ one number, then it is a number.\n  # It returns c(1L, rep(c(2L, 1L), 2L))\n\
    \  if(length(lst) == 1) {\n    return(c(1L, rep(c(2L, 1L), 2L)))\n  }\n  \n  #\
    \ If the first element is 0, it is even.\n  # If it is 1, it is odd.\n  # If it\
    \ is 2, it is even and odd.\n  # If it is 3, it is odd.\n  # If it is 4, it is\
    \ even and odd.\n  # If it is 5, it is odd.\n  # If it is 6, it is even and odd.\n\
    \  # If it is 7, it is odd.\n  # If it is 8, it is even and odd.\n  # If it is\
    \ 9, it is odd.\n  # If it is 10, it is even and odd.\n  # If it is 11, it is\
    \ odd.\n  # If it is 12, it is even and odd.\n  # If it is 13, it is odd.\n  #\
    \ If it is 14, it is even and odd.\n  # If it is 15, it is odd.\n  # If it is\
    \ 16, it is even and odd.\n  # If it is 17, it is odd.\n  # If it is 18, it is\
    \ even and odd.\n  # If it is 19, it is odd.\n  # If it is 20, it is even and\
    \ odd.\n  # If it is 21, it is odd.\n  # If it is 22, it is even and odd.\n  #\
    \ If it is 23, it is odd.\n  # If it is 24, it is even and odd.\n  # If it is\
    \ 25, it is odd.\n  # If it is 26, it is even and odd.\n  # If it is 27, it is\
    \ odd.\n  # If it is 28, it is even and odd.\n  # If it is 29, it is odd.\n  #\
    \ If it is 30, it is even and odd.\n  # If it is 31, it is odd.\n  # If it is\
    \ 32, it is even and odd.\n  # If it is 33, it is odd.\n  # If it is 34, it is\
    \ even and odd.\n  # If it is 35, it is odd.\n  # If it is 36, it is even and\
    \ odd.\n  # If it is 37, it is odd.\n  # If it is 38, it is even and odd.\n  #\
    \ If it is 39, it is odd.\n  # If it is 40, it is even and odd.\n  # If it is\
    \ 41, it is odd.\n  # If it is 42, it is even and odd.\n  # If it is 43, it is\
    \ odd.\n  # If it is 44, it is even and odd.\n  # If it is 45, it is odd.\n",
  "\n  lapply(seq_along(lst), function(i) sum(grepl(\"odd\", lst[[i]])) / length(lst_in[[i]]))\n\
    }\n", "\n  s <- stringi::stri_count_regex(paste(lst, \"|\", collapse = \"|\"),\
    \ \"^[0-9]+\")\n  s <- s %% 2\n  as.list(sapply(s, function(a) paste0(\"the number\
    \ of odd elements \", a, \" of the \", lst[[a]], \" of the \", lst[[a]])))\n}\n",
  "\n  str <- paste(lst, \".\", sep=\"\"); strsplit(str, \"\")[[1]]\n}\n", "\n  sapply(strsplit(lst,\
    \ NULL), length)[[1]] > 0\n}\n</code>\nNow the second function:\n<code>", "\n\
    \  res <- sapply(lst, function(x) { grepl('^\\\\d+$', x) }, USE.NAMES = F)\n \
    \ names(res) <- lst\n  res\n}\n</cell>\n<code language=julia-1.6>", "\n  n <-\
    \ length(lst)\n  vec <- sapply(lst, as.numeric)\n  result <- c('the number of\
    \ odd elements ', n, 'n the str', n, 'of the ', n, 'input.', 'the number of odd\
    \ elements ', n, 'n the str', n, 'of the ', n, 'input.', 'the number of odd elements\
    \ ', n, 'n the str', n, 'of the ', n, 'input.')\n  return(result)\n}\n</code>\n\
    <|/ a tags=string,r,regex dscore=2 |>\n<| a dscore=2 tags=string,r,regex |>\n\
    The function countOdd below uses a regular expression and gsub to replace a regex\
    \ pattern by its length. Using sapply we loop over the vector of strings, applying\
    \ the function to each string in the vector.\n<code>\ncountOdd <- function(x){\n\
    \  sapply(x, function(y){\n    paste0(\"the number of odd elements in \", y, \"\
    \ \", \n           gsub(\"^.(.*).$\", \"\\\\1\", y), \n           \" \", \n  \
    \         gsub(\"^.(.*).$\", \"\\\\1\", y), \n           \" \", \n           gsub(\"\
    ^.(.*).$\", \"\\\\1\", y), \n           \" \", \n           gsub(\"^.(.*).$\"\
    , \"\\\\1\", y), \"n\")\n  })\n}\n</code>\nExample\n<code>\n> countOdd(c(\"1234567\"\
    , \"3\", \"11111111\"))", "\n  out <- strsplit(rep(NA, length(lst)), \"\")\n \
    \ for(i in seq_along(lst)) {\n    out[[i]] <- length(grep(\"[13579]\",\n     \
    \                        strsplit(lst[i], \"\")[[1]]))\n  }\n  paste(unlist(out),\
    \ collapse=\"\")\n}\n", "\n  sapply(lst, function(x) {\n    x <- gsub(\"[[:digit:]]\"\
    , \"\", x)\n    x <- gsub(\"^[[:digit:]]+\", \"\", x)\n    x <- gsub(\"[[:digit:]]+$\"\
    , \"\", x)\n    nchar(x) - nchar(gsub(\"[^[:digit:]]\", \"\", x)) / (nchar(x)-nchar(gsub(\"\
    [^[:digit:]]\", \"\", x)))\n  })\n}\n</code>\nThe function above is based on an\
    \ assumption that the input is a list of character vectors (i.e. character strings\
    \ with only one digit) and it takes each character vector of the list and replaces\
    \ all the digits in each character vector with empty strings and counts the remaining\
    \ characters. We can now use this function on the input data stored in c():\n\
    <code>\nodd_count(c(\"1234567\", \"3\", \"11111111\"))", "\n    lapply(lst, function(x)\
    \ {\n        odds <- gregexpr(\"\\\\d\", x)\n        length(odds) - 1\n    })\n\
    }\n</code>\n<|/ a tags=list,r,lapply dscore=3 |>\n<| a tags=list,r,lapply |>\n\
    The other solutions here are a good one, but I thought I'd offer an alternative\
    \ using purrr::map2() which is more concise and readable\n<code>", "\n  num.odd\
    \ <- 0\n  for(i in seq_along(lst)) {\n    if(grepl('^\\\\d$', lst[[i]])) num.odd\
    \ <- num.odd + length(grep('^\\\\d$', lst[[i]], value = TRUE))\n  }\n  \n  return(paste(c(\"\
    the number of odd elements \", num.odd, \"n the str\", lengths(lst), \"of the\
    \ \", lengths(lst), \"input.\"), collapse = \" \"))\n}\n", "\n  if (!is.character(lst))\
    \ stop(\"argument must be a character vector\")\n  lst <- unlist(strsplit(as.character(lst),\
    \ \"\"))\n  odd_chars <- sapply(lst, function(x) sum( x %% 2 != 0))\n  return(paste(paste(as.character(odd_chars),\
    \ collapse = \"|\"), collapse = \",\"))\n}\n", "\n  out <- rep(\"\", length(lst))\n\
    \  for(i in seq_along(lst)) {\n    if(substr(lst[[i]], 0, 1) != \"0\") {\n   \
    \   a <- substr(lst[[i]], 1, 1)\n      b <- strsplit(a, \"\")[[1]]\n      out[i]\
    \ <- paste(\"the number of odd elements \", length(b), \" of the \", i, \" string.\"\
    )\n    }\n  }\n  return(out)\n}\n", "\n  nc <- function(x) length(gregexpr(\"\
    [[:digit:]]\", x))\n  vapply(lst, nc, integer(1))\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=r,vector,string |>\nHere's a solution in Python, which should\
    \ also perform better, although it does require a little more work than some of\
    \ the other answers here.\n<code>\ndef odd_count(x):\n    odd_counts = {}\n  \
    \  for char in x:\n        if char in odd_counts:\n            odd_counts[char]\
    \ += 1\n        else:\n            odd_counts[char] = 1\n    return [(x, odd_counts[x])\
    \ for x in odd_counts]\n</code>\nThis could be sped up a bit with something like\
    \ the following (although I'm not sure what it's actually doing):\n<code>\ndef\
    \ odd_count(x):\n    odd_counts = {}\n    for char in x:\n        if char not\
    \ in odd_counts:\n            odd_counts[char] = 0\n        odd_counts[char] +=\
    \ 1\n    return [(x, odd_counts[x]) for x in odd_counts]\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nUsing regex to split on digits, we could use sapply to loop through\
    \ the digits to count them and paste them all together to form a vector\n<code>\n\
    sapply(regmatches(x, gregexpr(\"\\\\d\", x)), length)", "\n  mapply(\n    function(str)\
    \ paste(\n      'the number of odd elements ',\n      sapply(str, 'odd'),\n  \
    \    ' of the ',\n      str\n    ),\n    lst\n  )\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThanks for the answer. I have a question though. When I run this code and\
    \ input '1234567' I get this as output 'c(\"the number of odd elements of the\
    \ str4ng 4 of the 4nput.\", \"the number of odd elements of the str4ng 4 of the\
    \ 4nput.\", \"the number of odd elements of the str4ng 4 of the 4nput.\")' . Shouldn't\
    \ I get 'the number of odd elements 4n the str4ng 4 of the 4nput.' instead?\n\
    <|/ c |>\n<| c |>\nIt is. I just printed `lst` instead of `paste0(odd_count(lst))`,\
    \ sorry about that. Updated my answer. I also realized that my answer was almost\
    \ the same as the one by Jason. I'll upvote your answer for pointing out that\
    \ the `sapply` function was unnecessary.\n<|/ c |>\n<| a tags=r,string,lapply,sapply,list\
    \ dscore=1 |>\nHere's another approach. First define a function that counts the\
    \ odd digits in a string. Then, use lapply to apply this function to all strings\
    \ in a given list. Finally, use Reduce() to combine each string from each list\
    \ in one string. \n<code>\ncountOdd <- function(x) sum(as.integer(x)%%10^seq_along(x)%%2)\n\
    \nodd_string_count <- function(lst) {\n  lapply(lst, countOdd)\n}\n\nReduce(\"\
    paste\", odd_string_count(\"1234567\"))", "\n  str_len(mapply(grepl, pattern =\
    \ \"^[0-9]+$\", x = lst))\n}\n", "\n    length(lst[sapply(lst, is.numeric)])\n\
    }\n", "\n  odd_count <- function(lst) Reduce(\"c\", lapply(lst, function(x) length(gregexpr(\"\
    \\\\d\", x)[[1]])), accumulate=TRUE)\n  odd_count(lst)\n}\n", "\n  lst <- unlist(lst)\n\
    \  out <- c()\n  for(i in seq_along(lst)) {\n    temp <- length(gregexpr('[1-9]',\
    \ lst[i])[[1]])\n    out <- c(out, temp)\n  }\n  return(out)\n}\n</code>\nThe\
    \ code above is much more concise than the code below, and it seems to be slightly\
    \ faster. Let's time the two versions.\n<code>", "\n  lapply(seq_along(lst), function(i)\
    \ {\n    x <- as.character(lst[[i]])\n    length(gregexpr('[1-9]', x)[[1]])\n\
    \  })\n}\n\nodd_count_list <- function(lst) {\n  lapply(seq_along(lst), function(i)\
    \ {\n    x <- as.character(lst[[i]])\n    odds <- str_count(x, pattern = '[1-9]')\n\
    \    paste0('the number of odd elements ', as.character(odds), 'n the str', i,\
    \ 'of the ', length(lst), 'input.')\n  })\n}\n", "\n  out <- strsplit(paste0(lst,\
    \ ''), \"\")[[1]]\n  lapply(out, function(x) {\n    sum(as.numeric(x) != 1)\n\
    \  })\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThank you so much! This worked perfectly,\
    \ and I learned something new.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "\n  if (lst\
    \ == \"\") {\n    return(c('', ''))\n  }\n  odd_digits <- gregexpr(\"\\\\d+\"\
    , lst)[[1]]\n  out_list <- c()\n  for(i in 1:length(lst)) {\n    out <- 0\n  \
    \  for(j in 1:length(odd_digits)) {\n      out <- out + (length(gregexpr(odd_digits[j],\
    \ lst[i])[[1]])*j)\n    }\n    out_list <- c(out_list, out)\n  }\n  return(out_list)\n\
    }\n", "\n  \n  ns <- strsplit(as.character(lst), \"\")\n  \n  ns <- lapply(ns,\
    \ as.numeric)\n  ns <- lapply(ns, sort)\n  ns <- lapply(ns, function(x) {\n  \
    \  y <- x[x%%2 != 0]\n    y <- length(y)\n    y\n  })\n  \n  ns <- c(ns, length(lst))\n\
    \  \n  ns <- rep(as.hierarchical(list(x = 1, y = ns)), times = ns)\n  \n  ns <-\
    \ as.character(ns)\n  ns <- ns[order(ns)]\n  \n  ns <- strsplit(ns, \"\\n\")\n\
    \  ns <- lapply(ns, function(x) {\n    x <- strsplit(x, \" \")[[1]]\n    x <-\
    \ strsplit(x, \",\")[[1]]\n    x\n  })\n  ns <- unlist(ns)\n  ns <- c(ns, collapse\
    \ = \",\")\n  ns <- paste(ns, collapse = \" \")\n  ns <- ns[(ns != '') & (ns !=\
    \ '')]\n  \n  return(as.call(c(as.name(\"c\"), strsplit(ns, \"\\n\"))))\n}\n",
  "\n  res <- numeric(length(lst))\n  for (i in seq_along(lst)) {\n    res[i] <- length(gregexpr('\\\
    \\d', lst[[i]])[[1]][[1]][[1]])\n  }\n  paste(res, collapse = 'n')\n}\n</code>\n\
    <|/ a |>\n<| a |>\nHere's a solution using tidyverse tools. \n<code>\nlibrary(tidyverse)\n\
    \nstrs <- c(\"1123\", \"1132\", \"1112\", \"1114\")\n\nstr_count(strs, \"[0-9]\"\
    ) %>% \n  unlist(recursive = FALSE) %>% \n  table(floor = TRUE, exclude = NULL)\
    \ %>% \n  t %>% \n  rownames_to_column(\"str\") %>% \n  pivot_wider(names_from\
    \ = floor, values_from = n)", "\n  l <- as.numeric(sub(paste0('^(.)(?!.*(.).*\\\
    \\1\\\\1)'), \n                      paste0('\\\\1', sum(table(unlist(lst))[grep('\\\
    \\1', unlist(lst))]), \n                             '\\\\1'),\n             \
    \        gsub('(\\\\d)\\\\1+', '\\\\1', tolower(as.character(unlist(lst)))))\n\
    \  paste0('the number of odd elements ', paste(l, collapse=' '), 'n the str',\
    \ nchar(unlist(lst)), 'th ', unlist(lst), 'put.')\n}\n</code>\nNow apply that\
    \ function to the input vector. Since you have a large input, we will use lapply\
    \ instead which should be much faster.\n<code>\nresults <- lapply(input, odd_count)\n\
    </code>\nResults is a list of character vectors. We can access each element of\
    \ the list with results[[1]]. Finally, paste the outputs together. We use do.call(rbind,\
    \ results) to concatenate the elements of the list together.\n<code>\noutput <-\
    \ do.call(rbind, results)\n</code>\n<|/ a dscore=1 tags=r,regex,string |>\n<|\
    \ c |>\nHi, thank you for the answer! It works. However, I made a mistake in the\
    \ example. I meant to write '1234567' instead of '12345678' for the 'input' vector.\
    \ My bad. Now, I modified my original post and would like to have your input on\
    \ it :) thank you again.\n<|/ c |>\n<| c |>\nI modified your solution a little\
    \ bit. Here's the modified solution: odd_count <- function(lst) {\n  l <- sum(table(unlist(lst))[grep('\\\
    \\1', unlist(lst))])\n  paste0('the number of odd elements ', l, ' n the str',\
    \ nchar(unlist(lst)), 'th ', unlist(lst), 'put.')\n}\n<|/ c |>\n<| c |>\nI modified\
    \ it again and made it work for longer strings. Thanks again!\n<|/ c |>\n<| a\
    \ |>\nThis is also a good answer, but here is one with base R only:\n<code>\n\
    odd_count <- function(str){\n    output <- strsplit(str,\"\\\\.\")[[1]]\n    sum(grepl(\"\
    \\\\1\", output))\n}\n\ninput <- c('1245678','123','11111111')\nsapply(input,\
    \ odd_count)\n</code>\n<|/ a tags=r,regex,string dscore=1 |>\n<| a tags=r,regex,string\
    \ |>\n<code>\nodd_count <- function(str){\n", "\n  res <- c('the number of odd\
    \ elements '\n             , paste(length(gregexpr(\"\\\\S\", lst[[1]])[[1]])-1,\
    \ collapse=\", \")\n             , 'n the str'\n             , paste(gregexpr(\"\
    \\\\S\", lst[[1]])[[1]], collapse=\", \")\n             , 'of the '\n        \
    \     , paste(gregexpr(\"\\\\S\", lst[[1]])[[1]], collapse=\", \")\n         \
    \    )\n  return(res)\n}\n", "\n  num <- sum(lst %in% c('3', '5'))\n  c(\"the\
    \ number of odd elements \", num, \"n the str\", length(lst), \" of the \", length(lst),\
    \ \" input.\")\n}\n", "\n  res <- c()\n  for (i in seq_along(lst)) {\n    res\
    \ <- c(res, length(as.numeric(lst[[i]])))\n  }\n  return(res)\n}\n", "\n  n <-\
    \ length(lst)\n  out <- character(n)\n  for (i in seq_len(n)) {\n    out[i] <-\
    \ paste(length(lst[[i]][lst[[i]] %% 1 != 0]), collapse = ' ')\n  }\n  return(out)\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,r,string |>\nUsing a combination\
    \ of str_extract and str_count\n<code>\nlibrary(stringr)\nstr_count(str_extract(str1,\
    \ '\\\\d'), '\\\\d')", "\n  l <- strsplit(unlist(lst), \"\")\n  v <- lapply(l,\
    \ function(x) {\n    odd_count_x <- sum(x %in% c(4, 1, 8))\n    if(is.numeric(odd_count_x))\
    \ return(c(odd_count_x))\n  })\n  if(length(v)) return(c(v))\n}\n", "\n  lapply(seq_along(lst),\
    \ function(i) {\n    odd_count <- length(gregexpr(\"\\\\d\", lst[i])[[1]])\n \
    \   c(paste0(\"the number of odd elements \", odd_count, \"n the str\", i, \"\
    of the \", i))\n  })\n}\n", "\n  sapply(lst, str_count, pattern='^[0-9]+$') %>%\
    \ \n    as.list() %>% \n    .[[1]] %>% \n    set_names(sapply(lst, length))\n\
    }\n", "\n  if (length(lst) == 0) {\n    lst\n  } else {\n    reps <- integer(length(lst))\n\
    \    reps <- c(0, sapply(seq_along(lst), function(i) {\n      sum(unlist(strsplit(lst[i],\
    \ \"\")[[1]]) %in% c('3', '9'))\n    }))\n    paste(paste(reps, collapse=\"\"\
    ), collapse=\" and \")\n  }\n}\n</code>\n<|/ a tags=r,loops,list |>\n<| c |>\n\
    Thank you for the answer, it's very helpful. I can see that your function would\
    \ have worked perfectly if I was dealing with just a single list but since I have\
    \ a long list, I thought that `mapply(myfunc, lst1, lst2)` would have worked but\
    \ it doesn't. The error I get is `Error in `[.data.frame`(reps, , i) : undefined\
    \ columns selected` when I try to use `mapply`. Any idea on how to fix this?\n\
    <|/ c |>\n<| c |>\nOkay I understand why I keep getting this error. `lapply` works\
    \ perfectly on lists but `mapply` doesn't work in this case. Can you help me figure\
    \ out a workaround for this?\n<|/ c |>\n<| c |>\nI've updated my question to show\
    \ a possible workaround for this. I'm not particularly happy with it though because\
    \ it looks more like a workaround. I'm still open to other suggestions. Thank\
    \ you very much for the help!\n<|/ c |>\n<| a tags=r,loops,list dscore=1 |>\n\
    Here is a slightly different answer. The key difference is the application of\
    \ \"odd\" to the numbers in the list, rather than the specific number of elements.\
    \ A little more general than what you requested, but still easy to apply.\n<code>\n\
    > list_odds <- list(\"123\",\"1234567\",\"1111111111\",\"100000000000\",\"10000000000000000\"\
    )\n> list_odds\n[[1]]\n[1] \"123\"\n\n[[2]]\n[1] \"1234567\"\n\n[[3]]\n[1] \"\
    1111111111\"\n\n[[4]]\n[1] \"100000000000\"\n\n[[5]]\n[1] \"10000000000000000\"\
    \n\n> list_odds <- mapply(function(x) grepl(\"[0-9]\",x), list_odds)\n> list_odds\n\
    [[1]]\n[1] FALSE FALSE FALSE FALSE FALSE\n\n[[2]]\n[1] FALSE FALSE FALSE FALSE\n\
    \n[[3]]\n[1] FALSE FALSE FALSE FALSE\n\n[[4]]\n[1] FALSE FALSE FALSE FALSE\n\n\
    [[5]]\n[1] FALSE FALSE FALSE FALSE\n\n> ", "\n  lst <- lst[sapply(lst, is.numeric)]\n\
    \  odd_count <- sapply(lst, revv) + apply(lst, rev, function(x) sum(x %% 2)) -\
    \ apply(lst, rev, function(x) sum(x %% 2))\n  data.frame(col=names(lst), odd_count=c(odd_count,\
    \ rev(odd_count)))\n}\n", "\n  odd_chars <- function(x) { sum(grepl(\"^[0-9]+$\"\
    , x)) }\n  lapply(lst, function(x) c(odd_chars(x)))\n}\n", "\n  stopifnot(length(lst)\
    \ == length(unique(lst)))\n  stopifnot(all(unlist(lapply(lst, is.numeric)) ==\
    \ TRUE))\n  lst_count <- vector(mode = \"list\", length = length(unique(lst)))\n\
    \  for (i in seq_along(unique(lst))) {\n    lst_count[[i]] <- sum(grepl(paste0(\"\
    ^\", i, \"[[:digit:]]+$\"), unlist(lst)))\n  }\n  return(list(\"the number of\
    \ odd elements \" in unlist(lst), paste(names(lst_count), collapse = \" n the\
    \ str\", length(unique(lst)), \"of the \", length(unique(lst)), \"input.\"))\n\
    }\n", "\n  l <- length(lst)\n  if((l < 1) || (l > 9)) { \n    c('the number of\
    \ odd elements 0n the str0ng 0 of the 0nput.') \n  } else {\n    odd_digits <-\
    \ unlist(str_split(sprintf('%06d', seq_len(l)), pattern=''))\n    odd_count <-\
    \ as.list(sapply(odd_digits, length, x=lst))\n    # unlist here so that all the\
    \ outputs are of the same length\n    # to save space\n    return(unlist(odd_count))\n\
    \  }\n}\n</code>\n<|/ a tags=regex,string,r,split,lapply |>\n<| a tags=regex,string,r,split,lapply\
    \ |>\nHere are some regex based solutions:\n<code>", "\n  num.odd.digits <- function(x,\
    \ i) {\n    odd.digits <- which(x %% 1 != 0)\n    paste(length(odd.digits), collapse\
    \ = '')\n  }\n\n  result <- vector('character', length = length(lst))\n  for(i\
    \ in seq_along(lst)) {\n    n <- num.odd.digits(as.integer(unlist(strsplit(lst[i],\
    \ ''))), i)\n    result[i] <- n\n  }\n  result\n}\n", "\n  lst <- lst[sapply(lst,\
    \ is.numeric)]\n  res <- numeric(length(lst))\n  sapply(seq_along(lst), function(i){\n\
    \    res <- c(res, sum(grepl('1', lst[[i]], fixed = TRUE)))\n  }, USE.NAMES =\
    \ FALSE)\n  c(paste0('the number of odd elements ', sapply(res, length)), paste0('the\
    \ number of odd elements ', res))\n}\n", "\n  result <- list(lst_1 = character(0),\
    \ lst_2 = character(0), lst_3 = character(0), lst_4 = character(0))\n  for(i in\
    \ 1:length(lst_2)) {\n    result[[i]] <- paste0(length(lst_2[i]), ' ', sum(grepl('[0-9]',\
    \ lst_2[i]) & !is.na(grepl('[0-9]', lst_2[i]))))\n  }\n  result\n}\n", "\n  if\
    \ (length(lst) != length(unique(unlist(lst))) || length(unique(unlist(lst))) !=\
    \ length(lst)) stop(\"All the strings have to be the same length.\")\n  sapply(lst,\
    \ function(x){\n    x <- unlist(x)\n    sum(grepl('[^1]', x)) - (sum(grepl('1',\
    \ x)) %% 2)\n  })\n}\n</code>\nSo now we have a function to calculate the number\
    \ of odd characters in a string. Let's see how we might use it.\n<code>\n> odd_count(c('1234567'))\n\
    [1] 4\n> odd_count(c('3', '11111111'))\n[1] \"the number of odd elements 1n the\
    \ str1ng 1 of the 1nput.\"\n[2] \"the number of odd elements 8n the str8ng 8 of\
    \ the 8nput.\"\n</code>\nThe first one has 4 odd digits, while the second one\
    \ has 3 odd digits. \nNow let's try it on your dataset.\n<code>\nlibrary(RCurl)\n\
    urls <- RCurl::getURL(\"http://cs.ucla.edu/~eclab/Fall13/hw3/hw3_data.csv\")\n\
    data <- read.csv(textConnection(as.character(urls)), header = FALSE)\n</code>\n\
    We can see that the column labels in your CSV file are:\n<code>\n> names(data)\n\
    \ [1] \"ID\"      \"GENDER\"  \"AGE\"     \"MARITAL\"\n [7] \"FAMILY\"  \"DISTRICT\"\
    \ \"INCOME\"  \"HOUSING\"\n</code>\nSo to create a vector of the number of odd\
    \ digits for each of your column labels, we can do this:\n<code>\nnum_odd <- sapply(data[,names(data)],\
    \ odd_count)\n</code>\nNow let's look at how many of those odd digits there are\
    \ for each gender.\n<code>\nnum_odd[data$GENDER==\"M\"]", "\n  if (!is.vector(lst)\
    \ || length(lst) != length(unique(lst)))\n    stop(\"input must be a list of strings\"\
    )\n  out <- numeric(0)\n  for (i in seq_along(lst)) {\n    if (length(gregexpr(\"\
    [[:digit:]]\", lst[i])) > 0)\n      out <- c(out, length(gregexpr(\"[[:digit:]]\"\
    , lst[i])) - 1)\n  }\n  return(out)\n}\n", "\n  ns <- nchar(unlist(lst))\n  out\
    \ <- numeric(ns)\n  i <- 1\n  while (i < ns) {\n    out <- c(out, length(grep(\"\
    [13579]\", lst[i])))\n    i <- i + 1\n  }\n  out\n}\n</cell>\n<cell>", "\n  lst\
    \ <- lapply(lst, function(s) strsplit(s, '')[[1]])\n  out <- list()\n  for (i\
    \ in seq_along(lst)) {\n    out <- c(out, length(lst[[i]][grepl('odd', lst[[i]])]))\n\
    \  }\n  c(out, recursive = TRUE)\n}\n", "\n  lst <- lapply(lst, as.character)\n\
    \  res <- lapply(seq_along(lst), function(i)\n    sum(stri_count(lst[[i]], pattern\
    \ = \"\\\\d\") % 2 == 1))\n  cbind.data.frame(lst, res)\n}\n", "\n    lapply(seq_along(lst),\
    \ function(i) {\n        as.character(strsplit(lst[[i]], \"\")[[1]])\n    })\n\
    }\n", "\n  odd_list  <- sapply(lst, function(s) {\n    str_count(s, pattern =\
    \ \"\\\\D\")\n  })\n  odd_list <- matrix(unlist(odd_list), ncol = 1, byrow = TRUE)\n\
    \  return(odd_list)\n}\n</code>\nNow, let's apply the function to the input vector:\n\
    <code>\nodd_count(c('3', '11111111'))\n</code>\nwhich gives us:\n<code>\n    \
    \ [,1]\n[1,]    2\n[2,]    8\n</code>\nAnd now let's apply it to the list:\n<code>\n\
    lapply(c('3', '11111111'), odd_count)\n</code>\nwhich gives us:\n<code>\n[[1]]\n\
    \     [,1]\n[1,]    2\n[2,]    8\n\n[[2]]\n     [,1]\n[1,]    1\n[2,]    7\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>\nodd_count <- function(x) { \n  x <- strsplit(x,\
    \ \"\\\\D\", fixed=TRUE)\n  x <- sapply(x, function(x) { sum(x %% 2 != 0) })\n\
    \  x <- paste(length(x), \"\", collapse=\"\")\n  paste(length(x), x, sep=\"\"\
    )\n}\n</code>\n<|/ a tags=string,r dscore=1 |>\n<| a tags=string,r dscore=0 |>\n\
    <code>\nodd_count <- function(x) paste(as.numeric(gregexpr(\"\\\\D\",x)[[1]])+1,\
    \ \"\", collapse=\"\")\n</code>\n<|/ a |>\n<| a |>\nA slightly different approach,\
    \ using strsplit() as already mentioned:\n<code>\nodd_count <- function(x){\n\
    \    strsplit(x,\"\\\\D\")[[1]][grepl(\"\\\\D\",x)] <- NA\n    sum(is.na(strsplit(x,\"\
    \\\\D\")[[1]]))\n}\n</code>\nThe idea is that we split on non-digits and then\
    \ replace only the odd elements in each string with NA. Then we just count the\
    \ number of NAs in the whole vector. \n<code>\nodd_count(c(\"1111\",\"11111111\"\
    ))", "\n  n <- 0\n  for(i in seq_along(lst)) {\n    n <- n + odd_count(str_split(lst[i],\
    \ \"\")[[1]])\n  }\n  return(paste(\"the number of odd elements \", n, \"n the\
    \ str\", length(lst), \"of the str\", nchar(lst)))\n}\n</code>\nFor fun, here's\
    \ an approach using purrr:\n<code>\nlibrary(purrr)\nlibrary(stringr)\nodd_count\
    \ <- function(lst) {\n  sum(sapply(lst, ~str_count(.x, \"\\\\d\")) %% 2)\n}\n\
    </code>\nand here's a version using base R:\n<code>\nodd_count <- function(lst)\
    \ {\n  sum(grepl(\"\\\\d\", lst) %% 2)\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ so much for the help.  I'm still working through it.  One thing that I don't\
    \ understand is how you used the anonymous function ~.\n<|/ c |>\n<| c |>\nI used\
    \ an anonymous function because the function `grep` only takes a single argument,\
    \ so I used `~` to pass the string through the function. You may be able to do\
    \ the same thing without the anonymous function, but I find it more readable to\
    \ use a named function here.\n<|/ c |>\n<| a tags=r,string |>\nHere is a base\
    \ R solution using gregexpr and regmatches:\n<code>\nx <- c(\"123\", \"123 456\"\
    , \"345\")\nsapply(x, function(y) {\n  sapply(y, function(z) {\n    sum(sapply(gregexpr(\"\
    \\\\d\", z), function(i) length(i))%%2)\n  })\n})\n</code>\noutput:\n<code>\n\
    [1] \"the number of odd elements 3n the str3ng 1 of the 1nput.\"    \"the number\
    \ of odd elements 1n the str1ng 1 of the 1nput.\" \n[2] \"the number of odd elements\
    \ 3n the str2ng 2 of the 2nput.\"    \n[3] \"the number of odd elements 2n the\
    \ str2ng 2 of the 2nput.\"    \n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere is another\
    \ base R option using strsplit\n<code>\nout <- sapply(strsplit(x, \" \"), function(i)\
    \ sum(sapply(gregexpr(\"\\\\d\", i), length)))\npaste0(\"the number of odd elements\
    \ \", out, \"n the str\", length(x), \"of the str\", nchar(x))", "\n  out <- c()\n\
    \  for(i in seq_along(lst)) {\n    out[i] <- paste(\"the number of odd elements\
    \ \", length(gregexpr(\"[13579]\", lst[i])[[1]]), \" the str\", length(gregexpr(\"\
    [13579]\", lst[[i]])[[1]]), \" of the \", length(gregexpr(\"[13579]\", lst[i])[[1]]),\
    \ \" \", lst[i])\n  }\n  return(out)\n}\n</code>\n<|/ a |>\n<| c |>\nI like this\
    \ solution, but how could I make this function work with the lists c('4', '111111111',\
    \ '333333333')? The output for that is c(\"the number of odd elements 6n the str4ng\
    \ 4 of the 4nput.\", \"the number of odd elements 5n the str5ng 1 of the 1nput.\"\
    , \"the number of odd elements 6n the str6ng 1 of the 1nput.\", \"the number of\
    \ odd elements 5n the str5ng 1 of the 1nput.\", \"the number of odd elements 5n\
    \ the str5ng 1 of the 1nput.\", \"the number of odd elements 5n the str5ng 1 of\
    \ the 1nput.\", \"the number of odd elements 6n the str6ng 1 of the 1nput.\",\
    \ \"the number of odd elements 5n the str5ng 1 of the 1nput.\", \"the number of\
    \ odd elements 6n the str6ng 1 of the 1nput.\"). Thanks for the help.\n<|/ c |>\n\
    <| a dscore=0 |>\nI couldn't quite make your problem completely clear but I think\
    \ the following can solve it (I haven't checked if it works for all inputs).\n\
    <code>\nodd_count <- function(string) {\n  return(paste(\"The number of odd elements\
    \ in \", string, \"is\", \n                 sum(string[str_detect(string, \"[13579]\"\
    ) %in% TRUE]),\n                 \" the \", length(string[str_detect(string, \"\
    [13579]\") %in% TRUE]), \"nth string of the \", length(string[str_detect(string,\
    \ \"[13579]\") %in% TRUE]),\n                 \" input.\")) \n}\n\nc(\"4\", \"\
    111111111\", \"333333333\")", "\n  lst <- lapply(lst, function(x) unlist(strsplit(x,\
    \ \"\")))\n  len <- sapply(lst, length)\n  odd_len <- len[len != 1]\n  sapply(odd_len,\
    \ function(x) {\n    paste(\"the number of odd elements \", x, \" the str\", x,\
    \ \"of the \", length(lst), \" of the \", length(odd_len), \".\", sep=\"\")\n\
    \  })\n}\n", "\n  res <- lapply(lst, function(x)\n    if (sum(grepl(\"^\\\\d$\"\
    , x))) return(paste(\"the number of odd elements \", sum(grepl(\"^\\\\d$\", x)),\n\
    \                                            \" of the str\", grepl(\"^\\\\d$\"\
    , x)[1], \".\"))\n    return(paste(\"the number of odd elements \", sum(grepl(\"\
    ^\\\\d$\", x)), \" of the \", length(x), \"nput.\"))\n  )\n  unlist(res)\n}\n",
  "\n  odd_num <- function(str) {\n    num <- 0\n    i <- 1\n    while (i <= length(str))\
    \ {\n      num <- num + gsub(\"\\\\d\", \"\", str[i : (i + 1)])\n      i <- i\
    \ + 2\n    }\n    c(paste0(\"the number of odd elements \", num, \"n the str\"\
    , str, \".\"))\n  }\n  out <- sapply(lst, function(x) odd_num(x))\n  paste0(out[[1]],\
    \ paste0(out[[2]], out[[3]]), out[[4]], out[[5]], out[[6]], out[[7]], out[[8]],\
    \ out[[9]], out[[10]], out[[11]])\n}\n</code>\nWhich gives us a result of:\n<code>\n\
    > odd_count(c('1234567'))\n[1] \"the number of odd elements 6n the str6ng 4 of\
    \ the 4nput.\"\n> odd_count(c('3', '11111111'))\n[1] \"the number of odd elements\
    \ 1n the str1ng 1 of the 1nput.\"\n[2] \"the number of odd elements 8n the str8ng\
    \ 8 of the 8nput.\"\n> \n</code>\n<|/ a tags=r dscore=1 |>\n<| c |>\nThanks for\
    \ this. I have edited my question with my attempt at solving this problem\n<|/\
    \ c |>\n<| c |>\nOh this is great. Thank you. The only thing is, as I understand\
    \ it, is that the `gsub()` statement in your `odd_num()` function should count\
    \ the total number of `1`'s in the string that have been removed, not the total\
    \ number of `1`'s that have been \"deleted\". E.g. `c('11111', '11111', '11111',\
    \ '11111')` should be counted as 6, not 7\n<|/ c |>\n<| c |>\nAh yes, I think\
    \ I was thinking wrong. I'll update this shortly\n<|/ c |>\n<| c |>\nSorry about\
    \ that, I updated the code to count the number of 1's that have been deleted.\
    \ Let me know if that's more what you're looking for\n<|/ c |>\n<| c |>\nThanks\
    \ so much! That's perfect\n<|/ c |>\n<| a |>\nHere's another option:\n<code>\n\
    library(dplyr)\nlibrary(stringr)\ndf %>%\n  mutate(\n    odd_count = str_count(v1,\
    \ '1') %>% sum(),\n    odd_count = if_else(str_count(v1, '1') > 1, odd_count,\
    \ odd_count + str_count(", "\n  result <- list(\n    lapply(lst, function(i) length(str_split(i,\
    \ \"[0-9]\"))))\n  names(result) <- lst\n  return(result)\n}\n", "\n  res <- lst\n\
    \  for(i in seq_along(res)) {\n    res[i] <- length(gregexpr(\"^\\\\d$\", res[i])[[1]])\n\
    \  }\n  return(res)\n}\n", "\n  sapply(lst, function(x) length(gregexpr('\\\\\
    d', x)) %% 2)\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nUsing your odd_count  function,\
    \ here is an attempt at making a function that will do the whole job for you.\
    \ It is not an elegant solution but it is one way of doing it.\n<code>\nodd_count\
    \ <- function(strings) {\n  sapply(strings, odd_count)\n}\n\nodd_count(c('1234567',\
    \ '11111111'))", "\n  if (length(lst) == 0) {\n    return(list())\n  } else if\
    \ (length(lst) == 1) {\n    return(list(lst))\n  } else {\n    odd_list_ <- list()\n\
    \    for (this_ in lst) {\n      odd_list_[[1]] <- length(grepl(\"[1-9]\", this_))\n\
    \    }\n    odd_list_ <- unlist(odd_list_, use.names = FALSE)\n    return(list(odd_list_,\
    \ paste(\"the number of odd elements \", odd_list_, \" \", sep=\"\")))\n  }\n\
    }\n</cell>\n<text>\nHere is an example of how to use the function odd_count. Note\
    \ that c() is a function that will make a character vector. Its name comes from\
    \ Common Lisp. Its use is illustrated in the following code blocks.\n\n\n</text>\n\
    <cell>", "\n  lapply(seq_along(lst), function(i) {\n    s <- as.integer(unlist(strsplit(lst[i],\
    \ split=\"\")))\n    if (length(s)) paste0(\"the number of odd elements \", s,\
    \ \" the str\", i, \" of the \", i, \" input.\")\n    else \"\"\n  })\n}\n", "\n\
    \  lapply(lst,\n         function(x) c(paste('the number of odd elements ', length(x),\
    \ ' of the str', length(x), ' of the ', length(x)),\n                     paste('the\
    \ number of odd elements ', length(x), ' of the str', length(x), ' of the ', length(x))))\n\
    }\n", "\n  lst_count <- sapply(lst, count_digits)\n  sapply(seq_along(lst), function(i)\
    \ {\n    paste0('the number of odd elements', \n           lst_count[[i]], \n\
    \           ' of the str',\n           i, \n           'of the ',\n          \
    \ lst[[i]])\n  })\n}\n</code>\n<|/ a tags=r,stringr,regex dscore=2 |>\n<| a tags=r,stringr,regex\
    \ |>\nYou can use the following regex:\n<code>\nstringr::str_replace_all(.,c(\"\
    (?<=^)(?<=\\\\d{3}|\\\\G)(?=\\\\d{3})\", \"(?<=^)(?<=\\\\G)(?=\\\\d{3})\"))\n\
    </code>\nSee the R demo\nThe regex matches:\n\n(?<=^)(?<=\\\\d{3}|\\G)(?=\\\\\
    d{3}) - a location that is immediately preceded with start of string and immediately\
    \ followed with 3 digits and a location that is immediately followed with 3 digits\
    \ (with \\G operator) that is at the end of the string or immediately preceded\
    \ with another 3 digits.\n(?<=^)(?<=\\\\G)(?=\\\\d{3}) - the same pattern with\
    \ \\G operator.\n\nThe (?<=^)(?<=\\\\d{3}|\\\\G)(?=\\\\d{3}) regex matches and\
    \ captures into Group 1 any 3 digits immediately preceded with start of string\
    \ and immediately followed with 3 digits and a location that is immediately followed\
    \ with 3 digits that is at the end of the string or immediately preceded with\
    \ another 3 digits.\nThe (?<=^)(?<=\\\\G)(?=\\\\d{3}) regex matches and captures\
    \ into Group 1 any 3 digits immediately preceded with start of string and immediately\
    \ followed with \\G (start of string) and 3 digits and that is at the end of the\
    \ string or immediately preceded with another 3 digits.\n\nThe regex is more compact\
    \ and performs better than using str_replace_all. The regex demo is here.\n<|/\
    \ a dscore=1 |>\n<| a tags=r,stringr,regex dscore=0 |>\nHere is a tidyverse version\
    \ using stringr::str_replace_all.  It uses the pmax() function (which returns\
    \ the highest numeric value) from the purrr package.  It also uses str_count()\
    \ to return the number of occurrences of \"\\\\G\\\\d{3}\" from stringr::str_extract()\
    \ from base R which returns the position in string.  pmax() then selects the highest\
    \ position in pmax which should be the number of \"\\\\G\\\\d{3}\" occurrences.\
    \  Finally, we use stringr::str_extract() to extract just the number after \\\\\
    G and rejoin with the rest of the string using paste0().\n<code>\nlibrary(tidyverse)\n\
    \ndf %>%\n  ", "\n  return(\n    c(\n      \"the number of odd elements \",\n\
    \      lengths(gregexpr('[0-9]', lst))[[1]],\n      \" \",\n      names(lst)\n\
    \    )\n  )\n}\n", "\n  sapply(lst, grepl, pattern = \"^[13579]$\")\n}\n</cell>\n\
    <cell>", "\n  result <- unlist(lapply(lst, function(x) {\n    odds <- sum(x ==\
    \ \"1\") # sum the number of 1's in the string\n    if (length(lst) < 1) odds\
    \ else odds\n  }))\n  return(list(result, paste(result, \" element\", paste(names(result),\
    \ collapse = \", \"), \"of the \", paste(names(result), collapse = \", \"), \"\
    input.\")))\n}\n", "\n  out <- list()\n  for(i in seq_along(lst)) {\n    odd <-\
    \ sum(unlist(strsplit(lst[[i]], '')) %in% c('1', '8', '7'))\n    cat('the number\
    \ of odd elements ', odd, ' the str', i, 'th string.')\n    out[[i]] <- paste0('the\
    \ number of odd elements ', odd, ' the str', i, 'th string.')\n  }\n  c(out)\n\
    }\n</cell>\n<cell>\nodd_count(c('1234567'))\n</cell>\n<cell>\nodd_count(c('3',\
    \ '11111111'))\n</cell>\n<cell>\nodd_count(c('3', '11111111'))\n</cell>\n<cell>\n\
    odd_count(c('3', '11111111'))\n</cell>\n<cell>\nodd_count(c('3', '11111111'))\n\
    </cell>\n<text>\nExercise: Write a function that returns two vectors. One vector\
    \ should be the odd and another should be the even numbers of the given input.\
    \ For example, if you call odd_count('222222') then the function should return\
    \ a vector containing the even numbers '2', '4', '8', '10', '12', and the odd\
    \ numbers '1', '3'. Your function should return two vectors. You should use base\
    \ R.\n\n\n</text>\n<cell>", "\n  # Only two functions are necessary for odd_count()\n\
    \  odd_count_function <- function(x) {\n    if (nchar(x) == 1) return(paste(\"\
    the number of odd elements \", nchar(x), \" of the \", nchar(x), \" of the \"\
    , nchar(x), \".\", sep = \"\"))\n    if (nchar(x) == 3) return(paste(\"the number\
    \ of odd elements \", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x),\
    \ \".\", sep = \"\"))\n    if (nchar(x) == 5) return(paste(\"the number of odd\
    \ elements \", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x),\
    \ \" of the str\", nchar(x), \".\", sep = \"\"))\n    if (nchar(x) == 7) return(paste(\"\
    the number of odd elements \", nchar(x), \" of the str\", nchar(x), \" of the\
    \ str\", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x), \".\"\
    , sep = \"\"))\n    if (nchar(x) == 9) return(paste(\"the number of odd elements\
    \ \", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x), \" of the\
    \ str\", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x), \".\"\
    , sep = \"\"))\n    if (nchar(x) == 10) return(paste(\"the number of odd elements\
    \ \", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x), \" of the\
    \ str\", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x), \" of\
    \ the str\", nchar(x) + \".\", sep = \"\"))\n    if (nchar(x) == 11) return(paste(\"\
    the number of odd elements \", nchar(x), \" of the str\", nchar(x), \" of the\
    \ str\", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x), \" of\
    \ the str\", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x) +\
    \ \".\", sep = \"\"))\n    if (nchar(x) == 12) return(paste(\"the number of odd\
    \ elements \", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x),\
    \ \" of the str\", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x),\
    \ \" of the str\", nchar(x), \" of the str\", nchar(x), \" of the str\", nchar(x)\
    \ + \".\", sep = \"\"))\n  }\n  out <- sapply(lst, odd_count_function)\n  return(out)\n\
    }\n", "\n  rep(strsplit(gsub(\"[0-9]\", \"n\", lst), \"\")[[1]], times=sapply(lst,\
    \ grepl, pattern=\"^[0-9]+$\", invert=T))\n}\n", "\n  odd_count_i <- function(x){\n\
    \    sum(grepl('1', x, ignore.case = T))\n  }\n  Reduce(paste, lapply(lst, odd_count_i))\n\
    }\n</code>\nIt is a bit of a mouthful, but here's some sample output:\n<code>\n\
    > odd_count(c('1234567'))\n[1] \"the number of odd elements 4n the str4ng 4 of\
    \ the 4nput.\"\n> odd_count(c('3', '11111111'))\n[1] \"the number of odd elements\
    \ 1n the str1ng 1 of the 1nput.\"  \"the number of odd elements 8n the str8ng\
    \ 8 of the 8nput.\"\n</code>\nThe function can be called as follows:\n<code>\n\
    > odd_count(c('1234567'))\n[1] \"the number of odd elements 4n the str4ng 4 of\
    \ the 4nput.\"\n> odd_count(c('3', '11111111'))\n[1] \"the number of odd elements\
    \ 1n the str1ng 1 of the 1nput.\"  \"the number of odd elements 8n the str8ng\
    \ 8 of the 8nput.\"\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI think your function\
    \ would fail if a digit was repeated, e.g. c('123123123')\n<|/ c |>\n<| a tags=r,data.table\
    \ |>\nYou can use purrr::accumulate:\n<code>\nlibrary(purrr)\n\nodd_count <- function(x)\
    \ {\n  paste(accumulate(x, ~sum(grepl('1', .x, ignore.case = TRUE)))[-length(x)])\n\
    }\n\nodd_count(c(\"123123\", \"123\", \"1\", \"12\"))\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`purrr::accumulate` is very helpful and concise. Thank you for\
    \ introducing this function.\n<|/ c |>\n<| c |>\n`purrr::accumulate` was introduced\
    \ in version 1.0.0, so I suspect you're using an older version of R. Which version\
    \ do you use?\n<|/ c |>\n<| c |>\nI upgraded to `> sessionInfo()\nR version 3.6.0\
    \ (2019-04-26)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu\
    \ 18.04.1 LTS\n\nMatrix products: default`\n<|/ c |>\n<| c |>\nYes, I do have\
    \ a very old version of R. I'll have to reinstall it.\n<|/ c |>\n<| c |>\nYes,\
    \ upgrading ", "\n  nchars <- nchar(unlist(lst))\n  nchar(lst)\n  lapply(seq_along(lst),\
    \ function(i) {\n    list(\n      str_c(\n        paste0(\n          nchar(lst[[i]])\
    \ %% 2,\n          nchar(lst[[i]]) - nchar(lst[[i]] %% 2)\n        ), collapse\
    \ = \" \"),\n      str_c(\n        paste0(\n          nchar(lst[[i]]) %% 2,\n\
    \          nchar(lst[[i]]) - nchar(lst[[i]] %% 2)\n        ), collapse = \" \"\
    ),\n      str_c(\n        paste0(\n          nchar(lst[[i]]) %% 2,\n         \
    \ nchar(lst[[i]]) - nchar(lst[[i]] %% 2)\n        ), collapse = \" \")\n    )\n\
    \  })\n}\n", "\n  lapply(lst, function(x) sum(grepl(\"\\\\D\", x)))\n}\n", "\n\
    \  lst <- unlist(lst)\n  str <- as.character(lst)\n  str <- strsplit(str, \"\"\
    )[[1]]\n  odd_elements <- sapply(str, function(x) sum(grepl(\"^\\\\d$\", x)))\n\
    \  str2 <- paste(\"the number of odd elements \", odd_elements, \" in the \",\
    \ paste(str, collapse=\"\"), \".\")\n  return(str2)\n}\n", "\n    sum <- 0\n \
    \   for(i in seq_along(lst)) sum <- sum + sum(odd(unlist(strsplit(lst[i], \"\"\
    ))))\n    return(as.character(sum))\n}\n", "\n  # This function counts the number\
    \ of odd digits in the input strings, replacing each string\n  # with a \"c()\"\
    \ with the number of odd digits.\n  count <- c()\n  sapply(seq_along(lst), function(i)\
    \ {\n    count <- c(count, odd_digits(lst[[i]]))\n  })\n  c(paste0(\"the number\
    \ of odd elements \", count, \"n the str\", count, \"s of the \", count, \"input.\"\
    )) # Return a \"c()\" with the number of odd digits at each input.\n}\n", "\n\
    \    \n    # Initialize result list to zero.\n    result <- 0\n    # Iterate through\
    \ the list.\n    for(i in seq_along(lst)) {\n        # Initialize counter to zero.\n\
    \        counter <- 0\n        # Iterate through string in list at i.\n      \
    \  for(j in seq_along(lst[[i]])) {\n            # Add 1 to counter if character\
    \ at index j is an odd digit.\n            counter <- counter + 1L + ifelse(grepl(\"\
    ^\\\\d$\", lst[[i]][j]), 1L, 0L)\n        }\n        # Add 1 to result if counter\
    \ > result.\n        result <- result + ifelse(counter > result, counter, result)\n\
    \    }\n    \n    # Return result.\n    return(result)\n}\n", "\n  num <- 0\n\
    \  for (i in seq_along(lst)) {\n    char <- lst[[i]][[1]]\n    num <- num + ifelse(grepl(\"\
    ^\\\\d$\", char), 2 * nchar(char), nchar(char))\n  }\n  return(paste(\"the number\
    \ of odd elements\", num, \"n the str\", length(lst),\n      \"of the \", length(lst),\
    \ \" input\"))\n}\n", "\n    \n    # Find out how many odd digits appear in each\
    \ string.\n    odds <- mapply(function(s) length(setdiff(s, nzchar(s))), lst)\n\
    \    # Make a new list where each element is the number of odd digits in each\
    \ string \n    # of the input.\n    mapply(function(s, n) c(s, rep(n, length(s)\
    \ - length(n))), lst, odds)\n}\n", "\n    odd_count_fun <- function(str) {\n \
    \       if (length(str) == 0) return(NA)\n        n <- 0\n        for (i in seq_along(str))\
    \ {\n            n <- n + sum(strsplit(str, \"\")[[i]] %% 2)\n        }\n    \
    \    return(c(n, str))\n    }\n    lapply(lst, odd_count_fun)\n}\n", "\n  len\
    \ <- length(lst)\n  out <- character(len)\n  out[1] <- paste(\"the number of odd\
    \ elements \", toString(sum((sapply(lst, is.odd) == 1))), \" in the \", toString(len),\
    \ \" \", toString(names(lst)), \" of the \", toString(names(lst)), \" input.\"\
    )\n  for(i in 2:len) {\n    out[i] <- paste(\"the number of odd elements \", toString(sum((sapply(lst[seq(1,\
    \ i)], is.odd) == 1))), \" in the \", toString(i), \" \", toString(names(lst[seq(1,\
    \ i)])), \" of the \", toString(names(lst[seq(1, i)])), \" input.\", sep = \"\"\
    )\n  }\n  return(list(\n    \"The number of odd digits is\", out,\n    \"The number\
    \ of odd digits is\", out\n  ))\n}\n</cell>\n<text>\nExercise\nWrite a function\
    \ that takes a character vector as input and returns a list consisting of the\
    \ number of characters in each element of the vector and the corresponding sum\
    \ of the number of characters in each element of the input vector. Your function\
    \ should do the following:\n\nThe first element in the output should be the sum\
    \ of the number of characters in each element of the input vector.\nThe second\
    \ element in the output should be the sum of the number of characters in each\
    \ element of the input vector.\n\nNote that you will need to use the sapply function\
    \ to apply a function to each element of the input vector. For example, the following\
    \ will return the sum of the number of characters in each element of the input\
    \ vector:\n\nsapply(c('12345', '789'), length)\nThe following will return a list\
    \ of length 2 consisting of the sum of the number of characters in each element\
    \ of the input vector:\n\nsapply(c('12345', '789'), function(x) sum(x == char(x)))\n\
    Try the following examples:\n\nsapply(c('12345', '789'), length)\nsapply(c('12345',\
    \ '789'), function(x) sum(x == char(x)))\nodd_character_counts(c('12345', '789'))\n\
    odd_character_counts(c('12345', '789'))\nNote that the example above is very slow\
    \ as it requires iterating over each character in the input vector. A more efficient\
    \ solution would be to use something like:\n\nsapply(c('12345', '789'), function(x)\
    \ sum(x == char(x)))\nThe example above will return the output below.\n\nThe number\
    \ of characters in '12345' is: 5\nThe number of characters in '789' is: 3\n\n\n\
    The number of characters in '12345' is: 5\nThe number of characters in '789' is:\
    \ 3\nThe number of characters in 'a' is: 5\nThe number of characters in 'b' is:\
    \ 5\nThe number of characters in 'c' is: 5\nThe number of characters in 'd' is:\
    \ 5\nThe number of characters in 'e' is: 5\nThe number of ", "\n    odd_count\
    \ <- function(x) {\n        odd_count <- sapply(x, function(str){\n          \
    \  length(str[str %% 2 != 0])\n        })\n        odd_count\n    }\n    x <-\
    \ unlist(lst)\n    length(x) <- length(unlist(lst))\n    odd_count(x)\n}\n", "\n\
    \  res <- c()\n  for(i in seq_along(lst)) {\n    res[i] <- paste(c('the number\
    \ of odd elements ', length(grep('odd', i)), 'n the str', nchar(tolower(unlist(strsplit(as.character(lst[i]),\
    \ \"\"))[-i])), 'of the ', nchar(tolower(unlist(strsplit(as.character(lst[i]),\
    \ \"\"))[-i])), 'input.'), collapse = ' ')\n  }\n  return(res)\n}\n", "\n  sapply(lst,\
    \ function(x){\n    sum(grepl('[0-9]$', x)) %>% \n      map(~length(x[.])) %>%\
    \ \n      unlist() %>% \n      paste(collapse = ' ')\n  })\n}\n", "\n  sapply(lst,\
    \ str_count, pattern = \"^[^0-9]+\") %>% \n    t() %>% \n    apply(1, sum) %>%\
    \ \n    cbind(lst) %>% \n    c()\n}\n</cell>\n<cell>", "\n  tmp <- unlist(lapply(lst,\
    \ as.character))\n  n <- nchar(tmp)\n  nchar(paste0(sub(\"^\", \"\", tmp), collapse\
    \ = \"\"))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt would be more efficient\
    \ to replace `tmp <- unlist(lapply(lst, as.character))` with `tmp <- sapply(lst,\
    \ as.character)`\n<|/ c |>\n<| c |>\nGood idea, I was just trying to keep the\
    \ answer as close to the original as possible. (I'm not very fluent in R, and\
    \ I like to stay true to what I know of R).\n<|/ c |>\n<| a tags=string,regex,r,count,character\
    \ |>\nHere are a couple of answers using dplyr::mutate and gsub:\n<code>\ndf <-\
    \ data.frame(\n    stringsAsFactors = FALSE,\n    str = c(\"1234567\", \"3\",\
    \ \"11111111\")\n)\n\ndf$odd_count <- gsub(\"[^0-9]\", \"\", df$str) %>%\n   \
    \ length\n\ndf$odd_count <- gsub(\"\\\\D\", \"\", df$str) %>%\n    length\n\n\
    df$odd_count <- as.integer(gsub(\"[^0-9]\", \"\", df$str)) %>%\n    length\n</code>\n\
    Results in:\n<code>\n> df\n   str    odd_count\n1 1234567           8\n2     3\
    \           1\n3 11111111           5\n</code>\n<|/ a dscore=2 |>\n<| c |>\nGreat\
    \ answer, but `gsub` has two problems. 1) It will remove all non-digits from the\
    \ string even if they are digits somewhere else in the string; 2) It will replace\
    \ all non-digits with an empty string, which will then count the characters. I\
    \ would advise `gsub(\"\\\\D\", \"\", df$str)` instead.\n<|/ c |>\n<| a dscore=1\
    \ tags=string,regex,r,count,character |>\nHere's a solution with stringr:\n<code>\n\
    library(stringr)", "\n  res <- list(list())\n  odd_string <- function(i) {\n \
    \   odd_length <- str_count(i, pattern = \"[[:digit:]]\", simplify = TRUE)\n \
    \   res[[i]][[1]] <- paste(odd_length, \"odd elements\", sep = \"n \")\n  }\n\
    \  lapply(lst, function(x) {\n    odd_string(x)\n  })\n  unlist(res)\n}\n</code>\n\
    We can then use mapply to apply this function to all the strings we have in our\
    \ list of strings.\n<code>\nmapply(odd_count, lst)\n</code>\nWe also can make\
    \ use of the fact that lapply will recycle results by default and that we know\
    \ that our list consists of strings.\n<code>\nmapply(odd_count, lst[[1]])\n</code>\n\
    The result will look like:\n<code>\n[[1]]\n[1] \"the number of odd elements 1n\
    \ the str1ng 1 of the 1nput.\"\n\n[[2]]\n[1] \"the number of odd elements 4n the\
    \ str4ng 4 of the 4nput.\"\n\n[[3]]\n[1] \"the number of odd elements 8n the str8ng\
    \ 8 of the 8nput.\"\n</code>\n<|/ a |>\n<| c |>\nThanks for your help. But when\
    \ I run your code I got the error of Error in odd_string(i) : object 'i' not found.\
    \ Do you know why?\n<|/ c |>\n<| c |>\nI used the function from the question.\
    \ I've updated the answer to include a step by step explanation.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nThis is a pretty good solution, though I think it can be improved\
    \ (maybe in a functional manner).  I thought the code would be readable for those\
    \ that are familiar with purrr.  \nFirst, create a function to count the odd-numbered\
    \ items in a string.  Here's a version that uses the purrr package (which I recommend\
    \ for R code).  It uses a helper function to do the counting:\n<code>\nlibrary(purrr)\n\
    \nodds <- function(x) {\n  x <- strsplit(x, \" \")\n  x <- map_chr(x, ~.x[str_count(.x,\
    \ \"[[:digit:]]\") %% 2 == 1])\n  x <- paste(x, collapse=\" \")\n  return(x)\n\
    }\n</code>\nNext, split the string on spaces to get a list of vectors.  Then map\
    \ the vector using odds to get the odd-numbered strings:\n<code>\nx <- c(\"one\
    \ two three four five six seven\", \"one two three four five six\")\n\ny <- map_chr(",
  "\n  output <- character(length(lst))\n  for(i in seq_along(lst)) {\n    output\
    \ <- paste(paste('the number of odd elements ', length(lst[[i]][which(grepl('\\\
    \\d', lst[[i]]))]), 'n the str', length(lst[[i]][which(grepl('\\\\d', lst[[i]]))]),\
    \ 'of', length(lst[[i]][which(grepl('\\\\d', lst[[i]]))]), ' of the ', length(lst[[i]][which(grepl('\\\
    \\d', lst[[i]]))]), '.', sep = \"\", collapse = \"\")\n  }\n  return(output)\n\
    }\n", "\n  sapply(strsplit(lst, \"\\\\d+\"), function(x) sum(grepl(\"1\", x)))\n\
    }\n</cell>\n<text>\nNow that you have your odds function, you can do the following\
    \ questions:\n\n\n</text>\n<text>\nQuestion 1b: Which of the following is true?\n\
    The odds function below is called a memoized function, which is a function whose\
    \ results get cached for later use. The function does not take a lot of time to\
    \ calculate (because it is just one line of code), but the caching only happens\
    \ once, at startup, so it takes longer time to calculate the same value twice.\n\
    The odd_count function uses strsplit, which is a relatively slow operation. Which\
    \ is faster?\nThe odd_count function calls grepl, which is a relatively slow operation.\
    \ Which is faster?\n\n\n</text>\n<text>\nThe first question answers your first\
    \ problem. Think about the second problem now. How would you solve it then?\n\n\
    \n</text>\n<text>\nQuestion 2: Write a function to find the longest substring\
    \ that contains no two adjacent digits.\nWrite a function to find the longest\
    \ substring that contains no two adjacent digits. Then, write a function to find\
    \ the longest substring that contains no two adjacent digits in the first two\
    \ strings. Then, write a function to find the longest substring that contains\
    \ no two adjacent digits in the first two strings and no two adjacent digits in\
    \ the third string. Then, write a function to find the longest substring that\
    \ contains no two adjacent digits in the first two strings and no two adjacent\
    \ digits in the third string and no two adjacent digits in the fourth string.\
    \ Then, write a function to find the longest substring that contains no two adjacent\
    \ digits in the first two strings and no two adjacent digits in the third string\
    \ and no two adjacent digits in the fourth string and no two adjacent digits in\
    \ the fifth string. Then, write a function to find the longest substring that\
    \ contains no two adjacent digits in the first two strings and no two adjacent\
    \ digits in the third string and no two adjacent digits in the fourth string and\
    \ no two adjacent digits in the fifth string and no two adjacent digits in the\
    \ sixth string. Then, write a function to find the longest substring that contains\
    \ no two adjacent digits in the first two strings and no two adjacent digits in\
    \ the third string and no two adjacent digits in the fourth string and no two\
    \ adjacent digits in the fifth string and no two adjacent digits in the sixth\
    \ string and no two adjacent digits in the seventh string.\nThen, write a function\
    \ to find the longest substring that contains no two adjacent digits in the first\
    \ two strings and no two adjacent digits in the third string ", "\n  \n  n <-\
    \ length(lst)\n  if(n <= 1) return(c())\n  \n  if(sum(grepl('[^0]$', lst)) ==\
    \ 1) return(c())\n  \n  odd_elements <- rep(NA, length(lst_str))\n  \n  for(i\
    \ in seq_along(lst)) {\n    if(grepl('[^0]$', lst[[i]])) return(c())\n    \n \
    \   grep('[^0]$', lst[[i]], value = TRUE, invert = TRUE, fixed = TRUE)\n    \n\
    \    odd_elements[i] <- sum(grepl('[^0]$', lst[[i]]))\n    \n  }\n  \n  return(c(paste0('the\
    \ number of odd elements ', odd_elements, ' of the ', n, ' string.')))\n}\n",
  "\n  x <- lst # x = '1234567'\n  num.odd <- 0\n  for(i in x) {\n    if(i %% 2 !=\
    \ 0) num.odd <- num.odd + 1 # i = '3'\n    if(i %% 3 != 0) num.odd <- num.odd\
    \ + 1 # i = '11111111'\n    if(i %% 4 != 0) num.odd <- num.odd + 1 # i = '1234567'\n\
    \  }\n  return(c)((paste0('the number of odd elements ', num.odd, ' the str',\
    \ length(x), ' of ', length(x), '.')))\n}\n", "\n  x <- seq_along(lst)\n  x[!is.na(odd_count(sub(\"\
    [^0-9]\", \"\", lst[x]))) ] <- \n    length(sub(\"[^0-9]\", \"\", lst[x]))\n \
    \ lst[x]\n}\n", "\n  sapply(lst, function(x) {\n    if (typeof(x) %in% c('double',\
    \ 'numeric')) {\n      paste('the number of odd elements ', x %/% 2 %% 2, 'n the\
    \ str', x %/% 2 %% 2 %*% x, 'of the ', x %*% x %in% c('5', '15'))\n    } else\
    \ if (is.character(x)) {\n      paste('the number of odd elements ', x %/% 2 %%\
    \ 2, 'n the str', x %/% 2 %% 2 %*% x, 'of the ', x %*% x %in% c('5', '15'))\n\
    \    } else {\n      paste('the number of odd elements ', x %/% 2 %% 2, 'n the\
    \ str', x %/% 2 %% 2 %*% x, 'of the ', x %*% x %in% c('5', '15'))\n    }\n  })\n\
    }\n", "\n  sapply(lst, function(x) {\n    if (nchar(x) != 0) {\n      paste0('the\
    \ number of odd elements ', nchar(x), ' the str', nchar(x), ' of the ', nchar(x),\
    \ ' of the input.')\n    } else {\n      NA_character_\n    }\n  })\n}\n", "\n\
    \  if (length(lst) == 0)\n    stop(\"Empty list\")\n  result <- as.character(lst[1])\n\
    \  for (i in seq_along(lst)){\n    result <- paste0(result, 'n the str', i, '.',\
    \ \n                     sapply(lst[(i+1):length(lst)], \n                   \
    \         function(x) odd_count(unlist(strsplit(x, \"\"))))\n                \
    \     )\n  }\n  return(result)\n}\n", "\n  nums <- vector(mode = \"list\", length\
    \ = length(lst))\n  for (i in seq_along(lst)) {\n    nums[[i]] <- sum(grepl(\"\
    odd\", lst[[i]]))\n  }\n  cat(paste0(names(nums), \" is the number of odd elements\
    \ in \", names(lst), \" of the \", names(lst), \".\"))\n  cat(paste0(\"the number\
    \ of odd elements \", nums, \" of the \", names(lst), \" \", paste0(length(nums),\
    \ \" \", ifelse(nums == 0, \"zero\", \"one\"), \" of the \", names(lst), \" \"\
    , names(lst), \".\")), sep = \"\")\n  cat(\"\\n\", sep = \"\")\n  return(list(nums,\
    \ paste0(names(nums), \" is the number of odd elements in \", names(lst), \" of\
    \ the \", names(lst), \".\")))\n}\n</cell>\n<cell>", "\n  lst <- as.character(lst)\n\
    \  str <- strsplit(lst, \"\")\n  str <- lapply(str, function(x) as.numeric(x)+x)\n\
    \  sapply(str, length)\n}\n\nodd_count_2 <- function(lst) {\n  sapply(lst, function(x)\
    \ sum(grepl(\"^\\\\d$\", x)))\n}\n", "\n    \n    sum(sapply(lst, '%in%', c(odd(lst),\
    \ rep(1, length(odd(lst)))))) * \"the number of odd elements \"\n}\n", "\n  output\
    \ <- character(length(lst))\n  for(i in seq_along(lst)) {\n    output <- paste0(output,\
    \ 'the number of odd elements ', sum(grepl('[1-9]', lst[i])), 'n the str', nchar(lst[i]),\
    \ 'of the str', nchar(lst[i]), 'of the input.')\n  }\n  return(output)\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\n`grepl` is vectorized. No need for a `for` loop. Plus,\
    \ your function does not return the strings, but it returns just a single character\
    \ string containing the numbers of the odd digits. The OP wants the return value\
    \ to contain the strings of the odd digits.\n<|/ c |>\n<| c |>\n`grepl` is vectorized\
    \ over `grep` matches. `grep` matches each element in `lst` against `grepl('[1-9]',\
    \ lst[i])` and returns a logical vector (i.e. `TRUE` for any number that satisfies\
    \ the condition). `sum` sums the logical vector and returns the count of elements\
    \ (i.e. `TRUE` values). `grepl('[1-9]', lst[i])` is the same as `grep(paste0('[1-9]',\
    \ lst[i]), lst)` but it makes the code a bit more readable by grouping the `paste0`s\
    \ together in one line.\n<|/ c |>\n<| a |>\nHow about this?\n<code>\nodd_digits\
    \ <- function(string) {\n  res <- lapply(string, function(x)\n    sum(grepl('[0-9]',\
    \ x) & grepl('[1-9]', x)) / (length(x) + 1) \n  )\n  paste(res, collapse = ',\
    \ ')\n}\n\nodd_digits(c('123 4567', '123'))", "\n    odd_list <- c()\n    for\
    \ (string in lst) {\n        number_odd <- length(str_split(string, \"[0-9]+\"\
    )[[1]])\n        odd_list <- c(odd_list, paste(number_odd, collapse = \" \"))\n\
    \    }\n    c(\"the number of odd elements \", odd_list, \" of the \", length(lst),\
    \ \" input.\")\n}\n", "\n  # TODO: write docstring\n  # The first two elements\
    \ are the oddness of the string and the total number.\n  odd_counts <- rep(list(list(odd_number(lst[1]),\
    \ odd_number(lst[2]))),\n                     sapply(lst[-1], nchar))\n  # The\
    \ last element is the odd_count of each string in lst\n  list(odd_counts, odd_count(unlist(lst[-1])))\n\
    }\n", "\n  unlist(lapply(lst, function(s) strsplit(s, '', fixed = TRUE)[[1]] %in%\
    \ c('1', '8')))\n}\n</cell>\n<cell>", "\n  l <- unlist(lst)\n  lst <- lapply(l,\
    \ function(x) ifelse(grepl('[1-9]', x), length(x) - 1, 0))\n  c(paste0('the number\
    \ of odd elements ', nchar(unlist(lst))), paste0('the number of odd elements ',\
    \ nchar(unlist(lst)), 'n the str', nchar(unlist(lst)), ' of the ', nchar(unlist(lst)),\
    \ 'nput.'))\n}\n</cell>\n<text>\nPalindrome\n\n</text>\n<cell>", "\n  if(length(lst)\
    \ == 0) {\n    return()\n  } else {\n    ans <- 1\n    for(i in 1:length(lst))\
    \ {\n      if(substr(lst[i], i, i + 1) == substr(lst[i], i, i + 1)) {\n      \
    \  ans <- ans + 1\n      }\n    }\n    return(\n      c(\n        paste0('the\
    \ number of odd elements ', ans, 'n the str', length(lst), 'of the ', length(lst),\
    \ 'input.')\n      )\n    )\n  }\n}\n</cell>\n<cell>", "\n  # Helper function\
    \ to return string with count of odd elements in each string.\n  str <- sapply(lst,\
    \ function(x) {\n    paste0('the number of odd elements ', length(x), ' the str',\
    \ length(x), ' of the str', length(x), '.')\n  })\n  c(str, str)\n}\n</code>\n\
    The next step is to modify the function that you have written:\n<code>", "\n \
    \ odd_counts <- list();\n  for (i in seq_along(lst)) {\n    odd_count <- sum(grepl(\"\
    ^\\\\d+$\", lst[[i]])) / length(lst[[i]])\n    odd_counts[[i]] <- as.character(odd_count);\n\
    \  }\n  c(odd_counts);\n}\n</cell>\n<text>\nNow that we have our function we can\
    \ use it. For this first exercise, we'll use the built-in vector c('1234567',\
    \ '1', '22', '33', '4444', '5555', '6666', '77777', '8888888') to test our function\
    \ with. The first few lines of output should look something like:\n\n[[1]]\n[1]\
    \ \"the number of odd elements 5n the str5ng 1 of the 1nput.\"\n\n[[2]]\n[1] \"\
    the number of odd elements 3n the str3ng 2 of the 2nput.\"\n\n[[3]]\n[1] \"the\
    \ number of odd elements 1n the str1ng 1 of the 1nput.\"\n\n[[4]]\n[1] \"the number\
    \ of odd elements 2n the str2ng 3 of the 3nput.\"\n\n[[5]]\n[1] \"the number of\
    \ odd elements 3n the str3ng 1 of the 4nput.\"\n\n[[6]]\n[1] \"the number of odd\
    \ elements 4n the str4ng 2 of the 5nput.\"\n\n[[7]]\n[1] \"the number of odd elements\
    \ 4n the str4ng 1 of the 6nput.\"\n\n[[8]]\n[1] \"the number of odd elements 3n\
    \ the str3ng 2 of the 7nput.\"\n\n[[9]]\n[1] \"the number of odd elements 4n the\
    \ str4ng 1 of the 8nput.\"\n\n[[10]]\n[1] \"the number of odd elements 4n the\
    \ str4ng 1 of the 9nput.\"\n\n[[11]]\n[1] \"the number of odd elements 5n the\
    \ str5ng 2 of the 10nput.\"\n\n[[12]]\n[1] \"the number of odd elements 3n the\
    \ str3ng 2 of the 11nput.\"\n\n[[13]]\n[1] \"the number of odd elements 4n the\
    \ str4ng 1 of the 12nput.\"\n\n[[14]]\n[1] \"the number of odd elements 4n the\
    \ str4ng 1 of the 13nput.\"\n\n[[15]]\n[1] \"the number of odd elements 3n the\
    \ str3ng 2 of the 14nput.\"\n\n[[16]]\n[1] \"the number of odd elements 4n the\
    \ str4ng 1 of the 15nput.\"\n\n[[17]]\n[1] \"the number of odd elements 4n the\
    \ str4ng", "\n  lapply(lst, function(x) {\n    x2 <- strsplit(x, split='')[[1]]\n\
    \    x2 <- as.integer(x2)\n    length(x2[x2%%2==1]) / length(x2)\n  })\n}\n</cell>\n\
    <cell>", "\n  sapply(lst, function(x)\n    length(which(grepl('[1-9]', x) & grepl('[0-4]',\
    \ x) & grepl('[0-4]', x) &\n                   grepl('[0-4]', x) &\n         \
    \          grepl('[0-4]', x) &\n                   grepl('[0-4]', x) &\n     \
    \              grepl('[0-4]', x) &\n                   grepl('[0-4]', x) &\n \
    \                  grepl('[0-4]', x))))\n}\n</code>\n<|/ a dscore=1 tags=r,regex\
    \ |>\n<| a dscore=0 tags=r,regex |>\nI would use regex here as well:\n<code>\n\
    > x <- c('11111111', '32211111', '42424242')\n> strsplit(x, split='(?<=\\\\d)(?=\\\
    \\d)')[[1]][apply(strsplit(x, split='(?<=\\\\d)(?=\\\\d)')[[1]], 1, function(x)\
    \ \n+     sum(x == 1)) != 0]\n[1] \"the number of odd elements 1n the str1ng 1\
    \ of the 1nput.\"\n[2] \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\
    \n</code>\nExplanation:\n<code>\n> x <- c('11111111', '32211111', '42424242')\n\
    > strsplit(x, split='(?<=\\\\d)(?=\\\\d)')[[1]]\n[1] \"11111111\" \"32211111\"\
    \  \"42424242\"\n</code>\nThis splits the string into substrings by the pattern\
    \ that matches non-digit characters followed by a digit character. Here we get\
    \ the first two elements. We then apply the function to the first element using\
    \ apply, which returns the number of matches found by strsplit:\n<code>\n> apply(strsplit(x,\
    \ split='(?<=\\\\d)(?=\\\\d)')[[1]], 1, function(x) \n+     sum(x == 1)) != 0\n\
    [1] FALSE  TRUE  TRUE\n</code>\nThen we get the number of elements that are not\
    \ zero using sum.\nThe result looks like this:\n<code>\n> strsplit(x, split='(?<=\\\
    \\d)(?=\\\\d)')[[1]][apply(strsplit(x, split='(?<=\\\\d)(?=\\\\d)')[[1]], 1, function(x)\
    \ \n+     sum(x == 1)) != 0]\n[1] \"the number of odd elements 1n the str1ng 1\
    \ of the 1nput.\"\n[2] \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\
    \n</code>\n<|/ a |>\n<| c |>\nThanks for your effort but as I mentioned the regex ",
  "\n  sapply(lst, function(x) {\n    x <- nchar(x)\n    sapply(seq_along(x), function(y)\
    \ {\n      y <- sapply(y, function(z) {\n        z <- nchar(z)\n        if (z%%2\
    \ == 1) {\n          y\n        } else {\n          0\n        }\n      })\n \
    \     length(which(y==1))\n    })\n  })\n}\n</cell>\n<text>\nProblem 2\nWrite\
    \ a function prime_count that takes as an input a list of integers and returns\
    \ the number of primes found in the list.\n\nThe prime factors of n are 2, 3,\
    \ 5, 7, 11, and 13. Your function should return 0 if the input has no prime factors.\
    \ Note that 2 is not a prime number. Also, 0 and 1 are not prime numbers, but\
    \ every other number is prime (ie: their prime factors are 1 and 1).\n\n\n</text>\n\
    <cell>", "\n    odd <- rep(0,length(lst))\n    for(i in 1:length(lst))\n     \
    \   odd[i] <- sum(grepl(\"[0-9]\", lst[i]))\n    return(list(str=gsub(\"[0-9]\"\
    , \"n\", names(odd)), val=unname(odd)))\n}\n</code>\nHere's another way that uses\
    \ a single call to grep and counts the number of characters:\n<code>", "\n  mapply(function(str)\
    \ {\n    x <- strsplit(str, \"\\\\D\")[[1]]\n    paste(length(setdiff(x, x)),\
    \ 'n the str', length(x), 'of', length(str), 'input.', sep=\"\")\n  }, lst)\n\
    }\n</code>\nThen the function works on vectors directly:\n<code>\n> odd_count(c(3,\
    \ 5, 7))\n[1] \"the number of odd elements 3n the str3ng 3 of the 3nput.\"\n[2]\
    \ \"the number of odd elements 4n the str4ng 4 of the 4nput.\"\n[3] \"the number\
    \ of odd elements 5n the str5ng 5 of the 5nput.\"\n[4] \"the number of odd elements\
    \ 7n the str7ng 7 of the 7nput.\"\n</code>\nAnd it works on whole vectors at once:\n\
    <code>\n> odd_count(c(3, 5, 7, 9))\n[1] \"the number of odd elements 3n the str3ng\
    \ 3 of the 3nput.\" \n[2] \"the number of odd elements 4n the str4ng 4 of the\
    \ 4nput.\" \n[3] \"the number of odd elements 5n the str5ng 5 of the 5nput.\"\
    \ \n[4] \"the number of odd elements 7n the str7ng 7 of the 7nput.\" \n[5] \"\
    the number of odd elements 9n the str9ng 9 of the 9nput.\"\n</code>\nAnd we can\
    \ apply it to multiple inputs at once:\n<code>\n> odd_count(c(3, 5, 7, 9), c(4,\
    \ 5, 8))\n[1] \"the number of odd elements 3n the str3ng 3 of the 3nput.\" \n\
    [2] \"the number of odd elements 4n the str4ng 4 of the 4nput.\" \n[3] \"the number\
    \ of odd elements 5n the str5ng 5 of the 5nput.\" \n[4] \"the number of odd elements\
    \ 7n the str7ng 7 of the 7nput.\" \n[5] \"the number of odd elements 9n the str9ng\
    \ 9 of the 9nput.\"\n[6] \"the number of odd elements 4n the str4ng 4 of the 4nput.\"\
    \ \n[7] \"the number of odd elements 5n the str5ng 5 of the 5nput.\" \n[8] \"\
    the number of odd elements 8n the str8ng 8 of the 8nput.\"\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI edited my question to give an example of the expected output\
    \ that I would have if I ran this over a vector containing both numbers and letters.\n\
    <|/ c |>\n", "\n  num <- list()\n  for (i in seq_along(lst)) {\n    str_i <- as.character(lst[[i]])\n\
    \    num[[i]] <- paste0('the number of odd elements ', length(str_i),\n      \
    \                  'n the str', str_i,\n                        ' of the ', length(str_i),\
    \ '.')\n  }\n  c(sapply(num, paste, collapse='\\n'))\n}\n", "\n  # Use `table`\
    \ to get the count of digits in a character vector.\n  # `table` returns a list\
    \ whose ith element is the number of occurrences of \n  # the ith digit in the\
    \ input.\n  tbl <- table(unlist(lst))\n  # The index of the digit with the highest\
    \ occurrence count\n  # is `which.max(tbl)`.\n  output <- paste0(\"the number\
    \ of odd elements \", \n                    tbl[which.max(tbl)], \"n the str\"\
    , \n                    max(tbl), \"of the \", \n                    max(tbl),\
    \ \"input.\" )\n  return(output)\n}\n", "\n    count <- 0\n    for (i in seq_along(lst))\
    \ {\n        count <- count + sum(grepl(\"\\\\d\", lst[i]))\n    }\n    cat(paste(\"\
    the number of odd elements \", count, \" of the \", length(lst), \" strings of\
    \ the \", length(lst), \" input.\"), \"\\n\", sep=\"\")\n}\nodd_count(c(\"3\"\
    , \"11111111\", \"13\", \"12\"))\n</cell>\n<cell>", "\n  nl <- length(lst)\n \
    \ out <- rep(list(list(length = 0, odd = 0, input = 1)), nl)\n  for (i in 1:nl)\
    \ {\n    out[[i]] <- out[[i]][[1]] %>%\n      mutate(length = nchar(as.character(input)))\
    \ %>%\n      mutate(odd = as.integer(length) - as.integer(odd)) %>%\n      mutate(input\
    \ = ifelse(odd > 0, paste(substr(input, 1, odd), collapse = \"\"), input))\n \
    \ }\n  return(out)\n}\n", "\n  lapply(\n    lst,\n    function(x)\n      length(strsplit(x,\
    \ \"\")[[1]][sapply(strsplit(x, \"\"), `%in%`, c(\"1\", \"7\"))])\n  )\n}\n",
  "\n  return(substitute(do.call(paste, c(list(lengths(lst)), list(sep = ''))), \n\
    \                     list(n = names(lst), str = lst)))\n}\n</code>\nThis code\
    \ will work on any number of strings (assuming you change the input vector to\
    \ have the right number of elements). \n<code>", "\n  num <- numeric(length(lst))\n\
    \  for(i in seq_along(lst)) {\n    x <- unlist(strsplit(lst[i], \"\"))\n    num[i]\
    \ <- sum(x[x%%2==1])\n  }\n  return(list(words(\"the number of odd elements \"\
    ), num))\n}\n", "\n    for(i in seq_along(lst)) {\n        lst[[i]] <- paste0(\"\
    the number of odd elements \", str_count(lst[[i]], pattern = \"\\\\d\")[[1]],\
    \ \" the str \", i, \" of the \", i, \" input.\")\n    }\n    lst\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for taking the time to go through this. I appreciate\
    \ the effort you put into this.\n<|/ c |>\n<| c |>\n: This is indeed a much more\
    \ compact solution. It would be even better if it would work on strings with more\
    \ than just one digit. I would also suggest to rename the function to `odd_count_str`\
    \ or something similar.\n<|/ c |>\n<| c |>\n: I thought about your suggestion\
    \ of changing the function name but decided that it would make the code longer\
    \ than it would need to be. The `odd_count_str` function doesn't handle strings\
    \ with more than one digit but as I said, it does make the code easier to understand.\n\
    <|/ c |>\n<| c |>\nThank you for making this into a much more compact solution.\n\
    <|/ c |>\n<| a dscore=0 |>\nFor this solution, I used purrr package. I first converted\
    \ the character vector to numeric vector by using the map function.\nThen I used\
    \ the count function from dplyr. Since I don't have the exact data that you have\
    \ provided, I created a sample data.\n<code>\ndf <- data.frame(name = c('111111',\
    \ '11111', '3', '2', '10'))\n\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(stringr)\n\
    \ndf %>%\n  mutate(name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = map(name, ~stringr::str_count(., pattern = as.numeric(.))),\n\
    \         name = ", "\n    odd <- function(x) {\n        odd <- !x %in% c(\"\"\
    , NA)\n        nchar(as.character(x)) * (odd==T ? 1 : -1)\n    }\n    result <-\
    \ lapply(lst, odd)\n    names(result) <- sapply(lst, deparse)\n    unname(result)\n\
    }\n", "\n  odd_list <- lapply(lst, function(x){\n    sum <- 0\n    for(i in x){\n\
    \      if(grepl('[0-9]', i)){\n        sum <- sum + as.integer(i)\n      }\n \
    \   }\n    return(sum)\n  })\n  c(paste0('the number of odd elements ', gsub(\"\
    \ \", \"\", \n    paste(as.integer(names(odd_list)), odd_list, sep = \"\")), '\
    \ of the ',\n    names(lst),\n    ' input.'))\n}\n", "\n  sapply(lst, function(x)\
    \ sum(grepl(\"[13579]\",x)))\n}\n", "\n  lst <- as.character(lst)\n  out <- \"\
    \"\n  for(i in seq_along(lst)) {\n    if(substr(lst[i], 1, 1) %in% c(\"0\", \"\
    1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\")) {\n      len <-\
    \ substr(lst[i], 1, 1) == \"0\"\n      len <- as.numeric(substr(lst[i], 2, 2))\n\
    \      out <- c(out, paste(c(length(which(len)), \"n\", substr(lst[i], 3)), collapse\
    \ = \" \"))\n      i <- i + 1\n      if(i > length(lst)) {\n        break\n  \
    \    }\n    }\n  }\n  return(out)\n}\n", "\n  str_count <- function(x) {\n   \
    \ str_length(x) %% 2 != 0\n  }\n  c(paste('the number of odd elements ', \n  \
    \         sapply(lst, str_length), ' of the ', \n           sapply(lst, str_count),\
    \ ' of the input ', \n           collapse = ''), \n    '.', collapse = '')\n}\n",
  "\n  res <- c()\n  for(i in seq_along(lst)) {\n    x <- 0\n    while(x != 1) x <-\
    \ sum(substr(lst[[i]], i, i)[-1])\n    res <- c(res, list(x))\n  }\n  return(res)\n\
    }\n\nodd_count('11011')", "\n  for(i in seq_along(lst))\n    if(is.na(sum(gregexpr('[0-9]',\
    \ lst[[i]]))))\n      return(c(paste0('the number of odd elements ', i, ' the\
    \ str', i, ' of the ', i, ' input'), ''))\n  return(c(paste0('the number of odd\
    \ elements ', seq_along(lst), 'n the str', seq_along(lst), 'n of the ', seq_along(lst),\
    \ 'n input'), ''))\n}\n</code>\nThis can now be used in a pipeline to easily print\
    \ out a table:\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(magrittr)\n\n\
    df <- tibble(num = c('1', '12', '123', '1234', '12345', '123456'))\n\ndf %>%\n\
    \  mutate(odd_nums = map_chr(num, ~odd_count(.x))) %>%\n  unnest() %>%\n  mutate(odd_nums\
    \ = ifelse(odd_nums == '', '', odd_nums)) %>%\n  mutate(odd_num = as.numeric(odd_nums))\
    \ %>%\n  mutate(odds = paste0('the ', odd_num, ' of the ', num, ' input')) %>%\n\
    \  mutate(num = ifelse(num %in% c('', '1', '12', '123', '1234', '12345', '123456'),\
    \ num, NA)) %>%\n  select(num, odds)\n</code>\nResult:\n<code>", "\n    output\
    \ <- \"\"\n    for (i in seq_along(lst)) {\n        if (length(unlist(strsplit(lst[[i]],\
    \ \"\"))) == 1) {\n            output <- c(output, paste(length(unlist(strsplit(lst[[i]],\
    \ \"\")))))\n        } else {\n            output <- c(output, paste(length(unlist(strsplit(lst[[i]],\
    \ \"\"))), \" \"))\n        }\n    }\n    return(output)\n}\n", "\n  odd_lists\
    \ <- lapply(lst, function(s) {\n    s <- unlist(strsplit(s, '', fixed = TRUE))\n\
    \    odd_counts <- as.numeric(unlist(strsplit(s, nchar(s) %% 2, fixed = TRUE)))\n\
    \    paste0(paste(c(odd_counts), collapse = ', '), 'n')\n  })\n  return(do.call(c,\
    \ odd_lists))\n}\n", "\n  num <- lengths(lst)\n  lens <- lengths(num)\n  num_odd_el\
    \ <- lengths(which(num %% 2))\n  if(all(lens <= num_odd_el)) {\n    c(paste(lens,\
    \ num_odd_el, sep = 'n the '), paste(lens - num_odd_el, lens, sep = 'n the '))\n\
    \  } else {\n    c(paste(num_odd_el, lens, sep = 'n the '), paste(num_odd_el,\
    \ lens - num_odd_el, sep = 'n the '))\n  }\n}\n", "\n    cat(\"c(\", paste(grep(\"\
    ^\\\\d$\", lst, value = TRUE, invert = TRUE), collapse = \", \"), \") \", sep\
    \ = \"\")\n}\n", "\n  lapply(lst,\n         function(str){\n           len <-\
    \ str_length(str)\n           as.numeric(unlist(strsplit(str, \"\")))[len]\n \
    \        })\n}\n", "\n  lapply(lst,\n         function(x) {\n           if (length(x)\
    \ == 0) return(NULL)\n           if (grepl('[0-9]', x)) return(length(grep('[0-9]',\
    \ x)))\n           return(c(paste('the number of odd elements', length(grep('[0-9]',\
    \ x)), 'n the str', length(grep('[0-9]', x)), 'of the ', length(x),\n        \
    \              'input.', sep = '')))\n         })\n}\n</cell>\n<cell>", "\n  stopifnot(length(lst)\
    \ > 1)\n  output <- c(\n    paste0(\"the number of odd elements \", length(\n\
    \      Filter(\n        Negate(grepl), strsplit(lst, \"(?<=[0-9])\"))[[1]][1]),\
    \ \" \", lst[[1]]),\n    paste0(\"the number of odd elements \", length(\n   \
    \   Filter(\n        Negate(grepl), strsplit(lst, \"(?<=[0-9])\"))[[1]][2]), \"\
    \ \", lst[[2]])\n  )\n  return(output)\n}\n</cell>\n<cell>", "\n  if (length(lst)\
    \ == 0) {\n    return(lst)\n  }\n  odd_count <- function(string, i) {\n    len_string\
    \ <- length(string)\n    len_list <- length(lst)\n    if (len_list == 0) {\n \
    \     return(lst)\n    }\n    odd_count <- function(list, i) {\n      odd_digits\
    \ <- 0\n      odd_digits <- length(str_split(string[i], pattern = \"\\\\d\"))\n\
    \      odd_digits <- odd_digits - list[i]\n      return(odd_digits)\n    }\n \
    \   odd_digits <- 0\n    odd_digits <- odd_count(string[i], i)\n    odd_digits\
    \ <- odd_digits + odd_count(list, i)\n    return(odd_digits)\n  }\n  odd_digits_list\
    \ <- mapply(odd_count, lst, seq_along(lst))\n  return(odd_digits_list)\n}\n",
  "\n  sapply(lst, str_detect, pattern = \"\\\\d\") %>%\n    map_int(~sum(.x & str_detect(.x,\
    \ \"\\\\d\"))) %>%\n    set_names(unique(c(lst))) %>%\n    reduce(.) %>%\n   \
    \ c(\"the number of odd elements\", .)\n}\n</code>\nWe can then implement a function\
    \ to get the odd sum:\n<code>", "\n  stopifnot(all(sapply(lst, isdigit)))\n  \n\
    \  odd_counts <- c()\n  \n  for(i in seq_along(lst)) {\n    odd_counts <- c(odd_counts,\n\
    \                    lengths(strsplit(as.character(lst[i]), \"\")))\n  }\n  \n\
    \  return(odd_counts)\n}\n</code>\n<code>", "\n  # Initialize counts\n  len <-\
    \ sapply(lst, length)\n  counts <- numeric(length(lst))\n  \n  # Get the number\
    \ of odd elements in each string\n  sapply(lst, function(x, i) sum(x %% 2 != 0)\
    \ | len[i] <- len[i])\n  \n  # Return the number of odd elements for each string\n\
    \  apply(counts, 1, function(x) paste(x, collapse = ' '))\n}\n", "\n  strlens\
    \ <- strsplit(as.character(lst), \"\")\n  strlens[[1]]\n}\n\nodd_count(\"111111\"\
    )", "\n  if (length(lst)==0) {\n    return('0')\n  }\n  s <- strsplit(toString(lst),'')[[1]]\n\
    \  s <- lapply(s, function(x) gsub(\"[0-9]\", \"\", x))\n  sum(sapply(s, function(x)\
    \ length(gregexpr('\\\\d',x)[[1]])))\n}\n</code>\nAnd a version of odd_count2\
    \ that gives a numeric vector instead of a list:\n<code>\nodd_count2 <- function(lst)\
    \ {\n  if (length(lst)==0) {\n    return(0)\n  }\n  s <- strsplit(toString(lst),'')[[1]]\n\
    \  s <- lapply(s, function(x) gsub(\"[0-9]\", \"\", x))\n  sum(sapply(s, function(x)\
    \ length(gregexpr('\\\\d',x)[[1]])))\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    I came up with a solution using stringr and purrr packages. I think it can be\
    \ more elegant.\n<code>", "\n  # TODO: Improve performance\n  ret <- c(\n    \"\
    the number of odd elements \", \n    apply(lst, 2, sum)\n  )\n  return(ret)\n\
    }\n", "\n  sapply(lst,function(x) sum(grepl('\\\\d',x))==0)\n}\n", "\n  x <- sapply(lst,\
    \ strsplit, split=\"\")\n  x <- lapply(x, function(i) {\n    y <- as.numeric(i[!is.na(i)])\n\
    \    if (length(y) == 0) y <- c(\"0\")\n    else y <- paste(y,collapse = \"\"\
    )\n  })\n  y <- sapply(x, length)\n  z <- data.frame(y=rep(y,x), stringsAsFactors=FALSE)\n\
    \  z <- z[order(z$y),]\n  z$x <- seq(nrow(z)) + rep(c(1,2),each=nrow(z))\n  return(paste(paste(c(z$y,\
    \ z$x), collapse=\"\"), collapse=\", \" ))\n}\n", "\n  odd_count_helper <- function(x,\
    \ n = 1) {\n    n <- n + 1\n    i <- 1\n    while(i <= length(x)) {\n      if\
    \ (x[[i]] %% 2 != 0) {\n        n <- n\n      }\n      i <- i + 1\n    }\n   \
    \ return(n)\n  }\n  return(Reduce(odd_count_helper, lst))\n}\n", "\n  if (length(lst)==0)\
    \ return(list())\n  odd_count <- rep(0:1, times = ceiling(length(lst)/2))\n  odd_count\
    \ <- c(cumsum(odd_count), length(lst)-cumsum(odd_count))\n  odd_count <- rep(odd_count,\
    \ rep(c(FALSE, TRUE), times = length(odd_count)-1))\n  odd_count <- odd_count[!odd_count]\n\
    \  odd_count <- setNames(odd_count, as.character(seq_along(odd_count)))\n  odd_count\n\
    }\n", "\n  sapply(lst, function(i) {\n    # Replace all i's in each string with\
    \ the number of odd digits in the i'th\n    # string of the input\n    n <- sum(strsplit(i,\
    \ \"\")[[1]] == \"1\")\n    paste(lengths(strsplit(i, \"\")[[1]][strsplit(i, \"\
    \")[[1]] %in% \"1\"])-n, collapse = \"n the str\")\n  })\n}\n</code>\nAnd another\
    \ one that replaces the odd digits with the number of times it occurs:\n<code>",
  "\n  n <- length(lst)\n  res <- rep(0,n)\n  for(i in seq(n)) {\n    res[i] <- sum(grepl(\"\
    [13579]\", lst[i]))\n  }\n  return(paste0(\"the number of odd elements \", n,\
    \ \"n the \", paste(lst,collapse=\", \")))\n}\n", "\n  lst[sapply(lst, is.digit)]\n\
    }\n", "\n    l <- strsplit(lst, \"\")\n    s <- lapply(l, function(x) strsplit(x,\
    \ \"\")[[1]]) # split on chars\n    o <- lapply(s, function(x) sapply(x, function(x)\
    \ length(odd_digits(x))) # count odd in each string\n    unname(Reduce(function(x,\
    \ y) c(x, y), o)) # unnest list into a vector\n}\n</code>\n<|/ a tags=r |>\n<|\
    \ a dscore=2 tags=r |>\nUsing stringr:\n<code>\nlibrary(stringr)\nodd_digit <-\
    \ function(x) {\n   str_count(x, \"\\\\d\") - 1L\n}\n\nodd_count(c(\"1234567\"\
    ))"]
stop_tokens:
- "\n#"
- "\n```"
