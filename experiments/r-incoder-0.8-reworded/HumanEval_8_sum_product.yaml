name: HumanEval_8_sum_product
language: r
prompt: "# For a given list of integers, return a list consisting of a sum and a product\
  \ of all the integers in a list.\n# Empty sum should be equal to 0 and empty product\
  \ should be equal to 1.\n# >>> sum_product(c())\n# c(0, 1)\n# >>> sum_product(c(1,\
  \ 2, 3, 4))\n# c(10, 24)\nsum_product <- function(numbers) {"
tests: "test_humaneval <- function() {\ncandidate <- sum_product\n    if(!identical(candidate(c()),\
  \ c(0, 1))){quit('no', 1)}\n    if(!identical(candidate(c(1, 1, 1)), c(3, 1))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(100, 0)), c(100, 0))){quit('no', 1)}\n    if(!identical(candidate(c(3,\
  \ 5, 7)), c(15, 105))){quit('no', 1)}\n    if(!identical(candidate(c(10)), c(10,\
  \ 10))){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  sapply(numbers, function(x) c((sum(x)), prod(x)))\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=r |>\nIf we are just looking at simple arithmetic\
    \ sum and product of elements of a vector\n<code>\nv1 <- c(1, 2, 3, 4, 5)\nv1*v1\n\
    </code>\nIf we need to include NA in the calculation\n<code>\nv1*v1 + NA\n</code>\n\
    If we need to include zero in the calculation\n<code>\nv1*v1 + (0 | NA)\n</code>\n\
    If we need to include NA with zero in the calculation\n<code>\nv1*v1 + (0 | NA)\
    \ * NA\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=r |>\nYou can use rep to\
    \ replicate the vector, then sum and prod on the replicated vector\n<code>\nv1\
    \ <- c(1, 2, 3, 4, 5)\n\nsum(v1 * rep(v1, 3))", "\n  numbers <- sort(numbers)\n\
    \  sum <- 0\n  product <- 1\n  for (i in seq_along(numbers)) {\n    sum <- sum\
    \ + numbers[i]\n    product <- product * numbers[i]\n  }\n  cbind(sum = sum, product\
    \ = product)\n}\n", "\n  numbers <- sort(numbers)\n  return(list(sum = sum.default(na.omit(numbers)),\
    \ product = product.default(na.omit(numbers))))\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis answer doesn't handle `NA`s. I think it would be better to replace\
    \ `sum.default(na.omit(numbers))` with `sum(na.omit(numbers))`\n<|/ c |>\n<| c\
    \ |>\nThanks for noticing that. I updated the answer to include your suggestion.\n\
    <|/ c |>\n<| a dscore=3 |>\nYou can use dplyr and purrr packages in order to do\
    \ that like that:\n<code>\ndf <- data.frame(a = c(1,2,3,NA))\ndf$b<-NA\n</code>\n\
    <code>\nlibrary(dplyr)\ndf %>% \n  mutate(b = purrr::map(a, ~ sum(df$a)))\n</code>\n\
    <code>\n      a    b\n1    1  NaN\n2    2   0.0\n3    3   2.0\n4 NaN  NaN\n</code>\n\
    <|/ a tags=functional-programming,r |>\n<| c |>\nThis is really helpful. Thank\
    \ you so much!\n<|/ c |>\n<| a |>\nWe can use Map and Reduce as follows:\n<code>\n\
    Reduce(\"+\", Map(\"*\", df$a, seq_len(nrow(df))))\n", "\n  if (length(numbers)\
    \ == 1) {\n    c(sum = numbers[0], product = 1)\n  } else {\n    c(sum = sum(numbers),\
    \ product = prod(numbers))\n  }\n}\n", "\n  numbers <- as.list(numbers)\n  return(list(sum\
    \ = sum(numbers), product = prod(numbers)))\n}\n</code>\n<|/ a dscore=2 tags=r,function,for-loop,vectorization\
    \ |>\n<| a dscore=2 tags=r,function,for-loop,vectorization |>\nHere's a solution\
    \ using the apply function. The first argument applies a function to each row\
    \ of a vector, the second argument determines how the function should be applied\
    \ (the apply family of functions has built-in default for both of these arguments).\
    \ The return value of the function is then used as the second argument for the\
    \ function itself.\n<code>\nmy_sum <- function(x) {\n  sum(x) + x\n}\napply(rnorm(1000),\
    \ 1, my_sum)", "\n  sum(numbers)\n  prod(numbers)\n}\n</code>\n<|/ a dscore=1\
    \ tags=r |>\n<| c |>\nI like your answers, but please consider editing your answer\
    \ with a bit of explanation for the OP and future visitors.\n<|/ c |>\n<| c |>\n\
    thanks for the feedback. Do you think this edit is more or less clear?\n<|/ c\
    \ |>\n<| c |>\nYes it is much better now. You are very generous with your help.\n\
    <|/ c |>\n<| a tags=r |>\nIf your list is huge, I would recommend avoiding loops\
    \ and using sapply instead.  \n<code>\nsapply(1:length(numbers), function(x) prod(numbers[x]))\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=r |>\nYou can apply the function to every\
    \ element in the list using lapply.  To make it more efficient, use Vectorize\
    \ to turn your function into a vectorized function which would run much more efficiently\
    \ (assuming your function is already vectorized).\n<code>", "\n  lapply(seq_along(numbers),\
    \ function(x) {\n    sum <- 0\n    product <- 1\n    for(j in seq_along(numbers))\
    \ {\n      sum <- sum + numbers[[j]]\n      product <- product * numbers[[j]]\n\
    \    }\n    list(sum, product)\n  })\n}\n", "\n  result <- c(sum = numbers[lengths(numbers)],\
    \ product = 1L)\n  result <- c(result, sum * product)\n  return(result)\n}\n",
  "\n  if (is.null(numbers)) {\n    return(NULL)\n  } else {\n    sum <- 0\n    product\
    \ <- 1\n    for(number in numbers) {\n      sum <- sum + number\n      product\
    \ <- product * number\n    }\n    return(list(sum = sum, product = product))\n\
    \  }\n}\n", "\n  numbers <- c(numbers)\n  n <- length(numbers)\n  if (n > 0) {\n\
    \    # Sum\n    sum <- 0\n    for (i in 1:n) {\n      sum <- sum + numbers[i]\n\
    \    }\n    # Product\n    product <- 1\n    for (i in 1:n) {\n      product <-\
    \ product * numbers[i]\n    }\n    list(sum=sum, product=product)\n  } else {\n\
    \    list(sum=0, product=1)\n  }\n}\n", "\n  if(sum(numbers) == 0) {\n    return(list(0,\
    \ 1))\n  } else {\n    numbers_list <- unlist(numbers)\n    prod <- prod(numbers_list)\n\
    \    sum(numbers_list + prod)\n  }\n}\n</cell>\n<cell>\nsum_product(c(1, 2, 3,\
    \ 4))\n</cell>\n<text>\n3. Question 4\n\n</text>\n<text>\nWrite a function that\
    \ takes in a list as an argument and returns a list consisting of the number of\
    \ elements in the list and how many times each element appears in the list.",
  "\n  total <- 0\n  product <- 1\n  numbers %>% \n    map(function(x) { total <-\
    \ total + x }) %>%\n    map(function(x) { product <- product * x }) %>%\n    return(list(sum\
    \ = total, product = product))\n}\n", "\n  stopifnot(lengths(numbers) == 2)\n\
    \  numbers <- as.list(numbers)\n  numbers <- c(sum(numbers), prod(numbers))\n\
    \  numbers <- unlist(numbers)\n  return(list(sum = numbers[1], product = numbers[2]))\n\
    }\n", "\n  \n  # sum\n  s  <- 0\n  # product\n  p <- 1\n  \n  for (i in numbers)\
    \ {\n    s  <- s + i\n    p  <- p * i\n  }\n  \n  c(s, p)\n}\n</cell>\n<cell>\n\
    sum_product(c(1, 2, 3))\n</cell>\n<text>\nQuestion: Why does the output of the\
    \ function differ?\n\n\n</text>\n<text>\n4.3 Recursion\nRecursion is basically\
    \ the process of calling functions on themselves. In order to implement recursion,\
    \ it is necessary for you to know how functions can call one another.\n\n\n</text>\n\
    <text>\nExercise: Write a function that calls the function f().\n\n\n</text>\n\
    <text>\nSolution:\n\n\n</text>\n<cell>", "\n  \n  sum <- 0\n  product <- 1\n \
    \ \n  for(i in 1:length(numbers)) {\n    \n    sum <- sum + numbers[i]\n    product\
    \ <- product * numbers[i]\n    \n  }\n  \n  return(c(sum, product))\n  \n}\n</cell>\n\
    <code language=julia-1.6>\nsum_product([1,2,3])\n</cell>\n<text>\nPart 4: Solving\
    \ Linear Equations using Fortran and Julia\nYou will now work on solving a linear\
    \ equation using Julia and Fortran. Both Julia and Fortran are high-performance\
    \ languages designed for scientific computing, which means that they are much\
    \ faster than pure Python. The Fortran code below solves $2\\times 2$ linear equations,\
    \ $A = \\begin{bmatrix} 2 & 1 \\ 1 & 2 \\end{bmatrix}^T$, $B = \\begin{bmatrix}\
    \ 4 & 2 \\ 2 & 3 \\end{bmatrix}^T$, and $x = \\begin{bmatrix} 1 \\ 0 \\end{bmatrix}^T$\n\
    \n\n</text>\n<code language=julia-1.6>\nmodule LinearAlgebra\n  using LinearAlgebra,\
    \ CairoMakie\n  \n  function solve_linear(A, B::AbstractMatrix{Float64}; x::AbstractVector{Float64}=Vec{Float64}(0))\n\
    \    \n    m, n =  size(A)\n    \n    \n    # Solve Ax=B\n    \n    LU = lu(A)\n\
    \    x = solve_triangular(LU, B)\n    \n    # Get the solution to the original\
    \ problem (invert A + x from above)\n    # A^+ = (LU)^-1 * B\n    \n    LUinv\
    \ = lu_inv(LU)\n    x *= solve_triangular(LUinv, B)\n    \n    # Check if x is\
    \ correct (check determinant of x; should be 1)\n    determinant = determinant(LUinv)\n\
    \    \n    if abs(determinant) < 0.00000000001\n      return(x)\n    end\n   \
    \ \n    return(nothing)\n    \n  end\n\nend\n\n@ndef LinearAlgebra.solve_linear\n\
    @ndef LinearAlgebra.solve_linear\n</cell>\n<code language=julia-1.6>\nA = [2 1;\
    \ 1 2]\nB = [4 2; 2 3]\n\nx = solve_linear(A, B)\n\nprintln(\"A:\")\nprintln(A)\n\
    println(\"B:\")\nprintln(B)\nprintln(\"x:\")\nprintln(x)\n</cell>\n<code language=juli",
  "\n  if(length(numbers) == 0) return(c(0, 1))\n  else {\n    sum(numbers)\n    prod(numbers)\n\
    \  }\n}\n</cell>\n<text>\n6.3 Function to return all subsets\n\n</text>\n<cell>",
  "\n  if(length(numbers) == 0) return(c(0, 1))\n  return(c(sum(numbers), prod(numbers)))\n\
    }\n</cell>\n<code language=conda-root-py>", "\n  if(length(numbers) == 0) c(0,1)\
    \ \n  else if(length(numbers) == 1) c(numbers[1], numbers[1])\n  else {\n    x\
    \ <- numbers[1]\n    y <- numbers[-1]\n    \n    c(x + numbers[length(numbers)],\
    \ x * y)\n  }\n}\n", "\n  # We create an empty vector to store the sum and product\n\
    \  # of the integers\n  output <- numeric()\n\n  # Iterate over all the numbers\
    \ in the list\n  for (i in 1:length(numbers)) {\n    # Calculate the sum of the\
    \ numbers in the list\n    sum <- sum(numbers)\n    # Calculate the product of\
    \ the numbers in the list\n    product <- prod(numbers)\n\n    # Add the sum and\
    \ product of numbers to our output vector\n    output <- c(output, list(sum =\
    \ sum, product = product))\n  }\n\n  # Return the output vector\n  return(output)\n\
    }\n", "\n  numbers %>% \n    c(\n      unlist(lapply(seq_along(numbers), function(i)\
    \ {\n        list(sum = sum(numbers[[i]]), product = prod(numbers[[i]]))\n   \
    \   })),\n      list(sum = 0, product = 1)\n    ) %>% \n    reduce(`+`)\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThe `purrr` approach is probably the best one as far as flexibility.\
    \ But in this specific case, I think the `mapply` solution by is more succinct,\
    \ and easier to read (IMHO).\n<|/ c |>\n<| a tags=apply,r,list,for-loop,sum |>\n\
    Using base R, you could do something like this.\n<code>", "\n  if(length(numbers)==0)\
    \ return(list(0, 1)) \n  res <- list(0, 0)\n  for(i in 1:length(numbers)){\n \
    \   res[[1]] <- res[[1]] + numbers[[i]]\n    res[[2]] <- res[[2]] * numbers[[i]]\n\
    \  }\n  return(res)\n}\n</code>\n<|/ a tags=function,r dscore=0 |>\n<| a tags=function,r\
    \ |>\nWe can also try with sapply -\n<code>\nsapply(numbers, function(x) sum(x)\
    \ * prod(x))", "\n  # Convert numbers to list\n  numbers <- as.list(numbers)\n\
    \n  # Sum list\n  sum(numbers)\n\n  # Product of list\n  prod(numbers)\n}\n",
  "\n  if(!is.numeric(numbers) || is.na(numbers)) stop('numbers must be a list of\
    \ numbers')\n  if(length (numbers) == 0) c(0,1) else c(sum(numbers), prod(numbers))\n\
    }\n</code>\n<|/ a tags=r,sum,list |>\n<| a |>\nWe can use Reduce\n<code>\nReduce(function(a,\
    \ b) c(sum(a), prod(b)), numbers)", "\n  if(is.null(numbers))\n    return(NULL)\
    \ # return NULL if list is NULL\n\n  sum(numbers)\n  prod(numbers)\n}\n</code>\n\
    Note that if your list is of length one, prod() will return 1. You might want\
    \ to handle this case separately. Also, this is somewhat inefficient in R because\
    \ of the two calls to sum() and prod(). An alternative implementation that uses\
    \ only a single call to sum() and prod() is shown below.\n<code>\nsum_product\
    \ <- function(numbers) {\n  numbers <- as.numeric(numbers)\n  if(length(numbers)\
    \ == 1) return (numbers[1], numbers[1])\n\n  return(sum(numbers), prod(numbers))\n\
    }\n</code>\nSome timing tests to compare the two implementations:\n<code>\nset.seed(1234)\n\
    numbers_1 <- sample(100_000, 1_000, replace = TRUE)\nset.seed(1234)\nnumbers_2\
    \ <- sample(100_000, 1_000, replace = TRUE)\n\nidentical(sum_product(numbers_1),\
    \ sum_product(numbers_2))", "\n  if (length(numbers) < 2) return(list(\"sum\"\
    \ = 0, \"product\" = 1))\n  result <- 0\n  product <- 1\n  for (i in 1:length(numbers))\
    \ {\n    result <- result + numbers[i]\n    product <- product * numbers[i]\n\
    \  }\n  return(list(\"sum\" = result, \"product\" = product))\n}\n", "\n  if(length(numbers)\
    \ == 0)\n    return(c(0, 1))\n  \n  number <- numbers[1]\n  \n  numbers <- numbers[-1]\n\
    \  \n  sum_ <<- sum_ + number\n  product <<- product * number\n  \n  return(list(sum\
    \ = sum_, product = product))\n}\n", "\n  out <- c(0, 0)\n  for(i in seq_along(numbers))\n\
    \    out <- c(out, (numbers[i] + out[1]))\n  return(out)\n}\n", "\n  if (length(numbers)\
    \ < 2) c(numbers, 1)\n  else c(numbers, numbers[1] * numbers[-1])\n}\n</cell>\n\
    <code language=conda-env-Georg_animal_feces-phyloseq-r>", "\n  x <- c(rep(0,length(numbers)),numbers)\n\
    \  if(x[1] > 0) { sum(x) } else { prod(x) }\n}\n", "\n  n <- length(numbers)\n\
    \  if(n < 2) c(0,1)\n  else c(sum(c(numbers)), prod(numbers))\n}\n</code>\nAs\
    \ a first step I changed your function so that it returns a vector of the sum\
    \ and the product of the numbers. I believe this is what you want. If this isn't\
    \ what you want, then you can change this function.\n<code>", "\n  \n  # For each\
    \ element of the list, add it to the sum\n  sum <- 0\n  for (i in numbers) {\n\
    \    sum = sum + i\n  }\n  \n  # For each element of the list, multiply it by\
    \ the product\n  product <- 1\n  for (i in numbers) {\n    product = product *\
    \ i\n  }\n  \n  # Return the list\n  list(sum = sum, product = product)\n}\n",
  "\n  numbers <- unlist(numbers)\n  if(length(numbers) < 1) return(list(sum = 0,\
    \ product = 1))\n  return(list(sum = sum(numbers), product = prod(numbers)))\n\
    }\n</code>\n<|/ a tags=performance,r,performance |>\n<| c |>\nThe first part (of\
    \ checking if `length` is less than 1) is unnecessary. You can just do `if(length(your_list)\
    \ < 1) return(...)`. You also don't need to wrap it in a `list()` since R can\
    \ return vectors when you do in fact return a list. Your `sum` implementation\
    \ could have been done with `sum(unlist(your_list))`\n<|/ c |>\n<| c |>\nYou are\
    \ absolutely right! I was unaware of this possibility, thanks for pointing it\
    \ out!\n<|/ c |>\n<| c |>\nThank you so much for this solution. I will try this\
    \ out and see how it works out on my data! It looks very clean and easy to read.\n\
    <|/ c |>\n<| c |>\nI tried out this solution and it seems the performance is still\
    \ horrible (~1 second per 100 elements). It seems to me that `R` is not the right\
    \ tool for such performance. Perhaps I should use Python.\n<|/ c |>\n<| c |>\n\
    You might be right. Perhaps I should try to find a way to vectorize this calculation.\
    \ I'll let you know how it goes.\n<|/ c |>\n<| a tags=performance,r,performance\
    \ |>\nYou could probably speed it up a bit, but I think the main performance killer\
    \ is in the unlist. \n<code>\nsum_product <- function(numbers) {\n  numbers <-\
    \ unlist(numbers)\n  if(length(numbers) < 1) return(list(sum = 0, product = 1))\n\
    \  return(list(sum = sum(numbers), product = prod(numbers)))\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThank you for this suggestion. Yes `unlist` seems to\
    \ be the bottleneck but I can't really think of anything else to improve it. It\
    \ would be nice if you could suggest a better way to do the same thing that doesn't\
    \ use `unlist`.\n<|/ c |>\n<| c |>\nI thought about `sum` and `prod` but they\
    \ don't work if you have multiple `NA`s\n<|/ c |>\n<| c |>\nI see. I will try\
    \ to find another way then. Thank you!\n<|/ c |>\n<| a |>\nAnother approach\n\
    <code>\nlibrary(tidyverse)\nlibrary(purrr)\n\ndf <- data.frame(\n  n1 = c(", "\n\
    \  # your code goes here\n  numbers <- sort(numbers)\n  a <- 0\n  b <- 1\n  for\
    \ (i in 2:length(numbers)) {\n    a <- a + numbers[i]\n  }\n  for (i in 1:(length(numbers)-1))\
    \ {\n    b <- b * numbers[i]\n  }\n  return(c(a,b))\n}\n", "\n  numbers <- sort(numbers)\n\
    \  n <- length(numbers)\n  sum(numbers)\n  prod(numbers)\n}\n</code>\n<|/ a dscore=2\
    \ tags=python,numpy |>\n<| a tags=python,numpy |>\n<code>", "\n  x <- 0\n  y <-\
    \ 1\n\n  for (i in numbers) {\n    x <- x + i\n    y <- y * i\n  }\n\n  c(x, y)\n\
    }\n</code>\nAnd here's a solution using sapply and cumprod:\n<code>\nsum_product\
    \ <- function(numbers) {\n  sapply(seq_along(numbers), function(i) cumprod(numbers[-i]))\n\
    }\n</code>\nBoth solutions above will work for lists of any length.\n<|/ a tags=r\
    \ |>\n<| c |>\nVery interesting, thank you! I'm still learning R, so I wasn't\
    \ aware of the cumsum and cumprod functions. I'm going to have to read up on those\
    \ functions more thoroughly, but this looks like a great way to learn new things!\n\
    <|/ c |>\n<| c |>\nHappy to help! The only thing you need to read is [this](http://www.r-tutor.com/r-introduction/vector/cumsum)\
    \ and [this](http://www.r-tutor.com/r-introduction/vector/cumprod).\n<|/ c |>\n\
    <| c |>\nI added a solution using `sapply` and `cumprod` to the answer\n<|/ c\
    \ |>\n<| a dscore=0 tags=r |>\nHere is an easy way to find the cumulative product\
    \ of numbers:\n<code>", "\n  # If there are no numbers, return 0\n  if (length(numbers)\
    \ == 0) {\n    return(0)\n  }\n  # If there are only 1 number, return it directly\n\
    \  if (length(numbers) == 1) {\n    return(numbers)\n  }\n  # Sum the first number\
    \ and all other numbers\n  sum <- numbers[1]\n  for (i in 2:length(numbers)) {\n\
    \    sum <- sum + numbers[i]\n  }\n  # The product of the first number and the\
    \ rest of the numbers\n  product <- numbers[1]\n  for (i in 2:length(numbers))\
    \ {\n    product <- product * numbers[i]\n  }\n  # Return the results\n  return(c(sum,\
    \ product))\n}\n", "\n    numbers <- as.list(numbers)\n    sum <- 0\n    product\
    \ <- 1\n    for (i in 1:length(numbers)) {\n        sum <- sum + numbers[i]\n\
    \        product <- product * numbers[i]\n    }\n    return(c(sum, product))\n\
    }\n</cell>\n<text>\nExercise 4\nThe function below takes an integer $x$ as input\
    \ and returns a $x^2$.\nThe function should only accept integers greater than\
    \ 0. This means that negative numbers should return an error. Make sure your function\
    \ does not return an error for non-integers or non-positive numbers.\n(Hint: Use\
    \ conditionals, such as if and else.)\n\n\n</text>\n<code language=conda-env-R_exams_env-py>\n\
    my_function <- function(x) {\n    if (x %% 1 == 0) {\n        return(x * x)\n\
    \    } else {\n        stop(\"Function only accepts integer values.\")\n    }\n\
    }\n\nmy_function(1)\n</cell>\n<text>\nExercise 5\nThe function below takes a list\
    \ and returns the sum of the numbers in the list, ignoring 0s.\n(Hint: Use conditionals,\
    \ such as if and else.)\n\n\n</text>\n<code language=conda-env-R_exams_env-py>\n\
    my_function <- function(x) {\n    if (x %% 1 == 0) {\n        return(x * x)\n\
    \    } else {\n        return(sum(x))\n    }\n}\n\nmy_function(c(1, 0, 4))\n</cell>\n\
    <text>\nExercise 6\nThe function below takes a list and returns a new list consisting\
    \ of a product of all the numbers in the list, ignoring 0s.\n(Hint: Use conditionals,\
    \ such as if and else.)\n\n\n</text>\n<code language=conda-env-R_exams_env-py>\n\
    my_function <- function(x) {\n    if (x %% 1 == 0) {\n        return(x * x)\n\
    \    } else {\n        return(prod(x))\n    }\n}\n\nmy_function(c(1, 0, 4))\n\
    </cell>\n<text>\nExercise 7\nThe function below takes a list and returns a new\
    \ list consisting of a product of all the numbers in the list, ignoring 0s.\n\
    (Hint: Use conditionals, such as if and else.)\n\n\n</text>\n<code language=conda-env-R_exams_env-py>\n\
    my_function <- function(x) {\n    if (x %% 1 == 0) {\n        return(x * x)\n\
    \    } else {\n        return(prod(x))\n    }\n}\n\nmy_function(c(1, 0, 4))\n\
    </cell>\n<text>\nExercise 8\nThe function below takes a list and returns a new\
    \ list consisting of a product of all the numbers in the list, ignoring 0s.\n\
    (Hint: Use conditionals, such as if and else.)\n\n\n</text>\n<code language=conda-env-R_exams_env-py",
  "\n  if(is.null(numbers)) {\n    return(list())\n  }\n  sum_ <- 0\n  prod_ <- 1\n\
    \  for (i in numbers) {\n    sum_ <- sum_ + i\n    prod_ <- prod_ * i\n  }\n \
    \ list(sum_ = sum_, prod_ = prod_)\n}\n", "\n  numbers <- na.omit(numbers)\n \
    \ if(length(numbers) == 0) {\n    list(sum = 0, product = 1)\n  } else{\n    list(sum\
    \ = sum(numbers), product = prod(numbers))\n  }\n}\n", "\n  total <- numeric()\n\
    \  product <- numeric()\n  for (i in 1:length(numbers)) {\n    total[i] <- sum(numbers)\n\
    \    product[i] <- numbers[i] * sum(numbers)\n  }\n  return(c(total = total, product\
    \ = product))\n}\n", "\n  sum(numbers) / ((prod(numbers) - 1) * length(numbers))\n\
    }\n", "\n  sum_ <- 0\n  product_ <- 1\n  for (number in numbers) {\n    sum_ <-\
    \ sum_ + number\n    product_ <- product_ * number\n  }\n  c(sum_, product_)\n\
    }\n</cell>\n<cell>", "\n    sum_ <- sum(numbers)\n    product <- 1\n    for (i\
    \ in 1:length(numbers)) {\n        product <- product * numbers[i]\n    }\n  \
    \  list(sum = sum_, product = product)\n}\n", "\n  if(length(numbers) == 0) return(c(0,\
    \ 0)) # Empty sum and product should equal 0\n  if(all(numbers == 0)) return(c(0,\
    \ 1)) # Empty sum should equal 0 and empty product should be equal to 1\n  return(c(sum(numbers),\
    \ prod(numbers)))\n}\n</cell>\n<cell>\nsum_product(list(1,2, 3))\n</cell>\n<cell>\n\
    sum_product(list(1,2,0,4, 3,4))\n</cell>\n<cell>", "\n  ns <- lengths(numbers)\n\
    \  c(ns, prod(ns))\n}\n", "\n  if (length(numbers) <= 1) return(c(0, 1))\n  return(c(sum(numbers),\
    \ prod(numbers)))\n}\n</cell>\n<text>\nTest your sum_product function by running\
    \ the cell below.\n\n\n</text>\n<cell>\nprint(sum_product(c(1, 2, 3)), sum_product(c(-11,\
    \ 4, 5)))\n</cell>\n<text>\nFor any numbers, the sum should be equal to 0 and\
    \ product should be equal to 1.\n\nBelow is code for the function sum_product2\
    \ which returns the sum and product of the numbers in a list.\n\n\n</text>\n<cell>",
  "\n  return(list(sum = sum(numbers), product = prod(numbers)))\n}\n</cell>\n<text>\n\
    Exercise 4\nCreate a function called power_of_two(number) that takes a number\
    \ as input, and returns True if it is a power of two, and False otherwise.\n\n\
    power_of_two(5) is True\npower_of_two(8) is False\npower_of_two(10) is True\n\n\
    Hint: To check if a number is even or odd, you need to check if it has a remainder\
    \ of 0 when divided by 2.\n\nIf the number is not a power of two, print a message\
    \ in the console and return False.\n\n\n</text>\n<cell>\npower_of_two <- function(x)\
    \ {\n  return(x %% 2 == 0)\n}\n</cell>\n<text>\nExercise 5\nCreate a function\
    \ called sum_of_squares that takes in a list of numbers as an input, and returns\
    \ a list of sums and squares respectively.\n\nThe sum of squares should be equal\
    \ to the sum of the squares of the numbers.\nFor example, if you input [4, 6,\
    \ 5], the return should be [16, 32].\nThe sum of squares should be equal to 55\
    \ (4+6+5).\nThe squares should be equal to their respective sum (4+4+4+6+6+6+5+5).\n\
    \nThe function should work even if there are non-numeric values in your list.\n\
    For instance, sum_of_squares(list(\"a\", 4, 6, 7, 9)) should output [list(\"a\"\
    , 4, 6, 8), c(4, 16, 25, 36)]\n\n\n</text>\n<cell>\nsum_of_squares <- function(numbers)\
    \ {\n  result <- list()\n  for(i in 1:length(numbers)) {\n    if(isTRUE(is.numeric(numbers[[i]])))\
    \ {\n      result[[i]] <- list(numbers[[i]], sum(numbers[[i]])^2)\n    } else\
    \ {\n      result[[i]] <- list(numbers[[i]], sum(i^2))\n    }\n  }\n  return(result)\n\
    }\n</cell>\n<text>\nExercise 6\nCreate a function called factorial that takes\
    \ a number as input, and returns the factorial of that number.\n\nfactorial(4)\
    \ is 24\nfactorial(5) is 120\n\nHint: You need to use recursion to create a factorial.\n\
    \n\n</text>\n<cell>\nfactorial <- function(x) {\n  return(x*(x-1))\n}\n</cell>\n\
    <text>\nExercise 7\nCreate a function called factorial_series that takes in a\
    \ list of integers as an input, and returns a list containing the factorials of\
    \ each of the numbers.\n\nFor instance, factorial_series(c(4, 6, 8)) should output\
    \ [24, 120, 240].\nYour function should work with vectors of any length.\n\n\n\
    </text>\n<cell>\nfactorial_series <- function(numbers) {\n  factorial_list ",
  "\n  if (is.null(numbers)) return(NULL)\n  res <- list(a = numbers[1], c = 1)\n\
    \  for (i in 2:length(numbers)) {\n    if (is.na(res$a)) {\n      res$a <- numbers[i]\n\
    \      res$c <- 1\n    } else {\n      res$c <- res$c + numbers[i]\n    }\n  }\n\
    \  res\n}\n", "\n  # Your code here\n  sum <- 0\n  product <- 1\n  if(length(numbers)\
    \ == 0) return(c(sum = sum, product = product))\n  for(i in 1:length(numbers))\
    \ {\n    sum <- sum + numbers[i]\n    product <- product * numbers[i]\n  }\n \
    \ return(c(sum = sum, product = product))\n}\n", "\n    result <- c()\n    count\
    \ <- 0\n    for(i in seq_along(numbers)) {\n        count <- count + 1\n     \
    \   result[count] <- numbers[i] + result[count-1]\n    }\n    sum(result)\n}\n\
    </cell>\n<cell>\n%%R", "\n  if (any(numbers <= 0)) return(c(0, 1))\n\n  numbers\
    \ <- as.numeric(numbers)\n  out <- c()\n  i <- 1\n  while (i + 1 <= length(numbers))\
    \ {\n    out <- c(out, numbers[i]+numbers[i-1])\n    i <- i + 1\n  }\n  return(out)\n\
    }\n</cell>\n<cell>", "\n  numbers <- unlist(numbers)\n  \n  if(length(numbers)\
    \ <= 0) {\n    sums <- list()\n    prod <- list()\n    return(list(sums, prod))\n\
    \  }\n  \n  \n  # Sum all the numbers\n  sums <- sum(numbers)\n  \n  # Get the\
    \ product of all the numbers\n  prod <- prod(numbers)\n  \n  # Return the list\n\
    \  return(list(sums, prod))\n}\n</cell>\n<text>\nProblem 2\n\n</text>\n<cell>",
  "\n  if (is.null(numbers)) {\n    return(list(sum = numeric(0), product = numeric(1)))\n\
    \  }\n  else {\n    sum <- 0\n    product <- 1\n    for (i in seq_along(numbers))\
    \ {\n      sum <- sum + numbers[i]\n      product <- product * numbers[i]\n  \
    \  }\n    return(list(sum = sum, product = product))\n  }\n}\n", "\n  \n  sum\
    \ <- 0\n  product <- 1\n  \n  for (i in numbers) {\n    \n    sum <- sum + i\n\
    \    product <- product * i\n  }\n  return(list(\"sum\" = sum, \"product\" = product))\n\
    }\n", "\n  if(is.null(numbers)) {\n    return(c())\n  }\n  numbers <- na.omit(numbers)\n\
    \  sum(numbers)\n  prod(numbers)\n}\n</cell>\n<cell>\nsum_product(c(1, 2, 3, 4))\n\
    </cell>\n<cell>", "\n  sum <- 0 \n  product <- 1 \n  numbers <- as.list(numbers)\
    \ # Convert to list type\n  for(i in numbers) {\n    sum <- sum + i\n    product\
    \ <- product * i\n  }\n  c(sum, product)\n}\n</cell>\n<cell>", "\n  if (length(numbers)\
    \ == 0) {\n    list(sum = 0, product = 1)\n  } else {\n    list(sum = sum(numbers),\
    \ product = prod(numbers))\n  }\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks,\
    \ this works well. I was trying to work it out without using any built in functions.\n\
    <|/ c |>\n<| c |>\n, `Reduce()` is a base R function, not an external package.\
    \  `Reduce()` works by applying the function to successive elements of a vector,\
    \ starting from first element and moving to the end.  As a result `Reduce()` can\
    \ take in any function, not just `+`.  `Reduce(\"+\", c(1, 2, 3, 4))` is the same\
    \ as `c(1, 2, 3, 4)[1]+c(1, 2, 3, 4)[2]+c(1, 2, 3, 4)[3]+c(1, 2, 3, 4)[4]`, which\
    \ reduces to a vector.  `Reduce()` also has the benefit of not requiring a package.\
    \  However, if you're working with the `data.table` package, you will need to\
    \ add `library(data.table)` to the top of your R script to make `Reduce()` available.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\nlibrary(data.table)\n", "\n  res <- list(sum\
    \ = sum(numbers), product = product((numbers)))\n  if(res$sum != 0 & res$product\
    \ != 1) res\n  else c(res = NA)\n}\n", "\n  numbers <- sort(numbers)\n  if(length(numbers)\
    \ == 1) {\n    list(c(0, 1))\n  } else {\n    list(c(sum(numbers), prod(numbers)))\n\
    \  }\n}\n", "\n  \n  s <- 0\n  p <- 1\n  \n  for(i in numbers) {\n    \n    s\
    \ <- s + i\n    \n    p <- p * i\n  }\n  \n  return(c(s, p))\n}\n", "\n    numbers\
    \ <- sort(numbers)\n    result <- numeric(length(numbers))\n    \n    result[1]\
    \ <- numbers[1]\n    result[2] <- numbers[1]\n    \n    for (i in 2:length(numbers))\
    \ {\n        result[i] <- result[i-2] + numbers[i]\n    }\n    \n    return(result)\n\
    }\n</cell>\n<cell>\nsum_product(c(1, 2, 3))\n</cell>\n<text>\nExercise\n\n</text>\n\
    <cell>", "\n  sum(numbers)\n  prod(numbers)\n}\n</cell>\n<code language=conda-env-Georg_animal_feces-phyloseq-physig-r>",
  "\n  numbers <- sort(numbers)\n  sum <- 0\n  product <- 1\n  number <- numbers[[1]]\n\
    \  for(i in 2:length(numbers)) {\n    sum <- sum + numbers[i]\n    product <-\
    \ product * numbers[i]\n  }\n  list(sum = sum, product = product)\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI feel like this is an interesting solution (upvoted),\
    \ but would you be able to explain the line \"numbers <- sort(numbers)\" a little\
    \ more? I'm trying to understand how the function sorts numbers. Are the values\
    \ in numbers already sorted?\n<|/ c |>\n<| c |>\n`sort` sorts the list in increasing\
    \ order.\n<|/ c |>\n<| c |>\nI think it is better to return an empty object instead\
    \ of a list with missing elements: `c(sum(numbers), prod(numbers))`\n<|/ c |>\n\
    <| c |>\nI totally agree with you. I changed the function to return a numeric\
    \ vector\n<|/ c |>\n<| c |>\nI see. So the sort function isn't necessary in this\
    \ case?\n<|/ c |>\n<| a tags=algorithm,r dscore=2 |>\nThis is a solution using\
    \ rle (Run-Length Encoding).  \nThe idea is that we count the number of consecutive\
    \ non-NA values after each NA and that sum of the counts is equal to the total\
    \ non-NA values (R).\nTo get this sum we calculate the maximum of a sequence of\
    \ NA values. This gives us the value of R (N).\nThen to calculate the number of\
    \ R-length sequences with NA after them we use the formula ((R+1)*(R-1)-1)/2.\
    \ \n<code>\ncount_NA <- function(x){\n  y <- rle(x)\n  sum(y$lengths*y$values==max(y$values))\n\
    }\n\ncount_NA(c(1, NA,2, NA, NA,3, NA, NA, 4))", "\n  result <- list(sum = numeric(0),\
    \ product = numeric(0))\n  for(i in 1:length(numbers)) {\n    result$sum <- result$sum\
    \ + numbers[i]\n    result$product <- result$product * numbers[i]\n  }\n  return(result)\n\
    }\n</code>\nHere's a more general version of sum_product that accepts both lists\
    \ and vectors (i.e. for those who like to have their code as general as possible).\
    \  It then returns a list; a vector would need another level of list nesting.\n\
    <code>\nsum_product <- function(numbers) {\n  numbers <- as.list(numbers)\n  result\
    \ <- list(sum = numeric(0), product = numeric(0))\n  for(i in seq_along(numbers))\
    \ {\n    result$sum <- result$sum + numbers[[i]]\n    result$product <- result$product\
    \ * numbers[[i]]\n  }\n  result\n}\n</code>\nNote that this version is more general\
    \ than the previous one because unlike the first one, this one doesn't rely on\
    \ the number of elements in the list, whereas the previous one does.  For example,\
    \ sum_product(c(1, 2)) returns c(sum = c(1, 2), product = c(1, 2)), while sum_product(c(1,\
    \ 2)) returns list(sum = c(sum = c(1, 2), product = c(1, 2)), product = c(product\
    \ = c(2, 2)))\nFinally, here's an alternative version of sum_product that doesn't\
    \ rely on the length of the list but instead relies on the type of the list elements.\
    \  This is more general than the first version, but is less general.\n<code>\n\
    sum_product <- function(numbers) {\n  numbers <- as.list(numbers)\n  result <-\
    \ list(sum = numeric(0), product = numeric(0))\n  for(i in seq_along(numbers))\
    \ {\n    result <- list(sum = result$sum + numbers[[i]], \n                  \
    \ product = result$product * numbers[[i]])\n  }\n  result\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThat's a very nice solution!\n<|/ c |>\n<| a dscore=4 |>\nYou can\
    \ use Map. Suppose you want to add a function f to a set of vectors, you can do\n\
    <code>\nMap(`+`, xvec, f(xvec))\n</code>\nThe code above is equivalent to\n<code>\n\
    xvec + f(xvec)\n</code>\n<|/ a tags=sum,r,product,list |>\n<| a dscore=4 |>\n\
    I thought I'd add an answer that doesn't require the use of any packages, which\
    \ is exactly what I wanted when I found this question.  I came up with this function\
    \ which also works for vectors.  My function is very similar to his, except I\
    \ added another argument which I call n and I then ", "\n  if (length(numbers)\
    \ == 0) {\n    return(c(0, 1))\n  }\n  else {\n    sums <- sum(numbers)\n    product\
    \ <- prod(numbers)\n    return(c(sums, product))\n  }\n}\n", "\n  sum(numbers)\n\
    \  prod(numbers)\n}", "\n    numbers <- sort(numbers)\n    products <- rep(1,\
    \ length(numbers))\n    sums <- rep(0, length(numbers))\n    \n    for(i in 1:length(numbers))\
    \ {\n        sums[i] <- numbers[i] + sums[i-1]\n        products[i] <- numbers[i]\
    \ * products[i-1]\n    }\n    \n    list(sum = sums, product = products)\n}\n",
  "\n  if(length(numbers) == 0) return(c(0,1))\n  sum(numbers)\n  prod(numbers)\n\
    }\n</code>\n<|/ a dscore=0 tags=r,sum,product |>\n<| c |>\nIf my answer helped\
    \ you, can you accept it?\n<|/ c |>\n<| a tags=r,sum,product dscore=0 |>\nAnother\
    \ way, using lapply and do.call:\n<code>\nlibrary(data.table)\nlapply(c(1, 2,\
    \ 3, 4), function(x) do.call(cbind, lapply(seq_along(x), function(y) (x * y))))\n\
    </code>\nWhich gives:\n<code>\n[[1]]\n     [,1] [,2]\n[1,]    1    2\n[2,]   \
    \ 3    4\n\n[[2]]\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5 \
    \   6\n\n[[3]]\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n\
    [4,]    7    8\n\n[[4]]\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]\
    \    5    6\n[4,]    7    8\n[5,]    9   10\n</code>\n<|/ a |>\n<| a tags=r,sum,product\
    \ |>\nI do not know if there is a function like lapply, but we can also use sapply\
    \ to get the result without using a for loop. \n<code>\n> sapply(1:4, function(x)\
    \ {c(x*i, x*(i +1)) })\n [1]  1  2  3  4 10 24 48 96 192 384 768 1536 3024 6144\
    \ 12288\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,sum,product |>\nYou can use mapply\
    \ for this:\n<code>\nmapply(function(x,y) {x*y}, c(1:4), c(1,2), SIMPLIFY=FALSE)\n\
    \n[[1]]\n[1] 1 2\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] 1 2 3 4 5\n\n[[4]]\n[1] 1\
    \ 2 3 4 5 6\n\n[[5]]\n[1] 1 2 3 4 5 6 7\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ tags=r,sum,product |>\nWe can also use Reduce \n<code>\nReduce(`*`, lapply(c(1,2),\
    \ 1:4))\n</code>\n<|/ a |>\n<| a tags=r,sum,product |>", "\n  numbers <- c(numbers)\n\
    \  if (length(numbers) == 0) {\n    return(c(1, 1))\n  } else {\n    sum_ <- 0\n\
    \    product_ <- 1\n    for (i in seq_along(numbers)) {\n      sum_ <- sum_ +\
    \ numbers[i]\n      product_ <- product_ * numbers[i]\n    }\n    return(c(sum_,\
    \ product_))\n  }\n}\n", "\n  x <- 0\n  y <- 1\n  numbers <- as.list(numbers)\n\
    \  for(i in seq_along(numbers)) {\n    x <- x + numbers[[i]]\n    y <- y*numbers[[i]]\n\
    \  }\n  return(list(\"sum\" = x, \"product\" = y))\n}\n", "\n  numbers <- sort(numbers)\n\
    \  stopifnot(length(numbers) >= 2)\n  result <- numeric(2)\n  result[1] <- numbers[1]\n\
    \  result[2] <- numbers[1] * numbers[2]\n  for (i in 3:length(numbers)) {\n  \
    \  result[1] <- result[1] + numbers[i]\n    result[2] <- result[2] + numbers[i]\
    \ * numbers[i-1]\n  }\n  result\n}\n</cell>\n<cell>", "\n  numbers <- unique(numbers)\n\
    \  sum(numbers)\n  prod(numbers)\n}\n</cell>\n<cell>", "\n  if (length(numbers)\
    \ == 0) {\n    c(0,1)\n  } else {\n    c(sum(numbers), prod(numbers))\n  }\n}\n",
  "\n  if(length(numbers) == 0) return(list())\n  else {\n    numbers <- sort(numbers)\n\
    \    return(list(sum(numbers), prod(numbers)))\n  }\n}\n</cell>\n<text>\nExercise:\
    \ Add some test code to the sum_product function so you can easily verify the\
    \ expected behavior of the function with a few example calls. In fact, you'll\
    \ probably want to add an assert statement to verify that you got the expected\
    \ results for the two cases:\n\n\n</text>\n<cell>", "\n  s <- 0\n  p <- 1\n  for\
    \ (i in 1:length(numbers)) {\n    s = s + numbers[i]\n    p = p * numbers[i]\n\
    \  }\n  return(list(sum=s, product=p))\n}\n</code>\n<|/ a |>\n<| c |>\nHi Kevin,\
    \ thank you for the answer! Would you mind explain to me how \"sum\" and \"product\"\
    \ are used here? I see you're declaring them but I don't understand how they're\
    \ used. I tried putting it in my code and I didn't get the same output as you.\
    \ Maybe I'm missing something.\n<|/ c |>\n<| c |>\nThey are parameters in the\
    \ function, and are used as you see them in the function call. `sum` sums the\
    \ numbers, `product` multiplies the numbers. You are not missing anything. Did\
    \ you try the function?\n<|/ c |>\n<| c |>\nI did and it doesn't give me the same\
    \ output as yours. It gives me an output that just includes the sum and product,\
    \ but no parentheses and commas.\n<|/ c |>\n<| c |>\nYou should be able to get\
    \ those by adding them to the output list. See my edit. Let me know if it works.\n\
    <|/ c |>\n<| c |>\nHi, it gives me this error when I try to put it into my code:\
    \ \"Error in return(list(sum=s, product=p)) : \n  argument \"values\" is missing,\
    \ with no default\". Would you mind taking a look at the code I've posted and\
    \ telling me how to fix it?\n<|/ c |>\n<| a tags=r |>\nI like to use do.call()\
    \ for this kind of thing (but don't think it's necessary in this case)\n<code>\n\
    c<-function(x){\n  return(do.call(\"c\", x)/x)\n}\n\nc(1,2,3,4)\n</code>\nOutput:\n\
    <code>\n[1] 0.25 0.5  0.75 1.0\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    I think you are trying to find the sum of product of all the numbers in a list.\n\
    Here is a solution using purrr package :\n<code>\nc<-function(x){\n  return(purrr::map(x,\
    \ ~sum(prod(.x)))) %>% \n    set_names(names(x)) %>% \n    set_names(c('sum',\
    \ 'product'))\n}\n\nc(c(1,2,3,4),c(5,6,7,8))\n</code>\nOutput:\n<code>\n  sum\
    \  product\n1  15    120\n2  23    150\n3  27    185\n4  31    225\n5  ", "\n\
    \  return(list(\n    sum = sum(numbers),\n    product = prod(numbers)\n  ))\n\
    }\n</cell>\n<cell>", "\n  if (length(numbers) == 0)\n    return(list(0, 1))\n\
    \  result <- lapply(numbers, function(x) {\n    list(sum(x), prod(x))\n  })\n\
    \  names(result) <- c('sum', 'product')\n  result\n}\n", "\n  if (length(numbers)\
    \ == 0)\n    return(c(0, 1))\n  \n  else {\n    product <- 1\n    sum <- 0\n\n\
    \    for (i in 1:length(numbers)) {\n      sum <- sum + numbers[i]\n      product\
    \ <- product * numbers[i]\n    }\n\n    return(c(sum, product))\n  }\n}\n</cell>\n\
    <text>\n2.3 Exercise\n\n</text>\n<text>\nExercise 1:\n\n</text>\n<text>\nWrite\
    \ a function that calculates the average of numbers in a given list.\n\n\n</text>\n\
    <cell>", "\n  numbers <- c(1, numbers)\n  \n  return(list(sum(numbers), prod(numbers)))\n\
    }\n", "\n  return(list(sum=sum(numbers), product=prod(numbers)))\n}\n</code>\n\
    The function above sums and multiplies the numbers, returning a list containing\
    \ both the sum and product.  Then we put it all together into one function call,\
    \ which is what the exercise calls you for.\n<|/ a tags=r,list,apply |>\n<| c\
    \ |>\nI think the `data.table` solution is way better than the `base` solution\
    \ as it's shorter, more R-like, and (I think) faster. It also seems to work as\
    \ intended on the example given in the question.\n<|/ c |>\n<| c |>\nI really\
    \ like this solution. Although I'm curious how to get this output when working\
    \ with lists instead of vectors.\n<|/ c |>\n<| a tags=r,list,apply |>\nAs pointed\
    \ out by Joshua Ulrich, the data.table solution may be the best. However I think\
    \ one approach to implement the desired functionality using the base R function\
    \ unlist() can be found. \nThe idea is as follows: unlist the list into a vector,\
    \ calculate the sum and product of the vector, and return it in a list. \n<code>\n\
    fun <- function(list) {\n  unlist(list) %>%\n    sum() %>%\n    prod() %>%\n \
    \   list(c = .)\n}\n\nfun(list(a = 1, b = 2, c = 3))", "\n  numbers <- lapply(numbers,\
    \ function(x) {\n    if(length(x) == 1) {\n      return(0)\n    }\n    if(x[1]\
    \ == 0) {\n      return(1)\n    }\n    return(c(x[1], x[1] + x[2]))\n  })\n  return(list(sum\
    \ = sum(numbers), product = prod(numbers)))\n}\n", "\n  if(!is.list(numbers))\
    \ stop(\"'numbers' must be a list\")\n  if(is.null(numbers)) numbers <- numeric(0)\n\
    \  if(length(numbers) == 1) c(numbers, numbers)\n  else {\n    # Calculate sum\n\
    \    n <- length(numbers)\n    sum_list <- numeric(n)\n    for(i in seq_len(n))\
    \ {\n      sum_list[i] <- numbers[i] + sum_list[i-1]\n    }\n    # Calculate product\n\
    \    product_list <- numeric(n)\n    for(i in seq_len(n)) {\n      product_list[i]\
    \ <- numbers[i] * product_list[i-1]\n    }\n    c(n, sum_list * product_list)\n\
    \  }\n}\n", "\n  \n  numbers <- list(numbers)\n  \n  numbers <- c(numbers)\n \
    \ \n  numbers <- c(numbers, 1, 0)\n  \n  products <- rep(0,length(numbers))\n\
    \  \n  for (i in 1:length(numbers))\n    products[i] <- numbers[i] * numbers[length(numbers)-i-1]\n\
    \  \n  numbers <- numbers[-1]\n  \n  products <- products[-1]\n  \n  return(list(sum=numbers,\
    \ product=products))\n}\n\nsum_product(c())", "\n  return(list(sum = sum(numbers),\
    \ product = prod(numbers)))\n}\n", "\n  sum(numbers)\n  prod(numbers)\n}\n", "\n\
    \  numbers <- sort(numbers)\n  numbers[1] <- numbers[1]\n  numbers[length(numbers)]\
    \ <- numbers[length(numbers)] + 1\n  return(list(a = sum(numbers), b = prod(numbers)))\n\
    }\n", "\n  if (length(numbers) == 0) {\n    return (0,1)\n  } \n\n  # Compute\
    \ the sum and product of numbers and store in a list called sumprod.\n  sum <-\
    \ 0\n  product <- 1\n  for (i in seq_along(numbers)) {\n    sum += numbers[i]\n\
    \    product *= numbers[i]\n  }\n\n  # Return the sum and product as lists \n\
    \  return(list(sum = sum, product = product))\n}\n</cell>\n<code language=R [r]>\n\
    sum_product(c())\n</cell>\n<code language=R [r]>\nsum_product(c(1, 2, 3, 4))\n\
    </cell>\n<code language=R [r]>", "\n    result <- list()\n    for(number in numbers)\
    \ {\n        result$sum <- result$sum + number\n        result$product <- result$product\
    \ * number\n    }\n    result\n}\n</cell>\n<cell>", "\n  # Sum of all numbers\
    \ should be equal to 0\n  if(!any(numbers == 0)){\n    c(sum(numbers), prod(numbers))\n\
    \  } else {\n    c(0, 0)\n  }\n}\n</cell>\n<cell>", "\n  s <- 0\n  for (i in 1:length(numbers))\
    \ {\n    s <- s + numbers[i]\n  }\n  c(s = s, product = prod(numbers))\n}\n</code>\n\
    <|/ a dscore=2 tags=sum,r,list,product,list |>\n<| a |>\nAn alternative solution,\
    \ which doesn't require the purrr package:\n<code>\nf <- function(x){\n  return(list(sum(x),\
    \ prod(x)))\n}\nf(1:3)\n</code>\n<|/ a dscore=1 tags=sum,r,list,product,list |>\n\
    <| c |>\n`f` should be `function(x){return(list(sum(x), prod(x)))}`\n<|/ c |>\n\
    <| c |>\nThanks! I fixed it.\n<|/ c |>\n<| a tags=sum,r,list,product,list |>\n\
    Using purrr map and reduce is also a viable solution:\n<code>\nmap(1:3, ~ list(sum(x),\
    \ prod(x)))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou don't need `~` here. You\
    \ could just `map(1:3, list(sum, prod))`. Furthermore `reduce` isn't needed here.\n\
    <|/ c |>\n<| a tags=sum,r,list,product,list |>\nThe purrr package is useful to\
    \ do operations on lists of lists. In this case, we are dealing with lists of\
    \ length 1 and 2. For this, we can simply use the map and reduce functions inside\
    \ map_df and reduce functions.\n<code>\nlibrary(purrr)\n", "\n  numbers %>% \n\
    \    map_dbl(function(x) if (length(x) == 0) 0 else x[1]) %>% \n    c(0) %>% \n\
    \    reduce(`*`)\n}\n", "\n  if(length( numbers ) == 0) return(c(0, 1))\n  if(length(\
    \ numbers ) == 1) return(numbers)\n  sum <- numbers[1]\n  product <- 1\n  \n \
    \ for (i in 2:length( numbers )) {\n    product <- product * numbers[i]\n    sum\
    \ <- sum + numbers[i]\n  }\n  \n  return(c(sum, product))\n}\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>", "\n  s <- 0\n  p <- 1\n  for (i in numbers) {\n   \
    \ s += i\n    p = p * i\n  }\n  list(sum=s, product=p)\n}\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes an integer n and returns the n-th element of\
    \ the Fibonacci sequence.\n\n\n</text>\n<cell>", "\n  numbers <- na.omit(numbers)\n\
    \  if(length(numbers) == 0) return(c(0, 1))\n  product <- 1\n  sum <- 0\n  for(i\
    \ in numbers) {\n    sum <- sum + i\n    product <- product * i\n  }\n  return(c(sum,\
    \ product))\n}\n</code>\n<|/ a |>\n<| c |>\nThis is definitely the best solution\
    \ here.  If you really want to use `data.table` for speed, you could speed this\
    \ up significantly by doing `library(data.table); setDT(numbers)[, list(sum, product),\
    \ by = numbers]`\n<|/ c |>\n<| c |>\nI did a benchmark with the different versions\
    \ and I agree with, your solution is much faster than mine. I am surprised that\
    \ my solution is so slow and you claim it isn't.\n<|/ c |>\n<| c |>\n`data.table`\
    \ was actually pretty slow on my machine. Even if I didn't have any other packages\
    \ loaded, it was still very slow. Your solution is pretty fast, though. I agree\
    \ with you that data.table is very slow on most systems, especially with large\
    \ data sets. I suppose your answer is faster because it doesn't use any packages,\
    \ and it's only relying on base R. If I wanted speed, I would use Rcpp and RcppArmadillo.\
    \ But I agree that your solution is much faster than mine :D\n<|/ c |>\n<| c |>\n\
    Just a note for anyone reading this later, the `data.table` solution was actually\
    \ slower for me, but was faster with smaller data sets. The larger data sets,\
    \ the `data.table` solution was significantly slower.\n<|/ c |>\n<| a tags=r,algorithm,loops\
    \ |>\nHere's a dplyr solution using rowSums and rowProd from the dplyr package\n\
    <code>\nlibrary(dplyr)\n\nnumbers <- c(1,2,3,4)\n\nnumbers %>% \n  as.data.frame()\
    \ %>% \n  rowSums() %>% \n  rowProd() %>% \n  data.frame()\n</code>\n<|/ a dscore=5\
    \ |>\n<| a tags=r,algorithm,loops |>\nYou could use lapply() with a for loop:\n\
    <code>\nnumbers <- c(1,2,3,4)\nfor (i in 1:length(numbers)) {\n  numbers[i] <-\
    \ numbers[i] * numbers[i]\n}\nnumbers", "\n    if (is.null(numbers)) {\n     \
    \   return(c(sum = 0, product = 1))\n    } else if (length(numbers) < 2) {\n \
    \       return(c(sum = 0, product = numbers[1]))\n    } else {\n        number\
    \ <- numbers[1]\n        for (i in 2:length(numbers)) {\n            number <-\
    \ number * numbers[i]\n        }\n        return(c(sum = number, product = number))\n\
    \    }\n}\n", "\n  numbers <- as.list(numbers)\n  sum(numbers)\n  prod(numbers)\n\
    }\n", "\n  if (length(numbers) <= 1) c(numbers, numbers)\n  else c(numbers[numbers\
    \ > 0],\n         numbers[numbers > 0] * numbers[numbers > 0])\n}\n</code>\n<|/\
    \ a tags=r dscore=0 |>\n<| a |>\nI think this one is a bit easier:\n<code>\nnumbers=c(1,2,3,4,5,6,7,8,9,10)\n\
    \nsum_product_function <- function(numbers){\n\n    product_function <- function(x){\n\
    \        x <- x*x\n    }\n\n    sum_function <- function(x){\n        sum(x)\n\
    \    }\n\n    product_function <- lapply(product_function, numbers)\n    sum_function\
    \ <- lapply(sum_function, numbers)\n\n    result <- do.call(\"c\", list(product_function,\
    \ sum_function))\n\n    return(result)\n}\n\nsum_product_function(numbers)\n</code>\n\
    <|/ a dscore=0 tags=r |>\n<| a dscore=0 |>\nWe can use outer\n<code>\nouter(numbers,\
    \ numbers, \"*\")\n</code>\n<|/ a tags=r |>\n<| a dscore=0 tags=r |>\nHere's a\
    \ solution that uses purrr::reduce:\n<code>\nlibrary(purrr)\nnumbers <- c(1,2,3,4,5,6,7,8,9,10)\n\
    \nreduce(numbers, function(x,y) c(x,y))\n", "\n  numbers <- sort(numbers)\n  result\
    \ <- c(0,1)\n  for(i in seq_along(numbers)) {\n    product = 1\n    sum = 0\n\
    \    for(j in i:length(numbers)) {\n      product *= numbers[j]\n      sum +=\
    \ numbers[j]\n    }\n    result <- c(result,list(sum=sum, product=product))\n\
    \  }\n  result\n}\n\nprint(sum_product(c(6,5,3,2,4,3)), collapse=\"\\n\")", "\n\
    \  numbers %>% \n    lapply(sum) %>% \n    do.call(c, .) %>% \n    c(., 1) %>%\
    \ \n    lapply(product)\n}\n", "\n  numbers <- sort(numbers)\n  sum(numbers) *\
    \ (length(numbers) + 1)\n}\n", "\n  out <- c(0,1)\n  for (i in 2:length(numbers))\
    \ {\n    out <- c(out[1], out[2] + numbers[i])\n  }\n  out\n}\n", "\n  numbers\
    \ <- sort(numbers)\n  sum <- 0\n  product <- 1\n  for (i in seq_along(numbers))\
    \ {\n    sum <- sum + numbers[i]\n    product <- product * numbers[i]\n  }\n \
    \ c(sum = sum, product = product)\n}\n", "\n  if (is.null(numbers)) return(0)\n\
    \  n <- length(numbers)\n  m <- n %%- 1\n  sum <- c(0, numbers)\n  if (m == 0)\
    \ {\n    product1 <- prod(numbers)\n    return(list(sum = sum, product = product1))\n\
    \  }\n  product2 <- c(1, numbers[1:m])\n  product2 <- prod(product2)\n  product2\
    \ <- product2[1]\n  return(list(sum = sum, product = product2))\n}\n\nsum_product(list(1,\
    \ 2, 3, 4))", "\n  numbers <- sort(numbers)\n  \n  if(nchar(numbers) == 0) {\n\
    \    c(1,1)\n  } else {\n    c(numbers[1] + numbers[2], numbers[1] * numbers[2])\n\
    \  }\n}\n", "\n  numbers <- sort(numbers)\n  sum(numbers)\n  prod(numbers)\n}\n\
    </cell>\n<text>\nProblem 3b\nDefine a function that computes the sum of the squares\
    \ of a list of numbers. You can do this using the function ss. The function ss\
    \ takes a single argument that is a list of numbers. A call to ss of a list of\
    \ numbers can either return the sum of the squares of the numbers, or the sum\
    \ of the squares and products of the numbers. For example:", "\n  numbersList\
    \ <- list(numbers)\n  \n  nums <- unlist(numbersList)\n  \n  nums <- sort(nums)\n\
    \  \n  listSumProduct <- list(x = nums, sum = sumNum(nums), product = productNum(nums))\n\
    \  \n  listSumProduct \n}\n", "\n    if (length(numbers) == 0) return(c(0, 1))\n\
    \    sum_ <- numbers[1]\n    product <- 1\n    for (i in 2:length(numbers)) {\n\
    \        sum_ <- sum_ + numbers[i]\n        product <- product * i\n    }\n  \
    \  return(c(sum_, product))\n}\n", "\n  sapply(numbers, function(x) sum(x) + prod(x))\n\
    }\n", "\n  if(length(numbers) < 2) {\n    return(list(sum = 0, product = 1))\n\
    \  }\n  else {\n    output <- c(sum(numbers), product(numbers))\n    return(output)\n\
    \  }\n}\n</code>\n<|/ a |>\n<| c |>\nThanks! That works beautifully. I just had\
    \ to change `numbers[[1]]` to `numbers`, and `numbers[[2]]` to `numbers[[1]]`,\
    \ so I can use it for a list of lists too, but otherwise it's a very neat solution.\
    \ :)\n<|/ c |>\n<| c |>\nYou are right, I changed the answer accordingly. Now\
    \ it works with a list of lists.\n<|/ c |>\n<| a |>\nHere is a solution using\
    \ tidyverse.\n<code>\nlibrary(tidyverse)\nx <- c(1, 2, 3, 4)\nsumx <- c(sum(x),\
    \ 1)\nyx <- c(x, 1)\nz <- mapply(`+`, sumx, yx)\nz <- rbind(z, c(1,1))\nz[c(NA,\
    \ seq_along(z))] <- c(z[c(NA, seq_along(z))], 0)\n\nt(z) %>% \n  as.data.frame()\
    \ %>% \n  rownames_to_column(var = \"var\") %>% \n  gather(var, val, -var) %>%\
    \ \n  mutate(val = ifelse(is.na(val), 0, val)) %>% \n  select(-var) %>% \n  spread(var,\
    \ val)\n\nvar     1    2    3    4\n[1,] 1.0 2.0 3.0 4.0\n[2,] 0.0 1.0 0.0 1.0\n\
    </code>\n<|/ a tags=sum,r dscore=1 |>\n<| c |>\nThanks. This works too, but I\
    \ went with the more elegant solution proposed by since it deals better to lists\
    \ than a tibble.\n<|/ c |>\n<| a tags=sum,r |>\nHere is another option with Reduce.\
    \  It may be efficient for larger datasets.\n<code>\nReduce(`+`, Map(`*`, x, c(1,\
    \ 1)))", "\n  if (length(numbers) == 0) return(list(sum = 1, product = 1))\n \
    \ else {\n    sum <- 0\n    product <- 1\n    for (num in numbers) sum <- sum\
    \ + num\n    for (num in numbers) product <- product * num\n    list(sum = sum,\
    \ product = product)\n  }\n}\n</code>\nUsing this function, you can create a function\
    \ that will output the product of a given list of integers (if the list is empty,\
    \ then the output will be 0). From there, you can use the function you created\
    \ in #3 to solve the problem as follows:\n<code>", "\n  s <- sum(numbers)\n  p\
    \ <- prod(numbers)\n  c(s, p)\n}\n", "\n  numbers <- sort(numbers)\n  if (sum(numbers)\
    \ == 0) {\n    return(0)\n  } else {\n    sum(numbers)\n  }\n}\n", "\n  result\
    \ <- vector(mode=\"numeric\")\n  result[length(result)] <- 0\n  result[length(result)+1]\
    \ <- 1\n  numbers <- sort(numbers)\n  result[1] <- 0\n  for (i in 2:length(numbers))\
    \ {\n    result[i] <- result[i-1] + numbers[i]\n  }\n  return(result)\n}\n", "\n\
    \  number_list = numbers[[1]]\n  number_list[] <- numeric(length(number_list))\n\
    \  number_list[1] <- 1\n  \n  number_sum <- 0\n  number_product <- 1\n  \n  for(num\
    \ in number_list) {\n    number_sum += num\n    number_product *= num\n  }\n \
    \ \n  list(sum = number_sum, product = number_product)\n}\n</cell>\n<cell>\nsum_product(c(1,\
    \ 2, 3, 4))\n</cell>\n<text>\n(2) Implement a binary search function that takes\
    \ a list and a number as arguments.\nThe function should return the index where\
    \ the number would be found if it was inserted at the head of the list.\nThe search\
    \ should start in the middle and go left if the number is less than the middle\
    \ element and go right if the number is greater than the middle element.\nNote\
    \ that if the number does not exist in the list the function should return -1.\n\
    \n\n</text>\n<cell>", "\n    output <- c()\n    for(i in seq_along(numbers)) {\n\
    \        output <- c(output, sum(numbers))\n        output <- c(output, prod(numbers))\n\
    \    }\n    return(output)\n}\n</cell>\n<text>\nExercise 5\nWrite a function that\
    \ multiplies all the numbers in a list.  It should return a list that includes\
    \ the sum and product of all numbers in the list.\nExample: c(1, 2, 3) should\
    \ return c(0, 6, 12).\nHint: Use sum and prod.\n\n\n</text>\n<code language=conda-env-Anaconda3-py>",
  "\n  if (length(numbers) == 0) {\n    return(c(0, 1))\n  } else if (length(numbers)\
    \ == 1) {\n    return(c(numbers[1], numbers[1]))\n  } else {\n    # Get the sum\
    \ of all the numbers\n    sum <- 0\n    for (number in numbers) {\n      sum <-\
    \ sum + number\n    }\n    \n    # Get the product of all the numbers\n    product\
    \ <- 1\n    for (number in numbers) {\n      product <- product * number\n   \
    \ }\n    return(c(sum, product))\n  }\n}\n", "\n  numbers <- sort(numbers)\n \
    \ sum(numbers)\n  prod(numbers)\n}\n</cell>\n<text>\nWe now implement the function\
    \ fibonacci_recursive() to calculate fibonacci numbers using recursion:\n\n\n\
    </text>\n<cell>\nfibonacci_recursive <- function(n) {\n  fibonacci_recursive(n-2)\
    \ + fibonacci_recursive(n-1)\n}\n\nfibonacci_recursive(2)\n</cell>\n<text>\nWe\
    \ now implement the function fibonacci_recursive_vectorized() to calculate fibonacci\
    \ numbers using vectorization:\n\n\n</text>\n<cell>\nfibonacci_recursive_vectorized\
    \ <- function(n) {\n  fibonacci_vectorized(n - 2) + fibonacci_vectorized(n - 1)\n\
    }\n\nfibonacci_recursive_vectorized(2)\n</cell>\n<text>\nWe now implement the\
    \ function fibonacci_vectorized() to calculate fibonacci numbers using a recursive\
    \ function:\n\n\n</text>\n<cell>\nfibonacci_vectorized <- function(n) {\n  if(n\
    \ < 2) return(0)\n  fibonacci_vectorized(n-2) + fibonacci_vectorized(n-1)\n}\n\
    \nfibonacci_vectorized(2)\n</cell>\n<text>\nWe now test our functions with the\
    \ two implementations and benchmark them:\n\n\n</text>\n<cell>\nfibonacci_recursive(100)\n\
    </cell>\n<cell>\nfibonacci_recursive_vectorized(100)\n</cell>\n<cell>\nfibonacci_vectorized(100)\n\
    </cell>\n<text>\nWe now implement the function fib() to calculate fibonacci numbers\
    \ using recursion:\n\n\n</text>\n<cell>\nfib <- function(n) {\n  if(n < 2) return(0)\n\
    \  fib(n-2) + fib(n-1)\n}\n\nfib(10)\n</cell>\n<text>\nWe now implement the function\
    \ fib_vectorized() to calculate fibonacci numbers using a recursive function:\n\
    \n\n</text>\n<cell>\nfib_vectorized <- function(n) {\n  fib_vectorized(n-2) +\
    \ fib_vectorized(n-1)\n}\n\nfib_vectorized(10)\n</cell>\n<text>\nWe now test our\
    \ functions with the two implementations and benchmark them:\n\n\n</text>\n<cell>\n\
    fib(100)\n</cell>\n<cell>\nfib_vectorized(100)\n</cell", "\n  numbers <- c(numbers)\n\
    \  numbers <- sort(numbers)\n  numbers <- c(numbers, rep(NA, length(numbers) +\
    \ 1))\n  numbers <- c(numbers, rep(numbers[1], nrow(numbers) + 1))\n  numbers\
    \ <- numbers[2:(nrow(numbers) - 1)]\n  numbers <- c(numbers, rep(numbers[length(nth(numbers,\
    \ 2)) - 2], length(numbers) + 1))\n  numbers <- numbers[3:(nrow(numbers) - 1)]\n\
    \  numbers <- numbers[1:(nrow(numbers) - 1)]\n  numbers <- numbers * numbers[length(numbers)]\n\
    \  numbers <- c(numbers, 0)\n  numbers[length(numbers)] <- 1\n  numbers <- numbers\
    \ / sum(numbers)\n  numbers <- numbers * numbers[length(numbers)]\n  numbers <-\
    \ numbers[2:(nrow(numbers) - 1)]\n  numbers <- c(numbers, rep(numbers[length(nth(numbers,\
    \ 2)) - 2], length(numbers) + 1))\n  numbers <- numbers[3:(nrow(numbers) - 1)]\n\
    \  numbers <- numbers[1:(nrow(numbers) - 1)]\n  numbers <- numbers * numbers[length(numbers)]\n\
    \  numbers <- c(numbers, 0)\n  numbers[length(numbers)] <- 1\n  numbers <- numbers\
    \ / sum(numbers)\n  numbers <- numbers * numbers[length(numbers)]\n  numbers <-\
    \ numbers[2:(nrow(numbers) - 1)]\n  numbers <- c(numbers, rep(numbers[length(nth(numbers,\
    \ 2)) - 2], length(numbers) + 1))\n  numbers <- numbers[3:(nrow(numbers) - 1)]\n\
    \  numbers <- numbers[1:(nrow(numbers) - 1)]\n  numbers <- numbers * numbers[length(numbers)]\n\
    \  numbers <- c(numbers, 0)\n  numbers[length(numbers)] <- 1\n  numbers <- numbers\
    \ / sum(numbers)\n  numbers <- numbers * numbers[length(numbers)]\n  numbers <-\
    \ numbers[2:(nrow(numbers) - 1)]\n  numbers <- c(numbers, rep(numbers[length(nth(numbers,\
    \ 2)) - 2], length(numbers) + 1))\n  numbers <- numbers[3:(nrow(numbers) - 1)]\n\
    \  numbers <- numbers[1:(nrow(numbers) - 1)]\n  numbers <- numbers * numbers[length(numbers)]\n\
    \  numbers <- c(numbers, 0)\n  numbers[length(numbers)] <- 1\n  numbers <- numbers\
    \ / sum(numbers)\n  numbers <- numbers * numbers[length(numbers)]\n  numbers <-\
    \ numbers[2:(nrow(numbers) - 1)]\n  numbers <- c(numbers, rep(numbers[length(nth(numbers,\
    \ 2)) - 2], length(numbers) + 1))", "\n  n_items <- length(numbers)\n  if(n_items\
    \ == 0) {\n    return (list(a = 0, b = 0))\n  } else if(n_items == 1) {\n    return\
    \ (list(a = numbers[1], b = numbers[1]))\n  }\n  \n  numbers <- sort(numbers)\n\
    \  \n  sum_list <- list()\n  prod_list <- list()\n  \n  sum_list <- c(sum_list,\
    \ numbers[1L])\n  prod_list <- c(prod_list, numbers[1L])\n  \n  for (i in 2L:n_items)\
    \ {\n    \n    tmp_sum <- numbers[i] + sum_list[length(sum_list)]\n    tmp_prod\
    \ <- numbers[i] * prod_list[length(prod_list)]\n    \n    sum_list <- c(sum_list,\
    \ tmp_sum)\n    prod_list <- c(prod_list, tmp_prod)\n    \n  }\n  \n  return(list(a\
    \ = sum_list, b = prod_list))\n}\n", "\n  if(is.null(numbers)) {\n    NULL\n \
    \ }\n  if(length(numbers) == 0) {\n    c(0,1)\n  }\n  \n  else {\n    sum <- numbers[1]\n\
    \    product <- 1\n    for(i in 2:length(numbers)) {\n      sum <- sum + numbers[i]\n\
    \      product <- product * i\n    }\n    c(sum, product)\n  }\n}\n", "\n  numbers\
    \ <- sort(numbers)\n  return(list(sum = sum(numbers), product = prod(numbers)))\n\
    }\n", "\n  result <- numeric(length(numbers))\n  result[[1]] <- 0\n  result[[2]]\
    \ <- 1\n  for (i in seq_along(numbers)) {\n    result[[i]] <- result[[i]] + (numbers[[i]])\n\
    \    result[[i]] <- result[[i]] * result[[i-1]]\n  }\n  result\n}\n", "\n  if(length(numbers)\
    \ < 2) return(c(0, 1))\n  number <- head(rev(numbers), 1)\n  numbers <- tail(numbers,\
    \ 1)\n  result <- list(sum(number), prod(number))\n  result\n}\n", "\n    numbers[[1]][1]\
    \ + numbers[[2]][1]*numbers[[3]][1]*numbers[[4]][1]*numbers[[5]][1]*numbers[[6]][1]*numbers[[7]][1]*numbers[[8]][1]*numbers[[9]][1]*numbers[[10]][1]*numbers[[11]][1]*numbers[[12]][1]*numbers[[13]][1]*numbers[[14]][1]*numbers[[15]][1]*numbers[[16]][1]*numbers[[17]][1]*numbers[[18]][1]*numbers[[19]][1]*numbers[[20]][1]*numbers[[21]][1]*numbers[[22]][1]*numbers[[23]][1]*numbers[[24]][1]*numbers[[25]][1]*numbers[[26]][1]*numbers[[27]][1]*numbers[[28]][1]*numbers[[29]][1]*numbers[[30]][1]*numbers[[31]][1]*numbers[[32]][1]*numbers[[33]][1]*numbers[[34]][1]*numbers[[35]][1]*numbers[[36]][1]*numbers[[37]][1]*numbers[[38]][1]*numbers[[39]][1]*numbers[[40]][1]*numbers[[41]][1]*numbers[[42]][1]*numbers[[43]][1]*numbers[[44]][1]*numbers[[45]][1]*numbers[[46]][1]*numbers[[47]][1]*numbers[[48]][1]*numbers[[49]][1]*numbers[[50]][1]*numbers[[51]][1]*numbers[[52]][1]*numbers[[53]][1]*numbers[[54]][1]*numbers[[55]][1]*numbers[[56]][1]*numbers[[57]][1]*numbers[[58]][1]*numbers[[59]][1]*numbers[[60]][1]*numbers[[61]][1]*numbers[[62]][1]*numbers[[63]][1]*numbers[[64]][1]*numbers[[65]][1]*numbers[[66]][1]*numbers[[67]][1]*numbers[[68]][1]*numbers[[69]][1]*numbers[[70]][1]*numbers[[71]][1]*numbers[[72]][1]*numbers[[73]][1]*numbers[[74]][1]*numbers[[75]][1]*numbers[[76]][1]*numbers[[77]][1]*number",
  "\n  numbers %>%\n    reduce2(function(a, b) c(a = a + b, a = a * a)) %>%\n    collect()\n\
    }\n", "\n  numbers <- sort(numbers)\n  if (length(numbers) == 0) return (c(sum\
    \ = 0, product = 1))\n  s <- 0\n  p <- 1\n  for (i in 1:length(numbers)) p <-\
    \ p * numbers[i]\n  return(c(sum = s, product = p))\n}\n", "\n  numbers <- numbers[-length(numbers)]\n\
    \  length(numbers) <- 0\n  numbers <- c(numbers, 0)\n  prod(numbers)\n}\n</cell>\n\
    <text>\nWe have a function called sum_product that can compute the sum and product\
    \ of the integers in a vector, and we already tested this with the vector c(),\
    \ which contains 0.\n\nNext, we write another function called factorial which\
    \ computes the factorial of a given number. As you may recall from the previous\
    \ lab, we can easily compute this from our previous sum_product function.\n\n\n\
    </text>\n<cell>\nfactorial <- function(number) {\n  if (number == 1) return (1)\n\
    \  prod(seq_len(number))\n}\n</cell>\n<text>\nThis factorial function takes a\
    \ number and checks whether it equals one or not. If it equals one, it returns\
    \ the number itself. If it doesn't, it returns the product of all positive integers\
    \ up to and including that number.\n\nFor instance, factorial(2) returns 2 (the\
    \ factorial of 2), factorial(3) returns 6 (the factorial of 3), and factorial(4)\
    \ returns 24 (the factorial of 4).\n\nLet's test our factorial function with the\
    \ numbers 1 and 2:\n\n\n</text>\n<cell>\nfactorial(1)\n</cell>\n<cell>\nfactorial(2)\n\
    </cell>\n<text>\nAs we can see, this function works exactly like our previous\
    \ sum_product function, which computes the sum and product of all the numbers\
    \ in a vector.\n\n\n</text>\n<text>\nProblem 2b\n\nWrite a function that takes\
    \ a vector of numbers and an integer k, and returns a vector of all the numbers\
    \ in the vector that do not divide evenly by k. For example:\n\n\n</text>\n<cell>\n\
    c(1, 2)\n</cell>\n<cell>\nc(1, 2, 3)\n</cell>\n<text>\nSince 3 divides evenly\
    \ into 2 and 3, these numbers are included in the output vector below:\n\n\n</text>\n\
    <cell>\nmy_func <- function(vec, k) {\n  sum(vec[sapply(vec, function(x) x %%\
    \ k != 0)])\n}\n</cell>\n<cell>\nmy_func(c(1, 2, 3), 3)\n</cell>\n<text>\nProblem\
    \ 2c\n\nWrite a function that takes a vector of numbers and an integer k, and\
    \ returns a vector of all the numbers in the vector that divide evenly into k.\
    \ For example:\n\n\n</text>\n<cell>\nc(4, 5, 6)\n</cell>\n<cell>\nc(4, 5, 6)\n\
    </cell>\n<cell>\nc(4, 5, 6)\n</cell>\n<text>\nSince 6 divides evenly into 4, 5,\
    \ and 6, these numbers are included in the output vector below:\n\n\n</text>\n\
    <cell>\nmy_func <- function(vec, k) {\n  ", "\n  \n  numbers <- sort(numbers)\n\
    \  \n  sum_ <- 0\n  product <- 1\n  \n  for(num in numbers) {\n    \n    sum_\
    \ <- sum_ + num\n    product <- product * num\n  }\n  \n  c(sum = sum_, product\
    \ = product)\n}\n</cell>\n<cell>\nsum_product(c(1, 2, 3))\n</cell>\n<cell>\nsum_product(c(12,\
    \ 3, 9))\n</cell>\n<cell>\nsum_product(c(14, 2, 6, 8))\n</cell>\n<cell>\nsum_product(c(7,\
    \ 4, 3, 2))\n</cell>\n<text>\nChallenge: Write a function called mean_squared_error\
    \ that takes two vectors as inputs, and calculates the mean squared error between\
    \ them. Then, test your function using the following two vectors (of different\
    \ lengths!):\n\na = [2, 4, 2, 4, 4]\nb = [1, 2]\n\nThe mean squared error should\
    \ be around 10. HINT: For simplicity, you should be using a for loop. You might\
    \ want to use mapply instead.\n\nNote that in Python, you can use the zip command\
    \ to pair the elements of two vectors together. HINT: This might be useful once\
    \ you get a hang of vectorized operations.\n\n\n</text>\n<cell>\nmean_squared_error\
    \ <- function(predictions, truth) {\n  # ...\n}\n</cell>\n<cell>\nmean_squared_error(a,\
    \ b)\n</cell>\n<cell>\nmean_squared_error(c(7, 3, 9), c(8, 3, 9))\n</cell>\n<cell>\n\
    mean_squared_error(c(7, 3, 9), c(8, 3, 9, 9))\n</cell>\n<text>\nChallenge: Write\
    \ a function called correlation that takes two vectors as inputs, and calculates\
    \ the correlation between them. Then, test your function using the following two\
    \ vectors (of different lengths!):\n\na = [2, 4, 2, 4, 4]\nb = [1, 2]\n\nThe correlation\
    \ should be around 0.55. HINT: You will want to use ifelse in conjunction with\
    \ cor.\n\n\n</text>\n<cell>\ncorrelation <- function(predictions, truth) {\n \
    \ # ...\n}\n</cell>\n<cell>\ncorrelation(a, b)\n</cell>\n<cell>\ncorrelation(c(7,\
    \ 3, 9), c(8, 3, 9))\n</cell>\n<cell>\ncorrelation(c(7, 3, 9), c(8, 3, 9, 9))\n\
    </cell>\n<text>\nChallenge: Write a function called rmse that takes two vectors\
    \ as inputs, and calculates the root ", "\n  numbers <- sort(numbers)\n  sum <-\
    \ 0\n  product <- 1\n  for (i in 1:length(numbers)) {\n    sum <- sum + numbers[i]\n\
    \    product <- product * numbers[i]\n  }\n  return(c(sum, product))\n}\n", "\n\
    \    numbers <- sort(numbers)\n    sum <- numbers[1]\n    product <- numbers[1]\n\
    \    for (number in numbers[-1]) {\n        sum <- sum + number\n        product\
    \ <- product * number\n    }\n    return(list(sum, product))\n}\n</cell>\n<cell>\n\
    %%R", "\n  numbers %>%\n    map_dbl(sum) %>%\n    map_dbl(prod)\n}\n", "\n  return(list(sum\
    \ = sum(numbers), product = prod(numbers)))\n}", "\n  sapply(numbers, function(x)\
    \ c(sum(x), prod(x)))\n}\n</cell>\n<text>\nExercise 3: For a given list of integers,\
    \ return a list consisting of a sum and a product of all the integers in a list\
    \ whose sum does not exceed 100.\nThe sum and product should both be non-negative.\n\
    The list should include at least one positive integer.\nThe list should include\
    \ at least one negative integer.\nThe product should be multiplied by -1 if all\
    \ elements are negative.\nThe product should be multiplied by -1 if all elements\
    \ are positive.\nIf there are multiple solutions, return the one with the lowest\
    \ sum.\n\n\n</text>\n<cell>", "\n  numbers %>% \n    accumulate(\n      ~c(sum(x),\
    \ prod(x))\n    ) %>% \n    tail(1) %>% \n    as.list()\n}\n</cell>\n<text>\n\
    Let's take a closer look at what we did above.\n\nFirst, we imported the accumulate\
    \ library from the purrr package and created a function that takes two arguments,\
    \ sum and prod, and returns a list consisting of the sum and product of the elements\
    \ in the list.\n\nNext, we used the pipe operator %>% to combine the accumulate\
    \ function with the tail function to remove the head of the list and save it as\
    \ a new list.\n\nFinally, we called the function on the list with the numbers\
    \ from 1 to 10 using a list.\n\nLet's try it out.\n\n\n</text>\n<cell>\nsum_product(c(1,2,3,4,5,6,7,8,9,10))\n\
    </cell>\n<text>\nTo make this a little easier to understand, let's break down\
    \ what we did above into some more \"wordy\" instructions. First, let's create\
    \ the function above.\n\n\n</text>\n<cell>\naccumulate_sum <- function(x) {\n\
    \  accumulate(\n    ~c(sum(x), prod(x)),\n    x,\n    init = list(c(), 1)\n  )\n\
    }\n</cell>\n<text>\nNext, let's create the function and call the function on the\
    \ numbers from 1 to 10.\n\n\n</text>\n<cell>\naccumulate_sum(c(1,2,3,4,5,6,7,8,9,10))\n\
    </cell>\n<text>\nNow, we can write one more function that takes numbers and returns\
    \ both the sum and product of the numbers in a list. To do this, we use the pipe\
    \ operator %>% to combine the accumulate_sum function with tail and as.list to\
    \ remove the head of the list.\n\n\n</text>\n<cell>\nsum_product_accumulate <-\
    \ function(numbers) {\n  numbers %>%\n    accumulate_sum() %>%\n    tail(1) %>%\n\
    \    as.list()\n}\n</cell>\n<text>\nLet's check out the result.\n\n\n</text>\n\
    <cell>\nsum_product_accumulate(c(1,2,3,4,5,6,7,8,9,10))\n</cell>\n<text>\nNotice\
    \ that when we removed the head of the list, it added 1 to the sum and multiplied\
    \ each element by 1.\n\nSo, let's create a function that calculates the product\
    \ of the numbers in a list with the sum of the numbers in a list.\n\n\n</text>\n\
    <cell>\nproduct_sum_accumulate <- function(numbers) {\n  numbers %>%\n    accumulate_sum()\
    \ %>%\n    accumulate(\n      ~c(prod(x), sum(x)),\n      x,\n      init = list(c(),\
    \ 1)\n    ) %>%\n    tail(1) %>%\n    as.list()\n}\n</cell>\n<text>", "\n  nums\
    \ <- lapply(numbers, function(x) sum(x) + prod(x))\n  nums <- setNames(nums, paste0(\"\
    c(\", paste(numbers, collapse = \", \"), \")\"))\n  return(nums)\n}\n</cell>\n\
    <code language=julia-0.6>\nsum_product([1, 2, 3, 4])\n</cell>\n<text>\nNow we\
    \ are ready to implement a function that returns the max number in a list of numbers\n\
    \n\n</text>\n<code language=julia-0.6>", "\n    numbers <- na.omit(numbers)\n\
    \    result <- c(0, 0)\n    i <- 0\n    while(i + length(numbers) < length(numbers))\
    \ result[1] <- result[1] + numbers[i]\n    while(i + 1 < length(numbers)) {\n\
    \        result[1] <- result[1] + numbers[i]\n        result[2] <- result[2] *\
    \ numbers[i + 1]\n        i <- i + 1\n    }\n    result\n}\n", "\n    numbers\
    \ <- unlist(numbers)\n    numbers <- c(numbers, 0)\n    numbers <- c(numbers,\
    \ 1)\n    numbers\n}\n\nsum_product <- function(numbers) {\n    numbers <- unlist(numbers)\n\
    \    numbers <- c(numbers, 0)\n    numbers <- c(numbers, 1)\n    numbers\n}\n\n\
    sum_product <- function(numbers) {\n    numbers <- unlist(numbers)\n    numbers\
    \ <- c(numbers, 0)\n    numbers <- c(numbers, 1)\n    numbers\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nIt might be a little too clever but I like it.  And it could\
    \ be a little less clever (not so much to me) by using a `Reduce` instead of `Reduce`.\
    \  Maybe the function should return a list rather than a single element (but that\
    \ would be a little too clever too).  You could even use the function `Reduce`\
    \ itself to do this too:  `Reduce(function(x,y)c(y,x), c(1, 2, 3, 4))`\n<|/ c\
    \ |>\n<| c |>\nI believe you mean `Reduce` rather than `Reduce`. And yes, I believe\
    \ `Reduce` would be more clever (IMHO).\n<|/ c |>\n<| c |>\n, Yes, you're right,\
    \ I meant `Reduce` rather than `Reduce`.  I edited the post accordingly.\n<|/\
    \ c |>\n<| a |>\nWe can use Reduce in base R. \n<code>\nReduce(function(x, y)\
    \ c(x,y), c(1, 2, 3, 4))\n", "\n    numbers <- as.list(numbers)\n    sum_numbers\
    \ <- 0\n    prod <- 1\n    for(i in seq_along(numbers))\n        sum_numbers <-\
    \ sum_numbers + numbers[i]\n    for(i in seq_along(numbers))\n        prod <-\
    \ prod * numbers[i]\n    c(sum_numbers, prod)\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nHere's a way using data.table package:\n<code>\nlibrary(data.table)\ndt\
    \ <- data.table(\n  n = c(1:5),\n  m = c(1:5)\n)\n\ndt[, summ := sum(n), by =\
    \ m]\n\ndt[, prod := prod(n), by = m]\n\n> dt\n    n  m  summ  prod\n1:  1  1\
    \   10   10\n2:  2  2   12   24\n3:  3  3   15   30\n4:  4  4   20   40\n5:  5\
    \  5   25   50\n</code>\n<|/ a tags=r |>\n<| c |>\nNice! It's also worth mentioning\
    \ that this can be done in `dplyr` as well - `dt %>% mutate(prod = sum(n) * prod(n))\
    \ %>% group_by(m) %>% summarise(summ = sum(n), prod = prod(n))`.\n<|/ c |>\n<|\
    \ a |>\nHere's another base R alternative\n<code>", "\n  s <- 0\n  p <- 1\n  for(i\
    \ in numbers) {\n    s <- s + i\n    p <- p * i\n  }\n  return(c(s, p))\n}\n",
  "\n  numbers <- as.numeric(numbers)\n  if(all(is.na(numbers))) {\n    return(c(sum=NA,\
    \ product=1))\n  }\n  else {\n    numbers <- sort(numbers)\n    i <- 0\n    while(i\
    \ < length(numbers)) {\n      j <- i + 1\n      while(j < length(numbers)) {\n\
    \        if(numbers[i] < numbers[j]) {\n          sum <- sum + numbers[i]\n  \
    \        product <- product * (numbers[j] - numbers[i])\n        }\n        j\
    \ <- j + 1\n      }\n      i <- i + 1\n    }\n    return(c(sum=sum, product=product))\n\
    \  }\n}\n", "\n    result <- list(sum=0, product=1)\n    for (i in seq_along(numbers))\
    \ {\n        result <- c(result, list(sum=sum(numbers[i]), product=numbers[i]*result$product))\n\
    \    }\n    result\n}\n", "\n  # your code here\n  sum(numbers)\n  prod(numbers)\n\
    }\n</cell>\n<cell>\nsum_product(c(1, 2, 3, 4))\n</cell>\n<cell>", "\n  s <- 0\n\
    \  p <- 1\n  for (i in seq_along(numbers)) {\n    s += numbers[i]\n    p *= numbers[i]\n\
    \  }\n  c(s, p)\n}\n</code>\n<|/ a tags=sum,r,function |>\n<| c |>\nNice.  I would\
    \ write it like this: `p <- 1; for (i in seq_along(numbers)) p <- p * numbers[i];\
    \ p`.\n<|/ c |>\n<| c |>\n: Thanks. I like your approach better.\n<|/ c |>\n<|\
    \ c |>\nYes, I didn't realize you could redefine p with p <- 1 in the `for` loop.\
    \  That's an elegant solution.\n<|/ c |>\n<| c |>\n+1. Very nice. Do you consider\
    \ it good practice to create your `p` variable in the global environment? It seems\
    \ weird to me to create it in the local environment and then throw it away at\
    \ the end of the function. What about using `<<-` instead?\n<|/ c |>\n<| c |>\n\
    , I would definitely not recommend creating `p` as an object in the global environment.\
    \ It makes the code less readable in my opinion. But it works either way. I used\
    \ the global environment because I thought it was the most common use case where\
    \ I would do that. But I would definitely use an argument for the function.\n\
    <|/ c |>\n<| a tags=sum,r,function dscore=4 |>\nWe can use Reduce with +:\n<code>\n\
    Reduce(`+`, list(1:3, 4:6))", "\n  numbers2 <- na.omit(numbers)\n  return(c(sum(numbers2),prod(numbers2)))\n\
    }\n", "\n  \n  number <- sort(numbers)\n  \n  if(length(number) == 1) {\n    sum\
    \ <- number[1]\n    product <- number[1]\n  } else {\n    sum <- sum(number[1:(length(number)-1)])\n\
    \    product <- product(number[1:(length(number)-1)])\n  }\n  \n  list(sum, product)\n\
    }\n</cell>\n<cell>\nsum_product(c(1, 2, 3, 4))\n</cell>\n<text>\nExercise 5: What\
    \ would you expect to happen if one changed the following line:\n\nnumber <- sort(numbers)\n\
    to\n\nnumber <- c(sort(numbers))\nYou would expect the output to be different\
    \ from c(1, 2). Why?\n\n\n</text>\n<text>\nSolution\n\n</text>\n<text>\nIn addition\
    \ to being used as an argument in the function sum_product(), it is passed into\
    \ the function by the user by assigning it to a variable called numbers. Since\
    \ we would like to ensure that we always have an unordered vector of numbers,\
    \ we could use c(...) instead of sort(...).\n\nThis would cause us to always have\
    \ numbers in the same order and therefore the output would be the same.\n\n\n\
    </text>\n<cell>\nsum_product <- function(numbers) {\n  \n  number <- c(sort(numbers))\n\
    \  \n  if(length(number) == 1) {\n    sum <- number[1]\n    product <- number[1]\n\
    \  } else {\n    sum <- sum(number[1:(length(number)-1)])\n    product <- product(number[1:(length(number)-1)])\n\
    \  }\n  \n  list(sum, product)\n}\n</cell>\n<cell>\nsum_product(c(1, 2, 3, 4))\n\
    </cell>\n<text>\nExercise 6: What would you expect to happen if one changed the\
    \ following line:\n\nnumber <- c(sort(numbers))\nto\n\nnumber <- sort(numbers)\n\
    You would expect the output to be different from c(1, 2). Why?\n\n\n</text>\n\
    <text>\nSolution\n\n</text>\n<text>\nIf we used c(...) to create the unordered\
    \ vector of numbers, the output would be c(2, 3, 4, 1). From this, we can deduce\
    \ that sort(...) returns the same vector unordered but with numbers re-ordered.\n\
    \n\n</text>\n<cell>\nsum_product <- function(numbers) {\n  \n  number <- sort(numbers)\n\
    \  \n  if(length(number) == 1) {\n    sum <- number[1]\n    product <- number[1]\n\
    \  } else {\n    sum <- sum(number[1:(length(number)-1)])\n    product <- product(number[1:(length(number)-1)])\n\
    \  }\n  \n  list(sum, product)\n}\n</cell>\n<cell>\n", "\n  if(length(numbers)\
    \ == 0) return(c(0, 1))\n  else {\n    sum(numbers)\n    prod(numbers)\n  }\n\
    }\n", "\n  result <- numeric(0)\n  result[[1]] <- 0\n  result[[2]] <- 1\n  result\
    \ <- lapply(numbers, function(number) c(result[[1]] + number, result[[2]] * number))\n\
    \  result\n}\n</code>\n<|/ a |>\n<| c |>\nI like this approach. Why does the `lapply`\
    \ solution take so much longer than the `sapply` solution?\n<|/ c |>\n<| c |>\n\
    Thank you for asking. As it turns out, I thought that `sapply` would do the job\
    \ as well, but I realized that in my case it would not give correct results. I\
    \ guess that I was wrong. I will post a follow up question. In the meantime, your\
    \ question is very helpful.\n<|/ c |>\n<| c |>\nMy follow up question can be found\
    \ [here](https://stackoverflow.com/questions/67709065/why-does-this-function-take-so-long-to-run).\n\
    <|/ c |>\n<| a dscore=1 tags=r,performance,for-loop |>\nYou can try a functional\
    \ solution:\n<code>\nset.seed(1234)\nx <- sample(1:1000000, 100, replace = TRUE)\n\
    system.time({\n  out <- sapply(1:length(x), function(y) sum(x[1:y] + x[(y + 1):length(x)]))\n\
    })", "\n  sum <- numbers[1]\n  product <- numbers[1]\n  for (i in 2:length(numbers))\
    \ {\n    sum <- sum + numbers[i]\n    product <- product * numbers[i]\n  }\n \
    \ return(c(sum, product))\n}\n", "\n  if (sum(numbers) < 0) return(c(0, 1))\n\
    \  else {\n    product <- 1\n    sum <- 0\n    for (i in seq_along(numbers)) {\n\
    \      sum <- sum + numbers[i]\n      product <- product * numbers[i]\n    }\n\
    \    c(sum, product)\n  }\n}\n", "\n  # Your code here\n  result <- list()\n \
    \ result$sum <- 0\n  result$product <- 1\n  if(length(numbers) == 0) {\n    return(result)\n\
    \  }\n  for(i in numbers) {\n    result$sum <- result$sum + i\n    result$product\
    \ <- result$product * i\n  }\n  result\n}\n</cell>\n<cell>\nsum_product(c(1,2,3))\n\
    </cell>\n<cell>\nsum_product(c(1,0))\n</cell>\n<cell>\nsum_product(c(1,2,0,4))\n\
    </cell>\n<cell>", "\n  res <- c(0, 0)\n  for (i in 1:length(numbers)) {\n    res[1]\
    \ <- res[1] + numbers[i]\n    res[2] <- res[2] * numbers[i]\n  }\n  res\n}\n</cell>\n\
    <text>\nExercise 9\nIn the following two exercises we make use of the function\
    \ sum_product. The first one defines a function that adds an element to a vector.\
    \ We use the function sum_product to add the number 3 to our vector x. We also\
    \ use the function sum_product to add the number 4 to our vector x. We then print\
    \ the resulting vector to observe the effect of adding elements to our vector.\n\
    \nIn the second exercise we make use of the function sum_product. We print the\
    \ resulting vector to observe the effect of adding elements to our vector.\n\n\
    Exercise 10\nWrite a function that takes two numbers x1 and x2 of type integer\
    \ and returns the sum of their squares:\n\n$$\nS{x1} + S{x2} = \\left(x1 \\times\
    \ x2 + x_1^2 \\times x_2\\right)^2\n$$\n\nExercise 11\nThe function sum_product\
    \ takes as input a vector of integers and returns the vector $y$ of same length\
    \ as the input vector $x$. For example, if the input vector is c(3, 4) and the\
    \ output vector is c(0, 0, 0), then $y = c(0, 0, 0)$.\n\nExercise 12\nWrite a\
    \ function that takes as input a vector of integers and returns a vector of 0's\
    \ and 1's. If the input vector is c(3, 4) and the output vector is c(1, 1, 1,\
    \ 1), then $y = c(1, 1, 1, 1)$.\n\nExercise 13\nWrite a function that takes as\
    \ input a vector of integers and returns a vector of -1's and 1's. If the input\
    \ vector is c(3, 4) and the output vector is c(1, 1, 1, 1), then $y = c(1, 1,\
    \ 1, 1)$.\n\nExercise 14\nWrite a function that takes as input a vector of integers\
    \ and returns a vector of -1's and 0's. If the input vector is c(3, 4) and the\
    \ output vector is c(1, 1, 1, 1), then $y = c(1, 1, 1, 1)$.\n\nExercise 15\nWrite\
    \ a function that takes as input a vector of integers and returns a vector of\
    \ -1's and 1's. If the input vector is c(3, 4) and the output vector is c(1, 1,\
    \ 1, 1), then $y = c(1, 1, 1, 1)$.\n\nExercise 16\nWrite a function that takes\
    \ as input a vector of integers and returns a vector of -1's and 0's. If the input\
    \ vector is c(3, 4) and the output vector is c(1, 1, 1, 1), then $y = c(1, 1,\
    \ 1, 1)$.\n\n\n</text>\n<cell>", "\n    result <- c(0, 1) # initialize to sum\
    \ and product of 0s and 1s\n    for (i in numbers) {\n        result <- c(result,\
    \ i) # add each element of numbers to result\n    }\n    result\n}\n", "\n  if(length(numbers)\
    \ == 0) c(0,1) else \n    c(sum(numbers), prod(numbers))\n}\n", "\n  number <-\
    \ numbers[1]\n  result <- rep(list(sum(number)), length(number))\n  result[[1]]\
    \ <- 0\n  result[[2]] <- 1\n  result\n}\n", "\n  numbers[[1]] <- 0\n  products[[1]]\
    \ <- 1\n  for (number in numbers) {\n    sums[[1]] <- sums[[1]] + number\n   \
    \ products[[1]] <- products[[1]] * number\n  }\n  list(\"sum\" = sums[[1]], \"\
    product\" = products[[1]])\n}\n", "\n  sapply(numbers, function(x) {\n    c(sum\
    \ = sum(x), product = prod(x))\n  })\n}\n</cell>\n<cell>", "\n  results <- numeric()\n\
    \  results <- c(results, sum(numbers))\n  results <- c(results, prod(numbers))\n\
    \  return(results)\n}\n", "\n  # Return vector with sum of numbers and product\
    \ of numbers\n  # For empty numbers, sum and product should be equal to 0\n  \n\
    \  # Check for empty numbers\n  if(length(numbers) <= 0) {\n    return(c(sum =\
    \ 0, product = 1))\n  }\n  \n  # Return vector with sum and product of numbers,\
    \ starting from the first number\n  # For empty numbers, sum and product should\
    \ be equal to 0\n  \n  # Set initial values for sum and product to 0 and 1\n \
    \ \n  sum_product <- c(sum = 0, product = 1)\n  \n  # For each number in the vector\
    \ numbers \n  for(i in seq_along(numbers)) {\n    \n    # Add the current number\
    \ to sum\n    sum_product$sum += numbers[i]\n    \n    # Multiply the current\
    \ number by product\n    sum_product$product *= numbers[i]\n  }\n  \n  # Return\
    \ sum and product\n  return(sum_product)\n}\n", "\n  numbers <- sort(numbers)\n\
    \  \n  sum(numbers)\n  prod(numbers)\n}\n", "\n  if (length(numbers) <= 0)\n \
    \   stop(\"You need to give a list\")\n  else {\n    sum_number <- 0\n    prod_number\
    \ <- 1\n    for (number in numbers) {\n      sum_number <- sum_number + number\n\
    \      prod_number <- prod_number * number\n    }\n    c(sum_number = sum_number,\
    \ prod_number = prod_number)\n  }\n}\n", "\n  if(length(numbers) == 0) {\n   \
    \ return(c(0, 1))\n  } else {\n    sum <- 0\n    product <- 1\n    for(i in seq_along(numbers))\
    \ {\n      sum <- sum + numbers[i]\n      product <- product * numbers[i]\n  \
    \  }\n    return(c(sum, product))\n  }\n}\n</cell>\n<cell>", "\n  if (length(numbers)\
    \ == 0) return(c(1, 1))\n  numbers <- sapply(numbers, as.integer)\n  return(list(sum\
    \ = sum(numbers), product = prod(numbers)))\n}\n</code>\nAnd now let's say we\
    \ want to find all possible combinations of size 4 from a vector with length 10.\n\
    <code>", "\n  ns <- length(numbers)\n  if (ns == 0)\n    return(list(0, 1))\n\n\
    \  sl <- c(numbers[1], 1)\n  sl <- append(sl, sapply(2:ns, function(x) numbers[x]))\n\
    \  return(list(sum(sl), prod(sl)))\n}\n</code>\n<|/ a |>\n<| c |>\nNice, I think\
    \ I've got a little more to learn with this. Thanks!\n<|/ c |>\n<| a |>\nUsing\
    \ a matrix may be a better option for this task. \nHere is an example which does\
    \ that using matrix multiplication: \n<code>\nn <- 10 # size of vector\nx <- 1:n\
    \ # initial vector\nm <- matrix(1:n^2, n, n) # matrix with x\n</code>\nThe product\
    \ of x and m is \n<code>\n> x%*%m\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\
    \ [,9] [,10]\n [1,]    1    2    3    4    5    6    7    8    9    10\n [2,]\
    \    2    4    6    8   10   12   14   16   18   20\n [3,]    3    6    9   12\
    \   15   18   21   24   27   30\n [4,]    4    8   12   16   20   24   28   32\
    \   36   40\n [5,]    5   10   15   20   25   30   35   40   45   50\n [6,]  \
    \  6   12   18   24   30   36   42   48   54   60\n [7,]    7   14   21   28 \
    \  35   42   49   56   63   70\n [8,]    8   16   24   32   40   48   56   64\
    \   72   80\n [9,]    9   18   27   36   45   54   63   72   81   90\n[10,]  \
    \ 10   20   30   40   50   60   70   80   90   100\n</code>\n<|/ a tags=r dscore=1\
    \ |>\n<| c |>\nThanks for this answer. I would have never thought to multiply\
    \ two vectors to give the sum and product of the numbers in each vector position.\
    \ Very nice!\n<|/ c |>\n<| a dscore=0 tags=r |>\nYou can use the following function\
    \ with purrr:\n<code>\nlibrary(purrr)\nlist_sum", "\n  numbers <- numbers[!is.na(numbers)]\
    \ # to remove NAs\n  numbers <- sort(numbers) # sort the numbers\n  if(length(numbers)==0)\
    \ { # empty sum/product should be equal 0 \n    return(c(0, 1)) \n  } else {\n\
    \    product_sum <- 1\n    for(i in 1:length(numbers)) { \n      product_sum <-\
    \ product_sum*numbers[i]\n    }\n    return(c(product_sum, product_sum))\n  }\n\
    }\n</code>\n<|/ a tags=r,dplyr,data.table,tidyverse dscore=1 |>\n<| c |>\nThis\
    \ is great! I realized that I actually had a question about it - how could I calculate\
    \ the mean?\n<|/ c |>\n<| c |>\n, `mean` is `sum(numbers)/length(numbers)` as\
    \ opposed to `sum(numbers)/prod(numbers)`.\n<|/ c |>\n<| a tags=r,dplyr,data.table,tidyverse\
    \ dscore=0 |>\nYou might want to start by checking out the following pages from\
    \ R for Data Science and R for Data Science:\nhttps://www.rstudio.com/wp-content/uploads/2015/09/r4ds-4-ch1-1.pdf\n\
    https://www.rstudio.com/wp-content/uploads/2015/09/r4ds-4-ch1-2.pdf\n<|/ a |>\n\
    <| a tags=r,dplyr,data.table,tidyverse |>\nA solution using dplyr, tidyr and purrr\
    \ packages:\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nnumbers <-\
    \ data.frame(numbers = c(1,2,3,4,5,6,7,8,9,10)) \nnumbers %>% \n  mutate(sum_product\
    \ = map_dbl(numbers, ~ .x * .x)) %>% \n  filter(sum_product > 0) %>% \n  summarise(sum_product\
    \ = sum(sum_product), \n            product_sum = prod(numbers)) \n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=r,dplyr,data.table,tidyverse |>\nI actually thought\
    \ of doing something similar, but I figured I would write a function first:\n\
    <code>\nmy_mean <- function(x) {\n  mean(x)\n}\n</code>\nI then wrote a simple\
    \ for loop inside of my_mean so that I could calculate any desired mean by calling\
    \ my_mean(c(1, 2, 3, 4, 5)) and my_mean(c(1, 2, 3, NA, NA)), etc. I then used\
    \ the apply function to run through the function and apply it to each number in\
    \ a vector\n<code>\napply(as.vector(numbers), 1, ", "\n  if (length(numbers) ==\
    \ 0) return(list())\n  else {\n    sum <- numbers[[1]]\n    product <- 1\n   \
    \ for (i in 2:length(numbers)) {\n      sum <- sum + numbers[[i]]\n      product\
    \ <- product * numbers[[i]]\n    }\n    return(list(sum=sum, product=product))\n\
    \  }\n}\n</cell>\n<code language=julia-1.5>", "\n    result <- c(sum=0, product=1)\n\
    \    for(i in seq_along(numbers)) {\n        result$sum <- result$sum + numbers[i]\n\
    \        result$product <- result$product * numbers[i]\n    }\n    result\n}\n\
    \n</code>\n<|/ a |>\n<| c |>\nA variation of this is to use `reduce` from the\
    \ `purrr` package.\n<|/ c |>\n<| a tags=algorithm,r dscore=1 |>\nHere's an implementation\
    \ using R's built-in capabilities:\n<code>\nsum_product <- function(numbers) {\n\
    \  numbers <- c(numbers)\n  sum(numbers) * prod(numbers)\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI like your solution, but it is just an implementation and not the optimal\
    \ solution for my problem.\n<|/ c |>\n<| a dscore=1 |>\nAs others have said, using\
    \ vector recycling is a nice and simple solution. However, if you really want\
    \ to use a loop for some reason, and you want to avoid vectorization, then here's\
    \ my take on it:\n<code>\nsum_product <- function(numbers) {\n  numbers <- numbers[!is.na(numbers)]\
    \ \n  s <- 0\n  p <- 1\n  for (i in seq_along(numbers)) {\n    s += numbers[i]\n\
    \    p *= numbers[i]\n  }\n  c(sum=s, product=p)\n}\n\nsum_product(numbers=c(NA,2,3,4))",
  "\n  if (length(numbers) == 0) return(list(0, 1)) \n  sum(numbers) \n}\n", "\n \
    \   numbers_sum <- sum(numbers)\n    numbers_product <- prod(numbers)\n    list(numbers_sum,\
    \ numbers_product)\n}\n</cell>\n<text>\nThe sum and product functions are extremely\
    \ useful for computing simple summaries of data.  We'll look at more complicated\
    \ versions later.\n\nFirst, let's look at some simple vectorized functions:\n\n\
    \n</text>\n<cell>", "\n  numbers <- sort(numbers)\n  sum <- numbers[1]\n  product\
    \ <- 1\n\n  for (i in 2:length(numbers)) {\n    sum <- sum + numbers[i]\n    product\
    \ <- product * numbers[i]\n  }\n\n  c(sum, product)\n}\n</code>\nI tried to vectorize\
    \ the for loop using R built in vectorization, but it didn't work:\n<code>", "\n\
    \  s <- sum(numbers)\n  product <- prod(numbers)\n  c(s, product)\n}\n</cell>\n\
    <text>\nWe have defined our sum_product function below. We have also defined the\
    \ function sum, which is a built-in function that calculates the sum of integers.\
    \ And we also have defined the function prod, which is a built-in function that\
    \ calculates the product of integers. We also have defined our c function, which\
    \ is a function that returns a vector consisting of the sum and the product of\
    \ all the numbers in a vector. Our sum_product function takes any number of integers\
    \ and returns a vector consisting of the sum and the product of all the integers.\
    \ The function sum_product is also the function that calculates the mean and standard\
    \ deviation of any number of integers. Our sum_product function takes any number\
    \ of integers and returns a vector consisting of the sum and the product of all\
    \ the integers. The function sum_product is also the function that calculates\
    \ the mean and standard deviation of any number of integers. Our sum_product function\
    \ takes any number of integers and returns a vector consisting of the sum and\
    \ the product of all the integers. The function sum_product is also the function\
    \ that calculates the mean and standard deviation of any number of integers. Our\
    \ sum_product function takes any number of integers and returns a vector consisting\
    \ of the sum and the product of all the integers. The function sum_product is\
    \ also the function that calculates the mean and standard deviation of any number\
    \ of integers.\n\nExercise: Write a function called mean_product which calculates\
    \ the mean product of a list of numbers. Your function should take in a vector\
    \ of integers and return a numeric vector.\n\nHint: You can do these calculations\
    \ by summing the product of all the numbers in the vector and then dividing by\
    \ the length of the vector. For example, to calculate the mean product of a list\
    \ of integers we would do the following:\n\n\n</text>\n<cell>\nmean_product <-\
    \ function(numbers) {\n  s <- sum(numbers)\n  product <- prod(numbers)\n  mean(product/length(numbers))\n\
    }\n</cell>\n<text>\nExercise: Write a function called standard_deviation which\
    \ calculates the standard deviation of a list of numbers.\n\n\n</text>\n<cell>\n\
    standard_deviation <- function(numbers) {\n  s <- sum(numbers)\n  product <- prod(numbers)\n\
    \  sqrt(s/(length(numbers)-1))\n}\n</cell>\n<text>\nExercise: Write a function\
    \ called std_deviation which calculates the standard deviation of a list of numbers.\n\
    \n\n</text>\n<cell>\nstd_deviation <- function(numbers) {\n  s <- sum(numbers)\n\
    \  product <- prod(numbers)\n  sqrt(s/(length(numbers)-1))\n}\n</cell>\n<text>\n\
    Exercise: Write a function called std_deviation which calculates the standard\
    \ deviation of a list of numbers.\n\n\n</text>\n<cell>\nstd_deviation <- function(numbers)\
    \ {\n  s ", "\n  numbers <- as.numeric(numbers)\n  if(length(numbers) == 0) {\n\
    \    return(c(NA, 1))\n  }\n  else return(list(c(sum(numbers), prod(numbers))))\n\
    }\n", "\n  if(!is.list(numbers)) stop(\"numbers must be a list\")\n  if(length(numbers)\
    \ <= 0) stop(\"numbers list is empty\")\n  \n  sum <- 0\n  product <- 1\n  \n\
    \  for(i in 1:length(numbers)) {\n    sum <- sum + numbers[i]\n    product <-\
    \ product * numbers[i]\n  }\n  \n  c(sum, product)\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis isn't quite what I'm after. I need to add them together as one, but\
    \ multiply them by each other and their product together.\n<|/ c |>\n<| c |>\n\
    Ah I see! I'll see if I can get it working properly this afternoon. I'm currently\
    \ on my phone.\n<|/ c |>\n<| c |>\nOkay I thought you only wanted the sum and\
    \ product. I'll try to come up with a solution that will do what you want.\n<|/\
    \ c |>\n<| c |>\nOkay so I added some comments to my code. Let me know if that\
    \ makes sense to you!\n<|/ c |>\n<| c |>\nIt helps very much! The only problem\
    \ is that the list will contain multiple vectors, for example `c(1,2,3)` then\
    \ `c(4,5,6)` and so on. So I need a way to only take the sum of the vectors in\
    \ the list and not the vectors themselves. Do you think that's possible? Or will\
    \ it require a different approach?\n<|/ c |>\n<| a dscore=0 tags=for-loop,r,list,vector\
    \ |>\nThis solution uses Reduce and split. Split splits the input list into lists\
    \ by the given element (here it is 'num'), and Reduce will then apply the function\
    \ 'f' on the elements of each list to generate a vector of the output values.\
    \ \n<code>\nf <- function(x,y) x[1] + y[1]\noutput <- Reduce(function(a,b) f(a,b),\
    \ split(x,num))\n</code>\nThe output variable is then a vector of the sums you\
    \ are looking for.\n<|/ a |>\n<| a tags=for-loop,r,list,vector |>\nI wrote a function\
    \ that does what you want:\n<code>\nx <- list(c(1,2,3), c(4,5,6))\nsx <- unlist(x)\n\
    n <- length(sx)\n\nsy <- c(sx)\nfor (i in 1:(n-1)) {\n  sy[i] <- sx[i] + sx[i+1]\n\
    }\nsy <- c(sx, sy)\nfor (i in 2:n) {\n  sy[i] <- sx[i] * sy[i-1]\n", "\n    numbers\
    \ %>%\n        map(c(1, )) %>%\n        map_df(function(x, i) {\n            data.frame(sum\
    \ = sum(x), product = prod(x), row = i)\n        }) %>%\n        arrange(desc(product))\n\
    }\n</cell>\n<text>\nEjercicio 1\nA\xF1ade una funci\xF3n que tome como argumentos\
    \ un tipo de dato vectorial y devuelva un tipo de dato vector.\n\nEn el ejemplo\
    \ siguiente, los vectores de enteros que se deben calcular son los siguientes:\n\
    \nc(1, 2, 3, 4)\nc(5, 6, 7, 8)\nc(9, 10, 11, 12)\n\nOJO: la funci\xF3n debe recibir\
    \ un vector de enteros y devuelve un vector de enteros y no una funci\xF3n.\n\n\
    \n</text>\n<cell>", "\n    if (length(numbers) == 0) {\n        return(c(sum =\
    \ 0, product = 1))\n    }\n    s <- sum(numbers)\n    p <- prod(numbers)\n   \
    \ return(c(sum = s, product = p))\n}\n\n</cell>\n<cell>", "\n  if (lengths(numbers)\
    \ == 0) return(c(0, 1))\n  numbers <- sort(numbers)\n  numbers <- numbers[2:lengths(numbers)]\n\
    \  list(sum = sum(numbers), product = prod(numbers))\n}\n", "\n  numbers %>% \n\
    \    sapply(function(x) x[1] + x[1]*x[2] ) %>% \n    c(0,1)\n}\n</code>\nThe function\
    \ works as follows:\n\nsapply(numbers, function(x)) takes the list numbers as\
    \ input and passes one item at a time to the function given to sapply(). This\
    \ function x is each element in the list.\nsapply() returns a named vector with\
    \ the sum and product of each element in the input list.\nsapply() returns a list\
    \ with the sum and product of each element in the input list.\nc(0,1) returns\
    \ the vector c(0,1) as a list. The list can be thought of as a tuple of two vectors\
    \ c(0,1), where the first vector contains the sums and the second vector contains\
    \ the products.\n<|/ a |>\n<| a |>\nMy solution using purrr::reduce()\n<code>\n\
    reduce(list(c(1,2,3), c(2,3,4), c(3,3,4)), \n        function(x,y) c(y[1], y[2]),\
    \ \n        init=c(0,1))\n[1] 0 1\n</code>\n<|/ a dscore=4 tags=r,list |>\n<|\
    \ a tags=r,list |>\n<code>", "\n  \n  numbers <- list(numbers)\n  \n  if (length(numbers)\
    \ == 1) {\n    \n    list(sum = 0, product = 1)\n  }\n  else {\n    \n    lapply(seq_along(numbers),\
    \ function(i) {\n      \n      a <- numbers[[i]]\n      \n      list(sum = sum(a),\
    \ product = prod(a))\n    })\n  }\n}\n", "\n  return(list(sum = sum(numbers),\
    \ product = prod(numbers)))\n}\n</cell>\n<cell>\nsum_product(c(1, 2, 3))\n</cell>\n\
    <text>\nWe can also use dplyr to do some data manipulation.\n\nFirst we can use\
    \ mutate to add a column to our dataframe consisting of the sum of the values\
    \ from the price column in our dataframe (using the sum() function).\n\n\n</text>\n\
    <cell>\nlibrary(dplyr)\n\ndata_new <- mutate(data, new_price = sum(price))\n</cell>\n\
    <cell>\ndata_new\n</cell>\n<text>\nNow we can use group_by to group by the month\
    \ of the year. We can then use summarise to compute the sum and product of the\
    \ values in the new_price column.\n\n\n</text>\n<cell>\ndata_new <- mutate(data,\
    \ new_price = sum(price)) %>%\n  group_by(month) %>%\n  summarise(new_price =\
    \ sum(new_price),\n            new_price_product = prod(new_price))\n\ndata_new\n\
    </cell>\n<text>\nWe can also use summarise to compute both the sum and product\
    \ of the values in the new_price column for each month.\n\n\n</text>\n<cell>\n\
    data_new <- mutate(data, new_price = sum(price)) %>%\n  group_by(month) %>%\n\
    \  summarise(new_price = sum(new_price),\n            new_price_product = prod(new_price))\
    \ %>%\n  ungroup()\n\ndata_new\n</cell>\n<text>\nThe %>% operator lets us chain\
    \ our commands using the pipe (|) character. For example\n\ndata_new <- mutate(data,\
    \ new_price = sum(price)) %>%\n  group_by(month) %>%\n  summarise(new_price =\
    \ sum(new_price),\n            new_price_product = prod(new_price)) %>%\n  ungroup()\n\
    \n\nis a way of writing our first dplyr pipe.\n\n\n</text>\n<text>\nGrouping Data\n\
    We can also group our data by any column that we want.\n\n\n</text>\n<cell>\n\
    data_new <- mutate(data, new_price = sum(price)) %>%\n  group_by(month) %>%\n\
    \  summarise(new_price = sum(new_price),\n            new_price_product = prod(new_price))\
    \ %>%\n  ungroup()\n\ndata_new\n</cell>\n<text>\nA great place to start with dplyr\
    \ is to read an introduction to R's tidyverse package.\n\nThis package is useful\
    \ for manipulating data frames. We will walk through some of the basic functions\
    \ we will use below.\n\nFor now let's just do some exploration of the data.\n\n\
    \n</text>\n<text>\nLooking at Data\nWe can look at the first few rows of ", "\n\
    \  # initialize empty list\n  sum <- NULL\n  product <- NULL\n\n  # loop through\
    \ each number\n  for (n in numbers) {\n\n    # create sum and product accumulators\n\
    \    sum_accumulator <- 0\n    product_accumulator <- 1\n\n    # create new sum\
    \ and product accumulators depending on n\n    n <- if (n > 0) {\n      sum <-\
    \ append(sum, sum_accumulator + n)\n      product <- append(product, product_accumulator\
    \ * n)\n    }\n\n    # create new sum and product accumulators depending on -n\n\
    \    n <- if (n < 0) {\n      sum <- append(sum, -sum_accumulator + n)\n     \
    \ product <- append(product, -product_accumulator * n)\n    }\n  }\n\n  # return\
    \ the list consisting of the sum and product\n  return(list(sum, product))\n}\n\
    </cell>\n<text>\n(OPTIONAL) Exercises\nTry your function on the example below.\
    \ As you add more examples, feel free to include more cases to try out your function.\n\
    Your function should also work for vectors (like c(1, 2, 3) or c(1,-2,-3)).\n\n\
    \n</text>\n<cell>", "\n  if (length(numbers) == 0) return(list())\n  sum <- 0\n\
    \  product <- 1\n  for (i in numbers) {\n    sum <- sum + i\n    product <- product\
    \ * i\n  }\n  return(list(sum = sum, product = product))\n}\n</cell>\n<cell>\n\
    sum_product(c(1, 2, 3, 4))\n</cell>\n<text>\nWe will now define a function which\
    \ takes a list of numbers and returns their sum raised to the power of an exponent.\n\
    \n\n</text>\n<cell>", "\n  n <- length(numbers)\n  if(is.null(numbers)) stop(\"\
    The list cannot be empty!\")\n  if(n <= 1) c(numbers, 1)\n  else {\n    c(numbers[seq(1,\
    \ n)], numbers[seq(1, n-1, -1)]*numbers[seq(2, n)]) }\n}\n", "\n  sum(numbers)\
    \ * ( prod(numbers) - 1 )\n}\n</cell>\n<cell>", "\n  number_list <- unlist(numbers)\n\
    \  number_list <- as.numeric(number_list)\n  if(length(numbers) == 0) {\n    return(c(0,1))\n\
    \  } else {\n    return(c(sum(number_list), prod(number_list)))\n  }\n}\n", "\n\
    \    if (length(numbers) == 0) return(c(0, 1))\n    numbers <- sort(numbers)\n\
    \    sum_ <- 0\n    product_ <- 1\n    for (num in numbers) {\n        sum_ <-\
    \ sum_ + num\n        product_ <- product_ * num\n    }\n    c((sum_, product_))\n\
    }\n</code>\n<|/ a dscore=4 tags=vector,r,mathematical-optimization,sum |>\n<|\
    \ c |>\nThis seems like a great solution, but it is giving me the following error\
    \ when used on a vector of size 50000:\n\n    Error in optim(par = 0.0, fn = sumProduct,\
    \ hessian = TRUE, method = optim.method, hessian =\n    TRUE, ...) : non-finite\
    \ function value\n<|/ c |>\n<| c |>\nI added a line to handle vectors of length\
    \ 0.\n<|/ c |>\n<| c |>\n`sumProduct(c())` gives an error and `sumProduct(c(1,2))`\
    \ gives a sum of 1.\n<|/ c |>\n<| c |>\nAh I see. Thank you for the clarification.\
    \ I missed this in my answer. I will edit my answer.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's another idea, using mapply to iteratively sum each vector in the\
    \ list, and return the product.  Note that this will return a vector of the same\
    \ length as the number of items in each list.  I used the code below to test it\
    \ out.\n<code>", "\n  \n  # Base case\n  if(length(numbers) == 0) return(list(1,\
    \ 1))\n  \n  # Recursive case\n  \n  # Compute the sum and product\n  sum = numbers[[1]]\n\
    \  product = 1\n  for (i in seq_along(numbers)) {\n    sum = sum + numbers[[i]]\n\
    \    product = product * numbers[[i]]\n  }\n  \n  # Return the answer\n  return(list(sum,\
    \ product))\n}\n</cell>\n<code language=conda-root-py>\nsum_product(c(1, 2, 3,\
    \ 4, 5))\n</cell>\n<code language=conda-root-py>", "\n  numbers <- as.numeric(numbers)\n\
    \  return(list(sum = sum(numbers), product = prod(numbers)))\n}\n", "\n  if (length(numbers)\
    \ == 0) return(NULL)\n  numbers <- as.list(numbers)\n  numbers <- c(numbers, 0)\n\
    \  numbers <- sapply(numbers, function(x){x * numbers[1]})\n  numbers <- c(numbers,\
    \ 1)\n  return(list(sum = sum(numbers), product = prod(numbers)))\n}\n", "\n \
    \ return(list(sum = sum(numbers), product = prod(numbers)))\n}\n", "\n  numbers\
    \ <- sort(numbers)\n  sum(numbers)\n  prod(numbers)\n}\n\n</cell>\n<cell>", "\n\
    \  numbers <- sort(numbers)\n  if (lengths(numbers) == 0) return(list(sum = NA,\
    \ product = NA))\n  sum(numbers) # Sum\n  prod(numbers) # Product\n}\n", "\n \
    \ numbers <- as.list(numbers)\n  sum(numbers)\n  prod(numbers)\n}\n", "\n  numbers\
    \ %>% \n    sapply(sum) %>% \n    sapply(prod)\n}\n</cell>\n<text>\nUsing a list\n\
    \n\n</text>\n<cell>", "\n  if(lengths(numbers)[2] == 0) {\n    list(sum(numbers),\
    \ prod(numbers))\n  } else {\n    list(sum(numbers[[1]]), prod(numbers[[1]]))\n\
    \  }\n}\n", "\n  if (length(numbers) == 0) {\n    return(list(sum = 0, product\
    \ = 1))\n  } else if (length(numbers) == 1) {\n    return(list(sum = numbers[1],\
    \ product = 1))\n  }\n\n  sum <- numbers[1]\n  product <- 1\n  \n  for (i in 2:length(numbers))\
    \ {\n    product <- product * numbers[i]\n    sum <- sum + numbers[i]\n  }\n \
    \ return(list(sum = sum, product = product))\n}\n", "\n  if(length(numbers) ==\
    \ 0)\n    c(0,1)\n  else {\n    sum <- 0\n    product <- 1\n    for(number in\
    \ numbers)\n      sum <- sum + number\n    for(number in numbers)\n      product\
    \ <- product * number\n    c(sum, product)\n  }\n}\n</code>\nThe sum_product function\
    \ could be made shorter in R, but it would make me want to give it some thought.\n\
    <|/ a tags=r |>\n<| c |>\nNice use of recursion!\n<|/ c |>\n<| a dscore=3 tags=r\
    \ |>\nTo find product of integers in a vector, use Reduce:\n<code>\nReduce(`*`,\
    \ 1:5)\n</code>\n<|/ a |>\n<| a |>\nAnother approach using purrr::reduce:\n<code>\n\
    library(purrr)\n\nnumbers = list(1,2,3,4,5)\nreduce(numbers, `*`)\n[1] 120\n</code>\n\
    <|/ a tags=r dscore=3 |>\n<| a dscore=3 tags=r |>\nI know this question has been\
    \ answered, but I felt this was a fun challenge anyway.\nYou can use nested lapply\
    \ to solve this for both sum and product.\n<code>\na <- c(10,20,30,40,50)\n",
  "\n  if (length(numbers) == 0) return(list(\"sum\" = 0, \"product\" = 1))\n  numbers\
    \ <- sort(numbers)\n  return(list(\"sum\" = sum(numbers), \"product\" = prod(numbers)))\n\
    }\n</code>\n<|/ a tags=r |>\n<| a |>\n<code>\nsum_product <- function(numbers)\
    \ {\n  if (length(numbers) <= 1) return(list(\"sum\" = 0, \"product\" = 1))\n\
    \  numbers <- sort(numbers)\n  return(list(\"sum\" = sum(numbers), \"product\"\
    \ = prod(numbers)))\n}\n\nsum_product(c())", "\n  if (is.null(numbers) || length(numbers)\
    \ == 0) {\n    return(list(1, 1))\n  }\n  else {\n    sum_number <- 0\n    product_number\
    \ <- 1\n    for (number in numbers) {\n      sum_number <- sum_number + number\n\
    \      product_number <- product_number * number\n    }\n    return(list(sum_number,\
    \ product_number))\n  }\n}\n", "\n  return(list(sum(numbers), prod(numbers)))\n\
    }\n</cell>\n<cell>", "\n  \n  product <- 1\n  sum <- 0\n  \n  for (i in numbers)\
    \ {\n    sum = sum + i\n    product = product * i\n  }\n  return(c(sum, product))\n\
    }\n", "\n  numbers <- list(numbers)\n  return(\n    c(sum(numbers), prod(numbers))\n\
    \  )\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
