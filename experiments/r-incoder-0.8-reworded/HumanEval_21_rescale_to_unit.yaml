name: HumanEval_21_rescale_to_unit
language: r
prompt: "# Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n# such that the smallest number will become 0 and the largest will\
  \ become 1\n# >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n# c(0.0, 0.25, 0.5,\
  \ 0.75, 1.0)\nrescale_to_unit <- function(numbers) {"
tests: "test_humaneval <- function() {\ncandidate <- rescale_to_unit\n    if(!identical(candidate(c(2.0,\
  \ 49.9)), c(0.0, 1.0))){quit('no', 1)}\n    if(!identical(candidate(c(100.0, 49.9)),\
  \ c(1.0, 0.0))){quit('no', 1)}\n    if(!identical(candidate(c(1.0, 2.0, 3.0, 4.0,\
  \ 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))){quit('no', 1)}\n    if(!identical(candidate(c(2.0,\
  \ 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))){quit('no', 1)}\n    if(!identical(candidate(c(12.0,\
  \ 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  numbers <- sort(numbers)\n  numbers <- numbers[order(numbers)]\n\
    \  numbers[length(numbers)] <- 1\n  numbers[numbers == 0] <- 0\n  numbers\n}\n",
  "\n  if (length(numbers) < 2) {\n    return(numbers)\n  }\n  min <- numbers[1]\n\
    \  max <- numbers[-1]\n  min <- min - min(min) * min\n  max <- max + max(max)\
    \ * max\n  range(numbers) <- c(min, max)\n  numbers[numbers > 1 ] <- 1\n  numbers[numbers\
    \ < 0] <- 0\n  return(numbers)\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    You can use dplyr's group_by and summarise to accomplish your goal. Here is an\
    \ example:\n<code>\nlibrary(dplyr)\n\ndf1 <- data.frame(x=c(0,1,2,3),\n      \
    \            y=c(4,3,2,1),\n                  z=c(2,3,1,0))\n\ndf2 <- data.frame(x=c(2,3),\n\
    \                  y=c(2,3))\n\ndf1 %>%\n  group_by(x) %>%\n  summarise(y=mean(c(y)),\n\
    \            z=mean(c(z)))\n", "\n    x <- min(numbers)\n    numbers <- numbers\
    \ - x\n    numbers <- numbers/max(numbers)\n    numbers <- c(x, numbers)\n}\n\
    </code>\nI hope you find this helpful!\n<|/ a tags=probability-distribution,r,probability,probability-theory,random\
    \ |>\n<| a tags=probability-distribution,r,probability,probability-theory,random\
    \ |>\nYou want to sample from your uniform distribution and then divide by its\
    \ maximum.\n<code>\nrnorm(10)/10\n</code>\nThe results are in the range 0 to 1.\n\
    <|/ a dscore=1 |>\n<| c |>\nWhat do you mean? The normal distribution is what\
    \ `rnorm` generates. `rnorm` generates normally distributed random variables.\n\
    <|/ c |>\n<| c |>\nrnorm generates random numbers from a normal distribution.\
    \ OP wants uniform distribution random variables. If you look at his question,\
    \ they already have a normal distribution random variable.\n<|/ c |>\n<| a tags=probability-distribution,r,probability,probability-theory,random\
    \ |>\nThe distribution is \"uniform\" because your maximum value is 1.\nIf you\
    \ generate numbers from rnorm(), then divide the result by its maximum value,\
    \ then the distribution will be uniform again. However, if you generate numbers\
    \ from a normal distribution, then the distribution will be normal. \nExample:\n\
    <code>\n> set.seed(10)\n> rnorm(10)\n[1] -0.302025  0.676432  1.530442  2.740301\
    \  1.949069  1.398196  2.739485  1.995725\n[10] -0.619747\n> rnorm(10) / 10\n\
    \ [1]   0   0.1 -0.2 -0.3 -0.4 -0.5 -0.6 -0.7 -0.8 -0.9 -1.0\n</code>\nNow let's\
    \ generate a normal distribution random variable and see what it looks like:\n\
    <code>\n> set.seed(10)\n> rnorm(10) / 10\n [1]   0   0.1 -0.2 -0.3 -0.4 -0.5 -0.6\
    \ -0.7 -0.8 -0.9 -1.0\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy did you choose\
    \ 10? Wouldn't it be better to choose a number less than the desired standard\
    \ deviation?\n<|/ c |>\n<| c |>\n, no it doesn't matter. Whatever number you choose\
    \ would not matter. The idea is that you should keep the number of samples to\
    \ the minimum required to see the distribution to converge to the desired distribution.\n\
    <|/ c |>\n<| c |>\nBut if you choose a number less than the standard deviation, ",
  "\n  numbers <- sort(numbers)\n  numbers_sorted <- sort(unique(numbers))\n  number\
    \ <- numbers_sorted[1]\n  x_min <- min(numbers[numbers == number])\n  x_max <-\
    \ max(numbers[numbers == number])\n  y <- x_min + (x_max - x_min) * (number -\
    \ min(numbers))\n  return(y)\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks,\
    \ I like this function!\n<|/ c |>\n<| c |>\nI edited a little bit to make the\
    \ function more accurate if the numbers are non-negative.\n<|/ c |>\n<| c |>\n\
    Thanks for the edit. I'd suggest using `numbers[numbers == number]` instead of\
    \ `which(numbers == number)` because it allows vectorization and will be a bit\
    \ faster.\n<|/ c |>\n<| c |>\nThis is great but what does the `unique` do? How\
    \ does it know not to pick the same number twice?\n<|/ c |>\n<| c |>\n`unique()`\
    \ removes duplicates from vectors.\n<|/ c |>\n<| a tags=r,scale,function |>\n\
    Here's an attempt at extending the function in the previous answers to allow for\
    \ non-negative numbers.  It will also return a vector of the same length as the\
    \ numbers vector if that's what is desired.  Note that I changed the argument\
    \ name from numbers to vector.\n<code>\nrescale_to_unit <- function(vector) {\n\
    \    numbers_sorted <- sort(unique(numbers))\n    number <- numbers_sorted[1]\n\
    \    x_min <- min(number[numbers == number])\n    x_max <- max(number[numbers\
    \ == number])\n    y <- x_min + (x_max - x_min) * (number - min(numbers))\n  \
    \  return(y)\n}\n</code>\n<|/ a dscore=5 |>\n<| a |>\nHere is my solution which\
    \ works quite nicely for me:\n<code>\nrescale_to_unit <- function(numbers){\n\
    \  numbers <- sort(numbers)\n  min <- min(numbers)\n  max <- max(numbers)\n  numbers\
    \ <- numbers - min # We need to shift the numbers so they start from zero\n  numbers\
    \ <- numbers / max\n  numbers <- numbers * max - min\n  numbers <- numbers + min\n\
    \  return(numbers)\n}\n</code>\n<|/ a dscore=5 tags=r,scale,function |>\n<| c\
    \ |>\nThis is not good: `rescale_to_unit(c(1,2,3,4,5,6,7,8,9,10))` gives 7.5 and\
    \ `rescale_to_unit(c(1,2,3,4,5,6,7,", "\n  if(length(x = numbers[[1]])) return(numbers)\n\
    \  return(ifelse(numbers[[1]] < 0, 0,\n                 ifelse(numbers[[1]] >\
    \ 1, 1,\n                        numbers[[1]]))\n  )\n}\n", "\n  numbers <- sort(numbers)\n\
    \  c((numbers[1] - min(numbers))/(max(numbers) - min(numbers)), numbers[-1])\n\
    }\n", "\n  if (length(numbers) < 2) stop(\"The input list must have at least two\
    \ elements\")\n  max_number <- max(numbers)\n  min_number <- min(numbers)\n  min_number\
    \ - max_number\n}\n", "\n  numbers[numbers < max(numbers)]\n}\n", "\n  numbers\
    \ <- sort(numbers)\n  min <- numbers[1]\n  range <- diff(numbers)\n  return((numbers\
    \ - min) / range)\n}\n", "\n  # Get the numbers' absolute values\n  abs <- abs(numbers)\n\
    \  # Find the minimum and maximum absolute values of the given numbers\n  min_abs\
    \ <- min(abs)\n  max_abs <- max(abs)\n  # Calculate the number of zeroes we need\n\
    \  zeros <- ceiling(max_abs - min_abs)\n  # Find the numbers' values by multiplying\
    \ the absolute numbers by (max_abs - min_abs)/max_abs\n  numbers <- numbers *\
    \ max_abs - min_abs / max_abs\n  # Multiply the original numbers by the new scale\
    \ factor\n  numbers <- numbers * scale_factor - min_abs\n  # Rescale the numbers\n\
    \  numbers <- numbers / zeros + min_abs\n  # Return the rescaled numbers\n  return(numbers)\n\
    }\n", "\n  if (length(numbers) < 2) {\n    return(numbers)\n  }\n  # first find\
    \ the highest and lowest number\n  min_number <- min(numbers)\n  max_number <-\
    \ max(numbers)\n  # now rescale all the numbers to interval [0, 1]\n  rescaled_numbers\
    \ <- numbers - min_number\n  rescaled_numbers <- (rescaled_numbers / max_number)\
    \ * 0.5 + 0.5\n  return(rescaled_numbers)\n}\n", "\n  stopifnot(length(na.omit(numbers))\
    \ > 1)\n  numbers <- na.omit(numbers)\n  numbers <- numbers / min(numbers)\n \
    \ numbers <- numbers * max(numbers)\n  numbers\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=r |>\nA simple way is to compute cumsum and divide each element of the\
    \ vector by the sum of cumsum and then multiply it by the first element of the\
    \ vector.\n<code>\nx <- c(.5,.2,.1,.2,.8,.3,.2)\ncumsum(x) * x[1]", "\n  min_number\
    \ <- min(numbers)\n  max_number <- max(numbers)\n  rescaled_numbers <- scale(numbers)\n\
    \  rescaled_numbers[rescaled_numbers > max_number] <- max_number\n  rescaled_numbers[rescaled_numbers\
    \ < (min_number - 1)] <- min_number - 1\n  rescaled_numbers\n}\n", "\n  min <-\
    \ min(c(numbers))\n  max <- max(c(numbers))\n  rescaled_numbers <- numbers/max(numbers)\n\
    \  rescaled_numbers[is.na(rescaled_numbers)] <- 0\n  rescaled_numbers[rescaled_numbers\
    \ <= 0] <- 0\n  rescaled_numbers[rescaled_numbers >= 1] <- 1\n  rescaled_numbers\
    \ * (max - min) + min\n}\n</cell>\n<cell>", "\n  numbers <- sort(numbers)\n  minimum.point\
    \ <- min(numbers)\n  maximum.point <- max(numbers)\n  range.from.minimum <- maximum.point\
    \ - minimum.point\n  range.from.minimum.floored <- floor(range.from.minimum)\n\
    \  rescaled.range <- maximum.point - range.from.minimum.floored\n  rescaled.range\
    \ / minimum.point\n}\n", "\n  numbers <- sort(numbers, index.return=T)\n  return(numbers\
    \ - numbers[length(numbers)])\n}\n", "\n  numbers <- sort(numbers)\n  min <- min(numbers)\n\
    \  max <- max(numbers)\n  c(0, numbers/max) - min\n}\n", "\n  # First, find the\
    \ minimum and the maximum\n  min.max <- c(min(c(numbers[[1]], numbers[length(numbers)])))\n\
    \  # Now, get the difference between the min and max\n  diff <- min.max - c(numbers[[1]],\
    \ numbers[length(numbers)])\n\n  # Now create the new scale (which should be the\
    \ min divided by the diff of the max and min)\n  # Also add a little bit of extra\
    \ for rounding\n  min <- diff[1]/10\n  max <- diff[2]/10\n  scale(numbers) <-\
    \ seq(min, 0, max) \n  scale\n\n}\n</code>\n<|/ a |>\n<| c |>\nThis works well\
    \ for numbers less than 1, but doesn't work for numbers that are greater than\
    \ 1\n<|/ c |>\n<| a dscore=4 |>\nI prefer a solution using base graphics:\n<code>\n\
    myfun <- function(x) {\n  plot(0:1, 0:1, type=\"n\")\n  plot(1:length(x), x, type=\"\
    l\")\n}\n\nmyfun(seq(0,4,0.1))\n</code>\n<|/ a tags=plot,r |>\n<| c |>\n+1. Note\
    \ that `type=\"n\"` gives you a black plot area with no axis ticks and no title.\
    \ To get that, you could use either `plot.new()` or `plot(NA,NA,type=\"n\")` (both\
    \ of which will set `xlab=\"\"` and `ylab=\"\"`). To get the labels, use `xlab(NULL)`\
    \ and `ylab(NULL)`. To get no axes, use `axis(side=4)`. See `?plot` for other\
    \ options.\n<|/ c |>\n<| a |>\nTry out package ggplot2\n<code>\ninstall.packages(\"\
    ggplot2\")\nlibrary(ggplot2)\n\nx = c(0.1,0.2,0.3)\ny = c(0.1,0.2,0.3)\nplot(x,y)\n\
    </code>\n<|/ a tags=plot,r dscore=4 |>\n<| c |>\nI don't think this is what the\
    \ OP wants. He wants to have it scale automatically.\n<|/ c |>\n<| a tags=plot,r\
    \ |>\nThis is now built into ggplot2: \n<code>\nmyplot <- function(x, y, ...)\
    \ {\n  require(ggplot2)\n  p = qplot(x,y,data=data.frame(x),geom=\"line\",ylab=y,xlab=x)\n\
    \  return(p)\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 |>\nTry this for base\
    \ graphics\n<code>\nplot(x = c(0,1,2,3), y = c(0,1,2,3), type=\"l\")\n</code>\n\
    <|/ a ", "\n  if (length(numbers) < 2) {\n    stop(\"Need at least two numbers\
    \ to rescale\")\n  }\n  if (all(numbers < 0)) {\n    stop(\"All numbers must be\
    \ positive\")\n  }\n  numbers <- sort(numbers)\n  max_number <- numbers[length(numbers)]\n\
    \  min_number <- numbers[1]\n  numbers <- seq(min_number, max_number, by = max_number\
    \ / length(numbers))\n  numbers[numbers < 0] <- 0.0\n  numbers[numbers > 1] <-\
    \ 1.0\n  numbers\n}\n", "\n  numbers <- sort(numbers)\n  numbers[numbers == min(numbers)]\
    \ <- 0\n  numbers[numbers == max(numbers)] <- 1\n  return(numbers)\n}\n", "\n\
    \  max_number <- max(numbers)\n  min_number <- min(numbers)\n  rescaled_numbers\
    \ <- numbers - min_number\n  rescaled_numbers / max_number\n}\n</code>\nAnd now:\n\
    <code>\n> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n  return(ifelse(numbers[1]\
    \ < numbers[2],\n                numbers[2] + (numbers[1]-numbers[2]) / length(numbers),\n\
    \                numbers[1] - (numbers[2]-numbers[1]) / length(numbers)))\n}\n\
    </code>\n<|/ a tags=r |>\n<| c |>\nThanks Martin! That works nicely. But it feels\
    \ ugly to have to specify the numbers in my function call in `rescale_to_unit`\
    \ when I have an arbitrary list of numbers. And I'd like to be able to scale the\
    \ whole vector at once, e.g. `rescale_to_unit(c(1.0, 2.0, 3.0))`. Is there a way\
    \ I can do that?\n<|/ c |>\n<| c |>\nThat's true. Thanks for your help with this,\
    \ Martin. I think I understand the problem better now.\n<|/ c |>\n<| c |>\nYou\
    \ might find it useful to use the `pmin` & `pmax` functions (`?pmin` `?pmax`)\
    \ to do this\n<|/ c |>\n<| c |>\n`rescale_to_unit <- function(numbers) {\n  return(numbers[1]\
    \ + (numbers[2] - numbers[1]) / length(numbers))\n}\nrescale_to_unit(c(1.0, 2.0,\
    \ 3.0))` produces `[1] 0.0 0.25 0.5 0.75 1.0` instead of `[1] 0.25 0.5 0.75 1.0`\n\
    <|/ c |>\n<| a tags=r dscore=0 |>\nHere's another option that will scale any vector\
    \ to [0;1] assuming that the length of the vector is even\n<code>\nrescale_to_unit\
    \ <- function(numbers) {\n  return(numbers[1] + (numbers[2] - numbers[1]) / length(numbers))\n\
    }\nrescale_to_unit(c(1.0, 2.0, 3.0))", "\n    len <- length(numbers)\n    rescaled\
    \ <- ifelse(len > 1, numbers[order(numbers)], 0)\n    rescaled / sum(rescaled)\n\
    }\n", "\n  min_ind = which.min(numbers)\n  max_ind = which.max(numbers)\n  return(numbers\
    \ - min_ind + 1 * (max_ind - min_ind))\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    I like your solution (+1). However I believe that `scale` function will produce\
    \ a slightly different results than `rescale_to_unit`. I think it would be better\
    \ to call `scale` only when the values are between `1` and `2`.\n<|/ c |>\n<|\
    \ c |>\nI think the function `scale` returns `0` when applied to `c(1,2,3,4,5)`.\
    \ However, if OP wants non-zero-mean values `scale` will return `1` when applied\
    \ to `c(1,2,3,4,5)`.\n<|/ c |>\n<| c |>\nOh yes, you are right. I'm sorry, I misread\
    \ your comment. Sorry about that.\n<|/ c |>\n<| a tags=r,statistics,standard-deviation,standard-error\
    \ |>\nI think you could do this with a function like this:\n<code>\nscale_mean\
    \ <- function(x, mean=mean(x)) {\n  if(mean(x) >= mean(x * 2)) {\n    mean(x)\
    \ <- mean(x * 2) - 1\n  }\n  return(x - mean(x))\n}\n</code>\nI used the if condition\
    \ because I don't think there's any way that R would use vectorization in this\
    \ function, which would make it very slow for large vectors.  \n<code>\n> x <-\
    \ c(1,2,3,4)\n> x\n[1] 1 2 3 4\n> scale_mean(x)\n[1] 0.375 0.375 0.375 0.375\n\
    > y <- c(1,3,2,4)\n> y\n[1] 1 2 3 4\n> scale_mean(y)\n[1] 1 2 3 4\n> z <- c(1,2,3,2,4)\n\
    > z\n[1] 1 2 3 2 4\n> scale_mean(z)\n[1] 1 2 3 2 4\n</code>\nThis would probably\
    \ work well enough for most uses, but I've not actually tested it on large vectors.\
    \ \nEDIT: I just tested the function on a bigger vector, and it seems to be working\
    \ for me so far, though I might have missed cases.  \nEDIT: I changed my function\
    \ to allow for non-integer inputs\n<|/ a dscore=5 |>\n<| c |>\nYes, you are right.\
    \ I am going to edit the answer to make that more clear.\n<|/ c |>\n<| c |>\n\
    I think this is better than my solution. I think `scale_mean` would return `Inf`\
    \ in many cases. I wonder if there is a ", "\n  rescaled_numbers <- numbers *\
    \ seq_along(numbers)\n  return(rescaled_numbers / sum(rescaled_numbers))\n}\n\n\
    rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n  numbers <- numbers[numbers\
    \ > 0]\n  min(numbers) / max(numbers)\n}\n</cell>\n<text>\nIn addition to rescaling\
    \ the values in the vector by some factor, we could also rescale them by some\
    \ arbitrary function; let's use a logarithmic transformation, which would convert\
    \ all numbers into the range $\\mathbb{R}$.\n\n$$\n\\large\n\\text{log}(x) = \\\
    frac{\\log_2(x)}{\\log_2(\\max(\\min(x,1))) - \\log_2(\\min(x,1))}\n$$\n\n(We\
    \ could also try other transformations like $\\mathcal{R}^{-1}$, etc.)\n\n\n</text>\n\
    <cell>", "\n  if (length(numbers) <= 1) return(numbers)\n\n  numbers <- sort(numbers)\n\
    \n  lower <- numbers[1]\n  upper <- numbers[length(numbers)]\n  lower_inclusive\
    \ <- TRUE\n\n  if(length(numbers) > 1) {\n    lower <- 0\n    lower <- numbers[length(numbers)-1]\n\
    \    lower_inclusive <- FALSE\n  }\n\n  upper <- 1.0\n  \n  return(\n    c(-upper,\n\
    \      lower,\n      (upper - lower) / (upper - lower),\n      upper,\n      1.0))\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=linear-interpolation,r |>\nYou can just\
    \ use linear interpolation. Take the min and max of your vector (in this example\
    \ it is c(0,1)) then find the midpoint of the vector (in this example it is (0.5,1)).\
    \ Now just interpolate between those midpoints.\n<code>\nmidpoint <- c(0.5,1)\n\
    midpoint\n\nx\n[1] 0.0 1.0 2.0 3.0 4.0 5.0\n\ny\n[1] 0.0 0.2 0.4 0.6 0.8 1.0\n\
    \napprox(x,y,midpoint)\n\n$x\n[1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0\n\n$y\n[1] 0.0 0.2\
    \ 0.4 0.6 0.8 1.0\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you, I was hoping\
    \ to avoid `approx`, but I'll use this to conduct some more testing and see how\
    \ well it works.\n<|/ c |>\n<| a |>\nI know this question was answered, but this\
    \ is what I've been using in practice for quite some time. Here it goes:\n<code>\n\
    rescale <- function(x, na.rm = FALSE) {\n  if(na.rm) {\n    x <- na.omit(x)\n\
    \  }\n\n  maxmin <- range(x, na.rm = na.rm)\n  if(maxmin[1] == maxmin[2]) {\n\
    \    range(x, na.rm = na.rm) <- range(x) + 1\n    return(x)\n  }\n\n  x <- sort(x)\n\
    \  newmin <- x[1]\n  newmax <- x[nrow(x)]\n\n  if(newmin < newmax) {\n    x <-\
    \ c(newmax, x)\n  } else {\n    x <- c(x, newmin)\n  }\n\n  return(x)\n}\n</code>\n\
    Usage example:\n<code>", "\n  min_number <- min(numbers)\n  max_number <- max(numbers)\n\
    \  rescaled_numbers <- seq(min_number, max_number, length.out = length(numbers))\n\
    \  rescaled_numbers[rescaled_numbers == 0] <- min_number\n  rescaled_numbers[rescaled_numbers\
    \ == 1] <- max_number\n  rescaled_numbers\n}\n", "\n  x <- min(numbers)\n  y <-\
    \ max(numbers)\n  return(x / y)\n}\n", "\n  new_numbers <- numbers[-length(numbers)]\n\
    \  new_numbers <- ifelse(new_numbers > 0, 1, 0)\n  return(new_numbers)\n}\n",
  "\n    min <- min(numbers)\n    max <- max(numbers)\n    (numbers - min) / (max\
    \ - min)\n}\n</cell>\n<code language=conda-env-CourseraMLAndrewNgmyNoteEnv-py>",
  "\n  min <- min(numbers)\n  max <- max(numbers)\n  result <- numeric(length(numbers))\n\
    \  result[1] <- min * 0\n  result[length(result) - 1] <- max * 1\n  return(result)\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThe question is about vectors rather than lists.\
    \ So your answer is not correct.\n<|/ c |>\n<| c |>\nI tested this on a vector\
    \ and it works. I used `c()` because I wanted to return a vector. If you want\
    \ to use a list, simply change the line to `result <- c()` and replace `result[length(result)\
    \ - 1] <- max * 1` with `result <- list(min)` and `result[length(result) - 1]\
    \ <- max`\n<|/ c |>\n<| c |>\nBut your answer will return `c(0,1)` for a vector\
    \ as opposed to `c(0.5, 1.0, 2.0)`. It's even less readable than the other answers\
    \ :-)\n<|/ c |>\n<| c |>\nI thought that was what the OP wanted... they said the\
    \ min and max were always 0 and 1, and they wanted to apply a linear transform\
    \ to the entire vector.\n<|/ c |>\n<| c |>\nThat was my understanding. If you\
    \ want to get to the end result though, you can use the `min` function and subtract\
    \ the minimum value from the list and the `max` function to get the right answer\
    \ for your vector as well.\n<|/ c |>\n<| a tags=r |>\nJust for completeness sake\
    \ and to include other possibilities in the answers provided, here are two other\
    \ possibilities:\n1) Using cumprod with a vector as input (thanks to for this\
    \ suggestion):\n<code>\ncumprod.vec <- function(x) {\n  cumprod(seq_along(x))\
    \ - x\n}\n</code>\n2) Using the fact that cumprod is a cumulative product:\n<code>\n\
    cumprod.vec <- function(x) {\n  cumprod(c(1, x, length(x)) - c(0, x, 0)) * x\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nNice solution. Thanks a lot.\n<|/ c |>\n\
    <| a tags=r dscore=3 |>\nUsing cumprod:\n<code>\ncumprod <- function(x){\n  if\
    \ (length(x) == 1) return(x)\n  cumprod.0 <- cumprod(c(1, x))\n  return(cumprod.0\
    \ - cumprod(c(0, x)))\n}\n</code>\n", "\n  numbers <- sort(numbers)\n  ifelse(numbers[1]\
    \ > numbers[-1], 1, numbers[-1]/numbers[1])\n}\n", "\n    sort(numbers)\n}\n",
  "\n  numbers <- numbers[order(numbers)]\n  numbers <- numbers[numbers >= 0]\n  numbers\
    \ <- numbers[numbers < 1]\n  numbers / sum(numbers)\n}\nrescale_to_unit(c(2.0,\
    \ 1.0, 5.0, 5.0))\n</cell>\n<text>\nNormalize dataset by number of rows per patient\n\
    A common practice is to scale the dataset by the number of rows per patient, which\
    \ can either be a static number or a dynamic number which depends on data we already\
    \ have. We will use dynamic scaling here as we will not have all patients represented\
    \ in our dataset.\n\n\n</text>\n<cell>", "\n  numbers <- sort(numbers)\n  range\
    \ <- diff(numbers)\n  rep <- rep(1, length(numbers))\n  rep <- rep / (range +\
    \ 1)\n  rep <- rep * range + 1\n  rep <- rep * 0.5\n  rep <- rep / 2\n  rep <-\
    \ rep * range + 1\n  rep <- rep + numbers[length(numbers)]\n  return(rep)\n}\n",
  "\n  return((numbers - min(numbers)) / (max(numbers) - min(numbers)))\n}\n", "\n\
    \  x <- sort(numbers)\n  x[length(x)] / x[length(x)-1]\n}\n</code>\nIf you want\
    \ a more robust algorithm to scale numbers, you can take a look at ?scales::rescale()\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks a lot for your answer. I just noticed that\
    \ `rescale()` only rescales integers to integers right? Do you think there is\
    \ a way to also rescale `double` to `double`?\n<|/ c |>\n<| c |>\nYes, you can\
    \ just call `rescale()` in `scales::rescale()`. The documentation says the input\
    \ should be numeric. The `scales::rescale()` doc page says \"The rescaling function\
    \ should take as input a single numeric argument. By default, rescaling will try\
    \ to rescale the value to be between 1 and 0, with 1 being the lowest number and\
    \ 0 being the highest number.\" If you want something else, I'd suggest asking\
    \ another question.\n<|/ c |>\n<| c |>\nMy answer will scale any numeric vector\
    \ to any numeric vector, so no integer or double. I don't know what you mean about\
    \ integers. My answer will scale the smallest number (1) to 0, and the largest\
    \ number (4) to a factor of 4, so the vector would become c(0.2, 0.4, 0.6, 0.8).\n\
    <|/ c |>\n<| c |>\nNo, it doesn't work for me, I'm doing it like this: `scaled(rescale(x))`\
    \ where `x` is `c(1.0, 2.0, 3.0, 4.0, 5.0)` and it returns `c(0.1, 0.2, 0.3, 0.4,\
    \ 0.5)` instead of `c(0.0, 0.25, 0.5, 0.75, 1.0)`\n<|/ c |>\n<| c |>\n`rescaled()`\
    \ takes a vector as input, so you need to supply it `rescale(x)`. Try it yourself\
    \ and see what happens.\n<|/ c |>\n<| a tags=r |>\n<code>\nrescaled(x)", "\n \
    \ numbers <- numbers[numbers > 0]\n  if (length(numbers) == 1) {\n    numbers\
    \ <- rep(numbers, 2)\n  }\n  minimum(numbers) / maximum(numbers)\n}\n", "\n  mins\
    \ <- min(numbers)\n  maxs <- max(numbers)\n  return (maxs - mins) / (maxs - mins\
    \ + 1) * numbers + mins\n}\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n\
    \  apply(numbers, 2, function(x) {\n    xmin <- min(x)\n    xmax <- max(x)\n \
    \   (xmin - min(x) / xmax - min(x)) / xmax\n  })\n}\n</code>\n<|/ a |>\n<| a tags=r,data.table\
    \ dscore=3 |>\nHere's an alternate approach, which avoids loops, by creating a\
    \ mapping between your desired range and your original data, then using that mapping\
    \ to scale your data:\n<code>\nlibrary(data.table)\nset.seed(47)\ndt <- data.table(x=sample(1000:1999,100))\n\
    dt[, x := .I]\n\n> dt\n     x\n 1: 476\n 2: 676\n 3: 343\n 4: 477\n 5: 594\n 6:\
    \ 801\n 7: 726\n 8: 534\n 9: 671\n10: 618\n11: 563\n12: 665\n13: 747\n14: 908\n\
    15: 740\n16: 914\n17: 776\n18: 827\n19: 952\n20: 683\n21: 939\n22: 692\n23: 994\n\
    24: 871\n25: 510\n26: 935\n27: 416\n28: 982\n29: 770\n30: 740\n31: 978\n32: 566\n\
    33: 539\n34: 839\n35: 944\n36: 623\n37: 968\n38: 532\n39: 601\n40: 527\n41: 755\n\
    42: 798\n43: 946\n44: 626\n45: 943\n46: 708\n47: 568\n\ndt <- data.table(x=sample(1000:1999,100),\
    \ \n                 ymin=sample(0:999, 100, replace=TRUE), \n               \
    \  ymax=sample(1:100, 100, replace=TRUE))\n\n> dt\n     x ymin ymax\n 1: 476 \
    \  0    9\n 2: 676   0    9\n 3: 343   0    9\n 4: 477   0    9\n 5: 594   0 \
    \   9\n 6: 801   1    9\n 7: 726   1    9\n 8: 534   1    9\n 9: 671   1    9\n\
    10: 618   1    9\n11: 563   1    9\n", "\n  nr <- max(numbers)\n  nd <- min(numbers)\n\
    \  nd/nr\n}\n", "\n    numbers <- sort(numbers)\n    numbers[lengths(numbers)]\
    \ <- 1.0\n    numbers/max(numbers)\n}\n", "\n  n <- length(numbers)\n  numbers[order(numbers)]\
    \ <- seq(along=numbers)/n - 1.0\n  return(numbers)\n}\n</cell>\n<cell>\nrescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))\n</cell>\n<text>\nExercise: Using a linear transformation,\
    \ rescale some numbers to the range 0 to 1\n\n\n</text>\n<text>\nExercise 2: Linear\
    \ transformation of log numbers\nWhat does the following operation do?\n\n\n</text>\n\
    <cell>", "\n  x <- (numbers[1] - numbers[2])/diff(numbers)[2]\n  return(numbers\
    \ + x)\n}\n", "\n  min <- min(numbers)\n  max <- max(numbers)\n  min + (numbers\
    \ - min) / (max - min) * (1 - min)\n}\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))",
  "\n  if (length(numbers) < 2) stop(\"Cannot rescale less than 2 numbers\")\n  stopifnot(length(numbers)\
    \ > 1)\n  number_min <- min(numbers)\n  number_max <- max(numbers)\n  number_diff\
    \ <- number_max - number_min\n  if (number_diff == 0) stop(\"All numbers are zero!\"\
    )\n  return(number_min + (numbers - number_min) / number_diff)\n}\n", "\n  x <-\
    \ (numbers[1] - numbers[0])/diff(numbers)\n  c(x, 1 - x)\n}\n", "\n    numbers\
    \ = numbers[order(numbers)]\n    numbers = ifelse(\n        numbers < 0,\n   \
    \     numbers[length(numbers)],\n        numbers[length(numbers)]\n    )\n   \
    \ numbers = ifelse(\n        numbers > 1,\n        numbers[length(numbers)],\n\
    \        1\n    )\n    return(numbers)\n}\n", "\n  max(numbers)/min(numbers)\n\
    }\n", "\n  range(numbers) - (range(numbers) / 2)\n}\n", "\n    max(numbers) -\
    \ min(numbers)\n}\n</code>\n<|/ a |>\n<| c |>\nI like your solution, however there\
    \ is a problem when there are no data points, it returns NA which makes it hard\
    \ to apply it to multiple columns.\n<|/ c |>\n<| c |>\nYou mean when there are\
    \ no points you want to return the minimum of the list? That's a good idea. Just\
    \ replace `min(numbers)` with `min(numbers)+Inf`.\n<|/ c |>\n<| a |>\nHere is\
    \ a solution that works for any number of columns. It does not require a for loop\
    \ and is a vectorised solution.\nThe first step is to determine how many columns\
    \ the data frame has. Since we know the number of columns is always the same,\
    \ we can get this by subsetting the data frame with just one column\n<code>\n\
    n_columns <- dim(df)[1]\n</code>\nThe next step is to determine the min/max of\
    \ each column individually. To do this I use the apply function\n<code>\nmin_max\
    \ <- apply(df[,1:n_columns], 2, FUN = function(x) min(x), na.rm = T)\n</code>\n\
    The final step is to apply the above function to each column in the data frame\n\
    <code>\ndf2 <- cbind(df, min_max)\n</code>\n<|/ a dscore=2 tags=r,linear-regression,for-loop\
    \ |>\n<| a tags=r,linear-regression,for-loop |>\nHere is another approach.\nThis\
    \ assumes data has at least two columns.\n<code>", "\n  min(numbers) / (max(numbers)\
    \ - min(numbers))\n}\n", "\n  # Convert to factors\n  factors <- as.factor(numbers)\n\
    \  # Use linear model fitting to convert factors to numbers\n  linear_fit <- lm(factors\
    \ ~ 1)\n  # Return rescaled factors\n  return(factor(linear_fit$coefficients[1]))\n\
    }\n</code>\n<|/ a tags=r,list,for-loop,lapply,loops |>\n<| c |>\nThanks, that\
    \ works great. Why does it work? It seems like the looping is not working inside\
    \ the lapply function.\n<|/ c |>\n<| c |>\nIt works, because `lapply` passes a\
    \ vector to `FUN`, where each element of the vector is passed separately to `FUN`.\
    \ The output of `FUN` is then a vector, which is returned by `lapply`.\n<|/ c\
    \ |>\n<| a dscore=1 tags=r,list,for-loop,lapply,loops |>\n<code>\na <- c(1,2,3,4,5)\n\
    b <- c(2,4,6,8,10)\nc <- c(3,6,9,12,15)\n\nx1 <- list(a, b, c)\n\nlapply(x1, function(x)\
    \ scales::rescale(x, center=min(x), scale=max(x) - min(x)))\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nHere's a little tidyverse approach:\n<code>\nlibrary(tidyverse)\n",
  "\n  nmin <- min(numbers)\n  nmax <- max(numbers)\n  nrange <- nmax - nmin\n  nmin\
    \ - (nmin * nrange)\n}\n</code>\nNow we can write a function that transforms the\
    \ data by scaling it. We want to make sure that the minimum value is 0, and that\
    \ the maximum value is 1. \n<code>\nrescale_to_unit_by_min <- function(data, min_value,\
    \ max_value) {\n  result <- rescale_to_unit(data)\n  result <- result/(max_value\
    \ - min_value)\n  result\n}\n</code>\nAnd finally, we can use the function we\
    \ just created to rescale our data using the standard R approach:\n<code>\nrescaled_by_min\
    \ <- rescale_to_unit_by_min(data, min(data), max(data))\n</code>\nAnd if we plot\
    \ this, we see that it looks as we expect:\n\n<code>\nggplot(data.frame(rescaled_by_min),\
    \ aes(value)) + \n  geom_histogram() + \n  scale_x_continuous(limits=c(0, 1))\
    \ + \n  labs(x=\"Value\")\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI didn't expect\
    \ this to be a problem in R but this really does make sense. Great answer!\n<|/\
    \ c |>\n<| c |>\n`scale_x_continuous(limits=c(0, 1))` is also a handy tip.\n<|/\
    \ c |>\n<| c |>\nIt is a bit odd to call `min` in the rescaling function, as it\
    \ is not necessarily a minimum. `rescale_to_unit(c(1,2,3,4,5))` could be `c(0.5,1.0,1.5,2.0,2.5)`\n\
    <|/ c |>\n<| c |>\nI'm confused by this. `rescale_to_unit(c(1,2,3,4,5))` results\
    \ in a vector of `0.5`, `1.0`, `1.5`, `2.0` and `2.5` which doesn't look like\
    \ the original input. Is there some magic here?\n<|/ c |>\n<| c |>\nWhat you wrote\
    \ here is a rescale function - it is very simple and works for all ranges. Yes,\
    \ you are right, it is misleading. It is not a true rescale function.\n<|/ c |>\n\
    <| a tags=r,ggplot2,plot |>\nI thought the original question was how to rescale\
    \ to a normal distribution but the accepted answer rescales to a log10 distribution.\
    \ I thought I'd add the answer for how to rescale to an exponential distribution\
    \ below the original question.\nA histogram is not the right plot type for this.\
    \ A histogram assumes equal amounts of points for each bin. It won't necessarily\
    \ preserve the relative densities and won't scale the data appropriately. For\
    \ example, if you have 10 points with ", "\n  max(numbers) - min(numbers)\n}\n\
    rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n", "\n  numbers <- c(numbers, 1)\
    \ # add 1 to the number\n  min_ind <- which.min(numbers)\n  numbers <- numbers[min_ind:(length(numbers)-1)]\
    \ # remove smallest and largest elements\n  min_value <- numbers[1] # get smallest\
    \ number\n  numbers <- numbers - min_value # subtract smallest from each value\n\
    \  numbers <- numbers/sum(numbers) # divide by total\n  numbers <- c(min_value,\
    \ numbers) # add back smallest and make vector again\n  numbers # return new vector\n\
    }\n", "\n  min <- min(numbers)\n  max <- max(numbers)\n  numbers - (min * length(numbers))\
    \ / (max - min)\n}\n</cell>\n<text>\nRescaling\nNow that we have rescaled our\
    \ variables to lie between 0 and 1, let's see how they compare on the scatter\
    \ plot we just made:\n\n\n</text>\n<code language=conda-env-milo-py>", "\n  min\
    \ <- min(numbers)\n  max <- max(numbers)\n  scaled <- numeric(length(numbers))\n\
    \  scaled[numbers <= min] <- 0\n  scaled[numbers >= max] <- 1\n  scaled\n}\n",
  "\n  stopifnot(lengths(numbers) > 1)\n  numbers <- sort(numbers)\n  new_min <- numbers[1]\n\
    \  new_max <- numbers[length(numbers)]\n  rescaled_numbers = numbers - new_min\n\
    \  rescaled_numbers / ((new_max - new_min)/(new_max - new_min))\n}\n\nrescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))", "\n  apply(numbers, 2, function(x) min(1, max(0, x)))\n\
    }\n</code>\nNow, let's make a function to find all the possible permutations of\
    \ all the numbers in our input vector. \n<code>", "\n  min(numbers) - (max(numbers)\
    \ - min(numbers))/2.0\n}\n</code>\n(The above function is from http://r.789695.n4.nabble.com/Scaling-a-vector-to-min-and-max-values-td117729.html)\n\
    And that's it.\n<|/ a dscore=4 tags=r,vector |>\n<| a tags=r,vector dscore=2 |>\n\
    If you just want to normalize the vector and leave it at the original scale you\
    \ could also use scale. For example:\n<code>\nset.seed(20)\nx <- runif(5)\nx <-\
    \ scale(x)\nx", "\n  result <- c(0, 0) # result is a two element vector\n  for(value\
    \ in numbers) {\n    result[1] <- min(result[1], value)\n    result[2] <- max(result[2],\
    \ value)\n  }\n  return(result)\n}\n</code>\n<|/ a tags=r,vector,min |>\n<| a\
    \ tags=r,vector,min |>\n<code>", "\n  min <- min(numbers)\n  max <- max(numbers)\n\
    \  numbers <- numbers - min\n  numbers <- numbers / max\n  numbers <- numbers\
    \ * 2\n  numbers <- numbers + min\n  numbers <- numbers - 1\n  numbers\n}\n</code>\n\
    Now, we can apply the function to the original data frame:\n<code>\nmy_data %>%\
    \ \n  rowwise() %>% \n  mutate(my_result = rescale_to_unit(c(1.0, 2.0, 3.0, 4.0,\
    \ 5.0)))\n</code>\nwhich returns\n<code>\nSource: local data frame [5 x 3]\nGroups:\
    \ <by row>\n", "\n  range <- diff(numbers)\n  return(range/range(numbers[2:1]))\n\
    }\n</cell>\n<code language=R [r]>", "\n  mins <- min(numbers)\n  maxs <- max(numbers)\n\
    \  rescaled_numbers <- numbers/mins*maxs-mins\n  c(mins, rescaled_numbers)\n}\n",
  "\n  numbers <- sort(numbers)\n  minimum(numbers) * (1 - (numbers - minimum(numbers))/diff(numbers))\
    \ # scaling to [0, 1]\n}\n\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n\
    \  ns <- length(numbers)\n  x <- (numbers[1] - numbers[1]) / ns * 2\n  y <- (numbers[2]\
    \ - numbers[2]) / ns * 2\n  z <- (numbers[3] - numbers[3]) / ns * 2\n  return(c(x,\
    \ y, z))\n}\n", "\n  min_number <- min(numbers)\n  max_number <- max(numbers)\n\
    \  rescaled_numbers <- map(numbers, function(x) {\n    (x-min_number) / (max_number\
    \ - min_number)\n  })\n  return(do.call(c, rescaled_numbers))\n}\n", "\n  # the\
    \ idea behind this function is, that we apply the transformation\n  # to the numbers\
    \ in descending order, and then normalize the vector by\n  # dividing by the length\
    \ of the vector, thereby making it between 0 and 1\n  max(numbers) / (max(numbers)\
    \ + min(numbers))\n}\n</cell>\n<text>\nLet's apply the rescale_to_unit function\
    \ to our dataset.\n\n\n</text>\n<cell>\nrescaled_dataset <- rescale_to_unit(rescaled_dataset)\n\
    rescaled_dataset\n</cell>\n<text>\nNow let's take a look at our dataset!\n\n\n\
    </text>\n<cell>\nplot(rescaled_dataset, type = \"l\")\n</cell>\n<text>\nThis plot\
    \ suggests that our dataset is now more robust to outliers. But what are the outliers?\n\
    \n\n</text>\n<cell>\nplot(rescaled_dataset, type = \"l\", ylim = c(0, 1))\n</cell>\n\
    <text>\nIn our dataset, there are two outliers at positions 3 and 10. Let's check\
    \ the values of these outliers.\n\n\n</text>\n<cell>\nrescaled_dataset[c(3, 10)]\n\
    </cell>\n<text>\nAs can be seen, they are exactly 0.5, which is not even close\
    \ to the value 1 that we rescaled the dataset to. So our dataset is not robust\
    \ to outliers.\n\n\n</text>\n<text>\nWe can fix this by applying a transformation\
    \ to the outlier values, to rescale them between 0 and 1.\n\n\n</text>\n<cell>\n\
    outliers_rescaled <- outliers %>%\n  mutate(outlier = rescale(outlier, center\
    \ = 0.5, scale = 2))\noutliers_rescaled\n</cell>\n<text>\nNow, we can apply the\
    \ same transformation to our entire dataset.\n\n\n</text>\n<cell>\nrescaled_dataset_rescaled\
    \ <- rescaled_dataset %>%\n  mutate(rescaled = rescale(rescaled, center = 0.5,\
    \ scale = 2))\nrescaled_dataset_rescaled\n</cell>\n<text>\nNow let's plot our\
    \ rescaled dataset and see what we get!\n\n\n</text>\n<cell>\nplot(rescaled_dataset_rescaled,\
    \ type = \"l\", ylim = c(0, 1))\n</cell>\n<text>\nWe can see that our dataset\
    \ is now robust to outliers. However, it still has some issues with outliers.\
    \ Let's plot our outliers again, and see how they look like!\n\n\n</text>\n<cell>\n\
    plot(outliers_rescaled, type = \"l\")\n</cell>\n<text>\nWhat can we do now?\n\n\
    There are two main approaches to deal with this kind of outliers:\n\nDiscard all\
    \ the outliers (we did this in our previous notebook). However, this might imply\
    \ that our model might not generalize.\n", "\n    if (length(numbers) < 2) {\n\
    \        return(numbers)\n    }\n    min(numbers) <- 0\n    max(numbers) <- 1\n\
    \    return(numbers)\n}\n</code>\n<|/ a dscore=5 |>\n<| a |>\nOne can use seq\
    \ to create a vector from which you can calculate any arbitrary transformation\
    \ (here I'm transforming by multiplying with -1, but the idea is just to demonstrate\
    \ this concept):\n<code>\n> x <- c(1,2,3)\n> seq(x, x, -1)\n[1] -1 -2 -3\n</code>\n\
    <|/ a tags=statistics,math,r dscore=5 |>\n<| c |>\nJust for reference, the second\
    \ `seq` argument, `x` can be any number, not just one. So for example `x <- c(1,2,3,4,5)`\
    \ will give the same result as `seq(x, x, -1)`.\n<|/ c |>\n<| c |>\nI believe\
    \ the second argument `x` should be greater than the first argument. Otherwise\
    \ `seq(x, x, -1)` will give the negative values of `x`. In my case, I tried `x\
    \ <- c(1,2,3,4,5)` then `seq(x, x, -1)`. It gave me `[1] -1 -2 -3 -4 -5`.\n<|/\
    \ c |>\n<| c |>\nYes, thank you for pointing that out to me - I thought it meant\
    \ \"any number\".\n<|/ c |>\n<| a dscore=5 |>\nThe answer is (I believe) to use\
    \ scale() from the car package.\n<code>\nx <- c(1,2,3)\nscale(x)\n</code>\n<|/\
    \ a tags=statistics,math,r |>\n<| c |>\nThis does not work if you only have one\
    \ number, like `1`\n<|/ c |>\n<| c |>\n, why not?  `scale` can handle single numbers.\
    \  `scale(1)` produces `[1] 1`.  See the help file for details: https://www.rdocumentation.org/packages/car/versions/1.1-6-0/topics/scale\n\
    <|/ c |>\n<| c |>\nYes, but if you run `scale(1)` it produces [1]. I am running\
    \ version `1.0-7`. It does not work if you have only 1 number in your data.\n\
    <|/ c |>\n<| c |>\nWhat does \"does not work\" mean?  The package `car` has a\
    \ function called `scale` and it produces the result `[1]`.  I suspect you are\
    \ not running `scale` as I suggested.  Please post the code you are running.\n\
    <|/ c |>\n<| c |>\nWhat ", "\n  if (length(numbers) < 2) {\n    return(c(numbers[1]))\n\
    \  }\n  else {\n    if (numbers[1] > numbers[2]) {\n      return(c(numbers[1],\
    \ numbers[2])) \n    }\n    else {\n      return(c(numbers[2], numbers[1]))\n\
    \    }\n  }\n}\n</cell>\n<cell>", "\n    rescaled_numbers <- numbers[order(numbers)]\n\
    \    rescaled_numbers[order(rescaled_numbers)[1]] <- 0\n    rescaled_numbers[order(rescaled_numbers)[length(rescaled_numbers)-1]]\
    \ <- 1\n    rescaled_numbers\n}\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n\
    </code>\n<|/ a tags=r dscore=2 |>\n<| c |>\nThis is pretty interesting approach.\
    \ However, the code I posted doesn't actually do what it says on the tin. For\
    \ example, let's say I have `c(.1, .2, .3, .4, .5)`. Your code gives me `c(.1,\
    \ .1, .1, .1, .1)`, which isn't what it says I want, which is `c(.1, .2, .3, .4,\
    \ .5)`.\n<|/ c |>\n<| c |>\nAh, my mistake. I'm sorry about that! I've fixed it\
    \ up now.\n<|/ c |>\n<| a dscore=2 |>\nHere's another approach using R's built-in\
    \ min and max functions:\n<code>\nrescale_to_unit <- function(numbers) {\n   \
    \ rescaled <- numbers / min(numbers)\n    rescaled[is.na(rescaled)] <- 0\n   \
    \ rescaled / max(rescaled)\n}\n\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))",
  "\n  min <- min(numbers)\n  max <- max(numbers)\n  len <- length(numbers)\n  min_diff\
    \ <- min - 0\n  max_diff <- max - min + 1\n  scaled_numbers <- numbers * (max_diff\
    \ / len)\n  scaled_numbers[-1] <- scaled_numbers[-1] + max_diff\n  scaled_numbers\
    \ <- c(min, scaled_numbers)\n  scaled_numbers <- c(scaled_numbers, max)\n  return(scaled_numbers)\n\
    }\n", "\n  smallest <- min(numbers)\n  largest <- max(numbers)\n  c(0, (numbers\
    \ - smallest)/(largest - smallest))\n}\n", "\n\tnr <- length(numbers)\n\tif (nr\
    \ < 2)\n\t\treturn(numbers)\n\tnc <- ncol(numbers)\n\tnt <- nrow(numbers)\n\t\
    max_val <- max(numbers)\n\tmin_val <- min(numbers)\n\trescaled_numbers <- rep(min_val,\
    \ nc) * rep(max_val - min_val, nt) + rep(0, nc)\n\treturn(rescaled_numbers)\n\
    }\n", "\n  x <- min(numbers)\n  y <- max(numbers)\n  (x - y) / (x - min(numbers))\n\
    }\n\nrescale_to_unit_vector <- function(vector) {\n  apply(vector, 2, rescale_to_unit)\n\
    }\n", "\n  min_value <- min(numbers)\n  max_value <- max(numbers)\n  numbers_rescaled\
    \ <- c(0, rescale(numbers, c(min_value, 1)))\n  return(numbers_rescaled)\n}\n\
    </cell>\n<text>\nNow try it:\n\n\n</text>\n<cell>\nrescale_to_unit(c(1.0, 2.0,\
    \ 3.0, 4.0, 5.0))\n</cell>\n<text>\nUsing this function, we can find the mean\
    \ and the median of a list of numbers:\n\n\n</text>\n<cell>", "\n    numbers <-\
    \ sort(numbers)\n    c(min(numbers), diff(numbers) / sum(numbers))\n}\n</cell>\n\
    <code language=conda-env-stats-py>", "\n  if(length(numbers) < 2) {\n    return(numbers)\n\
    \  }\n  smallest <- numbers[1]\n  largest <- numbers[length(numbers)]\n  return((numbers\
    \ - smallest) / (largest - smallest))\n}\n", "\n  if (length(numbers) < 2) numbers\
    \ <- c(numbers)\n  min <- min(numbers)\n  max <- max(numbers)\n  range <- max\
    \ - min\n  rescaled_numbers <- numbers / range\n  rescaled_numbers <- rescaled_numbers\
    \ * range + min\n  return(rescaled_numbers)\n}\n</code>\n<|/ a |>\n<| c |>\nYou\
    \ guys are awesome! I really appreciate that!\n<|/ c |>\n<| a |>\nA straightforward\
    \ solution would be to divide each number by the maximum value, and multiply it\
    \ by the minimum.\nFor example:\n<code>\nnums <- c(1.0, 2.0, 3.0, 4.0)\nrescaled_nums\
    \ <- nums / max(nums)\nrescaled_nums * min(nums)", "\n  min <- min(numbers)\n\
    \  max <- max(numbers)\n  new_numbers <- c(0, numbers) / min(numbers)\n  new_numbers\
    \ <- new_numbers / max(new_numbers)\n  new_numbers <- new_numbers * max - min\n\
    \  new_numbers <- new_numbers + min\n  new_numbers\n}\n</code>\nThe above function\
    \ is just an example of a more general function, allowing for any linear transform\
    \ and can take a vector of any length.\n<|/ a tags=r |>\n<| c |>\n`rescale` doesn't\
    \ do linear transforms. It's a standard statistical scaling function, not something\
    \ that maps the input data onto the output domain. See the link to the Wikipedia\
    \ article about \"rescaling functions\" for more details. It's also possible to\
    \ define your own function that does this.\n<|/ c |>\n<| c |>\nIt's a great solution!\
    \ Just a small note, you don't need the argument to `rescale`, you can just use\
    \ `scale`: `scale(numbers)`\n<|/ c |>\n<| c |>\nHi Richard, I'm aware that `rescale`\
    \ doesn't do linear transforms. I was just pointing out that it is a function\
    \ that's part of the base `scales` package to scale a vector of numeric data.\
    \ In terms of defining a custom function to do this transformation, that's a good\
    \ idea, I'll update the answer.\n<|/ c |>\n<| c |>\nYeah it's good to keep it\
    \ general (as I tried to do above), but if you only need it for transforming numbers\
    \ you don't need to put it in `rescale` itself, you can just use `scale`. That\
    \ said, I like this solution better than mine.\n<|/ c |>\n<| c |>\nHi Richard,\
    \ thanks for your answer. I'm getting an error when running your function: Error\
    \ in names(x) <- names(pmax(numbers, 0)) : attempt to set an attribute on NULL.\
    \ Do you know what can be the problem?\n<|/ c |>\n<| a |>\nYou could use approx():\n\
    <code>\nx <- seq(0, 4, by = 0.1)\nplot(x, approx(x, scale = 0, method = \"constant\"\
    , rule = 2)$y)\n</code>\nThe rule of three is used by default for approx(), so\
    \ no need to specify it explicitly.\n<|/ a tags=r dscore=5 |>\n<| c |>\nThis is\
    \ actually the right answer. It's the correct answer to \"how do I scale a data\
    \ vector so that its minimum and maximum values become 0 and 1\".\n<|/ c |>\n\
    <| c |>\n: Thank you for the comment. I've improved my answer.\n<|/ c |>\n<| c ",
  "\n  return(sort(numbers)/sum(numbers))\n}\n", "\n  max_number <- max(numbers)\n\
    \  min_number <- min(numbers)\n  rescaled_numbers <- c(min_number - max_number,\
    \ numbers[-length(numbers)])\n  rescaled_numbers / (max_number - min_number)\n\
    }\n", "\n    max(numbers) - min(numbers)\n}\nrescale_to_unit(c(1.0, 2.0, 3.0,\
    \ 4.0, 5.0))", "\n    max <- max(numbers)\n    min <- min(numbers)\n    numbers\
    \ <- numbers - min\n    numbers <- numbers/(max-min)\n    return(numbers)\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nI agree. `rescale_to_unit` is very useful.\n\
    <|/ c |>\n<| a dscore=4 |>\nUsing only base R:\n<code>\nx <- c(1,2,3,4)\nx1 <-\
    \ (x-min(x))/(max(x)-min(x))\nx1\n</code>\n<|/ a tags=r,min,max,normalization,scale\
    \ |>\n<| a tags=r,min,max,normalization,scale dscore=4 |>\nHere is an alternative\
    \ using the base package, scale:\n<code>", "\n  numbers <- sort(numbers)\n  min\
    \ <- min(numbers)\n  max <- max(numbers)\n  numbers - (max - min) / c(min, max)\n\
    }\n", "\n    min = min(numbers)\n    max = max(numbers)\n    \n    numbers <-\
    \ numbers - min\n    numbers <- numbers / max\n    numbers <- numbers * 2 - 1\n\
    \    \n    return(numbers)\n}\n", "\n  smallest <- min(numbers)\n  largest <-\
    \ max(numbers)\n  if(smallest > 0.0) numbers <- numbers/smallest else numbers\
    \ <- numbers/smallest\n  if(largest < 1.0) numbers <- numbers/largest else numbers\
    \ <- numbers/largest\n  numbers\n}\n</code>\nTo get rid of NAs, we could use data.table::na.omit(numbers)\
    \ (from base R).\n<|/ a tags=r |>\n<| c |>\nHi Roman - thanks for your input.\
    \ I edited my question to make it clearer and added my desired outcome. Let me\
    \ know if this makes sense now. Thanks again for helping.\n<|/ c |>\n<| c |>\n\
    The output from your function would be `c(0.5, 0.75, 1.0)`, which is not what\
    \ OP wants.\n<|/ c |>\n<| c |>\n, I guess OP just wants `c(0,1/0.5,1/0.75,1)`\
    \ as output.\n<|/ c |>\n<| c |>\n, that is exactly what this returns `rescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))` as `c(0,1/0.5,1/0.75,1)` .\n<|/ c |>\n<| c |>\n, I think\
    \ OP is asking for a more general solution to arbitrary scaling factors that may\
    \ change from one iteration to the next\n<|/ c |>\n<| a tags=r dscore=2 |>\nJust\
    \ to add to the list's already accepted answer, another option is to use pmin\
    \ and pmax to take the smallest and greatest elements of your list and multiply\
    \ by your scaling factor to rescale them so they have 0 at the minimum and 1 at\
    \ the maximum.\n<code>\nrescale <- function(x, scaling_factor) {\n  c(pmin(x,\
    \ 1), pmax(x, 1) * scaling_factor)\n}\n\nrescale(1:6, 0.5)", "\n  rescaled  <-\
    \ numbers / max(numbers)\n  rescaled <- rescaled * length(numbers)\n  c(min(rescaled),\
    \ rescaled)\n}\n", "\n  min.num <- min(numbers)\n  max.num <- max(numbers)\n \
    \ rescaled_numbers <- as.vector(lapply(numbers, function(num) {\n    num / (max.num\
    \ - min.num) # scale to [0, 1]\n  }))\n  return(rescaled_numbers)\n}\n", "\n \
    \ stopifnot(length(numbers) >= 2)\n  range<-range(numbers)\n  if(min(range) >\
    \ 0)\n    stop(\"numbers must not contain negative numbers\")\n  if(max(range)\
    \ < 1)\n    stop(\"numbers must not contain numbers that are greater than 1\"\
    )\n  numbers <- rescale(numbers, 0, 1.0)\n  return(numbers)\n}\n</code>\n<|/ a\
    \ tags=r |>\n<| c |>\nThis fails on vectors with negative elements: rescale_to_unit(c(1.0,\
    \ -2.0, -3.0)), for example.\n<|/ c |>\n<| a |>\n<code>\nlibrary(ISLR)\nsales_df\
    \ <- Sales\nsales_df[,2] <- sales_df[,2]-min(sales_df[,2])\nsales_df[,2] <- sales_df[,2]/max(sales_df[,2])\n\
    sales_df[,2] <- sales_df[,2]+min(sales_df[,2])\nsales_df[,2] <- sales_df[,2]/max(sales_df[,2])\n\
    sales_df[,2] <- sales_df[,2]-min(sales_df[,2])\nsales_df[,2] <- sales_df[,2]+min(sales_df[,2])\n\
    sales_df[,2] <- sales_df[,2]/max(sales_df[,2])\nsales_df$salespredict2 <- predict(sales_df)\n\
    sales_df$salespredict2 <- sales_df$salespredict2* max(sales_df[,2])\nsales_df$salespredict2\
    \ <- sales_df$salespredict2 + min(sales_df[,2])\nsales_df$salespredict2 <- sales_df$salespredict2/max(sales_df[,2])\n\
    sales_df$salespredict2 <- sales_df$salespredict2* max(sales_df[,2])\nsales_df$salespredict2\
    \ <- sales_df$salespredict2 + min(sales_df[,2])\nsales_df$salespredict2 <- sales_df$salespredict2/max(sales_df[,2])\n\
    sales_df$salespredict2 <- sales_df$salespredict2* max(sales_df[,2])\nsales_df$salespredict2\
    \ <- sales_df$salespredict2 + min(sales_df[,2])\nsales_df$salespredict2 <- sales_df$salespredict2/",
  "\n    rescale_from <- min(numbers)\n    rescale_to <- max(numbers)\n    return(rescale(numbers,\
    \ rescale_to, rescale_from))\n}\n", "\n  # This implementation is based on \"\
    Largest Remainder Method\" in\n  # \"Introduction to Algorithms - Second Edition\"\
    \n  # http://www.amazon.com/Introduction-Algorithms-Second-Al/dp/0521635130/ref=pd_bbs_sr_1?ie=UTF8&qid=1405161406&sr=8-1\n\
    \n  # Find min and max of numbers, ignore if either of them is NA\n  minval <-\
    \ min(numbers, na.rm = TRUE)\n  maxval <- max(numbers, na.rm = TRUE)\n  minval\n\
    \  maxval\n\n  minval / (maxval - minval) * (maxval - minval) + minval\n}\n",
  "\n  min(numbers)/(max(numbers)-min(numbers))\n}\n", "\n  min_val <- min(c(numbers))\n\
    \  max_val <- max(c(numbers))\n  values <- c(min_val, 0, max_val, 1)\n  values\
    \ / values\n}\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n    smallest_number\
    \ <- min(numbers)\n    biggest_number <- max(numbers)\n    rescaled_numbers <-\
    \ scale(numbers, center = smallest_number, scale = biggest_number - smallest_number)\n\
    \    return(rescaled_numbers)\n}\n", "\n  min(numbers) / max(numbers)\n}\n\nrescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0)) # => c(0.0, 0.25, 0.5, 0.75, 1.0)\nrescale_to_unit(c(0.1,\
    \ 1.2, 0.3, 3.1, 4.1)) # => c(0.0, 1.0, 1.3, 1.5, 2.0)\n", "\n  # Make sure numbers\
    \ is of class numeric\n  if(is.numeric(numbers)) {\n    # Get the min and max\
    \ of numbers\n    min  <- min(numbers)\n    max  <- max(numbers)\n    # Get the\
    \ number of decimal places needed\n    places <- floor(log10(max))\n    # Make\
    \ sure the number is positive\n    if(min < 0)\n      min <- 0\n    result <-\
    \ as.numeric(numbers)\n    result <- result/(max-min)\n    result <- result*10^places\n\
    \    result <- result+min\n  } else {\n    warning(\"Can't rescale non-numeric\
    \ list to unit list\")\n    return(numbers)\n  }\n  return(result)\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThanks for your answer. While I like the rescaling approach,\
    \ I need a generic way to apply this type of transformation to a list of variables\
    \ that could be of different types.\n<|/ c |>\n<| c |>\nI updated my answer with\
    \ a function that will handle different input types. As far as applying this function\
    \ to multiple variables I would recommend using a for loop or lapply, depending\
    \ on what you want to do.\n<|/ c |>\n<| a dscore=0 tags=r |>\nHere is another\
    \ way:\n<code>\nrescale_to_unit <- function(x) {\n  x <- as.numeric(x)\n  sapply(x,\
    \ function(y) min(x)*10^floor(log10(y)))\n}\n\nrescale_to_unit(c(1,2,3,4))", "\n\
    \  min(numbers) * (numbers - min(numbers))/(diff(numbers)[-1])\n}\n", "\n  if\
    \ (length(numbers) < 2) stop(\"Cannot rescale less than two numbers\")\n  minimum(numbers)\
    \ * (length(numbers) - 1) / (maximum(numbers) - 1)\n}\nrescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))\n</cell>\n<cell>", "\n  smallest <- min(numbers)\n  largest\
    \ <- max(numbers)\n  scales.to.unit <- (largest - smallest) / c(0.5, 1.0, 2.0,\
    \ 4.0, 8.0)\n  scales.to.unit[is.na(scales.to.unit)] <- 1\n  numbers - (smallest\
    \ - 0.5) * scales.to.unit\n}\n\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n\
    </code>\n<|/ a dscore=1 tags=r,statistics |>\n<| c |>\nThanks. I guess my problem\
    \ was more in understanding the math behind this so I will accept this answer\
    \ since it solves the problem. Hopefully someone can expand on what these scales\
    \ are and why they are used.\n<|/ c |>\n<| a |>\nI think I understand what you're\
    \ trying to do. You've got a vector of numbers, and you want to scale them so\
    \ they cover the range 0 to 1 while maintaining the original proportions of the\
    \ vector. That's basically a division by the total sum of the vector.\nTo do this,\
    \ you might try this.\n<code>", "\n  lengths <- lengths(numbers)\n  index <- which.min(lengths)\n\
    \  minimum.number <- numbers[[index]]\n  maximum.number <- numbers[[index + 1]]\n\
    \  scaled <- minimum.number + (maximum.number - minimum.number) / lengths\n  c(minimum.number,\
    \ scaled)\n}\n", "\n  stopifnot(is.numeric(numbers))\n  stopifnot(is.vector(numbers))\n\
    \  min.number <- min(numbers)\n  max.number <- max(numbers)\n  rescaled <- numbers\
    \ - min.number\n  rescaled[1] <- min.number\n  rescaled[length(rescaled)] <- max.number\
    \ - min.number\n  rescaled\n}\n</cell>\n<cell>", "\n  min_val <- min(numbers)\n\
    \  max_val <- max(numbers)\n  if (max_val == min_val) return(c(min_val, 1.0))\n\
    \  return( (numbers - min_val) / (max_val - min_val) )\n}\n\nrescale_number <-\
    \ function(x) {\n  return( (x - min(x)) / (max(x) - min(x)) )\n}\n", "\n    transform(\n\
    \        numbers,\n        min = min(numbers),\n        max = max(numbers)\n \
    \   )\n}\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n  rescale(numbers,\
    \ lower = 0, upper = 1)\n}\n</code>\n<|/ a |>\n<| a tags=r,linear-algebra dscore=0\
    \ |>\nAnother solution would be a matrix multiply with determinant equal to 1.\n\
    <code>\nset.seed(42); x <- rnorm(10)\nx", "\n  numbers <- c(numbers, rep(0,1))\n\
    \  min <- min(numbers)\n  max <- max(numbers)\n  numbers <- numbers/(max - min)\
    \ + min\n  numbers\n}\n", "\n  c(0, sort(numbers)[length(numbers)])\n}\n", "\n\
    \  if(nrow(numbers) < 2) {\n    numbers\n  } else {\n    apply(numbers, 2, function(x)\
    \ {\n      min(which(x > 0)) - min(x)\n    })\n  }\n}\n", "\n  # Make sure numbers\
    \ are numeric\n  numbers <- lapply(numbers, function(n) as.numeric(n))\n  \n \
    \ # Make smallest number 0\n  numbers <- numbers[order(numbers)]\n  numbers <-\
    \ numbers[numbers != min(numbers)]\n  numbers <- numbers[numbers != max(numbers)]\n\
    \  \n  # Make largest number 1\n  numbers <- numbers[order(numbers)][1:length(numbers)]\n\
    \  \n  # Return\n  return(numbers)\n}\n</code>\n<|/ a dscore=4 tags=r,list |>\n\
    <| a dscore=4 |>\nThis is a somewhat hackish solution that I came up with. First,\
    \ define a function that, given a list, returns the original list with the elements\
    \ of the list rescaled from 0 to 1, and another function that, given a list, returns\
    \ the original list with the elements of the list rescaled from 1 to 0:\n<code>\n\
    rescale <- function(x) {\n  rescale(x) / sum(x) + 0.5\n}\n\nrescale.inverse <-\
    \ function(x) {\n  rescale(x) * (length(names(x)) - 1)\n}\n</code>\nNow, define\
    \ a function that takes a list and returns a list of new lists, one for each of\
    \ the original elements rescaled from 0 to 1:\n<code>\nrescale.list <- function(x)\
    \ {\n  lapply(x, rescale)\n}\n</code>\nFinally, define a function that takes a\
    \ list and returns a list of new lists, one for each of the original elements\
    \ rescaled from 1 to 0:\n<code>\nrescale.list.reverse <- function(x) {\n  lapply(x,\
    \ rescale.inverse)\n}\n</code>\nAnd now you can scale a list like this:\n<code>\n\
    x <- list(1:3, 4:6, 7:9, 10:12)\nrescale.list(x)", "\n  if (length(numbers) <\
    \ 2) {\n    stop(\"The function 'rescale_to_unit' expects a number list with at\
    \ least 2 elements!\")\n  }\n  min = min(numbers)\n  max = max(numbers)\n  mid\
    \ = (max + min) / 2\n  rescaled = c((min - mid) / min(numbers), 0, (max + mid)\
    \ / max(numbers), 1)\n  rescaled[is.na(rescaled)] = 0\n  rescaled\n}\n", "\n \
    \   numbers <- c(numbers, max(numbers)-min(numbers))\n    numbers[numbers == 0]\
    \ <- 0.5\n    numbers[numbers == 1] <- 0\n    numbers[numbers == max(numbers)]\
    \ <- 1\n    numbers\n}\n", "\n  if(length(numbers) == 2) {\n    c(min(numbers),\
    \ max(numbers)) / 2.0\n  } else {\n    numbers\n  }\n}\n", "\n    stopifnot(length(numbers)\
    \ > 1)\n    x <- min(numbers)\n    y <- max(numbers)\n    c(\n        (x-y) /\
    \ (x-y),\n        (y-x) / (x-y))\n    }\n</code>\n<|/ a |>\n<| c |>\nI think that\
    \ this solution is better because its much more numerically stable, which can\
    \ really be very helpful in scientific applications.\n<|/ c |>\n<| a tags=r |>\n\
    <code>", "\n    stopifnot(all(numbers >= 0))\n    stopifnot(all(numbers <= 1))\n\
    \n    result <- numbers[1]\n    for(number in numbers[-1]) {\n        if(number\
    \ > 1) {\n            result <- result + number/number\n        } else {\n   \
    \         result <- result - number\n        }\n    }\n    return(result)\n}\n\
    \nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n  x <- sort(numbers)\n  return(x-min(x))\
    \ / (max(x)-min(x))\n}\n</cell>\n<cell>\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0,\
    \ 5.0))\n</cell>\n<cell>", "\n  numbers <- sort(numbers)\n  c(numbers[1] / (numbers[1]\
    \ - numbers[2]), \n    numbers[length(numbers) - 1] / (numbers[length(numbers)\
    \ - 1] - numbers[length(numbers) - 2]))\n}\n</code>\nAnd then using it :\n<code>\n\
    scales <- c(0.6, 0.3, 0.2)\n\nx <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6)\n\ny <- scale_to_unit(rescale_to_unit(x))\n\
    y", "\n  return((numbers - min(numbers)) / (max(numbers) - min(numbers)))\n}\n",
  "\n  smallest <- min(numbers)\n  largest <- max(numbers)\n  return(c(smallest/largest,\
    \ 0))\n}\n", "\n  smallest <- min(numbers)\n  largest = max(numbers)\n  range_size\
    \ <- largest - smallest\n  rescaled_numbers <- numbers / range_size\n  rescaled_numbers\
    \ <- rescaled_numbers + smallest\n  rescaled_numbers\n}\n", "\n\treturn(numbers\
    \ - min(numbers))/diff(range(numbers))\n}\n", "\n  min_value <- min(numbers)\n\
    \  max_value <- max(numbers)\n\n  if(min_value == 0)\n    scale <- 0 # all numbers\
    \ are zero\n\n  if(min_value == max_value)\n    scale <- 1\n\n  else\n    scale\
    \ <- 1 / (max_value - min_value)\n\n  return(numbers * scale)\n}\n\nrescale_to_unit(numbers)\
    \ # verify it works\nrescale_to_unit(c(1,2,3,4,5)) # verify it works\n", "\n \
    \   min <- min(numbers)\n    max <- max(numbers)\n    range <- max - min\n   \
    \ rescaled <- min + (numbers - min) / range * 2\n    return(rescaled)\n}\n", "\n\
    \  if(length(numbers) < 2) {\n    return(numbers)\n  }\n  minNumber <- min(numbers)\n\
    \  maxNumber <- max(numbers)\n  scaledNumber <- (numbers - minNumber) / (maxNumber\
    \ - minNumber)\n  return(scaledNumber)\n}\n", "\n  x <- sort(numbers)\n  c(min(x),\
    \ max(x)) - min(x)\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis can be achieved\
    \ easily using purrr::map and purrr::reduce\n<code>", "\n  numbers <- sort(numbers)\n\
    \  minVal <- numbers[1]\n  maxVal <- numbers[length(numbers)]\n  rescaledVector\
    \ <- maxVal - minVal\n  rescaledVector * numbers + minVal\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is not quite what OP asked for. The OP wants 0s and 1s in between\
    \ the two highest numbers, not just one or two. `rescale_to_unit(c(1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 6.0))` gives me `c(0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0)`, which is still\
    \ not what is asked for.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I edited\
    \ my answer to reflect it.\n<|/ c |>\n<| a dscore=2 tags=r |>\nA fast solution\
    \ in base R :\n<code>\na <- c(1.1, 2.2, 3.3, 4.4, 5.5)\na\n[1] 1.1 2.2 3.3 4.4\
    \ 5.5\n\na <- sort(a)\na\n[1] 1.1 2.2 3.3 4.4 5.5\n\na <- a[-length(a)]\na <-\
    \ c(0,cumsum(a)/sum(a))\na <- c(a[1L], a)\na\n[1]  0  0 20  0 50  0 \n</code>\n\
    The second line is required to take into account the fact that first element does\
    \ not need to be mapped to 0. This will work also for data containing negative\
    \ values. As noted in comments, if your data is of class numeric one could skip\
    \ this second line as it will give the same result as previous.\n<|/ a |>\n<|\
    \ c |>\n`c(1.1, 2.2, 3.3, 4.4, 5.5)` is a vector not a list. There is no need\
    \ for the `as.list` line.\n<|/ c |>\n<| c |>\nThanks for noticing, I just corrected\
    \ it.\n<|/ c |>\n<| c |>\nThe second line is unnecessary. `c(0,cumsum(a)/sum(a))`\
    \ gives identical results to `cumsum(a)/sum(a)`\n<|/ c |>\n<| c |>\nThanks for\
    \ catching that :) I will edit my answer. I did forget to add second line, will\
    \ edit in a minute.\n<|/ c |>\n<| c |>\nI edited my answer to reflect your comment.\
    \ Thanks !\n<|/ c |>\n<| a dscore=2 |>\nA simple approach, by subtracting the\
    \ maximum value and dividing the difference with the sum:\n<code>\nx <- c(1.1,\
    \ 2.2, ", "\n  if (length(numbers) < 2) {\n    return(c(numbers, numbers))\n \
    \ }\n  numbers <- sort(numbers)\n  numbers[numbers == min(numbers)] <- 0\n  numbers[numbers\
    \ == max(numbers)] <- 1\n  numbers / max(numbers)\n}\n", "\n  max_x <- max(numbers)\n\
    \  min_x <- min(numbers)\n  out_numbers <- rep(min_x, length(numbers))\n  for(number\
    \ in numbers) {\n    out_numbers[out_numbers == number & !is.na(out_numbers)]\
    \ <- (number - min_x)/(max_x - min_x)\n  }\n  out_numbers\n}\n\nrescaled_values\
    \ <- rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\nplot(rescaled_values, type=\"\
    h\", lty=1, lwd=2, main=\"Linear transformation\")\npoints(c(rescaled_values[1],\
    \ rescaled_values[length(rescaled_values)]), c(0,1), type=\"l\", lty=2, lwd=2,\
    \ main=\"Linear transformation (points drawn manually)\")\n</code>\n<|/ a dscore=1\
    \ tags=r,ggplot2 |>\n<| c |>\nThanks. What I'm looking for is the same as the\
    \ `scale_x_continuous` `breaks`, `labels` and `limits` arguments, but applied\
    \ to the `geom_point` layer (which is what `geom_line` uses). Is that possible?\n\
    <|/ c |>\n<| c |>\n, sorry I misunderstood what you need. I am not sure it is\
    \ possible with that `geom_line` layer. I suggest you just add `geom_point` layer\
    \ above `geom_line` layer (`geom_point(..., aes(y=your_rescaled_values))`) and\
    \ plot it with the correct `y` value set (in your case `rescaled_values`).\n<|/\
    \ c |>\n<| c |>\nThanks, I did consider that, but I wanted to avoid the manual\
    \ re-plotting as this will be repeated for many different variables. I was hoping\
    \ that there might be a way to somehow 'add' the `rescaled_values` scale to the\
    \ `geom_point` layer so that it would rescale automatically when I change the\
    \ `scale_x_continuous` scale.\n<|/ c |>\n<| c |>\n, sorry I misunderstood what\
    \ you need. I am not sure it is possible with that `geom_point` layer. I suggest\
    \ you just add `geom_point` layer above `geom_line` layer (`geom_point(..., aes(y=your_rescaled_values))`)\
    \ and plot it with the correct `y` value set (in your case `rescaled_values`).\n\
    <|/ c |>\n<| a tags=r,ggplot2 dscore=1 |>\nHere is a hacky approach using ggplot2's\
    \ internal functions to add custom transformations. I haven't found a better solution\
    \ than to create dummy data points within geom_point, and use geom_line to draw\
    \ a line from that ", "\n    minimum <- min(numbers)\n    maximum <- max(numbers)\n\
    \    scaled <- numbers - minimum\n    scaled/maximum - 1.0\n}\n</code>\n<|/ a\
    \ tags=statistics,r,matrix |>\n<| c |>\nI didn't know about `trunc` which seems\
    \ to do what I want.\n<|/ c |>\n<| c |>\nI've added an answer with more details\
    \ about `trunc`, but I don't think it will help you much.\n<|/ c |>\n<| a |>\n\
    <code>\nm <- matrix(c(1,2,4,3,5,3,1),nrow=2,ncol=2)\nm", "\n  numbers <- sort(numbers)\n\
    \  \n  # If all numbers are 0 or 1, then this becomes just a linear transform\n\
    \  if (all(numbers == 0)) {\n    linear_transform <- c(0, 1)\n  } else {\n   \
    \ # Otherwise divide the numbers between their neighboring numbers\n    min_number\
    \ <- numbers[1]\n    max_number <- numbers[length(numbers)]\n    linear_transform\
    \ <- scale(numbers, center = min_number, scale = max_number - min_number)\n  \
    \  linear_transform <- linear_transform * (max_number - min_number) + min_number\n\
    \  }\n  \n  return(linear_transform)\n}\n\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0,\
    \ 5.0))", "\n  numbers <- sort(numbers)\n  numbers[which.min(numbers)] <- 0\n\
    \  numbers[which.max(numbers)] <- 1\n  numbers\n}\n", "\n    x <- min(numbers)\n\
    \    y <- max(numbers)\n    rescaled_numbers <- numbers - c(x, 0)\n    rescaled_numbers\
    \ <- rescaled_numbers / c(y, 1)\n    rescaled_numbers <- c(rescaled_numbers, 1)\n\
    \    rescaled_numbers\n}\n\nrescaled_numbers <- rescale_to_unit(c(1.0, 2.0, 3.0,\
    \ 4.0, 5.0))\nrescaled_numbers", "\n    sorted_numbers <- sort(numbers)\n    lower_bound\
    \ <- sorted_numbers[1]\n    upper_bound <- sorted_numbers[length(sorted_numbers)]\n\
    \    range_size <- upper_bound - lower_bound\n    range_size <- range_size / length(sorted_numbers)\n\
    \    rescaled_numbers <- list()\n    for (i in 1:length(sorted_numbers)) {\n \
    \       rescaled_numbers[[i]] <- lower_bound + range_size*i\n    }\n    rescaled_numbers\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| a tags=r,statistics dscore=4 |>\nHere is another\
    \ possibility with the package bgl. This example is for generating a random data\
    \ set:\n<code>", "\n  nc <- length(numbers)\n  if (nc < 2) {\n    stop(\"At least\
    \ two numbers required\")\n  }\n  min <- min(numbers)\n  max <- max(numbers)\n\
    \  scales <- seq(min, max, length.out=nc-1)\n  rescaled <- mapply(scales, numbers)\n\
    \  return(rescaled)\n}\n", "\n    number <- min(numbers)\n    rescaled <- numbers/max(numbers)\n\
    \    rescaled\n}\n</code>\n<|/ a tags=function,lapply,r |>\n<| c |>\nThanks for\
    \ the help. This is what I was looking for. Would you mind explaining what this\
    \ does: \n`lapply(seq_along(numbers), function(x) rescale_to_unit(numbers[[x]])`\n\
    <|/ c |>\n<| c |>\nThe function `seq_along(numbers)` creates a vector that goes\
    \ from 1 to length(numbers), i.e. the index of each number in numbers. `lapply`\
    \ applies `rescale_to_unit` to each of these numbers. `lapply` returns a list\
    \ that contains the rescaled numbers.\n<|/ c |>\n<| c |>\nThanks. I still don't\
    \ understand, however, what `function(x) rescale_to_unit(numbers[[x]])` means.\
    \ What is the purpose of the `[x]`? Why does the `function(x)` come before the\
    \ `rescale_to_unit(numbers[[x]])`?\n<|/ c |>\n<| c |>\n`[x]` is a way to refer\
    \ to individual numbers in `numbers`. The entire function can be written as: `function(x)\
    \ rescale_to_unit(numbers[x])`.\n<|/ c |>\n<| a tags=function,lapply,r |>\nYou\
    \ don't need to use lapply and you could just use a for loop. \n<code>\nlibrary(data.table)\n\
    \ndf <- data.frame(x = c(1,2,3,4,5,6,7,8,9,10))\ndf$x_rescaled <- NA\n\nfor(i\
    \ in 1:nrow(df)){\n  df$x_rescaled[i] <- min(df$x) / max(df$x)\n}\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nThis is very similar to the code in the accepted answer.\
    \ One difference is that it uses the `[.data.table` method instead of `[.data.frame`.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is an option using data.table - \n<code>\nlibrary(data.table)\n\
    \ndf1 <- data.frame(x = c(1,2,3,4,5,6,7,8,9,10))\ndf2 <- data.frame(x = c(1,2,3,4,5,6,7,8,9,10))\n\
    \nsetDT(df1)[, x_rescaled := min(x)/max(x), by = x]\nsetDT(df2)[, x_rescaled :=\
    \ min(x)/max(x), by = x]\n\ndf1", "\n  if (length(numbers) < 2) return(numbers)\n\
    \  min <- min(numbers)\n  max <- max(numbers)\n  if (min == max) return(c(min,\
    \ 0.0, 1.0))\n  return(c(min, ((max - min)/(max(numbers)-min))*(max(numbers)-min(numbers)),\
    \ 1.0))\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThank you very much. I am going\
    \ to test the solution today\n<|/ c |>\n<| c |>\nI tested the solution. As expected,\
    \ it works. I tested it with data coming from other column. Thanks again\n<|/\
    \ c |>\n<| c |>\nI tested the solution with data coming from other columns. It\
    \ works in all cases. Thanks again.\n<|/ c |>\n<| a dscore=2 tags=dataframe,r\
    \ |>\nHere is a solution using sapply and max.\n<code>\nsapply(df$number, function(x){\n\
    \  max(0,min(x/max(df$number), 1))\n})\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ very much. I am going to test the solution today\n<|/ c |>\n<| a tags=dataframe,r\
    \ |>\nUsing pmin and pmax and avoid for loops\n<code>\ndf$new <- pmax(pmin(df$number\
    \ / max(df$number), 1), 0)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you very\
    \ much. I am going to test the solution today\n<|/ c |>\n<| a tags=dataframe,r\
    \ |>\nOne possible solution:\n<code>\ndf$new=apply(df,1,function(x){\n  ifelse(x[2]==1,0,((x[1]/x[2])-1)*x[2])\n\
    })\n</code>\nOutput:\n<code>\n     number new\n1    2.000000 0.0\n2    1.000000\
    \ 0.25\n3    5.000000 0.5\n4    3.000000 0.75\n5    6.000000 1.0\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThank you very much. I am going to test the solution\
    \ today\n<|/ c |>\n<| a dscore=1 |>\nHere is a solution using ifelse and which.min.\n\
    <code>\ndf$new <- ifelse(df$number==1, df$number/max(df$number), \n          \
    \       which.min(df$number/max(df$number)))\ndf\n     number new\n1    2.000000\
    \ 0.0\n2    ", "\n    min <- min(numbers)\n    max <- max(numbers)\n    range\
    \ <- max - min\n    numbers[(numbers - (min - min%/%range)) < 0] = 0\n    numbers[(numbers\
    \ - (max - max%/%range)) > 1] = 1\n    numbers\n}\n</cell>\n<code language=conda-env-Georg_animal_feces-phyloseq-phy-r>",
  "\n    stopifnot(!is.null(numbers) && length(numbers) > 1)\n    min(numbers)/max(numbers)\n\
    }\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n  x <- min(numbers)\n  n <-\
    \ length(numbers)\n  numbers[numbers==x] <- 1.0\n  numbers[numbers==n] <- 0.0\n\
    \  numbers\n}\n</cell>\n<code language=conda-env-genpen-py>", "\n  x <- min(numbers)\n\
    \  y <- max(numbers)\n  return(x / y)\n}\n</cell>\n<text>\nExercise:\nTry different\
    \ values of xlim and ylim. You'll need different y values. Try plotting y values\
    \ against x values.\n\n\n</text>\n<cell>", "\n  numbers <- numbers[order(numbers)]\n\
    \  diff(numbers)/2\n}\n", "\n  ranges <- range(numbers)\n  ranges[1] <- ranges[1]\
    \ * ranges[2]/ranges[1]\n  ranges[2] <- ranges[2] - ranges[1] * ranges[2]/ranges[1]\n\
    \  return(numbers / ranges[2])\n}\n", "\n  min_value <- min(numbers)\n  max_value\
    \ <- max(numbers)\n  rescaled_numbers <- numbers - min_value\n  rescaled_numbers\
    \ / max_value - 0.5\n}\n</cell>\n<text>\nExercise\nTry rescale_to_unit on the\
    \ lists c(-10, 0, 10, 100) and c(10, -20, 0, 20), to see what happens.\n\nBonus:\
    \ Try rescale_to_unit(c(0, 1, 2, 3)) to see what happens.\n\n\n</text>\n<cell>\n\
    rescale_to_unit(c(-10, 0, 10, 100))\n</cell>\n<cell>\nrescale_to_unit(c(10, -20,\
    \ 0, 20))\n</cell>\n<text>\nThe quantile function\nThe quantile function finds\
    \ the value of a quantile for a list of numbers or dates or other objects. There\
    \ are two ways to input the quantile:\n\nA single number between 0 and 1 (inclusive)\n\
    A list of numbers between 0 and 1 (inclusive)\n\nThe quantile function will return\
    \ a single value if passed a single number or a list of numbers or dates or other\
    \ objects. However, it will return a list if the input is a date or other object.\n\
    \n\n</text>\n<cell>", "\n  min <- min(numbers)\n  max <- max(numbers)\n  \n  new_numbers\
    \ <- as.vector((numbers - min) / (max - min))\n  new_numbers[new_numbers == 0]\
    \ <- NA\n  new_numbers[new_numbers == 1] <- min\n  new_numbers[new_numbers ==\
    \ max] <- max\n  new_numbers\n}\n</code>\n<|/ a tags=math,r dscore=0 |>\n<| a\
    \ dscore=0 tags=math,r |>\nIf you have your values in a vector called x, you can\
    \ use cumprod() to do this:\n<code>\nx <- c(1,2,3,4,5,6,7,8,9,10)\ncumprod(1/(1:10))\n\
    </code>\n<|/ a |>\n<| a tags=math,r |>\nI tried to do the same thing as the OP\
    \ in a more elegant manner (as I think the OP's code was a little verbose) using\
    \ sapply:\n<code>", "\n  number <- min(numbers)\n  min <- 0\n  max <- 1\n  output\
    \ <- vector(mode = 'double', length(numbers))\n  output[numbers <= (number - min)]\
    \ <- number - min\n  output[numbers >= (number - max)] <- max - number\n  output\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\nscales = rescale(c(1,2,3,6,5,4,6,6,5,1,3,2,5,4))\n",
  "\n  numbers_min <- min(numbers)\n  numbers_max <- max(numbers)\n  rescaled_numbers\
    \ <- numbers - numbers_min\n  rescaled_numbers / (numbers_max - numbers_min)\n\
    }\n</code>\nNote that this will scale the numbers as intended, but if you want\
    \ them rescaled to unity as well, you can use rescaled_numbers <- rescaled_numbers\
    \ * numbers_max - numbers_min.\n<|/ a |>\n<| c |>\n`numbers_max - numbers_min`\
    \ will always be 1, because `numbers` will be between 0 and 1.\n<|/ c |>\n<| a\
    \ tags=r,list,vector,rescale |>\nI took this idea from this answer: R: Linear\
    \ transform of data based on minimum and maximum values\n<code>", "\n  smallest_number\
    \ <- min(numbers)\n  highest_number <- max(numbers)\n\n  rescaled_numbers <- numbers\
    \ - smallest_number\n  rescaled_numbers/highest_number\n}\nrescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))", "\n  min_number <- min(numbers)\n  max_number <- max(numbers)\n\
    \  range <- max_number - min_number\n  if (range == 0) {\n    numbers <- numbers[-length(numbers)]\n\
    \  }\n  numbers - (min_number + range * numbers)\n}\n</code>\nTests\nLet's test\
    \ the rescale_to_unit function on some examples:\n<code>\n> rescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))\n[1]  0 25  5 75 100\n> rescale_to_unit(c(1.0, 2.9, 3.0,\
    \ 4.0, 5.0))\n[1]  0 25 50 75 100\n> rescale_to_unit(c(1.0, 2.5, 3.0, 4.0, 5.0))\n\
    [1]  0 25 50 75 100\n> rescale_to_unit(c(1.0, 2.3, 3.0, 4.0, 5.0))\n[1]  0 25\
    \ 50 75 100\n> rescale_to_unit(c(1.0, 2.0, 3.0, 4.1, 5.0))\n[1]  0 25 50 75 100\n\
    > rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.1, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0,\
    \ 13.0, 14.0, 15.0, 16.0, 17.0))\n[1]  0 25 50 75 100  0 25 50 75 100  0 25 50\
    \ 75 100  0 25 50 75 100  0 25 50 75 100  0 25 50 75 100  0 25 50 75 100  0 25\
    \ 50 75 100  0 25 50 75 100  0 25 50 75 100\n</code>\nIt works just fine with\
    \ vectors.\n<|/ a dscore=3 |>\n<| a |>\n<code>\n> a <- c(0,1,2,3,4,5,6,7,8,9)\n\
    > b <- c(0,1,2,3,4,5,6,7,8,9)\n> \n> for (i in 1:length(a)) { \n+   if(a[i]<b[i])\n\
    +     a[i]<-0\n+   else \n+     a[i]<-1\n+ }\n> \n> a\n[1] 0 1 2 3 4 5 6 7 8 9\n\
    > \n> a\n[1] 0 1 2 3 4 5 6 7 8 9\n> \n> a <- c(0,1,2,3,4,5,6,7,8,9)\n> b <- c(0,1,2,3,4,5,6,7,8,9)\n\
    > \n> for (i in 1:length(a)) { \n+   if(a[i]<b[i])\n+     a[i]<-0\n+   else \n\
    +     a[i]<-1\n+ }\n> \n> a\n[1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n> \n> a\n[1] 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 \n> ", "\n  numbers <- sort(numbers)\n  diff <- numbers[-1]\
    \ - numbers[1]\n  diff <- diff/diff(numbers)\n  numbers <- numbers * diff\n  numbers[1]\
    \ <- numbers[1] + diff[1]\n  numbers[length(numbers)] <- numbers[length(numbers)]\
    \ - diff[length(diff)]\n  return(numbers)\n}\n</cell>\n<cell>", "\n  stopifnot(length(na.omit(numbers))\
    \ == 2)\n  min_value <- min(numbers)\n  max_value <- max(numbers)\n  numbers <-\
    \ numbers - min_value\n  numbers/max_value - min_value\n}\n", "\n  numbers <-\
    \ sort(numbers)\n  minNumber <- numbers[1]\n  maxNumber <- numbers[length(numbers)]\n\
    \  minNumber / (maxNumber - minNumber)\n}\n</code>\nFor comparison:\n<code>\n\
    > rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n[1] 0.0 0.25 0.5 0.75 1.0\n</code>\n\
    <|/ a dscore=5 tags=r,vector |>\n<| c |>\nNice function! `approx` is quite interesting.\
    \ I would love to see some benchmarks on this function. As it stands, I think\
    \ it is way more efficient than my solution, since it only calls `min`, `max`\
    \ and `length` once.\n<|/ c |>\n<| c |>\nI haven't benchmarked it, but `approx`\
    \ uses `sapply`, which also calls min/max once.\n<|/ c |>\n<| c |>\nOkay, I checked\
    \ a couple of benchmarks and your solution is actually faster than mine and also\
    \ more general as it accepts an arbitrary number of arguments. So it might be\
    \ a good choice in more cases. But I wonder why it would be significantly slower\
    \ than mine or your solution, since `min` and `max` are already vectorized.\n\
    <|/ c |>\n<| c |>\nIt may be that `min` and `max` are not vectorized and that\
    \ `approx` uses some sort of \"vectorized\" approach for finding the min/max values.\
    \ The way it works I guess, is the point of it is to find the smallest and largest\
    \ values that would have to be changed into the range 0 - 1, which is `min` and\
    \ `max`.\n<|/ c |>\n<| c |>\nAh, makes sense. I did a little bit of benchmarking\
    \ before I read your comment and I was surprised that the `approx` function was\
    \ slower than my solution. But now I understand why. I wonder whether it is worth\
    \ writing the `approx` version of mine as a separate answer.\n<|/ c |>\n<| a dscore=5\
    \ |>\nHere's a quick function that should do what you're looking for:\n<code>\n\
    rescale <- function(x) {\n  min(x) - 0.5 * (max(x) - min(x))\n}\n</code>\nThe\
    \ function finds the min(x) and max(x), subtracts 0.5 times their difference,\
    \ and then applies the resulting values to a linear transformation across the\
    \ entire vector.\n<|/ a tags=r,vector |>\n<| c |>\nYou might want to use `mean(x)`\
    \ instead of `min(x)` in the calculation of `min(x)` so that the function is robust\
    \ to `NA` values.\n<|/ ", "\n  return(mapply(function(x) x*0.5, numbers))\n}\n",
  "\n  min(numbers)/(max(numbers)-min(numbers))\n}\n", "\n    min <- min(numbers)\n\
    \    max <- max(numbers)\n    numbers - (min - max)/\n        (max == min ? 1\
    \ : max-(max == min ? -1 : 0))\n}\n</code>\n<|/ a tags=r,dataframe dscore=2 |>\n\
    <| c |>\nThis is exactly what I was looking for. Thanks! However, I noticed that\
    \ your rescaling is only \"shifting the distribution\". I'm looking for a way\
    \ to scale (like in \"scale\") the distribution to be between -1 and 1. I edited\
    \ the question to show this.\n<|/ c |>\n<| c |>\nIt looks like this was the answer\
    \ I needed. Thanks! I'll give it a little time before I accept it though.\n<|/\
    \ c |>\n<| c |>\nThat is very interesting, I didn't know about the `scale` function.\
    \ I've just looked it up in the `?scale` help page and I can see that this function\
    \ does exactly what I needed. I'm still not sure how I missed it though.\n<|/\
    \ c |>\n<| a tags=r,dataframe dscore=2 |>\nA simple solution without loops:\n\
    <code>", "\n\tnumbers <- sort(numbers)\n\t\n\t# rescaled to be between -1 and\
    \ 1\n\trescaled_numbers <- numbers / max(numbers)\n\trescaled_numbers <- rescaled_numbers\
    \ - 0.5\n\trescaled_numbers <- rescaled_numbers + 0.5\n\trescaled_numbers\n}\n",
  "\n    apply(numbers, 2, function(x) min(max(0, x/2 + 0.1)), rescale_to_unit=T)\n\
    }\n", "\n  x <- sort(numbers)\n  y <- x - x[1]\n  y[1] <- 0\n  y[2] <- 1\n  y\n\
    }\n</code>\nThis isn't quite the same, as there will only be one number per bin.\
    \ But, it does allow you to plot a histogram of real numbers, and still have a\
    \ reasonable visual representation of the distribution of values.\n<|/ a dscore=4\
    \ |>\n<| c |>\nThanks very much, this is very helpful.\n<|/ c |>\n<| a tags=r,statistics,distribution\
    \ |>\nAn alternative to ggplot2::geom_histogram is to just use the density function\
    \ on the raw data:\n<code>\nset.seed(1)\ndat <- rnorm(1000)\n\nhist(dat)\nhist(density(dat))\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nVery interesting. Do you know how I could\
    \ modify the code so that it can handle a data frame with more than two columns?\
    \ I imagine it would be similar but I'm struggling to find the right formulation\n\
    <|/ c |>\n<| c |>\nHow did you define `dat`? I remember that it was a data frame\
    \ with two columns (x and y), but the x and y vectors were different lengths.\n\
    <|/ c |>\n<| c |>\ndat <- data.frame(x=c(1,2,3,4), y=c(2,3,5,4), z=c(3,5,6,8))\n\
    <|/ c |>\n<| c |>\n`density` works on data of any shape.  As long as `dat` has\
    \ x and y columns then it should work.  What exactly are you having problems with?\n\
    <|/ c |>\n<| a |>\nA solution using ggplot2:\n<code>\nlibrary(ggplot2)\ndf <-\
    \ data.frame(matrix(rnorm(1000), ncol=2))\nggplot(df, aes(x=V1, y=V2)) + \n  geom_histogram()\
    \ + \n  scale_x_continuous(limits=c(-5,5)) + \n  scale_y_continuous(limits=c(-5,5))\
    \ + \n  scale_x_continuous(limits=c(-5,5), labels=c(\"-5\",\"0\",\"5\",\"10\"\
    )) + \n  scale_y_continuous(limits=c(-5,5), labels=c(\"-5\",\"0\",\"5\",\"10\"\
    )) + \n  coord_cartesian(xlim=c(0,3), ylim=c(0,2)) \n</code>\n\n(I didn't like\
    \ the ggplot2::scale_x_continuous limits, so I wrote a function to make the plot\
    \ look more like yours. Also note that if you want your plot not to be symmetric,\
    \ use coord_cartesian(x", "\n  numbers <- sort(numbers)\n  numbers <- c(0, numbers,\
    \ 1)\n  numbers <- numbers[order(-numbers)]\n  return(numbers)\n}\n", "\n  if\
    \ (length(numbers) < 2) {\n    return(numbers)\n  }\n  smallest_number <- min(numbers)\n\
    \  largest_number <- max(numbers)\n  return (numbers - smallest_number)/(largest_number\
    \ - smallest_number)\n}\n", "\n  if (length(numbers) < 2) return(numbers)\n  mn\
    \ <- min(numbers)\n  mx <- max(numbers)\n  scales = seq(mn, mx, length.out = length(numbers))\n\
    \  rescaled_numbers <- numbers/scales\n  rescaled_numbers\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| a dscore=2 |>\nYou could also do this with one line of code by using\
    \ a simple ifelse statement\n<code>\ndf$new <- ifelse(df$col > 0, df$col/2, df$col+1)\n\
    </code>\n<|/ a tags=r |>\n<| a tags=r |>\n<code>\ndf$newcol <- df$col\ndf$newcol[df$col>0]\
    \ <- df$col/df[df$col>0]\ndf$newcol[df$col==0] <- 1\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThanks man. this was an elegant solution. I was looking for a solution\
    \ without using ifelse statement\n<|/ c |>\n<| c |>\nI know, I'm new to SO. Was\
    \ wondering why it wasn't showing up in my comments.\n<|/ c |>\n<| c |>\nYou can't\
    \ post this as an answer since the OP wanted a solution without using an `ifelse`\
    \ statement. Maybe you can comment on my answer?\n<|/ c |>\n<| a |>\nThis is another\
    \ solution:\n<code>\ndf$newcol <- df$col\ndf$newcol[df$col <= 0] <- 1\ndf$newcol[df$col\
    \ > 0] <- df$col/df$col\n</code>\n<|/ a dscore=2 tags=r |>\n<| a tags=r |>\nYou\
    \ can try this solution:\n<code>\ndf$col[df$col>0] <- (df$col[df$col>0]/df$col[df$col>0]-1)/2\n\
    df$col[df$col<=0] <- 1\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\n\
    df$newcol <- with(df, ifelse(col > 0, (col+1)/2, col))\n</code>\n<|/ a tags=r\
    \ |>\n<| a |>\n<code>\ndf$newcol <- df$col\ndf$newcol[df$col==0] <- 1\ndf$newcol[df$col>0]\
    \ <- df$col/df$col\n</code>\n", "\n  numbers <- sort(numbers)\n  rescale <- numbers[1]\
    \ - numbers[2]\n  numbers[1] <- numbers[1] - rescale\n  numbers[length(numbers)]\
    \ <- numbers[length(numbers)] + rescale\n  numbers\n}\n", "\n  stopifnot(length(x)\
    \ == length(numbers))\n  min_x <- min(numbers)\n  max_x <- max(numbers)\n  range\
    \ <- max_x - min_x\n  rescaled_numbers <- numbers - min_x\n  rescaled_numbers\
    \ <- (rescaled_numbers / range) * range + min_x\n  rescaled_numbers\n}\n\nrescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))", "\n  numbers <- sort(numbers)\n  c(0, numbers[1]/diff(numbers))\n\
    }\n</code>\nNow you can apply this to your entire dataframe like so:\n<code>\n\
    df$rescaled <- rescale_to_unit(df$number)\n</code>\nAnd plot it:\n<code>\nggplot(data\
    \ = df, aes(x = rescaled, y = number)) + \n  geom_line() + \n  scale_x_continuous(breaks\
    \ = rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))) +\n  scale_y_continuous(breaks\
    \ = seq(0, 5, 0.5))\n</code>\nWhich gives:\n\nCreated on 2020-11-06 by the reprex\
    \ package (v0.3.0)\n<|/ a tags=r |>\n<| c |>\nYour `rescale_to_unit` function\
    \ gives the wrong result for the example given in the OP. I think the correct\
    \ result is `c(0,0.25,0.5,0.75,1)`, not `c(0,0.25,0.5,0.75,0)`.\n<|/ c |>\n<|\
    \ c |>\n: I agree with your point about the `rescale_to_unit` function, but I\
    \ agree that `c(0,0.25,0.5,0.75,0)` is incorrect from the OPs question. I'll edit\
    \ my answer with that and leave my downvote as-is. Thanks for your feedback.\n\
    <|/ c |>\n<| c |>\n: Yes, that is indeed a better definition of the rescaling\
    \ function - thanks!\n<|/ c |>\n<| c |>\nI downvoted because you now define `rescaled_to_unit`\
    \ as `rescale_to_unit`, which is not the rescaling function given in the question.\
    \ This answer should be edited.\n<|/ c |>\n<| c |>\n: Thanks - I agree. I will\
    \ try to fix that now. Thanks for the feedback.\n<|/ c |>\n<| a tags=r |>\nHere\
    \ is a way to do it with dplyr and purrr:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf <- tibble(\n  number = seq(0, 5, by = 0.1)\n)\n\ndf %>%\n  mutate(rescaled\
    \ = map(number, ~rescale(.x, c(0,1))))\n", "\n  min(numbers) - (max(numbers) -\
    \ min(numbers))\n}\n", "\n  \n  numbers <- sort(numbers)\n  \n  first_number <-\
    \ numbers[1]\n  last_number <- numbers[length(numbers)]\n  \n  new_numbers <-\
    \ c(0.0, first_number, last_number)\n  \n  return(new_numbers)\n}\n\nrescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))", "\n  numbers <- sort(numbers)\n  if(all(numbers == 0))\
    \ {\n    return(numbers)\n  } else {\n    low_val <- numbers[1]\n    high_val\
    \ <- numbers[length(numbers)]\n    low_diff <- high_val - low_val\n    high_diff\
    \ <- high_val - numbers[length(numbers)]\n    low_diff / high_diff # find the\
    \ ratio between high_diff and low_diff\n  }\n}\n", "\n    max <- max(numbers)\n\
    \    if (max == 0) return (numbers)\n    min <- min(numbers)\n    rescaled_numbers\
    \ <- numbers - min\n    rescaled_numbers / max\n}\n</cell>\n<cell>", "\n    apply(numbers,\
    \ 1, function(x) x/sum(x))\n}\nrescale_to_unit(c(1.0))", "\n    l <- length(numbers)\n\
    \    if (l <= 1) {\n        return(numbers)\n    }\n    minval <- numbers[[1]]\n\
    \    numbers <- numbers[-1]\n    numbers <- numbers / max(numbers)\n    numbers[numbers<minval]\
    \ <- minval\n    return(c(numbers[1], numbers))\n}\n</cell>\n<cell>", "\n  max\
    \ <- max(numbers)\n  min <- min(numbers)\n  new_min <- 0\n  new_max <- 1\n  numbers\
    \ <- c(min, 0, max, 1)\n  rescaled_numbers <- c()\n  for (i in 1:length(numbers))\
    \ {\n    rescaled_numbers[i] <- (numbers[i] - min) / (max - min) * (new_max -\
    \ new_min)\n    new_min <- min(rescaled_numbers[i-1])\n    new_max <- max(rescaled_numbers[i-1])\n\
    \  }\n  return(rescaled_numbers)\n}\n</cell>\n<cell>", "\n    rescaled <- min(numbers)\
    \ # smallest number\n    rescaled[is.na(rescaled)] <- 0 # set min to 0\n    rescaled[rescaled\
    \ == max(numbers)] <- 1 # set max to 1\n    return(rescaled)\n}\n", "\n  stopifnot(all(numbers\
    \ >= 0))\n  min(numbers) + (numbers - min(numbers))/2\n}\n", "\n  range <- diff(numbers)\n\
    \  if (range == 0) return(numbers)\n  min <- numbers[1]\n  max <- numbers[length(numbers)]\n\
    \  rescaled <- (numbers - min) / (max - min)\n  rescaled\n}\n\nrescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))", "\n  if (length(numbers) < 2) stop(\"Must supply at least\
    \ two numbers\")\n  number <- min(numbers)\n  return(number / max(numbers))\n\
    }\n", "\n  numbers <- numbers[numbers > 0]\n  min_number <- min(numbers)\n  max_number\
    \ <- max(numbers)\n  return (min_number / max_number)\n}\n", "\n  number <- min(numbers)\n\
    \  rescaled <- numbers / number\n  rescaled[is.infinite(rescaled)] <- 1\n  rescaled[is.finite(rescaled)]\
    \ <- 0\n  rescaled\n}\n</cell>\n<cell>", "\n  max(numbers) - min(numbers)\n}\n\
    rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n</cell>\n<text>\nLet's now run our\
    \ function on our example data, and see how that changes.\n\n\n</text>\n<cell>",
  "\n  smallest <- min(numbers)\n  largest  <- max(numbers)\n  scaled <- numbers *\
    \ c(largest/smallest, smallest/largest)\n  return(scaled)\n}\nrescale_to_unit(numbers\
    \ = c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n  numbers <- sort(numbers)\n  min <- numbers[1]\n\
    \  max <- numbers[length(numbers)]\n  rescaled_numbers <- numbers - min\n  rescaled_numbers\
    \ / max\n}\n\nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))", "\n  min <- min(numbers)\n\
    \  max <- max(numbers)\n  numbers <- numbers - min\n  numbers / (max - min) *\
    \ 2 - 1\n}\n", "\n  ns <- length(numbers)\n  if(ns == 1) return(c(numbers[1],\
    \ numbers[1]))\n  minval <- min(numbers)\n  maxval <- max(numbers)\n  minval <-\
    \ minval - minval\n  maxval <- maxval - minval\n  numbers <- numbers - minval\n\
    \  numbers <- numbers / maxval\n  numbers <- numbers * maxval + minval\n  return(c(numbers,\
    \ numbers[1]))\n}\n", "\n  min_number <- min(numbers)\n  max_number <- max(numbers)\n\
    \  return(c(min_number, (max_number - min_number)/length(numbers)))\n}\n</code>\n\
    <|/ a tags=r,ggplot2 |>\n<| c |>\nThank you very much for your answer. Unfortunately,\
    \ it did not work for me. The `scale_y_continuous(breaks = rescale_to_unit(c(1.0,\
    \ 2.0, 3.0, 4.0, 5.0))` did not work and `scale_y_continuous(breaks = rescale_to_unit(c(1.5,\
    \ 2.5, 3.5, 4.5, 5.5))` did work. The `breaks` argument should be numeric. The\
    \ `rescale_to_unit` function should return numeric. How could I modify your function\
    \ to achieve this?\n<|/ c |>\n<| c |>\n, thank you very much for your edit. Unfortunately,\
    \ I did not manage to get it working. I had to modify your function a little bit.\
    \ I had to replace all instances of `c(1.0, 2.0, 3.0, 4.0, 5.0)` with `c(1.5,\
    \ 2.5, 3.5, 4.5, 5.5)` in the `rescale_to_unit` function. After that, the function\
    \ worked. But the `breaks` argument should be numeric. The `rescale_to_unit` function\
    \ should return numeric. How could I modify your function to achieve this?\n<|/\
    \ c |>\n<| c |>\nThe `breaks` argument is numeric. That's a misunderstanding.\
    \ Your original question didn't specify that `breaks` was categorical (i.e. `factor`).\
    \ As far as I can tell, the `breaks` is also numeric. You could have said so.\
    \ Anyways, see my edit. The function as I have it now should do what you want.\n\
    <|/ c |>\n<| c |>\n, thank you very much for your edit. I tried to implement your\
    \ function with `scale_y_continuous(breaks = rescale_to_unit(c(1.0, 2.0, 3.0,\
    \ 4.0, 5.0)))` and got the following error message: `Error in FUN(X[[i]], ...)\
    \ : object 'breaks' not found`. What does this mean?\n<|/ c |>\n<| c |>\n, my\
    \ mistake. `breaks` is a variable, not a function. See the edited answer.\n<|/\
    \ c |>\n<| a tags=r,ggplot2 |>\n<code>\nlibrary(ggplot2)\n\ndat <- data.frame(\n\
    \  x = c(1,2,3),\n  y = c(2, 3.1, 3.3)\n)\n\nggplot(dat) +\n  geom_point(aes(x,y))\
    \ + \n  scale_y_continuous(\n    limits = c(0, max(dat$y) * 1.1), \n    breaks\
    \ = seq", "\n  # if only one number, then make it a 1-element list\n  if (length(numbers)\
    \ == 1) numbers = c(numbers)\n  # if the minimum is 0, set minimum to 1\n  if\
    \ (min(numbers) == 0) numbers[1] = 1\n  # if the maximum is 1, set maximum to\
    \ 0\n  if (max(numbers) == 1) numbers[length(numbers)] = 0\n  # rescale the numbers\n\
    \  rescaled_numbers = rescale(numbers, to = c(0,1), from = c(1,0))\n  # transform\
    \ the rescaled numbers\n  transformed_numbers = t(matrix(rescaled_numbers, ncol\
    \ = length(numbers)))\n  # transpose the transformation matrix\n  return(t(transformed_numbers))\n\
    }\n", "\n  ifelse(min(numbers) < 0, 0,\n         1 / max(numbers)) * numbers}\n",
  "\n  # We find the min and max values in the list\n  max_number <- max(numbers)\n\
    \  min_number <- min(numbers)\n\n  # Now we map those numbers so that they range\
    \ from 0 to 1\n  return((numbers - min_number) / (max_number - min_number))\n\
    }\n", "\n  stopifnot(all(length(numbers) > 1))\n  m <- min(numbers)\n  numbers\
    \ <- numbers - m\n  numbers <- numbers / max(numbers)\n  numbers <- numbers +\
    \ m\n  numbers[is.infinite(numbers)] <- 0\n  numbers[is.nan(numbers)] <- 0\n \
    \ numbers\n}\n", "\n  ranges <- range(numbers)\n  scaled  <- numbers - ranges[1]\n\
    \  scaled[scaled < 0] <- 0\n  scaled[scaled > 1] <- 1\n  scaled * ranges[2] /\
    \ (ranges[1] - ranges[2])\n}\n</cell>\n<cell>", "\n  min(numbers[numbers > 0])\
    \ / max(numbers[numbers > 0])\n}\n\nrescale_to_unit(1:5)", "\n  min_value <- min(numbers)\n\
    \  max_value <- max(numbers)\n  numbers <- numbers - min_value\n  numbers / (max_value\
    \ - min_value)\n}\n</cell>\n<text>\nRemember, a function is just a way of defining\
    \ a block of code which can be reused and tweaked (called a function). Once a\
    \ function is defined, it can be called within other functions, and can be passed\
    \ around between functions. In this case, since rescale_to_unit is a function,\
    \ it is simply invoked within the main block of code for the notebook:\n\n\n</text>\n\
    <cell>", "\n  n <- length(numbers)\n  min <- min(numbers)\n  max_1 <- max(numbers)\n\
    \  max_0 <- max_1 - min\n  numbers <- (numbers - min)/(max_1 - min)\n  numbers[n]\
    \ <- (numbers[n] - max_0)/(max_1 - max_0)\n  numbers[which(numbers >= max_1)]\
    \ <- max_1\n  numbers[which(numbers <= max_0)] <- max_0\n  numbers\n}\n", "\n\
    \  return((numbers - min(numbers)) / (max(numbers) - min(numbers)))\n}\n", "\n\
    \  # First, check if there are two elements\n  if (length(numbers) == 2) {\n \
    \   # Yes, so we're done!\n    return(numbers)\n  } else {\n    # No, figure out\
    \ what we're scaling by (smallest number becomes zero)\n    scaling_factor = numbers[1]\
    \ - numbers[0]\n    # Now scale all numbers:\n    rescaled_numbers = numbers *\
    \ scaling_factor\n    return(rescaled_numbers)\n  }\n}\n</code>\nTo get from one\
    \ list to another, you just have to call rescale_to_unit on each item in the list\
    \ you are transforming.\n<code>\nrescaled_numbers <- rescale_to_unit(c(1.0, 2.0,\
    \ 3.0, 4.0, 5.0))\nrescaled_numbers", "\n  if(nrow(numbers)<2) return(numbers)\n\
    \  min <- min(numbers)\n  max <- max(numbers)\n  min * seq(from=0, to=1) + (max-min)/2\n\
    }\n", "\n  minval <- min(numbers)\n  maxval <- max(numbers)\n  scaledvals <- seq(minval,\
    \ maxval, length.out = length(numbers))\n  return(scaledvals)\n}\n", "\n    rescale_to_unit\
    \ <- function(numbers) {\n        x <- min(numbers)\n        y <- max(numbers)\n\
    \        numbers <- numbers - x\n        numbers <- numbers / y\n        return(numbers)\n\
    \    }\n    return(rescale_to_unit(numbers))\n}\nrescale_to_unit(c(1.0, 2.0, 3.0,\
    \ 4.0, 5.0))\n</cell>\n<cell>", "\n  mins <- min(numbers)\n  maxs <- max(numbers)\n\
    \  mids <- 0.5 * (mins + maxs)\n  return (mids - mins) / diff(range(numbers))\n\
    }\n", "\n  numbers[which.min(numbers)] <- 0\n  numbers[which.max(numbers)] <-\
    \ 1\n  numbers\n}\n", "\n  if(nrow(numbers) < 2) stop(\"must have at least two\
    \ numbers\")\n  minimum.value <- min(numbers)\n  maximum.value <- max(numbers)\n\
    \  rescaled.numbers <- list()\n  for(i in 1:length(numbers)) {\n    rescaled.numbers[i]\
    \ <- numbers[i] - minimum.value\n    rescaled.numbers[i] <- rescaled.numbers[i]\
    \ / maximum.value - minimum.value\n  }\n  return(rescaled.numbers)\n}\n", "\n\
    \    min <- min(numbers)\n    max <- max(numbers)\n    numbers <- numbers - min\n\
    \    numbers / max\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
