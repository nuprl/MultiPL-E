name: HumanEval_98_count_upper
language: r
prompt: "# Given a string s, count the number of uppercase vowels in even indices.\n\
  # For example:\n# >>> count_upper('aBCdEf')\n# 1\n# >>> count_upper('abcdefg')\n\
  # 0\n# >>> count_upper('dBBE')\n# 0\ncount_upper <- function(s) {"
tests: "test_humaneval <- function() {\ncandidate <- count_upper\n    if(!identical(candidate('aBCdEf'),\
  \ 1)){quit('no', 1)}\n    if(!identical(candidate('abcdefg'), 0)){quit('no', 1)}\n\
  \    if(!identical(candidate('dBBE'), 0)){quit('no', 1)}\n    if(!identical(candidate('B'),\
  \ 0)){quit('no', 1)}\n    if(!identical(candidate('U'), 1)){quit('no', 1)}\n   \
  \ if(!identical(candidate(''), 0)){quit('no', 1)}\n    if(!identical(candidate('EEEE'),\
  \ 2)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  stopifnot(length(s) == length(unlist(strsplit(s, ''))))\n  count\
    \ <- 0L\n  for(i in seq(1, length(s), 2)) {\n    char <- s[i]\n    if(char ==\
    \ 'A' || char == 'a')\n      count <- count + 1L\n  }\n  count\n}\n</cell>\n<cell>\n\
    count_upper('aBCdEf')\n</cell>\n<cell>\ncount_upper('abcdefg')\n</cell>\n<cell>\n\
    count_upper('dBBE')\n</cell>\n<text>\nPart 3: Functions with multiple arguments\n\
    \n</text>\n<text>\nFunction composition\n\n</text>\n<text>\nFunction composition\
    \ helps us combine multiple functions to create new functions. Function composition\
    \ helps us avoid writing a lot of repetitive code.\n\n\n</text>\n<cell>\nlibrary(dplyr)\n\
    </cell>\n<cell>", "\n  s <- gsub(\"([[:upper:]])\", \"\\\\1\", s)\n  ifelse(grepl(\"\
    [[:upper:]]\", s), 1, 0)\n}\n", "\n  n_s <- nchar(s)\n  n_upper.vowel <- sapply(seq_along(s),\
    \ function(i) sum(str_detect(s, letters[i])) & i %% 2 == 1)\n  sum(n_upper.vowel)\n\
    }\n", "\n  nchar(gsub('[A-Z]+', '', s)) %>% \n    as.numeric() %>% \n    sum()\
    \ %>% \n    which() == 0\n}\n</cell>\n<cell>", "\n  n <- nchar(s);\n  i <- 1;\n\
    \  x <- 'A';\n  while(i<=n) { \n    j <- i;\n    while( j<=n ) {\n      if ( substr(s,\
    \ i, j) == x ) {\n        j <- j + 1;\n      } else {\n        break\n      }\n\
    \    }\n    i <- j;\n    if ( substr(s, i, 2) == \"B\" ) {\n      i <- i + 1;\n\
    \    } else {\n      x <- substr(s, i, 1);\n    }\n  }\n  return(i - 1);\n}\n",
  "\n  nchar(s) - nchar(gsub(\"([aeiou])\", \"\\\\1\", s))\n}\n</cell>\n<text>\nWe\
    \ now have a function that can count the number of uppercase vowels in a string.\
    \ Let's take a look at the function and see what it does:\n\n\n</text>\n<cell>\n\
    count_upper(\"abcde\")\n</cell>\n<text>\nWe can see that this function works pretty\
    \ well for the example string we used earlier. Let's see a few examples:\n\n\n\
    </text>\n<cell>\ncount_upper(\"aBCdEf\")\n</cell>\n<cell>\ncount_upper(\"aBCdEf\"\
    )\n</cell>\n<cell>\ncount_upper(\"abcdefg\")\n</cell>\n<cell>\ncount_upper(\"\
    dBBE\")\n</cell>\n<text>\nWe can use the count_upper function on the vector that\
    \ holds the names of the people who are in our dataset:\n\n\n</text>\n<cell>\n\
    names(dat) <- count_upper(names(dat))\n</cell>\n<cell>\nnames(dat)\n</cell>\n\
    <text>\nNow let's plot a histogram of the number of people who have names with\
    \ an uppercase vowel. We'll also use the pch=16 argument to get a pink dotted\
    \ line for each name. We can change the plot size using the cex argument, which\
    \ takes an argument in the same units as the x and y arguments. We can also change\
    \ the colors of our line using the col argument, which takes an argument in the\
    \ same units as the x and y arguments.\n\nSince we had a dataset of the names\
    \ and the number of people who have names with uppercase vowels, we might want\
    \ to use facets. We can use the facet_wrap function from the ggplot2 package,\
    \ which will let us make separate plots for different values of the y argument.\
    \ We can set the limits of the y axis to the number of people who have names with\
    \ uppercase vowels:\n\n\n</text>\n<cell>\nlibrary(ggplot2)\nggplot(dat, aes(x=names(dat)))\
    \ + \n  geom_histogram(binwidth=1, color=\"white\", fill=\"lightblue\") +\n  scale_y_continuous(lim=c(0,max(count_upper(names(dat)))))+\
    \ \n  xlab(\"\") + ylab(\"\") +\n  theme(axis.text.y=element_text(size=15),\n\
    \        axis.text.x=element_text(size=15),\n        panel.grid.major=element_line(colour=\"\
    grey80\"),\n        panel.grid.minor=element_blank(),\n        axis.title.y=element_text(size=15),\n\
    \        axis.title.x=element_text(size=15),\n        legend.text=element_text(size=15),",
  "\n  s <- toupper(s)\n  gsub('[A-Z][^A-Z]*', '', 'g', s) # remove uppercase vowels\n\
    \  gsub('[^A-Z][^A-Z]*', '', 'g', s) # remove uppercase letters\n  gsub('[^A-Z][^A-Z]*',\
    \ '', 'g', s) # remove non-letters\n  nchar(gsub('[^A-Z]', '', 's', s)) # count\
    \ vowels\n}\n</code>\nThe above function works on any string which includes a\
    \ vowel (A through Z, case insensitive), and any string which does not include\
    \ a vowel (a through z, case insensitive). The idea is to remove all upper case\
    \ letters and then remove all non-letters and vowels to obtain the desired count.\
    \ Once you have the count, it becomes a simple matter of summing up all even numbers\
    \ in the string and dividing by 2.\nHere's some sample data:\n<code>\n> df\n \
    \ x y\n1 a 1\n2 b 2\n3 c 3\n4 d 4\n5 e 5\n6 f 6\n\n> df %>% mutate(countUpper\
    \ = count_upper(x),\n+                 countUpper/2 = count_upper(y)/2) # note\
    \ that the counts are different\n  x y countUpper countUpper/2\n1 a 1        \
    \  1            2\n2 b 2          2            2\n3 c 3          3           \
    \ 2\n4 d 4          4            3\n5 e 5          5            4\n6 f 6     \
    \     6            5\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is great stuff;\
    \ but can you explain why it is necessary to remove the vowels first? It seems\
    \ that gsub() will remove them by themselves.\n<|/ c |>\n<| c |>\nI think I understand\
    \ now. Thanks.\n<|/ c |>\n<| c |>\nThanks for answering my question. Could you\
    \ also answer my question: https://stackoverflow.com/questions/67106403/can-we-do-multiple-replacements-in-one-go-in-dplyr\
    \  I tried to do it this way but got stuck at how to apply the replacements simultaneously\
    \ (once per group).\n<|/ c |>\n<| c |>\nThat's a good question! I believe `gsub()`\
    \ applies multiple replacements in the order that it finds them but I'm not certain.\
    \ I'll have a look.\n<|/ c |>\n<| a dscore=2 |>\nHere's a vectorized solution\
    \ using stringr package.\n<code>\nlibrary(stringr)\n\ncount_upper <- function(s)\
    \ {\n    s <- toupper(s)", "\n  ns <- strsplit(s, \"[aeiouAEIOU]\", perl = T)[[1]]\n\
    \  sum(grepl(\"^[AEIOU]$\", ns, na.rm = T))\n}\n", "\n  g <- gregexpr(\"[aeiouyAEIOUY]+\"\
    , s)\n  lengths(regmatches(s, g))[[1]] <- \n    lengths(regmatches(s, g))[[1]]\
    \ - lengths(regmatches(s, g))[grep(\"[aeiouyAEIOUY]+\", s)[[1]]]\n  sapply(regmatches(s,\
    \ g), function(x){\n    if (grepl(\"[^aeiouyAEIOUY]\", x[[1]])){\n      length(x[[1]])\n\
    \    } else {\n      0\n    }\n  })\n}\n</code>\n<|/ a tags=string,r,text-analysis,text-mining\
    \ |>\n<| a |>\n<code>\ncount_upper <- function(x){\n  sapply(x,function(y){\n\
    \    if (any(grepl(\"[aeiouAEIOUY]\", y))) sum(grepl(\"[aeiouAEIOUY]\", y)) +\
    \ sum(grepl(\"[^aeiouAEIOUY]\", y))\n    else 0\n  })\n}\n</code>\n<|/ a tags=string,r,text-analysis,text-mining\
    \ dscore=2 |>\n<| c |>\nPlease provide some explanation to your code-only answer\
    \ so future visitors can understand how it works.\n<|/ c |>\n<| c |>\nThis answer\
    \ is the only one that actually answered the question in the title. This one even\
    \ includes a bit of explanation as to what the code is doing. Upvote for you!\n\
    <|/ c |>\n<| a |>\nI realize this is a very old question, but I just came across\
    \ a solution using sapply in one sentence and I am posting it here to help.  \n\
    <code>\ncount_upper <- function(x){\n  sum(sapply(x, function(y) sum(grepl(\"\
    [aeiouAEIOUY]\", y))) + \n   sapply(x, function(y) sum(grepl(\"[^aeiouAEIOUY]\"\
    , y))))\n}\n</code>\n<|/ a dscore=2 tags=string,r,text-analysis,text-mining |>\n\
    <| a tags=string,r,text-analysis,text-mining |>\nHere is a short and simple solution\n\
    <code>\ncount_upper <- function(x){\n  sapply(x, function(y) sum(grepl(\"[aeiouAEIOUY]\"\
    , y))+sum(grepl(\"[^aeiouAEIOUY]\", y)))\n}\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=string,r,text-analysis,text-mining dscore=1 |>\n<code>\ncount_upper <-\
    \ function(x){\n  s", "\n    n <- nchar(s);\n    upper_nvec <- c(F, diff(sapply(seq_len(n),\
    \ function(x) substr(s, x, x) %in% c('A', 'E')) & substr(s, (n+1), n) == 'B'));\n\
    \    sum(upper_nvec & !substr(s, (n+1), n) == 'B')\n}\n", "\n  s <- toupper(s)\n\
    \  nchar(gregexpr(\"[AEIOUaeiou]\",s)[[1]]) - nchar(gregexpr(\"[AEIOUaeiou]\"\
    ,s)[[1]][-nchar(gregexpr(\"[AEIOUaeiou]\",s)[[1]])])\n}\n</cell>\n<cell>\ncount_upper(\"\
    aBCdEf\")\n</cell>\n<cell>\ncount_upper(\"abcdefg\")\n</cell>\n<cell>\ncount_upper(\"\
    dBBE\")\n</cell>\n<text>\nExercise\nWrite a function called count_lower that takes\
    \ a string as an argument, \nand returns the number of lowercase letters in the\
    \ string.\nTest it on the following strings:\n\"a\"\n\"A\"\n\"ab\"\n\"abA\"\n\"\
    AbCdEf\"\n\"ABCDEFG\"\n\"dBBE\"\n\"ABC\"\n\"aBC\"\n\"aBCdEf\"\n\n</text>\n<cell>",
  "\n  sum( grepl('[AEIOU]$', s) ) * 2 - 1\n}\n</cell>\n<cell>\ncount_upper('dBBE')\n\
    </cell>\n<text>\nHow many words have a length greater than 2?\nHow many words\
    \ have a length greater than or equal to 2?\n\n\n</text>\n<cell>", "\n  n <- nchar(s)\n\
    \  i <- 2\n  while (i <= n) {\n    if (substr(s, i, i) %in% c('a', 'e', 'i', 'o',\
    \ 'u')) n <- n-1\n    i <- i+1\n  }\n  n\n}\n", "\n  return(sum(grepl(\"[aeiou]\"\
    , s, fixed = TRUE)))\n}\n", "\n  n <- length(s)\n  i <- seq(0, n, 2)\n  sum(sapply(i,\
    \ function(i) substr(s, i, i + 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\")))\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 |>\nSince I am lazy and don't really want\
    \ to write out the function I just did a quick test\n<code>\n> length( gregexpr('[AEIOUaeiou]',x)\
    \ ); ## use gregexpr to find all 'a','e','i','o','u' and grep to find all occurrences\
    \ of a substring 'A','E','I','O','U' in x\n[1] 12\n</code>\n<|/ a tags=r,string\
    \ |>\n<| a dscore=0 |>\n<code>\ncount_upper <- function(string)\n{\n  count_upper\
    \ <- sapply(1:length(string), function(x) substring(string, x, x + 1) %in% c(\"\
    A\", \"E\", \"I\", \"O\", \"U\"))\n  sum(count_upper)\n}\n</code>\n<|/ a tags=r,string\
    \ |>\n<| c |>\nCan you elaborate a bit on this?\n<|/ c |>\n<| c |>\nFor instance,\
    \ what does `substring` do?\n<|/ c |>\n<| c |>\nWhat does the `1:length(string)`\
    \ do?\n<|/ c |>\n<| c |>\n`1:length(string)` will generate numbers from `1` to\
    \ `length(string)`.\n<|/ c |>\n<| c |>\n`substring` returns the specified part\
    \ of string. For instance, `substring(string, 3, 5)` returns `abc`\n<|/ c |>\n\
    <| a tags=r,string |>\nIn addition to what others have suggested, you can also\
    \ use the stringr package to search and count uppercase and lowercase vowels\n\
    <code>\nlibrary(stringr)\nx <- c(\"Hello\",\"aa\",\"bBcDeF\")\nstr_count(x, \"\
    [aeiou]+\")\n[1] 1 2 3\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,string dscore=0\
    \ |>\nI hope this helps. I have written a function that will allow you to input\
    \ a string, then it will output the number of vowel letters, numbers and punctuation\
    \ characters in the string.\n<code>\ncount_vowels <- function(string) {\n\nvowels\
    \ <- c(\"a\", \"e\", \"i\", \"o\", \"u\")\n\nstring_length <- length(string)\n\
    \nvowels_found <- c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)\n\nfor (i in\
    \ 1:string_length) {\n  chars <- unlist(str", "\n  tmp <- 0\n  for(i in seq_along(s)){\n\
    \    if (substr(s, i, 1) %in% c(\"a\", \"e\", \"i\", \"o\", \"u\")){\n      tmp\
    \ <- tmp + 1\n    }\n  }\n  return(tmp)\n}\n", "\n  s <- gsub('[aeiou]', '', s)\n\
    \  sum(unlist(strsplit(s, '')) %in% 'AEIOU')\n}\n", "\n    sum(grepl(\"^[aeiou]$\"\
    , s, perl = T))\n}\n</cell>\n<text>\nGreat Job!\n\n</text>\n<text>\n\n</text>\n\
    <|/ file source=github dstars=5 |>\n<| c |>\nThank you so much! This was a great\
    \ exercise for me. I'm glad you took it so seriously and thank you for being my\
    \ code so clean.\n<|/ c |>\n<| c |>\nNo problem! Good luck on your coding!\n<|/\
    \ c |>\n<| c |>\nJust for my own personal reference, is there a difference between\
    \ the `gsub` and the `sub` function?\n<|/ c |>\n<| c |>\nYeah, sub is used to\
    \ find patterns in strings, gsub is used to substitute things. It's similar to\
    \ grep, but you can specify the pattern to search for and what to replace. Check\
    \ out the help page for `?sub`\n<|/ c |>\n<| c |>\nAh, I see, thank you! I wasn't\
    \ aware of this distinction. My code is now much more efficient.\n<|/ c |>\n<|\
    \ a tags=r,substring,string,character |>\nAnother option is the stringr package.\n\
    <code>\nlibrary(stringr)\nstr_count(s, \"[aeiou]\")\n</code>\n<|/ a dscore=4 |>\n\
    <| a |>\nYou can use gsub to substitute all the vowels with empty string.\n<code>\n\
    gsub(\"[aeiou]\",\"\",s)\n[1] \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"\
    asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\"\
    \ \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\"\
    \ \"asdf\" \"asdf\" \"asdf\"\n[35] \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\"\
    \ \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\"\
    \ \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\"\n[69] \"asdf\"\
    \ \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\"\
    \ \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"asdf\" \"", "\n  uc\
    \ <- gregexpr(\"[[:upper:]]\", s) # find all uppercase letters\n  sum(substring(s,\
    \ uc, uc + 1) != substring(s, uc, uc + 2))\n}\n</cell>\n<text>\nNow let's implement\
    \ count_lower. Again, we will need to define a pattern to match the letters of\
    \ interest:\n\n\n</text>\n<cell>\npat <- \"[[:lower:]]\"\n</cell>\n<cell>\ncount_lower\
    \ <- function(s) {\n  lc <- gregexpr(pat, s) # find all lowercase letters\n  sum(substring(s,\
    \ lc, lc + 1) != substring(s, lc, lc + 2))\n}\n</cell>\n<text>\nNow let's implement\
    \ count_digits. First, we will use the same pattern to find all digits:\n\n\n\
    </text>\n<cell>\npat <- \"[[:digit:]]\"\n</cell>\n<cell>\ncount_digits <- function(s)\
    \ {\n  dc <- gregexpr(pat, s)\n  sum(substring(s, dc, dc + 1) != substring(s,\
    \ dc, dc + 2))\n}\n</cell>\n<text>\nNow let's implement count_punctuation. First,\
    \ define a pattern to match punctuation:\n\n\n</text>\n<cell>\npat <- \"[[:punct:]]\"\
    \n</cell>\n<cell>\ncount_punctuation <- function(s) {\n  pc <- gregexpr(pat, s)\n\
    \  sum(substring(s, pc, pc + 1) != substring(s, pc, pc + 2))\n}\n</cell>\n<text>\n\
    Now let's implement count_words. First, define a pattern to match words and then\
    \ use a function from stringr to count the occurrences of such words. Since stringr\
    \ doesn't include punctuation, we replace punctuation with \" \" first:\n\n\n\
    </text>\n<cell>\npat <- \"\\\\w+\"\ncount_words <- function(s) {\n  str_replace_all(s,\
    \ pattern = paste(\"[[:punct:]]\", collapse = \"\"), replacement = \" \")\n  w\
    \ <- str_count(s, pattern = pat)\n  return(w)\n}\n</cell>\n<text>\nNow let's test\
    \ our functions:\n\n\n</text>\n<cell>", "\n  sum(grepl('e', s)) %% 2 == 0\n}\n",
  "\n  n <- length(s)\n  sapply(seq_len(n), function(i) sum(substr(s, i, i) == '^[A-Z]'))\n\
    }\n", "\n  n <- 0L\n  i <- 1L\n  i <- 1L\n  while (i < length(s)) {\n    n <-\
    \ n + 1L\n    i <- i + 2L\n  }\n  n\n}\n\ncount_upper(\"abBBdE\")", "\n  s <-\
    \ tolower(s)\n  nchar(gsub('([aeiou])', \"$1\", 'a')) + \n    nchar(gsub('([aeiou])',\
    \ \"$1\", 'A')) %/% 2 +\n    nchar(gsub('([aeiou])', \"$1\", 'e')) + \n    nchar(gsub('([aeiou])',\
    \ \"$1\", 'E')) %/% 2 +\n    nchar(gsub('([aeiou])', \"$1\", 'i')) + \n    nchar(gsub('([aeiou])',\
    \ \"$1\", 'I')) %/% 2 +\n    nchar(gsub('([aeiou])', \"$1\", 'o')) + \n    nchar(gsub('([aeiou])',\
    \ \"$1\", 'O')) %/% 2\n}\n</cell>\n<cell>", "\n  s <- gsub(\"[aeiou]\",\"\",s)\n\
    \  str <- strsplit(s,\"\")[[1]]\n  sum(grepl(\"[aeiou]\",str[seq(which(grepl(\"\
    [aeiou]\",str))+1)]))\n}\ncount_upper('abBcC')", "\n  uv_count(gregexpr(\"[AEIOUaeiou]\"\
    , s))\n}\n", "\n  sapply(strsplit(s, ''), function(x) sum(grepl('[aeiou]', x)\
    \ & seq_along(x) & seq_along(x) > 1))\n}\n", "\n    s <- tolower(s)\n    s <-\
    \ gsub(\"[[:alpha:]]\", \"\", s)\n    s <- unlist(strsplit(s, \"\"))\n    sum(s\
    \ == \"aa\" | s == \"ae\" | s == \"a\" | s == \"e\" | s == \"i\" | s == \"o\"\
    \ | s == \"u\")\n}\n\ncount_upper(\"aBCdEf\")\ncount_upper(\"abcdefg\")\ncount_upper(\"\
    dBBE\")\n</code>\nBut I get the following warning:\n<code>\nWarning message:\n\
    In gregexpr(\"[[:alpha:]]\", \"\", s) :\n  PCRE pattern compilation error\n  \
    \ '[:alpha:] not defined at position 2'\n</code>\nSo I changed the grep command\
    \ to:\n<code>\ngregexpr(\"\\\\p{Alpha}\", \"\", s)\n</code>\nAnd then I get the\
    \ following warning:\n<code>\nWarning message:\nIn gregexpr(\"\\\\p{Alpha}\",\
    \ \"\", s) :\n  PCRE pattern compilation error\n   '\\p{Alpha}' not defined at\
    \ offset 3\n</code>\nSo I changed it to:\n<code>\ngregexpr(\"[[:alpha:]]\", \"\
    \", s)\n</code>\nAnd now it works.\nBut I wonder why? \nI tried with gregexpr(\"\
    \\\\p{L}\", \"\", s) and gregexpr(\"\\\\p{Letter}\", \"\", s) instead of gregexpr(\"\
    \\\\p{Alpha}\", \"\", s), and it works as well.\nWhy does it not work if I use\
    \ gregexpr(\"[[:alpha:]]\", \"\", s) instead of gregexpr(\"\\\\p{Alpha}\", \"\"\
    , s)? I guess that the \\\\p{} syntax should work too, but I get the following\
    \ warning:\n<code>\nWarning message:\nIn gregexpr(\"[[:alpha:]]\", \"\", s) :\n\
    \  PCRE pattern compilation error\n   '\\p{Alpha}' not defined at offset 3\n</code>\n\
    <|/ q tags=r,string,regex dscore=3 |>\n<| c |>\nDo you mean `gregexpr(\"\\\\w\"\
    , \"\", s)`? I think you should use `\\\\w` instead of `[[:alpha:]]`.\n<|/ c |>\n\
    <| c |>\nYes, I meant `gregexpr(\"\\\\w\", \"\", s)`. I get the following warning:\
    \ `Warning message:\nIn gregexpr(\"\\\\w\", \"\", s) :\n  PCRE pattern compilation\
    \ error\n   '\\p{Alpha}' not defined at offset 3", "\n  count <- 0\n  for(i in\
    \ seq(1, nchar(s), 2)) {\n    if(toupper(substr(s, i, i)) %in% \"AEIOU\")\n  \
    \    count <- count + 1\n  }\n  return(count)\n}\n", "\n  # A vector of all possible\
    \ uppercase vowels.\n  v <- c('a', 'e', 'i', 'o', 'u')\n  sum(grepl(paste0(\"\
    ^[\", v, \"]$\"), s))\n}\n", "\n  i <- which(grepl(\"^[AEIOUYaeiouy]+$\", s))\n\
    \  sum((i - 1L) %% 2 == 0L)\n}\n", "\n  stopifnot(is.character(s))\n  s <- toupper(s)\n\
    \  gregexpr(\"[AEIOUaeiou]\", s)[[1]] %% 2 == 0\n}\n", "\n  u <- unique(sapply(str_extract_all(s,\
    \ '[aeiou]'), `+`, 0))\n  sum(i %in% u & i %% 2 == 0)\n}\n\ncount_upper\n</cell>\n\
    <text>\nMap and MapReduce\nThe Map and MapReduce functions are very useful, and\
    \ we'll use them often.\nmap is the map function on R. It is very similar to the\
    \ Map function in Python.\nThe main differences are:\n\nmap takes a function as\
    \ its argument\nmap only works with the vectorized form of R data structures\n\
    The argument to map must be of length one\n\nThe function returns a list with\
    \ the result of each function call\n\nThe reduce function takes the same arguments\
    \ as map, but can also reduce data structures.\n\n\n</text>\n<cell>", "\n  n <-\
    \ strcount(s,'[aeiou]')\n  n[seq(which(s=='e')[1])] + n[seq(which(s=='E')[1])]\n\
    }\n</cell>\n<cell>\ncount_upper('abbcccde')\n</cell>\n<text>\nstrcount\nCounts\
    \ the number of occurrences of a string within a character vector.\n\n\n</text>\n\
    <cell>\nhelp(strcount)\n</cell>\n<cell>\nstrcount('aa','a')\n</cell>\n<cell>\n\
    strcount('aaa','a')\n</cell>\n<cell>\nstrcount('aaa','b')\n</cell>\n<cell>\nstrcount('abcd','abc')\n\
    </cell>\n<cell>\nstrcount('aaaa','a')\n</cell>\n<cell>\nstrcount('aaaa','b')\n\
    </cell>\n<cell>\nstrcount('aaaaa','a')\n</cell>\n<cell>\nstrcount('aaaaa','b')\n\
    </cell>\n<text>\nstrsplit\nSplits a character vector into a list containing one\
    \ element per element. Useful for converting character vectors to lists.\n\n\n\
    </text>\n<cell>\nhelp(strsplit)\n</cell>\n<cell>\nstrsplit(c('a bc','a d','a e'),'\
    \ ')\n</cell>\n<text>\ngrepl\nReturns a logical vector indicating which elements\
    \ of x are matches to a pattern or string.\n\n\n</text>\n<cell>\nhelp(grepl)\n\
    </cell>\n<cell>\ngrepl('a', 'abc')\n</cell>\n<cell>\ngrepl('a', 'ab c')\n</cell>\n\
    <text>\ngrep\nReturns a numeric vector with positions of substrings matched by\
    \ pattern.\n\n\n</text>\n<cell>\nhelp(grep)\n</cell>\n<cell>\ngrep('a', 'abc')\n\
    </cell>\n<cell>\ngrep('a', 'ab c')\n</cell>\n<text>\ngregexpr\nReturns a list\
    \ of all non-overlapping matches of pattern in string x.\n\n\n</text>\n<cell>\n\
    help(gregexpr)\n</cell>\n<cell>\ngregexpr('a', 'abc abd')\n</cell>\n<cell>\ngregexpr('a',\
    \ 'ab c')\n</cell>\n<text>\ngrepchar\nReturns indices of matches of pattern in\
    \ character vector.\n\n\n</text>\n<cell>\nhelp(grepchar)\n</cell>\n", "\n  s <-\
    \ toupper(s)\n  sapply(strsplit(s, \"\"), function(x)\n           sum(grepl(\"\
    [AEIOUaeiou]\", x, perl = T)))\n}\n</cell>\n<cell>\ncount_upper(\"aBCdEf\")\n\
    </cell>\n<text>\nCount vowels including special characters only in even indices\n\
    \n</text>\n<cell>", "\n  n <- 1\n  for (i in seq_along(s)) {\n    if (substr(s,\
    \ i, i) %in% c('a', 'e', 'i', 'o', 'u'))\n      n <- n + 1\n  }\n  n\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI like the idea of using substr, but the question\
    \ is how do you apply it on a vector of strings and then apply it conditionally\
    \ on even indices?\n<|/ c |>\n<| c |>\n, that would be `apply(x, 2, function(s)\
    \ ...)` where `x` is your vector of strings and `...` is the function to be applied.\n\
    <|/ c |>\n<| a tags=r |>\nHere's an approach with stri_locate and gregexpr:\n\
    <code>\nx <- c(\"hello\", \"world\", \"foo\", \"bar\", \"baz\", \"zoo\")\ngx <-\
    \ gregexpr(\"^.\", x)\n", "\n    sum(grepl('^([a-z])([A-Z])', s))\n}\n</cell>\n\
    <cell>\ncount_upper(\"AaBbCcCdEe\")\n</cell>\n<cell>\ncount_upper(\"AaBbCcCdEe\"\
    ) < 1\n</cell>\n<cell>\ncount_upper(\"aBCdEf\") > 0\n</cell>\n<cell>\ncount_upper(\"\
    aBCdEf\") > 2\n</cell>\n<text>\nExercise: Count the number of times each of the\
    \ strings in lst occurs in s using a for loop.\n\n\n</text>\n<cell>", "\n  x <-\
    \ gregexpr('[aeiou]', s)\n  sum(lengths(x)[seq(2, length(x)) %% 2 == 0])\n}\n\
    </cell>\n<cell>\ncount_upper('abc')\n</cell>\n<cell>\ncount_upper('abcdef')\n\
    </cell>\n<text>\nThe %in% operator compares objects by reference, so it will return\
    \ True if an object is found in a vector, and False if not. If you want to compare\
    \ by a specific value, use %==.\n\n\n</text>\n<cell>\n'a' %in% 'aBCdEf'\n</cell>\n\
    <cell>\n'a' %in% 'dBBE'\n</cell>\n<text>\nVectors of type character\nAs with vectors\
    \ of type integer, integers are indexed by a whole number, starting at 1 and the\
    \ first element of the vector is indexed with 0.\n\n\n</text>\n<cell>\nv <- c('a',\
    \ 'b', 'c') # Vector of type character\nv\n</cell>\n<cell>\nv[1] # Indexing of\
    \ characters\n</cell>\n<cell>\nv[2] # Indexing of characters\n</cell>\n<text>\n\
    Vectors of type integer\nVectors of type integer are indexed with whole numbers\
    \ from 1 and the first element of the vector is indexed with 0.\n\n\n</text>\n\
    <cell>\nv <- c(1,2,3,4,5)\nv\n</cell>\n<cell>\nv[1] # Indexing of integers\n</cell>\n\
    <cell>\nv[2] # Indexing of integers\n</cell>\n<text>\nVectors of type double\n\
    Vectors of type double are indexed with whole numbers from 1 and the first element\
    \ of the vector is indexed with 0.0.\n\n\n</text>\n<cell>\nv <- c(1,2,3,4,5)\n\
    v\n</cell>\n<cell>\nv[1] # Indexing of doubles\n</cell>\n<cell>\nv[2] # Indexing\
    \ of doubles\n</cell>\n<text>\nVectors of type character\nWe can also index a\
    \ vector with a vector of type character by using the %in% operator as follows.\n\
    \n\n</text>\n<cell>\nv <- c('a', 'b', 'c') # Vector of type character\nv\n</cell>\n\
    <cell>\nv[1] == 'a' # Indexing of characters\n</cell>\n<cell>\nv[1] == 'c' # Indexing\
    \ of characters\n</cell>\n<text>\nVectors of type double\nWe can also index a\
    \ vector with a vector of type double by using the %in% operator as follows.\n\
    \n\n</text>\n<cell>\nv <- c(1,2,3,4,5) # Vector ", "\n  str <- toupper(s)\n  sum(grepl(\"\
    [AEIOU]\", str) & grepl(\"[D]\", str))\n}\n</cell>\n<cell>", "\n    n <- 0\n \
    \   i <- 0\n    while (i < nchar(s)) {\n        if (!is.na(match(s[i:(i + 1),\
    \ i], c('a', 'e', 'i', 'o', 'u')))) {\n            n <- n + 1\n        }\n   \
    \     i <- i + 1\n    }\n    return(n)\n}\n</cell>\n<cell>\ncount_upper('The quick\
    \ brown fox jumps over the lazy dog')\n</cell>\n<cell>\ncount_upper('The quick\
    \ brown fox jumps over the lazy dog.')\n</cell>\n<cell>", "\n  sum( grepl( paste0(\"\
    ^[aeiou]\",s), ignore.case=TRUE )[ seq( 2, nchar( s ) ) ] )\n}\n", "\n  nchar(gsub('[^A-Z]+',\
    \ '', s)) %>% \n    int() %>% \n    sum(ifelse(. %% 2 == 0, ., 0))\n}\ncount_upper\n\
    </cell>\n<text>\nStep 4: Sum Squared Error\nThe squared error function is:\n\n\
    \\begin{equation}\n\\sum_{i=0}^{n}(\\text{Real Value} - \\text{Predicted Value})^2\n\
    \\end{equation}\n\nWe can use the mean function to calculate the average, similar\
    \ to what we did with accuracy.\n\n\n</text>\n<cell>", "\n    n <- nchar(s)\n\
    \    sum(grepl('[a-z]', s[seq_len(n)])[seq_len(n)%%2L])\n}\n</cell>\n<cell>\n\
    count_upper(\"aBCdEf\")\n</cell>\n<cell>\ncount_upper(\"aBCdEf\")\n</cell>\n<cell>\n\
    count_upper(\"aBCdEf\")\n</cell>\n<cell>\ncount_upper(\"abcdefg\")\n</cell>\n\
    <cell>\ncount_upper(\"dBBE\")\n</cell>\n<cell>\ncount_upper(\"dBBE\")\n</cell>\n\
    <cell>\ncount_upper(\"dBBE\")\n</cell>\n<text>\nThe above code was for counting\
    \ uppercase vowels inside a string. However, it fails to count the uppercase vowels\
    \ inside a word. If we look at the following string it returns 1:\n\n\n</text>\n\
    <cell>\ncount_upper(\"aaaBBCdEf\")\n</cell>\n<text>\nSo we need to modify our\
    \ code to count the uppercase vowels inside a word, as well.\n\n\n</text>\n<cell>",
  "\n  s <- as.character(s)\n  sapply(s, function(x){\n    as.numeric(grepl(\"^\\\\\
    p{Ll}*$\", x, perl=TRUE))\n  })\n}\n", "\n  return(sum(strsplit(s, \"\")[[1]][seq(1,\
    \ length(strsplit(s, \"\")[[1]]), 2)] == toupper(substr(strsplit(s, \"\")[[1]],\
    \ 2, 2))))\n}\n</cell>\n<cell>", "\n    sum(grepl(\"^[AEIOUaeiou]*$\", s)[seq(1,\
    \ length(s) + 1)])\n}\n", "\n  nchar(gsub(\"[^aeiou]\", \"\", s)) / 2\n}\n", "\n\
    \  nchar(gsub(upper.chars, \"\", s)) / nchar(s) \n}\n</code>\n<|/ a |>\n<| c |>\n\
    Good answer, but `gsub` can take a regular expression as an argument. So, `gsub(upper.chars,\
    \ \"X\", \"\")` would replace all `upper.chars` with `X`.\n<|/ c |>\n<| c |>\n\
    Thanks, I didn't know that. I've updated my answer to include that. :)\n<|/ c\
    \ |>\n<| a dscore=3 |>\nHere's another solution which uses strsplit and gregexpr\
    \ to find where the pattern is present and replace it with NA\n<code>\nstring\
    \ <- 'aBCdEf'\ngsub(\"([aeiou])\", \"NA\", gregexpr(\"[aeiou]\", string, perl=TRUE)[[1]])",
  "\n  unlist(lapply(s, function(x) {\n    sum(c(TRUE, x %in% LETTERS[1:6]))\n  }))\n\
    }\n", "\n    sum(grepl(\"[aeiou]\", s[seq(1, length(s) - 2, 2)], fixed = TRUE))\n\
    }\n", "\n  stopifnot(length(s)>0)\n  is_even<-function(x) x%%2==0\n  sapply(seq_along(s),\
    \ function(i) sum(ifelse(is_even(i), strToUpper(substr(s,i,i)), 0)))\n}\n", "\n\
    \  nchar(gsub(\"[AEIOUaeiou]\", \"\", s))\n}\n", "\n    s <- tolower(s)\n    sum(toupper(s[seq(2,length(s)\
    \ + 1,2)])) \n}\n</cell>\n<cell>\ncount_upper('ABCDE')\n</cell>\n<text>\nQ13.\
    \ Create a function that counts the number of non-uppercase vowels in s in the\n\
    even indices only. For example:\n>>> count_non_upper('aBCdEf')\n0\n>>> count_non_upper('abcdefg')\n\
    3\n>>> count_non_upper('dBBE')\n2\nNote that counting upper case vowels does not\
    \ count the vowels\nthat are placed after a lower case vowel.\n\n</text>\n<cell>\n\
    count_non_upper <- function(s) {\n    s <- tolower(s)\n    sum(!(toupper(s[seq(2,length(s)\
    \ + 1,2)]))) \n}\n</cell>\n<cell>\ncount_non_upper('ABCDE')\n</cell>\n<text>\n\
    Q14. Create a function that counts the number of characters in the string that\
    \ are\nlowercase and uppercase at the same time. For example:\n>>> count_mixed('aBCdEf')\n\
    3\n>>> count_mixed('abcdefg')\n1\n>>> count_mixed('dBBE')\n2\n>>> count_mixed('cD')\n\
    0\nNote that counting lowercase characters does not count the characters\nthat\
    \ are placed after an upper case character.\n\n</text>\n<cell>\ncount_mixed <-\
    \ function(s) {\n    s <- tolower(s)\n    sum(toupper(s[seq(1,length(s)-1,2)]))\
    \ \n}\n</cell>\n<cell>\ncount_mixed('ABCDE')\n</cell>\n<text>\nQ15. Create a function\
    \ that counts the number of uppercase and lowercase\ncharacters in the string\
    \ s in both the even and odd indices. For example:\n>>> count_mixed_indices(aBCdEf)\n\
    (1, 0)\n>>> count_mixed_indices(abcdefg)\n(0, 1)\n>>> count_mixed_indices(dBBE)\n\
    (2, 0)\n>>> count_mixed_indices(cD)\n(0, 0)\n>>> count_mixed_indices('ABCDE')\n\
    (0, 0)\n>>> count_mixed_indices('CDE')\n(0, 0)\n>>> count_mixed_indices('ABCDEF')\n\
    (0, 0)\n>>> count_mixed_indices('DEF')\n(0, 1)\n>>> count_mixed_indices('ABCDEFG')\n\
    (1, 0)\n>>> count_mixed_indices('DEFG')\n(0, 1)\n>>> count_mixed_indices('ABCD')\n\
    (1, 0)\n>>> count_mixed_indices('AB')\n(0, 1)\n>>> count_mixed_indices('ABC')\n\
    (0, 0)\n>>> count_mixed_indices('abc')\n(0, 0)\n>>> ", "\n  counts <- c()\n  for(i\
    \ in seq_along(s)) {\n    if(i %% 2 == 0) {\n      if(substr(s[i],1,1) %in% c(\"\
    a\", \"e\", \"i\", \"o\", \"u\")) {\n        counts <- c(counts, 1)\n      }\n\
    \    }\n  }\n  return(sum(counts))\n}\n", "\n  sapply(1:nchar(s), function(x,\
    \ i) ifelse(i%%2==0 & s==\"a\", 1, 0))\n}\n</cell>\n<code language=julia-1.6>\n\
    @time count_upper(\"bBc\");\n@time count_upper(\"aBc\");\n@time count_upper(\"\
    aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time\
    \ count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"\
    aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time\
    \ count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"\
    aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time\
    \ count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"\
    aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time\
    \ count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"\
    aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time\
    \ count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"\
    aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time\
    \ count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"\
    aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time\
    \ count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"\
    aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time\
    \ count_upper(\"aBcDef\");\n@time count_upper(\"aBcDef\");\n@time count_upper(\"\
    aBcDef\");\n@time count_upper", "\n    s <- tolower(s)\n    c(which(sapply(s,\
    \ function(x) x == 'A') & c(TRUE, FALSE)) + 1, which(sapply(s, function(x) x ==\
    \ 'E') & c(TRUE, FALSE)) + 1, which(sapply(s, function(x) x == 'I') & c(TRUE,\
    \ FALSE)) + 1, which(sapply(s, function(x) x == 'O') & c(TRUE, FALSE)) + 1, which(sapply(s,\
    \ function(x) x == 'U') & c(TRUE, FALSE)) + 1)\n}\n", "\n  nchar(gsub('([^aeiouy])',\
    \ '', s)[seq(1, length(gsub('([^aeiouy])', '', s)), 2)])\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nThis does not answer the question which is about the number of\
    \ occurrences of `'aeiou'` in `s`, not the number of vowels in `s`. E.g. `count_upper(\"\
    abcde\")` should return `0` instead of `2`.\n<|/ c |>\n<| a dscore=2 |>\nFor those\
    \ who are looking to do similar tasks with R, I believe I found an answer. \n\
    <code>\nlibrary(stringr)\nstr_count(\"aeiou\")\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nFor those who are looking for a case insensitive solution `str_count(\"\
    aeiou\", ignore_case = T)` where `ignore_case` is set to TRUE or FALSE will yield\
    \ the same result\n<|/ c |>\n<| a |>\nI believe this might be the most efficient\
    \ approach\n<code>\ncount_vowel <- function(str) {\n  str <- gsub(\"[^aeiou]\"\
    , \"\", str)\n  str <- gsub(\"[aeiou]\", \"\", str)\n  nchar(str)\n}\n</code>\n\
    <|/ a dscore=2 tags=r |>\n<| c |>\nI believe this answers the question. However,\
    \ you should add a description of why this is more efficient than some of the\
    \ other answers. As it stands, it is not obvious for new readers of this answer\
    \ why.\n<|/ c |>\n<| a dscore=2 |>\nThis is a fairly efficient way to solve this\
    \ problem:\n<code>\nlibrary(stringr)\ncount_vowel <- function(s) {\n  str_count(s,\
    \ regex(\"a|e|i|o|u|y\", ignore_case = TRUE))\n}\n</code>\n<|/ a tags=r |>\n<|\
    \ c |>\nYou didn't specify an answer that works on strings like `'e'` or `'a'`.\n\
    <|/ c |>\n<| c |>\nHence my comment under OP's question that this is an \"inefficient\"\
    \ way. Although, in my own experience with large strings, `stringr` is very fast.\
    \ Even a small string like `'aB'` takes only a fraction of a second with my method\
    \ compared to yours above, whereas `stringi::stri_count` took over 5 seconds.\n\
    <|/ c |>\n<| c |>\nYes, `stringi::stri_count` can be very efficient.  But your ",
  "\n  # Special case: count the one character case.\n  if (length(s) == 1) {\n  \
    \  return(length(strtoi(s)))\n  }\n  # Count all cases of two consecutive characters.\n\
    \  result <- 0\n  i <- 0\n  while (i <= length(s)) {\n    result <- result + count_upper_pair(s,\
    \ i)\n    i <- i + 1\n  }\n  return(result)\n}\n", "\n    n <- length(s);\n  \
    \  if (n < 1) {\n        return(0)\n    }\n    stopifnot(length(s) == n && n >=\
    \ 1);\n\n    n <- nchar(s);\n    out <- 0L;\n    for (i <- seq_len(n)) {\n   \
    \     out <- out + if_else(substr(s, i, i) == 'A', 1L, 0L);\n    }\n    return(out)\n\
    }\n</cell>\n<cell>", "\n    length(gregexpr(\"[aeiou]\", s)[[1]][c(1, which(gregexpr(\"\
    [aeiou]\", s)[[1]])%%2 == 0)])\n}\n", "\n  count_vowel_count <- function(s) {\n\
    \    count_vowel <- function(s) {\n      count_voyel_count <- function(s) {\n\
    \        count_voyel <- function(s) {\n          count_vowel_count(s)\n      \
    \  }\n        c(sum(grepl(\"[aeiouAEIOU]\",s,perl=TRUE)),\n          count_vowel(s),\n\
    \          count_voyel(s),\n          count_vowel_count(s))\n      }\n      c(sum(grepl(\"\
    [aeiouAEIOU]\",s,perl=TRUE)),\n        count_vowel(s),\n        count_voyel_count(s),\n\
    \        count_vowel_count(s))\n    }\n    c(sum(grepl(\"[aeiouAEIOU]\",s,perl=TRUE)),\n\
    \      count_vowel(s),\n      count_voyel_count(s),\n      count_vowel_count(s))\n\
    \  }\n  count_vowel_count(s)\n}\n</cell>\n<cell>", "\n  s <- gsub(\" \", \"\"\
    , s)\n  i <- 0\n  repeat {\n    i <- i + 1\n    if (s[i] == \"A\" || s[i] == \"\
    E\" || s[i] == \"I\" || s[i] == \"O\" || s[i] == \"U\") {\n      return(i)\n \
    \   }\n  }\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r dscore=0 |>\nTry this,\n\
    <code>\ncount_upper <- function(s) {\n  s <- gsub(\" \", \"\", s)\n  repeat{\n\
    \    if(!is.na(match(toupper(s), toupper(tolower(s))))){\n      return(length(match(toupper(s),\
    \ toupper(tolower(s)))))\n    }\n    s <- s[-1L]\n  }\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI believe the OP wants the answer to be 0 if the string is all uppercase.\n\
    <|/ c |>\n<| c |>\nYes, you are right. `ifelse(is.na(match(toupper(s), toupper(tolower(s)))),\
    \ 0, length(match(toupper(s), toupper(tolower(s)))))` works.\n<|/ c |>\n<| c |>\n\
    This is not correct. `count_upper(\"A\")` is supposed to return 1.\n<|/ c |>\n\
    <| c |>\nI believe the OP wants to count how many times it appears in an upper\
    \ case string. For example, `\"ABCDEF\"` has three `A`s and one `E`. I think your\
    \ solution only counts the number of times the last upper case character appears.\n\
    <|/ c |>\n<| a dscore=0 tags=r |>\nYou can use the following code snippet to count\
    \ the upper case character:\n<code>\nlibrary(stringr)\n\nstr <- \"ABCDEF\"\nstr_count(str_upper(str_sub(str,\
    \ 1, 1), str_sub(str, 2, 1)), \"A\")", "\n  s <- gsub(\"[aeiou]\", \"\", s)\n\
    \  nchar(gsub(\"^.*[aeiou].*\", \"\\\\1\", s))\n}\n", "\n  count_up = 0\n  for(i\
    \ in 1:(length(s) - 1)){\n    if(substr(s[i], 2, 2) %in% c(\"A\", \"B\", \"C\"\
    , \"D\", \"E\", \"F\", \"G\"))\n      count_up <- count_up + 1\n  }\n  count_up\n\
    }\n</cell>\n<cell>", "\n  sum(grepl('([a-z])[aeiou]', s))\n}\n", "\n    n <- nchar(s);\n\
    \    x <- 0;\n    for(i in seq_len(n)) {\n        if(substr(s, i, i+1) %in% c(\"\
    A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\")) x <- x + 1;\n    }\n\
    \    x <- x - 1;\n}\n</code>\nIt appears that this works on all of the examples\
    \ provided. In fact, it works better on those that didn't quite work before. But,\
    \ for some reason, those that did work don't always appear to work now. Perhaps\
    \ the reason is that my previous code was using ifelse() instead of if(). I don't\
    \ know. \nSo I replaced ifelse() with if(). The next problem was the error message:\
    \ \n<code>\n> count_upper(df1$text)\nError in nchar(s) : invalid multibyte string\
    \ 1 \n</code>\nOkay, I figured that out and fixed it. But, now I get the following\
    \ error: \n<code>\n> count_upper(df1$text)\nError in ifelse(substr(s, i, i + 1)\
    \ %in% c(\"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\",  : \n  argument \"yes\"\
    \ is missing, with no default\n</code>\nSo I fixed it by adding an argument to\
    \ if(). Now I'm getting a different error: \n<code>\n> count_upper(df1$text)\n\
    Error in nchar(s) : invalid multibyte string 1\n</code>\nI googled this error\
    \ and discovered that it is caused by non-ascii characters in the string. That's\
    \ interesting. The string I'm dealing with is from my twitter dataset, so the\
    \ non-ascii characters shouldn't be the problem. \nMy next thought was that maybe\
    \ the text was incorrectly encoded. I checked the encoding of my strings and they\
    \ all were the same. \n<code>\n> Encoding(df1$text)\n[1] \"UTF-8\"\n> Encoding(df2$text)\n\
    [1] \"UTF-8\"\n</code>\nNow I'm a little stumped. Any help would be appreciated.\
    \ I'm pretty much out of ideas.\n<|/ q tags=r,if-statement,string,encoding dscore=1\
    \ |>\n<| a |>\nThere are several issues with the nchar function and R's UTF-8\
    \ encoding.  \nFirst, the nchar function is really only good for ASCII characters.\
    \ In UTF-8 encoding (and most other non-ASCII encodings), there are lots of other\
    \ characters that aren't ASCII.  When you try to count the number of non-ASCII\
    \ characters, you run into problems.  For example, the character \xE9 (LATIN SMALL\
    \ LETTER E WITH ACUTE) is encoded as 0xC3 0xA9.  n", "\n  s <- toupper(s)\n  n\
    \ <- 0\n  for (i in seq_along(s)) if (s[i] %in% 'AEIOU') n <- n + 1\n  n\n}\n",
  "\n  n <- nchar(s)\n  if(n > 0) {\n    sum(substring(s, i, i)==\"A\" | substring(s,\
    \ i, i)==\"B\" | substring(s, i, i)==\"C\" | substring(s, i, i)==\"D\" | substring(s,\
    \ i, i)==\"E\" | substring(s, i, i)==\"F\" | substring(s, i, i)==\"G\" | substring(s,\
    \ i, i)==\"H\" | substring(s, i, i)==\"I\" | substring(s, i, i)==\"J\" | substring(s,\
    \ i, i)==\"K\" | substring(s, i, i)==\"L\" | substring(s, i, i)==\"M\" | substring(s,\
    \ i, i)==\"N\" | substring(s, i, i)==\"O\" | substring(s, i, i)==\"P\" | substring(s,\
    \ i, i)==\"Q\" | substring(s, i, i)==\"R\" | substring(s, i, i)==\"S\" | substring(s,\
    \ i, i)==\"T\" | substring(s, i, i)==\"U\" | substring(s, i, i)==\"V\" | substring(s,\
    \ i, i)==\"W\" | substring(s, i, i)==\"X\" | substring(s, i, i)==\"Y\" | substring(s,\
    \ i, i)==\"Z\" |\n      substring(s, i, i)==\"a\")\n  }\n}\n</code>\n<|/ a tags=string,r,count,regex\
    \ dscore=1 |>\n<| a tags=string,r,count,regex |>\nThis solution has nothing to\
    \ do with regex. It uses the strsplit function and counts the number of occurrences\
    \ of 'a' in the list of strings. \n<code>\ncount_vowels <- function(x) {\n   \
    \ n <- 0\n    for (i in 1:length(x)) {\n        count <- grep(\"a\", x[i])\n \
    \       n <- n + 1\n    }\n    n\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy\
    \ not just `grep(\"a\", x)`?\n<|/ c |>\n<| c |>\nYes that would work, thanks.\
    \ I forgot that grep() could take a vector. I edited my answer.\n<|/ c |>\n<|\
    \ a |>\nYou can use stringi package to do this.\n<code>\nlibrary(stringi)\n\n\
    count_vowels <- function(x) {\n    n <- 0\n    for (i in 1:length(x)) {\n    \
    \    count <- stri_count_fixed(x[i],\"a\")\n        n <- n + 1\n    }\n    n\n\
    }\n\ncount_vowels(c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\"))\n</code>\nOutput\n\
    <code>\n[1] 4\n</code>\n<|/ a tags=string,r,count,regex dscore=1 |>\n<| c |>\n\
    The OP asked for regex in their question.  Also this doesn't even attempt to answer\
    \ the question.  Why would you want to use stringi?", "\n  sapply(strsplit(s,\
    \ \"\"), function(x) sum(x %in% 'aeiou'))\n}\n", "\n    s <- stringr::str_to_lower(s)\n\
    \    sum(grepl(\"^[aeiouy][A-Z]\", s))\n}\n", "\n    sum(strsplit(s, \"[aeiou]\"\
    )[[1]] %in% \"aeiou\"[seq(1,length(s) + 1,2)])\n}\n</cell>\n<text>\nNext, implement\
    \ the function count_vowels which takes an array of words and returns the number\
    \ of vowels present in each word.\n\n\n</text>\n<cell>", "\n    n <- 0\n    for\
    \ (i <- seq(1, nchar(s), by = 2)) {\n        n <- n + grepl('(?i)[aeiou]$', substr(s,\
    \ i, i + 1))\n    }\n    return(n)\n}\n</cell>\n<text>\nNow we can test our function:\n\
    \n\n</text>\n<cell>\ncount_upper(\"abADEf\")\n</cell>\n<text>\nExploring our data\n\
    Let's start by exploring our data a bit. What are some observations of our dataset?\n\
    \n\n</text>\n<cell>\nstr(data)\n</cell>\n<text>\nHow many observations? What are\
    \ their classes?\n\n\n</text>\n<cell>\nnrow(data)\n</cell>\n<cell>\nclass(data$species)\n\
    </cell>\n<text>\nHow many classes per species?\n\n\n</text>\n<cell>\ntable(data$species)\n\
    </cell>\n<text>\nWhat are the unique values of our species?\n\n\n</text>\n<cell>\n\
    unique(data$species)\n</cell>\n<text>\nWhat are the levels?\n\n\n</text>\n<cell>\n\
    levels(data$species)\n</cell>\n<text>\nWhat are the names of the levels?\n\n\n\
    </text>\n<cell>\nnames(sort(table(data$species)))\n</cell>\n<text>\nLet's plot\
    \ a histogram of the number of each species of flowers in our dataset:\n\n\n</text>\n\
    <cell>\nplot(table(data[, c('species', 'flowers')]), \n     main = \"Distribution\
    \ of Flowers in our Dataset\")\n</cell>\n<text>\nLooking at our dataset, we see\
    \ that some species have more flowers and others have fewer flowers.\n\nWhat if\
    \ we want to visualize our data in a way that we can make sense of it graphically?\
    \ That is, let's try to plot flowers for each species?\n\nHow can we do that?\n\
    \nOne way is to create separate plots for each species, and use them together\
    \ to build our overall plot:\n\n\n</text>\n<cell>\npar(mfrow = c(2, 1))\n\nfor(i\
    \ in unique(data$species)){\n    d <- data[data$species == i, ]\n    plot(d$flowers,\
    \ d$species, \n         main = paste(\"Distribution of Flowers for Species \"\
    , \n                     i, sep = \"\"), \n         xlab = \"Number of Flowers\"\
    , \n         ylab = \"Species\", \n         pch = 16, \n         cex = 3)\n}\n\
    \ndev.off()\n</cell>\n<text>\nHere we see that each species has a different distribution\
    \ of flowers. ", "\n  s <- toupper(s)\n  sapply(strsplit(s, ''), function(x) sum(grepl('[AEIOU]',\
    \ x) & x != 'E'))\n}\n", "\n  length(gregexpr(\"(?i)[aeiou]\", s)[[1]]) - length(gregexpr(\"\
    (?i)[aeiou]\", s)[[1]][[2]])\n}\n", "\n    count_vec <- rep(0, length(s) / 2)\n\
    \    for (i in seq(along = s)) {\n        if (substr(s, i, i) == 'e') count_vec[i]\
    \ <- count_vec[i] + 1\n    }\n    count_vec[c(TRUE, FALSE)]\n}\n", "\n  u <- strsplit(s,\
    \ '[aeiouAEIOU]', perl = TRUE)[[1]]\n  sum(grepl('([aeiou])([AEIOU])', u, perl\
    \ = TRUE))\n}\n</cell>\n<text>\nThis implementation is O(N). How fast is it compared\
    \ to the fastest solution?\n\n\n</text>\n<cell>\nbench::mark(\n  count_upper =\
    \ c(\"for(i in seq_along(s) {length(grep(s[i], toupper(s), ignore.case = TRUE))\
    \ > 0}\"),\n  count_upper = c(\"for(i in seq_along(s)) {sum(grepl(s[i], toupper(s),\
    \ ignore.case = TRUE)) > 0}\"),\n  count_upper = c(\"sapply(s, function(u) {sum((grepl('[aeiou]',\
    \ u, ignore.case = TRUE)) > 0)})\"),\n  count_upper = c(\"sapply(s, function(u)\
    \ {sum(grepl('[aeiou]', u)) > 0})\"),\n  count_upper = c(\"sapply(s, function(u)\
    \ {sum(grepl('[aeiou]', u, perl = TRUE)) > 0})\"),\n  count_upper = c(\"sapply(s,\
    \ function(u) {sum(grepl('[aeiouAEIOU]', u, perl = TRUE)) > 0})\"),\n  count_upper\
    \ = c(\"sapply(s, function(u) {sum(grepl('[aeiouAEIOU]', u, perl = TRUE)) > 0})\"\
    ),\n  count_upper = c(\"sapply(s, function(u) {sum(strsplit(u, '[aeiouAEIOU]',\
    \ perl = TRUE)[[1]] %in% c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'))\
    \ > 0})\"),\n  count_upper = c(\"sapply(s, function(u) {sum(strsplit(u, '[aeiouAEIOU]',\
    \ perl = TRUE)[[1]] %in% c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'))\
    \ > 0})\"),\n  count_upper = c(\"sapply(s, function(u) {sum(strsplit(u, '[aeiouAEIOU]',\
    \ perl = TRUE)[[1]] %in% c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'))\
    \ > 0})\"),\n  count_upper = c(\"sapply(s, function(u) {sum(strsplit(u, '[aeiouAEIOU]',\
    \ perl = TRUE)[[1]] %in% c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'))\
    \ > 0})\"),\n  count_upper = c(\"sapply(s, function(u) {sum(strsplit(u, '[aeiouAEIOU]',\
    \ per", "\n  length(gregexpr(\"[aeiou]\", s, perl = TRUE)) - 1\n}\n</code>\n<|/\
    \ a tags=r,regex |>\n<| a tags=r,regex |>\nI would do something like this (I hope\
    \ I understood your question):\n<code>\ncount_upper <- function(x) sum(x %in%\
    \ toupper(x))\n\ncount_upper('abcD')", "\n  sum(grepl(\"[aeiouAEIOU]\", s)[seq(2,\
    \ length(s)) +])\n}\n</cell>\n<text>\nThe first function, count_upper, is straightforward.\
    \ It counts how many times any single character appears in s in an even index.\n\
    \n\n</text>\n<cell>\ncount_upper(\"aaa\")\n</cell>\n<text>\nThe second function,\
    \ count_upper_multiple, is a little more complicated than the first. It counts\
    \ how many times any character appears in s in an even index. For example, count_upper_multiple(\"\
    abcdefg\") returns 2.\n\nA more general function is also provided:\n\n\n</text>\n\
    <cell>\ncount_upper_multiple <- function(s) {\n  sum(grepl(\"[aeiouAEIOU]\", s)[seq(2,\
    \ length(s)) +])\n}\n</cell>\n<text>\nLet's try it out:\n\n\n</text>\n<cell>\n\
    count_upper_multiple(\"aaa\")\n</cell>\n<text>\nThe grepl function returns a vector\
    \ of booleans, which are basically 0/1 values. The sum() function is a handy way\
    \ to convert a boolean vector into a numeric one:\n\n\n</text>\n<cell>\nx <- c(0,\
    \ 1, 1, 0)\nsum(x)\n</cell>\n<text>\nThe grepl function checks to see if the character\
    \ s in the string has an upper case vowel after an even index, which is what the\
    \ seq(2, length(s)) expression does. We can put this all in a one-liner:\n\n\n\
    </text>\n<cell>\ncount_upper_multiple <- function(s) { sum(grepl(\"[aeiouAEIOU]\"\
    , s)[seq(2, length(s)) +]) }\n</cell>\n<text>\nNow we can use it to count the\
    \ number of uppercase vowels in a string:\n\n\n</text>\n<cell>\ncount_upper_multiple(\"\
    aaa\")\n</cell>\n<text>\nLet's try to do the same with a character vector:\n\n\
    \n</text>\n<cell>\ncount_upper_multiple(c(\"a\", \"b\", \"c\", \"a\"))\n</cell>\n\
    <text>\nIn the above example, the grepl function returns a vector with the same\
    \ length as the number of characters in s, with the value TRUE for those characters\
    \ that satisfy the expression, and FALSE otherwise.\n\nThe above function can\
    \ be extended to count the number of uppercase vowels in each word of a string:\n\
    \n\n</text>\n<cell>\ncount_upper_multiple_on_word <- function(s) {\n  lapply(strsplit(s,\
    \ \" \"), function(x)\n    sum(grepl(\"[aeiouAEIOU]\", x)[seq(2, length(x)) +]))\n\
    }\n</cell>\n<text>\nLet's try it out:\n\n\n</text>\n<cell>\ncount_upper_multiple_on_word(\"\
    The ra", "\n    length(gregexpr(\"[AEIOU]\", s, perl=T)[[1]])\n}\n", "\n  count_upper_index\
    \ <- function(x) {\n    if (x >= 2 & x <= length(s) - 1) {\n      if (s[[x]] ==\
    \ \"e\") {\n        return 1\n      }\n      if (s[[x]] == \"A\") {\n        return\
    \ 1\n      }\n      if (s[[x]] == \"B\") {\n        return count_upper_index(x+1)\n\
    \      }\n      if (s[[x]] == \"C\") {\n        return count_upper_index(x+1)\n\
    \      }\n      if (s[[x]] == \"D\") {\n        return count_upper_index(x+1)\n\
    \      }\n      if (s[[x]] == \"E\") {\n        return count_upper_index(x+1)\n\
    \      }\n    }\n    0\n  }\n  count_upper_index(1) \n}\n", "\n  s <- tolower(s)\n\
    \  sapply(seq_along(s), function(i) {\n    if(i %% 2L == 0L) {\n      i <- toupper(i)\n\
    \      i\n    }\n  }, USE.NAMES = FALSE)\n}\n</code>\n<|/ a tags=regex,r |>\n\
    <| c |>\nThis is pretty neat, but I wonder if this approach is actually faster\
    \ than a loop with grepl() on the characters of the string (which in my experience\
    \ is quite slow).\n<|/ c |>\n<| c |>\nI think that grep is probably faster than\
    \ the loop either way, since it just returns a vector of positions wherever the\
    \ pattern matches. It doesn't look like grepl in R has a way to return a vector\
    \ of matches as far as I can tell.\n<|/ c |>\n<| c |>\n`grep` does have such a\
    \ feature. See `?grep`.\n<|/ c |>\n<| a dscore=3 tags=regex,r |>\nHow about:\n\
    <code>\ncount_upper.char <- function(s) {\n  strsplit(tolower(s), \"\")[[1]][cumsum(grepl(\"\
    [a-z]\",s[[1]])) + 1]\n}\n\ncount_upper.char(\"aBCdEf\")", "\n    n <- nchar(s)\n\
    \    even.indices <- which(substr(s,1,2) %in% c(\"a\",\"e\",\"i\",\"o\",\"u\"\
    )) - 1 # all indices of even chars\n    if (n %% 2)\n        sum(substring(s,even.indices,even.indices\
    \ + 2) %in% c(\"a\",\"e\",\"i\",\"o\",\"u\")) / 2\n    else\n        sum(substring(s,even.indices,even.indices\
    \ + 2) %in% c(\"a\",\"e\",\"i\",\"o\",\"u\")) / n\n}\n</cell>\n<cell>\ncount_upper(\"\
    aBcDeF\") # 1 because there's 2 vowels in even indices\n</cell>\n<cell>\ncount_upper(\"\
    aBcDeF\") # 1 because there's 2 vowels in even indices\n</cell>\n<cell>\ncount_upper(\"\
    aBCdEf\")\n</cell>\n<text>\nThe count_upper function above uses the fact that\
    \ if an odd number of letters in the string has an uppercase vowel, then the string\
    \ contains 2 uppercase vowels. So we can just use that fact to count uppercase\
    \ vowels by computing the sum of substrings (i.e. \"aBCdEf\" would be a vector\
    \ of length 5 containing \"aBC\", \"BCd\", \"CdE\" and \"Df\")\n\n\n</text>\n\
    <cell>\ncount_upper(\"aBCdEf\") + count_upper(\"aBCdEf\") - count_upper(\"aBCdEf\"\
    ) * count_upper(\"aBCdEf\")\n</cell>\n<text>\nThe count_upper function above uses\
    \ the fact that if an odd number of letters in the string has an uppercase vowel,\
    \ then the string contains 2 uppercase vowels. So we can just use that fact to\
    \ count uppercase vowels by computing the sum of substrings (i.e. \"aBCdEf\" would\
    \ be a vector of length 5 containing \"aBC\", \"BCd\", \"CdE\" and \"Df\")\n\n\
    \n</text>\n<cell>\ncount_upper(\"aBCdEf\") + count_upper(\"aBCdEf\") - count_upper(\"\
    aBCdEf\") * count_upper(\"aBCdEf\")\n</cell>\n<cell>", "\n    n <- 0\n    for(i\
    \ in seq_along(s)) {\n        if(substr(s[i], i, i)%%2 == 0) n <- n+1\n    }\n\
    \    return(n)\n}\n", "\n  nchar(gsub('([bcdfghjklmnpqrstvwxyz])', '', s)[grepl('([bcdfghjklmnpqrstvwxyz])',\
    \ s)])\n}\n</cell>\n<cell>", "\n    p <- gregexpr('[A-Z]', s)\n    sum(regmatches(s,\
    \ p) == vapply(p, '[', character(1L), 1L))\n}\n", "\n  stopifnot(all(grepl(\"\
    ^[aeiou]$\", s)))\n  sum(grepl(\"^[aeiou]$\", s, fixed = TRUE) & seq(2, length(s)\
    \ + 1, 2))\n}\n", "\n  evens <- which(grepl(\"^[02468]\", s))\n  sum(grepl(\"\
    [AEIOU]\", s[evens]))\n}\n</code>\n<|/ a dscore=3 tags=r |>\n<| a |>\nAs I said\
    \ in my comment above, here's a base R option\n<code>\ncount_upper <- function(s)\
    \ sum(grepl(\"[AEIOU]\", s))\n</code>\nHowever, if we do care about performance,\
    \ here's a version that does not use grep\n<code>\ncount_upper2 <- function(s)\
    \ {\n  s <- toupper(s[!grepl(\"^[02468]\", s)])\n  sum(s == \"A\" | s == \"E\"\
    \ | s == \"I\" | s == \"O\" | s == \"U\")\n}\n</code>\n<|/ a tags=r dscore=2 |>\n\
    <| a dscore=2 |>\nHere's an alternative using strsplit:\n<code>\nstr <- 'aBCdEf'\n\
    strsplit(str, \"[AEIOU]\", fixed=TRUE)\n[[1]]\n[1] \"a\" \"B\" \"C\" \"d\" \"\
    E\" \"f\" \"G\"\n\nsum(sapply(strsplit(str, \"[AEIOU]\", fixed=TRUE), function(x)\
    \ sum(x=='A' | x=='E' | x=='I' | x=='O' | x=='U'))>0)\n</code>\n<|/ a tags=r |>\n\
    <| a tags=r |>\nYou could also do this with regex:\n<code>\ncount_upper <- function(s){\n\
    \  sapply(gregexpr(\"^[02468]\", s), `[`, 1)\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=r dscore=2 |>\nAvoiding the need for the grep function you can do it\
    \ like this\n<code>\ncount_upper <- function(s){\n    evens <- which(grepl(\"\
    ^[02468]\", s))\n    sum(s == \"A\" | s == \"E\" | s == \"I\" | s == \"O\" | s\
    \ == \"U\")\n}\n</code>\nor like this\n<code>\ncount_upper <- function(s){\n \
    \   sum(grepl(\"[AEIOU]\", s))\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work\
    \ if you just want to count the uppercase characters, for instance with character\
    \ \"aBCdEf\"\n<|/ c |>\n<| a |>\nHere's one way using stringr:\n<code>\nlibrary(stringr)\n\
    count_upper <- function(s){\n  s <- str_to_upper(s[!", "\n  gsub(paste0('(?<!^)(?=[A-Z])'),\
    \ \"\", s) %>% \n    str_count(pattern='[A-Z]', perl=TRUE) %>% \n    sum()\n}\n",
  "\n    stopifnot(is.character(s))\n    x <- strsplit(s, '')[[1]]\n    x <- gsub(paste0('[^',\
    \ upper(letters), ']'), '', x)\n    sum(grepl(paste0('\\\\b', letters, '\\\\b'),\
    \ x))\n}\n\ncount_upper('hElLo')", "\n  return(length(gregexpr(\"[A-Z]\", s)[[1]][seq(2,\
    \ length(s) - 1, 2)][[1]]))\n}\n", "\n\ts <- str_lower(s)\n\tv <- c('A','a','O','o','U','u','I','i','L','l','S','s','P','p','K','k','J','j','Q','q')\n\
    \tsum(v[grepl(v,s)])\n}\n", "\n  m <- gregexpr(\"([a-z])([A-Z])\", s)\n  v <-\
    \ attr(m, \"captured\")\n  sum(sapply(v, function(x) x[[1]] == \"A\" || x[[1]]\
    \ == \"a\"))\n}\n</code>\n<code>", "\n  n <- nchar(s)\n  m <- 0\n  for(i <- 2:(n-1))\
    \ {\n    if(s[i] == 'e' || s[i] == 'E') {\n      m <- m+1\n    }\n  }\n  return(m)\n\
    }\n", "\n  sapply(seq_along(s), function(i) {\n    sum(substr(s, i, i) %in% \"\
    AEIOU\")\n  })\n}\n", "\n  sum(grepl(\"[aeiou]\", s, fixed=T) & grepl(\"^[0-9]*$\"\
    , s))\n}\n", "\n  sum(grepl(\"[AEIOU]\", s)[seq(1, length(s)) %% 2 == 0]) + 1\n\
    }\n", "\n    sum(grepl(\"^[AEIOU].*\", s))\n}\ncount_upper\n", "\n\tsum(grepl(\"\
    [aeiou]$\", s, perl = TRUE) & grepl(\"^[aeiou]$\", s, perl = TRUE))\n}\n", "\n\
    \  s <- str_to_lower(s)\n  sum((gregexpr(\"[aeiou]\", s)[[1]] %% 2)) / 2\n}\n",
  "\n  res <- 0\n  char.index <- function(c, i){\n    if(i <= length(c)) which(c[i]\
    \ == toupper(c[i]))\n  }\n  char.index(c(s), sapply(s, is.char))\n  sapply(1:length(char.index(s,\
    \ c(FALSE, TRUE))), function(i)\n    if(i%%2 == 0) res + sum(s[i:(i + 2)]))\n\
    }\n</cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </cell>\n<cell>\ncount_upper('The quick brown fox jumps over the lazy dog')\n\
    </", "\n    sum(grepl(\"[[:upper:]]\", s, perl=TRUE))\n}\n", "\n\tcount <- 0\n\
    \tfor (i in 1:(length(s))) {\n\t\tif (substr(s, i, i) %in% \"AEIOUaeiou\") {\n\
    \t\t\tcount <- count + 1\n\t\t}\n\t}\n\treturn(count)\n}\n", "\n  n_upper = 0L\n\
    \  for (i in seq_len(nchar(s))) {\n    if (substring(s, i, i) %in% LETTERS) {\n\
    \      if (substring(s, i, i) %in% c(LETTERS, 'a', 'e', 'i', 'o', 'u')) {\n  \
    \      n_upper = n_upper + 1L\n      }\n    }\n  }\n  return(n_upper)\n}\n</code>\n\
    Benchmark\n<code>\nmicrobenchmark(count_upper(\"aBCdEf\"), count_upper(\"abcdefg\"\
    ), count_upper(\"dBBE\"), count_upper(\"abcde\")) # Unit: microseconds", "\n \
    \   stopifnot(length(s) == length(toupper))\n    sum( s[seq_len(length(s)) & seq_len(length(s))\
    \ %% 2 == 0] == toupper)\n}\n", "\n  sum(toupper(s[seq_along(s)]) %in% c('a',\
    \ 'e', 'i', 'o', 'u'))\n}\n", "\n  # Count upper cases in even indices\n  count_upper_even\
    \ <- function(x, n) if (x %% 2 == 0) length(gregexpr(\"^[aeiou]\",substring(x,n,n)))\n\
    \  n_v <- sum(sapply(strsplit(s, \"\"), count_upper_even))\n  n_u <- sum(sapply(strsplit(s,\
    \ \"\"), function(x) sum(gregexpr(\"[AEIOU]\",x))))\n  n_v - n_u\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThanks for taking the time to write this up. I've\
    \ run your first script (thanks for that!) on a slightly larger data set of 150\
    \ million rows and it took 6 seconds. I ran the second script and it took 13 seconds.\
    \ I ran the first script again and it took 21 seconds. So I think your second\
    \ script is about twice as fast as the first (it took about 7 seconds for both\
    \ of them).\n<|/ c |>\n<| c |>\nThat's a great improvement! Thanks again for taking\
    \ the time to write this up!\n<|/ c |>\n<| c |>\n: You are welcome! I am curious\
    \ to know which solution was faster in your case? Did you try the other solutions\
    \ as well? Btw: I am pretty sure I didn't miss anything, so I may have missed\
    \ something.\n<|/ c |>\n<| c |>\nI tried the other solutions as well. I ran the\
    \ top one (which took 6 seconds) and that took about 7 seconds. When I ran the\
    \ second one (which took 13 seconds) that took about 6 seconds. When I ran the\
    \ top one (which took about 7 seconds) and that took about 7 seconds. I ran the\
    \ second one (which took about 6 seconds) and that took about 6 seconds. I ran\
    \ the top one (which took about 7 seconds) and that took about 7 seconds. I ran\
    \ the second one (which took about 7 seconds) and that took about 7 seconds. I\
    \ ran the top one (which took about 6 seconds) and that took about 6 seconds.\
    \ I ran the second one (which took about 6 seconds) and that took about 6 seconds.\
    \ I ran the top one (which took about 6 seconds) and that took about 6 seconds.\
    \ I ran the second one (which took about 7 seconds) and that took about 7 seconds.\n\
    <|/ c |>\n<| c |>\n: Thanks for the update! I updated my answer ", "\n  sum(s\
    \ %% 2L == 0L & s %% 2L == 7L)\n}\n</cell>\n<text>\nThe sum() function gives the\
    \ total number of elements in a vector or list\n(depending on its type).  The\
    \ sum() function is very commonly used in R\nprogramming, and we will use it quite\
    \ often in this course.\n\nFor example, to get the sum of a vector, we can just\
    \ use sum(), as in:\n\n\n</text>\n<cell>\nsum(1:10)\n</cell>\n<text>\nTo get the\
    \ sum of a vector, we can also use its special form sum(), as in:\n\n\n</text>\n\
    <cell>\nsum(1:4, na.rm=TRUE)\n</cell>\n<text>\nWe will also use the sum() function\
    \ in the next two problems to answer some more general\nquestions.  Those questions\
    \ are also addressed in this section.\n\nFor example, suppose we are interested\
    \ in the number of each uppercase letter in a\nstring.  We can create this vector\
    \ using the code\nbelow:\n\n\n</text>\n<cell>\ncount_up <- function(s) {\n  n\
    \ <- 0\n  for(letter in s) n <- n + count_upper(letter)\n  n\n}\n</cell>\n<cell>\n\
    count_up(\"aBCdEf\")\n</cell>\n<text>\nThis function works, but it can be written\
    \ more succinctly using the\ncode below:\n\n\n</text>\n<cell>\ncount_up <- function(s)\
    \ {\n  sum(s %% 2L == 0L & s %% 2L == 7L)\n}\n</cell>\n<text>\nThis code is very\
    \ similar to the first one, but it is slightly more concise\n(perhaps a little\
    \ harder to read).  It can be shortened a little\nmore using the fact that R will\
    \ coerce logical values to 1 when they\nare true, and 0 when they are false:\n\
    \n\n</text>\n<cell>\ncount_up <- function(s) {\n  sum(s %% 2L == 0L & s %% 2L\
    \ == 7L)\n}\n</cell>\n<text>\nNote that the TRUE and FALSE values are not exactly\
    \ 1 and 0, but rather TRUE\nand FALSE.\n\nLet's test it out with our string and\
    \ see how it works:\n\n\n</text>\n<cell>\ncount_up(\"aBCdEf\")\n</cell>\n<text>\n\
    Here we have tested it on a string with the exact same characters as the\nfirst\
    \ example (but in uppercase letters), and it appears to work!\nLet's try it on\
    \ a string with different characters:\n\n\n</text>\n<cell>\ncount_up(\"dBBE\"\
    )\n</cell>\n<text>\nOops!  It appears the ", "\n  n <- nchar(s)\n  if (n == 0)\
    \ 0\n  else if (substr(s, n+1, n) == \"e\") 1\n  else 0\n}\n", "\n  len <- length(s)\n\
    \  evens <- grepl('^..$', s)\n  sum(substring(s, evens, len - evens) == 'A')\n\
    }\n", "\n  s <- toupper(s)\n  n <- length(s)\n  if(n %% 2 == 1) {\n    return\
    \ 0\n  }\n  i <- seq(1,n+1,2)\n  sum( s[[i]] == 'A' | s[[i]] == 'E' | s[[i]] ==\
    \ 'I' | s[[i]] == 'O' | s[[i]] == 'U' )\n}\n</cell>\n<code language=conda-env-Anaconda3-py>\n\
    count_upper('dBBE')\n</cell>\n<code language=conda-env-Anaconda3-py>", "\n  sum(unlist(strsplit(s,\
    \ \"\")[grep(\"[AEIOUaeiou]\", unlist(strsplit(s, \"\")))]) == 0)\n}\n</cell>\n\
    <cell>\ncount_upper(\"dBBE\")\n</cell>\n<text>\nNow let us write count_lower that\
    \ takes just the even indices.\n\n\n</text>\n<cell>", "\n  sum(substr(s, seq(1,\
    \ nchar(s), 2), seq(2, nchar(s), 2))==\"AEIOU\")\n}\n", "\n    i <- 0\n    while\
    \ ((i < nchar(s)) & grepl('^[AEIOU]+$', s[i:(i + 3)]))\n        i += 4\n    n\
    \ <- length(s) - i - 1\n    if (n == 0) return(0)\n    if (n > 0) return(sum(s[i:(i\
    \ + n - 1)] == 'E'))\n}\n", "\n  unlist(lapply(1:length(sapply(gregexpr('[A-Z]',\
    \ s), FUN = function(x) x)), function(i) {\n    sum(grepl('[A-Z]', s, fixed =\
    \ TRUE, value = i)) - 1\n  }))\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\n\
    Here's a solution that uses strsplit, the function which separates strings into\
    \ character vectors.  We then use tapply to count the number of occurrences of\
    \ each substring in the vector of character vectors.\n<code>\nx <- strsplit(x,\
    \ \"\")\ntapply(x, names(x), function(x) length(x[x == \"A\"]))", "\n  s <- gsub('[A-Z]+',\
    \ '',s)\n  s <- gsub(\"[a-z]+\", '',s)\n  length(gregexpr(\"[aeiou]\",s)[[1]])\n\
    }\n</cell>\n<text>\nWe have already implemented a version of count_upper, which\
    \ counts the number of uppercase vowels in a string. Try to use it to implement\
    \ another count_vowels that counts the number of vowels in a string.\n\n\n</text>\n\
    <cell>", "\n  if (length(s) <= 1) return 0\n  count_upper <- function(s, i, count)\
    \ {\n    if (i == length(s)) return(count)\n    if (substr(s[i], 1, 1) %in% c(\"\
    A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n     \
    \   substr(s[i], 2, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\"\
    , \"i\", \"o\", \"u\") &&\n        substr(s[i], 3, 1) %in% c(\"A\", \"E\", \"\
    I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n        substr(s[i],\
    \ 4, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\",\
    \ \"u\") &&\n        substr(s[i], 5, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"\
    U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n        substr(s[i], 6, 1) %in% c(\"\
    A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n     \
    \   substr(s[i], 7, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\"\
    , \"i\", \"o\", \"u\") &&\n        substr(s[i], 8, 1) %in% c(\"A\", \"E\", \"\
    I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n        substr(s[i],\
    \ 9, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\",\
    \ \"u\") &&\n        substr(s[i], 10, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"\
    U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n        substr(s[i], 11, 1) %in% c(\"\
    A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n     \
    \   substr(s[i], 12, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\"\
    , \"i\", \"o\", \"u\") &&\n        substr(s[i], 13, 1) %in% c(\"A\", \"E\", \"\
    I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n        substr(s[i],\
    \ 14, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\"\
    , \"u\") &&\n        substr(s[i], 15, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"\
    U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n        substr(s[i], 16, 1) %in% c(\"\
    A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\", \"u\") &&\n     \
    \   substr(s[i], 17, 1) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"",
  "\n  count <- 0\n  for(i in seq_along(s)) {\n    if(substr(s, i, i) == 'a' || substr(s,\
    \ i, i) == 'A')\n      count <- count + 1\n  }\n  count\n}\n</cell>\n<cell>\n\
    count_upper(LETTERS)\n</cell>\n<cell>\ncount_upper('hcdef')\n</cell>\n<text>\n\
    Exercise 3: Repeating letters \nGiven the string 'cdeebdeed', repeat the second\
    \ 'd' twice, so the string becomes 'cdeebdeedcdeebdeed'.\n\n\n</text>\n<cell>",
  "\n  stopifnot(!is.null(s))\n  stopifnot(nchar(s) %% 2 == 0)\n  result <- 0L\n \
    \ v <- c(\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\")\n  pos <- 0L\n  i <-\
    \ 0L\n  while(i < nchar(s)) {\n    while(i < nchar(s) && substr(s, i, i + 1) %in%\
    \ v) {\n      pos += 1L\n      i <- i + 2L\n    }\n    if(substr(s, i, 1) == \"\
    u\") result <- result + 1L\n    i <- i + 1L\n  }\n  result\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThis solution assumes that there are no vowels at the\
    \ beginning of the string. If that is not the case, consider replacing `if (substr(s,\
    \ i, 1) == \"u\") result <- result + 1L` with `if (substr(s, i, 1) == \"u\") result\
    \ <- result + 1L else result <- result + 1L`\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    count_upper <- function(s) {\n    result <- 0L\n    pos_to_char <- function(x)\
    \ {\n        stopifnot(!is.null(x))\n        stopifnot(x %in% c(\"A\", \"A\"))\n\
    \        x <- toupper(x)\n        x <- tolower(x)\n        x\n    }\n    x <-\
    \ sapply(s, pos_to_char)\n    i <- 1L\n    while (i < nchar(x)) {\n        if\
    \ (substr(x, i, 1) == \"u\") result <- result + 1L\n        i <- i + 1L\n    }\n\
    \    result\n}\n</code>\n<|/ a tags=r,string |>\n<| a dscore=0 |>\nUsing the R\
    \ package stringr, this can be easily achieved like this:\n<code>\nlibrary(stringr)\n\
    \ncount <- function(string){\n    str_count <- str_count(string, '[aeiou]') %>%\
    \ \n        as.integer() %>% \n        sum\n    return(str_count)\n}\n</code>\n\
    <|/ a tags=r,string |>\n<| a tags=r,string |>\nMy solution is very similar to\
    \ your solution, just some changes and no packages imported\n<code>\ncount_upper\
    \ <- function(s) {\n    stopifnot(!is.null(s))\n    stopifnot(nchar(s) %% 2 ==\
    \ 0)\n    result <- 0L\n    v <- c(\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"\
    A\")\n    pos <- 0L\n    i <- 0L\n    while (i < nchar(s)) {\n        while (i\
    \ < nchar(s) && substr(s, i, i + 1) %in% v) {\n            po", "\n  n <- length(s)\n\
    \  upper.count <- 0\n  for (i in 1:n) {\n    char <- substr(s, i, i)\n    if (substr(char,\
    \ 2, 1) %in% c(\"A\",\"E\",\"I\",\"O\",\"U\")) upper.count <- upper.count + 1\n\
    \  }\n  upper.count\n}\n</cell>\n<cell>", "\n  sum(grepl('^[aeiou]$', s, perl\
    \ = TRUE))\n}\n\ncount_upper\n</cell>\n<cell>", "\n  len <- nchar(s)\n  if (len\
    \ > 0)\n    sum(grepl(\"^[AEIOUaeiou]{2,}\", s))\n  else 0\n}\n</code>\n<|/ a\
    \ dscore=0 tags=string,r |>\n<| a |>\nHere is a solution with str_count from stringr:\n\
    <code>\nlibrary(stringr)\n\nstring <- \"Hello\"\nstr_count(string = string, pattern\
    \ = \"[aeiouAEIOU]\")\n\n[1] 2\n</code>\n<|/ a tags=string,r dscore=0 |>\n<| a\
    \ dscore=0 |>\n<code>\nlibrary(stringr)\n\nstring <- \"Hello\"\n\nstr_count(string\
    \ = string, pattern = \"[aeiouAEIOU]\")\n\n[1] 2\n</code>\nThe stringr package\
    \ has a function str_count that does just that. Just put square brackets around\
    \ your pattern to include all uppercase vowels.\n<|/ a tags=string,r |>\n<| c\
    \ |>\nIt may be worth adding a note about this package not being on CRAN: `install.packages(\"\
    stringr\")` will install it if it is not already installed. This is a good way\
    \ of checking for missing packages on your machine.\n<|/ c |>\n<| a tags=string,r\
    \ |>\nUsing stringr, you can use str_count with grepl\n<code>\nstring <- \"Hello\"\
    \nstr_count(string = string, pattern = paste0(\"[\", LETTERS, collapse = \", \"\
    ), fixed = TRUE)\n[1] 2\n</code>\nIf you want case insensitivity, use\n<code>\n\
    str_count(string = string, pattern = paste0(\"[\", toupper(LETTERS), collapse\
    \ = \", \"), fixed = TRUE)\n[1] 2\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,r\
    \ dscore=0 |>\nThe answer using stringr only works if you put it in lowercase.\
    \ However, this might be the most efficient solution:\n<code>\n    string <- \"\
    Hello\"\n    string2 <- tolower(string)\n    \n    sum(grepl(\"[aeiouAEIOU]\"\
    , string2))\n    [1] 2\n    \n    sum(grepl(\"[aeiouAEIOU]\", string))\n    [1]\
    \ 2\n</code>\n<|/ a |>\n<| a tags=string,r |>\n<code>\nstring <- \"Hello\"\nsum(grepl(\"\
    [aeiouAEIOU]\",string))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for this\
    \ code snippet, which may provide some immediate help.  A proper explanation [would\
    \ greatly improve](//meta.", "\n  sum(grepl(\"[aeiou]\",s,fixed = TRUE))\n}\n",
  "\n\ts <- tolower(s)\n\tvec <- strsplit(s, '')[[1]]\n\tlength(which(grepl('[aeiou]',\
    \ vec, ignore.case = TRUE)))\n}\n</cell>\n<cell>\ncount_upper('babababa') # 'ab'\n\
    </cell>\n<cell>\ncount_upper('abBcDdEe') # 'bcd'\n</cell>\n<cell>\ncount_upper('abBcDdEe')\
    \ # 'bcd'\n</cell>\n<cell>\ncount_upper('abBcDdEe') # 'bcd'\n</cell>\n<cell>\n\
    count_upper('abBcDdEe') # 'bcd'\n</cell>\n<text>\nChallenge\nWrite a function\
    \ count_consonants that counts the number of consonants in an input string\nHint:\
    \ use grepl\n\n\n</text>\n<cell>\ncount_consonants <- function(s) {\n  s <- tolower(s)\n\
    \  vec <- strsplit(s, '')[[1]]\n  length(grepl('[^aeiou]', vec, ignore.case =\
    \ TRUE))\n}\n</cell>\n<cell>\ncount_consonants('babababa') # 'ba'\n</cell>\n<cell>\n\
    count_consonants('abBcDdEe') # 'bcd'\n</cell>\n<cell>\ncount_consonants('abBcDdEe')\
    \ # 'bcd'\n</cell>\n<cell>\ncount_consonants('abBcDdEe') # 'bcd'\n</cell>\n<cell>\n\
    count_consonants('abBcDdEe') # 'bcd'\n</cell>\n<text>\nChallenge\nWrite a function\
    \ count_digits that counts the number of digits in an input string\nHint: use\
    \ regexpr and stringi::stri_count_characters\n\n\n</text>\n<cell>\ncount_digits\
    \ <- function(s) {\n  s <- tolower(s)\n  vec <- strsplit(s, '')[[1]]\n  stri_count_characters(vec)\
    \ %>% sum()\n}\n</cell>\n<cell>\ncount_digits('babababa') # 'ba'\n</cell>\n<cell>\n\
    count_digits('abBcDdEe') # 'bcd'\n</cell>\n<cell>\ncount_digits('abBcDdEe') #\
    \ 'b", "\n  return(sum(grepl('^[aeiou]$', s, perl = T)))\n}\n</cell>\n<text>\n\
    Now, let's see how we can use these functions to answer questions about our favorite\
    \ dataset.\n\nIn this dataset, each row represents an animal and the corresponding\
    \ columns represent their attributes. For each animal, we know which of these\
    \ attributes are \"animal\" attributes and which are \"non-animal\" attributes.\
    \ The number of \"animal\" attributes is equal to the number of rows in the dataset\
    \ and each \"non-animal\" attribute has the number of non-animal attributes that\
    \ belong to that row.\n\n\n</text>\n<cell>", "\n  sapply(strsplit(s, \"\"), function(x)\
    \ sum(toupper(x[seq_along(x)]) == 'A'))\n}\n", "\n\tl <- strsplit(s, '')\n\tn\
    \ <- 0\n\tfor(i in 1:(length(l) - 1)) {\n\t\tif(substring(l[i], 2, 2)=='aeiuo')\n\
    \t\t\tn <- n + 1\n\t}\n\treturn(n)\n}\n", "\n  x <- unlist(strsplit(s, ''))\n\
    \  x <- x[x>='a' & x<='z']\n  sum(x[seq(2, length(x), by=2)])\n}\n", "\n    n\
    \ <- length(s)\n    if (n == 0) return 0\n    c <- c('a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n           'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n    even_index <- seq(1, n, by=2)\n\
    \    count_upper <- sapply(even_index, function(x) {\n        sum(toupper(substr(s,\
    \ x, x))==c)\n    })\n    return(count_upper)\n}\n</cell>\n<text>\nCount Vowels\n\
    Now we are ready to start writing our functions. We have already provided a function\
    \ that will count the vowels in a string. The function should take a single string\
    \ as its input and return a numeric vector of length equal to the length of the\
    \ input string with all elements as 0, except the element at index i which is\
    \ equal to the number of times we have seen the vowel at position i in the string.\
    \ The function will require a for loop to work as intended.\n\nThe function may\
    \ have some inputs that will help us understand our function. You can find them\
    \ at the bottom of this notebook.\n\nTo test your function, run this code:\n\n\
    \n</text>\n<cell>\ncount_vowels(\"abcef\")\n</cell>\n<text>\nYour answer should\
    \ match the table below:\n\n Letter  Count  Example  Output \n\n a  1  abcef \
    \ 1 \n b  1  abcef  1 \n c  1  abcef  1 \n e  2  abcef  2 \n f  1  abcef  1 \n\
    \n</text>\n<cell>\ncount_vowels <- function(s) {\n    n <- length(s)\n    if (n\
    \ == 0) return 0\n    c <- c('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm',\n           'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n    count_vowels <- rep(0,n)\n    for (i in 1:n) {\n       \
    \ count_vowels[i] <- sum(toupper(substr(s, i, i))==c)\n    }\n    return(count_vowels)\n\
    }\n</cell>\n<cell>", "\n  sum(toupper(s) + toupper(s[2])) > 0\n}\n", "\n  n <-\
    \ length(s)\n  ifelse(n%%2 == 1, sum(grepl(\"[AEIOU]\", s[seq(1,n/2,2)])), n)\n\
    }\n</cell>\n<cell>", "\n  s <- tolower(s)\n  out <- 0\n  for(i in seq_along(s))\
    \ {\n    if(s[i] %in% letters) {\n      if(s[i] == 'e' || s[i] == 'i' || s[i]\
    \ == 'o' || s[i] == 'u') out <- out + 1\n    }\n  }\n  out\n}\n</code>\nA more\
    \ functional approach, which should be faster:\n<code>", "\n  sum(unlist(strsplit(s,\
    \ \"\")[seq(2,length(strsplit(s, \"\")[[1]]),2)]) %in% c(\"A\", \"E\", \"I\",\
    \ \"O\", \"U\", \"a\",\"e\",\"i\",\"o\",\"u\"))\n}\n", "\n  evens <- gregexpr(\"\
    [aeiou]$\", s, perl=T)[[1]]\n  sum(regmatches(s, evens) %in% c(\"A\", \"E\", \"\
    I\", \"O\", \"U\"))\n}\n", "\n  count <- 0\n  for(i in 1:length(s)) {\n    if(s[i]\
    \ %in% c('a', 'e', 'i', 'o', 'u')) \n      count <- count + 1\n  }\n  return(count)\n\
    }\n\ncount_upper(\"aabbbcc\")", "\n  sum(grepl(\"^([aeiou])\", s, perl=TRUE) &\
    \ substr(s, 2, 2) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"))\n}\n", "\n\
    \    s <- gsub('[^aeiou]', '', s)\n    sapply(seq_along(s), function(i) sum(i\
    \ %% 2 == 0 & toupper(s[i]) == s[i]))\n}\n", "\n  n = 0\n  for (i in seq_along(s))\
    \ {\n    if(substr(s[i],1,1) == toupper(substr(s[i],1,1))) {\n      n <- n + 1\n\
    \    }\n  }\n  return(n)\n}\n", "\n  sum(grepl(\"^[aeiou]{2}\", s))\n}\n", "\n\
    \  s <- tolower(s)\n  sapply(seq_along(s), function(i)\n    sum(grepl(\"[aeiou]$\"\
    , s[seq(i, i, by=2)])) > 0)\n}\n</code>\nTest:\n<code>\n> count_upper(\"aBCdEf\"\
    )\n[1] 1\n> count_upper(\"abcdefg\")\n[1] 0\n> count_upper(\"dBBE\")\n[1] 0\n\
    </code>\n<|/ a |>\n<| a dscore=1 tags=r,count |>\nHere's a variation on the theme\
    \ of David's (+1), which I think works even better:\n<code>\ncount_upper2 <- function(x){\n\
    \  x <- tolower(x)\n  sapply(seq_along(x), function(i)\n    sum(grepl(\"[aeiou]$\"\
    , x[seq(i, i, by=2)])))\n}\n\ncount_upper(\"abcdefg\")\n[1] 0\ncount_upper(\"\
    dBBE\")\n[1] 0\ncount_upper2(\"abcdefg\")\n[1] 1\ncount_upper2(\"dBBE\")\n[1]\
    \ 0\n</code>\n<|/ a |>\n<| a tags=r,count dscore=0 |>\nHow about using sapply\
    \ and grep?\n<code>\nsapply(seq_along(s), function(i)\n  sum(grepl(\"[aeiou]$\"\
    , s[seq(i, i, by=2)])))\n</code>\n<|/ a |>\n<| c |>\nI think this won't work if\
    \ the string is `\"dBBE\"`, which should return `0`, but returns `1`.\n<|/ c |>\n\
    <| c |>\n, thanks for your input! I think you are right, I didn't pay attention\
    \ to the exact case. I updated my answer so it would return 0 when `dBBE` is input.\n\
    <|/ c |>\n<| c |>\nAh yes, I see what you mean. Your edit looks great; I'll see\
    \ if I can edit my answer to match.\n<|/ c |>\n<| a tags=r,count |>\n<code>\n\
    count_upper <- function(string){\n  sapply(seq_along(string), function(i) sum(grepl(\"\
    [aeiou]$\", string[seq(i, i, by=2)])))\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,count\
    \ dscore=0 |>\n<code>\ncount_upper <- function(s) {\n  s <- tolower(s)\n  sapply(seq_along(s),\
    \ function(i)\n    sum(grepl(\"[aeiou]$\", s[seq(i, i, by=2)])) > 0)\n}\n\ncount_upper(\"\
    abcDefG\")\n[1] 0", "\n  n <- 0\n  n <- length(s) \n  for (j in 1:n) {\n    if\
    \ (j%% 2 == 1) {\n      s <- s[(j+1):n] \n      n <- n+1\n    }\n    for (i in\
    \ 1:length(s)) {\n      if (substr(s[i],i,i)==\"A\" | substr(s[i],i,i)==\"a\"\
    \ | substr(s[i],i,i)==\"B\" | substr(s[i],i,i)==\"b\" | substr(s[i],i,i)==\"C\"\
    \ | substr(s[i],i,i)==\"c\" | substr(s[i],i,i)==\"D\" | substr(s[i],i,i)==\"d\"\
    \ | substr(s[i],i,i)==\"E\" | substr(s[i],i,i)==\"e\" | substr(s[i],i,i)==\"F\"\
    \ | substr(s[i],i,i)==\"f\") {\n        n <- n+1\n      }\n    }\n  }\n  n\n}\n\
    </cell>\n<text>\nNow let's count the number of uppercase vowels in each word of\
    \ a string of length 250 characters. We do so by looping over each character in\
    \ the string and counting the number of uppercase vowels in each word in the string.\n\
    \n\n</text>\n<cell>", "\n  u <- unlist(strsplit(s, '[[:upper:]]'))\n  length(u[seq(2,\
    \ length(u), 2)])\n}\n</code>\n<|/ a dscore=2 tags=regex,r,string |>\n<| c |>\n\
    Thank you for your answer!  I edited my question to explain what I'm looking for.\
    \  Please let me know if that doesn't make sense.  I believe your function does\
    \ work, but I don't understand how or why.\n<|/ c |>\n<| c |>\nOkay that does\
    \ make sense, but I thought you were looking for the number of upper case letters\
    \ in *any* position within a string? And your example output doesn't match what\
    \ your function says it does. Can you clarify your goal?\n<|/ c |>\n<| c |>\n\
    Thank you for the clarification!  I see how your function works.  I understand\
    \ how you created the vector of characters, but why does it not work the way I\
    \ was trying to do it?\n<|/ c |>\n<| c |>\nI updated the answer, I think it does\
    \ what you were after\n<|/ c |>\n<| a tags=regex,r,string dscore=2 |>\nIf you\
    \ want it to only return the uppercase letters in the even positions within your\
    \ string then this will work:\n<code>\ns <- \"aBcDeFgHIjkl\"\nstrsplit(s, split\
    \ = \"\")[[1]][seq(2, length(strsplit(s, split = \"\")[[1]]), 2)]", "\n  n <-\
    \ length(s);\n  rep(0,n) <- sapply(1:n, function(i) \n    sum(toupper(s[i:(i +\
    \ length(s)/2)]) == 'A'));\n  return(n);\n}\n", "\n  unlist(lapply(strsplit(s,\
    \ ''), function(x) sum(grepl('([[:upper:]]$)', x) & x%%2==0)))\n}\n</cell>\n<cell>\n\
    count_upper('The quick brown fox jumps over the lazy dog')\n</cell>\n<text>\n\
    Exercise: Write a function that takes in a string and returns the number of characters\
    \ in it that are lowercase vowels.\n\n\n</text>\n<cell>", "\n  s <- toupper(s);\n\
    \  sum(grepl(\"[AEIOU]\", s));\n}\n", "\n    count <- 0\n    for(i in seq_along(s))\n\
    \        if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] ==\
    \ 'U')\n            count <- count + 1\n    return(count)\n}\n", "\n  n_evens\
    \ <- sum(substr(s, start = 1L, end = 2L) %in% 'aeiou')\n  n_odds <- sum(substr(s,\
    \ start = 2L, end = 3L) %in% 'aeiou')\n  n_vowels <- sum(substr(s, start = 1L,\
    \ end = 3L) %in% 'aeiou')\n  n_consonants <- sum(substr(s, start = 1L, end = 2L)\
    \ %in% 'bcdfghjklmnoprtvwxyz')\n  n_both_cases <- n_vowels + n_consonants + n_odds\n\
    \  n_uppercase_vowels <- n_evens - n_both_cases\n  if (n_both_cases ==0) return(0)\n\
    \  return(n_uppercase_vowels)\n}\n", "\n  uv_count <- function(x) {\n    sum <-\
    \ 0\n    for (i in 1:length(x)) {\n      if (substr(x, i, i) == 'U' || substr(x,\
    \ i, i) == 'u') {\n        sum <- sum + 1\n      }\n    }\n    return(sum)\n \
    \ }\n  uv_count_list <- unlist(lapply(seq_along(s), uv_count))\n  sum <- 0\n \
    \ for (i in seq_along(uv_count_list)) {\n    if (uv_count_list[i] > 0) {\n   \
    \   sum <- sum + uv_count_list[i]\n    }\n  }\n  return(sum)\n}\n</code>\nTest\
    \ it:\n<code>\n> count_upper(\"aBCdEf\")\n[1] 1\n> count_upper(\"abcdefg\")\n\
    [1] 0\n> count_upper(\"dBBE\")\n[1] 0\n</code>\n<|/ a dscore=1 tags=r,string |>\n\
    <| c |>\nI believe this counts the number of upper case vowels instead of how\
    \ many there are. For instance, this function returns 2 when passed a string with\
    \ both upper and lower case vowels: `\"aBcDeFg\"`.\n<|/ c |>\n<| c |>\nOops, you're\
    \ right. I misunderstood the requirement. I'll fix it, but be very careful about\
    \ using `stringi` for anything other than simple string manipulation, as it's\
    \ very slow.\n<|/ c |>\n<| c |>\nI added a solution using `stringi`, but it's\
    \ going to be very slow.\n<|/ c |>\n<| c |>\nI tested both functions against each\
    \ other and it seems that your second solution is faster (by about x10).\n<|/\
    \ c |>\n<| c |>\nYou're right - this one is the slowest (but very clever). I've\
    \ updated my solution to use the `stringi` package instead of `sapply`.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nI suggest using the stringr package as this is designed\
    \ for this type of thing. It has a function that will do just this. \n<code>\n\
    library(stringr)\n", "\n  count_vowel <- function(x) {\n    sum(!uppercase %in%\
    \ strsplit(as.character(x), \"\")[[1]])\n  }\n  apply(s, 2, count_vowel)\n}\n",
  "\n    sum(grepl(\"^[^aeiou]\", s, perl = TRUE)) + sum(grepl(\"^[aeiou]\", s, perl\
    \ = TRUE))\n}\n</code>\n<|/ a tags=r,dataframe,count |>\n<| c |>\nI'm glad it\
    \ worked for you. Since this solved your problem, please accept the answer (check\
    \ mark below the votes). See https://stackoverflow.com/help/someone-answers for\
    \ more information.\n<|/ c |>\n<| c |>\nI'm glad it worked for you. Since this\
    \ solved your problem, please accept the answer (check mark below the votes).\
    \ See https://stackoverflow.com/help/someone-answers for more information.\n<|/\
    \ c |>\n<| a tags=r,dataframe,count |>\nJust to give another option for base R,\
    \ you can do this by splitting your string in 2 parts and then counting the number\
    \ of strings in each part:\n<code>\nnchar(unlist(strsplit(s, split = \"[aeiou]\"\
    ))[seq(1, length(unlist(strsplit(s, split = \"[aeiou]\"))), 2)])", "\n  # This\
    \ function is slightly modified from \n  # http://stackoverflow.com/questions/1147841/python-count-the-number-of-times-a-character-appears-in-a-string\n\
    \  n <- nchar(s);\n  num <- 0;\n  for(k in seq_len(n)) {\n    if((k %% 2 == 1)\
    \ & nchar(substr(s, k, k)) > 1) {\n      num <- num + 1;\n    }\n  }\n  return(num);\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like the simplicity of your `count_upper`,\
    \ but your implementation is overly complicated. Your function can be reduced\
    \ to `count_upper <- function(s) nchar(s) %% 2 == 1`.\n<|/ c |>\n<| c |>\nThanks,\
    \ I didn't know `nchar` could be used this way. Also note I didn't use `return`\
    \ at the end; `return` just exits the function and returns the last evaluated\
    \ expression. Thanks again for the suggestion.\n<|/ c |>\n<| c |>\nOh, I didn't\
    \ even notice that. I was looking at the `if` statement in your code. Just wanted\
    \ to make it clear what I was thinking.\n<|/ c |>\n<| c |>\nThank you, it's clear\
    \ now. I've accepted the other answer because it also shows how to get rid of\
    \ the `if` statement and return the number of times a given letter occurs in a\
    \ string.\n<|/ c |>\n<| a dscore=2 |>\nWe can do this by checking whether the\
    \ number is even or odd.\n<code>\ncount_upper <- function(x){\n  if(length(x)>0){\n\
    \    if(nchar(x)==1){\n      nchar(x)\n    }else{\n      if((nchar(x)%%2) == 1){\n\
    \        return(nchar(x)+1)\n      }else{\n        return(0)\n      }\n    }\n\
    \  }\n}\n</code>\n<|/ a tags=r,function |>\n<| a tags=r,function |>\n<code>\n\
    count_upper <- function(x) nchar(x)%%2==1\n\ncount_upper(\"aaaaAABB\")", "\n \
    \   l <- strsplit(s, '')\n    sum(sapply(l, function(x) {\n        length(gregexpr(paste0('(?i)([aeiou])'),\
    \ x)[[1]])>0\n    }))\n}\n", "\n  n <- nchar(s);\n  v <- c(FALSE, TRUE)[(n%%2L\
    \ == 0L) + 0L];\n  n * (n + 1L) / 2 + (sum(v) - 2L) * v\n}\n</cell>\n<cell>",
  "\n  s <- gsub(\"[AEIOU]\", \"\", s)\n  length(grep(\"^[aeiou]\",s,value=TRUE))\n\
    }\n</code>\nAnd now we can apply this function to each element of df$text:\n<code>\n\
    df$numVowels <- apply(df$text, 1, count_upper)\n</code>\nThe result:\n<code>\n\
    > df\n                                  text  numVowels\n1             The first\
    \ time I saw a cat   28\n2 Though I did not like the raining cat, I fell in love\
    \ ...   27\n3                   Man ran into the cat   26\n4                 \
    \        I knew the cat   25\n5                 The cat had a great laugh   24\n\
    6                         The cat liked his life   23\n7 He lived with the cat\
    \ for a while, then he ...   22\n8             I felt the cat was getting hungry\
    \   21\n9                    The cat looked at the window   20\n10 The cat thought\
    \ it was the best cat   19\n11   The cat thought it would be a good cat   18\n\
    12   He knew the cat was a good cat   17\n13                         The cat looked\
    \ at his ...   16\n14                         The cat seemed to be ...   15\n\
    15              The cat felt a little bit of ...   14\n16                    \
    \       The cat caught the eye   13\n17  I knew the cat was looking for a cat\
    \   12\n18                     The cat was all white   11\n19 A bad cat walked\
    \ into a barber shop   10\n20          The cat caught a black and white ...  \
    \  9\n</code>\n<|/ a |>\n<| c |>\nThank you this was really helpful! I knew there\
    \ would be a very simple solution. I will try this shortly and get back to you!\n\
    <|/ c |>\n<| a dscore=1 |>\nA solution using stringr as suggested by is good.\
    \ However there is a simpler solution in base:\n<code>\ndf$numVowels <- sum(grepl(\"\
    [aeiou]\",df$text))\n</code>\nIf you need to keep it very simple and don't use\
    \ stringr, then you can use the following solution:\n<code>\ndf$numVowels <- grepl(\"\
    [aeiou]\",df$text) * sum(grepl(\"[aeiou]\",df$text))\n</code>\nThe first line\
    \ counts the number of occurrences of \"[aeiou]\" in the whole string, while the\
    \ second line counts the number of occurrence", "\n  # Count occurences of capital\
    \ letters starting at even.\n  counts <- gregexpr('[A-Z]', s, perl = TRUE)\n \
    \ count <- sum(counts[seq(2, lengths(counts), 2)]) * 2\n  return(count)\n}\n\n\
    count_upper(\n  c(\"aBCdEf\",\n    \"abcdefg\",\n    \"dBBE\",\n    \"aBcDef\"\
    ))\n</cell>\n<text>\nGreat! Now that you have a working function, you can vectorize\
    \ it. We will be using the same function above in a later exercise; you might\
    \ want to try using for loops to complete the function.\n\nThe function below\
    \ takes a string, and returns a logical vector indicating which elements of s\
    \ are evenly divisible by 3. More precisely, it should return TRUE if (and only\
    \ if) the corresponding elements in the vector are divisible by 3. For example,\
    \ the string \"a\" is evenly divisible by 3. But it also returns TRUE if \"a\"\
    \ is evenly divisible by 5, because \"a\" is a factor of 3 in the remainder of\
    \ \"aBCdEf\". That means \"a\" is not an upper case vowel.\n\nSince there are\
    \ many ways to do this, your task is to write a function which takes a string\
    \ as its input and returns the logical vector as its output. The function should\
    \ return a single vector of logicals, as shown above. The function should have\
    \ one line of code.\n\n\n</text>\n<cell>", "\n  s <- gsub(\" \", \"\", s)\n  n\
    \ <- length(s)\n  s <- toupper(s)\n  sapply(seq_len(n), function(k) sum(s[k:n]\
    \ %in% c(\"A\", \"E\", \"I\", \"O\", \"U\")))\n}\n", "\n    count_up <- function(x)\
    \ {\n        sum(x %in% letters[upper]) / 2\n    }\n    Reduce(count_up, xreg(s))\n\
    }\n", "\n  ux <- gregexpr(\"\\\\B\", s)\n  sum(grepl(\"[aeiou]\", s[ux[[1]]])\
    \ & sapply(ux, `[`, 2))\n}\n</cell>\n<text>\nExercise\nNow try it out on a few\
    \ other strings, such as\n\nabBcDEFabcDEF\nabcxcdefABC\nabxddefabcxc\nAbBcDDEFabcxC\n\
    AbBCcDDDabcxC\nabBcCdefABxC\nabBcCdefABxC\nAbBcCDEFabcxC\nAbBcCDEFabcxc\nAbBCcDDEFabcxc\n\
    abBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\n\
    abBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\n\
    abBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\n\
    abBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\n\
    abBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\n\
    abBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\n\
    abBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABxC\nabBCdEfABx", "\n  r <- 0\n\
    \  for (i in seq_along(s)) {\n    if (i%%2 == 0 && s[i] >= 'a' && s[i] <= 'z')\
    \ {\n      r <- r + 1\n    }\n  }\n  r\n}\n</cell>\n<text>\nExercise 6\nCreate\
    \ a function that counts the number of vowels in a given string, but takes the\
    \ vowels into account.  Note that 'o' is included in the counting, while 'a' and\
    \ 'e' only occur once per letter, and 'u' only occurs once per word.  Also note\
    \ that the vowel counting function should count 'y' as a vowel only once per word.\
    \  Use a regular expression to identify the words you want to count, and then\
    \ use that to count the vowels.\n\nHINT: Try using strsplit to split your string\
    \ on a regular expression (like [:upper:]) which matches only upper case letters.\
    \  Also try using gsub to replace 'u' with 'u' to get rid of any words with 'u'.\n\
    \n\n</text>\n<cell>", "\n  n <- nchar(s)\n  if(n < 2) return(0)\n  i <- 0\n  while(n[i]\
    \ > 0) i <- i + n[i]\n  i <- i - 1\n  if(i %% 2 == 0) return(0)\n  i <- i + 1\n\
    \  while(n[i] > 0) i <- i + n[i]\n  return(i / 2)\n}\n</cell>\n<text>\nExercise\
    \ 1: Write a function that accepts a string and returns the number of vowels present\
    \ in it\n\n</text>\n<cell>", "\n  count <- 0\n  for(i in seq_along(s)) {\n   \
    \ c <- as.character(s[i])\n    if(grepl(\"[aeiou]\", c)) {\n      count <- count\
    \ + 1\n    }\n  }\n  return(count)\n}\n", "\n    n <- sum(grepl(\"[aeiou]\", s))\n\
    \    n\n}\n", "\n  # Special case\n  if (length(s) == 0) return 0\n  \n  # If\
    \ length is not even, return 0.\n  if (length(s) %% 2 == 0) return 0\n\n  # Find\
    \ all the uppercase letters.\n  uppers <- which(sapply(s, function(x) toupper(x)\
    \ == x))\n\n  # Count the number of times each of these uppercase letters appears\n\
    \  # in the even indices.\n  unlist(table(uppers[seq(1, length(uppers), 2)]))\n\
    }\n", "\n    n <- length(s)\n    if (n <= 0) return(0)\n    sum <- 0\n    for\
    \ (i in seq_len(n))\n        if (s[i] != toupper(s[i]) && s[i] != 'A' && s[i]\
    \ != 'E')\n            sum <- sum + 1\n    return(sum)\n}\n", "\n    s <- tolower(s)\n\
    \    i <- 1\n    res <- 0L\n    while (i<=length(s)) {\n        i <- i+1L\n  \
    \      x <- s[i]\n        if(x %in% LETTERS) {\n            res <- res + 1L\n\
    \        }\n        if(i %% 2 == 0) {\n            res <- res + 1L\n        }\n\
    \    }\n    return(res)\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere's\
    \ a recursive solution that uses a helper function to count each vowel:\n<code>\n\
    count_upper <- function(s) {\n    vowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n    if (sum(s %in% vowels) == 0) {\n        return(0)\n    }\n    if (sum(s\
    \ %in% vowels) == 1) {\n        return(1)\n    }\n    i <- 1L\n    sum_rec <-\
    \ 0L\n    s <- tolower(s)\n    while (i <= length(s)) {\n        if (s[i] %in%\
    \ vowels) {\n            sum_rec <- sum_rec + count_upper(s[i+1L:i])\n       \
    \ }\n        i <- i + 1L\n    }\n    return(sum_rec)\n}\n</code>\n<|/ a tags=r,function,string\
    \ |>\n<| a |>\nMy solution in R:\n<code>\ncount_upper <- function(s) {\n    s\
    \ <- tolower(s)\n    i <- 1\n    res <- 0L\n    while (i <= length(s)) {\n   \
    \     i <- i + 1L\n        if (s[i] %in% \"aeiou\") {\n            res <- res\
    \ + 1L\n        }\n        if (i %% 2 == 0) {\n            res <- res + 1L\n \
    \       }\n    }\n    return(res)\n}\n</code>\n<|/ a dscore=0 tags=r,function,string\
    \ |>\n<| a dscore=0 tags=r,function,string |>\nA solution using gregexpr:\n<code>\n\
    count_upper <- function(s) {\n  gregexpr(\"[aeiou]\",tolower(s)) %>% \n    apply(.,2,sum)\
    \ %>% \n    sum\n}\n</code>\n<|/ a |>\n<| c |>\nI like this one - it allows more\
    \ flexibility in terms of what characters you want in the string to be considered\
    \ a vowel.\n<|/ c |>\n<| c |>\nThanks,! Yes, that's really powerful, because it\
    \ allows you to check a vector of patterns rather than just a single one.\n<|/\
    \ c |>\n<| a dscore=0 |>\nHere is a solution using regex\n<code>\ncount_upper\
    \ <- function(s) {\n  s ", "\n  sum(toupper(s[seq(1, length(s) - 1, 2)])%%2)\n\
    }\n</cell>\n<cell>\ncount_upper(\"aBCdEf\")\n</cell>\n<text>\nMore Exercises\n\
    \n</text>\n<text>\nWrite a function to check whether a string is palindrome or\
    \ not.\n\n\n</text>\n<cell>", "\n    stopifnot(all(grepl('^[a-z]+$', s))) # make\
    \ sure we only deal with strings with lower case\n    grep('[a-z]+$',s) %>% \n\
    \        which(grepl('^[^aeiou]+$', s)) %>% \n        sum() %>% \n        round\n\
    }\n", "\n  n <- nchar(s)\n  m <- length(s)\n  evens <- seq(1, m, 2)\n  counts\
    \ <- 0\n  for (i in evens) {\n    if (substring(s, i, i) == \"A\"\n        ||\
    \ substring(s, i, i) == \"a\"\n        || substring(s, i, i) == \"E\"\n      \
    \  || substring(s, i, i) == \"e\") {\n      counts <- counts + 1\n    }\n  }\n\
    \  counts\n}\n", "\n  sum(grepl('(?i)[aeiou]$', s, perl=TRUE) & grepl('[AEIOU]',\
    \ s, perl=TRUE))\n}\n", "\n  s <- gsub(\"\\\\s\", \"\", s)\n  sapply(strsplit(s,\
    \ \"\"), function(x) sum(grepl(\"[AEIOU]\", x)))\n}\n</cell>\n<text>\nExercise\n\
    Using the above functions, write a function that counts the number of lowercase\
    \ vowels in an input string. Return 0 if no vowels are found.\n\n\n</text>\n<cell>",
  "\n  sapply(strsplit(s, ''), function(x) sum(x == 'e'))\n}\n", "\n  uc <- gsub(\"\
    [aeiouAEIOU]\", \"\", s)\n  uc[grepl(\"^[aeiou]$\", s)] <- 0\n  sum(uc[grepl(\"\
    ^[aeiou]$\", s)])\n}\n", "\n  n <- nchar(s);\n  v <- 0L;\n  for (i in seq_along(s))\
    \ {\n    if (i %% 2L == 0L && i > 0L) {\n      v <- v + 1L;\n    }\n  }\n  v;\n\
    }\n</code>\nTests:\n<code>\n> count_upper(\"aBCdEf\")\n[1] 1\n> count_upper(\"\
    abcdefg\")\n[1] 0\n> count_upper(\"dBBE\")\n[1] 0\n</code>\n<|/ a dscore=3 |>\n\
    <| a |>\nUsing dplyr\n<code>\nlibrary(dplyr)\ncount_upper <- function(s) sum(grepl('[aeiou]',\
    \ s, ignore.case = T))\ncount_upper(\"aBCdEf\")", "\n  s <- tolower(s)\n  sapply(seq_along(s),\
    \ function(i) sum(s[i:1] %in% letters[26:1]))\n}\n", "\n    sum(unlist(strsplit(s,\
    \ '')) %% 2L == 0L)\n}\n</code>\nIt doesn't return anything explicitly, but that\
    \ should be fairly straightforward.\nFor bonus points, make the function vectorized\
    \ so that, e.g., the following work:\n<code>\ncount_upper(\"aBCdEf\")\n</code>\n\
    <|/ a dscore=3 tags=r,indexing,character |>\n<| a tags=r,indexing,character |>\n\
    You can also do this with a nested ifelse statement:\n<code>\nlibrary(dplyr)",
  "\n  sapply(s, function(x) {\n    sum(substr(x, 1, 1) %in% c('a', 'e', 'i', 'o',\
    \ 'u')) * 2\n  })\n}\n", "\n  s <- str_replace_all(s, '[^aeiouyY]', '')\n  nchar(gsub('[A-Z]',\
    \ '', s))\n}\n</code>\nThe function count_upper is quite simple. It replaces all\
    \ the characters that are not vowels and uppercase vowels with nothing. Then,\
    \ it is just counting the characters from the input string that don't have any\
    \ uppercase vowels. \nThe main function would then look like this:\n<code>\nmain\
    \ = function() {\n  s <- readline(\"String: \")\n  count_upper(s)\n}\n</code>\n\
    EDIT: After some discussion, the OP has indicated that he wants to implement a\
    \ custom version of grepl to return a list of matches instead of simply printing\
    \ all the matches. I didn't go into details because it's already been explained\
    \ in other answers. Here is a solution that does this:\n<code>\nmygrepl = function(pattern,\
    \ string) {\n  pattern <- strsplit(pattern, \"\\\\W+\")[[1]]\n  grepl(pattern,\
    \ string, perl = TRUE)\n}\n", "\n\tlen <- length(s)\n\tres <- 0\n\tfor (i <- seq_len(len))\
    \ {\n\t\tres[i] <- sum(grepl(\"[aeiou]\", s[i], perl=TRUE))\n\t}\n\tres\n}\n</cell>\n\
    <cell>", "\n  result <- 0\n  i <- 0\n  j <- 0\n  n <- length(s)\n  while (i <\
    \ n) {\n    if (substring(s, i, i) == 'a') {\n      j <<- j + 1\n      i <<- i\
    \ + 1\n    } else if (substring(s, i, i) == 'b') {\n      j <<- j + 1\n      i\
    \ <<- i + 1\n    } else if (substring(s, i, i) == 'c') {\n      j <<- j + 1\n\
    \      i <<- i + 1\n    } else if (substring(s, i, i) == 'd') {\n      j <<- j\
    \ + 1\n      i <<- i + 1\n    } else if (substring(s, i, i) == 'e') {\n      j\
    \ <<- j + 1\n      i <<- i + 1\n    } else if (substring(s, i, i) == 'f') {\n\
    \      j <<- j + 1\n      i <<- i + 1\n    } else if (substring(s, i, i) == 'g')\
    \ {\n      j <<- j + 1\n      i <<- i + 1\n    } else {\n      i <<- i + 1\n \
    \   }\n    if (j % 2 == 0) {\n      result <<- result + 1\n    }\n  }\n  result\n\
    }\n", "\n    s <- tolower(s)\n    length(sapply(s, grepl, pattern = \"^[aeiouyAEIOUY]{2,}$\"\
    ))\n}\n", "\n    sum(grepl(\"^[aeiou]\", s[seq(1,nchar(s),2)], perl=TRUE) & !grepl(\"\
    ^[aeiou]\", s[seq(2,nchar(s),2)], perl=TRUE))\n}\n</cell>\n<cell>\ncount_upper(\"\
    aBCdEf\")\n</cell>\n<cell>\ncount_upper(\"abcdefg\")\n</cell>\n<cell>\ncount_upper(\"\
    dBBE\")\n</cell>\n<text>\nExercise\nWrite a function that will count the number\
    \ of uppercase vowels in a string. If there are no vowels, return 0.\nGiven a\
    \ string, count the number of uppercase vowels in even indices. For example:\n\
    >>> count_upper('aBCdEf')\n1\n>>> count_upper('abcdefg')\n0\n>>> count_upper('dBBE')\n\
    0\n</text>\n<cell>\ncount_upper <- function(s) {\n    sum(grepl(\"^[aeiou]\",\
    \ s[seq(1,nchar(s),2)], perl=TRUE) & !grepl(\"^[aeiou]\", s[seq(2,nchar(s),2)],\
    \ perl=TRUE))\n}\n</cell>\n<cell>\ncount_upper(\"aBCdEf\")\n</cell>\n<cell>\n\
    count_upper(\"abcdefg\")\n</cell>\n<cell>\ncount_upper(\"dBBE\")\n</cell>\n<text>\n\
    Exercise\nWrite a function that will return the number of letters in a string.\
    \ Ignore spaces.\n\n>>> count_letters(\"Hello World\")\n12\n>>> count_letters(\"\
    aBcD\")\n3\n>>> count_letters(\"abC d\")\n0\n\n</text>\n<cell>\ncount_letters\
    \ <- function(s) {\n    sum(grepl(\"^[a-z]\", s))\n}\n</cell>\n<cell>\ncount_letters(\"\
    Hello World\")\n</cell>\n<cell>\ncount_letters(\"aBcD\")\n</cell>\n<cell>\ncount_letters(\"\
    abC d\")\n</cell>\n<text>\nExercise\nWrite a function that will return the number\
    \ of uppercase letters in a string. Ignore spaces.\n\n>>> count_upper(\"Hello\
    \ World\")\n12\n>>> count_upper(\"aBcD\")\n3\n>>> count_upper(\"abC d\")\n0\n\n\
    </text>\n<cell>\ncount_upper <- function(s) {\n    sum(grepl(\"^[Aa]\", s))\n\
    }\n</cell>\n<cell>\ncount_upper(\"Hello World\")\n</", "\n  s <- unlist(strsplit(s,\
    \ \"[[:upper:]]\"))\n  sapply(s, function(x) sum(x %% 2 == 1))\n}\n</cell>\n<text>\n\
    We can see that it works. It's a little slow because of the overhead of converting\
    \ to a list.\n\n\n</text>\n<cell>\ncount_upper('abBCdEf')\n</cell>\n<text>\nWe\
    \ can vectorize this easily because there's only one pattern to match. Instead\
    \ of sapply, a vectorized function like apply would make much more sense. Here's\
    \ an example that counts the number of uppercase vowels in each of the words in\
    \ a string:\n\n\n</text>\n<cell>\ncount_upper <- function(s) {\n  apply(strsplit(s,\
    \ \"[[:upper:]]\"), 1, function(x) sum(x == x))\n}\n</cell>\n<text>\nNotice that\
    \ all we're doing is wrapping the pattern to match with [ ] to make it a vector.\
    \ Now the function works on an entire vector, which is much more efficient.\n\n\
    \n</text>\n<cell>\ncount_upper('abBCdEf')\n</cell>\n<text>\nRemember, the pattern\
    \ match is done element-by-element. The above example works on a single string.\n\
    \n\n</text>\n<cell>\ncount_upper(\"abBCdEf\")\n</cell>\n<text>\nNow we can do\
    \ another one. Suppose we wanted to count the number of vowels in each word in\
    \ a sentence. Maybe we want to count each vowel only once, so that \"abBcDeEf\"\
    \ results in [1, 1, 0, 2, 1, 1, 0, 1]. We'd need to use strsplit. Let's try that:\n\
    \n\n</text>\n<cell>\ncount_upper <- function(s) {\n  strsplit(s, \"[[:upper:]]\"\
    )\n}\n</cell>\n<text>\nNow we can see it works:\n\n\n</text>\n<cell>\ncount_upper(\"\
    abBcDeEf\")\n</cell>\n<text>\nThe next question is: how can we return a list where\
    \ each element represents a unique uppercase vowel? We could do this with a for\
    \ loop:\n\n\n</text>\n<cell>\ncount_upper <- function(s) {\n  out <- NULL\n  for\
    \ (i in 1:length(s)) {\n    thisChar <- s[i]\n    if (thisChar %% 2 == 1) {\n\
    \      out <- c(out, i)\n    }\n  }\n  return(out)\n}\n</cell>\n<text>\nBut we\
    \ can do better! There are several ways to vectorize a for loop, but one of the\
    \ most common is to replace the for loop with a call to sapply, like this:\n\n\
    \n</text>\n<cell>\ncount_upper <- function(s) {\n  sapply(s, function(x) {", "\n\
    \  n <- length(s);\n  upper <- 0;\n  for(i in seq_len(n)) {\n    if(substr(s,\
    \ i, i) == 'A') upper <- upper + 1;\n    if(substr(s, i, i) == 'a') upper <- upper\
    \ + 1;\n  }\n  upper;\n}\n", "\n  uc <- gregexpr(\"[AEIOUaeiou]\",s)\n  sum(grepl(\"\
    [AEIOUaeiou]\",s[uc[[1]]]) & grepl(\"[aeiou]\",s[uc[[2]]]) | grepl(\"[aeiou]\"\
    ,s[uc[[3]]]))\n}\n", "\n  s <- tolower(s)\n  sum(grepl(\"^[aeiouyAEIOUY]{2,}$\"\
    , s))\n}\n</code>\n<|/ a tags=string,r,regex |>\n<| c |>\nThis regex doesn't take\
    \ into account that the input string could be `'dBBE'` and not `'dBBEf'`. You\
    \ could fix that by replacing `^[aeiouyAEIOUY]{2,}$` with `^[aeiouyAEIOUY]+$`\n\
    <|/ c |>\n<| c |>\nThe question asks for lower-cased vowels.\n<|/ c |>\n<| a tags=string,r,regex\
    \ |>\nYou can use str_count from stringr package\n<code>\nlibrary(stringr)\n\n\
    str_count(s, \"[AEIOU]\")\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhy does this\
    \ not have more upvotes?\n<|/ c |>\n<| a tags=string,r,regex |>\nUsing strcount\
    \ from base R.\n<code>\n> strcount(\"dBBE\", \"[A-Z]+\")\n[1] 1\n</code>\n<|/\
    \ a dscore=3 |>\n<| a tags=string,r,regex |>\nThe stringr package has the strcount\
    \ function. \n<code>\n> library(stringr)\n> strcount(\"dBBE\", \"[aeiouyAEIOUY]+\"\
    )\n[1] 1\n</code>\n<|/ a dscore=3 |>\n<| a tags=string,r,regex |>\nUse str_count\
    \ from stringr:\n<code>\nstr_count(s, \"[aeiouyAEIOUY]+\")\n[1] 1\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\n<code>\n library(stringr)\n str_count(s, \"[aeiouyAEIOUY]+\"\
    )\n</code>\n<|/ a tags=string,r,regex dscore=2 |>\n<| a tags=string,r,regex |>\n\
    We can use str_count from stringr\n<code>\nlibrary(stringr)\nstr_count(s, '[aeiouyAEIOUY]+')",
  "\n    sum( grepl(\"^[AEIOU]\", s) )\n}\n", "\n  vowels <- c('a', 'e', 'i', 'o',\
    \ 'u')\n  s <- tolower(s)\n  num_upper <- 0\n  num_upper <- length(s) - length(gregexpr(paste(vowels,\
    \ collapse='|'), s)) - 1\n  num_upper\n}\n</cell>\n<cell>", "\n    s <- tolower(s)\n\
    \    ans <- 0\n    for(i in seq_along(s)) {\n        if(substr(s[i:i+2],1,2) %%\
    \ 2 == 0) ans <- ans + 1\n    }\n    return(ans)\n}\n</cell>\n<cell>", "\n  n\
    \ <- 0\n  for (i in seq_along(s)) {\n    if (s[i] %in% c(\"a\", \"e\", \"i\",\
    \ \"o\", \"u\")) n <- n + 1\n  }\n  n\n}\n", "\n  x <- strsplit(s, '')\n  sapply(x,\
    \ `[`, 1)\n}\n", "\n    sum(ifelse(substring(s, 1, 2) %in% c('aeiou'), 1, 0))\n\
    }\n", "\n  nchar(gsub(\"[^aeiou]\", \"\", s, perl = TRUE))\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nI like this one because it is very simple. But, for my specific\
    \ situation, it doesn't work. I have now edited my original post to give a more\
    \ detailed explanation of my problem.\n<|/ c |>\n<| c |>\nWhat do you mean by\
    \ \"doesn't work\"? It seems to work for me.\n<|/ c |>\n<| c |>\nWhen I try to\
    \ run my code I get the following error:\n\n`Error in gsub(\"[^aeiou]\", \"\"\
    , s, perl = TRUE) : \n  invalid regular expression '[^aeiou]', reason 'Missing\
    \ ')''`\n\nI'm sure it's something small but I can't seem to figure out what it\
    \ is.\n<|/ c |>\n<| c |>\nOops, I missed a closing parenthesis. Try it now.\n\
    <|/ c |>\n<| c |>\nThis works perfectly. I think my issue was that I didn't know\
    \ that you can combine functions. Thank you!\n<|/ c |>\n<| a dscore=1 |>\nYou\
    \ could try \n<code>\ncount_upper <- function(string) {\n  str_count(gsub(\"[[:upper:]]\"\
    , \"\", string, perl = TRUE), \"[[:upper:]]\")\n}\n</code>\n<|/ a tags=r |>\n\
    <| a tags=r |>\nJust in case you really need this kind of solution and you want\
    \ to use stringr, you can do:\n<code>\ncount_upper <- function(string){\n    str_count(gsub(\"\
    [^[:upper:]]\", \"\", string), \"[[:upper:]]\")\n}\n\nx <- \"This is some text\
    \ and some more text\"\ncount_upper(x)", "\n  if (length(s) <= 0) return 0\n \
    \ tmp <- 0\n  i <- 0\n  while (i < length(s)) {\n    if (substr(s, i, i) == 'A'\
    \ || substr(s, i, i) == 'a') {\n      tmp <- tmp + 1\n    } else if (substr(s,\
    \ i, i) == 'B' || substr(s, i, i) == 'b') {\n      tmp <- tmp + 0\n    } else\
    \ if (substr(s, i, i) == 'C' || substr(s, i, i) == 'c') {\n      tmp <- tmp +\
    \ 1\n    } else if (substr(s, i, i) == 'D' || substr(s, i, i) == 'd') {\n    \
    \  tmp <- tmp + 1\n    } else if (substr(s, i, i) == 'E' || substr(s, i, i) ==\
    \ 'e') {\n      tmp <- tmp + 1\n    } else if (substr(s, i, i) == 'F' || substr(s,\
    \ i, i) == 'f') {\n      tmp <- tmp + 1\n    } else if (substr(s, i, i) == 'G'\
    \ || substr(s, i, i) == 'g') {\n      tmp <- tmp + 1\n    } else if (substr(s,\
    \ i, i) == 'H' || substr(s, i, i) == 'h') {\n      tmp <- tmp + 1\n    } else\
    \ if (substr(s, i, i) == 'I' || substr(s, i, i) == 'i') {\n      tmp <- tmp +\
    \ 1\n    } else if (substr(s, i, i) == 'J' || substr(s, i, i) == 'j') {\n    \
    \  tmp <- tmp + 1\n    } else if (substr(s, i, i) == 'K' || substr(s, i, i) ==\
    \ 'k') {\n      tmp <- tmp + 1\n    } else if (substr(s, i, i) == 'L' || substr(s,\
    \ i, i) == 'l') {\n      tmp <- tmp + 1\n    } else if (substr(s, i, i) == 'M'\
    \ || substr(s, i, i) == 'm') {\n      tmp <- tmp + 1\n    } else if (substr(s,\
    \ i, i) == 'N' || substr(s, i, i) == 'n') {\n      tmp <- tmp + 1\n    } else\
    \ if (substr(s, i, i) == 'O' || substr(s, i, i) == 'o') {\n      tmp <- tmp +\
    \ 1\n    } else if (substr(s, i, i) == 'P' || substr(s, i, i) == 'p') {\n    \
    \  tmp <- tmp + 1\n    } else if (substr(s, i, i) == 'Q' || substr(s, i, i) ==\
    \ 'q') {\n      tmp <- tmp + 1\n    } else if (substr(s, i, i) == 'R' || substr(s,\
    \ i, i) == 'r') {\n      tmp <- tmp + 1\n    } else if (substr(s, i, i) == 'S'\
    \ || substr(s, i, i) == 's') {\n      tmp <- tmp + 1\n    } else if (substr(s,\
    \ i, i) == 'T' || substr(s, i, i) == 't') {\n      tmp <- tmp + 1\n    } else\
    \ if (substr(s, i, i) == 'U' || substr(s, i, i) == 'u') {\n      tmp <- tmp +\
    \ 1\n    } else if (substr(s, ", "\n  return(sum(grepl('^([aeiou]e)$', s, perl\
    \ = TRUE)) + sum(grepl('^([aeiou]e)$', s, perl = TRUE, fixed = TRUE))\n  }\ncount_upper('dBBE')",
  "\n  # Write your code here.\n  \n  return(sum(grepl(\"[aeiou]\",s)))\n}\n", "\n\
    \  nchar(toupper(s)) - nchar(sub(\"^\", \"\", s))\n}\n", "\n  return(sum((s%%2)==0,nchar(s,2)))\
    \ \n}\n", "\n  s <- gsub('^', '', s)\n  x <- gregexpr('([a-z])', s, perl = TRUE)\n\
    \  length(x[[1]][grepl('[aA]', x[[1]])])\n}\n", "\n  counts <- 0\n  ns <- strsplit(s,\
    \ '')[[1]]\n  for (i in 2:length(ns)) {\n    if (ns[i] == 'e' || ns[i] == 'i'\
    \ || ns[i] == 'o' || ns[i] == 'u') counts\n    else break\n  }\n  return(counts)\n\
    }\n", "\n  sum(grepl(\"^[AEIOUaeiou]+$\", s, perl = TRUE) & grepl(\"^[AEIOUaeiou]+$\"\
    , s, perl = TRUE) & s %% 2 != 0)\n}\n", "\n  x <- gregexpr('\\\\w+', s)\n  sum(regmatches(s,\
    \ x) %in% c(\"A\", \"E\", \"I\", \"O\", \"U\"))\n}\n", "\n  sum(substring(s,2)==\"\
    B\" | substring(s,2)==\"C\" | substring(s,2)==\"E\" | substring(s,2)==\"F\" |\
    \ substring(s,2)==\"G\")\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
