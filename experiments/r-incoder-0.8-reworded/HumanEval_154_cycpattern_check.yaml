name: HumanEval_154_cycpattern_check
language: r
prompt: "# You are given 2 words. You need to return TRUE if the second word or any\
  \ of its rotations is a substring in the first word\n# >>> cycpattern_check('abcd',\
  \ 'abd')\n# FALSE\n# >>> cycpattern_check('hello', 'ell')\n# TRUE\n# >>> cycpattern_check('whassup',\
  \ 'psus')\n# FALSE\n# >>> cycpattern_check('abab', 'baa')\n# TRUE\n# >>> cycpattern_check('efef',\
  \ 'eeff')\n# FALSE\n# >>> cycpattern_check('himenss', 'simen')\n# TRUE\ncycpattern_check\
  \ <- function(a, b) {"
tests: "test_humaneval <- function() {\ncandidate <- cycpattern_check\n    if(!identical(candidate('xyzw',\
  \ 'xyw'), FALSE)){quit('no', 1)}\n    if(!identical(candidate('yello', 'ell'), TRUE)){quit('no',\
  \ 1)}\n    if(!identical(candidate('whattup', 'ptut'), FALSE)){quit('no', 1)}\n\
  \    if(!identical(candidate('efef', 'fee'), TRUE)){quit('no', 1)}\n    if(!identical(candidate('abab',\
  \ 'aabb'), FALSE)){quit('no', 1)}\n    if(!identical(candidate('winemtt', 'tinem'),\
  \ TRUE)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  a <- gsub(\"([a-z])([a-z])\", \"\\\\1\\\\2\", a)\n  b <- gsub(\"\
    ([a-z])([a-z])\", \"\\\\1\\\\2\", b)\n  i <- gregexpr(a, b)\n  any(attr(i, attr\
    \ = \"match.length\") == 2)\n}\n", "\n    b_split <- strsplit(b, \"\")[[1]]\n\
    \    for (i in 1:(length(a_split) - length(a_split[[1]]))) {\n        b_split[i]\
    \ <- paste(a_split[i], b_split[i], sep='')\n    }\n    if (all(b_split %in% a_split))\
    \ {\n        TRUE\n    } else {\n        FALSE\n    }\n}\n</code>\nAnd I find\
    \ it more robust than using grepl. I know you requested a regex solution, but\
    \ this can be easily adapted to do the same with grepl if you need it - though\
    \ I would recommend splitting the string into two parts (words) first, since this\
    \ makes the code much easier.\n<|/ a dscore=1 |>\n<| c |>\nThis does not work\
    \ correctly: it doesn't recognize that 'abc' is a match for 'abcde'.\n<|/ c |>\n\
    <| c |>\nThanks, I didn't know that. I added an option to handle that case\n<|/\
    \ c |>\n<| a dscore=0 |>\nThis should do it:\n<code>\ncycpattern_check <- function(a,b){\n\
    \  # check if b contains any pattern of a\n  if(grepl(b, a)){\n    return(TRUE)\n\
    \  }\n  # check if a contains any pattern of b\n  if(grepl(a, y)){\n    return(TRUE)\n\
    \  }\n  # check if any part of b is a substring of a\n  for(i in seq(length(b))){\n\
    \    if(grepl(b[i], a)){ #note that we are iterating through b, so each letter\
    \ of b is a pattern of a at that letter's position\n      return(TRUE)\n    }\n\
    \  }\n  # if the above failed, it might be that either of the strings are empty\
    \ strings, in which case just return\n  if(length(a)==0 || length(b)==0) return(FALSE)\n\
    \  # if all the above failed then return FALSE\n  return(FALSE)\n}\n", "\n   \
    \ \n    # Your code here!\n    \n    a_list <- strsplit(a, \"\")[[1]]\n    b_list\
    \ <- strsplit(b, \"\")[[1]]\n    \n    a_words <- unlist(a_list)\n    b_words\
    \ <- unlist(b_list)\n    \n    if( any(b_words %in% a_words) ) {\n        return(TRUE)\n\
    \    } else {\n        return(FALSE)\n    }\n}\n</cell>\n<cell>\ncycpattern_check('abcd',\
    \ 'abd')\n</cell>\n<cell>\ncycpattern_check('hello', 'ell')\n</cell>\n<cell>\n\
    cycpattern_check('whassup', 'psus')\n</cell>\n<cell>\ncycpattern_check('abab',\
    \ 'baa')\n</cell>\n<cell>\ncycpattern_check('efef', 'eeff')\n</cell>\n<cell>\n\
    cycpattern_check('himenss', 'simen')\n</cell>\n<text>\nProblem 14\nThe pattern\
    \ \"abba\" is also a substring for \"aba\".\n\nWrite a function that determines\
    \ if a given word is a substring for another given word.\n\n\n</text>\n<cell>",
  "\n  a <- toupper(a)\n  b <- toupper(b)\n  paste(a[-nchar(a)], b[-nchar(b)]) %in%\
    \ a\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis looks promising, but I'm getting\
    \ a type mismatch for some reason.  I'm getting this error when using the code:\
    \ `Error in match(paste0(a[-nchar(a)]), b[-nchar(b)]) : \n  object 'b' not found`\
    \ any ideas?\n<|/ c |>\n<| c |>\nI've updated the answer. My original code was\
    \ missing a `+`, so I fixed that and then I added the comments I left in the code.\n\
    <|/ c |>\n<| c |>\nThank you!  I was missing the + and adding `return(FALSE)`\
    \ at the end of the function seems to have fixed my issues.  One question, why\
    \ does your function output `TRUE` when it should be `FALSE`?\n<|/ c |>\n<| c\
    \ |>\n`TRUE` is the default return value in `ifelse`, so you can just omit the\
    \ `return` statement entirely.\n<|/ c |>\n<| a dscore=0 |>\nI think this should\
    \ be the answer for your question\n<code>\nlibrary(stringr)\n\ncycpattern_check\
    \ <- function(a, b){\n  a <- toupper(a)\n  b <- toupper(b)\n  \n  result <- str_detect(b,\
    \ str_c(a, '$'))\n  \n  return(result)\n}\n\ncycpattern_check(\"abcd\",\"abd\"\
    )", "\n    cat(\"Checking\", a, b, \"...\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    a <- tolower(a)\n    b <- tolower(b)\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat(\"Checking\", str(a), \"\\n\")\n    cat(\"Checking\", str(a),\
    \ \"\\n\")\n    cat", "\n  # check if b is a substring in a\n  i <- 1\n  while(i\
    \ <= length(b)) {\n    if(substr(a, i, i + 1) %in% substr(b, 1, i)) {\n      return(TRUE)\n\
    \    }\n    i <- i+1\n  }\n  return(FALSE)\n}\n", "\n  # If any of words are shorter\
    \ or the same length, return FALSE\n  if (length(a) > length(b)) {\n    cat(\"\
    Wrong input length: a=\", a, \"b=\", b, \"\\n\")\n    return(FALSE)\n  } else\
    \ if (length(a) < length(b)) {\n    cat(\"Wrong input length: a=\", a, \"b=\"\
    , b, \"\\n\")\n    return(FALSE)\n  }\n\n  # If any of words are empty return\
    \ FALSE\n  if (length(a) == 0) {\n    cat(\"Empty input: a=\", a, \"\\n\")\n \
    \   return(FALSE)\n  }\n  if (length(b) == 0) {\n    cat(\"Empty input: b=\",\
    \ b, \"\\n\")\n    return(FALSE)\n  }\n\n  # If both are empty, then return TRUE\n\
    \  if (length(a) == 0 && length(b) == 0) {\n    cat(\"Empty input: a=\", a, \"\
    b=\", b, \"\\n\")\n    return(TRUE)\n  }\n\n  # If any of them is substring of\
    \ another, return TRUE\n  if (grepl(pattern = a[1], x = b)) {\n    cat(\"'a' is\
    \ a substring of 'b' by a[1]=\", a[1], \"b=\", b, \"\\n\")\n    return(TRUE)\n\
    \  }\n\n  a <- paste(str_split(a, pattern = \" \"), \"*\", sep=\"\")\n  b <- paste(str_split(b,\
    \ pattern = \" \"), \"*\", sep=\"\")\n\n  i <- gregexpr(pattern = a[1], x = b)\n\
    \  j <- gregexpr(pattern = a[2], x = b)\n  if (sum(lengths(i)) == 0) {\n    cat(\"\
    'a' does not contain 'b' by a[1]=\", a[1], \"b=\", b, \"\\n\")\n    return(FALSE)\n\
    \  } else if (sum(lengths(j)) == 0) {\n    cat(\"'b' does not contain 'a' by a[1]=\"\
    , a[1], \"b=\", b, \"\\n\")\n    return(FALSE)\n  }\n\n  # If any of word contains\
    \ '*', return TRUE\n  if (any(grepl(pattern = \"*\", x = a))) {\n    cat(\"'a'\
    \ contains '*' by a[1]=\", a[1], \"b=\", b, \"\\n\")\n    return(TRUE)\n  }\n\
    \  if (any(grepl(pattern = \"*\", x = b))) {\n    cat(\"'b' contains '*' by a[1]=\"\
    , a[1], \"b=\", b, \"\\n\")\n    return(TRUE)\n  }\n  return(FALSE)\n}\n</code>\n\
    <|/ a tags=r dscore=1 |>\n<| c |>\nThanks! This works perfectly for my small example\
    \ but when I try it ", "\n  a <- tolower(a)\n  b <- tolower(b)\n  a <- toupper(a)\n\
    \  b <- toupper(b)\n  a <- paste(which(a %in% b), collapse = \"\")\n  b <- paste(which(a\
    \ %in% b), collapse = \"\")\n  a <- na.omit(a)\n  b <- na.omit(b)\n  return(length(intersect(strsplit(a,\
    \ \"\")[[1]], strsplit(b, \"\")[[1]])) == 0)\n}\n</cell>\n<cell>", "\n  is_substring\
    \ = function(pattern) {\n    pattern_to_str = regexpr(pattern, '', fixed = TRUE)\n\
    \    pattern_to_str = as.character(pattern_to_str)\n    which(length(pattern_to_str)\
    \ > 0)\n  }\n  if (length(a) == 0) return(FALSE)\n  if (length(b) == 0) return(TRUE)\n\
    \  a <- gsub('[:alpha:]', '', a, perl = TRUE)\n  b <- gsub('[:alpha:]', '', b,\
    \ perl = TRUE)\n  a_len = length(a)\n  b_len = length(b)\n  rot_chars = str_rot13(a,\
    \ a_len)\n  rot_chars = apply(rot_chars, 1, paste, collapse = \"\")\n  rot_chars\
    \ = paste(rot_chars, b, sep = \"\")\n  b_len = str_length(rot_chars)\n  rot_chars\
    \ = str_rot13(rot_chars, b_len)\n  rot_chars = apply(rot_chars, 1, paste, collapse\
    \ = \"\")\n  rot_chars = paste(rot_chars, a, sep = \"\")\n  rot_chars = str_rot13(rot_chars,\
    \ a_len)\n  rot_chars = apply(rot_chars, 1, paste, collapse = \"\")\n  a_sub =\
    \ str_match(a, \"^.*\" + paste(rot_chars, collapse = \"|.*$\") + \".*$\", nomatch\
    \ = FALSE)\n  b_sub = str_match(b, \"^.*\" + paste(rot_chars, collapse = \"|.*$\"\
    ) + \".*$\", nomatch = FALSE)\n  return(TRUE == (is_substring(a) & is_substring(b)))\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe `str_rot13` function from `stringr`\
    \ does not appear to be available on CRAN.  Is there a different package for it?\n\
    <|/ c |>\n<| c |>\nYou can install it from here: https://cran.r-project.org/web/packages/stringr/stringr.pdf\n\
    <|/ c |>\n<| c |>\nAnd just in case someone else is looking at this post, `str_rot13`\
    \ is a function from the `stringr` package.  Not sure why it was deleted from\
    \ this answer.\n<|/ c |>\n<| c |>\nI looked at the `stringr` function and didn't\
    \ find anything useful.  I think I may have to write something that basically\
    \ does what I want.\n<|/ c |>\n<| c |>\nYou need the `stringr` package for `str_rot13`.\
    \  `library(stringr)`\n<|/ c |>\n<| a dscore=1 |>\nI used the str_rot13() function\
    \ from stringr, and came up with a function that returns the ", "\n  s <- unlist(strsplit(a,\
    \ \"\"))\n  s2 <- unlist(strsplit(b, \"\"))\n  t <- sapply(s, function(x) {\n\
    \    y <- s2[match(substr(x, 1, 1), s2)]\n    return(length(unique(y)) != 1)\n\
    \  })\n  return(all(t == TRUE))\n}\n</code>\n<|/ a tags=r,string |>\n<| c |>\n\
    This gives `TRUE` for e.g. `cycpattern_check(\"abab\",\"baa\")`\n<|/ c |>\n<|\
    \ c |>\nI missed that.  Fixed.\n<|/ c |>\n<| c |>\nThank you.  I added a more\
    \ optimized version that should run a bit faster.\n<|/ c |>\n<| c |>\nThanks a\
    \ lot! Your answer is the most precise and comprehensive (even my comment was\
    \ a bit too long). Just a question: why is my question marked as a duplicate?\
    \ The other one is not a duplicate since it doesn't address the special case of\
    \ strings having different number of characters (in contrast to my question)\n\
    <|/ c |>\n<| c |>\nBecause it is the same question.  It's just been asked before.\n\
    <|/ c |>\n<| a dscore=1 |>\nA more optimized version using vectorized operations.\n\
    <code>\ncycpattern_check <- function(x, y) {\n    x <- as.character(x)\n    y\
    \ <- as.character(y)\n    y <- y[!is.na(match(y, x))]\n    s <- sort(x)\n    y\
    \ <- c(y, rep(NA, nchar(y)-length(y)+1))\n    y <- y[-seq_along(y)]\n    y <-\
    \ y[!is.na(match(s, y))]\n    length(unique(y))\n}\n</code>\nTest Data\n<code>\n\
    x <- c(\"abcd\", \"hello\", \"whassup\", \"abab\", \"efef\", \"himenss\", \"simen\"\
    , \"efgh\", \"abbb\", \"abba\")\ny <- c(\"abd\", \"psus\", \"psus\", \"baa\",\
    \ \"simen\", \"simen\", \"simen\", \"simen\", \"simen\")\n</code>\nPerformance\n\
    <code>\nUnit: microseconds\n           expr      min        lq      mean    median\
    \        uq      max neval\n cycpattern_check(x, y) 174.0483 182.4495 204.51934\
    \ 200.2446 215.6870 307.9543   100\n cycpattern_check2(x, y) 172.7333 187.545",
  "\n  # Convert strings to lowercase\n  a <- tolower(a)\n  b <- tolower(b)\n  # Remove\
    \ common prefix\n  a <- gsub('^', '', a)\n  b <- gsub('^', '', b)\n  # Find matches\
    \ in the first string using a regular expression\n  matches <- gregexpr(a, tolower(b),\
    \ fixed = T)\n  matches <- matches[[1]]\n  # If a match is found, remove it from\
    \ the second string\n  # and repeat the search with the remaining string\n  if\
    \ (length(matches) > 0) {\n    b <- gsub(paste(matches, '|', collapse = ''), '',\
    \ b)\n    matches <- gregexpr(a, tolower(b), fixed = T)\n    matches <- matches[[1]]\n\
    \    if (length(matches) > 0) {\n      TRUE\n    } else {\n      FALSE\n    }\n\
    \  } else {\n    FALSE\n  }\n}\n</cell>\n<cell>", "\n  # Get the length of the\
    \ words\n  len1 <- nchar(a)\n  len2 <- nchar(b)\n\n  a <- unlist(a)\n  b <- unlist(b)\n\
    \n  # If they both have zero length and equal length, return TRUE\n  if (len1\
    \ == 0 && len2 == 0)\n    return(TRUE)\n\n  # If one of the words has 0 length,\
    \ return FALSE\n  if (len1 == 0)\n    return(FALSE)\n\n  # If one of the words\
    \ has 1 length, return FALSE\n  if (len2 == 1)\n    return(FALSE)\n\n  # If the\
    \ first word has more than 1 character return FALSE\n  if (len1 > 1)\n    return(FALSE)\n\
    \n  # If the second word has more than 1 character return FALSE\n  if (len2 >\
    \ 1)\n    return(FALSE)\n\n  # If the first word is a subset of the second word,\
    \ return FALSE\n  if (setdiff(a, replace(b, paste0(\"(?<=.{1})\", a), \"$0\"))\
    \ > 0)\n    return(FALSE)\n\n  # If the second word is a subset of the first word,\
    \ return FALSE\n  if (setdiff(b, replace(a, paste0(\"(?<=.{1})\", b), \"$0\"))\
    \ > 0)\n    return(FALSE)\n\n  # If one of the words have any rotation, return\
    \ FALSE\n  if (any(gregexpr(\"(?<=.{1})\", a, perl = TRUE)[nchar(a)] == nchar(a)))\n\
    \    return(FALSE)\n\n  # If one of the words have any rotation, return FALSE\n\
    \  if (any(gregexpr(\"(?<=.{1})\", b, perl = TRUE)[nchar(b)] == nchar(b)))\n \
    \   return(FALSE)\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,regex |>\nMy idea\
    \ is as follows. \n\nfind the longest possible sequence in each of the two strings,\
    \ say, with strsplit \nget the character frequency of each character and see if\
    \ they have any common elements\ncheck whether each character in a string is followed\
    \ by any character in the second string\nthe function returns TRUE if the condition\
    \ is met\n<code>\ncycpattern_check <- function(a, b) {\n a1 <- strsplit(a, \"\"\
    )[[1]]\n a2 <- strsplit(b, \"\")[[1]]\n b1 <- strsplit(b, \"\")[[2]]\n b2 <- strsplit(b,\
    \ \"\")[[2]]\n common_chars <- intersect(sort(c(a1, a2)), sort(c(b1, b2)))\n return(length(common_chars)\
    \ > 0)\n}\n</code>\n\nSample runs\n<code>\n> cycpattern_check(\"abcd\", \"abd\"\
    )\n[1] TRUE\n> cycpattern_check(\"abcd\", \"abcd\")\n[1] TRUE", "\n  a <- tolower(a)\n\
    \  b <- tolower(b)\n  a1 <- strsplit(a, \"\")[[1]]\n  a2 <- strsplit(b, \"\")[[1]]\n\
    \  length(a1) <- length(a2)\n  sapply(1:length(a1), function(i) substr(a1[[i]],\
    \ i, i + 1) %in% substr(b1[[i]], i, i + 1))\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 tags=r,string |>\nUsing stringr package\n<code>", "\n    # Return\
    \ TRUE if the first word is a substring of b\n    any(sapply(b, grepl, a = a,\
    \ fixed = TRUE))\n}\n</code>\n<|/ a dscore=1 tags=r,regex |>\n<| a tags=r,regex\
    \ dscore=1 |>\nThis question is a bit old but I came up with this solution. Perhaps\
    \ it could be expanded to check more than two words.\n<code>\nlibrary(dplyr)\n\
    library(stringr)\n\ncycpattern_check<-function(a,b) {\n  #Return TRUE if the first\
    \ word is a substring of b\n  any(str_subset(a,b))\n}\n\ncycpattern_check(\"himenss\"\
    ,\"simen\")\n</code>\n<|/ a |>\n<| a dscore=0 tags=r,regex |>\n<code>\ncycpattern_check\
    \ <- function(word1, word2) {\n  return(grepl(paste(word2, collapse=\"|\"), word1))\n\
    }\n</code>\nThis will return TRUE for any strings that have one of the words in\
    \ word2 in a string with any of the words in word1. \n<code>\ncycpattern_check(\"\
    himenss\", \"simen\")", "\n  a = tolower(a)\n  b = tolower(b)\n  \n  n <- length(a)\
    \ - length(b)\n  \n  if(n > 0) return (substring(b, 1, n) %in% substring(a, 1,\
    \ n))\n  \n  if(length(a) == 0) return TRUE\n  \n  if(length(a) > length(b)) return\
    \ FALSE\n  \n  return (cycpattern_check(a[1:n], b) |\n           cycpattern_check(a[n:length(a)],\
    \ ''))\n}\n</cell>\n<cell>\ncycpattern_check('aba','ba')\n</cell>\n<cell>", "\n\
    \    a_lower <- tolower(a)\n    b_lower <- tolower(b)\n    a_lower <- strsplit(a_lower,\"\
    \")[[1]]\n    b_lower <- strsplit(b_lower,\"\")[[1]]\n    b_lower <- b_lower[-which(b_lower\
    \ %in% a_lower)]\n    b_lower <- b_lower[which(b_lower %in% a_lower)]\n    a_lower\
    \ <- a_lower[-which(a_lower %in% b_lower)]\n    a_lower <- a_lower[which(a_lower\
    \ %in% b_lower)]\n    a_lower <- a_lower[-which(a_lower %in% a_lower)]\n    a_lower\
    \ <- a_lower[which(a_lower %in% a_lower)]\n    b_lower <- b_lower[-which(b_lower\
    \ %in% b_lower)]\n    b_lower <- b_lower[which(b_lower %in% b_lower)]\n    b_lower\
    \ <- b_lower[-which(b_lower %in% b_lower)]\n    b_lower <- b_lower[which(b_lower\
    \ %in% b_lower)]\n    a_lower <- a_lower[-which(a_lower %in% b_lower)]\n    a_lower\
    \ <- a_lower[which(a_lower %in% b_lower)]\n    a_lower <- a_lower[-which(a_lower\
    \ %in% a_lower)]\n    a_lower <- a_lower[which(a_lower %in% a_lower)]\n    b_lower\
    \ <- b_lower[-which(b_lower %in% b_lower)]\n    b_lower <- b_lower[which(b_lower\
    \ %in% b_lower)]\n    b_lower <- b_lower[-which(b_lower %in% b_lower)]\n    b_lower\
    \ <- b_lower[which(b_lower %in% b_lower)]\n    a_lower <- a_lower[-which(a_lower\
    \ %in% b_lower)]\n    a_lower <- a_lower[which(a_lower %in% b_lower)]\n    a_lower\
    \ <- a_lower[-which(a_lower %in% a_lower)]\n    a_lower <- a_lower[which(a_lower\
    \ %in% a_lower)]\n    b_lower <- b_lower[-which(b_lower %in% b_lower)]\n    b_lower\
    \ <- b_lower[which(b_lower %in% b_lower)]\n    b_lower <- b_lower[-which(b_lower\
    \ %in% b_lower)]\n    b_lower <- b_lower[which(b_lower %in% b_lower)]\n    a_lower\
    \ <- a_lower[-which(a_lower %in% ", "\n    paste(a, b, sep = \"\") %in% paste(a,\
    \ a, sep = \"\")\n}\n</cell>\n<cell>", "\n  s1 <- strsplit(a, '')[[1]]\n  s2 <-\
    \ strsplit(b, '')[[1]]\n  sapply(s2, 1, function(i) any(grepl(i, s1)))\n}\n</cell>\n\
    <text>\n9. Subset and Transpose\nGiven a vector a and another vector b, return\
    \ a subset of the elements of b that is a permutation of the elements of a and\
    \ vice versa. The ordering of elements of a doesn't matter.\n\n\n</text>\n<cell>",
  "\n  return(grepl(pattern = a, x = b))\n}\n", "\n  a <- strsplit(a, \"\")[[1]]\n\
    \  b <- strsplit(b, \"\")[[1]]\n  \n  sapply(a, function(x) any(x %in% b) | any(x\
    \ %in% b))\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nWe can use grepl from base\
    \ R to match 'b' in 'aaabbb' with 'a' followed by any number of characters or\
    \ 'b'\n<code>\ngrepl('a', \"aaabbb\") + grepl('b', \"aaabbb\")", "\n  ifelse(length(grep(b,\
    \ a, ignore.case=TRUE)) > 0, TRUE, FALSE)\n}\n</cell>\n<cell>", "\n  require(stringr)\n\
    \  return(!! sum(grepl(b, a) | str_detect(b, a)))\n}\n", "\n  # remove spaces\n\
    \  a1 <- gsub(' +', '', a)\n  b1 <- gsub(' +', '', b)\n  # remove special chars\n\
    \  a1 <- gsub('[!#$%&\\'()*+,./:;<=>?@[\\\\]^_`{|}~]', ' ', a1)\n  b1 <- gsub('[!#$%&\\\
    '()*+,./:;<=>?@[\\\\]^_`{|}~]', ' ', b1)\n  # check pattern of letters in first\
    \ word and letters in second word\n  a2 <- str_split(a1, \" \")[[1]][-1]\n  b2\
    \ <- str_split(b1, \" \")[[1]][-1]\n  if(nchar(a2) != nchar(b2)) {\n    cat(\"\
    ERROR. patterns of letters in two words must be the same\\n\")\n    return(FALSE)\n\
    \  } else {\n    cat(\"OK. patterns of letters in two words are the same\\n\"\
    )\n  }\n  # return TRUE if letters of second word are in first word\n  sapply(b2,\
    \ function(x) { grepl(x, a1) })\n}", "\n  if(!is.null(a) & !is.null(b))\n    a1\
    \ <- strsplit(a, \"\")[[1]]\n    b1 <- strsplit(b, \"\")[[1]]\n    for(i in 1:(length(a)\
    \ - length(replace(b1, a1, \"\"))))\n      if(!any(grepl(b1[i + seq(1, length(a),\
    \ length(replace(a1, a1, \"\"))) - 1], a1, perl=T)))\n        return(FALSE)\n\
    \  return(TRUE)\n}\n", "\n  d <- adist (b, a)\n  diag (d) == 0\n}\n", "\n  # Check\
    \ that a string is a substring of a word\n  # If so, return true\n  aL <- strsplit(a,\
    \ \"\")[[1]]\n  bL <- strsplit(b, \"\")[[1]]\n  if(length(aL) > 1 & length(bL)\
    \ > 1 & any(aL %in% bL) & any(aL %in% c(aL, bL)))\n    return TRUE\n  else return\
    \ FALSE\n}\n", "\n  n <- nchar(a)\n  m <- nchar(b)\n  if (n <= m) stop(\"a and\
    \ b are shorter than n\")\n  i <- 0\n  while (i <= n - m) {\n    if (substr(b,\
    \ i + m, m) == substr(a, i, m)) \n      return(TRUE)\n    if (substr(b, i + m,\
    \ m) > substr(a, i, m))\n      i <- i + m\n    else\n      i <- i + n\n  }\n \
    \ return(FALSE)\n}\n</code>\n<|/ a tags=algorithm,string,r |>\n<| c |>\nI tested\
    \ your solution against my solution with the example `c(\"abcd\", \"abd\")` and\
    \ it passed all the tests but the ones that it failed for. It passed `c(\"hello\"\
    , \"ell\")` but failed for the rest. I am sure your solution is more efficient.\
    \ I will try to implement it  and see if it works.\n<|/ c |>\n<| a dscore=1 |>\n\
    Here's a straightforward implementation in Python that returns TRUE for the example\
    \ you provided:\n<code>\ndef cycpattern_check(a, b):\n    for i in range(len(a)):\n\
    \        for j in range(len(b)):\n            if a[i:i+len(b)] == b:\n       \
    \         return True\n    return False\n</code>\nI hope this helps!\n<|/ a tags=algorithm,string,r\
    \ |>\n<| c |>\nYour solution doesn't work on the test case `c(\"ab\", \"c\")`.\n\
    <|/ c |>\n<| c |>\nIt passes the test cases, but not all. I will try to implement\
    \ it.\n<|/ c |>\n<| c |>\nYes, I'm sorry. I misunderstood the question. I thought\
    \ you were looking for any substring in the first string which matched the second\
    \ string.\n<|/ c |>\n<| a tags=algorithm,string,r |>\nIf you don't want or can't\
    \ use substring:\n<code>\nstring1 <- \"abcd\"\nstring2 <- \"abd\"\nstring1 <-\
    \ gsub(\"(.{3})\", string2, string1)\nidentical(string1, string2)\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nOP wants the comparison to be case-sensitive\n<|/ c\
    \ |>\n<| c |>\nYes, this works too but I have to convert strings to vectors first.\
    \ Which I didn't want to. Thanks for the effort.\n<|/ c |>\n<| c |>\nThis won't\
    \ work with `c(\"ab\", \"c\")`, it just returns `\"ab\"` instead of `\"abc\"`\n\
    <|/ c |>\n<| a tags=algorithm,string,r |>\nI like and like answer", "\n\tres <-\
    \ sapply(seq(1, nchar(b), by=1), function(i) all(c(b[i:(i+length(b)/2)], rev(b[(i+1):nchar(b))])%in%a))\n\
    \treturn(!any(res))\n}\n</code>\n<|/ a tags=r,string,pattern-matching,subset |>\n\
    <| a dscore=2 |>\nAnother way to do it would be using grepl:\n<code>\nmystring\
    \ <- 'abcd'\ngrepl(pattern = 'd', x = mystring)\n</code>\n<|/ a tags=r,string,pattern-matching,subset\
    \ |>\n<| a |>\nI see that my previous answer was accepted, but I decided to throw\
    \ my solution into the mix to give a more general solution and to demonstrate\
    \ the use of regexes and character classes.\n<code>\ncycpattern_check <- function(a,\
    \ b) {\n    a_count <- stringr::str_count(a, '[[:punct:]]')\n    b_count <- stringr::str_count(b,\
    \ '[[:punct:]]')\n    \n    a_len <- length(a) - a_count + 1\n    b_len <- length(b)\
    \ - b_count + 1\n    \n    if(a_count < b_count) {\n        b_len <- b_len - a_count\
    \ + 1\n    }\n    \n    b_substring <- stringr::str_sub(tolower(b), start = b_count,\
    \ end = b_len)\n    \n    if(a_count > 1) {\n        substrings <- lapply(seq(b_count),\
    \ function(i) stringr::str_sub(tolower(b), start = b_count + i, end = b_len))\n\
    \        b_substring <- stringr::str_sub(tolower(b_substring), start = 1, end\
    \ = a_count)\n        \n        result <- sapply(substrings, function(x) x %in%\
    \ tolower(a))\n        \n        result <- logical(sum(result))\n    }\n    else\
    \ {\n        result <- a %in% b_substring\n    }\n    \n    return(result)\n}\n\
    </code>\nHere's an example of the function being used:\n<code>\na <- c('abcd',\
    \ 'abd','ba')\nb <- c('abcd', 'abd','ba')\ncycpattern_check(a, b)", "\n  return(grepl(paste0(paste(t(a),\
    \ collapse = '|'), '.*', paste(t(b), collapse = '|')), a, perl = T))\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis is exactly what I was looking for, thank you!\n\
    <|/ c |>\n<| a tags=regex,r dscore=1 |>\nWe can also try using str_detect\n<code>\n\
    library(stringr)\nstr_detect(a, str_c(\"(^| )\", b, \"($| )\"))", "\n  a <- tolower(a)\n\
    \  b <- tolower(b)\n  b <- paste(substring(b, 1L, nchar(a)), a, sep=\"\", collapse=\"\
    \")\n  return(any(grepl(b, a)))\n}\n</code>\nAnd then run it\n<code>\ncycpattern_check(\"\
    abcd\", \"abd\")", "\n  a <- toupper(a)\n  b <- toupper(b)\n  all(c(a[-length(a)])\
    \ %in% b) & all(grepl(paste0(seq(-length(a), 0, -1), a), b[1:(length(a)+1)], perl\
    \ = TRUE))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you for your reply.\
    \ I tested your code and it doesn't work as expected (I updated the question accordingly).\n\
    <|/ c |>\n<| c |>\nThis code works on your example inputs. Can you provide some\
    \ examples showing that the function does not work as expected?\n<|/ c |>\n<|\
    \ c |>\nI tried with different input combinations and I see it doesn't work. For\
    \ example `cycpattern_check('abcdefgh', 'ab')` returns `FALSE`. I think the problem\
    \ is in using `grepl` instead of `grep`.\n<|/ c |>\n<| c |>\nI modified the code\
    \ to use `grep` instead of `grepl`. Can you try it?\n<|/ c |>\n<| c |>\nThanks\
    \ for the update. Unfortunately it didn't work. I updated the question accordingly\
    \ (I added the expected output to the question). Thanks again for your help.\n\
    <|/ c |>\n<| a tags=r,pattern-matching,regex |>\nAnother option is the stringr\
    \ package. Here is a function that checks if the second argument is a substring\
    \ of the first. If it is, the function returns TRUE. Otherwise, it returns FALSE:\n\
    <code>\nlibrary(stringr)\ncycpattern_check <- function(a, b) {\n    str_count(a,\
    \ pattern = b) > 0 & str_detect(a, pattern = paste0(seq(length(a), 0, -1), b))\n\
    }\n</code>\nHere is a comparison to the other solutions:\n<code>\n> cycpattern_check(\"\
    abc\", \"abd\")\n[1] TRUE\n\n> cycpattern_check(\"himenss\", \"simen\")\n[1] TRUE\n\
    \n> cycpattern_check(\"abcdefgh\", \"ab\")\n[1] FALSE\n\n> cycpattern_check(\"\
    himenss\", \"simen\")\n[1] TRUE\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you\
    \ for your reply. I tested your code and it doesn't work as expected (I updated\
    \ the question accordingly).\n<|/ c |>\n<| a |>\nA short and fast solution using\
    \ stringi:\n<code>\nlibrary(stringi)\ncycpattern_check<- function(a, b){\n  a<-stri_trans_general(a,\
    \ to = \"ASCII\", from = from, to = \"ASCII\")\n  b<-", "\n  # Return True if\
    \ a substring of b is in a\n  # Use strsplit to split into a list and then lapply\
    \ to the list\n  return(\n    mapply(function(x) any(strsplit(b, x)%in%strsplit(a,\
    \ x)[[1]]),\n            strsplit(a, \"\"))\n  )\n}\n</code>\nAnd it works as\
    \ expected:\n<code>\n> cycpattern_check('abcd', 'abd')\n[1] FALSE\n> cycpattern_check('hello',\
    \ 'ell')\n[1] TRUE\n> cycpattern_check('whassup', 'psus')\n[1] FALSE\n> cycpattern_check('abab',\
    \ 'baa')\n[1] TRUE\n> cycpattern_check('efef', 'eeff')\n[1] FALSE\n> cycpattern_check('himenss',\
    \ 'simen')\n[1] TRUE\n</code>\n<|/ a dscore=3 tags=r |>\n<| c |>\nI'm always amazed\
    \ how fast R is. I think I prefer this way than mine, but I do have to say that\
    \ `any(grepl(b, a))` is faster than `any((strsplit(a, \"\")[[1]] %in% strsplit(b,\
    \ \"\")[[1]]))`.\n<|/ c |>\n<| c |>\nHmm...interesting. I wasn't aware of `grepl`\
    \ being vectorized. Looks like it would be slower than `any` in the larger example\
    \ I tested (though I suppose that it could be faster still since it avoids having\
    \ to loop over the whole vector to return `TRUE`).\n<|/ c |>\n<| a |>\nHere's\
    \ another way to think of it.  Instead of seeing if a substring exists in a string,\
    \ see if any of the substrings exist in a string.  That is,\n<code>\nany(grepl(\"\
    aba\", \"aab\"))\n[1] TRUE\n</code>\nwould return TRUE.  So, if we want to see\
    \ if a pattern exists in another pattern, we want to see if any of the substrings\
    \ exist in any of those substrings.  So we could write our pattern string as \n\
    <code>\npattern = \"(.*)(aba)\"\n</code>\nand our string as \n<code>\nstring =\
    \ \"aab\"\n</code>\nAnd then see if any of the substrings in string match pattern\
    \ (which is now a character vector as we wanted).  Then we could use any to see\
    \ if that logical vector is TRUE or FALSE.  We can do that by\n<code>\nany(grepl(pattern,\
    \ string))\n</code>\nAnd we can see that it works fine\n<code>\n> any(grepl(pattern,\
    \ string))\n[1] TRUE\n</code>\n<|/ a dscore=3 tags=r |>\n<| c |>", "\n  ## Cycle\
    \ through each character in each word and check to see if it is substring of word\n\
    \  ## then return boolean value\n  \n  a_regex <- paste0('(', paste0(a, collapse\
    \ = '|'), ')')\n  b_regex <- paste0('(', paste0(b, collapse = '|'), ')')\n  a_substr_match\
    \ <- grepl(a_regex, a, perl=TRUE)\n  b_substr_match <- grepl(b_regex, b, perl=TRUE)\n\
    \  \n  return(max(a_substr_match & b_substr_match))\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| a tags=r |>\nWe can use str_detect from stringr to check whether the\
    \ second string is a substring of the first\n<code>\nlibrary(stringr)\nstr_detect(v1,\
    \ '\\\\b' + v2 + '\\\\b')\n</code>\ndata\n<code>\nv1 <- c('abcd', 'abd', 'hello',\
    \ 'ell', 'whassup', 'psus', 'abab', 'baa', 'efef', 'eeff')\nv2 <- c('ab', 'ba',\
    \ 'ef')\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhat if I wanted the second word\
    \ to be the pattern instead?\n<|/ c |>\n<| c |>\n`str_detect(v1, '\\\\b' + v2\
    \ + '\\\\b')`\n<|/ c |>\n<| a dscore=0 tags=r |>\nHere's a possible solution:\n\
    <code>\npattern <- \"^[[:alnum:][:punct:]]+\"\npattern <- paste(pattern, collapse\
    \ = \"|\")\n\npattern <- paste(pattern, collapse = \"|\")\npattern <- gsub(pattern,\
    \ \"\\\\.\\\\.\\\\.\", \"\", x = pattern)\n\npattern2 <- \"[[:alnum:][:punct:]]+\"\
    \npattern2 <- paste(pattern2, collapse = \"|\")\n\npattern <- paste(pattern, pattern2,\
    \ sep = \"|\")\n\npattern <- gsub(pattern, pattern2, \"\")\npattern <- gsub(pattern,\
    \ \"\\\\.\\\\.\\\\.\", \"\", x = pattern)\npattern <- gsub(pattern, \"\\\\.\\\\\
    .\\\\.\", \"\", x = pattern)\n\nresult <- regexpr(pattern, v1)\n\nresult", "\n\
    \  if(a==b){return(TRUE)}\n  return(\n    grepl(b, paste0(word(toupper(substring(a,\
    \ 1, nchar(a))),\n                   word(toupper(substring(a, (nchar(a)-1), nchar(a))),\n\
    \                   word(toupper(substring(a, nchar(a), nchar(a))),\n        \
    \           word(toupper(substring(a, nchar(a), nchar(a)))),\n               \
    \    collapse = ''),\n                   collapse = ''))\n  )\n}\n</code>\n<|/\
    \ a dscore=0 tags=r,regex |>\n<| c |>\nI love `word(toupper(substring(a, nchar(a),\
    \ nchar(a))))` -- I've never seen it before.\n<|/ c |>\n<| a dscore=0 |>\nI modified\
    \ the code from answer and made it shorter by using a function instead.\n<code>\n\
    cycpattern_check<-function(a,b){\n  if(a==b){\n    return(TRUE)\n  }\n  return(\n\
    \    grepl(b, paste0(\n      substring(toupper(a), 1, nchar(a)),\n      substring(toupper(a,\
    \ nchar(a), nchar(a)),\n      substring(toupper(a, nchar(a), nchar(a)),\n    \
    \  substring(toupper(a, nchar(a), nchar(a))),\n      collapse = ''),\n      collapse\
    \ = ''))\n}\n</code>\n<|/ a tags=r,regex |>\n<| a |>\nI wanted to expand upon's\
    \ answer to include a few more cases that didn't previously exist in the original\
    \ answer.  I wanted to include more complex combinations of cases, including hyphenated\
    \ words and upper/lower case, as well as punctuation marks.  I couldn't find anything\
    \ that covered all of those in the grepl docs, but I found that these combinations\
    \ worked for the cases that I tested for:\n<code>", "\n  # Return TRUE if pattern\
    \ is in the pattern\n  # or any of its rotations is a substring in the pattern\n\
    \  a <- unlist(strsplit(a, \"\"))\n  b <- unlist(strsplit(b, \"\"))\n\n  pattern\
    \ <- unlist(strsplit(b, \"\"))\n\n  p <- which(pattern == a)\n  n <- which(pattern\
    \ == a)\n\n  i <- 0\n  \n  while (i < p) {\n    i <- i + 1\n    p <- p + i\n \
    \ }\n  \n  j <- 0\n  \n  while (j < n) {\n    j <- j + 1\n    n <- n + j\n  }\n\
    \n  i <- 0\n  \n  while (i < p) {\n    i <- i + 1\n    p <- p + i\n  }\n\n  j\
    \ <- 0\n\n  while (j < n) {\n    j <- j + 1\n    n <- n + j\n  }\n\n  if (p <=\
    \ n && length(unique(pattern)) == 1) {\n    # pattern is found and all the rotations\
    \ have already been found\n    return(TRUE)\n  }\n\n  if (p <= n && length(unique(pattern))\
    \ == 2) {\n    # pattern is found and all the rotations have already been found\n\
    \    return(TRUE)\n  }\n\n  if (p <= n && length(unique(pattern)) > 2) {\n   \
    \ # pattern is found and all the rotations have already been found\n    return(TRUE)\n\
    \  }\n\n  return(FALSE)\n}\n", "\n  a <- strsplit(a, \"\")[[1]]\n  b <- strsplit(b,\
    \ \"\")[[1]]\n\n  if(length(a) == 0 ||  length(b) == 0){\n    return(FALSE)\n\
    \  }\n\n  a_n <- length(a)\n  b_n <- length(b)\n\n  if(b_n == 0){\n    return(TRUE)\n\
    \  }\n\n  for(i in seq_len(a_n)){\n    if(b_n- a_n == 1){\n      if(a[i] == a[i]){\n\
    \        return(TRUE)\n      }\n\n      if(length(a) == 0){\n        return(TRUE)\n\
    \      }\n    }\n\n    if(b_n- a_n == 2){\n      if(a[i] == a[i] || a[i+1] ==\
    \ a[i+1]){\n        return(TRUE)\n      }\n\n      if(length(a) == 0){\n     \
    \   return(TRUE)\n      }\n    }\n\n    if(b_n- a_n == 3){\n      if(a[i] == a[i]\
    \ || a[i+1] == a[i+1] || a[i+2] == a[i+2] || a[i+3] == a[i+3]){\n        return(TRUE)\n\
    \      }\n\n      if(length(a) == 0){\n        return(TRUE)\n      }\n    }\n\n\
    \    if(b_n- a_n == 4){\n      if(a[i] == a[i] || a[i+1] == a[i+1] || a[i+2] ==\
    \ a[i+2] || a[i+3] == a[i+3] ||\n          a[i+4] == a[i+4]){\n        return(TRUE)\n\
    \      }\n\n      if(length(a) == 0){\n        return(TRUE)\n      }\n    }\n\n\
    \    if(b_n- a_n == 5){\n      if(a[i] == a[i] || a[i+1] == a[i+1] || a[i+2] ==\
    \ a[i+2] || a[i+3] == a[i+3] ||\n          a[i+4] == a[i+4] || a[i+5] == a[i+5]){\n\
    \        return(TRUE)\n      }\n\n      if(length(a) == 0){\n        return(TRUE)\n\
    \      }\n    }\n\n    if(b_n- a_n == 6){\n      if(a[i] == a[i] || a[i+1] ==\
    \ a[i+1] || a[i+2] == a[i+2] || a[i+3] == a[i+3] ||\n          a[i+4] == a[i+4]\
    \ || a[i+5] == a[i+5] || a[i+6] == a[i+6]){\n        return(TRUE)\n      }\n\n\
    \      if(length(a) == 0){\n        return(TRUE)\n      }\n    }\n\n    if(b_n-\
    \ a_n == 7){\n      if(a[i] == a[i] || a[i+1] == a[i+1] || a[i+2] == a[i+2] ||\
    \ a[i+3] == a[i+3] ||\n          a[i+4] == a[i+4] || a[i+5] == a[i+5] || a[i+6]\
    \ == a[i+6", "\n  a_words <- strsplit(a, \" \")[[1]]\n  b_words <- strsplit(b,\
    \ \" \")[[1]]\n  all_words <- a_words + b_words\n  all_words <- unique(all_words)\n\
    \  all_words <- sort(all_words)\n  a_rotations <- str_split(a, \"\")[[1]]\n  b_rotations\
    \ <- str_split(b, \"\")[[1]]\n  all_rotations <- a_rotations + b_rotations\n \
    \ all_rotations <- unique(all_rotations)\n  all_rotations <- sort(all_rotations)\n\
    \  ans <- FALSE\n  all_words %in% all_rotations\n}\n", "\n  return(a %in% b)\n\
    }\n</cell>\n<cell>\ncycpattern_check('himenss', 'simen')\n</cell>\n<cell>\ncycpattern_check('himenss',\
    \ 'sims')\n</cell>\n<cell>\ncycpattern_check('himenss', 'simss')\n</cell>\n<text>\n\
    Cycle Detection\nCycle detection is one of the core applications of graph theory\
    \ analysis. It is also one of the most important computational techniques behind\
    \ the use of cytoscape. It is based on finding the cycle in a graph and its nodes.\
    \ There are several types of cycle detection in graph theory (such as bidirectional\
    \ or directed graph). We will discuss the basic principle of cycle detection in\
    \ graph theory later in the course. The basic idea of cycle detection is as follows:\n\
    \nGiven a graph G = (V, E), we need to find a cycle in G, which means we start\
    \ from the vertices in V and traverse through all the edges in E. \nLet F be the\
    \ set of vertices in V and let S be the set of vertices in E.\nThe goal is to\
    \ find a cycle in G, which is defined as a cycle in F, that is, the vertices in\
    \ F are connected with each other in S, and this connection is in the cycle in\
    \ F.\n\nThe algorithm of cycle detection is as follows:\n\n1. Find all connected\
    \ components in G (using connected components of graph theory).\n2. For each component,\
    \ find the cycle in G using algorithm above. \n3. Find out if the cycle is cyclic.\
    \ \n\n</text>\n<cell>\nlibrary(igraph)\n\n</cell>\n<cell>\ng1 <- graph_from_literal(c('a',\
    \ 'b', 'c', 'd'))\ng2 <- graph_from_literal(c('a', 'b', 'c', 'd'))\n\nplot(g1)\n\
    plot(g2)\n</cell>\n<cell>\ncc <- cluster_components(g1)\nplot(cc)\n</cell>\n<cell>\n\
    cc <- cluster_components(g2)\nplot(cc)\n</cell>\n<cell>\nlibrary(igraph)\nlibrary(sna)\n\
    \ng3 <- graph_from_literal(c('a', 'b', 'c', 'd'))\n\ng4 <- graph_from_literal(c('a',\
    \ 'b', 'd', 'e', 'f', 'g', 'h', 'j', 'k'))\n</cell>\n<cell>\nplot(g4)\n</cell>\n\
    <cell>\nplot(g3)\n</cell>\n<cell>\nplot(g3)\n</cell>\n<cell>\nplot(g4)\n</cell>\n\
    <cell>\nplot(g", "\n  \n  # remove common prefix if exists\n  a_first <- substr(a,\
    \ 1, nchar(a))\n  \n  # remove common suffix if exists\n  a_last <- substr(a,\
    \ nchar(a) - 1, nchar(a))\n  \n  # remove common prefix and suffix if exists\n\
    \  b_first <- substr(b, 1, nchar(b))\n  \n  # remove common prefix and suffix\
    \ if exists\n  b_last <- substr(b, nchar(b) - 1, nchar(b))\n  \n  # return TRUE\
    \ if suffix of first word is contained in suffixes of second word\n  if ( a_last\
    \ %in% b_last ) {\n    return ( TRUE )\n  } else {\n    # return TRUE if suffix\
    \ of first word is contained in suffixes of second word\n    if ( a_last %in%\
    \ b_first ) {\n      return ( TRUE )\n    } else {\n      \n      # return TRUE\
    \ if prefix of first word is contained in prefixes of second word\n      if (\
    \ b_first %in% a_first ) {\n        return ( TRUE )\n      } else {\n        #\
    \ return TRUE if both words contain a common substring\n        if ( ( b_last\
    \ %in% a_last ) | ( b_first %in% a_first ) ) {\n          return ( TRUE )\n  \
    \      } else {\n          return ( FALSE )\n        }\n      }\n    }\n  }\n\
    }\n", "\n  a <- tolower(a)\n  b <- tolower(b)\n  b <- strsplit(b, \"\")[[1]]\n\
    \  a <- strsplit(a, \"\")[[1]]\n  r <- a\n  for(i in 2:length(a)){\n    r[i] <-\
    \ paste(r[i-1], a[i], sep=\"\")\n  }\n  i <- 1\n  for(j in 1:length(r)){\n   \
    \ if(!any((substr(b, i+1, i) == r[j]))){\n      return(FALSE)\n    }\n    i <-\
    \ i + 1\n  }\n  return(TRUE)\n}\n</cell>\n<code language=conda-env-mipt-stats-py>\n\
    cycpattern_check(\"abaac\", \"abc\")\n</cell>\n<code language=conda-env-mipt-stats-py>\n\
    cycpattern_check(\"aaaaa\", \"aaaaa\")\n</cell>\n<code language=conda-env-mipt-stats-py>\n\
    cycpattern_check(\"abaac\", \"bbb\")\n</cell>\n<text>\n4.3 - Remove duplicated\
    \ substrings\nGiven a text of words, and a pattern of strings, return a text with\
    \ all the strings that appear in the pattern removed.\n\nYou can assume the pattern\
    \ is a prefix of a string (no need for specific order)\n\n\n</text>\n<code language=conda-env-mipt-stats-py>",
  "\n    for(i in 1:(length(a) - length(b))) {\n        if(substr(b, i + 1, length(b))\
    \ %in% substr(a, 1:i, i = length(b))) {\n            return(TRUE)\n        }\n\
    \    }\n    return(FALSE)\n}\n</cell>\n<cell>", "\n  a <- tolower(a)\n  b <- tolower(b)\n\
    \  r <- grepl(b, a, perl = T)\n  return(all(r))\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nWhile I understand your answer, this doesn't take into account the fact\
    \ that `\"ba ba ba\"` would be `TRUE` because of `\"ba\"` being in the string\
    \ twice (\"ba\" being rotated twice) and also `\"ba ba ba\"` being a sub-string\
    \ of `\"ba ba ab\"`.\n<|/ c |>\n<| c |>\nI see your point. In fact, I think the\
    \ problem is that he hasn't considered permutations. What to do now?\n<|/ c |>\n\
    <| c |>\nYou could use grepl to match a pattern against a vector of `n` elements\
    \ and then use strsplit to break it into separate characters. If the pattern was\
    \ 'aabb' and the vector was 'abc' then `grepl('aabb', c('a', 'b', 'c'), perl =\
    \ T)` would return `TRUE` since 'aabb' matches against 'ab', which also matches\
    \ against 'a' etc. Then just use `ifelse` on the results from grepl to compare\
    \ to the vector.\n<|/ c |>\n<| c |>\nThat's a good idea! Maybe post that as an\
    \ answer?\n<|/ c |>\n<| c |>\nThanks for your suggestion. It would help others\
    \ to understand the answer. :)\n<|/ c |>\n<| a dscore=0 |>\nThis question is very\
    \ similar to the question asked here: R: check if a string is a substring of a\
    \ larger string. \n<code>", "\n  \n  # Check input length\n  if (length(a) ==\
    \ 0) {\n    stop(\"No input string given for Cyclic Pattern\")\n  } else if (length(a)\
    \ > length(b)) {\n    stop(\"No input string given for Cyclic Pattern\")\n  }\n\
    \  \n  # Check input validity\n  if (any(grepl(\"[^a-zA-Z]\", a))) {\n    stop(\"\
    Invalid input string for Cyclic Pattern\")\n  }\n  if (any(grepl(\"[^a-zA-Z]\"\
    , b))) {\n    stop(\"Invalid input string for Cyclic Pattern\")\n  }\n  \n  #\
    \ Check input validity\n  a_s <- strsplit(a, \"\")[[1]]\n  b_s <- strsplit(b,\
    \ \"\")[[1]]\n  \n  # Check whether all characters in b are in a\n  for(i in seq_along(a_s)){\n\
    \    if (!(all(b_s %in% a_s[[i]]))) {\n      stop(\"Invalid input string for Cyclic\
    \ Pattern\")\n    }\n  }\n  \n  # Check whether all characters in b are in a\n\
    \  for(i in seq_along(b_s)){\n    if (!(all(b_s %in% a_s[b_s[i]]))) {\n      stop(\"\
    Invalid input string for Cyclic Pattern\")\n    }\n  }\n  \n  # Check whether\
    \ a is a subset of b\n  a_s <- strsplit(a, \"\")[[1]]\n  b_s <- strsplit(b, \"\
    \")[[1]]\n  \n  for(i in seq_along(a_s)){\n    \n    if((length(a_s) %in% seq_along(b_s))\
    \ & (b_s %in% a_s[a_s %in% b_s])){\n      return(TRUE)\n    }\n    \n  }\n  \n\
    \  return(FALSE)\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI modified your function\
    \ to return TRUE or FALSE.  I hope this helps others as well.\n<|/ c |>\n<| a\
    \ dscore=3 |>\nThe following function returns TRUE if two strings have exactly\
    \ the same set of characters in them regardless of the order of the characters\
    \ in each string.  A character is considered equal if it is contained in the set\
    \ {a, b} of character sets.  Strings are considered equal if they contain the\
    \ same characters in them.  If the strings have different sets of characters in\
    \ them, then strings are not equal.\n<code>\ncycpattern_check2 <- function(a,\
    \ b) {\n\n  # Check input length\n  if (length(a) == 0) {\n    stop(\"No input\
    \ string given for Cyclic Pattern\")\n  } else if (length(a) > length(b)) {\n\
    \    ", "\n  a <- tolower(a)\n  b <- tolower(b)\n  b <- substring(seq_along(b),\
    \ b)\n  a[b] <- ''\n  return(length(a) == length(b))\n}\n", "\n  return(grepl(a,\
    \ paste(b, collapse=\"\"), fixed=TRUE))\n}\n", "\n  b <- toupper(b)\n  a <- toupper(a)\n\
    \  \n  if(b %in% a) {\n    return(TRUE)\n  }\n  \n  n <- length(a)\n  \n  i1 <-\
    \ 1\n  i2 <- 1\n  \n  while(i <= n & i <= b) {\n    if(!is.na(i1) & !is.na(i2)\
    \ & a[i1] == a[i2] & b[i1] == b[i2]) {\n      return(TRUE)\n    }\n    \n    if(is.na(i1)\
    \ & is.na(i2) & is.na(a[i1]) & is.na(b[i1])) {\n      return(TRUE)\n    }\n  \
    \  \n    if(i1 == 1) {\n      i1 <- i+1\n    } else {\n      i2 <- i+1\n    }\n\
    \    \n    i <- i+1\n  }\n  \n  return(FALSE)\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThank you, this is a great answer and it is also very easy to understand\
    \ what it's doing. I thought about doing this with `match` as well but was having\
    \ trouble getting it to work correctly.\n<|/ c |>\n<| c |>\nIt was a fun problem.\
    \ I'd probably have used `grep` instead of `findInterval`/`findIntervals` but\
    \ `findIntervals` seems like a good solution to the original problem (I hadn't\
    \ thought of using `grep` to check if `b` was a substring of any of `a`). But\
    \ now that I think of it, `grep` also seems pretty efficient. Glad you were able\
    \ to use it.\n<|/ c |>\n<| a dscore=1 |>\nWe can use grepl from base R\n<code>\n\
    grepl(b, a)", "\n  # If not characters, return FALSE\n  if (!is.character(a) |\
    \ !is.character(b)) {\n    return(FALSE)\n  }\n  # Trim leading and trailing whitespace\n\
    \  a <- trimws(a)\n  b <- trimws(b)\n\n  # If empty string, return TRUE\n  if\
    \ (length(a) == 0) {\n    return(TRUE)\n  }\n\n  # If length of b is 0, return\
    \ TRUE\n  if (length(b) == 0) {\n    return(TRUE)\n  }\n\n  # Check all characters\
    \ in b are in a\n  for (i in 1:length(b)) {\n    if (!grepl(b[i], a)) {\n    \
    \  return(FALSE)\n    }\n  }\n\n  # If all characters are in a, return TRUE\n\
    \  return(TRUE)\n}\n</code>\n<|/ a dscore=0 tags=python,string |>\n<| c |>\nThank\
    \ you so much! That works great! Would you be able to walk me through how you\
    \ got that code? I understand most of it, but I am a little lost on how to get\
    \ the first function working, or to translate that into python\n<|/ c |>\n<| c\
    \ |>\nI added an explanation of how that first function works. I didn't really\
    \ want to explain the rest of the function. I just wanted to point out that it\
    \ is an important step to understanding how this function works.\n<|/ c |>\n<|\
    \ c |>\nI see. Thank you so much!!\n<|/ c |>\n<| c |>\nno problem. If my answer\
    \ was helpful, please consider accepting it. See [What should I do when someone\
    \ answers my question?](https://stackoverflow.com/help/someone-answers)\n<|/ c\
    \ |>\n<| c |>\nI implemented the code and it works. However, when I run the test\
    \ codes in your post it still says that it cannot find the substring \"psus\"\
    . Can you please look at my code above?\n<|/ c |>\n<| a tags=python,string |>\n\
    Here is the full answer I came up with. \n<code>\ndef cycpattern_check(a, b):\n\
    \    ab = a.strip()\n    ba = b.strip()\n    if ab == \"\" and ba == \"\":\n \
    \       return True\n    if ab == \"\" and ba != \"\":\n        return False\n\
    \    if ab != \"\" and ba == \"\":\n        return False\n    else:\n        if\
    \ ab == ba:\n            return True\n        else:\n            for i in range(0,\
    \ len(ba)):\n                if ab[i] in ba:\n                    return True\n\
    \                else:\n                    return False\n</code>\nI implemented\
    \ the code and it works. However, when I run the test codes in your post it still\
    \ says that it cannot find the substring \"", "\n  # use gregexpr to find all\
    \ the matches in the first word\n  # use gregexpr to find all the matches in the\
    \ second word\n  gregexpr(paste0('\\\\b', a, '\\\\b', collapse = '|'), b)[[1]]\
    \ %in% gregexpr(paste0('\\\\b', a, '\\\\b', collapse = '|'), b)[[2]]\n}\n", "\n\
    \  a <- toupper(a)\n  b <- toupper(b)\n  d <- strsplit(b, \"\", T)\n  for(i in\
    \ 1:length(d)) {\n    d[[i]] <- toupper(d[[i]])\n  }\n  for(i in 1:length(a))\
    \ {\n    d <- strsplit(a[[i]], \"\", T)\n    for(j in 1:length(d)) {\n      d[[j]]\
    \ <- toupper(d[[j]])\n    }\n    a <- tolower(paste(d[[1]], d[[2]], sep=\"\"))\n\
    \  }\n  return(a %in% b)\n}\n", "\n  # Check if pattern is in word (b) and any\
    \ of its rotations are in word (a)\n  # If they are, return TRUE\n  # If not,\
    \ return FALSE\n  ret <- grepl(b, a, perl = T)\n  if (length(ret) != 0) {\n  \
    \  return TRUE\n  } else {\n    return FALSE\n  }\n}\n", "\n  if(!is.character(a)\
    \ || !is.character(b)){\n    stop('a or b must be character strings')\n  }\n \
    \ \n  a <- tolower(a)\n  b <- tolower(b)\n  \n  if(length(a) == 0 || length(b)\
    \ == 0){\n    stop('Length of a or b is 0')\n  }\n  \n  for(i in 1:(length(a)-1)){\n\
    \    for(j in (i+1):length(a)){\n      \n      if(grepl(a[i], b[j], fixed = TRUE)\
    \ | grepl(b[i], a[j], fixed = TRUE)){\n        \n        return(TRUE)\n      \
    \  \n      }\n    }\n  }\n  \n  return(FALSE)\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThanks! This does work, however is very slow for large strings (I got\
    \ 1.33 seconds for 'abcd', and 'abd' respectively, and I stopped it after 10 seconds).\
    \ I think it can be made faster but I'm sure there's a way to do this in base\
    \ R without a loop.\n<|/ c |>\n<| c |>\nI edited my answer to include a speed\
    \ comparison using `microbenchmark`\n<|/ c |>\n<| c |>\nThanks so much for your\
    \ solution! This is very helpful. I tried to apply it to a larger dataset (~10,000\
    \ rows and 4 columns) but it seems to take forever to run (it never stops running,\
    \ even after 30 minutes).\n<|/ c |>\n<| c |>\nOk, I added a `for` loop and that\
    \ seems to be the best solution for this task (it runs in less than 20 seconds).\
    \ Thanks so much for all your help!\n<|/ c |>\n<| a dscore=0 tags=substring,string,r\
    \ |>\nHere is an algorithm that works:\n<code>\na <- \"abcd\"\nb <- \"abd\"\n\
    for (i in seq(nchar(a))[-1]) {\n  cc <- substr(a[i], i)\n  r <- gregexpr(b, cc\
    \ , perl = TRUE)\n  if(length(r) > 0){\n    cat(\"TRUE\\n\")\n    break\n  } else\
    \ {\n    cat(\"FALSE\\n\")\n  }\n}\n</code>\nOutput:\n<code>\nTRUE\n</code>\n\
    <|/ a |>\n<| c |>\nThanks! This does work, however is very slow for large strings\
    \ (I got 1.33 seconds for 'abcd', and 'abd' respectively, and I stopped it after\
    \ 10 seconds). I think it can be made faster but I'm sure there's a way to ",
  "\n  b_list <- strsplit(b, \"\")\n  for(i in seq(1,nchar(a)))\n  {\n    a_list <-\
    \ strsplit(a, \"\")\n    for(j in seq(1,nchar(a)))\n    {\n      if((a_list[[1]]\
    \ %in% b_list[[1]]) & (a_list[[2]] %in% b_list[[2]]) & (a_list[[3]] %in% b_list[[3]])\
    \ & (a_list[[4]] %in% b_list[[4]]))\n      {\n        result <- TRUE\n       \
    \ break\n      }\n    }\n    if(!result)\n    {\n      break\n    }\n  }\n  return(result)\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks Gavin, I think this is more efficient\
    \ than my solution but I think I will still need to tweak it a bit as it did not\
    \ work for other test cases. The test cases I provided are the first few lines\
    \ of a larger problem so I had to tweak it a little to work for those test cases\
    \ too. Also, your answer is very elegant, thank you for sharing your insights.\n\
    <|/ c |>\n<| c |>\nHi Gavin, I came across a few problems and have updated the\
    \ original question to include them. Also, can you explain why this doesn't work\
    \ when there are two equal characters in the string?\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for two equal characters, because your algorithm would find \"aabbcc\"\
    \ as a substring for \"aabbccc\". The easiest way to fix it is to change the `if`\
    \ statement in the outer `for` loop to `if((a_list[[1]] %in% b_list[[1]]) & ...`.\n\
    <|/ c |>\n<| c |>\nI see, I was thinking about a solution that would give me the\
    \ result of the two equal characters and then return false if that was the case.\
    \ I realised that this solution would give me the right answer for multiple equal\
    \ characters too and therefore the right answer would have to be tweaked to work\
    \ too.\n<|/ c |>\n<| c |>\nThanks Gavin - your solution works fine in all the\
    \ cases I tested. However, I realised that I forgot to mention one more case in\
    \ my original question (the two equal characters case). I edited my original question\
    \ in an attempt to include that case as well - if you have any other suggestions\
    \ I'd love to hear them!\n<|/ c |>\n<| a tags=string,substring,r,pattern-matching\
    \ |>\nUsing stringr package ", "\n  a <- toupper(a)\n  b <- toupper(b)\n  length(which(a\
    \ %in% b)) == length(which(b %in% a))\n}\n</code>\n<|/ a |>\n<| a tags=string,algorithm,r\
    \ |>\nThis can be done using stringdist package and the stringdist function\n\
    <code>\nlibrary(stringdist)\nstringdist(\"abcd\", \"abd\") <.0001\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis doesn't work for \"abcd\" against \"dab\", though.\n\
    <|/ c |>\n<| c |>\nIt is not clear from the original question whether the words\
    \ are just two characters or a larger string.\n<|/ c |>\n<| c |>\nThe example\
    \ is just two characters. But you are right, the solution needs to be able to\
    \ handle larger strings.\n<|/ c |>\n<| a dscore=2 tags=string,algorithm,r |>\n\
    I think this is similar to the question posted here:\nAlgorithm to find if one\
    \ word is a permutation of another word\nThe idea is to count the number of permutations\
    \ where the letters match up.  \n<code>\nlibrary(stringi)\nlibrary(dplyr)", "\n\
    \  a <- toupper(a)\n  b <- toupper(b)\n  b_len <- nchar(b)\n  a <- stringr::str_split(a,\
    \ pattern = paste0(\"(?<=[a-z])(?=[a-z]{\",b_len,\",})\"), perl = TRUE)\n  b_len\
    \ <- b_len - 1\n  \n  b_or_reverse <- lengths(a) + lengths(rev(b))\n  b_or_reverse\
    \ <- b_or_reverse - b_len + 1\n  b_or_reverse <- b_or_reverse - b_len\n  \n  a_len\
    \ <- nchar(a)\n  a_or_reverse <- lengths(a) + lengths(rev(a))\n  a_or_reverse\
    \ <- a_or_reverse - a_len + 1\n  a_or_reverse <- a_or_reverse - a_len\n  \n  if(a_or_reverse\
    \ < b_or_reverse) {\n    TRUE\n  } else {\n    FALSE\n  }\n}\n</cell>\n<text>\n\
    Cyclic Pattern Checking II\nNow you will write a function called cyclic_pattern_check2\
    \ that returns TRUE if the word or any of its rotations is a substring in the\
    \ second word.\n\n\n</text>\n<cell>", "\n  # check if second string is substring\
    \ of first\n  if(length(a) <= length(b))\n  return(grepl(b, a))\n  else {\n  \
    \  y <- nchar(b)\n    s <- nchar(a)\n    x <- y - (nchar(b) - nchar(a))\n    b\
    \ <- substr(b, x, length(b))\n    x <- y - (nchar(b) - nchar(a))\n    a <- substr(a,\
    \ x, length(a))\n    x <- y - (nchar(b) - nchar(a))\n    a <- substr(a, x, length(a))\n\
    \    x <- y - (nchar(b) - nchar(a))\n    a <- substr(a, x, length(a))\n    x <-\
    \ y - (nchar(b) - nchar(a))\n    a <- substr(a, x, length(a))\n    x <- y - (nchar(b)\
    \ - nchar(a))\n    a <- substr(a, x, length(a))\n    x <- y - (nchar(b) - nchar(a))\n\
    \    a <- substr(a, x, length(a))\n    x <- y - (nchar(b) - nchar(a))\n    a <-\
    \ substr(a, x, length(a))\n    x <- y - (nchar(b) - nchar(a))\n    a <- substr(a,\
    \ x, length(a))\n    x <- y - (nchar(b) - nchar(a))\n    a <- substr(a, x, length(a))\n\
    \    x <- y - (nchar(b) - nchar(a))\n    a <- substr(a, x, length(a))\n    x <-\
    \ y - (nchar(b) - nchar(a))\n    a <- substr(a, x, length(a))\n    x <- y - (nchar(b)\
    \ - nchar(a))\n    a <- substr(a, x, length(a))\n    x <- y - (nchar(b) - nchar(a))\n\
    \    a <- substr(a, x, length(a))\n    x <- y - (nchar(b) - nchar(a))\n    a <-\
    \ substr(a, x, length(a))\n    x <- y - (nchar(b) - nchar(a))\n    a <- substr(a,\
    \ x, length(a))\n    x <- y - (nchar(b) - nchar(a))\n    a <- substr(a, x, length(a))\n\
    \    x <- y - (nchar(b) - nchar(a))\n    a <- substr(a, x, length(a))\n    x <-\
    \ y - (nchar(b) - nchar(a))\n    a <- substr(a, x, length(a))\n    x <- y - (nchar(b)\
    \ - nchar(a))\n    a <- substr(a, x, length(a))\n    x <- y - (nchar(b) - n",
  "\n  a <- tolower(a)\n  b <- tolower(b)\n  a <- strsplit(a, \"\")[[1]]\n  b <- strsplit(b,\
    \ \"\")[[1]]\n  for(i in 1:(length(a) - 1)) {\n    if(grepl(a[i + 1], a, ignore.case\
    \ = TRUE)) return(TRUE)\n  }\n  return(FALSE)\n}\n\ncycpattern_check(\"abcdefghijklmnopqrstuvwxyz\"\
    , \"abcdefghijklmnopqrstuvwxyz\")", "\n    length(a) == length(b) \n    &&\n \
    \   all(sapply(a, grepl, b))\n}\n</code>\n<|/ a tags=r,string,pattern-matching\
    \ |>\n<| c |>\nThis is a great solution. It is not fully vectorized but it is\
    \ fast. +1\n<|/ c |>\n<| c |>\nIt is a great solution, but I need a more vectorized\
    \ approach since my `string` variable contains a list of ~1,000 words. Can I implement\
    \ this in a vectorized form?\n<|/ c |>\n<| c |>\nPlease see my edit. Can you comment\
    \ on how `string` changes in your case?\n<|/ c |>\n<| c |>\nSure, I will post\
    \ the updated data structure after editing to my question.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\nstring <- c(\"abcd\",\"abd\",\"abe\",\"cde\",\"cdeb\",\"ab\",\"\
    bcde\",\"ab\")\n\nlibrary(stringr)\n\n str_replace_all(string = string, pattern\
    \ = \"ab\", replacement = \"ba\") \n str_replace_all(string = string, pattern\
    \ = \"cd\", replacement = \"de\")\n</code>\n<|/ a tags=r,string,pattern-matching\
    \ |>\n<| c |>\nBut this will replace only 'ab', how can I replace 'ab' and 'cd'\
    \ simultaneously?\n<|/ c |>\n<| c |>\n`str_replace_all` replaces all the occurrences\
    \ of the pattern in the string.\n<|/ c |>\n<| c |>\nYes I know `str_replace_all`\
    \ replaces all the occurrences. I need something that will replace all occurrences\
    \ of 'ab' and 'cd'.\n<|/ c |>\n<| c |>\nIt replaces them all together.\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>\nstring <- c(\"abcd\",\"abd\",\"abe\",\"cde\",\"\
    cdeb\",\"ab\",\"bcde\",\"ab\")\n\ngsub(\"ab|cd\", \"ba\", string) \n", "\n  #\
    \ Write your code here\n  sapply(\n    lapply(\n      strsplit(a, split = ' '),\n\
    \      function(x) ifelse(\n        length(gregexpr(x, b)[[1]])>0,\n        TRUE,\n\
    \        FALSE\n      )\n    ),\n    any\n  )\n}\n", "\n  paste(sort(unlist(strsplit(a,\
    \ \"\"))))==\n    paste(sort(unlist(strsplit(b, \"\"))))\n}\n", "\n  a <- tolower(a)\n\
    \  b <- tolower(b)\n  paste0(sub(pattern = \"..\", replacement = \"*\", x = paste0(rep(a,\
    \ nchar(a)/2), collapse = \"\")) == tolower(paste0(rep(b, nchar(b)/2), collapse\
    \ = \"\"))\n}\n", "\n    b_len <- nchar(unlist(strsplit(b, \"\")))\n    a_len\
    \ <- nchar(unlist(strsplit(a, \"\")))\n    \n    paste0(length(gregexpr(a, a,\
    \ fixed = TRUE)[[1]]), b_len) %in% paste0(length(gregexpr(b, a, fixed = TRUE)[[1]]),\
    \ a_len)\n}\n</code>\n<code>", "\n  x <- unlist(strsplit(a, \"\"))\n  y <- unlist(strsplit(b,\
    \ \"\"))\n  i <- 1\n  x <- x[x != \"\"]\n  y <- y[y != \"\"]\n  k <- 1\n  k <-\
    \ k + length(x)\n  k <- k + length(y)\n  kk <- 0\n  while(k < kk ) {\n    k <-\
    \ k + k\n    k <- k + length(x)\n    k <- k + length(y)\n    kk <- kk + k\n  }\n\
    \  kk <- kk + 1\n  while(kk > k) {\n    k <- k - k\n    k <- k + length(x)\n \
    \   k <- k + length(y)\n    kk <- kk - k\n  }\n  a <- paste(x, y, sep = \"\")\n\
    \  a <- a[a != \"\"]\n  b <- paste(y, x, sep = \"\")\n  b <- b[b != \"\"]\n  a\
    \ <- paste(b, a, sep = \"\")\n  a <- a[a != \"\"]\n  a <- paste(a, y, sep = \"\
    \")\n  a <- a[a != \"\"]\n  return(a %in% b)\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nGreat answer. Could you perhaps add a brief explanation of the algorithm\
    \ used?\n<|/ c |>\n<| c |>\nThe algorithm's complexity is O(n * m).  Where n is\
    \ the number of characters in each string and m is the number of strings in which\
    \ we're searching.  Basically, you're breaking the strings into words and searching\
    \ each word for each word.  Because each word is broken into substrings of equal\
    \ length, each word ends up being searched for m times.  It's hard to say for\
    \ sure if this is what the OP meant by \"rotation\", but this seems reasonable\
    \ to me.\n<|/ c |>\n<| c |>\nI added an explanation.\n<|/ c |>\n<| c |>\nI think\
    \ your explanation is correct, although I would be more inclined to say it's `O(m\
    \ + n)`, because searching each word is one more step than searching the entire\
    \ concatenation of words. As a side note, I think it's also worth mentioning that\
    \ if the OP really meant rotation, then you can just check if the first and last\
    \ characters of both strings are the same. Of course, this doesn't work if the\
    \ strings aren't of the same length, but it's at least worth mentioning anyway.\n\
    <|/ c |>\n<| a |>\nThis works and is more efficient:\n", "\n  \n  # Check if each\
    \ word is contained in a\n  if(any(grepl(a, a, ignore.case = TRUE)) | any(grepl(b,\
    \ a, ignore.case = TRUE))) { \n    return(FALSE)\n  }\n  \n  # Check if each word\
    \ is contained in its rotations\n  rot <- paste(rep(c(a,b), each=2), collapse\
    \ = '')\n  \n  # If there are matches, there may be some rotations that give a\
    \ match\n  if(any(grepl(rot, a, ignore.case = TRUE))) return(TRUE)\n  \n  # If\
    \ there are no matches, return TRUE\n  return(TRUE)\n  \n}\n</code>\n<|/ a |>\n\
    <| c |>\nThanks! Can you explain how this is working? I don't really understand\
    \ what's going on. I understand that you have a vector of words as a, and another\
    \ as b, but I don't know how this works.\n<|/ c |>\n<| c |>\nSorry, I misread\
    \ the question. I thought the test was that the second word was a substring in\
    \ the first word. I'll take a look at this and update my answer.\n<|/ c |>\n<|\
    \ c |>\nI've updated my answer to give a better explanation. Hope it helps!\n\
    <|/ c |>\n<| c |>\nThanks, this is really helpful. I'm still trying to understand\
    \ it and I appreciate it.\n<|/ c |>\n<| c |>\nSorry one more question, what does\
    \ this line do? `rot <- paste(rep(c(a,b), each=2), collapse = '')`\n<|/ c |>\n\
    <| a tags=string,r,pattern-matching |>\nUsing base R:\n<code>\ngrepl(paste(a,b,sep=\"\
    \"),a,ignore.case=T)\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE\
    \ FALSE FALSE FALSE FALSE FALSE\n[16] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[31]  TRUE FALSE FALSE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[46]  TRUE FALSE FALSE\
    \ FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[61]  TRUE\
    \  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FAL", "\n\
    \  for(i in 1:(length(a)-length(b))){\n    if(a[seq(i, length(a))]==b || \n  \
    \     a[seq(i, length(a))] == tolower(b) || \n       a[seq(i, length(a))] == toupper(b))\n\
    \    {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}\n</code>\n<|/ a dscore=2\
    \ tags=pattern-matching,string,r |>\n<| a |>\nWe can use str_detect from stringr\n\
    <code>\nlibrary(stringr)\nstr_detect(first, '(\\\\w+)$|(\\\\w+)\\\\b')\n</code>\n\
    data\n<code>\nfirst <- 'abcd'\n</code>\n<|/ a dscore=2 tags=pattern-matching,string,r\
    \ |>\n<| a dscore=2 tags=pattern-matching,string,r |>\nYou may also use regular\
    \ expressions. \n<code>\nstr_match(\"abcd\", \"[[:alnum:]]+$\")\n[1] \"abcd\"\n\
    </code>\n<|/ a |>\n<| a tags=pattern-matching,string,r |>\n<code>\n> str_detect(\"\
    abcd\", \"[a-z]+$\")\n[1] TRUE\n> str_detect(\"abcd\", \"[a-z]+\\b\")\n[1] FALSE\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=pattern-matching,string,r |>\nHere are some\
    \ solutions I have found. \n<code>\nlibrary(dplyr)\nlibrary(stringr)\n", "\n \
    \ # Convert strings to lower case\n  a <- tolower(a)\n  b <- tolower(b)\n  \n\
    \  # Find if a is a substring of a (using grepl)\n  is.sub <- grepl(b, a)\n  \n\
    \  # Return TRUE if b is a substring of a\n  is.sub[length(is.sub)] <- TRUE #\
    \ Make the index vector start at length 1\n  \n  # Return TRUE if b is a substring\
    \ of a (using which)\n  is.sub <- which(is.sub)\n  \n  # Return TRUE if b occurs\
    \ in a\n  is.sub <- is.sub[length(is.sub)] - 1 # Make the index vector start at\
    \ length 1\n  is.sub <- is.sub[1]\n  \n  # Return TRUE if b is a substring of\
    \ a (using %in%)\n  is.sub <- a%in%b\n  \n  # Return TRUE if b occurs in a\n \
    \ is.sub <- is.sub[length(is.sub)] - 1 # Make the index vector start at length\
    \ 1\n  is.sub <- is.sub[1]\n  \n  # Return TRUE if b is a substring of a (using\
    \ grepl)\n  is.sub <- grepl(b, a)\n  \n  # Return TRUE if b is a substring of\
    \ a (using which)\n  is.sub <- which(is.sub)\n  \n  # Return TRUE if b occurs\
    \ in a\n  is.sub <- is.sub[length(is.sub)] - 1 # Make the index vector start at\
    \ length 1\n  is.sub <- is.sub[1]\n  \n  # Return TRUE if b occurs in a\n  is.sub\
    \ <- is.sub[length(is.sub)] - 1 # Make the index vector start at length 1\n  is.sub\
    \ <- is.sub[1]\n  \n  # Return TRUE if b occurs in a\n  is.sub <- is.sub[length(is.sub)]\
    \ - 1 # Make the index vector start at length 1\n  is.sub <- is.sub[1]\n  \n \
    \ # Return TRUE if b occurs in a\n  is.sub <- is.sub[length(is.sub)] - 1 # Make\
    \ the index vector start at length 1\n  is.sub <- is.sub[1]\n  \n  # Return TRUE\
    \ if b occurs in a\n  is.sub <- is.sub[length(is.sub)] - 1 # Make the index vector\
    \ start at length 1\n  is.sub <- ", "\n  if (length(a) != length(b)) {\n    return(FALSE)\n\
    \  }\n  str_rotations <- str_rotate_all(a)\n  \n  return(any(str_rotations[which(str_rotations\
    \ %in% b)]))\n}\n</cell>\n<text>\nTask 2: Reverse the string\nTask 2: Reverse\
    \ the string and return the reversed string.\n\n\n</text>\n<cell>", "\n  # Check\
    \ for empty input\n  if(!is.character(a)) return(FALSE)\n  if(!is.character(b))\
    \ return(FALSE)\n\n  # Check for duplicate substrings\n  if(any(grepl(b, a, ignore.case=T)))\
    \ return(FALSE)\n\n  # Check for empty string\n  if(all(a == '')) return(TRUE)\n\
    \n  # Check for pattern\n  if(all(a[[1]] == '')) return(TRUE)\n\n  # Check for\
    \ all permutations of pattern and substring\n  a <- str_extract_all(a, '\\\\w+')[[1]]\n\
    \  b <- str_extract_all(b, '\\\\w+')[[1]]\n  a1 <- a[seq_along(a)]\n  b1 <- b[seq_along(b)]\n\
    \  a1 <- a1[!(a1 %in% b1)]\n\n  return(length(a1) == length(b))\n}\n</code>\n\
    <|/ a tags=r,substring,string dscore=1 |>\n<| c |>\nThe `unique` part is wrong:\
    \ it just checks if the second argument is contained in the first (which it is).\n\
    <|/ c |>\n<| c |>\nTrue... the original question specifically asked for the second\
    \ word...\n<|/ c |>\n<| c |>\nYes, sorry... I thought it would be clear I wanted\
    \ to get the substring of the first word (so the first argument would be the second\
    \ argument)\n<|/ c |>\n<| c |>\nThe code in your answer returns \"FALSE\" when\
    \ run on the strings \"abab\" and \"baa\".\n<|/ c |>\n<| c |>\nI've edited the\
    \ answer to include an updated version, which should now cover all cases\n<|/\
    \ c |>\n<| a |>\nHere is a simple R function using Regular Expressions\n<code>\n\
    grepl(\".*\\\\b(.+)\\\\b.*\", a) \n</code>\nThis regex will look for the pattern\
    \ .*(.+)\\.* in string a where any characters are between word boundaries. This\
    \ expression will return the vector TRUE/FALSE as you require.\n<|/ a tags=r,substring,string\
    \ dscore=1 |>\n<| c |>\nThis returns the same result as the other solutions with\
    \ similar regular expressions.\n<|/ c |>\n<| c |>\nIt will return `TRUE` for any\
    \ string that has a substring that matches the pattern in question. Hence `grepl(...)\
    \ == TRUE`.\n<|/ c |>\n<| c |>\nOh OK... I didn't understand that it was looking\
    \ for substring matches.  I just assumed you wanted matches of words.\n<|/ c |>",
  "\n  a <- stringr::str_subset(a) # returns TRUE or FALSE\n  b <- stringr::str_subset(b)\
    \ # returns TRUE or FALSE\n  return(a | b)\n}\n</code>\n<|/ a |>\n<| c |>\nYeah,\
    \ this works for this particular problem. The problem I'm having is that if someone\
    \ is searching for \"himenss\", then this function should return TRUE for \"simen\"\
    \ as well, because \"himenss\" is a substring of the \"simen\" word. That's why\
    \ I added the str_subset function because if I don't, it will return FALSE if\
    \ the person is searching for \"simen\"\n<|/ c |>\n<| c |>\nPlease see my update.\
    \ I added another function to check if any rotation of `a` into `b` is in `b`.\
    \ I think that should be all you need.\n<|/ c |>\n<| c |>\nThis works! Thanks\
    \ so much. One more thing, how would you return TRUE/FALSE if you only had one\
    \ word? Say they entered \"aba\" instead of \"abcd\"?\n<|/ c |>\n<| c |>\nYou\
    \ would need to add another if-else statement to check if `a` is just one character.\
    \ If it is, return `FALSE`. I will update my answer. Give me a minute.\n<|/ c\
    \ |>\n<| c |>\nI think my code was unclear, sorry for that. Say the user entered\
    \ \"aba\", then the function should return TRUE. So it would look something like\
    \ this: \nif (length(a) == 1) {\nreturn(FALSE)\n}\n<|/ c |>\n<| a tags=string,r\
    \ |>\nYou might try\n<code>\ncycpattern_check<- function(a,b){\n  a<-substr(a,1,1)\n\
    \  b<-substr(b,1,1)\n  a <- na.omit(grep(a, paste0(b, collapse=\"|\"), value=T))\n\
    \  b <- na.omit(grep(b, paste0(a, collapse=\"|\"), value=T))\n  return(a | b)\n\
    }\n</code>\nwhich gives\n<code>\ncycpattern_check('abcd', 'abd')", "\n  a <- tolower(a)\n\
    \  b <- tolower(b)\n  ifelse(length(a) > length(b), 1, \n         ifelse(grepl(a,\
    \ paste(rep(\"[\", abs(length(a) - length(b)), \"]\"), collapse = \"\")), TRUE,\
    \ FALSE))\n}\n</code>\n<|/ a tags=string,r dscore=1 |>\n<| a tags=string,r |>\n\
    A naive way would be to check all the permutations of the second word and see\
    \ if they are in the first word. \n<code>", "\n    stopifnot(length(a) == length(b))\n\
    \    stopifnot(a %in% b)\n    \n    for(i in 1:(length(a) - length(b) + 1)) {\n\
    \        if(substr(a, i + 1, length(a)) %in% b) return(TRUE)\n    }\n    \n  \
    \  return(FALSE)\n}\n", "\n    length(gregexpr(a, tolower(b))) > 0\n}\n", "\n\
    \  a <- tolower(a)\n  b <- tolower(b)\n  r <- regexpr(b,a)\n  return( r < 0 )\n\
    }\n</code>\n<|/ a tags=string,r,performance,pattern-matching |>\n<| a dscore=3\
    \ tags=string,r,performance,pattern-matching |>\nA variation on MrFlick's answer\
    \ using stringr:\n<code>\nlibrary(stringr)\ncycpattern_check <- function(first,second){\n\
    \  cycpattern_check2 <- function(first,second){\n    return(str_detect(first,\
    \ second, FALSE))\n  }\n\n  cycpattern_check3 <- function(first,second){\n   \
    \ return(str_detect(first, second, TRUE))\n  }\n\n  cycpattern_check4 <- function(first,second){\n\
    \    return(str_detect(first, second, regex = T))\n  }\n\n  cycpattern_check <-\
    \ function(first,second){\n    cycpattern_check2 <- function(first,second){\n\
    \      return(str_detect(first, second, FALSE))\n    }\n\n    cycpattern_check3\
    \ <- function(first,second){\n      return(str_detect(first, second, TRUE))\n\
    \    }\n\n    cycpattern_check4 <- function(first,second){\n      return(str_detect(first,\
    \ second, regex = T))\n    }\n\n    cycpattern_check1 <- function(first,second){\n\
    \      return(FALSE)\n    }\n\n    cycpattern_check2 <- switch(cycpattern_check2(cycpattern_check3(cycpattern_check4(cycpattern_check1(first,second),\
    \ second), second), second), \n                                  TRUE=cycpattern_check3(cycpattern_check4(cycpattern_check1(first,second),\
    \ second), second), \n                                  FALSE=cycpattern_check4(cycpattern_check1(first,second),\
    \ second))\n  }\n  cycpattern_check2(first,second)\n}\n</code>\nI prefer the last\
    \ two functions over MrFlick's because they only test the pattern once.\nEdit:\
    \ This solution can be further improved to test multiple patterns at once:\n<code>\n\
    library(stringr)\ncycpattern_check2 <- function(first,second){\n  cycpattern_check3\
    \ <- function(first,second){\n    return(str_detect(first, second, TRUE))\n  }\n\
    \n  cycpattern_check4 <- function(first,second){\n    return(str_detect(first,\
    \ second, regex = T))\n  }\n\n  cycpattern_check5 <- function(first,second){\n\
    \    return(str_detect(", "\n  ifelse(\n    grepl(paste(rev(seq(along = a)), rev(a)),\
    \ b),\n    TRUE,\n    FALSE\n  )\n}\n</cell>\n<text>\nTask 7. Write a function\
    \ that counts the number of characters in a word\n\n\n</text>\n<cell>", "\n  \n\
    \  if(a==\"\" | b==\"\") {\n    return(FALSE)\n  }\n  \n  l1 <- length(a)\n  l2\
    \ <- length(b)\n  \n  if(l1>l2) return(FALSE)\n  \n  rot <- c(0:(l2-l1+1), 0)\n\
    \  \n  for(i in 1:l1) {\n    \n    substr_start <- findStrStart(a, a[i])\n   \
    \ \n    if(substr_start==-1) return(FALSE)\n    \n    for(j in 1:l2) {\n     \
    \ \n      if(substr(b, j, 1)==a[i] & j==l2) return(TRUE)\n      \n      if(substr(b,\
    \ j, 1)==a[i] & j==rot(j)) return(TRUE)\n      \n      if(substr(b, j, 1)==a[i]\
    \ & j==rot((j-1))) {\n        if(substr(b, j, 1)==a[i] & j==rot(j-1)) return(TRUE)\n\
    \        return(FALSE)\n      }\n      \n    }\n    \n  }\n  \n  return(FALSE)\n\
    }\n", "\n    \n    b <- tolower(b)\n    a <- tolower(a)\n    \n    ## Check for\
    \ pattern before rotation\n    i <- 1\n    while (i < length(a)) {\n        b\
    \ <- paste(b, a[i : (i + length(a - b))], sep = \"\")\n        i <- i + length(a\
    \ - b)\n    }\n    \n    ## Check for patterns after rotation\n    i <- 1\n  \
    \  while (i < length(b)) {\n        a <- paste(a, a[i : (i - length(a - b) + 1)],\
    \ sep = \"\")\n        i <- i + length(a - b)\n    }\n    \n    i <- 1\n    while\
    \ (i < length(a)) {\n        if (grepl(b, a[i])) {\n            i <- i + 1\n \
    \       }\n        else {\n            i <- i + 1\n        }\n    }\n    \n  \
    \  return(TRUE)\n}\n", "\n  x <- strsplit(a, \"\")[[1]]\n  y <- strsplit(b, \"\
    \")[[1]]\n  return(\n    apply(sapply(x, function (x) which(y %in% x)), 2, any)\n\
    \  )\n}\n</code>\nAnd we can test:\n<code>\n> cycpattern_check(\"abc\", \"acb\"\
    )\n[1] FALSE\n> cycpattern_check(\"abcd\", \"abd\")\n[1] FALSE\n> cycpattern_check(\"\
    hello\", \"ell\")\n[1] TRUE\n> cycpattern_check(\"whassup\", \"psus\")\n[1] FALSE\n\
    > cycpattern_check(\"abab\", \"baa\")\n[1] TRUE\n> cycpattern_check(\"efef\",\
    \ \"eeff\")\n[1] FALSE\n> cycpattern_check(\"himenss\", \"simen\")\n[1] TRUE\n\
    </code>\n<|/ a |>\n<| c |>\nPlease excuse my ignorance but I don't understand\
    \ the logic. Can you explain it in detail please?\n<|/ c |>\n<| c |>\nI think\
    \ my explanation is self-explanatory. First I split the words on characters into\
    \ different parts, then I test whether each part is present in the other word\
    \ (using sapply).\n<|/ c |>\n<| c |>\nIt works but can you tell me why it is faster?\n\
    <|/ c |>\n<| c |>\nI wonder why this one runs faster than `grepl()` on my computer\
    \ (R 3.2.1, Windows 7 64 bits). Could you explain it to me?\n<|/ c |>\n<| c |>\n\
    I suspect that `grepl()` is vectorized, and my code isn't.\n<|/ c |>\n<| a dscore=4\
    \ tags=string,r,string-matching,regex |>\n<code>\nlibrary(stringr)\n\nstringr::str_detect(\"\
    hello world\", \"hello .*\")\n[1] TRUE\n\nstringr::str_detect(\"hello world\"\
    , \"world hello\")\n[1] FALSE\n</code>\n<|/ a |>\n<| a dscore=4 |>\nAnother way\
    \ is using str_subset with word boundaries, which in R means look-behind and look-ahead\
    \ for word boundaries respectively:\n<code>\nstr_subset(\"abc def\", \"\\\\babc\\\
    \\b\")", "\n  a <- tolower(a)\n  b <- tolower(b)\n  \n  if(nchar(a) != nchar(b)\
    \ || nchar(a) == 0) {\n    return(FALSE)\n  }\n  \n  for(i in seq_along(a)) {\n\
    \    if(b %in% strsplit(a[i], \"\")) {\n      return(TRUE)\n    }\n    \n    for(j\
    \ in seq_along(b)) {\n      if(a[i] %in% strsplit(b[j], \"\")) {\n        return(TRUE)\n\
    \      }\n    }\n  }\n  \n  return(FALSE)\n}\n</cell>\n<cell>", "\n  if (length(a)\
    \ > length(b)) {\n    return(FALSE)\n  }\n  a_rotations <- t(apply(expand.grid(rep(list(a),\
    \ 2), nrow = 2), 1, function(x) {\n    return(paste0(x[1], x[2]))\n  }))\n  b_rotations\
    \ <- t(apply(expand.grid(rep(list(b), 2), nrow = 2), 1, function(x) {\n    return(paste0(x[1],\
    \ x[2]))\n  }))\n  return(any(a_rotations %in% b_rotations))\n}\n</cell>\n<code\
    \ language=conda-env-R-r>", "\n    a_lower <- tolower(a)\n    b_lower <- tolower(b)\n\
    \    \n    if(a_lower == b_lower) {\n        return(TRUE)\n    }\n    \n    a_lower\
    \ <- stringr::str_replace_all(a_lower, '\\\\s+', '')\n    b_lower <- stringr::str_replace_all(b_lower,\
    \ '\\\\s+', '')\n    \n    if(a_lower == b_lower) {\n        return(TRUE)\n  \
    \  }\n    \n    a_lower <- stringr::str_replace_all(a_lower, '[^a-zA-Z]', '')\n\
    \    b_lower <- stringr::str_replace_all(b_lower, '[^a-zA-Z]', '')\n    \n   \
    \ a_lower <- stringr::str_replace_all(a_lower, '_', '')\n    b_lower <- stringr::str_replace_all(b_lower,\
    \ '_', '')\n    \n    a_lower <- stringr::str_replace_all(a_lower, '', '')\n \
    \   b_lower <- stringr::str_replace_all(b_lower, '', '')\n    \n    a_lower <-\
    \ stringr::str_replace_all(a_lower, '  ', '')\n    b_lower <- stringr::str_replace_all(b_lower,\
    \ '  ', '')\n    \n    a_lower <- stringr::str_replace_all(a_lower, '_', '')\n\
    \    b_lower <- stringr::str_replace_all(b_lower, '_', '')\n    \n    a_lower\
    \ <- stringr::str_replace_all(a_lower, '', '')\n    b_lower <- stringr::str_replace_all(b_lower,\
    \ '', '')\n    \n    a_lower <- stringr::str_replace_all(a_lower, '  ', '')\n\
    \    b_lower <- stringr::str_replace_all(b_lower, '  ', '')\n    \n    a_lower\
    \ <- stringr::str_replace_all(a_lower, '_', '')\n    b_lower <- stringr::str_replace_all(b_lower,\
    \ '_', '')\n    \n    a_lower <- stringr::str_replace_all(a_lower, '', '')\n \
    \   b_lower <- stringr::str_replace_all(b_lower, '', '')\n    \n    a_lower <-\
    \ stringr::str_replace_all(a_lower, '  ', '')\n    b_lower <- stringr::str_replace_all(b_lower,\
    \ '  ', '')\n    \n    a_lower <- stringr::str_replace_all(a_lower, '_', '')\n\
    \    b_lower <- stringr::str_replace_all(b_lower, '_', '')\n    \n    a_lower\
    \ <- stringr::str_replace_all(a_lower, '', '')\n    b_lower <- stringr::str_replace_all(b_lower,\
    \ '', '')\n    \n    ", "\n  if(!is.vector(a) || !is.vector(b)) {\n    stop(\"\
    Both inputs must be vectors\")\n  }\n  \n  if(!all(length(a) == length(b))) {\n\
    \    stop(\"Inputs must have same length\")\n  }\n  \n  if(length(a) == 0) {\n\
    \    stop(\"No elements in first argument\")\n  }\n  \n  # Cyclic Pattern\n  #\
    \ If first is shorter than the second, no need to consider further\n  # If the\
    \ length of second is 0, then the pattern must be empty \n  # If the length of\
    \ the pattern is equal to the length of the first, it is cyclic\n  \n  if(nchar(a)\
    \ < nchar(b)) {\n    return(FALSE)\n  }\n  \n  if(nchar(b) == 0) {\n    return(TRUE)\n\
    \  }\n  \n  return(TRUE)\n}\n\n", "\n  a <- tolower(a)\n  b <- tolower(b)\n  if(length(a)\
    \ == length(b)) {\n    for(i in 1:(length(a))) {\n      if(grepl(a[i], b)) {\n\
    \        return(TRUE)\n      }\n    }\n    return(FALSE)\n  } else\n    stop(\"\
    The length of strings must be the same\")\n}\n</code>\n<|/ a dscore=1 tags=r,dataframe,string\
    \ |>\n<| c |>\nThank you for your comment. My expected results are TRUE for all\
    \ cases.\n<|/ c |>\n<| a tags=r,dataframe,string |>\nHere is a base R option:\n\
    <code>\ncycpattern_check=function(x, y){\n  x=tolower(x)\n  y=tolower(y)\n  if(length(x)==length(y)){\n\
    \    for(i in 1:(length(x))){\n      if(i>1&grepl(x[i],y[1:i],fixed=TRUE)){\n\
    \        return(TRUE)\n      }\n    }\n    return(FALSE)\n  }else\n    stop(\"\
    The length of strings must be the same\")\n}\n\ncycpattern_check(\"abcd\", \"\
    abd\")", "\n  str1 <- tolower(trimws(a))\n  str2 <- tolower(trimws(b))\n  len1\
    \ <- length(unlist(strsplit(str1, \"\")))\n  len2 <- length(unlist(strsplit(str2,\
    \ \"\")))\n  \n  if(len1 != len2) return(FALSE)\n  \n  for(i in seq(1, len1))\
    \ {\n    str2 <- paste(rev(str2), str2, sep=\"\")\n    str2 <- paste(str2, str1,\
    \ sep=\"\")\n    \n    if(str2 %in% str1) return(TRUE)\n  }\n  \n  return(FALSE)\n\
    }\n", "\n  a <- tolower(a)\n  b <- tolower(b)\n  any(grepl(paste0(\"\\\\b\", a,\
    \ \"\\\\b\", collapse = \"|\"), a) | grepl(paste0(\"\\\\b\", a, \"\\\\b\", collapse\
    \ = \"|\"), c(b)))\n}\n", "\n  a <- gsub(\"[.]\", '', a)\n  b <- gsub(\"[.]\"\
    , '', b)\n\n  m <- nchar(a)\n  n <- nchar(b)\n\n  if (m == 0) return(FALSE)\n\
    \  if (n == 0) return(FALSE)\n\n  for (i in 0:m) {\n    if (b[n-i+1] == a[i])\
    \ return(TRUE)\n  }\n  return(FALSE)\n}\n</code>\n<|/ a |>\n<| c |>\nYep. That's\
    \ it. Thanks for the answer. I've updated my answer to include my final solution.\n\
    <|/ c |>\n<| c |>\nYou probably meant `if (m == 0) return(FALSE)`\n<|/ c |>\n\
    <| c |>\nI did, I changed it to 'm' to be more descriptive.\n<|/ c |>\n<| a |>\n\
    If your input vectors are very long, there may be a more efficient solution than\
    \ using nested loops. But if you really want to avoid loops, you can use the sapply\
    \ function like this:\n<code>\ncycpattern_check<-function(a,b)\n{\n    a<-gsub(\"\
    [.]\", '', a)\n    b<-gsub(\"[.]\", '', b)\n\n    m<-length(a)\n    n<-length(b)\n\
    \n    if (m==0) return(FALSE)\n    if (n==0) return(FALSE)\n\n    any(sapply(1:m,\
    \ function(i) any(b[n-i] == a[i]))) \n}\n</code>\nIt works well for vectors with\
    \ small length (less than a thousand) but gets very slow for larger ones. For\
    \ example for a=c(letters,letters) or a=c(letters,letters,letters). \nA more efficient\
    \ way may be to use mapply like this:\n<code>\ncycpattern_check<-function(a,b)\n\
    {\n    a<-gsub(\"[.]\", '', a)\n    b<-gsub(\"[.]\", '', b)\n\n    m<-length(a)\n\
    \    n<-length(b)\n\n    if (m==0) return(FALSE)\n    if (n==0) return(FALSE)\n\
    \n    any(mapply(function(i,j) any(b[n-i] == a[j]),1:m,1:m))\n}\n</code>\n<|/\
    \ a dscore=2 tags=r,pattern-matching,string |>\n<| c |>\nI thought of using `any`\
    \ with `sapply` but `sapply` was too slow. Thanks for the answer!\n<|/ c |>\n\
    <| c |>\nI added an alternative with `mapply`\n<|/ c |>\n<| c |>", "\n  for(i\
    \ in 1:length(a)) {\n    for(j in 1:length(b)) {\n      if(a[i] %in% substring(b[j],\
    \ i, 1) | a[i] %in% substring(b[j], i, 2) | a[i] %in% substring(b[j], i, 3)) \n\
    \      a[i] <- substring(a[i], 1, 1)\n      a[i] <- substring(a[i], i, 1)\n  \
    \    a[i] <- substring(a[i], 1, i)\n    }\n  }\n  return(a == b)\n}\n</code>\n\
    <|/ a dscore=1 tags=r,string |>\n<| c |>\nthank you very much for your help. My\
    \ purpose is to find the substrings, not permutations\n<|/ c |>\n<| c |>\nThank\
    \ you for your help too. My purpose is to find the substrings, not permutations\n\
    <|/ c |>\n<| a |>\nUsing stringr, you can do this:\n<code>\nlibrary(stringr)\n\
    \na <- \"aaab\"\nb <- \"aba\"\n\na %in% str_match(b,\"(aa|ab)\",invert=TRUE)\n\
    \n[1] TRUE\n</code>\nThis works by finding the pattern (aa|ab) in the string a\
    \ and checking if it is in b with invert=TRUE. str_match returns the positions\
    \ and then we can simply check if the element is in the vector or not.\n<|/ a\
    \ tags=r,string dscore=1 |>\n<| c |>\nthank you very much for your help. My purpose\
    \ is to find the substrings, not permutations\n<|/ c |>\n<| c |>\nThank you for\
    \ your help too. My purpose is to find the substrings, not permutations\n<|/ c\
    \ |>\n<| c |>\nI think you need to rephrase your question then. What do you mean\
    \ by substring? Can you provide some examples please\n<|/ c |>\n<| a |>\nYou can\
    \ use lapply to generate all permutations of characters in each word and subset\
    \ those strings from your input strings.\n<code>", "\n  return(a %in% b)\n}\n\
    </code>\n<|/ a tags=r,regex |>\n<| c |>\nThank you for providing such a detailed\
    \ answer! I have made some changes to the code and I have tested it on a few other\
    \ cases and it works perfectly!\n<|/ c |>\n<| a |>\nHere is a solution that does\
    \ not use regular expressions.\n<code>\ncycpattern_check <- function(a, b) {\n\
    \  c <- strsplit(a, \"\")[[1]]\n  d <- strsplit(b, \"\")[[1]]\n  r <- length(c)\
    \ - length(d)\n  return(all(mapply(function(x, y) {\n    return(x %in% y)\n  },\
    \ c, lapply(strrep(d, r), function(x) { paste0(x, x) }))))\n}\n\ncycpattern_check(\"\
    hello\", \"ell\")", "\n  return(grepl(paste0(paste(rev(b), collapse = \"|\"),\
    \ collapse = \"|\"), paste(rev(a), collapse = \"|\")))\n}\n", "\n  # Your code\
    \ here\n  a_len <- length(a)\n  b_len <- length(b)\n  \n  if(a_len != b_len) {\n\
    \    return(FALSE)\n  }\n  \n  a_list <- strsplit(a, \"\")\n  b_list <- strsplit(b,\
    \ \"\")\n  \n  for(i in seq_along(a_list)) {\n    a_list[i] <- paste0(a_list[i],\
    \ collapse = \"\")\n  }\n  \n  for(i in seq_along(b_list)) {\n    b_list[i] <-\
    \ paste0(b_list[i], collapse = \"\")\n  }\n  \n  if(any(grepl(b_list, a_list)))\
    \ {\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n", "\n  # Convert\
    \ the strings to lower case\n  a <- tolower(a)\n  b <- tolower(b)\n  \n  # Check\
    \ for the first character\n  if (a[1] == b[1]) {\n    # Check for any word which\
    \ has a rotation of the first character in a word\n    for(w in 1:length(a)) {\n\
    \      if(a[w] == b[w]) {\n        for(a in 1:(w + 1)) {\n          if(length(grep(a[a:(w+1)],\
    \ a)) > 0) \n            return TRUE\n        }\n      }\n    }\n  }\n  \n  #\
    \ If they dont match, then check the second character\n  if(a[1] != b[1]) {\n\
    \    for(w in 1:length(a)) {\n      if(a[w] == b[w]) {\n        for(a in 1:(w\
    \ + 1)) {\n          if(length(grep(b[a:(w+1)], b)) > 0) \n            return\
    \ TRUE\n        }\n      }\n    }\n  }\n  \n  # Return FALSE if both dont match\n\
    \  return FALSE\n}\n", "\n  len1 <- nchar(a)\n  len2 <- nchar(b)\n  lenmin <-\
    \ min(c(len1, len2))\n  lenmax <- max(c(len1, len2))\n  \n  if (len1 %in% c(0,1)\
    \ && len2 %in% c(0,1)) {\n    \n  }\n  \n  if (len1 == 1) {\n    \n  }\n  \n \
    \ if (len1 == len2) {\n    \n  }\n  \n  if (len1 == lenmax) {\n    \n  }\n  \n\
    \  if (len1 == lenmin && lenmin > len2) {\n    \n  }\n  \n  if (len2 == lenmin\
    \ && lenmin > len1) {\n    \n  }\n  \n  if (lenmin > 1 & len1 < lenmax && lenmin\
    \ > len2) {\n    \n  }\n  \n  if (lenmin > 1 & len1 < lenmax && lenmin > len2)\
    \ {\n    \n  }\n  \n  if (lenmin > 1 & len1 < lenmax && lenmin > len2) {\n   \
    \ \n  }\n  \n  if (len1 == lenmax & lenmin > len2 & lenmin > len2) {\n    \n \
    \ }\n  \n  if (len1 == lenmax & lenmin > len2 & lenmin > len2) {\n    \n  }\n\
    \  \n  if (len1 == lenmax & lenmin > len2 & lenmin > len2) {\n    \n  }\n  \n\
    \  if (len1 == lenmax & lenmin > len2 & lenmin > len2) {\n    \n  }\n  \n  if\
    \ (len1 == lenmax & lenmin > len2 & lenmin > len2) {\n    \n  }\n  \n  if (len1\
    \ == lenmax & lenmin > len2 & lenmin > len2) {\n    \n  }\n  \n  if (len1 == lenmax\
    \ & lenmin > len2 & lenmin > len2) {\n    \n  }\n  \n  if (len1 == lenmax & lenmin\
    \ > len2 & lenmin > len2) {\n    \n  }\n  \n  if (len1 == lenmax & lenmin > len2\
    \ & lenmin > len2) {\n    \n  }\n  \n  if (len1 == lenmax & lenmin > len2 & lenmin\
    \ > len2) {\n    \n  }\n  \n  if (len1 == lenmax & lenmin > len2 & lenmin > len2)\
    \ {\n    \n  }\n  \n  if (len1 == lenmax & lenmin > len2 & lenmin > len2) {\n\
    \    \n  }\n  \n  if (len1 == lenmax & lenmin > len2 & lenmin > ", "\n    # checks\
    \ that a is a substring of the string\n    # b or any rotation of the b character\
    \ string is a substring of the a string\n    a <- toupper(a)\n    b <- toupper(b)\n\
    \    a <- gsub(\"[[:punct:]]\", \" \", a)\n    b <- gsub(\"[[:punct:]]\", \" \"\
    , b)\n    a <- paste(substr(a, 1, 1), substr(a, 2, nchar(a) - 2), substr(a, nchar(a)\
    \ - 1, nchar(a)), sep=\"\")\n    b <- paste(substr(b, 1, 1), substr(b, 2, nchar(b)\
    \ - 2), substr(b, nchar(b) - 1, nchar(b)), sep=\"\")\n    if (b %in% a) {\n  \
    \      return TRUE\n    } else {\n        return FALSE\n    }\n}\n", "\n  nc <-\
    \ nchar(a)\n  nr <- nchar(b)\n  r <- 0\n  c <- 1\n  while (c <= nr) {\n    if\
    \ (nc == 1) # We check it this way because if nc is 1, c will always be equal\
    \ to 1, therefore the while loop will never be entered\n      return (TRUE)\n\
    \    if (nc == 2) # We check it this way because if nc is 2, c will always be\
    \ equal to 2, therefore the while loop will never be entered\n      return (FALSE)\n\
    \    while (substr(a, c, c) == substr(b, c, c)) {\n      r <- r + 1\n      c <-\
    \ c + 2\n    }\n    c <- c + 1\n  }\n  return (FALSE)\n}\n", "\n  if (length(a)\
    \ < length(b)) {\n    b <- paste(rev(b), collapse = \"\")\n  }\n  any(grepl(b,\
    \ a))\n}\n", "\n  b <- toupper(b)\n  a <- toupper(a)\n  b <- b[-length(b)]\n \
    \ n <- length(a)\n  i <- 1\n  while(i <= n) {\n    while(i <= n && n <= length(a)\
    \ && isTRUE(str_detect(a, substring(b, i, n)))) i <- i + 1\n    if(i <= n) i <-\
    \ i + 1\n  }\n  return(i %in% n)\n}\n</cell>\n<cell>", "\n  \n  # Check length\n\
    \  if (length(a) != length(b) || length(b) == 0) {\n    return(FALSE)\n  }\n \
    \ \n  # Sort input\n  a <- sort(unique(a))\n  b <- sort(unique(b))\n  \n  # Find\
    \ index positions in a\n  a <- which(a %in% b)\n  \n  # Check each possible permutation\n\
    \  a <- a[!duplicated(a)]\n  \n  \n  # Remove if in b\n  if (length(a) == 0) {\n\
    \    return(TRUE)\n  }\n  \n  \n  \n  \n  # Check each element\n  for (i in 1:(length(a)-1))\
    \ {\n    \n    # Find all elements bigger than i in a\n    a <- a[a > i]\n   \
    \ \n    \n    # Remove if in b\n    if (length(a) == 1) {\n      return(TRUE)\n\
    \    }\n    \n    \n    \n    # Remove if in b\n    if (any(a %in% b)) {\n   \
    \   return(FALSE)\n    }\n    \n    \n    \n  }\n  \n  return(TRUE)\n}\n</cell>\n\
    <text>\nExample: Cyclic patterns\nThe pattern ABBA is not cyclic, because A appears\
    \ before the B on each of the two cycles.\n\nFor each of the two possible cycles,\
    \ we can remove the A from each of the cycles that begin with A or B. If we remove\
    \ A and B, both cycles become cyclic and hence not cyclic. The number of cycles\
    \ remains the same and hence cyclic. For example, the cycle ABBA has 3 cycles:\
    \ A, AB, BA. The number of cycles remains the same. Hence cyclic.\n\nThe word\
    \ HAPPYHAPPYHAPPY has only one cycle. The number of cycles remains the same. Hence\
    \ cyclic.\n\nFor each of the two possible cyclic patterns, we can remove all the\
    \ As and Bs from the cycles that begin with A and B. If we remove all the As and\
    \ Bs, there is one cycle left which doesn't contain any As or Bs. Hence cyclic.\
    \ For example, the pattern HAPPYHAPPYHAPPY has only one cycle, which is HAPPYHAPPYHAPPY.\
    \ The number of cycles remains the same. Hence cyclic.\n\nThe word ABB has two\
    \ cycles. Each cycle starts with A. The number of cycles is 2. Hence cyclic.\n\
    \n\n</text>\n<text>\nQuestion 5\nWrite a function which takes a string word as\
    \ an input and returns the longest substring that can be formed from the input\
    \ string which contains all unique letters. Write a test case for each of the\
    \ functions. For example:\n\ncycpattern_check", "\n    b <- tolower(b)\n    \n\
    \    a_l <- strsplit(a, \"\")[[1]]\n    b_l <- strsplit(b, \"\")[[1]]\n    \n\
    \    b_l <- b_l[-1]\n    \n    a_l <- a_l[-1]\n    \n    b_l <- paste(b_l, collapse\
    \ = \"\")\n    \n    a_l <- paste(a_l, collapse = \"\")\n    \n    b_l <- paste(b_l,\
    \ collapse = \"\")\n    \n    a_l <- paste(a_l, collapse = \"\")\n    \n    b_l\
    \ <- paste(b_l, collapse = \"\")\n    \n    a_l <- paste(a_l, collapse = \"\"\
    )\n    \n    b_l <- paste(b_l, collapse = \"\")\n    \n    a_l <- paste(a_l, collapse\
    \ = \"\")\n    \n    b_l <- paste(b_l, collapse = \"\")\n    \n    a_l <- paste(a_l,\
    \ collapse = \"\")\n    \n    b_l <- paste(b_l, collapse = \"\")\n    \n    a_l\
    \ <- paste(a_l, collapse = \"\")\n    \n    b_l <- paste(b_l, collapse = \"\"\
    )\n    \n    a_l <- paste(a_l, collapse = \"\")\n    \n    b_l <- paste(b_l, collapse\
    \ = \"\")\n    \n    a_l <- paste(a_l, collapse = \"\")\n    \n    b_l <- paste(b_l,\
    \ collapse = \"\")\n    \n    a_l <- paste(a_l, collapse = \"\")\n    \n    b_l\
    \ <- paste(b_l, collapse = \"\")\n    \n    a_l <- paste(a_l, collapse = \"\"\
    )\n    \n    b_l <- paste(b_l, collapse = \"\")\n    \n    a_l <- paste(a_l, collapse\
    \ = \"\")\n    \n    b_l <- paste(b_l, collapse = \"\")\n    \n    a_l <- paste(a_l,\
    \ collapse = \"\")\n    \n    b_l <- paste(b_l, collapse = \"\")\n    \n    a_l\
    \ <- paste(a_l, collapse = \"\")\n    \n    b_l <- paste(b_l, collapse = \"\"\
    )\n    \n    a_l <- paste(a_l, collapse = \"\")\n    \n    b_l <- paste(b_l, collapse\
    \ = \"\")\n    \n    a_l <- paste(a_l, collapse = \"\")\n    \n    b_l <- paste(b_l,\
    \ collapse = \"\")\n    \n    a_l <- paste(a_l, collapse = \"\")\n    \n    b_l\
    \ <- paste(b_l, collapse = \"\")\n    \n    a_l <- paste(a_l, collapse = \"\"\
    )\n    ", "\n  a <- tolower(a)\n  b <- tolower(b)\n  \n  if(!is.na(a) & !is.na(b)\
    \ & length(a) > 0) {\n    if(length(grep(b, a, ignore.case = TRUE)) > 0) return(TRUE)\n\
    \    \n    m <- sapply(seq_along(a), function(x) grep(b, substr(a[x], 1, x), ignore.case\
    \ = TRUE))\n    return(all(m))\n  }\n  \n  return(FALSE)\n}\n", "\n    \n    a\
    \ = tolower(a)\n    b = tolower(b)\n    \n    if (!is.na(a) && !is.na(b)) {\n\
    \        \n        a_l = length(a)\n        b_l = length(b)\n        \n      \
    \  for(i in 1:a_l) {\n            \n            for(j in 1:b_l) {\n          \
    \      \n                if(i %in% c(1:a_l) && j %in% c(1:b_l)) {\n          \
    \          \n                    if(a[(i+1):a_l] == b[(j+1):b_l]) {\n        \
    \                \n                        return(TRUE)\n                    \
    \    \n                    }\n                    \n                }\n      \
    \          \n            }\n            \n        }\n        \n        return(FALSE)\n\
    \        \n    }\n    \n}\n</cell>\n<cell>\ncycpattern_check('whassup', 'psus')\n\
    </cell>\n<cell>\ncycpattern_check('efef', 'eeff')\n</cell>\n<cell>\ncycpattern_check('himenss',\
    \ 'simen')\n</cell>\n<text>\nQuestion 2\nYou are given a string S consisting of\
    \ digits. You need to find out whether the string is a palindrome or not. A palindrome\
    \ is a word or phrase which reads the same backward as forward.\n\nA palindrome\
    \ is a word, phrase, or other sequence which reads the same backward as forward.\
    \ In a word, phrase, or other sequence, each word is read backward, then the next\
    \ word is read forward. \n\nGiven a string, S, you need to find out whether it\
    \ is a palindrome or not.\n\nInput/Output\n\n[time limit] 4000ms (py)\n\n[input]\
    \ string S\n\nA string consisting of digits.\n\nGuaranteed constraints:\n5 \u2264\
    \ Length of S \u2264 100.\n\n[output] boolean\n\ntrue if S is a palindrome, otherwise\
    \ false\n\n\n</text>\n<cell>", "\n  res <- TRUE\n  \n  for(i in seq_along(a))\
    \ {\n    for(j in seq_along(b)) {\n      if(a[[i]] == b[[j]]) {\n        res <-\
    \ FALSE\n        \n        break\n      }\n    }\n  }\n  \n  return(res)\n}\n",
  "\n  # Check if b is a substring of a\n  all(unlist(str_split(b, \"\", simplify\
    \ = TRUE)) == str_split(a, \"\", simplify = TRUE)\n  )\n}\n", "\n  stopifnot(a\
    \ != \"\", b != \"\")\n  stopifnot(grepl(pattern = \"^[a-z]+$\", x = a))\n  stopifnot(grepl(pattern\
    \ = \"^[a-z]+$\", x = b))\n  stopifnot(grepl(pattern = \"^[a-z]+$\", x = paste(rev(a),\
    \ rev(stringr::str_split(b, \"\\\\\")[[1]]), sep = \"\")))\n}\n", "\n  a <- unlist(strsplit(a,\
    \ \"\"))\n  b <- unlist(strsplit(b, \"\"))\n  \n  # a is the pattern\n  # b is\
    \ the word\n  \n  x <- length(a)\n  y <- length(b)\n  \n  # if the length of pattern\
    \ is greater than the length of word\n  if (x>y) {\n    # then return false\n\
    \    return FALSE\n  } else { \n    # then return true\n    # if the length of\
    \ word is greater than the length of pattern\n    if (x>y) {\n      # then go\
    \ through each character in pattern\n      # and compare them to the characters\
    \ in word\n      for (i in x:y) {\n        # if the characters in pattern are\
    \ in word\n        if (grepl(a[i], b)) \n          # then return true\n      \
    \    return TRUE\n      }\n    }\n  }\n  \n  # return false\n  return FALSE\n\
    }\n</code>\n<|/ a tags=string,pattern-matching,r |>\n<| c |>\nThis answer has\
    \ a few bugs. 1) It doesn't return true when the pattern is longer than the word,\
    \ and 2) it misses cases that do match, but shouldn't. For example, \"himenss\"\
    \ and \"simen\" both match, but shouldn't (they have one character rotated in\
    \ the middle). Also note that `str_rot13` isn't in the standard R installation.\n\
    <|/ c |>\n<| c |>\nThanks, your answer was very helpful! I changed some things\
    \ to get the desired outcome.\n<|/ c |>\n<| c |>\nHi Tyler, I updated my answer\
    \ to address the bugs. Thanks for pointing that out!\n<|/ c |>\n<| a dscore=0\
    \ tags=string,pattern-matching,r |>\nI think you mean something like this:\n<code>\n\
    cycpattern_check <- function(a, b) {\n  s1 <- strsplit(a, \"\")\n  s2 <- strsplit(b,\
    \ \"\")\n  \n  # a is the pattern\n  # b is the word\n  \n  x <- length(unlist(s1))\n\
    \  y <- length(unlist(s2))\n  \n  # if the length of pattern is greater than the\
    \ length of word\n  if (x>y) {\n    # then return false\n    return FALSE\n  }\
    \ else { \n    # then return true\n    # if the length of word is greater than\
    \ the length of pattern\n    if (x>y) {\n      # then go through each character\
    \ in pattern\n      # and compare them to the characters in word\n      for (i\
    \ in x:y) {\n        # if the characters in pattern are in word\n        if (grepl(unlist(s1)[i],\
    \ unlist(s2))) \n          # then return true\n          return TRUE\n      }\n\
    \    }\n  }\n  \n  # return ", "\n  a_words <- strsplit(a, \"\")[[1]]\n  b_words\
    \ <- strsplit(b, \"\")[[1]]\n  a_words <- a_words[-length(b_words)]\n  a_words\
    \ <- unlist(a_words)\n  b_words <- b_words[-length(a_words)]\n  b_words <- unlist(b_words)\n\
    \  all(unlist(sapply(a_words, function(x) any(x %in% b_words))))\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=algorithm,string,r |>\nHere is a simple solution\
    \ using regex:\n<code>\nlibrary(stringr)\n\ncycpattern_check<-function(pattern,string){\n\
    \  pattern=str_split(pattern,\"\")[[1]];\n  string=str_split(string,\"\")[[1]];\n\
    \  pattern=pattern[-length(string)];\n  pattern=pattern[!(grepl(pattern,string));]\n\
    \  return(length(grep(pattern,string,value=TRUE))>0)\n}\n\ncycpattern_check(\"\
    himenss\",\"simen\")", "\n  s <- strsplit(a, \"\")[[1]]\n  b <- strsplit(b, \"\
    \")[[1]]\n  sapply(1:(length(s) - length(b)), function(i) {\n    any(sapply(1:length(b),\
    \ function(j) {\n      substr(s, i, i + j) == b[j]\n    }))\n  })\n}\n</code>\n\
    <|/ a tags=string,r,pattern-matching |>\n<| a dscore=2 tags=string,r,pattern-matching\
    \ |>\nUsing base R\n<code>\nsapply(strsplit(word1,split=\" \") , function(x)\n\
    \    sapply(strsplit(word2,split=\" \") , function(y) \n             x %in% y))\n\
    </code>\nor using gregexpr\n<code>\nsapply(strsplit(word1,split=\" \") , function(x)\
    \ gregexpr(paste(x,collapse=\"|\"),word2))\n</code>\n<|/ a |>\n<| a tags=string,r,pattern-matching\
    \ |>\nWe can do this with a single gsub.  We capture the parts surrounded by (\
    \ and ) as a group ((\\\\((.*?))\\\\)) and then replace with the second string\
    \ (using backreference) and do a check to see if there are any matches.\n<code>\n\
    gsub('(\\\\((.*?))\\\\)', '\\\\1', word1) %in% gsub('(\\\\((.*?))\\\\)', '\\\\\
    1', word2)", "\n    a <- tolower(a)\n    b <- tolower(b)\n    res <- a %in% b\n\
    \    return(res)\n}\n</code>\n<|/ a dscore=0 tags=r,pattern-matching |>\n<| c\
    \ |>\nThis solution is not general enough since it fails on \"hello\" and \"helloo\"\
    \ which should return TRUE. Also it fails for \"aba\" and \"aab\", which should\
    \ return FALSE. Also, there are cases where this solution should return TRUE for\
    \ example the letter \"a\" is at the beginning of the string in \"aab\", which\
    \ should return FALSE.\n<|/ c |>\n<| a dscore=0 |>\nI took some ideas from another\
    \ post (here), including using regex to find the first occurrence of \"a\" and\
    \ then the beginning of the string. It seems to work well.\n<code>\ncycpattern_check2\
    \ <- function(x, y) {\n  # find first occurence of \"a\"\n  a_regex  <- gregexpr(\"\
    a\", x)[1]\n  # return TRUE if y is contained by x\n  a <- y[a_regex]\n  return(a\
    \ %in% x)\n}\n</code>\n<|/ a tags=r,pattern-matching |>\n<| a |>\nJust for reference,\
    \ here are 2 other ways of solving this problem:\n<code>\ncycpattern_check2 <-\
    \ function(x, y) {\n  # find first occurence of \"a\"\n  a_regex  <- gregexpr(\"\
    a\", x)[1]\n  # return TRUE if y is contained by x\n  a <- y[a_regex]\n  return(a\
    \ %in% x)\n}\n\ncycpattern_check3 <- function(x, y) {\n  # find first occurence\
    \ of \"a\"\n  a_regex  <- gregexpr(\"a\", x)[1]\n  # return TRUE if y is contained\
    \ by x\n  a <- y[a_regex]\n  return(a %in% x)\n}\n\ncycpattern_check4 <- function(x,\
    \ y) {\n  # find first occurence of \"a\"\n  a_regex  <- gregexpr(\"a\", x)[1]\n\
    \  # return TRUE if y is contained by x\n  a <- y[a_regex]\n  return(a %in% x)\n\
    }\n\ncycpattern_check5 <- function(x, y) {\n  # find first occurence of \"a\"\n\
    \  a_regex  <- gregexpr(\"a\", x)[1]\n  # return TRUE if y is contained by x\n\
    \  a <- y[a_regex]\n  return(a %in% x)", "\n    # split the first word into individual\
    \ characters\n    a_split <- strsplit(a, \"\")\n    # split the second word into\
    \ individual characters\n    b_split <- strsplit(b, \"\")\n    # initialize a\
    \ vector to hold a boolean indicating whether each character of the first word\
    \ is a substring of the character of the second word\n    check <- c()\n    #\
    \ loop over all characters in first word\n    for (i in 1:length(a)) {\n     \
    \   # if the current character of the second word is not equal to the current\
    \ character of the first word, return FALSE \n        if (b[i] != a[i]) return(FALSE)\n\
    \    }\n    # otherwise return TRUE\n    return(TRUE)\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=r,stringdist,string,pattern-matching,levenshtein-distance |>\n\
    The stringdist package is quite useful in this case. You need to use the pmatch\
    \ function. Here's a reproducible example:\n<code>\nrequire(stringdist)\nword1\
    \ <- c('abc','def','xyz','def')\nword2 <- c('abc','def','xyz','bcd')\npmatch(word1,word2,method\
    \ = 'lv')\n[1] FALSE FALSE FALSE FALSE\n</code>\nYou can see the different methods\
    \ here: http://cran.r-project.org/web/packages/stringdist/stringdist.pdf\n<|/\
    \ a dscore=3 |>\n<| c |>\n`pmatch` works great, but `stringdist::stringsim` has\
    \ some limitations: 1) `method = 'lv'` should match `word1` and `word2` only when\
    \ `word1` is rotated 90 degrees counterclockwise; 2) `method = 'nj'` should match\
    \ `word1` and `word2` only when both `word1` and `word2` are rotated 90 degrees\
    \ counterclockwise.\n<|/ c |>\n<| c |>\n: It would be nice if someone could contribute\
    \ an updated stringsim function which would support these additional criteria.\n\
    <|/ c |>\n<| a tags=r,stringdist,string,pattern-matching,levenshtein-distance\
    \ |>\nI took Riccardo's answer and extended it to allow for partial matching and\
    \ case-sensitivity using fuzzy matching.\n<code>\npmatch <- function(string1,\
    \ string2, method = \"lv\",\n                  case_sens = FALSE, partial = FALSE)\
    \ {\n  if(\"lv\" %in% method) {\n    result <- lapply(1:NROW(string1), function(i)\n\
    \      sapply(1:NROW(string2), function(j) {\n        min(\n          ifelse(\n\
    \            stringdist::stringsim(string", "\n  b <- gsub(\"[[:punct:]]\", \"\
    \", a)\n  a <- gsub(\"[[:punct:]]\", \"\", b)\n  c <- b %in% a\n  if (is.element(a,\
    \ a) && is.element(b, b)) {\n    c <- TRUE\n  }\n  return(c)\n}\n</code>\n<|/\
    \ a tags=r |>\n<| c |>\nI think this may have worked, but I still can't figure\
    \ out the last part to get the desired output. Here is a link to the original\
    \ problem http://www-stat.stanford.edu/~canzeh/courses/cps101/handouts/Handout-3-String-Matching.pdf\n\
    <|/ c |>\n<| c |>\n`c` needs to be a `logical` vector, not a `list` vector --\
    \ also, the `match` function returns integer indices for matches while `cycpattern_check`\
    \ returns a logical vector.  See the updates.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean about the match function and logicals vs. list vectors. I changed the output\
    \ to a logical vector but it returns all FALSE. I am not sure what is happening.\
    \ I am using the exact code you provided.\n<|/ c |>\n<| c |>\nI realized I forgot\
    \ to add `a` as a second argument.  See my updated answer.\n<|/ c |>\n<| c |>\n\
    I still get FALSE. I did notice that when I run cycpattern_check('a','a'), it\
    \ returns TRUE. Do you know why that could be?\n<|/ c |>\n<| a dscore=1 |>\nI\
    \ am not sure what output you are looking for, but here's a way to get it:\n<code>\n\
    library(stringr)\nstr_which(\"himenss\", \"i\")", "\n  sapply(strsplit(a, b),\
    \ function(x) grepl(x, strsplit(a, \"\")[[1]]))\n}\n", "\n  return(grepl(paste0(\"\
    (^|.*[[:space:]])\", a, \"($|[[:space:]]|.*)\"), b))\n}\n", "\n    i <- 0\n  \
    \  l <- length(a)\n    while(i < l) {\n        while(i < l && identical(a[i],\
    \ b[i])) i <- i + 1\n        i <- i + 1\n        while(i < l && identical(a[i],\
    \ b[i-l])) i <- i + 1\n        if(i >= l) return(FALSE)\n    }\n    return(TRUE)\n\
    }\n</code>\nThe algorithm is essentially a depth-first search of a substring in\
    \ the given string until it runs out of characters, checking each character against\
    \ the other. If all characters are equal to the substring, it returns TRUE. If\
    \ it finds some that aren't equal, it continues until the substring is found.\n\
    <|/ a tags=pattern-matching,r,string,pattern-matching |>\n<| c |>\nThanks for\
    \ your reply! Could you please explain what does `identical(a[i], b[i])` mean?\
    \ Why are we comparing each character separately?\n<|/ c |>\n<| c |>\nThe `identical()`\
    \ function checks for object identity. It returns a Boolean indicating whether\
    \ the two objects are identical. Two objects are identical if they are the same\
    \ exact object (same address in memory), or the result of coercing a character\
    \ vector into a character vector is the same as the original character vector\
    \ (which implies that they contain the same sequence of elements and are of equal\
    \ length). Otherwise `identical()` returns `FALSE`.\n<|/ c |>\n<| c |>\nThe same\
    \ is true of `identical(substitute(a), substitute(b))` which returns `true` if\
    \ `a` and `b` are the same, `substitute(a)` is a string with all the letters in\
    \ `a` translated into symbols that can be used when calling a function, `substitute(b)`\
    \ is a character vector containing all the letters in `b` translated into symbols.\n\
    <|/ c |>\n<| c |>\nAnd `identical(a[i], b[i-l])` checks whether the character\
    \ in `a[i]` is equal to `b[i-l]`. This happens when `i >= l`.\n<|/ c |>\n<| c\
    \ |>\nSorry, my mistake. I just realized that `identical(a[i], b[i-l])` would\
    \ evaluate to `FALSE` if `i >= l`, not `TRUE`.\n<|/ c |>\n<| a tags=pattern-matching,r,string,pattern-matching\
    \ |>\nHere is an R function that would do it for the first case:\n<code>\ncycpattern_check\
    \ <- function(a, b) {\n  i <- 0\n  lgth <- length(a)\n  while(i < lgth) {\n  \
    \  while(i < lgth && identical(a[i], b[i])) i <- i + 1\n    i <- i + 1\n    while(i\
    \ < ", "\n  any(grepl(a, tolower(b)))\n}\n\ncycpattern_check('himenss', 'simen')",
  "\n  \n  a <- tolower(a)\n  b <- tolower(b)\n  \n  a_sub <- strsplit(a, \" \")[[1]]\n\
    \  b_sub <- strsplit(b, \" \")[[1]]\n  \n  a_rot <- unlist(strsplit(a, \"\", fixed\
    \ = TRUE))\n  b_rot <- unlist(strsplit(b, \"\", fixed = TRUE))\n  \n  a_rot_len\
    \ <- length(a_rot)\n  b_rot_len <- length(b_rot)\n  \n  \n  \n  a_sub_ind <- which(a_sub\
    \ %in% b_sub)\n  b_sub_ind <- which(b_sub %in% a_sub)\n  \n  a_rot_ind <- which(a_rot\
    \ == b_rot)\n  b_rot_ind <- which(b_rot == a_rot)\n  \n  a_rot_sub_ind <- which(a_sub_ind\
    \ %in% b_rot_ind)\n  b_rot_sub_ind <- which(b_sub_ind %in% a_rot_ind)\n  \n  a_rot_sub\
    \ <- a_sub[a_sub_ind %in% b_rot_sub_ind]\n  b_rot_sub <- b_sub[b_sub_ind %in%\
    \ a_rot_sub_ind]\n  \n  a_sub_rot <- a_rot[a_rot_ind %in% b_rot_sub_ind]\n  b_sub_rot\
    \ <- b_rot[b_rot_ind %in% a_rot_sub_ind]\n  \n  \n  a_rot_sub_rot <- a_sub_rot[a_rot_sub_ind\
    \ %in% b_rot_len]\n  b_rot_sub_rot <- b_sub_rot[b_rot_sub_ind %in% a_rot_len]\n\
    \  \n  \n  \n  \n  \n  return(all(\n    a_sub_rot == b_sub_rot,\n    b_rot_sub_rot\
    \ == a_rot_sub_rot,\n    all(a_rot_sub_rot == b_rot_sub_rot)\n  ))\n  \n  \n}\n\
    </cell>\n<text>\nQuestion 4\n\n</text>\n<cell>", "\n  # split the strings by spaces\
    \ and check for substring in second string\n  a1 <- unlist( strsplit(a, split\
    \ = \" \") )\n  b1 <- unlist( strsplit(b, split = \" \") )\n  any( sapply( 1:(length(a1)\
    \ + length(b1) - 1), function(i) identical( a1[-i],b1[-i]) ) )\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nHi, thanks for the fast response. Sorry I forgot to\
    \ mention that, I just edited the main post. Actually the thing I wanted to do\
    \ is more like \"cyclomatic complexity\" but I dont know if it is possible. Let\
    \ me know if you have any other ideas. Thank you :)\n<|/ c |>\n<| c |>\nHi again,\
    \ this seems to work but I dont think it is efficient, since the complexity is\
    \ O(n^2) where n is the length of first string and n is the length of second string.\
    \ Thank you so much anyway :)\n<|/ c |>\n<| c |>\nYou're welcome. I added a O(n)\
    \ solution but I'm curious to see if there is a better one. Thanks.\n<|/ c |>\n\
    <| c |>\nHi again, I think this is a good solution (though not O(n)). It is probably\
    \ the fastest since it is O(n) time and O(n) space but it might be that there\
    \ is a way to make it even faster by using loops etc so that it is O(n^2) complexity.\
    \ I would really appreciate any help :)\n<|/ c |>\n<| c |>\nI added another O(n)\
    \ solution but I'm still curious to see if there is any other better one. Thanks.\n\
    <|/ c |>\n<| a dscore=1 |>\nIf you want the number of different words that can\
    \ be formed, here is a simple way to do it.\n<code>\nmyString <- \"hello how are\
    \ you\"\nlibrary(stringr)\nstr_count(myString, \" \")\n\n[1] 3\n</code>\nIf you\
    \ want a vector containing all the different words, here's an option:\n<code>\n\
    myString <- \"hello how are you\"\nlibrary(stringr)\nstr_split(myString, \" \"\
    , simplify = TRUE)\n</code>\n<|/ a tags=string,algorithm,r,pattern-matching |>\n\
    <| a |>\nI propose the following R solution:\n<code>", "\n  # Your code goes here\n\
    \  # ifelse(\n  for(i in seq_along(a)){\n    b <- paste(b, a[-i], sep=\"\")\n\
    \    if(length(strsplit(b, \"\")[[1]]) %in% strsplit(a, \"\")[[1]])\n      return(TRUE)\n\
    \  }\n  return(FALSE)\n}\n</code>\n<|/ a tags=pattern-matching,string,r |>\n<|\
    \ c |>\nYour approach is great, but I'm only interested in substring matches.\
    \ In other words, I don't care if the string \"ab\" is in the string \"abc\",\
    \ or if the substring \"ab\" is at the start or end of a string, and I want to\
    \ know if the word \"ab\" appears anywhere in the string. Thanks!\n<|/ c |>\n\
    <| c |>\n, I've updated my answer to accommodate your new constraints. Please\
    \ feel free to let me know if it doesn't work perfectly.\n<|/ c |>\n<| c |>\n\
    Thanks for your help! However, I think your approach would return FALSE for strings\
    \ such as \"abca\". It does so because stringsplit() returns more than a single\
    \ word. Would you happen to know a way of making your approach work for this scenario?\
    \ Thanks again!\n<|/ c |>\n<| c |>\n, I've updated my answer to allow for strings\
    \ with more than one word. I tested it and it works.\n<|/ c |>\n<| c |>\nYou're\
    \ absolutely right! It works perfectly! Thanks so much!\n<|/ c |>\n<| a |>\nIf\
    \ you have the stringr package installed, you could use str_extract_all. Here\
    \ is a solution with the stringr package and dplyr. It checks if any element from\
    \ the list returned is in your string. \n<code>\nlibrary(stringr)\nlibrary(dplyr)\n\
    \ncycpattern_check <- function(a, b) {\n  if(length(strsplit(a, \"\")[[1]]) >1)\
    \ {\n    str_extract_all(b,str_c(a, '|', sep = \"\"))[[1]] %>% \n      map_lgl(~\
    \ any(str_detect(.x, b)))\n  } else\n    any(str_detect(b, a))\n}\n</code>\nFor\
    \ your test cases:\n<code>\ncycpattern_check('abcc', 'abd')", "\n  # Find length\
    \ of the string\n  length_a <- nchar(a)\n  length_b <- nchar(b)\n\n  # Initialize\
    \ output variables\n  output_a <- NULL\n  output_b <- NULL\n\n  # Check each character\
    \ from both strings\n  for (j in 1:length_a) {\n    for (k in 1:length_b) {\n\
    \      # Check for substring in second string\n      if (substr(b, k, 1) %in%\
    \ substr(a, b, j)) {\n        # Flag output string\n        output_b <- TRUE\n\
    \        break\n      } else output_b <- FALSE\n\n      # Check for substring\
    \ in first string\n      if (substr(a, j, 1) %in% substr(a, b, k)) {\n       \
    \ # Flag output string\n        output_a <- TRUE\n        break\n      } else\
    \ output_a <- FALSE\n    }\n\n    # Check if output strings exist, break if they\
    \ do not\n    if (output_a & output_b) {\n      break\n    } else output_a <-\
    \ output_b <- FALSE\n  }\n\n  # Return TRUE or FALSE\n  return(output_a & output_b)\n\
    }\n</code>\n<|/ a tags=r,string,substring |>\n<| c |>\nThanks for you answer,\
    \ but this doesn't do what the OP needs. It returns TRUE even if both strings\
    \ are identical (`cycpattern_check('a', 'a')` is `TRUE`).\n<|/ c |>\n<| c |>\n\
    I edited my post. Please check it.\n<|/ c |>\n<| c |>\nThe output is different\
    \ from the OP's desired output because you're checking for `substring` equality\
    \ between the two strings. It should be `substring` substring matching between\
    \ the two strings.\n<|/ c |>\n<| c |>\nI realized that and changed it accordingly.\
    \ Thanks\n<|/ c |>\n<| a tags=r,string,substring dscore=0 |>\nA short one liner\
    \ with gregexpr and regmatches:\n<code>\ngregexpr(\"\\\\b[[:alpha:]]+\\\\b\",\
    \ df$string1, ignore.case=TRUE)\n</code>\n<|/ a |>\n<| a tags=r,string,substring\
    \ |>\nA simple function to check if any substring is in a given string is as follows:\n\
    <code>\n any_substring_in <- function(x,y){\n  \n  for(i in seq_along(y)){\n \
    \   \n    if(grepl(y[i], x)){\n      return (TRUE)\n    }\n  }\n  \n  (FALSE)\n\
    }\n\nany_substring_in(\"hello world\", \"hell\") #True\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=r,string,substring dscore=0 |>\nHere's a similar ", "\n  b <-\
    \ tolower(b)\n  a1 <- strsplit(a, \"\")[[1]]\n  b1 <- strsplit(b, \"\")[[1]]\n\
    \  n <- length(a1)\n  m <- length(b1)\n  i <- 0\n  j <- 0\n  done <- FALSE\n \
    \ res <- FALSE\n  while (i < n && j < m) {\n    if (a1[i] == b1[j]) {\n      i\
    \ <- i + 1\n      j <- j + 1\n    } else if (a1[i] == b1[j + 1]) {\n      i <-\
    \ i + 1\n      j <- j + 2\n    } else if (a1[i + 1] == b1[j]) {\n      i <- i\
    \ + 2\n      j <- j + 1\n    } else {\n      i <- i + 1\n      j <- j + 1\n  \
    \  }\n    if (i == n) {\n      done <- TRUE\n      break\n    }\n  }\n  return(done)\n\
    }\n</cell>\n<cell>", "\n    ans <- ifelse(length(a) == 0 || length(b) == 0, TRUE,\
    \ FALSE)\n    if(length(grep(b, a)) != 0) {\n        ans <- FALSE\n    }\n   \
    \ return(ans)\n}\n", "\n  b <- toupper(b)\n  a <- tolower(a)\n  a <- strsplit(a,\
    \ \"\")[[1]]\n  b <- strsplit(b, \"\")[[1]]\n  n <- length(a)\n  p <- length(b)\n\
    \  a <- setdiff(seq_along(a), which(b %in% a))\n  a <- lengths(stringdistmatrix(a,\
    \ b, method = \"lv\"))\n  return(max(abs(n-1L - a)))\n}\n</cell>\n<text>\nCyclic\
    \ Pattern\nThe Cyclic Pattern problem is considered in computer science as a problem\
    \ that arises when we attempt to solve a problem in which the input is cyclic.\
    \ In this problem, the length of the input is equal to the length of the output.\
    \ For example, the output is 'abc' but you are given 'abcabcabc'. Write a function\
    \ that checks if the input is a cyclic pattern or not. For the below questions,\
    \ your output is the one marked as correct. Also, your solution should contain\
    \ all of your code from your initial problem. Do not delete the function you wrote\
    \ to determine if the input is a cyclic pattern.\n\n\n</text>\n<cell>", "\n  x\
    \ <- strsplit(a, \"\")[[1]]\n  y <- strsplit(b, \"\")[[1]]\n  n <- length(x)\n\
    \  p <- length(y)\n  o <- n %/% p\n  if (length(x) == 1) {\n    return(TRUE)\n\
    \  }\n  else if (length(y) == 1) {\n    return(TRUE)\n  }\n  else if (n == 1)\
    \ {\n    return(TRUE)\n  }\n  else if (o == 1) {\n    return(FALSE)\n  }\n  else\
    \ if (o > 1) {\n    s <- strsplit(b, \"\")[[1]]\n    for(i in 1:(o-1)) {\n   \
    \   x <- c(x, rep(NA, p-i))\n      s <- c(s, rep(NA, p-i))\n    }\n    y <- y[s]\n\
    \    x <- x[-o]\n    i <- 1\n    while(i <= n) {\n      if(length(x) == 1) {\n\
    \        return(TRUE)\n      }\n      else if(length(y) == 1) {\n        return(TRUE)\n\
    \      }\n      else if(i == n) {\n        return(TRUE)\n      }\n      else {\n\
    \        i <- i + 1\n        if(str_detect(x, paste(y, collapse=\"|\"))) {\n \
    \         return(TRUE)\n        }\n      }\n    }\n  }\n  else {\n    for(i in\
    \ 1:p) {\n      x <- c(x, rep(NA, o-i))\n      y <- c(y, rep(NA, o-i))\n    }\n\
    \    x <- x[-p]\n    y <- y[-p]\n    for(i in 1:n) {\n      if(length(x) == 1)\
    \ {\n        return(TRUE)\n      }\n      else if(length(y) == 1) {\n        return(TRUE)\n\
    \      }\n      else if(i == n) {\n        return(TRUE)\n      }\n      else {\n\
    \        x <- c(x, rep(NA, p-i))\n        y <- c(y, rep(NA, p-i))\n      }\n \
    \   }\n  }\n}\n</code>\n<|/ a tags=r,string,regex |>\n<| c |>\nIt may fail when\
    \ words are of length 1. A more robust version is here https://stackoverflow.com/a/56405886/3025494\n\
    <|/ c |>\n<| a |>\nHere is a short function that gives the expected result with\
    \ your examples:\n<code>\ncycpattern_check<-function(x,y){\n     #check length\
    \ of x and y\n     n<-length(x)\n     p<-length(y)\n     #check which cases are\
    \ necessary\n     o<-ifelse(n %in% c(1,2),\n              ifelse(p %in% c(1,2),T,F),\n\
    \              ", "\n  b_rot <- apply(rotation(b, 2), 2, paste, collapse = \"\"\
    )\n  b_rot_len <- nchar(b_rot)\n  if (length(grep(a, a, fixed = TRUE)) > 0) {\n\
    \    b_rot_len <- length(grep(a, a, fixed = TRUE))\n  }\n  if (b_rot_len > 0)\
    \ {\n    b_rot <- b_rot[-b_rot_len]\n  }\n  a <- substring(a, 1:(nchar(a) - length(b_rot)))\n\
    \  b_rot_len <- nchar(a)\n  b_rot <- b_rot[-b_rot_len]\n  b_rot_len <- nchar(b)\n\
    \  b_rot <- b_rot[-b_rot_len]\n  a <- gsub(a, b_rot, a, fixed = TRUE)\n  if (nchar(a)\
    \ > 0) {\n    b <- substring(b, 1:(nchar(b) - length(b_rot)))\n    b_rot_len <-\
    \ nchar(b)\n    b_rot <- b_rot[-b_rot_len]\n    a <- gsub(a, b_rot, b, fixed =\
    \ TRUE)\n    b_rot_len <- nchar(b)\n    b_rot <- b_rot[-b_rot_len]\n  }\n  if\
    \ (nchar(a) == 0) {\n    a_len <- nchar(a)\n    b_rot_len <- nchar(b)\n    a_len\
    \ <- a_len - b_rot_len\n    b_rot <- b_rot[-b_rot_len]\n    a <- a[a_len]\n  \
    \  b_rot_len <- nchar(b)\n    b_rot <- b_rot[-b_rot_len]\n  }\n  a <- substring(a,\
    \ 1:(nchar(a) - length(b_rot)))\n  b_rot_len <- nchar(b)\n  b_rot <- b_rot[-b_rot_len]\n\
    \  a <- gsub(a, b_rot, b, fixed = TRUE)\n  b_rot_len <- nchar(b)\n  b_rot <- b_rot[-b_rot_len]\n\
    \  b <- substring(b, 1:(nchar(b) - length(b_rot)))\n  b_rot_len <- nchar(b)\n\
    \  b_rot <- b_rot[-b_rot_len]\n  b <- gsub(b, b_rot, b, fixed = TRUE)\n  b_rot_len\
    \ <- nchar(b)\n  b_rot <- b_rot[-b_rot_len]\n  return(a != b)\n}\n</code>\n<|/\
    \ a dscore=0 tags=r |>\n<| a |>\nI wrote this function to check whether a word\
    \ is a ", "\n  \n  # Initialize pattern vector\n  pattern <- c()\n  \n  # Step\
    \ through all rotations \n  for(i in 1:(length(b) - length(a))) \n  {\n    # Add\
    \ next pattern to pattern vector\n    pattern[i] <- paste0(a, rep(b[i], length(a)))\n\
    \  }\n  \n  # Test pattern against first word\n  if(b[length(b)] == a) \n  {\n\
    \    cat(\"TRUE\\n\")\n    return(TRUE)\n  } \n  \n  # Check if pattern matches\
    \ patterns of first word + remaining letters\n  if(!any(grepl(pattern, a)))\n\
    \  {\n    cat(\"FALSE\\n\")\n    return(FALSE)\n  }\n}\n</code>\n<|/ a tags=string,r,pattern-matching,data-cleaning\
    \ |>\n<| a |>\n<code>\nlibrary(stringr)\n\nstr <- \"abcdef\"\nstr2 <- \"aabcde\"\
    \n\nstr2 %in% str", "\n  s1 <- strsplit(a, \"\")[[1]]\n  s2 <- strsplit(b, \"\"\
    )[[1]]\n  s1b <- toupper(s1)\n  s2b <- toupper(s2)\n  s1b <- c(s1b, c(\"\", s2b[-length(s1b)]))\n\
    \  s2b <- c(s2b, c(\"\", s1b[-length(s2b)]))\n  intersect(toupper(s1b), toupper(s2b))\n\
    }\n</code>\n<|/ a tags=r,regex |>\n<| a dscore=0 |>\nI suggest you try stringi\
    \ instead of regex. \n<code>\n> library(stringi)\n> str1 <- \"aaabbbcccddd\"\n\
    > str2 <- \"aabbccdd\"\n> stri_sub(str1,stri_locate_all_regex(str1,\"[abc]\"),stri_locate_all_regex(str1,\"\
    [abc]\"))\n[1] \"cccddd\"\n> stri_sub(str2,stri_locate_all_regex(str2,\"[abc]\"\
    ),stri_locate_all_regex(str2,\"[abc]\"))\n[1] \"cccdd\"\n</code>\n<|/ a tags=r,regex\
    \ |>\n<| a tags=r,regex |>\n<code>\ncycpattern <- function(x, pattern) {\n  require(stringr)\n\
    \  sapply(strsplit(x, \"\"), grepl, pattern)\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nYou don't need the `toUpper` call because `strsplit` converts all its\
    \ arguments to lower-case.\n<|/ c |>\n<| a |>\nI tried to find a solution in R\
    \ that does not use loops and I haven't found one that does the job without looping\
    \ too. So I came up with my own solution. \n<code>\ncycpattern_check<-function(a,\
    \ b)\n{\n  s1 <- strsplit(a, \"\")[[1]]\n  s2 <- strsplit(b, \"\")[[1]]\n  intersect(toupper(s1),\
    \ toupper(s2))\n}\n</code>\nThis does the job by looping through each possible\
    \ sub-string of the original string and comparing it to the new string.\n<|/ a\
    \ tags=r,regex dscore=0 |>\n<| c |>\nNice solution, but you could just use mapply\
    \ rather than a loop. I doubt the performance difference would be noticable, but\
    \ I suppose the loop is probably more clear.\n<|/ c |>\n<| c |>\nOh, and you don't\
    \ need the toUpper call because strsplit converts all its arguments to lower-case.\n\
    <|/", "\n  a <- toupper(a)\n  b <- toupper(b)\n  \n  a <- a[-length(a)]\n  b <-\
    \ b[-length(b)]\n  \n  a <- stringr::str_subset(a, b)\n  b <- stringr::str_subset(b,\
    \ a)\n  \n  !length(which(a %in% b)) == length(which(a %in% b))\n}\n", "\n   \
    \ paste(toupper(substring(strsplit(a, \"\")[[1]], 1,\n                       \
    \ nchar(a) - 1)), collapse=\"\") %in%\n        paste(toupper(substring(strsplit(b,\
    \ \"\")[[1]], 1,\n                        nchar(b) - 1)), collapse=\"\") &\n \
    \       paste(toupper(substring(strsplit(a, \"\")[[1]], nchar(a),\n          \
    \              nchar(a) + 1)), collapse=\"\") %in%\n        paste(toupper(substring(strsplit(b,\
    \ \"\")[[1]], nchar(b),\n                        nchar(b) + 1)), collapse=\"\"\
    ) &\n        paste(toupper(substring(strsplit(a, \"\")[[1]], 1,\n            \
    \            nchar(a) - 1)), collapse=\"\") %in%\n        paste(toupper(substring(strsplit(b,\
    \ \"\")[[1]], nchar(b),\n                        nchar(b) + 1)), collapse=\"\"\
    ) &\n        paste(toupper(substring(strsplit(a, \"\")[[1]], nchar(a),\n     \
    \                   nchar(a) + 1)), collapse=\"\") %in%\n        paste(toupper(substring(strsplit(b,\
    \ \"\")[[1]], 1,\n                        nchar(b) - 1)), collapse=\"\") &\n \
    \       paste(toupper(substring(strsplit(a, \"\")[[1]], nchar(a),\n          \
    \              nchar(a) + 1)), collapse=\"\") %in%\n        paste(toupper(substring(strsplit(b,\
    \ \"\")[[1]], nchar(b),\n                        nchar(b) + 1)), collapse=\"\"\
    ) &\n        paste(toupper(substring(strsplit(a, \"\")[[1]], 1,\n            \
    \            nchar(a) - 1)), collapse=\"\") %in%\n        paste(toupper(substring(strsplit(b,\
    \ \"\")[[1]], nchar(b),\n                        nchar(b) + 1)), collapse=\"\"\
    ) &\n        paste(toupper(substring(strsplit(a, \"\")[[1]], nchar(a),\n     \
    \                   nchar(a) + 1)), collapse=\"\") %in%\n        paste(toupper(substring(strsplit(b,\
    \ \"\")[[1]], 1,\n                        nchar(b) - 1)), collapse=\"\") &\n \
    \       paste(toupper(substring(strsplit(a, \"\")[[1]], 1,\n                 \
    \       nchar(a) - 1)), collapse=\"\") %in%\n        paste(toupper(substring(strsplit(b,\
    \ \"\")[[1]], nchar(b),\n                        nchar(b) + 1)), collapse=\"\"\
    ) &\n        paste(toupper(substring(strsplit(a, \"\")[[1]], nchar(a),\n     \
    \                   nchar(a) + 1)), collapse=\"\") %in%\n        paste(to", "\n\
    \  a <- tolower(a)\n  b <- tolower(b)\n  \n  a_str <- strsplit(a, \"\")[[1]]\n\
    \  b_str <- strsplit(b, \"\")[[1]]\n  \n  a_str_rotations <- strsplit(paste(rev(a),\
    \ rev(unlist(strsplit(rev(a), \"\"))), collapse = \"\"), \"\")[[1]]\n  b_str_rotations\
    \ <- strsplit(paste(rev(b), rev(unlist(strsplit(rev(b), \"\"))), collapse = \"\
    \"), \"\")[[1]]\n  \n  if(cycpattern_match(a_str, b_str, a_str_rotations, b_str_rotations))\
    \ {\n    TRUE\n  } else {\n    FALSE\n  }\n}\n", "\n  if (any(grepl(b, a))) {\n\
    \    return(TRUE)\n  }\n  else {\n    for (i in 1:(length(a) - length(b))) {\n\
    \      if (substr(a, i, i + length(b)) %in% b) {\n        return(TRUE)\n     \
    \ }\n    }\n  }\n  return(FALSE)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ solution works for most cases, but it is slow for large input strings and also\
    \ for inputs with repeated substrings (eg: `'abaabcba'`). To speed it up further,\
    \ one may use the following variant (slightly faster) which only checks the last\
    \ character of `a` and `b`. See my [answer](https://stackoverflow.com/a/58454292/496488)\
    \ for more details.\n<|/ c |>\n<| a |>\nThe answer by is a little slow for large\
    \ inputs. Here is an improved variant:\n<code>\ncycpattern_check2 <- function(a,\
    \ b) {\n    lengtha <- nchar(a)\n    lengthb <- nchar(b)\n    ab <- seq(lengtha)[-lengthb]\n\
    \    ab <- paste0(ab, b)\n    length(grep(ab, a)) != 0\n}\n</code>\nFor large\
    \ inputs the above function can be significantly improved by replacing the calls\
    \ to nchar and substring with calls to gsub and the stringr package.\n<code>\n\
    cycpattern_check2 <- function(a, b) {\n    lengtha <- stringr::str_length(a)\n\
    \    lengthb <- stringr::str_length(b)\n    ab <- stringr::str_sub(seq(lengtha),\
    \ -lengthb)\n    ab <- stringr::str_paste(ab, b)\n    stringr::str_count(a, ab)\
    \ != 0\n}\n</code>\n<|/ a tags=r,string dscore=2 |>\n<| a dscore=1 |>\nBased on\
    \ previous answers and comments, here is a more efficient version that avoids\
    \ regex altogether.\n<code>\ncycpattern_check2 <- function(a, b) {\n    lengtha\
    \ <- nchar(a)\n    lengthb <- nchar(b)\n    ab <- seq(lengtha)[-lengthb]\n   \
    \ ab <- paste0(ab, b)\n    ab <- paste0(ab, collapse = \"|\")\n    length(grep(ab,\
    \ a)) != 0\n}\n</code>\n<|/ a tags=r,string |>\n<| c |>\nThanks for your suggestion.\
    \ I modified it a little (changed `lengtha` to `stringr::str_length(a)` and `",
  "\n  if(nchar(b) == 0) {\n    return (cycpattern_check(a, tail(a, nchar(a) - 1)))\
    \ \n  } else if(nchar(a) == 0) {\n    return (cycpattern_check(tail(b, nchar(b)\
    \ - 1), a))\n  } else {\n    return (length(intersect(tolower(a), tolower(b))\
    \ > 0) > 0)\n  }\n}\n", "\n  # remove substring from string 2\n  a_r <- a[seq_along(gregexpr(b,\
    \ \"a\", fixed = TRUE)$values)]\n  b_r <- b[seq_along(gregexpr(a, \"r\", fixed\
    \ = TRUE)$values)]\n\n  return(ifelse(grepl(a_r, b_r), TRUE, FALSE))\n}\n", "\n\
    \  d <- str_count(a, paste0(\"(\", paste0(tail(strsplit(b, \"\")[[1]], 2), collapse=\"\
    |\"), \")\"))\n  any(d > 0) || any(str_subset(a, paste0(tail(strsplit(b, \"\"\
    )[[1]], 2), collapse=\"|\")) > 0)\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nCan\
    \ you please explain how this works?\n<|/ c |>\n<| c |>\nYes, I've added some\
    \ explanations.\n<|/ c |>\n<| c |>\nThank you so much!\n<|/ c |>\n<| a |>\nHere\
    \ is another possible solution:\n<code>\ncycpattern_check <- function(string1,\
    \ string2){\n    str_count(string1, paste0(\"(\", string2, \")\")) > 0 |\n   \
    \     str_count(string1, string2) > 0\n}\n\ncycpattern_check(\"apple\", \"leppa\"\
    )", "\n  n <- nchar(a)\n  m <- nchar(b)\n  a1 <- substring(trimws(a), 1, 1)\n\
    \  b1 <- substring(trimws(b), 1, 1)\n  s1 <- substring(trimws(paste(a1, rep(\"\
    \", m-2), sep=\"\")), 1, 1)\n  s2 <- substring(trimws(paste(a1, rep(\"\", m-2),\
    \ sep=\"\")), 2, n-1)\n  s3 <- substring(trimws(paste(a1, rep(\"\", m-2), sep=\"\
    \")), n-1, n-1)\n  s4 <- substring(trimws(paste(a1, rep(\"\", m-2), sep=\"\")),\
    \ n-1, n-1)\n  ifelse(\n    a1 == b1,\n    TRUE,\n    ifelse(\n      a1 == s1\
    \ & s1 == s2 & s2 == s3 & s3 == s4 & s4 == \"\",\n      TRUE,\n      FALSE\n \
    \   )\n  )\n}\n", "\n  a <- unlist(strsplit(a,''))\n  b <- unlist(strsplit(b,''))\n\
    \  a <- c(t(rbind(rep(NA,(length(a)-2)),rep(0,2),rep(0,(length(a)-2)))));a\n \
    \ b <- c(t(rbind(rep(NA,(length(b)-2)),rep(0,2),rep(0,(length(b)-2)))));b\n  b\
    \ <- b[-length(b)]\n  if(a==b){\n    return(TRUE)\n  }else{\n    y <- a[which(match(unlist(a),unlist(b))>0)]\n\
    \    for(i in 1:(length(a)-length(b))+1){\n      y <- ifelse(length(which(match(a[i:(i+length(b))],y)>0))>0,TRUE,FALSE)\n\
    \    }\n    return(y)\n  }\n}\n", "\n  ifelse(grepl(b, a),\n         TRUE,\n \
    \        FALSE)\n}\n</code>\n<|/ a tags=r,regex |>\n<| a tags=r,regex |>\nFor\
    \ a fixed pattern of strings with no repeated strings you can try with gsubfn\
    \ :\n<code>\nlibrary(gsubfn)\n\ngsubfn(\"^.*?(?=.)\", str1, str2)", "\n  # a is\
    \ shorter than b\n  if (length(a) < length(b)) {\n    return(FALSE)\n  }\n  #\
    \ a is longer than b\n  if (length(a) > length(b)) {\n    return(FALSE)\n  }\n\
    \  # a contains b\n  return(grepl(b, a))\n}\n</code>\nTo test your code, I wrote\
    \ a couple test strings:\n<code>\na <- c('ab', 'abc', 'abcd', 'abd', 'abcde',\
    \ 'abdde', 'acde')\nb <- c('abc', 'abcd', 'abd', 'abde', 'acde', 'abdde', 'abcde')\n\
    </code>\nAnd I ran:\n<code>\n> cycpattern_check(a, b)\n[1]  TRUE  TRUE  TRUE FALSE\
    \ FALSE  TRUE FALSE\n</code>\nI used grep to find matches, and grepl to test if\
    \ a string contains another string:\n<code>\ngrep(b, a, value = TRUE)\n[1] \"\
    abcd\" \"abdde\" \"abcde\" \"abdde\"\ngrepl(b, a)\n[1]  TRUE  TRUE  TRUE FALSE\
    \ FALSE  TRUE FALSE\n</code>\n<|/ a tags=pattern-matching,string,r,string dscore=3\
    \ |>\n<| c |>\nThanks for your answer but when I ran your code I got this error\
    \ `Error in file(con, \"r\") : invalid 'description' argument`\n<|/ c |>\n<| c\
    \ |>\nI ran my code with my test strings and it worked for me.\n<|/ c |>\n<| c\
    \ |>\nI see what happened. It seems like there are some empty strings in my original\
    \ dataframe. I am trying this `apply(df[,col], 2, function(x) cycpattern_check(paste(tolower(x),\
    \ collapse = ''), tolower(paste(tolower(x), collapse = ''))))`\n<|/ c |>\n<| c\
    \ |>\nThat should fix it.  You should be able to wrap the `tolower` call in `paste`\
    \ so that you don't have to repeat it each time.\n<|/ c |>\n<| a dscore=2 tags=pattern-matching,string,r,string\
    \ |>\nOne solution is to use str_extract, which is a base R function that extracts\
    \ sub-strings from a string. \n<code>\nstr_extract(string, pattern)\n</code>\n\
    The example below demonstrates how it can be used. \n<code>\nlibrary(stringr)\n\
    str_extract(c('abced','abcfg','abcfj','abcfk','abcfn','abcff','abcfi'),\n    \
    \         '[abced]')\n\n[1] \"abced\"  \"", "\n  a <- stringr::str_to_lower(a)\n\
    \  b <- stringr::str_to_lower(b)\n  \n  a <- stringr::str_replace_all(a, \"[[:punct:]]\"\
    , \"\")\n  b <- stringr::str_replace_all(b, \"[[:punct:]]\", \"\")\n  \n  a <-\
    \ stringr::str_replace_all(a, \"[a-z]\", \"\") \n  b <- stringr::str_replace_all(b,\
    \ \"[a-z]\", \"\")\n  \n  a <- stringr::str_replace_all(a, \"[^[:alpha:][:space:]]\"\
    , \"\")\n  b <- stringr::str_replace_all(b, \"[^[:alpha:][:space:]]\", \"\")\n\
    \  \n  a <- stringr::str_replace_all(a, \"[[:digit:]]\", \"\")\n  b <- stringr::str_replace_all(b,\
    \ \"[[:digit:]]\", \"\")\n  \n  a <- stringr::str_replace_all(a, \"[[:upper:]]\"\
    , \"\")\n  b <- stringr::str_replace_all(b, \"[[:upper:]]\", \"\")\n  \n  a <-\
    \ stringr::str_replace_all(a, \"[[:lower:]]\", \"\")\n  b <- stringr::str_replace_all(b,\
    \ \"[[:lower:]]\", \"\")\n  \n  a <- stringr::str_replace_all(a, \"[[:upper:]]\"\
    , \"\")\n  b <- stringr::str_replace_all(b, \"[[:upper:]]\", \"\")\n  \n  a <-\
    \ stringr::str_replace_all(a, \"[[:alpha:]]\", \"\")\n  b <- stringr::str_replace_all(b,\
    \ \"[[:alpha:]]\", \"\")\n  \n  a <- stringr::str_replace_all(a, \"[[:space:]]\"\
    , \"\")\n  b <- stringr::str_replace_all(b, \"[[:space:]]\", \"\")\n  \n  a <-\
    \ stringr::str_replace_all(a, \"[[:digit:]]\", \"\")\n  b <- stringr::str_replace_all(b,\
    \ \"[[:digit:]]\", \"\")\n  \n  a <- stringr::str_replace_all(a, \"[[:punct:]]\"\
    , \"\")\n  b <- stringr::str_replace_all(b, \"[[:punct:]]\", \"\")\n  \n  a <-\
    \ paste0(a, \"$\") \n  b <- paste0(b, \"$\")\n  \n  a <- strsplit(a, \"\\\\$\"\
    )\n  b <- strsplit(b, \"\\\\$\")\n  ", "\n    b <- tolower(b)\n    a <- tolower(a)\n\
    \    for (i in seq_along(a)) {\n        x <- substr(a, i, i)\n        for (j in\
    \ seq_along(b)) {\n            y <- substr(b, j, j)\n            x <- paste(x,\
    \ y, sep = '')\n            if (x == y) {\n                return (TRUE)\n   \
    \         }\n        }\n    }\n    return (FALSE)\n}\n</code>\n<|/ a dscore=1\
    \ tags=r,substring,string |>\n<| c |>\nThis answer should be marked as correct.\n\
    <|/ c |>\n<| a tags=r,substring,string |>\nHere's one possible approach:\n<code>\n\
    cycpattern_check = function(x, y) {\n    any(grepl(y, strsplit(x, \"\")[[1]]))\n\
    }\n\ncycpattern_check(\"himenss\", \"simen\")\n[1] FALSE\n</code>\nThe idea is\
    \ to first split each string into characters and then match each element of y\
    \ against each element of x.\n<|/ a dscore=1 |>\n<| a |>\nYou could also use the\
    \ stringi package:\n<code>\ncycpattern_check = function(x, y) {\n    stri_match_all(x,\
    \ stri_trans_tolower(y)) > 0\n}\n</code>\n<|/ a dscore=1 tags=r,substring,string\
    \ |>\n<| a dscore=0 |>\nYou could do this\n<code>\ncycpattern_check<- function(a,b)\n\
    {\n  a<-tolower(a)\n  b<-tolower(b)\n  for(i in 1:length(a))\n  {\n    if(a[i]==b[i])\n\
    \    {\n      return(TRUE)\n    }\n    else\n    {\n      if(a[i]!=b[i])\n   \
    \   {\n        j <-which(a[i]==a[i])\n        if(length(a)-j>0)\n        {\n \
    \         if(a[i]==substr(b,j,j))\n          {\n            return(TRUE)\n   \
    \       }\n        }\n      }\n    }\n  }\n  return(FALSE)\n}\n</code>\n<|/ a\
    \ tags=r,substring,string |>\n<| c |>\nThank you for your help, your answer also\
    \ works very well. Since I posted my question, I changed my approach a little\
    \ bit, and I decided to make use of grep and strsplit. Thanks again!\n<|/ c |>\n\
    <| a tags=r,substring,string |>\n<code>\ncycpattern_check<- function(a,b)\n{\n\
    \  a<-tolower(a)\n  b<-tolower(b)\n  for(i in 1:length(a))\n  {\n    if(a[i]==b[i])\n\
    \    {\n", "\n  return(grepl(b, a))\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    For a case like 'whassup', 'psus', the first letter 'a' is not rotated (it stays\
    \ at 'a'). This is not correct.\n<|/ c |>\n<| a tags=r,algorithm,string |>\nThis\
    \ can be done using grepl:\n<code>\ncycpattern_check <- function(a, b) {\n  grepl(b,\
    \ a)\n}\n</code>\nThis will check whether b is contained in a. For example:\n\
    <code>\ncycpattern_check(\"ab\", \"ba\")", "\n    n <- length(a)\n    m <- length(b)\n\
    \    \n    i <- 0\n    k <- 0\n    while(i < n && k < m) {\n        if(a[i] ==\
    \ b[k]) {\n            k <- k + 1\n        }\n        else {\n            i <-\
    \ i + 1\n        }\n    }\n    \n    if(i == n) {\n        return (FALSE)\n  \
    \  }\n    else {\n        i <- i + 1\n        k <- k - 1\n        while(i < n\
    \ && k >= 0) {\n            if(a[i] == b[k]) {\n                i <- i + 1\n \
    \               k <- k - 1\n            }\n            else {\n              \
    \  return (FALSE)\n            }\n        }\n        \n        if(k >= 0) {\n\
    \            return (TRUE)\n        }\n        else {\n            return (FALSE)\n\
    \        }\n    }\n}\n</code>\n<|/ a |>\n<| c |>\n`any(sapply(a, grepl, b, fixed=TRUE))`\n\
    <|/ c |>\n<| c |>\nNice one, but I think you should use `any(sapply(a, grepl,\
    \ b, fixed=TRUE))` instead of `any` because grepl is vectorized.\n<|/ c |>\n<|\
    \ c |>\nOops, I missed that - thanks for bringing it up\n<|/ c |>\n<| a tags=string,r,string\
    \ |>\nHere is another way:\n<code>\nstring <- 'hello'\npattern <- 'hell'\nn <-\
    \ length(pattern)\na <- unlist(strsplit(string, \"\"))\ni <- 0\nwhile (i < n &\
    \ pattern[a[i]] == pattern) {\n  i <- i + 1\n}\nif(i == n) {\n  return(TRUE)\n\
    } else {\n  return(FALSE)\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThis\
    \ is my solution:\n<code>\ncycpattern_check <- function(a, b) {\n  i <- 1\n  while\
    \ (i <= length(a) & i <= length(b)) {\n    if(a[i] == b[i]) {\n      i <- i +\
    \ i\n    } else {\n      i <- i + 1\n    }\n  }\n  if(i > length(a)) {\n    return(TRUE)\n\
    \  }\n  else {\n    return(FALSE)\n  }\n}\n\ncycpattern_check(\"abc\", \"ab\")",
  "\n  # remove whitespace\n  a <- gsub(\"[[:space:]]+\", \"\", a)\n  b <- gsub(\"\
    [[:space:]]+\", \"\", b)\n  # remove duplicates\n  a <- unique(a)\n  b <- unique(b)\n\
    \  # check each character in a\n  i <- 1\n  s <- 0\n  for(j in 1:length(a)){\n\
    \    if(str_detect(a[j], paste(b, (rev(seq_along(b)), collapse = \"|\")))){\n\
    \      s <- s+1\n    }\n  }\n  if(s > 0){\n    return (1)\n  } else {\n    return\
    \ (0)\n  }\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nHey thanks for your code!\
    \  But it still does not work.  I used it to create a function in my own package\
    \ and called `cycpattern_check` with strings being passed to the function, but\
    \ it returns FALSE for all inputs.\n<|/ c |>\n<| c |>\nI took some of your code\
    \ and, from what I could tell, your solution works.  Thank you so much!  I would\
    \ upvote you if I had the reputation to do so.\n<|/ c |>\n<| c |>\nI have updated\
    \ my answer with the code that I have used to test my answer and it works correctly.\
    \  Please let me know if it works for you.  If it works, please mark my answer\
    \ as correct.\n<|/ c |>\n<| c |>\nHi, I appreciate your help and I am sorry that\
    \ it took me so long to get back to you.  When I tested your solution on a few\
    \ of the test cases I provided it did not work.  I went back to the problem that\
    \ I had and realized that I was only looking for substrings.  I also took your\
    \ code and used it to create my own function to test your solution.  It still\
    \ did not work.  I then tried something similar to what your code does and was\
    \ able to get your solution to work.  Thanks again!\n<|/ c |>\n<| c |>\nAwesome.\
    \  Glad to hear you got it working.  Please mark my answer as correct.  If you\
    \ get stuck again, let me know.\n<|/ c |>\n<| a dscore=0 |>\nThanks to everyone\
    \ who helped me with my problem.  I was able to solve this on my own.  I used\
    \ the solutions that I received above and came up with this solution.\n<code>\n\
    cycpattern_check <- function(a, b){\n  a <- gsub(\"[[:space:]]+\", \"\", a)\n\
    \  b <- gsub(\"[[:space:]]+\", \"\", b)\n", "\n  a <- toupper(a)\n  b <- toupper(b)\n\
    \  ab <- a[1]\n  for (i in 2:length(a))\n    ab <- paste0(ab, a[i])\n  for(j in\
    \ 1:length(b))\n    ab <- paste0(ab, b[j])\n  ab <- paste0(ab, a[length(a)])\n\
    \  ab <- paste0(ab, b[length(b)])\n  ab <- paste0(ab, a[length(a) - 1])\n  ab\
    \ <- paste0(ab, b[length(b) - 1])\n  ab <- paste0(ab, a[length(a) - 2])\n  ab\
    \ <- paste0(ab, b[length(b) - 2])\n  ab <- paste0(ab, a[length(a) - 3])\n  ab\
    \ <- paste0(ab, b[length(b) - 3])\n  ab <- paste0(ab, a[length(a) - 4])\n  ab\
    \ <- paste0(ab, b[length(b) - 4])\n  ab <- paste0(ab, a[length(a) - 5])\n  ab\
    \ <- paste0(ab, b[length(b) - 5])\n  ab <- paste0(ab, a[length(a) - 6])\n  ab\
    \ <- paste0(ab, b[length(b) - 6])\n  ab <- paste0(ab, a[length(a) - 7])\n  ab\
    \ <- paste0(ab, b[length(b) - 7])\n  ab <- paste0(ab, a[length(a) - 8])\n  ab\
    \ <- paste0(ab, b[length(b) - 8])\n  ab <- paste0(ab, a[length(a) - 9])\n  ab\
    \ <- paste0(ab, b[length(b) - 9])\n  ab <- paste0(ab, a[length(a) - 10])\n  ab\
    \ <- paste0(ab, b[length(b) - 10])\n  ab <- paste0(ab, a[length(a) - 11])\n  ab\
    \ <- paste0(ab, b[length(b) - 11])\n  ab <- paste0(ab, a[length(a) - 12])\n  ab\
    \ <- paste0(ab, b[length(b) - 12])\n  ab <- paste0(ab, a[length(a) - 13])\n  ab\
    \ <- paste0(ab, b[length(b) - 13])\n  ab <- paste0(ab, a[length(a) - 14])\n  ab\
    \ <- paste0(ab", "\n  \n  # Check length of words\n  if(length(a) != length(b))\
    \ {\n    stop(\"Different string lengths\")\n  }\n  \n  # Check chars in first\
    \ string\n  a <- toupper(a)\n  b <- toupper(b)\n  \n  # Check chars in second\
    \ string\n  i <- 0\n  \n  while(i < length(a)) {\n    \n    # Match substring\n\
    \    if(a[i] == b[i]) {\n      \n      # Rotate right\n      if(i < length(b))\
    \ {\n        i <- i + 1\n      } else {\n        i <- 0\n      }\n      \n   \
    \ } else if(a[i] == substr(b, i, 1)) {\n      \n      # Rotate right\n      i\
    \ <- i + 1\n    } else {\n      \n      # Not a match\n      i <- i + 1\n    }\n\
    \    \n  }\n  \n  # Return TRUE if substring in second string\n  return(i > 0)\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice code. Is there a way to do it with\
    \ loops? For example if there are 3 words, can you modify your code to check if\
    \ any of those three words are contained in a string?\n<|/ c |>\n<| c |>\nI added\
    \ a version of the code with loops.  I did not test the code, but it should work.\
    \  You may have to tweak the code slightly if there are spaces inside the words.\n\
    <|/ c |>\n<| a tags=algorithm,performance,r,string |>\n<code>\nlibrary(data.table)\n\
    library(stringi)\nlibrary(magrittr)\n", "\n  a <- as.character(a)\n  b <- as.character(b)\n\
    \  \n  a <- strsplit(a, \"\")[[1]]\n  b <- strsplit(b, \"\")[[1]]\n  \n  return(\n\
    \    a\n      %in%\n      b\n  )\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't\
    \ work as you intend for \"himenss\" to be TRUE, but it returns FALSE.\n<|/ c\
    \ |>\n<| c |>\nI don't think it should. I was just showing that it does indeed\
    \ work. I'll edit my answer to include a more functional solution.\n<|/ c |>\n\
    <| c |>\nThanks for your comments. I've modified the answer to address your comments.\
    \ I don't fully understand your comments about the second argument though. Did\
    \ you mean for the second argument to be \"simen\" instead of \"himenss\"? That\
    \ doesn't make any sense to me.\n<|/ c |>\n<| c |>\nI do mean for \"simen\" to\
    \ be TRUE, but your code returns FALSE. Try it with the string \"himenss\" in\
    \ your example. The two arguments for your function are \"himenss\" and \"simen\"\
    .\n<|/ c |>\n<| c |>\nI have made the necessary changes so that it should work\
    \ the way you want. Let me know if that works!\n<|/ c |>\n<| a dscore=0 |>\nFor\
    \ those who are looking for the solution in Python, here it is:\n<code>\ndef cycpattern_check(a,\
    \ b):\n    a = a.split()\n    b = b.split()\n    \n    for i in range(len(a)):\n\
    \        for j in range(len(b)):\n            if a[i] == b[j:j+len(a[i])] and\
    \ len(a[i]) < len(b[j:j+len(a[i])]):\n                return True\n        \n\
    \    return False\n</code>\n<|/ a tags=r |>\n<| a tags=r dscore=0 |>\nHere is\
    \ another solution that uses the rle function:\n<code>\ncycpattern_check=function(a,b){\n\
    \  if(rle(a)$values==rle(b)$values & lengths(rle(a)$lengths)==lengths(rle(b)$lengths)\
    \ & length(a)>length(b)){\n    TRUE\n  }\n  else{\n    FALSE\n  }\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis does not work: \ncycpattern_check(\"abc\", \"bc\")\n<|/\
    \ c |>\n<| c |>\nIt does not work because it is incorrect in many ways. \nYour\
    \ function does not return TRUE ", "\n  str_count(a, substring(b, 1, nchar(b)))\n\
    }\n", "\n    chars <- substr(b, 1, nchar(b))\n    first <- substr(a, 1, nchar(a))\n\
    \    all <- paste(chars, rep(chars, each = length(first)), sep = \"\")\n    all[match(first,all)]\n\
    }\n", "\n  \n  # check a\n  if (!is.element('a', a)) stop(\"a must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.element('b', b)) stop(\"b must be a valid\
    \ string\")\n  \n  # check b\n  if (!is.", "\n  a <- trimws(a)\n  b <- trimws(b)\n\
    \  \n  a <- toupper(a)\n  b <- toupper(b)\n  \n  a <- tolower(a)\n  b <- tolower(b)\n\
    \  \n  \n  cat(\"Checking:\", a, \"and\", b, \"\\n\")\n  \n  # find common substring\
    \ between a and b\n  common_substring <- function(x, pattern) {\n    \n    x <-\
    \ tolower(x)\n    pattern <- tolower(pattern)\n    \n    common <- x %in% pattern\n\
    \    common <- pattern[common]\n    common <- pattern[common]\n    \n    \n  \
    \  \n  }\n  \n  \n  \n  \n  \n  \n  \n  # find if first word is a subset of second\
    \ word\n  is_subset_of_second_word <- function(first_word, second_word) {\n  \
    \  \n    \n    first_word_split <- strsplit(first_word, \"\")\n    second_word_split\
    \ <- strsplit(second_word, \"\")\n    \n    first_word_subset <- lapply(first_word_split,\
    \ function(x) {\n      common_substring(paste0(x, collapse = \"\"), second_word)\n\
    \    })\n    \n    first_word_subset <- sapply(first_word_subset, function(x)\
    \ {\n      x == \"TRUE\"\n    })\n    \n    \n    first_word_subset <- unlist(first_word_subset)\n\
    \    \n    \n    first_word_subset <- unlist(first_word_subset)\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    ", "\n  # Your code here\n  n <-\
    \ length(a)\n  m <- length(b)\n  \n  # if n<0 then stop(\"length of string a is\
    \ < 0\") \n  # if m<0 then stop(\"length of string b is < 0\")\n  \n  if (n<0)\
    \ stop(\"length of string a is < 0\")\n  if (m<0) stop(\"length of string b is\
    \ < 0\")\n  \n  \n  \n  if(n <= m) {\n    \n    i <- 1\n    \n    while (i < n)\
    \ {\n      \n      if (substr(a, i, 1) %in% b) return(TRUE)\n      \n      \n\
    \      i <- i + 1\n      \n    }\n    \n  }\n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n", "\n    a <- toupper(a)\n    b <- toupper(b)\n\
    \    len <- nchar(a)\n    ans <- TRUE\n    for(i in 1:len) {\n        for(j in\
    \ (i+1):len) {\n            if(a[i] %in% b[j]) {\n                break\n    \
    \        }\n        }\n        if(!is.na(j)) {\n            ans <- FALSE\n   \
    \         break\n        }\n    }\n    return(ans)\n}\n", "\n  nchar(b) <- nchar(a)\n\
    \  b <- tolower(b)\n  a <- tolower(a)\n  b_mat <- nchar(a)\n  a_mat <- nchar(b)\n\
    \  if(b_mat == 0 || a_mat == 0) return(FALSE)\n  b_mat[seq_len(a_mat)] <- 0\n\
    \  a_mat <- b_mat\n  b_mat[seq_len(b_mat)] <- 0\n  for(i in seq_len(a_mat)) {\n\
    \    if(b_mat[i] == 0) return(FALSE)\n    for(j in seq_len(b_mat)) {\n      if(((i+j)\
    \ >= a_mat) & ((b_mat[i+j] == 1) | (b_mat[j+i] == 1))) return(TRUE)\n    }\n \
    \ }\n  return(FALSE)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI made a small mistake\
    \ in my question. I've corrected it. I made a mistake when copying and pasting\
    \ the question. My actual problem involves strings containing only characters\
    \ that aren't alphabetics, like `e` and `a`.\n<|/ c |>\n<| c |>\n, that's a very\
    \ good point. I edited the answer to handle only alphabetic characters.\n<|/ c\
    \ |>\n<| c |>\nI've tried it with the new question and have made some edits to\
    \ the answer, including removing unnecessary `if` statements.\n<|/ c |>\n<| c\
    \ |>\nThanks, that's much cleaner! I was able to get it working with my test cases.\
    \ But when I try to run it on actual text it fails on every test case. I'll update\
    \ my question to show the example cases I've been trying.\n<|/ c |>\n<| c |>\n\
    You have to apply the function to each row of `b`. In the answer, `b` is defined\
    \ as a vector of length 1 at the top and `s` is defined as a vector of length\
    \ n. I'm guessing you missed `rownames(s) <- a`. After that, `cycpattern_check`\
    \ returns `TRUE` for `'ef'` and `'eee'`. Is this what you want?\n<|/ c |>\n<|\
    \ a tags=r,substring |>\nYou can use the following code to check if a sub-string\
    \ appears anywhere in another string:\n<code>\nstring <- c(\"abcdef\", \"ab\"\
    , \"ef\", \"efgh\")\nsub <- c(\"ef\", \"ab\")\n\nany(sapply(string, function(x)\
    \ all(grepl(paste(sub, collapse = \"|\"), x))))\n</code>\n<|/ a dscore", "\n \
    \ return(\n    a%in%substring(b,1,nchar(a)) | \n    a%in%substring(b,nchar(a),nchar(a))\
    \ | \n    a%in%substring(b,1,nchar(a))|\n    a%in%substring(b,1,nchar(a)) & \n\
    \    a%in%substring(b,nchar(a),nchar(a)) & \n    a%in%substring(b,nchar(a),nchar(a))\
    \ & \n    a%in%substring(b,1,nchar(a)) & \n    a%in%substring(b,1,nchar(a)) &\
    \ \n    a%in%substring(b,nchar(a),nchar(a)) & \n    a%in%substring(b,nchar(a),nchar(a))\
    \ & \n    a%in%substring(b,nchar(a),nchar(a))\n  )\n}\n</code>\n<|/ a tags=r,pattern-matching,string,dataframe,string-matching\
    \ dscore=1 |>\n<| a dscore=1 |>\nUsing str_locate_all from stringr package :\n\
    <code>\ndf$check1 <- df$V1 %in% str_locate_all(df$V2, paste0(df$V1, collapse =\
    \ ''))[,1]\ndf$check2 <- df$V1 %in% str_locate_all(df$V2, paste0(df$V2, collapse\
    \ = ''))[,1]\n\ndf$check3 <- df$V1 %in% str_locate_all(df$V2, paste0(df$V2, collapse\
    \ = '')) \ndf$check3[!is.na(df$check3)] <- df$check3[!is.na(df$check3)]$V1\n\n\
    df$check4 <- df$V2 %in% str_locate_all(df$V1, paste0(df$V1, collapse = '')) \n\
    df$check4[!is.na(df$check4)] <- df$check4[!is.na(df$check4)]$V2\n</code>\n<|/\
    \ a tags=r,pattern-matching,string,dataframe,string-matching |>\n<| a tags=r,pattern-matching,string,dataframe,string-matching\
    \ |>\nThis is one way to do it with some regex:\n<code>\ndf$check<-grepl(\"[[:alnum:]]+[[:punct:]]*[[:alpha:]]\"\
    ,paste(df$V1,collapse=\"\"))\n</code>\nThe pattern basically says: \n\nAny string\
    \ that ", "\n  a <- trim(a)\n  b <- trim(b)\n  if(a==b) return(TRUE)\n  a <- strsplit(a,\
    \ \"\")[[1]]\n  b <- strsplit(b, \"\")[[1]]\n  for(i in 1:length(a)) {\n    for(j\
    \ in 1:length(b)) {\n      if(a[i]==b[j] || (a[i+1]==b[j+1] || (a[i+2]==b[j+2]\
    \ || (a[i+3]==b[j+3]))))\n        return(TRUE)\n    }\n  }\n  return(FALSE)\n\
    }\n", "\n  if (length(a) == 0 | length(b) == 0) return FALSE\n  if (length(a)\
    \ == 1 & grepl(b, b[1])) {\n    return TRUE\n  }\n  if (length(b) == 1 & grepl(a,\
    \ a[1])) {\n    return TRUE\n  }\n  \n  \n  for (i in 1:(length(a) + length(b)\
    \ - 1)) {\n    \n    if (length(a) == 1) {\n      \n      if (grepl(b[i], b[1]))\
    \ {\n        return TRUE\n      }\n      \n    } else if (length(b) == 1) {\n\
    \      \n      if (grepl(a[i], a[1])) {\n        return TRUE\n      }\n      \n\
    \    } else if (grepl(a[i], a[1]) & grepl(b[i], b[1])) {\n      return TRUE\n\
    \      \n    } else if (grepl(a[i], a[1]) & !grepl(b[i], b[1])) {\n      \n  \
    \    \n      if (length(a) > 1) {\n        \n        if (length(b) == 1) {\n \
    \         \n          if (grepl(b[i], b[1])) {\n            return TRUE\n    \
    \      }\n          \n        } else if (length(a) == 1) {\n          \n     \
    \     if (grepl(a[i], a[1])) {\n            return TRUE\n          }\n       \
    \   \n        } else {\n          \n          if (grepl(a[i], a[1]) & grepl(b[i],\
    \ b[1])) {\n            return TRUE\n            \n          }\n          \n \
    \       }\n        \n      }\n      \n    } else if (!grepl(a[i], a[1]) & grepl(b[i],\
    \ b[1])) {\n      \n      \n      if (length(a) > 1) {\n        \n        if (length(b)\
    \ == 1) {\n          \n          if (grepl(b[i], b[1])) {\n            return\
    \ TRUE\n          }\n          \n        } else if (length(a) == 1) {\n      \
    \    \n          if (grepl(a[i], a[1])) {\n            return TRUE\n         \
    \ }\n          \n        } else {\n          \n          if (grepl(a[i], a[1])\
    \ & grepl(b[i], b[1])) {\n            return TRUE\n            \n          }\n\
    \          \n        }\n        \n      }\n      \n    } else {\n      \n    \
    \  if (grepl(a[i], a[1]) & !grepl(b[i], b[1])) {\n        return TRUE\n      }\n\
    \      \n    }\n  }\n  \n  \n}\n", "\n  if (nchar(a) < nchar(b)) {\n    return(FALSE)\n\
    \  }\n  a <- tolower(a)\n  b <- tolower(b)\n  i <- seq(from=1, to=nchar(a), by=1)\n\
    \  j <- seq(from=1, to=nchar(b), by=1)\n  len <- nchar(a)\n  for(i in i) {\n \
    \   for(j in j) {\n      if(substr(a, i, i+1) == substr(b, j, j+1)) {\n      \
    \  len <- len - 1\n        break\n      }\n    }\n    if(len == 0) return(TRUE)\n\
    \  }\n  return(FALSE)\n}\n", "\n  any(grepl(paste(sprintf(\"^%s\", b), collapse\
    \ = \"|\"), a) | \n       grepl(sprintf(\"(%s)$\", paste(sprintf(\"^%s\", b),\
    \ collapse = \"|\")), a) | \n       grepl(paste(sprintf(\"(%s)$\", sprintf(\"\
    ^%s\", b)), collapse = \"|\"), a) | \n       grepl(sprintf(\"(%s)$\", sprintf(\"\
    ^%s\", b)), a))\n}\n</code>\n<|/ a dscore=3 tags=r,regex,string,r |>\n<| c |>\n\
    thanks for your answer.  it works!  Could you please tell me what is the meaning\
    \ of the following code: sprintf(\"(%s)$\", paste(sprintf(\"^%s\", b), collapse\
    \ = \"|\")), a)?\n<|/ c |>\n<| c |>\n: I guess it just concatenates the pattern\
    \ to the string `a`, but as regex I cannot explain it :) It checks if `b` contains\
    \ one of the strings: `^b$`, `^b` OR `b^`. Not sure why the pipe is necessary\
    \ there, but I am not sure. Can you explain the regex for me? I have just started\
    \ learning regex.\n<|/ c |>\n<| c |>\nThank you for your explanation.  I understand\
    \ now.\n<|/ c |>\n<| a tags=r,regex,string,r |>\nAs mentioned earlier, the problem\
    \ is that the pattern is being repeated.  I modified the function a bit and got\
    \ it working:\n<code>\nlibrary(stringr)\ncycpattern_check<-function(a,b){\n  x<-str_c(a,b)\n\
    \  any(grepl(x,a))\n}\ncycpattern_check(\"abacate\",\"abaca\")", "\n  # a should\
    \ be a string and b should be a string or a list of string\n  \n  if(!is.character(a)\
    \ || is.character(b)) \n    stop(\"Parameter 1 should be a string and Parameter\
    \ 2 should be a string or a list of strings.\")\n  \n  if(!is.character(a)) \n\
    \    a <- as.character(b)\n  \n  if(!is.character(b)) \n    b <- as.character(a)\n\
    \  \n  if(!is.list(a)) \n    a <- list(a)\n  \n  if(!is.list(b)) \n    b <- list(b)\n\
    \  \n  # If it is only 1 string just return FALSE\n  if(!length(a)) \n    return(FALSE)\n\
    \  \n  if(!length(b)) \n    b <- b[1]\n  \n  \n  # Check if any string in the\
    \ list is substring\n  for(i in 1:length(a)) {\n    if(grepl(b[i], a)) \n    \
    \  return(TRUE)\n  }\n  return(FALSE)\n}\n</code>\n<|/ a tags=r,pattern-matching\
    \ |>\n<| c |>\nThanks for the reply. However, the function you wrote has some\
    \ issues which is not the behavior I want. For example, when I input \"abbdeef\"\
    , \"ab\", the function returns TRUE which is not the behavior I want. It should\
    \ return FALSE.\n<|/ c |>\n<| c |>\nI didn't read your comment carefully. I missed\
    \ that part about substring in the first word. I'll edit my answer accordingly.\n\
    <|/ c |>\n<| a dscore=1 |>\nA data.table alternative is to use grepl with a negative\
    \ lookahead to check that one pattern does not come before another in a pattern:\n\
    <code>\nlibrary(data.table)", "\n  gsub(\"\\\\\", \"\", a) %>%\n    str_split(.,\
    \ \"\\\\\") %>%\n    sapply(., grepl, b, USE.NAMES = FALSE) %>%\n    any\n}\n",
  "\n  if(a == b || b %in% a) {\n    return(TRUE)\n  }\n  if(all(grepl(b, a))) {\n\
    \    return(TRUE)\n  }\n  if((length(b) > length(a))) {\n    b <- b[-(1:length(grep(b,\
    \ a)))]\n  }\n  return(FALSE)\n}\n</code>\n<|/ a dscore=2 tags=pattern-matching,substring,r,string\
    \ |>\n<| c |>\nThank you. Your code is really simple. It works really well for\
    \ the small dataset but for the bigger one it gets stuck in the middle (when I\
    \ try to print out or use it). Do you know why?\n<|/ c |>\n<| c |>\nIt works for\
    \ the smaller data set (the first one I showed). Could you give me an example\
    \ of how it fails for the big data set? Maybe we can find a way to solve it.\n\
    <|/ c |>\n<| c |>\nThe first one I showed you. It doesn't work for the bigger\
    \ one. \nIt works till step #3 and gets stuck at step #4 (I tried to print out\
    \ all the steps and it gets stuck at step #4). \nIt seems like it can't find the\
    \ pattern.\n<|/ c |>\n<| c |>\nThank you. I'll try to figure out what's wrong\
    \ and will let you know.\n<|/ c |>\n<| c |>\nIt's ok. Thank you so much. I really\
    \ appreciate your help.\n<|/ c |>\n<| a dscore=2 |>\nHere is one more option\n\
    <code>\nlibrary(data.table)\nf1 <- function(x, y) grepl(paste0(toupper(letters[x]),\
    \ collapse = ''), \n            toupper(letters[y]))\nf2 <- function(x, y) grepl(paste0(toupper(letters[y]),\
    \ collapse = ''), \n            toupper(letters[x]))\nf3 <- function(x, y) grepl(paste0(toupper(letters[y]),\
    \ collapse = ''), \n            toupper(letters[y]), ignore.case = TRUE)\nf4 <-\
    \ function(x, y) grepl(paste0(toupper(letters[x]), collapse = ''), \n        \
    \    toupper(letters[y]), ignore.case = TRUE)\n\nx <- strsplit(string1, '')[[1]]\n\
    y <- strsplit(string2, '')[[1]]\n\nf1 <- Vectorize(f1)\nf2 <- Vectorize(f2)\n\
    f3 <- Vectorize(f3)\nf4 <- Vectorize(f4)\n\nans <- Reduce(f", "\n  a1 <- unlist(strsplit(a,\
    \ \"\"))\n  b1 <- unlist(strsplit(b, \"\"))\n  a2 <- a1[a1 > b1]\n  b2 <- b1[a1\
    \ > b1]\n  length(a2) > 0\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    library(stringr)\nstr_detect(string, str_to_lower(paste(str_extract(string,pattern),collapse=\"\
    \ \")))\n</code>\n<|/ a tags=r,pattern-matching |>\n<| a tags=r,pattern-matching\
    \ |>\nAn option using agrep from qdap package -\n<code>\nlibrary(qdap)\nsapply(1:nchar(a),\
    \ function(i) any(agrep(a[i], b, ignore.case=T)))", "\n  # use sapply to apply\
    \ each pair of letters to a function that checks if they match each other\n  a_match\
    \ <- sapply(a, function(x) any(substring(b, x, max(x)) %in% b))\n  b_match <-\
    \ sapply(b, function(x) any(substring(a, x, max(x)) %in% a))\n  # Return TRUE\
    \ if all characters in each pair match\n  return(sum(a_match) == sum(b_match))\n\
    }\n", "\n  a1 <- strsplit(a, \"\")[[1]]\n  b1 <- strsplit(b, \"\")[[1]]\n  lapply(1:nchar(b),\
    \ function(i) {\n    a1[nchar(a1) - (nchar(a1) - nchar(b)) - (nchar(b) - i)]\n\
    \  }) %in% b1\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nthanks for your answer!\
    \ Just a small correction, you need to change \"any(strsplit(a, \"\")[[1]] %in%\
    \ strsplit(b, \"\")[[1]])\" to \"all(strsplit(a, \"\")[[1]] %in% strsplit(b, \"\
    \")[[1]])\" in order to check if there is any substring in the first string\n\
    <|/ c |>\n<| c |>\nThanks, I didn't realize it at first since I thought `all`\
    \ had to be `TRUE`, not `FALSE`. Edited.\n<|/ c |>\n<| c |>\nThanks, I thought\
    \ that too, but when I tried to run the code I got \"Error in strsplit(a, \"\"\
    )[[1]] : recursive indexing failed at level 2\".\n<|/ c |>\n<| c |>\nI've edited\
    \ my answer to fix this issue. Since `strsplit` returns a list of length 1, I\
    \ needed to use `[[1]]` to extract the string value.\n<|/ c |>\n<| c |>\nBy the\
    \ way, another way to do the same thing would be to use `grepl` and `grep`. See\
    \ my updated answer.\n<|/ c |>\n<| a tags=grepl,string,r dscore=0 |>\nIn case\
    \ you want a solution that does not use strsplit or grepl, here are two:\n<code>\n\
    grep(\"(.*)(\\\\b|$)\", a, perl = TRUE)", "\n  pattern <- gregexpr(b, c(a))[[1]]\n\
    \  pattern <- gsub(\"(.)\\\\1{2,}\", \"\\\\1\", pattern)\n  pattern <- gsub(\"\
    (.)\\\\1{1,}\", \"\\\\1\", pattern)\n  grepl(pattern, a, perl=T)\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nOne other possible approach, using stringi\
    \ package:\n<code>\nlibrary(stringi)\nstr_starts_with(c('ab', 'cd'), 'ab')", "\n\
    \  stopifnot(length(a) == length(b) && length(a) >= 1)\n  \n  a_rotations <- unlist(lapply(gregexpr(paste(rep(letters,\
    \ each=2), collapse=\"\"), a), function(x) \n    as.integer(x - 2)))\n  \n  return(\n\
    \    any(a_rotations %in% c(0, diff(a_rotations))) &&\n    any(grepl(b, a) | (a_rotations\
    \ %in% c(1, diff(a_rotations))) & \n      grepl(paste(rep(letters, each=2), collapse=\"\
    \"), a))\n  )\n}\n</cell>\n<cell>", "\n  \n  if(!is_match(a, b)) {\n    return(FALSE)\n\
    \  }\n  \n  return(TRUE)\n}\n", "\n  s <- substr(b, 1, nchar(a))\n  s1 <- substr(b,\
    \ nchar(a), nchar(b))\n  s2 <- substr(b, 1, nchar(a))\n  nchar(s1) < nchar(s2)\n\
    }\n\ncycpattern_check(c(\"whassup\", \"psus\", \"abc\", \"abd\"),\n          \
    \      c(\" whassup \", \"psus \", \"abc \", \"abd\"))", "\n  a <- toupper(tolower(a))\n\
    \  b <- toupper(tolower(b))\n  b <- strsplit(b, \"\\\\s\")[[1]]\n  b <- paste(b,\
    \ collapse = \" \")\n  c <- toupper(tolower(a))\n  c <- strsplit(c, \"\\\\s\"\
    )[[1]]\n  c <- paste(c, collapse = \" \")\n  d <- toupper(tolower(b))\n  d <-\
    \ strsplit(d, \"\\\\s\")[[1]]\n  d <- paste(d, collapse = \" \")\n  e <- toupper(tolower(c))\n\
    \  e <- strsplit(e, \"\\\\s\")[[1]]\n  e <- paste(e, collapse = \" \")\n  f <-\
    \ toupper(tolower(d))\n  f <- strsplit(f, \"\\\\s\")[[1]]\n  f <- paste(f, collapse\
    \ = \" \")\n  g <- toupper(tolower(e))\n  g <- strsplit(g, \"\\\\s\")[[1]]\n \
    \ g <- paste(g, collapse = \" \")\n  h <- toupper(tolower(f))\n  h <- strsplit(h,\
    \ \"\\\\s\")[[1]]\n  h <- paste(h, collapse = \" \")\n  i <- toupper(tolower(g))\n\
    \  i <- strsplit(i, \"\\\\s\")[[1]]\n  i <- paste(i, collapse = \" \")\n  j <-\
    \ toupper(tolower(h))\n  j <- strsplit(j, \"\\\\s\")[[1]]\n  j <- paste(j, collapse\
    \ = \" \")\n  k <- toupper(tolower(i))\n  k <- strsplit(k, \"\\\\s\")[[1]]\n \
    \ k <- paste(k, collapse = \" \")\n  l <- toupper(tolower(j))\n  l <- strsplit(l,\
    \ \"\\\\s\")[[1]]\n  l <- paste(l, collapse = \" \")\n  m <- toupper(tolower(k))\n\
    \  m <- strsplit(m, \"\\\\s\")[[1]]\n  m <- paste(m, collapse = \" \")\n  n <-\
    \ toupper(tolower(l))\n  n <- strsplit(n, \"\\\\s\")[[1]]\n  n <- paste(n, collapse\
    \ = \" \")\n  o <- toupper(tolower(m))\n  o <- strsplit(o, \"\\\\s\")[[1]]\n \
    \ o <- paste(o, collapse = \" \")\n  p <- toupper(tolower(n))\n  p <- strsplit(p,\
    \ \"\\\\s\")[[1]]\n  p <- paste(p, collapse = \" \")\n  q <- toupper(tolower(o))\n\
    \  q <- str", "\n  a <- tolower(a)\n  b <- tolower(b)\n  \n  ans <- a[-grepl(b,\
    \ a)]\n  \n  return(length(ans) > 0)\n}\n", "\n  ifelse(\n    grepl(paste0(substr(a,1,1),\n\
    \              rep(substr(a,2,1),each=2),\n              substr(a,3,1)),\n   \
    \        paste0(substr(b,1,1),\n                  rep(substr(b,2,1),each=2),\n\
    \                  substr(b,3,1)),\n           perl = TRUE),\n    TRUE, FALSE)\n\
    }\n</code>\nThe above checks if a word is a substring of b. This should be fast\
    \ as grep is vectorized over each word in a and b.\n<|/ a tags=r,string,pattern-matching\
    \ |>\n<| a |>\nHere is a simple function to check if two strings contain substrings\
    \ in each other:\n<code>", "\n    ans <- FALSE\n    for(i in 1:length(a))\n  \
    \  {\n        for(j in 1:length(b)){\n            if(a[i] == b[j]){\n        \
    \        ans <- TRUE\n                break\n            }\n        }\n      \
    \  if(!ans)\n            break\n    }\n    return(ans)\n}\n", "\n  a <- tolower(a)\n\
    \  b <- tolower(b)\n  n <- length(a)\n  m <- length(b)\n  if (n != m || n <= 0)\
    \ {\n    return(FALSE)\n  }\n  k <- 0\n  l <- 0\n  result <- FALSE\n  while (k\
    \ < n) {\n    while (l < m && !(strsplit(a, \"\")[[1]][k] == tolower(strsplit(b,\
    \ \"\")[[1]][l]))){\n      l <- l + 1\n    }\n    if (l < m) {\n      k <- k +\
    \ 1\n    }\n    else {\n      result <- TRUE\n      break\n    }\n  }\n  return(result)\n\
    }\n", "\n  if (grepl(paste0(letters, collapse = '|'), a) == FALSE || grepl(paste0(letters,\
    \ collapse = '|'), b) == FALSE) \n    return(FALSE)\n\n  # Find substring\n  a_length\
    \ <- nchar(a)\n  b_length <- nchar(b)\n  a_substrings <- gregexpr(paste0(letters,\
    \ collapse = '|'), a)\n  b_substrings <- gregexpr(paste0(letters, collapse = '|'),\
    \ b)\n  \n  # Iterate through substring and check each one\n  for(i in 1:a_length)\
    \ {\n    for(j in 1:b_length) {\n      \n      # Check substring\n      if((substr(a_substrings,\
    \ i, j) %in% b_substrings[[1]]) && (substr(a_substrings, i, j)%in% b_substrings[[2]]))\n\
    \        return(TRUE)\n      \n      # Check reverse substring\n      if((substr(b_substrings,\
    \ i, j) %in% a_substrings[[1]]) && (substr(b_substrings, i, j)%in% a_substrings[[2]]))\n\
    \        return(TRUE)\n    }\n  }\n  return(FALSE)\n}\n", "\n    \n    if (length(a)\
    \ == 0 || (length(a) == 1 && !str_detect(b, a))) return(FALSE)\n    if (length(b)\
    \ == 0) return(TRUE)\n    \n    for (i in seq_along(a)) {\n        \n        b\
    \ <- str_replace_all(b, a[i], \"\")\n        \n        if (!(str_detect(b, a[i])))\
    \ return(FALSE)\n    }\n    \n    return(TRUE)\n}\n", "\n  a <- gsub(\"(^\\\\\
    w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\", a)\n  b <- gsub(\"(^\\\\w+)(\\\\w+)(\\\
    \\w+)\", \"\\\\3\\\\2\\\\1\", b)\n  a <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\
    \\\\3\\\\2\\\\1\", a)\n  a <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\\
    2\\\\1\", a)\n  a <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\",\
    \ a)\n  a <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\", a)\n  b\
    \ <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\", b)\n  b <- gsub(\"\
    (^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\", b)\n  b <- gsub(\"(^\\\\w+)(\\\
    \\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\", b)\n  b <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\\
    w+)\", \"\\\\3\\\\2\\\\1\", b)\n  b <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\
    \\3\\\\2\\\\1\", b)\n  a <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\
    \\1\", a)\n  a <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\", a)\n\
    \  a <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\", a)\n  b <- gsub(\"\
    (^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\", b)\n  b <- gsub(\"(^\\\\w+)(\\\
    \\w+)(\\\\w+)\", \"\\\\3\\\\2\\\\1\", b)\n  b <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\\
    w+)\", \"\\\\3\\\\2\\\\1\", b)\n  b <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\
    \\3\\\\2\\\\1\", b)\n  b <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)\", \"\\\\3\\\\2\\\
    \\1\", b)\n  b <- gsub(\"(^\\\\w+)(\\\\w+)(\\\\w+)", "\n  return(\n    any(grepl(b,\
    \ a)) || \n    any(grepl(paste0(rep(substr(a, 1, nchar(a) - 1), each = nchar(b)\
    \ / nchar(a)), \"+\"), a)))\n  )\n}", "\n    all(c(0, diff(a)) == -0)\n    all(c(0,\
    \ diff(b)) == -0)\n    any(grepl(paste(rep(b, length(a)), rep(a, length(b)), sep\
    \ = \"\"), a, fixed = TRUE))\n}\n", "\n  n <- nchar(a)\n  m <- nchar(b)\n  \n\
    \  if(n < m) {\n    t <- ceiling(n / 2)\n    a <- substring(a, seq_len(t), seq_len(t))\n\
    \    b <- substring(b, seq_len(t), seq_len(t))\n  }\n  \n  if(nchar(a) == 0) {\n\
    \    return(TRUE)\n  }\n  \n  ax <- unique(c(substring(a, 1L, n), substring(a,\
    \ -1L, n)))\n  bx <- unique(c(substring(b, 1L, m), substring(b, -1L, m)))\n  \n\
    \  return(all(sapply(ax, function(x) any(bx %in% x))))\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThat is very close... you missed out one corner case. Try 'abc'\
    \ and 'abc'\n<|/ c |>\n<| c |>\nYes, that's true. I will add the solution with\
    \ your hint.\n<|/ c |>\n<| c |>\nThat worked! Now I have to see how that works\
    \ :)\n<|/ c |>\n<| c |>\nI added a description to the code and the test cases\
    \ in my answer.\n<|/ c |>\n<| a dscore=2 |>\nThis seems to work (I added some\
    \ more test cases to it). I've used the test cases you provided. \n<code>\ncycpattern_check\
    \ <- function(a, b) {\n  s1 <- strsplit(a, \"[[:alpha:]]+\")[[1]]\n  s2 <- strsplit(b,\
    \ \"[[:alpha:]]+\")[[1]]\n  s12 <- sapply(seq_along(s1), function(x) paste(s1[x],\
    \ s2[x], sep = \"\"))\n  s12 <- paste(s12, \"#\", sep = \"\")\n  return(all(s12\
    \ %in% c(s12, paste(s2[-length(s2)], s2[-1], sep = \"\"))))\n}\n</code>\n<|/ a\
    \ tags=string,algorithm,pattern-matching,r |>\n<| a tags=string,algorithm,pattern-matching,r\
    \ |>\nHere's an alternative solution, using rle from base R.\n<code>\ncycpattern_check\
    \ <- function(a, b) {\n  a <- strsplit(a, \"[[:alpha:]]+\", fixed = TRUE)[[1]]\n\
    \  b <- strsplit(b, \"[[:alpha:]]+\", fixed = TRUE)[[1]]\n  rl <- rle(a)\n  r\
    \ <- rle(b)\n  s <- c(\"a\", \"b\") # test cases\n  r[", "\n  ## Define a pattern\
    \ to match against\n  pattern <- paste0(a, paste(str_sub(b, start = 1, end = -1),\
    \ collapse = '|'), b)\n  \n  ## Check for pattern matches using grep\n  return(grepl(pattern,\
    \ a))\n}\n", "\n  # Return TRUE if any rotation of the second word is a substring\
    \ of the first\n  # Otherwise return FALSE\n  \n  # Return TRUE if any rotation\
    \ of the second word is a substring of the first\n  any(gregexpr(paste0(substr(b,\
    \ 1, 1), substr(b, 2, nchar(b) - 2)), paste0(a, b)) != -1)\n}\n</code>\n<|/ a\
    \ tags=string,r,regex,pattern-matching dscore=0 |>\n<| c |>\nThanks Matt! That\
    \ did work, although it didn't work for my test cases. I didn't realize that some\
    \ substrings would include characters that aren't in the first string. For example,\
    \ \"efef\" could match \"eeff\". Is there a way to include that case?\n<|/ c |>\n\
    <| c |>\nOops, I forgot to add the additional 'e' in your string for that case\
    \ to work. Sorry. Edited to fix that issue\n<|/ c |>\n<| c |>\nNo worries at all!\
    \ I just wasn't sure if there was a simple solution that I wasn't aware of. Thanks\
    \ for your help!\n<|/ c |>\n<| c |>\nNo problem, glad it helped!\n<|/ c |>\n<|\
    \ a tags=string,r,regex,pattern-matching dscore=0 |>\nIf you have the stringr\
    \ package loaded, the str_subset function will be able to handle this without\
    \ looping through each character by creating a regex pattern that includes all\
    \ of the characters you want to match:\n<code>\nlibrary(stringr)\n\ncycpattern_check\
    \ <- function(string1, string2) {\n  pattern = \"^[[:alpha:]]+$\"\n  result <-\
    \ str_subset(string1, pattern)\n  result <- c(result, str_subset(string2, pattern))\n\
    \  return(result %in% pattern)\n}\n</code>\n<|/ a |>\n<| c |>\nThanks Kyle! That\
    \ definitely looks more elegant, but unfortunately doesn't work for my test cases.\
    \ I probably should have mentioned those in my post because I'm new to regex and\
    \ was wondering if there was a way I can include those cases as well.\n<|/ c |>\n\
    <| a tags=string,r,regex,pattern-matching |>\nHere's a stringr solution that will\
    \ match any of a^nb, ab^n, ab^m, ab^p\n<code>\ncycpattern_check <- function(string1,\
    \ string2) {\n  string1 <- string1 %>% str_replace_all(\" \", \"\") %>% str_trim()\n\
    \  string2 <- string2 %>% str_replace_", "\n    b_words <- str_split(b, '')[[1]]\n\
    \    a_words <- str_split(a, '')[[1]]\n    ans <- paste(b_words, a_words, collapse\
    \ = ' ')\n    ans == a\n}\n", "\n  any(grepl(a, substring(b, 2, nchar(b))), ignore.case\
    \ = TRUE)\n}\n</code>\n<|/ a dscore=3 tags=r |>\n<| a tags=r |>\nIn addition to\
    \ previous answers, you can also use stri_detect_regex from stringr package. \n\
    <code>\nstringr::stri_detect_regex(c(\"aaa\",\"aba\",\"aea\",\"aea\",\"aea\"),\
    \ \"(?i)(aa)\")\n[1]  TRUE  TRUE FALSE  TRUE FALSE\n</code>\n<|/ a dscore=3 |>\n\
    <| a dscore=2 |>\nUsing stringr library you can write code like this\n<code>\n\
    library(stringr)\nstri_detect_regex(str_subset(c(\"aaa\",\"aba\",\"aea\",\"aea\"\
    ,\"aea\"), \"(?i)(aa)\"), pattern = \"(?i)(aa)\")\n</code>\n<|/ a tags=r |>\n\
    <| a dscore=2 |>\nAnother way to do it using dplyr and stringr, using mapply and\
    \ grepl:\n<code>", "\n  # if both vectors are length 0, return TRUE\n  if (length(a)\
    \ == 0 && length(b) == 0)\n    return(TRUE)\n  \n  # if vectors are length 1,\
    \ return FALSE\n  if (length(a) == 1 && (grepl(b, a) == FALSE)) {\n    return(FALSE)\n\
    \  }\n  \n  # check if pattern exists\n  if (grepl(b, a) == FALSE)\n    return(FALSE)\n\
    \  \n  # if pattern is found, remove it from both strings and recurse\n  a <-\
    \ sub(b, \"\", a)\n  b <- sub(b, \"\", a)\n  return(cycpattern_check(a, b))\n\
    }\n</cell>\n<text>\nLet\u2019s test our function:\n\n\n</text>\n<cell>\ncycpattern_check(\"\
    test\", \"test\")\n</cell>\n<cell>\ncycpattern_check(\"test\", \"test\")\n</cell>\n\
    <cell>\ncycpattern_check(\"hello\", \"o\")\n</cell>\n<cell>\ncycpattern_check(\"\
    hello\", \"o\")\n</cell>\n<cell>\ncycpattern_check(\"hello\", \"el\")\n</cell>\n\
    <cell>\ncycpattern_check(\"hello\", \"el\")\n</cell>\n<cell>\ncycpattern_check(\"\
    test\", \"a\")\n</cell>\n<cell>\ncycpattern_check(\"hello\", \"h\")\n</cell>\n\
    <text>\n6. Matching Patterns\nPatterns such as \u201C*\u201D and \u201C?\u201D\
    \ are greedy and will take as much input as they can. So, for example, the pattern\
    \ \u201Ca*\u201D would match the string \u201Cab\u201D and \u201Cab\u201D but\
    \ would not match the string \u201Ca\u201D (because it would take \u201Ca\u201D\
    \ and concatenate it with \u201Cb\u201D and then match the result).\n\nIn contrast,\
    \ patterns like \u201Ca*b\u201D will match the string \u201Cab\u201D because it\
    \ will try to find an a followed by any number of b\u2019s.\n\nA pattern like\
    \ \u201Ca?\u201D will match the string \u201Ca\u201D because the ? will force\
    \ it to take one character at a time.\n\nA pattern like \u201Ca?b\u201D will match\
    \ the string \u201Ca\u201D because it\u2019s anchored to begin with the a.\n\n\
    Let\u2019s test our function:\n\n\n</text>\n<cell>\ncycpattern_check(\"test\"\
    , \"test\")\n</cell>\n<cell>\ncycpattern_check(\"test\", \"a\")\n</cell>\n<cell>\n\
    cycpattern_check(\"test\", \"ab\")\n</cell>\n<cell>\ncycpattern_check(\"test\"\
    , \"testb\")", "\n  b <- tolower(b)\n  a <- tolower(a)\n  nchar(a) >= nchar(b)\n\
    }\n</code>\n<|/ a |>\n<| c |>\nWhat if you have a list of strings instead of a\
    \ single one? How would you go about applying this?\n<|/ c |>\n<| c |>\n, I have\
    \ updated the answer. Now the code accepts a vector of strings. You can check\
    \ it with `cycpattern_check(c('hello', 'himess'), 'simen')`.\n<|/ c |>\n<| c |>\n\
    Thanks, it's much better!\n<|/ c |>\n<| a tags=r,string |>\nWe can also use grepl\
    \ and greplx to check for a pattern.  \n<code>\ncycpattern_check2 <- function(string,\
    \ pattern) {\n    any(grepl(pattern, string))\n}\n\ncycpattern_check2(\"hello\"\
    , \"el\")", "\n  nchar(b) > nchar(a)\n}\n", "\n  return(\n    ifelse(\n      grepl(paste0(cycle_sub_patterns(a),\
    \ collapse=\"|\"), \n             paste0(b,collapse=\"|\")),\n      TRUE,\n  \
    \    FALSE\n    )\n  )\n}\n</code>\n<|/ a tags=r dscore=1 |>\n<| a |>\n<code>\n\
    library(stringr)\n\ncycpattern_check = function(A, B){\n  A = str_replace_all(A,\
    \ \"[[:punct:] ]\", \"\") \n  B = str_replace_all(B, \"[[:punct:] ]\", \"\")\n\
    \  \n  B = paste0(strrep(B, collapse=\"\"), collapse=\"-\")\n  \n  if(!grepl(paste0(B,\
    \ collapse=\"|\"), paste0(A, collapse=\"|\")))\n    return(TRUE)\n  \n  return(FALSE)\n\
    }\n\ncycpattern_check(\"whassup\", \"psus\")", "\n  if(length(a) > length(b))\
    \ {\n    b <- paste0(rep(b, length(a) - length(b)), collapse = \"\")\n  }\n  sapply(str_split(b,\
    \ \"\"), function(x){\n    any(grepl(paste0(\"\\\\b(\", paste(x, collapse=\"|\"\
    ), \")\\\\b\"), a))\n  })\n}\n", "\n  a <- tolower(a)\n  b <- tolower(b)\n  \n\
    \  if (length(a) == 0) {\n    return(TRUE)\n  }\n  \n  b <- paste0(sample(a, 2),\
    \ collapse = \"\")\n  b <- paste0(sample(b, 2), collapse = \"\")\n  \n  a <- paste0(sample(a,\
    \ 2), collapse = \"\")\n  a <- paste0(sample(a, 2), collapse = \"\")\n  \n  a\
    \ <- paste0(a, sample(b, 2))\n  \n  b <- paste0(b, sample(a, 2))\n  \n  return(grepl(b,\
    \ a))\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nAs a base R solution:\n\
    <code>\ncycpattern_check <- function(a, b) {\n  a <- tolower(a)\n  b <- tolower(b)\n\
    \  if (length(a) == 0) {\n    return(TRUE)\n  }\n  b <- paste0(sample(a, 2), collapse\
    \ = \"\")\n  b <- paste0(sample(b, 2), collapse = \"\")\n  a <- paste0(sample(a,\
    \ 2), collapse = \"\")\n  a <- paste0(a, sample(b, 2))\n  return(grepl(b, a))\n\
    }\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nThis is one possible approach:\n\
    <code>\nlibrary(data.table)\n\ncycpattern_check <- function(a, b) {\n    a <-\
    \ tolower(a)\n    b <- tolower(b)\n\n    if (length(a) == 0) {\n        return(TRUE)\n\
    \    }\n\n    b <- paste0(sample(a, 2), collapse = \"\")\n    b <- paste0(sample(b,\
    \ 2), collapse = \"\")\n\n    a <- paste0(sample(a, 2), collapse = \"\")\n   \
    \ a <- paste0(sample(a, 2), collapse = \"\")\n\n    a <- paste0(a, sample(b, 2))\n\
    \n    b <- paste0(b, sample(a, 2))\n\n    return(grepl(b, a))\n}\n\nset.seed(123)\n\
    s <- sample(letters, 10)\ncycpattern_check(\"ab\", s)", "\n  return(length(str_locate_all(a,b))\
    \ > 0) # TRUE or FALSE\n}\n", "\n  \n  # Check if string contains any of substring\
    \ in b\n  \n  # Create a vector of substrings to check\n  substr_to_check <- strsplit(b,\"\
    \")[[1]]\n  \n  result <- sapply(substr_to_check, function(x) any(grepl(x, a)))\n\
    \  \n  return(result)\n  \n}\n", "\n  a <- toupper(a)\n  b <- toupper(b)\n  if\
    \ (length(a) == length(b)) {\n    return (TRUE)\n  } else {\n    a_upper <- toupper(substr(a,\
    \ 1, (length(a) - 2)))\n    b_upper <- toupper(substr(b, 1, (length(b) - 2)))\n\
    \    if (any(a_upper %in% b_upper)) {\n      return(FALSE)\n    } else {\n   \
    \   b_lower <- tolower(substr(b, 1, (length(b) - 2)))\n      a_lower <- tolower(substr(a,\
    \ 1, (length(a) - 2)))\n      a_lower <- substr(a_lower, 1, (length(a_lower) -\
    \ length(b_lower)))\n      b_lower <- substr(b_lower, 1, (length(b_lower) - length(a_lower)))\n\
    \      if (a_lower %in% b_lower) {\n        return(TRUE)\n      } else {\n   \
    \     a_lower <- tolower(substr(a, 2, (length(a) - 2)))\n        b_lower <- tolower(substr(b,\
    \ 2, (length(b) - 2)))\n        if (any(a_lower %in% b_lower)) {\n          return(FALSE)\n\
    \        } else {\n          a_lower <- tolower(substr(a, 3, (length(a) - 2)))\n\
    \          b_lower <- tolower(substr(b, 3, (length(b) - 2)))\n          if (any(a_lower\
    \ %in% b_lower)) {\n            return(FALSE)\n          } else {\n          \
    \  return(TRUE)\n          }\n        }\n      }\n    }\n  }\n}\n", "\n  \n  #\
    \ astr <- paste0(a, '')\n  astr <- a\n  \n  # bstr <- paste0(b, '')\n  bstr <-\
    \ b\n  \n  astr <- paste0(t(strsplit(astr, \"\")[[1]]), \"\")\n  bstr <- paste0(t(strsplit(bstr,\
    \ \"\")[[1]]), \"\")\n  \n  astr <- paste0(t(strsplit(astr, \"\")[[2]]), \"\"\
    )\n  bstr <- paste0(t(strsplit(bstr, \"\")[[2]]), \"\")\n  \n  astr <- paste0(t(strsplit(astr,\
    \ \"\")[[3]]), \"\")\n  bstr <- paste0(t(strsplit(bstr, \"\")[[3]]), \"\")\n \
    \ \n  astr <- paste0(t(strsplit(astr, \"\")[[4]]), \"\")\n  bstr <- paste0(t(strsplit(bstr,\
    \ \"\")[[4]]), \"\")\n  \n  astr <- paste0(t(strsplit(astr, \"\")[[5]]), \"\"\
    )\n  bstr <- paste0(t(strsplit(bstr, \"\")[[5]]), \"\")\n  \n  astr <- paste0(t(strsplit(astr,\
    \ \"\")[[6]]), \"\")\n  bstr <- paste0(t(strsplit(bstr, \"\")[[6]]), \"\")\n \
    \ \n  astr <- paste0(t(strsplit(astr, \"\")[[7]]), \"\")\n  bstr <- paste0(t(strsplit(bstr,\
    \ \"\")[[7]]), \"\")\n  \n  astr <- paste0(t(strsplit(astr, \"\")[[8]]), \"\"\
    )\n  bstr <- paste0(t(strsplit(bstr, \"\")[[8]]), \"\")\n  \n  astr <- paste0(t(strsplit(astr,\
    \ \"\")[[9]]), \"\")\n  bstr <- paste0(t(strsplit(bstr, \"\")[[9]]), \"\")\n \
    \ \n  astr <- paste0(t(strsplit(astr, \"\")[[10]]), \"\")\n  bstr <- paste0(t(strsplit(bstr,\
    \ \"\")[[10]]), \"\")\n  \n  astr <- paste0(t(strsplit(astr, \"\")[[11]]), \"\"\
    )\n  bstr <- paste0(t(strsplit(bstr, \"\")[[11]]), \"\")\n  \n  astr <- paste0(t(strsplit(astr,\
    \ \"\")[[12]]), \"\")\n  bstr <- paste", "\n  a <- tolower(a)\n  b <- tolower(b)\n\
    \  s1 <- strsplit(a, \"[^[:alnum:]_]+\")[[1]]\n  s2 <- strsplit(b, \"[^[:alnum:]_]+\"\
    )[[1]]\n  len1 <- nchar(unlist(s1))\n  len2 <- nchar(unlist(s2))\n  if (len1==len2)\
    \ {\n    for(i in seq(along=s1)) {\n      for(j in seq(along=s2)) {\n        if\
    \ (s2[j] %in% s1[i]) {\n          return(TRUE)\n        }\n      }\n    }\n  \
    \  return(FALSE)\n  }\n  return(TRUE)\n}\n", "\n  # a is the shorter word\n  #\
    \ b is the longer word\n  # The test is done using regular expression\n  length(b)\
    \ <= length(a) && str_detect(b, a$words) & str_detect(b, a$sub_patterns)\n}\n",
  "\n  # Write code here\n  if(a%%1!=0) a <- a+1\n  if(grepl(b, a)) return(TRUE)\n\
    \  for(i in 1:(length(a)-length(b)+1)){\n    if(grepl(b, substr(a,i,i+length(b)))\
    \ ) return(TRUE)\n  }\n  return(FALSE)\n}", "\n  a <- strsplit(a, \"\")\n  b <-\
    \ strsplit(b, \"\")\n  sapply(b, function(x) any(grepl(x, a)))\n}\n", "\n  # if\
    \ the length of pattern is 0\n  if (length(a) == 0) return (b)\n  # if the pattern\
    \ contains '$', then check its rotation\n  if (any(grepl(\"$\", a)))\n    b <-\
    \ substring(gsub(paste0(rep(\" \", length(a)), collapse = ' '), \n           \
    \              \" \", \n                         b, fixed = TRUE), \n        \
    \            1, \n                    nchar(b))\n  # if the pattern contains '^',\
    \ then check whether it is rotated \n  if (any(grepl(\"^\", a)))\n    b <- substring(gsub(paste0(rep(\"\
    \ \", length(a)), collapse = ' '), \n                         \" \", \n      \
    \                   b, fixed = TRUE), \n                    2, \n            \
    \        nchar(b))\n  # if the pattern contains '*', then check whether it is\
    \ rotated \n  if (any(grepl(\"*\", a)))\n    b <- substring(gsub(paste0(rep(\"\
    \ \", length(a)), collapse = ' '), \n                         \" \", \n      \
    \                   b, fixed = TRUE), \n                    3, \n            \
    \        nchar(b))\n  # if the pattern contains '-', then check whether it is\
    \ rotated \n  if (any(grepl(\"-\", a)))\n    b <- substring(gsub(paste0(rep(\"\
    \ \", length(a)), collapse = ' '), \n                         \" \", \n      \
    \                   b, fixed = TRUE), \n                    4, \n            \
    \        nchar(b))\n  # if the pattern contains '$', then check whether it is\
    \ rotated \n  if (any(grepl(\"$\", a)))\n    b <- substring(gsub(paste0(rep(\"\
    \ \", length(a)), collapse = ' '), \n                         \" \", \n      \
    \                   b, fixed = TRUE), \n                    1, \n            \
    \        nchar(b))\n  # if the pattern contains '^', then check whether it is\
    \ rotated \n  if (any(grepl(\"^\", a)))\n    b <- substring(gsub(paste0(rep(\"\
    \ \", length(a)), collapse = ' '), \n                         \" \", \n      \
    \                   b, fixed = TRUE), \n                    2, \n            \
    \        nchar(b))\n  # if the pattern contains '*', then check whether it is\
    \ rotated \n  if (any(grepl(\"*\", a)))\n    b <- substring(gsub(paste0(rep(\"\
    \ \", length(a)), collapse = ' '), \n                         \" \", \n      \
    \                   b, fixed = TRUE), \n                    3, \n            \
    \        nchar(b))\n  # if the pattern contains '-', then check whether it is\
    \ rotated \n  if (any(grepl(\"-\", a)))\n    b <- substring(gsub(paste0(rep(\"\
    \ \", length(a)), collapse = ' '), \n                         \" \", \n      \
    \                   b, fixed = TRUE), \n                    4, \n            \
    \        nchar(b))\n  # if the pattern contains ", "\n  s1 <- strsplit(a, \"\"\
    )[[1]]\n  s2 <- strsplit(b, \"\")[[1]]\n  return(Reduce(function(a, b) Reduce(function(a,\
    \ b) a %in% b | b %in% a, c(s1, s2[1:(length(s1)-length(s2))+1])), c(s1, s2)))\n\
    }\n", "\n  \n  # Check if both words are of same length\n  if(length(a) != length(b))\
    \ {\n    stop(\"Words should have same length!\")\n  }\n  \n  # Check for substring\
    \ in second word\n  if(any(grepl(b, a))) {\n    TRUE\n  } else {\n    FALSE\n\
    \  }\n}\n", "\n  a <- tolower(a)\n  b <- tolower(b)\n  x <- stri_extract_all_words(a,\
    \ simplify=TRUE)\n  y <- stri_extract_all_words(b, simplify=TRUE)\n  result <-\
    \ logical(length(x))\n  for (i in 1:length(x)) {\n    result <- result & (grepl(x[i],\
    \ y) == T)\n  }\n  return(result)\n}\n", "\n  a <- tolower(a)\n  b <- tolower(b)\n\
    \  a <- strsplit(a, \"\\\\W+\")[[1]]\n  b <- strsplit(b, \"\\\\W+\")[[1]]\n  b\
    \ <- setdiff(b, a)\n  b <- paste0(b, a)\n  b <- tolower(b)\n  b <- b[b %in% a]\n\
    \  return(length(b) == 0)\n}\n</code>\n<|/ a tags=regex,r,string,r |>\n<| c |>\n\
    You will get a `character string with bad escape sequences` error if you try the\
    \ code with `cycpattern_check('hello', 'ell')`.\n<|/ c |>\n<| c |>\nThanks for\
    \ pointing this out. I added the tolower and also fixed the error. `tolower()`\
    \ should also probably be added.\n<|/ c |>\n<| c |>\nIt worked well for cycpattern_check('hello',\
    \ 'ell') but failed for cycpattern_check('efef', 'eeff') . I dont know why because\
    \ i converted both values to lower case . i tried using \nb<- b[b %in% a]\n instead\
    \ of b<- b[b %in% tolower(a)]\nstill same problem.\n<|/ c |>\n<| c |>\nOkay I\
    \ solved the problem and posted my answer . thanks a ton for helping me . :)\n\
    <|/ c |>\n<| a dscore=2 |>\nI made some changes to the original code (thanks everyone\
    \ for helping me) . Here is my final code (that worked for all the cases i have\
    \ tested ) :\n<code>\ncycpattern_check <- function(a, b) {\n  a <- tolower(a)\n\
    \  b <- tolower(b)\n  a <- strsplit(a, \"\\\\W+\")[[1]]\n  b <- strsplit(b, \"\
    \\\\W+\")[[1]]\n  b <- setdiff(b, a)\n  b <- paste0(b, a)\n  b <- tolower(b)\n\
    \  b <- b[b %in% a]\n  return(length(b) == 0)\n}\n</code>\n<|/ a tags=regex,r,string,r\
    \ |>\n<| c |>\nYou can remove `tolower(b)` from `b <- tolower(b)`. Actually your\
    \ code is too similar to's code, but this way you also remove any possible case\
    \ sensitivity issues.\n<|/ c |>\n<| c |>\nYeah i tried that too , still getting\
    \ the same error .\n<|/ c |>\n<| c ", "\n  if(!is.character(a)) stop('First argument\
    \ should be character')\n  if(!is.character(b)) stop('Second argument should be\
    \ character')\n  a <- tolower(a)\n  b <- tolower(b)\n  \n  # get list of all possible\
    \ rotations of 'a' in 'b'\n  a_rotations <- sapply(strsplit(a, \"\")[[1]], function(x)\
    \ paste(seq(x), collapse=\"\"))\n  \n  # get list of all possible substrings in\
    \ 'b'\n  b_subs <- unlist(strsplit(b, \"\"))\n  \n  if(nchar(b_subs) > 1) {\n\
    \    for(b_sub in b_subs) {\n      if(b_sub %in% a_rotations) {\n        return(TRUE)\n\
    \      }\n    }\n  }\n  return(FALSE)\n}\n", "\n  a <- tolower(a)\n  b <- tolower(b)\n\
    \  \n  i <- 0\n  j <- 0\n  \n  while(i < length(a) && j < length(b)) {\n    if(a[i]\
    \ == b[j]) {\n      j <- j + 1\n      i <- i + 1\n      \n      if(j == length(b))\
    \ {\n        \n        return(TRUE)\n      }\n    }\n    \n    if(a[i] == b[j])\
    \ {\n      j <- j + 1\n      i <- i + 1\n      \n      if(j == length(b)) {\n\
    \        \n        return(TRUE)\n      }\n      \n    } else {\n      if(j ==\
    \ length(a)) {\n        \n        return(TRUE)\n      }\n      \n      i <- i\
    \ + 1\n    }\n    \n  }\n  \n  if(length(a) == length(b)) {\n    return(TRUE)\n\
    \  }\n  \n  return(FALSE)\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nUsing base\
    \ R's gregexpr\n<code>\ngregexpr('.*\\\\b(' +tolower(s) +').*\\\\b', tolower(s))\n\
    </code>\nwhich gives the index of the position of the pattern in the whole string.\
    \ Subset the output to get the positions of the pattern in each string\n<code>\n\
    sapply(str_split(s,' '), function(x) gregexpr('.*\\\\b(' +tolower(x) +').*\\\\\
    b', tolower(x))[[1]])\n</code>\n<|/ a tags=string,regex,r dscore=2 |>\n<| a tags=string,regex,r\
    \ |>\nHere is another base R option\n<code>\ntolower(s) %in% tolower(gsub('(.)(?=[^\\\
    \\w])', paste0('\\\\1', s), s))\n</code>\nwhich gives\n<code>\n[1]  TRUE FALSE\
    \  TRUE  TRUE FALSE  TRUE\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you! This\
    \ also works for me! However, I am not able to understand the logic behind the\
    \ code. Can you please explain it as well?\n<|/ c |>\n<| a |>\nMy attempt:\n<code>\n\
    > str <- \"Hello there you\"\n> str1 <- \"you\"\n> grepl(\"\\\\b(?:\" paste0(tolower(str),\
    \ collapse=\"|\") \")\\\\b\", paste0(tolower(str1), collapse=\"|\"))\n[1]  TRUE\
    \ FALSE  TRUE FALSE  TRUE FALSE\n</code>\n<|/ a dscore=1 tags=string,regex,r |>\n\
    <|", "\n    lapply(seq_along(a), function(i)\n            grepl(b, paste0(substr(a,\
    \ i, i + 1, sep = \"\"), collapse = \"\"))\n    )\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
