name: HumanEval_5_intersperse
language: r
prompt: "# Insert a number 'delimeter' between every two consecutive elements of input\
  \ list `numbers'\n# >>> intersperse(c(), 4)\n# c()\n# >>> intersperse(c(1, 2, 3),\
  \ 4)\n# c(1, 4, 2, 4, 3)\nintersperse <- function(numbers, delimeter) {"
tests: "test_humaneval <- function() {\ncandidate <- intersperse\n    if(!identical(candidate(c(),\
  \ 7), c())){quit('no', 1)}\n    if(!identical(candidate(c(5, 6, 3, 2), 8), c(5,\
  \ 8, 6, 8, 3, 8, 2))){quit('no', 1)}\n    if(!identical(candidate(c(2, 2, 2), 2),\
  \ c(2, 2, 2, 2, 2))){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  num <- length(numbers)\n  result <- c(numbers[1], rep(delimeter,\
    \ num-2))\n  result <- c(result, numbers[-1])\n  return(result)\n}\n</cell>\n\
    <cell>", "\n  numbers <- c(numbers, delimeter)\n  result <- numbers[1]\n  for(i\
    \ in 2:length(numbers))\n    result <- c(result, numbers[i])\n  result\n}\n",
  "\n  if(!is.character(delimeter)) { stop(\"'delimeter' must be a character vector\"\
    ) }\n  if(is.character(numbers)) { numbers <- c(numbers, delimeter) }\n  if(!is.vector(numbers))\
    \ { numbers <- as.vector(numbers) }\n  numbers <- as.vector(numbers)\n  if(length(numbers)\
    \ <= 1) { return(numbers) }\n  if(all(numbers == numbers[1])) { return(numbers)\
    \ }\n  if(length(numbers) == 2) { return(numbers) }\n  if(length(numbers) > 2)\
    \ { return(numbers) }\n  if(numbers[length(numbers)] != delimeter) { return(numbers)\
    \ }\n  return(c(numbers[1], rep(delimeter, length(numbers)-1)))\n}\n", "\n  #\
    \ intersperse function expects a list and returns a list\n  unlist(\n    lapply(seq_along(numbers),\
    \ function(i) {\n      if(i > 0) c(numbers[i - 1], '/', numbers[i])\n      else\
    \ numbers[i]\n    }),\n    use.names = FALSE\n  )\n}\n</code>\n<|/ a tags=list,r\
    \ |>\n<| a dscore=0 tags=list,r |>\nI wanted to add an answer as I was struggling\
    \ with this problem for a while and found another way to do the same thing in\
    \ a bit more concise fashion (with some comments explaining each step).\n<code>\n\
    intersperse <- function(numbers, delimeter){\n  # Intersperse function expects\
    \ a list and returns a list\n  # - This part simply prepends your delimeter to\
    \ every element of a list until it reaches the end\n  # - Then it loops through\
    \ each element of the list starting at the second element of the list (i.e. the\
    \ delimeter)\n  # - As we now know that every second element (index 1, since the\
    \ delimeter is prepended to every element) is the actual list we want,\n  # -\
    \ we prepend the delimeter to every element before the first element of the list\
    \ \n  # - Then we remove the second element of the list from the list (i.e. the\
    \ delimeter) by setting the first element of the list equal to the second element\
    \ of the list (i.e. the delimeter)\n  # - Then we append the rest of the elements\
    \ of the list to the list we created (starting with the first element of the list)\
    \ to the new list.\n  # - I believe this would be the simplest way to do it.\n\
    \n  interspersed_list <- c(numbers, list(delimeter))\n  if(length(interspersed_list)\
    \ > length(numbers)){\n    interspersed_list[1] <- delimeter\n  }\n\n  interspersed_list\
    \ <- append(interspersed_list[1:(length(interspersed_list) - 1)], numbers[2:length(numbers)])\n\
    \n  return(interspersed_list)\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is\
    \ an approach with purrr:\n<code>", "\n    interp <- function(num) {\n       \
    \ if (length(num) > 1) {\n            interp(tail(num, 1)) + delimeter\n     \
    \   } else {\n            interp(num)}\n    }\n    list(numbers = numbers, interp\
    \ = interp)\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nHi Achim and thanks for your\
    \ help. I really appreciate this. But what I'm trying to do is intersperse a constant\
    \ string between the elements. So if the list is `c(1, 2, 3)` then the output\
    \ should be `c(1, \"Constant\", 2, \"Constant\", 3, \"Constant\")`. Is this possible?\n\
    <|/ c |>\n<| c |>\nThis is very close to what I need, thank you very much. But\
    \ is there a way I can get the output to return a single list instead of `c()`\
    \ with the concatenated strings? Like the output should be `list(1, \"Constant\"\
    , 2, \"Constant\", 3, \"Constant\")`\n<|/ c |>\n<| c |>\nJust remove `interp <-\
    \ function(num) {\n    if (length(num) > 1) {\n        interp(tail(num, 1)) +\
    \ delimeter\n    } else {\n        interp(num)}\n}` from `intersperse` function\n\
    <|/ c |>\n<| c |>\n: I edited my answer accordingly.\n<|/ c |>\n<| a dscore=4\
    \ |>\nFor a base R solution you can use Reduce with + to create the string:\n\
    <code>\nReduce(`+`, list(1, 2, 3))\n</code>\n<|/ a tags=r |>\n<| a dscore=3 |>\n\
    Just another option:\n<code>\nsapply(c(1, 2, 3), function(x) paste(x, \"Constant\"\
    , sep=\"\"))", "\n  numbers <- as.list(numbers)\n  if (length(numbers) %% 2 !=\
    \ 0) stop(\"List length must be even\")\n  out <- numbers[length(numbers):1]\n\
    \  for (k in seq_along(numbers):2) {\n    out <- c(out, numbers[seq(from = k,\
    \ to = length(numbers), by = 2)])\n  }\n  out <- c(out, numbers[-1])\n  out <-\
    \ paste0(out, collapse = delimeter)\n  as.character(out)\n}\n", "\n  numbers <-\
    \ c(numbers, numbers)\n  n <- length(numbers)\n  lapply(seq_len(n / 2 + 1), function(i)\
    \ numbers[2 * i + 1] <- delimeter, \n         unlist(numbers))\n}\n</code>\nSample\
    \ usage:\n<code>\nnumbers <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nintersperse(c(),\
    \ 4)", "\n  res <- rep(NA_real_, 0)\n  last_delimeter <- 1\n  if(length(numbers)\
    \ == 0) return(res)\n  while(last_delimeter <= length(numbers)) {\n    res[last_delimeter]\
    \ <- numbers[last_delimeter]\n    last_delimeter <- last_delimeter + delimeter\n\
    \  }\n  return(res)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThe OP wants a `list`\
    \ of results as output, not a vector of results.\n<|/ c |>\n<| c |>\nI interpret\
    \ `list` as vector.  If you want vector, just wrap with `unlist()`\n<|/ c |>\n\
    <| c |>\n`unlist` doesn't work because `intersperse(c(1, 2), 1)` returns a `vector`\n\
    <|/ c |>\n<| c |>\nI am not sure I get your point.  If the OP wants a vector,\
    \ wrap with `unlist()`.  I thought OP wanted to have a list as output.  I made\
    \ it a list just in case it needed a `list` of output.  Thanks for pointing out\n\
    <|/ c |>\n<| a dscore=0 tags=r |>\nHere is a base R solution:\n<code>\nintersperse\
    \ <- function(list, delimeter) {\n  if(length(list) == 0) {\n    list()\n  } else\
    \ {\n    stopifnot(length(list) == length(unlist(list)))\n    result <- rep(NA,\
    \ length(list))\n    stopifnot(all(sapply(seq_along(result), function(i) result[i]\
    \ == list[i])),\n              \"Your input list must have a number-number pair\
    \ as each element\")\n    stopifnot(all(sapply(seq_along(result), function(i)\
    \ result[i] == list[i+1])),\n              \"Your input list must have a number-number\
    \ pair as each element\")\n    result <- cbind(result, rep(list[1:2], nchar(list[2])\
    \ - 1))\n    stopifnot(all(sapply(seq_along(result), function(i) result[i] ==\
    \ list[i+2])),\n              \"Your input list must have a number-number pair\
    \ as each element\")\n    result\n  }\n}\n</code>\n<|/ a |>\n<| c |>\n`intersperse(c(1,2),\
    \ 1)` returns `NA`\n<|/ c |>\n<| c |>\n`stopifnot(length(result) == length(unlist(result)))`\
    \ might be more robust than `stopifnot(length(result) == length(numbers))`\n<|/\
    \ c |>\n<| a dscore=0 |>\nHere is my attempt using purrr::map and purrr::reduce ",
  "\n  numbers <- unlist(numbers)\n  \n  number <- unlist(strsplit(toString(numbers),\
    \ \"\"))[[1]]\n  \n  if (length(number) > 1) {\n    result <- c()\n    for (number\
    \ in numbers) {\n      result <- c(result, c(number, delimeter))\n    }\n  } else\
    \ {\n    result <- c(number, delimeter)\n  }\n  \n  class(result) <- \"character\"\
    \n  \n  return(result)\n}\n</code>\nThis one takes advantage of the fact that\
    \ strings are sequences of characters and c() will convert it to a character vector\
    \ with the length of the longest string:\n<code>", "\n  if (length(numbers) ==\
    \ 1) {\n    numbers[[1]]\n  } else {\n    lapply(seq_along(numbers), function(x)\
    \ {\n      c(numbers[[x]], delimeter)\n    })\n  }\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nIt's not quite as simple as your answer but still an interesting solution\n\
    <|/ c |>\n<| a dscore=2 |>\nI think this is an interesting one. We can use Reduce\
    \ with its accumulator argument (in this case it is the character vector \"-\"\
    ), to create an \"interspersed\" vector:\n<code>\na <- c()\na <- Reduce(function(a,x)\
    \ {\n    if(length(a) == 0) a <- c(x, \"-\")\n    else           a <- c(x, a)\n\
    \    return(a)\n    }, a, c)\n</code>\nOutput:\n<code>\n> a\n[1] \"-\" \" \" \"\
    -\" \" \" \"-\" \" \" \" \"-\" \" \" \"-\" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \"-\" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\
    \ ", "\n    i <- 0\n    f <- function(i, numbers, delimeter) {\n        if (i\
    \ == length(numbers)) return(numbers)\n        if (length(numbers) == 1) {\n \
    \           numbers[i] <- numbers[i]\n            return(numbers)\n        }\n\
    \        numbers[i] <- (numbers[i] %||% delimeter) * numbers[i + 1]\n        return(numbers)\n\
    \    }\n    f(i = i, numbers, delimeter)\n}\n", "\n  if (is.character(numbers))\
    \ {\n    numbers <- as.numeric(numbers)\n  }\n  return(mapply(function(x,y) paste(x,\
    \ delimeter, y, sep=\"\"), numbers, numbers))\n}\n</code>\n<|/ a tags=r,python,r\
    \ |>\n<| a |>\nYou could use rbind to build up all combinations of elements of\
    \ the two input vectors and then rbind the vector of the elements of the combinations\
    \ with the other element of the second vector to get the result:\n<code>\na <-\
    \ c(1,2,3)\nb <- c(4,5,6)\nr <- rbind(a, b)\nr <- c(r, \"other\")\n\nr", "\n \
    \ return(paste0(deparse(substitute(numbers)), delimeter, paste0(numbers[-1], deparse(substitute(delimeter)))))\n\
    }\n</cell>\n<text>\nNow we create a function that returns the 'numbers' input\
    \ list with each element repeated 'count' number of times\n\n\n</text>\n<cell>",
  "\n  if (length(numbers) %% delimeter > 0) {\n    stop('intersperse: input list\
    \ must have an even number of elements')\n  }\n  output <- unlist(numbers)\n \
    \ output <- output[-length(output)]\n  output <- c(output, delimeter)\n  output\
    \ <- paste0(output, numbers[-1])\n  output\n}\n</cell>\n<cell>", "\n    if(length(numbers)\
    \ < 2) return(numbers)\n    else return(unlist(numbers, use.names = FALSE)[(seq(1,\
    \ length(numbers), 2)) + 1] <- numbers[(seq(1, length(numbers), 2)) + 1] <- delimeter)\n\
    }\n", "\n  unlist(lapply(numbers, function(x) {\n    result <- x\n    if (x !=\
    \ 0) result <- c(result, delimeter)\n    result\n  }))\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nI like Alexey's solution, and I'd like to provide a variation with\
    \ only base R functions. It's not as compact as Alexey's, but it avoids any unnecessary\
    \ concatenation.\n<code>\nintersperse = function(x, delimeter){\n  if(length(x)\
    \ == 1) return(x)\n  if(length(x) == 2) return(paste0(delimeter, x[1], delimeter,\
    \ x[2]))\n  if(length(x) > 2) return(paste0(intersperse(tail(x, -1), delimeter),\
    \ delimeter, head(x, -1)))\n}\n</code>\n<|/ a dscore=3 tags=r,list |>\n<| c |>\n\
    I like this solution. Easy to read, easy to understand, and easy to extend.\n\
    <|/ c |>\n<| a dscore=3 tags=r,list |>\nHere is another solution. Using the functions\
    \ mapply and unlist in the base R package:\n<code>\nx <- c(1, 2, 3)\nunlist(mapply(c,\
    \ x, c(x, x, x)))\n</code>\n<|/ a |>\n<| a |>\nAnother way to do it in one line\
    \ is\n<code>\nintersperse <- function(x, delimeter){\n  paste(\n    c(\n     \
    \ unlist(lapply(x, function(y) { if(y==0) NA else c(y,delimeter) })),\n      unlist(lapply(x,\
    \ function(y) { if(y==1) NA else c(delimeter,y) })\n    ),\n    collapse = delimeter\n\
    \  )\n}\n</code>\n<|/ a dscore=3 tags=r,list |>\n<| c |>\nNice solution! Thank\
    \ you!\n<|/ c |>\n<| a dscore=3 |>\nYou can use the following function:\n<code>\n\
    intersperse <- function(x, delimeter) {\n    result <- c(as.character(x), as.character(x[-1]))\n\
    \    res <- paste0(result, delimeter)\n    if (length(res) > 1)\n        paste0(intersperse(res[-1],\
    \ delimeter), delimeter)\n    else res\n}\n</code>\nFor example:\n<code>\nx1 <-\
    \ c(1,2,3)\nx2 <- c(1,2)\nx3 <- c(2,3,4)\nintersperse(x1, \",\")", "\n  return(append(numbers,\
    \ numbers[length(numbers)], after = 1))\n}\n", "\n    paste(numbers, collapse=paste(delimeter,\
    \ collapse=delimeter))\n}\n</cell>\n<cell>", "\n  numbers <- unlist(numbers)\n\
    \  repeat {\n    repeat.n <- min(length(numbers), length(numbers)) %% 2\n    if(repeat.n\
    \ == 0) return numbers # No more interspersion needed\n    numbers <- c(numbers,\
    \ numbers[-1])\n  }\n  repeat {\n    repeat.n <- length(numbers) %% 2\n    if(repeat.n\
    \ == 0) return numbers # No more interspersion needed\n    numbers <- c(numbers,\
    \ numbers[length(numbers)])\n  }\n  numbers <- numbers[1L:length(numbers)] # Remove\
    \ the extra intersperse\n  numbers <- paste0(numbers, c(delimeter, rep(delimeter,\
    \ length(numbers))))\n  numbers\n}\n</cell>\n<cell>\nintersperse(c(1, 2, 3), 4)\n\
    </cell>\n<text>\nRecursion\nA recursive function call is made repeatedly until\
    \ the base case is reached.\nThe base case is reached if the function returns\
    \ without any recursion.\n\nThe base case is reached when there are no more elements\
    \ in the list to be processed.\n\n\n</text>\n<cell>\nfactorial <- function(n)\
    \ {\n  if(n < 0) stop(\"Negative factorials not allowed\")\n  if(n <= 1) return(n)\n\
    \  return(n * factorial(n-1))\n}\n</cell>\n<cell>\nfactorial(10)\n</cell>\n<cell>\n\
    factorial(-1)\n</cell>\n<cell>\nfactorial(0)\n</cell>\n<cell>\nfactorial(1)\n\
    </cell>\n<cell>\nfactorial(2)\n</cell>\n<text>\nBase case examples\nIf the function\
    \ is called without any recursion, it is called with a base case (stop(\"Negative\
    \ factorials not allowed\")) that stops the function from running.\nIf the function\
    \ is called with at least one recursion, it is called with a base case that stops\
    \ the function from running and return an error message (stop(\"Negative factorials\
    \ not allowed\")) that stops the function from running and returns an error message\
    \ to the user.\nIf the function calls itself with only one argument, the function\
    \ will run until it reaches the base case and return an error message (stop(\"\
    Negative factorials not allowed\")) that stops the function from running and returns\
    \ an error message to the user (this happens because there is no element in the\
    \ list to process).\n\nRecursive functions can have multiple base cases, which\
    \ are the stop(\"Error message\") calls that stops the function from running and\
    \ returns an error message to the user. The first base case that returns a non-NULL\
    \ value stops the function from running and returns NULL that stops the function\
    \ from running.\n\n\n</text>\n<cell>", "\n  if (length(numbers) < 2) return(numbers)\n\
    \  if (length(numbers) == 1) return(c(numbers, delimeter))\n  intersperse_(numbers,\
    \ delimeter)\n}\n", "\n    lapply(seq_along(numbers), function(i) {\n        if(i\
    \ <= length(numbers)) c(numbers[i - 1], numbers[i], numbers[i + 1])\n        else\
    \ numbers[i - 1]\n    })\n}\n", "\n  unlist(strsplit(numbers, sprintf(\"(?<=%s)\"\
    , paste0(delimeter, collapse = \"|\"))))\n}\n", "\n  return(function(x) {\n  \
    \  if (!is.atomic(x)) {\n      stop(\"'x' must be atomic!\")\n    }\n    if (length(x)\
    \ > 1) {\n      stop(\"'x' must be of length greater than 1!\")\n    }\n    lapply(seq_along(x),\
    \ function(i) {\n      if (length(x) <= i) return(\"\")\n      else return(paste(x[i],\
    \ delimeter, sep = \"\"))\n    })\n  })\n}\n", "\n  return(numbers[seq(1, length(numbers),\
    \ by=2)] <<- c(numbers[seq(1, length(numbers), by=2)], delimeter))\n}\n", "\n\
    \  sapply(seq_along(numbers), function(i){\n    c(numbers[i], numbers[(i+1):length(numbers)],\
    \ delimeter)\n  })\n}\n", "\n  c(numbers[1], numbers[2], numbers[length(numbers)],\
    \ numbers[seq_len(length(numbers)-1)], delimeter, numbers[length(numbers)+1])\n\
    }\n", "\n    lapply(numbers, function(x) {\n        c(x, delimeter, x)\n    })\n\
    }\n", "\n  numbers <- unlist(numbers)\n  numbers <- c(numbers, rep(delimeter,\
    \ length(numbers) - 1))\n  numbers\n}\n</code>\n<code>\nintersperse(c(1, 2, 3),\
    \ 4)\nc(1, 4, 2, 4, 3)\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThis one is the shortest\
    \ and most compact way I can think of:\n<code>\n x <- c(1,2,3)\n n <- 4\n paste0(c(\"\
    \",c(paste0(\"c(\", paste(x[1:(n-1)], collapse=\"\"),\n                paste(x[1:(n-1)],\
    \ collapse=\"\"),\n                \")\"),\n              paste(x[1:(n-2)], collapse=\"\
    \"),\n              paste(x[1:(n-1)], collapse=\"\"),\n              \"\",\n \
    \             paste(x[n], collapse=\"\"),\n              paste(x[n+1], collapse=\"\
    \"),\n              paste(x[n+2], collapse=\"\"),\n              paste(x[n+3],\
    \ collapse=\"\"),\n              paste(x[n+4], collapse=\"\"))),\n       collapse=\"\
    \")\n</code>\nThe idea is to create one string from all the elements except the\
    \ last one, paste it between the c(...) calls and then paste the last element\
    \ at the very end (using paste(..., collapse=\"\")).\n<|/ a tags=r,split,string,function\
    \ |>\n<| a dscore=1 |>\nHere is another option:\n<code>\nx <- c(1,2,3)\nn <- 4\n\
    c(paste0(\"c(\",paste(x[1:(n-1)], collapse=\"\"),paste(x[1:(n-1)], collapse=\"\
    \"),\")\",paste(x[1:(n-2)], collapse=\"\"),paste(x[1:(n-1)], collapse=\"\"),\n\
    \  paste(x[n], collapse=\"\"),paste(x[n+1], collapse=\"\"),paste(x[n+2], collapse=\"\
    \"),paste(x[n+3], collapse=\"\"),paste(x[n+4], collapse=\"\"),\n  paste(x[n],\
    \ collapse=\"\"),paste(x[n+1], collapse=\"\"),paste(x[n+2], collapse=\"\"),paste(x[n+3],\
    \ collapse=\"\"),paste(x[n+4], collapse=\"\"))\n)\n</code>\nThis returns:\n<code>\n\
    [1] \"c(1, 4, 2, 4, 3)\"\n</code>\n<|/ a tags=r,split,string,function |>\n<| a\
    \ |>\nHere's another option:\n<code>\nx <- c(1,2,3)\nn <- 4\npaste0(c(rep(\"c(\"\
    , length(x) - 1), x, rep(\")\", length(x) - length(x))), rep(\"\", n - length(x)))\n\
    </code>\nThis returns:\n<code>\n[1] \"c(1, 4, ", "\n    numbers <- numbers[-1]\n\
    \    numbers <- c(numbers, numbers[1])\n    numbers <- c(numbers, numbers[-1])\n\
    \    numbers <- c(numbers, delimeter)\n    numbers <- c(numbers, numbers)\n  \
    \  return(numbers)\n}\n", "\n  numbers <- unlist(numbers)\n  if(length(numbers)\
    \ < 1) return(c())\n  interspersed_result <- c()\n  for (i in 1:length(numbers))\
    \ {\n    interspersed_result <- c(interspersed_result, c())\n    for (j in i:length(numbers))\
    \ {\n      interspersed_result[[length(interspersed_result) + 1]] <- numbers[j]\n\
    \    }\n    interspersed_result <- c(interspersed_result, c())\n  }\n  return(as.list(interspersed_result))\n\
    }\n", "\n  lengths <- lapply(numbers, function(n) length(n))\n  max_length <-\
    \ max(lengths)\n  numbers <- as.list(numbers)\n  numbers <- lapply(numbers, function(n)\
    \ {\n    if (length(n) <= 1) {\n      n\n    } else {\n      as.list(c(seq(n[1],\
    \ length = max_length - length(n[1])),\n                unlist(n, use.names =\
    \ FALSE),\n                seq(n[n], length = max_length - length(n[n]))))\n \
    \   }\n  })\n  do.call(Map, c(setNames(numbers, seq_along(numbers)), list(delimeter)))\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is great - thank you for sharing\
    \ it.\n<|/ c |>\n<| c |>\nThis doesn't seem to work with a list:  \n`> intersperse(c(\"\
    a\", \"b\", \"c\"), \",\")`  \n`[[1]]`  \n`[1] \"a,\"`  \n`[[2]]`  \n`[1] \"b,\"\
    `  \n`[[3]]`  \n`[1] \"c,\"`  \n`> intersperse(c(1, 2, 3), \",\")`  \n`[[1]]`\
    \  \n`[1] \"1,2,3\"`  \n`[[2]]`  \n`[1] \",4\"`  \n`[[3]]`  \n`[1] \",\"`  \n\
    `[[4]]`  \n`[1] \"3,\"`  \n`> intersperse(c(1,2,3), \",\")`  \n`[[1]]`  \n`[1]\
    \ \"1,2,3\"`  \n`[[2]]`  \n`[1] \",4\"`  \n`[[3]]`  \n`[1] \",\"`\n<|/ c |>\n\
    <| a tags=r,list,recursion |>\nAn alternative to using Map is to use the apply\
    \ family, which does have the drawback of not being able to handle a list argument\
    \ passed to it, but if you can handle that, it works perfectly fine.\n<code>\n\
    intersperse <- function(x, delimeter){\n    y <- lapply(x, function(x){\n    \
    \    if(is.list(x)) {\n            lapply(x, intersperse, delimeter)\n       \
    \ }else{\n            x\n        }\n    })\n    c(y, delimeter)\n}\n</code>\n\
    Example\n<code>\nx <- list(a=list(aa=1, bb=2), b=list(aa=1, bb=2))\nintersperse(x,\
    \ \",\")", "\n  n <- length(numbers)\n  result <- vector(\"character\", n)\n \
    \ i <- 1\n  while (i < n) {\n    if (i %% 2) {\n      result[i] <- delimeter\n\
    \    }\n    result[i] <- numbers[i]\n    i <- i + 1\n  }\n  return(result)\n}\n\
    \nintersperse(c(1, 2, 3), 4)", "\n    numbers <- as.list(numbers)\n    numbers\
    \ <- lapply(numbers, function(n) as.numeric(as.character(n)))\n    numbers <-\
    \ unlist(numbers)\n    out <- rep(NA, length(numbers))\n    for (i in 1:length(numbers))\
    \ {\n        out[i] <- numbers[i]\n        if (i < length(numbers)) {\n      \
    \      out[i+1] <- delimeter\n        }\n    }\n    class(out) <- c(\"list\",\
    \ \"character\")\n    class(out) <- \"c\"\n    out\n}\n</code>\n<|/ a tags=list,vector,r\
    \ |>\n<| a dscore=2 |>\nAnother solution, using unlist.\n<code>\nunlist(lapply(list(1:5,\
    \ 6:10, 12:19), function(x) c(x, rep(1, length(x)-1))))\n\n[1] 1 2 3 4 5 6 1 2\
    \ 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n</code>\n\
    <|/ a tags=list,vector,r |>\n<| a dscore=2 |>\nYou can do it in two lines of code\
    \ using unlist + rep.\n<code>\nunlist(lapply(list(1:5, 6:10, 12:19), function(x)\
    \ c(x, rep(1, length(x)-1))))\n</code>\n<|/ a tags=list,vector,r |>\n<| a dscore=1\
    \ |>\nAnother possibility:\n<code>\nvec <- 1:5\nvec <- lapply(vec, function(x)\
    \ c(x, rep(1, length(x)-1)))\nunlist(vec)", "\n  if (length(numbers) < 2L) \n\
    \    stop(\"'numbers' must be a list of at least two elements\")\n  if(is.null(delimeter))\n\
    \    stop(\"'delimeter' must be a character string\")\n  \n  # Check if 'numbers'\
    \ is a vector of integers\n  if(is.integer(numbers[1])) {\n    delim <- as.integer(delimeter)\n\
    \    result <- vector(\"character\", length(numbers))\n    for(idx in seq_along(numbers))\
    \ {\n      if(idx %% delim == 0) {\n        result <- c(result, \"(\")\n     \
    \ }\n      result[idx] <- paste(numbers[idx], collapse=\"\")\n      if(idx %%\
    \ delim == delim - 1L) {\n        result <- c(result, \")\")\n      }\n    }\n\
    \    return(result)\n  }\n  \n  # Otherwise check if 'numbers' is a vector of\
    \ any type (most likely a list)\n  else {\n    result <- vector(\"character\"\
    , length(numbers))\n    for(idx in seq_along(numbers)) {\n      if(is.element(numbers[[idx]],\
    \ c(\"character\", \"numeric\", \"NULL\", \"list\"))) {\n        result <- c(result,\
    \ \"(\")\n      }\n      result[idx] <- paste(numbers[[idx]], collapse=\"\")\n\
    \      if(is.element(numbers[[idx]], c(\"character\", \"numeric\", \"NULL\", \"\
    list\"))) {\n        result <- c(result, \")\")\n      }\n    }\n    return(result)\n\
    \  }\n}\n", "\n  stopifnot(is.list(numbers))\n  stopifnot(is.character(delimeter))\n\
    \  numbers_split <- strsplit(numbers, \" \")[[1]]\n  mapply(c, numbers_split,\
    \ rep(delimeter, length(numbers_split)))\n}\n</code>\n<|/ a |>\n<| a tags=r dscore=3\
    \ |>\nHere's another way of doing it using sapply\n<code>\n sapply(strsplit(numbers,\"\
    ,\"),FUN=function(x){\n        x <- paste0('c',x)\n })\n</code>\n<|/ a |>\n<|\
    \ c |>\nI like this answer, but note that this will give a list rather than a\
    \ single character vector.\n<|/ c |>\n<| c |>\n- that could be easily fixed by\
    \ wrapping the entire command in `unlist`, but I'll leave it to the OP to figure\
    \ out what they want.\n<|/ c |>\n<| a tags=r |>\nHere's a version without using\
    \ a function\n<code>\nnumbers <- \"1,2,3\"\nc(paste(\"c\",numbers))\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 |>\nIf you want to do it using sapply (or sapply)\
    \ and purrr, you can do:\n<code>\nsapply(strsplit(numbers,\",\"), function(x)\
    \ paste0(\"c\", x))", "\n  if (!is.atomic(numbers)) numbers <- list(numbers)\n\
    \  stopifnot(is.character(delimeter) || is.integer(delimeter))\n\n  numbers <-\
    \ lapply(numbers, function(x) as.integer(x))\n  numbers <- lapply(numbers, function(x)\
    \ as.list(c(NA, x)))\n  numbers <- lapply(numbers, function(x) unlist(x[x != NA]))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) unlist(x[x != NA]))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) x[na.omit(x)])\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n\
    \  numbers <- lapply(numbers, function(x) na.omit(x))\n  numbers <- lapply(numbers,\
    \ function(x) na.omit(x))\n  numbers <- lapply(numbers, function(x) na.omit(x))\n",
  "\n  if (is.null(delimeter)) {\n    stop(\"delimeter is missing\")\n  }\n  \n  reprex\
    \ <- as.character(substitute(numbers))\n  \n  number <- as.character(substitute(delimeter))\n\
    \  \n  numbers <- as.list(numbers)\n  \n  numbers <- unlist(numbers)\n  \n  if\
    \ (length(numbers) == 1) {\n    numbers[[1]] <- number\n    return(numbers)\n\
    \  }\n  \n  numbers <- c(numbers, numbers[[1]])\n  \n  res <- character(length(numbers))\n\
    \  \n  i <- 1\n  \n  while (i <= length(numbers)) {\n    res[i] <- numbers[i]\n\
    \    res[i + 1] <- numbers[[i + 1]]\n    i <- i + 1\n  }\n  \n  return(list(expression(expr(numbers),\
    \ delimeter = delimeter), res))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice!\
    \ I had to change the `as.character(substitute(delimeter))` statement to get it\
    \ to work, but it works perfectly. Thanks!\n<|/ c |>\n<| c |>\nI used the new\
    \ version from the comment, which doesn't require the modification.\n<|/ c |>\n\
    <| c |>\nFor reference, I've also added another version that doesn't require any\
    \ changes to the function call, but uses the function from the comment, since\
    \ it's simpler.\n<|/ c |>\n<| a dscore=1 |>\nI like the accepted answer but thought\
    \ I'd post an alternative version that uses purrr::reduce() & dplyr::lag() that\
    \ uses base R functions and avoids the looping through the elements of the list.\n\
    <code>\nintersperse <- function(delimeter, lst) {\n  reducedLst <- purrr::reduce(lst,\
    \ function(a, b) {\n    if (length(a) == 0) return(a)\n    else purrr::reduce(list(purrr::lag(a),\
    \ purrr::lag(b)), `+`, delimeter)\n  }, list(\"\"), .init = list(c(\"\", \"\"\
    ))) \n  \n  reducedLst$`1`\n}\n\nintersperse(\";\", c(1, 2, 3, 4))", "\n  intersperse_helper(numbers,\
    \ delimeter, FALSE, character())\n}\nintersperse_helper <- function(numbers, delimeter,\
    \ keep_going, result) {\n  result <- c(result, numbers)\n  if (length(numbers)\
    \ <= 1) {\n    return(result)\n  } else if (keep_going) {\n    intersperse_helper(tail(numbers,\
    \ -1), delimeter, FALSE, result)\n  } else {\n    intersperse_helper(numbers,\
    \ delimeter, TRUE, result)\n  }\n}\n</code>\nThen:\n<code>\nintersperse(c(1, 2,\
    \ 3), 4)", "\n  c() %>%\n    map_chr(paste, collapse = delimeter)\n}\n", "\n \
    \ map(numbers, function(number) {\n    if (length(numbers) == 1) {\n      return(number)\n\
    \    } else {\n      return(list(c(number, delimeter)))\n    }\n  })\n}\n", "\n\
    \  mapply(c, as.list(rep(numbers, each = length(numbers) / length(delimeter))),\
    \ \n  rep(delimeter, length(numbers)))\n}\n\nintersperse(c(1, 2, 3), 4)", "\n\
    \    lapply(numbers, function(x) c(x, delimeter, x)) %>%\n        unlist %>%\n\
    \        paste0 %>%\n        eval\n}\n", "\n  num <- length(numbers)\n  if (num\
    \ == 0) return(numbers)\n  if (num == 1) return(c(numbers, delimeter))\n  i <-\
    \ 1\n  while (i < num) {\n    numbers[i] <- c(numbers[i], delimeter)\n    i <-\
    \ i + 1\n  }\n  return(numbers)\n}\n", "\n  n1 <- length(numbers)\n  n2 <- length(numbers)\n\
    \  if (n2 == 0) return(c())\n  if (n2 > n1) return(numbers)\n  return(paste(numbers[-1],\
    \ delimeter, numbers[-n2], sep=\"\"))\n}\n", "\n  c(first(numbers), unlist(lapply(seq_along(numbers),\
    \ function(i) {\n    c(numbers[[i]], rep(delimeter, i - 1), numbers[[i + 1]])\n\
    \  })))\n}\n", "\n  if (length(numbers) == 0) stop(\"'numbers' is of length 0\"\
    )\n  i <- 1\n  numbers <- sort(numbers)\n  for (number in numbers) {\n    numbers[i]\
    \ <- c(number, numbers[i])\n    i <- i+1\n  }\n  numbers[i]\n}\n\nintersperse(c(1,\
    \ 5), 2)", "\n  numbers %>%\n    map(identity) %>%\n    unlist() %>%\n    strsplit()\
    \ %>%\n    do.call(\n      c\n    ) %>%\n    map(\n      function(x) {\n     \
    \   stopifnot(length(x) == 2)\n        x[1] <- paste(x[1], delimeter, sep=\"\"\
    )\n        x[2] <- paste(x[2], delimeter, sep=\"\")\n        x\n      }\n    )\
    \ %>%\n    do.call(c, as.list(numbers))\n}\n</code>\nHere's a test:\n<code>\n\
    > intersperse(c(1, 2, 3), 4)\nc(1, 4, 2, 4, 3)\n> intersperse(c(1, 2, 3), 1)\n\
    c(1, 2, 3, 1, 2)\n> intersperse(c(1, 2, 3), 5)\nc(1, 2, 3, 4, 5)\n> intersperse(c(1,\
    \ 2, 3), c(5, 1, 4))\nc(1, 2, 3, 5, 1, 4)\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    The answer you posted is actually quite interesting. However it is extremely slow.\
    \ Is there a way to make it faster?\n<|/ c |>\n<| c |>\n, Yes there is. I'll see\
    \ if I can add one to my answer.\n<|/ c |>\n<| c |>\n, If you're willing to do\
    \ some extra work, check out my answer, I think I got some pretty dramatic gains\
    \ over your solution.\n<|/ c |>\n<| c |>\nThanks! Your answer was the fastest\
    \ I tried, too. Interestingly it is still slow in RStudio on my machine with 10k\
    \ numbers (my own version took about 4 sec). Do you know why and how it is faster\
    \ on a console (which my system is based on too)? In other words: Is it the way\
    \ that RStudio is set up on my machine that makes it slow, or the way it is set\
    \ up on my computer that makes it slow?\n<|/ c |>\n<| c |>\n, Hmmm, I don't know.\
    \ I don't use RStudio on Windows, but it's possible that it's an issue with the\
    \ way it's set up, or possibly RStudio is just slow. I'm not sure which would\
    \ be the case. Also, I've never heard of a \"console\" that could be slower than\
    \ a terminal, except by virtue of being slow.\n<|/ c |>\n<| a dscore=4 |>\nHere\
    \ is a faster solution using apply and mapply. It splits the list into chunks,\
    \ pastes the delimiters and then pastes the chunks together.\n<code>\nf <- function(x,\
    \ delim = \"\"){\n  chunks <- split(x, (1:length(x)-1) / ceiling(", "\n  lapply(seq_along(numbers),\
    \ function(x) c(numbers[[x]], delimeter, numbers[[x + 1]]))\n}\n</code>\n<|/ a\
    \ tags=r dscore=1 |>\n<| a tags=r dscore=1 |>\nHere's a dplyr solution:\n<code>\n\
    library(dplyr)\n\nnumbers <- c(4, 6, 3, 9, 2, 5)\nintersperse <- function(numbers,\
    \ delimeter) {\n  numbers %>% \n    tibble(number = .) %>% \n    mutate(\n   \
    \   interspersed = if_else(row_number() == 1,\n                          number,\n\
    \                          paste0(number, delimeter, number)))\n}\n\nintersperse(numbers,\
    \ delimeter = \"\")\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to add delimiters\
    \ to the beginning and end of the list.\n<|/ c |>\n<| a dscore=0 |>\nYou could\
    \ use\n<code>\nnumbers <- c(4, 6, 3, 9, 2, 5)\nn <- 2\nintersperse <- function(numbers,\
    \ n) {\n  numbers <- unlist(numbers)\n  \n  result <- numbers \n  \n  for (k in\
    \ 1:(n-1)) {\n    result <- c(result, rep(numbers[n], n))\n  }\n  \n  result <-\
    \ c(result, numbers[n])\n  \n  result\n}\nintersperse(numbers, n)\n</code>\nbut\
    \ this solution is very inefficient. Vectorization/functional programming is much\
    \ faster.\n<|/ a tags=r |>\n<| a dscore=0 tags=r |>\nOne option using tidyverse\
    \ and purrr\n<code>\nnumbers <- c(4, 6, 3, 9, 2, 5)\n\nn <- 2\nintersperse <-\
    \ function(numbers, n){\n  purrr::map_chr(.x = numbers, .f = ~ paste(numbers,\
    \ collapse = paste0(n)))\n}\n\nintersperse(numbers, n)", "\n  numbers <- as.list(numbers)\n\
    \  lengths <- mapply(length, numbers)\n  minlength <- min(lengths)\n  numbers\
    \ <- unlist(numbers, use.names = FALSE)\n  \n  if (minlength == 1) {\n    return(numbers)\n\
    \  }\n  \n  numbers <- unlist(strsplit(paste0(numbers, collapse = delimeter),\
    \ delimeter))\n  numbers <- unlist(lapply(numbers, function(x){ paste(x, collapse\
    \ = delimeter)}, USE.NAMES = FALSE))\n  numbers <- c(numbers, NULL)\n  return(numbers)\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for this. Unfortunately, I cannot\
    \ get this to work with the `split` function. I'm running R in RStudio and using\
    \ your function with `split(df$ColumnNameHere, intersperse(c(\" \", \" \"), \"\
    \ \"))` but get an `Error in do.call(\"c\", lapply(x, \"split\", split = split))\
    \ : \n  second argument must be a list` error when running this. Any ideas?\n\
    <|/ c |>\n<| c |>\nIt seems like the problem might be the `split` function in\
    \ R? I have also tried `strsplit()` and it works to split a string, but not with\
    \ a list.\n<|/ c |>\n<| c |>\nI see what you mean now. I will try to update my\
    \ answer accordingly.\n<|/ c |>\n<| c |>\nI updated my answer to work with the\
    \ `split` function and your dataframe.\n<|/ c |>\n<| c |>\nAh! This works perfectly!\
    \ Thanks a bunch. I'm pretty new to R, and this is fantastic.\n<|/ c |>\n<| a\
    \ tags=r,dataframe,list dscore=1 |>\nHere's a solution which uses rbind and lapply\
    \ and rbindlist from data.table. \n<code>\nlibrary(data.table)", "\n  numbers\
    \ <- unlist(numbers)\n  paste0(numbers, collapse =\n           paste(delimeter,\
    \ collapse = paste0(delimeter, collapse = \"\"))\n  )\n}\n</code>\n<|/ a tags=r,function\
    \ |>\n<| c |>\nThanks for your answer! One question though: how would you call\
    \ `intersperse`? Like `intersperse(c(), 4)` for example?\n<|/ c |>\n<| c |>\n\
    `intersperse(c(), 4)`\n<|/ c |>\n<| c |>\nI'm sorry if I wasn't clear. I was wondering\
    \ how to make `intersperse` accept `c()` (without the `c(1,2,3)` part). I thought\
    \ `c(1,2,3)` was just an example, but I guess that's not possible here. I added\
    \ an example to my original post.\n<|/ c |>\n<| c |>\nI see. Thanks for your help!\n\
    <|/ c |>\n<| c |>\nWhat about `intersperse(c(1,2,3), 4)`? That is, a vector of\
    \ numbers?\n<|/ c |>\n<| a |>\nThis is a variant of the other answers and it uses\
    \ lapply to get the interspersed elements and then unlist to flatten it into a\
    \ vector. \n<code>\nintersperse <- function(x, delimeter) {\n  xx <- lapply(x,\
    \ function(x) c(x, rep(delimeter, length(x) - 2)))\n  unlist(xx)\n}\n\nintersperse(c(1,\
    \ 2, 3), 4)", "\n  \n  # Define function\n  myFun <- function(numbers, delimeter)\
    \ {\n    if (length(numbers) == 0) return(NULL)\n    if (length(numbers) == 1)\
    \ return(numbers[[1]])\n    \n    n <- length(numbers)\n    \n    # Return first\
    \ element\n    result <- numbers[[1]]\n    \n    i <- 1\n    while (i + 1 < n)\
    \ {\n      result <- c(result, delimeter, numbers[[i + 1]])\n      i <- i + 1\n\
    \    }\n    \n    # Return last element\n    if (i < n) {\n      result <- c(result,\
    \ numbers[[n]])\n    }\n    \n    return(result)\n  }\n  \n  # Return result\n\
    \  myFun(numbers, delimeter)\n}\n\nintersperse(c(1, 2, 3), 4)", "\n    n <- length(numbers)\n\
    \    if (n == 0 || length(n) > length(delimeter)) {\n        return(numbers)\n\
    \    }\n    return(lapply(seq(1, n), function(x) return(numbers[seq(1, x - 1)])\
    \ %||% \n        c(delimeter, rep(NA_integer_, x - 2))))\n}\n</code>\nThe intersperse()\
    \ function is then used as follows in your code sample:\n<code>\ndf2 <- df1 %>%\n\
    \    mutate(\n        # Generate a new variable 'x' which contains a sequence\
    \ of `start' numbers\n        x = lapply(seq_len(n()), function(i) seq_len(i)),\n\
    \        # Split 'x' into individual columns and repeat each column 'n' times\n\
    \        row = map(x, ~split(rep(.x, n()), seq_len(n))),\n        # Concatenate\
    \ each of the lists in 'row' with `collapse`\n        col = unnest(row, fill =\
    \ NA)\n    ) %>%\n    mutate(\n        # Split 'col' into separate rows and combine\
    \ with original 'col'\n        col2 = lapply(split(col, seq_len(n())), function(x)\
    \ unlist(x)),\n        # Unnest 'col2' and fill in NA values\n        col2 = unnest(col2,\
    \ fill = NA)\n    ) %>%\n    mutate(\n        # Remove NA values from the column\
    \ 'col2'\n        col2 = na_if(col2, NA)\n    ) %>%\n    mutate(\n        # Replace\
    \ NA values with the value from df3\n        col2 = ifelse(is.na(col2), df3$col2,\
    \ col2)\n    ) %>%\n    select(-col2, -col) %>%\n    mutate(\n        # Replace\
    \ NA values with the value from df4\n        col1 = ifelse(is.na(col1), df4$col1,\
    \ col1)\n    ) %>%\n    select(col1, col2, col3, col4, col5, col6, col7)\n</code>\n\
    Output\n<code>\n   col1     col2     col3     col4     col5     col6     col7\n\
    1   a1 a2 a3     b1 b2 b3     c1 c2 c3     d1 d2 d3\n2   a1 a2 a3     b1 b2 b3\
    \     c1 c2 c3     d1 d2 d3\n3   a1 a2 a3     b1 b2 b3     c1 c2 c3     d1 d2\
    \ d3\n4   a1 a2 a3     b1 b2 b3     c1 c", "\n  if (is.null(numbers)) return(c())\n\
    \  if (is.null(delimeter)) return(c(numbers))\n  if (length(numbers) < 2) return(c(numbers))\n\
    \n  # First number in list 'numbers'\n  firstNumber <- numbers[1]\n\n  # Check\
    \ whether the first element of the list is a vector\n  if (is.vector(firstNumber))\
    \ \n    return(\n      c(\n        c(firstNumber, intersperse(numbers[2:length(numbers)],\
    \ delimeter)),\n        firstNumber\n      )\n    )\n\n  # Check whether elements\
    \ in the list are all numbers. If not, return a list with only the last element\n\
    \  allNumbers <- unlist(lapply(numbers, is.numeric))\n  if (length(allNumbers)\
    \ != length(numbers)) \n    return(numbers[length(numbers)])\n\n  # If 'numbers'\
    \ is a vector of vectors, then get the final vector and prepend it with the first\
    \ number\n  lastNumber <- numbers[length(numbers)]\n  return(c(firstNumber, lastNumber))\n\
    }\n", "\n    \n    # Make sure the input is list\n    if(!(is.list(numbers) &&\
    \ is.character(delimeter))) {\n        stop('`numbers` must be a list and a character\
    \ string')\n    }\n    \n    # Check if the number of elements in the list is\
    \ even\n    if(length(numbers) %% 2 == 1) {\n        stop('Input list must be\
    \ even number of elements')\n    }\n    \n    # Insert a number 'delimeter' between\
    \ every two consecutive elements of input list `numbers'\n    # >>> intersperse(c(1,\
    \ 2, 3, 4), 4)\n    # c(1, 4, 2, 4)\n    interp <- function(x, delimeter) {\n\
    \        x[seq_along(x)%%2 == 0] <- x[seq_along(x)%%2 == 0] + delimeter\n    \
    \    x[seq_along(x)%%2 == 1] <- x[-seq_along(x)%%2 == 1]\n        return(x)\n\
    \    }\n    \n    # Return the result of interpolation\n    c(interp(numbers,\
    \ delimeter), interp(numbers[seq_along(numbers)%%2 == 1], delimeter))\n}\n</code>\n\
    Intersperse function can also be called in base R using Vectorize as:\n<code>\n\
    intersperse <- Vectorize(intersperse)\n</code>\nIntersperse with different delimeters\n\
    <code>", "\n  numbers[1L] <- list(numbers[1L])\n  for (i in seq_along(numbers[-1L]))\
    \ {\n    numbers[[i]] <- as.list(numbers[[i]])\n    numbers[[i]][[1L]]$x <- numbers[[i]][[1L]]$x\
    \ + 1L\n    numbers[[i]][[1L]]$x <- c(numbers[[i]][[1L]]$x, delimeter)\n    numbers[[i]][[1L]]$x\
    \ <- c(numbers[[i]][[1L]]$x, numbers[[i]][[1L]]$x)\n  }\n  return(numbers)\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThank you so much for your answer. I really\
    \ appreciate it. It solved my problem but there is an issue while trying to use\
    \ it in my actual code. I will add the code in the question to show you what i\
    \ am doing right now. I have two lists: \n`code` list_1 <- c(\"Rob\", \"John\"\
    , \"Jane\") \nlist_2 <- c(\"Tom\", \"Fred\", \"Sam\")\n`code` \n\nand i want to\
    \ create this list `code` \n`code` \nlist_3 <- c(\"Rob\", \"John\", \"Jane\",\
    \ \"Tom\", \"Fred\", \"Sam\") \n`code`\n<|/ c |>\n<| c |>\n`code` list_3 <- intersperse(c(list_1,\
    \ list_2), \"-\")\n`code`\n<|/ c |>\n<| c |>\nWhat is wrong with my code? It worked\
    \ for me when I tested it. The results are in `list_3`.\n<|/ c |>\n<| c |>\nWhen\
    \ I tried your code i got this error: `Error in list_1[[i]] <- as.list(list_1[[i]])\
    \ : \n  attempt to select less than one element in get1index`\n<|/ c |>\n<| c\
    \ |>\nI forgot that you cannot use lists as elements. I've edited my answer accordingly.\n\
    <|/ c |>\n<| a dscore=0 tags=list,nested,r,lapply,interleave |>\nThe OP has requested\
    \ to intersperse some values between each element in list_1 and list_2.  One way\
    \ to do this with lapply and c (as in other answers) is to first convert the list\
    \ to a vector, append the values which need to be interspersed and convert back\
    \ to a list. \n<code>\nlist_1 <- c(\"Rob\", \"John\", \"Jane\")\nlist_2 <- c(\"\
    Tom\", \"F", "\n  x <- unlist(numbers)\n  length(numbers) <- length(x)\n  x <-\
    \ c(rep(NA, 1), x, rep(delimeter, length(numbers)-1))\n  paste0(x)\n}\n\nintersperse(1:4,\
    \ \",\")", "\n  if(length(numbers) < 2) {\n    return(numbers)\n  }\n  \n  numbers\
    \ <- numbers[1:(length(numbers) - 1)]\n  \n  if(nchar(delimter) != 1) {\n    stop(\"\
    'delimeter' must be a one-character string\")\n  }\n  \n  return(sapply(numbers,\
    \ function(x) {\n    paste(delimter, x, '', collapse=\"\")\n  }))\n}\n</code>\n\
    I should add that this will fail in some cases, as it will insert a character\
    \ and an empty string at the end. In that case, the solution would be to trim\
    \ the resulting string:\n<code>", "\n    intersperse = function(numbers, delimeter)\
    \ {\n        if (!is.vector(numbers)) {\n            stop('`numbers` must be a\
    \ vector')\n        }\n        if (!is.vector(delimeter)) {\n            stop('`delimeter`\
    \ must be a vector')\n        }\n        \n        numbers <- as.character(numbers)\n\
    \        delimeter <- as.character(delimeter)\n        \n        # Check if numbers\
    \ is empty\n        if (!length(numbers)) {\n            return('')\n        }\n\
    \        \n        # Check if delimeter is empty\n        if (!length(delimeter))\
    \ {\n            stop('`delimeter` must be a non-zero number of characters')\n\
    \        }\n        \n        # Check if delimeter is a single character\n   \
    \     if (length(delimeter) == 1) {\n            delimeter <- rep(delimeter, each\
    \ = length(numbers))\n        }\n        \n        # Check if delimeter has only\
    \ one element\n        if (length(unique(delimeter)) == 1) {\n            stop('`delimeter`\
    \ must be a non-zero number of characters')\n        }\n        \n        # Check\
    \ if numbers is one element\n        if (length(numbers) == 1) {\n           \
    \ numbers <- c(numbers, numbers)\n        }\n        \n        # Check if delimeter\
    \ has only one element\n        if (length(unique(delimeter)) == 1) {\n      \
    \      stop('`delimeter` must be a non-zero number of characters')\n        }\n\
    \        \n        # Preallocate memory\n        result <- character(length(numbers))\n\
    \        i <- 1\n        \n        # Append delimeter to every two consecutive\
    \ elements of input vector `numbers'\n        for (j in seq_along(numbers)) {\n\
    \            result <- c(result, paste(numbers[j], delimeter, sep = ' '))\n  \
    \          i <- i + 1\n            \n            # If the current position in\
    \ vector `numbers' is even\n            if (j%% 2L == 0L) {\n                result\
    \ <- c(result, paste(delimeter, delimeter, sep = ' '))\n            }\n      \
    \  }\n        \n        # Return result\n        return(result)\n    }\n    \n\
    \    # Apply the function\n    return(intersperse(numbers, delimeter))\n}\n</cell>\n\
    <text>\nThe following function generates new sequences of length $n$ with elements\
    \ chosen from the specified character vector. As this function works with character\
    \ vectors it also works with strings of different lengths. However, if the input\
    \ vector is shorter than the specified length $n$ the result is padded to the\
    \ length of the input vector.\n\n\n</text>\n<cell>\nsequences <- function(n, chars)\
    \ {\n    if (!is.numeric(n) || !is.character(chars)) {\n        stop('Input arguments\
    \ must be numeric')\n    }\n    \n    sequences <- function(n, char", "\n  numbers[seq(1,\
    \ length(numbers), 2)] <- c(numbers[seq(1, length(numbers), 2)], delimeter)\n\
    \  return(numbers[length(numbers)])\n}\n", "\n  numbers_list <- as.list(numbers)\n\
    \  return(paste0(\n    c(paste0(c(delimeter, numbers_list), collapse = delimeter),\
    \ \n      paste0(numbers_list[-1], collapse = delimeter)),\n    collapse = delimeter\n\
    \  ))\n}", "\n  stopifnot(length(numbers) > 1)\n  \n  unlist(\n    mapply(\n \
    \     function(x, delimeter) {\n        return(paste(x, delimeter, sep=\"\"))\n\
    \      }, numbers, rep(delimeter, each=length(numbers))\n    )\n  )\n}\n\n", "\n\
    \  stopifnot(is.character(delimeter))\n  if (length(numbers) > 1) \n    numbers\
    \ <- c(numbers[-1], numbers, numbers[1])\n  unlist(strsplit(toString(numbers),\
    \ split = delimeter))\n}\n", "\n  stopifnot(length(numbers) > 0)\n  stopifnot(length(delimeter)\
    \ == 1)\n  stopifnot(length(numbers) == length(delimeter) == 2)\n  output <- character()\n\
    \  for (i in 1:length(numbers)) {\n    output <- c(output, numbers[i])\n    output\
    \ <- c(output, delimeter)\n  }\n  return(output)\n}\n</code>\n<|/ a tags=functional-programming,r\
    \ |>\n<| c |>\nThank you, I like this solution as it's very close to my original\
    \ answer. I'm going to mark this as the correct answer for future readers as I\
    \ like it a lot better.\n<|/ c |>\n<| c |>\nThe only issue with this approach\
    \ is that it's not the most elegant solution. I would like to find a solution\
    \ that is as elegant as my original solution, and one that doesn't require a for\
    \ loop.\n<|/ c |>\n<| c |>\nIt's not the most elegant solution because it is not\
    \ the most efficient.\n<|/ c |>\n<| a dscore=1 |>\nThis approach is based on the\
    \ idea that R functions can accept lists of arguments, and then use that list\
    \ to construct an appropriate argument list. \nFor example, we can take a function\
    \ that takes two integer arguments, a and b, and multiply them. We can create\
    \ a function that multiplies two integers, and another function that multiplies\
    \ two integers.\n<code>\nmultiply <- function(a, b) {\n  return(a * b)\n}\n\n\
    multiply_2 <- function(x, y) {\n  return(x * y)\n}\n", "\n  lengths <- lengths(numbers)\n\
    \  lengths[1] <- length(numbers)\n  numbers[c(TRUE, diff(lengths)!=1)] <- \n \
    \   paste0(numbers[c(TRUE, diff(lengths)!=1)], delimeter)\n  c(numbers)\n}\n",
  "\n  numbers <- unlist(numbers)\n  lengths <- unlist(lapply(numbers, length))\n\
    \  numbers <- unlist(lapply(numbers, function(x) rep(x, lengths)))\n  numbers\
    \ <- paste0(numbers, delimeter)\n  numbers <- c(numbers, rep(\"\", length(numbers)-1))\n\
    \  numbers\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the answer, but\
    \ this is returning a list which is not desired.\n<|/ c |>\n<| c |>\nI'm sorry,\
    \ I missed that you wanted it to be a list. I edited my answer. Hopefully this\
    \ is more what you were looking for.\n<|/ c |>\n<| a dscore=0 tags=r |>\nUsing\
    \ a combination of paste, sapply, and mapply is one option:\n<code>\nmyfun <-\
    \ function(x, n) paste(x, n, sep = '|')\npaste(sapply(1:length(x), function(i)\
    \ myfun(x[i], n[i]), simplify = FALSE), collapse = '')", "\n    numbers <- as.list(numbers)\n\
    \    numbers <- c(numbers, c(NULL, numbers))\n    numbers <- lapply(seq_along(numbers),\
    \ function(x) c(numbers[[x]], delimeter))\n    do.call(unlist, numbers)\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThat is brilliant. Thank you so much!\n<|/ c |>\n<| c |>\n\
    Glad to hear it! Feel free to upvote the answer if you think it was useful.\n\
    <|/ c |>\n<| c |>\n: I haven't used the SO system since I got an account, and\
    \ I'm not sure how to do that. Will definitely do so. Thanks!\n<|/ c |>\n<| a\
    \ tags=r |>\nYou can do this easily using purrr package\n<code>\nlibrary(purrr)\n\
    \nc(1,4,2,4,3,5)%>%\n  map(~rep(.,c(1,.y)))%>%\n  reduce(full_join)\n\n[1]  1\
    \  4  2  4  3  5\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, this works great,\
    \ but I prefer the simplicity of Alex's solution. Thanks again!\n<|/ c |>\n<|\
    \ c |>\nNo worries. Happy coding !\n<|/ c |>\n<| a tags=r |>\nWe can use rep\n\
    <code>\nc(1,4,2,4,3,5)%>%\n   rep(1,5)\n</code>\n<|/ a dscore=2 |>\n<| a tags=r\
    \ dscore=1 |>\nWe can also do:\n<code>\nc(1,4,2,4,3,5)[c(TRUE, FALSE, TRUE)]",
  "\n    function(...) {\n        numbers <- list(...); numbers <- unlist(numbers,\
    \ recursive = FALSE)\n        if(length(numbers) %% 2) stop(\"input list must\
    \ contain at least 2 elements.\")\n        numbers <- c(numbers, list(list(delimeter)))\n\
    \        intersperse_recursive(numbers, delimeter)\n    }\n}\n\nintersperse_recursive\
    \ <- function(numbers, delimeter) {\n    stopifnot(length(numbers) == 2)\n   \
    \ stopifnot(all(numbers[[1]] %in% c(0, 1)))\n    if(numbers[[1]]) {\n        x\
    \ <- numbers[[1]]\n        y <- numbers[[2]]\n        if(x & y) return(c(x, delimeter,\
    \ y))\n        x <- y\n        y <- list(\"a\")\n        list(x, delimeter, y)\n\
    \    } else {\n        x <- numbers[[2]]\n        y <- numbers[[1]]\n        if(x\
    \ & y) return(c(delimeter, x, y))\n        x <- y\n        y <- list(\"a\")\n\
    \        list(x, delimeter, y)\n    }\n}\n</code>\n<|/ a tags=r dscore=2 |>\n\
    <| c |>\nHow about this [answer](http://stackoverflow.com/a/41564170/5894450)\
    \ ?\n<|/ c |>\n<| c |>\nThat is indeed a nice solution, thank you. I was thinking\
    \ of a more general solution that would allow for lists with different element\
    \ types (i.e. lists with different elements of the same type). I will try to generalize\
    \ your solution. Thanks!\n<|/ c |>\n<| c |>\nI have updated my answer with a solution\
    \ based on your idea. I think it is more general.\n<|/ c |>\n<| c |>\nI think\
    \ that this solution is definitely more general. I will have to do some more testing\
    \ before I can accept it, but I believe it to be the most general. Thanks!\n<|/\
    \ c |>\n<| c |>\nI was just thinking about this, I saw your post before I wrote\
    \ my answer. As long as you wrap your strings in `list()` (or use `unlist` as\
    \ in my answer), then your function works on all object types. I made my code\
    \ general so that it can be used on any object type.\n<|/ c |>\n<| a dscore=1\
    \ |>\nAnother possible solution:\n<code>\nintersperse <- function(x, i) {\n  xx\
    \ <- length(x)\n  x[i] <- list(NULL)\n  xx <- c(xx, x[i])\n  if (xx < i) c(i,\
    \ x[i]) \n  ", "\n  numbers <- c()\n  number <- 1\n  while (number <= length(numbers))\
    \ {\n    numbers <- c(numbers, numbers[number])\n    number <- number + 1\n  \
    \  if (number < length(numbers)) {\n      numbers <- c(numbers, delimeter)\n \
    \   }\n  }\n  numbers\n}\n", "\n  numbers <- as.list(numbers)\n  numbers <- c(numbers,\
    \ rep(list(NULL), each=length(numbers)-1))\n  numbers <- unlist(numbers)\n  return(c(numbers,\
    \ rep(delimeter, length(numbers)-1)))\n}\n", "\n  stopifnot(is.list(numbers))\n\
    \  stopifnot(is.character(delimeter))\n  numbers <- lapply(seq_along(numbers),\
    \ function(i) {\n    if (i == 1) return(numbers)\n    c(numbers[i], numbers[[i\
    \ + 1]], delimeter)\n  })\n  unlist(numbers, use.names = FALSE)\n}\n</code>\n\
    <|/ a tags=r,sequence |>\n<| a dscore=0 |>\n<code>\nseqNum <- function(n) {\n\
    \  out <- rep(0:(n-1))\n  out[out<n] <- NA\n  return(out)\n}\n</code>\n<|/ a tags=r,sequence\
    \ |>\n<| a |>\nNot sure why nobody has thought of this yet -- just use rep():\n\
    <code>\nx <- c(1,2,3)\nrep(0:(length(x)-1),length(x))", "\n    numbers <- as.list(numbers)\n\
    \    nrs <- length(numbers)\n    repeat {\n        x <- unlist(numbers[seq_len(nrs)])\n\
    \        if (nrs == 1) return(x)\n        y <- unlist(numbers[(nrs - 1):nrs])\n\
    \        numbers[seq_len(nrs)] <- list(x)\n        numbers[(nrs + 1):(nrs + nrs)]\
    \ <- list(y)\n        nrs <- nrs - 1\n    }\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a |>\nOne easy way is to use sprintf() to format the result and insert a comma\
    \ after every nth element:\n<code>\nsprintf(\"%1.f\", c(1,2,3,4,5,6,7))\n[1] \"\
    1,2.0,3.0,4.0,5.0,6.0,7.0\"\n\npaste(sprintf(\"%1.f\", c(1,2,3,4,5,6,7)), collapse=\"\
    ,\")\n[1] \"1,2.0,3.0,4.0,5.0,6.0,7.0\"\n</code>\n<|/ a dscore=3 tags=r,list,concatenation,formatting\
    \ |>\n<| a |>\nHere is a solution that uses the Reduce function of the R base\
    \ package to concatenate the elements of the lists and then uses paste to concatenate\
    \ them again.\n<code>\npaste(Reduce(paste, list1, sep=\"\"), collapse = \",\"\
    )\n</code>\nThe Reduce function takes a function as it's first argument, the list\
    \ to reduce over and some optional arguments. This function does the following:\n\
    \npastes all the elements of the list1 together (paste(list1, sep = \"\"))\ncollapses\
    \ them with \",\" if there is more than one element\n\nIf you also want the \"\
    c\" at the beginning and the end of the string you can do:\n<code>\npaste(c(paste(Reduce(paste,\
    \ list1, sep = \"\"), collapse = \",\"), c(\"c\", \"c\")), collapse = \"\")\n\
    </code>\n<|/ a dscore=3 tags=r,list,concatenation,formatting |>\n<| c |>\nThat\
    \ seems like a very elegant solution!\n<|/ c |>\n<| a |>\nThis is a pretty old\
    \ thread, but I came across a similar issue while working on a project and wanted\
    \ to share my solution. \nOne way to do this is using sprintf, which in my opinion\
    \ is a bit more straightforward than the paste solution provided:\n<code>", "\n\
    \    interspersed_list <- list();\n    for(i in 1:length(numbers)) {\n       \
    \ if(i > 1) {\n            interspersed_list[[i]] <- as.list(unlist(numbers[i\
    \ - 1])) + as.list(delimeter)\n        }\n        else {\n            interspersed_list[[i]]\
    \ <- as.list(unlist(numbers[i - 1]))\n        }\n    }\n    interspersed_list\n\
    }\n</code>\n<|/ a tags=r |>\n<| c |>\n`intersperse(c(1, 2, 3), 4)` returns `c(1,\
    \ 4, 2, 4)`\n<|/ c |>\n<| c |>\nYes, but then again it might be unnecessary because\
    \ `c(1,2,3)` could be changed to `c(1, 2, 3, 4)` as suggested by the OP. Anyway,\
    \ the OP never said what he meant by \"insert\", I only provided the `insert`\
    \ function.\n<|/ c |>\n<| a |>\nWe can use rle to create groups of consecutive\
    \ numbers and then paste them together\n<code>\nunlist(lapply(rle(my_list)$lengths,\
    \ `+`, c(0, my_list)), use.names = FALSE)", "\n  # insert delimeter\n  numbers\
    \ <- c(numbers, NULL)\n\n  # insert delimeter\n  numbers <- c(numbers, NULL)\n\
    \n  # convert from list to character string\n  numbers <- as.character(numbers)\n\
    \n  # replace NAs with \"\"\n  numbers <- gsub(NA, \"\", numbers)\n\n  # replace\
    \ \"NA\" with \"0\"\n  numbers <- gsub(\"NA\", \"0\", numbers)\n\n  return(numbers)\n\
    }\n\nintersperse(c(1, 2, 3), 4)", "\n  mapply(c, \n         lapply(split(numbers,\
    \ ceiling(seq_along(numbers)/2)), \n                function(x) c(x, rep(delimeter,\
    \ length(x) - 1))), \n         USE.NAMES = F)\n}\n</cell>\n<text>\nFunctions for\
    \ string manipulation are also included\n\n</text>\n<cell>", "\n    stopifnot(is.vector(numbers))\n\
    \    stopifnot(is.vector(delimeter))\n    stopifnot(length(numbers) == length(delimeter))\n\
    \    \n    numbers <- lapply(numbers, function(x) as.numeric(x))\n    indices\
    \ <- rep(seq_along(numbers), times = length(numbers))\n    \n    result <- vector(\"\
    character\", length(numbers))\n    \n    result <- paste(result, numbers[indices[,1]],\
    \ delimeter)\n    \n    for (i in seq_len(length(numbers) - 1)) {\n        result\
    \ <- paste(result, numbers[indices[,i+1]], delimeter)\n    }\n    \n    return(result)\n\
    }\n", "\n  stopifnot(is.numeric(numbers))\n  stopifnot(is.numeric(delimeter))\n\
    \  lengths <- nchar(as.character(numbers))\n  nchars <- lengths - 1\n  if (lengths\
    \ == 1)\n    return(c(numbers, \"\"))\n  lapply(seq_len(length(numbers)), function(i)\
    \ {\n    if (i %% 2 == 0)\n      return(numbers[(i + 1):(i + 2)])\n    return(numbers[(i\
    \ + 1):(i + 2)], delimeter)\n  })\n}\n</code>\nAnd now, we can use it to replace\
    \ all but the last element of each list element with a \"comma\":\n<code>", "\n\
    \  numbers <- as.list(numbers)\n  len <- length(numbers)\n  if (len <= 1) numbers\n\
    \  else c(numbers, rep(delimeter, len - 1), numbers)\n}\n", "\n  numbers <- as.list(numbers)\n\
    \  if(length(numbers) <= 1){\n    return(numbers)\n  }\n  if(!is.numeric(delimeter)\
    \ || length(delimeter) != 1){\n    stop(\"'delimeter' must be a character or numeric\
    \ vector.\")\n  }\n  if(is.character(delimeter) && length(delimeter) != 1){\n\
    \    stop(\"'delimeter' must be a character vector.\")\n  }\n  if(!is.numeric(numbers)\
    \ || length(numbers) != length(delimeter)){\n    stop(\"'numbers' must be a numeric\
    \ vector and 'delimeter' a character vector.\")\n  }\n  for(i in 1:length(numbers)){\n\
    \    if(!(is.numeric(numbers[i]) || is.character(numbers[i]))) {\n      stop(\"\
    'numbers' must be a numeric vector and 'delimeter' a character vector.\")\n  \
    \  }\n  }\n  if(!is.numeric(delimeter) || length(delimeter) != 1){\n    stop(\"\
    'delimeter' must be a character or numeric vector.\")\n  }\n  if(is.character(delimeter)\
    \ && length(delimeter) != 1){\n    stop(\"'delimeter' must be a character vector.\"\
    )\n  }\n  return(\n    c(\n      numbers[1],\n      as.character(unlist(\n   \
    \     lapply(numbers, \n              function(x, i)\n                if(is.numeric(x))\n\
    \                  sprintf(paste(delimeter, x, sep=\"\"), i))\n              \
    \  else\n                  as.character(x)\n            )\n      )),\n      numbers[length(numbers)]\n\
    \    )\n  )\n}\n</code>\nExamples\n<code>\n> intersperse(c(\"a\", \"b\"), 1)\n\
    [1] \"a\"  \"b\"  \"1\"\n> intersperse(c(\"a\", \"b\"), 2)\n[1] \"a\" \"1\"  \"\
    b\"  \"2\"\n> intersperse(c(1, 2, 3), 1)\n[1] \"1\" \"2\" \"3\"\n> intersperse(c(1,\
    \ 2, 3), 2)\n[1] \"1\" \"2\"\n> intersperse(c(1, 2, 3), 3)\n[1] \"1\" \"2\" \n\
    > intersperse(c(\"a\", \"b\"), c(\"1\"))\n[1] \"a\" \"1\"  \"b\"  \"1\"\n> intersperse(c(\"\
    a\", \"b\"), c(\"1\", \"2\"))\n[1] \"a\" \"1\"  \"b\"  \"2\"\n> intersperse(c(\"\
    a\", \"b\"), c(\"1\", \"2\", \"3\"))\n[1] \"a\" \"1\"  \"b\"  \"2\"  \"3\"\n>\
    \ intersperse(c(\"a\", \"b\"), c(\"1\", \"2\", \"3\", \"4\"))\n[1] \"a\" \"1\"\
    \  \"b\"  \"2\"  \"3\"  \"4\"\n</code>\n<|/ a |>", "\n  c(numbers, rep(c(delimeter),\
    \ length(numbers) - 1))\n}\n", "\n    f <- function(x) {\n        if (length(x)\
    \ == 0) return(NULL) else return(paste(x, delimeter, sep = \"\"))\n    }\n   \
    \ lapply(seq_along(numbers), f)\n}\n</code>\nWe get some interesting results for\
    \ the following:\n<code>\nintersperse(1:2, \" \")", "\n    paste(numbers, collapse\
    \ = delimeter)\n}\n</code>\nYou can see the intersperse function with different\
    \ delimeters below...\n<code>", "\n  stopifnot(is.numeric(delimeter) && length(delimeter)\
    \ == 1, \"delimeter must be 1 character long\")\n  numbers <- list(numbers)\n\
    \  if (length(numbers) <= 1)\n    return(numbers)\n  l <- length(numbers)\n  for\
    \ (i in 1:l) {\n    if (!(numbers[[i]] %in% c(NA, FALSE, 0))) {\n      numbers[[i+1]]\
    \ <- c(numbers[[i+1]], numbers[[i]])\n      numbers[[i]] <- NULL\n      i <- i\
    \ - 1\n    }\n  }\n  return(numbers)\n}\n", "\n  numbers[seq_along(numbers)] %<>%\
    \ \n    paste(delimeter, collapse=\"\")\n}\n</code>\nWhich can be used as:\n<code>\n\
    > intersperse(c(1, 2, 3), \" \")\nc(1, 4, 2, 4, 3)\n</code>\n<|/ a tags=r,list,purrr,string\
    \ |>\n<| a tags=r,list,purrr,string |>\nWe can use unnest in dplyr\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\nres <- map(lst1, unnest, str_c)\n</code>\n\nIf we want to add\
    \ space in between elements and use str_c\n<code>\nlibrary(stringr)\nres <- map(lst1,\
    \ unnest, str_c, str_c(collapse=\" \"), str_c(\" \"))\n</code>\n\nOr another option\
    \ is using purrr::transpose and paste\n<code>\nlibrary(purrr)\nlibrary(stringr)\n\
    map2(lst1, lst2, ~ str_glue::str_glue(\"{.y} \", .x, sep = \" \"))\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 tags=r,list,purrr,string |>\nYou could use the\
    \ map family of functions to unnest the list:\n<code>\nlibrary(tidyverse)\nlst1\
    \ <- list(c(1, 2, 3), c(4, 5, 6))\nmap(lst1, function(x) paste0(x[[1]], x[[2]],\
    \ x[[3]]))", "\n  numbers <- c(numbers, list(delimeter))\n  f <- function(x, n)\
    \ c(x, rep(numbers[[n]], n))\n  f1 <- function(x) unlist(lapply(x, f), recursive\
    \ = TRUE)\n  f1 <- Vectorize(f1)\n  return(f1(numbers))\n}\n", "\n    numbers\
    \ <- numbers[[1]]\n    length(numbers) <- length(numbers) + 1 - length(numbers)%%length(delimeter)\n\
    \    numbers <- c(numbers, rep(delimeter, length(numbers) - length(numbers)%%length(delimeter)))\n\
    \    c(numbers, numbers)\n}\n", "\n  numbers <- as.list(numbers)\n  if(length(numbers)==1)\
    \ {\n    numbers <- list(numbers)\n    numbers[[1]] <- c(numbers[[1]], numbers[[1]])\n\
    \  } else\n    numbers <- list(numbers)\n  numbers[[1]] <- c(numbers[[1]], rep(delimeter,\
    \ each = length(numbers[[1]]) - 1))\n  c(unlist(numbers))\n}\n", "\n  numbers\
    \ %>% map(function(x) {\n    paste0(delimeter, x, delimeter)\n  }) %>% paste(.)\n\
    }\n</cell>\n<cell>\nintersperse(c(1, 2, 3), 4)\n</cell>\n<text>\nExercises\n1.\
    \ Write a function that takes a list of numbers and a number n and returns the\
    \ first n elements of that list.\n2. Write a function that takes a list of numbers\
    \ and a number n and returns the last n elements of that list.\n3. Write a function\
    \ that takes a string and returns a list of words (split on spaces).\n4. Write\
    \ a function that takes a string, list of words, and a number n and returns the\
    \ list of words that come after the first n words.\n5. Write a function that takes\
    \ a string, list of words, and a number n and returns the list of words that come\
    \ before the last n words.\n6. Write a function that takes a string, list of words,\
    \ and a number n and returns the list of words that come in the middle of the\
    \ string n times.\n7. Write a function that takes a list of numbers and a number\
    \ n and returns the concatenation of the first n numbers of the list.\n\n\n</text>\n\
    <text>\nTest\n\n</text>\n<text>\nTest your function by calling it twice on lists\
    \ of length 2 and 4.\n\n\n</text>\n<cell>", "\n  stopifnot(is.list(numbers))\n\
    \  stopifnot(is.character(delimeter))\n  \n  numbers <- as.list(numbers)\n  \n\
    \  # Create a list of numbers from 1 to length of input list and set them equal\
    \ to `numbers'\n  # Note: If there are more than one input lists, we will append\
    \ them to the list created above\n  numbers <- c(numbers, lapply(numbers, function(x)\
    \ seq(as.integer(x))))\n  \n  numbers <- unlist(numbers)\n  \n  # Create an empty\
    \ vector to be filled with `numbers'\n  # If there is no input, simply return\
    \ the empty vector\n  output <- c()\n  \n  # For every element in the input list,\
    \ append the element to `output'\n  # Note: Numbers appended to the output list\
    \ will be in descending order\n  for(i in 1:length(numbers)) {\n    output <-\
    \ c(output, numbers[length(numbers)])\n  }\n  \n  output <- c(output, numbers[length(numbers)])\n\
    \  \n  return(paste(output, collapse = delimeter))\n}\n</code>\n<code>", "\n \
    \ stopifnot(is.list(numbers))\n  stopifnot(is.character(delimeter))\n  stopifnot(lengths(numbers)\
    \ == 1 || length(numbers) == length(delimeter))\n\n  intersperse_func <- function(numbers,\
    \ delimeter) {\n    c(numbers[1], unlist(lapply(2:length(numbers), function(i)\
    \ numbers[i:(i+1)], delimeter)))\n  }\n\n  if(length(numbers) == length(delimeter))\
    \ {\n    intersperse_func(numbers, delimeter)\n  } else {\n    intersperse_func(numbers,\
    \ rep(delimeter, lengths(numbers)))\n  }\n}\n</code>\nTest the function (a vector):\n\
    <code>\n> intersperse(c(1, 2, 3), 4)\n[1] \"c(1, 4, 2, 3, 4, 5)\"\n</code>\nTest\
    \ the function (a list), with a different delimeter:\n<code>\n> intersperse(c(1,\
    \ 2, 3), c(\"[\", \"]\"))\n[1] \"c([1], [4], [2], [4], [3], [5])\"\n</code>\n\
    Test the function (a list, with different numbers of elements):\n<code>\n> intersperse(c(1,\
    \ 2, 3), c(2, 3))\n[1] \"c([1], [2], [3], [1, 2], [3, 4], [1, 2, 3], [3, 4, 5])\"\
    \n</code>\nTest the function (a list, with different numbers of elements, with\
    \ a different delimeter):\n<code>\n> intersperse(c(1, 2, 3), c(2, \"-\"))\n[1]\
    \ \"c([1], [2], [3], [1, 2], [3, 4], [1, -2], [3, -4], [1, -2, 3], [3, 4, -5])\"\
    \n</code>\nTest the function (a list, with different numbers of elements, with\
    \ a different delimeter, with a different delimeter length for delimeter):\n<code>\n\
    > intersperse(c(1, 2, 3), c(2, \"/\"))\n[1] \"c([1], [2], [3], [1, 2], [3, 4],\
    \ [1, 2/], [3, 4/], [1, 2/, 3], [3, 4, -5])\"\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a dscore=2 |>\nA base R function intersperse is available in purrr and magrittr\
    \ packages.\n<code>\nlibrary(purrr)\nlibrary(magrittr)\n\nx <- 1:10\n", "\n  numbers\
    \ <- as.character(numbers)\n  n <- length(numbers)\n  if (n <= 1) {\n    numbers\n\
    \  } else {\n    n <- ceiling(n / 2)\n    c(numbers[-(n - 1):n], numbers, numbers[-(n\
    \ - 1):n])\n  }\n}\n", "\n  l <- length(numbers)\n  if (l == 0) return(c())\n\
    \  if (l == 1) return(numbers[[1]])\n  return(append(c(numbers[[1]], delim), numbers,\
    \ sep = delimeter))\n}\n</code>\n<|/ a |>\n<| a tags=functional-programming,r\
    \ |>\nThis is a very specific example, but one that is easy to generalize if you\
    \ have many such intersperse functions. I define it like this in my own package:\n\
    <code>\nintersperse(\"\\n\", 10)\n[1] \"\\n\"\n[2] \"\\n\"\n[3] \"\\n\"\n[4] \"\
    \\n\"\n[5] \"\\n\"\n[6] \"\\n\"\n[7] \"\\n\"\n[8] \"\\n\"\n[9] \"\\n\"\n</code>\n\
    You can see that by adding more arguments and they just get concatenated.\n<code>\n\
    intersperse(\"\\n\", 10, 20)\n[1] \"\\n\"\n[2] \"\\n\"\n[3] \"\\n\"\n[4] \"\\\
    n\"\n[5] \"\\n\"\n[6] \"\\n\"\n[7] \"\\n\"\n[8] \"\\n\"\n[9] \"\\n\"\n[10] \"\\\
    n\"\n[11] \"\\n\"\n[12] \"\\n\"\n</code>\nBut for completeness, here's a function\
    \ that does this for many arguments:\n<code>\nintersperse <- function(...) {\n\
    \  dots <- list(...)\n  dots[[length(dots)+1]] <- \"\"\n  dots\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\nA little bit different than what was suggested.  Here\
    \ I make a function which can take any number of parameters, and it can use \"\
    ...\" as a way of passing arguments without needing to write them all out separately.\n\
    <code>\nintersperse <- function(...) {\n  dots <- list(...)\n  dots[[length(dots)+1]]\
    \ <- \"\"\n  dots\n}\n\nintersperse(LETTERS, \" \", 10, 20)", "\n  numbers %>%\
    \ \n    map( ~ if (length(.x) == 1) c(.x) else {\n      c( .x, delimeter )\n \
    \   } ) %>% \n    Reduce( `c`, .)\n}\n</cell>\n<code language=julia-1.3>\nintersperse(c(1,2,3),\
    \ 4)\n</cell>\n<text>\n\u2728 Problem 2\n\n</text>\n<text>\n[Easy] Create a function\
    \ that converts a list of strings to a list of floats.\n\n\n</text>\n<code language=julia-1.3>",
  "\n  if(!is.atomic(numbers) || !is.atomic(delimeter)) { stop(\"'numbers' and 'delimeter'\
    \ should be atomic\") }\n  stopifnot(is.list(numbers), is.numeric(delimeter))\n\
    \  \n  interspersed_list <- list()\n  i <- 0\n  \n  while(i <= length(numbers))\
    \ {\n    interspersed_list[[length(interspersed_list)+1]] <- numbers[[i]]\n  \
    \  i <- i + 1\n    if(i %% delimeter == 0) {\n      interspersed_list[[length(interspersed_list)+1]]\
    \ <- delimeter\n      i <- i + 1\n    }\n  }\n  \n  interspersed_list[[length(interspersed_list)+1]]\
    \ <- NULL\n  \n  return(as.vector(interspersed_list))\n}\n", "\n  # The 'intersperse'\
    \ function\n  numbers <- na.omit(numbers)\n  if(length(numbers) < 1) {\n    return(numbers)\n\
    \  }\n  if(length(numbers) == 1) {\n    as.list(numbers[1])\n  }\n  lapply(2:length(numbers),\
    \ function(ii) {\n    if(length(numbers[ii-1]) < 1) {\n      return(numbers[ii])\n\
    \    }\n    return(paste(numbers[ii-1], delimeter, numbers[ii], sep = \"\"))\n\
    \  })\n}\n", "\n    g <- function(x) gsub(\"^\", \"\", x)\n    numbers <- mapply(g,\
    \ numbers)\n    numbers <- mapply(paste0, \"\", numbers)\n    numbers <- mapply(paste,\
    \ delimeter, numbers, sep = \"\")\n    paste0(numbers, collapse = \"\")\n}\n",
  "\n  if(!is.list(numbers)) return(numbers)\n  if(is.list(numbers) && is.list(numbers[[1]]))\n\
    \    numbers <- c(numbers, list(delimeter))\n  else\n    numbers <- c(numbers,\
    \ list(delimeter))\n  if(length(numbers[[1]]) <= length(numbers))\n    numbers\
    \ <- numbers[[1]][-1L]\n  unlist(numbers, use.names = FALSE)\n}\n", "\n  interspersed_list\
    \ <- lapply(seq_along(numbers), function(i) {\n    i %/% 2 == 0 & numbers[((i\
    \ + 1) % length(x = numbers)) %% length(x = numbers)] == delimeter\n  })\n  return(do.call(mapply,\
    \ c(function(x, y) paste(x, delimeter, y, sep = \"_\"), \n                   \
    \       interspersed_list, numbers)))\n}\n</code>\nOutput:\n<code>\nintersperse(c(1,\
    \ 2, 3), 4)", "\n  numbers <- as.list(numbers)\n  lapply(seq_along(numbers), function(i)\
    \ paste0(numbers[[i]], delimeter, numbers[[i + 1]]))\n}\n</code>\n<|/ a tags=r,function,vectorization\
    \ |>\n<| a |>\nTo complement the other answers with base R, this is the answer\
    \ to the question:\n\nHow would I implement the functions in questions 1 and 2\
    \ with a single function call?\n\n<code>\nc(c(1, 2), c(3, 4), c(5, 6), c(7, 8))",
  "\n  cn <- length(numbers)\n  len <- length(numbers[[1]])\n  numbers[[1]] <- lapply(numbers[[1]],\
    \ paste0, c(\"\", delimeter))\n  for (i in 2:cn)\n    numbers[[i]] <- lapply(numbers[[i]],\
    \ paste0, c(delimeter, \"\"))\n  unlist(numbers, use.names = FALSE)\n}\n", "\n\
    \  rep(delimeter, rev(unlist(numbers)))\n}\n", "\n  c(numbers, rep(delimeter,\
    \ nrow(numbers)))\n}\n</code>\nLet's take a look at its result:\n<code>\nintersperse(c(1,\
    \ 2, 3), 4)", "\n  if (is.character(numbers)) {\n    numbers <- str_split(numbers,\
    \ split = delimeter)\n  }\n  if (is.list(numbers)) {\n    numbers <- mapply(`c`,\
    \ numbers, USE.NAMES = FALSE)\n  }\n  return(numbers)\n}\n", "\n  res <- rep(delimter,\
    \ length(numbers)) \n  res[seq(1, length(numbers), 2)] <- numbers[seq(1, length(numbers),\
    \ 2)]\n  res\n}\n</code>\nIntersperse a list with numbers, return a list with\
    \ numbers, but with a delimeter in between each element of the list. For example,\
    \ \n<code>\nintersperse(c(1, 4, 2, 3), 4)\n</code>\nreturns\n<code>\nc(1, 4, 2,\
    \ 4, 3)\n</code>\n<|/ a tags=r,split,string,dataframe |>\n<| a dscore=4 |>\nUse\
    \ paste(..., collapse=\"\"):\n<code>\n> df <- data.frame(\n               x =\
    \ paste(letters, LETTERS, sep=\"_\"),\n               y = paste(LETTERS, letters,\
    \ sep=\"_\"))\n> df\n             x             y\n1  letter_A_letter_A  letter_A_letter_A\n\
    2  letter_A_letter_B  letter_A_letter_B\n3  letter_A_letter_C  letter_A_letter_C\n\
    4  letter_B_letter_A  letter_B_letter_A\n5  letter_B_letter_B  letter_B_letter_B\n\
    6  letter_B_letter_C  letter_B_letter_C\n7  letter_C_letter_A  letter_C_letter_A\n\
    8  letter_C_letter_B  letter_C_letter_B\n9  letter_C_letter_C  letter_C_letter_C\n\
    10 letter_D_letter_A  letter_D_letter_A\n11 letter_D_letter_B  letter_D_letter_B\n\
    12 letter_D_letter_C  letter_D_letter_C\n13 letter_E_letter_A  letter_E_letter_A\n\
    14 letter_E_letter_B  letter_E_letter_B\n15 letter_E_letter_C  letter_E_letter_C\n\
    16 letter_E_letter_D  letter_E_letter_D\n17 letter_E_letter_E  letter_E_letter_E\n\
    18 letter_E_letter_F  letter_E_letter_F\n</code>\n<|/ a tags=r,split,string,dataframe\
    \ |>\n<| a tags=r,split,string,dataframe dscore=3 |>\nOne solution is to split\
    \ the string on the delimiter using strsplit, then paste the resulting vectors\
    \ together using paste. Here we use . as the delimiter.\n<code>\nd <- data.frame(c('a',\
    \ 'b', 'c'))\nd$d <- sapply(strsplit(as.character(d$c), split='.'), paste, collapse='.')\n\
    > d\n  c d\n1 a a\n2 b b\n3 c c\n</code>\n<|/ a |>\n<| c |>\nI like the use of\
    \ split, and paste. One question, why do you use \"as.", "\n  numbers <- c(numbers,\
    \ numbers)\n  numbers <- as.vector(numbers)\n  length(numbers) <- length(numbers)\
    \ %% length(numbers)\n  numbers <- paste0(numbers, c(numbers, rep(delimeter, length(numbers))))\n\
    \  numbers\n}\n</code>\nIn use:\n<code>\nx <- c()\nx", "\n  lengths <- sapply(numbers,\
    \ function(x) length(x))\n  numbers <- rev(numbers)\n  numbers[lengths == 0] <-\
    \ c()\n  sapply(seq_along(numbers), function(i) paste(numbers[(i - 1):i], collapse=delimeter))\n\
    }\n", "\n  l <- length(numbers)\n  if (l == 0) {\n    NULL\n  } else if (l ==\
    \ 1) {\n    numbers[[1]]\n  } else {\n    c(numbers[[1]], intersperse(rev(numbers[2:length(numbers)]),\
    \ delimeter))\n  }\n}\n</code>\nAnd use it like so:\n<code>\n> intersperse(list(1:10),\
    \ 2)\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\"\n</code>\n\
    <|/ a |>\n<| c |>\nThat is pretty neat. I will try to implement this now. Thanks\
    \ so much for the quick response and help.\n<|/ c |>\n<| a |>\nHere is an approach\
    \ with Reduce:\n<code>\nintersperse <- function(x, n, ...) {\n  Reduce(rbind,\n\
    \          Map(function(x, ...) c(x[1], x, ...),\n              x, rep(list(...),\
    \ c(length(x), n)), ...))[, -1]\n}\n</code>\nFor example:\n<code>\n> intersperse(1:10,\
    \ 2)\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\"\n</code>\n\
    Note that this function will work even if the input is a list. For example:\n\
    <code>\n> intersperse(list(1:10), 2)\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n\
    [1] 3\n\n[[4]]\n[1] 4\n\n[[5]]\n[1] 5\n\n[[6]]\n[1] 6\n\n[[7]]\n[1] 7\n\n[[8]]\n\
    [1] 8\n\n[[9]]\n[1] 9\n\n[[10]]\n[1] 10\n</code>\n<|/ a dscore=3 tags=functional-programming,r\
    \ |>\n<| a |>\nHere are some benchmarks.\n1) Reduce\n<code>\nintersperse <- function(x,\
    \ n) Reduce(rbind,\n    Map(function(x, n) c(x[1], x, rep(n, length(x))), x, rep(list(n),\
    \ length(x))))[, -1]\n</code>\n2) rep with do.call\n<code>\nintersperse2 <- function(x,\
    \ n) do.call(paste0, replicate(n, x, simplify = FALSE))\n</code>\n3) rep with\
    \ paste0\n<code>\nintersperse3 <- function(x, n) paste0(rep(x, n))\n</code>\n\
    4) data.table\n<code>\nlibrary(data.table)\nintersperse4 <- function(x, n) data.table(x)[rep(seq_len(n),\
    \ each=x), V1]\n</code>\n5) purrr\n<code>\nlibrary(purrr)\nintersperse", "\n \
    \ numbers <- rep(numbers, each = length(numbers))\n  c(numbers[-1], rep(delimeter,\
    \ length(numbers)-1))\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=list,r dscore=0\
    \ |>\nThe R function unlist does not work for you? This would help you unlist\
    \ any list into vector:\n<code>\nx <- list(1:4, 1:10)\nx\n[[1]]\n[1] 1 2 3 4\n\
    \n[[2]]\n[1] 1 2 3 4 5 6 7 8 9\n\nunlist(x)\n[1] 1 2 3 4 1 2 3 4 5 6 7 8 9\n\n\
    x[1, 2] <- list(1:5)\nx\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] 1 2 3 4 5 6 7 8 9\n\
    \nunlist(x)\n[1] 1 2 3 4 5 1 2 3 4 5 6 7 8 9\n</code>\n<|/ a |>\n<| c |>\nI guess\
    \ I was thinking of this list as an argument that I want to pass into a function.\
    \ What I really want is for the function to be able to deal with lists within\
    \ lists.\n<|/ c |>\n<| c |>\nSo you want to treat your argument as vector, not\
    \ as list?\n<|/ c |>\n<| c |>\nYes, I want my function to be able to handle lists\
    \ within lists.\n<|/ c |>\n<| a dscore=0 |>\nUsing Reduce:\n<code>\nlst <- list(1:4,\
    \ 1:10)\nReduce(function(x,y) {c(y,x)},lst)\n[[1]]\n[1] 1 2 3 4\n\n[[2]]\n[1]\
    \ 1 2 3 4 5 6 7 8 9\n</code>\n<|/ a tags=list,r |>\n<| c |>\nThanks, this was\
    \ also a good suggestion! I chose to use my own answer because it's more general.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nlist1 <- list(1:4, 1:10)\nlist2 <- list(1:5)\n\
    list3 <- list(1:5)\nlist4 <- list(1:5)\nlist5 <- list(1:5)\nlist6 <- list(1:5)\n",
  "\n  lapply(split(numbers, ceiling(seq_along(numbers) / length(numbers)) * length(numbers)),\
    \ \n         function(x) c(x, rep(delimeter, length(x) - 1)))\n}\n</code>\nHere\
    \ are some examples:\n<code>\n> intersperse(c(1, 2, 3), 4)\n[[1]]\n[1] 1\n\n[[2]]\n\
    [1] 1 2 3\n\n[[3]]\n[1] 1 2 3 4\n\n[[4]]\n[1] 1 2 3 4 5\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\nYou can also use stri_replace_last_regex\n<code>\nlibrary(stringi)\n\
    \nstri_replace_last_regex(\"abcdabcdabcdabcd\", \"abcd\", \"bcde\")\n", "\n  numbers\
    \ <- unlist(numbers)\n  return(eval(parse(text = paste(\"c(\", paste(numbers,\
    \ collapse = paste(delimeter, collapse = \"\"), paste(\")\")))))\n}\n", "\n  sapply(\n\
    \    seq_along(numbers),\n    function(i) {\n      numbers[i - 1] <- numbers[i\
    \ - 1]\n      numbers[i] <- delimeter\n      numbers[i + 1] <- numbers[i + 1]\n\
    \      unlist(numbers)\n    }\n  )\n}\n", "\n  function(x) {\n    l <- list()\n\
    \    l <- append(l, numbers)\n    l <- append(l, list(x[length(numbers):1]))\n\
    \    paste(l, collapse = delimeter)\n  }\n}\n</code>\n<|/ a tags=list,r dscore=4\
    \ |>\n<| c |>\nIt's probably better to have `l` be `list(x)` rather than `c` in\
    \ the first line so that each element is enclosed into its own list, rather than\
    \ all elements of the list being combined into a single string.\n<|/ c |>\n<|\
    \ c |>\n, good point, and I fixed it, but didn't change the result\n<|/ c |>\n\
    <| c |>\nNo need to wrap `x` into `c`. Just do `l <- list(x)`.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nAnother alternative could be to convert your list into a data.frame\
    \ (from tidyverse) and then use sprintf to build the output:\n<code>", "\n   \
    \ lapply(seq_along(numbers), function(i) {\n        paste(numbers[rep(i, c(length(numbers),\
    \ 1)[1:(length(numbers)-i)])], \n            collapse = delimeter)\n    })\n}\n",
  "\n  stopifnot(is.list(numbers))\n  stopifnot(is.character(delimeter))\n  numbers\
    \ <- as.list(numbers)\n  stopifnot(length(numbers) %% 2 == 0)\n  stopifnot(is.character(numbers[[1]])\
    \ || is.numeric(numbers[[1]]))\n  interspersed_list <- list()\n  for(i in 1:length(numbers))\
    \ {\n    if(is.character(numbers[[i]])) {\n      interspersed_list[[i]] <- paste0(numbers[[i]],\
    \ delimeter, numbers[[i+1]])\n    } else {\n      interspersed_list[[i]] <- numbers[[i]]\n\
    \    }\n  }\n  interspersed_list\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`sapply(\
    \ intersperse( list('1', '2', '3'), '#'), paste0, collapse = '#' )` gives `\"\
    1#2#3#\"` which is different from what OP wanted. I think `paste0( intersperse(\
    \ list('1', '2', '3'), '#' ), collapse = '#' )` should work\n<|/ c |>\n<| c |>\n\
    Thank you, I missed the requirement to have `c()` be the delimiting character.\n\
    <|/ c |>\n<| c |>\nThank you. Your code gives the result I wanted. I was just\
    \ trying to learn a little about `purrr` package. I was planning to solve this\
    \ using `map` function and `cbind`. I was trying to solve it using recursion by\
    \ calling `intersperse` function until `length(numbers)` is odd. I should have\
    \ thought about solving this problem using recursion. Thanks for your help!\n\
    <|/ c |>\n<| a |>\nHere's a solution using purrr.\n<code>\nintersperse <- function(numbers,\
    \ delimeter) {\n  numbers <- as.list(numbers)\n  interspersed_list <- purrr::map(seq_len(length(numbers)-1),\
    \ ~ {\n    if (.y %% 2 == 0) c(numbers[.y], delimeter)\n    else c(numbers[.y])\n\
    \  })\n  purrr::map(interspersed_list, purrr::flatten)\n}\nintersperse( list('1',\
    \ '2', '3'), '#' )", "\n  numbers <- c(numbers, numbers[length(numbers)])\n  rep(delimeter,\
    \ length(numbers)) <- numbers[rep(numbers, times=length(numbers))]\n  numbers[rep(numbers,\
    \ times=length(numbers))] <- NULL\n  return(numbers)\n}\n</code>\nThen, to illustrate\
    \ the difference between this approach and your intersperse_1 function, let's\
    \ look at the output of your intersperse_1 function:\n<code>\n> intersperse_1(4,\
    \ c(1,2,3))\n[1] \"c()\"   \"c(1,4,2)\" \"c(1,2,3,4)\"\n> intersperse(c(4, 5),\
    \ 3)\n[1] \"c(4,5,5,5,5,5)\" \"c(4,5,5)\"        \"c(4,5)\"        \n> intersperse(c(4,\
    \ 5), c(2, 2))\n[1] \"c(4,5,5,5,5,5)\" \"c(4,5,5)\"        \"c(4,5)\"        \n\
    > intersperse(c(4,5,5), c(2,2))\n[1] \"c(4,5,5,5,5,5)\" \"c(4,5,5)\"        \"\
    c(4,5)\"        \n</code>\nThe output from intersperse_1 does not have the correct\
    \ spacing between each element of its input vector, while intersperse does!\n\
    <|/ a dscore=1 |>\n<| a |>\nHere is another idea using RcppAlgos (for Rcpp), although's\
    \ solution will work just fine:\n<code>", "\n  c(numbers, as.character(c(delimeter,\
    \ rep(NA, length(numbers)-2), delimeter)))\n}\n", "\n  stopifnot(is.character(delimeter))\n\
    \  \n  if(length(numbers) == 1) {\n    c(numbers, delimeter)\n  } else {\n   \
    \ c(\n      numbers[1L],\n      intersperse(numbers[-1], delimeter)\n    )\n \
    \ }\n}\n", "\n  if (length(numbers) < 1) return('')\n  else {\n    output <- character(length(numbers))\
    \ \n    \n    i <- 1\n    for (element in numbers) {\n      output[i - 1] <- paste(element,\
    \ output[i - 1], sep = delimeter)\n      i <- i + 1\n    }\n    return(output)\n\
    \  }\n}\n</code>\n<|/ a tags=r,dplyr |>\n<| c |>\nThanks! This works great for\
    \ adding delimeters but it doesn't give me the order that I need it to. It gives\
    \ me the order in which it appears in the `numbers` list, and it doesn't put a\
    \ delimeter in between each pair of consecutive numbers. Is there a way to make\
    \ this function so that it gives the order that I need?\n<|/ c |>\n<| c |>\nWhat\
    \ do you mean by \"the order that I need\"? If you want the list to begin with\
    \ a specific delimeter, then you should prepend it to the numbers, not append\
    \ to them. `paste` will pad with `NA` if there's not enough room.\n<|/ c |>\n\
    <| c |>\nI want the list to start with the delimeter, which is how I know the\
    \ order that I need. So let's say that I had a list named `numbers` that contained\
    \ these numbers: `c(1, 2, 3, 4, 5, 6, 7)`. Then I would like it to start off like\
    \ this: `c(1, 4, 2, 5, 3, 6, 7)`, but with the delimeters added between the numbers.\
    \ So for the example above, I would like `c(1, 4, 2, 5, 3, 6, 7)`.\n<|/ c |>\n\
    <| c |>\nYou would need to make a new list that has the numbers with your desired\
    \ delimeter in front of them. For example, `list(c(1, 2, 3, 4, 5), c(2, 3, 4,\
    \ 5, 6), c(3, 4, 5, 6, 7))`.\n<|/ c |>\n<| c |>\nI've added an edit above. Thanks\
    \ for your help!\n<|/ c |>\n<| a tags=r,dplyr |>\nI finally solved this after\
    \ several hours of headbanging. I needed to modify my original function so that\
    \ it added the delimeters between the numbers rather than after. I just added\
    \ the + symbol to the end of each paste, instead of to the beginning of the function.\
    \ Here's what I came up with:\n<code>", "\n  \n  # Convert to list if `numbers'\
    \ is not already a list\n  numbers <- if (!is.list(numbers)) as.list(numbers)\
    \ else numbers\n  \n  # Create an empty list to return\n  output <- list()\n \
    \ \n  # Loop over consecutive elements of input list `numbers'\n  for (i in 1:length(numbers))\
    \ {\n    \n    # Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    output[[i]] <- c(numbers[[i]], delimeter, numbers[[i+1]])\n\
    \    \n  }\n  \n  # Return a list with `output'\n  return(output)\n  \n}\n</cell>\n\
    <cell>", "\n  stopifnot(length(nrow(numbers)) == 1) \n  stopifnot(length(numbers)\
    \ == 1) \n  intersect(rep(c(delimeter, numbers), nrow(numbers)), rep(c(delimeter,\
    \ numbers), length(numbers)))\n}\n", "\n  numbers %>%\n    map(function(x) return(paste(x,\
    \ delimeter, sep=\"\"))) %>%\n    paste(collapse=\"\")\n}\n</code>\n<code>\nintersperse(c(1,\
    \ 2, 3), 4)", "\n    paste(numbers, collapse = paste0(delimeter, collapse = delimeter))\n\
    }\n</code>\nNote that this assumes that numbers is always a numeric vector. If\
    \ the numbers argument is something else, e.g. a data frame or tibble, then you\
    \ might need to convert the elements first:\n<code>\nintersperse(c(1, 2, 3), 4)",
  "\n  intersperseR(numbers, delimeter, FALSE)\n}\n\nintersperseR <- function(numbers,\
    \ delimeter, keep) {\n  if (is.null(numbers)) return(NULL)\n  \n  if (keep) {\n\
    \    numbers <- c(numbers, numbers)\n  } else {\n    numbers <- numbers[-length(numbers):length(sapply(numbers,\
    \ length))]\n  }\n  \n  len <- length(numbers)\n  \n  if(len <= 1) return(numbers)\n\
    \  \n  repeat {\n    i <- 1\n    while(i < len) {\n      if(numbers[[i*2-1]] ==\
    \ numbers[[i*2]]) {\n        numbers <- c(numbers[(i*2):i], c(numbers[(i*2)-1],\
    \ numbers[[i]]))\n      } else {\n        break\n      }\n      i <- i + 1\n \
    \   }\n    \n    if(i > len) return(numbers)\n  }\n}\n", "\n  function(x) {\n\
    \    lapply(seq_along(x), function(i) {\n      if (i != 0) \n        paste(numbers[i\
    \ - 1], delimeter, sep=\"\")\n      else\n        numbers[i]\n    })\n  }\n}\n",
  "\n  lapply(seq_along(numbers), function(i) {\n    numbers[c(i, (i+1):length(numbers))]\n\
    \  }) %>%\n    set_names(names(numbers)) %>%\n    map(c) %>%\n    map(~c(delimeter,\
    \ .)) %>%\n    map(~.[1:(length(.)-1)]) %>%\n    unlist(., use.names = FALSE)\n\
    }\n", "\n  cn <- character(length(numbers))\n  for(i in seq_along(numbers)) {\n\
    \    cn[i] <- paste(numbers[i], collapse = delimeter)\n  }\n  cn\n}\n</code>\n\
    <|/ a dscore=5 tags=r,list,element,string |>\n<| c |>\nI like this because it\
    \ is a one liner (`paste`!). However I prefer using `paste0`, because `paste0`\
    \ has the additional advantage of not requiring `n` calls to `paste`.\n<|/ c |>\n\
    <| c |>\n`paste0` is great if you're dealing with character strings.  `paste`\
    \ works best with `numeric` or `logical` values.\n<|/ c |>\n<| c |>\nThe function\
    \ should use `seq_along(numbers)` in place of `1:length(numbers)`. Otherwise,\
    \ the output will be different if `numbers` is of length greater than 1.\n<|/\
    \ c |>\n<| c |>\nGreat solution! The only thing I would add is that if you're\
    \ working with numbers rather than strings, you might want to add na.rm=TRUE to\
    \ your paste call.  Otherwise any NA's in your list will get replaced with a string\
    \ of the same length.\n<|/ c |>\n<| c |>\nHow would you deal with the situation\
    \ that there were multiple elements of 'delimeter'? Say `list(c(1,2,3), c(1,2,3),\
    \ c(1,2,3), c(1,2,3), c(1,2,3))` ? What would the output be in this case?\n<|/\
    \ c |>\n<| a dscore=5 |>\nHere is a solution using the lapply function. \n<code>\n\
    \ lapply(seq_along(numbers),function(x) paste(numbers[x],collapse=\" \"))\n</code>\n\
    <|/ a tags=r,list,element,string |>\n<| c |>\nI actually like the `lapply` solution\
    \ because it is easier to read and understand.\n<|/ c |>\n<| c |>\nThis can be\
    \ written more concisely as: `lapply(seq_along(numbers), function(x) paste(numbers[x],\
    \ collapse=\" \"))`\n<|/ c |>\n<| c |>\nYou can also use `sapply` instead of `lapply`\
    \ to return values rather than a list of name-value pairs.\n<|/ c |>\n<| a tags=r,list,element,string\
    \ dscore=5 |>\nIf you really want to do it the hard way you can do:\n<code>\n\
    > list(a = \"a\",b = \"b\",c = \"c\")\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] \"b\"\n\n\
    [[3]]\n[1] \"c\"\n", "\n  numbers %>% \n    as.list %>% \n    lapply(., `+`, 1)\
    \ %>% \n    lapply(., function(x) c(x, delimeter, x)) %>% \n    do.call %>% \n\
    \    .[[1]]\n}\n</code>\nTest it out:\n<code>\n> intersperse(c(1, 2, 3), \" \"\
    )\n[1] \" 1 2 3 \"\n\n> intersperse(c(1, 2, 3), \" \")\n[1] \" 1 2 3 \"\n\n> intersperse(c(1,\
    \ 2, 3), \" \")\n[1] \" 1 2 3 \"\n\n> intersperse(c(1, 2, 3), \" \")\n[1] \" 1\
    \ 2 3 \"\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks - this is very interesting\
    \ and solves the problem.  What did you change so that it works with the `lapply`\
    \ statement in the original question?\n<|/ c |>\n<| c |>\nI added a simpler version\
    \ in the answer. I basically changed the `lapply` line to just add the \"delimeter\"\
    \ argument to `c()` instead of using `as.list` and an anonymous function.\n<|/\
    \ c |>\n<| c |>\nThis is great, thanks.  I ended up using another solution (see\
    \ my answer below) but this one is very good.  Thank you!\n<|/ c |>\n<| a tags=list,lapply,r\
    \ |>\nHere is another solution:\n<code>\nx <- list(list(1, 2), list(3, 4))\n",
  "\n    if (length(numbers) < 2) return(numbers)\n    result <- c()\n    counter\
    \ <- 0\n    result <- c(result, numbers[counter])\n    for (current in seq_along(numbers))\
    \ {\n      if (counter < length(numbers) - 1) {\n        counter <- counter +\
    \ 1\n      }\n      result <- c(result, delimeter)\n      result <- c(result,\
    \ numbers[counter])\n    }\n    result\n}\n", "\n  numbers %>%\n    map_chr(~.x)\
    \ %>%\n    strsplit(., \"(?<=\\\\G.{1})\") %>%\n    lapply(function(.x) {\n  \
    \    paste(\n        .x,\n        c(rep(delimeter, length(. ) - 1), paste(.x,\
    \ collapse = \"\"))\n      )\n    })\n}\n", "\n    paste0(\"c(\", paste(numbers,\
    \ collapse = delimeter), \")\")\n}\n", "\n    \n    interspersedNumbers <- unlist(sapply(split(numbers,\
    \ ceiling(seq_along(numbers)/2)), \n        function(x) paste0(x, delimeter),\
    \ USE.NAMES=FALSE), recursive = FALSE)\n    \n    interspersedNumbers\n}\n", "\n\
    \  interpose(numbers, delimeter)\n}\n</code>\nNow we can apply intersperse to\
    \ each element of numbers, for example like this:\n<code>\nsapply(numbers, intersperse,\
    \ delim)\n</code>\n<|/ a |>\n<| a dscore=3 |>\nA simple approach would be to create\
    \ a custom function (e.g. intersperse) which wraps paste and paste0:\n<code>\n\
    intersperse <- function(x, sep) {\n  paste0(paste0(sep, x), paste0(sep, sep))\n\
    }\n\nsapply(numbers, intersperse, sep)\n</code>\nResult:\n<code>\n[1] \"a\"  \"\
    b\"  \"c\"  \"1\"  \" 2\"  \"3\"  \" 4\"  \"5\"\n</code>\n<|/ a tags=r,list,interleave\
    \ |>\n<| c |>\nThis is neat, although it would be more straightforward to use\
    \ paste0, not paste.\n<|/ c |>\n<| c |>\n, that's a good suggestion. I added it\
    \ to the answer.\n<|/ c |>\n<| a dscore=3 |>\nA variation on Paul's answer, with\
    \ one more argument that makes it a bit more robust to different numbers of elements\
    \ in the input vector:\n<code>\nintersperse <- function(x, sep, max){\n  paste0(\n\
    \    paste0(sep, x),\n    ifelse(length(x) < max, paste0(sep, sep), NA)\n  )\n\
    }\n</code>\nThen we apply it to each element of the vector numbers, and pass the\
    \ maximum length to pad with the delimiter when necessary.\n<code>\nsapply(numbers,\
    \ intersperse, sep, max(lengths(numbers)))\n</code>\n<|/ a tags=r,list,interleave\
    \ |>\n<| a tags=r,list,interleave |>\nYou can do this with mapply and paste:\n\
    <code>\npaste(paste(numbers, sep = \"\", collapse = \"\"), sep = \"\")\n</code>\n\
    The outer paste, with collapse set to \"\", is a hack to collapse the numbers\
    \ into a string. Then, the inner paste collapses those into strings with the desired\
    \ separator.\n<|/ a dscore=3 |>\n<| c |>\n+1 for the `collapse = \"\"`, I was\
    \ trying `paste0` with no luck.\n<|/ c |>\n<| a tags=r,list,interleave |>\n<code>\n\
    numbers <- c(\"a\",\"b\",\"c\",\"1\",\"2\",\"3\",\"4\",\"5\")\n</code>\nThis may\
    \ be what you're looking for:\n<code>\npaste(numbers, collapse = \"\")\n</code>\n\
    <|/ a dscore=3 |>", "\n  # Create a list to store all the intermediate steps\n\
    \  inters <- vector(mode=\"list\", length=length(numbers))\n  \n  # Looping through\
    \ the list to store the intermediate steps\n  for (i in seq_along(numbers)) {\n\
    \    # Insert a number 'delimeter' between every two consecutive elements of input\
    \ list `numbers'\n    inters[[i]] <- numbers[seq(i, i+1)]\n    inters[[i]] <-\
    \ c(inters[[i]], delimeter)\n  }\n  \n  # Return the interspersed list\n  unlist(inters)\n\
    }\n", "\n    x <- paste(numbers, collapse = delimeter)\n    return(eval(parse(text\
    \ = x)))\n}\n", "\n  x <- numeric()\n  for (i in seq_along(numbers)) {\n    if\
    \ (i == 1) {\n      x[length(numbers)] <- numbers[i]\n    } else {\n      x[length(numbers)]\
    \ <- numbers[i]\n      x[length(numbers) + 1] <- delimeter\n    }\n  }\n  return(x)\n\
    }\n</code>\n<|/ a tags=for-loop,r |>\n<| c |>\nNice and elegant. I was about to\
    \ post a variant which kept the vector `numbers` around for repeated use, but\
    \ yours is more efficient.\n<|/ c |>\n<| a dscore=2 |>\nTo answer the original\
    \ question, without using any packages, you can use sapply to create a vector\
    \ of concatenated elements from each input list.\n<code>\n> myvector <- unlist(sapply(mylist,\
    \ paste, collapse=\", \"))\n> myvector\n[1] \"a1, b1, c1\" \"a2, b2, c2\" \"a3,\
    \ b3, c3\"\n</code>\n<|/ a tags=for-loop,r |>\n<| c |>\nThis seems very clever.\
    \ I didn't know you can pass a function with arguments to the `sapply` function.\
    \ What exactly does the `paste` function do?\n<|/ c |>\n<| c |>\nIt's a function\
    \ of which I couldn't find the documentation, but here's some examples: http://stat.ethz.ch/R-manual/R-patched/library/base/html/paste.html\n\
    <|/ c |>\n<| a |>\nHere is a solution using sapply:\n<code>\n mylist  <- list(a\
    \ = data.frame(a = 1:10, b = 2:11),\n                 b = data.frame(a = 1:10,\
    \ b = 11:20))\n myvector <- paste(sapply(mylist, '[[', 'a'), sapply(mylist, '[[',\
    \ 'b'), sep = ', ')\n myvector\n[1] \"1, 2, 3\" \"4, 5, 6\" \"7, 8, 9\"\n</code>\n\
    Or if you only want to use one of the lists:\n<code>\nmyvector <- paste(sapply(mylist,\
    \ '[[', 'a'), sep = ', ')\n</code>\n<|/ a dscore=1 tags=for-loop,r |>\n<| a |>\n\
    You say you tried \"vectorizing\" it but it's not vectorized in the sense that\
    \ it still uses a for loop. I would do something like this instead:\n<code>",
  "\n  # Check if 'numbers' is an empty list\n  if(length(numbers) == 0) {\n    return('')\n\
    \  }\n  else {\n    # Create a vector containing all the elements of input list\
    \ `numbers'\n    numbers <- c(numbers)\n    # Create a vector containing all the\
    \ elements of input list `numbers' except the last one\n    numbers <- numbers[-1]\n\
    \    # Return the interspersed vector concatenated with input list 'delimeter'\n\
    \    return(paste0(numbers, delimeter))\n  }\n}\n</code>\nAnd here are the test\
    \ cases I used:\n<code>\n> print(intersperse(c(3,5,7,11), \",\"))", "\n  stopifnot(is.numeric(numbers))\n\
    \  stopifnot(is.character(delimeter))\n  stopifnot(length(numbers) <= length(delimeter))\n\
    \n  function(...) {\n    paste(numbers, collapse=delim)\n  }\n}\n</code>\nThis\
    \ was fun, let's try it:\n<code>\nintersperse(c(1, 4, 2, 3), 4)", "\n  intersp\
    \ <- function(nums, delim) {\n    if (length(nums) < 2) return(NULL)\n    x <-\
    \ nums[1]\n    c(nums[1], paste(delim,x,delim,nums[2:length(nums)], sep = \"\"\
    ))\n  }\n  sapply(numbers, intersp, delimeter)\n}\n", "\n  if(!is.integer(delimeter))\
    \ stop(\"delimeter needs to be an integer\")\n  if(!is.numeric(numbers)) stop(\"\
    numbers needs to be a vector\")\n  \n  if(length(numbers) == 1) return(numbers)\n\
    \  \n  n <- length(numbers)\n  \n  if(n > 1) {\n    sapply(2:(n-1), function(x)\
    \ {\n      x <- c(numbers[x], delimeter)\n      paste(x, collapse = \"\")\n  \
    \  })\n  } else {\n    paste(numbers, delimeter)\n  }\n}\n</code>\n<|/ a tags=r,vector,string\
    \ |>\n<| a tags=r,vector,string |>\nHere's a short solution with strsplit() applied\
    \ twice and pasting the elements into a string:\n<code>\n> paste0(strsplit(c(1,2,3,4,5,6),\"\
    ,\"), strsplit(c(1,2,3,4,5,6),\",\"))\n[1] \"1,1,2,3,4,5,6\" \"1,2,3,4,5,6,1\"\
    \ \"1,2,3,4,5,6,1,2\" \"1,2,3,4,5,6,1,2\" \"1,2,3,4,5,6,1,2\" \"1,2,3,4,5,6,1,2\"\
    \ \"1,2,3,4,5,6,1,2\" \"1,2,3,4,5,6,1,2\"\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nHere's an approach using gsub and regular expressions.\n<code>\npaste0(strsplit(c(1,\
    \ 2, 3, 4, 5, 6), \",\"), strsplit(c(1, 2, 3, 4, 5, 6), \",\"))\n\n[1] \"1,1,2,3,4,5,6\"\
    \ \"1,2,3,4,5,6,1\" \"1,2,3,4,5,6,1,2\" \"1,2,3,4,5,6,1,2\" \"1,2,3,4,5,6,1,2\"\
    \ \"1,2,3,4,5,6,1,2\" \"1,2,3,4,5,6,1,2\" \"1,2,3,4,5,6,1,2\"\n</code>\n<|/ a\
    \ tags=r,vector,string |>\n<| a |>\nA more concise version using paste0, strsplit\
    \ and paste:\n<code>\npaste0(strsplit(c(1, 2, 3, 4, 5, 6), \",\"), strsplit(c(1,\
    \ 2, 3, 4, 5, 6), \",\"))\n</code>\n<|/ a dscore=1 tags=r,vector,string |>\n<|\
    \ a dscore=0 tags=r,vector,string |>\nYou could use paste() and paste0()\n<code>\n\
    paste(c(1,2,3,4,5,6),c(1,2,3,4,5,6),sep=\",\")\n</code>\n<|/ a |>\n<| a tags=r,vector,string\
    \ |>\nI like this solution\n<code>\ns <- \"1,2,3,4,5,6\"\ns <- strsplit(s, \"\
    ,\")\nsapply(s, function(x) paste0(x, collapse=\",\"))\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\npaste", "\n  numbers[seq(1, length(numbers), 2)]\
    \ <- c(numbers[seq(1, length(numbers), 2)], delimeter)\n  return(numbers)\n}\n",
  "\n  paste0(numbers, collapse=paste0(delimeter, collapse=delimeter))\n}\n", "\n\
    \  return(function(x) c(numbers, x, delimeter))\n}\n", "\n    if(length(numbers)\
    \ < 1) return numbers;\n    if(length (numbers %% 2)) {\n        numbers <- c(numbers,\
    \ numbers[-length(numbers):1]);\n    }\n    c(numbers, rep(delimeter, length(numbers)));\n\
    }\n", "\n  if (length(numbers) == 0) {\n    return(numbers)\n  } else if (length(numbers)\
    \ == 1) {\n    return(numbers)\n  } else {\n    numbers <- c(numbers, delimeter,\
    \ numbers[-1])\n    return(numbers[1:length(numbers)])\n  }\n}\n", "\n  intersperse_args\
    \ <- list(numbers = numbers, delimeter = delimeter)\n  intersperse_name <- paste0('intersperse_',\
    \ deparse(substitute(numbers)))\n  body(\n    intersperse_body(numbers, delimeter),\n\
    \    intersperse_args\n  )\n  environment(\n    intersperse_name\n  ) <- environment()\n\
    \  intersperse_name\n}\n\nintersperse_body <- function(numbers, delimeter) {\n\
    \  numbers <<- deparse(substitute(numbers))\n  delimeter <<- deparse(substitute(delimeter))\n\
    \  numbers_names <- gsub('^.*?(\\\\S+).*$', \"\\\\2\", numbers)\n  return(\n \
    \   intersperse_body(\n      numbers_names,\n      delimeter\n    )\n  )\n}\n",
  "\n    numbers <- as.list(numbers)\n    length(numbers) <- length(numbers) * 2 -\
    \ 1\n    numbers <- c(numbers, rep(delimeter, length(numbers)-1))\n    numbers\
    \ <- unlist(numbers, recursive = FALSE)\n    function(x) paste(x, numbers, sep\
    \ = \"\")\n}\n</code>\nHere's an example of how to use it:\n<code>\n> intersperse(c(1,\
    \ 2, 3), 4)\nc(1, 4, 2, 4, 3)\n> intersperse(c(123, 456, 789), 4)\nc(123, 456,\
    \ 789, 4, 2)\n</code>\n<|/ a tags=list,r |>\n<| c |>\nThis is very very elegant.\
    \ Thanks! I wonder why I haven't thought of that!\n<|/ c |>\n<| c |>\nYou're welcome.\
    \ It does seem like a very \"hacky\" solution. I'm curious what you learned about\
    \ this approach, and how it's different than your own.\n<|/ c |>\n<| a |>\nUsing\
    \ lapply. \n<code>\n numbers <- list(c(123, 456, 789))\n lapply(1:length(numbers),\
    \ function(x) paste(numbers[[x]], rep(\" \", length(numbers[[x]]) - x + 1), sep\
    \ = \"\"))\n</code>\n<|/ a tags=list,r dscore=4 |>\n<| a tags=list,r |>\nYou can\
    \ try a for loop:\n<code>\nnumbers <- list(c(123, 456, 789))\nfor (i in 1:length(numbers))\
    \ {\n  numbers[[i]] <- paste(numbers[[i]], rep(\" \", length(numbers[[i]])-1),\
    \ sep=\"\")\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\nHere's another way:\n<code>\n\
    numbers <- list(c(123, 456, 789))\n\nlapply(1:length(numbers), function(x) numbers[[x]])\
    \ %>%\n  unlist() %>%\n  paste0(rep(\" \", length(numbers[[1]]) - length(unlist(numbers))))",
  "\n  stopifnot(is.character(delimeter), length(delimeter) == 1)\n  numbers <- unlist(numbers)\n\
    \  result <- vector(mode=\"list\", length=length(numbers))\n  result[c(TRUE, FALSE)]\
    \ <- NA\n  result[c(FALSE, TRUE)] <- numbers\n  result[c(TRUE, FALSE)][2] <- delimeter\n\
    \  result[c(FALSE, TRUE)][2] <- numbers\n  do.call(c, result)\n}\n", "\n    stopifnot(is.numeric(numbers))\n\
    \    stopifnot(is.numeric(delimeter))\n    numbers <- as.list(numbers)\n    paste0(numbers,\
    \ collapse = delimeter)\n}\n</cell>\n<code language=conda-env-Anaconda3-py>\n\
    intersperse(c(1, 2, 3), 4)\n</cell>\n<text>\nintersperse_l\nintersperse_l takes\
    \ a list of lists and a delimeter, and returns a list consisting of the elements\
    \ of all the lists separated by the delimeter. For example:\n\nintersperse_l([1,2],\
    \ \",\")\n[[1]]\n[1] \"1\"\n\n[[2]]\n[1] \"2\"\n\nintersperse_l([1,2], \",\")\n\
    [[1]]\n[1] \"1\"\n\n[[2]]\n[1] \"2\"\n\nintersperse_l([[1,2,3],[4,5,6]], \",\"\
    )\n[[1]]\n[[1]][[1]]\n[1] \"1\"\n\n[[1]][[2]]\n[1] \"2\"\n\n[[2]]\n[[2]][[1]]\n\
    [1] \"3\"\n\n[[2]][[2]]\n[1] \"4\"\n\n[[3]]\n[[3]][[1]]\n[1] \"5\"\n\n[[3]][[2]]\n\
    [1] \"6\"\n\nintersperse_l([[1,2,3],[4,5,6]], \",\")\n[[1]]\n[[1]][[1]]\n[1] \"\
    1\"\n\n[[1]][[2]]\n[1] \"2\"\n\n[[2]]\n[[2]][[1]]\n[1] \"3\"\n\n[[2]][[2]]\n[1]\
    \ \"4\"\n\n[[3]]\n[[3]][[1]]\n[1] \"5\"\n\n[[3]][[2]]\n[1] \"6\"\n\n</text>\n\
    <code language=conda-env-Anaconda3-py>\nintersperse_l <- function(lists, delimeter)\
    \ {\n    stopifnot(is.list(lists))\n    stopifnot(is.character(delimeter))\n \
    \   lists <- as.list(lists)\n    paste(lists, collapse = delimeter)\n}\n</cell>\n\
    <code language=conda-env-Anaconda3-py>\nintersperse_l([1,2], \",\")\n</cell>\n\
    <code language=conda-env-Anaconda3-py>\nintersperse_l([1,2], \",\")\n</cell>\n\
    <code language=conda-env-Anaconda3-py>\nintersperse_l([[1,2,3],[4,5,6]], \",\"\
    )\n</cell>\n<text>\nintersperse_l\nintersperse_l takes a list of lists and a delimeter,\
    \ and returns a list consisting of the elements of all the lists separated by\
    \ the delimeter", "\n    if(length(numbers) <= 1) {\n        return(numbers)\n\
    \    } else {\n        c(numbers[(1):length(numbers)], delimeter, numbers[(length(numbers)+1):length(numbers)])\n\
    \    }\n}\n", "\n  lengths <- lengths(numbers)\n  lengths[lengths == 0] <- 1\n\
    \  number <- numbers[[1]]\n  output <- number\n  \n  for(i in seq_along(numbers[2]\
    \ - 1)) {\n    output <- c(output, delimeter)\n  }\n  \n  return(output)\n}\n",
  "\n  length(numbers) <- length(numbers) * 2 - 1\n  lapply(seq_along(numbers), function(i)\
    \ {\n    c(numbers[i - 1], unlist(numbers[c(seq(i, 2 * length(x), by = 2), lengths(numbers))]),\
    \ delimeter)\n  })\n}\n", "\n  if(nchar(numbers) < 3) return(c(numbers, numbers))\n\
    \  return(c(numbers, numbers[seq_len(length((numbers))) - 1], delimeter, numbers))\n\
    }\n", "\n  \n  # Initializing\n  output <- c()\n  \n  # Looping through the input\
    \ list and adding 'delimeter' between every two consecutive elements\n  for (i\
    \ in seq_along(numbers)) {\n    \n    # Adding 'delimeter' to the output\n   \
    \ output <- c(output, numbers[[i]])\n    \n    # Adding the delimeter\n    output\
    \ <- c(output, delimeter)\n  }\n  \n  return(output)\n}\n</code>\nIntersperse\
    \ is called intersperse because it is interspersing between elements, as opposed\
    \ to concatenating elements together.\n<code>", "\n  if (length(numbers) > 1)\
    \ {\n    intersect(unlist(sapply(numbers, c)), unlist(sapply(numbers, c(delimeter,\
    \ delimeter))))\n  } else {\n    numbers\n  }\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nOne solution using lapply.\n<code>\nlapply(1:length(x), function(i) paste(x[1:i],\
    \ collapse = paste0(\",\", x[i])))", "\n  lapply(seq_along(numbers), function(i)\
    \ {\n    if (i %% 2 == 0)\n      c(numbers[i - 1], numbers[i], numbers[(i + 1L):\
    \ length(numbers)])\n    else\n      c(numbers[i - 1], numbers[(i + 1L): length(numbers)])\n\
    \  })\n}\n", "\n  lapply(seq_along(numbers), function(i)\n    if (i < length(numbers))\
    \ c(numbers[i], numbers[(i+1):length(numbers)]) else numbers)\n}\n</code>\n<|/\
    \ a |>\n<| a tags=functional-programming,list,r |>\nHere's another approach. It\
    \ uses purrr's map and unlist to map the function to each element of a list, then\
    \ use base R to convert the list back to a vector. \n<code>\nintersperse <- function(x,\
    \ xs) unlist(map(x, xs, seq_len))\n</code>\nHere is an example. \n<code>\nintersperse(c(1,\
    \ 2, 3), c())", "\n  if (length(numbers) == 1) {\n    numbers[1]\n  } else {\n\
    \    c(numbers[1], intersperse(tail(numbers, 1), delimeter))\n  }\n}\n", "\n \
    \ if (length(numbers) <= 1) {\n    return(numbers)\n  } else {\n    interspersed_elements\
    \ <- list()\n    length(interspersed_elements) <- length(numbers)\n    index <-\
    \ 1\n    while (index <= length(numbers)) {\n      interspersed_elements[index]\
    \ <- numbers[index]\n      index <- index + delimeter\n    }\n    return(do.call(paste,\
    \ c(list(interspersed_elements), list(collapse = \", \"))))\n  }\n}\n", "\n  if\
    \ (length(numbers) > 1) {\n    c(numbers[1], unlist(lapply(split(numbers, ceiling(seq_along(numbers)\
    \ / 2)), `length<-`, 2)),\n      numbers[length(numbers)])\n  } else {\n    numbers\n\
    \  }\n}\n</code>\n<|/ a tags=function,r dscore=2 |>\n<| a dscore=2 |>\nYou can\
    \ also use the function c() with a list as input.\n<code>\n> c(4,2,3)\n[1] 4 2\
    \ 3\n</code>\n<|/ a tags=function,r |>\n<| c |>\n`c(4)` will also produce `4`.\
    \ I think you meant `c(4,2)`.\n<|/ c |>\n<| c |>\nNot necessarily, but if I'm\
    \ correct, then the OP wants it to behave like a vector or list, so I think I\
    \ made my point clear.\n<|/ c |>\n<| c |>\n`c(4,2)` would not produce `4 2`. `c(4,2,3)`\
    \ is perfectly fine.\n<|/ c |>\n<| c |>\nTrue, I was thinking more of the case\
    \ of `c(1, 2, 3, 4, 5)` being called with `c(4)` as the argument.\n<|/ c |>\n\
    <| a |>\nHow about:\n<code>\nintersperse <- function(x, n){\n    lapply(x, function(x)\
    \ c(x, rep(NA, n-length(x)+1)))[c(T,F)]\n}\n\nintersperse(c(1,2,3), 2)\n[[1]]\n\
    [1] 1\n\n[[2]]\n[1] 2 3\n\n[[3]]\n[1] NA NA\n\nintersperse(c(1,2,3), 3)\n[[1]]\n\
    [1] 1 2 3\n\n[[2]]\n[1] NA NA NA\n\n[[3]]\n[1] NA\n</code>\n<|/ a dscore=1 tags=function,r\
    \ |>\n<| a tags=function,r dscore=1 |>\nI suggest the following code (thanks to\
    \ Ricardo Barradas for his answer):\n<code>\nintersperse <- function(x, n){\n\
    \  unlist(lapply(x, function(x) c(x, rep(NA, n-length(x)+1)))[c(T,F)])\n}\n</code>\n\
    The result will look like that:\n<code>\nintersperse(c(1,2,3), 2)", "\n  interp_numbers\
    \ <- c(numbers, list())\n  interp_numbers <- lapply(interp_numbers, function(x)\
    \ {\n    lapply(x, function(y) c(x, delimeter, y))\n  })\n  unlist(unlist(interp_numbers),\
    \ use.names=FALSE)\n}\n</cell>\n<text>\nLet's test our function to verify that\
    \ it works:\n\n\n</text>\n<cell>\nintersperse(c(1, 2, 3), 4)\n</cell>\n<text>\n\
    Pretty good!\n\nLet's now implement the function and test again:\n\n\n</text>\n\
    <cell>\nintersperse(c(1, 2, 3), 4)\n</cell>\n<text>\nAwesome!  As an exercise,\
    \ try changing delimeter to \"*\" in the function definition above and see what\
    \ happens when we change the input list to c(1, 2, 3, 4).\n\nExercise: Implement\
    \ intersperse.  You should be able to use our existing code above and the above\
    \ test to help you write your implementation.\n\nExercise: It would be nice to\
    \ change the behavior of intersperse so that it keeps any existing numbers after\
    \ the delimeter as well.  We can do this by using a wrapper function around intersperse.\
    \  We'll add a new parameter to intersperse that allows us to specify what behavior\
    \ we want.\n\nExercise: Implement a function intersperse_that does the same thing\
    \ as intersperse except that instead of inserting a number between consecutive\
    \ elements it puts in a character string that matches the existing number in the\
    \ list.  Test it on the following input:\n\nintersperse_that(c(1, 4, 2, 5), \"\
    .\")\nc(1, \"4\", \".\", \"2\", \".\", \"5\")\nIntersperse_that returns the original\
    \ list if there are no matches in the input.\n\n\n</text>\n<cell>\nintersperse_that\
    \ <- function(numbers, delimeter, other_argument) {\n  # Your code here!\n}\n\
    </cell>\n<text>\nLet's test our new function:\n\n\n</text>\n<cell>\nintersperse_that(c(1,\
    \ 4, 2, 5), \".\")\n</cell>\n<text>\nThat looks pretty good.  Let's test our original\
    \ intersperse:\n\n\n</text>\n<cell>\nintersperse(c(1, 2, 3), 4)\n</cell>\n<text>\n\
    Awesome!\n\n\n</text>\n<text>\nChallenge Exercise\nLet's take it one step further.\
    \  Implement intersperse_that so that it returns the original list if there are\
    \ no matches in the input.  Implement intersperse_that so that it keeps any existing\
    \ numbers after the delimeter as well.  Test this on c(1, 4, 2, 5) and \".\".\n\
    \nExercise: How would you do this?  What changes would you make to the functions ",
  "\n  result <- character(length(numbers))\n  index <- 1\n  while(index <= length(numbers))\
    \ {\n    result <- c(result, numbers[index], delimeter)\n    index <- index +\
    \ 1\n  }\n  result\n}\n</code>\n<|/ a tags=r,tidyverse dscore=1 |>\n<| c |>\n\
    Hi thanks for your answer. Can you elaborate on what exactly is going on here?\
    \ I understand what intersperse is doing but I am struggling to understand how\
    \ this particular function works. What exactly is happening in the middle of the\
    \ function?\n<|/ c |>\n<| c |>\nIt is a very simple function.  It starts by setting\
    \ `result` to the character `\"\"` and then `index` = 1 and then while `index`\
    \ <= `length(numbers)`, it takes the next element in the list and concatenates\
    \ it to the result and the delimeter `delimeter`.  Then, it increments `index`\
    \ and repeats the process until the end of list `numbers`.\n<|/ c |>\n<| c |>\n\
    Thanks, that helps explain it a bit. I guess what I am still struggling with is\
    \ how exactly it works. When you say \"takes the next element in the list\", are\
    \ you referring to the actual number that gets concatenated with the delimeter?\n\
    <|/ c |>\n<| c |>\nNo.  I am referring to the list `numbers[index] <- numbers[index]\
    \ + delimeter`\n<|/ c |>\n<| c |>\nThanks so much\n<|/ c |>\n<| a dscore=1 |>\n\
    Here is another solution that uses the base R function lapply:\n<code>\nintersperse\
    \ <- function(input, delimeter) {\n  unlist(lapply(input, function(x) c(delimeter,\
    \ x, delimeter)))\n}\n</code>\nIt works as follows: for every element x in the\
    \ vector input, a list is created consisting of delimeter and x and then another\
    \ list consisting of x and the delimeter.\nThen unlist does what it says on the\
    \ box: it reassembles those lists into a vector.\n<|/ a tags=r,tidyverse |>\n\
    <| a dscore=1 |>\nThis can also be done with gsubfn\n<code>\nlibrary(gsubfn)\n\
    \ngsubfn(\"(.)(.)\", c(delimeter, delimeter), x, perl = TRUE)\n</code>\nOr without\
    \ creating a function using paste\n<code>\npaste(delimeter, x, delimeter, sep=\"\
    \")\n</code>\ndata\n<code>\nx <- c(1, 2, 3)\ndelimeter <- \"^\"", "\n    c(\n\
    \      numbers[rep(TRUE, nrow(numbers))], \n      rep(delimeter, nrow(numbers)-1)\n\
    \    )\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI love how you use `rep` with\
    \ a `bool` vector to index the list. Not sure why this is so famous in R packages.\
    \ I thought of doing this in base R, but I really didn't like it and wouldn't\
    \ have ever thought to ask how it worked.\n<|/ c |>\n<| c |>\nI like your `intersperse`\
    \ function. It's even more useful when working with a list of character vectors.\n\
    <|/ c |>\n<| a |>\nHere is another solution:\n<code>\nintersperse <- function(x,\
    \ value) {\n  stopifnot(is.atomic(x), is.atomic(value))\n  n <- length(x)\n  i\
    \ <- seq_len(n)\n  j <- seq_len(n)\n  i <- c(0, i)\n  j <- c(1, j)\n  i <- c(1,\
    \ i)\n  x[c(i, j[!j])] <- x[i]\n  x[i[-1]] <- value\n  x\n}\n\nintersperse(c(1,\
    \ 2, 3), 4)", "\n  if (length(numbers) == 0) return(numbers)\n  rep(delimeter,\
    \ ceiling(length(numbers) / 2)) + numbers[-(length(numbers) / 2):]\n}\n</code>\n\
    Let's test it\n<code>\nintersperse(c(1, 2, 3), 4)", "\n  len <- lengths(numbers)\n\
    \  len <- max(len + 1, 0)\n  len <- min(len, length(numbers))\n  numbers <- c()\n\
    \  i <- 1\n  while(i <= len) {\n    if (i != 1) {\n      numbers <- c(numbers,\
    \ delimeter)\n    }\n    numbers <- c(numbers, numbers[seq(i)])\n    i <- i +\
    \ 1\n  }\n  return(numbers)\n}\n</code>\n<|/ a |>\n<| a tags=r,lapply,list,interleave\
    \ |>\nWe can use unlist to convert list to vector and then use rep to create the\
    \ desired result.\n<code>\nsapply(1:length(L), function(i) c(L[[i]], rep(\"\"\
    , i-1)))\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nUsing lapply, you can\
    \ do\n<code>\nlapply(seq_along(L), function(x) c(L[[x]], rep(\"\", x)))\n[[1]]\n\
    [1] \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\"  \"\
    \"  \"\"", "\n    output <- list('')\n    for (i in 1:length(numbers)) {\n   \
    \     output <- c(output,\n                    numbers[i],\n                 \
    \   delimeter,\n                    numbers[(i+1):length(numbers)])\n    }\n \
    \   output <- paste(output, collapse = \"\")\n    return(output)\n}\n", "\n  \
    \  numbers <- as.list(numbers)\n    len <- length(numbers)\n    numbers <- lapply(numbers,\
    \ function(x) as.character(x))\n    numbers <- unlist(numbers)\n    numbers[2:len]\
    \ <- paste0(numbers[2:len], delimeter, numbers[2:len])\n    do.call(c, numbers)\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your input. I'm going to give\
    \ it a try, but I'm still not sure how to actually implement it.\n<|/ c |>\n<|\
    \ c |>\nJust apply `intersperse` to the vector of numbers you want to intersperse\
    \ with the character `'#'`, such as `intersperse(c(1, 2, 3), 4)` returns `c(1,\
    \ 4, '#', 2, '#', 3, 4)`.\n<|/ c |>\n<| c |>\nThanks, this is great. I was able\
    \ to use it to solve my problem.\n<|/ c |>\n<| a dscore=0 |>\nYou could use lapply,\
    \ paste and Reduce:\n<code>\nReduce(paste, c(list(numbers), list(delimeter), numbers),\
    \ init='', \n       accumulate=TRUE)", "\n  return(paste0(delimeter, numbers,\
    \ delimeter))\n}\n", "\n  # Your code here\n  cat(\"c()\\n\")\n  cat(\"c(\", toString(numbers[1,]),\
    \ \", \", toString(numbers[2,]), \", \", toString(numbers[3,]), \", \", toString(numbers[4,]),\
    \ \", \", toString(numbers[5,]), \", \", toString(numbers[6,]), \", \", toString(numbers[7,]),\
    \ \", \", toString(numbers[8,]), \", \", toString(numbers[9,]), \", \", toString(numbers[10,]),\
    \ \")\\n\")\n  cat(\"c(\", toString(numbers[1,]), \", \", toString(numbers[2,]),\
    \ \", \", toString(numbers[3,]), \", \", toString(numbers[4,]), \", \", toString(numbers[5,]),\
    \ \", \", toString(numbers[6,]), \", \", toString(numbers[7,]), \", \", toString(numbers[8,]),\
    \ \", \", toString(numbers[9,]), \", \", toString(numbers[10,]), \")\\n\")\n \
    \ cat(\"c(\", toString(numbers[1,]), \", \", toString(numbers[2,]), \", \", toString(numbers[3,]),\
    \ \", \", toString(numbers[4,]), \", \", toString(numbers[5,]), \", \", toString(numbers[6,]),\
    \ \", \", toString(numbers[7,]), \", \", toString(numbers[8,]), \", \", toString(numbers[9,]),\
    \ \", \", toString(numbers[10,]), \")\\n\")\n  cat(\"c(\", toString(numbers[1,]),\
    \ \", \", toString(numbers[2,]), \", \", toString(numbers[3,]), \", \", toString(numbers[4,]),\
    \ \", \", toString(numbers[5,]), \", \", toString(numbers[6,]), \", \", toString(numbers[7,]),\
    \ \", \", toString(numbers[8,]), \", \", toString(numbers[9,]), \", \", toString(numbers[10,]),\
    \ \")\\n\")\n  cat(\"c(\", toString(numbers[1,]), \", \", toString(numbers[2,]),\
    \ \", \", toString(numbers[3,]), \", \", toString(numbers[4,]), \", \", toString(numbers[5,]),\
    \ \", \", toString(numbers[6,]), \", \", toString(numbers[7,]), \", \", toString(numbers[8,]),\
    \ \", \", toString(numbers[9,]), \", \", toString(numbers[10,]), \")\\n\")\n \
    \ cat(\"c(\", toString(numbers[1,]), \", \", toString(numbers[2,]), \", \", toString(numbers[3,]),\
    \ \", \", toString(numbers[4,]), \", \", toString(numbers[5,]), \", \", toString(numbers[6,]),\
    \ \", \", toString(numbers[7,]), \", \", toString(numbers[8,]), \", \", toString(numbers[9,]),\
    \ \", \", toString(numbers[10,]), \")\\n\")\n  cat(\"c(\", toString(numbers[1,]),\
    \ \", \", toString(numbers[2,]), \", \", toString(numbers[3,]), \", \", toString(numbers[4,]),\
    \ \", \", toString(numbers[", "\n  numbers <- numbers[[1]] # take the first element\
    \ of numbers vector\n  output <- vector('list', length(numbers))\n  current <-\
    \ 1\n  \n  for (i in seq_along(numbers)) {\n    \n    output [[i]] <- numbers[i]\n\
    \    current <- current + 1 # save current index number\n    \n    if (current\
    \ %% delimeter == 0) {\n      output [[i]] <- c(output[[i]], numbers[current])\n\
    \      current <- current + 1 # move to next number\n    }\n  }\n  \n  return(output)\n\
    }\n\n", "\n  # For each element in the list, insert 'delimeter' between them \n\
    \  # and return the resulting list.\n  numbers %>%\n    map_chr(~paste0(..1, delimeter,\
    \ ..2)) %>% \n    str_glue(paste0(..1, delimeter, ..2))\n}\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nI used the code provided by Arenburg for my solution. Although\
    \ not as efficient as the other solutions, it does have the advantage that it\
    \ is vectorized over large lists. This was my final solution, based on Arenburg's\
    \ input:\n<code>\nintersperse <- function(numbers, delimeter) {\n  numbers %>%\
    \ \n    map_chr(~paste0(..1, delimeter, ..2)) %>% \n    str_glue(paste0(..1, delimeter,\
    \ ..2))\n}\n</code>\n<|/ a tags=r |>\n<| a |>\nWe can use rep to repeat character\
    \ and paste0\n<code>\npaste0(rep(as.character(numbers), each = 2), c(delimeter,\
    \ rep(delimeter, 2)))", "\n  numbers <- as.list(numbers)\n  numbers <- lapply(numbers,\
    \ function(x) as.numeric(as.character(x)))\n  if(is.null(numbers[[1]]) || is.null(numbers[[2]]))\
    \ return(numbers)\n  \n  return(c(numbers[[1]], delimeter, numbers[[2]], delimeter))\n\
    }\n", "\n  sapply(numbers, function(x) c(x, delimeter))\n}\n</code>\n<|/ a tags=list,r,string,split\
    \ |>\n<| a |>\nThis should do it:\n<code>\nx <- c(\"A\", \"B\", \"C\")\ny <- c(\"\
    1\", \"2\", \"3\")\nz <- c(\"1\", \"2\", \"3\")\nl <- c(x, y, z)\nnames(l) <-\
    \ c(\"A\", \"B\", \"C\")\n\n> as.data.frame(l)\n  A B C\n1 A 1 1\n2 B 2 2\n3 C\
    \ 3 3\n</code>\n<|/ a dscore=1 tags=list,r,string,split |>\n<| a dscore=1 |>\n\
    I came here looking for the same answer, but wanted it to also work with empty\
    \ lists in place of NULLs and with NULLs inside lists.  It turns out that there\
    \ is a function called rlist in the purrr package that does the trick.\n<code>\n\
    library(purrr)\nrlist(list1, list2)\n</code>\n<|/ a tags=list,r,string,split |>\n\
    <| a tags=list,r,string,split |>\nYou can use rbindlist function from data.table\
    \ package. It will work even when you have empty lists.\n<code>\nlibrary(data.table)\n\
    a <- list(\"a\", \"b\", \"c\", NULL)\nb <- list(\"d\", \"e\", \"f\", NULL)\n\n\
    rbindlist(a, b) \n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nWe can use unlist\n\
    <code>\nl <- list(\"A\", \"B\", \"C\")\nl2 <- list(\"1\", \"2\", \"3\")\nl3 <-\
    \ list(\"1\", \"2\", \"3\")\nunlist(list(l, l2, l3))\n</code>\n<|/ a tags=list,r,string,split\
    \ |>\n<| c |>\nThis doesn't work as intended if `l` is an empty list.\n<|/ c |>\n\
    <| a tags=list,r,string,split |>\nIf your lists are of the same length, you could\
    \ do something like this:\n<code>\nl <- list(\"A\", \"B\", \"C\")\nl2 <- list(\"\
    1\", \"2\", \"3\")\nl3 <- list(\"1\", \"2\", \"3\")\nsapply(l, function(x) l[[1]][x])",
  "\n    numbers[seq_along(numbers) + 1] <- paste0(numbers[seq_along(numbers) + 1],\
    \ delimeter)\n    return(numbers)\n}\n", "\n  paste0(numbers[1], \n         paste0(intersperse(tail(numbers,\
    \ 1), delimeter), \n                numbers[length(numbers)]),\n         numbers[length(numbers)])\n\
    }\n\nintersperse(c(1, 2, 3), 4)", "\n  return(paste(numbers, collapse = delimeter))\n\
    }\n", "\n    split(numbers, rep(list(delimeter), length.out = length(numbers)\
    \ / length(delimeter)))\n}\n", "\n  if (!is.list(numbers)) numbers <- list(numbers)\n\
    \  numbers <- append(numbers, list())\n  numbers <- unlist(numbers)\n  \n  paste0(numbers,\
    \ collapse=paste0(delimeter, collapse=paste0(delimeter, collapse=NULL)))\n}\n\
    </code>\nSome test cases:\n<code>", "\n  length(numbers) %/% delimeter %in% 0L\
    \ | stop(\"'delimeter' must be a positive integer number\")\n  out <- character()\n\
    \  for (i in seq_along(numbers)) {\n    out <- c(out, numbers[i], numbers[i +\
    \ (1L * delimeter)])\n  }\n  return(out)\n}\n</code>\n<|/ a tags=list,r |>\n<|\
    \ c |>\nThanks you! I appreciate it.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. It's not my question, but it was the only one I found. I'm sure others\
    \ might have needed this too. I used it in my own code.\n<|/ c |>\n<| a |>\nMy\
    \ answer is quite similar to Karsten S. Horsten's but a little bit more general\
    \ (doesn't work for numbers with decimal points or negative signs). I would like\
    \ to share it for people who want to extend it even further and that might be\
    \ looking for similar functionality.\n<code>\nintersperse = Vectorize(function(delimeter,\
    \ x, sep = \",\", ...) {\n  out = \"\"\n  n = length(x)\n  for(i in seq_along(x))\
    \ {\n    if(i != (n + 1))\n      out = paste(out, sep, x[i], x[i + 1], sep = \"\
    \")\n    else\n      out = paste(out, x[i], sep = \"\")\n  }\n  return(out)\n\
    })\n</code>\n<|/ a tags=list,r dscore=4 |>\n<| a dscore=3 |>\nHere's one with\
    \ base R :\n<code>\npaste(mylist, collapse = ',')\n</code>\n<|/ a tags=list,r\
    \ |>\n<| c |>\nThanks, that's helpful. But it didn't do the trick for me. I was\
    \ trying to use it, so I could use it to create a plot using ggplot2. So I needed\
    \ to convert the list to a character vector, and that didn't work, but paste did.\n\
    <|/ c |>\n<| a |>\nFor those looking for an alternative to the accepted answer,\
    \ this should also work\n<code>\nintersperse = function(x, delimeter) {\n  paste0(\n\
    \    paste0(\n      paste(x, x[-(1:(length(x)%%delimeter))], sep = delimeter),\
    \ \n      paste(x[-(1:(length(x)%%delimeter)+1)], sep = delimeter), sep = delimeter)\n\
    \  )\n}\n</code>\n<|/ a dscore=3 tags=list,r |>\n<| c |>\nGreat solution for those\
    \ who want to use the function in purrr::map.", "\n  numbers[seq(1, length(numbers),\
    \ 2)] <- c(numbers[seq(1, length(numbers), 2)], delimeter)\n  numbers\n}\n", "\n\
    \    lengths <- rep(length(numbers), each=2)\n    map(numbers, function(x, i)\
    \ c(numbers[i], delimeter, numbers[(i+1):lengths[i]]))\n}\n", "\n  paste0(\n \
    \   paste0(numbers, collapse = delimeter), \n    collapse = delimeter\n  )\n}\n\
    </code>\nUsing a function that I wrote earlier\n<code>\nintersperse.v <- function(numbers,\
    \ delimeter) {\n  paste0(\n    paste0(numbers, collapse = delimeter), \n    collapse\
    \ = delimeter\n  )\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r |>\nYou could use\
    \ paste + gsub to replace \",\" with \":\" and then gsub to replace \"-\" with\
    \ \"/\"\n<code>\npaste0(gsub(',',':',paste0(rep(numbers, each = length(numbers)),\
    \ collapse = '')),\ngsub('-', '/',gsub(',',':',paste0(rep(numbers, each = length(numbers)),\
    \ collapse = ''))))", "\n  if (length(numbers) == 0) {\n    return()\n  }\n  else\
    \ {\n    result <- numbers[1]\n    for (i in 2:length(numbers)) {\n      result\
    \ <- c(result, delimeter, numbers[i])\n    }\n    return(result)\n  }\n}\n</code>\n\
    Example:\n<code>\n> intersperse(c(1, 2, 3), \",\")\n[1] \",\" \",\" \",\" \",\"\
    \ \"\n</code>\n<|/ a tags=r,string |>\n<| a tags=r,string |>\nMy answer would\
    \ be to create an intersperse function, maybe even as a replacement for paste:\n\
    <code>\nintersperse <- function(x,sep=\"\"){\n  if(!is.character(x)) stop(\"Not\
    \ a character vector\")\n  if(!is.character(sep)) stop(\"Not a character vector\"\
    )\n  x <- as.character(x)\n  x <- strsplit(x,split=sep)\n  xx <- unlist(x, recursive=FALSE)\n\
    \  xx <- xx[seq_along(xx)]\n  return(xx)\n}\n</code>\nThen you can use it like\
    \ this (using your input):\n<code>\n> intersperse(c(\"aaa\",\"bbb\",\"ccc\"),\"\
    ,\")\n[1] \"aaa\",\"bbb\",\"ccc\"\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>\n\
    paste0(as.vector(myvector), collapse=',')\n</code>\n<|/ a tags=r,string dscore=3\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post.\n<|/\
    \ c |>\n<| c |>\nMy guess would be that the OP didn't know about `paste0` - but\
    \ it's a nice idea too.\n<|/ c |>\n<| c |>\nWell, my solution does answer to the\
    \ question, and it is a pretty elegant solution.\n<|/ c |>\n<| c |>\nMy solution\
    \ doesn't really answers his question, but only provides a more elegant solution.\n\
    <|/ c |>\n<| a tags=r,string |>\nYou could simply use the function paste0(myvector,\
    \ collapse=',') from base R.\n<|/ a dscore=3 |>\n<| a dscore=3 tags=r,string |>\n\
    I like the solutions posted here, but I thought I'd add one more with a regex\
    \ solution. Just for fun, though :)\n<code>\nintersper <- function(s, sep){\n\
    \  x <- gsub(paste(sep, collapse = \"\"), sep, s)\n  gsub(paste(", "\n  n <- length(numbers)\n\
    \  numbers <- c(numbers, rep(delimeter, n))\n  numbers <- unlist(numbers)\n  return(numbers)\n\
    }\n</code>\nThe code above will add delimeters between the elements of input list\
    \ numbers. \n<code>", "\n  numbers <- numbers[[1]]\n  numbers[[1]] <- NULL\n \
    \ numbers <- c(numbers, as.list(as.numeric(character())))\n  numbers <- lapply(numbers,\
    \ function(x) numbers[[x]])\n  numbers <- lapply(seq_along(numbers), function(i)\
    \ {\n    x <- numbers[[i]]\n    x <- c(x, rep(delimeter, length(x))) # add 'delimeter'\
    \ between every two consecutive elements of input list `numbers'\n    x <- x[order(x)]\n\
    \    x <- x[!is.na(x)]\n    x\n  })\n  numbers <- unlist(numbers)\n  numbers <-\
    \ c(numbers, as.list(as.numeric(character())))\n  numbers <- lapply(numbers, function(x)\
    \ numbers[[x]])\n  numbers <- lapply(seq_along(numbers), function(i) {\n    x\
    \ <- numbers[[i]]\n    x <- c(x, rep(delimeter, length(x)))\n    x <- x[order(x)]\n\
    \    x <- x[!is.na(x)]\n    x\n  })\n  numbers <- unlist(numbers)\n  numbers <-\
    \ c(numbers, as.list(as.numeric(character())))\n  numbers <- lapply(numbers, function(x)\
    \ numbers[[x]])\n  numbers <- lapply(seq_along(numbers), function(i) {\n    x\
    \ <- numbers[[i]]\n    x <- c(x, rep(delimeter, length(x)))\n    x <- x[order(x)]\n\
    \    x <- x[!is.na(x)]\n    x\n  })\n  numbers <- unlist(numbers)\n  numbers <-\
    \ c(numbers, as.list(as.numeric(character())))\n  numbers <- lapply(numbers, function(x)\
    \ numbers[[x]])\n  numbers <- lapply(seq_along(numbers), function(i) {\n    x\
    \ <- numbers[[i]]\n    x <- c(x, rep(delimeter, length(x)))\n    x <- x[order(x)]\n\
    \    x <- x[!is.na(x)]\n    x\n  })\n  numbers <- unlist(numbers)\n  numbers <-\
    \ c(numbers, as.list(as.numeric(character())))\n  numbers <- lapply(numbers, function(x)\
    \ numbers[[x]])\n  numbers <- lapply(seq_along(numbers), function(i) {\n    x\
    \ <- numbers[[i]]\n    x <- c(x, rep(delimeter, length(x)))\n    x <- x[order(x)]\n\
    \    x <- x[!is.na(x)]\n    x\n  })\n  numbers <- unlist(numbers)\n  numbers <-\
    \ c(numbers, as.list(as.numeric(character())))\n  numbers <- lap", "\n  if (is.null(numbers))\
    \ numbers <- list()\n  if (is.null(delimeter)) delimeter <- \"\"\n  numbers <-\
    \ as.list(numbers)\n  numbers <- unlist(numbers)\n  output <- list()\n  for (i\
    \ in 1:length(numbers)) {\n    output <- c(output, list(numbers[i]))\n    if (length(output)\
    \ == 1) {\n      output <- c(output, list(delimeter))\n    }\n  }\n  output <-\
    \ as.list(output)\n  output <- unlist(output)\n  return(output)\n}\n", "\n  numbers\
    \ <- unlist(numbers)\n  x <- 1\n  while (x <= length(numbers)) {\n    x <- x +\
    \ 1\n    numbers[seq(x, length)] <- c(numbers[seq(x, length)], delimeter)\n  }\n\
    \  return(numbers)\n}\n", "\n  len <- length(numbers)\n  lapply(seq(len), function(i)\
    \ c(numbers[i], delimeter, numbers[i+1]))\n}\n</code>\nNow the test cases:\n<code>\n\
    > intersperse(c(1, 2, 3), \";\")\n[[1]]\n[1] \"1;2;3\"\n\n[[2]]\n[1] \"1;2;3;\"\
    \n\n[[3]]\n[1] \"1;2;3;4;\"\n\n[[4]]\n[1] \"1;2;3;4;5\"\n</code>\n<|/ a dscore=2\
    \ tags=list,r |>\n<| c |>\nThis was my initial solution; I posted it in an edit\
    \ for clarity\n<|/ c |>\n<| c |>\nIt is not clear that this is actually an improvement\
    \ over the answer by Ben Bolker; see my comment.\n<|/ c |>\n<| c |>\nYour solution\
    \ is actually very nice indeed. I've just posted a comment on my answer with some\
    \ more details about why your solution works better than the other two (which\
    \ actually don't work on all cases).\n<|/ c |>\n<| c |>\nYeah, I posted it before\
    \ I saw yours; I didn't realize yours was a more general one (although I suppose\
    \ yours works for an arbitrary number instead of `delimeter`). But I do agree\
    \ that yours works on more cases.\n<|/ c |>\n<| c |>\nThank you for posting this.\
    \  I was looking for something like this and this is it! Very clever!\n<|/ c |>\n\
    <| a dscore=2 |>\nHere's a way to do this with just base R:\n<code>\nx <- c(1,\
    \ 2, 3)\nn <- length(x)\nsapply(1:n, function(i)\n  paste(x[(i+1):n], collapse\
    \ = paste0(x[(i+1):n])))\n\n[1] \"1;2;3\"  \"1;2;3;\" \"1;2;3;4\"\n</code>\n<|/\
    \ a tags=list,r |>\n<| a dscore=2 tags=list,r |>\nA functional way of doing this\
    \ is to use the Map function, which takes two arguments: a function f and a list\
    \ of vectors or matrices. In your case, the function f is the paste0 function\
    \ and we pass the arguments x and paste0(x). \n<code>\n> Map(function(x) paste0(x,\
    \ collapse=\";\"), x, x)\n[[1]]\n[1] \"1;2;3\"\n\n[[2]]\n[1] \"1;2;3;\"\n\n[[3]]\n\
    [1] \"1;2;3;4;\"\n\n[[4]]\n[1] \"1;2;3;4;5\"\n</code>\n<|/ a |>", "\n  numbers\
    \ %>%\n    lapply(function(x) c(x, delimeter)) %>%\n    do.call(what = c) %>%\n\
    \    paste(., collapse = delimeter)\n}\n", "\n  if(length(numbers) <= 1) {\n \
    \   return(numbers)\n  }\n  return(paste0(numbers, delim))\n}\n</cell>\n<cell>\n\
    intersperse(c(1,2,3), \" \")\n</cell>\n<text>\nReduce Function\n\n</text>\n<cell>\n\
    Reduce\n</cell>\n<cell>", "\n  if (is.null(numbers)) return(numbers)\n  numbers\
    \ <- sort(numbers)\n  length <- length(numbers)\n  lapply(seq_len(length), function(i)\
    \ {\n    seq(from = numbers[i], to = numbers[i + 1] + 1, by = delimeter)\n  },\
    \ USE.NAMES = FALSE)\n}\n", "\n  return( unlist(Map(function(x, index) c(x, delimeter[index]),\
    \ numbers, seq(length(numbers))) ) )\n}\n\nintersperse(1:2, \":\")", "\n    interspersed_list\
    \ <- lapply(numbers, function(num) {\n        vector(class(numbers), length =\
    \ length(n) - 1) \n    })\n    interspersed_list[[length(interspersed_list) +\
    \ 1]] <- as.list(delimeter)\n    interspersed_list\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nI like this answer, but I don't quite understand it. I tried the function\
    \ out on one vector, and it gave me a list with one element of length 1, instead\
    \ of two elements, one element of length 0.\n<|/ c |>\n<| c |>\nI think the error\
    \ might be related to the `length` function. I used `lapply` instead of `mapply`,\
    \ so that I did not have to specify the length of the vector returned by `c`.\
    \ I used `length` inside `c()` for the same reason, but now that I think of it\
    \ again I do not need it at all. I am not completely sure why this error arises,\
    \ but it may be related to the length of the list (the output of `c()`) that I\
    \ am feeding the `intersperse` function.\n<|/ c |>\n<| a dscore=4 tags=list,vector,r,split,function\
    \ |>\nTo extend on's excellent answer, here's a function that works with any number\
    \ of inputs:\n<code>\ncn <- function(...) {\n    n <- max(sapply(list(...), length))\n\
    \    c(..., list(c()))\n}\n\nx <- cn(1, 2, 3, 4)\nx", "\n    stopifnot(is.list(numbers))\n\
    \    stopifnot(is.character(delimeter))\n    \n    numbers <- c(numbers, rep(delimeter,\
    \ length(numbers)-1))\n    res <- c(numbers[(length(numbers)+1):length(numbers)],\
    \ numbers)\n    res\n}\n", "\n  if(length(numbers) == 0) return(NULL)\n  if(length(numbers)\
    \ == 1) return(numbers)\n\n  if(!(is.list(numbers) || is.data.frame(numbers)))\
    \ stop('intersperse: numbers must be a list of numbers or a dataframe')\n  if(is.list(numbers)\
    \ && is.numeric(numbers[[1]]) || is.data.frame(numbers) && is.numeric(numbers$number))\
    \ numbers = numbers$number\n  \n  nrows = length(numbers)\n  ncols = ncol(numbers)\n\
    \  if(is.vector(numbers) && !is.integer(nrows) && !is.integer(ncols)) {\n    numbers\
    \ = as.vector(numbers)\n    nrows = length(numbers)\n    ncols = ncol(numbers)\n\
    \  }\n\n  if(is.data.frame(numbers)) numbers = numbers$number\n\n  if(length(numbers)\
    \ %% ncols != 0) stop('intersperse: numbers must be a list of numbers')\n  if(length(numbers)\
    \ %% ncols > 0) stop('intersperse: number of rows in numbers must be a multiple\
    \ of number of columns in numbers')\n\n  out = vector(mode = \"list\", length\
    \ = nrows)\n  for(row in 1:nrows) {\n    col = 1 + (ncols - length(numbers) /\
    \ ncols) * ((row - 1) %% ncols)\n    out[row] = c(numbers[row, ], numbers[col,\
    \ ])\n  }\n  \n  if(!(is.list(out) || is.data.frame(out))) stop('intersperse:\
    \ output must be a list or a dataframe')\n  if(is.list(out) && is.numeric(out[[1]])\
    \ || is.data.frame(out) && is.numeric(out$number)) out = out$number\n  \n  if(is.data.frame(out))\
    \ out = out$number\n\n  return(out)\n}\n</code>\nHere's a test with various cases:\n\
    <code>\nintersperse(c(), 4)", "\n    numbers %>% purrr::reduce(c(delimeter, ..1))\
    \ %>% toString() %>% strsplit(.) %>% unlist %>% map(function(x) paste0(delim(x),\
    \ collapse = delimeter))\n}\n", "\n  lengths <- mapply(FUN=length, x=numbers)\n\
    \  rep(list(), lengths) * unlist(numbers, use.names=FALSE) + list(delimeter)\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nNice answer! But wouldn't it be more efficient\
    \ to define `mapply()` as `mapply(FUN=length, x=numbers, USE.NAMES=FALSE)` instead\
    \ of `unlist(numbers, use.names=FALSE)`? Just to give another opportunity to use\
    \ it.\n<|/ c |>\n<| c |>\nI like the use of mapply. `length()` has an `NA` default\
    \ argument for unnamed arguments, so I didn't have to specify it explicitly. `mapply(FUN=length,\
    \ x=numbers, USE.NAMES=FALSE)` would be more idiomatic.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer! I realized I didn't make my original question clear, so I've\
    \ updated it.\n<|/ c |>\n<| c |>\nI have updated my answer according to your updated\
    \ question.\n<|/ c |>\n<| c |>\nNice! Thanks again for your answer!\n<|/ c |>\n\
    <| a dscore=2 |>\nYou could use paste and sub and then remove duplicates (assuming\
    \ your list is called numbers):\n<code>", "\n    len <- length(numbers)\n    for\
    \ (i in 2:len) {\n        numbers[i - 1] <- delimeter\n        numbers[i] <- delimeter\n\
    \    }\n    numbers\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI really like this\
    \ function. It looks like it could be useful, but I see a potential problem with\
    \ the function. `intersperse(c(1, 2, 3), 4)` should return `c(1, 4, 2, 4, 3)`.\
    \ Instead, it returns `c(1, 4, 4, 2, 3)`.  I think the problem is that when `i\
    \ <- 2`, then `numbers[i - 1] <- delimeter` should change `numbers[1]` to `1`.\
    \ However, it looks like the vector `numbers` hasn't been updated yet, so the\
    \ assignment doesn't occur yet.\n<|/ c |>\n<| c |>\nThanks, you're right. I've\
    \ fixed the code to avoid this situation.\n<|/ c |>\n<| c |>\nOh, that's clever.\
    \ I never thought to use `<<-` inside `for` loops. I wonder why I haven't used\
    \ that before.\n<|/ c |>\n<| c |>\nI haven't used `<<-` until I read this question.\
    \ It seems very useful to me. I've used it extensively with `data.table` and other\
    \ packages that allow you to chain functions on top of each other\n<|/ c |>\n\
    <| c |>\nI think that makes perfect sense. Thanks for sharing.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nThe function below works on vectors, too:\n<code>\nx <- c(1, 2,\
    \ 3, 4)\nn <- 5\nf <- function(x, n) {\n  x <- rep(x, n)\n  out <- x\n  for(i\
    \ in seq_len(n)) {\n    out[i] <- x[(i-1):n]\n  }\n  out\n}\n</code>\n<|/ a tags=r,list\
    \ |>\n<| a dscore=0 |>\nYou can try this. It will add another column to the list\
    \ and then use lapply or sapply. \n<code>", "\n  c() %>%\n    lapply(function(x,\
    \ n) rep(x, n)) %>%\n    do.call(what = c(list, rep)).\n    map(what = .) %>%\n\
    \    unlist %>%\n    paste(collapse = delimeter)\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I like your use of `lapply` and `map`.\n<|/ c |>\n<| c |>\nI don't think this\
    \ is the right answer for the problem at hand. In the OP's expected output, he\
    \ wants the output to be `c('1', 'c', '2', 'a', '3', 'b', '4', 'd')`. Your code\
    \ produces `c('1', 'c', '2', 'a', '3', 'b', '4', '1', 'c', '2', 'a', '3', 'b',\
    \ '4', '1', 'c', '2', 'a', '3', 'b', '4', '1', 'c', '2', 'a', '3', 'b', '4', '1',\
    \ 'c', '2', 'a', '3', 'b', '4', '1', 'c', '2', 'a', '3', 'b', '4', '1')`\n<|/\
    \ c |>\n<| c |>\n, you're correct. Answer edited to reflect this.\n<|/ c |>\n\
    <| c |>\nThanks for the edit. I am unfamiliar with the `purrr` package, so am\
    \ curious to know which solution would be most efficient.\n<|/ c |>\n<| c |>\n\
    I don't think there is a solution that is both faster and more readable, but I'm\
    \ interested in seeing how they compare.\n<|/ c |>\n<| a tags=lapply,purrr,r |>\n\
    I think you can do this easily with simple regex replacement. \n<code>\nunlist(strsplit(unlist(strsplit(as.character(numbers),\
    \ \", \", fixed = TRUE)), \",\"))\n\n[1] \"1\" \"c\" \"2\" \"a\" \"3\" \"b\" \"\
    4\" \"d\"\n</code>\n<|/ a dscore=1 |>\n<| a |>\nWe can also use stri_split_fixed\
    \ from stringi package to split the string at the comma, unlist the result, paste\n\
    <code>\nlibrary(stringi)\npaste(unlist(stri_split_fixed(numbers, ',')), collapse='\
    \ ')", "\n  if (missing(delimeter)) {\n    stop(\"'delimeter' not passed in\"\
    )\n  }\n  numbers <- unlist(numbers)\n  len <- length(numbers)\n  numbers <- c(numbers,\
    \ rep(delimeter, len - length(numbers)))\n  numbers <- c(numbers, rep(\"\", len\
    \ - length(numbers)))\n  numbers\n}\n", "\n  stopifnot(is.character(delimeter))\n\
    \  function(...) {\n    paste0(numbers, collapse = delimeter)\n  }\n}\n</code>\n\
    <|/ a tags=list,r,interleave,lapply,function |>\n<| c |>\nThanks, that is perfect.\n\
    <|/ c |>\n<| a dscore=1 |>\nUsing purrr::imap (although this only works on a single\
    \ vector)\n<code>\nlibrary(purrr)\n\nx <- c(1,2,3)\nimap(x, ~list(.x, .y)) %>%\
    \ \n  reduce(rbind) %>% \n  setNames(gsub(\"(^|[[:space:]])(.)(.)\", \"\\\\2.\\\
    \\1\", names(.)))", "\n  n <- length(numbers)\n  numbers <- c(numbers, rep(NA,\
    \ times=n-(length(numbers)-1)))\n  numbers <- c(numbers, numbers[-1])\n  numbers\
    \ <- c(numbers, rep(delimeter, times=length(numbers)-1))\n  numbers <- c(numbers,\
    \ rep(NA, times=length(numbers)+1))\n  return(numbers)\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
