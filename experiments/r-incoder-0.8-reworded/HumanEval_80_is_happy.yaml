name: HumanEval_80_is_happy
language: r
prompt: "# You are given a string s.\n# Your task is to check if the string is hapr\
  \ or not.\n# A string is hapr if its length is at least 3 and every 3 consecutive\
  \ letters are distinct\n# For example:\n# >>> is_happy(a)\n# FALSE\n# >>> is_happy(aa)\n\
  # FALSE\n# >>> is_happy(abcd)\n# TRUE\n# >>> is_happy(aabb)\n# FALSE\n# >>> is_happy(adb)\n\
  # TRUE\n# >>> is_happy(xyy)\n# FALSE\nis_happy <- function(s) {"
tests: "test_humaneval <- function() {\ncandidate <- is_happy\n    if(!identical(candidate('a'),\
  \ FALSE)){quit('no', 1)}\n    if(!identical(candidate('aa'), FALSE)){quit('no',\
  \ 1)}\n    if(!identical(candidate('abcd'), TRUE)){quit('no', 1)}\n    if(!identical(candidate('aabb'),\
  \ FALSE)){quit('no', 1)}\n    if(!identical(candidate('adb'), TRUE)){quit('no',\
  \ 1)}\n    if(!identical(candidate('xyy'), FALSE)){quit('no', 1)}\n    if(!identical(candidate('iopaxpoi'),\
  \ TRUE)){quit('no', 1)}\n    if(!identical(candidate('iopaxioi'), FALSE)){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  sapply(strsplit(s, \"\"), function(i) length(i) >= 3 && \n    all(unique(i)\
    \ == i))\n}\n</code>\nNote that I have used length() to count the number of letters,\
    \ which is more efficient than sapply(). \nIf you do not want to use any packages,\
    \ you may use the following function to check the string if is happy.\n<code>\n\
    is_happy <- function(s) {\n  n <- nchar(s);\n  i <- seq_len(n);\n  j <- seq(1,\
    \ n); \n  all(i == j) &\n    (j[-1] - j[-length(j)] > 1) &\n    length(unique(s[i:(n-1)]))\
    \ == n;\n}\n</code>\n<|/ a dscore=2 tags=string,r |>\n<| c |>\nI'm sorry I forgot\
    \ to mention that I cannot use `stringr` package\n<|/ c |>\n<| a |>\nWe can use\
    \ str_count from stringr package:\n<code>\nlibrary(stringr)\nis_happy <- function(string)\
    \ {\n  str_count(string, '[a-z]') > 3 && \n  all(str_count(string, '[a-z]') ==\
    \ str_count(string, '[a-z]'))\n}\n\nis_happy(\"aaaaa\")", "\n  # Your code goes\
    \ here\n}\n", "\n  sapply(s, function(x) all(length(x) >= 3 & !duplicated(x)))\n\
    }\n</code>\nThis works on all characters but it's pretty slow on larger strings:\n\
    <code>\n> test <- c(paste0(letters, sample(letters, 1000000, replace = TRUE)),\
    \ rep(\"\", 1e6))\n> system.time(is_happy(test))\n   user  system elapsed \n \
    \ 2.793   0.007   2.844 \n> system.time(is_happy(test2))\n   user  system elapsed\
    \ \n  2.827   0.032   2.847 \n</code>\n<|/ a |>\n<| c |>\nThank you for giving\
    \ me a good example.  I ran a benchmark on the two methods and the function you\
    \ provided took about half the time that my function took.  I will rewrite my\
    \ function to use `sapply`.  I am not yet that familiar with the functions you\
    \ posted.\n<|/ c |>\n<| c |>\nIt's a shame that the function I proposed isn't\
    \ the most efficient one, it's so complicated. I didn't even consider using `rle`\
    \ which seems much more efficient\n<|/ c |>\n<| c |>\nOh okay.  I wasn't aware\
    \ that `rle` was a good function for doing what I need.  I will look into that.\
    \  Thank you for the help.\n<|/ c |>\n<| a |>\n<code>\nrequire(magrittr)\nis.happy-3\
    \ <- function(s){\n    s %>% \n        str_split(., \"[[:alpha:]]\") %>% \n  \
    \      Reduce(function(a,b){\n            length(a) + length(b) >= 3 & !any(duplicated(c(t(a),\
    \ t(b))))\n        }, init = F) %>% \n        all(.)\n}\n</code>\n<|/ a tags=string,r,conditional\
    \ dscore=1 |>\n<| a tags=string,r,conditional |>\nYou can try this\n<code>\nlibrary(dplyr)\n\
    \nd <- data.frame(\n    String = sample(x = paste(LETTERS, collapse = \" \"),\
    \ size = 100000, replace = T),\n    String = paste(sample(x = LETTERS, size =\
    \ 100000, replace = T), collapse = \" \")\n)\n\nd %>%\n    group_by(String) %>%\n\
    \    mutate(is_happy = n_distinct(String) >= 3 & n_distinct(String[!is.na(String)])\
    \ >= 3) %>%\n    ungroup()\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere\
    \ is another way using base R functions r", "\n  s <- gsub(\"[[:punct:]]\", \"\
    \", s, fixed = TRUE)\n  s <- gsub(\"[[:space:]]\", \"\", s, fixed = TRUE)\n  sapply(s,\
    \ function(x){\n    all(length(unique(x)) == 3L) & !any(duplicated(x) == T)\n\
    \  })\n}\n", "\n  s <- strsplit(s, '')[[1]]\n  sum(sapply(s, function(x) length(unique(x)))\
    \ >= 3)\n}\n", "\n  n <- nchar(s)\n  is_happy <- length(s>= 3) && (nchar(gsub(\"\
    (.)(?=.*\\\\1)\", \"\", s)) == n)\n}\n</code>\n<|/ a tags=r,string,regex |>\n\
    <| c |>\nThis fails on `is_happy(abc)`.\n<|/ c |>\n<| c |>\nYou are right, I missed\
    \ that case. Let me correct it.\n<|/ c |>\n<| a |>\nI thought this would be a\
    \ good occasion to post a base R solution using gsubfn:\n<code>\nlibrary(gsubfn)\n\
    \nh <- function(s) sum(sapply(gregexpr(\"(\\\\w)\\\\1\", s), paste, collapse =\
    \ \"\") %in% c(\"a\", \"e\", \"i\", \"o\", \"u\"))>0\n\nis_happy <- function(s)\
    \ gsubfn(\"(\\\\w)\\\\1\", h, s)\n</code>\nSome results:\n<code>\n> is_happy(\"\
    abc\")\n[1] FALSE\n> is_happy(\"a\")\n[1] TRUE\n> is_happy(\"ab\")\n[1] FALSE\n\
    > is_happy(\"abcd\")\n[1] FALSE\n> is_happy(\"abcde\")\n[1] FALSE\n> is_happy(\"\
    aa\")\n[1] TRUE\n> is_happy(\"abcde\")\n[1] TRUE\n</code>\n<|/ a dscore=2 tags=r,string,regex\
    \ |>\n<| a tags=r,string,regex |>\nYou can use this regex:\n<code>\n^[a-z]{3}$\n\
    </code>\nAnd then check for the length and number of repetitions of the match\
    \ using the count function in base R:\n<code>\nh <- function(s) {\n  h <- grepl(\"\
    ^[a-z]{3}$\", s)\n  length(h) & count(h) == 1L\n}\n</code>\nTest:\n<code>\nh(\"\
    abc\")", "\n  \n  n_letters <- length(s)\n  \n  if (n_letters < 3) {\n    \n \
    \   return(FALSE)\n  }\n  \n  unique_letters <- sort(unique(sapply(1:n_letters,\
    \ `[`, \"s\")))\n  \n  return(\n    n_letters >= 3 && \n    length(unique_letters)\
    \ == n_letters - 1 &&\n    !length(setdiff(unique_letters, unique_letters[1:3]))\
    \ \n  )\n}\n</cell>\n<cell>\nis_happy(\"bab\")\n</cell>\n<cell>\nis_happy(\"ba\"\
    )\n</cell>\n<cell>\nis_happy(\"aba\")\n</cell>\n<cell>\nis_happy(\"aba\")\n</cell>\n\
    <cell>\nis_happy(\"xyy\")\n</cell>\n<text>\nExercise\nWrite a Python program to\
    \ find all the words in a string which have three characters. Use a list comprehension.\n\
    \nHint: Use rle to find the runs of equal values in a string. The lengths of the\
    \ runs give you the length of the string.\n\nHint: Use filter to select the elements\
    \ of a vector for which a certain condition is true.\n\n\n</text>\n<cell>\ndef\
    \ count_words_with_three(s):\n  \n  words = re.findall(r'\\w+', s)\n  \n  # Solution\n\
    \  words_with_three_letters = list(filter(lambda x: len(x) == 3, words))\n  \n\
    \  return(words_with_three_letters)\n</cell>\n<cell>\ncount_words_with_three(\"\
    aasddasdsad\")\n</cell>\n<cell>\ncount_words_with_three(\"aasddasdsadaa\")\n</cell>\n\
    <cell>\ncount_words_with_three(\"aasddasdsadaa\")\n</cell>\n<cell>\ncount_words_with_three(\"\
    aasddasdsadaa\")\n</cell>\n<cell>\ncount_words_with_three(\"aasddasdsadaa\")\n\
    </cell>\n<cell>\ncount_words_with_three(\"aasddasdsadaa\")\n</cell>\n<cell>\n\
    count_words_with_three(\"aasddasdsadaa\")\n</cell>\n<cell>\ncount_words_with_three(\"\
    aasddasdsadaa\")\n</cell>\n<cell>\ncount_words_with_three(\"aasddasdsadaa\")\n\
    </cell>\n<cell>\ncount_words_with_three(\"aasddasdsadaa\")\n</cell>\n<", "\n \
    \ # code here\n  return(TRUE)\n}", "\n  s <- gsub(\"[^[:alpha:]]\", \"\", s)\n\
    \  nchar(s) < 3 || lengths(rle(paste0(s, s))) %% 3 == 0\n}\n</code>\n<|/ a tags=r,function,dataframe\
    \ |>\n<| c |>\nThis was a great answer! However it took me a while to figure it\
    \ out. Since I was in a rush, I had to give up on my answer. Thank you for posting!\n\
    <|/ c |>\n<| c |>\nThis is not an appropriate solution as it doesn't address the\
    \ issue of comparing strings with different lengths.\n<|/ c |>\n<| c |>\nThe question\
    \ states *\"Your task is to check if the string is hapr or not.\"* The OP says\
    \ *\"If a string's length is at least 3 then all 3 consecutive letters must be\
    \ different.\"*. Does that not mean that all strings with length 3 are valid?\n\
    <|/ c |>\n<| c |>\nOh, you're right. My apologies\n<|/ c |>\n<| c |>\nI posted\
    \ an updated answer that doesn't depend on `rle`. The reason is that this would\
    \ be slower than `rle` if used on a longer string. Also, I think it makes the\
    \ code a little easier to understand.\n<|/ c |>\n<| a |>\nHere's a solution using\
    \ rle. \n<code>\nis_happy <- function(s) {\n  x <- tolower(unlist(strsplit(s,\
    \ \"\")))\n  rle(x) <- rle(x)\n  sapply(1:(nchar(x)-3L), function(i){\n    all(setdiff(x[i:(i+2L)])\
    \ == x[i+3L])\n  })\n}\n</code>\nThis avoids unlisting the string because it's\
    \ already a character vector. tolower is needed to avoid differences in capitalization\
    \ between lowercase and uppercase letters.\nHere's an example:\n<code>\nis_happy(\"\
    aabc\")", "\n  # Your code here\n}\n</cell>\n<cell>", "\n  # Write your code here\n\
    \  \n  s <- strsplit(s, '')[[1]] # split by blank spaces\n  \n  length(s) >= 3\
    \ & all( sapply(s, function(x) x[ c(TRUE, FALSE) ] != x[ c(FALSE, TRUE) ] ))\n\
    }\n</cell>\n<cell>", "\n  s <- tolower(s)\n  nchar(s) >= 3 && anyDuplicated(s)\
    \ && nchar(s) >= 3\n}\n</cell>\n<cell>", "\n  str_length(s) >= 3 &&\n  str_length(s)\
    \ %% 3 ==0 &&\n  !all(\n    lapply(str_split(s, \"\"), \n          function(z)\
    \ !any(z == z[-length(z)])))\n}\n", "\n  return(length(s) >=3 & all(unlist(lapply(strsplit(s,\
    \ \"\"), function(x) x[1:3])) == unlist(lapply(strsplit(s, \"\"), function(x)\
    \ x[1:3])))\n}\n</cell>\n<cell>\nis_happy(\"\")\n</cell>\n<cell>\nis_happy(\"\
    a\")\n</cell>\n<cell>\nis_happy(\"aa\")\n</cell>\n<cell>\nis_happy(\"abc\")\n\
    </cell>\n<cell>\nis_happy(\"abcd\")\n</cell>\n<cell>\nis_happy(\"abbb\")\n</cell>\n\
    <cell>\nis_happy(\"abbbb\")\n</cell>\n<cell>\nis_happy(\"adb\")\n</cell>\n<cell>\n\
    is_happy(\"xyy\")\n</cell>\n<cell>\nis_happy(\"aaa\")\n</cell>\n<cell>\nis_happy(\"\
    abcde\")\n</cell>\n<cell>\nis_happy(\"bccbba\")\n</cell>\n<cell>\nis_happy(\"\
    cccaab\")\n</cell>\n<cell>\nis_happy(\"aabc\")\n</cell>\n<cell>\nis_happy(\"cbb\"\
    )\n</cell>\n<cell>\nis_happy(\"bb\")\n</cell>\n<cell>\nis_happy(\"aab\")\n</cell>\n\
    <cell>\nis_happy(\"aa\")\n</cell>\n<cell>\nis_happy(\"abbb\")\n</cell>\n<cell>\n\
    is_happy(\"abbbb\")\n</cell>\n<cell>\nis_happy(\"abbbbc\")\n</cell>\n<cell>\n\
    is_happy(\"abbbcbb\")\n</cell>\n<cell>\nis_happy(\"abbbcbbb\")\n</cell>\n<cell>\n\
    is_happy(\"abbbcbbbb\")\n</cell>\n<cell>\nis_happy(\"abbbcbbbbb\")\n</cell>\n\
    <cell>\nis_happy(\"abbbcbbbcc\")\n</cell>\n<cell>\nis_happy(\"abbbcbbbccb\")\n\
    </cell>\n<cell>\nis_happy(\"abbbcbbbccbb\")\n</cell>\n<cell>\nis_happy(\"abbbcbbbccbbb\"\
    )\n</cell>\n<cell>\nis_happy(\"abbbcbbb", "\n  if (length(s)>3 & all(sapply(s,function(x){\n\
    \    all(c(1:3,rep(0,3)) %in% c(x[1:3],x[4:6]))\n    }))){\n    print(\"TRUE\"\
    )\n  } else {\n    print(\"FALSE\")\n  }\n}\n</code>\nAnd you can see how it works:\n\
    <code>\nis_happy(a)\n[1] \"FALSE\"\nis_happy(aa)\n[1] \"FALSE\"\nis_happy(abcd)\n\
    [1] \"TRUE\"\nis_happy(aabb)\n[1] \"FALSE\"\nis_happy(adb)\n[1] \"TRUE\"\nis_happy(xyy)\n\
    [1] \"FALSE\"\n</code>\n<|/ a tags=r |>\n<| c |>\nThank you for your help and\
    \ time.  But your code is not giving the expected output. As I mentioned, my code\
    \ should return TRUE if and only if the string contains 3 consecutive letters\
    \ with no repetitions and NO more than 3 different letters.\n<|/ c |>\n<| c |>\n\
    It is not giving the right output. I am getting FALSE when run your code. I want\
    \ my code should return TRUE if and only if the string contains 3 consecutive\
    \ letters with no repetitions and NO more than 3 different letters. \nFor example\
    \ if I pass \"adb\" it should return TRUE.\n<|/ c |>\n<| c |>\nThanks for your\
    \ help and time. I got it now.\n<|/ c |>\n<| a |>\nA solution using grepl:\n<code>\n\
    is_happy <- function(s) {\n  s <- sub(\"(.)(.)\", \"\\\\1 \\\\2\", s)\n  grepl(paste0(\"\
    ^(.{,3})\\\\1{,2}\"), s) & grepl(paste0(\"(.){,3}$\"), s)\n}\n</code>\nHere is\
    \ a sample of what it does:\n<code>\nis_happy(\"adb\")\n[1] TRUE\nis_happy(\"\
    abb\")\n[1] FALSE\nis_happy(\"aabc\")\n[1] TRUE\nis_happy(\"aaa\")\n[1] TRUE\n\
    </code>\nExplanation\nThe function uses two grepl patterns to search the string.\
    \ The first one is used to make sure that the string has at least 3 characters.\
    \ In the second grepl pattern, the string is surrounded by groups of 3 characters,\
    \ as described by the first grepl. So, the string aa is surrounded by aa a aa\
    \ aa. The patterns are combined using paste0 which concatenates the pattern with\
    \ \\\\1 \\\\2. Thus, the function looks for patterns aa aa aa ", "\n  nchar(s^1)\
    \ >= 3 && all(s^1 == substr(s,1,3)^1)\n}\n</code>\n<|/ a |>\n<| c |>\nWhy do you\
    \ assume a purely arithmetic approach is fastest? Your first solution also requires\
    \ `gtools::permutations()` whereas your second solution does not.\n<|/ c |>\n\
    <| c |>\nThe second solution does not require `gtools`, so I removed that part.\
    \  However, the second solution will be slower because it requires `substr` instead\
    \ of `gsub`\n<|/ c |>\n<| c |>\nAh, I see. Thanks for the clarification.\n<|/\
    \ c |>\n<| c |>\nI did some quick performance testing on the two methods and it\
    \ seems the second method is the clear winner - at least for these examples!\n\
    <|/ c |>\n<| a tags=regex,gsub,r dscore=2 |>\n<code>\nis_happy <- function(s)\
    \ {\n  nchar(s^1) >= 3 && all(s^1 == substr(s,1,3)^1)\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI do not think that this is an answer. This should be a comment not an\
    \ answer.\n<|/ c |>\n<| a tags=regex,gsub,r |>\nUse gsubfn package to do this\
    \ quickly:\n<code>\nis_happy <- function(s) {\n  gsubfn(\"\\\\D\", ~ grepl(.x,\
    \ s), s)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice solution but it needs more\
    \ explanation.\n<|/ c |>\n<| c |>\nIt is an answer. OP asked how to solve it with\
    \ \"regex\". gsubfn uses regex to match each character to an anonymous function.\
    \ The anonymous function is a simple regular expression that matches any non-digit\
    \ character and returns TRUE if the character matches and FALSE otherwise. grepl\
    \ is used to check if the character matches (TRUE) then it is replaced with itself\
    \ so it can be tested against itself. This is all done in one line using the \"\
    ~\" operator which does the replacement and returns the output from the anonymous\
    \ function.\n<|/ c |>\n<| c |>\nThanks. I believe this solution should be accepted.\n\
    <|/ c |>\n<| c |>\nThis is what I was looking for! Thanks everyone who helped\
    \ me out here.\n<|/ c |>\n<| a tags=regex,gsub,r dscore=1 |>\nHere's a data.table\
    \ solution:\n<code>\nrequire(data.table)\ndt <- ", "\n  if(length(s) >=3) {\n\
    \    return(TRUE)\n  }\n  return(FALSE)\n}\n", "\n  if(is.null(s) || s == \"\"\
    ) return(TRUE)\n  s <- gsub(\"\\\\s\", \"\", s)\n  if(length(s) >= 3) return(TRUE\
    \ %in% unique(gsub(\"[\\\\W]+\", \"\", s)))\n}\n</code>\n<|/ a |>\n<| a tags=r,gsub,string,regex,pattern-matching\
    \ |>\nHere is one way to solve this\n<code>\na <- c('abc','bbb','adb','xxx')\n\
    a %>% \n  sapply( function(x) ifelse(length(unique(x)) == length(x), TRUE, FALSE)\
    \ )\n\n abc   bbb   adb  xxx \nFALSE  FALSE  FALSE  TRUE \n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis solution is quite close to what I was looking for. Thank you!\n\
    <|/ c |>\n<| c |>\nno worries! :)  Glad I could help.\n<|/ c |>\n<| a |>\n<code>\n\
    a = \"abcde\"\ngsub(\"([a-z])\\\\1{2}\", \"\\\\1\", a)\n[1] \"abcde\"\ngsub(\"\
    ([a-z])\\\\1{3}\", \"\\\\1\", a)\n[1] \"abcde\"\n</code>\n<|/ a dscore=1 tags=r,gsub,string,regex,pattern-matching\
    \ |>\n<| c |>\nOP is looking for consecutive letters so the pattern is \"a{2,3}\"\
    \ and then \"a{3,4}\"\n<|/ c |>\n<| c |>\n, `gsub(\"([a-z])\\\\1{2,3}\", \"\\\\\
    1\", a)` does not work\n<|/ c |>\n<| c |>\nSorry, I was missing a comma.\n<|/\
    \ c |>\n<| a dscore=1 |>\nYou could use a regex to match three consecutive non-letters\
    \ and replace with a single non-letter:\n<code>\ngsub('[^a-zA-Z]+([a-zA-Z])\\\\\
    1{3}[^a-zA-Z]+', '\\\\1', a)\n</code>\nThis would match one or more non-letters\
    \ followed by three letters and replace them with a single non-letter.\n<|/ a\
    \ tags=r,gsub,string,regex,pattern-matching |>\n<| a dscore=1 tags=r,gsub,string,regex,pattern-matching\
    \ |>\n<code>\nlibrary(dplyr)\nlibrary(stringr)\n", "\n  length(s) >= 3 && all((rep(1,\
    \ length(s))) - duplicated(rep(s, 3)) %in% TRUE)\n}\n", "\n    s <- tolower(s)\n\
    \    n <- nchar(s)\n    \n    n >= 3 & all(diff(sort(s)) == 0)\n}\n", "\n  s <-\
    \ substr(s, start = 1, stop = nchar(s))\n  nchar(s) * 3 > sum(grepl(\"[^[:alpha:]]\"\
    , s)) & sum(sapply(strsplit(s, \"(?<=.)\", perl = TRUE), \n                  \
    \              function(x) all(c(length(x) == 3, as.integer(x[1]) == as.integer(x[2]))\
    \ \n                                & !duplicated(x), USE.NAMES = FALSE))) > 0\n\
    }\n\nis_happy(\"a\") # False\nis_happy(\"aa\") # False\nis_happy(\"abcd\") # True\n\
    is_happy(\"aabb\") # False\nis_happy(\"adb\") # True\nis_happy(\"xyy\") # False\n\
    </code>\n<|/ a dscore=3 tags=r,string,regex |>\n<| c |>\nOooh beautiful solution,\
    \ I'm going to remember the `grepl` function so I can do that `grepl(\"[^[:alpha:]]\"\
    , s)` trick for another problem I'm working on. Thank you so much for the help!\n\
    <|/ c |>\n<| c |>\nI was wondering if you could provide some help with my other\
    \ question? http://stackoverflow.com/questions/23008414/how-can-i-replace-a-character-in-r-using-gsub\n\
    <|/ c |>\n<| c |>\nGlad it helps. I'm still new to this forum and I'm learning\
    \ all the time, so I hope you won't mind if I keep asking about it, but in addition\
    \ to getting it answered, I'm also trying to learn the etiquette of asking new\
    \ questions :)\n<|/ c |>\n<| c |>\nNo, you won't mind at all :) I appreciate your\
    \ help a lot\n<|/ c |>\n<| a dscore=2 |>\nI'd use strsplit() and check each substring\
    \ for being all letters and having length 3, and also that the substrings are\
    \ distinct.\n<code>\n> s <- \"abcd\"\n> n <- strsplit(s, \"\")[[1]]\n> n[length(n)%%3\
    \ != 0] <- \"\"\n> n[length(n)%%3 == 0] <- NA\n> length(unique(n)) > 1\n[1] TRUE\n\
    > s <- \"xyy\"\n> n <- strsplit(s, \"\")[[1]]\n> n[length(n)%%3 != 0] <- \"\"\n\
    > n[length(n)%%3 == 0] <- NA\n> length(unique(n)) > 1\n[1] FALSE\n</code>\n<|/\
    \ a tags=r,string,regex |>\n<| c |>\nThank you for the ", "\n  \n  if(length(s)\
    \ >= 3) {\n    for(i in 1:(length(s) - 2)) {\n      if(s[i] != s[i+1] && s[i]\
    \ != s[i+2] && s[i] != s[i+3]) \n        break\n    }\n    if(i == length(s) -\
    \ 3) \n      return (TRUE)\n  }\n  return (FALSE)\n}\n</code>\n<|/ a tags=r,stringr\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\nlibrary(dplyr)", "\n  n <- length(s)\n\
    \  if(n >= 3) {\n    all(c(NA, unlist(lapply(s, is.na))) %in% c(NA, TRUE, TRUE))\n\
    \  } else {\n    TRUE\n  }\n}\n</code>\nOutput:\n<code>\n> is_happy(\"abba\")\n\
    [1] FALSE\n> is_happy(\"aaab\")\n[1] FALSE\n> is_happy(\"bbbb\")\n[1] TRUE\n>\
    \ is_happy(\"aba\")\n[1] TRUE\n> is_happy(\"abbac\")\n[1] FALSE\n> is_happy(\"\
    aaaaaa\")\n[1] FALSE\n> is_happy(\"aaaaaaaaaaa\")\n[1] TRUE\n> is_happy(\"aaaaaaaaaa\"\
    )\n[1] TRUE\n> is_happy(\"aa aaa\")\n[1] TRUE\n> is_happy(\"aaa aa\")\n[1] TRUE\n\
    > is_happy(\"aa a\")\n[1] FALSE\n> is_happy(\"aa aa\")\n[1] FALSE\n> is_happy(\"\
    aaa\")\n[1] TRUE\n> is_happy(\"aa aa\")\n[1] FALSE\n> is_happy(\"aa aa\")\n[1]\
    \ FALSE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"aa aa\")\n[1] FALSE\n> is_happy(\"\
    a aaa\")\n[1] FALSE\n> is_happy(\"a aa\")\n[1] FALSE\n> is_happy(\"a aaa\")\n\
    [1] TRUE\n> is_happy(\"a a\")\n[1] FALSE\n> is_happy(\"aaaaaa\")\n[1] TRUE\n>\
    \ is_happy(\"aaaaa\")\n[1] TRUE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"\
    aaaa\")\n[1] TRUE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"aaaaaa\")\n[1]\
    \ TRUE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"\
    aaaa\")\n[1] TRUE\n> is_happy(\"aaaaa\")\n[1] TRUE\n> is_happy(\"aaaa\")\n[1]\
    \ TRUE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"aaaaa\")\n[1] TRUE\n> is_happy(\"\
    aaaa\")\n[1] TRUE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"aaaaa\")\n[1]\
    \ TRUE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"aaaaa\")\n[1] TRUE\n> is_happy(\"\
    aaaa\")\n[1] TRUE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"aaaaa\")\n[1]\
    \ TRUE\n> is_happy(\"aaaa\")\n[1] TRUE\n> is_happy(\"", "\n  str <- gsub('(.)',\
    \ '\\\\1', s)\n  sum <- 0\n  sapply(strsplit(str, ''), function(x) {\n    sum\
    \ <- sum + tolower(x[1])\n    sum <- sum + tolower(x[2])\n    sum <- sum + tolower(x[3])\n\
    \    sum <- sum + tolower(x[4])\n    sum <- sum + tolower(x[5])\n    sum <- sum\
    \ + tolower(x[6])\n    sum <- sum + tolower(x[7])\n    sum <- sum + tolower(x[8])\n\
    \    sum <- sum + tolower(x[9])\n    sum <- sum + tolower(x[10])\n    sum <- sum\
    \ + tolower(x[11])\n    sum <- sum + tolower(x[12])\n    sum <- sum + tolower(x[13])\n\
    \    sum <- sum + tolower(x[14])\n    sum <- sum + tolower(x[15])\n    sum <-\
    \ sum + tolower(x[16])\n    sum <- sum + tolower(x[17])\n    sum <- sum + tolower(x[18])\n\
    \    sum <- sum + tolower(x[19])\n    sum <- sum + tolower(x[20])\n    sum <-\
    \ sum + tolower(x[21])\n    sum <- sum + tolower(x[22])\n    sum <- sum + tolower(x[23])\n\
    \    sum <- sum + tolower(x[24])\n    sum <- sum + tolower(x[25])\n    sum <-\
    \ sum + tolower(x[26])\n    sum <- sum + tolower(x[27])\n    sum <- sum + tolower(x[28])\n\
    \    sum <- sum + tolower(x[29])\n    sum <- sum + tolower(x[30])\n    sum <-\
    \ sum + tolower(x[31])\n    sum <- sum + tolower(x[32])\n    sum <- sum + tolower(x[33])\n\
    \    sum <- sum + tolower(x[34])\n    sum <- sum + tolower(x[35])\n    sum <-\
    \ sum + tolower(x[36])\n    sum <- sum + tolower(x[37])\n    sum <- sum + tolower(x[38])\n\
    \    sum <- sum + tolower(x[39])\n    sum <- sum + tolower(x[40])\n    sum <-\
    \ sum", "\n    length(s) >= 3 &&\n        all(sapply(s, FUN = function(c) length(unique(c)))\
    \ == 3)\n}\n", "\n  s <- tolower(s)\n  n <- length(s)\n  if (n == 3 & all(duplicated(s[seq_len(n\
    \ - 2)]) | duplicated(s[seq_len(n - 1)], fromLast = TRUE))) {\n    return(TRUE)\n\
    \  } else {\n    return(FALSE)\n  }\n}\n</code>\n<|/ a tags=string,r,duplicates,character,string\
    \ |>\n<| a tags=string,r,duplicates,character,string |>\nWe can use strsplit to\
    \ split the string into characters, get the unique elements, check with length\
    \ to see if it is greater than or equal to 3\n<code>\nisHappy2 <- function(x)\
    \ {\n     length(unique(strsplit(tolower(x), \"\")[[1]])) >= 3\n}\nisHappy2(\"\
    ABABA\")", "\n  return(length(s) >= 3 &&\n          all(sapply(1:(length(s) -3),\
    \ function(i) length(unique(substr(s,(i+1),(i+2))))) == 3))\n}\n</code>\n<|/ a\
    \ dscore=3 tags=r |>\n<| c |>\n`substr` is a great solution too.\n<|/ c |>\n<|\
    \ a |>\nIn R it can be done like this:\n<code>", "\n  # Your code here\n  if(length(s)\
    \ >= 3 & all(sapply(s, function(x) length(unique(x))) == 3)){\n    return(TRUE)\n\
    \  }\n  return(FALSE)\n}\n</cell>\n<cell>", "\n    length(s)>=3 && all(\n    \
    \    sapply( strsplit(s, \"\")[[1]], function(x)\n            length(unique(x))==3\n\
    \        )\n    )\n}\n", "\n  n <- nchar(s);\n  if (n < 3) {\n    stop(\"Not happy.\"\
    );\n  }\n  k <- 0;\n  for (i in 1:(n-2)) {\n    if (s[i] !=s[i+1]) {\n      k\
    \ <- k + 1;\n    }\n  }\n  if (k == 3) {\n    return(TRUE);\n  } else {\n    return(FALSE);\n\
    \  }\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nHow would this be done in Python?\
    \ Is there a package that supports this? I'm curious.\n<|/ c |>\n<| c |>\nThis\
    \ solution is also very fast, so I thought I'd add it here for future reference.\n\
    <|/ c |>\n<| a tags=r |>\nI came up with this solution:\n<code>\nlibrary(stringr)\n\
    isHappy <- function(s) {\n  if(length(s) >= 3 && nchar(str_replace_all(s, '.',\
    \ ''))>=3){\n    s <- str_replace_all(s, '.', '')\n    s <- str_split(s, '')[[1]]\n\
    \    all(length(unique(s)) == 3)\n  } else {\n    stop(\"Not happy.\")\n  }\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere's a solution using stringi::stri_count\
    \ from stringi package:\n<code>\nis_happy <- function(s) {\n  if(length(s) >=\
    \ 3 && stri_count(s, pattern = \".{3}\", simplify = TRUE)>=3){\n    s <- stri_count(s,\
    \ pattern = \".{3}\", simplify = TRUE)\n    all(s == 3)\n  } else {\n    stop(\"\
    Not happy.\")\n  }\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r dscore=2 |>\nWe can\
    \ use stringr::str_count_all\n<code>\nlibrary(stringr)\nstr1 <- \"aabcde.\"\n\
    all(str_count_all(str1, fixed(\".{3}\"))==3)", "\n  \n  if(is.null(s))\n    return(FALSE)\n\
    \  \n  length(s)>=3 && all(unlist(lapply(1:3, function(x) nchar(unique(s[(1+x):(2+x)]))))==3)\
    \ \n}\n", "\n    any(nchar(s) >= 3 & unique(sapply(strsplit(s, ''), function(x)\
    \ unique(x)) %% length(set(x))) == 0)\n}\n\nis_happy(c('a', 'aa', 'ab', 'abcd',\
    \ 'aabb', 'adb', 'xyy'))", "\n  if(length(s) <3) {\n    return(FALSE)\n  } else{\n\
    \    cat(\"This input has a haphazard length: \",length(s),\"\\n\")\n    cat(\"\
    \\n\")\n    for(i in 1:length(s)) {\n      if(s[i] != s[i+1]) {\n        return(FALSE)\n\
    \      }\n    }\n    return(TRUE)\n  }\n}\n</code>\n<|/ a tags=r,if-statement,string\
    \ |>\n<| c |>\nI really like this answer. Thanks for taking the time to explain\
    \ this in such a nice way.\n<|/ c |>\n<| c |>\nNice answer. However `for` loop\
    \ is slow. Try `system.time({for (i in 1:length(s) ) if (s[i] != s[i+1]) return(FALSE)})`\
    \ vs `system.time({if (length(s) <3) {\n    return(FALSE)\n  } else{\n    cat(\"\
    This input has a haphazard length: \",length(s),\"\\n\")\n    cat(\"\\n\")\n \
    \   for(i in 1:length(s)) {\n      if(s[i] != s[i+1]) {\n        return(FALSE)\n\
    \      }\n    }\n    return(TRUE)\n  }\n})`\n<|/ c |>\n<| c |>\nI agree with your\
    \ comment. However in my experience `for` loops are usually the most effective\
    \ tool for iterating over data objects in R. It all comes down to preference.\
    \ In this particular case I think `for` loops are the most effective tool because\
    \ 1) the length test is simple, and 2) we can test the whole vector at once instead\
    \ of looping over each individual element to check if it equals the next.\n<|/\
    \ c |>\n<| c |>\nI thought that too. However I ran some tests. In fact, `system.time({for\
    \ (i in 1:length(s) ) if (s[i] != s[i+1]) return(FALSE)})` should be faster than\
    \ `system.time({if (length(s) <3) {\n    return(FALSE)\n  } else{\n    cat(\"\
    This input has a haphazard length: \",length(s),\"\\n\")\n    cat(\"\\n\")\n \
    \   for(i in 1:length(s)) {\n      if(s[i] != s[i+1]) {\n        return(FALSE)\n\
    \      }\n    }\n    return(TRUE)\n  }\n})`\n<|/ c |>\n<| c |>\nWow! I just tried\
    \ again and now it seems like you are right. I'll update my post to reflect your\
    \ observations.\n<|/ c |>\n<| a dscore=2 tags=r,if-statement,string |>\nYou can\
    \ use grep ", "\n  if (length(s) >=3 && all(sapply(1:(nchar(s)), function(i) substr(s,\
    \ i, i) %in% c(\"a\", \"e\", \"i\", \"o\", \"u\"))))\n    TRUE\n  else\n    FALSE\n\
    }\n\nis_happy(\"abcde\")\nis_happy(\"abcdea\")\nis_happy(\"abcdeab\")\nis_happy(\"\
    abcdeabc\")\nis_happy(\"abcdeabbc\")\nis_happy(\"abcdeabcde\")\nis_happy(\"abbdeabcde\"\
    )\nis_happy(\"abbdeabcdea\")\nis_happy(\"abbdeabcdeab\")\nis_happy(\"abbdeabcdeabc\"\
    )\nis_happy(\"abbdeabcdeabbc\")\nis_happy(\"abbdeabcdeabcde\")\nis_happy(\"abbdeabbdeabcde\"\
    )\nis_happy(\"abbdeabbdeabcdea\")\nis_happy(\"abbdeabbdeabcdeab\")\nis_happy(\"\
    abbdeabbdeabcdeabc\")\nis_happy(\"abbdeabbdeabcdeabbc\")\nis_happy(\"abbdeabbdeabcdeabcde\"\
    )\nis_happy(\"abbdeabbdeabbdeabcde\")\nis_happy(\"abbdeabbdeabbdeabcdea\")\nis_happy(\"\
    abbdeabbdeabbdeabcdeab\")\nis_happy(\"abbdeabbdeabbdeabcdeabc\")\nis_happy(\"\
    abbdeabbdeabbdeabcdeabbc\")\nis_happy(\"abbdeabbdeabbdeabcdeabcde\")\nis_happy(\"\
    abbdeabbdeabbdeabbdeabcde\")\nis_happy(\"abbdeabbdeabbdeabbdeabcdea\")\nis_happy(\"\
    abbdeabbdeabbdeabbdeabcdeab\")\nis_happy(\"abbdeabbdeabbdeabbdeabcdeabc\")\nis_happy(\"\
    abbdeabbdeabbdeabbdeabcdeabbc\")\nis_happy(\"abbdeabbdeabbdeabbdeabcdeabcde\"\
    )\nis_happy(\"abbdeabbdeabbdeabbdeabbdeabcde\")\nis_happy(\"abbdeabbdeabbdeabbdeabbdeabcdea\"\
    )\nis_", "\n  if (length(a) == 0)\n    return(\"FALSE\")\n  else\n    x <- c(substr(s,1,3),substr(s,4,6))\n\
    \  if(nchar(x) >= 3 && all(x == sort(x,decreasing = TRUE)))\n    return(\"TRUE\"\
    )\n  else\n    return(\"FALSE\")\n}\n", "\n    s <- gsub(paste0(\"[\", LETTERS,\
    \ \"]\"), \"\\\\1\", s)\n    length(gregexpr(\"^[[:alpha:]]{3}\", s)[[1]]) >=\
    \ 3\n}\n</code>\n<|/ a tags=r,dataframe dscore=1 |>\n<| a dscore=0 |>\nA variation\
    \ on akrun's answer, using sapply:\n<code>\nis_happy <- function(s) {\n  sapply(seq_len(nchar(s)-3),\
    \ 1, function(x) all(x == unique(substr(s, x, x+3))))\n}\n</code>\n<|/ a tags=r,dataframe\
    \ |>\n<| c |>\nThis could be generalized to handle a string of any length.\n<|/\
    \ c |>\n<| a tags=r,dataframe |>\nI like Greg Snow's idea, but I'd use gsubfn\
    \ to do the work for me. I think it's better than looping through every letter,\
    \ although it does mean that there's a loop that doesn't exist in R. I also like\
    \ that it's not using regular expressions, which are slower than loops. \n<code>\n\
    library(gsubfn)\nis_happy <- function(s) {\n  sapply(1:nchar(s)-4, function(x)\
    \ all(x != gsubfn(\".\", paste, \n                                           \
    \       substr(s, x, x+4), fixed = TRUE)))\n}\n\nis_happy(\"\")", "\n  str <-\
    \ nchar(s) >= 3 && all(strsplit(s, nchar(s) %/% 3) == 0)\n}\n\n</cell>\n<code\
    \ language=conda-env-Anaconda3-py>\nis_happy('abcde')\n</cell>\n<code language=conda-env-Anaconda3-py>\n\
    is_happy('aa')\n</cell>\n<code language=conda-env-Anaconda3-py>\nis_happy('abc')\n\
    </cell>\n<code language=conda-env-Anaconda3-py>\nis_happy('abcde')\n</cell>\n\
    <code language=conda-env-Anaconda3-py>\nis_happy('aaaa')\n</cell>\n<code language=conda-env-Anaconda3-py>\n\
    is_happy('a')\n</cell>\n<code language=conda-env-Anaconda3-py>\nis_happy('x')\n\
    </cell>\n<text>\n2. Naive Bayes\nIn this section, we will use Naive Bayes classifier\n\
    Naive Bayes classifier is an algorithm that makes good predictions on continuous\
    \ numerical features.\n\nThe algorithm is divided into two parts; Naive Bayes\
    \ Classifier and Maximum Likelihood Estimation (MLE).\n\n\n</text>\n<text>\n2.1\
    \ Naive Bayes Classifier\nNaive Bayes classifier is an algorithm that makes good\
    \ predictions on continuous numerical features.\n\nThe algorithm is divided into\
    \ two parts; Naive Bayes Classifier and Maximum Likelihood Estimation (MLE).\n\
    \nThe model that we are going to use is Naive Bayes Classifier.\n\nThe Naive Bayes\
    \ classifier algorithm finds the conditional probability of a particular class\
    \ conditioned on the features in the data that are assumed to be independent of\
    \ each other.\n\nFor example , we can assume that in a dataset of emails, we have\
    \ the features that each email consists of.\nLet us assume that we are given the\
    \ following information:\n\nEmail subject : Email Content : Email Sender\n\n\n\
    We can assume that EmailSubject and EmailContent are independent of each other,\
    \ and EmailSender can be independent of EmailSubject or EmailContent.\n\nThis\
    \ can be represented as follows below:\n\nNone \n\n\n\n</text>\n<text>\nThe Naive\
    \ Bayes classifier assumes that each feature has a distribution of values based\
    \ on the features that it contains, and each observation belongs to a particular\
    \ class.\n\nThe Naive Bayes Classifier can be represented as follows:\n\n$$\n\
    P(Class | Features) = \\frac{P(Features)}{P(Class | Features)}\n$$\n\nNone \n\n\
    \n\n</text>\n<text>\nThe Nai", "\n  if(s == \"\")\n    return(FALSE)\n  length(s)\
    \ >= 3 && all((c(head(s,3)) == tail(s,3)) & !duplicated(c(head(s,3))))\n}\n",
  "\n  n <- length(s)\n  if(n < 3L) {\n    return(FALSE)\n  }\n  res <- FALSE\n  for(i\
    \ in seq_len(n-3L)) {\n    c <- substr(s, i, i+3L)\n    if(!any(unique(c))) {\n\
    \      res <- TRUE\n      break\n    }\n  }\n  return(res)\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a |>\nHere is an alternative solution:\n<code>\n is_happy <-\
    \ function(s) {\n     n <- length(s)\n     if (n <= 3L)\n         return(FALSE)\n\
    \     i <- 3L\n     while (i < n) {\n         if (length(unique(substr(s, i, i\
    \ + 3L))) > 1L)\n             i <- i + 3L\n         else\n             break\n\
    \     }\n     return(TRUE)\n }\n</code>\n<|/ a dscore=0 tags=r |>\n<| a tags=r\
    \ dscore=0 |>\n<code>\nis_happy <- function(s) {\n  n <- length(s);\n  if(n <\
    \ 3L){\n    return(FALSE);\n  }\n  else{\n    while(length(unique(substr(s,3,n-3L)))\
    \ > 1L){\n      n <- n + 3L;\n      if(n < 3L){\n        return(FALSE);\n    \
    \  }\n    }\n    return(TRUE);\n  }\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    How about this one?\n<code>\nis_happy <- function(s) {\n  n <- length(s);\n  if(n\
    \ <= 3L) {\n    return(FALSE);\n  }\n  i <- 3L;\n  while(i < (n - 3L)) {\n   \
    \ if(length(unique(substr(s, i, i + 3L))) > 1L) {\n      i <- i + 3L;\n    } else\
    \ {\n      i <- i + 3L + 1;\n    }\n  }\n  return(TRUE);\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| a |>\nHere is another solution that uses R's vectorized operations and\
    \ string manipulation functions, rather than stringing together a bunch of loops.\
    \  I did this for the fun of it, because I thought it would be fun to explore\
    \ ways to break down a problem like this into simpler steps.\n<code>\nis_happy\
    \ <- function(s) {\n  n <- length(s);\n  l <- substr(s, 3L, n - 3L);\n  n <- length(l);\n\
    \  s <- s[length(s);\n  i <- 1L;\n  while(i <= n) {\n    l <- substr(s, 3L + i, ",
  "\n    length(s) == length(unique(s))\n}\n", "\n  sum(strsplit(s,\"\")[[1]] %in%\
    \ c('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'))\
    \ >= 3 & all(sapply(strsplit(s,\"\")[[1]],function(x){x %in% c('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')}))\
    \ \n}\n", "\n  nchar(s) / 3 %in% seq_len(nchar(s) / 3) && \n    sapply(seq(1,\
    \ nchar(s) / 3), function(x) length(unique(sapply(seq(x, nchar(s) / 3), \"[\"\
    , s))) == 1) && \n    sapply(seq(1, nchar(s) / 3), function(x) length(unique(sapply(seq(x,\
    \ nchar(s) / 3), \"[\", s))) == 3)\n}\n", "\n  length(s) + 3 <= (length(unique(unlist(strsplit(s,\
    \ \"\")))))\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=regex,string,r,grepl,lapply\
    \ |>\nYou could do :\n<code>\na <- c(\"aba\",\"a\",\"bbb\",\"bab\")\nb <- c(\"\
    bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\")\nc <- c(\"\
    bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\"\
    )\nd <- c(\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\"\
    ,\"bbb\")\ne <- c(\"aba\",\"a\",\"bbb\",\"bab\")\nf <- c(\"bbb\",\"bbb\",\"bbb\"\
    ,\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\")\ng <- c(\"bbb\",\"bbb\",\"bbb\"\
    ,\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\",\"bbb\")\n", "\n  if(length(s) < 3) return(FALSE)\n\
    \  x <- sapply(s, function(x) length(unique(x)))\n  return(sum(x) >= 3 && all(x[1:3]\
    \ == x[3:5]))\n}\n</code>\n<|/ a |>\n<| c |>\nThe string `a` should return TRUE\
    \ here: `is_happy(\"a\")`\n<|/ c |>\n<| c |>\nIt should return false when `s`\
    \ is empty.\n<|/ c |>\n<| c |>\nI realized the same thing.\n<|/ c |>\n<| c |>\n\
    Your code is way more concise than mine, thanks. But I still wonder why my code\
    \ is so slow.\n<|/ c |>\n<| c |>\nI'm guessing it's because you call `sapply(1:n,\
    \ ...)` which returns a matrix instead of an `vector` which is more efficient\
    \ for vectorization. But I'm not sure. You'll probably have to time it.\n<|/ c\
    \ |>\n<| a |>\n<code>\ns <- 'abaacccddfgghijkhijkkjhkhikjhjhjijhijkjhjkjhjkjhkjhkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjkjhjk",
  "\n  length(s) >= 3 &&\n  all(sapply(3:nchar(s), function(x) !any(x %in% unlist(strsplit(s,\
    \ \"\")))))\n}\n</code>\n<|/ a tags=r,logical-operators,conditional,string,dataframe\
    \ |>\n<| c |>\nThis fails for a string like `'adb'` - it returns `FALSE`, which\
    \ is not correct, because it is not `happy`.\n<|/ c |>\n<| c |>\nYes, and I noticed\
    \ that too. But I just couldn't figure out how to avoid the problem. So I went\
    \ with what I thought would work.\n<|/ c |>\n<| a tags=r,logical-operators,conditional,string,dataframe\
    \ |>\nI believe the following is more efficient:\n<code>", "\n  sapply(strsplit(s,\
    \ \"\"), function(x){\n    length(unique(x)) == 3 & all(c(unique(x), unique(x[-length(x)]))\
    \ %in% c(\"a\", \"b\", \"c\")) \n  })\n}\n", "\n  sapply(strsplit(s, \"\"), function(x)\
    \ length(unique(x)) >= 3 & all(!duplicated(x)))\n}\n</code>\n<|/ a dscore=4 tags=r,string\
    \ |>\n<| c |>\nI guess you meant to return TRUE instead of FALSE in the else part\
    \ of ifelse\n<|/ c |>\n<| c |>\nYes, fixed. Thank you!\n<|/ c |>\n<| c |>\nThis\
    \ answer is not correct for R-specific, as it requires the string to be a character\
    \ vector. Also, `grepl` should be used instead of `gsub` since we are not looking\
    \ for exact matches, but rather to find substrings.\n<|/ c |>\n<| c |>\nOh, I\
    \ see. Didn't realize `grepl` used that way. Thank you!\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work for `abbb` - it returns FALSE. `grepl` does not require the string\
    \ to be a character-vector (it's not a regex function), so the `+` operator doesn't\
    \ work for strings.\n<|/ c |>\n<| a |>\nAn alternative to using stringi would\
    \ be to use regmatches and grepl, with a negative lookahead:\n<code>\nis_happy\
    \ <- function(s){\n  regmatches(s, gregexpr(\"^(?=.*?(?!(.*?a{1}.*?){2,})).{3,}$\"\
    , s))\n}\n</code>\n<|/ a tags=r,string dscore=3 |>\n<| a |>\nTry this:\n<code>\n\
    > a<-c(\"a\",\"b\",\"c\")\n> b<-c(\"a\",\"b\",\"d\")\n> c<-c(\"a\",\"b\")\n> a\n\
    [1] \"a\" \"b\" \"c\"\n> b\n[1] \"a\" \"b\" \"d\"\n> c\n[1] \"a\" \"b\"\n> library(stringi)\n\
    > any(stri_count_fixed(a,pattern=\"a\")>=3)\n[1] TRUE\n> any(stri_count_fixed(b,pattern=\"\
    a\")>=3)\n[1] TRUE\n> any(stri_count_fixed(c,pattern=\"a\")>=3)\n[1] FALSE\n>\
    \ \n</code>\n<|/ a tags=r,string dscore=2 |>\n<| a tags=r,string |>\nHow about\
    \ this?\n<code>\nis_happy <- function(s) {\n  grepl(\"^(?=(.*?a{1}.*?){2,}).{3,}$\"\
    ,s)\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,string |>\nA simple solution to\
    \ check if string is hapr is to use \n<code>", "\n  length <- nchar(s);\n  return(length\
    \ >= 3 & all(3 %in% c(substr(s, 1, 3), substr(s, 4, 3), substr(s, 7, 3))))\n}\n\
    </cell>\n<cell>", "\n  nl <- strsplit(s, \"\")[[1]]\n  n <- length(nl)\n  n3 <-\
    \ n * 3\n  n_distincts <- n_distinct(unlist(nl))\n  n_distincts == n && length(nl)\
    \ >= n3\n}\n</code>\nNote that for n=10, the test will return FALSE, as it would\
    \ not be possible to get all 3 consecutive letters in all three positions (which\
    \ would result in n=12).\n<|/ a dscore=1 |>\n<| a |>\nI wrote this function using\
    \ recursion and it works just fine:\n<code>\nis_happy <- function(string){\n \
    \ if(!length(string)){\n    return(FALSE)\n  }\n  if(length(string)==1){\n   \
    \ return(FALSE)\n  }\n  if(string[1]==string[2]){\n    return(is_happy(substring(string,1,3)))\n\
    \  }\n  if(string[2]==string[3]){\n    return(is_happy(substring(string,2,3)))\n\
    \  }\n  if(string[3]==string[2]){\n    return(is_happy(substring(string,3,3)))\n\
    \  }\n  return(TRUE)\n}\n\nis_happy(\"babba\")\nis_happy(\"abba\")\nis_happy(\"\
    abc\")\nis_happy(\"abcc\")\nis_happy(\"aacc\")\nis_happy(\"aaabc\")\nis_happy(\"\
    aaacb\")\nis_happy(\"aaaac\")\nis_happy(\"aaaaa\")\nis_happy(\"aaaaab\")\nis_happy(\"\
    aaaaabb\")\nis_happy(\"aaaaabbb\")\nis_happy(\"aaaaabbbbb\")\nis_happy(\"aaaaabbbbbb\"\
    )\nis_happy(\"aaaaabbbbbbb\")\nis_happy(\"aaaaabbbbbbbb\")\n</code>\n<|/ a tags=r,string,unique\
    \ dscore=1 |>\n<| a |>\nI came up with a solution using dplyr and purrr.\n<code>\n\
    library(dplyr)\nlibrary(purrr)\n\nis_happy <- function(string) {\n  length(unique(c(string,string[1])))==1\
    \ & \n    nchar(paste(string(1),string(1),string(1),sep=\"\"))>=3\n}\n\nis_happy(\"\
    babba\")\n[1] FALSE\nis_happy(\"abba\")\n[1] FALSE\nis_happy(\"abc\")\n[1] TRUE\n\
    is_happy(\"abcc\")\n[1] TRUE\nis_happy(\"aacc\")\n[1] TRUE\nis_happy(\"aaabc\"\
    )\n[1] TRUE\nis_happy(\"aaacb\")\n[1] TRUE\nis_happy(\"aaaac\")\n[1] TRUE\nis_happy(\"\
    aaaaa\")\n[1] TRUE\nis_", "\n  s <- strsplit(s,\"\")[[1]]\n  lengths(s)>=3 &&\
    \ all(sapply(s,FUN=function(x)!any(duplicated(x))))\n}\n\nis_happy(\"\")", "\n\
    \  len <- length(s)\n  if (len < 3) return(FALSE)\n  out <- FALSE\n  for (i in\
    \ seq_along(s) {\n    if (s[(i+1):(len-1)] == s[(i+1):(len-1)] & s[(i+1):(len-1)]\
    \ != s[(i+1):(len-1)] & s[(i+1):(len-1)] != s[(i+1):(len-1)])\n      out <- TRUE\n\
    \    else return(FALSE)\n  }\n  return(out)\n}\n</cell>\n<cell>", "\n  # Your\
    \ code here\n  res <- c(TRUE, length(s) >=3 & sapply(s, function(a){\n    all(unique(a)==a)\n\
    \  }))\n  return(res)\n}\n\nprint(is_happy(\"ab\"))\nis_happy(\"a\")\nprint(is_happy(\"\
    abb\"))\nis_happy(\"ba\")\nprint(is_happy(\"ac\"))\nis_happy(\"abc\")\nprint(is_happy(\"\
    xyy\"))\nis_happy(\"x\")\n</code>\nOutputs:\n<code>\n> print(is_happy(\"ab\"))\n\
    [1] TRUE\n> is_happy(\"a\")\n[1] FALSE\n> print(is_happy(\"abb\"))\n[1] FALSE\n\
    > is_happy(\"ba\")\n[1] TRUE\n> print(is_happy(\"ac\"))\n[1] FALSE\n> is_happy(\"\
    abc\")\n[1] TRUE\n> print(is_happy(\"xyy\"))\n[1] FALSE\n> is_happy(\"x\")\n[1]\
    \ TRUE\n</code>\n<|/ a dscore=0 tags=r |>\n<| c |>\nHi John, I'm so sorry for\
    \ the mistakes I've made, I already tried using the same concept as you provided\
    \ but it didn't work for some reasons. But anyway thank you very much for your\
    \ kind help.\n<|/ c |>\n<| c |>\nNo worries, I guess your question doesn't make\
    \ much sense now. Perhaps you can edit it to make clear what you wanted? It seems\
    \ you just wanted the function to return true for all strings of at least 3 letters,\
    \ regardless of how many different letters were in each of the three strings.\
    \ I thought that's what you wanted.\n<|/ c |>\n<| c |>\nHi John, thank you very\
    \ much for your kindness. I wanted my function to return true for all strings\
    \ of at least 3 letters, regardless of how many different letters were in each\
    \ of the three strings. Thanks again!\n<|/ c |>\n<| a dscore=0 |>\nUsing stringr\
    \ and purrr:\n<code>\nlibrary(stringr)\nlibrary(purrr)\n\nis_happy <- function(string)\
    \ {\n\n  str_count(string = string, pattern = \".\") %/% 3 == 0 &\n  str_count(string\
    \ = string, pattern = \".\") %/% 3 ==  1 &\n  str_count(string = string, pattern\
    \ = \".\") %/% 3 ==  2\n}\n\nis_happy(\"ab\")\nis_happy(\"a\")\nis_happy(\"abb\"\
    )\nis_happy(\"ba\")\nis_happy(\"ac\")\nis_happy(\"abc\")\nis_happy(\"xyy\")\n\
    is_happy(\"x", "\n  s <- gsub(\"[[:punct:]]\", \"\", s, fixed = TRUE)\n  if (length(s)\
    \ <= 3) {\n    TRUE\n  } else {\n    if (length(unique(s[seq(1, (length(s) - 3),\
    \ 3)])) == 3) {\n      TRUE\n    } else {\n      FALSE\n    }\n  }\n}\n", "\n\
    \  n <- length(s)\n  if (n<3 || n==1 || n==2) return FALSE\n  all(c(letters, LETTERS)\
    \ %in% s)\n}\n</code>\n<|/ a tags=string,r,if-statement dscore=2 |>\n<| c |>\n\
    I thought this was the answer but when I ran the code  for the string \"abcd\"\
    \ it gave me TRUE.\n<|/ c |>\n<| c |>\n, you are absolutely right. I should go\
    \ back to check my code more carefully. Thanks for pointing out.\n<|/ c |>\n<|\
    \ a tags=string,r,if-statement |>\nHere is a simple way using stringi::stri_length\
    \ where we check whether the string is of length 3 or not and based on that we\
    \ can use logical (if) statement to return TRUE or FALSE\n<code>\na <- \"abcd\"\
    \nsapply(a, function(x) ifelse(stri_length(x)>=3,TRUE,FALSE))", "\n  require(stringr)\n\
    \  sapply(str_split(s, '')[[1]], function(x) length(unique(x)) >= 3)\n}\n</cell>\n\
    <cell>\n%%R\nis_happy(a)\n</cell>\n<cell>\nis_happy(aa)\n</cell>\n<cell>\nis_happy(abcd)\n\
    </cell>\n<cell>\nis_happy(aabb)\n</cell>\n<cell>\nis_happy(adb)\n</cell>\n<cell>\n\
    is_happy(xyy)\n</cell>\n<text>\nLet's also write a function that takes a string\
    \ as an input and returns a boolean indicating whether the string is hapr or not\n\
    \n\n</text>\n<cell>", "\n  # Your code here\n}\n", "\n  require(stringr)\n  s\
    \ <- gsub(\"([^\\\\w]|^)\", \"\", s)\n  sapply(s, function(x) {\n    n <- str_count(s,\
    \ \"\\\\1\\\\1\")\n    n >= 3 & n == length(s) & all(sapply(1:(n-1), function(x)\
    \ {\n      length(unique(substring(s, x, x+3)) %in% c(\"a\", \"b\", \"c\")) ==\
    \ 0\n    }))\n  })\n}\n", "\n  nchar(gsub(\"[^A-Za-z]\", \"\", s)) >= 3 && \n\
    \    all(\n      length(sort(unique(gsub(\"[^A-Za-z]\", \"\", s))))\n        ==\
    \ sort(unique(gsub(\"[^A-Za-z]\", \"\", s))))\n}\nis_happy(a)", "\n  stopifnot(is.character(s))\n\
    \  n <- length(s)\n  out <- FALSE\n  for(i in 1:(n-3)) {\n    if(!is.equal(substr(s,\
    \ i, i+3), substr(s, i+1, i+3))) out <- TRUE\n  }\n  return(out)\n}\n</cell>\n\
    <cell>", "\n    length(s) >= 3 && all(rep(3, 3) == (s[1:2]==s[3:4])) && length(unique(substr(s,\
    \ 1, 3))) == 3\n}\n\nis_happy(\"abbbc\")\nis_happy(\"abcd\")\nis_happy(\"a1b2c\"\
    )\nis_happy(\"a1b2c1\")\nis_happy(\"a1b2c1de\")\nis_happy(\"a1b2cdef\")\nis_happy(\"\
    ab\")\nis_happy(\"a1bc\")\nis_happy(\"a1bcdef\")\nis_happy(\"a1bcd\")\nis_happy(\"\
    a1bcdef\")\nis_happy(\"a1bcd\")\nis_happy(\"ab\")\nis_happy(\"a1bcdefg\")\nis_happy(\"\
    ab\")\nis_happy(\"abbbcdef\")\nis_happy(\"abbbcdefg\")\nis_happy(\"abbbcdefgh\"\
    )\nis_happy(\"abbbcdefghi\")\nis_happy(\"abbbcdefghij\")\nis_happy(\"abbbcdefghijk\"\
    )\nis_happy(\"abbbcdefghijkl\")\nis_happy(\"abbbcdefghijklm\")\nis_happy(\"abbbcdefghijklmno\"\
    )\nis_happy(\"abbbcdefghijklmn\")\nis_happy(\"abbbcdefghijklmno\")\nis_happy(\"\
    abbbcdefghijklmn\")\nis_happy(\"abbbcdefghijklmnop\")\nis_happy(\"abbbcdefghijklmnopq\"\
    )\nis_happy(\"abbbcdefghijklmnopqrst\")\nis_happy(\"abbbcdefghijklmnopqrstu\"\
    )\nis_happy(\"abbbcdefghijklmnopqrstuv\")\nis_happy(\"abbbcdefghijklmnopqrstuvw\"\
    )\nis_happy(\"abbbcdefghijklmnopqrstuvwx\")\nis_happy(\"abbbcdefghijklmnopqrstuvwxy\"\
    )\nis_happy(\"abbbcdefghijklmnopqrstuvwxyz\")\nis_happy(\"abbbcdefghijklmnopqrstuvwxyza\"\
    )\nis_happy(\"abbbcdefghijklmnopqrstuvwxyzab\")\nis_happy(\"abbbcdefghijklmnopqrstuvwxyzabc\"\
    )\nis_happy(\"abbbc", "\n  s <- tolower(s)\n  n <- length(s)\n  if(n <= 3)\n \
    \   return(FALSE)\n  for(i in 1:(n-3)) {\n    if(s[i] != s[i+1] ||\n       s[i]\
    \ != s[i+2] ||\n       s[i] != s[i+3] ||\n       s[i] != s[i+4])\n      return(FALSE)\n\
    \  }\n  return(TRUE)\n}\n", "\n  nchar(s) - nchar(trimws(s)) >= 3 && length(unique(unlist(strsplit(s,\
    \ \"\")))) >= 3\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks. I believe `str_length(s)\
    \ == length(unique(stringr::str_split(s, \"\")[[1]]))` will be faster and more\
    \ efficient as I suspect that your solution would split the string twice and `unlist`\
    \ would convert it back to a list. Also, I believe `stringr::str_split(s, \"\"\
    )[[1]]` is more readable.\n<|/ c |>\n<| c |>\nI appreciate your comments, thank\
    \ you. I have edited my answer to include your comments, as I think it would be\
    \ helpful for future readers who want to see an answer with your approach. Again,\
    \ thank you.\n<|/ c |>\n<| c |>\nGreat improvements +1!\n<|/ c |>\n<| a tags=r\
    \ dscore=3 |>\nWe can use data.table::rleid\n<code>\nlibrary(data.table)\nn <-\
    \ nchar(\"adb\") #5\nv <- c(\"a\",\"b\",\"c\")\nwhich(rleid(v)>=n)", "\n  # write\
    \ your code here\n  if(length(s) < 3 || (s %>% nchar()) %% 3 != 0 ) {\n    cat(\"\
    Invalid input\\n\", sep = \"\")\n    return(FALSE)\n  } \n  res <- s %>% str_split(pattern\
    \ = \"(?<=.)\") %>% unlist() %>% setdiff(.) %>% length()\n  return(all(unique(res)\
    \ %in% c(\"a\", \"b\", \"c\")))\n}\nis_happy(abcd)\nis_happy(abcde)\nis_happy(abcdeef)\n\
    is_happy(abcdabeef)\nis_happy(axyzb)\nis_happy(axyzbxyz)\nis_happy(axyzbxyz)\n\
    is_happy(\"axyzb\")\nis_happy(\"axyzbxyz\")\nis_happy(\"\")\nis_happy(\"abc\"\
    )\nis_happy(NULL)\nis_happy(NA)\nis_happy(FALSE)\nis_happy(TRUE)\nis_happy(\"\
    a\")\nis_happy(\"abcde\")\nis_happy(\"abcd\")\nis_happy(\"abcd\")\nis_happy(\"\
    abcde\")\nis_happy(\"abcd\")\nis_happy(\"adb\")\nis_happy(\"xyy\")\n\n</code>\n\
    <|/ a tags=r,string |>\n<| a dscore=2 |>\nUsing strsplit to split by empty space\
    \ and then checking if there are at least 3 unique letters. And using sapply to\
    \ apply this function to each element of the vector. This may also be useful if\
    \ you want to generalize this to other functions. \n<code>\nx <- c(\"a\", \"b\"\
    , \"c\")\nstrsplit(x, split = \" \")[[1]]\n[1] \"\" \"a\" \"b\" \"c\" \"\"\n\n\
    sapply(x, function(x) length(unique(unlist(strsplit(x, split = \" \")))))\n[1]\
    \  3 NA  3 NA  3  0\n</code>\nOr another method using mapply\n<code>\nsapply(x,\
    \ function(x) {\n  length(unique(unlist(strsplit(x, split = \" \"))))\n})\n[1]\
    \  3 NA  3 NA  3  0\n</code>\n<|/ a tags=r,string |>\n<| c |>\nYes, this works\
    \ but I forgot to mention that `strsplit` can take `pattern` argument which makes\
    \ it possible to split by different characters\n<|/ c |>\n<| c |>\nAh yes, I saw\
    \ that `pattern` argument in documentation. Thanks for pointing that out.\n<|/\
    \ c |>\n<| a dscore=1 |>\nAnother solution using lapply:\n<code>\nx <- c(\"a\"\
    , \"b\", \"", "\n  length(s) -> N\n  length(s) >= 3 && all(sapply(s[c(TRUE, FALSE)],\
    \ function(x) {\n    length(unique(x))==1 & sum(sapply(s[c(TRUE, FALSE)], function(y)\
    \ {\n      length(unique(y))==1\n    }))==N\n  }))\n}\n\nis_happy(\"a\")\nis_happy(\"\
    ab\")\nis_happy(\"abcd\")\nis_happy(\"aabb\")\nis_happy(\"adb\")\nis_happy(\"\
    xyy\")\nis_happy(\"aaabbbcccc\")\nis_happy(\"aabbbcccc\")\nis_happy(\"baba\")\n\
    is_happy(\"abbbbcccd\")\nis_happy(\"abbbbcccd\")\nis_happy(\"ababab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"abbabbabab\")\nis_happy(\"\
    abbabbabab\")\n", "\n    n <- length(s)\n    if(n<3) return(FALSE)\n    if(grepl('^(.)\\\
    \\1{2,}$', s, perl = TRUE)) return(TRUE)\n    if(grepl('^(.)(.)\\\\1{2,}$', s,\
    \ perl = TRUE)) return(TRUE)\n    if(grepl('^(.)\\\\1{2,}(.)$', s, perl = TRUE))\
    \ return(TRUE)\n}\n", "\n    length(s>= 3) == (uniqueN(s) == 3)\n}\n</code>\n\
    <|/ a tags=r,regex,string,strsplit dscore=0 |>\n<| a tags=r,regex,string,strsplit\
    \ |>\nA base R way using regex. \n<code>\nstringr::str_length(x) %>% \n  as_tibble()\
    \ %>% \n  mutate(is_happy_char = str_extract(string = x, pattern = '^[[:alpha:]]+$')\
    \ %in% 'TRUE')\n</code>\n<|/ a dscore=0 |>\n<| a |>\nYou can try this regex,\n\
    <code>\ngrepl(\"^[a-z]{3,}$\", \"happy\")", "\n  length(ave(seq_along(s), s, FUN\
    \ = seq_along) == 3) & \n    ave(seq_along(s), s, FUN = seq_along) == 3 & \n \
    \   !duplicated(s)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthis only works if\
    \ the input is of the form \"abcabc\".\n<|/ c |>\n<| c |>\nI added a new solution\
    \ that takes care of any string with more than three letters.\n<|/ c |>\n<| a\
    \ dscore=1 tags=r,string,subset,apply |>\n<code>\nx <- c(\"abbab\", \"aaaaaacb\"\
    , \"abbbaacb\")\nsum(sapply(x, function(y) {\n  return(length(setdiff(y[seq(1,\
    \ length(y), 3)], y[1:(length(y)-3)]))==0)\n})==0)\n[1] 2\n</code>\n<|/ a |>\n\
    <| a dscore=1 tags=r,string,subset,apply |>\nI think it could be easily solved\
    \ with base R using sapply, setdiff and Reduce:\n<code>\nx <- c(\"abbab\", \"\
    aaaaaacb\", \"abbbaacb\")\n\ny <- sapply(x, function(z) length(setdiff(z[seq(1,\
    \ length(z), 3)], z[1:(length(z) - 3)]))==0)\n\n> y\n[1]  TRUE FALSE FALSE\n</code>\n\
    EDIT\nSince you mentioned that your string is also of length 3, you can try:\n\
    <code>\nx <- c(\"abbab\", \"aaaaaacb\", \"abbbaacb\", \"abcd\")\ny <- sapply(x,\
    \ function(z) length(setdiff(z[seq(1, length(z), 3)], z[1:(length(z) - 3)]))==0\
    \ & \n             length(z) == 3)\n> y\n[1]  TRUE FALSE FALSE FALSE\n</code>\n\
    <|/ a |>\n<| c |>\nHi Oliver, thanks for your answer! However, if the string is\
    \ not of length 3, then it returns FALSE instead of TRUE. Is there a way to solve\
    \ this?\n<|/ c |>\n<| a dscore=0 |>\nTo generalize your solution, we can create\
    \ a function that takes any number of sequences of length K as its arguments,\
    \ and then iterate over each of those sequences, counting how many unique elements\
    \ are in those sequences. We can then return a vector of length equal to the number\
    \ of sequences we passed in. This can be done with a for loop or using one of\
    \ the apply family functions.\n<code>\ncount_unique_elements_in_sequences <- function(sequence)\
    \ {\n  length(unique(sequence))\n}\n\nsequences <- c(\"abbab", "\n  s <- strsplit(s,\
    \ \"\")[[1]]\n  length(s)>=3 && all(sapply(s, nchar) == 3) \n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a |>\nWe can use str_count from stringr\n<code>\nlibrary(stringr)\n\
    sapply(a, function(x) !any(nchar(x)<3 & str_count(x, \"[a-z]\") >= 3))", "\n \
    \ length(s) - 1 <= 3 & \n    all(length(unique(gsub(\"([a-z])([a-z])\", \"\\\\\
    1 \\\\2\", s)) == 3)) \n}\n</cell>\n<text>\nWe have used the function unique to\
    \ find the unique letters in the string.\nThe gsub function replaces every two\
    \ consecutive letters with a space.\nThe length function gives the length of the\
    \ string s.\nThe all function checks that all the conditions are satisfied.\n\n\
    \n</text>\n<text>\nQuestion 3\nWrite a function to determine if a string contains\
    \ any non-ASCII characters.\n\nIn a string, every character is represented by\
    \ an integer in the range 0 to 65535. Non-ASCII characters do not occupy consecutive\
    \ integers in the range 0 to 65535, but may be anywhere in the string. Hence the\
    \ function should determine if the string contains any non-ASCII characters.\n\
    \nThe function is_ascii should take a string as input and should return a boolean\
    \ indicating whether the string contains any non-ASCII characters.\n\nNote: Every\
    \ string may contain non-ASCII characters, even the empty string.\n\n\n</text>\n\
    <cell>", "\n  length(s)>=3 && all(sapply(strsplit(s,\"\"), function(x) !any(duplicated(x))))\n\
    }\n</cell>\n<text>\nLet's try it for our example :\n\n\n</text>\n<cell>\nis_happy(a)\n\
    </cell>\n<text>\nRemarks : The sapply function applies a function to every element\
    \ of the list passed to it\nThe strsplit function splits a string into a character\
    \ vector and returns a list of the character vectors split at each element of\
    \ the character vectors passed to it\nThe duplicated function returns TRUE for\
    \ each element that has appeared in another string\nWe then negate the return\
    \ value of duplicated to test if all elements of the list returned from strsplit\
    \ appear in the other string\n\n\n</text>\n<text>\nAnd now the function is_happy_2\
    \ :\n\n\n</text>\n<cell>\nis_happy_2 <- function(s) {\n  length(s)>=3 && all(sapply(strsplit(s,\"\
    \"), function(x) !any(duplicated(x))))\n}\n</cell>\n<text>\nLet's test our function\
    \ for different strings\n\n\n</text>\n<cell>\nis_happy(aa)\n</cell>\n<cell>\n\
    is_happy_2(aa)\n</cell>\n<cell>\nis_happy(abcd)\n</cell>\n<cell>\nis_happy(aabb)\n\
    </cell>\n<cell>\nis_happy(adb)\n</cell>\n<cell>\nis_happy(xyy)\n</cell>\n<text>\n\
    Extras\n\n</text>\n<text>\nNow it's your turn to write a function that checks\
    \ if a string is palindrome, and return TRUE or FALSE if it is. It is guaranteed\
    \ that the string contains only lower case letters (a to z).\n\n\n</text>\n<cell>\n\
    is_palindrome <- function(s) {\n  # YOUR CODE HERE\n}\n</cell>\n<text>\nTest it\
    \ for various strings:\n\n\n</text>\n<cell>\nis_palindrome(\"abc\")\n</cell>\n\
    <cell>\nis_palindrome(\"abba\")\n</cell>\n<cell>\nis_palindrome(\"abbacd\")\n\
    </cell>\n<cell>\nis_palindrome(\"abad\")\n</cell>\n<cell>\nis_palindrome(\"abbad\"\
    )\n</cell>\n<cell>\nis_palindrome(\"abba\")\n</cell>\n<cell>\nis_palindrome(\"\
    aba\")\n</cell>\n<text>\nQuestion 7", "\n    x <- strsplit(s, '')\n    length(x)\
    \ <-3 && all(unique(x[[1]]) == unique(x[[2]]) && unique(x[[2]]) == unique(x[[3]])\
    \ &&\n                         unique(x[[3]]) == unique(x[[4]]))\n}\n</code>\n\
    <|/ a tags=string,r dscore=0 |>\n<| a tags=string,r |>\nThis is an R function\
    \ which returns a boolean based on whether a given string is happy.\n<code>",
  "\n  stopifnot(is.character(s))\n  length(s) >= 3 && all(\n    sapply(1:(length(s)\
    \ - 1), function(k) length(unique(sapply(1:k + 1, function(i) substr(s, i, i +\
    \ 1)))) == 3L)\n  )\n}\n", "\n  h <- length(s) >= 3 && sapply(seq(1, length(s))\
    \ - 1, function(i) length(unique(sapply(seq(i, i + 3), paste, collapse=\"\")))\
    \ == 3)\n  return(h)\n}\nis_happy(\"abracadabra\")", "\n  n <- nchar(s);\n  n\
    \ <- ifelse(n == 3, TRUE, FALSE);\n  n <- ifelse(\n    n == TRUE,\n    mapply(function(x,\
    \ y) {\n      if(y == TRUE) {\n        any(grepl(y, substr(s, 1, x)))\n      }\
    \ else {\n        FALSE\n      }\n    }, seq(3, n, by = 3), seq(3, n, by = 3)),\n\
    \    TRUE\n  )\n  n\n}\n</code>\n<|/ a |>\n<| c |>\nYou might consider using `grepl`\
    \ instead of `mapply` in your solution.\n<|/ c |>\n<| c |>\nThanks. I just used\
    \ it because I thought it would be more efficient than using `mapply` twice, once\
    \ for counting the number of consecutive duplicates and once for testing for the\
    \ condition. But the `grepl` would still be the better solution.\n<|/ c |>\n<|\
    \ c |>\nIt would be more efficient to use the `mapply` twice as you suggested.\
    \ Using `grepl` would only make the code more complicated (and therefore less\
    \ readable).\n<|/ c |>\n<| c |>\nOkay, I updated the answer to show how `mapply`\
    \ is used to avoid repeating the `grepl` function.\n<|/ c |>\n<| a dscore=2 |>\n\
    This is a non-recursive solution. I've written it iteratively because I find it\
    \ easier to read.\n<code>\nhapr <- function(s) {\n  n <- nchar(s);\n  y <- c(FALSE,\
    \ TRUE);\n  i <- 1;\n  while (i < n) {\n    if (s[i] == s[i + 1]) {\n      y[i]\
    \ <- TRUE;\n      i <- i + 2;\n    } else {\n      y[i] <- FALSE;\n      i <-\
    \ i + 1;\n    }\n  }\n  y;\n}\n</code>\n<|/ a tags=string,r |>\n<| a dscore=1\
    \ tags=string,r |>\nThe code below uses regular expressions to determine whether\
    \ a string is haper. \n<code>\nlibrary(stringr)\n", "\n  length( s ) >= 3\n  apply(\
    \ s, 1, function(x) length(unique( x )) == 3 )\n}\n", "\n    n <- nchar(s);\n\
    \    if(n > 3)\n        TRUE #is happy\n    else {\n        if(n >= 3)\n     \
    \       length(unique(substring(s, 1, 3))) >= 3 & length(unique(substring(s, 1,\
    \ 3))) == 3 & \n            length(unique(substring(s, 2, 4))) >= 3 & length(unique(substring(s,\
    \ 2, 4))) == 3 & \n            length(unique(substring(s, 3, 5))) >= 3 & length(unique(substring(s,\
    \ 3, 5))) == 3 & \n            length(unique(substring(s, 4, 6))) >= 3 & length(unique(substring(s,\
    \ 4, 6))) == 3 & \n            length(unique(substring(s, 5, 7))) >= 3 & length(unique(substring(s,\
    \ 5, 7))) == 3 & \n            length(unique(substring(s, 6, 8))) >= 3 & length(unique(substring(s,\
    \ 6, 8))) == 3 & \n            length(unique(substring(s, 7, 9))) >= 3 & length(unique(substring(s,\
    \ 7, 9))) == 3 & \n            length(unique(substring(s, 8, 10))) >= 3 & length(unique(substring(s,\
    \ 8, 10))) == 3\n        else\n            length(unique(substring(s, 1, 2)))\
    \ >= 3 & length(unique(substring(s, 1, 2))) == 3\n    }\n}\n", "\n  if (length(s)\
    \ == 0) {\n    return(FALSE)\n  }\n\n  lapply(strsplit(s, \"\"), function(x) {\n\
    \    x2 <- unlist(strsplit(x, \"(?<=[a-z])(?=[a-z])\"))\n    if (length(x2) ==\
    \ 3 && length(unique(x2)) == 1) {\n      return(TRUE)\n    } else {\n      return(FALSE)\n\
    \    }\n  }) %>%\n    any()\n}\n\nis_happy(\"adbca\")\nis_happy(\"xyy\")\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=regex,r |>\nThis works for me. I know it's not efficient,\
    \ but it's at least correct:\n<code>\nis_happy <- function(s) {\n  a <- paste(s,collapse='')\n\
    \  a <- gsub('(.)\\\\1{2,}','\\\\1',a)\n  a <- gsub('(.)\\\\1{2,}','\\\\1',a)\n\
    \  a <- gsub('(.)\\\\1{2,}','\\\\1',a)\n  a <- gsub('(.)\\\\1{2,}','\\\\1',a)\n\
    \  a <- gsub('(.)\\\\1{2,}','\\\\1',a)\n  a <- gsub('(.)\\\\1{2,}','\\\\1',a)\n\
    \  a <- gsub('(.)\\\\1{2,}','\\\\1',a)\n  return(length(a) >= 3 & !any(duplicated(a)))\n\
    }\n\nis_happy('abaca')\nis_happy('xyz')\nis_happy('abacaba')\nis_happy('adb')\n\
    is_happy('xyzzy')\n</code>\n<|/ a |>\n<| c |>\nThanks, that definitely works!\n\
    <|/ c |>\n<| c |>\nYour code does not work for `is_happy('abaca')` because it\
    \ has three characters that are the same, but you return `false` for that case.\
    \ Why not return `TRUE` in that case?\n<|/ c |>\n<| a tags=regex,r |>\nHere is\
    \ an alternative implementation using stri_detect from the stringi package:\n\
    <code>\nis_happy <- function(s) {\n  library(stringi)\n  stri_count(s, '(?=(\\\
    \\w))')>=3&!any(stri_detect(s, '\\\\w+'))\n}\n</code>\nHere is a second approach\
    \ using gregexpr:\n<code>\nis_happy <- function(s) {\n  library(stringr)\n  m\
    \ <- regexpr('(\\\\w)(?=\\\\w+)\\\\1+', s, perl = TRUE)\n  any(!is.", "\n  length(s)\
    \ >= 3 && all(sapply(strsplit(s, \"(?<=^.{3})(?=.{3})\", perl = TRUE), function(x)\
    \ {\n    length(unique(x))>1\n  }))\n}\n", "\n  n <- length(s)\n  n >= 3 && all(sapply(1:(n-2),\
    \ function(x) length(unique(c(s[x:(x+2)], s[(x+1):(x+3)]))) == 2))\n}\n", "\n\
    \  sapply(seq_along(s), function(x) length(gregexpr(\"[a-d]+\", s)[[1]][x]) >=\
    \ 3 & \n                      all(unique(unlist(strsplit(s[seq(x:(x+3))], \"[a-d]\"\
    ))) == c(\"\", \"\", \"\")))\n}\n</code>\n<|/ a tags=r,string,python,data.table,r\
    \ |>\n<| c |>\nThank you for the answer. I am actually quite new to R so I have\
    \ some trouble understanding the code you provided. However, I do think I am on\
    \ the right track. Thanks again!\n<|/ c |>\n<| c |>\nI have added some explanation\
    \ to the answer.\n<|/ c |>\n<| a tags=r,string,python,data.table,r |>\nYou could\
    \ also use data.table::rleid to create a unique ID for each group of 3 consecutive\
    \ letters, and then check if the length of ID is greater than 0, i.e.\n<code>\n\
    library(data.table)\ns <- c(\"aabb\", \"abcd\", \"abcd\", \"abcc\", \"ab\", \"\
    xyy\")\ns2 <- gsub(\"(.)\\\\1+\", \"\\\\1\", s)\nsetDT(setnames(as.data.table(s2),\
    \ gsub(\"(.)\\\\1\", \"\\\\1_\", s2)))[\n  , .(is_happy = .N > 0), .(grp = rleid(V1))][\n\
    \    , is_happy := V1 > 0][]\n</code>\nwhich gives,\n\n<code>\n     grp is_happy\n\
    1:     0      FALSE\n2:     1      FALSE\n3:     2      FALSE\n4:     3      \
    \ TRUE\n5:     4      FALSE\n6:     5      FALSE\n</code>\n\nExplanation: gsub\
    \ will replace each repeated letter with itself, i.e., aaaa will be replaced by\
    \ a. Then, setnames changes the names of the data.table, such that we get a column\
    \ named \"aa_\", instead of just \"a\" as before. rleid will create a unique ID\
    \ for each group of 3 consecutive letters. Then, we count the number of rows for\
    \ each group of 3 consecutive letters using .N > 0, i.e. is_happy = .N > 0, and\
    \ finally we select the groups with is_happy = TRUE.\nData\n<code>\nlibrary(data.table)\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer akrun! I got an error\
    \ message for setnames saying \"Error in `colnames<-`(`*tmp*`, value = c(\"a\"\
    , \"a\", \"a\", \"a\", \"a\",  : \n  length of 'dimnames' [2] not equal to array\
    \ extent\"\n<|/ c |>\n<| c |>\nOh ", "\n  if(length(s)>=3 & all(lengths(strsplit(s,\
    \ \"\")) %in% c(1,3))) {\n    grepl(\"\\\\(.*\\\\)\", s)\n  } else {\n    FALSE\n\
    \  }\n}\n</code>\nExplanation:\n\nlength(a) returns the number of characters in\
    \ the string a.\nall(lengths(strsplit(a, \"\")) %in% c(1,3)) returns TRUE/FALSE\
    \ for every group of 3 consecutive letters in a given string a.\ngrepl(\"\\\\\
    (.*\\\\)\", a) checks if a string a is \"happy\", i.e. it contains at least 3\
    \ consecutive letters and all the letters occur only once in that group.\n<|/\
    \ a dscore=0 tags=r |>\n<| c |>\nThe `==` operator is vectorized, so `length(a)==3`\
    \ is equivalent to `length(a) == 3`.\n<|/ c |>\n<| c |>\nYes, of course. Thanks\
    \ for catching that. I edited the answer.\n<|/ c |>\n<| c |>\nAnd `==` works even\
    \ when one of its arguments is length 1 (e.g., `FALSE`, `TRUE`, `NA`, etc.).\n\
    <|/ c |>\n<| c |>\nGreat. Thanks for the explanation. I am wondering if the above\
    \ function can be improved on to make it faster. I would think strsplit could\
    \ take advantage of strsplit vectorizing, but I am not sure.\n<|/ c |>\n<| a dscore=0\
    \ tags=r |>\n<code>\nsapply(strsplit(s, \"(?<=.{3})\", perl=TRUE), function(x)\
    \ all(unique(x)))\n</code>\n<|/ a |>\n<| c |>\nHow do you think it could be improved?\
    \ It does run in about the same amount of time as the other two solutions posted\
    \ here.\n<|/ c |>\n<| c |>\nAha, now that makes sense, thanks for that insight.\
    \ It seems like strsplit is not vectorized at all and hence the slow run-time\
    \ for multiple runs of the function. This solution runs much faster though. Thanks.\n\
    <|/ c |>\n<| a |>\nWe can use chartr from base R (as it is vectorized) to remove\
    \ the repeated letters in-between the three characters and then check if the number\
    \ of unique elements are greater than 0 i.e. if the string is happy.\n<code>\n\
    is_happy <- function(s){\n  v1 <- chartr('aaabb', '', s)\n  v1 <- nchar(v1)\n\
    \  v1 <- unique(v1)\n  length(v1) > 0\n}\n\nis_happy(\"aaa\")", "\n  length(s)\
    \ >= 3 &&\n  sapply(s, function(x) { all(!duplicated(x)) }) \n}\n\nis_happy(c(\"\
    a\", \"b\", \"c\"))", "\n  s <- tolower(s)\n  return((length(s)>=3) & (unique(s)))\n\
    }\n", "\n  str <- strsplit(s, '')[[1]]\n  sum(length(s) == 3) & !duplicated(str)\
    \ & sum(sapply(str[3:(length(str) - 2)], function(x) \n    length(unique(x)) !=\
    \ 1)) == 3\n}\n\nis_happy(\"abc\")", "\n  str_length <- function(x)\n    sum(!is.na(str_match(x,\
    \ \"^\\\\w+$\")))\n  \n  n_chars <- function(x) sum(strsplit(x, \"\")[[1]] !=\
    \ \"\")\n  \n  return(n_chars(s) < 3 & str_length(s) < 3)\n}\n</cell>\n<text>\n\
    Now we test the function by comparing some strings:\n\n\n</text>\n<cell>\nis_happy('aaa')\n\
    </cell>\n<cell>\nis_happy('aabb')\n</cell>\n<cell>\nis_happy('adb')\n</cell>\n\
    <cell>\nis_happy('xyy')\n</cell>\n<text>\nExercise\nDefine a function is_happy\
    \ with one parameter s which:\n\nTakes as input a string s (str).\nReturns a Boolean\
    \ value (True/False) indicating whether string s is a happy string.\nYou should\
    \ be able to write code like this:\n", "\n  length(na.omit(str_split(s, na.rm\
    \ = T)) == 3) && \n    !duplicated(na.omit(str_split(s, na.rm = T)[[1]][seq_along(str_split(s,\
    \ na.rm = T)[[1]]) %in% c(TRUE, TRUE)]))\n}\n</code>\n<|/ a tags=r dscore=1 |>\n\
    <| a dscore=1 tags=r |>\nBase R solution\n<code>\nis_happy <- function(s) {\n\
    \  s <- na.omit(gsub(\"[^a-z]\", \"\", s))\n  n <- sapply(s, nchar) >= 3\n  return(!any(diff(as.numeric(factor(s)[!n]))\
    \ > 1))\n}\n\nis_happy(\"aabb\")", "\n  s <- toupper(s)\n  sapply(1:(length(s)-3),\
    \ function(i) all(c(\"A\", \"A\", \"B\", \"B\", \"C\", \"C\", \"D\", \"D\", \"\
    E\", \"E\") == s[(1+i):(2+i)]) & !unique(ss[(1+i):(2+i)])) # checks each 3 consecutive\
    \ letters are distinct\n}\n\nis_happy(a)\nis_happy(aa)\nis_happy(abcd)\nis_happy(aabb)\n\
    is_happy(adb)\nis_happy(xyy)\n</code>\n<|/ a |>\n<| a |>\nIf you don't mind the\
    \ function returning a list (which is often better than a vector when you want\
    \ to return a result that doesn't fit into a vector) you can do this by generating\
    \ a vector and using a logical test on that. For example:\n<code>\nis_happy <-\
    \ function(string) {\n  is_happy_indicator <- FALSE\n  for(i in  1:(length(string)\
    \ - 3)) {\n    is_happy_indicator <- is_happy_indicator | (string[i:(i + 3)] %in%\
    \ letters)\n  }\n  list(is_happy_indicator)\n}\n\nis_happy(\"abc\")\nis_happy(\"\
    abcd\")\nis_happy(\"aaaa\")\nis_happy(\"abcde\")\n</code>\n<code>\n$is_happy_indicator\n\
    [1] FALSE\n\n$is_happy_indicator\n[1] FALSE\n\n$is_happy_indicator\n[1] TRUE\n\
    \n$is_happy_indicator\n[1] FALSE\n\n$is_happy_indicator\n[1] FALSE\n\n$is_happy_indicator\n\
    [1] TRUE\n\n$is_happy_indicator\n[1] FALSE\n</code>\n<|/ a tags=r dscore=1 |>\n\
    <| a tags=r dscore=1 |>\nYou could use strsplit to get your parts into a list\
    \ and then use Reduce with a logical or (|) to combine them into a single logical\
    \ vector.\n<code>\nis_happy <- function(string) {\n  stringSplit <- strsplit(string,\
    \ \"\")\n  Reduce(`|`, lapply(stringSplit, function(x) c(letters, x)))\n}\n\n\
    is_happy(\"abc\")", "\n  lapply(seq_along(s), function(i)\n    length(s) == 3\
    \ & unique(s[(i +1):(nchar(s) - (i + 1))])==3\n  )\n}\n</cell>\n<cell>\nis_happy(a)\
    \ # FALSE\nis_happy(aa) # FALSE\nis_happy(abcd) # TRUE\nis_happy(aabb) # FALSE\n\
    is_happy(adb) # TRUE\nis_happy(xyy) # FALSE\n</cell>\n<text>\nExercises:\nWhat\
    \ is the string abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is\
    \ the string abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the\
    \ string abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string\
    \ abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string abcdef\
    \ that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string abcdef that\
    \ is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string abcdef that is\
    \ hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string abcdef that is hapr?\n\
    \n\n</text>\n<text>\nExercises:\nWhat is the string abcdef that is hapr?\n\n\n\
    </text>\n<text>\nExercises:\nWhat is the string abcdef that is hapr?\n\n\n</text>\n\
    <text>\nExercises:\nWhat is the string abcdef that is hapr?\n\n\n</text>\n<text>\n\
    Exercises:\nWhat is the string abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\n\
    What is the string abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat\
    \ is the string abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is\
    \ the string abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the\
    \ string abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string\
    \ abcdef that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string abcdef\
    \ that is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string abcdef that\
    \ is hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string abcdef that is\
    \ hapr?\n\n\n</text>\n<text>\nExercises:\nWhat is the string abcdef that is hapr?\n\
    \n\n</text>\n<text>\nExercises:\nWhat is the string abcdef that is hapr?\n\n\n\
    </text>\n<text>\nExercises:\nWhat is the string abcdef that is hapr?\n\n\n</text>\n\
    <text>\nExercises:\nWhat is the ", "\n  strlen <- length(s) \n  h <- seq(3, strlen,\
    \ by = 3)\n  lapply(h, function(x) all(unique(substr(s, x, x + 3)) == s[x:x +\
    \ 3]))\n}\n", "\n  if(length(s) < 3 || (length(s) == 3 & length(unique(substr(s,\
    \ nchar(s), nchar(s))))<3)) FALSE else TRUE\n}\n", "\n    l <- strsplit(s, \"\"\
    )\n    any(length(l) >= 3 & lapply(l, function(x) length(unique(x))) == 3)\n}\n\
    </code>\n<|/ a dscore=0 tags=r,string |>\n<| c |>\nCan you explain why you use\
    \ \"a\" as an argument to your function?\n<|/ c |>\n<| c |>\nI used it as a variable\
    \ and I used `a` as a string for testing\n<|/ c |>\n<| c |>\n`a` means any letter\
    \ of the alphabet\n<|/ c |>\n<| c |>\nI tested it on my machine and it worked!\
    \ How did you do that?\n<|/ c |>\n<| c |>\nI run it on R terminal from rstudio\
    \ and it worked! How did you do that?\n<|/ c |>\n<| a |>\nHere's a version using\
    \ strsplit and lapply. \n<code>\nis_happy <- function(s) {\n    l <- strsplit(s,\
    \ \"\")\n    any(length(l) >= 3 & lapply(l, function(x) length(unique(x))) ==\
    \ 3)\n}\n</code>\nTesting it on some sample strings\n<code>\n> is_happy(\"abcd\"\
    )\n[1] FALSE\n\n> is_happy(\"aabc\")\n[1] TRUE\n\n> is_happy(\"aabb\")\n[1] FALSE\n\
    \n> is_happy(\"adb\")\n[1] TRUE\n\n> is_happy(\"xyy\")\n[1] FALSE\n</code>\n<|/\
    \ a tags=r,string dscore=0 |>\n<| c |>\nCan you explain why you use \"a\" as an\
    \ argument to your function?\n<|/ c |>\n<| c |>\nI used it as a variable and I\
    \ used `a` as a string for testing\n<|/ c |>\n<| c |>\n`a` means any letter of\
    \ the alphabet. In the function, `a` means an `a` or a string `aa`. I just used\
    \ `a` so that I could use `a` as input for testing\n<|/ c |>\n<| c |>\nI run it\
    \ on R terminal from rstudio and it worked! How did you do that?\n<|/ c |>\n<|\
    \ c |>\nThe function is taking the input argument `a` and passing it to `strsplit`\
    \ as an argument. Since `strsplit` requires an argument as string, `a` is converted\
    \ to `\"a\"`. When you run it in Rstudio, you're using your input argument as\
    \ `\"a\"` which makes the function work\n<|/ c |>\n<| a dscore=0 |>\nMy first\
    \ idea would be", "\n    l <- length(s)\n    if(l < 3 || l %% 3 != 0)\n      \
    \  return(FALSE)\n    for(i in 1:(l-2)) {\n        if(s[i] != s[i+1]) return(FALSE)\n\
    \    }\n    return(TRUE)\n}\n</code>\n<|/ a tags=r dscore=2 |>\n<| c |>\nI get\
    \ the following error when running your `is_happy` function: Error in is_happy(hello)\
    \ : argument \"s\" is missing, with no default\n<|/ c |>\n<| c |>\nYour question\
    \ did not include an example of `s`, so I assumed you knew what that was, otherwise\
    \ I suppose your original attempt would be okay. I'll update my answer with something\
    \ that works with an arbitrary `s`.\n<|/ c |>\n<| c |>\nHi Robert. Sorry I forgot\
    \ to include it. I was testing your function with strings of length 1, 2 & 3.\
    \ Once I tested with your function with strings length 3 & 4  it worked as expected.\
    \ Do you know why that would be? I thought your function would only test if the\
    \ length of s is 3 or 4.\n<|/ c |>\n<| c |>\n, that's because I used `sapply(s,\
    \ is_happy)`, which would apply the function to the whole of `s`. If you want\
    \ to test the lengths, you should use `sapply(s, is_happy)`.\n<|/ c |>\n<| c |>\n\
    , yes, that's exactly what it does. Since `sapply` only applies the function to\
    \ the elements of a vector, it would work just fine for `sapply(s, is_happy)`.\
    \ I'll update my answer with a full example.\n<|/ c |>\n<| a tags=r |>\nAn option\
    \ with str_detect\n<code>\nlibrary(stringr)\nstr_length(s) == 3|str_length(s)\
    \ == 4\n</code>\n<|/ a dscore=1 |>\n<| a tags=r dscore=1 |>\n<code>\nis_happy\
    \ <- function(s) {\n  length(s) * grepl(\"[^a]\", s)\n}\n\nis_happy(\"aaaa\")\n\
    is_happy(\"aaaaa\")\nis_happy(\"aaaaaa\")\nis_happy(\"aaaaaaa\")\nis_happy(\"\
    aaaaaaa\")\n</code>\n<|/ a |>\n<| c |>\nI edited the question to include an example\
    \ with my desired output and made a mistake when testing the function with strings\
    \ of length 1, 2 & 3. Your function seems to work well for strings of length 3\
    \ & 4.\n<|/ c |>\n<| c |>\nI edi", "\n  \n  # checks if the string is empty\n\
    \  if(length(s) < 3L) return(FALSE)\n  \n  # checks every 3 consecutive letters\
    \ \n  for(i in 2:(length(s)-3L)) {\n    \n    # checks if the current letter is\
    \ a different one\n    if(s[i] != s[i+1]) {\n      \n      # checks if the current\
    \ letter is the same letter\n      if(s[i] != s[s[i+1]]) {\n        \n       \
    \ # checks if the current letter is a different one\n        if(s[i] != s[s[i+2]])\
    \ return(TRUE)\n      }\n    }\n  }\n  return(FALSE)\n}\n", "\n  nchar(s) >= 3\
    \ && !(\n    length(s) - 3L == sapply(1:(length(s) - 3L), function(i) all(sapply(1:3,\
    \ function(j) s[i] == s[i+j], j=3)))\n  )\n}\n", "\n  len <- nchar(s)\n  all_distinct\
    \  <- unique(unlist(strsplit(s, \"\")))\n  return(len >=3 && all(all_distinct\
    \ %in% all_distinct[1:3]))\n}\n</cell>\n<cell>", "\n  s <- tolower(s)\n  length(sapply(s,\
    \ function(x) length(unique(x))) == 3) & \n     all(sapply(s, function(x) length(unique(x))\
    \ == 3)) == TRUE\n}\n</code>\n<|/ a dscore=0 tags=string,r |>\n<| c |>\nThis seems\
    \ like a clever approach, but why is the `length` necessary?  If you use `sapply(s,\
    \ function(x) length(unique(x))) == 3` you get the same result?\n<|/ c |>\n<|\
    \ c |>\nThe `length` is to make sure that the `if` statement returns TRUE or FALSE.\
    \ `sapply` returns the `length`s of each string in the vector, and `all` tests\
    \ whether the sum of the lengths is `3` (i.e. that the strings are all the same\
    \ length)\n<|/ c |>\n<| a |>\n<code>\nis_happy <- function(s) {\n  s <- tolower(s)\n\
    \  sapply(s, function(x) length(unique(x))) == 3 && all(sapply(s, function(x)\
    \ length(unique(x)) == 3))\n}\n</code>\nThis doesn't require packages.\n<|/ a\
    \ dscore=0 tags=string,r |>\n<| a tags=string,r |>\nOne can simply do it as follows:\n\
    <code>\nis_happy <- function(s) {\n  s <- tolower(s)\n  x <- sapply(s, function(x)\
    \ length(unique(x)))\n  all(x > 2)\n}\n\nis_happy(\"ABbbCcDdd\")", "\n  return(length(s)\
    \ >=3 && all(sapply(1:(length(s)-1), function(i) !identical(s[i:(i+1)], s[i:(i+1)]))))\n\
    }\n</code>\nAnd there you go! This should do it!\n<|/ a dscore=1 |>\n<| c |>\n\
    This is not quite what OP wants. For example, `is_happy(\"aabbcc\")` is `FALSE`\
    \ but should be `True`\n<|/ c |>\n<| c |>\nI think OP did say that it was supposed\
    \ to return `true` if the string has at least 3 letters and that the letters are\
    \ distinct. That's what the OP asked.\n<|/ c |>\n<| c |>\nI agree with you, I\
    \ just saw the sentence at the end where it says \"every 3 consecutive letters\
    \ are distinct\" and I thought that OP wants that.\n<|/ c |>\n<| c |>\nI see what\
    \ you mean... I'll edit my answer accordingly\n<|/ c |>\n<| c |>\nI believe this\
    \ still doesn't work. For example `is_happy(\"aba\")` returns `TRUE` but it should\
    \ be `FALSE`\n<|/ c |>\n<| a dscore=1 |>\nWe can use rle\n<code>\nis_happy <-\
    \ function(s) {\n  with(rle(s), all(values == 3 & lengths == 3))\n}\n\nis_happy(\"\
    aabbcc\")", "\n  n <- nchar(s);\n  if(length(n) == 0) {\n    return(TRUE)\n  }\n\
    \  if(length(n) < 3) {\n    return(FALSE)\n  }\n  for(i in 1:(n-2)) {\n    if(s[(i+1):n]\
    \ == s[(i+1):n+1]) continue;\n    return(FALSE)\n  }\n  return(TRUE)\n}\n\nis_happy(s\
    \ = \"adb\")\nis_happy(s = \"abd\")\nis_happy(s = \"abdb\")\nis_happy(s = \"abbdd\"\
    )\nis_happy(s = \"aaaa\")\nis_happy(s = \"xyy\")\nis_happy(s = \"\")\nis_happy(s\
    \ = \" \")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s\
    \ = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\n\
    is_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb\
    \ aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s\
    \ = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\n\
    is_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb\
    \ aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s\
    \ = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\n\
    is_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb\
    \ aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s\
    \ = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\n\
    is_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb\
    \ aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s = \"adb bb aa\")\nis_happy(s\
    \ = \"ad", "\n    s <- tolower(s)\n    s <- gsub(\"[[:punct:]]\", \"\", s)\n \
    \   s <- gsub(\"[[:space:]]\", \"\", s)\n    s <- gsub(\"[[:alpha:]]\", \"\",\
    \ s)\n    s <- gsub(\"[[:digit:]]\", \"\", s)\n    s <- paste0(s,collapse=\"\"\
    )\n    s <- substr(s, 1, 3)\n    s <- paste0(s, collapse=\"\")\n    s <- nchar(s)\
    \ >= 3 && all((substr(s, 1, 1) == substr(s, 2, 1)) | (substr(s, 1, 2) == substr(s,\
    \ 2, 1)))\n    return(s)\n}\n</cell>\n<cell>\nprint(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(is_happy(",
  "\n  require(stringr)\n  require(foreach)\n  require(parallel)\n  require(doParallel)\n\
    \n  s <- tolower(s)\n  n <- str_count(s, \"[[:alpha:]]\")\n  if(length(s) < 3)\
    \ {\n    return(FALSE)\n  }\n  else {\n    s <- strsplit(s, \"\")[[1]]\n    s\
    \ <- s[-n:3]\n    s <- unique(unlist(s))\n    s <- toupper(s)\n    s <- s == s\n\
    \    length(s) >= 3\n  }\n}\n", "\n  s <- tolower(s)\n  if (length(s)>3) {\n \
    \   for(i in 3:(length(s))){\n      if(s[i-3]==s[i-2]==s[i-1]){\n        return(FALSE)\n\
    \      }\n    }\n  }\n  return(TRUE)\n}\n</code>\n<|/ a |>\n<| c |>\nI like this\
    \ idea, but a simpler version can be found by using the fact that `TRUE` and `FALSE`\
    \ are logicals and that `x && y` means (`if(x) { return(TRUE) } else { return\
    \ (FALSE) }`). So `if (length(s)>3) { for (i in 3:(length(s)-1)) if (s[i] == s[i+1]\
    \ && s[i] == s[i+2]) return(FALSE) } return(TRUE)`. Just for completeness, I should\
    \ point out that `s == substr(s, 1, 3)` would also work, as is more efficient\
    \ than `sapply`\n<|/ c |>\n<| c |>\n: Yes, your solution is simpler. I was thinking\
    \ along the lines of the way you did the other one, but since `sapply` returns\
    \ `FALSE` for an empty list, I thought there would be a slicker way to do the\
    \ check. Thanks!\n<|/ c |>\n<| c |>\nThanks for the quick answer. Could you please\
    \ explain the difference between `s[3:length(s) + 1]` and `s[-c(3, length(s) +\
    \ 1)]?` Thanks\n<|/ c |>\n<| a dscore=4 |>\nHere's an interesting solution that\
    \ I came up with. It uses some basic regular expressions (but no looping). \n\
    <code>\nis_happy <- function(s) {\n  s <- tolower(s)\n  grepl(\"^(?=.{3,}[a-z])(?=.{3,}[A-Z])(?=.{3,}[a-z]+$)\"\
    , s)\n}\n</code>\nThe first three characters (^ and $) ensure there is at least\
    \ three characters before and after the string (no spaces, hyphens, etc), while\
    \ the (?=.{3,}[a-z]+) matches any string of at least three characters consisting\
    \ of lowercase characters, including lowercase followed by lowercase at the end\
    \ of the string. \nThe grepl() check returns TRUE if the pattern matches, FALSE\
    \ otherwise.\n<|/ a tags=string,r,regex |>\n<| a dscore=3 |>\nThis is what I have\
    \ come up with so far:\n<code>\ngrepl(\"^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)\", x,\
    \ perl=TRUE)\n</code>\nIn short, it uses three lookahead assertions with:\n<code>\n\
    (?=", "\n    all((nchar(s) == 3) & n_distinct(s) >= 3 & n_distinct(s, 2)) == TRUE\n\
    }\n</cell>\n<cell>", "\n  str <- nchar(s) >= 3\n  if (any(str)) {\n    lapply(strsplit(s,\
    \ \"\"), function(x) !is.na(unique(x)))\n  } else {\n    FALSE\n  }\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for providing a solution. Could you please explain\
    \ the difference between your solution and mine? Which is more \"efficient\"?\
    \ I wanted to learn `sapply` vs `lapply` so I understand the difference. Thank\
    \ you again.\n<|/ c |>\n<| c |>\nMy solution does `length(s) >= 3` and then checks\
    \ if there are any strings with length 3 or larger. That is not what you want.\n\
    <|/ c |>\n<| a dscore=3 tags=r |>\nHere's a vectorized solution using rle:\n<code>\n\
    is_happy <- function(s) {\n  r <- rle(s[length(s)>=3])\n  any(r$values)\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis seems to run faster. Thanks!\n<|/ c |>\n<| a |>\nHere's\
    \ my solution\n<code>\nis_happy <- function(s) {\n  i <- which(sapply(strsplit(s,\
    \ \"\"), length)>=3)\n  if(length(i)>0) grepl(\"aa|ab|ba|bb\", s)\n}\n</code>\n\
    <|/ a dscore=2 tags=r |>\n<| c |>\nIf you're going to use regular expressions,\
    \ you might as well use `grepl` instead of `grep` - `grepl(\"^aa$\", s)` would\
    \ be equivalent to the longer version of your `grep` call.\n<|/ c |>\n<| c |>\n\
    Yeah, I forgot to add ^ (beginning) and $ (end) to grepl to match the OP's requirement.\
    \ Edited.\n<|/ c |>\n<| c |>\nI think that `grepl` is slower than `grep` in R\n\
    <|/ c |>\n<| c |>\nI didnt test it but it may be faster - if you test it, let\
    \ me know how it compares to the other solutions here.\n<|/ c |>\n<| c |>\nI think\
    \ that using `grepl` instead of `grep` will probably be slower, but as I commented\
    \ on your answer - benchmarking the two on strings with 10^6 elements will tell\
    \ you the truth.\n<|/ c |>\n<| a |>\nI think this is shorter and works:\n<code>\n\
    is_happy <- function(s) {\n  all(sapply(strsplit(s, \"\"), function(x) ", "\n\
    \  length(s) >= 3 && all(sapply(strsplit(s,\"\"),function(x) length(unique(x))==3))\n\
    }\n", "\n    l <- str_len(s)\n    l >= 3 && all(diff(sort(c(1, head(rev(s), l-3))))\
    \ == 0)\n}\nis_happy('abc')", "\n  s <- gsub('', '', s)\n  return(length(s) >=\
    \ 3 &\n         all(sapply(1:(length(s)-3), function(i) all(unique(substr(s, i,\
    \ i+3)) %in% s))))\n}\n</code>\n<|/ a |>\n<| a |>\nI tried to implement the solution\
    \ that was given to me by and to compare it with my solution:\n<code>\nlibrary(data.table)\n\
    library(tidyverse)\n\nstr_distn <- function(string) {\n  return(distn(string))\n\
    }\n", "\n  if(length(s) >= 3 && !(substr(s, 1, 3) %in% c(\"\", letters[1:26]))\
    \ ){\n    return(FALSE)\n  }else{\n    return(TRUE)\n  }\n}\n</cell>\n<cell>",
  "\n  if(length(s) >= 3 && !(identical(substr(s, 1, 2), substr(s, 2, 2)) | identical(substr(s,\
    \ 2, 2), substr(s, 1, 2)))){\n    return(TRUE)\n  } else {\n    return(FALSE)\n\
    \  }\n}\n</cell>\n<cell>", "\n    n <- length(s)\n    any(n>=3 & \n        all(unique(c(s[i-1:i+2])\
    \ %in% s[j:k])==FALSE)\n        for (i in seq_len(n-2) ) \n        for (j in seq_len(n-2)\
    \ ) \n        for (k in seq_len(n-2) ) )\n}\n", "\n  # return FALSE if empty string\n\
    \  if (!isTRUE(grepl('^$',s))) {\n    cat('string is not empty\\n')\n    return(FALSE)\n\
    \  }\n  # if string length is 0, return FALSE\n  cat('string length is 0\\n')\n\
    \  if (length(s) < 3) {\n    cat('string length is less than 3\\n')\n    return(FALSE)\n\
    \  }\n  # if not every three characters are distinct\n  # return FALSE\n  cat('checking\
    \ if every three characters are distinct\\n')\n  if(all(sapply(seq(1, (length(s)-3)),\
    \ function(i) all(unique(c(s[c(1:(i-1),i+1),c(2:(i+2),length(s))]))) == sapply(seq(1,\
    \ (length(s)-3)), function(i) all(unique(c(s[c(1:(i-1),i+1),c(2:(i+2),length(s))])))))\
    \ {\n    cat('yes, every three characters are distinct\\n')\n    return(TRUE)\n\
    \  } else {\n    cat('no, every three characters are not distinct\\n')\n    return(FALSE)\n\
    \  }\n}", "\n  s <- tolower(s)\n  sum(length(s) >= 3 & \n       sapply(s, function(i){\n\
    \         unique(substr(s, i, i+3))\n       })) > 0\n}\n</code>\n<|/ a tags=r,performance,for-loop,string\
    \ |>\n<| c |>\nThis is amazing! Just what I needed. I didn't realize that using\
    \ sapply on s would simplify it a great deal. Thanks so much!\n<|/ c |>\n<| c\
    \ |>\n`sapply` on a string returns a vector. The `length` of that vector is what\
    \ you're after. And `substr` extracts a section of a string.\n<|/ c |>\n<| c |>\n\
    Gotcha, thanks for the explanation. I thought `sapply` would iterate over the\
    \ characters in the string `s`, but I was mistaken.\n<|/ c |>\n<| a dscore=0 |>\n\
    This solution is slightly different, but it is a bit faster (1.5 times faster)\
    \ than the other solutions so far:\n<code>\nis_happy <- function(s) {\n  sapply(s,\
    \ nchar) >= 3 & !any(sapply(s, nchar) == 1)\n}\n</code>\nThe trick is that nchar\
    \ counts the number of characters in a string, and we know that any string that\
    \ contains exactly one character has at least one other character. So if we have\
    \ two strings, a and aaa, the first one will have 2 characters, and the second\
    \ will have 3. The difference is that the second one will have 2 different characters,\
    \ even though they look the same to the user.\nWe could even speed it up even\
    \ more by pre-computing the counts first, but that is unlikely to help much for\
    \ much larger inputs (I tested it on inputs of size 1000 and 10000).\n<|/ a tags=r,performance,for-loop,string\
    \ |>\n<| a dscore=0 |>\nAn additional alternative using stringi and stringr (1.3\
    \ times faster):\n<code>\nlibrary(stringr)\nlibrary(stringi)\n\nis_happy <- function(s)\
    \ {\n  sum(stri_count(s, regex('[a-zA-Z]', ignore_case = TRUE)) == 3 & \n    \
    \  stri_count(s, regex('[a-z]', ignore_case = TRUE)) == 3) == 1\n}\n</code>\n\
    <|/ a tags=r,performance,for-loop,string |>\n<| a tags=r,performance,for-loop,string\
    \ |>\nHere's another solution:\n<code>\nis_happy <- function(s) {\n    n <- nchar(s);\n\
    \    for(i in 1:(n - 1)) {\n        for(j in (i + 1):n) {\n            if((j -\
    \ i) > 1 & nchar(gsub(\"[a-z]\", \"\", s, fixed = ", "\n    length(na.omit(s))>=3\
    \ &\n        Reduce(`&`, lapply(str_split(s, n = 3), function(x) !length(x) %in%\
    \ c(1, length(unique(x))))) \n}\n</cell>\n<cell>\nis_happy(a)\n</cell>\n<cell>\n\
    is_happy(aa)\n</cell>\n<cell>\nis_happy(abcd)\n</cell>\n<cell>\nis_happy(aabb)\n\
    </cell>\n<cell>\nis_happy(adb)\n</cell>\n<cell>\nis_happy(xyy)\n</cell>\n<cell>",
  "\n  sapply(s, length) >= 3 && \n    sapply(s, function(x){\n      all(x != c(x[-length(x)])\
    \ | x %in% c(x[-length(x)], x[1]))\n    })\n}\n\nis_happy(letters)\n</code>\n\
    <|/ a |>\n<| c |>\nI like the idea of using the modulus operator and also thought\
    \ about using `rle` to check for groups of consecutive letters. I posted my answer\
    \ before seeing yours.\n<|/ c |>\n<| a |>\nI like's answer but I thought I'd try\
    \ another approach. \nLet's assume that we can only have two letter groups. \n\
    <code>", "\n  # Find out how many letters there are in the string\n  n <- length(s)\n\
    \  \n  # If there are too few letters, return False\n  if(n < 3) {\n    return(FALSE)\n\
    \  }\n  \n  # Check that each 3 consecutive letters are distinct\n  for(i in 3:n)\
    \ {\n    for(j in 1:(i - 1)) {\n      if(s[i] != s[j]) {\n        return(FALSE)\n\
    \      }\n    }\n  }\n  \n  # If we've made it here, we have a happy string\n\
    \  return(TRUE)\n}\n", "\n  if (length(s) >= 3) {\n    result <- FALSE\n    for\
    \ (letter in s) {\n      if (!(letter %in% letters)) result <- TRUE\n    }\n \
    \   return(result)\n  }\n  return(FALSE)\n}\n", "\n    n <- nchar(s)\n    length(sapply(strsplit(s,\
    \ \"\"), function(x) length(unique(x))) == 3)\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\n`==3` will cause problem if OP needs to detect `aba`.\n<|/ c |>\n<| c\
    \ |>\nYeah I noticed that. I will amend my answer\n<|/ c |>\n<| c |>\nThanks,\
    \ this works. But I still don't understand why `==3` doesn't work\n<|/ c |>\n\
    <| c |>\nPlease see my explanation in the edit\n<|/ c |>\n<| a dscore=1 |>\nA\
    \ vectorized solution would be to use regex and lookarounds (?<=) and (?!) to\
    \ make sure there are no 2 adjacent letters repeated:\n<code>\ngrepl(\"(?<=.)(?!.*(.).*\\\
    1)\", x)", "\n  if(length(s) >= 3) sapply(strsplit(s, \"(..)\"), function(x)\n\
    \    length(x) >=3 & length(unique(x)) >=3)\n}\n", "\n  n <- nchar(s) # or length(s)\n\
    \  all(n >= 3 & rep(seq_along(n), each = 3) %in% rep(1:3, length(n)))\n}\n</cell>\n\
    <text>\n2.3 Exercise: Convert strings to factors\n\n</text>\n<text>\nWrite a function\
    \ char_to_factor(s) that takes in one character string and outputs a factor. Your\
    \ function should convert all character strings to factors.\nThe function should\
    \ throw an error if the input string is empty or contains duplicate characters.\n\
    The function should raise an error if the input string contains characters that\
    \ are not letters.\n\nExamples:\nchar_to_factor('a') should return factor(c('a'))\n\
    char_to_factor('xyy') should return factor(c('a', 'y'))\nchar_to_factor('a#')\
    \ should return factor(c('a'))\nchar_to_factor('abc') should throw an error\n\n\
    \n</text>\n<cell>\nchar_to_factor <- function(s) {\n  # Your code here\n  if(length(s)==0){\n\
    \    stop('Empty string')\n  }\n  if(any(!grepl('^[A-Za-z]+$', s))){\n    stop('Invalid\
    \ input')\n  }\n  if(any(duplicated(as.character(s)))){\n    stop('Duplicate chars')\n\
    \  }\n  return(factor(s))\n}\n</cell>\n<text>\n2.4 Exercise: Character encoding\n\
    \n</text>\n<text>\nWrite a function encode(c) that takes in one character string\
    \ and outputs a character string. The output character string should be encoded\
    \ in UTF-8.\nThe function should convert all character strings to UTF-8 encoded\
    \ character strings.\nThe function should throw an error if the input string contains\
    \ characters that are not letters.\n\nExamples:\nencode('a') should return 'a'\n\
    encode('abc') should return 'abc'\nencode('xyy') should raise an error\n\n\n</text>\n\
    <cell>\nencode <- function(c) {\n  # Your code here\n  if(any(!grepl('^[A-Za-z]+$',\
    \ c))){\n    stop('Invalid input')\n  }\n  return(ifelse(is.character(c), utf8ToInt(as.character(c)),\
    \ \n               ifelse(is.factor(c), as.character(c), c)))\n}\n</cell>\n<text>\n\
    3. Vectorization\n\n</text>\n<text>\n3.1 Vectorization: Vectorizing with strings\n\
    \n</text>\n<text>\nWrite a function that converts one vector to another. The function\
    \ should convert each element of a vector, regardless of its class, to a character\
    \ string.\nThe function should throw an error if the input vector is empty.\n\
    The function should throw an error if the input vector contains ", "\n  return(sapply(1:(nchar(s)),\
    \ function(i) length(unique(sapply(seq(i, i+3), \n                           \
    \                        function(j) substr(s, i, j)))))>=3)\n}\n</cell>\n<cell>\n\
    is_happy(a) \nis_happy(aa)\nis_happy(abcd)\nis_happy(aabb)\nis_happy(adb)\nis_happy(xyy)\n\
    </cell>\n<cell>", "\n  if(grepl(\"^[a-zA-Z]{3,}$\", s) == TRUE) {\n    if(grepl(\"\
    ^[a-zA-Z]{3,}$\", substr(s, 1, 3)) != TRUE) {\n      return(FALSE)\n    } else\
    \ {\n      return(all(unique(substr(s, 1, 3)) == substr(s, 1, 3)))\n    }\n  }\
    \ else {\n    return(FALSE)\n  }\n}\n</code>\n<|/ a tags=r dscore=2 |>\n<| a tags=r\
    \ |>\nHere's a solution using a regex to test for \"happy.\"\n<code>\nis_happy\
    \ <- function(s) {\n  grepl(\"^(?=.*[A-Za-z])(?=[^A-Za-z]*[A-Z])(?=[^A-Za-z]*\\\
    \\d)[A-Za-z]{3}$\", s)\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\nHere's\
    \ a variation on Josh's answer:\n<code>\nis_happy <- function(s) {\n  grepl(\"\
    ^(?=.*[A-Za-z])(?=.*\\\\d)[A-Za-z]{3}$\", s)\n}\n\nis_happy(\"\")\nis_happy(\"\
    a\")\nis_happy(\"aa\")\nis_happy(\"abcd\")\nis_happy(\"aabb\")\nis_happy(\"adb\"\
    )\nis_happy(\"xyy\")\n</code>\nThis looks for three upper case letters followed\
    \ by a digit.\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nA more complex regex to match\
    \ a 3-digit number with at least one alpha character in between would be:\n<code>\n\
    ^(?=.{3})(?=.*?[a-zA-Z])(?=.*?[0-9])[a-zA-Z0-9]{3}$\n</code>\n<|/ a tags=r |>\n\
    <| a dscore=1 tags=r |>\nA more general solution using str_count from the stringr\
    \ package\n<code>\nlibrary(stringr)\nstr_count(\"ababba\", \"[a-z]\") >= 3 & str_count(x,\
    \ \"[a-z]\") >= 3", "\n  length(s) % 3 == 0L &\n    grepl(\"^[a-z]{3}$\", s) &\n\
    \    !grepl(\"^[a-z]{3}{2}$\", s) &\n    !grepl(\"^[a-z]{3}[a-z]{2}$\", s)\n}\n\
    </cell>\n<cell>\nis_happy(s = \"abb\")\n</cell>\n<cell>\nis_happy(s = \"aabb\"\
    )\n</cell>\n<cell>\nis_happy(s = \"abbb\")\n</cell>\n<cell>\nis_happy(s = \"abbba\"\
    )\n</cell>\n<text>\nP2.3. The function is_happy_2(a)\n\n</text>\n<cell>\nis_happy_2\
    \ <- function(a) {\n  length(a) %% 3 == 0 &\n    !is.na(sort(a, decreasing = TRUE))\
    \ &\n    !is.na(sort(a, decreasing = FALSE))\n}\n</cell>\n<cell>\nis_happy_2(s\
    \ = \"abbba\")\n</cell>\n<cell>\nis_happy_2(s = \"aabb\")\n</cell>\n<cell>\nis_happy_2(s\
    \ = \"aabbbb\")\n</cell>\n<text>\nP2.4. The function is_happy_3(a)\n\n</text>\n\
    <cell>\nis_happy_3 <- function(s) {\n  length(s) % 3 == 0 &\n    !is.na(sort(s,\
    \ decreasing = TRUE)) &\n    !is.na(sort(s, decreasing = FALSE)) &\n    !is.na(sort(s,\
    \ decreasing = TRUE)) &\n    !is.na(sort(s, decreasing = FALSE))\n}\n</cell>\n\
    <cell>\nis_happy_3(s = \"abbba\")\n</cell>\n<cell>\nis_happy_3(s = \"aabb\")\n\
    </cell>\n<cell>\nis_happy_3(s = \"aabbbb\")\n</cell>\n<text>\nP2.5. The function\
    \ is_happy_4(a)\n\n</text>\n<cell>\nis_happy_4 <- function(s) {\n  length(s) %\
    \ 3 == 0 &\n    !is.na(sort(s, decreasing = TRUE)) &\n    !is.na(sort(s, decreasing\
    \ = FALSE)) &\n    !is.na(sort(s, decreasing = TRUE)) &\n    !is.na(sort(s, decreasing\
    \ = FALSE)) &\n    !is.na(sort(s, decreasing = TRUE)) &\n    !is.na(sort(s, decreasing\
    \ = FALSE))\n}\n</cell>\n", "\n  if(length(s<3)||(length(s)>3&&(length(unique(substr(s,1,3))!=length(unique(substr(s,1,3)))))))\
    \ return(FALSE)\n  if(length(unique(sapply(strsplit(s,\"\"),function(x)x)))==length(unique(sapply(strsplit(s,\"\
    \"),function(x)x)))) return(TRUE)\n  return(FALSE)\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks a lot! But it gives FALSE when I run it with \"aabb\".\n\
    <|/ c |>\n<| c |>\nYeah, sorry about that, I didn't test it on my own.\n<|/ c\
    \ |>\n<| c |>\nIf my answer helped please mark it as the solution and give it\
    \ an upvote, thanks!\n<|/ c |>\n<| a dscore=0 |>\nThis works for the example you\
    \ gave:\n<code>\nis_happy <- function(s) {\n  m <- gregexpr(\"(?=(.))\", s)\n\
    \  grepl(\"(.)\\\\1\", substr(s, 1L, match = m[[1]][2]))\n}\n</code>\nBut it is\
    \ easy to make more general by removing the need for substr and match. The following\
    \ is better:\n<code>\nis_happy <- function(s) {\n  m <- gregexpr(\"(?=(.))\",\
    \ s)\n  sapply(m, function(x) grepl(\"(.)\\\\1\", x))\n}\n</code>\n<|/ a tags=string,regex,r\
    \ |>\n<| c |>\nThanks. But it gives FALSE when I run it with \"aabb\".\n<|/ c\
    \ |>\n<| c |>\nIt gives FALSE as you stated in your question. Did you try the\
    \ second one?\n<|/ c |>\n<| c |>\nYes, but this time it doesn't give me TRUE.\n\
    <|/ c |>\n<| c |>\nCan you give an example of a string that doesn't work?\n<|/\
    \ c |>\n<| c |>\nIt gives TRUE for \"aaabbb\". And also \"aaaadb\" gives FALSE.\
    \ I edited my question. Thanks.\n<|/ c |>\n<| a |>\n<code>\n is_happy <- function(s){\n\
    \   s <- gsub(\"[a-z]\", \"\", s)\n   m <- gregexpr(\"(.)\\\\1\", s)\n   sapply(m,\
    \ function(x) grepl(\"(.)\\\\1\", x))\n }\n</code>\n<|/ a dscore=0 tags=string,regex,r\
    \ |>\n<|", "\n    n <- nchar(s)\n    all(3 <= n & nchar(s) >= 3)\n}\n", "\n  if(s\
    \ == '') return(TRUE)\n  if(length(s) == 0) return(TRUE)\n  n <- nchar(s)\n  if(n\
    \ < 3) return(FALSE)\n  for(i in 1:(n-3)) {\n    if(s[i] %in% unique(c(s[i+1],\
    \ s[i+2], s[i+3]))) return(FALSE)\n  }\n  return(TRUE)\n}\n", "\n  s <- gsub(\"\
    \ \", \"\", s)\n  sapply(s, function(x) {\n    length(gregexpr(\"^[a-z]+$\", x))\
    \ == 3 && length(unique(unlist(strsplit(x, \"\"))) == 3\n  })\n}\n\nis_happy(\"\
    aabc\")\nis_happy(\"abbc\")\nis_happy(\"abc\")\nis_happy(\"aa\")\nis_happy(\"\
    aaaa\")\nis_happy(\"aab\")\nis_happy(\"abcde\")\nis_happy(\"aabcde\")\nis_happy(\"\
    aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\n\
    is_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"\
    aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\n\
    is_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"\
    aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\n\
    is_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"\
    aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\n\
    is_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"\
    aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\n\
    is_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"\
    aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\n\
    is_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"\
    aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\n\
    is_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"\
    aabcde\")\nis_happy(\"aabcde\")\nis_happy(\"aabc", "\n  # Complete the function\
    \ body below to solve the problem\n  # Check if s is empty\n  if(!is.na(s)){\n\
    \    # Check if s is of length 2 or less.\n    if(length(s) <= 2){\n      # Check\
    \ if every 3 consecutive letters are distinct\n      all(unique(substr(s,1,3))\
    \ == substr(s,1,3))\n    }\n  }\n}\n", "\n  if(length(s) < 3) {\n    return(FALSE)\n\
    \  }\n  for(i in 1:(length(s) - 1)) {\n    if(!all(s[i:(i + 3)] == s[i:(i + 3)])){\n\
    \      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\nis_happy(\"abcc\")\nis_happy(\"\
    aaa\")\nis_happy(\"aab\")\nis_happy(\"bbc\")\nis_happy(\"abcx\")\nis_happy(\"\
    aaxxx\")\nis_happy(\"axxx\")\nis_happy(\"xaxxx\")\nis_happy(\"xaxxxa\")\nis_happy(\"\
    xaxxxb\")\nis_happy(\"xaxxxc\")\nis_happy(\"xaxxxd\")\nis_happy(\"xaxxxe\")\n\
    is_happy(\"xaxxxf\")\nis_happy(\"xaxxxg\")\nis_happy(\"xaxxxh\")\nis_happy(\"\
    xaxxxi\")\nis_happy(\"xaxxxj\")\nis_happy(\"xaxxxk\")\nis_happy(\"xaxxxl\")\n\
    is_happy(\"xaxxxm\")\nis_happy(\"xaxxxn\")\nis_happy(\"xaxxxo\")\nis_happy(\"\
    xaxxxp\")\nis_happy(\"xaxxxq\")\nis_happy(\"xaxxxr\")\nis_happy(\"xaxxxs\")\n\
    is_happy(\"xaxxxt\")\nis_happy(\"xaxxxu\")\nis_happy(\"xaxxxv\")\nis_happy(\"\
    xaxxxw\")\nis_happy(\"xaxxxx\")\nis_happy(\"xaxxxy\")\nis_happy(\"xaxxxz\")\n\
    is_happy(\"xaxxxx\")\nis_happy(\"xaxxxxx\")\nis_happy(\"xaxxxxxx\")\nis_happy(\"\
    xaxxxxxxx\")\nis_happy(\"xaxxxxxxxx\")\nis_happy(\"xaxxxxxxxxx\")\nis_happy(\"\
    xaxxxxxxxxxx\")\nis_happy(\"xaxxxxxxxxxxx\")\nis_happy(\"xaxxxxxxxxxxxx\")\nis_happy(\"\
    xaxxxxxxxxxxxxx\")\nis_happy(\"xaxxxxxxxxxxxxxx\")\nis_happy(\"xaxxxxxxxxxxxxxxx\"\
    )\nis_happy(\"xaxxxxxxxxxxxxxxxx\")\nis_happy(\"xaxxxxxxxxxxxxxxxxx\")\nis_happy(\"\
    xaxxxxxxxxxxxxxxxxxx\")\nis_happy(\"xaxxxxxxxxxxxxxxxxxxx\")\nis_happy(\"xaxxxxxxxxxxxxx",
  "\n    result <- FALSE\n    count <- 0\n    for(letter in s) {\n        count <-\
    \ count + 1\n        if(count == 3 && letter != s[count - 1]) {\n            result\
    \ <- TRUE\n        }\n    }\n    return(result)\n}\n</cell>\n<text>\nQ4: Create\
    \ a function is_happy_2(string) that accepts one argument string and return a\
    \ boolean indicating if given string can be reduced to a haphazard string.\nFor\
    \ example :\nis_happy_2(abc) should return TRUE.\nis_happy_2(xyz) should return\
    \ FALSE.\n\n</text>\n<cell>", "\n  n <- nchar(s)\n  n %in% c(3, n)\n  any(length(s)\
    \ >= 3 & rep(seq_along(s)%%3, each=3) == rep(seq_along(s), each=3))\n}\nis_happy(\"\
    a\") # FALSE\nis_happy(\"aa\") # FALSE\nis_happy(\"abcd\") # TRUE\nis_happy(\"\
    aabb\") # FALSE\nis_happy(\"adb\") # TRUE\nis_happy(\"xyy\") # FALSE\n</code>\n\
    <|/ a |>\n<| c |>\nNice answer, thanks!  I hadn't thought of using `any` with\
    \ the `%in%` operator to check for repeating patterns.  I'm still new at R, so\
    \ I didn't realize you could use the `%in%` operator for that purpose.\n<|/ c\
    \ |>\n<| a |>\n<code>\nisHappy <- function(s){\n  nchar(s)>=3 & \n  grepl(\"(.).\\\
    \\1\", s) & \n  !grepl(\"(.).\\\\1\", paste0(s,s,s))\n}\n\nisHappy(\"abcde\") ",
  "\n  return(length(s) >= 3 & all(lapply(strsplit(s,\"\"),function(x) length(unique(x)))\
    \ == 3))\n}\n", "\n  s <- unlist(strsplit(s, \"\"))\n  length(s) == 3 & sapply(seq_along(s),\
    \ function(x) all(unique(substr(s, x + 1, x + 3))))\n}\n", "\n  str <- strsplit(s,\
    \ \"\")[[1]]\n  sum(str == \"happy\") == length(str) && \n    all(unique(str)\
    \ == str) & \n    all(diff(lapply(str, length)) == 0)\n}\n", "\n    \n    if(length(s)\
    \ == 0) {\n        return(FALSE)\n    }\n    \n    if(!(all(sapply(s, function(x)\
    \ is.character(x) & nchar(x) == 3)))) {\n        return(FALSE)\n    }\n    \n\
    \    s <- substr(s, 1, nchar(s) - 1)\n    \n    length(unique(s[!duplicated(s)]))\
    \ >= 3\n}\n", "\n  if(length(s) < 3L) return(FALSE)\n  s <- tolower(s)\n  x <-\
    \ rle(s)\n  all(length(x$lengths)>=3L) & all(\n    all(x$values) == c(x$values[1L],\
    \ x$values[2L], x$values[3L]) )\n}\n</cell>\n<text>\n\u0420\u0435\u0448\u0435\u043D\
    \u0438\u0435 \u0434\u0435\u043F\u043B\u043E\u044F \u043C\u0435\u0445\u0430\u043D\
    \u0438\u0437\u043C\u043E\u0432\n\u0420\u0435\u0448\u0435\u043D\u0438\u0435 \u0434\
    \u0435\u043F\u043B\u043E\u044F \u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\
    \u0441\u044F \u043F\u0440\u0430\u0432\u0438\u043B\u043E \u043B\u043E\u0433\u0438\
    \u0441\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0439 \u043C\u043E\u0434\u0435\
    \u043B\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u0438\u0437 \u0440\u0443\
    \u043A\u043E\u043F\u0438\u0441\u043D\u044B\u0445 \u043C\u0430\u0448\u0438\u043D\
    \ \u0438 \u043B\u043E\u0433\u0438\u0441\u0442\u0438\u0447\u0435\u0441\u043A\u043E\
    \u0439 \u043B\u043E\u0433\u0438\u0441\u0442\u0438\u0447\u0435\u0441\u043A\u043E\
    \u0439 \u0440\u0435\u0433\u0440\u0435\u0441\u0441\u0438\u0438 \u0438\u0437 \u043F\
    \u043E\u0434\u043C\u043D\u043E\u0436\u0435\u0441\u0442\u0432\u0435\u043D\u043D\
    \u043E\u0439 \u0434\u043B\u0438\u043D\u044B n (\u043A\u0430\u0436\u0434\u0430\u044F\
    \ \u0433\u043E\u0440\u0430\u0437\u0434\u043E 3 \u043B\u0443\u0447\u0430\u044F\
    \ \u043B\u0438\u043D\u0435\u0439\u043D\u0430\u044F \u0437\u0430\u0432\u0438\u0441\
    \u0438\u043C\u043E\u0441\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u043E\
    \u043D\u0430\u043B\u0430).\n\n\u0412 \u043A\u0430\u0447\u0435\u0441\u0442\u0432\
    \u0435 \u043B\u043E\u0433\u0438\u0441\u0442\u0438\u0447\u0435\u0441\u043A\u043E\
    \u0439 \u0440\u0435\u0433\u0440\u0435\u0441\u0441\u0438\u0438 \u0438\u0437 \u043F\
    \u043E\u0434\u043C\u043D\u043E\u0436\u0435\u0441\u0442\u0432\u0435\u043D\u043D\
    \u043E\u0439 \u0434\u043B\u0438\u043D\u044B n \u043F\u043E\u043B\u044C\u0437\u0443\
    \u0435\u0442\u0441\u044F \u044D\u0442\u043E \u0441\u0430\u043C\u0430\u044F \u043F\
    \u0440\u043E\u0441\u0442\u0430\u044F \u0440\u0435\u0433\u0440\u0435\u0441\u0441\
    \u0438\u044F \u0434\u043B\u044F \u0440\u0430\u0437\u043D\u044B\u0445 \u0438\u0437\
    \u043C\u0435\u0440\u0435\u043D\u0438\u0439 \u0444\u0443\u043D\u043A\u0446\u0438\
    \u0438 f(x) = ax^2 + bx + c.\n\u041F\u0440\u0430\u0432\u0438\u043B\u043E \u043B\
    \u043E\u0433\u0438\u0441\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0439 \u043C\
    \u043E\u0434\u0435\u043B\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u0438\
    \u0437 \u0440\u0443\u043A\u043E\u043F\u0438\u0441\u043D\u044B\u0445 \u043C\u0430\
    \u0448\u0438\u043D \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\
    \u0441\u044F \u0444\u0443\u043D\u043A\u0446\u0438\u044F \u0440\u0430\u0441\u0441\
    \u0447\u0438\u0442\u0430\u043D\u0430 \u0434\u043B\u044F \u0440\u0430\u0437\u043D\
    \u044B\u0445 \u044F\u0434\u0440\u0430.\n\u0414\u043B\u044F \u0440\u0430\u0437\u043D\
    \u044B\u0445 \u044F\u0434\u0440\u0430 \u0431\u0430\u0437\u043E\u0432\u043E\u0439\
    \ \u043C\u043E\u0434\u0435\u043B\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435\
    \ \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F \u0444\
    \u0443\u043D\u043A\u0446\u0438\u044F \u0440", "\n  if (length(s) == 0) return(FALSE)\n\
    \  return(length(s) >= 3 & all((letterDistinct(s[1:3], s[4:6], s[7:9])) == FALSE))\n\
    }\n</cell>\n<cell>", "\n  str <- unlist(strsplit(s, \"\")) # Split the string\
    \ into a vector\n  str_len <- length(str)\n  is_happy <- str_len >= 3 # Return\
    \ TRUE if the string length is greater than or equal to 3\n  is_happy <- is_happy\
    \ & all((str != str[-(1:2)]) & !anyDuplicated(str)) # Check if string contains\
    \ only distinct characters\n  is_happy\n}\n", "\n  s <- gsub(\" \", \"\", s, fixed\
    \ = TRUE)\n  length(s) >= 3 & all(sapply(s, function(x)(x != gsub(\"(\\\\w)(?!\\\
    \\w)\", \"\\\\1\", x))) == TRUE)\n}\n\nis_happy(\"\")\nis_happy(\"abc\")\nis_happy(\"\
    abcd\")\nis_happy(\"abcde\")\nis_happy(\"abcdef\")\nis_happy(\"abcdefg\")\nis_happy(\"\
    abcdefgh\")\nis_happy(\"abcdefghi\")\nis_happy(\"abcdefghij\")\nis_happy(\"abcdefghijk\"\
    )\nis_happy(\"abcdefghijkl\")\nis_happy(\"abcdefghijklm\")\nis_happy(\"abcdefghijklmn\"\
    )\nis_happy(\"abcdefghijklmno\")\nis_happy(\"abcdefghijklmnop\")\nis_happy(\"\
    abcdefghijklmnopq\")\nis_happy(\"abcdefghijklmnopqr\")\nis_happy(\"abcdefghijklmnopqrs\"\
    )\nis_happy(\"abcdefghijklmnopqrsw\")\nis_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"\
    abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\"\
    )\nis_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\")\n\
    is_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"\
    abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\"\
    )\nis_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\")\n\
    is_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"\
    abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\"\
    )\nis_happy(\"abcdefghijklmnopqrswd\")\nis_happy(\"abcdefghijklmnopqrswd\")\n\
    is_happy(\"abcdefghijklmnop", "\n  s <- gsub(\"[[:punct:]]\", \"\", s)\n  \n \
    \ n <- length(s)\n  \n  n >= 3 && all(sapply(seq_along(s), function(i) length(unique((s[(i\
    \ - 1):(i + 1)]))) == 1))\n}\n</cell>\n<cell>", "\n  if(!is.character(s))\n  \
    \  stop(\"is_happy() takes a string as its argument\")\n  s <- gsub(\"\\\\s\"\
    , \"\", s)\n  if(length(s) < 3)\n    stop(\"is_happy() requires a string of at\
    \ least 3 letters\")\n  for(i in 1:(length(s) - 2)) {\n    for(j in (i+1):(length(s)\
    \ - 1)) {\n      if(!is.na(match(s[i], s[j], nomatch = -1)))\n        stop(\"\
    is_happy() requires a string of at least 3 letters\")\n    }\n  }\n  TRUE\n}\n",
  "\n  length(s) >=3 && \n    unique(substr(s,1,3)) %in% c('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    }\n</code>\n<|/ a tags=r dscore=2 |>\n<| c |>\nHi Ronak, how would I go about\
    \ converting this function from base R to dplyr?  I'm getting a lot of errors\
    \ when I try to run it.\n<|/ c |>\n<| c |>\nI got it to work but it took 4 minutes\
    \ to run on my computer versus the 5 minutes it took to type out in R.  I figured\
    \ out that I needed to use mutate instead of mutate_if because I was also trying\
    \ to mutate an additional variable based on whether the string was happy.  Now\
    \ it takes 10 seconds to run.  I really appreciate the help!\n<|/ c |>\n<| c |>\n\
    Great. You should accept this answer by clicking the tick on the left side of\
    \ this answer. Also, please note that Ronak's solution is much much better than\
    \ mine. :)\n<|/ c |>\n<| c |>\nThanks for the help!  I've accepted Ronak's answer\
    \ since he was the first to post it.  I just upvoted your answer since it helped\
    \ me figure out how to do the second part that needed mutating!\n<|/ c |>\n<|\
    \ a dscore=1 tags=r |>\nI wrote an alternate version using dplyr package. I find\
    \ it more straightforward to me than base R but maybe there is some hidden trick\
    \ I don't know about yet?\n<code>\nlibrary(dplyr)\nlibrary(stringr)\n\nis_happy\
    \ <- function(x) {\n  n <- str_count(x, \"\\\\w\")\n  ifelse(n > 3, TRUE, FALSE)\n\
    }\n\nis_happy(\"abcd\")", "\n  all(length(s) >= 3 & \n    apply(s, 1, function(x)\
    \ length(unique(x))) == 3\n  )\n}\n", "\n  require(digest)\n  return(length(s)\
    \ >=3 & digest(s)[[1]] == digest(s)[[1]])\n}\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nWow, that's actually really nice.\n<|/ c |>\n<| a tags=r,string |>\nUsing\
    \ R code (I assume that you are looking for a string that satisfies the condition)\n\
    <code>", "\n  n <- nchar(s)\n  if(n == 0) return(TRUE)\n  else if(n == 1) return(FALSE)\n\
    \  else return(TRUE)\n}\n", "\n    s <- gsub(\"[^[:alpha:]]\", \"\", s)\n    n\
    \ <- length(s)\n    n >= 3 && all(unique(substr(s, 3, n)) %in% unique(substr(s,\
    \ 3, n-1)))\n}\n", "\n  length(ave(str_split(s, nchar(s), simplify = TRUE), \n\
    \              str_split(s, nchar(s), simplify = TRUE) == 1, \n             FUN\
    \ = all))\n}\n\n</cell>\n<cell>", "\n  # Write your code here\n  s <- tolower(s)\n\
    \  return(length(s) >=3 & all(sapply(seq(length=3), function(i) {\n    if (i%3==0)\
    \ return(length(unique(ss[[i]])))==1)\n  })))\n}\n", "\n  sapply(s, length) >=\
    \ 3 && sapply(s, function(x) {\n    unique(unlist(strsplit(x, \"\")))\n  })\n\
    }\nis_happy(paste(sample(c(\"a\", \"b\", \"c\", \"d\"), 10, replace = TRUE), collapse\
    \ = \"\"))", "\n  str <- unlist(strsplit(s, '', fixed=T))\n  if(length(str) <\
    \ 3) return(FALSE)\n  all(duplicated(str)) & !all(str[-3] != str[-4])\n}\n</cell>\n\
    <cell>\nis_happy('abc')\n</cell>\n<cell>\nis_happy('aabb')\n</cell>\n<cell>\n\
    is_happy('aabba')\n</cell>\n<cell>\nis_happy('xyy')\n</cell>\n<cell>\nis_happy('xxx')\n\
    </cell>\n<cell>\nis_happy('aaa')\n</cell>\n<cell>\nis_happy('aaaa')\n</cell>\n\
    <text>\nQ6. Write a function, is_happy2(s). it takes exactly two strings as parameters.\
    \ It should return TRUE if both the strings have the same letters in the same\
    \ order and if they are of the same length. Otherwise it should return FALSE.\n\
    \nWrite your function here\n\n\n</text>\n<cell>", "\n  if(is.null(s))\n    stop(\"\
    No string\")\n  if(length(s) < 3 | sum(s == substr(s,1,3)) > 3)\n    stop(\"Not\
    \ happy-happy\")\n  return(TRUE)\n}\n</cell>\n<cell>\nis_happy(\"abc\")\n</cell>\n\
    <cell>\nis_happy(\"abcd\")\n</cell>\n<cell>\nis_happy(\"adb\")\n</cell>\n<cell>\n\
    is_happy(\"adb\")\n</cell>\n<cell>\nis_happy(\"xyy\")\n</cell>\n<cell>\nis_happy(\"\
    xxxxxxx\")\n</cell>\n<cell>\nis_happy(\"xxxxxxx\")\n</cell>\n<cell>\nis_happy(\"\
    abcdef\")\n</cell>\n<cell>\nis_happy(\"aaabbb\")\n</cell>\n<cell>\nis_happy(\"\
    aaaaaaaaa\")\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaa\")\n</cell>\n<cell>\nis_happy(\"\
    aaaaaaaaaaa\")\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaaaa\")\n</cell>\n<cell>\n\
    is_happy(\"aaaaaaaaaaaaa\")\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaaaaaaaaaa\"\
    )\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaaaaaaaaaaa\")\n</cell>\n<cell>\nis_happy(\"\
    aaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaa\"\
    )\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n<cell>\nis_happy(\"\
    aaaaaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaasdf\"\
    )\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaasdf\")\n</cell>\n<cell>\n\
    is_happy(\"aaaaaaaaaaaaaaaaaaaaaaaasdfasdf\")\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaasdfasdfasdf\"\
    )\n</cell>\n<cell>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaasdfasdfasdfasdf\")\n</cell>\n\
    <cell>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaasdfasdfasdfasdfasdfasdf\")\n</cell>\n\
    <cell>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaasdf", "\n  return(grepl(\"^[a-zA-Z]{3,}$\"\
    , s) & all(sapply(strsplit(s, \"\"), function(i) length(unique(i)) >=3)))\n}\n\
    \nis_happy(\"a\") # FALSE\nis_happy(\"aa\") # FALSE\nis_happy(\"abcd\") # TRUE\n\
    is_happy(\"aabb\") # FALSE\nis_happy(\"adb\") # TRUE\nis_happy(\"xyy\") # FALSE\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\nis_happy <- function(string){\n\
    \    string <- strsplit(string, '')[[1]]\n    i <- 1\n    flag <- FALSE\n    while(i\
    \ <= length(string)) {\n        if (string[i] == string[i-1]) {\n            i\
    \ <- i + 1\n        }else {\n            flag <- flag | !any(string[i:length(string)]\
    \ == string[i])\n            i <- i + 1\n        }\n    }\n    return(flag)\n\
    }\n</code>\n<|/ a tags=r,regex,string |>\n<| a dscore=0 |>\nA solution using base\
    \ R:\n<code>\nis_happy <- function(string){\n    string2 <- unlist(strsplit(string,\
    \ \"\"))\n    string2 <- string2[!string2 %in% string2[-length(string2)]]\n  \
    \  !sum(string2 %in% string2[seq(length(string2))]) == length(string)\n}\n</code>\n\
    <|/ a tags=r,regex,string |>\n<| c |>\nIf it doesnt have to be a regex, then this\
    \ solution seems more elegant.\n<|/ c |>\n<| a |>\nHere's one option using stringr\
    \ package :\n<code>\nlibrary(stringr)\nlibrary(dplyr)\n\nis_happy <- function(string)\
    \ {\n  str_extract(string = string, pattern = \"^[a-zA-Z]{3,}$\") %>%\n    str_count()\
    \ %>%\n    !. == length(string)\n}\n\nis_happy(\"a\") # FALSE\nis_happy(\"aa\"\
    ) # FALSE\nis_happy(\"abcd\") # TRUE\nis_happy(\"aabb\") # FALSE\nis_happy(\"\
    adb\") # TRUE\nis_happy(\"xyy\") # FALSE\n</code>\n<|/ a tags=r,regex,string dscore=0\
    \ |>\n<| a dscore=0 tags=r,regex,string |>\n<code>\nis_happy <- function(string)\
    \ {\n  n <- nchar(tolower(string))\n  for(i in 2:n) {\n    if (tolower(string[-i-1])\
    \ != tolower(string[-i])) {\n      return(FALSE)", "\n  # your code here\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=string,r,regex |>\nAs already pointed out\
    \ in comments, grep is not the most efficient method to do this task, since it\
    \ first has to find all the matches (and thus also all the non-matches). Instead,\
    \ we can use regular expressions to find matches and count the characters in those\
    \ matches:\n<code>\nsapply(strsplit(x, \"\"), function(x) {\n  sum(grepl(\"^[[:alpha:]]{3}$\"\
    , x) & duplicated(x)) > 0\n})\n</code>\nIn words, this splits the string into\
    \ characters, and then counts the number of matches and non-matches (grepl) in\
    \ the string. Finally, it checks whether there are at least 3 characters (length\
    \ >= 3) and that there are at least 3 consecutive characters (grepl matches \"\
    aaa\" but \"aab\" is non-matches) and that the first 3 characters are not repeated.\n\
    <|/ a dscore=0 |>\n<| a tags=string,r,regex dscore=0 |>\nWe can use gregexpr to\
    \ find all the occurences of \"aaa\" and then check whether they occur more than\
    \ twice. \n<code>\nx <- c(\"aabc\", \"aacd\", \"abc\", \"acd\", \"dcd\", \"dca\"\
    , \"dcb\", \"abcd\")\n\ngregexpr(\"aaa\", x)\n     [,1] [,2] [,3] [,4] [,5] [,6]\
    \ [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n[1,]    4    4    1    1    1\
    \    2    2    2    4     4     4     4     4\n[2,]    1    1    1    2    2 \
    \   2    2    2    2     4     4     4     4     4\n[3,]    2    2    2    2 \
    \   2    2    2    2    2     4     4     4     4     4\n[4,]    2    2    2 \
    \   2    2    2    2    2    2     4     4     4     4     4\n[5,]    4    4 \
    \   1    1    1    1    2    2    2    4     4     4     4     4\n[6,]    1  \
    \  1    1    2    2    2    2    2    2     4     4     4     4     4\n</code>\n\
    The values represent the starting positions of the matches. We can use them to\
    \ check if the string satisfies the condition:\n<code>\nsapply(gregexpr(\"aaa\"\
    , x), `[`, 1) > 2\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI believe this can be\
    \ done with str_count and stringr::str_count in ", "\n  # Return TRUE/FALSE depending\
    \ on whether s is happy\n  s <- substr(s,1,3)\n  return(length(unique(s)) >= 3\
    \ & length(unique(s[-3:])) == 1)\n}\n", "\n  if(s == \"\") {\n    stop(\"Empty\
    \ string\")\n  } else\n  if(s == \"\"){\n    stop(\"Empty string\")\n  } else\n\
    \  if(length(s) <3) {\n    stop(\"Not happy\")\n  } else\n  if(!is.null(unique(s)))\
    \ {\n    stop(\"Not happy\")\n  } else {\n    s <- paste(s[-length(s)], s, sep=\"\
    \")\n    if(grepl(\"\\\\S{3}\", s)) {\n      TRUE\n    } else {\n      FALSE\n\
    \    }\n  }\n}\n", "\n  length(s) >= 3 & lapply(strsplit(s, \"\"), function(x)\
    \ length(unique(x))) == 3\n}\n</cell>\n<cell>\nis_happy(\"abcdef\")\n</cell>\n\
    <cell>\nis_happy(\"abcf\")\n</cell>\n<cell>\nis_happy(\"abcdefgg\")\n</cell>\n\
    <cell>\nis_happy(\"abcfgg\")\n</cell>\n<cell>\nis_happy(\"abcfggg\")\n</cell>\n\
    <cell>\nis_happy(\"abcfgggfd\")\n</cell>\n<text>\nWrite a function is_happy2(s)\
    \ that takes string as input and returns the boolean equivalent of is_happy(s).\n\
    You can assume that the string contains at least 3 and at most 20 characters.\n\
    (You can still call is_happy on other strings)\n\n\n</text>\n<cell>", "\n  nchar(s)>=3\
    \ && \n  sapply(1:(nchar(s)-2),function(i) all(sapply(seq_len(i-3),function(j)\
    \ \n  !duplicated(substr(s,i,j)))))\n}\n</code>\n<|/ a tags=r,function |>\n<|\
    \ c |>\nThis is really cool but I think it could be better. I'm not 100% sure\
    \ how this works, but I would have thought that `sapply` would try to return something\
    \ for anything that did not return `TRUE` for the whole `sapply` statement, rather\
    \ than just the last `TRUE`? This would be more efficient as it doesn't have to\
    \ use `substr` each time `duplicated(sapply(seq_len(i-3),function(j) !duplicated(substr(s,i,j))))`\n\
    <|/ c |>\n<| c |>\nYes, you are right. It will return the value of the last `TRUE`\
    \ element. I've changed the code as you suggested.\n<|/ c |>\n<| a |>\nWe can\
    \ use sapply as mentioned in the comments\n<code>\nis_happy <- function(s) sapply(strsplit(s,\
    \ \"[\"), function(x) \n          all(sapply(seq_along(x), function(i) \n    \
    \         all(i != seq_along(x) & !duplicated(substr(x, i, i))))))\n\nis_happy(\"\
    \")", "\n  if (nchar(s) < 3) {\n    return(FALSE)\n  }\n  is_happy_fun <- function(x,\
    \ i) {\n    if (x == x[i]) {\n      if (i == (nchar(x) - 1)) {\n        return(TRUE)\n\
    \      }\n      return(FALSE)\n    }\n    return(FALSE)\n  }\n  is_happy_fun(s[1],\
    \ 1) + is_happy_fun(s[2], 2) + is_happy_fun(s[3], 3) + is_happy_fun(s[4], 4) +\
    \ is_happy_fun(s[5], 5) + is_happy_fun(s[6], 6) + is_happy_fun(s[7], 7) + is_happy_fun(s[8],\
    \ 8) + is_happy_fun(s[9], 9) + is_happy_fun(s[10], 10) + is_happy_fun(s[11], 11)\
    \ + is_happy_fun(s[12], 12)\n}\n</cell>\n<cell>", "\n  length(s)>=3 &&\n  all(length(s)%%3\
    \ ==0) &&\n  !any(duplicated(substr(s, 3, nchar(s))))\n}\n</cell>\n<cell>", "\n\
    \  # Write your code here\n  return(length(s) == 3 & all(sapply(s, function(x)\
    \ !any(duplicated(x))))) \n}\n</cell>\n<cell>\nis_happy(a)\nis_happy(aa)\nis_happy(abcd)\n\
    is_happy(aabb)\nis_happy(adb)\nis_happy(xyy)\n</cell>\n<text>\nExercise 7: Write\
    \ a function that generates all palindrome permutations from the given string.\
    \ For example, for the string abc, the function should generate the following\
    \ permutations.\n\nabc\nbac\ncba\ndbc\nacb\nbac\ncab\nacb\nbca\ncab\naac\nbac\n\
    cab\nbca\ncba\nYou can assume that the input string has at least 1 character.\
    \ For example, the string \"a\" is a valid input but \"ba\" is not because it\
    \ has no unique last letter.\n\n</text>\n<cell>", "\n  nchar(strsplit(s, \"\"\
    )[[1]])>=3 & \n  apply(strsplit(s, \"\")[[1]], 1, function(x) length(unique(x))==3)\n\
    }\n</code>\nIn your question, you mentioned that if length(strsplit(s, \"\")[[1]])\
    \ is greater than 3 then return TRUE else FALSE. So, here I used the strsplit\
    \ function and used that in the lapply function.\n<|/ a tags=r dscore=0 |>\n<|\
    \ c |>\nPlease see my answer, I added a comment on it at the top. You might find\
    \ it interesting.\n<|/ c |>\n<| c |>\nThank you for your help but how would this\
    \ work using lapply\n<|/ c |>\n<| c |>\nPlease see the answer. I have added an\
    \ explanation to the function `is_happy`.\n<|/ c |>\n<| c |>\nI agree with your\
    \ solution with using lapply, and it is also a great solution, thank you for the\
    \ explanation! Would this work with other types of strings i.e. character vectors\
    \ and dataframes?\n<|/ c |>\n<| c |>\nI agree with your solution as well, but\
    \ I would like to use the lapply function with other types of string i.e. character\
    \ vectors and dataframes\n<|/ c |>\n<| a tags=r dscore=0 |>\nWe can use lapply\
    \ here\n<code>\nis_happy <- function(x) {\n   length(x) >= 3 & !is.na(which(length(x)\
    \ == 3)[3])\n }\n\nlapply(strsplit(a, \"\"), is_happy)", "\n  s <- nchar(s)\n\
    \  if(s == 0) FALSE else (s == 1 & unique(substr(s, 1, 3)) %in% c(\"a\", \"e\"\
    , \"i\", \"o\", \"u\") | s == 3 & all(diff(unique(substr(s, nchar(s))))== 0))\n\
    }\n</cell>\n<code language=conda-root-py>", "\n  h <- length(s)\n  if(!(h>=3 &\
    \ sapply(3:(h-1), function(x) sum(grepl(x,s)) > 1)))\n    return(FALSE)\n  return(TRUE)\n\
    }\n\nis_happy(\"apple\")\nis_happy(\"abcdef\")\nis_happy(\"abcdeff\")\nis_happy(\"\
    apple\")\nis_happy(\"aaa\")\nis_happy(\"aaaa\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aaaax\")\nis_happy(\"aaaaa\")\nis_happy(\"aaaaax\")\nis_happy(\"aaaaax\")\nis_happy(\"\
    aaaaaxa\")\nis_happy(\"aaaaaxaa\")\nis_happy(\"aaaaaxaaa\")\nis_happy(\"aaaaaxaaaa\"\
    )\nis_happy(\"aaaaaxaaaaa\")\nis_happy(\"aaaaaxaaaaaa\")\nis_happy(\"aaaaaxaaaaaaa\"\
    )\nis_happy(\"aaaaaxaaaaaaab\")\nis_happy(\"aaaaaxaaaaaaabb\")\nis_happy(\"aaaaaxaaaaaaabbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbb\")\nis_happy(\"\
    aaaaaxaaaaaaabbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbbbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbbbbbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbb\")\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbb\"\
    )\nis_happy(\"aaaaaxaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbb\")\nis_happy", "\n  n\
    \ <- nchar(s)\n  if (n >= 3) {\n    for(i in 1:(n - 3)) {\n      if (unique(substring(s,\
    \ i, i + 3)) != \"\") {\n        return FALSE\n      }\n    }\n  }\n  else return(TRUE)\n\
    }\n", "\n  s <- tolower(s)\n  lengths <- rle(s)$length\n  all(lengths >= 3 & all(lengths[-3:]\
    \ %in% lengths[-3:(lengths - 1)]))\n}\n\n</code>\n<|/ a |>\n<| c |>\n`rle` will\
    \ return the run-length encoding of `s` if it has at least 3 elements. That is\
    \ why I use `rle(s)$length` in the `all` statement.\n<|/ c |>\n<| c |>\nYes, your\
    \ function will work, but I don't think it's worth the extra typing for the next\
    \ guy who has to come along and maintain it :)\n<|/ c |>\n<| c |>\nYou are right\
    \ about maintainability. But since I am not familiar with run-length encoding,\
    \ my function is also easy to understand. Just a note for those who are familiar\
    \ with run-length encoding, you can find the `rle` function by typing `?rle` in\
    \ the console and clicking on the `Examples` link to see its example.\n<|/ c |>\n\
    <| c |>\nYeah, I was just adding that to the comment at the end. :)\n<|/ c |>\n\
    <| a dscore=2 |>\nWith purrr you could do:\n<code>\nis_happy <- function(s) {\n\
    \  s <- tolower(s)\n  lengths <- map(strsplit(s, ''), length)\n  all(lengths >=\
    \ 3 & all(lengths[-3:] %in% lengths[-3:(lengths - 1)]))\n}\n\nis_happy(\"aaaaa\"\
    )", "\n  return(strsplit(s, n = 1L)[[1]][3] != unique(strsplit(s, n = 1L)[[1]][3:4])\
    \ | \n         strsplit(s, n = 1L)[[1]][4] != unique(strsplit(s, n = 1L)[[1]][5:6])\
    \ | \n         strsplit(s, n = 1L)[[1]][6] != unique(strsplit(s, n = 1L)[[1]][7:8]))\n\
    }\n", "\n  length(s) >= 3 && \n    all(length(regexpr(\"\\\\w+$\", s)) == 3L)\
    \ & \n    all(!duplicated(strsplit(s, \"\")[[1]]))\n}\n\nprint(is_happy(\"abcc\"\
    ))\nprint(is_happy(\"aaaa\"))\nprint(is_happy(\"aabb\"))\nprint(is_happy(\"abcd\"\
    ))\nprint(is_happy(\"adb\"))\nprint(is_happy(\"xyy\"))\nprint(is_happy(\"bab\"\
    ))\n", "\n  if(length(s)<3){\n    return(FALSE)\n  }\n  s <- strsplit(s,\"\")[[1]]\n\
    \  lapply(s,function(x){\n    if(length(x) == 3 & !unique(x) == x){\n      return(TRUE)\n\
    \    }\n  })\n}\n\nis_happy(\"\")\nis_happy(\"a\")\nis_happy(\"aa\")\nis_happy(\"\
    abcd\")\nis_happy(\"aabb\")\nis_happy(\"adb\")\nis_happy(\"xyy\")\nis_happy(\"\
    abc\")\nis_happy(\"abcd\")\nis_happy(\"abbc\")\nis_happy(\"abbb\")\nis_happy(\"\
    aaaa\")\nis_happy(\"aaaaa\")\nis_happy(\"abbbbbbb\")\nis_happy(\"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd",
  "\n  if(length(aa)<3){\n    cat(\"FALSE\")\n    return(FALSE)\n  }\n  x<-strsplit(s,\
    \ '')[[1]]\n  x<-paste0(unique(x),collapse = \"\")\n  return(strsplit(x,\"\")[[1]]==\"\
    \")\n}\n", "\n  str_length(s)>=3 &\n  apply(a, 1, function(i) length(unique(i))>=3)\
    \ \n}\n</code>\n<|/ a |>\n<| c |>\nWhile this code might answer the question,\
    \ it lacks some explanation. Please consider adding some explanation to your code\
    \ and especially to what it is doing.\n<|/ c |>\n<| a tags=r |>\n<code>", "\n\
    \  s <- gsub(\"[^a-zA-Z]\", \"\", s) #remove non-letter chars\n  return(length(s)\
    \ >= 3 & all(lapply(\n    c(seq(1, nchar(s), 3), seq(3, nchar(s), -1)), \n   \
    \ function(i1) substr(s, i1, 1, i1) == substr(s, i2, 1, i2))))\n}\n\nis_happy(\"\
    \")", "\n  s <- tolower(s)\n  any(nchar(s) < 3 || (nchar(s) == 3 && (unique(substring(s,\
    \ 3, 5)) != unique(substring(s, 4, 5)))))\n}\n</cell>\n<cell>", "\n  s <- gsub(\"\
    [[:punct:]]\", \"\", s)\n  n <- nchar(s)\n  all(nchar(s) == 3 & n >= 3 & unique(substr(s,\
    \ 1, 3)) %in% c(\"\", \"\"))\n}\n</code>\n<|/ a tags=r,string |>\n<| a |>\nI like\
    \ Jake's solution.  Here is a slightly different approach. \n<code>\ntest <- c(\"\
    abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yza\"\
    )\n\nis_happy <- function(s) {\n    s <- gsub(\"[[:punct:]]\", \"\", s)\n    n\
    \ <- nchar(s)\n    all(nchar(s) == 3 & n >= 3 & unique(substr(s, 1, 3)) %in% c(\"\
    \", \"\"))\n}\n\nis_happy(test)\n</code>\n<|/ a tags=r,string dscore=2 |>\n<|\
    \ a tags=r,string dscore=1 |>\nHere's another solution that seems to work well:\n\
    <code>\nlibrary(stringr)\n\ntest <- c(\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"\
    , \"pqr\", \"stu\", \"vwx\", \"yza\")\n\nis_happy <- function(s) {\n    s <- str_trim(s)\n\
    \    n <- nchar(s)\n    all(nchar(s) == 3 & n >= 3 & unique(substr(s, 1, 3)) %in%\
    \ c(\"\", \"\"))\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere's a solution using\
    \ stringr:\n<code>\nlibrary(stringr)\ntest <- c(\"abc\", \"def\", \"ghi\", \"\
    jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yza\")\nis_happy <- function(s) {\n\
    \  s <- str_trim(s)\n  n <- nchar(s)\n  all(nchar(s) == 3 & n >= 3 & unique(substr(s,\
    \ 1, 3)) %in% c(\"\", \"\"))\n}\nis_happy(test)\n</code>\n<|/ a tags=r,string\
    \ |>\n<| a tags=r,string |>\nHere is another option:\n<code>\nlibrary(stringr)\n\
    test <- c(\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\"\
    , \"yza\")\n\nis_happy <- function(s) {\n    s <- gsub(\"[[:punct:]]\", \"\",\
    \ s)\n    n <- nchar(s)\n    all(nchar(s) == 3 & n >= 3 & unique(substr(s, 1,\
    \ 3)) %in% c(\"\", \"\"))\n}\n\nis_", "\n  s <- toupper(s)\n  n_distinct <- length(unique(s))\n\
    \  n_chars <- length(s)\n  n_hapr <- n_chars >= 3 && n_distinct > 1\n  return(n_hapr)\n\
    }\n", "\n    length(s) / 3 == 3 && \n        !(s %>% strsplit(pattern = \".\"\
    ) %>% unlist() %>% \n            unique() %>% \n            length() != 3)\n}\n\
    </cell>\n<cell>\nis_happy(abcd)\n</cell>\n<cell>\nis_happy(abba)\n</cell>\n<cell>\n\
    is_happy(xyy)\n</cell>\n<text>\nPS 1: If your function works and passes all the\
    \ test cases then you are done.\nPS 2: If you pass all the test cases but it doesn't\
    \ pass the hidden test case, feel free to remove it from the hidden test case\
    \ and rerun to see which test case is failing.\nPS 3: Don't remove any test case\
    \ from the hidden test case.\nPS 4: Hidden test cases won't affect your grade.\n\
    \n\n</text>\n<text>\nQ3: Apply is_happy() to all the strings in the list my_list\
    \ which are not in the list happy_strs. Print the strings which are not happy.\n\
    \n</text>\n<cell>\nmy_list <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nhappy_strs\
    \ <- c(\"a\", \"b\", \"c\")\n</cell>\n<cell>\nmy_list %>% \n    map(is_happy)\n\
    </cell>\n<cell>\nmy_list %>% \n    map_lgl(is_happy)\n</cell>\n<cell>\nmy_list\
    \ %>% \n    map_if(is_happy, is.character)\n</cell>\n<cell>\nmy_list %>% \n  \
    \  map_if(is_happy, is.character) %>% \n    map(is_happy)\n</cell>\n<text>\nQ4:\
    \ Apply is_happy() to all the strings in the list my_list which are not in the\
    \ list happy_strs AND my_string is in the list happy_strs. Print the strings which\
    \ are not happy and my_string is in the list happy_strs.\n\n</text>\n<cell>\n\
    my_list <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nhappy_strs <- c(\"a\", \"b\"\
    , \"c\")\nmy_string <- \"e\"\n</cell>\n<cell>\nmy_list %>% \n    map_lgl(is_happy)\
    \ %>% \n    map_if(is_happy, is.character) %>% \n    map(is_happy) %>% \n    map(function(x)\
    \ {\n        x == my_string && x %in% happy_strs\n    })\n</cell>\n<text>\nQ5:\
    \ Apply is_happy() to all the strings in the list my_list which are not in the\
    \ list happy_strs AND my_string is not in the list hap", "\n  s <- toupper(s)\n\
    \  \n  if(length(s)<3) return(FALSE)\n  \n  unique(substr(s,1,3))==0\n}\n\nis_happy(aa)\
    \ # should return TRUE but returns FALSE\nis_happy(abb) # should return TRUE but\
    \ returns FALSE\nis_happy(adb) # should return TRUE but returns FALSE\nis_happy(xyy)\
    \ # should return TRUE but returns FALSE\n</code>\n<|/ a tags=r,string |>\n<|\
    \ c |>\n`str_detect` is more idiomatic than `grepl`.\n<|/ c |>\n<| c |>\nBut `str_detect`\
    \ doesn't have `ignore.case` option. `grepl` does. But I agree it would be better\
    \ if we add `ignore.case`.\n<|/ c |>\n<| a tags=r,string |>\nThe string package\
    \ has a function called \"str_detect\" which will do this. You just need to convert\
    \ your string to a vector of characters (vectorized) and then feed it into the\
    \ function. For your purposes, you want to use the ignore.case option. You can\
    \ read more about it here:\nhttps://stringr.tidyverse.org/reference/str_detect.html\
    \ \n<code>\nlibrary(stringr)\n\nx <- \"abba\"\nstr_detect(x,\"[a-z]\", ignore.case\
    \ = TRUE)\n</code>\nThis should give you a TRUE or a FALSE, depending on whether\
    \ x contains any lowercase letters or not.\n<|/ a dscore=0 |>\n<| a tags=r,string\
    \ |>\nThe answer by is correct but is missing a character vector. I found it easier\
    \ to do this:\n<code>\nx <- c(\"abba\", \"abc\", \"abba\")\nstringr::str_detect(x,\"\
    [a-z]\", ignore.case = TRUE)\n\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,string\
    \ |>\nA solution using gsub and the fact that strings are case-sensitive:\n<code>\n\
    x <- \"abba\"\n!all(\n    gsub(\"[^a-z]\",\"\",x)==\" \",\n    gsub(\"  \",\"\"\
    ,x)==\"\"\n)\n\n[1]  TRUE  TRUE FALSE\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,string\
    \ |>\n<code>\nstringr::str_detect(\"abba\", \"[a-z]\", ignore.case = TRUE)", "\n\
    \  if(length(s) >= 3 && all(sapply(s, function(x) !(x[1] == x[1]+x[1]+x[1]))))\n\
    \    TRUE\n  else\n    FALSE\n}\n", "\n  \n  is_happy <- function(s) {\n    \n\
    \    if(length(s) < 3) {\n      return(FALSE)\n    }\n    \n    for(i in 1:(length(s)\
    \ - 1)) {\n      if(s[i] != s[i+1]) {\n        return(FALSE)\n      }\n    }\n\
    \    \n    for(i in 2:(length(s) - 1)) {\n      if(s[i] != s[i-1]) {\n       \
    \ return(FALSE)\n      }\n    }\n    \n    return(TRUE)\n  }\n  \n  is_happy(s)\n\
    }\n</cell>\n<cell>", "\n  s <- gsub(\"[^A-Za-z]\", \"\", s)\n  n <- nchar(s) #\
    \ get length of string\n  all(length(n) >= 3) # make sure length is at least 3\n\
    \  all(sapply(seq_len(n), function(x) all(!unique(substr(s, x, x+3))))) # make\
    \ sure all 3 consecutive letters are distinct\n}\n\nis_happy(\"xyy\")\nis_happy(\"\
    abc\")\nis_happy(\"bcd\")\nis_happy(\"abab\")\nis_happy(\"acb\")\nis_happy(\"\
    abbc\")\nis_happy(\"a\")\nis_happy(\"aa\")\nis_happy(\"aaa\")\nis_happy(\"aaaa\"\
    )\nis_happy(\"aaab\")\nis_happy(\"aaaab\")\nis_happy(\"aaaabb\")\nis_happy(\"\
    aaaaa\")\n</code>\n<|/ a dscore=1 tags=r,regex,stringr,string |>\n<| c |>\nThank\
    \ you for the answer. Unfortunately the example you provided in your code is also\
    \ not correct.\n<|/ c |>\n<| c |>\nThanks, I fixed my answer.\n<|/ c |>\n<| a\
    \ tags=r,regex,stringr,string |>\nThis should work\n<code>\nlibrary(stringr)\n\
    \nis_happy <- function(s){\n  s <- str_split(s, \"\")[[1]]\n  n <- nchar(s) #get\
    \ length of string\n  all(length(n) >= 3) #make sure length is at least 3\n  all(sapply(seq_len(n),\
    \ function(x) all(!unique(substr(s, x, x+3))))) #make sure all 3 consecutive letters\
    \ are distinct\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for the answer.\
    \ Unfortunately the example you provided in your code is also not correct.\n<|/\
    \ c |>\n<| c |>\nWhat is \"not correct\" ?\n<|/ c |>\n<| c |>\nI wrote a test\
    \ case in my question where it should be\nFALSE\nFALSE\nFALSE\nTRUE\nTRUE\nTRUE\n\
    <|/ c |>\n<| a dscore=0 |>\nI wrote a solution in R:\n<code>", "\n  l <- nchar(s);\n\
    \  all(l >= 3 & l %% 3 == 0)\n}\n</cell>\n<cell>\nis_happy(a)\n</cell>\n<cell>\n\
    is_happy(aa)\n</cell>\n<cell>\nis_happy(abcd)\n</cell>\n<cell>\nis_happy(aabb)\n\
    </cell>\n<cell>\nis_happy(adb)\n</cell>\n<cell>\nis_happy(xyy)\n</cell>\n<text>\n\
    Task\nYour task is to count the characters in a string\nThe function should only\
    \ count the characters that are present in string without counting any extra characters\n\
    \n\n</text>\n<cell>", "\n  # Write your code here\n  s <- strsplit(s,\"\")[[1]]\n\
    \  length(s)>=3 && all(sapply(s, unique)==ss)\n}\nis_happy(paste0(sample(letters,\
    \ 1, TRUE), sample(letters, 1, TRUE), sample(letters, 1, TRUE), sample(letters,\
    \ 1, TRUE)))\n</cell>\n<cell>", "\n  str_length <- strlen(s)\n  n_letra <- str_length(s)\
    \ \n  \n  # We check the first three characters\n  return(\n    str_length(s)\
    \ >= 3 &&\n    n_letra >= 3\n  )\n}\n\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\n\
    is_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_happy('aaaa')\nis_",
  "\n  s <- tolower(s)\n  sapply(s, FUN=function(x) length(unique(x)) == length(x))\n\
    }\n", "\n  if(length(s<3 || length(unique(sapply(strsplit(s,\"\"),function(x){unlist(strsplit(x,\"\
    \"))}))!=3)) {\n    false\n  }else {\n    true\n  }\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nVery nice solution! `data.table` has a function called `rleid` which should\
    \ speed it up a bit.\n<|/ c |>\n<| c |>\nThanks for your suggestion. Will update\
    \ my solution accordingly.\n<|/ c |>\n<| c |>\n, `rleid` will do the job and it's\
    \ faster than `rle`, but you still have to convert the result to logical using\
    \ `any`. `rleid` returns a vector of type `integer` so you still need to convert\
    \ the result to logical.\n<|/ c |>\n<| c |>\nthanks for reminding me of this function!\
    \ I updated the function accordingly.\n<|/ c |>\n<| c |>\n`rleid` does not work\
    \ for `runif(1L, 6L, 1e6)` but it does for `runif(1e6)` so it's not really a solution\n\
    <|/ c |>\n<| a dscore=5 tags=r,string |>\nHere's another approach with base R:\n\
    <code>\nis_happy <- function(s) length(nchar(s) > 3) & anyDuplicated(sapply(s,\
    \ nchar) > 0)\n</code>\nOr alternatively with stringr:\n<code>\nlibrary(stringr)\n\
    is_happy <- function(s) length(nchar(s) > 3) & anyDuplicated(str_replace_all(s,\
    \ \"(?<=.)(?=.)\", \"\"))\n</code>\nIt should be faster than other solutions posted\
    \ here, but might not be the fastest solution for very long strings. Also the\
    \ solution from is quite elegant.\n<|/ a |>\n<| a dscore=5 |>\nThis seems to work:\n\
    <code>\nlibrary(data.table)\nstringr::strsplit(c(\"abc\",\"abc\",\"abc\",\"def\"\
    ,\"def\",\"def\"),\"\",perl=TRUE)\n[[1]]\n[1] \"abc\" \"abc\" \"abc\"\n\n[[2]]\n\
    [1] \"def\" \"def\" \"def\"\n\nis.happy<-function(x){\n  x<-x[!duplicated(paste(x))]\n\
    \  !length(x)\n}\n\nis.happy(stringr::strsplit(c(\"abc\",\"abc\",\"abc\",\"def\"\
    ,\"def\",\"def\"),\"\",perl=TRUE))\n[1] FALSE  TRUE  TRUE  TRUE  TRUE\n\nis.happy(stringr::strsplit(c(\"\
    abc\",\"abc\",\"abc\",\"def\",\"def\",\"def\"),", "\n    s <- str_replace_all(\"\
    ([a-z])\\\\1{2,}\", \"\\\\1\", s)\n    sum(strsplit(s, \"(?<=[a-z])\\\\1\", perl\
    \ = TRUE)) == 3\n}\n", "\n  s <- tolower(s)\n  length(s)>=3 & \n  Reduce(`&`,\
    \ lapply(strsplit(s, \"\"), function(x) length(x) >=3 & !any(duplicated(x))))\n\
    }\n</cell>\n<cell>\nis_happy(paste(sample(c(\"a\", \"z\", \"A\", \"Z\"), 1000,\
    \ replace = T)))\n</cell>\n<cell>\nis_happy(paste(sample(c(\"a\", \"z\", \"A\"\
    , \"Z\", \"xyy\", \"adb\"), 1000, replace = T)))\n</cell>\n<text>\n13. Extract\
    \ digits from string\nWrite a function that extracts digits from a string.\nThe\
    \ function should return a list of integers (representing the digits extracted\
    \ from the string).\nThe function should ignore non-digits in the string.\nThe\
    \ digits can be in any order.\nExamples:\n\nExtracting digits from abc123def should\
    \ return [1,2,3]. \nExtracting digits from a1b2c3d should return [1,2]. \nExtracting\
    \ digits from 123a1b2c3 should return [1,2,3]. \nExtracting digits from 123 should\
    \ return [].\n\n</text>\n<cell>", "\n  length(aa(s) == 3 & aad(aa(s)) == 3 & aaa(aa(s))\
    \ == 3) &\n    !is.na(unique(unlist(lapply(aa(s), function(x) {\n      aaa(aa(a)(x))\n\
    \    }))))\n}\nis_happy(\"adbb\")", "\n  # your code here\n  \n}\n", "\n  nchar(s)\
    \ / 3 >= 3 &&\n  length(unique(substr(s, 3, nchar(s) - 3))) == 3\n}\n</code>\n\
    <|/ a dscore=2 tags=r |>\n<| c |>\nA very compact but inefficient approach to\
    \ count the three unique characters. +1\n<|/ c |>\n<| a dscore=1 |>\nAnother solution\
    \ to find out is to use this approach\n<code>\nlibrary(stringr)", "\n    length(s)\
    \ >= 3 && s %>%\n        str_subset(\"^(.)\\\\1{2,3}$\") %>%\n        length()\
    \ == 0\n}\n</cell>\n<text>\nAs a rule, you should always aim for a solution that\
    \ is easy to read, easy to understand, easy to modify, and easy to test.\nOf course,\
    \ sometimes you just have no other choice but to code up a solution and then test\
    \ it and debug it. \nAsking other people to read your code is a good way to get\
    \ a bad feel for how your code works.\n\nLet's start with a short example to see\
    \ how it works:\n\n\n</text>\n<cell>\nx <- c(\"a\", \"bb\", \"c\")\n\nx %>% str_subset(\"\
    ^(.)\\\\1{2,3}$\")\n</cell>\n<text>\nWe use regular expressions to select only\
    \ those strings that are at least 3 characters long, and that are made up of letters\
    \ followed by only 2 of the same letters.\nThe pattern \"^(.)\\\\1{2,3}$\" means,\
    \ match the first letter followed by exactly 2 of the same letters, and then match\
    \ the last letter of the string. \nThe parentheses capture the part of the string\
    \ that matches the regular expression, while \\\\1 references the substring captured\
    \ by the first set of parentheses.\nThe {2,3} part means that the previous part\
    \ must appear at least twice, and at most three times.\nTherefore, all strings\
    \ that satisfy this pattern are selected.\n\nLet's try it on a string:\n\n\n</text>\n\
    <cell>\nx <- \"abcdef\"\n\nx %>% str_subset(\"^(.)\\\\1{2,3}$\")\n</cell>\n<text>\n\
    We get a \"success\" outcome, which indicates that the string satisfies the pattern.\n\
    \nNow, let's try to make it work on the letters of the alphabet:\n\n\n</text>\n\
    <cell>\nx <- \"abcdef\"\n\nx %>% str_subset(\"^(.)\\\\1{2,3}$\")\n</cell>\n<text>\n\
    We get an empty character vector, which means it didn't work. \nWe can fix this\
    \ by using a capital \\\\w, which means \"match a letter\".\n\nLet's try it on\
    \ the alphabet:\n\n\n</text>\n<cell>\nx <- \"abcdef\"\n\nx %>% str_subset(\"^(.)\\\
    \\1{2,3}$\")\n</cell>\n<text>\nAgain, we get an empty character vector, which\
    \ means it didn't work.\n\nNow let's try a string:\n\n\n</text>\n<cell>\nx <-\
    \ \"abcdef\"\n\nx %>% str_subset(\"^(.)\\\\1{2,3}$\")\n</cell>\n<text>\nWe get\
    \ \"Success\" as output! And that's the whole idea of this code", "\n  strlen\
    \ <- nchar(s);\n  length(s) >= 3 &&\n    substr(s, 1, 3) == substr(s, 4, strlen)\
    \ &&\n    length(unique(substr(s, 1, 3))) >= 3;\n}\n", "\n  len <- nchar(s)\n\
    \  ifelse(len >= 3, \n         sapply(seq_len(len - 3), \n                function(i)\
    \ \n                   length(unique(subset(s, \n                            \
    \                 ((i - 1) :i) == s[i]))) == 3), \n         FALSE)\n}\n</code>\n\
    Output\n<code>\n> is_happy(abc)\n[1] FALSE\n\n> is_happy(abcb)\n[1] FALSE\n\n\
    > is_happy(abc)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n[1] TRUE\n\n> is_happy(abcb)\n\
    [1] TRUE\n\n> is_", "\n  n <- nchar(s)\n  n <- n[n != 0]\n  if (n >= 3) {\n  \
    \  c <- c(1, 1, 1)\n    n <- n - 1\n    while (n > 3) {\n      c[c[2]] <- 0\n\
    \      n <- n - 3\n    }\n    if (all(c != 1)) {\n      return(TRUE)\n    }\n\
    \  }\n  return(FALSE)\n}\n</cell>\n<cell>", "\n  l <- nchar(s)\n  return(l >=\
    \ 3 && !duplicated(substr(s, 3, 3))) # I suppose we can check duplicates with\
    \ substring\n}\n\nis_happy('aaabbb')\nis_happy('aaa')\nis_happy('a')\nis_happy('aaaabbb')\n\
    is_happy(NULL)\nis_happy('')\n", "\n    l <- nchar(s);\n    if (l < 3) return(FALSE);\n\
    \    for(i in 1:l) {\n        if (!all(s[i:(i + 3)] == s[i:(i + 3)])) {\n    \
    \        return(FALSE);\n        }\n    }\n    return(TRUE);\n}\n", "\n  if(length(s)\
    \ < 3) {\n    return(FALSE)\n  }\n  \n  repeat {\n    if(length(unique(substr(s,\
    \ nchar(s)-3, nchar(s)-1))) < 3) {\n      return(TRUE)\n    }\n  }\n  \n  return(FALSE)\n\
    }\n", "\n    s <- as.character(s)\n    length(s) >= 3 &&\n        length(unique(substr(s,\
    \ 1, 3))) == 3 &&\n        all(unique(sapply(seq(1, length(s), by = 3), function(i)\
    \ substr(s, i, i)) == substr(s, i+1, i+1)))\n}\n\nis_happy(\"abcde\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aaxx\")\nis_happy(\"aaaaa\")\nis_happy(\"\
    aa\")\nis_happy(\"aax\")\nis_happy(\"aax", "\n  l <- strsplit(s, \"(?<=.)(?=.)\"\
    , perl = T)\n  length(l) >= 3 && all( lapply(l, function(x) x != l[[length(x)]])\
    \ ) \n}\n</cell>\n<cell>", "\n  if(!is.character(s)) {\n    stop(\"The parameter\
    \ should be a string\")\n  }\n  if(!grepl(\"^[a-z]+$\", s)) {\n    stop(\"The\
    \ parameter should only contain lowercase and uppercase letters\")\n  }\n  if(strLen(s)\
    \ < 3) {\n    stop(\"The parameter should be at least 3 characters long\")\n \
    \ }\n  y <- strsplit(s, \"\")\n  xs <- unlist(y[3:length(s)])\n  all(xs %in% y[[1]])\n\
    }\n", "\n    str_length(s) < 3 || (str_length(s) == 3 && (duplicated(strsplit(s,\
    \ \"\")[[1]])))\n}\n</cell>\n<code language=conda-root-py>", "\n  length(s) >=\
    \ 3 && \n    all(sapply(\n      gregexpr('\\\\d', \n          paste(rep(letters[1:3],\
    \ each=3), collapse='')),  \n      function(x) length(x) == 3) & \n    !duplicated(unlist(strsplit(s,\
    \ ''))))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nGreat solution. Can you explain\
    \ the `gregexpr` part? I understand the regex but not the gregexpr. Thanks!\n\
    <|/ c |>\n<| c |>\nOkay I understand the regex part. `gregexpr('\\\\d', \n   \
    \   paste(rep(letters[1:3], each=3), collapse=''))`\n<|/ c |>\n<| c |>\nYes, I\
    \ understand how to use gregexpr now. But I am still confused about `!duplicated(unlist(strsplit(s,\
    \ '')))`. Can you explain that part? Thanks!\n<|/ c |>\n<| c |>\n: In R `!duplicated`\
    \ returns true only if there are no duplicates. `!duplicated(unlist(strsplit(s,\
    \ '')))` returns true if there are duplicates (i.e. the same letter) in the same\
    \ location in the string. Basically it checks whether all letters in the string\
    \ are different.\n<|/ c |>\n<| a tags=r dscore=1 |>\nYou can do it by splitting\
    \ the string into its characters and then checking if they are all distinct:\n\
    <code>\nstr1 <- c('a', 'aa', 'abc', 'abcd', 'adb', 'xyy')\nsapply(str1, function(x)\
    \ length(unique(x)) == 1)", "\n  if(s == \"\")\n    return(FALSE)\n  if(length(s)\
    \ < 3)\n    return(FALSE)\n  for(i in 1:(length(s) - 2)){\n    if(s[i] != s[i+1]){\n\
    \      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
