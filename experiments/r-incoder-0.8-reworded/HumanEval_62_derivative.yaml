name: HumanEval_62_derivative
language: r
prompt: "# xs represent coefficients of a polynomial.\n# xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n# Return derivative of this polynomial in the same form.\n# >>>\
  \ derivative(c(3, 1, 2, 4, 5))\n# c(1, 4, 12, 20)\n# >>> derivative(c(1, 2, 3))\n\
  # c(2, 6)\nderivative <- function(xs) {"
tests: "test_humaneval <- function() {\ncandidate <- derivative\n    if(!identical(candidate(c(3,\
  \ 1, 2, 4, 5)), c(1, 4, 12, 20))){quit('no', 1)}\n    if(!identical(candidate(c(1,\
  \ 2, 3)), c(2, 6))){quit('no', 1)}\n    if(!identical(candidate(c(3, 2, 1)), c(2,\
  \ 2))){quit('no', 1)}\n    if(!identical(candidate(c(3, 2, 1, 0, 4)), c(2, 2, 0,\
  \ 16))){quit('no', 1)}\n    if(!identical(candidate(c(1)), c())){quit('no', 1)}\n\
  }\ntest_humaneval()"
completions: ["\n  n <- length(xs)\n  if(n < 2) return(xs)\n  \n  x <- xs[1]\n  xs[n-1]\
    \ <- xs[n-1] * x\n  return(c(xs[n-2] + xs[n-3] * x, xs[-1]))\n}\n", "\n  if (length(xs)\
    \ != 2) {\n    stop(\"This function can only differentiate polynomials of degree\
    \ 2\")\n  }\n  xs[1] - xs[2] * xs[1]\n}\n", "\n  # Convert xs list to a vector\
    \ in R\n  xs <- as.vector(xs)\n\n  # Define the derivative function\n  derivative\
    \ <- function(x) c(rep(NA_real_, length(xs)), -xs[-1])\n\n  # Apply function to\
    \ all elements in a vector\n  derivative <- Vectorize(derivative)(xs)\n\n  # Return\
    \ derivative vector\n  return(derivative)\n}\n", "\n  if (length(xs) %% 2 == 1)\
    \ {\n    stop(\"Derivatives of length N must be even.\")\n  }\n  xs <- c(xs[1],\
    \ xs[-1])\n  y <- 1\n  for(i in 2:(length(xs) - 1L)) {\n    y <- y * xs[i] - xs[i\
    \ - 1] * y\n  }\n  y\n}\n", "\n  x <- xs[1]\n  xs[1] <- xs[2]\n  xs[2] <- xs[3]\n\
    \  xs[3] <- x\n  return(c(1))\n}\n</cell>\n<cell>\nderivative(c(3, 4, 7))\n</cell>\n\
    <cell>", "\n  # derivative is sum of derivatives of individual coefficients\n\
    \  # so here we find out what they are and add them up\n  # then multiply them\
    \ by their power to get derivatives\n  # of individual coefficients\n  z <- c()\n\
    \  for(i in 0:length(xs) - 1){\n    z[i] <- xs[i] + (xs[i + 1] * xs[i]) + (xs[i\
    \ + 2] * xs[i] * xs[i]) + (xs[i + 3] * xs[i] * xs[i] * xs[i])\n  }\n  return(z)\n\
    }\n", "\n  stopifnot(length(xs) == length(xs[1]))\n  stopifnot(all(xs <= 0, na.rm=T))\n\
    \  d <- function(x) {\n    # Return d^k of this polynomial (d^k is the derivative\
    \ of this polynomial\n    # in the form of c(1, x, x^2, x^3, ...))\n    if (length(xs)\
    \ == 1) {\n      return(c(1, x))\n    }\n    if (length(xs) == 2) {\n      return(c(1,\
    \ x, x^2))\n    }\n    if (length(xs) == 3) {\n      return(c(1, x, x^2, x^3))\n\
    \    }\n    if (length(xs) == 4) {\n      return(c(1, x, x^2, x^3, x^4))\n   \
    \ }\n    if (length(xs) == 5) {\n      return(c(1, x, x^2, x^3, x^4, x^5))\n \
    \   }\n    stop(\"Too many terms\")\n  }\n  return(list(d1=d[1], d2=d[2], d3=d[3],\
    \ d4=d[4], d5=d[5]))\n}\n</cell>\n<code language=conda-root-py>", "\n  return(\
    \ c(xs[1], diff(xs[1])*xs[2], diff(xs[1])*xs[2]^2, diff(xs[1])*xs[2]^3, diff(xs[1])*xs[2]^4,\
    \ diff(xs[1])*xs[2]^5))\n}\n", "\n  stopifnot(length(xs) == length(xs$coef))\n\
    \  xs <- as.list(xs)\n  length(xs)\n  xs <- xs[-1]\n  r <- rep(coef(xs), length(xs)-1)\n\
    \  names(r) <- names(xs)\n  r\n}\n", "\n    x <- head(xs, 1)\n    head(xs, length(xs))\
    \ %>% \n        sapply(function(z) z * (x - z) * xs) %>% \n        sum\n}\n</code>\n\
    <|/ a tags=r,polynomials,algebra,linear-algebra |>\n<| c |>\nIt's been a long\
    \ time since I posted this, but I thought I should give credit to this since I\
    \ learned about this in the last year and then came back to this and learned about\
    \ it. Thanks!\n<|/ c |>\n<| c |>\nI thought this was just an excercise for understanding\
    \ how R works. Thanks for coming back and sharing this solution, helped me out.\
    \ I've used this in other contexts :)\n<|/ c |>\n<| a |>\nI have developed a general\
    \ function for finding a polynomial with the given degree by using the sympy package\
    \ to symbolically represent the polynomial and using R\u2019s solve.\n<code>",
  "\n  # Reverse the list so it's like c(1,2,3,...)\n  # then use the linear regression\
    \ to find the slope and y-intercept\n  xs <- rev(xs)\n  xs <- c(0,xs)\n  xs <-\
    \ xs[-1]\n  fit <- lm(x ~ poly(x, xs))\n  ys <- fit$coefficients[,1] + fit$coefficients[,2]*x\
    \ + fit$coefficients[,3]*x*x + fit$coefficients[,4]*x*x*x + fit$coefficients[,5]*x*x*x*x\n\
    \  ys <- c(ys, 0)\n  return(c(xs, ys))\n}\n", "\n  y <- rep(NA, length(xs))\n\
    \  y[1] <- xs[1]\n  y[2] <- (xs[1] * xs[2]) / (xs[1] * xs[1] + xs[2] * xs[2])\n\
    \  for(i in 3:length(xs)) {\n    y[i] <- (xs[i] * y[i-2] - (xs[i-1] * y[i-1]))\
    \ / (xs[i-1] * xs[i-1] + xs[i] * xs[i])\n  }\n  y\n}\n", "\n  x <- xs[1]\n  return(list(xs[1]\
    \ * x, c(xs[2], x[1]*x)))\n}\n</code>\n<|/ a |>\n<| c |>\nThis seems very helpful.\
    \ I'm not sure if I'm understanding what the output is, but I've run the function\
    \ and I get a list with two items: 1 and c(1, 4). How would I go about extracting\
    \ the 1? Also, how do I run this on a list of any length? Do I need to put an\
    \ if statement inside the first function? Thanks for your help!\n<|/ c |>\n<|\
    \ c |>\nThe first function returns an object of type `list`. The first element\
    \ of this list has two components: 1) `1`, 2) the polynomial `c(1, 4)`. The second\
    \ element of the list has two components: 1) `2`, 2) the polynomial `c(2, 6)`.\
    \ The example I gave was with two polynomials, just to show the structure of the\
    \ result. The length of the list can be greater than two, but this example was\
    \ for two polynomials. You would have to put an `if` statement inside the first\
    \ function.\n<|/ c |>\n<| c |>\nSo I should put an if statement inside the function\
    \ and get the second element of the list after I run it? It should work then?\
    \ When I run it on a list with a length of greater than 2 it tells me that my\
    \ object has 2 dimensions but has 1 element.\n<|/ c |>\n<| c |>\nI added an example\
    \ of one function that would work with any number of polynomials.\n<|/ c |>\n\
    <| c |>\nAh, okay. Thank you!\n<|/ c |>\n<| a |>\n<code>", "\n  if(xs[1] == 0)\
    \ return(xs)\n  d <- c(xs[2], xs[1] * (xs[2] - 1))\n  return(d)\n}\n</cell>\n\
    <cell>", "\n  # If xs length is 1 then return zero\n  if (length(xs) == 1) {\n\
    \    zero(as.integer(xs))\n  } else if (length(xs) == 0) {\n    zero(as.integer(xs))\n\
    \  } else {\n    # Find number of coefficients in xs minus one\n    n = length(xs)\
    \ - 1\n    # Compute coefficients\n    coefficients = c(xs, xs[n])\n    # Return\
    \ polynomial derivative\n    as.vector(c(coefficients, diff(c(coefficients, xs))))\n\
    \  }\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nI wanted to find a solution that\
    \ works on vectors of different lengths and found this question and all the answers\
    \ very helpful. I am posting my solution here, it might be helpful for someone.\n\
    <code>", "\n  if (length(xs) == 1) \n    NULL\n  else \n    xs[1] / (xs[2] - xs[1])\n\
    }\n", "\n  n <- length(xs)\n  deriv <- vector(mode = \"numeric\", length = n +\
    \ 1)\n  deriv[1] <- 1\n  for (i in 2:n) {\n    deriv[i] <- deriv[i - 1] * xs[i\
    \ - 1]\n  }\n  deriv\n}\n", "\n  x1 <- head(xs, -1)\n  x2 <- tail(xs, -1)\n  y\
    \ <- x1 * x2 - x1\n  return(list(x = x1, y = y))\n}\n", "\n  # Return derivative\
    \ of polynomial in same form.\n  # >>> derivative(c(1, 2, 3))\n  # c(2, 6)\n \
    \ xs[1]\n}\n</code>\n<|/ a tags=function,list,polynomials,r dscore=2 |>\n<| a\
    \ |>\nI realized a very simple solution:\n<code>\npolynomial = function(x) {\n\
    \  # xs represents the coefficients of a polynomial.\n  # xs[0] + xs[1] * x +\
    \ xs[2] * x^2 + ....\n  # Return derivative of this polynomial in the same form.\n\
    \  # >>> derivative(c(1, 2, 3))\n  # c(2, 6)\n  return(x[1])\n}\n\nderivative\
    \ = function(xs) {\n  # Return derivative of polynomial in same form.\n  # >>>\
    \ derivative(c(1, 2, 3))\n  # c(2, 6)\n  return(polynomial(xs))\n}\n</code>\n\
    <|/ a dscore=1 tags=function,list,polynomials,r |>\n<| a tags=function,list,polynomials,r\
    \ |>\nA more compact solution is to use Reduce function\n<code>\npolynomial =\
    \ Reduce(function(x, y) x*y, c(1:3, xs=1:3), init=1)\n\nderivative = Reduce(function(x,\
    \ y) x*y, c(1:3, xs=4:6), init=1)\n</code>\n<|/ a dscore=1 |>\n<| a tags=function,list,polynomials,r\
    \ |>\nThis should do the trick:\n<code>\npolynomial = function(x) {\n  # xs represents\
    \ the coefficients of a polynomial.\n  # xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\
    \  # Return derivative of this polynomial in the same form.\n  # >>> derivative(c(1,\
    \ 2, 3))\n  # c(2, 6)\n  return(sum(do.call(\"*\", expand.grid(x, x)))) # This\
    \ part is your function\n}\n\nderivative = function(xs) {\n  # Return derivative\
    \ of polynomial in same form.\n  # >>> derivative(c(1, 2, 3))\n  # c(2, 6)\n \
    \ return(polynomial(xs))\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks! I understand\
    \ why this doesn't work, but I haven't been able to figure out how to fix it.\n\
    <|/ c |>\n<| a tags=function,list,polynomials,r dscore=0 |>\n<code>\npolynomial\
    \ = function(x) {\n  # xs represents the coefficients of a polynomial.\n  # xs[0]\
    \ + xs[1] * x + xs[2] * x^2 + ....\n  # Return derivative of this polynomial in\
    \ the same form.\n  # >>> derivative(c(1, 2, 3))\n  # c(2, 6)\n  return(x[1])\n\
    }\n\nderivative = function(xs) {\n  # Return derivative of polynomial in same\
    \ form.\n  # >>> derivative(c(1, 2, 3))\n  # c(2, ", "\n    m <- length(xs)\n\
    \    ds <- rep(NA,m)\n    ds[1] <- xs[1]\n    ds[2:m] <- rep(NA,m-1) * c(xs[2],\
    \ xs[1] * xs[2:m])\n    as.vector(ds)\n}\n", "\n    # xs represents coefficients\
    \ of a polynomial.\n    # xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    # Return\
    \ derivative of this polynomial in the same form.\n    # >>> derivative(c(3, 1,\
    \ 2, 4, 5))\n    # c(1, 4, 12, 20)\n    # >>> derivative(c(1, 2, 3))\n    # c(2,\
    \ 6)\n    m <- length(xs)\n    i <- m\n    s <- 0\n    while(i != 0) {\n     \
    \   s <- s + xs[i - 1]\n        i <- i-1\n    }\n    return(1 - s)\n}\n", "\n\
    \  xs <- tail(xs)\n  x <- head(xs)\n  x1 <- x * x\n  c(x1, 2 * x, 3 * x1)\n}\n\
    </cell>\n<cell>\nderivative(c(1, 2, 3))\n</cell>\n<cell>\nderivative(c(3, 1, 2,\
    \ 4, 5))\n</cell>\n<text>\nLet's define a function that takes a vector of length\
    \ 3 as input and outputs a vector of length 2:\n\n$$\n\\begin{align}\nx(\\vec{x})\
    \ = \n\\begin{bmatrix}\nx{1}(x{0}) \\\nx{2}(x{1})\n\\end{bmatrix}\n\\\n\\vec{y}\
    \ = \n\\begin{bmatrix}\ny_1\\\ny_2\n\\end{bmatrix}\n\\end{align}\n$$\n\n</text>\n\
    <cell>\nmy_function <- function(x) {\n  x0 <- x[2]\n  x1 <- x[1] * x0\n  c(x0,\
    \ x1)\n}\n</cell>\n<cell>\nmy_function(c(1, 2, 3))\n</cell>\n<text>\nExercise:\
    \ Create a function named my_function2 that takes the same vector of length 3\
    \ as input and outputs a vector of length 3:\n\n$$\n\\begin{align}\nx(\\vec{x})\
    \ = \n\\begin{bmatrix}\nx{1}(x{0}) \\\nx{2}(x{1})\n\\end{bmatrix}\n\\\n\\vec{y}\
    \ = \n\\begin{bmatrix}\ny_1\\\ny_2\n\\end{bmatrix}\n\\end{align}\n$$\n\n</text>\n\
    <cell>", "\n  x1 <- xs[1]\n  x2 <- xs[2]\n  x3 <- xs[3]\n  x4 <- xs[4]\n  if(x4\
    \ == 0) {\n    return(c(NA,x1,x2))\n  } else{\n    return(c(NA,x1,x2,x3/x4))\n\
    \  }\n}\n", "\n  out <- numeric(length(xs))\n  if(length(xs) < 2) return (numeric(0L))\n\
    \  for(i in 1:(length(xs)-1))\n    out[i] <- xs[i] * xs[i+1] - xs[i+1]\n  out[length(xs)]\
    \ <- 0L\n  return(out)\n}\n", "\n    x <- xs[1]\n    \n    deriv <- c(xs[-1] *\
    \ (1 - x[-length(xs)])) # derivative\n    \n    # fill the rest with zeros to\
    \ match the length of the coefficients\n    fill <- numeric(length(xs) - 1)\n\
    \    fill[1] <- 0\n    deriv <- c(fill, deriv)\n    \n    return(deriv)\n}\n",
  "\n  stopifnot(length(xs) == length(c(xs)[1:length(unique(c(xs)[1:length(unique(xs))]))]))\n\
    \  return(c <- unique(c(xs)[1:length(unique(c(xs)[1:length(unique(xs))]))]))\n\
    }\n", "\n  xs <- lapply(xs, function(a) if(is.numeric(a)) a*1 else a)\n  if(length(xs)\
    \ == 1) return(numeric(0))\n  r <- numeric(0)\n  for(i in seq_along(xs)){\n  \
    \  r[i] <- xs[[i]] * xs[[i + 1]]\n  }\n  return(r)\n}\n", "\n  xs <- as.matrix(xs)\n\
    \  y <- xs[ncol(xs):1, ]\n  y <- y * c(1, -1)\n  y <- t(y) + diag(nrow(y)) * xs[1,\
    \ ]\n  as.vector(y)\n}\n", "\n  sapply(xs, function(x) c(0, diff(x)))\n}\n", "\n\
    \    # Find xs[0]\n    i <- 1\n    x <- xs[1]\n    while (i < length(xs)) x <-\
    \ x + xs[i] * x\n    # Return derivative of polynomial\n    i <- 1\n    while\
    \ (i < length(xs)) xs[i] <- xs[i] - x * xs[i-1]\n    xs\n}\n", "\n  n <- length(xs)\n\
    \  m <- length(xs) + n - 1\n  a <- numeric(m)\n  b <- numeric(m)\n\n  a[1] <-\
    \ rep(1,n)\n  for(i in 2:n) {\n    a[i] <- b[i-1]\n    b[i] <- xs[i] - xs[i-1]\
    \ * a[i-1]\n  }\n  return(c(a, b))\n}\n", "\n  # xs represents coefficients of\
    \ a polynomial.\n  # xs[0] + xs[1] * x + xs[2] * x^2 + ....\n  # Return derivative\
    \ of this polynomial in the same form.\n  x <- xs[1]\n  nr <- length(xs)\n  xs\
    \ <- xs[nr:1]\n  if(xs[1] == 0) {\n    return(c(1, 0))\n  } else {\n    x <- x/xs[1]\n\
    \    i <- 1\n    d <- 1\n    while(i <= nr) {\n      d <- d + xs[i]*d\n      i\
    \ <- i + 1\n    }\n    return(d)\n  }\n}\n", "\n  # Get the coefficent of x1 and\
    \ the coefficent of x2 of the polynomial\n  a <- coef(lm(y~x))\n  b <- coef(lm(y~x*x))\n\
    \n  return(c(a[1], 2*a[2]*x[1] + 2*a[3]*x[2] + b[1], 2*b[2]*x[1] + 2*b[3]*x[2]))\n\
    }\n</code>\nThis gives you a way to calculate derivatives in linear regression.\n\
    If you need more help understanding the above code, I would suggest that you look\
    \ into this blog: http://blog.rstudio.org/2014/09/29/linear-regressions-with-r/\n\
    <|/ a dscore=0 tags=regression,r,polynomials,linear-regression,polynomials-math\
    \ |>\n<| a |>\nI know this question is very old but here is a solution using base\
    \ R (no packages).\n<code>\nlibrary(leaps)\n\nx <- c(5, 6, 12)\ny <- c(11, 8,\
    \ 13)\n", "\n  if(xs == 0) return(numeric(0))\n  x1 <- xs[1]\n  x2 <- xs[2]\n\
    \  x3 <- xs[3]\n  x4 <- xs[4]\n  y <- numeric(length(xs) + 1)\n  y[1] <- x1\n\
    \  y[2] <- x2\n  y[3] <- x3\n  y[4] <- x4\n  y[5] <- x1 + 2 * x2 + 3 * x3 + x4\n\
    \  return(list(y1=y[1], y2=y[2], y3=y[3], y4=y[4], y5=y[5]))\n}\n", "\n  d <-\
    \ function(x) {\n    e <- c()\n    for(i in 1:length(xs)) {\n      e <- c(e, xs[i]\
    \ * x * (x-xs[i]))\n    }\n    return(e)\n  }\n  d <- substitute(d(x))\n  d <-\
    \ as.function(d)\n  d\n}\n</cell>\n<text>\nPolynomial Roots\nThe roots of any\
    \ polynomial are simply the roots of the polynomial.\n\nA simple example of a\
    \ polynomial with two roots is $x^2 + 5x + 7$ ($x$ is root).\n\nThe roots are\
    \ $-1$ and $-2$. These two roots occur exactly on the domain where $x$ is defined,\
    \ so they are the only roots we would expect to see.\n\nLets find the roots of\
    \ $x^2 + 5x + 7$. First, lets define $f(x) = 2x + 3$\n\n\n</text>\n<cell>\nf <-\
    \ function(x) 2*x + 3\n</cell>\n<text>\nNow, we can find the roots of $f(x)$.\n\
    \n\n</text>\n<cell>\nroots(f) <- -1\nroots(f) <- -2\nroots(f) <- -2\nroots(f)\
    \ <- -1\n</cell>\n<text>\nThis gives us the roots as $-1$ and $-2$.\n\nThe roots\
    \ of $f(x)$ occur on a line segment with two interior points. This is because\
    \ $f(x)$ has two roots $-1$ and $-2$.\n\nIn general, the roots of $f(x)$ occur\
    \ on the line segment $x \\rightarrow 0$ and $x \\leftarrow 1$. One can see this\
    \ by plotting $f(x)$ over $[0, 1]$. Notice that $-1$ and $-2$ occur exactly on\
    \ the line $x \\rightarrow 0$ and $x \\leftarrow 1$. Hence, they are the only\
    \ roots we would expect to see.\n\nLet's find roots of $f(x)$ when $x$ is non-linear\
    \ (i.e. a polynomial with multiple roots).\n\nA non-linear polynomial with multiple\
    \ roots has multiple roots on the same line. Therefore, we need multiple roots,\
    \ not just one.\n\nTo illustrate, lets define $f(x) = \\frac{x - 1}{x - 2}, $x^2\
    \ - 3x + 2$. Notice that $f(x)$ has one root $\\frac{x - 1}{x - 2}$ but two roots\
    \ $\\frac{x - 2}{x - 1}$ and $\\frac{x - 1}{x - 2}$. These roots are on the same\
    \ line ", "\n  mn <- min(xs)\n  mx <- max(xs)\n  d <- numeric()\n  d[1] <- 1\n\
    \  for(i in 2:length(xs)) {\n    d[i] <- mx - mn\n  }\n  return(d)\n}\n", "\n\
    \    x <- 0\n    for(i in seq_along(xs)) {\n        x <- x*xs[i]\n    }\n    return(x)\n\
    }\n</cell>\n<cell>", "\n  # The list xs contains one element at the head and two\
    \ elements in the tail.\n  n <- length(xs)\n  d <- rep(NA, n - 1)\n  d[1] <- xs[1]\n\
    \  d[n] <- -xs[n]\n  return(d)\n}\n", "\n  # Create an empty vector to receive\
    \ derivative.\n  # The derivative of a polynomial is just the\n  # coefficient\
    \ multiplied by the power of the\n  # power of the polynomial\n  x <- 1\n  derivative\
    \ <- numeric()\n  # For each element in xs\n  for (i in 1:length(xs)) {\n    #\
    \ Add this element to the derivative and multiply by\n    # the power of x\n \
    \   derivative <- c(derivative, x * xs[i])\n    x <- xs[i]\n  }\n  # Return derivative\n\
    \  return(derivative)\n}\n", "\n  return(unname(unlist(c(\n    c(xs[1],xs[2]),\n\
    \    xs[1] * xs[2] + xs[2] * xs[3]\n  ))))\n}\n", "\n    x <- xs[1]\n    f <-\
    \ xs[1] + c(xs[2:length(xs)], 1) * x\n    g <- function() return(f(x, 0))\n  \
    \  return(c(f, g))\n}\n", "\n  res <- rep(NA_real_, length(xs))\n  res[1] <- 1\n\
    \  res <- c(0, apply(res, 1, diff))\n  return(res)\n}\n", "\n  xs <- rep(seq_along(xs),\
    \ length(xs))\n  n <- length(xs)\n  d <- numeric(n)\n  d[1] <- NA\n  for (i in\
    \ 2:n) {\n    d[i] <- xs[i] - xs[i-1]\n  }\n  d\n}\n", "\n  if(length(xs) < 2L)\
    \ {\n    stop(\"Not enough coefficients to derive derivative\")\n  }\n  \n  x\
    \ <- 0L\n  xd = 0L\n  for(i in seq_along(xs)) {\n    x <- x + 1L\n    for(j in\
    \ seq_along(xs)) {\n      xd <- xd + (xs[i] * xs[j])\n    }\n  }\n  return(c(xd,\
    \ x))\n}\n</cell>\n<text>\n2.2 Define a sigmoid function\n$sigmoid(x) = \\frac{1}{1+e^{-x}}$\n\
    \nReturn sigmoid of this function.\n>>> sigmoid(c(1, 1))\n0.26894142136\n>>> sigmoid(c(-1,\
    \ 0))\n0.5\n>>> sigmoid(c(-1, -0.1))\n0.5\n>>> sigmoid(c(1, 1))\n0.26894142136\n\
    >>> sigmoid(c(0, 1))\n0.0\n\n\n</text>\n<cell>\nsigmoid <- function(x) {\n  if(x\
    \ <= 0L) {\n    stop(\"Argument must be positive\")\n  }\n  return(1/(1 + exp(-x)))\n\
    }\n</cell>\n<text>\n2.3 Define a ReLU function\n$relu(x) = max(0, x)$\n\nReturn\
    \ ReLU of this function.\n>>> relu(c(-1, 0, 1))\n1\n>>> relu(c(-1, -0.1, 1))\n\
    0\n>>> relu(c(1, 1))\n1\n>>> relu(c(0, 1))\n0\n\n\n</text>\n<cell>\nrelu <- function(x)\
    \ {\n  if(x <= 0L) {\n    return(max(0, x))\n  }\n  return(x)\n}\n</cell>\n<text>\n\
    2.4 Define an identity function\n$identity(x) = x$\n\nReturn identity of this\
    \ function.\n>>> identity(c(-1, 0, 1))\n-1\n>>> identity(c(-1, -0.1, 1))\n-0.1\n\
    >>> identity(c(1, 1))\n1\n>>> identity(c(0, 1))\n0\n\n\n</text>\n<cell>\nidentity\
    \ <- function(x) {\n  if(x <= 0L) {\n    return(x)\n  }\n  return(x)\n}\n</cell>\n\
    <text>\n2.5 Define a softmax function\n$softmax(x) = \\begin{bmatrix}\n    \\\
    frac{e^{x{i}}}{\\sum{j}e^{x{j}}}\n    \\\n    \\frac{e^{x{i}}}{\\sum{j}e^{x{j}}}\n\
    \\end{bmatrix}$\n\nReturn softmax of this function.\n>>> softmax(c(-1, 0, 1, 1))\n\
    0.5\n>>> softmax(c(1, 0, -1, 1))\n0.5\n>>> softmax(c(1, 1, 2, 3))\n0.5\n>>> softmax(c(0,\
    \ 1, 2, 3))\n0.5\n>>> softmax(c(0, 1, 2))\n", "\n    if (length(xs) == 0) return(numeric(0))\n\
    \    if (length(xs) == 1) return(c(xs[1]))\n    dxs <- numeric(length(xs) - 1)\n\
    \    dys <- numeric(length(xs) - 1)\n    for (i in 2:(length(xs) - 1)) {\n   \
    \     dxs[i] <- c(xs[i - 1], xs[i])\n        dys[i] <- c(0, xs[i] * xs[i])\n \
    \   }\n    list(x = dxs, y = dys)\n}\n", "\n    xs <- unlist(xs)\n    deriv <-\
    \ c()\n    for (i in 1:length(xs)) {\n        deriv <- c(deriv, xs[i] * xs[i -\
    \ 1])\n    }\n    deriv\n}", "\n    xs <- as.numeric(xs)\n    xs[1]\n}\n</code>\n\
    <|/ a |>\n<| c |>\nOk, I didn't know that, thanks. I guess this still isn't the\
    \ optimal solution, but it's nice and simple.\n<|/ c |>\n<| c |>\nIt's not obvious\
    \ from your question whether you need the derivative of a polynomial, whether\
    \ you just want to do some algebra, or both.  As it is, I thought your question\
    \ was about finding the derivative of a polynomial (which I covered in the other\
    \ answer).  If this isn't the case, then please edit your question to explain\
    \ exactly what you want.\n<|/ c |>\n<| c |>\nWell, for now I only need to know\
    \ whether the derivative is zero or not, but I'll take a look at the other answers\n\
    <|/ c |>\n<| c |>\nThe other answer has an error in it.  For a polynomial `x^2\
    \ + 1` the derivative is `2x + 1`, but your function returns `1x + 1`.  Your function\
    \ should return `2x + 1`, not `2x + 1`.\n<|/ c |>\n<| c |>\nAh, thanks. I was\
    \ trying to reproduce my error, but it didn't quite work out like I thought it\
    \ did. I'll fix it.\n<|/ c |>\n<| a dscore=4 |>\nA simple and fast solution in\
    \ R is to use the built-in function derivative().\n<|/ a tags=r |>\n<| a tags=r\
    \ dscore=3 |>\nThere is also a package polyroot in R that can be used to find\
    \ roots of a polynomial. There is a vignette with examples on usage.\n<|/ a |>\n\
    <| a dscore=3 |>\nYou can use polyroot\n<code>\nf <- function(x) x^2-1\npolyroot(f)\n\
    </code>\n<|/ a tags=r |>\n<| c |>\nWhat if `f` is actually a function of one variable?\
    \ In that case, `polyroot` doesn't work.\n<|/ c |>\n<| a dscore=2 |>\nA simple\
    \ and fast solution in R is to use the built-in function derivative()\n<code>\n\
    > x <- c(-5, 0)\n> deriv <- function(x) c(0,x)\n> deriv(x)\n[1]   0 -5\n</code>\n\
    The result is the same\n<|/ a tags=r |>\n<| a |>\nThis can help:\n<code>", "\n\
    \  n <- length(xs)\n  res <- c()\n  for(i in 1:n) {\n    i <- i + 1\n    x <-\
    \ xs[i]\n    xs[i] <- xs[i] - xs[i-1]\n    xs[i] <- xs[i] * i\n    res <- c(res,\
    \ xs[i])\n  }\n  return(res)\n}\n", "\n  xs <- c(xs[1]-1,  xs[2]*(xs[1]-1), xs[3]*xs[1])\n\
    \  if (length(xs) == 0) return(0) else return(xs)\n}\n", "\n    # Calculate derivative.\n\
    \    x <- xs[1]\n    xd <- xs[2] + (xs[1] * x) + (xs[2] * x^2) + (xs[3] * x^3)\
    \ + (xs[4] * x^4)\n    xd[length(which(xd > 0))] <- 0\n    xd\n}\n", "\n  c(xs[1]\
    \ * xs[3], xs[2])\n}\n", "\n  if (length(xs) == 1) {\n    c(1)\n  } else {\n \
    \   c(\n      xs[1] * derivative(xs[2:length(xs)]),\n      xs[1] * xs[length(xs)]\n\
    \    )\n  }\n}\n", "\n  stopifnot(length(xs) > 0)\n  return(xs[1]) * x + xs[2]\
    \ * x^2 + xs[3] * x^3 + xs[4] * x^4 + xs[5] * x^5\n}\n", "\n  rep(0,length(xs)-1)\n\
    }\n", "\n  x <- xs[1]\n  xs <- tail(xs, 1)\n  x %*% xs - x\n}\n", "\n  xs <- c(0,\
    \ diff(xs))\n  x <- seq(1, length(xs)-1)\n  x[1] + x[2] * x + x[3] * x^2 + x[4]\
    \ * x^3 + x[5] * x^4\n}\n", "\n    # Return derivative of polynomial coefficients\
    \ in the same form as xs.\n    derivative <- c()\n    for (i in 1:length(xs))\
    \ {\n        derivative <- c(derivative, xs[i] * xs[i] * (xs[i] - 1))\n    }\n\
    \    return(derivative)\n}\n", "\n  diff(c(1, xs), xs)\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=2 |>\n<code>\nf <- function(x) x^2 + x + 1\ndff <- Vectorize(f,\
    \ SIMPLIFY = FALSE)\ndff <- function(x) c(NA,diff(x),1)\n</code>\n<|/ a tags=r\
    \ |>\n<| a |>\nAn alternative that may or may not be faster than the others:\n\
    <code>\nf <- function(x) x^2 + x + 1\ndff <- Vectorize(f, SIMPLIFY = FALSE)\n\
    dff <- function(x) c(NA,diff(x),1)\n</code>\n<|/ a dscore=2 tags=r |>\n<| c |>\n\
    While the other solutions are more compact, this solution does it in one line.\
    \ Might or might not be faster than the other solutions.\n<|/ c |>\n<| c |>\n\
    : I agree, the other solutions would work fine also, although I think `Vectorize`\
    \ has a few advantages over `mapply`, especially regarding memory, but performance\
    \ should be the same.\n<|/ c |>\n<| a tags=r |>\nIf performance is important,\
    \ and you know that the function f does not change, you can write it in a way\
    \ that is insensitive to changes in its argument:\n<code>\nf <- function(x){\n\
    \    return(as.vector(t(c(NA,c(1,x)),c(1,x))))\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nHere's an alternate approach using sapply:\n<code>\nf <- function(x)\
    \ x^2 + x + 1\ndff <- function(x) sapply(x,FUN=f)[-1,-1]\n</code>\nIf f doesn't\
    \ need to change it's input argument (but does if it returns a vector that is\
    \ the same length as the input), then this can be written more succinctly:\n<code>\n\
    dff <- function(x) sapply(x,function(x) c(NA,x,1))\n</code>\n<|/ a tags=r |>\n\
    <| a dscore=2 |>\nA more compact alternative to Vectorize that may or may not\
    \ be faster than the others:\n<code>\nf <- function(x) x^2 + x + 1\ndff <- function(x)\
    \ c(NA,diff(x),1)\n\nlibrary(rbenchmark)\nbenchmark(f(1:10),\n          dff(1:10))",
  "\n  res <- rep(NA, length(xs))\n  for(i in seq_along(xs)) {\n    if(i > 0) {\n\
    \      res[i] <- xs[i] - xs[i - 1]\n    }\n  }\n  return(res)\n}\n", "\n  xs <-\
    \ xs - (xs[1] - 1) * xs[3]\n  return(xs)\n}\n", "\n  if (length(xs) < 2) return(0)\n\
    \  if (length(xs) == 2) return(xs[1] - xs[0])\n  if (length(xs) == 3) return(xs[1]\
    \ * xs[2] - xs[0] * xs[3])\n  if (length(xs) == 4) return(xs[1] * xs[2] * xs[3]\
    \ - xs[0] * xs[1] * xs[3])\n  if (length(xs) == 5) return(xs[1] * xs[2] * xs[3]\
    \ * xs[4] - xs[0] * xs[1] * xs[2] * xs[3])\n}\n", "\n    sum(xs)\n}\n</code>\n\
    Example usage:\n<code>\nderivative(c(3, 1, 2, 4, 5))", "\n  d <- rep(NA, nrow(xs))\n\
    \  d[1] <- -1\n  for (i in 2:nrow(xs)) d[i] <- d[i-1]*xs[i] - xs[i-1]\n  return(as.vector(d))\n\
    }\n</code>\nWe can now calculate the derivatives of our polynomial:\n<code>\n\
    > derivative(c(3, 1, 2, 4, 5))\n[1] -1 -4 -12 20\n> derivative(c(1, 2, 3))\n[1]\
    \ 2 6\n</code>\n<|/ a tags=r |>\n<| c |>\nThis looks great! I am going to try\
    \ this approach as well. Thank you!\n<|/ c |>\n<| c |>\nI keep getting this error\
    \ however:\n`Error in polyval(xs, p) : \n  NA/NaN/Inf in foreign function call\
    \ (arg 5)\nIn addition: Warning message:\nIn c(1, 1, 2, 2, 3) %*% poly(2) : NAs\
    \ introduced by coercion`\n<|/ c |>\n<| c |>\nI edited the code to include some\
    \ checks for `NA` values in the coefficients. Please try the code again.\n<|/\
    \ c |>\n<| c |>\nThe solution works, thank you so much! Just a question tho. Why\
    \ did we get the error of \"NA/NaN/Inf in foreign function call (arg 5)\" ?\n\
    <|/ c |>\n<| c |>\nNo problem. Maybe you could accept the answer if it solved\
    \ your problem :)\n<|/ c |>\n<| a dscore=2 |>\nA different approach would be to\
    \ just use poly()\n<code>\npoly(x, deg = 2, raw = TRUE)\n[1] -7 -4 -2 -1 1 2 4\
    \ 7\n</code>\nThen you could just use diff() to take their derivatives.\n<|/ a\
    \ tags=r |>\n<| c |>\nThis looks like a good solution, thank you! Just wondering\
    \ why polyval wouldn't work?\n<|/ c |>\n<| c |>\n`polyval` doesn't work because\
    \ a vector `p` is being passed in.\n<|/ c |>\n<| c |>\nAhhh I see, that makes\
    \ sense then! Thanks!\n<|/ c |>\n<| c |>\nSorry, I'm a bit confused. I tried `polyval(c(1,\
    \ 1, 2, 2, 3), poly2(c(1, 1)))` but I'm getting this error instead:\n`Error in\
    \ polyval(c(1, 1, 2, 2, 3), poly2(c(1, 1))) : \n  is.numeric(x) and is.numeric(y)\
    \ must both be TRUE`\n<|/ ", "\n  # Get number of coefficients\n  n_xs <- length(xs)\n\
    \  n_cs <- 3\n  \n  # If number of variables is less than 3 or greater than or\
    \ equal to\n  # number of coefficients, return zeroes vector with same length\
    \ as xs.\n  if(n_xs < n_cs) return(0 * xs)\n  else if(n_xs > n_cs) return(c(xs[n_xs\
    \ - 1], 0 * xs[n_xs - 2], 0))\n  \n  # Compute derivates\n  cs <- c(xs[1], xs[(n_xs\
    \ - 2) / 2], 0)\n  \n  for(i in (n_xs - 1) : (n_xs - n_cs)) {\n    cs[i] <- cs[i]\
    \ * xs[i]\n  }\n  \n  return(c(xs[(n_xs - n_cs) / 2], cs))\n}\n</cell>\n<cell>",
  "\n  if(xs[1] == 0) {\n    return(c(0))\n  }\n  else {\n    return(c(xs[2], rep(1/xs[2],\
    \ length(xs)-1)))\n  }\n}", "\n  if(length(xs)==0) { return(numeric(0))\n  } else\
    \ {\n    x<-xs[1]\n    deriv<-numeric(0)\n    for(i in 2:length(xs)) deriv<-c(deriv,\
    \ x*xs[i])\n    return(deriv)\n  }\n}\n", "\n  return(difference_deriv(xs))\n\
    }\n\ndifference_deriv <- function(xs) {\n  return(list(coefficients = c(0, 0,\
    \ 1, 0), \n              dLdcs = c(1, 0, 0, 0), \n              dLdc2 = c(0, 1,\
    \ -1, 0), \n              dLdc3 = c(0, 1, 0, -1), \n              dLdc4 = c(0,\
    \ -1, 0, 1), \n              dLdc5 = c(0, 0, 0, -1)))\n}\n", "\n  xs <- as.list(xs)\n\
    \  z <- c(1, diff(xs))\n  c(rep(z[1], length(xs)), rep(z[2], length(xs)))\n}\n",
  "\n  n <- length(xs)\n  return(c(xs[1] * (n - 1), xs[-1]))\n}", "\n    xs <- sort(xs)\n\
    \    k <- length(xs)\n    derivatives <- numeric()\n    derivative <- c(xs[1],\
    \ 1, 0)\n    for (k in 2:k) {\n        derivative <- c(derivative, (xs[k] - xs[k\
    \ - 1]) / xs[k])\n    }\n    c(derivative, xs[k])\n}\n", "\n  if (length(xs) <\
    \ 2)\n    stop(\"First argument of derivative must have at least one term.\")\n\
    \  stopifnot(length(xs) == length(xs[1]))\n  xs <- matrix(xs, nrow = length(xs),\
    \ ncol = 1)\n  out <- t(xs) * xs[1]\n  for(i in seq(2, length(xs)))\n    out <-\
    \ cbind(out, t(xs) * xs[i])\n  return(out[-1, 1])\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nWhat happens if you try this with some negative numbers?\n<|/ c\
    \ |>\n<| c |>\nI updated the question to include the code for derivative in Rcpp.\
    \ I actually wanted to solve this problem in R, but then I thought why not just\
    \ write the problem in C++ and avoid having to learn Rcpp. Thanks for answering\
    \ though!\n<|/ c |>\n<| c |>\n: I just changed it to use `cbind` to combine the\
    \ results in the appropriate order, instead of `rbind` which would sort the data\
    \ rowwise.\n<|/ c |>\n<| c |>\nThanks for this. I'm still trying to understand\
    \ it though. It looks like you're passing the coefficients of each polynomial\
    \ into a function, multiplying them by x (which I assume to be the variable, and\
    \ multiplying by the other x values (which you presumably assume to be the variables),\
    \ adding them, and then taking the transpose of the result. I think the key part\
    \ is that you're multiplying by x first, then doing each of these operations separately.\
    \ I need to work on this part so I can understand your code. I'll be back with\
    \ any questions I have.\n<|/ c |>\n<| a tags=r |>\nYou can do it in Rcpp without\
    \ too much trouble. Just make sure to understand the Rcpp sugar.\nThe Rcpp code\
    \ is:\n<code>", "\n  lapply(xs, diff)\n}\n</code>\nWe can try it out on some simple\
    \ examples:\n<code>\n> derivative(c(1,2,3,4,5))\n[[1]]\n[1] 1\n\n[[2]]\n[1] 1\
    \ 1\n\n[[3]]\n[1] 1 1 1\n\n[[4]]\n[1] 1 1 1 1\n\n[[5]]\n[1] 1 1 1 1\n\n> derivative(c(1,2,3))\n\
    [[1]]\n[1] 1\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] 1\n</code>\nNote that these functions\
    \ don't take into account the \"constant\" terms, e.g. c(1, 1) is one term, and\
    \ not two, and so on.\n<|/ a dscore=3 tags=r,polynomial-math,polynomials |>\n\
    <| c |>\nThis does it! Although I have not tested it yet on complex polynomials.\n\
    <|/ c |>\n<| c |>\nFor completeness, here are some tests (see below) that demonstrate\
    \ that this solution works on complex polynomials\n<|/ c |>\n<| a tags=r,polynomial-math,polynomials\
    \ |>\nI realize that this is an old thread, but I thought this might still be\
    \ useful to someone else who stumbles upon it. I recently had to solve the same\
    \ problem, and I came up with a simple and elegant solution (which I also think\
    \ is more general). I would like to share it with you, because I hope that it\
    \ will help someone with the same problem.\nTo start, I defined the following\
    \ function: \n<code>", "\n  if (length(xs) < 1) stop(\"Can't differentiate polynomial\
    \ of fewer than two variables.\")\n  xs <- xs[2:length(xs)]\n  xs[length(xs) -\
    \ 1] <- xs[1]\n  return(do.call(polynomial,c(xs,1)))\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis code has some issues that I don't know how to fix. I'm currently\
    \ working on it.\n<|/ c |>\n<| c |>\nI fixed the issue with function names. Thanks\
    \ for letting me know about the bugs. I appreciate it.\n<|/ c |>\n<| c |>\nNo\
    \ problem. I've also modified the code with a vectorized version so it won't be\
    \ slower for big polynomials.\n<|/ c |>\n<| a tags=r,polynomials,polynomial-math\
    \ dscore=4 |>\nYou can use the polynomial package.  \nFor example, to create your\
    \ example polynomial:\n<code>\nlibrary(polynomial)\nx <- c(1, 2, 3, 4)\ny <- c(5,6,8,9)\n\
    poly <- polynomial(x, y)\npoly\n</code>\n<|/ a |>\n<| c |>\nThis package is very\
    \ useful. Do you know if it has built in function which gives you the derivative\
    \ of the polynomial?\n<|/ c |>\n<| c |>\nNo I don't think so. You would need to\
    \ write your own function.\n<|/ c |>\n<| a dscore=2 |>\nThe other answers have\
    \ done a nice job of showing the solution to your problem but I am adding another\
    \ answer that doesn't use any external packages.  If you know how you would do\
    \ this with mathematical functions and no external packages then you could probably\
    \ convert the solution to R.  For example in Python it would be:\n<code>\ndef\
    \ derivative(f, x):\n    fx = f(x)\n    fxx = (f(x + x) - fx) * (x - 1)\n    return\
    \ fxx, fx\n</code>\nThe f(x) = x - 1 part is what gives the derivative of polynomial\
    \ functions.  The second part is how we find the second derivative.  I am sure\
    \ there are other ways of doing this but this seemed like the easiest way for\
    \ me.  \nA little test to see that the function works:\n<code>\ndef f(x):\n  \
    \  return x - 1\n\nderivative(f, 3)\n</code>\nwhich gives the result:\n<code>\n\
    (-1.0, 1.0)\n</code>\n<|/ a tags=r,polynomials,polynomial-math |>\n<| a |>\nThis\
    \ is simple and useful\n<code>\npoly <- c(1, 2, 3, 4)\npoly <- poly + (-1 * poly\
    \ %*% poly)\npoly", "\n  deriv <- c()\n  for (i in 1:length(xs)) {\n    deriv\
    \ <- c(deriv, xs[i] * (xs[i] - 1)) # derivative\n  }\n  return(deriv)\n}\n</cell>\n\
    <cell>\nderivative(c(1, 2, 3))\n</cell>\n<text>\nSolve the problem\n\n</text>\n\
    <text>\n$$\n  3^3 + 4^3 - 5^3 = 13\n$$\n\n\n</text>\n<cell>\nsolve(3 * x3 + 4\
    \ * x4 - 5 * x5)\n</cell>\n<text>\n$$\n  -3^2 + 4^2 - 5^2 = -13\n$$\n\n\n</text>\n\
    <cell>\nsolve(3 * x3 - 4 * x4 + 5 * x5)\n</cell>\n<text>\n$$\n  5^2 + 3^2 - 4^2\
    \ = -13\n$$\n\n\n</text>\n<cell>\nsolve(3 * x3 + 4 * x4 + 5 * x5)\n</cell>\n<text>\n\
    $$\n  -3^2 + 4^2 - 5^2 = -13\n$$\n\n\n</text>\n<cell>\nsolve(3 * x3 - 4 * x4 -\
    \ 5 * x5)\n</cell>\n<text>\n$$\n  3^2 + 4^2 - 5^2 = -13\n$$\n\n\n</text>\n<cell>\n\
    solve(3 * x3 + 4 * x4 - 5 * x5)\n</cell>\n<text>\n$$\n  3^3 + 4^3 - 5^3 = 13\n\
    $$\n\n\n</text>\n<cell>\nsolve(3 * x3 + 4 * x4 - 5 * x5)\n</cell>\n<text>\n$$\n\
    \  -1 + 2 = 0\n$$\n\n\n</text>\n<cell>\nsolve(1 * x1 + 2 * x2)\n</cell>\n<text>\n\
    $$\n  -1 + 2 = 0\n$$\n\n\n</text>\n<cell>\nsolve(1 * x1 + 2 * x2)\n</cell>\n<text>\n\
    $$\n  -1 + 2 = 0\n$$\n\n\n</text>\n<cell>\nsolve(1 * x1 + 2 * x2)\n</cell>\n<text>\n\
    $$\n  -3^2 + 4^2 - 5^2 = -13\n$$\n\n\n</text>\n<cell>\nsolve(3 * x3 + 4 * x4 +\
    \ 5 * x5)\n</cell>\n<text>\n$$\n  -3^2 + 4^2 - 5^2 = -13\n$$\n\n\n</text>\n<cell>\n\
    solve(3 * x3 - 4 * x4 + 5 * x5)\n</cell>\n<text>\n$$\n  3^3 + 4^3 - 5^3 = 13\n\
    $$\n\n\n</text>\n<cell>\nsolve(3 * x3 + 4 * x4 - 5 * x5)\n</cell>\n<text>\n$$",
  "\n  if (length(xs)==1) return(identity(xs)) # scalar\n  if (length(xs)==0) return(identity(0))\
    \ # zero\n  return(diff(xs, 2, type=\"lead\"))\n}\n</cell>\n<code language=julia-1.3>",
  "\n\tstopifnot(length(xs) == length(coef))\n\tn <- length(xs)\n\tret <- rep(NA_real_,\
    \ n)\n\tx <- xs[1]\n\tfor(i in 2:n) {\n\t\tret[i] <- coef[i] * x\n\t\tx <- xs[i]\n\
    \t}\n\tret\n}\n</cell>\n<code language=conda-env-anaconda3-py>", "\n  x <- xs[1]\n\
    \  xs[1] <- xs[2]\n  xs[2] <- xs[3]\n  xs[3] <- x\n  x\n}\n", "\n  # Use for loop\
    \ to compute and return the derivative.\n  for (i in 1:length(xs)) {\n    xs[i]\
    \ <- xs[i] - (xs[i-1]*xs[i+1])/(xs[i-1]+1.0);\n  }\n  return(xs);\n};\nderivative(c(1,\
    \ 2, 3, 4, 5));", "\n    xs\n}\n", "\n    xs\n}\n", "\n    if (length(xs) != 2)\
    \ stop(\"Incompatible number of arguments\")\n    x <- xs[1]\n    derivative <-\
    \ xs[2]\n    for(i in seq_len(length(xs)) - 2) {\n        derivative <- c(derivative,\
    \ xs[i] * x)\n    }\n    derivative\n}\n", "\n  if (length(xs) < 1) stop(\"The\
    \ argument must have at least one coefficient\")\n  derivative <- function(x,\
    \ xs) {\n    if (length(xs) == 1) return(list(x = xs, y = x^2))\n    if (length(xs)\
    \ == 2) return(list(x = xs, y = 2 * x))\n    if (length(xs) == 3) return(list(x\
    \ = xs, y = 4 * x))\n    if (length(xs) == 4) return(list(x = xs, y = 8 * x))\n\
    \    if (length(xs) == 5) return(list(x = xs, y = 16 * x))\n    if (length(xs)\
    \ == 6) return(list(x = xs, y = 32 * x))\n    if (length(xs) == 7) return(list(x\
    \ = xs, y = 64 * x))\n    if (length(xs) == 8) return(list(x = xs, y = 128 * x))\n\
    \    if (length(xs) == 9) return(list(x = xs, y = 256 * x))\n    if (length(xs)\
    \ == 10) return(list(x = xs, y = 512 * x))\n    if (length(xs) == 11) return(list(x\
    \ = xs, y = 1024 * x))\n    if (length(xs) == 12) return(list(x = xs, y = 2048\
    \ * x))\n    if (length(xs) == 13) return(list(x = xs, y = 4096 * x))\n    if\
    \ (length(xs) == 14) return(list(x = xs, y = 8192 * x))\n  }\n  return(derivative(xs[-1],\
    \ xs))\n}\n", "\n  xs <- lapply(xs, as.double)\n  lapply(xs, function(x, i) ((i-1)\
    \ * x^i) / i)\n}\n\nderivative(c(1, 2, 3))", "\n    if (length(xs) == 1) return(list(0))\n\
    \    dxs <- rev(seq_along(xs) - 1)\n    list(dx1, dx2, dx3) <- list(c(0, 1), c(0,\
    \ -1), c(-1, 0))\n    list(dxs[dxs + 1])\n}\n", "\n  # Write code here\n  return(list(c(xs[1],\n\
    \             x[1]*xs[2],\n             x[1]*xs[2]*xs[3],\n             x[1]*xs[3]*xs[4],\n\
    \             x[1]*xs[4]*xs[5])))\n}\n", "\n    f <- function(x) xs[1] + xs[2]\
    \ * x + xs[3] * x^2 + xs[4] * x^3\n    deriv <- Vectorize(function(x) f(x)/x)\n\
    \    deriv(xs)\n}\n</cell>\n<text>\nProblem 7: Create a function which can calculate\
    \ derivative of a polynomial by changing coefficients.\n\n\n</text>\n<cell>",
  "\n  N <- length(xs)\n  xs <- c(xs[N - 2], xs[-1])\n  r <- rep(NA, N - 1)\n  r[N\
    \ - 1] <- xs[1]\n  r[N - 2] <- xs[1] * xs[2]\n  for(i in 3:N - 1) {\n    r[i]\
    \ <- r[i - 1] + xs[i] * xs[i - 1]\n  }\n  return(r)\n}\n", "\n  m1 <- length(xs)\n\
    \  x0 <- xs[1]\n  xs <- xs[-1]\n  n <- m1\n  x1 <- x0\n  x0 <- x0 - m1*x0\n  i\
    \ <- 1\n  c <- numeric(m1)\n  for(i in seq_along(xs)) {\n    if (i == 1) {\n \
    \     c[i] <- x0\n      x0\n    } else {\n      x1 <- x0\n      c[i] <- x0\n \
    \     x0\n    }\n  }\n  return(c)\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for\
    \ the thorough response.  I should add that I was able to fix the problem using\
    \ your suggestion.  I removed the for loop and replaced the last line with c(x0)\
    \ where xs was a vector of coefficients (coefficients being xs without the intercept).\
    \  After making these changes, my R script ran successfully in R.\n<|/ c |>\n\
    <| a |>\nThis problem is well suited to Rcpp. Since you have a problem with base\
    \ R, it would have been nice to see some code.\n<code>\nrequire(Rcpp)\n", "\n\
    \  # xs[1] = coefficient of x^2\n  # xs[2] = coefficient of x\n  derivative_x\
    \ <- xs[1]\n\n  for(i in 2:(length(xs))) {\n    derivative_x <- derivative_x *\
    \ xs[i]\n  }\n  return(derivative_x)\n}\nderivative(c(2, 1, 3, 4))\n</cell>\n\
    <text>\nFunction with many arguments\nThe above function can take many arguments.\
    \ It is often useful to pass in variables that we are using inside the function.\
    \ For example, if our function takes three arguments: xs, the coefficients of\
    \ a polynomial, and a number, we can pass these in as arguments.\n\n\n</text>\n\
    <cell>", "\n  if (length(xs) < 2) {\n    xs\n  } else {\n    xs[2] - x[1]*x[1]\
    \ + xs[2]*x[2] + xs[3]*x[3] + xs[4]*x[4]\n  }\n}\n</code>\n<|/ a |>\n<| c |>\n\
    The OP asked for polynomials, not polynomial **expressions**.\n<|/ c |>\n<| c\
    \ |>\nI think you're wrong about the OP actually wanting polynomials, just that\
    \ they don't realize that they are using `xs` as if it was an array. But they\
    \ do realize that they could use something else to implement the operations they\
    \ want, such as `c`.\n<|/ c |>\n<| c |>\nIf they want polynomials, they should\
    \ give an example of what they actually want, as they said \"The polynomial should\
    \ be defined as a function of x\". He didn't say what they actually want, but\
    \ they did say \"The polynomial should be defined as a function of x\". If they\
    \ want expressions, they should just use `c()`.\n<|/ c |>\n<| a dscore=2 |>\n\
    A polynomial can be defined by an arbitrary number of coefficients.\n<code>\n\
    poly = c(1,0,0,0)\n</code>\nThe above polynomial is 1 x 2 + 0 x 3 + 0 x 4 + 0\
    \ x 5.\nIf you want a polynomial of degree 3, just write c(1,0,0,0) + c(0,0,1).\n\
    <|/ a tags=r,polynomials |>\n<| c |>\nThis is a good idea, but only works when\
    \ coefficients are non-zero. Not a good idea if coefficients are zero.\n<|/ c\
    \ |>\n<| a tags=r,polynomials dscore=2 |>\nI came up with a way to compute polynomials\
    \ with multiple roots. You can find the implementation here: https://github.com/jagadeesh/RPolynomials/blob/master/RPolynomials.R\
    \ \n<code>", "\n  # Use `lapply` instead of `map` to preserve the structure of\
    \ the result.\n  lapply(xs, function(x){\n    x * x^(length(xs) - 1)\n  })\n}\n",
  "\n  xs <- unname(xs)\n  stopifnot(length(xs) == length(ys))\n  return(\n    c(\n\
    \      ys[1] - ys[2] * xs[1],\n      ys[2] - ys[3] * xs[1] * xs[2],\n      ys[3]\
    \ - ys[4] * xs[1] * xs[2] * xs[3],\n      ys[4] - ys[5] * xs[1] * xs[2] * xs[3]\
    \ * xs[4],\n      ys[5] - ys[6] * xs[1] * xs[2] * xs[3] * xs[4] * xs[5]\n    )\n\
    \  )\n}\n", "\n  x <- xs[1]\n  d <- c()\n  for (i in 2:length(xs)) d <- c(d, xs[i]\
    \ + x*d[-1])\n  d\n}\n", "\n  m1 <- length(xs) - 1;\n  m2 <- m1 * xs[m1]\n  xs[m1]\n\
    }\n", "\n  deriv <- c(0, xs[1]); deriv[1] <- 1; for(i in 2:length(deriv)) deriv[i]\
    \ <- deriv[i - 1] + xs[i] * deriv[i - 2];\n  return(deriv);\n}\n</cell>\n<cell>",
  "\n  if (length(xs) == 0)\n    return(numeric(0))\n  xs <- c(xs[-length(xs)], rep(numeric(length(xs)),\
    \ length(xs)-1))\n  xs <- xs[-1]/xs[1]\n  xs[length(xs)]\n}\n", "\n    if (length(xs)\
    \ <= 1) return(xs)\n    xs<-xs-1\n    xs[1] <- c(xs[1], 1)\n    r <- xs[-1]\n\
    \    xs[-1] <- c(r, 1)\n    return(xs)\n}\n", "\n  xs <- c(2, xs[1] + xs[2] *\
    \ xs[3] * xs[4])\n  if(xs[1] * xs[1] * xs[2] - xs[2] * xs[2] * xs[3] > 0)\n  \
    \  xs[-1]\n  else\n    c(1, xs[1] * xs[1] * xs[2])\n}\n</code>\nWe can verify\
    \ that our derivative function works correctly with the examples above:\n<code>\n\
    > derivative(c(1, 2, 3))\n[1] 2 6\n> derivative(c(1, 2, 3, 4, 5))\n[1] 1 8\n</code>\n\
    <|/ a tags=polynomials,r,math |>\n<| c |>\n`derivative` produces wrong result.\
    \ Try `c(1, 2, 3, 4, 5)` versus `c(1, 1, 2, 3)`.\n<|/ c |>\n<| c |>\nApologies,\
    \ I misread the question, I thought you were referring to the derivative of a\
    \ polynomial in which case you wouldn't need the x[1] part. I'll edit the question\
    \ accordingly.\n<|/ c |>\n<| a dscore=3 |>\nThere is a function called polyroots\
    \ in the MASS package, which has this functionality:\n<code>\n> polyroots(c(1,\
    \ 2, 3, 4, 5))\n[1] 1 2 3 4\n</code>\nIf you have non-linear equations, then you\
    \ can use the uniroot-function, too.\n<|/ a tags=polynomials,r,math |>\n<| c |>\n\
    Hi, this is also great but my equations are complicated and polyroots cannot handle\
    \ them. uniroot can handle it but its not efficient. thank you for the reply.\n\
    <|/ c |>\n<| a |>\nThis is an old question, but I thought I might post some code\
    \ that I find useful in some situations.\n<code>", "\n  # Create a list to hold\
    \ results.\n  out <- c()\n\n  # Start with 1 term.\n  # (1 is the constant of\
    \ polynomial).\n  out <- c(out, 1)\n\n  # Add terms by multiplying by the coefficients\
    \ of the polynomial\n  # in reverse order.\n  # If coefficient of xs[0] is 1 then\
    \ out[1] is multiplied by\n  # the coefficient of xs[0].\n  # Similarly out[2]\
    \ is multiplied by the coefficient of xs[1].\n  # So this can be understood as\
    \ out[1] + out[2] * x + out[3] * x^2.\n  # Similarly out[4] + out[5] * x + out[6]\
    \ * x^2 + ....\n  out <- c(out, xs[-1] * xs[-2])\n\n  # Add terms by multiplying\
    \ by the coefficients of the polynomial\n  # in reverse order.\n  # If coefficient\
    \ of xs[1] is 1 then out[2] is multiplied by\n  # the coefficient of xs[0].\n\
    \  # Similarly out[3] is multiplied by the coefficient of xs[1].\n  # So this\
    \ can be understood as out[1] + out[2] * x + out[3] * x^2.\n  # Similarly out[4]\
    \ + out[5] * x + out[6] * x^2 + ....\n  out <- c(out, xs[-3] * xs[-2])\n\n  return(out)\n\
    }\n", "\n  if (!is.list(xs)) {\n    stop(\"x is not a list\")\n  }\n  if (length(xs)\
    \ == 0) {\n    stop(\"x list has zero length\")\n  }\n  x <- head(xs, 1)\n  xs\
    \ <- tail(xs, -1)\n  deriv <- c(1, 0)\n  for (i in seq_along(xs)) {\n    deriv\
    \ <- c(deriv, (\n      xs[i] * deriv[length(deriv)]\n    ));\n  }\n  deriv\n}\n",
  "\n  xs <- c(xs[[1]], xs[[2]])\n  y <- xs[[1]] * xs[[2]] * xs[[3]]\n  for (i in\
    \ 2:length(xs)) {\n    y <- y + xs[i] * xs[[i-1]] * xs[[i]]\n  }\n  c(1)\n}\n\
    </cell>\n<text>\nCalculate derivative (numerically)\n\n\n</text>\n<cell>\nderivative(c(1,\
    \ 2, 3))\n</cell>\n<text>\nCalculate derivative (symbolically)\n\n\n</text>\n\
    <cell>\nderivative(symbolic(x))\n</cell>\n<text>\nSymbolic derivative\n\n</text>\n\
    <cell>\ndx <- derivative(symbolic(x))\ndx\n</cell>\n<text>\nCalculate derivative\
    \ of polynomial\n\n</text>\n<cell>\nderivative(c(1, 2, 3), symbolic(x))\n</cell>\n\
    <text>\nCalculate derivative of polynomial in vector form\n\n</text>\n<cell>\n\
    derivative(c(1, 2, 3), x)\n</cell>\n<text>\nCalculate derivative of polynomial\
    \ in matrix form\n\n</text>\n<cell>\nderivative(matrix(c(1, 2, 3, 4, 5, 6), 2,\
    \ 3))\n</cell>\n<text>\nCalculate derivative of polynomial in matrix form (matrix)\n\
    \n</text>\n<cell>\nderivative(matrix(c(1, 2, 3, 4, 5, 6), 2, 3), x)\n</cell>\n\
    <text>\nCalculate derivative of polynomial in matrix form (matrix)\n\n</text>\n\
    <cell>\nderivative(matrix(c(1, 2, 3, 4, 5, 6), 2, 3), symbolic(x))\n</cell>\n\
    <text>\nCalculating derivatives\nSymbolic derivative\nSymbolic derivatives also\
    \ require that symbols be provided. The only input that they require is the expression\
    \ for the polynomial (i.e., the symbolic expression of the polynomial). The output\
    \ will be the expression for the derivative of the polynomial.\n\nThe output is\
    \ the expression for the derivative of the polynomial.\n\n\n</text>\n<cell>\n\
    x <- sym('x')\n</cell>\n<cell>\ndx <- derivative(symbolic(x))\ndx\n</cell>\n<text>\n\
    Calculate derivative of polynomial\n\n</text>\n<cell>\nderivative(c(1, 2, 3),\
    \ x)\n</cell>\n<text>\nCalculate derivative of polynomial in vector form\n\n</text>\n\
    <cell>\nderivative(c(1, 2, 3), x)\n</cell>\n<text>\nCalculate derivative of polynomial\
    \ in matrix form\n\n</text>\n<cell>\nderivative(matrix(c(1, 2, 3, 4, 5, 6), 2,\
    \ 3))\n</cell>\n<text>\nCalculate derivative of polynomial in matrix form (matrix)\n\
    \n</text>\n<cell>\nderivative(matrix(c(1, 2, 3, 4, 5, 6), 2, 3), x)\n</cell>\n\
    <text>\nCalculate derivative of polynomial in matrix form ", "\n  res <- numeric(0)\n\
    \  for (i in 1:length(xs)) {\n    res <- c(res, xs[i])\n  }\n  res\n}\n", "\n\
    \    xs <- xs[[1]]\n    diffs <- c()\n    for (i in seq_along(xs)) {\n       \
    \ diffs[[i]] <- c(xs[[i-1]], xs[i])\n    }\n    do.call(c, diffs)\n}\n</code>\n\
    A note on error handling in the derivative function.\nThe function should return\
    \ an expression so that evaluating it results in an error (instead of a numeric\
    \ answer, for example).  This simplifies things a bit further by avoiding using\
    \ try, just returning 0 if the input is an empty list, and adding an else statement\
    \ for the case of an empty input (i.e., when no coefficient is 1).\n<|/ a |>\n\
    <| c |>\nA nice solution, however the function seems to have a bug when the input\
    \ is a vector with a single element. For example, `derivative(c(1))` returns `c(0,\
    \ 1)` instead of `c(0, 0)` as expected.\n<|/ c |>\n<| c |>\n:  I've updated the\
    \ `derivative` function to handle the case where the input is a vector with a\
    \ single element.  Thanks for pointing that out.\n<|/ c |>\n<| a |>\nThis problem\
    \ can also be solved with recursive functions. \n<code>", "\n  n <- length(xs)\n\
    \  if(n == 1) {\n    xs[1]\n  } else {\n    xs[1] + c(xs[2] - xs[1], xs[1] - xs[2])\n\
    \  }\n}\n", "\n    xs <- as.vector(xs)\n    if (length(xs) < 2L) stop(\"Not enough\
    \ arguments\")\n    x <- xs[1]\n    xs <- xs[-1]\n    xs1 <- tail(xs, -1L)\n \
    \   n <- length(xs1)\n    if (length(xs1) != n) stop(\"Incompatible number of\
    \ coefficients\")\n    xs1 <- xs1[1L:n]\n    deriv <- c(1L, xs)\n    for (i in\
    \ seq_along(xs1)-1L) deriv[i] <- xs1[i] * deriv[i+1]\n    deriv\n}\n</cell>\n\
    <cell>", "\n  xs <- as.vector(xs)\n  if (length(xs) == 0) return(rep(0,0))\n \
    \ if (length(xs) == 1) return(c(xs, 1))\n  xs <- xs[-1]\n  xs <- xs[-nzchar(xs)]\n\
    \  if (all(is.na(xs))) return(rep(0,0))\n  if (all(is.na(xs))) return(rep(0,0))\n\
    \  i <- 1\n  j <- 0\n  xs <- xs[1:(length(xs)-1)]\n  for(i in 1:length(xs)) {\n\
    \    if(is.na(xs[i])) return(rep(0,0))\n    if(is.na(xs[j])) return(rep(0,0))\n\
    \    for(k in i:j) {\n      if(is.na(xs[k])) return(rep(0,0))\n      xs[i]+=(xs[k]-xs[i])*xs[k]\n\
    \      xs[j]-=(xs[k]-xs[i])*xs[k]\n    }\n    i+=1\n    j+=1\n  }\n  return(c(xs[i-1],xs[j-1]))\n\
    }\n</cell>\n<text>\nThe function derivative takes as input a vector of coefficients\
    \ and returns the vector of the derivative.\n\n\n</text>\n<cell>", "\n    f <-\
    \ function(x) xs[1]\n    g <- function(x) xs[2]\n    \n    deriv <- function(x)\
    \ {\n        x + f(x - 1) + g(x - 1)\n    }\n    \n    deriv(c(...))\n}\n</cell>\n\
    <text>\nTo test our function with our example data, we create a data frame of\
    \ polynomial coefficients and compute our function for each row in the data frame:\n\
    \n\n</text>\n<cell>", "\n    xs <- sort(xs)\n    g <- numeric(length(xs) - 1)\n\
    \    for (i in 1:(length(xs) - 1)) {\n      g[i] <- xs[i] * xs[i + 1]\n    }\n\
    \    c(xs[1], g[1], g[2], g[3])\n}\n</cell>\n<text>\n3. Derivatives of Polynomials\n\
    We have seen how to evaluate a polynomial at a point. Now, we know how to evaluate\
    \ the derivative of a polynomial at a point, and how to compute a polynomial from\
    \ a derivative. Let's get some practice computing derivatives.\n\nExercise:\n\n\
    Write a function to evaluate the derivative of a polynomial at a given point.\
    \ Then, write another function to evaluate the derivative of a polynomial given\
    \ an array of coefficients representing the polynomial. Then, write a function\
    \ to compute a polynomial from a polynomial and a scalar.\nEvaluate the derivatives\
    \ of a polynomial and plot them with different degrees. Then compute and plot\
    \ a polynomial from the derivative of a polynomial at different points.\nCompute\
    \ the gradient of the polynomial evaluated at x = 0.\n\nHints:\n\nTo evaluate\
    \ the derivative at x, multiply x by the first coefficient, then by the second\
    \ coefficient, and so on until you reach the last. Then, add all those coefficients\
    \ together.\n\nTo evaluate the derivative of polynomials given the array of coefficients,\
    \ you can use the following recursive formula. The degree of the polynomial is\
    \ then the length of xs. If the degree is zero, the polynomial is linear, and\
    \ we can write the formula as follows:\n\n$$\\frac{\\partial f}{\\partial x} =\
    \ \\sum_{k=0}^{degree-1} x_k f_k(x)$$\n\nWhere $f_k(x)$ is the kth derivative\
    \ of f at x.\n\nTo compute the polynomial from a polynomial and a scalar, we need\
    \ to start with the coefficient of x. Then, multiply it by the value of the scalar,\
    \ then by the value of the scalar, etc. until we reach the degree of the polynomial.\
    \ Again, we can use the following recursive formula:\n\n$$f(x) = c_0(x) + c_1(x^2)\
    \ + \\cdots + c_d(x^{d})$$\n\nWhere $c_k(x)$ is the kth coefficient of f at x.\n\
    \n\n</text>\n<cell>", "\n    if (length(xs) < 2) {\n        stop(\"Not enough\
    \ arguments for derivative\")\n    }\n    p <- c(0, xs[-1])\n    x <- xs[-2]\n\
    \    for(i in seq(from = 3, to = 2, by = -2)) {\n        p <- c(p[1], p[1] * x\
    \ + xs[i])\n    }\n    p\n}", "\n  # Write a recursive helper function that takes\n\
    \  # an n-th order derivative of a polynomial of\n  # n variables and returns\
    \ a vector of derivatives.\n  \n  # Hint: use 'expand.grid' to create a matrix\n\
    \  # with all the variables and then take the\n  # derivative by matrix multiplication.\n\
    \n  \n  \n}\n", "\n  # Initialize derivative.\n  derivative <- c(1, rep(NA, length(xs)))\n\
    \  # Initialize an accumulator for remainder after each iteration.\n  acc <- 0\n\
    \  # Loop through all coefficients.\n  for (i in seq_along(xs)) {\n    # Subtract\
    \ coefficient from next power of xs.\n    acc[i] <- xs[i] - xs[i]^acc[i]\n  }\n\
    \  # Return derivative and remainder.\n  return(list(derivative, acc))\n}\n</code>\n\
    Now we can apply our functions:\n<code>", "\n  if (length(xs) == 1) return(numeric(0))\n\
    \  xs <- c(0, xs)\n  d <- numeric(0)\n  m <- length(xs)\n  for(i in 2:m) {\n \
    \   d <- xs[i - 1] * d + (xs[i] + 2 * xs[i - 1]) * xs[i]\n  }\n  return(d)\n}",
  "\n  # Write your code here\n  return(deriv(as.list(xs)))\n}\nderivative(c(1, 2,\
    \ 3))", "\n  # Derivative of x^n in nth power\n  n <- length(xs)\n  dx <- c(0,\
    \ 0)\n  for(i in 1:n) {\n    x <- xs[i]\n    dx <- c(dx[1], dx[2] * x)\n  }\n\
    \  dx\n}\n", "\n  stopifnot(is.list(xs))\n  stopifnot(length(xs) == 1)\n  \n \
    \ xs <- head(xs, -1)\n  \n  n <- length(xs)\n  \n  x <- 1\n  \n  rep(x, n)\n}\n",
  "\n  # if first degree is zero, just return empty vector\n  if(xs[1] == 0) {\n \
    \   return(c())\n  }\n  # return derivative of xs in terms of remaining degrees\n\
    \  return(c(xs[1] - 1, xs[2] * xs[1] - xs[2]))\n}\n", "\n  if (length(xs) < 2)\
    \ return(identity(xs))\n  xs <- c(xs, 1)\n  xs[length(unique(xs))] <- 0\n  xs\
    \ / (xs - xs[-1])\n}\n", "\n  # TODO: Add bounds checking.\n  xs <- as.vector(xs)\n\
    \  sum(xs * xs)\n}\n", "\n  xs <- c(xs[1], xs[2])\n  d <- xs[1] * xs[2] - xs[2]\
    \ * xs[1]\n  if (d > 0) return(list(xs[1] = -d, xs[2] = -d))\n  if (d < 0) return(list(xs[1]\
    \ = -d, xs[2] = d))\n  return(list(xs[1] = 0, xs[2] = d))\n}\n", "\n    y <- xs[[1]]\n\
    \    if (length(xs) > 1) y <- c(0, y)\n    y <- y[1]\n    if (y < 0) y <- c(y,\
    \ 0)\n    if (y > 0) y <- c(y, 1)\n    y\n}\n", "\n  xs <- c(xs[1], diff(xs, 2))\n\
    \  xs[1] + xs[2] * xs[length(\n    xs) - 1]\n}\n</cell>\n<cell>\nderivative(c(1,\
    \ 2, 3))\n</cell>\n<cell>", "\n  return(\n    xs[1]*x[1]^2 + xs[2]*x[1]*x[2] +\
    \ xs[3]*x[1]*x[3] + \n    xs[1]*x[1]*x[2]*x[3] + xs[2]*x[2]^2 + xs[3]*x[2]*x[3]\n\
    \  )\n}", "\n  xs <- as.vector(xs)\n  \n  # Find length of xs.\n  n <- length(xs)\n\
    \  \n  # Reshape xs.\n  x <- rep.int(rep(1, n), x)\n  \n  # Return derivative\
    \ of xs.\n  y <- rep(0, n)\n  \n  for(i in 2:n)\n    y <- c(y, xs[i - 1] * xs[i])\n\
    \  \n  y\n}\n</cell>\n<text>\nLet's test our derivative function by comparing\
    \ it to our result from calculating the derivative manually. First, we have to\
    \ create a vector to pass into the derivative function.\n\n\n</text>\n<cell>",
  "\n  \n  # Return derivative of polynomial in same form.\n  # The first element\
    \ is xs[0]\n  # The second element is the sum of the first two, second two, etc.\n\
    \  \n  # Get list of coefficients \n  coeffs <- as.vector(c(xs[[1]], rev(tail(xs,\
    \ 2))))\n  \n  # Get length of coefficients list\n  coeffsLength <- length(coeffs)\n\
    \  \n  # Define function to multiply by coefficent and subtract from first element\n\
    \  newCoeffs <- function(x) { x * coeffs[[length(coeffs)]]  -\n    coeffs[[length(coeffs)\
    \ - 1]]  }\n  \n  return(newCoeffs)\n}\n", "\n    x <- 1\n    for(i in seq_along(xs)){\n\
    \        x <- xs[i]*x + xs[i+1]\n    }\n    return(x)\n}\n</cell>\n<text>\nLet's\
    \ plot the function $f(x) = x + x^2 + x^3$. We are going to use function plot\
    \ and function abline to plot points for function $f$ on the graph\n\n\n</text>\n\
    <cell>", "\n    xs <- coefficients(xs)\n    r <- rep(1, length(xs))\n    r <-\
    \ r - xs[1] * r\n    r\n}\n", "\n  # Recursive case: evaluate derivative of polynomial\
    \ with one variable.\n  # if there are more than one variables in the polynomial\n\
    \  if (length(xs)==1) {\n    # ys = c(rep(0,xs[1]+1),0)\n    ys <- c(0,0)\n  \
    \  # Evaluate the polynomial for one variable and add the result to ys.\n    #\
    \ ys[1] + xs[1] * xs[2] + xs[1] * xs[2]^2 + xs[1] * xs[2]^3 + ....\n    ys[1]\
    \ + xs[1] * xs[2] \n  } \n  else {\n    # Compute xs[1] + xs[2] * x + xs[3] *\
    \ x^2 + ....\n    ys <- xs[1] + xs[length(\n      xs\n    )] * xs[length(\n  \
    \    xs\n    )+1]\n    # Recursive case: evaluate derivative of polynomial with\
    \ one variable.\n    # if the polynomial contains more than one variable\n   \
    \ if (length(xs)>1) {\n      # ys = c(rep(0,xs[1]+1),\n      #       rep(0,xs[2]+1),\n\
    \      #       rep(0,xs[3]+1),\n      #       rep(0,xs[4]+1),\n      #       0)\n\
    \      ys <- c(0,rep(0,xs[length(\n        xs\n      )]+1),rep(0,xs[length(\n\
    \        xs\n      )]+1),rep(0,xs[length(\n        xs\n      )]+1))\n      # The\
    \ remaining variables should be evaluated from back to front.\n      ys[length(\n\
    \        ys\n      )-1] + \n        xs[length(\n          xs\n        )] * \n\
    \        xs[length(\n          xs\n        )-1] + \n        xs[length(\n     \
    \     xs\n        )] * xs[length(\n          xs\n        )-2] + \n        xs[length(\n\
    \          xs\n        )] * xs[length(\n          xs\n        )-3] + \n      \
    \  xs[length(\n          xs\n        )] * xs[length(\n          xs\n        )-4]\n\
    \    } \n  }\n  # Return derivative of polynomial in xs.\n  return(ys)\n}", "\n\
    \  # Return first derivative as a vector.\n  deriv <- c(1, xs[2])\n  # Return\
    \ second derivative as a vector.\n  deriv <- c(deriv, xs[1])\n  # Return result\
    \ as a vector.\n  return(deriv)\n}\n", "\n  ys <- c(xs[1] * (xs[2] * xs[3]) +\
    \ (xs[2] * (xs[3] * xs[4]) - xs[4] * xs[3]), \n           xs[1] * (xs[2] * xs[4])\
    \ - (xs[2] * (xs[3] * xs[5]) - xs[4] * xs[3]), \n           xs[2] * (xs[3] * xs[5])\
    \ - (xs[3] * xs[4] * xs[5]) - (xs[4] * xs[5] * xs[6]))\n  return(c(xs[1], xs[2],\
    \ ys[1], ys[2]))\n}\n", "\n  stopifnot(length(xs) == 3)\n  ys <- c(rep(0,1), xs[1],\
    \ xs[2] * xs[1])\n  ys[1] <- xs[1]\n  ys[2] <- xs[2]\n  ys <- ys[-1]\n  return(ys)\n\
    }\n", "\n    n <- length(xs)\n    d <- c(1, (n - 1) * xs[-1])\n    xs[1:(n-1)]\
    \ <- xs[-(n-1)] - (xs[-1] - xs[-(n-1)]) * d\n    return(xs)\n}\n", "\n    stopifnot(length(xs)\
    \ > 0)\n    deriv <- c()\n    for(i in 2:length(xs)) {\n        deriv <- c(deriv,\
    \ sum(xs[:i]))\n    }\n    deriv\n}\n", "\n  # TODO: Add your code\n  # return\
    \ c()\n}\n</cell>\n<cell>", "\n  result <- rep(NA_real_, length(xs))\n  result[1L]\
    \ <- 1\n  for (i in seq(2L, length(xs))) {\n    result[i] <- result[i-1] * xs[i]\n\
    \  }\n  result\n}\n", "\n  xs <- substitute(xs)\n  n <- length(xs)\n  if (n <\
    \ 1) {\n    return(call(\"c\", xs))\n  } else {\n    d <- rep(1L, n)\n    for\
    \ (i in seq(from=n, to=n, by=-1)) {\n      d[i] <- -1\n    }\n    return(call(\"\
    c\", xs) - d)\n  }\n}\n", "\n  # Get the derivative in reverse order.\n  derivatives\
    \ <- numeric()\n  derivatives[1] <- c(xs[2])\n  for(i in 3:length(xs)) {\n   \
    \ derivatives[i] <- c(derivatives[i-1], xs[i] * derivatives[i-2])\n  }\n  derivative\n\
    }\n</code>\nHere's our example polynomial:\n<code>\nx <- c(1, 2, 3)\n</code>\n\
    We can get the derivative and plot the results:\n<code>", "\n  xs <- c(xs[1],\
    \ 1, xs[2])\n  return(c(xs[1] + xs[2], xs[2], 1))\n}\n", "\n  # The first term\
    \ is 1\n  xs[1]\n}\n", "\n  if(length(xs) == 0) return(0)\n  sum <- 0\n  for(i\
    \ in 1:length(xs)) {\n    for(j in 1:i) {\n      sum <- sum + xs[j] * xs[i]\n\
    \    }\n  }\n  return(sum)\n}", "\n  f <- xs[1] + xs[2] * xs[3] + xs[4] * xs[3]^2\
    \ + xs[5] * xs[3]^3\n  return(list(xs[1] = 1, xs[2] = xs[2], xs[3] = xs[3], xs[4]\
    \ = xs[4], xs[5] = xs[5], f = f))\n}\n", "\n  x <- x[1]\n  xs <- c(xs[2], x[1]^2,\
    \ x[1]*x[2], x[2], xs[1]^2, xs[1])\n  length(xs) <- length(xs) - 1\n  sapply(xs,\
    \ function(x) {\n    x <- x^2\n    sum(xs) * x\n  })\n}\n", "\n  mx <- length(xs)\n\
    \  mx\n}\n", "\n\txs <- substitute(xs)\n\tx <- as.numeric(sub(\"\\\\^\", \"\"\
    , deparse(xs)))\n\tres <- rep(NA_real_, length(xs))\n\tres[1] <- 1\n\tfor(i in\
    \ 2:length(xs)) res[i] <- xs[i] - xs[i-1] * x\n\treturn(as.c(res))\n}\n", "\n\
    \    diff(c(head(xs, -1), tail(xs, -1)))\n}\n</cell>\n<text>\nNow that we have\
    \ our derivative function, we will be able to derive the gradient of a function\
    \ given some points (xs).\n\n\n</text>\n<cell>", "\n  n <- length(xs)\n  if(n\
    \ == 0) return(numeric(0))\n  if(n == 1) return(c(numeric(1)))\n  \n  # Calculate\
    \ a polynomial with coeficients in reverse order.\n  # i.e. x[1] + x * x^2 + ...\n\
    \  # Reverse order here is to ensure that x[0] holds the coefficient of x.\n \
    \ xs <- rev(sort(xs))\n  \n  # Use linear regression to estimate derivative.\n\
    \  fm <- lm(x ~ poly(xs, n), data = data.frame(x))\n  \n  return(c(coef(summary(fm))[1],\
    \ coef(fm)$f[1]))\n}\n\nderiv(c(1, 2, 3, 4, 5))\nderiv(c(1, 2, 3, 4))\n</code>\n\
    Output:\n<code>\n> deriv(c(1, 2, 3, 4, 5))\n[1]  4  9 12  9\n> deriv(c(1, 2, 3,\
    \ 4))\n[1] 6\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks. This is super helpful.\
    \ I like the approach. I'm a little confused by your comment \"# Reverse order\
    \ here is to ensure that x[0] holds the coefficient of x.\" Why is x needed? Shouldn't\
    \ the coefficient of x be available as x[0] regardless of where it is in the vector?\n\
    <|/ c |>\n<| c |>\nIt is not necessary, but it is better programming practice.\
    \ `xs[1]` always holds the coefficient of x, so `xs[0]` is redundant. `lm` calculates\
    \ the coefficient of x based on the first n coefficients (the nth coefficient\
    \ is what matters), and your `deriv` function assumes the coefficient of x is\
    \ at index `n`, but that is not always the case. Hence, it is better to reverse\
    \ the coefficients so that `xs[0]` holds the coefficient of x, so that `lm` will\
    \ work as expected.\n<|/ c |>\n<| c |>\nI think I get what you are saying. So\
    \ what you are saying is that because xs[0] is already the coefficient of x, lm()\
    \ does not need me to reverse the order of the vector. Is that correct?\n<|/ c\
    \ |>\n<| c |>\nYes, that is correct. You are free to choose whatever order you\
    \ like, but for clarity it is best to stick to the convention of x[0] holding\
    \ the coefficient of x.\n<|/ c |>\n<| a dscore=0 |>\nFor what it's worth, I think\
    \ you might get the same results by simply doing this:\n<code>\nf(x) <- x\nderiv\
    \ <- function(x) c(numeric(length(x)), f(x))\n</code>\nOr, if you don't want the\
    \ intermediate variable:\n<code>\nderiv <", "\n  xs <- c(xs[-3L], xs[-2L], xs[-1])\n\
    \  out <- rep(0, length(xs))\n  out <- c(xs[1] * xs[2L], xs[2L] * xs[1], xs[3]\
    \ * xs[2L])\n  out <- out / sum(out)\n  return(out)\n}\n</cell>\n<cell>", "\n\
    \  c(xs[1] - xs[2], xs[2] + xs[3])\n}\n", "\n  return( c(xs[1], xs[2]*x[1]*xs,\
    \ xs[3]*x[1]^2*xs) )\n}\n", "\n  if(nrow(xs) != 1) stop(\"Expecting a column vector\"\
    )\n  x <- col(xs)[1]\n  dx <- xs[1]\n  for(i in 2:nrow(xs)) {\n    dx <- dx *\
    \ xs[i]\n  }\n  dx\n}\n", "\n  rep(NA, length(xs) - 1)\n}\n\nderivative <- function(xs)\
    \ {\n  return(rep(NA, length(xs) - 1))\n}\n</code>\n<|/ a |>\n<| a tags=derivative,r\
    \ dscore=1 |>\n<code>", "\n    xs[length(which(xs==0))]\n}\n", "\n    x <- xs\n\
    \    out <- rep(NA)\n    for (i in seq_along(xs)) {\n        out <- c(out, c(x[seq(1,\
    \ i)] - x[seq(i, 1, -1)] * x[i-1]))\n    }\n    out\n}\n</cell>\n<cell>", "\n\
    \  x <- xs[1]\n  y <- xs[2]\n  deriv <- rep(NA, n)\n  deriv[1] <- x\n  for (i\
    \ in 3:n) {\n    deriv[i] <- x * deriv[i - 1] + y * deriv[i - 2]\n  }\n  deriv\n\
    }\n</code>\nNow we can find the roots of this polynomial by finding x where derivative\
    \ is equal to zero.\n<code>\nroots <- function(x) {\n  d <- derivative(c(x, x^2))\n\
    \  d[1]\n  which(d==0)\n}\n</code>\nWe can now draw a line through the roots:\n\
    <code>\nplot(x=0, y=0, xlim=c(0,5), ylim=c(0,5))\nplot(function(x) x, 0, xlim=c(0,5),\
    \ ylim=c(0,5), type=\"l\", lwd=2)\nabline(0,0)\n</code>\n\n<code>\nxs <- roots(3)\n\
    xs <- c(xs, xs[-1])\nlines(xs, xs, col=\"red\")\n</code>\n\n<code>\nplot(xs, xs)\n\
    </code>\n<|/ a tags=curve-fitting,r,linear-regression,statistics |>\n<| a dscore=0\
    \ |>\nHere's a solution using a linear approximation technique. The idea is to\
    \ fit a linear model using the data points you already have. The fit is made using\
    \ least squares (lm function). Note that lm is non-parametric, i.e. it fits a\
    \ linear model using a straight line.\nI then take the same set of data points\
    \ and use these as the input for the linear model fit.\n<code>\ndata <- c(1, 3,\
    \ 2, 5, 4, 3, 6)\n\nx1 <- seq_along(data) - 0.5\nx2 <- data\n\nfit <- lm(y~x1+x2,\
    \ data=data.frame(x1=x1, x2=x2))", "\n  xs <- c(xs[1], xs[2], xs[3])\n  deriv\
    \ <- function(x) {\n    2 * x\n  }\n  deriv(c(xs[1], xs[2], xs[3])) - xs[1] +\
    \ xs[2] * x + xs[3] * x^2\n}\n</cell>\n<cell>\nderivative (c(1,2,3))\n</cell>\n\
    <cell>\nderivative(c(1,2,3))\n</cell>\n<cell>", "\n    if (length(xs) == 1) {\n\
    \        c(0)\n    } else {\n        xs %% 1\n    }\n}\n", "\n  stopifnot(length(xs)\
    \ == length(c(1, 2)))\n  if (length(xs) == 1) {\n    list(xs)\n  } else {\n  \
    \  if (length(xs) == 2) {\n      xs[1] - xs[2]\n    } else {\n      xs[1] - xs[2]\
    \ - xs[3]\n    }\n  }\n}\n", "\n  return(\n    c(xs[1], (xs[1] - xs[2]) * xs[3])\n\
    \  )\n}\n", "\n  c(1, diff(xs), diff(xs)^2)\n}\n", "\n  res <- c()\n  for (i in\
    \ seq(length(xs))) {\n    res <- c(res, xs[i] + xs[i + 1] * x)\n  }\n  return(res)\n\
    }\n", "\n  # xs[1] - xs[0] = xs[2] - xs[0] * xs[2]\n  # xs[2] - xs[0] * xs[1]\
    \ = xs[3] - xs[0] * xs[1] * xs[2]\n  # xs[3] - xs[0] * xs[1] * xs[2] = xs[4] -\
    \ xs[0] * xs[1] * xs[2] * xs[3]\n  # xs[4] - xs[0] * xs[1] * xs[2] * xs[3]\n \
    \ # xs[1] - xs[0] * xs[1] * xs[2] * xs[3]\n  # xs[4] - xs[0] * xs[1] * xs[2] *\
    \ xs[3] * xs[5]\n  # xs[4] - xs[0] * xs[1] * xs[2] * xs[3] * xs[5] * xs[6]\n \
    \ # xs[4] - xs[0] * xs[1] * xs[2] * xs[3] * xs[5] * xs[6] * xs[7]\n  # xs[4] -\
    \ xs[0] * xs[1] * xs[2] * xs[3] * xs[5] * xs[6] * xs[7] * xs[8]\n  xs[1] - xs[0]\
    \ * xs[2]\n  # xs[1] - xs[0] * xs[2] * xs[3]\n  # xs[1] - xs[0] * xs[2] * xs[3]\
    \ * xs[4]\n  # xs[1] - xs[0] * xs[2] * xs[3] * xs[4] * xs[5]\n  # xs[1] - xs[0]\
    \ * xs[2] * xs[3] * xs[4] * xs[5] * xs[6]\n  # xs[1] - xs[0] * xs[2] * xs[3] *\
    \ xs[4] * xs[5] * xs[6] * xs[7]\n  # xs[1] - xs[0] * xs[2] * xs[3] * xs[4] * xs[5]\
    \ * xs[6] * xs[7] * xs[8]\n  # xs[1] - xs[0] * xs[2] * xs[3] * xs[4] * xs[5] *\
    \ xs[6] * xs[7] * xs[8] * xs[9]\n}\n", "\n  # Initialize polynomial\n  xs <- as.vector(xs)\n\
    \  d <- c()\n  for(i in seq(1, length(xs))) {\n    d <- c(d, xs[i])\n  }\n  return(d)\n\
    }\n", "\n  if (length(xs) <= 3) {\n    stop(\"Derivative's argument must be a\
    \ list with at least 3 coefficients.\");\n  }\n  z <- c();\n  z[1] <- 1;\n  for\
    \ (i in 2:length(xs)) {\n    z[i] <- xs[i] * z[i - 1];\n  }\n  z\n}\n</cell>\n\
    <cell>", "\n  ys <- numeric(0)\n  k <- length(xs)\n  for (i in 1:k) {\n    if\
    \ (i == 1) {\n      ys <- c(ys, xs[1])\n    } else if (i == k) {\n      ys <-\
    \ c(ys, xs[k])\n    } else {\n      ys <- c(ys, xs[i] * xs[k + 1])\n    }\n  }\n\
    \  return(ys)\n}\n</cell>\n<text>\nNow let's test our new function:\n\n\n</text>\n\
    <cell>", "\n  if (length(xs) > 2) {\n    stop(\"Not enough coefficients!\")\n\
    \  }\n  if (length(xs) == 1) {\n    return(c(1, xs^2))\n  }\n  x1 <- xs[1]\n \
    \ x2 <- xs[2]\n  x3 <- xs[3]\n  x4 <- xs[4]\n  return(c(x1*x2, x1*x3, x1*x4, x2*x3,\
    \ 2*(x1^2)*x4, 2*(x1^2)*x3 + 2*(x2^2)*x4, 2*(x2^2)*x3 + 2*(x1^2)*x4, x1*x3))\n\
    }\n</code>\nAs you can see you can now use derivative(c(1, 2, 3, 4, 5)) to get\
    \ c(1, 4, 9, 25, 35) and derivative(c(1, 2, 3)) to get c(2, 6) and derivative(c(3,\
    \ 4, 5)) to get c(4, 10, 22).\n<|/ a tags=algebra,polynomial-math,r |>\n<| c |>\n\
    I'm trying your solution and I can't get it to work.  \n\n    `x1 <- xs[1]\n \
    \   x2 <- xs[2]\n    x3 <- xs[3]\n    x4 <- xs[4]\n    return(c(x1*x2, x1*x3,\
    \ x1*x4, x2*x3, 2*(x1^2)*x4, 2*(x1^2)*x3 + 2*(x2^2)*x4, 2*(x2^2)*x3 + 2*(x1^2)*x4,\
    \ x1*x3))`\n\nThis is what I get when I type your command in R:\n\n    `Error\
    \ in xs[4] : subscript out of bounds` \n\nI have my x values in an array xs[]\
    \ and I type\n\n    `x1 <- xs[1]\n    x2 <- xs[2]\n    x3 <- xs[3]\n    x4 <-\
    \ xs[4]\n    return(c(x1*x2, x1*x3, x1*x4, x2*x3, 2*(x1^2)*x4, 2*(x1^2)*x3 + 2*(x2^2)*x4,\
    \ 2*(x2^2)*x3 + 2*(x1^2)*x4, x1*x3))`\n\nAnd I get the same error.\n<|/ c |>\n\
    <| c |>\n: Your function expects a vector (or list) of x's, not the values of\
    \ a variable. If you want to call the function with actual variables you have\
    \ to create a list containing the values of these variables and pass the list\
    \ to the function.\n<|/ c |>\n<| c |>\nAh, ok.  I think I understand what you\
    \ mean now.  Thanks.\n<|/ c |>\n<| a tags=algebra,polynomial-math,r |>\nThis is\
    \ called \"differentiation\", and there are several ways to do it (Wikipedia gives\
    \ a good overview of differentiation).\nOne way is to use gradients (and derivatives).\
    \ You start with differen", "\n  rev(coefs(poly(xs, 2))) * (2 - xs)\n}\n</code>\n\
    I realize that I am a noob, but I do enjoy learning so much. One of my favorite\
    \ parts about learning R is that it helps you to solve problems like this. I hope\
    \ this helps someone.\n<|/ a dscore=3 |>\n<| a tags=numerical-integration,math,r\
    \ |>\nI wrote a very simple function to evaluate the definite integral of a polynomial:\n\
    <code>\nintegrate_poly <- function(xs,p,a,b,tol=1e-7){\n  if(abs(a-b)<tol)stop(\"\
    'a' and 'b' are too far apart.\")\n  if(length(xs)<=2){\n    return(0)\n  }\n\
    \  if(length(xs)==2){\n    return(integrate(f=p^2*xs[1],lower=a,upper=b)$value)\n\
    \  }\n  if(length(xs)==3){\n    return(integrate(f=p*xs[2]*(1-xs[1]),lower=a,upper=b)$value)\n\
    \  }\n  if(length(xs)==4){\n    return(integrate(f=p*xs[3]+p*xs[2]*(xs[1]-1)*(1-xs[1]),lower=a,upper=b)$value)\n\
    \  }\n  if(length(xs)==5){\n    return(integrate(f=p*xs[3]+p*xs[2]*(xs[1]-1)*(1-xs[1])+p*xs[1]*(xs[2]-1)*(1-xs[2]),lower=a,upper=b)$value)\n\
    \  }\n  if(length(xs)==6){\n    return(integrate(f=p*xs[3]+p*xs[2]*(xs[1]-1)*(1-xs[1])+p*xs[1]*(xs[2]-1)*(1-xs[2])+p*xs[0]*(xs[3]-1)*(1-xs[3])+p*xs[1]*(xs[2]-1)*(xs[3]-1)*(1-xs[3])+p*xs[0]*(xs[1]-1)*(xs[4]-1)*(1-xs[4])+p*xs[2]*(xs[0]-1)*(1-xs[4])+p*xs[1]*(xs[3]-1)*(1-xs[3])+p*xs[0]*(xs[2]-1)*(xs[4]-1)*(1-xs[4])+p*xs[2]*(xs[0]-1)*(1-xs[4])+p*xs[1]*(xs[3]-1)*(1-xs[3])+p*xs[0]*(xs[2]-1)*(xs[4]-1)*(1-xs[4]),lower=a,upper=b)$value)\n\
    \  }\n  if(length(xs)==7){\n    return(integrate(f", "\n    s <- sapply(xs, function(x)\
    \ c(x))\n    s[1] - s[2] / (s[1] - s[2])\n}\n</code>\n<|/ a tags=polynomials,r,derivative\
    \ |>\n<| c |>\nThanks Stephen. I ran this on the example provided by OP. I get\
    \ `[1] 3.600000000`. What am I missing?\n<|/ c |>\n<| c |>\nI'm getting 3.59755.\
    \ Not sure what the algorithm is doing, but I'm guessing it has something to do\
    \ with how R is storing the polynomials. Maybe someone can explain how this works.\n\
    <|/ c |>\n<| c |>\nThat does seem odd. I'm going to try and track it down. Thanks\
    \ for the help!\n<|/ c |>\n<| c |>\nI ran it again with some better data, and\
    \ the answer I get is 3.597550000. This answer doesn't seem to account for all\
    \ the coefficients in the polynomial `c(3, 2, 8, 6, 5, 1, 4)`. Any ideas?\n<|/\
    \ c |>\n<| a dscore=2 |>\nAnother base R option:\n<code>\nf <- c(3, 2, 8, 6, 5,\
    \ 1, 4)\npoly1 <- polynom(f, 3)\npoly1", "\n    diff(c(coef(as.vector(xs))), 2)\n\
    }\n", "\n    xs\n}\n", "\n  x <- xs[1]\n  xs <- tail(xs, -1)\n  x + (x * (xs -\
    \ x))\n}\n", "\n  x <- tail(xs, 1)\n  xs <- head(xs, -1)\n  c(x[1] - x[1], x*xs[1],\
    \ x[2]*x[2] + x[3]*x[3]*x[3] + x[4]*x[4]*x[4] + x[5]*x[5]*x[5])\n}\n", "\n  res\
    \ <- numeric(length(xs))\n  for(i in seq_along(xs)) {\n    res[i] <- c(xs[i -\
    \ 1] * xs[i], 1)\n  }\n  res\n}\n", "\n  if(xs[1] == 0) stop(\"derivative of constant\"\
    )\n  n <- length(xs)\n  if(n == 1) return(xs[1]) # constant -- single derivative\n\
    \  if(n == 2) return(xs[1] * xs[2]) # constant times x\n  if(n == 3) return(xs[1]\
    \ * xs[2] * xs[3])\n  if(n == 4) return(xs[1] * xs[2] * xs[3] * xs[4])\n  if(n\
    \ == 5) return(xs[1] * xs[2] * xs[3] * xs[4] * xs[5])\n}\n", "\n  \n  xs <- c(xs[1],xs[2])\n\
    \  \n  xs[1] <- xs[1] - xs[1] * xs[3]\n  xs[2] <- xs[2] - xs[2] * xs[3]\n  \n\
    \  return(c(xs[1],xs[2]))\n}\n\n", "\n  stopifnot(length(xs) == ncoef(x))\n  d\
    \ <- rep(NA_real_, length(xs))\n  for(i in 1:ncoef(x)) {\n    d[i] <- x[i]\n \
    \ }\n  d\n}\n", "\n  x <- coef(xs)\n  x <- x[length(x)]\n  if (x == 0)\n    stop(\"\
    No coefficient of x^0 in polynomial\")\n  x <- 1\n  out <- rep(NA_real_, 0)\n\
    \  out <- c(out, x)\n  out <- c(out, x^2)\n  out <- c(out, x^3)\n  out <- c(out,\
    \ x^4)\n  out <- c(out, x^5)\n  out <- c(out, x^6)\n  out <- c(out, x^7)\n  out\
    \ <- c(out, x^8)\n  out <- c(out, x^9)\n  out <- c(out, x^10)\n  out <- c(out,\
    \ x^11)\n  out <- c(out, x^12)\n  out <- c(out, x^13)\n  out <- c(out, x^14)\n\
    \  out <- c(out, x^15)\n  out <- c(out, x^16)\n  out <- c(out, x^17)\n  out <-\
    \ c(out, x^18)\n  out <- c(out, x^19)\n  out <- c(out, x^20)\n  return(out)\n\
    }\n</cell>\n<cell>", "\n  reformulate(poly::derivative(xs, 2), \"c\", degree(xs))\n\
    }\n</code>\n<|/ a tags=polynomial-math,r |>\n<| a dscore=1 |>\nI wrote a function\
    \ that takes one vector and produces the derivative polynomial:\n<code>", "\n\
    \  x <- x[1]\n  y <- rep(NA, length(xs))\n  y[[1]] <- 1\n  for(i in seq_along(xs)\
    \ - 1) {\n    y <- c((y[[1]] * x) ^ i, y)\n  }\n  return(y)\n}\nderivative(c(3,\
    \ 4, 5))", "\n    function(x) {\n        res <- 0\n        for (i in 1:length(xs))\
    \ {\n            res <- res + xs[i] * x\n        }\n        res <- res / xs[length(xs)]\
    \ * x\n        res\n    }\n}\n", "\n  n <- length(xs)\n  if (n == 1) {\n    x\
    \ <- xs[1]\n    c(x, 1)\n  } else if (n == 2) {\n    x <- xs[1]\n    c(x, x[2])\n\
    \  } else {\n    dx <- c(xs[2:(n-2)], rep(0,(n-2)))\n    x <- xs[1]\n    c <-\
    \ c(0, x[2:(n-1)])\n    x <- xs[2:(n-1)]\n    derivative_out <- c(c(dx,x), derivative(c(x)))\n\
    \    sort(derivative_out)\n  }\n}\n</code>\nSome functions in R that will help\
    \ you:\n\n?derivative\n?c\n?sort\n?rep\n?ifelse\n?if\n?length\n?sort\n\nI hope\
    \ this helps.\n<|/ a tags=r,polynomials dscore=1 |>\n<| a dscore=0 |>\nIf you're\
    \ looking for an efficient way to evaluate a polynomial, the best way to do it\
    \ is with Taylor series expansions. \nThe series expansion for x^n is\n<code>\n\
    x^n+(-1)^(n-1)*x^(n-2)+(-1)^(n-2)*x^(n-3)+...+(-1)^0*x^0\n</code>\nWhen you have\
    \ a polynomial in the form nth terms with coefficients, you only need to compute\
    \ nth terms.\nFor example, if you want to evaluate the 3rd degree polynomial x^3\
    \ + x^2 + x +1 then you compute x^3 + x^2 + x + 1 three times and add them to\
    \ get a vector x^3 + x^2 + x + 1.\n<|/ a tags=r,polynomials |>\n<| a dscore=0\
    \ |>\nHere's a vectorized way of calculating the derivative in R:\n<code>", "\n\
    \  f <- function(x, xi, xs) {\n    stopifnot(length(xs) == length(xi), \"Arguments\
    \ not of equal length\")\n    yi <- xs[1L]\n    xi <- xi[2L]\n    ys <- rep.int(yi,\
    \ length(x))\n    ys[seq_along(x)] <- xs[xi]\n    sum(xi * ys)\n  }\n  grad <-\
    \ function(f, x, xi) {\n    stopifnot(length(xs) == length(xi), \"Arguments not\
    \ of equal length\")\n    xi <- xi[2L]\n    ys <- f(xs, x, xi)\n    yi <- xi[1L]\n\
    \    ys[yi - 1] * yi\n  }\n  g(xs, x, xi)\n}\n</code>\nThe derivative is a function\
    \ of two scalar values, x, and the value of the current variable xi. The scalar\
    \ value represents the current value of xi, and the vector of values represents\
    \ the values of x at the current value of xi. Here's an example of a derivative\
    \ of the polynomial:\n<code>\n> derivative(c(3, 1, 2, 4, 5))", "\n  if(length(xs)\
    \ == 1) stop(\"need one coefficient\")\n  if(!is.numeric(xs)) stop(\"need numeric\
    \ coefficients\")\n  if(xs[1] < 0) stop(\"need non-negative first coefficient\"\
    )\n\n  deriv <- c(xs[1], 0)\n  for(i in 2:length(xs))\n    deriv <- c(deriv, xs[i]\
    \ * deriv)\n\n  deriv\n}\n</code>\n<|/ a tags=polynomial-math,r dscore=5 |>\n\
    <| c |>\nThis is a great example; I used it for my own implementation of `expand.grid`\
    \ which I called `expand.grid2`. See my answer below to see what I did.\n<|/ c\
    \ |>\n<| c |>\nNice solution!  I ran into a problem when I tried to pass my own\
    \ function to this function.  My function returned a vector with one element and\
    \ I tried to pass it to the `apply` function.  I fixed it by adding `SIMPLIFY\
    \ = F` to `lapply`.\n<|/ c |>\n<| c |>\n`Error in x[i] * x[i + 1] : non-numeric\
    \ argument to binary operator`\n<|/ c |>\n<| a tags=polynomial-math,r |>\nThe\
    \ accepted answer has a couple of problems that I ran into (and others seem to\
    \ have). \nThe first problem is that the code doesn't handle polynomials whose\
    \ coefficients are all negative (e.g., polynomials with all but the first coefficient\
    \ negative).  Also, the code doesn't handle the case where coefficients are all\
    \ zero.\nThe second problem is that the code doesn't handle polynomials with an\
    \ odd number of coefficients.\nSo here is the code that handles both these problems:\n\
    <code>\nderivative <- function(x) {\n  if(!is.numeric(x)) stop(\"need numeric\
    \ coefficients\")\n  if(!all(x >=0)) stop(\"need non-negative coefficients\")\n\
    \n  deriv <- x[1] \n  for(i in 2:length(x))\n    deriv <- c(deriv, (x[i]/deriv)*deriv)\n\
    \n  deriv\n}\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4 |>\nHere's a more general\
    \ function that works for polynomials with an even number of terms.\n<code>\n\
    derivative2 <- function(x) {\n  if(!is.numeric(x)) stop(\"need numeric coefficients\"\
    )\n  if(!all(x >=0)) stop(\"need non-negative coefficients\")\n  if(length(x)\
    \ == 1) x <- c(1, x)\n\n  if(length(x)==1) return(x)\n\n  if(length(unique(x))%%2\
    \ == 1){\n    stop('need an even number of terms in the polynomial')\n  }\n  deriv\
    \ <- x[1]\n  for(i", "\n  if (length(xs) == 1)\n    rep(rep(1,xs[1]), xs[1]);\n\
    \  else {\n    rep(rep(0,xs[1]), length(xs)-1) + (xs[1]-1) * rep(c(1,-1),length(xs)-xs[1]);\n\
    \  }\n}\n", "\n  f <- function(x) (1 - x^2) / (2 * x^2)\n  dx <- f(xs[2])\n  return(c(xs[1],\
    \ dx^2, dx))\n}\n", "\n  f <- function(x, coef) { \n    xs <- coef * x\n    x\n\
    \  }\n  d <- function(x) {\n    f <- function(x, coef) {\n      xs <- coef * x\n\
    \      xs\n    }\n    coefs <- length(xs)\n    f <- lapply(xs, f)\n    f <- Reduce(function(x,\
    \ y) f(x, y), f)\n    f\n  }\n  list(d, f)\n}\n", "\n  n <- length(xs)\n  f <-\
    \ function(x, i) {\n    x <- xs[i]\n    if (i == 1) {\n      return(x)\n    }\n\
    \    x / (x + xs[i - 1])\n  }\n  return(Reduce(f, 1, xs))\n}\n", "\n  xs <- c(xs[1],\
    \ xs[2], xs[3])\n  sum(c(1, xs, xs[-1]))\n}\n", "\n  xs[length(xs) - 1] <- 0\n\
    \  xs <- c(1,xs)\n  ys <- rev(seq_along(xs))\n  deriv <- c(xs, rev(xs))\n  return(deriv)\n\
    }\n", "\n  ns <- length(unlist(xs))\n  if (ns == 1) return(unlist(xs))\n  else\
    \ return(c(unlist(xs), rep(0,ns-1)))\n}\n", "\n  xs <- substitute(xs)\n  xs <-\
    \ as.list(xs)\n  xs[1] <- as.numeric(xs[1])\n  res <- c()\n  res[1] <- xs[1]\n\
    \  res <- res[-1L] + xs[1] * res\n  for(i in 2L:length(xs)) {\n    res[i] <- xs[i]\
    \ * res[i - 1L]\n  }\n  as.polynomial(res)\n}\n</code>\n<|/ a |>\n<| a dscore=4\
    \ tags=polynomials,polynomials,r,polynomial-math,numerical-methods |>\nA slightly\
    \ different approach that relies on the fact that R does everything symbolically.\n\
    <code>\npoly <- function(x, coef, degree){\n    l <- length(coef) - degree\n \
    \   if(l < 0){\n        stop(\"Too few coefficients for given degree of polynomial\"\
    )\n    }\n    if(l > length(x)){\n        stop(\"Too many coefficients for given\
    \ degree of polynomial\")\n    }\n    poly <- numeric(degree)\n    poly <- poly[-1L]\
    \ + x[1] * poly\n    for(i in 2:l){\n        poly <- poly[-1L] + x[i] * poly\n\
    \    }\n    poly\n}\n</code>\n<|/ a |>\n<| a dscore=4 |>\nAnother option:\n<code>\n\
    poly <- function(x, degree){\n  degree<-as.integer(substitute(degree))\n  x<-substitute(x)\n\
    \  if(degree<1 || degree>length(as.list(x)))\n    stop(\"Degree out of bounds\"\
    )\n  poly <- numeric(degree)\n  poly[degree]<-x[degree]\n  for(i in 1:(degree-1)){\n\
    \    poly<-poly+as.list(x)[(i+1):degree]*(as.list(x)[degree])^(degree-i)\n  }\n\
    \  return(poly)\n}\n</code>\n<|/ a tags=polynomials,polynomials,r,polynomial-math,numerical-methods\
    \ |>\n<| c |>\nI used a similar approach to evaluate a polynomial at a certain\
    \ point. Just change `poly[degree]<-x[degree]` to `poly[degree]<-as.list(x)[degree]`\
    \ and then use `poly[1]` as your initial polynomial coefficient.\n<|/ c |>\n<|\
    \ a |>\nHere's an implementation using base:\n<code>\npoly <- function(x, degree){\n\
    \    degree<-as.integer(substitute(degree))\n    x<-substitute(x)\n    if(degree<1\
    \ || degree>length(x))\n        ", "\n  stopifnot(length(xs) == length(terms(xs)))\n\
    \  d <- numeric(length(terms(xs)))\n  d[1] <- 1\n  for(i in 2:length(terms(xs)))\
    \ {\n    d[i] <- (xs[i] + xs[i+1]) * d[i-1]\n  }\n  return(as.vector(d))\n}\n",
  "\n  # The function below is just a helper function that gets a vector\n  # of partial\
    \ derivatives.\n  get_derivatives <- function(xs) {\n    p <- c()\n    for (i\
    \ in 1:length(xs)) {\n      p = c(\n        p,\n        c(xs[i])\n      )\n  \
    \  }\n    return(p)\n  }\n  # Get the derivatives of xs and multiply them by x^2\
    \ to get\n  # the final vector.\n  derivs <- get_derivatives(xs)\n  return(\n\
    \    c(xs[1]) * derivs\n  )\n}\n", "\n    s <- diff(xs, 2)\n    r <- s[-1]\n \
    \   t <- c(0, r / s)\n    t <- c(t, rep(NA, length(r)))\n    names(t) <- paste(rep(\"\
    d\", length(r)), names(t), sep = \"-\")\n    t\n}\n</cell>\n<cell>", "\n  x <-\
    \ x[1]\n  xs <- tail(xs, 1)\n  deriv <- c(0, xs)\n  if (length(xs) > 2) {\n  \
    \  deriv <- c(deriv, 2 * xs - deriv)\n  }\n  if (length(xs) == 2) {\n    deriv\
    \ <- c(deriv, xs)\n  }\n  if (length(xs) == 1) {\n    return(c(0, x))\n  }\n \
    \ return(deriv)\n}\n", "\n  xs <- rep(NA, length(xs))\n  x <- 0\n  for (i in seq(length(xs)))\
    \ {\n    x <- xs[i]\n    xs[i] <- 1 - x / x\n  }\n  xs[length(xs)]\n}\n", "\n\
    \  x <- 0\n  y <- 0\n  dx <- numeric(length(xs) - 1)\n  dy <- numeric(length(xs)\
    \ - 1)\n\n  for (i in 1:(length(xs) - 1)) {\n    dx[i] <- 1\n    dy[i] <- xs[i]\n\
    \  }\n\n  return(c(dx, dy))\n}\n", "\n  lapply(xs, function(x){\n    x^2 - 2 *\
    \ x + 1\n  })\n}\n", "\n  n <- length(xs)\n  if (n == 1) {\n    return(c(1, xs[1]))\n\
    \  } else if (n > 1) {\n    return(c(2 * xs[n-1] - xs[n-2] + 1, xs[n-2]))\n  }\n\
    }\n", "\n  # Check argument type\n  if(!is.numeric(xs)) stop(\"xs must be numeric\"\
    )\n  # Return derivative\n  xs <- c(xs[-1])\n  xs[-length(xs)] * xs[-1]\n}\n",
  "\n  if(length(xs) < 1) stop(\"derivative requires at least 2 arguments\")\n  \n\
    \  if(length(xs) == 1) {\n    y <- xs[1]\n    return(list(x = 1, y = y))\n  }\
    \ else {\n    if(length(xs) == 2) {\n      y <- x[1]\n      x <- x[2]\n      return(list(x\
    \ = x, y = y))\n    } else {\n      x <- xs[2]\n      y <- xs[1]\n      return(list(x\
    \ = x, y = y))\n    }\n  }\n}\n\n", "\n  d <- c()\n  for (i in 1:length(xs)) {\n\
    \    d[i] <- xs[i - 1] * xs[i]\n  }\n  return(d)\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
