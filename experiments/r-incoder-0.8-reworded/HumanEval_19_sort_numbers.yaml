name: HumanEval_19_sort_numbers
language: r
prompt: "# Input is a space-delimited string of numberals from 'zero' to 'nine'.\n\
  # Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\
  \ 'eight' and 'nine'.\n# Return the string with numbers sorted from smallest to\
  \ largest\n# >>> sort_numbers('three one five')\n# 'one three five'\nsort_numbers\
  \ <- function(numbers) {"
tests: "test_humaneval <- function() {\ncandidate <- sort_numbers\n    if(!identical(candidate(''),\
  \ '')){quit('no', 1)}\n    if(!identical(candidate('three'), 'three')){quit('no',\
  \ 1)}\n    if(!identical(candidate('three five nine'), 'three five nine')){quit('no',\
  \ 1)}\n    if(!identical(candidate('five zero four seven nine eight'), 'zero four\
  \ five seven eight nine')){quit('no', 1)}\n    if(!identical(candidate('six five\
  \ four three two one zero'), 'zero one two three four five six')){quit('no', 1)}\n\
  }\ntest_humaneval()"
completions: ["\n  numbers <- as.character(numbers)\n  numbers <- gsub(\" \", \"\"\
    , numbers)\n  numbers_sorted <- gsub(\"[^0-9]\", \" \", numbers)\n  sort(as.numeric(numbers_sorted))\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| a |>\nHere's a version that doesn't require\
    \ regular expressions:\n<code>\nsort_numbers <- function(num) {\n  num <- as.character(num)\n\
    \  num <- gsub(\" \", \"\", num)\n  num <- gsub(\"[^0-9]\", \" \", num)\n  num\
    \ <- as.numeric(num)\n  num <- sort(num)\n  paste(num, collapse = \" \")\n}\n\
    </code>\n<|/ a tags=r,sorting dscore=2 |>\n<| a |>\nHere is one way to do this:\n\
    <code>\nsort_numbers <- function(nums) {\n  nums <- as.character(nums)\n  nums\
    \ <- gsub(\" \", \"\", nums)\n  nums <- gsub(\"[^0-9]\", \" \", nums)\n  nums\
    \ <- gsub(\"\\\\s\", \" \", nums)\n  nums <- as.numeric(nums)\n  nums <- sort(nums)\n\
    \  paste(nums, collapse = \" \")\n}\n</code>\n<|/ a dscore=2 tags=r,sorting |>\n\
    <| a tags=r,sorting dscore=1 |>\nIf one really wants to sort the elements of the\
    \ string \"three one two\" by the integer value of the numbers, here is a function\
    \ that sorts the elements of the string by the integer value of the numbers (assuming\
    \ that the number has already been converted to an integer)\n<code>\nsort_numbers\
    \ <- function(s){\n    s <- strsplit(s, \"\\\\s+\")[[1]]\n    s <- unlist(lapply(s,\
    \ function(x) gsub(\"[^0-9]\", \"\", x)))\n    s <- sort(as.numeric(s))\n    paste(s,\
    \ collapse=\", \")\n}\n</code>\n<|/ a |>\n<| a tags=r,sorting dscore=0 |>\nAnother\
    \ solution without using regular expressions.\n<code>\nsort_numbers <- function(x)\
    \ {\n  s1 <- gsub(\" \", \"\", x)\n  s2 <- sapply(strsplit(s1, \"\\\\s+\"), function(x)\
    \ as.numeric(x)[1])\n  paste(s2, collapse = \" \")\n}\n\nsort_numbers(\"three\
    \ one two\")", "\n  numbers <- gsub(' ', '', numbers)\n  numbers <- gsub('^[[:digit:]]+',\
    \ '', numbers)\n  numbers <- gsub('[[:digit:]]+$', '', numbers)\n  numbers <-\
    \ gsub(' +', ' ') \n  numbers <- gsub('\\\\s', ' ', numbers)\n  numbers <- gsub('(\\\
    \\w)', '', numbers)\n  numbers <- sort(numbers)\n  numbers\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nHi Ramnath, thank you for your answer, it worked great! The only\
    \ problem is that it returns \"one two three\" instead of \"one three two\", and\
    \ I can't seem to figure out why...\n<|/ c |>\n<| c |>\nThanks for catching that.\
    \  I fixed it in the code.\n<|/ c |>\n<| a |>\nThe most straightforward way is\
    \ to do it with stringr::str_pad\n<code>\nstr_pad(sort(c(\"one\", \"two\", \"\
    three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")), 4, side=\"\
    left\")\n</code>\n<|/ a dscore=3 tags=sorting,r,string,sequence |>\n<| a |>\n\
    Here are some possibilities using stringi::stri_pad and tidyverse, with the caveats\
    \ mentioned in the comments:\n<code>\nlibrary(stringi)\nlibrary(tidyverse)\n",
  "\n  numbers <- gsub(\"[^0-9]\", \"\", numbers)\n  numbers <- sort(numbers)\n  numbers\
    \ <- paste(numbers, collapse = \" \")\n  numbers\n}\n\nsort_numbers(numbers)\n\
    [1] \"one three five\"\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThanks for\
    \ the answer, although it's not a complete solution. I'm trying to reproduce the\
    \ same exact output as you did in your answer. However I'm still struggling with\
    \ a couple of things. My actual string has multiple numbers, some are longer,\
    \ some are short, some are in different orders, some are missing a number (see\
    \ my updated question). Can you please take a look at that?\n<|/ c |>\n<| c |>\n\
    Okay I updated the answer, I hope it works for you. Let me know how it goes.\n\
    <|/ c |>\n<| c |>\nThis almost works! But when I enter a string like \"one three\
    \ five nine\" it gives me \"one three five nine nine\". It seems to only sort\
    \ by length of the numbers, I really need to sort by the order they appear. Sorry\
    \ for not clarifying that in my question.\n<|/ c |>\n<| c |>\nOkay I've updated\
    \ the answer again. Let me know how it goes.\n<|/ c |>\n<| c |>\nI think I solved\
    \ it with the solution of Aaron Digulla, which involves splitting up my string\
    \ into a character vector. Thanks again for all your help, though! I really appreciate\
    \ it!\n<|/ c |>\n<| a tags=r,sorting |>\nWe can use gsubfn\n<code>\nlibrary(gsubfn)\n\
    gsubfn(\"(\\\\d+) *\\\\1\", \n   ~sort(as.numeric(unlist(strsplit(., \"\\\\s\"\
    )))), str1)", "\n  numbers <- gsub(\" \", \"\", numbers)\n  numbers <- strsplit(numbers,\
    \ \" \")[[1]]\n  numbers[order(numbers)]\n}\n\nsort_numbers(\"two six one\")",
  "\n  \n  numbers <- strsplit(numbers, \" \")[[1]]\n  numbers <- numbers[order(numbers)]\n\
    \  numbers <- paste0(numbers, collapse = \" \")\n  \n  return(numbers)\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis is not exactly what I wanted. I edited my original post\
    \ to include an example where I wanted it sorted from smallest to largest\n<|/\
    \ c |>\n<| a tags=vector,r,sorting,list |>\nA solution using the dplyr package:\n\
    <code>\nlibrary(dplyr)\n\ndat <- data.frame(\n  values = c(3,8,5,2,4,6,1,7,9)\n\
    )\n\ndat %>%\n  mutate(\n    values = sort(values)\n  )\n\n  values\n1       1\n\
    2       2\n3       3\n4       4\n5       5\n6       6\n7       7\n8       8\n\
    9       9\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is not exactly what I wanted.\
    \ I edited my original post to include an example where I wanted it sorted from\
    \ smallest to largest\n<|/ c |>\n<| c |>\nYou want the *column* in `dat` to sort\
    \ based on the values in `dat$values`? Like this: `dat %>% mutate(values = sort(values))\
    \ %>% mutate(values = values) %>% mutate(values = values)`\n<|/ c |>\n<| a dscore=1\
    \ |>\nJust for fun...\n<code>\n> foo <- c(1,4,7,9,10,5,6,3,2)\n> sort(foo)\n[1]\
    \ 1 2 3 4 5 6 7 9\n</code>\nAnd if you're not interested in the actual data frame...\n\
    <code>\n> foo <- c(1,4,7,9,10,5,6,3,2)\n> foo <- sort(foo)\n> foo\n[1] 1 2 3 4\
    \ 5 6 7 9\n</code>\n<|/ a tags=vector,r,sorting,list |>\n<| a |>\nIn data.table:\n\
    <code>\nlibrary(data.table)\nDT <- data.table(value = c(3, 8, 5, 2, 4, 6, 1, 7,\
    \ 9))\nDT[order(value), ]\n</code>\nOr:\n<code>\nDT[order(value), value := value]\n\
    </code>\nThis can be modified to sort by another column as well.\n<|/ a tags=vector,r,sorting,list\
    \ dscore=1 |>\n<| a dscore=1 |>\n<code>\nnumbers = sort(c(1,4,7,9,10,5,6,3,",
  "\n  out <- list()\n  for (i in strsplit(numbers, \" \")[[1]]) {\n    out[[i]] <-\
    \ i\n  }\n  paste(sort(out), collapse = \" \")\n}\n", "\n  numbers <- gsub(\"\
    \ \", \"\", numbers)\n  numbers_sorted <- sort(numbers)\n  numbers <- paste0(numbers_sorted,collapse=\"\
    \ \")\n  return(numbers)\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=r,sorting |>\n\
    We can use mixedsort from gtools\n<code>\nlibrary(gtools)\nmixedsort(as.character(c('zero\
    \ one two three four five six seven eight nine')))", "\n  numbers <- sort(numbers)\n\
    \  return(paste(numbers, collapse = \" \"))\n}\n</code>\n<|/ a tags=r,sorting,string\
    \ dscore=0 |>\n<| a tags=r,sorting,string dscore=0 |>\nHere is another approach\
    \ with dplyr and stringr:\n<code>\nlibrary(dplyr)\nlibrary(stringr)\n", "\n  number_list\
    \ <- unlist(strsplit(numbers, split = ' '))\n  number_vector <- c(one = 1, two\
    \ = 2, three = 3, four = 4, five = 5, six = 6, seven = 7, eight = 8, nine = 9)\n\
    \  number_list <- \n    number_list %>% \n    as.numeric() %>%\n    sort(decreasing\
    \ = TRUE) %>%\n    paste(number_vector, collapse = ' ')\n  return(number_list)\n\
    }\n", "\n  numbers <- as.character(numbers)\n  sorted_numbers <- gsub(\" \", \"\
    \", numbers)\n  return(paste(sorted_numbers, collapse = \" \")) # paste takes\
    \ vectors as input\n}\n</code>\n<|/ a tags=regex,r |>\n<| a dscore=0 |>\nHere\
    \ is an option with gsubfn.  We match the digits (\\\\d+) from the start (^) of\
    \ the string, followed by one or more spaces, followed by one or more digits (\\\
    \\d+) captured as a group ((...)) followed by the rest of the characters (.*)\
    \ and replace with backreference (\\\\1) of the captured group\n<code>\nlibrary(gsubfn)\n\
    gsubfn('^(\\\\d+)\\\\s+(\\\\S+)$', ~ paste(sort(c(as.numeric(x[1]), as.numeric(x[2]))),\
    \ collapse=' '), str1)", "\n  numbers <- gsub('(^|[ ])(nine|zero|one|two|three|four|five|six|seven|eight|nine)([\
    \ ])([a-zA-Z]+|$)', \n                  paste0(\"\\\\1 \\\\2 \\\\3\"), numbers)\n\
    \  numbers <- gsub('([0-9])([ ])', paste0(\"\\\\1 \\\\2\"), numbers)\n  numbers\
    \ <- gsub('([a-zA-Z]+)($)', paste0(\"\\\\1 \"), numbers)\n  numbers\n}\n", "\n\
    \  if (any(numbers == 'zero')) stop('Not a valid number. Must start with a \"\
    zero\".')\n  if (any(numbers == 'nine')) stop('Not a valid number. Must start\
    \ with a \"nine\".')\n  if (any(grepl('[^0-9]', numbers))) stop('Not a valid number.\
    \ Must contain only numbers.')\n  numbers <- gsub(',', '', numbers)\n  numbers\
    \ <- sort(numbers)\n  return(paste(numbers, collapse = ' '))\n}\n", "\n  numbers\
    \ <- str_split(numbers, ' ')[[1]]\n  sort(numbers)\n}\n</code>\nYou can see this\
    \ in action in the following RStudio output:\n<|/ a dscore=4 tags=r |>\n<| a tags=r\
    \ dscore=3 |>\nI liked's answer, but found that \n<code>\npaste(sort(unlist(strsplit(x,\
    \ split=' '))), collapse=' ')\n</code>\nworked better for me because it preserved\
    \ the original spacing.\n<|/ a |>\n<| a |>\nThe simplest way that I found was\
    \ to first split the string into words (str_split), then convert each word into\
    \ a number using as.integer(). After that, you can simply sort the list using\
    \ sort(). \n<code>\nx <- c('zero one two three four five six seven eight nine')\n\
    sort(as.integer(str_split(x, ' ')[[1]]))\n\n[1] nine seven six five four three\
    \ two one zero\n</code>\n<|/ a dscore=3 tags=r |>\n<| a dscore=3 tags=r |>\nIf\
    \ you want to keep your input format you can do the following (if you do not need\
    \ any additional information from the input):\n<code>\nx <- c('zero one two three\
    \ four five six seven eight nine')\ny <- unlist(strsplit(x, \" \"))\ny", "\n \
    \ sorted_numbers <- gsub(\"(zero|one|two|three|four|five|six|seven|eight|nine)\"\
    , \"\", numbers)\n  sorted_numbers <- gsub(\"\\\\s+\", \" \", sorted_numbers)\n\
    \  sorted_numbers <- sorted_numbers[order(as.integer(sorted_numbers))]\n  return(paste(sorted_numbers,\
    \ collapse = \" \"))\n}\n", "\n  numbers <- as.numeric(numbers)\n  numbers_sorted\
    \ <- sort(numbers)\n  return(paste(numbers_sorted, collapse = \" \"))\n}\n</cell>\n\
    <text>\nExercise 4:\nWrite a function, sort_numbers_reverse(), that takes the\
    \ argument numbers containing the string\n\"three one five\" and sorts the numbers\
    \ in descending order from smallest to largest.\nThis should return \"five three\
    \ one\".\n\nHint: The function sort() may be useful in doing this.\n\nIn your\
    \ function definition, do not include print(numbers). Your function should return\
    \ the result without modifying the argument that calls the function.\n\n\n</text>\n\
    <cell>", "\n  num_vector <- as.numeric(unlist(strsplit(numbers, ' ', fixed = TRUE)))\n\
    \  num_vector <- sort(num_vector)\n  return(paste(num_vector, collapse = ' '))\n\
    }\n\nsort_numbers('three one five')", "\n    numbers <- gsub(\" \", \"\", numbers)\n\
    \    numbers <- gsub(\"\\\\s+\", \" \", numbers)\n    numbers <- gsub(\"(^ +)|(\
    \ +$)\", \" \", numbers)\n    numbers <- gsub(\"^\\\\s\", \"zero\", numbers)\n\
    \    numbers <- gsub(\"\\\\s+$\", \"nine\", numbers)\n    numbers <- gsub(\"\\\
    \\s\", \"zero \", numbers)\n    numbers <- gsub(\"\\\\s+\", \"nine \", numbers)\n\
    \    numbers <- gsub(\"^zero\", \"zero\", numbers)\n    numbers <- gsub(\"^nine\"\
    , \"nine\", numbers)\n    numbers <- gsub(\"^\", \"one\", numbers)\n    numbers\
    \ <- gsub(\"$\", \"two\", numbers)\n    numbers <- sort(numbers)\n    numbers\
    \ <- paste(numbers, collapse=\" \")\n    return(numbers)\n}\n", "\n    numbers\
    \ <- as.character(numbers)\n    out <- c()\n    for (i in 1:length(numbers)) {\n\
    \        if (numbers[i] %in% c('zero', 'one', 'two', 'three', 'four', 'five',\
    \ 'six', 'seven', 'eight', 'nine')) {\n            out <- c(out, numbers[i])\n\
    \        }\n    }\n    return(paste(sort(out), collapse = ' '))\n}\n</cell>\n\
    <cell>", "\n  numbers <- unlist(strsplit(numbers, \" \"))\n  numbers <- numbers[order(numbers)]\n\
    \  paste(numbers, collapse = \" \")\n}\n</cell>\n<cell>", "\n  numbers <- strsplit(numbers,\
    \ ' ')[[1]]\n  numbers <- sort(numbers)\n  paste0(numbers, collapse = ' ')\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThanks Alistair Robinson, what is the meaning of '[[1]]'?\
    \ I usually use '[, 1]' to subset a matrix and get column by column or row by\
    \ row. Why does [[1]] work?\n<|/ c |>\n<| c |>\nThe brackets indicate that you\
    \ want to extract a column or row, not the first element of the vector. The `[[1]]`\
    \ notation extracts the first element of a vector (or matrix or data.frame or\
    \ tibble or whatever).\n<|/ c |>\n<| c |>\nIt's not really an issue of sorting,\
    \ but more of how a vector is structured.  If you did `x <- c(1,2,3); x[1] # extract\
    \ the first element, which is 1`.  But `x <- c(1,3,5)`, then `x[1] # extract the\
    \ first element, which is `3`.  In `sort_numbers`, you're telling it to use `sort`,\
    \ which requires the vector to be a 1-dimensional vector (so a vector's `length`\
    \ must be 1)\n<|/ c |>\n<| c |>\nOh! Thanks Alistair Robinson, you have really\
    \ cleared out my confusion.\n<|/ c |>\n<| a |>\nThe issue is with sort() which\
    \ requires a vector, not a factor.  The following is an alternative approach to\
    \ sort the numbers.  It first converts your string into a numeric vector, then\
    \ sorts the numbers, converts back to a string and returns that as your output.\n\
    <code>\nsort_numbers <- function(numbers) {\n  numbers <- strsplit(numbers, \"\
    \ \")[[1]]\n  numbers <- as.numeric(numbers)\n  numbers <- sort(numbers)\n  paste0(numbers,\
    \ collapse = \" \")\n}\n</code>\n<|/ a dscore=0 tags=r |>\n<| c |>\nThanks MrFlick,\
    \ I did try this before but didn't use as.numeric(). This worked.\n<|/ c |>\n\
    <| a |>\nHere's a solution using gsub to replace each space with + and gsub to\
    \ replace each +  with a space before calling sort:\n<code>\nsort_numbers <- function(numbers)\
    \ {\n  numbers <- gsub(\" \", \"+\", numbers)\n  numbers <- gsub(\"\\\\+\", \"\
    \\\\ \", numbers)\n  numbers <- sort(numbers)\n  paste0(numbers, collapse = \"\
    \ \")\n}\n\nsort_numbers(\"one three ", "\n  numbers <- strsplit(numbers, ' ')[[1]]\n\
    \  numbers[order(numbers)]\n}\n</code>\n<code>\nsort_numbers('three one five')",
  "\n  numbers <- gsub(\" \", \"\", numbers)\n  numbers <- sort(numbers)\n  paste0(numbers,\
    \ collapse = \" \")\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nA bit of a hacky\
    \ way, but does get it done.  It's a bit too long, but it's concise and to the\
    \ point.  It requires no packages.\n<code>\nsort_numbers <- function(numbers)\
    \ {\n  numbers <- gsub(\" \", \"\", numbers)\n  numbers <- sort(numbers)\n  numbers\
    \ <- paste0(numbers, collapse = \" \")\n  numbers\n}\n</code>\nTesting:\n<code>\n\
    > sort_numbers(\"three one five\")\n[1] \"one three five\"\n> sort_numbers(\"\
    one three five\")\n[1] \"one three five\"\n> sort_numbers(\"two one five\")\n\
    [1] \"two one five\"\n> sort_numbers(\"three one five, two seven\")\n[1] \"one\
    \ three five, two seven\"\n> sort_numbers(\"two one five, three six, four eight\"\
    )\n[1] \"two one five, three six, four eight\"\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nThis isn't really a hacky way, it's just not what I'm looking for - I might\
    \ have to go with something like this. Thanks\n<|/ c |>\n<| c |>\n- it's hacky\
    \ because it is using the `sort` function that is in the base package.  As I said,\
    \ there are better ways to do this, but this answer doesn't require a package\
    \ - a hack or not.\n<|/ c |>\n<| c |>\nI understand it isn't a package solution,\
    \ I'm just looking for something that doesn't involve a package.\n<|/ c |>\n<|\
    \ c |>\n- this is basically what `sort()` is doing, but in a different way - it's\
    \ just not what you're looking for.\n<|/ c |>\n<| c |>\nI realize this is hacky,\
    \ but it is what I'm looking for, and it does what I'm looking for in a very concise\
    \ way, and I like that.  Thanks\n<|/ c |>\n<| a tags=r |>\nUse nchar to find the\
    \ lengths of numbers then paste them together then sort them.\n<code>\nx<-\"three\
    \ one five\"\ny<-\"one three five\"\nz<-\"two one five\"\nw<-\"three one five,\
    \ two seven\"\nsort(paste(nchar(unlist(strsplit(x,\" \"))),\n             ", "\n\
    \  numbers <- gsub(\"[[:punct:]]\", \"\", numbers)\n  numbers <- gsub(\"[[:digit:]]\"\
    , \"\", numbers)\n  numbers <- gsub(\"^[[:space:]]+\", \"\", numbers)\n  numbers\
    \ <- gsub(\"[[:space:]]+$\", \"\", numbers)\n  numbers <- numbers[order(as.numeric(numbers))]\n\
    \  paste(numbers, collapse = \" \")\n}\n\nsort_numbers(\"nine two nine\")", "\n\
    \  numbers <- str_split(numbers, ' ')\n  numbers <- sapply(numbers, function(n)\
    \ sort_number(n))\n  paste(numbers, collapse = ' ')\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nYour solution doesn't work: for the example `sort_numbers(\"three one\
    \ five\")` it returns `\"three\" \"one\" \"five\"`. Which is exactly the opposite\
    \ of what the OP asked for in the question.\n<|/ c |>\n<| a dscore=2 |>\nYou can\
    \ use the following function which splits the string on space, sorts the results,\
    \ and re-joins on space.\n<code>\nsort_numbers <- function(x){\n    s <- strsplit(x,\
    \ \" \")\n    s <- lapply(s, function(x) sort(as.numeric(as.character(x))))\n\
    \    paste(as.character(unlist(s)), collapse = \" \")\n}\n</code>\n<|/ a tags=sorting,r,algorithm\
    \ |>\n<| a |>\n<code>\nsort_numbers <- function(numbers){\n  numbers <- str_split(numbers,\
    \ \" \")\n  numbers <- sapply(numbers, function(n) sort(n)) # sort each number\n\
    \  paste(numbers, collapse = \" \")\n}\n</code>\n<|/ a tags=sorting,r,algorithm\
    \ dscore=2 |>\n<| a tags=sorting,r,algorithm |>\nHere's a solution using gsub\
    \ to convert numbers into strings and then ordering the strings, then converting\
    \ them back to numbers:\n<code>\nsort_numbers <- function(numbers){\n  numbers\
    \ <- gsub(\"([0-9])\", as.character(sort(as.numeric(gsub(\"\\\\s\", \"\", numbers)))),\
    \ numbers)\n  numbers <- as.numeric(numbers)\n  return(numbers)\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nAnother approach is using lapply to split the string\
    \ into numbers and then sort them. The code below is more efficient, since it\
    \ avoids sorting each number twice:\n<code>\nsort_numbers <- function(x) {\n \
    \ numbers_ <- unlist(strsplit(x, \" \"))\n  numbers_ <- sort(numbers_)\n  paste0(numbers_,\
    \ \" \")\n}\n</code>\n<|/ a tags=sorting,r,algorithm dscore=2 |>\n<| a |>\nHere's\
    \ an alternative approach:\n<code>\nsort_numbers <- function(x){\n  numbers_ <-\
    \ unlist(strsplit(x, \" \"))\n  numbers_ <- sort(numbers_)\n  paste0(numbers_,\
    \ \" \")\n}\n\n> sort_numbers(\"five one two\")\n[1] \"five\" \"", "\n  numbers\
    \ <- unlist(strsplit(numbers, ' '))\n  numbers <- numbers[order(numbers)]\n  paste(numbers,\
    \ collapse = ' ')\n}\n", "\n  split_numbers = strsplit(numbers, \" \")\n  num_list\
    \ <- mapply(function(x, n) paste(x, sort(rep(0:9, n)), sep=\"\"), split_numbers,\
    \ 1:9)\n  paste(num_list, rep(\" \", 9), sep=\"\")\n}\n\nsort_numbers(numbers)\n\
    </code>\n<|/ a tags=r |>\n<| a |>\n<code>\n    numbers = \"zero one two three\
    \ four five six seven eight nine\"\n    sort_numbers <- function(numbers) {\n\
    \      split_numbers = strsplit(numbers, \" \")\n      num_list <- mapply(function(x,\
    \ n) paste(x, sort(rep(0:9, n)), sep=\"\"), split_numbers, 1:9)\n      paste(num_list,\
    \ rep(\" \", 9), sep=\"\")\n    }\n    sort_numbers(numbers)\n</code>\n<|/ a tags=r\
    \ dscore=1 |>\n<| c |>\nThis solution uses `stringsAsFactors = FALSE`. Not a good\
    \ idea if you're going to use other functions where `stringsAsFactors` is set\
    \ to `TRUE` anyway.\n<|/ c |>\n<| a dscore=0 tags=r |>\nHere's another solution\
    \ which doesn't use mapply (but does use paste0). I would also use tidyverse or\
    \ data.table but I don't know if that's an option at this stage. \n<code>\nnumbers\
    \ <- \"zero one two three four five six seven eight nine\"\n\nsort_numbers <-\
    \ function(numbers) {\n  numbers <- strsplit(numbers, \" \")\n  num_list <- paste0(numbers,\
    \ sapply(numbers, function(x) sort(rep(0:9, length(x))))) %>% \n    paste(collapse\
    \ = \" \")\n  paste0(num_list, rep(\" \", 9), sep=\"\")\n}\n\nsort_numbers(numbers)\n\
    \n[1] \"zero one two three four five six seven eight nine\"\n</code>\n<|/ a |>\n\
    <| a tags=r |>\nA base R solution:\n<code>\nnumbers = \"zero one two three four\
    \ five six seven eight nine\"\nsplit_numbers <- strsplit(numbers, \" \")\nnum_list\
    \ <- sapply(split_numbers, function(x) paste(x, sort(rep(0:9, length(x)), sep=\"\
    \"), sep=\"\"))\npaste(num_list, rep(\" \", 9), sep=\"\")\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nThis is my take using strsplit and sapply:\n<code>\nnumbers <-\
    \ \"zero one two three four five six seven eight n", "\n  num <- strsplit(numbers,\
    \ \" \")[[1]]\n  num <- num[order(num)]\n  cat(paste(num,collapse = \" \"))\n\
    }\n", "\n  numbers <- gsub(\" \", \"\", numbers)\n  numbers <- numbers[gsub(\"\
    \\\\D\", \"\", numbers) == \"\"]\n  numbers <- sort(numbers)\n  numbers <- paste(numbers,\
    \ collapse=\" \")\n  return(numbers)\n}\n", "\n  numbers <- as.character(numbers)\n\
    \  numbers <- gsub(' ', '', numbers)\n  numbers <- gsub('[^0-9]', '', numbers)\n\
    \  numbers <- as.numeric(numbers)\n  numbers[order(numbers)] <- sort(numbers[order(numbers)])\n\
    \  paste(numbers, collapse=' ')\n}\n</code>\nThe final step is to call your function\
    \ from within your shiny app, like so\n<code>\noutput$text1 <- renderText({\n\
    \    sort_numbers(input$text1)\n})\n</code>\nHere's a shiny app that implements\
    \ the above\n<code>\nlibrary(shiny)\n\nshinyApp(\n    ui = fluidPage(\n      \
    \  textInput(\"text1\", \"enter your numbers\", \"three one five\"),\n       \
    \ textOutput(\"text1\")\n    ),\n    server = function(input, output) {\n    \
    \    output$text1 <- renderText({\n            sort_numbers(input$text1)\n   \
    \     })\n    }\n)\n</code>\n<|/ a |>\n<| c |>\nThank you so much! That works\
    \ perfectly on my machine. However, when I copy and paste the script into my shiny\
    \ app it says \"object 'sort_numbers' not found\" Any ideas?\n<|/ c |>\n<| c |>\n\
    You need to add the function to your R/Shiny app. See [here](https://shiny.rstudio.com/articles/modules.html)\
    \ for more information\n<|/ c |>\n<| c |>\nI tried to add it to the R/Shiny app\
    \ like so:\n<|/ c |>\n<| c |>\nshinyApp(\n    ui = fluidPage(\n        textInput(\"\
    text1\", \"enter your numbers\", \"three one five\"),\n        textOutput(\"text1\"\
    )\n    ),\n    server = function(input, output) {\n        output$text1 <- renderText({\n\
    \            sort_numbers(input$text1)\n        })\n    }\n)\n<|/ c |>\n<| c |>\n\
    But it still doesn't work. Do you have a complete shiny app that I could look\
    \ at? Maybe I missed something.\n<|/ c |>\n<| a |>\nHere is a solution with base\
    \ R\n<code>\ntext <- \"three, one and five\"\nnumber <- unlist(strsplit(text,\
    \ split = \", \"))\nnumber <- sapply(number, function(x){\n  as.numeric(gsub(\"\
    \\\\D\", \"\", x))\n})\nnumber <- sort(number)\npaste(number, collapse = \" \"\
    )\n</code>\n<|/ a dscore=0 tags=shiny,r |>\n<| c |>\nThank you so much! ", "\n\
    \  words <- strsplit(numbers, ' ')[[1]]\n  sorted_nums <- sort(words)\n  paste(sorted_nums,\
    \ collapse = ' ')\n}\n</code>\n<|/ a tags=sorting,r |>\n<| a dscore=0 |>\n<code>\n\
    \    library(dplyr)\n    library(stringr)\n    str_trim(sort(str_split(paste0(sample(letters,\
    \ 1000, replace = T), collapse = \" \"), \" \"), \n      decreasing = T))\n</code>\n\
    I used sample to generate a big string of random letters.\nThe paste0 function\
    \ concatenate all the strings in the vector together. \nThen I split the string\
    \ by space and sorted the list.\n<|/ a tags=sorting,r |>\n<| a dscore=0 |>\n<code>",
  "\n  numbers <- strsplit(numbers, ' ')[[1]]\n  numbers\n  cat(sort(numbers))\n}\n",
  "\n    out <- numbers[numbers != \"\"]\n    out <- as.numeric(out)\n    out <- sort(out)\n\
    \    out <- paste(out, \"  \", sep = \"\")\n    return(out)\n}\n", "\n  numbers\
    \ <- as.character(numbers)\n  numbers <- strsplit(numbers, \" \")[[1]]\n  numbers\
    \ <- as.numeric(numbers)\n  numbers[order(numbers)] \n}\n</code>\n<|/ a |>\n<|\
    \ a tags=sorting,r |>\nHere's a solution which uses unlist(), sapply(), and order():\n\
    <code>\nsort_numbers <- function(numbers) {\n  numbers <- unlist(strsplit(numbers,\
    \ \" \"))\n  numbers <- sapply(numbers, function(n) as.numeric(n))\n  numbers\
    \ <- order(numbers)\n  numbers[numbers]\n}\n</code>\nExample:\n<code>\n> sort_numbers(\"\
    nine two three one\")\n[1] 1 2 3 4\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nI like to keep things simple. \nThe code below should produce the same result\
    \ as your code\n<code>\nsort_numbers <- function(numbers) {\n  numbers <- strsplit(numbers,\
    \ \" \")\n  numbers <- unlist(numbers)\n  numbers <- as.numeric(numbers)\n  numbers[order(numbers)]\n\
    }\n</code>\n<|/ a tags=sorting,r |>\n<| c |>\n`numbers[order(numbers)]` just does\
    \ `numbers[order(numbers)[1]]` - so you can just replace `numbers <- unlist(numbers)`\
    \ with `numbers <- sort(numbers)` directly.\n<|/ c |>\n<| c |>\nI think you meant\
    \ to say `numbers <- sort(numbers)`\n<|/ c |>\n<| c |>\nWhoops. Yes, you're right.\
    \ Thanks.\n<|/ c |>\n<| a tags=sorting,r dscore=1 |>\n<code>\n    sort_numbers\
    \ <- function(numbers) {\n        numbers <- as.character(numbers)\n        numbers\
    \ <- strsplit(numbers, \" \")[[1]]\n        numbers <- as.numeric(numbers)\n \
    \       numbers <- sort(numbers)\n        numbers[numbers]\n    }\n</code>\n<|/\
    \ a |>\n<| a tags=sorting,r |>\nI like all the answers above, but since my code\
    \ was a little slow, I took the liberty of doing a few benchmarks, to compare\
    \ them to other methods. As the size of your data is quite large I used a smaller\
    \ data frame to run the benchmarks. \n<code>\nn <- 100\nd <- data.frame(v1=sample(letters,n,TRUE),v2=sample(letters,n,TRUE),v3=sample(letters,n,TRUE))\n\
    \nsort_numbers_base <- function(numbers){\n  numbers <- ", "\n  numbers <- stringr::str_split(numbers,\
    \ ' ')[[1]]\n  numbers <- sort(numbers)\n  numbers <- paste(numbers, collapse\
    \ = ' ')\n  numbers <- stringr::str_sub(numbers, start = 1, end = 5)\n}\n</code>\n\
    The output from sort_numbers('two three five seven nine') is:\n<code>\n[1] \"\
    one two three seven nine\"\n</code>\n<|/ a tags=string,r,split |>\n<| a dscore=1\
    \ tags=string,r,split |>\nHere are some options:\n1) gsub Use gsub to replace\
    \ the numbers with blanks, sort the resulting vector, and then remove the leading\
    \ blanks:\n<code>\ns1 <- \"one two three four five\"\ngsub(\"(^| )[0-9]+(| $)\"\
    , \"\", s1) \n[1] \"one two three four five\"\n\ns2 <- \"one two three\"\ngsub(\"\
    (^| )[0-9]+(| $)\", \"\", s2)\n[1] \"one two three\"\n</code>\n2) strsplit() Another\
    \ approach using strsplit():\n<code>\ns <- \"one two three four five\"\n\nstrsplit(s,\
    \ \"\\\\d+\", fixed = TRUE)[[1]]\n[1] \"one two three four five\"\n\nstrsplit(s,\
    \ \"\\\\s+\", fixed = TRUE)[[1]]\n[1] \"one two three four five\"\n\nstrsplit(s,\
    \ \"\\\\s+\", fixed = TRUE)[[1]][order(sapply(strsplit(s, \"\\\\s+\", fixed =\
    \ TRUE)[[1]], as.numeric))][,1]\n[1] \"one two three four five\"\n</code>\n3)\
    \ read.table/read.csv Another approach using read.csv:\n<code>\ns <- \"one two\
    \ three four five\"\n\nread.table(text = s)[,1]\n[1] \"one two three four five\"\
    \n\nread.csv(text = s)[,1]\n[1] \"one two three four five\"\n</code>\n4) gsubfn\
    \ Another approach using gsubfn:\n<code>\nlibrary(gsubfn)\n\ns <- \"one two three\
    \ four five\"\n\ngsubfn(\"(\\\\S+)(\\\\s+)\", ~sort(c(...)), s)\n[1] \"one two\
    \ three four five\"\n</code>\n<|/ a |>\n<| a tags=string,r,split |>\nHere is an\
    \ attempt using stringr\n<code>\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\n\
    \ndat <- data.frame(col1 = c(\"one two three four five\", \"one two three four\"\
    ))\n\ndat %>% \n", "\n  return(numbers)\n}\n</code>\nNow to test the function,\
    \ we can check against the results of running sort_numbers in R, Python, and C.\
    \ Here are some results:\n<code>\n> sort_numbers(\"one six nine\")\n[1] \"one\
    \ six nine\"\n> sort_numbers(\"three eight two\")\n[1] \"three eight two\"\n>\
    \ sort_numbers(\"four one seven\")\n[1] \"four one seven\"\n> sort_numbers(\"\
    six seven three\")\n[1] \"six seven three\"\n> sort_numbers(\"eight five four\"\
    )\n[1] \"eight five four\"\n> sort_numbers(\"nine four five\")\n[1] \"nine four\
    \ five\"\n> sort_numbers(\"zero one two\")\n[1] \"zero one two\"\n> sort_numbers(\"\
    three four\")\n[1] \"three four\"\n> sort_numbers(\"five seven six\")\n[1] \"\
    five seven six\"\n> sort_numbers(\"six nine eight\")\n[1] \"six nine eight\"\n\
    > sort_numbers(\"three five\")\n[1] \"three five\"\n> sort_numbers(\"two six eight\"\
    )\n[1] \"two six eight\"\n> sort_numbers(\"two three five\")\n[1] \"two three\
    \ five\"\n</code>\nI should also point out that this approach does not preserve\
    \ the original order of numbers, but instead sorts the numbers in an arbitrary\
    \ fashion. However, the resulting order may still be correct.\n<|/ a |>\n<| c\
    \ |>\nYou should not use `rbind()` on vectors as this converts the vectors to\
    \ matrices. Instead use: `sapply(x, sort, decreasing=T)`. See https://stackoverflow.com/a/34596499/4259345\n\
    <|/ c |>\n<| c |>\nThanks! I updated the answer to include `decreasing=TRUE` since\
    \ the original version did not do this. I did not know about `rbind()`, but I\
    \ like your approach because I think it's more readable. However, I agree that\
    \ `sapply()` is more suitable for this kind of tasks. Thanks!\n<|/ c |>\n<| a\
    \ dscore=2 tags=string,r,sorting |>\nA bit late, but here is another solution\
    \ using library(gtools):\n<code>\nmyfun <- function(x) {\n  require(gtools)\n\
    \  c(unique(x[order(table(x), decreasing=TRUE)]))\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis returns an error on ", "\n  as.character(unlist(strsplit(numbers, \"\
    \ \")))\n}\n", "\n  ns <- strsplit(numbers, ' ')[[1]]\n  ns1 <- c(ns, sort(ns))\n\
    \  paste(paste(ns1, collapse = ' '), collapse = ' ')\n}\n</code>\n<|/ a tags=r,sorting,numbers\
    \ dscore=1 |>\n<| a dscore=1 |>\nHere is a way using gsubfn\n<code>\nlibrary(gsubfn)\n\
    gsubfn('\\\\w+', ~ c(..., rev(sort(c(...)))), str1)", "\n  numbers2 <- sort(numbers)\n\
    \  paste(numbers2, collapse=\" \")\n}\n", "\n  sort(as.numeric(unlist(strsplit(numbers,\
    \ ' ')))) # sort alphabetically\n}\n", "\n  numbers <- strsplit(numbers, \" \"\
    )\n  numbers <- as.integer(unlist(numbers))\n  numbers <- sort(numbers)\n  numbers\
    \ <- paste(numbers, collapse = \" \")\n  return(numbers)\n}\n</cell>\n<cell>",
  "\n  nums <- strsplit(numbers, ' ')\n  nums <- lapply(nums, as.numeric)\n  nums\
    \ <- sort(nums)\n  numbers <- paste(sort(nums), collapse=' ')\n  return(numbers)\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI liked the other answers and used a for loop to\
    \ get the result I wanted. However I wanted to keep the results as a vector instead\
    \ of concatenating.\nI came up with this code which works in R:\n<code>", "\n\
    \  numbers <- unlist(strsplit(numbers, \" \"))\n  numbers <- sort(numbers)\n \
    \ numbers <- paste(numbers, collapse = \" \")\n  numbers\n}\n\n</code>\n<|/ a\
    \ tags=r,sorting |>\n<| a tags=r,sorting dscore=3 |>\nThis question is very similar\
    \ to another one I asked a while ago.\nHere's my solution:\n<code>", "\n  numbers\
    \ <- as.character(numbers)\n  numbers <- strsplit(numbers, \" \")[[1]]\n  numbers_sorted\
    \ <- c('zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',\
    \ 'nine')\n  numbers <- numbers[order(numbers_sorted)]\n  paste(numbers, collapse\
    \ = \" \")\n}\n</code>\nExample output\n<code>\n> sort_numbers(\"three one five\"\
    )\n[1] \"one three five\"\n\n> sort_numbers(\"one three five\")\n[1] \"three one\
    \ five\"\n</code>\n<|/ a |>\n<| c |>\nThis is pretty cool and I really like your\
    \ solution, but my issue is that I need the output to reflect that 'one two' is\
    \ before 'two one' and that 'four two' is before 'two four'.\n<|/ c |>\n<| a |>\n\
    Here's a solution using regular expressions and the stringr package:\n<code>\n\
    sort_numbers <- function(numbers) {\n  numbers <- strsplit(numbers, \" \")[[1]]\n\
    \  numbers_sorted <- c('zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\
    \ 'eight', 'nine')\n  numbers <- numbers[order(numbers_sorted)]\n  paste(numbers,\
    \ collapse = \" \")\n}\n\nsort_numbers(\"four two\")", "\n  # Split each string\
    \ into separate words\n  words <- strsplit(numbers, \" \")[[1]]\n  # Convert each\
    \ word to an integer\n  numbers <- lapply(words, as.integer)\n  # Sort and join\
    \ strings\n  paste(sort(numbers), collapse=\" \")\n}\n</code>\nThis works for\
    \ me.\n<|/ a dscore=4 |>\n<| c |>\nWow, that is great!  It is a little tricky\
    \ to understand for someone who has never used R, but I will try and learn from\
    \ this.  Thanks!\n<|/ c |>\n<| c |>\nI added comments to the code to explain what's\
    \ going on and why.  If you have any questions, let me know.\n<|/ c |>\n<| c |>\n\
    Thanks, I appreciate the explanation!\n<|/ c |>\n<| c |>\nJust wanted to add that\
    \ my solution is in fact a combination of your solution and mine.  I appreciate\
    \ the answers all, but I went with this one because it came out on first glance\
    \ and was easy to understand.\n<|/ c |>\n<| a |>\nHere's one way using data.table\
    \ and the package stringr.\n<code>\nlibrary(data.table)\nlibrary(stringr)\n",
  "\n  numbers <- as.character(numbers)\n  numbers <- strsplit(numbers, ' ')\n  numbers\
    \ <- unlist(numbers)\n  numbers <- sort(numbers, decreasing = TRUE)\n  numbers\
    \ <- paste0(numbers, collapse = ' ')\n  return(numbers)\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks for taking the time to share your thoughts. Unfortunately,\
    \ I believe that your solution will fall short on `sort_numbers('six nine seven\
    \ four three')` since the output should be `'four six nine seven three'`. Thank\
    \ you though, I'll +1 you for the effort!\n<|/ c |>\n<| a tags=r |>\nI went through\
    \ the same problem and couldn't find any R package that does this automatically,\
    \ so I decided to write a short R function to do it for me.\n<code>\nsort_numbers\
    \ <- function(numbers) {\n  numbers <- as.character(numbers)\n  numbers <- strsplit(numbers,\
    \ \" \")\n  numbers <- unlist(numbers)\n  numbers <- sort(numbers, decreasing\
    \ = TRUE)\n  numbers <- paste0(numbers, collapse = \" \")\n  return(numbers)\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=r dscore=0 |>\nHere is a solution using\
    \ regex and functions from dplyr. First, a function which removes the numbers\
    \ from a string, then reorders the elements of the string as requested:\n<code>\n\
    library(dplyr)\nremoveNumbers <- function(x) {\n  x <- gsub(\"\\\\D\", \"\", x)\n\
    \  x <- unlist(strsplit(x, \" \"))\n  x <- sort(x)\n  x <- paste0(x, collapse\
    \ = \" \")\n  return(x)\n}\n</code>\nSecond, a function, which parses the character\
    \ string into a data frame with one column of strings, and one column of numbers.\
    \ Then, it is simply a matter of reordering the numbers:\n<code>\nparseStringToDataFrame\
    \ <- function(x) {\n  x <- as.data.frame(unlist(strsplit(x, \" \")))\n  x <- data.frame(strings\
    \ = x[1], numbers = x[-1])\n  return(x)\n}\n</code>\nThird, a function, which\
    \ reorders the strings and then reorders the numbers:\n<code>\nreorder <- function(x)\
    \ {\n  x <- data.frame(sort(x$strings, decreasing = TRUE), sort(x$numbers, decreasing\
    \ = TRUE))\n  return(x)\n}\n</code>\nPutting it all together with some sample\
    \ data:\n<code>\nx <- ", "\n  sapply(strsplit(numbers, \" \")[[1]], \n       \
    \  function(x) paste(sort(as.numeric(x)), collapse = \" \"))\n}\n", "\n  numbers\
    \ <- as.numeric(unlist(strsplit(numbers, ' ')))\n  sort(numbers)\n}\n", "\n  numbers\
    \ <- gsub('[^0-9]', '', numbers)\n  numbers <- gsub('(?<=\\\\s)\\\\s', '', numbers)\n\
    \  numbers[order(numbers)]\n}\n</code>\nSome of the other answers here suggest\
    \ using gsubfn but that requires another package, so the above is my answer.\n\
    <|/ a dscore=5 |>\n<| c |>\nThis is great! I just needed the sort function, because\
    \ I needed to find the first non-negative integer in a vector of negative integers.\
    \ You just need to change '-1' to '0' if you want zero instead of negative 1.\n\
    <|/ c |>\n<| c |>\n`gsubfn` has a `?sort.int` method that will sort integers *without*\
    \ the need for a custom function. `x <- c(-3, 0, 5, 3, 0); as.integer(sort(x,\
    \ decreasing = TRUE))` yields `-1 0 1 2 3`. It's probably more efficient than\
    \ writing a custom sorting function, and it allows you to use `?regexpr` to find\
    \ the first non-negative integer.\n<|/ c |>\n<| c |>\n: nice trick. I've never\
    \ heard about that function. I've always used `regexpr` because that's my normal\
    \ way of finding a specific part of a string, but hadn't realized you could use\
    \ `regexpr` to sort numbers. Will definitely look into that. Thanks!\n<|/ c |>\n\
    <| a tags=sorting,r |>\nI needed a version of this for a problem I was working\
    \ on, so I put together a function that sorts strings by an arbitrary column of\
    \ the dataframe, which may contain multiple strings:\n<code>\nsort_strings <-\
    \ function(df, column_name) {\n  cols_to_sort <- grep('[A-Za-z]', names(df))\n\
    \  df[, column_name := str_extract(df[[column_name]], '[A-Za-z]+')]\n  df[, column_name\
    \ := factor(column_name, levels = cols_to_sort)][, column_name := \n    order(column_name)]\n\
    }\n</code>\n(I did some checking to make sure it worked, and it does)\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis is the best answer for me: it works with the `gsubfn` package,\
    \ which I do not want to install. Thanks\n<|/ c |>\n<| c |>\nNice function. I've\
    \ added a couple of small enhancements that make the function even nicer: `gsubfn::is_sorted`\
    \ and `gsubfn::sort_n`\n<|/ c |>\n<| c |>\nThank you! `factor()` is really useful\
    \ in solving my problem. And I did some check", "\n  numbers <- unlist(strsplit(numbers,\
    \ \"\\\\s+\"))\n  sorted <- sort(numbers)\n  paste(sorted, collapse = \" \")\n\
    }\n\nsort_numbers('nine eight seven six five four three two')", "\n  x <- strsplit(numbers,\
    \ ' ')[[1]]\n  sort(x, decreasing=TRUE)\n}\n", "\n  numbers_list <- unlist(strsplit(numbers,\
    \ ' '))\n  numbers_list <- numbers_list[order(numbers_list)]\n  return(paste(numbers_list,\
    \ collapse = ' '))\n}\n", "\n  numbers <- unlist(strsplit(numbers, split = \"\
    \ \"))\n  numbers <- numbers[order(numbers)]\n  paste(numbers, collapse = \" \"\
    )\n}\n", "\n  numbers <- gsub(\" \", \"\", numbers)\n  numbers <- unlist(strsplit(numbers,\
    \ \" \"))\n  numbers <- sort(numbers)\n  numbers <- paste0(numbers, collapse=\"\
    \ \")\n  return(numbers)\n}\n", "\n  # TODO: Implement this function\n  return('')\n\
    }\n", "\n  # Only change code below this line\n  numbers <- gsub(\" \", \"\",\
    \ numbers)\n  numbers <- gsub(\" \", \"\", numbers)\n  numbers <- gsub(\",\",\
    \ \" \", numbers)\n  numbers <- gsub(\"'\", \"\", numbers)\n  numbers <- gsub(\"\
    '\", \"\", numbers)\n  numbers <- gsub(\"\\\\s+\", \"\", numbers)\n  numbers <-\
    \ gsub(\"\\\\s+\", \"\", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n\
    \  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\",\
    \ \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <-\
    \ gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n\
    \  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\",\
    \ \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <-\
    \ gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n\
    \  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\",\
    \ \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <-\
    \ gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n\
    \  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\",\
    \ \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <-\
    \ gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n\
    \  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\",\
    \ \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <-\
    \ gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n\
    \  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <- gsub(\"\\\\s+\",\
    \ \" \", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers <-\
    \ gsub(\"\\\\s+\", \" \", number", "\n    numbers_list <- strsplit(numbers, '\
    \ ')\n    numbers_list <- numbers_list[[1]]\n    numbers_list <- sort(numbers_list)\n\
    \    paste(numbers_list, collapse = ' ')\n}\n</code>\n<|/ a dscore=0 tags=sorting,r,string,sorting\
    \ |>\n<| a tags=sorting,r,string,sorting |>\nYou could use gsub to remove the\
    \ numbers before you sort them, and then rebuild them in a sorted order.\n<code>\n\
    sort_numbers <- function(numbers){\n  nums <- gsub('[0-9]+', '', numbers)\n  nums\
    \ <- sort(nums)\n  paste0(nums, collapse = ' ')\n}\n\nsort_numbers('nine seven\
    \ nine eight six nine four three eight five')\n[1] \"one three eight five six\
    \ nine seven eight nine\"\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere's a more\
    \ generic way that relies on dplyr and stringr:\n<code>\nlibrary(dplyr)\nlibrary(stringr)\n\
    \nsort_numbers <- function(x){\n  x %>%\n    str_extract_all(\"[0-9]\") %>%\n\
    \    do.call(order, c(., .[,1])) %>%\n    str_c(collapse = \" \")\n}\n</code>\n\
    <|/ a tags=sorting,r,string,sorting dscore=0 |>\n<| a |>\nHere's a base R solution:\n\
    <code>\nsort_numbers <- function(numbers) {\n  temp <- strsplit(numbers, \" \"\
    )[[1]]\n  temp <- as.numeric(unlist(strsplit(numbers, \" \"))[order(temp)])\n\
    \  paste(temp, collapse = \" \")\n}\n\nsort_numbers(\"nine seven nine eight six\
    \ nine four three eight five\")", "\n  sorted <- c()\n  split <- strsplit(numbers,\
    \ \"\\\\s\")[[1]]\n  for(i in 1:length(split)) {\n    numbers <- unlist(strsplit(split[i],\
    \ \" \"))\n    sorted <- c(sorted, numbers[order(numbers)])\n  }\n  return(paste(sorted,\
    \ collapse = \" \"))\n}\n", "\n    numbers <- gsub(\" \", \"\", numbers)\n   \
    \ numbers <- sapply(strsplit(numbers, \"[[:space:]]\"), as.numeric)\n    numbers\
    \ <- sort(numbers)\n    numbers <- paste(numbers, collapse = \" \")\n    numbers\
    \ = paste(\"one \", numbers, sep = \"\")\n    return(numbers)\n}\n</code>\n<|/\
    \ a tags=r,sorting,numbers |>\n<| c |>\nIt's worth noting that you can do `sort(c(\"\
    three\", \"one\", \"five\"))` and it will work as expected.\n<|/ c |>\n<| a tags=r,sorting,numbers\
    \ dscore=1 |>\nI came up with this solution, using \"stringi\" package and custom\
    \ \"toNumber\" function that converts a string to a number:\n<code>\ntoNumber\
    \ <- function(x) {\n  x <- paste(as.character(x), collapse = \"\")\n  x <- as.numeric(paste(stri_replace_all_regex(x,\
    \ \"[[:digit:]]\", \"0\"), sep=\"\"))\n  return(x)\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis is really slick - I didn't know about `stri_replace_all_regex`.  Just\
    \ want to point out that `as.character` isn't necessary for \"three\".  `as.numeric`\
    \ can handle character strings without being explicitly converted to character\
    \ first.  Also, `gsub` can take `collapse` as an argument, `paste` can be replaced\
    \ with a `paste0`, etc.\n<|/ c |>\n<| c |>\nI didn't know that `as.character`\
    \ is not necessary for \"three\".  Thanks for pointing that out.\n<|/ c |>\n<|\
    \ c |>\nIt isn't necessary for \"three\" because `toNumber` isn't vectorized.\
    \  You don't want `toNumber` to change all 3 elements of a vector to \"3\".  You\
    \ could easily do `toNumber(\"four\")` which would return `4`, not `0`.  This\
    \ is why I added the `stri_replace_all_regex` call.\n<|/ c |>\n<| c |>\nAh I see!\
    \ Yes that's true. Thanks for the tip!\n<|/ c |>\n<| a tags=r,sorting,numbers\
    \ |>\nAnother possibility:\n<code>\nsort_numbers <- function(numbers){\n  words\
    \ <- strsplit(numbers, \"\\\\s+\")\n  out <- paste(words[[1]], collapse = \" \"\
    )\n  out <- gsub(\"0\",\"1\",out)\n  return(out)\n}\n\n> sort_numbers(\"one two\
    \ three\")\n[1] \"one two three\"", "\n  # Write your code here\n}\n</cell>\n\
    <cell>", "\n    numbers <- as.character(numbers)\n    numbers <- gsub(\"[[:punct:]]\"\
    , \"\", numbers)\n    numbers <- gsub(\"[[:upper:]]\", \"\", numbers)\n    numbers\
    \ <- gsub(\"[[:lower:]]\", \"\", numbers)\n    numbers <- gsub(\"[^0-9]\", \"\
    \ \", numbers)\n    numbers <- as.numeric(numbers)\n    numbers <- sort(numbers)\n\
    \    numbers <- paste0(numbers, collapse=\" \")\n    return(numbers)\n}\n\nsort_numbers(\"\
    one five three\")", "\n  numbers <- gsub(\"[^0-9]\", \"\", numbers)\n  numbers_vector\
    \ <- as.numeric(numbers)\n  numbers_vector[order(numbers_vector)] <- paste(numbers_vector[order(numbers_vector)],\
    \ collapse=\" \")\n  return(numbers_vector)\n}\n</code>\n<|/ a tags=r,data-wrangling,sorting\
    \ dscore=3 |>\n<| c |>\nVery nice solution, I like how `gsub` is able to handle\
    \ a vector of any length.\n<|/ c |>\n<| c |>\nYeah, I didn't know that about `gsub`.\n\
    <|/ c |>\n<| c |>\nThis is great solution, thank you!\n<|/ c |>\n<| a |>\nUsing\
    \ the following code you can convert the number to a character vector and then\
    \ sort the characters as numbers with order and finally combine them to a string\
    \ with paste.\n<code>\nx <- c(123, 456, 789)\nx <- c(sort(as.character(x)))\n\
    paste(x, collapse = \" \")\n</code>\n<|/ a dscore=1 tags=r,data-wrangling,sorting\
    \ |>\n<| c |>\nYou should not use `x` for other objects. Please read [What is\
    \ the R inferno?](https://stackoverflow.com/questions/17559390/what-is-the-r-inferno)\n\
    <|/ c |>\n<| c |>\nThanks for the feedback, I updated my answer.\n<|/ c |>\n<|\
    \ a tags=r,data-wrangling,sorting |>\n<code>\nsort_numbers <- function(numbers)\
    \ {\n  numbers <- gsub(\"[^0-9]\", \"\", numbers)\n  numbers_vector <- as.numeric(numbers)\n\
    \  numbers_vector[order(numbers_vector)] <- paste(numbers_vector[order(numbers_vector)],\
    \ collapse=\" \")\n  return(numbers_vector)\n}\n\nx <- c(123, 456, 789)\nsort_numbers(x)",
  "\n  numbers <- gsub(\" \", \"\", numbers)\n  numbers <- unlist(strsplit(numbers,\
    \ split = \" \"))\n  numbers <- sort(numbers, decreasing = TRUE)\n  numbers <-\
    \ paste(numbers, collapse = \" \")\n}\n", "\n  numbers <- strsplit(numbers, '\
    \ ')[[1]]\n  sorted <- sort(numbers)\n  return(paste(sorted, collapse = ' '))\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`sort_numbers <- function(numbers) {\n\
    \  numbers <- strsplit(numbers, ' ')[[1]]\n  sorted <- sort(numbers)\n  return(paste(sorted,\
    \ collapse = ' '))\n}` works but is unnecessary. `sort(gsub(\" \", \"\", numbers))`\
    \ works just as well\n<|/ c |>\n<| a tags=regex,r,gsub dscore=1 |>\n<code>", "\n\
    \  split_numbers <- unlist(strsplit(numbers, \" \"))\n  numbers <- paste0(\"'\"\
    , sort(split_numbers), \"'\")\n  return(numbers)\n}\n</code>\n<|/ a tags=r dscore=1\
    \ |>\n<| c |>\nYou only need to use as.character for characters. as.numeric will\
    \ coerce numeric to character.\n<|/ c |>\n<| a tags=r |>\n<code>", "\n  x <- strsplit(numbers,\
    \ ' ')\n  x <- lapply(x, as.numeric)\n  x <- as.numeric(names(x))\n  sort(x)\n\
    }\n</code>\n<|/ a tags=r,sorting,dataframe |>\n<| a dscore=1 tags=r,sorting,dataframe\
    \ |>\nHere is an approach without packages using only basic R tools (which may\
    \ be more useful than using packages):\n<code>", "\n  numbers <- as.character(numbers)\n\
    \  numbers1 <- unlist(strsplit(numbers, split = \" \"))\n  numbers2 <- sort(numbers1)\n\
    \  paste(numbers2, collapse = \" \")\n}\n</code>\n<|/ a dscore=3 tags=string,r,sorting\
    \ |>\n<| c |>\n`numbers2 <- sort(numbers1)` should be `numbers2 <- sort(numbers2)`.\
    \ Otherwise you are sorting in the opposite direction.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a slightly different approach that uses stri_extract_all_regex, a\
    \ tidyverse function. This is a good example for using the purrr package. \n<code>",
  "\n    numbers[order(as.numeric(str_split(numbers, \" \")[[1]][-1]))]\n}\n</code>\n\
    <|/ a tags=sorting,r |>\n<| a |>\nHere's a solution that uses gsub to remove all\
    \ digits in the string and sort alphabetically.\n<code>", "\n  # Make sure the\
    \ input is a string\n  numbers <- as.character(numbers)\n  # Parse the string\
    \ as a list of numbers\n  numbers <- strsplit(numbers, ' ')[[1]]\n  # Sort and\
    \ join it into a single string\n  paste0(sort(numbers), collapse = ' ')\n}\n</code>\n\
    Some benchmarks\n<code>\n> microbenchmark(\n+   sort_numbers_1('one two three'),\n\
    +   sort_numbers_2('one two three'),\n+   sort_numbers_3('one two three'),\n+\
    \   sort_numbers_4('one two three'),\n+   sort_numbers_5('one two three'),\n+\
    \   sort_numbers_6('one two three'),\n+   sort_numbers_7('one two three'),\n+\
    \   sort_numbers_8('one two three'),\n+   sort_numbers_9('one two three'),\n+\
    \   times = 10\n+ )\nUnit: milliseconds\n               expr      min       lq\
    \     mean   median       uq      max neval\n sort_numbers_1(\"one\", \"two\"\
    , \"three\") 21.5469 22.4088 23.25575 22.7051 24.1705    10\n sort_numbers_2(\"\
    one\", \"two\", \"three\") 25.6870 27.6400 28.79643 28.1427 29.1715    10\n sort_numbers_3(\"\
    one\", \"two\", \"three\") 31.1735 32.4398 33.72650 33.4953 34.7775    10\n sort_numbers_4(\"\
    one\", \"two\", \"three\") 34.6351 35.5901 36.78804 35.7257 36.6556    10\n sort_numbers_5(\"\
    one\", \"two\", \"three\") 39.5983 40.5511 41.12335 40.6457 41.0742    10\n sort_numbers_6(\"\
    one\", \"two\", \"three\") 44.5101 45.2413 46.08445 45.5938 46.0714    10\n sort_numbers_7(\"\
    one\", \"two\", \"three\") 49.7950 50.3976 51.62765 50.6836 51.6441    10\n sort_numbers_8(\"\
    one\", \"two\", \"three\") 52.1035 53.1267 53.93930 53.4699 53.8291    10\n sort_numbers_9(\"\
    one\", \"two\", \"three\") 54.6276 55.2620 55.85578 55.", "\n  numbers <- as.numeric(unlist(strsplit(numbers,\
    \ \" \")))\n  numbers <- sort(numbers)\n  return(paste0(numbers[-nrow(numbers)],\
    \ collapse = \" \"))\n}\n", "\n    numbers <- unlist(strsplit(numbers, \" \"))\n\
    \    paste(sort(numbers), collapse = \" \")\n}\n</code>\n<|/ a |>\n<| c |>\nI\
    \ don't think you can sort multiple numbers in a string with a space delimited\
    \ string. You'd have to have numbers with a space delimited string as separate\
    \ entries in the vector. I'm going to update my answer to include this option.\n\
    <|/ c |>\n<| c |>\nThank you for your answer. It appears that when I run `sort_numbers(\"\
    three four five\")` I still get the wrong output. Also, when I run `sort_numbers(\"\
    one three four five\")` I still get `one three four five` instead of `one three\
    \ four five`.\n<|/ c |>\n<| c |>\nYes, sorry, that wasn't the idea. Just a straight\
    \ sort would not work. I'll see if I can update my answer.\n<|/ c |>\n<| c |>\n\
    I updated the answer, sorry I forgot to include the part about the numbers being\
    \ space-delimited. Also, thanks for the extra credit for the other answer :)\n\
    <|/ c |>\n<| c |>\nThanks for your help, I really appreciate it. Also, thanks\
    \ for the extra credit for the other answer as well :)\n<|/ c |>\n<| a |>\nThis\
    \ is an extension of Nathan's answer above. Using strsplit with regular expressions\
    \ (regex) we can get each number, then sort the numbers, and combine them back\
    \ together. \n<code>\nsort_numbers <- function(string){\n  n <- gregexpr(\"\\\\\
    d+\", string)\n  numbers <- string[n[[1]]]\n  numbers <- sort(numbers)\n  paste(numbers,\
    \ collapse = \" \")\n}\n</code>\nExample:\n<code>\n> sort_numbers(\"three four\
    \ five\")\n[1] \"one three four five\"\n> sort_numbers(\"one two three\")\n[1]\
    \ \"one two three\"\n> sort_numbers(\"two three four\")\n[1] \"two three four\"\
    \n> sort_numbers(\"one three four five\")\n[1] \"one three four five\"\n</code>\n\
    <|/ a dscore=2 tags=r,sorting |>\n<| a tags=r,sorting |>\nThe package stringr\
    \ contains a function str_extract_all that can be used to extract each number.\
    \ \n<code>\n> library(stringr)\n> str_extract_all(\"three four five\", \"\\\\\
    d+\")\n[[1]]\n[1] \"3\" \"4\" \"5\"\n</code>\nYou can then sort the numbers and\
    \ combine them back together. \n<code>\n> paste(sort(str_extract_all", "\n  numbers_vector\
    \ <- unlist(strsplit(numbers, \" \"))\n  numbers <- numbers_vector[order(numbers_vector)]\n\
    \  paste0(numbers, collapse = \" \")\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nAn alternate answer to what was already suggested, but without the use of\
    \ regex. Instead of writing a function, we can leverage the vectorized functions\
    \ of base R. The following function will take in a character vector of numbers\
    \ and return them in sorted order. \n<code>\nsort_numbers <- function(numbers)\
    \ {\n  numbers <- c(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\"\
    , \"six\", \"seven\", \"eight\", \"nine\")\n  numbers <- factor(numbers, levels\
    \ = numbers)\n  numbers <- sort(numbers)\n  numbers <- as.character(numbers)\n\
    \  numbers <- paste(numbers, collapse = \" \")\n  numbers\n}\n</code>\n<|/ a tags=sorting,r,numbers,alphanumeric\
    \ |>\n<| a |>\nThis might not be the most elegant solution, but it works.\nThe\
    \ idea is to make a vector of numbers ('nums') of length 10 ranging from 0 to\
    \ 9 (which equals 10 numbers), and then using the 'match' function to get those\
    \ values from another vector ('alpha') that has the alphabets in it.\nThe code\
    \ below works for the example you posted:\n<code>\nnums <- seq(from = 0, to =\
    \ 9) # Vector of 10 numbers\nalpha <- c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"\
    g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"\
    t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\") # Vector of alphabet letters", "\n  numbers\
    \ <- as.character(numbers)\n  numbers <- strsplit(numbers, \" \")[[1]]\n  numbers\
    \ <- sort(numbers)\n  paste(numbers, collapse = \" \")\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like `paste(sort(numbers), collapse=\" \")`, but I'm not a big\
    \ fan of coercing character vector to numeric vector. I'd also suggest using `sapply`\
    \ instead to simplify the code.\n<|/ c |>\n<| a dscore=2 tags=sorting,r |>\nHere\
    \ is another solution using strsplit and sort:\n<code>\nsortNumbers <- function(x)\
    \ {\n  as.numeric(unlist(strsplit(x, \" \", fixed = TRUE)))\n}\n\nx <- c(\"three\
    \ one five\", \"nine four two\")\nsortNumbers(x)\n\n[1] 1 2 3 4 5 6 7 8 9\n</code>\n\
    This should work nicely with any kind of string. Here is a longer example that\
    \ includes a few special cases (like empty strings and \"zero one\"):\n<code>\n\
    x <- c(\"zero one\", \"one one\", \"two two\", \"three three\", \"four four\"\
    , \"five five\", \"six six\", \"seven seven\", \"eight eight\", \"nine nine\"\
    )\n\nsortNumbers(x)\n[1]  1  2  3  4  5  6  7  8  9 10\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis is a great answer (and probably the fastest too). But, I wonder if\
    \ the `sapply` solution I posted below would be faster. I'm not a big fan of coercing\
    \ character vector to numeric vector.\n<|/ c |>\n<| c |>\nThanks for the comment.\
    \ I thought about using `sapply`. And I didn't want to coerce to numeric, since\
    \ my solution also handles that. I just wanted the code to not include `as.numeric`.\
    \ But that's a fair point, and one that isn't really a concern with my solution,\
    \ but might be nice to have in a different context.\n<|/ c |>\n<| a dscore=1 |>\n\
    I like Gregor's answer, but here's an alternate version that uses sapply.\n<code>\n\
    sort_numbers <- function(x) {\n  x <- as.character(x)\n  sapply(x, function(x)\
    \ sort(as.numeric(unlist(strsplit(x, \" \")))))\n}\n</code>\n<|/ a tags=sorting,r\
    \ |>\n<| a tags=sorting,r dscore=1 |>\nHere's a solution using gsub using \"zero\
    \ one\" as an example:", "\n  words <- str_split(numbers, ' ')\n  num_words <-\
    \ unlist(words)\n  num_words <- num_words[order(num_words)]\n  paste(num_words,collapse='\
    \ ')\n}\n</code>\n<|/ a tags=r |>\n<| a |>\nHere is a function that will work\
    \ with any given list with any given set of numbers:\n<code>\nsort_numbers <-\
    \ function(numbers, choice=\"zero\", n=9){\n    # convert numbers to a character\
    \ vector for regex matching\n    numbers <- strsplit(numbers, \" \")[[1]]\n  \
    \  # create a vector of the valid choices and remove duplicates\n    choices <-\
    \ unique(choice)\n    # create an index to match choices to numbers\n    index\
    \ <- grep(choices, numbers)\n    # find the numbers that need to be sorted\n \
    \   to_sort <- unlist(numbers[index])\n    # sort them and return a character\
    \ vector\n    paste(sort(to_sort), collapse=\" \")\n}\n\nsort_numbers(\"one one\
    \ three two two nine four nine two seven\", choice=\"one\")\n</code>\n<|/ a dscore=1\
    \ tags=r |>\n<| c |>\nNice solution but I think `sort` is more flexible than `order`\
    \ as it handles ties in the case of ties: `sort_numbers(\"one one three two two\
    \ nine four nine two seven\", choice=\"one\")`\n<|/ c |>\n<| a tags=r |>\nBuilding\
    \ off of answer, but using lapply instead of sapply. \n<code>\nsort_numbers =\
    \ function(numbers, choice=\"zero\", n=9){\n    # convert numbers to a character\
    \ vector for regex matching\n    numbers <- strsplit(numbers, \" \")[[1]]\n  \
    \  # create a vector of the valid choices and remove duplicates\n    choices <-\
    \ unique(choice)\n    # create an index to match choices to numbers\n    index\
    \ <- grep(choices, numbers)\n    # find the numbers that need to be sorted\n \
    \   to_sort <- unlist(numbers[index])\n    # sort them and return a character\
    \ vector\n    paste(sort(to_sort), collapse=\" \")\n}\n\nsort_numbers(\"one one\
    \ three two two nine four nine two seven\", choice=\"one\")\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nNice solution but I think `sort` is more flexible than `order`\
    \ as it handles ties in the case of ties: `sort_numbers(\"one one three two two\
    \ nine four nine two seven\", choice=\"one\")`\n<|/ c |>\n<| a tags=r |>\nWe can\
    \ use agrepl from base R\n<code>\nsort_", "\n    numbers <- gsub(\" \", \"\",\
    \ numbers)\n    numbers <- unlist(strsplit(numbers, \"\\\\ \"))\n    numbers <-\
    \ numbers[order(numbers)]\n    paste(numbers, collapse = \" \")\n}\n", "\n  gsub('[^[:digit:][:space:]]',\
    \ '0', numbers) # replace all non-digits and non-spaces with '0'\n  numbers <-\
    \ as.numeric(sapply(strsplit(numbers, ' '), \"[\", -1)) # convert all spaces into\
    \ '0's\n  numbers <- sort(numbers, decreasing = TRUE) # sort from largest to smallest\n\
    \  numbers <- paste(numbers, collapse = ' ')\n  gsub('0{2,}', '0', numbers) #\
    \ remove duplicates\n}\n", "\n  numbers_sorted <- as.numeric(as.factor(numbers))\n\
    \  return(paste0(sort(numbers_sorted), collapse = ' '))\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nThanks for your solution,! But I used `fortify.data.frame` to get\
    \ the data into a data frame. Do you know if there is a way to use the `fortify.data.frame`\
    \ output to get a data frame?\n<|/ c |>\n<| c |>\nHi Kenny, `fortify.data.frame`\
    \ is only useful for converting data frames to other formats such as json or XML.\n\
    <|/ c |>\n<| c |>\nHi Kenny, I have added an alternative using only base R and\
    \ `fortify.data.frame`\n<|/ c |>\n<| a tags=r dscore=2 |>\nHere is an alternative\
    \ using only base R. First I made a vector with all the digits, then I sorted\
    \ that vector in descending order and printed the result. \n<code>\ndigits <-\
    \ c(9:1, 2:3, 8:7, 0:5)\ndigits[order(digits, decreasing = T)]\n", "\n  numbers\
    \ <- strsplit(numbers, ' ')[[1]]\n  numbers <- sort(numbers)\n  numbers <- paste0(numbers,\
    \ collapse = ' ')\n  return(numbers)\n}\n</code>\n<|/ a tags=r,string,sorting\
    \ |>\n<| c |>\nThis is very clever, but I suspect there is a simpler solution\
    \ than converting them to `factor`s\n<|/ c |>\n<| c |>\nThis works well on my\
    \ toy example, unfortunately on real data I cannot afford to convert to a factor\
    \ because they have hundreds of thousands of observations. Thanks though, I'll\
    \ keep this question open for awhile in case anyone else has ideas that don't\
    \ involve factors\n<|/ c |>\n<| c |>\nThanks, I like the idea of using \"one three\
    \ five\" as a test input\n<|/ c |>\n<| c |>\nAh, thank you for the edit. On my\
    \ real data, the strings are actually characters. So the solutions wouldn't work.\
    \ I'll try to find a way around this, perhaps using a different sort algorithm\
    \ than the default one\n<|/ c |>\n<| c |>\nI've found an answer, thank you anyway!\
    \ I'll post it in a moment\n<|/ c |>\n<| a tags=r,string,sorting |>\nFor anyone\
    \ looking at this in the future, the answer is to use a radix sort. There are\
    \ many different sorting algorithms out there, but I believe this one is the best\
    \ for characters and numbers. \n<code>\nlibrary(radix)\nradix_sort <- function(string)\
    \ {\n  sapply(str_split(string, ' '), function(x) \n    str_sort(x, radix = \"\
    decimal\"))\n}\n\nradix_sort(\"one four seven\")\n[1] \"one four seven\"\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis solution has only worked on my example because\
    \ each string contains no numbers and no special characters, so I believe it works\
    \ with this toy example. Thank you! Unfortunately on my real data it didn't work,\
    \ I posted an answer that worked for me\n<|/ c |>\n<| c |>\nThis works well on\
    \ my toy example, unfortunately on real data I cannot afford to convert to a factor\
    \ because they have hundreds of thousands of observations. Thanks though, I'll\
    \ keep this question open for awhile in case anyone else has ideas that don't\
    \ involve factors\n<|/ c |>\n<| a |>\nI tried to convert the strings to factors\
    \ and then sort by levels()\n<code>\nsort_numbers <- function(string", "\n   \
    \ numbers_ordered <- gsub(\" \", \"\", numbers)\n    nums_vector <- strsplit(numbers_ordered,\
    \ \" \")[[1]]\n    nums_sorted <- sort(nums_vector)\n    paste(nums_sorted, collapse\
    \ = \" \")\n}\n</cell>\n<cell>\nsort_numbers(\"nine two eight four\")\n</cell>\n\
    <cell>\nsort_numbers(\"nine two four\")\n</cell>\n<cell>\nsort_numbers(\"two eight\
    \ four\")\n</cell>\n<text>\nThe Sort function takes a vector and returns a vector\
    \ in alphabetical order. Notice the example above where it only works on a single\
    \ word. We need to do this for all the words in a column of a dataframe. Here's\
    \ one way to do it.\n\n\n</text>\n<cell>", "\n  numbers <- strsplit(numbers, \"\
    \ \")[[1]]\n  numbers <- sort(numbers)\n  numbers <- paste0(numbers, collapse\
    \ = \" \")\n  return(numbers)\n}\n</code>\n<|/ a |>\n<| c |>\nI like this one.\
    \  It doesn't need an additional package, but `sprintf` will give unexpected results\
    \ if you supply too many arguments.  See my answer for a more robust solution\
    \ that doesn't have that issue.\n<|/ c |>\n<| c |>\n, thanks for the comment!\
    \ I updated the code to remove any extra arguments that `sprintf` might receive.\n\
    <|/ c |>\n<| a tags=sorting,r,string |>\nIf you need to keep the spaces between\
    \ the numbers, you can use the following solution:\n<code>\nsort_numbers <- function(numbers)\
    \ {\n  numbers <- strsplit(numbers, \" \")[[1]]\n  numbers <- paste0(sort(numbers),\
    \ collapse = \" \")\n  return(numbers)\n}\n\nsort_numbers('five six seven nine')\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=sorting,r,string |>\nA slight modification\
    \ to answer by to not concatenate extra spaces after the last number:\n<code>\n\
    sort_numbers <- function(numbers) {\n  numbers <- strsplit(numbers, \" \")[[1]]\n\
    \  numbers <- paste0(sort(numbers), collapse = \" \")\n  return(numbers)\n}\n\
    </code>\n<|/ a |>\n<| a |>\nAnother option that does not require installing any\
    \ additional packages:\n<code>\nsort_numbers <- function(numbers) {\n    numbers\
    \ <- strsplit(numbers, \" \")[[1]]\n    numbers <- paste0(sort(numbers), collapse\
    \ = \" \")\n    numbers[!(grepl(\"^0$\", numbers))] <- paste0(numbers[!(grepl(\"\
    ^0$\", numbers))], collapse = \" \")\n    numbers[!(grepl(\"^9$\", numbers))]\
    \ <- paste0(numbers[!(grepl(\"^9$\", numbers))], collapse = \" \")\n    return(numbers)\n\
    }\n</code>\n<|/ a tags=sorting,r,string dscore=0 |>\n<| a dscore=0 |>\nUsing dplyr\n\
    <code>\nlibrary(dplyr)", "\n  if (missing(numbers)) return(\"\")\n  numbers <-\
    \ str_split(numbers, \" \")[[1]]\n  if (length(numbers) == 0) return(\"\")\n \
    \ numbers <- sort(numbers)\n  numbers <- paste0(numbers, collapse = \" \")\n \
    \ return(numbers)\n}\n", "\n  numbers <- as.character(numbers)\n  numbers <- gsub(\"\
    [^0-9]\", \"\", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n  numbers\
    \ <- unlist(strsplit(numbers, \" \"))\n  numbers <- gsub(\"^\\\\s+|\\\\s+$\",\
    \ \"\", numbers)\n  numbers <- sort(numbers)\n  numbers <- paste(numbers, collapse=\"\
    \ \")\n  return(numbers)\n}\n", "\n  numbers <- gsub(\" \", \"\", numbers)\n \
    \ numbers <- gsub(\"\\\\s|\\\\d|-\", \"-\", numbers)\n  numbers <- gsub(\"\\\\\
    s\", \"-\", numbers)\n  numbers <- gsub(\"\\\\-\", \"-\", numbers)\n  numbers\
    \ <- gsub(\"-\\\\-\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n\
    \  numbers <- gsub(\"-\", \"\", numbers)\n  numbers <- gsub(\"\\\\-\", \"\", numbers)\n\
    \  numbers <- gsub(\"\\\\-\", \"\\\\-\", numbers)\n  numbers <- gsub(\"\\\\-\"\
    , \"\\\\-\", numbers)\n  numbers <- gsub(\"\\\\-\", \"-\", numbers)\n  numbers\
    \ <- gsub(\"\\\\-\", \"\\\\-\", numbers)\n  numbers <- gsub(\"\\\\-\", \"-\",\
    \ numbers)\n  numbers <- gsub(\"-\\\\-\", \"\\\\-\", numbers)\n  numbers <- gsub(\"\
    -\\\\-\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"\\\\-\", numbers)\n  numbers\
    \ <- gsub(\"\\\\-\", \"-\", numbers)\n  numbers <- gsub(\"\\\\-\", \"\\\\-\",\
    \ numbers)\n  numbers <- gsub(\"\\\\-\", \"\\\\-\", numbers)\n  numbers <- gsub(\"\
    \\\\-\", \"\\\\-\", numbers)\n  numbers <- gsub(\"\\\\-\", \"-\", numbers)\n \
    \ numbers <- gsub(\"-\\\\-\", \"\\\\-\", numbers)\n  numbers <- gsub(\"-\\\\-\"\
    , \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n  numbers <- gsub(\"\
    -\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n  numbers <- gsub(\"\
    -\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n  numbers <- gsub(\"\
    -\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n  numbers <- gsub(\"\
    -\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n  numbers <- gsub(\"\
    -\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n  numbers <- gsub(\"\
    -\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n  numbers <- gsub(\"\
    -\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n  numbers <- gsub(\"\
    -\", \"-\", numbers)\n  numbers <- gsub(\"-\", \"-\", numbers)\n  numbers <- gsub(\"\
    -\", \"-\", numbers)\n  ", "\n  numbers <- gsub(\"\\\\s+\", \"\", numbers)\n \
    \ numbers <- gsub(\"\\\\D\", \"\", numbers)\n  numbers <- gsub(\"^0*\", \"\",\
    \ numbers)\n  numbers <- gsub(\"^0\", \"\", numbers)\n  numbers <- gsub(\"*$\"\
    , \"\", numbers)\n  numbers <- gsub(\"^0*$\", \"\", numbers)\n  numbers <- gsub(\"\
    ^0*0*\", \"\", numbers)\n  numbers <- gsub(\"^0*0*0*\", \"\", numbers)\n  numbers\
    \ <- gsub(\"^0*0*0*0*\", \"\", numbers)\n  numbers <- gsub(\"^0*0*0*0*0*\", \"\
    \", numbers)\n  numbers <- gsub(\"^0*0*0*0*0*0*\", \"\", numbers)\n  numbers <-\
    \ gsub(\"^0*0*0*0*0*0*0*\", \"\", numbers)\n  numbers <- gsub(\"^0*0*0*0*0*0*0*0*\"\
    , \"\", numbers)\n  numbers <- gsub(\"^0*0*0*0*0*0*0*0*0*\", \"\", numbers)\n\
    \  numbers <- gsub(\"^0*0*0*0*0*0*0*0*0*0*\", \"\", numbers)\n  numbers <- gsub(\"\
    ^0*0*0*0*0*0*0*0*0*0*0*\", \"\", numbers)\n  numbers <- gsub(\"^0*0*0*0*0*0*0*0*0*0*0*0*0*\"\
    , \"\", numbers)\n  numbers <- gsub(\"^0*0*0*0*0*0*0*0*0*0*0*0*0*0*0*\", \"\"\
    , numbers)\n  numbers <- gsub(\"^0*0*0*0*0*0*0*0*0*0*0*0*0*0*0*0*\", \"\", numbers)\n\
    \  numbers <- gsub(\"^0*0*0*0*0*0*0*0*0*0*0*0*0*0*0*0*0*0*\", \"\", numbers)\n\
    \  numbers <- gsub(\"^0", "\n  numbers <- gsub(\" \", \"\", numbers) # Replace\
    \ whitespace in string with empty string\n  numbers <- gsub(\"[^0-9]\", \"\",\
    \ numbers) # Remove anything that's not a number 0-9\n  numbers <- sort(numbers)\
    \ # Sort the numbers\n  numbers <- paste0(numbers, collapse = \" \") # Append\
    \ the numbers with whitespace between them\n  return(numbers)\n}\n</code>\n<|/\
    \ a tags=sorting,r,regex |>\n<| c |>\nThe answer by is much more elegant, I think.\n\
    <|/ c |>\n<| a tags=sorting,r,regex |>\nI like using the stringr library to do\
    \ this type of string manipulation. There are a couple ways to do this, but here's\
    \ a way that doesn't require any regex and handles your input in a nice fashion:\n\
    <code>", "\n  result <- gsub(\"[^0-9]\", \"\", numbers)\n  num <- c('zero', 'one',\
    \ 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine')\n  result <-\
    \ num[order(as.numeric(result))]\n  return(paste(result, collapse = \" \"))\n\
    }\n", "\n  \n  # split the numbers into character vectors based on the space\n\
    \  numbers <- strsplit(numbers, ' ')[[1]]\n  # sort the vector from smallest to\
    \ largest\n  numbers <- sort(numbers)\n  # convert the vector to a string\n  numbers\
    \ <- paste(numbers, collapse = ' ')\n  \n  # return the string\n  return(numbers)\n\
    }\n", "\n  numbers <- strsplit(numbers, \"\\\\s+\")[[1]]\n  numbers <- sort(numbers)\n\
    \  paste(numbers, collapse = \" \")\n}\n", "\n    numbers <- strsplit(numbers,\
    \ ' ')[[1]]\n    nums <- sort(numbers)\n    paste(sort(nums), collapse = ' ')\n\
    }\n", "\n    n <- strsplit(numbers, ' ')[[1]]\n    n <- n[order(n)]\n    paste(n,\
    \ collapse=' ')\n}\n", "\n    numbers <- strsplit(numbers, ' ')[[1]]\n    numbers\
    \ <- as.numeric(numbers)\n    numbers <- sort(numbers)\n    numbers <- paste0(numbers,\
    \ '')\n    numbers\n}\n</code>\n<|/ a tags=r |>\n<| a |>\nHere is another approach\n\
    <code>", "\n  splitnum <- strsplit(numbers, \" \")[[1]]\n  sort(unlist(splitnum))\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere is a recursive function that splits\
    \ the string, sorts the split elements and then pastes them back together with\
    \ collapse:\n<code>\nsort_string <- function(s) {\n  l <- strsplit(s, \" \")[[1]]\n\
    \  sapply(l, function(x) {\n    paste0(sort(x), collapse = \" \")\n  })\n}\n\n\
    sort_string(\"one three five\")", "\n    numbers <- unlist(strsplit(numbers, \"\
    \ \"))\n    numbers <- sort(numbers)\n    numbers <- paste(numbers, collapse =\
    \ \" \")\n    numbers\n}\n", "\n  numbers <- gsub(\" \", \"\", numbers)\n  numbers\
    \ <- gsub(\"[^0-9]\", \"\", numbers)\n  numbers <- gsub(\"^0\", \"\", numbers)\n\
    \  numbers <- gsub(\"^0-9\", \"\", numbers)\n  numbers <- gsub(\"^-\", \"\", numbers)\n\
    \  numbers <- gsub(\"^#\", \"\", numbers)\n  numbers <- as.numeric(numbers)\n\
    \  numbers[numbers < 0] <- 9999\n  numbers <- sort(numbers)\n  numbers <- paste0(\"\
    '\", numbers, \"'\")\n  return(numbers)\n}\n</code>\n<|/ a |>\n<| c |>\nHmmm...\
    \ this was meant to be a comment on one of the earlier answers.  It seems the\
    \ OP has deleted that comment.  I'm running into some problems with this answer,\
    \ though.  Please see my response to that question.\n<|/ c |>\n<| c |>\nI'm undeleting\
    \ it, but I have a new problem with it.  The numbers are sorting from smallest\
    \ to largest, but I need it to sort from largest to smallest.  My edit is above.\
    \  Thanks!\n<|/ c |>\n<| c |>\nI edited the answer to sort from largest to smallest;\
    \ this should work now. Having said that, I would strongly suggest using package\
    \ 'stringi' to clean up the strings (I personally prefer the stringr package for\
    \ string cleaning, since stringi is more \"verbose\"). I've edited my answer to\
    \ show you how this can be done using the stringi package.\n<|/ c |>\n<| c |>\n\
    Thanks again!  I really appreciate the help.  I'm going to play around with this\
    \ and see if I can figure this out.  I'm new to R, but I have a pretty good grasp\
    \ of it.  So far I have not been able to get this to work yet.  It seems that\
    \ no matter what I try to do with this solution, I am unable to get it to work.\
    \  I think I'm doing something wrong, but I'm not sure what.  I edited the main\
    \ post to show what I have done so far.  Thanks!\n<|/ c |>\n<| c |>\nI've edited\
    \ my answer to include an example on how to use `stringi` to get what you want.\n\
    <|/ c |>\n<| a dscore=1 |>\nIt was a difficult question to parse because your\
    \ example isn't particularly representative. Here's a function that sorts words\
    \ alphabetically, as in your example:\n<code>\nsort_words <- function(x, case\
    \ = FALSE) {\n  x_vec <- strsplit(x, \" \")[[1]]\n  x_sorted <- ", "\n  numbers\
    \ <- gsub(\"[^0-9]\", \"\", numbers)\n  numbers <- gsub(\"\\\\s\", \"\", numbers)\n\
    \  numbers <- as.numeric(numbers)\n  numbers <- sort(numbers)\n  numbers <- paste(numbers,\
    \ collapse = \" \")\n  numbers <- gsub(\"\\\\s\", \"-\", numbers)\n  numbers <-\
    \ paste(numbers, collapse = \"-\")\n  return(numbers)\n}\n</cell>\n<cell>\nsort_numbers('one\
    \ two three')\n</cell>\n<cell>\nsort_numbers('one one three six two')\n</cell>\n\
    <cell>\nsort_numbers('one two three two four')\n</cell>\n<text>\nThis function\
    \ is actually a wrapper around the more general, vectorized version of the 'sort_numbers'\
    \ function above.\n\n\n</text>\n<cell>\nsort_numbers <- Vectorize(sort_numbers)\n\
    </cell>\n<text>\nSome examples:\n\n\n</text>\n<cell>\nsort_numbers(c('zero', 'one',\
    \ 'three', 'four', 'two', 'seven', 'nine'))\n</cell>\n<cell>\nsort_numbers(c('zero',\
    \ 'one', 'three', 'four', 'two', 'seven', 'nine', 'eight', 'five', 'six'))\n</cell>\n\
    <cell>\nsort_numbers(c('zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\
    \ 'eight', 'nine'))\n</cell>\n<cell>\nsort_numbers(c('zero', 'one', 'two', 'three',\
    \ 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven'))\n</cell>\n\
    <text>\nFunctional Programming (FP)\nHaving now seen the 'sort_numbers' function\
    \ and the 'Vectorize' wrapper above we can now see the power of functional programming.\n\
    \nIn the next few functions we'll explore how this works and apply functional\
    \ programming to the 'sort_numbers' function above.\n\nOne of the most basic concepts\
    \ in FP is the application of functions. A function is a specific type of expression\
    \ that is used to manipulate data.\n\nIn functional programming functions use\
    \ 'names' to distinguish themselves from their arguments. For example, in the\
    \ following function, 'sort' takes in an argument 'numbers', and we give it a\
    \ name 'x'. x is then used inside the function to refer to this argument.\n\n\n\
    </text>\n<cell>", "\n  nums <- str_split(numbers, ' ')\n  nums\n  nums[order(nums[[1]],\
    \ decreasing = TRUE)]\n}\n\nsort_numbers('one two three')", "\n  number_list <-\
    \ as.list(strsplit(numbers, \" \"))\n  numbers_sorted <- sort(number_list)\n \
    \ paste(numbers_sorted, collapse=\" \")\n}\n", "\n  numbers <- tolower(numbers)\n\
    \  if (grepl(\"[^0-9 ]\", numbers)) stop(\"Invalid numbers in input. Numbers cannot\
    \ contain non-numeric characters.\")\n  output <- numbers\n  for(i in 1:(length(numbers)-1))\
    \ {\n    if(numbers[i] == ' ') output[i] <- ' '\n    if(numbers[i+1] == ' ') output[i+1]\
    \ <- ' '\n  }\n  for(i in 1:(length(output)-1)) {\n    if(output[i] == ' ') output[i]\
    \ <- ' '\n    if(output[i+1] != ' ' && output[i+1] < output[i]) output[i+1] <-\
    \ output[i]\n  }\n  for(i in 1:(length(output)-1)) {\n    if(output[i] != ' '\
    \ && output[i+1] == ' ') {\n      output[i] <- ' '\n      output[i+1] <- ' '\n\
    \    }\n  }\n  return(paste(output, collapse = \" \"))\n}\n", "\n  numbers <-\
    \ as.integer(unlist(strsplit(numbers, ' ')))\n  numbers[order(numbers)] <- paste(numbers[order(numbers)],\
    \ collapse = ' ')\n  return(paste(numbers, collapse = ' '))\n}\n", "\n  numbers\
    \ <- gsub('[^0-9]', '', numbers)\n  numbers <- gsub(' +', ' ', numbers)\n  numbers\
    \ <- sort(gsub('(^| )([0-9]{1})( |$)', '\\2 \\1', numbers))\n  paste(numbers,\
    \ collapse = ' ')\n}\n", "\n  # Convert string to vector with one entry per number\n\
    \  numbers <- strsplit(numbers, \" \")[[1]]\n  # Sort vector with numbers\n  numbers\
    \ <- numbers[order(numbers)]\n  # Convert numbers back to string\n  numbers <-\
    \ paste(numbers, collapse=\" \")\n  # Return result as a string\n  return(numbers)\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,sorting |>\nThis can be done fairly\
    \ easily with the stringr package, using str_split on a space and then ordering\
    \ the elements by position in the resulting vector and pasting the elements together.\n\
    <code>\nlibrary(stringr)\npaste(str_split(string1, \"\\\\s+\"), collapse = \"\
    \ \")[order(str_count(string1, \"\\\\s+\"))]\n</code>\nTo put this in a function:\n\
    <code>\nsort_numbers <- function(string1) {\n  paste(str_split(string1, \"\\\\\
    s+\"), collapse = \" \")[order(str_count(string1, \"\\\\s+\"))]\n}\n\nsort_numbers(string1)\n\
    [1] \"one two three\" \"four five six\"  \"seven eight nine\"\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=r,sorting |>\nHere is an option using base R\n<code>\n\
    paste(sort(unique(unlist(strsplit(string1, \" \")))), collapse=\" \")", "\n  numbers\
    \ <- strsplit(numbers, \" \")[[1]]\n  out <- paste(sort(numbers), collapse = \"\
    \ \")\n  return(out)\n}\n", "\n  numbers <- gsub(\" \", \"\", numbers) # Remove\
    \ spaces from string and remove spaces\n  numbers <- gsub(\"^[[:space:]]+|[[:space:]]+$\"\
    , \"\", numbers) # Remove leading/trailing whitespace\n  numbers <- gsub(\"[[:space:]]+\"\
    , \" \", numbers) # Replace multiple spaces with one space\n  numbers <- sort(numbers)\
    \ # Sort numbers\n  numbers <- paste(numbers, collapse = \" \") # Put numbers\
    \ together with spaces\n  return(numbers)\n}\n", "\n    numbers_string <- strsplit(numbers,\
    \ ' ')[[1]]\n    numbers_number <- as.numeric(unlist(numbers_string))\n    numbers_number_string\
    \ <- paste0(sort(numbers_number), collapse = \" \")\n    return(numbers_number_string)\n\
    }\n", "\n  # Parse the string and convert all strings to numbers\n  numbers <-\
    \ strsplit(numbers, \" \")[[1]]\n  numbers <- as.numeric(numbers)\n  \n  # Sort\
    \ from smallest to largest\n  numbers <- sort(numbers)\n  \n  # Convert back to\
    \ a string with the correct order\n  numbers <- paste(numbers, collapse = \" \"\
    )\n  \n  # Return the sorted string\n  return(numbers)\n}\n</cell>\n<cell>", "\n\
    \  numbers <- unlist(strsplit(numbers, \" \"))\n  numbers <- sort(numbers)\n \
    \ paste(numbers, collapse = \" \")\n}\n", "\n  sorted_numbers <- NULL\n  temp_number\
    \ <- 1L\n  for (i in as.integer(str_split(numbers, ' ')[[1]])) {\n    if (temp_number\
    \ > 9) {\n      sorted_numbers <- paste(sorted_numbers, paste(as.character(temp_number),\
    \ collapse = \" \"))\n      temp_number <- 1L\n    } else {\n      temp_number\
    \ <- temp_number + 1L\n    }\n  }\n  sorted_numbers <- paste(sorted_numbers, paste(as.character(temp_number),\
    \ collapse = \" \"))\n  sorted_numbers\n}\n</code>\n<|/ a tags=string,sorting,r,data-cleaning\
    \ |>\n<| a dscore=3 tags=string,sorting,r,data-cleaning |>\n<code>\nsort_numbers\
    \ <- function(x) {\n  numbers_sorted = NULL\n  i = 0\n  while(i < length(x)) {\n\
    \    numbers_sorted <- c(numbers_sorted, substr(x, i, i))\n    i = i + 1\n  }\n\
    \  numbers_sorted\n}\n</code>\n<|/ a |>\n<| a dscore=3 tags=string,sorting,r,data-cleaning\
    \ |>\nThis question was asked over 2 years ago and I wonder if any of the answers\
    \ have actually been tested? I wrote a test to see if the answers work. I am assuming\
    \ that the strings are in a data frame called df$numbers. \n<code>", "\n  # Convert\
    \ the string to a vector of numbers\n  numbers <- strsplit(numbers, ' ')[[1]]\n\
    \n  # Sort from smallest to largest\n  numbers <- sort(numbers)\n\n  # Convert\
    \ back to a string\n  numbers <- paste(numbers, collapse = ' ')\n  return(numbers)\n\
    }\n", "\n  # Split numbers by space\n  numbers <- strsplit(numbers, ' ')[[1]]\n\
    \  # Sort numbers in descending order\n  numbers <- sort(numbers, decreasing =\
    \ TRUE)\n  # Return sorted numbers\n  paste(numbers, collapse = ' ')\n}\n</code>\n\
    <|/ a dscore=2 tags=r |>\n<| c |>\nThe `strsplit` function is designed for splitting\
    \ strings on character classes, not strings.\n<|/ c |>\n<| c |>\nAh, good point.\
    \  I've fixed the answer.\n<|/ c |>\n<| a dscore=1 |>\nTry this:\n<code>\nsort_numbers\
    \ <- function(numbers) {\n  numbers = strsplit(numbers, ' ')[[1]]\n  sort(numbers,\
    \ decreasing = TRUE)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work\
    \ with a character vector containing numbers that aren't in ascending order.\n\
    <|/ c |>\n<| a tags=r dscore=1 |>\nA data.table approach -\n<code>\nlibrary(\"\
    data.table\")\nx1 <- c(\"one two three\", \"four three five\", \"seven two nine\"\
    )\nx2 <- c(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\"\
    , \"seven\", \"eight\", \"nine\")\nx3 <- c(\"seven eight nine\", \"eight six seven\"\
    , \"two five five\")\n\nDT1 <- data.table(x1,x2)\nDT2 <- data.table(x3,x2)\nsetkey(DT1,x1)\n\
    setkey(DT2,x3)\nDT1[DT2,\n     .(sort_numbers = paste0(sort(unlist(x2)), collapse\
    \ = \" \"))\n     ][, V1 := NULL]", "\n  numbers <- strsplit(numbers, ' ')[[1]]\n\
    \  if(length(numbers) == 0)\n    return(numbers)\n  if(numbers[-1] < 9)\n    return(sort(numbers))\n\
    \  if(numbers[-1] == 9)\n    return(sort(numbers))\n  if(numbers[-1] > 9)\n  \
    \  return(sort(numbers))\n  return(sort(numbers))\n}\n", "\n  as.numeric(gsub(\"\
    \\\\s+|([[:digit:]]+)(?=[[:alpha:]]|$)\", paste, strsplit(numbers, ' ')[[1]]))\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=sorting,r dscore=1 |>\nAs far as I know,\
    \ the R base doesn't have a function to do this, but here's a way with dplyr and\
    \ dplyr::arrange.\n<code>\ndf <- data.frame(X = c(\"one\",\"two\",\"three\",\"\
    four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\",\"ten\"))\n\ndf %>% mutate(Z\
    \ = as.numeric(sub('\\\\s', '',X))) %>% arrange(Z)\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nYou can use the dplyr package to do this. Here I am creating a new column\
    \ \"sort_num\" that calculates the numbers in your vector according to your rules.\
    \ Then I am just ordering your data by that column:\n<code>\ndf <- data.frame(X\
    \ = c(\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\"\
    ,\"nine\",\"ten\"))\ndf$sort_num <- as.numeric(gsub(\"\\\\s+|([[:digit:]]+)(?=[[:alpha:]]|$)\"\
    , paste, strsplit(df$X, ' ')[[1]]))\ndf <- df %>% arrange(sort_num)\n</code>\n\
    <|/ a tags=sorting,r |>\n<| a tags=sorting,r |>\nI like using arrange from dplyr\
    \ for this sort of thing:\n<code>\ndf <- data.frame(X = c(\"one\",\"two\",\"three\"\
    ,\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\",\"ten\"))\n\ndf %>% \n\
    \  mutate(sort_num = as.numeric(gsub(\"\\\\s+|([[:digit:]]+)(?=[[:alpha:]]|$)\"\
    , paste, strsplit(X, ' ')[[1]]))) %>% \n  arrange(sort_num)\n\n   X  sort_num\n\
    1 one        1\n2 two        2\n3 three     3\n4 four      4\n5 five      5\n\
    6 six       6\n7 seven     7\n8 eight     8\n9 nine      9\n10 ten      10\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=sorting,r dscore=1 |>\nThe R base way:\n<code>",
  "\n  numbers <- strsplit(numbers, \" \")[[1]]\n  out <- sort(numbers)\n  out <-\
    \ paste(out, \"\\n\")\n  return(out)\n}\n", "\n  numbers <- gsub(\"\\\\s+\", \"\
    \ \", numbers)\n  numbers <- gsub(\"\\\\s*\", \"\", numbers)\n  numbers <- gsub(\"\
    \\\\s+$\", \"\", numbers)\n  numbers <- as.numeric(numbers)\n  numbers <- sort(numbers)\n\
    \  numbers <- paste(numbers, collapse = \" \")\n  numbers[length(numbers)]\n}\n\
    \nsort_numbers(\"one two three four five six seven eight nine\")", "\n  numbers\
    \ <- strsplit(numbers, ' ')\n  numbers_sorted <- sort(unlist(numbers))\n  paste(numbers_sorted,\
    \ collapse = ' ')\n}\n", "\n    # Create a vector of valid numbers, e.g. 'one',\
    \ 'two', 'three', etc.\n    numbers <- c(\"zero\", \"one\", \"two\", \"three\"\
    , \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n    # Sort the\
    \ vector in descending order using order()\n    sorted <- order(rev(numbers))\n\
    \    # Extract the vector of numbers corresponding to the\n    # sorted vector,\
    \ e.g. the numbers 'one', 'three', 'five'.\n    sorted <- numbers[sorted]\n  \
    \  # Return the string with numbers sorted from smallest to largest\n    return(paste(sorted,\
    \ collapse = \" \"))\n}\n</code>\n<|/ a tags=function,r,function dscore=0 |>\n\
    <| a |>\nAn alternative to using regular expressions is to use strsplit() to split\
    \ the strings into individual numbers and then sort them:\n<code>\nsort_numbers\
    \ <- function(numbers) {\n  # Create a vector of valid numbers, e.g. 'one', 'two',\
    \ 'three', etc.\n  numbers <- c(\"zero\", \"one\", \"two\", \"three\", \"four\"\
    , \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n  # Sort the vector in descending\
    \ order using order()\n  sorted <- order(sapply(strsplit(numbers, split = \" \"\
    ), sort))\n  # Extract the vector of numbers corresponding to the\n  # sorted\
    \ vector, e.g. the numbers 'one', 'three', 'five'.\n  sorted <- numbers[sorted]\n\
    \  # Return the string with numbers sorted from smallest to largest\n  return(paste(sorted,\
    \ collapse = \" \"))\n}\n\nsort_numbers(\"three one five\")", "\n  number <- c(0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9)\n  string <- strsplit(numbers, \" \")\n  string <-\
    \ unlist(string)\n  string[order(as.numeric(string))]\n}\n</code>\n<|/ a |>\n\
    <| a tags=r |>\nI got it\n<code>\nsort_numbers <- function(numbers) {\n  number\
    \ <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n  string <- strsplit(numbers, \" \")\n \
    \ string <- unlist(string)\n  string[order(as.numeric(string))]\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI added it at the top and you didnt add it at the\
    \ bottom where you got the function code.  It should be `return(string)`\n<|/\
    \ c |>\n<| c |>\nOh yes sorry, I see now, but do you know what is the problem\
    \ with the code? It doesn't work for me\n<|/ c |>\n<| c |>\nthe problem is that\
    \ your original string was not split properly into the individual numbers.  Your\
    \ example input was \"three one five\".  So you just needed to change the code\
    \ to `strsplit(numbers, \" \")`\n<|/ c |>\n<| c |>\nI just edited your original\
    \ post.  You added the function definition in the middle of the code section.\
    \  The function needed to be at the top and your function had an extra `}` at\
    \ the end.  I moved it to the top and formatted your `numbers` variable a little\
    \ to make it easier to read.  Try my code at the bottom and see if it works for\
    \ you.\n<|/ c |>\n<| c |>\nThanks! It really helps\n<|/ c |>\n<| a dscore=0 |>\n\
    As others have mentioned, using strsplit is one option, but another option is\
    \ to use stringi::stri_split_fixed.  \n<code>\nlibrary(stringi)\n\nsort_numbers\
    \ <- function(numbers) {\n  stri_split_fixed(numbers, \" \")[[1]]\n}\n\nsort_numbers(\"\
    three one five\")", "\n    # Convert string to vector\n    numbers <- strsplit(numbers,\
    \ \"\\\\s+\", fixed = TRUE)\n    numbers <- unlist(numbers)\n\n    # Sort vector\n\
    \    numbers <- numbers[order(numbers)]\n\n    # Convert vector back to string\n\
    \    numbers <- paste(numbers, collapse = \" \")\n    return(numbers)\n}\n</code>\n\
    <|/ a tags=sorting,string,r,numbers,numbers |>\n<| a tags=sorting,string,r,numbers,numbers\
    \ |>\nA function using gsub to replace all non-numeric characters in numbers with\
    \ NA. Then you can sort using na.omit(numbers).\n<code>\nnumbers <- c(\"zero\"\
    ,\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"\
    )\nnumbers <- gsub(\"[^0-9]\",\"\",numbers)\nnumbers[order(na.omit(numbers))]\n\
    </code>\nOutput:\n<code>\n[1] \"one\" \"three\" \"five\" \"two\" \"six\"  \"eight\"\
    \ \"four\"  \"seven\" \"nine\"\n</code>\n<|/ a dscore=4 |>\n<| a |>\nTo sort numbers\
    \ that are mixed numeric and non-numeric or have leading zeros, use the order\
    \ function like so:\n<code>\nnumbers <- c(\"zero\", \"one\", \"two\", \"three\"\
    , \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\"\
    , \"twelve\")\nnumbers <- as.numeric(gsub(\"[^0-9]\", NA, numbers))\n\norders\
    \ <- c(rep(1,10), \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"\
    seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\")\norders[order(as.numeric(orders),\
    \ decreasing = TRUE)]", "\n  numbers <- gsub(\"[^0-9]\", \"\", numbers)\n  numbers_sorted\
    \ <- gsub(\"([0-9])\", \"\\\\1\", numbers)\n  sort(numbers_sorted)\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nAnother approach would be to take input as a string\
    \ and parse it using base R gregexpr.  Here, we will use regexp to match the pattern\
    \ in the question and replace the string with just the digits.  In base R we could\
    \ do this as\n<code>\nv1 <- gsub(\"^((?<=\\\\d) (?=\\\\d)|(?<=\\\\d) (?=\\\\d))+\"\
    , \"\", v1)\n</code>\nWe could also do this with gsubfn in the qdap package with\
    \ \n<code>\nlibrary(qdap)\ngsubfn(\"\\\\d+\", ~ gsub(\"^((?<=\\\\d) (?=\\\\d)|(?<=\\\
    \\d) (?=\\\\d))+\", \"\", .), v1)\n</code>\nIf we need it to be a factor we can\
    \ use fct_inorder, as in the other solutions.\ndata\n<code>\nv1 <- c('three',\
    \ 'one', 'five', 'two', 'four', 'six')\n</code>\n<|/ a tags=r |>\n<| a |>\nAnother\
    \ way of doing it is to turn your numeric values into a factor, and order your\
    \ levels by the factor levels then unfactor the factor to return the ordered numeric\
    \ values.\n<code>\nmydata <- data.frame(mynum = c(1,1,2,2,2,3,3))\nmydata\n  mynum\n\
    1     1\n2     1\n3     2\n4     2\n5     2\n6     3\n7     3\n\nmydata$factor\
    \ <- factor(mydata$mynum, levels = c(1,2,3))\n\nmydata[order(mydata$factor),]\n\
    \n  mynum factor\n6     3       3\n5     2       2\n4     2       2\n3     1 \
    \      1\n2     1       1\n1     1       1\n</code>\n<|/ a tags=r dscore=0 |>\n\
    <| a tags=r |>\nThis may be a little too obvious, but if you just want to get\
    \ all digits and leave all other characters in the string intact, you could use\
    \ str_replace_all() from the stringr package. It only replaces digits:\n<code>\n\
    v1 <- c('three', 'one', 'five', 'two', 'four', 'six')\n\nlibrary(stringr)\nlibrary(magrittr)\n\
    \nstr_replace_all(v1, pattern = \"\\\\d\")\n[1] \"3\"  \"1\"  \"5\"  \"2\"  \"\
    4\"  \"6\" \n", "\n    splits <- strsplit(numbers, ' ')[[1]]\n    splits <- split(splits,\
    \ as.integer(splits))\n    out <- unlist(splits)\n    out <- sort(out, decreasing\
    \ = TRUE)\n    paste(out, '')\n}\n</code>\n<|/ a tags=regex,r |>\n<| a |>\nHere\
    \ is another possibility using str_extract:\n<code>\nlibrary(stringr)\n\nx <-\
    \ c('one two three', 'five three four', 'six five seven')\nstr_extract(x, regex('(?<=\\\
    \\s)(?=\\\\d)'))\n</code>\nwhich gives:\n\n<code>\n[1] \"one two three\"  \"three\
    \ five four\"  \"six five seven\"\n</code>\n<|/ a dscore=2 tags=regex,r |>\n<|\
    \ a dscore=2 |>\nHere is another base R solution using strsplit():\n<code>\nx\
    \ <- c('one two three', 'five three four', 'six five seven')\n\nsapply(strsplit(x,\
    \ ' '), function(i) paste(i, collapse = ' '))", "\n  numbers <- strsplit(numbers,\
    \ ' ')\n  numbers[[1]]\n  numbers[[1]][order(numbers[[1]])]\n}\n", "\n  numbers\
    \ <- unlist(strsplit(numbers, ' '))\n  numbers <- numbers[order(numbers)]\n  numbers[numbers\
    \ == ''] <- NA\n  paste0(numbers, collapse = ' ')\n}\n", "\n  numbers <- gsub(\"\
    \ \", \"\", numbers)\n  numbers <- gsub(\"[^0-9a-zA-Z]\", \"\", numbers)\n  numbers\
    \ <- sort(numbers)\n  numbers <- paste(numbers, collapse=' ')\n  return(numbers)\n\
    }\n</code>\nOutput:\n<code>\n> sort_numbers('nine')\n[1] \"nine\"\n> sort_numbers('three')\n\
    [1] \"three\"\n> sort_numbers('five seven three one')\n[1] \"one three five seven\"\
    \n</code>\n<|/ a dscore=2 |>\n<| a tags=string,regex,sorting,r |>\nUsing lapply\
    \ you can do:\n<code>\nsort_numbers <- function(string){\n  string <- gsub(\"\
    \ \",\"\",string)\n  string <- gsub(\"[^0-9a-zA-Z]\",\"\",string)\n  string <-\
    \ sort(string)\n  return(paste0(string,collapse = \" \"))\n}\n\nlapply(c(\"nine\"\
    ,\"three\",\"five seven three one\"),sort_numbers)", "\n  x <- as.numeric(unlist(strsplit(numbers,\
    \ ' ')))\n  x[order(x)]\n}\n</code>\n<|/ a dscore=2 tags=r |>\n<| a dscore=2 |>\n\
    We can use gsubfn \n<code>\nlibrary(gsubfn)\nunlist(lapply(strsplit(numbers, \"\
    \ \"), as.numeric), use.names = FALSE)", "\n  numbers <- gsub(\" \", \"\", numbers)\n\
    \  numbers <- as.numeric(gsub(\",\", \"\", numbers))\n  sort(numbers)\n}\n", "\n\
    \    # First we split the string into single words.\n    numbers <- strsplit(numbers,\
    \ \" \")[[1]]\n    numbers <- sort(as.numeric(numbers))\n    numbers <- paste(numbers,\
    \ collapse = \" \")\n    return(numbers)\n}\n", "\n  numbers <- unlist(strsplit(numbers,\
    \ \" \"))\n  numbers <- numbers[(numbers >= 0 & numbers <= 9)]\n  numbers <- numbers[order(numbers)]\n\
    \  numbers <- paste0(numbers, \" \")\n  return(numbers)\n}\n</code>\n<|/ a tags=string,sorting,r,character\
    \ |>\n<| c |>\nThanks, I just implemented this into my code and it is working\
    \ great!\n<|/ c |>\n<| a dscore=1 |>\nHere's a regex approach:\n<code>\nx <- c(\"\
    three one five\", \"zero four nine\", \"three six ten\", \"one zero nine eleven\"\
    )\nsapply(x, function(x) regmatches(x, gregexpr(\"\\\\s+\", x))[[1]][order(regmatches(x,\
    \ gregexpr(\"\\\\s+\", x))[[1]])])", "\n  number_list <- strsplit(numbers, \"\
    \ \")[[1]]\n  number_list <- as.numeric(number_list)\n  number_list <- sort(number_list)\n\
    \  number_list <- paste(number_list, collapse = \" \")\n  return(number_list)\n\
    }\n", "\n  numbers <- strsplit(numbers, \" \")[[1]]\n  number <- gsub(\"[^0-9]\"\
    , \"\", numbers)\n  numbers <- sort(number)\n  numbers_string <- paste(numbers,\
    \ collapse = \" \")\n  return(numbers_string)\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I find this solution more elegant than's, in that it condenses all the logic into\
    \ a single function\n<|/ c |>\n<| a |>\nUsing gsub function with regular expressions\
    \ would work and be easily readable as well. The below solution would also work\
    \ when the numbers are in different order than the other examples (if they exist).\n\
    <code>\nlibrary(gsubfn)\nstr <- c(\"three one five\", \"five one two\")\ngsubfn(\"\
    ([0-9]+)\",\n       function(x) paste0(sort(x), collapse = \" \"),\n       str\n\
    )", "\n  nums <- strsplit(numbers, ' ')[[1]]\n  sort <- numeric(length(nums))\n\
    \  for(i in 1:length(nums)) {\n    sort[[i]] <- as.numeric(nums[i])\n  }\n  names(sort)\
    \ <- nums\n  sort(sort)\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nsort_numbers\
    \ <- function(x) {\n    x <- stringr::str_split(x, \" \")[[1]]\n    x <- sort(x)\n\
    \    paste(x, collapse = \" \")\n}\n</code>\n<|/ a dscore=0 tags=string,sorting,r\
    \ |>\n<| c |>\nIt's not necessary to convert the string to character. Also, `sort`\
    \ is vectorized so you don't need a loop.\n<|/ c |>\n<| c |>\n, thanks for the\
    \ comment. The `stringr::str_split` splits into a character vector. By calling\
    \ `[[1]]` you are extracting the character vector.\n<|/ c |>\n<| c |>\nMy mistake,\
    \ I wasn't aware that `str_split` returned a list.\n<|/ c |>\n<| a |>\nHere is\
    \ a solution using dplyr and stringr. Here is an explanation of the solution:\n\
    1) Separate numbers by spaces and get them as a tibble\n<code>\nlibrary(dplyr)\n\
    library(stringr)\n\nseparate_numbers_by <- function(x) {\n    tibble(\n      \
    \  words = str_split(x, \" \"),\n        number = str_extract(x, \"[[:digit:]]+\"\
    ))\n}\n\nnumber_df <- separate_numbers_by(dat$numbers)\n</code>\n2) Convert the\
    \ tibble to a data frame with one row per number with two columns: one containing\
    \ the numbers as numbers and the second containing the names of the numbers.\n\
    <code>\nnumber_df <- number_df %>%\n    tidyr::unite(numbers, words, number, sep\
    \ = \" \") %>%\n    dplyr::select(numbers, words)\n</code>\n3) Order them by number\n\
    <code>\nnumber_df <- number_df %>%\n    dplyr::arrange(numbers)\n</code>\n4) Rebuild\
    \ the original string with sorted numbers.\n<code>\ndat %>%\n    mutate(numbers\
    \ = paste0(numbers, collapse = \" \")) %>%\n    select(numbers)\n</code>\n<|/\
    \ a tags=string,sorting,r dscore=0 |>\n<| a dscore=0 |>\nHere's a base R option\
    \ that uses the fact that paste0(sort(unlist(strsplit(x, \" \"))), collapse =\
    \ \" \") works even with multiple numbers in a single string:", "\n  numbers <-\
    \ strsplit(numbers, '\\\\s+')\n  numbers_sorted <- c()\n  for (i in 1:length(numbers))\
    \ {\n    numbers_sorted <- c(numbers_sorted,\n                        paste(sort(numbers[[i]]),\n\
    \                              collapse = ' '))\n  }\n  return(paste(numbers_sorted,\n\
    \              collapse = ' '))\n}\n</code>\nResulting output:\n<code>", "\n \
    \ numbers <- strsplit(numbers, ' ')\n  numbers <- unlist(numbers)\n  sort(numbers)\n\
    }\n", "\n  numbers_sorted <- c()\n  split_numbers <- strsplit(numbers, ' ')[[1]]\n\
    \  for (i in seq_along(split_numbers)) {\n    if (split_numbers[i] %in% 'zero')\
    \ { \n      numbers_sorted <- c(numbers_sorted, 'zero')\n    } else if (split_numbers[i]\
    \ %in% 'one') {\n      numbers_sorted <- c(numbers_sorted, 'one')\n    } else\
    \ if (split_numbers[i] %in% 'two') {\n      numbers_sorted <- c(numbers_sorted,\
    \ 'two')\n    } else if (split_numbers[i] %in% 'three') {\n      numbers_sorted\
    \ <- c(numbers_sorted, 'three')\n    } else if (split_numbers[i] %in% 'four')\
    \ {\n      numbers_sorted <- c(numbers_sorted, 'four')\n    } else if (split_numbers[i]\
    \ %in% 'five') {\n      numbers_sorted <- c(numbers_sorted, 'five')\n    } else\
    \ if (split_numbers[i] %in% 'six') {\n      numbers_sorted <- c(numbers_sorted,\
    \ 'six')\n    } else if (split_numbers[i] %in% 'seven') {\n      numbers_sorted\
    \ <- c(numbers_sorted, 'seven')\n    } else if (split_numbers[i] %in% 'eight')\
    \ {\n      numbers_sorted <- c(numbers_sorted, 'eight')\n    } else if (split_numbers[i]\
    \ %in% 'nine') {\n      numbers_sorted <- c(numbers_sorted, 'nine')\n    }\n \
    \ }\n  paste(numbers_sorted, collapse = ' ')\n}\n", "\n  numbers <- as.character(numbers)\n\
    \  numbers[numbers == 'zero'] <- 'one'\n  numbers[numbers == 'one'] <- 'two'\n\
    \  numbers[numbers == 'two'] <- 'three'\n  numbers[numbers == 'three'] <- 'four'\n\
    \  numbers[numbers == 'four'] <- 'five'\n  numbers[numbers == 'five'] <- 'six'\n\
    \  numbers[numbers == 'six'] <- 'seven'\n  numbers[numbers == 'seven'] <- 'eight'\n\
    \  numbers[numbers == 'eight'] <- 'nine'\n  numbers[numbers == 'nine'] <- 'zero'\n\
    \  sort(numbers, decreasing = TRUE)\n}\n</code>\n<|/ a tags=string,r,sorting dscore=2\
    \ |>\n<| a dscore=2 |>\nHere is a possible solution using base R:\n<code>\nv <-\
    \ sapply(strsplit(numbers, \"\\\\s+\"), function(x) sort(x))\npaste(v[c(FALSE,\
    \ TRUE)], collapse = \" \")\n</code>\nor with base R:\n<code>\npaste(sort(unlist(strsplit(numbers,\
    \ \"\\\\s+\")))[c(TRUE, FALSE)], collapse = \" \")\n</code>\nor with base R:\n\
    <code>\npaste(sort(unlist(strsplit(numbers, \"\\\\s+\")), decreasing = TRUE)[c(TRUE,\
    \ FALSE)], collapse = \" \")\n</code>\nResult:\n<code>\n[1] \"three one five\"\
    \n</code>\n<|/ a tags=string,r,sorting |>\n<| a |>\nHere is a base R solution\
    \ that splits the string on spaces, then sorts each chunk, combines the pieces,\
    \ then pastes the pieces together:\n<code>\npaste(\n  unlist(lapply(strsplit(numbers,\
    \ \" \"), sort))[c(TRUE, FALSE)],\n  collapse = \" \",\n)", "\n  numbers <- as.character(numbers)\n\
    \  numbers2 <- strsplit(numbers, \" \")[[1]]\n  numbers3 <- gsub(\"zero\", \"\"\
    , numbers)\n  numbers4 <- gsub(\"nine\", \"\", numbers)\n  numbers5 <- gsub(\"\
    one\", \"1\", numbers3)\n  numbers6 <- gsub(\"two\", \"2\", numbers3)\n  numbers7\
    \ <- gsub(\"three\", \"3\", numbers3)\n  numbers8 <- gsub(\"four\", \"4\", numbers3)\n\
    \  numbers9 <- gsub(\"five\", \"5\", numbers3)\n  numbers10 <- gsub(\"six\", \"\
    6\", numbers3)\n  numbers11 <- gsub(\"seven\", \"7\", numbers3)\n  numbers12 <-\
    \ gsub(\"eight\", \"8\", numbers3)\n  numbers13 <- gsub(\"nine\", \"9\", numbers3)\n\
    \  numbers30 <- paste(numbers5, numbers6, numbers7, sep=\" \")\n  numbers31 <-\
    \ paste(numbers8, numbers9, numbers10, sep=\" \")\n  numbers32 <- paste(numbers11,\
    \ numbers12, numbers13, sep=\" \")\n  return(paste(numbers30, numbers32, sep=\"\
    \ \"))\n}\n", "\n  numbers <- unlist(strsplit(numbers, ' '))\n  numbers <- sort(numbers)\n\
    \  numbers <- paste(numbers, collapse = ' ')\n  numbers\n}\n</cell>\n<cell>",
  "\n  n <- as.numeric(unlist(strsplit(numbers, ' ')))\n  n[n == \"nine\"] <- 9\n\
    \  n[n == \"eight\"] <- 8\n  n[n == \"seven\"] <- 7\n  n[n == \"six\"] <- 6\n\
    \  n[n == \"five\"] <- 5\n  n[n == \"four\"] <- 4\n  n[n == \"three\"] <- 3\n\
    \  n[n == \"two\"] <- 2\n  n[n == \"one\"] <- 1\n  n[n == \"zero\"] <- 0\n  sort(n)\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,function,string |>\nWe can use separate_rows\
    \ on the 'numbers' column\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\ndf1 %>%\n \
    \  separate_rows(numbers)\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,function,string\
    \ dscore=0 |>\nIf you have data frame:\n<code>\nnumbers <- c('zero one two three\
    \ four five six seven eight nine', 'one two three four five six seven eight nine')\n\
    \nnumbers <- c('zero one two three four five six seven eight nine',\n        \
    \     'one two three four five six seven eight nine')\n\ndf <- data.frame(numbers)\n\
    </code>\nThen this should work:\n<code>\n library(stringr)\n\n df <- data.frame(numbers)\n\
    \ df$numbers_sorted <- str_split(df$numbers, ' ')[[1]][order(str_split(df$numbers,\
    \ ' ')[[1]])]\n</code>\n<|/ a |>\n<| a |>\nYou could split the number column into\
    \ rows (using separate_rows() from the tidyr package) and then order the values\
    \ by row. Something like:\n<code>\nlibrary(tidyverse)\n\ndf <- tibble(\n  numbers\
    \ = c('zero one two three four five six seven eight nine',\n              'one\
    \ two three four five six seven eight nine'),\n  stringsAsFactors = FALSE\n)\n\
    \ndf %>% separate_rows(numbers) %>% \n  arrange(row_number())\n</code>\nWhich\
    \ gives:\n<code>", "\n    numbers <- strsplit(numbers, \" \")[[1]]\n    numbers\n\
    }\n\nsort_numbers('eight nine two six')", "\n  stopifnot(is.character(numbers))\n\
    \  stopifnot(grepl('^[0-9]{1,2}$', numbers))\n  stopifnot(grepl('one|two|three|four|five|six|seven|eight|nine$',\
    \ numbers))\n  numbers <- strsplit(numbers, ' ')[[1]]\n  numbers <- sort(numbers)\n\
    \  paste(numbers, collapse = ' ')\n}\n", "\n  numbers <- gsub(\" \", \"\", numbers)\n\
    \  numbers <- sort(numbers)\n  return(numbers)\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=r,regex |>\nUsing stri_replace_all_regex from stringi package, you can\
    \ do:\n<code>\nlibrary(stringi)\nstr <- \"three one five\"\nstri_replace_all_regex(str,\
    \ \"([a-z]{2})([0-9]+)\",\n                       c(`0` = \"0\", `1` = \"1\",\
    \ `2` = \"2\", `3` = \"3\", `4` = \"4\", `5` = \"5\", `6` = \"6\", `7` = \"7\"\
    ,\n                         `8` = \"8\", `9` = \"9\"))", "\n  numbers<-strsplit(numbers,\
    \ ' ')[[1]]\n  numbers<-paste(sort(numbers), collapse=' ')\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\n`library(dplyr)`\n`df %>% group_by(group) %>% mutate(value = paste(sort(value),\
    \ collapse = \" \")) %>% ungroup()`\n<|/ c |>\n<| c |>\n`df$value <- with(df,\
    \ paste(sort(value), collapse = \" \")) %>% as.numeric()`\n<|/ c |>\n<| a dscore=5\
    \ |>\nHere is an option with data.table\n<code>\nlibrary(data.table)\nsetDT(df)[order(as.numeric(do.call(paste,\
    \ c(.SD, sep=\" \")))), ]\n</code>\n<|/ a tags=dataframe,sorting,r |>\n<| c |>\n\
    This answer should be selected as it's the fastest and simplest one. Not only\
    \ because it uses `data.table` but also because it is written in plain R and doesn't\
    \ rely on any external libraries.\n<|/ c |>\n<| a tags=dataframe,sorting,r |>\n\
    Here are some benchmarks of the various solutions. \nThe data.table solution is\
    \ the fastest by far, followed by dplyr and finally the purrr solution.\n<code>\n\
    library(microbenchmark)\nlibrary(dplyr)\nlibrary(purrr)\n</code>\nA simple sample\
    \ data.frame:\n<code>\ndf <- data.frame(a = c(\"a\", \"b\", \"c\", \"d\"), b =\
    \ c(1,5,3,8), stringsAsFactors = FALSE)\n</code>\ndata.table solution:\n<code>\n\
    data.table(df)[order(as.numeric(do.call(paste, c(.SD, sep=\" \")))), ]\n", "\n\
    \    numbers <- stringr::str_remove(numbers, \"[:digit:]\")\n    numbers <- str_replace_all(numbers,\
    \ \"[:alpha:]\", \" \", 1)\n    numbers <- str_replace_all(numbers, \" \", \"\"\
    , fixed = TRUE)\n    numbers <- str_replace_all(numbers, \"\\\\s\", \"\")\n  \
    \  numbers <- str_replace_all(numbers, \",\", \"\")\n    numbers[numbers == \"\
    \"] <- 0\n    numbers <- sort(numbers)\n    numbers\n}\n</cell>\n<cell>\nsort_numbers('one\
    \ three three')\n</cell>\n<cell>", "\n  numbers <- gsub(\"\\\\s\",\"\", numbers)\n\
    \  numbers <- gsub(\"[^0-9]\",\"\", numbers)\n  numbers <- gsub(\"^\\\\D+|\\\\\
    s+\",\"\", numbers)\n  numbers <- gsub(\"^\\\\D+|\\\\s+|$\",\"\", numbers)\n \
    \ numbers <- gsub(\"\\\\D+$\",\"\", numbers)\n  numbers <- sort(as.numeric(numbers))\n\
    \  numbers <- paste(numbers, collapse = \" \")\n  return(numbers)\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nThis problem has been solved, thanks guys for your\
    \ help\n<code>\nsort_numbers <- function(numbers){\n  numbers <- gsub(\"\\\\s\"\
    ,\"\", numbers)\n  numbers <- gsub(\"[^0-9]\",\"\", numbers)\n  numbers <- gsub(\"\
    ^\\\\D+|\\\\s+\",\"\", numbers)\n  numbers <- gsub(\"^\\\\D+|\\\\s+|$\",\"\",\
    \ numbers)\n  numbers <- gsub(\"\\\\D+$\",\"\", numbers)\n  numbers <- sort(as.numeric(numbers))\n\
    \  numbers <- paste(numbers, collapse = \" \")\n  return(numbers)\n}\n\n</code>\n\
    <|/ a tags=numbers,sorting,r |>\n<| a tags=numbers,sorting,r |>\nA slight variation\
    \ on Alistair's solution:\n<code>\nsort_numbers <- function(numbers){\n    numbers\
    \ <- gsub(\"\\\\s\", \"\", numbers)\n    numbers <- gsub(\"[^0-9]\", \"\", numbers)\n\
    \    numbers <- gsub(\"^\\\\D+|\\\\s+\", \"\", numbers)\n    numbers <- gsub(\"\
    ^\\\\D+|\\\\s+|$\", \"\", numbers)\n    numbers <- gsub(\"\\\\D+$\", \"\", numbers)\n\
    \    numbers <- sort(as.numeric(numbers))\n    numbers <- paste(numbers, collapse\
    \ = \" \")\n    return(numbers)\n}\n\nsort_numbers(\"one two three four\")", "\n\
    \  sorted <- sort(as.numeric(unlist(strsplit(numbers, ' '))))\n  return(paste(sorted,\
    \ '\\n', sep=' '))\n}\n", "\n  numbers_string <- unlist(strsplit(numbers, \" \"\
    ))\n  numbers_string <- numbers_string[order(numbers_string)]\n  return(paste(numbers_string,\
    \ collapse = \" \"))\n}\n</code>\n<|/ a |>\n<| c |>\nI think it's more intuitive\
    \ to take the input as an ordered character vector with space separated terms,\
    \ and then to sort it.  I think this is more intuitive to me than to others, but\
    \ I'm a mathematician and am used to the idea of sorting ordered vectors.\n<|/\
    \ c |>\n<| c |>\n, I like how you recast the question as an ordered character\
    \ vector with spaces separating the terms.  I think it's more intuitive to me\
    \ that way too.\n<|/ c |>\n<| c |>\nYou don't need the `paste` call at all. It\
    \ should just be `sort(unlist(strsplit(numbers, \" \")))`\n<|/ c |>\n<| c |>\n\
    Good call on `paste`!\n<|/ c |>\n<| a tags=r,sorting,split |>\n<code>\nnumbers\
    \ <- c(\"one three five seven nine\", \"one two five eight nine\")\nsort(gsub(\"\
    \\\\s\",\"\",numbers))\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 |>\nHere's another\
    \ possibility:\n<code>\nnumbers <- c(\"one three five seven nine\", \"one two\
    \ five eight nine\")\n\ngsub(\"\\\\s+\",\"\", numbers)\n[1] \"one three five seven\
    \ nine\" \"one two five eight nine\"\n\nsort(gsub(\"\\\\s+\",\"\", numbers))\n\
    [1] \"one two five eight nine\" \"one three five seven nine\"\n</code>\n<|/ a\
    \ tags=r,sorting,split |>\n<| c |>\nNice one, using `gsub`. I was just about to\
    \ post an answer using `substr` but you beat me to it :)\n<|/ c |>\n<| c |>\n\
    I think the more important difference is that `gsub` only searches for one or\
    \ more whitespaces, which makes it a little faster and more concise.  That said,\
    \ this is definitely the way to go.\n<|/ c |>\n<| c |>\nI'm sure the speed would\
    \ be negligible since `gsub` doesn't use regular expressions.\n<|/ c |>\n<| c\
    \ |>\n, It would be better to use `stri_split_fixed` from stringi instead of ",
  "\n  numbers <- as.character(numbers)\n  numbers <- numbers[order(nchar(numbers))]\n\
    \  numbers\n}\n", "\n  numbers <- strsplit(numbers, \" \")[[1]]\n  numbers <-\
    \ sort(numbers)\n  paste(numbers, collapse = \" \")\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI used `paste0` to avoid the trailing space which `paste` would add.\n\
    <|/ c |>\n<| a tags=r dscore=3 |>\nHere's a solution in base R:\n<code>\nnumbers\
    \ <- c(\"three two five\", \"four\")\n\nnumbers <- strsplit(numbers, \"\\\\s+\"\
    )\n\nnumbers[1] <- lapply(numbers[1], sort)\n\npaste(numbers[[1]], collapse=\"\
    \ \")", "\n    numbers_sorted <- sort(numbers)\n    numbers_sorted\n}\n", "\n\
    \  \n  if(!is.character(numbers)) {\n    stop('This function only works for character\
    \ vectors')\n  }\n  if(!all(numbers %in% c('zero', 'one', 'two', 'three', 'four',\
    \ 'five', 'six', 'seven', 'eight', 'nine'))) {\n    stop('All numbers must be\
    \ in the set {zero, one, two, three, four, five, six, seven, eight, nine}')\n\
    \  }\n  \n  numbers <- gsub('\\\\s', '', numbers)\n  numbers <- gsub('zero', '0',\
    \ numbers)\n  numbers <- gsub('one', '1', numbers)\n  numbers <- gsub('two', '2',\
    \ numbers)\n  numbers <- gsub('three', '3', numbers)\n  numbers <- gsub('four',\
    \ '4', numbers)\n  numbers <- gsub('five', '5', numbers)\n  numbers <- gsub('six',\
    \ '6', numbers)\n  numbers <- gsub('seven', '7', numbers)\n  numbers <- gsub('eight',\
    \ '8', numbers)\n  numbers <- gsub('nine', '9', numbers)\n  \n  numbers <- gsub('nine',\
    \ '9', numbers)\n  numbers <- gsub('zero', '0', numbers)\n  numbers <- gsub('one',\
    \ '1', numbers)\n  numbers <- gsub('two', '2', numbers)\n  numbers <- gsub('three',\
    \ '3', numbers)\n  numbers <- gsub('four', '4', numbers)\n  numbers <- gsub('five',\
    \ '5', numbers)\n  numbers <- gsub('six', '6', numbers)\n  numbers <- gsub('seven',\
    \ '7', numbers)\n  numbers <- gsub('eight', '8', numbers)\n  numbers <- gsub('nine',\
    \ '9', numbers)\n  \n  numbers <- as.numeric(numbers)\n  sort(numbers)\n}\n</cell>\n\
    <cell>", "\n  numbers <- as.character(numbers)\n  words <- strsplit(numbers, \"\
    \ \")[[1]]\n  sorted.words <- words[order(as.integer(words))]\n  paste(sorted.words,\
    \ collapse = \" \")\n}\n</code>\n<|/ a tags=string,r dscore=1 |>\n<| a dscore=1\
    \ |>\nHere's a pretty simple approach that works when there are less than 10 numbers\
    \ in your vector:\n<code>\nx <- c(\"five\", \"six\", \"seven\", \"nine\")\ny <-\
    \ c(\"four\", \"two\", \"nine\", \"three\")\nz <- c(\"one\", \"two\", \"three\"\
    , \"four\")\nw <- c(\"zero\", \"one\", \"two\", \"three\")\n", "\n    numbers\
    \ <- gsub('([[:digit:]])', '\\\\1 ', numbers)\n    numbers <- gsub('(^| )([[:digit:]])',\
    \ '\\\\1\\\\2', numbers)\n    numbers <- gsub(' ', '\\\\2', numbers)\n    numbers\
    \ <- gsub('(^| )(\\\\1)', '\\\\1', numbers)\n    numbers <- gsub('( )([[:digit:]])',\
    \ '\\\\1 \\\\2', numbers)\n    numbers <- paste(sort(numbers), collapse = \" \"\
    )\n    numbers <- gsub('\\\\1 ', '\\\\2 ', numbers)\n    return(numbers)\n}\n",
  "\n  numbers_sorted <- paste0(sort(numbers))\n  numbers_sorted <- gsub(\"^\\\\s+|\\\
    \\s+$\", \"\", numbers_sorted)\n  return(numbers_sorted)\n}\n</code>\n<|/ a |>\n\
    <| a tags=string,r,regex |>\nWe can also use gsubfn for this purpose\n<code>\n\
    library(gsubfn)\ngsubfn(\"\\\\b\\\\d+\\\\b\", list, as.character(string))", "\n\
    \  numbers <- gsub(\" \", \"\", numbers)\n  numbers <- gsub(\"[^0-9]\", \"\",\
    \ numbers)\n  numbers <- sort(numbers, decreasing = TRUE)\n  numbers <- paste0(numbers,\
    \ collapse = \" \")\n}\n", "\n  numbers <- str_split(numbers, \" \")[[1]]\n  numbers\
    \ <- sort(numbers)\n  numbers <- paste(numbers, collapse = \" \")\n  return(numbers)\n\
    }\n</code>\n<|/ a tags=r,sorting,string |>\n<| c |>\nThis is a better approach.\
    \ Nice.\n<|/ c |>\n<| c |>\nHi Joshua. Thanks so much for sharing this approach!\
    \ I noticed that you added a space/delimiter between the numbers before sorting\
    \ them, which I did not include in my original question. Does that make any difference?\n\
    <|/ c |>\n<| c |>\n, if you add a space after the `sort`, that might matter. It\
    \ depends on your input. If you're dealing with input from the user (as opposed\
    \ to some predetermined input), then that might be an issue. If you're dealing\
    \ with pre-determined inputs, the space/delimiter does make a difference. With\
    \ a space after sort, you're sorting the numbers lexicographically, so a space\
    \ after it would mean that \"nineteen\" comes before \"ninety\". If you had \"\
    nine hundred twenty\" before \"nineteen\", the space after the sort would not\
    \ matter.\n<|/ c |>\n<| c |>\n, If you're dealing with user input, though, it's\
    \ probably best to just remove extra spaces as they come in if possible. Otherwise,\
    \ you might end up with some surprising results if someone put in \"twenty\" or\
    \ \"nineteen\" but didn't put a space after it.\n<|/ c |>\n<| c |>\nThanks Joshua!\
    \ This makes perfect sense. I've edited my original question to show how I implemented\
    \ your `sort_numbers` function. Thanks again!\n<|/ c |>\n<| a |>\nAs far as I\
    \ can tell this is not a very straightforward way to do this in R. Basically you\
    \ want to split each string by whitespace and then sort each sub-string in ascending\
    \ order. After that you can combine these sub-strings into one string with str_replace.\
    \ You can do this by nesting lapplys. I have added some extra lines to show how\
    \ to do this with a string with more than one number in it.\n<code>\nlibrary(dplyr)\n\
    library(stringr)\n\ndf <- data.frame(\n  stringsAsFactors = FALSE,\n  stringsAsFactors\
    \ = FALSE,\n  stringsAsFactors = FALSE,\n  stringsAsFactors = FALSE,\n  stringsAsFactors\
    \ = FALSE,\n  stringsAsFactors = FALSE,\n  stringsAsFactors = FALSE,\n  stringsAsFactors\
    \ = FALSE,\n", "\n  # Convert the list of numbers to a character vector in order\
    \ to use \n  # the stringr package for string manipulation\n  numbers <- strsplit(numbers,\
    \ \" \")[[1]]\n  # Use the stringr package's str_pad to pad the numbers up to\
    \ a length of 5\n  # and use a combination of sort and order to get the desired\
    \ ordering\n  return(numbers[order(str_pad(numbers, width = 5, pad = \"0\"), decreasing\
    \ = TRUE)])\n}\n</code>\n<code>", "\n    numbers <- gsub(\" \", \"\", numbers)\
    \ # remove spaces in string input\n    numbers <- strsplit(numbers, \"\\\\s\"\
    ) # split into individual numbers in list\n    numbers <- sapply(numbers, function(x)\
    \ x[which.min(x)])  # take smallest number in list\n    return(paste(numbers,\
    \ collapse = \" \")) # combine number strings into single string again\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThe code is not working with input string `\"four\"\
    `. You will get `Error in gsub(\" \", \"\", numbers) : argument \"pattern\" is\
    \ missing, with no default`.\n<|/ c |>\n<| c |>\nI think this answer is the best,\
    \ it's elegant and efficient. Very good, thank you.\n<|/ c |>\n<| a |>\nThis should\
    \ work too:\n<code>\nsort_numbers <- function(numbers){\n  numbers2 <- gsub(\"\
    \ \", \"\", numbers)\n  numbers2 <- strsplit(numbers2, \" \")\n  numbers2 <- sapply(numbers2,\
    \ function(x) paste0(x,collapse=\" \")) # combine number strings into single string\
    \ again\n  numbers2 <- paste0(sort(numbers2),collapse=\"\")\n  return(numbers2)\n\
    }\n</code>\n<|/ a dscore=4 tags=r,sorting |>\n<| c |>\nNice solution. One thing\
    \ I would add is that `sort` returns a list, so one could do `numbers2 <- sort(numbers2)`\
    \ instead of `numbers2<-sort(numbers2)`\n<|/ c |>\n<| c |>\nIn your `numbers2`\
    \ assignment, the `sapply` call won't work because `numbers2` is a `list` rather\
    \ than a vector.\n<|/ c |>\n<| a dscore=3 |>\nI've used this package to do my\
    \ sorting when there are multiple criteria for sorting, just pass a list of columns\
    \ to orderby, e.g.:\n<code>\norder_by(df, col1, col2, col3)\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nI like this package - very versatile. I would only recommend it\
    \ if your data set is very large - it will sort in-memory rather than sorting\
    \ on disk (although the underlying implementation is usually the same for both).\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is a solution using stringr::str_split and stringr::str_trim\n\
    <code>\nsort_numbers <- function(numbers){\n    numbers <- str_trim(str_split(numbers,\
    \ \" \")[[1]])\n    numbers <- sort(numbers)\n    return", "\n    # Convert to\
    \ a character vector\n    numbers <- as.character(numbers)\n    # Remove trailing\
    \ white spaces\n    numbers <- trimws(numbers)\n    # Split each word into a separate\
    \ element of a character vector\n    numbers <- strsplit(numbers, \" \")\n   \
    \ # Remove empty elements\n    numbers <- numbers[numbers != \"\"]\n    # Remove\
    \ white spaces again\n    numbers <- trimws(numbers)\n    # Remove numbers that\
    \ are not from 0 to nine\n    numbers <- numbers[numbers != \"zero\"]\n    # Remove\
    \ any number that is less than five\n    numbers <- numbers[numbers >= \"five\"\
    ]\n    # Convert character vector back to a numeric vector\n    numbers <- as.numeric(numbers)\n\
    \    # Sort and return\n    sort(numbers)\n}\n\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nThis is great but it doesn't work if the numbers are in one word like `\"\
    two nine\"` for example. I'm wondering if there's a way to remove the numbers\
    \ that are not in a word form like `\"two nine\"` since I'm going to be using\
    \ this on multiple variables and don't want it to break them.\n<|/ c |>\n<| c\
    \ |>\nHow does it fail? It seems to work fine, e.g. for `\"two nine\"` the vector\
    \ `c(\"two\", \"nine\")` is sorted. I've updated the answer to handle that. I'm\
    \ just unsure as to whether you want the output as a string or to have the numbers\
    \ ordered as a numeric vector.\n<|/ c |>\n<| c |>\nThe output is a character vector\
    \ but I'm going to be using this on multiple variables and don't want it to break\
    \ them.\n<|/ c |>\n<| c |>\nI've updated the answer to return character instead\
    \ of numeric vector.\n<|/ c |>\n<| a dscore=1 |>\nJust another option using gsubfn.\n\
    <code>\nlibrary(gsubfn)\n\nsort_numbers <- function(numbers) {\n  gsubfn(\n  \
    \  pattern = \"(one|two|three|four|five|six|seven|eight|nine)\",\n    replacement\
    \ = \"\\\\1\",\n    numbers,\n  )\n}\n\nsort_numbers(\"three one five\")", "\n\
    \  numbers_string <- unlist(strsplit(numbers, \" \"))\n  return(sort(numbers_string))\n\
    }\n", "\n  # Split on space\n  numbers <- strsplit(numbers, \" \")[[1]]\n  # Return\
    \ sorted list of numbers\n  numbers[order(as.numeric(numbers))]\n}\n</code>\n\
    <|/ a tags=r,sorting,function |>\n<| c |>\nThank you! This was helpful.\n<|/ c\
    \ |>\n<| a dscore=2 tags=r,sorting,function |>\nYou can use gsubfn to extract\
    \ digits and sort them numerically as follows:\n<code>\nlibrary(gsubfn)\nsort_numbers\
    \ <- function(string){\n    n <- as.numeric(unlist(strsplit(gsubfn(\"\\\\D+\"\
    , \" \", string), \" \"))) \n    n[order(n)]\n}\n\nsort_numbers(\"one three seven\
    \ four nine five six seven eight two one\")\n[1] \"one\" \"three\" \"four\" \"\
    nine\" \"five\" \"six\" \"seven\" \"eight\" \"two\"\n</code>\n<|/ a |>\n<| c |>\n\
    I think you mean \"gsubfn\" for the package.  Just in case someone else lands\
    \ on this page and needs to use it.\n<|/ c |>\n<| c |>\nI believe `gsubfn` is\
    \ in the `gsubfn` package.\n<|/ c |>\n<| c |>\n, thanks for pointing it out. I\
    \ will correct it now.\n<|/ c |>\n<| c |>\n: Thanks!  I never thought of using\
    \ `gsubfn` like that because I have never used it before.\n<|/ c |>\n<| a dscore=2\
    \ tags=r,sorting,function |>\nThe function below gives the desired output using\
    \ gsubfn. \n<code>\nsort_numbers <- function(x){\n  x <- gsub(\"(.*)(\\\\d+)(.*)\"\
    ,\"\\\\1\\\\2\",x)\n  x <- gsub(\"(\\\\d+)(.*)\",\"\\\\1\\\\2\",x)\n  y <- as.numeric(unlist(strsplit(x,\"\
    \ \")))\n  y[order(y)]\n}\n</code>\n<|/ a |>\n<| c |>\nI think you mean `gsubfn`?\n\
    <|/ c |>\n<| c |>\nI did mean `gsubfn`.\n<|/ c |>\n<| a dscore=1 tags=r,sorting,function\
    \ |>\nTry this:\n<code>\nsort_numbers <- function(x) {\n  x <- strsplit(x, \"\
    \ \")[[1]]\n  y <- as.numeric(unlist(strsplit(x,\" \")))\n  y[order(y)]\n}\n</code>\n",
  "\n  numbers <- strsplit(numbers, \" \")[[1]]\n  numbers <- numbers[order(numbers)]\n\
    \  paste(numbers, collapse = \" \")\n}\n", "\n  numbers <- gsub(\"[^0-9]\", \"\
    \", numbers)\n  numbers\n}\n", "\n  numbers <- strsplit(numbers, \" \")[[1]]\n\
    \  out <- sapply(seq_along(numbers), function(i) {\n    numbers[[i]]\n  }) %>%\n\
    \    do.call(rbind, .) %>%\n    arrange(V1, V2) %>%\n    as.character %>%\n  \
    \  paste(collapse = \" \")\n  return(out)\n}\n", "\n    numbers <- strsplit(numbers,\
    \ \" \")[[1]]\n    numbers <- numbers[order(as.numeric(numbers))]\n    paste(numbers,\
    \ collapse = \" \")\n}\n", "\n  x <- unlist(strsplit(numbers, \" \"))\n  paste(sort(as.numeric(x),\
    \ decreasing = TRUE), collapse = \" \")\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    I believe `paste(sort(as.numeric(x), decreasing = TRUE), collapse = \" \")` is\
    \ equivalent to `paste(sort(x), collapse = \" \")` since `as.numeric` is already\
    \ in ascending order.\n<|/ c |>\n<| c |>\n- I think you are right. Thanks for\
    \ the reminder!\n<|/ c |>\n<| a dscore=0 tags=string,r,sorting |>\nA solution\
    \ using regular expressions (though I haven't tested the performance on very large\
    \ vectors):\n<code>\nx <- c(\"zero four six two five one three\", \"two nine one\
    \ five three four zero\")\n\nz <- unlist(strsplit(x, \"\\\\s+\"))\nz[order(-z)]\n\
    \n[1] \"one five three four zero two nine six\"\n[2] \"two nine six four five\
    \ one three zero\"\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThe \"sort numbers function\"\
    \ below is adapted from one of the answers previously given, with one small modification\
    \ to ensure valid inputs are handled:\n<code>\nsort_numbers <- function(numbers)\
    \ {\n  numbers <- as.numeric(unlist(strsplit(numbers, \" \")))\n  if(!all(numbers\
    \ >= 0 & numbers <= 9)) {\n    print(\"invalid input\")\n    return()\n  }\n \
    \ paste(sort(numbers, decreasing = TRUE), collapse = \" \")\n}\n</code>\nNote\
    \ that this solution does a couple of additional things that could have unintended\
    \ consequences:\n\nIt will throw a warning if numbers is an empty string. If that\
    \ is a valid input, this is ok, but it is important to keep this in mind.\nIt\
    \ will also return if numbers is invalid. Is that valid input? If so, this could\
    \ cause further problems. In particular, if numbers is invalid, as.numeric(unlist(strsplit(numbers,\
    \ \" \"))) will return NA, which means sort() will sort it into ascending order.\n\
    \nThis means this function will also return if numbers is invalid. If that is\
    \ valid input, this could be problematic, since if numbers is invalid, sort()\
    \ will sort it into ascending order. But if numbers is invalid, sort_numbers()\
    \ will also return an invalid input. But if we use ifelse() with is.na() in place\
    \ of if(), we avoid the warning and error that sort_numbers() is returning if\
    \ numbers is invalid:\n<code>\nsort_numbers <- function(number", "\n  x <- unlist(strsplit(numbers,\
    \ \" \"))\n  x <- sort(x)\n  paste0(x, collapse=\" \")\n}\n</code>\n<|/ a dscore=3\
    \ tags=r,regex |>\n<| a |>\nIf you just want a sorting algorithm, there are multiple\
    \ ways to achieve that :\n<code>\nnumbers_split <- unlist(strsplit(numbers, \"\
    \ \"))\nnumbers_sort <- sort(numbers_split)\nnumbers_sort2 <- paste(numbers_split,\
    \ collapse=\" \")\nnumbers_sort3 <- paste0(numbers_split, collapse=\" \")\n\n\
    numbers_split <- str_split(numbers, \" \", simplify = TRUE)\nnumbers_sort <- sort(unlist(numbers_split))\n\
    numbers_sort2 <- paste(unlist(numbers_split), collapse = \" \")\nnumbers_sort3\
    \ <- paste0(unlist(numbers_split), collapse = \" \")\n</code>\nWhich gives\n<code>\n\
    numbers_split <- unlist(strsplit(numbers, \" \"))\nnumbers_sort <- sort(numbers_split)\n\
    numbers_sort2 <- paste(numbers_split, collapse=\" \")\nnumbers_sort3 <- paste0(numbers_split,\
    \ collapse=\" \")\n\nnumbers_split <- str_split(numbers, \" \", simplify = TRUE)\n\
    numbers_sort <- sort(unlist(numbers_split))\nnumbers_sort2 <- paste(unlist(numbers_split),\
    \ collapse = \" \")\nnumbers_sort3 <- paste0(unlist(numbers_split), collapse =\
    \ \" \")\n\nnumbers_split <- str_split(numbers, \" \", simplify = TRUE)\nnumbers_sort\
    \ <- sort(unlist(numbers_split))\nnumbers_sort2 <- paste(unlist(numbers_split),\
    \ collapse = \" \")\nnumbers_sort3 <- paste0(unlist(numbers_split), collapse =\
    \ \" \")\n</code>\n<|/ a dscore=3 tags=r,regex |>\n<| c |>\nThe `str_split` approach\
    \ is quite clever, and is very readable for those not very familiar with regex.\n\
    <|/ c |>\n<| a dscore=3 tags=r,regex |>\nThe answers given so far are nice and\
    \ succinct, but I thought I'd add another way by which we can do it without splitting\
    \ the string at all.\nWe could also use str_extract_all to extract all the digits\
    \ and then sort them in place. \n<code>\nnumbers_split <- str_extract_all(numbers,\
    \ pattern = \"\\\\d+\")\nnumbers_sort <- sort(unlist(numbers_split), decreasing\
    \ = T)\n</code>\n<|/ a |>\n<| a dscore=3 |>\nThe ", "\n  num_list <- strsplit(numbers,\
    \ ' ')[[1]]\n  num_list <- sort(num_list)\n  paste0(num_list, collapse = ' ')\n\
    }\n\nsort_numbers('nine two one five')\n</code>\n<|/ a tags=regex,r,stringr |>\n\
    <| c |>\nHi Kevin, thanks for the help. Your code worked great for single words\
    \ and numbers separated by a space. I am not able to use this to sort numbers\
    \ in multiple columns in a dataframe though. Any ideas on that? The dataframe\
    \ contains multiple columns each containing one number or multiple numbers. I\
    \ am new to R and have been struggling with this for some time.\n<|/ c |>\n<|\
    \ c |>\nHi - I updated my answer so that it now supports multiple numbers per\
    \ row and now sorts them as per your specification.\n<|/ c |>\n<| c |>\nHey, thanks\
    \ for the quick response. The code does work, but only on one column. When I try\
    \ to run it for multiple columns with multiple numbers, the sorting gets messed\
    \ up. For example, the code works well for one column containing numbers such\
    \ as \"10 1 9 8 7 6\" but not \"10 4 3 2 8 1\". I tried to create a sample dataframe\
    \ but could not get it to work. Any suggestions would be greatly appreciated.\
    \ Thanks again!\n<|/ c |>\n<| c |>\nHey, I updated my answer - I added a new function\
    \ called `sort_numbers` which now sorts numbers across multiple columns in a data.frame.\n\
    <|/ c |>\n<| a tags=regex,r,stringr |>\nFor this sort of thing, I've found it\
    \ very helpful to read in the data as a string.  Then you can use strsplit to\
    \ break it up into separate vectors.  The following will do the job.\n<code>\n\
    library(dplyr)\n\ndata <- data.frame(\n  stringsAsFactors = FALSE,\n         \
    \     V1= c(\"1 3 2 4 5 6 7 8\",\"10 2 1 3 4 5 6 7\",\"9 8 1 2 3 4 5 6\"),\n \
    \ V2= c(\"3 4 2 5 1 6 7 8\",\"7 1 2 3 4 5 6 8\",\"8 9 1 2 3 4 5 6\"))\n\ndata$V3\
    \ <- sapply(data$V1, function(x) sapply(strsplit(x, \" \"), as.numeric))\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks David! This worked very well for me. I just\
    \ had to change the last line to data$V3 <- sapply(data$V2, function(x) sapply(strsplit(x,\
    \ \" \"), as.numeric))\n", "\n  numbers <- as.numeric(unlist(strsplit(numbers,\
    \ ' ')))\n  sort(numbers)\n  return(paste(numbers, collapse = ' '))\n}\n</code>\n\
    <|/ a tags=sorting,r,string,string-matching dscore=2 |>\n<| c |>\n+1 Nice solution,\
    \ but this seems to return a character vector rather than a string.\n<|/ c |>\n\
    <| c |>\nThanks for noticing that. I fixed it by converting the result to string\
    \ in the last line.\n<|/ c |>\n<| a dscore=1 tags=sorting,r,string,string-matching\
    \ |>\nHere's another way using gsubfn that doesn't use regular expressions alone:\n\
    <code>\nlibrary(gsubfn)\nx = 'one three five'\ngsubfn('[0-9]+', as.numeric, x)",
  "\n  numbers <- as.character(numbers)\n  numbers <- sapply(strsplit(numbers, \"\
    \ \"), as.numeric)\n  numbers <- sort(numbers)\n  paste(numbers, collapse=' ')\n\
    }\n", "\n  if(is.character(numbers)) numbers <- strsplit(numbers, \" \")[[1]]\n\
    \  numbers <- gsub(\" \", \"0\", numbers)\n  numbers <- numbers[order(as.numeric(numbers),\
    \ decreasing = TRUE)]\n  return(paste0(numbers, collapse = \" \"))\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=regex,r,sorting |>\nThis isn't the prettiest solution,\
    \ but I think it gets the job done.\n<code>\nsort_numbers <- function(string){\n\
    \  #split string into numeric elements and sort them\n  numerics <- as.numeric(unlist(strsplit(string,\
    \ split = \" \"))[order(as.numeric(unlist(strsplit(string, split = \" \")), decreasing\
    \ = T)])\n\n  #recombine the elements back into one string and return\n  paste0(numerics,\
    \ collapse = \" \")\n}\n\nsort_numbers(\"three one five\")", "\n  numbers <- unlist(strsplit(numbers,\
    \ \" \"))\n  sapply(numbers, sort)\n}\n</code>\n<|/ a dscore=4 tags=sorting,string,r\
    \ |>\n<| a dscore=3 |>\nYou can use this:\n<code>\nsort(gsub(\"[[:space:]]\",\
    \ \"\", strsplit(string, \"\\\\s+\")[[1]]))\n</code>\n<|/ a tags=sorting,string,r\
    \ |>\n<| a tags=sorting,string,r dscore=2 |>\nHere's a solution that uses a few\
    \ other solutions and uses sapply.\n<code>\nsort.numbers <- function(string){\n\
    \  numbers <- unlist(strsplit(string, \" \"))\n  sapply(numbers, sort)\n}\n</code>\n\
    <|/ a |>\n<| a dscore=2 |>\nAnother way using sapply and lapply. \n<code>\nsort_numbers\
    \ <- function(string) {\n    words <- unlist(strsplit(string, \" \"))\n    lapply(words,\
    \ sort)\n}\n", "\n  # We make a list of character vectors.\n  numbers <- strsplit(numbers,\
    \ \" \")\n\n  # Get rid of empty strings\n  numbers <- numbers[sapply(numbers,\
    \ length)>0]\n\n  # Get rid of zero's\n  numbers <- numbers[numbers != 'zero']\n\
    \n  # Sort them\n  numbers <- numbers[order(as.numeric(numbers))]\n\n  # Join\
    \ the numbers together\n  paste(numbers, collapse=\" \")\n}\n", "\n  number <-\
    \ strsplit(numbers, \" \")[[1]]\n  number <- unlist(sapply(number, function(x)\
    \ gsub(\"[^0-9]\", \"\", x)))\n  number <- sort(number)\n  number <- paste0(number,\
    \ \"\\n\")\n  return(number)\n}\n", "\n    require(splitstackshape)\n    numbers2\
    \ <- strsplit(numbers, ' ')\n    numbers2 <- lapply(numbers2, function(x) {\n\
    \        y <- as.numeric(x)\n        if (is.na(y))\n            return(x)\n  \
    \      y\n    })\n    sort_na.number(numbers2)\n}\n", "\n  numbers <- strsplit(numbers,\
    \ \" \")\n  numbers[sapply(numbers, function(x) {\n    x <- tolower(x)\n    if\
    \ (grepl(\"zero\", x)) {\n      \"0\"\n    } else if (grepl(\"one\", x)) {\n \
    \     \"1\"\n    } else if (grepl(\"two\", x)) {\n      \"2\"\n    } else if (grepl(\"\
    three\", x)) {\n      \"3\"\n    } else if (grepl(\"four\", x)) {\n      \"4\"\
    \n    } else if (grepl(\"five\", x)) {\n      \"5\"\n    } else if (grepl(\"six\"\
    , x)) {\n      \"6\"\n    } else if (grepl(\"seven\", x)) {\n      \"7\"\n   \
    \ } else if (grepl(\"eight\", x)) {\n      \"8\"\n    } else if (grepl(\"nine\"\
    , x)) {\n      \"9\"\n    }\n  })][order(sapply(numbers, function(x) {\n    x\
    \ <- tolower(x)\n    if (grepl(\"zero\", x)) {\n      \"0\"\n    } else if (grepl(\"\
    one\", x)) {\n      \"1\"\n    } else if (grepl(\"two\", x)) {\n      \"2\"\n\
    \    } else if (grepl(\"three\", x)) {\n      \"3\"\n    } else if (grepl(\"four\"\
    , x)) {\n      \"4\"\n    } else if (grepl(\"five\", x)) {\n      \"5\"\n    }\
    \ else if (grepl(\"six\", x)) {\n      \"6\"\n    } else if (grepl(\"seven\",\
    \ x)) {\n      \"7\"\n    } else if (grepl(\"eight\", x)) {\n      \"8\"\n   \
    \ } else if (grepl(\"nine\", x)) {\n      \"9\"\n    }\n  }))]\n}\n", "\n  numbers\
    \ <- strsplit(numbers, \" \")\n  numbers <- lapply(numbers, function(x) {\n  \
    \  x <- as.integer(x)\n    if(x %in% c(0:9)) {\n      return(x)\n    } else {\n\
    \      return(NA)\n    }\n  })\n  numbers <- as.integer(unlist(numbers))\n  numbers\
    \ <- sort(numbers)\n  numbers <- paste(numbers, collapse = \" \")\n  return(numbers)\n\
    }\n", "\n  # Split the numbers, convert each to numeric type, and sort them\n\
    \  numbers <- strsplit(numbers, ' ')[[1]]\n  numbers <- lapply(numbers, as.numeric)\n\
    \  numbers[order(numbers)]\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    <code>", "\n  return(numbers)\n}\n</code>\n<|/ q tags=r,string |>\n<| c |>\nWhat\
    \ have you tried? What problems did you encounter?\n<|/ c |>\n<| c |>\nI wanted\
    \ to use str_split to split at spaces and then use an ifelse to return numbers\
    \ sorted in order but have not gotten very far. I am new to R so I am struggling\
    \ to find documentation on the functions.\n<|/ c |>\n<| c |>\nYou should post\
    \ the code you've tried and explain how it isn't working.  That way people can\
    \ help you understand where you are going wrong.\n<|/ c |>\n<| c |>\nI have added\
    \ the code I have used so far\n<|/ c |>\n<| c |>\nHmm... `sort_numbers(x)` returns\
    \ an error.  Please post the code you actually ran.\n<|/ c |>\n<| a |>\nThis approach\
    \ uses two steps: \n\nsplit the strings on spaces and store them in a list\nsort\
    \ the list numerically\n\n<code>\nsort_numbers <- function(string){\n  lst <-\
    \ strsplit(string = string, split = \"\\\\s+\")\n  lst[order(sapply(lst, as.numeric),\
    \ decreasing = TRUE)]\n}\n\nsort_numbers(\"one two three four five six seven eight\
    \ nine\")", "\n  numbers <- gsub(\"[^0-9]\", \"\", numbers)\n  numbers <- gsub(\"\
    ^\\\\s+|\\\\s+$\", \"\", numbers)\n  numbers <- gsub(\"\\\\s+\", \" \", numbers)\n\
    \  numbers <- gsub(\"(^|[a-z])(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\"\
    , \"\\\\2\\\\1\", numbers)\n  numbers <- gsub(\"(^|[a-z])(ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen)\"\
    , \"\\\\1\\\\1\", numbers)\n  numbers <- gsub(\"^[a-z]\", \"\", numbers)\n  numbers\
    \ <- gsub(\"[a-z]$\", \"\", numbers)\n  numbers <- gsub(\" +\", \" \", numbers)\n\
    \  numbers <- gsub(\" +\", \"\\\\s\", numbers)\n  numbers <- sort(as.integer(numbers))\n\
    \  numbers <- paste0(\"\\\\s\", numbers, \"\\\\s\")\n  return(numbers)\n}\n",
  "\n  ns <- strsplit(numbers, ' ')[[1]]\n  ns[ns %in% c('zero', 'one', 'two', 'three',\
    \ 'four', 'five', 'six', 'seven', 'eight', 'nine')]\n}\n", "\n  numbers <- stringr::str_split(numbers,\
    \ \" \")[[1]]\n  numbers <- numbers[order(numbers)]\n  paste(numbers, collapse\
    \ = \" \")\n}\n</code>\n<|/ a dscore=3 tags=r,sorting,string |>\n<| a tags=r,sorting,string\
    \ dscore=3 |>\nI think this is one way, using factors.\n<code>\n> x <- c(\"five\"\
    ,\"three\",\"one\",\"two\",\"seven\",\"four\",\"six\")\n> f <- factor(x, levels=c(\"\
    zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\"\
    ,\"nine\"))\n> f\n[1] five   three one   two seven four  six <NA>  \nLevels: zero\
    \ one two three four five six seven eight nine\n> sort(f)\n[1] seven one three\
    \ four five six <NA>\nLevels: zero one two three four five six seven eight nine\n\
    </code>\n<|/ a |>\n<| c |>\nThis is nice, but I like the original answer better\
    \ for its simplicity.\n<|/ c |>\n<| c |>\nThe answer by Jim Hesters is the correct\
    \ one for me.  I added a couple comments to help explain what he did.\n<|/ c |>\n\
    <| a tags=r,sorting,string |>\nAn interesting way of doing this in base R:\n<code>\n\
    x <- c(\"five\",\"three\",\"one\",\"two\",\"seven\",\"four\",\"six\")\nx", "\n\
    \  numbers <- strsplit(numbers, ' ')[[1]]\n  numbers[order(numbers)]\n}\n", "\n\
    \  numbers <- strsplit(numbers, \" \")[[1]]\n  numbers <- sort(numbers)\n  numbers\
    \ <- paste(numbers, collapse = \" \")\n  numbers\n}\n</code>\nOutput\n<code>\n\
    sort_numbers(\"one three four\")", "\n  # Convert to vector of numbers and make\
    \ sure it has a length of at least 3\n  numbers <- unlist(strsplit(numbers, \"\
    \ \"))\n  numbers <- na.omit(numbers)\n\n  # If there are less than three elements,\
    \ just return them\n  if(length(numbers) < 3) {\n    return(numbers)\n  }\n\n\
    \  # Sort the numbers and put them back together\n  numbers <- sort(numbers)\n\
    \  return(paste(numbers, collapse = \" \"))\n}\n", "\n  numbers <- as.numeric(unlist(strsplit(numbers,\
    \ \" \")))\n  sort(numbers)\n}\n</code>\n<|/ a tags=sorting,r |>\n<| c |>\nThank\
    \ you. Your solution works. I chose the first one because I thought it would be\
    \ more straightforward to implement it in `dplyr`.\n<|/ c |>\n<| c |>\nJust a\
    \ note about why this is the case: this answer was given prior to `dplyr`. I think\
    \ it was a much more straightforward question to ask, even without `dplyr` being\
    \ in the picture at all. `dplyr` answers work because `dplyr` relies on `stats::order`\
    \ and `stats::order` sorts numeric vectors lexicographically. `base` R does not.\n\
    <|/ c |>\n<| a tags=sorting,r |>\nUsing a reproducible example from the previous\
    \ answer from. \n<code>\nsort_numbers <- function(numbers) {\n  numbers <- as.numeric(unlist(strsplit(numbers,\
    \ \" \")))\n  sort(numbers)\n}\n</code>\nI got this error when trying to sort\
    \ a vector of numbers: \n\nError in order(V2) : argument 1 is not a vector\n\n\
    So I used sort(numbers,decreasing = TRUE) which fixed the issue.\n<|/ a dscore=2\
    \ |>\n<| a tags=sorting,r |>\nUsing dplyr:\n<code>\nlibrary(dplyr)\ndf <- data.frame(x\
    \ = c(1, 2, 3, 4, 5, 6, 7))\ndf %>% arrange(x)\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a tags=sorting,r |>\nI think it is worth mentioning that the question of sorting\
    \ numbers has already been asked before. \nHere is one option:\n<code>\nsort_numbers\
    \ <- function(numbers) {\n  numbers <- as.numeric(unlist(strsplit(numbers, \"\
    \ \")))\n  numbers[order(numbers)]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank\
    \ you! I looked at other solutions but the idea of putting it in a function and\
    \ using `strsplit` threw me. This works well though.\n<|/ c |>\n<| c |>\nNice\
    \ answer, although I didn't know about `strsplit` until I saw the other answers.\
    \ I'll leave my answer intact for those who do know `strsplit`.\n<|/ c |>\n<|\
    \ a |>\nYou can use order() function in base R:\n<code>\ndf <- data.frame(x =\
    \ c(1, 2, 3, 4, 5, 6, 7))\n", "\n  numbers <- strsplit(numbers, \" \")[[1]]\n\
    \  sorted <- numbers[order(numbers)]\n  paste0(sorted[1], ' ', sorted[2], ' ',\
    \ sorted[3])\n}\n</code>\n<|/ a |>\n<| c |>\nThis was extremely helpful and I\
    \ learned a lot from it.  I made a few changes to the code as I went along, but\
    \ I appreciate your help.  It works great!\n<|/ c |>\n<| a |>\nThe solution to\
    \ the general question would be:\n<code>\nsort_numbers <- function(numbers) {\n\
    \  numbers <- strsplit(numbers, \" \")[[1]]\n  sorted <- numbers[order(numbers)]\n\
    \  paste0(sorted[1], ' ', sorted[2], ' ', sorted[3])\n}\n</code>\nHowever, I assume\
    \ that your problem is a bit more specific, and that you are asking for help with\
    \ that specific problem. Here is the code for that specific problem:\n<code>\n\
    sort_numbers <- function(numbers) {\n  numbers <- strsplit(numbers, \" \")[[1]]\n\
    \  sorted <- numbers[order(numbers)]\n  paste0(sorted[1], ' ', sorted[2], ' ',\
    \ sorted[3])\n}\n\nsort_numbers('three one five')", "\n  \n  numbers_list <- strsplit(numbers,\
    \ \" \")[[1]]\n  \n  numbers_sorted <- sort(numbers_list)\n  \n  return(paste(numbers_sorted,\
    \ collapse = \" \"))\n}\n", "\n  nums <- strsplit(numbers, \" \")[[1]]\n  nums[order(as.numeric(nums))]\n\
    }\n", "\n  numbers <- gsub(\"[^0-9]\", \"\", numbers)\n  numbers <- gsub(\"^\\\
    \\s+|\\\\s+$\", \"\", numbers)\n  sort(numbers)\n}\n", "\n  # Your code here\n\
    \  numbers <- unlist(strsplit(numbers, split = \" \"))\n  sort(numbers)\n}\n",
  "\n  # Split the space-delimited string of numbers into numbers\n  numbers <- strsplit(numbers,\
    \ ' ')[[1]]\n  # Sort the numbers\n  numbers <- sort(numbers)\n  # Return the\
    \ sorted string\n  paste(numbers, collapse=' ')\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a |>\nI thought I'd give an answer that uses string manipulation in an\
    \ environment that may be a bit more flexible.  I think it's simpler than the\
    \ other answers and it works well if the string is formatted as in one of the\
    \ other answers, since you can split the string based on spaces, sort, and join\
    \ it together with paste.\n<code>\nsort_numbers <- function(numbers) {\n  splits\
    \ <- strsplit(numbers, \" \")\n  numbers <- unname(sapply(splits, sort))\n  paste0(numbers,\
    \ collapse = \" \")\n}\n</code>\nThis works in both of the scenarios shown by\
    \ the OP with the sample numbers:\n<code>\nsort_numbers(\"one six three two seven\"\
    )", "\n  numbers <- gsub(\"[^0-9]\", \"\", numbers)\n  gsub(\"(^|[\\\\s])(\\\\\
    d)([\\\\s])\", \"\\\\3 \\\\2\\\\1\", numbers) \n}\n", "\n    numbers <- unlist(strsplit(numbers,\
    \ \" \"))\n    numbers <- sort(numbers)\n    paste(numbers, collapse = \" \")\n\
    }\n\n</cell>\n<cell>\n%%R\n", "\n  sorted_numbers = numbers[1]\n  numbers = numbers[2]\n\
    \  for (i in 1:length(numbers)) {\n    if (numbers[i] < sorted_numbers[-1]) {\n\
    \      sorted_numbers = c(sorted_numbers, numbers[i])\n    }\n  }\n  return(paste(sorted_numbers,\
    \ collapse = ' '))\n}\n</cell>\n<cell>", "\n    numbers <- strsplit(numbers, \"\
    \ \")[[1]]\n    numbers <- unique(numbers)\n    numbers <- numbers[order(numbers,\
    \ decreasing = T)]\n    paste(numbers, collapse = \" \")\n}\n</code>\n<|/ a tags=r,regex\
    \ |>\n<| c |>\nNice solution and concise. However, the `gregexpr` method is much\
    \ slower than the others in my test. See the answer below for timings.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nI wrote a function, which I then found here: How to sort\
    \ a vector of numbers in R by smallest to largest\n<code>\nsort.num <- function(x)\
    \ {\n  y <- as.numeric(as.character(x))\n  y <- y[1:(length(y) - 1)] # remove\
    \ last element\n  y[order(y)]\n}\n</code>\n<|/ a tags=r,regex |>\n<| a tags=r,regex\
    \ |>\nI think using gsub is a bit too much. Here's an idea using strsplit:\n<code>\n\
    x <- c('one two three four five six seven eight nine',\n       'one two three\
    \ four five six seven eight',\n       'one two three four five six seven eight\
    \ nine',\n       'one two three four five six seven eight nine',\n       'one\
    \ two three four five six seven eight nine',\n       'one two three four five\
    \ six seven eight nine',\n       'one two three four five six seven eight nine')\n\
    \nsapply(strsplit(x, \" \"), function(y) {\n  # remove duplicated word\n  y <-\
    \ unique(unlist(strsplit(y, \" \")))\n  # sort numbers\n  y <- y[order(y, decreasing\
    \ = T)]\n  # return sorted vector\n  return(paste(y, collapse = \" \"))\n})\n",
  "\n  numbers <- gsub('[^0-9]', ' ', numbers)\n  numbers <- unlist(strsplit(numbers,\
    \ '\\\\s+'))\n  numbers <- sort(numbers)\n  numbers <- paste0(numbers, collapse='\
    \ ')\n  return(numbers)\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nThis isn't a\
    \ solution for your exact problem (as requested in the comments), but perhaps\
    \ it might be of some use:\n<code>", "\n    numbers <- strsplit(numbers, \" \"\
    )[[1]]\n    numbers <- sort(numbers)\n    numbers <- paste(numbers, collapse =\
    \ \" \")\n    return(numbers)\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=string,r,string\
    \ |>\nUsing gsubfn package you can do that using below code\n<code>\nlibrary(gsubfn)\n\
    \ngsubfn(\"[[:alpha:]]+\", ~ sort(as.character(.)), x)", "\n  numbers_vector <-\
    \ str_split(numbers, \" \")[[1]]\n  numbers_vector <- sort(numbers_vector)\n \
    \ numbers_vector <- paste(numbers_vector, collapse=\" \")\n}\n</code>\n<|/ a dscore=0\
    \ tags=r |>\n<| a dscore=0 |>\nUsing a regex you can get the number and then sort\
    \ them easily. This is an example with the string \"one two three four five six\
    \ seven eight nine\" \n<code>\nlibrary(stringr)\nstr_extract(str_split(str_subset(x,\
    \ 1, 3),\"\\\\s+\"), \"\\\\d+\")\n[1] \"2\" \"6\" \"3\" \"8\"\nsort(str_extract(str_split(str_subset(x,\
    \ 1, 3),\"\\\\s+\"), \"\\\\d+\"))\n[1] \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"\
    2\"\n</code>\n<|/ a tags=r |>\n<| c |>\nThis works perfectly! Just out of curiosity,\
    \ how would you do this if your string was `\"one two three four five six seven\
    \ eight nine\"`?\n<|/ c |>\n<| c |>\nYou can get the number of digits by doing\
    \ str_count and then str_splitting on \" \" and then taking the first value. Or\
    \ for two digits, str_count will give 2, str_splitting will give two elements\
    \ and then you can take the first value directly. For more than two digits, str_count\
    \ will give you a number, str_splitting will give you a vector which can be directly\
    \ taken for the first value.\n<|/ c |>\n<| c |>\nJust to make sure I understand,\
    \ if the string was `\"one two three four five six seven eight nine\"`, then the\
    \ second line of your answer would result in `\"8\" \"2\" \"6\" \"3\" \"4\" \"\
    5\" \"7\" \"eight\" \"six\" \"seven\" \"one\"`?\n<|/ c |>\n<| c |>\nExactly. The\
    \ first line returns the numbers in sorted order. And the second line is getting\
    \ the 1st value in sorted order which is 8\n<|/ c |>\n<| c |>\nI see. I will definitely\
    \ use this approach in the future. Thank you!\n<|/ c |>\n<| a |>\n<code>", "\n\
    \  # Your code here\n}\n", "\n  ns <- strsplit(numbers, \" \")[[1]]\n  ns <- sort(ns,\
    \ decreasing = T)\n  paste(paste(ns, collapse = \" \"), collapse = \" \")\n}\n\
    </code>\n<code>\nsort_numbers(\"one five\")", "\n  stopifnot(is.character(numbers))\n\
    \  \n  # Split input on whitespace\n  numbers <- strsplit(numbers, \" \")[[1]]\n\
    \  \n  # Convert to numbers and sort\n  numbers <- sort(as.numeric(unlist(numbers)))\n\
    \  \n  # Convert back to a string\n  paste(numbers, collapse = \" \")\n}\n", "\n\
    \  numbers <- gsub(\"[^0-9]\", \"\", numbers)\n  numbers <- sort(as.numeric(numbers))\n\
    \  numbers <- paste(numbers, collapse = \" \")\n  numbers <- gsub(\"^ \", \"\"\
    , numbers)\n  numbers <- gsub(\"$\", \"\", numbers)\n  numbers\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis answer was the only one that worked with numbers\
    \ of any size. Thanks\n<|/ c |>\n<| c |>\nGreat solution!  And it really was the\
    \ only one that worked for me too.  Thanks!\n<|/ c |>\n<| a tags=sorting,r,string,numbers\
    \ |>\nFor those of us who prefer the tidyverse approach:\n<code>\nlibrary(tidyverse)\n",
  "\n  # Your code here\n}\n</code>\nNow that you've solved this problem, I wonder\
    \ if you would do well to learn more about base R.\n<|/ a dscore=0 |>\n<| c |>\n\
    Thank you!! This helped. Yes, I have looked through R, but I'm new and haven't\
    \ really got my head around all the functions yet. I'll definitely do more research\
    \ on it before I tackle the question again. Again, thank you for your help.\n\
    <|/ c |>\n<| a tags=r,sorting |>\nA simple base R solution:\n<code>\nsort_numbers\
    \ <- function(numbers) {\n    stopifnot(is.character(numbers))\n    stopifnot(length(numbers)\
    \ == 9)\n    stopifnot(numbers[1:3] == c(\"zero\", \"one\", \"two\"))\n    stopifnot(numbers[5:7]\
    \ == c(\"five\", \"six\", \"seven\"))\n    stopifnot(numbers[8] == c(\"eight\"\
    , \"nine\"))\n    numbers <- as.numeric(numbers)\n    sort(numbers)\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI didn't know that you could set stopifnots for specific\
    \ items in vectors. That seems interesting. Thank you!!\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nYou could also use match():\n<code>\nsort_numbers <- function(numbers) {\n\
    \    numbers <- as.numeric(numbers)\n    numbers[match(paste(sort(c(\"zero\",\
    \ \"one\", \"two\")),\n                       sort(c(\"five\", \"six\", \"seven\"\
    )),\n                       sort(c(\"eight\", \"nine\"))), numbers)]\n}\n\nsort_numbers(\"\
    three one five\")"]
stop_tokens:
- "\n#"
- "\n```"
