name: HumanEval_97_multiply
language: r
prompt: "# Complete the function that takes two integers and returns \n# the product\
  \ of their unit digits.\n# Assume the input is always valid.\n# Examples:\n# >>>\
  \ multiply(148, 412)\n# 16\n# >>> multiply(19, 28)\n# 72\n# >>> multiply(2020, 1851)\n\
  # 0\n# >>> multiply(14, -15)\n# 20\nmultiply <- function(a, b) {"
tests: "test_humaneval <- function() {\ncandidate <- multiply\n    if(!identical(candidate(148,\
  \ 412), 16)){quit('no', 1)}\n    if(!identical(candidate(19, 28), 72)){quit('no',\
  \ 1)}\n    if(!identical(candidate(2020, 1851), 0)){quit('no', 1)}\n    if(!identical(candidate(14,\
  \ -15), 20)){quit('no', 1)}\n    if(!identical(candidate(76, 67), 42)){quit('no',\
  \ 1)}\n    if(!identical(candidate(17, 27), 49)){quit('no', 1)}\n    if(!identical(candidate(0,\
  \ 1), 0)){quit('no', 1)}\n    if(!identical(candidate(0, 0), 0)){quit('no', 1)}\n\
  }\ntest_humaneval()"
completions: ["\n  \n    # Write your code here\n    a <- a %%10\n    b <- b %%10\n\
    \    result <- 0\n    \n    if (a < 0){\n      result <- result + abs(a)*b\n \
    \     result <- result + abs(a)*10\n      a <- 10 - a\n    }\n    \n    if (b\
    \ < 0){\n      result <- result + abs(b)*10\n      b <- 10 - b\n    }\n    \n\
    \    if (a < 0){\n      result <- result + abs(a)*b\n      a <- 10 - a\n    }\n\
    \    \n    if (b < 0){\n      result <- result + abs(b)*10\n      b <- 10 - b\n\
    \    }\n    \n    if (a < 0){\n      result <- result + abs(a)*b\n      a <- 10\
    \ - a\n    }\n    \n    if (b < 0){\n      result <- result + abs(b)*10\n    \
    \  b <- 10 - b\n    }\n    \n    if (a < 0){\n      result <- result + abs(a)*b\n\
    \      a <- 10 - a\n    }\n    \n    if (b < 0){\n      result <- result + abs(b)*10\n\
    \      b <- 10 - b\n    }\n    \n    if (a < 0){\n      result <- result + abs(a)*b\n\
    \      a <- 10 - a\n    }\n    \n    if (b < 0){\n      result <- result + abs(b)*10\n\
    \      b <- 10 - b\n    }\n    \n    if (a < 0){\n      result <- result + abs(a)*b\n\
    \      a <- 10 - a\n    }\n    \n    if (b < 0){\n      result <- result + abs(b)*10\n\
    \      b <- 10 - b\n    }\n    \n    if (a < 0){\n      result <- result + abs(a)*b\n\
    \      a <- 10 - a\n    }\n    \n    if (b < 0){\n      result <- result + abs(b)*10\n\
    \      b <- 10 - b\n    }\n    \n    if (a < 0){\n      result <- result + abs(a)*b\n\
    \      a <- 10 - a\n    }\n    \n    if (b < 0){\n      result <- result + abs(b)*10\n\
    \      b <- 10 - b\n    }\n    \n    if (a < 0){\n      result <- result + abs(a)*b\n\
    \      a <- 10 - a\n    }\n    \n    if (b < 0){\n      result <- result + abs(b)*10\n\
    \      b <- 10 - b\n    }", "\n    a <- as.integer(a)\n    b <- as.integer(b)\n\
    \    if (a==0) {\n        return(0)\n    }\n    c <- 0\n    for (i in a:b) {\n\
    \        c <- c * i\n    }\n    return(c)\n}\n", "\n  if (a == 0) {\n    return(b)\n\
    \  } else\n  {\n    return(multiply(floor(a/10), b*10)) \n  }\n}\n", "\n    if\
    \ (a == 0) stop(\"Invalid input\")\n    x <- trunc((a %% 10) * b)\n    y <- trunc((a\
    \ %/% 10) * b)\n    x <- ifelse(x < 10, x, x + 10)\n    y <- ifelse(y < 10, y,\
    \ y + 10)\n    (x * y) / b\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is a\
    \ great start. I'd be interested in seeing the `p` function in action. Also, the\
    \ comment about `multiply` not being very good is debatable :)\n<|/ c |>\n<| c\
    \ |>\nI added the p function and made some research on the algorithm I used. This\
    \ algorithm is called \"Karatsuba multiplication\" btw. Thanks for the feedback\
    \ I really appreciate it!\n<|/ c |>\n<| c |>\nThanks man! Do you have a reference\
    \ for that algorithm? I couldn't find it on Wikipedia or anything like that. Very\
    \ interesting.\n<|/ c |>\n<| c |>\nThis algorithm is a variant of the Karatsuba\
    \ multiplication. I recommend you to read about it here: https://www.geeksforgeeks.org/karatsuba-multiplication-algorithm/\n\
    <|/ c |>\n<| a |>\nI've implemented this in R as follows.\n<code>\nmultiply <-\
    \ function(number1, number2) {\n  if(number1 < 0 & number2 <0) stop(\"Invalid\
    \ input\")\n  if(number1 == 0 & number2 == 0) return(0)\n  if(number1 == 0 & number2\
    \ > 0) return(number2)\n  if(number1 > 0 & number2 == 0) return(number1)\n  if(number1\
    \ == 1 & number2 < 10) return(number1 * number2)\n  if(number1 > 1 & number2 >\
    \ 10) return(number1 * number2)\n  \n  \n  ifelse(number1 %% 10 == 0 & number2\
    \ %% 10 == 0, \n         return(number1 * number2),\n         ifelse(number2 %%\
    \ 10 == 0 & number1 == 1,\n                ifelse(number1 > 1, \n            \
    \           number1 * number2,\n                       number1 * number2 + 10),\n\
    \                ifelse(number1 == 1 & number2 < 10,\n                       number1\
    \ * number2,\n                       number1 * number2 + 10)))\n}\n</code>\n<|/\
    \ a dscore=1 tags=r |>\n<| a tags=r |>\nTry using recursion.\n<code>", "\n  units\
    \ <- stringr::str_split(as.character(a), \"\")\n  \n  if (length(units) > 1) {\n\
    \    x <- units[[1]]\n    y <- units[[2]]\n  }\n  \n  if (length(x) == 1) {\n\
    \    x <- paste0(x, \"*\", y)\n  }\n  \n  a <- as.integer(x)\n  b <- as.integer(y)\n\
    \  \n  a <- a * 10^(length(x)-1)\n  b <- b * 10^(length(y)-1)\n  \n  return(a)\n\
    }\n", "\n  c <- 0\n  while(a > 0) {\n    c <- c + ((a%10) * b)\n    a <- floor(a/10)\n\
    \  }\n  return(c)\n}\n", "\n  if (a > 9 || a < 0 || b > 9 || b < 0) \n    return(0)\n\
    \  \n  x <- a\n  y <- b\n\n  if (x < y) {\n    while (x < y) {\n      x <- x +\
    \ 1\n      y <- y - 1\n    }\n    return(y * x)\n  }\n  \n  while (y < x) {\n\
    \    y <- y + 1\n    x <- x - 1\n  }\n  return(y * x)\n}\n", "\n  if (is.na(b))\
    \ {\n    return(NA)\n  }\n  if (a == 0 || b == 0) {\n    return(0)\n  }\n  a <-\
    \ strsplit(as.character(a), \"\")[[1]]\n  b <- strsplit(as.character(b), \"\"\
    )[[1]]\n  if (length(a) == 1) {\n    return(b)\n  }\n  if (length(b) == 1) {\n\
    \    return(a)\n  }\n  out <- rep(NA, length(a))\n  for (i in seq_along(a)) {\n\
    \    out <- out + (as.numeric(a[[i]]) * as.numeric(b[[i]]))\n  }\n  out\n}\n</cell>\n\
    <cell>\nmultiply(148, 412)\n</cell>\n<cell>\nmultiply(19, 28)\n</cell>\n<cell>\n\
    multiply(2020, 1851)\n</cell>\n<cell>\nmultiply(14, -15)\n</cell>\n<text>\nExercise\
    \ - Implement the function below that takes two positive integers as input and\
    \ returns the sum of their digits.\n\n</text>\n<cell>", "\n  if(b < 0) {\n   \
    \ return(a)\n  }\n\n  x <- 0\n  for(i in seq_along(floor(a/b))) {\n    x <- x\
    \ * 10\n    x <- x + as.numeric(digits(a/b)[i])\n    a <- floor(a/b)\n  }\n  return(x)\n\
    }\n", "\n  amod <- a%%10; bmod <- b%%10\n  if (amod==0) bmod <- bmod+1\n  amod\
    \ <- amod/10; bmod <- bmod/10\n  return(amod*bmod)\n}\n</cell>\n<cell>", "\n \
    \ if(b == 0) {\n    return(0)\n  }\n  else {\n    a <- a / b\n    a <- 10 * a\
    \ % 10\n    a <- a / 10\n    return(a)\n  }\n}\n", "\n  \n  a1 <- trunc(a)\n \
    \ a2 <- trunc(b) \n  \n  result <- 0\n  \n  for(i in 1:length(a1)) {\n    \n \
    \   result <- result + trunc(10^(a1[i]*a2[i]))\n    \n  }\n  \n  return(result)\n\
    }\n", "\n  # Add conditions to make sure a and b are valid integers\n  a <- a\
    \ < 0 || is.na(a) ? 0 : a\n  b <- b < 0 || is.na(b) ? 0 : b\n  \n  # Compute the\
    \ unit digits of a\n  aunit <- a %% 10\n  a <- a / 10\n  \n  # Compute the unit\
    \ digits of b\n  bunit <- b %% 10\n  b <- b / 10\n  \n  # Compute the product\
    \ of the unit digits\n  result <- a * b \n  \n  # Add back the unit digits\n \
    \ result <- result + aunit * bunit\n  \n  # Check if the result is 0\n  result\
    \ <- result > 0 || is.na(result) ? 0 : result\n  \n  # Return the result\n  result\n\
    }\n</cell>\n<text>\nQuestion 4\nWrite a function that returns all possible permutations\
    \ of the digits of the number:\n\n\n</text>\n<cell>", "\n    if (b == 0) return(0)\n\
    \    if (b %% 10 == 0) return(multiply(a, b %% 10))\n    if (b %% 100 == 0) return(multiply(a,\
    \ b %% 100))\n    if (b %% 1000 == 0) return(multiply(a, b %% 1000))\n    if (b\
    \ %% 10000 == 0) return(multiply(a, b %% 10000))\n    if (b %% 100000 == 0) return(multiply(a,\
    \ b %% 100000))\n    if (b %% 1000000 == 0) return(multiply(a, b %% 1000000))\n\
    \    if (b %% 10000000 == 0) return(multiply(a, b %% 10000000))\n    if (b %%\
    \ 100000000 == 0) return(multiply(a, b %% 100000000))\n    if (b %% 1000000000\
    \ == 0) return(multiply(a, b %% 1000000000))\n    if (b %% 10000000000 == 0) return(multiply(a,\
    \ b %% 10000000000))\n    if (b %% 100000000000 == 0) return(multiply(a, b %%\
    \ 100000000000))\n    if (b %% 1000000000000 == 0) return(multiply(a, b %% 1000000000000))\n\
    \    if (b %% 10000000000000 == 0) return(multiply(a, b %% 10000000000000))\n\
    \    if (b %% 100000000000000 == 0) return(multiply(a, b %% 100000000000000))\n\
    \    if (b %% 1000000000000000 == 0) return(multiply(a, b %% 1000000000000000))\n\
    \    if (b %% 10000000000000000 == 0) return(multiply(a, b %% 10000000000000000))\n\
    \    if (b %% 100000000000000000 == 0) return(multiply(a, b %% 100000000000000000))\n\
    \    if (b %% 1000000000000000000 == 0) return(multiply(a, b %% 1000000000000000000))\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\nTo complete the other answers, there is\
    \ also a very nice way to do it with data.table:\n<code>\nlibrary(data.table)\n\
    setDT(dt)\ndt[,V1:=ifelse(b%%10==0,b%/%10,b%/%100),by=a]\ndt[,V2:=ifelse(b%%100==0,b%/%100,b%/%1000),by=a]\n\
    dt[,V3:=ifelse(b%%1000==0,b%/%1000,b%/%10000),by=a]\ndt[,V4:=ifelse(b%%10000==0,b%/%10000,b%/%100000),by=a]\n\
    dt[,V5:=ifelse(b%%100000==0,b%/%100000,b%/%1000000),by=a]\ndt[,V6:=ifelse(b%%1000000==0,b%/%1000000,b",
  "\n  out <- 0\n  while(a != 0) {\n    out <- out * 10 + a %%10\n    a <- a %/% 10\n\
    \  }\n  out\n}\n</cell>\n<cell>\nmultiply(148, 412)\n</cell>\n<cell>\nmultiply(19,\
    \ 28)\n</cell>\n<cell>\nmultiply(2020, 1851)\n</cell>\n<cell>\nmultiply(14, -15)\n\
    </cell>\n<text>\nProblem 8 (4 points)\nWrite a function that returns a string\
    \ of all the numbers 1 to n.\n\n\n</text>\n<cell>", "\n  if(a==0 | b==0) {\n \
    \   return(0)\n  }\n  a = a %% 10 \n  b = b %% 10\n  mult <- a * b\n  return(mult)\n\
    }\n</cell>\n<cell>", "\n    if(a==0 || b==0) return(0)\n    \n    digits_a <-\
    \ strsplit(as.character(a), \"\")[[1]]\n    digits_b <- strsplit(as.character(b),\
    \ \"\")[[1]]\n    \n    sum(as.numeric(digits_a) * as.numeric(digits_b)) \n}\n",
  "\n  \n  # Your code here\n  \n  result <- 0\n  while (a > 0) {\n    result <- result\
    \ + a%10*b\n    a <- floor(a/10)\n  }\n  if (a < 0) {\n    result <- result +\
    \ a%10*b\n    a <- abs(a)\n  }\n  result\n}\n", "\n  if (a < 0 | a > 9) {\n  \
    \  message(\"Invalid input: Multiply requires only positive integers\")\n    return(-1)\n\
    \  }\n  if (b < 0 | b > 9) {\n    message(\"Invalid input: Multiply requires only\
    \ positive integers\")\n    return(-1)\n  }\n  a <- as.numeric(as.character(a))\n\
    \  b <- as.numeric(as.character(b))\n  res <- a * b\n  return(res)\n}\n", "\n\t\
    return(as.integer(factor(a, levels = c(10, 9, 8, 7, 6, 5, 4, 3, 2))) * \n\t\t\
    factor(b, levels = c(10, 9, 8, 7, 6, 5, 4, 3, 2)))\n}\n</cell>\n<text>\nProblem\
    \ 1.12\nFor this problem, you will need to complete the function\nmultiply_digits(a,\
    \ b) which takes in two numbers a and b\nand returns the product of the unit digits\
    \ of the numbers a and b.\nThe unit digit of one number is 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9. \nFor example, for a = 31 and b = 7, the unit digit of 31 is\n9. The product\
    \ of unit digits of a and b should be calculated as \nshown below.\n\nFor example:\n\
    \nmultiply(30, 7) = 309\nmultiply(6, 30) = 30\nmultiply(6, -5) = 50\nmultiply(-6,\
    \ 30) = 30\nmultiply(-6, -5) = 50\nmultiply(-10, 15) = 0\nmultiply(31, 7) = 309\n\
    multiply(10, 15) = 0\nmultiply(14, 15) = 0\nmultiply(15, 15) = 0\n\n</text>\n\
    <cell>", "\n  a <- as.integer(a)\n  b <- as.integer(b)\n  a <- ifelse(a < 0, abs(a),\
    \ a)\n  b <- ifelse(b < 0, abs(b), b)\n  product <- a * b\n  as.numeric(as.character(product))\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you for answering my question. Your code\
    \ is very helpful.\n<|/ c |>\n<| c |>\nNo problem. Glad I could help you. Would\
    \ you mind marking my answer as \"accepted\"? This helps me (and other people\
    \ in the future) know that it solved your problem :)\n<|/ c |>\n<| c |>\nI added\
    \ another solution that I think is simpler but probably has worse performance.\n\
    <|/ c |>\n<| a dscore=0 |>\nI think this might be a good fit for using modulo\n\
    <code>", "\n    mult <- 0\n    for (i in seq(a)) {\n        if (i == 0) {\n  \
    \          mult <- mult * b\n        } else {\n            mult <- mult * 10\n\
    \            mult <- mult + 10 * b\n        }\n    }\n    return(mult / 10)\n\
    }\n</code>\nThe function is almost certainly not correct for all inputs. For example,\
    \ multiply(148, 412) will return the product of all the digits of 148 times 4,\
    \ and give the wrong answer (16). The function also has the potential to overflow\
    \ for large inputs.\nWe can use the function gmp::gmpmultinm to do the math:\n\
    <code>\nlibrary(gmp)\ngmp::gmpmultinm(148, 412)", "\n  return(a %/% b)\n}\n",
  "\n  a <- as.integer(a)\n  b <- as.integer(b)\n  if (isTRUE(a < 0)) a <- abs(a)\n\
    \  if (isTRUE(b < 0)) b <- abs(b)\n  if (a < b) {\n    a * b\n  } else {\n   \
    \ as.integer(a) - as.integer(b) * 10\n  }\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    I made a slight edit to include checking for negative numbers.\n<|/ c |>\n<| c\
    \ |>\nThanks. I guess that was a fairly minor change. :)\n<|/ c |>\n<| a dscore=2\
    \ |>\nThis is very similar to the solution that proposed but doesn't use modulus\
    \ or subtraction.\n<code>\nmultiply <- function(x, y) {\n  x <- as.integer(x)\n\
    \  y <- as.integer(y)\n\n  if (x > y) x <- x + 10\n\n  digits_x <- stringr::str_split(str_pad(x,\
    \ digits = 3, pad = '0'), '')[[1]]\n  digits_y <- stringr::str_split(str_pad(y,\
    \ digits = 3, pad = '0'), '')[[1]]\n  res <- sapply(digits_x, `*`, digits_y)\n\
    \n  return(max(as.integer(x), as.integer(y)) * 10 + res[which.max(res)])\n}\n\
    </code>\n<|/ a tags=r |>\n<| a tags=r |>\nMy answer only handles positive numbers,\
    \ not negative ones, but it may still be helpful to some. Here is an example:\n\
    <code>", "\n    result <- 0\n    for(i in a%%10*10^(length(a)-1), j=b%%10*10^(length(b)-1),\
    \ k in i%%10*10^(length(i)-1), l in j%%10*10^(length(j)-1) {\n        if(k < l)\n\
    \            result <- result*(i-k)*(j-k)\n        else if(k > l)\n          \
    \  result <- result*(i-l)*(j-l)\n        else if(l < k)\n            result <-\
    \ result*(i-k)*(j-l)\n        }\n    return(result)\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nFor a general set of numbers the method can be made simpler if we use\
    \ binary representation of each number instead of the decimal digits (base 2)\n\
    <|/ c |>\n<| c |>\nCan you elaborate a little bit more? Like how would you go\
    \ about doing it?\n<|/ c |>\n<| c |>\n, added an answer\n<|/ c |>\n<| a |>\nHere\
    \ is an improved version of the code by Rui. \nI added a check for numbers too\
    \ small for the first division by 10 to avoid an infinite loop.\nI used a for\
    \ loop to avoid repeating code. \nI used ifelse instead of if/else for improved\
    \ readability and to avoid the redundant tests. \n<code>\nmultiply <- function(a,\
    \ b) {\n  if (a%%10 > b %% 10) {\n    stop(\"numbers must be the same in both\
    \ inputs\")\n  }\n  if (a %% 10 == b %% 10) {\n    result <- 0\n    for (i in\
    \ a%%10*10^(length(a)-1), j in b%%10*10^(length(b)-1) : (i%%10*10^(length(i)-1)),\
    \ (j%%10*10^(length(j)-1))  {\n      result <- result + (i%%10*10^(length(i)-1))*(j%%10*10^(length(j)-1))\n\
    \    }\n    return(result)\n  }\n  if (a %% 10 < b %% 10) {\n    result <- 0\n\
    \    for (i in a%%10*10^(length(a)-1), j in b%%10*10^(length(b)-1) : (i%%10*10^(length(i)-1)),\
    \ (j%%10*10^(length(j)-1))  {\n      result <- result + (i%%10*10^(length(i)-1))*((j%%10*10^(length(j)-1))-(b%%10*10^(length(b)-1)))\n\
    \    }\n    return(result)\n  }\n}\n</code>\n<|/ a tags=r dscore=0 |>\n<| a dscore=0 ",
  "\n  # Fill in the code below.\n  if(b == 0) return(0)\n  if(b == 1) return(a)\n\
    \  return(multiply(a, digits(b)[1]) * multiply(a, digits(b)[2]))\n}\n", "\n  if\
    \ (a < 0 || b < 0) {\n    stop(\"Invalid input: both numbers cannot be negative\"\
    )\n  } \n  \n  res <- 0\n  \n  while (a > 0) {\n    res <- res + a%10*b%10\n \
    \   a <- floor(a/10)\n    b <- floor(b/10)\n  }\n  \n  return(res)\n}\n", "\n\
    \  res <- a\n  res <- res * 10\n  res <- res + b\n  res <- res / 10\n  return(res)\n\
    }\n</cell>\n<text>\nQuestion 9: Write a function that converts a whole number\
    \ to its unit digits. Assume that the input always belongs to a valid unit number,\
    \ and that the input is an integer greater than 0.\n\n</text>\n<cell>", "\n  return(as.integer(sprintf('%%d%d',\
    \ a) * sprintf('%%d%d', b)))\n}\n</cell>\n<cell>", "\n  x <- as.numeric(levels(a))[as.numeric(a)]\n\
    \  y <- as.numeric(levels(b))[as.numeric(b)]\n  return(round(x*y))\n}\n</code>\n\
    <|/ a dscore=1 tags=r |>\n<| a tags=r |>\nYou could use dplyr\n<code>\ndf %>%\
    \ mutate(Product = apply(.,1,function(x){x[2]*x[1]}))\n", "\n  if(a==0 | b==0)\
    \ {\n    NA\n  } else {\n    if(abs(a) > abs(b)) {\n      a <- a * sign(b)\n \
    \   } else {\n      b <- b * sign(a)\n    }\n    result <- a / b\n    return(result)\n\
    \  }\n}\n</code>\nHere's some sample data\n<code>\nset.seed(123)\nsample_data\
    \ <- data.frame(\n  name = as.character(sample(c(LETTERS, letters), 100, replace\
    \ = TRUE)),\n  value = sample(c(seq(0, 100, by = 1), NA), 100, replace = TRUE)\n\
    )\n\nhead(sample_data)", "\n    # Complete this function!\n    product <- 0\n\
    \    a <- as.integer(a)\n    b <- as.integer(b)\n    while (a > 0 || b > 0) {\n\
    \        if (a > 0 & b == 0) {\n            product <- product + a %/%10\n   \
    \         a <- as.integer(a %/%10)\n        } else {\n            product <- product\
    \ + b %/%10\n            b <- as.integer(b %/%10)\n        }\n    }\n    product\n\
    }\n</code>\nMy solution works, but I think it can be improved. The main issue\
    \ is that it uses unnecessary steps. For example, you can find the product of\
    \ the unit digits using a = a %/% 10 and b = b %/% 10, which means you don't need\
    \ the as.integer-casting step. Also, your function does not handle negative numbers\
    \ well. This could be fixed using a = a - as.integer(a) instead of a = a %/% 10.\
    \ But again, I don't think you need it since the product of the unit digits is\
    \ not necessarily negative.\n<|/ a dscore=3 tags=r |>\n<| c |>\nYour function\
    \ produces unnecessary output by including units. Try with `a = 19; b = -45; multiply(a,\
    \ b)` instead.\n<|/ c |>\n<| c |>\nThanks for pointing that out! I've fixed it\
    \ now.\n<|/ c |>\n<| c |>\nI see that your solution works. But for my assignment\
    \ I was asked to use recursive functions, not loops. So I came up with this: https://pastebin.com/yLmKkK2U\n\
    <|/ c |>\n<| c |>\nOk, I've fixed it again. Your recursive function produces a\
    \ wrong answer when `a = 1` and `b = -1`. That's because you're doing a modulus\
    \ operation when your `a` and `b` get negative numbers, which makes the function\
    \ go into an infinite loop.\n<|/ c |>\n<| c |>\nI appreciate your help and your\
    \ effort! The output is still wrong, but at least I know how to do it!\n<|/ c\
    \ |>\n<| a tags=r |>\nThe simple way is to implement the Euclid's algorithm and\
    \ then check whether the product is zero. For this we will use two helper functions:\n\
    \ngcd: Find greatest common divisor of two numbers.\ninverse: Find the inverse\
    \ of a number.\n\nTo test whether the product is zero we use the fact that if\
    \ gcd of x and y is 1 then x is equivalent to y. Hence, if the gcd of x and y\
    \ is 1 then it implies that x is equivalent to y times the inverse.\n<code>\n\
    gcd <- function(a, b) if (", "\n  return(as.integer(a) * as.integer(b))\n}\n",
  "\n  if(!is.integer(a) || !is.integer(b)) {\n    stop(\"arguments must be integers\"\
    )\n  }\n  if(b < 0) b<-abs(b)\n  if(!is.integer(b)) {\n    stop(\"input must be\
    \ integer\")\n  }\n  if(b == 0) return(0)\n  a = as.integer(a)\n  b = as.integer(b)\n\
    \  if(a*b<10) {\n    return(a*b)\n  } else {\n    if(b > 0) {\n      return(multiply(a/10,\
    \ b*10))\n    } else {\n      return(a*10+multiply(a/10, -b*10))\n    }\n  }\n\
    }\n</code>\n<|/ a tags=r,algorithm dscore=1 |>\n<| c |>\nThis would be a good\
    \ solution if you needed to find the number of digits of the product, rather than\
    \ the product itself. However, in my case, I need to be able to test to see if\
    \ the product is actually valid. For example (5 + 4) == 9 but (5 + 4) != 10\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's a recursive function that can do what you want:\n\
    <code>\nf <- function(x, digits=2) {\n  if(x > 1) {\n    x <- x / 10\n    f (x,\
    \ digits - 1)\n  }\n  return(digits)\n}\n</code>\n<|/ a tags=r,algorithm |>\n\
    <| a |>\nWe can use the following code to find the number of digits of the product\
    \ of two integers. But please note that if you want this to be the product of\
    \ the digits, you will have to reverse them in the function.\n<code>", "\n   \
    \ if (a < 0) {\n        a <- -a \n    } else if (a > 9) {\n        a <- 0\n  \
    \  }\n    if (b < 0) {\n        b <- -b\n    } else if (b > 9) {\n        b <-\
    \ 0\n    }\n    if (a == 0) {\n        return(b)\n    } else if (b == 0) {\n \
    \       return(a)\n    } else if (a < 10) {\n        result <- 0\n    } else if\
    \ (b < 10) {\n        result <- 0\n    } else if (a > 9) {\n        result <-\
    \ 0\n    } else if (b > 9) {\n        result <- 0\n    } else {\n        result\
    \ <- 10 * a + b\n    }\n    return(result)\n}\n", "\n    if (a < 0 || b < 0) {\n\
    \        stop(\"The input values must be positive\")\n    }\n\n    if (b %% 10\
    \ == 0 && a%% 10 == 0) return(as.integer(b)/as.integer(a))\n    \n    x <- as.integer(b)/as.integer(a)\n\
    \    y <- a %% 10\n    z <- b %% 10\n    if (y==0 & z!=0) {return(x-z)}\n    if\
    \ (y==0 & z==0) {return(x*y)}\n    if (y!=0 & z==0) {return(x*y)}\n    if (y!=0\
    \ & z!=0) {return(x*y+z)}\n}\n", "\n  return(as.integer(strsplit(sprintf(\"%+d\"\
    , a), \"\")[[1]][3] - strsplit(sprintf(\"%+d\", b), \"\")[[1]][3]) * 10)\n}\n",
  "\n  a <- as.integer(a)\n  b <- as.integer(b)\n  a / b\n}\n", "\n  # If the signs\
    \ are opposite then we are done\n  if((a < 0) || (b < 0)) stop(\"Invalid input\"\
    )\n  \n  # Calculate the product and unit digit product\n  prod <- 0\n  units\
    \ <- 0\n  \n  # Loop through the units in both numbers\n  for(i in seq(a)) {\n\
    \    # If the current unit in b is less than the unit in a, then we need to multiply\
    \ that unit by b\n    if(b < i) prod <- prod + (b - i)\n    # Otherwise, the unit\
    \ in b is greater, so we need to subtract that unit from a\n    else prod <- prod\
    \ + (i - b)\n    \n    # Add the unit digit\n    units <- units + i\n  }\n  \n\
    \  # Return the product and unit digit\n  return(prod + units)\n}\n</code>\n<|/\
    \ a tags=r,integer,algorithm dscore=3 |>\n<| c |>\nI thought of doing this but\
    \ I just don't like using loops. And that isn't the only reason I didn't like\
    \ it: It's not vectorized.\n<|/ c |>\n<| c |>\n: That sounds like a good reason.\
    \ Vectorization is usually a good thing. But if you don't like loops in R then\
    \ I guess you could consider using `sapply`. I just don't know if that'll do much\
    \ for you.\n<|/ c |>\n<| c |>\nI'm pretty sure that the R code you've posted here\
    \ is not vectorized (the loop in `multiply` is).\n<|/ c |>\n<| c |>\n`Vectorize()`\
    \ would work but you'd still have to do `sapply` for each digit. I'm sure there\
    \ must be a better way of doing this though...\n<|/ c |>\n<| c |>\n- You are right.\
    \ Vectorize doesn't help here. I've deleted that part and replaced it with a `for`\
    \ loop that works.\n<|/ c |>\n<| a dscore=3 tags=r,integer,algorithm |>\nHere's\
    \ my take:\n<code>", "\n    stopifnot(isTRUE(is.numeric(a)), 'a must be numeric')\n\
    \    stopifnot(isTRUE(is.numeric(b)), 'b must be numeric')\n    \n    if (a <\
    \ 0 || b < 0) {\n        stop('a and b must be non-negative')\n    }\n    if (a\
    \ < b) {\n        stop('a must be less than b')\n    }\n    \n    digit <- floor(log10(abs(a)))\n\
    \    if (digit == 0)\n        stop('a must be positive')\n    \n    digit <- digit+1\n\
    \    \n    digits <- paste0('0', seq(digit))\n    \n    result <- 0\n    for (i\
    \ in digits) {\n        result <- result + ((10^(digit-length(i))) * (a/b)) %%\
    \ 10\n    }\n    return(result)\n}\n</cell>\n<cell>", "\n  \n}\n</cell>\n<cell>",
  "\n  as.integer(a / b %% 10) * as.integer(b / (10 ^ floor(log10(abs(b)))) %% 10)\n\
    }\n", "\n  a <- suppressWarnings(as.integer(a))\n  b <- suppressWarnings(as.integer(b))\n\
    \  c <- suppressWarnings(a %/% b)\n  return(c)\n}\n", "\n  # Your code here\n\
    \  \n  # return the result of the computation\n  \n}\n", "\n  if (a>=b){\n   \
    \ stop(\"The first number is greater than the second number\")\n  } \n  if (a==0\
    \ || b==0){\n    return(0)\n  }\n  if (b%%10==0) {\n    return (multiply(a/10,\
    \ b%10) * 10)\n  }\n  if (a%%10==0) {\n    return (multiply(a/10, b%10) * 10)\n\
    \  }\n  if (a%%10==0 && b%%10==0) {\n    return(a*b)\n  }\n  \n}\n", "\n    if\
    \ (a > 9) {\n        a <- a - 10\n    }\n    if (b > 9) {\n        b <- b - 10\n\
    \    }\n    result <- 0\n    result <- result + a * 10^(b - 1)\n    return(result)\n\
    }\n</code>\nThis function is now complete, we just need to complete the for loop.\n\
    <code>", "\n    c <- a / 10\n    d <- b / 10\n    e <- c * d\n    f <- e\n   \
    \ g <- f + b\n    h <- g / 10\n    i <- h\n    j \n    k <- i + c\n    l\n   \
    \ m <- k / 10\n    n <- m * 10\n    o <- n + b\n    p\n}\n</code>\n<|/ a |>\n\
    <| a |>\nYou can use gmp and the lubridate package:\n<code>\nlibrary(gmp)\nlibrary(lubridate)\n",
  "\n    \n    a <- a\n    b <- b\n    \n    if (a > b) {\n        stop(\"The first\
    \ number must be less than the second\")\n    }\n    \n    a <- trunc(a)\n   \
    \ b <- trunc(b)\n    \n    if (a == 0) {\n        return(0)\n    }\n    else if\
    \ (a == 1) {\n        return(b)\n    }\n    else if (b == 0) {\n        return(a)\n\
    \    }\n    else if (b == 1) {\n        return(trunc(trunc(a) * b * 100))\n  \
    \  }\n    else {\n        mult <- trunc(a/100)\n        mult <- trunc(mult*b%100/100)\n\
    \        return(trunc(mult*100))\n    }\n}\n</cell>\n<text>\nProblem 2: Using\
    \ your previous function, convert the integers into their digit representation,\
    \ multiply them together, and add the result to the original integer.\n\n</text>\n\
    <cell>", "\n  \n  # Initialize result\n  res <- 0\n  \n  # Store the remainder\
    \ after dividing\n  rem <- a %% b\n  \n  # Store the digits of the two numbers\
    \ to divide\n  a <- a / b\n  b <- b / 10\n  \n  # Perform the division until we\
    \ reach zero\n  while (a > 0) {\n    a <- a %% b\n    b <- b / 10\n    res <-\
    \ res * 10 + rem\n    rem <- rem %% b\n  }\n  return(res)\n}\n</code>\nTest the\
    \ function\nNow that we have a working function, we can test it using different\
    \ numbers:\n<code>", "\n  # Write your code here!\n  a <- suppressWarnings(as.integer(a))\n\
    \  b <- suppressWarnings(as.integer(b))\n  a <- ifelse(a < 0, -a, a)\n  b <- ifelse(b\
    \ < 0, -b, b)\n  res <- a * b\n  return(ifelse(is.na(res), 0, res))\n}\n", "\n\
    \  \n  if(a < 0 & b < 0) {\n    return(0)\n  }\n  if(a < 0 & b > 0) {\n    return(0)\n\
    \  }\n  if(a > 0 & b < 0) {\n    return(0)\n  }\n  if(a > 0 & b > 0) {\n    return(digits(a)[1]*digits(b)[2])\n\
    \  }\n  return(0)\n}\n", "\n  return(ifelse(b < 0 || !is.integer(a) || !is.integer(b),\
    \ 0, a*b))\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for negative inputs.\
    \ You need to convert both inputs to integers (`as.integer`), perform the computation,\
    \ and then convert the result back to character form (`as.character`). Also, the\
    \ `ifelse` expression can be simplified to: `return(ifelse(b < 0 || !is.integer(a)\
    \ || !is.integer(b), 0, a*b))`\n<|/ c |>\n<| c |>\n- Thank you for correcting\
    \ me on the `ifelse` suggestion; I was just typing something quick and then getting\
    \ a message in the console that said I should use that instead. Regarding the\
    \ negative inputs, `ifelse` works just fine for me; could you provide a specific\
    \ example where it does not?\n<|/ c |>\n<| c |>\nI ran a test and got the error\
    \ message you mentioned; so I guess it works now?\n<|/ c |>\n<| c |>\n- Yeah that\
    \ was it. Glad it worked for you. I've never run into anything like this and I'm\
    \ sure I used `ifelse` before for positive values. I guess I really had the wrong\
    \ end of the stick thinking about it like it wasn't an issue for negative values.\
    \ Thanks!\n<|/ c |>\n<| c |>\n- You're right, `ifelse` works just fine for me\
    \ with negative values now; but it's worth noting that the reason `ifelse` is\
    \ better for negative values is because `ifelse` allows the condition to be evaluated\
    \ only once; whereas `+` or `*` will evaluate it every time. I've edited the answer\
    \ to reflect that as well.\n<|/ c |>\n<| a tags=r |>\n<code>", "\n  a <- as.numeric(a)\n\
    \  b <- as.numeric(b)\n\n  if (is.na(a) || is.na(b)) {\n    stop(\"Invalid input.\
    \ Ensure both inputs are numeric.\", call. = FALSE)\n  }\n  if (is.na(a) == TRUE)\
    \ {\n    return(0)\n  }\n  if (is.na(b) == TRUE) {\n    return(0)\n  }\n  if (a\
    \ == 0) {\n    return(b)\n  }\n  if (b == 0) {\n    return(a)\n  }\n  a <- formatC(a,\
    \ digits = 2)\n  b <- formatC(b, digits = 2)\n\n  a <- as.numeric(a)\n  b <- as.numeric(b)\n\
    \n  if(a > b) {\n    a <- a - b\n  }\n  if(a == 0) {\n    return(0)\n  }\n  a\
    \ <- round(as.numeric(a) * 10, 0)\n  b <- round(as.numeric(b) * 10, 0)\n  return(round(a\
    \ * b, 0))\n}\n", "\n  \n  # Add zeros to make the result an integer if needed.\n\
    \  \n  mult <- 0\n  \n  # Test if a's digits are all zero\n  if(a%%10 ==0) {\n\
    \    a <- a / 10\n  }\n  \n  # If b's digits are all zero\n  if(length(b) == 1)\
    \ b <- b * 10\n  \n  # Test if b's digits are all zero\n  if(length(b) == 1) b\
    \ <- b * 10\n  \n  if(a %% 10 == 0 & b %% 10 == 0) mult <- a * b\n  \n  if(a %%\
    \ 10 != 0 & b %% 10 == 0) mult <- a * b\n  \n  if(a %% 10 != 0 & b %% 10 != 0)\
    \ mult <- a * b\n  \n  if(a %% 10 == 0 & b %% 10 != 0) mult <- a * b\n  \n  if(a\
    \ %% 10 != 0 & b %% 10 != 0) mult <- a * b\n  \n  return(mult)\n}\n", "\n  if\
    \ (a == 0 || b == 0) {\n    return(0)\n  }\n  x <- floor((a / pow(10, b)))\n \
    \ y <- floor(a %% pow(10, b))\n  return(x %% 10 * y)\n}\n", "\n  a <- as.numeric(as.character(a))\n\
    \  b <- as.numeric(as.character(b))\n  result <- a*b\n  return(result)\n}\n",
  "\n  n1 <- as.integer(floor(a / 10^floor(log10(abs(a)))));\n  n2 <- as.integer(floor(a\
    \ / 10^floor(log10(abs(b)))));\n  out <- as.integer(n1 * 10^floor(log10(abs(n2))))\n\
    \  if (a > b) out <- -(out - b + 10);\n  return(out);\n}\n</code>\n<|/ a tags=math,integer,r\
    \ |>\n<| a tags=math,integer,r |>\nAn R solution without using any package:\n\
    <code>\nmult <- function(m, n) {\n  if(n%%10 != 0) return(mult(m,n%/%10*10))\n\
    \  return(n%*%m*10^(floor(log10(n))+1))\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    A recursive solution that does not use logs or log10.  It is not exactly the same,\
    \ since it returns 0.  It would be better to have it return -9999 if there were\
    \ an odd number of digits.  But it works for your examples and is easy to extend\
    \ to other cases.\n<code>\nmult <- function(a, b) {\n    n <- length(a);\n   \
    \ k <- 1;\n    d <- 1;\n    if (n <= 0) {\n        return(1);\n    }\n    while\
    \ (n > 0) {\n        if (k >= n) {\n            k <- 1;\n            d++;\n  \
    \      }\n        n <- n / 10;\n        k <- k + 1;\n    }\n    d <- d - 1;\n\
    \    out <- a * 10^d;\n    out <- ifelse(out < 0, -9999, out);\n    return(out);\n\
    }\n</code>\n<|/ a tags=math,integer,r dscore=2 |>\n<| c |>\nThanks, this was exactly\
    \ what I was looking for.\n<|/ c |>\n<| a tags=math,integer,r dscore=1 |>\nYou\
    \ could also use gmp library. Here is an example for factoring integers:\n<code>\n\
    library(gmp)\nn <- 148;\nx <- as.bigz(n)\nx %/% as.bigz(3)", "\n    if(b == 0)\
    \ {\n        return(0)\n    }\n    \n    # Initialize the answer variable to be\
    \ the smaller one\n    answer = min(a, b)\n\n    # Look at each digit of the units\
    \ and multiply \n    # by the digit in the longer one\n    \n    for(i in 1:which.max(b))\
    \ {\n        digit = b %% 10\n        answer = answer * digit\n        b = b %%\
    \ 10\n    }\n    \n    # Return the answer\n    return(answer)\n}\n</cell>\n<cell>",
  "\n  a <- as.integer(a)\n  b <- as.integer(b)\n  if(b == 0)\n    return(0)\n  else\
    \ {\n    carry <- a %%10\n    a <- a %/% 10\n    a <- 10*a + carry\n    carry\
    \ <- b %%10\n    b <- b %/% 10\n    b <- 10*b + carry\n    return(a * b)\n  }\n\
    }\n", "\n  a <- as.numeric(a %/% 10)\n  b <- as.numeric(b %/% 10)\n  return(a\
    \ ^ b)\n}\n</cell>\n<cell>", "\n  a <- as.numeric(a)\n  b <- as.numeric(b)\n \
    \ if (a > max(a * 10 - 1, b * 10 - 1) || b > max(a * 10 - 1, b * 10 - 1) || a\
    \ == 0 || b == 0) {\n    return(0)\n  } else if (a < 0 || b < 0) {\n    return(0)\n\
    \  } else {\n    x <- a / 10\n    y <- a %% 10\n    d <- b / 10\n    e <- b %%\
    \ 10\n    return(10 * x * y * d + e * d)\n  }\n}\n", "\n  # BEGIN Practice Test\
    \ Cases\n  if(is.na(a) || is.na(b)) {\n    return(0)\n  } else if(a > b) {\n \
    \   return(as.integer(0))\n  } else {\n    return(as.integer(a%%b))\n  }\n  #\
    \ END Practice Test Cases\n}\n", "\n    m <- floor((a + b)/10)\n    n <- floor((a\
    \ + b - 10*m)/10)\n    p <- floor(a + b - 10*m - 10*n)\n    p \n}\n</code>\n<|/\
    \ a |>\n<| a dscore=0 tags=integer,r,math,modulo |>\nYou can use the fact that\
    \ R's modular arithmetic is exact:\n<code>\nx <- c(148, 412, 19, 28)\ny  <- c(148,\
    \ 412, 19, 28)\nz  <- c(148, 412, 19, 28)\n\nres <- x %/% y\nres\n[1] 16 72 20\
    \ 0\n</code>\n<|/ a |>\n<| c |>\nThat's pretty clever, but it doesn't work for\
    \ OP's example. `x %/% y == 0` because `x %/% y` is *exactly* zero.\n<|/ c |>\n\
    <| c |>\nYes, but that's not what OP is asking for. He wants to calculate the\
    \ product of its unit digits. Your code will give the product of whole digits,\
    \ which is equivalent to multiplying `x %/% y` by `n`.\n<|/ c |>\n<| c |>\nIf\
    \ `x` and `y` don't contain `NA`, then you can do `x %/% y`, which will give you\
    \ the correct result. Otherwise (including `NA`), `x %/% y` will return `NA`.\n\
    <|/ c |>\n<| a |>\nA vectorized version of the accepted answer:\n<code>\nx <-\
    \ c(148, 412, 19, 28)\nn <- c(148, 412, 19, 28)\n(x %/% n)[!(x %/% n) == 0]",
  "\n  if (a == 0 || b == 0)\n    return(0)\n  else\n    a1 <- digits(a)\n    b1 <-\
    \ digits(b)\n    digits <- length(a1)\n    mult <- 0\n    for(i in seq_along(a1))\
    \ {\n      mult <- mult * 10 + a1[i] * 10 + b1[i]\n    }\n    sum(mult%/%10^(i+1L))\n\
    \  }\n  \n  ", "\n  x = 10^a\n  y = 10^b\n  if (y == 0) return(0)\n  return(x\
    \ * y)\n}\n", "\n  num <- paste(a, b, sep=\"\", na.rm=T)\n  num <- ifelse(nchar(num)\
    \ == 1, paste0(\"0\", num), num)\n  num <- as.integer(num)\n  units <- strsplit(num,\
    \ \".\", fixed=T)[[1]]\n  units <- units[length(units)]\n  num <- as.integer(num)\n\
    \  units <- as.integer(units)\n  units <- rep(units, each=(nchar(num) - 1))\n\
    \  product <- units * num\n  product\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThank\
    \ you very much! You were very helpful!\n<|/ c |>\n<| a tags=r |>\nHere's a base\
    \ R solution. I'll break it into steps:\n\nFirst, we'll create a function that\
    \ can take a number like \"148.412\" and output the fractional digits. I'll use\
    \ gsubfn to replace everything except the fractional digits with blanks.\n<code>\n\
    library(gsubfn)\n\nfrac <- function(x)\n{\n  s <- gsubfn(\"(?<=^[0-9]+)(?=\\\\\
    .)\", \" \", x)\n  as.numeric(s) * as.numeric(gsub(\"\\\\.\", \"\", s))\n}\n</code>\n\
    Next, we want to extract the numerical part of the number. I'll use read.table\
    \ to do that.\n<code>\nnum <- read.table(text = \"148.412\")[[1]]\n</code>\nFinally,\
    \ we extract the fractional digits using frac, and multiply by that fractional\
    \ digit.\n<code>\nprod(frac(x) * num)\n</code>\n\nResults:\n<code>\n> num <- read.table(text\
    \ = \"148.412\")[[1]]\n> frac(x) * num\n[1] 16\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nVery nice solution! I didn't know about gsubfn and read.table. Thank you\
    \ so much for teaching me these techniques!!\n<|/ c |>\n<| c |>\nThis also works:\
    \ `as.integer(num) * frac(x)`\n<|/ c |>\n<| a dscore=0 |>\nThe answer using gsubfn\
    \ and read.table() was very useful to me, thanks! \nI wanted to extend it a bit\
    \ further and wanted to check if there were any extra spaces in the string and\
    \ remove them with gsub(). So that \"148.412\" would become \"148412\". \n<code>\n\
    gsub(\"[ ]{2,}\", \"\", \"148.412\")\n</code>\nThis would leave the \"4.\" and\
    \ the \"8.\" intact. I used the follow", "\n  if (a < 0 || b < 0) {\n    return(0)\n\
    \  }\n  \n  a <- str(a)\n  b <- str(b)\n  \n  a <- a[1]\n  b <- b[1]\n  \n  a\
    \ <- str_split(a, \"\")[[1]]\n  b <- str_split(b, \"\")[[1]]\n  \n  a <- na.omit(as.numeric(a))\n\
    \  b <- na.omit(as.numeric(b))\n  \n  a <- a * 10^(a[1]-1)\n  b <- b * 10^(b[1]-1)\n\
    \  \n  a[1] <- 0\n  \n  b <- ifelse(b == 1, 1, b)\n  b <- ifelse(b == 2, 1, b)\n\
    \  b <- ifelse(b == 3, 1, b)\n  b <- ifelse(b == 4, 2, b)\n  b <- ifelse(b ==\
    \ 5, 3, b)\n  b <- ifelse(b == 6, 4, b)\n  b <- ifelse(b == 7, 5, b)\n  b <- ifelse(b\
    \ == 8, 6, b)\n  b <- ifelse(b == 9, 0.5, b)\n  \n  result <- a + b\n  \n  return(round(result))\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI see no reason for downvoting this answer. The\
    \ solution works, and the OP has stated that they want an answer that only uses\
    \ base R. Besides, this is an excellent solution, and I think it is clear that\
    \ people are trying to learn, not to get a job done.\n<|/ c |>\n<| c |>\nI agree\
    \ that it's an excellent solution, but I believe that it's a little too \"hacky\"\
    \ to be the accepted answer. Perhaps I'm missing something, but this could be\
    \ more easily done with `ifelse` statements, like in the answer I posted. Also,\
    \ it's probably not an \"excellent\" solution because I chose to solve the issue\
    \ with the OP's specifications of base R. It might be worth pointing out that\
    \ you could do this with a simple `for` loop and `gsub(\"(.)(.)\", \"\\\\2\\\\\
    1\", \"(148) 412\")`, but I believe that it's better to learn the proper R functions\
    \ for this kind of situation.\n<|/ c |>\n<| c |>\n, what do you mean by hacky?\
    \ If it is an \"hacky\" solution, then that should be explained to the OP so they\
    \ can get to the right answer, rather than the solutions given.\n<|/ c |>\n<|\
    \ c |>\nThe accepted answer uses `ifelse` statement", "\n    \n    # Write your\
    \ code here.\n    \n}\n</cell>\n<cell>", "\n  a <- as.character(a)\n  b <- as.character(b)\n\
    \  \n  if (a == \"0\") a <- as.integer(a)\n  if (b == \"0\") b <- as.integer(b)\n\
    \n  tmp <- substr(b, 1, 3)\n  if (grepl(\"[0-9]\", tmp)) return(as.integer(a*b))\n\
    \  if (grepl(\"[12][0-9]\", tmp)) return(as.integer(a*b))\n  \n  tmp <- substr(a,\
    \ 1, 1)\n  if (grepl(\"[0-9]\", tmp)) return(as.integer(a*b))\n  if (grepl(\"\
    [12][0-9]\", tmp)) return(as.integer(a*b))\n  \n  tmp <- substr(b, 1, 2)\n  if\
    \ (grepl(\"[0-9]\", tmp)) return(as.integer(a*b))\n  if (grepl(\"[12][0-9]\",\
    \ tmp)) return(as.integer(a*b))\n  \n  tmp <- substr(a, 2, 2)\n  if (grepl(\"\
    [0-9]\", tmp)) return(as.integer(a*b))\n  if (grepl(\"[12][0-9]\", tmp)) return(as.integer(a*b))\n\
    \  \n  tmp <- substr(b, 2, 2)\n  if (grepl(\"[0-9]\", tmp)) return(as.integer(a*b))\n\
    \  if (grepl(\"[12][0-9]\", tmp)) return(as.integer(a*b))\n  \n  return(as.integer(0))\n\
    }\n", "\n  if (b < 0) {\n    a <- a * -1\n    b <- -b * -1\n  }\n  a <- trunc(a)\n\
    \  b <- trunc(b)\n  c <- trunc(a * b)\n  if (c < 0) {\n    c <- c + 12\n  }\n\
    \  return(c)\n}", "\n  if (abs(a) == 0) {\n    return(b);\n  } else if (abs(b)\
    \ == 0) {\n    return(a);\n  } else if (abs(a) > abs(b)) {\n    r <- multiply(a,\
    \ b/10)\n    if (b %% 10 != 0) {\n      r <- r + multiply(a/10, 10)\n    }\n \
    \   return(r);\n  } else {\n    r <- multiply(b/10, a)\n    if (a %% 10 != 0)\
    \ {\n      r <- r + multiply(b/10, 10/a)\n    }\n    return(r);\n  }\n}\n", "\n\
    \  # your code here\n}\n", "\n  \n  b <- b / 10\n  a <- a / 10\n  \n  if(a ==\
    \ 0) {\n    if(b == 0) {\n      return(1)\n    }\n    return(0)\n  }\n  \n  \n\
    \  if(b < 0) {\n    a <- a + (-a * b)\n    return(multiply(a, 10 - b))\n  }\n\
    \  \n  if(b > 0) {\n    a <- a + (a * b)\n    return(multiply(a, b))\n  }\n  \n\
    }\n", "\n    if (a == 0) return(NA)\n    if (b == 0) return(NA)\n    a <- as.integer(a)\n\
    \    b <- as.integer(b)\n    return(a * b / a)\n}\n</cell>\n<text>\nProblem 2b\n\
    Test the function with the integer zero. How does your function behave?\n\n\n\
    </text>\n<cell>\nmultiply(0, 0)\n</cell>\n<text>\nProblem 2c\nTest your function\
    \ with the integer zero. Is the result correct?\n\n\n</text>\n<cell>", "\n   \
    \ mult <- 0\n    for (i in 0:9) {\n        mult <- mult + b^i*a\n    }\n    mult\
    \ <- mult %/% 10\n    mult <- mult %% 10\n}\n</cell>\n<cell>", "\n  for(i in a:b)\
    \ {\n    x <- 0\n    for(j in 1:i) {\n      x <- x * 10\n    }\n    x <- x + i\n\
    \  }\n  return(x)\n}\n\nmultiply(148, 412)\n</code>\n<|/ a tags=r,math,multiplication\
    \ |>\n<| a dscore=0 |>\nI believe that the algorithm below will help you out in\
    \ figuring this out. \nLet a and b be two integers. Then\n<code>\n(a*b)/(a+b)\
    \ <- (a/b)*(b+a)/(b-a)\n</code>\nNow, let c and d be the factors of a and b, respectively.\n\
    <code>\n(a*d)/(b*c) <- (a/c) * (b*c)/(a*c)\n(a*b)/(b*d) <- (a/b) * (b/d) * (a*d)/(b*c)\
    \ <- (a*d)/(b*c)\n(a*b)/(b*d) <- (a/b) * (b/d) * (a*d)/(b*c) <- (a/c) * (b/d)\
    \ * (a*d)/(b*c)\n</code>\nSo you can figure it out on paper.\n<|/ a tags=r,math,multiplication\
    \ |>\n<| a tags=r,math,multiplication |>\nHere is a function that computes the\
    \ product of two integers, mod one another integer (mod 10, the modulus of the\
    \ quotient of the integers):\n<code>\nmult <- function(x,y) {\n    if(y>x) { stop(\"\
    y must be < x\") }\n    x <- x%10 \n    y <- y%10\n    y <- ifelse(y == 1, 10,\
    \ y)\n    y <- y/10\n    y <- y*10\n    y <- y+1\n    y <- y%10\n    y <- ifelse(y\
    \ == 10, 0, y)\n    x <- x*10\n    x <- x/10\n    x <- x*y\n    x <- x+x\n   \
    \ x <- x+x\n    return(x)\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis might\
    \ help you out:\n<code>\nmy_multiplication <- function(x,y){\n  a<-floor(x/10)*10\n\
    \  b <- x%10\n  x<-floor(y*10)\n  z<-y*10\n  if(z>x){\n    z<-z%10\n  }\n  x<-x%10\n\
    \  y<-y%10\n  z<-z%10\n  if(z>x){\n    z<-z%", "\n    \n    # write your logic\
    \ here\n    if(a==0 && b==0) return(0)\n    if(a==0) return(b)\n    if(b==0) return(a)\n\
    \    if(a>0 && b>0) {\n        \n        res<-a*b\n        \n        if(res<10)\
    \ {\n            return(res)\n        }\n        \n        return(res)\n    }\n\
    \    \n}\n</cell>\n<cell>", "\n    \n}\n</cell>\n<cell>", "\n  # Your code here\n\
    \  # This should return 0 if b is negative, otherwise a\n  if(a < 0) {\n    return(0)\
    \ \n  }\n  return(b*a%10) * 10^(floor(log10(b)/10))\n}\n</cell>\n<text>\nQ2. What\
    \ is the minimum value of n?\nInput (stdin)\n8\nOutput (stdout)\n3\n\n</text>\n\
    <cell>", "\n  res <- a %/% b\n  return(res)\n}\n</code>\nLet's test it...\n<code>\n\
    multiply(148, 412)", "\n  res <- a\n  i <- 1\n  while (b > 0) {\n    if (b < 10)\
    \ {\n      res * i <- res * a + b\n      b <- b - 10\n    } else {\n      res\
    \ * i <- res * a\n      b <- b - 10\n    }\n    i <- i + 1\n  }\n  res\n}\n",
  "\n  result <- 0\n  for (i in seq(a, b)) {\n    result <- result + as.numeric(substr(i,\
    \ 1, 1))\n  }\n  return(result)\n}\n</code>\nWe can then use mapply to apply this\
    \ function to all pairs of numbers whose units differ by 1 in the first digit:\n\
    <code>\nmapply(multiply, sapply(c(1, 2), function(x) seq(as.integer(x), as.integer(x\
    \ + 1))))", "\n  a <- as.numeric(format(round(a), nsmall=1))\n  b <- as.numeric(format(round(b),\
    \ nsmall=1))\n  a <- ifelse(a > 15, a, b * 10)\n  b <- ifelse(b > 15, a, -b /\
    \ 10)\n  b <- ifelse(b <= 0, 0, b)\n  result <- ifelse(a < b, a * b, 0)\n  return(result)\n\
    }\n</code>\nThe function takes two integers and returns the product of their unit\
    \ digits. The input is assumed to always be valid as discussed in the question.\
    \ \nThe input can be represented in two ways. One way is as a fraction and another\
    \ is a decimal number. \nA fraction is represented as a string like \"148.00/412\"\
    . We can convert this to a number using the function read_decimal. \n<code>\n\
    > read_decimal(\"148.00/412\")\n[1] 148.00 412\n</code>\nThe second way is as\
    \ a decimal number with the last two digits representing the fraction.\n<code>\n\
    > read_decimal(\"1928\")\n[1] 19.28\n</code>\nNow we use the function multiply\
    \ to calculate the product of the unit digits.\n<code>\n> multiply(read_decimal(\"\
    148\"), read_decimal(\"412\"))\n[1] 16\n> multiply(read_decimal(\"19\"), read_decimal(\"\
    28\"))\n[1] 72\n> multiply(read_decimal(\"2020\"), read_decimal(\"1851\"))\n[1]\
    \ 0\n> multiply(read_decimal(\"14\"), -read_decimal(\"15\"))\n[1] 20\n</code>\n\
    The function returns 0 if the input does not represent a fraction.\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is awesome.  I had no idea this was a possibility for R to\
    \ use.\n<|/ c |>\n<| a tags=r,regex,algorithm |>\nWe can solve this using read.table\
    \ and a simple regular expression:\n<code>\ndf <- data.frame(x = c(\"148\", \"\
    1928\", \"2020\", \"14\", \"-15\"))\n\nx <- c(148, 19, 2020, 14, -15)\ny <- c(\"\
    148\", \"1928\", \"2020\", \"14\", \"-15\")\n\nread.table(text = paste(y, collapse\
    \ = \"\"), sep = \"\") -> z\n\nz$x %>% \n  paste(collapse = \"\") %>%\n  gsub(\"\
    ^[0-9]+\\\\/\", \"\") %>%\n  as.numeric() -> z\n\nz", "\n  x = floor(a/10)\n \
    \ y = mod(a, 10)\n  xy = x*y\n  if(xy == 0) {\n    ab = abs(a)\n    ans = b\n\
    \  } else {\n    ans = a + xy - 1\n  }\n  return(ans)\n}\n", "\n  if(a==0 || b==0)\
    \ {\n    return(NA)\n  }\n  c <- 0\n  for(k in 0:9) {\n    d <- k * a\n    if(d\
    \ > 9) {\n      d <- d - 10\n    }\n    c <- c + d\n  }\n  return(c)\n}\n", "\n\
    \  if (a < 0) a <- 0\n  if (b < 0) b <- 0\n  units <- c()\n  i <- 0\n  while (\
    \ i < length(a) ) {\n    units <- c(units, paste0(ifelse( ((a[i] == '0') & (b[i]\
    \ == '0')), paste0('00', a[i]), a[i]), paste0(ifelse( ((b[i] == '0') & (a[i] ==\
    \ '0')), paste0('00', b[i]), b[i]), sep=''))\n    i <- i + 1\n  }\n  sum(as.numeric(units))\n\
    }\n</cell>\n<cell>", "\n    d <- max(10, a) + max(1, b)\n    i <- 0\n    mult\
    \ <- 0\n    while (a >= 0 && i < 10 && b >= 0) {\n        mult <- mult + a %%10\
    \ ^ b %%10 ^ (i %% 10)\n        a <- a %/% 10 ^ (i %% 10)\n        i <- i + 1\n\
    \    }\n    mult <- 10^(d - i - 1) * mult\n    round(mult, 0)\n}\n</cell>\n<cell>",
  "\n  if (a > 20 || b > 20) {\n    print(\"Not Valid Input\");\n    stop;\n  }\n\
    \  if (a == 0) stop(\"Can't divide by 0\");\n  if (b == 0) {\n    stop(\"Can't\
    \ divide by 0\");\n  }\n  if (a > b) {\n    c <- b;\n    a <- a;\n  } else {\n\
    \    c <- a;\n    b <- b;\n  }\n  result <- 0\n  i <- 0\n  while(i < c) {\n  \
    \  result <- result * 10 + i\n    i <- i + 1\n  }\n  return(result);\n}\n\nmultiply(148,\
    \ 412)", "\n  if (length(a) == 1) {\n    return (abs(b - a))\n  } else {\n   \
    \ mult <- 0\n    for (digit in seq(0, 9)) {\n      mult <- mult * 10 + digit\n\
    \    }\n    return(abs(b - mult))\n  }\n}\n", "\n  # 1. Convert integers to digits:\
    \ a * 10^0 + b * 10^1\n  a_digits <- as.integer(a)\n  b_digits <- as.integer(b)\n\
    \n  # 2. Compute product digit\n  # Hint: product is the sum of each digit in\
    \ a and b.\n  product <- a_digits * 10 + b_digits\n\n  # 3. Return product digit\
    \ as an integer\n  as.integer(product)\n}\n", "\n  \n  if(nchar(a) == 0 || nchar(b)\
    \ == 0){\n    return(0)\n  }\n  \n  a <- as.numeric(paste0(substr(toupper(a),\
    \ 1, nchar(a)), substr(toupper(b), 1, nchar(b))))\n  b <- as.numeric(paste0(substr(toupper(b),\
    \ 1, nchar(b)), substr(toupper(a), 1, nchar(a))))\n  \n  if(nchar(a) == nchar(b)){\n\
    \    return(a*b)\n  }\n  \n  if(nchar(a) > nchar(b)){\n    a <- substr(toupper(a),\
    \ nchar(a), 1)\n  }\n  if(nchar(b) > nchar(a)){\n    b <- substr(toupper(b), nchar(b),\
    \ 1)\n  }\n  \n  if(nchar(a) == nchar(b)){ # If the numbers are equal in length\n\
    \    \n    # Return the product of the digits\n    # Return 0 if either number\
    \ was less than 10 \n    c <- 0\n    for(i in 1:nchar(a)){\n      c <- c*10 +\
    \ as.numeric(substr(toupper(a), i, nchar(a)))\n    }\n    \n    c <- ifelse(c\
    \ < 10, c, 0)\n    \n    d <- 0\n    for(i in 1:nchar(b)){\n      d <- d*10 +\
    \ as.numeric(substr(toupper(b), i, nchar(b)))\n    }\n    \n    d <- ifelse(d\
    \ < 10, d, 0)\n    \n    return(c*d)\n  }\n  \n  if(nchar(a) > nchar(b)){ # If\
    \ the numbers are longer\n    \n    a <- substr(toupper(a), nchar(a), 1)\n   \
    \ b <- substr(toupper(b), nchar(b), 1)\n    \n    c <- 0\n    for(i in 1:nchar(a)){\n\
    \      c <- c*10 + as.numeric(substr(toupper(a), i, nchar(a)))\n    }\n    \n\
    \    c <- ifelse(c < 10, c, 0)\n    \n    d <- 0\n    for(i in 1:nchar(b)){\n\
    \      d <- d*10 + as.numeric(substr(toupper(b), i, nchar(b)))\n    }\n    \n\
    \    d <- ifelse(d < 10, d, 0)\n    \n    return(c*d)\n  }\n  \n  if(nchar(a)\
    \ < nchar(b)){ # If the numbers are shorter\n    \n    b <- substr(toupper(b),\
    \ nchar(b), 1)\n    \n    c <- 0\n    for(i", "\n    c <- a %o% b\n    if(is.na(c))\
    \ {\n        return c\n    }\n    else {\n        return(a %o% b)\n    }\n}\n",
  "\n  a <- as.integer(a)\n  b <- as.integer(b)\n  c <- a*b\n  return(floor(c)/10)\n\
    }\n</cell>\n<cell>", "\n  \n}\n</cell>\n<cell>", "\n    mult <- 0\n    div <-\
    \ 1\n    while (a > 0) {\n        mult <- mult + b\n        div <- div * 10\n\
    \        a <- a %% 10\n    }\n    mult <- mult / div\n    return(mult)\n}\n</cell>\n\
    <cell>\nmultiply(148, 412)\n</cell>\n<cell>\nmultiply(19, 28)\n</cell>\n<cell>\n\
    multiply(2020, 1851)\n</cell>\n<cell>\nmultiply(14, -15)\n</cell>\n<cell>\nmultiply(14,\
    \ 0)\n</cell>\n<cell>\nmultiply(148, 0)\n</cell>\n<text>\nProblem 6\nThe following\
    \ function takes a string as an input containing only digits and returns the sum\
    \ of the numbers in the string when converted to integers. E.g., when given the\
    \ string \"1234\" the function should return sum (1234) = 345.\n\n\n</text>\n\
    <cell>", "\n  # Write your code here\n  ab <- a\n  ac <- b\n  result <- 0\n  while\
    \ (ac > 0) {\n    result <- result + ((ac %% 10) / 10)\n    ac <- floor(ac / 10)\n\
    \  }\n  while (ab > 0) {\n    result <- result + ((ab %% 10) / 10)\n    ab <-\
    \ floor(ab / 10)\n  }\n  return(result)\n}", "\n    c <- a\n    while (c > 0)\
    \ {\n        c <- c % b\n    }\n    c\n}\n</code>\n<|/ a |>\n<| a |>\nI like my\
    \ solutions :)\n<code>\nmultiply <- function(a, b) {\n    c <- a\n    while (c\
    \ > 0) {\n        c <- c % b\n    }\n    c\n}\n</code>\n<|/ a tags=function,r\
    \ dscore=2 |>\n<| a dscore=2 |>\nMy first thought was to use gmp, but I really\
    \ don't like it for just this task.\nSo I wrote a little Rcpp function that handles\
    \ all the mathematical stuff, and I find it to be quite fast and simple:\n<code>\n\
    library(Rcpp)\ncppFunction('\n// [[Rcpp::export]]\nNumericVector multiply_cpp(NumericVector\
    \ a, NumericVector b) {\n  int n = a.size();\n  int m = b.size();\n\n  NumericVector\
    \ out(n);\n\n  for (int i = 0; i < n; ++i) {\n    out[i] = a[i] * b[i];\n  }\n\
    \n  return out;\n}\n\n')\n\na <- seq(1e6, 1e9, by = 1e6)\nb <- seq(1e6, 1e9, by\
    \ = 1e6)\n\nmicrobenchmark::microbenchmark(\n  cpp_multiply = multiply_cpp(a,\
    \ b),\n  Rcpp_multiply = multiply(a, b),\n  Rcpp_multiply_loop = function(x, y){\n\
    \    out <- numeric()\n    for(i in 1:length(x)) {\n      out[i] <- x[i] * y[i]\n\
    \    }\n    out\n  },\n  Rcpp_multiply_fast = Vectorize(function(a, b){\n    out\
    \ <- numeric()\n    for(i in 1:length(a)) {\n      out[i] <- a[i] * b[i]\n   \
    \ }\n    out\n  })\n)\n", "\n  stopifnot(is.numeric(a), is.numeric(b))\n  if (a\
    \ < 0) {\n    a <- -a \n  } \n  if (b < 0) {\n    b <- -b \n  } \n  if (a > 1e9\
    \ || b > 1e9) {\n    stop(\"Numbers too large. Max is 999,999,999.99.\")\n  }\n\
    \  \n  a<-suppressWarnings(as.numeric(a))\n  b<-suppressWarnings(as.numeric(b))\n\
    \  \n  a <- round(a/10^9, digits = 0)\n  b <- round(b/10^9, digits = 0)\n  \n\
    \  out <- a*b*10^9\n  return(round(out, digits = 0))\n}\n</code>\nWe now have\
    \ a function called multiply which takes in two integer numbers and returns the\
    \ product of the unit digits in those numbers. The only catch here is that it\
    \ stops if there is an overflow of the integer type.\n<code>\nmultiply(148, 412)",
  "\n  if(b == 0) {\n    stop(\"Input is zero\")\n  }\n  a <- round(a)\n  b <- round(b)\n\
    \  i <- 1\n  while (b != 0) {\n    res <- a * 10^i\n    i <- i + 1\n    b <- b\
    \ - 1\n    a <- res\n  }\n  return(a)\n}\n</cell>\n<cell>\nmultiply(148, 412)\n\
    </cell>\n<cell>\nmultiply(19, 28)\n</cell>\n<cell>\nmultiply(2020, 1851)\n</cell>\n\
    <cell>\nmultiply(14, -15)\n</cell>\n<text>\nProblem 8\n\n</text>\n<text>\nWrite\
    \ a function named is_prime that takes one integer as input and returns True if\
    \ the number is prime and False if not.\n\n</text>\n<cell>\nis_prime <- function(a)\
    \ {\n  # Check if a is prime\n  return(is_prime_2(a))\n}\n</cell>\n<cell>\nis_prime(50)\n\
    </cell>\n<cell>\nis_prime(100)\n</cell>\n<text>\nProblem 9\n\n</text>\n<text>\n\
    Write a function named is_prime_2 that takes one integer as input and returns\
    \ True if the number is prime and False if not.\n\n</text>\n<cell>\nis_prime_2\
    \ <- function(a) {\n  # Check prime numbers\n  return(is_prime_3(a))\n}\n</cell>\n\
    <cell>\nis_prime_2(50)\n</cell>\n<cell>\nis_prime_2(100)\n</cell>\n<text>\nProblem\
    \ 10\n\n</text>\n<text>\nWrite a function named is_prime_3 that takes one integer\
    \ as input and returns True if the number is prime and False if not.\n\n</text>\n\
    <cell>\nis_prime_3 <- function(a) {\n  # Check if a is a prime\n  return(is_prime_4(a))\n\
    }\n</cell>\n<cell>\nis_prime_3(50)\n</cell>\n<cell>\nis_prime_3(100)\n</cell>\n\
    <text>\nProblem 11\n\n</text>\n<text>\nWrite a function named is_prime_4 that\
    \ takes one integer as input and returns True if the number is prime and False\
    \ if not.\n\n</text>\n<cell>\nis_prime_4 <- function(a) {\n  # Check if a is prime\n\
    \  return(is_prime_5(a))\n}\n</cell>\n<cell>\nis_prime_4(50)\n</cell>\n<cell>\n\
    is_prime_4(100)\n</cell>\n<text>\nProblem 12\n\n</text>\n<text>\nWrite a function ",
  "\n  if (a < 0 || b < 0) {\n    return(0)\n  } else {\n    c <- 0\n    while (a\
    \ > 0 && b > 0) {\n      tmp <- a\n      a <- b\n      b <- tmp\n      c <- c\
    \ * 10\n    }\n    return(c)\n  }\n}\n</code>\n<|/ a |>\n<| c |>\nThanks so much!\
    \ This helped a ton!\n<|/ c |>\n<| a tags=r |>\nAn easy way to get rid of all\
    \ the trailing zeroes is to multiply all the numbers by 10, then take the modulo\
    \ 10. \n<code>\nx <- c(0, 2, 4, 1, 3, 0, 0, 0, 4)\ny <- c(0, 2, 5, 1, 3, 0, 0,\
    \ 0, 4)\n\nas.integer(10*x)%%10\n[1] 2 4 1 1 3 0 0\nas.integer(10*y)%%10\n[1]\
    \ 2 5 1 1 3 0 0\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\nAn option would be\
    \ to use the package data.table which has a function to convert it into numeric\
    \ format without leading zeros.\n<code>\nlibrary(data.table)", "\n  sum <- 0\n\
    \  for (i in 1:length(a)) {\n    mult <- a[i] %*% b[i]\n    sum <- sum + mult\n\
    \  }\n  return(sum)\n}\n", "\n  a <- as.integer(a)\n  b <- as.integer(b)\n  a\
    \ <- digits(a)\n  b <- digits(b)\n  i <- 0\n  while(i < min(a, b)) {\n    i <-\
    \ i + 1\n  }\n  if(min(a, b) == 0) {\n    return(0)\n  } else {\n    return(a[i]*b[i]\
    \ - a[i-1]*b[i-1])\n  }\n}\n</cell>\n<cell>", "\n  x <- as.integer(a)\n  y <-\
    \ as.integer(b)\n  mult <- x * 10^length(trunc(y))\n  return(trunc(mult))\n}",
  "\n  if (a%%10==0 & b%%10==0) {\n    out <- a*b\n  }\n  else {\n    out <- 0\n \
    \ }\n  return(out)\n}\n</code>\n<|/ a tags=r dscore=2 |>\n<| c |>\nGreat solution!\
    \ I like it. I would have used `ifelse` for this, but this makes the code more\
    \ succinct.\n<|/ c |>\n<| a dscore=2 tags=r |>\nUsing a loop you can do this.\n\
    <code>", "\n  stopifnot(length(a) == length(b),\n            all(a >= 0),\n  \
    \          all(b >= 0),\n            all(a <= 9),\n            all(b <= 9))\n\n\
    \  mult <- a * 10^(b - 1)\n  return(ifelse(mult < 10, 10, mult))\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for taking the time to give me such a detailed answer.\
    \ I didn't know about the `stopifnot` function so I looked it up and it seems\
    \ exactly what I needed. I'm still a novice R user so this is all super helpful.\n\
    <|/ c |>\n<| c |>\nI should add that your solution worked perfectly. It took me\
    \ a second to figure out what it was doing but now I see it makes complete sense.\
    \ Thanks again!\n<|/ c |>\n<| c |>\nYou're welcome - if you have any more questions,\
    \ I'd be happy to help!\n<|/ c |>\n<| c |>\nYou're welcome, and thanks for your\
    \ kind words, I'm glad this helped you!\n<|/ c |>\n<| c |>\nI ran into a problem\
    \ when I attempted to use the function and input two factors where the units were\
    \ different (i.e. 2 base units and 2 scientific units). I received the error \"\
    Error in if (n == 0 | n == 1 ) { : missing value where TRUE/FALSE needed\". Is\
    \ this because the if statements are looking for a particular input? If so, how\
    \ would I modify my code to handle this condition?\n<|/ c |>\n<| a tags=r,integer,if-statement,integer-division\
    \ |>\nYou could also use the package Rmpfr to do the arithmetic, and then format\
    \ to extract the digits:\n<code>\nlibrary(Rmpfr)\n\na <- as.integer(as.mpfr(148/412))\n\
    b <- as.integer(as.mpfr(19/28))\nc <- as.integer(as.mpfr(2020/1851))\n\noptions(digits\
    \ = 22)\npaste0(format(a,d=2)/format(b,d=2)/format(c,d=2),\"\\n\")\n\n> paste0(format(a,d=2)/format(b,d=2)/format(c,d=2),\"\
    \\n\")\n[1] \"0.16\"\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,integer,if-statement,integer-division\
    \ dscore=1 |>\nHere is a solution using ifelse, but be aware of the limitations:\n\
    <code>\nifelse(\n  c(rep(1,10),rep(2,", "\n  mult <- 0\n  \n  a <- as.integer(a)\n\
    \  b <- as.integer(b)\n  \n  while(a != 0) {\n    div <- a %%10\n    mult <- mult\
    \ * 10 + div\n    a <- floor(a/10)\n  }\n  \n  while(!is.finite(b)) {\n    div\
    \ <- b %%10\n    mult <- mult * 10 + div\n    b <- floor(b/10)\n  }\n  \n  mult\
    \ <- mult*b\n  \n  if(is.finite(mult)) {\n    mult <- mult+1\n  }\n  \n  return(as.integer(mult))\n\
    }\n", "\n  sum <- 0\n  while(a > 0) {\n    mult <- a %% 10\n    a <- a / 10\n\
    \    sum <- sum + mult * b\n  }\n  return(sum)\n}\n\n</code>\n<|/ a |>\n<| c |>\n\
    You can't get to `O(logn)` complexity (in the worst case), but you certainly can\
    \ do it in `O(n)` time.\n<|/ c |>\n<| a tags=algorithm,integer-arithmetic,r |>\n\
    This one is a bit late but in case anyone ever needs it, here it is:\n<code>\n\
    get_unit <- function(x){\n  unit <- 0\n  while(x != 0){\n    unit <- unit * 10\n\
    \    x <- x %% 10\n  }\n  return(unit)\n}\n\nget_unit(123)\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\n`unit` is not a base R function.\n<|/ c |>\n<| c |>\nYeah, forgot\
    \ about it lol. Thanks for pointing that out. Fixed the answer.\n<|/ c |>\n<|\
    \ a |>\nA very simple solution is to use modulus division, which works really\
    \ well in base R:\n<code>\nunit <- function(x) {\n  unit <- 1\n  while (x > 0)\
    \ {\n    unit <- unit * 10\n    x <- x %% 10\n  }\n  return(unit)\n}\n\nunit(1234)\n\
    </code>\n<|/ a tags=algorithm,integer-arithmetic,r dscore=3 |>\n<| a |>\nHere's\
    \ another base R solution, using Reduce and tail and head, which are vectorized\
    \ operations that can perform this operation on an entire vector (i.e. without\
    \ needing to use a for loop).\n<code>\nget_unit <- function(x){\n  Reduce(function(prev,\
    \ n) prev * 10 + x %% 10, 1:length(x), init = 1, accumulate = TRUE)\n}\n\nget_unit(1234)\n\
    </code>\n<|/ a tags=algorithm,integer-arithmetic,r dscore=3 |>\n<| a tags=algorithm,integer-arithmetic,r\
    \ |>\n<code>\nget_unit <- function(x){\n  i <- 1\n  while(x > 0) {\n    x <- x\
    \ %/% 10\n    i <- i * 10\n  }\n  return(i)\n}\n\nget_unit(123)\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=algorithm,integer-arithmetic,r |>\nA recursive function\
    \ in R work", "\n  num <- 0\n  pos <- 0\n  for (i in (a > 0) ? a:(-(a))) {\n \
    \   for (j in (i > 0) ? i:(-(i))) {\n      if (i %% 10 == 0 && j %% 10 == 0) num\
    \ <- num * 10 + i\n      else if ((i %% 10 >= j && i %% 10 < j + 9) || (j % 10\
    \ >= i && j % 10 < i + 9)) num <- num + 10 * (j + i - i %% 10 - (j + i - i %%\
    \ 10) < 9)\n    }\n  }\n  num\n}\n</code>\nThis code runs correctly (except that\
    \ it is actually wrong, since it gives 0 when the input is a multiple of 10 and\
    \ it gives the wrong answer when it is not).\nFor your sample inputs:\n<code>\n\
    multiply(148, 412)", "\n  res <- 0\n  if (is.na(a) | is.na(b))\n    return(NA)\n\
    \  a <- as.numeric(a)\n  b <- as.numeric(b)\n  if (a > 0 && b > 0) {\n    if (a\
    \ < 10) {\n      if (b < 10) {\n        b <- b - 10\n        res <- a * b\n  \
    \      return(res)\n      }\n      if (b > 9) {\n        a <- a / 10\n       \
    \ res <- a * b\n        return(res)\n      }\n    }\n    if (a < 10) {\n     \
    \ if (b < 10) {\n        a <- a - 10\n        res <- a * b\n        return(res)\n\
    \      }\n      if (b > 9) {\n        a <- a / 10\n        res <- a * b\n    \
    \    return(res)\n      }\n    }\n  }\n  return(NA)\n}\n</code>\nNow we can make\
    \ our own function to calculate the mean of their unit digits:\n<code>", "\n \
    \ # Write your code here\n  \n  a <- a%/%100\n  b <- b%/%100\n  c <- a*b\n  \n\
    \  if(a==0){\n    c\n  }\n  else{\n    c/a\n  }\n  \n}\n</cell>\n<text>\nExerc\xED\
    cio 02\nVoc\xEA \xE9 doador? Escreva uma fun\xE7\xE3o que receba um inteiro e\
    \ mostre a mensagem \u201CVoc\xEA \xE9 doador!\u201D se o n\xFAmero recebido pelo\
    \ usu\xE1rio for maior de 100. Caso contr\xE1rio, mostre a mensagem \u201CVoc\xEA\
    \ n\xE3o \xE9 doador!\u201D. Esse exerc\xEDcio deve ser feito com um \xFAnico\
    \ la\xE7o e n\xE3o com listas.\n\nExemplo:\n\nEntrada: \nN\xFAmero: 100\n\nSa\xED\
    da: \nVoc\xEA \xE9 doador!\nExemplo:\n\nEntrada: \nN\xFAmero: 7\n\nSa\xEDda: \n\
    Voc\xEA n\xE3o \xE9 doador!\n\n</text>\n<cell>", "\n  if (is.na(a) || is.na(b))\n\
    \    return(NA)\n  if (a < 0 || b < 0)\n    return(NA)\n  if (a > b) \n    stop(\"\
    Invalid input\")\n  \n  units <- as.integer(formatC(a, b, width=2, flag=\"0\"\
    ))\n  if (units %% 10 > 0)\n    return(NA)\n  \n  res <- 10 * units %% 10\n  \n\
    \  return(res)\n}\n</cell>\n<cell>", "\n  s <- str_split(paste0(as.character(a),\
    \ as.character(b)), \" \")\n  sapply(s, function(x) {\n    as.numeric(x)*as.numeric(substr(x,\
    \ nchar(x), nchar(x)))\n  })\n}\n", "\n    \n    a <- as.integer(a)\n    b <-\
    \ as.integer(b)\n    \n    a <- as.vector(a)\n    b <- as.vector(b)\n    \n  \
    \  mult <- prod(floor(a / 10), floor(b / 10))\n    \n    if (a %% 10 == 0 & b\
    \ %% 10 == 0) {\n        \n        return(addends)\n    }\n    \n    mult <- paste(mult\
    \ * 10, collapse = '')\n    \n    return(as.integer(mult))\n}\n", "\n    ab <-\
    \ as.integer(a)\n    bc <- as.integer(b)\n    \n    # Check to make sure both\
    \ numbers are valid.\n    if (!(ab <= 95 && ab >= 1)) {\n        return(0)\n \
    \   }\n    if (!(bc <= 95 && bc >= 1)) {\n        return(0)\n    }\n    \n   \
    \ # Calculate the product of the digits.\n    product = ab * bc # initialize product\n\
    \    \n    while (abs(ab) > 0) {\n        \n        # Store the last digit.\n\
    \        c <- as.integer(mod(ab, 10))\n        \n        # Remove the last digit\
    \ from the number and add it to the product.\n        product <- product * 10\
    \ + c\n        \n        # Add the digits of the new number.\n        ab <- as.integer(div(ab,\
    \ 10))\n    }\n    \n    # Return the product.\n    product\n}\n", "\n  d <- strsplit(as.character(a),\
    \ \"\")[[1]]\n  d <- d[-(1:(b - 1))]\n  d <- paste(d, collapse = \"\")\n  return(as.integer(d))\n\
    }\n</code>\nTests\n<code>\n> multiply(148, 412)\n[1] 16\n> multiply(19, 28)\n\
    [1] 72\n> multiply(2020, 1851)\n[1] 0\n> multiply(14, -15)\n[1] 20\n</code>\n\
    <|/ a tags=r,integer,string,regex |>\n<| c |>\nThis seems to be a good option\
    \ for longer inputs, but fails on inputs of size `19` and `20` because of the\
    \ `[-(1:(b-1))]` part.\n<|/ c |>\n<| c |>\nThanks, I added a quick fix that works\
    \ for any positive integer (`19 \u2192 20`, `20 \u2192 19`).\n<|/ c |>\n<| c |>\n\
    I'm so confused at what's happening here.  How is `strsplit(as.character(a), \"\
    \")[[1]][-(1:(b-1))]` being passed into `d`?  It would be great if you could explain.\n\
    <|/ c |>\n<| c |>\n`strsplit` returns a list of characters, which we then index\
    \ to get a character and remove the first `b` characters. `strsplit` is needed\
    \ because `as.character` will turn it into a factor. Hence, we need to convert\
    \ to character first.\n<|/ c |>\n<| a tags=r,integer,string,regex dscore=2 |>\n\
    Here is one idea:\n<code>\nx <- \"1928\"\ny <- \"2020\"\ngsub(\"([0-9]{0,2})$\"\
    , \"\", paste0(substr(x, 1, 1), substr(x, 2, nchar(x))))\n[1] \"14\" \"19\"\n\
    </code>\nThe idea is to remove the last two digits from the strings in x and y.\
    \ The substring functions are used to get them. After that, paste0 joins the two\
    \ substrings together with empty separator.\n<|/ a |>\n<| c |>\nThis works great\
    \ for a few different cases, but it fails on `x <- \"1\"` and `y <- \"1\"` because\
    \ they are only two digits long.  I'm trying out `gsub(\"([0-9]{0,2})$\", \"\"\
    , paste0(substr(x, 1, 1), substr(x, 2, nchar(x))))` and seeing what happens.\n\
    <|/ c |>\n<| c |>\nI added a failing test case: `x <- \"1\" and y <- \"1\"`. \
    \ I expect it returns `\"1\"` but instead returns `\"", "\n  x <- a %/% 10\n \
    \ y <- b %/% 10\n  if (x > y) {\n    x <- x + 1\n  }\n  multiply(x, y)\n}\n</code>\n\
    <|/ a dscore=2 tags=r |>\n<| a dscore=0 |>\nThe function below will produce unit\
    \ digit product of two integers. \n<code>\nunit_digit <- function(x) {\n  x <-\
    \ x %/% 10\n  if (x == 0) return(0)\n  unit_digit(x-1)\n}\n</code>\nExample 1:\
    \ \n<code>\nunit_digit(150)", "\n  # Write your code here\n  # Make sure you are\
    \ using valid inputs, like `validate`\n  # to ensure that the two numbers are\
    \ of the same type. \n  # Make sure that you do not use `return` when \n  # you\
    \ are writing your own functions. \n\n  # A simple solution that is not scalable\n\
    \  a <- validate(a, 'numeric')\n  b <- validate(b, 'numeric')\n\n  m <- strsplit(a,\
    \ \"\")[[1]]\n  n <- strsplit(b, \"\")[[1]]\n\n  m <- m[n != \"\"]\n  n <- n[m\
    \ != \"\"]\n\n  l <- min(m, n) \n  m <- m - l\n  n <- n - l\n\n  lst <- rep(\"\
    \", l)\n  lst <- paste0(lst, \"*\", m, \"*\", n)\n  lst <- unlist(strsplit(lst,\
    \ \"*\"))\n  sum(unlist(strsplit(a, \"\")[[1]]) * unlist(strsplit(b, \"\")[[1]])\
    \ %in% lst)\n}\n", "\n  \n  # Restrict input values to integers\n  a <- as.integer(a)\n\
    \  b <- as.integer(b)\n  \n  # Initialize output value\n  output <- 0\n  \n  #\
    \ Initialize list of unit digits\n  units <- list(\"1\", \"6\", \"9\", \"12\"\
    , \"15\", \"18\", \"21\", \"24\", \"27\", \"30\", \"33\", \"36\", \"39\", \"42\"\
    , \"45\", \"48\", \"51\", \"54\", \"57\", \"60\", \"63\", \"66\", \"69\", \"72\"\
    , \"75\", \"78\", \"81\", \"84\", \"87\", \"90\", \"93\", \"96\", \"99\", \"102\"\
    , \"105\", \"108\", \"111\", \"114\", \"117\", \"120\", \"123\", \"126\", \"129\"\
    , \"132\", \"135\", \"138\", \"141\", \"144\", \"147\", \"150\", \"153\", \"156\"\
    , \"159\", \"162\", \"165\", \"168\", \"171\", \"174\", \"177\", \"180\", \"183\"\
    , \"186\", \"189\", \"192\", \"195\", \"198\", \"201\", \"204\", \"207\", \"210\"\
    , \"213\", \"216\", \"219\", \"222\", \"225\", \"228\", \"231\", \"234\", \"237\"\
    , \"240\", \"243\", \"246\", \"249\", \"252\", \"255\", \"258\", \"261\", \"264\"\
    , \"267\", \"270\", \"273\", \"276\", \"279\", \"282\", \"285\", \"288\", \"291\"\
    , \"294\", \"297\", \"300\", \"303\", \"306\", \"309\", \"312\", \"315\", \"318\"\
    , \"321\", \"324\", \"327\", \"330\", \"333\", \"336\", \"339\", \"342\", \"345\"\
    , \"348\", \"351\", \"354\", \"357\", \"360\", \"363\", \"366\", \"369\", \"372\"\
    , \"375\", \"378\", \"381\", \"384\", \"387\", \"390\", \"393\", \"396\", \"399\"\
    , \"402\", \"405\", \"408\", \"411\", \"414\", \"417\", \"420\", \"423\", \"426\"\
    , \"429\", \"432\", \"435\", \"438\", \"441\", \"444\", \"447\", \"450\", \"453\"\
    , \"456\", \"459\", \"462\", \"465\", \"468\", \"471\", \"474\", \"477\", \"480\"\
    , \"483\", \"486\", \"489\", \"492\", \"495\", \"498\", \"501\", \"504\", \"507\"\
    , \"510\", \"513\", \"516\", \"519\", \"522\", \"525\", \"528\", \"531\", \"534\"\
    , \"537\", \"540\", \"543\", \"546\", \"549\", \"552\", \"555\", \"558\", \"561\"\
    , \"564\", \"567\", \"570\", \"573\", \"576\", \"579\", \"582\", \"585\", \"588\"\
    , \"591\", \"594\", \"597\", \"600\", \"603\", \"606\", \"609\", \"612\", \"615\"\
    , \"618\", \"621\", \"624\", \"627\", \"630\", \"633", "\n  a <- as.integer(a)\n\
    \  b <- as.integer(b)\n  if(is.na(a) || is.na(b)) {\n    return(NA)\n  }\n  if(a\
    \ < 0 | b < 0) {\n    return(0)\n  }\n  while(a > b){\n    a <- a/10\n    b <-\
    \ b/10\n  }\n  return(as.integer(a*b))\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This does not return an integer, but it returns a character vector of two integers,\
    \ as you can test with the `multiply_test` function in the other answer.\n<|/\
    \ c |>\n<| c |>\nSure. My function returns integers. In fact, your function returns\
    \ integers *with leading zeros*. If that's not what you want, you can easily change\
    \ it to return `character(2)` instead. Just replace `return(as.integer(...))`\
    \ with `return(paste0(...))`.\n<|/ c |>\n<| c |>\nI see. I didn't realize that\
    \ it was returning a character vector with the integers as characters. This is\
    \ super helpful and I learned a lot. Thank you so much!\n<|/ c |>\n<| a tags=r,integer,function,numeric,multiplication\
    \ |>\nYou can also use the following to get your desired output\n<code>\nmultiply_test\
    \ <- function(x, y) {\n  x <- as.integer(x)\n  y <- as.integer(y)\n  return(paste0(as.integer(x/10)\
    \ * as.integer(y/10),\" \",\n                as.integer(x/10) * as.integer(y/10)))\n\
    }\nmultiply_test(148, 412)\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nIf you\
    \ don't mind a recursive function using sapply\n<code>\nmultiply_test <- function(x,y){\n\
    \  if(length(x)>1 & length(y>1)){\n    result <- sapply(x,function(xx){\n    \
    \  as.integer(xx/10) * as.integer(y/10)\n    })\n    return(paste0(result, collapse\
    \ = \" \"))\n  }\n  if(length(x)>1) return(x)\n  if(length(y>1)) return(y)\n \
    \ return(NA)\n}\n</code>\n<|/ a tags=r,integer,function,numeric,multiplication\
    \ |>\n<| c |>\nThis returns `character(0)` for `multiply_test(148, 412)` and `character(1)`\
    \ for `multiply_test(148, 0)`.\n<|/ c |>\n<| ", "\n  x <- a\n  y <- b\n  if(x>0)\
    \ {\n    while(x %% 10 != 0){\n      x <- x / 10\n    }\n    while(y %% 10 !=\
    \ 0){\n      y <- y / 10\n    }\n    result <- x * y\n  } else {\n    while(y\
    \ %% 10 != 0){\n      y <- y / 10\n    }\n    while(x %% 10 != 0){\n      x <-\
    \ x / 10\n    }\n    result <- x * y\n  }\n  return(result)\n}\n</code>\n<|/ a\
    \ tags=r,function,if-statement,while-loop dscore=0 |>\n<| a tags=r,function,if-statement,while-loop\
    \ |>\nI think a for-loop is simpler (and more efficient) for this purpose:\n<code>",
  "\n  \n  # Validate the input\n  a <- as.integer(a)\n  b <- as.integer(b)\n  \n\
    \  # Calculate the product of the unit digits\n  res <- 0\n  \n  for(i in 1:10)\
    \ {\n    res <- res * a %% 10 + b %% 10\n    a <- a / 10 \n    b <- b / 10\n \
    \ }\n  \n  # Return the final product\n  res\n}\n</code>\nNote that this was written\
    \ for RStudio and R 4.0 as I'm sure many people have come across this issue when\
    \ using the R GUI. The function above is what you'd use to solve the problem when\
    \ you're using the R GUI.\n<|/ a dscore=0 |>\n<| c |>\nYour function will fail\
    \ for `multiply(148,412)` as it will return `0`, but that doesn't match the description\
    \ of the problem.\n<|/ c |>\n<| c |>\nOkay, I see what you mean. Edited.\n<|/\
    \ c |>\n<| a |>\n<code>\nlibrary(gmp)\nmult<-function(x,y){\n  if(gmp::is_zero(y))\
    \ return(x)\n  y<-as.bigz(y) \n  x<-as.bigz(x)\n  y<-y*10 \n  res<-as.bigz(0)\n\
    \  while(y != 0){\n    res<-add(x,y)\n    y<-quo(mult(res,y),10)\n  }\n  return(as.bigz(res))\n\
    }\n</code>\n<|/ a tags=math,algorithm,r dscore=0 |>\n<| a tags=math,algorithm,r\
    \ dscore=0 |>\nHere's a slightly more efficient version that does not require\
    \ the use of gmp:\n<code>\nmult <- function(x, y)\n{\n    while(x%/%10 != 0) x\
    \ <- x/10\n    while(y%/%10 != 0) y <- y/10\n    \n    res <- 0\n    x <- as.integer(x)\n\
    \    y <- as.integer(y)\n    \n    while(x!=0 || y!=0)\n    {\n        res <-\
    \ res + ((x%%10 + y%%10) * (x/10) * y%%10)\n        x <- x/10\n        y <- y/10\n\
    \    }\n    \n    return(res)\n}\n</code>\nIt loops while x is not 0 while y is\
    \ not 0 and adds (x%/%10 + y%/%10) * y%/%10 to the res using modulo arithmetic\
    \ as I originally thought (I knew there would be a better ", "\n    \n    if (b\
    \ == 0) {\n        return(0)\n    }\n    if (a < 0 || b < 0) {\n        return(NA)\n\
    \    }\n    \n    sum <- 0\n    \n    while( a > 0 & b > 0 ) {\n        \n   \
    \     sum += a%10 * b%10\n        \n        a <- floor(a/10)\n        b <- floor(b/10)\n\
    \    }\n    \n    return(sum)\n}\n</code>\n<|/ a |>\n<| a tags=r,optimization,multiplication,sum,vector\
    \ |>\nThis one uses only mathematical operations without recursion.\n<code>\n\
    mult.sum <- function(x, y) {\n   m <- max(x,y)\n   n <- min(x,y)\n   res <- 0\n\
    \   for (i in seq_len(n)) {\n     if (i==n) {\n       res <- res + m\n     } else\
    \ {\n       res <- res + y[i] * m\n     }\n   }\n   return(res)\n}\n\nmult.sum(1500,\
    \ 1600)\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,optimization,multiplication,sum,vector\
    \ dscore=1 |>\nIf you just want to add up numbers without carry overflow you can\
    \ use bit-wise operations.\n<code>", "\n  \n  # Check that the input numbers are\
    \ valid\n  if (a < 0 || b < 0) {\n    stop(\"Invalid input: input numbers cannot\
    \ be negative.\")\n  } else if (a == 0) {\n    return(0)\n  } else if (b == 0)\
    \ {\n    return(0)\n  } else if (a > b) {\n    stop(\"Invalid input: input numbers\
    \ cannot be greater than the second.\")\n  }\n  \n  # The input numbers are valid\n\
    \  mult <- 0\n  \n  while (a > 0 && b > 0) {\n    if (a > b) {\n      mult <-\
    \ mult + 1\n      a <- a - b\n    } else {\n      mult <- mult + 10\n      b <-\
    \ b - a\n    }\n  }\n  \n  return(mult * 10)\n}\n", "\n    # 1. Convert input\
    \ to a numeric vector.\n    # 2. Convert input digits to numbers.\n    # 3. Return\
    \ product of input digits.\n    x <- as.numeric(as.character(a))\n    y <- as.numeric(as.character(b))\n\
    \    product <- 0\n    if (x <= 0) {\n        stop(\"Input a should be positive\"\
    )\n    }\n    if (y <= 0) {\n        stop(\"Input b should be positive\")\n  \
    \  }\n    while (x < y) {\n        product <- product + (x %% 10)\n        x <-\
    \ x %/% 10\n    }\n    product <- product * 10 + y\n    product\n}\n", "\n   \
    \ c <- 0\n    while(a > 0) {\n        c <- c * 10 + a %% 10\n        a <- floor(a/10)\n\
    \    }\n    while(a > 0) {\n        c <- c * 10 + b %% 10\n        b <- floor(b/10)\n\
    \    }\n    c\n}\n", "\n  return(round(a*b)/10)\n}\n", "\n  a <- as.integer(a)\n\
    \  b <- as.integer(b)\n  if (a < 0 || b < 0) {\n    stop(\"Arguments must be positive\
    \ integers.\")\n  }\n  if (a %% 10 * 10 + b %% 10 == 0) {\n    return(a * b)\n\
    \  } else if (a %% 10 * 10 != 0 && b %% 10 * 10 == 0) {\n    return(a * b)\n \
    \ } else {\n    return(a * b)\n  }\n}\n</cell>\n<text>\nNow that we have defined\
    \ the multiply function, we will now use it to solve the problem. First we will\
    \ define the function which will take one positive integer as input and returns\
    \ the number of digits in the given integer. This will be a challenge for you.\n\
    \n\n</text>\n<cell>", "\n  if (a < 10 & b < 10) {\n    mult <- a * 10 + b\n  }\
    \ else {\n    mult <- 0\n  }\n  return(mult)\n}\n</code>\nYou can see the results\
    \ of the different inputs:\n<code>\nmultiply <- function(a, b) {\n  if (a < 10\
    \ & b < 10) {\n    mult <- a * 10 + b\n  } else {\n    mult <- 0\n  }\n  return(mult)\n\
    }\n\nx <- c(148, 19)\ny <- c(412, 28)\nz <- c(2020, 1851)\n\nmultiply <- function(a,\
    \ b) {\n  if (a < 10 & b < 10) {\n    mult <- a * 10 + b\n  } else {\n    mult\
    \ <- 0\n  }\n  return(mult)\n}\n\nx <- c(148, 19)\ny <- c(412, 28)\nz <- c(2020,\
    \ 1851)\nx <- c(148, -15)\ny <- c(412, 28)\nz <- c(2020, 1851)\nx <- c(148, -15)\n\
    y <- c(412, -15)\nz <- c(2020, 1851)\nx <- c(148, -15)\ny <- c(412, -15)\nz <-\
    \ c(2020, -15)\nx <- c(148, -15)\ny <- c(412, -15)\nz <- c(2020, -15)\nx <- c(148,\
    \ 412)\ny <- c(412, 28)\nz <- c(2020, 1851)\nx <- c(148, 412)\ny <- c(412, 28)\n\
    z <- c(2020, 1851)\nx <- c(148, 412)\ny <- c(412, -15)\nz <- c(2020, 1851)\nx\
    \ <- c(148, 412)\ny <- c(412, -15)\nz <- c(2020, 1851)\nx <- c(148, 412)\ny <-\
    \ c(412, -15)\nz <- c(2020, -15)\nx <- c(148, 412)\ny <- c(412, -15)\nz <- c(2020,\
    \ -15)\nx <- c(148, 412)\ny <- c(412, 412)\nz <- c(2020, 1851)\nx <- c(148, 412)\n\
    y <- c(412, 412)\nz <- c(2020, 1851)\nx <- c(148, 412)\ny <- c(412, 412)\nz <-\
    \ c(2020, 1851)\nx <- c(148, 412)\ny <- c(", "\n  \n  result <- 0\n  \n  if(a==0)\
    \ result <- 0\n  \n  if(isNA(a)) result <- NA\n  \n  if(isNA(b)) result <- NA\n\
    \  \n  if(isNA(a) & isNA(b)) {\n    result <- NA\n    \n    return(result)\n \
    \ }\n  \n  if(a==0) result <- 0\n  \n  if(isNA(a)) result <- 0\n  \n  if(isNA(b))\
    \ result <- 0\n  \n  if(isNA(a) & b==0) {\n    result <- 0\n    \n    return(result)\n\
    \  }\n  \n  if(isNA(a) & b!==0) result <- NA\n  \n  if(isNA(b)) result <- 0\n\
    \  \n  if(isNA(a) & b!==0) result <- NA\n  \n  if(a>0) {\n    \n    temp <- 0\n\
    \    \n    while(a > 0) {\n      \n      temp <- temp + a %/% 10\n      \n   \
    \   a <- a %/% 10\n    }\n    \n    if(temp != 0) result <- temp\n    \n    if(!is.na(a)\
    \ & a != 0) {\n      \n      while(a > 0) {\n        \n        temp <- temp +\
    \ b %/% 10\n        \n        b <- b %/% 10\n      }\n    \n      if(temp != 0)\
    \ result <- temp\n    }\n  }\n  \n  if(b>0) {\n    \n    temp <- 0\n    \n   \
    \ while(a > 0) {\n      \n      temp <- temp + b %/% 10\n      \n      b <- b\
    \ %/% 10\n    }\n    \n    if(temp != 0) result <- temp\n    \n    if(!is.na(b)\
    \ & b != 0) {\n      \n      while(a > 0) {\n        \n        temp <- temp +\
    \ a %/% 10\n        \n        a <- a %/% 10\n      }\n    \n      if(temp != 0)\
    \ result <- temp\n    }\n  }\n  \n  if(!is.na(a) & !is.na(b)) {\n    \n    temp\
    \ <- 0\n    \n    while(a > 0) {\n      \n      temp <- temp + a %/% 10\n    \
    \  \n      a <- a %/% 10\n    }\n    \n    while(a > 0) {\n      \n      temp\
    \ <- temp + b %/% 10\n      \n      b <- b %/% 10\n    }\n    \n    if(temp !=\
    \ 0) result <- temp\n  }", "\n  # Your code here\n  a <- ifelse(a < 10, a, 10*a)\n\
    \  b <- ifelse(b < 10, b, 10*b)\n  return(a * b) \n}\n", "\n  # TODO: Complete\
    \ the function below.\n  return(0) \n}", "\n  a <- as.numeric(a)\n  b <- as.numeric(b)\n\
    \  result <- a * b \n  result\n}\n</cell>\n<cell>", "\n  a %/% b\n}\n", "\n  if\
    \ (a == 0 || b == 0) {\n    return(0)\n  }\n  else {\n    mult <- c(0, round(log(a)/log(10)))\n\
    \    mult <- mult*10 + round(log(b)/log(10))\n    mult <- mult*10 + round(a/b)\n\
    \    return(trunc(mult))\n  }\n}\n", "\n  if(b < a) {\n    return 0\n  } else\
    \ {\n    x <- 0\n    i <- 0\n    while(i < length(a)) {\n      x <- x * 10\n \
    \     x <- x + a[i]\n      i <- i + 1\n    }\n    x\n  }\n}", "\n    digit_a <-\
    \ a[1]\n    digit_b <- b[1]\n    digit_c <- c[1]\n    digit_d <- d[1]\n    digit_e\
    \ <- e[1]\n    digit_f <- f[1]\n    digit_g <- g[1]\n    digit_h <- h[1]\n   \
    \ digit_i <- i[1]\n    digit_j <- j[1]\n    digit_k <- k[1]\n    digit_l <- l[1]\n\
    \    digit_m <- m[1]\n    digit_n <- n[1]\n    digit_o <- o[1]\n    digit_p <-\
    \ p[1]\n    digit_q <- q[1]\n    digit_r <- r[1]\n    digit_s <- s[1]\n    digit_t\
    \ <- t[1]\n    digit_u <- u[1]\n    digit_v <- v[1]\n    digit_w <- w[1]\n   \
    \ digit_x <- x[1]\n    digit_y <- y[1]\n    digit_z <- z[1]\n    \n    if(digit_a\
    \ == 0 || digit_b == 0) {\n        return(digit_c)\n    }\n    if(digit_c == 0)\
    \ {\n        return(digit_d)\n    }\n    if(digit_d == 0) {\n        return(digit_e)\n\
    \    }\n    if(digit_e == 0) {\n        return(digit_f)\n    }\n    if(digit_f\
    \ == 0) {\n        return(digit_g)\n    }\n    if(digit_g == 0) {\n        return(digit_h)\n\
    \    }\n    if(digit_h == 0) {\n        return(digit_i)\n    }\n    if(digit_i\
    \ == 0) {\n        return(digit_j)\n    }\n    if(digit_j == 0) {\n        return(digit_k)\n\
    \    }\n    if(digit_k == 0) {\n        return(digit_l)\n    }\n    if(digit_l\
    \ == 0) {\n        return(digit_m)\n    }\n    if(digit_m == 0) {\n        return(digit_n)\n\
    \    }\n    if(digit_n == 0) {\n        return(digit_o)\n    }\n    if(digit_o\
    \ == 0) {\n        return(digit_p)\n    }\n    if(digit_p == 0) {\n        return(digit_q)\n\
    \    }\n    if(digit_q == 0) {\n        return(digit_r)\n    }\n    if(digit_r\
    \ == 0) {\n        return(digit_s)\n    }\n    if(digit_s == 0) {\n        return(digit_t)\n\
    \    }\n    if(digit_t == 0) {\n        return(digit_u)\n    }\n    if(digit_u\
    \ == 0) {\n        return(digit_v)\n    }\n    if(digit_v == 0) {\n        return(digit_w)\n\
    \    }\n    if(digit_w == 0) {\n        return(digit_x)\n    }\n    if(digit_x\
    \ == 0) {\n        return(digit_y)\n    }\n    if(digit_y == 0) {\n        return(digit_z)\n\
    \    }\n    if(digit_z == 0) {\n        return(0)\n    }\n    \n    digit_ab <-\
    \ digit_a + digit_b\n    digit_cd_e <- ", "\n  res <- 0\n  \n  for(i in seq_along(a))\
    \ {\n    mult <- a[i] %*% b\n    res <- res + mult\n  }\n  \n  return(res)\n}\n",
  "\n  a <- as.integer(a)\n  b <- as.integer(b)\n  a <- trunc(a)\n  b <- trunc(b)\n\
    \  if (a == 0) {\n    return(b)\n  } else if (b == 0) {\n    return(a)\n  } else\
    \ {\n    return(a*b)\n  }\n}\n", "\n  if(b == 0) a else 0\n}\n", "\n  # Your code\
    \ here\n  a <- floor(a)\n  b <- floor(b)\n  result <- 0\n  \n  while(a > 0) {\n\
    \    result <- result + 10^(ceiling(a/10))\n    a <- floor(a/10)\n  }\n  \n  while(b\
    \ > 0) {\n    result <- result - 10^(ceiling(b/10))\n    b <- floor(b/10)\n  }\n\
    \  \n  return(result)\n}\n</cell>\n<cell>", "\n  x <- as.integer(as.numeric(a)/as.numeric(b))\n\
    \  if(a<0) {\n    x <- abs(x)\n  }\n  return(x)\n}\n</cell>\n<cell>", "\n  a <-\
    \ a %% 10\n  b <- b %% 10\n  if (a < 0 || a > 9 || b < 0 || b > 9) {\n    stop(sprintf('Input\
    \ must be valid and contain only digits. Please try again. '))\n  } \n  if (a\
    \ == 0) {\n    stop(sprintf('Input must be valid and contain only digits. Please\
    \ try again. '))\n  }\n  if (a < 1 || b < 1) {\n    stop(sprintf('Input must be\
    \ valid and contain only digits. Please try again. '))\n  }\n  c <- a * b\n  d\
    \ <- floor(c / 10)\n  c <- c %% 10\n  e <- b - a\n  f <- floor(e / 10)\n  e <-\
    \ e %% 10\n  g <- c + f\n  h <- d + g\n  i <- h / 10\n  h <- h %% 10\n  j <- i\
    \ - h\n  k <- j + j\n  l <- k / 10\n  k <- k %% 10\n  m <- l - k\n  n <- m + m\n\
    \  o <- n + n\n  p <- o + o\n  q <- p + p\n  r <- q + q\n  return(r)\n}\n", "\n\
    \  a <- a\n  b <- b\n  a %% 10 * b %% 10\n}\n</code>\nAs you can see there are\
    \ many other ways to write this function. Here is another one:\n<code>", "\n \
    \ if(a == 0 || b == 0) {\n    return(0)\n  } else if(a > 0 && b > 0) {\n    return(a*b)\n\
    \  } else {\n    while(a > 0) {\n      a = a - 1\n      return(multiply(b, a))\n\
    \    }\n  }\n}\n", "\n  return(a * 10 + b)\n}\n", "\n  a <- floor(a)\n  b <- floor(b)\n\
    \  \n  # Find digits of a\n  a_digits <- unlist(strsplit(as.character(a), \"\\\
    \\.\"))\n  \n  # Find digits of b\n  b_digits <- unlist(strsplit(as.character(b),\
    \ \"\\\\.\"))\n  \n  # Multiply digits together\n  units <- unlist(a_digits) %*%\
    \ unlist(b_digits)\n  \n  # Truncate to nearest unit digit\n  truncated <- floor(units\
    \ + .Machine$double.eps / 2)\n  \n  # Recombine with units and truncate\n  floor(truncated\
    \ / 10) * 10 + truncated %% 10\n}\n</cell>\n<cell>", "\n  if (a < 0) stop(\"Negative\
    \ numbers not allowed\")\n  if (b <= 0) stop(\"Non-positive numbers not allowed\"\
    )\n  res = 0\n  while (a > 0) {\n    res <- res * 10\n    res <- res + a%%10\n\
    \    a <- floor(a/10)\n  }\n  while (abs(b) > 0) {\n    res <- res * 10\n    res\
    \ <- res + b%%10\n    b <- floor(b/10)\n  }\n  return(res)\n}\n", "\n  a <- round(a)\n\
    \  b <- round(b)\n  if (a==0) {\n    if (b==0) stop(\"cannot divide by zero\"\
    )\n    b <- -b\n    a <- -a \n  }\n  if (b==0) {\n    stop(\"cannot divide by\
    \ zero\")\n  }\n  if (a==0) {\n    a <- 1\n    b <- -1\n  }\n  b <- round(b)\n\
    \  a <- round(a)\n  a <- ifelse(a<0, -a, a)\n  b <- ifelse(b<0, -b, b)\n  a <-\
    \ round(a)\n  b <- round(b)\n  a <- a/b\n  return(a)\n}\n\nprint(multiply(148,\
    \ 412))\nprint(multiply(19, 28))\nprint(multiply(2020, 1851))\nprint(multiply(14,\
    \ -15)); \n</code>\n<|/ a |>\n<| c |>\nThis is very helpful, but I'm not clear\
    \ on how to get the code to return the correct value when one of the values is\
    \ negative.  For example, how would I get the output from your solution to return\
    \ 16 for your example instead of -128?\n<|/ c |>\n<| c |>\nI have updated the\
    \ answer to handle the negative input in some cases.  Please see the example.\n\
    <|/ c |>\n<| a tags=r dscore=0 |>\nHere's another solution using recode from car\
    \ package:\n<code>\nlibrary(car)\na<-c(148, 19, 2020, 14)\nb<-c(412, 28, 1851,\
    \ -15)\nas.integer(recode(\n  a*(1+sign(b)),\n  'a*(1+sign(b))' = 'a*(b+1)',\n\
    \  'a*(-b+1)' = 'a*(b+-1)',\n  'a' = 1,\n  NA = 'a'\n))\n</code>\nOutput:\n<code>\n\
    [1] 16   72 -128 20\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI would just make them\
    \ positive and subtract 1 from whichever one is bigger.\n<code>\na <- c(148, 19,\
    \ 2020, 14)\nb <- c(412, 28, 1851, -15)\na <- sign(a) + a\nb <- sign(b) + b\n\
    a - b - 1\n\n> a - b - 1\n[1] 16   72 -128 20\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nThis is very helpful, but I'm not clear on how to get the code to return\
    \ the correct value when one of the values is negative.  For example, how would\
    \ I get the output from your solution to return 16 for your example instead of\
    \ -128?\n<|/ c |>\n<| c |>\n`a - b - 1", "\n  if(a == 0 || b == 0) {\n    return\
    \ 0\n  }\n  \n  # Write your code here\n  \n}\n</cell>\n<cell>", "\n    if (a\
    \ < 0 || b < 0) {\n        return(NA)\n    }\n    \n    if (a > 0 && b > 0) {\n\
    \        a <- a[as.numeric(as.character(a))] \n        b <- b[as.numeric(as.character(b))]\
    \ \n        return(a * b)\n    }\n    \n    a <- a[as.numeric(as.character(a))]\
    \ \n    b <- b[as.numeric(as.character(b))] \n    \n    if (a < 0 || b < 0) {\n\
    \        return(NA)\n    }\n    \n    if (a == 0) {\n        return(b)\n    }\n\
    \    \n    if (b == 0) {\n        return(a)\n    }\n    \n    if (a < 0 && b <\
    \ 0) {\n        return(NA)\n    }\n    \n    if (a < 0 && b > 0) {\n        return(a\
    \ * b)\n    }\n    \n    if (a > 0 && b < 0) {\n        return(-1 * a * b)\n \
    \   }\n}\n</cell>\n<cell>", "\n    result <- 0\n    i <- 0\n    while (i < length(a)\
    \ && i < length(b)) {\n        result <- result + as.numeric(substr(a[i], 1, 1))\
    \ * as.numeric(substr(b[i], 1, 1))\n        i <- i + 1\n    }\n    \n    result\
    \ \n}\n</code>\n<code>\nlibrary(tidyverse)\nlibrary(magrittr)\n", "\n  # Your\
    \ code here\n  out <- 0\n  for (i in 1:a) {\n    for (j in 1:b) {\n      out <-\
    \ out + ((i - 1) * j) * 10^(i - 1) * 10^(j - 1)\n    }\n  }\n  return(out)\n}\n\
    </cell>\n<cell>", "\n  a <- strsplit(a, \"\")[[1]]\n  b <- strsplit(b, \"\")[[1]]\n\
    \  sum(a * b)\n}\n</cell>\n<cell>", "\n  mult <- 0\n  \n  while(a > 0) {\n   \
    \ mid <- a %% 10\n    a <- a %/% 10\n    mult <- mult * 10 + (mid * b)\n  }\n\
    \  \n  mult\n}\n", "\n  a <- as.numeric(a) ; b <- as.numeric(b)\n  result <- 0\n\
    \  for(k in seq_along(as.character(a))) { \n    if (a[k] == 0) { result <- result\
    \ + as.numeric(b[k]) }\n    else { result <- result * as.numeric(a[k]) }\n  }\n\
    \  return(result)\n}\n", "\n  a <- a %% 10\n  b <- b %% 10\n  if (a == 0) a <-\
    \ 10\n  if (b == 0) b <- 10\n  a <- 10 * a + b\n  a <- a / 10\n  return(a)\n}\n",
  "\n  \n  a <- ifelse(a < 0, abs(a), a)\n  b <- ifelse(b < 0, abs(b), b)\n  \n  ifelse(is.numeric(a)\
    \ & is.numeric(b), \n         ifelse(is.numeric(a), \n                trunc(a\
    \ * trunc(10^(b/10), 10)),\n                trunc(trunc(b*10^(a/10), 10) * trunc(10,\
    \ 10)),\n                trunc(trunc(trunc(b * 10^(a/10), 10) * 10, 10)), \n \
    \               trunc(trunc(trunc(trunc(b * 10^(a/10), 10) * 10, 10) * 10, 10)),\n\
    \                trunc(trunc(trunc(trunc(trunc(b * 10^(a/10), 10) * 10, 10) *\
    \ 10, 10) * 10, 10) * 10, 10) * 10, 10) * 10, 10) * 10, 10)\n}\n", "\n    # Write\
    \ your code here.\n    stopifnot(a >= 0)\n    stopifnot(b >= 0)\n    x <- 0\n\
    \    while (a != 0) {\n        x <- x + ((a%%10)*(b%%10))\n        a <- floor(a/10)\n\
    \        b <- floor(b/10)\n    }\n    return(x)\n}\n</code>\nTest Code:\n<code>",
  "\n  x <- a / 10\n  y <- b / 10\n  x * 10^(y-1) * 10^(x-1)\n}\n", "\n  \n  p <-\
    \ as.numeric(paste(substr(a, start = 1, stop = 1),\n                       substr(b,\
    \ start = 1, stop = 1),\n                       sep = \"-\"))\n  \n  p <- p -\
    \ ((p %% 10) * (p %% 10))\n  p <- p + ((p %% 10) * (p %% 10) * 10)\n  \n  p <-\
    \ ifelse(p > 0, p, 0)\n  \n  return(p)\n}\n</code>\nNote that since this function\
    \ assumes the input to be valid, it's not robust. It will return 0 instead of\
    \ NA if the inputs are invalid.\nFinally, let's test this function:\n<code>\n\
    print(multiply(148, 412))", "\n    c <- 0\n    while (a != 0) {\n        c <-\
    \ c + as.integer(as.numeric(substr(a, 1, 1))) * as.integer(as.numeric(substr(b,\
    \ 1, 1)))\n        a <- substr(a, 2, nchar(a))\n        b <- substr(b, 2, nchar(b))\n\
    \    }\n    return(c)\n}\n</code>\n<|/ a |>\n<| a tags=r,integer |>\nYou could\
    \ use a while loop in conjunction with rbind to build up the number in the right\
    \ place\n<code>\na <- '141'\nb <- '412'\ni <- 2\nwhile(i < length(a)) {\n  x <-\
    \ as.numeric(substr(a,i,i))\n  y <- as.numeric(substr(b,i,i))\n  i <- i + 1\n\
    \  x <- x*y\n  print(paste(x,sep=''))\n}\n[1] \"168\"\n[1] \"720\"\n[1] \"0\"\
    \  \n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. I am not able\
    \ to follow the logic. Could you please explain the logic to me?\n<|/ c |>\n<|\
    \ c |>\nSo I've been thinking about this problem and I've come up with a simple\
    \ solution which uses `substr` to get the individual digits of your numbers and\
    \ then multiplies them together to build up a number. Hope that helps.\n<|/ c\
    \ |>\n<| c |>\nThanks for your efforts. I understand your approach but I guess\
    \ you did not understand my problem correctly. Your method does not take into\
    \ consideration the fact that there are zeroes in the input. If input is `'141'`\
    \ and `'412'`, it outputs `'8'` instead of `'168'`.\n<|/ c |>\n<| c |>\nI guess\
    \ I was thinking you could add a condition to only add one zero if the next digit\
    \ is > 9. I would say that this solution would be a more complex problem than\
    \ the others so I feel that the other solutions would work best.\n<|/ c |>\n<|\
    \ a |>\nHere is a solution without using any packages.\n<code>\nmultiply_2 <-\
    \ function(x,y) {\n  y <- as.integer(y)\n  sx <- as.integer(trunc(x/10)*y)\n \
    \ sy <- x/10 - sx\n  if(sx==0) sx <- 1\n  sx <- paste0(sx,\"0\")\n  sy <- paste0(sy,sx)\n\
    \  x <- as.integer(sx)\n  y <- as.integer(sy)\n  y <- ifelse(y>9,y+1,", "\n  a\
    \ <- as.numeric(as.character(a))\n  b <- as.numeric(as.character(b))\n  if (a\
    \ %% 10 == 0 && b %% 10 == 0) return(0)\n  else if (a %% 10 != 0 & b %% 10 !=\
    \ 0) return(a - b * 10)\n  else return(a - b)\n}\n", "\n  \n  if (a == 0) {\n\
    \    return 0\n  }\n  if (b == 0) {\n    return a\n  }\n  \n  sum <- a %/%b\n\
    \  \n  return(sum(multiply(a, (sum - b)/b)))\n}\n", "\n  res <- 0\n  for (i in\
    \ 1:length(a)) {\n    mult <- 0\n    for (j in 1:length(b)) {\n      if (a[i]\
    \ == 0 && b[j] > 0) {\n        res <- res + 1\n      } else if (a[i] == 0 && b[j]\
    \ < 0) {\n        res <- res + b[j]\n      } else if (a[i] < 0 && b[j] > 0) {\n\
    \        res <- res + a[i]\n      } else if (a[i] < 0 && b[j] < 0) {\n       \
    \ res <- res + b[j] + a[i]\n      }\n      mult <- mult + b[j]\n    }\n    res\
    \ <- res + mult\n  }\n  res\n}\n</code>\n<|/ a tags=r,optimization dscore=1 |>\n\
    <| c |>\nThanks. This is super helpful.\n<|/ c |>\n<| c |>\nThanks for your feedback.\
    \ I'd appreciate it if you could mark my answer as helpful, and/or not helpful,\
    \ depending on the results of your testing.\n<|/ c |>\n<| a |>\nYour code works\
    \ when only one of the input vectors is of length zero. That is a good start.\
    \ As long as the input vectors are the same length, and all of the numbers are\
    \ positive, the function will work. \nThe next step is to make sure that your\
    \ input vectors are of the same length. The function will still work, even if\
    \ the numbers are not all the same length. \nThe next step is to make sure that\
    \ all the numbers are positive before you run the function. Then you can assume\
    \ that there will be an answer that will not make any assumptions about negative\
    \ numbers. \nTo account for the different lengths of the input vectors, you can\
    \ do some checking before running the function.  \nFor example, if your first\
    \ input vector is of length 0, and your second input vector is of length 3, you\
    \ can run the function twice until one of them is of length 0.  \n<code>", "\n\
    \  result <- 0\n  while(a > 0) {\n    result <- result * 10 + a%%10\n    a <-\
    \ a/10\n  }\n  while(b > 0) {\n    result <- result * 10 + b%%10\n    b <- b/10\n\
    \  }\n  result\n}\n", "\n    b <- toInt(b)\n    out <- 0\n    if (b > 0) {\n \
    \       while (a > 0) {\n            out <- out + 10\n            a <- floor(a/10)\n\
    \        }\n    }\n    return(out)\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=1\
    \ tags=r |>\nThis is a fun task that was also asked in an R programming contest.\
    \ The challenge is to determine which of the following functions returns zero\
    \ when provided with a positive integer:\n\ndivby10\ndivby100\ndivby1000\n\nWe\
    \ can use this solution to solve the problem:\n<code>\ndivby100 <- function(x)\
    \ {\n    if(x < 100) {\n        return(x)\n    }\n    y <- 0\n    div <- x\n \
    \   while(div > 0) {\n        y <- y + div/10\n        div <- div%10\n    }\n\
    \    return(y)\n}\n</code>\nThe above function simply returns the integer when\
    \ given an integer greater than or equal to 100.\nThe function divby1000 can be\
    \ written like this:\n<code>\ndivby1000 <- function(x) {\n    if(x < 1000) {\n\
    \        return(x)\n    }\n    y <- 0\n    div <- x\n    while(div > 0) {\n  \
    \      y <- y + div/100\n        div <- div%100\n    }\n    return(y)\n}\n</code>\n\
    Now we can write a function that returns a vector that contains each of the functions\
    \ described above, given a positive integer.\n<code>\nmyfun <- function(x) {\n\
    \    div <- x\n    vec <- c()\n    while(div > 0) {\n        vec <- c(vec, divby10(div))\n\
    \        div <- div%10\n    }\n    vec <- c(vec, divby100(div))\n    vec <- c(vec,\
    \ divby1000(div))\n    return(vec)\n}\n</code>\nLet's test the function on the\
    \ first few values.\n<code>\n> myfun(14)\n[1]  14 14 14 14 14 14 14 14 14 14 14\
    \ 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14\
    \ 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14\
    \ 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14\
    \ 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14\
    \ 14 14 14 14 14 ", "\n  units <- c(a, b)  # Keep track of each unit digit\n \
    \ while ((length(units) > 1) && (units[-1] < 0)) {  # Check if the product is\
    \ negative \n    units <- units[-1] - units[-2]  # Subtract the unit digits from\
    \ the product\n  }\n  sum(as.integer(units)) * 10^ceiling(log10(sum(as.integer(units))))\n\
    }\n", "\n    # Initialize total to zero \n    total <- 0\n    \n    # Loop from\
    \ first to last digit\n    for (i in 1:(length(a)))\n    {\n        # Convert\
    \ each digit to a character then convert to numeric type\n        x <- as.numeric(as.character(a[[i]]))\n\
    \        y <- as.numeric(as.character(b[[i]]))\n        # Use modulus to get remainder\n\
    \        rem <- x %% y\n        # Update total\n        total <- total + rem\n\
    \        # Update the remainder\n        x <- x - rem\n    }\n    # Return the\
    \ product of the total\n    return(total)\n}\n", "\n  x <- a%/%10\n  y <- a%%10\n\
    \  z <- b%/%10\n  w <- b%%10\n  if(x == 0) {\n    x <- 1\n  }\n  if(y == 0) {\n\
    \    y <- 1\n  }\n  if(z == 0) {\n    z <- 1\n  }\n  if(w == 0) {\n    w <- 1\n\
    \  }\n  x*y*z*w\n}\n</code>\n<|/ a tags=r,numbers,integer,math |>\n<| a tags=r,numbers,integer,math\
    \ dscore=1 |>\nHere is a solution using a recursive function using RcppAlgos\n\
    <code>\nlibrary(RcppAlgos)\nlibrary(Rcpp)\ncppFunction('\nNumericVector multiplyDigits(int\
    \ a, int b) {\n  if (a == 0) {\n    return NumericVector(1,1);\n  } else if (b\
    \ == 0) {\n    return NumericVector(1,0);\n  } else if (a < 10) {\n    return\
    \ a * multiplyDigits(a/10, b/10);\n  } else if (b < 10) {\n    return multiplyDigits(a/10,\
    \ b*10);\n  } else {\n    return multiplyDigits(a/10, b/10) * a;\n  }\n}\n')\n\
    </code>\n<|/ a |>\n<| a tags=r,numbers,integer,math |>\nHere's a very simple recursive\
    \ function\n<code>\nmymul <- function(x, y) {\n  if(x==0) return(y)\n  return(mymul(x/10,\
    \ y*10))\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,numbers,integer,math |>\n\
    The answer to this question is a bit late, but I was looking for a way to do this\
    \ with a recursive function, and I came across the following R package:\nhttps://cran.r-project.org/web/packages/Rcpp/index.html\n\
    I hope this may help other people looking to do the same thing.\n<|/ a dscore=0\
    \ |>\n<| a |>\nHere is an R function using RcppAlgos\n<code>\ncpp_multiply_digits\
    \ <- RcppAlgos::multiply_digits\n</code>\n<|/ a tags=r,numbers,integer,math dscore=0\
    \ |>\n<| a dscore=0 |>\nAn R function that uses recursion:\n<code>\nmultiply_digits\
    \ <- function(a, b) {\n  x <- a / 10\n  y <- b %% 10\n\n  if (x == 0) {\n    return(y)\n\
    \  } else if (y == 0) {\n    return(x)\n  } else if (x < 10) {\n    return(x *\
    \ multiply_digits(x, y - 1))\n  } else if (y < 10) {\n    return(multiply_digits(x\
    \ * 10, y - 1) * x)\n  } else {\n    return", "\n  # your code here\n  \n  product\
    \ = as.integer(a)*as.integer(b)\n  \n  return(product)\n}\n</code>\nTest\n<code>",
  "\n  # Extract the unit digits and compute their product.\n  units <- strsplit(as.character(a),\
    \ \"\")\n  units <- sapply(units, function(x){ as.integer(x[which(x == \"U\")])})\n\
    \  units <- units^b\n  units <- units * 1e9\n  units <- ifelse(units > 1e9, units\
    \ - (units %% 1e9), units)\n  units <- ifelse(units > 1e6, units - (units %% 1e6),\
    \ units)\n  units <- ifelse(units > 1e3, units - (units %% 1e3), units)\n  units\
    \ <- ifelse(units > 1, units - (units %% 1), units)\n\n  # Compute the product\
    \ in integer form. \n  # If the result is < 1, return 0.\n  units <- ifelse(units\
    \ > 1, units, 1)\n\n  # Add back the units digits.\n  units <- sprintf('%d', units)\n\
    \n  # Return the computed product.\n  as.integer(units)\n}\n</cell>\n<text>\n\
    Problem 3\nAssume we implement a version of vector addition that performs a \n\
    cartesian product between two vectors while avoiding duplicates.\n\nWhat would\
    \ be the complexity of this function? How much memory do we \nallocate?\n\n\n\
    </text>\n<cell>", "\n    # code here\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=recursion,r\
    \ dscore=0 |>\nHere's a solution using only R's base functions (No packages).\
    \ \n<code>", "\n  a <- as.numeric(a)\n  b <- as.numeric(b)\n  d <- strsplit(b,\
    \ \"\")[[1]][1]\n  if (d <= 9) {\n    return(a * d)\n  } else {\n    return(a)\n\
    \  }\n}\n", "\n  if (a < 10 || a > 99) {\n    stop('Invalid input')\n  }\n  if\
    \ (b < 10 || b > 99) {\n    stop('Invalid input')\n  }\n  if (a > b) {\n    stop('Invalid\
    \ input')\n  }\n\n  a <- a %% 10\n  b <- b %% 10\n\n  product <- 0\n  for (i in\
    \ 0:9) {\n    product <- product * 10 + a\n  }\n  for (i in 10:99) {\n    product\
    \ <- product * 10 + b\n  }\n  return(product)\n}\n</code>\n<|/ a tags=r,tidyverse\
    \ |>\n<| c |>\nThanks for your solution. I'm sure it will help others in future\
    \ :-)\n<|/ c |>\n<| c |>\nIf you feel this answer has solved your problem please\
    \ consider accepting it by clicking the check-mark.\n<|/ c |>\n<| a |>\nWe can\
    \ convert the numbers to character and use gsub to get the desired result\n<code>\n\
    library(dplyr)\n\ndf %>% \n  mutate(col1 = as.character(col1)) %>%\n  mutate(col2\
    \ = as.character(col2))  %>% \n  mutate(col3 = as.numeric(col1) %>%  col1 * as.numeric(col2))\
    \ %>% \n  mutate(col3 = as.character(col3)  %>% \n  gsub(',', '', col3))\n", "\n\
    \  if (isFinite(a) && isFinite(b)) {\n    \n    # Get the absolute value of the\
    \ product, \n    # then get the modulo to get the remainder.\n    # If the remainder\
    \ is negative, add the number to the result \n    # in reverse order, and reverse\
    \ the result. \n    # If the remainder is not negative, do nothing.\n    \n  \
    \  mod <- function(x, y) {\n      return(x %% y)\n    }\n    \n    res <- 0\n\
    \    \n    while (a > 0 && b > 0) {\n      r <- mod(a, b)\n      res <- res *\
    \ 10 + r\n      a <- floor(a/b) * b\n      b <- floor(b/b) * b\n    }\n    \n\
    \    if (mod (a, b) < 0) {\n      res <- res * -1\n    }\n    \n    return(res)\n\
    \  }\n}\n", "\n  # Make sure that input is an integer\n  if(!is.integer(a) ||\
    \ !is.integer(b))\n    stop(\"Input must be integers\")\n\n  # Validate that input\
    \ is a positive integer\n  # and greater than 0\n  if(!is.numeric(a) || !is.numeric(b)\
    \ || !is.integer(a) || !is.integer(b) || !a || a < 0)\n    stop(\"Input must be\
    \ positive integers and greater than 0\")\n\n  return((a % 10) * (b % 10))\n}\n\
    </code>\n<|/ a tags=r |>\n<| a dscore=0 |>\nMy answer is based on this thread:\
    \ \nhttps://community.rstudio.com/t/how-to-find-the-maximum-of-the-digits-of-a-number/1368\n\
    The function below can solve this problem.\n<code>\ndigitmax <- function(x) {\n\
    \    x <- as.numeric(x)\n    result <- 0\n    if(is.na(x)) {\n        return(result)\n\
    \    }\n    for (i in 1:(length(x)-1)) {\n        result <- result + (x[[i]] -\
    \ min(x)) * (x[[i]] - min(x))\n    }\n    return(result)\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nThis solution is wrong. Take a look to the examples I've added\
    \ to the original question. There are two cases where this solution fails. In\
    \ the first case `digitmax(19)` returns `0` while it should be `20`. The second\
    \ case `digitmax(148)` returns `0` while it should be `148`\n<|/ c |>\n<| c |>\n\
    Sorry, my mistake. Corrected now\n<|/ c |>\n<| c |>\nIt looks correct now. Can\
    \ you explain the logic behind the solution?\n<|/ c |>\n<| c |>\nBasically I create\
    \ a loop from 1 to length of number minus 1, and check every digit of the number\
    \ in the loop, subtract min from the digit. If I find the same digit twice, sum\
    \ them, otherwise add the result to the previous sum\n<|/ c |>\n<| c |>\nNow I\
    \ see what you are doing. I just want to know if there is a shorter way\n<|/ c\
    \ |>\n<| a tags=r |>\n<code>\ndigitmax <- function(x) {\n  x <- as.numeric(x)\n\
    \  result <- 0\n  if(is.na(x)) {\n    return(result)\n  }\n  for(i in 1:(length(x)-1))\
    \ {\n    result <- result + (x[[i]] - min(x)) * (x[[i]] - min(x))\n  }\n  return(result)\n\
    }\n</code>\n<|/ a dscore=0 |>\n<|", "\n  if(a%%10 == 0 & b%%10 == 0) \n  return(a*b)\n\
    \  \n  if(a%%10 != 0 & b%%10 == 0) \n  return(multiply(a/10, b/10))\n  \n  if(a%%10\
    \ == 0 & b%%10 != 0) \n  return(multiply(a/10, b/10))\n  \n  if(a%%10 != 0 & b%%10\
    \ != 0) \n  return(multiply(a/10, b/10) * 10)\n}\n", "\n  # Compute the product\
    \ of the first digits\n  # Then multiply with the second.  \n  # Start by getting\
    \ the product of the digits of the first\n  # number.  Then multiply with the\
    \ second number, ignoring\n  # those that were multiplied with zero.\n  # Compute\
    \ the product of the two numbers to get \n  # the product\n  a <- a[[1]]\n  b\
    \ <- b[[1]]\n  p <- prod(a)\n  sa <- sum(a)\n  sb <- sum(b)\n  \n  if (sb == 0)\
    \ \n    return(as.numeric(p))\n  \n  if(sb > 0)\n  {\n    p <- p*a\n  }\n  else\
    \ \n  {\n    p <- p*b\n    p <- p/sa \n  }\n  \n  return(as.numeric(p))\n}", "\n\
    \  a <- as.integer(a)\n  b <- as.integer(b)\n  a %o% b # returns the remainder\
    \ of a divided by b\n}\n</cell>\n<text>\nNow let's test our multiply function\
    \ by multiplying two numbers that we know should produce the answer 16.\n\n</text>\n\
    <cell>\nmultiply(148, 412)\n</cell>\n<cell>\nmultiply(19, 28)\n</cell>\n<cell>\n\
    multiply(2020, 1851)\n</cell>\n<cell>\nmultiply(14, -15)\n</cell>\n<text>\nSo\
    \ our function seems to be working as expected.\n\nNow let's write a function\
    \ that takes a single string as input\nand returns True if the string contains\
    \ all of the digits from 1 to 9.\nFalse otherwise.\n\n</text>\n<cell>", "\n  if\
    \ (b < 0) b + 144 else b\n}\n", "\n  # ...\n}\n</code>\n3. Tests\nNow let's test\
    \ your implementation with some example inputs to make sure the output matches\
    \ your expectations.\n<code>", "\n  \n  \n  \n  \n}\n</cell>\n<cell>", "\n  \n\
    \  # Your code here\n  \n  return(sum(na.omit(as.integer(a) * as.integer(b))))\n\
    }\n", "\n  # Write your code here\n  if(a>0 && a<10){\n    a*b\n  }else{\n   \
    \ a*(b+10)\n  }\n}\nmultiply(148,412)\n</cell>\n<cell>", "\n  # TODO: Write your\
    \ code here\n}\n", "\n  # Your code goes here\n  return(10^(floor(log10(a)) *\
    \ floor(log10(b))))\n}\n</cell>\n<text>\nQuestion 15\nWrite a recursive function\
    \ called factorial that takes one integer and returns \nthe factorial of that\
    \ integer. Write a test that runs your function on all \npossible input values.\n\
    \nHint: Look at the examples above that use this function\n\nHint: Recursion is\
    \ most useful when your function has more than one base case\nYou don't have to\
    \ worry about special cases here (like 0)\n\nHint: You should be able to use your\
    \ own function here\n\n\n</text>\n<cell>", "\n  c <- a\n  d <- b\n  while( !(is.na(c)\
    \ & is.na(d)) ) {\n    if(d >= 10) {\n      c <- c + as.integer(digits[d]) \n\
    \      d <- d - 10\n    } else {\n      d <- d + as.integer(digits[d]) \n    \
    \  c <- c - as.integer(digits[d])\n    }\n  }\n  return(c)\n}", "\n  b <- b -\
    \ a %% 10\n  if (a == 0) {\n    return(0)\n  } else if (a < 0 || b <0) {\n   \
    \ return(0)\n  } else {\n    return(10*a + b)\n  }\n}\n</code>\n<|/ a dscore=2\
    \ tags=r |>\n<| c |>\nIt would be nice to be able to get the actual digit of the\
    \ product back, since that's the goal of the question. E.g. if the product is\
    \ `148 * 412`, then it should return `16`.\n<|/ c |>\n<| c |>\n: I think that's\
    \ what the code in the answer does ;-)\n<|/ c |>\n<| c |>\nYeah, I thought you\
    \ meant the `digit` function that you added. Anyway, I think you should have added\
    \ that to the answer (even though I agree that it would be more useful to have\
    \ the actual digits printed out at the end).\n<|/ c |>\n<| a |>\nThis could be\
    \ achieved by first calculating the unit digit of the product (divide the product\
    \ by ten) and then rounding to integer and summing these integers, e.g.:\n<code>\n\
    unit_digit <- function(x) {\n  y <- x / 10\n  y <- floor(y)\n  if (y == 0) {\n\
    \    return(0)\n  } else if (y < 0) {\n    return(-1)\n  } else {\n    return(y)\n\
    \  }\n}\n\nsum_digits <- function(x) {\n  y <- 10^(0:length(x))\n  sum <- 0\n\
    \  for (k in 1:length(x)) {\n    y <- y[,k]\n    y <- c(y, 0)\n    sum <- sum\
    \ + y*unit_digit(x[k])\n  }\n  return(sum)\n}\n\nmult <- function(x, y) {\n  z\
    \ <- sum_digits(x)*sum_digits(y)\n  z <- c(z, 0)\n  return(round(z))\n}\n</code>\n\
    Testing the functions works as expected:\n<code>\nmult(148, 412)", "\n  \n  #\
    \ Convert input to a numeric type\n  a1 <- as.numeric(as.character(a))\n  b1 <-\
    \ as.numeric(as.character(b))\n  \n  # If the two numbers have the same number\
    \ of digits\n  if(length(a1) == length(b1)) {\n    \n    # Subset each digit of\
    \ the two numbers\n    a2 <- as.numeric(substr(as.character(a), 1, 1))\n    b2\
    \ <- as.numeric(substr(as.character(b), 1, 1))\n    \n    # Multiply each digit\
    \ of the two numbers\n    result <- a2 * b2\n  }\n  \n  # If the two numbers have\
    \ different number of digits\n  else if(length(a1) > length(b1)) {\n    \n   \
    \ # Subset each digit of the two numbers\n    a2 <- as.numeric(substr(as.character(a),\
    \ 1, 1))\n    b2 <- as.numeric(substr(as.character(b), 1, 1))\n    \n    # Add\
    \ the remaining digits\n    result <- a1 + b1 + a2\n  }\n  \n  # If the two numbers\
    \ have different number of digits\n  else if(length(a1) < length(b1)) {\n    \n\
    \    # Subset each digit of the two numbers\n    a2 <- as.numeric(substr(as.character(a),\
    \ 1, 1))\n    b2 <- as.numeric(substr(as.character(b), 1, 1))\n    \n    # Add\
    \ the remaining digits\n    result <- a1 + b1 + a2\n  }\n  \n  # If the two numbers\
    \ have the same number of digits\n  else {\n    \n    # Subset each digit of the\
    \ two numbers\n    a2 <- as.numeric(substr(as.character(a), 1, 1))\n    b2 <-\
    \ as.numeric(substr(as.character(b), 1, 1))\n    \n    # Add the remaining digits\n\
    \    result <- a1 + b1 + a2\n  }\n  \n  # Return the result\n  result\n}\n</cell>\n\
    <cell>", "\n  mult <- 0; # Initialize our accumulator to 0\n  for(i in seq(a,\
    \ b)) {\n    mult <- mult + floor(i/10)\n  }\n  mult\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThank you very much. Your answer was very helpful. I was able to write\
    \ a code using your answer to solve my problem.\n<|/ c |>\n<| a dscore=0 |>\n\
    Here's another solution:\n<code>\nlibrary(tidyverse)\nlibrary(data.table)\n",
  "\n  # Complete the function body here\n  # To check valid inputs, use an if/else\
    \ statement.\n  a <- a / 10\n  b <- b / 10\n  return(a + (b*10L))\n}\n</cell>\n\
    <cell>", "\n  result <- a\n  if (isdigit(b)) \n    result <- a*as.numeric(b)\n\
    \  return(result)\n}\n\nprint(multiply(4, 12))\nprint(multiply(4, 12))\nprint(multiply(14,\
    \ 4))\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,biginteger,math |>\nA solution\
    \ based on gmp (a GNU Multiple Precision Arithmetic package) package:\n<code>\n\
    multiply <- function(a, b) {\n  library(gmp)\n  a <- as.bigz(a)\n  b <- as.bigz(b)\n\
    \  res <- mpz.sgn(a) * mpz.sgn(b)\n  if (res.gt.0) {\n    res <- mpz.sqrt(res)\n\
    \    a <- mpz.multiply(a, b, res ^ (mpz.sqrt(2) * mpz.sqrt(2)))\n  }\n  return(as.numeric(a))\n\
    }\n</code>\nBenchmark test with larger arguments:\n<code>\n> microbenchmark(multiply(412,\
    \ -188), multiply(-12, 484))\nUnit: milliseconds\n         expr      min     \
    \  lq      mean   median       uq      max neval cld\n multiply(412, -188) 16.43446\
    \ 17.33597 18.25840 18.72525 19.54578 54.5072   100   c\n multiply(-12, 484) \
    \ 7.30505  8.41534  9.06948  8.58055  9.86733  10.3354   100  b \n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nIt works, but it seems that the two first lines (`library(gmp)`\
    \ and `a <- as.bigz(a)`) are executed for every function call, right? So if I\
    \ have thousands of such functions in my code, it would be quite inefficient.\n\
    <|/ c |>\n<| c |>\n, yes, it seems like that. But if you need to calculate a big\
    \ number, you can always cache it for multiple calls.\n<|/ c |>\n<| a dscore=2\
    \ tags=r,biginteger,math |>\nThis is how I ended up doing, using Rmpfr and Rmpfr\
    \ packages:\n<code>", "\n  n <- trunc(a/10)*10\n  d <- trunc(b/10)*10\n  return(sum(n,\
    \ d)*10)\n}\n", "\n  # your solution here\n  return(a * b / 100) \n}\n</code>\n\
    <|/ a tags=r,string,type-conversion,integer |>\n<| a tags=r,string,type-conversion,integer\
    \ dscore=2 |>\nA variation on Paul's answer, which will also work if the input\
    \ vector does not consist of numeric values only:\n<code>\nconvert_string <- function(x){\n\
    \  y <- c()\n  for (i in 1:length(x)){\n    n <- as.numeric(unlist(strsplit(as.character(x[i]),\
    \ \"\")))\n    y <- c(y, n)\n  }\n  return(y)\n}\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work for \"-\". Maybe `x <- c(\"1\",\"1-2\",\"1-2-3\",\"-\",\"1-2-3\"\
    )`\n<|/ c |>\n<| a dscore=2 |>\nUsing tidyverse and stringr:\n<code>\nlibrary(stringr)\n\
    library(tidyverse)\n", "\n  \n  # Initialize the variable product, which will\
    \ hold the answer.\n  # Note that R does not allow assignment inside functions,\
    \ \n  # so you must explicitly say product = ...\n  product <- 0\n  \n  # Convert\
    \ both numbers to strings for easier manipulation\n  astr <- toString(a)\n  bstr\
    \ <- toString(b)\n  \n  # Iterate through the digits of the numbers, \n  # adding\
    \ units to the product as we go.\n  for(digit in seq(1, length(astr))) {\n   \
    \ \n    current <- as.numeric(astr[digit])\n    next <- as.numeric(bstr[digit])\n\
    \    \n    if (current < next) {\n      \n      product <- product * 10\n    \
    \  \n      product <- product + (current - next)\n      \n    } else {\n     \
    \ \n      product <- product * 10\n      \n      product <- product + (next -\
    \ current)\n      \n    }\n    \n  }\n  \n  return(product)\n  \n}\n", "\n  return(as.numeric(paste(as.vector(a),\
    \ as.vector(b), sep=\"\")))\n}\n</code>\nTest cases\n<code>\nmultiply(1, 10)",
  "\n    d <- 0\n    for(i in seq(0, nchar(a), 1))\n    {\n        d <- d + as.numeric(substr(a[i\
    \ : (i - 1)], i, 1)) * as.numeric(substr(a[(i - 1) : i], 1, i))\n    }\n    return(d)\n\
    }\n", "\n  if (a < 0 | a > 9 | b < 0 | b > 9) {\n    stop(\"Invalid arguments\"\
    )\n  }\n  result <- 0\n  i <- 0\n  while (a %% 10 == 0 && b %% 10 == 0) {\n  \
    \  a <- a/10\n    b <- b/10\n    i <- i + 1\n    result <- result + ((a*b)/(i))\n\
    \  }\n  if (a %% 10 != 0 && b %% 10 != 0) {\n    result <- result + ((a*b)/(i))\n\
    \  }\n  if (i == 0) {\n    result\n  } else {\n    stop(\"Invalid input\")\n \
    \ }\n}", "\n  if (a > b || a == 0) {\n    stop(\"Invalid input\")\n  }\n  \n \
    \ a <- as.character(a)\n  b <- as.character(b)\n  \n  a <- strsplit(a, \"\")\n\
    \  b <- strsplit(b, \"\")\n  \n  a <- as.integer(sapply(a, function(x) paste(grep(x,\
    \ b, value = TRUE), collapse = \"\")))\n  b <- as.integer(sapply(b, function(x)\
    \ paste(grep(x, b, value = TRUE), collapse = \"\")))\n  \n  a <- ifelse(a > b,\
    \ a - b, a)\n  \n  return(as.integer(as.character((a - 1) / b)))\n}\n", "\n  res\
    \ <- 0\n  for (i in 0:9) {\n    if ( (a %% 10) == 0 ) {\n      res <- res * 10\
    \ + i\n    }\n    a <- a / 10\n  }\n  if ( (b %% 10) == 0 ) {\n    res <- res\
    \ * 10 + b\n  }\n  return(res)\n}\n\nmultiply(148, 412)"]
stop_tokens:
- "\n#"
- "\n```"
