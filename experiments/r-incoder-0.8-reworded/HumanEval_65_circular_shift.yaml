name: HumanEval_65_circular_shift
language: r
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift(12, 1)\n# '21'\n# >>> circular_shift(12, 2)\n\
  # '12'\ncircular_shift <- function(x, shift) {"
tests: "test_humaneval <- function() {\ncandidate <- circular_shift\n    if(!identical(candidate(100,\
  \ 2), '001')){quit('no', 1)}\n    if(!identical(candidate(12, 2), '12')){quit('no',\
  \ 1)}\n    if(!identical(candidate(97, 8), '79')){quit('no', 1)}\n    if(!identical(candidate(12,\
  \ 1), '21')){quit('no', 1)}\n    if(!identical(candidate(11, 101), '11')){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  if(x == 0) return(0)\n  if(x == 1) return(1)\n  r <- circular_shift(floor(x/10),\
    \ shift)\n  r <- paste0(r, rev(x))\n  return(r)\n}\n", "\n  x <- as.character(x)\n\
    \  ifelse(shift > nchar(x), paste(rev(substr(x, 1, nchar(x))), substr(x, nchar(x)\
    \ + 1, nchar(x)), sep = \"\"),\n         paste(substr(x, 1, nchar(x) - shift),\
    \ substr(x, nchar(x) + shift, nchar(x)), sep = \"\"))\n}\n</cell>\n<text>\nPractice\
    \ Problems\nWrite a function to replicate a string of x copies of y.\nWrite a\
    \ function to convert the first letter of a string to upper case.\nWrite a function\
    \ to capitalize the first letter of every word in a string.\nWrite a function\
    \ to remove leading and trailing spaces from a string.\nWrite a function that\
    \ returns a new string made by replacing the characters in old with new in a string.\n\
    Write a function that replaces the second and third letters of every word in a\
    \ string with the letters \"py\".\nWrite a function that takes a vector of strings\
    \ and returns a new string made up of all the words of the original string separated\
    \ by spaces.\nWrite a function that returns a new string made up of all but the\
    \ first and last letter of the original string separated by a space.\nWrite a\
    \ function that takes a vector of strings and returns a new string made up of\
    \ all the words of the original string separated by a space and an exclamation\
    \ mark.\nWrite a function that takes a vector of strings and returns a new string\
    \ made up of all the words of the original string separated by a space and an\
    \ exclamation mark and a colon.\nWrite a function that takes a vector of strings\
    \ and returns a new string made up of all the words of the original string separated\
    \ by a space and an exclamation mark and a colon and a dash.\nWrite a function\
    \ that takes a vector of strings and returns a new string made up of all the words\
    \ of the original string separated by a space and an exclamation mark and a colon\
    \ and a dash and a period.\nWrite a function that takes a vector of strings and\
    \ returns a new string made up of all the words of the original string separated\
    \ by a space and an exclamation mark and a colon and a dash and a period and an\
    \ apostrophe.\nWrite a function that takes a vector of strings and returns a new\
    \ string made up of all the words of the original string separated by a space\
    \ and an exclamation mark and a colon and a dash and a period and an apostrophe\
    \ and an exclamation mark.\nWrite a function that takes a vector of strings and\
    \ returns a new string made up of all the words of the original string separated\
    \ by a space and an exclamation mark and a colon and a dash and a period and an\
    \ apostrophe and an exclamation mark and a dash.\nWrite a function that takes\
    \ a vector of strings and returns a ", "\n  s <- substr(x, 1, 1)\n  x <- substr(x,\
    \ 2, nchar(x))\n  paste0(s, x, s)\n}\n", "\n  shift <- as.integer(shift) # ensure\
    \ shift is integer\n  x <- as.integer(x)       # ensure x is integer\n  if(x <\
    \ 0) x <- x%+% 10 + 10 - x\n  digits <- floor(x/10)\n  x <- x %% 10\n  digits\
    \ <- c(digits, x)\n  paste(digits, rev(digits), sep=\"\", na.rm=TRUE)\n}\n", "\n\
    \  if(x == 0)\n    return(paste0(\"\", as.character(x)))\n  ifelse(shift > length(as.character(x)),\
    \ \n         paste0(substr(x, 1, length(as.character(x))-shift), \n          \
    \      substr(as.character(x),1,shift)), \n         substr(as.character(x), 1,shift))\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis was very helpful to me, thank you! I really\
    \ like the way you used ifelse() and the use of paste().\n<|/ c |>\n<| c |>\n\
    Haha, I was surprised by how much more complicated the function would be. I also\
    \ wondered why you chose to return the shifted number as a character string.\n\
    <|/ c |>\n<| a tags=r dscore=1 |>\n<code>\ncshift(x, 1)", "\n  if((shift > length(x))\
    \ || (shift < 0)) {\n    return(as.character(x))\n  }\n  if(shift > 0)\n    x\
    \ <- ceiling(log10(x))\n  x <- floor(x)\n  x <- c(x, rep(0,shift-length(x)))\n\
    \  x <- rep(10, x)\n  return(paste0(rev(x), as.character(x)))\n}\n", "\n  ndigits\
    \ <- length(x)\n  shift <- if (shift > ndigits) 0 else shift\n  digits <- as.numeric(as.character(x))\n\
    \  digits <- digits[(digits %% 10) + shift + 1 : (digits %% 10) + shift]\n  if\
    \ (shift > ndigits) digits <- digits[(digits %% 10) : ndigits]\n  paste(digits,\
    \ collapse = \"\")\n}\n", "\n  as.integer(x)^(-1 * (shift % 3))\n}\n</code>\n\
    <|/ a tags=r |>\n<| a |>\nI used the following code to find the number of zeros\
    \ in binary representation of a number.\n<code>\nbit_count_r <- function(x, bit_width){\n\
    \n  res <- 0\n  bit_count <- 0\n  bit_length <- bit_width\n  \n  while(bit_length\
    \ > 0){\n    if((x & 1L) != 0){\n      res <- res + 1L\n    }\n    bit_count <-\
    \ bit_count + 1L\n    x <- x >> 1L\n    bit_length <- bit_length - 1L\n  }\n \
    \ \n  return(bit_count)\n}\n</code>\n<|/ a tags=r dscore=2 |>\n<| a tags=r |>\n\
    Here's a slightly more compact answer using base-R functions. This will allow\
    \ you to use other bases than 2 as well.\n<code>\nbin_zeros <- function(x, base)\
    \ {\n  sapply(strsplit(as.character(x), ''), \n         function(y)\n        \
    \   sum(y == 0^1:(nchar(y)/base^(nchar(y)%%base)))\n  )\n}\n</code>\nExamples:\n\
    <code>\nx <- c(11, 22, 33, 44, 55)\n\nbin_zeros(x, 2) # returns 3 zeros in binary\
    \ 1111 \n\nbin_zeros(x, 16) # returns 5 zeros in binary 11111111 \n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=1 tags=r |>\nIf someone still looking for base R\
    \ solution for converting decimal to binary and finding number of zeros in binary\
    \ representation (without using any package).\n<code>", "\n  n <- digits(x) #\
    \ Number of digits in the number\n  o <- numeric(n) # Overflow vector to prevent\
    \ overflow\n  o[length(o)] <- 1 # Initialize overflow to 1 (not needed, but it\
    \ doesn't hurt)\n  x <- trunc(x) # Truncate the number\n  m <- length(o) # Number\
    \ of digits in overflow vector\n  x <- trunc(x) # Truncate the number\n  shift\
    \ <- trunc(shift)\n  if (shift > m) return(paste0(rev(x), digits(x)[length(x)]))\n\
    \  if (shift == 0) return(x)\n  x <- paste0(rep(0, shift - m), x, rep(0,m - (shift\
    \ + m)))\n  x <- paste0(substr(x, 1, m+1), x, substr(x, m+1, n))\n  return(paste0(x,\
    \ digits(x)[(m + n + 1L):length(digits(x))]))\n}\n</code>\n<|/ a |>\n<| a tags=r,string-concatenation\
    \ |>\nThis is a way to add leading zeros in R\n<code>\ngsub(\"(.{8})\", \"\\\\\
    10\\\\1\", num<-as.numeric(c(12, 12, 12)))\n[1] \"0000000012\" \"0000000012\"\
    \ \"0000000012\"\n</code>\n<|/ a dscore=4 |>\n<| a tags=r,string-concatenation\
    \ |>\nA solution in base R using format and sprintf.\n<code>\nx <- c(12, 12, 12)\n\
    sprintf(\n  \"%0*d\", \n  max(length(x), nchar(x)), \n  paste0(\"0000000000\"\
    , x)\n)", "\n  return(substr(x, 1, nchar(as.integer(x)) - n + shift))\n}\n</code>\n\
    <|/ a |>\n<| a dscore=3 |>\nYou could use regex\n<code>\nsub(\"(.{3})(..)\", \"\
    \\\\1\\\\2\", \"123\")\n[1] \"123\"\n</code>\nOr, if you need an extra level of\
    \ nesting, use backreference:\n<code>\nsub(\"(.{3})(..)\", \"\\\\1\\\\2\", \"\
    123\")\n[1] \"123\"\n</code>\n<|/ a tags=string,r |>\n<| c |>\n+1 But it would\
    \ be nice to have a complete explanation of what's going on in each of your examples.\n\
    <|/ c |>\n<| c |>\nThanks, I added a brief explanation.\n<|/ c |>\n<| a |>\n<code>\n\
    gsub(\"(.{3})(.)\", \"\\\\1\\\\2\", \"123333\")\n</code>\n<|/ a dscore=3 tags=string,r\
    \ |>\n<| c |>\n+1 for the use of back-references, however note that this doesn't\
    \ quite work in all cases. E.g., the replacement would need to be `\"\\\\1\\\\\
    2\"` instead of `\"\\\\1\\\\23\"`.\n<|/ c |>\n<| c |>\nI think that's true but\
    \ I'm not sure that OP wants to handle that. My answer assumes that if someone\
    \ does want to handle that they know what to do.\n<|/ c |>\n<| c |>\nIt's a really\
    \ bad assumption to make, and is just going to confuse people (and lead them to\
    \ asking another question). :)\n<|/ c |>\n<| a tags=string,r dscore=3 |>\nTo generalize\
    \ it a little bit:\n<code>\ngsub('(.{3})(.)(.)', \"\\\\2\\\\3\", \"123333\", perl=T)\n\
    [1] \"1233333\"\n</code>\n<|/ a |>\n<| c |>\n+1 for the use of back-references,\
    \ however note that this doesn't quite work in all cases. E.g., the replacement\
    \ would need to be `\"\\\\1\\\\2\"` instead of `\"\\\\1\\\\23\"`.\n<|/ c |>\n\
    <| a tags=string,r |>\nHere is an additional solution which handles special characters\
    \ by adding them to the character vector:\n<code>\nfun <- function(s, n, ...)\
    \ {\n   if(nchar(n) != length(s)) stop(\"The specified number of characters is\
    \ not a whole number\")\n   if(n <= 1) stop(\"The specified number of characters\
    \ must be greater than one\")\n   c <- nchar(as.integer(s))\n   if(n <= ", "\n\
    \  if (shift > nchar(x)) return(rev(x)); # shift is greater than number of digits\n\
    \  digits_shift <- floor(log10(abs(x))); # Number of digits of x shifted by shift\n\
    \  return(\n    paste(rev(x), # Reverse the digits\n           substring(x, 0,\
    \ digits_shift), # Take first digits of x\n           substring(x, digits_shift,\
    \ nchar(x)) # Take remaining digits\n    )\n  )\n}\n", "\n  if (shift > log10(length(x)))\
    \ {\n    x <- round(x, digits = -shift)\n  } else {\n    x <- round(x, digits\
    \ = -shift + 1)\n  }\n  paste0(x[-seq_len(abs(shift))], x[seq_len(-abs(shift))])\n\
    }\n", "\n  paste0(ifelse(shift > length(x), \n                 substring(x, 1,\
    \ (length(x) - shift)), reverse(substring(x, (length(x) - shift), 1)) + substring(\n\
    \                   x, 1, shift),\n                 substring(x, 1, shift))\n\
    \  )\n}\n</cell>\n<cell>", "\n  x = x * 10^shift\n  x <- as.character(x)\n  x[length(gregexpr(\"\
    \\\\G\\\\d\", x)[[1]])] <- paste0(x[length(gregexpr(\"\\\\G\\\\d\", x)[[1]])],\
    \ substr(x, 1, length(gregexpr(\"\\\\G\\\\d\", x)[[1]])))\n  substr(x, 1, length(gregexpr(\"\
    \\\\G\\\\d\", x)[[1]])) + substr(x, length(gregexpr(\"\\\\G\\\\d\", x)[[1]]),\
    \ nchar(x))\n}\n</cell>\n<code language=conda-env-py3_physeq-r>\nx <- as.data.frame(matrix(c(1:4,\
    \ -4:1), ncol=2, byrow=TRUE))\ncolnames(x) <- c('y', 'x')\nhead(x)\n</cell>\n\
    <code language=conda-env-py3_physeq-r>\nlibrary(ggplot2)\nggplot(x, aes(x=x, y=y))\
    \ + geom_point(alpha=0.5, size=1, position='jitter') + theme_bw()\n</cell>\n<code\
    \ language=conda-env-py3_physeq-r>\nggplot(x, aes(x=x, y=y)) + geom_point(alpha=0.5,\
    \ size=1, position='jitter') + theme_bw() + coord_flip(ylim=c(-5, 5)) # reverse\
    \ y-axis\n</cell>\n<code language=conda-env-py3_physeq-r>\nx <- as.data.frame(matrix(c(1:4,\
    \ -4:1), ncol=2, byrow=TRUE))\ncolnames(x) <- c('y', 'x')\nhead(x)\n</cell>\n\
    <code language=conda-env-py3_physeq-r>\nggplot(x, aes(x=x, y=y)) + geom_point(alpha=0.5,\
    \ size=1, position='jitter') + theme_bw() + coord_flip() # reverse y-axis\n</cell>\n\
    <code language=conda-env-py3_physeq-r>\nggplot(x, aes(x=x, y=y)) + geom_point(alpha=0.5,\
    \ size=1, position='jitter') + theme_bw() + coord_flip(ylim=c(5, -5)) # reverse\
    \ y-axis\n</cell>\n<code language=conda-env-py3_physeq-r>", "\n  as.integer(gsub(\"\
    ^(..?)0+(.{1})\", \"\\\\2\\\\1\", as.character(x)))\n}\n", "\n  \n  n <- nchar(x)\n\
    \  \n  if (n == 0) {\n    return(\"\")\n  }\n  \n  digits <- as.numeric(as.character(x))\n\
    \  digits <- digits[1:(n - shift + 1)]\n  \n  return(paste(digits, rev(digits),\
    \ sep=\"\"))\n  \n}\n</code>\n<|/ a |>\n<| a tags=function,r,digits |>\nA solution\
    \ with base R:\n<code>\nn <- 12\n\nformatC(\n  c(1:n),\n  format = \"d\",\n  big.mark\
    \ = \".\",\n  digits = 3\n)\n</code>\ngives\n<code>\n[1] \"1.2.3\"\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=function,r,digits dscore=1 |>\nHere are some functions\
    \ using formatC:\n<code>", "\n    digits_len <- floor(log(x, 10))\n    digits\
    \ <- ifelse(shift == digits_len, x, 0L)\n    digits <- digits %% 10\n    digits\
    \ <- c(digits, rep(0L, digits_len - length(digits)))\n    paste(rep(digits, floor(digits_len/2)),\
    \ collapse = \"\")\n}\n", "\n  require(base);\n  if(shift > length(x)) {\n   \
    \ stop(sprintf(\"Shift %d out of range for length %d\", shift, length(x)));\n\
    \  }\n  \n  x <- as.character(x);\n  x <- substr(x, 1, length(digits(x)) + shift);\n\
    \  x <- paste0(substr(x, 1, 1), substr(x, 2, nchar(x) - 2));\n  return(x);\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThanks Nick. I think this is a good answer,\
    \ but I was thinking that there would be some kind of builtin function in base\
    \ R for this. I was hoping there was some function like `circular_shift`.\n<|/\
    \ c |>\n<| c |>\nThis is not the desired answer.  You just need `circular_shift(as.character(x),\
    \ 1)` but this is an answer to the question \"How do you do this\".  It doesn't\
    \ answer the question \"How does this function work?\"\n<|/ c |>\n<| c |>\nThanks\
    \ Nick, that is correct.  I was thinking that the answer was \"Because it works\"\
    .  As you point out though, this is not a question that should be asked in an\
    \ SO answer - it should be a separate Q&A.\n<|/ c |>\n<| a |>\nAs I noted in a\
    \ comment on the accepted answer, the answer is \"Because it works\".  However,\
    \ I wanted to show you how to test this function.  I thought it would be useful\
    \ to include the tests and the expected results from the R code in the answer\
    \ as well, so I wrote a separate answer.\nThe test is as follows (I took Nick's\
    \ answer and added the tests):\n<code>\nlibrary(utils)", "\n  x <- as.character(x)\n\
    \  shift <- as.integer(shift)\n  if(shift > length(x)) return(rev(x))\n  \n  if(is.na(x)\
    \ || is.na(shift)) return(x)\n  \n  if(x == \"0\") return(\"0\")\n  \n  x <- as.integer(x)\n\
    \  shift <- as.integer(shift)\n  \n  n <- max(length(x), shift)\n  digits <- as.numeric(as.character(x))\n\
    \  \n  if(x%%1 == 0) digits <- digits - 1\n  \n  x <- digits + x\n  \n  digits\
    \ <- digits - shift\n  \n  x <- paste0(digits, x)\n  \n  if(nchar(digits) > shift)\n\
    \    return(rev(x))\n  \n  return(x)\n}\n", "\n  div <- function(x, n) {\n   \
    \ while(n > 0) {\n      x <- floor(x/n) * 10 + (x%n == 0)\n      n <- n - 1\n\
    \    }\n    return(x)\n  }\n  if (shift <= 0) return(paste(x, collapse = \"\"\
    ))\n  return(paste(div(x, shift), rev(x), collapse = \"\"))\n}\n\ncircular_shift(10,\
    \ 5)", "\n  stopifnot(is.integer(x), is.integer(shift))\n  len <- ceiling(log10(x))\n\
    \  digits <- sprintf('%0*d', len, x)\n  return(paste(substr(digits, 1, -shift),\
    \ substr(digits, -shift+1)))\n}\n</cell>\n<text>\nC. Sentiment Analysis\n\n</text>\n\
    <text>\nIn this exercise, we'll use reticulate to analyze sentiment of tweets.\
    \ First, we'll import the necessary libraries.\n\n\n</text>\n<cell>\nlibrary(twitteR)\n\
    library(magrittr)\nlibrary(reticulate)\n</cell>\n<text>\nA. Load Twitter API credentials\n\
    \n</text>\n<text>\nIn order to analyze sentiment, you need to authenticate with\
    \ Twitter. You can do this by visiting Twitter's website and signing in with your\
    \ Twitter account. Once you've done so, you'll be given your API access credentials.\
    \ You'll store these in an appropriately named file that you can later upload\
    \ to Github for your use.\n\n\n</text>\n<text>\nOnce you have your Twitter credentials,\
    \ you'll set the api_key and api_secret fields in the following cell to those\
    \ credentials.\n\n\n</text>\n<cell>\napi_key <- \"YOUR API KEY\"\napi_secret <-\
    \ \"YOUR API SECRET\"\naccess_token <- \"YOUR ACCESS TOKEN\"\naccess_token_secret\
    \ <- \"YOUR ACCESS TOKEN SECRET\"\n</cell>\n<text>\nB. Load Twitter API\n\n</text>\n\
    <text>\nReticulate will automatically find the Twitter API credentials once you\
    \ run library(twitteR). To avoid running this command repeatedly, you can set\
    \ the credentials fields of api_key and api_secret to values returned from reticulate::get_oauth().\
    \ These values are:\n\napi_key\napi_secret\naccess_token\naccess_token_secret\n\
    \nIn order to load your Twitter API credentials, set the api_key and api_secret\
    \ fields of your Twitter credentials object.\n\n\n</text>\n<cell>\ncredentials\
    \ <- reticulate::get_oauth(\n  \"twitter\",\n  api_key, api_secret, access_token,\
    \ access_token_secret\n)\n</cell>\n<text>\nC. Twitter API call\n\n</text>\n<text>\n\
    Now you'll write a function that makes a Twitter API call for some Twitter search.\
    \ You'll give it a search term, an optional number of results, and an optional\
    \ geographic restriction. It will return a dataframe with a column containing\
    \ the search term, a column containing some sentiment scores, and a column containing\
    \ a datestamp indicating when each twe", "\n    char(x) %>% \n        as.integer[1:(length(as.character(x))-(shift+1))]\
    \ %>%\n        sapply(function(z) z[(1+shift+1):(length(z)+shift)], USE.NAMES=FALSE)\
    \ %>%\n        paste0(collapse=\"\") %>%\n        as.character()\n}\n", "\n  num\
    \ <- floor(log10(x)) + 1L\n  out <- as.character(x)\n  out <- ifelse(num > shift,\
    \ substr(out, 1L, num - shift+1L), out)\n  out <- paste0(out, '0')\n  out <- substr(out,\
    \ 1L, num + shift-1L)\n  return(out)\n}\n", "\n  out <- as.character(x)\n  if\
    \ (length(x) > shift) {\n    digits_to_shift <- floor(log(length(out), shift))\
    \ + 1\n    out <- substring(out,1,digits_to_shift) + substring(out,digits_to_shift+1,\
    \ length(x))\n  } else if (length(x) < shift) {\n    digits_to_shift <- floor(log(length(out),\
    \ shift))\n    out <- substring(out,1,digits_to_shift) + substring(out,digits_to_shift+1,\
    \ length(x))\n  }\n  return(out)\n}\n</code>\nI did this with a helper function\
    \ circular_shift, but you could simply use substring and specify the desired number\
    \ of characters.\n<|/ a dscore=3 tags=r,r-faq,regex |>\n<| c |>\nThanks for your\
    \ answer. Your solution is very close to what I needed (I modified the definition\
    \ of `circular_shift` to include a `shift` argument, which allows you to choose\
    \ the right number of digits to be shifted. I will post my own answer shortly.\
    \ Still I wonder whether there is a standard solution in R that does it all for\
    \ me. Anyway, your solution is very clever and I learned something new about R!\n\
    <|/ c |>\n<| a dscore=2 |>\nHow about this?\n<code>", "\n  x <- as.character(x)\n\
    \  if (shift < 0) shift <- -shift\n  len <- length(digits(x))\n  digits <- substr(x,\
    \ 1, len)\n  paste0(substr(digits, 1, len - shift), substr(digits, len - shift,\
    \ len))\n}\n", "\n    x <- as.character(x)\n    x <- substr(x, 1, shift - 1)\n\
    \    x <- paste(x, substr(x, shift, nchar(x)))\n    x <- paste0(substr(x, 1, 1),\
    \ substr(x, 2, nchar(x)))\n    x <- paste0(x, substr(x, shift, nchar(x)))\n  \
    \  return(x)\n}\n", "\n  x <- as.integer(x)\n  if (shift > length(x)) return(rev(as.integer(x)))\n\
    \  res <- paste(rev(as.integer(x)), collapse=\"\")\n  len <- length(res)\n  if\
    \ (shift < len) res <- paste0(substr(res, 0, shift), substr(res, shift, len))\n\
    \  else res <- substr(res, 0, shift)\n  return(res)\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=string,r,substring |>\nThis should work\n<code>\nx <- 'abcdefgh'\nsubstr(x,1,1)\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis is still not working, you forgot the\
    \ `substr` function.\n<|/ c |>\n<| c |>\nSorry, I fixed my answer. Thanks.\n<|/\
    \ c |>\n<| a |>\nThe same method as Henrik, but without creating a new object.\n\
    <code>\nsubstr('abcdefgh',1,1)\n</code>\n<|/ a dscore=1 tags=string,r,substring\
    \ |>\n<| a |>\nWe can use the stringr package:\n<code>\nlibrary(stringr)\nstr_sub('abcdefgh',\
    \ 1, 1)\n</code>\n<|/ a dscore=0 tags=string,r,substring |>\n<| a tags=string,r,substring\
    \ |>\nYou could also use substr instead of substr as follows:\n<code>\nx <- \"\
    abcdefgh\"\nsubstr(x, 1, 1)\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n\
    library(stringr)\nx <- \"abcdefgh\"\nstr_sub(x,1,1)\n</code>\n<|/ a tags=string,r,substring\
    \ |>\n<| a dscore=0 tags=string,r,substring |>\nYou can use substring function\
    \ to get substring in R. \n<code>\nsubstr(vector,start,end)\n</code>\nThe start\
    \ argument is inclusive while the end argument is exclusive. The default is to\
    \ start at the start of the string.\n<|/ a |>\n<| a dscore=0 |>\nUse strsplit\
    \ to split your string by it's first character and take the substring of this\
    \ list:\n<code>\n> strsplit(x, \"[\")[[1]][1]\n[1] \"a\"\n</code>\n<|/ a tags=string,r,substring\
    \ |>\n<| a dscore=0 tags=string,r,substring |>\nIn addition to the previous answers,\
    \ you can also use substring. \n<code>\nsubstring <- function(string, start, stop){\n\
    \   sub <- substr(string, start, stop)\n   return(sub)\n}\n</code>\n<|/ a |>\n",
  "\n  if(x == 0) {\n    return(0)\n  }\n  if(shift > length(x)) {\n    x <- rev(as.character(x))\n\
    \    shift <- length(x)\n  }\n  x <- paste0(floor(x/10), x, rev(floor(x%%10)))\n\
    \  return(substr(x, 1, shift))\n}\n</cell>\n<text>\nNow that we have written a\
    \ function for the task, we need to write a wrapper to handle the task. The wrapper\
    \ should accept 2 arguments: dataset and column name.\nThe function should return\
    \ the output from the function.\nThe function should filter data based on column\
    \ value.\nThe function should handle NA values.\n\n\n</text>\n<cell>", "\n  x\
    \ <- as.character(x)\n  digits <- unlist(strsplit(x, \"\\\\D\"))\n  res <- c()\n\
    \  for(i in 1:(length(digits)-shift)) {\n    res <- c(res, paste0(digits[i+(shift):i],\
    \ collapse = \"\"))\n  }\n  res <- c(res, paste0(digits[-(shift+1):(length(digits)-shift)],\
    \ collapse = \"\"))\n  paste0(res, collapse = \"\")\n}\n</code>\n<|/ a tags=r,string\
    \ |>\n<| c |>\nThanks, this is a very nice solution. I think it would be worthwhile\
    \ to add some comments to explain why it works.\n<|/ c |>\n<| c |>\nThe `unlist(strsplit(...))`\
    \ is simply converting the string to a vector, collapsing each character into\
    \ a single string `paste0(\"12\", collapse = \"\")` returns the string `12`. `paste0()`\
    \ collapses the vector into a single string `paste0(..., collapse = \"\")` returns\
    \ `12` again.\n<|/ c |>\n<| c |>\nThis is very useful to know. Can anyone give\
    \ a brief overview of how this works?\n<|/ c |>\n<| a tags=r,string |>\nHere is\
    \ a solution for strings with repeating characters.  It is a slight variation\
    \ of my first answer that uses strsplit() with a negative value for the second\
    \ argument.  Since we only want to keep the last of the duplicates, we then loop\
    \ through each of the elements and add them to the result string one at a time.\n\
    <code>\nlibrary(stringr)\n", "\n  sapply(seq(shift), function(i) x[i:(length(x)-shift)+i])\n\
    }\n", "\n  len <- ceiling(log10(x))\n  shift <- floor(shift)\n  out <- \"\"\n\
    \  for(i in 0:len) {\n    out <- c(out, floor(x / 10^(i - shift)))\n    x <- x\
    \ %% 10^(i - shift)\n  }\n  return(out)\n}\n</cell>\n<cell>", "\n    x <- ifelse(x\
    \ < 0, -x, x)\n    sprintf(\"%d%+d%s\", x, (x %% 1) * pow(10, (shift * -1)), \n\
    \        paste(0:((floor(log10(x)) + 1) * -1)))\n}\n</code>\n<|/ a tags=integer,r,dataframe\
    \ dscore=0 |>\n<| a |>\nIn case this is of use to anyone else, I went with Gregor's\
    \ answer but implemented the function with a for loop, which was more intuitive\
    \ to me. Here's what I came up with: \n<code>", "\n  if (shift > length(x)) return(rev(as.character(x)));\n\
    \  c(substring(as.character(x), 1, shift - 1),\n    substring(as.character(x),\
    \ shift, length(x)))\n}\n</code>\n<|/ a |>\n<| c |>\nA function like this would\
    \ be great to have in an R package or something.\n<|/ c |>\n<| c |>\n: Feel free\
    \ to open an issue requesting this function. I haven't realized its usefulness\
    \ yet, so I might as well open it now.\n<|/ c |>\n<| c |>\n: Okay, done and done.\n\
    <|/ c |>\n<| c |>\n: Nice, thanks.  I wasn't aware of such a function before,\
    \ but now I see how it can be used to solve this problem.\n<|/ c |>\n<| a |>\n\
    As noted by the other answers, this has been addressed by an R package called\
    \ stringi.  It is available from GitHub using devtools::install_github(\"moodymudskipper/stringi\"\
    ) (from ?stringi), or from CRAN using devtools::install_version(\"stringi\",\"\
    1.9.3\") (from ?stringi).\nIt is also available from CRAN as stringi at version\
    \ 1.4.0 from MRAN (as pointed out in the comments by).  If it is available, you\
    \ should prefer that over stringr::str_shift.  It is also available from GitHub\
    \ (as stringi_1.4.0).  If you prefer to use stringr, you can install the devtools\
    \ package to install the stringr version.  If you prefer to install stringi from\
    \ GitHub, there is a new version available at GitHub (as stringi_1.4.1.9009).\
    \  \n<code>\ninstall.packages(\"stringi\", repos = c(\"http://cran.us.r-project.org\"\
    , \n                                        \"http://cran.r-project.org\"))\n\
    </code>\nor \n<code>\ndevtools::install_github(\"moodymudskipper/stringi\")\n\
    </code>\nIf you would prefer to use stringi but are using an older R version (3.x.x)\
    \ than stringr was built in, you can install the stringi version using stringi\
    \ v1.4.0 from MRAN (as pointed out in the comments by)\n<code>\nlibrary(stringi)\n\
    </code>\nor \n<code>\nlibrary(stringi)\ninstall.packages(\"stringi_v1.4.0\", repos\
    \ = c(\"http://cran.us.r-project.org\", \n                                   \
    \     \"http://cran.r-project.org\"))\n</code>\nIf you would prefer to install\
    \ stringi from GitHub, there is a new version available at GitHub (as string",
  "\n  digits <- str_split(as.character(x), \"(?<=\\\\G.{1})\")[[1]][-shift]\n  paste0(rev(c(digits,\
    \ rep(\"\", shift))), collapse = \"\")\n}\n</code>\n<|/ a tags=r,stringr dscore=1\
    \ |>\n<| c |>\nThis one works just like my `circular_shift`, but you added an\
    \ extra `digits` variable and used `str_replace_all` instead of `str_replace`.\n\
    <|/ c |>\n<| c |>\nThanks for that catch. It was a mistake. Fixed.\n<|/ c |>\n\
    <| a |>\nThis is an alternative answer that doesn't use stringr or stringi, but\
    \ I believe it's easier to read:\n<code>\nxx <- c(paste0(\"0\", seq_along(digits)),\
    \ paste0(rev(digits), seq_along(digits)))\npaste0(rev(xx), paste0(digits, seq_along(digits)))",
  "\n  if (shift < -length(x))\n    stop(paste(\"Shift must be >= 0\", sep = \"\"\
    ))\n\n  # Circularly shift by shift digits, using digits and rev to reverse\n\
    \  # the digits if shift is positive, and digits and rev to reverse the\n  # digits\
    \ if shift is negative.\n  digits <- as.integer(x)\n  rev(digits) %/% abs(shift)\
    \ %*% digits[1L] + (\n    shift(rev(digits)) %*% digits\n  )\n}\n", "\n  digits\
    \ <- as.integer(format(x, \"d\"))\n  if (shift <= length(digits)) return(paste0(digits,\
    \ rev(digits), sep=\"\"))\n  out <- integer(length(digits))\n  start <- 1\n  end\
    \ <- 1\n  shift <- length(digits) - shift\n  while (start <= shift) {\n    out[start]\
    \ <- digits[end]\n    start <- start + end\n    end <- start + shift\n  }\n  out\n\
    }\n", "\n  if (shift > length(x)) {\n    c(tail(digits(x), -shift), head(x, -shift))\n\
    \  } else {\n    c(head(x, -shift), tail(digits(x), -shift))\n  }\n}\n</code>\n\
    The idea is very simple: just convert it to an integer, shift it, then convert\
    \ it back.\n(Note that this doesn't produce decimal digits; you can multiply or\
    \ divide by 10 afterwards if necessary.)\n<|/ a |>\n<| c |>\nThanks, I haven't\
    \ realized that this question was unanswered for so long. I am still trying to\
    \ figure out how this works, but I'm getting a lot of good answers here.\n<|/\
    \ c |>\n<| c |>\nI should add that this works with negative numbers as well. My\
    \ test data was a little confusing because I was using integers, but that doesn't\
    \ really matter for your answer.\n<|/ c |>\n<| a tags=c++,r,algorithm dscore=2\
    \ |>\nIf speed is of concern, one might use gmp as an intermediate step.\nA simple\
    \ example with integers.\n<code>\nlibrary(gmp)\nx <- as.integer(as.character(\"\
    7401033623\"))\nx", "\n  if (shift == 0)\n    return('')\n  else if (shift > nchar(x))\n\
    \    return(rev(x)[1:(shift - nchar(x))])\n  else\n    return(paste(as.integer(x),rev(as.integer(x)):(shift\
    \ - nchar(x))), sep='')\n}\n", "\n  if (shift > length(x)) {\n    x <- x[length(as.integer(x))\
    \ + shift:1]\n  } else {\n    x <- c(x, rep(NA, shift(-length(x))))\n  }\n  paste0(tail(x,\
    \ -shift), head(x, shift))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks Roman\
    \ - that works well.  But I don't understand why my version produces different\
    \ results.  I've just started with R, any thoughts?\n<|/ c |>\n<| c |>\n- I added\
    \ some explanation, and an example for the first few digits of circular_shift\
    \ output.\n<|/ c |>\n<| a tags=r,mathematical-optimization dscore=1 |>\n<code>\n\
    circular_shift <- function(x){\n  x <- as.integer(x)\n  xx <- c(x, rep(NA, length(x)+1))\n\
    \  return(paste0(substr(xx, 1, 2), substr(xx, 3, 5)))\n}\n\ncircular_shift(c(1,13,13,1))\n\
    [1] \"1213131\"\n\ncircular_shift(c(1,13,13,1))\n[1] \"11213131\"\n\ncircular_shift(c(1,13,13,1))\n\
    [1] \"11213131\"\n\ncircular_shift(c(1,13,13,1))\n[1] \"11213131\"\n\ncircular_shift(c(1,13,13,1))\n\
    [1] \"11213131\"\n\ncircular_shift(c(1,13,13,1))\n[1] \"11213131\"\n\ncircular_shift(c(1,13,13,1))\n\
    [1] \"11213131\"\n\ncircular_shift(c(1,13,13,1))\n[1] \"11213131\"\n\ncircular_shift(c(1,13,13,1))\n\
    [1] \"11213131\"\n</code>\n<|/ a |>\n<| c |>\nThanks Roman - that works well.\
    \  But I don't understand why my version produces different results.  I've just\
    \ started with R, any thoughts?\n<|/ c |>\n<| c |>\nThe other solutions have `NA`\
    \ as the first digit.  So they should also have `NA` as the first digit when you\
    \ start with `1`.\n<|/ c |>\n<| a tags=r,mathematical-optimization |>\n<code>\n\
    library(stringr)\n", "\n  n <- floor(x/10)\n  y <- x %% 10\n  z <- paste0(y,\n\
    \             ifelse(n < (shift + 1), \n                    paste0(shift(n), collapse\
    \ = \"\"),\n                    paste0(rev(shift(n)), collapse = \"\")))\n  z\
    \ <- paste(rev(z), rep(\"\", (shift + 1) - n))\n  z\n}\n</code>\nThis function\
    \ takes three parameters: the integer, the number of digits before the shift\n\
    to circularly shift (default 10); the number of shifts (default 1); the optional\
    \ shift parameter\n(default 1).\nThe function takes two nested ifelse statements\
    \ --\nthe first statement tests whether the integer is less than the shift and,\
    \ if so, takes\nthe first shift digits (shift(n)) and concatenates them to the\
    \ output (paste0(shift(n), collapse = \"\"))\nThe second statement reverses the\
    \ shift digits (rev(shift(n)) and concatenates them to the output (paste0(rev(shift(n)),\
    \ collapse = \"\"))\nIf the integer is greater than the shift, then the first\
    \ shift digits of the integer are returned\n(rev(shift(n)))\nIf the integer is\
    \ greater than the shift, then all shift digits are reversed\n(paste0(rev(shift(n)),\
    \ collapse = \"\"))\nIf the integer is less than the shift, then the integer is\
    \ returned without modification\n(the second paste0 in the function).\nThe first\
    \ paste0 concatenates the shift digits with collapse\nand the second paste0 concatenates\
    \ the reversed shift digits with collapse\nThe third paste0 concatenates all shift\
    \ digits with collapse\nThe second paste0 concatenates the reversed shift digits\
    \ with collapse\nThe final paste0 concatenates all output digits with collapse\n\
    Test runs:\n<code>\n> circular_shift(1234, 1)\n[1] \"2341\"\n> circular_shift(1234,\
    \ 2)\n[1] \"3412\"\n> circular_shift(1234, 3)\n[1] \"4321\"\n> circular_shift(1234,\
    \ 4)\n[1] \"1234\"\n</code>\n<|/ a tags=circular-shift,python,r dscore=2 |>\n\
    <| a |>\nBased on the answers and comments from and, I have produced the following\
    \ function which works pretty well on all integer sizes.\n<code>\ncircular_shift\
    \ <- function(number, shift) {\n  if(shift==0) return(number)\n  digits = as.integer(log(number,\
    \ 10) + shift)\n  digit_lengths = cut(digits, c(-Inf, max(digits), Inf))\n  digit_lengths\
    \ = paste(digit_lengths, collapse = '')\n  digit_length = length(digit_lengths)\n\
    \  digits_left = digits - ", "\n    shift_digits <- function(x, shift) {\n   \
    \     digits <- strsplit(as.character(x), '')[[1]]\n        if (shift > length(digits))\
    \ {\n            rev(digits)\n        } else {\n            digits[seq(shift,\
    \ length = length(digits))]\n        }\n    }\n    shift_digits(x, shift) %>%\
    \ unlist()\n}\n", "\n  n <- length(x)\n  if(shift > n) \n    x <- paste(rev(substr(x,\
    \ 1, n)), collapse=\"\")\n  else\n    x <- substr(x, 1+(shift-n), n)\n  return(x)\n\
    }\n", "\n  s <- sprintf(\"%%0%dd\", abs(shift))\n  paste0(rev(x), s)\n}\n</code>\n\
    A nice thing about this approach is that we can actually use any function that\
    \ works when applied to a single number to produce a function that works on a\
    \ list of numbers. For example, if we wanted to create a list of all the prime\
    \ numbers less than or equal to 100, we could just do this:\n<code>\nprimes <-\
    \ function(n) {\n  x <- 1\n  while (x <= n) {\n    if (all(x %% i != 0L)) x <-\
    \ x + 1\n    else x <- x + 2\n  }\n  return(x)\n}\n</code>\nAnd then we can easily\
    \ create a list of all the prime numbers less than or equal to 100:\n<code>\n\
    primes(100)", "\n    if (shift > length(x)) return(tail(x, -shift))\n    if (shift\
    \ < 0) return(head(x, -shift))\n    paste(head(x, shift), tail(x, shift), sep=\"\
    \", na.rm = TRUE)\n}\n</code>\nBenchmarks\n<code>\nlibrary(microbenchmark)\nmicrobenchmark(\n\
    \  original = {\n    x <- 12\n    circular_shift(x, 1)\n  },\n  base = {\n   \
    \ x <- 12\n    x %>% as.numeric() %>% circular_shift(1)\n  }\n)\nUnit: milliseconds\n\
    \  expr         min           lq        mean      median          uq         max\
    \ neval\n original 140.7959585 148.7241220 170.7439303 157.0400275 175.5253031\
    \ 198.587706   100\n    base 184.5894475 195.5623626 233.4956213 207.4153700 231.8860877\
    \ 259.594181   100\n</code>\n<|/ a tags=dataframe,r |>\n<| c |>\nVery clever approach.\
    \ I don't understand why I get the error: \"Error in FUN(X[[i]], ...) : \n  unused\
    \ argument (digits = 2) \" when I run this on my data.\n<|/ c |>\n<| c |>\nThat's\
    \ a good point. I've updated my answer to use the `digits` argument, though this\
    \ may still be slower than `circular_shift`.\n<|/ c |>\n<| c |>\nI get the following\
    \ error when using your code: Error in FUN(X[[i]], ...) : \n  unused argument\
    \ (digits = 2)\n<|/ c |>\n<| c |>\nWhat do you get if you run `str(x)`?\n<|/ c\
    \ |>\n<| c |>\nI get: num [1:24] 1 2 3 4 5 6 7 8 9 10 ...\n<|/ c |>\n<| a dscore=3\
    \ |>\nIt seems you are wanting to circularly shift each value in your data frame\
    \ by a given amount:\n<code>\n> x <- 12\n> circular_shift(x, 1)\n[1] 12\n</code>\n\
    Your data frame is named df, and this can be easily done using lapply from base\
    \ R:\n<code>\n> df$CircularShift <- lapply(df, function(x) {circular_shift(x,\
    \ 1)})\n> df\n   CircularShift\n1             12\n2             12\n3        \
    \     12\n4             12\n5             12\n6             ", "\n  # Return digits\
    \ reversed\n  if (shift == 0) {\n    return(x)\n  }\n  if (shift > length(x))\
    \ {\n    return(rev(x))\n  }\n\n  digits <- integer(length(x))\n  for (i in 1:(shift\
    \ - 1)) {\n    digits[i] <- x[length(digits) - i - 1]\n  }\n  return(rev(digits))\n\
    }\n", "\n  if (shift > length(x)) return (x) \n  else return(paste(rev(substr(x,\
    \ 1, shift + 1)), collapse = \"\"))\n}\n", "\n  if (shift < -length(x)) {\n  \
    \  return(rev(x))\n  }\n\n  digits <- c(x, 0)\n  shift <- min(abs(shift), length(digits)\
    \ - 1)\n\n  for (i in 1:shift) {\n    digits[i] <- digits[i] * 10 + digits[i -\
    \ 1]\n  }\n\n  return(paste(rev(digits[shift:length(digits)])))\n}\n", "\n   \
    \ require(base)\n    n <- length(x)\n    shift <- as.integer(shift)\n    digits\
    \ <- as.integer(\n        round(\n            10^\n                floor(log(10^(n\
    \ + shift), 10)) - floor(log(10^n, 10))\n        )\n    )\n    s <- rev(digits)\n\
    \    paste0(\n        s,\n        paste0(\n            tail(digits, -(n %% shift)),\n\
    \            if((n %% shift) > 0) tail(x, -((n %% shift) + 1)),\n            if((n\
    \ %% shift) < 0) tail(x, -(n + shift))\n        )\n    )\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nGood use of R's log function.\n<|/ c |>\n<| a dscore=2 |>\nHere\
    \ is my answer:\n<code>\n myfun <- function(x) {\n  myfun2 <- function(x, n) {\n\
    \    t <- floor((log(x, 10))/log(10))\n    a <- 10^t\n    b <- 10^((t-n)*10)\n\
    \    y <- log10(x)/log10(a)\n    y <- a*floor(y+(b*(floor(y)-1)))\n    y <- ifelse(y\
    \ > 1, trunc(y), trunc(y)-1)\n    return(y)\n  }\n\n  num <- floor(x)\n  res <-\
    \ myfun2(num,n)\n  res <- ifelse(res > 1, trunc(res), trunc(res)-1)\n  return(res)\n\
    }\n</code>\nTest for myfun:\n<code>\nmyfun(6)\n[1] 4\n\nmyfun(8)\n[1] 4\n\nmyfun(10)\n\
    [1] 4\n\nmyfun(30)\n[1] 6\n\nmyfun(50)\n[1] 9\n</code>\nTest for myfun2:\n<code>\n\
    myfun2(6,3)\n[1] 3\n\nmyfun2(8,3)\n[1] 3\n\nmyfun2(10,3)\n[1] 3\n\nmyfun2(30,3)\n\
    [1] 6\n\nmyfun2(50,3)\n[1] 8\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nHere is\
    \ another solution (using the same function):\n<code>\ncircular_shift <- function(x,\
    \ n) {\n  n <- floor(log(x, 10))\n  as.numeric(paste(10^seq(floor(log10(n)), n,\
    \ by = -10), collapse = ''))\n}\n\n> circular_shift(6, 3)\n[1] 3\n> circular_shift(8,\
    \ 3)\n[1] 3\n> circular_shift(10, 3)\n[1] 3\n> circular_shift(30, 3)\n", "\n \
    \   x <- as.numeric(x)\n    shift <- as.numeric(shift)\n    len <- length(x)\n\
    \    if (shift >= len) {\n        return(paste(rev(x), collapse=\"\"))\n    }\n\
    \    if (shift < -len) {\n        return(paste(rev(x), collapse=\"\"))\n    }\n\
    \    res <- c(x[shift:len])\n    while (shift > 0) {\n        shift <- shift -\
    \ 1\n        res <- c(res, x[-shift])\n    }\n    return(paste(res, collapse=\"\
    \"))\n}\n", "\n  xx <- as.character(x)\n  if (shift > length(digits(x))) {\n \
    \   xx <- paste(tail(xx, -(shift-length(digits(x)))), reverse(head(xx, -(shift-length(digits(x))))))\n\
    \  }\n  xx\n}\n</code>\n<|/ a |>\n<| a |>\nI have another approach for you\n<code>\n\
    a <- c(9, 10, 11, 12)\nb <- c(12, 10, 11, 9)\n</code>\nFirst we can get the difference\
    \ in the lengths of the vectors by:\n<code>\ndiff_a <- length(a) - length(b)\n\
    diff_b <- length(b) - length(a)\n</code>\nThen, we can use cbind to get all possible\
    \ combinations:\n<code>\ncombs <- expand.grid(a, b, stringsAsFactors=FALSE)\n\
    </code>\nThen, we can get the differences between each row and each column by:\n\
    <code>\ndiff_a_c <- combs$V1 - combs$V2\ndiff_b_c <- combs$V3 - combs$V4\n</code>\n\
    And then combine these three vectors:\n<code>\ncombined_vector <- c(diff_a_c,\
    \ diff_b_c)\n</code>\nFinally, we get the positions where the difference is positive:\n\
    <code>\npos_diff <- which(combined_vector > 0, arr.ind=TRUE)\n</code>\nAnd then\
    \ we get the number of times this happens:\n<code>\nnumber_of_times <- unlist(lapply(seq_len(length(pos_diff)),\
    \ function(x) \n  sapply(pos_diff[,x], function(y) length(unique(b[y[,2]:y[,3]])))\n\
    ))\n</code>\nAnd finally we get the vector positions:\n<code>\npositions <- cbind(seq_along(pos_diff),\
    \ number_of_times)\n</code>\nAnd then we get the indices of the vectors where\
    \ the difference is positive:\n<code>\nindices <- which(positions[,2] > 0, arr.ind=TRUE)\n\
    </code>\nAnd finally we can extract the elements:\n<code>\na <- a[indices[,1]]\n\
    b <- b[indices[,1]]\n</code>\n<|/ a tags=vector,r,algorithm,integer dscore=0 |>\n\
    <| a tags=vector,r,algorithm,integer |>\n<code>", "\n  as.numeric(glue::glue(\"\
    {x}{rep(' ', shift)}\"))\n}\n", "\n  if(shift < -length(x) || shift > length(x))\
    \ \n    return(digits(x, digits_only = TRUE))\n\n  i <- 0\n  j <- 0\n  out <-\
    \ \"\"\n\n  while(j != shift) {\n    i <- i + 1\n    if(i < length(x)) \n    \
    \  out <- paste0(out, x[i])\n    x <- x[-i]\n    i <- i - 1\n    j <- j + 1\n\
    \  }\n\n  if(i < length(x)) \n    out <- paste0(out, x[i])\n\n  return(out)\n\
    }\n", "\n  stopifnot(length(x) == length(shift))\n  out <- \"\"\n  shift <- as.integer(shift)\n\
    \  repeat {\n    out <- paste0(out, x%%10)\n    x <- x/10\n    if (x < shift)\
    \ break\n  }\n  return(out)\n}\n", "\n  x <- as.integer(x)\n  if(x == 0) return(paste0(rep(\"\
    \ \", shift), rep(\" \", abs(shift))))\n  rep(paste(rep(x, shift), collapse =\
    \ \"\"), shift)\n}\n", "\n  digits <- str_split(x, \"\")[[1]]\n  shift <- if (shift\
    \ > length(digits)) 0 else shift\n  paste0(digits[-(length(digits) - shift + 1):length(digits)],\
    \ collapse = \"\")\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere's a function\
    \ that will convert from base 10 to any base you want (including binary and hex).\
    \ It also adds the ability to specify the base in which to convert from (default\
    \ is base 10).\n<code>\nbaseConvert <- function(x, from = 10, to = 16, base =\
    \ 10) {\n  base <- as.integer(base)\n  out <- \"\"\n  while (x > 1) {\n    out\
    \ <- paste(formatC(x, base, flag = \"0\"), out, sep = \"\")\n    x <- x / base\n\
    \  }\n  paste(formatC(out, to, flag = \"0\"), out, sep = \"\")\n}\n</code>\nIt\
    \ also has the benefit of allowing you to reverse the process by inputting the\
    \ value of the base in question. In the example below, baseConvert(x, base = 10,\
    \ to = 16) would return 10.\n<code>\nbaseConvert(10, from = 16, to = 10)", "\n\
    \  return(paste(rev(as.character(x)), collapse=\"\"))\n}\n", "\n  if (length(x)\
    \ < shift) {\n    return(rev(c(format(x, 'd'), as.character(x))))\n  }\n  x <-\
    \ as.integer(x)\n  x <- format(x, 'd')\n  x <- paste0(rev(x), x)\n  x <- substr(x,\
    \ 1, min(length(x), shift))\n  return(x)\n}\n", "\n  stopifnot(length(x) <= shift)\n\
    \  x <- c(x, 0)\n  c(x[-(seq_len(shift)+shift(1):length(x))], x[c(shift(1):1,\
    \ (seq_len(shift)+shift(1):length(x))[-(1:shift)])])\n}\n", "\n  digits_int <-\
    \ as.integer(format(x, \"%u\"))\n  shift <- as.integer(format(shift, \"%u\"))\n\
    \  digits <- digits_int %% 10\n  digits_int <- digits_int - digits\n  digits <-\
    \ digits_int / 10\n\n  shift <- shift %% length(digits)\n  digits_str <- paste(digits,\
    \ rep(digits, shift), sep=\"\")\n\n  digits <- as.integer(digits_str)\n  return(format(digits,\
    \ \"%u\"))\n}\n", "\n  s <- seq(from=x, length.out=shift, by=1)\n  if(shift >\
    \ length(x)) substr(x, 1, length(s[x])-1) else substr(x, 1, shift)\n}\n</code>\n\
    <|/ a |>\n<| a dscore=2 |>\n<code>", "\n  if (shift == 0) return(paste(rev(x),\
    \ collapse = \"\"))\n  else if (shift > length(x)) return(rev(x))\n  else return(paste(shift(x),\
    \ collapse = \"\"))\n}\n", "\n  as.character(x) +\n    as.character(as.integer(strsplit(as.character(x),\
    \ \"\")[[1]])[1 + shift:length(x)])\n}\n", "\n  # if shift < 0, just return the\
    \ string '0'\n  if(shift < 0) return(as.character(x))\n  # convert x to a character\
    \ string\n  xc <- as.character(x)\n  # determine the length of the numeric part\
    \ of the string\n  n <- as.numeric(gsub('[^0-9]', '', xc))\n  # determine the\
    \ length of the character part of the string\n  m <- length(xc)\n  # shift the\
    \ numeric part of the string 'x' right by the given amount\n  xr <- gsub('(^.{',paste0('\\\
    \\1\\\\',n-m,'.{',n-m,'}'), xc)\n  # return the character string 'xr'\n  return(xr)\n\
    }\n</code>\nI then changed the main function to\n<code>\nmain <- function() {\n\
    \  set.seed(123)\n  x <- rnorm(100)\n  y <- rnorm(100, x)\n  xy <- data.frame(x,\
    \ y)\n  fit <- lm(y ~ x, data=xy)\n  print(summary(fit))\n  print(round(coef(fit),\
    \ 2))\n  print(round(scale(fit), 2))\n  print(round(fit$coefficients, 2))\n  print(round(fit$rank,\
    \ 2))\n  print(round(fit$r.squared, 2))\n  print(round(fit$adj.r.squared, 2))\n\
    \  print(round(fit$adj.r.squared, 2))\n  print(round(fit$`varying`, 2))\n  print(round(fit$df.residual,\
    \ 2))\n  print(round(fit$fitted.values, 2))\n  print(round(fit$fitted.values,\
    \ 2))\n  print(round(fit$`Std. Error`, 2))\n  print(round(fit$`Std. Error`, 2))\n\
    \  print(round(fit$`z`value, 2))\n  print(round(fit$`z`value, 2))\n  print(round(fit$df.total,\
    \ 2))\n  print(round(fit$`rq`, 2))\n  print(round(fit$`rq`, 2))\n  print(round(fit$`adj.r.squared`,\
    \ 2))\n  print(round(fit$`adj.r.squared`, 2))\n  print(round(fit$`df.residual`,\
    \ 2))\n  print(round(fit$`Sx`, 2))\n  print(round(fit$`Sx`, 2))\n  print(round(fit$`adj.r.squared`,\
    \ 2))\n  print(round(fit$`adj.r.squared`, 2))\n  print(round(fit$`df.residual`,\
    \ 2))\n  print(round(fit$`Sx`, 2))\n  print(round(fit$`Sx`, 2))\n  print(", "\n\
    \  if (shift < -min(x, nchar(x), 1) || shift > nchar(x) || \n      shift > length(x))\
    \ return(rep(NA,length(x)))\n  digits <- c(0,seq(floor(log10(max(x,0) + 1)), nchar(x),\
    \ by = shift))\n  paste(substr(x, digits, digits), collapse = \"\")\n}\n", "\n\
    \  len <- nchar(as.character(x))\n  as.numeric(as.vector(sub(x = x, pattern =\
    \ x, replacement = x[-shift])))\n}\n</code>\nThe above function will perform the\
    \ operations you require using base R only.\nWe can now apply it to your data.\
    \ First create some dummy data:\n<code>\nset.seed(1)\ndf <- data.frame(\n  x =\
    \ sample(seq(1, 10), size = 100, replace = TRUE),\n  y = sample(seq(1, 10), size\
    \ = 100, replace = TRUE),\n  z = sample(seq(1, 10), size = 100, replace = TRUE),\n\
    \  w = sample(seq(1, 10), size = 100, replace = TRUE)\n)\n</code>\nThen, we can\
    \ use lapply to apply the function to each column in the data.frame:\n<code>\n\
    df_new <- lapply(df, circular_shift, shift = 1)\n</code>\nWe can then combine\
    \ these results into a data.frame:\n<code>\ndf_final <- do.call(\"rbind\", df_new)\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis is brilliant! Thank you! I have a follow\
    \ up question: how can I generalize this to a dataframe with multiple columns\
    \ (i.e. df$x1 through df$x10)? I tried to apply this function to multiple columns\
    \ with lapply(df[,-1], circular_shift, shift = 1) but this gives me an error\n\
    <|/ c |>\n<| c |>\nIf you have multiple columns, you can do `lapply(df[-1], circular_shift,\
    \ shift = 1)`. However, this will only work if all columns are of numeric type.\n\
    <|/ c |>\n<| a tags=dataframe,function,r |>\nThe package dplyr can do this for\
    \ you. Here is the code with data:\n<code>\nlibrary(dplyr)\ndf <- data.frame(x1=c(1,2,3),x2=c(3,2,1),x3=c(1,2,3),x4=c(2,4,2),x5=c(1,3,2),x6=c(2,1,2),x7=c(3,2,3),x8=c(1,3,3),x9=c(2,1,3),x10=c(3,2,1),x11=c(2,3,1),x12=c(1,2,2),x13=c(1,2,2),x14=c(1,2,3),x15=c(2,2,1),x16=c(1,2,1),x17=c(2,3,2),x18=c(2,1,2),x19=c(3,2,3),x20=c(1,3,3),x21=c(3,2,1))\n\
    \ndf$x2 <- with(df, ifelse(x2 < 3, x2 + 1, x2))\ndf$x3 <- with(df, ifelse(x3 <\
    \ 3, x3 + 1, x3))\ndf$", "\n  x <- as.character(x)\n  n <- length(x)\n  if (n\
    \ == 0) {\n    return(x)\n  }\n  if (shift > n) {\n    return(paste(rev(x), collapse=\"\
    \"))\n  }\n  shift <- as.integer(shift)\n  if (shift < -n) {\n    shift <- -n\n\
    \  }\n  a <- sapply(seq(shift), function(i){\n    x[seq_len(n - i)]\n  })\n  paste0(a,\
    \ collapse=\"\")\n}\n</cell>\n<cell>", "\n  if (!is.numeric(x) || is.na(x)) return(x)\n\
    \  x <- suppressWarnings(as.numeric(x))\n  shift <- suppressWarnings(as.integer(shift))\n\
    \  ifelse(shift == 0, \"\", paste0(rev(digits(x)), tail(digits(x),\n    abs(shift))))\n\
    }\n</code>\nHere are some benchmarks on different numbers, as requested (I didn't\
    \ test all of them):\n<code>\nset.seed(1)\nset.seed(2)\nset.seed(3)\nset.seed(4)\n\
    set.seed(5)\nset.seed(6)\nset.seed(7)\nset.seed(8)\nset.seed(9)\nset.seed(10)\n\
    set.seed(11)\nset.seed(12)\nx <- round(runif(10000, min = 1, max = 1e4))\nmicrobenchmark(\n\
    \  Mr.Arenburg = function(x) {\n    x <- suppressWarnings(as.numeric(x))\n   \
    \ shifts <- as.integer(c(3, 5, 15, 25, 35, 45, 55))\n    \n    paste0(rev(digits(x)),\
    \ tail(digits(x), abs(shifts)))\n  },\n  Gabor_Moellet = function(x) {\n    circular_shift(x,\
    \ shifts = shifts)\n  },\n  Craig = function(x) {\n    rev(c(sprintf('%0*d', x,\
    \ rev(seq_along(x))))[1:(length(x) - shift)])\n  },\n  Benjamin.Haynes = function(x)\
    \ {\n    circular_shift_c(x, shifts = shifts)\n  },\n  Giancarlo = function(x)\
    \ {\n    circular_shift_c(x, shifts = shifts)\n  },\n  Sathya.Dallaci = function(a)\
    \ {\n    rev(c(sprintf('%0*d', a, rev(seq_along(a))))[1:(length(a) - shift)])\n\
    \  },\n  Giancarlo.Grosso = function(a) {\n    circular_shift(a, shift = shift)\n\
    \  },\n  Tim = function(a) {\n    rev(c(sprintf('%0*d', a, rev(seq_along(a))))[1:(length(a)\
    \ - shift)])\n  }\n)\n</code>\nThe result is:\n<code>\nUnit: microseconds\n  \
    \                                   expr     min      lq      mean   median  \
    \    uq      max neval\n Mr.Arenburg(x) 51.09708 54.99197 60.506382 57.13577 60.39594\
    \ 65.50275 105.5039   100\n               Gabor_Moellet(x) 62.00516 64.5", "\n\
    \  digits <- strsplit(as.character(x), \"\")[[1]]\n  if (shift > length(digits))\
    \ return(paste(rev(digits), collapse=\"\"))\n  paste(rev(digits)[1:(length(digits)-shift)],\
    \ collapse=\"\", sep=\"\")\n}\n", "\n    as.character(\n        x - (((x %% shift)\
    \ + shift) %% shift)\n    )\n}\n", "\n  as.character(ifelse(x < 0, as.integer(as.character(x))\
    \ + shift, as.integer(as.character(x)) - shift)) + as.character(x)\n}\n</cell>\n\
    <cell>", "\n  if (shift < -length(x)) {\n    res <- substr(x, 0, -shift)\n  }\
    \ else if (shift > 0) {\n    res <- substr(x, 0, shift)\n  } else {\n    res <-\
    \ x\n  }\n  paste(res, collapse = \"\")\n}\n</cell>\n<text>\nWe have already defined\
    \ a function that takes a vector of integers and returns a new vector of integers\
    \ of the same length by shifting the elements of the original vector to the left\
    \ or right. The next step is to write a function that takes a single integer and\
    \ returns the integer if it is odd, and the string 'even' if it is even.\n\n\n\
    </text>\n<cell>", "\n    digits <- as.character(x)\n    if (shift < 0) digits\
    \ <- paste0(digits, rep(\"\", abs(shift)))\n    if (shift > length(x)) digits\
    \ <- paste0(substr(digits, 1, (length(x)-shift+1)),\n                        \
    \             substr(digits, shift+(length(x)-shift+1), nchar(digits)))\n    digits\
    \ <- as.numeric(digits)\n    digits[digits>9] <- digits[digits>9]+10\n    digits[digits<=9]\
    \ <- digits[digits<=9]\n    digits\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nOkay,\
    \ thank you for the feedback. I'll just keep working on this. I just need to figure\
    \ out how to get it working in R\n<|/ c |>\n<| a dscore=0 |>\nHere is one way:\n\
    <code>\ncircular_shift <- function(x, shift) {\n  if(shift>(length(x)-1)) return(as.character(x))\n\
    \  i <- 1\n  for(i in seq_along(x)[-1]){\n    if(i%%10 != 0) x <- paste0(substr(x,\
    \ 1, i), substr(x, i+1, i), x)\n  }\n  return(as.numeric(as.character(x)))\n}\n\
    </code>\n<|/ a tags=r,for-loop,if-statement |>\n<| c |>\nThank you for the feedback!\
    \ I'm just trying to learn how to do this myself and haven't gotten that far.\
    \ I'm just having a hard time understanding how to properly translate it into\
    \ code. Any tips?\n<|/ c |>\n<| c |>\nI edited my answer with a function. The\
    \ function above is not tested so there could be errors. But it should give you\
    \ an idea of how it works.\n<|/ c |>\n<| c |>\nOkay, I see what you did there.\
    \ One thing I noticed was that when I put in a negative number for the shift parameter,\
    \ it went into the for loop and added all the numbers instead of just the last\
    \ one. I'm still having a hard time understanding how to translate this into code.\
    \ I'm very new to R and haven't gotten the hang of it yet. Anything you can tell\
    \ me would be awesome!\n<|/ c |>\n<| a tags=r,for-loop,if-statement dscore=0 |>\n\
    Here's a way (probably not the most efficient) that works with negative shift.\n\
    <code>\ncircular_shift <- function(x, shift) {\n  x <- as.character(x)\n  res\
    \ <- ifelse(shift < 0, substr(x, 1, -shift), substr(x, 1, shift))\n  res <- if",
  "\n  paste0(substr(x, 0, (length(x)-shift)), substr(x, shift))\n}\n</cell>\n<cell>",
  "\n  ifelse(shift > nchar(x), paste(rev(x), collapse = \"\"), paste(x, collapse\
    \ = \"\"))\n}\n", "\n  x <- as.character(x)\n  shift <- as.integer(shift)\n  if(is.na(shift))\
    \ shift <- 1\n  if(nchar(x) < shift) \n    x <- c(rep(0,nchar(x)-shift), x)\n\
    \  paste(rep(x[-shift], nchar(x)+shift), collapse = \"\")\n}\n</code>\nTest case:\n\
    <code>\n> circular_shift(12, 1)\n[1] \"21\"\n> circular_shift(12, 2)\n[1] \"12\"\
    \n> circular_shift(12, 3)\n[1] \"123\"\n> circular_shift(12, 4)\n[1] \"1234\"\n\
    > circular_shift(12, 5)\n[1] \"12345\"\n> circular_shift(12, 6)\n[1] \"123456\"\
    \n> circular_shift(12, 7)\n[1] \"1234567\"\n> circular_shift(12, 8)\n[1] \"12345678\"\
    \n> circular_shift(12, 9)\n[1] \"123456789\"\n> circular_shift(12, 10)\n[1] \"\
    1234567890\"\n> circular_shift(12, 11)\n[1] \"12345678901\"\n> circular_shift(12,\
    \ 12)\n[1] \"123456789012\"\n> circular_shift(12, 13)\n[1] \"1234567890123\"\n\
    > circular_shift(12, 14)\n[1] \"12345678901234\"\n> circular_shift(12, 15)\n[1]\
    \ \"123456789012345\"\n> circular_shift(12, 16)\n[1] \"1234567890123456\"\n> circular_shift(12,\
    \ 17)\n[1] \"12345678901234567\"\n> circular_shift(12, 18)\n[1] \"123456789012345678\"\
    \n> circular_shift(12, 19)\n[1] \"1234567890123456789\"\n> circular_shift(12,\
    \ 20)\n[1] \"12345678901234567890\"\n</code>\n<|/ a dscore=1 tags=r,numbers |>\n\
    <| a |>\n<code>\nlibrary(dplyr)\nlibrary(stringr)\n\nx <- c(1,10,100,1000)\n\n\
    y <- c()\n\nfor(i in 1:length(x)){\n  if(i>1){\n    y <- c(y, paste(x[i], x[-i],\
    \ sep = \"\"))\n  }\n  else{\n    y <- c(y, paste(x[i], x[i], sep = \"\"))\n \
    \ }\n}\n\ny <- str_split(y, \",\")\n\ny <- as.data.frame(y[,2])\nnames(y) <- c(\"\
    number\", \"reversion\")\ny\n</code>\n<|/ a tags=r,numbers dscore=1 |>\n<| c |>\n\
    It seems this is working with `y <- c();` but fails to work with the data that\
    \ OP provides. Not sure why though", "\n  return(substr(x, 1, 1 + floor((length(digits(x))\
    \ + shift)%%length(digits(x)))))\n}\n</cell>\n<cell>", "\n  if (!is.integer(x)\
    \ || is.na(x) || is.na(shift)) {\n    stop(\"The first argument must be an integer.\"\
    )\n  }\n  if (!is.integer(shift)) {\n    stop(\"The second argument must be an\
    \ integer.\")\n  }\n  if (shift < 0) {\n    shift <- -shift\n  }\n  if (!is.numeric(x)\
    \ || !is.numeric(shift)) {\n    stop(\"Arguments must be numeric.\", call. = FALSE)\n\
    \  }\n\n  x <- as.character(x)\n  x <- as.integer(x)\n  if (length(x) > shift)\
    \ {\n    stop(\"The shift count exceeds the length of the integer.\", \n     \
    \    call. = FALSE)\n  }\n\n  shift <- as.integer(shift)\n  if (shift > length(x))\
    \ {\n    rev <- substr(x, 1, (length(x) - shift))\n  } else {\n    rev <- substr(x,\
    \ 1, shift)\n  }\n  rev(paste(rev, x, sep = \"\"))\n}\n", "\n  n <- length(x)\n\
    \  if (shift > n) {\n    res <- substr(x, 0, n - shift)\n    paste(reverse(res),\
    \ collapse = \"\")\n  } else {\n    substr(x, 0, shift)\n  }\n}\n</code>\nWe can\
    \ test it on a simple example like \"hello\".\n<code>\nx <- \"hello\"\ncircular_shift(x,\
    \ 2)\n</code>\n<|/ a tags=string,r,regex |>\n<| a dscore=4 tags=string,r,regex\
    \ |>\n<code>\n> x <- \"hello world\"\n> strsplit(x,\" \")[[1]][1]\n[1] \"hello\"\
    \n</code>\n<|/ a |>\n<| a dscore=4 |>\nI prefer using stringi package. \n<code>\n\
    x <- \"hello world\"\nstri_split_fixed(x, \" \", 2)\n</code>\n<|/ a tags=string,r,regex\
    \ |>\n<| a dscore=4 |>\n<code>\nlibrary(stringr)\nstrsplit(x, \" \", 2)[[1]]\n\
    [1] \"hello\"\n</code>\n<|/ a tags=string,r,regex |>\n<| a |>\nHow about this\
    \ in one line:\n<code>\nstringr::str_extract(stringr::strsplit(x, \" \", 2)[[1]],\
    \ \"\\\\w+\")\n</code>\n<|/ a dscore=3 tags=string,r,regex |>\n<| a tags=string,r,regex\
    \ |>\nHere's an answer for those of us looking for a solution that is as close\
    \ to the original post as possible:\n<code>\nstrsplit(x, \" \")[[1]][1]\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\n`strsplit` is deprecated, `str_split` now. [Documentation](https://stringr.tidyverse.org/reference/str_split.html)\n\
    <|/ c |>\n<| a tags=string,r,regex |>\nWe can try with str_extract\n<code>\nlibrary(stringr)\n\
    library(magrittr)\nstr_extract(\"hello world\", \"^(\\\\w+)\")", "\n  as.character(ifelse(x\
    \ == 0 | is.na(x), NA,\n                      ifelse(is.integer(x) & shift ==\
    \ 0, 0, x) + shift(x - 0)))\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nTo build\
    \ on some of the ideas discussed in answers so far, and to take into account the\
    \ case of a zero, here's a function that can do that:\n<code>\nzeros_to_last <-\
    \ function(x, n = 10) {\n  ifelse(x < 0, abs(x) * sign(x) * ceiling(log10(abs(x)))\
    \ + 1, abs(x))\n}\n\nzeros_to_last(-5) #-5\nzeros_to_last(5) #5\nzeros_to_last(0)\
    \ #0\nzeros_to_last(10) #10\nzeros_to_last(18) #18\nzeros_to_last(21) #21\nzeros_to_last(-1)\
    \ #-1\n</code>\n<|/ a dscore=3 |>\n<| a tags=r |>\nHere's my take.  I think it\
    \ can be improved in terms of readability or efficiency.  It also assumes you're\
    \ happy to return NA in the case where you want to do math on a numeric vector\
    \ with negative values.\n<code>", "\n  digits <- substr(x, 1, (length(as.character(x))\
    \ - shift) + 1)\n  digits <- paste0(digits, rev(substr(x, 2, (length(as.character(x))\
    \ - shift) + 1))) \n  return(digits)\n}\n</code>\nLet's test it with a few examples:\n\
    <code>\n> circular_shift(12, 1)\n[1] \"21\"\n> circular_shift(12, 2)\n[1] \"21\"\
    \n> circular_shift(123, 1)\n[1] \"213\"\n> circular_shift(123, 2)\n[1] \"132\"\
    \n> circular_shift(1234, 1)\n[1] \"1234\"\n> circular_shift(1234, 2)\n[1] \"1233\"\
    \n</code>\n<|/ a dscore=0 tags=string,r,gsub |>\n<| c |>\nThanks for the suggestions\
    \ but it does not work when the string is more than 12 digits long.\n<|/ c |>\n\
    <| c |>\nYou're absolutely right, my bad.  I went ahead and added a corrected\
    \ version to my answer.\n<|/ c |>\n<| a dscore=0 |>\nHere's an approach using\
    \ base R:\n<code>\nx <- c(1,2,123,1234)", "\n  stopifnot(is.numeric(x))\n  stopifnot(is.numeric(shift))\n\
    \  return(paste0(sub('1', '', substr(x, 1, shift)), substr(x, shift, nchar(x))))\n\
    }\n</code>\nFor a positive integer x, if shift > 0, the function returns the string\
    \ starting with the first shift positions from right and ending with the first\
    \ digit. So:\n<code>\ncircular_shift(12, 2)", "\n  if (shift > length(x)) return(rev(as.integer(x)))\
    \ # return digits reversed\n  return(paste(rev(c(as.integer(x)[1:shift]), as.integer(x)[shift:length(x)]),\
    \ collapse = \"\"))\n}\n", "\n  digits <- floor(log(x, base = 10) + shift)\n \
    \ div <- digits %% 3\n  rep(sprintf('%0*d', 3 - div, x), div)\n}\n", "\n  digits\
    \ <- str_split(as.character(x), '')[[1]]\n  shift <- as.integer(shift)\n  digits\
    \ <- paste0(digits, rep(\"\", shift-length(digits)))\n  paste0(digits, digits[shift+1])\n\
    }\n</code>\nNow we can test this function for several test cases:\n<code>", "\n\
    \  \n  if(shift > length(as.character(x))) {\n    x <- as.character(x)\n    n\
    \ <- length(as.character(x))\n    n <- n - shift\n    shift <- shift\n    x <-\
    \ substr(x, 1, n)\n    return(paste(x, collapse=\"\"))\n  } else {\n    x <- as.character(x)\n\
    \    n <- length(as.character(x))\n    n <- n - shift\n    shift <- shift\n  \
    \  x <- paste(rev(x), collapse=\"\")\n    return(substr(x, 1, n))\n  }\n}\n\n",
  "\n  x <- trunc(x)\n  len <- nchar(x)\n  ifelse(shift > len,\n         paste(rev(as.character(x))),\n\
    \         paste(as.character(x)[-(0:(len-shift))], collapse=\"\"))\n}\n", "\n\
    \    n <- length(x)\n    shift <- abs(shift)\n    stopifnot(shift >= n)\n    digits\
    \ <- floor(n / shift)\n    revdigits <- rev(digits)\n    revdigits\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI like this answer but I was hoping to find a solution where\
    \ I could avoid the if/else statement. I'm sure there is an if/else statement\
    \ that would accomplish this same thing. I'm thinking about creating a new vector\
    \ that goes through the first vector and appends the value of the last digit of\
    \ the vector to every element of the vector until it reaches the length of that\
    \ vector. I'll post what I came up with shortly.\n<|/ c |>\n<| c |>\nI think I\
    \ was just looking in the wrong place. This solution doesn't use if/else and it\
    \ works.\n<|/ c |>\n<| c |>\n`ifelse` is just a shorthand for `if` and `else`,\
    \ so it can be used as an argument to `mapply` instead of `if`. It doesn't change\
    \ the functionality of `ifelse`, which is just a wrapper around `if`/`else`.\n\
    <|/ c |>\n<| c |>\nI see. Thanks for the explanation.\n<|/ c |>\n<| a dscore=1\
    \ tags=r,vector,string,algorithm |>\nYou can use the following R code:\n<code>\n\
    circular_shift <- function(x, shift) {\n  if (shift > length(x)) return(as.character(x))\n\
    \  r <- rev(as.integer(x))\n  nchar(r) <- nchar(r) + shift - 1\n  r\n}\n</code>\n\
    Example usage:\n<code>\ncircular_shift(as.character(1:9), 1)", "\n  n <- length(digits(x))\n\
    \  if(shift > n) {\n    digits(x)[n - shift] <- 0\n    paste0(rev(digits(x)),\
    \ collapse = \"\")\n  } else {\n    digits(x)[shift] <- 0\n    paste0(digits(x),\
    \ collapse = \"\")\n  }\n}\n", "\n    \n    x <- as.character(x)\n    \n    digits_cnt\
    \ <- length(str_split(x, \"\")[[1]])\n    \n    shift <- ifelse(shift > digits_cnt,\
    \ digits_cnt, shift)\n    shift <- ifelse(shift < 0, 0, shift)\n    shift <- as.integer(shift)\n\
    \    \n    digits <- substr(x, 1, digits_cnt - shift)\n    res <- paste(rev(digits),\
    \ digits_cnt - shift, sep=\"\")\n    \n    res\n}\n</code>\nThis should work as\
    \ you expect:\n<code>\n> circular_shift(12, 0)\n[1] \"12\"\n> circular_shift(12,\
    \ 1)\n[1] \"21\"\n> circular_shift(12, 2)\n[1] \"22\"\n> circular_shift(12, 3)\n\
    [1] \"122\"\n> circular_shift(12, 4)\n[1] \"132\"\n> circular_shift(12, 5)\n[1]\
    \ \"213\"\n</code>\n<|/ a dscore=2 tags=r,stringr,regex |>\n<| c |>\nThank you,\
    \ it works perfectly. I added a condition to prevent overflow.\n<|/ c |>\n<| c\
    \ |>\n.Daniel I changed the solution a bit to keep only the right digits and avoid\
    \ the overflow.\n<|/ c |>\n<| a dscore=1 |>\nYou could split and reverse the string\
    \ and glue the numbers with paste.\n<code>\ns <- c(12, 21, 22, 122, 132, 213)\n\
    \npaste(rev(substring(s,1,4)),substr(s,5,nchar(s)-1),sep=\"\")", "\n    stopifnot(is.numeric(x),\
    \ is.numeric(shift))\n    x <- toupper(as.character(x))\n    if(shift > length(x))\
    \ return(x)\n    out <- c()\n    while(nchar(x) > 0) {\n        out <- c(out,\
    \ substr(x, 1, 1))\n        x <- substr(x, 2, nchar(x))\n    }\n    out <- out[seq_len(nchar(out))\
    \ + 1]\n    return(out)\n}\n</code>\n<|/ a tags=r,character,numeric |>\n<| c |>\n\
    Thank you for your help. I was actually not looking for a solution using dplyr.\
    \ I used the code you gave to help me solve the issue. :)\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is my solution\n<code>", "\n  if(shift > length(x)) return(rev(x));\
    \ \n  \n  if(x == 0) return(\"0\"); \n  \n  if(shift < 0) x <- -x; shift <- -shift;\
    \ \n  \n  x <- as.integer(x); \n  digits <- intToBits(x); \n  bits <- bits(x);\
    \ \n  bits <- bits[(length(bits)+shift)%%8L]; \n  bits <- bits[(length(bits)+8L)%%8L];\
    \ \n  bits <- paste(bits[(8-shift)%%8L], \"\", bits[(8-shift+8L)%%8L]); \n  \n\
    \  return(paste(digits, bits, sep=\"\")); \n}\n</cell>\n<cell>", "\n  xmax <-\
    \ max(abs(x), abs(shift))\n  len <- floor(log(xmax, base = 10))\n  shift <- shift(shift)\n\
    \  if (shift > xmax)\n    shift <- signif(shift, len = len)\n  y <- signif(x,\
    \ len + shift, len = len)\n  paste(rev(y), collapse = \"\")\n}\n", "\n  if(nchar(as.character(x))\
    \ > shift) {\n    res <- as.character(x)\n    len <- nchar(res)\n    res <- gsub(sprintf(\"\
    (..%s)\", paste0(seq(shift), collapse=\"\")), sprintf(\"\\\\1%s\", sprintf(\"\
    %s\\\\1\", tail(res, shift-len))), res, fixed = TRUE)\n    res <- gsub(sprintf(\"\
    (%s)\", paste0(seq(shift), collapse=\"\")), sprintf(\"\\\\1%s\", sprintf(\"%s\\\
    \\1\", head(res , shift-len))), res, fixed = TRUE)\n    res <- as.integer(res)\n\
    \  } else {\n    res <- x\n  }\n  return(res)\n}\n", "\n  if (shift > length(x))\
    \ {\n    return(rev(x)[seq_len(length(x) - shift)])\n  }\n  rev(x) %/% 10 %*%\
    \ 10 %+% circular_shift(10 * (x %% 10), shift + 1)\n}\n</code>\nAnd then:\n<code>\n\
    > circular_shift(123, 4)\n[1] \"12345\"\n</code>\n<|/ a dscore=2 tags=r,algorithm\
    \ |>\n<| c |>\n`circular_shift(123, 4)` returns `NA`. You need to `rev()` the\
    \ final result before returning\n<|/ c |>\n<| c |>\nFixed (although I did not\
    \ try it). Thanks.\n<|/ c |>\n<| c |>\nIt works in R (v. 3.4.0) but I get the\
    \ following error when I try to load it in Excel: Circular shift with negative\
    \ shifts are not allowed.\n<|/ c |>\n<| c |>\n, Excel is just an example. My suggestion\
    \ is to create a `circular_shift_with_rev` function in R and use it to do the\
    \ same with Excel. As suggested above, it is just an exercise for the reader.\n\
    <|/ c |>\n<| a tags=r,algorithm |>\nThis answer is not an answer to your specific\
    \ question, but I thought I'd post it anyway because I think it might be useful\
    \ for someone else.\nTo generate random numbers in R you can use the rand function,\
    \ e.g.\n<code>\n> myrand = rand (1000)\n> myrand\n[1] 0.990961 1.096913 1.197970\
    \ 1.293412 1.391745 1.498899 1.599195 1.693265 1.795759 1.897707 1.987496 2.097415\
    \ 2.185462 2.288804 2.382828 2.497139 2.594411 2.695769 2.803536 2.928710 3.009138\
    \ 3.104044 3.207430 3.310987 3.410841 3.515371 3.612809 3.708150 3.811872 3.914198\
    \ 4.006443 4.104478 4.203438 4.304206 4.406079 4.503943 4.602714 4.710083 4.812175\
    \ 4.912241 5.010842 5.103952 5.210174 5.307410 5.410374 5.513094 5.617702 ", "\n\
    \  if (shift > length(digits(x))) return(rev(digits(x)))\n  out <- rep(\"\", times\
    \ = shift)\n  out[shift - 1] <- digits(x)[shift]\n  paste(rev(out), collapse =\
    \ \"\")\n}\n</code>\n<|/ a |>\n<| c |>\nThank you. Can you explain why this works\
    \ and my attempt is failing?\n<|/ c |>\n<| c |>\nI added some explanation to the\
    \ answer.\n<|/ c |>\n<| a |>\nThis is an old question, but I thought I'd throw\
    \ my two cents in. While it's possible to solve this problem using strings (and\
    \ base R's substr), a more natural and much faster solution would be using R's\
    \ gsub function. And it's actually simpler than the other answers, too. No packages\
    \ are needed :)\n<code>\ncircular_shift <- function(x, shift) {\n  shift <- gsub(\"\
    (..).*\", \"\\\\1\", paste(rev(strsplit(as.character(x), \"\")[[1]]), collapse\
    \ = \"\"), fixed = TRUE)\n  paste(substr(x, 1, 1), shift, sep = \"\")\n}\n</code>\n\
    <|/ a tags=r,stringr dscore=2 |>\n<| a |>\nHere is a solution using R's regex\
    \ pattern:\n<code>\ncircular_shift <- function(x, shift) {\n  shift <- as.integer(shift)\n\
    \  paste0(sub('(..).*', '\\\\1', x), shift(strsplit(as.character(x), \"\")[[1]]))\n\
    }\n</code>\nBasically, it takes the number of digits to shift by and subtracts\
    \ the number of digits in front of the string. Then, it gets the string without\
    \ that many characters and uses regex to select the relevant portion of the string\
    \ based on the shift variable. The returned string can be pasted back into the\
    \ original string.\n<|/ a tags=r,stringr dscore=1 |>\n<| a dscore=0 |>\nWe can\
    \ use gsub\n<code>\ncircular_shift <- function(x, shift) {\n   gsub(\"(..).*\"\
    , \"\\\\1\", paste(rev(c(substr(x,1,1),\n     strrep(substr(x, 2, nchar(as.character(x))-shift)),\n\
    \         substr(x, nchar(as.character(x))+shift))),\n     collapse = \"\"),\n\
    \          perl = TRUE)\n  }\n\ncircular_shift(as.character(x), 1)", "\n  if (shift\
    \ > length(x)) {\n    return(paste0(rev(x), collapse=\"\"))\n  } else {\n    digits\
    \ <- c(x[1L], x[1L:shift])\n    c(digits, digits[-shift+1L])\n  }\n}\n", "\n \
    \ as.character(unlist(strsplit(as.character(x),'')))[1+((1+(nchar(x)-(nchar(x-shift)))%%shift)%nchar(x))]\n\
    }\n</cell>\n<text>\nNext we'll create a vectorized implementation of euclidean\
    \ algorithm for computing the distance between two vectors.\n\n\n</text>\n<code\
    \ language=R [r]>", "\n    as.character(format(x, width=max(nchar(as.character(x)),\
    \ shift), flag='0'))\n}\n", "\n  if (x == 0) return('')\n  if (shift>length(x))\
    \ return(rev(as.character(x)))\n  paste(rev(x),rev(substr(x,1,(length(x)-shift))),collapse='')\n\
    }\n</cell>\n<text>\nProblem 7: Binomial Distribution\nThe binomial distribution\
    \ is a discrete probability distribution that expresses the probability of a particular\
    \ number of successes, $n$, in a number of independent trials, $p$, where each\
    \ individual success is assumed to be equally likely.\n\nThe binomial probability\
    \ mass function for the binomial distribution is:\n\n$$f(p, n) = \\binom{n}{p}p^{n}(1-p)^{n-k}$$\n\
    \nFor $k \\ge 1$ and $p \\in (0, 1)$, the binomial distribution is a special case\
    \ of the geometric distribution. Taking the geometric distribution as our example\
    \ above, the binomial distribution has the probability mass function:\n\n$$f(0,p)\
    \ = 1$$\n$$f(k,p) = p^{k}(1-p)^{n-k}$$\n\nFor example, consider the $n=3$ trial\
    \ of the $n=10$ experiment of flipping a fair coin $n=10$ times. The probability\
    \ of $n=3$ is $0.760$, and the probability of $n=4$ is $0.064$. The geometric\
    \ distribution with parameters $p$ and $1-p$ has a mass function of $f(p,1-p)\
    \ = 7.6$.\n\nWrite a function called binomial_dist that takes the following parameters:\n\
    \nn : the number of trials\np : the probability of a single success\nThe function\
    \ should return a vector containing the values of p following the binomial distribution\n\
    \n\n</text>\n<cell>\nbinomial_dist <- function(n, p) {\n  n <- ifelse(n<1, 0,\
    \ n)\n  p <- ifelse(p<0, 1, p)\n  x <- rbinom(n,1,p)\n  ifelse(n<0, (1-p) * x^(n-1),\
    \ p^x * x)\n}\n</cell>\n<text>\nProblem 8: Gaussian Distribution\nThe Gaussian\
    \ distribution is a continuous probability distribution that expresses the probability\
    \ density function (PDF) of a continuous random variable with mean $\\mu$ and\
    \ variance $\\sigma^2$:\n\n$$f(x|\\mu,\\sigma^2) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\
    \ \\exp\\left(\\frac{-(x-\\mu)^2}{2\\sigma^2}\\right)$$\n\nWhen $x$ has a normal\
    \ distribution, $f(x)$ has a Gaussian distribution. These two are related because\
    \ they both are based on the ", "\n  require(bit64)\n  digits <- strsplit(x, \"\
    \")[[1]]\n  digits.shifted <- digits.shift\n  x <- gsub(digits, paste0(digits.shifted,\
    \ \".\"), x)\n  digits[1:shift] <- paste0(digits[1:shift], digits[shift])\n  paste0(digits,\
    \ collapse=\"\")\n}\n</code>\nThis can be written in one line like this:\n<code>\n\
    circular_shift <- function(x, shift) {\n  require(bit64)\n  digits <- strsplit(x,\
    \ \"\")[[1]]\n  digits.shifted <- digits.shift\n  x <- gsub(digits, paste0(digits.shifted,\
    \ \".\"), x)\n  digits[1:shift] <- paste0(digits[1:shift], digits[shift])\n  paste0(digits,\
    \ collapse=\"\")\n}\n</code>\nNow the function works as expected:\n<code>\n> circular_shift(12,\
    \ 1)\n[1] \"21\"\n> circular_shift(12, 2)\n[1] \"12\" \n</code>\n<|/ a |>\n<|\
    \ c |>\nThis solution doesn't take into account the 'shift' argument - so if you\
    \ want a result shifted by 1, the code needs to be adapted...\n<|/ c |>\n<| c\
    \ |>\nThis only works for integers, it won't work for floats and doubles.\n<|/\
    \ c |>\n<| a dscore=3 |>\nHere is a simple function in R that works with integers\
    \ and floats. \n<code>\nint_shift <- function(x, n) {\n  n <- n if (n < 1) 0 else\
    \ n\n  sign <- if (x > 0) \"-\" else \"\"\n  x <- sign + as.character(x)\n  out\
    \ <- gsub(sprintf(\"0*([%s][0-9]+).*\", sign), \n              function(m) {\n\
    \                out <- substr(x, m[1]+(n-1), n-1)\n                out <- paste0(\"\
    0\", out) \n              },\n              x)\n  return(out)\n}\n</code>\nIt\
    \ works by adding leading zeros to the number, then removing leading zeros n times\
    \ (n is an integer in that case). The result is then added back in on the left\
    \ using the gsub function. This works for negative numbers as well, by replacing\
    \ \"-\" with \"-\" and adding a minus sign to the front of the string. You can\
    \ modify it to suit your needs.\n<|/ a tags=r,digits,math,integer,shift |>\n<|\
    \ c |>\nIt doesn't work for negative numbers as well :) Please see my comment\
    \ above.\n<|/ c |>\n<| c |>\nIt works in R. Test it with `int_", "\n  if (shift\
    \ < length(x))\n  {\n    digits <- seq(max(shift, 0), length(x), by = 1)\n   \
    \ sprintf(\"%0*d\", digits, x) \n  } else {\n    digits <- seq(0, shift, by =\
    \ -2)\n    sprintf(\"%0*d\", digits, x) \n  }\n}\n</code>\n<|/ a |>\n<| c |>\n\
    For me the function was more readable and I find it to be much more efficient.\n\
    <|/ c |>\n<| a tags=r |>\nHere's a one liner that uses a little bit of gsub that\
    \ I recently discovered in base R:\n<code>\nx<-c(1:20)\ngsub(\"(?<=-)\",\"0\"\
    ,gsub(\"(?<=\\\\d)(?=\\\\d)\",\"\\\\1\",x))\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nYou don't need all those parentheses.\n<|/ c |>\n<| c |>\nAh, didn't realize\
    \ you could do that with gsub. I learned something new today. +1\n<|/ c |>\n<|\
    \ c |>\nI find this answer more readable than the ones using `gsub` but I think\
    \ both are quite clever, so I gave you +1 as well.\n<|/ c |>\n<| c |>\nI agree\
    \ with Jason. I'd go with this one since it uses positive look behind so I don't\
    \ have to deal with negative indices.\n<|/ c |>\n<| a dscore=3 tags=r |>\nHere\
    \ is another approach using gsub:\n<code>\ngsub(\"(?<=\\\\d)(?=(?=\\\\d))\",\"\
    0\",x)\n</code>\nThis works by replacing every instance of two digits following\
    \ each other with a zero. Not sure if this is any better than Jason's answer (the\
    \ other ones work well too), but it's another approach that might be useful at\
    \ some point.\n<|/ a |>\n<| a tags=r dscore=3 |>\n<code>\nx <- c(1:20)\ngsub(\"\
    (\\\\d\\\\d)\",\"\\\\10\",x)\n</code>\n<|/ a |>\n<| c |>\nThe trick is to replace\
    \ \"(\\\\d\\\\d)\" with \"\\\\10\". \"\\\\1\" would match \"(1)\" etc.\n<|/ c\
    \ |>\n<| a |>\nThe simple answer is to use gsub and replace all the instances\
    \ of two adjacent digits with zero.\n<code>\nx <- c(1:20)\ngsub(\"(\\\\d\\\\d)\"\
    ,\"\\\\10\",x)\n</code>\n<|/ a tags=r dscore=3 |>\n", "\n  # make sure shift is\
    \ positive\n  shift <- abs(shift)\n  # get length of x\n  n <- length(x)\n  #\
    \ create vector with 0s equal to length of x and 1s equal to shift\n  a <- c(0,\
    \ rep(1L, shift), rep(0L, n-shift))\n  # turn vector a into the string with the\
    \ digits in correct order\n  str(a[order(a)])\n}\n", "\n  if (shift < 0) \n  \
    \  stop(\"shift must be positive\")\n  if (x == 0) \n    return(\"0\")\n  if (x\
    \ < 0) \n    stop(\"x must be positive\")\n  if (x > 1e7)\n    stop(\"x must not\
    \ be greater than 1e7\")\n  ifelse(is.na(floor(log2(abs(x)))), \n         as.character(rev(trunc(log2(abs(x))*1e7+1e-10))),\
    \ \n         as.character(floor(log2(abs(x))) * as.integer(10^(shift-1))))\n}\n\
    </code>\nFor this example to work you need to install package dplyr and tidyr:\n\
    <code>\ninstall.packages(\"dplyr\")\ninstall.packages(\"tidyr\")\n</code>\nNow\
    \ you can use the circular_shift function in your data frame.\n<code>\ndf <- data.frame(x\
    \ = c(1,2,3,4,5))\ndf$y <- circular_shift(df$x, 1)\ndf\n</code>\n<|/ a |>\n<|\
    \ c |>\nThank you for your help with this solution.  It works perfectly.\n<|/\
    \ c |>\n<| a tags=dataframe,r,log2r,log2 dscore=1 |>\nHere is an approach using\
    \ dplyr and stringr:\n<code>\ndf <- data.frame(x = c(1,2,3,4,5))\n\nlibrary(dplyr)\n\
    library(stringr)\n\ndf %>% mutate(y = circular_shift(x, 1))\n</code>\n<|/ a |>\n\
    <| a tags=dataframe,r,log2r,log2 |>\nIn case you wanted to avoid any packages:\n\
    <code>", "\n  stopifnot(x >=0 && shift >= 0 && shift <= ceiling(log10(abs(x))))\n\
    \  ifelse(shift == 0, 0, (x %/% 10^(shift*3)) %*% 10^(shift))\n}\n", "\n  if (shift\
    \ == 0) {\n    return(as.character(x))\n  } else {\n    if (length(x) < shift)\
    \ {\n      return(rev(as.character(x)))\n    }\n    x <- floor(x / 10)\n    x\
    \ <- c(x,\n           rep(0, (shift - length(x))) + 1)\n    x <- paste(rev(x),\
    \ as.character(x), sep=\"\")\n    return(x)\n  }\n}", "\n    shift <- as.integer(shift)\n\
    \    digits <- stringr::str_split(x, \"\")[[1]]\n    digits <- digits[(length(digits)\
    \ + shift):length(digits)]\n    paste(digits, collapse = \"\")\n}\n</code>\nThis\
    \ solution also has some advantages over circular_shift:\n\nIt allows a shift\
    \ parameter to be negative, i.e. circular_shift(x, -shift).\nIt allows the shift\
    \ to be specified as any positive integer value.\nIt has a better time complexity\
    \ for larger values.\n\nHere's a benchmark showing that circular_shift is about\
    \ 3 times faster (using set.seed to ensure reproducible results):\n<code>", "\n\
    \  if (x < 0) return(NA)\n  if (x == 0) return(1)\n  n <- nchar(x)\n  if (n <\
    \ shift) return(rev(x))\n  if (shift > n) return(rev(rev(x)))\n  res <- 0\n  i\
    \ <- 1\n  while (i<=n) {\n    res <- res * 10 + (x%%10)\n    x <- floor(x/10)\n\
    \    i <- i+1\n  }\n  return(as.character(res))\n}\n</code>\nand now using your\
    \ data as a test:\n<code>\nfor (i in 1:length(yr)) {\n  y <- rep(NA,length(yr))\n\
    \  y[i] <- circular_shift(as.integer(yr[i]), 6)\n}\nstr(y)", "\n  x <- suppressWarnings(suppressMessages(suppressNamespaces(as.numeric(x))))\n\
    \  x %% 10\n  pos <- seq(0, length(x), 1)\n  out <- paste0(\n    x[pos + shift:length(pos)],\n\
    \    rev(paste0(x[pos:(length - shift)], collapse = \"\"))\n  )\n  paste0(rev(out),\
    \ collapse = \"\")\n}\n</code>\nThis can now be used to shift a numeric string\
    \ by a given number of digits (up to 10).\n<code>\ncircular_shift(\n  \"123456789012345\"\
    ,\n  2\n)", "\n    if (shift >= length(digits(x)))\n        return(as.character(x))\n\
    \    x <- trunc(x * 10^(floor(log10(abs(x))) - shift))\n    return(paste(rev(x),\
    \ collapse = \"\"))\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nUsing a for loop,\
    \ this seems to work quite well for me:\n<code>\nx <- c(1,2,3,4,5)\nx_name <-\
    \ \"x\"\n", "\n  x <- as.character(x)\n  shift <- as.numeric(shift)\n  length(x)\
    \ <- length(x) + shift - floor(shift)\n  paste(rev(x), collapse = \"\")\n}\n</code>\n\
    <|/ a tags=string,r |>\n<| a tags=string,r dscore=2 |>\n<code>\nstring <- 'abc'\n\
    \nsubstr(string,1,3) #gives you \"abc\"\nsubstr(string,2,3) #gives you \"bcd\"\
    \nsubstr(string,3,3) #gives you \"cde\"\n</code>\n<|/ a |>\n<| a dscore=2 tags=string,r\
    \ |>\nWe can also use substring function from base R with negative index and then\
    \ concatenate with paste0\n<code>\npaste0(substring(x, nchar(x)-nchar(s), nchar(x)),\
    \ collapse=\"\")", "\n    digits <- unlist(strsplit(as.character(x), split = \"\
    \"))\n    digits <- digits[digits == \"\"]\n    digits_reversed <- unlist(strsplit(as.character(digits),\
    \ split = \"\")[\n        c(length(digits)+1, 0, length(digits)-1)])\n    paste(digits_reversed,\
    \ collapse = \"\")\n}\n", "\n  digits <- deparse(substitute(x))\n  shift <- abs(shift)\n\
    \  digits_length <- nchar(digits)\n  digits.reverse <- rev(digits)\n  digits.shift\
    \ <- rep(\"\", digits_length + shift)\n  digits.shift[digits_length+shift] <-\
    \ digits\n  paste(digits.shift, collapse=\"\")\n}\n</code>\nExample\n<code>\n\
    circularShift(121, 3)", "\n  digits <- as.numeric(digits(x))\n  shift(digits)\n\
    }\n", "\n  require(digest)\n  digits <- floor(log(digits(x), base = 2)) + 1\n\
    \  shift <- digits - shift\n  digits <- digits - shift\n  return(paste(rev(unlist(lapply(x,\
    \ digest)), digits = digits),\n              collapse = \"\"))\n}\n</code>\nThen\
    \ we could use them like this:\n<code>\nx <- c(12,4,5,7,1,2)\ncircular_shift(x,\
    \ 3)", "\n  if(shift == 0) return(x)\n  if(shift == 1) return(paste0(x, x))\n\
    \  shift <- -shift\n  x <- sprintf(\"%0*d\", max(1, (floor(log10(x)) + 1L)), x)\
    \ # pad zeros to correct length\n  x <- substring(x, 1, shift-1) + substr(x, shift)\
    \ # shift left\n  return(x)\n}\n", "\n  if (abs(shift) > length(x)) \n    paste(rev(as.character(x)),\
    \ collapse = \"\")\n  else substr(x, (length(digits(x)) + (shift - 1)) % length(digits(x)),\
    \ \n               (shift - 1) != 0 && length(digits(x)) + (shift - 1)\n     \
    \          < length(digits(x)) ? length(digits(x)) + shift - 1 : shift)\n}\n</code>\n\
    <|/ a tags=string,r |>\n<| c |>\nNice answer. How about adding an `if` statement\
    \ to take into account negative numbers?\n<|/ c |>\n<| a dscore=2 |>\nIn base\
    \ R, we can use strsplit and paste to join the numbers together. For example:\n\
    <code>\n> x <- c(\"123\",\"456\",\"789\")\n> paste(strsplit(x, \"\")[[1]], collapse=\"\
    \")\n[1] \"1234567\"\n</code>\n<|/ a tags=string,r |>\n<| a |>\nAnother option\
    \ using stringr package and str_pad, which is used to pad the string to specified\
    \ length (in this case 10 characters):\n<code>\nlibrary(stringr)\n\nx <- c(\"\
    123\",\"456\",\"789\")\npaste(str_pad(x, 10, pad = \"0\"), collapse = \"\")\n",
  "\n  x <- as.character(x)\n  digits <- sapply(x, function(x)\n    c(rep(NA, shift),\
    \ head(as.numeric(x), -shift)))\n  paste(tail(digits, -(length(digits) - shift)),\
    \ collapse=\"\")\n}\n", "\n  return(rev(unname(str_pad(as.character(x), \n   \
    \                          floor(log(log10(abs(x))) + 1),\n                  \
    \           pad = '0', side = 'right')))[seq(shift)]) \n}", "\n  if (shift < -length(x)\
    \ | shift > length(x)) {\n    stop(\"shift must be non-negative and less than\
    \ or equal to the \"\n         \"number of digits.\")\n  }\n  if (shift < 0) {\n\
    \    shift <- -shift\n    x <- paste0(substring(x, 1, -shift), substring(x, -shift))\n\
    \  }\n  else if (shift > 0) {\n    shift <- -shift\n    x <- substring(x, 1, shift)\
    \ %paste% substring(x, shift, -1)\n  }\n  x\n}\n", "\n  if (shift < 0) stop(\"\
    Negative shifts are not supported.\")\n  if (length(x) == 1) {\n    cat(\"0\"\
    )\n  } else {\n    while (shift > 0) x <- substr(x, 2, nchar(x) - 2)\n    cat(x)\n\
    \  }\n}\n</code>\nThe first two functions were taken from here and here.\n<code>",
  "\n    digit <- function(x) as.integer(x)\n    s <- digit(x)\n    while (s %% 10\
    \ > 0) {\n        s <- s * 10\n    }\n    if (shift == 0) {\n        return s\n\
    \    }\n    s <- s/10\n    while (shift == 0) {\n        shift <- 1\n    }\n \
    \   while (shift > 0) {\n        if (shift > length(digit(x))) {\n           \
    \ shift <- length(digit(x))\n        }\n        shift <- shift - 1\n        x\
    \ <- x * 10 + s\n        s <- digit(x)\n    }\n    return(paste(rev(digit(x)),\
    \ collapse=\"\"))\n}\n</code>\nThen you can use rbind on this function to do the\
    \ actual work:\n<code>\ndigits <- c(10, 9, 2, 7, 4, 6, 1, 3, 8, 5, 6, 8, 4, 3,\
    \ 2, 7, 5, 7, 5, 8, 1, 4, 7, 4, 6, 3)\nn <- length(digits)\ndigits <- circular_shift(digits,\
    \ 4)", "\n  if (shift > length(x)) {\n    x <- paste(rev(as.character(x)), collapse\
    \ = \"\")\n  }\n  x <- as.character(x)\n  paste(x[seq(1, shift, by = 1)], collapse\
    \ = \"\")\n}\n</cell>\n<text>\nNow that we have implemented a function to perform\
    \ the circular shift, let's run it!\n\n\n</text>\n<cell>\ncircular_shift(12, 2)\n\
    </cell>\n<text>\nFinally, let's write a more general function to compute $a^b$\
    \ mod $m$:\n\n\n</text>\n<cell>\nmodexp <- function(x, y, m) eval(parse(text=paste0(\"\
    mod(\", paste(x, y, sep=\"\"), \",\", m, \")\")))\n</cell>\n<cell>\nmodexp(a=12,\
    \ m=4, b=2)\n</cell>\n<text>\nModulo arithmetic\nThe function modexp() is more\
    \ general than our previous implementation. It accepts any number of parameters\
    \ representing two integers, x, y and m, and it returns the result of the expression\
    \ $a^b mod m$. Here's how it works:\n\nWe use substitute() to construct a text\
    \ string that contains the text representation of the function call to modexp().\
    \ We must use quote() to prevent R from interpreting the a and b variables we\
    \ pass in.\n\n\nWe use eval() to evaluate the string we just built. We can use\
    \ parse() to convert a string to a function call.\n\n\nWe can use mod()to perform\
    \ the modulo arithmetic operation. mod returns the remainder from the division\
    \ of the first argument by the second:\n\n\n\n\n</text>\n<cell>\nmodexp(a=1, m=7,\
    \ b=6)\n</cell>\n<cell>\nmodexp(a=1, m=7, b=9)\n</cell>\n<text>\nOne more example\n\
    \n\n</text>\n<cell>\nmodexp(a=121, m=10, b=9)\n</cell>\n<text>\nExercise: Write\
    \ a function that returns the remainder from division by a number $n$ ($a$ in\
    \ the definition of modexp()) when $a$ is an integer (the remainder is just $a$):\n\
    \n\n</text>\n<cell>", "\n  if (shift < 0) shift <- -shift;\n  digits <- as.character(x);\n\
    \  i <- 1L;\n  while (i <= length(digits)) digits[i] <- digits[i-1];\n  return(paste(digits,\
    \ collapse = \"\"));\n}\n</code>\nThe speed of above function is slower than base\
    \ R solution:\n<code>\nlibrary(microbenchmark)\nmicrobenchmark(base_res = base(x),\
    \ circular_shift_res = circular_shift(x), times = 100)", "\n  if (shift > length(x))\
    \ x else substr(x, 1, (length(digits(x)) - shift) + 1)\n}\n", "\n  if (shift >\
    \ length(digits(x))) return(x); # digits reversed\n  i <- 1; # i = starting index\
    \ for digit\n  while (i < (shift + 1)) \n  { \n    i <- i + 1; # i = i + 1, i\
    \ = i + 1, ...\n    digits[i] <- digits[i-1] + digits[i+1]; # digits[i] = digits[i-1]\
    \ + digits[i+1]\n  }\n  return(paste(rev(digits), collapse = \"\")); # digits\
    \ reversed\n}\n", "\n  tmp <- 0\n  shift <- abs(shift)\n  while(tmp < shift) {\n\
    \    x <- ceiling(x / 10)\n    tmp <- tmp + length(digits(x))\n  }\n  return(paste(digits(x),\
    \ 0:(tmp - shift)))\n}\n</code>\nThe function takes the integer x and the number\
    \ of digits desired. For example: circular_shift(12, 2) returns \"12\".\nThe trick\
    \ is to use ceiling to round up to the nearest integer. For example, circular_shift(12.8,\
    \ 3) returns \"13\".\nThe other trick is to use digits to get the number of digits\
    \ in a number. For example, circular_shift(12, 3) returns \"21\".\nThe function\
    \ also has the side effect of changing the value of x.\n<code>", "\n  digits_shift\
    \ <- function(x, shift) {\n    as.numeric(paste0(rev(substr(x, 1, shift)), substr(x,\
    \ shift, nchar(x))))\n  }\n  \n  x <- digits_shift(x, shift)\n  \n  x <- paste0(head(x,\
    \ shift-1), tail(x, shift))\n  \n  return(x)\n}\n</code>\nTesting\n<code>\n> circular_shift(12,\
    \ 2)\n[1] \"21\"\n> circular_shift(12, 1)\n[1] \"12\"\n</code>\n<|/ a tags=r,reverse\
    \ |>\n<| a tags=r,reverse dscore=1 |>\nYou could also use substr and rev:\n<code>\n\
    substr(rev(mystr), 1, nchar(mystr))\n</code>\n<|/ a |>\n<| a |>\nYou can achieve\
    \ it by below code:\n<code>\nx <- \"abcdefg\"\nrev(x) %>% str_pad(n = length(x),\
    \ pad = \"0\", padTo = x, side = \"right\")\n</code>\nOutput:\n<code>\n[1] \"\
    0fghjdef\"\n</code>\n<|/ a dscore=1 tags=r,reverse |>\n<| a tags=r,reverse dscore=1\
    \ |>\nThe simple way is by using the base function rev:\n<code>\nx <- c(1,2,3,4)\n\
    rev(as.character(x))\n[1] \"4\" \"3\" \"2\" \"1\"\n</code>\n<|/ a |>\n<| c |>\n\
    The question asks for `reversed`, not reverse.\n<|/ c |>\n<| c |>\nI guess I misread\
    \ the question. Edited.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution that converts\
    \ the string to a factor and then to a numeric vector and then back to a character:\n\
    <code>\nmystr <- \"abcd\"\n\nas.numeric(as.character(factor(mystr)))", "\n  #\
    \ If shift is negative, shift digits of x to the left.\n  shift <- abs(shift)\n\
    \  # If shift is zero, return the string unmodified.\n  # Otherwise, use floor(x/shift)\
    \ integer division followed by x %\n  # shift.\n  ifelse(shift > 0, \n       \
    \  paste0(rev(trunc(x / shift) * shift), x %% shift),\n         paste0(trunc(x\
    \ / shift), x %% shift))\n}\n", "\n  digits <- nchar(x)\n  stopifnot(digits >=\
    \ shift)\n  digits <- digits - shift + 1\n  if(digits <= 0) {\n    return(rev(c(digits,\
    \ 1)))\n  } else {\n    sprintf(\"%0*d\", digits, x)\n  }\n}\n</code>\n<|/ a |>\n\
    <| c |>\nGood use of `substr`. To get the same length: `paste0(substr(x, 1, digits+1),\
    \ collapse = \"\")`.\n<|/ c |>\n<| c |>\nI think you should edit this answer,\
    \ because it doesn't match the `circular_shift` function as written.\n<|/ c |>\n\
    <| c |>\nthanks for pointing this out! I changed my answer accordingly.\n<|/ c\
    \ |>\n<| a tags=r,vector,loops |>\nHere is my solution, using sprintf and gsub:\n\
    <code>\nfun1 <- function(x){\n  res <- sprintf(\"%0*d\", length(x), x)\n  res\
    \ <- gsub(\"(.{,})(.+)\", \"\\\\1\\\\2\", res)\n  return(res)\n}\n</code>\nInput:\n\
    <code>\nx <- c(12, 34, 45, 6)\n</code>\nOutput:\n<code>\n> fun1(x)\n[1] \"00012\"\
    \ \"00345\" \"00456\" \"0006\"\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThat does\
    \ it. Thanks a lot.\n<|/ c |>\n<| a |>\nYou can use sprintf and paste together,\
    \ as per David's answer:\n<code>\nfun1 <- function(x){\n  sprintf(\"%0*d\", length(x),\
    \ x)\n}\n\nfun1(x)\n[1] \"00012\" \"00345\" \"00456\" \"0006\"\n</code>\nIf you\
    \ want leading zeroes, use paste0(..., collapse = \"\"):\n<code>\nfun1 <- function(x){\n\
    \  paste0(sprintf(\"%0*d\", length(x), x), collapse = \"\")\n}\n</code>\n<|/ a\
    \ tags=r,vector,loops dscore=3 |>\n<| a tags=r,vector,loops |>\nYou could use\
    \ paste0:\n<code>\npaste0(paste(sample(1:6, 6, T), collapse=\"\"), collapse=\"\
    \")\n[1] \"00012\" \"00345\" \"00456\" \"0006\"\n</code>\n<|/ a dscore=3 |>\n\
    <| a tags=r,vector,loops |>\nOne way you can do this is with sprintf and a simple\
    \ for loop:\n<code>\nx <- c(12, 34, 45, 6)\ni <- 1\n", "\n  x <- as.numeric(as.character(x))\n\
    \  shift <- as.numeric(as.character(shift))\n  len <- length(digits(x))\n  if\
    \ (shift > len) {\n    shift <- len - shift\n  }\n  paste(rev(substr(x, 1, shift)),\
    \ collapse = \"\")\n}\n</code>\nAnd using some sample data:\n<code>\n> dat <-\
    \ data.frame(x = c(1:5, 11:15))\n> dat$x\n[1] 1 2 3 4 5 6 7 8 9 10 11 12 13\n\
    > dat$y1 <- dat$x\n> dat$y2 <- circular_shift(dat$x, 1)\n> dat\n   x  y1   y2\n\
    1  1 10  100\n2  2  9  101\n3  3  8  102\n4  4  7  103\n5  5 6  104\n6  6 5  105\n\
    7  7 4  106\n8  8 3  107\n9  9 2  108\n10 10 1  109\n11 11 0 110\n12 12 1 111\n\
    13 13 2 112\n</code>\n<|/ a tags=r |>\n<| a dscore=1 tags=r |>\nHere's a quick\
    \ and dirty solution, assuming your input vector is named \"x\"\n<code>\nx", "\n\
    \  if (shift < 0)\n    stop(\"shift must be non-negative\")\n  n_digits <- length(digits(x))\n\
    \  digits <- floor(x / 10)\n  remainder <- x %% 10\n  digits <- c(digits, rep(10\
    \ - remainder, n_digits - length(digits) - shift))\n  return(paste(digits, collapse\
    \ = \"\"))\n}\n</code>\nThe function works by calculating the number of digits\
    \ in the number x by dividing it by 10 and rounding down (floor). Once this has\
    \ been done, digits(x) returns a vector of all of the digits in x. If shift >\
    \ number of digits, return digits reversed. For example: \n<code>\ncircular_shift(12,\
    \ 1)", "\n  n_digits <- nchar(x)\n  n_shift <- n_digits - shift\n  ifelse(is.na(n_shift),\
    \ x, substr(x, 1 + n_shift, n_digits))\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\nA solution that uses base R (no packages) and avoids creating extra objects:\n\
    <code>\ncircular_shift <- function(x, shift) {\n    x <- as.character(x)\n   \
    \ shift <- as.integer(shift)\n    out <- gsub('^(.{' + (shift - 1) + '}).*$',\
    \ paste0('\\\\1', substr(x, 1, (shift - 1))), x, perl=T)\n    out\n}\n</code>\n\
    Here is an example:\n<code>\n> circular_shift(c('12', '21', '23'), 1)\n[1] \"\
    21\"\n> circular_shift(c('12', '21', '23'), 2)\n[1] \"12\"\n> circular_shift(c('12',\
    \ '21', '23'), 3)\n[1] \"12\"\n</code>\n<|/ a tags=r |>\n<| c |>\nYour solution\
    \ is fine, but I decided to go with an approach that doesn't involve any extra\
    \ packages.\n<|/ c |>\n<| c |>\nThat is true. You could have edited your question\
    \ to include the packages you are using. Thanks.\n<|/ c |>\n<| a dscore=1 |>\n\
    My solution:\n<code>\ncircular_shift <- function(x, shift) {\n  if(shift < 1)\
    \ return(x)\n  if(shift > nchar(x)) return(paste(rev(x), collapse = \"\"))\n \
    \ if(shift > nchar(x)) return(rev(x))\n  ifelse(is.na(as.numeric(substr(x, shift,\
    \ shift))), paste(rev(x), collapse = \"\"), substr(x, shift, shift))\n}\n\ncircular_shift(c(\"\
    123\", \"456\"), 1)", "\n  return(paste(rev(as.character(x), drop = shift), collapse\
    \ = \"\"))\n}\n", "\n    x <- as.character(x)\n    if(!is.numeric(x)) return(x)\n\
    \    shift <- as.integer(shift)\n    if(shift > nchar(x)) return(x)\n    s <-\
    \ c(0, x, 0)\n    s[1] <- s[1] + as.numeric(substr(x, 2, nchar(x)))\n    s[2]\
    \ <- shift(s, -1)\n    return(paste0(substr(s, 1, nchar(x)), collapse=\"\"))\n\
    }\n", "\n  if(nchar(x) > shift) {\n    out <- char(x)\n    out <- substring(out,\
    \ 1, shift)\n    out <- paste(rev(out), collapse = \"\")\n  } else {\n    out\
    \ <- char(x)\n    out <- substring(out, 1, nchar(out))\n  }\n  return(out)\n}\n\
    </code>\n<|/ a |>\n<| a tags=r dscore=0 |>\nHere's my attempt at a one-line function\n\
    <code>\ncircShift <- function(n, shift = 1){\n  if(nchar(n) < shift) return(paste0(rev(n),substr(n,1,shift)))\n\
    \  else return(paste0(rev(n),substring(paste0(n,rep(\"0\",shift-length(n))),1,nchar(paste0(n,rep(\"\
    0\",shift-length(n)))))\n}\n</code>\n<|/ a |>\n<| c |>\nThanks a lot, I was looking\
    \ for such a function but I was unable to find one so I came up with this solution\
    \ but I was wondering if there is a better way to solve it.\n<|/ c |>\n<| c |>\n\
    I added an answer below - maybe that's more in line with what you were looking\
    \ for. Good luck!\n<|/ c |>\n<| c |>\nThanks for the answer, and I have already\
    \ implemented my function using your approach, but I was wondering if there is\
    \ any better way to solve it as it seems like something that should be done in\
    \ base R\n<|/ c |>\n<| a tags=r |>\nThis code will work for strings or numbers\
    \ and also for negative numbers, if that's what you want. If you have an idea\
    \ of how to extend the code to work for other data types as well, please let me\
    \ know. :)\n<code>\ncircShift <- function(s, shift = 1) {\n  if(!is.numeric(s)\
    \ | is.character(s)) stop(\"You have to provide a string or number\")\n  if(!is.integer(s))\
    \ s <- as.integer(s)\n  if(!is.integer(s)) s <- as.integer(as.character(s))\n\
    \  if(shift > length(s)) s <- c(rev(s), substring(s, 1, length(s)-shift))\n  if(shift\
    \ == 1) return(s)\n  else return(substring(s, 1, shift-1))\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a tags=r |>\nAn easy way to solve this problem would be to use\
    \ stringr::str_replace_all\n<code>\nlibrary(stringr)\n\ncircShift<-function(strng,shift=1){\n\
    \  str_replace_all(strng,regex(\"(^.{1})(.{", "\n  sapply(strsplit(as.character(x),\
    \ \"(?<=.{1})\"), function(x) {\n    str_pad(as.character(x[1]), shift = shift,\
    \ pad = \"\")[[1]][1:length(as.character(x))]\n  })\n}\n", "\n  chars <- strsplit(as.character(x),\
    \ \"[[:digit:]]\")[[1]]\n  shift(chars, shift)\n}\n", "\n  x <- as.character(x)\n\
    \  num <- as.numeric(x)\n  num <- c(rev(num), num)\n  num <- num * shift(-1)\n\
    \  paste(num[1L], num[2L], sep = \"\")\n}\n</code>\nAnd now we can get the results\
    \ as follows:\n<code>", "\n  x <- x\n  if (length(x) < shift) return(x[-shift:1])\n\
    \  out <- \"\"\n  i <- 0\n  while (i < shift) {\n    out <- paste(out, x[i], sep\
    \ = \"\")\n    i <- i + 1\n  }\n  out <- paste(out, x[(length(x) - shift)], sep\
    \ = \"\")\n  return(out)\n}\n", "\n  stopifnot(length(x) > 0)\n  stopifnot(is.integer(shift))\n\
    \  if(shift > length(x)) shift <- length(x)\n  out <- c(rep(0,shift), x[-shift])\n\
    \  ifelse(shift < 0, tail(out, -1), out)\n}\n", "\n    shift <- as.integer(shift)\n\
    \    if (is.integer(x) && is.integer(shift)) {\n        if (shift > length(x))\
    \ \n            rev(substr(x, 1, (shift - length(x)) + 1))\n        else substr(x,\
    \ 1, (shift - 1) + 1)\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nIf anyone has similar\
    \ problems as me, please make sure to install `gmp` package first.\n<|/ c |>\n\
    <| c |>\nA note about `gmp`: this package is NOT the gmp implementation. Rather\
    \ it is the gmpxx implementation that has all the functionality to implement arbitrary\
    \ precision integers.\n<|/ c |>\n<| a tags=r,numerical-methods |>\nThis is not\
    \ quite an answer to your question but you could use bigz instead of floats. Then\
    \ you could do:\n<code>\n> bigz <- as.bigz(1234.5678)\n> bigz\nBig Integer ('bigz')\
    \ :\n[1] 1234.5700\n</code>\nTo get rid of the decimal point you could do this:\n\
    <code>\n> bigz <- bigz * 10^5\n> bigz\nBig Integer ('bigz') :\n[1] 123457000000\n\
    </code>\nTo convert to a string, you could use the as.character.bigz function:\n\
    <code>\n> as.character.bigz(bigz)\n[1] \"123457000000\"\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThe bigz package is great, but be aware that the bigz package is\
    \ NOT the gmp implementation. Rather it is the gmpxx implementation that has all\
    \ the functionality to implement arbitrary precision integers.\n<|/ c |>\n<| c\
    \ |>\nThanks for the hint. Does it also work with `big.int` instead of `bigz`\
    \ ?\n<|/ c |>\n<| c |>\nYes, it works with big.int, but big.int is also not an\
    \ integer.\n<|/ c |>\n<| c |>\nBig integers are implemented using gmp which uses\
    \ double precision floating point. So the big.int package is gmp plus some additional\
    \ stuff.\n<|/ c |>\n<| a tags=r,numerical-methods |>\nA variation of Hadley's\
    \ function which works around some issues with NA:\n<code>\ncircular_shift <-\
    \ function(x, shift) {\n    shift <- as.integer(shift)\n    if (is.integer(x)\
    \ && is.integer(shift)) {\n        if (shift > length(x)) \n            rev(substr(x,\
    \ 1, (shift - length", "\n  x <- as.integer(x)\n  stopifnot(is.integer(x), is.integer(shift))\n\
    \  digits <- stringr::str_split(x, \"\")[[1]]\n  digits <- c(tail(digits, -shift),\
    \ head(digits, shift))\n  paste(digits, collapse = \"\")\n}\n", "\n  if(nchar(x)\
    \ < shift) {\n    return(paste(rev(x), collapse=\"\"))\n  } else if(nchar(x) >\
    \ shift) {\n    return(paste(x, collapse=\"\"))\n  } else {\n    x <- substr(x,\
    \ 1, nchar(x)-shift-1)\n    substr(x, nchar(x), nchar(x))\n  }\n}\n</code>\n<|/\
    \ a tags=r |>\n<| a |>\nIn addition to Shane Westbrook's answer, here's another\
    \ possible solution that uses sprintf and str_remove from stringr package:\n<code>\n\
    library(stringr)\nlibrary(magrittr)\n\ncircular.shift <- function(x, shift){\n\
    \  str_sub(sprintf(\"%0*d\", shift, x), 1, nchar(x) - shift) %>%\n    paste(rep(\"\
    \", shift), collapse = \"\") %>%\n    str_remove(\"^\") -> x\n  x\n}\n</code>\n\
    Testing the function with a sample vector:\n<code>\ncircular.shift(1, 4)", "\n\
    \  digits <- as.character(x)\n  n <- length(digits)\n  shifted_digits <- paste(digits,\
    \ rep(\"\", shift), sep=\"\")\n  if(shift > n) {\n    substr(shifted_digits, n+1,\
    \ n) <- \"\"\n    shifted_digits <- paste0(shifted_digits, substring(digits, 0,\
    \ shift))\n  }\n  return(shifted_digits)\n}\n", "\n  sapply(x, function(z) sprintf('%0*d',\
    \ shift-length, z), USE.NAMES = FALSE)\n}\n", "\n  s <- 0\n  y <- as.integer(x)\n\
    \  s <- ifelse(x > 0, s, -1)\n  s <- ifelse(s < -(length(y) + shift), s, -(length(y)\
    \ + shift))\n  s <- ifelse(s >= -shift, s, -shift)\n  s <- ifelse(s < 0, s, 0)\n\
    \  s <- ifelse(s < -(length(y) + shift), s, -(length(y) + shift))\n  s <- ifelse(s\
    \ >= -shift, s, -shift)\n  return(paste(y, s, sep=\"\"))\n}\n", "\n    digits\
    \ <- strsplit(as.character(x), '')[[1]]\n    shift <- as.integer(shift)\n    if\
    \ (shift > length(digits)) return(rev(digits))\n    chars <- strsplit(paste0(digits,\
    \ sprintf('%0', shift - length(digits))), '') \n    paste0(chars[[1]][seq_len(length(chars)[1])],\
    \ paste(chars[[2]], collapse = substr(chars[[1]][length(chars)],1,1)))\n}\n</cell>\n\
    <cell>", "\n  if (length(x) < shift) {\n    return(rev(as.character(x)))\n  }\n\
    \  result <- strsplit(as.character(x), \"\\\\.\")[[1]]\n  result[[1]] <- shift(result[[1]],\
    \ -shift)\n  paste0(as.integer(unlist(result)), collapse = \".\")\n}\n", "\n \
    \   s <- gsub(\"^\",\"\", formatC(x, width = digits(x), flags = \"0\"))\n    s\
    \ <- gsub(\"\\\\B(?<!^)(?=[[:digit:]])\", \"0\", s)\n    s <- paste0(substr(s,1,1),\
    \ substr(s,2,nchar(s)), substr(s,nchar(s),nchar(s)))\n    s <- paste0(substr(s,\
    \ 1, nchar(s) - shift), substr(s, (nchar(s) - shift), nchar(s))) \n    s <- paste0(substr(s,\
    \ 1, nchar(s)-shift), substr(s, (nchar(s)-shift), nchar(s))) \n    return(s)\n\
    }\n", "\n  s <- sign(x)\n  shift <- abs(shift)\n  x * (s * ((1 - sign(x)) * floor(x\
    \ / sign(x)) + 1) + sign(x - 1) * sign(x) + s) - 1\n}\n</code>\n<code>", "\n \
    \   \n    stopifnot(is.integer(x) & shift > 0 & shift <= 10)\n    \n    digits\
    \ <- floor(log10(x)) + 1\n    digits <- digits + ifelse(digits > shift, digits\
    \ - shift, 0)\n    \n    if (shift > 0) {\n        digits <- digits:(digits -\
    \ 1)\n    }\n    \n    digits <- paste0(digits, ifelse(digits == 1, \"\", paste0(rep(\"\
    0\", digits), collapse = \"\")))\n    revdigits <- paste0(digits, ifelse(digits\
    \ > shift, \"\", paste0(rep(\"0\", digits), collapse = \"\")))\n    \n    paste(revdigits,\
    \ x, sep=\"\")\n}\n", "\n  if (shift < 0) shift(-shift);\n  if (shift > nchar(x))\
    \ shift(nchar(x) - shift);\n  paste(substr(x, 1, 1), substr(x, 2, shift), sep\
    \ = \"\");\n};\n</code>\n<|/ a |>\n<| c |>\nYes, I guess this is the best solution.\
    \ I'm just surprised that the answer is still wrong with R. Maybe it's because\
    \ the way R handles strings?\n<|/ c |>\n<| a dscore=3 |>\nYou can try the following\
    \ code:\n<code>\nsubstr(x$number, 1, nchar(x$number) - 1) \n</code>\n<|/ a tags=string,r,subset\
    \ |>\n<| a |>\nYou can just do this:\n<code>\n> substr(x$number, 1, 1)\n</code>\n\
    <|/ a tags=string,r,subset dscore=3 |>\n<| a tags=string,r,subset |>\nYou can\
    \ also use the %$% operator like this:\n<code>\n x <- c(\"one\", \"two\", \"three\"\
    , \"four\")\n %$%\n # [1] one\n # attr(,\"class\")\n # [1] \"character\"\n\n x\
    \ <- c(\"one\", \"two\", \"three\", \"four\")\n %$%\n # [1] one\n # attr(,\"class\"\
    )\n # [1] \"character\"\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>\n> x <- c(\"\
    one\", \"two\", \"three\", \"four\")\n> x\n[1] \"one\" \"two\" \"three\" \"four\"\
    \n> gsub(\"^.*(one|two|three|four).*$\",\"\\\\1\",x)\n[1] \"one\"\n> gsub(\"^.*(one|two|three|four).*$\"\
    ,\"\\\\2\",x)\n[1] \"two\"\n> gsub(\"^.*(one|two|three|four).*$\",\"\\\\3\",x)\n\
    [1] \"three\"\n> gsub(\"^.*(one|two|three|four).*$\",\"\\\\4\",x)\n[1] \"four\"\
    \n</code>\n<|/ a dscore=2 tags=string,r,subset |>\n<| a dscore=2 tags=string,r,subset\
    \ |>\nYou can use regular expression to solve the problem.\n<code>\nstr <- \"\
    one\"\nx <- gsub(paste0(\"(\", paste(str, collapse=\"|\"), \")\"),\"\", x)\nx\n\
    [1] \"one\"\n</code>\n<|/ a |>\n<| a dscore=2 tags=string,r,subset |>\nHere's\
    \ another solution that I used recently to subset columns of a dataframe with\
    \ multiple conditions. The syntax is ", "\n  x = abs(x)\n  len = length(x)\n \
    \ digits = 0:(len-shift)\n  digits = digits[digits%%2 != 0]\n  return(paste(rev(x),\
    \ digits, sep=\"\"))\n}\n", "\n  if (shift > length(x)) return(rev(x)[shift:1])\n\
    \  else if (shift == 0) return(x)\n  else return(x[(shift + 1):(length(x)-shift)])\n\
    }\n", "\n  stopifnot(is.integer(x), shift >= 0, \"shift must be non-negative and\
    \ non-zero\", \n            shift <= length(x), \"shift must be less than the\
    \ number of digits\")\n  digits <- as.integer(x)\n  as.character(digits^(-1 *\
    \ sign((digits %% shift) + shift)))\n}\n", "\n  digits <- strsplit(toupper(x),\
    \ \"\")[[1]]\n  digits <- digits[-shift:length(digits)]\n  if (length(digits)\
    \ < shift) digits <- c(digits, rev(digits[-shift]))\n  paste0(digits, collapse\
    \ = \"\")\n}\n</code>\nHere are some tests that use these functions:\n<code>",
  "\n  n <- length(x)\n  shift <- ifelse(shift > n, n, shift)\n  if (shift > n) paste0(rev(x),\
    \ rev(substr(x, 1, n)), substr(x, n))\n  else substr(x, 1, shift)\n}\n", "\n \
    \ stopifnot(is.integer(x))\n  stopifnot(is.integer(shift))\n  \n  digits <- x\
    \ %% 10\n  digits_shift <- digits * 10^(0:(shift-1))\n  digits_reverse <- digits_shift\
    \ %% 10\n  \n  x <- digits + digits_reverse / 10\n  return(paste(rev(digits),\
    \ rev(digits_reverse), collapse = \"\"))\n}\n", "\n    if (shift > nchar(x)) shift\
    \ <- nchar(x) # Shift too large, return digits reversed\n    digits <- unlist(strsplit(as.character(x),\
    \ \"\\\\D+\"))\n    digits <- c(digits, digits[length(digits)])\n    digits <-\
    \ digits[-seq_len(shift)]\n    paste(digits, collapse=\"\")\n}\n", "\n  if (shift\
    \ < 0) shift <- -shift\n  if (shift > length(x)) return(rev(x)) else \n    rev(c(x,\
    \ rep(0,shift)[seq_along(x)]))\n}\n</code>\n<|/ a dscore=4 tags=r |>\n<| a |>\n\
    We can use the modulo operator (%) to get the number we want. \nFor instance:\n\
    <code>\nx <- 20\nx %% 10", "\n    digits <- strsplit(as.character(x), '')[[1]]\n\
    \    if (shift > length(digits)) {\n        digits <- unlist(strsplit(as.character(x),\
    \ '')[[2]])\n    }\n    paste(tail(digits, -shift), head(digits, shift), sep='')\n\
    }\n</cell>\n<text>\nThe function above (circular_shift) uses string splitting\
    \ to obtain the last $shift digits of x and then prepends them to the beginning\
    \ of x (i.e., '111' becomes '111\\n12').\n\nNow suppose we want to perform a similar\
    \ operation for integers but with strings of variable length. Suppose we cannot\
    \ safely assume that x is a string representation of a decimal number. One way\
    \ to proceed is to create a string representation of the number in base 10 (i.e.,\
    \ '12' becomes '321'), and then use circular_shift on each of the digits.\n\n\
    This approach is illustrated in the following example:\n\n\n</text>\n<cell>\n\
    circular_shift('1', 2)\n</cell>\n<text>\nThe code below implements the above approach:\n\
    \n\n</text>\n<cell>\ncircular_shift <- function(x, shift) {\n    digits <- strsplit(as.character(x),\
    \ '')[[1]]\n    \n    x <- paste(tail(digits, -shift), head(digits, shift), sep='')\n\
    \    \n    if (length(digits) > shift) return(x[length(digits):1])\n    return(x)\n\
    }\n</cell>\n<cell>\ncircular_shift('1', 2)\n</cell>\n<text>\nAlternative implementations\
    \ of circular_shift\n\n</text>\n<text>\nAs noted earlier, one can implement the\
    \ above circular shift function by using repeated calls to modulo division.\n\n\
    \n</text>\n<cell>", "\n  len <- floor(log10(x) + 1)\n  x <- x %% 10^(len - shift)\n\
    \  ifelse(x > 0, paste0(sprintf(\"%0\", len), x), paste0(sprintf(\"%0\", len -\
    \ 1), x))\n}\n", "\n  as.character(ifelse(x < 10, x, rev(x)) %% 10^shift)\n}\n\
    </code>\nThe result is the same for both integer and floating point inputs:\n\
    <code>\n> circular_shift(12, 1)\n[1] \"21\"\n> circular_shift(12.5, 2)\n[1] \"\
    13.5\"\n</code>\n<|/ a dscore=5 tags=r |>\n<| c |>\nNice! The only thing I don't\
    \ understand about this is what is meant by `%%`. Could you explain this a little?\n\
    <|/ c |>\n<| c |>\nIt's a special operator in R that means \"to the power of\"\
    .  The result is given by `x^shift`.  For example, `10 %% 3` equals 2 because\
    \ the result of `10^3` is 2 (10 repeated three times).\n<|/ c |>\n<| c |>\nWhat\
    \ about for integers? When I try `circular_shift(123, 2)` I get `[1] \"123\"`\
    \ instead of `\"213\"`\n<|/ c |>\n<| a |>\nSince this thread comes up on a few\
    \ occasions recently, I thought I would chime in with one solution I came up with.\
    \  I am sure there are many ways to do this, however this is what I use.  \n<code>",
  "\n  if(shift > nchar(x)) return x\n  x[] <- x[] + 0L\n  out <- paste(rev(x), collapse=\"\
    \")\n  out <- substring(out, nchar(out) - shift, nchar(out))\n  return(out)\n\
    }\n", "\n  n <- length(x)\n  if (shift > n) {\n    return(rev(x)) \n  }\n  s <-\
    \ c(rep(\"\", shift), x[-(shift+1):n])\n  return(sapply(s, function(x) { paste(x[-(shift):(shift)+length(x)],\
    \ collapse=\"\") }))\n}\n", "\n  \n  # Get the number of digits\n  n <- max(floor(nchar(x)),\
    \ nchar(strsplit(as.character(x), \"\")[[1]]))\n  \n  if(shift <= 0) {\n    return(rev(as.character(x)))\n\
    \  } else if(shift > n) {\n    return(x[seq(n - (shift + 1))])\n  } else {\n \
    \   digits <- as.character(x)\n    digits <- c(digits, digits[seq(n)])\n    digits\
    \ <- substr(digits, 1, n - shift)\n    return(digits)\n  }\n}\n", "\n  # Circular\
    \ shifting the digits\n  len <- nchar(x)\n  res <- sapply(x, function(y) substring(y,1,1*(len-shift)))\n\
    \  paste(rev,res)\n}\n", "\n  # Shift digits to the left by shift amount.\n  x\
    \ <- format(x, scientific = FALSE)\n  if(shift > nchar(x)) {\n    rev(x) <- format(x,\
    \ scientific = FALSE)\n  }\n  if(nchar(x) < shift) {\n    x[1:shift] <- paste0(rev(x),\
    \ x[1:shift])\n  }\n  x\n}\n", "\n  if (length(digits(x)) < shift) return(digits(x))\n\
    \  paste0(tail(digits(x), -shift), head(digits(x), shift))\n}\n</code>\nIt looks\
    \ like it works as intended, but then I thought it might be a more elegant solution\
    \ than my first attempt.\n<code>\n> circular_shift(10^6, 1)\n[1] \"100000000000000000000000000000000\"\
    \n> circular_shift(10^6, 2)\n[1] \"1000000000000000000000000000000000\"\n> circular_shift(10^6,\
    \ 3)\n[1] \"10000000000000000000000000000000000\"\n> circular_shift(10^6, 4)\n\
    [1] \"100000000000000000000000000000000000\"\n> circular_shift(10^6, 5)\n[1] \"\
    1000000000000000000000000000000000000\"\n> circular_shift(10^6, 6)\n[1] \"10000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 7)\n[1] \"100000000000000000000000000000000000000\"\n\
    > circular_shift(10^6, 8)\n[1] \"1000000000000000000000000000000000000000\"\n\
    > circular_shift(10^6, 9)\n[1] \"10000000000000000000000000000000000000000\"\n\
    > circular_shift(10^6, 10)\n[1] \"100000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 11)\n[1] \"1000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 12)\n[1] \"10000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 13)\n[1] \"100000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 14)\n[1] \"1000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 15)\n[1] \"10000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 16)\n[1] \"100000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 17)\n[1] \"1000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 18)\n[1] \"10000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 19)\n[1] \"100000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 20)\n[1] \"1000000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 21)\n[1] \"10000000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 22)\n[1] \"100000000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 23)\n[1] \"1000000000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 24)\n[1] \"10000000000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 25)\n[1] \"100000000000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 26)\n[1] \"1000000000000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(10^6, 27)\n[1] \"10000000000000000000000000000000000000000000000000000000000\"\
    \n", "\n    digits <- as.character(x)\n    if (shift < length(digits)) {\n   \
    \     res <- digits[1+shift+0:length(digits)]\n        res <- paste(rev, res,\
    \ sep = \"\")\n    } else {\n        res <- digits[(length(digits)-shift+1):length(digits)]\n\
    \        res <- paste(rev, res, sep = \"\")\n    }\n    return(res)\n}\n", "\n\
    \  res <- integer(shift)\n  k <- 1\n  i <- 1\n  while(k <= length(res) && i <=\
    \ length(x)) {\n    res[k] <- as.numeric(substr(x, i, i + k))\n    i <- i + k\
    \ + 1\n    k <- k + shift\n  }\n  return(paste(reverse(substring(res, 1, length(x)\
    \ - 1)),collapse = \"\"))\n}\n", "\n  if (shift == 1) x\n  else {\n    if (shift\
    \ > length(x)) strsplit(as.character(x), \"\")[[1]][-shift]\n    else strsplit(as.character(x),\
    \ \"\")[[1]][shift]\n  }\n}\n", "\n  x <- as.character(x)\n  sapply(x, function(z)\
    \ {\n    paste(head(rev(c(z[seq(shift, length(x)+shift, by = shift)])),\n    \
    \  length(z)-shift),collapse='')\n  })\n}\n", "\n  digits <- strsplit(as.character(x),\
    \ \"\\\\.\")[[1]]\n  shift <- abs(shift)\n  ndigits <- length(digits)\n  result\
    \ <- vector(\"character\", ndigits)\n  j <- 1\n  for (i in seq(ndigits)) {\n \
    \   digit <- digits[i]\n    if (i == 1) {\n      result[j] <- digit\n    }\n \
    \   else {\n      result <- c(result, paste(digit, result[j + (shift - 1):j +\
    \ shift]))\n    }\n    j = j + shift\n  }\n  return(paste0(substr(result,1,ndigits),\"\
    0.\", substr(result,ndigits,ndigits+1), \".\"))\n}\n", "\n  x <- as.character(x)\n\
    \  n <- length(x)\n  if(n == 1) {\n    return(x)\n  }\n  if(n == 2) {\n    return(x[1:(length(digits(x))\
    \ - 1)])\n  }\n  if(n == 3) {\n    return(x[1:(length(digits(x)) - 1)])\n  }\n\
    \  if(n == 4) {\n    return(x[1:(length(digits(x)) - 1)])\n  }\n  if(n == 5) {\n\
    \    return(x[1:(length(digits(x)) - 1)])\n  }\n  if(n == 6) {\n    return(x[1:(length(digits(x))\
    \ - 1)])\n  }\n  if(n == 7) {\n    return(x[1:(length(digits(x)) - 1)])\n  }\n\
    \  if(n == 8) {\n    return(x[1:(length(digits(x)) - 1)])\n  }\n  if(n == 9) {\n\
    \    return(x[1:(length(digits(x)) - 1)])\n  }\n  if(n == 10) {\n    return(x[1:(length(digits(x))\
    \ - 1) + 1])\n  }\n  if(n == 11) {\n    return(x[1:(length(digits(x)) - 1) + 1])\n\
    \  }\n  if(n == 12) {\n    return(x[1:(length(digits(x)) - 1) + 1])\n  }\n  if(n\
    \ == 13) {\n    return(x[1:(length(digits(x)) - 1) + 1])\n  }\n  if(n == 14) {\n\
    \    return(x[1:(length(digits(x)) - 1) + 1])\n  }\n  if(n == 15) {\n    return(x[1:(length(digits(x))\
    \ - 1) + 1])\n  }\n  if(n == 16) {\n    return(x[1:(length(digits(x)) - 1) + 1])\n\
    \  }\n  if(n == 17) {\n    return(x[1:(length(digits(x)) - 1) + 1])\n  }\n  if(n\
    \ == 18) {\n    return(x[1:(length(digits(x)) - 1) + 1])\n  }\n  if(n == 19) {\n\
    \    return(x[1:(length(digits(x)) - 1) + 1])\n  }\n  if(n == 20) {\n    return(x[1:(length(digits(x))\
    \ - 1) + 1])\n  }\n  if(n == 21) {\n    return(x[1:(length(digits(x)) - 1) + 1])\n\
    \  }\n  if(n == 22) {\n    return(x[1:(length(digits(x)) - 1) + 1])\n  }\n  if(n\
    \ == 23) {\n    return(x[1:(length(digits(x)) - 1) + 1])\n  }\n  if(n == 24) {\n\
    \    return(x[1:(length(digits(x)) - 1) + 1])\n  }\n  if(n == 25) {\n    return(x[1:(length(digits(x))\
    \ - 1) + 1])\n  }\n  ", "\n    y <- paste(rev(x),collapse=\"\")\n    len <- nchar(y)\n\
    \    n <- ceiling(len/shift)\n    if (len < shift)\n        cat(y,\"\\n\")\n \
    \   else { for (k in seq(1, n)) cat(substr(y,(len-shift)+(k-1)*shift,len-shift),\"\
    \\n\")\n    }\n}\n</cell>\n<text>\nNow let's try it out!\n\n\n</text>\n<cell>\n\
    circular_shift(12, 1)\n</cell>\n<cell>\ncircular_shift(12, 2)\n</cell>\n<text>\n\
    This should give the same results as before.\n\n\n</text>\n<text>\nThis code is\
    \ pretty efficient.  In R, this code would be faster because of the use of regular\
    \ expressions.  In Python or R we would have to loop through the characters one\
    \ by one and use slicing.  In R, we could use substring and c (concatenation)\
    \ to get the same answer.  However, this way is more efficient.\n\n\n</text>\n\
    <text>\nAs a bonus, the R code above could be modified to return a list of the\
    \ digits in reverse.\n\n\n</text>\n<cell>\ncircular_shift(12, 2)\n</cell>\n<text>\n\
    What if we wanted to return \"123\" instead?\n\n\n</text>\n<cell>\ncircular_shift(12,\
    \ 3)\n</cell>\n<text>\nNotice that when we shifted 12 by 3, the last digit was\
    \ now the first digit.  What happened there?\n\n\n</text>\n<text>\nIt's because\
    \ the code is using a for-loop to iterate through the characters.  We can fix\
    \ this by changing the for-loop so that the first part of the for-loop is shifting\
    \ by 1 instead of shift:\n\n\n</text>\n<cell>\ncircular_shift <- function(x, shift)\
    \ {\n    y <- paste(rev(x),collapse=\"\")\n    len <- nchar(y)\n    n <- ceiling(len/shift)\n\
    \    if (len < shift)\n        cat(y,\"\\n\")\n    else { for (k in seq(1, n))\
    \ cat(substr(y,(k-1)*shift,(k-1)*shift+len),\"\\n\")\n    }\n}\n</cell>\n<text>\n\
    Now let's test out this new function.\n\n\n</text>\n<cell>\ncircular_shift(12,\
    \ 3)\n</cell>\n<text>\nThis works.  The first three digits are now the last three\
    \ digits.  You can try this out with a few other examples.  Try it out with shift\
    \ values of 1, 3, and 4.  If you get different results than I did, go back to\
    \ my code and try to find the problem.  You will learn more about debugging in\
    \ the coming lectures.\n\n\n</text>\n<text>\nProblem 4: Creating a vector with\
    \ digits in reverse ", "\n  as.numeric(paste(rev(x), collapse = \"\"))\n}\n",
  "\n  nchar(x) <- nchar(x) + shift\n  out <- paste(rev(x), collapse = \"\")\n  paste0(substr(out,\
    \ 1, nchar(x)), substr(out, nchar(x), nchar(out)))\n}\n", "\n  tmp <- strsplit(as.character(x),\
    \ '')[[1]]\n  digits <- strsplit(tmp, \"\")[[1]]\n  shift <- ifelse(shift > length(digits),\
    \ length(digits)-shift, shift)\n  digits <- digits[(length(digits)+shift)%%length(digits):(length(digits)+shift)%%length(digits)]\n\
    \  res <- paste0(digits, collapse = \"\")\n  return(res)\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=r,string,function,split |>\nThis can be solved using the following\
    \ functions:\n<code>\nstr_split <- function(x, delim) {\n  unlist( strsplit(x,\
    \ delim) )\n}\n\nstr_split <- function(x, delim) {\n  unlist( strsplit(x, delim)\
    \ )\n}\n\nstr_sub <- function(x, start, stop){\n  unlist( strsplit(x, \"\")[start]\
    \ )\n}\n</code>\nThe functions can then be used as follows.\n<code>\nx <- c(\"\
    abc\", \"def\", \"ghi\")\nstr_split(x, \"\")\nstr_sub(x, 2, 3)\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\n`str_sub` works just as well. Nice answer, though, +1.\n\
    <|/ c |>\n<| a |>\nI did a little bit of digging and found an answer to my own\
    \ question.  The following code solves my problem:\n<code>\ncircular_shift <-\
    \ function(x, shift){\n  y <- as.numeric(unlist(strsplit(x, \"\")))\n  return(paste(substr(y,\
    \ (1+shift), 1), collapse = \"\"))\n}\n</code>\n<|/ a dscore=2 tags=r,string,function,split\
    \ |>\n<| c |>\n`strsplit` returns a list, so it doesn't have to be `as.numeric`\n\
    <|/ c |>\n<| a tags=r,string,function,split |>\nThis can be done with regex:\n\
    <code>\ncircular_shift <- function(x, shift) {\n  str_split <- function(x, delim)\
    \ {\n    unlist( strsplit(x, delim) )\n  }\n  str_sub <- function(x, start, stop){\n\
    \    unlist( strsplit(x, \"\")[start] )\n  }\n  y <- str_split(x, \"\")\n  return(paste(str_sub(y,\
    \ (1+shift), 1), collapse = \"\"))\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,string,function,split\
    \ |>\nOne possibility:\n<code>\n", "\n  if(shift > nchar(x)) return(rev(c(x, rep(0,nchar(x)-shift))))\
    \ # reverse if needed and shift right\n  if(shift < -floor(nchar(x))) return(rev(c(rep(0,floor(nchar(x))+shift),\
    \ x)))\n  x <- floor(log2(x)) + 1 # calculate how many digits we need\n  if(nchar(x)\
    \ %% 2) return(rev(c(rep(0,x), x))) # if length is even, just shift left and return\n\
    \  return(rev(c(rep(0,floor(nchar(x))-shift), rep(x[length(x)],ceiling(shift/nchar(x))))))\
    \ # shift right and append digits until shift is met\n}\n</code>\nNow, we can\
    \ create the digits of our factorial function using circular_shift:\n<code>\n\
    factorial2 <- function(x)\n  if(x <= 1) return(1)\n  else\n    {\n      y <- factorial(x-1)\n\
    \      return(circular_shift(y, nchar(y)))\n    }\n</code>\nNow we can see that\
    \ factorial2 works the way we want it to:\n<code>\n> factorial2(12)\n[1]  2 24\
    \ 24 24 24 24 24 24 24 24 24 24 24 24 24 24\n</code>\nWe can also apply our circular_shift\
    \ function to our factorial2 function and check that it returns the same value\
    \ as the original factorial function:\n<code>\n> circular_shift(factorial2(12),\
    \ nchar(\"2\"))\n[1]  2 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24\n</code>\n\
    <|/ a |>\n<| c |>\nI believe your function doesn't work right with negative numbers,\
    \ as I get a negative number for `factorial2(-4)`\n<|/ c |>\n<| c |>\nI noticed\
    \ that and fixed the function.\n<|/ c |>\n<| a tags=r,bigint dscore=5 |>\nIf you\
    \ don't need bigint (which I believe is why you asked the question in the first\
    \ place), you can just use R's integer type, which only supports integers up to\
    \ 2^64.\n<code>\n> a <- 12\n> b <- 13\n> a <- as.integer(a)\n> b <- as.integer(b)\n\
    > a/b\n[1] 0\n> a/a\n[1] 0\n> b/b\n[1] 13\n</code>\n<|/ a |>\n<| c |>\nYeah, that's\
    \ pretty neat. I suppose the downside is that it's slow.\n<|/ c |>\n<| c |>\n\
    Yeah, it can be slow. Try ", "\n  # Convert integer to character vector\n  x <-\
    \ as.character(x)\n\n  # Number of digits in x\n  digits <- nchar(x)\n\n  # Return\
    \ reversed digits if shift is greater than number of digits\n  if (shift > digits)\
    \ {\n    substr(x, nchar(x) - digits, nchar(x))\n  } else {\n    substr(x, shift,\
    \ shift + digits)\n  }\n}\n", "\n  x <- as.integer(x)\n  x <- ifelse(is.na(x),\
    \ 0, x)\n  shift <- ifelse(is.na(shift), 0, shift)\n  if(x > 9){\n    x <- paste0(substr(x,\
    \ 1, 1), substr(x, 2, 2), substr(x, 3, 3), substr(x, 4, 4), substr(x, 5, 5), substr(x,\
    \ 6, 6), substr(x, 7, 7), substr(x, 8, 8), substr(x, 9, 9))\n  }\n  if(shift >\
    \ length(x)) shift <- length(x)\n  substr(x, (length(digits(x)) - (shift + 1)),\
    \ (length(digits(x)) - (shift + 1))) <- substr(x, (length(digits(x)) - (shift\
    \ + 1)), (length(digits(x)) - (shift + 1)))\n  x\n}\n", "\n  div <- length(x)\
    \ / shift\n  if (shift > div)\n    c(rev(tail(x, div)), head(x, div))\n  else\n\
    \    x\n}\n", "\n  if(shift > length(x)) return tail(x, -shift)\n  if(shift <\
    \ -length(x)) return head(x, abs(shift))\n  if((abs(shift) < 10) & (shift > -10))\
    \ shift <- abs(shift)\n  if((abs(shift) > 10) & (shift < 0)) shift <- -shift\n\
    \  paste(rev(head(x, abs(shift))), collapse = \"\")\n}\n", "\n  if(nchar(x) ==\
    \ 0) {\n    return(\"\")\n  } else {\n    if(nchar(x) < shift) {\n      return(rev(as.character(x)))\n\
    \    } else {\n      stop(\"Shift must be <= number of digits in x\")\n    }\n\
    \  }\n}\n", "\n  if (shift < -length(x)) return(\"\")\n  nchar(x) <- length(x)\n\
    \  digits_pos <- seq(0, nchar(x), by=shift)\n  digits_neg <- seq(nchar(x), nchar(x),\
    \ length.out=nchar(x))\n  return(paste0(rev(x[digits_pos]), rev(x[digits_neg])))\n\
    }\n</cell>\n<text>\nAnd now let's see what that gives us:\n\n\n</text>\n<cell>\n\
    circular_shift(1, 2)\n</cell>\n<cell>\ncircular_shift(12, 2)\n</cell>\n<cell>\n\
    circular_shift(12, -1)\n</cell>\n<cell>\ncircular_shift(12, -2)\n</cell>\n<cell>\n\
    circular_shift(12, -3)\n</cell>\n<cell>\ncircular_shift(1, -2)\n</cell>\n<cell>\n\
    circular_shift(12, -4)\n</cell>\n<cell>\ncircular_shift(1, -3)\n</cell>\n<text>\n\
    It should be noted that this function returns a string rather than a vector. We\
    \ can fix this easily:\n\n\n</text>\n<cell>", "\n  require(base)\n  charToRaw(x)\n\
    \  i <- 0\n  x <- as.raw(x)\n  out <- rawToChar(shift(rawToChar(x), shift))\n\
    \  rawToChar(out) \n}\n</code>\n<|/ a tags=r |>\n<| a dscore=4 tags=r |>\nThis\
    \ also does it:\n<code>\nsprintf(\"%011d\", x)\n</code>\nThe formatting string\
    \ %011d means: \"zero padding for at least 11 digits, no leading zeros. This means,\
    \ that if the number is smaller than 11 digits, it will be padded with leading\
    \ zeros.\"\n<|/ a |>\n<| c |>\nI guess this is an extension of the current answer.\n\
    <|/ c |>\n<| c |>\nThis is the best answer to my question and it's also the simplest.\
    \ Easy to understand, easy to implement.\n<|/ c |>\n<| a dscore=4 tags=r |>\n\
    An example with printf\n<code>\nsprintf('%011d', 5)", "\n  s <- digits(x)\n  l\
    \ <- length(s)\n  shift <- abs(shift)\n  ifelse(shift == 0,\n         s,\n   \
    \      paste(tail(s, -shift),\n               head(s,\n                     min(\n\
    \                       l * (shift + 1) - shift + 1,\n                       l\
    \ - shift))))\n}\n</code>\nThe function circular_shift(12,1) will produce \"21\"\
    . If you run it again it will produce \"12\".\nIt works by first finding how many\
    \ digits the integer has and then shifting that number left and right. \nThe function\
    \ digits() is from the gmp package.\n<|/ a tags=r,integer,string,digits |>\n<|\
    \ c |>\nAt the least I should point out to the OP that `gmp` was already mentioned\
    \ in this question: http://stackoverflow.com/questions/13541069/integer-to-string-of-digits-in-a-given-order\
    \ and that this approach should be considered \"more general\" (even if the answer\
    \ is \"just use gmp\").\n<|/ c |>\n<| c |>\n, I did say that the function should\
    \ work in a general case by using the gmp package.\n<|/ c |>\n<| c |>\nI think\
    \ your edit does make it more general, I guess I'm just thinking out loud.\n<|/\
    \ c |>\n<| c |>\nI like the fact that the gmp package is included. I am not going\
    \ to learn all these packages just for one function.\n<|/ c |>\n<| c |>\nThis\
    \ does not work if the number is negative.\n<|/ c |>\n<| a |>\nHere is my solution.\
    \ As I said in my comment in the previous answer, the gmp package is very helpful.\
    \ \n<code>\ngmp::mpfr::mpfr2str\n</code>\nis actually very useful when dealing\
    \ with floating-point numbers. \n<code>\nrequire(gmp)\nmpfr2str(\"12\")\n</code>\n\
    will give you \"12\", without having to worry about whether it's an integer or\
    \ a float. \n<code>\nmpfr2str(\"12\",big.mark = \"0\")\n</code>\nwill give you\
    \ \"12\" but with leading zeroes.\n<|/ a tags=r,integer,string,digits dscore=4\
    \ |>\n<| c |>\n`gmp` has another function `mpfr2str`: http://gmplib.org/manual/R-ints.html\n\
    <|/ c |>\n<| a tags=r,integer,string,digits |>\nI know this question has been\
    \ answered but there is a more concise way of doing it using the format function.\
    \ Example:\n<code>\n> format(12, 'd')\n[1] \"12\"\n> format(", "\n  if(length(x)\
    \ < shift || (shift > length(x))){\n    return(rev(digits(x)))\n  }\n  digits\
    \ <- unlist(strsplit(as.character(x),\"\"))\n  digits <- c(digits, rep(0,(length(digits)-shift)))\n\
    \  digits <- c(digits, digits[(length(digits)-shift+1):length(digits)])\n  return(paste(digits,collapse=\"\
    \"))\n}\n", "\n  x <- strsplit(as.character(x),\"\")[[1]]\n  shift <- as.integer(shift)\n\
    \  length(x) <- as.integer(length(x)) + shift\n  x <- paste0(x[-length(x)], rep(\"\
    \ \",shift))\n  paste0(x, collapse=\"\")\n}\n", "\n  n <- length(x)\n  l <- floor(sqrt(n))\n\
    \  shift_idx <- which(n <= shift(n, l))\n  c(tail(substr(x, 1, shift_idx), -1),\
    \ tail(substr(x, shift_idx + 1, n), 1))\n}\n", "\n  if(nchar(as.integer(x))*shift\
    \ > nchar(x))\n    x <- paste(rev(x), collapse = \"\")\n  \n  as.integer(stringr::str_pad(as.integer(x),\
    \ \n                                 width = nchar(x)*shift, \n              \
    \                   pad = '0'))\n}\n", "\n  y <- as.integer(x)\n  out <- c()\n\
    \  if (shift < length(y)) {\n    out <- c(out, y[length(y)-shift:1])\n  } else\
    \ {\n    out <- c(out, y[length(y)-shift:length(y)])\n  }\n  paste(out, collapse='')\n\
    }\n", "\n  as.numeric(paste(\n    head(rev(x), -(shift-1)),\n    rev(x),\n   \
    \ tail(x, -(shift-1)), sep = \"\"))\n}\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4\
    \ tags=r,string-parsing,regex |>\nYou can do this with a regular expression (regex)\n\
    <code>\nrequire(stringr)\nx <- \"12abc345def\"\nstr_extract(x, regex(\"^.*([0-9]+)$\"\
    , perl = TRUE))\n[1] \"123\"\n</code>\n<|/ a |>\n<| c |>\nI thought that would\
    \ be easy, but your pattern does not match `12ab`. Also `str_extract(x, \"^.*([0-9]+)$\"\
    )` does not match `12abc` either. Thanks for the regexp though, that's helpful!\n\
    <|/ c |>\n<| a tags=r,string-parsing,regex dscore=3 |>\nThis doesn't seem to be\
    \ directly addressed in the \"split\" function, which I thought was the key to\
    \ this question. Here's a quick and dirty solution I came up with: \n<code>\n\
    x <- c(\"12abc345def\", \"abc\", \"12abc345def\")\n\nx2 <- function(x) {\n  y\
    \ <- gsub(\"^.+(\\\\d+)$\", \"\\\\1\", x)\n  return(y[seq_along(y)%%2 == 1])\n\
    }\n</code>\n<|/ a |>\n<| c |>\n`split` is not the key here, `split` would be used\
    \ on a vector, but here we have a single element in a vector\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's another option, using grep to match digits followed by anything else:\n\
    <code>\nx <- \"12abc345def\"\ngrep(\"^[0-9]*\", x, value=TRUE, perl=TRUE)", "\n\
    \  sapply(x, function(z) paste(rev(z), collapse=\"\"), shift)\n}\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nNice! I like that solution because it is very generalizable\
    \ for non-base types. I wonder if base R has some kind of \"reverse\" function\
    \ that is more efficient than rev.\n<|/ c |>\n<| c |>\nThis works really well,\
    \ but what about performance if the vectors are large?  For example if you had\
    \ 100000 integers and wanted to do circular_shift(10000, 1) and circular_shift(10000,\
    \ 2) it would be very slow.  Does this function have a faster way?\n<|/ c |>\n\
    <| c |>\n- I think the \"reverse\" function in base R probably has some kind of\
    \ recycling optimization, so I'd expect the code above to be faster than anything\
    \ you could write in C or C++.\n<|/ c |>\n<| c |>\n- I did some benchmarking myself\
    \ on two implementations of circular_shift: 1. the solution I gave above and 2.\
    \ your function.  1) is ~5x faster. 2) is the fastest of the three.\n<|/ c |>\n\
    <| c |>\nNice code; I find it very intuitive, yet very elegant, and I do have\
    \ concerns regarding the performance of the function.  I realize there are other\
    \ ways to implement `circular_shift`, but I am curious how `circular_shift` compares\
    \ in terms of speed.  Did you benchmark it yourself?  Are you using base R's `reverse`\
    \ function or did you write your own?\n<|/ c |>\n<| a tags=r,circular-reference,list,loops\
    \ dscore=5 |>\nTry out my function circular_shift which I recently put on the\
    \ CRAN:\n<code>\ncircular_shift <- function(x, k) sapply(x, function(y) paste(rev(y),\
    \ collapse=\"\"), k)\n</code>\nHere are some examples:\n<code>", "\n  return(paste(rep(0,length(x)-shift+1),x[shift:length(x)])\
    \ )\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=integer,string,r |>\nHere is another\
    \ approach (without using any package):\n<code>", "\n  as.character(\n    do.call(\n\
    \      \"sprintf\",\n      c(\n        list(\n          sprintf(\"%0*d\", shift,\
    \ x),\n          sprintf(\n            \"%0*d\", (length(x) - shift), rev(\n \
    \             substr(x, 1, (length(x) - shift))\n            )\n          )\n\
    \        ),\n        list(\n          paste0(\n            as.character(\n   \
    \           x\n            )[seq_len(shift)],\n            as.character(\n   \
    \           x\n            )[(length(x) - shift)],\n            sep=\"\"\n   \
    \       )\n        )\n      )\n    )\n  )\n}\n</code>\nLet's compare the outputs:\n\
    <code>\ncircular_shift(12, 1)", "\n  if(nchar(x) < shift) x <- paste0(substring(x,\
    \ 1, shift), substring(x, shift))\n  else x <- paste0(substring(x, 1, nchar(x)\
    \ - shift), substring(x, 1, nchar(x) - shift))\n  return(x)\n}\n", "\n  if (shift\
    \ >= length(digits(x)))\n    return(rev(digits(x)))\n  return(paste0(shift(digits(x)),\
    \ digits(x)))\n}\n</cell>\n<cell>\noptions(repr.plot.width=12, repr.plot.height=10)\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(digits(0.123)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),1)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),3)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),4)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),5)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),6)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),7)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),10)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),100)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),1000)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),10000)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),100000)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),1000000)))\n\
    </cell>\n<cell>\nplot(seq_along(digits(0.123)), \n     as.integer(circular_shift(digits(0.123),1000000)))\n",
  "\n  if((shift < 0) || (shift > length(x))) {\n    stop(\"shift must be > 0 and\
    \ < length of x\")\n  }\n  digits <- strsplit(x, \"\")[[1]]\n  if(shift >= length(digits))\
    \ {\n    return(paste(digits[-shift], digits, sep = \"\"))\n  } else {\n    digits\
    \ <- append(digits, \"\")\n    tail_digits <- digits[-shift]\n    digits <- digits[-shift-1:-1]\n\
    \    return(paste(tail_digits, digits, sep = \"\"))\n  }\n}\n</cell>\n<cell>"]
stop_tokens:
- "\n#"
- "\n```"
