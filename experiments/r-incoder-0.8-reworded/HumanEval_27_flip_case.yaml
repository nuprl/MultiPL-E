name: HumanEval_27_flip_case
language: r
prompt: "# For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n# >>> flip_case('Hello')\n# 'hELLO'\nflip_case <- function(string)\
  \ {"
tests: "test_humaneval <- function() {\ncandidate <- flip_case\n    if(!identical(candidate(''),\
  \ '')){quit('no', 1)}\n    if(!identical(candidate('Hello!'), 'hELLO!')){quit('no',\
  \ 1)}\n    if(!identical(candidate('These violent delights have violent ends'),\
  \ 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  string <- toupper(tolower(string))\n  return(string)\n}\n", "\n\
    \  toUpper <- function(s) { tolower(s) }\n  toLower <- function(s) { toupper(s)\
    \ }\n  toUpper(string)\n}\n</code>\n<|/ a tags=r,string,capitalization dscore=5\
    \ |>\n<| c |>\nThe first one was my favorite :)\n<|/ c |>\n<| c |>\nWhat about\
    \ `toUpper` instead of `toLower`?\n<|/ c |>\n<| c |>\n`toUpper` is the default\
    \ case transformation function, so it's not needed. `toLower` would do what `toUpper`\
    \ does.\n<|/ c |>\n<| c |>\nAh, that makes sense. I was wondering why `toUpper`\
    \ was the default function, but never thought of why `toLower` would do what the\
    \ other would do. Thanks!\n<|/ c |>\n<| c |>\n, your method doesn't work for me\
    \ if strings are longer than one character.  Is there a way to get this to work?\
    \  For instance, `flip_case(c(\"a\", \"ab\"))` results in `c(\"A\", \"AB\")`.\
    \  I'd expect `c(\"a\", \"AB\")`.\n<|/ c |>\n<| a |>\nUse toupper/tolower as suggested\
    \ in the comments:\n<code>\nx <- c(\"A\", \"B\", \"C\")\ntoupper(x)", "\n  sapply(stringtolower(string),\
    \ function(x) ifelse(x == 'a', x, toupper(x)))\n}\n", "\n  paste(toupper(substring(string,\
    \ 1, 1)),\n        substring(string, 2),\n        tolower(substring(string, 1,\
    \ 1)))\n}\n</cell>\n<cell>", "\n  return(gsub(toupper(string), tolower(string),\
    \ string))\n}\n", "\n  str <- str_to_lower(string)\n  str <- str_replace_all(str,\
    \ '[A-Z]', '[[:upper:]]')\n  str <- str_replace_all(str, '[a-z]', '[[:lower:]]')\n\
    \  str\n}\n</cell>\n<cell>", "\n  string[[1]] <- toupper(string[[1]])\n  paste(tolower(string[[1]]),\
    \ string[[2]])\n}\n", "\n  return(gsub(toupper, toLowerCase, string))\n}\n", "\n\
    \    string <- tolower(string)\n    string <- toupper(string)\n    return(string)\n\
    }\n", "\n  string %>% \n    str_split(\"[-_]\") %>% \n    map_chr(~str_upper(.x)\
    \ %>% str_lower(.x)) %>% \n    paste(., collapse = \"\")\n}\n\nflip_case(\"Hello\"\
    )\n</code>\n<|/ a dscore=1 |>\n<| a tags=regex,string,r |>\n<code>\nlibrary(stringr)\n\
    str_toupper(\"hello World\", ignore_case = T)\n[1] \"HELLO WORLD\"\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=regex,string,r dscore=1 |>\nHere's an approach:\n\
    <code>\n> toUPper <- function(txt)\n+ {\n+   if(length(txt) <= 0)\n+     return(txt)\n\
    +   tmp <- paste(toupper(substr(txt,1,1)),substr(txt,2,nchar(txt)),sep=\"\")\n\
    +   if(length(txt) > 1)\n+     tmp <- paste(tmp,toUPper(substring(txt,3,nchar(txt))))\n\
    +   return(tmp)\n+ }\n> \n> toUPper(\"hello\")\n[1] \"HELLO\"\n</code>\n<|/ a\
    \ |>\n<| a dscore=1 |>\nTo add onto the other solutions offered here, I've provided\
    \ a more flexible function that can handle longer strings. It's not necessarily\
    \ efficient, but it's a starting point and it will help you learn more about the\
    \ string manipulation functions in R.\n<code>\nflip_case_longer <- function(string){\n\
    \  result <- \"\"\n  \n  while(length(string) > 0){\n    next_string <- substr(string,\
    \ 1, 1)\n    \n    letter_to_upper <- ifelse(next_string == \"a\" | next_string\
    \ == \"e\" | next_string == \"i\" | next_string == \"o\" | next_string == \"u\"\
    ,\n                               next_string == \"A\" | next_string == \"E\"\
    \ | next_string == \"I\" | next_string == \"O\" | next_string == \"U\",\n    \
    \                           next_string == \"a\")\n    \n    letter_to_lower <-\
    \ ifelse(next_string == \"a\" | next_string == \"e\" | next_string == \"i\" |\
    \ next_string == \"o\" | next_string == \"u\",\n                             \
    \  next_string == \"a\" | next_string == \"e\" | next_string == \"i\" | next_string\
    \ == \"o\" | next_string == \"u\",\n                               next_string\
    \ == \"a\")\n    \n    letter_to_upper <- paste0(letter_to_upper, next_string)\n\
    \    letter_to_lower <- paste0(letter_to_lower, next_string)\n    \n    string\
    \ <- substring(string, 2)\n    \n    string <- paste0(", "\n    string <- tolower(string)\n\
    \    string <- toupper(string)\n    return(string)\n}\nflip_case(\"HELLO\") #\
    \ Strings are immutable, so this returns a new string instead of changing the\
    \ original.\n</cell>\n<cell>", "\n  string %>% \n    str_split('') %>% \n    str_transform()\
    \ %>% \n    str_replace(toupper, tolower) %>% \n    str_replace(tolower, toupper)\n\
    }\n\nflip_case('hello')", "\n  chars <- str_split(string, \"\")[[1]]\n  chars[lower.chars(chars)]\
    \ <- upper.chars(chars)\n  paste(chars, collapse = \"\")\n}\n", "\n  str_tolower(string)\
    \ %>% str_toupper() %>% str_to_title()\n}\n", "\n  # Convert the input string\
    \ to lower case.\n  string <- tolower(string)\n  # Split the input string into\
    \ characters.\n  character_vector <- unlist(strsplit(string, ''))\n  # Return\
    \ a new string where each character (except the first one) is replaced by its\
    \ uppercase equivalent.\n  return(unlist(lapply(character_vector, function(x)\
    \ substr(x, 1, 1) <- substr(x, 1, 1) <- toupper(x))))\n}\n", "\n    paste(unlist(strsplit(string,\
    \ \"\")), collapse = \"\")\n}\n", "\n    out <- tolower(string)\n    out <- toupper(out)\n\
    \    return(out)\n}\n</cell>\n<cell>\nflip_case(\"Hello, World\")\n</cell>\n<cell>\n\
    flip_case(\"hello, world\")\n</cell>\n<text>\nGreat Job!\n\n</text>\n<text>\n\
    Exercises:\n1) Try to write your own functions - there are many ways to do it.\n\
    \n\n</text>\n<text>\n2) Read this article: \n2) Try another function\n\n\n</text>\n\
    <cell>", "\n  string <- gsub('([a-z])([A-Z])', '\\\\1\\\\2', string)\n  string\
    \ <- gsub('([A-Z])([A-Z])', '\\\\1\\\\2', string)\n  return(toupper(string))\n\
    }\n", "\n  string <- tolower(string)\n  string <- toupper(string)\n  string\n\
    }\n", "\n    string %>% \n        stri_trans_toupper() %>%\n        stri_trans_tolower()\n\
    }\n\nflip_case('hello')", "\n    string %>% \n        make.to.upper() %>% \n \
    \       make.to.lower()\n}\n", "\n  toupper(string) %>% tolower() %>% toupper()\n\
    }\n</code>\nTo test it, we need to flip both uppercase and lowercase strings:\n\
    <code>", "\n  return(gsub(toupper(tolower(string)), toupper(string), string))\n\
    }\n", "\n  gsub(\"[A-Z]\", \"\\\\U\\\\1\", gsub(\"[a-z]\", \"\\\\l\\\\1\", string))\n\
    }\n</cell>\n<text>\nLet's use some more complex string manipulations and apply\
    \ this function to some strings.\n\n\n</text>\n<cell>", "\n  str_to_lower(gsub(\"\
    [a-z]\", \"[A-Z]\", string))\n}\n", "\n  gsub('([a-z])([A-Z])', '\\\\1\\\\2',\
    \ tolower(string))\n}\n", "\n  gsub(toupper(string), tolower(string), string)\n\
    }\n", "\n    str_replace_all(string, c(\"a\", \"A\", \"e\", \"E\", \"i\", \"I\"\
    , \"o\", \"O\", \"u\", \"U\", \"y\", \"Y\", \"+\", \"-\", \"*\", \"/\", \"&\"\
    , \"!\", \"<\", \">\", \"=\", \",\", \".\", \"?\", \"^\", \"~\", \"-\", \";\"\
    , \":\", \"?\", \"_\", \"&\", \"!\", \"<\", \">\", \"=\", \",\", \".\", \"?\"\
    , \"^\", \"~\", \"-\", \";\", \":\", \"?\", \"_\", \"&\", \"!\", \"<\", \">\"\
    , \"=\", \",\", \".\", \"?\", \"^\", \"~\", \"-\", \";\", \":\", \"?\", \"_\"\
    , \"&\", \"!\", \"<\", \">\", \"=\", \",\", \".\", \"?\", \"^\", \"~\", \"-\"\
    , \";\", \":\", \"?\", \"_\", \"&\", \"!\", \"<\", \">\", \"=\", \",\", \".\"\
    , \"?\", \"^\", \"~\", \"-\", \";\", \":\", \"?\", \"_\", \"&\", \"!\", \"<\"\
    , \">\", \"=\", \",\", \".\", \"?\", \"^\", \"~\", \"-\", \";\", \":\", \"?\"\
    , \"_\", \"&\", \"!\", \"<\", \">\", \"=\", \",\", \".\", \"?\", \"^\", \"~\"\
    , \"-\", \";\", \":\", \"?\", \"_\", \"&\", \"!\", \"<\", \">\", \"=\", \",\"\
    , \".\", \"?\", \"^\", \"~\", \"-\", \";\", \":\", \"?\", \"_\", \"&\", \"!\"\
    , \"<\", \">\", \"=\", \",\", \".\", \"?\", \"^\", \"~\", \"-\", \";\", \":\"\
    , \"?\", \"_\", \"&\", \"!\", \"<\", \">\", \"=\", \",\", \".\", \"?\", \"^\"\
    , \"~\", \"-\", \";\", \":\", \"?\", \"_\", \"&\", \"!\", \"<\", \">\", \"=\"\
    , \",\", \".\", \"?\", \"^\", \"~\", \"-\", \";\", \":\", \"?\", \"_\", \"&\"\
    , \"!\", \"<\", \">\", \"=\", \",\", \".\", \"?\", \"^\", \"~\", \"-\", \";\"\
    , \":\", \"?\", \"_\", \"&\", \"!\", \"<\", \">\", \"=\", \",\", \".\", \"?\"\
    , \"^\", \"~\", \"-\", \";\", \":\", \"?\", \"_\", \"&\", \"!\", \"<\", \">\"\
    , \"=\", \",\", \".\", \"?\", \"^\", \"~\", \"-\", \";\", \":\", \"?\", \"_\"\
    , \"&\", \"!\", \"<\", \">\", \"=\", \",\", \".\", \"?\", \"^\", \"~\", \"-\"\
    , \";\", \":\", \"?\", \"_\", \"&\", \"!\", \"<\", \">\", \"=\", \",\", \".\"\
    , \"?\", \"^\", \"~\", \"-\", \";\", \":\", \"?\", \"_\", \"&\", \"!\", \"<\"\
    , \">\", \"=\", \",\", \".\", \"?\", \"^\", \"~\", \"-\", \";\", \":\", \"?\"\
    , \"_\", \"&\", \"", "\n  string <- gsub(\"([a-z])([A-Z])\", \"\\\\1\\\\2\", string)\n\
    \  string <- gsub(\"([A-Z])([A-Z][a-z])\", \"\\\\1\\\\2\", string)\n  return(string)\n\
    }\n\nflip_case(\"Hello\")\nflip_case(\"hELLO\")\nflip_case(\"HellO\")\nflip_case(\"\
    hello\")\nflip_case(\"hELlo\")\nflip_case(\"HELLO\")\nflip_case(\"helloworld\"\
    )\nflip_case(\"hELLoWrd\")\nflip_case(\"helloWorld\")\nflip_case(\"helloWorld\"\
    ) # no change\nflip_case(\"helloworld\") # no change\nflip_case(\"HelloWorld\"\
    ) # no change\n", "\n  string %>% str_to_lower() %>% str_to_upper() %>% str_to_lower()\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nAs already noted, using regex\
    \ to capitalize the first letter will work:\n<code>\nmyString <- c(\"Awesome\"\
    , \"Awesome string\", \"Not too bad\", \"No problem\")\nmyString <- gsub(\"^\\\
    \\p{L}\", \"\", myString)\ntoUpper <- function(x) {\n  ifelse(x %in% c(\"No\"\
    , \"Nope\"), \"\", toUpper(sub(\"\\\\p{L}\", \"\", x)))\n}\ntoUpper(myString)\n\
    [1] \"AWESOME\"        \"AWESOME STRING\" \"NOT TOO BAD\"      \"NO PROBLEM\"\n\
    </code>\nIf you wanted to do that for the whole string, you could do something\
    \ like this:\n<code>\ntoUpper <- function(x) {\n  ifelse(x %in% c(\"No\", \"Nope\"\
    ), \"\", toUpper(sub(\"\\\\p{L}\", \"\", x))) %>% paste0(toUpper(x), collapse\
    \ = \" \")\n}\n\ntoUpper(myString)\n[1] \"AWESOME STRING\" \"NOT TOO BAD\"   \
    \   \"NO PROBLEM\"\n</code>\n<|/ a tags=r,string,capitalize |>\n<| a |>\nThe stringi\
    \ package allows capitalization by index or pattern matching:\n<code>\nlibrary(stringi)\n\
    \ncap(\"hello\")", "\n  string <- toupper(as.character(string))\n  string <- tolower(string)\n\
    \  return(string)\n}\n", "\n  charToRaw(tolower(string)) %<>%\n  paste0(toupper(substring(.x,\
    \ 1, 1)), substring(.x, 2))\n}\n</code>\nThen we can use purrr::map to do the\
    \ whole conversion:\n<code>", "\n  # Regex to match upper case characters in string\n\
    \  upper_case <- \"[A-Z]+\"\n  # Regex to match lower case characters in string\n\
    \  lower_case <- \"[a-z]+\"\n  # Return input string with each character flipped.\n\
    \  gsub(upper_case, upper_case %R% lower_case, string)\n}\n", "\n  chartr(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    , \"abcdefghijklmnopqrstuvwxyz\", string)\n}\n", "\n  lower <- tolower(string)\n\
    \  upper <- toupper(lower)\n  return(upper)\n}\n", "\n  string %>% str_to_lower()\
    \ %>% str_to_upper() %>% str_to_lower()\n}\n", "\n  gsub('(.)([a-z])', '$\\\\\
    1\\\\2', tolower(string))\n}\n\nflip_case('hello')\nflip_case('HELLO')\nflip_case('Hello')\n\
    </cell>\n<cell>", "\n  toupper(string)\n}\n", "\n  string <- gsub(\"(.)([A-Z])\"\
    , \"\\\\U\\\\1\", string)\n  string <- gsub(\"([a-z])([A-Z])\", \"\\\\1\\\\2\"\
    , string)\n  string\n}\n</cell>\n<cell>", "\n  for( i in seq_along(string) ) {\n\
    \    if( i==1 ) {\n      string[i] <- toupper(string[i])\n    } else {\n     \
    \ string[i] <- tolower(string[i])\n    }\n  }\n  return(string)\n}\n", "\n  string\
    \ <- tolower(string)\n  string <- toupper(string)\n  return(string)\n}\n", "\n\
    \  gsub(\"(.)([a-z])\", toupper(\"\\\\1\\\\2\"), string)\n}\n", "\n  return(tolower(string)\
    \ %>% toupper())\n}\n", "\n  string <- gsub(\"[a-z]\", \"U\\\\1\", string)\n \
    \ string <- gsub(\"U[A-Z]\", \"[a-z]\", string)\n  return(string)\n}\n", "\n \
    \   chartr(\"[[:lower:]]\", \"[[:upper:]]\", string)\n}\n</cell>\n<cell>", "\n\
    \  gsub(\"(.)\", \"\\\\U\\\\1\", string)\n}\n</cell>\n<cell>", "\n  str_tolower(string)\
    \ %>% \n    str_replace(c(\"A\", \"a\", \"B\", \"b\", \"C\", \"c\", \"D\", \"\
    d\", \"E\", \"e\", \"F\", \"f\"), \n                c(toupper(\"A\"), toupper(\"\
    a\"), toupper(\"B\"), toupper(\"b\"), toupper(\"C\"), toupper(\"c\"), toupper(\"\
    D\"), toupper(\"d\"), toupper(\"E\"), toupper(\"e\"), toupper(\"F\"), toupper(\"\
    f\"))\n)\n}\n</code>\n<|/ a tags=tidyverse,string,dplyr,regex,r dscore=2 |>\n\
    <| a tags=tidyverse,string,dplyr,regex,r dscore=1 |>\nHere is a base R solution:\n\
    <code>\nx <- c(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\")\n\
    y <- c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\")\n\npaste(x[upper.case(tolower(x))],\
    \ y[upper.case(tolower(y))]) \n[1] \"a b\" \"b c\" \"c d\" \"d e\" \"e f\" \"\
    f g\" \"g h\" \"h i\" \"i j\"\n</code>\n<|/ a |>\n<| a dscore=1 |>\nWe can use\
    \ transmute to apply the two functions on each element separately:\n<code>\nlibrary(dplyr)\n\
    library(stringr)\n\ndf %>%\n  transmute(across(everything(), ~str_replace(\n \
    \   stringr::str_replace(.x, c(\"A\", \"a\", \"B\", \"b\", \"C\", \"c\", \"D\"\
    , \"d\", \"E\", \"e\", \"F\", \"f\"), c(toupper(\"A\"), toupper(\"a\"), toupper(\"\
    B\"), toupper(\"b\"), toupper(\"C\"), toupper(\"c\"), toupper(\"D\"), toupper(\"\
    d\"), toupper(\"E\"), toupper(\"e\"), toupper(\"F\"), toupper(\"f\"))\n  ))\n\n\
    \  col1\n  <chr>\n1 AaBbCcDdEeFf\n2 AaBbCcDdEeFf\n3 AaBbCcDdEeFf\n4 AaBbCcDdEeFf\n\
    5 AaBbCcDdEeFf\n6 AaBbCcDdEeFf\n7 AaBbCcDdEe", "\n    string %>% \n        str_split(pattern\
    \ = .) %>% \n        map_chr(~.x %>% \n                  str_to_lower() %>% \n\
    \                  str_to_upper())\n}\n</cell>\n<cell>\nflip_case(\"Hello, world\"\
    )\n</cell>\n<text>\nExercise\nWrite a function that removes a single character\
    \ from a given string. Test it on a single character string. Try removing one\
    \ from a longer string like \"The cat in the hat is sleeping.\"\n\n\n</text>\n\
    <cell>", "\n  return(gsub(\"([a-z])([A-Z])\",\"\\\\1\\\\2\",string))\n}\n", "\n\
    \  out <- toupper(string)\n  out <- tolower(out)\n  out\n}\n</code>\n<|/ a |>\n\
    <| c |>\nWhat is the purpose of returning the `return` in the function ?\n<|/\
    \ c |>\n<| c |>\nYou can return anything you want. In some cases you could also\
    \ use `return(out)`, but I thought it made more sense to simply return the output\
    \ rather than the whole function in its entirety.\n<|/ c |>\n<| a tags=r,string\
    \ |>\nAn option with str_replace\n<code>\nlibrary(stringr)\nstr_replace(tolower(x),\
    \ toupper('\\\\<C\\\\>'), '')", "\n  case_change <- function(x) {\n    x <- toupper(x)\n\
    \    x <- tolower(x)\n    x\n  }\n  str_to_lower(gsub(\" \", \"\", string, ignore.case\
    \ = TRUE), case_change)\n}\n", "\n  string <- str_replace_all(string, c(\"\\\\\
    l\",\"u\")) # Lowercase to uppercase\n  string <- str_replace_all(string, c(\"\
    \\\\u\",\"l\")) # Uppercase to lowercase\n  return(string)\n}\n</cell>\n<text>\n\
    Now that we have our function, let's test it out.\n\n\n</text>\n<cell>", "\n \
    \ string <- toupper(string)\n  string <- tolower(string)\n  string\n}\nflip_case(\"\
    Hello World!\")\n</cell>\n<cell>\nflip_case(\"Hello World!\")\n</cell>\n<text>\n\
    Slicing and Indexing\nStrings are arrays of characters. Subsetting by specifying\
    \ numbers returns a vector or list object.\n\nThe $ operator can be used to extract\
    \ the character at the position specified in the index vector. For example, extracting\
    \ the first character from the string 'Hello World!' produces 'H'.\n\nNote that\
    \ indices are 0-based, unlike Python\u2019s standard 1-based indexing.\n\n\n</text>\n\
    <cell>", "\n  return(tolower(string)) %>% toupper() %>% tolower()\n}\n", "\n \
    \ string <- tolower(string)\n  string <- toupper(string)\n  return(string)\n}\n\
    \nflip_case(\"heLLo\")", "\n    paste0(toupper(substring(string, 1, 1)), \n  \
    \         substring(string, 2))\n}\n", "\n  string <- tolower(string)\n  string\
    \ <- toupper(string)\n  return(string)\n}\n", "\n  string <- unlist(strsplit(string,\
    \ \"\"))\n  string[tolower(string)]\n}\nflip_case(\"hello\")\n</cell>\n<text>\n\
    The tolower and toupper functions take a string as an argument, and return the\
    \ string with the lowercase characters converted to uppercase and the uppercase\
    \ characters converted to lowercase:\n\n\n</text>\n<cell>\ntoupper(\"hello\")\n\
    </cell>\n<text>\nExercise\nImplement a function that returns the string with the\
    \ characters in string reversed. For example, \"hello\" becomes \"olleh\". Hint:\
    \ check out rev\n\n\n</text>\n<cell>", "\n  tolower(toupper(string))\n}\n", "\n\
    \  toupper(tolower(string))\n}\nflip_case(\"Hello\")\n</cell>\n<text>\nIn the\
    \ cell below, we are going to define a function which computes the distance between\
    \ two given points.\n\n\n</text>\n<cell>", "\n  gsub(\"[[:lower:]]\", \"[[:upper:]]\"\
    , string)\n  gsub(\"[[:upper:]]\", \"[[:lower:]]\", string)\n}\n</cell>\n<cell>",
  "\n  chars <- strsplit(string, \"\")[[1]]\n  chars <- chars[apply(chars, 2, function(x)\
    \ x == tolower(x))]\n  chars[apply(chars, 2, function(x) x == toupper(x))] <-\
    \ tolower(chars[apply(chars, 2, function(x) x == toupper(x))])\n  paste(chars,\
    \ collapse = \"\")\n}\nflip_case(\"Hello\")\n</cell>\n<cell>", "\n  gsub(toupper,\
    \ toLowerCase, string)\n}\n</cell>\n<cell>\nflip_case(\"Hello, world!\")\n</cell>\n\
    <text>\nExercise 2\nImplement a function that can find the n-th most frequent\
    \ element in a vector.\n\n\n</text>\n<cell>", "\n  strsplit(string, '') %>%\n\
    \    map_chr(function(string) {\n      toupper(string) %>%\n        paste0(tolower(string),\
    \ collapse = \"\")\n    }) %>%\n    paste0(collapse = \"\")\n}\n", "\n  x <- tolower(string)\n\
    \  toupper(x) <- tolower(x)\n  toupper(x)\n}\n\nflip_case(\"HeLlO\")", "\n  sapply(string,\
    \ toupper)\n}\n", "\n  output <- strsplit(string, \"\\\\s+\") %>% \n    map(function(x)\
    \ case_when(\n      x == tolower(x) ~ toupper(x),\n      x == toupper(x) -> tolower(x)\n\
    \    )) %>% \n    paste(collapse = \" \")\n  return(output)\n}\n", "\n    result\
    \ <- str_replace_all(string, c(\"l\", \"L\", \"a\", \"A\") -> \"L\")\n    str_replace_all(result,\
    \ c(\"L\", \"l\", \"A\", \"a\") -> \"a\")\n}\n</cell>\n<text>\nFor this last function,\
    \ we can use the function str_extract_all() to extract the patterns from the string.\
    \ Then, for each pattern, we need to get the index location of the pattern in\
    \ the string. We can do this using the stringr::str_locate() function.\n\n\n</text>\n\
    <cell>", "\n  case_map(string) %>%\n    gsub(tolower(.), toupper(.)) %>%\n   \
    \ tolower() %>%\n    toupper()\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis works\
    \ for me, although I had to flip capital and lowercase. `toupper` before `tolower`\
    \ did the trick for me.\n<|/ c |>\n<| a |>\n<code>\nflip <- function(string) {\n\
    \  # remove non-letters and numbers\n  result <- gsub(sprintf(\"[^A-Za-z0-9]\"\
    , \"\", string), \"\", string)\n  # add missing capital letters from \"a\" to\
    \ \"z\"\n  result <- paste0(LETTERS, result)\n  # remove non-letters and numbers\
    \ again\n  result <- gsub(sprintf(\"[^A-Za-z0-9]\", \"\", string), \"\", result)\n\
    \  # convert it to lower case\n  result <- tolower(result)\n  result\n}\n</code>\n\
    <|/ a tags=string,r dscore=4 |>\n<| c |>\nThanks. My solution was similar to yours\
    \ with some improvements\n<|/ c |>\n<| a |>\n<code>\nflip <- function(string)\
    \ {\n  toupper(substr(string,1,1)) + substr(string, 2, nchar(string))\n}\n</code>\n\
    <|/ a dscore=4 tags=string,r |>\n<| a tags=string,r |>\nUsing regular expressions\
    \ would also work:\n<code>\n> gsub(\"[a-z]\", toupper(\"z\")[tolower(gsub(\"[A-Z]\"\
    , toupper(\"A\"), \"\"))], \n>      tolower(str_c(\"abc\", \"ab\", \"a\")))\n\
    [1] \"zbc\"\n</code>\n<|/ a dscore=3 |>\n<| a |>\nAn alternative solution using\
    \ sapply and regexpr:\n<code>\nflip <- function(string) {\n  result <- gsub(sprintf(\"\
    [^A-Za-z0-9]\", \"\", string), \"\", string)\n  result <- paste0(LETTERS, result)\n\
    \  result <- gsub(sprintf(\"[^A-Za-z0-9]\", \"\", string), \"\", result)\n  result\
    \ <- tolower(result)\n  sapply(result, regexpr, pattern = \"[A-Z]\")\n}\n</code>\n\
    <|/ a dscore=2 tags=string,r |>\n<| a tags=string,r dscore=2 |>\nA slightly different\
    \ approach without using regex:\n<code>\nflip <- function(string) {\n    result\
    \ <- gsub(\"[^A-Za-z0-9]\",\"\",string)\n    result <- gsub(sprintf(\"%s\",seq(97,123)),\"\
    \",result)", "\n  return(toupper(tolower(string)))\n}\n", "\n  return(sub('([a-z])([A-Z])',\
    \ '\\U\\1\\L\\2', string))\n}\n</cell>\n<text>\nNow let's use our function to\
    \ flip all characters in our string that are not a-z or A-Z:\n\n\n</text>\n<cell>\n\
    flip_case(\"Hello\")\n</cell>\n<text>\nAs you can see, this function doesn't change\
    \ the string but returns a new string with all the lowercase characters replaced\
    \ with uppercase characters and vice-versa. For a more in-depth explanation of\
    \ regular expressions, check out this resource: . You can also test out this regex\
    \ online.\n\n\n</text>\n<text>\nExercise:\nWrite a function that takes a string\
    \ and returns it with the first letter of each word capitalized. This means that\
    \ if a string has the word \"The\" in it, the function should return \"The Rock\"\
    .\n\n\n</text>\n<cell>", "\n  ustring <- toupper(tolower(string))\n  return(ustring)\n\
    }\n", "\n  gsub(\" \", \"\", string)\n}\n", "\n  gsub(\"[a-z]\",\n        function(string)\
    \ {\n          toupper(substr(string, 1, 1))\n        }, string)\n}\n", "\n  str\
    \ <- tolower(string)\n  str[str == toupper(str)]  <- tolower(str)[str == toupper(str)]\n\
    \  str\n}\n", "\n  chartr(c('a', 'b'), c('A', 'B'), string)\n}\n", "\n  gsub(\"\
    (.)([a-z])\", toupper(\"\\\\1\\\\2\"), string, perl=TRUE)\n}\n\nflip_case(\"hello\"\
    )\nflip_case(\"HellO\")\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,string,replace\
    \ dscore=2 |>\nTo expand on what was said, here is a solution that uses gsub,\
    \ without regular expressions, and is vectorised in the sense that it can operate\
    \ on any number of vectors, not just one:\n<code>\nmy_string <- 'hello world'\n",
  "\n  return(tolower(string) %>% toupper())\n}\n", "\n  out <- strsplit(string, '')[[1]]\n\
    \  out <- toupper(out)\n  out <- tolower(out)\n  out <- paste0(out, '')\n  return(out)\n\
    }\n", "\n  toupper(tolower(string))\n}\n\nflip_case(\"hello world\")\n</cell>\n\
    <text>\nWe can make this function more useful using map2() from purrr:\n\n\n</text>\n\
    <cell>\nlibrary(purrr)\n\nflip_case <- function(string) {\n  string %>%\n    map2(toupper,\
    \ tolower) %>%\n    paste0\n}\n\nflip_case(\"hello world\")\n</cell>\n<text>\n\
    Here is a version of flip_case that flips multiple characters at once:\n\n\n</text>\n\
    <cell>\nflip_multiple_cases <- function(string) {\n  string %>%\n    map2(toupper,\
    \ tolower, ~paste0(.x, .y)) %>%\n    paste0\n}\n\nflip_multiple_cases(\"hello\
    \ world\")\n</cell>\n<text>\nWe can also use anonymous functions in our map2 call:\n\
    \n\n</text>\n<cell>\nflip_multiple_cases <- function(string) {\n  string %>%\n\
    \    map2(toupper, tolower, ~paste0(.x, .y)) %>%\n    paste0\n}\n\nflip_multiple_cases(\"\
    hello world\") %>% print\n</cell>\n<text>\nThe map2 function in R takes three\
    \ arguments:\n\nA function that takes two arguments: the first is what we are\
    \ mapping over and the second is the element we are mapping over\nA function that\
    \ takes one argument: the element we are mapping over\nA function that takes two\
    \ arguments: the first is what we are mapping over and the second is the element\
    \ we are mapping over\n\nWe can use anonymous functions in our map2 call like\
    \ so:\n\n\n</text>\n<cell>\nflip_multiple_cases <- function(string) {\n  string\
    \ %>%\n    map2(toupper, tolower, ~paste0(.x, .y)) %>%\n    paste0\n}\n\nflip_multiple_cases(\"\
    hello world\") %>% print\n</cell>\n<text>\nIf we call map2() with a function that\
    \ takes two arguments, we are telling it to apply the two functions to each element\
    \ of two vectors. We could use map2() like this if we wanted to apply the toupper\
    \ and tolower functions to the entire vector of characters:\n\n\n</text>\n<cell>\n\
    flip_multiple_cases <- function(string) {\n  string %>%\n    map2(toupper, tolower)\
    \ %>%\n    paste0\n}\n\nflip_multiple_cases(\"hello world\") %>% print\n</cell>\n\
    <text>\nIf we had passed a list to map2(), it would have applied toupper and tolower\
    \ to the individual elements of the list. We could also pass in a character vector\
    \ to map2() like this:\n\n\n</text>\n<cell", "\n  string <- tolower(string)\n\
    \  string <- toupper(paste(string, collapse = \"\"))\n  return(string)\n}\n",
  "\n  gsub(tolower(string), toupper(string), string)\n}\n</cell>\n<cell>", "\n  string\
    \ %>% tolower() %>% toupper() %>% str_squish()\n}\n", "\n    case_change <- function(x)\
    \ {\n        case_changes <- switch(x, \n            lower = toupper(x), \n  \
    \          upper = tolower(x))\n        case_changes[[1]]\n    }\n    \n    stringr::str_to_lower(string)\n\
    \         %>%\n        str_split(pattern = \" \")\n         %>% \n        sapply(case_change)\n\
    \         %>%\n        paste(collapse = \" \")\n}\n", "\n    string %>% \n   \
    \     case_when(\n            tolower(string) == string ~ toupper(string),\n \
    \           toupper(string) == string ~ tolower(string)\n        )\n}\n</cell>\n\
    <cell>", "\n  n <- nchar(string)\n  \n  for(i in 1:n) {\n    string[i] <- toupper(substr(string,\
    \ i, i))\n  }\n  \n  for(i in 1:n) {\n    string[i] <- tolower(substr(string,\
    \ i, i))\n  }\n  \n  string\n}\n", "\n  uc <- toupper(string)\n  lc <- tolower(string)\n\
    \  paste0(uc, lc)\n}\nflip_case('hello')\n</cell>\n<text>\nGreat, now we can use\
    \ the function above to flip all the cases of a given string!\n\nBut what if you\
    \ wanted to flip just some cases? For example, if you want to flip all lowercase\
    \ to uppercase and lowercase to uppercase, but leave numbers alone, what should\
    \ you do?\n\nTo answer this question, let's try a combination of functions from\
    \ the other chapter on applying functions and slicing lists, to create a new function\
    \ that flips some or all of the cases of a given string, as follows:\n\nCreate\
    \ a function called flip_cases that flips some or all of the cases of a given\
    \ string.\nIn the function flip_cases, use a combination of lapply, toupper, and\
    \ tolower to flip lowercase characters to uppercase and uppercase to lowercase.\n\
    In the function flip_cases, use a combination of mapply, toupper, and tolower\
    \ to flip uppercase characters to lowercase and lowercase to uppercase.\nReturn\
    \ the result of applying the function flip_cases to the given string.\n\n\n</text>\n\
    <cell>\nflip_cases <- function(string) {\n  fl <- list(toupper, tolower)\n  uc\
    \ <- lapply(fl, function(x) toupper(string))\n  lc <- lapply(fl, function(x) tolower(string))\n\
    \  unlist(mapply(function(x, y) paste0(x, y), uc, lc))\n}\n\nflip_cases('hello')\n\
    </cell>\n<text>\nGreat! Now, let's use our new function flip_cases to reverse\
    \ the case of each word of a given string:\n\nCreate a function called reverse_cases\
    \ that takes in a string and reverses case of each word.\nIn the function reverse_cases,\
    \ use a combination of lapply, flip_cases, and toupper to reverse the case of\
    \ each word.\nIn the function reverse_cases, use a combination of mapply, flip_cases,\
    \ and tolower to reverse the case of each word.\nReturn the result of applying\
    \ the function reverse_cases to the given string.\n\n\n</text>\n<cell>\nreverse_cases\
    \ <- function(string) {\n  fl <- list(toupper, flip_cases)\n  uc <- lapply(fl,\
    \ function(x) flip_cases(x))\n  lc <- lapply(fl, function(x) flip_cases(x))\n\
    \  unlist(mapply(function(x, y) paste0(x, y), uc, lc))\n}\n\nreverse_cases('HELLO')\n\
    </cell>\n<text>\nIt works! But there's a problem... the function flip_cases doesn't\
    \ return the results as a string but rather returns a list. We can address this\
    \ issue by calling un", "\n  gsub(\"(^[a-z])(.*)\", \"\\\\U\\\\2\\\\L\\\\1\",\
    \ string)\n}\n</code>\nSome other notes on this function:\n\nThis regex is case-insensitive.\
    \  If you want upper- and lower-case versions to match, you'll have to add additional\
    \ flags to the regex (e.g. RegexCaseInsensitive for case-sensitivity).\nI used\
    \ the perl=TRUE flag to improve efficiency.  If you don't include this flag, then\
    \ a lookbehind is created which can slow things down.\n<|/ a dscore=2 |>\n<| c\
    \ |>\nFor those of you who are unclear about `perl=TRUE` (or are unsure how to\
    \ install it) there is a great [guide](http://stackoverflow.com/questions/5890584/how-to-use-perl-regex-engine-in-python)\
    \ to installing it on Windows.  This should help you avoid the need for another\
    \ question, but will still require the installer if you don't already have it.\n\
    <|/ c |>\n<| c |>\nJust to be sure, I will rewrite my answer. :)\n<|/ c |>\n<|\
    \ c |>\nThanks for the answer, but I am having problems implementing this. Do\
    \ I paste this into the R script and run it from the command line or do I replace\
    \ something with the 'perl=TRUE'?\n<|/ c |>\n<| c |>\nI put `perl=TRUE` into the\
    \ `gsub()` function and ran the script from the command line.  I edited my post\
    \ to show my changes to the `flip_case` function.\n<|/ c |>\n<| c |>\nThank you\
    \ for your answer. I pasted the script into R and ran it by typing 'source(\"\
    flip_case.R\")' into the command line and I am getting the following error message:\n\
    'Warning message:\nIn source(\"flip_case.R\") :\n  Error in sourceUTF8(file) :\
    \ unused argument (file = 'flip_case.R')'\n<|/ c |>\n<| a tags=r,regex |>\nThis\
    \ is not exactly a regex solution, but you can use the library stringi for text\
    \ manipulation from R.\n<code>\n> library(stringi)\n> x <- \"HELLO WORLD\"\n>\
    \ stri_trans_totitle(x)\n[1] \"Hello World\"\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThanks for your answer. This could be a solution but I would like to avoid\
    \ installing additional packages if possible. I am very new to R so I am not sure\
    \ how to install these packages. Would this package also be installed when I install\
    \ R or do I have to download and install it separately?\n<|/ c ", "\n  string\
    \ <- gsub(\"([a-z])([A-Z])\", \"\\\\1_\\\\2\", string)\n  string <- gsub(\"([A-Z])([A-Z][a-z])\"\
    , \"\\\\1_\\\\2\", string)\n  string <- tolower(string)\n  return(string)\n}\n\
    </cell>\n<text>\nAnd now we test our function:\n\n\n</text>\n<cell>\nflip_case(\"\
    hello\")\n</cell>\n<cell>\nflip_case(\"Hello\")\n</cell>\n<text>\nNow let's write\
    \ a function using lapply, which loops through every character in a string, and\
    \ returns the length of the string in each iteration. We can use lapply to loop\
    \ through every character in a string:\n\n\n</text>\n<cell>", "\n    string <-\
    \ gsub(\" \", \"\", string)\n    string <- toupper(string)\n    string <- tolower(string)\n\
    \    return(string)\n}\n", "\n  sapply(1:nchar(string), function(x) {\n    upper(substring(string,\
    \ x, x + 1)) +\n    substring(string, 1, x) +\n    lower(substring(string, x +\
    \ 1, nchar(string)))\n  })\n}\nflip_case(\"Hello\")", "\n  gsub(\"([a-z])([A-Z])\"\
    , \"\\\\U\\\\1\\\\L\\\\2\", string)\n}\n</cell>\n<text>\nAs a first example, let's\
    \ try flipping all the lowercase characters to uppercase and vice-versa.\n\n\n\
    </text>\n<cell>\nflip_case('hello')\n</cell>\n<text>\nThe function should return\
    \ an error in case a string with more than one lowercase character appears more\
    \ than once in the original string.\n\n</text>\n<cell>", "\n  string <- gsub(\"\
    ([a-z])([A-Z])\", \"\\U\\1\\L\\2\", string)\n  string <- gsub(\"([A-Z])([a-z])\"\
    , \"\\L\\1\\U\\2\", string)\n  return(string)\n}\n", "\n  gsub(\"(.)\", upper,\
    \ gsub(\"([a-z])\", upper, string))\n}\n\nflip_case(\"The quick brown fox jumps\
    \ over the lazy dog.\")", "\n  string <- gsub(\"([a-z])([A-Z])\", \"\\U\\1\\L\\\
    2\", string, perl = TRUE)\n  string <- gsub(\"([A-Z])([A-Z])\", \"\\L\\1\\U\\\
    2\", string, perl = TRUE)\n  return(string)\n}\n", "\n    string %>% gsub(\"[a-z]\"\
    , \"[A-Z]\", ., ignore.case = TRUE) %>% \n               gsub(\"[A-Z]\", \"[a-z]\"\
    , ., ignore.case = TRUE) %>%\n               toUpperCase()\n}\nflip_case(\"Hello\
    \ World\")\n</cell>\n<cell>", "\n  string <- str_to_lower(string)\n  str_tolower(string)\n\
    }\n", "\n  string %>% gsub(\"([a-z])\", \"\\\\U\\\\1\", .) %>% gsub(\"([A-Z])\"\
    , \"\\\\U\\\\2\", .)\n}\n", "\n  string <- tolower(string)\n  string <- gsub(\"\
    A\", \"B\", string)\n  string <- gsub(\"b\", \"B\", string)\n  string <- gsub(\"\
    b\", \"a\", string)\n  string\n}\n", "\n    string <- gsub(\"(.)([A-Z])\", \"\\\
    \\2\\\\1\", string)\n    string <- gsub(\"([a-z])([A-Z])\", \"\\\\1\\\\3\", string)\n\
    \    return(tolower(string))\n}\n", "\n  for(i in 1:(length(string)-1)) {\n  \
    \  if(tolower(substr(string, i, i+1)) != tolower(substr(string, i, i+1))) {\n\
    \      string <- paste0(substr(string, i, i+1), substr(string, i+1, i+2))\n  \
    \  }\n  }\n  return(string)\n}\n\nflip_case('Hello')\n</cell>\n<text>\nRegex\n\
    Regular expression is a powerful way of matching strings in many different ways.\
    \ In R we can use regex to match any string that begins with a particular string.\n\
    \n\n</text>\n<cell>", "\n  str <- toupper(string)\n  gsub(tolower(string), toupper(string),\
    \ str)\n}\n\nflip_case(\"hello\")\nflip_case(\"Hello World\")\nflip_case(\"HelloWorld\"\
    )\nflip_case(\"HelloWorld\")\n", "\n  # Convert to lower case\n  string <- tolower(string)\n\
    \  # Convert to upper case\n  string <- toupper(string)\n  # Return the result\n\
    \  return(string)\n}\n</cell>\n<text>\nApply our function to each element in the\
    \ vector. The output is a character vector.\n\n\n</text>\n<cell>\nflip_case(test[[1]])\n\
    </cell>\n<cell>\nflip_case(test[[2]])\n</cell>\n<text>\nFor this exercise, write\
    \ your own version of apply. Do this by converting the string to a vector, then\
    \ use your function on each element of the vector.\n\nYour function will look\
    \ like:\n  function(string) {\n    # Convert to lower case\n    string <- tolower(string)\n\
    \    # Convert to upper case\n    string <- toupper(string)\n    return(string)\n\
    \  }\n\n</text>\n<cell>\ntest <- c('hello', 'hi')\n", "\n  string <- tolower(string)\n\
    \  string <- toupper(string)\n  return(string)\n}\n</code>\nLet's take a look\
    \ at the solution:\n<code>\nflip_case(\"Hello\")", "\n    string %>%\n       \
    \ str_c %>%\n        map_chr(~ifelse(. %in% c('a','e','i','o','u'),\n        \
    \                toupper(.),\n                        tolower(.)))\n}\n\nflip_case('hello')",
  "\n  # Convert each character in the string to upper case\n  upper_string <- str_replace_all(string,\
    \ pattern = \"[^[:lower:]]\", replacement = \"\")\n  upper_string <- paste(upper_string,\
    \ collapse = \"\")\n  upper_string <- toupper(upper_string)\n  # Convert each\
    \ character in the string to lower case\n  lower_string <- str_replace_all(upper_string,\
    \ pattern = \"[[:lower:]]\", replacement = \"\")\n  lower_string <- paste(lower_string,\
    \ collapse = \"\")\n  lower_string <- tolower(lower_string)\n  # Concatenate the\
    \ string\n  string <- paste0(lower_string, upper_string)\n  return(string)\n}\n",
  "\n    string %>%\n    str_tolower() %>%\n    str_to_upper() %>%\n    str_to_lower()\n\
    }\n", "\n    string <- gsub(\"[a-z]\", \"[A-Z]\", string)\n    string <- gsub(\"\
    [A-Z]\", \"[a-z]\", string)\n    string\n}\n", "\n  string %>% tolower() %>% toupper()\n\
    }\n\nflip_case('Hello')\n</cell>\n<text>\nTo remove any space characters, use\
    \ strip function in base R.\n\n\n</text>\n<cell>", "\n  string <- toupper(tolower(string))\n\
    \  return(string)\n}\n", "\n  unlist(strsplit(string, \"(?i)\", perl=T))\n}\n\
    flip_case(\"Hello\")\n</cell>\n<cell>", "\n  str_split(string, \"([a-z])\") %>%\
    \ \n    map(function(x) paste0(x[1], toupper(x[2]), x[3]))\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a dscore=1 |>\nUsing tidyverse and stringr, this could be an\
    \ approach -\n<code>\nlibrary(tidyverse)\nlibrary(stringr)\n\ndf %>%\n  mutate(new_name\
    \ = map_chr(str_split(name, pattern = '[[:upper:]]+'), \n                    \
    \      ~ str_c(str_extract(., '^[A-Z].*'), str_replace(str_extract(., '[A-Z]'),\
    \ '.', '')))\n", "\n  string <- toupper(string)\n  paste(tolower(gsub(\"[a-z]\"\
    , \"[A-Z]\", string)),\n        gsub(\"[A-Z]\", \"[a-z]\", string), sep=\"\",\
    \ collapse=\"\")\n}\n</code>\nNow the string \"Hello\" becomes \"hELLO\" which\
    \ is what the final output looks like.\n<|/ a tags=r,regex,string dscore=1 |>\n\
    <| a tags=r,regex,string |>\nAnother approach is to use stringi package:\n<code>\n\
    stri_replace_all_regex(toupper(substr(string, 1, 1)),\n                      \
    \ \"([A-Z])\", \"\\\\1\\\\l\")\n</code>\nThe idea is to use \\l (lowercase letters)\
    \ in the replacement string.\nExample\n<code>\nstri_replace_all_regex(\"ABCD\"\
    , \"([A-Z])\", \"\\\\1\\\\l\")", "\n  string <- tolower(string)\n  string <- toupper(string)\n\
    \  return(string)\n}\n\n</cell>\n<text>\nVectorisation\nVectorisation is a programming\
    \ technique that can greatly improve the performance of code. Vectorisation allows\
    \ us to perform operations on entire objects at once instead of one element at\
    \ a time.\n\nFor example, if we were to repeatedly multiply a vector by a scalar\
    \ we could write this in a single line of code:\n\n\n</text>\n<cell>\nx1 <- c(1,2,3)\n\
    x2 <- c(4,5,6)\n\nx1 <- x1 * 2\nx2 <- x2 * 2\nx3 <- x1 * x2\n\nprint(x3)\n</cell>\n\
    <text>\nNotice how we did not have to perform the operations one at a time. Vectorisation\
    \ also allows us to perform an operation on multiple vectors at once which we\
    \ will learn more about in the next chapter.\n\nTo vectorise a function we simply\
    \ create a vector of the inputs to the function and perform the operation on the\
    \ entire vector:\n\n\n</text>\n<cell>\nvectorised_function <- function(vector_1,\
    \ vector_2, vector_3){\n  vector_1 * vector_2 * vector_3\n}\n\nvectorised_function(x1,x2,x3)\n\
    </cell>\n<text>\nFor small functions this can sometimes be more efficient than\
    \ using a for loop. Vectorisation can also be useful if you are performing a number\
    \ of similar operations, as demonstrated here:\n\n\n</text>\n<cell>\nvectorised_function\
    \ <- function(vector_1, vector_2, vector_3){\n  vector_1 + vector_2 + vector_3\n\
    }\n\nvectorised_function(x1,x2,x3)\n</cell>\n<text>\nThis can be more efficient\
    \ than using a for loop since we avoid the overhead of the for loop and instead\
    \ perform the entire calculation once.\n\nHowever, sometimes vectorisation can\
    \ lead to inefficiencies or inelegance when used carelessly. As we will see, it\
    \ is useful to understand the problems with the inelegance and inefficiency of\
    \ vectorisation before deciding whether or not to use it.\n\nWhen we encountered\
    \ this issue earlier in the book we saw that vectorisation can lead to inefficient\
    \ code. Here, for example, we are repeatedly creating a new vector x1 every time\
    \ the function is called. What happens when we call a function repeatedly?\n\n\
    We will learn more about this in the next chapter, but to understand how it relates\
    \ to performance we will first introduce a concept, the call stack. Let's start\
    \ by considering what happens when a function is called recursively.\n\n\n</text>\n\
    <cell>\nflip_case <- ", "\n    string <- str_to_lower(string)\n    string <- str_to_upper(string)\n\
    \    return(string(string))\n}\n", "\n  result <- tolower(string)\n  result <-\
    \ toupper(result)\n  return(result)\n}\n", "\n  gsub(\"(.)([A-Z])\", \"\\\\1_\\\
    \\2\", gsub(\"([a-z])([A-Z])\", \"\\\\1_\\\\2\", string))\n}\n</cell>\n<code language=conda-env-R_env-py>",
  "\n  gsub(\"([a-z])([A-Z])\", \"\\U\\1\\L\\2\", tolower(string), perl = TRUE)\n\
    }\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nHere is a simpler regex solution:\n\
    <code>\nlibrary(stringr)\n\nflip_case <- function(x) {\n  str_replace_all(x, \"\
    ([A-Z])([A-Z])\", \"\\\\U\\\\1\\\\L\\\\2\")\n}\n\nflip_case(\"HELLO WORLD\")",
  "\n  string <- gsub(\"[a-z]\", toupper, string)\n  string <- gsub(\"[A-Z]\", tolower,\
    \ string)\n  return(string)\n}\n", "\n    string <- gsub(\"[a-z]\", \"[A-Z]\"\
    , string)\n    string <- gsub(\"[A-Z]\", \"[a-z]\", string)\n    return(string)\n\
    }\n", "\n  string <- tolower(string)\n  return(toupper(sub(\"[a-z]\", \"[A-Z]\"\
    , string)))\n}\n</code>\n<|/ a tags=r,stringr,regex |>\n<| c |>\nYou might want\
    \ to mention the `stringr` package since your function uses `stringr::str_replace()`.\n\
    <|/ c |>\n<| a tags=r,stringr,regex dscore=5 |>\nAs of R-Studio 0.97.136, the\
    \ function str_replace_all in package stringr has been replaced by str_match_all\
    \ in package stringi. \n<code>\nlibrary(stringr)\n> a <- c(\"Hello World\", \"\
    Goodbye World\")\n> str_replace_all(a, \"World\", \"Bob\")\n[1] \"Hello Bob\"\
    \ \"Goodbye Bob\"\n</code>\n<|/ a |>\n<| a dscore=5 |>\nThe easiest way is to\
    \ use gsub.  For a specific string replace pattern like \"World\" with another\
    \ string like \"Bob\", you can use:\n<code>\ngsub(\"World\", \"Bob\", a)\n[1]\
    \ \"Hello Bob\" \"Goodbye Bob\"\n</code>\nFor a general pattern replace, use gsubfn\
    \ from the gsubfn package:\n<code>\nlibrary(gsubfn)\ngsubfn(\"(World)\", list(\"\
    World\" = \"Bob\"), a)\n</code>\n<|/ a tags=r,stringr,regex |>\n<| a |>\nAnother\
    \ package that provides several additional functions, like stringi::stri_replace_all\
    \ for replacing multiple strings, is stringr:\n<code>\nlibrary(stringr)\n\na <-\
    \ c(\"Hello World\", \"Goodbye World\")\nstr_replace_all(a, \"World\", \"Bob\"\
    )\n</code>\n<|/ a tags=r,stringr,regex dscore=5 |>\n<| a dscore=4 |>\nIf you need\
    \ to replace every occurrence of a substring in a string with another string,\
    \ you can use gsub. \n<code>\ngsub(pattern, substring, x, perl = T)\n</code>\n\
    <|/ a tags=r,stringr,regex |>\n<| a dscore=4 |>\nThe stringr package is another\
    \ option that doesn't depend on external libraries\n<code>\nlibrary(stringr)\n\
    a <- c(\"Hello World\", \"Goodbye World\")\nstr_match(a, \"World\")\n</code>\n\
    <|/ a tags=r,stringr,regex |>\n<| c |>\nI think this is the best answer in my\
    \ opinion. Plus, it works for multiple matches: `str_match(a, \"World|Hi\")` will\
    \ find `World` anywhere in the string", "\n  uc <- toupper\n  lc <- tolower\n\
    \  gsub(\"(.)\", toupper, gsub(\"(.)\", lc, string))\n}\n", "\n  ustr <- toupper(string)\n\
    \  lstr <- tolower(string)\n  paste0(ustr, lstr)\n}\n</cell>\n<text>\nNow, let's\
    \ put our functions into a package, and import the package for use in a notebook.\n\
    \n\n</text>\n<cell>\nlibrary(devtools)\nlibrary(ggplot2)\n\nsource(\"functions.R\"\
    )\n</cell>\n<text>\nNow we'll have a package with a bunch of useful functions.\n\
    \nLet's test out the package.\n\nFirst, we'll use the function we defined above,\
    \ flip_case.\n\n\n</text>\n<cell>\nflip_case(\"Hello\")\n</cell>\n<text>\nNow,\
    \ let's use it to flip all entries in a vector, using each entry in the vector.\
    \  We'll store the result in a new vector.\n\n\n</text>\n<cell>\nflip <- flip_case(c('Hello','world'))\n\
    </cell>\n<text>\nAnd let's see if it's correct.\n\n\n</text>\n<cell>\nflip\n</cell>\n\
    <text>\nNext, let's see what happens if we use it to flip all the entries in each\
    \ of our data frames.  We'll store the results back into our data frames.\n\n\n\
    </text>\n<cell>\nflip_data <- flip_case(df)\n</cell>\n<text>\nNow, we can check\
    \ to see if the data frames are correct.\n\n\n</text>\n<cell>\nflip_data\n</cell>\n\
    <text>\nWe can also do more complicated things.\n\nFor example, let's see what\
    \ happens when we flip a number between 0 and 1, and store it in another data\
    \ frame.\n\n\n</text>\n<cell>\nflip_num <- flip_case(runif(100))\n</cell>\n<cell>",
  "\n    chartr(toupper, tolower, string)\n}\n", "\n  string <- tolower(string)\n\
    \  string <- toupper(string)\n  return(string)\n}\n", "\n  stringr::str_replace_all(string,\
    \ \"(.)\", \"\\\\U\\\\1\")\n}\n", "\n  string %>% \n    str_to_upper() %>% \n\
    \    str_to_lower() %>% \n    paste0(toupper(string), tolower(string))\n}\n\n\
    flip_case('hello')\n</code>\nAnd as far as returning the values as strings, rather\
    \ than objects, you just need to add another paste0 call:\n<code>\n> flip_case(\"\
    hello\")\n[1] \"hELLO\"\n</code>\n<|/ a |>\n<| a |>\nFor anyone who's using dplyr\
    \ and stringr, you can just do:\n<code>\nlibrary(dplyr)\nlibrary(stringr)\ndf\
    \ <- data.frame(a=c(1:10), b=c(letters[1:10])) # df with two columns\ndf %>% mutate(a=str_to_lower(a),\
    \ b=str_to_lower(b))\n</code>\n<|/ a dscore=4 tags=lowercase,string,r |>\n<| c\
    \ |>\nIf you use dplyr instead of data.table this also works: `df %>% mutate_each(funs(str_to_lower))`.\n\
    <|/ c |>\n<| a tags=lowercase,string,r |>\nI like using gsub from the base package,\
    \ which is very flexible.\n<code>\nx <- c(\"Hello world\")\ngsub(\"([a-z])\",\
    \ toupper(\"\\\\1\"), x)\n[1] \"Hello World\"\n</code>\n<|/ a dscore=4 |>\n<|\
    \ a |>\nFor anyone using data.table you can do the following. Note that I used\
    \ a capital T in the column name in the dttable object in the first line of code\
    \ below.\n<code>\ndttable <- data.table(Col1=c(\"Hello\",\"Goodbye\"))\n</code>\n\
    The function below will convert all values in Col1 to lowercase.\n<code>\ndttable\
    \ <- dttable %>%\n  mutate(Col1 = tolower(Col1))\n</code>\n<|/ a dscore=4 tags=lowercase,string,r\
    \ |>\n<| a tags=lowercase,string,r |>\nThe answer above worked for me. Thanks\
    \ Kathleen. Here is my complete code. Here is a data frame of 3 variables and\
    \ a vector with 3 elements. \n<code>\ndata <- data.frame(ID = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n                 Date = c(\"1/12/2016\", \"1/12/2017\", \"1/12/2018\"\
    , \"1/12/2019\"),\n                 Time = c(\"12:12:12\", \"12:12:13\", \"12:12:14\"\
    , \"12:12:15\"))\nvec <- c(\"a\", \"b\", \"c\")\n</code>\nI wanted to change all\
    \ of the strings in column Date and Time to lowercase and to remove any leading\
    \ 0s. For this I wrote ", "\n  string <- gsub(toupper(string), tolower(string),\
    \ string)\n  return(toupper(string))\n}\n</cell>\n<cell>", "\n  string <- gsub(\"\
    ([a-z])([A-Z])\", \"\\\\1\\\\U\\\\2\", string)\n  string <- gsub(\"([A-Z])([A-Z])\"\
    , \"\\\\1\\\\2\", string)\n  string <- gsub(\"([A-Z])\", \"\\\\U\", string)\n\
    \  return(string)\n}\n</cell>\n<code language=conda-env-R4-py>\nflip_case('Hello')\n\
    </cell>\n<code language=conda-env-R4-py>", "\n  return(toupper(substring(string,\
    \ 1, 1)) %>% paste0(tolower(substring(string, 2, nchar(string)))))\n}\n</cell>\n\
    <cell>\nflip_case(\"hELLO\")\n</cell>\n<text>\nWe can also use the following regular\
    \ expression to find capitalized words.\n\n\n</text>\n<cell>\ngrep(\"^[A-Z]{2,}\"\
    , text, value = TRUE)\n</cell>\n<text>\nExercise\nCan you use the function flip_case()\
    \ to identify all capitalized words in a string?\n\n\n</text>\n<cell>\n\n</cell>\n\
    <text>\nWe can also use regular expressions to identify words that are not capitalized.\
    \ In this case, we can use negative lookahead to find words that have a different\
    \ case than the one we're looking for.\n\n\n</text>\n<cell>\ngrep(\"^(?![A-Z]{2,})\"\
    , text, value = TRUE)\n</cell>\n<text>\nWe can also identify words that are not\
    \ in our vocabulary. This can be useful in case we want to remove words that appear\
    \ too commonly.\n\n\n</text>\n<cell>\ngrep(\"(?<![a-z])(?=[A-Z])\", text, value\
    \ = TRUE)\n</cell>\n<text>\nWe can also identify words that match both upper and\
    \ lower case patterns.\n\n\n</text>\n<cell>\ngrep(\"(?=.*[A-Z])(?=.*[a-z])\",\
    \ text, value = TRUE)\n</cell>\n<text>\nAnd we can also find words containing\
    \ numbers or special characters using regular expressions.\n\n\n</text>\n<cell>\n\
    grep(\"^[A-Za-z0-9]*$\", text, value = TRUE)\n</cell>\n<text>\nCombining Regular\
    \ Expressions\nThere are several ways to combine regular expressions. In this\
    \ exercise we want to identify all words that only contain characters in our vocabulary\
    \ and that we do not want to remove.\n\n\n</text>\n<cell>", "\n    str_split(tolower(string),\
    \ \"\")[[1]] %>% \n        paste(collapse = \"\") %>% \n        toupper() %>%\
    \ \n        paste(collapse = \"\")\n}\nflip_case(c(\"hello\", \"world\"))\n</cell>\n\
    <cell>\nflip_case(\"Hello World\")\n</cell>\n<text>\nLet's apply this function\
    \ to the entire column in the dataset. We'll use a purrr package to iterate over\
    \ each row of the data frame with map2_dfc().\n\n\n</text>\n<cell>\nlibrary(purrr)\n",
  "\n  out <- string\n  for(i in 1:nchar(out)) {\n    if (tolower(out[[i]]) == out[[i]])\
    \ {\n      out[[i]] <- toupper(out[[i]])\n    } else if (toupper(out[[i]]) ==\
    \ out[[i]]) {\n      out[[i]] <- tolower(out[[i]])\n    }\n  }\n  out\n}\n</code>\n\
    And then, to test our function:\n<code>\nflip_case(\"hello\")\n[1] \"hello\"\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for this, but this doesn't actually work. Try\
    \ `flip_case(\"Hello\")`\n<|/ c |>\n<| c |>\nOh, yeah, I see what you've done\
    \ now. I was assuming that if the first letter in the string is `lowercase` and\
    \ it appears in the second position, it will be flipped. But I see now that the\
    \ first letter is always flipped, so I'll edit my answer.\n<|/ c |>\n<| c |>\n\
    Ok, I've updated my answer to include a function that works.\n<|/ c |>\n<| a dscore=0\
    \ tags=r,string,regex |>\nThis works:\n<code>\ngsub(\"(?i)[a-z]\", \"[\\\\U\\\\\
    1\\\\W]\", x)\n</code>\n<|/ a |>\n<| c |>\nThis doesn't actually work.  Try `gsub(\"\
    (?i)[a-z]\", \"[\\\\U\\\\1\\\\W]\", \"Hello\")`\n<|/ c |>\n<| c |>\nOh, you were\
    \ right. I don't know what I was thinking when I wrote this... I've fixed my solution.\n\
    <|/ c |>\n<| a dscore=0 |>\nA shorter regex to handle that case:\n<code>\nx <-\
    \ \"Hello World!\"\ngsub(\"([A-Z])\", paste(\"\\\\U\\\\1\", x, sep=\"\"), x)",
  "\n  gsub('(.)([a-z])', '\\\\U\\\\2\\\\L\\\\1', string)\n}\n\nflip_case(\"hello\"\
    )\n</cell>\n<cell>", "\n  # Convert the string to lower case characters.\n  string\
    \ <- tolower(string)\n  # Convert the string to upper case characters.\n  string\
    \ <- toupper(string)\n  # Return string.\n  string\n}\n", "\n    string %>% \n\
    \        str_to_lower() %>% \n        str_to_upper() %>% \n        str_to_lower()\n\
    }\n</code>\n<|/ a |>\n<| c |>\nNice. I'll have to remember this one for future.\n\
    <|/ c |>\n<| c |>\nThanks! And sorry for my late reply.\n<|/ c |>\n<| c |>\nNo\
    \ problem. I was able to learn some of these things as I was doing this kind of\
    \ thing in SAS!\n<|/ c |>\n<| a dscore=3 tags=r,stringr |>\nHere is a base R solution\
    \ that should be faster than the stringr solutions.\n<code>\nx <- c('ABCDE', 'ABCDf',\
    \ 'abcDe', 'ABCdE')\n\n> sapply(x, function(i) sapply(i, function(j) toupper(tolower(j))))\n\
    \       ABCDE         ABCDf       abcDe         ABCdE\nABCDE ABCDE ABCDE ABCDE\
    \ ABCDE ABCDE ABCDE ABCDE ABCDE\nABCDf ABCDf ABCDf ABCDf ABCDf ABCDf ABCDf ABCDf\
    \ ABCDf\nabcDe abcDe abcDe abcDe abcDe abcDe abcDe abcDe abcDe\nABCdE ABCdE ABCdE\
    \ ABCdE ABCdE ABCdE ABCdE ABCdE ABCdE\n</code>\n<|/ a |>\n<| a |>\n<code>\nx <-\
    \ c(\"ABCDE\", \"ABCDf\", \"abcDe\", \"ABCdE\")\n\nlibrary(stringi)\nstri_replace_all_regex(x,\
    \ \"([a-z])\", str_to_upper)\n</code>\n<|/ a tags=r,stringr dscore=3 |>\n<| c\
    \ |>\nI always forget that base R has a function for this in its own `stringi`\
    \ package.  `stringi` also has some more string-specific functions like `stri_replace_all_regex`\
    \ as opposed to `gsub` which only works on strings.\n<|/ c |>\n<| a tags=r,stringr\
    \ |>\nHere is a data.table version using lapply:\n<code>\nx <- c(\"ABCDE\", \"\
    ABCDf\", \"abcDe\", \"ABCdE\")\n\nlibrary(data.table)\nlibrary(stringr)\n\nx <-\
    \ as.data.table(x)\n\nsetDT(x)\nx[x[, lapply(.SD,str_to_upper), by=.(rownames(x))]]\n\
    </code>\nThe output:\n<code>", "\n  string <- tolower(string)\n  string <- toupper(string)\n\
    \  return(string)\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for the tips\
    \ on string manipulation with R. I am new to programming and your examples help\
    \ a lot.\n<|/ c |>\n<| c |>\nGlad it helped!\n<|/ c |>\n<| a dscore=0 |>\nYou\
    \ can use str_replace for that.\n<code>\nstr_replace(\"Hello\", \"h\", \"H\")\n\
    </code>\nThis replaces the string h in the string Hello with H.\nYou can also\
    \ use a function with lapply.\n<code>\nlapply(c(\"Hello\",\"h\"), function(x)\
    \ str_replace(x, \"h\", \"H\"))\n</code>\n<|/ a tags=lapply,r,string,replace |>\n\
    <| c |>\nOh I did not know about str_replace. Thank you for the tip.\n<|/ c |>\n\
    <| a tags=lapply,r,string,replace |>\nHere is a simple function to do that in\
    \ base R: \n<code>\nflip_case = function(str){\n  toupper(tolower(str))\n}\n\n\
    flip_case('hELLO')", "\n  x <- string\n  x <- gsub(toupper(x), tolower(x), x)\n\
    \  x\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\nlibrary(stringr)", "\n \
    \ gsub(\"(?<=.)([a-z])\", toupper, string)\n}\n\nflip_case(\"How are you?\")\n\
    </cell>\n<text>\nPractice writing your own functions\nDefine a function called\
    \ square, which takes a number and returns the square of the number.  Use it to\
    \ take the square of the number 3, for example.  The function should only take\
    \ one argument (the number).\n\n\n</text>\n<code language=conda-root-py>", "\n\
    \    string <- toupper(string)\n    gsub(paste0(\"(?i)\", LETTERS), LETTERS, string)\n\
    }\n", "\n  sapply(string, toupper) %>% tolower()\n}\n\nflip_case(\"HeLLo\")\n\
    </cell>\n<text>\nExercise 7\nWrite a function to reverse a string given as a string.\n\
    \n\n</text>\n<cell>", "\n  toupper(string) %>% \n    tolower() %>%\n    str_replace(toupper(pattern\
    \ = \"[a-z]\"), toupper(pattern = \"[A-Z]\"), .) %>%\n    str_replace(tolower(pattern\
    \ = \"[A-Z]\"), tolower(pattern = \"[a-z]\"), .)\n}\n</code>\nAnd here is a way\
    \ to generate your dataframe from the text you provided:\n<code>\nraw_data <-\
    \ \"\nTitle, First Name, Last Name, Department, Department, Date, Time, Phone,\
    \ Email, Note\nSenior Recruiter, Joe, Doe, Accounting, Accounting, 2017-09-17,\
    \ 10:10:00, 555-555-555, , , \nManager, Joe, Doe, Accounting, Accounting, 2017-09-17,\
    \ 10:10:00, 555-555-555, , , \nSenior Recruiter, Joe, Doe, IT, IT, 2017-09-17,\
    \ 10:10:00, 555-555-555, , , \nManager, Joe, Doe, IT, IT, 2017-09-17, 10:10:00,\
    \ 555-555-555, , , \nSenior Recruiter, Joe, Doe, Accounting, Accounting, 2017-09-17,\
    \ 10:10:00, 555-555-555, , , \nSenior Recruiter, Joe, Doe, Accounting, Accounting,\
    \ 2017-09-17, 10:10:00, 555-555-555, , , \nManager, Joe, Doe, Accounting, Accounting,\
    \ 2017-09-17, 10:10:00, 555-555-555, , , \nSenior Recruiter, Joe, Doe, Accounting,\
    \ Accounting, 2017-09-17, 10:10:00, 555-555-555, , , \nSenior Recruiter, Joe,\
    \ Doe, Accounting, Accounting, 2017-09-17, 10:10:00, 555-555-555, , , \nManager,\
    \ Joe, Doe, Accounting, Accounting, 2017-09-17, 10:10:00, 555-555-555, , , \n\
    Senior Recruiter, Joe, Doe, IT, IT, 2017-09-17, 10:10:00, 555-555-555, , , \n\
    Manager, Joe, Doe, IT, IT, 2017-09-17, 10:10:00, 555-555-555, , , \nSenior Recruiter,\
    \ Joe, Doe, Accounting, Accounting, 2017-09-17, 10:10:00, 555-555-555, , , \n\
    Senior Recruiter, Joe, Doe, Accounting, Accounting, 2017-09-17, 10:10:00, 555-555",
  "\n  # Only lowercase characters.\n  string_lower <- tolower(string)\n  # Replace\
    \ uppercase characters with lowercase.\n  string_upper <- toupper(string_lower)\n\
    \  # Return the flipped string.\n  return(string_upper)\n}\n\nflip_case('hello')\n\
    </cell>\n<cell>", "\n  gsub(toupper(string), '', tolower(string))\n}\n\nflip_case('Hello')",
  "\n  x <- tolower(string)\n  y <- toupper(x)\n  z <- tolower(y)\n  return(z)\n}\n",
  "\n  str_replace_all(string, pattern = \"[A-Z]\", replacement = \"_UPPER\")\n  str_replace_all(string,\
    \ pattern = \"_UPPER\", replacement = \"[a-z]\")\n}\n", "\n  toupper(string) %>%\
    \ str_replace_all(c(\"a\" = \"A\", \"b\" = \"B\", \"c\" = \"C\", \"d\" = \"D\"\
    ,\n                                       \"e\" = \"E\", \"f\" = \"F\", \"g\"\
    \ = \"G\", \"h\" = \"H\", \"i\" = \"I\",\n                                   \
    \    \"j\" = \"J\", \"k\" = \"K\", \"l\" = \"L\", \"m\" = \"M\", \"n\" = \"N\"\
    , \"o\" = \"O\",\n                                       \"p\" = \"P\", \"q\"\
    \ = \"Q\", \"r\" = \"R\", \"s\" = \"S\", \"t\" = \"T\", \"u\" = \"U\",\n     \
    \                                  \"v\" = \"V\", \"w\" = \"W\", \"x\" = \"X\"\
    , \"y\" = \"Y\", \"z\" = \"Z\", letter = \"_\",\n                            \
    \           letters = LETTERS))\n}\n", "\n  gsub(\"([a-z])([A-Z])\", \"\\\\1\\\
    \\2\", string)\n}\n", "\n  string <- gsub(pattern = \"([a-z])\", replacement =\
    \ \"\\\\U\\\\1\", x = string)\n  return(toupper(string))\n}\n", "\n  string %>%\n\
    \    str_replace_all(c(\"\\\\w\", \"_\"), \"\\\\U{1}\\\\w\\\\U{1}\") %>%\n   \
    \ str_replace_all(c(\"_\", \"\\\\U{1}\")) %>%\n    str_replace_all(\"^[a-z]+$\"\
    , \"\\\\U{1}\\\\w\") %>%\n    str_replace_all(\"^[A-Z]+$\", \"\\\\U{1}\") %>%\n\
    \    str_replace_all(\"^[0-9]+$\", \"\\\\U{1}\\\\d\") %>%\n    str_replace_all(\"\
    ^[A-Z]+$\", \"\\\\U{1}\") %>%\n    str_replace_all(\"^[a-z]+$\", \"\\\\U{1}\\\\\
    w\") %>%\n    str_replace_all(\"^[0-9]+$\", \"\\\\U{1}\\\\d\") %>%\n    str_replace_all(\"\
    ^[a-z]+$\", \"\\\\U{1}\\\\w\") %>%\n    str_replace_all(\"^[A-Z]+$\", \"\\\\U{1}\"\
    ) %>%\n    str_replace_all(\"^[a-z]+$\", \"\\\\U{1}\\\\w\") %>%\n    str_replace_all(\"\
    ^[0-9]+$\", \"\\\\U{1}\\\\d\")\n}\n", "\n    str_split_fixed(string, pattern =\
    \ \"(?<=.)(?=.)\", n = 1)[[1]]\n}\n</cell>\n<cell>", "\n    string %>%\n    gsub(\"\
    ([a-z])([A-Z])\", \"\\\\1\\\\2\") %>%\n    gsub(\"([A-Z])([A-Z][a-z])\", \"\\\\\
    1\\\\2\") %>%\n    gsub(\"([a-z])([A-Z])\", \"\\\\1\\\\2\")\n}\n\nflip_case(\"\
    Hello\")\n</code>\n<|/ a dscore=1 tags=r,string,gsub |>\n<| c |>\nThis would work\
    \ only when the string has one capital letter per word.\n<|/ c |>\n<| c |>\nAh\
    \ yes, I see what you're saying.  So this won't work if there's a word with multiple\
    \ capitals?  Oh well!\n<|/ c |>\n<| c |>\nI realized that my answer won't do what\
    \ you need with your new requirements. So I've updated it to work with your new\
    \ requirements.  Let me know if that helps you!\n<|/ c |>\n<| c |>\nThis answer\
    \ works for all possible cases. Thank you!\n<|/ c |>\n<| a dscore=0 |>\nUsing\
    \ the same idea as but using regexp to find and replace with \\L\\U\\L instead\
    \ of \\L\\E\\L:\n<code>\nflip_case <- function(string) {\n    string %>%\n   \
    \     str_split() %>%\n        map_chr(~gsub(paste(\"([a-z])([A-Z])\", collapse\
    \ = \"|\"), \n                     \"\\\\1\\\\2\", .)) %>%\n        map_chr(~gsub(paste(\"\
    ([A-Z])([A-Z][a-z])\", collapse = \"|\"),\n                     \"\\\\1\\\\2\"\
    , .))\n}\n\nflip_case(\"Hello, world.\")\n</code>\nEDIT: Just realized this won't\
    \ work with words containing only a single capital.  Hopefully it's good enough\
    \ for the general case.\n<|/ a tags=r,string,gsub |>\n<| c |>\nThank you for your\
    \ reply! But this doesn't work for me. My string just returns the same string\
    \ as before and my console doesn't return any errors. I added my strings as an\
    \ edit to the question\n<|/ c |>\n<| a tags=r,string,gsub |>\nYou can try this\
    \ approach to keep it vectorized.\n<code>\nflip_case <- function(string) {\n \
    \ vec <- unlist(strsplit(string, \" \"))\n  \n  vec[is.na(vec)] <- vec[!is.na(vec)]\
    \ %>%\n    paste0(., \"_\") %>%\n    paste(., \"_\") %>%\n    strsplit(\"\") ",
  "\n  string %>%\n    str_to_lower %>%\n    str_to_upper %>%\n    str_to_lower\n\
    }\n</cell>\n<code language=conda-env-PromoterArchitecturePipeline-py>", "\n  toupper(string)\
    \ %>% \n    chartr('aeiou', 'AEIOU')\n}\nflip_case('Hello')\n</cell>\n<cell>",
  "\n  n <- nchar(str)\n  sapply(\n    rep(letters, n), \n    function(x) \n     \
    \ paste0(\n        toupper(x[seq(1, n)]), \n        tolower(x[-seq(1, n)]), \n\
    \        x[-seq_len(n)]\n      )\n  )\n}\n", "\n  gsub('(.)([A-Z])', \n      \
    \ \"\\U\\1\\L\\2\", \n       tolower(string))\n}\n</code>\nThe pattern matches\
    \ all lowercase letters and flips them by reversing the order of letters.\nIn\
    \ your code, you do not use any of this functionality. To do that you need to\
    \ do the following:\n\nCreate two regex patterns:\n<code>", "\n  string <- gsub(\"\
    ([a-z])([A-Z])\", \"\\\\U\\\\2\\\\L\\\\1\", string)\n  string <- gsub(\"([A-Z])([A-Z])\"\
    , \"\\\\U\\\\1\\\\L\\\\2\", string)\n  return(string)\n}\n", "\n  strsplit(string,\
    \ \"(?i)\")[[1]][2] %>% toupper() %>% paste(collapse = \"\")\n}\n\nflip_case(\"\
    Hello World!\")", "\n  gsub(\n    pattern = \"([a-z])\",\n    replacement = paste0(\"\
    \\\\U\\\\1\", toupper(string)),\n    x = string\n  )\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nJust to add my two cents, here are two other versions written in\
    \ R without using stringr package which has already been suggested.\n<code>",
  "\n  string_flipped <- gsub(\"(.)([A-Z])\", \"\\\\U\\\\2\\\\L\\\\1\", string)\n\
    \  return(string_flipped)\n}\n", "\n  gsub(toupper, tolower, string)\n}\n\nflip_case('Hello')",
  "\n    string %>% \n        gsub(\" \", \"_\", .) %>% \n        gsub(\"([a-z])([A-Z])\"\
    , \"\\U\\1\", .) %>% \n        gsub(\"([A-Z])([A-Z][a-z])\", \"\\U\\1\", .)\n\
    }\n</cell>\n<cell>\nflip_case(\"Hello, World!\")\n</cell>\n<cell>", "\n  nchar(gsub(tolower(string),\
    \ toupper(string), string)) > 0L\n}\nflip_case(c(\"Hello\", \"hi\"))\n</cell>\n\
    <cell>\nflip_case(c(\"Hi\", \"hello\"))\n</cell>\n<cell>\nflip_case(c(\"Hi\",\
    \ \"hi\"))\n</cell>\n<cell>\nflip_case(c(\"Hi\", \"hi\", \"Hello\"))\n</cell>\n\
    <text>\nVectorizing functions\nVectorizing functions help us work with each element\
    \ of a vector separately, rather than processing an entire vector at once. A vectorizing\
    \ function has the general syntax:\n\n\n</text>\n<cell>", "\n  gsub(\"(.)([A-Z])\"\
    , \n       function(x) toupper(x[2]) + x[1], \"\\\\1\", \n       perl = TRUE)\n\
    }\n", "\n  gsub(paste0(\"\\\\b\", LETTERS, \"\\\\b|\\\\b\", LETTERS, \"\\\\b\"\
    ), \n         toupper(tolower(string)), \n         string)\n}\n</code>\nThis returns\
    \ a vector, not a string. So, if you're going to save it as a string, you'll need\
    \ to unlist it. \n<code>\n> flip_case(\n    paste(letters, paste0(letters, collapse=\"\
    \"))\n)\n[1] \"aA\"  \"bB\"  \"cC\"  \"dD\"  \"eE\"  \"fF\"  \"gG\"  \"hH\"  \"\
    iI\"  \"jJ\"  \"kK\"  \"lL\"  \"mM\"  \"nN\"  \"oO\"  \"pP\"  \"qQ\"  \"rR\" \
    \ \"sS\"  \"tT\"  \"uU\"  \"vV\"  \"wW\"  \"xX\"  \"yY\"  \"zZ\" \n</code>\nOr,\
    \ if you really want to return the uppercase string itself:\n<code>\nflip_case\
    \ <- function(string) {\n  gsub(paste0(\"\\\\b\", LETTERS, \"\\\\b|\\\\b\", LETTERS,\
    \ \"\\\\b\"), \n         toupper(tolower(string)), \n         string)\n}\n</code>\n\
    <|/ a tags=r,regex,string,gsub,character |>\n<| c |>\nThanks for your answer,\
    \ but I'm afraid the output is just a character string, not a new variable. I've\
    \ edited my question to show what I mean. Maybe I should have been clearer in\
    \ my question...\n<|/ c |>\n<| c |>\n, sorry, the output is still a character\
    \ string. I'm confused why you think it's not.\n<|/ c |>\n<| a |>\nUsing gsubfn\
    \ package, we can use a recursive function with nested gsubfn calls:\n<code>\n\
    library(gsubfn)\n\nx <- \"He said that she was a political genius when he was\
    \ a political freak.\"\n\nunlist(gsubfn(\"\\\\b(\\\\w)(\\\\w+\\\\b)\\\\1\", gsubfn(\"\
    \\\\b\\\\w+\\\\b\", ~paste0(toupper(.), tolower(.)), x), x))", "\n  str_to_lower(string)\
    \ %>%\n    str_upper() %>%\n    str_lower()\n}\n\nflip_case('Hello')\n</cell>\n\
    <cell>", "\n    string %>% \n        str_split(\"[a-z]\") %>% \n        unlist\
    \ %>% \n        paste(collapse=\"\") %>% \n        paste(collapse=\"_\") %>% \n\
    \        toupper() %>% \n        paste(collapse=\"\") %>% \n        str_replace_all(\"\
    _[a-z]\", \"_\") %>% \n        paste(collapse=\"_\") %>% \n        tolower()\n\
    }\n</cell>\n<text>\nNow let's test our function:\n\n\n</text>\n<cell>\nflip_case(\"\
    hello_there\")\n</cell>\n<text>\nThat looks reasonable enough!  As we mentioned\
    \ in the last section, the output from our function can easily be captured as\
    \ a new column in our dataframe.  Let's do that!\n\n\n</text>\n<cell>", "\n  case_change\
    \ <- function(x) {\n    x <- toupper(x)\n    x <- tolower(x)\n    x\n  }\n  return(apply(sapply(string,\
    \ case_change), 1, paste, collapse = \"\"))\n}\n</cell>\n<cell>\nflip_case('hello')\n\
    </cell>\n<text>\nThe purrr package\nThe purrr package is designed to help you\
    \ work with data frame objects that consist of multiple columns. One of the main\
    \ advantages of purrr is that it has functions to help you manipulate lists, vectors,\
    \ and data frames. With purrr, you can do all sorts of cool things with your data!\n\
    \n\n</text>\n<cell>\nlibrary(purrr)\n</cell>\n<text>\nWe can use map_chr which\
    \ applies a function to every element of a list.\n\n\n</text>\n<cell>\nmap_chr(c(\"\
    a\", \"b\", \"c\"), length)\n</cell>\n<text>\nmap_chr is an alias for map for\
    \ data frames.\n\n\n</text>\n<cell>\nmap_chr(mtcars, ~as.character(.))\n</cell>\n\
    <text>\nYou can pass in a vector or matrix of values to map_chr.\n\n\n</text>\n\
    <cell>\nmap_chr(mtcars[, c(\"mpg\", \"cyl\")], ~as.character(.))\n</cell>\n<text>\n\
    map_chr and map can take a function that modifies each element of an element of\
    \ a data frame and returns an updated data frame.\n\n\n</text>\n<cell>\nmap_df(mtcars,\
    \ ~.x %>% mutate(.x = gsub(\"G\", \"e\", .x)))\n</cell>\n<text>\nmap_df can apply\
    \ a function to each column of a data frame.\n\n\n</text>\n<cell>\nmap_df(mtcars,\
    \ ~.x %>% mutate(.x = gsub(\"G\", \"e\", .x)))[, c(\"mpg\", \"cyl\", \"disp\"\
    , \"drat\", \"wt\", \"qsec\", \"vs\", \"am\", \"gear\", \"carb\")]\n</cell>\n\
    <text>\nMap and map_df are also aliases of map.\n\n\n</text>\n<cell>\nmap(mtcars,\
    \ ~.x %>% mutate(.x = gsub(\"G\", \"e\", .x)))\n</cell>\n<cell>\nmap_df(mtcars,\
    \ ~.x %>% mutate(.x = gsub(\"G\", \"e\", .x)))[, c(\"mpg\", \"cyl\", \"disp\"\
    , \"drat\", \"wt\", \"qsec\", \"vs\", \"am\", \"gear\", \"carb\")]\n</cell>\n\
    <text>\nThe imap_* family of ", "\n  string <- tolower(string)\n  str_split(string,\
    \ \"(?<=[a-z])(?=[A-Z])\", perl=TRUE)[[1]][1]\n}\n</code>\nYou can see that all\
    \ letters are flipped. Now let's look at the results you gave:\n<code>\nflip_case(\"\
    AAbc\")", "\n  stringr::str_replace_all(string, toupper, tolower)\n}\n", "\n \
    \ toupper(string)\n}\n", "\n  gsub(toupper(string), '\\\\1', tolower(string))\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the solution but can you explain\
    \ to me how you are using regex to find the letters?  I don't really understand\
    \ what that code does.  Thanks!\n<|/ c |>\n<| c |>\nI added an explanation, let\
    \ me know if that helps.\n<|/ c |>\n<| a |>\n<code>\n> library(stringr)\n> unlist(str_extract_all(\"\
    hello my name is Jack \", pattern=\"[A-Z]+\"))\n[1] \"Jack\"\n> unlist(str_extract_all(\"\
    hello my name is Jack \", pattern=\"[A-Z]+\"))\n[1] \"Jack\"\n</code>\n<|/ a tags=string,r,regex,pattern-matching\
    \ dscore=2 |>\n<| c |>\nThat's pretty much the same code I provided, except you\
    \ used `str_extract_all` instead of `str_match` which is not needed here.\n<|/\
    \ c |>\n<| a dscore=1 tags=string,r,regex,pattern-matching |>\nHere's a data.table\
    \ option:\n<code>\nlibrary(data.table)", "\n  gsubfn(\"(..)\", c(toupper, tolower),\
    \ string)\n}\n", "\n    str_split(tolower(string), \" \") %>%\n        unlist\
    \ %>%\n        paste(collapse=\" \") %>%\n        paste(str_split(toupper(string),\
    \ \" \") %>%\n                unlist %>%\n                paste(collapse=\" \"\
    ))\n}\n\n</cell>\n<cell>\nflip_case(\"Hello, world!\")\n</cell>\n<cell>\nflip_case(\"\
    Hello, world!!\")\n</cell>\n<text>\nMap\nYou can apply a function to each element\
    \ of a vector or each element of a list. You can also apply a function to each\
    \ element of a tibble and return a tibble.\n\n\n</text>\n<cell>", "\n  string\
    \ <- gsub(tolower(string), '\\\\1', toupper(string))\n  string <- gsub(toupper(string),\
    \ '\\\\1', tolower(string))\n  return(string)\n}\nflip_case(\"aBcDeF\")", "\n\
    \  str <- gsub(\"([a-z])([A-Z])\", paste0(\"\\\\U\\\\1\", \n                 \
    \                          \"\\\\L\\\\1\"), string)\n  str <- gsub(\"([A-Z])([A-Z])\"\
    , paste0(\"\\\\U\\\\1\", \n                                           \"\\\\L\\\
    \\1\"), str)\n  str <- gsub(\"([A-Z])([a-z])\", paste0(\"\\\\U\\\\1\", \n    \
    \                                       \"\\\\L\\\\1\"), str)\n  str <- gsub(\"\
    ([a-z])([A-Z])\", paste0(\"\\\\U\\\\1\", \n                                  \
    \         \"\\\\L\\\\1\"), str)\n  str <- tolower(str)\n  str\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=4 tags=replace,r,text-manipulation |>\nThe stringr package\
    \ has a function str_replace_all that works well for me:\n<code>\n> library(stringr)\n\
    > str_replace_all(\"Hello\", \"o\", \"a\")\n[1] \"Haello\"\n</code>\n<|/ a |>\n\
    <| c |>\nWhat about str_replace_all(\"Hello\", \"o\", \"a\") ?\n<|/ c |>\n<| c\
    \ |>\nI agree, this is the best answer here.\n<|/ c |>\n<| a tags=replace,r,text-manipulation\
    \ dscore=3 |>\nThis can also be done with gsubfn.\n<code>\nlibrary(gsubfn)\n\n\
    gsubfn(\"(.*)(o)(.*)\", ~ c(s1=sub(\"\\\\1\", \"\\\\U\\\\1\", .x), s2=sub(\"\\\
    \\3\", \"\\\\L\\\\2\", .x))[c(1,3)], \n      x=c(\"Hello\", \"Hello\"))", "\n\
    \  chartr(toupper, tolower, string)\n}\n", "\n  out <- tolower(string)\n  out\
    \ <- toupper(out)\n  out\n}\n\nflip_case('hELLO')\n", "\n    string %>%\n    \
    \    str_split('') %>%\n        map_chr(~ {\n            .[[1]] %>%\n        \
    \    str_to_upper %>%\n            str_to_lower\n        })\n}\n", "\n    string\
    \ %>% \n        gsub(pattern = \"(.)\", replacement = function(x) toupper(substring(x,\
    \ 2, nchar(x))), perl=TRUE)\n}\n</cell>\n<cell>\nstring = 'hello, world !'\n</cell>\n\
    <cell>\nstring\n</cell>\n<cell>\nflip_case(string)\n</cell>\n<cell>\nflip_case(test)\n\
    </cell>\n<cell>\ntest_vector = c('hello', 'world', '!')\n</cell>\n<cell>\ntest_vector\n\
    </cell>\n<cell>\nflip_case(test_vector)\n</cell>\n<text>\nString length\n\n</text>\n\
    <cell>", "\n    chartr(\"'\\\\l*'\",\n            \"'\\\\U*'\",\n            toupper(string))\n\
    }\n", "\n  string %>%\n    str_replace_all(\"[a-z]\",\n                    toupper)\
    \ %>%\n    str_replace_all(\"[A-Z]\",\n                    tolower) %>%\n    paste(collapse\
    \ = \"\")\n}\n</cell>\n<text>\nChallenge 13 (10 Points)\nWrite a function called\
    \ check_for_duplicate_values which will return True if the provided vector has\
    \ duplicate values, False otherwise.\n\nFor a more detailed description, please\
    \ see the examples section of the Introduction to R tutorial\n\n</text>\n<code\
    \ language=r>\ncheck_for_duplicate_values <- function(x) {\n  length(which(x %in%\
    \ x)) == 1\n}\n</cell>\n<text>\nChallenge 14 (10 Points)\nWrite a function called\
    \ extract_data which accepts a single string argument\nThis function should return\
    \ a dataframe of the data in the passed string as a data.frame\nFor a more detailed\
    \ description, please see the examples section of the Introduction to R tutorial\n\
    \n</text>\n<code language=r>\nextract_data <- function(string) {\n  # Extract\
    \ data\n}\n</cell>\n<text>\nChallenge 15 (10 Points)\nWrite a function called\
    \ extract_all_values which accepts a single string argument that returns a vector\
    \ of the values from the passed string\nFor a more detailed description, please\
    \ see the examples section of the Introduction to R tutorial\n\n</text>\n<code\
    \ language=r>\nextract_all_values <- function(string) {\n  # Extract all values\n\
    }\n</cell>\n<text>\nChallenge 16 (10 Points)\nWrite a function called extract_values\
    \ which accepts a single character argument that returns all values from the passed\
    \ string except for those that end with the passed argument\nFor a more detailed\
    \ description, please see the examples section of the Introduction to R tutorial\n\
    \n</text>\n<code language=r>\nextract_values <- function(string, value) {\n  #\
    \ Extract value\n}\n</cell>\n<text>\nChallenge 17 (10 Points)\nWrite a function\
    \ called is_palindrome which accepts a single string argument that returns True\
    \ if the passed string is a palindrome and False if it is not a palindrome\nFor\
    \ a more detailed description, please see the examples section of the Introduction\
    \ to R tutorial\n\n</text>\n<code language=r>\nis_palindrome <- function(string)\
    \ {\n  # Check if palindrome\n}\n</cell>\n<text>\nChallenge 18 (10 Points)\nWrite\
    \ a function called count_characters which\n\nAccepts a character vector as input\n\
    This function should return a new vector of character counts based on the provided\
    \ character vector\nFor a more detailed description, please see the examples section\
    \ of the Introduction to R tutorial\n\n</text>\n<code language=r>\ncount_characters\
    \ <- function(x) {\n  # Count characters\n}\n</cell>\n<text>", "\n    string %>%\
    \ \n        str_split('') %>% \n        map_chr(~str_c(str_to_upper(.x), str_to_lower(.x),\
    \ sep = \"\"))\n}\n", "\n  gsub(\n    \"[[:lower:]]\",\n    function(x) {\n  \
    \    tolower(x)\n    },\n    string,\n    perl = TRUE,\n  )\n}\n\nflip_case(\"\
    hello\")", "\n  string <- tolower(string)\n  string <- toupper(string)\n  return(string)\n\
    }\n", "\n    string %>%\n        str_toupper %>%\n        str_tolower\n}\nflip_case(fakenames)\n\
    </cell>\n<cell>\nfakenames\n</cell>\n<cell>", "\n  gsub(toupper,tolower,string)\n\
    }\n</cell>\n<cell>\nflip_case(\"Hello, world!\")\n</cell>\n<cell>", "\n  pattern\
    \ <- \"([a-z])([A-Z])\"\n  str_replace_all(string, pattern, \"\\\\1\\\\2\")\n\
    }\n</code>\n<|/ a tags=r,stringr,regex |>\n<| a |>\nWe can use the stringi package's\
    \ stri_replace_all_fixed\n<code>\nlibrary(stringi)\nstri_replace_all_fixed(c(\"\
    L\", \"l\"), \"l\", \"I\")", "\n  string %>% \n    str_replace_all(\"([a-z])\"\
    , \"\\\\U\\\\1\") %>% \n    str_replace_all(\"([A-Z])\", \"\\\\l\\\\1\") %>% \n\
    \    str_replace_all(\"([A-Z])\", \"\\\\U\\\\1\") %>% \n    str_replace_all(\"\
    ([a-z])\", \"\\\\l\\\\1\") %>% \n    str_replace_all(\"([a-z])\", \"\\\\U\\\\\
    1\") %>% \n    paste0(collapse = \"\")\n}\n</code>\n<|/ a tags=r,string |>\n<|\
    \ c |>\nthanks for your help, but your solution does not produce the expected\
    \ output: e.g. flip_case(\"ABC\") returns \"AbC\"\n<|/ c |>\n<| c |>\nit works\
    \ for me. What output are you expecting?\n<|/ c |>\n<| c |>\nsorry I should have\
    \ been clearer, I want the following result \"ABC\" to be returned as \"AbC\"\n\
    <|/ c |>\n<| c |>\nit still works for me. I have edited my answer to show you\
    \ what happens when you enter \"ABC\"\n<|/ c |>\n<| a |>\nI got it working. Here's\
    \ an implementation in R:\n<code>\nflip_case <- function(string) {\n  result <-\
    \ str_replace_all(string, \"([a-z])\", \"\\\\U\\\\1\")\n  result <- str_replace_all(result,\
    \ \"([A-Z])\", \"\\\\l\\\\1\")\n  result <- str_replace_all(result, \"([a-z])\"\
    , \"\\\\l\\\\1\")\n  result <- str_replace_all(result, \"([A-Z])\", \"\\\\U\\\\\
    1\")\n  return(result)\n}\n\nflip_case(\"abc\")", "\n  gsub('(.)([A-Z])', '\\\\\
    U\\\\1\\\\L\\\\2', string)\n}\n</code>\nAnd then to test it I created the following\
    \ dataframe:\n<code>\n  x y\n1 a B\n2 b c\n3 d e\n</code>\nWhich I then grouped\
    \ by x and flipped the cases of the values of y.\n<code>\n  x y x\n1 a B a\n2\
    \ b c B\n3 d e d\n</code>\nThis gives me the expected result.\n<|/ a |>\n<| c\
    \ |>\nThis works for some strings, but not all. For example: `'Hi everybody'`\
    \ becomes `'Hi everybody'` rather than `'Hi everybody Hi everybody'`.\n<|/ c |>\n\
    <| c |>\nI think that's because there aren't any lowercase letters. If you try\
    \ `'Hi everybody'.tolower()` you'll see that there's only a single lowercase letter.\
    \ I'll update the answer with a more robust approach.\n<|/ c |>\n<| c |>\nYes,\
    \ that's true, but I assumed that if the OP had some strings that aren't working\
    \ that he would have mentioned those in the question. I'll admit that I don't\
    \ have a strong intuition for what kinds of strings are expected in questions,\
    \ but I've updated my answer with some more test cases.\n<|/ c |>\n<| c |>\nThanks.\
    \ I didn't know about `tolower()`. It's a great solution.\n<|/ c |>\n<| a tags=string,r\
    \ dscore=1 |>\nThis problem may be better solved with gsub:\n<code>\ngsub(\"([a-z])\"\
    ,toupper(\"\\\\1\"),\"hello\")\n</code>\n<|/ a |>\n<| c |>\nThis works for some\
    \ strings, but not all. For example: `'Hi everybody'` becomes `'Hi everybody'`\
    \ rather than `'Hi everybody Hi everybody'`.\n<|/ c |>\n<| a tags=string,r |>\n\
    I realize this is an old question, but I wanted to share my solution to this.\
    \ I came up with a solution that was close to what was already suggested in the\
    \ comments. This solution takes the string and replaces the case of each character\
    \ individually. \nIt also keeps the character itself in the string if it has at\
    \ least one uppercase letter, otherwise it deletes it. The string can contain\
    \ both lower and uppercase letters and numbers. I tested it against all possible\
    \ cases, including combinations of both and mixed cases. \n<code>\nreplace_case\
    \ <- function(string){", "\n    string %>% str_replace_all('([a-z])([A-Z])', '\\\
    U\\1\\L\\2')\n}\n</code>\nSo we can do:\n<code>\n> flip_case(\"Hello World!\"\
    )\n[1] \"hELLO wORLD!\"\n> flip_case(\"Hey dude\")\n[1] \"Hey dUde\"\n</code>\n\
    Now we can use the two functions to get the correct case for your sentence:\n\
    <code>\n> flip_case_sentence(sentence)\n[1] \"hELLO wORLD!\"\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI agree this should work, but I am getting this error `Error in\
    \ eval(expr, envir, enclos) : \n  cannot create S4 class 'sentence': \n  Class\
    \ constructor is private`\n<|/ c |>\n<| c |>\nYou're probably calling the function\
    \ wrong. Try calling it just as I did for `flip_case`\n<|/ c |>\n<| c |>\nYeah\
    \ I figured out the problem I didn't have `rlang` installed. Thank you!\n<|/ c\
    \ |>\n<| a tags=r,tidytext,stringr |>\nJust use stringi package\n<code>\nrequire(stringi)\n\
    stri_trans_totitle(str_replace_all(sentence, \"[[:upper:]]\", \"_\")) \n[1] \"\
    hELLO wORLD!\"\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`require(stringi)` returns\
    \ `Error: package or namespace load failed for \u2018stringi\u2019:\n object \u2018\
    stri_trans_totitle\u2019 is not exported by 'namespace:stringi'`\n<|/ c |>\n<|\
    \ c |>\nYeah I installed `stringr` after reading this [answer](https://stackoverflow.com/a/58061268/5325862)\
    \ but I still get the same error.\n<|/ c |>\n<| a |>\nSince you are using stringr,\
    \ you can use the functions str_collapse and str_split.\n<code>\nlibrary(stringr)\n\
    sentence <- \"Hello World!\"\n\nsentence <- str_split(sentence, \" \")\nstr_collapse(sentence,\
    \ \"_\") %>% str_c(collapse=\" \")\n</code>\n<|/ a dscore=0 tags=r,tidytext,stringr\
    \ |>\n<| c |>\nThank you for this, I get the error `Error: could not find function\
    \ \"str_collapse\"`\n<|/ c |>\n<| c |>\nWhat version of `stringr` are you using?\
    \ If `stringr` is 0.4.1, you might ", "\n  string %>% tolower() %>% toupper()\n\
    }\n</cell>\n<cell>\nflip_case(hello_world)\n</cell>\n<text>\nVectorized Functions\n\
    Vectorized functions operate on a whole vector at a time.\n\n\n</text>\n<cell>",
  "\n  chartr(\n    tolower(string),\n    toupper(string),\n    string\n  )\n}\n",
  "\n  string <- tolower(string)\n  str_split(string, '') %>% \n    str_split('')\
    \ %>% \n    map(., str_to_lower) %>% \n    unlist %>% \n    str_c(collapse='')\n\
    }\n</cell>\n<cell>\nflip_case(\"the quick brown fox jumped over the lazy dog\"\
    )\n</cell>\n<cell>\nstring = 'The quick brown fox jumped over the lazy dog'\n\
    </cell>\n<cell>\nstring = 'The quick brown fox jumped over the lazy dog'\n</cell>\n\
    <cell>\nstring = 'The quick brown fox jumped over the lazy dog'\n</cell>\n<cell>\n\
    string = 'the quick brown fox jumped over the lazy dog'\n</cell>\n<cell>\nstring\
    \ = 'the quick brown fox jumped over the lazy dog'\n</cell>\n<cell>\nstring =\
    \ 'the quick brown fox jumped over the lazy dog'\n</cell>\n<cell>\nstring = 'the\
    \ quick brown fox jumped over the lazy dog'\n</cell>\n<cell>\nstring = 'the quick\
    \ brown fox jumped over the lazy dog'\n</cell>\n<cell>\nstring = 'the quick brown\
    \ fox jumped over the lazy dog'\n</cell>\n<cell>\nstring = 'the quick brown fox\
    \ jumped over the lazy dog'\n</cell>\n<cell>\nstring = 'the quick brown fox jumped\
    \ over the lazy dog'\n</cell>\n<cell>\nstring = 'the quick brown fox jumped over\
    \ the lazy dog'\n</cell>\n<cell>\nstring = 'the quick brown fox jumped over the\
    \ lazy dog'\n</cell>\n<cell>\nstring = 'the quick brown fox jumped over the lazy\
    \ dog'\n</cell>\n<cell>\nstring = 'the quick brown fox jumped over the lazy dog'\n\
    </cell>\n<cell>\nstring = 'the quick brown fox jumped over the lazy dog'\n</cell>\n\
    <cell>\nstring = 'the quick brown fox jumped over the lazy dog'\n</cell>\n<cell>\n\
    string = 'the quick brown fox jumped over the lazy dog'\n</cell>\n<cell>\nstring\
    \ = 'the quick brown fox jumped over the lazy dog'\n</cell>\n", "\n  toupper(string)\
    \ %>% \n    paste0(tolower(string), collapse = \"\") %>%\n    paste0(toupper(string),\
    \ collapse = \"\")\n}\n", "\n  ustring <- toupper(tolower(string))\n  return(ustring)\n\
    }\nflip_case(\"hello\")", "\n  string <- gsub(\"(^.)|(.$)\", paste0(\"\\\\U\\\\\
    1\", string), string)\n  string <- gsub(\"(.)([A-Z])\", paste0(\"\\\\1\\\\2\"\
    ), string)\n  string\n}\n\nflip_case(\"Hello\")\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nI like this solution because it doesn't require any packages. I wonder\
    \ if there is a way to also use this function to make title-case? For instance,\
    \ I want to do \"Ohio\" -> \"Ohio\"\n<|/ c |>\n<| a dscore=5 tags=r,capitalization,string\
    \ |>\nYou could use tolower function from base R library to do this. Below is\
    \ the example.\n<code>", "\n  str_to_lower <- tolower(string)\n  str_to_upper\
    \ <- toupper(str_to_lower)\n  return(str_to_upper)\n}\n", "\n  chartr(\"[[:lower:]]\"\
    , \"[[:upper:]]\", string)\n}\n</code>\nNow we can simply use mapply on the vector\
    \ of words and flip each case:\n<code>\nmapply(flip_case, words)\n</code>\nOutput:\n\
    <code>\n[1] \"hello\"  \"hELLO\"  \"what\"   \"wHAT\"   \"How\"    \"WoW\"   \
    \ \"Where\"  \"WHO\"    \"When\"   \"WHEN\"   \"And\"    \"&\"      \"How\"  \
    \  \"What\"   \"How\"    \"When\"   \"Where\"  \"What\"   \"How\"    \"Where\"\
    \  \"What\"   \"Where\"  \"Where\"  \n[26]  \"where\"  \"Where\"  \"Where\"  \"\
    Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"\
    Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"\
    Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"\
    Where\"  \n[51]  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"\
    \  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"\
    \  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"\
    \  \"Where\"  \"Where\"  \"Where\"  \n[76]  \"Where\"  \"Where\"  \"Where\"  \"\
    Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"\
    Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"\
    Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \n\
    [101] \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"\
    \  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"\
    \  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"\
    \  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \n[126] \"Where\"  \"Where\"  \"\
    Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"\
    Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"\
    Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"  \"Where\"", "\n\
    \  gsub(\"([a-z])([A-Z])\",\"\\\\1\\\\2\", string)\n}\n", "\n    string %>%\n\
    \        str_to_lower() %>%\n        paste(toupper(tolower(string)), sep = \"\"\
    )\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
