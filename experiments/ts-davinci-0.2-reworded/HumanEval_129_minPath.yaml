name: HumanEval_129_minPath
language: ts
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered arrays of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered array of the values on the cells that the minimum\
  \ path go through.\n// Examples:    \n// >>> minPath([[1, 2, 3], [4, 5, 6], [7,\
  \ 8, 9]], 3)\n// [1, 2, 1]\n// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\
  // [1]\nfunction minPath(grid: number[][], k: number): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3],\
  \ [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3],\
  \ [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5,\
  \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6,\
  \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10,\
  \ 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5,\
  \ 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11,\
  \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1,\
  \ 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5,\
  \ 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["    const n = grid.length;\n    const m = grid[0].length;\n    const\
    \ visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n    const\
    \ queue = [[0, 0, 0, []]];\n    let minPath = [];\n    while (queue.length) {\n\
    \        const [i, j, l, path] = queue.shift();\n        if (l === k) {\n    \
    \        if (!minPath.length || minPath.join('') > path.join('')) {\n        \
    \        minPath = path;\n            }\n            continue;\n        }\n  \
    \      if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n          \
    \  continue;\n        }\n        visited[i][j] = true;\n        queue.push([i\
    \ + 1, j, l + 1, [...path, grid[i][j]]]);\n        queue.push([i - 1, j, l + 1,\
    \ [...path, grid[i][j]]]);\n        queue.push([i, j + 1, l + 1, [...path, grid[i][j]]]);\n\
    \        queue.push([i, j - 1, l + 1, [...path, grid[i][j]]]);\n    }\n    return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \    let dfs = (i: number, j: number, path: number[], sum: number) => {\n    \
    \    if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n  \
    \      sum += grid[i][j];\n        if (path.length === k) {\n            if (sum\
    \ < minPathSum) {\n                minPathSum = sum;\n                minPath\
    \ = path.slice();\n            } else if (sum === minPathSum) {\n            \
    \    if (path.join('') < minPath.join('')) {\n                    minPath = path.slice();\n\
    \                }\n            }\n        } else {\n            dfs(i + 1, j,\
    \ path, sum);\n            dfs(i - 1, j, path, sum);\n            dfs(i, j + 1,\
    \ path, sum);\n            dfs(i, j - 1, path, sum);\n        }\n        path.pop();\n\
    \        visited[i][j] = false;\n    }\n    for (let i = 0; i < n; i++) {\n  \
    \      for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n).fill(0).map(() => new Array(m).fill(0).map(() => new\
    \ Array(k + 1).fill(Infinity)));\n    let ans = new Array(k).fill(Infinity);\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            for (let l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j\
    \ = 0; j < m; j++) {\n            if (dp[i][j][k] < ans[k - 1]) {\n          \
    \      ans[k - 1] = dp[i][j][k];\n            }\n        }\n    }\n    for (let\
    \ i = k - 2; i >= 0; i--) {\n        ans[i] = ans[i + 1];\n    }\n    return ans;",
  "    const n = grid.length;\n    const m = grid[0].length;\n    const dp: number[][][]\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            dp[i][j] = [];\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dp[i][j][0] = grid[i][j];\n        }\n    }\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            for (let l = 1; l < k;\
    \ l++) {\n                dp[i][j][l] = Infinity;\n                if (i > 0)\
    \ {\n                    dp[i][j][l] = Math.min(dp[i][j][l], dp[i - 1][j][l -\
    \ 1]);\n                }\n                if (i < n - 1) {\n                \
    \    dp[i][j][l] = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n             \
    \   }\n                if (j > 0) {\n                    dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < m - 1) {\n\
    \                    dp[i][j][l] = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n            }\n        }\n    }\n    let min = Infinity;\n\
    \    let minI = -1;\n    let minJ = -1;\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j = 0; j < m; j++) {\n            if (dp[i][j][k - 1] < min)\
    \ {\n                min = dp[i][j][k - 1];\n                minI", "    const\
    \ n = grid.length;\n    const m = grid[0].length;\n    const dp = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(0).map(() => new Array(k + 1).fill(Infinity)));\n    const\
    \ res = [];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m;\
    \ j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            for\
    \ (let l = 2; l <= k; l++) {\n                if (i > 0) {\n                 \
    \   dp[i][j][l] = Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n              \
    \  }\n                if (j > 0) {\n                    dp[i][j][l] = Math.min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    let min = Infinity;\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            min = Math.min(min, dp[i][j][k]);\n\
    \        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            if (dp[i][j][k] === min) {\n                res.push(grid[i][j]);\n\
    \            }\n", "    // TODO\n    return [];\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n);\n    for (let i = 0;\
    \ i < n; i++) {\n        dp[i] = new Array(m);\n        for (let j = 0; j < m;\
    \ j++) {\n            dp[i][j] = new Array(k + 1);\n            for (let l = 0;\
    \ l <= k; l++) {\n                dp[i][j][l] = new Array(2);\n              \
    \  dp[i][j][l][0] = Number.MAX_SAFE_INTEGER;\n                dp[i][j][l][1] =\
    \ [];\n            }\n        }\n    }\n    dp[0][0][1][0] = grid[0][0];\n   \
    \ dp[0][0][1][1] = [grid[0][0]];\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < m; j++) {\n            for (let l = 1; l <= k; l++) {\n    \
    \            if (i > 0) {\n                    if (dp[i - 1][j][l - 1][0] + grid[i][j]\
    \ < dp[i][j][l][0]) {\n                        dp[i][j][l][0] = dp[i - 1][j][l\
    \ - 1][0] + grid[i][j];\n                        dp[i][j][l][1] = dp[i - 1][j][l\
    \ - 1][1].concat(grid[i][j]);\n                    } else if (dp[i - 1][j][l -\
    \ 1][0] + grid[i][j] === dp[i][j][l][0]) {\n                        let temp =\
    \ dp[i - 1][j][l - 1][1].concat(grid[i][j]);\n                        if (temp.toString()\
    \ < dp[i][j][l][1].toString()) {\n                            dp[i][j][l][1] =\
    \ temp;\n                        }\n                    }\n                }\n\
    \                if (j >", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath: number[] = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n\
    \    let minPathSum = Number.MAX_SAFE_INTEGER;\n    let visited: boolean[][] =\
    \ [];\n    for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for\
    \ (let j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n \
    \   }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            let path: number[] = [];\n            let pathSum = 0;\n    \
    \        dfs(i, j, k, path, pathSum);\n        }\n    }\n    return minPath;\n\
    \n    function dfs(i: number, j: number, k: number, path: number[], pathSum: number)\
    \ {\n        if (k === 0) {\n            if (pathSum < minPathSum) {\n       \
    \         minPathSum = pathSum;\n                minPath = path.slice();\n   \
    \         } else if (pathSum === minPathSum) {\n                if (path[0] <\
    \ minPath[0]) {\n                    minPath = path.slice();\n               \
    \ }\n            }\n            return;\n        }\n        if (i < 0 || i >=\
    \ n || j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n \
    \       visited[i][j] = true;\n        path.push(grid[i][j]);\n        pathSum\
    \ += grid[i][j];\n        dfs(i - 1, j, k - 1, path, pathSum);\n        dfs(i\
    \ + 1, j, k - 1, path, pathSum);\n        dfs(i, j - 1, k - 1, path, pathSum);\n\
    \        dfs(i, j + 1, k - 1, path, pathSum);\n        path.pop();\n        pathSum\
    \ -= grid[i][j];\n        visited[i][j] = false;\n    }\n}\n\n", "    let n =\
    \ grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = new Array(k);\n    let minSum = Infinity;\n    let minPathSum\
    \ = Infinity;\n    let dfs = (i: number, j: number, path: number[], sum: number,\
    \ pathSum: number) => {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j])\
    \ {\n            return;\n        }\n        if (path.length === k) {\n      \
    \      if (sum < minSum || (sum === minSum && pathSum < minPathSum)) {\n     \
    \           minSum = sum;\n                minPathSum = pathSum;\n           \
    \     minPath = path.slice();\n            }\n            return;\n        }\n\
    \        visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        pathSum += grid[i][j] * path.length;\n        dfs(i + 1,\
    \ j, path, sum, pathSum);\n        dfs(i - 1, j, path, sum, pathSum);\n      \
    \  dfs(i, j + 1, path, sum, pathSum);\n        dfs(i, j - 1, path, sum, pathSum);\n\
    \        path.pop();\n        sum -= grid[i][j];\n        pathSum -= grid[i][j]\
    \ * path.length;\n        visited[i][j] = false;\n    };\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i, j,\
    \ [], 0, 0);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let visited = new Set();\n    let dfs = (i: number, j: number, path: number[],\
    \ pathSum: number) => {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited.has(i\
    \ * m + j)) {\n            return;\n        }\n        if (path.length === k)\
    \ {\n            if (pathSum < minPathSum) {\n                minPathSum = pathSum;\n\
    \                minPath = path;\n            }\n            return;\n       \
    \ }\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n        visited.add(i\
    \ * m + j);\n        dfs(i - 1, j, path, pathSum);\n        dfs(i + 1, j, path,\
    \ pathSum);\n        dfs(i, j - 1, path, pathSum);\n        dfs(i, j + 1, path,\
    \ pathSum);\n        visited.delete(i * m + j);\n        path.pop();\n    }\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let minPath: number[]\
    \ = [];\n    let minSum = Infinity;\n    let minPaths: number[][] = [];\n    let\
    \ minSums: number[] = [];\n    let visited: boolean[][] = [];\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = [];\n        for (let j = 0; j < m;\
    \ j++) {\n            visited[i][j] = false;\n        }\n    }\n    function dfs(i:\
    \ number, j: number, path: number[], sum: number): void {\n        if (sum > minSum)\
    \ {\n            return;\n        }\n        if (path.length === k) {\n      \
    \      if (sum < minSum) {\n                minSum = sum;\n                minPath\
    \ = path;\n                minPaths = [];\n                minSums = [];\n   \
    \         }\n            if (sum === minSum) {\n                minPaths.push(path);\n\
    \                minSums.push(sum);\n            }\n            return;\n    \
    \    }\n        if (i > 0 && !visited[i - 1][j]) {\n            visited[i - 1][j]\
    \ = true;\n            dfs(i - 1, j, path.concat(grid[i - 1][j]), sum + grid[i\
    \ - 1][j]);\n            visited[i - 1][j] = false;\n        }\n        if (i\
    \ < n - 1 && !visited[i + 1][j]) {\n            visited[i + 1][j] = true;\n  \
    \          dfs(i + 1, j, path.concat(grid[i + 1][j]), sum + grid[i + 1][j]);\n\
    \            visited[i + 1][j] = false;\n        }\n        if (j > 0 && !visited[i][j\
    \ - 1]) {\n            visited[i][j - 1] = true;\n            dfs(i, j - 1, path.concat(grid[i][j\
    \ - 1]), sum + grid[i][j - 1]);\n            visited[i][j - 1] = false;\n    \
    \    }", "    const n = grid.length;\n    const visited = new Set<string>();\n\
    \    const queue = [[0, 0, [grid[0][0]]]];\n    while (queue.length > 0) {\n \
    \       const [i, j, path] = queue.shift()!;\n        if (path.length === k) {\n\
    \            return path;\n        }\n        if (i > 0 && !visited.has(`${i -\
    \ 1},${j}`)) {\n            visited.add(`${i - 1},${j}`);\n            queue.push([i\
    \ - 1, j, [...path, grid[i - 1][j]]]);\n        }\n        if (i < n - 1 && !visited.has(`${i\
    \ + 1},${j}`)) {\n            visited.add(`${i + 1},${j}`);\n            queue.push([i\
    \ + 1, j, [...path, grid[i + 1][j]]]);\n        }\n        if (j > 0 && !visited.has(`${i},${j\
    \ - 1}`)) {\n            visited.add(`${i},${j - 1}`);\n            queue.push([i,\
    \ j - 1, [...path, grid[i][j - 1]]]);\n        }\n        if (j < n - 1 && !visited.has(`${i},${j\
    \ + 1}`)) {\n            visited.add(`${i},${j + 1}`);\n            queue.push([i,\
    \ j + 1, [...path, grid[i][j + 1]]]);\n        }\n    }\n    return [];\n}\n",
  "    let N = grid.length;\n    let visited = new Array(N);\n    for (let i = 0;\
    \ i < N; i++) {\n        visited[i] = new Array(N).fill(false);\n    }\n    let\
    \ minPath = [];\n    let minValue = Infinity;\n    for (let i = 0; i < N; i++)\
    \ {\n        for (let j = 0; j < N; j++) {\n            let path = [];\n     \
    \       let value = dfs(grid, visited, i, j, k, path);\n            if (value\
    \ < minValue) {\n                minValue = value;\n                minPath =\
    \ path;\n            }\n        }\n    }\n    return minPath;\n}\n", "    // your\
    \ code goes here\n    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ dp: number[][][] = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n\
    \        for (let j = 0; j < m; j++) {\n            dp[i][j] = [];\n         \
    \   for (let l = 0; l < k; l++) {\n                dp[i][j][l] = -1;\n       \
    \     }\n        }\n    }\n    let min = Number.MAX_SAFE_INTEGER;\n    let minPath:\
    \ number[] = [];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            let path = findPath(grid, dp, i, j, k);\n         \
    \   if (path < min) {\n                min = path;\n                minPath =\
    \ dp[i][j];\n            }\n        }\n    }\n    return minPath;\n}\n", "   \
    \ // your code here\n    return [];\n}\n", "    // your code here\n    return\
    \ [];\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new\
    \ Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let\
    \ minPath3 = [];\n    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n\
    \    let minPath4 = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];", "    const n = grid.length;\n    const m = grid[0].length;\n\
    \    const visited = new Set<string>();\n    const queue = new PriorityQueue<[number[],\
    \ number[]]>((a, b) => {\n        for (let i = 0; i < a[1].length; i++) {\n  \
    \          if (a[1][i] < b[1][i]) {\n                return -1;\n            }\
    \ else if (a[1][i] > b[1][i]) {\n                return 1;\n            }\n  \
    \      }\n        return 0;\n    });\n    const start = [0, 0];\n    const startPath\
    \ = [grid[0][0]];\n    queue.enqueue([start, startPath]);\n    visited.add(start.toString());\n\
    \    while (!queue.isEmpty()) {\n        const [curr, path] = queue.dequeue();\n\
    \        if (path.length === k) {\n            return path;\n        }\n     \
    \   const [i, j] = curr;\n        const neighbors = [\n            [i - 1, j],\n\
    \            [i + 1, j],\n            [i, j - 1],\n            [i, j + 1],\n \
    \       ];\n        for (const [ni, nj] of neighbors) {\n            if (ni >=\
    \ 0 && ni < n && nj >= 0 && nj < m && !visited.has([ni, nj].toString())) {\n \
    \               const newPath = [...path, grid[ni][nj]];\n                queue.enqueue([[ni,\
    \ nj], newPath]);\n                visited.add([ni, nj].toString());\n       \
    \     }\n        }\n    }\n    return [];\n}\n", "    let n = grid.length;\n \
    \   let m = grid[0].length;\n    let dp = new Array(n).fill(0).map(() => new Array(m).fill(Infinity));\n\
    \    let q = [];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            dp[i][j] = grid[i][j];\n            q.push([i, j]);\n\
    \        }\n    }\n    while (q.length) {\n        let [x, y] = q.shift();\n \
    \       let d = dp[x][y];\n        if (x > 0 && d + grid[x - 1][y] < dp[x - 1][y])\
    \ {\n            dp[x - 1][y] = d + grid[x - 1][y];\n            q.push([x - 1,\
    \ y]);\n        }\n        if (x < n - 1 && d + grid[x + 1][y] < dp[x + 1][y])\
    \ {\n            dp[x + 1][y] = d + grid[x + 1][y];\n            q.push([x + 1,\
    \ y]);\n        }\n        if (y > 0 && d + grid[x][y - 1] < dp[x][y - 1]) {\n\
    \            dp[x][y - 1] = d + grid[x][y - 1];\n            q.push([x, y - 1]);\n\
    \        }\n        if (y < m - 1 && d + grid[x][y + 1] < dp[x][y + 1]) {\n  \
    \          dp[x][y + 1] = d + grid[x][y + 1];\n            q.push([x, y + 1]);\n\
    \        }\n    }\n    let min = Infinity;\n    let res = [];\n    for (let i\
    \ = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (dp[i][j]\
    \ < min) {\n                min = dp[i][j];\n                res = [grid[i][j]];\n\
    \            } else if (", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Set<string>();\n    let minPath = new Array<number>();\n\
    \    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPaths\
    \ = new Array<Array<number>>();\n    let minPathsSum = new Array<number>();\n\
    \    let minPathsVisited = new Array<Set<string>>();\n    let minPathsVisitedSum\
    \ = new Array<number>();\n    let minPathsVisitedSumIndex = new Array<number>();\n\
    \    let minPathsVisitedSumIndexSum = new Array<number>();\n    let minPathsVisitedSumIndexSumIndex\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSum = new Array<number>();\n\
    \    let minPathsVisitedSumIndexSumIndexSumIndex = new Array<number>();\n    let\
    \ minPathsVisitedSumIndexSumIndexSumIndexSum = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndex\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndexSum\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = new Array<number>();\n    let minPathsVisitedSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = new Array<number", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp: number[][][] = [];\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            dp[i][j] = [];\n \
    \           for (let l = 0; l < k; l++) {\n                dp[i][j][l] = -1;\n\
    \            }\n        }\n    }\n    let minPath = (i: number, j: number, l:\
    \ number): number[] => {\n        if (l === 0) {\n            return [grid[i][j]];\n\
    \        }\n        if (dp[i][j][l] !== -1) {\n            return dp[i][j][l];\n\
    \        }\n        let min = [];\n        if (i > 0) {\n            let path\
    \ = minPath(i - 1, j, l - 1);\n            if (min.length === 0 || path < min)\
    \ {\n                min = path;\n            }\n        }\n        if (i < n\
    \ - 1) {\n            let path = minPath(i + 1, j, l - 1);\n            if (min.length\
    \ === 0 || path < min) {\n                min = path;\n            }\n       \
    \ }\n        if (j > 0) {\n            let path = minPath(i, j - 1, l - 1);\n\
    \            if (min.length === 0 || path < min) {\n                min = path;\n\
    \            }\n        }\n        if (j < m - 1) {\n            let path = minPath(i,\
    \ j + 1, l - 1);\n            if (min.length === 0 || path < min) {\n        \
    \        min = path;\n            }\n        }\n        min.unshift(grid[i][j]);\n\
    \        dp[i][j][l] = min;\n        return min;\n    }\n    return minPath(0,\
    \ 0, k - 1);\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n \
    \   let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPathSum10 = Infinity;\n    let minPathSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let minPathSum14\
    \ = Infinity;\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPathSum17 = Infinity;\n    let minPathSum18 = Infinity;\n    let minPathSum19\
    \ = Infinity;\n    let minPathSum20 = Infinity;\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPathSum25 = Infinity;\n    let minPathSum26 = Infinity;\n\
    \    let minPathSum27 = Infinity;\n    let minPathSum28 = Infinity;\n    let minPathSum29\
    \ = Infinity;\n    let minPathSum30 = Infinity;\n    let minPathSum31 = Infinity;\n\
    \    let minPathSum32 = Infinity;\n    let minPathSum33 = Infinity;\n    let minPathSum34\
    \ = Infinity;\n    let minPathSum35 = Infinity;\n    let minPathSum36 = Infinity;\n\
    \    let minPathSum37 = Infinity;\n    let minPathSum38 = Infinity;\n    let minPathSum39\
    \ = Infinity;\n    let minPathSum40 = Infinity;\n    let minPathSum41 = Infinity;\n\
    \    let minPathSum42 = Infinity;\n    let minPathSum43 = Infinity;\n    let minPathSum44\
    \ = Infinity;\n    let minPathSum45 = Infinity;\n    let minPathSum46 = Infinity;\n\
    \    let minPathSum47 = Infinity;\n    let minPathSum48 =", "    let minPath:\
    \ number[] = [];\n    let minSum: number = Infinity;\n    let minPaths: number[][]\
    \ = [];\n    let minPathsSum: number[] = [];\n    let minPathsSumIndex: number[]\
    \ = [];\n    let minPathsSumIndexIndex: number[] = [];\n    let minPathsSumIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndex: number[] = [];\n  \
    \  let minPathsSumIndexIndexIndexIndexIndex: number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndex: number[]\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex:\
    \ number[] = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex",
  "    let result: number[] = [];\n    let min: number = Number.MAX_SAFE_INTEGER;\n\
    \    let minPath: number[] = [];\n    let visited: boolean[][] = [];\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        visited[i] = [];\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            visited[i][j] = false;\n    \
    \    }\n    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j\
    \ = 0; j < grid[i].length; j++) {\n            let path: number[] = [];\n    \
    \        let sum: number = 0;\n            dfs(grid, i, j, k, visited, path, sum);\n\
    \            if (sum < min) {\n                min = sum;\n                minPath\
    \ = path;\n            }\n        }\n    }\n    return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n    let\
    \ minSum = Infinity;\n    let minPaths = [];\n    let visited = new Set();\n \
    \   function dfs(i: number, j: number, path: number[], sum: number) {\n      \
    \  if (visited.has(`${i}-${j}`)) {\n            return;\n        }\n        visited.add(`${i}-${j}`);\n\
    \        path.push(grid[i][j]);\n        sum += grid[i][j];\n        if (path.length\
    \ === k) {\n            if (sum < minSum) {\n                minSum = sum;\n \
    \               minPath = path.slice();\n                minPaths = [];\n    \
    \        } else if (sum === minSum) {\n                minPaths.push(path.slice());\n\
    \            }\n            path.pop();\n            visited.delete(`${i}-${j}`);\n\
    \            return;\n        }\n        if (i > 0) {\n            dfs(i - 1,\
    \ j, path, sum);\n        }\n        if (i < n - 1) {\n            dfs(i + 1,\
    \ j, path, sum);\n        }\n        if (j > 0) {\n            dfs(i, j - 1, path,\
    \ sum);\n        }\n        if (j < m - 1) {\n            dfs(i, j + 1, path,\
    \ sum);\n        }\n        path.pop();\n        visited.delete(`${i}-${j}`);\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dfs(i, j, [], 0);\n        }\n    }\n    if (minPaths.length\
    \ === 0) {\n        return minPath;\n    }\n    minPaths.push(minPath);\n    minPaths.sort((a,\
    \ b) => {\n        for (let i = 0; i < k; i++) {\n            if (a[i] < b[i])\
    \ {\n                return -1;\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp: number[][][] = [];\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = [];\n        for (let j = 0; j < m; j++) {\n            dp[i][j] = [];\n \
    \           for (let l = 0; l < k; l++) {\n                dp[i][j][l] = -1;\n\
    \            }\n        }\n    }\n    let min = Number.MAX_VALUE;\n    let minPath:\
    \ number[] = [];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < m; j++) {\n            let path = getMinPath(i, j, k);\n            if (path.length\
    \ > 0 && path[0] < min) {\n                min = path[0];\n                minPath\
    \ = path;\n            }\n        }\n    }\n    return minPath;\n\n    function\
    \ getMinPath(i: number, j: number, k: number): number[] {\n        if (k == 0)\
    \ {\n            return [];\n        }\n        if (i < 0 || i >= n || j < 0 ||\
    \ j >= m) {\n            return [];\n        }\n        if (dp[i][j][k - 1] !=\
    \ -1) {\n            return dp[i][j][k - 1];\n        }\n        let min = Number.MAX_VALUE;\n\
    \        let minPath: number[] = [];\n        let path = getMinPath(i - 1, j,\
    \ k - 1);\n        if (path.length > 0 && path[0] < min) {\n            min =\
    \ path[0];\n            minPath = path;\n        }\n        path = getMinPath(i\
    \ + 1, j, k - 1);\n        if (path.length > 0 && path[0] < min) {\n         \
    \   min = path[0];\n            minPath = path;\n        }\n        path = getMinPath(i,\
    \ j - 1, k - 1);\n        if (path.length > 0 && path[0] < min) {\n          \
    \  min", "    const n = grid.length;\n    const m = grid[0].length;\n    const\
    \ visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    const path = [];\n    let minPath =\
    \ [];\n    function dfs(i: number, j: number, path: number[]) {\n        if (path.length\
    \ === k) {\n            if (minPath.length === 0 || path.join('') < minPath.join(''))\
    \ {\n                minPath = path.slice();\n            }\n            return;\n\
    \        }\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        dfs(i - 1, j, path);\n        dfs(i + 1, j, path);\n        dfs(i, j\
    \ - 1, path);\n        dfs(i, j + 1, path);\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dfs(i, j, path);\n        }\n    }\n    return minPath;\n\
    }\n", "    const n = grid.length;\n    const m = grid[0].length;\n    const dp\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(0).map(() => new Array(k\
    \ + 1).fill(Infinity)));\n    const path = new Array(n).fill(0).map(() => new\
    \ Array(m).fill(0).map(() => new Array(k + 1).fill(0)));\n    for (let i = 0;\
    \ i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1] = grid[i][j];\n        }\n    }\n \
    \   for (let i = 1; i <= k; i++) {\n        for (let j = 0; j < n; j++) {\n  \
    \          for (let l = 0; l < m; l++) {\n                for (let p = 0; p <\
    \ 4; p++) {\n                    const x = j + dx[p];\n                    const\
    \ y = l + dy[p];\n                    if (x < 0 || x >= n || y < 0 || y >= m)\
    \ {\n                        continue;\n                    }\n              \
    \      if (dp[x][y][i - 1] + grid[j][l] < dp[j][l][i]) {\n                   \
    \     dp[j][l][i] = dp[x][y][i - 1] + grid[j][l];\n                        path[j][l][i]\
    \ = grid[j][l];\n                    }\n                }\n            }\n   \
    \     }\n    }\n    let min = Infinity;\n    let minI = 0;\n    let minJ = 0;\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          if (dp[i][j][k] < min) {\n                min = dp[i][j][k];\n    \
    \            minI = i;\n                minJ = j;\n            }\n        }\n\
    \    }\n    const result = [path[minI][minJ][k]", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n\
    \    let minPath = new Array(k);\n    let minPathSum = Infinity;\n    let minPathSumIndex\
    \ = -1;\n    let dfs = (i: number, j: number, path: number[], pathSum: number,\
    \ pathSumIndex: number) => {\n        if (path.length === k) {\n            if\
    \ (pathSum < minPathSum) {\n                minPathSum = pathSum;\n          \
    \      minPathSumIndex = pathSumIndex;\n                for (let i = 0; i < k;\
    \ i++) {\n                    minPath[i] = path[i];\n                }\n     \
    \       }\n            return;\n        }\n        if (i < 0 || i >= n || j <\
    \ 0 || j >= m || visited[i][j]) {\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path[path.length] = grid[i][j];\n        pathSum += grid[i][j];\n\
    \        pathSumIndex += grid[i][j] * Math.pow(10, k - path.length);\n       \
    \ dfs(i - 1, j, path, pathSum, pathSumIndex);\n        dfs(i + 1, j, path, pathSum,\
    \ pathSumIndex);\n        dfs(i, j - 1, path, pathSum, pathSumIndex);\n      \
    \  dfs(i, j + 1, path, pathSum, pathSumIndex);\n        path.pop();\n        pathSum\
    \ -= grid[i][j];\n        pathSumIndex -= grid[i][j] * Math.pow(10, k - path.length);\n\
    \        visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n \
    \       for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0, 0);\n    \
    \    }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let path: number[] = [];\n    let minPath: number[] =\
    \ [];\n    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let\
    \ minPathSum3 = Infinity;\n    let minPathSum4 = Infinity;\n    let minPathSum5\
    \ = Infinity;\n    let minPathSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPathSum8 = Infinity;\n    let minPathSum9 = Infinity;\n    let minPathSum10\
    \ = Infinity;\n    let minPathSum11 = Infinity;\n    let minPathSum12 = Infinity;\n\
    \    let minPathSum13 = Infinity;\n    let minPathSum14 = Infinity;\n    let minPathSum15\
    \ = Infinity;\n    let minPathSum16 = Infinity;\n    let minPathSum17 = Infinity;\n\
    \    let minPathSum18 = Infinity;\n    let minPathSum19 = Infinity;\n    let minPathSum20\
    \ = Infinity;\n    let minPathSum21 = Infinity;\n    let minPathSum22 = Infinity;\n\
    \    let minPathSum23 = Infinity;\n    let minPathSum24 = Infinity;\n    let minPathSum25\
    \ = Infinity;\n    let minPathSum26 = Infinity;\n    let minPathSum27 = Infinity;\n\
    \    let minPathSum28 = Infinity;\n    let minPathSum29 = Infinity;\n    let minPathSum30\
    \ = Infinity;\n    let minPathSum31 = Infinity;\n    let minPathSum32 = Infinity;\n\
    \    let minPathSum33 = Infinity;\n    let minPathSum34 = Infinity;\n    let minPathSum35\
    \ = Infinity;\n    let minPathSum36 = Infinity;\n    let minPathSum37 = Infinity;\n\
    \    let minPathSum38 = Infinity;\n    let minPathSum39 = Infinity;\n    let minPathSum40\
    \ = Infinity;\n    let minPathSum41 = Infinity;\n    let minPathSum42 = Infinity;\n\
    \    let minPathSum43 = Infinity;\n    let minPathSum44 = Infinity;\n    let minPathSum45\
    \ = Infinity;\n    let minPathSum46 = Infinity;\n    let minPathSum47 = Infinity;\n\
    \    let min", "    const n = grid.length;\n    const m = grid[0].length;\n  \
    \  const dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i]\
    \ = new Array(m);\n        for (let j = 0; j < m; j++) {\n            dp[i][j]\
    \ = new Array(k + 1);\n            for (let l = 0; l <= k; l++) {\n          \
    \      dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] = Number.MAX_SAFE_INTEGER;\n\
    \                dp[i][j][l][1] = [];\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dp[i][j][1][0] = grid[i][j];\n            dp[i][j][1][1] = [grid[i][j]];\n\
    \        }\n    }\n    for (let l = 2; l <= k; l++) {\n        for (let i = 0;\
    \ i < n; i++) {\n            for (let j = 0; j < m; j++) {\n                for\
    \ (let di = -1; di <= 1; di++) {\n                    for (let dj = -1; dj <=\
    \ 1; dj++) {\n                        if (di === 0 && dj === 0) {\n          \
    \                  continue;\n                        }\n                    \
    \    const ni = i + di;\n                        const nj = j + dj;\n        \
    \                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {\n             \
    \               continue;\n                        }\n                       \
    \ const curr = dp[i][j][l][0];\n                        const next = dp[ni][nj][l\
    \ - 1][0];\n                        if (curr > next) {\n                     \
    \       dp[i][j][l][0] = next;\n                            dp[i][j][l][1] = [grid[i][j]].concat(dp[ni][nj][l\
    \ - 1][1]);\n                       ", "    const n = grid.length;\n    const\
    \ m = grid[0].length;\n    const visited = Array(n).fill(0).map(() => Array(m).fill(false));\n\
    \    const queue = [];\n    const result = [];\n    let min = Infinity;\n    let\
    \ minPath = [];\n    queue.push({\n        x: 0,\n        y: 0,\n        path:\
    \ [grid[0][0]],\n        length: 1\n    });\n    while (queue.length) {\n    \
    \    const { x, y, path, length } = queue.shift();\n        if (length > k) {\n\
    \            break;\n        }\n        if (x === n - 1 && y === m - 1) {\n  \
    \          if (length < min) {\n                min = length;\n              \
    \  minPath = path;\n            } else if (length === min) {\n               \
    \ if (path.join('') < minPath.join('')) {\n                    minPath = path;\n\
    \                }\n            }\n            continue;\n        }\n        if\
    \ (x + 1 < n && !visited[x + 1][y]) {\n            visited[x + 1][y] = true;\n\
    \            queue.push({\n                x: x + 1,\n                y,\n   \
    \             path: [...path, grid[x + 1][y]],\n                length: length\
    \ + 1\n            });\n        }\n        if (y + 1 < m && !visited[x][y + 1])\
    \ {\n            visited[x][y + 1] = true;\n            queue.push({\n       \
    \         x,\n                y: y + 1,\n                path: [...path, grid[x][y\
    \ + 1]],\n                length: length + 1\n            });\n        }\n   \
    \     if (x - 1 >= 0 && !visited[x - 1][y]) {\n            visited[x - 1][y] =\
    \ true;\n            queue.push({\n                x: x - 1,\n               \
    \ y,\n                path: [...path, grid[x - 1][y]],\n                length:\
    \ length + 1\n            });\n        }\n        if (y - 1 >= 0 && !visited[x][y\
    \ - 1]) {\n            visited[x", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n\
    \    let visited = new Set();\n    let dfs = (i: number, j: number, path: number[],\
    \ sum: number) => {\n        if (sum > minSum) {\n            return;\n      \
    \  }\n        if (path.length === k) {\n            if (sum < minSum) {\n    \
    \            minSum = sum;\n                minSumPath = path;\n            }\n\
    \            return;\n        }\n        if (i < 0 || i >= n || j < 0 || j >=\
    \ m) {\n            return;\n        }\n        if (visited.has(`${i}_${j}`))\
    \ {\n            return;\n        }\n        visited.add(`${i}_${j}`);\n     \
    \   dfs(i + 1, j, [...path, grid[i][j]], sum + grid[i][j]);\n        dfs(i - 1,\
    \ j, [...path, grid[i][j]], sum + grid[i][j]);\n        dfs(i, j + 1, [...path,\
    \ grid[i][j]], sum + grid[i][j]);\n        dfs(i, j - 1, [...path, grid[i][j]],\
    \ sum + grid[i][j]);\n        visited.delete(`${i}_${j}`);\n    }\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minSumPath;\n}\n", "    const n = grid.length;\n\
    \    const m = grid[0].length;\n    const visited = new Set<string>();\n    const\
    \ queue = new PriorityQueue<[number[], number[]]>((a, b) => {\n        for (let\
    \ i = 0; i < a[1].length; i++) {\n            if (a[1][i] < b[1][i]) {\n     \
    \           return -1;\n            } else if (a[1][i] > b[1][i]) {\n        \
    \        return 1;\n            }\n        }\n        return 0;\n    });\n   \
    \ const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    queue.push([[0, 0], [grid[0][0]]]);\n\
    \    while (!queue.isEmpty()) {\n        const [curr, path] = queue.pop();\n \
    \       if (path.length === k) {\n            return path;\n        }\n      \
    \  for (const dir of dirs) {\n            const [x, y] = [curr[0] + dir[0], curr[1]\
    \ + dir[1]];\n            if (x < 0 || x >= n || y < 0 || y >= m || visited.has(`${x},${y}`))\
    \ {\n                continue;\n            }\n            visited.add(`${x},${y}`);\n\
    \            queue.push([[x, y], [...path, grid[x][y]]]);\n        }\n    }\n\
    \    return [];\n}\n", "    const n = grid.length;\n    const m = grid[0].length;\n\
    \    const dp: number[][][] = [];\n    const path: number[][][] = [];\n    for\
    \ (let i = 0; i < n; i++) {\n        dp[i] = [];\n        path[i] = [];\n    \
    \    for (let j = 0; j < m; j++) {\n            dp[i][j] = [];\n            path[i][j]\
    \ = [];\n            for (let l = 0; l < k; l++) {\n                dp[i][j][l]\
    \ = Infinity;\n                path[i][j][l] = -1;\n            }\n        }\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dp[i][j][0] = grid[i][j];\n        }\n    }\n    for (let l =\
    \ 1; l < k; l++) {\n        for (let i = 0; i < n; i++) {\n            for (let\
    \ j = 0; j < m; j++) {\n                for (let di = -1; di <= 1; di++) {\n \
    \                   for (let dj = -1; dj <= 1; dj++) {\n                     \
    \   if (di * di + dj * dj === 1) {\n                            const ni = i +\
    \ di;\n                            const nj = j + dj;\n                      \
    \      if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                       \
    \         if (dp[ni][nj][l - 1] < dp[i][j][l]) {\n                           \
    \         dp[i][j][l] = dp[ni][nj][l - 1];\n                                 \
    \   path[i][j][l] = ni * m + nj;\n                                }\n        \
    \                    }\n                        }\n                    }\n   \
    \             }\n            }\n        }\n    }\n    let min = Infinity;\n  \
    \  let minI = -1;\n    let minJ = -1;\n    for (let i = 0; i < n; i++) {\n   \
    \     for (let j = 0", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minPathSum = Infinity;\n    let minPathSum2 =\
    \ Infinity;\n    let minPath2 = [];\n    let minPathSum3 = Infinity;\n    let\
    \ minPath3 = [];\n    let minPathSum4 = Infinity;\n    let minPath4 = [];\n  \
    \  let minPathSum5 = Infinity;\n    let minPath5 = [];\n    let minPathSum6 =\
    \ Infinity;\n    let minPath6 = [];\n    let minPathSum7 = Infinity;\n    let\
    \ minPath7 = [];\n    let minPathSum8 = Infinity;\n    let minPath8 = [];\n  \
    \  let minPathSum9 = Infinity;\n    let minPath9 = [];\n    let minPathSum10 =\
    \ Infinity;\n    let minPath10 = [];\n    let minPathSum11 = Infinity;\n    let\
    \ minPath11 = [];\n    let minPathSum12 = Infinity;\n    let minPath12 = [];\n\
    \    let minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minPathSum14\
    \ = Infinity;\n    let minPath14 = [];\n    let minPathSum15 = Infinity;\n   \
    \ let minPath15 = [];\n    let minPathSum16 = Infinity;\n    let minPath16 = [];\n\
    \    let minPathSum17 = Infinity;\n    let minPath17 = [];\n    let minPathSum18\
    \ = Infinity;\n    let minPath18 = [];\n    let minPathSum19 = Infinity;\n   \
    \ let minPath19 = [];\n    let minPathSum20 = Infinity;\n    let minPath20 = [];\n\
    \    let minPathSum21 = Infinity;\n    let minPath21 = [];\n    let minPathSum22\
    \ = Infinity;\n    let minPath22 = [];\n    let minPathSum23 = Infinity;\n   \
    \ let minPath23 = [];\n    let minPathSum24 = Infinity;\n    let minPath24 = [];\n\
    \    let minPathSum25 = Infinity;\n    let minPath25 = [];\n    let minPathSum26\
    \ = Infinity;\n    let minPath26 = [];\n    let minPathSum27 = Infinity;\n   \
    \ let minPath27 = [];\n    let minPathSum28 =", "    let n = grid.length;\n  \
    \  let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i =\
    \ 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n  \
    \  let minPath = new Array(k);\n    let minPathSum = Infinity;\n    let minPathSum2\
    \ = Infinity;\n    let minPath2 = new Array(k);\n    let dfs = function (i: number,\
    \ j: number, path: number[], pathSum: number, pathSum2: number, path2: number[],\
    \ pathLen: number) {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]\
    \ || pathLen > k) {\n            return;\n        }\n        visited[i][j] = true;\n\
    \        path[pathLen] = grid[i][j];\n        pathSum += grid[i][j];\n       \
    \ pathSum2 += grid[i][j] * grid[i][j];\n        path2[pathLen] = grid[i][j];\n\
    \        if (pathLen === k) {\n            if (pathSum < minPathSum || (pathSum\
    \ === minPathSum && pathSum2 < minPathSum2)) {\n                minPathSum = pathSum;\n\
    \                minPathSum2 = pathSum2;\n                minPath = path.slice();\n\
    \                minPath2 = path2.slice();\n            }\n        } else {\n\
    \            dfs(i - 1, j, path, pathSum, pathSum2, path2, pathLen + 1);\n   \
    \         dfs(i + 1, j, path, pathSum, pathSum2, path2, pathLen + 1);\n      \
    \      dfs(i, j - 1, path, pathSum, pathSum2, path2, pathLen + 1);\n         \
    \   dfs(i, j + 1, path, pathSum, pathSum2, path2, pathLen + 1);\n        }\n \
    \       visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n  \
    \      for (let j = 0; j < m; j++) {\n            d", "    let N = grid.length;\n\
    \    let M = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let visited = [];\n\
    \    for (let i = 0; i < N; i++) {\n        visited[i] = [];\n        for (let\
    \ j = 0; j < M; j++) {\n            visited[i][j] = false;\n        }\n    }\n\
    \    let path = [];\n    let pathSum = 0;\n    let pathSum2 = 0;\n    let path2\
    \ = [];\n    function dfs(i: number, j: number, k: number) {\n        if (k ===\
    \ 0) {\n            if (pathSum < minPathSum) {\n                minPathSum =\
    \ pathSum;\n                minPath = path.slice();\n            } else if (pathSum\
    \ === minPathSum) {\n                if (pathSum2 < minPathSum2) {\n         \
    \           minPathSum2 = pathSum2;\n                    minPath2 = path2.slice();\n\
    \                }\n            }\n            return;\n        }\n        if\
    \ (i < 0 || i >= N || j < 0 || j >= M || visited[i][j]) {\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n  \
    \      pathSum += grid[i][j];\n        path2.push(grid[i][j]);\n        pathSum2\
    \ += grid[i][j];\n        dfs(i - 1, j, k - 1);\n        dfs(i + 1, j, k - 1);\n\
    \        dfs(i, j - 1, k - 1);\n        dfs(i, j + 1, k - 1);\n        path.pop();\n\
    \        pathSum -= grid[i][j];\n        path2.pop();\n        pathSum2 -= grid[i][j];\n\
    \        visited[i][j] = false;\n    }\n    for (let i = 0; i < N; i++) {\n  \
    \      for (let j = 0; j < M; j++) {\n            dfs(i, j,", "    let N = grid.length;\n\
    \    let minPath: number[] = [];\n    let minPathSum = Infinity;\n    let visited:\
    \ boolean[][] = [];\n    for (let i = 0; i < N; i++) {\n        visited[i] = [];\n\
    \        for (let j = 0; j < N; j++) {\n            visited[i][j] = false;\n \
    \       }\n    }\n    function dfs(i: number, j: number, path: number[], pathSum:\
    \ number) {\n        if (path.length === k) {\n            if (pathSum < minPathSum)\
    \ {\n                minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n            return;\n        }\n        if (pathSum > minPathSum)\
    \ {\n            return;\n        }\n        visited[i][j] = true;\n        if\
    \ (i > 0 && !visited[i - 1][j]) {\n            dfs(i - 1, j, path.concat(grid[i\
    \ - 1][j]), pathSum + grid[i - 1][j]);\n        }\n        if (i < N - 1 && !visited[i\
    \ + 1][j]) {\n            dfs(i + 1, j, path.concat(grid[i + 1][j]), pathSum +\
    \ grid[i + 1][j]);\n        }\n        if (j > 0 && !visited[i][j - 1]) {\n  \
    \          dfs(i, j - 1, path.concat(grid[i][j - 1]), pathSum + grid[i][j - 1]);\n\
    \        }\n        if (j < N - 1 && !visited[i][j + 1]) {\n            dfs(i,\
    \ j + 1, path.concat(grid[i][j + 1]), pathSum + grid[i][j + 1]);\n        }\n\
    \        visited[i][j] = false;\n    }\n    for (let i = 0; i < N; i++) {\n  \
    \      for (let j = 0; j < N; j++) {\n            dfs(i, j, [grid[i][j]], grid[i][j]);\n\
    \        }\n    }\n    return", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n\
    \    let minPathSum3 = Infinity;\n    let minPathSum4 = Infinity;\n    let minPathSum5\
    \ = Infinity;\n    let minPathSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPathSum8 = Infinity;\n    let minPathSum9 = Infinity;\n    let minPathSum10\
    \ = Infinity;\n    let minPathSum11 = Infinity;\n    let minPathSum12 = Infinity;\n\
    \    let minPathSum13 = Infinity;\n    let minPathSum14 = Infinity;\n    let minPathSum15\
    \ = Infinity;\n    let minPathSum16 = Infinity;\n    let minPathSum17 = Infinity;\n\
    \    let minPathSum18 = Infinity;\n    let minPathSum19 = Infinity;\n    let minPathSum20\
    \ = Infinity;\n    let minPathSum21 = Infinity;\n    let minPathSum22 = Infinity;\n\
    \    let minPathSum23 = Infinity;\n    let minPathSum24 = Infinity;\n    let minPathSum25\
    \ = Infinity;\n    let minPathSum26 = Infinity;\n    let minPathSum27 = Infinity;\n\
    \    let minPathSum28 = Infinity;\n    let minPathSum29 = Infinity;\n    let minPathSum30\
    \ = Infinity;\n    let minPathSum31 = Infinity;\n    let minPathSum32 = Infinity;\n\
    \    let minPathSum33 = Infinity;\n    let minPathSum34 = Infinity;\n    let minPathSum35\
    \ = Infinity;\n    let minPathSum36 = Infinity;\n    let minPathSum37 = Infinity;\n\
    \    let minPathSum38 = Infinity;\n    let minPathSum39 = Infinity;\n    let minPathSum40\
    \ = Infinity;\n    let minPathSum41 = Infinity;\n    let minPathSum42 = Infinity;\n\
    \    let minPathSum43 = Infinity;\n    let", "    const n = grid.length;\n   \
    \ const m = grid[0].length;\n    const visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(false));\n    const queue = [];\n    const result = [];\n\
    \    let min = Infinity;\n    let minPath = [];\n    let minPaths = [];\n    let\
    \ minPaths2 = [];\n    let minPaths3 = [];\n    let minPaths4 = [];\n    let minPaths5\
    \ = [];\n    let minPaths6 = [];\n    let minPaths7 = [];\n    let minPaths8 =\
    \ [];\n    let minPaths9 = [];\n    let minPaths10 = [];\n    let minPaths11 =\
    \ [];\n    let minPaths12 = [];\n    let minPaths13 = [];\n    let minPaths14\
    \ = [];\n    let minPaths15 = [];\n    let minPaths16 = [];\n    let minPaths17\
    \ = [];\n    let minPaths18 = [];\n    let minPaths19 = [];\n    let minPaths20\
    \ = [];\n    let minPaths21 = [];\n    let minPaths22 = [];\n    let minPaths23\
    \ = [];\n    let minPaths24 = [];\n    let minPaths25 = [];\n    let minPaths26\
    \ = [];\n    let minPaths27 = [];\n    let minPaths28 = [];\n    let minPaths29\
    \ = [];\n    let minPaths30 = [];\n    let minPaths31 = [];\n    let minPaths32\
    \ = [];\n    let minPaths33 = [];\n    let minPaths34 = [];\n    let minPaths35\
    \ = [];\n    let minPaths36 = [];\n    let minPaths37 = [];\n    let minPaths38\
    \ = [];\n    let minPaths39 = [];\n    let minPaths40 = [];\n    let minPaths41\
    \ = [];\n    let minPaths42 = [];\n    let minPaths43 = [];\n    let minPaths44\
    \ = [];\n    let minPaths45 = [];\n    let minPaths46 = [];\n    let minPaths47\
    \ = [];\n    let minPaths48 = [];\n    let minPaths49 =", "    const n = grid.length;\n\
    \    const m = grid[0].length;\n    const visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    const queue = [];\n    queue.push([0, 0,\
    \ 0, [grid[0][0]]]);\n    visited[0][0] = true;\n    let minPath = null;\n   \
    \ while (queue.length > 0) {\n        const [i, j, pathLen, path] = queue.shift();\n\
    \        if (pathLen === k) {\n            if (minPath === null || path < minPath)\
    \ {\n                minPath = path;\n            }\n            continue;\n \
    \       }\n        if (i > 0 && !visited[i - 1][j]) {\n            visited[i -\
    \ 1][j] = true;\n            queue.push([i - 1, j, pathLen + 1, [...path, grid[i\
    \ - 1][j]]]);\n        }\n        if (i < n - 1 && !visited[i + 1][j]) {\n   \
    \         visited[i + 1][j] = true;\n            queue.push([i + 1, j, pathLen\
    \ + 1, [...path, grid[i + 1][j]]]);\n        }\n        if (j > 0 && !visited[i][j\
    \ - 1]) {\n            visited[i][j - 1] = true;\n            queue.push([i, j\
    \ - 1, pathLen + 1, [...path, grid[i][j - 1]]]);\n        }\n        if (j < m\
    \ - 1 && !visited[i][j + 1]) {\n            visited[i][j + 1] = true;\n      \
    \      queue.push([i, j + 1, pathLen + 1, [...path, grid[i][j + 1]]]);\n     \
    \   }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let minPath: number[] = [];\n    let minPathSum = Infinity;\n\
    \    let visited: boolean[][] = [];\n    for (let i = 0; i < n; i++) {\n     \
    \   visited[i] = [];\n        for (let j = 0; j < m; j++) {\n            visited[i][j]\
    \ = false;\n        }\n    }\n    function dfs(i: number, j: number, path: number[],\
    \ pathSum: number) {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j])\
    \ {\n            return;\n        }\n        path.push(grid[i][j]);\n        pathSum\
    \ += grid[i][j];\n        if (path.length === k) {\n            if (pathSum <\
    \ minPathSum) {\n                minPathSum = pathSum;\n                minPath\
    \ = path.slice();\n            }\n            path.pop();\n            return;\n\
    \        }\n        visited[i][j] = true;\n        dfs(i - 1, j, path, pathSum);\n\
    \        dfs(i + 1, j, path, pathSum);\n        dfs(i, j - 1, path, pathSum);\n\
    \        dfs(i, j + 1, path, pathSum);\n        visited[i][j] = false;\n     \
    \   path.pop();\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j\
    \ = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let minPath = [];\n    let minPathSum = Infinity;\n    let visited = [];\n \
    \   for (let i = 0; i < n; i++) {\n        visited[i] = [];\n        for (let\
    \ j = 0; j < m; j++) {\n            visited[i][j] = false;\n        }\n    }\n\
    \    function dfs(i: number, j: number, path: number[], pathSum: number) {\n \
    \       if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n         \
    \   return;\n        }\n        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n\
    \        if (path.length === k) {\n            if (pathSum < minPathSum) {\n \
    \               minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n            path.pop();\n            return;\n        }\n    \
    \    visited[i][j] = true;\n        dfs(i - 1, j, path, pathSum);\n        dfs(i\
    \ + 1, j, path, pathSum);\n        dfs(i, j - 1, path, pathSum);\n        dfs(i,\
    \ j + 1, path, pathSum);\n        visited[i][j] = false;\n        path.pop();\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n  \
    \  let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minPathSum8 =\
    \ Infinity;\n    let minPath8 = [];\n    let minPathSum9 = Infinity;\n    let\
    \ minPath9 = [];\n    let minPathSum10 = Infinity;\n    let minPath10 = [];\n\
    \    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPathSum13 = Infinity;\n   \
    \ let minPath13 = [];\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n\
    \    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPathSum17 = Infinity;\n   \
    \ let minPath17 = [];\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n\
    \    let minPathSum19 = Infinity;\n    let minPath19 = [];\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPathSum21 = Infinity;\n   \
    \ let minPath21 = [];\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n\
    \    let minPathSum23 = Infinity;\n    let minPath23 = [];\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPathSum25 = Infinity;\n   \
    \ let minPath25 = [];\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n\
    \    let minPathSum27 = Infinity;\n    let minPath27 = [];\n    let minPathSum28\
    \ =", "    let n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n\
    \    let minSum = Infinity;\n    let minPath = [];\n    let visited = new Set();\n\
    \    function dfs(i: number, j: number, path: number[], sum: number) {\n     \
    \   if (i < 0 || i >= n || j < 0 || j >= m || visited.has(i * m + j)) {\n    \
    \        return;\n        }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        visited.add(i * m + j);\n        if (path.length === k) {\n         \
    \   if (sum < minSum) {\n                minSum = sum;\n                min =\
    \ path.slice();\n            } else if (sum === minSum) {\n                if\
    \ (path.join('') < min.join('')) {\n                    min = path.slice();\n\
    \                }\n            }\n        } else {\n            dfs(i - 1, j,\
    \ path, sum);\n            dfs(i + 1, j, path, sum);\n            dfs(i, j - 1,\
    \ path, sum);\n            dfs(i, j + 1, path, sum);\n        }\n        path.pop();\n\
    \        visited.delete(i * m + j);\n    }\n    for (let i = 0; i < n; i++) {\n\
    \        for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n      \
    \  }\n    }\n    return min;\n}\n", "    let minPath = [];\n    let minSum = Infinity;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            let path = [];\n            let sum = 0;\n            findPath(grid,\
    \ i, j, k, path, sum);\n            if (sum < minSum) {\n                minPath\
    \ = path;\n                minSum = sum;\n            }\n        }\n    }\n  \
    \  return minPath;\n}\n", "    // Your code goes here\n    return [];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
