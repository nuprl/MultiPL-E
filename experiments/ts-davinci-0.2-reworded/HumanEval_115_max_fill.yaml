name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["  let count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n\
    \  let max = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        max = Math.max(max, j);\n   \
    \   }\n    }\n  }\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j <\
    \ col; j++) {\n      if (grid[i][j] === 1) {\n        if (j === max) {\n     \
    \     count += capacity;\n        } else {\n          count += 1;\n        }\n\
    \      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n \
    \ }\n  return count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "  let count = 0;\n  let max = 0;\n  for (let i\
    \ = 0; i < grid.length; i++) {\n    max = Math.max(...grid[i]);\n    if (max >\
    \ 0) {\n      count += max;\n    }\n  }\n  return count * capacity;\n}\n", " \
    \   let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count += capacity;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let result = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        let row = grid[i];\n        let row_sum = row.reduce((a, b) => a\
    \ + b, 0);\n        if (row_sum > capacity) {\n            result += row_sum -\
    \ capacity;\n        }\n    }\n    return result;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n\
    \  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \      }\n    }\n    if (count > max) {\n      max = count;\n    }\n    count\
    \ = 0;\n  }\n  return max * capacity;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] == 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count++;\n            }\n        }\n        if (count > max) {\n\
    \            max = count;\n        }\n        count = 0;\n    }\n    return max\
    \ * capacity;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "  // your code here\n  return 0;\n}\n\nexport\
    \ { max_fill };", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        count += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "   \
    \ let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count += capacity;\n            }\n        }\n    }\n    return\
    \ count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count += capacity;\n            }\n        }\n    }\n    return count;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                grid[i][j] = 0;\n                count++;\n          \
    \      for (let k = 0; k < capacity; k++) {\n                    if (i + k < grid.length\
    \ && grid[i + k][j] === 1) {\n                        grid[i + k][j] = 0;\n  \
    \                      count++;\n                    }\n                    if\
    \ (j + k < grid[i].length && grid[i][j + k] === 1) {\n                       \
    \ grid[i][j + k] = 0;\n                        count++;\n                    }\n\
    \                }\n            }\n        }\n    }\n    return count;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n \
    \ for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n        grid[i][j]\
    \ = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n", "  let count =\
    \ 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1,\
    \ 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let\
    \ row = grid[i];\n    let row_sum = row.reduce((acc, curr) => acc + curr, 0);\n\
    \    if (row_sum > capacity) {\n      count += row_sum - capacity;\n    }\n  }\n\
    \  return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        grid[i][j] = 0;\n        count++;\n        let k = i;\n  \
    \      while (k > 0 && grid[k - 1][j] === 1) {\n          grid[k - 1][j] = 0;\n\
    \          k--;\n        }\n      }\n    }\n  }\n  return count;\n}\n", "    //\
    \ your code here\n    let count = 0;\n    let max = 0;\n    let min = 0;\n   \
    \ let max_index = 0;\n    let min_index = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n            max_index = i;\n        }\n\
    \        if (count < min) {\n            min = count;\n            min_index =\
    \ i;\n        }\n        count = 0;\n    }\n    if (max === 0) {\n        return\
    \ 0;\n    }\n    return max * capacity - min * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                max = Math.max(max, j);\n            }\n        }\n\
    \    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n            if (j === max) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n\
    \  let row = grid.length;\n  let col = grid[0].length;\n  let max = 0;\n  for\
    \ (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count++;\n      }\n    }\n    max = Math.max(max, count);\n\
    \    count = 0;\n  }\n  return max * capacity;\n}\n", "  let count = 0;\n  let\
    \ max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j <\
    \ grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        max = Math.max(max,\
    \ j);\n      }\n    }\n  }\n  for (let i = 0; i < grid.length; i++) {\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n    \
    \    count += capacity;\n      }\n      if (j === max) {\n        count += capacity;\n\
    \      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \            grid[i][j] = 0;\n                for (let k = i + 1; k < grid.length;\
    \ k++) {\n                    if (grid[k][j] === 1) {\n                      \
    \  grid[k][j] = 0;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count * capacity;\n}\n", "  let count = 0;\n  for\
    \ (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_count\
    \ = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n\
    \        row_count++;\n      }\n    }\n    count += Math.ceil(row_count / capacity);\n\
    \  }\n  return count;\n}\n", "    let count = 0;\n    let max_count = 0;\n   \
    \ let max_row = 0;\n    let max_col = 0;\n    let max_row_count = 0;\n    let\
    \ max_col_count = 0;\n    let max_row_col_count = 0;\n    let max_col_row_count\
    \ = 0;\n    let max_row_col_row_count = 0;\n    let max_col_row_col_count = 0;\n\
    \    let max_row_col_row_col_count = 0;\n    let max_col_row_col_row_count = 0;\n\
    \    let max_row_col_row_col_row_count = 0;\n    let max_col_row_col_row_col_count\
    \ = 0;\n    let max_row_col_row_col_row_col_count = 0;\n    let max_col_row_col_row_col_row_count\
    \ = 0;\n    let max_row_col_row_col_row_col_row_count = 0;\n    let max_col_row_col_row_col_row_col_count\
    \ = 0;\n    let max_row_col_row_col_row_col_row_col_count = 0;\n    let max_col_row_col_row_col_row_col_row_count\
    \ = 0;\n    let max_row_col_row_col_row_col_row_col_row_count = 0;\n    let max_col_row_col_row_col_row_col_row_col_count\
    \ = 0;\n    let max_row_col_row_col_row_col_row_col_row_col_count = 0;\n    let\
    \ max_col_row_col_row_col_row_col_row_col_row_count = 0;\n    let max_row_col_row_col_row_col_row_col_row_col_row_count\
    \ = 0;\n    let max_col_row_col_row_col_row_col_row_col_row_col_count = 0;\n \
    \   let max_row_col_row_col_row_col", "  let total = 0;\n  for (let i = 0; i <\
    \ grid.length; i++) {\n    let row = grid[i];\n    let row_total = 0;\n    for\
    \ (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n        row_total\
    \ += 1;\n      }\n    }\n    total += Math.ceil(row_total / capacity);\n  }\n\
    \  return total;\n}\n", "  let count = 0;\n  let max = 0;\n  for (let i = 0; i\
    \ < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n    \
    \  if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n    if (count >\
    \ max) {\n      max = count;\n    }\n    count = 0;\n  }\n  return max * capacity;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "  let count = 0;\n  let row = grid.length;\n\
    \  let col = grid[0].length;\n  let max = 0;\n  let max_index = 0;\n  let max_row\
    \ = 0;\n  let max_col = 0;\n  let max_count = 0;\n  let max_row_count = 0;\n \
    \ let max_col_count = 0;\n  let max_row_index = 0;\n  let max_col_index = 0;\n\
    \  let max_row_index_count = 0;\n  let max_col_index_count = 0;\n  for (let i\
    \ = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count++;\n      }\n    }\n  }\n  while (count > 0) {\n   \
    \ for (let i = 0; i < row; i++) {\n      for (let j = 0; j < col; j++) {\n   \
    \     if (grid[i][j] === 1) {\n          max_row_count++;\n        }\n      }\n\
    \      if (max_row_count > max_row) {\n        max_row = max_row_count;\n    \
    \    max_row_index = i;\n      }\n      max_row_count = 0;\n    }\n    for (let\
    \ i = 0; i < col; i++) {\n      for (let j = 0; j < row; j++) {\n        if (grid[j][i]\
    \ === 1) {\n          max_col_count++;\n        }\n      }\n      if (max_col_count\
    \ > max_col) {\n        max_col = max_col_count;\n        max_col_index = i;\n\
    \      }\n      max_col_count = 0;\n    }\n    if (max_row > max_col) {\n    \
    \  max = max_row;\n      max_index = max_row_index;\n      max_count = max_row_index_count;\n\
    \    } else {\n      max = max_col;\n      max_index = max_col_index;\n      max_count\
    \ =", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
    \    let bucket = capacity;\n    for (let i = 0; i < row; i++) {\n        for\
    \ (let j = 0; j < col; j++) {\n            if (grid[i][j] === 1) {\n         \
    \       if (bucket > 0) {\n                    bucket--;\n                   \
    \ grid[i][j] = 0;\n                } else {\n                    bucket = capacity;\n\
    \                    count++;\n                    j--;\n                }\n \
    \           }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let buckets = new Array(row).fill(0);\n  \
    \  let i = 0;\n    while (i < col) {\n        for (let j = 0; j < row; j++) {\n\
    \            if (grid[j][i] === 1) {\n                buckets[j]++;\n        \
    \        if (buckets[j] > capacity) {\n                    return -1;\n      \
    \          }\n            }\n        }\n        count++;\n        i++;\n    }\n\
    \    return count;\n}\n", "  let count = 0;\n  let max = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n  \
    \    if (grid[i][j] === 1) {\n        max = Math.max(max, j);\n      }\n    }\n\
    \  }\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n        grid[i][j]\
    \ = 0;\n      }\n    }\n    if (i < grid.length - 1) {\n      for (let j = 0;\
    \ j < grid[i].length; j++) {\n        if (grid[i][j] === 0 && grid[i + 1][j] ===\
    \ 1) {\n          count++;\n          grid[i + 1][j] = 0;\n        }\n      }\n\
    \    }\n  }\n  return count;\n}\n", "  let count = 0;\n  let max = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let sum = 0;\n \
    \   for (let j = 0; j < row.length; j++) {\n      sum += row[j];\n    }\n    if\
    \ (sum > max) {\n      max = sum;\n    }\n  }\n  count = max * capacity;\n  return\
    \ count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        count += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j\
    \ < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n\
    \      }\n    }\n  }\n  return count * capacity;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n\
    \  let max = 0;\n  let max_index = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max =\
    \ count;\n      max_index = i;\n    }\n    count = 0;\n  }\n  return max * capacity;\n\
    }\n", "    let count = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
    \    let visited = new Array(row).fill(0).map(() => new Array(col).fill(false));\n\
    \    let queue = [];\n    for (let i = 0; i < row; i++) {\n        for (let j\
    \ = 0; j < col; j++) {\n            if (grid[i][j] === 1 && !visited[i][j]) {\n\
    \                queue.push([i, j]);\n                visited[i][j] = true;\n\
    \                while (queue.length) {\n                    let [x, y] = queue.shift();\n\
    \                    if (grid[x][y] === 1) {\n                        grid[x][y]\
    \ = 0;\n                        count++;\n                    }\n            \
    \        if (x - 1 >= 0 && grid[x - 1][y] === 1 && !visited[x - 1][y]) {\n   \
    \                     queue.push([x - 1, y]);\n                        visited[x\
    \ - 1][y] = true;\n                    }\n                    if (x + 1 < row\
    \ && grid[x + 1][y] === 1 && !visited[x + 1][y]) {\n                        queue.push([x\
    \ + 1, y]);\n                        visited[x + 1][y] = true;\n             \
    \       }\n                    if (y - 1 >= 0 && grid[x][y - 1] === 1 && !visited[x][y\
    \ - 1]) {\n                        queue.push([x, y - 1]);\n                 \
    \       visited[x][y - 1] = true;\n                    }\n                   \
    \ if (y + 1 < col && grid[x][y + 1] === 1 && !visited[x][y + 1]) {\n         \
    \               queue.push([x, y + 1]);\n                        visited[x][y\
    \ + 1] = true;\n                    }\n                }\n            }\n    \
    \    }\n    }\n    return count / capacity;\n}\n", "    let total = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let\
    \ row_total = 0;\n        for (let j = 0; j < row.length; j++) {\n           \
    \ let cell = row[j];\n            if (cell === 1) {\n                row_total\
    \ += 1;\n            }\n        }\n        total += Math.ceil(row_total / capacity);\n\
    \    }\n    return total;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                count += capacity;\n     \
    \       }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n     \
    \   let filled = 0;\n        for (let j = 0; j < row.length; j++) {\n        \
    \    if (row[j] === 1) {\n                filled++;\n            }\n        }\n\
    \        if (filled > 0) {\n            count += Math.ceil(filled / capacity);\n\
    \        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let sum\
    \ = 0;\n        for (let j = 0; j < row.length; j++) {\n            sum += row[j];\n\
    \        }\n        count += Math.ceil(sum / capacity);\n    }\n    return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let result = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_sum\
    \ = row.reduce((a, b) => a + b, 0);\n    if (row_sum > capacity) {\n      result\
    \ += row_sum - capacity;\n    }\n  }\n  return result;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let row = grid[i];\n        let filled = 0;\n        for (let\
    \ j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n           \
    \     filled++;\n            }\n        }\n        if (filled > 0) {\n       \
    \     count += Math.ceil(filled / capacity);\n        }\n    }\n    return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n\
    \    let row = grid.length;\n    let col = grid[0].length;\n    for (let i = 0;\
    \ i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let k = i;\n                while (k < row && grid[k][j] === 0) {\n\
    \                    grid[k][j] = 1;\n                    k++;\n             \
    \   }\n            }\n        }\n    }\n    return count;\n}\n", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count += capacity;\n            }\n        }\n    }\n    return count;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                count += capacity;\n            }\n        }\n    }\n\
    \    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n \
    \ for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "    let count = 0;\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n      \
    \          count += capacity;\n            }\n        }\n    }\n    return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  // your code here\n\
    \  return 0;\n}\n\nexport { max_fill };", "  let count = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n  \
    \    if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n  }\n\
    \  return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  // your code goes here\n  let count = 0;\n  let max = 0;\n  let maxRow\
    \ = 0;\n  let maxCol = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n    \
    \    count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n  \
    \    maxRow = i;\n    }\n    count = 0;\n  }\n  for (let i = 0; i < grid[maxRow].length;\
    \ i++) {\n    if (grid[maxRow][i] === 1) {\n      count++;\n    }\n  }\n  if (count\
    \ > max) {\n    max = count;\n    maxCol = 1;\n  }\n  count = 0;\n  if (maxCol\
    \ === 1) {\n    for (let i = 0; i < grid.length; i++) {\n      if (grid[i][maxRow]\
    \ === 1) {\n        count++;\n      }\n    }\n  } else {\n    for (let i = 0;\
    \ i < grid[maxRow].length; i++) {\n      if (grid[maxRow][i] === 1) {\n      \
    \  count++;\n      }\n    }\n  }\n  return count * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  let max = 0;\n  let maxRow =\
    \ 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n  \
    \  if (count > max) {\n      max = count;\n      maxRow = i;\n    }\n    count\
    \ = 0;\n  }\n  return max * capacity;\n}\n", "  let count = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    let row = grid[i];\n    for (let j = 0; j <\
    \ row.length; j++) {\n      if (row[j] === 1) {\n        count += capacity;\n\
    \      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let count = 0;\n  let max = 0;\n  let max_index = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max\
    \ = count;\n      max_index = i;\n    }\n    count = 0;\n  }\n  return max * capacity;\n\
    }\n", "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max =\
    \ count;\n    }\n    count = 0;\n  }\n  return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let max = 0;\n    for (let i = 0; i < row;\
    \ i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                max = Math.max(max, j);\n            }\n        }\n\
    \    }\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity\
    \ - j;\n            }\n        }\n    }\n    return count;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
