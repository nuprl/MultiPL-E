name: HumanEval_6_parse_nested_parens
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
  \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
  \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
  \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
  \ parseNestedParens(String paren_string) {\n"
tests: "return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static\
  \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
  )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
  \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
  \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
completions: ["        ArrayList<Integer> levels = new ArrayList<Integer>();\n   \
    \     StringTokenizer tok = new StringTokenizer(paren_string);\n        tok.useDelimiter(\"\
    \ \");\n        while (tok.hasMoreTokens()) {\n            String curr_str = tok.nextToken();\n\
    \            // If the current string contains parenthesis, recurse\n        \
    \    if (curr_str.contains(\"(\")) {\n                ArrayList<Integer> curr_levels\
    \ = parseNestedParens(curr_str);\n                levels.addAll(curr_levels);\n\
    \            }\n            // Otherwise, add one to the deepest level\n     \
    \       else {\n                levels.add(levels.size());\n            }\n  \
    \      }\n        return levels;", "        ArrayList<Integer> levels = new ArrayList<Integer>();\n\
    \        Matcher m = Pattern.compile(\"\\\\(.*?\\\\)\").matcher(paren_string);\n\
    \        while (m.find()) {\n            MatchResult res = m.toMatchResult();\n\
    \            String group_str = res.group();\n            int index = group_str.indexOf(\"\
    )\");\n            if (index > 0) {\n                int paren_count = 1;\n  \
    \              for (int j = 1; j < index; j++) {\n                    if (group_str.charAt(j)\
    \ == ')')\n                        paren_count--;\n                }\n       \
    \         levels.add(paren_count);\n            }\n        }\n        return levels;",
  "        ArrayList<Integer> max_level_of_nesting = new ArrayList<>();\n        ArrayList<Integer>\
    \ level_of_nesting = new ArrayList<>();\n        HashMap<String, Integer> paren_level_count\
    \ = new HashMap<>();\n        ArrayList<String> paren_level_chars = new ArrayList<>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            paren_level_count.put(paren_string.substring(i,\
    \ i + 1), paren_level_count.get(paren_string.substring(i, i + 1) + 1) + 1);\n\
    \        }\n        for (String char_string : paren_level_count.keySet()) {\n\
    \            if (paren_level_count.get(char_string) > max_level_of_nesting.get(0))\
    \ {\n                max_level_of_nesting.clear();\n                level_of_nesting.clear();\n\
    \                paren_level_count.clear();\n            }\n            if (paren_level_count.get(char_string)\
    \ == max_level_of_nesting.get(0))\n                max_level_of_nesting.add(paren_level_count.get(char_string));\n\
    \            if (paren_level_count.get(char_string) > max_level_of_nesting.get(0))\
    \ {\n                max_level_of_nesting.add(paren_level_count.get(char_string));\n\
    \                level_of_nesting.add(char_string);\n                paren_level_count.remove(char_string);\n\
    \                paren_level_chars.add(char_string);\n            }\n        }\n\
    \        ArrayList<Integer> final_level_of_nesting = new ArrayList<>();\n    \
    \    for (int i = 0; i < max_level_of_nesting.size(); i++) {\n            for\
    \ (int j = 0; j < level_of_nesting.size(); j++) {\n                if (level_of_nesting.get(j).equals(paren_level_chars.get(i)))\
    \ {\n                    final_level_of_nesting.add(level_of_nesting.get(j));\n\
    \                }\n            }\n        }\n        return final_level_of_nesting;",
  "        ArrayList<Integer> results = new ArrayList<Integer>();\n\n        // First\
    \ pass to find all the groups of parentheses that we recognize.\n        for(int\
    \ i = 0; ; i++) {\n            if(paren_string.charAt(i) == '(') {\n         \
    \       results.add(1);\n            }\n            else if(paren_string.charAt(i)\
    \ == ')') {\n                if(results.size() == 0) {\n                    throw\
    \ new RuntimeException(\"No matching closing parenthesis.\");\n              \
    \  }\n                else {\n                    if(results.get(results.size()\
    \ - 1) != 1) {\n                        throw new RuntimeException(\"Unbalanced\
    \ parentheses.\");\n                    }\n                    results.pop();\n\
    \                }\n            }\n            else {\n                throw new\
    \ RuntimeException(\"Unrecognized opening parenthesis.\");\n            }\n  \
    \      }", "        ArrayList<Integer> nesting_level = new ArrayList<>();\n  \
    \      ArrayList<Integer> pair = new ArrayList<>();\n        // initialize pair\
    \ to store parentheses pair\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(') {\n                pair.add(i);\n\
    \            }\n            if (paren_string.charAt(i) == ')') {\n           \
    \     nesting_level.add(pair.size() - 1);\n            }\n        }\n        return\
    \ nesting_level;", "        if (paren_string.isEmpty()) return new ArrayList<Integer>();\n\
    \        ArrayList<Integer> nestings = new ArrayList<Integer>();\n        int\
    \ paren_depth = paren_string.length();\n        StringBuilder temp = new StringBuilder(paren_string);\n\
    \        boolean first_char = true;\n        while (true) {\n            if (paren_depth\
    \ == 0) {\n                nestings.add(temp.lastIndexOf(')'));\n            \
    \    break;\n            }\n            int i = temp.lastIndexOf('(');\n     \
    \       if (i == -1) {\n                nestings.add(0);\n                break;\n\
    \            }\n            nestings.add(i + 1);\n            temp.replace(i,\
    \ 1, ' ');\n            paren_depth--;\n        }\n        return nestings;",
  "        ArrayList<Integer> result = new ArrayList<Integer>();\n        // Start\
    \ with a queue of all the parentheses (and their opening parentheses).\n     \
    \   LinkedList<Integer> opening_parentheses = new LinkedList<Integer>();\n   \
    \     opening_parentheses.add(0);\n        // Keep track of the number of unmatched\
    \ parentheses we find. Whenever a new opening parentheses is found,\n        //\
    \ we subtract 1 from the number of unmatched parentheses.\n        int unmatched_parentheses\
    \ = 0;\n        // Loop through all parentheses in the input string.\n       \
    \ for(int i = 0; i < paren_string.length(); i++) {\n            // If there is\
    \ a closing parenthesis anywhere, we will consider this a match.\n           \
    \ if(paren_string.charAt(i) == '(') {\n                // Add the opening parentheses\
    \ to the queue of parentheses to match later.\n                opening_parentheses.addFirst(i);\n\
    \            }\n            // Otherwise, we are adding an opening parenthesis\
    \ to the queue of parentheses to match later.\n            else {\n          \
    \      // If there are no parentheses in the queue, then we are matching an opening\
    \ parentheses we did not find.\n                // So we will add this opening\
    \ parentheses to our open list and subtract 1 from our number of unmatched parenthesis.\n\
    \                if(opening_parentheses.size() > 0) {\n                    opening_parentheses.addFirst(i);\n\
    \                    unmatched_parentheses--;\n                }\n           \
    \ }\n        }\n        // The result list will keep track of the deepest level\
    \ of nesting.\n        result.add(0);\n        // Loop through all the parentheses\
    \ in the queue.\n        for(int i = 0; i < opening_parentheses.size();) {\n \
    \           // If the queue is not empty, and the number of unmatched parentheses\
    \ is less than or equal to 1,\n            // then this parenthesis is a matching\
    \ parenthese, so we will increment our level of nesting.\n            if((i >=\
    \ opening_parentheses.size()) || (unmatched_parentheses <= 1)) {\n           \
    \     result.add((int)result.last() + 1);\n                // Loop through all\
    \ the unmatched parentheses we have.\n                for(int j = 0; j < unmatched_parentheses;\
    \ j++) {\n                    opening_parentheses.removeLast();\n            \
    \    }\n            }\n            // Otherwise, we'll remove the last element\
    \ in the queue, increment our level of nesting, and remove the\n            //\
    \ last element from the queue.\n            else {\n                opening_parentheses.removeLast();\n\
    \                result.add((int)result.last() + 1);\n            }\n        }\n\
    \        // Return result as an array.\n        return result;", "        ArrayList<Integer>\
    \ results = new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n\
    \        boolean open_brace = false;\n        for (char c : paren_string.toCharArray())\
    \ {\n            switch (c) {\n                case '(':\n                   \
    \ open_brace = true;\n                    stack.push(c);\n                   \
    \ break;\n                case ')':\n                    if (open_brace) {\n \
    \                       int levels = stack.size();\n                        if\
    \ (levels > 0) {\n                            int level = stack.pop();\n     \
    \                       while (level > 0) {\n                                level--;\n\
    \                            }\n                            results.add(levels);\n\
    \                        }\n                        open_brace = false;\n    \
    \                }\n                    break;\n                default:\n   \
    \                 if (!open_brace) {\n                        stack.push(c);\n\
    \                    }\n                    break;\n            }\n        }\n\
    \        if (stack.isEmpty()) {\n            return results;\n        } else {\n\
    \            return null;\n        }", "        // Create a stack for recording\
    \ the deepest level of\n        // nesting for each group of parentheses.\n  \
    \      Stack<Integer> stack = new Stack<>();\n        // For each group of parentheses,\
    \ push the level of\n        // nesting onto the stack.\n        for (int i =\
    \ 0; i < paren_string.length(); i++) {\n            char ch = paren_string.charAt(i);\n\
    \            if (ch == '(') {\n                stack.push(1);\n            } else\
    \ if (ch == ')') {\n                // If the current level of nesting is greater\n\
    \                // than the previous level of nesting, pop the\n            \
    \    // current level of nesting off the stack and push\n                // the\
    \ new level of nesting onto the stack.\n                if (stack.isEmpty() ||\
    \ stack.pop() < stack.getTop()) {\n                    stack.push(1);\n      \
    \          }\n            } else {\n                // Otherwise, record the current\
    \ level of nesting.\n                stack.push(0);\n            }\n        }\n\
    \        // Return the level of nesting of each group of parentheses.\n      \
    \  ArrayList<Integer> result = new ArrayList<>(paren_string.length());\n     \
    \   for (Integer levelOfNesting : stack) {\n            result.add(levelOfNesting);\n\
    \        }\n        return result;", "        int stack = -1;\n        int paren_count\
    \ = 0;\n        ArrayList<Integer> nesting_levels = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> levels = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ indices = new ArrayList<Integer>();\n        int prev_char = '(';\n        int\
    \ new_char = '(';\n        for (int i = 0; i < paren_string.length(); i++) {\n\
    \            char ch = paren_string.charAt(i);\n            switch (ch) {\n  \
    \          case '(':\n                if (stack == -1) {\n                   \
    \ stack++;\n                }\n                else {\n                    stack--;\n\
    \                }\n                levels.add(stack + 1);\n                break;\n\
    \            case '[':\n                stack = -1;\n                levels.add(stack\
    \ + 1);\n                indices.add(levels.size() - 1);\n                prev_char\
    \ = ch;\n                break;\n            case ')':\n                if (stack\
    \ == 0) {\n                    throw new IllegalArgumentException(\"unexpected\
    \ closing bracket \" + ch);\n                }\n                else {\n     \
    \               stack--;\n                }\n                levels.add(stack\
    \ + 1);\n                indices.add(levels.size() - 1);\n                prev_char\
    \ = ch;\n                break;\n            case ' ':\n                levels.add(stack\
    \ + 1);\n                break;\n            case ')':\n                if (prev_char\
    \ == ' ') {\n                    levels.add(stack + 1);\n                    prev_char\
    \ = ch;\n                }\n                else {\n                    throw\
    \ new IllegalArgumentException(\"unexpected closing bracket \" + ch);\n      \
    \          }\n                break;\n            default:\n                if\
    \ (prev_char == ' ') {\n                    prev_char = ch;\n                }\n\
    \                else {\n                    throw new IllegalArgumentException(\"\
    unexpected character \" + ch + \" at index \" + i);\n                }\n     \
    \           break;\n            }\n        }\n        int max_level = levels.get(levels.size()\
    \ - 1);\n        for (int i = 0; i <= max_level; i++) {\n            nesting_levels.add(levels.get(i));\n\
    \        }\n        return nesting_levels;", "        ArrayList<Integer> level_of_nesting\
    \ = new ArrayList<>();\n        // Split string by spaces\n        String[] strings\
    \ = paren_string.split(\" \");\n        // Create a stack\n        Stack<Character>\
    \ stack = new Stack<>();\n        // Iterate through the strings and add the level\
    \ of nesting\n        for (String string : strings) {\n            // We encountered\
    \ a \")\" which means we need to push the previous \")\"\n            if (string.equals(\"\
    )\")) {\n                // Push the current \")\"\n                stack.push(string);\n\
    \            } else {\n                // We encountered an opening \"(\" which\
    \ means we need to increase the level of nesting by one\n                if (string.equals(\"\
    (\")) {\n                    level_of_nesting.add(0, level_of_nesting.size());\n\
    \                } else if (stack.empty()) {\n                    // When we encountered\
    \ the opening \"(\" without pushing the \")\", the current level of nesting is\
    \ zero.\n                    level_of_nesting.add(0, level_of_nesting.size());\n\
    \                } else {\n                    level_of_nesting.add(0, level_of_nesting.size());\n\
    \                    int level = Integer.parseInt(string);\n                 \
    \   // Pop the previous \")\" and push current \"(\" with increasing level\n \
    \                   while (!stack.empty()) {\n                        String element\
    \ = stack.pop();\n                        if (element.equals(\")\")) {\n     \
    \                       level_of_nesting.add(level);\n                       \
    \ } else {\n                            level_of_nesting.add(level + 1);\n   \
    \                     }\n                    }\n                }\n          \
    \  }\n        }\n        // We are done since we need to return the maximum level\
    \ of nesting\n        return level_of_nesting;", "        ArrayList<Integer> list_of_ints\
    \ = new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n       \
    \ boolean open_parentheses = false;\n        boolean close_parentheses = false;\n\
    \        StringBuilder nested_stack = new StringBuilder();\n        StringBuilder\
    \ new_stack = new StringBuilder();\n        for(int i = 0; i < (paren_string.length());\
    \ i++) {\n            char ch = paren_string.charAt(i);\n            int int_ch\
    \ = ch;\n            int int_stack_size = 0;\n            String str_ch = String.valueOf(int_ch);\n\
    \            if(open_parentheses) {\n                stack.push(str_ch);\n   \
    \             int_stack_size++;\n            }\n            if(ch == '(') {\n\
    \                open_parentheses = true;\n                int_stack_size++;\n\
    \            }\n            if(ch == ')') {\n                open_parentheses\
    \ = false;\n                close_parentheses = true;\n                int_stack_size++;\n\
    \            }\n            if(open_parentheses && close_parentheses) {\n    \
    \            if(int_stack_size < 2) {\n                    list_of_ints.add(int_stack_size);\n\
    \                } else {\n                    list_of_ints.add(int_stack_size);\n\
    \                    list_of_ints.add(new_stack.indexOf(1));\n               \
    \ }\n                new_stack = new StringBuilder();\n                close_parentheses\
    \ = false;\n            }\n            nested_stack.append(str_ch);\n        }\n\
    \        if(open_parentheses && close_parentheses && new_stack.length() > 0) {\n\
    \            list_of_ints.add(new_stack.indexOf(1));\n        }\n        return\
    \ list_of_ints;", "        ArrayList<Integer> result = new ArrayList<Integer>();\n\
    \        String[] strings = paren_string.split(\" \");\n        for (String string\
    \ : strings) {\n            result.addAll(parseNestedParens(string));\n      \
    \  }\n        return result;", "        ArrayList<Integer> parens_levels = new\
    \ ArrayList<Integer>();\n        // Loop through the string and find all parenthesis\
    \ pairs\n        for (int i = 0; i < paren_string.length(); i++) {\n         \
    \   // If this character is right to left then ignore the character\n        \
    \    if (paren_string.charAt(i) == '(') {\n                // If we have not seen\
    \ the opening parenthesis then add it to the parens_levels\n                if\
    \ (parens_levels.isEmpty()) {\n                    parens_levels.add(0);\n   \
    \             }\n                // If the current parenthesis level is greater\
    \ than the parens_levels in the parens_levels arraylist\n                // then\
    \ append it to the parens_levels arraylist\n                if (parens_levels.get(i)\
    \ > parens_levels.get(parens_levels.size() - 1)) {\n                    parens_levels.add(parens_levels.get(parens_levels.size()\
    \ - 1) + 1);\n                }\n            }\n            // If this character\
    \ is left to right then ignore the character\n            else if (paren_string.charAt(i)\
    \ == ')') {\n                // If we have not seen the closing parenthesis then\
    \ add it to the parens_levels\n                if (parens_levels.isEmpty()) {\n\
    \                    parens_levels.add(0);\n                }\n              \
    \  // If the current parenthesis level is greater than the parens_levels in the\
    \ parens_levels arraylist\n                // then append it to the parens_levels\
    \ arraylist\n                if (parens_levels.get(i) > parens_levels.get(parens_levels.size()\
    \ - 1)) {\n                    parens_levels.add(parens_levels.get(parens_levels.size()\
    \ - 1) + 1);\n                }\n            }\n        }\n        return parens_levels;",
  "        int paren_level = new Integer[paren_string.length()];\n        for (int\
    \ i = 0; i < paren_level.length; i++) {\n            paren_level[i] = 0;\n   \
    \     }\n        ArrayList<Integer> results = new ArrayList<Integer>();\n    \
    \    boolean in_paren_pair = false;\n        int paren_pair = 0;\n        for\
    \ (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            if (c == '(') {\n                paren_level[paren_pair]++;\n   \
    \             in_paren_pair = true;\n            } else if (c == ')' && in_paren_pair)\
    \ {\n                paren_level[paren_pair]--;\n                in_paren_pair\
    \ = false;\n                results.add(paren_level[paren_pair]);\n          \
    \  } else if (c == ' ' && in_paren_pair) {\n                results.add(paren_level[paren_pair]);\n\
    \            }\n        }\n        return results;", "        ArrayList<Integer>\
    \ levels = new ArrayList<Integer>();\n        StringTokenizer tokens = new StringTokenizer(paren_string);\n\
    \        while (tokens.hasMoreTokens()) {\n            String level_str = tokens.nextToken();\n\
    \            int level = 0;\n            for (int i = 0; i < level_str.length();\
    \ i++) {\n                char c = level_str.charAt(i);\n                if (c\
    \ == '(') level++;\n                if (c == ')') level--;\n            }\n  \
    \          levels.add(level);\n        }\n        return levels;", "        //\
    \ Store the parentheses level of each parentheses\n        ArrayList<Integer>\
    \ levels = new ArrayList<>();\n        // The parentheses stack\n        Stack<String>\
    \ paren_stack = new Stack<>();\n        // The parentheses group\n        ArrayList<String>\
    \ paren_group = new ArrayList<>();\n        // The parentheses level\n       \
    \ int level = 0;\n        // Iterate through the string\n        for(int i = 0;\
    \ i<paren_string.length(); i++) {\n            // If the current char is an opening\
    \ parentheses, push it to the stack\n            if(paren_string.charAt(i) ==\
    \ '(') {\n                paren_stack.push(paren_group);\n                paren_group.clear();\n\
    \                level = 0;\n            }\n            // If the current char\
    \ is a closing parentheses, pop an element from stack\n            else if(paren_string.charAt(i)\
    \ == ')') {\n                level -= 1;\n                if(level == 0 && levels.size()\
    \ > 0) {\n                    levels.add(levels.size());\n                }\n\
    \                level++;\n            }\n            // If the current char is\
    \ neither opening nor closing parentheses, push it to the stack\n            else\
    \ {\n                paren_group.add(paren_string.charAt(i));\n            }\n\
    \        }\n        if(levels.size() > 0) {\n            levels.add(levels.size());\n\
    \        }\n        return levels;", "        if (paren_string.isEmpty())\n  \
    \          return new ArrayList<>();\n        ArrayList<Integer> stack = new ArrayList<>();\n\
    \        int paren_level = 0;\n        boolean paranthesesFound = false;\n   \
    \     int paren_count = 0;\n        int current_level = 0;\n        int current_count\
    \ = 0;\n        for (char c : paren_string.toCharArray()) {\n            if (c\
    \ == '(') {\n                paren_count++;\n                if (paren_count ==\
    \ 1 && parenthesesFound) {\n                    stack.clear();\n             \
    \       stack.add(paren_level);\n                    paranthesesFound = false;\n\
    \                }\n            }\n            if (c == ')') {\n             \
    \   paren_count--;\n                if (paren_count == 0) {\n                \
    \    parenthesesFound = true;\n                    stack.clear();\n          \
    \          stack.add(paren_level);\n                    current_level = stack.size()\
    \ - 1;\n                    current_count = stack.size();\n                }\n\
    \            }\n            if (c == '(') {\n                paranthesesFound\
    \ = true;\n                paren_count++;\n            }\n            if (c ==\
    \ ')') {\n                paranthesesFound = false;\n                paren_count--;\n\
    \            }\n            current_count++;\n        }\n        if (paranthesesFound)\
    \ {\n            stack.clear();\n        }\n        return stack;", "        ArrayList<Integer>\
    \ level_array = new ArrayList<Integer>();\n        String[] string_array = paren_string.trim().split(\"\
    \ \");\n        for (String s : string_array) {\n            if (s.equals(\"()\"\
    ) || s.equals(\")\") || s.equals(\"\")) {\n                level_array.add(0);\n\
    \            } else {\n                int level = 0;\n                for (int\
    \ i = 0; i < s.length(); i++) {\n                    if (s.charAt(i) == '(')\n\
    \                        level++;\n                    if (s.charAt(i) == ')')\n\
    \                        level--;\n                    if (level == -1)\n    \
    \                    break;\n                }\n                level_array.add(level);\n\
    \            }\n        }\n        return level_array;", "        // Return value\n\
    \        ArrayList<Integer> result_list = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ result_stack = new ArrayList<Integer>();\n        // Iterate over input string\n\
    \        for (String chars : paren_string.split(\" \")) {\n            int paren_level\
    \ = 0;\n            // Iterate over input string chars\n            for (char\
    \ c : chars.toCharArray()) {\n                switch (c) {\n                 \
    \   case '(':\n                        result_stack.add(paren_level);\n      \
    \                  break;\n                    case ')':\n                   \
    \     // If level > 0, then we have found an inner level.\n                  \
    \      // Increase level and store result in result_list\n                   \
    \     if (result_stack.isEmpty()) result_list.add(-1);\n                     \
    \   else {\n                            int level_top = result_stack.peek();\n\
    \                            if (level_top > result_list.size())\n           \
    \                     result_list.add(level_top);\n                        }\n\
    \                        // Pop level from stack\n                        int\
    \ pop_level = result_stack.poll();\n                        if (pop_level >= 0)\n\
    \                            result_list.add(pop_level);\n                   \
    \     break;\n                    case ' ':\n                        // Increase\
    \ level\n                        result_list.add(paren_level);\n             \
    \           break;\n                    default:\n                        break;\n\
    \                }\n            }\n        }\n        return result_list;", " \
    \       // Iterate over each group and find deepest level of nesting\n       \
    \ ArrayList<Integer> deepest_level_of_nesting = new ArrayList<Integer>();\n  \
    \      for (String group_string : paren_string.split(\" \")) {\n            group_string\
    \ = group_string.trim();\n            int level_of_nesting = 1;\n            for\
    \ (int i = 0; i < group_string.length(); i++) {\n                if (group_string.charAt(i)\
    \ == '(') {\n                    level_of_nesting++;\n                }\n    \
    \            if (group_string.charAt(i) == ')') {\n                    level_of_nesting--;\n\
    \                }\n            }\n            deepest_level_of_nesting.add(level_of_nesting);\n\
    \        }\n        return deepest_level_of_nesting;", "        // Initialize\
    \ an empty array list\n        ArrayList<Integer> max_level_of_nesting = new ArrayList<Integer>();\n\
    \        // Add each level of nesting in parentheses to the arraylist\n      \
    \  int level_of_nesting = 0;\n        for(int i = 0; i < paren_string.length();\
    \ i++) {\n            if(paren_string.charAt(i) == ')') {\n                level_of_nesting++;\n\
    \                if(level_of_nesting > max_level_of_nesting.size()) {\n      \
    \              max_level_of_nesting.add(level_of_nesting);\n                }\n\
    \            } else {\n                level_of_nesting = 0;\n            }\n\
    \        }\n        return max_level_of_nesting;", "        ArrayList<Integer>\
    \ result = new ArrayList<Integer>();\n        StringTokenizer tokenizer = new\
    \ StringTokenizer(paren_string);\n        while (tokenizer.hasMoreTokens()) {\n\
    \            String token = tokenizer.nextToken();\n            if (token.equals(\"\
    (\")) {\n                result.add(1);\n            } else {\n              \
    \  int index = result.size() - 1;\n                for (int i = 1; i < result.size();\
    \ i++) {\n                    if (paren_string.charAt(index) == token.charAt(0))\
    \ {\n                        result.add(i);\n                        index = i;\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ result;", "        ArrayList<Integer> nesting_levels = new ArrayList<>();\n\n\
    \        // First, find how many parentheses are in the string.\n        int num_parentheses\
    \ = paren_string.split(\"\\\\(\").length - 1;\n\n        // Now traverse through\
    \ the string and record how much each level of nesting is.\n        for (int i\
    \ = 0; i < num_parentheses; i++) {\n            // To get nested parentheses,\
    \ we need to keep track of how many levels of parentheses\n            // are\
    \ already in the string.\n            int parentheses_before = i;\n          \
    \  while (parentheses_before >= 0) {\n                if (paren_string.indexOf(\"\
    \\\\((\", parentheses_before) < 0) {\n                    break;\n           \
    \     }\n                parentheses_before--;\n            }\n            //\
    \ Now that we know how many levels of parentheses are before the current parentheses,\
    \ we\n            // can determine how many levels of parentheses exist after\
    \ the current parentheses.\n            int parentheses_after = paren_string.indexOf(\"\
    \\\\)\", parentheses_before + 1);\n            int new_levels = (parentheses_after\
    \ - parentheses_before + 1);\n            nesting_levels.add(new_levels);\n  \
    \      }\n\n        return nesting_levels;", "        // Define an empty list\
    \ for storing the nested level of parentheses.\n        ArrayList<Integer> max_level\
    \ = new ArrayList<>();\n        // For each of the parentheses in paren_string,\
    \ add one to the nesting level if it is closed.\n        // Then, add one to the\
    \ nesting level if the parentheses inside are closed.\n        paren_string.split(\"\
    \ \").forEach(str ->\n                max_level.add(max_level.size() + 1).orElse(max_level.size()\
    \ + 1)\n        );\n        // Return the list.\n        return max_level;", " \
    \       ArrayList<Integer> nesting_levels = new ArrayList<>();\n        StringTokenizer\
    \ tokenizer = new StringTokenizer(paren_string, \" ()\");\n        while (tokenizer.hasMoreTokens())\
    \ {\n            String curr_token = tokenizer.nextToken();\n            nesting_levels.add(paren_string.indexOf(curr_token));\n\
    \        }\n        Collections.sort(nesting_levels);\n        return nesting_levels;",
  "        // Store all opening brackets in the same array and the same index\n  \
    \      ArrayList<String> opening_brackets = Arrays.asList(paren_string.split(\"\
    \\\\(\"));\n\n        // Find the deepest nested level of brackets\n        ArrayList<Integer>\
    \ max_level = Arrays.asList(0, 0);\n        ArrayList<Integer> temp_level;\n \
    \       boolean found_brackets = false;\n        for (int i = 1; i < opening_brackets.size();\
    \ i++) {\n            // Find the next bracket\n            String open_bracket\
    \ = opening_brackets.get(i);\n\n            // Find the matching closing brackets\n\
    \            String close_bracket = opening_brackets.get(i - 1);\n           \
    \ int close_bracket_index = opening_brackets.indexOf(close_bracket);\n\n     \
    \       if (close_bracket.equals(\"(\") || close_bracket.equals(\")\") || close_bracket.equals(\"\
    {\")\n                    || close_bracket.equals(\"}\") || close_bracket.equals(\"\
    [\")) {\n                // Close the brackets found\n                found_brackets\
    \ = true;\n            }\n            else {\n                // Find the corresponding\
    \ open brackets\n                String open_bracket_index = opening_brackets.indexOf(open_bracket);\n\
    \                String temp_string = opening_brackets.get(open_bracket_index);\n\
    \                int temp_index = 0;\n\n                // Keep track of the deepest\
    \ level of nesting of brackets\n                while (open_bracket_index != -1\
    \ && temp_index < temp_level.size()) {\n                    if (temp_level.get(temp_index)\
    \ > temp_level.get(temp_index + 1)) {\n                        temp_level = temp_level.subList(temp_index\
    \ + 1, temp_index + 2);\n                        temp_index = temp_index + 1;\n\
    \                    }\n                    else {\n                        temp_index\
    \ = temp_index + 1;\n                    }\n                }\n\n            \
    \    // Keep track of the maximum level of nesting of brackets\n             \
    \   for (int j = temp_index; j < temp_level.size() - 1; j++) {\n             \
    \       if (temp_level.get(j) > temp_level.get(j + 1)) {\n                   \
    \     temp_level = temp_level.subList(j, j + 1);\n                        found_brackets\
    \ = true;\n                    }\n                    else {\n               \
    \         found_brackets = true;\n                    }\n                }\n\n\
    \                if (found_brackets == false) {\n                    // If the\
    \ last bracket is not found, then the deepest level is 1\n                   \
    \ temp_level = Arrays.asList(1, 0);\n                }\n\n                if (temp_level.get(temp_level.size()\
    \ - 1) > max_level.get(max_level.size() - 1)) {\n                    max_level\
    \ = temp_level;\n                }\n            }\n        }\n\n        return\
    \ max_level;", "        ArrayList<Integer> max_levels = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> levels = new ArrayList<Integer>();\n        int level\
    \ = 0;\n        for (int i = 0; i < paren_string.length(); ++i) {\n          \
    \  char ch = paren_string.charAt(i);\n            if (ch == '(') {\n         \
    \       level++;\n            } else if (ch == ')') {\n                level--;\n\
    \            } else {\n                levels.add(level);\n                if\
    \ (level > max_levels.get(0)) {\n                    max_levels.set(0, level);\n\
    \                }\n            }\n        }\n        for (int i = 0; i < max_levels.size();\
    \ ++i) {\n            max_levels.set(i + 1, max_levels.get(i) + levels.get(i));\n\
    \        }\n        return max_levels;", "        ArrayList<Integer> nested_levels\
    \ = new ArrayList<>();\n\n        // The input string can be represented using\
    \ two characters of parentheses: { and }.\n        // If there is any single parentheses,\
    \ then output the deepest level of nesting.\n        // Else, output zero.\n \
    \       if (paren_string.contains(\"{\") && paren_string.contains(\"}\")) {\n\
    \            String first_par = paren_string.substring(0,1);\n            String\
    \ second_par = paren_string.substring(1,2);\n            if (first_par.equals(\"\
    {\")) {\n                nested_levels.add(0);\n            } else {\n       \
    \         int max_level = 0;\n                for (int i = 0; i < paren_string.length();\
    \ i++) {\n                    String level_char = paren_string.substring(i, i+1);\n\
    \                    if (level_char.equals(first_par)) {\n                   \
    \     if (level_char.equals(second_par)) {\n                            nested_levels.add(max_level\
    \ + 1);\n                            break;\n                        }\n     \
    \                   nested_levels.add(max_level);\n                        max_level\
    \ += 1;\n                        i = paren_string.length();\n                \
    \    } else {\n                        nested_levels.add(max_level);\n       \
    \                 max_level += 1;\n                    }\n                }\n\
    \            }\n        } else {\n            nested_levels.add(0);\n        }\n\
    \n        return nested_levels;", "        ArrayList<Integer> results = new ArrayList<>();\n\
    \        if (paren_string == null || paren_string.trim().isEmpty()) {\n      \
    \      return results;\n        }\n        // First, strip the outermost parens,\
    \ if any\n        int num_parens = paren_string.trim().length();\n        if (num_parens\
    \ > 0 && paren_string.charAt(0) == '(' && paren_string.charAt(num_parens - 1)\
    \ == ')') {\n            num_parens--;\n            paren_string = paren_string.substring(1,\
    \ num_parens);\n        }\n        paren_string = paren_string.trim();\n     \
    \   // Now go through the string again to look for nested parens\n        int\
    \ curr_level = 1;\n        int curr_pos = 0;\n        while (curr_pos < paren_string.length())\
    \ {\n            int next_pos = paren_string.indexOf('(', curr_pos);\n       \
    \     if (next_pos == -1) {\n                return results;\n            }\n\
    \            // Found a match\n            results.add(curr_level);\n        \
    \    // Update the current level\n            curr_level = next_pos - curr_pos\
    \ + 1;\n            curr_pos = next_pos + 1;\n        }\n        return results;",
  "        // Create an array of length equal to the string length\n        ArrayList<Integer>\
    \ a = new ArrayList<Integer>(paren_string.length());\n        // Initialize a\
    \ to empty array\n        a.clear();\n        // Parse the parenthesis\n     \
    \   char[] chars = paren_string.toCharArray();\n        int index = 0;\n     \
    \   // If current char is a open parenthesis\n        if (chars[index] == '(')\
    \ {\n            // Increase the index\n            index++;\n            // If\
    \ the index is not the end of the string\n            while (index < chars.length\
    \ && chars[index] == ')') {\n                // Decrease the index\n         \
    \       index++;\n                // If index is equal to the string length, then\
    \ stop parsing\n                if (index == chars.length) break;\n          \
    \      // Else if the current char is a closing parenthesis\n                if\
    \ (chars[index] == ')') {\n                    // Add 1 to the index\n       \
    \             index++;\n                }\n            }\n            // Else\
    \ if the current char is a close parenthesis\n            if (index == chars.length)\
    \ break;\n            // Else if the current char is a comma\n            if (chars[index]\
    \ == ',') {\n                // Add 1 to the index\n                index++;\n\
    \            }\n            // Else if the current char is a semicolon\n     \
    \       if (chars[index] == ';') {\n                // Add 1 to the index\n  \
    \              index++;\n            }\n            // Else if the current char\
    \ is an opening parenthesis\n            if (chars[index] == '(') {\n        \
    \        // Add 1 to the index\n                index++;\n            }\n    \
    \        // Else if the current char is a closing parenthesis\n            if\
    \ (chars[index] == ')') {\n                // Add 1 to the index\n           \
    \     index++;\n            }\n            // Else if the current char is a opening\
    \ bracket\n            if (chars[index] == '[') {\n                // Add 1 to\
    \ the index\n                index++;\n            }\n            // Else if the\
    \ current char is a closing bracket\n            if (chars[index] == ']') {\n\
    \                // Add 1 to the index\n                index++;\n           \
    \ }\n            // Else if the current char is a decimal point\n            if\
    \ (chars[index] == '.') {\n                // Add 1 to the index\n           \
    \     index++;\n            }\n            // Else if the current char is a hex\
    \ digit\n            if (chars[index] == 'x' || chars[index] == 'X') {\n     \
    \           // Add 1 to the index\n                index++;\n            }\n \
    \           // Else if the current char is a number or a letter\n            if\
    \ (chars[index] >= '0' && chars[index] <= '9' || chars[index] >= 'a' && chars[index]\
    \ <= 'z' || chars[index] >= 'A' && chars[index] <= 'Z' || chars[index] == '_'\
    \ || chars[index] == '-') {\n                // Add 1 to the index\n         \
    \       index++;\n            }\n            // Else if the current char is blank\n\
    \            if (char", "        ArrayList<Integer> levels = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> level_stack = new ArrayList<Integer>();\n        for(int\
    \ i = 0; i < paren_string.length(); i++) {\n            String curr_char = null;\n\
    \            char curr_char_ch = '\\0';\n            boolean found = false;\n\
    \            for(int j = 0; j < level_stack.size(); j++) {\n                if(paren_string.charAt(i)\
    \ == level_stack.get(j)) {\n                    found = true;\n              \
    \      break;\n                }\n            }\n            if(found) {\n   \
    \             level_stack.remove(0);\n                level_stack.add(0);\n  \
    \              level_stack.clear();\n            } else {\n                level_stack.add(paren_string.charAt(i));\n\
    \            }\n            if(paren_string.charAt(i) == '(') {\n            \
    \    level_stack.add(paren_string.charAt(i));\n            } else {\n        \
    \        if(level_stack.size() > 0) {\n                    curr_char = level_stack.get(level_stack.size()\
    \ - 1);\n                } else {\n                    curr_char = '\\0';\n  \
    \              }\n            }\n            if(paren_string.charAt(i) == ')')\
    \ {\n                if(level_stack.size() > 0) {\n                    if(paren_string.charAt(i)\
    \ == '(') {\n                        levels.add(paren_string.charAt(i));\n   \
    \                 } else {\n                        levels.add(level_stack.get(level_stack.size()\
    \ - 1));\n                    }\n                }\n            }\n        }\n\
    \        return levels;", "        ArrayList<Integer> max_levels = new ArrayList<Integer>();\n\
    \        int curr_level = 0;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(') {\n                curr_level++;\n\
    \            } else if (paren_string.charAt(i) == ')') {\n                curr_level--;\n\
    \            }\n            if (curr_level > max_levels.size()) {\n          \
    \      max_levels.add(curr_level);\n            } else if (curr_level < max_levels.size())\
    \ {\n                max_levels.set(max_levels.size(), curr_level);\n        \
    \    }\n        }\n        return max_levels;", "        ArrayList<Integer> level_count\
    \ = new ArrayList<>();\n        \n        // A stack of levels of nesting.\n \
    \       ArrayList<Integer> stack = new ArrayList<>();\n        // A stack of parentheses\
    \ opened so far.\n        ArrayList<Character> stack_ptr = new ArrayList<>();\n\
    \        \n        // The parens opened by (), {}, [], [], etc.\n        Map<Character,\
    \ Integer> parens = {\n            '(': -1, '[': -1, '{': -1, '(': -1, '[': -1,\
    \ '{': -1\n        };\n        \n        // Process every character in string.\n\
    \        for (char c : paren_string.toCharArray()) {\n            // Open parentheses.\n\
    \            if (parens.get(c) != -1) {\n                if (stack_ptr.contains(c))\
    \ {\n                    // If there are open () in the stack, pop it.\n     \
    \               stack_ptr.remove(stack.peek());\n                    stack.pop();\n\
    \                } else {\n                    // If there are no open () in the\
    \ stack, push it to the stack.\n                    stack.push(c);\n         \
    \       }\n            } else {\n                // Close parentheses.\n     \
    \           if (stack.size() == 0) {\n                    level_count.add(0);\n\
    \                } else {\n                    // Get current level of nesting.\n\
    \                    int level_num = stack.size();\n                    // Update\
    \ the level count of the parentheses.\n                    parens[stack.get(stack.size()\
    \ - 1)]++;\n                    // Pop from the stack.\n                    stack.pop();\n\
    \                    // Update the level count of the level.\n               \
    \     level_count.set(level_num - 1, level_count.get(level_num - 1) + 1);\n  \
    \              }\n            }\n        }\n        \n        // Pop the stack\
    \ till we reach the root.\n        while (stack.size() != 0) {\n            int\
    \ level_num = stack.size();\n            int level = level_count.get(level_num\
    \ - 1);\n            parens[stack.get(stack.size() - 1)]--;\n            stack.pop(level);\n\
    \        }\n        \n        return level_count;", "        // Your code here\n\
    \        ArrayList<Integer> nest_level = new ArrayList<Integer>();\n        int\
    \ nest_level_count = 0;\n        for (char c : paren_string.toCharArray()) {\n\
    \            if ((c == '(') && (nest_level_count > 0)) {\n                nest_level.add(nest_level_count);\n\
    \                nest_level_count = 0;\n            } else if (c == '(') {\n \
    \               nest_level_count++;\n            } else if (c == ')') {\n    \
    \            nest_level_count--;\n            }\n        }\n        nest_level.add(nest_level_count);\n\
    \        return nest_level;", "        ArrayList<Integer> max_level = new ArrayList<Integer>();\n\
    \        // Create an array to store the final answer.\n        ArrayList<Integer>\
    \ output = new ArrayList<Integer>();\n        // Keep track of the depth of the\
    \ previous parenthesis.\n        int current_depth = 0;\n        // Keep track\
    \ of the nesting level of each parenthesis.\n        ArrayList<Integer> nesting_level\
    \ = new ArrayList<Integer>();\n        // Convert the input string to array using\
    \ String.split.\n        String[] parens = paren_string.split(\" \");\n      \
    \  // Iterate through each of the input array.\n        for(int i = 0; i < parens.length;\
    \ i++) {\n            // If the character is not a parenthesis, add the character\
    \ to the array.\n            if(parens[i].charAt(0) == '(') {\n              \
    \  nesting_level.add(current_depth);\n            }\n            // If the character\
    \ is a closing parenthesis, increment the depth.\n            else if(parens[i].charAt(0)\
    \ == ')') {\n                current_depth++;\n            }\n            // If\
    \ the character is not a closing parenthesis, find the deepest level of nesting.\n\
    \            else if(parens[i].charAt(0) != ')') {\n                nesting_level.remove(nesting_level.size()\
    \ - 1);\n                current_depth = 0;\n                nesting_level.add(current_depth);\n\
    \            }\n        }\n        // Add the current depth value to the output\
    \ array if the character is a closing parenthesis.\n        if(current_depth >\
    \ 0) {\n            nesting_level.remove(nesting_level.size() - 1);\n        \
    \    output.add(current_depth);\n        }\n        // Return the output array.\n\
    \        return output;", "        ArrayList<Integer> results = new ArrayList<Integer>();\n\
    \        boolean first_paren = true;\n        StringTokenizer st = new StringTokenizer(paren_string,\
    \ \" ()\");\n        while (st.hasMoreTokens()) {\n            String token =\
    \ st.nextToken();\n            int level_of_nesting = token.indexOf('(');\n  \
    \          if (level_of_nesting > 0) {\n                if (first_paren) {\n \
    \                   results.add(level_of_nesting);\n                } else {\n\
    \                    if (level_of_nesting > results.last()) {\n              \
    \          results.add(level_of_nesting);\n                    }\n           \
    \     }\n            }\n            first_paren = false;\n        }\n        return\
    \ results;", "        // Implement your solution here\n        ArrayList<Integer>\
    \ result = new ArrayList<>();\n        HashMap<String, Integer> paren_nesting\
    \ = new HashMap<>();\n        for (String s : paren_string.trim().split(\" \"\
    )) {\n            String key = s;\n            int nesting = 0;\n            while\
    \ (paren_nesting.containsKey(key)) {\n                nesting++;\n           \
    \     key = paren_nesting.get(key);\n            }\n            paren_nesting.put(key,\
    \ nesting);\n            if (s.equals(\"(\")) {\n                result.add(nesting);\n\
    \            } else if (s.equals(\")\")) {\n                boolean has_rightmost_unmatched\
    \ = false;\n                for (int j = 0; j < nesting; j++) {\n            \
    \        if (!paren_nesting.containsKey(key + \"(\")) {\n                    \
    \    has_rightmost_unmatched = true;\n                        break;\n       \
    \             }\n                }\n                if (!has_rightmost_unmatched)\
    \ {\n                    result.add(nesting - 1);\n                }\n       \
    \     }\n        }\n        return result;", "        int max = 0;\n        int\
    \ level = 1;\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\
    \        List<String> all_parens = paren_string.split(\"\\\\s+\");\n        for\
    \ (String s: all_parens) {\n            if (s.equals(\"(\")) {\n             \
    \   if (level >= max) {\n                    result.add(max);\n              \
    \  }\n                max++;\n                level++;\n            } else if\
    \ (s.equals(\")\")) {\n                if (level >= max) {\n                 \
    \   result.add(max);\n                }\n                level--;\n          \
    \  }\n        }\n        return result;", "        // We use two lists to store\
    \ one level of parentheses and one level of nesting.\n        // If the level\
    \ of nesting is less than the level of parentheses, add parentheses level.\n \
    \       // If the level of nesting is more than the level of parentheses, increase\
    \ the level of nesting.\n        ArrayList<Integer> nesting = new ArrayList<>();\n\
    \        ArrayList<Integer> paren_level = new ArrayList<>();\n\n        // Use\
    \ a stack to store every substring of the string separated by parentheses.\n \
    \       // We only care about parentheses and ignore brackets.\n        Stack<String>\
    \ stack = new Stack<>();\n        for(char c : paren_string.toCharArray())\n \
    \       {\n            if (c == '(') stack.push(c);\n            if (c == ')')\
    \ stack.pop();\n        }\n\n        // Add the nesting level until we encounter\
    \ a closing parentheses.\n        while(!stack.isEmpty())\n        {\n       \
    \     nesting.add(paren_level.size());\n            paren_level.add(paren_level.size());\n\
    \n            char top = stack.pop();\n            char bottom = stack.pop();\n\
    \            if (top == '(') stack.push(bottom);\n            if (bottom == ')')\
    \ stack.pop();\n        }\n\n        return nesting;", "        ArrayList<Integer>\
    \ result = new ArrayList<>();\n        stack<Integer> stack = new stack<>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            String\
    \ token = paren_string.substring(i, paren_string.length());\n            if (\"\
    (\" == token.charAt(0)) {\n                stack.push(0);\n            }\n   \
    \         else if (\")\" == token.charAt(0)) {\n                result.add(stack.pop());\n\
    \            }\n            else if (\")\" == token.charAt(1)) {\n           \
    \     result.add(stack.pop());\n                result.add(1);\n            }\n\
    \            else if (\")\" == token.charAt(2)) {\n                result.add(stack.pop());\n\
    \                result.add(2);\n            }\n            else if (\")\" ==\
    \ token.charAt(3)) {\n                result.add(stack.pop());\n             \
    \   result.add(3);\n            }\n            else if (\")\" == token.charAt(4))\
    \ {\n                result.add(stack.pop());\n                result.add(4);\n\
    \            }\n            else if (\")\" == token.charAt(5)) {\n           \
    \     result.add(stack.pop());\n                result.add(5);\n            }\n\
    \        }\n        return result;", "        // Use a set to get the unique nesting\
    \ level.\n        // The key is the nested parentheses, while the value is the\n\
    \        // nesting level of the parentheses.\n        Set<String> parens = new\
    \ HashSet<String>();\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\
    \        for(char c : paren_string.toCharArray()) {\n            // Only deal\
    \ with the parentheses.\n            // We assume that the parentheses are in\
    \ pairs.\n            // If they are not, just output the parentheses.\n     \
    \       if (c == '(') parens.add(\"(\" + c);\n            else if (c == ')') parens.add(\"\
    )\" + c);\n            else {\n                // If it is a opening parentheses,\
    \ increment its nesting level.\n                if (parens.contains(c)) {\n  \
    \                  parens.replace(c, (char) ('(' + parens.get(c).charAt(0) + 1));\n\
    \                }\n                // If it is a closing parentheses, decrement\
    \ the nesting level.\n                else {\n                    int depth =\
    \ 0;\n                    while ((c = parens.get(c).charAt(depth)) != ')') {\n\
    \                        depth++;\n                    }\n                   \
    \ parens.replace(c, (char) ('(' + parens.get(c).charAt(0) - depth));\n       \
    \         }\n            }\n        }\n        // Add the maximum nesting level\
    \ to the result.\n        // We assume that the parentheses are in pairs.\n  \
    \      // If they are not, just output the parentheses.\n        // The nesting\
    \ level of the parentheses is actually the sum of the nesting levels of the parentheses\n\
    \        // above it.\n        int max_nesting_level = Integer.MIN_VALUE;\n  \
    \      for (String paren : parens) {\n            max_nesting_level = Math.max(max_nesting_level,\
    \ parseNestedParens(paren).stream().mapToInt(Integer::intValue).sum());\n    \
    \    }\n        result.add(max_nesting_level);\n        return result;", "   \
    \     ArrayList<Integer> max_levels_of_nesting = new ArrayList<Integer>();\n \
    \       Stack<Integer> stack = new Stack<Integer>();\n        char[] char_array\
    \ = paren_string.toCharArray();\n        int length = char_array.length;\n   \
    \     int last_index = 0;\n        for (int i = 0; i < length; i++) {\n      \
    \      if (char_array[i] == '(') {\n                if (stack.isEmpty()) {\n \
    \                   stack.push(char_array[i]);\n                } else if (stack.peek()\
    \ != '(') {\n                    stack.push(char_array[i]);\n                }\n\
    \            } else if (char_array[i] == ')') {\n                if (stack.isEmpty())\
    \ {\n                    max_levels_of_nesting.add(i - last_index);\n        \
    \            stack.push(char_array[i]);\n                } else if (stack.peek()\
    \ == '(') {\n                    max_levels_of_nesting.add(i - last_index);\n\
    \                    stack.push(char_array[i]);\n                }\n         \
    \   } else if (char_array[i] == ' ') {\n                if (stack.isEmpty()) {\n\
    \                    stack.push(char_array[i]);\n                } else if (stack.peek()\
    \ != '(') {\n                    stack.push(char_array[i]);\n                }\n\
    \            } else {\n                if (stack.isEmpty()) {\n              \
    \      stack.push(char_array[i]);\n                } else if (stack.peek() !=\
    \ '(') {\n                    stack.push(char_array[i]);\n                }\n\
    \            }\n            last_index = i;\n        }\n        return max_levels_of_nesting;",
  "        ArrayList<Integer> ret = new ArrayList<>();\n        Stack<Integer> stack_of_nesting\
    \ = new Stack<>();\n        for(int i = 0; i < paren_string.length(); i++) {\n\
    \            char ch = paren_string.charAt(i);\n            if(!Character.isWhitespace(ch)\
    \ && ch != '(' && ch != ')') {\n                stack_of_nesting.push(ch);\n \
    \           } else if(ch == '(') {\n                if(stack_of_nesting.isEmpty())\
    \ {\n                    ret.add(0);\n                } else {\n             \
    \       int current = stack_of_nesting.pop();\n                    ret.add(current\
    \ + 1);\n                }\n            } else if(ch == ')') {\n             \
    \   while(stack_of_nesting.peek() != '(') {\n                    stack_of_nesting.pop();\n\
    \                }\n                int nest = stack_of_nesting.pop();\n     \
    \           ret.add(nest + 1);\n            }\n        }\n        return ret;",
  "        ArrayList<Integer> max_depth = new ArrayList<>();\n\n        ArrayList<Integer>\
    \ parentheses = paren_string.split(\"\\\\s\");\n\n        for (int i = 0; i <\
    \ parentheses.size(); ++i) {\n            if (parentheses.get(i).length() > 0)\
    \ {\n                ArrayList<Integer> sub_depth = parseNestedParens(parentheses.get(i));\n\
    \                for (int j = 0; j < sub_depth.size(); ++j) {\n              \
    \      if (max_depth.size() < sub_depth.size()) {\n                        max_depth.add(sub_depth.size());\n\
    \                    }\n                }\n            }\n        }\n\n      \
    \  return max_depth;", "        if (paren_string.startsWith(\"(\") || paren_string.startsWith(\"\
    [\")) {\n            return new ArrayList<>();\n        }\n        ArrayList<Integer>\
    \ result = new ArrayList<>();\n        boolean last_char_was_open = false, last_char_was_close\
    \ = false;\n        for (char c : paren_string.toCharArray()) {\n            if\
    \ (c == '(') {\n                last_char_was_open = true;\n            }\n  \
    \          if (c == ')') {\n                last_char_was_close = true;\n    \
    \        }\n            if (last_char_was_open && last_char_was_close) {\n   \
    \             result.add(c == '(' ? 1 : -1);\n                last_char_was_close\
    \ = false;\n                last_char_was_open = false;\n            }\n     \
    \       if (c == '[') {\n                last_char_was_open = true;\n        \
    \    }\n            if (c == ']') {\n                last_char_was_close = true;\n\
    \            }\n            if (last_char_was_open) {\n                result.add(c\
    \ == '(' ? 1 : -1);\n                last_char_was_open = false;\n           \
    \ }\n            if (last_char_was_close) {\n                last_char_was_close\
    \ = false;\n            }\n        }\n        return result;", "        ArrayList<Integer>\
    \ level = new ArrayList<Integer>();\n        ArrayList<Integer> levels_so_far\
    \ = new ArrayList<Integer>();\n        int paren = 0;\n        int depth = 0;\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            char c\
    \ = paren_string.charAt(i);\n            if ((c == '(') || (c == ')')) {\n   \
    \             if (c == '(') {\n                    levels_so_far.add(depth);\n\
    \                }\n                depth++;\n                level.add(depth);\n\
    \                paren = i;\n            } else {\n                depth--;\n\
    \            }\n        }\n        if (paren > 0) {\n            depth--;\n  \
    \      }\n        for (int i = 0; i < level.size(); i++) {\n            if (levels_so_far.get(i)\
    \ > level.get(i)) {\n                levels_so_far.set(i, level.get(i));\n   \
    \         }\n        }\n        return levels_so_far;", "        ArrayList<Integer>\
    \ max_levels = new ArrayList<Integer>();\n        ArrayList<Integer> open_brackets\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> close_brackets = new\
    \ ArrayList<Integer>();\n        ArrayList<Integer> open_parentheses = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> close_parentheses = new ArrayList<Integer>();\n  \
    \      ArrayList<Integer> paren_opens = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ paren_closes = new ArrayList<Integer>();\n        int max_level = 0;\n     \
    \   int open_count = 1;\n        for (int i=0; i<paren_string.length(); i++) {\n\
    \            char ch = paren_string.charAt(i);\n            if (ch == '(') {\n\
    \                open_brackets.add(open_count);\n                open_parentheses.add(open_count);\n\
    \                paren_opens.add(open_count);\n                open_count++;\n\
    \            }\n            if (ch == ')') {\n                close_brackets.add(open_count);\n\
    \                close_parentheses.add(open_count);\n                paren_closes.add(open_count);\n\
    \                open_count++;\n            }\n            if (ch == '[') {\n\
    \                open_count++;\n            }\n            if (ch == ']') {\n\
    \                close_count++;\n            }\n            if (open_count > 0)\
    \ {\n                if (ch == ')') {\n                    if (close_brackets.get(close_parentheses.size()-1)\
    \ == open_count) {\n                        close_parentheses.remove(close_parentheses.size()-1);\n\
    \                        close_count--;\n                    }\n             \
    \       if (close_brackets.get(close_parentheses.size()-1) == open_count) {\n\
    \                        max_level = Math.max(max_level, close_parentheses.get(close_parentheses.size()-1));\n\
    \                    }\n                }\n                if (ch == ']') {\n\
    \                    if (open_parentheses.get(open_parentheses.size()-1) == open_count)\
    \ {\n                        open_parentheses.remove(open_parentheses.size()-1);\n\
    \                        open_count--;\n                    }\n              \
    \      if (open_parentheses.get(open_parentheses.size()-1) == open_count) {\n\
    \                        max_level = Math.max(max_level, open_parentheses.get(open_parentheses.size()-1));\n\
    \                    }\n                }\n                if (ch == '(') {\n\
    \                    if (close_brackets.get(close_parentheses.size()-1) == open_count)\
    \ {\n                        close_brackets.remove(close_parentheses.size()-1);\n\
    \                        close_count--;\n                    }\n             \
    \       if (close_brackets.get(close_parentheses.size()-1) == open_count) {\n\
    \                        max_level = Math.max(max_level, close_brackets.get(close_parentheses.size()-1));\n\
    \                    }\n                }\n                if (ch == '[') {\n\
    \                    if (open_parentheses.get(open_parentheses.size()-1) == open_count)\
    \ {\n                        open_parentheses.remove(open_parentheses.size()-1);\n\
    \                        open_count--;\n                    }\n              \
    \      if (open_parentheses.get(open_parentheses.size()-1) == open_count) {\n\
    \                        max_level = Math.max(max_level, open_parentheses.get(open_parentheses.size()-1));\n\
    \                    }\n                }\n            }\n        }\n        System.out.println(max_levels);\n\
    \        return max_", "        // Use recursive function to find the maximum\
    \ level of nesting.\n        // To keep track of all levels of nesting, use a\
    \ stack. \n        ArrayList<Integer> levels = new ArrayList<>();\n        Stack<Integer>\
    \ stack = new Stack<>();\n        for(char c: paren_string.toCharArray()) {\n\
    \            int level = 0;\n            while(!stack.empty()) {\n           \
    \     level++;\n                stack.pop();\n            }\n            levels.add(level);\n\
    \            switch(c) {\n                case '(':\n                    stack.push(level);\n\
    \                    break;\n                case ')':\n                    int\
    \ level = stack.pop();\n                    if(level > levels.get(levels.size()\
    \ - 1)) {\n                        levels.add(level);\n                    }\n\
    \                    break;\n                default:\n                    stack.push(level);\n\
    \            }\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n\
    \        int max_level = levels.get(levels.size() - 1);\n        for(int level\
    \ = 0; level < levels.size(); level++) {\n            if(level < levels.size()\
    \ - 1 && levels.get(level + 1) - levels.get(level) != max_level) {\n         \
    \       result.add(levels.get(level + 1) + 1);\n            }\n        }\n   \
    \     return result;", "        ArrayList<Integer> results = new ArrayList<Integer>();\n\
    \        int stack_size = 0;\n        for(int i = 0; i < paren_string.length();\
    \ i++) {\n            String curr_char = paren_string.substring(i, i + 1);\n \
    \           if(!paren_string.substring(i, i + 1).equals('(') && !paren_string.substring(i,\
    \ i + 1).equals(')')) {\n                // If the current character is not a\
    \ left or right paren, just add it to the stack\n                stack_size++;\n\
    \            } else {\n                // If the current character is a left or\
    \ right paren, pop from the stack\n                if(paren_string.substring(i,\
    \ i + 1).equals('(')) {\n                    stack_size++;\n                }\
    \ else if (paren_string.substring(i, i + 1).equals(')')) {\n                 \
    \   stack_size--;\n                } else {\n                    // if the current\
    \ character is something other than left or right paren, return error\n      \
    \              System.out.println(\"Error parsing parens\");\n               \
    \     return null;\n                }\n            }\n            if(!stack_size)\
    \ {\n                // If the stack size is zero after processing this character,\
    \ add it to the results list\n                results.add(stack_size);\n     \
    \       }\n        }\n        return results;", "        ArrayList<Integer> ans\
    \ = new ArrayList<Integer>();\n        Stack<Integer> parenStack = new Stack<Integer>();\n\
    \        StringBuilder sb = new StringBuilder(paren_string);\n        boolean\
    \ firstChar = true;\n        while(!parenStack.isEmpty()) {\n            if(parenStack.peek()\
    \ >= paren_string.length())\n                break;\n            char curChar\
    \ = paren_string.charAt(parenStack.peek());\n            if(firstChar) {\n   \
    \             firstChar = false;\n                parenStack.push(0);\n      \
    \      } else if(curChar == ')') {\n                if(parenStack.peek() > 0)\
    \ {\n                    ans.add(parenStack.pop());\n                } else {\n\
    \                    throw new RuntimeException(\"unexpected end of string\");\n\
    \                }\n            } else if(curChar == '(') {\n                parenStack.push(parenStack.peek()\
    \ + 1);\n            } else {\n                throw new RuntimeException(\"unexpected\
    \ char\");\n            }\n        }\n        return ans;", "        // Initialize\
    \ result array and parse string as group by group into it.\n        ArrayList<Integer>\
    \ result = new ArrayList<>();\n        for(String group: paren_string.split(\"\
    \\\\s+\")) {\n            // Start new group and recur into it if current group\
    \ has nested parentheses.\n            if(group.length() > 0 && group.indexOf('(')\
    \ != -1) {\n                result.add(parseNestedParens(group));\n          \
    \  } else {\n                // Append level of parentheses to result array (first\
    \ index is 0).\n                result.add(paren_string.indexOf('('));\n     \
    \       }\n        }\n        return result;", "        List<Integer> list = new\
    \ ArrayList<Integer>();\n        int i = 0;\n        while (i < paren_string.length())\
    \ {\n            if (paren_string.charAt(i) == '(') {\n                list.add(0);\n\
    \                i++;\n            } else if (paren_string.charAt(i) == ')') {\n\
    \                list.add(list.get(list.size()-1)+1);\n                i++;\n\
    \            } else {\n                i++;\n            }\n        }\n      \
    \  return list;", "        ArrayList<Integer> result = new ArrayList<Integer>();\n\
    \        Stack<Integer> stack = new Stack<Integer>();\n        StringTokenizer\
    \ st = new StringTokenizer(paren_string);\n        while(st.hasMoreTokens()) {\n\
    \            String token = st.nextToken();\n            if(token.equals(\"(\"\
    ))\n                stack.push(new Integer(0));\n            else if(token.equals(\"\
    )\")) {\n                result.add(new Integer(stack.pop()));\n             \
    \   stack.push(new Integer(0));\n            }\n            else if(token.equals(\"\
    )\")) {\n                while(stack.peek() > 0)\n                    result.add(new\
    \ Integer(stack.pop()));\n                result.add(new Integer(stack.pop()));\n\
    \            }\n            else if(token.equals(\"(\")) {\n                while(stack.peek()\
    \ > 0)\n                    stack.push(new Integer(0));\n            }\n     \
    \       else\n                stack.push(new Integer(0));\n        }\n       \
    \ while(!stack.empty()) {\n            result.add(new Integer(stack.pop()));\n\
    \        }\n        return result;", "        ArrayList<Integer> parens_level\
    \ = \n            Arrays.stream(paren_string.split(\" \"))\n                .map(x\
    \ -> {\n                    Pattern p = Pattern.compile(\"\\\\((\\\\()|(\\\\))|\\\
    \\s(\\\\))\");\n                    Matcher m = p.matcher(x);\n              \
    \      int parens = 0;\n                    while (m.find()) {\n             \
    \           parens = parens + 1;\n                    }\n                    return\
    \ parens;\n                })\n                .filter(x -> x > 0)\n         \
    \       .collect(Collectors.toList());\n        int max_level = Math.max(parens_level);\n\
    \        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int\
    \ i = 0; i < parens_level.size(); i++) {\n            result.add(parens_level[i]);\n\
    \            if (max_level > parens_level[i]) {\n                result.add(max_level\
    \ - parens_level[i]);\n            }\n        }\n        return result;", "  \
    \      // Your code here\n        ArrayList<Integer> result = new ArrayList<>();\n\
    \        int current_level = 0;\n        for(int i=0;i<paren_string.length();i++)\
    \ {\n            if(paren_string.charAt(i) == '(') {\n                current_level++;\n\
    \            }\n            else if(paren_string.charAt(i) == ')') {\n       \
    \         current_level--;\n            }\n            result.add(current_level);\n\
    \        }\n        return result;", "        String[] nested_groups = paren_string.split(\"\
    \ \");\n        ArrayList<Integer> max_level_nested_parens = new ArrayList<Integer>();\n\
    \        for (int i = 0, length = nested_groups.length; i < length; i++) {\n \
    \           String group_for_current_level = nested_groups[i];\n            int\
    \ max_level = 0;\n            // If this group has a non-parentheses characters\
    \ at the end, make it a zero\n            boolean last_group_end_with_non_parentheses\
    \ = !group_for_current_level.matches(\"\\\\W\");\n            for(int j = i+1;\
    \ j < length; j++) {\n                String other_group_for_current_level = nested_groups[j];\n\
    \                // If this group has any non-parentheses characters at the end,\
    \ make its level zero and break\n                boolean other_group_end_with_non_parentheses\
    \ = !other_group_for_current_level.matches(\"\\\\W\");\n                if(last_group_end_with_non_parentheses\
    \ && other_group_end_with_non_parentheses){\n                    break;\n    \
    \            } else if(last_group_end_with_non_parentheses && !other_group_end_with_non_parentheses){\n\
    \                    max_level = 0;\n                    break;\n            \
    \    } else if(!last_group_end_with_non_parentheses && other_group_end_with_non_parentheses){\n\
    \                    max_level = 1;\n                    break;\n            \
    \    } else if(last_group_end_with_non_parentheses && other_group_end_with_non_parentheses){\n\
    \                    max_level = 2;\n                    break;\n            \
    \    }\n            }\n            max_level_nested_parens.add(max_level);\n \
    \       }\n        return max_level_nested_parens;", "        // Split string\
    \ on spaces so you can get each group of parentheses\n        String group_str\
    \ = paren_string.split(\" \");\n        List<Integer> groups = new ArrayList<Integer>();\n\
    \        // Iterate through each group of parentheses.\n        for (int i = 0;\
    \ i < group_str.length; i++) {\n            // Check that the group is a valid\
    \ parentheses group\n            int group_level = 0;\n            while (group_str[i]\
    \ != \")\") {\n                group_level++;\n                i++;\n        \
    \    }\n            // If group has more than one opening, put it in a separate\
    \ list and add it to the main list\n            if (group_level > 1) {\n     \
    \           ArrayList<Integer> temp_groups = new ArrayList<Integer>();\n     \
    \           while (i < group_str.length) {\n                    if (group_str[i]\
    \ == \"(\") {\n                        temp_groups.add(group_level);\n       \
    \                 i++;\n                    }\n                    else {\n  \
    \                      break;\n                    }\n                }\n    \
    \            groups.addAll(temp_groups);\n            }\n            else {\n\
    \                groups.add(group_level);\n            }\n        }\n        //\
    \ Return the maximum level of nested parentheses\n        return groups;", " \
    \       ArrayList<Integer> level_of_nestings = new ArrayList<Integer>();\n   \
    \     String[] splits = paren_string.trim().split(\"\\\\s+\");\n        ArrayDeque<String>\
    \ stack = new ArrayDeque<String>(Arrays.asList(splits));\n        while (!stack.isEmpty())\
    \ {\n            String s = stack.pop();\n            int level = level_of_nestings.size();\n\
    \            if (s.equals(\"(\")) {\n                level_of_nestings.add(level);\n\
    \            } else if (s.equals(\")\")) {\n                level_of_nestings.remove(level\
    \ - 1);\n            } else if (s.length() > 0) {\n                stack.push(s);\n\
    \            }\n        }\n        return level_of_nestings;", "        ArrayList<Integer>\
    \ results = new ArrayList<>();\n        int paren_level = 0;\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            switch(c) {\n            case '(':\n                if (paren_level\
    \ == 0) {\n                    results.add(1);\n                } else {\n   \
    \                 results.add(paren_level);\n                }\n             \
    \   paren_level++;\n                break;\n            case ')':\n          \
    \      if (paren_level == 1 && paren_level > 0) {\n                    results.add(paren_level);\n\
    \                }\n                paren_level--;\n                break;\n \
    \           }\n        }\n        return results;", "        ArrayList<Integer>\
    \ result = new ArrayList<>();\n\n        final String REGEX_STRING = \"\\\\(\\\
    \\(|\\\\)\\\\)\";\n\n        for(int i = 0; i < paren_string.length(); i++) {\n\
    \            if(paren_string.charAt(i) == '(') {\n                result.add(i);\n\
    \            }\n            else if(paren_string.charAt(i) == ')') {\n       \
    \         if(result.size() > 0) {\n                    int index_of_opening =\
    \ result.size() - 1;\n\n                    while(result.size() > 1 && paren_string.charAt(index_of_opening)\
    \ == '(') {\n                        result.remove(index_of_opening);\n      \
    \                  index_of_opening--;\n                    }\n              \
    \  }\n                result.add(i + 1);\n            }\n        }\n\n       \
    \ return result;", "        ArrayList<Integer> max_levels = new ArrayList<Integer>();\n\
    \        Stack<Integer> stack_of_levels = new Stack<Integer>();\n        int level\
    \ = 0;\n        for(int i = 0; i < paren_string.length(); i++) {\n           \
    \ if(paren_string.charAt(i) == ')')\n                level--;\n            else\
    \ if(paren_string.charAt(i) == '(') {\n                if(stack_of_levels.size()\
    \ <= level) {\n                    stack_of_levels.push(level);\n            \
    \    }\n                level++;\n            } else {\n                if(stack_of_levels.size()\
    \ <= level) {\n                    stack_of_levels.push(level);\n            \
    \    }\n                level--;\n            }\n            if(stack_of_levels.size()\
    \ > max_levels.size()) {\n                max_levels = stack_of_levels;\n    \
    \        }\n        }\n        return max_levels;", "        ArrayList<Integer>\
    \ result = new ArrayList<Integer>();\n        ArrayList<Integer> stack = new ArrayList<Integer>();\n\
    \        String[] arr = paren_string.split(\" \");\n        for(int i=0; i<arr.length;\
    \ i++) {\n            if(\")\".equals(arr[i])) {\n                if(stack.size()\
    \ > 0) {\n                    result.add(stack.size());\n                }\n \
    \               stack.remove(0);\n            } else if(\"(\".length() == arr[i].length())\
    \ {\n                int level_of_nesting = stack.size();\n                while(level_of_nesting\
    \ > 0) {\n                    result.add(level_of_nesting);\n                \
    \    level_of_nesting --;\n                }\n                stack.add(0);\n\
    \            } else {\n                int level_of_nesting = stack.size();\n\
    \                while(level_of_nesting > 0) {\n                    result.add(level_of_nesting);\n\
    \                    level_of_nesting --;\n                }\n               \
    \ stack.add(0);\n                result.add(arr[i].length());\n            }\n\
    \        }\n        return result;", "        // Your code goes here\n       \
    \ int paren_count = paren_string.length();\n        ArrayList<Integer> max_level\
    \ = new ArrayList<Integer>();\n        for (int i = 0; i < paren_count; i++) {\n\
    \            int count = 0;\n            int paren_level = paren_string.charAt(i);\n\
    \            if (paren_level == '(') {\n                count++;\n           \
    \ }\n            if (paren_level == ')') {\n                count--;\n       \
    \     }\n            max_level.add(count);\n        }\n        return max_level;",
  "        ArrayList<Integer> levels = new ArrayList<>();\n        Map<Character,\
    \ Integer> paren_counter = new HashMap<>();\n        for (char c : paren_string.toCharArray())\
    \ {\n            if (paren_counter.containsKey(c)) {\n                paren_counter.put(c,\
    \ paren_counter.get(c) + 1);\n            } else {\n                paren_counter.put(c,\
    \ 1);\n            }\n        }\n        for (Map.Entry<Character, Integer> entry\
    \ : paren_counter.entrySet()) {\n            if (entry.getValue() > 1) {\n   \
    \             for (char d : paren_string.toCharArray()) {\n                  \
    \  if (paren_counter.get(d) > 1) {\n                        paren_counter.put(d,\
    \ paren_counter.get(d) - 1);\n                    }\n                }\n     \
    \           levels.set(levels.size() - 1, paren_counter.get(entry.getKey()));\n\
    \            }\n        }\n        return levels;", "        ArrayList<Integer>\
    \ results = new ArrayList<Integer>();\n\n        // Loop through each group of\
    \ parenthesis.\n        for(int i = 0; i < paren_string.groupCount(); i++) {\n\
    \            // If this group of parenthesis has a level of nesting greater than\
    \ the current result array, set the result array to\n            // the current\
    \ level of nesting and add the current group of parenthesis to it.\n         \
    \   if(paren_string.group(i).groupCount() > results.size()) {\n              \
    \  results.set(results.size(),paren_string.group(i).groupCount());\n         \
    \       results.add(paren_string.group(i).start());\n            }\n        }\n\
    \        return results;", "        ArrayList<Integer> levels = new ArrayList<>();\n\
    \        ArrayList<String> groups = new ArrayList<>();\n\n        for (String\
    \ s : paren_string.split(\" \")) {\n            if (s.isEmpty()) {\n         \
    \       continue;\n            }\n            char first = s.charAt(0);\n    \
    \        if (s.charAt(0) == '(') {\n                groups.add(s);\n         \
    \   }\n            if (s.charAt(0) == ')') {\n                int index = groups.indexOf(s);\n\
    \                levels.add(index - 1);\n                groups.remove(index);\n\
    \            }\n        }\n        return levels;", "        ArrayList<Integer>\
    \ nesting_level = new ArrayList<>();\n        ArrayList<String> groups = Arrays.asList(paren_string.split(\"\
    \ \"));\n        ArrayList<Integer> parentheses_depth = new ArrayList<>();\n \
    \       int index = 0;\n        for (String group : groups) {\n            parenthesis_depth.add(index,\
    \ groups.indexOf(group) + 1);\n            index++;\n        }\n        for (Integer\
    \ i = 0; i < parenthesis_depth.size(); i++) {\n            if (parentheses_depth.get(i)\
    \ > nesting_level.size())\n                nesting_level.add(i, parentheses_depth.get(i));\n\
    \        }\n        return nesting_level;", "        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        if (paren_string.isEmpty()) {\n            return\
    \ levels;\n        }\n        String current_string = \"\";\n        int parens_level\
    \ = 0;\n        for (int i = 0; i < paren_string.length(); i++) {\n          \
    \  if (parens_level == 0) {\n                current_string = paren_string.substring(i,\
    \ i + 1);\n            } else if (paren_string.charAt(i) == '(') {\n         \
    \       levels.add(parens_level);\n                parens_level++;\n         \
    \   } else if (paren_string.charAt(i) == ')') {\n                if (parens_level\
    \ == 0) {\n                    levels.add(parens_level);\n                   \
    \ parens_level++;\n                } else {\n                    parens_level--;\n\
    \                }\n            }\n        }\n        return levels;", "     \
    \   int level = 1;\n        ArrayList<Integer> results = new ArrayList<>();\n\
    \        List<String> input_list = Arrays.asList(paren_string.split(\" \"));\n\
    \        for (int i = 0; i < input_list.size(); i++) {\n            if (input_list.get(i).equals(\"\
    (\")) {\n                results.add(level);\n            } else if (input_list.get(i).equals(\"\
    )\")) {\n                level--;\n            }\n        }\n        return results;",
  "        ArrayList<Integer> paren_levels = new ArrayList<Integer>();\n        ArrayList<String>\
    \ paren_string_list = new ArrayList<String>();\n        paren_string = paren_string.toLowerCase();\n\
    \        paren_string = paren_string.replaceAll(\"\\\\(|\\\\)\", \"\");\n    \
    \    String[] parts = paren_string.split(\" \");\n        for (String part : parts)\
    \ {\n            if (part.length() > 0) {\n                if (part.charAt(0)\
    \ == '(') {\n                    if (paren_string_list.size() > 0) {\n       \
    \                 paren_string_list.get(paren_string_list.size()-1).append(\"\
    )\");\n                    }\n                    paren_string_list.add(part);\n\
    \                } else {\n                    if (paren_string_list.size() >\
    \ 0) {\n                        paren_string_list.get(paren_string_list.size()-1).append(\"\
    (\");\n                    }\n                    paren_string_list.add(part);\n\
    \                }\n            }\n        }\n        // Add paren_levels\n  \
    \      int prev_paren_level = 0;\n        ArrayList<Integer> paren_levels_array\
    \ = new ArrayList<Integer>();\n        paren_string_list.forEach(string -> {\n\
    \            paren_levels_array.add(paren_levels.size());\n            prev_paren_level\
    \ = paren_levels.get(paren_levels.size()-1);\n        });\n        for (int i=paren_levels_array.size()-1;\
    \ i>=0; i--) {\n            paren_levels_array.add(i,(paren_levels.get(i) + prev_paren_level));\n\
    \        }\n        paren_levels.addAll(paren_levels_array);\n        return paren_levels;",
  "        // Create a stack to hold the parenthesis\n        Stack<Character> stack\
    \ = new Stack<>();\n        // Create a map to hold the depth for each of the\
    \ parenthesis\n        Map<Character, Integer> max_depth = new HashMap<>();\n\n\
    \        // Iterate through the string\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            // Get the current char\n            char current_char =\
    \ paren_string.charAt(i);\n            // If the stack is not empty and last character\
    \ is open parenthesis then pop the stack\n            // and increment its depth\n\
    \            if (!stack.isEmpty() && stack.peek() == '(') {\n                max_depth.put('(',\
    \ (max_depth.get('(') == null ? 1 : max_depth.get('(') + 1));\n              \
    \  stack.pop();\n            }\n            // If the stack is not empty and last\
    \ character is close parenthesis then push the stack \n            // and decrement\
    \ its depth\n            if (!stack.isEmpty() && stack.peek() == ')') {\n    \
    \            max_depth.put(')', (max_depth.get('(') == null ? 1 : max_depth.get('(')\
    \ - 1));\n                stack.push(')');\n            }\n            // If the\
    \ stack is not empty and last character is space then push it to the stack\n \
    \           // and increment its depth\n            if (!stack.isEmpty() && stack.peek()\
    \ == ' ') {\n                stack.push(' ');\n                max_depth.put(current_char,\
    \ (max_depth.get(current_char) == null ? 1 : max_depth.get(current_char) + 1));\n\
    \            }\n            // If the stack is not empty and last character is\
    \ any character other than space, open\n            // parenthesis or close parenthesis\
    \ then push it to the stack\n            if (stack.isEmpty() || !stack.isEmpty()\
    \ && (current_char == ' ' || current_char == '(' || current_char == ')')) {\n\
    \                stack.push(current_char);\n            }\n            // If the\
    \ stack is empty or last character is not space or open parenthesis or close parenthesis\
    \ \n            // then set the current parenthesis depth to 1.\n            if\
    \ (stack.isEmpty() || !stack.isEmpty() && current_char != ' ' && current_char\
    \ != '(' && current_char !=')') {\n                max_depth.put(current_char,\
    \ 1);\n            }\n        }\n        // Iterate through the map and add the\
    \ depth for each of the parenthesis\n        ArrayList<Integer> list_of_depths\
    \ = new ArrayList<>();\n        for (Map.Entry<Character, Integer> entry : max_depth.entrySet())\
    \ {\n            list_of_depths.add(entry.getValue());\n        }\n        return\
    \ list_of_depths;", "        if (paren_string.trim().isEmpty()) {\n          \
    \  return new ArrayList<Integer>();\n        }\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        ArrayList<String> group_strings = new ArrayList<>();\n\
    \        // Split the input string into nested parentheses\n        String[] splited_array\
    \ = paren_string.split(\" \");\n        for (String nested_string: splited_array)\
    \ {\n            // Get all characters inside nested parentheses\n           \
    \ ArrayList<String> group_strings = nested_string.trim().split(\"\\\\)|\\\\(\"\
    );\n            // Add all characters to the group strings array\n           \
    \ for (String group_string: group_strings) {\n                if (!group_string.trim().isEmpty())\
    \ {\n                    group_strings.add(group_string);\n                }\n\
    \            }\n            group_strings.trimToSize();\n            // Iterate\
    \ through group strings and find the deepest level of nesting\n            for\
    \ (String group_string: group_strings) {\n                ArrayList<Integer> levels_of_nesting\
    \ = new ArrayList<>();\n                int level = 0;\n                // Iterate\
    \ through characters in the group string\n                for (char c: group_string.toCharArray())\
    \ {\n                    // If this is a new nested level, then increment the\
    \ level by 1\n                    if (c == '(') {\n                        level++;\n\
    \                    }\n                    // If this is a closing parentheses,\
    \ then decrement the level by 1\n                    if (c == ')') {\n       \
    \                 level--;\n                    }\n                    levels_of_nesting.add(level);\n\
    \                }\n                levels_of_nesting.trimToSize();\n        \
    \        // Add the deepest level of nesting to the result array\n           \
    \     for (int level: levels_of_nesting) {\n                    results.add(level);\n\
    \                }\n            }\n        }\n        return results;", "    \
    \    ArrayList<Integer> levels = new ArrayList<Integer>();\n        int startIndex\
    \ = 0;\n        char[] chars = paren_string.toCharArray();\n        while (startIndex\
    \ < chars.length) {\n            boolean foundOpen = false;\n            boolean\
    \ foundClose = false;\n            int openIndex = -1;\n            int closeIndex\
    \ = -1;\n            for (int i = startIndex; i < chars.length; i++) {\n     \
    \           if (chars[i] == '(') {\n                    if (!foundOpen) {\n  \
    \                      openIndex = i;\n                        foundOpen = true;\n\
    \                        continue;\n                    }\n                  \
    \  levels.add(i - 1);\n                }\n                if (chars[i] == ')')\
    \ {\n                    if (!foundClose) {\n                        closeIndex\
    \ = i;\n                        foundClose = true;\n                        continue;\n\
    \                    }\n                    levels.add(i - 1);\n             \
    \   }\n            }\n            if (openIndex >= 0 && closeIndex >= 0) {\n \
    \               levels.add(closeIndex - 1);\n            }\n            startIndex\
    \ = closeIndex + 1;\n        }\n        return levels;", "        ArrayList<Integer>\
    \ result = new ArrayList<>();\n        StringBuilder temp_buf = new StringBuilder(paren_string);\n\
    \        char[] paren_chars = paren_string.toCharArray();\n        int open_brackets_cnt\
    \ = 0;\n        // Iterate over all the characters in the input string\n     \
    \   for (int i = 0; i < paren_chars.length; i++) {\n            if (paren_chars[i]\
    \ == '(') {\n                open_brackets_cnt++;\n            } else if (paren_chars[i]\
    \ == ')') {\n                open_brackets_cnt--;\n            }\n           \
    \ // Handle the closing bracket when open_brackets_cnt becomes 0\n           \
    \ if (open_brackets_cnt == 0) {\n                result.add(temp_buf.length());\n\
    \                temp_buf.setLength(0);\n            }\n            temp_buf.append(paren_chars[i]);\n\
    \        }\n        return result;", "        int counter = 0;\n        ArrayList<Integer>\
    \ levels = new ArrayList<Integer>();\n        for (String par : paren_string.split(\"\
    \ \")) {\n            counter = 0;\n            while (true) {\n             \
    \   if (paren_string.charAt(counter) == '(')\n                    counter++;\n\
    \                else if (paren_string.charAt(counter) == ')')\n             \
    \       counter++;\n                else if (paren_string.charAt(counter) != '('\
    \ && paren_string.charAt(counter) != ')')\n                    break;\n      \
    \          else\n                    counter++;\n            }\n            levels.add(counter);\n\
    \        }\n        return levels;", "        ArrayList<Integer> levels = new\
    \ ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \        StringTokenizer st = new StringTokenizer(paren_string, \" ()\");\n  \
    \      while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n\
    \            if (token.equals(\"(\")) {\n                stack.push(1);\n    \
    \        } else if (token.equals(\")\")) {\n                int popped_level =\
    \ stack.pop();\n                levels.add(popped_level + 1);\n            }\n\
    \        }\n        return levels;", "        ArrayList<Integer> level = new ArrayList<>();\n\
    \        // find out how many levels of nesting there are\n        int number_of_levels\
    \ = paren_string.length() - paren_string.replace(\"(\", \"\").replace(\")\", \"\
    \").length() + 1;\n        // find the level of each opening parenthesis\n   \
    \     ArrayList<Integer> opening_levels = new ArrayList<>();\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                opening_levels.add(i);\n            }\n        }\n\
    \        ArrayList<Integer> opening_levels_copy = new ArrayList<>(opening_levels);\n\
    \        for (int i = number_of_levels; i < paren_string.length(); i++) {\n  \
    \          if (paren_string.charAt(i) == ')') {\n                opening_levels_copy.remove(i);\n\
    \            }\n        }\n        opening_levels = opening_levels_copy;\n   \
    \     // find out how many closing parenthesis there are for each level\n    \
    \    ArrayList<Integer> closing_levels = new ArrayList<>(opening_levels.size());\n\
    \        for (int i = 0; i < opening_levels.size(); i++) {\n            closing_levels.add(0,\
    \ opening_levels.get(opening_levels.size() - 1 - i));\n        }\n        // find\
    \ the level of each closing parenthesis\n        for (int i = opening_levels.size()\
    \ - 1; i >= 0; i--) {\n            if (paren_string.charAt(paren_string.length()\
    \ - 1 - i) == ')') {\n                closing_levels.add(i);\n            }\n\
    \        }\n        ArrayList<Integer> closing_levels_copy = new ArrayList<>(closing_levels);\n\
    \        // count how many times the closing parenthesis occurs for each level\n\
    \        ArrayList<Integer> closing_counts = new ArrayList<>(closing_levels_copy);\n\
    \        for (int i = 0; i < closing_levels.size(); i++) {\n            closing_counts.set(i,\
    \ closing_counts.get(closing_levels.size() - 1 - i) + 1);\n        }\n       \
    \ // traverse from the outer level and find the max number of levels for each\
    \ parenthesis\n        ArrayList<Integer> max_levels = new ArrayList<>();\n  \
    \      for (int i = 0; i < opening_levels.size(); i++) {\n            int j =\
    \ 0;\n            for (int j = 0; j < closing_levels.size() && j < opening_levels.size()\
    \ - 1; j++) {\n                if (opening_levels.get(i) < closing_levels.get(j))\
    \ {\n                    break;\n                }\n            }\n          \
    \  ArrayList<Integer> level_copy = new ArrayList<>(opening_levels.size());\n \
    \           for (int j = 0; j < level_copy.size(); j++) {\n                level_copy.set(j,\
    \ (opening_levels.get(i) + j));\n            }\n            int level_max = level_copy.size();\n\
    \            if (level_max > max_levels.size()) {\n                max_levels\
    \ = level_copy;\n            }\n        }\n        // traverse from the inner\
    \ level and find the max number of levels for each parenthesis\n        for (int\
    \ i = 0; i < opening_", "        ArrayList<Integer> result = new ArrayList<Integer>();\n\
    \        int i = 0;\n        // Find all the left parenthesis\n        while (i\
    \ < paren_string.length() && paren_string.charAt(i) == '(') {\n            i++;\n\
    \        }\n        // Find all the right parenthesis\n        while (i < paren_string.length()\
    \ && paren_string.charAt(i) == ')') {\n            result.add(i);\n          \
    \  i++;\n        }\n        // Find all the right parenthesis\n        while (i\
    \ < paren_string.length() && paren_string.charAt(i) == ')') {\n            i++;\n\
    \        }\n        // Add how many right parenthesis we've found\n        result.add(paren_string.length());\n\
    \        return result;", "        ArrayList<Integer> levels = new ArrayList<>();\n\
    \        int open_levels = 0;\n        for (char ch: paren_string.toCharArray())\
    \ {\n            if (ch == '(')\n                open_levels++;\n            if\
    \ (ch == ')')\n                open_levels--;\n            if (open_levels ==\
    \ 0)\n                levels.add(levels.size());\n        }\n        return levels;",
  "        ArrayList<Integer> res = new ArrayList<>();\n        ArrayList<String>\
    \ list = new ArrayList<>();\n        int i = 0;\n        int depth = 0;\n    \
    \    int j = 0;\n        for (char c : paren_string.toCharArray()) {\n       \
    \     if (c == '(') {\n                depth++;\n                list.add((\"\"\
    \ + depth));\n            } else if (c == ')') {\n                depth--;\n \
    \               list.add((\"\" + depth));\n            }\n            if (depth\
    \ == 0 && list.size() > 0) {\n                res.add(Integer.parseInt(list.get(list.size()\
    \ - 1)));\n                depth = 0;\n                list.clear();\n       \
    \     }\n            i++;\n        }\n        return res;", "        ArrayList<Integer>\
    \ levels = new ArrayList<Integer>();\n        Matcher matcher = Pattern.compile(\"\
    \\\\(([\\\\w()]+[\\\\w()]*)+\\\\)\").matcher(paren_string);\n        while (matcher.find())\
    \ {\n            String group_of_pars = matcher.group(1);\n            String[]\
    \ pars_array = group_of_pars.split(\"[()]\");\n            int min_par_count =\
    \ Math.min(pars_array.length, levels.size());\n            for (int i = 0; i <\
    \ min_par_count; i++) {\n                if (pars_array[i].equals(pars_array[i\
    \ - 1])) {\n                    levels.add(i + 1);\n                    break;\n\
    \                }\n            }\n        }\n        return levels;", "     \
    \   ArrayList<Integer> list_of_levels = new ArrayList<Integer>();\n        ArrayList<String>\
    \ list_of_groups = new ArrayList<String>();\n        String[] string_array = paren_string.split(\"\
    \ \");\n        for (int i = 0; i < string_array.length; i++) {\n            if\
    \ (string_array[i].startsWith(\"(\") || string_array[i].startsWith(\")\") || string_array[i].equals(\"\
    )\")) {\n                list_of_groups.add(string_array[i]);\n            } else\
    \ {\n                list_of_levels.add(string_array[i].length());\n         \
    \   }\n        }\n        List<List<Integer>> list_of_levels_to_levels = new ArrayList<List<Integer>>();\n\
    \        List<String> list_of_groups_to_levels = new ArrayList<String>();\n  \
    \      for (int i = 0; i < list_of_levels.size(); i++) {\n            String group\
    \ = list_of_groups.get(i);\n            int group_level = list_of_levels.get(i);\n\
    \            if (list_of_levels_to_levels.get(list_of_levels.size() - 1) != null)\
    \ {\n                list_of_levels_to_levels.get(list_of_levels.size() - 1).add(group_level);\n\
    \            } else {\n                List<Integer> levels_to_levels = new ArrayList<Integer>();\n\
    \                levels_to_levels.add(group_level);\n                list_of_levels_to_levels.add(levels_to_levels);\n\
    \            }\n            list_of_groups_to_levels.add(group);\n        }\n\
    \        list_of_groups_to_levels.forEach(group -> {\n            List<Integer>\
    \ levels_to_levels = list_of_levels_to_levels.get(list_of_groups_to_levels.indexOf(group));\n\
    \            System.out.println(Arrays.toString(levels_to_levels.toArray()));\n\
    \        });\n        Arrays.sort(list_of_levels_to_levels);\n        return list_of_levels_to_levels;",
  "        ArrayList<Integer> nesting_levels = new ArrayList<Integer>();\n       \
    \ \n        ArrayList<String> strings = Arrays.asList(paren_string.split(\" \"\
    ));\n        for (String string : strings) {\n            List<String> list_string\
    \ = Arrays.asList(string.split(\"(\"));\n            String opening_par = list_string.get(0).replace(\"\
    )\", \"\");\n            String closing_par = list_string.get(list_string.size()-1);\n\
    \            \n            String opening_par2 = list_string.get(0).replace(\"\
    )\", \"\");\n            String closing_par2 = list_string.get(list_string.size()-1);\n\
    \            String opening_par3 = list_string.get(0).replace(\")\", \"\");\n\
    \            String closing_par3 = list_string.get(list_string.size()-1);\n  \
    \          \n            int opening_par_count = list_string.size() - 1;\n   \
    \         int opening_par2_count = list_string.size() - 1;\n            int opening_par3_count\
    \ = list_string.size() - 1;\n            \n            if (list_string.size()\
    \ > 1){\n                for (int i = 1; i < list_string.size() - 1; i++){\n \
    \                   opening_par_count = opening_par_count + 1;\n             \
    \       opening_par2_count = opening_par2_count + 1;\n                    opening_par3_count\
    \ = opening_par3_count + 1;\n                }\n            }\n            \n\
    \            String str2 = opening_par.trim();\n            \n            int\
    \ new_count = opening_par_count;\n            int new_count2 = opening_par2_count;\n\
    \            int new_count3 = opening_par3_count;\n            \n            if\
    \ (new_count != new_count2 || new_count != new_count3) {\n                if (new_count\
    \ > new_count2 || new_count > new_count3) {\n                    nesting_levels.add(new_count);\n\
    \                    nesting_levels.add(new_count2);\n                    nesting_levels.add(new_count3);\n\
    \                }\n                else if (new_count2 > new_count3) {\n    \
    \                nesting_levels.add(new_count);\n                    nesting_levels.add(new_count2);\n\
    \                    nesting_levels.add(new_count3);\n                }\n    \
    \            else if (new_count3 > new_count) {\n                    nesting_levels.add(new_count);\n\
    \                    nesting_levels.add(new_count2);\n                    nesting_levels.add(new_count3);\n\
    \                }\n            }\n            \n            String str3 = closing_par.trim();\n\
    \            \n            int new_count4 = opening_par_count;\n            int\
    \ new_count5= opening_par2_count;\n            int new_count6= opening_par3_count;\n\
    \            \n            if (new_count4 != new_count5 || new_count4 != new_count6)\
    \ {\n                if (new_count4 > new_", "        ArrayList<Integer> max_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<String> nesting_strings = new\
    \ ArrayList<String>();\n        ArrayList<Integer> levels = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> nesting_levels = new ArrayList<Integer>();\n     \
    \   ArrayList<String> tokens = new ArrayList<String>();\n        ArrayList<Integer>\
    \ stack = new ArrayList<Integer>();\n        ArrayList<Integer> temp_max_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> temp_nesting_levels\
    \ = new ArrayList<Integer>();\n        boolean in_parantheses = false;\n     \
    \   boolean in_nested_parantheses = false;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            String char_at_i = paren_string.substring(i, i + 1);\n \
    \           if (in_parantheses && char_at_i.equals(\"(\")) {\n               \
    \ nesting_strings.add(char_at_i);\n                nesting_levels.add(nesting_levels.size());\n\
    \                temp_nesting_levels.add(nesting_levels.size() - 1);\n       \
    \         levels.add(nesting_levels.size());\n                in_parantheses =\
    \ false;\n            } else if (in_parantheses && !char_at_i.equals(\"(\")) {\n\
    \                nesting_strings.add(char_at_i);\n                nesting_levels.add(nesting_levels.size());\n\
    \                temp_nesting_levels.add(nesting_levels.size() - 1);\n       \
    \         levels.add(nesting_levels.size());\n                in_parantheses =\
    \ false;\n            } else if (char_at_i.equals(\"(\")) {\n                levels.add(nesting_levels.size());\n\
    \                nesting_levels.add(nesting_levels.size());\n                in_parantheses\
    \ = true;\n            } else if (!char_at_i.equals(\")\")) {\n              \
    \  tokens.add(char_at_i);\n            } else if (char_at_i.equals(\")\")) {\n\
    \                if (nesting_levels.size() == levels.size()) {\n             \
    \       temp_nesting_levels.add(nesting_levels.size() - 1);\n                }\
    \ else {\n                    int current_level = nesting_levels.get(nesting_levels.size()\
    \ - 1);\n                    int expected_level = levels.get(nesting_levels.size()\
    \ - 1);\n                    if (expected_level == current_level) {\n        \
    \                temp_nesting_levels.add(nesting_levels.size() - 1);\n       \
    \             }\n                }\n                nesting_levels.remove(nesting_levels.size()\
    \ - 1);\n            }\n        }\n        for (int i = 1; i < nesting_levels.size();\
    \ i++) {\n            int current_level = nesting_levels.get(nesting_levels.size()\
    \ - i);\n            int expected_level = levels.get(nesting_levels.size() - i);\n\
    \            if (expected_level == current_level) {\n                temp_max_levels.add(current_level);\n\
    \            }\n        }\n        for (int i = 1; i < nesting_levels.size();\
    \ i++) {\n            if (nesting_levels.get(nesting_levels.size() - i) == temp_max_levels.get(0))\
    \ {\n                temp_max_levels.set(temp_max_level", "        ArrayList<Integer>\
    \ nesting_stack = new ArrayList<Integer>();\n\n        StringTokenizer st = new\
    \ StringTokenizer(paren_string);\n        String current_paren = null;\n     \
    \   while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n\
    \            switch(token) {\n                case \"(\":\n                  \
    \  nesting_stack.add(nesting_stack.size());\n                    current_paren\
    \ = token;\n                    break;\n                case \")\":\n        \
    \            nesting_stack.remove(nesting_stack.size() - 1);\n               \
    \     current_paren = token;\n                    break;\n            }\n    \
    \    }\n        return nesting_stack;", "        String[] parts = paren_string.split(\"\
    \ \");\n        ArrayList<Integer> results = new ArrayList<>();\n        for (String\
    \ part : parts) {\n            results = results.stream()\n                  \
    \  .flatMap(x -> parseNestedParens(x))\n                    .collect(toList());\n\
    \        }\n        return results;", "        ArrayList<Integer> result = new\
    \ ArrayList<>();\n        for (int i = 0; i < paren_string.length(); i++) {\n\
    \            char c = paren_string.charAt(i);\n            if (c == ' ') {\n \
    \               // Ignore whitespace\n                while (i < paren_string.length()\
    \ && paren_string.charAt(i) == ' ')\n                    i++;\n            } else\
    \ if (c == '(') {\n                // Add one level of nesting\n             \
    \   result.add(i);\n            } else if (c == ')') {\n                // Remove\
    \ one level of nesting\n                result.remove(i + 1);\n            } else\
    \ {\n                break;\n            }\n        }\n        return result;",
  "        ArrayList<Integer> levels = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ temp = new ArrayList<Integer>();\n\n        // Initialize all levels to zero.\n\
    \        for(int i = 0; i< levels.size();i++) {\n            levels.add(0);\n\
    \        }\n\n        // Parse the string and add the levels of nesting to levels.\n\
    \        for(int i = 1; i<paren_string.length(); i++) {\n            // Skip spaces.\n\
    \            if(paren_string.charAt(i) == ' ') {\n                i++;\n     \
    \           continue;\n            }\n\n            // Get the opening paren level.\n\
    \            int open_paren_level = paren_string.charAt(i) - '0';\n\n        \
    \    // If the level is zero, then ignore it.\n            if(open_paren_level\
    \ == 0) {\n                i++;\n                continue;\n            }\n\n\
    \            // If the level is greater than the maximum level of nesting then\
    \ ignore it.\n            if(levels.get(open_paren_level) > levels.size()) {\n\
    \                i++;\n                continue;\n            }\n\n          \
    \  // If the level is less than the minimum level of nesting, then ignore it.\n\
    \            if(levels.get(open_paren_level) < levels.size()) {\n            \
    \    i++;\n                continue;\n            }\n\n            // Add the\
    \ level of nesting to levels at this level.\n            levels.add(open_paren_level);\n\
    \n            // Skip to the next character.\n            i++;\n        }\n\n\
    \        // Get the deepest level of nesting.\n        int deepest_level = levels.get(levels.size()-1);\n\
    \n        // Reverse the array. Because the deepest level is higher than the deepest\
    \ level of nesting from the beginning,\n        // we want to reverse the array\
    \ to get the highest level of nesting from the beginning to lowest.\n        Collections.reverse(levels);\n\
    \n        // Return the array that contains the deepest level of nesting.\n  \
    \      return levels;", "        int max_level = 0;\n        int max_level_count\
    \ = 0;\n        ArrayList<Integer> level_array = new ArrayList<Integer>();\n \
    \       ArrayList<Integer> level_count_array = new ArrayList<Integer>();\n   \
    \     ArrayList<Integer> max_level_level_array = new ArrayList<Integer>();\n\n\
    \        // Add max_level and max_level_count to the level_array\n        // and\
    \ level_count_array respectively\n        int level = 0;\n        int level_count\
    \ = 0;\n        for (int i = 0; i < paren_string.length(); i++) {\n          \
    \  char c = paren_string.charAt(i);\n            if ((c == '(') || (c == ')'))\
    \ {\n                // Add 1 to the level counter\n                level_count++;\n\
    \                level_array.add(level);\n                level_count_array.add(level_count);\n\
    \                // If the max level count is greater than the current\n     \
    \           // level count, update the max_level_count with the level\n      \
    \          // count\n                if (level_count > max_level_count) {\n  \
    \                  max_level_count = level_count;\n                    max_level\
    \ = level;\n                }\n            } else {\n                level++;\n\
    \            }\n        }\n\n        // Add max_level and max_level_count to the\
    \ level_array\n        // and level_count_array respectively\n        max_level_level_array.add(max_level);\n\
    \        max_level_level_array.add(max_level_count);\n        return max_level_level_array;",
  "        ArrayList<Integer> ans = new ArrayList<Integer>();\n        ArrayList<String>\
    \ paren_strings = new ArrayList<String>();\n        paren_strings.add(paren_string);\n\
    \        paren_strings.add(paren_string);\n        int level = 1;\n        while(paren_strings.size()\
    \ > 0) {\n            String s = paren_strings.get(0);\n            paren_strings.remove(0);\n\
    \            int index = paren_strings.indexOf(s);\n            ans.add(level);\n\
    \            level++;\n            if(index == -1) {\n                paren_strings.add(s);\n\
    \                level++;\n                index = paren_strings.indexOf(s);\n\
    \            }\n            for(int i = 1; i < index; i++) {\n               \
    \ String ss = paren_strings.get(i);\n                paren_strings.remove(i);\n\
    \                int index2 = paren_strings.indexOf(ss);\n                for(int\
    \ j = 1; j < (index2 - i); j++) {\n                    ans.add(level);\n     \
    \               level++;\n                }\n                paren_strings.add(ss);\n\
    \                level++;\n            }\n        }\n        return ans;", " \
    \       // Use recursion :)\n        return parseNestedParens(paren_string, 0,\
    \ paren_string.length(), new ArrayList<Integer>());", "        ArrayList<Integer>\
    \ max_level = new ArrayList<Integer>();\n        int level = 0;\n        int level_count\
    \ = 0;\n        int i = 0;\n        do {\n            if (i == paren_string.length())\n\
    \                return max_level;\n\n            if (paren_string.charAt(i) ==\
    \ ' ') {\n                level_count++;\n                level++;\n         \
    \   }\n\n            else if (paren_string.charAt(i) == '(') {\n             \
    \   level_count++;\n                level++;\n            }\n\n            else\
    \ if (paren_string.charAt(i) == ')') {\n                level_count--;\n     \
    \           level--;\n            }\n            i++;\n        } while (level_count\
    \ > 0 && level > 0);\n        max_level.add(level);\n        return max_level;",
  "        ArrayList<Integer> paren_list_in_str = new ArrayList<Integer>();\n    \
    \    paren_list_in_str.add(1);\n        int depth = 1;\n        int i;\n     \
    \   for(i=0; i < paren_string.length(); i++){\n            if(paren_string.charAt(i)\
    \ == '('){\n                paren_list_in_str.add(depth);\n                depth++;\n\
    \            }\n            else if(paren_string.charAt(i) == ')'){\n        \
    \        if(paren_list_in_str.get(depth - 1) > paren_list_in_str.get(depth)){\n\
    \                    paren_list_in_str.remove(depth - 1);\n                }\n\
    \                depth--;\n            }\n        }\n        return paren_list_in_str;",
  "        ArrayList<Integer> deepest_level_of_nesting = new ArrayList<>();\n\n  \
    \      for (int i = 0; i < paren_string.length(); i++) {\n            char c =\
    \ paren_string.charAt(i);\n            char next_c = paren_string.charAt(i + 1);\n\
    \n            if (c == '(' && next_c == ')') {\n                deepest_level_of_nesting.add(0);\n\
    \                i++;\n            } else {\n                deepest_level_of_nesting.add(deepest_level_of_nesting.size());\n\
    \            }\n        }\n\n        return deepest_level_of_nesting;", "    \
    \    ArrayList<Integer> levels = new ArrayList<Integer>();\n        Stack<Integer>\
    \ s = new Stack<Integer>();\n        int level = 0;\n\n        for (int i = 0;\
    \ i < paren_string.length(); ++i) {\n            char c = paren_string.charAt(i);\n\
    \            if (c == '(')\n                s.push(-level);\n            if (c\
    \ == ')')\n                level = Math.max(level, s.pop());\n            levels.add(level);\n\
    \        }\n        return levels;", "        ArrayList<Integer> nested_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> deepest_levels_of_parens\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> groups = new ArrayList<Integer>();\n\
    \        boolean in_parens = false;\n        int nesting_level = 0;\n\n      \
    \  for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') in_parens = true;\n            if (paren_string.charAt(i) == ')') in_parens\
    \ = false;\n\n            if (in_parens) {\n                nesting_level++;\n\
    \                if (nesting_level == 2) {\n                    nested_levels.add(nesting_level);\n\
    \                }\n\n                if (nesting_level > deepest_levels_of_parens.size())\
    \ {\n                    deepest_levels_of_parens.add(nesting_level);\n      \
    \          }\n            }\n            else {\n                nesting_level--;\n\
    \            }\n\n            if (in_parens && nesting_level == 0) {\n       \
    \         groups.add(groups.size());\n            }\n        }\n\n        for\
    \ (int i = 0; i < deepest_levels_of_parens.size(); i++) {\n            for (int\
    \ j = 0; j < groups.size(); j++) {\n                if (groups.get(j) == deepest_levels_of_parens.get(i))\
    \ {\n                    nested_levels.add(j);\n                    break;\n \
    \               }\n            }\n        }\n\n        return nested_levels;",
  "        ArrayList<Integer> result = new ArrayList<Integer>();\n        HashSet<String>\
    \ set_string = new HashSet<String>();\n        HashSet<String> set_paren_string\
    \ = new HashSet<String>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if(c == '('\
    \ || c == '[' || c == '{' || c == '<' || c == '>') {\n                set_string.add(String.valueOf(c));\n\
    \                set_paren_string.add(String.valueOf(paren_string.charAt(i)));\n\
    \            } else if(c != ')' && c != ']' && c != '}' && c != '>' && c != '<')\
    \ {\n                set_string.add(String.valueOf(c));\n                set_paren_string.add(String.valueOf(paren_string.charAt(i)));\n\
    \            }\n        }\n        \n        while(set_string.size() > 0 && set_paren_string.size()\
    \ > 0) {\n            String temp = set_string.remove(set_string.size() - 1);\n\
    \            String temp_2 = set_paren_string.remove(set_paren_string.size() -\
    \ 1);\n            if(temp.equalsIgnoreCase(temp_2)) {\n                result.add(Integer.valueOf(temp.charAt(0)));\n\
    \            } else {\n                result.add(Integer.valueOf(temp.charAt(0)));\n\
    \                result.add(Integer.valueOf(temp_2.charAt(0)));\n            }\n\
    \        }\n        \n        return result;", "        // Convert the string\
    \ to a list to support recursive functions\n        ArrayList<Integer> parens_list\
    \ = Arrays.asList(paren_string.split(\" \"));\n        Arrays.sort(parens_list);\n\
    \        int index = 0;\n        int current_level = parens_list.get(index++);\n\
    \        int max_level = 0;\n        while (index < parens_list.size()) {\n  \
    \          if (parens_list.get(index).equals(current_level)) {\n             \
    \   index++;\n                current_level = parens_list.get(index++);\n    \
    \        } else {\n                // Keep the current level and the max level\n\
    \                if (current_level < max_level) {\n                    max_level\
    \ = current_level;\n                }\n                index++;\n            \
    \    current_level = parens_list.get(index++);\n            }\n        }\n   \
    \     ArrayList<Integer> result = new ArrayList<>();\n        for (int i = 0;\
    \ i <= max_level; i++) {\n            result.add(i);\n        }\n        return\
    \ result;", "        ArrayList<Integer> result = new ArrayList<>();\n        stack<int>\
    \ paren_stack = new stack<int>();\n        paren_stack.push(0);\n        for (int\
    \ i = 0; i < paren_string.length(); ++i) {\n            int ch = paren_string.charAt(i);\n\
    \            if (ch == '(') {\n                while (paren_stack.empty() == false\
    \ && paren_stack.top() >= paren_string.length()) {\n                    --paren_stack.top();\n\
    \                }\n                paren_stack.push(paren_string.length());\n\
    \            } else if (ch == ')') {\n                while (paren_stack.empty()\
    \ == false && paren_stack.top() <= 0) {\n                    ++paren_stack.top();\n\
    \                }\n                paren_stack.pop();\n            }\n      \
    \      else if (ch == ' ') {\n                if (paren_stack.empty() == false)\
    \ {\n                    --paren_stack.top();\n                }\n           \
    \ }\n            if (paren_stack.empty() == false)\n                result.add(paren_stack.top());\n\
    \        }\n        return result;", "        ArrayList<Integer> max_level = new\
    \ ArrayList<Integer>();\n        // We first need a stack of parens.\n       \
    \ Stack<String> parens = new Stack<String>();\n        // We will store the level\
    \ of nesting for each parens pushed.\n        ArrayList<Integer> nesting_level\
    \ = new ArrayList<Integer>();\n        // If we have an empty string\n       \
    \ if (paren_string == null || paren_string.length() == 0) {\n            return\
    \ max_level;\n        }\n        String[] tokens = paren_string.split(\" \");\n\
    \        Arrays.stream(tokens)\n                .filter(t -> !t.isEmpty())\n \
    \               .forEach(t -> {\n                    // If there are brackets\
    \ present then we will push them to stack and ignore them.\n                 \
    \   if (t.contains(\"(\") || t.contains(\")\")) {\n                        parens.push(t);\n\
    \                    } else {\n                        nesting_level.add(Integer.parseInt(t));\n\
    \                    }\n                });\n\n        // We will be doing two\
    \ nested loops.\n        for (int i = 0; i < nesting_level.size(); i++) {\n  \
    \          // For every level we will be doing one more nested loop for popping\
    \ the parentheses.\n            for (int j = 0; j < nesting_level.get(i); j++)\
    \ {\n                String temp;\n                // For each parentheses we\
    \ will be doing one more nested loop.\n                for (int k = parens.size();\
    \ k > 0; k--) {\n                    temp = parens.pop();\n                  \
    \  // If we have encountered a parentheses then we will push the string to the\
    \ stack again.\n                    if (temp.contains(\"(\") || temp.contains(\"\
    )\")) {\n                        parens.push(temp);\n                    } else\
    \ {\n                        nesting_level.add(Integer.parseInt(temp));\n    \
    \                }\n                }\n            }\n        }\n\n        nesting_level.remove(nesting_level.size()-1);\n\
    \        // We will add the level of nesting for last parens.\n        max_level.add(nesting_level.get(0));\n\
    \        // For the first level of nesting we will do one more nested loop for\
    \ popping the parentheses.\n        for (int k = 1; k < nesting_level.size();\
    \ k++) {\n            String temp;\n            for (int j = 0; j < nesting_level.get(k);\
    \ j++) {\n                temp = parens.pop();\n                if (temp.contains(\"\
    (\") || temp.contains(\")\")) {\n                    parens.push(temp);\n    \
    \            } else {\n                    nesting_level.add(Integer.parseInt(temp));\n\
    \                }\n            }\n        }\n        return max_level;", "  \
    \      ArrayList<Integer> nesting = new ArrayList<>();\n        for (String s\
    \ : paren_string.trim().replaceAll(\" +\", \" \").split(\"\\\\(|\\\\)\")) {\n\
    \            if (s.contains(\"(\")) {\n                int depth = parseNestedParens(s).getMax();\n\
    \                nesting.add(depth);\n            }\n        }\n        return\
    \ nesting;", "        ArrayList<Integer> level_of_nesting = new ArrayList<>();\n\
    \        if (paren_string.contains(\")\")) {\n            level_of_nesting.add(1);\n\
    \        }\n        int depth = 1;\n        for (int i = paren_string.length()\
    \ - 1; i >= 0; --i) {\n            if (paren_string.charAt(i) == '(') {\n    \
    \            ++level_of_nesting.get(depth);\n            }\n            if (paren_string.charAt(i)\
    \ == ')') {\n                if (level_of_nesting.get(depth) == 1) {\n       \
    \             level_of_nesting.set(depth, 0);\n                } else {\n    \
    \                --level_of_nesting.get(depth);\n                }\n         \
    \   }\n        }\n        return level_of_nesting;", "        ArrayList<Integer>\
    \ levels = new ArrayList<Integer>();\n        char[] parens = paren_string.toCharArray();\n\
    \        int i = parens.length - 1;\n        while (i > 0) {\n            int\
    \ j = i;\n            while (j < parens.length && parens[j] == ')') {\n      \
    \          j++;\n            }\n            if (j == parens.length) break;\n \
    \           levels.add(parens.length - j);\n            i = j - 1;\n        }\n\
    \        return levels;", "        if (paren_string.trim().isEmpty()) throw new\
    \ IllegalArgumentException(\"Bad paren_string: empty string\");\n        if (paren_string.trim().length()\
    \ < 3) throw new IllegalArgumentException(\"Bad paren_string: string too small\"\
    );\n        HashMap<Integer, HashMap<Integer, Integer>> pairs = new HashMap<>();\n\
    \        // for each character in the input string\n        for (char c: paren_string.toCharArray())\
    \ {\n            int depth = 1;\n            if (c == '(') depth++;\n        \
    \    if (c == ')') depth--;\n            // if the character is parenthesis, increment\
    \ or decrement depth\n            if (depth > 0) {\n                Integer current_depth\
    \ = pairs.getOrDefault(depth, new HashMap<>());\n                current_depth.put(c,\
    \ 1);\n                pairs.put(depth, current_depth);\n            } else {\n\
    \                if (pairs.containsKey(depth)) {\n                    Integer\
    \ current_depth = pairs.get(depth);\n                    Integer current_count\
    \ = current_depth.get(c);\n                    if (current_count == null) current_count\
    \ = 0;\n                    current_depth.put(c, current_count + 1);\n       \
    \         }\n            }\n        }\n        // Find the max depth of nesting\
    \ in the parenthesis.\n        Integer max_depth = -1;\n        for (Map.Entry<Integer,\
    \ Map<Integer, Integer>> entry : pairs.entrySet()) {\n            if (entry.getValue().size()\
    \ > max_depth) max_depth = entry.getKey();\n        }\n        // Create a list\
    \ with each element of the maximum depth map.\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        for (Map.Entry<Integer, Map<Integer, Integer>>\
    \ entry : pairs.entrySet()) {\n            if (max_depth == entry.getKey()) results.add(entry.getValue().size());\n\
    \        }\n        return results;", "        if (paren_string.length() == 0)\
    \ return new ArrayList<Integer>(0);\n\n        List<Integer> nesting_levels =\
    \ new ArrayList<>();\n\n        // We use the string builder to build each level.\n\
    \        StringBuilder builder_level = new StringBuilder();\n        StringBuilder\
    \ builder_current = new StringBuilder();\n\n        // We use the stack to track\
    \ the nested levels\n        Deque<Integer> stack_current = new ArrayDeque<>();\n\
    \n        // The string builder with the previous level is used as\n        //\
    \ the parent level\n        stack_current.add(0);\n        builder_level.append(paren_string);\n\
    \n        // While the builder level is not empty\n        while (builder_level.length()\
    \ != 0) {\n\n            // If the builder has already been built\n          \
    \  if (builder_current.length() != 0) {\n\n                // Remove the left\
    \ parenthesis off the builder level\n                builder_level.remove(0);\n\
    \                builder_current.remove();\n\n                // If the builder\
    \ level is not empty\n                if (builder_level.length() != 0) {\n   \
    \                 int levels_to_add = stack_current.size();\n                \
    \    int nest_level = builder_level.length() - builder_current.length();\n   \
    \                 int stack_top = stack_current.size() - 1;\n\n              \
    \      // If the level to add is less than the stack top\n                   \
    \ // then add the level\n                    if (levels_to_add < stack_top) {\n\
    \                        stack_current.add(nest_level);\n                    }\
    \ else {\n                        // Else remove the level and add it to the stack\n\
    \                        stack_current.remove(stack_top);\n                  \
    \      stack_current.add(nest_level);\n                    }\n               \
    \ }\n            }\n\n            // If the builder level is not empty\n     \
    \       if (builder_level.length() != 0) {\n                int levels_to_add\
    \ = stack_current.size();\n                int nest_level = builder_level.length()\
    \ - builder_current.length();\n                int stack_top = stack_current.size()\
    \ - 1;\n\n                // If the level to add is less than the stack top\n\
    \                // then add the level\n                if (levels_to_add < stack_top)\
    \ {\n                    stack_current.add(nest_level);\n                } else\
    \ {\n                    // Else remove the level and add it to the stack\n  \
    \                  stack_current.remove(stack_top);\n                    stack_current.add(nest_level);\n\
    \                }\n            }\n\n            // We add the level to the nest\
    \ levels list\n            nesting_levels.add(stack_current.size());\n       \
    \ }\n\n        return nesting_levels;", "        ArrayList<Integer> level_of_nesting\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> nested_parens_index\
    \ = new ArrayList<Integer>();\n        ArrayList<String> paren_strings = new ArrayList<String>();\n\
    \n        int index = 0;\n        while (index < paren_string.length()) {\n  \
    \          paren_strings.add(paren_string.substring(index, index + 1));\n    \
    \        index = paren_string.indexOf('(', index + 1);\n        }\n\n        for\
    \ (String s : paren_strings) {\n            paren_string = paren_string.replaceAll(s,\
    \ \"\");\n            paren_string = paren_string.replaceAll(\"\\\\(\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\)\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\[\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\]\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\{\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\}\"\
    , \"\");\n            paren_string = paren_string.replaceAll(\"\\\\,\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\|\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\!\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\<\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\>\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\+\"\
    , \"\");\n            paren_string = paren_string.replaceAll(\"\\\\*\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\-\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\/\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\?\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\;\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\^\"\
    , \"\");\n            paren_string = paren_string.replaceAll(\"\\\\~\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\=\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\!\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\.\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\.\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\*\"\
    , \"\");\n            paren_string = paren_string.replaceAll(\"\\\\+\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\(\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\)\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\[\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\]\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\{\"\
    , \"\");\n            paren_string", "        ArrayList<Integer> levels = new\
    \ ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \n        // Traverse the input string level by level\n        for(int i = 0;\
    \ i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \n            // If open parenthesis, push it to stack\n            if(c == '(')\
    \ {\n                stack.add(i);\n            }\n\n            // If close parenthesis,\
    \ pop levels to array\n            if(c == ')') {\n                while(!stack.isEmpty())\
    \ {\n                    levels.add(stack.pop());\n                }\n       \
    \         stack = new Stack<Integer>();\n            }\n\n            // If comma\
    \ or closing bracket and stack is not empty\n            if(c != ',' && c != ')'\
    \ && !stack.isEmpty()) {\n                stack.add(i);\n            }\n     \
    \   }\n\n        // Pop levels to array\n        while(!stack.isEmpty()) {\n \
    \           levels.add(stack.pop());\n        }\n\n        return levels;", " \
    \       ArrayList<Integer> level_of_nesting = new ArrayList<>();\n        if (paren_string.length()\
    \ == 0 || paren_string.equals(\"()\")) level_of_nesting.add(0);\n        else\
    \ {\n            int opening_level = 0;\n            int index = paren_string.indexOf(\"\
    (\");\n            while (index >= 0) {\n                int close_paren = paren_string.indexOf(\"\
    )\", index);\n                if (close_paren < 0) close_paren = paren_string.length();\n\
    \                level_of_nesting.add(close_paren - opening_level);\n        \
    \        opening_level = close_paren + 1;\n                index = paren_string.indexOf(\"\
    (\", close_paren + 1);\n            }\n        }\n        return level_of_nesting;",
  "        ArrayList<Integer> max_nesting_levels = new ArrayList<Integer>();\n   \
    \     for (String nested_parens: split(paren_string, \" \")) {\n            String\
    \ nested_parens_without_spaces = nested_parens.replaceAll(\"\\\\s\", \"\");\n\
    \            if (nested_parens_without_spaces.equals(\"()\")) {\n            \
    \    ArrayList <Integer> temp_arraylist = new ArrayList <Integer>();\n       \
    \         temp_arraylist.add(0);\n                temp_arraylist.add(0);\n   \
    \             temp_arraylist.add(0);\n                max_nesting_levels.add(temp_arraylist);\n\
    \                continue;\n            }\n            ArrayList<Integer> temp\
    \ = new ArrayList <Integer>();\n            for (int i = 0; i < nested_parens_without_spaces.length();\
    \ i++) {\n                String character = nested_parens_without_spaces.charAt(i);\n\
    \                if (Character.isAlphabetic(character)) {\n                  \
    \  int char_int = Character.getNumericValue(character);\n                    if\
    \ (char_int != 0 && char_int <= 25) {\n                        temp.add (char_int\
    \ - 1);\n                    } else {\n                        break;\n      \
    \              }\n                } else {\n                    break;\n     \
    \           }\n            }\n            if (temp.size() > 0) {\n           \
    \     ArrayList<Integer> temp_arraylist = new ArrayList <Integer>();\n       \
    \         temp_arraylist.add(0);\n                temp_arraylist.add(0);\n   \
    \             temp_arraylist.add(0);\n                max_nesting_levels.add(temp_arraylist);\n\
    \            }\n        }\n        return max_nesting_levels;", "        ArrayList<Integer>\
    \ results = new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                stack.push(paren_string.charAt(i));\n           \
    \ } else if (paren_string.charAt(i) == ')') {\n                int depth = stack.pop();\n\
    \                results.add(depth);\n            }\n        }\n        return\
    \ results;", "        ArrayList<Integer> levels = new ArrayList<>();\n       \
    \ for(int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            // if the char is an opening paren\n            if (c == '(') {\n\
    \                if (levels.size() <= 0) {\n                    levels.add(0);\n\
    \                }\n                levels.add(levels.get(levels.size() - 1) +\
    \ 1);\n            }\n            // if the char is a closing paren\n        \
    \    else if (c == ')') {\n                int prev_level = levels.get(levels.size()\
    \ - 1);\n                levels.set(levels.size() - 1, prev_level - 1);\n    \
    \        }\n        }\n        return levels;", "        // TODO: Make this work\n\
    \        // Create a Stack for keeping track of nested levels\n        Stack<Integer>\
    \ level_stack = new Stack<Integer>();\n\n        // Remember the deepest level\n\
    \        level_stack.push(0);\n\n        // Push the current level\n        level_stack.push(0);\n\
    \n        // Parse until no more nested parenthesis\n        while (level_stack.size()\
    \ > 0) {\n            // Pop the top level from the stack\n            int level\
    \ = level_stack.pop();\n            // Pop all possible levels until the desired\
    \ level is met\n            while (level_stack.size() > level) {\n           \
    \     level_stack.pop();\n            }\n            // If the level isn't met\
    \ yet, push the level to the stack\n            if (level_stack.size() < level)\
    \ {\n                level_stack.push(level);\n            }\n        }\n\n  \
    \      // Return the stack elements\n        return new ArrayList<Integer>(level_stack);",
  "        ArrayList<Integer> levels = new ArrayList<>();\n        // Convert strings\
    \ to lists of integers by splitting on spaces.\n        ArrayList<Integer> list1\
    \ = new ArrayList<>();\n        ArrayList<Integer> list2 = new ArrayList<>();\n\
    \        for (String s : paren_string.split(\" \")) {\n            if (s.equals(\"\
    (\")) {\n                list1.add(0);\n            } else if (s.equals(\")\"\
    )) {\n                list2.add(0);\n            } else if (s.equals(\"(\")) {\n\
    \                list1.add(1);\n            } else if (s.equals(\")\")) {\n  \
    \              list2.add(1);\n            } else {\n                int first\
    \ = Integer.valueOf(s.substring(0, 1));\n                int second = Integer.valueOf(s.substring(1,\
    \ s.length() - 1));\n                list1.add(first);\n                list2.add(second);\n\
    \            }\n        }\n        // Find deepest level of nesting.\n       \
    \ int maxLevel = 0;\n        for (int i = 0; i < list1.size(); i++) {\n      \
    \      if (list1.get(i) > list2.get(i)) {\n                maxLevel = list1.get(i);\n\
    \            }\n        }\n        // Add levels to return list.\n        for\
    \ (int i = 0; i < list1.size(); i++) {\n            if (list1.get(i) > maxLevel)\
    \ {\n                levels.add(maxLevel);\n            }\n            if (list1.get(i)\
    \ == maxLevel) {\n                if (i == list1.size() - 1) {\n             \
    \       levels.add(list2.get(i));\n                } else {\n                \
    \    levels.add(list1.get(i));\n                }\n            }\n        }\n\
    \        return levels;", "        int depth = 0;\n        ArrayList<Integer>\
    \ out = new ArrayList<Integer>();\n        for (String substring : paren_string.split(\"\
    \ \")) {\n            if (substring.equals(\"(\")) {\n                depth++;\n\
    \            } else if (substring.equals(\")\")) {\n                depth--;\n\
    \            }\n            out.add(depth);\n        }\n        return out;",
  "        ArrayList<Integer> nested_levels = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ stack = new ArrayList<Integer>();\n        for(int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(')\
    \ stack.push(i);\n            else if (c == ')') {\n                int top =\
    \ stack.get(stack.size()-1);\n                nested_levels.add(i - top);\n  \
    \              stack.remove(stack.size()-1);\n            }\n        }\n     \
    \   return nested_levels;", "        int count = new ArrayList<Integer>();\n \
    \       for(int i = 0; i < paren_string.length(); i++) {\n            char c =\
    \ paren_string.charAt(i);\n            if(c == '(')\n                count.add(i);\n\
    \            else if (c == ')') {\n                count.remove(count.size() -\
    \ 1);\n                count.add(i - count.size());\n            }\n        }\n\
    \        for(int i = 0; i < count.size(); i++) {\n            int j = count.size()\
    \ - i - 1;\n            int k = count.size() - i - 1;\n            int max = Integer.MIN_VALUE;\n\
    \            for(int k = j; k < count.size(); k++) {\n                for(int\
    \ l = k; l < count.size(); l++) {\n                    if(count.get(k) == count.get(l))\
    \ {\n                        max = Math.max(max, k - j);\n                   \
    \ }\n                }\n            }\n            count.set(i, max);\n      \
    \  }\n        return count;", "        ArrayList<Integer> levels = new ArrayList<Integer>();\n\
    \n        // This stores indexes of levels we encounter with parentheses.\n  \
    \      int paren_index = 0;\n        // This is an index where we store the last\
    \ parenthesis found.\n        int last_paren_index = 0;\n        // This is an\
    \ index where we store where the next pair of parentheses begins.\n        int\
    \ next_index = 0;\n\n        int i;\n\n        for (i = 0; ; i++) {\n        \
    \    if (paren_string.charAt(i) == '(') {\n                if (paren_index ==\
    \ 0) {\n                    levels.add(0);\n                }\n              \
    \  levels.add(levels.get(paren_index) - 1);\n                paren_index++;\n\
    \            }\n            if (paren_string.charAt(i) == ')') {\n           \
    \     levels.add(levels.get(paren_index) + 1);\n                paren_index--;\n\
    \            }\n            if (paren_index == 0) {\n                last_paren_index\
    \ = i;\n                break;\n            }\n        }\n\n        // Now that\
    \ we have parsed all the parentheses, we can just output their values.\n     \
    \   for (i = paren_index + 1; i < levels.size(); i++) {\n            levels.add(0,\
    \ levels.get(i));\n        }\n\n        return levels;", "        // Create empty\
    \ array to store level values\n        ArrayList<Integer> level = new ArrayList<Integer>();\n\
    \        // Get all the groups and put them into one array\n        String[] groups\
    \ = paren_string.split(\" \");\n        for (String g : groups) {\n          \
    \  // For each group, get all parentheses and put them into an array\n       \
    \     String[] opens = g.split(\"(\");\n            String[] closes = g.split(\"\
    )\");\n            // For each group that has parentheses, recursively search\
    \ deeper\n            for (int i = 0; i < opens.length; i++) {\n             \
    \   ArrayList<Integer> temp = new ArrayList<Integer>();\n                level.add(0);\n\
    \                // If opens has more elements, search deeper\n              \
    \  if (opens[i].length() > closes[i].length()) {\n                    temp = parseNestedParens(opens[i]);\n\
    \                }\n                // If closes has more elements, search deeper\n\
    \                else if (opens[i].length() < closes[i].length()) {\n        \
    \            temp = parseNestedParens(closes[i]);\n                }\n       \
    \         // If they are the same level\n                else {\n            \
    \        level.add(level.get(level.size() - 1) + 1);\n                }\n    \
    \            level.add(level.get(level.size() - 1) + 1);\n            }\n    \
    \    }\n        return level;", "        ArrayList<Integer> result = new ArrayList<>();\n\
    \n        ArrayList<ArrayList<String>> groups = splitStrings(paren_string, \"\
    \ \");\n        for (ArrayList<String> group: groups) {\n            ArrayList<String>\
    \ parens = new ArrayList<>();\n            int curLevel = 0;\n            boolean\
    \ inGroup = false;\n            for (String p: group) {\n                if (inGroup)\
    \ {\n                    parens.add(p);\n                } else {\n          \
    \          if (p.equals(\"(\")) {\n                        inGroup = true;\n \
    \                   } else if (p.equals(\")\")) {\n                        inGroup\
    \ = false;\n                    } else if (p.equals(\"[\")) {\n              \
    \          curLevel++;\n                    } else if (p.equals(\"]\")) {\n  \
    \                      curLevel--;\n                    }\n                }\n\
    \            }\n            result.add(curLevel);\n        }\n        return result;",
  "        ArrayList<Integer> nested_levels = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ paren_stack = new ArrayList<Integer>();\n        for (String str : paren_string.split(\"\
    \\\\s+\")) {\n            if (str.length() == 0) {\n                continue;\n\
    \            }\n            if (str.charAt(0) == '(') {\n                paren_stack.add(0);\n\
    \            } else if (str.charAt(str.length()-1) == ')') {\n               \
    \ int level_of_paren_opening = paren_stack.get(paren_stack.size()-1);\n      \
    \          nested_levels.add(level_of_paren_opening + 1);\n                paren_stack.remove(paren_stack.size()-1);\n\
    \            }\n        }\n        return nested_levels;", "        ArrayList<Integer>\
    \ answer = new ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \        Set<Integer> unmatched = new HashSet<Integer>();\n        StringTokenizer\
    \ tok = new StringTokenizer(paren_string);\n        StringBuilder sb = new StringBuilder();\n\
    \        while (tok.hasMoreTokens()) {\n            String token = tok.nextToken();\n\
    \            if (!unmatched.contains(token)) {\n                sb.append(token);\n\
    \                if (!token.equals(\")\")) {\n                    if (stack.peek()\
    \ == Token.LEFT_PAREN) {\n                        unmatched.add(stack.pop());\n\
    \                        answer.add(1);\n                    } else {\n      \
    \                  stack.push(Token.LEFT_PAREN);\n                        answer.add(0);\n\
    \                    }\n                } else {\n                    unmatched.add(stack.pop());\n\
    \                    if (stack.peek() == Token.LEFT_PAREN) {\n               \
    \         answer.add(stack.pop());\n                    }\n                }\n\
    \            }\n        }\n        while (!stack.isEmpty()) {\n            unmatched.add(stack.pop());\n\
    \            answer.add(0);\n        }\n        return answer;", "        ArrayList<Integer>\
    \ results = new ArrayList<Integer>();\n\n        List<String> groups = paren_string.split(\"\
    \\\\s+\");\n        for (int i = 0; i < groups.size(); i++) {\n            String\
    \ group = groups.get(i);\n            int level = 0;\n            int lastPos\
    \ = 0;\n            while (lastPos < group.length()) {\n                int index\
    \ = group.indexOf('(', lastPos);\n                if (index == -1) {\n       \
    \             results.add(level);\n                    break;\n              \
    \  } else {\n                    String s = group.substring(lastPos, index); //\
    \ '(())'\n                    int nextIndex = index + 1;\n                   \
    \ int depth = nextIndex - lastPos;\n                    if (depth % 2 == 0) {\n\
    \                        results.add(level);\n                    }\n        \
    \            level += depth;\n                    lastPos = nextIndex;\n     \
    \           }\n            }\n        }\n\n        return results;", "       \
    \ int n = paren_string.length();\n        ArrayList<Integer> depth = new ArrayList<Integer>();\n\
    \        boolean[] visited = new boolean[n];\n        int max_level = 0;\n   \
    \     int i = 0;\n        while (i < n) {\n            int paren_level = paren_string.indexOf('(',\
    \ i) - i;\n            if (paren_level >= 0) {\n                depth.add(paren_level);\n\
    \                visited[paren_level] = true;\n            }\n            int\
    \ new_level = paren_level + depth.get(paren_level) - 1;\n            if (new_level\
    \ > max_level) {\n                max_level = new_level;\n            }\n    \
    \        i = paren_string.indexOf('(', i + 1);\n        }\n        // The depths\
    \ we found are in descending order\n        Collections.sort(depth);\n       \
    \ ArrayList<Integer> ans = new ArrayList<Integer>();\n        for (int j = 0;\
    \ j < depth.size(); ++j) {\n            if (visited[j]) {\n                continue;\n\
    \            }\n            ans.add(depth.get(j));\n        }\n        return\
    \ ans;", "        ArrayList<Integer> max_level = parseLevels(paren_string);\n\
    \        ArrayList<Integer> levels = new ArrayList<>();\n        ArrayList<Integer>\
    \ counts = new ArrayList<>();\n        for (int i = 0; i < max_level.size(); i++)\
    \ {\n            if (max_level.get(i) == 0) {\n                levels.add(0);\n\
    \                counts.add(1);\n            } else {\n                levels.add(i);\n\
    \                counts.add(1);\n                while (counts.get(i) > max_level.get(i)\
    \ - 1) {\n                    counts.set(i,\n                            counts.get(i)\
    \ - 1);\n                    levels.add(i);\n                }\n            }\n\
    \        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        int num_levels\
    \ = levels.size();\n        for (int i = 0; i < num_levels; i++) {\n         \
    \   ans.add(levels.get(i));\n        }\n        return ans;", "        ArrayList<Integer>\
    \ results = new ArrayList<>();\n        String[] parens = paren_string.split(\"\
    \ \");\n        int max_level = 1;\n        ArrayList<Integer> current_level =\
    \ new ArrayList<>();\n        for (int i = 0; i < parens.length; i++) {\n    \
    \        if (parens[i].equals(\"()\")) {\n                if (current_level.isEmpty())\
    \ {\n                    current_level.add(1);\n                } else {\n   \
    \                 current_level.add(current_level.get(current_level.size() - 1)\
    \ + 1);\n                }\n            } else if (parens[i].equals(\"[]\")) {\n\
    \                current_level.add(1);\n            } else {\n               \
    \ current_level.add(current_level.get(current_level.size() - 1) + 1);\n      \
    \          if (current_level.size() > max_level) {\n                    max_level\
    \ = current_level.size();\n                }\n            }\n        }\n     \
    \   if (max_level > 0) {\n            for (int i = 1; i < max_level; i++) {\n\
    \                results.add(current_level.get(i));\n            }\n        }\n\
    \        return results;", "        // To find the deepest level of nesting we\
    \ use a stack. On each iteration,\n        // we pop the stack and increment the\
    \ count of nested parentheses.\n        // The stack is emptied once we reach\
    \ a parentheses with count greater than zero.\n        // If stack is empty then\
    \ we know that all parentheses are at level 0.\n        Stack<Integer> stack =\
    \ new Stack<Integer>();\n        StringTokenizer tokens = new StringTokenizer(paren_string);\n\
    \        ArrayList<Integer> paren_count = new ArrayList<Integer>();\n        while\
    \ (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n\
    \            if (token.equals(\"(\")) {\n                stack.push(0);\n    \
    \        } else if (token.equals(\")\")) {\n                int count = stack.pop();\n\
    \                if (count == 0) {\n                    // This paren has count\
    \ of 0, indicating all parens are at level 0.\n                    // We just\
    \ need to keep track of the count of parentheses and return.\n               \
    \     paren_count.add(0);\n                } else {\n                    paren_count.add(count);\n\
    \                }\n            }\n        }\n        return paren_count;", " \
    \       ArrayList<Integer> result = new ArrayList<>();\n        Stack<Integer>\
    \ stack = new Stack<>();\n\n        // Iterate over all parentheses\n        for\
    \ (char c : paren_string.toCharArray()) {\n            // If current character\
    \ is parentheses, add to stack\n            if (c == '(') {\n                stack.add(c);\n\
    \            }\n            // If current character is close parentheses, push\
    \ nested level and pop parentheses\n            else if (c == ')') {\n       \
    \         result.add(stack.pop());\n            }\n            // If current character\
    \ is whitespace, do nothing\n            else if (c == ' ') {\n            }\n\
    \            // If current character is other character, do nothing\n        \
    \    else {\n                throw new IllegalArgumentException(\"Invalid input:\
    \ \" + paren_string);\n            }\n        }\n        // If parentheses are\
    \ unbalanced, stack will always be empty\n        result.add(stack.pop());\n \
    \       return result;", "        ArrayList<Integer> max_levels = new ArrayList<Integer>();\n\
    \        char[] input_array = paren_string.toCharArray();\n        int depth =\
    \ 0;\n        for (char c : input_array) {\n            if (c == '(') {\n    \
    \            depth++;\n            }\n            if (c == ')') {\n          \
    \      depth--;\n            }\n            if (depth > max_levels.size()) {\n\
    \                max_levels.add(depth);\n            }\n        }\n        return\
    \ max_levels;", "        // We need to keep track of level to do proper recursion.\n\
    \        ArrayList<Integer> level_of_nesting = new ArrayList<>();\n        //\
    \ This map will keep track of each character in the input string\n        Map<Character,\
    \ Integer> input_string = new HashMap<>();\n        // This map will keep track\
    \ of current parentheses level for each character\n        Map<Character, Integer>\
    \ current_level = new HashMap<>();\n        // This map will keep track of level\
    \ of parenthesis for each character with -1 as default.\n        Map<Character,\
    \ Integer> max_level = new HashMap<>();\n        // This map will keep track of\
    \ level of parenthesis for each character with -1 as default.\n        Map<Character,\
    \ Integer> min_level = new HashMap<>();\n\n        // Loop through all characters\
    \ in the string\n        for(char c : paren_string.toCharArray()) {\n        \
    \    // If this character is a parenthesis then increase its level\n         \
    \   if(isParenthesis(c)) {\n                current_level.put(c, current_level.get(c)\
    \ + 1);\n            }\n            // If this character is a space then increase\
    \ its level\n            if(isSpace(c)) {\n                current_level.put(c,\
    \ current_level.get(c) + 1);\n            }\n            // This character should\
    \ be added to the input string if not already there\n            if(!input_string.containsKey(c))\
    \ {\n                input_string.put(c, 1);\n            }\n            else\
    \ {\n                input_string.put(c, input_string.get(c) + 1);\n         \
    \   }\n            // If the current level is greater than the max then update\
    \ max_level map\n            if(current_level.get(c) > max_level.get(c)) {\n \
    \               max_level.put(c, current_level.get(c));\n            }\n     \
    \       // If the current level is less than min then update min_level map\n \
    \           if(current_level.get(c) < min_level.get(c)) {\n                min_level.put(c,\
    \ current_level.get(c));\n            }\n            // If the level is not -1,\
    \ then we shouldn't increment it by 1\n            if(current_level.get(c) !=\
    \ -1) {\n                current_level.put(c, current_level.get(c) + 1);\n   \
    \         }\n        }\n        // Loop through all characters in input string\
    \ and if they are part of max_level, update max_level\n        for(int c : input_string.keySet())\
    \ {\n            if(max_level.get(c) == -1) {\n                throw new IllegalArgumentException(\"\
    Invalid input!\");\n            }\n        }\n        // Loop through all characters\
    \ in input string and if they are part of min_level, update min_level\n      \
    \  for(int c : input_string.keySet()) {\n            if(min_level.get(c) == -1)\
    \ {\n                min_level.put(c, 1);\n            }\n        }\n        //\
    \ Loop through all characters in input string and update level_of_nesting list\
    \ accordingly\n        for(int c : input_string.keySet()) {\n            if(current_level.get(c)\
    \ < min_level.get(c)) {\n", "        // Your code here\n        // Solution:\n\
    \        ArrayList<Integer> res = new ArrayList<>();\n        HashSet<String>\
    \ parens = new HashSet<>();\n        boolean inParens = false;\n        int i\
    \ = -1;\n        while (true) {\n            i++;\n            int c = paren_string.charAt(i);\n\
    \            if (c == '(') {\n                inParens = true;\n             \
    \   parens.add(c);\n            } else if (c == ')') {\n                inParens\
    \ = false;\n                for (int j = 0; j < parens.size(); j++) {\n      \
    \              String a = parens.remove(parens.last());\n                    if\
    \ (parens.isEmpty()) {\n                        res.add(i);\n                \
    \        break;\n                    }\n                    for (int k = 0; k\
    \ < a.length(); k++) {\n                        if (!inParens) {\n           \
    \                 parens.add(a.charAt(k));\n                            break;\n\
    \                        }\n                    }\n                }\n       \
    \     } else if (c == ' ') {\n                res.add(i);\n            }\n   \
    \     }\n        return res;", "        // Create a stack to track the level of\
    \ nesting\n        Stack<Integer> levelStack = new Stack<>();\n        // Create\
    \ a stack to track the paren level\n        Stack<Integer> parenLevelStack = new\
    \ Stack<>();\n        // A list to hold the max level count\n        ArrayList<Integer>\
    \ maxLevelCount = new ArrayList<>();\n        // A list to hold the corresponding\
    \ nested level\n        ArrayList<Integer> nestedLevelCount = new ArrayList<>();\n\
    \        // Iterate through the input string one character at a time\n       \
    \ for(int i = 0; i < paren_string.length(); i++) {\n            // Get the current\
    \ character\n            char c = paren_string.charAt(i);\n            // Push\
    \ the current level of nesting onto the stack\n            levelStack.push(i);\n\
    \            // If current character is a left parentheses, push the level onto\
    \ the stack\n            if(Character.isLetter(c)) {\n                parenLevelStack.push(i);\n\
    \            }\n            // If current character is a right parentheses, pop\
    \ the level from the stack\n            else if(Character.isLetter(c)) {\n   \
    \             levelStack.pop();\n                parenLevelStack.pop();\n    \
    \        }\n            // If current character is a comma, add one to the level\
    \ of nesting\n            else if(Character.isLetter(c)) {\n                levelStack.peek();\n\
    \                parenLevelStack.peek();\n            }\n            // If current\
    \ character is a space, add one to the level of nesting\n            else if(Character.isLetter(c))\
    \ {\n                levelStack.peek();\n                parenLevelStack.peek();\n\
    \            }\n            // If the current level of nesting is greater than\
    \ the max level\n            // push it to the max level count\n            else\
    \ if(levelStack.peek() > maxLevelCount.peek()) {\n                maxLevelCount.push(levelStack.peek());\n\
    \            }\n            // If the current level of nesting is equal to the\
    \ max level\n            // push it to the nested level count\n            else\
    \ if(levelStack.peek() == maxLevelCount.peek()) {\n                nestedLevelCount.push(levelStack.peek());\n\
    \            }\n        }\n        // Return the nested level count\n        return\
    \ nestedLevelCount;", "        ArrayList<Integer> result = new ArrayList<>();\n\
    \        Stack<Integer> stack = new Stack<>();\n        for (String group : paren_string.split(\"\
    \ \")) {\n            while (!stack.empty() && stack.peek() > group.charAt(0))\
    \ {\n                result.add(stack.peek() - 1);\n                stack.pop();\n\
    \            }\n            stack.push(group.charAt(0));\n        }\n        return\
    \ result;", "        // For each group of parentheses, go through each level of\
    \ nested parentheses.\n        // Keep a count of how many parentheses you have\
    \ seen in the group.\n        // If this is greater than the previous count of\
    \ parentheses, reset the count.\n        // Otherwise, just add the number of\
    \ parentheses you have seen to this count.\n        // The result is added to\
    \ an ArrayList of integers to return.\n        ArrayList<Integer> levels = new\
    \ ArrayList<Integer>();\n        int i = 0;\n        while (i < paren_string.length())\
    \ {\n            int j = paren_string.indexOf('(', i);\n            levels.add(j\
    \ - i); // Add level count.\n            i = j + 1; // Move to next opening parentheses.\n\
    \        }\n        // Add the last level.\n        levels.add(i);\n        return\
    \ levels;", "        ArrayList<Integer> output_array = new ArrayList<>();\n  \
    \      ArrayList<String> par = new ArrayList<>();\n        par.add(paren_string);\n\
    \n        ArrayList<String> par2 = new ArrayList<>();\n        int level_counter\
    \ = 0;\n        int prev_level_count = -1;\n\n        while (level_counter <=\
    \ 0) {\n            String temp = par2.get(0);\n            par2.remove(0);\n\
    \            par.add(temp);\n\n            level_counter++;\n            if (level_counter\
    \ > prev_level_count) {\n                prev_level_count = level_counter;\n \
    \           }\n\n        }\n\n        for (int x = 0; x < par2.size(); x++) {\n\
    \            int num_groups = Integer.parseInt(par2.get(x));\n            ArrayList<Integer>\
    \ group_array = new ArrayList<>();\n            for (int i = 0; i < num_groups;\
    \ i++) {\n                String temp = par.get(level_counter);\n            \
    \    par.remove(level_counter);\n                par.add(temp);\n            \
    \    group_array.add(level_counter);\n            }\n            output_array.addAll(group_array);\n\
    \        }\n        return output_array;", "        ArrayList<Integer> paren_levels\
    \ = new ArrayList<Integer>();\n        int paren_level_counter = 0;\n        //\
    \ This will be used to keep track of the number of open parentheses encountered\
    \ per level.\n        // This will be used when deciding whether to count parentheses\
    \ enclosed within parentheses or\n        // parentheses enclosed by parentheses.\n\
    \        int open_parentheses_counter = 0;\n        // This will be used to keep\
    \ track of the number of closing parentheses encountered per level.\n        //\
    \ This will be used when deciding whether to count parentheses enclosed within\
    \ parentheses or\n        // parentheses enclosed by parentheses.\n        int\
    \ close_parentheses_counter = 0;\n        // This will be used to keep track of\
    \ the number of parentheses encountered per level.\n        // This will be used\
    \ when deciding whether to count parentheses enclosed within parentheses or\n\
    \        // parentheses enclosed by parentheses.\n        int parentheses_counter\
    \ = 0;\n        // This will be used to keep track of the number of unmatched\
    \ parentheses encountered per level.\n        // This will be used when deciding\
    \ whether to count parentheses enclosed within parentheses or\n        // parentheses\
    \ enclosed by parentheses.\n        int unmatched_parentheses_counter = 0;\n\n\
    \        // This will be used to keep track of the number of opening parentheses\
    \ encountered per level.\n        // This will be used when deciding whether to\
    \ count parentheses enclosed within parentheses or\n        // parentheses enclosed\
    \ by parentheses.\n        int open_parentheses_counter_per_level = new ArrayList<Integer>();\n\
    \n        // This will be used to keep track of the number of closing parentheses\
    \ encountered per level.\n        // This will be used when deciding whether to\
    \ count parentheses enclosed within parentheses or\n        // parentheses enclosed\
    \ by parentheses.\n        int close_parentheses_counter_per_level = new ArrayList<Integer>();\n\
    \n        // This will be used to keep track of the number of parentheses encountered\
    \ per level.\n        // This will be used when deciding whether to count parentheses\
    \ enclosed within parentheses or\n        // parentheses enclosed by parentheses.\n\
    \        int parentheses_counter_per_level = new ArrayList<Integer>();\n\n   \
    \     ArrayList<Integer> parentheses_enclosed_within_parentheses = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> parentheses_enclosed_by_parentheses = new ArrayList<Integer>();\n\
    \n        paren_string.chars().forEach(x -> {\n            switch (x) {\n    \
    \            case ')':\n                    parentheses_counter_per_level.set(paren_level_counter,\
    \ parentheses_counter_per_level.get(paren_level_counter) - 1);\n             \
    \       paren_level_counter--;\n                    parentheses_counter++;\n \
    \                   break;\n                case '(':\n                    parentheses_counter_per_level.set(paren_level_counter,\
    \ parentheses_counter_per_level.get(paren_level_counter) + 1);\n             \
    \       paren_level_counter++;\n                    break;\n                case\
    \ '{':\n                    open_parentheses_counter_", "        ArrayList<Integer>\
    \ nesting_level = new ArrayList<Integer>();\n        paren_string = paren_string.replaceAll(\"\
    [\\(\\)]\", \"\");\n        String temp = null;\n        int level = 0;\n    \
    \    for(int i = 0; i < paren_string.length(); i++) {\n            if(paren_string.charAt(i)\
    \ == '(') {\n                nesting_level.add(level);\n            } else if(paren_string.charAt(i)\
    \ == ')') {\n                nesting_level.remove((int) nesting_level.get((int)\
    \ nesting_level.size() - 1));\n            } else if(nesting_level.size() == 0\
    \ && paren_string.charAt(i) != '(' && paren_string.charAt(i) != ')') {\n     \
    \           temp = paren_string.substring(i, paren_string.length());\n       \
    \         level = nesting_level.size() - 1;\n            }\n        }\n      \
    \  if(nesting_level.size() > 0) {\n            nesting_level.remove((int) nesting_level.get((int)\
    \ nesting_level.size() - 1));\n        }\n        return nesting_level;", "  \
    \      ArrayList<Integer> nested_levels = new ArrayList<Integer>();\n        //\
    \ The pattern to find parentheses.\n        String pattern = \"\\\\(\\\\w+\\\\\
    )\";\n        // The regular expression pattern\n        Pattern r = Pattern.compile(pattern);\n\
    \        Matcher m = r.matcher(paren_string);\n        while(m.find()) {\n   \
    \         // Each match group is a list of parentheses.\n            ArrayList<String>\
    \ match_groups = m.group().split(\"\\\\)\");\n            // Get the level of\
    \ nesting of parentheses.\n            int level = 0;\n            for(int i =\
    \ 0; i < match_groups.size(); i++) {\n                String curr = match_groups.get(i);\n\
    \                if(\"(\".equals(curr)) {\n                    level++;\n    \
    \            } else if(\")\".equals(curr)) {\n                    level--;\n \
    \               }\n                nested_levels.add(level);\n            }\n\
    \        }\n        return nested_levels;", "        ArrayList<Integer> paren_levels\
    \ = new ArrayList<Integer>();\n        int paren_count = 0;\n        for (char\
    \ c : paren_string.toCharArray()) {\n            if (c == '(') {\n           \
    \     paren_count++;\n            } else if (c == ')') {\n                paren_count--;\n\
    \            }\n            if (paren_count == 0) {\n                paren_levels.add(paren_count);\n\
    \            }\n        }\n        return paren_levels;", "        if (paren_string.matches(\"\
    \\\\(.*\\\\)\")) {\n            String nested = paren_string.substring(1);\n \
    \           String[] inner_strings = nested.split(\"\\\\)\");\n            ArrayList<Integer>\
    \ nested_levels = new ArrayList<>();\n            for (String inner_string : inner_strings)\
    \ {\n                nested_levels.add(parseNestedParens(inner_string));\n   \
    \         }\n            ArrayList<Integer> results = new ArrayList<>();\n   \
    \         for (int i = 0; i < nested_levels.size() - 1; i++) {\n             \
    \   if (nested_levels.get(i) > nested_levels.get(nested_levels.size() - 2)) {\n\
    \                    results.add(nested_levels.get(i));\n                }\n \
    \           }\n            return results;\n        }\n        return Arrays.asList(1,\
    \ 1);", "        ArrayList<Integer> nest = new ArrayList<Integer>();\n       \
    \ ArrayList<Integer> nest_level = new ArrayList<Integer>();\n        boolean is_open\
    \ = true;\n        for (int i = 0; i < paren_string.length(); i++) {\n       \
    \     char c = paren_string.charAt(i);\n            if (c == '(') {\n        \
    \        if (!is_open) {\n                    nest.add(0);\n                 \
    \   nest_level.add(0);\n                }\n                is_open = true;\n \
    \               nest_level.add(nest.size());\n            } else if (c == ')')\
    \ {\n                nest_level.remove(nest_level.size()-1);\n               \
    \ is_open = false;\n                nest.add(nest_level.get(nest_level.size()-1));\n\
    \            } else if (c == ' ') {\n                nest.add(nest.size()-1);\n\
    \            }\n        }\n        return nest;", "        ArrayList<Integer>\
    \ deepest_nesting = new ArrayList<Integer>();\n        for (String group : paren_string.split(\"\
    \ \"))\n        {\n            ArrayList<Integer> current_level = new ArrayList<Integer>();\n\
    \            for (int i = 0; i < group.length(); i++)\n            {\n       \
    \         if (group.charAt(i) == '(')\n                {\n                   \
    \ if (current_level.size() > deepest_nesting.size())\n                       \
    \ deepest_nesting = current_level;\n                    current_level.add(1);\n\
    \                }\n                else if (group.charAt(i) == ')')\n       \
    \         {\n                    if (current_level.size() > deepest_nesting.size())\n\
    \                        deepest_nesting = current_level;\n                  \
    \  current_level.add(-1);\n                }\n                else\n         \
    \       {\n                    current_level.add(0);\n                }\n    \
    \        }\n        }\n        return deepest_nesting;", "        if (paren_string.length()\
    \ < 2) return null;\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\
    \        int start_index = 1;\n        for (; start_index < paren_string.length();\
    \ start_index++) {\n            if (paren_string.charAt(start_index) == '(') {\n\
    \                result.add(0);\n            }\n            else if (paren_string.charAt(start_index)\
    \ == '(') {\n                result.add(1);\n            }\n            else if\
    \ (paren_string.charAt(start_index) == ')') {\n                int index = result.lastIndexOf(0);\n\
    \                if (index > 0) {\n                    result.remove(index);\n\
    \                    result.remove(index);\n                }\n              \
    \  else {\n                    return null;\n                }\n            }\n\
    \        }\n        return result;", "        ArrayList<Integer> levels = new\
    \ ArrayList<>();\n        for (String curr_paren = paren_string.trim(); curr_paren.length()\
    \ > 0; curr_paren = paren_string.trim()) {\n            if (curr_paren.equals(\"\
    (\")) {\n                if (levels.size() > 0) {\n                    levels.add(levels.size()\
    \ - 1);\n                }\n            } else if (curr_paren.equals(\")\")) {\n\
    \                if (levels.size() > 0) {\n                    levels.remove(levels.size()\
    \ - 1);\n                }\n            } else {\n                levels.add(1);\n\
    \            }\n        }\n        return levels;", "        // Get the number\
    \ of opening and closing parentheses\n        int num_opening_parentheses = paren_string.length();\n\
    \        int num_closing_parentheses = paren_string.trim().length() - paren_string.trim().replaceAll(\"\
    \\\\s\", \"\").length();\n\n        // Define the arraylist to hold all lengths\
    \ of nesting levels\n        ArrayList<Integer> length_list = new ArrayList<Integer>();\n\
    \n        // Traverse through each character in string\n        for (int i = 1;\
    \ i < paren_string.length(); i++) {\n            // For each opening parentheses,\
    \ increase the length by 1\n            if (paren_string.charAt(i) == '(') {\n\
    \                length_list.add(num_opening_parentheses);\n            }\n  \
    \          // For each closing parentheses, decrease the length by 1\n       \
    \     else if (paren_string.charAt(i) == ')') {\n                length_list.remove(length_list.size()\
    \ - 1);\n            }\n        }\n\n        // Add the sum of lengths\n     \
    \   ArrayList<Integer> result = length_list;\n        result.add(length_list.get(0).intValue()\
    \ + length_list.get(1).intValue());\n\n        return result;", "        ArrayList<Integer>\
    \ max_levels = new ArrayList<>();\n        for (String nested_paren : paren_string.split(\"\
    \\\\s+\")) {\n            int n = parseNestedParens(nested_paren);\n         \
    \   if (max_levels.isEmpty() || n > max_levels.get(max_levels.size() - 1)) {\n\
    \                ArrayList<Integer> new_levels = new ArrayList<>();\n        \
    \        for (int i = 0; i < n; i++) {\n                    new_levels.add(i);\n\
    \                }\n                max_levels.add(new_levels);\n            }\n\
    \            else {\n                max_levels.get(max_levels.size() - 1).add(i);\n\
    \            }\n        }\n        return max_levels;", "        ArrayList<Integer>\
    \ max_level = new ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            char c\
    \ = paren_string.charAt(i);\n            if (c == '(')\n                stack.push(i);\n\
    \            if (c == ')')\n                while (stack.isEmpty())\n        \
    \            stack.pop();\n                if (stack.isEmpty())\n            \
    \        max_level.add(0);\n                else\n                    max_level.add(stack.pop());\n\
    \            if (stack.size() > 0 && stack.peek() != i)\n                max_level.add(stack.peek());\n\
    \        }\n        return max_level;", "        ArrayList<Integer> result = new\
    \ ArrayList<>();\n        int pos = 0;\n        boolean inside_group = false;\n\
    \        int stack = 1;\n        while(pos < paren_string.length()) {\n      \
    \      char ch = paren_string.charAt(pos);\n            if (ch == '(') {\n   \
    \             inside_group = true;\n            } else if (ch == ')') {\n    \
    \            inside_group = false;\n            } else if (inside_group) {\n \
    \               stack++;\n            }\n            pos++;\n            if (stack\
    \ > result.size()) {\n                result.add(stack);\n            }\n    \
    \    }\n        return result;", "        ArrayList<Integer> levels = new ArrayList<>();\n\
    \n        // Step 1: convert string to a nested list of brackets.\n        StringBuilder\
    \ nested_bracket = new StringBuilder();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            nested_bracket.append(paren_string.charAt(i));\n       \
    \ }\n        Stack<String> brackets = new Stack<>();\n        brackets.push(nested_bracket.toString());\n\
    \        int brackets_size = brackets.size();\n\n        // Step 2: count the\
    \ levels.\n        while (brackets.size() > 0) {\n            String bracket =\
    \ brackets.pop();\n            if (bracket.charAt(0) == '(') {\n             \
    \   brackets.push(bracket);\n            } else {\n                String current_level_str\
    \ = bracket.toString();\n                int current_level = brackets.length();\n\
    \                for (int i = 0; i < brackets_size; i++) {\n                 \
    \   if (brackets.get(i).equals(current_level_str)) {\n                       \
    \ brackets.set(i, current_level_str);\n                        brackets_size =\
    \ i;\n                        current_level_str = brackets.pop();\n          \
    \              break;\n                    }\n                }\n            \
    \    if (current_level_str != \"\") levels.add(current_level);\n            }\n\
    \        }\n\n        // Step 3: convert levels to array list.\n        ArrayList<Integer>\
    \ levels_array = new ArrayList<>(levels);\n        levels_array.remove(levels_array.size()\
    \ - 1);\n        return levels_array;", "        // Keep track of how many levels\
    \ we have seen so far\n        ArrayList<Integer> levels = new ArrayList<Integer>();\n\
    \n        // We want to keep a record of how many \"levels\" we see.\n       \
    \ // If we see 0 levels then it's time to call this function again!\n        int\
    \ max_levels = -1;\n\n        // Get the array of strings that we get from splitting\
    \ by spaces\n        String[] groups = paren_string.split(\" \");\n\n        //\
    \ Iterate over the groups and keep track of the levels\n        for (String group\
    \ : groups) {\n            int level = levels.size();\n            levels.add(level);\n\
    \n            // If the level goes over max_levels then call this function again!\n\
    \            if (level >= max_levels) {\n                // We want to keep track\
    \ of the largest level\n                max_levels = level;\n\n              \
    \  // We call this function again with different parameter\n                levels\
    \ = parseNestedParens(group);\n            }\n        }\n\n        // Return an\
    \ array with the levels\n        return levels;", "        ArrayList<Integer>\
    \ nest = new ArrayList<>();\n        int open = 0;\n        int close = 0;\n \
    \       int counter = 0;\n        int i = 0;\n        while ((i = paren_string.indexOf(\"\
    (\", open)) > -1) {\n            while (i >= 0 && paren_string.charAt(i) == '(')\
    \ {\n                nest.add(counter);\n                open++;\n           \
    \     i = paren_string.indexOf(\"(\", open);\n            }\n            while\
    \ (i >= 0 && paren_string.charAt(i) == ')') {\n                close++;\n    \
    \            i = paren_string.indexOf(\")\", close);\n            }\n        \
    \    counter++;\n            open++;\n        }\n        return nest;", "    \
    \    ArrayList<Integer> levels = new ArrayList<>();\n        StringTokenizer tokenizer\
    \ = new StringTokenizer(paren_string, \" ()\");\n        while (tokenizer.hasMoreTokens())\
    \ {\n            String token = tokenizer.nextToken();\n            int level_of_nesting\
    \ = 0;\n            for (int i = 0; i < token.length(); i++) {\n             \
    \   char c = token.charAt(i);\n                if (c == '(')\n               \
    \     level_of_nesting++;\n                if (c == ')')\n                   \
    \ level_of_nesting--;\n            }\n            levels.add(level_of_nesting);\n\
    \        }\n        System.out.println(levels);\n        return levels;", "  \
    \      ArrayList<Integer> levels = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ depths = new ArrayList<Integer>();\n        ArrayList<Integer> nesting = new\
    \ ArrayList<Integer>();\n        ArrayList<Integer> par_counts = new ArrayList<Integer>();\n\
    \        int depth = 0;\n        int par_count = 0;\n        ArrayList<Integer>\
    \ level = 0;\n        ArrayList<Integer> par_depth = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> par_count = new ArrayList<Integer>();\n        boolean\
    \ found = false;\n        for(int i = 0; i < paren_string.length(); i++) {\n \
    \           char curr = paren_string.charAt(i);\n            if(curr == '(') {\n\
    \                par_count++;\n                par_depth.add(depth);\n       \
    \     } else if(curr == ')') {\n                par_count--;\n               \
    \ par_depth.remove(par_depth.size() - 1);\n            } else if(curr == ' ')\
    \ {\n                if(par_depth.size() != 0) {\n                    depth =\
    \ par_depth.get(par_depth.size() - 1);\n                    levels.add(level);\n\
    \                    depths.add(depth);\n                    nesting.add(par_count);\n\
    \                    par_counts.set(par_counts.size() - 1, par_count);\n     \
    \               level = 0;\n                    par_count = 0;\n             \
    \       par_depth.clear();\n                } else {\n                    level++;\n\
    \                }\n            } else if(curr == '(' || curr == ')') {\n    \
    \            level++;\n            } else if(curr == '[') {\n                if(!found)\
    \ {\n                    par_count++;\n                } else {\n            \
    \        par_count++;\n                    par_depth.add(depth);\n           \
    \     }\n            } else if(curr == ']') {\n                par_count--;\n\
    \                par_depth.remove(par_depth.size() - 1);\n            } else if(curr\
    \ == '<' || curr == '>') {\n                found = true;\n            }\n   \
    \     }\n        if(!found) {\n            levels.add(level);\n            depths.add(depth);\n\
    \            nesting.add(par_count);\n            par_counts.set(par_counts.size()\
    \ - 1, par_count);\n            level = 0;\n            depth = 0;\n         \
    \   par_depth.clear();\n            found = false;\n        }\n        ArrayList<Integer>\
    \ output = levels.stream().flatMap(Collection::stream).collect(Collectors.toList());\n\
    \        return output;", "        ArrayList<Integer> results = new ArrayList<>();\n\
    \        Stack<Integer> stack = new Stack<>();\n        stack.add(0);\n      \
    \  \n        int parentheses_cnt = 0;\n        for(int i=0; i<paren_string.length();\
    \ i++) {\n            if(paren_string.charAt(i) == '(') {\n                parentheses_cnt++;\n\
    \                stack.add(parentheses_cnt);\n            } else if(paren_string.charAt(i)\
    \ == ')') {\n                stack.remove(stack.size()-1);\n                parentheses_cnt--;\n\
    \            }\n            \n            while(!stack.empty() && stack.peek()\
    \ == (parentheses_cnt+1)) {\n                results.add(stack.peek());\n    \
    \            stack.pop();\n            }\n        }\n        \n        return\
    \ results;", "        ArrayList<Integer> levels = new ArrayList<Integer>();\n\
    \        if (paren_string.length() == 0) {\n            levels.add(0);\n     \
    \   } else {\n            int nesting = 1;\n            while (nesting > 0 &&\
    \ paren_string.charAt(nesting - 1) == ')') {\n                nesting--;\n   \
    \         }\n            int prev_nesting = nesting;\n            levels.add(nesting);\n\
    \            paren_string = paren_string.substring(prev_nesting);\n          \
    \  int start_pos = paren_string.indexOf(\"(\");\n            if (start_pos ==\
    \ -1) {\n                return levels;\n            }\n            ArrayList<Integer>\
    \ new_levels = parseNestedParens(paren_string.substring(0, start_pos));\n    \
    \        ArrayList<Integer> last_levels = parseNestedParens(paren_string.substring(start_pos\
    \ + 1));\n            for (int i = 0; i < last_levels.size(); i++) {\n       \
    \         if (last_levels.get(i) > new_levels.get(i)) {\n                    ArrayList<Integer>\
    \ temp = new_levels;\n                    new_levels = last_levels;\n        \
    \            last_levels = temp;\n                }\n            }\n         \
    \   for (int i = 0; i < new_levels.size(); i++) {\n                levels.add(new_levels.get(i)\
    \ + 1);\n            }\n        }\n        return levels;", "        ArrayList<Integer>\
    \ stack = new ArrayList<Integer>();\n        stack.add(0);\n\n        ArrayList<Integer>\
    \ results = new ArrayList<Integer>();\n        for (String s : paren_string.split(\"\
    \ \")) {\n            int len = s.length();\n            if (len > 0) {\n    \
    \            int depth = stack.get(stack.size() - 1);\n                if (s.charAt(len\
    \ - 1) == ')') {\n                    if (depth > 0) {\n                     \
    \   stack.remove(stack.size() - 1);\n                        stack.add(depth -\
    \ 1);\n                    }\n                }\n                else if (s.charAt(len\
    \ - 1) == '(') {\n                    int left_count = 1 + stack.get(stack.size()\
    \ - 1 - len + 1);\n                    if (left_count > depth) {\n           \
    \             results.add(depth);\n                        stack.remove(stack.size()\
    \ - 1);\n                        stack.add(depth);\n                    }\n  \
    \              }\n                else if (s.charAt(len - 1) == ')') {\n     \
    \               if (depth < stack.get(stack.size() - 1)) {\n                 \
    \       stack.remove(stack.size() - 1);\n                        stack.add(depth);\n\
    \                    }\n                }\n                else {\n          \
    \          stack.remove(stack.size() - 1);\n                }\n            }\n\
    \        }\n        return results;", "        ArrayList<Integer> nestingLevels\
    \ = new ArrayList<Integer>();\n        ArrayList<String> parenStrings = new ArrayList<String>();\n\
    \        ArrayList<String> parenStringsReverse = new ArrayList<String>();\n\n\
    \        paren_string = paren_string.toLowerCase().trim();\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\)\\\\)\\\\)\",\"\");\n        paren_string =\
    \ paren_string.replaceAll(\"\\\\(+\\\\)\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\(|\\\\)\", \"\");\n\n        paren_string = paren_string.replaceAll(\"(\\\\\
    ))\", \"\");\n        paren_string = paren_string.replaceAll(\"(\\\\()\", \"\"\
    );\n        paren_string = paren_string.replaceAll(\"(\\\\))\", \"\");\n     \
    \   paren_string = paren_string.replaceAll(\"(\\\\()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"(\\\\))\", \"\");\n\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\n\
    \        paren_string = paren_string.replaceAll(\"(\\\\()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"(\\\\))\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    (\\\\()\", \"\");\n        paren_string = paren_string.replaceAll(\"(\\\\))\"\
    , \"\");\n        paren_string = paren_string.replaceAll(\"(\\\\()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"(\\\\))\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"(\\\\()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    (\\\\))\", \"\");\n        ", "        ArrayList<Integer> parens = new ArrayList<Integer>();\n\
    \        \n        int index = -1;\n        while(paren_string.charAt(index) !=\
    \ '(' && paren_string.charAt(index) != ')'){\n            index++;\n        }\n\
    \        while(index >= 0){\n            parens.add(paren_string.indexOf('(',index));\n\
    \            index++;\n            parens.add(paren_string.indexOf(')',index));\n\
    \            index++;\n        }\n        \n        Collections.sort(parens);\n\
    \        return parens;", "        ArrayList<Integer> results = new ArrayList<>();\n\
    \n        // Keep adding each parenthesis level to the stack (i.e. the number\
    \ of open parenthesis)\n        int level_stack = 0;\n\n        // The current\
    \ level on the stack (i.e. the number of open parenthesis)\n        int current_level\
    \ = 0;\n\n        // The current string that we are working on\n        String\
    \ current_string = \"\";\n\n        // Iterate over the parenthesis\n        for\
    \ (char c : paren_string.toCharArray()) {\n            current_string.append(c);\n\
    \            // Increment the level by 1 for each parenthesis\n            if\
    \ (c == '(') {\n                current_level++;\n            } else if (c ==\
    \ ')') {\n                current_level--;\n            }\n\n            // If\
    \ we are on the top of the stack, append the current level\n            // to\
    \ the result\n            if (level_stack > 0 && current_level == 0) {\n     \
    \           results.add(current_level);\n            }\n\n            // If the\
    \ level is greater than the top level on the stack\n            // and we are\
    \ not at the top of the stack, append the level to\n            // the result\
    \ and increment the level by one\n            if (level_stack > current_level\
    \ && level_stack > 0 && current_level == 0) {\n                results.add(current_level);\n\
    \                current_level++;\n            }\n\n            // If the level\
    \ is greater than the current level, and we are not at the top level\n       \
    \     // on the stack and we are not on the top of the stack, append the level\
    \ to\n            // the result and decrement the level by one\n            if\
    \ (level_stack > current_level && level_stack > current_level && level_stack >\
    \ 0 && current_level == 0) {\n                results.add(current_level);\n  \
    \              current_level--;\n            }\n\n            // If we are at\
    \ the top of the stack and we are at the top of the stack,\n            // don't\
    \ do anything, otherwise decrement the level by one (which will\n            //\
    \ remove the last level of parenthesis)\n            if (level_stack == current_level)\
    \ {\n                level_stack--;\n            }\n\n            // If we have\
    \ reached the end of the parenthesis string, add the\n            // number of\
    \ parenthesis at the current level to the results\n            if (c == '(' &&\
    \ level_stack == 0) {\n                results.add(current_level);\n         \
    \   }\n        }\n\n        return results;", "        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n\
    \        for (int i = 0; i < groups.length; i++) {\n            ArrayList<Integer>\
    \ level_stack = new ArrayList<Integer>();\n            String group = groups[i];\n\
    \            int group_length = group.length();\n            int last_open = -1;\n\
    \            int last_closed = -1;\n            for (int j = 0; j < group_length;\
    \ j++) {\n                if (group.charAt(j) == '(') {\n                    last_open\
    \ = j;\n                }\n                if (group.charAt(j) == ')') {\n   \
    \                 last_closed = j;\n                }\n            }\n       \
    \     // If last group ends with parentheses, push it to the stack\n         \
    \   if (last_close > last_open + 1) {\n                level_stack.push(last_open);\n\
    \            }\n            // Otherwise, we are on the top level\n          \
    \  else {\n                // Get current level\n                int level = level_stack.size()\
    \ - 1;\n                // If we are at the top level, we are done\n         \
    \       if (level == -1) {\n                    break;\n                }\n  \
    \              // Otherwise, get previous level and push to it\n             \
    \   else {\n                    level_stack.push(level_stack.get(level - 1));\n\
    \                }\n            }\n            // Now go through the group\n \
    \           for (int j = last_open + 1; j < last_close; j++) {\n             \
    \   if (group.charAt(j) == '(') {\n                    level_stack.push(j);\n\
    \                }\n                if (group.charAt(j) == ')') {\n          \
    \          int level_open = level_stack.get(level_stack.size() - 1);\n       \
    \             if (level_open > level) {\n                        level = level_open;\n\
    \                    }\n                    level_stack.pop();\n             \
    \   }\n            }\n            levels.add(level);\n        }\n        return\
    \ levels;", "        ArrayList<Integer> level_of_nesting = new ArrayList<>();\n\
    \        ArrayList groups = new ArrayList<>();\n\n        // Create a map for\
    \ paren groups to their position\n        HashMap<String, Integer> paren_groups\
    \ = new HashMap<>();\n\n        // Iterate through each group\n        StringBuilder\
    \ paren_builder = new StringBuilder();\n        for (int i = 1; i < paren_string.length();\
    \ i++) {\n            paren_builder.append(paren_string.charAt(i));\n\n      \
    \      // When we see a parenthesis, create a group\n            if (paren_builder.charAt(i)\
    \ == '(') {\n                paren_groups.get(paren_builder.toString()) == null\
    \ ?\n                    paren_groups.put(paren_builder.toString(), i) :\n   \
    \                 paren_builder.append(paren_groups.put(paren_builder.toString(),\
    \ i));\n            }\n\n            // When we see a closing parenthesis, check\
    \ its level\n            else if (paren_builder.charAt(i) == ')') {\n        \
    \        // If this group is empty (i.e. no parenthesis pairs), add this to the\
    \ list of groups\n                if (paren_groups.get(paren_builder.toString()).isEmpty())\
    \ {\n                    groups.add(new Integer(paren_builder.toString()));\n\
    \                }\n                else {\n                    level_of_nesting.add(new\
    \ Integer(paren_groups.get(paren_builder.toString())));\n                }\n \
    \           }\n\n            // When we see any other character, just add it to\
    \ the parenthesis group\n            else {\n                paren_builder.append(paren_groups.put(paren_builder.toString(),\
    \ i));\n            }\n        }\n\n        // Return the maximum level of nesting\n\
    \        return level_of_nesting;", "        // Define a stack to hold the groups\
    \ of parentheses.\n        Stack<String> stack = new Stack<>();\n        \n  \
    \      // Pop all groups out of paren_string and push them into the stack until\
    \ parentheses are unbalanced.\n        for(int i = 0; i < paren_string.length();\
    \ i++) {\n            char ch = paren_string.charAt(i);\n            \n      \
    \      // Handle parentheses.\n            if(ch == '(')\n                stack.push(ch);\n\
    \            else if(ch == ')') {\n                if(stack.isEmpty())\n     \
    \               throw new RuntimeException(\"No matching closing parentheses.\"\
    );\n                else {\n                    stack.pop();\n               \
    \ }\n            }\n            else {\n                throw new RuntimeException(\"\
    Invalid parentheses \" + ch);\n            }\n        }\n        \n        //\
    \ Now we have all groups out. Now we need to find the deepest level of nesting.\n\
    \        List<Integer> deepest_levels_of_nesting = new ArrayList<>();\n      \
    \  while(!stack.isEmpty()) {\n            String current_level = stack.pop();\n\
    \            deepest_levels_of_nesting.add(deepest_levels_of_nesting.size());\n\
    \            int deepest_level = deepest_levels_of_nesting.get(deepest_levels_of_nesting.size()\
    \ - 1);\n            for(int i = 0; i < current_level.length(); i++) {\n     \
    \           char ch = current_level.charAt(i);\n                if(ch == '(')\n\
    \                    stack.push(ch);\n                else if(ch == ')') {\n \
    \                   if(stack.isEmpty())\n                        throw new RuntimeException(\"\
    No matching closing parentheses.\");\n                    else {\n           \
    \             stack.pop();\n                    }\n                }\n       \
    \     }\n        }\n        \n        return deepest_levels_of_nesting;", "  \
    \      // Use a HashMap to count the parentheses.\n        HashMap<String, Integer>\
    \ paren_counter = new HashMap<String, Integer>();\n        // For every parenthesis\
    \ in the string, increment its count.\n        for (char c : paren_string.toCharArray())\
    \ {\n            if (c == '(') paren_counter.put(c, paren_counter.get(c) + 1);\n\
    \            if (c == ')') paren_counter.put(c, paren_counter.get(c) - 1);\n \
    \       }\n        // If no more parentheses are found, the level is zero.\n \
    \       if (paren_counter.equals(new HashMap<String, Integer>())) return new ArrayList<Integer>();\n\
    \        // Sort the counters from largest to smallest.\n        ArrayList<Integer>\
    \ sorted_paren_count = new ArrayList<Integer>(paren_counter.values());\n     \
    \   Collections.sort(sorted_paren_count);\n        // Return list with deepest\
    \ level.\n        return sorted_paren_count.subList(0, sorted_paren_count.size()\
    \ - 1);", "        ArrayList<Integer> max_level = new ArrayList<>();\n       \
    \ Stack<Integer> level = new Stack<>();\n        ArrayList<Integer> ans = new\
    \ ArrayList<>();\n        for (int i = 0; i < paren_string.length(); i++) {\n\
    \            if (paren_string.charAt(i) == '(') {\n                level.push(new\
    \ Integer(0));\n            } else if (paren_string.charAt(i) == ')') {\n    \
    \            int current_level = level.size();\n                while (current_level\
    \ > 0 && !level.isEmpty()) {\n                    level.pop();\n             \
    \       current_level--;\n                }\n                if (current_level\
    \ > max_level.size()) max_level = new ArrayList<>(current_level);\n          \
    \      max_level.add(current_level);\n            } else {\n                int\
    \ current_level = level.size();\n                while (current_level > 0 && !level.isEmpty())\
    \ {\n                    level.pop();\n                    current_level--;\n\
    \                }\n                if (current_level > max_level.size()) max_level\
    \ = new ArrayList<>(current_level);\n                level.push(new Integer(current_level));\n\
    \            }\n        }\n        level.pop();\n        for (Integer i : max_level)\
    \ {\n            ans.add(i);\n        }\n        return ans;", "        int level\
    \ = 0;\n        ArrayList<Integer> parens = new ArrayList<>();\n        for (char\
    \ c : paren_string.toCharArray()) {\n            if (c == '(') {\n           \
    \     if (parens.isEmpty() || parens.get(parens.size() - 1) < level) {\n     \
    \               parens.add(level);\n                } else {\n               \
    \     parens.set(parens.size() - 1, parens.get(parens.size() - 1) + 1);\n    \
    \            }\n            } else if (c == ')') {\n                if (parens.get(parens.size()\
    \ - 1) == level) {\n                    parens.remove(parens.size() - 1);\n  \
    \              } else {\n                    parens.set(parens.size() - 1, parens.get(parens.size()\
    \ - 1) - 1);\n                }\n            } else {\n                throw new\
    \ IllegalArgumentException(\"invalid paren string: \" + paren_string);\n     \
    \       }\n            level++;\n        }\n        return parens;", "       \
    \ ArrayList<Integer> level_of_nestings = new ArrayList<Integer>();\n        for\
    \ (String nested_parens : paren_string.split(\" \")) {\n            ArrayList<Integer>\
    \ curr_level_of_nestings = parseNestedParens(nested_parens);\n            level_of_nestings.addAll(curr_level_of_nestings);\n\
    \        }\n        return level_of_nestings;", "        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        for(int i = 0; i < paren_string.length(); i++)\
    \ {\n            if(paren_string.charAt(i) == '(') {\n                result.add(i\
    \ + 1);\n            } else if(paren_string.charAt(i) == ')') {\n            \
    \    while(result.size() > 0) {\n                    if(result.get(result.size()\
    \ - 1) == i) {\n                        result.remove(result.get(result.size()\
    \ - 1));\n                    }\n                    else {\n                \
    \        result.add(result.size());\n                        break;\n        \
    \            }\n                }\n            }\n        }\n        return result;",
  "        ArrayList<Integer> results = new ArrayList<>();\n        if (paren_string.isEmpty())\n\
    \            return results;\n        int counter = 0;\n        char[] char_array\
    \ = paren_string.toCharArray();\n        for (int i = 0; i < char_array.length;\
    \ i++) {\n            if (char_array[i] == '(') {\n                counter++;\n\
    \            } else if (char_array[i] == '(') {\n                counter--;\n\
    \            }\n            if (counter == 0) {\n                results.add(counter);\n\
    \            }\n        }\n        return results;", "        ArrayList<Integer>\
    \ parentheses = new ArrayList<Integer>();\n        Stack<String> stack = new Stack<String>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            char ch\
    \ = paren_string.charAt(i);\n            switch (ch) {\n                case ')':\n\
    \                    if (stack.isEmpty()) {\n                        throw new\
    \ RuntimeException(\"Mismatched parentheses. Please re-input.\");\n          \
    \          }\n                    String s = stack.pop();\n                  \
    \  parentheses.add(s.length());\n                    break;\n                case\
    \ ')':\n                    stack.pop();\n                    break;\n       \
    \         case '(':\n                    stack.push(String.valueOf(ch));\n   \
    \                 break;\n                default:\n                    stack.push(String.valueOf(ch));\n\
    \            }\n        }\n        parentheses.add(stack.size());\n        return\
    \ parentheses;", "        ArrayList<Integer> results = new ArrayList<Integer>();\n\
    \        ArrayList<String> parens = new ArrayList<String>();\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\)\\\\s*\\\\(\", \" \");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\s+\", \" \");\n        paren_string = paren_string.replaceAll(\"\
    \\\\s+\\\\)\\\\s*\\\\(\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\s+\\\\)\\\\s*\\\\(.*\\\\)\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\s+\\\\)\\\\s*\\\\(.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\s*\\\\)\\\\s*\\\\(.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\s+\\\\(.*?\\\\)\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\s+\\\\(.*?\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\
    \\s+\\\\)\\\\s*\\\\(.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\s+\\\\(.*?\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\
    \\s+\\\\(.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\\
    s+\\\\(.*?\\\\)\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\
    \\s+\\\\(.*?\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\\
    s+\\\\(.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\(\"\
    , \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\)\", \")\");\n\
    \        paren_string = paren_string.replaceAll(\"\\\\s+\", \"(\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\(.*\\\\)\", \"(\");\n        paren_string =\
    \ paren_string.replaceAll(\"\\\\(.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\(.*?\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\(.*?\\\
    \\)\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\(.*?\", \"\
    (\");\n        paren_string = paren_string.replaceAll(\"\\\\(.*\", \"(\");\n \
    \       paren_string = paren_string.replaceAll(\"\\\\(.*?\\\\)\", \"(\");\n  \
    \      paren_string = paren_string.replaceAll(\"\\\\(.*?\", \"(\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\(.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\(.*?\\\\)\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\\
    (.*?", "        ArrayList<Integer> res = new ArrayList<Integer>();\n        int\
    \ stack = 0, par = 0, level = 1;\n        while(paren_string.charAt(0) == '('\
    \ && paren_string.length() > 1) {\n            par++;\n            paren_string\
    \ = paren_string.substring(1);\n            while(paren_string.charAt(0) == '\
    \ ' || paren_string.charAt(0) == '(' || paren_string.charAt(0) == ')') {\n   \
    \             paren_string = paren_string.substring(1);\n            }\n     \
    \       paren_string = paren_string.substring(1);\n            while(paren_string.charAt(0)\
    \ == ')' && stack > 0) {\n                res.add(level);\n                paren_string\
    \ = paren_string.substring(1);\n                stack--;\n            }\n    \
    \        level++;\n        }\n        if(paren_string.length() > 0) {\n      \
    \      res.add(level);\n        }\n        return res;", "        ArrayList<Integer>\
    \ paren_level = new ArrayList<>();\n        ArrayList<String> nested_strings =\
    \ paren_string.split(\" \");\n        Iterator<String> iterator = nested_strings.iterator();\n\
    \        while (iterator.hasNext()) {\n            String s = iterator.next();\n\
    \            paren_level.add(s.length());\n            if (s.startsWith(\"(\"\
    ) && s.endsWith(\")\")) {\n                int current_level = paren_level.size()\
    \ - 1;\n                for (int i = 0; i < current_level; i++) {\n          \
    \          paren_level.remove(0);\n                }\n                paren_level.add(current_level);\n\
    \            }\n        }\n        return paren_level;", "        if (paren_string.trim().equals(\"\
    \")) return new ArrayList<Integer>();\n        // The output will be stored here\n\
    \        ArrayList<Integer> max_levels = new ArrayList<Integer>();\n        //\
    \ The input will be stored here\n        ArrayList<Integer> parens = new ArrayList<Integer>();\n\
    \        // The current depth of the parenthesis stack\n        int cur_depth\
    \ = 0;\n        // Go through each character of the parenthesis string\n     \
    \   for (char c : paren_string.toCharArray()) {\n            String s = String.valueOf(c);\n\
    \            // If the current character is opening, then add to the parenthesis\
    \ stack\n            if (s.equals('(')) {\n                if (cur_depth == 0)\
    \ throw new Exception(\"Input is not a valid nested parenthesis string.\");\n\
    \                parens.add(cur_depth);\n                cur_depth++;\n      \
    \          // If the parenthesis stack is full then store the output\n       \
    \         if (cur_depth == max_levels.size()) {\n                    max_levels.add(parens.size());\n\
    \                }\n            }\n            // If the current character is\
    \ closing, then remove from the parenthesis stack\n            else if (s.equals(')'))\
    \ {\n                // If the current depth of the parenthesis stack is greater\
    \ than the max levels, then store the output\n                if (cur_depth >\
    \ max_levels.size()) {\n                    max_levels.add(parens.size());\n \
    \               }\n                cur_depth--;\n            }\n        }\n  \
    \      // If the current depth of the parenthesis stack is greater than the max\
    \ levels, then store the output\n        if (cur_depth > max_levels.size()) {\n\
    \            max_levels.add(parens.size());\n        }\n        return max_levels;",
  "        ArrayList<Integer> result = new ArrayList<>();\n        Stack<Integer>\
    \ parens = new Stack<>();\n        ArrayList<Integer> stack = new ArrayList<>();\n\
    \n        for (char ch : paren_string.toCharArray()) {\n            switch (ch)\
    \ {\n                case '(':\n                    parens.push(0);\n        \
    \            break;\n                case ')':\n                    parens.pop();\n\
    \                    break;\n                default:\n                    if\
    \ (parens.isEmpty()) {\n                        result.add(0);\n             \
    \       } else {\n                        result.add(parens.pop() + 1);\n    \
    \                }\n                    break;\n            }\n        }\n   \
    \     return result;", "        // Initialize output array\n        ArrayList<Integer>\
    \ max_level = new ArrayList<Integer>();\n        // For each parenthesis, parse\
    \ its substring and call recursively\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            int level = 0;\n            // For each parenthesis character,\
    \ increment level if it matches the next parenthesis character\n            while\
    \ (paren_string.charAt(i) == '(') level++;\n            while (paren_string.charAt(i)\
    \ == ')') level--;\n            if (level > max_level.get(max_level.size()-1))\
    \ max_level.add(level);\n        }\n        // Print the output array\n      \
    \  System.out.println(max_level);\n        return max_level;", "        // Initialize\
    \ a list of integers to store the result of the parsing.\n        ArrayList<Integer>\
    \ result = new ArrayList<>();\n        // Use a stack to keep track of whether\
    \ parentheses are stacked or not.\n        Stack<Boolean> stack_of_parentheses\
    \ = new Stack<>();\n        for (int i = 0; i < paren_string.length(); i++) {\n\
    \            // If the parentheses are stacked, then the number of nested parentheses\
    \ will be added to the result\n            // and push it on the stack. Otherwise,\
    \ just add the character to the result and push it on\n            // the stack.\n\
    \            if (paren_string.charAt(i) == '(') {\n                stack_of_parentheses.push(true);\n\
    \            } else if (paren_string.charAt(i) == ')') {\n                stack_of_parentheses.pop();\n\
    \            }\n            if (stack_of_parentheses.isEmpty()) {\n          \
    \      result.add(i);\n            }\n        }\n        return result;", "  \
    \      ArrayList<Integer> max_levels = new ArrayList<Integer>();\n        Stack<Integer>\
    \ levels = new Stack<Integer>();\n        ArrayList<Integer> current_levels =\
    \ new ArrayList<Integer>();\n        // Iterate through parenthesis and add levels\
    \ of nesting\n        for (int i = 0; i < paren_string.length(); i++) {\n    \
    \        if (paren_string.charAt(i) == '(') {\n                current_levels.add(1);\n\
    \            } else if (paren_string.charAt(i) == ')') {\n                current_levels.add(current_levels.pop());\n\
    \            } else {\n                levels.push(current_levels.pop());\n  \
    \          }\n        }\n\n        // Keep track of max levels of nesting\n  \
    \      for (int i = current_levels.size() - 1; i >= 0; i--) {\n            if\
    \ (max_levels.size() < current_levels.get(i)) {\n                max_levels.add(current_levels.get(i));\n\
    \            }\n        }\n\n        return max_levels;", "        ArrayList<Integer>\
    \ return_list = new ArrayList<Integer>();\n        if (paren_string == null)\n\
    \            return return_list;\n        paren_string = paren_string.replaceAll(\"\
    [()]\", \"\");\n        paren_string = paren_string.replaceAll(\"\\\\s\", \"\"\
    );\n        paren_string = paren_string.trim();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(')\n                return_list.add(1);\n\
    \            else if (paren_string.charAt(i) == ')')\n                return_list.add(0);\n\
    \        }\n        return return_list;", "        ArrayList<Integer> paren_levels\
    \ = new ArrayList<>();\n        ArrayList<Integer> paren_level = new ArrayList<>();\n\
    \        String curr_paren = \"\";\n        for (int i=0; i<paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == ')'){\n                paren_level.add(paren_level.size()-1);\n\
    \                paren_levels.add(paren_level.size()-1);\n                curr_paren\
    \ = \"\";\n            }\n            if (paren_string.charAt(i) == '(' && paren_level.isEmpty()\
    \ && !paren_level.isEmpty()){\n                paren_level = new ArrayList<>();\n\
    \                paren_levels.add(paren_level.size()-1);\n            }\n    \
    \        if (paren_string.charAt(i) == ')' && paren_level.isEmpty() && !paren_level.isEmpty()){\n\
    \                paren_level = new ArrayList<>();\n                paren_levels.add(paren_level.size()-1);\n\
    \            }\n            if (paren_string.charAt(i) == ' ' && paren_level.isEmpty()){\n\
    \                curr_paren = \"\";\n            }\n            else if (paren_string.charAt(i)\
    \ == ' ' && curr_paren == \"\"){\n                curr_paren = paren_string.charAt(i);\n\
    \            }\n            else if (paren_string.charAt(i) == ')' && curr_paren\
    \ != \"\"){\n                curr_paren = paren_string.charAt(i);\n          \
    \  }\n            else if (paren_string.charAt(i) == '(' && curr_paren != \"\"\
    ){\n                curr_paren = paren_string.charAt(i);\n            }\n    \
    \        else if (paren_string.charAt(i) != ' ' && paren_string.charAt(i) != ')'\
    \ && paren_string.charAt(i) != '('){\n                curr_paren = paren_string.charAt(i);\n\
    \            }\n        }\n        return paren_levels;", "        ArrayList<Integer>\
    \ levels = new ArrayList<Integer>();\n        ArrayList <String> group_stack =\
    \ new ArrayList <String>();\n        int group_level = 0;\n        for (char c\
    \ : paren_string.toCharArray()) {\n            switch (c) {\n                case\
    \ '(':\n                    group_stack.add(\"\" + c);\n                    levels.add(group_level);\n\
    \                    group_level++;\n                    break;\n            \
    \    case ')':\n                    int group_depth = levels.get(group_stack.size()\
    \ - 1);\n                    if (group_depth >= levels.size()) throw new RuntimeException(\"\
    Inconsistent input\");\n                    levels.add(group_depth);\n       \
    \             group_stack.remove(group_stack.size() - 1);\n                  \
    \  break;\n                default:\n                    if (group_stack.size()\
    \ == 0) {\n                        throw new RuntimeException(\"Inconsistent input\"\
    );\n                    }\n                    group_stack.add(\"\" + c);\n  \
    \                  break;\n            }\n        }\n        return levels;",
  "        ArrayList<Integer> paren_levels = new ArrayList<Integer>();\n        for\
    \ (String str : paren_string.split(\"\\\\s\")) {\n            paren_levels.add(getLevel(str));\n\
    \        }\n        return paren_levels;", "        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        String s = paren_string;\n        while (s.startsWith(\"\
    (\") && s.endsWith(\")\")) {\n            int depth = 0;\n            while (s.startsWith(\"\
    (\") && s.endsWith(\")\")) {\n                if (s.startsWith(\"(\")) {\n   \
    \                 depth += 1;\n                } else {\n                    depth\
    \ -= 1;\n                }\n                s = s.substring(1);\n            }\n\
    \            results.add(depth);\n            s = s.substring(1, s.length() -\
    \ 1);\n        }\n        return results;", "        ArrayList<Integer> results\
    \ = new ArrayList<Integer>();\n        int nesting_level = 0;\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            int j = i;\n         \
    \   int k = i;\n            int num_open = 0;\n            for (; j > 0 && paren_string.charAt(j\
    \ - 1) == '('; j--, k++, nesting_level++) {\n                ++num_open;\n   \
    \         }\n            while (k < paren_string.length() && (paren_string.charAt(k)\
    \ == ' ' || paren_string.charAt(k) == ')')) {\n                ++num_open;\n \
    \               k++;\n            }\n            while (j < paren_string.length()\
    \ && paren_string.charAt(j) == ' ') {\n                j++;\n            }\n \
    \           if (num_open == nesting_level) {\n                results.add(nesting_level);\n\
    \            }\n        }\n        return results;", "        ArrayList<Integer>\
    \ list_of_levels = new ArrayList<Integer>();\n        for(int i = 0; i < paren_string.length();\
    \ i++){\n            if(paren_string.charAt(i) == '('){\n                list_of_levels.add(i\
    \ + 1);\n            }\n            else if (paren_string.charAt(i) == ')'){\n\
    \                list_of_levels.remove(list_of_levels.get(list_of_levels.size()\
    \ - 1));\n            }\n        }\n        return list_of_levels;", "       \
    \ ArrayList<Integer> result = new ArrayList<>();\n        for (int i = 0; i <\
    \ paren_string.length(); i++) {\n            if (paren_string.charAt(i) == '(')\
    \ {\n                int level = 1;\n                for (int j = i; j < paren_string.length();\
    \ j++) {\n                    if (paren_string.charAt(j) == ')') {\n         \
    \               result.add(level);\n                        i = j + 1;\n     \
    \                   level++;\n                        break;\n               \
    \     }\n                }\n            }\n        }\n        return result;",
  "        ArrayList<Integer> results = new ArrayList<>();\n        if (paren_string.length()\
    \ == 0) {\n            results.add(0);\n        }\n        String s = paren_string.trim();\n\
    \        if (s.startsWith(\"(\")) {\n            results.add(0);\n        }\n\
    \        if (s.endsWith(\")\")) {\n            results.add(0);\n        }\n\n\
    \        // Step 1. Get all the paren group lengths.\n        ArrayList<Integer>\
    \ paren_lengths = getParenGroupLengths(s);\n\n        // Step 2. Scan all the\
    \ lengths and find the deepest level.\n        for (int i = 0; i < paren_lengths.size();\
    \ i++) {\n            int current_length = paren_lengths.get(i);\n           \
    \ if (current_length > results.get(i)) {\n                results.set(i, current_length);\n\
    \            }\n        }\n\n        // Step 3. Convert lengths to lengths of\
    \ groups.\n        ArrayList<Integer> paren_group_lengths = new ArrayList<>();\n\
    \        for (int i = 0; i < paren_lengths.size(); i++) {\n            int current_length\
    \ = paren_lengths.get(i);\n            for (int j = 0; j < current_length; j++)\
    \ {\n                paren_group_lengths.add(i);\n            }\n        }\n\n\
    \        // Step 4. Scan the groups until we find a deeper level.\n        for\
    \ (int i = 0; i < paren_group_lengths.size(); i++) {\n            int current_group_length\
    \ = paren_group_lengths.get(i);\n            if (current_group_length > 0) {\n\
    \                ArrayList<Integer> next_group_lengths = new ArrayList<>();\n\
    \                for (int j = 0; j < paren_group_lengths.size(); j++) {\n    \
    \                int next_group_length = paren_group_lengths.get(j);\n       \
    \             if (j == i) {\n                        next_group_lengths.add(current_group_length);\n\
    \                        break;\n                    }\n                    next_group_lengths.add(next_group_length);\n\
    \                }\n                while (next_group_lengths.size() > 0) {\n\
    \                    next_group_lengths.remove(0);\n                }\n      \
    \          results.addAll(next_group_lengths);\n            }\n        }\n   \
    \     return results;", "        ArrayList<Integer> result = new ArrayList<>();\n\
    \        Queue<Integer> stack = new LinkedList<>();\n        StringBuilder stringBuilder\
    \ = new StringBuilder();\n        for (char c : paren_string.toCharArray()) {\n\
    \            if (c == '(' || c == ')') {\n                stringBuilder.append(c);\n\
    \                result.add(stringBuilder.length());\n                if (stack.size()\
    \ == 0)\n                    result.add(1);\n                stack.offer(stringBuilder.length());\n\
    \            }\n            else if (c == ' ') {\n                if (stringBuilder.length()\
    \ != 0) {\n                    result.add(stringBuilder.length());\n         \
    \       }\n                stringBuilder = new StringBuilder();\n            }\n\
    \            else if (c == ')') {\n                if (stringBuilder.length()\
    \ != 0)\n                    result.add(stringBuilder.length());\n           \
    \     while (stack.size() > 0 && stack.poll().equals(result.size())) {\n     \
    \               result.add(stack.poll());\n                }\n               \
    \ stringBuilder = new StringBuilder();\n            }\n        }\n        return\
    \ result;", "        ArrayList<Integer> results = new ArrayList<>();\n       \
    \ int currentLevel = 0;\n        Stack<Integer> parenStack = new Stack<>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            char c\
    \ = paren_string.charAt(i);\n            if (c == '(') {\n                parenStack.push(i);\n\
    \            } else if (c == ')') {\n                int parenCount = parenStack.size()\
    \ - 1;\n                if (parenCount > 0) {\n                    if (parenStack.peek()\
    \ == currentLevel) {\n                        currentLevel--;\n              \
    \      } else {\n                        currentLevel++;\n                   \
    \ }\n                }\n                parenStack.pop();\n            }\n   \
    \     }\n        for (int i = 0; i < parenStack.size(); i++) {\n            int\
    \ parenCount = parenStack.size() - 1;\n            if (parenCount > 0) {\n   \
    \             if (parenStack.peek() == currentLevel) {\n                    currentLevel--;\n\
    \                } else {\n                    currentLevel++;\n             \
    \   }\n            }\n        }\n        results.add(currentLevel);\n        return\
    \ results;", "        // Initialize an empty array that will store each parenthetic\
    \ group's depth of nesting\n        ArrayList<Integer> max_nested_depth = new\
    \ ArrayList<>();\n\n        // Initialize empty stack to store depth of nesting\
    \ of a parenthetic group\n        Stack<Integer> stack = new Stack<>();\n\n  \
    \      // Parse parenthetic groups from input\n        for(String group : paren_string.split(\"\
    \ \")){\n            // Add group's depth to stack\n            stack.push(group.length());\n\
    \        }\n\n        // If parenthetic groups are left with empty strings, stop\
    \ here\n        while(!stack.isEmpty()){\n            // Pop a group's depth of\
    \ nesting from the stack and add it to the max_nested_depth array\n          \
    \  max_nested_depth.add(stack.pop());\n        }\n\n        // Return max_nested_depth\
    \ array as a list\n        return max_nested_depth;", "        ArrayList<Integer>\
    \ max_levels_of_nesting = new ArrayList<>();\n        ArrayList<Integer> current_levels_of_nesting\
    \ = new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n\n     \
    \   for(int i = 0; i < paren_string.length(); ++i) {\n            char c = paren_string.charAt(i);\n\
    \            if(Character.isWhitespace(c)) {\n                continue;\n    \
    \        }\n            char next_c = paren_string.charAt(i + 1);\n          \
    \  if(Character.isWhitespace(next_c)) {\n                stack.add(String.valueOf(Character.toUpperCase(c)));\n\
    \                continue;\n            }\n            if(c == '(') {\n      \
    \          current_levels_of_nesting.add(0, 0);\n            }\n            else\
    \ if(Character.toUpperCase(c) != '(') {\n                current_levels_of_nesting.remove(0);\n\
    \                stack.remove(String.valueOf(Character.toUpperCase(c)));\n   \
    \         }\n            if(next_c == '(') {\n                next_c = paren_string.charAt(i\
    \ + 2);\n                if(Character.isWhitespace(next_c)) {\n              \
    \      stack.add(String.valueOf(Character.toUpperCase(next_c)));\n           \
    \         i += 2;\n                    continue;\n                }\n        \
    \        if(c == '(') {\n                    current_levels_of_nesting.add(1,\
    \ 1);\n                }\n                else if(Character.toUpperCase(c) !=\
    \ '(') {\n                    current_levels_of_nesting.remove(1);\n         \
    \           stack.remove(String.valueOf(Character.toUpperCase(c)));\n        \
    \        }\n                if(next_c == '(') {\n                    next_c =\
    \ paren_string.charAt(i + 3);\n                    if(Character.isWhitespace(next_c))\
    \ {\n                        stack.add(String.valueOf(Character.toUpperCase(next_c)));\n\
    \                        i += 3;\n                        continue;\n        \
    \            }\n                    if(c == '(') {\n                        current_levels_of_nesting.add(2,\
    \ 2);\n                    }\n                    else if(Character.toUpperCase(c)\
    \ != '(') {\n                        current_levels_of_nesting.remove(2);\n  \
    \                      stack.remove(String.valueOf(Character.toUpperCase(c)));\n\
    \                    }\n                    if(next_c == '(') {\n            \
    \            next_c = paren_string.charAt(i + 4);\n                        if(Character.isWhitespace(next_c))\
    \ {\n                            stack.add(String.valueOf(Character.toUpperCase(next_c)));\n\
    \                            i += 4;\n                            continue;\n\
    \                        }\n                        if(c == '(') {\n         \
    \                   current_levels_of_nesting.add(3, 3);\n                   \
    \     }\n                        else if(Character.toUpperCase(c) != '(') {\n\
    \                            current_levels_of_nesting.remove(3);\n          \
    \                  stack.remove(String.valueOf(Character.toUpperCase(c)));\n \
    \                       }\n                    }\n                }\n        \
    \    }\n            current_levels_of_nesting.add(stack.isEmpty() ? 0 : stack.pop());\n\
    \        }\n        for(int level : current_levels_of_nesting) {", "        ArrayList<Integer>\
    \ result = new ArrayList<Integer>();\n        int[] count = new int[paren_string.length()];\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                if (count[i - 1] == 0)\n                    count[i\
    \ - 1]++;\n                else {\n                    count[i - 1]++;\n     \
    \               if (count[i - 1] > result.size())\n                        result.add(i\
    \ - 1);\n                }\n            } else if (paren_string.charAt(i) == ')')\
    \ {\n                count[i - 1]--;\n            }\n        }\n        if (Arrays.stream(count).sum()\
    \ < 0)\n            result.add(result.size() - 1);\n        return result;", " \
    \       ArrayList<Integer> levels = new ArrayList<>();\n        ArrayList<Integer>\
    \ level_count = new ArrayList<>();\n        int level = 0;\n        for (int i\
    \ = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            switch (c) {\n                case '(':\n                    level++;\n\
    \                    break;\n                case ')':\n                    level--;\n\
    \                    levels.add(level);\n                    level_count.add(level);\n\
    \                    break;\n            }\n        }\n        return level_count;",
  "        // For each '(' we insert an element in our Stack and each ')' we remove\
    \ one from our Stack.\n        Stack<Integer> stack_of_opening_parentheses = new\
    \ Stack<Integer>();\n        Stack<Integer> stack_of_closing_parentheses = new\
    \ Stack<Integer>();\n\n        // We iterate over each character of the string\
    \ and insert '(' and ')'\n        // if they meet a condition (i.e., they have\
    \ different characters).\n        // We then count the number of elements in the\
    \ Stack.\n        // We then return the element with the highest number of elements.\n\
    \        // If there are multiple elements with equal numbers, we return the smallest\
    \ one.\n        for (char c : paren_string.toCharArray()) {\n            if (c\
    \ == '(') {\n                stack_of_opening_parentheses.push(c);\n         \
    \   } else if (c == ')') {\n                if (stack_of_closing_parentheses.size()\
    \ > stack_of_opening_parentheses.size()) {\n                    stack_of_closing_parentheses.push(c);\n\
    \                } else if (stack_of_closing_parentheses.size() < stack_of_opening_parentheses.size())\
    \ {\n                    stack_of_opening_parentheses.push(c);\n             \
    \   }\n            }\n        }\n\n        // Once we finish, we know the number\
    \ of opening parentheses and the number of closing parentheses.\n        // We\
    \ now need to loop through the Stack and compare the elements to find which one\
    \ has the highest number of elements.\n        int num_of_opening_parentheses\
    \ = stack_of_opening_parentheses.size();\n        int num_of_closing_parentheses\
    \ = stack_of_closing_parentheses.size();\n        ArrayList<Integer> max_num_of_opening_parentheses_elements\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> max_num_of_closing_parentheses_elements\
    \ = new ArrayList<Integer>();\n\n        for (int i = 0; i < num_of_opening_parentheses;\
    \ i++) {\n            // If we are closing parentheses, we must stop comparing\
    \ elements with the lowest number of elements.\n            if (stack_of_closing_parentheses.isEmpty())\
    \ {\n                break;\n            }\n\n            // We get the element\
    \ at the top of the Stack so we can compare it to all elements in the Stack.\n\
    \            Integer opening_parentheses = stack_of_opening_parentheses.peek();\n\
    \            int num_of_elements = stack_of_opening_parentheses.size();\n\n  \
    \          for (int j = 0; j < num_of_elements; j++) {\n                Integer\
    \ current_element = stack_of_opening_parentheses.peek();\n\n                //\
    \ If the number of opening parentheses elements equals the number of closing parentheses\
    \ elements, then we know that\n                // the elements at the top of the\
    \ Stack are equal, so we know that they are the deepest level of nesting.\n  \
    \              // We set the element at the top of the Stack as the deepest level\
    \ of nesting.\n                if (num_of_opening_parentheses == num_of_closing_parentheses)\
    \ {\n                    max_num_of_opening_parentheses_elements.add(current_element);\n\
    \                    break;\n                }\n\n                // If the current\
    \ level of nesting between the opening and closing parentheses is equal to the ",
  "        // Initialize a list to store our results.\n        ArrayList<Integer>\
    \ results = new ArrayList<Integer>();\n\n        // For each character in the\
    \ input string...\n        for (char c : paren_string.toCharArray()) {\n     \
    \       // If the character is a left paren...\n            if (c == '(') {\n\
    \                // If our stack is empty, increment our current result by 1.\n\
    \                if (results.isEmpty())\n                    results.add(1);\n\
    \                else {\n                    // Otherwise, decrement the top of\
    \ our result by 1.\n                    int top = results.get(results.size() -\
    \ 1);\n                    results.set(results.size() - 1, top - 1);\n       \
    \         }\n            }\n            // Else, if the character is a right paren...\n\
    \            else if (c == ')') {\n                // If our stack is not empty...\n\
    \                if (results.size() > 0) {\n                    // And if we have\
    \ a left paren, decrement the top of our result by 1.\n                    if\
    \ (results.get(0) == '(')\n                        results.set(results.size()\
    \ - 1, results.get(results.size() - 1) - 1);\n                }\n            }\n\
    \            // Else, just add the current character to our stack.\n         \
    \   else\n                results.add(c);\n        }\n\n        // Return the\
    \ list of results.\n        return results;", "        // Initialize and fill\
    \ the list\n        ArrayList<Integer> list = new ArrayList<Integer>();\n    \
    \    // Create a stack of type Stack<Character>\n        Stack<Character> stack\
    \ = new Stack<Character>();\n        // Go through each character in the string\n\
    \        for(int i = 0; i < paren_string.length(); i++) {\n            // Get\
    \ character at index i\n            char c = paren_string.charAt(i);\n       \
    \     // If the character is a left parentheses, push it onto the stack\n    \
    \        if(c == '(') {\n                stack.push(c);\n            }\n     \
    \       // If the character is a right parentheses, pop the stack until the stack\
    \ is empty\n            if(c == ')') {\n                // If the stack is empty,\
    \ the parentheses were unbalanced\n                if(stack.empty()) {\n     \
    \               return new ArrayList<Integer>();\n                }\n        \
    \        // Get the top element in the stack\n                char top_element\
    \ = stack.pop();\n                // If the top element is a left parentheses,\
    \ push the stack onto the list\n                if(top_element == '(') {\n   \
    \                 list.add(list.size());\n                }\n            }\n \
    \       }\n        // Return the list that was created above\n        return list;",
  "        ArrayList<Integer> num_list = new ArrayList<>();\n        ArrayList<Integer>\
    \ stack = new ArrayList<>();\n        stack.add(0);\n        int current_level\
    \ = 1;\n        Stack<Integer> stack_new = new Stack<>();\n        stack_new.add(0);\n\
    \n        for (int i = 0; i < paren_string.length(); i++) {\n            char\
    \ curr_char = paren_string.charAt(i);\n            if (curr_char == '(') {\n \
    \               stack.add(current_level);\n                stack_new.add(current_level);\n\
    \                current_level++;\n            } else if (curr_char == ')') {\n\
    \                int top = stack.get(stack.size() - 1);\n                while\
    \ (top > 1) {\n                    num_list.add(top - 1);\n                  \
    \  top--;\n                }\n                stack.remove(stack.size() - 1);\n\
    \                stack_new.remove(stack_new.size() - 1);\n                current_level--;\n\
    \            }\n        }\n        return num_list;", "        ArrayList<Integer>\
    \ output = new ArrayList<Integer>();\n        int level = 0;\n        int stack_count\
    \ = 0;\n        for (char c : paren_string.toCharArray()) {\n            switch\
    \ (c) {\n                case '(':\n                    output.add(level);\n \
    \                   level++;\n                    break;\n                case\
    \ ')':\n                    level--;\n                    if (level == 0) {\n\
    \                        stack_count++;\n                    } else {\n      \
    \                  stack_count--;\n                    }\n                   \
    \ break;\n                default:\n                    break;\n            }\n\
    \        }\n        if (stack_count == 0 && level > 0) {\n            level--;\n\
    \        }\n        output.add(level);\n        return output;", "        ArrayList<Integer>\
    \ levels = new ArrayList<>();\n        ArrayList<Character> chars = new ArrayList<>();\n\
    \        ArrayList<Integer> current_levels = new ArrayList<>();\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            if (c == '(') levels.add(0);\n            else if (c == ')') {\n\
    \                int l = levels.get(levels.size() - 1);\n                if (current_levels.size()\
    \ == 0) {\n                    levels.add(l);\n                    chars.add(c);\n\
    \                } else {\n                    int level_difference = Math.abs(current_levels.get(current_levels.size()\
    \ - 1) - l);\n                    if (level_difference > 1) {\n              \
    \          levels.add(l);\n                        chars.add(c);\n           \
    \             current_levels.add(l);\n                    }\n                }\n\
    \            }\n            if (c == '(') {\n                current_levels.add(0);\n\
    \            } else {\n                current_levels.add((chars.size() - 1) +\
    \ chars.size());\n            }\n        }\n        return levels;", "       \
    \ ArrayList<Integer> stack = new ArrayList<Integer>();\n        for(int i = 0;\
    \ i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            if(c == '(') {\n                stack.push(i);\n            }\n \
    \           if(c == ')') {\n                int index = stack.pop();\n       \
    \         int current_length = i - index - 1;\n                if(stack.isEmpty())\
    \ {\n                    // Only one item on the stack\n                    if(current_length\
    \ >= 2) {\n                        stack.push(current_length);\n             \
    \       }\n                } else {\n                    // Two or more items\
    \ on the stack\n                    if(current_length >= 2) {\n              \
    \          stack.push(current_length + 1);\n                    }\n          \
    \      }\n            }\n        }\n        return stack;", "        ArrayList<Integer>\
    \ return_val = new ArrayList<Integer>();\n\n        // Use a stack to check whether\
    \ the parenthesis is balanced.\n        // Start with a stack of size zero and\
    \ push all open parentheses.\n        Stack<String> stack = new Stack<String>();\n\
    \        for (char c : paren_string.toCharArray()) {\n            if (c == '(')\
    \ {\n                stack.push(c);\n            } else if (c == ')') {\n    \
    \            if (stack.size() > 0) {\n                    return_val.add(stack.size());\n\
    \                }\n                stack.pop();\n            }\n        }\n \
    \       return return_val;"]
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- "    }\n}"
- "\n    }\n"
