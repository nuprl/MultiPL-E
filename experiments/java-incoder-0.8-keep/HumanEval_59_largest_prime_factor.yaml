completions:
- "        int largest_prime_factor = 0;\n        ArrayList<Integer> prime_factors\
  \ = new ArrayList<Integer>();\n        // Fill the primes ArrayList with primes\
  \ below n.\n        for(int i = 1 ; i <= n ; i++) {\n            if (n % i == 0)\
  \ {\n                prime_factors.add(i);\n            }\n        }\n        Collections.sort(prime_factors);\n\
  \        // Iterate through each prime factor, and increment the largest prime factor\
  \ found.\n        for(int x : prime_factors) {\n            int counter = 1;\n \
  \           for(int i = 1 ; i <= x ; i++) {\n                if (x % i == 0) {\n\
  \                    counter++;\n                }\n            }\n            if\
  \ (counter == x)\n                largest_prime_factor = x;\n        }\n       \
  \ return largest_prime_factor;"
- "        int largestPrimeFactor = Integer.MIN_VALUE;\n        for(long i = 2; i\
  \ <= n; i++){\n            if(n % i == 0){\n                largestPrimeFactor =\
  \ i;\n            }\n        }\n        return largestPrimeFactor;"
- "        int maxFactor = Integer.MIN_VALUE, maxFactorIndex = 0;\n        ArrayList<Integer>\
  \ factors = new ArrayList<Integer>();\n        // Scan the factors of n and build\
  \ factors array\n        for(int i = 2; i <= Math.sqrt(n); i++) {\n            if(n\
  \ % i == 0) {\n                factors.add(i);\n            }\n        }\n     \
  \   // Find first factor (largest prime factor)\n        for(int i = factors.size()-1;\
  \ i >= 0; i--) {\n            if(factors.get(i) > maxFactor) {\n               \
  \ maxFactor = factors.get(i);\n                maxFactorIndex = i;\n           \
  \ }\n        }\n        // Return the largest factor of n\n        return maxFactor;"
- "        Set<Integer> set = new HashSet<>();\n        while (!set.add(n)) {\n  \
  \          Set<Integer> ns = new HashSet<>();\n            while (n != 1) {\n  \
  \              if (n % 2 == 0) {\n                    n = n/2;\n               \
  \     continue;\n                }\n                if (n % 3 == 0) {\n        \
  \            n = n/3;\n                    continue;\n                }\n      \
  \          ns.add(n);\n                if (n % 5 == 0) {\n                    n\
  \ = n/5;\n                    continue;\n                }\n                n =\
  \ n/5;\n            }\n            set.retainAll(ns);\n        }\n        return\
  \ set.stream().max().orElse(1);"
- "        int i = 2;\n        int factor = 2;\n        while (factor * i <= n) {\n\
  \            if (n % i == 0) {\n                factor++;\n            }\n     \
  \       i++;\n        }\n        return factor;"
- "        int maxFactor = 0;\n        while (n % 2 == 0) {\n            n = n/2;\n\
  \            maxFactor++;\n        }\n        // now n is even, odd divisor will\
  \ cause max factor to be 1\n        while (n % 2 == 1) {\n            n = n/2;\n\
  \            maxFactor++;\n        }\n        while (n%3 != 0) {\n            n\
  \ = n/3;\n            maxFactor++;\n        }\n        return maxFactor;"
- '        // Implement this function in a new method'
- "        if(n < 2)\n            return 1;\n        HashSet<Integer> primeFactors\
  \ = new HashSet<>();\n        for(int i = 2; i <= Math.sqrt(n); i++) {\n       \
  \     if(n%i == 0) {\n                int j = i;\n                while(j < n) {\n\
  \                    if(n % j == 0)\n                        break;\n          \
  \          j++;\n                }\n                if(j > i)\n                \
  \    primeFactors.add(i);\n            }\n        }\n        int largestPrimeFactor\
  \ = -1;\n        for(Integer i : primeFactors) {\n            if(i > largestPrimeFactor)\n\
  \                largestPrimeFactor = i;\n        }\n        return largestPrimeFactor;"
- "        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n   \
  \     // Skip even numbers\n        for (int i = 2; i < Math.sqrt(n); i++) {\n \
  \           if (n % i == 0) {\n                primes.add(i);\n                n\
  \ = n / i;\n            }\n        }\n        Integer maxPrime = null;\n       \
  \ for (int i = 1; i <= n; i++) {\n            if (maxPrime == null || primes.stream().anyMatch(x\
  \ -> x == maxPrime)) {\n                maxPrime = i;\n            }\n        }\n\
  \        return maxPrime;"
- "        // TODO Auto-generated method stub\n        if(n==0)return 0;\n       \
  \ if(isPrime(n))return n;\n        int maxFact=2;\n        for(int i=3;i<=Math.sqrt(n);i+=2){\n\
  \            if(isPrime(i))maxFact=i;\n        }\n        return maxFact;"
- "        long p = n;\n        int l = 2;\n        while (p % 2 == 0) {\n       \
  \     p = p / 2;\n            l++;\n        }\n        long q = 2;\n        while\
  \ (p != 1 && q < n) {\n            long y = p;\n            p = q;\n           \
  \ q = y;\n            l++;\n        }\n        return l-1;"
- '        return largestPrimeFactor(n, 2, 2);'
- "        Set<Integer> factors = new HashSet<>();\n\n        for (int i = 2; i <=\
  \ n/i; i++) {\n            if (n % i == 0) {\n                factors.add(i);\n\
  \            }\n        }\n\n        while (true) {\n            int p = factors.stream().min((i)\
  \ -> { return Integer.compare(i, n/i); }).get();\n\n            if (p == n) {\n\
  \                return p;\n            }\n\n            factors.remove(p);\n  \
  \      }"
- "        int i = 2;\n        while (i <= n/2) {\n            if (n % i == 0) {\n\
  \                n = n/i;\n            } else {\n                i = i + 1;\n  \
  \          }\n        }\n        return n;"
- "        // Declare and initialize variables.\n        int largestFactor = 0;\n\
  \        int remainder;\n\n        // Check if n is prime\n        if (n % 2 ==\
  \ 0)\n            throw new IllegalArgumentException(\"n is not prime!\");\n   \
  \     if (n <= 1)\n            throw new IllegalArgumentException(\"n is too small!\"\
  );\n\n        // If n equals 1, then it is a prime.\n        if (n == 1)\n     \
  \       return 1;\n\n        // Find largest factor of the number n\n        for\
  \ (int i = 2; i <= n / 2; i++) {\n            // Divide n by every number between\
  \ i and the square root of n\n            while (n % i == 0) {\n               \
  \ remainder = n / i;\n                if (remainder > largestFactor) {\n       \
  \             largestFactor = remainder;\n                }\n            }\n   \
  \     }\n\n        // Return the largest prime factor of n\n        return largestFactor;"
- "        int largestFactor = n;\n        for(int i = 3; i <= n / i; i += 2) {\n\
  \            while(n % i == 0) {\n                largestFactor = i;\n         \
  \       n /= i;\n            }\n        }\n        return largestFactor;"
- "        if (n <= 1) return n;\n        int i = 2, factor = 2, count = 1;\n    \
  \    while(factor * factor <= n) {\n            if((n % factor) == 0) {\n      \
  \          count = count + 1;\n            }\n            factor++;\n        }\n\
  \        return count;"
- "        boolean is_prime=true;\n        for(int i=2; i<=n; i++)\n        {\n  \
  \          if(n%i==0)\n                is_prime=false;\n        }\n        if(is_prime)\n\
  \            return n;\n        else{\n            for(int i=3; i<=n; i+=2){\n \
  \               if(n%i==0)\n                    return n;\n            }\n     \
  \       return 0;\n        }"
- "        // Complete this function\n        int result = 1;\n        for (int i\
  \ = 2; i <= n / 2; i++) {\n            if (n % i == 0) {\n                for (int\
  \ j = 2; j <= i / j; j++) {\n                    if (i % j == 0) {\n           \
  \             result = i;\n                        break;\n                    }\n\
  \                }\n            }\n        }\n        return result;"
- "        \n        int largest = 1;\n        int i;\n        \n        boolean isPrime\
  \ = true;\n        for(i = 2; i <= Math.sqrt(n); i++) {\n            \n        \
  \    if(n%i == 0) {\n                isPrime = false;\n            }\n         \
  \   \n            if(isPrime) {\n                largest = i;\n            }\n \
  \       }\n        \n        return largest;"
- "        int i = 2;\n        while (n % i == 0) {\n            i += 2;\n       \
  \ }\n        while (n % 2 == 0) {\n            i += 1;\n            n /= 2;\n  \
  \      }\n        return i;"
- "        int result = 0;\n        int maxResult = n;\n        boolean isPrime =\
  \ true;\n        for(int i = 2; i <= maxResult; i++)\n        {\n            isPrime\
  \ = true;\n            for(int j = 2; j < i; j++)\n            {\n             \
  \   if(i % j == 0)\n                {\n                    isPrime = false;\n  \
  \                  break;\n                }\n            }\n            if(isPrime)\n\
  \            {\n                result = i;\n                break;\n          \
  \  }\n        }\n        return result;"
- "        List<Integer> factors = new ArrayList<Integer>();\n        for (int i =\
  \ 1; i <= n; i++) {\n            // If n is divisible by any factor between 2 and\
  \ i, then it is not prime\n            if (n % i == 0) {\n                factors.add(i);\n\
  \            }\n        }\n        if (factors.size() > 0) {\n            return\
  \ factors.get(factors.size() - 1);\n        } else {\n            return n;\n  \
  \      }"
- "        int largestPrimeFactor = 1;\n        int d = 2;\n        while(d < n &&\
  \ d < largestPrimeFactor) {\n            while(n % d == 0) {\n                largestPrimeFactor\
  \ = d;\n                n /= d;\n                d *= 2;\n            }\n      \
  \      d++;\n        }\n        return largestPrimeFactor;"
- "        if (n < 2) return 2;\n        if (n == 2) return n;\n        int max =\
  \ Integer.MIN_VALUE;\n        for(int i = 2; i <= n; i++) {\n            if (n %\
  \ i == 0) {\n                int j = i + 2;\n                while(j < n && n %\
  \ j == 0) {\n                    j++;\n                }\n                if (j\
  \ > max) max = j;\n            }\n        }\n        return max;"
- "        if (n < 2) return 2;\n        if (n <= 3) return n;\n        if (n % 2\
  \ == 0) return largestPrimeFactor(n / 2);\n        // Test for primeness using the\
  \ Sieve of Eratosthenes.\n        Set<Integer> primes = new HashSet<>();\n     \
  \   // Generate the primes from 2 to n. Skip composite numbers.\n        for (int\
  \ p = 2; p <= n; p++) primes.add(p);\n        for (int p = 2; p <= n; p++) {\n \
  \           for (int q = p * 2; q <= n; q += p) {\n                primes.add(q);\n\
  \            }\n        }\n        // Find largest prime factor.\n        Set<Integer>\
  \ primeFactors = primes.stream()\n                .filter(i -> n % i == 0)\n   \
  \             .collect(Collectors.toSet());\n        Integer largestPrimeFactor\
  \ = primeFactors.stream()\n                .max(Comparator.comparingInt(i -> i))\n\
  \                .get();\n        return largestPrimeFactor;"
- "        PrimeFactorsFinder finder = new PrimeFactorsFinder(n);\n        PrimeFactorsFinder.SieveOfEratosthenes\
  \ sieve = new PrimeFactorsFinder.SieveOfEratosthenes();\n        sieve.computePrimeFactors(finder);\n\
  \        return finder.largestPrimeFactor;"
- "        if (n <= 1) return n;\n        if (n % 2 == 0) return largestPrimeFactor(n\
  \ / 2);\n        int p = smallestPrimeFactor(n / 2);\n        for (int i = 3; i\
  \ <= n; i += 2) {\n            if (n % i == 0) continue;\n            while (p %\
  \ i == 0) {\n                p /= i;\n            }\n            if (p * p > n)\
  \ break;\n        }\n        return p;"
- "        Set<Integer> factors = new HashSet<>();\n        for (int i = 1; i <= n;\
  \ i++) {\n            if (n % i == 0) {\n                while (n % i == 0) {\n\
  \                    factors.add(i);\n                    n /= i;\n            \
  \    }\n            }\n        }\n        if (n > 1) {\n            while (n > 1)\
  \ {\n                if (factors.contains(n)) {\n                    return n;\n\
  \                }\n                factors.add(n);\n                n /= 2;\n \
  \           }\n        }\n        return 1;"
- "        int maxPrime = 1;\n        for (int i = 2; i <= n / 2; i++) {\n       \
  \     boolean isPrime = true;\n            for (int j = i; j < n; j++)\n       \
  \         if (n % j == 0)\n                    isPrime = false;\n            if\
  \ (isPrime)\n                maxPrime = i;\n        }\n        return maxPrime;"
- "        int maxFactor = 1;\n        for (int factor = 2; factor <= n / 2; factor++)\
  \ {\n            if (n % factor == 0) {\n                maxFactor = factor;\n \
  \           }\n        }\n        return maxFactor;"
- "        int max = 0;\n        for (int i = 2; i < n; i++) {\n            while\
  \ (n % i == 0) {\n                max += i;\n                n /= i;\n         \
  \   }\n        }\n        return max;"
- "        List<Integer> factors = new ArrayList<>();\n        for (; n > 1; n--)\
  \ { // n-- is unnecessary but improves performance.\n            if (isPrime(n))\
  \ {\n                factors.add(n);\n            }\n        }\n        return Math.max(factors);"
- "        // Create a list to hold all the prime factors.\n        ArrayList<Integer>\
  \ primeFactors = new ArrayList<>();\n        // Create a boolean array for storing\
  \ whether or not a factor is prime.\n        boolean[] isPrime = new boolean[n +\
  \ 1];\n        // Set the default return value.\n        int maxFactor = 1;\n  \
  \      // Check if n is prime.\n        if (n <= 1)\n            return maxFactor;\n\
  \        // Check if n is even.\n        if (n % 2 == 0)\n            maxFactor\
  \ = 2;\n        else\n            // Fill the array with the first prime factors\
  \ of n.\n            for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            \
  \    if (n % i == 0) {\n                    primeFactors.add(i);\n             \
  \       isPrime[i] = true;\n                }\n            }\n        // Check if\
  \ n is divisible by any prime factor.\n        for (int i = 3; i <= Math.sqrt(n);\
  \ i += 2) {\n            if (n % i == 0)\n                isPrime[i] = false;\n\
  \        }\n        // If n is prime, then return that value.\n        if (isPrime[n])\n\
  \            return n;\n        // If n is divisible by any prime factor greater\
  \ than 1 then return that value.\n        for (int i = 3; i <= Math.sqrt(n); i +=\
  \ 2) {\n            if (isPrime[i])\n                return i;\n        }\n    \
  \    // If n is divisible by all prime factors, then return the largest prime factor\
  \ of that value.\n        for (int i = 0; i < primeFactors.size(); i++)\n      \
  \      if (isPrime[primeFactors.get(i)])\n                maxFactor = primeFactors.get(i);\n\
  \        return maxFactor;"
- "        if (n == 1) {\n            return 1;\n        }\n        // We assume that\
  \ n > 1 and not prime. Also, the factors of 2 are always\n        // candidates.\n\
  \        boolean is_prime[] = new boolean[n + 1];\n        is_prime[0] = true;\n\
  \        for (int i = 1; i < is_prime.length; i++) {\n            is_prime[i] =\
  \ n % i == 0;\n        }\n        int max_factor = 0;\n        for (int i = 2; i\
  \ <= n; i++) {\n            // If the current number is not a prime factor.\n  \
  \          if (!is_prime[i]) {\n                // Then the factor is the current\
  \ number\n                for (int j = i; j <= n; j++) {\n                    if\
  \ (!is_prime[j]) {\n                        break;\n                    }\n    \
  \            }\n                // If the largest factor has been found, return\
  \ the current number\n                if (max_factor < j) {\n                  \
  \  max_factor = j;\n                }\n            }\n        }\n        return\
  \ max_factor;"
- "        if(n < 2) return 1;\n        if(n % 2 == 0) return 2;\n        int max_i\
  \ = Math.sqrt(n);\n        for(int i = 3; i <= max_i; i+=2) {\n            while(n\
  \ % i == 0) {\n                max_i = i;\n                n /= i;\n           \
  \ }\n        }\n        return n;"
- "        if (n < 2) {\n            return 2;\n        }\n\n        Stack<Integer>\
  \ factors = new Stack<>();\n\n        while (true) {\n            int x = 2;\n \
  \           while (!factors.empty() && x < (n / factors.peek())) {\n           \
  \     x ++;\n            }\n            factors.push(x);\n            if (x == n)\
  \ {\n                while (!factors.empty()) {\n                    factors.pop();\n\
  \                }\n                return n;\n            }\n            if (n\
  \ % x == 0) {\n                while (!factors.empty() && x < (n / factors.peek()))\
  \ {\n                    x ++;\n                }\n                if (x == n /\
  \ x) {\n                    while (!factors.empty()) {\n                       \
  \ factors.pop();\n                    }\n                    return n;\n       \
  \         }\n            }\n        }"
- "        // Your code here\n        int max = 2;\n        int i = 2;\n        while(i\
  \ <= n/2)\n        {\n            if(n%i == 0)\n            {\n                if(n%i*i\
  \ == 0)\n                {\n                    if(n%i*i*i == 0)\n             \
  \       {\n                        if(n%i*i*i*i == 0)\n                        {\n\
  \                            max = i;\n                        }\n             \
  \       }\n                }\n            }\n            i++;\n        }\n     \
  \   return max;"
- "        boolean prime = true;\n        int maxFactor = 1;\n        for (int i =\
  \ 2; i <= n / 2; i++) {\n            if (n % i == 0) {\n                prime =\
  \ false;\n                break;\n            }\n        }\n        for (int i =\
  \ 2; i < n / 2; i++) {\n            if (n % i == 0) {\n                maxFactor\
  \ = i;\n            }\n        }\n        if (prime) {\n            return maxFactor;\n\
  \        }\n        return 1;"
- "        // Solve the problem of finding the largest prime factor by dividing the\
  \ number\n        // by all the prime factors.\n        int[] factors = new int[n];\n\
  \        for (int i = 2; i <= n; i++) {\n            // Check if the number is divisible\
  \ by the current factor. If so, add that\n            // factor to the list of factors.\n\
  \            if (n % i == 0) {\n                factors[i - 2] = i;\n          \
  \      n = n / i;\n            }\n        }\n        // If n is a factor of the\
  \ number then n does not have the highest prime\n        // factor and so n is the\
  \ largest factor of n and so return it.\n        if (n == 1) {\n            return\
  \ factors[0];\n        }\n        // If the number is not divisible by any number\
  \ within the list of prime factors\n        // then n does not have the highest\
  \ prime factor and so n is the largest\n        // factor of n and so return it.\n\
  \        if (Arrays.stream(factors).anyMatch(x -> n % x == 0)) {\n            return\
  \ factors[n - 2];\n        }\n        // If n is greater than all factors within\
  \ the list of prime factors then n\n        // has the highest prime factor, so\
  \ return it.\n        if (Arrays.stream(factors).allMatch(x -> x <= n)) {\n    \
  \        return factors[n - 2];\n        }\n        // Otherwise, n does not have\
  \ the highest prime factor and so n is the largest\n        // factor of n and so\
  \ return it.\n        return n;"
- "        int i;\n        int l = 2;\n        int r = n;\n        while (l <= r)\
  \ {\n            int m = l + (r - l) / 2;\n            i = 1;\n            while\
  \ ((m % i == 0) && (m != n)) {\n                i++;\n            }\n          \
  \  if (i == 2) return m;\n            if (i != 2) {\n                l = m + 1;\n\
  \            } else {\n                r = m / i;\n            }\n        }\n  \
  \      return n;"
- "        if (n == 1) return n;\n        // Use a sieve of Eratosthenes to avoid\
  \ checking the square root\n        final int S[] = new int[n + 1];\n        final\
  \ int sqrtN = Math.sqrt(n);\n        int i, j, k;\n        // Fill the array with\
  \ n's prime factors\n        for (i = 2; i <= sqrtN; ++i)\n            S[i] = i;\n\
  \        // Test for compositeness of all numbers, starting from 2\n        for\
  \ (i = 2; i < n; ++i) {\n            if (S[i] == 2) continue;\n            // Test\
  \ for non-primes up to sqrt(i)\n            for (j = i + i; j < sqrtN; j += i) {\n\
  \                k = j;\n                // If this exceeds the largest prime so\
  \ far,\n                // set it as the largest prime so far\n                if\
  \ (k >= S[0]) {\n                    S[0] = k;\n                    // Also set\
  \ k as the largest factor of n\n                    k = n/k;\n                 \
  \   while (k > 1 && k <= S[0]) {\n                        S[k] = S[k - 1];\n   \
  \                     k *= k;\n                    }\n                }\n      \
  \      }\n        }\n        // Return the largest prime factor of n\n        return\
  \ S[0];"
- "        if(n < 2) return n;\n        int k = 3;\n        for(int i=3; i<=n/k; ++i){\n\
  \            int j=i*i;\n            while(j<n && j%i==0){\n                j+=i;\n\
  \            }\n            if(j>n) break;\n            if(i*j==n){\n          \
  \      k=i;\n            }\n        }\n        return k;"
- '        return largestPrimeFactor(n, new ArrayList<>());'
- "        long largest_prime_factor = 1;\n        for (long i = 2; i <= Math.sqrt(n);\
  \ i++) {\n            if (n % i == 0) {\n                if (largest_prime_factor\
  \ < i)\n                    largest_prime_factor = i;\n            }\n        }\n\
  \        return (int) largest_prime_factor;"
- "        int largest_factor = 1;\n        int factor = 2;\n        while ((n % factor)\
  \ == 0) {\n            largest_factor *= factor;\n            factor++;\n      \
  \  }\n        return largest_factor;"
- "        int max_prime;\n        if (n <= 1) {\n            return n;\n        }\
  \ else {\n            max_prime = 1;\n            for (int i = 2; i < n; i++) {\n\
  \                if (n % i == 0) {\n                    max_prime = i;\n       \
  \         } else {\n                    break;\n                }\n            }\n\
  \        }\n        return max_prime;"
- '        return (int) Math.ceil(Math.sqrt(n));'
- "        int i;\n        List<Integer> factors = new ArrayList<>();\n        for\
  \ (i = 0; i < n; ++i) {\n            if (isPrime(i)) {\n                factors.add(i);\n\
  \            }\n        }\n        if (factors.isEmpty()) {\n            return\
  \ n;\n        }\n        int largest_factor = -1;\n        for (i = factors.size()\
  \ - 1; i >= 0; --i) {\n            if (factors.get(i) > largest_factor) {\n    \
  \            largest_factor = factors.get(i);\n            }\n        }\n      \
  \  return largest_factor;"
- "        if (n < 2) return 2;\n        if (n % 2 == 0) return largestPrimeFactor(n\
  \ / 2);\n        int i = 3;\n        int max_i = i;\n        while (i != max_i &&\
  \ n % i == 0) {\n            i = i + 2;\n            max_i = i;\n        }\n   \
  \     if (i > n) return i;\n        int res = largestPrimeFactor(n / i);\n     \
  \   if (res < n) return i + res;\n        return n;"
- "        int largestPrimeFactor = 1;\n        for (int i = 1; i < n; i++) {\n  \
  \          while (n % i == 0) {\n                largestPrimeFactor = i;\n     \
  \           n = n / i;\n            }\n        }\n        return largestPrimeFactor;"
- "        int largestPrime = 1;\n        for (int i = 2; i <= n / 2; i++) {\n   \
  \         while (n % i == 0) {\n                largestPrime = i;\n            \
  \    n /= i;\n            }\n        }\n        if (n > 1)\n            largestPrime\
  \ = n;\n        return largestPrime;"
- "        if (n >= 2) {\n            while (n % 2 == 0) {\n                n = n\
  \ / 2;\n            }\n            int max = 2;\n            while (n % 2 == 0)\
  \ {\n                max = max * 2;\n                n = n / 2;\n            }\n\
  \            while (n % 2 == 0) {\n                n = n / 2;\n            }\n \
  \           return max;\n        }\n        return n;"
- "        // Return primes less than or equal to n.\n        List<Integer> primes\
  \ = Arrays.stream(new int[(n + 1) << 1])\n            .mapToObj(p -> (p - 1) * (p\
  \ - 1))\n            .filter(p -> p < n)\n            .collect(Collectors.toList());\n\
  \        boolean foundPrime = true;\n        while (foundPrime) {\n            foundPrime\
  \ = false;\n            for (Integer p : primes) {\n                if (n % p ==\
  \ 0) {\n                    foundPrime = true;\n                    n = n / p;\n\
  \                    break;\n                }\n            }\n        }\n     \
  \   return n;"
- "        ArrayList<Integer> factors = new ArrayList<>();\n        long num = n;\n\
  \        while(num > 1) {\n            int rem = num % 2;\n            if(rem ==\
  \ 0) {\n                num /= 2;\n            } else {\n                num *=\
  \ 3;\n            }\n            factors.add(num);\n        }\n        Collections.sort(factors);\n\
  \        int result = factors.get(factors.size()-1);\n        return result;"
- "        ArrayDeque<Integer> q = new ArrayDeque<>();\n        q.add(2);\n      \
  \  while (!q.isEmpty() && n < q.poll()) {\n            int next = q.poll();\n  \
  \          while (n % next != 0) {\n                q.addFirst(next);\n        \
  \    }\n        }\n        return q.isEmpty() ? 1 : q.poll();"
- "        return IntStream.range(1, n / 2)\n                .filter(x -> n % x ==\
  \ 0)\n                .max().getAsInt();"
- "        int candidate = n;\n        int count = 0;\n        List<Integer> factors\
  \ = new ArrayList<Integer>();\n        while (candidate % 2 == 0 && candidate !=\
  \ 1) {\n            candidate = candidate / 2;\n            count++;\n        }\n\
  \        for (int i = 3; i <= n; i += 2) {\n            while (candidate % i ==\
  \ 0) {\n                candidate = candidate / i;\n                count++;\n \
  \               if (count > 1) {\n                    factors.add(i);\n        \
  \            break;\n                }\n            }\n        }\n        return\
  \ factors.get(factors.size()-1);"
- "        int largest_factor = 1;\n        // Loop over all odd numbers less than\
  \ n and find all the prime factors\n        for (int i = 2; i < n; i += 2) {\n \
  \           // Only test odd numbers with factors greater than 1\n            if\
  \ (n % i == 0) {\n                for (int j = i * i; j < n; j += i) {\n       \
  \             if (n % j == 0) {\n                        largest_factor = i;\n \
  \                   }\n                }\n            }\n        }\n        return\
  \ largest_factor;"
- "        // Initialize a list to hold all the factors\n        List<Integer> factors\
  \ = new ArrayList<>();\n\n        // Keep a count of the number of times we see\
  \ a factor\n        int seen = 0;\n\n        // Iterate through the numbers until\
  \ we find one that isn't prime\n        for (int i = 1; i <= n; i++) {\n       \
  \     // If we haven't seen this factor before, add it to the list\n           \
  \ if (factors.contains(i)) {\n                seen++;\n            } else {\n  \
  \              // If we've seen this factor before, check if it's too large\n  \
  \              if (seen > factors.size()) {\n                    // If it's too\
  \ large, remove it\n                    factors.removeIf(x -> x == i);\n       \
  \         } else {\n                    // If it's not too large, increment the\
  \ count\n                    seen++;\n                }\n            }\n       \
  \ }\n\n        // If we haven't seen a factor greater than n times, we haven't found\
  \ the largest\n        if (seen < n) {\n            return -1;\n        } else {\n\
  \            // If we haven't seen a factor greater than n times, we have found\
  \ the largest\n            return factors.get(factors.size() - 1);\n        }"
- "        int largest_prime_factor = 2;\n        for (int i = 3; i <= Math.sqrt(n);\
  \ i += 2)\n            if (n % i == 0) {\n                while (n % i == 0)\n \
  \                   n /= i;\n                if (n > largest_prime_factor) {\n \
  \                   largest_prime_factor = n;\n                }\n            }\n\
  \        return largest_prime_factor;"
- "        int retVal = 1;\n        if (n <= 1) return 1;\n        while (n % 2 ==\
  \ 0) n /= 2;\n        for (int i = 3; i * i <= n; i += 2)\n            if (n % i\
  \ == 0) retVal = i;\n        return retVal;"
- "        PrimeFactor[] primeFactors = PrimeFactor.allPrimeFactors(n);\n        return\
  \ primeFactors.length > 0 ? primeFactors[0].primeFactor : 0;"
- "        int maxFact = n;\n        int fact = 1;\n        while (n > 1) {\n    \
  \        while (n % fact == 0) {\n                fact++;\n                if (fact\
  \ > maxFact) {\n                    maxFact = fact;\n                }\n       \
  \     }\n            n /= fact;\n        }\n        return maxFact;"
- "        if (n < 2) return 0;\n        \n        int p = 5;\n        int q = 3;\n\
  \        \n        while (true) {\n            while (n % p == 0) {\n          \
  \      p = p * 2;\n            }\n            while (n % q == 0) {\n           \
  \     q = q * 2;\n            }\n            \n            if (p < q) return p;\n\
  \            \n            n = q;\n        }"
- "        if (n < 2) return 1;\n        if (n == 2) return 2;\n        ArrayList\
  \ l = new ArrayList();\n        int p = 3; // Prime number\n        while (true)\
  \ {\n            if (n % p == 0) {\n                l.add(p);\n                if\
  \ (n > 2) {\n                    while (n % p == 0) {\n                        n\
  \ /= p;\n                    }\n                }\n            }\n            else\
  \ if (n > 2) {\n                n = n / p;\n            }\n            else {\n\
  \                break;\n            }\n            p = p + 1;\n        }\n    \
  \    return p.intValue();"
- "        int p = 2;\n        while (p <= n/p) {\n            if (n%p == 0) {\n \
  \               break;\n            }\n            ++p;\n        }\n        return\
  \ p;"
- "        List<Integer> factors = new ArrayList<Integer>();\n        for (; n > 1;\
  \ n--) {\n            if (isPrime(n)) {\n                factors.add(n);\n     \
  \       }\n        }\n        if (factors.isEmpty()) {\n            return n;\n\
  \        }\n        return Collections.max(factors);"
- "        List<Integer> factors = new ArrayList<>();\n        largestPrimeFactor(n,\
  \ factors);\n        return factors.get(0);"
- "        if (n == 2) return 2;\n        if (n == 1) return 1;\n        if (n%2 ==\
  \ 0) return largestPrimeFactor(n/2);\n        int max_factor = 0;\n        int i\
  \ = 1;\n        while (i < n) {\n            if (n%i == 0) {\n                for\
  \ (int j = 3; j*i < n; j++) {\n                    if (n%j == 0) {\n           \
  \             max_factor = i;\n                        break;\n                \
  \    }\n                }\n                if (max_factor == 0) max_factor = i;\n\
  \            }\n            i += 2;\n        }\n        return max_factor;"
- "        int largest = 0;\n        int d = 2;\n        while (n > 1) {\n       \
  \     if (n % d == 0) {\n                largest = d;\n            }\n         \
  \   n /= d;\n            d++;\n        }\n        return largest;"
- "        int result = 0;\n        int max = Math.sqrt(n);\n        while (max !=\
  \ 1) {\n            if (n % max == 0)\n                max++;\n            else\
  \ {\n                while (n % max == 0)\n                    max++;\n        \
  \        max--;\n            }\n            n/= max;\n            result++;\n  \
  \      }\n        return result;"
- "        Set<Integer> factors = new HashSet<Integer>();\n        for (int i = 1;\
  \ i <= n; i++) {\n            if (n % i == 0) {\n                while (n % i ==\
  \ 0) {\n                    factors.add(i);\n                    n /= i;\n     \
  \           }\n            }\n        }\n        if (n > 2) {\n            factors.add(n);\n\
  \        }\n        int maxFact = factors.isEmpty() ? 2 : 1;\n        for (Integer\
  \ fact : factors) {\n            if (fact > maxFact) {\n                maxFact\
  \ = fact;\n            }\n        }\n        return maxFact;"
- '        return largestPrimeFactor(n, new int[n]);'
- "        int factor = 1;\n        while (n > 1) {\n            while (n % factor\
  \ == 0) {\n                n /= factor;\n                factor++;\n           \
  \ }\n        }\n        return factor;"
- "        int largestPrimeFactor = 1;\n        while (n > 1) {\n            int nextPrime\
  \ = 1;\n            for (int i = 2; i < n; i++) {\n                if (n % i ==\
  \ 0) {\n                    nextPrime = i;\n                    break;\n       \
  \         }\n            }\n            if (nextPrime == 1) {\n                largestPrimeFactor\
  \ = n;\n                break;\n            } else {\n                n = nextPrime;\n\
  \            }\n        }\n        return largestPrimeFactor;"
- "        // A prime factor of 0 means n is prime.\n        if( n == 1 ) return n;\n\
  \        // If the only factor is a single 1, return it.\n        if( n == 2 ) return\
  \ 2;\n        // Search for factors.\n        int factor = 2;\n        for( int\
  \ i = 3; i <= n/factor; i++ ) {\n            if( n % i == 0 ) {\n              \
  \  // n doesn't divide into i. Check if i divides into n (i is not a factor).\n\
  \                if( n/i == i ) {\n                    // n divides into i, i is\
  \ a factor of n. i is the factor. Return it.\n                    return i;\n  \
  \              } else {\n                    // n doesn't divide into i, i is not\
  \ a factor. Increment i by 1, and check for a factor.\n                    factor++;\n\
  \                }\n            }\n        }\n        // No factors found. Return\
  \ the number itself.\n        return n;"
- "        if (n == 1) return 1;\n        if (n <= 2) return 2;\n        if (n % 2\
  \ == 0) return largestPrimeFactor(n / 2);\n        for (int i = 3; i <= Math.sqrt(n);\
  \ i += 2) {\n            if (n % i == 0) return i * largestPrimeFactor(n / i);\n\
  \        }\n        return n;"
- "        int largestPrimeFactor = 0;\n        int a = n;\n        for (int i = 1;\
  \ i <= a; ++i) {\n            // only odd numbers can divide even\n            if\
  \ (a % i == 0) {\n                a = a / i;\n                largestPrimeFactor\
  \ = i;\n            }\n        }\n        return largestPrimeFactor;"
- "        int max = 1, max2 = 0;\n        for (int i = 1; i <= n / 2; i++) {\n  \
  \          if (n % i == 0) {\n                max = i;\n                max2 = i;\n\
  \            }\n            if (max2 == 2) {\n                max2 = i;\n      \
  \      }\n        }\n        return max;"
- '        return PrimeFactors.largestPrimeFactor(n);'
- "        int largest = 2;\n        for (int i = 1; i <= Math.sqrt(n); i++) {\n \
  \           if (n % i == 0) {\n                while (n % i == 0) {\n          \
  \          largest = i;\n                    n = n / i;\n                }\n   \
  \         }\n        }\n        return largest;"
- "        int result = 0;\n\n        while (n%2 == 0) {\n            n /= 2;\n  \
  \          result++;\n        }\n\n        if (n == 1) {\n            return result;\n\
  \        }\n\n        for (int i = 3; i <= n; i += 2) {\n            if (n % i ==\
  \ 0) {\n                result = i;\n                break;\n            }\n   \
  \     }\n\n        return result;"
- "        if (n < 2) return 0;\n        if (n == 2) return 2;\n        if (n & 1)\
  \ { // If n is odd, then it is not prime\n            int m = n/2;\n           \
  \ while (m % 2 == 0) // While m is odd, double it\n                m *= 2;\n   \
  \         while (m % 3 == 0) // While m is odd, triple it\n                m *=\
  \ 3;\n            return m; // If m is prime, return it\n        }\n        int\
  \ m = 1;\n        while (m * m <= n) { // While the square root of n is less than\
  \ or equal to n\n            int temp = m;\n            m += 1;\n            if\
  \ (temp % 2 == 0 || temp % 3 == 0) // If the number is not a prime, return it\n\
  \                return temp;\n        }\n        // n was prime (or is composite),\
  \ so return the largest factor of n\n        while (n % m == 0) // While m divides\
  \ n, keep reducing m\n            m *= m;\n        return m;"
- "        if (n < 2) return 2;\n        if (n == 2) return 2;\n        int i = 2;\n\
  \        int p = n;\n        while (p * p <= n) {\n            i += 2;\n       \
  \     p = n/i;\n        }\n        return i;"
- "        List<Integer> factors = new ArrayList<>();\n        while(true) {\n   \
  \         for(int i = 0; i < factors.size(); i++) {\n                factors.remove(i);\n\
  \                if(isPrime(factors.get(i))) {\n                    break;\n   \
  \             }\n            }\n            factors.add(n);\n            if(factors.size()\
  \ <= 2) {\n                return n;\n            }\n            n--;\n        }"
- "        if (n == 1) return n;\n        else if (n % 2 == 0) return n;\n       \
  \ int largestPrimeFactor = largestPrimeFactor(n/2);\n        if (largestPrimeFactor\
  \ == 0) {\n            largestPrimeFactor = largestPrimeFactor(n/3) + 1;\n     \
  \   }\n        return largestPrimeFactor;"
- "        int largestPrimeFactor = 1;\n        int primeFactor = 2;\n\n        while\
  \ (primeFactor <= n / 2) {\n            while (n % primeFactor == 0) {\n       \
  \         n = n / primeFactor;\n                largestPrimeFactor = primeFactor;\n\
  \            }\n            primeFactor++;\n        }\n        return largestPrimeFactor;"
- "        int result = 0;\n        for (int x = 2; x <= n; x++) {\n            if\
  \ (n % x == 0) {\n                result = x;\n                break;\n        \
  \    }\n        }\n        return result;"
- "        int maxFactor = n / 2;\n\n        for (int i = 2; i <= Math.sqrt(n); i++)\
  \ {\n            if (n % i == 0) {\n                while (n % i == 0) {\n     \
  \               n /= i;\n                    if (n == 1) return i;\n           \
  \     }\n            }\n        }\n        return maxFactor;"
- "        ArrayList<Integer> factors = new ArrayList<>(n);\n        for (int i =\
  \ 1; i <= n; i++) {\n            if (n % i == 0) {\n                factors.add(i);\n\
  \            }\n        }\n        return factors.get(factors.size() - 1);"
- "        int max = 3;\n        int current = 1;\n        while (max < n) {\n   \
  \         while (n % current == 0) {\n                current++;\n            }\n\
  \            if (current > max) {\n                max = current;\n            }\n\
  \            current++;\n        }\n        return max;"
- "        int largest = 1;\n        while (n > 1) {\n            if (n % 2 == 0)\
  \ {\n                largest = largest * 2;\n            }\n            while (n\
  \ % 3 == 0) {\n                largest = largest * 3;\n                n /= 3;\n\
  \            }\n            while (n % 5 == 0) {\n                largest = largest\
  \ * 5;\n                n /= 5;\n            }\n        }\n        return largest;"
- "        int largestFactor = -1;\n        while (true) {\n            int testDivisor\
  \ = 1;\n            int div = 2;\n            while (testDivisor <= n / div) {\n\
  \                if (n % div == 0) {\n                    break;\n             \
  \   }\n                testDivisor += 1;\n                div += 1;\n          \
  \  }\n            if (testDivisor > n / div) {\n                largestFactor =\
  \ div;\n                break;\n            }\n        }\n        return largestFactor;"
- "        int i = 2;\n        while (i < n){\n            if (n % i == 0){\n    \
  \            n = n/i;\n            } else {\n                i++;\n            }\n\
  \        }\n        return i;"
- '        return largest_prime_factor(n);'
- "        if(n < 2)\n            return n;\n\n        // Set up to work up to the\
  \ square root of the number.\n        int n = Math.sqrt(n);\n        \n        //\
  \ Check if n is prime.\n        if(n%2 == 0 || n%3 == 0)\n            return n;\n\
  \n        // Set up the list of prime factors.\n        ArrayList<Integer> factors\
  \ = new ArrayList<Integer>();\n\n        // Check all odd factors of n.\n      \
  \  for(int x = 2; x*x <= n; x++)\n        {\n            if(n % x == 0)\n      \
  \          factors.add(x);\n        }\n\n        // If no odd factors were found\
  \ (n is prime), return it.\n        if(factors.size() == 0)\n            return\
  \ n;\n\n        // Otherwise, return the largest prime factor of the number n -\
  \ 1.\n        int max_prime = 0;\n        for(int i = 0; i < factors.size(); i++)\n\
  \        {\n            int num_factor = factors.get(i);\n            int factor\
  \ = Math.min(num_factor, n-1);\n\n            if(factor > max_prime)\n         \
  \       max_prime = factor;\n        }\n        return max_prime;"
- "        HashSet<Integer> primeFactors = new HashSet<Integer>();\n\n        int\
  \ max = 2;\n        int maxFactor = 1;\n\n        for (int i = 2; i <= Math.sqrt(n);\
  \ i++) {\n            if (n % i == 0) {\n                maxFactor = i;\n      \
  \          max = i;\n            }\n        }\n\n        for (Integer factor : primeFactors)\
  \ {\n            if (factor == maxFactor) {\n                return max;\n     \
  \       }\n        }\n\n        primeFactors.add(maxFactor);\n        return largestPrimeFactor(n\
  \ / maxFactor);"
- "        int largestPrimeFactor = -1;\n        int i = 1;\n        while (i <= n)\
  \ {\n            if (isPrime(i)) {\n                largestPrimeFactor = i;\n  \
  \              break;\n            }\n            else {\n                i++;\n\
  \            }\n        }\n        return largestPrimeFactor;"
- "        int largestPrimeFactor = 0;\n        int i = 2;\n        while (i < n)\
  \ {\n            if (n % i == 0) {\n                largestPrimeFactor = i;\n  \
  \              break;\n            }\n            i = i + 2;\n        }\n      \
  \  return largestPrimeFactor;"
- "        \n        // Step 1: Compute n / 2\n        int half = n / 2;\n       \
  \ // Step 2: Start dividing n by 2 until half is no longer\n        // divisible\
  \ by 2, then dividing by 3 and 4, and so on until\n        // n/2 is greater than\
  \ 1 or the number is composite.\n        for(int i = 1; half < n / 2; half += i)\
  \ {\n            // Step 3: If n is evenly divisible by i, it can be\n         \
  \   // divided by i without causing problems. Therefore,\n            // if n is\
  \ also divisible by half and half is a factor,\n            // then half is also\
  \ a factor.\n            if (n % i == 0) {\n                // Step 4: If half is\
  \ not a factor but half is no\n                // longer a factor, then n is prime.\n\
  \                if (!half % i) {\n                    return half;\n          \
  \      }\n                // Step 5: If half is a factor and n is not a prime,\n\
  \                // then n is also prime.\n                if (half % i != 0) {\n\
  \                    return half;\n                }\n            }\n        }\n\
  \        // Step 6: If n is greater than 1 but is not a prime, then\n        //\
  \ n is also prime.\n        return n;"
- '        return Math.max(IntStream.range(1, n).filter(i -> n % i == 0).max().getAsInt(),
  1);'
- "        List<Integer> factors = new ArrayList<>();\n        for (int i = 2; i <=\
  \ Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                factors.add(i);\n\
  \                while (n % i == 0) {\n                    n /= i;\n           \
  \     }\n            }\n        }\n        return factors.size() > 0 ? factors.get(factors.size()\
  \ - 1) : n;"
- "        if (n == 1) return 2;\n        if (n == 2) return 2;\n        BigInteger\
  \ i = BigInteger.valueOf(2);\n        while (true) {\n            while (!i.equals(n))\
  \ {\n                if (i.mod(n).equals(BigInteger.ZERO)) return i;\n         \
  \       i = i.add(BigInteger.ONE);\n            }\n            i = BigInteger.valueOf(2);\n\
  \            while (!i.equals(BigInteger.ONE)) {\n                if (i.mod(n).equals(BigInteger.ZERO))\
  \ return i;\n                i = i.add(BigInteger.ONE);\n            }\n       \
  \ }"
- "        if (n <= 1)\n            return n;\n        int largestPrimeFactor = 1;\n\
  \        for (int i = 2; i <= n / 2; i++)\n            if (n % i == 0) {\n     \
  \           largestPrimeFactor = i;\n                break;\n            }\n   \
  \     return largestPrimeFactor;"
- "        int largest = 1;\n        while (n > 1) {\n            largest = n;\n \
  \           while (n % 2 == 0) {\n                n = n / 2;\n            }\n  \
  \          while (n % 3 == 0) {\n                n = n / 3;\n            }\n   \
  \         if (n > 2) {\n                while (n % 5 == 0) {\n                 \
  \   n = n / 5;\n                }\n            }\n        }\n        return largest;"
- "        int factor = 1;\n        while (n >= 2) {\n            if (n % 2 == 0)\
  \ {\n                factor *= 2;\n            }\n            while (n % 2 == 0)\
  \ {\n                n /= 2;\n            }\n            while (n > 1) {\n     \
  \           if (n % 2 == 0) {\n                    n /= 2;\n                } else\
  \ {\n                    break;\n                }\n            }\n        }\n \
  \       return factor;"
- "        if (n < 2) return n;\n\n        List<Integer> factors = Arrays.asList(2,\
  \ 3, 5); // List of known prime factors\n        Iterator<Integer> it = factors.iterator();\n\
  \n        int candidate = n;\n        int currentfactor = 1;\n        while (it.hasNext())\
  \ {\n            int nextfactor = (int) it.next();\n            while (candidate\
  \ % nextfactor != 0) {\n                candidate /= nextfactor;\n             \
  \   currentfactor++;\n            }\n        }\n\n        return candidate;"
- "        if (n < 2) return n;\n\n        int[] factors = new int[n];\n\n       \
  \ for (int i = 2; i <= n/2; i++) {\n            while (n % i == 0) {\n         \
  \       factors[i / 2]++;\n                n = n / i;\n            }\n        }\n\
  \n        Arrays.sort(factors);\n\n        return factors[factors.length-1];"
- "        int result = n;\n        for(int i=2; i<=n/2; i++) {\n            if(n%i\
  \ == 0) {\n                result = i;\n                break;\n            }\n\
  \        }\n        return result;"
- "        int p = 2, q = n;\n        while (q > 1) {\n            if (isPrime(q))\
  \ {\n                while (!isPrime(q)) {\n                    q = q / p;\n   \
  \             }\n                if (q != 1) {\n                    p = p * q;\n\
  \                    q--;\n                }\n            }\n            q--;\n\
  \        }\n        return p;"
- "        // We only need to keep track of the largest prime factor,\n        //\
  \ so start by checking if n is prime. Otherwise we would also\n        // have to\
  \ keep track of the largest prime factors of every \n        // number up to n.\n\
  \        if (is_prime(n)) {\n            return n;\n        }\n        int largestPrimeFactor\
  \ = 1;\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // Check\
  \ if n is divisible by i, which is true for odd numbers.\n            if (n % i\
  \ == 0) {\n                // If n is divisible by i, then n is clearly not a prime.\n\
  \                return 0;\n            }\n            // If n is not divisible\
  \ by i, then n is either a prime\n            // factor of n or a composite factor.\
  \ Check what its largest\n            // prime factor is.\n            else {\n\
  \                int isprime = is_prime(i);\n                if (isprime) {\n  \
  \                  // If i is a prime factor, then n is clearly a prime.\n     \
  \               return i;\n                }\n                // If i is not a prime\
  \ factor of n, then n is clearly a \n                // composite factor of some\
  \ larger factor. Check what its\n                // largest prime factor is.\n \
  \               else {\n                    if (largestPrimeFactor < i) {\n    \
  \                    largestPrimeFactor = i;\n                    }\n          \
  \      }\n            }\n        }\n        return largestPrimeFactor;"
- "        // 1\n        if (n == 1) {\n            return n;\n        }\n       \
  \ // 2\n        if (n == 2) {\n            return 2;\n        }\n        // 3\n\
  \        if (n % 2 == 0) {\n            return 2;\n        }\n        // 4\n   \
  \     if (n % 3 == 0) {\n            return 3;\n        }\n        // 5\n      \
  \  if (n % 5 == 0) {\n            return 5;\n        }\n        // 6\n        if\
  \ (n % 6 == 0) {\n            return 6;\n        }\n        // 7\n        if (n\
  \ % 7 == 0) {\n            return 7;\n        }\n        // 8\n        if (n % 8\
  \ == 0) {\n            return 8;\n        }\n        // 9\n        if (n % 9 ==\
  \ 0) {\n            return 9;\n        }\n        // 10\n        if (n % 10 == 0)\
  \ {\n            return 10;\n        }\n        // 11\n        if (n % 11 == 0)\
  \ {\n            return 11;\n        }\n        // 12\n        if (n % 12 == 0)\
  \ {\n            return 12;\n        }\n        // 13\n        if (n % 13 == 0)\
  \ {\n            return 13;\n        }\n        // 14\n        if (n % 14 == 0)\
  \ {\n            return 14;\n        }\n        // 15\n        if (n % 15 == 0)\
  \ {\n            return 15;\n        }\n        // 16\n        if (n % 16 == 0)\
  \ {\n            return 16;\n        }\n        // 17\n        if (n % 17 == 0)\
  \ {\n            return 17;\n        }\n        // 18\n        if (n % 18 == 0)\
  \ {\n            return 18;\n        }\n        // 19\n        if (n % 19 == 0)\
  \ {\n            return 19;\n        }\n        // 20\n        if (n % 20 == 0)\
  \ {\n            return 20;\n        }\n        // 21\n        if (n % 21 == 0)\
  \ {\n            return 21;\n        }\n        // 22\n        if (n % 22 == 0)\
  \ {\n            return 22;\n        }\n        // 23\n        if (n % 23 == 0)\
  \ {\n            return 23;\n        }\n        // 24\n        if (n % 24 == 0)\
  \ {\n            return 24;\n        }\n        // 25\n        if (n % 25 == 0)\
  \ {\n            return 25;\n        }\n        // 26\n        if (n % 26 == 0)\
  \ {\n            return 26;\n        }\n        // 27\n        if (n % 27 == 0)\
  \ {\n            return 27;\n        }\n        // 28\n        if (n % 28 == 0)\
  \ {\n            return 28;\n        }\n        // 29\n        if (n % 29 == 0)\
  \ {\n            return 29;\n        }\n        // 30\n        if (n % 30 == 0)\
  \ {\n            return 30;\n        }\n        // 31\n        if (n % 31 == 0)\
  \ {\n            return 31;\n        }\n        // 32\n        if (n % 32 == 0)\
  \ {\n            return 32;\n        }\n        // 33\n        if (n % 33 == 0)\
  \ {\n            return 33;\n        }\n        // 34\n        if (n % 34 == 0)\
  \ {\n            return 34;\n        }\n        // 35\n        if (n % 35 == 0)\
  \ {\n            return 35;\n        }\n        // 36\n        if (n % 36 == 0)\
  \ {\n            return 36;\n        }\n        // 37\n        if (n % 37 == 0)\
  \ {\n            return 37;\n        }\n        // 38\n        if (n % 38 == 0)\
  \ {\n            return 38;\n        }"
- "        int factor = 1;\n        while (n % factor != 0) {\n            factor\
  \ = n + 1;\n        }\n        return factor;"
- "        int largestPrimeFactor = 0;\n        for (int i = 1; i <= n; i++) {\n \
  \           if (n % i == 0) {\n                while (n / i > i && n % i == 0) {\n\
  \                    largestPrimeFactor = i;\n                    n = n / i;\n \
  \               }\n            }\n        }\n        return largestPrimeFactor;"
- "        int largestFactor = n;\n        for (int i = 2; i <= Math.sqrt(n); i++)\
  \ {\n            if (n % i == 0) {\n                largestFactor = i;\n       \
  \         break;\n            }\n        }\n        return largestFactor;"
- "        int max_prime_factor = n;\n        int prime_factor = 2;\n        while(prime_factor\
  \ <= max_prime_factor) {\n            if(n % prime_factor == 0) {\n            \
  \    max_prime_factor = prime_factor;\n            }\n            else {\n     \
  \           prime_factor++;\n            }\n        }\n        return max_prime_factor;"
- '        return largest_prime_factor(n);'
- "        int p = 1;\n        while (n > 1) {\n            while (n % p == 0 && p\
  \ != 1) {\n                p++;\n            }\n            n/=p;\n        }\n \
  \       return p;"
- "        int i = 1;\n        List<Integer> factors = new ArrayList<>();\n      \
  \  while (n != 1) {\n            if (n % i == 0) {\n                factors.add(i);\n\
  \                while (n % i == 0) {\n                    n /= i;\n           \
  \         ++i;\n                }\n            }\n            ++i;\n        }\n\
  \        System.out.println(factors);\n        return factors.get(factors.size()-1);"
- "        int i = 2;\n        while (n > 1 && isPrime(i)) {\n            while (n\
  \ % i == 0) {\n                n /= i;\n            }\n            ++i;\n      \
  \  }\n        return n;"
- "        if (n == 1) return n;\n        int max_factor = 1;\n        Primes primes\
  \ = new Primes(n);\n        primes.stream().filter(p -> p > 1).forEach(p -> {\n\
  \            if (p > max_factor) max_factor = p;\n        });\n        return max_factor;"
- "        if (n == 0 || n == 1) {\n            return n;\n        }\n        int\
  \ i = 2;\n        while (i < n / i) {\n            if (n % i == 0) {\n         \
  \       return i;\n            }\n            i += 2;\n        }\n        return\
  \ n;"
- '        return largestPrimeFactorWithMemoization(n, new HashMap<>());'
- "        List<Integer> factors = new ArrayList<>();\n        // Generate all prime\
  \ factors of n\n        for (int i = 0; i <= n / i; i++) {\n            while (n\
  \ % i == 0) {\n                factors.add(i);\n                n /= i;\n      \
  \      }\n        }\n        // Return the largest prime factor of n\n        return\
  \ Collections.max(factors);"
- "        List<Integer> primes = primeFactors(n);\n        return Collections.max(primes);"
- "        if (n < 1) {\n            return -1;\n        }\n        ArrayList<Integer>\
  \ arr = new ArrayList<>();\n        for (int i = 2; i <= n / 2; i++) {\n       \
  \     while (n % i == 0) {\n                arr.add(i);\n                n = n /\
  \ i;\n            }\n        }\n        Arrays.sort(arr);\n        return arr.get(arr.size()\
  \ - 1);"
- "        // Write your code here\n        int k = 0;\n        while (n % 2 == 0)\
  \ {\n            n /= 2;\n            k++;\n        }\n        if (k > 2) {\n  \
  \          return 2;\n        }\n        if (n == 1) {\n            return 1;\n\
  \        }\n        int l = 3;\n        while ((n % l) != 0) {\n            l +=\
  \ 2;\n        }\n        while ((n % l) == 0) {\n            k++;\n            n\
  \ /= l;\n        }\n        if (k == 1) {\n            return l;\n        }\n  \
  \      return 2;"
- "        int result = 1;\n        while (n > 2) {\n            if (n % 2 == 0) {\n\
  \                n /= 2;\n            }\n            else {\n                int\
  \ i = 3;\n                while (i < (int) sqrt(n)) {\n                    if (!(n\
  \ % i)) {\n                        n = n / i;\n                        result =\
  \ i;\n                    }\n                    i += 2;\n                }\n  \
  \          }\n        }\n        return result;"
- "        int max = (int)Math.sqrt(n);\n        int max_factor = 2;\n        for\
  \ (int i = 2; i <= max; i++) {\n            if (n % i == 0) {\n                while\
  \ (n % i == 0) {\n                    n /= i;\n                    max_factor++;\n\
  \                }\n                break;\n            }\n        }\n        return\
  \ max_factor;"
- "        int largestPrimeFactor = n;\n        while (largestPrimeFactor % 2 == 0)\
  \ {\n            largestPrimeFactor /= 2;\n        }\n        while (largestPrimeFactor\
  \ != 2) {\n            for (int i = 3; i <= largestPrimeFactor; i += 2) {\n    \
  \            while (largestPrimeFactor % i == 0) {\n                    largestPrimeFactor\
  \ = i;\n                    break;\n                }\n            }\n        }\n\
  \        return largestPrimeFactor;"
- "        List<Integer> factors = new ArrayList<>(); // Store factors of n\n    \
  \    List<Integer> divisors = new ArrayList<>(); // Store divisors of n\n\n    \
  \    // Sieve of Erastothenes\n        for (int i = 2; i <= n / 2; i++) {\n    \
  \        if (i % 2 == 0) {\n                divisors.add(i);\n                for\
  \ (int j = i * i; j < n; j += i) {\n                    divisors.add(j);\n     \
  \           }\n            }\n        }\n        // Sieve of Atkowicz\n        for\
  \ (int i = 3; i <= n / 2; i += 2) {\n            if (i % 2 == 0) {\n           \
  \     divisors.add(i);\n                for (int j = i * i; j < n; j += i) {\n \
  \                   divisors.add(j);\n                }\n            }\n       \
  \ }\n\n        // Determine if n is prime\n        for (Integer i : divisors) {\n\
  \            if (i % n != 0) {\n                return i;\n            }\n     \
  \   }\n\n        return n; // n is prime"
- "        List<Integer> factors = new ArrayList<>();\n        for(int i = 1; i<=n;\
  \ i = i*2) {\n            if(n % i == 0) {\n                factors.add(i);\n  \
  \          }\n        }\n        if(factors.size() > 0) {\n            return factors.get(factors.size()\
  \ - 1);\n        }\n        return n;"
- "        // Start with an initial list of candidates.\n        List<Integer> candidates\
  \ = Arrays.asList(\n                2,\n                3,\n                5,\n\
  \                7,\n                11,\n                13,\n                17,\n\
  \                19,\n                23,\n                29,\n               \
  \ 31\n        );\n\n        // Keep looping while the candidates list contains non-primes.\n\
  \        while (true) {\n            // See if this candidate divides n.\n     \
  \       boolean n = n % candidates.stream().anyMatch(i -> i == n / i);\n\n     \
  \       // If we found a divisor then return the largest candidate.\n          \
  \  if (n) {\n                candidates.stream().max(Integer::compareTo).ifPresent(c\
  \ -> return c);\n            } else {\n                // If we've reached the end\
  \ of the candidates list then return the\n                // largest candidate.\n\
  \                if (candidates.size() == 1) {\n                    return candidates.stream().max(Integer::compareTo).ifPresent(c\
  \ -> return c);\n                }\n                // Otherwise repeat the process\
  \ with the candidates list shortened to\n                // remove this candidate.\n\
  \                candidates.removeIf(i -> i == n / i);\n            }\n        }"
- "        int factor = 2;\n        while (n > 2) {\n            if (n % factor ==\
  \ 0) {\n                n = n / factor;\n                factor++;\n           \
  \ } else {\n                break;\n            }\n        }\n        return factor;"
- "        System.out.println(n);\n        return (n<2? n: largestPrimeFactor(n-2))%n!=0\
  \ ? largestPrimeFactor(n-1) : n;"
- "        int result = 1;\n        for(int i = 2; i <= Math.sqrt(n); ++i) {\n   \
  \         if(n%i == 0) {\n                result = i;\n            }\n        }\n\
  \        return result;"
- "        // Base case: n is less than or equal to 1\n        if (n <= 1) return\
  \ n;\n\n        // If n is prime\n        if (isPrime(n)) return n;\n\n        //\
  \ Create a set for testing\n        Set<Integer> test = new HashSet<Integer>();\n\
  \n        // Iterate over all the odd numbers between 2 and n except 2\n       \
  \ for (int i = 2; i <= n / 2; i++) {\n            // If the current number is not\
  \ a prime\n            if (isPrime(i) == false) {\n                // Divide i by\
  \ each number from 2 to n excluding the current number\n                for (int\
  \ j = i * i; j <= n; j += i) {\n                    // If the current number divides\
  \ the number to be tested then\n                    // add it to the set\n     \
  \               if (n % j == 0)\n                        test.add(j);\n        \
  \        }\n            }\n        }\n        // Return the greatest prime factor\n\
  \        return largestPrimeFactor(test.stream().max(Integer::compareTo).get());"
- "        Set<Integer> factors = new HashSet<>();\n        while(true) {\n      \
  \      while(n % 2 == 0) {\n                factors.add(2);\n                n =\
  \ n/2;\n            }\n            while(n % 3 == 0) {\n                factors.add(3);\n\
  \                n = n/3;\n            }\n            while(n % 5 == 0) {\n    \
  \            factors.add(5);\n                n = n/5;\n            }\n        \
  \    if(n > 1) {\n                factors.add(n);\n                break;\n    \
  \        }\n        }\n        return factors.stream().max().getAsInt();"
- "        if (n < 1) {\n            return -1;\n        }\n        final int div\
  \ = 1;\n        int i = 1;\n        while ((n % i) > 0) {\n            div++;\n\
  \            i += div;\n        }\n        return div;"
- "        if (n < 2) return n;\n        ArrayList <Integer> factors = new ArrayList<>();\n\
  \        int i = 2;\n        while (i <= n / i) {\n            if (n % i == 0) {\n\
  \                factors.add(i);\n                if (n / i != i) factors.add(n\
  \ / i);\n            }\n            i++;\n        }\n        Collections.sort (factors,\
  \ Collections.reverseOrder());\n        int largestFactor = factors.get(0);\n  \
  \      for (int factor : factors) {\n            if (factor > largestFactor) {\n\
  \                largestFactor = factor;\n            }\n        }\n        return\
  \ largestFactor;"
- "        int max = n;\n        for (int i = 1; i < max; i++) {\n            while\
  \ (n % i == 0) {\n                max = i;\n                i--;\n            }\n\
  \        }\n        return max;"
- "        int largestPrimeFactor = 1;\n        while (n > 1) {\n            int tempLargestPrimeFactor\
  \ = largestPrimeFactor;\n            largestPrimeFactor = (n % largestPrimeFactor);\n\
  \            n = n / largestPrimeFactor;\n            if (n == 1) {\n          \
  \      break;\n            }\n        }\n        return largestPrimeFactor;"
- "        if (n <= 1) return n;\n        ArrayList<Integer> primeFactors = new ArrayList<Integer>();\n\
  \        for (int p = 2; p * p <= n; p++) {\n            if (n % p == 0) {\n   \
  \             primeFactors.add(p);\n                while (n % p == 0) {\n     \
  \               primeFactors.add(p);\n                    n /= p;\n            \
  \    }\n            }\n        }\n        if (n != 1) primeFactors.add(n);\n   \
  \     int largest = 0;\n        for (Integer p : primeFactors) {\n            if\
  \ (largest < p) {\n                largest = p;\n            }\n        }\n    \
  \    return largest;"
- "        int maxFactor = 0;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n\
  \            if (n % i == 0) {\n                maxFactor = i;\n            }\n\
  \        }\n        return maxFactor;"
- "        Map<Integer,Integer> primeFactorMap = new HashMap<>();\n        for(int\
  \ i=2;i<n;i+=2){\n            if(n % i == 0){\n                primeFactorMap.put(i,1);\n\
  \            }\n        }\n        for(Map.Entry<Integer,Integer> entry : primeFactorMap.entrySet()){\n\
  \            int largest = entry.getValue();\n            for(Integer x : primeFactorMap.values()){\n\
  \                if(x == largest){\n                    break;\n               \
  \ }\n            }\n            primeFactorMap.put(entry.getKey(),largest);\n  \
  \      }\n        return primeFactorMap.lastEntry().getKey();"
- "        int maxPrime = 1;\n        for (int i = 2; i <= n / 2; i++) {\n       \
  \     // Check if it's prime\n            if (isPrime(i))\n                continue;\n\
  \            // Check if it can be divided by current max\n            if (n % i\
  \ == 0) {\n                // If so, update max to i\n                maxPrime =\
  \ i;\n                // If n is prime, no more need to check\n                break;\n\
  \            }\n        }\n        return maxPrime;"
- "        int largestPrimeFactor = 1;\n        int nMinus1 = 1;\n        int m =\
  \ n;\n\n        while (m != 1) {\n            int m = nMinus1;\n            nMinus1\
  \ = n % m;\n            if (m * nMinus1 > n) m = 1;\n            else {\n      \
  \          largestPrimeFactor = m + 1;\n                break;\n            }\n\
  \        }\n        return largestPrimeFactor;"
- "        int result = 2;\n        while ( n % result != 0) {\n            result\
  \ = result + 1;\n        }\n        return result;"
- "        if (n == 1) {\n            return 1;\n        }\n\n        int max_factor\
  \ = 2;\n        Prime[] primes = Prime.primes;\n\n        for (Prime prime : primes)\
  \ {\n            // We don't consider any prime numbers smaller than n.\n      \
  \      if (n > prime) {\n                continue;\n            }\n\n          \
  \  // We have found a prime that is larger than n. Go on\n            if (n == prime)\
  \ {\n                return prime;\n            }\n\n            // The smallest\
  \ prime factor of n must be smaller than the largest prime factor of n-1.\n    \
  \        // If n > prime.\n            // So we conclude that prime is larger than\
  \ n, and we could make prime the largest prime factor\n            if (prime > max_factor)\
  \ {\n                max_factor = prime;\n            }\n        }\n\n        return\
  \ max_factor;"
- "        int largestPrimeFactor = 0;\n        for(int i = 1; i <= n; i++) {\n  \
  \          if(n%i == 0) {\n                largestPrimeFactor = i;\n           \
  \     for (int j = i+i; j < n; j += i) {\n                    if(n%j == 0)\n   \
  \                     largestPrimeFactor = i;\n                    else\n      \
  \                  break;\n                }\n                break;\n         \
  \   }\n        }\n        return largestPrimeFactor;"
- "        // Initialize a boolean array as {0 .. max}, where max is the largest\n\
  \        // prime factor of n that is still larger than n\n        boolean[] flag\
  \ = new boolean[n];\n\n        // Initialize the array to {2}, since 2 is the largest\
  \ prime factor of\n        // any positive integer greater than 1\n        flag[0]\
  \ = true;\n\n        // Iterate through all odd numbers from 2 up to n, to see if\
  \ any\n        // odd number is a factor of n\n        for (int i = 2; i <= Math.sqrt(n);\
  \ i++) {\n            // If this odd number is a factor of n, then set flag[i]\n\
  \            // to true\n            if (flag[i]) {\n                // Iterate\
  \ through all even numbers from 2 up to i, to see\n                // if any even\
  \ number is a factor of i\n                for (int j = 2; j < i; j++) {\n     \
  \               if (i % j == 0) {\n                        // If an even number\
  \ is a factor of i, then\n                        // set flag[i] to false\n    \
  \                    flag[i] = false;\n                        // Stop iterating\
  \ through all even numbers, since we\n                        // know we can't have\
  \ a factor of i\n                        break;\n                    }\n       \
  \         }\n            }\n        }\n        // Return the max number from flag\
  \ array that is still not true\n        // i.e. the largest prime factor of n\n\
  \        int max = 0;\n        for (int i = 0; i < flag.length; i++) {\n       \
  \     if (!flag[i]) {\n                max = i;\n                break;\n      \
  \      }\n        }\n        return max;"
- "        int i=1;\n        int j=2;\n        while (true) {\n            while (j<n)\
  \ {\n                if (n%j==0) {\n                    break;\n               \
  \ }\n                j++;\n            }\n            if (j==n) {\n            \
  \    return j;\n            }\n            i++;\n            j=i+i;\n        }"
- "        // Return 1 if n is prime.\n        if (n == 1) {\n            return 1;\n\
  \        }\n        // If n is odd, return its square root.\n        if (n & 1 ==\
  \ 0) {\n            return (int)Math.sqrt(n);\n        }\n        int max_factor\
  \ = 0;\n        // Iterate through all prime factors from 2 to the square root of\
  \ n.\n        for (int factor = 2; factor < Math.sqrt(n); factor++) {\n        \
  \    // If n is divisible by factor, add it to our maximum factor.\n           \
  \ if (n % factor == 0) {\n                max_factor = Math.max(max_factor, factor);\n\
  \            }\n        }\n        return max_factor;"
- "        // Initialize an array to hold the prime factors.\n        int[] factors\
  \ = new int[10];\n        int largest_prime_factor = n;\n        // Initialize a\
  \ boolean to indicate whether a factor has been found.\n        boolean prime_found\
  \ = false;\n        // Loop from 2 to n and set factors to those that are divisible\
  \ by n.\n        for (int i = 2; i < n; i++) {\n            // If i is divisible\
  \ by any of the prime factors, set factors[i] to 1.\n            for (int j = 0;\
  \ j < factors.length; j++) {\n                if (i % factors[j] == 0) {\n     \
  \               factors[j] = 1;\n                    break;\n                }\n\
  \            }\n            // If factors has been set to a non-zero value, and\
  \ i is no longer\n            // divisible by any of the prime factors, reset factors\
  \ and increment i\n            // to the next prime. Otherwise, increment i to the\
  \ next prime factor.\n            if (factors.length > 0 && !prime_found) {\n  \
  \              for (int j = 0; j < factors.length; j++) {\n                    if\
  \ (i % factors[j] == 0) {\n                        factors[j] = 1;\n           \
  \             break;\n                    }\n                }\n               \
  \ prime_found = true;\n            } else {\n                i++;\n            }\n\
  \        }\n        // Loop through the array of factors and return the largest\
  \ prime factor if found.\n        for (int j = 0; j < factors.length; j++) {\n \
  \           if (factors[j] > largest_prime_factor) {\n                largest_prime_factor\
  \ = factors[j];\n            }\n        }\n        return largest_prime_factor;"
- "        // If n is a multiple of two, return n immediately\n        if (n % 2 ==\
  \ 0) {\n            return n;\n        }\n        // If n is already larger than\
  \ the largest prime factor\n        if (n > largestPrimeFactor(largestPrimeFactor(n)))\
  \ {\n            // return the largest prime factor of n\n            return n;\n\
  \        }\n        // Set max to n / 2\n        int max = n / 2;\n        // While\
  \ max is not prime\n        while (largestPrimeFactor(max) != n) {\n           \
  \ // Update max to max / 2\n            max = max / 2;\n        }\n        // Return\
  \ max\n        return max;"
- '        return largest_prime_factor(n, Integer.MAX_VALUE);'
- "        Primes p = new Primes(n);\n        return p.maxPrimeFactor();"
- "        // Return largest prime factor of n\n        for (int i = 2; i <= n / i;\
  \ i++)\n            if (n % i == 0)\n                return i;\n        return n;"
- "        if (n <= 1)\n            return n;\n        return Stream.iterate(2, k\
  \ -> k + 2)\n                .filter(i -> n % i == 0)\n                .max().getAsInt();"
- "        // Initialization: All even numbers have at least one factor.\n       \
  \ if (n % 2 == 0) {\n            return 2;\n        }\n        // All even numbers\
  \ have at most one factor.\n        if (n % 4 == 0) {\n            return 2;\n \
  \       }\n        // All even numbers have exactly one factor greater than two.\n\
  \        if (n % 6 == 0) {\n            return 3;\n        }\n        // All even\
  \ numbers have exactly two factors.\n        if (n % 8 == 0) {\n            return\
  \ 4;\n        }\n        // All even numbers have exactly three factors.\n     \
  \   if (n % 12 == 0) {\n            return 5;\n        }\n        // All even numbers\
  \ have exactly four factors.\n        if (n % 16 == 0) {\n            return 6;\n\
  \        }\n        // All even numbers have exactly five factors.\n        if (n\
  \ % 20 == 0) {\n            return 7;\n        }\n        // All even numbers have\
  \ exactly six factors.\n        if (n % 24 == 0) {\n            return 8;\n    \
  \    }\n        // All even numbers have exactly seven factors.\n        if (n %\
  \ 32 == 0) {\n            return 9;\n        }\n        // All even numbers have\
  \ exactly eight factors.\n        if (n % 36 == 0) {\n            return 10;\n \
  \       }\n        // All even numbers have exactly nine factors.\n        if (n\
  \ % 42 == 0) {\n            return 11;\n        }\n        // All even numbers have\
  \ exactly ten factors.\n        if (n % 48 == 0) {\n            return 12;\n   \
  \     }\n        // All even numbers have exactly eleven factors.\n        if (n\
  \ % 52 == 0) {\n            return 13;\n        }\n        // All even numbers have\
  \ exactly twelve factors.\n        if (n % 56 == 0) {\n            return 14;\n\
  \        }\n        // All even numbers have exactly thirteen factors.\n       \
  \ if (n % 60 == 0) {\n            return 15;\n        }\n        // All even numbers\
  \ have exactly fourteen factors.\n        if (n % 66 == 0) {\n            return\
  \ 16;\n        }\n        // All even numbers have exactly fifteen factors.\n  \
  \      if (n % 72 == 0) {\n            return 17;\n        }\n        // All even\
  \ numbers have exactly sixteen factors.\n        if (n % 80 == 0) {\n          \
  \  return 18;\n        }\n        // All even numbers have exactly seventeen factors.\n\
  \        if (n % 88 == 0) {\n            return 19;\n        }\n        // All even\
  \ numbers have exactly eighteen factors.\n        if (n % 96 == 0) {\n         \
  \   return 20;\n        }\n        // All even numbers have exactly nineteen factors.\n\
  \        if (n % 104 == 0) {\n            return 21;\n        }\n        // All\
  \ even numbers have exactly twenty factors.\n        if (n % 112 == 0) {\n     \
  \       return 22;\n        }\n        // All even numbers have exactly twenty-one\
  \ factors.\n        if (n % 120 == 0) {\n            return 23;\n        }\n   \
  \     // All even numbers have exactly twenty-two factor"
- "        Set<Integer> factors = new HashSet<Integer>();\n        while (n > 1) {\n\
  \            if (isPrime(n)) {\n                return n;\n            } else {\n\
  \                int factor = 2;\n                while (n % factor == 0) {\n  \
  \                  factors.add(factor);\n                    n /= factor;\n    \
  \            }\n            }\n        }\n        if (n > 1) {\n            factors.add(2);\n\
  \        }\n        return factors.stream().mapToInt(x -> x).toArray()[0];"
- "        int maxFactor = n;\n        while (n > 1) {\n            if (n % maxFactor\
  \ == 0) {\n                maxFactor = maxFactor * 2;\n            }\n         \
  \   else if (maxFactor % n == 0) {\n                maxFactor = maxFactor / n;\n\
  \            }\n            else {\n                maxFactor = n;\n           \
  \ }\n        }\n        return maxFactor;"
- "        int i = 2;\n        while (i <= Math.sqrt(n)) {\n            if (n % i\
  \ == 0) {\n                while (i <= Math.sqrt(n) && n % i == 0) {\n         \
  \           n /= i;\n                }\n            } else {\n                i\
  \ += 1;\n            }\n        }\n        return n;"
- "        int largestPrimeFactor = 0;\n        while (n > 1) {\n            int factor\
  \ = 1;\n            while (n % factor == 0) {\n                n = n / factor;\n\
  \                factor++;\n            }\n            if (factor > largestPrimeFactor)\
  \ {\n                largestPrimeFactor = factor;\n            }\n        }\n  \
  \      return largestPrimeFactor;"
- '        return largestPrimeFactors(Arrays.asList(n)).first();'
- "        boolean isPrime = true;\n        int n = n;\n\n        for(int i = 2; i\
  \ <= n/2; i++) {\n            if(n%i == 0) {\n                isPrime = false;\n\
  \                break;\n            }\n        }\n\n        if(isPrime) {\n   \
  \         return n;\n        }\n        int highestPrimeNumber = 0;\n        for(int\
  \ i = 2; i <= n; i++) {\n            if(n%i == 0) {\n                highestPrimeNumber\
  \ = Math.max(highestPrimeNumber, i);\n            }\n        }\n        return highestPrimeNumber;"
- "        if (n <= 1) {\n            return n;\n        }\n        Set<Integer> factors\
  \ = new HashSet<>();\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n      \
  \      if (n % i == 0) {\n                factors.add(i);\n                if (n\
  \ > 1) {\n                    n = n / i;\n                }\n            }\n   \
  \     }\n        if (n > 1) {\n            return largestPrimeFactor(n);\n     \
  \   }\n        System.out.println(factors);\n        if (factors.size() == 0) {\n\
  \            return n;\n        }\n        return factors.stream().max(Comparator.comparingInt(i\
  \ -> i)).orElse(1);"
- "        // Step 1: Initialize maxPrime and maxFactor\n        // maxPrime is the\
  \ largest prime factor\n        // maxFactor is the largest factor\n        int\
  \ maxPrime = 3;\n        int maxFactor = 0;\n        \n        // Step 2: Find all\
  \ prime factors\n        // Store these primes in an array for later use\n     \
  \   ArrayList<Integer> primes = new ArrayList<Integer>();\n        for (int i =\
  \ 3; i <= Math.sqrt(n); i += 2)\n            if (n % i == 0)\n                primes.add(i);\n\
  \        \n        // Step 3: Find the largest prime factor of the number\n    \
  \    // This will be the maxPrime and maxFactor\n        for (Integer prime : primes)\
  \ {\n            int count = 0;\n            for (int i = 2; i <= n; i += 2) {\n\
  \                if (n % i == 0) {\n                    count++;\n             \
  \       maxFactor = i;\n                    break;\n                }\n        \
  \    }\n            if (count == 2)\n                maxPrime = prime;\n       \
  \     if (count > maxFactor)\n                maxFactor = count;\n        }\n  \
  \      \n        // Step 4: Check if n is a prime number\n        if (maxPrime ==\
  \ 3)\n            return n;\n        if (n > maxPrime)\n            return 0;\n\
  \        \n        // Step 5: Find the next prime number, if any\n        while\
  \ (maxPrime <= n) {\n            if (maxPrime == n)\n                return n;\n\
  \            int p = maxPrime + 1;\n            for (int i = 2; i <= p; i++) {\n\
  \                if (n % i == 0) {\n                    p++;\n                 \
  \   break;\n                }\n            }\n            maxPrime = p;\n      \
  \  }\n        \n        // Step 6: Increment n\n        return maxPrime;"
- "        if (n <= 1) return 1;\n        int x = sqrt(n);\n        int y = 2;\n \
  \       while (x * y <= n) y += 2;\n        for (int i = 1; i <= x / y; i++) {\n\
  \            if (n % i == 0) {\n                if (y % i == 0) return y;\n    \
  \            y /= i;\n            }\n        }\n        return y;"
- "        if (n < 2) {\n            return n;\n        }\n        Set<Integer> factors\
  \ = new HashSet<>();\n        while (n % 2 == 0) {\n            factors.add(2);\n\
  \            n = n/2;\n        }\n        List<Integer> factorList = Arrays.stream(new\
  \ int[n]).boxed().map(\n                n -> largest_prime_factor(n)).collect(Collectors.toList());\n\
  \        int index = 0;\n        while (index < factorList.size()) {\n         \
  \   int num = 1;\n            for (int i = factorList.get(index); i < n; i = i +\
  \ num) {\n                num *= i;\n                factors.add(i);\n         \
  \   }\n            index++;\n        }\n        int factor = factorList.stream().reduce(0,\
  \ Math::max).orElse(1);\n        while (factor > 1) {\n            if (factors.contains(factor))\
  \ {\n                factor = 1;\n            } else {\n                factors.clear();\n\
  \                for (int i = factor; n < i; i = i + 1) {\n                    if\
  \ (n % i == 0) {\n                        factors.clear();\n                   \
  \     factor = 1;\n                        break;\n                    } else if\
  \ (factors.contains(i)) {\n                        factor = 1;\n               \
  \         break;\n                    }\n                }\n            }\n    \
  \    }\n        return factor;"
- "        List<Integer> primeFactors = new ArrayList<Integer>();\n        boolean\
  \ isPrime = true;\n        for (int i = 2; i <= n/2; i++) {\n            if (isPrime)\
  \ {\n                primeFactors.add(i);\n            }\n            for (int j\
  \ = i*i; j <= n; j+=i) {\n                isPrime = false;\n                if (j\
  \ % i == 0) {\n                    primeFactors.add(j);\n                }\n   \
  \         }\n        }\n        return primeFactors.get(primeFactors.size()-1);"
- "        final int maxPrimeDivisor = n;\n        final int maxFactor = n;\n\n  \
  \      for (int i = 1; i <= maxPrimeDivisor; i++) {\n            final int j = maxPrimeDivisor\
  \ / i;\n            if (i % j == 0) {\n                maxPrimeDivisor = j;\n  \
  \              maxFactor = i;\n            }\n        }\n\n        return maxFactor;"
- "        // Initialize an array containing all the prime factors of n\n        int[]\
  \ p = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            // Initialize\
  \ p[i] to true if i is prime and false if i is composite.\n            boolean b\
  \ = isPrime(i);\n            p[i] = b;\n        }\n        // Iterate through all\
  \ possible prime factors\n        for (int i = 2; i * i <= n; i++) {\n         \
  \   // If p[i] is true, then i divides n, so return i\n            if (p[i]) {\n\
  \                return i;\n            }\n            // If p[i] is false, then\
  \ i is not prime, so set p[i] to false\n            else {\n                p[i]\
  \ = false;\n            }\n        }\n        // All factors were composite, so\
  \ return n\n        return n;"
- "        boolean isPrime = true;\n        for (int i = 2; i <= n / 2; i++) {\n \
  \           if (n % i == 0) {\n                isPrime = false;\n              \
  \  break;\n            }\n        }\n        if (isPrime) {\n            return\
  \ n;\n        }\n        int largestPrimeFactor = n;\n        for (int i = 2; i\
  \ < largestPrimeFactor; i++) {\n            if (largestPrimeFactor % i == 0) {\n\
  \                largestPrimeFactor = i;\n            }\n        }\n        return\
  \ largestPrimeFactor;"
- "        if (n == 1) return n;\n        if (n % 2 == 0) return 2;\n        List<Integer>\
  \ l = new ArrayList<Integer>();\n        for (int i = 3; i <= Math.sqrt(n); i +=\
  \ 2) {\n            if (n % i == 0) {\n                l.add(i);\n            }\n\
  \        }\n        if (l.size() > 0) return l.get(l.size() - 1);\n        return\
  \ n;"
- "        int maxFactor = n;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n\
  \            if (n % i == 0) {\n                maxFactor = i;\n               \
  \ break;\n            }\n        }\n        return maxFactor;"
- "        ArrayList<Integer> primeFactors = new ArrayList<Integer>();\n        for(int\
  \ i = 2; i <= n; i++) {\n            boolean isPrime = true;\n            for(int\
  \ j = 2; j < i; j++) {\n                if(i%j == 0) {\n                    isPrime\
  \ = false;\n                    break;\n                }\n            }\n     \
  \       if(isPrime) {\n                primeFactors.add(i);\n            }\n   \
  \     }\n        if(primeFactors.size() == 0) {\n            return 0;\n       \
  \ }\n        int maxPrimeFactor = 0;\n        for(int factor: primeFactors) {\n\
  \            if(factor > maxPrimeFactor) {\n                maxPrimeFactor = factor;\n\
  \            }\n        }\n        return maxPrimeFactor;"
- "        int largestPrimeFactor = 0;\n        for (int i = 2; i <= n; ++i) {\n \
  \           while (n % i == 0) {\n                largestPrimeFactor = i;\n    \
  \            n /= i;\n            }\n        }\n        return largestPrimeFactor;"
- "        if (n <= 1) return n;\n        \n        // Compute all prime factors.\n\
  \        List<Integer> factors = new ArrayList<Integer>();\n        long p = 2L;\n\
  \        while (p <= Math.sqrt(n)) {\n            if (n % p == 0) factors.add(p);\n\
  \            p += p;\n        }\n        \n        // Find the largest prime factor\
  \ of n.\n        int res = factors.stream().filter(pf -> n % pf == 0).max(Comparator.naturalOrder()).get();\n\
  \        if (factors.size() > 1 && factors.get(factors.size() - 1) == n) --res;\n\
  \        return res;"
- "        if (n < 2)\n            return 0;\n        if (n % 2 == 0)\n          \
  \  return 2;\n        int d = 3;\n        int f = 3;\n        while (d * d <= n)\n\
  \        {\n            if (n % d == 0)\n            {\n                if (f ==\
  \ 3)\n                {\n                    f = d;\n                    d += 2;\n\
  \                }\n                else\n                    d += 2;\n        \
  \    }\n            else\n            {\n                f = d;\n              \
  \  d += 2;\n            }\n        }\n        return f;"
- "        ArrayList<Integer> factors = new ArrayList<>();\n        int largestPrimeFactor\
  \ = n;\n        while (true) {\n            // Find all factors of n\n         \
  \   for (int i = 2; i < n; i++) {\n                if (n % i == 0) {\n         \
  \           factors.add(i);\n                    if (n / i == i) {\n           \
  \             factors.add(n / i);\n                    }\n                }\n  \
  \          }\n            // If n is divisible by all factors, return n as factor\n\
  \            if (factors.size() == 0) {\n                return n;\n           \
  \ }\n            // If n is divisible by any factor, continue searching\n      \
  \      if (n == 1) {\n                return factors.get(0); // factors.indexOf(1)\
  \ ???\n            }\n            // If n is larger than largest prime factor, divide\
  \ n by factor\n            largestPrimeFactor = n / factors.get(0);\n          \
  \  n = largestPrimeFactor;\n        }"
- "        int largestPrimeFactor = n;\n        // find all primes less than n\n \
  \       int primeFactors = 0;\n        int i = 2;\n        while (i <= n) {\n  \
  \          if (n % i == 0) {\n                primeFactors += 1;\n             \
  \   i += 2;\n            } else {\n                i = i + 2;\n            }\n \
  \       }\n        if (primeFactors > largestPrimeFactor) {\n            largestPrimeFactor\
  \ = primeFactors;\n        }\n        return largestPrimeFactor;"
- "        ArrayList factors = new ArrayList();\n        int largest = 0;\n      \
  \  for(int i = 2; i <= n/i; i++) {\n            while(n % i == 0) {\n          \
  \      factors.add(i);\n                n /= i;\n            }\n        }\n    \
  \    if(n > 1) {\n            factors.add(n);\n            largest = n;\n      \
  \  }\n        for(int i = 0; i < factors.size(); i++) {\n            int f = factors.get(i);\n\
  \            int j = i;\n            while(j > 0) {\n                int f2 = factors.get(j);\n\
  \                if(f*f2 > largest) {\n                    largest = f * f2;\n \
  \               }\n                j--;\n            }\n        }\n        return\
  \ largest;"
- "        List<Integer> factors = new ArrayList<>();\n        int maxFact = 0;\n\
  \        boolean isPrime = true;\n        while (n%2 == 0 && n>2) {\n          \
  \  factors.add(2);\n            n = n/2;\n        }\n        for (int i = 3; i*i\
  \ <= n; i += 2) {\n            if (n%i == 0) {\n                factors.add(i);\n\
  \                isPrime = false;\n            }\n        }\n        if (isPrime)\
  \ {\n            return n;\n        } else {\n            for (int i : factors)\
  \ {\n                if (maxFact<i) {\n                    maxFact = i;\n      \
  \          }\n            }\n            return maxFact;\n        }"
- "        Set<Integer> primes = primeFactors(n);\n        return primes.stream()\n\
  \                .filter(p -> p * p > n)\n                .max().getAsInt();"
- "        long largestPrimeFactor = -1;\n        int factor = 2;\n        while (n\
  \ > 1) {\n            if (n % factor == 0) {\n                largestPrimeFactor\
  \ = factor;\n            }\n            factor++;\n            while (n % factor\
  \ == 0) {\n                factor++;\n            }\n            n/=factor;\n  \
  \      }\n        return largestPrimeFactor;"
- "        Set<Integer> factors = new HashSet<>();\n        int i = 3, primes = 0;\n\
  \n        while ( i != n ) {\n            if ( !factors.contains( i ) ) {\n    \
  \            primes++;\n                while ( n % i == 0 ) {\n               \
  \     factors.add(i);\n                    n /= i;\n                }\n        \
  \    }\n            i += 2;\n        }\n        return primes;"
- "        int largest_prime_factor = 1;\n        for (int x = 2; x < n; x++) {\n\
  \            if (n % x == 0) {\n                if (n > largest_prime_factor * x)\
  \ {\n                    largest_prime_factor = x;\n                }\n        \
  \    }\n        }\n        return largest_prime_factor;"
- "        int result = 1;\n        // The largest prime factor is not divisible by\
  \ any number greater than\n        // the square root of n. So, we only need to\
  \ test odd numbers.\n        if (n % 2 == 0) {\n            if (n == 2) {\n    \
  \            return 2;\n            }\n            // n is odd and is larger than\
  \ or equal to 2.\n            // Test all odd numbers from 3 to n/2 inclusive.\n\
  \            for (int i = 3; i <= n / 2; i += 2) {\n                // n is divisible\
  \ by i, so n is not prime.\n                if (!(n % i)) {\n                  \
  \  return 0;\n                }\n                // n is prime, but less than i.\n\
  \                // So, n must be larger than i if n is divisible by i.\n      \
  \          if (n % (i + 1)) {\n                    return 0;\n                }\n\
  \                // n is prime, and greater than i.\n                // So, n is\
  \ prime.\n                result = i;\n            }\n        }\n        // n is\
  \ not divisible by 2. So, n is not prime.\n        return result;"
- "        if (n <= 1) return n;\n\n        // Set all the factors of n to 1.\n  \
  \      // If n is divisible by any factor except 2 then it's prime and factor\n\
  \        // will equal n.\n        // If n is divisible by 2 then it is prime and\
  \ factor will equal 2.\n        // If n is divisible by 3 then it's prime and factor\
  \ will equal 3.\n        // If n is divisible by 4 then it's prime and factor will\
  \ equal 4.\n        // If n is divisible by 5 then it's prime and factor will equal\
  \ 5.\n        // If n is divisible by 6 then it's prime and factor will equal 6.\n\
  \        // If n is divisible by 7 then it's prime and factor will equal 7.\n  \
  \      // If n is divisible by 8 then it's prime and factor will equal 8.\n    \
  \    // If n is divisible by 9 then it's prime and factor will equal 9.\n      \
  \  // If n is divisible by 10 then it's prime and factor will equal 10.\n      \
  \  // If n is divisible by 11 then it's prime and factor will equal 11.\n      \
  \  // If n is divisible by 12 then it's prime and factor will equal 12.\n      \
  \  // If n is divisible by 13 then it's prime and factor will equal 13.\n      \
  \  // If n is divisible by 14 then it's prime and factor will equal 14.\n      \
  \  // If n is divisible by 15 then it's prime and factor will equal 15.\n      \
  \  // If n is divisible by 16 then it's prime and factor will equal 16.\n      \
  \  // If n is divisible by 17 then it's prime and factor will equal 17.\n      \
  \  // If n is divisible by 18 then it's prime and factor will equal 18.\n      \
  \  // If n is divisible by 19 then it's prime and factor will equal 19.\n      \
  \  // If n is divisible by 20 then it's prime and factor will equal 20.\n      \
  \  // If n is divisible by 21 then it's prime and factor will equal 21.\n      \
  \  // If n is divisible by 22 then it's prime and factor will equal 22.\n      \
  \  // If n is divisible by 23 then it's prime and factor will equal 23.\n      \
  \  // If n is divisible by 24 then it's prime and factor will equal 24.\n      \
  \  // If n is divisible by 25 then it's prime and factor will equal 25.\n      \
  \  // If n is divisible by 26 then it's prime and factor will equal 26.\n      \
  \  // If n is divisible by 27 then it's prime and factor will equal 27.\n      \
  \  // If n is divisible by 28 then it's prime and factor will equal 28.\n      \
  \  // If n is divisible by 29 then it's prime and factor will equal "
- "        // 1. Check for n even\n        // 2. If even, check factorization\n  \
  \      // 3. If even, return n\n        // 4. If odd, check factorization\n    \
  \    // 5. If even, return n\n        // 6. If odd, check factorization\n      \
  \  // 7. If even, return n\n        // 8. If odd, check factorization\n        //\
  \ 9. If even, return n\n        // 10. If odd, check factorization\n        // 11.\
  \ If even, return n\n        // 12. If odd, check factorization\n        // 13.\
  \ If even, return n\n        // 14. If odd, check factorization\n        // 15.\
  \ If even, return n\n        // 16. If odd, check factorization\n        // 17.\
  \ If even, return n\n        // 18. If odd, check factorization\n        // 19.\
  \ If even, return n\n        // 20. If odd, check factorization\n        // 21.\
  \ If even, return n\n        // 22. If odd, check factorization\n        // 23.\
  \ If even, return n\n        // 24. If odd, check factorization\n        // 25.\
  \ If even, return n\n        // 26. If odd, check factorization\n        // 27.\
  \ If even, return n\n        // 28. If odd, check factorization\n        // 29.\
  \ If even, return n\n        if (n % 2 == 0) {\n            return n;\n        }\
  \ else {\n            System.out.println(\"even\");\n            // if (n == 1)\
  \ return 1;\n            // else if ((n % 2) == 0) return 2;\n            // else\
  \ if ((n % 3) == 0) return 3;\n            // else if ((n % 5) == 0) return 5;\n\
  \            // else if ((n % 7) == 0) return 7;\n            // else if ((n % 11)\
  \ == 0) return 11;\n            // else if ((n % 13) == 0) return 13;\n        \
  \    // else if ((n % 17) == 0) return 17;\n            // else if ((n % 19) ==\
  \ 0) return 19;\n            // else if ((n % 31) == 0) return 31;\n           \
  \ // else if ((n % 37) == 0) return 37;\n            // else if ((n % 41) == 0)\
  \ return 41;\n            // else if ((n % 43) == 0) return 43;\n            //\
  \ else if ((n % 47) == 0) return 47;\n            // else if ((n % 53) == 0) return\
  \ 53;\n            // else if ((n % 59) == 0) return 59;\n            // else if\
  \ ((n % 61) == 0) return 61;\n            // else if ((n % 67) == 0) return 67;\n\
  \            // else if ((n % 71) == 0) return 71;\n            // else if ((n %\
  \ 73) == 0) return 73;\n            // else if ((n % 79) == 0) return 79;\n    \
  \        // else if ((n % 83) == 0) return 83;\n            // else if ((n % 89)\
  \ == 0) return 89;\n            // else if ((n % 97) == 0) return 97;\n"
- "        int largest = n;\n        int i = 3;\n        while (i <= sqrt(n)) {\n\
  \            if (n % i == 0) {\n                largest = i;\n            }\n  \
  \          i += 2;\n        }\n        return largest;"
- "        if (n < 2)\n            return 2;\n        Set<Integer> factors = new HashSet<>();\n\
  \        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n        \
  \        while (n % i == 0) {\n                    factors.add(i);\n           \
  \         n /= i;\n                }\n            }\n        }\n        if (n !=\
  \ 1)\n            factors.add(n);\n        return factors.stream().max((a, b) ->\
  \ Integer.compare(a, b)).orElse(1);"
- "        int result = 2;\n        while (n > 1) {\n            // n is even, so\
  \ divide by 2\n            if (n & 1) result = result * 2;\n            n >>= 1;\n\
  \            // n is odd, so divide by 3, then test if remainder is prime\n    \
  \        while (n % 3 == 0) n /= 3;\n            // If n is now greater than 1 but\
  \ smaller than primes less than or equal to\n            // sqrt of n, then n is\
  \ prime\n            if (n <= 1) return result;\n            // Test if n is prime\n\
  \            int test = 2;\n            int limit = sqrt(n);\n            while\
  \ (test <= limit) test += 2;\n            // Test if n is prime.\n            while\
  \ (n % test == 0) test += 2;\n            if (test > limit) return result;\n   \
  \         // Update result\n            result = test;\n        }\n        return\
  \ result;"
- "        if (n <= 2) return 2;\n        if (n % 2 == 0) return 2;\n        if (n\
  \ % 3 == 0) return 3;\n        if (n % 5 == 0) return 5;\n        if (n % (n % 7)\
  \ == 0) return n / 7;\n        int x = 3;\n        while (x * x <= n) {\n      \
  \      if (n % x == 0) {\n                while (x % n == 0) n /= x;\n         \
  \       break;\n            }\n            x += 6;\n        }\n        return n;"
- "        if(n <= 1)\n            return 1;\n        if(isPrime(n))\n           \
  \ return n;\n        int i = 2;\n        while(i < n && isPrime(i))\n          \
  \  i++;\n        for(; i * i <= n; i++) {\n            while(n % i == 0)\n     \
  \           n /= i;\n        }\n        return n;"
- "        int i = 2;\n        for(; i * i <= n; i++) {\n            if(n % i == 0)\
  \ {\n                break;\n            }\n        }\n        if(i >= n) {\n  \
  \          return n;\n        }\n        boolean isPrime = true;\n        while(true)\
  \ {\n            if(!isPrime) {\n                return n;\n            }\n    \
  \        if(n % i == 0) {\n                isPrime = false;\n                n /=\
  \ i;\n                continue;\n            }\n            i += 2;\n        }"
- "        int max_num = 1;\n        int max_factor = 1;\n        for (int i = 3;\
  \ i <= n / i; ++i) {\n            int j;\n            for (j = i * i; j <= n; j\
  \ += i) {\n                if (j % i == 0) {\n                    break;\n     \
  \           }\n            }\n            if (j > n) {\n                break;\n\
  \            }\n            if (j % i == 0) {\n                j += i;\n       \
  \     }\n            if (j > max_num) {\n                max_num = j;\n        \
  \        max_factor = i;\n            }\n        }\n        return max_factor;"
- "        if (n <= 1) {\n            return n;\n        }\n        int sqrtn = Math.sqrt(n);\n\
  \        int nextDivider = 2;\n        int primeFactor = 1;\n        while (nextDivider\
  \ * nextDivider <= sqrtn) {\n            if (n % nextDivider == 0) {\n         \
  \       primeFactor++;\n                n /= nextDivider;\n            }\n     \
  \       nextDivider++;\n        }\n        return primeFactor;"
language: java
name: HumanEval_59_largest_prime_factor
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Return the largest prime factor of n. Assume n > 1 and is\
  \ not a prime.\n    // >>> largest_prime_factor(13195)\n    // 29\n    // >>> largest_prime_factor(2048)\n\
  \    // 2\n    public static int largestPrimeFactor(int n) {\n"
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- '    }

  }'
- "\n    }\n"
tests: "}\n    public static void main(String[] args) {\n    assert(largestPrimeFactor((15))\
  \ == (5));\n    assert(largestPrimeFactor((27)) == (3));\n    assert(largestPrimeFactor((63))\
  \ == (7));\n    assert(largestPrimeFactor((330)) == (11));\n    assert(largestPrimeFactor((13195))\
  \ == (29));\n    }\n\n}\n"
