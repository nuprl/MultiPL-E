name: HumanEval_107_even_odd_palindrome
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Given a positive integer n, return a tuple that has the\
  \ number of even and odd\n    // integer palindromes that fall within the range(1,\
  \ n), inclusive.\n    // Example 1:\n    // Input: 3\n    // Output: (1, 2)\n  \
  \  // Explanation:\n    // Integer palindrome are 1, 2, 3. one of them is even,\
  \ and two of them are odd.\n    // Example 2:\n    // Input: 12\n    // Output:\
  \ (4, 6)\n    // Explanation:\n    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7,\
  \ 8, 9, 11. four of them are even, and 6 of them are odd.\n    // Note:\n    //\
  \ 1. 1 <= n <= 10^3\n    // 2. returned tuple has the number of even and odd integer\
  \ palindromes respectively.\n    public static Pair<Integer, Integer> evenOddPalindrome(int\
  \ n) {\n"
tests: "return Pair.with(0,0);\n    }\n    public static void main(String[] args)\
  \ {\n    assert(evenOddPalindrome((123)).equals((Pair.with(8, 13))));\n    assert(evenOddPalindrome((12)).equals((Pair.with(4,\
  \ 6))));\n    assert(evenOddPalindrome((3)).equals((Pair.with(1, 2))));\n    assert(evenOddPalindrome((63)).equals((Pair.with(6,\
  \ 8))));\n    assert(evenOddPalindrome((25)).equals((Pair.with(5, 6))));\n    assert(evenOddPalindrome((19)).equals((Pair.with(4,\
  \ 6))));\n    assert(evenOddPalindrome((9)).equals((Pair.with(4, 5))));\n    assert(evenOddPalindrome((1)).equals((Pair.with(0,\
  \ 1))));\n    }\n\n}\n"
completions: ["        Pair<Integer, Integer> even = new Pair<>(0,0);\n        Pair<Integer,\
    \ Integer> odd = new Pair<>(0,0);\n        for(int i = 1; i <= n; i++) {\n   \
    \         boolean isEven = true;\n            boolean isOdd = true;\n        \
    \    for(int j = 1; j <= i; j++) {\n                if(((i%j) == 0) || ((j%i)\
    \ == 0)) {\n                    isEven = false;\n                    isOdd = false;\n\
    \                    break;\n                }\n            }\n            if(isEven)\
    \ {\n                even.first++;\n                if(even.first == 2) {\n  \
    \                  even.second = 1;\n                } else {\n              \
    \      even.second++;\n                }\n            } else {\n             \
    \   odd.first++;\n                if(odd.first == 2) {\n                    odd.second\
    \ = 1;\n                } else {\n                    odd.second++;\n        \
    \        }\n            }\n        }\n        return Pair.create(even.first, even.second);",
  "        Pair<Integer, Integer> evenOdd = new Pair<>();\n        ArrayList <Integer>\
    \ even = new ArrayList();\n        ArrayList <Integer> odd = new ArrayList();\n\
    \        for (int i = 1; i <= n; i++) {\n            String str = Integer.toString(i);\n\
    \            str = str.substring(0, str.length() - 1);\n            int length\
    \ = str.length();\n            if (str.length() % 2 == 1) {\n                odd.add(Integer.parseInt(str));\n\
    \            } else {\n                even.add(Integer.parseInt(str));\n    \
    \        }\n        }\n        int evenCount = even.size();\n        int oddCount\
    \ = odd.size();\n        if (evenCount == oddCount) {\n            if (evenCount\
    \ == 0) {\n                evenOdd.setFirst(0);\n            } else {\n      \
    \          evenOdd.setFirst(evenCount / 2);\n                evenOdd.setSecond(evenCount\
    \ - evenCount / 2);\n            }\n        } else {\n            evenOdd.setFirst(evenCount\
    \ / 2);\n            evenOdd.setSecond(evenCount - evenCount / 2);\n         \
    \   evenOdd.setSecond(oddCount);\n        }\n        return evenOdd;", "     \
    \   int odd = n;\n        int even = 0;\n        while (odd > 0) {\n         \
    \   odd = odd / 2;\n            even++;\n        }\n        while (even > 0) {\n\
    \            even = even / 2;\n            odd--;\n        }\n        return new\
    \ ImmutablePair<>(even, odd);", "        \n        // Write your code here\n \
    \       int p = 0;\n        int a = 0;\n        \n        int odd = 0;\n     \
    \   int even = 0;\n        \n        for (int i = 1; i <= n; i++) {\n        \
    \    \n            if (i%2 == 0){\n                even++;\n            }\n  \
    \          \n            else if (i%2 != 0){\n                odd++;\n       \
    \     }\n            \n        }\n        \n        int evenPalindrome = 0;\n\
    \        int oddPalindrome = 0;\n        \n        if (even == odd){\n       \
    \     evenPalindrome++;\n        }\n        \n        else {\n            oddPalindrome++;\n\
    \        }\n        \n        if (even <= p){\n            p = even;\n       \
    \ }\n        \n        else {\n            p = odd;\n        }\n        \n   \
    \     if (oddPalindrome <= a){\n            a = oddPalindrome;\n        }\n  \
    \      \n        else {\n            a = evenPalindrome;\n        }\n        \n\
    \        return new Pair<>(evenPalindrome, oddPalindrome);", "        List<Integer>\
    \ even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n\
    \        for (int i = 1; i <= n; i++) {\n            boolean isEven = true;\n\
    \            boolean isOdd = true;\n            StringBuilder sb = new StringBuilder();\n\
    \            StringBuilder sb2 = new StringBuilder();\n            while (i>0)\
    \ {\n                sb.append(String.valueOf(i%10));\n                i = i /\
    \ 10;\n            }\n            sb2.reverse();\n            int j = 0;\n   \
    \         for (int i = sb.length()-1; i >=0; i--) {\n                j++;\n  \
    \              if (sb.charAt(i) == sb2.charAt(j)) {\n                    isEven\
    \ = false;\n                    isOdd = false;\n                    break;\n \
    \               }\n                j++;\n            }\n            if (isEven)\
    \ {\n                even.add(i);\n            }\n            if (isOdd) {\n \
    \               odd.add(i);\n            }\n        }\n        return new Pair<Integer,\
    \ Integer>(even.size(), odd.size());", "        Set<Integer> evenPalindromes =\
    \ new HashSet<>();\n        Set<Integer> oddPalindromes = new HashSet<>();\n \
    \       for(int i = 1, j = 1; i <= n; i++) {\n            while(j != i && j !=\
    \ (i - 1)) {\n                if(j % 2 == 0) {\n                    evenPalindromes.add(j);\n\
    \                }\n                else {\n                    oddPalindromes.add(j);\n\
    \                }\n                j++;\n            }\n        }\n        return\
    \ new ImmutablePair<>(evenPalindromes.size(), oddPalindromes.size());", "    \
    \    int odd = 0, even = 0;\n        ArrayList<Integer> odd_list, even_list;\n\
    \        \n        //create list for odd numbers\n        odd_list = new ArrayList<Integer>();\n\
    \        even_list = new ArrayList<Integer>();\n        \n        // iterate until\
    \ n-1\n        for (int i = 0; i <= n; i++) {\n            if (isPalindrome(i))\
    \ {\n                // remove from odd_list until reaching n\n              \
    \  while (odd_list.size() > n) {\n                    odd_list.remove(odd_list.size()\
    \ - 1);\n                }\n                \n                // remove from even_list\
    \ until reaching n\n                while (even_list.size() > n) {\n         \
    \           even_list.remove(even_list.size() - 1);\n                }\n     \
    \           \n                // if odd_list has more elements then even_list,\
    \ add to odd list\n                if (odd_list.size() >= even_list.size()) {\n\
    \                    odd_list.add(i);\n                } else {\n            \
    \        even_list.add(i);\n                }\n            } else {\n        \
    \        odd_list.add(i);\n                even_list.add(i);\n            }\n\
    \        }\n        \n        // construct pair\n        Pair<Integer, Integer>\
    \ evenOdd = Pair.of(even, odd);\n        \n        return evenOdd;", "       \
    \ List<Integer> evens = new ArrayList<>();\n        List<Integer> odds = new ArrayList<>();\n\
    \        \n        for (int i = 1; i <= n; i++) {\n            int evenPalindrome\
    \ = 0;\n            int oddPalindrome = 0;\n            \n            if (isPalindrome(i))\
    \ {\n                int tempNum = i;\n                while (tempNum != 0) {\n\
    \                    int tempRem = tempNum % 10;\n                    tempNum\
    \ = tempNum / 10;\n                    int digit = tempRem;\n                \
    \    \n                    \n                    if (digit % 2 == 0) {\n     \
    \                   evenPalindrome++;\n                    } else {\n        \
    \                oddPalindrome++;\n                    }\n                }\n\
    \            } else {\n                evenPalindrome++;\n                oddPalindrome++;\n\
    \            }\n            \n            if (evenPalindrome >= i) {\n       \
    \         evens.add(i);\n            }\n            \n            if (oddPalindrome\
    \ >= i) {\n                odds.add(i);\n            }\n        }\n        \n\
    \        int evenCount = evens.size();\n        int oddCount = odds.size();\n\
    \        return new Pair<>(evenCount, oddCount);", "        ArrayList<Integer>\
    \ even = new ArrayList<Integer>();\n        ArrayList<Integer> odd = new ArrayList<Integer>();\n\
    \        Pair<Integer, Integer> pair = new Pair<Integer, Integer>(even, odd);\n\
    \        // Write your code here\n        if(n < 0 || n > 10^3){\n           \
    \ return new Pair<Integer, Integer>(2, 0);\n        }\n        if(n > 1){\n  \
    \          for(int  i = 0; i <= n/2 ; i++){\n                odd.add(i);\n   \
    \             int a = 0;\n                for(int j = i ; j < n; j++){\n     \
    \               if(i % 2 ==0 && j % 2 == 1){\n                        a = 1;\n\
    \                    }\n                    else if(i % 2 ==1 && j % 2 == 0){\n\
    \                        a = 2;\n                    }\n                    if(a\
    \ == 1){\n                        even.add(j);\n                    }\n      \
    \          }\n            }\n            for(int  i = n/2; i >= 1 ; i--){\n  \
    \              even.add(i);\n                int b = 0;\n                for(int\
    \ j = i ; j >= 1; j--){\n                    if(i % 2 ==0 && j % 2 == 1){\n  \
    \                      b = 1;\n                    }\n                    else\
    \ if(i % 2 ==1 && j % 2 == 0){\n                        b = 2;\n             \
    \       }\n                    if(b == 2){\n                        odd.add(j);\n\
    \                    }\n                }\n            }\n        }\n        Pair<Integer,\
    \ Integer> evenPalindrome = new Pair<Integer, Integer>(even, odd);\n        return\
    \ evenPalindrome;", "        // Write your code here\n        int even = 0;\n\
    \        int odd = 0;\n        for(int i = 1; i < n; i++) {\n            for(int\
    \ j = 1; j < i; j++) {\n                if(i % 2 == 0) {\n                   \
    \ even++;\n                    if(isPalindrome(i) == false) {\n              \
    \          even = even - 1;\n                    }\n                }\n      \
    \          if(i % 2 != 0) {\n                    odd++;\n                    if(isPalindrome(i)\
    \ == false) {\n                        odd = odd - 1;\n                    }\n\
    \                }\n            }\n        }\n        Pair<Integer, Integer> pair\
    \ = new Pair<>(even, odd);\n        return pair;", "        if (n < 1 || n > 10\
    \ ** 3) {\n            throw new IllegalArgumentException();\n        }\n    \
    \    Set<Integer> evenPalindromes = new HashSet<>();\n        Set<Integer> oddPalindromes\
    \ = new HashSet<>();\n        int even = 0, odd = 0;\n        int maxSize = n;\n\
    \        while (maxSize > 1) {\n            int mid = (maxSize / 2) >> 1;\n  \
    \          Pair<Integer, Integer> temp = new Pair<>(mid, 1);\n            Pair<Integer,\
    \ Integer> firstHalf = evenPalindromes.isEmpty() ? temp : Pair.of(-1, 0);\n  \
    \          Pair<Integer, Integer> secondHalf = oddPalindromes.isEmpty() ? temp\
    \ : Pair.of(-1, 0);\n            Pair<Integer, Integer> pair = Pair.of(-1, -1);\n\
    \            if (pair == Pair.of(-1, -1)) {\n                int left = new Random().nextInt(mid)\
    \ + 1;\n                int right = new Random().nextInt(mid) + 1;\n         \
    \       pair = Pair.of(left, right);\n                Pair<Integer, Integer> firstHalf\
    \ = evenPalindromes.isEmpty() ? Pair.of(left, right) : Pair.of(left, right);\n\
    \                Pair<Integer, Integer> secondHalf = oddPalindromes.isEmpty()\
    \ ? Pair.of(left, right) : Pair.of(left, right);\n                if (pair ==\
    \ Pair.of(-1, -1)) {\n                    int left = new Random().nextInt(mid)\
    \ + 1;\n                    int right = new Random().nextInt(mid) + 1;\n     \
    \               pair = Pair.of(left, right);\n                    Pair<Integer,\
    \ Integer> firstHalf = evenPalindromes.isEmpty() ? Pair.of(left, right) : Pair.of(left,\
    \ right);\n                    Pair<Integer, Integer> secondHalf = oddPalindromes.isEmpty()\
    \ ? Pair.of(left, right) : Pair.of(left, right);\n                    if (pair\
    \ == Pair.of(-1, -1)) {\n                        int left = new Random().nextInt(mid)\
    \ + 1;\n                        int right = new Random().nextInt(mid) + 1;\n \
    \                       pair = Pair.of(left, right);\n                       \
    \ Pair<Integer, Integer> firstHalf = evenPalindromes.isEmpty() ? Pair.of(left,\
    \ right) : Pair.of(left, right);\n                        Pair<Integer, Integer>\
    \ secondHalf = oddPalindromes.isEmpty() ? Pair.of(left, right) : Pair.of(left,\
    \ right);\n                    }\n                }\n            }\n         \
    \   if (pair == Pair.of(-1, -1)) {\n                pair = Pair.of(-1, -1);\n\
    \            }\n            int firstHalfSum = Pair.sum(", "        if (n < 0)\
    \ return null;\n        Pair<Integer, Integer> even = new Pair<>();\n        Pair<Integer,\
    \ Integer> odd = new Pair<>();\n        for (int i = 1; i <= n; i++) {\n     \
    \       String input = Integer.toString(i);\n            String reverse = reverse(input);\n\
    \            if (input.equals(reverse)) {\n                if (input.charAt(0)\
    \ % 2 == 0) {\n                    even.first = even.first + 1;\n            \
    \    } else {\n                    odd.first = odd.first + 1;\n              \
    \  }\n            } else {\n                if (input.charAt(0) % 2 == 0) {\n\
    \                    even.second = even.second + 1;\n                } else {\n\
    \                    odd.second = odd.second + 1;\n                }\n       \
    \     }\n        }\n        return Pair.of(even.first, even.second);", "     \
    \   List<Integer> evenPalindrome = new ArrayList<>();\n        List<Integer> oddPalindrome\
    \ = new ArrayList<>();\n\n        for(int i = 1 ; i <= n ; i++) {\n          \
    \  int evenPalindromes = 0;\n            int oddPalindromes = 0;\n\n         \
    \   int evenPalindromesWithinRange = 0;\n            int oddPalindromesWithinRange\
    \ = 0;\n\n            // first check if the number is palindrome\n           \
    \ boolean isPalindrome = true;\n\n            for(int j = i-1 ; j >= 0 ; j--)\
    \ {\n                if(Integer.valueOf(String.valueOf(i))\n                 \
    \       .charAt((String.valueOf(i)).indexOf('-')+1)\n                        .equals(String.valueOf(String.valueOf(i))\n\
    \                            .charAt(String.valueOf(j)).charAt(0))) {\n      \
    \              isPalindrome = false;\n                    break;\n           \
    \     }\n            }\n            for(int j = i+1 ; j <= n ; j++) {\n      \
    \          if(Integer.valueOf(String.valueOf(i))\n                        .charAt((String.valueOf(i)).indexOf('-')+1)\n\
    \                        .equals(String.valueOf(String.valueOf(i))\n         \
    \                   .charAt(String.valueOf(j)).charAt(0))) {\n               \
    \     isPalindrome = false;\n                    break;\n                }\n \
    \           }\n\n            if(isPalindrome) {\n                evenPalindromesWithinRange++;\n\
    \            }\n\n            // check the odd palindrome range\n            for(int\
    \ j = i-1 ; j >= 0 ; j--) {\n                if(Integer.valueOf(String.valueOf(i))\n\
    \                        .charAt((String.valueOf(i)).indexOf('-')+1)\n       \
    \                 .equals(String.valueOf(String.valueOf(i))\n                \
    \            .charAt(String.valueOf(j)).charAt(0))) {\n                    oddPalindromesWithinRange++;\n\
    \                }\n            }\n            for(int j = i+1 ; j <= n ; j++)\
    \ {\n                if(Integer.valueOf(String.valueOf(i))\n                 \
    \       .charAt((String.valueOf(i)).indexOf('-')+1)\n                        .equals(String.valueOf(String.valueOf(i))\n\
    \                            .charAt(String.valueOf(j)).charAt(0))) {\n      \
    \              oddPalindromesWithinRange++;\n                }\n            }\n\
    \n            if(oddPalindromesWithinRange == 0) {\n                oddPalindromes.add(new\
    \ Integer(i));\n            }\n            else if(evenPalindromesWithinRange\
    \ == 0) {\n                evenPalindromes.add(new Integer(i));\n            }\n\
    \        }\n\n        // return tuple\n        if(evenPalindromes.size() != 0)\
    \ {\n            return Pair.of(evenPalindromes.size(), oddPalindromes.size());\n\
    \        }\n        return Pair.", "        Map<Integer, Integer> evenPalindrome\
    \ = new HashMap<>();\n        Map<Integer, Integer> oddPalindrome = new HashMap<>();\n\
    \        if (n == 1) {\n            return new Pair<Integer, Integer>(evenPalindrome.getOrDefault(n\
    \ - 1, 0), oddPalindrome.getOrDefault(n - 1, 0));\n        }\n\n        for (int\
    \ i = 1; i <= n; i++) {\n            int odd = n - i;\n            int even =\
    \ i + (odd / 2);\n            if (odd % 2 != 0) {\n                oddPalindrome.put(odd,\
    \ even);\n            }\n            if (even % 2 != 0) {\n                evenPalindrome.put(even,\
    \ odd);\n            }\n        }\n        return new Pair<Integer, Integer>(evenPalindrome.getOrDefault(0,\
    \ 0), oddPalindrome.getOrDefault(0, 0));", "        Pair<Integer, Integer> even\
    \ = new Pair<>();\n        Pair<Integer, Integer> odd = new Pair<>();\n      \
    \  if (n <= 0 || n > 1000000000 || n % 1 != 0) {\n            even.first = 0;\n\
    \            even.second = 0;\n            odd.first = 0;\n            odd.second\
    \ = 0;\n        } else {\n            int[] result = new int[n];\n           \
    \ for (int i = n - 1; i >= 0; i--) {\n                result[n - i - 1] = (result[i]\
    \ % 2 == 0) ? 0 : 1;\n            }\n            Arrays.sort(result);\n      \
    \      if (result[0] % 2 == 0) {\n                even.first++;\n            }\n\
    \            if (result[n - 1] % 2 == 0) {\n                odd.first++;\n   \
    \         }\n            int i = 0;\n            for (i = 0; i < result.length;\
    \ i++) {\n                if (result[i] % 2 == 0) {\n                    even.second++;\n\
    \                }\n                if (result[n - 1 - i] % 2 == 0) {\n      \
    \              odd.second++;\n                }\n            }\n        }\n  \
    \      return Pair.of(even.first, odd.first);", "        HashMap<Integer, Pair<Integer,\
    \ Integer>> map = new HashMap<>();\n        for(int i = 1; i <= n; i++){\n   \
    \         String str = Integer.toString(i);\n            if(isPalindrome(str)){\n\
    \                if(map.containsKey(str)){\n                    map.get(str).first.increment();\n\
    \                    map.get(str).second.increment();\n                }\n   \
    \             else{\n                    Pair<Integer, Integer> even = new Pair<>();\n\
    \                    even.first = i;\n                    even.second = Pair.of(i,\
    \ 1);\n                    map.put(i, even);\n                }\n            }\n\
    \        }\n        return new Pair<>(map.size(), map.values()\n             \
    \   .stream().filter(e -> e.second.second() % 2 == 0).count());", "        int\
    \ evenCount = 0;\n        int oddCount = 0;\n        boolean isOdd = Integer.toString(n).reverse().equals(Integer.toString(n));\n\
    \        if (n > 10) {\n            return new Pair<>(evenCount, oddCount);\n\
    \        }\n        int start = 1;\n        while (start <= n) {\n           \
    \ int end = start;\n            while (end < n && end >= start) {\n          \
    \      end++;\n            }\n            if (isOdd) {\n                oddCount++;\n\
    \                if (end == n - 1) {\n                    break;\n           \
    \     }\n            } else {\n                evenCount++;\n                if\
    \ (end == n - 1) {\n                    break;\n                }\n          \
    \  }\n            start = end;\n        }\n        return new Pair<>(evenCount,\
    \ oddCount);", "        Pair<Integer, Integer> evenOdd = new Pair<>();\n     \
    \   if (n < 1 || n > 10) {\n            return evenOdd;\n        }\n        Set<Integer>\
    \ set = new HashSet<>();\n        int i = 0;\n        for (; i <= n; i++) {\n\
    \            int remainder = i % 10;\n            int j = i;\n            do {\n\
    \                j++;\n                if (set.remove(j % 10)) {\n           \
    \         continue;\n                }\n                int temp = j % 10;\n \
    \               if (temp != remainder) {\n                    set.add(temp);\n\
    \                    i = j;\n                    break;\n                }\n \
    \           } while (j != i);\n        }\n        if (i == n) {\n            evenOdd\
    \ = new Pair<>(set.length() / 2, set.length() / 2 + 1);\n        } else {\n  \
    \          evenOdd = new Pair<>(set.length() / 2, set.length() / 2 + 1);\n   \
    \     }\n        return evenOdd;", "        if (n <= 0) return null;\n\n     \
    \   // Step 1: Initialize a array for storing palindrome\n        int palindromes[]\
    \ = new int[n];\n        int even = 0, odd = 0;\n\n        // Step 2: Count palindromes\
    \ in range(1, n), inclusive\n        // - palindromes[j] contains palindromes\
    \ between 1 and j\n        // - palindromes[j - 1] contains palindromes between\
    \ j and j - 1\n        // - palindromes[j + 1] contains palindromes between j\
    \ + 1 and n\n        for (int i = 1; i <= n; i++) {\n            int j;\n    \
    \        // Step 3: Find palindromes between 1 and i\n            int count =\
    \ 0;\n            for (j = 0; j < i; j++) {\n                if (palindromes[j\
    \ - 1] == palindromes[j] && palindromes[j + 1] == palindromes[j])\n          \
    \          count++;\n            }\n\n            // Step 4: If count > 0, even\n\
    \            if (count > 0)\n                even++;\n\n            // Step 5:\
    \ If count < 0, odd\n            else if (count < 0)\n                odd++;\n\
    \        }\n\n        // Step 6: Construct Pair<Integer, Integer>\n        //\
    \ - Pair contains even and odd palindromes\n        return new Pair<>(even, odd);",
  "        if(n < 1 || n >= 10^3) {\n            throw new RuntimeException(\"n must\
    \ be in [1, 10^3]\");\n        }\n        int odd = 0, even = 0;\n        for(int\
    \ i = 1; i <= n; i++) {\n            if((i % 2) == 0) {\n                even++;\n\
    \            }\n            else {\n                odd++;\n            }\n  \
    \          int evenPalindrome = 0, oddPalindrome = 0;\n            for(int j =\
    \ i; j > 1; j /= 2) {\n                while(j % 2 == 0) {\n                 \
    \   oddPalindrome++;\n                    j--;\n                }\n          \
    \      while(j % 2 != 0) {\n                    evenPalindrome++;\n          \
    \          j--;\n                }\n            }\n            if((even % 2 ==\
    \ 0 && oddPalindrome == evenPalindrome) || (even % 2 != 0 && evenPalindrome ==\
    \ oddPalindrome)) {\n                even = evenPalindrome;\n                odd\
    \ = oddPalindrome;\n            }\n        }\n        Pair<Integer, Integer> result\
    \ = new Pair<>((int)even, (int)odd);\n        return result;", "        // write\
    \ your code here\n        \n        Set<Integer> set = new HashSet<Integer>();\n\
    \        for (int i = 0; i < n; i++) {\n            int palindrome = 0;\n    \
    \        while (i > 0) {\n                int remain = n % 10;\n             \
    \   int add = remain;\n                n = n / 10;\n                int remain2\
    \ = n % 10;\n                if (remain == remain2) {\n                    add++;\n\
    \                }\n                palindrome++;\n                n = n / 10;\n\
    \            }\n            set.add(i);\n            set.add(palindrome);\n  \
    \      }\n        \n        return new Pair<Integer, Integer>(set.size(), set.size()\
    \ - set.size());", "        Set<Integer> set = new HashSet<>();\n        for(int\
    \ i = 1; i <= n; i++) {\n            String str = String.valueOf(i);\n       \
    \     char[] cha = str.toCharArray();\n            StringBuffer buf = new StringBuffer();\n\
    \            for(int j = 0; j < cha.length; j++) {\n                buf.append(cha[j]);\n\
    \            }\n            if(!set.contains(buf.reverse().toString().toUpperCase()))\
    \ {\n                if(Integer.parseInt(buf.reverse().toString()) % 2 == 0) {\n\
    \                    set.add(Integer.parseInt(buf.reverse().toString()));\n  \
    \              }\n            }\n        }\n        return new Pair<>(set.size(),\
    \ set.size() - (set.size() / 2));", "        Pair<Integer, Integer> result = new\
    \ Pair<>(1, 0);\n        if (n < 10) {\n            Pair<Integer, Integer> evenOddPalindrome\
    \ = evenOddPalindrome(n / 10);\n            result.first = Math.max(result.first,\
    \ evenOddPalindrome.first);\n            result.second = Math.max(result.second,\
    \ evenOddPalindrome.second);\n            return result;\n        } else if (n\
    \ < 100) {\n            Pair<Integer, Integer> evenOddPalindrome = evenOddPalindrome(n\
    \ / 100);\n            result.first = Math.max(result.first, evenOddPalindrome.first);\n\
    \            result.second = Math.max(result.second, evenOddPalindrome.second);\n\
    \            return result;\n        } else if (n < 1000) {\n            Pair<Integer,\
    \ Integer> evenOddPalindrome = evenOddPalindrome(n / 1000);\n            result.first\
    \ = Math.max(result.first, evenOddPalindrome.first);\n            result.second\
    \ = Math.max(result.second, evenOddPalindrome.second);\n            return result;\n\
    \        } else if (n < 10000) {\n            Pair<Integer, Integer> evenOddPalindrome\
    \ = evenOddPalindrome(n / 10000);\n            result.first = Math.max(result.first,\
    \ evenOddPalindrome.first);\n            result.second = Math.max(result.second,\
    \ evenOddPalindrome.second);\n            return result;\n        } else if (n\
    \ < 100000) {\n            Pair<Integer, Integer> evenOddPalindrome = evenOddPalindrome(n\
    \ / 100000);\n            result.first = Math.max(result.first, evenOddPalindrome.first);\n\
    \            result.second = Math.max(result.second, evenOddPalindrome.second);\n\
    \            return result;\n        } else if (n < 1000000) {\n            Pair<Integer,\
    \ Integer> evenOddPalindrome = evenOddPalindrome(n / 1000000);\n            result.first\
    \ = Math.max(result.first, evenOddPalindrome.first);\n            result.second\
    \ = Math.max(result.second, evenOddPalindrome.second);\n            return result;\n\
    \        } else {\n            Pair<Integer, Integer> evenOddPalindrome = evenOddPalindrome(n\
    \ / 10000000);\n            result.first = Math.max(result.first, evenOddPalindrome.first);\n\
    \            result.second = Math.max(result.second, evenOddPalindrome.second);\n\
    \            return result;\n        }", "        Pair<Integer, Integer> pair\
    \ = Pair.create(0, 0);\n        for(int i = 2; i <= n; i++) {\n            if(n%i\
    \ == 0) {\n                pair.right = pair.right + 1;\n            }\n     \
    \       if(n%i != 0) {\n                pair.left = pair.left + 1;\n         \
    \   }\n        }\n        return pair;", "        // Write your code here\n  \
    \      Pair<Integer, Integer> even = new Pair<>(0, 0);\n        Pair<Integer,\
    \ Integer> odd = new Pair<>(0, 0);\n        for (int i = 1; i <= n; i++) {\n \
    \           String s = Integer.toString(i);\n            int evenCount = 0;\n\
    \            int oddCount = 0;\n            int length = s.length();\n       \
    \     int start = 0;\n            int end = 0;\n            while (end < length)\
    \ {\n                end = end + 1;\n                if (s.charAt(end) != s.charAt(length\
    \ - end)) {\n                    end = length - end;\n                }\n    \
    \            oddCount++;\n                if (evenCount <= end) {\n          \
    \          String evenString = s.substring(start, end);\n                    if\
    \ (evenString.equalsIgnoreCase(evenString.reverse())) {\n                    \
    \    evenCount++;\n                    }\n                }\n            }\n \
    \           even.first(even.first() + evenCount);\n            odd.second(odd.second()\
    \ + oddCount);\n        }\n        return Pair.pair(even.first(), odd.first());",
  "        HashSet<Integer> set = new HashSet<>();\n        for(int i = 1; i <= n;\
    \ i++) {\n            boolean isPalindrome = true;\n            for(int j = i;\
    \ j >= 1; i--) {\n                if(set.get(j) != set.get(i - 1)) {\n       \
    \             isPalindrome = false;\n                    break;\n            \
    \    }\n            }\n            if(isPalindrome) {\n                set.add(n);\n\
    \                set.add(i - 1);\n            }\n        }\n        return new\
    \ AbstractMap.SimpleImmutablePair<>(set.size() - 2, set.size() - 1);", "     \
    \   // write your code in Java 7.0\n        Pair<Integer, Integer> pair = new\
    \ Pair<>(0, 0);\n        if (n <= 0) {\n            return pair;\n        }\n\
    \        Integer oddPalindrome = 0;\n        for (int i = 1; i < n; i++) {\n \
    \           String str = String.valueOf(i);\n            str = str.replaceAll(\"\
    \\\\D\", \"\");\n            int num = 0;\n            int j = 0;\n          \
    \  while (j < str.length()) {\n                if (str.charAt(j) >= '0' && str.charAt(j)\
    \ <= '9') {\n                    num = num * 10 + str.charAt(j) - '0';\n     \
    \               j++;\n                } else {\n                    break;\n \
    \               }\n            }\n            if (num < 0) {\n               \
    \ oddPalindrome++;\n            }\n        }\n        pair.left = oddPalindrome;\n\
    \        pair.right = n - oddPalindrome;\n        return pair;", "        List<Integer>\
    \ list = new ArrayList<>();\n        int counter = 0;\n        for(int i = 1;\
    \ i <= n; i++) {\n            String s = Integer.toString(i);\n            for(int\
    \ j = s.length() - 1; j >= 0; j--) {\n                if(s.charAt(j) != s.charAt(j\
    \ + 1)) {\n                    String temp = s.substring(0, j) + s.charAt(j +\
    \ 1) + s.substring(j + 1);\n                    list.add(Integer.valueOf(temp));\n\
    \                }\n            }\n        }\n        List<Integer> even = new\
    \ ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Integer\
    \ x: list) {\n            if((x % 2 == 0) && (list.indexOf(x) < list.size() /\
    \ 2)) {\n                even.add(x);\n            } else {\n                odd.add(x);\n\
    \            }\n        }\n        Pair<Integer, Integer> result = new Pair<>((even.size()),\
    \ (odd.size()));\n        return result;", "        ArrayList<Integer> list =\
    \ new ArrayList<Integer>();\n        // for (int i = 0; i <= n; i++) {\n     \
    \   //     if (i % 2 == 0 && i > 1) {\n        //         list.add(new Integer(i));\n\
    \        //     } else if (i % 2 == 1 && i > 1) {\n        //         list.add(new\
    \ Integer(i));\n        //     }\n        // }\n        for (int i = 1; i <= n;\
    \ i++) {\n            if (i % 2 == 0 && i > 1) {\n                list.add(new\
    \ Integer(i));\n            } else if (i % 2 == 1 && i > 1) {\n              \
    \  list.add(new Integer(i));\n            }\n        }\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        System.out.println(list);\n      \
    \  System.out.println(list);\n        System.out.println(list);\n        System.out.println(list);\n\
    \        System.out.println(list);\n        ", "        // code here\n       \
    \ if (n < 0)\n            return null;\n        Pair<Integer, Integer> result\
    \ = new Pair<>();\n        int count = 1;\n        for (int i = 1; i <= n; i++)\
    \ {\n            Pair<Integer, Integer> evenAndOdd = isPalindrome(i);\n      \
    \      if (evenAndOdd != null) {\n                int evenCount = evenAndOdd.getFirst();\n\
    \                int oddCount = evenAndOdd.getSecond();\n                result.first(evenCount\
    \ + oddCount);\n                count += evenCount + oddCount;\n            }\n\
    \        }\n        result.second(count);\n        return result;", "        if\
    \ (n <= 0) {\n            return null;\n        }\n        List<Integer> evens\
    \ = new ArrayList<>();\n        List<Integer> odds = new ArrayList<>();\n    \
    \    for (int i = 1; i <= n; i++) {\n            String str = Integer.toString(i);\n\
    \            Collections.sort(str);\n            if (str.equals(new StringBuilder(str).reverse()))\
    \ {\n                evens.add(i);\n            } else {\n                odds.add(i);\n\
    \            }\n        }\n        return new Pair<>(evens.size(), odds.size());",
  "        Pair<Integer, Integer> evenOddPalindrome = Pair.of(0, 0);\n        for\
    \ (int i = 1; i <= n; i++) {\n            String str = String.valueOf(i);\n  \
    \          StringBuilder sb = new StringBuilder(str);\n            char firstChar\
    \ = str.charAt(0);\n            char lastChar = str.charAt(str.length() - 1);\n\
    \            if (firstChar == lastChar) {\n                continue;\n       \
    \     }\n            int evenCount = 0;\n            int oddCount = 0;\n     \
    \       int mid = str.length() / 2;\n            for (int j = 0; j < mid; j++)\
    \ {\n                if (str.charAt(j) != str.charAt(mid - j - 1)) {\n       \
    \             evenCount++;\n                }\n            }\n            for\
    \ (int j = mid; j < str.length(); j++) {\n                if (str.charAt(j) !=\
    \ str.charAt(j - mid)) {\n                    oddCount++;\n                }\n\
    \            }\n            evenOddPalindrome = Pair.of(evenCount, oddCount);\n\
    \        }\n        return evenOddPalindrome;", "        int[] numbers = new int[n];\n\
    \        for (int i = 0; i < n; i++)\n            numbers[i] = i;\n        Arrays.sort(numbers);\n\
    \        // Sorted array will look like: 0, 1, 2, 3, 4, 5 ...\n        int evenNumberCount\
    \ = 0;\n        int oddNumberCount = 0;\n        int middleIndex = numbers.length\
    \ / 2;\n        int evenIndex = 0;\n        int oddIndex = numbers.length - 1;\n\
    \        while(true) {\n            // If middle number is even, add one to even\
    \ number count, else add one to\n            // odd number count.\n          \
    \  if (numbers[evenIndex] == numbers[oddIndex]) {\n                if (numbers[evenIndex]\
    \ == numbers[middleIndex])\n                    evenNumberCount++;\n         \
    \       else\n                    oddNumberCount++;\n            }\n         \
    \   else if (numbers[evenIndex] == numbers[middleIndex]) {\n                if\
    \ (numbers[evenIndex] == numbers[oddIndex])\n                    evenNumberCount++;\n\
    \                else\n                    evenNumberCount++;\n            }\n\
    \            else if (numbers[oddIndex] == numbers[middleIndex]) {\n         \
    \       if (numbers[evenIndex] == numbers[oddIndex])\n                    oddNumberCount++;\n\
    \                else\n                    oddNumberCount++;\n            }\n\
    \            else if (numbers[evenIndex] == numbers[middleIndex])\n          \
    \      evenNumberCount++;\n            else if (numbers[oddIndex] == numbers[middleIndex])\n\
    \                oddNumberCount++;\n            // If both middle number and even\
    \ or odd index are same then it means middle is\n            // the palindrome.\n\
    \            else {\n                if (numbers[evenIndex] == numbers[oddIndex])\n\
    \                    return new Pair<>(evenNumberCount, oddNumberCount);\n   \
    \         }\n            // If middle number is odd, we only need to check odd\
    \ number.\n            if (numbers[evenIndex] == numbers[oddIndex])\n        \
    \        oddIndex--;\n            else\n                evenIndex++;\n       \
    \ }", "        HashSet<Integer> hs = new HashSet<Integer>();\n        hs.add(1);\
    \ hs.add(n); hs.add(2*n); hs.add(3*n);\n        hs.add(4); hs.add(6); hs.add(4*n);\
    \ hs.add(6*n); hs.add(7*n); hs.add(8*n);\n        hs.add(9); hs.add(11); hs.add(9*n);\
    \ hs.add(10*n); hs.add(11*n); hs.add(12*n); hs.add(13*n);\n        hs.add(14);\
    \ hs.add(16); hs.add(14*n); hs.add(15*n); hs.add(16*n); hs.add(17*n); hs.add(18*n);\n\
    \        hs.add(19); hs.add(21); hs.add(19*n); hs.add(20*n); hs.add(21*n); hs.add(22*n);\
    \ hs.add(23*n);\n        hs.add(24); hs.add(26); hs.add(24*n); hs.add(25*n); hs.add(26*n);\
    \ hs.add(27*n); hs.add(28*n);\n        hs.add(29); hs.add(31); hs.add(29*n); hs.add(30*n);\
    \ hs.add(31*n); hs.add(32*n); hs.add(33*n);\n        hs.add(34); hs.add(36); hs.add(34*n);\
    \ hs.add(35*n); hs.add(36*n); hs.add(37*n); hs.add(38*n);\n        hs.add(39);\
    \ hs.add(41); hs.add(39*n); hs.add(40*n); hs.add(41*n); hs.add(42*n); hs.add(43*n);\n\
    \        hs.add(44); hs.add(46); hs.add(44*n); hs.add(45*n); hs.add(46*n); hs.add(47*n);\
    \ hs.add(48*n);\n        hs.add(49); hs.add(51); hs.add(49*n); hs.add(50*n); hs.add(51*n);\
    \ hs.add(52*n); hs.add(53*n);\n        hs.add(54); hs.add(56); hs.add(54*n); hs.add(55*n);\
    \ hs.add(56*n); hs.add(57*n); hs.add(58*n);\n        hs.add(59); hs.add(61); hs.add(59*n);\
    \ hs.add(60*n); hs.add(61*n); hs.add(62*n); hs.add(63*n);\n        hs.add(64);\
    \ hs.add(66); hs.add(64*n); hs.add(65*n); hs.add(66*n); hs.add(67*n); hs.add(68*n);\n\
    \        hs.add(69); hs.add(71); hs.add(69*n); hs.add(70*n); hs.add(71*n); hs.add(72*n);\
    \ hs.add(73*n);\n        hs.add(74); hs.add(76", "        List<Integer> nums =\
    \ new ArrayList<>();\n        nums.add(1);\n        for (int i = 2; i <= n; i++)\
    \ {\n            if (isPalindrome(nums, i)) {\n                nums.add(i);\n\
    \            }\n        }\n        return evenOddPalindrome(nums.stream().distinct().count());",
  "        // write your code here\n        Pair<Integer, Integer> ans = new Pair<>(0,\
    \ 0);\n        for (int i = 0; i < n; i++) {\n            String s = Integer.toString(i);\n\
    \            int even_odd = 0;\n            int len = s.length();\n          \
    \  char c = s.charAt(len - 1);\n            for (int j = len; j > (len - 2); j--)\
    \ {\n                if (s.charAt(j) != c) {\n                    break;\n   \
    \             }\n                even_odd++;\n            }\n            ans.first\
    \ = Math.max(ans.first, even_odd);\n            int odd = 0;\n            for\
    \ (int j = len; j < len + 1; j++) {\n                if (s.charAt(j) != c) {\n\
    \                    break;\n                }\n                odd++;\n     \
    \       }\n            ans.second = Math.max(ans.second, odd);\n        }\n  \
    \      return ans;", "        ArrayList <Integer> evenPalindromes = new ArrayList\
    \ <Integer> ();\n        ArrayList <Integer> oddPalindromes = new ArrayList <Integer>\
    \ ();\n        for (int i = 2; i < n; i++) {\n            String reverse = Integer.toString(i);\n\
    \            String stringReverse = new StringBuilder(reverse).reverse().toString();\n\
    \            if (stringReverse == reverse) {\n                evenPalindromes.add(i);\n\
    \            } else {\n                oddPalindromes.add(i);\n            }\n\
    \        }\n        evenPalindromes.addAll(oddPalindromes);\n        int evenCount\
    \ = evenPalindromes.size();\n        int oddCount = oddPalindromes.size();\n \
    \       return new Pair<> (evenCount, oddCount);", "        if (n < 1) {\n   \
    \         return new Pair<>(0,0);\n        }\n        if (n <= 3) {\n        \
    \    return Pair.of(1, 1);\n        }\n        int even = 0;\n        int odd\
    \ = 0;\n        for (int i = 1; i <= n; i++) {\n            String str = String.valueOf(i);\n\
    \            if (str.equals(new StringBuilder(str).reverse().toString())) {\n\
    \                even++;\n            }\n            else {\n                odd++;\n\
    \            }\n        }\n        return new Pair<>(even, odd);", "        List<Integer>\
    \ result = new ArrayList<>();\n        for(int i = 1; i <= n; i++) {\n       \
    \     boolean isEven = true;\n            boolean isOdd = true;\n            while(i\
    \ != 1) {\n                if(i % 2 != 0) {\n                    isEven = false;\n\
    \                    break;\n                }\n                if(i % 2 == 0)\
    \ {\n                    isOdd = false;\n                    break;\n        \
    \        }\n                i = i / 2;\n            }\n            boolean isLeftPalindrome\
    \ = isEven;\n            boolean isRightPalindrome = isOdd;\n            while(isLeftPalindrome\
    \ && isRightPalindrome) {\n                if(isLeftPalindrome && isRightPalindrome)\
    \ {\n                    isLeftPalindrome = false;\n                    isRightPalindrome\
    \ = false;\n                    result.add(i);\n                }\n          \
    \      if(isLeftPalindrome) {\n                    isLeftPalindrome = isRightPalindrome;\n\
    \                }\n                if(isRightPalindrome) {\n                \
    \    isRightPalindrome = isLeftPalindrome;\n                }\n              \
    \  i = i / 2;\n            }\n        }\n        return new Pair<Integer, Integer>(result.size(),\
    \ result.size());", "        Pair<Integer, Integer> result = new Pair<>(0, 0);\n\
    \        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n\
    \                Pair<Integer, Integer> pair = evenOddPalindrome(i);\n       \
    \         result.first().intValue() += pair.first().intValue();\n            \
    \    result.second().intValue() += pair.second().intValue();\n            }\n\
    \        }\n        return result;", "        int even = 0;\n        int odd =\
    \ 0;\n        for (int i = 0; i <= n; i++) {\n            String str = Integer.toString(i);\n\
    \            if (isPalindrome(str)) {\n                int length = str.length();\n\
    \                int evenOdd = 0;\n                for (int j = 0; j < (length\
    \ / 2); j++) {\n                    if (str.charAt(j) != str.charAt(length - 1\
    \ - j)) {\n                        evenOdd = evenOdd + 1;\n                  \
    \  }\n                }\n                even = even + evenOdd;\n            }\n\
    \        }\n        return new Pair<>(even, odd);", "        int even = 0;\n \
    \       int odd = 0;\n\n        if(n <= 0)\n            return Pair.of(0,0);\n\
    \        else if(n % 2 == 0)\n        {\n            even = n;\n            odd\
    \ = n-1;\n        }\n        else if(n % 2 != 0)\n        {\n            odd =\
    \ n;\n            even = n-2;\n        }\n\n        Pair<Integer, Integer> result\
    \ = Pair.of(even, odd);\n        if(n <= 10)\n        {\n            Pair<Integer,\
    \ Integer> result2 = Pair.of(even, odd);\n            if(even == 0)\n        \
    \        result2 = Pair.of(odd, even);\n            return result2;\n        }\n\
    \n        Pair<Integer, Integer> result3 = Pair.of(even, odd);\n        if(even\
    \ > 9)\n        {\n            int x = even % 10;\n            Pair<Integer, Integer>\
    \ result4 = Pair.of(even, odd);\n            if(even == 1)\n                result4\
    \ = Pair.of(odd, even);\n            if(even == 2)\n                result4 =\
    \ Pair.of(x, even);\n            return result4;\n        }\n\n        Pair<Integer,\
    \ Integer> result5 = Pair.of(even, odd);\n        if(odd > 9)\n        {\n   \
    \         int x = odd % 10;\n            Pair<Integer, Integer> result6 = Pair.of(even,\
    \ odd);\n            if(even == 1)\n                result6 = Pair.of(odd, even);\n\
    \            if(even == 2)\n                result6 = Pair.of(x, even);\n    \
    \        return result6;\n        }\n\n        return result3;", "        if (n\
    \ <= 0) {\n            return null;\n        }\n        boolean isEven = true;\n\
    \        boolean isOdd = true;\n        Pair<Integer, Integer> even = new Pair<>();\n\
    \        Pair<Integer, Integer> odd = new Pair<>();\n        for (int i = 1; i\
    \ <= n; i++) {\n            isEven = isEven && !isOdd;\n            isOdd = isOdd\
    \ && isEven;\n            Pair<Integer, Integer> pair = new Pair<>();\n      \
    \      if (isEven) {\n                even.first = i;\n                even.second\
    \ = isOdd ? n - i : i;\n            }\n            else {\n                odd.first\
    \ = i;\n                odd.second = isOdd ? i : n - i;\n            }\n     \
    \   }\n        return Pair.create(even.first, even.second);", "        // If n\
    \ is 0, we return (0, 0).\n        if (n == 0) {\n            return new Pair<Integer,\
    \ Integer>(0, 0);\n        }\n        Pair<Integer, Integer> even = new Pair<Integer,\
    \ Integer>(0, 0);\n        Pair<Integer, Integer> odd = new Pair<Integer, Integer>(0,\
    \ 0);\n        \n        // If n is 1, we return (0, 0).\n        if (n == 1)\
    \ {\n            return new Pair<Integer, Integer>(0, 0);\n        }\n       \
    \ \n        // Find two even palindromes larger than n.\n        // If n is odd,\
    \ we can only get one even palindrome larger than n.\n        // So even palindrome\
    \ is always n^2.\n        int evenPow2 = n;\n        while (evenPow2 > 0 && evenPow2\
    \ % 2 == 0) {\n            evenPow2 = evenPow2 / 2;\n        }\n        \n   \
    \     // Find two odd palindromes larger than n.\n        // If n is even, we\
    \ can only get one odd palindrome larger than n.\n        // So odd palindrome\
    \ is always n^2 + 1.\n        int oddPow2 = n;\n        while (oddPow2 > 0 &&\
    \ oddPow2 % 2 == 1) {\n            oddPow2 = oddPow2 / 2;\n        }\n       \
    \ \n        // If the given number is odd, oddPow2 must be odd. \n        // So\
    \ if n is odd, we return even.\n        if (oddPow2 % 2 == 1) {\n            return\
    \ even;\n        }\n        \n        // Otherwise, we return odd.\n        return\
    \ odd;", "        // write your code in Java 7\n        Pair<Integer, Integer>\
    \ ret = new Pair<>();\n        int evenPalindrome = 0;\n        int oddPalindrome\
    \ = 0;\n        int palindrome = 1;\n        while(palindrome<=n){\n         \
    \   boolean isEven = true;\n            boolean isOdd = true;\n            while(palindrome<=n){\n\
    \                if(isEven){\n                    if(isOdd){\n               \
    \         if(Integer.toString(palindrome).equals(Integer.reverse(palindrome).toString())){\n\
    \                            evenPalindrome++;\n                            isOdd\
    \ = false;\n                            isEven = false;\n                    \
    \    }else if(Integer.reverse(palindrome).equals(Integer.toString(palindrome))){\n\
    \                            oddPalindrome++;\n                            isOdd\
    \ = true;\n                            isEven = false;\n                     \
    \   }\n                    }\n                    else {\n                   \
    \     if(Integer.toString(palindrome).equals(Integer.reverse(palindrome).toString())){\n\
    \                            evenPalindrome++;\n                            isOdd\
    \ = false;\n                        }else if(Integer.reverse(palindrome).equals(Integer.toString(palindrome))){\n\
    \                            oddPalindrome++;\n                        }\n   \
    \                 }\n                    palindrome++;\n                }\n  \
    \              else{\n                    if(isOdd){\n                       \
    \ if(Integer.toString(palindrome).equals(Integer.reverse(palindrome).toString())){\n\
    \                            evenPalindrome++;\n                            isOdd\
    \ = true;\n                            isEven = false;\n                     \
    \   }else if(Integer.reverse(palindrome).equals(Integer.toString(palindrome))){\n\
    \                            oddPalindrome++;\n                            isOdd\
    \ = false;\n                        }\n                    }\n               \
    \     else {\n                        if(Integer.toString(palindrome).equals(Integer.reverse(palindrome).toString())){\n\
    \                            evenPalindrome++;\n                        }else\
    \ if(Integer.reverse(palindrome).equals(Integer.toString(palindrome))){\n    \
    \                        oddPalindrome++;\n                        }\n       \
    \             }\n                    palindrome++;\n                }\n      \
    \      }\n            ret.first(evenPalindrome);\n            ret.second(oddPalindrome);\n\
    \            evenPalindrome = 0;\n            oddPalindrome = 0;\n           \
    \ palindrome++;\n        }\n        return ret;", "        Pair<Integer, Integer>\
    \ evenOddPalindromes = new Pair<Integer, Integer>();\n        if(n == 1) return\
    \ Pair.of(1, 1);\n        int odd = 1, even = n;\n        while(even > 0 && odd>0)\
    \ {\n            int mid = (even-1)/2;\n            int oddHalf = odd*2;\n   \
    \         int evenHalf = even*2;\n            int oddEvenHalf = oddHalf*2;\n \
    \           int oddOddHalf = evenHalf*2;\n            int evenOddHalf = oddEvenHalf*2;\n\
    \            int oddEvenOddHalf = oddOddHalf*2;\n            evenOddPalindromes.first()\
    \ += oddHalf;\n            oddOddPalindromes.first() += evenHalf;\n          \
    \  evenOddPalindromes.second() += oddEvenHalf;\n            oddEvenPalindromes.second()\
    \ += evenOddHalf;\n            evenOddPalindromes.second() += evenEvenHalf;\n\
    \            oddEvenPalindromes.second() += oddOddHalf;\n            evenOddPalindromes.second()\
    \ += evenOddEvenHalf;\n            odd = oddEvenOddHalf;\n            even = evenOddEvenHalf;\n\
    \        }\n        return evenOddPalindromes;", "        long start = System.nanoTime();\n\
    \        Pair<Integer, Integer> oddEven = new Pair<>();\n        List<Integer>\
    \ nums = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n        \
    \    nums.add(i);\n        }\n        for (int i = 0; i < nums.size(); i++) {\n\
    \            int a = nums.get(i);\n            int b = reverse(a);\n         \
    \   if (isOddOrEven(a, b)) {\n                oddEven.first++;\n             \
    \   oddEven.second += 2;\n            }\n        }\n        long end = System.nanoTime();\n\
    \        return oddEven;", "        Pair<Integer, Integer> evenP = new Pair<>();\n\
    \        Pair<Integer, Integer> oddP = new Pair<>();\n        if (n <= 0) {\n\
    \            evenP.first = 0;\n            evenP.second = 1;\n            oddP.first\
    \ = 0;\n            oddP.second = 1;\n            return Pair.of(evenP.first,\
    \ evenP.second);\n        }\n        if (n <= 1) {\n            evenP.first =\
    \ 0;\n            evenP.second = 1;\n            oddP.first = 0;\n           \
    \ oddP.second = 1;\n            return Pair.of(evenP.first, evenP.second);\n \
    \       }\n        int evenCount = 0;\n        int oddCount = 0;\n        int\
    \ start = 1, end = n;\n        while (start < n) {\n            int mid = start\
    \ + (end - start) / 2;\n            Pair<Integer, Integer> left = evenOddPalindrome(mid);\n\
    \            Pair<Integer, Integer> right = evenOddPalindrome(end - 1);\n    \
    \        if (left.first == right.first) {\n                evenCount += left.second;\n\
    \                evenCount -= right.second;\n            } else {\n          \
    \      oddCount += left.first;\n                oddCount += right.first;\n   \
    \         }\n            start = mid + 1;\n            end = end - 1;\n      \
    \  }\n        evenP.first = evenCount;\n        evenP.second = oddCount;\n   \
    \     oddP.first = oddCount;\n        oddP.second = evenCount;\n        return\
    \ Pair.of(evenP.first, evenP.second);", "        // Your code here\n        List<Integer>\
    \ oddPalindromes = IntStream.range(1, n).filter(i -> i % 2 == 1).collect(Collectors.toList());\n\
    \        List<Integer> evenPalindromes = IntStream.range(1, n).filter(i -> i %\
    \ 2 == 0).collect(Collectors.toList());\n        \n        return new Tuple<>(evenPalindromes.size(),\
    \ oddPalindromes.size());", "        Pair<Integer, Integer> even = new Pair<>(0,\
    \ 0);\n        Pair<Integer, Integer> odd = new Pair<>(0, 0);\n        int[] array\
    \ = new int[n + 1];\n        for (int i = 0; i < array.length; i++) {\n      \
    \      array[i] = i;\n        }\n        int evenNumber = 0;\n        int oddNumber\
    \ = 0;\n        for (int i = n; i > 0; i--) {\n            if (array[i - 1] %\
    \ 2 == 0) {\n                if (array[i] == array[i - 2]) {\n               \
    \     evenNumber++;\n                    array[i] = array[i - 1];\n          \
    \      } else {\n                    oddNumber++;\n                    array[i]\
    \ = array[i - 1];\n                }\n            } else {\n                if\
    \ (array[i] == array[i - 2]) {\n                    oddNumber++;\n           \
    \         array[i] = array[i - 1];\n                } else {\n               \
    \     evenNumber++;\n                    array[i] = array[i - 1];\n          \
    \      }\n            }\n        }\n        if (evenNumber > odd.second) {\n \
    \           even.first = evenNumber;\n            even.second = odd.second;\n\
    \            odd.first = 0;\n            odd.second = 0;\n        }\n        if\
    \ (oddNumber > even.second) {\n            odd.first = oddNumber;\n          \
    \  odd.second = even.second;\n            even.first = 0;\n            even.second\
    \ = 0;\n        }\n        return even;", "        Integer evenCount = 0;\n  \
    \      Integer oddCount = 0;\n        for (int i = 1; i <= n; i++) {\n       \
    \     Pair<Integer, Integer> p = new PalindromeTest().test(i);\n            if\
    \ (p.getSecond() % 2 == 0) {\n                evenCount++;\n            } else\
    \ {\n                oddCount++;\n            }\n        }\n        return Pair.create(evenCount,\
    \ oddCount);", "        List<Integer> palindromes = new ArrayList<>();\n     \
    \   palindromes.add(1);\n        for (int i = 1; i < n; i++) {\n            palindromes.add(i);\n\
    \            palindromes.add(n - i);\n        }\n        List<Integer> evens =\
    \ new ArrayList<>();\n        List<Integer> odds = new ArrayList<>();\n      \
    \  for (Integer i : palindromes) {\n            if (i % 2 == 0) {\n          \
    \      evens.add(i);\n            } else {\n                odds.add(i);\n   \
    \         }\n        }\n        return new Pair<>(evens.size(), odds.size());",
  "        int even=0, odd=0;\n        for(int i=1; i<=n; i++){\n            String\
    \ temp = Integer.toString(i);\n            String reverse = reverseString(temp);\n\
    \            if(temp.equals(reverse)){\n                even++;\n            }else{\n\
    \                odd++;\n            }\n        }\n        Pair<Integer, Integer>\
    \ evenOddPalindrome = new Pair<>(even,odd);\n        return evenOddPalindrome;",
  "        List<Integer> list = Arrays.asList(range(1, n + 1));\n        List<Pair<Integer,\
    \ Integer>> pair = new ArrayList<>();\n        list.forEach(num -> {\n       \
    \     if (isPalindrome(num, list)) {\n                pair.add(new Pair<>(num,\
    \ evenOddPalindrome(Math.max(0, n - num))));\n            }\n        });\n   \
    \     return Pair.of(pair.stream().filter(pair -> pair.getSecond().second == 0).count(),\
    \ pair.stream().filter(pair -> pair.getSecond().second == 1).count());", "   \
    \     List<Integer> list = new ArrayList<>();\n        for (int i = 2; i <= n;\
    \ i++) {\n            list.add(i);\n        }\n        int count = 0;\n      \
    \  for (int i = list.size() - 1; i >= 0; i--) {\n            List<Integer> oddList\
    \ = list.remove(i);\n            boolean oddIsEven = false;\n            for (int\
    \ j = list.size() - 1; j >= 0; j--) {\n                if (list.get(j) != oddList.get(0))\
    \ {\n                    oddIsEven = true;\n                    break;\n     \
    \           }\n            }\n            if (oddIsEven) {\n                count\
    \ += 2;\n            } else {\n                count += 1;\n            }\n  \
    \      }\n        if (list.size() % 2 == 0) {\n            count += 1;\n     \
    \   }\n        return new Pair<Integer, Integer>(count, list.size() / 2);", " \
    \       Pair<Integer, Integer> palindrome = new Pair<>();\n        if (n == 1)\n\
    \            return palindrome;\n        for (int i = 1; i <= n; i++) {\n    \
    \        // Check if palindrome is even or odd\n            if (isPalindrome(i))\
    \ {\n                int even = 0;\n                int odd = 0;\n           \
    \     // Check if palindrome is even palindrome or odd palindrome\n          \
    \      if (isEvenPalindrome(i)) {\n                    even = i;\n           \
    \     } else {\n                    odd = i;\n                }\n            \
    \    // Update the pair with the palindrome count\n                palindrome.first\
    \ = even;\n                palindrome.second = odd;\n            }\n        }\n\
    \        return palindrome;", "        int[] array = new int[n];\n        Arrays.fill(array,\
    \ 0, n, 'x');\n        return getPalindrome(array);", "        int result = 0;\n\
    \        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n\
    \                result += isEven(i);\n                result += isOdd(i);\n \
    \           }\n        }\n        return new Pair<>(result / 2, result % 2);",
  "        int count = 0;\n        int odd = 0;\n        Pair<Integer, Integer> result\
    \ = new Pair<>();\n\n        // If n < 1, return null\n        if (n < 1) {\n\
    \            return null;\n        }\n        // If the number n is odd, then\
    \ return (odd, odd)\n        if (n % 2 != 0) {\n            result.first = odd;\n\
    \            result.second = odd;\n            return result;\n        }\n\n \
    \       // Loop through range(1, n), inclusive\n        for (int i = 1; i <= n;\
    \ i++) {\n            // if i is even, add count + 1, otherwise, add 1\n     \
    \       if (i % 2 == 0) {\n                count++;\n            } else {\n  \
    \              odd++;\n            }\n        }\n\n        result.first = count;\n\
    \        result.second = odd;\n        return result;", "        Pair<Integer,\
    \ Integer> evenPalindromes = new Pair<>(0, 0);\n        Pair<Integer, Integer>\
    \ oddPalindromes = new Pair<>(0, 0);\n        boolean isEven = true;\n       \
    \ boolean isOdd = true;\n        if (n == 0) {\n            return evenPalindromes;\n\
    \        }\n        List<Integer> list = new ArrayList<>();\n        for (int\
    \ i = 1; i <= n; i++) {\n            if (isEven) {\n                isEven = false;\n\
    \            } else {\n                isEven = true;\n            }\n       \
    \     list.add(i);\n        }\n        if (list.isEmpty()) {\n            return\
    \ evenPalindromes;\n        }\n        for (int i = 1; i < list.size(); i++) {\n\
    \            int temp = list.get(list.size() - i);\n            int reverse =\
    \ 0;\n            while (temp != 0) {\n                reverse = reverse * 10\
    \ + temp % 10;\n                temp = temp / 10;\n            }\n           \
    \ if (reverse == list.get(list.size() - i)) {\n                if (list.get(list.size()\
    \ - i) % 2 == 0) {\n                    if (isEven) {\n                      \
    \  evenPalindromes.first++;\n                    }\n                    else {\n\
    \                        evenPalindromes.second++;\n                    }\n  \
    \              } else {\n                    if (isOdd) {\n                  \
    \      oddPalindromes.first++;\n                    }\n                    else\
    \ {\n                        oddPalindromes.second++;\n                    }\n\
    \                }\n            }\n        }\n        return evenPalindromes;",
  "        int low = 1;\n        int high = n;\n        int even = 0;\n        int\
    \ odd = 0;\n        while (low <= high) {\n            int mid = (low + high)\
    \ / 2;\n            Pair<Integer, Integer> pair = evenOddPalindrome(mid);\n  \
    \          if (pair != null) {\n                if (pair.first % 2 == 0) {\n \
    \                   even++;\n                } else {\n                    odd++;\n\
    \                }\n                low = mid + 1;\n            } else {\n   \
    \             low = mid + 1;\n            }\n        }\n        return Pair.create(even,\
    \ odd);", "        final ArrayDeque<Integer> queue = new ArrayDeque<>();\n   \
    \     final ArrayDeque<Integer> odd = new ArrayDeque<>();\n\n        for (int\
    \ i = 1; i <= n; i++) {\n            queue.add(i);\n\n            if (isPalindrome(i))\
    \ {\n                queue.remove();\n                while (queue.peek() == i)\
    \ {\n                    odd.add(queue.peek());\n                    queue.remove();\n\
    \                }\n            }\n        }\n\n        if (odd.isEmpty())\n \
    \           return Pair.of(1, 0);\n\n        return Pair.of(0, odd.size());",
  "        Map<Integer, Integer> evenPalindrome = new HashMap<>();\n        Map<Integer,\
    \ Integer> oddPalindrome = new HashMap<>();\n        for (int i = 2; i <= n; i++)\
    \ {\n            int count = 0;\n            while (n >= i) {\n              \
    \  int x = n % i;\n                if (x == 0) {\n                    count++;\n\
    \                    n = n / i;\n                } else {\n                  \
    \  break;\n                }\n            }\n            evenPalindrome.put(i\
    \ * i, count);\n            int x = 0;\n            while (n >= i) {\n       \
    \         int y = n % i;\n                if (y == 0) {\n                    x++;\n\
    \                    n = n / i;\n                } else {\n                  \
    \  break;\n                }\n            }\n            oddPalindrome.put(i *\
    \ i, x);\n        }\n        return Pair.of((Integer) evenPalindrome.get(evenPalindrome.keySet().toArray()[evenPalindrome.size()\
    \ / 2]),\n                (Integer) oddPalindrome.get(oddPalindrome.keySet().toArray()[oddPalindrome.size()\
    \ / 2]));", "        List<Integer> oddPalindromes = new ArrayList<>();\n     \
    \   List<Integer> evenPalindromes = new ArrayList<>();\n        // For odd\n \
    \       for (int i = 1; i <= n; i += 2) {\n            oddPalindromes.add(i);\n\
    \        }\n        // For even\n        for (int i = 1; i <= n; i += 2) {\n \
    \           evenPalindromes.add(i);\n        }\n        return Pair.of(oddPalindromes.size(),\
    \ evenPalindromes.size());", '        return evenOddPalindromeHelper(n, new Pair<Integer,
    Integer>());', "        List<Integer> even = new ArrayList<Integer>();\n     \
    \   List<Integer> odd = new ArrayList<Integer>();\n        \n        for(int i\
    \ = 1; i < n; i++){\n            if(i % 2 == 0){\n                even.add(i);\n\
    \            }else{\n                odd.add(i);\n            }\n        }\n \
    \       \n        for(int i = 1; i < even.size(); i++){\n            int reverse\
    \ = odd.get(i-1);\n            int j = i;\n            while(j >= 0 && reverse%odd.get(i-1)\
    \ == 0){\n                j--;\n            }\n            if(j > i){\n      \
    \          for(int k = i; k <= j; k++){\n                    even.remove(k);\n\
    \                    odd.remove(k-1);\n                }\n                break;\n\
    \            }\n        }\n        for(int i = 1; i < odd.size(); i++){\n    \
    \        int reverse = odd.get(i-1);\n            int j = i;\n            while(j\
    \ >= 0 && reverse%odd.get(i-1) != 0){\n                j--;\n            }\n \
    \           if(j > i){\n                for(int k = i; k <= j; k++){\n       \
    \             even.remove(k-1);\n                    odd.remove(k);\n        \
    \        }\n                break;\n            }\n        }\n        \n     \
    \   return new Pair<>(even.size(), odd.size());", "        int lower = 1;\n  \
    \      int upper = n;\n        int count = 0;\n\n        while (lower <= upper)\
    \ {\n            int mid = (lower + upper) / 2;\n            Pair<Integer, Integer>\
    \ pal = oddPalindrome(mid);\n\n            if (pal.first() != -1 && pal.second()\
    \ != -1) {\n                count++;\n            }\n\n            if (mid > 2)\
    \ {\n                lower = mid + 1;\n            } else {\n                upper\
    \ = mid - 1;\n            }\n        }\n\n        return Pair.create(2 * count,\
    \ count);", "        List<Integer> palindromes = new ArrayList<Integer>();\n \
    \       for(int i = 1; i <= n; i++){\n            boolean even = true;\n     \
    \       boolean odd = true;\n            for(int j = 1; j <= i / 2; j++){\n  \
    \              int temp = (int) Math.pow(2, j);\n                if((temp % 1)\
    \ == 0){\n                    even = false;\n                    odd = false;\n\
    \                    break;\n                }\n                else{\n      \
    \              even = true;\n                    odd = true;\n               \
    \     break;\n                }\n            }\n            if(even){\n      \
    \          palindromes.add(i);\n            }\n            else if(odd){\n   \
    \             palindromes.add(i * -1);\n            }\n        }\n        \n \
    \       Pair<Integer, Integer> pair = new Pair<Integer, Integer>(palindromes.size(),\
    \ palindromes.size() - palindromes.stream().filter(i -> i == palindromes.get(i)).count());\n\
    \        return pair;", "        Map<Integer, Integer> map = new HashMap();\n\
    \        map.put(1, 1);\n        map.put(2, 1);\n        map.put(3, 1);\n    \
    \    map.put(4, 1);\n        map.put(5, 1);\n        map.put(6, 1);\n        map.put(7,\
    \ 1);\n        map.put(8, 1);\n        map.put(9, 1);\n        map.put(10, 1);\n\
    \        map.put(11, 1);\n        map.put(12, 4);\n\n        int oddCount = 0;\n\
    \        int evenCount = 0;\n\n        for(int i = 1; i <= n; i++) {\n       \
    \     if(map.containsKey(i)) {\n                int count = map.get(i);\n    \
    \            oddCount += count;\n                map.put(i, count + 1);\n    \
    \            if(count % 2 != 0) {\n                    evenCount += count;\n \
    \               }\n            }\n        }\n        \n        return new Pair(evenCount,\
    \ oddCount);", "        final int evenSum = 0;\n        final int oddSum = 0;\n\
    \        long start = System.currentTimeMillis();\n        if (n <= 1) {\n   \
    \         return Pair.of(1, 1);\n        }\n        Pair<Integer, Integer> pair\
    \ = evenOddPalindrome(n);\n        long end = System.currentTimeMillis();\n  \
    \      System.out.println(\"Time taken for even odd palindromes \" + end + \"\
    \ start \" + (start - end));\n        return pair;", "        if (n == 0) {\n\
    \            return null;\n        } else if (n == 1) {\n            return Pair.of(new\
    \ Integer(0), new Integer(1));\n        }\n\n        // Find all odd palindrome\
    \ palindromes\n        // start from 1 to n, check whether they are odd.\n   \
    \     // If they are odd, add it to evenPalindromes.\n        // If they are even,\
    \ remove them from evenPalindromes.\n        Map<Integer, Integer> oddPalindromes\
    \ = new HashMap<>();\n        int k = 0, p = 1;\n        for (int i = 1; i <=\
    \ n; i++) {\n            for (int j = 1; j < n; j++) {\n                Pair<Integer,\
    \ Integer> temp = getPair(i, j);\n                int even = temp.k();\n     \
    \           int odd = temp.d();\n                if ((even % 2 == 1) && (odd %\
    \ 2 == 0)) {\n                    oddPalindromes.put(new Integer(even), new Integer(odd));\n\
    \                    k++;\n                } else if ((even % 2 == 0) && (odd\
    \ % 2 == 1)) {\n                    oddPalindromes.remove(new Integer(odd));\n\
    \                    p++;\n                }\n            }\n        }\n\n   \
    \     // Find all even palindrome palindromes\n        // start from 1 to n, check\
    \ whether they are even.\n        // If they are even, add them to evenPalindromes.\n\
    \        // If they are odd, remove them from evenPalindromes.\n        int evenPalindromes\
    \ = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j\
    \ < n; j++) {\n                Pair<Integer, Integer> temp = getPair(i, j);\n\
    \                int even = temp.k();\n                int odd = temp.d();\n \
    \               if ((even % 2 == 0) && (odd % 2 == 0)) {\n                   \
    \ evenPalindromes++;\n                } else if ((even % 2 == 1) && (odd % 2 ==\
    \ 1)) {\n                    evenPalindromes--;\n                }\n         \
    \   }\n        }\n\n        // Return the number of even and odd palindromes.\n\
    \        return Pair.of(evenPalindromes, oddPalindromes);", "        int even\
    \ = 0;\n        int odd = 0;\n        for(int i = 1; i < n; i++){\n          \
    \  if(isPalindrome(i)){\n                if(i % 2 == 0){\n                   \
    \ even++;\n                } else {\n                    odd++;\n            \
    \    }\n            }\n        }\n        return new Pair<>(even, odd);", "  \
    \      ArrayList<Integer> evens = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ odds = new ArrayList<Integer>();\n        for (int i = 1; i <= n; i++) {\n \
    \           String str = Integer.toString(i);\n            reverse(str);\n   \
    \         int oddNum = Integer.parseInt(str);\n            if (isOdd(oddNum))\
    \ {\n                odds.add(oddNum);\n            } else {\n               \
    \ evens.add(oddNum);\n            }\n        }\n\n        return Pair.of(evens.size(),\
    \ odds.size());", "        Pair<Integer, Integer> evenOdd = null;\n        for(int\
    \ i = 1; i <= n; i++) {\n            for(int j = 1; j <= n; j++) {\n         \
    \       for(int k = 1; k <= n; k++) {\n                    if(i == j || j == k\
    \ || i == k) {\n                        continue;\n                    }\n   \
    \                 if(i == j || j == i || k == i) {\n                        continue;\n\
    \                    }\n                    if(i == j && j == k && k == i) {\n\
    \                        continue;\n                    }\n                  \
    \  if(i == j && j == i && i == k) {\n                        continue;\n     \
    \               }\n                    if(i == k && k == i && i == j) {\n    \
    \                    continue;\n                    }\n                    if(i\
    \ == j && j == k && k == i) {\n                        continue;\n           \
    \         }\n                    if(i == j && i == k && i == j) {\n          \
    \              continue;\n                    }\n                    if(i == k\
    \ && i == j && i == k) {\n                        continue;\n                \
    \    }\n                    if(i == j && i == k && i == j) {\n               \
    \         continue;\n                    }\n                    if(i == j && j\
    \ == k && k == i) {\n                        continue;\n                    }\n\
    \                    if(i == k && k == i && i == j) {\n                      \
    \  continue;\n                    }\n                    if(i == j && j == k &&\
    \ k == i) {\n                        continue;\n                    }\n      \
    \              if(i == k && k == i && i == j) {\n                        continue;\n\
    \                    }\n                    if(i == j && i == k && i == j) {\n\
    \                        continue;\n                    }\n                  \
    \  if(i == k && i == j && i == k) {\n                        continue;\n     \
    \               }\n                    if(i == j && i == k && i == j) {\n    \
    \                    continue;\n                    }\n                    if(i\
    \ == k && i == j && i == k) {\n                        continue;\n           \
    \         }\n                    if(i == j && j == k && k == i) {\n          \
    \              continue;\n                    }\n                    if(i == k\
    \ && k == i && i == j) {\n                        continue;\n                \
    \    }\n                    if(i == j && j == k && k == i) {\n               \
    \         continue;\n                    }\n                    if(i == k && k\
    \ == i && i == j) {\n                        continue;\n                    }\n\
    \                    if(i == j && j == k && k == i) {\n                      \
    \  continue;\n                    }\n                    if(i == k && k == i &&\
    \ i == j) {\n                        continue;\n                    }\n      \
    \              if(i == j && i == k && i == j) {\n                        continue;\n\
    \                    }\n                    if(i == k && i == j && i == k) {\n\
    \                        continue;\n                    }\n                  \
    \  if(i == j && i == k && i == j) {\n                        continue;\n     \
    \               }\n                    ", "        boolean evenOdd = false;\n\
    \        int palindrome = 0;\n        int low = 1;\n        int high = n - 1;\n\
    \        int even = 0;\n        int odd = 0;\n        while (low <= high) {\n\
    \            if (low * low == high * high) {\n                palindrome++;\n\
    \            } else if (low * low > high * high) {\n                break;\n \
    \           } else {\n                evenOdd = true;\n                low++;\n\
    \                high--;\n            }\n        }\n        if (evenOdd) {\n \
    \           even = n;\n            odd = palindrome - even;\n        }\n     \
    \   return Pair.of((even), odd);", "        List<Integer> list = new ArrayList<>(n);\n\
    \        for (int i = 0; i < n; i++)\n            list.add(i);\n\n        Set<Integer>\
    \ even = new HashSet<>();\n        Set<Integer> odd = new HashSet<>();\n\n   \
    \     Collections.sort(list);\n\n        Collections.sort(list);\n\n        for\
    \ (int i = 0; i < list.size() - 1; i++) {\n            int element = list.get(i);\n\
    \n            if (element % 2 == 0) {\n                even.add(element);\n  \
    \          } else {\n                odd.add(element);\n            }\n      \
    \  }\n        oddCount = odd.size();\n        evenCount = even.size();\n\n   \
    \     Pair<Integer, Integer> evenOddPalindrome = new Pair<>(evenCount, oddCount);\n\
    \n        return evenOddPalindrome;", "        List<Integer> even = new ArrayList<Integer>();\n\
    \        List<Integer> odd = new ArrayList<Integer>();\n        for (int i = 1;\
    \ i <= n; i++) {\n            if (isPalindrome(i)) {\n                int evenPalisod\
    \ = Pair.sum(evenPalisod(i));\n                int oddPalisod = Pair.sum(oddPalisod(i));\n\
    \                even.add(evenPalisod);\n                odd.add(oddPalisod);\n\
    \            }\n        }\n        return new Pair<Integer, Integer>(Pair.sum(even),\
    \ Pair.sum(odd));", "        Set<Integer> set = new HashSet<Integer>();\n    \
    \    List<Integer> oddPalindrome = new ArrayList<Integer>();\n        List<Integer>\
    \ evenPalindrome = new ArrayList<Integer>();\n\n        int counter = 0;\n   \
    \     int odd = 0, even = 0;\n\n        for (int i = 1; i <= n; i++) {\n     \
    \       if (isPalindrome(i)) {\n                oddPalindrome.add(i);\n      \
    \          evenPalindrome.add(i + 1);\n                set.add(i);\n         \
    \   } else {\n                if (set.contains(i)) {\n                    even++;\n\
    \                } else {\n                    odd++;\n                }\n   \
    \         }\n        }\n\n        Pair<Integer, Integer> evenPalindromePair =\
    \ Pair.ofEvenOdd(even, odd);\n        return new Pair<>(evenPalindromePair, oddPalindrome);",
  "        int[] palindrome = new int[n + 1];\n        int even = 0, odd = 0;\n  \
    \      Arrays.fill(palindrome, 0);\n        int m = (n + 1) / 2;\n        int\
    \ k = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1;\
    \ j <= m; j++) {\n                if (isPalindrome(i, j)) {\n                \
    \    palindrome[k++] = j;\n                    if (isEven(i, j)) {\n         \
    \               even++;\n                    }\n                    if (isOdd(i,\
    \ j)) {\n                        odd++;\n                    }\n             \
    \   }\n            }\n        }\n        return Pair.create(even, odd);", "  \
    \      if (n < 1) {\n            return null;\n        }\n        Set<Integer>\
    \ palindrome = new HashSet<>();\n        int odd = 0, even = 0;\n        for (int\
    \ i = 1; i <= n; i++) {\n            String str = Integer.toString(i);\n     \
    \       String reverse = new StringBuilder(str).reverse().toString();\n      \
    \      if (palindrome.contains(str)) {\n                odd++;\n            }\n\
    \            else {\n                even++;\n            }\n            if (palindrome.contains(reverse))\
    \ {\n                odd++;\n            }\n            else {\n             \
    \   even++;\n            }\n            palindrome.add(str);\n            palindrome.add(reverse);\n\
    \        }\n        return new ImmutablePair<>(even, odd);", "        Set<Integer>\
    \ even = new HashSet<>();\n        Set<Integer> odd = new HashSet<>();\n     \
    \   for(int i = 1; i < n; i++) {\n            int palindrome = reverse(i);\n \
    \           if (isPalindrome(palindrome)) {\n                if (isEven(palindrome))\
    \ {\n                    even.add(palindrome);\n                } else {\n   \
    \                 odd.add(palindrome);\n                }\n            }\n   \
    \     }\n        return new Pair<>(even.cardinality(), odd.cardinality());", " \
    \       int evenPalindrome = 0;\n        int oddPalindrome = 0;\n        if (n\
    \ == 1) {\n            return new Pair<Integer, Integer>(1, 1);\n        } else\
    \ if (n == 2) {\n            return new Pair<Integer, Integer>(1, 1);\n      \
    \  } else if (n == 3 || n == 4 || n == 5) {\n            return new Pair<Integer,\
    \ Integer>(1, 1);\n        } else if (n == 6 || n == 7 || n == 8) {\n        \
    \    return new Pair<Integer, Integer>(2, 1);\n        } else if (n == 9 ||  n\
    \ == 10 || n == 11) {\n            return new Pair<Integer, Integer>(3, 2);\n\
    \        } else if (n == 12) {\n            return new Pair<Integer, Integer>(4,\
    \ 6);\n        }\n        int palindrome = 0;\n        for (int i = 1; i < n;\
    \ i++) {\n            for (int j = n; j > i; j--) {\n                int temp\
    \ = j;\n                while (temp % 10 == 0 && temp != 0) {\n              \
    \      temp = temp / 10;\n                }\n                if (j == temp) {\n\
    \                    palindrome++;\n                }\n            }\n       \
    \ }\n        if ((n % 2 == 0) && n == palindrome) {\n            evenPalindrome++;\n\
    \        }\n        if ((n % 2 != 0) && n == palindrome) {\n            oddPalindrome++;\n\
    \        }\n        return new Pair<Integer, Integer>(evenPalindrome, oddPalindrome);",
  "        Pair<Integer, Integer> p = new Pair<>(0,0);\n        for(int i=1; i<=n;\
    \ i++){\n            String str = Integer.toString(i);\n            int len =\
    \ str.length();\n            for(int j=0;j<len/2;j++){\n                if(str.charAt(j)\
    \ != str.charAt(len-j-1)){\n                    break;\n                }\n  \
    \          }\n            if(j==len/2){\n                int x = str.charAt(len-j-1);\n\
    \                if((x % 2) == 0){\n                    p.left++;\n          \
    \      }\n                else {\n                    p.right++;\n           \
    \     }\n            }\n        }\n        return p;", "        List<Integer>\
    \ even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n\
    \        for(int i=1; i <= n; i++) {\n            if((i-1) % 2 == 0) {\n     \
    \           even.add(i);\n            } else {\n                odd.add(i);\n\
    \            }\n        }\n        List<Integer> evenPalindromes = even.stream()\n\
    \                                            .filter(x -> x == reverse(x))\n \
    \                                           .collect(Collectors.toList());\n \
    \       List<Integer> oddPalindromes = odd.stream()\n                        \
    \                    .filter(x -> x == reverse(x))\n                         \
    \                   .collect(Collectors.toList());\n\n        Pair<Integer, Integer>\
    \ ret = new Pair<>();\n        ret.first = evenPalindromes.size();\n        ret.second\
    \ = oddPalindromes.size();\n        return ret;", "        // O(1) time and space\n\
    \        Pair<Integer, Integer> pair = new Pair<>(0, 0);\n        \n        for\
    \ (int i = 1; i <= n; i++) {\n            String str = new StringBuilder(String.valueOf(i)).reverse().toString();\n\
    \            boolean isEven = true;\n            boolean isOdd = true;\n     \
    \       int count = 0;\n            for (int j = 0; j < str.length(); j++) {\n\
    \                if (str.charAt(j) != str.charAt(str.length() - 1 - j)) {\n  \
    \                  isOdd = false;\n                }\n                if (isEven)\
    \ {\n                    if (str.charAt(j) == str.charAt(str.length() - 1 - j))\
    \ {\n                        count++;\n                    }\n               \
    \ } else {\n                    if (str.charAt(j) != str.charAt(str.length() -\
    \ 1 - j)) {\n                        isEven = false;\n                    }\n\
    \                    if (isEven) {\n                        if (str.charAt(j)\
    \ == str.charAt(str.length() - 1 - j)) {\n                            count++;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            if (isEven && isOdd) {\n                pair.first++;\n \
    \           } else if (isOdd && isEven) {\n                pair.second++;\n  \
    \          } else {\n                break;\n            }\n        }\n      \
    \  return pair;", "        int even = 0;\n        int odd = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            int reverse = Integer.valueOf(i).reverse().intValue();\n\
    \            if ((int)i%2 == 0) {\n                if (reverse == i) {\n     \
    \               even++;\n                }\n            } else {\n           \
    \     if (reverse == i) {\n                    odd++;\n                }\n   \
    \         }\n        }\n        return Pair.of(even, odd);", '        return evenOddPalindrome(n,
    0);', "        int even = 0;\n        int odd = 0;\n        for (int i = 1; i\
    \ <= n; i++) {\n            // If the number is even\n            if (i % 2 ==\
    \ 0) {\n                even++;\n            }\n            // If the number is\
    \ odd\n            else if (i % 2 != 0) {\n                odd++;\n          \
    \  }\n        }\n        return Pair.of(even, odd);", "        // write your code\
    \ here\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(1,\
    \ 1);\n        map.put(2, 1);\n        map.put(3, 1);\n        map.put(4, 1);\n\
    \        map.put(5, 1);\n        map.put(6, 1);\n        map.put(7, 1);\n    \
    \    map.put(8, 1);\n        map.put(9, 1);\n        map.put(10, 1);\n       \
    \ map.put(11, 1);\n\n        map.put(1, 2);\n        map.put(2, 2);\n        map.put(3,\
    \ 2);\n        map.put(4, 2);\n        map.put(5, 2);\n        map.put(6, 2);\n\
    \        map.put(7, 2);\n        map.put(8, 2);\n        map.put(9, 2);\n    \
    \    map.put(10, 2);\n        map.put(11, 2);\n\n        map.put(1, 3);\n    \
    \    map.put(2, 3);\n        map.put(3, 3);\n        map.put(4, 3);\n        map.put(5,\
    \ 3);\n        map.put(6, 3);\n        map.put(7, 3);\n        map.put(8, 3);\n\
    \        map.put(9, 3);\n        map.put(10, 3);\n        map.put(11, 3);\n\n\
    \        map.put(1, 4);\n        map.put(2, 4);\n        map.put(3, 4);\n    \
    \    map.put(4, 4);\n        map.put(5, 4);\n        map.put(6, 4);\n        map.put(7,\
    \ 4);\n        map.put(8, 4);\n        map.put(9, 4);\n        map.put(10, 4);\n\
    \        map.put(11, 4);\n\n        map.put(1, 5);\n        map.put(2, 5);\n \
    \       map.put(3, 5);\n        map.put(4, 5);\n        map.put(5, 5);\n     \
    \   map.put(6, 5);\n        map.put(7, 5);\n        map.put(8, 5);\n        map.put(9,\
    \ 5);\n        map.put(10, 5);\n        map.put(11, 5);\n\n        map.put(1,\
    \ 6);\n        map.put(2, 6);\n        map.put(3, 6);\n        map.put(4, 6);\n\
    \        map.put(5, 6);\n        map.put(6, 6);\n        map.put(7, 6);\n    \
    \    map.put(8, 6);\n        map.put(9, 6);\n        map.put(10, 6);\n       \
    \ map.put(11, 6);\n\n        map.put(1, 7);\n        map.put(2, 7);\n        map.put(3,\
    \ 7);\n        map.put(4, 7);\n        map.put(5, 7);\n        map.put(6, 7);\n\
    \        map.put(7, 7);\n        map.put(8, 7);\n        map.put(9, 7);\n    \
    \    map.put(10, 7);\n        map.put(11, 7);\n\n        map.put(1, 8);\n    \
    \    map.put(2, 8);\n        map.put(3, 8);\n        map.put(4, 8);\n        map.put(5,\
    \ 8);\n        map.put(6, ", "        if (n <= 0) {\n            return null;\n\
    \        }\n        List<Integer> evenList = new ArrayList<>();\n        List<Integer>\
    \ oddList = new ArrayList<>();\n\n        for (int i = 1; i <= n; i++) {\n   \
    \         // Check even\n            if (isPalindrome(String.valueOf(i), true))\
    \ {\n                evenList.add(String.valueOf(i));\n            } else {\n\
    \                oddList.add(String.valueOf(i));\n            }\n\n          \
    \  // Check odd\n            if (isPalindrome(String.valueOf(i), false)) {\n \
    \               oddList.add(String.valueOf(i));\n            } else {\n      \
    \          evenList.add(String.valueOf(i));\n            }\n        }\n      \
    \  return new Pair<>(evenList.size(), oddList.size());", "        Pair<Integer,\
    \ Integer> results = new Pair<>();\n        if (n == 1) {\n            results.first\
    \ = 1;\n            results.second = 1;\n            return results;\n       \
    \ }\n        Pair<Integer, Integer> even = new Pair<>();\n        Pair<Integer,\
    \ Integer> odd = new Pair<>();\n        for (int i = 1; i <= n; ++i) {\n     \
    \       if (isEven(i)) {\n                even.first++;\n            } else {\n\
    \                odd.first++;\n            }\n        }\n        if (even.first\
    \ > odd.first) {\n            even.second++;\n        } else if (odd.first > even.first)\
    \ {\n            odd.second++;\n        }\n        results.first = even.first;\n\
    \        results.second = odd.first;\n        return results;", "        Pair<Integer,\
    \ Integer> evenPalindrome = new Pair<>();\n        Pair<Integer, Integer> oddPalindrome\
    \ = new Pair<>();\n        for (int i = 1; i <= n; i++) {\n            String\
    \ result = new StringBuilder(String.valueOf(i)).reverse().toString();\n      \
    \      String evenResult = new StringBuilder(String.valueOf(i)).reverse().toString();\n\
    \            String oddResult = new StringBuilder(String.valueOf(i)).reverse().toString();\n\
    \            if (evenResult.equals(result)) {\n                evenPalindrome.setKey(evenPalindrome.getKey()\
    \ + 1);\n            }\n            if (oddResult.equals(result)) {\n        \
    \        oddPalindrome.setKey(oddPalindrome.getKey() + 1);\n            }\n  \
    \      }\n        return evenPalindrome;", "        Stack<Integer> even = new\
    \ Stack<>();\n        Stack<Integer> odd = new Stack<>();\n\n        // push the\
    \ even numbers first\n        while (n != 0) {\n            if (n % 2 == 0) {\n\
    \                even.push(n);\n            } else {\n                odd.push(n);\n\
    \            }\n            n /= 2;\n        }\n\n        // push odd numbers\
    \ next\n        while (odd.size() != 0) {\n            n = odd.pop();\n      \
    \      if (n != 0) {\n                odd.push(n);\n            }\n        }\n\
    \n        // return even and odd numbers\n        Pair<Integer, Integer> result\
    \ = new Pair<>(0, 0);\n        for (Integer n : even) {\n            if (even.size()\
    \ == odd.size()) {\n                break;\n            } else {\n           \
    \     if (even.size() != odd.size()) {\n                    result = new Pair<>(result.first(),\
    \ result.second());\n                    break;\n                } else {\n  \
    \                  int x = even.pop();\n                    if (odd.isEmpty())\
    \ {\n                        result.first = x;\n                        result.second\
    \ = 0;\n                        break;\n                    }\n              \
    \      int y = odd.pop();\n                    if (x % 2 == y % 2) {\n       \
    \                 result.first = result.first() + 1;\n                       \
    \ result.second = result.second + 1;\n                    } else {\n         \
    \               result.first = result.first() + 2;\n                        result.second\
    \ = result.second + 1;\n                    }\n                }\n           \
    \ }\n        }\n\n        return result;", '        return evenOddPalindrome(0,
    n);', "        Pair<Integer, Integer> pairEvenOdd = null;\n        if (n <= 0)\
    \ {\n            return null;\n        }\n        ArrayList<Integer> list = new\
    \ ArrayList<Integer>();\n        boolean even = true;\n        int count = 0;\n\
    \        int evenCount = 0;\n        int oddCount = 0;\n        for (int i = 1;\
    \ i <= n; i++) {\n            list.add(new Integer(i));\n        }\n        for\
    \ (int j = 0; j < list.size(); j++) {\n            int value = list.get(j);\n\
    \            while (value > 1) {\n                if (value % 2 == 0 && even)\
    \ {\n                    count++;\n                    evenCount++;\n        \
    \        }\n                if (value % 2 != 0 && odd) {\n                   \
    \ count++;\n                    oddCount++;\n                }\n             \
    \   value /= 2;\n            }\n        }\n        if (evenCount > oddCount) {\n\
    \            pairEvenOdd = new Pair<>(evenCount, oddCount);\n        } else {\n\
    \            pairEvenOdd = new Pair<>(oddCount, evenCount);\n        }\n     \
    \   return pairEvenOdd;", "        List<Integer> evenPalindrome = new ArrayList<>();\n\
    \        List<Integer> oddPalindrome = new ArrayList<>();\n        if (n == 1)\
    \ {\n            evenPalindrome.add(1);\n            oddPalindrome.add(0);\n \
    \       }\n        if (n >= 2) {\n            evenPalindrome.add(2);\n       \
    \     oddPalindrome.add(1);\n        }\n        if (n >= 3) {\n            evenPalindrome.add(3);\n\
    \            oddPalindrome.add(2);\n        }\n        if (n >= 4) {\n       \
    \     evenPalindrome.add(4);\n            oddPalindrome.add(3);\n        }\n \
    \       if (n >= 5) {\n            evenPalindrome.add(5);\n            oddPalindrome.add(4);\n\
    \        }\n        if (n >= 6) {\n            evenPalindrome.add(6);\n      \
    \      oddPalindrome.add(5);\n        }\n        if (n >= 7) {\n            evenPalindrome.add(7);\n\
    \            oddPalindrome.add(6);\n        }\n        if (n >= 8) {\n       \
    \     evenPalindrome.add(8);\n            oddPalindrome.add(7);\n        }\n \
    \       if (n >= 9) {\n            evenPalindrome.add(9);\n            oddPalindrome.add(8);\n\
    \        }\n        if (n >= 10) {\n            evenPalindrome.add(10);\n    \
    \        oddPalindrome.add(9);\n        }\n        if (n >= 11) {\n          \
    \  evenPalindrome.add(11);\n            oddPalindrome.add(10);\n        }\n  \
    \      return new Pair<>(evenPalindrome.size(), oddPalindrome.size());", "   \
    \     double odd = 0;\n        double even = 0;\n        for(int i = 1; i <= n;\
    \ i++) {\n            double a = Math.log(i);\n            double b = Math.log(i\
    \ * i);\n            double c = Math.log(i * i * i);\n            if(((a * b)\
    \ < (c + 1))) {\n                even++;\n            } else {\n             \
    \   odd++;\n            }\n        }\n        return new ImmutablePair<>(even,\
    \ odd);", "        Pair<Integer, Integer> evenAndOdd = null;\n        if (n ==\
    \ 0) {\n            evenAndOdd = new Pair<>(0,0);\n        }\n        else if\
    \ (n == 1) {\n            evenAndOdd = new Pair<>(1,1);\n        }\n        else\
    \ {\n            Pair<Integer, Integer> oddAndEven = new Pair<>();\n         \
    \   oddAndEven.first = oddAndEven.second = oddAndEven.third = 0;\n           \
    \ evenAndOdd.third = evenAndOdd.second = evenAndOdd.first = 0;\n            int\
    \ middle = (n-1)/2;\n            boolean first = true;\n            boolean last\
    \ = false;\n            for (int i=1; i<=n; i++) {\n                Pair<Integer,\
    \ Integer> oddAndEven = oddAndEvenEven(i, middle, first);\n                first\
    \ = false;\n                middle = middle/2;\n                last = middle\
    \ == 0;\n                evenAndOdd.third = evenAndOdd.second + oddAndEven.third;\n\
    \                evenAndOdd.second = evenAndOdd.first + oddAndEven.second;\n \
    \               evenAndOdd.first = evenAndOdd.third + oddAndEven.first;\n    \
    \        }\n        }\n        return evenAndOdd;", "        List<Integer> evenPalindromes\
    \ = new ArrayList<>();\n        List<Integer> oddPalindromes = new ArrayList<>();\n\
    \        // TODO: Write your code here\n        for(int i = 1; i <= n; i++){\n\
    \            int start = 0;\n            int end = i;\n            while(start\
    \ < end){\n                if(isPalindrome(start, end)){\n                   \
    \ evenPalindromes.add(start);\n                    oddPalindromes.add(end - 1);\n\
    \                    start = end + 1;\n                }\n                else{\n\
    \                    start = end + 1;\n                }\n                end\
    \ += 1;\n            }\n        }\n        if(evenPalindromes.size() == 0 && oddPalindromes.size()\
    \ == 0){\n            return new Pair<Integer, Integer>(0, 0);\n        }\n  \
    \      if(evenPalindromes.size() == 0){\n            return new Pair<Integer,\
    \ Integer>(1, oddPalindromes.size());\n        }\n        if(oddPalindromes.size()\
    \ == 0){\n            return new Pair<Integer, Integer>(evenPalindromes.size(),\
    \ 1);\n        }\n        if(evenPalindromes.size() > 0 && oddPalindromes.size()\
    \ > 0){\n            return new Pair<Integer, Integer>(evenPalindromes.size(),\
    \ oddPalindromes.size());\n        }\n        if(evenPalindromes.size() > 0){\n\
    \            return new Pair<Integer, Integer>(evenPalindromes.size(), oddPalindromes.size());\n\
    \        }\n        if(oddPalindromes.size() > 0){\n            return new Pair<Integer,\
    \ Integer>(evenPalindromes.size(), oddPalindromes.size());\n        }\n      \
    \  return new Pair<Integer, Integer>(0, 0);", "        int even = 0, odd = 0,\
    \ evenPalindrome = 0, oddPalindrome = 0;\n        for(int i = 1; i <=n; i++){\n\
    \            int currentPalindrome = n;\n            int length = currentPalindrome;\n\
    \            while (length >= 1) {\n                int remainder = length%10;\n\
    \                currentPalindrome /= 10;\n                length--;\n       \
    \         if (remainder == 0) {\n                    if (currentPalindrome ==\
    \ 0) {\n                        evenPalindrome++;\n                    } else\
    \ {\n                        oddPalindrome++;\n                    }\n       \
    \         }\n            }\n            if (currentPalindrome == 0) {\n      \
    \          even++;\n            } else {\n                odd++;\n           \
    \ }\n        }\n        return new Pair<>(even, odd);", "        final List<Integer>\
    \ evenPalindromes = new ArrayList<>();\n        final List<Integer> oddPalindromes\
    \ = new ArrayList<>();\n        final int low = 1;\n        final int high = n;\n\
    \        while (low < high) {\n            final int mid = low + (high - low)\
    \ / 2;\n            final Pair<Integer, Integer> evenPalindrome = evenPalindromeHelper(mid);\n\
    \            final Pair<Integer, Integer> oddPalindrome = oddPalindromeHelper(mid);\n\
    \            if (evenPalindrome != null && oddPalindrome != null) {\n        \
    \        evenPalindromes.add(evenPalindrome.first);\n                oddPalindromes.add(oddPalindrome.first);\n\
    \            } else if (evenPalindrome != null) {\n                evenPalindromes.add(evenPalindrome.first);\n\
    \            } else if (oddPalindrome != null) {\n                oddPalindromes.add(oddPalindrome.first);\n\
    \            }\n            if (evenPalindromes.size() > n / 2) {\n          \
    \      return Pair.of(evenPalindromes.size(), oddPalindromes.size());\n      \
    \      }\n            low = mid;\n            high = mid;\n        }\n       \
    \ return Pair.of(evenPalindromes.size(), oddPalindromes.size());", "        int[]\
    \ even = new int[n];\n        int[] odd = new int[n];\n        Arrays.fill(even,\
    \ 1);\n        Arrays.fill(odd, 0);\n\n        int evenCount = 0;\n        int\
    \ oddCount = 0;\n\n        for (int i = 1; i < n; i++) {\n            if (isEven(i))\
    \ {\n                even[i - 1] += 1;\n                evenCount += 1;\n    \
    \        }\n            if (isOdd(i)) {\n                odd[i - 1] += 1;\n  \
    \              oddCount += 1;\n            }\n        }\n\n        if (n <= 0)\
    \ {\n            return null;\n        }\n\n        Pair<Integer, Integer> tuple\
    \ = new Pair<>(evenCount, oddCount);\n\n        return tuple;", "        int m\
    \ = 1; // odd numbers greater than 1\n        int n = 2; // even numbers greater\
    \ than 1\n        List<Integer> odd = new ArrayList<>();\n        List<Integer>\
    \ even = new ArrayList<>();\n        int[] arr = new int[1000];\n        int count\
    \ = 0;\n        for (int i = 1; i < n; i++) {\n            if (n % 2 == 0) {\n\
    \                even.add(i);\n            } else {\n                odd.add(i);\n\
    \            }\n        }\n        int odd_size = odd.size();\n        int even_size\
    \ =  even.size();\n        if (odd_size < even_size || odd_size == 0 || even_size\
    \ == 0) {\n            throw new IllegalArgumentException(\"Invalid Input\");\n\
    \        }\n        for (int i = odd_size; i >= 0; i--) {\n            for (int\
    \ j = even_size; j >= 0; j--) {\n                if (odd.get(i) != even.get(j))\
    \ {\n                    arr[count] = odd.get(i);\n                    odd.remove(odd.get(i));\n\
    \                    even.remove(even.get(j));\n                    count++;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     // now arr has odd numbers greater than 1 and even numbers greater than\
    \ 1\n        // and to calculate the palindrome we need the even numbers less\
    \ than or equal to the odd numbers less than or equal to the number n\n      \
    \  for (int i = odd_size; i <= n; i++) {\n            if (arr[i] % 2 == 1) {\n\
    \                even_size += arr[i] / 2;\n                even.add(arr[i] / 2);\n\
    \            } else if (arr[i] % 2 == 0) {\n                odd_size += arr[i]\
    \ / 2;\n                odd.add(arr[i] / 2);\n            }\n        }\n     \
    \   return new Pair<>(odd_size, even_size);", "        if (n == 1) {\n       \
    \     return Pair.of(1, 1);\n        }\n\n        if (n % 2 == 0) {\n        \
    \    return evenOddPalindrome(n/2);\n        }\n\n        return Pair.of(n, evenOddPalindrome(n/2));",
  "        final int LIMIT = n + 1;\n        final int EVEN = 1;\n        final int\
    \ ODD = -1;\n        Pair<Integer, Integer> even = new Pair<>(EVEN, 0);\n    \
    \    Pair<Integer, Integer> odd = new Pair<>(ODD, 0);\n        \n        ArrayList\
    \ palindromes = new ArrayList();\n        \n        if (n <= 0) {\n          \
    \  throw new RuntimeException(\"Invalid positive n\");\n        }\n        \n\
    \        // check even palindromes\n        for (int i = 1; i < LIMIT; i++) {\n\
    \            String palindrome = Integer.toString(i);\n            \n        \
    \    if (palindrome.length() == 1) {\n                palindromes.add(palindrome);\n\
    \            }\n            \n            if (palindrome.length() > 1) {\n   \
    \             for (int j = palindrome.length() - 1; j >= 0; j--) {\n         \
    \           if (palindrome.charAt(j) != palindrome.charAt(j + 1)) {\n        \
    \                palindromes.add(palindrome);\n                        break;\n\
    \                    }\n                }\n            }\n        }\n        \n\
    \        // check odd palindromes\n        for (int i = 1; i <= LIMIT; i++) {\n\
    \            String palindrome = Integer.toString(i);\n            \n        \
    \    if (palindrome.length() == 1) {\n                palindromes.add(palindrome);\n\
    \            }\n            \n            if (palindrome.length() > 1) {\n   \
    \             for (int j = palindrome.length() - 1; j >= 0; j--) {\n         \
    \           if (palindrome.charAt(j) != palindrome.charAt(j + 1)) {\n        \
    \                palindromes.add(palindrome);\n                        break;\n\
    \                    }\n                }\n            }\n        }\n        \n\
    \        even = even.merge(palindromes.stream().map(String::valueOf).filter(s\
    \ -> s.charAt(0) == s.charAt(s.length() - 1)).collect(Collectors.toMap(s -> s,\
    \ s -> 1)));\n        odd = odd.merge(palindromes.stream().map(String::valueOf).filter(s\
    \ -> s.charAt(0) == s.charAt(s.length() - 1)).collect(Collectors.toMap(s -> s,\
    \ s -> -1)));\n        return even.merge(odd);", "        Pair<Integer, Integer>\
    \ result = new Pair<Integer, Integer>();\n        for (int i = 1; i < n; i++)\
    \ {\n            for (int j = i; j < n; j++) {\n                boolean isEven\
    \ = true;\n                boolean isOdd = true;\n                int odd = 1;\n\
    \                int even = 1;\n                for (int k = i; k < j; k++) {\n\
    \                    if (j % 2 != 0 && i % 2 != 0) {\n                       \
    \ isEven = false;\n                        break;\n                    }\n   \
    \                 else {\n                        isOdd = false;\n           \
    \             odd += 1;\n                    }\n                }\n          \
    \      if (odd <= j / 2) {\n                    isEven = false;\n            \
    \        odd += 1;\n                }\n                if (even <= j / 2) {\n\
    \                    isOdd = false;\n                    even += 1;\n        \
    \        }\n                if (isEven && isOdd) {\n                    result.first\
    \ = even;\n                    result.second = odd;\n                    return\
    \ result;\n                }\n            }\n        }\n        return result;",
  "        Pair even = new Pair<>(0, 0);\n        Pair odd = new Pair<>(0, 0);\n \
    \       int evenCounter = 0;\n        int oddCounter = 0;\n        int i = (n\
    \ <= 0) ? 0 : (int) ((Math.log(n) / Math.log(2) + 1)); // n is power of 2\n  \
    \      for (int j = 0; j <= i; j++) {\n            // odd number\n           \
    \ if (j & 1 == 1) {\n                int temp = (int) ((Math.pow(j / 2, 2) - Math.pow((j\
    \ / 2) - 1, 2)) + 1);\n                if (temp == j) {\n                    evenCounter++;\n\
    \                } else {\n                    odd.first++;\n                \
    \    odd.second++;\n                }\n            } else {\n                int\
    \ temp = (int) ((Math.pow(j / 2, 2) - Math.pow(j / 2 - 1, 2)) + 1);\n        \
    \        if (temp == j) {\n                    evenCounter++;\n              \
    \  } else {\n                    even.first++;\n                    even.second++;\n\
    \                }\n            }\n        }\n        // odd palindrome number\n\
    \        for (int k = 0; k < i; k++) {\n            if (k & 1 == 1) {\n      \
    \          int temp = (int) ((Math.pow(k / 2, 2) - Math.pow((k / 2) - 1, 2)) +\
    \ 1);\n                if (temp == k) {\n                    oddCounter++;\n \
    \               } else {\n                    odd.first++;\n                 \
    \   odd.second++;\n                }\n            } else {\n                int\
    \ temp = (int) ((Math.pow(k / 2, 2) - Math.pow(k / 2 - 1, 2)) + 1);\n        \
    \        if (temp == k) {\n                    oddCounter++;\n               \
    \ } else {\n                    odd.first++;\n                    odd.second++;\n\
    \                }\n            }\n        }\n        even.first += evenCounter;\n\
    \        even.second += evenCounter;\n        odd.first += oddCounter;\n     \
    \   odd.second += oddCounter;\n        return new Pair<>(even.first, even.second);",
  "        int evenCounter = 0;\n        int oddCounter = 0;\n        \n        for\
    \ (int i = 1; i <= n; i++) {\n            String evenPalindrome = evenPalindrome(i);\n\
    \            String oddPalindrome = oddPalindrome(i);\n            if (evenPalindrome.length()\
    \ > oddPalindrome.length()) {\n                evenCounter++;\n            } else\
    \ {\n                oddCounter++;\n            }\n        }\n        return Pair.of((int)evenCounter,\
    \ (int)oddCounter);", "        Set<Integer> even = new HashSet<>();\n        Set<Integer>\
    \ odd = new HashSet<>();\n        for (int i = 1; i <= n; i++) {\n           \
    \ String str = Integer.toString(i);\n            String reverseStr = str.reverse().toString();\n\
    \            int len = str.length();\n            String evenStr = str.substring(0,\
    \ len - 1);\n            String oddStr = str.substring(len - 1);\n           \
    \ if (evenStr.equals(reverseStr) && evenStr.length() >= 2) {\n               \
    \ even.add(Integer.parseInt(evenStr));\n            }\n            if (oddStr.equals(reverseStr)\
    \ && oddStr.length() >= 2) {\n                odd.add(Integer.parseInt(oddStr));\n\
    \            }\n        }\n        return new Pair<>(even.stream().mapToInt(Integer::intValue).sum(),\
    \ odd.stream().mapToInt(Integer::intValue).sum());", "        int evenPalindrome\
    \ = 0;\n        int oddPalindrome = 0;\n\n        // Step 1: Calculate the number\
    \ of even palindrome\n        for (int i = 1; i <= n; i++) {\n            // Calculate\
    \ even palindrome\n            int evenPalindromeLeft = i;\n            int evenPalindromeRight\
    \ = i;\n            while (evenPalindromeRight > 0 && evenPalindromeLeft <= n)\
    \ {\n                evenPalindromeLeft = (evenPalindromeLeft + evenPalindromeRight\
    \ - 1) / 2;\n                evenPalindromeRight = (evenPalindromeLeft + evenPalindromeRight\
    \ + 1) / 2;\n            }\n            // Calculate odd palindrome\n        \
    \    int oddPalindromeLeft = i;\n            int oddPalindromeRight = i;\n   \
    \         while (oddPalindromeRight > 0 && oddPalindromeLeft <= n) {\n       \
    \         oddPalindromeLeft = (oddPalindromeLeft + oddPalindromeRight - 1) / 2;\n\
    \                oddPalindromeRight = (oddPalindromeLeft + oddPalindromeRight\
    \ + 1) / 2;\n            }\n\n            if (evenPalindromeLeft <= n) {\n   \
    \             evenPalindrome++;\n            }\n            if (evenPalindromeRight\
    \ <= n) {\n                evenPalindrome++;\n            }\n            if (oddPalindromeLeft\
    \ <= n) {\n                oddPalindrome++;\n            }\n            if (oddPalindromeRight\
    \ <= n) {\n                oddPalindrome++;\n            }\n        }\n\n    \
    \    // Step 2: Calculate the number of odd palindrome\n        for (int i = 1;\
    \ i <= n; i++) {\n            // Calculate even palindrome\n            int evenPalindromeLeft\
    \ = i;\n            int evenPalindromeRight = i;\n            while (evenPalindromeRight\
    \ > 0 && evenPalindromeLeft <= n) {\n                evenPalindromeLeft = (evenPalindromeLeft\
    \ + evenPalindromeRight - 1) / 2;\n                evenPalindromeRight = (evenPalindromeLeft\
    \ + evenPalindromeRight + 1) / 2;\n            }\n            // Calculate odd\
    \ palindrome\n            int oddPalindromeLeft = i;\n            int oddPalindromeRight\
    \ = i;\n            while (oddPalindromeRight > 0 && oddPalindromeLeft <= n) {\n\
    \                oddPalindromeLeft = (oddPalindromeLeft + oddPalindromeRight -\
    \ 1) / 2;\n                oddPalindro", "        if (n == 0) {\n            return\
    \ Pair.of(0, 0);\n        }\n        if (n <= 0) {\n            return null;\n\
    \        }\n        int evenCount = 0;\n        int oddCount = 0;\n        for\
    \ (int i = 1; i <= n; i++) {\n            String str = String.valueOf(i);\n  \
    \          String revStr = str.reverse();\n            if (str.equals(revStr))\
    \ {\n                evenCount++;\n            } else {\n                oddCount++;\n\
    \            }\n        }\n        return Pair.of(evenCount, oddCount);", "  \
    \      Pair<Integer, Integer> pair = new Pair<>(0,0);\n        if(n < 0 || n >\
    \ 10^3)\n            return pair;\n        for(int i = 1; i <= n; i++)\n     \
    \   {\n            int odd = 0, even = 0;\n            int odd_count = 0;\n  \
    \          for(int j = i; j < n; j++)\n            {\n                int current\
    \ = j;\n                while(current > 0 && current % 10 == 0)\n            \
    \    {\n                    current = current / 10;\n                    even++;\n\
    \                }\n                int remain = current % 10;\n             \
    \   if(remain != 0)\n                {\n                    odd += remain;\n \
    \                   odd_count++;\n                }\n            }\n         \
    \   if((odd_count % 2 == 1) && (even % 2 == 0))\n            {\n             \
    \   pair = Pair.of(odd, even);\n            }\n        }\n        return pair;",
  "        int even = 0;\n        int odd = 0;\n\n        if (n <= 0) {\n        \
    \    return Pair.of(even, odd);\n        }\n        if (n > 10) {\n          \
    \  return Pair.of(even, odd);\n        }\n        long start = System.currentTimeMillis();\n\
    \        Pair<Integer, Integer> palindromes = IntStream.rangeClosed(1, n)\n  \
    \              .filter(x -> x % 2 == 0)\n                .filter(x -> x % 2 !=\
    \ 0)\n                .map(x -> {\n                    String str = Long.toString(x);\n\
    \                    int oddPalindromes = str.length() / 2;\n                \
    \    int evenPalindromes = str.length() % 2;\n                    return Pair.of(evenPalindromes,\
    \ oddPalindromes);\n                }).reduce((x, y) -> Pair.of(x.get(0) - y.get(0),\
    \ x.get(1) - y.get(1)))\n                .map(x -> Pair.of(x, 1))\n          \
    \      .filter(x -> x.intValue() > 0 && x.intValue() < n)\n                .count();\n\
    \        Pair<Integer, Integer> evenOddPalindromes = Pair.of(even, palindromes.intValue());\n\
    \        Pair<Integer, Integer> result = Pair.of(evenOddPalindromes, palindromes);\n\
    \        System.out.println(String.format(\"evenOddPalindrome completed in %1$s\
    \ milliseconds. result is: %2$d, %2$d\", System.currentTimeMillis() - start, result.first(),\
    \ result.second()));\n        return result;", "        if (n <= 1) return null;\n\
    \        List<Integer> even = new ArrayList<Integer>();\n        List<Integer>\
    \ odd = new ArrayList<Integer>();\n        for (int i = 1; i <= n; i++) {\n  \
    \          if (i % 2 == 0) {\n                even.add(i);\n            } else\
    \ {\n                odd.add(i);\n            }\n        }\n        even.removeAll(odd);\n\
    \        odd.removeAll(even);\n        boolean evenPalindrome = true;\n      \
    \  for (Integer i : even) {\n            String evenPalindromeString = new StringBuilder(i).reverse().toString();\n\
    \            if (evenPalindromeString.equals(i)) {\n                evenPalindrome\
    \ = false;\n                break;\n            }\n        }\n        boolean\
    \ oddPalindrome = true;\n        for (Integer i : odd) {\n            String oddPalindromeString\
    \ = new StringBuilder(i).reverse().toString();\n            if (oddPalindromeString.equals(i))\
    \ {\n                oddPalindrome = false;\n                break;\n        \
    \    }\n        }\n        return new ImmutablePair<>(evenPalindrome ? 1 : 0,\
    \ oddPalindrome ? 1 : 0);", "        int even = 0;\n        int odd = 0;\n   \
    \     for (int i = 2; i <= n / 2; i++) {\n            while (n / i >= 0) {\n \
    \               int n = i / 2;\n                int m = n - 1;\n             \
    \   int flag = 1;\n                int count = 0;\n                if (n == i)\
    \ {\n                    flag = 2;\n                } else {\n               \
    \     while (m != -1) {\n                        if (n % m == 0) {\n         \
    \                   if (flag == 1) {\n                                count +=\
    \ 2;\n                            } else if (flag == 2) {\n                  \
    \              count += 1;\n                            } else {\n           \
    \                     count++;\n                            }\n              \
    \              flag = 1;\n                            break;\n               \
    \         } else {\n                            m--;\n                       \
    \     flag = 0;\n                        }\n                    }\n          \
    \          if (flag == 1) {\n                        count += 2;\n           \
    \         } else if (flag == 2) {\n                        count += 1;\n     \
    \               } else {\n                        count++;\n                 \
    \   }\n                }\n                if (count == 2) {\n                \
    \    odd += count;\n                } else if (count == 1) {\n               \
    \     even += count;\n                }\n            }\n        }\n        return\
    \ new Pair<>(even, odd);", "        // write your code here\n        return null;",
  "        // Think about how this problem can be solved using recursion.\n      \
    \  // Avoid using ArrayList.\n        // If you cannot use recursion, think about\
    \ how this problem can be solved using another data structure like arraylist.\n\
    \        ArrayList<Integer> palindromes = new ArrayList<>();\n        // return\
    \ (even, odd)\n        if (n > 1) {\n            Pair<Integer, Integer> even =\
    \ evenOddPalindrome(n - 2);\n            Pair<Integer, Integer> odd = evenOddPalindrome(n\
    \ - 1);\n            palindromes.add(even.getFirst());\n            palindromes.add(even.getSecond());\n\
    \            palindromes.add(odd.getFirst());\n            palindromes.add(odd.getSecond());\n\
    \            return Pair.of(palindromes.size(), palindromes.size() + (even.getFirst()\
    \ + even.getSecond()));\n        }\n        return new Pair<>(new Integer(0),\
    \ new Integer(0));", "        // write your code here\n        Pair<Integer, Integer>\
    \ result = new Pair<>();\n        if (n < 1 || n > 10) {\n            throw new\
    \ IllegalArgumentException();\n        }\n        int even = 0;\n        int odd\
    \ = 0;\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i))\
    \ {\n                even++;\n            } else {\n                odd++;\n \
    \           }\n        }\n        result.setFirst(even);\n        result.setSecond(odd);\n\
    \        return result;", "        // code here\n        if (n==0)\n        {\n\
    \            return new Pair<Integer,Integer>(0,0);\n        }\n        Pair<Integer,\
    \ Integer> even = new Pair<Integer, Integer>(1, 1);\n        Pair<Integer, Integer>\
    \ odd = new Pair<Integer, Integer>(1, 1);\n        for (int i = 1; i <= n; i++)\
    \ {\n            even = evenOddPalindrome(i * 2 + 1, even);\n            odd =\
    \ evenOddPalindrome(i * 2 + 2, odd);\n        }\n        return new Pair<Integer,\
    \ Integer>(even.getFirst() + odd.getFirst(), even.getSecond() + odd.getSecond());",
  "        // Straightforward solution.\n        Set<Integer> even = new HashSet<>();\n\
    \        Set<Integer> odd = new HashSet<>();\n        for (int i = 1; i <= n;\
    \ i++) {\n            String str = getString(i);\n            str = str.trim();\n\
    \            str = str.substring(str.length() - 1);\n            if (isPalindrome(str))\
    \ {\n                odd.add(str);\n            } else {\n                even.add(str);\n\
    \            }\n        }\n        Pair<Integer, Integer> evenOddPalindrome =\
    \ new Pair<>();\n        evenOddPalindrome.setFirst(even.size());\n        evenOddPalindrome.setSecond(odd.size());\n\
    \        return evenOddPalindrome;", '        return evenOddPalindromeHelper(n,
    Integer.valueOf(2), Integer.valueOf(12));', "        // write your code here\n\
    \        Pair<Integer, Integer> even = new Pair<>();\n        Pair<Integer, Integer>\
    \ odd = new Pair<>();\n        int half = n / 2;\n        \n        for (int i\
    \ = 1; i <= half; i++) {\n            if (isPalindrome(i)) {\n               \
    \ if (isEven(i)) {\n                    even.count++;\n                }\n   \
    \             if (isOdd(i)) {\n                    odd.count++;\n            \
    \    }\n            }\n        }\n        return Pair.create(even.count, odd.count);",
  '        return evenOddPalindromeHelper(range(1, n));', "        ArrayList<Integer>\
    \ even = new ArrayList<>();\n        ArrayList<Integer> odd = new ArrayList<>();\n\
    \        Pair<Integer, Integer> result = null;\n        for(int i = 2; i <= n;\
    \ i++) {\n            int half = i / 2;\n            int rem = i & 1;\n      \
    \      for(int j = 1; j <= half; j++) {\n                if(rem == (j % 2 == 0))\
    \ {\n                    even.add(j);\n                } else {\n            \
    \        odd.add(j);\n                }\n            }\n        }\n        even.sort((a,\
    \ b) -> a - b);\n        odd.sort((a, b) -> a - b);\n        even.removeAll(odd);\n\
    \        odd.removeAll(even);\n        if(even.isEmpty() || odd.isEmpty()) {\n\
    \            result = Pair.of(even.size(), odd.size());\n        } else {\n  \
    \          result = Pair.of(even.get(0), even.size());\n            for(int i\
    \ = 1; i < even.size() - 1; i++) {\n                result = Pair.of(even.get(i),\
    \ even.size());\n            }\n        }\n        return result;", "        //\
    \ your code goes here\n        Pair pair = new Pair(0,0);\n        for(int i=1;i<=n;i++){\n\
    \            for(int j=1;j<=i;j++){\n                if(i-j==i){\n           \
    \         pair.setFirst(pair.getFirst()+1);\n                    pair.setSecond(pair.getSecond()+1);\n\
    \                }\n            }\n        }\n        return pair;", "       \
    \ Pair<Integer, Integer> evenPalindrome = new Pair<>(0,0);\n        Pair<Integer,\
    \ Integer> oddPalindrome = new Pair<>(0,0);\n        for(int i=0;i<n;i++){\n \
    \           evenPalindrome = evenPalindrome.update(evenPalindrome,Palindrome.evenPalindrome(i));\n\
    \            oddPalindrome = oddPalindrome.update(oddPalindrome,Palindrome.oddPalindrome(i));\n\
    \        }\n        return Pair.create(evenPalindrome.getFirst(), oddPalindrome.getFirst());",
  "        // write your code here\n        ArrayList<Integer> oddPalindromes = new\
    \ ArrayList<>();\n        ArrayList<Integer> evenPalindromes = new ArrayList<>();\n\
    \        oddPalindromes.addAll(Arrays.asList(1, 2, 3));\n        evenPalindromes.addAll(Arrays.asList(4,\
    \ 5, 6, 7, 8, 9, 11));\n        if (n >= 2) {\n            oddPalindromes.remove(oddPalindromes.size()\
    \ - 1);\n        }\n        if (n >= 3 && n <= 10) {\n            oddPalindromes.remove(oddPalindromes.size()\
    \ - 2);\n        }\n        if (n >= 11) {\n            oddPalindromes.remove(oddPalindromes.size()\
    \ - 10);\n        }\n        if (n == 1) {\n            return new Pair<>(1, 1);\n\
    \        }\n        oddPalindromes.stream().filter(p -> p >= 1 && p <= n).forEach(p\
    \ -> {\n            if (isPalindrome(p)) {\n                oddPalindromes.remove(p);\n\
    \            }\n        });\n        evenPalindromes.stream().filter(p -> p >=\
    \ 1 && p <= n).forEach(p -> {\n            if (isPalindrome(p)) {\n          \
    \      evenPalindromes.remove(p);\n            }\n        });\n        return\
    \ new Pair<>(evenPalindromes.size(), oddPalindromes.size());", "        List<Integer>\
    \ numbers = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n     \
    \       numbers.add(i);\n        }\n        Set<Integer> even = numbers.stream().filter(number\
    \ -> number % 2 == 0).collect(Collectors.toSet());\n        Set<Integer> odd =\
    \ numbers.stream().filter(number -> number % 2 == 1).collect(Collectors.toSet());\n\
    \        Map<Integer, Integer> evenOdd = even.stream().collect(Collectors.toMap(number\
    \ -> number, number -> odd.contains(number) ? 1 : 0));\n        Set<Integer> result\
    \ = evenOdd.entrySet().stream().filter(entry -> entry.getValue() == 2).collect(Collectors.toSet());\n\
    \        return new Pair<>(evenOdd.keySet().size(), result.size());", "      \
    \  if(n <= 0) {\n            return null;\n        }\n        if(n <= 2) {\n \
    \           return Pair.of(2,2);\n        }\n        Set<Integer> set = new TreeSet<Integer>();\n\
    \        for(int i = 1; ; i++) {\n            if(i%2 == 0) {\n               \
    \ if((n-1) % i > 0) {\n                    set.add(i);\n                }\n  \
    \          } else {\n                if((n-1) % i > 0) {\n                   \
    \ set.add(i);\n                }\n            }\n        }\n        int evenPalindromes\
    \ = 0;\n        int oddPalindromes = 0;\n        for(Integer i : set) {\n    \
    \        int n = i*i;\n            int even = (n/2)/i;\n            int odd =\
    \ (n/2)/(i-1);\n            evenPalindromes += even;\n            oddPalindromes\
    \ += odd;\n        }\n        return Pair.of(evenPalindromes, oddPalindromes);",
  "        long palindrome = 0;\n        int odd = 0, even = 0;\n        long[] evenPalindrome\
    \ = new long[n];\n        long[] oddPalindrome = new long[n];\n        List<Integer>\
    \ integers = new ArrayList<>();\n        for(int i = 1; i <= n; i++){\n      \
    \      integers.add(i);\n        }\n        for(int i = 1; i <= n; i++){\n   \
    \         Integer temp = (Integer) integers.get(i);\n            for(int j = 1;\
    \ j <= n / 2; j++){\n                if(Integer.parseInt(new StringBuilder(temp.toString()).reverse().toString())\
    \ == temp)\n                    oddPalindrome[i] += 1;\n            }\n      \
    \      for(int j = temp - 2; j <= temp + 2; j ++){\n                if(Integer.parseInt(new\
    \ StringBuilder(temp.toString()).reverse().toString()) == temp)\n            \
    \        evenPalindrome[i] += 1;\n            }\n        }\n        for(int i\
    \ = 1; i <= n; i++){\n            if(oddPalindrome[i] > 0 && evenPalindrome[i]\
    \ > 0){\n                oddPalindrome[i] = oddPalindrome[i] / 2;\n          \
    \      evenPalindrome[i] = evenPalindrome[i] / 2;\n                palindrome\
    \ += oddPalindrome[i];\n                palindrome += evenPalindrome[i];\n   \
    \         }\n        }\n        return new Pair<>(palindrome, palindrome % 2);",
  "        Pair<Integer, Integer> p1 = new Pair<>(0,0);\n        if(n<=0){\n     \
    \       return p1;\n        }\n        if(n%2==0){\n            p1.setSecond(0);\n\
    \            p1.setFirst(n);\n        }\n        else{\n            p1.setSecond(n);\n\
    \            p1.setFirst(n/2);\n        }\n        for(int i=1; i<=n; i=i+2){\n\
    \            if(n%2==0){\n                if(i<n && i>=(n-1)){\n             \
    \       p1=new Pair<>(p1.getFirst(),p1.getSecond()+1);\n                }\n  \
    \              if(i==n && i<(n-1)){\n                    p1=new Pair<>(p1.getFirst(),p1.getSecond()+1);\n\
    \                }\n                if(i==(n-1) && i>=0){\n                  \
    \  p1=new Pair<>(p1.getFirst(),p1.getSecond()+1);\n                }\n       \
    \     }\n            if(n%2==1){\n                if(i>0 && i<(n-1)){\n      \
    \              p1=new Pair<>(p1.getFirst()+1,p1.getSecond());\n              \
    \  }\n                if(i==n && i>=(n-1)){\n                    p1=new Pair<>(p1.getFirst()+1,p1.getSecond());\n\
    \                }\n                if(i==(n-1) && i<=0){\n                  \
    \  p1=new Pair<>(p1.getFirst()+1,p1.getSecond());\n                }\n       \
    \     }\n        }\n        return p1;", "        List<Integer> numbers = new\
    \ ArrayList<>();\n        for (int i = 2; i <= n; i++) {\n            if (isPalindrome(i))\
    \ {\n                numbers.add(i);\n            }\n        }\n        \n   \
    \     Collections.sort(numbers);\n        \n        List<Integer> evenNumbers\
    \ = new ArrayList<>();\n        List<Integer> oddNumbers = new ArrayList<>();\n\
    \        \n        for (int i = 0; i < numbers.size(); i++) {\n            if\
    \ (numbers.get(i) % 2 == 0) {\n                evenNumbers.add(numbers.get(i));\n\
    \            } else {\n                oddNumbers.add(numbers.get(i));\n     \
    \       }\n        }\n        \n        return Pair.of((int)evenNumbers.size(),\
    \ (int)oddNumbers.size());", "        Pair<Integer, Integer> pair = new Pair<>(0,0);\n\
    \        int even = 0;\n        int odd = 0;\n        int mid = 0;\n        for(int\
    \ i = 0; i < n; i++) {\n            mid = (n / 2) + (i % 2);\n            if(mid\
    \ < n) mid++;\n            for(int j = 0; j <= mid; j++) {\n                if(j\
    \ == 0 || j == mid) {\n                    continue;\n                } else {\n\
    \                    if(i == 0 || i == mid || i % 2 != 0)\n                  \
    \      even++;\n                    else\n                        odd++;\n   \
    \             }\n            }\n        }\n        pair.first(even);\n       \
    \ pair.second(odd);\n        return pair;", "        Map<Integer, Integer> map\
    \ = new HashMap<>();\n        map.put(1, 0);\n        map.put(2, 0);\n       \
    \ map.put(3, 0);\n        map.put(4, 0);\n        map.put(5, 0);\n        map.put(6,\
    \ 0);\n        map.put(7, 0);\n        map.put(8, 0);\n        map.put(9, 0);\n\
    \        map.put(10, 0);\n\n        // palindrome counter\n        int evenPalCount\
    \ = 0, oddPalCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n          \
    \  // palindrome is odd\n            if (isPalindrome(String.valueOf(i))) {\n\
    \                oddPalCount++;\n            } else {\n                evenPalCount++;\n\
    \            }\n\n            // palindrome is even\n            if (map.containsKey(String.valueOf(i)))\
    \ {\n                map.put(String.valueOf(i), map.get(String.valueOf(i)) + 1);\n\
    \            } else {\n                map.put(String.valueOf(i), 1);\n      \
    \      }\n        }\n\n        // return even and odd palindrome count in tuple\n\
    \        return new Pair<>(evenPalCount, oddPalCount);", "        Pair<Integer,\
    \ Integer> even = new Pair<>(0, 0);\n        Pair<Integer, Integer> odd = new\
    \ Pair<>(0, 0);\n\n        if (n <= 0) return odd;\n        if (n == 1) return\
    \ even;\n\n        Integer mid = n / 2;\n        Pair<Integer, Integer> midEven\
    \ = evenOddPalindrome(mid);\n        Pair<Integer, Integer> midOdd = evenOddPalindrome(n\
    \ - mid);\n\n        if (midEven.first.getFirst() > midOdd.first.getFirst()) {\n\
    \            even = new Pair<>(midEven.first.getFirst(), midEven.second.getFirst());\n\
    \        } else {\n            even = new Pair<>(midOdd.first.getFirst(), midOdd.second.getFirst());\n\
    \        }\n\n        if (midEven.first.getSecond() > midOdd.first.getSecond())\
    \ {\n            odd = new Pair<>(midEven.first.getSecond(), midEven.second.getSecond());\n\
    \        } else {\n            odd = new Pair<>(midOdd.first.getSecond(), midOdd.second.getSecond());\n\
    \        }\n        return Pair.of(even, odd);", "        Map<Integer, Integer>\
    \ odds = new HashMap<>();\n        Map<Integer, Integer> evens = new HashMap<>();\n\
    \n        int evenCount = 0;\n        int oddCount = 0;\n\n        // O(n)\n \
    \       for (int i = 0; i < n; i++) {\n            int currentNum = i;\n\n   \
    \         // odd number\n            if (currentNum % 2 != 0) {\n            \
    \    odds.put(i, 1);\n            } else {\n                // even number\n \
    \               if (odds.containsKey(currentNum)) {\n                    evens.put(i,\
    \ 1);\n                } else {\n                    evens.put(i, 0);\n      \
    \          }\n            }\n        }\n\n        // O(n^2)\n        for (Map.Entry<Integer,\
    \ Integer> odd : odds.entrySet()) {\n            for (Map.Entry<Integer, Integer>\
    \ even : evens.entrySet()) {\n                if (odd.getKey() >= 0 && even.getKey()\
    \ >= 0 && odd.getKey() <= n && even.getKey() <= n) {\n                    int\
    \ diff = odd.getKey() - even.getKey();\n                    int currentNum = even.getKey()\
    \ - odd.getKey();\n                    if (diff == 0) {\n                    \
    \    if (currentNum % 2 == 0) {\n                            evenCount++;\n  \
    \                      } else {\n                            oddCount++;\n   \
    \                     }\n                    } else {\n                      \
    \  for (int j = 0; j < diff; j++) {\n                            if (currentNum\
    \ % 2 == 0) {\n                                evenCount++;\n                \
    \            } else {\n                                oddCount++;\n         \
    \                   }\n                            currentNum--;\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n        return Pair.pair(evenCount, oddCount);", "        int even =\
    \ 0, odd = 0;\n        int evenSum = 0, oddSum = 0;\n        long range = (long)(n\
    \ - 1);\n        for(int i = 0; i <= range; i++) {\n            Pair<Integer,\
    \ Integer> currentPair = new Pair<Integer, Integer>(0, 0);\n            currentPair\
    \ = checkPalindrome(i, 1, n);\n            evenSum += currentPair.getKey();\n\
    \            oddSum += currentPair.getValue();\n        }\n        if(evenSum\
    \ > oddSum) {\n            return Pair.of(evenSum - oddSum, 0);\n        }\n \
    \       else {\n            return Pair.of(0, oddSum - evenSum);\n        }",
  "        Set<Integer> odd = new HashSet<>();\n        Set<Integer> even = new HashSet<>();\n\
    \        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i =\
    \ 2; i < n; i++) {\n            if (odd.contains(i)) {\n                oddCount++;\n\
    \            } else {\n                evenCount++;\n                odd.add(i);\n\
    \            }\n        }\n        return Pair.create(evenCount, oddCount);",
  "        int half = n / 2;\n        int odd = n / 2;\n        int even = half;\n\
    \        int i = 0;\n        while (odd < half) {\n            i++;\n        \
    \    odd += 2;\n        }\n        int j = i + 1;\n        while (even <= half)\
    \ {\n            j++;\n            even++;\n        }\n        Pair<Integer, Integer>\
    \ res = new Pair<>();\n        res.setLeft(even);\n        res.setRight(odd);\n\
    \        return res;", "        int[] even = new int[n];\n        int[] odd =\
    \ new int[n];\n        int mid = (n + 1) >> 1;\n        int countEven = 0;\n \
    \       int countOdd = 0;\n        for (int i = 1; i <= mid; i++) {\n        \
    \    if (isPalindrome(i)) {\n                countEven++;\n            } else\
    \ {\n                countOdd++;\n            }\n        }\n        for (int i\
    \ = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                even[i\
    \ - 1]++;\n                odd[mid--]++;\n            }\n        }\n        return\
    \ new Pair<>(countEven, countOdd);", "        Pair<Integer, Integer> even = new\
    \ Pair<>();\n        Pair<Integer, Integer> odd = new Pair<>();\n        Arrays.fill(n\
    \ * n, n);\n        Pair<Integer, Integer> p = new Pair<>();\n        Arrays.fill(p.x,\
    \ p.y);\n        for (int i = 1; i < n; i++) {\n            int evenC = 0;\n \
    \           int oddC = 0;\n            Arrays.fill(p.x, p.y);\n            for\
    \ (int j = i * i; j < n; j += 2 * i) {\n                p.x += 2 * j;\n      \
    \          p.y += 2 * j;\n                String a = Integer.toString(p.x);\n\
    \                String b = Integer.toString(p.y);\n                if (a.equals(b))\
    \ {\n                    p.x = p.y;\n                    p.y = p.x;\n        \
    \            evenC++;\n                } else if (b.equals(a)) {\n           \
    \         p.y = p.x;\n                    p.x = p.y;\n                    oddC++;\n\
    \                }\n            }\n            even.x += (p.x % 2 == 0) ? evenC\
    \ : (evenC - oddC);\n            even.y += (p.y % 2 == 0) ? evenC : (evenC - oddC);\n\
    \            odd.x += (p.x % 2 == 1) ? oddC : (oddC - evenC);\n            odd.y\
    \ += (p.y % 2 == 1) ? oddC : (oddC - evenC);\n        }\n        return new Pair<>(even,\
    \ odd);", "        Set<Integer> s = new HashSet<Integer>();\n        for (int\
    \ i = 1; i <= n; ++i) {\n            String str = String.valueOf(i);\n       \
    \     if (str.equals(str.reverse().toString())) {\n                s.add(i);\n\
    \            }\n        }\n        boolean isOdd = n % 2 != 0;\n        if (isOdd)\
    \ {\n            return new Pair<>(s.stream().filter(e -> e % 2 == 1).count()\
    \ + 1, s.stream().filter(e -> e % 2 == 0).count() + 1);\n        } else {\n  \
    \          return new Pair<>(s.stream().filter(e -> e % 2 == 1).count(), s.stream().filter(e\
    \ -> e % 2 == 0).count());\n        }", "        Pair<Integer, Integer> even =\
    \ new Pair<>();\n        even.first = 0;\n        even.second = 0;\n        int\
    \ count = 0;\n        for (int i = 1; i <= n; i++) {\n            Pair<Integer,\
    \ Integer> odd = new Pair<>();\n            odd.first = 0;\n            odd.second\
    \ = 0;\n            boolean isEven = true;\n            for (int j = 1; j <= n\
    \ / 2; j++) {\n                if (i % j == 0) {\n                    isEven =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       if (isEven) {\n                even.first++;\n                even.second\
    \ += odd.second + 1;\n            } else {\n                odd.first++;\n   \
    \             odd.second += even.first + 1;\n            }\n            count++;\n\
    \        }\n        return Pair.of(even.first, even.second);", "        // code\
    \ here\n        long start = System.currentTimeMillis();\n        int evenCount\
    \ = 0;\n        int oddCount = 0;\n        int evenoddCount = 1;\n        int\
    \ oddevenoddCount = 2;\n        for (int i = 1; i <= n; i++) {\n            String\
    \ str = String.valueOf(i);\n            int left = 0, right = str.length() - 1;\n\
    \            while (left < right) {\n                int mid = (left + right)\
    \ / 2;\n                if (str.charAt(mid) != str.charAt(mid + 1) || str.charAt(mid)\
    \ != str.charAt(mid - 1)) {\n                    right = mid;\n              \
    \  } else {\n                    if (mid == 0) {\n                        left\
    \ = mid + 1;\n                        mid = (left + right) / 2;\n            \
    \            break;\n                    } else if (mid == str.length() - 1) {\n\
    \                        left = mid - 1;\n                        mid = (left\
    \ + right) / 2;\n                        break;\n                    } else {\n\
    \                        left = mid + 1;\n                        mid = (left\
    \ + right) / 2;\n                    }\n                }\n            }\n   \
    \         if (left != 0) {\n                evenCount++;\n                if (left\
    \ % 2 == 1) {\n                    evenoddCount++;\n                }\n      \
    \      }\n            if (right != str.length() - 1) {\n                oddCount++;\n\
    \                if (right % 2 == 1) {\n                    oddevenoddCount++;\n\
    \                }\n            }\n        }\n        Pair<Integer, Integer> res\
    \ = new Pair<>(evenCount, oddCount);\n        res.setOddEvenCount(evenoddCount,\
    \ oddevenoddCount);\n        res.setRunTime((System.currentTimeMillis() - start)\
    \ / 1000);\n        return res;", "        Set<Integer> odd = new HashSet<Integer>();\n\
    \        Set<Integer> even = new HashSet<Integer>();\n        Set<Integer> evenOrOdd\
    \ = new HashSet<Integer>();\n        ArrayDeque<Integer> stack = new ArrayDeque<Integer>();\n\
    \n        stack.push(n);\n        while (stack.size() > 0) {\n            int\
    \ n = stack.pop();\n            for (int i = 1; i <= n; i++) {\n             \
    \   if (even.contains(i) && odd.contains(n)) {\n                    evenOrOdd.add(new\
    \ Integer[]{i});\n                } else if (odd.contains(i) && even.contains(n))\
    \ {\n                    evenOrOdd.add(new Integer[]{n});\n                } else\
    \ if (odd.contains(i) && odd.contains(n)) {\n                    evenOrOdd.add(new\
    \ Integer[]{new Integer[]{i}, new Integer[]{n}});\n                } else {\n\
    \                    evenOrOdd.add(new Integer[]{i});\n                    evenOrOdd.add(new\
    \ Integer[]{n});\n                }\n                if (even.contains(i) && odd.contains(n))\
    \ {\n                    evenOrOdd.add(new Integer[]{i});\n                  \
    \  evenOrOdd.add(new Integer[]{n});\n                } else if (even.contains(i)\
    \ && even.contains(n)) {\n                    evenOrOdd.add(new Integer[]{i});\n\
    \                    evenOrOdd.add(new Integer[]{n});\n                } else\
    \ if (odd.contains(i) && even.contains(n)) {\n                    evenOrOdd.add(new\
    \ Integer[]{i});\n                    evenOrOdd.add(new Integer[]{n});\n     \
    \           } else if (odd.contains(i) && odd.contains(n)) {\n               \
    \     evenOrOdd.add(new Integer[]{i});\n                    evenOrOdd.add(new\
    \ Integer[]{n});\n                } else if (even.contains(i) && odd.contains(n))\
    \ {\n                    evenOrOdd.add(new Integer[]{i});\n                  \
    \  evenOrOdd.add(new Integer[]{n});\n                } else if (even.contains(i)\
    \ && even.contains(n)) {\n                    evenOrOdd.add(new Integer[]{i});\n\
    \                    evenOrOdd.add(new Integer[]{n});\n                } else\
    \ if (odd.contains(i) && even.contains(n)) {\n                    evenOrOdd.add(new\
    \ Integer[]{i});\n                    evenOrOdd.add(new Integer[]{n});\n     \
    \           } else if (odd.contains(i) && odd.contains(n)) {\n               \
    \     evenOrOdd.add(new Integer[]{i});\n                    ", "        if (n\
    \ < 0) {\n            return new Pair<Integer, Integer>(1, 0);\n        }\n  \
    \      if (n <= 10) {\n            Pair<Integer, Integer> even = new Pair<Integer,\
    \ Integer>(0, 0);\n            Pair<Integer, Integer> odd = new Pair<Integer,\
    \ Integer>(0, 0);\n            StringBuilder evenString = new StringBuilder();\n\
    \            StringBuilder oddString = new StringBuilder();\n            int evenCount\
    \ = 1;\n            int oddCount = 1;\n            while (n > 9) {\n         \
    \       if (isPalindrome(n)) {\n                    if (evenCount == 1) {\n  \
    \                      evenString.append(n);\n                        evenCount\
    \ = evenCount + 1;\n                    }\n                    else {\n      \
    \                  oddString.append(n);\n                        oddCount = oddCount\
    \ + 1;\n                    }\n                }\n                n = n/10;\n\
    \            }\n            if (evenCount % 2 == 0) {\n                even =\
    \ new Pair<Integer, Integer>(evenCount, oddCount);\n            }\n          \
    \  else {\n                odd = new Pair<Integer, Integer>(oddCount, evenCount);\n\
    \            }\n            return new Pair<Integer, Integer>(even, odd);\n  \
    \      }\n        Pair<Integer, Integer> even = new Pair<Integer, Integer>(0,\
    \ 0);\n        Pair<Integer, Integer> odd = new Pair<Integer, Integer>(0, 0);\n\
    \        while (n > 0) {\n            if (isPalindrome(n)) {\n               \
    \ if (isEven(n)) {\n                    if (evenCount == 1) {\n              \
    \          evenString.append(n);\n                        evenCount = evenCount\
    \ + 1;\n                    }\n                    else {\n                  \
    \      oddString.append(n);\n                        oddCount = oddCount + 1;\n\
    \                    }\n                }\n                else {\n          \
    \          if (oddCount == 1) {\n                        oddString.append(n);\n\
    \                        oddCount = oddCount + 1;\n                    }\n   \
    \                 else {\n                        evenString.append(n);\n    \
    \                    evenCount = evenCount + 1;\n                    }\n     \
    \           }\n            }\n            n = n/10;\n        }\n        if (isEven(n))\
    \ {\n            if (evenCount == 1) {\n                evenString.append(n);\n\
    \                evenCount = evenCount + 1;\n            }\n            else {\n\
    \                oddString.append(n);\n                oddCount = oddCount + 1;\n\
    \            }\n        }\n        else {\n            if (oddCount == 1) {\n\
    \                oddString.append(n);\n                oddCount = oddCount + 1;\n\
    \            }\n            else {\n                evenString.append(n);\n  \
    \              evenCount = evenCount + 1;\n            }\n        }\n        even\
    \ = new Pair<Integer, Integer>(evenCount, oddCount);\n        odd = new Pair<Integer,\
    \ Integer>(oddCount, evenCount);\n        return new Pair<Integer, Integer>(even,\
    \ odd);", "        int nHalf = n/2;\n        if(n<2){\n            return new\
    \ Pair<>(0, 0);\n        }\n        return evenOddPalindrome(nHalf);", "     \
    \   List<Integer> list = new ArrayList<>();\n        \n        Set<Integer> set\
    \ = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toSet());\n\n     \
    \   for (int i = 1; i <= n; i++) {\n            StringBuilder str = new StringBuilder(i).reverse();\n\
    \            if (set.contains(i)) {\n                list.add(str);\n        \
    \    }\n        }\n        return Pair.tuple(list.size(), list.stream().filter(e\
    \ -> e.replaceFirst(\"\\\\d\", \"\").length() == e.replaceFirst(\"\\\\D\", \"\"\
    ).length()).count());", "        List<Integer> oddPalindromes = getPalindromes(n);\n\
    \        List<Integer> evenPalindromes = getPalindromes(n);\n        Pair<Integer,\
    \ Integer> pair = new Pair<>();\n        Integer odd = 0;\n        Integer even\
    \ = 0;\n        oddPalindromes.stream().map(i -> new Integer(i)).forEach(i ->\
    \ {\n            int j = i;\n            while (j > 0) {\n                int\
    \ rem = j % 10;\n                if (rem == 0) {\n                    j = (int)\
    \ Math.floor(j / 10);\n                } else {\n                    break;\n\
    \                }\n            }\n            if (j > 0) {\n                odd\
    \ += i;\n            }\n        });\n        evenPalindromes.stream().map(i ->\
    \ new Integer(i)).forEach(i -> {\n            int j = i;\n            while (j\
    \ > 0) {\n                int rem = j % 10;\n                if (rem != 0) {\n\
    \                    j = (int) Math.floor(j / 10);\n                } else {\n\
    \                    break;\n                }\n            }\n            if\
    \ (j > 0) {\n                even += i;\n            }\n        });\n        pair.first\
    \ = odd;\n        pair.second = even;\n        return pair;", "        /*\n  \
    \       * Problem can be solved in two ways\n         * 1. Brute force\n     \
    \    * 2. Dynamic Programming (See below)\n         */\n        \n        Pair<Integer,\
    \ Integer> evenOdd = null;\n        \n        // Brute Force Solution\n      \
    \  // O(n^3)\n        for(int i = 0; i < n; i++) {\n            for(int j = 0;\
    \ j < n; j++) {\n                for(int k = 0; k < n; k++) {\n              \
    \      if(i != j && i != k && j != k) {\n                        if(isPalindrome(i,\
    \ j, k)) {\n                            if(evenOdd == null) {\n              \
    \                  evenOdd = new Pair<>(i, j);\n                            }\
    \ else {\n                                evenOdd = new Pair<>(evenOdd.getLeft()\
    \ + 1, evenOdd.getRight() + 1);\n                            }\n             \
    \           }\n                    }\n                }\n            }\n     \
    \   }\n        \n        // Dynamic Programming Solution\n        // O(n^3)\n\
    \        int[] evenOddCount = new int[n];\n        \n        for(int i = 0; i\
    \ < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                for(int\
    \ k = j + 1; k < n; k++) {\n                    if(i != j && i != k && j != k)\
    \ {\n                        if(isPalindrome(i, j, k)) {\n                   \
    \         if(evenOddCount[i - 1] == 0 && evenOddCount[j - 1] == 0 && evenOddCount[k\
    \ - 1] == 0) {\n                                evenOddCount[i - 1] = 1;\n   \
    \                             evenOddCount[j - 1] = 1;\n                     \
    \           evenOddCount[k - 1] = 1;\n                            } else {\n \
    \                               evenOddCount[i - 1]++;\n                     \
    \           evenOddCount[j - 1]++;\n                                evenOddCount[k\
    \ - 1]++;\n                            }\n                        }\n        \
    \            }\n                }\n            }\n        }\n        \n      \
    \  if(evenOdd == null) {\n            return new Pair<>(0,0);\n        } else\
    \ {\n            return new Pair<>(evenOdd.getLeft() + 1, evenOdd.getRight() +\
    \ 1);\n        }", "        List<Integer> evenPalindromes = new ArrayList<>();\n\
    \        List<Integer> oddPalindromes = new ArrayList<>();\n        int countEven\
    \ = 0, countOdd = 0, count = 1, start = 1;\n        for (int i = n; i > 0; i -=\
    \ 2) {\n            while (n % i == 0) {\n                evenPalindromes.add(start++);\n\
    \                count += 1;\n                if (count == i) {\n            \
    \        countEven++;\n                }\n                count /= i;\n      \
    \      }\n            while (n % i != 0) {\n                oddPalindromes.add(start++);\n\
    \                count += 1;\n                if (count == i) {\n            \
    \        countOdd++;\n                }\n                count /= i;\n       \
    \     }\n        }\n        Pair<Integer, Integer> pair = new Pair<>();\n    \
    \    if (countEven == 0) {\n            pair.setFirst(countOdd);\n        } else\
    \ {\n            pair.setFirst(countEven);\n        }\n        if (countOdd ==\
    \ 0) {\n            pair.setSecond(n);\n        } else {\n            pair.setSecond(countOdd);\n\
    \        }\n        return pair;", "        Pair<Integer, Integer> evenOddPalindrome\
    \ = Pair.create(0,0);\n        for(int i=1; i<=n; i++){\n            String s\
    \ = i.toString();\n            int even = 0;\n            int odd = 0;\n     \
    \       int j = 0;\n            while(j<s.length()){\n                if(s.charAt(j)\
    \ == s.charAt(j+1)){\n                    even++;\n                }\n       \
    \         else{\n                    odd++;\n                }\n             \
    \   j++;\n            }\n            if(even%2 == 0){\n                evenOddPalindrome\
    \ = Pair.create(evenOddPalindrome.getFirst()+even, evenOddPalindrome.getSecond()+odd);\n\
    \            }\n            else{\n                evenOddPalindrome = Pair.create(evenOddPalindrome.getFirst()+odd+even,\
    \ evenOddPalindrome.getSecond()+odd);\n            }\n        }\n        return\
    \ evenOddPalindrome;", '        return evenOddPalindrome(n, new Pair<>());', " \
    \       Map<Integer, Integer> palindromes = new HashMap<>();\n\n        for (int\
    \ i = 1; i <= n; i++) {\n            boolean oddPalindrome = true;\n         \
    \   boolean evenPalindrome = true;\n\n            StringBuilder sb = new StringBuilder();\n\
    \n            int j = 1;\n            while (j <= i) {\n                if (j\
    \ % 2 == 0) {\n                    sb.append(j);\n                }\n        \
    \        else {\n                    oddPalindrome = false;\n                }\n\
    \n                j++;\n            }\n\n            int k = sb.length() - 1;\n\
    \            while (k >= 1) {\n                if (sb.charAt(k) != sb.charAt(k\
    \ - 1)) {\n                    evenPalindrome = false;\n                }\n  \
    \              k--;\n            }\n\n            if (oddPalindrome && evenPalindrome)\
    \ {\n                palindromes.put(i, 1);\n            }\n            else if\
    \ (oddPalindrome && !evenPalindrome) {\n                palindromes.put(i, 2);\n\
    \            }\n            else if (!oddPalindrome && evenPalindrome) {\n   \
    \             palindromes.put(i, 3);\n            }\n        }\n\n        return\
    \ new ImmutablePair<>(palindromes.keySet().size(), palindromes.values().stream().reduce(0,\
    \ (x, y) -> x + y));", "        IntStream\n                .range(1, n)\n    \
    \            .parallel()\n                .filter(i -> Integer.toString(i).chars()\n\
    \                        .mapToObj(c -> (char) c)\n                        .reduce(\"\
    \", (a, b) -> a + b)\n                        .equals(new StringBuilder().reverse().toString())\n\
    \                )\n                .count();\n        return new Pair<>(\n  \
    \              IntStream.range(1, n).parallel().filter(i -> i % 2 == 0).count(),\n\
    \                IntStream.range(1, n).parallel().filter(i -> i % 2 != 0).count());",
  "        if (n < 1)\n            return null;\n\n        final Map<Integer, Pair<Integer,\
    \ Integer>> oddNumbers = new HashMap<>();\n        final Map<Integer, Pair<Integer,\
    \ Integer>> evenNumbers = new HashMap<>();\n\n        int counter = 0;\n\n   \
    \     Stack<Integer> even = new Stack<>();\n        Stack<Integer> odd = new Stack<>();\n\
    \n        for (int i = 2; i < n; i++) {\n            odd.push(i);\n        }\n\
    \n        while (!odd.isEmpty()) {\n            int temp = Math.max(odd.pop(),\
    \ even.pop());\n            if (oddNumbers.get(temp) == null) {\n            \
    \    oddNumbers.put(temp, new Pair<>(1, 1));\n            } else {\n         \
    \       Pair<Integer, Integer> pair = oddNumbers.get(temp);\n                Pair<Integer,\
    \ Integer> previousPair = oddNumbers.get(temp - 1);\n\n                if (pair.x\
    \ == previousPair.x && pair.y == previousPair.y) {\n                    oddNumbers.put(temp,\
    \ new Pair<>(pair.x + 1, pair.y));\n                    counter++;\n         \
    \       } else {\n                    oddNumbers.put(temp, new Pair<>(1, 1));\n\
    \                }\n            }\n\n            if (evenNumbers.get(temp) ==\
    \ null) {\n                evenNumbers.put(temp, new Pair<>(1, 1));\n        \
    \    } else {\n                Pair<Integer, Integer> pair = evenNumbers.get(temp);\n\
    \                Pair<Integer, Integer> previousPair = evenNumbers.get(temp -\
    \ 1);\n\n                if (pair.x == previousPair.x && pair.y == previousPair.y)\
    \ {\n                    evenNumbers.put(temp, new Pair<>(pair.x + 1, pair.y));\n\
    \                    counter++;\n                } else {\n                  \
    \  evenNumbers.put(temp, new Pair<>(1, 1));\n                }\n            }\n\
    \        }\n\n        Pair<Integer, Integer> finalPair = new Pair<>(counter, counter);\n\
    \n        evenNumbers.entrySet().stream().map(e -> new AbstractMap.SimpleEntry<>(e.getKey(),\
    \ e.getValue()))\n                .forEach(e -> evenNumbers.put(e.getKey() - 1,\
    \ e));\n\n        oddNumbers.entrySet().stream().map(e -> new AbstractMap.SimpleEntry<>(e.getKey(),\
    \ e.getValue()))\n                .forEach(e -> oddNumbers.put(e.getKey() - 1,\
    \ e));\n\n        evenNumbers.entrySet().stream().filter(e -> e.getValue().x >\
    \ e.getValue().y)\n                .forEach(e -> evenNumbers.put(e.getKey(), new\
    \ Pair<>(e.getValue().x, e.getValue().y - 1)));\n\n        oddNumbers.entrySet().stream().filter(e\
    \ -> e.getValue().x > e.getValue().y)\n                .forEach(e -> oddNumbers.put(e.getKey(),\
    \ new ", "        Pair<Integer, Integer> evenP = new Pair<>();\n        Pair<Integer,\
    \ Integer> oddP = new Pair<>();\n        if (n < 1) {\n            oddP.first\
    \ = 0;\n            oddP.second = 0;\n            return oddP;\n        }\n  \
    \      int low = 1;\n        int high = n;\n        while (low < high) {\n   \
    \         int mid = (low + high) / 2;\n            if (mid > n) {\n          \
    \      high = mid;\n            } else if (mid < 1) {\n                low = mid\
    \ + 1;\n            } else {\n                int evenCount = 0;\n           \
    \     int oddCount = 0;\n                while (low <= mid) {\n              \
    \      String str1 = Integer.toString(low);\n                    String str2 =\
    \ Integer.toString(mid - 1);\n                    if (str1.equals(str2)) {\n \
    \                       evenCount++;\n                        mid--;\n       \
    \             } else if (str1.equals(\"0\")) {\n                        oddCount++;\n\
    \                    } else {\n                        mid--;\n              \
    \      }\n                    low++;\n                }\n                if (evenCount\
    \ > 0) {\n                    evenP.first = mid + 1;\n                    evenP.second\
    \ = evenCount;\n                } else if (oddCount > 0) {\n                 \
    \   oddP.first = mid + 1;\n                    oddP.second = oddCount;\n     \
    \           }\n            }\n        }\n        return evenP;", "        // write\
    \ your code here\n        Pair<Integer, Integer> pair = new Pair<>();\n      \
    \  for (int i = 1; i <= n; i++) {\n            String rev = \"\";\n          \
    \  rev = rev + String.valueOf(i);\n            if (rev == rev.toUpperCase()) {\n\
    \                pair.setFirst(pair.getFirst() + 1);\n            } else {\n \
    \               pair.setSecond(pair.getSecond() + 1);\n            }\n       \
    \ }\n        return pair;", "        Set<Integer> palindromes = new HashSet<>();\n\
    \        if (n < 1 || n > 10) {\n            return null;\n        }\n       \
    \ for (int i = 1; i <= n; i++) {\n            int palindrome = checkPalindrome(i);\n\
    \            if (palindrome == i) {\n                palindromes.add(i);\n   \
    \         } else if (palindrome % 2 == 0) {\n                palindromes.add((palindrome\
    \ / 2) + 1);\n            }\n        }\n        return Pair.of(\n            palindromes.stream().filter(palindrome\
    \ -> palindrome % 2 == 0).collect(Collectors.toList()),\n            palindromes.stream().filter(palindrome\
    \ -> palindrome % 2 == 1).collect(Collectors.toList()));", "        Set<Integer>\
    \ even = new HashSet<>();\n        Set<Integer> odd = new HashSet<>();\n     \
    \   for (int i = 1; i <= n; i++) {\n            int len = (int) Math.sqrt(i) +\
    \ 1;\n            for (int j = 1; j <= len; j++) {\n                int k = j;\n\
    \                while (k < i) {\n                    int temp = (k * k - i *\
    \ j) / (2 * k + j);\n                    if (temp % 2 != 0) {\n              \
    \          k = k + 1;\n                    } else {\n                        j\
    \ = j + 1;\n                    }\n                }\n                if (k !=\
    \ i) {\n                    even.add(k);\n                } else {\n         \
    \           odd.add(j);\n                }\n            }\n        }\n       \
    \ return new Pair<>(even.stream().filter(n -> n % 2 == 0).collect(Collectors.toSet()),\
    \ odd.stream().filter(n -> n % 2 == 1).collect(Collectors.toSet()));", "     \
    \   // write your code here\n        long startTime = System.currentTimeMillis();\n\
    \        int count = 0;\n        int countO = 0;\n        int countE = 0;\n  \
    \      for(int i = 1; i <= n; i++) {\n            if(isPalindrome(i)) {\n    \
    \            count++;\n                if(isEven(i)) {\n                    countE++;\n\
    \                } else {\n                    countO++;\n                }\n\
    \            }\n        }\n        return new Pair<Integer, Integer>(countE, countO);",
  "        // write your code here\n        \n        Pair<Integer, Integer> result\
    \ = new Pair<>();\n        int odd = 1;\n        for (int i = 1; i <= n; i++)\
    \ {\n            Pair<Integer, Integer> evenOddPalindromes = evenOddPalindrome(i);\n\
    \            \n            if (evenOddPalindromes.second % 2 == 0) {\n       \
    \         evenOddPalindromes.first++;\n            }\n            \n         \
    \   if (evenOddPalindromes.second % 2 != 0) {\n                odd++;\n      \
    \      }\n            \n            result.first = evenOddPalindromes.first;\n\
    \            result.second = odd;\n        }\n        \n        return result;",
  '        return evenOddPalindrome(n, null);', "        long counter = 0;\n     \
    \   int oddCount = 0;\n        int evenCount = 0;\n        int i = 0;\n\n    \
    \    while (i < n) {\n            String str = new StringBuilder(String.valueOf(i)).reverse().toString();\n\
    \            while (str.charAt(i) != '0') {\n                oddCount++;\n   \
    \             i++;\n            }\n            while (str.charAt(i) != '1') {\n\
    \                evenCount++;\n                i++;\n            }\n         \
    \   i++;\n            if (oddCount == evenCount) {\n                counter +=\
    \ oddCount;\n            }\n        }\n\n        if (counter > n) {\n        \
    \    return new Pair<Integer, Integer>(n, 0);\n        }\n\n        return new\
    \ Pair<Integer, Integer>(counter - n, oddCount - evenCount);", "        Set<Integer>\
    \ odds = new HashSet<>();\n        Set<Integer> evens = new HashSet<>();\n   \
    \     for(int i = 1; i <= n; i++)\n        {\n            if(isPalindrome(i))\n\
    \            {\n                if(isEven(i))\n                    evens.add(i);\n\
    \                else\n                    odds.add(i);\n            }\n     \
    \   }\n        return new Pair<>(evens.size(), odds.size());", '        return
    evenOddPalindromeHelper(n, new ArrayList(), 0, n);', "        Set<Integer> palindrome\
    \ = new HashSet<Integer>();\n        int odd = 0, even = 0, low = 0, high = n-1;\n\
    \        while (low <= high) {\n            if (low == high) {\n             \
    \   if (low%2 == 0) {\n                    even++;\n                } else {\n\
    \                    odd++;\n                }\n                palindrome.add(low);\n\
    \            } else if (low % 2 == 0 && high % 2 == 0) {\n                palindrome.add(low);\n\
    \                low++;\n            } else if (low % 2 == 0 && high % 2 != 0)\
    \ {\n                palindrome.add(high);\n                high--;\n        \
    \    } else if (low % 2 != 0 && high % 2 != 0) {\n                palindrome.add(low);\n\
    \                palindrome.add(high);\n                low++;\n             \
    \   high--;\n            } else {\n                low++;\n                high--;\n\
    \            }\n        }\n        return new Pair<>((even*2)+1, odd*2);", " \
    \       int[] arr = new int[n];\n        Arrays.fill(arr, 0);\n        \n    \
    \    for (int i = 0; i < n; i++) {\n            if (isPalindrome(i, n)) {\n  \
    \              for (int j = n - 1; j >= 0; j--) {\n                    arr[j]\
    \ += 1;\n                }\n            }\n        }\n        \n        int even\
    \ = 0;\n        int odd = 1;\n        \n        for (int i = 0; i < n; i++) {\n\
    \            if (arr[i] % 2 == 0) {\n                even += 1;\n            }\
    \ else {\n                odd += 1;\n            }\n        }\n        \n    \
    \    return new Pair<Integer, Integer>(even, odd);", "        Integer countEven\
    \ = 0;\n        Integer countOdd = 0;\n\n        for(int i = 1; i < n; i++) {\n\
    \            // count even\n            countEven++;\n            // count odd\n\
    \            countOdd += isOdd(i) ? 1 : 0;\n        }\n        return new Tuple2<>(countEven,\
    \ countOdd);", "        if (n < 0 || n >= 100000) {\n            return new Pair<>(0,\
    \ 0);\n        }\n        if (n == 0) {\n            return new Pair<>(0, 1);\n\
    \        }\n        int odd = 0, even = 0;\n        int palindrome = 1;\n    \
    \    for (int i = 1; i <= n; i++) {\n            if (isPalindrome(palindrome))\
    \ {\n                odd += 1;\n                palindrome += 1;\n           \
    \ } else {\n                even += 1;\n                palindrome *= 10;\n  \
    \          }\n        }\n        return new Pair<>(even, odd);", "        // write\
    \ your code here\n        return null;", "        if (n < 1 || n > 10^3) {\n \
    \           return Pair.create(0,0);\n        }\n        Map<Integer, Integer>\
    \ oddSumMap = new HashMap<>();\n        Map<Integer, Integer> evenSumMap = new\
    \ HashMap<>();\n        List<Integer> evenPalindromes = new ArrayList<>();\n \
    \       List<Integer> oddPalindromes = new ArrayList<>();\n        int evenSum\
    \ = 0;\n        int oddSum = 0;\n        for (int i = 2; i <= n; i++) {\n    \
    \        if (oddSumMap.containsKey(i)) {\n                oddSumMap.put(i, oddSumMap.get(i)\
    \ + 1);\n            }\n            else {\n                oddSumMap.put(i, 1);\n\
    \            }\n            if (evenSumMap.containsKey(i)) {\n               \
    \ evenSumMap.put(i, evenSumMap.get(i) + 1);\n            }\n            else {\n\
    \                evenSumMap.put(i, 1);\n            }\n        }\n        oddSumMap.entrySet().stream().forEach(pair\
    \ -> oddSum+=pair.getValue());\n        evenSumMap.entrySet().stream().forEach(pair\
    \ -> evenSum+=pair.getValue());\n        for (int i = 2; i <= n; i++) {\n    \
    \        Pair<Integer, Integer> evenPalindrome = evenPalindromes.stream().filter(p\
    \ -> p == i).findFirst();\n            Pair<Integer, Integer> oddPalindrome =\
    \ oddPalindromes.stream().filter(p -> p == i).findFirst();\n            if (evenPalindrome\
    \ != null && oddPalindrome != null) {\n                Pair<Integer, Integer>\
    \ evenPalindromePair = evenPalindrome;\n                Pair<Integer, Integer>\
    \ oddPalindromePair = oddPalindrome;\n                if (oddPalindromePair.getValue()\
    \ <= evenPalindromePair.getValue()) {\n                    if (oddSumMap.containsKey(i))\
    \ {\n                        oddSumMap.put(i, oddSumMap.get(i) + 1);\n       \
    \             }\n                    else {\n                        oddSumMap.put(i,\
    \ 1);\n                    }\n                    if (evenSumMap.containsKey(i))\
    \ {\n                        evenSumMap.put(i, evenSumMap.get(i) + 1);\n     \
    \               }\n                    else {\n                        evenSumMap.put(i,\
    \ 1);\n                    }\n                }\n                else {\n    \
    \                if (evenSumMap.containsKey(i)) {\n                        evenSumMap.put(i,\
    \ evenSumMap.get(i) + 1);\n                    }\n                    else {\n\
    \                        evenSumMap.put(i, 1);\n                    }\n      \
    \              if (oddSumMap.containsKey(i)) {\n                        oddSumMap.put(i,\
    \ oddSumMap.get(i) + 1);\n                    }\n                    else {\n\
    \                        oddSumMap.put(i, 1);\n                    }\n       \
    \         }\n            }\n            if (", "        List<Integer> evenList\
    \ = new ArrayList<>();\n        List<Integer> oddList = new ArrayList<>();\n \
    \       evenList.add(1);\n        oddList.add(1);\n        for (int i = 1; i <=\
    \ n; i++) {\n            if (isPalindrome(i)) {\n                if (isEven(i))\
    \ {\n                    evenList.add(2 * i);\n                } else {\n    \
    \                oddList.add(2 * i);\n                }\n            }\n     \
    \   }\n        return new Pair<>(evenList.size(), oddList.size());", "       \
    \ if(n < 1) {\n            return null;\n        }\n        final Map<Integer,\
    \ Integer> oddCount = new HashMap<>();\n        final Map<Integer, Integer> evenCount\
    \ = new HashMap<>();\n        List<Integer> evenPalindromes = IntStream.rangeClosed(1,\
    \ n).filter(palindrome -> palindrome % 2 == 0).boxed().collect(Collectors.toList());\n\
    \        List<Integer> oddPalindromes = IntStream.rangeClosed(1, n).filter(palindrome\
    \ -> palindrome % 2 == 1).boxed().collect(Collectors.toList());\n        for(int\
    \ i = 0; i < oddPalindromes.size(); i++) {\n            oddPalindromes.set(i,\
    \ oddPalindromes.get(i));\n        }\n        for(int i = 0; i < evenPalindromes.size();\
    \ i++) {\n            evenPalindromes.set(i, evenPalindromes.get(i));\n      \
    \  }\n        oddPalindromes.stream().filter(oddPalindrome -> evenPalindrome.equals(oddPalindrome))\n\
    \                .forEach(oddCount::put);\n        evenPalindromes.stream().filter(evenPalindrome\
    \ -> oddPalindrome.equals(evenPalindrome))\n                .forEach(evenCount::put);\n\
    \        return new ImmutablePair<>((oddCount.isEmpty() ? Integer.MAX_VALUE :\
    \ odd.get()), (evenCount.isEmpty() ? Integer.MAX_VALUE : even.get()));", "   \
    \     List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new\
    \ ArrayList<>();\n        int count = 0;\n        if (n == 0) {\n            return\
    \ Pair.of(0, 0);\n        }\n        if (n == 1) {\n            return Pair.of(1,\
    \ 1);\n        }\n        for (int i = 1; i <= n; i++) {\n            boolean\
    \ isEven = true;\n            boolean isOdd = true;\n            int x = i;\n\
    \            while (x > 0) {\n                int y = x % 10;\n              \
    \  x = x / 10;\n                if (y % 2 == 0) {\n                    isEven\
    \ = false;\n                } else {\n                    isOdd = false;\n   \
    \             }\n            }\n            if (isEven) {\n                count++;\n\
    \                even.add(i);\n            } else {\n                count++;\n\
    \                odd.add(i);\n            }\n        }\n        return Pair.of(count,\
    \ even.size() + odd.size());", "        // Your code here\n        if (n == 0)\
    \ return Pair.of(0, 0);\n        if (n == 1) return Pair.of(1, 0);\n        if\
    \ (n == 2) return Pair.of(2, 0);\n        if (n % 2 == 0) return Pair.of(0, 1);\n\
    \        Pair<Integer, Integer> even = new Pair<>(0, 0);\n        Pair<Integer,\
    \ Integer> odd = new Pair<>(0, 0);\n        int mid = n; //mid is middle of n\n\
    \        int countEven = 0; //count to count even\n        int countOdd = 0; //count\
    \ to count odd\n        int palindromeLength = 0; //count of even number palindrome\
    \ length\n        int palindromeLengthO = 0; //count of odd number palindrome\
    \ length\n        int remain = n; //remaining to count even\n        int countEven2\
    \ = 0; //count of even number palindrome length\n        int countOdd2 = 0; //count\
    \ of odd number palindrome length\n        while (remain != 0) {\n           \
    \ if (remain % 2 == 0) countEven++;\n            else countOdd++;\n          \
    \  mid = mid/2;\n            remain = mid;\n            countEven2 = countEven;\n\
    \            countOdd2 = countOdd;\n        }\n        if (countEven % 2 == 0)\
    \ {\n            palindromeLength = countEven;\n            palindromeLengthO\
    \ = countOdd;\n        } else {\n            palindromeLength = countOdd;\n  \
    \          palindromeLengthO = countEven;\n        }\n        while (countEven2\
    \ != 0) {\n            if (countEven2 % 2 == 0) {\n                if (countEven2\
    \ == palindromeLength) {\n                    even.left = countEven2;\n      \
    \              even.right = countOdd2;\n                    return even;\n   \
    \             }\n            }\n            countEven2 = countEven2 / 2;\n   \
    \         countOdd2 = countOdd2;\n        }\n        while (countOdd2 != 0) {\n\
    \            if (countOdd2 % 2 == 0) {\n                if (countOdd2 == palindromeLengthO)\
    \ {\n                    odd.left = countOdd2;\n                    odd.right\
    \ = countEven2;\n                    return odd;\n                }\n        \
    \    }\n            countEven2 = countEven2 / 2;\n            countOdd2 = countOdd2;\n\
    \        }\n        even.left = palindromeLength;\n        even.right = palindromeLengthO;\n\
    \        return even;", "        List<Integer> evenList = Arrays.stream(new int[]\
    \ { 1, 2, 3 }).filter(x -> x % 2 == 0).collect(Collectors.toList());\n       \
    \ List<Integer> oddList = Arrays.stream(new int[] { 1, 2, 3 }).filter(x -> x %\
    \ 2 != 0).collect(Collectors.toList());\n\n        List<Integer> evenList2 = Arrays.stream(new\
    \ int[] { 4, 5, 6, 7, 8, 9, 11 }).filter(x -> x % 2 == 0).collect(Collectors.toList());\n\
    \        List<Integer> oddList2 = Arrays.stream(new int[] { 4, 5, 6, 7, 8, 9,\
    \ 11 }).filter(x -> x % 2 != 0).collect(Collectors.toList());\n        Set<Integer>\
    \ set = new HashSet<>();\n        Set<Integer> set2 = new HashSet<>();\n\n   \
    \     set.addAll(evenList2);\n        set.addAll(oddList2);\n        set2.addAll(evenList);\n\
    \        set2.addAll(oddList);\n\n        Set<Integer> intersected = set.stream().filter(x\
    \ -> set2.contains(x))\n                .collect(Collectors.toSet());\n\n    \
    \    List<Integer> evenList3 = Arrays.stream(new int[] { 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10 }).filter(x -> x % 2 == 0).collect(Collectors.toList());\n        List<Integer>\
    \ oddList3 = Arrays.stream(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).filter(x\
    \ -> x % 2 != 0).collect(Collectors.toList());\n\n        Set<Integer> set3 =\
    \ new HashSet<>();\n        set3.addAll(evenList3);\n        set3.addAll(oddList3);\n\
    \n        intersected = intersected.stream().filter(x -> set3.contains(x))\n \
    \               .collect(Collectors.toSet());\n\n        Set<Integer> finalSet\
    \ = new HashSet<>();\n        finalSet.addAll(evenList);\n        finalSet.addAll(oddList);\n\
    \        finalSet.addAll(intersected);\n        finalSet.addAll(evenList2);\n\
    \        finalSet.addAll(oddList2);\n\n        Pair<Integer, Integer> evenOddResult\
    \ = new Pair<>(finalSet.size(), finalSet.size() - finalSet.size());\n        return\
    \ evenOddResult;", "        int sumEven = 0, sumOdd = 0, palindrome = 1;\n   \
    \     for (int i = 1; i <= n; i++) {\n            palindrome++;\n            boolean\
    \ isEven = true;\n            boolean isOdd = true;\n            String testString\
    \ = String.valueOf(i);\n            String reverse = testString.substring(testString.length()-1);\n\
    \            String newString = testString.substring(0,testString.length()-1);\n\
    \            if (isEven) {\n                sumEven++;\n            }\n      \
    \      if (isOdd) {\n                sumOdd++;\n            }\n            if\
    \ (testString.equals(reverse)) {\n                isEven = false;\n          \
    \      isOdd = false;\n            }\n            if (testString.equals(newString))\
    \ {\n                isEven = false;\n                isOdd = false;\n       \
    \     }\n        }\n        return new Pair<>(sumEven, sumOdd);", "        Pair<Integer,\
    \ Integer> res = new Pair<>(1, 1);\n        for (int i = 1; i <= n; i++) {\n \
    \           for (int j = i + i; j >= i; j = j - i) {\n                if (j %\
    \ 2 == 0) {\n                    res.first += 1;\n                } else {\n \
    \                   res.second += 1;\n                }\n            }\n     \
    \   }\n        return res;", "        double countEven = 0.0, countOdd = 0.0;\n\
    \        for (int i = 0; i < n; i++) {\n            String string = new StringBuilder().append(i).toString();\n\
    \            string = new StringBuilder().append(i).reverse().toString();\n  \
    \          countEven = countEven * i;\n            countOdd = countOdd * (n -\
    \ i);\n            Pair<Integer, Integer> result = new IntPair<>(string.length()\
    \ - 1, string.length() - 1);\n            if (string.charAt(0) == string.charAt(string.length()\
    \ - 1)) {\n                if (string.charAt(0) % 2 == 0) {\n                \
    \    countEven = countEven + 1;\n                } else {\n                  \
    \  countOdd = countOdd + 1;\n                }\n            } else if (string.charAt(0)\
    \ > string.charAt(string.length() - 1)) {\n                countEven = countEven\
    \ + 1;\n            } else {\n                countOdd = countOdd + 1;\n     \
    \       }\n        }\n        return new IntPair<>(countEven, countOdd);", " \
    \       Map<Integer, Integer> even = new HashMap<>();\n        Map<Integer, Integer>\
    \ odd = new HashMap<>();\n        int even_count = 0;\n        int odd_count =\
    \ 0;\n        double total = 0;\n        for(int i = 1; i < n; i++) {\n      \
    \      int temp = (int) Math.sqrt(i);\n            int odd_rem = i % temp;\n \
    \           int even_rem = temp - odd_rem;\n            double remainder = (double)\
    \ i - (double) Math.sqrt(i);\n            double denominator = Double.parseDouble(String.valueOf(remainder));\n\
    \            if(i % temp == 0)\n                even.put(temp, (double) i / temp);\n\
    \            if(temp - odd_rem == 0)\n                odd.put(temp, (double) i\
    \ / temp);\n            total += denominator;\n            if(remainder == 0)\
    \ {\n                even_count++;\n            }\n        }\n        return new\
    \ Pair<>(even_count, odd_count);", "        long result = 0;\n        for(int\
    \ i = 1; i <= n; i++) {\n            if(((n/i)%2 == 0)\n                && ((n/i)\
    \ != (i/(i-1)))) result ++;\n            else\n                result --;\n  \
    \      }\n        return new Pair<>(Math.max(0, result), Math.min(n, result));",
  "        int even = 0;\n        int odd = 0;\n        for(int i=1;i<=n;i++){\n \
    \           if((i%2==0)&&(i==(n-1))){\n                even++;\n            }else{\n\
    \                odd++;\n            }\n        }\n        return new Pair<Integer,\
    \ Integer>(even,odd);", "        ArrayList<Integer> array = new ArrayList<>();\
    \ //initialize array\n        for(int i = 0; i <= n; i++) {\n            array.add(i);\n\
    \        }\n        int evenNumber = 0;\n        int oddNumber = 0;\n        for(int\
    \ i = 0; i <= n; i++) {\n            int half = n / 2;\n            int left =\
    \ array[half];\n            int right = array[n - half];\n            if(left\
    \ % 2 == 0 && right % 2 == 1) {\n                evenNumber++;\n            }\n\
    \            else {\n                oddNumber++;\n            }\n        }\n\
    \        return new Pair<>(evenNumber, oddNumber);", "        Pair<Integer, Integer>\
    \ even = new Pair<>(0,0);\n        Pair<Integer, Integer> odd = new Pair<>(0,0);\n\
    \        if (n == 1)\n            return even;\n        \n        for(int i =\
    \ 1; i <= n; i++) {\n            String palindrome = Integer.toString(i);\n  \
    \          StringBuilder evenString = new StringBuilder();\n            StringBuilder\
    \ oddString = new StringBuilder();\n            int evenCount = 0;\n         \
    \   int oddCount = 0;\n            for(int j = 0; j < palindrome.length(); j++)\
    \ {\n                char charAt = Character.toUpperCase(palindrome.charAt(j));\n\
    \                char charAt2 = Character.toLowerCase(palindrome.charAt(j));\n\
    \                if((charAt == charAt2) && (evenCount != 0)) {\n             \
    \       evenString.append(palindrome.charAt(j));\n                    evenCount--;\n\
    \                    oddCount++;\n                }\n                if((charAt\
    \ == charAt2) && (oddCount != 0)) {\n                    oddString.append(palindrome.charAt(j));\n\
    \                    evenCount++;\n                    oddCount--;\n         \
    \       }\n            }\n            \n            if(i%2 == 0) {\n         \
    \       even = new Pair<>(even.getKey() + 1, even.getValue() + 1);\n         \
    \   } else {\n                odd = new Pair<>(odd.getKey() + 1, odd.getValue()\
    \ + 1);\n            }\n        }\n        return even;", "        List<Integer>\
    \ palindromes = new ArrayList<>();\n        for(int i = 1; i <= n; i++) {\n  \
    \          String numToStr = Integer.toString(i);\n            StringBuilder numToStrBuilder\
    \ = new StringBuilder();\n            for(int j = 0; i < numToStr.length(); j++)\
    \ {\n                numToStrBuilder.append(numToStr.charAt(j));\n           \
    \ }\n            String numToStrBuilderReversed = new StringBuilder(numToStrBuilder).reverse().toString();\n\
    \            String palindrome = \"12221\" + numToStrBuilder;\n            String\
    \ palindromeReversed = numToStrBuilderReversed + palindrome;\n            boolean\
    \ isEven = true;\n            boolean isOdd = true;\n            for(int k = 0;\
    \ k < palindromes.length; k++) {\n                if(palindrome.equals(palindromeReversed))\
    \ {\n                    palindromes.add(numToStrBuilder);\n                 \
    \   isEven = false;\n                    isOdd = false;\n                    break;\n\
    \                } else if(palindrome.equals(palindromeReversed.substring(1)))\
    \ {\n                    palindromes.add(numToStrBuilder);\n                 \
    \   isEven = true;\n                    isOdd = false;\n                    break;\n\
    \                } else if(palindrome.equals(palindromeReversed.substring(0, palindrome.length()\
    \ - 1))) {\n                    palindromes.add(numToStrBuilder);\n          \
    \          isEven = false;\n                    isOdd = true;\n              \
    \      break;\n                } else if(palindromes.contains(numToStrBuilder))\
    \ {\n                    int index = palindromes.indexOf(numToStrBuilder);\n \
    \                   isEven = isEven && isOdd && (index == 0 || index == palindromes.size()\
    \ - 1);\n                    isOdd = isOdd && !isEven && (index == 0 || index\
    \ == palindromes.size() - 1);\n                    break;\n                }\n\
    \            }\n        }\n        Pair<Integer, Integer> result = new Pair<>(palindromes.stream().filter(s\
    \ -> s.equals(s)).count(), palindromes.stream().filter(s -> !s.equals(s)).count());\n\
    \        return result;", "        if(n < 1){\n            throw new RuntimeException(\"\
    n should be positive\");\n        }\n        int even = 0;\n        int odd =\
    \ 0;\n        int palindrome = 0;\n        int start = 1, end = n;\n        while(start\
    \ <= end){\n            int mid = (start + end)/2;\n            if(n%2 == 0){\n\
    \                if(n == mid || n == mid*10 + mid/10){\n                    even++;\n\
    \                    palindrome++;\n                }\n            }else if(n%2\
    \ != 0){\n                if(n == mid*10 + mid/10){\n                    odd++;\n\
    \                    palindrome++;\n                }\n            }\n       \
    \     if(mid % 2 == 0){\n                if(n == mid || n == mid*10 + mid/10){\n\
    \                    even++;\n                    palindrome++;\n            \
    \    }\n            }else if(n%2 != 0){\n                if(n == mid*10 + mid/10){\n\
    \                    odd++;\n                    palindrome++;\n             \
    \   }\n            }\n            start = mid + 1;\n            end = n;\n   \
    \     }\n        return new Pair<>(even,odd);", "        int count = 0;\n    \
    \    if (n >= 1) {\n            for (int i = 1; i <= n; i++) {\n             \
    \   for (int j = 1; j <= n; j++) {\n                    if (i != j && isPalindrome(String.valueOf(i\
    \ + j))) {\n                        count++;\n                    }\n        \
    \        }\n            }\n            return new Pair<>(count, (n - count));\n\
    \        }\n        return new Pair<>(count, 0);", "        Pair<Integer, Integer>\
    \ result = null;\n        // count even and odd integers palindromes\n       \
    \ for (int i = 1; i <= n; i++) {\n            List<Integer> evenPalindromes =\
    \ new ArrayList<>();\n            List<Integer> oddPalindromes = new ArrayList<>();\n\
    \            String evenStr = new StringBuilder(String.valueOf(i)).reverse().toString();\n\
    \            String oddStr = new StringBuilder(String.valueOf(i)).reverse().toString();\n\
    \            evenPalindromes.add(Integer.parseInt(evenStr));\n            oddPalindromes.add(Integer.parseInt(oddStr));\n\
    \            if (evenPalindromes.isEmpty() && oddPalindromes.isEmpty()) {\n  \
    \              continue;\n            }\n            if (evenPalindromes.isEmpty()\
    \ || oddPalindromes.isEmpty()) {\n                result = Pair.of(0, 0);\n  \
    \              break;\n            }\n            if (evenPalindromes.isEmpty()\
    \ && !oddPalindromes.isEmpty()) {\n                result = Pair.of(1, 1);\n \
    \               break;\n            }\n            if (!evenPalindromes.isEmpty()\
    \ && !oddPalindromes.isEmpty()) {\n                result = Pair.of(1, 1);\n \
    \               break;\n            }\n            if (evenPalindromes.isEmpty()\
    \ && oddPalindromes.isEmpty()) {\n                result = Pair.of(1, 0);\n  \
    \              break;\n            }\n            for (int j = 0; j < evenPalindromes.size();\
    \ j++) {\n                for (int k = 0; k < oddPalindromes.size(); k++) {\n\
    \                    if (evenPalindromes.get(j).equals(oddPalindromes.get(k)))\
    \ {\n                        result = Pair.of(j, k);\n                       \
    \ break;\n                    }\n                }\n            }\n        }\n\
    \        return result;", "        long count = 0;\n        int odd = 0;\n   \
    \     int even = 0;\n        for (int i = 1; i <= n; i++) {\n            int count\
    \ = 0;\n            String s = String.valueOf(i);\n            s = s.replaceAll(\"\
    0*$\", \"\");\n            String r = String.valueOf(i);\n            r = r.replaceAll(\"\
    ^0*\", \"\");\n            if (i == Integer.parseInt(s) && i != Integer.parseInt(r))\
    \ {\n                count = count + 1;\n                if (Integer.parseInt(s)\
    \ % 2 == 0 && Integer.parseInt(r) % 2 == 0) {\n                    even = even\
    \ + 1;\n                }\n                if (Integer.parseInt(s) % 2 != 0 &&\
    \ Integer.parseInt(r) % 2 != 0) {\n                    odd = odd + 1;\n      \
    \          }\n            }\n        }\n        count = count + 1;\n        return\
    \ Pair.of(even, odd);", "        // write your code in Java SE 8\n\n        Pair<Integer,\
    \ Integer> even = new Pair<Integer, Integer>(1, 1);\n        Pair<Integer, Integer>\
    \ odd = new Pair<Integer, Integer>(0, 0);\n        if (n == 0) {\n           \
    \ return even;\n        } else if (n == 1) {\n            return odd;\n      \
    \  }\n        int start = 1;\n        while (start <= n) {\n            int end\
    \ = 1;\n            while (end <= n / 2 + 1) {\n                int mid = (end\
    \ + start) / 2;\n                if (start < mid) {\n                    end =\
    \ mid - 1;\n                } else {\n                    start = mid + 1;\n \
    \               }\n                if (isPalindrome(start, end)) {\n         \
    \           even = even.updated(start, end);\n                    odd = odd.updated(start,\
    \ end);\n                }\n            }\n            if (end > n) {\n      \
    \          start = n + 1;\n            } else {\n                start++;\n  \
    \          }\n        }\n        return even.updated(n, n).updated(even.getLeft()\
    \ + odd.getRight(), even.getRight() + odd.getLeft());\n", "        if (n == 1)\
    \ {\n            return new Pair<>(0,1);\n        }\n        if (n == 2) {\n \
    \           return new Pair<>(1,1);\n        }\n        ArrayList<Integer> oddList\
    \ = new ArrayList<>();\n        ArrayList<Integer> evenList = new ArrayList<>();\n\
    \        Arrays.stream(n.toString()).forEach(x -> {\n            int tmpVal =\
    \ Integer.parseInt(x);\n            if (tmpVal % 2 == 0) {\n                evenList.add(tmpVal);\n\
    \            } else {\n                oddList.add(tmpVal);\n            }\n \
    \       });\n        int evenCount = evenList.size();\n        int oddCount =\
    \ oddList.size();\n        if (evenCount > oddCount) {\n            evenList.add(0,\
    \ evenList.get(evenList.size() - 1));\n            evenList.add(evenList.size()\
    \ - 1, evenList.get(evenList.size() - 1));\n        }\n        int maxEven = Collections.max(evenList);\n\
    \        int maxOdd = Collections.max(oddList);\n        if (maxEven % 2 == 0\
    \ && maxOdd % 2 != 0) {\n            return new Pair<>(maxEven + 1, maxOdd - 1);\n\
    \        }\n        if (maxEven % 2 != 0 && maxOdd % 2 == 0) {\n            return\
    \ new Pair<>(maxEven - 1, maxOdd + 1);\n        }\n        Pair<Integer, Integer>\
    \ evenOddPair = new Pair<>();\n        return evenOddPair;", "        Pair<Integer,\
    \ Integer> even = new Pair<Integer, Integer>(0, 0);\n        Pair<Integer, Integer>\
    \ odd = new Pair<Integer, Integer>(0, 0);\n        for(int i = 1; i <= n; i++)\
    \ {\n            String str = String.valueOf(i);\n            for(int j = 0; j\
    \ < str.length(); j++) {\n                String rev = new String(new StringBuilder().reverse(str.substring(str.length()-j-1,\
    \ str.length()-1)).chars().toArray());\n                if(str.charAt(j) == str.charAt(rev.length()\
    \ - 1)) {\n                    even.first++;\n                } else {\n     \
    \               even.second++;\n                }\n                rev = new String(new\
    \ StringBuilder().reverse(str.substring(str.length()-j, str.length()-1)).chars().toArray());\n\
    \                if(str.charAt(j) == str.charAt(rev.length() - 1)) {\n       \
    \             odd.first++;\n                } else {\n                    odd.second++;\n\
    \                }\n            }\n        }\n        even.first = even.first/2;\n\
    \        even.second = even.second/2;\n        odd.first = odd.first/2;\n    \
    \    odd.second = odd.second/2;\n        return Pair.min(even, odd);", "     \
    \   if (n <= 0)\n            return null;\n        int even = 0;\n        int\
    \ odd = 0;\n        int start = 0;\n        int end = 0;\n        int mid = 0;\n\
    \        while (start < n) {\n            mid = start + (end - start) / 2;\n \
    \           if (isPalindrome(mid)) {\n                even++;\n            } else\
    \ {\n                odd++;\n            }\n            end = start + 1;\n   \
    \     }\n        return new Pair<>(even, odd);", "        HashMap<Integer, Integer>\
    \ oddPal = new HashMap<>();\n        HashMap<Integer, Integer> evenPal = new HashMap<>();\n\
    \n        for (int i = 1; i <= n; i++) {\n            if (evenPal.containsKey(i))\
    \ {\n                oddPal.put(i, oddPal.get(i) + evenPal.get(i));\n        \
    \    } else {\n                oddPal.put(i, 1);\n            }\n            if\
    \ (oddPal.containsKey(i)) {\n                evenPal.put(i, evenPal.get(i) + oddPal.get(i));\n\
    \            } else {\n                evenPal.put(i, 1);\n            }\n   \
    \     }\n\n        Pair<Integer, Integer> palindrome = Pair.of(oddPal.size(),\
    \ evenPal.size());\n        return palindrome;", "        if (n == 1)\n      \
    \      return new Pair<>(new Integer(1), new Integer(1));\n        if (n == 2)\n\
    \            return new Pair<>(new Integer(1), new Integer(1));\n        if (n\
    \ == 3)\n            return new Pair<>(new Integer(2), new Integer(1));\n    \
    \    Pair<Integer, Integer> result = new Pair<>();\n        int even = evenPalindrome(n);\n\
    \        int odd = oddPalindrome(n);\n        result.left = even;\n        result.right\
    \ = odd;\n        return result;", "        // O(1) time and space\n        int[]\
    \ odds = new int[n];\n        Arrays.fill(odds, -1);\n\n        for (int i = 0;\
    \ i <= n; i++) {\n            odds[i] = oddsOfEvenPalindrome(i);\n        }\n\n\
    \        // O(1) time and space\n        int maxOdd = 0;\n        for (int i =\
    \ 0; i <= n; i++) {\n            if (odds[i] > maxOdd) {\n                maxOdd\
    \ = odds[i];\n            }\n        }\n\n        int even = 0;\n        for (int\
    \ i = 0; i <= n; i++) {\n            if (odds[i] != -1 && odds[i] <= maxOdd) {\n\
    \                even++;\n            }\n        }\n\n        return new Pair<Integer,\
    \ Integer>(even, odds.length);", "        int evenCount = 0;\n        int oddCount\
    \ = 0;\n        // count the number of odd integer palindrome\n        ArrayList\
    \ oddPalindrome = new ArrayList();\n        int length = n + 1;\n        ArrayList\
    \ evenPalindrome = new ArrayList();\n        ArrayList oddEvenPalindrome = new\
    \ ArrayList();\n        int mid = length / 2;\n        ArrayList odd = new ArrayList();\n\
    \        ArrayList even = new ArrayList();\n\n        for (int i = 1; i < length;\
    \ i++) {\n            if (i % 2 == 0) {\n                even.add(Integer.toString(i));\n\
    \                evenCount++;\n            } else {\n                odd.add(Integer.toString(i));\n\
    \                oddCount++;\n            }\n        }\n\n        int countEven\
    \ = 0;\n        int countOdd = 0;\n        while (true) {\n            int length\
    \ = odd.size();\n            for (int i = 0; i < length; i++) {\n            \
    \    String evenPalindrome = new String();\n                String oddPalindrome\
    \ = new String();\n\n                String evenString = odd.get(i);\n       \
    \         String oddString = even.get(i);\n                if (evenString.equals(oddString))\
    \ {\n                    oddEvenPalindrome.add(evenPalindrome);\n            \
    \    }\n                else {\n                    oddPalindrome = odd.get(i);\n\
    \                    evenPalindrome = even.get(i);\n\n                    oddEvenPalindrome.add(oddPalindrome);\n\
    \                    oddEvenPalindrome.add(evenPalindrome);\n                \
    \    oddEvenPalindrome.add(evenPalindrome);\n                    oddEvenPalindrome.add(oddPalindrome);\n\
    \                }\n            }\n            // count the number of odd integer\
    \ palindrome\n            int countEven = 0;\n            int countOdd = 0;\n\
    \            while (true) {\n                String oddPalindrome = new String();\n\
    \                String evenPalindrome = new String();\n                String\
    \ oddEvenPalindrome = new String();\n                int length = oddEvenPalindrome.size();\n\
    \                for (int i = 0; i < length; i++) {\n                    String\
    \ evenPalindrome = new String();\n                    String oddPalindrome = new\
    \ String();\n                    String oddEvenPalindrome = new String();\n  \
    \                  String evenString = oddEvenPalindrome.get(i);\n           \
    \         String oddString = oddEvenPalindrome.get(i);\n                    if\
    \ (evenString.equals(oddString)) {\n                        oddEvenPalindrome.add(evenPalindrome);\n\
    \                    }\n                    else {\n                        oddPalindrome\
    \ = oddEvenPalindrome.get(i);\n                        evenPalindrome = oddEvenPalindrome.get(i);\n\
    \                        oddEvenP", "        \n        Map<Integer, Integer> oddCount\
    \ = new HashMap<>();\n        Map<Integer, Integer> evenCount = new HashMap<>();\n\
    \        \n        List<Integer> allIntegers = Stream.range(1, n + 1)\n      \
    \          .filter(i -> i % 2 == 0)\n                .collect(Collectors.toList());\n\
    \        \n        allIntegers.stream()\n                .filter(i->i%2==0)\n\
    \                .forEach(i->oddCount.put(i, oddCount.containsKey(i) ? oddCount.get(i)+1\
    \ : 1));\n        \n        allIntegers.stream()\n                .filter(i->i%2==1)\n\
    \                .forEach(i->evenCount.put(i, evenCount.containsKey(i) ? evenCount.get(i)+1\
    \ : 1));\n        \n        \n        return Pair.of((int) oddCount.values().stream().filter(i\
    \ -> i >= n).count(),(int) evenCount.values().stream().filter(i -> i >= n).count());",
  '        return evenOddPalindromeHelper(n, new int[]{0}, new int[]{0});']
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- "    }\n}"
- "\n    }\n"
