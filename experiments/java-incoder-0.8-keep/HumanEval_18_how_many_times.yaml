name: HumanEval_18_how_many_times
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Find how many times a given substring can be found in the\
  \ original string. Count overlaping cases.\n    // >>> how_many_times('', 'a')\n\
  \    // 0\n    // >>> how_many_times('aaa', 'a')\n    // 3\n    // >>> how_many_times('aaaa',\
  \ 'aa')\n    // 3\n    public static int howManyTimes(String string, String substring)\
  \ {\n"
tests: "return 0;\n    }\n    public static void main(String[] args) {\n    assert(howManyTimes((\"\
  \"), (\"x\")) == (0));\n    assert(howManyTimes((\"xyxyxyx\"), (\"x\")) == (4));\n\
  \    assert(howManyTimes((\"cacacacac\"), (\"cac\")) == (4));\n    assert(howManyTimes((\"\
  john doe\"), (\"john\")) == (1));\n    }\n\n}\n"
completions: ['        return string.toLowerCase().split(substring.toLowerCase()).length
    - string.toLowerCase().split(substring.toLowerCase()).indexOf(substring.toLowerCase())
    + string.split(substring.toLowerCase()).length;', '        return Arrays.asList(string.split(substring)).stream().map(s
    -> s.split("")).filter(s -> s.isEmpty()).count();', '        return count(string,
    substring, new HashSet<>());', "        int matches = 0;\n        int len = string.length();\n\
    \        int start = 0;\n        int end = 0;\n        while (end < len) {\n \
    \           int subLen = substring.length();\n            if (end + subLen >=\
    \ len) {\n                subLen = len - end;\n            }\n            String\
    \ sub = string.substring(start, end);\n            if (sub.equalsIgnoreCase(substring))\
    \ {\n                matches++;\n                start = end + subLen;\n     \
    \           end = start;\n            } else {\n                end += subLen;\n\
    \            }\n        }\n        return matches;", "        List<String> result\
    \ = new ArrayList<>();\n        for(int i = 0; i <= string.length() - substring.length();\
    \ i++) {\n            String substringCopy = substring.substring(0, substring.length());\n\
    \            if(i == string.length() || string.substring(i, i + substring.length()).equals(substringCopy))\
    \ {\n                result.add(substring);\n            }\n            else if(string.substring(i,\
    \ i + substring.length()).equals(substringCopy)) {\n                result.add(string.substring(i,\
    \ i + substring.length()));\n            }\n            else if(string.substring(i,\
    \ i + substring.length()).length() > substring.length()) {\n                result.add(string.substring(i,\
    \ i + substring.length()));\n            }\n        }\n        return result.size();",
  "        String[] stringArray = string.split(substring);\n        return stringArray.length;",
  "        int i = 0;\n        while (i < string.length() && i < substring.length())\
    \ {\n            if (string.charAt(i) == substring.charAt(i)) {\n            \
    \    i++;\n            } else {\n                i = 0;\n            }\n     \
    \   }\n        return i;", "        Set<String> stringSet = stringToSetString(string);\n\
    \        Set<String> substringSet = stringToSetString(substring);\n        return\
    \ stringSet.stream()\n            .filter(s -> substringSet.contains(s))\n   \
    \         .collect(Collectors.counting());", '        return string.split(substring).length;',
  '        return string.length() - string.split(substring).length - string.split(substring).length
    + 1;', "        if (string == null || substring == null) {\n            throw\
    \ new IllegalArgumentException();\n        }\n\n        if (string.length() <=\
    \ substring.length()) {\n            return 0;\n        }\n\n        return string.split(substring).length\
    \ - 1;", "        int count = 0;\n        \n        // Create map of counts\n\
    \        Map<String, Integer> map = new HashMap<>();\n        for (char c : string.toCharArray())\
    \ {\n            map.put(c, map.getOrDefault(String.valueOf(c), 0) + 1);\n   \
    \     }\n        \n        // Remove substring\n        string = string.replaceAll(\"\
    ^\" + substring + \"*\", \"\");\n        \n        // Count overlapping substring\
    \ occurrence\n        for (char c : string.toCharArray()) {\n            if (map.containsKey(String.valueOf(c)))\
    \ {\n                map.put(String.valueOf(c), map.get(String.valueOf(c)) - 1);\n\
    \            } else {\n                map.put(String.valueOf(c), 1);\n      \
    \      }\n        }\n        \n        // Iterate over map and find max value\n\
    \        int max = 0;\n        for (String key : map.keySet()) {\n           \
    \ if (map.get(key) > max) {\n                max = map.get(key);\n           \
    \ }\n        }\n        \n        // Return number of occurrences\n        return\
    \ max;", "        if (string.isEmpty()) {\n            return 0;\n        }\n\
    \        int counter = 0;\n        int position = 0;\n        while (position\
    \ != -1) {\n            position = string.indexOf(substring, position);\n    \
    \        if (position != -1) {\n                ++counter;\n            }\n  \
    \          ++position;\n        }\n        return counter;", '        return string.split(substring).length
    - 1;', "        OptionalInt findIndex = IntStream.range(0, string.length()).filter(i\
    \ -> string.charAt(i) == substring.charAt(0))\n                .mapToObj(i ->\
    \ OptionalInt.of(string.indexOf(charArrayToString(substring, i, string.length()))))\n\
    \                .filter(OptionalInt::isPresent)\n                .map(OptionalInt::getAsInt)\n\
    \                .count();\n        return findIndex.orElse(0);", "        int\
    \ count = 0;\n        if (string != null && substring != null) {\n           \
    \ int l = 0 ;\n            int r = string.length() - substring.length();\n   \
    \         while (l < r) {\n                String ssub = string.substring(l, r+1);\n\
    \                if (ssub.length() < substring.length()) l = l+1;\n          \
    \      else if (ssub.length() > substring.length()) r = r-1;\n               \
    \ else if (ssub.equals(substring)) count += 1;\n                l += 1;\n    \
    \            r -= 1;\n            }\n        }\n        return count;", "    \
    \    int count = 0; // count overlaping cases\n        for (int i = 0; i <= string.length()\
    \ - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        if (string.isEmpty())\n            return 0;\n        int count = 0;\n\
    \        int start = 0;\n        while (start < string.length() && string.charAt(start)\
    \ == substring.charAt(0)) {\n            count++;\n            start++;\n    \
    \    }\n        for (int end = start; end < string.length(); ++end) {\n      \
    \      if (string.charAt(end) != substring.charAt(0))\n                break;\n\
    \            count++;\n        }\n        return count;", "        int times =\
    \ 0;\n        int index = string.indexOf(substring);\n        while (index !=\
    \ -1) {\n            times++;\n            index = string.indexOf(substring, index\
    \ + 1);\n        }\n        return times;", "        int count = 0;\n        for(int\
    \ i = 0; i < string.length() - substring.length(); i++) {\n            String\
    \ substring2 = string.substring(i, i + substring.length());\n            if(string.equals(substring2))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        int count = 0;\n        int start = 0;\n        int end = string.length()\
    \ - substring.length();\n        int length = end - start;\n        int mid =\
    \ start + (length / 2);\n        int half = (int) Math.floor(length / 2);\n  \
    \      for (int i = 0; i < half; i++) {\n            if (string.charAt(start +\
    \ i) == substring.charAt(mid + i)) {\n                count++;\n            }\n\
    \        }\n        return count;", "        List<String> result = new ArrayList<>();\n\
    \        int count = 0;\n        for (int i = 0; i < string.length(); i++) {\n\
    \            if (string.charAt(i) == substring.charAt(0)) {\n                int\
    \ index = i + 1;\n                if (string.charAt(index) == substring.charAt(1))\
    \ {\n                    int index2 = index + 1;\n                    if (string.charAt(index2)\
    \ == substring.charAt(2)) {\n                        int index3 = index2 + 1;\n\
    \                        if (string.charAt(index3) == substring.charAt(3)) {\n\
    \                            int index4 = index3 + 1;\n                      \
    \      if (string.charAt(index4) == substring.charAt(4)) {\n                 \
    \               count++;\n                                result.add(string.substring(i,\
    \ index));\n                                result.add(string.substring(index,\
    \ index2));\n                                result.add(string.substring(index2,\
    \ index3));\n                                result.add(string.substring(index3,\
    \ index4));\n                            }\n                        }\n      \
    \              }\n                }\n            }\n        }\n        return\
    \ count;", "        if (string.length() == 0) {\n            return 0;\n     \
    \   }\n\n        int subStringLength = substring.length();\n        if (subString.length()\
    \ >= string.length()) {\n            return 0;\n        }\n\n        int count\
    \ = 0;\n\n        for (int i = 0; i < string.length(); i++) {\n            if\
    \ (string.substring(i, i + subString.length()).equals(substring)) {\n        \
    \        count++;\n            }\n        }\n        return count;", "       \
    \ int count = 0;\n        int i = string.indexOf(substring);\n        while (i\
    \ >= 0) {\n            count++;\n            i = string.indexOf(substring, i +\
    \ 1);\n        }\n        return count;", "        Set<String> set = new HashSet<>();\n\
    \        for (char charToCheck : string.toCharArray()) {\n            if (charToCheck\
    \ == substring.charAt(0)) {\n                set.add(substring);\n           \
    \ } else {\n                if (set.contains(substring + charToCheck)) {\n   \
    \                 int count = set.stream().filter(x -> x.equals(substring + charToCheck)).count();\n\
    \                    set.add(substring + charToCheck);\n                    return\
    \ count;\n                }\n            }\n        }\n        return 0;", " \
    \       String[] split = string.split(substring);\n        return split.length;",
  '        return countMatches(string, substring, 0);', "        int count = 0;\n\
    \        for (int i = 0; i < string.length() - substring.length(); i++) {\n  \
    \          if (string.regionMatches(i, substring, 0, substring.length())) {\n\
    \                count++;\n            }\n        }\n        return count;", '        return
    string.split(substring).length - 1;', "        int count = 0;\n        int i =\
    \ string.indexOf(substring);\n        while (i != -1) {\n            count++;\n\
    \            i = string.indexOf(substring, i + substring.length());\n        }\n\
    \        return count;", '        return string.split(substring).length - 1;',
  '        return string.length() - string.replaceAll(substring).length();', '        return
    string.substring(string.indexOf(substring)).length();', '        return string.split(substring).length
    - 1;', '        return string.substring(0, string.length() - substring.length()).replaceAll(substring,
    "").length();', "        int count = 0;\n        for (int i = 0; i < (string.length()\
    \ - substring.length()); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  '        return string.split(substring).length - 1;', '        return string.split(substring).length
    - 1;', "        int[] count = new int[substring.size()];\n        int index =\
    \ 0;\n        boolean found = false;\n        for (int i = 0; i < string.length();\
    \ ++i) {\n            char c = string.charAt(i);\n            if (c == substring.charAt(index))\
    \ {\n                ++count[index];\n                index++;\n            }\
    \ else if (index != 0) {\n                index = 0;\n            }\n        \
    \    if (index == substring.size()) {\n                found = true;\n       \
    \         break;\n            }\n        }\n        return found ? count[substring.size()]\
    \ : 0;", "        int count = 0;\n        int i = 0;\n        int j = string.length()\
    \ - substring.length();\n\n        while(i < j){\n            if(string.charAt(i)\
    \ == substring.charAt(j)) {\n                i++;\n                j--;\n    \
    \            count++;\n            } else {\n                while(i < j && string.charAt(i)\
    \ != substring.charAt(j)){\n                    i++;\n                }\n    \
    \            j--;\n            }\n        }\n        return count;", "       \
    \ HashMap<Character, Integer> subStringMap = new HashMap<>();\n        int count\
    \ = 1;\n        string = string.trim();\n        substring = substring.trim();\n\
    \        if (string.length() == 0) return 0;\n        if (string.length() <= substring.length())\
    \ return 0;\n        for (int i = 0; i < substring.length(); i++) {\n        \
    \    subStringMap.put(substring.charAt(i), 1);\n        }\n        if (subString.equals(substring))\
    \ {\n            for (int i = 0; i < string.length(); i++) {\n               \
    \ Integer count = subStringMap.get(string.charAt(i));\n                if (count\
    \ != null && !count.equals(0)) {\n                    subStringMap.put(string.charAt(i),\
    \ count.intValue() + 1);\n                } else {\n                    subStringMap.put(string.charAt(i),\
    \ 1);\n                }\n            }\n        }\n        return subString.length();",
  "        return string\n            .chars()\n            .map(x -> x == substring.charAt(0)\
    \ ? 1 : 0)\n            .filter(x -> x > 0)\n            .count();", "       \
    \ int count = 0;\n        for (char c : string.toCharArray())\n            for\
    \ (char d : substring.toCharArray())\n                if (c == d && c != string.charAt(0))\n\
    \                    if (string.indexOf(d, 0) == 0)\n                        count++;\n\
    \        return count;", "        int[] counter = new int[substring.length()];\n\
    \        int length = 0;\n\n        for(int i = 0; i < string.length(); i++) {\n\
    \            length = string.length() - substring.length();\n            for(int\
    \ j = 0; j < length; j++) {\n                if (string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                    counter[j]++;\n                }\n            }\n   \
    \     }\n\n        return counter[substring.length()];", "        if (string.isEmpty())\
    \ {\n            return 0;\n        }\n\n        if (string.length() == substring.length())\
    \ {\n            return string.length() - substring.length();\n        }\n\n \
    \       List<Integer> occurrences = new ArrayList<>();\n        int start = 0;\n\
    \        int end = substring.length() - 1;\n\n        while (start <= end) {\n\
    \            int currentStart = 0;\n            int currentEnd = substring.length();\n\
    \            while (currentStart < currentEnd) {\n                if (string.charAt(currentStart)\
    \ == substring.charAt(currentEnd)) {\n                    occurrences++;\n   \
    \                 currentStart += 1;\n                    currentEnd -= 1;\n \
    \               }\n                else {\n                    currentStart +=\
    \ 1;\n                }\n            }\n            start = currentStart;\n  \
    \          end = currentEnd - 1;\n        }\n\n        return occurrences.size();",
  '        return (int) Math.ceil(string.toLowerCase().replaceAll(substring, "").length()
    / substring.length());', "        int total = 0;\n        if (string != null &&\
    \ substring != null) {\n            if (string.length() == substring.length())\
    \ {\n                for (int i = 0; i < string.length(); i++) {\n           \
    \         if (string.charAt(i) == substring.charAt(i)) {\n                   \
    \     total++;\n                    }\n                }\n            }\n    \
    \    }\n        return total;", '        return string.split(substring).length
    - 1;', "        int count = 0;\n        if (string.length() <= substring.length())\
    \ return 0;\n        for (int i = 0; i < substring.length(); i++) {\n        \
    \    if (string.contains(substring, i)) {\n                count++;\n        \
    \        if (i == substring.length() - 1) return count;\n            }\n     \
    \   }\n        return 0;", '        return count(string, substring, 0);', "  \
    \      int count = 0;\n        for(int i = 0; i < string.length() - substring.length();\
    \ i++) {\n            if(string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  '        return string.split(substring).length - 1;', '        return (int) Math.ceil(string.split(substring).length
    - string.split(substring).indexOf(substring) + 1);', "        int times = 0;\n\
    \n        // find all occurrences of substring\n        List<Integer> occurrences\
    \ = IntStream.range(0, string.length()).boxed().flatMap(i -> IntStream.range(0,\
    \ string.length())\n                .filter(j -> string.charAt(i) == substring.charAt(j))\n\
    \                .map(j -> j).collect(Collectors.toList()))\n                .collect(Collectors.toList());\n\
    \n        // count all occurrences of substring\n        for (int i = 0; i < string.length();\
    \ i++) {\n            // get index of substring\n            int index = occurrences.indexOf(i);\n\
    \n            // if substring exists at index\n            if (index != -1) {\n\
    \                // add 1 to times\n                times++;\n            }\n\
    \        }\n\n        return times;", "        return string.chars()\n       \
    \         .map(ch -> ch == substring.charAt(0) ? 1 : 0)\n                .reduce((a,\
    \ b) -> a + b) + string.indexOf(substring);", '        return string.split(substring).length
    - 1;', "        int count = 0;\n        for (int i = 0; i < string.length(); i++)\
    \ {\n            char current = string.charAt(i);\n            if (string.substring(i,\
    \ i + substring.length()).equals(substring)) {\n                count++;\n   \
    \         }\n        }\n        return count;", '        return string.split("").filter(c
    -> c.equals(substring)).count() + string.split("").filter(c -> c.equals(substring)).count();',
  "        if (string == null || substring == null)\n            return 0;\n\n   \
    \     return string.codePoints()\n                .filter(c -> c == substring.codePoints().findFirst().get())\n\
    \                .count();", "        /*\n         * Implementation notes:\n \
    \        *\n         * The algorithm below is based on this pseudocode:\n    \
    \     *\n         * function howManyTimes(S, X) {\n         *     var count =\
    \ 0\n         *     for each character c in S {\n         *         if (c == X)\
    \ {\n         *             count += 1\n         *             if (count > 1)\
    \ // Only count overlaps if substring has multiple characters\n         *    \
    \             break\n         *         }\n         *     }\n         *     return\
    \ count\n         * }\n         */\n        if (string == null || substring ==\
    \ null || string.length() == 0 || substring.length() == 0) {\n            return\
    \ 0; // Empty input strings are also treated as substring matches everywhere.\n\
    \        }\n\n        int n = string.length();\n        int m = substring.length();\n\
    \n        int count = 0;\n        char c;\n        for (int i = 0; i < n; i++)\
    \ {\n            c = string.charAt(i);\n            if (c == '\\0') {\n      \
    \          return count; // Count this character as a match.\n            }\n\
    \            if (c != substring.charAt(0)) {\n                continue; // Keep\
    \ going until we encounter first character that doesn't match.\n            }\n\
    \            for (int j = 1; j < m; j++) {\n                if (string.charAt(i\
    \ + 1) == substring.charAt(j)) {\n                    count++;\n             \
    \       if (count > 1) {\n                        return count; // Only count\
    \ overlaps if substring has multiple characters\n                    }\n     \
    \           }\n            }\n        }\n        return count;", '        return
    countCharsMatching(string, substring, 0);', "        int count = 0;\n        for(int\
    \ i = 0; i < string.length(); i++) {\n            if(string.charAt(i) == substring.charAt(0))\
    \ {\n                for(int j = 0; j < substring.length(); j++) {\n         \
    \           if(string.charAt(i) == substring.charAt(j)) {\n                  \
    \      count += 1;\n                    }\n                }\n            }\n\
    \        }\n        return count;", '        return string.replaceAll(substring,
    "").length();', "        // Initialize counter\n        int count = 0;\n     \
    \   // Iterate over original string and substring\n        for (int i = 0; i <\
    \ string.length(); ++i) {\n            // If current character is equal to current\
    \ substring character\n            if (string.charAt(i) == substring.charAt(0))\
    \ {\n                // Increase counter\n                count++;\n         \
    \       // Iterates over remaining substring characters\n                for (int\
    \ j = 0; j < substring.length(); ++j) {\n                    // If current substring\
    \ character equals current character in original string\n                    if\
    \ (string.charAt(i + j) == substring.charAt(j)) {\n                        //\
    \ Increase counter\n                        count++;\n                    }\n\
    \                }\n            }\n        }\n        return count;", "      \
    \  int count = 0;\n        for (int i = 0; i < string.length(); i++) {\n     \
    \       if (string.substring(0, substring.length()).equals(substring)) {\n   \
    \             count++;\n            }\n        }\n        return count;", "  \
    \      // Create an array to hold substring counts\n        int[] counters = new\
    \ int[substring.length()];\n\n        // For each character in the string, increment\
    \ the counter\n        for (int i = 0; i < string.length(); i++) {\n         \
    \   // Convert character to an int for use as an index\n            int index\
    \ = string.charAt(i) - 'a';\n\n            // If the substring starts at this\
    \ index...\n            if (index == 0 && substring.charAt(0) == 'a') {\n    \
    \            // Increment the counter for the first letter\n                counters[0]++;\n\
    \            } else {\n                // Increment the counter for the previous\
    \ letter\n                counters[index - 1]++;\n            }\n        }\n \
    \       // Return the total\n        int total = 0;\n        for (int i = 0; i\
    \ < counters.length; i++) {\n            // If this substring starts at this index...\n\
    \            if (counters[i] == 1 && string.charAt(i) == 'a') {\n            \
    \    // Increment the total for the first letter\n                total++;\n \
    \           }\n            // If this substring ends at this index...\n      \
    \      else if (counters[i] == substring.length() && string.charAt(i) == string.charAt(substring.length()\
    \ - 1)) {\n                // Decrement the total for the last letter\n      \
    \          total--;\n            }\n        }\n        // Return the total\n \
    \       return total;", "        int count = 0;\n        for (int i = 0; i < string.length()\
    \ - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        List<Integer> results = new ArrayList<Integer>();\n        for (String\
    \ subString: String.split(substring)) {\n            int count = 0;\n        \
    \    for (int i=0; i<string.length(); i++) {\n                if (string.charAt(i)\
    \ == subString.charAt(i)) {\n                    count++;\n                }\n\
    \            }\n            if (count == 0) {\n                results.add(0);\n\
    \            } else {\n                results.add(count);\n            }\n  \
    \      }\n        return results.stream().reduce(0, (x, y) -> x+y);", "      \
    \  int count = 0;\n        for (int i = 0; i < string.length(); i++) {\n     \
    \       if (string.charAt(i) == substring.charAt(0)) {\n                if (string.charAt(i)\
    \ == substring.charAt(1)) {\n                    if (string.charAt(i) == substring.charAt(2))\
    \ {\n                        count++;\n                    }\n               \
    \ }\n            }\n        }\n        return count;", '        return string.split(substring,
    -1).length - 1;', '        return string.split(substring).length - 1;', "    \
    \    int count = 0;\n        for (int i = 0; i < string.length() - substring.length();\
    \ i++) {\n            if (string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        if (string.equals(substring)) {\n            return 0;\n        }\n   \
    \     if (string.length() < substring.length()) {\n            return 0;\n   \
    \     }\n        int pos = -1;\n        pos = string.indexOf(substring, 0);\n\
    \        while (pos != -1) {\n            int substringLen = substring.length();\n\
    \            int startPos = pos;\n            pos = string.indexOf(substring,\
    \ pos + substringLen);\n            if (pos != -1) {\n                return 1\
    \ + howManyTimes(string.substring(startPos + substringLen, pos), substring);\n\
    \            }\n        }\n        return 0;", "        int count = 0;\n     \
    \   int currentIndex = 0;\n\n        while (currentIndex < string.length()) {\n\
    \            currentIndex = string.indexOf(substring, currentIndex);\n       \
    \     if (currentIndex != -1) {\n                count++;\n                currentIndex\
    \ += substring.length();\n            }\n        }\n        return count;", " \
    \       int count = 0;\n        string = string.trim();\n        substring = substring.trim();\n\
    \        if (string.isEmpty()) {\n            return count;\n        }\n     \
    \   string = string.toUpperCase();\n        substring = substring.toUpperCase();\n\
    \        for (int i = 0; i <= string.length() - substring.length(); i++) {\n \
    \           if (string.regionMatches(i, substring, 0, substring.length())) {\n\
    \                count++;\n            }\n        }\n        return count;", " \
    \       int count = 0;\n        for(int i = 0, j = 0; i < string.length() && j\
    \ < substring.length(); ) {\n            if(string.charAt(i) == substring.charAt(j))\
    \ i++;\n            else if(string.charAt(i) < substring.charAt(j)) i++;\n   \
    \         else j++;\n            count++;\n        }\n        return count;",
  "        List<String> substringList = Arrays.stream(string.split(substring)).collect(Collectors.toList());\n\
    \        return substringList.stream().mapToInt(String::length).sum();", '        return
    string.length() - string.replace(substring, "").length();', "        int i = 0;\n\
    \        int j = 0;\n        int overlap = 0;\n        while (i < string.length()\
    \ && j < substring.length()) {\n            if (string.charAt(i) == substring.charAt(j))\
    \ {\n                i++;\n                j++;\n            } else if (string.charAt(i)\
    \ == substring.charAt(j)) {\n                i++;\n                overlap++;\n\
    \            } else if (string.charAt(i) != substring.charAt(j)) {\n         \
    \       j++;\n                overlap++;\n            }\n        }\n        return\
    \ overlap;", "        if (string.length() < substring.length()) {\n          \
    \  return 0;\n        }\n        List<Integer> occurrences = new ArrayList<>();\n\
    \        int currentIndex = 0;\n        char currentChar = string.charAt(currentIndex);\n\
    \        while (currentIndex < string.length() && currentChar != substring.charAt(currentIndex))\
    \ {\n            currentIndex++;\n            currentChar = string.charAt(currentIndex);\n\
    \        }\n        for (int index = currentIndex; index < substring.length();\
    \ index++) {\n            currentChar = string.charAt(index);\n            while\
    \ (currentIndex < string.length() && currentChar != substring.charAt(currentIndex))\
    \ {\n                currentIndex++;\n                currentChar = string.charAt(currentIndex);\n\
    \            }\n            if (currentIndex == substring.length()) {\n      \
    \          occurrences.add(1);\n            } else {\n                occurrences.add(occurrences.get(currentIndex)\
    \ + 1);\n            }\n        }\n        return occurrences.stream().filter((value)\
    \ -> value == substring.length()).count();", "        int count = 0;\n       \
    \ for (int i = 0; i < string.length(); ++i) {\n            if (string.substring(i,\
    \ i + substring.length()).equals(substring)) {\n                ++count;\n   \
    \         }\n        }\n        return count;", "        int count = 0;\n    \
    \    for(int i = 0; i < string.length(); i++) {\n            if(string.substring(i,\
    \ i + substring.length()).equalsIgnoreCase(substring)) {\n                count++;\n\
    \            }\n        }\n        return count;", "        if (string == null\
    \ || substring == null || string.length() < substring.length() || substring ==\
    \ \"\") return 0;\n        int times = 0;\n        int j = 0;\n        for (int\
    \ i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i,\
    \ j).equals(substring)) {\n                times++;\n                i = j + substring.length();\n\
    \            } else {\n                j++;\n            }\n        }\n      \
    \  return times;", "        \n        int count = 0;\n        for(int i = 0; i\
    \ < string.length(); i++) {\n            for(int j = 0; j < substring.length();\
    \ j++) {\n                if(string.charAt(i) == substring.charAt(j)) {\n    \
    \                count++;\n                }\n            }\n        }\n     \
    \   return count;", "        int count = 0;\n        // iterate over all the characters\n\
    \        for (char c : string.toCharArray()) {\n            // check if the current\
    \ character is equal to the current substring\n            if (c == substring)\
    \ {\n                // increment the count\n                count++;\n      \
    \      }\n        }\n        // return the count\n        return count;", "  \
    \      String regex = String.format(\"(?i)%s(?i)\", substring);\n        return\
    \ string.split(regex).length - 1;", "        int substringLen = substring.length();\n\
    \        int stringLen = string.length();\n        int cnt = 0;\n        if (string.startsWith(substring))\
    \ {\n            cnt += substringLen;\n        }\n        if (stringLen <= substringLen)\
    \ {\n            return cnt;\n        }\n        char[] chars = string.toCharArray();\n\
    \        for (int i = 0; i < chars.length; i++) {\n            if (string.charAt(i)\
    \ != substring.charAt(i)) {\n                continue;\n            }\n      \
    \      cnt++;\n            for (int j = substringLen - 1; j >= 0; j--) {\n   \
    \             if (chars[i] == substring.charAt(j)) {\n                    cnt\
    \ += substringLen - j;\n                    break;\n                }\n      \
    \      }\n        }\n        return cnt;", "        int count = 0;\n        if\
    \ (string.indexOf(substring) != -1) {\n            count++;\n        }\n     \
    \   return count;", "        HashMap<String, Integer> counts = new HashMap<>();\n\
    \        for (String c : string.split(substring)) {\n            if (counts.containsKey(c))\
    \ {\n                counts.put(c, counts.get(c) + 1);\n            } else {\n\
    \                counts.put(c, 1);\n            }\n        }\n\n        int count\
    \ = 0;\n        for (Integer count : counts.values()) {\n            if (count\
    \ > 1) {\n                count = count;\n            }\n        }\n\n       \
    \ return count;", '        return string.length() - substring.length() + string.indexOf(substring)
    + string.split(substring).length - 1;', "        // TODO: Complete me!\n     \
    \   int count = 0;\n        // if string.equals(substring){\n        //     count++\n\
    \        // }\n        for(int i = 0; i<string.length(); i++){\n            if(string.substring(i,\
    \ i+substring.length()).equals(substring)){\n                count++;\n      \
    \      }\n        }\n        return count;", "        if (string == null || substring\
    \ == null || string.length() == 0 || substring.length() == 0) {\n            return\
    \ 0;\n        }\n        int count = 0;\n        \n        int len = (string.length()\
    \ > substring.length()) ? substring.length() : string.length();\n        for (int\
    \ i = 0; i < len; i++) {\n            String sub = substring.substring(0, Math.min(substring.length(),\
    \ len - i));\n            if (string.indexOf(sub) != -1) {\n                count\
    \ = count + 1;\n            }\n        }\n        return count;", "        //\
    \ use String::length to get the length of the string\n        int count = 0;\n\
    \        if (string.equals(substring)) {\n            count = 1;\n        }\n\
    \        for (int i = 0; i < string.length() - substring.length(); i++) {\n  \
    \          if (string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        int count = 0;\n        // System.out.println(string);\n        // System.out.println(substring);\n\
    \        // System.out.println(string.indexOf(substring));\n        for (int i\
    \ = 0; i < string.length() - substring.length(); i++) {\n            if (string.substring(i,\
    \ i + substring.length()).equals(substring)) {\n                count++;\n   \
    \         }\n        }\n        return count;", "        Map<String, Integer>\
    \ map = new HashMap<>();\n        final String regex = \"[^\" + substring.toString()\
    \ + \"]+\";\n        int count = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            String currentChar = string.substring(i, i + 1);\n     \
    \       if (map.containsKey(currentChar)) {\n                int count = map.get(currentChar);\n\
    \                map.put(currentChar, count + 1);\n            } else {\n    \
    \            map.put(currentChar, 1);\n            }\n        }\n\n        final\
    \ Pattern pattern = Pattern.compile(regex);\n        List<String> matches = pattern.matcher(string).results().map(MatchResult::group).collect(Collectors.toList());\n\
    \        matches.stream().forEach(match -> {\n            if (map.containsKey(match))\
    \ {\n                int count = map.get(match);\n                map.put(match,\
    \ count + 1);\n            } else {\n                map.put(match, 1);\n    \
    \        }\n        });\n\n        return map.size();", '        return 0;', '        return
    string.split(substring).length-1;', "        int count = 0;\n        for(int i\
    \ = 0; i < string.length() && i < substring.length(); i++) {\n            if(string.charAt(i)\
    \ == substring.charAt(i)) count++;\n        }\n        return count;", "     \
    \   int count = 0;\n        int len = string.length();\n        int sublen = substring.length();\n\
    \        char[] array = string.toCharArray();\n        char[] subarray = substring.toCharArray();\n\
    \        Arrays.sort(array);\n        Arrays.sort(subarray);\n        if (len\
    \ <= 0 || sublen <= 0) {\n            return count;\n        }\n        if (sublen\
    \ == 1) {\n            if (array[0] == subarray[0]) {\n                count++;\n\
    \            }\n            return count;\n        }\n        for (int i = 0;\
    \ i < sublen; i++) {\n            boolean isMatch = false;\n            int j\
    \ = 0;\n            while (j < len) {\n                if (array[j] == subarray[i])\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                j++;\n            }\n            if (isMatch) {\n\
    \                count++;\n            }\n        }\n        return count;", " \
    \       int count = 0;\n        int start = string.indexOf(substring);\n     \
    \   while (start >= 0) {\n            int end = string.indexOf(substring, start\
    \ + substring.length());\n            count += end - start;\n            start\
    \ = end;\n        }\n        return count;", '        return string.split(substring).length
    - 1;', "        return Math.abs(string.codePoints().filter(o -> o.equals(substring.codePoint()))\n\
    \                          .count()) -\n                Math.abs(string.codePoints().filter(o\
    \ -> o.equals(substring.codePoint()).orElse(-1))\n                          .count())\
    \ +\n                Math.abs(string.codePoints().filter(o -> o.equals(substring.codePoint()).orElse(-1))\n\
    \                          .count()) / 2;", '        return string.indexOf(substring)
    + 1;', '        return string.split(substring).length - 1;', "        \n     \
    \   String aString = string;\n        String bString = substring;\n        \n\
    \        int count = 0;\n        if (string.equals(substring))\n        {\n  \
    \          count++;\n        }\n        else if (aString.equals(bString))\n  \
    \      {\n            count++;\n        }\n        \n        \n        if (bString.length()\
    \ > aString.length())\n        {\n            String tempString = aString;\n \
    \           aString = bString;\n            bString = tempString;\n        }\n\
    \        \n        \n        for (int i = 0; i < bString.length(); i++)\n    \
    \    {\n            \n            \n            \n            int pos = bString.indexOf(bString.charAt(i));\n\
    \            \n            if (pos >= 0)\n            {\n                count++;\n\
    \                \n                String aSubstring = aString.substring(i, i+pos+1);\n\
    \                if (aString.equals(aSubstring))\n                {\n        \
    \            count++;\n                }\n                \n                String\
    \ bSubstring = substring;\n                bSubstring = bString.substring(i+pos+1);\n\
    \                if (bString.equals(bSubstring))\n                {\n        \
    \            count++;\n                }\n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                \n                \n                \n                \n    \
    \            \n                \n                \n                \n        \
    \        \n                \n                \n                \n            \
    \    \n                \n                \n                \n                \n\
    \                ", "        final int length = string.length();\n        final\
    \ int sublength = substring.length();\n        final int count = 0;\n        final\
    \ int counter = length - sublength;\n        if (counter < 0)\n            throw\
    \ new IllegalArgumentException(\"Substring length cannot be less than original\
    \ string length!\");\n        if (sublength == 0) {\n            return count;\n\
    \        }\n        int start = 0;\n        int end = length - 1;\n        while\
    \ (end >= start) {\n            if (string.charAt(start) == substring.charAt(0))\n\
    \                count++;\n            else if (string.charAt(end) == substring.charAt(sublength\
    \ - 1))\n                count++;\n            else\n                count++;\n\
    \            start++;\n            end--;\n        }\n        return count;",
  "        Map<Character, Integer> chars = new HashMap<>();\n        for (int i =\
    \ 0; i < string.length(); i++) {\n            if (string.toLowerCase().charAt(i)\
    \ == substring.toLowerCase().charAt(i)) {\n                chars.mergeIfAbsent(string.charAt(i),\
    \ 1L, (o, n) -> o + 1);\n            } else {\n                chars.mergeIfAbsent(string.charAt(i),\
    \ 1L, (o, n) -> o);\n            }\n        }\n        return chars.entrySet().stream()\n\
    \                .filter(entry -> string.toLowerCase().indexOf(entry.getKey().toLowerCase())\
    \ > -1)\n                .map(Map.Entry::getValue)\n                .sum();",
  "        List<String> wordList = Arrays.asList(string.split(\"\"));\n        List<String>\
    \ wordListSub = Arrays.asList(substring.split(\"\"));\n        Map<String, List<String>>\
    \ wordMap = wordList.stream().collect(Collectors.groupingBy(Function.identity(),\
    \ LinkedHashMap::new, Collectors.mapping(Function.identity(), Collectors.toList())));\n\
    \        Map<String, List<String>> wordMapSub = wordListSub.stream().collect(Collectors.groupingBy(Function.identity(),\
    \ LinkedHashMap::new, Collectors.mapping(Function.identity(), Collectors.toList())));\n\
    \        return wordMap.keySet().stream().filter(wordMapSub::containsKey).mapToInt(String::length).sum();",
  "        // Create an array to count the string and substring occurrences\n    \
    \    int[] count = {0, 0};\n        // Iterate over the substring\n        for(int\
    \ i = 0; i < string.length() - substring.length(); i++) {\n            // Iterate\
    \ over the string and substring from the start until the length of the string\n\
    \            for(int j = 0; j < substring.length(); j++) {\n                //\
    \ Increment the count if the character is the same\n                if(string.charAt(i\
    \ + j) == substring.charAt(j)) {\n                    count[0]++;\n          \
    \          count[1]++;\n                }\n            }\n        }\n        //\
    \ Return the maximum count value\n        return count[0] > count[1] ? count[0]\
    \ : count[1];", "        if (string.length() == 0 || string.length() == 0 || substring.length()\
    \ == 0 || string.length() == substring.length()) return 0;\n        // https://stackoverflow.com/questions/1503506/how-do-i-check-if-a-string-contains-a-substring-that-is-in-the-same-string\n\
    \        if (string.indexOf(substring) != -1) return string.substring(string.indexOf(substring)).lastIndexOf(substring)\
    \ + 1;\n        return 0;", "        if (string == null || string.equals(\"\"\
    )) {\n            return 0;\n        }\n        if (substring == null || substring.equals(\"\
    \")) {\n            return 0;\n        }\n\n        int index = 0;\n        int\
    \ count = 0;\n        while (index < string.length()) {\n            int len =\
    \ string.length() - index;\n            String substr = string.substring(index,\
    \ len);\n            if (substr.equals(substring)) {\n                count++;\n\
    \            }\n            index = index + substring.length();\n        }\n \
    \       return count;", "        if (string == null || substring == null)\n  \
    \          return -1;\n\n        int count = 0;\n        int index = string.indexOf(substring);\n\
    \        while (index >= 0) {\n            count++;\n            index = string.indexOf(substring,\
    \ index + substring.length());\n        }\n\n        return count;", '        return
    string.split(substring).length - 1;', '        return string.indexOf(substring)
    + 1;', "        if (string.length() == 0 || substring.length() == 0) {\n     \
    \       return 0;\n        }\n        return string.substring(0, substring.length()).replaceAll(substring,\
    \ \"\").length();", "        \n        return string.substring(string.indexOf(substring)).chars().filter(c\
    \ -> c == string.charAt(string.indexOf(substring))).count() - string.substring(string.indexOf(substring)).equals(string.substring(0,\
    \ string.indexOf(substring))) ? 1 : 0;", '        return string.substring(0, string.length()
    - substring.length()).split(substring).length - 1;', "        // Create a map\
    \ from the string and substring into a list of all occurrences in the string.\n\
    \        Map<String, List<Integer>> stringSubstringOccurrences = string.chars().boxed().collect(Collectors.groupingBy(e\
    \ -> string.substring(0, e) + string.substring(e + 1), Collectors.mapping(e ->\
    \ e, Collectors.toList())));\n\n        // Find the number of occurrences of the\
    \ substring in the list.\n        int numberOccurrences = stringSubstringOccurrences.entrySet().stream().filter(e\
    \ -> e.getKey().contains(substring)).count();\n\n        // Return the result.\n\
    \        return numberOccurrences;", "        if (string.indexOf(substring) ==\
    \ -1) {\n            return 0;\n        }\n        String temp = string.substring(0,\
    \ string.indexOf(substring));\n        return howManyTimes(temp, substring) +\
    \ 1;", "        int count = 0;\n        for (int i = 0; i < string.length(); ++i)\
    \ {\n            count += string.substring(i, i + substring.length()).equals(substring);\n\
    \        }\n        return count;", '        return string.substring(0, string.length()
    - substring.length()).split(substring).length - 1;', "        if (string.isEmpty())\
    \ {\n            return 0;\n        } else if (string.length() < substring.length())\
    \ {\n            return 0;\n        }\n        return (int) Math.ceil(\n     \
    \           IntStream.range(\n                        string.indexOf(substring)\
    \ + 1,\n                        string.lastIndexOf(substring))\n             \
    \           .filter(i -> string.charAt(i) != string.charAt(string.lastIndexOf(substring)))\n\
    \                        .count()\n                /\n                (substring.length()));",
  "        int count = 0;\n        for (String sub : string.split(substring)) {\n\
    \            if (string.indexOf(sub) != -1) {\n                count++;\n    \
    \        }\n        }\n        return count;", '        return string.split(substring).length
    - 1;', "        if (string.contains(substring))\n            return string.split(substring).length\
    \ - 1;\n        return 0;", "        int count = 0;\n        if (string == null\
    \ || string == \"\") {\n            return 0;\n        }\n\n        string = string.trim();\n\
    \        substring = substring.trim();\n\n        // String is empty\n       \
    \ if (string.length() == 0) {\n            return count;\n        }\n\n      \
    \  int minIndex = 0;\n        int maxIndex = string.length() - 1;\n        int\
    \ currentIndex = string.indexOf(substring, minIndex);\n\n        while (currentIndex\
    \ != -1) {\n            // If current index is the starting index\n          \
    \  if (currentIndex == minIndex) {\n                count++;\n               \
    \ currentIndex = string.indexOf(substring, ++currentIndex);\n            } else\
    \ {\n                // If current index is NOT the starting index\n         \
    \       count++;\n                currentIndex = string.indexOf(substring, currentIndex\
    \ + 1);\n            }\n\n            // If current index is the ending index\n\
    \            if (currentIndex == maxIndex) {\n                currentIndex = string.indexOf(substring,\
    \ currentIndex + 1);\n                count++;\n            }\n\n            //\
    \ Keep searching if the index is not found\n            if (currentIndex == -1)\
    \ {\n                return count;\n            }\n        }\n        return count;",
  "        int subStringLength = substring.length();\n        int stringLength = string.length();\n\
    \n        // if substring length is zero, return zero times\n        if (subStringLength\
    \ == 0) {\n            return 0;\n        }\n\n        // Use recursion to count\
    \ how many times the substring can be found in the original string.\n        int\
    \ count = 0;\n\n        // Base case, when the substring found is at the end of\
    \ the original string\n        if (string.endsWith(substring)) {\n           \
    \ return 1;\n        }\n\n        // Base case, when the substring found is not\
    \ at the end of original string\n        int startIndex = 0;\n        int endIndex\
    \ = stringLength;\n\n        // Looping through each index to find the substring\
    \ occurrence\n        while (startIndex < endIndex) {\n            // Find the\
    \ substring occurrence in the original string and add one\n            if (string.substring(startIndex,\
    \ startIndex + subStringLength).equals(substring)) {\n                count++;\n\
    \            }\n\n            // Increment the starting index\n            startIndex\
    \ += subStringLength;\n        }\n\n        // Return the count of times the substring\
    \ can be found in the original string\n        return count;", '        return
    string.split(substring, -1).length - 1;', "        if (string.equals(substring))\
    \ {\n            return 0;\n        }\n        int count = 0;\n        for (int\
    \ i = 0; i < string.length() - substring.length(); i++) {\n            if (string.substring(i,\
    \ i + substring.length()).equals(substring)) {\n                count += 1;\n\
    \            }\n        }\n        return count;", '        return string.split(substring).length
    - 1;', "        int count = 0;\n        if (string.length() <= substring.length())\n\
    \            count = string.length();\n        else\n            count = substring.length();\n\
    \n        int start = -1;\n        for (int i = 0; i < substring.length(); i++)\
    \ {\n            if (string.charAt(i) == substring.charAt(i)) {\n            \
    \    if (start == -1)\n                    start = i;\n            }\n       \
    \ }\n        for (int i = start; i < string.length(); i++) {\n            if (string.charAt(i)\
    \ == substring.charAt(i)) {\n                count++;\n            }\n       \
    \ }\n\n        return count;", "        int count = 0;\n        int start = 0;\n\
    \        while ((start = string.indexOf(substring, start)) != -1) {\n        \
    \    count++;\n            start += substring.length();\n        }\n        return\
    \ count;", '        return string.replaceAll(substring, "").length();', '        return
    string.substring(0, string.length() - substring.length()).lastIndexOf(substring);',
  "        if (string.length() == 0 || substring.length() == 0)\n            return\
    \ 0;\n\n        HashMap<Character, Integer> map = new HashMap<>();\n        int\
    \ count = 0;\n        for (int i = 0; i < string.length(); i++) {\n          \
    \  if (map.containsKey(string.charAt(i))) {\n                map.put(string.charAt(i),\
    \ map.get(string.charAt(i)) + 1);\n            } else {\n                map.put(string.charAt(i),\
    \ 1);\n            }\n        }\n        if (map.containsKey(substring.charAt(0)))\
    \ {\n            count += map.get(substring.charAt(0));\n        }\n        for\
    \ (int i = 0; i < substring.length(); i++) {\n            Character key = substring.charAt(i);\n\
    \            if (map.containsKey(key)) {\n                map.put(key, map.get(key)\
    \ - 1);\n                if (map.get(key) == 0) {\n                    map.remove(key);\n\
    \                } else {\n                    count += 1;\n                }\n\
    \            }\n        }\n\n        return count;", '        return string.replaceAll(substring,
    "").length();', '        return string.split(substring).length - 1;', "      \
    \  int times = 0;\n        for (int i = 0; i < string.length(); i++) {\n     \
    \       if (string.substring(i, i + substring.length()).equals(substring)) {\n\
    \                times++;\n            }\n        }\n        return times;", '        return
    string.indexOf(substring) + string.lastIndexOf(substring);', "        Set<String>\
    \ set = new HashSet<String>();\n        for (int i = 0; i < string.length(); i++)\
    \ {\n            String substring1 = string.substring(0, i);\n            String\
    \ substring2 = string.substring(i + 1);\n            if (string.equals(substring)\
    \ || substring1.equals(substring)) {\n                set.add(\"0\");\n      \
    \      } else {\n                set.add(substring1 + substring2);\n         \
    \   }\n        }\n        return set.size();", "        int count = 0;\n     \
    \   int subLength = substring.length();\n        int len = string.length();\n\
    \        boolean found = false;\n\n        for (int i = 0; i < len; ++i) {\n \
    \           if (string.charAt(i) == substring.charAt(0)) {\n                if\
    \ (string.charAt(i) == substring.charAt(subLength - 1)) {\n                  \
    \  if (found) {\n                        ++count;\n                    } else\
    \ {\n                        found = true;\n                        count = 1\
    \ + howManyTimes(string.substring(1, subLength), substring);\n               \
    \     }\n                }\n            }\n        }\n        return count;",
  "        int count = 0;\n        int endIndex = 0;\n        for (int startIndex\
    \ = 0; startIndex < string.length(); startIndex++) {\n            if (string.charAt(startIndex)\
    \ == substring.charAt(0)) {\n                endIndex = startIndex + substring.length()\
    \ - 1;\n                for (int endIndexEnd = endIndex; endIndexEnd < string.length();\
    \ endIndexEnd++) {\n                    if (string.charAt(endIndexEnd) == substring.charAt(endIndexEnd))\
    \ {\n                        endIndexEnd++;\n                    } else if (string.charAt(endIndexEnd)\
    \ != substring.charAt(endIndexEnd)) {\n                        break;\n      \
    \              }\n                }\n                if (endIndex == startIndex)\
    \ {\n                    count++;\n                }\n            } else {\n \
    \               break;\n            }\n        }\n        return count;", "  \
    \      int count = 0;\n        int index = 0;\n        while (index < string.length())\
    \ {\n            index = string.indexOf(substring, index);\n            if (index\
    \ != -1) {\n                count++;\n                index = string.indexOf(substring,\
    \ index + 1);\n            }\n        }\n        return count;", "        int[]\
    \ count = new int[string.length()];\n        int pos = 0;\n        while (pos\
    \ < string.length()) {\n            int index = string.indexOf(substring, pos);\n\
    \            if (index == -1)\n                return 0;\n            count[index]++;\n\
    \            pos = index + 1;\n        }\n        Arrays.sort(count);\n      \
    \  return count[count.length - 1];", "        int count = 0;\n        if (string\
    \ == null || substring == null) {\n            return 0;\n        }\n        int\
    \ index1 = string.indexOf(substring);\n        int index2 = string.indexOf(substring,\
    \ index1 + substring.length());\n        while (index1 != -1) {\n            count++;\n\
    \            index1 = string.indexOf(substring, index1 + substring.length());\n\
    \            index2 = string.indexOf(substring, index1 + substring.length());\n\
    \        }\n        return count;", "        String regex = substring + \"+\"\
    ;\n        return string.split(regex).length;", "        int times = 0;\n    \
    \    int length = string.length();\n        char[] substringArray = substring.toCharArray();\n\
    \        for (int i = 0; i < length; i++) {\n            if (string.charAt(i)\
    \ == substringArray[i]) {\n                times++;\n            }\n        }\n\
    \        return times;", "        int count = 0;\n        for(char c : string.toCharArray())\
    \ {\n            if(substring.indexOf(c) > 0) {\n                count += 1;\n\
    \                subString = substring.replaceAll(c,\"\");\n            }\n  \
    \      }\n        return count;", "        int count = 0;\n        int len = 0;\n\
    \        int i = 0;\n        for (i = 0; i <= string.length() - substring.length();\
    \ i++) {\n            if (string.regionMatches(true, i, substring, 0, substring.length()))\
    \ {\n                count++;\n                len += substring.length();\n  \
    \          }\n        }\n        return count;", '        return (int) string.chars().mapToObj(i
    -> (char) i).filter(i -> i == string.toCharArray()[string.indexOf(substring)]).count();',
  "        int count = 0;\n        // Use two loops to solve it using String methods.\n\
    \        for (char ch: string.toCharArray()) {\n            if (ch == substring.charAt(0))\
    \ {\n                for (int i = 1; i < substring.length(); i++) {\n        \
    \            if (ch == substring.charAt(i)) {\n                        count++;\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ count;", '        return string.length() - substring.length() + string.indexOf(string)
    + string.lastIndexOf(substring);', '        return string.length() - string.replaceAll(substring,
    "").length();', "        int count = 0;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (string.substring(i, string.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        int count = 0;\n        int lengthOfString = string.length();\n       \
    \ int lengthOfSubstring = substring.length();\n        if (lengthOfSubstring <\
    \ lengthOfString) {\n            substring = substring.substring(0, lengthOfSubstring);\n\
    \        }\n        for (int i = 0; i < lengthOfString; i++) {\n            if\
    \ (string.charAt(i) == substring.charAt(i)) {\n                count++;\n    \
    \        }\n        }\n        return count;", "        List<String> occurrences\
    \ = new ArrayList<>();\n        for (int i = 0; i < string.length(); i++) {\n\
    \            if (string.charAt(i) == substring.charAt(0)) {\n                occurrences.add(string.substring(i));\n\
    \                for (int j = i + 1; j <= string.length(); j++) {\n          \
    \          if (string.charAt(j) == substring.charAt(1)) {\n                  \
    \      occurrences.add(string.substring(i, j));\n                    }\n     \
    \           }\n            }\n        }\n        return occurrences.size();",
  "        int count = 0;\n        for (int i = 0; i < string.length(); i++) {\n \
    \           if (string.charAt(i) == substring.charAt(0)) {\n                count\
    \ += howManyTimes(string.substring(i + 1), substring);\n            }\n      \
    \      count += 1;\n        }\n        return count;", "        int count = 0;\n\
    \        int string_length = string.length();\n        int substring_length =\
    \ substring.length();\n        for (int i = 0; i < string_length - substring_length;\
    \ i++) {\n            if (string.substring(i, i + substring_length).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        if (string.contains(substring)) {\n            return string.length() -\
    \ string.replace(substring, \"\").length();\n        } else {\n            return\
    \ 0;\n        }", "        int count = 0;\n        int i = 0;\n        while(i\
    \ < string.length() && i < string.length() - substring.length()) {\n         \
    \   if(i + substring.length() >= string.length()) {\n                break;\n\
    \            }\n            if(string.substring(i,i+substring.length()).equals(substring))\
    \ {\n                count++;\n                i += substring.length();\n    \
    \        }\n            i++;\n        }\n        return count;", "        String[]\
    \ result = string.split(substring);\n        Set<String> counts = new HashSet<>();\n\
    \        for (String i : result)\n            if (counts.add(i))\n           \
    \     counts.remove(i);\n        return counts.size();", '        return string.split(substring).length
    - string.split(substring).join("").length();', '        return string.split(substring,
    -1).length - 1;', '        return count(string, substring);', "        int count\
    \ = 0;\n        for(int i = 0; i < string.length(); i++) {\n            if(i +\
    \ substring.length() <= string.length() && string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                count++;\n                i = i + substring.length();\n \
    \           }\n        }\n        return count;", "        int count = 0;\n  \
    \      for (int i = 0; i < string.length() - substring.length(); i++) {\n    \
    \        if (string.substring(i, i + substring.length()).equals(substring)) {\n\
    \                count++;\n            }\n        }\n        return count;", '        return
    string.split(substring, -1).length - 1;', "        int count = 0;\n        for\
    \ (int i = 0; i < string.length(); i++) {\n            count = 0;\n          \
    \  for (int j = 0; j < substring.length(); j++) {\n                if (string.charAt(i)\
    \ == substring.charAt(j)) {\n                    count++;\n                }\n\
    \            }\n            if (count == substring.length()) {\n             \
    \   return count;\n            }\n        }\n        return -1;", "        int\
    \ count = 1;\n        if (string == null || substring == null) return count;\n\
    \        for(int i = 0; i <= string.length() - substring.length(); i++) {\n  \
    \          String sub = string.substring(i, i + substring.length());\n       \
    \     if (sub.equals(substring)) {\n                count++;\n            } else\
    \ {\n                break;\n            }\n        }\n        return count;",
  "        int count = 0;\n        int i = 0, j = 0;\n        // Loop through the\
    \ string from the beginning\n        while (i < string.length()) {\n         \
    \   // Break if we reach the end of the string\n            if (i == string.length()\
    \ - 1) {\n                break;\n            }\n\n            // Start our search\
    \ index at 0 if we are not in the string\n            if (string.charAt(i) !=\
    \ substring.charAt(j)) {\n                j = 0;\n            }\n\n          \
    \  // Increment our index position\n            i++;\n\n            // Check if\
    \ we reach the end of the substring\n            if (j == substring.length())\
    \ {\n                count++;\n                // Reset our index\n          \
    \      j = 0;\n            }\n            // Increment our index position\n  \
    \          j++;\n        }\n        return count;", '        return string.chars().filter(x
    -> x == substring.charAt(0)).filter(x -> x == substring.charAt(substring.length()
    - 1)).count() + howManyTimes(string, substring);', "        int count = 0;\n \
    \       for (int i = 0; i < string.length() - substring.length(); i++) {\n   \
    \         if (string.substring(i, i + substring.length()).equals(substring)) {\n\
    \                count++;\n            }\n        }\n        return count;", '        return
    string.split(substring).length - 1;', "        // Use streams because this is\
    \ a common task and we already have lambdas in Java 8\n        return IntStream.range(0,\
    \ string.length()).filter(i -> string.regionMatches(false, i, substring, 0, substring.length()))\n\
    \                .count();", "        return string.contains(substring)\n    \
    \            ? string.split(substring).length - 1\n                : 0;", "  \
    \      if (string.isEmpty() || substring.equals(\"\")) {\n            return 0;\n\
    \        }\n        return string.substring(0, string.length() - substring.length()).split(substring).length\
    \ - 1;", "        int times = 0;\n        if (string.contains(substring)) {\n\
    \            int counter = 0;\n            for (int i = 0; i < string.length();\
    \ i++) {\n                for (int j = 0; j < substring.length(); j++) {\n   \
    \                 if (string.charAt(i) == substring.charAt(j)) {\n           \
    \             counter++;\n                    }\n                }\n         \
    \       if (string.charAt(i) == substring.charAt(substring.length() - 1)) {\n\
    \                    times++;\n                }\n            }\n        }\n \
    \       return times;", "        List<String> list = IntStream.range(0, string.length()\
    \ - substring.length()).mapToObj(i -> string.substring(i, i + substring.length()))\n\
    \                .collect(Collectors.toList());\n        int counter = 0;\n  \
    \      list.forEach(s -> {\n            if (s.equals(substring)) {\n         \
    \       counter++;\n            }\n        });\n        return counter;", "  \
    \      if (string.startsWith(substring) && string.endsWith(substring))\n     \
    \       return string.length() - string.replace(substring, \"\").length();\n \
    \       else\n            return 0;", "        int count = 0;\n        for (int\
    \ i = 0; i < string.length(); i++) {\n            if (string.charAt(i) == substring.charAt(0))\
    \ {\n                if (substring.indexOf(string) != -1)\n                  \
    \  count++;\n                else {\n                    for (int j = i; j < string.length();\
    \ j++) {\n                        if (string.charAt(j) == substring.charAt(1))\
    \ {\n                            if (substring.indexOf(string) != -1)\n      \
    \                          count++;\n                            else {\n    \
    \                            for (int k = j + 1; k < string.length(); k++) {\n\
    \                                    if (string.charAt(k) == substring.charAt(2))\
    \ {\n                                        if (substring.indexOf(string) !=\
    \ -1)\n                                            count++;\n                \
    \                        else {\n                                            for\
    \ (int l = k + 1; l < string.length(); l++) {\n                              \
    \                  if (string.charAt(l) == substring.charAt(3)) {\n          \
    \                                          if (substring.indexOf(string) != -1)\n\
    \                                                        count++;\n          \
    \                                      }\n                                   \
    \         }\n                                        }\n                     \
    \               }\n                                }\n                       \
    \     }\n                        }\n                    }\n                }\n\
    \            }\n        }\n        return count;", "        if (string.length()\
    \ < substring.length())\n            return 0;\n        int count = 0;\n     \
    \   final int str_len = string.length();\n        final int sub_len = substring.length();\n\
    \        for (int i = 0; i < str_len; i++) {\n            if (string.charAt(i)\
    \ == substring.charAt(i)) {\n                count++;\n                for (int\
    \ j = i; j < str_len; j++) {\n                    if (string.charAt(j) != substring.charAt(j))\n\
    \                        break;\n                    else\n                  \
    \      count++;\n                }\n            }\n        }\n        return count;",
  "        if (string.isEmpty()) {\n            return 0;\n        } else if (string.length()\
    \ < substring.length()) {\n            return 0;\n        } else {\n         \
    \   final int countAll = string.length() - substring.length();\n            if\
    \ (string.substring(0, substring.length()).equals(substring)) {\n            \
    \    return countAll;\n            } else {\n                return countAll +\
    \ howManyTimes(string.substring(substring.length()), substring);\n           \
    \ }\n        }", "        // return number of times\n        int times = Collections.frequency(\n\
    \            string.chars()\n                .mapToObj(c -> (char) c)\n      \
    \          .filter(c -> c == substring.charAt(0)).boxed(),\n            substring\n\
    \        );\n        return times;", "        String stringWithoutSubstring =\
    \ string.substring(0, string.length() - substring.length());\n        return stringWithoutSubstring.indexOf(substring)\
    \ + substring.length();", "        List<Integer> counts = IntStream.range(0, string.length())\n\
    \                .map(i -> string.toLowerCase().indexOf(substring.toLowerCase(),\
    \ i))\n                .mapToObj(i -> new Pair<Integer, Integer>(i == -1 ? -1\
    \ : i, i == string.length() - 1 ? -1 : i + substring.length()))\n            \
    \    .collect(Collectors.groupingBy(Pair::getValue, LinkedHashMap::new, Collectors.counting()));\n\
    \n        int max = Collections.max(counts.values());\n        int min = Collections.min(counts.values());\n\
    \        int length = max - min + 1;\n\n        return length == 0 ? 0 : (length\
    \ / substring.length()) + 1;", "        if (string == null || string.equals(\"\
    \")) {\n            return 0;\n        }\n        if (substring == null || substring.equals(\"\
    \")) {\n            return 1;\n        }\n        if (string.indexOf(substring)\
    \ != -1) {\n            return 1;\n        }\n        int count = 0;\n       \
    \ for (int i = 0; i < string.length() - substring.length(); i++) {\n         \
    \   if (string.substring(i, i + substring.length()).equals(substring)) {\n   \
    \             count++;\n            }\n        }\n        return count;", "  \
    \      int substringLength = substring.length();\n        if (substringLength\
    \ == 0)\n            return 0;\n        List<Integer> indexesOfSubstring = new\
    \ ArrayList<Integer>();\n        for(int i = 0; i < string.length(); ++i) {\n\
    \            int index = string.indexOf(string.toLowerCase(), i);\n          \
    \  String lowerCaseString = string.toLowerCase();\n            if (index != -1)\
    \ {\n                String substringToCompare = lowerCaseString.substring(i,\
    \ i+substringLength);\n                if (substringToCompare.equals(substring))\
    \ {\n                    indexesOfSubstring.add(index);\n                }\n \
    \           }\n        }\n        return indexesOfSubstring.size();", '        return
    string.length() - substring.length() + string.indexOf(substring);', '        return
    string.split(substring).length - 1;', "        int count = 0;\n        boolean\
    \ start = false;\n        boolean end = false;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (string.charAt(i) == substring.charAt(0)) {\n       \
    \         start = true;\n            } else {\n                if (start && string.charAt(i)\
    \ == substring.charAt(0)) {\n                    count++;\n                  \
    \  start = false;\n                } else {\n                    count++;\n  \
    \              }\n            }\n            if (string.charAt(i) == substring.charAt(string.length()\
    \ - 1)) {\n                end = true;\n            } else {\n               \
    \ if (end && string.charAt(i) == substring.charAt(string.length() - 1)) {\n  \
    \                  count++;\n                    end = false;\n              \
    \  } else {\n                    count++;\n                }\n            }\n\
    \        }\n        return count;", "        \n        int count = 0;\n      \
    \  \n        // Find the length\n        int string_length = string.length();\n\
    \        int substring_length = substring.length();\n        \n        // Iterate\
    \ over each character\n        for (int i = 0; i < string_length; ++i) {\n   \
    \         \n            // Check next character in substring\n            int\
    \ j = 0;\n            while (j < substring_length && string.charAt(i) == substring.charAt(j))\
    \ {\n                ++j;\n            }\n            \n            // Increase\
    \ count by number of characters of substring in string\n            if (j == substring_length)\
    \ {\n                ++count;\n            }\n        }\n        \n        return\
    \ count;", "        int count = 0;\n        int start = 0;\n        int end =\
    \ string.length();\n        while (start < end) {\n            if (string.substring(start,\
    \ start + substring.length()).equals(substring)) {\n                count++;\n\
    \            }\n            start = end + 1;\n        }\n        return count;",
  "        int count = 0;\n        int stringLength = string.length();\n        int\
    \ substringLength = substring.length();\n        for (int i = 0; i < stringLength\
    \ - substringLength + 1; i++) {\n            if (string.substring(i, i + substringLength).equals(substring))\
    \ {\n                count += 1;\n            }\n        }\n        return count;",
  '        return howManyTimes(string.split(""), substring.split(""));', '        return
    string.split(substring).length - 1;', "        return string.chars().filter(c\
    \ -> c == substring.charAt(0)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(1)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(2)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(3)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(4)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(5)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(6)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(7)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(8)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(9)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(10)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(11)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(12)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(13)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(14)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(15)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(16)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(17)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(18)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(19)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(20)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(21)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(22)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(23)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(24)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(25)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(26)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(27)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(28)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(29)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(30)).count() +\n                string.chars().filter(c\
    \ -> c == substring.charAt(31)).count() +\n", "        int count = 0;\n      \
    \  int i = 0;\n        int j = string.length() - substring.length();\n       \
    \ while (i < j) {\n            if (string.charAt(i + substring.length()) == substring.charAt(0))\
    \ {\n                i++;\n                j--;\n                count++;\n  \
    \          }\n            else if (string.charAt(i) == substring.charAt(0)) {\n\
    \                i++;\n                count++;\n            }\n            else\
    \ {\n                i++;\n                j--;\n            }\n        }\n  \
    \      return count;", '        return string.split(substring).length - 1;', " \
    \       // Write your code here\n        int count = 0;\n        if (string.length()\
    \ == 0 || substring.length() == 0) {\n            return 0;\n        }\n     \
    \   int start = 0;\n        int end = 0;\n        int index = 0;\n        int\
    \ len = 0;\n        while ((start = string.indexOf(substring, start)) >= 0) {\n\
    \            end = start + substring.length();\n            while (end < string.length()\
    \ && string.charAt(end) == string.charAt(end)) {\n                end++;\n   \
    \         }\n            while (start < end && string.charAt(start) == string.charAt(start))\
    \ {\n                start++;\n            }\n            if (start == end) {\n\
    \                index = start;\n            } else {\n                index =\
    \ end - 1;\n            }\n            if (index > len) {\n                len\
    \ = index;\n            }\n            count++;\n            start = end;\n  \
    \      }\n        return count;", "        char[] ch = string.toCharArray();\n\
    \        char[] sc = substring.toCharArray();\n        int count = 0;\n      \
    \  for (int i = 0; i <= string.length() - substring.length(); i++) {\n       \
    \     int j;\n            for (j = 0; j < sc.length; j++) {\n                if\
    \ (ch[i + j] != sc[j]) {\n                    break;\n                }\n    \
    \        }\n            if (j == sc.length)\n                count++;\n      \
    \  }\n        return count;"]
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- "    }\n}"
- "\n    }\n"
