completions:
- "        if (lst.isEmpty())\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        IntStream\n            .sortedCopy(lst.stream())\n            .filter(i\
  \ -> i < 0)\n            .mapToInt(Integer::intValue)\n            .peek(i -> System.out.print(\"\
  neg int at \" + i + \" \"));\n        IntStream\n            .sortedCopy(lst.stream())\n\
  \            .filter(i -> i >= 0)\n            .mapToInt(Integer::intValue)\n  \
  \          .peek(i -> System.out.print(\"pos int at \" + i + \" \"));\n        IntStream.range(0,\
  \ lst.size() - 1)\n            .filter(i -> lst.get(i) < 0)\n            .mapToInt(Integer::intValue)\n\
  \            .peek(i -> System.out.print(\"neg int at \" + i + \" \"))\n       \
  \     .filter(i -> lst.get(i) > 0)\n            .mapToInt(Integer::intValue)\n \
  \           .peek(i -> System.out.print(\"pos int at \" + i + \" \"));\n       \
  \ Pair<Optional<Integer>, Optional<Integer>> result = Pair.of(\n            Optional.ofNullable(lst.stream().filter(i->i<0).max(Integer::compareTo).orElse(Integer.MAX_VALUE)),\n\
  \            Optional.ofNullable(lst.stream().filter(i->i>0).min(Integer::compareTo).orElse(Integer.MIN_VALUE)));\n\
  \        if (lst.stream().noneMatch(i -> i < 0 || i > 0))\n            return Pair.of(Optional.empty(),\
  \ Optional.empty());\n        return result;"
- "        if (lst.isEmpty()) {\n            return new Pair<>(Optional.empty(), Optional.empty());\n\
  \        }\n\n        // sort the array in descending order\n        lst.sort(Comparator.reverseOrder());\n\
  \n        // store the negative and positive numbers in two separate lists, and\
  \ then\n        // return an Optional.of() of one of these two lists.\n        ArrayList<Integer>\
  \ positive = new ArrayList<>();\n        ArrayList<Integer> negative = new ArrayList<>();\n\
  \        for (int i : lst) {\n            if (i < 0) {\n                negative.add(i);\n\
  \            } else {\n                positive.add(i);\n            }\n       \
  \ }\n\n        // we always have an 'or' here because we don't care whether one\
  \ list is empty\n        Pair<Optional<Integer>, Optional<Integer>> p = Optional.of(positive.stream().min(Comparator.naturalOrder()).or(Optional.of(negative.stream().max(Comparator.naturalOrder()).or(Optional.empty()))).or(Optional.empty()));\n\
  \        return p;"
- "        // Your code goes here\n        Optional<Integer> first;\n        Optional<Integer>\
  \ second;\n        Optional<Integer> firstNegative = lst.stream().filter(i -> i\
  \ < 0).findFirst();\n        if (firstNegative.isPresent()) {\n            first\
  \ = Optional.of(firstNegative.get());\n        } else {\n            first = Optional.empty();\n\
  \        }\n        Optional<Integer> secondPositive = lst.stream().filter(i ->\
  \ i >= 0).findFirst();\n        if (secondPositive.isPresent()) {\n            second\
  \ = Optional.of(secondPositive.get());\n        } else {\n            second = Optional.empty();\n\
  \        }\n        return new Pair<>(first,second);"
- "        // Create a list where all integers are positive.\n        ArrayList<Integer>\
  \ positiveIntegers = new ArrayList<>(lst);\n\n        // For each integer in the\
  \ list, add it to the list if its\n        // absolute value is greater than zero.\n\
  \        // If the absolute value is the same as the smallest integer,\n       \
  \ // then replace it.\n        // If the absolute value is the same as the largest\
  \ integer,\n        // then replace it.\n        // If the absolute value is negative,\
  \ then add it to the list\n        // if the absolute value is greater than zero.\n\
  \        for(int num : positiveIntegers){\n            num = Math.abs(num);\n  \
  \          if(num > 0){\n                positiveIntegers.add(num);\n          \
  \  }\n            else if (num < Integer.MIN_VALUE){\n                positiveIntegers.add(Integer.MIN_VALUE);\n\
  \            }\n            else if (num < Integer.MAX_VALUE){\n               \
  \ positiveIntegers.add(Integer.MAX_VALUE);\n            }\n            else{\n \
  \               positiveIntegers.add(null);\n            }\n        }\n\n      \
  \  // Create a list where all integers are negative.\n        ArrayList<Integer>\
  \ negativeIntegers = new ArrayList<>(positiveIntegers);\n        // For each integer\
  \ in the list, remove it from the list.\n        for(Integer num : negativeIntegers){\n\
  \            positiveIntegers.remove(num);\n        }\n\n        // Create a pair\
  \ with all of the positive integers as the\n        // first item in the tuple and\
  \ the negative integers as the\n        // second item in the tuple.\n        //\
  \ Return this pair as a tuple.\n        return new Pair<>(positiveIntegers, negativeIntegers);"
- "        int min = 0;\n        int max = Integer.MAX_VALUE;\n        for (Integer\
  \ integer : lst) {\n            min = Math.min(min, integer);\n            max =\
  \ Math.max(max, integer);\n        }\n        return new Pair<>(Optional.ofNullable(max),\
  \ Optional.ofNullable(min));"
- "        Optional<Integer> min = null;\n        Optional<Integer> max = null;\n\
  \        for (int i : lst) {\n            if (min == null || i < min.get()) {\n\
  \                min = Optional.of(i);\n            }\n            if (max == null\
  \ || max < i) {\n                max = Optional.of(i);\n            }\n        }\n\
  \        return (min, max);"
- "        if (lst.stream().anyMatch(i -> i < 0)) {\n            return new Pair<>(Optional.empty(),\
  \ Optional.empty());\n        }\n        if (lst.stream().anyMatch(i -> i > 0))\
  \ {\n            return new Pair<>(Optional.empty(), Optional.empty());\n      \
  \  }\n        Optional<Integer> minInd = lst.stream().min(i -> i);\n        Optional<Integer>\
  \ maxInd = lst.stream().max(i -> i);\n        return new Pair<>(maxInd, minInd);"
- "        \n        List<Pair<Optional<Integer>, Optional<Integer>>> list = Arrays.stream(lst.stream().mapToInt(Integer::intValue).boxed().collect(Collectors.toList())).collect(Collectors.toList());\n\
  \        List<Pair<Optional<Integer>, Optional<Integer>>> pairList = list.stream().filter(t\
  \ -> t.first.isPresent() && t.second.isPresent()).collect(Collectors.toList());\n\
  \        \n        //List<Pair<Optional<Integer>, Optional<Integer>>> pairList =\
  \ Arrays.asList(new Pair<Optional<Integer>, Optional<Integer>>(null,null)).stream().filter(t\
  \ -> t.first.isPresent() && t.second.isPresent()).collect(Collectors.toList());\n\
  \n        if(pairList.isEmpty()) return null;\n        else if(pairList.size() ==\
  \ 1) return pairList.get(0);\n        \n        Optional<Integer> max = pairList.stream().map(t\
  \ -> t.first).max(Integer::compareTo);\n        Optional<Integer> min = pairList.stream().map(t\
  \ -> t.second).min(Integer::compareTo);\n        \n        //return max.flatMap(t\
  \ -> min.map(t1 -> Pair.of(t,t1)));\n        return Pair.of(max,min);\n        \n\
  \        /*List<Pair<Optional<Integer>, Optional<Integer>>> pairList = Arrays.asList(new\
  \ Pair<Optional<Integer>, Optional<Integer>>(null,null)).stream().filter(t -> t.first.isPresent()\
  \ && t.second.isPresent()).collect(Collectors.toList());\n        \n        Optional<Integer>\
  \ max = pairList.stream().map(t -> t.first).max(Integer::compareTo);\n        Optional<Integer>\
  \ min = pairList.stream().map(t -> t.second).min(Integer::compareTo);\n        \n\
  \        return max.flatMap(t -> min.map(t1 -> Pair.of(t,t1)));*/"
- "        int n = lst.size();\n        int n1 = 0, n2 = 0;\n        if (n > 0) {\n\
  \            Optional<Integer> max = Optional.ofNullable(Collections.max(lst));\n\
  \            Optional<Integer> min = Optional.ofNullable(Collections.min(lst));\n\
  \            if (min.isPresent()) {\n                min1 = min.orElse(0);\n   \
  \         }\n            if (max.isPresent()) {\n                max1 = max.orElse(0);\n\
  \            }\n        }\n        return Pair.of(max, min);"
- "        if (lst.stream().noneMatch(v -> v < 0 || v > 0)) {\n            return\
  \ null;\n        }\n        Optional<Integer> largest = Optional.empty();\n    \
  \    Optional<Integer> smallest = Optional.empty();\n        Optional<Integer> temp\
  \ = Optional.empty();\n        for (int i : lst) {\n            if (i < 0 || i >\
  \ 0 && temp.isPresent()) {\n                break;\n            }\n            temp\
  \ = Optional.of(i);\n            if (temp.isPresent() && largest.isPresent()) {\n\
  \                if (temp.get() > largest.get()) {\n                    largest\
  \ = Optional.of(temp.get());\n                }\n            } else {\n        \
  \        largest = Optional.of(temp.get());\n            }\n        }\n        if\
  \ (largest.isPresent() && smallest.isPresent()) {\n            return Pair.of(largest,\
  \ smallest);\n        } else {\n            return null;\n        }"
- "        Optional<Integer> positiveInteger = Optional.empty();\n        Optional<Integer>\
  \ negativeInteger = Optional.empty();\n        for (Integer i : lst) {\n       \
  \     if (i < 0) {\n                negativeInteger = Optional.of(i);\n        \
  \    } else if (i > 0) {\n                positiveInteger = Optional.of(i);\n  \
  \          }\n        }\n        return Pair.of(positiveInteger, negativeInteger);"
- "        Optional<Integer> min = null;\n        Optional<Integer> max = null;\n\n\
  \        for(int num: lst) {\n            if(min.isPresent() && num < min.get())\
  \ {\n                max = new Optional<Integer>(min.get());\n                min\
  \ = new Optional<Integer>(num);\n            } else if(max == null || num > max.get())\
  \ {\n                max = new Optional<Integer>(num);\n            }\n        }\n\
  \n        if(min.isPresent()) {\n            return Pair.of(min.orElse(null), max.orElse(null));\n\
  \        } else {\n            return Pair.of(Optional.absent(), Optional.absent());\n\
  \        }"
- "        // Sort the list.\n        Collections.sort(lst);\n        // Loop through\
  \ the list, keeping track of the largest and smallest values found.\n        Optional<Integer>\
  \ largest = Optional.empty();\n        Optional<Integer> smallest = Optional.empty();\n\
  \        for (int num : lst) {\n            if (num < 0) {\n                if (largest.isPresent())\
  \ {\n                    // We already have a largest value, so we need to update\
  \ it with the new value.\n                    largest = Optional.of(largest.get().compareTo(num)\
  \ > 0 ? largest.get() : num);\n                }\n            } else {\n       \
  \         if (smallest.isPresent()) {\n                    // We already have a\
  \ smallest value, so we need to update it with the new value.\n                \
  \    smallest = Optional.of(smallest.get().compareTo(num) < 0 ? smallest.get() :\
  \ num);\n                }\n            }\n        }\n        // Return the tuple\
  \ of the largest and smallest values.\n        return Pair.of(largest, smallest);"
- "        ArrayList<Integer> negative = new ArrayList<>();\n        ArrayList<Integer>\
  \ positive = new ArrayList<>();\n        for (int num : lst) {\n            if (num\
  \ < 0) {\n                negative.add(num);\n            } else {\n           \
  \     positive.add(num);\n            }\n        }\n\n        if (negative.isEmpty()\
  \ && positive.isEmpty()) {\n            return null;\n        }\n        // sort\
  \ negative integers to find the largest negative integer\n        Collections.sort(negative);\n\
  \        // sort positive integers to find the smallest positive integer\n     \
  \   Collections.sort(positive);\n        // return None if the list is empty or\
  \ contains no negative integers\n        if (negative.isEmpty()) {\n           \
  \ return Optional.of(Optional.empty());\n        }\n        if (positive.isEmpty())\
  \ {\n            return Optional.of(Optional.empty());\n        }\n        // return\
  \ the smallest negative integer as the smallest negative integer\n        return\
  \ Optional.of(Optional.of((Integer) negative.get(0)));"
- "        Collections.sort(lst);\n        if (lst.stream().allMatch(i -> i < 0))\
  \ {\n            return Pair.of(Optional.empty(), Optional.empty());\n        }\n\
  \        if (lst.stream().allMatch(i -> i >= 0)) {\n            return Pair.of(Optional.empty(),\
  \ Optional.of(Collections.min(lst)));\n        }\n        return Pair.of(Optional.of(Collections.max(lst)),\
  \ Optional.empty());"
- "        if (lst.isEmpty()) {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }\n        int negMax = Integer.MIN_VALUE;\n        int posMin = Integer.MAX_VALUE;\n\
  \        int max = Integer.MIN_VALUE;\n        for (Integer n : lst) {\n       \
  \     int current = negMax < n ? negMax : posMin;\n            max = max < n ? max\
  \ : n;\n            current = n > current ? n : current;\n            negMax = n\
  \ < negMax ? n : negMax;\n            posMin = n < posMin ? n : posMin;\n      \
  \  }\n        return Pair.of(Optional.of(max), Optional.of(current));"
- "        Optional<Integer> largest_value = Optional.empty();\n        Optional<Integer>\
  \ smallest_value = Optional.empty();\n\n        for (int i = 0; i < lst.size();\
  \ i++) {\n            int value = lst.get(i);\n\n            if (value < 0) {\n\
  \                if (largest_value.isEmpty()) {\n                    largest_value\
  \ = Optional.of(value);\n                } else {\n                    largest_value\
  \ = Optional.of(Math.max(largest_value, value));\n                }\n          \
  \  } else if (value > 0) {\n                if (smallest_value.isEmpty()) {\n  \
  \                  smallest_value = Optional.of(value);\n                } else\
  \ {\n                    smallest_value = Optional.of(Math.min(smallest_value, value));\n\
  \                }\n            }\n        }\n\n        return largest_value.flatMap(Optional::of).map(Pair::of).orElseGet(()\
  \ -> smallest_value.flatMap(Optional::of).map(Pair::of));"
- "        Optional<Integer> largestOfNegativeInteger = lst.stream()\n           \
  \     .filter(x -> x < 0)\n                .max(Integer::compareTo);\n        Optional<Integer>\
  \ smallestOfPositiveInteger = lst.stream()\n                .filter(x -> x > 0)\n\
  \                .min(Integer::compareTo);\n        return largestOfNegativeInteger.map((Integer\
  \ i) -> smallestOfPositiveInteger.orElse(i))\n                .map(Pair::of)\n \
  \               .orElseGet(() -> Pair.of(Optional.empty(), Optional.empty()));"
- "        if(lst.isEmpty()) {\n            return null;\n        }\n        int max\
  \ = lst.get(0);\n        int min = lst.get(0);\n        for(Integer i : lst) {\n\
  \            if(i.compareTo(max) < 0) {\n                max = i;\n            }\n\
  \            if(i.compareTo(min) > 0) {\n                min = i;\n            }\n\
  \        }\n        return Pair.of(Optional.of(max), Optional.of(min));"
- "        Optional<Integer> min = Optional.empty();\n        Optional<Integer> max\
  \ = Optional.empty();\n        int numOfIntegers = lst.size();\n        if (numOfIntegers\
  \ == 0) {\n            return Pair.of(min, max);\n        }\n        for (int i\
  \ = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n             \
  \   min = Optional.of(lst.get(i));\n            }\n            if (lst.get(i) >\
  \ 0) {\n                max = Optional.of(lst.get(i));\n            }\n        }\n\
  \        return Pair.of(min, max);"
- "        Optional<Integer> max = null;\n        Optional<Integer> min = null;\n\
  \        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0)\
  \ {\n                if (max == null || lst.size() < max.size()) {\n           \
  \         max = Optional.of(lst.get(i));\n                }\n            } else\
  \ if (lst.get(i) > 0) {\n                if (min == null || lst.size() < min.size())\
  \ {\n                    min = Optional.of(lst.get(i));\n                }\n   \
  \         }\n        }\n        if (min.isPresent() && max.isPresent()) {\n    \
  \        return new Pair<>(max, min);\n        } else if (min.isPresent()) {\n \
  \           return new Pair<>(min, null);\n        } else if (max.isPresent()) {\n\
  \            return new Pair<>(null, max);\n        } else {\n            return\
  \ new Pair<>(null, null);\n        }"
- "        // TODO: write your code here\n        if (lst.isEmpty()) {\n         \
  \   return new Pair(Optional.empty(), Optional.empty());\n        }\n        Optional<Integer>\
  \ largestInteger = Optional.empty();\n        Optional<Integer> smallestInteger\
  \ = Optional.empty();\n\n        for (Integer i : lst) {\n            if (i < 0)\
  \ {\n                largestInteger = Optional.of(i);\n            } else {\n  \
  \              smallestInteger = Optional.of(i);\n            }\n        }\n\n \
  \       return new Pair(largestInteger, smallestInteger);"
- "        if (lst.stream().noneMatch(i -> i < 0)) {\n            Optional<Integer>\
  \ a = lst.stream().filter(i -> i < 0).max();\n            Optional<Integer> b =\
  \ lst.stream().filter(i -> i >= 0).min();\n            return new Pair<>(Optional.ofNullable(a),\
  \ Optional.ofNullable(b));\n        }\n        else return null;"
- "        ArrayList<Integer> negative = new ArrayList<>();\n        ArrayList<Integer>\
  \ positive = new ArrayList<>();\n\n        int maxNegative = Integer.MIN_VALUE;\n\
  \        int minPositive = Integer.MAX_VALUE;\n\n        for(int i = 0; i < lst.size();\
  \ i++) {\n            if(lst.get(i) < 0) {\n                negative.add(lst.get(i));\n\
  \                maxNegative = Math.max(maxNegative, lst.get(i));\n            }\
  \ else if(lst.get(i) > 0) {\n                positive.add(lst.get(i));\n       \
  \         minPositive = Math.min(minPositive, lst.get(i));\n            }\n    \
  \    }\n\n        if(maxNegative == Integer.MIN_VALUE && minPositive == Integer.MAX_VALUE)\
  \ return new Pair(Optional.empty(), Optional.empty());\n\n        if(maxNegative\
  \ > minPositive) return new Pair(Optional.of(maxNegative), Optional.empty());\n\
  \        return new Pair(Optional.empty(), Optional.of(minPositive));"
- "        Optional<Integer> a = Optional.empty();\n        Optional<Integer> b =\
  \ Optional.empty();\n        for (int i : lst) {\n            if (i.equals(Integer.MIN_VALUE))\
  \ {\n                a = Optional.of(i);\n            } else if (i.equals(Integer.MAX_VALUE))\
  \ {\n                b = Optional.of(i);\n            }\n        }\n        return\
  \ new Pair<>(a, b);"
- "        Optional<Integer> max = Optional.empty();\n        Optional<Integer> min\
  \ = Optional.empty();\n        for (Integer i : lst) {\n            max = max.map(imax(i,\
  \ max)).orElse(i);\n            min = min.map(imin(i, min)).orElse(i);\n       \
  \ }\n        return new Pair<Optional<Integer>, Optional<Integer>>(max, min);"
- "        Optional<Integer> firstPositiveInteger = Optional.empty();\n        Optional<Integer>\
  \ firstNegativeInteger = Optional.empty();\n        Optional<Integer> secondPositiveInteger\
  \ = Optional.empty();\n        Optional<Integer> secondNegativeInteger = Optional.empty();\n\
  \n        Optional<Integer> firstPositiveOrNone = Optional.ofNullable(lst.get(0)).filter(i\
  \ -> i > 0).map(Integer::valueOf);\n        Optional<Integer> firstNegativeOrNone\
  \ = Optional.ofNullable(lst.get(0)).filter(i -> i < 0).map(Integer::valueOf);\n\n\
  \        Optional<Integer> secondPositiveOrNone = Optional.ofNullable(lst.get(0)).filter(i\
  \ -> i < 0).map(Integer::valueOf);\n        Optional<Integer> secondNegativeOrNone\
  \ = Optional.ofNullable(lst.get(0)).filter(i -> i > 0).map(Integer::valueOf);\n\n\
  \        for (Integer i : lst) {\n            if (i > 0)\n                firstPositiveInteger\
  \ = Optional.of(i);\n            else if (i < 0)\n                firstNegativeInteger\
  \ = Optional.of(i);\n            else\n                firstPositiveOrNone = Optional.of(i);\n\
  \        }\n\n        for (Integer i : lst) {\n            if (i < 0)\n        \
  \        secondNegativeInteger = Optional.of(i);\n            else if (i > 0)\n\
  \                secondPositiveInteger = Optional.of(i);\n            else\n   \
  \             secondNegativeOrNone = Optional.of(i);\n        }\n\n        if (firstPositiveInteger.isPresent()\
  \ && firstNegativeInteger.isPresent() && !secondPositiveInteger.isPresent() && !secondNegativeInteger.isPresent())\n\
  \            return new Pair(firstPositiveInteger, firstNegativeInteger);\n    \
  \    else if (firstPositiveInteger.isPresent() && !firstNegativeInteger.isPresent()\
  \ && !secondPositiveInteger.isPresent() && !secondNegativeInteger.isPresent())\n\
  \            return new Pair(firstPositiveInteger, secondNegativeInteger);\n   \
  \     else if (firstNegativeInteger.isPresent() && !firstPositiveInteger.isPresent()\
  \ && !secondNegativeInteger.isPresent() && !secondPositiveInteger.isPresent())\n\
  \            return new Pair(firstNegativeInteger, secondPositiveInteger);\n   \
  \     else\n            return new Pair(firstPositiveOrNone, firstNegativeOrNone);"
- "        Optional<Integer> largest = lst.stream()\n                .max(Comparator.naturalOrder())\n\
  \                .map(x -> (x > 0) ? x : null);\n        Optional<Integer> smallest\
  \ = lst.stream()\n                .min(Comparator.naturalOrder())\n            \
  \    .map(x -> (x < 0) ? x : null);\n        if (largest == null || smallest ==\
  \ null) {\n            return Pair.of(Optional.empty(), Optional.empty());\n   \
  \     }\n        return Pair.of(largest, smallest);"
- "        int maxPos = Integer.MIN_VALUE, minPos = Integer.MAX_VALUE;\n        for\
  \ (Integer i : lst) {\n            if (i < 0) {\n                maxPos = i;\n \
  \           } else if (i > maxPos) {\n                maxPos = i;\n            }\n\
  \            if (i < 0) {\n                minPos = i;\n            } else if (i\
  \ > minPos) {\n                minPos = i;\n            }\n        }\n        return\
  \ Pair.of(Optional.of(maxPos), Optional.of(minPos));"
- "        ArrayList<Integer> negative = new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ positive = new ArrayList<Integer>();\n        int max = 0;\n        for (int elem\
  \ : lst) {\n            if (elem < 0) {\n                negative.add(elem);\n \
  \               if (max < elem) {\n                    max = elem;\n           \
  \     }\n            } else {\n                positive.add(elem);\n           \
  \     if (max > elem) {\n                    max = elem;\n                }\n  \
  \          }\n        }\n        if (negative.isEmpty() && positive.isEmpty()) {\n\
  \            return new Pair(Optional.of(null), Optional.of(null));\n        }\n\
  \        return new Pair(Optional.of(max), Optional.of(Math.max(positive.get(0),\
  \ negative.get(0))));"
- "        // Write your code here\n        Integer max = null;\n        Integer min\
  \ = null;\n        if(lst.isEmpty()) {\n            return Pair.of(Optional.of(max),\
  \ Optional.of(min));\n        }\n        for(int i : lst) {\n            if(i <\
  \ 0) {\n                max = i;\n            }\n            if(i > 0){\n      \
  \          min = i;\n            }\n        }\n        return Pair.of(Optional.of(max),\
  \ Optional.of(min));"
- "        List<Integer> negative = new ArrayList<>();\n        List<Integer> positive\
  \ = new ArrayList<>();\n\n        for(int i : lst) {\n            if (i < 0) {\n\
  \                negative.add(i);\n            } else {\n                positive.add(i);\n\
  \            }\n        }\n        if (negative.isEmpty()) {\n            return\
  \ Pair.of((Optional<Integer>) null, Optional.of(positive.stream().min(Comparator.naturalOrder()).orElse(Integer.MAX_VALUE)));\n\
  \        }\n\n        if (positive.isEmpty()) {\n            return Pair.of((Optional<Integer>)\
  \ null, Optional.of(negative.stream().max(Comparator.naturalOrder()).orElse(Integer.MIN_VALUE)));\n\
  \        }\n\n        Pair<Optional<Integer>, Optional<Integer>> largestSmallestIntegers\
  \ = new Pair<>(Optional.of(negative.stream().max(Comparator.naturalOrder()).orElse(Integer.MIN_VALUE)),\
  \ Optional.of(positive.stream().min(Comparator.naturalOrder()).orElse(Integer.MAX_VALUE)));\n\
  \        return largestSmallestIntegers;"
- "        if (lst.isEmpty())\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \n        Optional<Integer> biggest = lst.stream()\n            .max((a, b) -> Integer.compare(b,\
  \ a));\n\n        Optional<Integer> smallest = lst.stream()\n            .min((a,\
  \ b) -> Integer.compare(b, a));\n\n        return Pair.of(biggest, smallest);"
- "        if(lst.isEmpty()) return (Optional.empty(), Optional.empty());\n      \
  \  if(lst.size() == 1) return (Optional.of(lst.get(0)), Optional.empty());\n\n \
  \       // Sort the list\n        lst.sort(Comparator.comparingInt(Integer::intValue));\n\
  \n        // Find the negative integer\n        Optional<Integer> negInteger = lst.stream().filter(i\
  \ -> i < 0).findAny();\n\n        // Find the positive integer\n        Optional<Integer>\
  \ posInteger = lst.stream().filter(i -> i >= 0).findAny();\n\n        // Return\
  \ the largest number\n        return negInteger.orElse(posInteger.orElse(null));"
- "        // TODO: Write your answer here\n        return null;"
- "        return lst.stream().parallel()\n                .max((a, b) -> a.compareTo(b)\
  \ > 0 ? a : b)\n                .min(Math::abs);"
- "        Pair<Optional<Integer>, Optional<Integer>> pair = lst.stream()\n      \
  \          .filter(i -> i < 0)\n                .min(Comparator.naturalOrder())\n\
  \                .map(Optional::ofNullable)\n                .flatMap(Optional::stream)\n\
  \                .collect(\n                        Pair::new,\n               \
  \         Pair::of,\n                        Pair::of\n                );\n    \
  \    return pair;"
- "        // Start by defining tuples of two elements. We define them using a Pair\
  \ class.\n        Pair<Optional<Integer>, Optional<Integer>> firstPositive = Pair.of(Optional.ofNullable(lst.stream().filter(x\
  \ -> x > 0).min()), Optional.ofNullable(lst.stream().filter(x -> x > 0).max()));\n\
  \        Pair<Optional<Integer>, Optional<Integer>> firstNegative = Pair.of(Optional.ofNullable(lst.stream().filter(x\
  \ -> x < 0).min()), Optional.ofNullable(lst.stream().filter(x -> x < 0).max()));\n\
  \        Pair<Optional<Integer>, Optional<Integer>> nonePositive = Pair.of(Optional.empty(),\
  \ Optional.empty());\n        Pair<Optional<Integer>, Optional<Integer>> noneNegative\
  \ = Pair.of(Optional.empty(), Optional.empty());\n\n        // If none of the numbers\
  \ are positive, none of the numbers are negative.\n        if (firstPositive.first().isPresent()\
  \ && firstPositive.second().isPresent()) {\n            // If the first number is\
  \ greater than the second number, return the pair.\n            if (firstPositive.first().get()\
  \ > firstPositive.second().get()) {\n                return nonePositive;\n    \
  \        } else {\n                return firstPositive;\n            }\n      \
  \  } else if (firstNegative.first().isPresent() && firstNegative.second().isPresent())\
  \ {\n            // If the first number is less than the second number, return the\
  \ pair.\n            if (firstNegative.first().get() < firstNegative.second().get())\
  \ {\n                return noneNegative;\n            } else {\n              \
  \  return firstNegative;\n            }\n        } else if (nonePositive.first().isPresent()\
  \ && nonePositive.second().isPresent()) {\n            // If both numbers are null,\
  \ return them.\n            return nonePositive;\n        } else if (noneNegative.first().isPresent()\
  \ && noneNegative.second().isPresent()) {\n            // If both numbers are null,\
  \ return them.\n            return noneNegative;\n        } else {\n           \
  \ // If none of the numbers are positive, none of the numbers are negative.\n  \
  \          return nonePositive;\n        }"
- "        Optional<Integer> largestInteger = Optional.empty();\n        Optional<Integer>\
  \ smallestInteger = Optional.empty();\n        // Find the biggest and smallest\
  \ integers\n        for(int i=0; i<lst.size(); i++) {\n            if(lst.get(i)\
  \ < 0) {\n                smallestInteger = Optional.of(lst.get(i));\n         \
  \   } else if(lst.get(i) > 0) {\n                largestInteger = Optional.of(lst.get(i));\n\
  \            }\n        }\n        // Return None if the list is empty.\n      \
  \  if(lst.isEmpty()) {\n            return Pair.of(largestInteger, smallestInteger);\n\
  \        }\n        // If the largest integer is greater than the smallest integer,\n\
  \        // swap them so that the smallest integer is now the largest.\n       \
  \ if(largestInteger.isPresent() && smallestInteger.isPresent()) {\n            if(largestInteger.get()\
  \ > smallestInteger.get()) {\n                largestInteger = Optional.of(smallestInteger.get());\n\
  \                smallestInteger = Optional.of(largestInteger.get());\n        \
  \    }\n        }\n        return Pair.of(largestInteger, smallestInteger);"
- "        if (lst.stream().noneMatch(i -> i < 0)) {\n            Optional<Integer>\
  \ maxVal = lst.stream().max(Comparator.comparing(i -> i));\n            Optional<Integer>\
  \ minVal = lst.stream().min(Comparator.comparing(i -> i));\n            return Pair.of(maxVal,\
  \ minVal);\n        }\n        return Pair.of(Optional.empty(), Optional.empty());"
- "        Optional<Integer> a = Optional.empty();\n        Optional<Integer> b =\
  \ Optional.empty();\n        if(lst.isEmpty()){\n            return new Pair<>(a,\
  \ b);\n        }\n        // Sort list by ascending order\n        Collections.sort(lst);\n\
  \        // Find first negative number\n        int firstNeg = 0;\n        int firstPosMax\
  \ = lst.get(0);\n        for(int i=1;i<lst.size();i++){\n            if(lst.get(i)<firstPosMax){\n\
  \                firstNeg=i;\n                firstPosMax = lst.get(i);\n      \
  \      }\n        }\n        // Find first positive number\n        int firstPos\
  \ = 0;\n        int firstPosMin = lst.get(0);\n        for(int i=1;i<lst.size();i++){\n\
  \            if(lst.get(i)>firstPosMin){\n                firstPos=i;\n        \
  \        firstPosMin = lst.get(i);\n            }\n        }\n        // Reverse\
  \ list\n        Collections.reverse(lst);\n        // Find largest negative number\n\
  \        int firstNegMax = lst.get(0);\n        for(int i=1;i<lst.size();i++){\n\
  \            if(lst.get(i)>firstNegMax){\n                firstNegMax = lst.get(i);\n\
  \            }\n        }\n        // Find smallest positive number\n        int\
  \ firstPosMin = lst.get(0);\n        for(int i=1;i<lst.size();i++){\n          \
  \  if(lst.get(i)<firstPosMin){\n                firstPosMin = lst.get(i);\n    \
  \        }\n        }\n        // Return smallest negative number and largest positive\
  \ number\n        if(firstNeg < firstPos){\n            return new Pair<>(Optional.of(firstNegMax),\
  \ Optional.of(firstPosMin));\n        }\n        else{\n            return new Pair<>(Optional.of(firstNegMax),\
  \ Optional.of(firstPosMin));\n        }"
- "        ArrayList<Integer> sortedLst = lst.stream().sorted().collect(toList());\n\
  \        if (sortedLst.stream().noneMatch(b -> b < 0))\n            return Pair.of(Optional.of(null),\
  \ Optional.of(null));\n        if (sortedLst.stream().noneMatch(b -> b > 0))\n \
  \           return Pair.of(Optional.of(null), Optional.of(null));\n        int minPos\
  \ = sortedLst.stream().filter(a -> a >= 0).findFirst().getAsInt();\n        int\
  \ maxPos = sortedLst.stream().filter(a -> a >= 0).findFirst().getAsInt() - 1;\n\
  \        return Pair.of(Optional.of(minPos), Optional.of(maxPos));"
- "        Optional<Integer> smallestNumber = lst.stream().min((a, b) -> Integer.compare(a,\
  \ b));\n        Optional<Integer> largestNumber = lst.stream().max((a, b) -> Integer.compare(a,\
  \ b));\n        return Optional.of((smallestNumber, largestNumber));"
- "        if (lst.isEmpty()) {\n            return new Pair<>(null, null);\n    \
  \    }\n        Optional<Integer> smallNumber = lst.stream().min((e1, e2) -> Integer.compare(e1,\
  \ e2));\n        Optional<Integer> largeNumber = lst.stream().max((e1, e2) -> Integer.compare(e1,\
  \ e2));\n        return new Pair<>(largeNumber, smallNumber);"
- "        Optional<Integer> max = null;\n        Optional<Integer> min = null;\n\
  \        if (lst.stream().allMatch(i -> i < 0)) {\n            max = Optional.of(-lst.stream().max().getAsInt());\n\
  \        } else {\n            max = Optional.of(-lst.stream().min().getAsInt());\n\
  \        }\n        if (lst.stream().allMatch(i -> i >= 0)) {\n            min =\
  \ Optional.of(lst.stream().min().getAsInt());\n        } else {\n            min\
  \ = Optional.of(lst.stream().max().getAsInt());\n        }\n        return Pair.create(min,\
  \ max);"
- "        if (lst.isEmpty()) return Optional.of(null);\n        IntSummaryStatistics\
  \ stats = lst.stream()\n                .mapToInt(Integer::intValue)\n         \
  \       .summaryStatistics();\n        return Pair.of(Optional.of(-stats.getMax()),\
  \ Optional.of(stats.getMin()));"
- "        Optional<Integer> positiveInteger = Optional.ofNullable(lst).stream().filter(i\
  \ -> i >= 0).findAny();\n        Optional<Integer> negativeInteger = Optional.ofNullable(lst).stream().filter(i\
  \ -> i < 0).findAny();\n        if (positiveInteger.isPresent() && negativeInteger.isPresent())\
  \ {\n            return Pair.of(Optional.ofNullable(positiveInteger.get()).map(v\
  \ -> Integer.min(v, negativeInteger.get())),\n                    Optional.ofNullable(negativeInteger.get()).map(v\
  \ -> Integer.max(v, positiveInteger.get())));\n        }\n        if (positiveInteger.isPresent())\
  \ {\n            return Pair.of(Optional.ofNullable(positiveInteger.get()).map(v\
  \ -> Integer.min(v, Integer.MAX_VALUE)),\n                    Optional.empty());\n\
  \        }\n        if (negativeInteger.isPresent()) {\n            return Pair.of(Optional.empty(),\
  \ Optional.ofNullable(negativeInteger.get()).map(v -> Integer.max(v, Integer.MIN_VALUE)));\n\
  \        }\n        return Pair.of(Optional.empty(), Optional.empty());"
- "        if (lst.stream().noneMatch(i -> i < 0)) {\n            Collections.sort(lst);\n\
  \            if (lst.get(lst.size() - 1) < 0) {\n                return Optional.of(lst.get(lst.size()\
  \ - 1));\n            } else {\n                return Optional.of(lst.get(0));\n\
  \            }\n        }\n        return Optional.empty();"
- "        if (lst.isEmpty()) {\n            return Pair.make(Optional.empty(), Optional.empty());\n\
  \        }\n        Optional<Integer> minValue = Optional.of(lst.get(0));\n    \
  \    Optional<Integer> maxValue = Optional.of(lst.get(lst.size() - 1));\n      \
  \  for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n \
  \               maxValue = maxValue.filter(e -> e > lst.get(i));\n            }\
  \ else if (lst.get(i) > 0) {\n                minValue = minValue.filter(e -> e\
  \ < lst.get(i));\n            }\n        }\n        return Pair.make(minValue, maxValue);"
- "        if (lst.size() > 0) {\n            int minInt = Integer.MAX_VALUE;\n  \
  \          int maxInt = Integer.MIN_VALUE;\n            for (int i : lst) {\n  \
  \              if (i < minInt) {\n                    minInt = i;\n            \
  \    } else if (i > maxInt) {\n                    maxInt = i;\n               \
  \ }\n            }\n            return Pair.of(Optional.of(maxInt), Optional.of(minInt));\n\
  \        } else {\n            return Pair.of(Optional.of(null), Optional.of(null));\n\
  \        }"
- "        // Implement here\n        Optional<Integer> max = Optional.empty();\n\
  \        Optional<Integer> min = Optional.empty();\n        for(int i = 0; i < lst.size();\
  \ i++) {\n            if(lst.get(i) >= 0) {\n                if (min.isEmpty())\
  \ {\n                    min = Optional.of(lst.get(i));\n                } else\
  \ if (min.orElse() > lst.get(i)) {\n                    min = Optional.of(lst.get(i));\n\
  \                }\n            }\n            if(lst.get(i) < 0) {\n          \
  \      if (max.isEmpty()) {\n                    max = Optional.of(lst.get(i));\n\
  \                } else if (max.orElse() < lst.get(i)) {\n                    max\
  \ = Optional.of(lst.get(i));\n                }\n            }\n        }\n    \
  \    Pair result = (max.isPresent() ? Pair.of(max, min) : Pair.of(max, None));\n\
  \        return result;"
- "        \n        List<Integer> sortedList = lst.stream()\n            .sorted()\n\
  \            .collect(Collectors.toList());\n        \n        int small = sortedList.get(0);\n\
  \        int big = sortedList.get(0);\n        \n        if (small == big) {\n \
  \           throw new IllegalArgumentException(\"Small and Big are the same!\");\n\
  \        }\n        \n        for (int i = 0; i < sortedList.size(); i++) {\n  \
  \          if (sortedList.get(i) > small) {\n                big = sortedList.get(i);\n\
  \            } else if (sortedList.get(i) < small) {\n                small = sortedList.get(i);\n\
  \            }\n        }\n        \n        return Pair.of(Optional.of(small),\
  \ Optional.of(big));"
- "        Optional<Integer> a = Optional.ofNullable(lst);\n        Optional<Integer>\
  \ b = Optional.ofNullable(lst);\n        for (Integer i : lst) {\n            if\
  \ (i.compareTo(BigInteger.ZERO) < 0)\n                a = Optional.of(i);\n    \
  \        else\n                b = Optional.of(i);\n        }\n        return new\
  \ Pair<>(a, b);"
- "        Optional<Integer> maxValue = null;\n        Optional<Integer> minValue\
  \ = null;\n        for (int ele : lst) {\n            Optional<Integer> value =\
  \ ele.map(i -> {\n                Optional<Integer> result = Optional.of(i);\n \
  \               if (i > 0) {\n                    result = result.filter(r -> r\
  \ > 0);\n                }\n                return result;\n            });\n  \
  \          Optional<Integer> value1 = value.filter(i -> i > 0);\n            if\
  \ (maxValue.isPresent()) {\n                maxValue = maxValue.filter(r -> r >\
  \ value1);\n            } else {\n                maxValue = value1;\n         \
  \   }\n            if (minValue.isPresent()) {\n                minValue = minValue.filter(r\
  \ -> r < value1);\n            } else {\n                minValue = value1;\n  \
  \          }\n        }\n        return Pair.of(maxValue, minValue);"
- "        int minIndex = lst.indexOf(Collections.min(lst));\n        int maxIndex\
  \ = lst.indexOf(Collections.max(lst));\n        if (minIndex < maxIndex) {\n   \
  \         return Pair.of(Optional.ofNullable(lst.get(minIndex)), Optional.ofNullable(lst.get(maxIndex)));\n\
  \        } else {\n            return Pair.of(Optional.ofNullable(lst.get(maxIndex)),\
  \ Optional.ofNullable(lst.get(minIndex)));\n        }"
- "        ArrayList<Integer> negative = new ArrayList<>();\n        ArrayList<Integer>\
  \ positive = new ArrayList<>();\n\n        boolean neg = false;\n        for (int\
  \ i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n           \
  \     if (!neg) negative.add(lst.get(i));\n                else positive.add(lst.get(i));\n\
  \                neg = true;\n            } else {\n                if (neg) negative.add(lst.get(i));\n\
  \                else positive.add(lst.get(i));\n            }\n        }\n\n  \
  \      if (negative.isEmpty()) {\n            return new Pair<>(Optional.ofNullable(positive),\
  \ Optional.ofNullable(positive));\n        } else if (positive.isEmpty()) {\n  \
  \          return new Pair<>(Optional.ofNullable(negative), Optional.ofNullable(negative));\n\
  \        } else {\n            Collections.sort(negative);\n            Collections.sort(positive);\n\
  \            Optional<Integer> largestNegative = Optional.ofNullable(negative.get(0));\n\
  \            Optional<Integer> smallestPositive = Optional.ofNullable(positive.get(0));\n\
  \            for (int i = 0; i < lst.size(); i++) {\n                if (lst.get(i)\
  \ < 0) {\n                    if (largestNegative.isPresent()) {\n             \
  \           largestNegative = Optional.of(largestNegative.get().intValue() < lst.get(i).intValue()\
  \ ? largestNegative.get() : lst.get(i));\n                    } else {\n       \
  \                 largestNegative = Optional.of(lst.get(i));\n                 \
  \   }\n                } else {\n                    if (smallestPositive.isPresent())\
  \ {\n                        smallestPositive = Optional.of(smallestPositive.get().intValue()\
  \ > lst.get(i).intValue() ? smallestPositive.get() : lst.get(i));\n            \
  \        } else {\n                        smallestPositive = Optional.of(lst.get(i));\n\
  \                    }\n                }\n            }\n            return new\
  \ Pair<>(largestNegative, smallestPositive);\n        }"
- "        if(lst.isEmpty()) return new Pair<>(null, null);\n        Optional<Integer>\
  \ largest = Optional.ofNullable(Collections.max(lst));\n        Optional<Integer>\
  \ smallest = Optional.ofNullable(Collections.min(lst));\n        if(largest.isPresent()\
  \ && smallest.isPresent()) {\n            return new Pair<>(largest, smallest);\n\
  \        }\n        return null;"
- "        Optional<Integer> positiveInteger = Optional.empty();\n        Optional<Integer>\
  \ negativeInteger = Optional.empty();\n\n        if (lst.stream().allMatch(i ->\
  \ i < 0)) {\n            negativeInteger = Optional.of(lst.stream().min());\n  \
  \      } else if (lst.stream().allMatch(i -> i >= 0)) {\n            positiveInteger\
  \ = Optional.of(lst.stream().max());\n        } else {\n            return Pair.of(null,\
  \ null);\n        }\n        return Pair.of(positiveInteger, negativeInteger);"
- "        Optional<Integer> maxInteger = lst.stream()\n            .filter(x -> x\
  \ < 0)\n            .max(Integer::compare);\n        Optional<Integer> minInteger\
  \ = lst.stream()\n            .filter(x -> x > 0)\n            .min(Integer::compare);\n\
  \        if (maxInteger.isPresent() && minInteger.isPresent()) {\n            return\
  \ Pair.of(maxInteger, minInteger);\n        } else {\n            return Pair.of(Optional.empty(),\
  \ Optional.empty());\n        }"
- "        Pair<Optional<Integer>, Optional<Integer>> ret = null;\n        if (lst.stream().allMatch(x\
  \ -> x < 0)) {\n            Optional<Integer> large = lst.stream().max(Collections.reverseOrder());\n\
  \            Optional<Integer> small = lst.stream().min(Collections.reverseOrder());\n\
  \            ret = new Pair<>(large, small);\n        }\n        return ret;"
- "        Optional<Integer> a = Optional.empty();\n        Optional<Integer> b =\
  \ Optional.empty();\n        for (Integer i : lst) {\n            Pair<Optional<Integer>,\
  \ Optional<Integer>> r = largest_smallest_integer(i);\n            a = a.orElse(r.getA());\n\
  \            b = b.orElse(r.getB());\n        }\n        return new Pair<>(a, b);"
- "        if (lst.isEmpty()) return null;\n        Optional<Integer> smallest = Optional.of(lst.get(0));\n\
  \        Optional<Integer> largest = Optional.of(lst.get(0));\n        for (int\
  \ i = 1; i < lst.size(); i++) {\n            if (lst.get(i) < smallest) smallest\
  \ = Optional.of(lst.get(i));\n            if (lst.get(i) > largest) largest = Optional.of(lst.get(i));\n\
  \        }\n        return Pair.of(largest, smallest);"
- "        // Write your code here\n        Optional<Integer> largest = lst.stream().max(Integer::compareTo).map(Integer::valueOf).orElse(null);\n\
  \        Optional<Integer> smallest = lst.stream().min(Integer::compareTo).map(Integer::valueOf).orElse(null);\n\
  \        return new ImmutablePair<>(largest, smallest);"
- "        List<Integer> negative = new ArrayList<>();\n        List<Integer> positive\
  \ = new ArrayList<>();\n        Optional<Integer> maxNegative = Optional.empty();\n\
  \        Optional<Integer> minPositive = Optional.empty();\n        int i = 0;\n\
  \        while (i < lst.size()) {\n            if (lst.get(i) < 0) {\n         \
  \       negative.add(lst.get(i));\n            } else {\n                positive.add(lst.get(i));\n\
  \            }\n            i++;\n        }\n        if (negative.isEmpty()) {\n\
  \            return Pair.of(Optional.of(Integer.MIN_VALUE), Optional.of(Integer.MAX_VALUE));\n\
  \        }\n        if (positive.isEmpty()) {\n            return Pair.of(Optional.of(Integer.MAX_VALUE),\
  \ Optional.of(Integer.MIN_VALUE));\n        }\n        // First pass: if all integers\
  \ are negative, choose the negative integer\n        // (i.e. the largest). Otherwise,\
  \ the positive integer\n        if (negative.equals(negative)) {\n            maxNegative\
  \ = Optional.of(Collections.max(negative));\n        } else {\n            maxNegative\
  \ = Optional.of(Collections.max(negative)); //Collections.max(negative) gives the\
  \ largest integer in the list\n        }\n        // Second pass: if all integers\
  \ are positive, choose the positive integer\n        // (i.e. the smallest). Otherwise,\
  \ the negative integer\n        if (positive.equals(positive)) {\n            minPositive\
  \ = Optional.of(Collections.min(positive));\n        } else {\n            minPositive\
  \ = Optional.of(Collections.min(positive));\n        }\n        return Pair.of(maxNegative,\
  \ minPositive);"
- "        List<Integer> ints = new ArrayList<>();\n        for (Integer x : lst)\
  \ {\n            ints.add(x);\n        }\n        if (ints.size() == 0) {\n    \
  \        return Pair.of(Optional.empty(), Optional.empty());\n        }\n      \
  \  Collections.sort(ints);\n        return Pair.of(Optional.of(ints.get(0)), Optional.of(ints.get(lst.size()\
  \ - 1)));"
- "        Optional<Integer> positive = lst.stream().filter(x -> x >= 0).findFirst();\n\
  \        Optional<Integer> negative = lst.stream().filter(x -> x < 0).findFirst();\n\
  \        if (positive.isPresent() && negative.isPresent())\n            return Pair.of(positive,\
  \ negative);\n        if (positive.isPresent() == false)\n            return Pair.of(Optional.of(null),\
  \ Optional.of(null));\n        if (negative.isPresent() == false)\n            return\
  \ Pair.of(Optional.of(null), Optional.of(null));\n        return Pair.of(Optional.of(positive.orElse(null)),\
  \ Optional.of(negative.orElse(null)));"
- "        if(lst.isEmpty()) {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }\n        Optional<Integer> maxNegative = lst.stream().filter(x -> x <\
  \ 0).findAny();\n        Optional<Integer> minPositive = lst.stream().filter(x ->\
  \ x >= 0).findAny();\n        if(maxNegative.isPresent()) return Pair.of(Optional.of(maxNegative.get()),\
  \ Optional.empty());\n        if(minPositive.isPresent()) return Pair.of(Optional.empty(),\
  \ Optional.of(minPositive.get()));\n        return Pair.of(Optional.empty(), Optional.empty());"
- "        // TODO: Write your code here\n        Optional<Integer> largest_integer\
  \ = null;\n        Optional<Integer> smallest_integer = null;\n\n        if (lst.stream().noneMatch(e\
  \ -> e < 0)) {\n            largest_integer = lst.stream().max(Comparator.naturalOrder());\n\
  \        }\n\n        if (lst.stream().noneMatch(e -> e > 0)) {\n            smallest_integer\
  \ = lst.stream().min(Comparator.naturalOrder());\n        }\n\n        return new\
  \ Tuple<>(largest_integer, smallest_integer);"
- "        List<Integer> positive = new ArrayList<>();\n        List<Integer> negative\
  \ = new ArrayList<>();\n        for (int i : lst) {\n            if (i < 0) {\n\
  \                negative.add(i);\n            } else {\n                positive.add(i);\n\
  \            }\n        }\n\n        if (positive.isEmpty()) {\n            return\
  \ Pair.of(Optional.of(null), Optional.of(null));\n        } else if (negative.isEmpty())\
  \ {\n            return Pair.of(Optional.of(null), Optional.of(null));\n       \
  \ }\n\n        int max = Collections.max(positive);\n        int min = Collections.min(negative);\n\
  \        return Pair.of(Optional.of(max), Optional.of(min));"
- "        if (lst.isEmpty())\n            return Pair.make(Optional.empty(), Optional.empty());\n\
  \        Optional<Integer> smallest = Optional.empty();\n        Optional<Integer>\
  \ largest = Optional.empty();\n        int smallestIndex = 0;\n        int largestIndex\
  \ = 0;\n        for (Integer number : lst) {\n            if (number.intValue()\
  \ < 0) {\n                if (!smallest.isPresent())\n                    smallest\
  \ = Optional.of(number);\n                else\n                    smallest = Optional.of(Math.min(smallest,\
  \ number));\n                smallestIndex++;\n            } else {\n          \
  \      if (!largest.isPresent())\n                    largest = Optional.of(number);\n\
  \                else\n                    largest = Optional.of(Math.max(largest,\
  \ number));\n                largestIndex++;\n            }\n        }\n       \
  \ return Pair.make(largest, smallest);"
- "        Pair<Optional<Integer>, Optional<Integer>> ret;\n        if (lst.isEmpty())\n\
  \            return (null,null);\n        if (lst.isEmpty() % 2 == 1) {\n      \
  \      ret= largestSmallestIntegersAux(lst);\n            return ret;\n        }\n\
  \        Pair<Optional<Integer>, Optional<Integer>> ret= largestSmallestIntegersAux(lst,\
  \ 0, 0);\n        return ret;"
- "        if (lst.isEmpty()) return null;\n        int maxNegative = -Integer.MAX_VALUE;\n\
  \        int minPositive = Integer.MAX_VALUE;\n        int maxNegativeInList = -1;\n\
  \        int minPositiveInList = -1;\n        for (int num : lst) {\n          \
  \  if (num < 0 && num > maxNegative) {\n                maxNegativeInList = num;\n\
  \            }\n            if (num > 0 && num < minPositive) {\n              \
  \  minPositiveInList = num;\n            }\n            if (num > maxNegative &&\
  \ num < minPositive) {\n                maxNegative = num;\n                minPositive\
  \ = num;\n            }\n        }\n        Optional<Integer> maxNegativeInPair\
  \ = Optional.ofNullable(maxNegativeInList);\n        Optional<Integer> minPositiveInPair\
  \ = Optional.ofNullable(minPositiveInList);\n        if (maxNegativeInPair.isPresent()\
  \ && minPositiveInPair.isPresent()) return new Tuple2<>(maxNegativeInPair, minPositiveInPair);\n\
  \        else return null;"
- "        Optional<Integer> largest = lst.stream().max();\n        Optional<Integer>\
  \ smallest = lst.stream().min();\n        return Pair.of(largest, smallest);"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        for(Integer i : lst) {\n            if (i.signum()\
  \ >= 0) {\n                smallest = Optional.of(i);\n            } else {\n  \
  \              largest = Optional.of(i);\n            }\n        }\n        return\
  \ new ImmutablePair<>(largest, smallest);"
- "        Optional<Integer> biggest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        for (int el : lst) {\n            if (el\
  \ < 0)\n                biggest = Optional.of(el);\n            else if (el > 0)\n\
  \                smallest = Optional.of(el);\n        }\n        return biggest.map(x\
  \ -> Pair.of(x, smallest)).orElseGet(Pair::of);"
- "        if (lst.isEmpty()) return new Pair<>(null, null);\n        // Get a sorted\
  \ list\n        Arrays.sort(lst);\n        // Get min and max\n        Optional<Integer>\
  \ min = Optional.ofNullable(lst.get(0)).flatMap(i -> Optional.ofNullable(i));\n\
  \        Optional<Integer> max = Optional.ofNullable(lst.get(lst.size() - 1)).flatMap(i\
  \ -> Optional.ofNullable(i));\n        // Check if negative and positive\n     \
  \   if (min.flatMap(i -> Optional.ofNullable(i)).filter(i -> i < 0) == null) {\n\
  \            return new Pair<>(min, max);\n        } else if (max.flatMap(i -> Optional.ofNullable(i)).filter(i\
  \ -> i >= 0) == null) {\n            return new Pair<>(max, min);\n        } else\
  \ {\n            return new Pair<>(max.flatMap(i -> Optional.ofNullable(i)), min.flatMap(i\
  \ -> Optional.ofNullable(i)));\n        }"
- "        int[] a = lst.stream().filter(x -> x < 0).sorted().toArray();\n       \
  \ int first = a[0];\n        int second = a[1];\n        if (a.length == 2) {\n\
  \            first = second = 0;\n        }\n        Optional<Integer> first = Optional.of(first);\n\
  \        Optional<Integer> second = Optional.of(second);\n        if (first == second\
  \ && second == 0) {\n            return Pair.of(first, second);\n        }\n   \
  \     return Pair.of(first, largestSmallestIntegers(Arrays.copyOfRange(a, 2, a.length)));"
- "        Optional<Integer> minNum = Optional.of(Integer.MIN_VALUE);\n        Optional<Integer>\
  \ maxNum = Optional.of(Integer.MAX_VALUE);\n\n        List<Integer> negNums = new\
  \ ArrayList<Integer>();\n        List<Integer> posNums = new ArrayList<Integer>();\n\
  \n        // Get rid of negative numbers\n        for (Integer x : lst) {\n    \
  \        if (x < 0) negNums.add(x);\n            if (x >= 0) posNums.add(x);\n \
  \       }\n\n        // Get the smallest number\n        minNum = Optional.min(negNums);\n\
  \        if (minNum.isEmpty()) minNum = null;\n\n        // Get the largest number\n\
  \        maxNum = Optional.max(posNums);\n        if (maxNum.isEmpty()) maxNum =\
  \ null;\n\n        // Return the results\n        return Pair.of(minNum, maxNum);"
- "        Comparator<Integer> comp = (x, y) -> x > y ? 1 : -1;\n        Optional<Integer>\
  \ minInd = Optional.empty();\n        Optional<Integer> maxInd = Optional.empty();\n\
  \        for (int i : lst) {\n            if (minInd.isPresent() && maxInd.isPresent()\
  \ && comp.compare(i, minInd.get()) < 0)\n                return Pair.of(Optional.of(maxInd.get()),\
  \ Optional.empty());\n            else if (minInd.isPresent() && maxInd.isPresent()\
  \ && comp.compare(i, maxInd.get()) > 0)\n                return Pair.of(Optional.empty(),\
  \ Optional.of(minInd.get()));\n            else if (minInd.isPresent() && !maxInd.isPresent()\
  \ && comp.compare(i, minInd.get()) < 0)\n                return Pair.of(Optional.of(maxInd.get()),\
  \ Optional.of(minInd.get()));\n            else if (minInd.isPresent() && !maxInd.isPresent()\
  \ && comp.compare(i, maxInd.get()) > 0)\n                return Pair.of(Optional.empty(),\
  \ Optional.empty());\n            else\n                minInd = Optional.of(i);\n\
  \            maxInd = Optional.of(i);\n        }\n        return Pair.of(Optional.empty(),\
  \ Optional.empty());"
- "        Optional<Integer> smallestPositiveInList = lst.stream().filter((i) -> i\
  \ >= 0).findAny();\n        Optional<Integer> largestNegativeInList = lst.stream().filter((i)\
  \ -> i < 0).findAny();\n        Optional<Integer> smallestPositiveInNone = Optional.empty();\n\
  \        Optional<Integer> largestNegativeInNone = Optional.empty();\n        if\
  \ (smallestPositiveInList.isPresent()) {\n            smallestPositiveInNone = Optional.of(smallestPositiveInList.get());\n\
  \        }\n        if (largestNegativeInList.isPresent()) {\n            largestNegativeInNone\
  \ = Optional.of(largestNegativeInList.get());\n        }\n        return Pair.create(smallestPositiveInNone,\
  \ largestNegativeInNone);"
- "        // Create two lists, one for negative integers, and one for positive integers.\n\
  \        List<Integer> negative = new ArrayList<>();\n        List<Integer> positive\
  \ = new ArrayList<>();\n        Optional<Integer> negativeValue = Optional.empty();\n\
  \        Optional<Integer> positiveValue = Optional.empty();\n        for (int number\
  \ : lst) {\n            if (number < 0) {\n                negative.add(number);\n\
  \                negativeValue = Optional.of(number);\n            } else {\n  \
  \              positive.add(number);\n                positiveValue = Optional.of(number);\n\
  \            }\n        }\n        Optional<Integer> negativeSorted = Optional.of(Collections.sort(negative));\n\
  \        Optional<Integer> positiveSorted = Optional.of(Collections.sort(positive));\n\
  \        // Find the largest of negative/positive and return\n        return Pair.of(\n\
  \                Optional.ofNullable(negativeValue).filter(Optional::isPresent).map(Optional::get),\n\
  \                Optional.ofNullable(positiveValue).filter(Optional::isPresent).map(Optional::get)\n\
  \        );"
- "        if (lst.isEmpty()) {\n            return new Pair<>(Optional.empty(), Optional.empty());\n\
  \        }\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n\
  \        for (Integer i : lst) {\n            min = Math.min(min, i);\n        \
  \    max = Math.max(max, i);\n        }\n        if (min < 0 && max > 0) {\n   \
  \         return new Pair<>(Optional.of(max), Optional.of(min));\n        }\n  \
  \      if (min >= 0) {\n            return new Pair<>(Optional.of(min), Optional.empty());\n\
  \        }\n        return new Pair<>(Optional.empty(), Optional.of(max));"
- "        Optional<Integer> smallest = Optional.ofNullable(lst.get(0)).map(Integer::intValue);\n\
  \        Optional<Integer> largest = Optional.ofNullable(lst.get(0)).map(Integer::intValue);\n\
  \        lst.stream().filter(i -> i < 0).forEach(i -> {\n            Optional<Integer>\
  \ nextSmallest = Optional.ofNullable(lst.get(i)).map(Integer::intValue);\n     \
  \       if (nextSmallest.isPresent()) {\n                if (nextSmallest.get()\
  \ < smallest.get()) {\n                    smallest = nextSmallest;\n          \
  \      }\n            }\n        });\n        lst.stream().filter(i -> i > 0).forEach(i\
  \ -> {\n            Optional<Integer> nextLargest = Optional.ofNullable(lst.get(i)).map(Integer::intValue);\n\
  \            if (nextLargest.isPresent()) {\n                if (nextLargest.get()\
  \ > largest.get()) {\n                    largest = nextLargest;\n             \
  \   }\n            }\n        });\n        return new Pair<>(smallest, largest);"
- "        if (lst.isEmpty()) {\n            return new Pair<>(Optional.empty(), Optional.empty());\n\
  \        }\n        Pair<Optional<Integer>, Optional<Integer>> max = new Pair<>(Optional.empty(),\
  \ Optional.empty());\n        Pair<Optional<Integer>, Optional<Integer>> min = new\
  \ Pair<>(Optional.empty(), Optional.empty());\n        Integer maxValue = Integer.MIN_VALUE;\n\
  \        Integer minValue = Integer.MAX_VALUE;\n        for (Integer value : lst)\
  \ {\n            if (value.intValue() > maxValue.intValue()) {\n               \
  \ maxValue = value;\n            } else if (value.intValue() < minValue.intValue())\
  \ {\n                minValue = value;\n            }\n        }\n        max.second\
  \ = Optional.of(maxValue);\n        min.second = Optional.of(minValue);\n      \
  \  return max.first.compareTo(min.first) >= 0 ? max : min;"
- "        List<Pair<Optional<Integer>, Optional<Integer>>> pairList = new ArrayList<>();\n\
  \        int smallestInteger = 0;\n        int largestInteger = 0;\n        for\
  \ (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n      \
  \          smallestInteger = Integer.MAX_VALUE;\n            } else {\n        \
  \        smallestInteger = Integer.MIN_VALUE;\n            }\n            if (lst.get(i)\
  \ > 0) {\n                largestInteger = Integer.MIN_VALUE;\n            } else\
  \ {\n                largestInteger = Integer.MAX_VALUE;\n            }\n      \
  \      Pair<Optional<Integer>, Optional<Integer>> p1 = Pair.of(Optional.ofNullable(smallestInteger),\
  \ Optional.ofNullable(largestInteger));\n            pairList.add(p1);\n       \
  \ }\n        if (pairList.size() == 0) {\n            return Pair.of(Optional.ofNullable(smallestInteger),\
  \ Optional.ofNullable(largestInteger));\n        } else {\n            return Pair.of(pairList.get(pairList.size()\
  \ - 1), pairList.get(0));\n        }"
- "        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n  \
  \      Optional<Integer> minInt = Optional.empty();\n        Optional<Integer> maxInt\
  \ = Optional.empty();\n\n        for (Integer i : lst) {\n            int current\
  \ = i;\n            if (current > max) {\n                max = current;\n     \
  \           maxInt = Optional.of(current);\n            }\n\n            if (current\
  \ < min) {\n                min = current;\n                minInt = Optional.of(current);\n\
  \            }\n        }\n\n        return Pair.of(minInt, maxInt);"
- "        int largest = -1;\n        int smallest = Integer.MIN_VALUE;\n        for\
  \ (Integer i : lst) {\n            if (i < 0) largest = i;\n            else if\
  \ (i > smallest) smallest = i;\n        }\n        return Pair.of(Optional.of(largest),\
  \ Optional.of(smallest));"
- "        // Code here\n        int largest = -1;\n        int smallest = Integer.MAX_VALUE;\n\
  \        for(int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < smallest)\
  \ {\n                smallest = lst.get(i);\n            }\n            if (lst.get(i)\
  \ > largest) {\n                largest = lst.get(i);\n            }\n        }\n\
  \        return Pair.of( Optional.ofNullable(largest), Optional.ofNullable(smallest));"
- '        // return Pair.of(x, y) where x is Optional<Integer> and y is Optional<Integer>'
- "        Optional<Integer> first = lst.stream().min((a, b) -> Integer.compare(a,\
  \ b));\n        Optional<Integer> last = lst.stream().max((a, b) -> Integer.compare(a,\
  \ b));\n        return new Pair<>(first, last);"
- "        Optional<Integer> biggest = lst.stream().max(Comparator.reverseOrder());\n\
  \        Optional<Integer> smallest = lst.stream().min(Comparator.naturalOrder());\n\
  \        return biggest.map(v -> Optional.ofNullable(v)).flatMap(Optional::of).orElse(smallest).map(v\
  \ -> Optional.ofNullable(v)).flatMap(Optional::of).orElse(null);"
- "        // If there are no integers, return (None, None)\n        if (lst.size()\
  \ == 0) {\n            return (Optional.of(null), Optional.of(null));\n        }\n\
  \        // If there is only one integer in the list, return (Some(integer), None)\n\
  \        if (lst.size() == 1) {\n            return Optional.of(Optional.of(lst.get(0)),\
  \ Optional.empty());\n        }\n        // Create a map to store negative and positive\
  \ integers\n        Map<Boolean, Integer> isNegative = new HashMap<>();\n      \
  \  Map<Boolean, Integer> isPositive = new HashMap<>();\n        for (int i = 0;\
  \ i < lst.size(); i++) {\n            int num = lst.get(i);\n            if (isPositive.containsKey(num))\
  \ {\n                isPositive.put(num, isPositive.get(num) + 1);\n           \
  \ } else {\n                isPositive.put(num, 1);\n            }\n           \
  \ if (isNegative.containsKey(num)) {\n                isNegative.put(num, isNegative.get(num)\
  \ + 1);\n            } else {\n                isNegative.put(num, 1);\n       \
  \     }\n        }\n        // Use the map to determine which integers are negative\
  \ and positive\n        Set<Boolean> keys = isNegative.keySet();\n        boolean\
  \ allNegative = keys.stream().allMatch(key -> isNegative.get(key) < 1);\n      \
  \  boolean allPositive = keys.stream().allMatch(key -> isPositive.get(key) > 0);\n\
  \n        // If the largest is negative, return the smallest positive\n        //\
  \ integer. If there are no negative and positive integers, return\n        // None\n\
  \        if (allNegative) {\n            Integer largest = Collections.max(isPositive.values());\n\
  \            Integer smallest = Collections.min(isPositive.values());\n        \
  \    return Optional.of(Optional.of(smallest), Optional.empty());\n        }\n \
  \       // If the largest is positive, return the smallest negative\n        //\
  \ integer. If there are no negative and positive integers, return\n        // None\n\
  \        if (allPositive) {\n            Integer largest = Collections.max(isNegative.values());\n\
  \            Integer smallest = Collections.min(isNegative.values());\n        \
  \    return Optional.of(Optional.of(largest), Optional.empty());\n        }\n  \
  \      // If the largest is negative and all the positive integers are smaller\n\
  \        // than the largest negative integer, return (None, None)\n        if (allNegative)\
  \ {\n            Integer largest = Collections.max(isPositive.values());\n     \
  \       Integer smallest = Collections.min(isNegative.values());\n            return\
  \ Optional.of(Optional.of(largest), Optional.empty());\n        }\n        // If\
  \ the largest is positive and all the negative integers are greater\n        //\
  \ than the smallest positive integer, return (None, None)\n        if (allPositive)\
  \ {\n            Integer largest = Collections.max(isNegative.values());\n     \
  \       Integer smallest = Collections.min("
- "        if (lst.stream().noneMatch(n -> n < 0)) {\n            return Pair.of(Optional.empty(),\
  \ Optional.empty());\n        }\n        if (lst.stream().noneMatch(n -> n > 0))\
  \ {\n            return Pair.of(Optional.empty(), Optional.empty());\n        }\n\
  \        int firstNegativeInteger = lst.stream().max(Comparator.naturalOrder()).get();\n\
  \        int firstPositiveInteger = lst.stream().min(Comparator.naturalOrder()).get();\n\
  \        return Pair.of(Optional.of(firstNegativeInteger), Optional.of(firstPositiveInteger));"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        for (Integer i : lst) {\n            largest\
  \ = Optional.of(i.max());\n            smallest = Optional.of(i.min());\n      \
  \  }\n        return new Pair<>(largest, smallest);"
- "        if (lst.isEmpty()) {\n            return new Pair<>(Optional.empty(), Optional.empty());\n\
  \        }\n        Optional<Integer> negativeInt = Optional.ofNullable(lst.stream().filter(x\
  \ -> x < 0).max());\n        Optional<Integer> positiveInt = Optional.ofNullable(lst.stream().filter(x\
  \ -> x > 0).min());\n        if (negativeInt.isPresent() && positiveInt.isPresent())\
  \ {\n            return new Pair<>(negativeInt, positiveInt);\n        }\n     \
  \   if (negativeInt.isPresent()) {\n            return new Pair<>(negativeInt, Optional.empty());\n\
  \        }\n        if (positiveInt.isPresent()) {\n            return new Pair<>(Optional.empty(),\
  \ positiveInt);\n        }\n        return new Pair<>(Optional.empty(), Optional.empty());"
- "        int maxNegative = Integer.MIN_VALUE;\n        int minPositive = Integer.MAX_VALUE;\n\
  \n        for (Integer i : lst) {\n            if (i < 0) {\n                maxNegative\
  \ = i;\n            } else if (i > 0 ) {\n                minPositive = i;\n   \
  \         }\n        }\n\n        return Pair.create(Optional.of(maxNegative), Optional.of(minPositive));"
- "        Optional<Integer> largestInteger = null;\n        Optional<Integer> smallestInteger\
  \ = null;\n        for (int number : lst) {\n            if (number < 0) {\n   \
  \             if (smallestInteger == null || number < smallestInteger.orElse(number))\
  \ {\n                    smallestInteger = Optional.of(number);\n              \
  \  }\n            } else {\n                if (largestInteger == null || number\
  \ > largestInteger.orElse(number)) {\n                    largestInteger = Optional.of(number);\n\
  \                }\n            }\n        }\n        return Pair.of(largestInteger,\
  \ smallestInteger);"
- "        Optional<Integer> a = None;\n        Optional<Integer> b = None;\n    \
  \    \n        if (lst.stream().allMatch(i -> i < 0)) {\n            a = Optional.of(null);\n\
  \        }\n        if (lst.stream().allMatch(i -> i >= 0)) {\n            b = Optional.of(null);\n\
  \        }\n\n        return Pair.of(a, b);"
- "        Optional<Integer> max = Optional.empty();\n        Optional<Integer> min\
  \ = Optional.empty();\n        if (lst.stream().noneMatch(i -> i < 0)) {\n     \
  \       max = lst.stream().max();\n        }\n        if (lst.stream().noneMatch(i\
  \ -> i > 0)) {\n            min = lst.stream().min();\n        }\n        return\
  \ Pair.of(max, min);"
- "        ArrayList<Integer> lstCopy = new ArrayList<>();\n        lst.stream().filter(i\
  \ -> !lstCopy.add(i)).collect(Collectors.toCollection(ArrayList::new));\n      \
  \  if (lstCopy.isEmpty()) return Pair.of(Optional.empty(), Optional.empty());\n\
  \        if (lstCopy.size() == 1) return Pair.of(Optional.of(lstCopy.get(0)), Optional.empty());\n\
  \        Integer max = new Integer(0);\n        Integer min = new Integer(0);\n\
  \        lstCopy.stream().filter(i -> i < 0).forEach(i -> max = new Integer(max).max(i,\
  \ max));\n        lstCopy.stream().filter(i -> i > 0).forEach(i -> min = new Integer(min).min(i,\
  \ min));\n        return Pair.of(Optional.of(max), Optional.of(min));"
- "        \n        if (lst.isEmpty()) {\n            return Pair.of(Optional.empty(),\
  \ Optional.empty());\n        }\n        \n        int min = Integer.MAX_VALUE;\n\
  \        Optional<Integer> minOpt = Optional.empty();\n        \n        int max\
  \ = Integer.MIN_VALUE;\n        Optional<Integer> maxOpt = Optional.empty();\n \
  \       \n        for (int item : lst) {\n            min = Math.min(item, min);\n\
  \            max = Math.max(item, max);\n            \n            if (item < 0)\
  \ {\n                minOpt = Optional.of(Integer.MIN_VALUE);\n            } else\
  \ {\n                minOpt = Optional.of(Integer.MAX_VALUE);\n            }\n \
  \       }\n        \n        return Pair.of(maxOpt, minOpt);"
- "        int[] a = lst.stream().mapToInt(Integer::intValue).toArray();\n       \
  \ int b = 0;\n        int c = 0;\n        for (int i = a.length - 1; i >= 0; i--)\
  \ {\n            if ((a[i] > 0 && c < a[i]) || (a[i] < 0 && b < a[i]))\n       \
  \         b++;\n            else\n                c++;\n        }\n        if (c\
  \ == 0)\n            return null;\n        return new Pair(Optional.of(b), Optional.of(c));"
- "        Optional<Integer> max = null;\n        Optional<Integer> min = null;\n\
  \        for (int i : lst) {\n            if (min == null || i < min) {\n      \
  \          min = Optional.of(i);\n            }\n            if (max == null ||\
  \ i > max) {\n                max = Optional.of(i);\n            }\n        }\n\
  \        return Pair.of(max, min);"
- "        Optional<Integer> smallestInteger = Optional.empty();\n        Optional<Integer>\
  \ largestInteger = Optional.empty();\n        for(Integer number : lst){\n     \
  \       if( number.compareTo(smallestInteger) < 0 ){\n                smallestInteger\
  \ = number;\n            }\n            if( number.compareTo(largestInteger) > 0\
  \ ){\n                largestInteger = number;\n            }\n        }\n     \
  \   return Pair.of(largestInteger, smallestInteger);"
- "        if (lst.isEmpty()) {\n            return Pair.make(Optional.empty(), Optional.empty());\n\
  \        }\n        ArrayList<Integer> positive = new ArrayList<>();\n        ArrayList<Integer>\
  \ negative = new ArrayList<>();\n        int minPositive = Integer.MAX_VALUE;\n\
  \        int minNegative = Integer.MAX_VALUE;\n        int maxPositive = Integer.MIN_VALUE;\n\
  \        int maxNegative = Integer.MIN_VALUE;\n        for (Integer i : lst) {\n\
  \            if (i < 0) {\n                negative.add(i);\n                if\
  \ (i < minNegative) {\n                    minNegative = i;\n                } else\
  \ if (i > maxNegative) {\n                    maxNegative = i;\n               \
  \ }\n            } else {\n                positive.add(i);\n                if\
  \ (i < minPositive) {\n                    minPositive = i;\n                } else\
  \ if (i > maxPositive) {\n                    maxPositive = i;\n               \
  \ }\n            }\n        }\n        if (minNegative > minPositive) {\n      \
  \      return Pair.make(Optional.of(maxNegative), Optional.of(maxPositive));\n \
  \       } else {\n            return Pair.make(Optional.of(maxPositive), Optional.of(maxNegative));\n\
  \        }"
- "        Optional<Integer> smallestNumber = lst.stream().min(Integer::compare).get();\n\
  \        Optional<Integer> largestNumber = lst.stream().max(Integer::compare).get();\n\
  \        return Optional.ofNullable(smallestNumber).orElseGet(() -> Optional.ofNullable(largestNumber));"
- "        Optional<Integer> pos1 = Optional.empty();\n        Optional<Integer> pos2\
  \ = Optional.empty();\n        Optional<Integer> neg1 = Optional.empty();\n    \
  \    Optional<Integer> neg2 = Optional.empty();\n        for (int i = 0; i < lst.size();\
  \ i++) {\n            if (lst.get(i) < 0) {\n                neg1 = neg1.orElse(lst.get(i));\n\
  \            } else if (lst.get(i) > 0) {\n                pos2 = pos2.orElse(lst.get(i));\n\
  \            } else {\n                if (neg1.isPresent() || neg2.isPresent())\
  \ {\n                    return Pair.of(Optional.empty(), Optional.empty());\n \
  \               }\n            }\n        }\n        if (neg1.isPresent() && neg2.isPresent())\
  \ {\n            return Pair.of(neg1, neg2);\n        } else if (pos1.isPresent()\
  \ && pos2.isPresent()) {\n            return Pair.of(pos1, pos2);\n        } else\
  \ {\n            return Pair.of(Optional.empty(), Optional.empty());\n        }"
- "        if (lst == null || lst.isEmpty()) return null;\n        // Sort the list\
  \ in ascending order\n        Collections.sort(lst);\n        // Start with smallest\n\
  \        Optional<Integer> smallest = Optional.ofNullable(lst.get(0));\n       \
  \ // Iterate through the list, updating smallest and largest as necessary\n    \
  \    for (int i = 1; i < lst.size(); i++) {\n            Optional<Integer> current\
  \ = Optional.ofNullable(lst.get(i));\n            if (current.isPresent() && smallest.isPresent()\
  \ && smallest.get().compareTo(current.get()) < 0)\n                smallest = current;\n\
  \            else if (current.isPresent() && largest.isPresent() && largest.get().compareTo(current.get())\
  \ > 0)\n                largest = current;\n        }\n        // Return tuple with\
  \ either largest or smallest value\n        return smallest.flatMap(i -> largest.flatMap(j\
  \ -> new Pair(i, j)));"
- "        // If there are no negative or positive integers, return them as None\n\
  \        if (lst.stream().noneMatch (i -> i < 0)) {\n            return Pair.of(Optional.of(null),\
  \ Optional.of(null));\n        }\n        \n        // Get the largest and smallest\
  \ integers\n        Optional<Integer> maxOptional = lst.stream().max(Comparator.naturalOrder());\n\
  \        Optional<Integer> minOptional = lst.stream().min(Comparator.naturalOrder());\n\
  \n        // If there is no max or min, replace the None with None\n        if (maxOptional.isEmpty()\
  \ && minOptional.isEmpty()) {\n            return Pair.of(Optional.of(null), Optional.of(null));\n\
  \        }\n        return Pair.of(maxOptional, minOptional);"
- "        if (lst.isEmpty()) return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        Optional<Integer> largest = lst.stream().max(Integer::compare);\n\
  \        Optional<Integer> smallest = lst.stream().min(Integer::compare);\n    \
  \    return new Pair<Optional<Integer>, Optional<Integer>>(largest, smallest);"
- "        Optional<Integer> ls = lst.stream().filter(i -> i < 0).findFirst();\n \
  \       Optional<Integer> lp = lst.stream().filter(i -> i > 0).findFirst();\n  \
  \      return Pair.of(ls, lp);"
- "        \n        // Find negatives\n        Optional<Integer> aOpt = lst.stream().filter(i\
  \ -> i < 0).findAny();\n        \n        // Find positives\n        Optional<Integer>\
  \ bOpt = lst.stream().filter(i -> i > 0).findAny();\n        \n        // Return\
  \ None if a or b are None\n        if (aOpt.isPresent() && bOpt.isPresent()) {\n\
  \            \n            // Find maximum\n            int max = Collections.max(lst);\n\
  \            \n            // Find minimum\n            int min = Collections.min(lst);\n\
  \            \n            // Create a pair using Optional values\n            return\
  \ Pair.of(aOpt.map(i -> i), bOpt.map(i -> min));\n        }\n        return null;"
- "        ArrayList<Integer> intList = new ArrayList<>();\n\n        for (int i :\
  \ lst) {\n            if (i < 0) {\n                intList.add(Math.abs(i));\n\
  \            } else {\n                intList.add(i);\n            }\n        }\n\
  \n        int intMax = Collections.max(intList);\n        int intMin = Collections.min(intList);\n\
  \n        Optional<Integer> intMaxOptional = Optional.of(intMax);\n        Optional<Integer>\
  \ intMinOptional = Optional.of(intMin);\n\n        if (intMaxOptional.isPresent()\
  \ && intMinOptional.isPresent()) {\n            return new Pair<>(intMaxOptional.map(b\
  \ -> Math.min(a, b)), intMinOptional.map(b -> Math.max(a, b)));\n        }\n\n \
  \       return Optional.of(null);"
- '        return lst.stream().max(Integer::compareTo).map(Integer::valueOf).orElse(null);'
- "        Optional<Integer> a = Optional.empty();\n        Optional<Integer> b =\
  \ Optional.empty();\n        for (Integer i : lst) {\n            if (b.isPresent()\
  \ || a.isPresent()) {\n                break;\n            }\n            boolean\
  \ isAPositive = i.signum() >= 0;\n            if (isAPositive != b.isPresent())\
  \ {\n                b = Optional.of(i);\n            } else if (!isAPositive) {\n\
  \                a = Optional.of(i);\n            }\n        }\n        return Pair.of(a,\
  \ b);"
- "        Integer a = null;\n        Integer b = null;\n        \n        if(lst.isEmpty())\
  \ {\n            return new Pair<>(a, None);\n        }\n        \n        Optional<Integer>\
  \ first_negative_int = lst.stream()\n                .filter(v -> v < 0)\n     \
  \           .findAny();\n        \n        Optional<Integer> first_positive_int\
  \ = lst.stream()\n                .filter(v -> v >= 0)\n                .findAny();\n\
  \        \n        if (first_negative_int != null && first_positive_int != null)\
  \ {\n            int first_negative_value = first_negative_int.orElse(null);\n \
  \           int first_positive_value = first_positive_int.orElse(null);\n      \
  \      if (first_negative_value < first_positive_value) {\n                a = first_negative_value;\n\
  \            } else {\n                a = first_positive_value;\n            }\n\
  \            b = first_positive_value;\n        } else {\n            return new\
  \ Pair<>(a, None);\n        }\n        \n        Optional<Integer> second_negative_int\
  \ = lst.stream()\n                .filter(v -> v < 0)\n                .filter(v\
  \ -> v <= a)\n                .findAny();\n        \n        Optional<Integer> second_positive_int\
  \ = lst.stream()\n                .filter(v -> v >= 0)\n                .filter(v\
  \ -> v <= a)\n                .findAny();\n        \n        if (second_negative_int\
  \ != null && second_positive_int != null) {\n            int second_negative_value\
  \ = second_negative_int.orElse(null);\n            int second_positive_value = second_positive_int.orElse(null);\n\
  \            if (second_negative_value < second_positive_value) {\n            \
  \    a = second_negative_value;\n            } else {\n                a = second_positive_value;\n\
  \            }\n            b = second_positive_value;\n        } else {\n     \
  \       return new Pair<>(a, None);\n        }\n        \n        Optional<Integer>\
  \ third_negative_int = lst.stream()\n                .filter(v -> v < 0)\n     \
  \           .filter(v -> v <= a)\n                .filter(v -> v >= b)\n       \
  \         .findAny();\n        \n        Optional<Integer> third_positive_int =\
  \ lst.stream()\n                .filter(v -> v >= 0)\n                .filter(v\
  \ -> v <= a)\n                .filter(v -> v >= b)\n                .findAny();\n\
  \        \n        if (third_negative_int != null && third_positive_int != null)\
  \ {\n            int third_negative_value = third_negative_int.orElse(null);\n \
  \           int third_positive_value = third_positive_int.orElse(null);\n      \
  \      if (third_negative_value < third_positive_value) {\n                a = third_negative_value;\n\
  \            } else {\n                a = third_positive_value;\n            }\n\
  \            b = third_positive_value;\n        } else {\n            return new\
  \ Pair<>(a, None);\n        }\n        \n        Optional<Integer> fourth_negative_"
- "        Optional<Integer> a = Optional.empty();\n        Optional<Integer> b =\
  \ Optional.empty();\n        Optional<Integer> c = Optional.empty();\n        for\
  \ (int i : lst) {\n            if (a.isPresent() && b.isPresent() && c.isPresent())\
  \ {\n                Optional<Integer> x0 = largest(a, b, c);\n                Optional<Integer>\
  \ x1 = smallest(a, b, c);\n                return Pair.of(x0, x1);\n           \
  \ }\n            if (a.isPresent() && b.isPresent()) {\n                Optional<Integer>\
  \ x0 = largest(a, b, c);\n                return Pair.of(x0, Optional.of(i));\n\
  \            }\n            if (a.isPresent() && c.isPresent()) {\n            \
  \    Optional<Integer> x1 = smallest(a, b, c);\n                return Pair.of(Optional.of(i),\
  \ x1);\n            }\n            if (b.isPresent() && c.isPresent()) {\n     \
  \           Optional<Integer> x0 = largest(a, b, c);\n                return Pair.of(Optional.of(i),\
  \ x0);\n            }\n            if (a.isPresent()) {\n                return\
  \ Pair.of(a, Optional.of(i));\n            }\n            if (b.isPresent()) {\n\
  \                return Pair.of(Optional.of(i), b);\n            }\n           \
  \ if (c.isPresent()) {\n                return Pair.of(Optional.of(i), c);\n   \
  \         }\n        }\n        return Pair.of(Optional.of(-1), Optional.of(-1));"
- "        if(lst.isEmpty()) return Pair.of(Optional.empty(), Optional.empty());\n\
  \        int largest = Collections.max(lst);\n        int smallest = Collections.min(lst);\n\
  \        if(largest == smallest) return Pair.of(Optional.of(largest), Optional.of(smallest));\n\
  \        return Pair.of(largestSmallestIntegers(lst.stream().filter(n -> n < smallest).collect(toList())));"
- "        // Check if the input list is empty or not.\n        if (lst.isEmpty())\
  \ {\n            return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        }\n\n        // Declare variables for storing positive\
  \ and negative numbers.\n        int positive = 0;\n        int negative = 0;\n\n\
  \        // Declare variables for storing the largest and smallest numbers.\n  \
  \      int max;\n        int min;\n\n        // Declare a variable for storing the\
  \ first element of the list.\n        Optional<Integer> firstElem = Optional.of(lst.get(0));\n\
  \n        // Declare a variable for storing the last element of the list.\n    \
  \    Optional<Integer> lastElem = Optional.empty();\n\n        // Declare a variable\
  \ to store the first element of the list as a double.\n        Double firstElemDouble;\n\
  \n        // Declare a variable for storing the first element of the list as an\
  \ integer.\n        Integer firstElemInt;\n\n        // Declare a variable for storing\
  \ the last element of the list as a double.\n        Double lastElemDouble;\n\n\
  \        // Declare a variable for storing the last element of the list as an integer.\n\
  \        Integer lastElemInt;\n\n        // Iterate through the list.\n        for\
  \ (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n      \
  \          negative++;\n                lastElem = Optional.of(lst.get(i));\n  \
  \          } else if (lst.get(i) > 0) {\n                positive++;\n         \
  \       firstElem = Optional.of(lst.get(i));\n            }\n        }\n\n     \
  \   // If there are no negative or positive numbers, return them as None.\n    \
  \    if (negative == 0 && positive == 0) {\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(Optional.empty(), Optional.empty());\n        }\n\n       \
  \ // If there are no negative numbers, return the first element as the largest number.\n\
  \        if (negative == 0) {\n            max = firstElem.orElse(Optional.empty());\n\
  \            return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(max),\
  \ firstElem);\n        }\n\n        // If there are no positive numbers, return\
  \ the last element as the smallest number.\n        if (positive == 0) {\n     \
  \       min = lastElem.orElse(Optional.empty());\n            return new Pair<Optional<Integer>,\
  \ Optional<Integer>>(firstElem, Optional.of(min));\n        }\n\n        // If there\
  \ are both negative and positive numbers, return them as a tuple.\n        if (negative\
  \ > 0 && positive > 0) {\n            // Sort the input list\n            Collections.sort(lst);\n\
  \n            // Declare a variable to store the previous element of the list.\n\
  \            Optional<Integer> previousElem = Optional.empty();\n\n            //\
  \ Iterate through the list.\n            for (int i = 0; i < lst.size(); i++) {\n\
  \                // If "
- "        ArrayList<Integer> negative = new ArrayList<>();\n        ArrayList<Integer>\
  \ positive = new ArrayList<>();\n        ArrayList<Integer> negatives = new ArrayList<>();\n\
  \        ArrayList<Integer> positives = new ArrayList<>();\n        for(int i =\
  \ 0; i < lst.size(); i++){\n            if(lst.get(i) < 0){\n                negative.add(lst.get(i));\n\
  \                negatives.add(i);\n            }\n            if(lst.get(i) > 0){\n\
  \                positive.add(lst.get(i));\n                positives.add(i);\n\
  \            }\n        }\n        if (negative.size() > 0){\n            Collections.sort(negative);\n\
  \        }\n        if (positive.size() > 0){\n            Collections.sort(positive);\n\
  \        }\n        boolean flag = true;\n        boolean flag1 = true;\n      \
  \  if (flag){\n            flag = false;\n        }\n        if (flag1){\n     \
  \       flag1 = false;\n        }\n        if (flag && flag1){\n            int\
  \ max = negative.get(negatives.size() - 1);\n            int min = positive.get(0);\n\
  \            return new Pair<>(Optional.of(max), Optional.of(min));\n        }\n\
  \        if (negatives.size() > 0) {\n            int max = negatives.get(negatives.size()\
  \ - 1);\n            return new Pair<>(Optional.of(max), Optional.empty());\n  \
  \      }\n        if (positives.size() > 0) {\n            int min = positives.get(0);\n\
  \            return new Pair<>(Optional.empty(), Optional.of(min));\n        }\n\
  \        return new Pair<>(Optional.empty(), Optional.empty());"
- "        int[] arr = new int[100];\n        int max=-1000000000;\n        int min=1000000000;\n\
  \        for(int i=0;i<arr.length;i++){\n            arr[i]=lst.get(i);\n      \
  \      if(arr[i]<0){\n                max=Math.min(max,arr[i]);\n            }\n\
  \            else if(arr[i]>0){\n                min=Math.max(min,arr[i]);\n   \
  \         }\n        }\n        Optional<Integer> a = Optional.of(max);\n      \
  \  Optional<Integer> b = Optional.of(min);\n        if(a.isPresent() && b.isPresent()){\n\
  \            return new Pair<>(a,b);\n        }\n        return null;"
- "        \n        Optional<Integer> max = Optional.empty();\n        Optional<Integer>\
  \ min = Optional.empty();\n        int max = Integer.MIN_VALUE;\n        int min\
  \ = Integer.MAX_VALUE;\n        for (Integer i : lst) {\n            if (i < 0)\
  \ {\n                if (min.isPresent() && i == min.get()) {\n                \
  \    min = Optional.empty();\n                }\n                min = Optional.of(i);\n\
  \            } else if (i > 0 && min.isPresent() && i == min.get()) {\n        \
  \        min = Optional.empty();\n            } else {\n                if (max\
  \ == Integer.MIN_VALUE || max > i) {\n                    max = i;\n           \
  \     } else if (min == Integer.MAX_VALUE || min < i) {\n                    min\
  \ = i;\n                }\n            }\n        }\n        return Pair.of(max,\
  \ min);"
- "        Pair<Optional<Integer>, Optional<Integer>> max = largestOfNegatives(lst);\n\
  \        Pair<Optional<Integer>, Optional<Integer>> min = largestOfPositives(lst);\n\
  \        return max.map(v -> min.map((v->v))).orElse(max);"
- "        Pair<Optional<Integer>, Optional<Integer>> result = null;\n        if (lst\
  \ == null || lst.isEmpty()) result = Optional.empty();\n        else if (lst.stream().allMatch(n\
  \ -> n < 0)) result = Optional.of(Optional.ofNullable(Optional.of(lst.stream().max((a,\
  \ b) -> Integer.compare(a, b))).orElse(Integer.MIN_VALUE)));\n        else if (lst.stream().allMatch(n\
  \ -> n > 0)) result = Optional.of(Optional.ofNullable(Optional.of(lst.stream().min((a,\
  \ b) -> Integer.compare(a, b))).orElse(Integer.MAX_VALUE)));\n        return result;"
- "    Optional<Integer> minValue=Optional.empty();\n    Optional<Integer> maxValue=Optional.empty();\n\
  \    Optional<Integer> minVal=Optional.empty();\n    Optional<Integer> maxVal=Optional.empty();\n\
  \    int size=lst.size();\n    for (int i=0;i<size;i++) {\n        Integer integ=lst.get(i);\n\
  \        minValue.ifPresent(min -> {\n            if (min<integ) {\n           \
  \     minVal=Optional.of(integ);\n            }\n        });\n        maxValue.ifPresent(max\
  \ -> {\n            if (max>integ) {\n                maxVal=Optional.of(integ);\n\
  \            }\n        });"
- "        Optional<Integer> positive = lst.stream().filter(i -> i >= 0).findAny();\n\
  \        Optional<Integer> negative = lst.stream().filter(i -> i < 0).findAny();\n\
  \n        if (positive.isPresent() && negative.isPresent()) {\n            return\
  \ Pair.of(Optional.of(positive.orElse(Integer.MIN_VALUE)), Optional.of(negative.orElse(Integer.MAX_VALUE)));\n\
  \        } else if (positive.isPresent()) {\n            return Pair.of(Optional.of(positive.orElse(Integer.MIN_VALUE)),\
  \ Optional.empty());\n        } else if (negative.isPresent()) {\n            return\
  \ Pair.of(Optional.empty(), Optional.of(negative.orElse(Integer.MAX_VALUE)));\n\
  \        } else {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }"
- "        if (lst.isEmpty()) {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }\n\n        // sort descending first, then ascending\n        Collections.sort(lst,\
  \ Collections.reverseOrder());\n        Collections.sort(lst);\n\n        // loop\
  \ over list to find highest and lowest integers\n        int minInt = 0;\n     \
  \   int maxInt = Integer.MIN_VALUE;\n        for (int i : lst) {\n            if\
  \ (i < minInt) {\n                minInt = i;\n            } else if (i > maxInt)\
  \ {\n                maxInt = i;\n            }\n        }\n\n        // return\
  \ smallest and highest as pairs\n        return Pair.of(Optional.of(minInt), Optional.of(maxInt));"
- "        Optional<Integer> negativeInt = lst.stream().filter(x -> x < 0).findFirst();\n\
  \        Optional<Integer> positiveInt = lst.stream().filter(x -> x >= 0).findFirst();\n\
  \        if(negativeInt.isPresent() && positiveInt.isPresent()) {\n            return\
  \ Pair.of(Optional.of(negativeInt.get()), Optional.of(positiveInt.get()));\n   \
  \     } else if (negativeInt.isPresent()) {\n            return Pair.of(Optional.of(negativeInt.get()),\
  \ Optional.empty());\n        } else if (positiveInt.isPresent()) {\n          \
  \  return Pair.of(Optional.empty(), Optional.of(positiveInt.get()));\n        }\
  \ else {\n            return Pair.of(Optional.empty(), Optional.empty());\n    \
  \    }"
- "        if (lst.size() == 0) {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }\n        Optional<Integer> maxValue = null;\n        Optional<Integer>\
  \ minValue = null;\n        for (int val : lst) {\n            if (val < 0 && minValue\
  \ == null) {\n                minValue = Optional.of(val);\n            } else if\
  \ (val > 0 && maxValue == null) {\n                maxValue = Optional.of(val);\n\
  \            } else if (val > 0 && val < minValue.orElse(val)) {\n             \
  \   minValue = Optional.of(val);\n            } else if (val < 0 && val > maxValue.orElse(val))\
  \ {\n                maxValue = Optional.of(val);\n            }\n        }\n  \
  \      if (maxValue.isPresent() && minValue.isPresent()) {\n            return Pair.of(minValue,\
  \ maxValue);\n        } else if (maxValue.isPresent()) {\n            return Pair.of(maxValue,\
  \ maxValue);\n        } else if (minValue.isPresent()) {\n            return Pair.of(maxValue,\
  \ minValue);\n        }\n        return Pair.of(Optional.empty(), Optional.empty());"
- "        Optional<Integer> firstNumber = lst.stream().filter(i -> i < 0).findFirst();\n\
  \        Optional<Integer> secondNumber = lst.stream().filter(i -> i >= 0).findFirst();\n\
  \        return firstNumber.isEmpty() ? secondNumber : secondNumber.isEmpty() ?\
  \ firstNumber : Pair.of(firstNumber, secondNumber);"
- "        if (lst.size() == 0) return Pair.of(Optional.empty(), Optional.empty());\n\
  \        Comparator<Integer> c1 = Comparator.comparingInt(x -> x < 0);\n       \
  \ Comparator<Integer> c2 = Comparator.comparingInt(x -> x > 0);\n        Optional<Integer>\
  \ a = Optional.ofNullable(lst.stream().max(c1).orElse(Integer.MIN_VALUE));\n   \
  \     Optional<Integer> b = Optional.ofNullable(lst.stream().min(c2).orElse(Integer.MAX_VALUE));\n\
  \        return Pair.of(a, b);"
- "        if (lst.isEmpty())\n            return new Pair<>(Optional.empty(), Optional.empty());\n\
  \        \n        int largest_negative = Collections.max(lst.stream().filter(x\
  \ -> x < 0));\n        int smallest_positive = Collections.min(lst.stream().filter(x\
  \ -> x > 0));\n        \n        return new Pair<>(Optional.of(largest_negative),\
  \ Optional.of(smallest_positive));"
- "        int posSum = 0, negSum = 0;\n        for (Integer num : lst) {\n      \
  \      int pos = -num; // -num = num + pos\n            posSum += pos;\n       \
  \     int neg = -num; // -num = num + neg\n            negSum += neg;\n        }\n\
  \n        Optional<Integer> posInteger = Optional.ofNullable(posSum);\n        Optional<Integer>\
  \ negInteger = Optional.ofNullable(negSum);\n        if (posInteger.isPresent()\
  \ && negInteger.isPresent()) {\n            if (negInteger.isPresent() == posInteger.isPresent())\
  \ {\n                return Pair.of(posInteger, negInteger);\n            }\n  \
  \          if (posInteger.isPresent() == negInteger.isPresent()) {\n           \
  \     return Pair.of(negInteger, posInteger);\n            }\n        }\n      \
  \  return Pair.of(posInteger, negInteger);"
- "        // Create pairs to store max and min integers\n        Optional<Integer>\
  \ max = Optional.empty();\n        Optional<Integer> min = Optional.empty();\n\n\
  \        // Return pair\n        if (lst.size() > 1) {\n            // Find largest\
  \ of negative integers\n            max = Optional.ofNullable(lst.stream().filter(x\
  \ -> x <= 0).max().getAsInt());\n            // Find smallest of positive integers\n\
  \            min = Optional.ofNullable(lst.stream().filter(x -> x > 0).min().getAsInt());\n\
  \        } else if (lst.size() == 1) {\n            max = Optional.ofNullable((Integer)\
  \ lst.stream().filter(x -> x <= 0).max().getAsInt());\n            min = Optional.ofNullable((Integer)\
  \ lst.stream().filter(x -> x > 0).min().getAsInt());\n        } else {\n       \
  \     // If the list has only one element, then return it without an additional\
  \ tuple\n            max = Optional.ofNullable(0);\n            min = Optional.ofNullable(0);\n\
  \        }\n        return Pair.of(max, min);"
- "        Optional<Integer> negInt = lst.stream().filter(x -> x < 0).findFirst();\n\
  \        Optional<Integer> posInt = lst.stream().filter(x -> x > 0).findFirst();\n\
  \        if(negInt.isPresent() && posInt.isPresent()) {\n            return new\
  \ Pair<>(negInt, posInt);\n        }\n        if(negInt.isPresent()) {\n       \
  \     return new Pair<>(negInt, Optional.empty());\n        }\n        if(posInt.isPresent())\
  \ {\n            return new Pair<>(Optional.empty(), posInt);\n        }\n     \
  \   return new Pair<>(Optional.empty(), Optional.empty());"
- "        if(lst.isEmpty()) {\n            return Pair.of(null, null);\n        }\n\
  \        Optional<Integer> firstNegative = lst.stream().filter(i -> i < 0).findFirst();\n\
  \        Optional<Integer> firstPositive = lst.stream().filter(i -> i > 0).findFirst();\n\
  \        if(firstNegative.isPresent() && firstPositive.isPresent()) {\n        \
  \    return Pair.of(firstPositive, firstNegative);\n        }\n        if(firstNegative.isPresent())\
  \ {\n            return Pair.of(firstNegative, null);\n        }\n        if(firstPositive.isPresent())\
  \ {\n            return Pair.of(null, firstPositive);\n        }\n        return\
  \ Pair.of(null, null);"
- "        // Sort list from greatest to least and get the first and last elements.\n\
  \        Collections.sort(lst);\n        if (lst.size() <= 0) {\n            return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(), Optional.empty());\n\
  \        }\n\n        Optional<Integer> first = Optional.ofNullable(lst.get(0));\n\
  \        Optional<Integer> last = Optional.ofNullable(lst.get(lst.size() - 1));\n\
  \n        // If there is only one element, return it as is.\n        if (lst.size()\
  \ == 1) {\n            return new Pair<Optional<Integer>, Optional<Integer>>(first,\
  \ last);\n        }\n\n        // Otherwise, find the first and last negative and\
  \ positive elements.\n        Optional<Integer> first_neg = Optional.ofNullable(lst.get(0));\n\
  \        Optional<Integer> first_pos = Optional.ofNullable(lst.get(0));\n      \
  \  int first_neg_ind = lst.indexOf(first_neg.get());\n        int first_pos_ind\
  \ = lst.indexOf(first_pos.get());\n\n        // Iterate through the rest of the\
  \ list comparing each element\n        // with the current one.\n        for (int\
  \ i = 1; i < lst.size(); i++) {\n            Optional<Integer> curr = Optional.ofNullable(lst.get(i));\n\
  \            int curr_ind = lst.indexOf(curr.get());\n            if (curr_ind >\
  \ first_neg_ind) {\n                first_neg = Optional.ofNullable(lst.get(i));\n\
  \                first_neg_ind = curr_ind;\n            }\n            if (curr_ind\
  \ < first_pos_ind) {\n                first_pos = Optional.ofNullable(lst.get(i));\n\
  \                first_pos_ind = curr_ind;\n            }\n        }\n\n       \
  \ // Return the largest negative and smallest positive element.\n        return\
  \ new Pair<Optional<Integer>, Optional<Integer>>(first_neg, first);"
- "        Optional<Integer> min = null;\n        Optional<Integer> max = null;\n\
  \        Optional<Integer> first = null;\n        Optional<Integer> second = null;\n\
  \        int i;\n        for (i = 0; i < lst.size(); ++i) {\n            if (first\
  \ == null || min == null || lst.get(i) < first) {\n                first = Optional.of(lst.get(i));\n\
  \            }\n            if (second == null || max == null || lst.get(i) > second)\
  \ {\n                second = Optional.of(lst.get(i));\n            }\n        \
  \    if (lst.get(i) < min) {\n                min = Optional.of(lst.get(i));\n \
  \           }\n            if (lst.get(i) > max) {\n                max = Optional.of(lst.get(i));\n\
  \            }\n        }\n        if (first == null && second == null) {\n    \
  \        return Pair.of(min, max);\n        }\n        else if (first == null &&\
  \ max == null) {\n            return Pair.of(first, second);\n        }\n      \
  \  else if (first == null && min == null) {\n            return Pair.of(second,\
  \ max);\n        }\n        else if (max == null) {\n            return Pair.of(min,\
  \ first);\n        }\n        else if (min == null) {\n            return Pair.of(max,\
  \ first);\n        }\n        return new Pair<>(min, max);"
- "        return lst.stream().map(integer -> {\n            if (integer < 0)\n  \
  \              return Optional.ofNullable(integer);\n            else\n        \
  \        return Optional.of(integer);\n        }).reduce(Pair::of).orElse(Pair.of(Optional.ofNullable(Integer.MAX_VALUE),\
  \ Optional.ofNullable(Integer.MIN_VALUE)));"
- "        Optional<Integer> minValue = Optional.ofNullable(Collections.min(lst));\n\
  \        Optional<Integer> maxValue = Optional.ofNullable(Collections.max(lst));\n\
  \        return minValue.isPresent() ?\n                Pair.of(minValue, maxValue)\
  \ :\n                Pair.of(Optional.of(null), Optional.of(null));"
- "        Optional<Integer> first = lst.stream().filter(i -> i < 0).findFirst();\n\
  \        Optional<Integer> second = lst.stream().filter(i -> i >= 0).findFirst();\n\
  \n        return first.isPresent() ? Pair.of(first, second) : Pair.of(Optional.empty(),\
  \ Optional.empty());"
- "        List<Integer> positiveIntegersList = lst.stream().filter(i -> i >= 0).collect(Collectors.toList());\n\
  \        if (positiveIntegersList.size() > 0)\n            return new SimpleImmutablePair<>(Optional.of(Collections.max(positiveIntegersList)),\
  \ Optional.of(Collections.min(positiveIntegersList)));\n        else\n         \
  \   return new SimpleImmutablePair<>(Optional.of(null), Optional.of(null));"
- "        Optional<Integer> max = Optional.ofNullable(Collections.max(lst));\n  \
  \      Optional<Integer> min = Optional.ofNullable(Collections.min(lst));\n    \
  \    return Pair.of(max, min);"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n        for(Integer i : lst) {\n            if(i\
  \ < 0) {\n                largest = Optional.of(i);\n            } else {\n    \
  \            smallest = Optional.of(i);\n            }\n        }\n        Pair<Optional<Integer>,\
  \ Optional<Integer>> result = Pair.of(largest, smallest);\n        return result;"
- "        Optional<Integer> maxInt = lst.stream().max((a, b) -> Integer.compare(b,\
  \ a));\n        Optional<Integer> minInt = lst.stream().min((a, b) -> Integer.compare(b,\
  \ a));\n\n        return Pair.of(maxInt, minInt);"
- "        ArrayList<Integer> negativeIntegers = new ArrayList<>();\n        ArrayList<Integer>\
  \ positiveIntegers = new ArrayList<>();\n        for (Integer i : lst) {\n     \
  \       if (i < 0) {\n                negativeIntegers.add(i);\n            } else\
  \ {\n                positiveIntegers.add(i);\n            }\n        }\n      \
  \  if (negativeIntegers.isEmpty() && positiveIntegers.isEmpty()) {\n           \
  \ return Pair.of(Optional.empty(), Optional.empty());\n        }\n        int min\
  \ = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for (Integer\
  \ i : negativeIntegers) {\n            min = Math.min(i, min);\n        }\n    \
  \    for (Integer i : positiveIntegers) {\n            max = Math.max(i, max);\n\
  \        }\n        return Pair.of(Optional.of(max), Optional.of(min));"
- "        Integer min = Collections.min(lst);\n        Integer max = Collections.max(lst);\n\
  \        if (min < 0 && max > 0) {\n            return Pair.of(min,max);\n     \
  \   }\n        else if (min < 0) {\n            return Pair.of(Optional.empty(),\
  \ max);\n        }\n        else if (max > 0) {\n            return Pair.of(Optional.of(min),\
  \ Optional.empty());\n        }\n        else {\n            return Pair.of(Optional.empty(),\
  \ Optional.empty());\n        }"
- "        Optional<Integer> maxInt = Optional.empty();\n        Optional<Integer>\
  \ minInt = Optional.empty();\n        for (Integer num : lst) {\n            if\
  \ (num < 0) {\n                maxInt = Optional.of(num);\n            } else if\
  \ (num > 0) {\n                minInt = Optional.of(num);\n            }\n     \
  \   }\n        if (minInt.isPresent() && maxInt.isPresent()) {\n            return\
  \ Pair.of(maxInt, minInt);\n        }\n        return Pair.of(maxInt, minInt);"
- "        List<Integer> list = lst.stream().filter(i -> i < 0).collect(Collectors.toList());\n\
  \        List<Integer> list2 = lst.stream().filter(i -> i >= 0).collect(Collectors.toList());\n\
  \        Optional<Integer> max = list.stream().max(Comparator.naturalOrder()).orElse(null);\n\
  \        Optional<Integer> max2 = list2.stream().max(Comparator.naturalOrder()).orElse(null);\n\
  \        return new ImmutablePair<>(max, max2);"
- "        Optional<Integer> a = Optional.ofNullable(lst.get(0)).map(x -> x > 0 ?\
  \ x : null);\n        Optional<Integer> b = Optional.ofNullable(lst.get(0)).map(x\
  \ -> x < 0 ? x : null);\n\n        for (Integer i : lst.subList(1, lst.size()))\n\
  \        {\n            Optional<Integer> a = Optional.ofNullable(lst.get(i)).map(x\
  \ -> x > 0 ? x : null);\n            Optional<Integer> b = Optional.ofNullable(lst.get(i)).map(x\
  \ -> x < 0 ? x : null);\n            a = a.orElse(b);\n            b = a.orElse(b);\n\
  \        }\n\n        return Pair.of(a, b);"
- "        Optional<Integer> largest = Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.empty();\n\n        if (lst.isEmpty()) {\n            return\
  \ Pair.of(largest, smallest);\n        }\n\n        // If the first integer is negative\n\
  \        if (lst.stream().allMatch(i -> i < 0)) {\n            // find the smallest\
  \ and largest negative integer\n            Optional<Integer> lb = Optional.of(lst.stream().max(Comparator.naturalOrder()));\n\
  \            Optional<Integer> ls = Optional.of(lst.stream().min(Comparator.naturalOrder()));\n\
  \            return Pair.of(lb, ls);\n        }\n\n        // If the first integer\
  \ is positive\n        if (lst.stream().allMatch(i -> i > 0)) {\n            //\
  \ find the smallest and largest positive integer\n            Optional<Integer>\
  \ lb = Optional.of(lst.stream().min(Comparator.naturalOrder()));\n            Optional<Integer>\
  \ ls = Optional.of(lst.stream().max(Comparator.naturalOrder()));\n            return\
  \ Pair.of(lb, ls);\n        }\n\n        return Pair.of(largest, smallest);"
- "        if (lst.isEmpty()) return Pair.of(Optional.empty(), Optional.empty());\n\
  \        int largest = Collections.max(lst);\n        int smallest = Collections.min(lst);\n\
  \        return Pair.of(Optional.of(largest), Optional.of(smallest));"
- "        Optional<Integer> a = null;\n        Optional<Integer> b = null;\n    \
  \    if (lst.stream().anyMatch(i -> i < 0)) {\n            a = Optional.ofNullable(null);\n\
  \        }\n        if (lst.stream().allMatch(i -> i >= 0)) {\n            b = Optional.ofNullable(null);\n\
  \        }\n        return Pair.of(a, b);"
- "        // Your code goes here\n        Pair<Optional<Integer>, Optional<Integer>>\
  \ tuple = null;\n        int maxNegative = 0, maxPositive = 0;\n        for(Integer\
  \ i : lst) {\n            if (i < 0) {\n                if (maxNegative > i)\n \
  \                   maxNegative = i;\n            } else {\n                if (maxPositive\
  \ < i)\n                    maxPositive = i;\n            }\n        }\n       \
  \ if (maxNegative > maxPositive)\n            tuple = new Pair<>(Optional.of(maxNegative),\
  \ Optional.of(maxPositive));\n        else\n            tuple = null;\n        return\
  \ tuple;"
- "        if(lst.isEmpty()) return Pair.of(Optional.empty(), Optional.empty());\n\
  \        List<Integer> negative = lst.stream().filter(n -> n < 0).collect(Collectors.toList());\n\
  \        List<Integer> positive = lst.stream().filter(n -> n >= 0).collect(Collectors.toList());\n\
  \        int small = Collections.min(positive);\n        int large = Collections.max(negative);\n\
  \        return Pair.of(Optional.of(small), Optional.of(large));"
- "        if (lst.isEmpty()) {\n            return new Pair<>(Optional.empty(), Optional.empty());\n\
  \        }\n        int[] intArr = lst.stream()\n                .map(x -> Math.abs(x))\n\
  \                .toArray();\n        Arrays.sort(intArr);\n        int a = intArr[intArr.length\
  \ - 1];\n        int b = intArr[0];\n        return new Pair<>(Optional.ofNullable(a),\
  \ Optional.ofNullable(b));"
- "        if (lst.isEmpty()) {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }\n        Optional<Integer> maxVal = lst.stream().max((a, b) -> {\n  \
  \          if (a < 0 && b > 0) {\n                return a;\n            }\n   \
  \         if (a > 0 && b < 0) {\n                return b;\n            }\n    \
  \        return Integer.compare(a, b);\n        });\n        Optional<Integer> minVal\
  \ = lst.stream().min((a, b) -> {\n            if (a < 0 && b > 0) {\n          \
  \      return b;\n            }\n            if (a > 0 && b < 0) {\n           \
  \     return a;\n            }\n            return Integer.compare(a, b);\n    \
  \    });\n        return Pair.of(maxVal, minVal);"
- "        Set<Integer> negatives = new HashSet<>();\n        Set<Integer> positives\
  \ = new HashSet<>();\n        for (Integer i: lst) {\n            if (i < 0) {\n\
  \                negatives.add(i);\n            }\n            else if (i > 0) {\n\
  \                positives.add(i);\n            }\n        }\n        if (negatives.isEmpty()\
  \ && positives.isEmpty()) {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }\n        if (negatives.isEmpty()) {\n            return Pair.of(Optional.of(Collections.min(positives)),\
  \ Optional.empty());\n        }\n        if (positives.isEmpty()) {\n          \
  \  return Pair.of(Optional.empty(), Optional.of(Collections.max(negatives)));\n\
  \        }\n        int min = Collections.min(positives);\n        int max = Collections.max(negatives);\n\
  \        return Pair.of(Optional.of(min), Optional.of(max));"
- "        if (lst.isEmpty()) return (Optional.empty(), Optional.empty());\n     \
  \   ArrayList<Integer> negative = new ArrayList<Integer>();\n        ArrayList<Integer>\
  \ positive = new ArrayList<Integer>();\n        for (int i = 0; i < lst.size();\
  \ i++) {\n            if (lst.get(i) < 0) negative.add(lst.get(i));\n          \
  \  else positive.add(lst.get(i));\n        }\n        if (negative.isEmpty()) return\
  \ (Optional.empty(), Optional.empty());\n        if (positive.isEmpty()) return\
  \ (Optional.empty(), Optional.empty());\n        Collections.sort(negative);\n \
  \       Collections.sort(positive);\n        if (negative.get(0) <= positive.get(0))\
  \ return (Optional.of(negative.get(0)), Optional.of(positive.get(0)));\n       \
  \ else if (negative.get(0) < positive.get(0)) return (Optional.of(negative.get(0)),\
  \ Optional.empty());\n        else return (Optional.of(positive.get(0)), Optional.of(negative.get(0)));"
- "        Optional<Integer> max_num = Optional.empty();\n        Optional<Integer>\
  \ min_num = Optional.empty();\n        if(lst == null || lst.isEmpty()) {\n    \
  \        return new Pair<>(Optional.empty(), Optional.empty());\n        }\n   \
  \     Optional<Integer> first_num = Optional.empty();\n        Optional<Integer>\
  \ second_num = Optional.empty();\n        for(int i = 0; i <lst.size(); i++) {\n\
  \            if(lst.get(i) < 0) {\n                if(max_num.isEmpty())\n     \
  \               first_num = Optional.of(lst.get(i));\n                else\n   \
  \                 first_num = max_num;\n            }\n            else if(lst.get(i)\
  \ > 0) {\n                if(min_num.isEmpty())\n                    second_num\
  \ = Optional.of(lst.get(i));\n                else\n                    second_num\
  \ = min_num;\n            }\n            else\n                break;\n        \
  \    if(lst.get(i) > max_num)\n                max_num = Optional.of(lst.get(i));\n\
  \            else if(lst.get(i) < min_num)\n                min_num = Optional.of(lst.get(i));\n\
  \        }\n        if(max_num.isEmpty()) {\n            return new Pair<>(Optional.empty(),\
  \ Optional.empty());\n        }\n        if(min_num.isEmpty()) {\n            return\
  \ new Pair<>(Optional.of(max_num), Optional.empty());\n        }\n        if(first_num.isEmpty())\
  \ {\n            return new Pair<>(Optional.empty(), Optional.of(min_num));\n  \
  \      }\n        if(second_num.isEmpty()) {\n            return new Pair<>(Optional.of(max_num),\
  \ Optional.of(min_num));\n        }\n        return new Pair<>(Optional.of(max_num),\
  \ Optional.of(min_num));"
- "        Optional<Integer> firstOpt = lst.stream().filter( i -> i < 0 ).max( Comparator.naturalOrder()\
  \ );\n        Optional<Integer> secondOpt = lst.stream().filter( i -> i > 0 ).min(\
  \ Comparator.naturalOrder());\n        return firstOpt.map( i -> new Pair<>( Optional.ofNullable(i),\
  \ Optional.ofNullable(secondOpt) ) ).orElse( secondOpt.map( i -> new Pair<>( Optional.ofNullable(i),\
  \ Optional.ofNullable(firstOpt) ) ).orElse( new Pair<>( Optional.empty(), Optional.empty()\
  \ ) ) );"
- "        if (lst.isEmpty()) {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }\n        List<Integer> filteredList = lst.stream().filter(x -> x > 0).toList();\n\
  \        if (filteredList.size() <= 1) {\n            return Pair.of(Optional.empty(),\
  \ Optional.empty());\n        }\n        Optional<Integer> maxNegativeInteger =\
  \ filteredList.stream().max(Comparator.naturalOrder()).map(x -> -x);\n        Optional<Integer>\
  \ minPositiveInteger = filteredList.stream().min(Comparator.naturalOrder());\n \
  \       if (maxNegativeInteger.isPresent()) {\n            return Pair.of(maxNegativeInteger,\
  \ minPositiveInteger);\n        } else {\n            return Pair.of(Optional.empty(),\
  \ minPositiveInteger);\n        }"
- "        int largestInt = -1;\n        int smallestInt = Integer.MAX_VALUE;\n  \
  \      for (int i = 0; i < lst.size(); i++) {\n            int element = lst.get(i);\n\
  \            if (element < 0) {\n                largestInt = Math.max(largestInt,\
  \ element);\n            } else if (element > smallestInt) {\n                smallestInt\
  \ = element;\n            }\n        }\n        return new Pair<>(Optional.ofNullable(largestInt),\
  \ Optional.ofNullable(smallestInt));"
- "        Optional<Integer> a = Optional.empty();\n        Optional<Integer> b =\
  \ Optional.empty();\n        for(int i = 0; i< lst.size(); i++)\n        {\n   \
  \         if (lst.get(i) < 0){\n                a = Optional.of(lst.get(i));\n \
  \           }\n            else if (lst.get(i) > 0){\n                b = Optional.of(lst.get(i));\n\
  \            }\n            else{\n                a = Optional.empty();\n     \
  \           b = Optional.empty();\n            }\n        }\n        return new\
  \ Pair<Optional<Integer>, Optional<Integer>>(a, Optional.of(b));"
- "        if (lst.isEmpty()) return Optional.empty();\n        Optional<Integer>\
  \ smallest = Optional.of(lst.get(0));\n        Optional<Integer> largest = Optional.of(lst.get(0));\n\
  \        for (int i = 1; i < lst.size(); i++) {\n            Optional<Integer> current\
  \ = Optional.of(lst.get(i));\n            if (smallest.isPresent() && largest.isPresent()\
  \ && current.isPresent() && smallest.get() < current.get()) {\n                largest\
  \ = Optional.of(current.orElse(smallest.get()));\n            } else if (smallest.isPresent()\
  \ && current.isPresent() && smallest.get() < current.get()) {\n                smallest\
  \ = Optional.of(current.orElse(smallest.get()));\n            } else if (current.isPresent()\
  \ && largest.isPresent() && current.get() < largest.get()) {\n                largest\
  \ = Optional.of(current.orElse(largest.get()));\n            }\n        }\n    \
  \    return largest.map(v -> new Pair<>(v,smallest.get()));"
- "        Optional<Integer> a = Optional.empty();\n        Optional<Integer> b =\
  \ Optional.empty();\n        if (lst.isEmpty())\n            return Pair.of(a, b);\n\
  \        Collections.sort(lst);\n        a = Optional.of(lst.get(lst.size() - 1));\n\
  \        b = Optional.of(lst.get(0)).filter((t) -> {\n            boolean flag =\
  \ false;\n            for (int i = 0; i <= lst.get(0).intValue(); i++) {\n     \
  \           if (lst.get(0).intValue() <= i && i > 0) {\n                    flag\
  \ = true;\n                    break;\n                }\n            }\n      \
  \      return flag;\n        });\n        return Pair.of(a, b);"
- "        if(lst.size() == 0) {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }\n        Optional<Integer> largest = lst.stream().max(Comparator.naturalOrder());\n\
  \        Optional<Integer> smallest = lst.stream().min(Comparator.naturalOrder());\n\
  \        return Pair.of(largest, smallest);"
- "        if(lst.size() == 0) {\n            return new Pair<Optional<Integer>, Optional<Integer>>(Optional.empty(),\
  \ Optional.empty());\n        }\n        Set<Integer> set = new HashSet<>();\n \
  \       for(Integer i: lst) {\n            if(i.signum() < 0) {\n              \
  \  set.add(i);\n            }\n        }\n        ArrayList<Integer> sorted = new\
  \ ArrayList<>(set);\n        Collections.sort(sorted);\n        Optional<Integer>\
  \ firstNegativeInt = Optional.empty();\n        Optional<Integer> firstPositiveInt\
  \ = Optional.empty();\n        for(Integer i: sorted) {\n            if(i.signum()\
  \ < 0) {\n                firstNegativeInt = Optional.of(i);\n                break;\n\
  \            }\n        }\n        for(Integer i: sorted) {\n            if(i.signum()\
  \ > 0) {\n                firstPositiveInt = Optional.of(i);\n                break;\n\
  \            }\n        }\n        if(firstNegativeInt.isPresent()) {\n        \
  \    firstNegativeInt = firstNegativeInt.get();\n            sorted = sorted.subList(0,\
  \ sorted.indexOf(firstNegativeInt));\n        }\n        if(firstPositiveInt.isPresent())\
  \ {\n            firstPositiveInt = firstPositiveInt.get();\n            sorted\
  \ = sorted.subList(sorted.indexOf(firstPositiveInt) + 1, sorted.size());\n     \
  \   }\n        return new Pair<Optional<Integer>, Optional<Integer>>(firstNegativeInt,\
  \ firstPositiveInt);"
- "        // Declare variables to store largest and smallest integers\n        Optional<Integer>\
  \ largest = Optional.empty();\n        Optional<Integer> smallest = Optional.empty();\n\
  \n        // Loop through each integer\n        for (Integer integer : lst) {\n\
  \            // If integer is negative, set largest to be the new largest integer\n\
  \            if (integer < 0) {\n                largest = Optional.of(integer);\n\
  \                // If smallest integer is not currently empty\n               \
  \ // and new integer is smaller than existing integer\n                if (smallest\
  \ == Optional.empty() || integer < smallest.get()) {\n                    smallest\
  \ = Optional.of(integer);\n                }\n            }\n        }\n\n     \
  \   // If both largest and smallest integers are empty\n        // return None as\
  \ a tuple\n        if (largest.isEmpty() && smallest.isEmpty()) {\n            return\
  \ Optional.empty();\n        }\n\n        // Return Pair of largest and smallest\
  \ integers\n        return Pair.of(largest, smallest);"
- "        Optional<Integer> maxInt = null;\n        Optional<Integer> minInt = null;\n\
  \        for (int i : lst) {\n            Optional<Integer> intOptional = Optional.of(i);\n\
  \            if (minInt == null || intOptional.isLess(minInt)) {\n             \
  \   minInt = intOptional;\n            }\n            if (maxInt == null || intOptional.isGreater(maxInt))\
  \ {\n                maxInt = intOptional;\n            }\n        }\n        if\
  \ (minInt.isPresent()) {\n            return Pair.of(Optional.of(minInt), maxInt);\n\
  \        } else {\n            return Pair.of(Optional.of(maxInt), Optional.of(Integer.MIN_VALUE));\n\
  \        }"
- "        Optional<Integer> positiveIntegersOpt = lst.stream()\n            .filter(x\
  \ -> x > 0)\n            .findFirst();\n        Optional<Integer> negativeIntegersOpt\
  \ = lst.stream()\n            .filter(x -> x < 0)\n            .findFirst();\n \
  \       return Optional.of(Pair.of(positiveIntegersOpt, negativeIntegersOpt));"
- "        Optional<Integer> big = null;\n        Optional<Integer> small = null;\n\
  \        for (int n : lst) {\n            if (n < 0)\n                big = Optional.of(n);\n\
  \            else if (n > 0)\n                small = Optional.of(n);\n        }\n\
  \        return new Pair<>(big, small);"
- "        if (lst.isEmpty()) return Pair.of(Optional.empty(), Optional.empty());\n\
  \        List<Integer> negative = new ArrayList<>();\n        List<Integer> positive\
  \ = new ArrayList<>();\n        for(int i : lst) {\n            if (i < 0) negative.add(i);\n\
  \            else positive.add(i);\n        }\n        if (negative.isEmpty() &&\
  \ positive.isEmpty()) return Pair.of(Optional.empty(), Optional.empty());\n    \
  \    if (negative.isEmpty()) return Pair.of(Optional.of(negative.get(0)), Optional.empty());\n\
  \        if (positive.isEmpty()) return Pair.of(Optional.empty(), Optional.of(positive.get(0)));\n\
  \        Collections.sort(negative);\n        Collections.sort(positive);\n    \
  \    return Pair.of(Optional.of(negative.get(0)), Optional.of(positive.get(0)));"
- "        if (lst.size() > 0) {\n            if (lst.contains(Integer.MIN_VALUE))\
  \ {\n                return Pair.of(Optional.of(Integer.MIN_VALUE), Optional.empty());\n\
  \            }\n            if (lst.contains(Integer.MAX_VALUE)) {\n           \
  \     return Pair.of(Optional.empty(), Optional.of(Integer.MAX_VALUE));\n      \
  \      }\n            return Pair.of(\n                    Optional.of(lst.stream()\n\
  \                            .sorted(Comparator.naturalOrder())\n              \
  \              .max((a, b) -> {\n                                if (a < b) return\
  \ -1;\n                                if (a > b) return 1;\n                  \
  \              return 0;\n                            })\n                     \
  \       .orElse(Integer.MIN_VALUE)),\n                    Optional.of(lst.stream()\n\
  \                            .sorted(Comparator.naturalOrder())\n              \
  \              .min((a, b) -> {\n                                if (a < b) return\
  \ -1;\n                                if (a > b) return 1;\n                  \
  \              return 0;\n                            })\n                     \
  \       .orElse(Integer.MAX_VALUE)));\n        }\n        return Pair.of(Optional.empty(),\
  \ Optional.empty());"
- "        Optional<Integer> maxNegative = Optional.empty();\n        Optional<Integer>\
  \ minPositive = Optional.empty();\n\n        boolean negFound = false;\n       \
  \ boolean posFound = false;\n        for (int i = 0; i < lst.size(); i++) {\n  \
  \          int curr = lst.get(i);\n            if (curr < 0 && !negFound) {\n  \
  \              maxNegative = Optional.of(curr);\n                negFound = true;\n\
  \            } else if (curr > 0 && !posFound) {\n                minPositive =\
  \ Optional.of(curr);\n                posFound = true;\n            }\n        }\n\
  \        if (negFound) {\n            negFound = false;\n        }\n        if (posFound)\
  \ {\n            posFound = false;\n        }\n        return Pair.of(maxNegative,\
  \ minPositive);"
- "        if (lst.isEmpty()) return (null, null);\n        \n        Optional<Integer>\
  \ min = Optional.empty();\n        Optional<Integer> max = Optional.empty();\n \
  \       \n        list.sort(lst);\n        \n        Integer minInList = lst.get(0);\n\
  \        Integer maxInList = lst.get(0);\n        \n        for (int i = 1; i <\
  \ lst.size(); i++) {\n            Integer current = lst.get(i);\n            \n\
  \            if (current > maxInList) {\n                maxInList = current;\n\
  \            } else if (current < minInList) {\n                minInList = current;\n\
  \            }\n        }\n        \n        if (minInList.isPresent() && maxInList.isPresent())\
  \ {\n            return (Optional.of(minInList), Optional.of(maxInList));\n    \
  \    }\n        \n        return null;"
- "        // Write your code\n        if (lst.stream().noneMatch( i -> i < 0)){\n\
  \            return Pair.of(Optional.ofNullable(Integer.MAX_VALUE), Optional.ofNullable(Integer.MIN_VALUE));\n\
  \        }\n        if (lst.stream().noneMatch( i -> i > 0)){\n            return\
  \ Pair.of(Optional.ofNullable(Integer.MIN_VALUE), Optional.ofNullable(Integer.MAX_VALUE));\n\
  \        }\n        return Pair.of(Optional.ofNullable(Integer.MAX_VALUE), Optional.ofNullable(Integer.MIN_VALUE));"
- "        if (lst.isEmpty()) return Optional.empty();\n        int min = Collections.min(lst);\n\
  \        int max = Collections.max(lst);\n        int small = Collections.min(lst.stream().filter(i\
  \ -> i < min).boxed().collect(Collectors.toList()));\n        int large = Collections.max(lst.stream().filter(i\
  \ -> i > max).boxed().collect(Collectors.toList()));\n        return Optional.of(large).isPresent()\
  \ ? Optional.of(new Pair(Optional.of(large), Optional.of(small))) : Optional.of(new\
  \ Pair(Optional.empty(), Optional.of(small)));"
- "        Optional<Integer> maxValue = null;\n        Optional<Integer> minValue\
  \ = null;\n\n        for (int element : lst) {\n            if (element < 0) {\n\
  \                if (maxValue.isPresent()) {\n                    return Pair.of(Optional.of(maxValue.orElse(0)),\
  \ Optional.of(Integer.MAX_VALUE));\n                } else {\n                 \
  \   maxValue = Optional.of(element);\n                }\n            } else if (element\
  \ > 0) {\n                if (minValue.isPresent()) {\n                    return\
  \ Pair.of(Optional.of(minValue.orElse(0)), Optional.of(Integer.MIN_VALUE));\n  \
  \              } else {\n                    minValue = Optional.of(element);\n\
  \                }\n            }\n        }\n        if (maxValue.isPresent() &&\
  \ minValue.isPresent()) {\n            return Pair.of(Optional.of(maxValue.orElse(0)),\
  \ Optional.of(Integer.MIN_VALUE));\n        } else if (maxValue.isPresent()) {\n\
  \            return Pair.of(Optional.of(maxValue.orElse(0)), Optional.of(Integer.MAX_VALUE));\n\
  \        } else if (minValue.isPresent()) {\n            return Pair.of(Optional.of(Integer.MIN_VALUE),\
  \ Optional.of(minValue.orElse(0)));\n        } else {\n            return Pair.of(Optional.empty(),\
  \ Optional.empty());\n        }"
- "        int largest = Collections.max(lst);\n        int smallest = Collections.min(lst);\n\
  \        if (largest == smallest) {\n            return (Optional.of(largest), Optional.of(largest));\n\
  \        }\n        return Pair.of(Optional.of(largest), Optional.of(smallest));"
- "        if (lst == null || lst.isEmpty()) {\n            return null;\n       \
  \ }\n\n        int large = lst.get(0);\n        int small = lst.get(0);\n\n    \
  \    for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i) < 0) {\n\
  \                if (small > 0 && lst.get(i) > small) {\n                    small\
  \ = lst.get(i);\n                }\n            } else {\n                if (large\
  \ < 0 && lst.get(i) > large) {\n                    large = lst.get(i);\n      \
  \          }\n            }\n        }\n\n        return new ImmutablePair<>(Optional.of(large),\
  \ Optional.of(small));"
- "        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n        for (Integer\
  \ i : lst) {\n            int temp = i;\n            if (temp < min) {\n       \
  \         min = temp;\n            }\n            if (temp > max) {\n          \
  \      max = temp;\n            }\n        }\n        if (min <= 0) {\n        \
  \    return null;\n        }\n        if (max <= 0) {\n            return Pair.of(Optional.of(min),\
  \ Optional.of(max));\n        }\n        return Pair.of(Optional.of(min), Optional.of(max));"
- "    Optional<Integer> minInt = Optional.empty();\n    Optional<Integer> maxInt\
  \ = Optional.empty();\n    Optional<Integer> bothInt = Optional.empty();\n\n   \
  \ for (Integer i : lst) {\n        if (minInt.isPresent() && i.compareTo(minInt)\
  \ > 0) {\n            maxInt = Optional.of(i);\n        } else if (maxInt.isPresent()\
  \ && i.compareTo(maxInt) < 0) {\n            minInt = Optional.of(i);\n        }\
  \ else if (maxInt.isPresent() && i.compareTo(maxInt) == 0) {\n            bothInt\
  \ = Optional.of(i);\n        }"
- "        Integer largest = null;\n        Integer smallest = null;\n        if (lst.stream().allMatch(x\
  \ -> x < 0))\n            largest = Optional.of(0);\n        else\n            largest\
  \ = Optional.of(lst.stream().max(Integer::compareTo).orElse(-1));\n        if (lst.stream().allMatch(x\
  \ -> x > 0))\n            smallest = Optional.of(0);\n        else\n           \
  \ smallest = Optional.of(lst.stream().min(Integer::compareTo).orElse(-1));\n   \
  \     return Pair.of(largest, smallest);"
- "        int largest = 0;\n        int smallest = 0;\n        for (int i = 0; i\
  \ < lst.size(); i++) {\n            if (lst.get(i) >= 0) {\n                largest\
  \ = lst.get(i);\n            } else if (largest != 0) {\n                smallest\
  \ = lst.get(i);\n            }\n        }\n        if (smallest == 0) {\n      \
  \      return Optional.empty();\n        } else if (largest == 0) {\n          \
  \  return Optional.of(Optional.of(smallest));\n        } else {\n            return\
  \ Optional.of(Optional.of(smallest), Optional.of(largest));\n        }"
- "        Optional<Integer> max1 = Optional.empty();\n        Optional<Integer> min1\
  \ = Optional.empty();\n        if (lst.size() > 0) {\n            List<Integer>\
  \ positive = new ArrayList<>();\n            List<Integer> negative = new ArrayList<>();\n\
  \n            for(Integer i : lst) {\n                if(i<0) {\n              \
  \      negative.add(i);\n                }\n                else if(i>0) {\n   \
  \                 positive.add(i);\n                }\n            }\n\n       \
  \     // Get max from negative\n            Optional<Integer> max2 = Optional.empty();\n\
  \            Optional<Integer> maxDiff = Optional.empty();\n            for (Integer\
  \ i : negative) {\n                if (max2.isPresent() && max2.get().intValue()\
  \ < i) {\n                    maxDiff = Optional.of(Integer.valueOf(max2.get().intValue()\
  \ - i));\n                }\n                if (max2.isPresent() && max2.get().intValue()\
  \ == i) {\n                    maxDiff = Optional.of(Integer.valueOf(max2.get().intValue()\
  \ - i));\n                }\n                if (maxDiff.isPresent()) {\n      \
  \              max2 = Optional.of(Integer.valueOf(maxDiff.get()));\n           \
  \         maxDiff = Optional.empty();\n                }\n                max2 =\
  \ Optional.of(i);\n            }\n\n            // Get min from positive\n     \
  \       Optional<Integer> min2 = Optional.empty();\n            Optional<Integer>\
  \ minDiff = Optional.empty();\n            for (Integer i : positive) {\n      \
  \          if (min2.isPresent() && min2.get().intValue() > i) {\n              \
  \      minDiff = Optional.of(Integer.valueOf(i - min2.get().intValue()));\n    \
  \            }\n                if (min2.isPresent() && min2.get().intValue() ==\
  \ i) {\n                    minDiff = Optional.of(Integer.valueOf(i - min2.get().intValue()));\n\
  \                }\n                if (minDiff.isPresent()) {\n               \
  \     min2 = Optional.of(Integer.valueOf(i - minDiff.get()));\n                \
  \    minDiff = Optional.empty();\n                }\n                min2 = Optional.of(i);\n\
  \            }\n\n            Pair<Optional<Integer>, Optional<Integer>> result\
  \ = new Pair<>(max2, min2);\n            return result;\n        }\n        else\
  \ {\n            return new Pair<>(max1, min1);\n        }"
- "        Optional<Integer> negative = Optional.empty();\n        Optional<Integer>\
  \ positive = Optional.empty();\n        Optional<Integer> maxNegative = Optional.empty();\n\
  \        Optional<Integer> maxPositive = Optional.empty();\n        for (int num\
  \ : lst) {\n            if (num < 0 || num > 0) {\n                negative = Optional.of(num);\n\
  \            } else {\n                positive = Optional.of(num);\n          \
  \  }\n            if (negative.compareTo(maxNegative) < 0) {\n                maxNegative\
  \ = negative;\n            }\n            if (positive.compareTo(maxPositive) <\
  \ 0) {\n                maxPositive = positive;\n            }\n        }\n    \
  \    if (negative.isPresent()) {\n            return Pair.of(maxNegative, negative);\n\
  \        } else {\n            return Pair.of(maxPositive, positive);\n        }"
- "        Optional<Integer> negative = null;\n        Optional<Integer> positive\
  \ = null;\n        for(int i = 0; i < lst.size(); i++) {\n            int val =\
  \ lst.get(i);\n            if(-val > 0) {\n                negative = Optional.of(val);\n\
  \            } else if(val < 0) {\n                positive = Optional.of(val);\n\
  \            }\n        }\n        if(negative != null && positive != null) {\n\
  \            return Pair.of(negative, positive);\n        } else if(negative !=\
  \ null) {\n            return Pair.of(Optional.of(negative), Optional.empty());\n\
  \        } else if(positive != null) {\n            return Pair.of(Optional.empty(),\
  \ positive);\n        } else {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \        }"
- "        List<Pair<Integer, Integer>> lsts = new ArrayList<>(lst.size());\n    \
  \    for(Integer x: lst){\n            if(x < 0){\n                lsts.add(new\
  \ Pair<>(x, 0));\n            }else if(x > 0){\n                lsts.add(new Pair<>(x,\
  \ x));\n            }\n        }\n        Optional<Integer> max = Optional.empty();\n\
  \        Optional<Integer> min = Optional.empty();\n        for(Pair<Integer, Integer>\
  \ p : lsts){\n            if(!max.isPresent()){\n                max = p;\n    \
  \        }else if(p.getFirst() > max.get()){\n                max = p;\n       \
  \     }\n            if(!min.isPresent()){\n                min = p;\n         \
  \   }else if(p.getSecond() < min.get()){\n                min = p;\n           \
  \ }\n        }\n        return max.isPresent() ? Pair.of(max, min) : Pair.of(Optional.empty(),\
  \ Optional.empty());"
- "        Optional<Integer> min;\n        Optional<Integer> max;\n        int n =\
  \ lst.size();\n        if (n < 2) {\n            return Pair.of(Optional.of(null),\
  \ Optional.of(null));\n        }\n        min = max = Optional.of(lst.get(0));\n\
  \        for (int i = 1; i < n; i++) {\n            if (lst.stream().allMatch(x\
  \ -> x < min.orElse(null))) {\n                min = Optional.of(lst.get(i));\n\
  \            } else if (lst.stream().allMatch(x -> x > max.orElse(null))) {\n  \
  \              max = Optional.of(lst.get(i));\n            }\n        }\n      \
  \  return Pair.of(min.orElse(null), max.orElse(null));"
- "        Optional<Integer> smallest = Optional.empty();\n        Optional<Integer>\
  \ largest = Optional.empty();\n        Optional<Integer> minNegative = Optional.empty();\n\
  \        Optional<Integer> maxPositive = Optional.empty();\n\n        // First we\
  \ find the max negative, min positive\n        for (int num : lst) {\n         \
  \   if (num < 0) {\n                if (minNegative.isEmpty()) {\n             \
  \       minNegative = Optional.of(num);\n                } else {\n            \
  \        minNegative = Optional.min(minNegative, Optional.of(num));\n          \
  \      }\n            } else if (num > 0) {\n                if (maxPositive.isEmpty())\
  \ {\n                    maxPositive = Optional.of(num);\n                } else\
  \ {\n                    maxPositive = Optional.max(maxPositive, Optional.of(num));\n\
  \                }\n            }\n        }\n\n        // Then we check which one\
  \ is the largest\n        if (minNegative.isPresent() && maxPositive.isPresent())\
  \ {\n            Optional<Integer> largestSmallest = Optional.of(\n            \
  \        minNegative.orElse(maxPositive).max(maxPositive.orElse(minNegative))\n\
  \            );\n            return largestSmallest;\n        } else if (minNegative.isPresent())\
  \ {\n            return largest(Optional.of(lst.get(0)), largest);\n        } else\
  \ if (maxPositive.isPresent()) {\n            return largest(largest, Optional.of(lst.get(0)));\n\
  \        } else {\n            return largest(largest, Optional.empty());\n    \
  \    }"
- "        Optional<Integer> maxPositiveInt = Optional.ofNullable(lst.get(0));\n \
  \       Optional<Integer> maxNegativeInt = Optional.ofNullable(lst.get(0));\n  \
  \      for(int i = 1; i < lst.size(); i++) {\n            Integer nextInt = lst.get(i);\n\
  \            Optional<Integer> nextPositiveInt = Optional.ofNullable(nextInt);\n\
  \            Optional<Integer> nextNegativeInt = Optional.ofNullable(nextInt);\n\
  \n            boolean isNextPositive = nextPositiveInt.isPresent();\n          \
  \  boolean isNextNegative = nextNegativeInt.isPresent();\n            boolean isNextMax\
  \ = isNextPositive && !isNextNegative;\n            boolean isNextMin = isNextNegative\
  \ && !isNextPositive;\n            \n            if (isNextMax) {\n            \
  \    maxPositiveInt = nextPositiveInt.orElse(maxPositiveInt);\n            } else\
  \ if (isNextMin) {\n                maxNegativeInt = nextNegativeInt.orElse(maxNegativeInt);\n\
  \            } else {\n                Optional<Integer> first = maxPositiveInt.orElse(maxNegativeInt);\n\
  \                Optional<Integer> second = nextPositiveInt.orElse(nextNegativeInt);\n\
  \                Pair<Optional<Integer>, Optional<Integer>> result = new Pair<>(first,\
  \ second);\n                maxPositiveInt = result.f1;\n                maxNegativeInt\
  \ = result.f2;\n            }\n        }\n        return Pair.create(maxPositiveInt,\
  \ maxNegativeInt);"
- "        ArrayList<Integer> negative = new ArrayList<>();\n        ArrayList<Integer>\
  \ positive = new ArrayList<>();\n        for(Integer i : lst){\n            if (i\
  \ < 0) negative.add(i);\n            else if (i > 0) positive.add(i);\n        }\n\
  \        if (negative.size() == 0) return new Pair<>(null,null);\n        if (positive.size()\
  \ == 0) return new Pair<>(null,null);\n        Collections.sort(negative);\n   \
  \     Collections.sort(positive);\n        int a = negative.get(0);\n        int\
  \ b = positive.get(0);\n        int c = positive.get(1);\n        int d = negative.get(1);\n\
  \        if (a > b) a = b;\n        if (c < d) c = d;\n        return new Pair<>(Optional.of(a),\
  \ Optional.of(c));"
- "        if (lst == null || lst.size() == 0) {\n            return null;\n     \
  \   }\n        Optional<Integer> largest_integer = lst.stream().max();\n       \
  \ Optional<Integer> smallest_integer = lst.stream().min();\n        return Pair.of(largest_integer,\
  \ smallest_integer);"
- "        if (lst.stream().allMatch(x -> x % 2 == 0)) {\n            // odd\n   \
  \         if (lst.stream().allMatch(x -> x < 0)) {\n                return Pair.of(Optional.of(-lst.stream().max().get()),\
  \ Optional.of(lst.stream().min().get()));\n            } else {\n              \
  \  return Pair.of(Optional.of(-lst.stream().min().get()), Optional.of(lst.stream().max().get()));\n\
  \            }\n        } else {\n            // even\n            if (lst.stream().allMatch(x\
  \ -> x > 0)) {\n                return Pair.of(Optional.of(-lst.stream().min().get()),\
  \ Optional.of(lst.stream().max().get()));\n            } else {\n              \
  \  return Pair.of(Optional.of(Integer.MIN_VALUE), Optional.of(Integer.MAX_VALUE));\n\
  \            }\n        }"
- "        if (lst.isEmpty()) {\n            return new Pair<Optional<Integer>, Optional<Integer>>(null,\
  \ null);\n        }\n\n        // Add each element to the accumulator\n        int\
  \ largestPositive = Integer.MIN_VALUE;\n        int largestNegative = Integer.MAX_VALUE;\n\
  \        for (Integer integer : lst) {\n            if (integer > largestNegative)\
  \ {\n                largestNegative = integer;\n            }\n            if (integer\
  \ < largestPositive) {\n                largestPositive = integer;\n           \
  \ }\n        }\n\n        // Return the tuple with the largest of the two\n    \
  \    return new Pair<Optional<Integer>, Optional<Integer>>(Optional.of(largestNegative),\
  \ Optional.of(largestPositive));"
- "        Optional<Integer> a = Optional.of(-1);\n        Optional<Integer> b = Optional.of(1);\n\
  \        for (Integer i : lst) {\n            if (i.signum() == 0) {\n         \
  \       a = Optional.of(i);\n            } else if (i.signum() == 1) {\n       \
  \         b = Optional.of(i);\n            } else {\n                break;\n  \
  \          }\n        }\n        return Pair.of(a, b);"
- "        Optional<Integer> max = lst.stream()\n            .max(Integer::compareTo)\n\
  \            .map(Integer::intValue)\n            .orElse(Optional.empty());\n \
  \       Optional<Integer> min = lst.stream()\n            .min(Integer::compareTo)\n\
  \            .map(Integer::intValue)\n            .orElse(Optional.empty());\n \
  \       return max.isPresent() ? Pair.of(max, min) : Pair.of(Optional.empty(), Optional.empty());"
- "        Optional<Integer> posMin = Optional.empty();\n        Optional<Integer>\
  \ negMin = Optional.empty();\n        Optional<Integer> posMax = Optional.empty();\n\
  \        Optional<Integer> negMax = Optional.empty();\n\n        // Check if there\
  \ are any negative integers in the list.\n        if (lst.stream().filter(x -> x\
  \ < 0).count() > 0) {\n            negMin = Optional.of(Math.min.apply(lst));\n\
  \        }\n        // Check if there are any positive integers in the list.\n \
  \       if (lst.stream().filter(x -> x >= 0).count() > 0) {\n            posMax\
  \ = Optional.of(Math.max.apply(lst));\n        }\n        // Check if there are\
  \ any integers in the list.\n        if (lst.size() > 0) {\n            posMin =\
  \ Optional.of(Math.min(lst));\n        }\n        // Check if there are no positive\
  \ and negative integers.\n        if (posMin.isPresent() && negMin.isPresent() &&\
  \ posMax.isPresent() && negMax.isPresent()) {\n            return new Pair<>(posMin,\
  \ negMin);\n        }\n        return Optional.of(Pair.of(Optional.empty(), Optional.empty()));"
- "        if (lst.isEmpty())\n            return Pair.of(Optional.empty(), Optional.empty());\n\
  \n        Optional<Integer> negMin = lst.stream().filter(x -> x < 0).min();\n  \
  \      Optional<Integer> posMax = lst.stream().filter(x -> x > 0).max();\n     \
  \   return Pair.of(negMin, posMax);"
language: java
name: HumanEval_136_largest_smallest_integers
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Create a function that returns a tuple (a, b), where 'a'\
  \ is\n    // the largest of negative integers, and 'b' is the smallest\n    // of\
  \ positive integers in a list.\n    // If there is no negative or positive integers,\
  \ return them as None.\n    // Examples:\n    // largest_smallest_integers([2, 4,\
  \ 1, 3, 5, 7]) == (None, 1)\n    // largest_smallest_integers([]) == (None, None)\n\
  \    // largest_smallest_integers([0]) == (None, None)\n    public static Pair<Optional<Integer>,\
  \ Optional<Integer>> largestSmallestIntegers(ArrayList<Integer> lst) {\n"
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- '    }

  }'
- "\n    }\n"
tests: "}\n    public static void main(String[] args) {\n    assert(largestSmallestIntegers((new\
  \ ArrayList<Integer>(Arrays.asList((int)2, (int)4, (int)1, (int)3, (int)5, (int)7)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(1))));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)2,\
  \ (int)4, (int)1, (int)3, (int)5, (int)7, (int)0)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(1))));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)1,\
  \ (int)3, (int)2, (int)4, (int)5, (int)6, (int)-2)))).equals(Pair.with(-2, 1)));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)4,\
  \ (int)5, (int)3, (int)6, (int)2, (int)7, (int)-7)))).equals(Pair.with(-7, 2)));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)7,\
  \ (int)3, (int)8, (int)4, (int)9, (int)2, (int)5, (int)-9)))).equals(Pair.with(-9,\
  \ 2)));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList()))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)0)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)-1,\
  \ (int)-3, (int)-5, (int)-6)))).equals(Pair.with(Optional.of(-1), Optional.of(Optional.empty()))));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)-1,\
  \ (int)-3, (int)-5, (int)-6, (int)0)))).equals(Pair.with(Optional.of(-1), Optional.of(Optional.empty()))));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Integer>(Arrays.asList((int)-6,\
  \ (int)-4, (int)-4, (int)-3, (int)1)))).equals(Pair.with(-3, 1)));\n    assert(largestSmallestIntegers((new\
  \ ArrayList<Integer>(Arrays.asList((int)-6, (int)-4, (int)-4, (int)-3, (int)-100,\
  \ (int)1)))).equals(Pair.with(-3, 1)));\n    }\n\n}\n"
