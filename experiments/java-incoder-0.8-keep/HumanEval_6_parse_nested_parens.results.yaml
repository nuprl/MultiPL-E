name: HumanEval_6_parse_nested_parens
language: java
results:
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        StringTokenizer tok = new StringTokenizer(paren_string);\n\
    \        tok.useDelimiter(\" \");\n        while (tok.hasMoreTokens()) {\n   \
    \         String curr_str = tok.nextToken();\n            // If the current string\
    \ contains parenthesis, recurse\n            if (curr_str.contains(\"(\")) {\n\
    \                ArrayList<Integer> curr_levels = parseNestedParens(curr_str);\n\
    \                levels.addAll(curr_levels);\n            }\n            // Otherwise,\
    \ add one to the deepest level\n            else {\n                levels.add(levels.size());\n\
    \            }\n        }\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmprq55ota2.java:17: error: cannot find symbol\n        tok.useDelimiter(\"\
    \ \");\n           ^\n  symbol:   method useDelimiter(String)\n  location: variable\
    \ tok of type StringTokenizer\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        Matcher m = Pattern.compile(\"\\\\(.*?\\\
    \\)\").matcher(paren_string);\n        while (m.find()) {\n            MatchResult\
    \ res = m.toMatchResult();\n            String group_str = res.group();\n    \
    \        int index = group_str.indexOf(\")\");\n            if (index > 0) {\n\
    \                int paren_count = 1;\n                for (int j = 1; j < index;\
    \ j++) {\n                    if (group_str.charAt(j) == ')')\n              \
    \          paren_count--;\n                }\n                levels.add(paren_count);\n\
    \            }\n        }\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6au9th33.java:16: error: cannot find symbol\n        Matcher m\
    \ = Pattern.compile(\"\\\\(.*?\\\\)\").matcher(paren_string);\n        ^\n  symbol:\
    \   class Matcher\n  location: class Problem\n/tmp/tmp6au9th33.java:16: error:\
    \ cannot find symbol\n        Matcher m = Pattern.compile(\"\\\\(.*?\\\\)\").matcher(paren_string);\n\
    \                    ^\n  symbol:   variable Pattern\n  location: class Problem\n\
    /tmp/tmp6au9th33.java:18: error: cannot find symbol\n            MatchResult res\
    \ = m.toMatchResult();\n            ^\n  symbol:   class MatchResult\n  location:\
    \ class Problem\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_level_of_nesting\
    \ = new ArrayList<>();\n        ArrayList<Integer> level_of_nesting = new ArrayList<>();\n\
    \        HashMap<String, Integer> paren_level_count = new HashMap<>();\n     \
    \   ArrayList<String> paren_level_chars = new ArrayList<>();\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            paren_level_count.put(paren_string.substring(i,\
    \ i + 1), paren_level_count.get(paren_string.substring(i, i + 1) + 1) + 1);\n\
    \        }\n        for (String char_string : paren_level_count.keySet()) {\n\
    \            if (paren_level_count.get(char_string) > max_level_of_nesting.get(0))\
    \ {\n                max_level_of_nesting.clear();\n                level_of_nesting.clear();\n\
    \                paren_level_count.clear();\n            }\n            if (paren_level_count.get(char_string)\
    \ == max_level_of_nesting.get(0))\n                max_level_of_nesting.add(paren_level_count.get(char_string));\n\
    \            if (paren_level_count.get(char_string) > max_level_of_nesting.get(0))\
    \ {\n                max_level_of_nesting.add(paren_level_count.get(char_string));\n\
    \                level_of_nesting.add(char_string);\n                paren_level_count.remove(char_string);\n\
    \                paren_level_chars.add(char_string);\n            }\n        }\n\
    \        ArrayList<Integer> final_level_of_nesting = new ArrayList<>();\n    \
    \    for (int i = 0; i < max_level_of_nesting.size(); i++) {\n            for\
    \ (int j = 0; j < level_of_nesting.size(); j++) {\n                if (level_of_nesting.get(j).equals(paren_level_chars.get(i)))\
    \ {\n                    final_level_of_nesting.add(level_of_nesting.get(j));\n\
    \                }\n            }\n        }\n        return final_level_of_nesting;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu2_u2mcu.java:32: error: no suitable method found for add(String)\n\
    \                level_of_nesting.add(char_string);\n                        \
    \        ^\n    method Collection.add(Integer) is not applicable\n      (argument\
    \ mismatch; String cannot be converted to Integer)\n    method List.add(Integer)\
    \ is not applicable\n      (argument mismatch; String cannot be converted to Integer)\n\
    \    method AbstractCollection.add(Integer) is not applicable\n      (argument\
    \ mismatch; String cannot be converted to Integer)\n    method AbstractList.add(Integer)\
    \ is not applicable\n      (argument mismatch; String cannot be converted to Integer)\n\
    \    method ArrayList.add(Integer) is not applicable\n      (argument mismatch;\
    \ String cannot be converted to Integer)\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<Integer>();\n\n        // First pass to find all the groups\
    \ of parentheses that we recognize.\n        for(int i = 0; ; i++) {\n       \
    \     if(paren_string.charAt(i) == '(') {\n                results.add(1);\n \
    \           }\n            else if(paren_string.charAt(i) == ')') {\n        \
    \        if(results.size() == 0) {\n                    throw new RuntimeException(\"\
    No matching closing parenthesis.\");\n                }\n                else\
    \ {\n                    if(results.get(results.size() - 1) != 1) {\n        \
    \                throw new RuntimeException(\"Unbalanced parentheses.\");\n  \
    \                  }\n                    results.pop();\n                }\n\
    \            }\n            else {\n                throw new RuntimeException(\"\
    Unrecognized opening parenthesis.\");\n            }\n        }\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt0qsdww1.java:30: error: cannot find symbol\n                 \
    \   results.pop();\n                           ^\n  symbol:   method pop()\n \
    \ location: variable results of type ArrayList<Integer>\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nesting_level\
    \ = new ArrayList<>();\n        ArrayList<Integer> pair = new ArrayList<>();\n\
    \        // initialize pair to store parentheses pair\n        for (int i = 0;\
    \ i < paren_string.length(); i++) {\n            if (paren_string.charAt(i) ==\
    \ '(') {\n                pair.add(i);\n            }\n            if (paren_string.charAt(i)\
    \ == ')') {\n                nesting_level.add(pair.size() - 1);\n           \
    \ }\n        }\n        return nesting_level;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpohs8c_01.java:27: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        if (paren_string.isEmpty())\
    \ return new ArrayList<Integer>();\n        ArrayList<Integer> nestings = new\
    \ ArrayList<Integer>();\n        int paren_depth = paren_string.length();\n  \
    \      StringBuilder temp = new StringBuilder(paren_string);\n        boolean\
    \ first_char = true;\n        while (true) {\n            if (paren_depth == 0)\
    \ {\n                nestings.add(temp.lastIndexOf(')'));\n                break;\n\
    \            }\n            int i = temp.lastIndexOf('(');\n            if (i\
    \ == -1) {\n                nestings.add(0);\n                break;\n       \
    \     }\n            nestings.add(i + 1);\n            temp.replace(i, 1, ' ');\n\
    \            paren_depth--;\n        }\n        return nestings;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmptv736t_e.java:22: error: no suitable method found for lastIndexOf(char)\n\
    \                nestings.add(temp.lastIndexOf(')'));\n                      \
    \           ^\n    method AbstractStringBuilder.lastIndexOf(String) is not applicable\n\
    \      (argument mismatch; char cannot be converted to String)\n    method StringBuilder.lastIndexOf(String)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    /tmp/tmptv736t_e.java:25: error: no suitable method found for lastIndexOf(char)\n\
    \            int i = temp.lastIndexOf('(');\n                        ^\n    method\
    \ AbstractStringBuilder.lastIndexOf(String) is not applicable\n      (argument\
    \ mismatch; char cannot be converted to String)\n    method StringBuilder.lastIndexOf(String)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    /tmp/tmptv736t_e.java:31: error: no suitable method found for replace(int,int,char)\n\
    \            temp.replace(i, 1, ' ');\n                ^\n    method AbstractStringBuilder.replace(int,int,String)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    \    method StringBuilder.replace(int,int,String) is not applicable\n      (argument\
    \ mismatch; char cannot be converted to String)\nNote: Some messages have been\
    \ simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<Integer>();\n        // Start with a queue of all the parentheses\
    \ (and their opening parentheses).\n        LinkedList<Integer> opening_parentheses\
    \ = new LinkedList<Integer>();\n        opening_parentheses.add(0);\n        //\
    \ Keep track of the number of unmatched parentheses we find. Whenever a new opening\
    \ parentheses is found,\n        // we subtract 1 from the number of unmatched\
    \ parentheses.\n        int unmatched_parentheses = 0;\n        // Loop through\
    \ all parentheses in the input string.\n        for(int i = 0; i < paren_string.length();\
    \ i++) {\n            // If there is a closing parenthesis anywhere, we will consider\
    \ this a match.\n            if(paren_string.charAt(i) == '(') {\n           \
    \     // Add the opening parentheses to the queue of parentheses to match later.\n\
    \                opening_parentheses.addFirst(i);\n            }\n           \
    \ // Otherwise, we are adding an opening parenthesis to the queue of parentheses\
    \ to match later.\n            else {\n                // If there are no parentheses\
    \ in the queue, then we are matching an opening parentheses we did not find.\n\
    \                // So we will add this opening parentheses to our open list and\
    \ subtract 1 from our number of unmatched parenthesis.\n                if(opening_parentheses.size()\
    \ > 0) {\n                    opening_parentheses.addFirst(i);\n             \
    \       unmatched_parentheses--;\n                }\n            }\n        }\n\
    \        // The result list will keep track of the deepest level of nesting.\n\
    \        result.add(0);\n        // Loop through all the parentheses in the queue.\n\
    \        for(int i = 0; i < opening_parentheses.size();) {\n            // If\
    \ the queue is not empty, and the number of unmatched parentheses is less than\
    \ or equal to 1,\n            // then this parenthesis is a matching parenthese,\
    \ so we will increment our level of nesting.\n            if((i >= opening_parentheses.size())\
    \ || (unmatched_parentheses <= 1)) {\n                result.add((int)result.last()\
    \ + 1);\n                // Loop through all the unmatched parentheses we have.\n\
    \                for(int j = 0; j < unmatched_parentheses; j++) {\n          \
    \          opening_parentheses.removeLast();\n                }\n            }\n\
    \            // Otherwise, we'll remove the last element in the queue, increment\
    \ our level of nesting, and remove the\n            // last element from the queue.\n\
    \            else {\n                opening_parentheses.removeLast();\n     \
    \           result.add((int)result.last() + 1);\n            }\n        }\n  \
    \      // Return result as an array.\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmptzemyhcc.java:46: error: cannot find symbol\n                result.add((int)result.last()\
    \ + 1);\n                                      ^\n  symbol:   method last()\n\
    \  location: variable result of type ArrayList<Integer>\n/tmp/tmptzemyhcc.java:56:\
    \ error: cannot find symbol\n                result.add((int)result.last() + 1);\n\
    \                                      ^\n  symbol:   method last()\n  location:\
    \ variable result of type ArrayList<Integer>\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n       \
    \ boolean open_brace = false;\n        for (char c : paren_string.toCharArray())\
    \ {\n            switch (c) {\n                case '(':\n                   \
    \ open_brace = true;\n                    stack.push(c);\n                   \
    \ break;\n                case ')':\n                    if (open_brace) {\n \
    \                       int levels = stack.size();\n                        if\
    \ (levels > 0) {\n                            int level = stack.pop();\n     \
    \                       while (level > 0) {\n                                level--;\n\
    \                            }\n                            results.add(levels);\n\
    \                        }\n                        open_brace = false;\n    \
    \                }\n                    break;\n                default:\n   \
    \                 if (!open_brace) {\n                        stack.push(c);\n\
    \                    }\n                    break;\n            }\n        }\n\
    \        if (stack.isEmpty()) {\n            return results;\n        } else {\n\
    \            return null;\n        }\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx1goexi0.java:22: error: incompatible types: char cannot be converted\
    \ to String\n                    stack.push(c);\n                            \
    \   ^\n/tmp/tmpx1goexi0.java:28: error: incompatible types: String cannot be converted\
    \ to int\n                            int level = stack.pop();\n             \
    \                                    ^\n/tmp/tmpx1goexi0.java:39: error: incompatible\
    \ types: char cannot be converted to String\n                        stack.push(c);\n\
    \                                   ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Create a stack for recording\
    \ the deepest level of\n        // nesting for each group of parentheses.\n  \
    \      Stack<Integer> stack = new Stack<>();\n        // For each group of parentheses,\
    \ push the level of\n        // nesting onto the stack.\n        for (int i =\
    \ 0; i < paren_string.length(); i++) {\n            char ch = paren_string.charAt(i);\n\
    \            if (ch == '(') {\n                stack.push(1);\n            } else\
    \ if (ch == ')') {\n                // If the current level of nesting is greater\n\
    \                // than the previous level of nesting, pop the\n            \
    \    // current level of nesting off the stack and push\n                // the\
    \ new level of nesting onto the stack.\n                if (stack.isEmpty() ||\
    \ stack.pop() < stack.getTop()) {\n                    stack.push(1);\n      \
    \          }\n            } else {\n                // Otherwise, record the current\
    \ level of nesting.\n                stack.push(0);\n            }\n        }\n\
    \        // Return the level of nesting of each group of parentheses.\n      \
    \  ArrayList<Integer> result = new ArrayList<>(paren_string.length());\n     \
    \   for (Integer levelOfNesting : stack) {\n            result.add(levelOfNesting);\n\
    \        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc4xz5s9l.java:29: error: cannot find symbol\n                if\
    \ (stack.isEmpty() || stack.pop() < stack.getTop()) {\n                      \
    \                                    ^\n  symbol:   method getTop()\n  location:\
    \ variable stack of type Stack<Integer>\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int stack = -1;\n        int\
    \ paren_count = 0;\n        ArrayList<Integer> nesting_levels = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> levels = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ indices = new ArrayList<Integer>();\n        int prev_char = '(';\n        int\
    \ new_char = '(';\n        for (int i = 0; i < paren_string.length(); i++) {\n\
    \            char ch = paren_string.charAt(i);\n            switch (ch) {\n  \
    \          case '(':\n                if (stack == -1) {\n                   \
    \ stack++;\n                }\n                else {\n                    stack--;\n\
    \                }\n                levels.add(stack + 1);\n                break;\n\
    \            case '[':\n                stack = -1;\n                levels.add(stack\
    \ + 1);\n                indices.add(levels.size() - 1);\n                prev_char\
    \ = ch;\n                break;\n            case ')':\n                if (stack\
    \ == 0) {\n                    throw new IllegalArgumentException(\"unexpected\
    \ closing bracket \" + ch);\n                }\n                else {\n     \
    \               stack--;\n                }\n                levels.add(stack\
    \ + 1);\n                indices.add(levels.size() - 1);\n                prev_char\
    \ = ch;\n                break;\n            case ' ':\n                levels.add(stack\
    \ + 1);\n                break;\n            case ')':\n                if (prev_char\
    \ == ' ') {\n                    levels.add(stack + 1);\n                    prev_char\
    \ = ch;\n                }\n                else {\n                    throw\
    \ new IllegalArgumentException(\"unexpected closing bracket \" + ch);\n      \
    \          }\n                break;\n            default:\n                if\
    \ (prev_char == ' ') {\n                    prev_char = ch;\n                }\n\
    \                else {\n                    throw new IllegalArgumentException(\"\
    unexpected character \" + ch + \" at index \" + i);\n                }\n     \
    \           break;\n            }\n        }\n        int max_level = levels.get(levels.size()\
    \ - 1);\n        for (int i = 0; i <= max_level; i++) {\n            nesting_levels.add(levels.get(i));\n\
    \        }\n        return nesting_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpunc41pcq.java:54: error: duplicate case label\n            case\
    \ ')':\n            ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level_of_nesting\
    \ = new ArrayList<>();\n        // Split string by spaces\n        String[] strings\
    \ = paren_string.split(\" \");\n        // Create a stack\n        Stack<Character>\
    \ stack = new Stack<>();\n        // Iterate through the strings and add the level\
    \ of nesting\n        for (String string : strings) {\n            // We encountered\
    \ a \")\" which means we need to push the previous \")\"\n            if (string.equals(\"\
    )\")) {\n                // Push the current \")\"\n                stack.push(string);\n\
    \            } else {\n                // We encountered an opening \"(\" which\
    \ means we need to increase the level of nesting by one\n                if (string.equals(\"\
    (\")) {\n                    level_of_nesting.add(0, level_of_nesting.size());\n\
    \                } else if (stack.empty()) {\n                    // When we encountered\
    \ the opening \"(\" without pushing the \")\", the current level of nesting is\
    \ zero.\n                    level_of_nesting.add(0, level_of_nesting.size());\n\
    \                } else {\n                    level_of_nesting.add(0, level_of_nesting.size());\n\
    \                    int level = Integer.parseInt(string);\n                 \
    \   // Pop the previous \")\" and push current \"(\" with increasing level\n \
    \                   while (!stack.empty()) {\n                        String element\
    \ = stack.pop();\n                        if (element.equals(\")\")) {\n     \
    \                       level_of_nesting.add(level);\n                       \
    \ } else {\n                            level_of_nesting.add(level + 1);\n   \
    \                     }\n                    }\n                }\n          \
    \  }\n        }\n        // We are done since we need to return the maximum level\
    \ of nesting\n        return level_of_nesting;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc0b67rw6.java:25: error: incompatible types: String cannot be converted\
    \ to Character\n                stack.push(string);\n                        \
    \   ^\n/tmp/tmpc0b67rw6.java:38: error: incompatible types: Character cannot be\
    \ converted to String\n                        String element = stack.pop();\n\
    \                                                  ^\nNote: Some messages have\
    \ been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> list_of_ints\
    \ = new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n       \
    \ boolean open_parentheses = false;\n        boolean close_parentheses = false;\n\
    \        StringBuilder nested_stack = new StringBuilder();\n        StringBuilder\
    \ new_stack = new StringBuilder();\n        for(int i = 0; i < (paren_string.length());\
    \ i++) {\n            char ch = paren_string.charAt(i);\n            int int_ch\
    \ = ch;\n            int int_stack_size = 0;\n            String str_ch = String.valueOf(int_ch);\n\
    \            if(open_parentheses) {\n                stack.push(str_ch);\n   \
    \             int_stack_size++;\n            }\n            if(ch == '(') {\n\
    \                open_parentheses = true;\n                int_stack_size++;\n\
    \            }\n            if(ch == ')') {\n                open_parentheses\
    \ = false;\n                close_parentheses = true;\n                int_stack_size++;\n\
    \            }\n            if(open_parentheses && close_parentheses) {\n    \
    \            if(int_stack_size < 2) {\n                    list_of_ints.add(int_stack_size);\n\
    \                } else {\n                    list_of_ints.add(int_stack_size);\n\
    \                    list_of_ints.add(new_stack.indexOf(1));\n               \
    \ }\n                new_stack = new StringBuilder();\n                close_parentheses\
    \ = false;\n            }\n            nested_stack.append(str_ch);\n        }\n\
    \        if(open_parentheses && close_parentheses && new_stack.length() > 0) {\n\
    \            list_of_ints.add(new_stack.indexOf(1));\n        }\n        return\
    \ list_of_ints;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp25iq3rv1.java:44: error: no suitable method found for indexOf(int)\n\
    \                    list_of_ints.add(new_stack.indexOf(1));\n               \
    \                               ^\n    method AbstractStringBuilder.indexOf(String)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to String)\n\
    \    method StringBuilder.indexOf(String) is not applicable\n      (argument mismatch;\
    \ int cannot be converted to String)\n/tmp/tmp25iq3rv1.java:52: error: no suitable\
    \ method found for indexOf(int)\n            list_of_ints.add(new_stack.indexOf(1));\n\
    \                                      ^\n    method AbstractStringBuilder.indexOf(String)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to String)\n\
    \    method StringBuilder.indexOf(String) is not applicable\n      (argument mismatch;\
    \ int cannot be converted to String)\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<Integer>();\n        String[] strings = paren_string.split(\"\
    \ \");\n        for (String string : strings) {\n            result.addAll(parseNestedParens(string));\n\
    \        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4l0o3nly.java:21: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> parens_levels\
    \ = new ArrayList<Integer>();\n        // Loop through the string and find all\
    \ parenthesis pairs\n        for (int i = 0; i < paren_string.length(); i++) {\n\
    \            // If this character is right to left then ignore the character\n\
    \            if (paren_string.charAt(i) == '(') {\n                // If we have\
    \ not seen the opening parenthesis then add it to the parens_levels\n        \
    \        if (parens_levels.isEmpty()) {\n                    parens_levels.add(0);\n\
    \                }\n                // If the current parenthesis level is greater\
    \ than the parens_levels in the parens_levels arraylist\n                // then\
    \ append it to the parens_levels arraylist\n                if (parens_levels.get(i)\
    \ > parens_levels.get(parens_levels.size() - 1)) {\n                    parens_levels.add(parens_levels.get(parens_levels.size()\
    \ - 1) + 1);\n                }\n            }\n            // If this character\
    \ is left to right then ignore the character\n            else if (paren_string.charAt(i)\
    \ == ')') {\n                // If we have not seen the closing parenthesis then\
    \ add it to the parens_levels\n                if (parens_levels.isEmpty()) {\n\
    \                    parens_levels.add(0);\n                }\n              \
    \  // If the current parenthesis level is greater than the parens_levels in the\
    \ parens_levels arraylist\n                // then append it to the parens_levels\
    \ arraylist\n                if (parens_levels.get(i) > parens_levels.get(parens_levels.size()\
    \ - 1)) {\n                    parens_levels.add(parens_levels.get(parens_levels.size()\
    \ - 1) + 1);\n                }\n            }\n        }\n        return parens_levels;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzpec8rmx.java:44: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int paren_level = new Integer[paren_string.length()];\n\
    \        for (int i = 0; i < paren_level.length; i++) {\n            paren_level[i]\
    \ = 0;\n        }\n        ArrayList<Integer> results = new ArrayList<Integer>();\n\
    \        boolean in_paren_pair = false;\n        int paren_pair = 0;\n       \
    \ for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            if (c == '(') {\n                paren_level[paren_pair]++;\n   \
    \             in_paren_pair = true;\n            } else if (c == ')' && in_paren_pair)\
    \ {\n                paren_level[paren_pair]--;\n                in_paren_pair\
    \ = false;\n                results.add(paren_level[paren_pair]);\n          \
    \  } else if (c == ' ' && in_paren_pair) {\n                results.add(paren_level[paren_pair]);\n\
    \            }\n        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj6bxn6eb.java:15: error: incompatible types: Integer[] cannot be\
    \ converted to int\n        int paren_level = new Integer[paren_string.length()];\n\
    \                          ^\n/tmp/tmpj6bxn6eb.java:16: error: int cannot be dereferenced\n\
    \        for (int i = 0; i < paren_level.length; i++) {\n                    \
    \                   ^\n/tmp/tmpj6bxn6eb.java:17: error: array required, but int\
    \ found\n            paren_level[i] = 0;\n                       ^\n/tmp/tmpj6bxn6eb.java:25:\
    \ error: array required, but int found\n                paren_level[paren_pair]++;\n\
    \                           ^\n/tmp/tmpj6bxn6eb.java:28: error: array required,\
    \ but int found\n                paren_level[paren_pair]--;\n                \
    \           ^\n/tmp/tmpj6bxn6eb.java:30: error: array required, but int found\n\
    \                results.add(paren_level[paren_pair]);\n                     \
    \                  ^\n/tmp/tmpj6bxn6eb.java:32: error: array required, but int\
    \ found\n                results.add(paren_level[paren_pair]);\n             \
    \                          ^\n7 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        StringTokenizer tokens = new StringTokenizer(paren_string);\n\
    \        while (tokens.hasMoreTokens()) {\n            String level_str = tokens.nextToken();\n\
    \            int level = 0;\n            for (int i = 0; i < level_str.length();\
    \ i++) {\n                char c = level_str.charAt(i);\n                if (c\
    \ == '(') level++;\n                if (c == ')') level--;\n            }\n  \
    \          levels.add(level);\n        }\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9l8oz0ri.java:28: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Store the parentheses level\
    \ of each parentheses\n        ArrayList<Integer> levels = new ArrayList<>();\n\
    \        // The parentheses stack\n        Stack<String> paren_stack = new Stack<>();\n\
    \        // The parentheses group\n        ArrayList<String> paren_group = new\
    \ ArrayList<>();\n        // The parentheses level\n        int level = 0;\n \
    \       // Iterate through the string\n        for(int i = 0; i<paren_string.length();\
    \ i++) {\n            // If the current char is an opening parentheses, push it\
    \ to the stack\n            if(paren_string.charAt(i) == '(') {\n            \
    \    paren_stack.push(paren_group);\n                paren_group.clear();\n  \
    \              level = 0;\n            }\n            // If the current char is\
    \ a closing parentheses, pop an element from stack\n            else if(paren_string.charAt(i)\
    \ == ')') {\n                level -= 1;\n                if(level == 0 && levels.size()\
    \ > 0) {\n                    levels.add(levels.size());\n                }\n\
    \                level++;\n            }\n            // If the current char is\
    \ neither opening nor closing parentheses, push it to the stack\n            else\
    \ {\n                paren_group.add(paren_string.charAt(i));\n            }\n\
    \        }\n        if(levels.size() > 0) {\n            levels.add(levels.size());\n\
    \        }\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu53qx5wo.java:27: error: incompatible types: ArrayList<String>\
    \ cannot be converted to String\n                paren_stack.push(paren_group);\n\
    \                                 ^\n/tmp/tmpu53qx5wo.java:41: error: no suitable\
    \ method found for add(char)\n                paren_group.add(paren_string.charAt(i));\n\
    \                           ^\n    method Collection.add(String) is not applicable\n\
    \      (argument mismatch; char cannot be converted to String)\n    method List.add(String)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    \    method AbstractCollection.add(String) is not applicable\n      (argument\
    \ mismatch; char cannot be converted to String)\n    method AbstractList.add(String)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    \    method ArrayList.add(String) is not applicable\n      (argument mismatch;\
    \ char cannot be converted to String)\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        if (paren_string.isEmpty())\n\
    \            return new ArrayList<>();\n        ArrayList<Integer> stack = new\
    \ ArrayList<>();\n        int paren_level = 0;\n        boolean paranthesesFound\
    \ = false;\n        int paren_count = 0;\n        int current_level = 0;\n   \
    \     int current_count = 0;\n        for (char c : paren_string.toCharArray())\
    \ {\n            if (c == '(') {\n                paren_count++;\n           \
    \     if (paren_count == 1 && parenthesesFound) {\n                    stack.clear();\n\
    \                    stack.add(paren_level);\n                    paranthesesFound\
    \ = false;\n                }\n            }\n            if (c == ')') {\n  \
    \              paren_count--;\n                if (paren_count == 0) {\n     \
    \               parenthesesFound = true;\n                    stack.clear();\n\
    \                    stack.add(paren_level);\n                    current_level\
    \ = stack.size() - 1;\n                    current_count = stack.size();\n   \
    \             }\n            }\n            if (c == '(') {\n                paranthesesFound\
    \ = true;\n                paren_count++;\n            }\n            if (c ==\
    \ ')') {\n                paranthesesFound = false;\n                paren_count--;\n\
    \            }\n            current_count++;\n        }\n        if (paranthesesFound)\
    \ {\n            stack.clear();\n        }\n        return stack;\nreturn new\
    \ ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3u83hmj0.java:26: error: cannot find symbol\n                if\
    \ (paren_count == 1 && parenthesesFound) {\n                                 \
    \       ^\n  symbol:   variable parenthesesFound\n  location: class Problem\n\
    /tmp/tmp3u83hmj0.java:35: error: cannot find symbol\n                    parenthesesFound\
    \ = true;\n                    ^\n  symbol:   variable parenthesesFound\n  location:\
    \ class Problem\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level_array\
    \ = new ArrayList<Integer>();\n        String[] string_array = paren_string.trim().split(\"\
    \ \");\n        for (String s : string_array) {\n            if (s.equals(\"()\"\
    ) || s.equals(\")\") || s.equals(\"\")) {\n                level_array.add(0);\n\
    \            } else {\n                int level = 0;\n                for (int\
    \ i = 0; i < s.length(); i++) {\n                    if (s.charAt(i) == '(')\n\
    \                        level++;\n                    if (s.charAt(i) == ')')\n\
    \                        level--;\n                    if (level == -1)\n    \
    \                    break;\n                }\n                level_array.add(level);\n\
    \            }\n        }\n        return level_array;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzok33_nf.java:34: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Return value\n        ArrayList<Integer>\
    \ result_list = new ArrayList<Integer>();\n        ArrayList<Integer> result_stack\
    \ = new ArrayList<Integer>();\n        // Iterate over input string\n        for\
    \ (String chars : paren_string.split(\" \")) {\n            int paren_level =\
    \ 0;\n            // Iterate over input string chars\n            for (char c\
    \ : chars.toCharArray()) {\n                switch (c) {\n                   \
    \ case '(':\n                        result_stack.add(paren_level);\n        \
    \                break;\n                    case ')':\n                     \
    \   // If level > 0, then we have found an inner level.\n                    \
    \    // Increase level and store result in result_list\n                     \
    \   if (result_stack.isEmpty()) result_list.add(-1);\n                       \
    \ else {\n                            int level_top = result_stack.peek();\n \
    \                           if (level_top > result_list.size())\n            \
    \                    result_list.add(level_top);\n                        }\n\
    \                        // Pop level from stack\n                        int\
    \ pop_level = result_stack.poll();\n                        if (pop_level >= 0)\n\
    \                            result_list.add(pop_level);\n                   \
    \     break;\n                    case ' ':\n                        // Increase\
    \ level\n                        result_list.add(paren_level);\n             \
    \           break;\n                    default:\n                        break;\n\
    \                }\n            }\n        }\n        return result_list;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmps5k19n6p.java:32: error: cannot find symbol\n                 \
    \           int level_top = result_stack.peek();\n                           \
    \                             ^\n  symbol:   method peek()\n  location: variable\
    \ result_stack of type ArrayList<Integer>\n/tmp/tmps5k19n6p.java:37: error: cannot\
    \ find symbol\n                        int pop_level = result_stack.poll();\n\
    \                                                    ^\n  symbol:   method poll()\n\
    \  location: variable result_stack of type ArrayList<Integer>\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Iterate over each group\
    \ and find deepest level of nesting\n        ArrayList<Integer> deepest_level_of_nesting\
    \ = new ArrayList<Integer>();\n        for (String group_string : paren_string.split(\"\
    \ \")) {\n            group_string = group_string.trim();\n            int level_of_nesting\
    \ = 1;\n            for (int i = 0; i < group_string.length(); i++) {\n      \
    \          if (group_string.charAt(i) == '(') {\n                    level_of_nesting++;\n\
    \                }\n                if (group_string.charAt(i) == ')') {\n   \
    \                 level_of_nesting--;\n                }\n            }\n    \
    \        deepest_level_of_nesting.add(level_of_nesting);\n        }\n        return\
    \ deepest_level_of_nesting;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeqkrwfx3.java:31: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Initialize an empty array\
    \ list\n        ArrayList<Integer> max_level_of_nesting = new ArrayList<Integer>();\n\
    \        // Add each level of nesting in parentheses to the arraylist\n      \
    \  int level_of_nesting = 0;\n        for(int i = 0; i < paren_string.length();\
    \ i++) {\n            if(paren_string.charAt(i) == ')') {\n                level_of_nesting++;\n\
    \                if(level_of_nesting > max_level_of_nesting.size()) {\n      \
    \              max_level_of_nesting.add(level_of_nesting);\n                }\n\
    \            } else {\n                level_of_nesting = 0;\n            }\n\
    \        }\n        return max_level_of_nesting;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp017b8wqy.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<Integer>();\n        StringTokenizer tokenizer = new StringTokenizer(paren_string);\n\
    \        while (tokenizer.hasMoreTokens()) {\n            String token = tokenizer.nextToken();\n\
    \            if (token.equals(\"(\")) {\n                result.add(1);\n    \
    \        } else {\n                int index = result.size() - 1;\n          \
    \      for (int i = 1; i < result.size(); i++) {\n                    if (paren_string.charAt(index)\
    \ == token.charAt(0)) {\n                        result.add(i);\n            \
    \            index = i;\n                    }\n                }\n          \
    \  }\n        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkd2a03wq.java:32: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nesting_levels\
    \ = new ArrayList<>();\n\n        // First, find how many parentheses are in the\
    \ string.\n        int num_parentheses = paren_string.split(\"\\\\(\").length\
    \ - 1;\n\n        // Now traverse through the string and record how much each\
    \ level of nesting is.\n        for (int i = 0; i < num_parentheses; i++) {\n\
    \            // To get nested parentheses, we need to keep track of how many levels\
    \ of parentheses\n            // are already in the string.\n            int parentheses_before\
    \ = i;\n            while (parentheses_before >= 0) {\n                if (paren_string.indexOf(\"\
    \\\\((\", parentheses_before) < 0) {\n                    break;\n           \
    \     }\n                parentheses_before--;\n            }\n            //\
    \ Now that we know how many levels of parentheses are before the current parentheses,\
    \ we\n            // can determine how many levels of parentheses exist after\
    \ the current parentheses.\n            int parentheses_after = paren_string.indexOf(\"\
    \\\\)\", parentheses_before + 1);\n            int new_levels = (parentheses_after\
    \ - parentheses_before + 1);\n            nesting_levels.add(new_levels);\n  \
    \      }\n\n        return nesting_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6zar26nb.java:39: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Define an empty list for\
    \ storing the nested level of parentheses.\n        ArrayList<Integer> max_level\
    \ = new ArrayList<>();\n        // For each of the parentheses in paren_string,\
    \ add one to the nesting level if it is closed.\n        // Then, add one to the\
    \ nesting level if the parentheses inside are closed.\n        paren_string.split(\"\
    \ \").forEach(str ->\n                max_level.add(max_level.size() + 1).orElse(max_level.size()\
    \ + 1)\n        );\n        // Return the list.\n        return max_level;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5idrrz6u.java:19: error: cannot find symbol\n        paren_string.split(\"\
    \ \").forEach(str ->\n                               ^\n  symbol:   method forEach((str)->max[...]\
    \ + 1))\n  location: class String[]\n/tmp/tmp5idrrz6u.java:20: error: boolean\
    \ cannot be dereferenced\n                max_level.add(max_level.size() + 1).orElse(max_level.size()\
    \ + 1)\n                                                   ^\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nesting_levels\
    \ = new ArrayList<>();\n        StringTokenizer tokenizer = new StringTokenizer(paren_string,\
    \ \" ()\");\n        while (tokenizer.hasMoreTokens()) {\n            String curr_token\
    \ = tokenizer.nextToken();\n            nesting_levels.add(paren_string.indexOf(curr_token));\n\
    \        }\n        Collections.sort(nesting_levels);\n        return nesting_levels;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuqui488z.java:23: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Store all opening brackets\
    \ in the same array and the same index\n        ArrayList<String> opening_brackets\
    \ = Arrays.asList(paren_string.split(\"\\\\(\"));\n\n        // Find the deepest\
    \ nested level of brackets\n        ArrayList<Integer> max_level = Arrays.asList(0,\
    \ 0);\n        ArrayList<Integer> temp_level;\n        boolean found_brackets\
    \ = false;\n        for (int i = 1; i < opening_brackets.size(); i++) {\n    \
    \        // Find the next bracket\n            String open_bracket = opening_brackets.get(i);\n\
    \n            // Find the matching closing brackets\n            String close_bracket\
    \ = opening_brackets.get(i - 1);\n            int close_bracket_index = opening_brackets.indexOf(close_bracket);\n\
    \n            if (close_bracket.equals(\"(\") || close_bracket.equals(\")\") ||\
    \ close_bracket.equals(\"{\")\n                    || close_bracket.equals(\"\
    }\") || close_bracket.equals(\"[\")) {\n                // Close the brackets\
    \ found\n                found_brackets = true;\n            }\n            else\
    \ {\n                // Find the corresponding open brackets\n               \
    \ String open_bracket_index = opening_brackets.indexOf(open_bracket);\n      \
    \          String temp_string = opening_brackets.get(open_bracket_index);\n  \
    \              int temp_index = 0;\n\n                // Keep track of the deepest\
    \ level of nesting of brackets\n                while (open_bracket_index != -1\
    \ && temp_index < temp_level.size()) {\n                    if (temp_level.get(temp_index)\
    \ > temp_level.get(temp_index + 1)) {\n                        temp_level = temp_level.subList(temp_index\
    \ + 1, temp_index + 2);\n                        temp_index = temp_index + 1;\n\
    \                    }\n                    else {\n                        temp_index\
    \ = temp_index + 1;\n                    }\n                }\n\n            \
    \    // Keep track of the maximum level of nesting of brackets\n             \
    \   for (int j = temp_index; j < temp_level.size() - 1; j++) {\n             \
    \       if (temp_level.get(j) > temp_level.get(j + 1)) {\n                   \
    \     temp_level = temp_level.subList(j, j + 1);\n                        found_brackets\
    \ = true;\n                    }\n                    else {\n               \
    \         found_brackets = true;\n                    }\n                }\n\n\
    \                if (found_brackets == false) {\n                    // If the\
    \ last bracket is not found, then the deepest level is 1\n                   \
    \ temp_level = Arrays.asList(1, 0);\n                }\n\n                if (temp_level.get(temp_level.size()\
    \ - 1) > max_level.get(max_level.size() - 1)) {\n                    max_level\
    \ = temp_level;\n                }\n            }\n        }\n\n        return\
    \ max_level;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpoy6td96f.java:16: error: incompatible types: no instance(s) of\
    \ type variable(s) T exist so that List<T> conforms to ArrayList<String>\n   \
    \     ArrayList<String> opening_brackets = Arrays.asList(paren_string.split(\"\
    \\\\(\"));\n                                                          ^\n  where\
    \ T is a type-variable:\n    T extends Object declared in method <T>asList(T...)\n\
    /tmp/tmpoy6td96f.java:19: error: incompatible types: no instance(s) of type variable(s)\
    \ T exist so that List<T> conforms to ArrayList<Integer>\n        ArrayList<Integer>\
    \ max_level = Arrays.asList(0, 0);\n                                         \
    \           ^\n  where T is a type-variable:\n    T extends Object declared in\
    \ method <T>asList(T...)\n/tmp/tmpoy6td96f.java:37: error: incompatible types:\
    \ int cannot be converted to String\n                String open_bracket_index\
    \ = opening_brackets.indexOf(open_bracket);\n                                \
    \                                    ^\n/tmp/tmpoy6td96f.java:38: error: no suitable\
    \ method found for get(String)\n                String temp_string = opening_brackets.get(open_bracket_index);\n\
    \                                                     ^\n    method List.get(int)\
    \ is not applicable\n      (argument mismatch; String cannot be converted to int)\n\
    \    method AbstractList.get(int) is not applicable\n      (argument mismatch;\
    \ String cannot be converted to int)\n    method ArrayList.get(int) is not applicable\n\
    \      (argument mismatch; String cannot be converted to int)\n/tmp/tmpoy6td96f.java:42:\
    \ error: incomparable types: String and int\n                while (open_bracket_index\
    \ != -1 && temp_index < temp_level.size()) {\n                               \
    \           ^\n/tmp/tmpoy6td96f.java:44: error: incompatible types: List<Integer>\
    \ cannot be converted to ArrayList<Integer>\n                        temp_level\
    \ = temp_level.subList(temp_index + 1, temp_index + 2);\n                    \
    \                                   ^\n/tmp/tmpoy6td96f.java:55: error: incompatible\
    \ types: List<Integer> cannot be converted to ArrayList<Inte"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> levels = new ArrayList<Integer>();\n\
    \        int level = 0;\n        for (int i = 0; i < paren_string.length(); ++i)\
    \ {\n            char ch = paren_string.charAt(i);\n            if (ch == '(')\
    \ {\n                level++;\n            } else if (ch == ')') {\n         \
    \       level--;\n            } else {\n                levels.add(level);\n \
    \               if (level > max_levels.get(0)) {\n                    max_levels.set(0,\
    \ level);\n                }\n            }\n        }\n        for (int i = 0;\
    \ i < max_levels.size(); ++i) {\n            max_levels.set(i + 1, max_levels.get(i)\
    \ + levels.get(i));\n        }\n        return max_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaze2uyty.java:35: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nested_levels\
    \ = new ArrayList<>();\n\n        // The input string can be represented using\
    \ two characters of parentheses: { and }.\n        // If there is any single parentheses,\
    \ then output the deepest level of nesting.\n        // Else, output zero.\n \
    \       if (paren_string.contains(\"{\") && paren_string.contains(\"}\")) {\n\
    \            String first_par = paren_string.substring(0,1);\n            String\
    \ second_par = paren_string.substring(1,2);\n            if (first_par.equals(\"\
    {\")) {\n                nested_levels.add(0);\n            } else {\n       \
    \         int max_level = 0;\n                for (int i = 0; i < paren_string.length();\
    \ i++) {\n                    String level_char = paren_string.substring(i, i+1);\n\
    \                    if (level_char.equals(first_par)) {\n                   \
    \     if (level_char.equals(second_par)) {\n                            nested_levels.add(max_level\
    \ + 1);\n                            break;\n                        }\n     \
    \                   nested_levels.add(max_level);\n                        max_level\
    \ += 1;\n                        i = paren_string.length();\n                \
    \    } else {\n                        nested_levels.add(max_level);\n       \
    \                 max_level += 1;\n                    }\n                }\n\
    \            }\n        } else {\n            nested_levels.add(0);\n        }\n\
    \n        return nested_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdrmov501.java:48: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        if (paren_string == null || paren_string.trim().isEmpty())\
    \ {\n            return results;\n        }\n        // First, strip the outermost\
    \ parens, if any\n        int num_parens = paren_string.trim().length();\n   \
    \     if (num_parens > 0 && paren_string.charAt(0) == '(' && paren_string.charAt(num_parens\
    \ - 1) == ')') {\n            num_parens--;\n            paren_string = paren_string.substring(1,\
    \ num_parens);\n        }\n        paren_string = paren_string.trim();\n     \
    \   // Now go through the string again to look for nested parens\n        int\
    \ curr_level = 1;\n        int curr_pos = 0;\n        while (curr_pos < paren_string.length())\
    \ {\n            int next_pos = paren_string.indexOf('(', curr_pos);\n       \
    \     if (next_pos == -1) {\n                return results;\n            }\n\
    \            // Found a match\n            results.add(curr_level);\n        \
    \    // Update the current level\n            curr_level = next_pos - curr_pos\
    \ + 1;\n            curr_pos = next_pos + 1;\n        }\n        return results;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6aswswc6.java:41: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Create an array of length\
    \ equal to the string length\n        ArrayList<Integer> a = new ArrayList<Integer>(paren_string.length());\n\
    \        // Initialize a to empty array\n        a.clear();\n        // Parse\
    \ the parenthesis\n        char[] chars = paren_string.toCharArray();\n      \
    \  int index = 0;\n        // If current char is a open parenthesis\n        if\
    \ (chars[index] == '(') {\n            // Increase the index\n            index++;\n\
    \            // If the index is not the end of the string\n            while (index\
    \ < chars.length && chars[index] == ')') {\n                // Decrease the index\n\
    \                index++;\n                // If index is equal to the string\
    \ length, then stop parsing\n                if (index == chars.length) break;\n\
    \                // Else if the current char is a closing parenthesis\n      \
    \          if (chars[index] == ')') {\n                    // Add 1 to the index\n\
    \                    index++;\n                }\n            }\n            //\
    \ Else if the current char is a close parenthesis\n            if (index == chars.length)\
    \ break;\n            // Else if the current char is a comma\n            if (chars[index]\
    \ == ',') {\n                // Add 1 to the index\n                index++;\n\
    \            }\n            // Else if the current char is a semicolon\n     \
    \       if (chars[index] == ';') {\n                // Add 1 to the index\n  \
    \              index++;\n            }\n            // Else if the current char\
    \ is an opening parenthesis\n            if (chars[index] == '(') {\n        \
    \        // Add 1 to the index\n                index++;\n            }\n    \
    \        // Else if the current char is a closing parenthesis\n            if\
    \ (chars[index] == ')') {\n                // Add 1 to the index\n           \
    \     index++;\n            }\n            // Else if the current char is a opening\
    \ bracket\n            if (chars[index] == '[') {\n                // Add 1 to\
    \ the index\n                index++;\n            }\n            // Else if the\
    \ current char is a closing bracket\n            if (chars[index] == ']') {\n\
    \                // Add 1 to the index\n                index++;\n           \
    \ }\n            // Else if the current char is a decimal point\n            if\
    \ (chars[index] == '.') {\n                // Add 1 to the index\n           \
    \     index++;\n            }\n            // Else if the current char is a hex\
    \ digit\n            if (chars[index] == 'x' || chars[index] == 'X') {\n     \
    \           // Add 1 to the index\n                index++;\n            }\n \
    \           // Else if the current char is a number or a letter\n            if\
    \ (chars[index] >= '0' && chars[index] <= '9' || chars[index] >= 'a' && chars[index]\
    \ <= 'z' || chars[index] >= 'A' && chars[index] <= 'Z' || chars[index] == '_'\
    \ || chars[index] == '-') {\n                // Add 1 to the index\n         \
    \       index++;\n            }\n            // Else if the current char is blank\n\
    \            if (char\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpafpxbvhi.java:87: error: '.class' expected\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n/tmp/tmpafpxbvhi.java:89: error: illegal start of expression\n    public static\
    \ void main(String[] args) {\n    ^\n/tmp/tmpafpxbvhi.java:89: error: illegal\
    \ start of expression\n    public static void main(String[] args) {\n        \
    \   ^\n/tmp/tmpafpxbvhi.java:89: error: ';' expected\n    public static void main(String[]\
    \ args) {\n                 ^\n/tmp/tmpafpxbvhi.java:89: error: '.class' expected\n\
    \    public static void main(String[] args) {\n                              \
    \       ^\n/tmp/tmpafpxbvhi.java:89: error: ';' expected\n    public static void\
    \ main(String[] args) {\n                                         ^\n/tmp/tmpafpxbvhi.java:95:\
    \ error: reached end of file while parsing\n}\n ^\n7 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> level_stack = new ArrayList<Integer>();\n\
    \        for(int i = 0; i < paren_string.length(); i++) {\n            String\
    \ curr_char = null;\n            char curr_char_ch = '\\0';\n            boolean\
    \ found = false;\n            for(int j = 0; j < level_stack.size(); j++) {\n\
    \                if(paren_string.charAt(i) == level_stack.get(j)) {\n        \
    \            found = true;\n                    break;\n                }\n  \
    \          }\n            if(found) {\n                level_stack.remove(0);\n\
    \                level_stack.add(0);\n                level_stack.clear();\n \
    \           } else {\n                level_stack.add(paren_string.charAt(i));\n\
    \            }\n            if(paren_string.charAt(i) == '(') {\n            \
    \    level_stack.add(paren_string.charAt(i));\n            } else {\n        \
    \        if(level_stack.size() > 0) {\n                    curr_char = level_stack.get(level_stack.size()\
    \ - 1);\n                } else {\n                    curr_char = '\\0';\n  \
    \              }\n            }\n            if(paren_string.charAt(i) == ')')\
    \ {\n                if(level_stack.size() > 0) {\n                    if(paren_string.charAt(i)\
    \ == '(') {\n                        levels.add(paren_string.charAt(i));\n   \
    \                 } else {\n                        levels.add(level_stack.get(level_stack.size()\
    \ - 1));\n                    }\n                }\n            }\n        }\n\
    \        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp29988r84.java:32: error: no suitable method found for add(char)\n\
    \                level_stack.add(paren_string.charAt(i));\n                  \
    \         ^\n    method Collection.add(Integer) is not applicable\n      (argument\
    \ mismatch; char cannot be converted to Integer)\n    method List.add(Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    \    method AbstractCollection.add(Integer) is not applicable\n      (argument\
    \ mismatch; char cannot be converted to Integer)\n    method AbstractList.add(Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    \    method ArrayList.add(Integer) is not applicable\n      (argument mismatch;\
    \ char cannot be converted to Integer)\n/tmp/tmp29988r84.java:35: error: no suitable\
    \ method found for add(char)\n                level_stack.add(paren_string.charAt(i));\n\
    \                           ^\n    method Collection.add(Integer) is not applicable\n\
    \      (argument mismatch; char cannot be converted to Integer)\n    method List.add(Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    \    method AbstractCollection.add(Integer) is not applicable\n      (argument\
    \ mismatch; char cannot be converted to Integer)\n    method AbstractList.add(Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    \    method ArrayList.add(Integer) is not applicable\n      (argument mismatch;\
    \ char cannot be converted to Integer)\n/tmp/tmp29988r84.java:38: error: incompatible\
    \ types: Integer cannot be converted to String\n                    curr_char\
    \ = level_stack.get(level_stack.size() - 1);\n                               \
    \                ^\n/tmp/tmp29988r84.java:40: error: incompatible types: char\
    \ cannot be converted to String\n                    curr_char = '\\0';\n    \
    \                            ^\n/tmp/tmp29988r84.java:46: error: no suitable method\
    \ found for add(char)\n                        levels.add(paren_string.charAt(i));\n\
    \                              ^\n    method Collection.add(Int"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels\
    \ = new ArrayList<Integer>();\n        int curr_level = 0;\n        for (int i\
    \ = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                curr_level++;\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                curr_level--;\n            }\n            if (curr_level\
    \ > max_levels.size()) {\n                max_levels.add(curr_level);\n      \
    \      } else if (curr_level < max_levels.size()) {\n                max_levels.set(max_levels.size(),\
    \ curr_level);\n            }\n        }\n        return max_levels;\nreturn new\
    \ ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe4lcnnwv.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level_count\
    \ = new ArrayList<>();\n        \n        // A stack of levels of nesting.\n \
    \       ArrayList<Integer> stack = new ArrayList<>();\n        // A stack of parentheses\
    \ opened so far.\n        ArrayList<Character> stack_ptr = new ArrayList<>();\n\
    \        \n        // The parens opened by (), {}, [], [], etc.\n        Map<Character,\
    \ Integer> parens = {\n            '(': -1, '[': -1, '{': -1, '(': -1, '[': -1,\
    \ '{': -1\n        };\n        \n        // Process every character in string.\n\
    \        for (char c : paren_string.toCharArray()) {\n            // Open parentheses.\n\
    \            if (parens.get(c) != -1) {\n                if (stack_ptr.contains(c))\
    \ {\n                    // If there are open () in the stack, pop it.\n     \
    \               stack_ptr.remove(stack.peek());\n                    stack.pop();\n\
    \                } else {\n                    // If there are no open () in the\
    \ stack, push it to the stack.\n                    stack.push(c);\n         \
    \       }\n            } else {\n                // Close parentheses.\n     \
    \           if (stack.size() == 0) {\n                    level_count.add(0);\n\
    \                } else {\n                    // Get current level of nesting.\n\
    \                    int level_num = stack.size();\n                    // Update\
    \ the level count of the parentheses.\n                    parens[stack.get(stack.size()\
    \ - 1)]++;\n                    // Pop from the stack.\n                    stack.pop();\n\
    \                    // Update the level count of the level.\n               \
    \     level_count.set(level_num - 1, level_count.get(level_num - 1) + 1);\n  \
    \              }\n            }\n        }\n        \n        // Pop the stack\
    \ till we reach the root.\n        while (stack.size() != 0) {\n            int\
    \ level_num = stack.size();\n            int level = level_count.get(level_num\
    \ - 1);\n            parens[stack.get(stack.size() - 1)]--;\n            stack.pop(level);\n\
    \        }\n        \n        return level_count;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvpowilcm.java:24: error: '}' expected\n            '(': -1, '[':\
    \ -1, '{': -1, '(': -1, '[': -1, '{': -1\n               ^\n/tmp/tmpvpowilcm.java:24:\
    \ error: not a statement\n            '(': -1, '[': -1, '{': -1, '(': -1, '[':\
    \ -1, '{': -1\n                 ^\n/tmp/tmpvpowilcm.java:24: error: ';' expected\n\
    \            '(': -1, '[': -1, '{': -1, '(': -1, '[': -1, '{': -1\n          \
    \         ^\n/tmp/tmpvpowilcm.java:28: error: illegal start of type\n        for\
    \ (char c : paren_string.toCharArray()) {\n        ^\n/tmp/tmpvpowilcm.java:28:\
    \ error: ')' expected\n        for (char c : paren_string.toCharArray()) {\n \
    \                  ^\n/tmp/tmpvpowilcm.java:28: error: <identifier> expected\n\
    \        for (char c : paren_string.toCharArray()) {\n                       \
    \                       ^\n/tmp/tmpvpowilcm.java:28: error: ';' expected\n   \
    \     for (char c : paren_string.toCharArray()) {\n                          \
    \                      ^\n/tmp/tmpvpowilcm.java:57: error: illegal start of type\n\
    \        while (stack.size() != 0) {\n        ^\n/tmp/tmpvpowilcm.java:57: error:\
    \ <identifier> expected\n        while (stack.size() != 0) {\n               \
    \          ^\n/tmp/tmpvpowilcm.java:57: error: ';' expected\n        while (stack.size()\
    \ != 0) {\n                          ^\n/tmp/tmpvpowilcm.java:57: error: illegal\
    \ start of type\n        while (stack.size() != 0) {\n                       \
    \     ^\n/tmp/tmpvpowilcm.java:57: error: <identifier> expected\n        while\
    \ (stack.size() != 0) {\n                              ^\n/tmp/tmpvpowilcm.java:57:\
    \ error: ';' expected\n        while (stack.size() != 0) {\n                 \
    \               ^\n/tmp/tmpvpowilcm.java:64: error: illegal start of type\n  \
    \      return level_count;\n        ^\n/tmp/tmpvpowilcm.java:64: error: ';' expected\n\
    \        return level_count;\n              ^\n/tmp/tmpvpowilcm.java:65: error:\
    \ illegal start of type\nreturn new ArrayList<Integer>(Arrays.asList());\n^\n\
    /tmp/tmpvpowilcm.java:65: error: ';' expected\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \      ^\n/tmp/tmpvpowilcm.java:65: error: <ide"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Your code here\n      \
    \  ArrayList<Integer> nest_level = new ArrayList<Integer>();\n        int nest_level_count\
    \ = 0;\n        for (char c : paren_string.toCharArray()) {\n            if ((c\
    \ == '(') && (nest_level_count > 0)) {\n                nest_level.add(nest_level_count);\n\
    \                nest_level_count = 0;\n            } else if (c == '(') {\n \
    \               nest_level_count++;\n            } else if (c == ')') {\n    \
    \            nest_level_count--;\n            }\n        }\n        nest_level.add(nest_level_count);\n\
    \        return nest_level;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_gidk86j.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_level\
    \ = new ArrayList<Integer>();\n        // Create an array to store the final answer.\n\
    \        ArrayList<Integer> output = new ArrayList<Integer>();\n        // Keep\
    \ track of the depth of the previous parenthesis.\n        int current_depth =\
    \ 0;\n        // Keep track of the nesting level of each parenthesis.\n      \
    \  ArrayList<Integer> nesting_level = new ArrayList<Integer>();\n        // Convert\
    \ the input string to array using String.split.\n        String[] parens = paren_string.split(\"\
    \ \");\n        // Iterate through each of the input array.\n        for(int i\
    \ = 0; i < parens.length; i++) {\n            // If the character is not a parenthesis,\
    \ add the character to the array.\n            if(parens[i].charAt(0) == '(')\
    \ {\n                nesting_level.add(current_depth);\n            }\n      \
    \      // If the character is a closing parenthesis, increment the depth.\n  \
    \          else if(parens[i].charAt(0) == ')') {\n                current_depth++;\n\
    \            }\n            // If the character is not a closing parenthesis,\
    \ find the deepest level of nesting.\n            else if(parens[i].charAt(0)\
    \ != ')') {\n                nesting_level.remove(nesting_level.size() - 1);\n\
    \                current_depth = 0;\n                nesting_level.add(current_depth);\n\
    \            }\n        }\n        // Add the current depth value to the output\
    \ array if the character is a closing parenthesis.\n        if(current_depth >\
    \ 0) {\n            nesting_level.remove(nesting_level.size() - 1);\n        \
    \    output.add(current_depth);\n        }\n        // Return the output array.\n\
    \        return output;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3_ouodqq.java:48: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<Integer>();\n        boolean first_paren = true;\n        StringTokenizer\
    \ st = new StringTokenizer(paren_string, \" ()\");\n        while (st.hasMoreTokens())\
    \ {\n            String token = st.nextToken();\n            int level_of_nesting\
    \ = token.indexOf('(');\n            if (level_of_nesting > 0) {\n           \
    \     if (first_paren) {\n                    results.add(level_of_nesting);\n\
    \                } else {\n                    if (level_of_nesting > results.last())\
    \ {\n                        results.add(level_of_nesting);\n                \
    \    }\n                }\n            }\n            first_paren = false;\n \
    \       }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4rk0fmmr.java:25: error: cannot find symbol\n                 \
    \   if (level_of_nesting > results.last()) {\n                               \
    \                   ^\n  symbol:   method last()\n  location: variable results\
    \ of type ArrayList<Integer>\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Implement your solution\
    \ here\n        ArrayList<Integer> result = new ArrayList<>();\n        HashMap<String,\
    \ Integer> paren_nesting = new HashMap<>();\n        for (String s : paren_string.trim().split(\"\
    \ \")) {\n            String key = s;\n            int nesting = 0;\n        \
    \    while (paren_nesting.containsKey(key)) {\n                nesting++;\n  \
    \              key = paren_nesting.get(key);\n            }\n            paren_nesting.put(key,\
    \ nesting);\n            if (s.equals(\"(\")) {\n                result.add(nesting);\n\
    \            } else if (s.equals(\")\")) {\n                boolean has_rightmost_unmatched\
    \ = false;\n                for (int j = 0; j < nesting; j++) {\n            \
    \        if (!paren_nesting.containsKey(key + \"(\")) {\n                    \
    \    has_rightmost_unmatched = true;\n                        break;\n       \
    \             }\n                }\n                if (!has_rightmost_unmatched)\
    \ {\n                    result.add(nesting - 1);\n                }\n       \
    \     }\n        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp225flpqz.java:23: error: incompatible types: Integer cannot be\
    \ converted to String\n                key = paren_nesting.get(key);\n       \
    \                                ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int max = 0;\n        int\
    \ level = 1;\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\
    \        List<String> all_parens = paren_string.split(\"\\\\s+\");\n        for\
    \ (String s: all_parens) {\n            if (s.equals(\"(\")) {\n             \
    \   if (level >= max) {\n                    result.add(max);\n              \
    \  }\n                max++;\n                level++;\n            } else if\
    \ (s.equals(\")\")) {\n                if (level >= max) {\n                 \
    \   result.add(max);\n                }\n                level--;\n          \
    \  }\n        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8nss4xt7.java:18: error: incompatible types: String[] cannot be\
    \ converted to List<String>\n        List<String> all_parens = paren_string.split(\"\
    \\\\s+\");\n                                                    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // We use two lists to store\
    \ one level of parentheses and one level of nesting.\n        // If the level\
    \ of nesting is less than the level of parentheses, add parentheses level.\n \
    \       // If the level of nesting is more than the level of parentheses, increase\
    \ the level of nesting.\n        ArrayList<Integer> nesting = new ArrayList<>();\n\
    \        ArrayList<Integer> paren_level = new ArrayList<>();\n\n        // Use\
    \ a stack to store every substring of the string separated by parentheses.\n \
    \       // We only care about parentheses and ignore brackets.\n        Stack<String>\
    \ stack = new Stack<>();\n        for(char c : paren_string.toCharArray())\n \
    \       {\n            if (c == '(') stack.push(c);\n            if (c == ')')\
    \ stack.pop();\n        }\n\n        // Add the nesting level until we encounter\
    \ a closing parentheses.\n        while(!stack.isEmpty())\n        {\n       \
    \     nesting.add(paren_level.size());\n            paren_level.add(paren_level.size());\n\
    \n            char top = stack.pop();\n            char bottom = stack.pop();\n\
    \            if (top == '(') stack.push(bottom);\n            if (bottom == ')')\
    \ stack.pop();\n        }\n\n        return nesting;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp09gpn23.java:26: error: incompatible types: char cannot be converted\
    \ to String\n            if (c == '(') stack.push(c);\n                      \
    \               ^\n/tmp/tmpp09gpn23.java:36: error: incompatible types: String\
    \ cannot be converted to char\n            char top = stack.pop();\n         \
    \                       ^\n/tmp/tmpp09gpn23.java:37: error: incompatible types:\
    \ String cannot be converted to char\n            char bottom = stack.pop();\n\
    \                                   ^\n/tmp/tmpp09gpn23.java:38: error: incompatible\
    \ types: char cannot be converted to String\n            if (top == '(') stack.push(bottom);\n\
    \                                       ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n4 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        stack<Integer> stack = new stack<>();\n      \
    \  for (int i = 0; i < paren_string.length(); i++) {\n            String token\
    \ = paren_string.substring(i, paren_string.length());\n            if (\"(\" ==\
    \ token.charAt(0)) {\n                stack.push(0);\n            }\n        \
    \    else if (\")\" == token.charAt(0)) {\n                result.add(stack.pop());\n\
    \            }\n            else if (\")\" == token.charAt(1)) {\n           \
    \     result.add(stack.pop());\n                result.add(1);\n            }\n\
    \            else if (\")\" == token.charAt(2)) {\n                result.add(stack.pop());\n\
    \                result.add(2);\n            }\n            else if (\")\" ==\
    \ token.charAt(3)) {\n                result.add(stack.pop());\n             \
    \   result.add(3);\n            }\n            else if (\")\" == token.charAt(4))\
    \ {\n                result.add(stack.pop());\n                result.add(4);\n\
    \            }\n            else if (\")\" == token.charAt(5)) {\n           \
    \     result.add(stack.pop());\n                result.add(5);\n            }\n\
    \        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu5rgd1_v.java:16: error: cannot find symbol\n        stack<Integer>\
    \ stack = new stack<>();\n        ^\n  symbol:   class stack\n  location: class\
    \ Problem\n/tmp/tmpu5rgd1_v.java:16: error: cannot find symbol\n        stack<Integer>\
    \ stack = new stack<>();\n                                   ^\n  symbol:   class\
    \ stack\n  location: class Problem\n/tmp/tmpu5rgd1_v.java:19: error: incomparable\
    \ types: String and char\n            if (\"(\" == token.charAt(0)) {\n      \
    \              ^\n/tmp/tmpu5rgd1_v.java:22: error: incomparable types: String\
    \ and char\n            else if (\")\" == token.charAt(0)) {\n               \
    \          ^\n/tmp/tmpu5rgd1_v.java:25: error: incomparable types: String and\
    \ char\n            else if (\")\" == token.charAt(1)) {\n                   \
    \      ^\n/tmp/tmpu5rgd1_v.java:29: error: incomparable types: String and char\n\
    \            else if (\")\" == token.charAt(2)) {\n                         ^\n\
    /tmp/tmpu5rgd1_v.java:33: error: incomparable types: String and char\n       \
    \     else if (\")\" == token.charAt(3)) {\n                         ^\n/tmp/tmpu5rgd1_v.java:37:\
    \ error: incomparable types: String and char\n            else if (\")\" == token.charAt(4))\
    \ {\n                         ^\n/tmp/tmpu5rgd1_v.java:41: error: incomparable\
    \ types: String and char\n            else if (\")\" == token.charAt(5)) {\n \
    \                        ^\n9 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Use a set to get the unique\
    \ nesting level.\n        // The key is the nested parentheses, while the value\
    \ is the\n        // nesting level of the parentheses.\n        Set<String> parens\
    \ = new HashSet<String>();\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\
    \        for(char c : paren_string.toCharArray()) {\n            // Only deal\
    \ with the parentheses.\n            // We assume that the parentheses are in\
    \ pairs.\n            // If they are not, just output the parentheses.\n     \
    \       if (c == '(') parens.add(\"(\" + c);\n            else if (c == ')') parens.add(\"\
    )\" + c);\n            else {\n                // If it is a opening parentheses,\
    \ increment its nesting level.\n                if (parens.contains(c)) {\n  \
    \                  parens.replace(c, (char) ('(' + parens.get(c).charAt(0) + 1));\n\
    \                }\n                // If it is a closing parentheses, decrement\
    \ the nesting level.\n                else {\n                    int depth =\
    \ 0;\n                    while ((c = parens.get(c).charAt(depth)) != ')') {\n\
    \                        depth++;\n                    }\n                   \
    \ parens.replace(c, (char) ('(' + parens.get(c).charAt(0) - depth));\n       \
    \         }\n            }\n        }\n        // Add the maximum nesting level\
    \ to the result.\n        // We assume that the parentheses are in pairs.\n  \
    \      // If they are not, just output the parentheses.\n        // The nesting\
    \ level of the parentheses is actually the sum of the nesting levels of the parentheses\n\
    \        // above it.\n        int max_nesting_level = Integer.MIN_VALUE;\n  \
    \      for (String paren : parens) {\n            max_nesting_level = Math.max(max_nesting_level,\
    \ parseNestedParens(paren).stream().mapToInt(Integer::intValue).sum());\n    \
    \    }\n        result.add(max_nesting_level);\n        return result;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmptn9pnl0b.java:29: error: cannot find symbol\n                 \
    \   parens.replace(c, (char) ('(' + parens.get(c).charAt(0) + 1));\n         \
    \                                                 ^\n  symbol:   method get(char)\n\
    \  location: variable parens of type Set<String>\n/tmp/tmptn9pnl0b.java:29: error:\
    \ cannot find symbol\n                    parens.replace(c, (char) ('(' + parens.get(c).charAt(0)\
    \ + 1));\n                          ^\n  symbol:   method replace(char,char)\n\
    \  location: variable parens of type Set<String>\n/tmp/tmptn9pnl0b.java:34: error:\
    \ cannot find symbol\n                    while ((c = parens.get(c).charAt(depth))\
    \ != ')') {\n                                      ^\n  symbol:   method get(char)\n\
    \  location: variable parens of type Set<String>\n/tmp/tmptn9pnl0b.java:37: error:\
    \ cannot find symbol\n                    parens.replace(c, (char) ('(' + parens.get(c).charAt(0)\
    \ - depth));\n                                                          ^\n  symbol:\
    \   method get(char)\n  location: variable parens of type Set<String>\n/tmp/tmptn9pnl0b.java:37:\
    \ error: cannot find symbol\n                    parens.replace(c, (char) ('('\
    \ + parens.get(c).charAt(0) - depth));\n                          ^\n  symbol:\
    \   method replace(char,char)\n  location: variable parens of type Set<String>\n\
    5 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels_of_nesting\
    \ = new ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \        char[] char_array = paren_string.toCharArray();\n        int length =\
    \ char_array.length;\n        int last_index = 0;\n        for (int i = 0; i <\
    \ length; i++) {\n            if (char_array[i] == '(') {\n                if\
    \ (stack.isEmpty()) {\n                    stack.push(char_array[i]);\n      \
    \          } else if (stack.peek() != '(') {\n                    stack.push(char_array[i]);\n\
    \                }\n            } else if (char_array[i] == ')') {\n         \
    \       if (stack.isEmpty()) {\n                    max_levels_of_nesting.add(i\
    \ - last_index);\n                    stack.push(char_array[i]);\n           \
    \     } else if (stack.peek() == '(') {\n                    max_levels_of_nesting.add(i\
    \ - last_index);\n                    stack.push(char_array[i]);\n           \
    \     }\n            } else if (char_array[i] == ' ') {\n                if (stack.isEmpty())\
    \ {\n                    stack.push(char_array[i]);\n                } else if\
    \ (stack.peek() != '(') {\n                    stack.push(char_array[i]);\n  \
    \              }\n            } else {\n                if (stack.isEmpty()) {\n\
    \                    stack.push(char_array[i]);\n                } else if (stack.peek()\
    \ != '(') {\n                    stack.push(char_array[i]);\n                }\n\
    \            }\n            last_index = i;\n        }\n        return max_levels_of_nesting;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3552bz9w.java:23: error: incompatible types: char cannot be converted\
    \ to Integer\n                    stack.push(char_array[i]);\n               \
    \                          ^\n/tmp/tmp3552bz9w.java:25: error: incompatible types:\
    \ char cannot be converted to Integer\n                    stack.push(char_array[i]);\n\
    \                                         ^\n/tmp/tmp3552bz9w.java:30: error:\
    \ incompatible types: char cannot be converted to Integer\n                  \
    \  stack.push(char_array[i]);\n                                         ^\n/tmp/tmp3552bz9w.java:33:\
    \ error: incompatible types: char cannot be converted to Integer\n           \
    \         stack.push(char_array[i]);\n                                       \
    \  ^\n/tmp/tmp3552bz9w.java:37: error: incompatible types: char cannot be converted\
    \ to Integer\n                    stack.push(char_array[i]);\n               \
    \                          ^\n/tmp/tmp3552bz9w.java:39: error: incompatible types:\
    \ char cannot be converted to Integer\n                    stack.push(char_array[i]);\n\
    \                                         ^\n/tmp/tmp3552bz9w.java:43: error:\
    \ incompatible types: char cannot be converted to Integer\n                  \
    \  stack.push(char_array[i]);\n                                         ^\n/tmp/tmp3552bz9w.java:45:\
    \ error: incompatible types: char cannot be converted to Integer\n           \
    \         stack.push(char_array[i]);\n                                       \
    \  ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n8 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> ret = new\
    \ ArrayList<>();\n        Stack<Integer> stack_of_nesting = new Stack<>();\n \
    \       for(int i = 0; i < paren_string.length(); i++) {\n            char ch\
    \ = paren_string.charAt(i);\n            if(!Character.isWhitespace(ch) && ch\
    \ != '(' && ch != ')') {\n                stack_of_nesting.push(ch);\n       \
    \     } else if(ch == '(') {\n                if(stack_of_nesting.isEmpty()) {\n\
    \                    ret.add(0);\n                } else {\n                 \
    \   int current = stack_of_nesting.pop();\n                    ret.add(current\
    \ + 1);\n                }\n            } else if(ch == ')') {\n             \
    \   while(stack_of_nesting.peek() != '(') {\n                    stack_of_nesting.pop();\n\
    \                }\n                int nest = stack_of_nesting.pop();\n     \
    \           ret.add(nest + 1);\n            }\n        }\n        return ret;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9g9l4s74.java:20: error: incompatible types: char cannot be converted\
    \ to Integer\n                stack_of_nesting.push(ch);\n                   \
    \                   ^\nNote: Some messages have been simplified; recompile with\
    \ -Xdiags:verbose to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_depth\
    \ = new ArrayList<>();\n\n        ArrayList<Integer> parentheses = paren_string.split(\"\
    \\\\s\");\n\n        for (int i = 0; i < parentheses.size(); ++i) {\n        \
    \    if (parentheses.get(i).length() > 0) {\n                ArrayList<Integer>\
    \ sub_depth = parseNestedParens(parentheses.get(i));\n                for (int\
    \ j = 0; j < sub_depth.size(); ++j) {\n                    if (max_depth.size()\
    \ < sub_depth.size()) {\n                        max_depth.add(sub_depth.size());\n\
    \                    }\n                }\n            }\n        }\n\n      \
    \  return max_depth;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi_2vbokm.java:17: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<Integer>\n        ArrayList<Integer> parentheses = paren_string.split(\"\
    \\\\s\");\n                                                           ^\n/tmp/tmpi_2vbokm.java:20:\
    \ error: cannot find symbol\n            if (parentheses.get(i).length() > 0)\
    \ {\n                                  ^\n  symbol:   method length()\n  location:\
    \ class Integer\n/tmp/tmpi_2vbokm.java:21: error: incompatible types: Integer\
    \ cannot be converted to String\n                ArrayList<Integer> sub_depth\
    \ = parseNestedParens(parentheses.get(i));\n                                 \
    \                                               ^\nNote: Some messages have been\
    \ simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        if (paren_string.startsWith(\"\
    (\") || paren_string.startsWith(\"[\")) {\n            return new ArrayList<>();\n\
    \        }\n        ArrayList<Integer> result = new ArrayList<>();\n        boolean\
    \ last_char_was_open = false, last_char_was_close = false;\n        for (char\
    \ c : paren_string.toCharArray()) {\n            if (c == '(') {\n           \
    \     last_char_was_open = true;\n            }\n            if (c == ')') {\n\
    \                last_char_was_close = true;\n            }\n            if (last_char_was_open\
    \ && last_char_was_close) {\n                result.add(c == '(' ? 1 : -1);\n\
    \                last_char_was_close = false;\n                last_char_was_open\
    \ = false;\n            }\n            if (c == '[') {\n                last_char_was_open\
    \ = true;\n            }\n            if (c == ']') {\n                last_char_was_close\
    \ = true;\n            }\n            if (last_char_was_open) {\n            \
    \    result.add(c == '(' ? 1 : -1);\n                last_char_was_open = false;\n\
    \            }\n            if (last_char_was_close) {\n                last_char_was_close\
    \ = false;\n            }\n        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_o9gqbyq.java:47: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level =\
    \ new ArrayList<Integer>();\n        ArrayList<Integer> levels_so_far = new ArrayList<Integer>();\n\
    \        int paren = 0;\n        int depth = 0;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if ((c ==\
    \ '(') || (c == ')')) {\n                if (c == '(') {\n                   \
    \ levels_so_far.add(depth);\n                }\n                depth++;\n   \
    \             level.add(depth);\n                paren = i;\n            } else\
    \ {\n                depth--;\n            }\n        }\n        if (paren > 0)\
    \ {\n            depth--;\n        }\n        for (int i = 0; i < level.size();\
    \ i++) {\n            if (levels_so_far.get(i) > level.get(i)) {\n           \
    \     levels_so_far.set(i, level.get(i));\n            }\n        }\n        return\
    \ levels_so_far;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n   \
    \ public static void main(String[] args) {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp01wyevcz.java:41: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> open_brackets = new\
    \ ArrayList<Integer>();\n        ArrayList<Integer> close_brackets = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> open_parentheses = new ArrayList<Integer>();\n   \
    \     ArrayList<Integer> close_parentheses = new ArrayList<Integer>();\n     \
    \   ArrayList<Integer> paren_opens = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ paren_closes = new ArrayList<Integer>();\n        int max_level = 0;\n     \
    \   int open_count = 1;\n        for (int i=0; i<paren_string.length(); i++) {\n\
    \            char ch = paren_string.charAt(i);\n            if (ch == '(') {\n\
    \                open_brackets.add(open_count);\n                open_parentheses.add(open_count);\n\
    \                paren_opens.add(open_count);\n                open_count++;\n\
    \            }\n            if (ch == ')') {\n                close_brackets.add(open_count);\n\
    \                close_parentheses.add(open_count);\n                paren_closes.add(open_count);\n\
    \                open_count++;\n            }\n            if (ch == '[') {\n\
    \                open_count++;\n            }\n            if (ch == ']') {\n\
    \                close_count++;\n            }\n            if (open_count > 0)\
    \ {\n                if (ch == ')') {\n                    if (close_brackets.get(close_parentheses.size()-1)\
    \ == open_count) {\n                        close_parentheses.remove(close_parentheses.size()-1);\n\
    \                        close_count--;\n                    }\n             \
    \       if (close_brackets.get(close_parentheses.size()-1) == open_count) {\n\
    \                        max_level = Math.max(max_level, close_parentheses.get(close_parentheses.size()-1));\n\
    \                    }\n                }\n                if (ch == ']') {\n\
    \                    if (open_parentheses.get(open_parentheses.size()-1) == open_count)\
    \ {\n                        open_parentheses.remove(open_parentheses.size()-1);\n\
    \                        open_count--;\n                    }\n              \
    \      if (open_parentheses.get(open_parentheses.size()-1) == open_count) {\n\
    \                        max_level = Math.max(max_level, open_parentheses.get(open_parentheses.size()-1));\n\
    \                    }\n                }\n                if (ch == '(') {\n\
    \                    if (close_brackets.get(close_parentheses.size()-1) == open_count)\
    \ {\n                        close_brackets.remove(close_parentheses.size()-1);\n\
    \                        close_count--;\n                    }\n             \
    \       if (close_brackets.get(close_parentheses.size()-1) == open_count) {\n\
    \                        max_level = Math.max(max_level, close_brackets.get(close_parentheses.size()-1));\n\
    \                    }\n                }\n                if (ch == '[') {\n\
    \                    if (open_parentheses.get(open_parentheses.size()-1) == open_count)\
    \ {\n                        open_parentheses.remove(open_parentheses.size()-1);\n\
    \                        open_count--;\n                    }\n              \
    \      if (open_parentheses.get(open_parentheses.size()-1) == open_count) {\n\
    \                        max_level = Math.max(max_level, open_parentheses.get(open_parentheses.size()-1));\n\
    \                    }\n                }\n            }\n        }\n        System.out.println(max_levels);\n\
    \        return max_\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi2983a2p.java:84: error: ';' expected\n        return max_\n  \
    \                 ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Use recursive function\
    \ to find the maximum level of nesting.\n        // To keep track of all levels\
    \ of nesting, use a stack. \n        ArrayList<Integer> levels = new ArrayList<>();\n\
    \        Stack<Integer> stack = new Stack<>();\n        for(char c: paren_string.toCharArray())\
    \ {\n            int level = 0;\n            while(!stack.empty()) {\n       \
    \         level++;\n                stack.pop();\n            }\n            levels.add(level);\n\
    \            switch(c) {\n                case '(':\n                    stack.push(level);\n\
    \                    break;\n                case ')':\n                    int\
    \ level = stack.pop();\n                    if(level > levels.get(levels.size()\
    \ - 1)) {\n                        levels.add(level);\n                    }\n\
    \                    break;\n                default:\n                    stack.push(level);\n\
    \            }\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n\
    \        int max_level = levels.get(levels.size() - 1);\n        for(int level\
    \ = 0; level < levels.size(); level++) {\n            if(level < levels.size()\
    \ - 1 && levels.get(level + 1) - levels.get(level) != max_level) {\n         \
    \       result.add(levels.get(level + 1) + 1);\n            }\n        }\n   \
    \     return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeao4466m.java:31: error: variable level is already defined in method\
    \ parseNestedParens(String)\n                    int level = stack.pop();\n  \
    \                      ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<Integer>();\n        int stack_size = 0;\n        for(int i\
    \ = 0; i < paren_string.length(); i++) {\n            String curr_char = paren_string.substring(i,\
    \ i + 1);\n            if(!paren_string.substring(i, i + 1).equals('(') && !paren_string.substring(i,\
    \ i + 1).equals(')')) {\n                // If the current character is not a\
    \ left or right paren, just add it to the stack\n                stack_size++;\n\
    \            } else {\n                // If the current character is a left or\
    \ right paren, pop from the stack\n                if(paren_string.substring(i,\
    \ i + 1).equals('(')) {\n                    stack_size++;\n                }\
    \ else if (paren_string.substring(i, i + 1).equals(')')) {\n                 \
    \   stack_size--;\n                } else {\n                    // if the current\
    \ character is something other than left or right paren, return error\n      \
    \              System.out.println(\"Error parsing parens\");\n               \
    \     return null;\n                }\n            }\n            if(!stack_size)\
    \ {\n                // If the stack size is zero after processing this character,\
    \ add it to the results list\n                results.add(stack_size);\n     \
    \       }\n        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmnv4kdx5.java:34: error: bad operand type int for unary operator\
    \ '!'\n            if(!stack_size) {\n               ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> ans = new\
    \ ArrayList<Integer>();\n        Stack<Integer> parenStack = new Stack<Integer>();\n\
    \        StringBuilder sb = new StringBuilder(paren_string);\n        boolean\
    \ firstChar = true;\n        while(!parenStack.isEmpty()) {\n            if(parenStack.peek()\
    \ >= paren_string.length())\n                break;\n            char curChar\
    \ = paren_string.charAt(parenStack.peek());\n            if(firstChar) {\n   \
    \             firstChar = false;\n                parenStack.push(0);\n      \
    \      } else if(curChar == ')') {\n                if(parenStack.peek() > 0)\
    \ {\n                    ans.add(parenStack.pop());\n                } else {\n\
    \                    throw new RuntimeException(\"unexpected end of string\");\n\
    \                }\n            } else if(curChar == '(') {\n                parenStack.push(parenStack.peek()\
    \ + 1);\n            } else {\n                throw new RuntimeException(\"unexpected\
    \ char\");\n            }\n        }\n        return ans;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd2pooavt.java:39: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Initialize result array\
    \ and parse string as group by group into it.\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        for(String group: paren_string.split(\"\\\\s+\"\
    )) {\n            // Start new group and recur into it if current group has nested\
    \ parentheses.\n            if(group.length() > 0 && group.indexOf('(') != -1)\
    \ {\n                result.add(parseNestedParens(group));\n            } else\
    \ {\n                // Append level of parentheses to result array (first index\
    \ is 0).\n                result.add(paren_string.indexOf('('));\n           \
    \ }\n        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp16z64nfh.java:20: error: no suitable method found for add(ArrayList<Integer>)\n\
    \                result.add(parseNestedParens(group));\n                     \
    \ ^\n    method Collection.add(Integer) is not applicable\n      (argument mismatch;\
    \ ArrayList<Integer> cannot be converted to Integer)\n    method List.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n    method AbstractCollection.add(Integer) is not applicable\n\
    \      (argument mismatch; ArrayList<Integer> cannot be converted to Integer)\n\
    \    method AbstractList.add(Integer) is not applicable\n      (argument mismatch;\
    \ ArrayList<Integer> cannot be converted to Integer)\n    method ArrayList.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        List<Integer> list = new ArrayList<Integer>();\n\
    \        int i = 0;\n        while (i < paren_string.length()) {\n           \
    \ if (paren_string.charAt(i) == '(') {\n                list.add(0);\n       \
    \         i++;\n            } else if (paren_string.charAt(i) == ')') {\n    \
    \            list.add(list.get(list.size()-1)+1);\n                i++;\n    \
    \        } else {\n                i++;\n            }\n        }\n        return\
    \ list;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdehyxrk5.java:28: error: incompatible types: List<Integer> cannot\
    \ be converted to ArrayList<Integer>\n        return list;\n               ^\n\
    1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \        StringTokenizer st = new StringTokenizer(paren_string);\n        while(st.hasMoreTokens())\
    \ {\n            String token = st.nextToken();\n            if(token.equals(\"\
    (\"))\n                stack.push(new Integer(0));\n            else if(token.equals(\"\
    )\")) {\n                result.add(new Integer(stack.pop()));\n             \
    \   stack.push(new Integer(0));\n            }\n            else if(token.equals(\"\
    )\")) {\n                while(stack.peek() > 0)\n                    result.add(new\
    \ Integer(stack.pop()));\n                result.add(new Integer(stack.pop()));\n\
    \            }\n            else if(token.equals(\"(\")) {\n                while(stack.peek()\
    \ > 0)\n                    stack.push(new Integer(0));\n            }\n     \
    \       else\n                stack.push(new Integer(0));\n        }\n       \
    \ while(!stack.empty()) {\n            result.add(new Integer(stack.pop()));\n\
    \        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4gggjhk1.java:42: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> parens_level\
    \ = \n            Arrays.stream(paren_string.split(\" \"))\n                .map(x\
    \ -> {\n                    Pattern p = Pattern.compile(\"\\\\((\\\\()|(\\\\))|\\\
    \\s(\\\\))\");\n                    Matcher m = p.matcher(x);\n              \
    \      int parens = 0;\n                    while (m.find()) {\n             \
    \           parens = parens + 1;\n                    }\n                    return\
    \ parens;\n                })\n                .filter(x -> x > 0)\n         \
    \       .collect(Collectors.toList());\n        int max_level = Math.max(parens_level);\n\
    \        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int\
    \ i = 0; i < parens_level.size(); i++) {\n            result.add(parens_level[i]);\n\
    \            if (max_level > parens_level[i]) {\n                result.add(max_level\
    \ - parens_level[i]);\n            }\n        }\n        return result;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf1ee2zfl.java:18: error: cannot find symbol\n                 \
    \   Pattern p = Pattern.compile(\"\\\\((\\\\()|(\\\\))|\\\\s(\\\\))\");\n    \
    \                ^\n  symbol:   class Pattern\n  location: class Problem\n/tmp/tmpf1ee2zfl.java:18:\
    \ error: cannot find symbol\n                    Pattern p = Pattern.compile(\"\
    \\\\((\\\\()|(\\\\))|\\\\s(\\\\))\");\n                                ^\n  symbol:\
    \   variable Pattern\n  location: class Problem\n/tmp/tmpf1ee2zfl.java:19: error:\
    \ cannot find symbol\n                    Matcher m = p.matcher(x);\n        \
    \            ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmpf1ee2zfl.java:27:\
    \ error: incompatible types: inference variable R has incompatible bounds\n  \
    \              .collect(Collectors.toList());\n                        ^\n   \
    \ equality constraints: List<Integer>\n    upper bounds: ArrayList<Integer>,Object\n\
    \  where R,A,T are type-variables:\n    R extends Object declared in method <R,A>collect(Collector<?\
    \ super T,A,R>)\n    A extends Object declared in method <R,A>collect(Collector<?\
    \ super T,A,R>)\n    T extends Object declared in interface Stream\n/tmp/tmpf1ee2zfl.java:28:\
    \ error: no suitable method found for max(ArrayList<Integer>)\n        int max_level\
    \ = Math.max(parens_level);\n                            ^\n    method Math.max(int,int)\
    \ is not applicable\n      (actual and formal argument lists differ in length)\n\
    \    method Math.max(long,long) is not applicable\n      (actual and formal argument\
    \ lists differ in length)\n    method Math.max(float,float) is not applicable\n\
    \      (actual and formal argument lists differ in length)\n    method Math.max(double,double)\
    \ is not applicable\n      (actual and formal argument lists differ in length)\n\
    /tmp/tmpf1ee2zfl.java:31: error: array required, but ArrayList<Integer> found\n\
    \            result.add(parens_level[i]);\n                                  \
    \ ^\n/tmp/tmpf1ee2zfl.java:32: error: array required, but ArrayList<Integer> found\n\
    \            if (max_level > parens_level[i]) {\n                            \
    \            ^\n/tmp/tmpf1ee2zfl.java:33: error: array re"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Your code here\n      \
    \  ArrayList<Integer> result = new ArrayList<>();\n        int current_level =\
    \ 0;\n        for(int i=0;i<paren_string.length();i++) {\n            if(paren_string.charAt(i)\
    \ == '(') {\n                current_level++;\n            }\n            else\
    \ if(paren_string.charAt(i) == ')') {\n                current_level--;\n    \
    \        }\n            result.add(current_level);\n        }\n        return\
    \ result;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5hcv4cma.java:28: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        String[] nested_groups = paren_string.split(\"\
    \ \");\n        ArrayList<Integer> max_level_nested_parens = new ArrayList<Integer>();\n\
    \        for (int i = 0, length = nested_groups.length; i < length; i++) {\n \
    \           String group_for_current_level = nested_groups[i];\n            int\
    \ max_level = 0;\n            // If this group has a non-parentheses characters\
    \ at the end, make it a zero\n            boolean last_group_end_with_non_parentheses\
    \ = !group_for_current_level.matches(\"\\\\W\");\n            for(int j = i+1;\
    \ j < length; j++) {\n                String other_group_for_current_level = nested_groups[j];\n\
    \                // If this group has any non-parentheses characters at the end,\
    \ make its level zero and break\n                boolean other_group_end_with_non_parentheses\
    \ = !other_group_for_current_level.matches(\"\\\\W\");\n                if(last_group_end_with_non_parentheses\
    \ && other_group_end_with_non_parentheses){\n                    break;\n    \
    \            } else if(last_group_end_with_non_parentheses && !other_group_end_with_non_parentheses){\n\
    \                    max_level = 0;\n                    break;\n            \
    \    } else if(!last_group_end_with_non_parentheses && other_group_end_with_non_parentheses){\n\
    \                    max_level = 1;\n                    break;\n            \
    \    } else if(last_group_end_with_non_parentheses && other_group_end_with_non_parentheses){\n\
    \                    max_level = 2;\n                    break;\n            \
    \    }\n            }\n            max_level_nested_parens.add(max_level);\n \
    \       }\n        return max_level_nested_parens;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf5etoxff.java:42: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Split string on spaces\
    \ so you can get each group of parentheses\n        String group_str = paren_string.split(\"\
    \ \");\n        List<Integer> groups = new ArrayList<Integer>();\n        // Iterate\
    \ through each group of parentheses.\n        for (int i = 0; i < group_str.length;\
    \ i++) {\n            // Check that the group is a valid parentheses group\n \
    \           int group_level = 0;\n            while (group_str[i] != \")\") {\n\
    \                group_level++;\n                i++;\n            }\n       \
    \     // If group has more than one opening, put it in a separate list and add\
    \ it to the main list\n            if (group_level > 1) {\n                ArrayList<Integer>\
    \ temp_groups = new ArrayList<Integer>();\n                while (i < group_str.length)\
    \ {\n                    if (group_str[i] == \"(\") {\n                      \
    \  temp_groups.add(group_level);\n                        i++;\n             \
    \       }\n                    else {\n                        break;\n      \
    \              }\n                }\n                groups.addAll(temp_groups);\n\
    \            }\n            else {\n                groups.add(group_level);\n\
    \            }\n        }\n        // Return the maximum level of nested parentheses\n\
    \        return groups;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqvm42d88.java:16: error: incompatible types: String[] cannot be\
    \ converted to String\n        String group_str = paren_string.split(\" \");\n\
    \                                             ^\n/tmp/tmpqvm42d88.java:19: error:\
    \ cannot find symbol\n        for (int i = 0; i < group_str.length; i++) {\n \
    \                                    ^\n  symbol:   variable length\n  location:\
    \ variable group_str of type String\n/tmp/tmpqvm42d88.java:22: error: array required,\
    \ but String found\n            while (group_str[i] != \")\") {\n            \
    \                ^\n/tmp/tmpqvm42d88.java:29: error: cannot find symbol\n    \
    \            while (i < group_str.length) {\n                                \
    \    ^\n  symbol:   variable length\n  location: variable group_str of type String\n\
    /tmp/tmpqvm42d88.java:30: error: array required, but String found\n          \
    \          if (group_str[i] == \"(\") {\n                                 ^\n\
    /tmp/tmpqvm42d88.java:45: error: incompatible types: List<Integer> cannot be converted\
    \ to ArrayList<Integer>\n        return groups;\n               ^\n6 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level_of_nestings\
    \ = new ArrayList<Integer>();\n        String[] splits = paren_string.trim().split(\"\
    \\\\s+\");\n        ArrayDeque<String> stack = new ArrayDeque<String>(Arrays.asList(splits));\n\
    \        while (!stack.isEmpty()) {\n            String s = stack.pop();\n   \
    \         int level = level_of_nestings.size();\n            if (s.equals(\"(\"\
    )) {\n                level_of_nestings.add(level);\n            } else if (s.equals(\"\
    )\")) {\n                level_of_nestings.remove(level - 1);\n            } else\
    \ if (s.length() > 0) {\n                stack.push(s);\n            }\n     \
    \   }\n        return level_of_nestings;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyp6jabfg.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        int paren_level = 0;\n        for (int i = 0;\
    \ i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            switch(c) {\n            case '(':\n                if (paren_level\
    \ == 0) {\n                    results.add(1);\n                } else {\n   \
    \                 results.add(paren_level);\n                }\n             \
    \   paren_level++;\n                break;\n            case ')':\n          \
    \      if (paren_level == 1 && paren_level > 0) {\n                    results.add(paren_level);\n\
    \                }\n                paren_level--;\n                break;\n \
    \           }\n        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5z36197f.java:37: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n\n        final String REGEX_STRING = \"\\\\(\\\\(|\\\\\
    )\\\\)\";\n\n        for(int i = 0; i < paren_string.length(); i++) {\n      \
    \      if(paren_string.charAt(i) == '(') {\n                result.add(i);\n \
    \           }\n            else if(paren_string.charAt(i) == ')') {\n        \
    \        if(result.size() > 0) {\n                    int index_of_opening = result.size()\
    \ - 1;\n\n                    while(result.size() > 1 && paren_string.charAt(index_of_opening)\
    \ == '(') {\n                        result.remove(index_of_opening);\n      \
    \                  index_of_opening--;\n                    }\n              \
    \  }\n                result.add(i + 1);\n            }\n        }\n\n       \
    \ return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n   \
    \ public static void main(String[] args) {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi_bc7ksr.java:37: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels\
    \ = new ArrayList<Integer>();\n        Stack<Integer> stack_of_levels = new Stack<Integer>();\n\
    \        int level = 0;\n        for(int i = 0; i < paren_string.length(); i++)\
    \ {\n            if(paren_string.charAt(i) == ')')\n                level--;\n\
    \            else if(paren_string.charAt(i) == '(') {\n                if(stack_of_levels.size()\
    \ <= level) {\n                    stack_of_levels.push(level);\n            \
    \    }\n                level++;\n            } else {\n                if(stack_of_levels.size()\
    \ <= level) {\n                    stack_of_levels.push(level);\n            \
    \    }\n                level--;\n            }\n            if(stack_of_levels.size()\
    \ > max_levels.size()) {\n                max_levels = stack_of_levels;\n    \
    \        }\n        }\n        return max_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxnvlft9d.java:33: error: incompatible types: Stack<Integer> cannot\
    \ be converted to ArrayList<Integer>\n                max_levels = stack_of_levels;\n\
    \                             ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> stack = new ArrayList<Integer>();\n\
    \        String[] arr = paren_string.split(\" \");\n        for(int i=0; i<arr.length;\
    \ i++) {\n            if(\")\".equals(arr[i])) {\n                if(stack.size()\
    \ > 0) {\n                    result.add(stack.size());\n                }\n \
    \               stack.remove(0);\n            } else if(\"(\".length() == arr[i].length())\
    \ {\n                int level_of_nesting = stack.size();\n                while(level_of_nesting\
    \ > 0) {\n                    result.add(level_of_nesting);\n                \
    \    level_of_nesting --;\n                }\n                stack.add(0);\n\
    \            } else {\n                int level_of_nesting = stack.size();\n\
    \                while(level_of_nesting > 0) {\n                    result.add(level_of_nesting);\n\
    \                    level_of_nesting --;\n                }\n               \
    \ stack.add(0);\n                result.add(arr[i].length());\n            }\n\
    \        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpii9nrty3.java:42: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Your code goes here\n \
    \       int paren_count = paren_string.length();\n        ArrayList<Integer> max_level\
    \ = new ArrayList<Integer>();\n        for (int i = 0; i < paren_count; i++) {\n\
    \            int count = 0;\n            int paren_level = paren_string.charAt(i);\n\
    \            if (paren_level == '(') {\n                count++;\n           \
    \ }\n            if (paren_level == ')') {\n                count--;\n       \
    \     }\n            max_level.add(count);\n        }\n        return max_level;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzeqxlke4.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        Map<Character, Integer> paren_counter = new HashMap<>();\n\
    \        for (char c : paren_string.toCharArray()) {\n            if (paren_counter.containsKey(c))\
    \ {\n                paren_counter.put(c, paren_counter.get(c) + 1);\n       \
    \     } else {\n                paren_counter.put(c, 1);\n            }\n    \
    \    }\n        for (Map.Entry<Character, Integer> entry : paren_counter.entrySet())\
    \ {\n            if (entry.getValue() > 1) {\n                for (char d : paren_string.toCharArray())\
    \ {\n                    if (paren_counter.get(d) > 1) {\n                   \
    \     paren_counter.put(d, paren_counter.get(d) - 1);\n                    }\n\
    \                }\n                levels.set(levels.size() - 1, paren_counter.get(entry.getKey()));\n\
    \            }\n        }\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0_oq6y6o.java:35: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<Integer>();\n\n        // Loop through each group of parenthesis.\n\
    \        for(int i = 0; i < paren_string.groupCount(); i++) {\n            //\
    \ If this group of parenthesis has a level of nesting greater than the current\
    \ result array, set the result array to\n            // the current level of nesting\
    \ and add the current group of parenthesis to it.\n            if(paren_string.group(i).groupCount()\
    \ > results.size()) {\n                results.set(results.size(),paren_string.group(i).groupCount());\n\
    \                results.add(paren_string.group(i).start());\n            }\n\
    \        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnkpcgf8r.java:18: error: cannot find symbol\n        for(int i\
    \ = 0; i < paren_string.groupCount(); i++) {\n                               \
    \        ^\n  symbol:   method groupCount()\n  location: variable paren_string\
    \ of type String\n/tmp/tmpnkpcgf8r.java:21: error: cannot find symbol\n      \
    \      if(paren_string.group(i).groupCount() > results.size()) {\n           \
    \                ^\n  symbol:   method group(int)\n  location: variable paren_string\
    \ of type String\n/tmp/tmpnkpcgf8r.java:22: error: cannot find symbol\n      \
    \          results.set(results.size(),paren_string.group(i).groupCount());\n \
    \                                                      ^\n  symbol:   method group(int)\n\
    \  location: variable paren_string of type String\n/tmp/tmpnkpcgf8r.java:23: error:\
    \ cannot find symbol\n                results.add(paren_string.group(i).start());\n\
    \                                        ^\n  symbol:   method group(int)\n  location:\
    \ variable paren_string of type String\n4 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        ArrayList<String> groups = new ArrayList<>();\n\
    \n        for (String s : paren_string.split(\" \")) {\n            if (s.isEmpty())\
    \ {\n                continue;\n            }\n            char first = s.charAt(0);\n\
    \            if (s.charAt(0) == '(') {\n                groups.add(s);\n     \
    \       }\n            if (s.charAt(0) == ')') {\n                int index =\
    \ groups.indexOf(s);\n                levels.add(index - 1);\n               \
    \ groups.remove(index);\n            }\n        }\n        return levels;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp192qgs16.java:33: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nesting_level\
    \ = new ArrayList<>();\n        ArrayList<String> groups = Arrays.asList(paren_string.split(\"\
    \ \"));\n        ArrayList<Integer> parentheses_depth = new ArrayList<>();\n \
    \       int index = 0;\n        for (String group : groups) {\n            parenthesis_depth.add(index,\
    \ groups.indexOf(group) + 1);\n            index++;\n        }\n        for (Integer\
    \ i = 0; i < parenthesis_depth.size(); i++) {\n            if (parentheses_depth.get(i)\
    \ > nesting_level.size())\n                nesting_level.add(i, parentheses_depth.get(i));\n\
    \        }\n        return nesting_level;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdo6nquk9.java:16: error: incompatible types: no instance(s) of\
    \ type variable(s) T exist so that List<T> conforms to ArrayList<String>\n   \
    \     ArrayList<String> groups = Arrays.asList(paren_string.split(\" \"));\n \
    \                                               ^\n  where T is a type-variable:\n\
    \    T extends Object declared in method <T>asList(T...)\n/tmp/tmpdo6nquk9.java:20:\
    \ error: cannot find symbol\n            parenthesis_depth.add(index, groups.indexOf(group)\
    \ + 1);\n            ^\n  symbol:   variable parenthesis_depth\n  location: class\
    \ Problem\n/tmp/tmpdo6nquk9.java:23: error: cannot find symbol\n        for (Integer\
    \ i = 0; i < parenthesis_depth.size(); i++) {\n                              \
    \  ^\n  symbol:   variable parenthesis_depth\n  location: class Problem\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        if (paren_string.isEmpty()) {\n            return\
    \ levels;\n        }\n        String current_string = \"\";\n        int parens_level\
    \ = 0;\n        for (int i = 0; i < paren_string.length(); i++) {\n          \
    \  if (parens_level == 0) {\n                current_string = paren_string.substring(i,\
    \ i + 1);\n            } else if (paren_string.charAt(i) == '(') {\n         \
    \       levels.add(parens_level);\n                parens_level++;\n         \
    \   } else if (paren_string.charAt(i) == ')') {\n                if (parens_level\
    \ == 0) {\n                    levels.add(parens_level);\n                   \
    \ parens_level++;\n                } else {\n                    parens_level--;\n\
    \                }\n            }\n        }\n        return levels;\nreturn new\
    \ ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy4phfg5m.java:37: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int level = 1;\n        ArrayList<Integer>\
    \ results = new ArrayList<>();\n        List<String> input_list = Arrays.asList(paren_string.split(\"\
    \ \"));\n        for (int i = 0; i < input_list.size(); i++) {\n            if\
    \ (input_list.get(i).equals(\"(\")) {\n                results.add(level);\n \
    \           } else if (input_list.get(i).equals(\")\")) {\n                level--;\n\
    \            }\n        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmps437v4bn.java:26: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> paren_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<String> paren_string_list = new\
    \ ArrayList<String>();\n        paren_string = paren_string.toLowerCase();\n \
    \       paren_string = paren_string.replaceAll(\"\\\\(|\\\\)\", \"\");\n     \
    \   String[] parts = paren_string.split(\" \");\n        for (String part : parts)\
    \ {\n            if (part.length() > 0) {\n                if (part.charAt(0)\
    \ == '(') {\n                    if (paren_string_list.size() > 0) {\n       \
    \                 paren_string_list.get(paren_string_list.size()-1).append(\"\
    )\");\n                    }\n                    paren_string_list.add(part);\n\
    \                } else {\n                    if (paren_string_list.size() >\
    \ 0) {\n                        paren_string_list.get(paren_string_list.size()-1).append(\"\
    (\");\n                    }\n                    paren_string_list.add(part);\n\
    \                }\n            }\n        }\n        // Add paren_levels\n  \
    \      int prev_paren_level = 0;\n        ArrayList<Integer> paren_levels_array\
    \ = new ArrayList<Integer>();\n        paren_string_list.forEach(string -> {\n\
    \            paren_levels_array.add(paren_levels.size());\n            prev_paren_level\
    \ = paren_levels.get(paren_levels.size()-1);\n        });\n        for (int i=paren_levels_array.size()-1;\
    \ i>=0; i--) {\n            paren_levels_array.add(i,(paren_levels.get(i) + prev_paren_level));\n\
    \        }\n        paren_levels.addAll(paren_levels_array);\n        return paren_levels;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi6mgfy8_.java:24: error: cannot find symbol\n                 \
    \       paren_string_list.get(paren_string_list.size()-1).append(\")\");\n   \
    \                                                                      ^\n  symbol:\
    \   method append(String)\n  location: class String\n/tmp/tmpi6mgfy8_.java:29:\
    \ error: cannot find symbol\n                        paren_string_list.get(paren_string_list.size()-1).append(\"\
    (\");\n                                                                      \
    \   ^\n  symbol:   method append(String)\n  location: class String\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Create a stack to hold\
    \ the parenthesis\n        Stack<Character> stack = new Stack<>();\n        //\
    \ Create a map to hold the depth for each of the parenthesis\n        Map<Character,\
    \ Integer> max_depth = new HashMap<>();\n\n        // Iterate through the string\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            // Get\
    \ the current char\n            char current_char = paren_string.charAt(i);\n\
    \            // If the stack is not empty and last character is open parenthesis\
    \ then pop the stack\n            // and increment its depth\n            if (!stack.isEmpty()\
    \ && stack.peek() == '(') {\n                max_depth.put('(', (max_depth.get('(')\
    \ == null ? 1 : max_depth.get('(') + 1));\n                stack.pop();\n    \
    \        }\n            // If the stack is not empty and last character is close\
    \ parenthesis then push the stack \n            // and decrement its depth\n \
    \           if (!stack.isEmpty() && stack.peek() == ')') {\n                max_depth.put(')',\
    \ (max_depth.get('(') == null ? 1 : max_depth.get('(') - 1));\n              \
    \  stack.push(')');\n            }\n            // If the stack is not empty and\
    \ last character is space then push it to the stack\n            // and increment\
    \ its depth\n            if (!stack.isEmpty() && stack.peek() == ' ') {\n    \
    \            stack.push(' ');\n                max_depth.put(current_char, (max_depth.get(current_char)\
    \ == null ? 1 : max_depth.get(current_char) + 1));\n            }\n          \
    \  // If the stack is not empty and last character is any character other than\
    \ space, open\n            // parenthesis or close parenthesis then push it to\
    \ the stack\n            if (stack.isEmpty() || !stack.isEmpty() && (current_char\
    \ == ' ' || current_char == '(' || current_char == ')')) {\n                stack.push(current_char);\n\
    \            }\n            // If the stack is empty or last character is not\
    \ space or open parenthesis or close parenthesis \n            // then set the\
    \ current parenthesis depth to 1.\n            if (stack.isEmpty() || !stack.isEmpty()\
    \ && current_char != ' ' && current_char != '(' && current_char !=')') {\n   \
    \             max_depth.put(current_char, 1);\n            }\n        }\n    \
    \    // Iterate through the map and add the depth for each of the parenthesis\n\
    \        ArrayList<Integer> list_of_depths = new ArrayList<>();\n        for (Map.Entry<Character,\
    \ Integer> entry : max_depth.entrySet()) {\n            list_of_depths.add(entry.getValue());\n\
    \        }\n        return list_of_depths;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp43puf9mv.java:59: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        if (paren_string.trim().isEmpty())\
    \ {\n            return new ArrayList<Integer>();\n        }\n        ArrayList<Integer>\
    \ results = new ArrayList<>();\n        ArrayList<String> group_strings = new\
    \ ArrayList<>();\n        // Split the input string into nested parentheses\n\
    \        String[] splited_array = paren_string.split(\" \");\n        for (String\
    \ nested_string: splited_array) {\n            // Get all characters inside nested\
    \ parentheses\n            ArrayList<String> group_strings = nested_string.trim().split(\"\
    \\\\)|\\\\(\");\n            // Add all characters to the group strings array\n\
    \            for (String group_string: group_strings) {\n                if (!group_string.trim().isEmpty())\
    \ {\n                    group_strings.add(group_string);\n                }\n\
    \            }\n            group_strings.trimToSize();\n            // Iterate\
    \ through group strings and find the deepest level of nesting\n            for\
    \ (String group_string: group_strings) {\n                ArrayList<Integer> levels_of_nesting\
    \ = new ArrayList<>();\n                int level = 0;\n                // Iterate\
    \ through characters in the group string\n                for (char c: group_string.toCharArray())\
    \ {\n                    // If this is a new nested level, then increment the\
    \ level by 1\n                    if (c == '(') {\n                        level++;\n\
    \                    }\n                    // If this is a closing parentheses,\
    \ then decrement the level by 1\n                    if (c == ')') {\n       \
    \                 level--;\n                    }\n                    levels_of_nesting.add(level);\n\
    \                }\n                levels_of_nesting.trimToSize();\n        \
    \        // Add the deepest level of nesting to the result array\n           \
    \     for (int level: levels_of_nesting) {\n                    results.add(level);\n\
    \                }\n            }\n        }\n        return results;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3rw_3um4.java:24: error: variable group_strings is already defined\
    \ in method parseNestedParens(String)\n            ArrayList<String> group_strings\
    \ = nested_string.trim().split(\"\\\\)|\\\\(\");\n                           \
    \   ^\n/tmp/tmp3rw_3um4.java:24: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<String>\n            ArrayList<String> group_strings\
    \ = nested_string.trim().split(\"\\\\)|\\\\(\");\n                           \
    \                                             ^\n/tmp/tmp3rw_3um4.java:50: error:\
    \ variable level is already defined in method parseNestedParens(String)\n    \
    \            for (int level: levels_of_nesting) {\n                         ^\n\
    3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        int startIndex = 0;\n        char[] chars\
    \ = paren_string.toCharArray();\n        while (startIndex < chars.length) {\n\
    \            boolean foundOpen = false;\n            boolean foundClose = false;\n\
    \            int openIndex = -1;\n            int closeIndex = -1;\n         \
    \   for (int i = startIndex; i < chars.length; i++) {\n                if (chars[i]\
    \ == '(') {\n                    if (!foundOpen) {\n                        openIndex\
    \ = i;\n                        foundOpen = true;\n                        continue;\n\
    \                    }\n                    levels.add(i - 1);\n             \
    \   }\n                if (chars[i] == ')') {\n                    if (!foundClose)\
    \ {\n                        closeIndex = i;\n                        foundClose\
    \ = true;\n                        continue;\n                    }\n        \
    \            levels.add(i - 1);\n                }\n            }\n          \
    \  if (openIndex >= 0 && closeIndex >= 0) {\n                levels.add(closeIndex\
    \ - 1);\n            }\n            startIndex = closeIndex + 1;\n        }\n\
    \        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7kypxja6.java:47: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        StringBuilder temp_buf = new StringBuilder(paren_string);\n\
    \        char[] paren_chars = paren_string.toCharArray();\n        int open_brackets_cnt\
    \ = 0;\n        // Iterate over all the characters in the input string\n     \
    \   for (int i = 0; i < paren_chars.length; i++) {\n            if (paren_chars[i]\
    \ == '(') {\n                open_brackets_cnt++;\n            } else if (paren_chars[i]\
    \ == ')') {\n                open_brackets_cnt--;\n            }\n           \
    \ // Handle the closing bracket when open_brackets_cnt becomes 0\n           \
    \ if (open_brackets_cnt == 0) {\n                result.add(temp_buf.length());\n\
    \                temp_buf.setLength(0);\n            }\n            temp_buf.append(paren_chars[i]);\n\
    \        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6yt0x8mj.java:34: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int counter = 0;\n       \
    \ ArrayList<Integer> levels = new ArrayList<Integer>();\n        for (String par\
    \ : paren_string.split(\" \")) {\n            counter = 0;\n            while\
    \ (true) {\n                if (paren_string.charAt(counter) == '(')\n       \
    \             counter++;\n                else if (paren_string.charAt(counter)\
    \ == ')')\n                    counter++;\n                else if (paren_string.charAt(counter)\
    \ != '(' && paren_string.charAt(counter) != ')')\n                    break;\n\
    \                else\n                    counter++;\n            }\n       \
    \     levels.add(counter);\n        }\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9pv818v6.java:32: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \        StringTokenizer st = new StringTokenizer(paren_string, \" ()\");\n  \
    \      while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n\
    \            if (token.equals(\"(\")) {\n                stack.push(1);\n    \
    \        } else if (token.equals(\")\")) {\n                int popped_level =\
    \ stack.pop();\n                levels.add(popped_level + 1);\n            }\n\
    \        }\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpabmvsn1o.java:28: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level =\
    \ new ArrayList<>();\n        // find out how many levels of nesting there are\n\
    \        int number_of_levels = paren_string.length() - paren_string.replace(\"\
    (\", \"\").replace(\")\", \"\").length() + 1;\n        // find the level of each\
    \ opening parenthesis\n        ArrayList<Integer> opening_levels = new ArrayList<>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                opening_levels.add(i);\n            }\n        }\n\
    \        ArrayList<Integer> opening_levels_copy = new ArrayList<>(opening_levels);\n\
    \        for (int i = number_of_levels; i < paren_string.length(); i++) {\n  \
    \          if (paren_string.charAt(i) == ')') {\n                opening_levels_copy.remove(i);\n\
    \            }\n        }\n        opening_levels = opening_levels_copy;\n   \
    \     // find out how many closing parenthesis there are for each level\n    \
    \    ArrayList<Integer> closing_levels = new ArrayList<>(opening_levels.size());\n\
    \        for (int i = 0; i < opening_levels.size(); i++) {\n            closing_levels.add(0,\
    \ opening_levels.get(opening_levels.size() - 1 - i));\n        }\n        // find\
    \ the level of each closing parenthesis\n        for (int i = opening_levels.size()\
    \ - 1; i >= 0; i--) {\n            if (paren_string.charAt(paren_string.length()\
    \ - 1 - i) == ')') {\n                closing_levels.add(i);\n            }\n\
    \        }\n        ArrayList<Integer> closing_levels_copy = new ArrayList<>(closing_levels);\n\
    \        // count how many times the closing parenthesis occurs for each level\n\
    \        ArrayList<Integer> closing_counts = new ArrayList<>(closing_levels_copy);\n\
    \        for (int i = 0; i < closing_levels.size(); i++) {\n            closing_counts.set(i,\
    \ closing_counts.get(closing_levels.size() - 1 - i) + 1);\n        }\n       \
    \ // traverse from the outer level and find the max number of levels for each\
    \ parenthesis\n        ArrayList<Integer> max_levels = new ArrayList<>();\n  \
    \      for (int i = 0; i < opening_levels.size(); i++) {\n            int j =\
    \ 0;\n            for (int j = 0; j < closing_levels.size() && j < opening_levels.size()\
    \ - 1; j++) {\n                if (opening_levels.get(i) < closing_levels.get(j))\
    \ {\n                    break;\n                }\n            }\n          \
    \  ArrayList<Integer> level_copy = new ArrayList<>(opening_levels.size());\n \
    \           for (int j = 0; j < level_copy.size(); j++) {\n                level_copy.set(j,\
    \ (opening_levels.get(i) + j));\n            }\n            int level_max = level_copy.size();\n\
    \            if (level_max > max_levels.size()) {\n                max_levels\
    \ = level_copy;\n            }\n        }\n        // traverse from the inner\
    \ level and find the max number of levels for each parenthesis\n        for (int\
    \ i = 0; i < opening_\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxr7moeu8.java:68: error: ';' expected\n        for (int i = 0;\
    \ i < opening_\n                                    ^\n/tmp/tmpxr7moeu8.java:69:\
    \ error: illegal start of expression\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n/tmp/tmpxr7moeu8.java:69: error: ')' expected\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \      ^\n/tmp/tmpxr7moeu8.java:69: error: not a statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \                    ^\n/tmp/tmpxr7moeu8.java:69: error: ';' expected\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n                             ^\n/tmp/tmpxr7moeu8.java:69:\
    \ error: ';' expected\nreturn new ArrayList<Integer>(Arrays.asList());\n     \
    \                                        ^\n6 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<Integer>();\n        int i = 0;\n        // Find all the left\
    \ parenthesis\n        while (i < paren_string.length() && paren_string.charAt(i)\
    \ == '(') {\n            i++;\n        }\n        // Find all the right parenthesis\n\
    \        while (i < paren_string.length() && paren_string.charAt(i) == ')') {\n\
    \            result.add(i);\n            i++;\n        }\n        // Find all\
    \ the right parenthesis\n        while (i < paren_string.length() && paren_string.charAt(i)\
    \ == ')') {\n            i++;\n        }\n        // Add how many right parenthesis\
    \ we've found\n        result.add(paren_string.length());\n        return result;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmphjtydzli.java:33: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        int open_levels = 0;\n        for (char ch: paren_string.toCharArray())\
    \ {\n            if (ch == '(')\n                open_levels++;\n            if\
    \ (ch == ')')\n                open_levels--;\n            if (open_levels ==\
    \ 0)\n                levels.add(levels.size());\n        }\n        return levels;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl0kmwl5t.java:26: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> res = new\
    \ ArrayList<>();\n        ArrayList<String> list = new ArrayList<>();\n      \
    \  int i = 0;\n        int depth = 0;\n        int j = 0;\n        for (char c\
    \ : paren_string.toCharArray()) {\n            if (c == '(') {\n             \
    \   depth++;\n                list.add((\"\" + depth));\n            } else if\
    \ (c == ')') {\n                depth--;\n                list.add((\"\" + depth));\n\
    \            }\n            if (depth == 0 && list.size() > 0) {\n           \
    \     res.add(Integer.parseInt(list.get(list.size() - 1)));\n                depth\
    \ = 0;\n                list.clear();\n            }\n            i++;\n     \
    \   }\n        return res;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm1qyymhq.java:36: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        Matcher matcher = Pattern.compile(\"\\\\\
    (([\\\\w()]+[\\\\w()]*)+\\\\)\").matcher(paren_string);\n        while (matcher.find())\
    \ {\n            String group_of_pars = matcher.group(1);\n            String[]\
    \ pars_array = group_of_pars.split(\"[()]\");\n            int min_par_count =\
    \ Math.min(pars_array.length, levels.size());\n            for (int i = 0; i <\
    \ min_par_count; i++) {\n                if (pars_array[i].equals(pars_array[i\
    \ - 1])) {\n                    levels.add(i + 1);\n                    break;\n\
    \                }\n            }\n        }\n        return levels;\nreturn new\
    \ ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmy_uqv27.java:16: error: cannot find symbol\n        Matcher matcher\
    \ = Pattern.compile(\"\\\\(([\\\\w()]+[\\\\w()]*)+\\\\)\").matcher(paren_string);\n\
    \        ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmpmy_uqv27.java:16:\
    \ error: cannot find symbol\n        Matcher matcher = Pattern.compile(\"\\\\\
    (([\\\\w()]+[\\\\w()]*)+\\\\)\").matcher(paren_string);\n                    \
    \      ^\n  symbol:   variable Pattern\n  location: class Problem\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> list_of_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<String> list_of_groups = new\
    \ ArrayList<String>();\n        String[] string_array = paren_string.split(\"\
    \ \");\n        for (int i = 0; i < string_array.length; i++) {\n            if\
    \ (string_array[i].startsWith(\"(\") || string_array[i].startsWith(\")\") || string_array[i].equals(\"\
    )\")) {\n                list_of_groups.add(string_array[i]);\n            } else\
    \ {\n                list_of_levels.add(string_array[i].length());\n         \
    \   }\n        }\n        List<List<Integer>> list_of_levels_to_levels = new ArrayList<List<Integer>>();\n\
    \        List<String> list_of_groups_to_levels = new ArrayList<String>();\n  \
    \      for (int i = 0; i < list_of_levels.size(); i++) {\n            String group\
    \ = list_of_groups.get(i);\n            int group_level = list_of_levels.get(i);\n\
    \            if (list_of_levels_to_levels.get(list_of_levels.size() - 1) != null)\
    \ {\n                list_of_levels_to_levels.get(list_of_levels.size() - 1).add(group_level);\n\
    \            } else {\n                List<Integer> levels_to_levels = new ArrayList<Integer>();\n\
    \                levels_to_levels.add(group_level);\n                list_of_levels_to_levels.add(levels_to_levels);\n\
    \            }\n            list_of_groups_to_levels.add(group);\n        }\n\
    \        list_of_groups_to_levels.forEach(group -> {\n            List<Integer>\
    \ levels_to_levels = list_of_levels_to_levels.get(list_of_groups_to_levels.indexOf(group));\n\
    \            System.out.println(Arrays.toString(levels_to_levels.toArray()));\n\
    \        });\n        Arrays.sort(list_of_levels_to_levels);\n        return list_of_levels_to_levels;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzvv3pzkz.java:43: error: no suitable method found for sort(List<List<Integer>>)\n\
    \        Arrays.sort(list_of_levels_to_levels);\n              ^\n    method Arrays.sort(int[])\
    \ is not applicable\n      (argument mismatch; List<List<Integer>> cannot be converted\
    \ to int[])\n    method Arrays.sort(long[]) is not applicable\n      (argument\
    \ mismatch; List<List<Integer>> cannot be converted to long[])\n    method Arrays.sort(short[])\
    \ is not applicable\n      (argument mismatch; List<List<Integer>> cannot be converted\
    \ to short[])\n    method Arrays.sort(char[]) is not applicable\n      (argument\
    \ mismatch; List<List<Integer>> cannot be converted to char[])\n    method Arrays.sort(byte[])\
    \ is not applicable\n      (argument mismatch; List<List<Integer>> cannot be converted\
    \ to byte[])\n    method Arrays.sort(float[]) is not applicable\n      (argument\
    \ mismatch; List<List<Integer>> cannot be converted to float[])\n    method Arrays.sort(double[])\
    \ is not applicable\n      (argument mismatch; List<List<Integer>> cannot be converted\
    \ to double[])\n    method Arrays.sort(Object[]) is not applicable\n      (argument\
    \ mismatch; List<List<Integer>> cannot be converted to Object[])\n    method Arrays.<T#1>sort(T#1[],Comparator<?\
    \ super T#1>) is not applicable\n      (cannot infer type-variable(s) T#1\n  \
    \      (actual and formal argument lists differ in length))\n    method Arrays.<T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>) is not applicable\n      (cannot infer type-variable(s) T#2\n  \
    \      (actual and formal argument lists differ in length))\n  where T#1,T#2 are\
    \ type-variables:\n    T#1 extends Object declared in method <T#1>sort(T#1[],Comparator<?\
    \ super T#1>)\n    T#2 extends Object declared in method <T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>)\n/tmp/tmpzvv3pzkz.java:44: error: incompatible types: List<List<Integer>>\
    \ cannot be converted to ArrayList<Integer>\n        return list_of_levels_to_levels;\n\
    \               ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nesting_levels\
    \ = new ArrayList<Integer>();\n        \n        ArrayList<String> strings = Arrays.asList(paren_string.split(\"\
    \ \"));\n        for (String string : strings) {\n            List<String> list_string\
    \ = Arrays.asList(string.split(\"(\"));\n            String opening_par = list_string.get(0).replace(\"\
    )\", \"\");\n            String closing_par = list_string.get(list_string.size()-1);\n\
    \            \n            String opening_par2 = list_string.get(0).replace(\"\
    )\", \"\");\n            String closing_par2 = list_string.get(list_string.size()-1);\n\
    \            String opening_par3 = list_string.get(0).replace(\")\", \"\");\n\
    \            String closing_par3 = list_string.get(list_string.size()-1);\n  \
    \          \n            int opening_par_count = list_string.size() - 1;\n   \
    \         int opening_par2_count = list_string.size() - 1;\n            int opening_par3_count\
    \ = list_string.size() - 1;\n            \n            if (list_string.size()\
    \ > 1){\n                for (int i = 1; i < list_string.size() - 1; i++){\n \
    \                   opening_par_count = opening_par_count + 1;\n             \
    \       opening_par2_count = opening_par2_count + 1;\n                    opening_par3_count\
    \ = opening_par3_count + 1;\n                }\n            }\n            \n\
    \            String str2 = opening_par.trim();\n            \n            int\
    \ new_count = opening_par_count;\n            int new_count2 = opening_par2_count;\n\
    \            int new_count3 = opening_par3_count;\n            \n            if\
    \ (new_count != new_count2 || new_count != new_count3) {\n                if (new_count\
    \ > new_count2 || new_count > new_count3) {\n                    nesting_levels.add(new_count);\n\
    \                    nesting_levels.add(new_count2);\n                    nesting_levels.add(new_count3);\n\
    \                }\n                else if (new_count2 > new_count3) {\n    \
    \                nesting_levels.add(new_count);\n                    nesting_levels.add(new_count2);\n\
    \                    nesting_levels.add(new_count3);\n                }\n    \
    \            else if (new_count3 > new_count) {\n                    nesting_levels.add(new_count);\n\
    \                    nesting_levels.add(new_count2);\n                    nesting_levels.add(new_count3);\n\
    \                }\n            }\n            \n            String str3 = closing_par.trim();\n\
    \            \n            int new_count4 = opening_par_count;\n            int\
    \ new_count5= opening_par2_count;\n            int new_count6= opening_par3_count;\n\
    \            \n            if (new_count4 != new_count5 || new_count4 != new_count6)\
    \ {\n                if (new_count4 > new_\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1iiy3zlk.java:71: error: ')' expected\n                if (new_count4\
    \ > new_\n                                     ^\n/tmp/tmp1iiy3zlk.java:74: error:\
    \ illegal start of expression\n    public static void main(String[] args) {\n\
    \    ^\n/tmp/tmp1iiy3zlk.java:74: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n           ^\n/tmp/tmp1iiy3zlk.java:74: error:\
    \ ';' expected\n    public static void main(String[] args) {\n               \
    \  ^\n/tmp/tmp1iiy3zlk.java:74: error: '.class' expected\n    public static void\
    \ main(String[] args) {\n                                     ^\n/tmp/tmp1iiy3zlk.java:74:\
    \ error: ';' expected\n    public static void main(String[] args) {\n        \
    \                                 ^\n/tmp/tmp1iiy3zlk.java:80: error: reached\
    \ end of file while parsing\n}\n ^\n7 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<String> nesting_strings = new\
    \ ArrayList<String>();\n        ArrayList<Integer> levels = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> nesting_levels = new ArrayList<Integer>();\n     \
    \   ArrayList<String> tokens = new ArrayList<String>();\n        ArrayList<Integer>\
    \ stack = new ArrayList<Integer>();\n        ArrayList<Integer> temp_max_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> temp_nesting_levels\
    \ = new ArrayList<Integer>();\n        boolean in_parantheses = false;\n     \
    \   boolean in_nested_parantheses = false;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            String char_at_i = paren_string.substring(i, i + 1);\n \
    \           if (in_parantheses && char_at_i.equals(\"(\")) {\n               \
    \ nesting_strings.add(char_at_i);\n                nesting_levels.add(nesting_levels.size());\n\
    \                temp_nesting_levels.add(nesting_levels.size() - 1);\n       \
    \         levels.add(nesting_levels.size());\n                in_parantheses =\
    \ false;\n            } else if (in_parantheses && !char_at_i.equals(\"(\")) {\n\
    \                nesting_strings.add(char_at_i);\n                nesting_levels.add(nesting_levels.size());\n\
    \                temp_nesting_levels.add(nesting_levels.size() - 1);\n       \
    \         levels.add(nesting_levels.size());\n                in_parantheses =\
    \ false;\n            } else if (char_at_i.equals(\"(\")) {\n                levels.add(nesting_levels.size());\n\
    \                nesting_levels.add(nesting_levels.size());\n                in_parantheses\
    \ = true;\n            } else if (!char_at_i.equals(\")\")) {\n              \
    \  tokens.add(char_at_i);\n            } else if (char_at_i.equals(\")\")) {\n\
    \                if (nesting_levels.size() == levels.size()) {\n             \
    \       temp_nesting_levels.add(nesting_levels.size() - 1);\n                }\
    \ else {\n                    int current_level = nesting_levels.get(nesting_levels.size()\
    \ - 1);\n                    int expected_level = levels.get(nesting_levels.size()\
    \ - 1);\n                    if (expected_level == current_level) {\n        \
    \                temp_nesting_levels.add(nesting_levels.size() - 1);\n       \
    \             }\n                }\n                nesting_levels.remove(nesting_levels.size()\
    \ - 1);\n            }\n        }\n        for (int i = 1; i < nesting_levels.size();\
    \ i++) {\n            int current_level = nesting_levels.get(nesting_levels.size()\
    \ - i);\n            int expected_level = levels.get(nesting_levels.size() - i);\n\
    \            if (expected_level == current_level) {\n                temp_max_levels.add(current_level);\n\
    \            }\n        }\n        for (int i = 1; i < nesting_levels.size();\
    \ i++) {\n            if (nesting_levels.get(nesting_levels.size() - i) == temp_max_levels.get(0))\
    \ {\n                temp_max_levels.set(temp_max_level\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp61z3fu45.java:67: error: ')' expected\n                temp_max_levels.set(temp_max_level\n\
    \                                                  ^\n/tmp/tmp61z3fu45.java:70:\
    \ error: illegal start of expression\n    public static void main(String[] args)\
    \ {\n    ^\n/tmp/tmp61z3fu45.java:70: error: illegal start of expression\n   \
    \ public static void main(String[] args) {\n           ^\n/tmp/tmp61z3fu45.java:70:\
    \ error: ';' expected\n    public static void main(String[] args) {\n        \
    \         ^\n/tmp/tmp61z3fu45.java:70: error: '.class' expected\n    public static\
    \ void main(String[] args) {\n                                     ^\n/tmp/tmp61z3fu45.java:70:\
    \ error: ';' expected\n    public static void main(String[] args) {\n        \
    \                                 ^\n/tmp/tmp61z3fu45.java:76: error: reached\
    \ end of file while parsing\n}\n ^\n7 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nesting_stack\
    \ = new ArrayList<Integer>();\n\n        StringTokenizer st = new StringTokenizer(paren_string);\n\
    \        String current_paren = null;\n        while (st.hasMoreTokens()) {\n\
    \            String token = st.nextToken();\n            switch(token) {\n   \
    \             case \"(\":\n                    nesting_stack.add(nesting_stack.size());\n\
    \                    current_paren = token;\n                    break;\n    \
    \            case \")\":\n                    nesting_stack.remove(nesting_stack.size()\
    \ - 1);\n                    current_paren = token;\n                    break;\n\
    \            }\n        }\n        return nesting_stack;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwstlquei.java:33: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        String[] parts = paren_string.split(\"\
    \ \");\n        ArrayList<Integer> results = new ArrayList<>();\n        for (String\
    \ part : parts) {\n            results = results.stream()\n                  \
    \  .flatMap(x -> parseNestedParens(x))\n                    .collect(toList());\n\
    \        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpctq3axbk.java:20: error: cannot find symbol\n                 \
    \   .collect(toList());\n                             ^\n  symbol:   method toList()\n\
    \  location: class Problem\n/tmp/tmpctq3axbk.java:19: error: incompatible types:\
    \ Integer cannot be converted to String\n                    .flatMap(x -> parseNestedParens(x))\n\
    \                                                    ^\nNote: Some messages have\
    \ been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        for (int i = 0; i < paren_string.length(); i++)\
    \ {\n            char c = paren_string.charAt(i);\n            if (c == ' ') {\n\
    \                // Ignore whitespace\n                while (i < paren_string.length()\
    \ && paren_string.charAt(i) == ' ')\n                    i++;\n            } else\
    \ if (c == '(') {\n                // Add one level of nesting\n             \
    \   result.add(i);\n            } else if (c == ')') {\n                // Remove\
    \ one level of nesting\n                result.remove(i + 1);\n            } else\
    \ {\n                break;\n            }\n        }\n        return result;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpatfuszqr.java:33: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> temp = new ArrayList<Integer>();\n\
    \n        // Initialize all levels to zero.\n        for(int i = 0; i< levels.size();i++)\
    \ {\n            levels.add(0);\n        }\n\n        // Parse the string and\
    \ add the levels of nesting to levels.\n        for(int i = 1; i<paren_string.length();\
    \ i++) {\n            // Skip spaces.\n            if(paren_string.charAt(i) ==\
    \ ' ') {\n                i++;\n                continue;\n            }\n\n \
    \           // Get the opening paren level.\n            int open_paren_level\
    \ = paren_string.charAt(i) - '0';\n\n            // If the level is zero, then\
    \ ignore it.\n            if(open_paren_level == 0) {\n                i++;\n\
    \                continue;\n            }\n\n            // If the level is greater\
    \ than the maximum level of nesting then ignore it.\n            if(levels.get(open_paren_level)\
    \ > levels.size()) {\n                i++;\n                continue;\n      \
    \      }\n\n            // If the level is less than the minimum level of nesting,\
    \ then ignore it.\n            if(levels.get(open_paren_level) < levels.size())\
    \ {\n                i++;\n                continue;\n            }\n\n      \
    \      // Add the level of nesting to levels at this level.\n            levels.add(open_paren_level);\n\
    \n            // Skip to the next character.\n            i++;\n        }\n\n\
    \        // Get the deepest level of nesting.\n        int deepest_level = levels.get(levels.size()-1);\n\
    \n        // Reverse the array. Because the deepest level is higher than the deepest\
    \ level of nesting from the beginning,\n        // we want to reverse the array\
    \ to get the highest level of nesting from the beginning to lowest.\n        Collections.reverse(levels);\n\
    \n        // Return the array that contains the deepest level of nesting.\n  \
    \      return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmw9odeyg.java:68: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int max_level = 0;\n     \
    \   int max_level_count = 0;\n        ArrayList<Integer> level_array = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> level_count_array = new ArrayList<Integer>();\n  \
    \      ArrayList<Integer> max_level_level_array = new ArrayList<Integer>();\n\n\
    \        // Add max_level and max_level_count to the level_array\n        // and\
    \ level_count_array respectively\n        int level = 0;\n        int level_count\
    \ = 0;\n        for (int i = 0; i < paren_string.length(); i++) {\n          \
    \  char c = paren_string.charAt(i);\n            if ((c == '(') || (c == ')'))\
    \ {\n                // Add 1 to the level counter\n                level_count++;\n\
    \                level_array.add(level);\n                level_count_array.add(level_count);\n\
    \                // If the max level count is greater than the current\n     \
    \           // level count, update the max_level_count with the level\n      \
    \          // count\n                if (level_count > max_level_count) {\n  \
    \                  max_level_count = level_count;\n                    max_level\
    \ = level;\n                }\n            } else {\n                level++;\n\
    \            }\n        }\n\n        // Add max_level and max_level_count to the\
    \ level_array\n        // and level_count_array respectively\n        max_level_level_array.add(max_level);\n\
    \        max_level_level_array.add(max_level_count);\n        return max_level_level_array;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo4ueom1m.java:49: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> ans = new\
    \ ArrayList<Integer>();\n        ArrayList<String> paren_strings = new ArrayList<String>();\n\
    \        paren_strings.add(paren_string);\n        paren_strings.add(paren_string);\n\
    \        int level = 1;\n        while(paren_strings.size() > 0) {\n         \
    \   String s = paren_strings.get(0);\n            paren_strings.remove(0);\n \
    \           int index = paren_strings.indexOf(s);\n            ans.add(level);\n\
    \            level++;\n            if(index == -1) {\n                paren_strings.add(s);\n\
    \                level++;\n                index = paren_strings.indexOf(s);\n\
    \            }\n            for(int i = 1; i < index; i++) {\n               \
    \ String ss = paren_strings.get(i);\n                paren_strings.remove(i);\n\
    \                int index2 = paren_strings.indexOf(ss);\n                for(int\
    \ j = 1; j < (index2 - i); j++) {\n                    ans.add(level);\n     \
    \               level++;\n                }\n                paren_strings.add(ss);\n\
    \                level++;\n            }\n        }\n        return ans;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm8g4gstb.java:44: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Use recursion :)\n    \
    \    return parseNestedParens(paren_string, 0, paren_string.length(), new ArrayList<Integer>());\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp4kypifb.java:16: error: method parseNestedParens in class Problem\
    \ cannot be applied to given types;\n        return parseNestedParens(paren_string,\
    \ 0, paren_string.length(), new ArrayList<Integer>());\n               ^\n  required:\
    \ String\n  found: String,int,int,ArrayList<Integer>\n  reason: actual and formal\
    \ argument lists differ in length\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_level\
    \ = new ArrayList<Integer>();\n        int level = 0;\n        int level_count\
    \ = 0;\n        int i = 0;\n        do {\n            if (i == paren_string.length())\n\
    \                return max_level;\n\n            if (paren_string.charAt(i) ==\
    \ ' ') {\n                level_count++;\n                level++;\n         \
    \   }\n\n            else if (paren_string.charAt(i) == '(') {\n             \
    \   level_count++;\n                level++;\n            }\n\n            else\
    \ if (paren_string.charAt(i) == ')') {\n                level_count--;\n     \
    \           level--;\n            }\n            i++;\n        } while (level_count\
    \ > 0 && level > 0);\n        max_level.add(level);\n        return max_level;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu21yk0hx.java:41: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> paren_list_in_str\
    \ = new ArrayList<Integer>();\n        paren_list_in_str.add(1);\n        int\
    \ depth = 1;\n        int i;\n        for(i=0; i < paren_string.length(); i++){\n\
    \            if(paren_string.charAt(i) == '('){\n                paren_list_in_str.add(depth);\n\
    \                depth++;\n            }\n            else if(paren_string.charAt(i)\
    \ == ')'){\n                if(paren_list_in_str.get(depth - 1) > paren_list_in_str.get(depth)){\n\
    \                    paren_list_in_str.remove(depth - 1);\n                }\n\
    \                depth--;\n            }\n        }\n        return paren_list_in_str;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp80_u8eqz.java:32: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> deepest_level_of_nesting\
    \ = new ArrayList<>();\n\n        for (int i = 0; i < paren_string.length(); i++)\
    \ {\n            char c = paren_string.charAt(i);\n            char next_c = paren_string.charAt(i\
    \ + 1);\n\n            if (c == '(' && next_c == ')') {\n                deepest_level_of_nesting.add(0);\n\
    \                i++;\n            } else {\n                deepest_level_of_nesting.add(deepest_level_of_nesting.size());\n\
    \            }\n        }\n\n        return deepest_level_of_nesting;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbtsr5mm5.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        Stack<Integer> s = new Stack<Integer>();\n\
    \        int level = 0;\n\n        for (int i = 0; i < paren_string.length();\
    \ ++i) {\n            char c = paren_string.charAt(i);\n            if (c == '(')\n\
    \                s.push(-level);\n            if (c == ')')\n                level\
    \ = Math.max(level, s.pop());\n            levels.add(level);\n        }\n   \
    \     return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm0gifqs4.java:28: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nested_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> deepest_levels_of_parens\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> groups = new ArrayList<Integer>();\n\
    \        boolean in_parens = false;\n        int nesting_level = 0;\n\n      \
    \  for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') in_parens = true;\n            if (paren_string.charAt(i) == ')') in_parens\
    \ = false;\n\n            if (in_parens) {\n                nesting_level++;\n\
    \                if (nesting_level == 2) {\n                    nested_levels.add(nesting_level);\n\
    \                }\n\n                if (nesting_level > deepest_levels_of_parens.size())\
    \ {\n                    deepest_levels_of_parens.add(nesting_level);\n      \
    \          }\n            }\n            else {\n                nesting_level--;\n\
    \            }\n\n            if (in_parens && nesting_level == 0) {\n       \
    \         groups.add(groups.size());\n            }\n        }\n\n        for\
    \ (int i = 0; i < deepest_levels_of_parens.size(); i++) {\n            for (int\
    \ j = 0; j < groups.size(); j++) {\n                if (groups.get(j) == deepest_levels_of_parens.get(i))\
    \ {\n                    nested_levels.add(j);\n                    break;\n \
    \               }\n            }\n        }\n\n        return nested_levels;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8jpa5622.java:54: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<Integer>();\n        HashSet<String> set_string = new HashSet<String>();\n\
    \        HashSet<String> set_paren_string = new HashSet<String>();\n        for\
    \ (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            if(c == '(' || c == '[' || c == '{' || c == '<' || c == '>') {\n\
    \                set_string.add(String.valueOf(c));\n                set_paren_string.add(String.valueOf(paren_string.charAt(i)));\n\
    \            } else if(c != ')' && c != ']' && c != '}' && c != '>' && c != '<')\
    \ {\n                set_string.add(String.valueOf(c));\n                set_paren_string.add(String.valueOf(paren_string.charAt(i)));\n\
    \            }\n        }\n        \n        while(set_string.size() > 0 && set_paren_string.size()\
    \ > 0) {\n            String temp = set_string.remove(set_string.size() - 1);\n\
    \            String temp_2 = set_paren_string.remove(set_paren_string.size() -\
    \ 1);\n            if(temp.equalsIgnoreCase(temp_2)) {\n                result.add(Integer.valueOf(temp.charAt(0)));\n\
    \            } else {\n                result.add(Integer.valueOf(temp.charAt(0)));\n\
    \                result.add(Integer.valueOf(temp_2.charAt(0)));\n            }\n\
    \        }\n        \n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk7ni2vxr.java:30: error: incompatible types: boolean cannot be\
    \ converted to String\n            String temp = set_string.remove(set_string.size()\
    \ - 1);\n                                           ^\n/tmp/tmpk7ni2vxr.java:31:\
    \ error: incompatible types: boolean cannot be converted to String\n         \
    \   String temp_2 = set_paren_string.remove(set_paren_string.size() - 1);\n  \
    \                                                 ^\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Convert the string to a\
    \ list to support recursive functions\n        ArrayList<Integer> parens_list\
    \ = Arrays.asList(paren_string.split(\" \"));\n        Arrays.sort(parens_list);\n\
    \        int index = 0;\n        int current_level = parens_list.get(index++);\n\
    \        int max_level = 0;\n        while (index < parens_list.size()) {\n  \
    \          if (parens_list.get(index).equals(current_level)) {\n             \
    \   index++;\n                current_level = parens_list.get(index++);\n    \
    \        } else {\n                // Keep the current level and the max level\n\
    \                if (current_level < max_level) {\n                    max_level\
    \ = current_level;\n                }\n                index++;\n            \
    \    current_level = parens_list.get(index++);\n            }\n        }\n   \
    \     ArrayList<Integer> result = new ArrayList<>();\n        for (int i = 0;\
    \ i <= max_level; i++) {\n            result.add(i);\n        }\n        return\
    \ result;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0vnv3ear.java:16: error: incompatible types: no instance(s) of\
    \ type variable(s) T exist so that List<T> conforms to ArrayList<Integer>\n  \
    \      ArrayList<Integer> parens_list = Arrays.asList(paren_string.split(\" \"\
    ));\n                                                      ^\n  where T is a type-variable:\n\
    \    T extends Object declared in method <T>asList(T...)\n/tmp/tmp0vnv3ear.java:17:\
    \ error: no suitable method found for sort(ArrayList<Integer>)\n        Arrays.sort(parens_list);\n\
    \              ^\n    method Arrays.sort(int[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to int[])\n    method Arrays.sort(long[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to long[])\n    method Arrays.sort(short[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to short[])\n    method Arrays.sort(char[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to char[])\n    method Arrays.sort(byte[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to byte[])\n    method Arrays.sort(float[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to float[])\n    method Arrays.sort(double[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to double[])\n    method Arrays.sort(Object[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Object[])\n    method Arrays.<T#1>sort(T#1[],Comparator<? super T#1>) is\
    \ not applicable\n      (cannot infer type-variable(s) T#1\n        (actual and\
    \ formal argument lists differ in length))\n    method Arrays.<T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>) is not applicable\n      (cannot infer type-variable(s) T#2\n  \
    \      (actual and formal argument lists differ in length))\n  where T#1,T#2 are\
    \ type-variables:\n    T#1 extends Object declared in method <T#1>sort(T#1[],Comparator<?\
    \ super T#1>)\n    T#2 extends Object declared in method <T#2>sor"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        stack<int> paren_stack = new stack<int>();\n \
    \       paren_stack.push(0);\n        for (int i = 0; i < paren_string.length();\
    \ ++i) {\n            int ch = paren_string.charAt(i);\n            if (ch ==\
    \ '(') {\n                while (paren_stack.empty() == false && paren_stack.top()\
    \ >= paren_string.length()) {\n                    --paren_stack.top();\n    \
    \            }\n                paren_stack.push(paren_string.length());\n   \
    \         } else if (ch == ')') {\n                while (paren_stack.empty()\
    \ == false && paren_stack.top() <= 0) {\n                    ++paren_stack.top();\n\
    \                }\n                paren_stack.pop();\n            }\n      \
    \      else if (ch == ' ') {\n                if (paren_stack.empty() == false)\
    \ {\n                    --paren_stack.top();\n                }\n           \
    \ }\n            if (paren_stack.empty() == false)\n                result.add(paren_stack.top());\n\
    \        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdm_2hhn_.java:16: error: cannot find symbol\n        stack<int>\
    \ paren_stack = new stack<int>();\n        ^\n  symbol:   class stack\n  location:\
    \ class Problem\n/tmp/tmpdm_2hhn_.java:16: error: unexpected type\n        stack<int>\
    \ paren_stack = new stack<int>();\n              ^\n  required: reference\n  found:\
    \    int\n/tmp/tmpdm_2hhn_.java:16: error: cannot find symbol\n        stack<int>\
    \ paren_stack = new stack<int>();\n                                     ^\n  symbol:\
    \   class stack\n  location: class Problem\n/tmp/tmpdm_2hhn_.java:16: error: unexpected\
    \ type\n        stack<int> paren_stack = new stack<int>();\n                 \
    \                          ^\n  required: reference\n  found:    int\n4 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_level\
    \ = new ArrayList<Integer>();\n        // We first need a stack of parens.\n \
    \       Stack<String> parens = new Stack<String>();\n        // We will store\
    \ the level of nesting for each parens pushed.\n        ArrayList<Integer> nesting_level\
    \ = new ArrayList<Integer>();\n        // If we have an empty string\n       \
    \ if (paren_string == null || paren_string.length() == 0) {\n            return\
    \ max_level;\n        }\n        String[] tokens = paren_string.split(\" \");\n\
    \        Arrays.stream(tokens)\n                .filter(t -> !t.isEmpty())\n \
    \               .forEach(t -> {\n                    // If there are brackets\
    \ present then we will push them to stack and ignore them.\n                 \
    \   if (t.contains(\"(\") || t.contains(\")\")) {\n                        parens.push(t);\n\
    \                    } else {\n                        nesting_level.add(Integer.parseInt(t));\n\
    \                    }\n                });\n\n        // We will be doing two\
    \ nested loops.\n        for (int i = 0; i < nesting_level.size(); i++) {\n  \
    \          // For every level we will be doing one more nested loop for popping\
    \ the parentheses.\n            for (int j = 0; j < nesting_level.get(i); j++)\
    \ {\n                String temp;\n                // For each parentheses we\
    \ will be doing one more nested loop.\n                for (int k = parens.size();\
    \ k > 0; k--) {\n                    temp = parens.pop();\n                  \
    \  // If we have encountered a parentheses then we will push the string to the\
    \ stack again.\n                    if (temp.contains(\"(\") || temp.contains(\"\
    )\")) {\n                        parens.push(temp);\n                    } else\
    \ {\n                        nesting_level.add(Integer.parseInt(temp));\n    \
    \                }\n                }\n            }\n        }\n\n        nesting_level.remove(nesting_level.size()-1);\n\
    \        // We will add the level of nesting for last parens.\n        max_level.add(nesting_level.get(0));\n\
    \        // For the first level of nesting we will do one more nested loop for\
    \ popping the parentheses.\n        for (int k = 1; k < nesting_level.size();\
    \ k++) {\n            String temp;\n            for (int j = 0; j < nesting_level.get(k);\
    \ j++) {\n                temp = parens.pop();\n                if (temp.contains(\"\
    (\") || temp.contains(\")\")) {\n                    parens.push(temp);\n    \
    \            } else {\n                    nesting_level.add(Integer.parseInt(temp));\n\
    \                }\n            }\n        }\n        return max_level;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg8ehswwz.java:70: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nesting\
    \ = new ArrayList<>();\n        for (String s : paren_string.trim().replaceAll(\"\
    \ +\", \" \").split(\"\\\\(|\\\\)\")) {\n            if (s.contains(\"(\")) {\n\
    \                int depth = parseNestedParens(s).getMax();\n                nesting.add(depth);\n\
    \            }\n        }\n        return nesting;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnyhaqwg0.java:18: error: cannot find symbol\n                int\
    \ depth = parseNestedParens(s).getMax();\n                                   \
    \             ^\n  symbol:   method getMax()\n  location: class ArrayList<Integer>\n\
    1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level_of_nesting\
    \ = new ArrayList<>();\n        if (paren_string.contains(\")\")) {\n        \
    \    level_of_nesting.add(1);\n        }\n        int depth = 1;\n        for\
    \ (int i = paren_string.length() - 1; i >= 0; --i) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                ++level_of_nesting.get(depth);\n            }\n \
    \           if (paren_string.charAt(i) == ')') {\n                if (level_of_nesting.get(depth)\
    \ == 1) {\n                    level_of_nesting.set(depth, 0);\n             \
    \   } else {\n                    --level_of_nesting.get(depth);\n           \
    \     }\n            }\n        }\n        return level_of_nesting;\nreturn new\
    \ ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb707jab4.java:22: error: unexpected type\n                ++level_of_nesting.get(depth);\n\
    \                                      ^\n  required: variable\n  found:    value\n\
    /tmp/tmpb707jab4.java:28: error: unexpected type\n                    --level_of_nesting.get(depth);\n\
    \                                          ^\n  required: variable\n  found: \
    \   value\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        char[] parens = paren_string.toCharArray();\n\
    \        int i = parens.length - 1;\n        while (i > 0) {\n            int\
    \ j = i;\n            while (j < parens.length && parens[j] == ')') {\n      \
    \          j++;\n            }\n            if (j == parens.length) break;\n \
    \           levels.add(parens.length - j);\n            i = j - 1;\n        }\n\
    \        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp04s0ql7k.java:28: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        if (paren_string.trim().isEmpty())\
    \ throw new IllegalArgumentException(\"Bad paren_string: empty string\");\n  \
    \      if (paren_string.trim().length() < 3) throw new IllegalArgumentException(\"\
    Bad paren_string: string too small\");\n        HashMap<Integer, HashMap<Integer,\
    \ Integer>> pairs = new HashMap<>();\n        // for each character in the input\
    \ string\n        for (char c: paren_string.toCharArray()) {\n            int\
    \ depth = 1;\n            if (c == '(') depth++;\n            if (c == ')') depth--;\n\
    \            // if the character is parenthesis, increment or decrement depth\n\
    \            if (depth > 0) {\n                Integer current_depth = pairs.getOrDefault(depth,\
    \ new HashMap<>());\n                current_depth.put(c, 1);\n              \
    \  pairs.put(depth, current_depth);\n            } else {\n                if\
    \ (pairs.containsKey(depth)) {\n                    Integer current_depth = pairs.get(depth);\n\
    \                    Integer current_count = current_depth.get(c);\n         \
    \           if (current_count == null) current_count = 0;\n                  \
    \  current_depth.put(c, current_count + 1);\n                }\n            }\n\
    \        }\n        // Find the max depth of nesting in the parenthesis.\n   \
    \     Integer max_depth = -1;\n        for (Map.Entry<Integer, Map<Integer, Integer>>\
    \ entry : pairs.entrySet()) {\n            if (entry.getValue().size() > max_depth)\
    \ max_depth = entry.getKey();\n        }\n        // Create a list with each element\
    \ of the maximum depth map.\n        ArrayList<Integer> results = new ArrayList<>();\n\
    \        for (Map.Entry<Integer, Map<Integer, Integer>> entry : pairs.entrySet())\
    \ {\n            if (max_depth == entry.getKey()) results.add(entry.getValue().size());\n\
    \        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdoqm3wbs.java:25: error: incompatible types: HashMap<Integer,Integer>\
    \ cannot be converted to Integer\n                Integer current_depth = pairs.getOrDefault(depth,\
    \ new HashMap<>());\n                                                        \
    \  ^\n/tmp/tmpdoqm3wbs.java:26: error: cannot find symbol\n                current_depth.put(c,\
    \ 1);\n                             ^\n  symbol:   method put(char,int)\n  location:\
    \ variable current_depth of type Integer\n/tmp/tmpdoqm3wbs.java:27: error: no\
    \ suitable method found for put(int,Integer)\n                pairs.put(depth,\
    \ current_depth);\n                     ^\n    method Map.put(Integer,HashMap<Integer,Integer>)\
    \ is not applicable\n      (argument mismatch; Integer cannot be converted to\
    \ HashMap<Integer,Integer>)\n    method AbstractMap.put(Integer,HashMap<Integer,Integer>)\
    \ is not applicable\n      (argument mismatch; Integer cannot be converted to\
    \ HashMap<Integer,Integer>)\n    method HashMap.put(Integer,HashMap<Integer,Integer>)\
    \ is not applicable\n      (argument mismatch; Integer cannot be converted to\
    \ HashMap<Integer,Integer>)\n/tmp/tmpdoqm3wbs.java:30: error: incompatible types:\
    \ HashMap<Integer,Integer> cannot be converted to Integer\n                  \
    \  Integer current_depth = pairs.get(depth);\n                               \
    \                      ^\n/tmp/tmpdoqm3wbs.java:31: error: cannot find symbol\n\
    \                    Integer current_count = current_depth.get(c);\n         \
    \                                                ^\n  symbol:   method get(char)\n\
    \  location: variable current_depth of type Integer\n/tmp/tmpdoqm3wbs.java:33:\
    \ error: cannot find symbol\n                    current_depth.put(c, current_count\
    \ + 1);\n                                 ^\n  symbol:   method put(char,int)\n\
    \  location: variable current_depth of type Integer\n/tmp/tmpdoqm3wbs.java:39:\
    \ error: incompatible types: Entry<Integer,HashMap<Integer,Integer>> cannot be\
    \ converted to Entry<Integer,Map<Integer,Integer>>\n        for (Map.Entry<Integer,\
    \ Map<Integer, Integer>> entry : pairs.entrySet()) {\n            "
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        if (paren_string.length()\
    \ == 0) return new ArrayList<Integer>(0);\n\n        List<Integer> nesting_levels\
    \ = new ArrayList<>();\n\n        // We use the string builder to build each level.\n\
    \        StringBuilder builder_level = new StringBuilder();\n        StringBuilder\
    \ builder_current = new StringBuilder();\n\n        // We use the stack to track\
    \ the nested levels\n        Deque<Integer> stack_current = new ArrayDeque<>();\n\
    \n        // The string builder with the previous level is used as\n        //\
    \ the parent level\n        stack_current.add(0);\n        builder_level.append(paren_string);\n\
    \n        // While the builder level is not empty\n        while (builder_level.length()\
    \ != 0) {\n\n            // If the builder has already been built\n          \
    \  if (builder_current.length() != 0) {\n\n                // Remove the left\
    \ parenthesis off the builder level\n                builder_level.remove(0);\n\
    \                builder_current.remove();\n\n                // If the builder\
    \ level is not empty\n                if (builder_level.length() != 0) {\n   \
    \                 int levels_to_add = stack_current.size();\n                \
    \    int nest_level = builder_level.length() - builder_current.length();\n   \
    \                 int stack_top = stack_current.size() - 1;\n\n              \
    \      // If the level to add is less than the stack top\n                   \
    \ // then add the level\n                    if (levels_to_add < stack_top) {\n\
    \                        stack_current.add(nest_level);\n                    }\
    \ else {\n                        // Else remove the level and add it to the stack\n\
    \                        stack_current.remove(stack_top);\n                  \
    \      stack_current.add(nest_level);\n                    }\n               \
    \ }\n            }\n\n            // If the builder level is not empty\n     \
    \       if (builder_level.length() != 0) {\n                int levels_to_add\
    \ = stack_current.size();\n                int nest_level = builder_level.length()\
    \ - builder_current.length();\n                int stack_top = stack_current.size()\
    \ - 1;\n\n                // If the level to add is less than the stack top\n\
    \                // then add the level\n                if (levels_to_add < stack_top)\
    \ {\n                    stack_current.add(nest_level);\n                } else\
    \ {\n                    // Else remove the level and add it to the stack\n  \
    \                  stack_current.remove(stack_top);\n                    stack_current.add(nest_level);\n\
    \                }\n            }\n\n            // We add the level to the nest\
    \ levels list\n            nesting_levels.add(stack_current.size());\n       \
    \ }\n\n        return nesting_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmz3b1j57.java:38: error: cannot find symbol\n                builder_level.remove(0);\n\
    \                             ^\n  symbol:   method remove(int)\n  location: variable\
    \ builder_level of type StringBuilder\n/tmp/tmpmz3b1j57.java:39: error: cannot\
    \ find symbol\n                builder_current.remove();\n                   \
    \            ^\n  symbol:   method remove()\n  location: variable builder_current\
    \ of type StringBuilder\n/tmp/tmpmz3b1j57.java:80: error: incompatible types:\
    \ List<Integer> cannot be converted to ArrayList<Integer>\n        return nesting_levels;\n\
    \               ^\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level_of_nesting\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> nested_parens_index\
    \ = new ArrayList<Integer>();\n        ArrayList<String> paren_strings = new ArrayList<String>();\n\
    \n        int index = 0;\n        while (index < paren_string.length()) {\n  \
    \          paren_strings.add(paren_string.substring(index, index + 1));\n    \
    \        index = paren_string.indexOf('(', index + 1);\n        }\n\n        for\
    \ (String s : paren_strings) {\n            paren_string = paren_string.replaceAll(s,\
    \ \"\");\n            paren_string = paren_string.replaceAll(\"\\\\(\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\)\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\[\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\]\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\{\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\}\"\
    , \"\");\n            paren_string = paren_string.replaceAll(\"\\\\,\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\|\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\!\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\<\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\>\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\+\"\
    , \"\");\n            paren_string = paren_string.replaceAll(\"\\\\*\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\-\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\/\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\?\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\;\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\^\"\
    , \"\");\n            paren_string = paren_string.replaceAll(\"\\\\~\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\=\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\!\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\.\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\.\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\*\"\
    , \"\");\n            paren_string = paren_string.replaceAll(\"\\\\+\", \"\");\n\
    \            paren_string = paren_string.replaceAll(\"\\\\(\", \"\");\n      \
    \      paren_string = paren_string.replaceAll(\"\\\\)\", \"\");\n            paren_string\
    \ = paren_string.replaceAll(\"\\\\[\", \"\");\n            paren_string = paren_string.replaceAll(\"\
    \\\\]\", \"\");\n            paren_string = paren_string.replaceAll(\"\\\\{\"\
    , \"\");\n            paren_string\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn0mvsp1z.java:57: error: not a statement\n            paren_string\n\
    \            ^\n/tmp/tmpn0mvsp1z.java:57: error: ';' expected\n            paren_string\n\
    \                        ^\n/tmp/tmpn0mvsp1z.java:60: error: illegal start of\
    \ expression\n    public static void main(String[] args) {\n    ^\n/tmp/tmpn0mvsp1z.java:60:\
    \ error: illegal start of expression\n    public static void main(String[] args)\
    \ {\n           ^\n/tmp/tmpn0mvsp1z.java:60: error: ';' expected\n    public static\
    \ void main(String[] args) {\n                 ^\n/tmp/tmpn0mvsp1z.java:60: error:\
    \ '.class' expected\n    public static void main(String[] args) {\n          \
    \                           ^\n/tmp/tmpn0mvsp1z.java:60: error: ';' expected\n\
    \    public static void main(String[] args) {\n                              \
    \           ^\n/tmp/tmpn0mvsp1z.java:66: error: reached end of file while parsing\n\
    }\n ^\n8 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \n        // Traverse the input string level by level\n        for(int i = 0;\
    \ i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \n            // If open parenthesis, push it to stack\n            if(c == '(')\
    \ {\n                stack.add(i);\n            }\n\n            // If close parenthesis,\
    \ pop levels to array\n            if(c == ')') {\n                while(!stack.isEmpty())\
    \ {\n                    levels.add(stack.pop());\n                }\n       \
    \         stack = new Stack<Integer>();\n            }\n\n            // If comma\
    \ or closing bracket and stack is not empty\n            if(c != ',' && c != ')'\
    \ && !stack.isEmpty()) {\n                stack.add(i);\n            }\n     \
    \   }\n\n        // Pop levels to array\n        while(!stack.isEmpty()) {\n \
    \           levels.add(stack.pop());\n        }\n\n        return levels;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp96mtl4ay.java:47: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level_of_nesting\
    \ = new ArrayList<>();\n        if (paren_string.length() == 0 || paren_string.equals(\"\
    ()\")) level_of_nesting.add(0);\n        else {\n            int opening_level\
    \ = 0;\n            int index = paren_string.indexOf(\"(\");\n            while\
    \ (index >= 0) {\n                int close_paren = paren_string.indexOf(\")\"\
    , index);\n                if (close_paren < 0) close_paren = paren_string.length();\n\
    \                level_of_nesting.add(close_paren - opening_level);\n        \
    \        opening_level = close_paren + 1;\n                index = paren_string.indexOf(\"\
    (\", close_paren + 1);\n            }\n        }\n        return level_of_nesting;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7jimi60r.java:29: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_nesting_levels\
    \ = new ArrayList<Integer>();\n        for (String nested_parens: split(paren_string,\
    \ \" \")) {\n            String nested_parens_without_spaces = nested_parens.replaceAll(\"\
    \\\\s\", \"\");\n            if (nested_parens_without_spaces.equals(\"()\"))\
    \ {\n                ArrayList <Integer> temp_arraylist = new ArrayList <Integer>();\n\
    \                temp_arraylist.add(0);\n                temp_arraylist.add(0);\n\
    \                temp_arraylist.add(0);\n                max_nesting_levels.add(temp_arraylist);\n\
    \                continue;\n            }\n            ArrayList<Integer> temp\
    \ = new ArrayList <Integer>();\n            for (int i = 0; i < nested_parens_without_spaces.length();\
    \ i++) {\n                String character = nested_parens_without_spaces.charAt(i);\n\
    \                if (Character.isAlphabetic(character)) {\n                  \
    \  int char_int = Character.getNumericValue(character);\n                    if\
    \ (char_int != 0 && char_int <= 25) {\n                        temp.add (char_int\
    \ - 1);\n                    } else {\n                        break;\n      \
    \              }\n                } else {\n                    break;\n     \
    \           }\n            }\n            if (temp.size() > 0) {\n           \
    \     ArrayList<Integer> temp_arraylist = new ArrayList <Integer>();\n       \
    \         temp_arraylist.add(0);\n                temp_arraylist.add(0);\n   \
    \             temp_arraylist.add(0);\n                max_nesting_levels.add(temp_arraylist);\n\
    \            }\n        }\n        return max_nesting_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9gmees9u.java:16: error: cannot find symbol\n        for (String\
    \ nested_parens: split(paren_string, \" \")) {\n                             \
    \      ^\n  symbol:   method split(String,String)\n  location: class Problem\n\
    /tmp/tmp9gmees9u.java:23: error: no suitable method found for add(ArrayList<Integer>)\n\
    \                max_nesting_levels.add(temp_arraylist);\n                   \
    \               ^\n    method Collection.add(Integer) is not applicable\n    \
    \  (argument mismatch; ArrayList<Integer> cannot be converted to Integer)\n  \
    \  method List.add(Integer) is not applicable\n      (argument mismatch; ArrayList<Integer>\
    \ cannot be converted to Integer)\n    method AbstractCollection.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n    method AbstractList.add(Integer) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to Integer)\n    method ArrayList.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n/tmp/tmp9gmees9u.java:28: error: incompatible types: char cannot\
    \ be converted to String\n                String character = nested_parens_without_spaces.charAt(i);\n\
    \                                                                      ^\n/tmp/tmp9gmees9u.java:29:\
    \ error: incompatible types: String cannot be converted to int\n             \
    \   if (Character.isAlphabetic(character)) {\n                               \
    \            ^\n/tmp/tmp9gmees9u.java:30: error: no suitable method found for\
    \ getNumericValue(String)\n                    int char_int = Character.getNumericValue(character);\n\
    \                                            ^\n    method Character.getNumericValue(char)\
    \ is not applicable\n      (argument mismatch; String cannot be converted to char)\n\
    \    method Character.getNumericValue(int) is not applicable\n      (argument\
    \ mismatch; String cannot be converted to int)\n/tmp/tmp9gmees9u.java:45: error:\
    \ no suitable method found for add(ArrayList<Integer>)\n                max_nesting_levels.add(t"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n       \
    \ for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                stack.push(paren_string.charAt(i));\n           \
    \ } else if (paren_string.charAt(i) == ')') {\n                int depth = stack.pop();\n\
    \                results.add(depth);\n            }\n        }\n        return\
    \ results;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9hc3x8wy.java:19: error: incompatible types: char cannot be converted\
    \ to String\n                stack.push(paren_string.charAt(i));\n           \
    \                                   ^\n/tmp/tmp9hc3x8wy.java:21: error: incompatible\
    \ types: String cannot be converted to int\n                int depth = stack.pop();\n\
    \                                     ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        for(int i = 0; i < paren_string.length(); i++)\
    \ {\n            char c = paren_string.charAt(i);\n            // if the char\
    \ is an opening paren\n            if (c == '(') {\n                if (levels.size()\
    \ <= 0) {\n                    levels.add(0);\n                }\n           \
    \     levels.add(levels.get(levels.size() - 1) + 1);\n            }\n        \
    \    // if the char is a closing paren\n            else if (c == ')') {\n   \
    \             int prev_level = levels.get(levels.size() - 1);\n              \
    \  levels.set(levels.size() - 1, prev_level - 1);\n            }\n        }\n\
    \        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqtup5ppf.java:32: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // TODO: Make this work\n\
    \        // Create a Stack for keeping track of nested levels\n        Stack<Integer>\
    \ level_stack = new Stack<Integer>();\n\n        // Remember the deepest level\n\
    \        level_stack.push(0);\n\n        // Push the current level\n        level_stack.push(0);\n\
    \n        // Parse until no more nested parenthesis\n        while (level_stack.size()\
    \ > 0) {\n            // Pop the top level from the stack\n            int level\
    \ = level_stack.pop();\n            // Pop all possible levels until the desired\
    \ level is met\n            while (level_stack.size() > level) {\n           \
    \     level_stack.pop();\n            }\n            // If the level isn't met\
    \ yet, push the level to the stack\n            if (level_stack.size() < level)\
    \ {\n                level_stack.push(level);\n            }\n        }\n\n  \
    \      // Return the stack elements\n        return new ArrayList<Integer>(level_stack);\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5nvzgunl.java:41: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        // Convert strings to lists of integers by splitting\
    \ on spaces.\n        ArrayList<Integer> list1 = new ArrayList<>();\n        ArrayList<Integer>\
    \ list2 = new ArrayList<>();\n        for (String s : paren_string.split(\" \"\
    )) {\n            if (s.equals(\"(\")) {\n                list1.add(0);\n    \
    \        } else if (s.equals(\")\")) {\n                list2.add(0);\n      \
    \      } else if (s.equals(\"(\")) {\n                list1.add(1);\n        \
    \    } else if (s.equals(\")\")) {\n                list2.add(1);\n          \
    \  } else {\n                int first = Integer.valueOf(s.substring(0, 1));\n\
    \                int second = Integer.valueOf(s.substring(1, s.length() - 1));\n\
    \                list1.add(first);\n                list2.add(second);\n     \
    \       }\n        }\n        // Find deepest level of nesting.\n        int maxLevel\
    \ = 0;\n        for (int i = 0; i < list1.size(); i++) {\n            if (list1.get(i)\
    \ > list2.get(i)) {\n                maxLevel = list1.get(i);\n            }\n\
    \        }\n        // Add levels to return list.\n        for (int i = 0; i <\
    \ list1.size(); i++) {\n            if (list1.get(i) > maxLevel) {\n         \
    \       levels.add(maxLevel);\n            }\n            if (list1.get(i) ==\
    \ maxLevel) {\n                if (i == list1.size() - 1) {\n                \
    \    levels.add(list2.get(i));\n                } else {\n                   \
    \ levels.add(list1.get(i));\n                }\n            }\n        }\n   \
    \     return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkdgqnu4t.java:56: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int depth = 0;\n        ArrayList<Integer>\
    \ out = new ArrayList<Integer>();\n        for (String substring : paren_string.split(\"\
    \ \")) {\n            if (substring.equals(\"(\")) {\n                depth++;\n\
    \            } else if (substring.equals(\")\")) {\n                depth--;\n\
    \            }\n            out.add(depth);\n        }\n        return out;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmph27yeugj.java:26: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nested_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> stack = new ArrayList<Integer>();\n\
    \        for(int i = 0; i < paren_string.length(); i++) {\n            char c\
    \ = paren_string.charAt(i);\n            if (c == '(') stack.push(i);\n      \
    \      else if (c == ')') {\n                int top = stack.get(stack.size()-1);\n\
    \                nested_levels.add(i - top);\n                stack.remove(stack.size()-1);\n\
    \            }\n        }\n        return nested_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg1wgp5pg.java:19: error: cannot find symbol\n            if (c\
    \ == '(') stack.push(i);\n                               ^\n  symbol:   method\
    \ push(int)\n  location: variable stack of type ArrayList<Integer>\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int count = new ArrayList<Integer>();\n\
    \        for(int i = 0; i < paren_string.length(); i++) {\n            char c\
    \ = paren_string.charAt(i);\n            if(c == '(')\n                count.add(i);\n\
    \            else if (c == ')') {\n                count.remove(count.size() -\
    \ 1);\n                count.add(i - count.size());\n            }\n        }\n\
    \        for(int i = 0; i < count.size(); i++) {\n            int j = count.size()\
    \ - i - 1;\n            int k = count.size() - i - 1;\n            int max = Integer.MIN_VALUE;\n\
    \            for(int k = j; k < count.size(); k++) {\n                for(int\
    \ l = k; l < count.size(); l++) {\n                    if(count.get(k) == count.get(l))\
    \ {\n                        max = Math.max(max, k - j);\n                   \
    \ }\n                }\n            }\n            count.set(i, max);\n      \
    \  }\n        return count;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmprk615zxv.java:15: error: incompatible types: ArrayList<Integer>\
    \ cannot be converted to int\n        int count = new ArrayList<Integer>();\n\
    \                    ^\n/tmp/tmprk615zxv.java:19: error: int cannot be dereferenced\n\
    \                count.add(i);\n                     ^\n/tmp/tmprk615zxv.java:21:\
    \ error: int cannot be dereferenced\n                count.remove(count.size()\
    \ - 1);\n                                  ^\n/tmp/tmprk615zxv.java:21: error:\
    \ int cannot be dereferenced\n                count.remove(count.size() - 1);\n\
    \                     ^\n/tmp/tmprk615zxv.java:22: error: int cannot be dereferenced\n\
    \                count.add(i - count.size());\n                              \
    \     ^\n/tmp/tmprk615zxv.java:22: error: int cannot be dereferenced\n       \
    \         count.add(i - count.size());\n                     ^\n/tmp/tmprk615zxv.java:25:\
    \ error: int cannot be dereferenced\n        for(int i = 0; i < count.size();\
    \ i++) {\n                                ^\n/tmp/tmprk615zxv.java:26: error:\
    \ int cannot be dereferenced\n            int j = count.size() - i - 1;\n    \
    \                     ^\n/tmp/tmprk615zxv.java:27: error: int cannot be dereferenced\n\
    \            int k = count.size() - i - 1;\n                         ^\n/tmp/tmprk615zxv.java:29:\
    \ error: variable k is already defined in method parseNestedParens(String)\n \
    \           for(int k = j; k < count.size(); k++) {\n                    ^\n/tmp/tmprk615zxv.java:29:\
    \ error: int cannot be dereferenced\n            for(int k = j; k < count.size();\
    \ k++) {\n                                    ^\n/tmp/tmprk615zxv.java:30: error:\
    \ int cannot be dereferenced\n                for(int l = k; l < count.size();\
    \ l++) {\n                                        ^\n/tmp/tmprk615zxv.java:31:\
    \ error: int cannot be dereferenced\n                    if(count.get(k) == count.get(l))\
    \ {\n                            ^\n/tmp/tmprk615zxv.java:31: error: int cannot\
    \ be dereferenced\n                    if(count.get(k) == count.get(l)) {\n  \
    \                                          ^\n/tmp/tmprk615zxv.java:36: error:\
    \ int"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n\n        // This stores indexes of levels we encounter\
    \ with parentheses.\n        int paren_index = 0;\n        // This is an index\
    \ where we store the last parenthesis found.\n        int last_paren_index = 0;\n\
    \        // This is an index where we store where the next pair of parentheses\
    \ begins.\n        int next_index = 0;\n\n        int i;\n\n        for (i = 0;\
    \ ; i++) {\n            if (paren_string.charAt(i) == '(') {\n               \
    \ if (paren_index == 0) {\n                    levels.add(0);\n              \
    \  }\n                levels.add(levels.get(paren_index) - 1);\n             \
    \   paren_index++;\n            }\n            if (paren_string.charAt(i) == ')')\
    \ {\n                levels.add(levels.get(paren_index) + 1);\n              \
    \  paren_index--;\n            }\n            if (paren_index == 0) {\n      \
    \          last_paren_index = i;\n                break;\n            }\n    \
    \    }\n\n        // Now that we have parsed all the parentheses, we can just\
    \ output their values.\n        for (i = paren_index + 1; i < levels.size(); i++)\
    \ {\n            levels.add(0, levels.get(i));\n        }\n\n        return levels;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp47nsco1o.java:50: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Create empty array to store\
    \ level values\n        ArrayList<Integer> level = new ArrayList<Integer>();\n\
    \        // Get all the groups and put them into one array\n        String[] groups\
    \ = paren_string.split(\" \");\n        for (String g : groups) {\n          \
    \  // For each group, get all parentheses and put them into an array\n       \
    \     String[] opens = g.split(\"(\");\n            String[] closes = g.split(\"\
    )\");\n            // For each group that has parentheses, recursively search\
    \ deeper\n            for (int i = 0; i < opens.length; i++) {\n             \
    \   ArrayList<Integer> temp = new ArrayList<Integer>();\n                level.add(0);\n\
    \                // If opens has more elements, search deeper\n              \
    \  if (opens[i].length() > closes[i].length()) {\n                    temp = parseNestedParens(opens[i]);\n\
    \                }\n                // If closes has more elements, search deeper\n\
    \                else if (opens[i].length() < closes[i].length()) {\n        \
    \            temp = parseNestedParens(closes[i]);\n                }\n       \
    \         // If they are the same level\n                else {\n            \
    \        level.add(level.get(level.size() - 1) + 1);\n                }\n    \
    \            level.add(level.get(level.size() - 1) + 1);\n            }\n    \
    \    }\n        return level;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmps0oprvhz.java:43: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n\n        ArrayList<ArrayList<String>> groups = splitStrings(paren_string,\
    \ \" \");\n        for (ArrayList<String> group: groups) {\n            ArrayList<String>\
    \ parens = new ArrayList<>();\n            int curLevel = 0;\n            boolean\
    \ inGroup = false;\n            for (String p: group) {\n                if (inGroup)\
    \ {\n                    parens.add(p);\n                } else {\n          \
    \          if (p.equals(\"(\")) {\n                        inGroup = true;\n \
    \                   } else if (p.equals(\")\")) {\n                        inGroup\
    \ = false;\n                    } else if (p.equals(\"[\")) {\n              \
    \          curLevel++;\n                    } else if (p.equals(\"]\")) {\n  \
    \                      curLevel--;\n                    }\n                }\n\
    \            }\n            result.add(curLevel);\n        }\n        return result;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7keh6wgm.java:17: error: cannot find symbol\n        ArrayList<ArrayList<String>>\
    \ groups = splitStrings(paren_string, \" \");\n                              \
    \                ^\n  symbol:   method splitStrings(String,String)\n  location:\
    \ class Problem\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nested_levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> paren_stack = new ArrayList<Integer>();\n\
    \        for (String str : paren_string.split(\"\\\\s+\")) {\n            if (str.length()\
    \ == 0) {\n                continue;\n            }\n            if (str.charAt(0)\
    \ == '(') {\n                paren_stack.add(0);\n            } else if (str.charAt(str.length()-1)\
    \ == ')') {\n                int level_of_paren_opening = paren_stack.get(paren_stack.size()-1);\n\
    \                nested_levels.add(level_of_paren_opening + 1);\n            \
    \    paren_stack.remove(paren_stack.size()-1);\n            }\n        }\n   \
    \     return nested_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr39awryd.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> answer\
    \ = new ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \        Set<Integer> unmatched = new HashSet<Integer>();\n        StringTokenizer\
    \ tok = new StringTokenizer(paren_string);\n        StringBuilder sb = new StringBuilder();\n\
    \        while (tok.hasMoreTokens()) {\n            String token = tok.nextToken();\n\
    \            if (!unmatched.contains(token)) {\n                sb.append(token);\n\
    \                if (!token.equals(\")\")) {\n                    if (stack.peek()\
    \ == Token.LEFT_PAREN) {\n                        unmatched.add(stack.pop());\n\
    \                        answer.add(1);\n                    } else {\n      \
    \                  stack.push(Token.LEFT_PAREN);\n                        answer.add(0);\n\
    \                    }\n                } else {\n                    unmatched.add(stack.pop());\n\
    \                    if (stack.peek() == Token.LEFT_PAREN) {\n               \
    \         answer.add(stack.pop());\n                    }\n                }\n\
    \            }\n        }\n        while (!stack.isEmpty()) {\n            unmatched.add(stack.pop());\n\
    \            answer.add(0);\n        }\n        return answer;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0fhr7vji.java:25: error: cannot find symbol\n                 \
    \   if (stack.peek() == Token.LEFT_PAREN) {\n                                \
    \        ^\n  symbol:   variable Token\n  location: class Problem\n/tmp/tmp0fhr7vji.java:29:\
    \ error: cannot find symbol\n                        stack.push(Token.LEFT_PAREN);\n\
    \                                   ^\n  symbol:   variable Token\n  location:\
    \ class Problem\n/tmp/tmp0fhr7vji.java:34: error: cannot find symbol\n       \
    \             if (stack.peek() == Token.LEFT_PAREN) {\n                      \
    \                  ^\n  symbol:   variable Token\n  location: class Problem\n\
    3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<Integer>();\n\n        List<String> groups = paren_string.split(\"\
    \\\\s+\");\n        for (int i = 0; i < groups.size(); i++) {\n            String\
    \ group = groups.get(i);\n            int level = 0;\n            int lastPos\
    \ = 0;\n            while (lastPos < group.length()) {\n                int index\
    \ = group.indexOf('(', lastPos);\n                if (index == -1) {\n       \
    \             results.add(level);\n                    break;\n              \
    \  } else {\n                    String s = group.substring(lastPos, index); //\
    \ '(())'\n                    int nextIndex = index + 1;\n                   \
    \ int depth = nextIndex - lastPos;\n                    if (depth % 2 == 0) {\n\
    \                        results.add(level);\n                    }\n        \
    \            level += depth;\n                    lastPos = nextIndex;\n     \
    \           }\n            }\n        }\n\n        return results;\nreturn new\
    \ ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo21crkkr.java:17: error: incompatible types: String[] cannot be\
    \ converted to List<String>\n        List<String> groups = paren_string.split(\"\
    \\\\s+\");\n                                                ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int n = paren_string.length();\n\
    \        ArrayList<Integer> depth = new ArrayList<Integer>();\n        boolean[]\
    \ visited = new boolean[n];\n        int max_level = 0;\n        int i = 0;\n\
    \        while (i < n) {\n            int paren_level = paren_string.indexOf('(',\
    \ i) - i;\n            if (paren_level >= 0) {\n                depth.add(paren_level);\n\
    \                visited[paren_level] = true;\n            }\n            int\
    \ new_level = paren_level + depth.get(paren_level) - 1;\n            if (new_level\
    \ > max_level) {\n                max_level = new_level;\n            }\n    \
    \        i = paren_string.indexOf('(', i + 1);\n        }\n        // The depths\
    \ we found are in descending order\n        Collections.sort(depth);\n       \
    \ ArrayList<Integer> ans = new ArrayList<Integer>();\n        for (int j = 0;\
    \ j < depth.size(); ++j) {\n            if (visited[j]) {\n                continue;\n\
    \            }\n            ans.add(depth.get(j));\n        }\n        return\
    \ ans;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1r29lf1p.java:42: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_level\
    \ = parseLevels(paren_string);\n        ArrayList<Integer> levels = new ArrayList<>();\n\
    \        ArrayList<Integer> counts = new ArrayList<>();\n        for (int i =\
    \ 0; i < max_level.size(); i++) {\n            if (max_level.get(i) == 0) {\n\
    \                levels.add(0);\n                counts.add(1);\n            }\
    \ else {\n                levels.add(i);\n                counts.add(1);\n   \
    \             while (counts.get(i) > max_level.get(i) - 1) {\n               \
    \     counts.set(i,\n                            counts.get(i) - 1);\n       \
    \             levels.add(i);\n                }\n            }\n        }\n  \
    \      ArrayList<Integer> ans = new ArrayList<>();\n        int num_levels = levels.size();\n\
    \        for (int i = 0; i < num_levels; i++) {\n            ans.add(levels.get(i));\n\
    \        }\n        return ans;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzuky3a20.java:15: error: cannot find symbol\n        ArrayList<Integer>\
    \ max_level = parseLevels(paren_string);\n                                   \
    \    ^\n  symbol:   method parseLevels(String)\n  location: class Problem\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        String[] parens = paren_string.split(\" \");\n\
    \        int max_level = 1;\n        ArrayList<Integer> current_level = new ArrayList<>();\n\
    \        for (int i = 0; i < parens.length; i++) {\n            if (parens[i].equals(\"\
    ()\")) {\n                if (current_level.isEmpty()) {\n                   \
    \ current_level.add(1);\n                } else {\n                    current_level.add(current_level.get(current_level.size()\
    \ - 1) + 1);\n                }\n            } else if (parens[i].equals(\"[]\"\
    )) {\n                current_level.add(1);\n            } else {\n          \
    \      current_level.add(current_level.get(current_level.size() - 1) + 1);\n \
    \               if (current_level.size() > max_level) {\n                    max_level\
    \ = current_level.size();\n                }\n            }\n        }\n     \
    \   if (max_level > 0) {\n            for (int i = 1; i < max_level; i++) {\n\
    \                results.add(current_level.get(i));\n            }\n        }\n\
    \        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n  \
    \  }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd54gvm_r.java:41: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // To find the deepest level\
    \ of nesting we use a stack. On each iteration,\n        // we pop the stack and\
    \ increment the count of nested parentheses.\n        // The stack is emptied\
    \ once we reach a parentheses with count greater than zero.\n        // If stack\
    \ is empty then we know that all parentheses are at level 0.\n        Stack<Integer>\
    \ stack = new Stack<Integer>();\n        StringTokenizer tokens = new StringTokenizer(paren_string);\n\
    \        ArrayList<Integer> paren_count = new ArrayList<Integer>();\n        while\
    \ (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n\
    \            if (token.equals(\"(\")) {\n                stack.push(0);\n    \
    \        } else if (token.equals(\")\")) {\n                int count = stack.pop();\n\
    \                if (count == 0) {\n                    // This paren has count\
    \ of 0, indicating all parens are at level 0.\n                    // We just\
    \ need to keep track of the count of parentheses and return.\n               \
    \     paren_count.add(0);\n                } else {\n                    paren_count.add(count);\n\
    \                }\n            }\n        }\n        return paren_count;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9cegk2wo.java:38: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n\n    \
    \    // Iterate over all parentheses\n        for (char c : paren_string.toCharArray())\
    \ {\n            // If current character is parentheses, add to stack\n      \
    \      if (c == '(') {\n                stack.add(c);\n            }\n       \
    \     // If current character is close parentheses, push nested level and pop\
    \ parentheses\n            else if (c == ')') {\n                result.add(stack.pop());\n\
    \            }\n            // If current character is whitespace, do nothing\n\
    \            else if (c == ' ') {\n            }\n            // If current character\
    \ is other character, do nothing\n            else {\n                throw new\
    \ IllegalArgumentException(\"Invalid input: \" + paren_string);\n            }\n\
    \        }\n        // If parentheses are unbalanced, stack will always be empty\n\
    \        result.add(stack.pop());\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdyvue_m7.java:22: error: no suitable method found for add(char)\n\
    \                stack.add(c);\n                     ^\n    method Collection.add(Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    \    method List.add(Integer) is not applicable\n      (argument mismatch; char\
    \ cannot be converted to Integer)\n    method AbstractCollection.add(Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    \    method AbstractList.add(Integer) is not applicable\n      (argument mismatch;\
    \ char cannot be converted to Integer)\n    method Vector.add(Integer) is not\
    \ applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    Note: Some messages have been simplified; recompile with -Xdiags:verbose to get\
    \ full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels\
    \ = new ArrayList<Integer>();\n        char[] input_array = paren_string.toCharArray();\n\
    \        int depth = 0;\n        for (char c : input_array) {\n            if\
    \ (c == '(') {\n                depth++;\n            }\n            if (c ==\
    \ ')') {\n                depth--;\n            }\n            if (depth > max_levels.size())\
    \ {\n                max_levels.add(depth);\n            }\n        }\n      \
    \  return max_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_7jbvbrm.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // We need to keep track of\
    \ level to do proper recursion.\n        ArrayList<Integer> level_of_nesting =\
    \ new ArrayList<>();\n        // This map will keep track of each character in\
    \ the input string\n        Map<Character, Integer> input_string = new HashMap<>();\n\
    \        // This map will keep track of current parentheses level for each character\n\
    \        Map<Character, Integer> current_level = new HashMap<>();\n        //\
    \ This map will keep track of level of parenthesis for each character with -1\
    \ as default.\n        Map<Character, Integer> max_level = new HashMap<>();\n\
    \        // This map will keep track of level of parenthesis for each character\
    \ with -1 as default.\n        Map<Character, Integer> min_level = new HashMap<>();\n\
    \n        // Loop through all characters in the string\n        for(char c : paren_string.toCharArray())\
    \ {\n            // If this character is a parenthesis then increase its level\n\
    \            if(isParenthesis(c)) {\n                current_level.put(c, current_level.get(c)\
    \ + 1);\n            }\n            // If this character is a space then increase\
    \ its level\n            if(isSpace(c)) {\n                current_level.put(c,\
    \ current_level.get(c) + 1);\n            }\n            // This character should\
    \ be added to the input string if not already there\n            if(!input_string.containsKey(c))\
    \ {\n                input_string.put(c, 1);\n            }\n            else\
    \ {\n                input_string.put(c, input_string.get(c) + 1);\n         \
    \   }\n            // If the current level is greater than the max then update\
    \ max_level map\n            if(current_level.get(c) > max_level.get(c)) {\n \
    \               max_level.put(c, current_level.get(c));\n            }\n     \
    \       // If the current level is less than min then update min_level map\n \
    \           if(current_level.get(c) < min_level.get(c)) {\n                min_level.put(c,\
    \ current_level.get(c));\n            }\n            // If the level is not -1,\
    \ then we shouldn't increment it by 1\n            if(current_level.get(c) !=\
    \ -1) {\n                current_level.put(c, current_level.get(c) + 1);\n   \
    \         }\n        }\n        // Loop through all characters in input string\
    \ and if they are part of max_level, update max_level\n        for(int c : input_string.keySet())\
    \ {\n            if(max_level.get(c) == -1) {\n                throw new IllegalArgumentException(\"\
    Invalid input!\");\n            }\n        }\n        // Loop through all characters\
    \ in input string and if they are part of min_level, update min_level\n      \
    \  for(int c : input_string.keySet()) {\n            if(min_level.get(c) == -1)\
    \ {\n                min_level.put(c, 1);\n            }\n        }\n        //\
    \ Loop through all characters in input string and update level_of_nesting list\
    \ accordingly\n        for(int c : input_string.keySet()) {\n            if(current_level.get(c)\
    \ < min_level.get(c)) {\n\nreturn new ArrayList<Integer>(Arrays.asList());\n \
    \   }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbn8o8l6p.java:74: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n/tmp/tmpbn8o8l6p.java:74: error: illegal\
    \ start of expression\n    public static void main(String[] args) {\n        \
    \   ^\n/tmp/tmpbn8o8l6p.java:74: error: ';' expected\n    public static void main(String[]\
    \ args) {\n                 ^\n/tmp/tmpbn8o8l6p.java:74: error: '.class' expected\n\
    \    public static void main(String[] args) {\n                              \
    \       ^\n/tmp/tmpbn8o8l6p.java:74: error: ';' expected\n    public static void\
    \ main(String[] args) {\n                                         ^\n/tmp/tmpbn8o8l6p.java:80:\
    \ error: reached end of file while parsing\n}\n ^\n6 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Your code here\n      \
    \  // Solution:\n        ArrayList<Integer> res = new ArrayList<>();\n       \
    \ HashSet<String> parens = new HashSet<>();\n        boolean inParens = false;\n\
    \        int i = -1;\n        while (true) {\n            i++;\n            int\
    \ c = paren_string.charAt(i);\n            if (c == '(') {\n                inParens\
    \ = true;\n                parens.add(c);\n            } else if (c == ')') {\n\
    \                inParens = false;\n                for (int j = 0; j < parens.size();\
    \ j++) {\n                    String a = parens.remove(parens.last());\n     \
    \               if (parens.isEmpty()) {\n                        res.add(i);\n\
    \                        break;\n                    }\n                    for\
    \ (int k = 0; k < a.length(); k++) {\n                        if (!inParens) {\n\
    \                            parens.add(a.charAt(k));\n                      \
    \      break;\n                        }\n                    }\n            \
    \    }\n            } else if (c == ' ') {\n                res.add(i);\n    \
    \        }\n        }\n        return res;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpipf3a0nd.java:26: error: no suitable method found for add(int)\n\
    \                parens.add(c);\n                      ^\n    method Collection.add(String)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to String)\n\
    \    method Set.add(String) is not applicable\n      (argument mismatch; int cannot\
    \ be converted to String)\n    method AbstractCollection.add(String) is not applicable\n\
    \      (argument mismatch; int cannot be converted to String)\n    method HashSet.add(String)\
    \ is not applicable\n      (argument mismatch; int cannot be converted to String)\n\
    /tmp/tmpipf3a0nd.java:30: error: cannot find symbol\n                    String\
    \ a = parens.remove(parens.last());\n                                        \
    \           ^\n  symbol:   method last()\n  location: variable parens of type\
    \ HashSet<String>\n/tmp/tmpipf3a0nd.java:37: error: no suitable method found for\
    \ add(char)\n                            parens.add(a.charAt(k));\n          \
    \                        ^\n    method Collection.add(String) is not applicable\n\
    \      (argument mismatch; char cannot be converted to String)\n    method Set.add(String)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    \    method AbstractCollection.add(String) is not applicable\n      (argument\
    \ mismatch; char cannot be converted to String)\n    method HashSet.add(String)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Create a stack to track\
    \ the level of nesting\n        Stack<Integer> levelStack = new Stack<>();\n \
    \       // Create a stack to track the paren level\n        Stack<Integer> parenLevelStack\
    \ = new Stack<>();\n        // A list to hold the max level count\n        ArrayList<Integer>\
    \ maxLevelCount = new ArrayList<>();\n        // A list to hold the corresponding\
    \ nested level\n        ArrayList<Integer> nestedLevelCount = new ArrayList<>();\n\
    \        // Iterate through the input string one character at a time\n       \
    \ for(int i = 0; i < paren_string.length(); i++) {\n            // Get the current\
    \ character\n            char c = paren_string.charAt(i);\n            // Push\
    \ the current level of nesting onto the stack\n            levelStack.push(i);\n\
    \            // If current character is a left parentheses, push the level onto\
    \ the stack\n            if(Character.isLetter(c)) {\n                parenLevelStack.push(i);\n\
    \            }\n            // If current character is a right parentheses, pop\
    \ the level from the stack\n            else if(Character.isLetter(c)) {\n   \
    \             levelStack.pop();\n                parenLevelStack.pop();\n    \
    \        }\n            // If current character is a comma, add one to the level\
    \ of nesting\n            else if(Character.isLetter(c)) {\n                levelStack.peek();\n\
    \                parenLevelStack.peek();\n            }\n            // If current\
    \ character is a space, add one to the level of nesting\n            else if(Character.isLetter(c))\
    \ {\n                levelStack.peek();\n                parenLevelStack.peek();\n\
    \            }\n            // If the current level of nesting is greater than\
    \ the max level\n            // push it to the max level count\n            else\
    \ if(levelStack.peek() > maxLevelCount.peek()) {\n                maxLevelCount.push(levelStack.peek());\n\
    \            }\n            // If the current level of nesting is equal to the\
    \ max level\n            // push it to the nested level count\n            else\
    \ if(levelStack.peek() == maxLevelCount.peek()) {\n                nestedLevelCount.push(levelStack.peek());\n\
    \            }\n        }\n        // Return the nested level count\n        return\
    \ nestedLevelCount;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2wntv5a3.java:50: error: cannot find symbol\n            else if(levelStack.peek()\
    \ > maxLevelCount.peek()) {\n                                                \
    \     ^\n  symbol:   method peek()\n  location: variable maxLevelCount of type\
    \ ArrayList<Integer>\n/tmp/tmp2wntv5a3.java:51: error: cannot find symbol\n  \
    \              maxLevelCount.push(levelStack.peek());\n                      \
    \       ^\n  symbol:   method push(Integer)\n  location: variable maxLevelCount\
    \ of type ArrayList<Integer>\n/tmp/tmp2wntv5a3.java:55: error: cannot find symbol\n\
    \            else if(levelStack.peek() == maxLevelCount.peek()) {\n          \
    \                                            ^\n  symbol:   method peek()\n  location:\
    \ variable maxLevelCount of type ArrayList<Integer>\n/tmp/tmp2wntv5a3.java:56:\
    \ error: cannot find symbol\n                nestedLevelCount.push(levelStack.peek());\n\
    \                                ^\n  symbol:   method push(Integer)\n  location:\
    \ variable nestedLevelCount of type ArrayList<Integer>\n4 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n      \
    \  for (String group : paren_string.split(\" \")) {\n            while (!stack.empty()\
    \ && stack.peek() > group.charAt(0)) {\n                result.add(stack.peek()\
    \ - 1);\n                stack.pop();\n            }\n            stack.push(group.charAt(0));\n\
    \        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy5qofbtq.java:22: error: incompatible types: char cannot be converted\
    \ to Integer\n            stack.push(group.charAt(0));\n                     \
    \              ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // For each group of parentheses,\
    \ go through each level of nested parentheses.\n        // Keep a count of how\
    \ many parentheses you have seen in the group.\n        // If this is greater\
    \ than the previous count of parentheses, reset the count.\n        // Otherwise,\
    \ just add the number of parentheses you have seen to this count.\n        //\
    \ The result is added to an ArrayList of integers to return.\n        ArrayList<Integer>\
    \ levels = new ArrayList<Integer>();\n        int i = 0;\n        while (i < paren_string.length())\
    \ {\n            int j = paren_string.indexOf('(', i);\n            levels.add(j\
    \ - i); // Add level count.\n            i = j + 1; // Move to next opening parentheses.\n\
    \        }\n        // Add the last level.\n        levels.add(i);\n        return\
    \ levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi0ej5snm.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> output_array\
    \ = new ArrayList<>();\n        ArrayList<String> par = new ArrayList<>();\n \
    \       par.add(paren_string);\n\n        ArrayList<String> par2 = new ArrayList<>();\n\
    \        int level_counter = 0;\n        int prev_level_count = -1;\n\n      \
    \  while (level_counter <= 0) {\n            String temp = par2.get(0);\n    \
    \        par2.remove(0);\n            par.add(temp);\n\n            level_counter++;\n\
    \            if (level_counter > prev_level_count) {\n                prev_level_count\
    \ = level_counter;\n            }\n\n        }\n\n        for (int x = 0; x <\
    \ par2.size(); x++) {\n            int num_groups = Integer.parseInt(par2.get(x));\n\
    \            ArrayList<Integer> group_array = new ArrayList<>();\n           \
    \ for (int i = 0; i < num_groups; i++) {\n                String temp = par.get(level_counter);\n\
    \                par.remove(level_counter);\n                par.add(temp);\n\
    \                group_array.add(level_counter);\n            }\n            output_array.addAll(group_array);\n\
    \        }\n        return output_array;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp12ky43bs.java:47: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> paren_levels\
    \ = new ArrayList<Integer>();\n        int paren_level_counter = 0;\n        //\
    \ This will be used to keep track of the number of open parentheses encountered\
    \ per level.\n        // This will be used when deciding whether to count parentheses\
    \ enclosed within parentheses or\n        // parentheses enclosed by parentheses.\n\
    \        int open_parentheses_counter = 0;\n        // This will be used to keep\
    \ track of the number of closing parentheses encountered per level.\n        //\
    \ This will be used when deciding whether to count parentheses enclosed within\
    \ parentheses or\n        // parentheses enclosed by parentheses.\n        int\
    \ close_parentheses_counter = 0;\n        // This will be used to keep track of\
    \ the number of parentheses encountered per level.\n        // This will be used\
    \ when deciding whether to count parentheses enclosed within parentheses or\n\
    \        // parentheses enclosed by parentheses.\n        int parentheses_counter\
    \ = 0;\n        // This will be used to keep track of the number of unmatched\
    \ parentheses encountered per level.\n        // This will be used when deciding\
    \ whether to count parentheses enclosed within parentheses or\n        // parentheses\
    \ enclosed by parentheses.\n        int unmatched_parentheses_counter = 0;\n\n\
    \        // This will be used to keep track of the number of opening parentheses\
    \ encountered per level.\n        // This will be used when deciding whether to\
    \ count parentheses enclosed within parentheses or\n        // parentheses enclosed\
    \ by parentheses.\n        int open_parentheses_counter_per_level = new ArrayList<Integer>();\n\
    \n        // This will be used to keep track of the number of closing parentheses\
    \ encountered per level.\n        // This will be used when deciding whether to\
    \ count parentheses enclosed within parentheses or\n        // parentheses enclosed\
    \ by parentheses.\n        int close_parentheses_counter_per_level = new ArrayList<Integer>();\n\
    \n        // This will be used to keep track of the number of parentheses encountered\
    \ per level.\n        // This will be used when deciding whether to count parentheses\
    \ enclosed within parentheses or\n        // parentheses enclosed by parentheses.\n\
    \        int parentheses_counter_per_level = new ArrayList<Integer>();\n\n   \
    \     ArrayList<Integer> parentheses_enclosed_within_parentheses = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> parentheses_enclosed_by_parentheses = new ArrayList<Integer>();\n\
    \n        paren_string.chars().forEach(x -> {\n            switch (x) {\n    \
    \            case ')':\n                    parentheses_counter_per_level.set(paren_level_counter,\
    \ parentheses_counter_per_level.get(paren_level_counter) - 1);\n             \
    \       paren_level_counter--;\n                    parentheses_counter++;\n \
    \                   break;\n                case '(':\n                    parentheses_counter_per_level.set(paren_level_counter,\
    \ parentheses_counter_per_level.get(paren_level_counter) + 1);\n             \
    \       paren_level_counter++;\n                    break;\n                case\
    \ '{':\n                    open_parentheses_counter_\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnr0m67ln.java:64: error: not a statement\n                    open_parentheses_counter_\n\
    \                    ^\n/tmp/tmpnr0m67ln.java:64: error: ';' expected\n      \
    \              open_parentheses_counter_\n                                   \
    \          ^\n/tmp/tmpnr0m67ln.java:67: error: illegal start of expression\n \
    \   public static void main(String[] args) {\n    ^\n/tmp/tmpnr0m67ln.java:67:\
    \ error: illegal start of expression\n    public static void main(String[] args)\
    \ {\n           ^\n/tmp/tmpnr0m67ln.java:67: error: ';' expected\n    public static\
    \ void main(String[] args) {\n                 ^\n/tmp/tmpnr0m67ln.java:67: error:\
    \ '.class' expected\n    public static void main(String[] args) {\n          \
    \                           ^\n/tmp/tmpnr0m67ln.java:67: error: ';' expected\n\
    \    public static void main(String[] args) {\n                              \
    \           ^\n/tmp/tmpnr0m67ln.java:73: error: reached end of file while parsing\n\
    }\n ^\n/tmp/tmpnr0m67ln.java:74: error: reached end of file while parsing\n9 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nesting_level\
    \ = new ArrayList<Integer>();\n        paren_string = paren_string.replaceAll(\"\
    [\\(\\)]\", \"\");\n        String temp = null;\n        int level = 0;\n    \
    \    for(int i = 0; i < paren_string.length(); i++) {\n            if(paren_string.charAt(i)\
    \ == '(') {\n                nesting_level.add(level);\n            } else if(paren_string.charAt(i)\
    \ == ')') {\n                nesting_level.remove((int) nesting_level.get((int)\
    \ nesting_level.size() - 1));\n            } else if(nesting_level.size() == 0\
    \ && paren_string.charAt(i) != '(' && paren_string.charAt(i) != ')') {\n     \
    \           temp = paren_string.substring(i, paren_string.length());\n       \
    \         level = nesting_level.size() - 1;\n            }\n        }\n      \
    \  if(nesting_level.size() > 0) {\n            nesting_level.remove((int) nesting_level.get((int)\
    \ nesting_level.size() - 1));\n        }\n        return nesting_level;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnox_lf62.java:16: error: illegal escape character\n        paren_string\
    \ = paren_string.replaceAll(\"[\\(\\)]\", \"\");\n                           \
    \                       ^\n/tmp/tmpnox_lf62.java:16: error: illegal escape character\n\
    \        paren_string = paren_string.replaceAll(\"[\\(\\)]\", \"\");\n       \
    \                                             ^\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nested_levels\
    \ = new ArrayList<Integer>();\n        // The pattern to find parentheses.\n \
    \       String pattern = \"\\\\(\\\\w+\\\\)\";\n        // The regular expression\
    \ pattern\n        Pattern r = Pattern.compile(pattern);\n        Matcher m =\
    \ r.matcher(paren_string);\n        while(m.find()) {\n            // Each match\
    \ group is a list of parentheses.\n            ArrayList<String> match_groups\
    \ = m.group().split(\"\\\\)\");\n            // Get the level of nesting of parentheses.\n\
    \            int level = 0;\n            for(int i = 0; i < match_groups.size();\
    \ i++) {\n                String curr = match_groups.get(i);\n               \
    \ if(\"(\".equals(curr)) {\n                    level++;\n                } else\
    \ if(\")\".equals(curr)) {\n                    level--;\n                }\n\
    \                nested_levels.add(level);\n            }\n        }\n       \
    \ return nested_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7ko8zk0m.java:19: error: cannot find symbol\n        Pattern r\
    \ = Pattern.compile(pattern);\n        ^\n  symbol:   class Pattern\n  location:\
    \ class Problem\n/tmp/tmp7ko8zk0m.java:19: error: cannot find symbol\n       \
    \ Pattern r = Pattern.compile(pattern);\n                    ^\n  symbol:   variable\
    \ Pattern\n  location: class Problem\n/tmp/tmp7ko8zk0m.java:20: error: cannot\
    \ find symbol\n        Matcher m = r.matcher(paren_string);\n        ^\n  symbol:\
    \   class Matcher\n  location: class Problem\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> paren_levels\
    \ = new ArrayList<Integer>();\n        int paren_count = 0;\n        for (char\
    \ c : paren_string.toCharArray()) {\n            if (c == '(') {\n           \
    \     paren_count++;\n            } else if (c == ')') {\n                paren_count--;\n\
    \            }\n            if (paren_count == 0) {\n                paren_levels.add(paren_count);\n\
    \            }\n        }\n        return paren_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmphkkczoi9.java:28: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        if (paren_string.matches(\"\
    \\\\(.*\\\\)\")) {\n            String nested = paren_string.substring(1);\n \
    \           String[] inner_strings = nested.split(\"\\\\)\");\n            ArrayList<Integer>\
    \ nested_levels = new ArrayList<>();\n            for (String inner_string : inner_strings)\
    \ {\n                nested_levels.add(parseNestedParens(inner_string));\n   \
    \         }\n            ArrayList<Integer> results = new ArrayList<>();\n   \
    \         for (int i = 0; i < nested_levels.size() - 1; i++) {\n             \
    \   if (nested_levels.get(i) > nested_levels.get(nested_levels.size() - 2)) {\n\
    \                    results.add(nested_levels.get(i));\n                }\n \
    \           }\n            return results;\n        }\n        return Arrays.asList(1,\
    \ 1);\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpva_pm7_h.java:20: error: no suitable method found for add(ArrayList<Integer>)\n\
    \                nested_levels.add(parseNestedParens(inner_string));\n       \
    \                      ^\n    method Collection.add(Integer) is not applicable\n\
    \      (argument mismatch; ArrayList<Integer> cannot be converted to Integer)\n\
    \    method List.add(Integer) is not applicable\n      (argument mismatch; ArrayList<Integer>\
    \ cannot be converted to Integer)\n    method AbstractCollection.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n    method AbstractList.add(Integer) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to Integer)\n    method ArrayList.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n/tmp/tmpva_pm7_h.java:30: error: incompatible types: no instance(s)\
    \ of type variable(s) T exist so that List<T> conforms to ArrayList<Integer>\n\
    \        return Arrays.asList(1, 1);\n                            ^\n  where T\
    \ is a type-variable:\n    T extends Object declared in method <T>asList(T...)\n\
    Note: Some messages have been simplified; recompile with -Xdiags:verbose to get\
    \ full output\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nest =\
    \ new ArrayList<Integer>();\n        ArrayList<Integer> nest_level = new ArrayList<Integer>();\n\
    \        boolean is_open = true;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(')\
    \ {\n                if (!is_open) {\n                    nest.add(0);\n     \
    \               nest_level.add(0);\n                }\n                is_open\
    \ = true;\n                nest_level.add(nest.size());\n            } else if\
    \ (c == ')') {\n                nest_level.remove(nest_level.size()-1);\n    \
    \            is_open = false;\n                nest.add(nest_level.get(nest_level.size()-1));\n\
    \            } else if (c == ' ') {\n                nest.add(nest.size()-1);\n\
    \            }\n        }\n        return nest;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4ie2v7tu.java:36: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> deepest_nesting\
    \ = new ArrayList<Integer>();\n        for (String group : paren_string.split(\"\
    \ \"))\n        {\n            ArrayList<Integer> current_level = new ArrayList<Integer>();\n\
    \            for (int i = 0; i < group.length(); i++)\n            {\n       \
    \         if (group.charAt(i) == '(')\n                {\n                   \
    \ if (current_level.size() > deepest_nesting.size())\n                       \
    \ deepest_nesting = current_level;\n                    current_level.add(1);\n\
    \                }\n                else if (group.charAt(i) == ')')\n       \
    \         {\n                    if (current_level.size() > deepest_nesting.size())\n\
    \                        deepest_nesting = current_level;\n                  \
    \  current_level.add(-1);\n                }\n                else\n         \
    \       {\n                    current_level.add(0);\n                }\n    \
    \        }\n        }\n        return deepest_nesting;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg2b4dgzg.java:40: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        if (paren_string.length()\
    \ < 2) return null;\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\
    \        int start_index = 1;\n        for (; start_index < paren_string.length();\
    \ start_index++) {\n            if (paren_string.charAt(start_index) == '(') {\n\
    \                result.add(0);\n            }\n            else if (paren_string.charAt(start_index)\
    \ == '(') {\n                result.add(1);\n            }\n            else if\
    \ (paren_string.charAt(start_index) == ')') {\n                int index = result.lastIndexOf(0);\n\
    \                if (index > 0) {\n                    result.remove(index);\n\
    \                    result.remove(index);\n                }\n              \
    \  else {\n                    return null;\n                }\n            }\n\
    \        }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmplp3515n6.java:37: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        for (String curr_paren = paren_string.trim();\
    \ curr_paren.length() > 0; curr_paren = paren_string.trim()) {\n            if\
    \ (curr_paren.equals(\"(\")) {\n                if (levels.size() > 0) {\n   \
    \                 levels.add(levels.size() - 1);\n                }\n        \
    \    } else if (curr_paren.equals(\")\")) {\n                if (levels.size()\
    \ > 0) {\n                    levels.remove(levels.size() - 1);\n            \
    \    }\n            } else {\n                levels.add(1);\n            }\n\
    \        }\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmprc5coaty.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Get the number of opening\
    \ and closing parentheses\n        int num_opening_parentheses = paren_string.length();\n\
    \        int num_closing_parentheses = paren_string.trim().length() - paren_string.trim().replaceAll(\"\
    \\\\s\", \"\").length();\n\n        // Define the arraylist to hold all lengths\
    \ of nesting levels\n        ArrayList<Integer> length_list = new ArrayList<Integer>();\n\
    \n        // Traverse through each character in string\n        for (int i = 1;\
    \ i < paren_string.length(); i++) {\n            // For each opening parentheses,\
    \ increase the length by 1\n            if (paren_string.charAt(i) == '(') {\n\
    \                length_list.add(num_opening_parentheses);\n            }\n  \
    \          // For each closing parentheses, decrease the length by 1\n       \
    \     else if (paren_string.charAt(i) == ')') {\n                length_list.remove(length_list.size()\
    \ - 1);\n            }\n        }\n\n        // Add the sum of lengths\n     \
    \   ArrayList<Integer> result = length_list;\n        result.add(length_list.get(0).intValue()\
    \ + length_list.get(1).intValue());\n\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy796lafg.java:39: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels\
    \ = new ArrayList<>();\n        for (String nested_paren : paren_string.split(\"\
    \\\\s+\")) {\n            int n = parseNestedParens(nested_paren);\n         \
    \   if (max_levels.isEmpty() || n > max_levels.get(max_levels.size() - 1)) {\n\
    \                ArrayList<Integer> new_levels = new ArrayList<>();\n        \
    \        for (int i = 0; i < n; i++) {\n                    new_levels.add(i);\n\
    \                }\n                max_levels.add(new_levels);\n            }\n\
    \            else {\n                max_levels.get(max_levels.size() - 1).add(i);\n\
    \            }\n        }\n        return max_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpthht30k4.java:17: error: incompatible types: ArrayList<Integer>\
    \ cannot be converted to int\n            int n = parseNestedParens(nested_paren);\n\
    \                                     ^\n/tmp/tmpthht30k4.java:23: error: no suitable\
    \ method found for add(ArrayList<Integer>)\n                max_levels.add(new_levels);\n\
    \                          ^\n    method Collection.add(Integer) is not applicable\n\
    \      (argument mismatch; ArrayList<Integer> cannot be converted to Integer)\n\
    \    method List.add(Integer) is not applicable\n      (argument mismatch; ArrayList<Integer>\
    \ cannot be converted to Integer)\n    method AbstractCollection.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n    method AbstractList.add(Integer) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to Integer)\n    method ArrayList.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n/tmp/tmpthht30k4.java:26: error: cannot find symbol\n         \
    \       max_levels.get(max_levels.size() - 1).add(i);\n                      \
    \                                    ^\n  symbol:   variable i\n  location: class\
    \ Problem\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_level\
    \ = new ArrayList<Integer>();\n        Stack<Integer> stack = new Stack<Integer>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            char c\
    \ = paren_string.charAt(i);\n            if (c == '(')\n                stack.push(i);\n\
    \            if (c == ')')\n                while (stack.isEmpty())\n        \
    \            stack.pop();\n                if (stack.isEmpty())\n            \
    \        max_level.add(0);\n                else\n                    max_level.add(stack.pop());\n\
    \            if (stack.size() > 0 && stack.peek() != i)\n                max_level.add(stack.peek());\n\
    \        }\n        return max_level;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd9e0585a.java:32: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        int pos = 0;\n        boolean inside_group = false;\n\
    \        int stack = 1;\n        while(pos < paren_string.length()) {\n      \
    \      char ch = paren_string.charAt(pos);\n            if (ch == '(') {\n   \
    \             inside_group = true;\n            } else if (ch == ')') {\n    \
    \            inside_group = false;\n            } else if (inside_group) {\n \
    \               stack++;\n            }\n            pos++;\n            if (stack\
    \ > result.size()) {\n                result.add(stack);\n            }\n    \
    \    }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4_4e9tlt.java:34: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n\n        // Step 1: convert string to a nested list of\
    \ brackets.\n        StringBuilder nested_bracket = new StringBuilder();\n   \
    \     for (int i = 0; i < paren_string.length(); i++) {\n            nested_bracket.append(paren_string.charAt(i));\n\
    \        }\n        Stack<String> brackets = new Stack<>();\n        brackets.push(nested_bracket.toString());\n\
    \        int brackets_size = brackets.size();\n\n        // Step 2: count the\
    \ levels.\n        while (brackets.size() > 0) {\n            String bracket =\
    \ brackets.pop();\n            if (bracket.charAt(0) == '(') {\n             \
    \   brackets.push(bracket);\n            } else {\n                String current_level_str\
    \ = bracket.toString();\n                int current_level = brackets.length();\n\
    \                for (int i = 0; i < brackets_size; i++) {\n                 \
    \   if (brackets.get(i).equals(current_level_str)) {\n                       \
    \ brackets.set(i, current_level_str);\n                        brackets_size =\
    \ i;\n                        current_level_str = brackets.pop();\n          \
    \              break;\n                    }\n                }\n            \
    \    if (current_level_str != \"\") levels.add(current_level);\n            }\n\
    \        }\n\n        // Step 3: convert levels to array list.\n        ArrayList<Integer>\
    \ levels_array = new ArrayList<>(levels);\n        levels_array.remove(levels_array.size()\
    \ - 1);\n        return levels_array;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpetr6tj6l.java:33: error: cannot find symbol\n                int\
    \ current_level = brackets.length();\n                                       \
    \     ^\n  symbol:   method length()\n  location: variable brackets of type Stack<String>\n\
    1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Keep track of how many\
    \ levels we have seen so far\n        ArrayList<Integer> levels = new ArrayList<Integer>();\n\
    \n        // We want to keep a record of how many \"levels\" we see.\n       \
    \ // If we see 0 levels then it's time to call this function again!\n        int\
    \ max_levels = -1;\n\n        // Get the array of strings that we get from splitting\
    \ by spaces\n        String[] groups = paren_string.split(\" \");\n\n        //\
    \ Iterate over the groups and keep track of the levels\n        for (String group\
    \ : groups) {\n            int level = levels.size();\n            levels.add(level);\n\
    \n            // If the level goes over max_levels then call this function again!\n\
    \            if (level >= max_levels) {\n                // We want to keep track\
    \ of the largest level\n                max_levels = level;\n\n              \
    \  // We call this function again with different parameter\n                levels\
    \ = parseNestedParens(group);\n            }\n        }\n\n        // Return an\
    \ array with the levels\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3gsqmnyg.java:42: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nest =\
    \ new ArrayList<>();\n        int open = 0;\n        int close = 0;\n        int\
    \ counter = 0;\n        int i = 0;\n        while ((i = paren_string.indexOf(\"\
    (\", open)) > -1) {\n            while (i >= 0 && paren_string.charAt(i) == '(')\
    \ {\n                nest.add(counter);\n                open++;\n           \
    \     i = paren_string.indexOf(\"(\", open);\n            }\n            while\
    \ (i >= 0 && paren_string.charAt(i) == ')') {\n                close++;\n    \
    \            i = paren_string.indexOf(\")\", close);\n            }\n        \
    \    counter++;\n            open++;\n        }\n        return nest;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmppsqca3yc.java:34: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        StringTokenizer tokenizer = new StringTokenizer(paren_string,\
    \ \" ()\");\n        while (tokenizer.hasMoreTokens()) {\n            String token\
    \ = tokenizer.nextToken();\n            int level_of_nesting = 0;\n          \
    \  for (int i = 0; i < token.length(); i++) {\n                char c = token.charAt(i);\n\
    \                if (c == '(')\n                    level_of_nesting++;\n    \
    \            if (c == ')')\n                    level_of_nesting--;\n        \
    \    }\n            levels.add(level_of_nesting);\n        }\n        System.out.println(levels);\n\
    \        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0vzvcxfs.java:31: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> depths = new ArrayList<Integer>();\n\
    \        ArrayList<Integer> nesting = new ArrayList<Integer>();\n        ArrayList<Integer>\
    \ par_counts = new ArrayList<Integer>();\n        int depth = 0;\n        int\
    \ par_count = 0;\n        ArrayList<Integer> level = 0;\n        ArrayList<Integer>\
    \ par_depth = new ArrayList<Integer>();\n        ArrayList<Integer> par_count\
    \ = new ArrayList<Integer>();\n        boolean found = false;\n        for(int\
    \ i = 0; i < paren_string.length(); i++) {\n            char curr = paren_string.charAt(i);\n\
    \            if(curr == '(') {\n                par_count++;\n               \
    \ par_depth.add(depth);\n            } else if(curr == ')') {\n              \
    \  par_count--;\n                par_depth.remove(par_depth.size() - 1);\n   \
    \         } else if(curr == ' ') {\n                if(par_depth.size() != 0)\
    \ {\n                    depth = par_depth.get(par_depth.size() - 1);\n      \
    \              levels.add(level);\n                    depths.add(depth);\n  \
    \                  nesting.add(par_count);\n                    par_counts.set(par_counts.size()\
    \ - 1, par_count);\n                    level = 0;\n                    par_count\
    \ = 0;\n                    par_depth.clear();\n                } else {\n   \
    \                 level++;\n                }\n            } else if(curr == '('\
    \ || curr == ')') {\n                level++;\n            } else if(curr == '[')\
    \ {\n                if(!found) {\n                    par_count++;\n        \
    \        } else {\n                    par_count++;\n                    par_depth.add(depth);\n\
    \                }\n            } else if(curr == ']') {\n                par_count--;\n\
    \                par_depth.remove(par_depth.size() - 1);\n            } else if(curr\
    \ == '<' || curr == '>') {\n                found = true;\n            }\n   \
    \     }\n        if(!found) {\n            levels.add(level);\n            depths.add(depth);\n\
    \            nesting.add(par_count);\n            par_counts.set(par_counts.size()\
    \ - 1, par_count);\n            level = 0;\n            depth = 0;\n         \
    \   par_depth.clear();\n            found = false;\n        }\n        ArrayList<Integer>\
    \ output = levels.stream().flatMap(Collection::stream).collect(Collectors.toList());\n\
    \        return output;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2yy3n7ne.java:21: error: incompatible types: int cannot be converted\
    \ to ArrayList<Integer>\n        ArrayList<Integer> level = 0;\n             \
    \                      ^\n/tmp/tmp2yy3n7ne.java:23: error: variable par_count\
    \ is already defined in method parseNestedParens(String)\n        ArrayList<Integer>\
    \ par_count = new ArrayList<Integer>();\n                           ^\n/tmp/tmp2yy3n7ne.java:36:\
    \ error: no suitable method found for add(ArrayList<Integer>)\n              \
    \      levels.add(level);\n                          ^\n    method Collection.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n    method List.add(Integer) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to Integer)\n    method AbstractCollection.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n    method AbstractList.add(Integer) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to Integer)\n    method ArrayList.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n/tmp/tmp2yy3n7ne.java:40: error: incompatible types: int cannot\
    \ be converted to ArrayList<Integer>\n                    level = 0;\n       \
    \                     ^\n/tmp/tmp2yy3n7ne.java:44: error: bad operand type ArrayList<Integer>\
    \ for unary operator '++'\n                    level++;\n                    \
    \     ^\n/tmp/tmp2yy3n7ne.java:47: error: bad operand type ArrayList<Integer>\
    \ for unary operator '++'\n                level++;\n                     ^\n\
    /tmp/tmp2yy3n7ne.java:63: error: no suitable method found for add(ArrayList<Integer>)\n\
    \            levels.add(level);\n                  ^\n    method Collection.add(Integer)\
    \ is not applicable\n      (argument mismatch; ArrayList<Integer> cannot be converted\
    \ to Integer)\n    method List.add(Integer) is not applicable\n      (argument\
    \ mismatch; ArrayList<Integer> cannot be converted to Integer)\n    method AbstractCollect"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n      \
    \  stack.add(0);\n        \n        int parentheses_cnt = 0;\n        for(int\
    \ i=0; i<paren_string.length(); i++) {\n            if(paren_string.charAt(i)\
    \ == '(') {\n                parentheses_cnt++;\n                stack.add(parentheses_cnt);\n\
    \            } else if(paren_string.charAt(i) == ')') {\n                stack.remove(stack.size()-1);\n\
    \                parentheses_cnt--;\n            }\n            \n           \
    \ while(!stack.empty() && stack.peek() == (parentheses_cnt+1)) {\n           \
    \     results.add(stack.peek());\n                stack.pop();\n            }\n\
    \        }\n        \n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf_rpcncv.java:36: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        if (paren_string.length() == 0) {\n   \
    \         levels.add(0);\n        } else {\n            int nesting = 1;\n   \
    \         while (nesting > 0 && paren_string.charAt(nesting - 1) == ')') {\n \
    \               nesting--;\n            }\n            int prev_nesting = nesting;\n\
    \            levels.add(nesting);\n            paren_string = paren_string.substring(prev_nesting);\n\
    \            int start_pos = paren_string.indexOf(\"(\");\n            if (start_pos\
    \ == -1) {\n                return levels;\n            }\n            ArrayList<Integer>\
    \ new_levels = parseNestedParens(paren_string.substring(0, start_pos));\n    \
    \        ArrayList<Integer> last_levels = parseNestedParens(paren_string.substring(start_pos\
    \ + 1));\n            for (int i = 0; i < last_levels.size(); i++) {\n       \
    \         if (last_levels.get(i) > new_levels.get(i)) {\n                    ArrayList<Integer>\
    \ temp = new_levels;\n                    new_levels = last_levels;\n        \
    \            last_levels = temp;\n                }\n            }\n         \
    \   for (int i = 0; i < new_levels.size(); i++) {\n                levels.add(new_levels.get(i)\
    \ + 1);\n            }\n        }\n        return levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmprv6mz3w1.java:44: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> stack =\
    \ new ArrayList<Integer>();\n        stack.add(0);\n\n        ArrayList<Integer>\
    \ results = new ArrayList<Integer>();\n        for (String s : paren_string.split(\"\
    \ \")) {\n            int len = s.length();\n            if (len > 0) {\n    \
    \            int depth = stack.get(stack.size() - 1);\n                if (s.charAt(len\
    \ - 1) == ')') {\n                    if (depth > 0) {\n                     \
    \   stack.remove(stack.size() - 1);\n                        stack.add(depth -\
    \ 1);\n                    }\n                }\n                else if (s.charAt(len\
    \ - 1) == '(') {\n                    int left_count = 1 + stack.get(stack.size()\
    \ - 1 - len + 1);\n                    if (left_count > depth) {\n           \
    \             results.add(depth);\n                        stack.remove(stack.size()\
    \ - 1);\n                        stack.add(depth);\n                    }\n  \
    \              }\n                else if (s.charAt(len - 1) == ')') {\n     \
    \               if (depth < stack.get(stack.size() - 1)) {\n                 \
    \       stack.remove(stack.size() - 1);\n                        stack.add(depth);\n\
    \                    }\n                }\n                else {\n          \
    \          stack.remove(stack.size() - 1);\n                }\n            }\n\
    \        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg8hjgrg8.java:49: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> nestingLevels\
    \ = new ArrayList<Integer>();\n        ArrayList<String> parenStrings = new ArrayList<String>();\n\
    \        ArrayList<String> parenStringsReverse = new ArrayList<String>();\n\n\
    \        paren_string = paren_string.toLowerCase().trim();\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\)\\\\)\\\\)\",\"\");\n        paren_string =\
    \ paren_string.replaceAll(\"\\\\(+\\\\)\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\(|\\\\)\", \"\");\n\n        paren_string = paren_string.replaceAll(\"(\\\\\
    ))\", \"\");\n        paren_string = paren_string.replaceAll(\"(\\\\()\", \"\"\
    );\n        paren_string = paren_string.replaceAll(\"(\\\\))\", \"\");\n     \
    \   paren_string = paren_string.replaceAll(\"(\\\\()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"(\\\\))\", \"\");\n\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    ()\", \"\");\n        paren_string = paren_string.replaceAll(\"()\", \"\");\n\n\
    \        paren_string = paren_string.replaceAll(\"(\\\\()\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"(\\\\))\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    (\\\\()\", \"\");\n        paren_string = paren_string.replaceAll(\"(\\\\))\"\
    , \"\");\n        paren_string = paren_string.replaceAll(\"(\\\\()\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"(\\\\))\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"(\\\\()\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    (\\\\))\", \"\");\n        \nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpf0634vg3.java:61)\n"
  exit_code: 1
  status: Exception
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> parens\
    \ = new ArrayList<Integer>();\n        \n        int index = -1;\n        while(paren_string.charAt(index)\
    \ != '(' && paren_string.charAt(index) != ')'){\n            index++;\n      \
    \  }\n        while(index >= 0){\n            parens.add(paren_string.indexOf('(',index));\n\
    \            index++;\n            parens.add(paren_string.indexOf(')',index));\n\
    \            index++;\n        }\n        \n        Collections.sort(parens);\n\
    \        return parens;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf9tsqnyv.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n\n        // Keep adding each parenthesis level to the\
    \ stack (i.e. the number of open parenthesis)\n        int level_stack = 0;\n\n\
    \        // The current level on the stack (i.e. the number of open parenthesis)\n\
    \        int current_level = 0;\n\n        // The current string that we are working\
    \ on\n        String current_string = \"\";\n\n        // Iterate over the parenthesis\n\
    \        for (char c : paren_string.toCharArray()) {\n            current_string.append(c);\n\
    \            // Increment the level by 1 for each parenthesis\n            if\
    \ (c == '(') {\n                current_level++;\n            } else if (c ==\
    \ ')') {\n                current_level--;\n            }\n\n            // If\
    \ we are on the top of the stack, append the current level\n            // to\
    \ the result\n            if (level_stack > 0 && current_level == 0) {\n     \
    \           results.add(current_level);\n            }\n\n            // If the\
    \ level is greater than the top level on the stack\n            // and we are\
    \ not at the top of the stack, append the level to\n            // the result\
    \ and increment the level by one\n            if (level_stack > current_level\
    \ && level_stack > 0 && current_level == 0) {\n                results.add(current_level);\n\
    \                current_level++;\n            }\n\n            // If the level\
    \ is greater than the current level, and we are not at the top level\n       \
    \     // on the stack and we are not on the top of the stack, append the level\
    \ to\n            // the result and decrement the level by one\n            if\
    \ (level_stack > current_level && level_stack > current_level && level_stack >\
    \ 0 && current_level == 0) {\n                results.add(current_level);\n  \
    \              current_level--;\n            }\n\n            // If we are at\
    \ the top of the stack and we are at the top of the stack,\n            // don't\
    \ do anything, otherwise decrement the level by one (which will\n            //\
    \ remove the last level of parenthesis)\n            if (level_stack == current_level)\
    \ {\n                level_stack--;\n            }\n\n            // If we have\
    \ reached the end of the parenthesis string, add the\n            // number of\
    \ parenthesis at the current level to the results\n            if (c == '(' &&\
    \ level_stack == 0) {\n                results.add(current_level);\n         \
    \   }\n        }\n\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0y5z1fj2.java:28: error: cannot find symbol\n            current_string.append(c);\n\
    \                          ^\n  symbol:   method append(char)\n  location: variable\
    \ current_string of type String\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        String[] groups = paren_string.split(\" \");\n\
    \        for (int i = 0; i < groups.length; i++) {\n            ArrayList<Integer>\
    \ level_stack = new ArrayList<Integer>();\n            String group = groups[i];\n\
    \            int group_length = group.length();\n            int last_open = -1;\n\
    \            int last_closed = -1;\n            for (int j = 0; j < group_length;\
    \ j++) {\n                if (group.charAt(j) == '(') {\n                    last_open\
    \ = j;\n                }\n                if (group.charAt(j) == ')') {\n   \
    \                 last_closed = j;\n                }\n            }\n       \
    \     // If last group ends with parentheses, push it to the stack\n         \
    \   if (last_close > last_open + 1) {\n                level_stack.push(last_open);\n\
    \            }\n            // Otherwise, we are on the top level\n          \
    \  else {\n                // Get current level\n                int level = level_stack.size()\
    \ - 1;\n                // If we are at the top level, we are done\n         \
    \       if (level == -1) {\n                    break;\n                }\n  \
    \              // Otherwise, get previous level and push to it\n             \
    \   else {\n                    level_stack.push(level_stack.get(level - 1));\n\
    \                }\n            }\n            // Now go through the group\n \
    \           for (int j = last_open + 1; j < last_close; j++) {\n             \
    \   if (group.charAt(j) == '(') {\n                    level_stack.push(j);\n\
    \                }\n                if (group.charAt(j) == ')') {\n          \
    \          int level_open = level_stack.get(level_stack.size() - 1);\n       \
    \             if (level_open > level) {\n                        level = level_open;\n\
    \                    }\n                    level_stack.pop();\n             \
    \   }\n            }\n            levels.add(level);\n        }\n        return\
    \ levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4io_luej.java:32: error: cannot find symbol\n            if (last_close\
    \ > last_open + 1) {\n                ^\n  symbol:   variable last_close\n  location:\
    \ class Problem\n/tmp/tmp4io_luej.java:33: error: cannot find symbol\n       \
    \         level_stack.push(last_open);\n                           ^\n  symbol:\
    \   method push(int)\n  location: variable level_stack of type ArrayList<Integer>\n\
    /tmp/tmp4io_luej.java:45: error: cannot find symbol\n                    level_stack.push(level_stack.get(level\
    \ - 1));\n                               ^\n  symbol:   method push(Integer)\n\
    \  location: variable level_stack of type ArrayList<Integer>\n/tmp/tmp4io_luej.java:49:\
    \ error: cannot find symbol\n            for (int j = last_open + 1; j < last_close;\
    \ j++) {\n                                            ^\n  symbol:   variable\
    \ last_close\n  location: class Problem\n/tmp/tmp4io_luej.java:51: error: cannot\
    \ find symbol\n                    level_stack.push(j);\n                    \
    \           ^\n  symbol:   method push(int)\n  location: variable level_stack\
    \ of type ArrayList<Integer>\n/tmp/tmp4io_luej.java:55: error: cannot find symbol\n\
    \                    if (level_open > level) {\n                             \
    \        ^\n  symbol:   variable level\n  location: class Problem\n/tmp/tmp4io_luej.java:56:\
    \ error: cannot find symbol\n                        level = level_open;\n   \
    \                     ^\n  symbol:   variable level\n  location: class Problem\n\
    /tmp/tmp4io_luej.java:58: error: cannot find symbol\n                    level_stack.pop();\n\
    \                               ^\n  symbol:   method pop()\n  location: variable\
    \ level_stack of type ArrayList<Integer>\n/tmp/tmp4io_luej.java:61: error: cannot\
    \ find symbol\n            levels.add(level);\n                       ^\n  symbol:\
    \   variable level\n  location: class Problem\n9 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level_of_nesting\
    \ = new ArrayList<>();\n        ArrayList groups = new ArrayList<>();\n\n    \
    \    // Create a map for paren groups to their position\n        HashMap<String,\
    \ Integer> paren_groups = new HashMap<>();\n\n        // Iterate through each\
    \ group\n        StringBuilder paren_builder = new StringBuilder();\n        for\
    \ (int i = 1; i < paren_string.length(); i++) {\n            paren_builder.append(paren_string.charAt(i));\n\
    \n            // When we see a parenthesis, create a group\n            if (paren_builder.charAt(i)\
    \ == '(') {\n                paren_groups.get(paren_builder.toString()) == null\
    \ ?\n                    paren_groups.put(paren_builder.toString(), i) :\n   \
    \                 paren_builder.append(paren_groups.put(paren_builder.toString(),\
    \ i));\n            }\n\n            // When we see a closing parenthesis, check\
    \ its level\n            else if (paren_builder.charAt(i) == ')') {\n        \
    \        // If this group is empty (i.e. no parenthesis pairs), add this to the\
    \ list of groups\n                if (paren_groups.get(paren_builder.toString()).isEmpty())\
    \ {\n                    groups.add(new Integer(paren_builder.toString()));\n\
    \                }\n                else {\n                    level_of_nesting.add(new\
    \ Integer(paren_groups.get(paren_builder.toString())));\n                }\n \
    \           }\n\n            // When we see any other character, just add it to\
    \ the parenthesis group\n            else {\n                paren_builder.append(paren_groups.put(paren_builder.toString(),\
    \ i));\n            }\n        }\n\n        // Return the maximum level of nesting\n\
    \        return level_of_nesting;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt68j2s81.java:28: error: not a statement\n                paren_groups.get(paren_builder.toString())\
    \ == null ?\n                                                                \
    \   ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Define a stack to hold\
    \ the groups of parentheses.\n        Stack<String> stack = new Stack<>();\n \
    \       \n        // Pop all groups out of paren_string and push them into the\
    \ stack until parentheses are unbalanced.\n        for(int i = 0; i < paren_string.length();\
    \ i++) {\n            char ch = paren_string.charAt(i);\n            \n      \
    \      // Handle parentheses.\n            if(ch == '(')\n                stack.push(ch);\n\
    \            else if(ch == ')') {\n                if(stack.isEmpty())\n     \
    \               throw new RuntimeException(\"No matching closing parentheses.\"\
    );\n                else {\n                    stack.pop();\n               \
    \ }\n            }\n            else {\n                throw new RuntimeException(\"\
    Invalid parentheses \" + ch);\n            }\n        }\n        \n        //\
    \ Now we have all groups out. Now we need to find the deepest level of nesting.\n\
    \        List<Integer> deepest_levels_of_nesting = new ArrayList<>();\n      \
    \  while(!stack.isEmpty()) {\n            String current_level = stack.pop();\n\
    \            deepest_levels_of_nesting.add(deepest_levels_of_nesting.size());\n\
    \            int deepest_level = deepest_levels_of_nesting.get(deepest_levels_of_nesting.size()\
    \ - 1);\n            for(int i = 0; i < current_level.length(); i++) {\n     \
    \           char ch = current_level.charAt(i);\n                if(ch == '(')\n\
    \                    stack.push(ch);\n                else if(ch == ')') {\n \
    \                   if(stack.isEmpty())\n                        throw new RuntimeException(\"\
    No matching closing parentheses.\");\n                    else {\n           \
    \             stack.pop();\n                    }\n                }\n       \
    \     }\n        }\n        \n        return deepest_levels_of_nesting;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnfdx7lya.java:24: error: incompatible types: char cannot be converted\
    \ to String\n                stack.push(ch);\n                           ^\n/tmp/tmpnfdx7lya.java:46:\
    \ error: incompatible types: char cannot be converted to String\n            \
    \        stack.push(ch);\n                               ^\n/tmp/tmpnfdx7lya.java:57:\
    \ error: incompatible types: List<Integer> cannot be converted to ArrayList<Integer>\n\
    \        return deepest_levels_of_nesting;\n               ^\nNote: Some messages\
    \ have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Use a HashMap to count\
    \ the parentheses.\n        HashMap<String, Integer> paren_counter = new HashMap<String,\
    \ Integer>();\n        // For every parenthesis in the string, increment its count.\n\
    \        for (char c : paren_string.toCharArray()) {\n            if (c == '(')\
    \ paren_counter.put(c, paren_counter.get(c) + 1);\n            if (c == ')') paren_counter.put(c,\
    \ paren_counter.get(c) - 1);\n        }\n        // If no more parentheses are\
    \ found, the level is zero.\n        if (paren_counter.equals(new HashMap<String,\
    \ Integer>())) return new ArrayList<Integer>();\n        // Sort the counters\
    \ from largest to smallest.\n        ArrayList<Integer> sorted_paren_count = new\
    \ ArrayList<Integer>(paren_counter.values());\n        Collections.sort(sorted_paren_count);\n\
    \        // Return list with deepest level.\n        return sorted_paren_count.subList(0,\
    \ sorted_paren_count.size() - 1);\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9cwk5m0a.java:19: error: no suitable method found for put(char,int)\n\
    \            if (c == '(') paren_counter.put(c, paren_counter.get(c) + 1);\n \
    \                                      ^\n    method Map.put(String,Integer) is\
    \ not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    \    method AbstractMap.put(String,Integer) is not applicable\n      (argument\
    \ mismatch; char cannot be converted to String)\n    method HashMap.put(String,Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    /tmp/tmp9cwk5m0a.java:20: error: no suitable method found for put(char,int)\n\
    \            if (c == ')') paren_counter.put(c, paren_counter.get(c) - 1);\n \
    \                                      ^\n    method Map.put(String,Integer) is\
    \ not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    \    method AbstractMap.put(String,Integer) is not applicable\n      (argument\
    \ mismatch; char cannot be converted to String)\n    method HashMap.put(String,Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to String)\n\
    /tmp/tmp9cwk5m0a.java:28: error: incompatible types: List<Integer> cannot be converted\
    \ to ArrayList<Integer>\n        return sorted_paren_count.subList(0, sorted_paren_count.size()\
    \ - 1);\n                                         ^\n3 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_level\
    \ = new ArrayList<>();\n        Stack<Integer> level = new Stack<>();\n      \
    \  ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(') {\n                level.push(new\
    \ Integer(0));\n            } else if (paren_string.charAt(i) == ')') {\n    \
    \            int current_level = level.size();\n                while (current_level\
    \ > 0 && !level.isEmpty()) {\n                    level.pop();\n             \
    \       current_level--;\n                }\n                if (current_level\
    \ > max_level.size()) max_level = new ArrayList<>(current_level);\n          \
    \      max_level.add(current_level);\n            } else {\n                int\
    \ current_level = level.size();\n                while (current_level > 0 && !level.isEmpty())\
    \ {\n                    level.pop();\n                    current_level--;\n\
    \                }\n                if (current_level > max_level.size()) max_level\
    \ = new ArrayList<>(current_level);\n                level.push(new Integer(current_level));\n\
    \            }\n        }\n        level.pop();\n        for (Integer i : max_level)\
    \ {\n            ans.add(i);\n        }\n        return ans;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo2jcleed.java:44: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        int level = 0;\n        ArrayList<Integer>\
    \ parens = new ArrayList<>();\n        for (char c : paren_string.toCharArray())\
    \ {\n            if (c == '(') {\n                if (parens.isEmpty() || parens.get(parens.size()\
    \ - 1) < level) {\n                    parens.add(level);\n                } else\
    \ {\n                    parens.set(parens.size() - 1, parens.get(parens.size()\
    \ - 1) + 1);\n                }\n            } else if (c == ')') {\n        \
    \        if (parens.get(parens.size() - 1) == level) {\n                    parens.remove(parens.size()\
    \ - 1);\n                } else {\n                    parens.set(parens.size()\
    \ - 1, parens.get(parens.size() - 1) - 1);\n                }\n            } else\
    \ {\n                throw new IllegalArgumentException(\"invalid paren string:\
    \ \" + paren_string);\n            }\n            level++;\n        }\n      \
    \  return parens;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n  \
    \  public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn8aw92en.java:36: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> level_of_nestings\
    \ = new ArrayList<Integer>();\n        for (String nested_parens : paren_string.split(\"\
    \ \")) {\n            ArrayList<Integer> curr_level_of_nestings = parseNestedParens(nested_parens);\n\
    \            level_of_nestings.addAll(curr_level_of_nestings);\n        }\n  \
    \      return level_of_nestings;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmproujmtam.java:21: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        for(int i = 0; i < paren_string.length(); i++)\
    \ {\n            if(paren_string.charAt(i) == '(') {\n                result.add(i\
    \ + 1);\n            } else if(paren_string.charAt(i) == ')') {\n            \
    \    while(result.size() > 0) {\n                    if(result.get(result.size()\
    \ - 1) == i) {\n                        result.remove(result.get(result.size()\
    \ - 1));\n                    }\n                    else {\n                \
    \        result.add(result.size());\n                        break;\n        \
    \            }\n                }\n            }\n        }\n        return result;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq9v2up8a.java:32: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        if (paren_string.isEmpty())\n            return\
    \ results;\n        int counter = 0;\n        char[] char_array = paren_string.toCharArray();\n\
    \        for (int i = 0; i < char_array.length; i++) {\n            if (char_array[i]\
    \ == '(') {\n                counter++;\n            } else if (char_array[i]\
    \ == '(') {\n                counter--;\n            }\n            if (counter\
    \ == 0) {\n                results.add(counter);\n            }\n        }\n \
    \       return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcuvw_7hm.java:31: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> parentheses\
    \ = new ArrayList<Integer>();\n        Stack<String> stack = new Stack<String>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            char ch\
    \ = paren_string.charAt(i);\n            switch (ch) {\n                case ')':\n\
    \                    if (stack.isEmpty()) {\n                        throw new\
    \ RuntimeException(\"Mismatched parentheses. Please re-input.\");\n          \
    \          }\n                    String s = stack.pop();\n                  \
    \  parentheses.add(s.length());\n                    break;\n                case\
    \ ')':\n                    stack.pop();\n                    break;\n       \
    \         case '(':\n                    stack.push(String.valueOf(ch));\n   \
    \                 break;\n                default:\n                    stack.push(String.valueOf(ch));\n\
    \            }\n        }\n        parentheses.add(stack.size());\n        return\
    \ parentheses;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1dy2bieo.java:27: error: duplicate case label\n               \
    \ case ')':\n                ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<Integer>();\n        ArrayList<String> parens = new ArrayList<String>();\n\
    \        paren_string = paren_string.replaceAll(\"\\\\)\\\\s*\\\\(\", \" \");\n\
    \        paren_string = paren_string.replaceAll(\"\\\\s+\", \" \");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\s+\\\\)\\\\s*\\\\(\", \"(\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\s+\\\\)\\\\s*\\\\(.*\\\\)\", \"(\");\n     \
    \   paren_string = paren_string.replaceAll(\"\\\\s+\\\\)\\\\s*\\\\(.*\", \"(\"\
    );\n        paren_string = paren_string.replaceAll(\"\\\\s*\\\\)\\\\s*\\\\(.*\"\
    , \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\s+\\\\(.*?\\\\\
    )\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\s+\\\\(.*?\"\
    , \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\s+\\\\)\\\\s*\\\
    \\(.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\s+\\\\\
    (.*?\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\s+\\\\(.*\"\
    , \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\s+\\\\(.*?\\\\\
    )\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\s+\\\\(.*?\"\
    , \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\s+\\\\(.*\", \"\
    (\");\n        paren_string = paren_string.replaceAll(\"\\\\(\", \"(\");\n   \
    \     paren_string = paren_string.replaceAll(\"\\\\)\", \")\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\s+\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\(.*\\\\)\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\\
    (.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\(.*?\", \"\
    (\");\n        paren_string = paren_string.replaceAll(\"\\\\(.*?\\\\)\", \"(\"\
    );\n        paren_string = paren_string.replaceAll(\"\\\\(.*?\", \"(\");\n   \
    \     paren_string = paren_string.replaceAll(\"\\\\(.*\", \"(\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\(.*?\\\\)\", \"(\");\n        paren_string =\
    \ paren_string.replaceAll(\"\\\\(.*?\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\(.*\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\(.*?\\\
    \\)\", \"(\");\n        paren_string = paren_string.replaceAll(\"\\\\(.*?\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkir85ya_.java:44: error: unclosed string literal\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\(.*?\n                                     \
    \          ^\n/tmp/tmpkir85ya_.java:44: error: ';' expected\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\(.*?\n                                     \
    \                 ^\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> res = new\
    \ ArrayList<Integer>();\n        int stack = 0, par = 0, level = 1;\n        while(paren_string.charAt(0)\
    \ == '(' && paren_string.length() > 1) {\n            par++;\n            paren_string\
    \ = paren_string.substring(1);\n            while(paren_string.charAt(0) == '\
    \ ' || paren_string.charAt(0) == '(' || paren_string.charAt(0) == ')') {\n   \
    \             paren_string = paren_string.substring(1);\n            }\n     \
    \       paren_string = paren_string.substring(1);\n            while(paren_string.charAt(0)\
    \ == ')' && stack > 0) {\n                res.add(level);\n                paren_string\
    \ = paren_string.substring(1);\n                stack--;\n            }\n    \
    \        level++;\n        }\n        if(paren_string.length() > 0) {\n      \
    \      res.add(level);\n        }\n        return res;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmplnpfs91n.java:35: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> paren_level\
    \ = new ArrayList<>();\n        ArrayList<String> nested_strings = paren_string.split(\"\
    \ \");\n        Iterator<String> iterator = nested_strings.iterator();\n     \
    \   while (iterator.hasNext()) {\n            String s = iterator.next();\n  \
    \          paren_level.add(s.length());\n            if (s.startsWith(\"(\") &&\
    \ s.endsWith(\")\")) {\n                int current_level = paren_level.size()\
    \ - 1;\n                for (int i = 0; i < current_level; i++) {\n          \
    \          paren_level.remove(0);\n                }\n                paren_level.add(current_level);\n\
    \            }\n        }\n        return paren_level;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_5hqd3ti.java:16: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<String>\n        ArrayList<String> nested_strings = paren_string.split(\"\
    \ \");\n                                                             ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        if (paren_string.trim().equals(\"\
    \")) return new ArrayList<Integer>();\n        // The output will be stored here\n\
    \        ArrayList<Integer> max_levels = new ArrayList<Integer>();\n        //\
    \ The input will be stored here\n        ArrayList<Integer> parens = new ArrayList<Integer>();\n\
    \        // The current depth of the parenthesis stack\n        int cur_depth\
    \ = 0;\n        // Go through each character of the parenthesis string\n     \
    \   for (char c : paren_string.toCharArray()) {\n            String s = String.valueOf(c);\n\
    \            // If the current character is opening, then add to the parenthesis\
    \ stack\n            if (s.equals('(')) {\n                if (cur_depth == 0)\
    \ throw new Exception(\"Input is not a valid nested parenthesis string.\");\n\
    \                parens.add(cur_depth);\n                cur_depth++;\n      \
    \          // If the parenthesis stack is full then store the output\n       \
    \         if (cur_depth == max_levels.size()) {\n                    max_levels.add(parens.size());\n\
    \                }\n            }\n            // If the current character is\
    \ closing, then remove from the parenthesis stack\n            else if (s.equals(')'))\
    \ {\n                // If the current depth of the parenthesis stack is greater\
    \ than the max levels, then store the output\n                if (cur_depth >\
    \ max_levels.size()) {\n                    max_levels.add(parens.size());\n \
    \               }\n                cur_depth--;\n            }\n        }\n  \
    \      // If the current depth of the parenthesis stack is greater than the max\
    \ levels, then store the output\n        if (cur_depth > max_levels.size()) {\n\
    \            max_levels.add(parens.size());\n        }\n        return max_levels;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpijyar285.java:49: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n/tmp/tmpijyar285.java:27: error: unreported exception Exception; must be caught\
    \ or declared to be thrown\n                if (cur_depth == 0) throw new Exception(\"\
    Input is not a valid nested parenthesis string.\");\n                        \
    \            ^\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        Stack<Integer> parens = new Stack<>();\n     \
    \   ArrayList<Integer> stack = new ArrayList<>();\n\n        for (char ch : paren_string.toCharArray())\
    \ {\n            switch (ch) {\n                case '(':\n                  \
    \  parens.push(0);\n                    break;\n                case ')':\n  \
    \                  parens.pop();\n                    break;\n               \
    \ default:\n                    if (parens.isEmpty()) {\n                    \
    \    result.add(0);\n                    } else {\n                        result.add(parens.pop()\
    \ + 1);\n                    }\n                    break;\n            }\n  \
    \      }\n        return result;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpugbzrr2x.java:37: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Initialize output array\n\
    \        ArrayList<Integer> max_level = new ArrayList<Integer>();\n        //\
    \ For each parenthesis, parse its substring and call recursively\n        for\
    \ (int i = 0; i < paren_string.length(); i++) {\n            int level = 0;\n\
    \            // For each parenthesis character, increment level if it matches\
    \ the next parenthesis character\n            while (paren_string.charAt(i) ==\
    \ '(') level++;\n            while (paren_string.charAt(i) == ')') level--;\n\
    \            if (level > max_level.get(max_level.size()-1)) max_level.add(level);\n\
    \        }\n        // Print the output array\n        System.out.println(max_level);\n\
    \        return max_level;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpro_ohet8.java:28: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Initialize a list of integers\
    \ to store the result of the parsing.\n        ArrayList<Integer> result = new\
    \ ArrayList<>();\n        // Use a stack to keep track of whether parentheses\
    \ are stacked or not.\n        Stack<Boolean> stack_of_parentheses = new Stack<>();\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            // If\
    \ the parentheses are stacked, then the number of nested parentheses will be added\
    \ to the result\n            // and push it on the stack. Otherwise, just add\
    \ the character to the result and push it on\n            // the stack.\n    \
    \        if (paren_string.charAt(i) == '(') {\n                stack_of_parentheses.push(true);\n\
    \            } else if (paren_string.charAt(i) == ')') {\n                stack_of_parentheses.pop();\n\
    \            }\n            if (stack_of_parentheses.isEmpty()) {\n          \
    \      result.add(i);\n            }\n        }\n        return result;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpusndauh5.java:33: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels\
    \ = new ArrayList<Integer>();\n        Stack<Integer> levels = new Stack<Integer>();\n\
    \        ArrayList<Integer> current_levels = new ArrayList<Integer>();\n     \
    \   // Iterate through parenthesis and add levels of nesting\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                current_levels.add(1);\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                current_levels.add(current_levels.pop());\n     \
    \       } else {\n                levels.push(current_levels.pop());\n       \
    \     }\n        }\n\n        // Keep track of max levels of nesting\n       \
    \ for (int i = current_levels.size() - 1; i >= 0; i--) {\n            if (max_levels.size()\
    \ < current_levels.get(i)) {\n                max_levels.add(current_levels.get(i));\n\
    \            }\n        }\n\n        return max_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkrzsb6y7.java:23: error: cannot find symbol\n                current_levels.add(current_levels.pop());\n\
    \                                                 ^\n  symbol:   method pop()\n\
    \  location: variable current_levels of type ArrayList<Integer>\n/tmp/tmpkrzsb6y7.java:25:\
    \ error: cannot find symbol\n                levels.push(current_levels.pop());\n\
    \                                          ^\n  symbol:   method pop()\n  location:\
    \ variable current_levels of type ArrayList<Integer>\n2 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> return_list\
    \ = new ArrayList<Integer>();\n        if (paren_string == null)\n           \
    \ return return_list;\n        paren_string = paren_string.replaceAll(\"[()]\"\
    , \"\");\n        paren_string = paren_string.replaceAll(\"\\\\s\", \"\");\n \
    \       paren_string = paren_string.trim();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(')\n                return_list.add(1);\n\
    \            else if (paren_string.charAt(i) == ')')\n                return_list.add(0);\n\
    \        }\n        return return_list;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeiz15eqr.java:28: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> paren_levels\
    \ = new ArrayList<>();\n        ArrayList<Integer> paren_level = new ArrayList<>();\n\
    \        String curr_paren = \"\";\n        for (int i=0; i<paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == ')'){\n                paren_level.add(paren_level.size()-1);\n\
    \                paren_levels.add(paren_level.size()-1);\n                curr_paren\
    \ = \"\";\n            }\n            if (paren_string.charAt(i) == '(' && paren_level.isEmpty()\
    \ && !paren_level.isEmpty()){\n                paren_level = new ArrayList<>();\n\
    \                paren_levels.add(paren_level.size()-1);\n            }\n    \
    \        if (paren_string.charAt(i) == ')' && paren_level.isEmpty() && !paren_level.isEmpty()){\n\
    \                paren_level = new ArrayList<>();\n                paren_levels.add(paren_level.size()-1);\n\
    \            }\n            if (paren_string.charAt(i) == ' ' && paren_level.isEmpty()){\n\
    \                curr_paren = \"\";\n            }\n            else if (paren_string.charAt(i)\
    \ == ' ' && curr_paren == \"\"){\n                curr_paren = paren_string.charAt(i);\n\
    \            }\n            else if (paren_string.charAt(i) == ')' && curr_paren\
    \ != \"\"){\n                curr_paren = paren_string.charAt(i);\n          \
    \  }\n            else if (paren_string.charAt(i) == '(' && curr_paren != \"\"\
    ){\n                curr_paren = paren_string.charAt(i);\n            }\n    \
    \        else if (paren_string.charAt(i) != ' ' && paren_string.charAt(i) != ')'\
    \ && paren_string.charAt(i) != '('){\n                curr_paren = paren_string.charAt(i);\n\
    \            }\n        }\n        return paren_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3__6fbzp.java:36: error: incompatible types: char cannot be converted\
    \ to String\n                curr_paren = paren_string.charAt(i);\n          \
    \                                      ^\n/tmp/tmp3__6fbzp.java:39: error: incompatible\
    \ types: char cannot be converted to String\n                curr_paren = paren_string.charAt(i);\n\
    \                                                ^\n/tmp/tmp3__6fbzp.java:42:\
    \ error: incompatible types: char cannot be converted to String\n            \
    \    curr_paren = paren_string.charAt(i);\n                                  \
    \              ^\n/tmp/tmp3__6fbzp.java:45: error: incompatible types: char cannot\
    \ be converted to String\n                curr_paren = paren_string.charAt(i);\n\
    \                                                ^\n4 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<Integer>();\n        ArrayList <String> group_stack = new ArrayList\
    \ <String>();\n        int group_level = 0;\n        for (char c : paren_string.toCharArray())\
    \ {\n            switch (c) {\n                case '(':\n                   \
    \ group_stack.add(\"\" + c);\n                    levels.add(group_level);\n \
    \                   group_level++;\n                    break;\n             \
    \   case ')':\n                    int group_depth = levels.get(group_stack.size()\
    \ - 1);\n                    if (group_depth >= levels.size()) throw new RuntimeException(\"\
    Inconsistent input\");\n                    levels.add(group_depth);\n       \
    \             group_stack.remove(group_stack.size() - 1);\n                  \
    \  break;\n                default:\n                    if (group_stack.size()\
    \ == 0) {\n                        throw new RuntimeException(\"Inconsistent input\"\
    );\n                    }\n                    group_stack.add(\"\" + c);\n  \
    \                  break;\n            }\n        }\n        return levels;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2pqq5ixg.java:40: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> paren_levels\
    \ = new ArrayList<Integer>();\n        for (String str : paren_string.split(\"\
    \\\\s\")) {\n            paren_levels.add(getLevel(str));\n        }\n       \
    \ return paren_levels;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp242ttzeu.java:17: error: cannot find symbol\n            paren_levels.add(getLevel(str));\n\
    \                             ^\n  symbol:   method getLevel(String)\n  location:\
    \ class Problem\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        String s = paren_string;\n        while (s.startsWith(\"\
    (\") && s.endsWith(\")\")) {\n            int depth = 0;\n            while (s.startsWith(\"\
    (\") && s.endsWith(\")\")) {\n                if (s.startsWith(\"(\")) {\n   \
    \                 depth += 1;\n                } else {\n                    depth\
    \ -= 1;\n                }\n                s = s.substring(1);\n            }\n\
    \            results.add(depth);\n            s = s.substring(1, s.length() -\
    \ 1);\n        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmprigcca7a.java:31: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<Integer>();\n        int nesting_level = 0;\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            int j = i;\n         \
    \   int k = i;\n            int num_open = 0;\n            for (; j > 0 && paren_string.charAt(j\
    \ - 1) == '('; j--, k++, nesting_level++) {\n                ++num_open;\n   \
    \         }\n            while (k < paren_string.length() && (paren_string.charAt(k)\
    \ == ' ' || paren_string.charAt(k) == ')')) {\n                ++num_open;\n \
    \               k++;\n            }\n            while (j < paren_string.length()\
    \ && paren_string.charAt(j) == ' ') {\n                j++;\n            }\n \
    \           if (num_open == nesting_level) {\n                results.add(nesting_level);\n\
    \            }\n        }\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgkaxlbla.java:36: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> list_of_levels\
    \ = new ArrayList<Integer>();\n        for(int i = 0; i < paren_string.length();\
    \ i++){\n            if(paren_string.charAt(i) == '('){\n                list_of_levels.add(i\
    \ + 1);\n            }\n            else if (paren_string.charAt(i) == ')'){\n\
    \                list_of_levels.remove(list_of_levels.get(list_of_levels.size()\
    \ - 1));\n            }\n        }\n        return list_of_levels;\nreturn new\
    \ ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmprei3sm2q.java:25: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        for (int i = 0; i < paren_string.length(); i++)\
    \ {\n            if (paren_string.charAt(i) == '(') {\n                int level\
    \ = 1;\n                for (int j = i; j < paren_string.length(); j++) {\n  \
    \                  if (paren_string.charAt(j) == ')') {\n                    \
    \    result.add(level);\n                        i = j + 1;\n                \
    \        level++;\n                        break;\n                    }\n   \
    \             }\n            }\n        }\n        return result;\nreturn new\
    \ ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmppw1ihf48.java:30: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        if (paren_string.length() == 0) {\n          \
    \  results.add(0);\n        }\n        String s = paren_string.trim();\n     \
    \   if (s.startsWith(\"(\")) {\n            results.add(0);\n        }\n     \
    \   if (s.endsWith(\")\")) {\n            results.add(0);\n        }\n\n     \
    \   // Step 1. Get all the paren group lengths.\n        ArrayList<Integer> paren_lengths\
    \ = getParenGroupLengths(s);\n\n        // Step 2. Scan all the lengths and find\
    \ the deepest level.\n        for (int i = 0; i < paren_lengths.size(); i++) {\n\
    \            int current_length = paren_lengths.get(i);\n            if (current_length\
    \ > results.get(i)) {\n                results.set(i, current_length);\n     \
    \       }\n        }\n\n        // Step 3. Convert lengths to lengths of groups.\n\
    \        ArrayList<Integer> paren_group_lengths = new ArrayList<>();\n       \
    \ for (int i = 0; i < paren_lengths.size(); i++) {\n            int current_length\
    \ = paren_lengths.get(i);\n            for (int j = 0; j < current_length; j++)\
    \ {\n                paren_group_lengths.add(i);\n            }\n        }\n\n\
    \        // Step 4. Scan the groups until we find a deeper level.\n        for\
    \ (int i = 0; i < paren_group_lengths.size(); i++) {\n            int current_group_length\
    \ = paren_group_lengths.get(i);\n            if (current_group_length > 0) {\n\
    \                ArrayList<Integer> next_group_lengths = new ArrayList<>();\n\
    \                for (int j = 0; j < paren_group_lengths.size(); j++) {\n    \
    \                int next_group_length = paren_group_lengths.get(j);\n       \
    \             if (j == i) {\n                        next_group_lengths.add(current_group_length);\n\
    \                        break;\n                    }\n                    next_group_lengths.add(next_group_length);\n\
    \                }\n                while (next_group_lengths.size() > 0) {\n\
    \                    next_group_lengths.remove(0);\n                }\n      \
    \          results.addAll(next_group_lengths);\n            }\n        }\n   \
    \     return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp49baa888.java:28: error: cannot find symbol\n        ArrayList<Integer>\
    \ paren_lengths = getParenGroupLengths(s);\n                                 \
    \          ^\n  symbol:   method getParenGroupLengths(String)\n  location: class\
    \ Problem\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<>();\n        Queue<Integer> stack = new LinkedList<>();\n \
    \       StringBuilder stringBuilder = new StringBuilder();\n        for (char\
    \ c : paren_string.toCharArray()) {\n            if (c == '(' || c == ')') {\n\
    \                stringBuilder.append(c);\n                result.add(stringBuilder.length());\n\
    \                if (stack.size() == 0)\n                    result.add(1);\n\
    \                stack.offer(stringBuilder.length());\n            }\n       \
    \     else if (c == ' ') {\n                if (stringBuilder.length() != 0) {\n\
    \                    result.add(stringBuilder.length());\n                }\n\
    \                stringBuilder = new StringBuilder();\n            }\n       \
    \     else if (c == ')') {\n                if (stringBuilder.length() != 0)\n\
    \                    result.add(stringBuilder.length());\n                while\
    \ (stack.size() > 0 && stack.poll().equals(result.size())) {\n               \
    \     result.add(stack.poll());\n                }\n                stringBuilder\
    \ = new StringBuilder();\n            }\n        }\n        return result;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpha5ywrjs.java:42: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> results\
    \ = new ArrayList<>();\n        int currentLevel = 0;\n        Stack<Integer>\
    \ parenStack = new Stack<>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(')\
    \ {\n                parenStack.push(i);\n            } else if (c == ')') {\n\
    \                int parenCount = parenStack.size() - 1;\n                if (parenCount\
    \ > 0) {\n                    if (parenStack.peek() == currentLevel) {\n     \
    \                   currentLevel--;\n                    } else {\n          \
    \              currentLevel++;\n                    }\n                }\n   \
    \             parenStack.pop();\n            }\n        }\n        for (int i\
    \ = 0; i < parenStack.size(); i++) {\n            int parenCount = parenStack.size()\
    \ - 1;\n            if (parenCount > 0) {\n                if (parenStack.peek()\
    \ == currentLevel) {\n                    currentLevel--;\n                } else\
    \ {\n                    currentLevel++;\n                }\n            }\n \
    \       }\n        results.add(currentLevel);\n        return results;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpywfx4fb2.java:46: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Initialize an empty array\
    \ that will store each parenthetic group's depth of nesting\n        ArrayList<Integer>\
    \ max_nested_depth = new ArrayList<>();\n\n        // Initialize empty stack to\
    \ store depth of nesting of a parenthetic group\n        Stack<Integer> stack\
    \ = new Stack<>();\n\n        // Parse parenthetic groups from input\n       \
    \ for(String group : paren_string.split(\" \")){\n            // Add group's depth\
    \ to stack\n            stack.push(group.length());\n        }\n\n        // If\
    \ parenthetic groups are left with empty strings, stop here\n        while(!stack.isEmpty()){\n\
    \            // Pop a group's depth of nesting from the stack and add it to the\
    \ max_nested_depth array\n            max_nested_depth.add(stack.pop());\n   \
    \     }\n\n        // Return max_nested_depth array as a list\n        return\
    \ max_nested_depth;\nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmphohk0u60.java:35: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> max_levels_of_nesting\
    \ = new ArrayList<>();\n        ArrayList<Integer> current_levels_of_nesting =\
    \ new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n\n       \
    \ for(int i = 0; i < paren_string.length(); ++i) {\n            char c = paren_string.charAt(i);\n\
    \            if(Character.isWhitespace(c)) {\n                continue;\n    \
    \        }\n            char next_c = paren_string.charAt(i + 1);\n          \
    \  if(Character.isWhitespace(next_c)) {\n                stack.add(String.valueOf(Character.toUpperCase(c)));\n\
    \                continue;\n            }\n            if(c == '(') {\n      \
    \          current_levels_of_nesting.add(0, 0);\n            }\n            else\
    \ if(Character.toUpperCase(c) != '(') {\n                current_levels_of_nesting.remove(0);\n\
    \                stack.remove(String.valueOf(Character.toUpperCase(c)));\n   \
    \         }\n            if(next_c == '(') {\n                next_c = paren_string.charAt(i\
    \ + 2);\n                if(Character.isWhitespace(next_c)) {\n              \
    \      stack.add(String.valueOf(Character.toUpperCase(next_c)));\n           \
    \         i += 2;\n                    continue;\n                }\n        \
    \        if(c == '(') {\n                    current_levels_of_nesting.add(1,\
    \ 1);\n                }\n                else if(Character.toUpperCase(c) !=\
    \ '(') {\n                    current_levels_of_nesting.remove(1);\n         \
    \           stack.remove(String.valueOf(Character.toUpperCase(c)));\n        \
    \        }\n                if(next_c == '(') {\n                    next_c =\
    \ paren_string.charAt(i + 3);\n                    if(Character.isWhitespace(next_c))\
    \ {\n                        stack.add(String.valueOf(Character.toUpperCase(next_c)));\n\
    \                        i += 3;\n                        continue;\n        \
    \            }\n                    if(c == '(') {\n                        current_levels_of_nesting.add(2,\
    \ 2);\n                    }\n                    else if(Character.toUpperCase(c)\
    \ != '(') {\n                        current_levels_of_nesting.remove(2);\n  \
    \                      stack.remove(String.valueOf(Character.toUpperCase(c)));\n\
    \                    }\n                    if(next_c == '(') {\n            \
    \            next_c = paren_string.charAt(i + 4);\n                        if(Character.isWhitespace(next_c))\
    \ {\n                            stack.add(String.valueOf(Character.toUpperCase(next_c)));\n\
    \                            i += 4;\n                            continue;\n\
    \                        }\n                        if(c == '(') {\n         \
    \                   current_levels_of_nesting.add(3, 3);\n                   \
    \     }\n                        else if(Character.toUpperCase(c) != '(') {\n\
    \                            current_levels_of_nesting.remove(3);\n          \
    \                  stack.remove(String.valueOf(Character.toUpperCase(c)));\n \
    \                       }\n                    }\n                }\n        \
    \    }\n            current_levels_of_nesting.add(stack.isEmpty() ? 0 : stack.pop());\n\
    \        }\n        for(int level : current_levels_of_nesting) {\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1wfukdjo.java:86: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n/tmp/tmp1wfukdjo.java:86: error: illegal\
    \ start of expression\n    public static void main(String[] args) {\n        \
    \   ^\n/tmp/tmp1wfukdjo.java:86: error: ';' expected\n    public static void main(String[]\
    \ args) {\n                 ^\n/tmp/tmp1wfukdjo.java:86: error: '.class' expected\n\
    \    public static void main(String[] args) {\n                              \
    \       ^\n/tmp/tmp1wfukdjo.java:86: error: ';' expected\n    public static void\
    \ main(String[] args) {\n                                         ^\n/tmp/tmp1wfukdjo.java:92:\
    \ error: reached end of file while parsing\n}\n ^\n6 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> result\
    \ = new ArrayList<Integer>();\n        int[] count = new int[paren_string.length()];\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                if (count[i - 1] == 0)\n                    count[i\
    \ - 1]++;\n                else {\n                    count[i - 1]++;\n     \
    \               if (count[i - 1] > result.size())\n                        result.add(i\
    \ - 1);\n                }\n            } else if (paren_string.charAt(i) == ')')\
    \ {\n                count[i - 1]--;\n            }\n        }\n        if (Arrays.stream(count).sum()\
    \ < 0)\n            result.add(result.size() - 1);\n        return result;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmplnxy3y_1.java:33: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        ArrayList<Integer> level_count = new ArrayList<>();\n\
    \        int level = 0;\n        for (int i = 0; i < paren_string.length(); i++)\
    \ {\n            char c = paren_string.charAt(i);\n            switch (c) {\n\
    \                case '(':\n                    level++;\n                   \
    \ break;\n                case ')':\n                    level--;\n          \
    \          levels.add(level);\n                    level_count.add(level);\n \
    \                   break;\n            }\n        }\n        return level_count;\n\
    return new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkc1y9lf1.java:32: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // For each '(' we insert\
    \ an element in our Stack and each ')' we remove one from our Stack.\n       \
    \ Stack<Integer> stack_of_opening_parentheses = new Stack<Integer>();\n      \
    \  Stack<Integer> stack_of_closing_parentheses = new Stack<Integer>();\n\n   \
    \     // We iterate over each character of the string and insert '(' and ')'\n\
    \        // if they meet a condition (i.e., they have different characters).\n\
    \        // We then count the number of elements in the Stack.\n        // We\
    \ then return the element with the highest number of elements.\n        // If\
    \ there are multiple elements with equal numbers, we return the smallest one.\n\
    \        for (char c : paren_string.toCharArray()) {\n            if (c == '(')\
    \ {\n                stack_of_opening_parentheses.push(c);\n            } else\
    \ if (c == ')') {\n                if (stack_of_closing_parentheses.size() > stack_of_opening_parentheses.size())\
    \ {\n                    stack_of_closing_parentheses.push(c);\n             \
    \   } else if (stack_of_closing_parentheses.size() < stack_of_opening_parentheses.size())\
    \ {\n                    stack_of_opening_parentheses.push(c);\n             \
    \   }\n            }\n        }\n\n        // Once we finish, we know the number\
    \ of opening parentheses and the number of closing parentheses.\n        // We\
    \ now need to loop through the Stack and compare the elements to find which one\
    \ has the highest number of elements.\n        int num_of_opening_parentheses\
    \ = stack_of_opening_parentheses.size();\n        int num_of_closing_parentheses\
    \ = stack_of_closing_parentheses.size();\n        ArrayList<Integer> max_num_of_opening_parentheses_elements\
    \ = new ArrayList<Integer>();\n        ArrayList<Integer> max_num_of_closing_parentheses_elements\
    \ = new ArrayList<Integer>();\n\n        for (int i = 0; i < num_of_opening_parentheses;\
    \ i++) {\n            // If we are closing parentheses, we must stop comparing\
    \ elements with the lowest number of elements.\n            if (stack_of_closing_parentheses.isEmpty())\
    \ {\n                break;\n            }\n\n            // We get the element\
    \ at the top of the Stack so we can compare it to all elements in the Stack.\n\
    \            Integer opening_parentheses = stack_of_opening_parentheses.peek();\n\
    \            int num_of_elements = stack_of_opening_parentheses.size();\n\n  \
    \          for (int j = 0; j < num_of_elements; j++) {\n                Integer\
    \ current_element = stack_of_opening_parentheses.peek();\n\n                //\
    \ If the number of opening parentheses elements equals the number of closing parentheses\
    \ elements, then we know that\n                // the elements at the top of the\
    \ Stack are equal, so we know that they are the deepest level of nesting.\n  \
    \              // We set the element at the top of the Stack as the deepest level\
    \ of nesting.\n                if (num_of_opening_parentheses == num_of_closing_parentheses)\
    \ {\n                    max_num_of_opening_parentheses_elements.add(current_element);\n\
    \                    break;\n                }\n\n                // If the current\
    \ level of nesting between the opening and closing parentheses is equal to the\
    \ \nreturn new ArrayList<Integer>(Arrays.asList());\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2, (int)3,\
    \ (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3, (int)4)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n\
    \    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmppg4dd3fa.java:67: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n/tmp/tmppg4dd3fa.java:67: error: illegal\
    \ start of expression\n    public static void main(String[] args) {\n        \
    \   ^\n/tmp/tmppg4dd3fa.java:67: error: ';' expected\n    public static void main(String[]\
    \ args) {\n                 ^\n/tmp/tmppg4dd3fa.java:67: error: '.class' expected\n\
    \    public static void main(String[] args) {\n                              \
    \       ^\n/tmp/tmppg4dd3fa.java:67: error: ';' expected\n    public static void\
    \ main(String[] args) {\n                                         ^\n/tmp/tmppg4dd3fa.java:73:\
    \ error: reached end of file while parsing\n}\n ^\n6 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Initialize a list to store\
    \ our results.\n        ArrayList<Integer> results = new ArrayList<Integer>();\n\
    \n        // For each character in the input string...\n        for (char c :\
    \ paren_string.toCharArray()) {\n            // If the character is a left paren...\n\
    \            if (c == '(') {\n                // If our stack is empty, increment\
    \ our current result by 1.\n                if (results.isEmpty())\n         \
    \           results.add(1);\n                else {\n                    // Otherwise,\
    \ decrement the top of our result by 1.\n                    int top = results.get(results.size()\
    \ - 1);\n                    results.set(results.size() - 1, top - 1);\n     \
    \           }\n            }\n            // Else, if the character is a right\
    \ paren...\n            else if (c == ')') {\n                // If our stack\
    \ is not empty...\n                if (results.size() > 0) {\n               \
    \     // And if we have a left paren, decrement the top of our result by 1.\n\
    \                    if (results.get(0) == '(')\n                        results.set(results.size()\
    \ - 1, results.get(results.size() - 1) - 1);\n                }\n            }\n\
    \            // Else, just add the current character to our stack.\n         \
    \   else\n                results.add(c);\n        }\n\n        // Return the\
    \ list of results.\n        return results;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjdd3xr36.java:42: error: no suitable method found for add(char)\n\
    \                results.add(c);\n                       ^\n    method Collection.add(Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    \    method List.add(Integer) is not applicable\n      (argument mismatch; char\
    \ cannot be converted to Integer)\n    method AbstractCollection.add(Integer)\
    \ is not applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    \    method AbstractList.add(Integer) is not applicable\n      (argument mismatch;\
    \ char cannot be converted to Integer)\n    method ArrayList.add(Integer) is not\
    \ applicable\n      (argument mismatch; char cannot be converted to Integer)\n\
    Note: Some messages have been simplified; recompile with -Xdiags:verbose to get\
    \ full output\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        // Initialize and fill the\
    \ list\n        ArrayList<Integer> list = new ArrayList<Integer>();\n        //\
    \ Create a stack of type Stack<Character>\n        Stack<Character> stack = new\
    \ Stack<Character>();\n        // Go through each character in the string\n  \
    \      for(int i = 0; i < paren_string.length(); i++) {\n            // Get character\
    \ at index i\n            char c = paren_string.charAt(i);\n            // If\
    \ the character is a left parentheses, push it onto the stack\n            if(c\
    \ == '(') {\n                stack.push(c);\n            }\n            // If\
    \ the character is a right parentheses, pop the stack until the stack is empty\n\
    \            if(c == ')') {\n                // If the stack is empty, the parentheses\
    \ were unbalanced\n                if(stack.empty()) {\n                    return\
    \ new ArrayList<Integer>();\n                }\n                // Get the top\
    \ element in the stack\n                char top_element = stack.pop();\n    \
    \            // If the top element is a left parentheses, push the stack onto\
    \ the list\n                if(top_element == '(') {\n                    list.add(list.size());\n\
    \                }\n            }\n        }\n        // Return the list that\
    \ was created above\n        return list;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkil4ui7r.java:43: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> num_list\
    \ = new ArrayList<>();\n        ArrayList<Integer> stack = new ArrayList<>();\n\
    \        stack.add(0);\n        int current_level = 1;\n        Stack<Integer>\
    \ stack_new = new Stack<>();\n        stack_new.add(0);\n\n        for (int i\
    \ = 0; i < paren_string.length(); i++) {\n            char curr_char = paren_string.charAt(i);\n\
    \            if (curr_char == '(') {\n                stack.add(current_level);\n\
    \                stack_new.add(current_level);\n                current_level++;\n\
    \            } else if (curr_char == ')') {\n                int top = stack.get(stack.size()\
    \ - 1);\n                while (top > 1) {\n                    num_list.add(top\
    \ - 1);\n                    top--;\n                }\n                stack.remove(stack.size()\
    \ - 1);\n                stack_new.remove(stack_new.size() - 1);\n           \
    \     current_level--;\n            }\n        }\n        return num_list;\nreturn\
    \ new ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_gktoon5.java:40: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> output\
    \ = new ArrayList<Integer>();\n        int level = 0;\n        int stack_count\
    \ = 0;\n        for (char c : paren_string.toCharArray()) {\n            switch\
    \ (c) {\n                case '(':\n                    output.add(level);\n \
    \                   level++;\n                    break;\n                case\
    \ ')':\n                    level--;\n                    if (level == 0) {\n\
    \                        stack_count++;\n                    } else {\n      \
    \                  stack_count--;\n                    }\n                   \
    \ break;\n                default:\n                    break;\n            }\n\
    \        }\n        if (stack_count == 0 && level > 0) {\n            level--;\n\
    \        }\n        output.add(level);\n        return output;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyduw35b0.java:41: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> levels\
    \ = new ArrayList<>();\n        ArrayList<Character> chars = new ArrayList<>();\n\
    \        ArrayList<Integer> current_levels = new ArrayList<>();\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            if (c == '(') levels.add(0);\n            else if (c == ')') {\n\
    \                int l = levels.get(levels.size() - 1);\n                if (current_levels.size()\
    \ == 0) {\n                    levels.add(l);\n                    chars.add(c);\n\
    \                } else {\n                    int level_difference = Math.abs(current_levels.get(current_levels.size()\
    \ - 1) - l);\n                    if (level_difference > 1) {\n              \
    \          levels.add(l);\n                        chars.add(c);\n           \
    \             current_levels.add(l);\n                    }\n                }\n\
    \            }\n            if (c == '(') {\n                current_levels.add(0);\n\
    \            } else {\n                current_levels.add((chars.size() - 1) +\
    \ chars.size());\n            }\n        }\n        return levels;\nreturn new\
    \ ArrayList<Integer>(Arrays.asList());\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)2, (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1,\
    \ (int)2, (int)3, (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx4iit4z_.java:42: error: unreachable statement\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    ^\n1 error\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> stack =\
    \ new ArrayList<Integer>();\n        for(int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if(c == '(')\
    \ {\n                stack.push(i);\n            }\n            if(c == ')') {\n\
    \                int index = stack.pop();\n                int current_length\
    \ = i - index - 1;\n                if(stack.isEmpty()) {\n                  \
    \  // Only one item on the stack\n                    if(current_length >= 2)\
    \ {\n                        stack.push(current_length);\n                   \
    \ }\n                } else {\n                    // Two or more items on the\
    \ stack\n                    if(current_length >= 2) {\n                     \
    \   stack.push(current_length + 1);\n                    }\n                }\n\
    \            }\n        }\n        return stack;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk6lvxvbe.java:19: error: cannot find symbol\n                stack.push(i);\n\
    \                     ^\n  symbol:   method push(int)\n  location: variable stack\
    \ of type ArrayList<Integer>\n/tmp/tmpk6lvxvbe.java:22: error: cannot find symbol\n\
    \                int index = stack.pop();\n                                 ^\n\
    \  symbol:   method pop()\n  location: variable stack of type ArrayList<Integer>\n\
    /tmp/tmpk6lvxvbe.java:27: error: cannot find symbol\n                        stack.push(current_length);\n\
    \                             ^\n  symbol:   method push(int)\n  location: variable\
    \ stack of type ArrayList<Integer>\n/tmp/tmpk6lvxvbe.java:32: error: cannot find\
    \ symbol\n                        stack.push(current_length + 1);\n          \
    \                   ^\n  symbol:   method push(int)\n  location: variable stack\
    \ of type ArrayList<Integer>\n4 errors\n"
  exit_code: 1
  status: SyntaxError
- program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    public static ArrayList<Integer>\
    \ parseNestedParens(String paren_string) {\n        ArrayList<Integer> return_val\
    \ = new ArrayList<Integer>();\n\n        // Use a stack to check whether the parenthesis\
    \ is balanced.\n        // Start with a stack of size zero and push all open parentheses.\n\
    \        Stack<String> stack = new Stack<String>();\n        for (char c : paren_string.toCharArray())\
    \ {\n            if (c == '(') {\n                stack.push(c);\n           \
    \ } else if (c == ')') {\n                if (stack.size() > 0) {\n          \
    \          return_val.add(stack.size());\n                }\n                stack.pop();\n\
    \            }\n        }\n        return return_val;\nreturn new ArrayList<Integer>(Arrays.asList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Integer>(Arrays.asList((int)2,\
    \ (int)3, (int)1, (int)3)))));\n    assert(parseNestedParens((\"() (()) ((()))\
    \ (((())))\")).equals((new ArrayList<Integer>(Arrays.asList((int)1, (int)2, (int)3,\
    \ (int)4)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Integer>(Arrays.asList((int)4)))));\n    }\n\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq62j_hzx.java:22: error: incompatible types: char cannot be converted\
    \ to String\n                stack.push(c);\n                           ^\nNote:\
    \ Some messages have been simplified; recompile with -Xdiags:verbose to get full\
    \ output\n1 error\n"
  exit_code: 1
  status: SyntaxError
