completions:
- "        int res = 1;\n        while ((n /= 2) != 1) {\n            res *= n;\n\
  \        }\n        return ((n % p + p) % p == 0) ? res : n % p;"
- '        return ((long) Math.pow(2, n)) % (long) p;'
- "        // https://stackoverflow.com/questions/7106539/java-modulus-operator-for-negative-numbers\n\
  \        // if n is negative, return 1\n        if (n < 0)\n            return 1;\n\
  \n        // otherwise if n is 0 or 1, return n\n        if (n == 0)\n         \
  \   return n;\n        if (n == 1)\n            return n;\n\n        // otherwise,\
  \ return the correct answer\n        return ((n % p) + p) % p;"
- "        int result = (int)Math.pow(2, n) % p;\n        return result;"
- "        int rem = n;\n        while(p > 0 && rem % p != 0) {\n            rem =\
  \ (int)(rem / p);\n        }\n        return rem;"
- "        BigInteger p = BigInteger.valueOf(p);\n        BigInteger q = BigInteger.valueOf(2).pow(n);\n\
  \        BigInteger q = p.multiply(q);\n        BigInteger result = q.mod(p);\n\
  \        return result.intValue();"
- "        long res = 0;\n        for (long i = n; i < p; i++) res = (1LL << i) %\
  \ p;\n        return (int) res;"
- "        int x = p - (p >> 1) + (n >> 1) + (n >> 2) + (n >> 3) + (n >> 4);\n   \
  \     return ((x & -p) + (p >> 1)) & p;"
- "        int res = 1;\n        while (n > p) {\n            res = (res * (n - p\
  \ + 1))%p;\n            n--;\n        }\n        return res;"
- '        return (int)(Math.pow(Math.pow(2,n), p));'
- "        int res = 1;\n        for (int i = 0; i < n; ++i) {\n            res =\
  \ (res * p) % p;\n        }\n        return res;"
- "        int res = 1;\n        while (n != 0) {\n            int tmp = n / p;\n\
  \            res = (res * p + n % p) % p;\n            n = tmp;\n        }\n   \
  \     return res;"
- "        int x = 2;\n        while (n-- != 0) {\n            x = x * x % p;\n  \
  \      }\n        return x;"
- "        int r = n % (int) p;\n        int d = p - 1;\n        int f = 1;\n    \
  \    while (r != 0) {\n            if (d > r) {\n                f += d;\n     \
  \           d = r;\n            }\n            d /= 2;\n            r = (r * f)\
  \ % (int) p;\n        }\n        return f;"
- "        int q = n % p;\n        if (q == 0) {\n            return 1;\n        }\n\
  \        if ((q > 0) && (q % 2 == 0)) {\n            return modp((n / p), p) * modp((p\
  \ / q), p);\n        }\n        if (p == q) {\n            return 1;\n        }\n\
  \        if (p % 2 == 1) {\n            return modp((n / p), p) * modp((n / q),\
  \ q);\n        }\n        return modp((n / p), q) * modp((n / q), p);"
- "        if (n == 0) {\n            return 1;\n        } else if (n < 1) {\n   \
  \         throw new RuntimeException(\"modp(\" + n + \", \" + p + \"): n < 1\");\n\
  \        } else {\n            int r = 1;\n            int p = p%n;\n          \
  \  while (p != 0) {\n                if (p%2 != 0) {\n                    r += 1;\n\
  \                }\n                p = p/2;\n            }\n            return\
  \ r;\n        }"
- "        int res = 1;\n        while (n>1) {\n            if (n & 1) {\n       \
  \         res = (res * 2) % (p);\n            }\n            n = n >> 1;\n     \
  \   }\n        return res + p;"
- "        if (n < 0) throw new RuntimeException(\"modp(\" + n + \", \" + p + \")\
  \ should be non-negative\");\n        if (p == 1) return n;\n        if (p == 0)\
  \ return 1;\n        if (p == -1) return -1; // if p is negative, return -1\n  \
  \      int q = p; // we'll be doing division\n        int r = 1;\n        while\
  \ (q < n) {\n            int x = q % p;\n            q = p;\n            p = r;\n\
  \            r = x * p;\n        }\n        if (q == n) r = 1;\n        return r;"
- '        return ((n & (p-1)) + (n >> 1 & -p)) % p;'
- "        if (p == 0) return 1;\n        if (p == 1) return n;\n        if (p ==\
  \ -1) return n;\n        int dp = p;\n        int q;\n        if (n < 0) {\n   \
  \         q = modp(-n, p);\n            if (q < 0) return -q;\n            n ^=\
  \ q;\n            q = 0;\n        } else if (n == 0) {\n            q = 0;\n   \
  \     } else if (n < p) {\n            q = modp(-n, p);\n            if (q < 0)\
  \ return -q;\n            n ^= q;\n            q = 0;\n        } else if (n == p)\
  \ {\n            q = modp(1, p);\n            if (q < 0) return -q;\n          \
  \  return q;\n        }\n        do {\n            q = dp;\n            dp <<= 1;\n\
  \            n ^= dp;\n        } while (q != 0);\n        return n;"
- "        long res = 1L;\n        while (n>0) {\n            res = (res * n) % p;\n\
  \            n /= 2;\n        }\n        return (int) res;"
- "        int result = 1;\n        while ((n % p) != 0) {\n            result *=\
  \ 2;\n            n /= p;\n        }\n        return n % p ? result : 1;"
- "        int res = 1;\n        while (n > 0) {\n            int tmp = n % p;\n \
  \           res = (res * tmp) % p;\n            n = (n - tmp) / p;\n        }\n\
  \        return res;"
- "        if (n == 0)\n            return 1;\n        int res = n % p;\n        if\
  \ (res == 0)\n            return modp(n / p, p);\n        return modp(n / p, p)\
  \ + 1;"
- "        int res = 1;\n        while (n != 0) {\n            n &= n - 1;\n     \
  \       res *= p;\n        }\n        return res;"
- "        int bits = Integer.bitCount(n);\n        int mask = 1 << (bits - 1);\n\
  \        int res = n & mask;\n        while (n > 1) {\n            n = n >> 1;\n\
  \            bits = Integer.bitCount(n);\n            mask = 1 << (bits - 1);\n\
  \            res = (res << 1) + n & mask;\n        }\n        return res % p;"
- "        if (n == 0)\n            return 1;\n        if (p == 0)\n            return\
  \ n;\n        if (p == 1)\n            return n;\n        if (n % 2 == 0)\n    \
  \        return modp(n / 2, p);\n        else\n            return modp(n / 2, p\
  \ * p) % p;"
- '        return n % p;'
- '        return ((1 << n) & p) ^ (p >> n); // xor with p to force modulo.'
- "        // Use bitwise operators to avoid overflows.\n        if (n < 0)\n    \
  \        return -modp(-n, p);\n        if (n >= p)\n            return n;\n    \
  \    return n % p;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (p == 0) {\n\
  \            return 0;\n        }\n        int r = 1;\n        for (int i = 31;\
  \ i >= 1; i--) {\n            int t = n % i;\n            if (t != 0) {\n      \
  \          t = p - t;\n                if (t < 0) {\n                    t += i;\n\
  \                }\n                r = r * t % i;\n            }\n            n\
  \ = n / i;\n        }\n        return r;"
- "        List<Integer> list = new ArrayList<Integer>(Arrays.asList(new int[]{n}));\n\
  \        while (list.size() > 1) {\n            list.remove(0);\n            int\
  \ tmp = list.get(0);\n            int r1 = tmp & ((1 << list.size()) - 1);\n   \
  \         int r2 = (r1 << list.size()) - 1;\n            list.remove(0);\n     \
  \       list.add(tmp + r2);\n        }\n        if (list.size() == 0) {\n      \
  \      return 0;\n        } else {\n            return list.get(0);\n        }"
- "        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < n; ++i)\
  \ {\n            result = result.multiply(BigInteger.valueOf(2).pow(i))\n      \
  \          .mod(BigInteger.valueOf(p));\n        }\n        return result.intValue();"
- "        // We do 2^(n+p) modulo p, which is equivalent to (2**n) % p + p.\n   \
  \     // We do this by finding the largest power of 2 <= p, adding p to it\n   \
  \     // (we only need to do this for p <= 32), and taking mod'ing that\n      \
  \  // number.  Since p is necessarily a power of 2, we can do this in\n        //\
  \ constant time.\n        if (p > 32) throw new ArithmeticException(\"Only power\
  \ of 2 allowed\");\n        int max = (int) Math.pow(2, n);\n        return (max\
  \ % p + p) % p;"
- "        int mod = 1 << n;\n        while ( p > mod ) {\n            mod += mod;\n\
  \        }\n        mod %= p;\n        return mod;"
- "        if (n >= p) {\n            n = n - p;\n        }\n        if (n == 0) {\n\
  \            return 1;\n        }\n        return modp(n / 2, p) * 2 * n % p;"
- "        int r = 1;\n        while (n != 0) {\n            int x = n & -p;\n   \
  \         n ^= x;\n            r ^= x;\n        }\n        return r;"
- '        return n % p == 0 ? n : ((n / p) % p) * p;'
- "        // TODO: replace with Math.pow()?\n        return ((long) Math.pow(2.0,\
  \ n)) % ((long) Math.pow(p, 2));"
- "        if (n < 0) {\n            throw new IllegalArgumentException(\"negative\
  \ n\");\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"\
  negative p\");\n        }\n        BigInteger result = BigInteger.ONE;\n       \
  \ while (n!=1) {\n            BigInteger next = BigInteger.valueOf(2).modPow(n,\
  \ p);\n            if (next.compareTo(result)>0) {\n                result = next;\n\
  \            }\n            n = next;\n        }\n        return result.intValue();"
- "        final BigInteger pow2 = BigInteger.valueOf(2);\n        final BigInteger\
  \ pow4 = BigInteger.valueOf(4);\n        BigInteger remainder = BigInteger.ZERO;\n\
  \        BigInteger dividend = BigInteger.valueOf(1);\n        for (int i = 0; i\
  \ < 31; i++) {\n            dividend = dividend.multiply(pow2);\n            if\
  \ (n % dividend == 0) {\n                BigInteger quotient = dividend.divide(p);\n\
  \                BigInteger modulo = quotient.mod(p);\n                if (modulo.equals(BigInteger.ZERO))\
  \ {\n                    return 0;\n                }\n                BigInteger\
  \ quotientModulus = quotient.mod(BigInteger.valueOf(p));\n                BigInteger\
  \ modulus = quotientModulus.mod(p);\n                if (modulus.equals(BigInteger.ZERO))\
  \ {\n                    return 1;\n                }\n                BigInteger\
  \ remainder = quotient.subtract(modulo).multiply(\n                        modulo.divide(p));\n\
  \                dividend = quotientModulus.multiply(remainder);\n             \
  \   remainders.add(remainder);\n                n = modulo.multiply(modulo).subtract(BigInteger.ONE);\n\
  \            }\n        }\n        final List<BigInteger> remainders = Stream.generate(()\
  \ -> BigInteger.ZERO)\n                .limit(31).collect(Collectors.toList());\n\
  \        BigInteger result = BigInteger.ZERO;\n        BigInteger product = BigInteger.ONE;\n\
  \        for (int i = 0; i < 31; i++) {\n            BigInteger bigIntMultiply =\
  \ product.multiply(BigInteger.valueOf(p));\n            BigInteger bigIntModulus\
  \ = bigIntMultiply.mod(p);\n            if (bigIntModulus.equals(BigInteger.ZERO))\
  \ {\n                result = bigIntMultiply;\n            } else {\n          \
  \      BigInteger bigIntDivide = bigIntModulus.divide(p);\n                BigInteger\
  \ bigIntRemainder = bigIntDivide.subtract(BigInteger.ONE)\n                    \
  \    .multiply(bigIntDivide);\n                BigInteger bigIntQuotient = bigIntRemainder.divide(p);\n\
  \                BigInteger bigIntModulus = bigIntQuotient.mod(p);\n           \
  \     if (bigIntModulus.equals(BigInteger.ZERO)) {\n                    result =\
  \ bigIntQuotient;\n                } else {\n                    BigInteger bigIntRemainderDivide\
  \ = bigIntRemainder.divide(p);\n                    BigInteger bigIntQuotientRemainder\
  \ = bigIntRemainderDivide\n                            .subtract(BigInteger.ONE).multiply(\n\
  \                                    bigIntRemainderDivide);\n                 \
  \   BigInteger bigIntQuotientModulus = bigIntQuotientRemainder\n               \
  \             .mod(p);\n                    if (bigIntQuotientModulus.equals(Big"
- "        int r = n%p;\n        if (r > p) {\n            r = (p%p + (n/p)) % p;\n\
  \        }\n        return r;"
- "        if (p == 0) return 1;\n        if (n == 1) return p;\n        if (n % 2\
  \ == 1) return modp(n / 2, p);\n        return modp(n / 2, p + p) % p;"
- "        if (n == 0) return 1;\n        if (p < 0) throw new IllegalArgumentException();\n\
  \        int n1 = (n >>> 1) | (n & 1);\n        if (n1 == 0) return n;\n       \
  \ int p = p % n1;\n        if (p != 0) return modp(n1, p);\n        if (n1 < 2)\
  \ return n;\n        return modp(n1 >> 1, p) + n1 >> 1;"
- '        return ((long) Math.pow(2, n)) % p;'
- "        if (p == 0) return 0;\n        if (p == 1) return 1;\n        if (p ==\
  \ 2) return n;\n        int r = n % p;\n        if (r < 0) r += p;\n        return\
  \ modp(r, p);"
- '        return ((1 << n) - 1) & (p-1);'
- "        if (n == 0) {\n            return 1;\n        }\n        if ((n & -n) ==\
  \ n) {\n            int x = 1;\n            while (n > 0) {\n                x <<=\
  \ 1;\n                x += (n & 1);\n                n >>>= 1;\n            }\n\
  \            return x * p % p;\n        }\n        int x = (n&-n) * modp(0x5555555555555555L,\
  \ n);\n        int y = ((n>>1)&1) * modp(0x3333333333333333L, n);\n        int z\
  \ = (n&1) * modp(0x0f0f0f0f0f0f0f0fL, n);\n        return ((x<<1)|(y<<2)|(z<<4))%p;"
- "        int res = 1;\n        while (p * p > n) {\n            if (n % 2 == 0)\
  \ {\n                res *= n;\n            }\n            n = n / 2;\n        }\n\
  \        return n;"
- "        int res = 1;\n        for (int i = 0; i < n; i++) {\n            res =\
  \ (res * p) % p;\n        }\n        return res;"
- "        if (n < 0)\n            throw new IllegalArgumentException();\n       \
  \ int ret = 1;\n        for(int i = 1; ; i <<= 1) {\n            if (n & i == 0)\n\
  \                return ret;\n            if (i >= p)\n                ret *= p\
  \ - i;\n        }"
- '        return ((int)Math.pow(2,n)) % p;'
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            return modp(n / 2, p);\n        } else {\n            return modp((n\
  \ * 10 + n % 2) / (2 * 10 + 1), p) % p;\n        }"
- '        return (int) Math.pow(BigInteger.valueOf(n), p).mod(BigInteger.valueOf(p));'
- "        if ((n & -p) != 0)\n            n -= (p + 1) << 1; // shift n to rightmost\
  \ bit and then subtract p\n        return n & (p + 1);"
- "        // We first try a naive approach (the most naive algorithm for integers).\n\
  \        // This works well with small integers because they are relatively easy\n\
  \        // to implement. An interesting question is how we can implement it\n \
  \       // for integers greater than the word size.\n        if (n <= 0) return\
  \ 0;\n        if (n == 1) return p;\n        int r1 = modp(n - 1, p); // (n - 1)\
  \ mod p\n        int r2 = modp(n / 2, p); // (n / 2) mod p\n        int r3 = modp((n\
  \ / r2) + 1, r1); // ((n / r2) + 1) mod r1\n        int r = r1 - (r1 * r3) % p;\n\
  \        return r;"
- "        if (n == 0) return 1;\n        if (p == 0) return n;\n        return n\
  \ % p + (modp(n / p, p) % p);"
- "        if (n == 0 || p == 0) return 1;\n        if (p < 0 || n < 0 || n < p)\n\
  \            throw new IllegalArgumentException();\n        return modp(n - 1, p\
  \ + 1) + n % p;"
- "        if ((p & 0x80000000) != 0) {\n            throw new IllegalArgumentException();\n\
  \        }\n        if ((n & 0x80000000) != 0) {\n            throw new IllegalArgumentException();\n\
  \        }\n        if ((p < 1) || (p > 5)) {\n            throw new IllegalArgumentException();\n\
  \        }\n        if ((n < 0) || (n > p)) {\n            throw new IllegalArgumentException();\n\
  \        }\n        int q = n / p;\n        int r = n % p;\n        while (r > 0)\
  \ {\n            int c = p * q;\n            q = r - q * p;\n            r = c;\n\
  \        }\n        return q;"
- "        int r = 1;\n        while ((n & 1) == 0) {\n            n >>>= 1;\n   \
  \         r += n;\n        }\n        while (r < p) {\n            r *= 2;\n   \
  \     }\n        return r % p;"
- "        if ((n & (n - 1)) == 0)\n            return n % p;\n        else\n    \
  \        return ((n % p) + p) % p;"
- "        if (n >= p) {\n            return (n % p + p) % p;\n        }\n       \
  \ return 0;"
- "        if (n < 0) throw new IllegalArgumentException(\"n must be positive\");\n\
  \        if (p < 1) throw new IllegalArgumentException(\"p must be positive\");\n\
  \        int q = (int) Math.pow(p, (n * n - p) / (n * n));\n        return q;"
- '        return ((1 << n) % (1 << p));'
- "        int r = 1;\n        while (p) {\n            r <<= 1;\n            r |=\
  \ 1;\n            p >>= 1;\n        }\n        return n & p;"
- '        return Integer.bitCount(n ^ (n >>> p));'
- "        if (n == 0 || p == 0)\n            return 1;\n        if (n == p)\n   \
  \         return n;\n        int r = modp(n / 2, p);\n        return r * p % p;"
- "        Integer mod = (Integer) Integer.valueOf((long)Math.pow(2,n) % p);\n   \
  \     return mod.intValue();"
- "        if ((n%p) == 0)\n            return 1;\n        int ans = n/p;\n      \
  \  if (ans != (int)ans)\n            return ans;\n        int mod = (int)Math.pow(2,n);\n\
  \        ans = mod(p);\n        if (ans == (int)ans)\n            return mod(p);\n\
  \        ans %= p;\n        if (ans == (int)ans)\n            return mod(p);\n \
  \       ans %= p;\n        if (ans == (int)ans)\n            return mod(p);\n  \
  \      return 1;"
- "        int mask = 0;\n        while (n > 0) {\n            n &= n - 1; // (n &\
  \ (n - 1))\n            mask |= n & 0x01; // mask |= (n & 0x01) would work as well\n\
  \            n >>= 1; // n >>= 1 would also work\n        }\n        return p &\
  \ mask;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n\
  \            return p;\n        }\n        return ((n % p) + p) % p;"
- "        if (n >= p) {\n            int pow = 0;\n            while (n >= p) {\n\
  \                pow = pow * 2 + 1;\n                n = n / p;\n            }\n\
  \            return pow;\n        }\n        else {\n            return 0;\n   \
  \     }"
- "        int ret = n;\n        while (ret < p) {\n            ret = ret << 1;\n\
  \        }\n        while (ret >= p) {\n            ret = ret >>> 1;\n        }\n\
  \        return ret;"
- "        int r = 1;\n        while (n >= p) {\n            n -= p;\n           \
  \ ++r;\n        }\n        return r;"
- '        return ((n%p) * (n%p))%p;'
- "        if (n >= p) return 1;\n        if (n < p) return n;\n        return n %\
  \ p;"
- "        return ((n) % (p + 1))\n                + p;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n\
  \            return p;\n        }\n        int r = n % p;\n        if (n < p - r)\
  \ {\n            return n;\n        }\n        if (n == p - r) {\n            return\
  \ n + modp(n - r, p);\n        }\n        return n + modp(n - r, p) % p;"
- "        if (p == 0 || n == 0) {\n            return 1;\n        }\n        if ((n\
  \ & 1) != 0) {\n            return modp(n / 2, p);\n        }\n        return modp(n\
  \ % 2, p) * modp(n / 2, p);"
- "        if (n == 0 || n == 1 || n >= p)\n            return n;\n        int r =\
  \ n % p;\n        int q = n / p;\n        long result = 1;\n        while (q > 0)\
  \ {\n            result *= p;\n            result %= q;\n            q /= 10;\n\
  \        }\n        if (result > Integer.MAX_VALUE / p)\n            return 1;\n\
  \        if (result < Integer.MIN_VALUE / p)\n            return 0;\n        return\
  \ (int) result;"
- '        return (n^(p-1)) % p;'
- "        int result = 1;\n        for (int i = 1; i <= n; ++i) {\n            result\
  \ *= p;\n            result %= p;\n        }\n        return result;"
- "        int m = (1 << n) % (p - 1);\n        return m;"
- "        if (p == 0)\n            return 1;\n        if (p == 1)\n            return\
  \ n;\n        return n % p + modp(n - p % p, p) % p;"
- "        int d = (int) Math.pow(2,n);\n        if (d % p != 0) {\n            return\
  \ 0;\n        }\n        return d;"
- "        int rem = n % p;\n        return rem >= p ? rem : p - rem;"
- "        if (n == 0) return 1;\n        if (n == 1) return p;\n        if (n % 2\
  \ == 0) return modp(n / 2, p) * p;\n        return modp(n / 2, p) * p + p;"
- '        return ((1 << n) & -p) - p;'
- "        if (n >= p) {\n            return n;\n        }\n\n        if (n % p ==\
  \ 0) {\n            return n;\n        }\n\n        if (n % p == p - 1) {\n    \
  \        return n % p;\n        }\n\n        long a = Math.pow(p, n - 1);\n    \
  \    long b = p * p;\n        return ((long) a * b) % p;"
- "        if (n < 0) {\n            throw new IllegalArgumentException(\"Negative\
  \ exponent\");\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"\
  Negative modulus\");\n        }\n        if (n == 0) {\n            return 1;\n\
  \        }\n        if (p % n == 0) {\n            return modp(n / p, p);\n    \
  \    }\n        return modp(n % p, p) * modp(n / p, p);"
- "        int m = 1;\n        while (n > p) {\n            n = m % p;\n         \
  \   m = n % p;\n        }\n        return m;"
- "        int result = 0;\n        while (n!=0) {\n            result = result *\
  \ p + (n&1);\n            n >>>= 1;\n        }\n        return result;"
- "        int s = 1;\n        for (int i = 0; i < n; ++i) {\n            s = s *\
  \ p;\n        }\n        return s;"
- "        if ( n == 1 )\n            return 1;\n        else if ( n == p )\n    \
  \        return n;\n        else if ( n == p - 1 )\n            return p+1;\n  \
  \      else \n            return (p + modp(n-1, p)) % p;"
- "        int n2 = n * n;\n        int n2mod = n2 - (n2 % p);\n        return n2mod\
  \ % p;"
- "        // A better solution would be to compute n%p directly as a power of 2,\
  \ but since that's not allowed,\n        // we'll use BigInteger.\n        return\
  \ BigInteger.valueOf(n).shiftRight(p.bitLength()).mod(new BigInteger(\"2\"));"
- "        if (p < 1)\n            throw new IllegalArgumentException();\n       \
  \ if (n < 0 || p < 2)\n            return 1;\n        if (n & p)\n            return\
  \ n;\n        int r = 0, t = n;\n        do {\n            r = r + t & p;\n    \
  \        t = t >> 1;\n        } while (t > 0);\n        return r;"
- "        int res = (n % p + p) % p;\n        while (p > 0 && res == 0) {\n     \
  \       p /= 2;\n            res = (n % p + p) % p;\n        }\n        return res;"
- '        return Math.pow(2, n) % p;'
- "        int d = n >>> 1; // d = n / 2 = n >> 1\n        return ((n % p) + p) %\
  \ p;"
- "        // Get factorial\n        int f = 1;\n        while (n-- > 0) {\n     \
  \       f *= n;\n        }\n        // Get power\n        int res = 1;\n       \
  \ while (p > 1) {\n            int rem = p % 2;\n            if (rem == 1) {\n \
  \               res = res * f;\n            }\n            p = p / 2;\n        \
  \    f *= p;\n        }\n        return res;"
- "        if (n < 0)\n            throw new IllegalArgumentException(\"n must be\
  \ positive\");\n        if (p < 1)\n            throw new IllegalArgumentException(\"\
  p must be positive\");\n        if (p > n)\n            throw new IllegalArgumentException(\"\
  p is not smaller than n\");\n        if (n == 0)\n            return 1;\n      \
  \  if (p == 1)\n            return n;\n        return n % p + (n / p % p) * modp(n\
  \ / p, p);"
- "        int mod = 1;\n        while (n > 0) {\n            mod *= p;\n        \
  \    n -= 1;\n        }\n        return mod;"
- '        return (int) Math.pow(2, n) % p;'
- "        if (n == 0 || p == 0)\n            return 0;\n        if (n == p)\n   \
  \         return 1;\n        if (n < p)\n            return modp(n - p, p);\n  \
  \      long m = n / p;\n        if (m < p - 1)\n            return modp(m, p);\n\
  \        int q = m % p;\n        return modp(q, p) * modp(p, p - q);"
- '        return n > p ? n : n % p;'
- "        if (n == 0) return 0;\n        if (p == 0) return 1;\n        final int\
  \ k = n - 1;\n        return ((p / k) * modp(k, p)) % p;"
- '        return ((n&p) + (n>>(32-(p&31)))) & p;'
- "        if (n < 0) {\n            throw new IllegalArgumentException(\"Negative\
  \ exponent is not supported\");\n        }\n        int q = p + 2;\n        int\
  \ r = n;\n        while (true) {\n            int t = (q * q + r) % p;\n       \
  \     if (t == 1) {\n                break;\n            }\n            r = (r *\
  \ r + q) % p;\n            q = (q * q + t) % p;\n        }\n        return r;"
- "        if (n == 0) return 1;\n        int dp = 1;\n        while ((n%p) != 0)\
  \ dp = dp * 2;\n        return dp;"
- "        if (n < 0) throw new ArithmeticException(\"Negative modulus not allowed.\"\
  );\n        if (n < 2) return 1;\n        if (n < p) return n;\n        BigInteger\
  \ q = new BigInteger(String.valueOf(p));\n        BigInteger result = q.pow(n).mod(q);\n\
  \        if (result.equals(BigInteger.ZERO)) return 1;\n        if (result.equals(p))\
  \ return n;\n        throw new ArithmeticException(\"Modular exponentiation did\
  \ not terminate.\");"
- "        if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n\
  \            return modp(n - 1, p) + 1;\n        } else if (n % 3 == 0) {\n    \
  \        return modp(n - 1, p) * 3;\n        }\n        long m = n / p;\n      \
  \  int r = n % p;\n        m -= (r / p);\n        r %= p;\n        int d = modp(m,\
  \ p);\n        int r = modp(r, p);\n        return d * p + r;"
- "        if (n<0) return 0;\n        return n&-p;"
- "        int r = 1;\n        while (r * p < n) {\n            r *= 2;\n        }\n\
  \        if (n * 2 < r) {\n            return 1;\n        }\n        while (r %\
  \ p != 0) {\n            r += p;\n        }\n        return r % p;"
- "        boolean negative = n < 0;\n        boolean positive = n > 0;\n        int\
  \ result;\n        if (n == 0 || p == 0)\n            return 0;\n        else if\
  \ (n < 0)\n            n = -n;\n        if (p < 0)\n            p += p;\n      \
  \  if (n >= p)\n            result = 1;\n        else if (n < p)\n            result\
  \ = -1;\n        else\n            result = 0;\n        if (negative)\n        \
  \    result = -result;\n        return result;"
- "        if (n < 0 || p < 0) {\n            throw new IllegalArgumentException(\"\
  Arguments must be non-negative.\");\n        }\n        int res = 1;\n        while\
  \ (n != 0) {\n            if ((n & 1) == 0) {\n                res = (res * p) %\
  \ p;\n            }\n            n >>>= 1;\n            p >>>= 1;\n        }\n \
  \       return res;"
- "        if (p % 2 == 0) {\n            return n;\n        }\n        int res =\
  \ 2;\n        while ((res % p) != 0) {\n            res = (res << 1) | 1;\n    \
  \    }\n        return n - res;"
- '        return ((n%p)+p-1)%p;'
- '        return (n*(n+1) - 1) / (p * p);'
- "        int mask = p >> 1;\n        int a = p & mask;\n        int b = p;\n   \
  \     int c = n & mask;\n        while (!(n & mask)) {\n            b = b ^ a;\n\
  \            n ^= mask;\n            mask = mask >> 1;\n            a = a ^ b;\n\
  \            n ^= mask;\n            mask = mask >> 1;\n            a = a ^ b;\n\
  \            n ^= mask;\n            mask = mask >> 1;\n            a = a ^ b;\n\
  \            n ^= mask;\n            mask = mask >> 1;\n            a = a ^ b;\n\
  \            n ^= mask;\n            mask = mask >> 1;\n            a = a ^ b;\n\
  \            n ^= mask;\n            mask = mask >> 1;\n            a = a ^ b;\n\
  \            n ^= mask;\n        }\n        return ((n % p) + mask) & p;"
- '        return ((n % p) + p) % p;'
- "        int mask = 0x55555555;\n        int r = n & mask;\n        int mask2 =\
  \ (0x99999999 & mask);\n        int r2 = r^mask2;\n        return (r2 - ((1 & r2)\
  \ * p)) & mask;"
- "        int result = 0;\n        int divisor = 1;\n        int prime_power;\n \
  \       do {\n            prime_power = (n % divisor);\n            n = n / divisor;\n\
  \            divisor *= p;\n            result += prime_power;\n        } while\
  \ (divisor < p);\n        return result;"
- "        if (n == 0) {\n            return 0;\n        }\n        if (n < p) {\n\
  \            return n % p;\n        } else {\n            return ((n - (n % p))\
  \ + p) % p;\n        }"
- "        int result = 0;\n        while (n > 0) {\n            int digit = n % p;\n\
  \            result += digit * digit;\n            n /= p;\n        }\n        if\
  \ (result > Integer.MAX_VALUE)\n            return Integer.MAX_VALUE;\n        else\
  \ if (result < Integer.MIN_VALUE)\n            return Integer.MIN_VALUE;\n     \
  \   else\n            return result;"
- "        int r = 0x1;\n        while ((n >> r) != 0) {\n            r = (r << 1)\
  \ | (n & 1);\n        }\n        return r % p;"
- "        int n1 = n % p;\n        if (n1 == 0)\n            return n;\n        int\
  \ n2 = n / p;\n        return modp(n1, p) * modp(n2, p) % p;"
- "        int r = n & p;\n        int t = n ^ p;\n        int m = p >> 1;\n     \
  \   while (m > 0) {\n            r = (r << 1) ^ t;\n            t = (t >> 1);\n\
  \            m--;\n        }\n        return r ^ p;"
- "        int m = (int) Math.pow(2,n);\n        return Math.max(m, (p + 1) - ((p\
  \ + 1) & m));"
- "        int r = 1;\n        do {\n            r <<= 1;\n            r |= 1;\n \
  \       } while (--n >= 0);\n        do {\n            if (r & p)\n            \
  \    return r;\n            r <<= 1;\n            r |= 1;\n        } while (--n\
  \ > 0);\n        return 1;"
- "        if ((n % p) == 0) {\n            return n;\n        }\n        BigInteger\
  \ d = BigInteger.valueOf(p);\n        BigInteger m = BigInteger.valueOf(n).divide(BigInteger.valueOf(p));\n\
  \        return m.mod(d).intValue();"
- "        if (n == 0 || n == p) {\n            return n;\n        }\n        if (n\
  \ < 0 || p < 0) {\n            throw new IllegalArgumentException();\n        }\n\
  \        if (p > n) {\n            throw new ArithmeticException();\n        }\n\
  \        if (p == 1) {\n            return 1;\n        }\n        int[] bits = new\
  \ int[p];\n        Arrays.fill(bits, 0);\n        bits[0] |= 1 << (n - 1);\n   \
  \     bits[n - 1] |= 1 << (p - 1);\n        int count = 0;\n        for(int i =\
  \ 1; i <= p; i++) {\n            if((bits[i] & bits[p - i]) != 0) {\n          \
  \      count += 1;\n            }\n        }\n        return count;"
- "        if (n < 0) return 0;\n        return p - (p / n) * (n % p) % p;"
- '        return (n * n) % p;'
- "        int ret = 0;\n        while (n > 0) {\n            ret += (n & 1) * (p\
  \ & 1);\n            n >>= 1;\n            p >>= 1;\n        }\n        return ret;"
- "        int x = n & (-p);\n        return ((x + (x >> 31)) & -32) * x;"
- "        // We will count the bits of the modulus and then add that many bits to\n\
  \        // the result\n        int count = 0;\n        int res = 0;\n        do\
  \ {\n            count += n % p;\n            n /= p;\n        } while (n > 0);\n\
  \        // Make sure we don't go below 0 when the modulus is negative.\n      \
  \  if (n < 0)\n            n = -n;\n        // Now add in that number of bits\n\
  \        do {\n            res |= (n & 1) << count;\n            count--;\n    \
  \    } while (count >= 0);\n        return res;"
- "        long p = 1;\n        for(;;) {\n            p = p * p % p;\n          \
  \  if(p == 1) return 1;\n            if(p == p) break;\n        }\n        return\
  \ n % p;"
- "        // If p is 0 mod 2^n then p = 1. Invert if necessary.\n        if (p ==\
  \ 0 || (p & 1) == 0)\n            p = 1; // Invert if necessary.\n        // If\
  \ n is 0 mod p then n = 1. Invert if necessary.\n        if (n == 0 || (n & 1) ==\
  \ 0)\n            n = 1; // Invert if necessary.\n        // If n is 1 mod p then\
  \ n = p. Otherwise n = p ^ 2. Invert if necessary.\n        if (n == 1 || (n & 1)\
  \ == 1)\n            return p;\n        return ((p-1) >> 1) ^ ((p-1) & 1); // Invert\
  \ if necessary."
- "        int r = 1;\n        while (p-- > 0) {\n            if (n & 1) r = (r*n)\
  \ % p;\n            n >>= 1;\n        }\n        return r;"
- "        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be\
  \ non-negative\");\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"\
  p must be non-negative\");\n        }\n        if (p == 0) {\n            if (n\
  \ != 0) {\n                return 1;\n            }\n            return 0;\n   \
  \     }\n        if (p == 1) {\n            if (n == 0) {\n                return\
  \ 0;\n            }\n            return 1;\n        }\n        int n2 = n * n;\n\
  \        int p2 = p * p;\n        while (n2 >= p2) {\n            n2 -= p2;\n  \
  \          p2 *= p;\n        }\n        while (n2 >= p) {\n            n2 -= p;\n\
  \            p2 *= p;\n        }\n        return n2 % p;"
- "        long r = powMod(n, p, p);\n        if (r < 0) {\n            return 0;\n\
  \        } else if (r == 0) {\n            return 1;\n        } else {\n       \
  \     int result = (int) r;\n            while (result > 0) {\n                result\
  \ %= p;\n            }\n            return result;\n        }"
- "        if (n == 0)\n            return 1;\n        if (p < 0)\n            return\
  \ n;\n        if (p > n)\n            return n;\n        if (p > p / 2)\n      \
  \      return modp(n, p - p);\n        if (p % 2 == 0)\n            return modp(n\
  \ * n, p);\n        if (p % 3 == 0)\n            return modp(n * n * n, p);\n  \
  \      return modp(modp(n * n, p), p) / p;"
- "        if (n == 0)\n            return 0;\n        int res = 1;\n        for (int\
  \ i = 0; i < n; i++)\n            res = (res*p) % p;\n        return res;"
- "        if (n >= p)\n            return 1;\n        return n % p;"
- "        int q = p / 2;\n        if (p % 2 == 0) {\n            return n * q % p;\n\
  \        } else {\n            int t = (p * q + q) % p;\n            return n *\
  \ t % p;\n        }"
- "        /*\n          We need to write it as a recursive function:\n          modp(m,\
  \ p) < m - modp(0, p) if modp(m, p) < m\n          otherwise, modp(m, p) < m + (m\
  \ - modp(0, p))\n          Thus, we have:\n          modp(m, p) <= m + m - modp(0,p)\n\
  \          (We assume that modp(m,p) is a non-negative integer)\n          \n  \
  \        This leads to the following inequality for modp(m, p):\n          m + m\
  \ - modp(0,p) <= m + 1 - modp(0,p)\n          (Substitute the inequalities to get\
  \ (m - modp(0,p)) >= (m + (m - modp(0,p))) >= m - modp(0,p) and simplify to m >=\
  \ (m + (m - modp(0,p))) >= m)\n          \n          Thus, if we have m + m - modp(0,p)\
  \ >= m, we return m:\n          m + 1 - modp(0,p) >= m + 1 - modp(0,p)\n       \
  \   (Substitute and simplify): (m + (m - modp(0,p))) >= m\n          (Substitute\
  \ and simplify: m + 1 - modp(0,p) >= m + 1 - modp(0,p))\n          \n          Thus,\
  \ if we have (m + (m - modp(0,p))) >= m, we can return m + (m - modp(0,p)) >= m:\n\
  \          m >= (m + (m - modp(0,p))) >= m\n          \n          Thus we can implement\
  \ modp(m, p) this way:\n          \n          (m + (m - modp(0,p))) >= m\n     \
  \     \n          Thus it would be easy to calculate the modulo with the formula:\n\
  \          (m+1) - modp(0,p)\n          \n          Thus we get modp(m, p) = m +\
  \ 1 - modp(0,p).\n          \n          The only problem with modp(m, p) is that\
  \ Java's integer limits mean it won't go beyond a value of 1023, so we have to write\
  \ modp(m, p) as modp(m, p+1). \n        */\n        return modp(m, p+1) >= m ? m\
  \ + (m - modp(0,p)) : m+1;"
- "        List<Integer> values = new ArrayList();\n        int power = 0;\n     \
  \   for (int i = 1; i <= n; ++i) {\n            power = (2 * i) % p;\n         \
  \   values.add(power);\n        }\n        return values.stream().reduce(0, (i,\
  \ j) -> i % j == 0 ? j : i);"
- "        if (n < 0) {\n            throw new IllegalArgumentException(\"n < 0\"\
  );\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"\
  p < 0\");\n        }\n\n        if (p > n) {\n            throw new IllegalArgumentException(\"\
  p > n\");\n        }\n\n        if (n == 0) {\n            return 1;\n        }\
  \ else if (n > 0) {\n            return pow(n, p) % p;\n        } else {\n     \
  \       return ((p-1)*n) % p;\n        }"
- "        if (n < 0) {\n            n = -n;\n            p = -p;\n        }\n   \
  \     if (n < 0 || p < 0) {\n            throw new RuntimeException(\"modp() called\
  \ with bad arguments\");\n        }\n        int result = 1;\n        while (n >\
  \ p) {\n            result *= p;\n            n -= p;\n        }\n        while\
  \ (n < p) {\n            result /= p;\n            n += p;\n        }\n        return\
  \ result;"
- '        return (n * p + n) % p;'
- "        if (n==0) return 1;\n        int c = 1;\n        while (n>=p) {\n     \
  \       n-=p;\n            c*=p;\n        }\n        return c;"
- "        int res = 1;\n        while (n != 0) {\n            int next = n & -p;\n\
  \            if (next < p) {\n                res <<= 1;\n                res |=\
  \ 1;\n            }\n            n = next;\n        }\n        return res;"
- "        int result = 0;\n        if (n != 0) {\n            if (n < 0) {\n    \
  \            n = -n;\n                result++;\n            }\n            while\
  \ (n > 0) {\n                result += (n % p) + ((n / p) % p == 0 ? 1 : 0);\n \
  \               n /= p;\n            }\n            result %= p;\n        }\n  \
  \      return result;"
- "        if (n == 0)\n            return 1;\n        if (p % 2 == 0) {\n       \
  \     if (n % 2 == 0)\n                return 2;\n            else {\n         \
  \       if (n % 3 == 0)\n                    return 3;\n                if (n %\
  \ 5 == 0)\n                    return 5;\n                if (n % 7 == 0)\n    \
  \                return 7;\n                return modp(n - 2, p + 11) * modp(n\
  \ - 4, p + 13) * modp(n - 7, p + 15);\n            }\n        }\n        else if\
  \ (p % 3 == 0)\n            return modp(n / 3, p + 2);\n        else if (p % 5 ==\
  \ 0)\n            return modp(n / 5, p + 4);\n        else if (p % 7 == 0)\n   \
  \         return modp(n / 7, p + 6);\n        else\n            throw new AssertionError(\"\
  Can't be prime.\");"
- '        return (((1 << n) % p) + n) % p;'
- "        // We use the fact that mod is the inverse and multiplicative inverse\n\
  \        // of power.\n        return n * modinv(n, p);"
- "        int result = 1;\n        while (n > p) {\n            result *= 2;\n  \
  \          n -= 1;\n        }\n        if (n > 0) {\n            result *= 2;\n\
  \        }\n        return result % p;"
- '        return ((n * (n - 1)) % (p * (p - 1))) % p;'
- '        return ((int)Math.pow(2,n) % (int)p);'
- '        return ((1 << n) - 1) % (p - 1);'
- "        // Remember the leading bit of n.\n        int lsb = n & -(n);\n      \
  \  // Test if n is odd.\n        if (lsb > 0) {\n            // n & lsb = n & (lsb\
  \ - 1) + lsb\n            return n & (lsb - 1) + lsb;\n        }\n        // n is\
  \ even.\n        // We do n >> 1 until we get back to lsb.\n        while (n >>\
  \ 1 > 0) {\n            lsb--;\n            n >>>= 1;\n        }\n        // lsb\
  \ now holds the last bit of n.\n        // lsb & lsb = lsb\n        // lsb\n   \
  \     return lsb;"
- '        return ((n & -p) + p) % p;'
- "        if (n == 0 || p == 0 || p == 1) return n;\n        if (p > n) return 0;\n\
  \        int result = modp(n/2, p);\n        int mod = n%p;\n        result %= p;\n\
  \        if (result < mod) result += p;\n        return result;"
- "        if (p == 0)\n            return 1;\n        return modp(n - 1, (p - 1)\
  \ * (n / p));"
- "        if (n == 0 || p == 0)\n            return n;\n        int res = 1;\n  \
  \      for (int i = 0; i < p; i++) {\n            if (n & (1 << i))\n          \
  \      res *= p;\n        }\n        if (res <= p)\n            return n;\n    \
  \    else\n            return p % res;"
- "        BigInteger pow = BigInteger.valueOf(n).pow(n);\n        return pow.mod(BigInteger.valueOf(p)).toIntExact();"
- '        return ((n-1) & (p - 1))+1;'
- '        return (p == 0) ? 1 : ((n & -p) == p) ? 1 : modp(n >> p, (p << 1) + 1);'
- "        if (n == 0) {\n            return 0;\n        }\n        int result = modp(n\
  \ >> 1, p) << (p & 31); // 2^n mod p\n        int t = n % p;\n        result ^=\
  \ (t) * (t < 0 ? p : p-1);\n        return result;"
- "        int res = 1;\n        while ((n & 1) == 0) {\n            res = (res*2)\
  \ % p;\n            n >>= 1;\n        }\n        while ((n & 1) == 1) {\n      \
  \      res = (res*2) % p;\n            n >>= 1;\n        }\n        return res;"
- "        if (p == 0)\n            return 0;\n        if (p > n)\n            return\
  \ n;\n        int d = 1;\n        while (p > 1) {\n            d *= p;\n       \
  \     p /= 2;\n        }\n        n %= d;\n        return n;"
- "        if (n < 0) throw new IllegalArgumentException(\"n < 0\");\n        if (p\
  \ < 1) throw new IllegalArgumentException(\"p < 1\");\n        int res = 1;\n  \
  \      \n        while (n != 0) {\n            int d = n % p;\n            if (d\
  \ == 0) {\n                d += p;\n            }\n            res *= d;\n     \
  \       n /= p;\n        }\n        return res;"
- "        if (n == 0)\n            return 1;\n        if (p < 1)\n            throw\
  \ new IllegalArgumentException(\"p must be >= 1\");\n        if (p % 2 == 1)\n \
  \           throw new IllegalArgumentException(\"p is not an odd number\");\n  \
  \      int r = n & (-p);\n        if (n < p)\n            r |= n;\n        if (p\
  \ % 2 == 1)\n            r += p;\n        return r;"
- "        if (n <= 0) {\n            throw new ArithmeticException();\n        }\n\
  \        if (n >= p) {\n            return n - p;\n        }\n        int r = p\
  \ - (p >> 1);\n        while ((n & r) == 0) {\n            r >>= 1;\n        }\n\
  \        return (r * 2) + p;"
- "        if ((p == 0) && (n == 0)) {\n            return 1;\n        }\n       \
  \ if ((n == 0) || (p == 0)) {\n            return 0;\n        }\n        int a =\
  \ 1;\n        int b;\n        while (a <= n) {\n            b = (n % p + p) % p;\n\
  \            a = a + b;\n            n = n / p;\n        }\n        return a;"
- "        int r = 1;\n        while (p > 0) {\n            int r = r * n + (p & 1);\n\
  \            p >>= 1;\n        }\n        return r;"
- "        // The base case is easy: we know that n is 0 or 1.\n        if (n == 0\
  \ || n == 1) {\n            return n;\n        }\n\n        // Otherwise, subtract\
  \ 1 from n until we reach 1, then return n.\n        int res = modp(n - 1, p) %\
  \ p;\n        if (res == 0) {\n            return n;\n        }\n        return\
  \ res;"
- "        if (p == 0) return 1;\n        if (n < 0 || p < 0) return 0;\n        if\
  \ (n < p / 2) return modp(n - p, p);\n        if (n % p != 0) return modp(n / p,\
  \ p);\n        return modp((n * n) % p, p);"
- "        int result = (int) Math.pow(2.0 * n, 1.0 / p);\n        if (result % p\
  \ != 0) result = (int) Math.pow(result, p) % p;\n        return result;"
- "        int q = n;\n        int r = n & (p - 1);\n        while (q > 0) {\n   \
  \         int t = q;\n            q = (q / p) * p;\n            r = r + t;\n   \
  \     }\n        return r;"
- "        if (n == 0) return 0;\n        if (n & 1 == 0 && n % p == 0) return 1;\n\
  \        if (n % p == 0) return modp(n >> 1, p);\n        return modp(n >> 1, p)\
  \ + modp(n >> 1, p + p);"
- "        int ret = 1;\n        for (int i = 1; i <= n; i++, ret = ret * (2 % p))\
  \ {\n        }\n        return ret;"
- "        if (n < 0)\n            throw new IllegalArgumentException(\"Negative n:\
  \ \" + n);\n        if (p < 0)\n            throw new IllegalArgumentException(\"\
  Negative p: \" + p);\n        int result = 0;\n        for (int i = 0; i < n; i++)\
  \ {\n            result <<= 1;\n            result += (n >> i) % p;\n        }\n\
  \        return result;"
- "        return (n == 0 || n == 1) ? n :\n            modp(n % p, p) + modp(n/p,\
  \ p);"
- "        int res = 1;\n        while (p > 0 && n % p == 0) {\n            res *=\
  \ p;\n            n /= p;\n        }\n        return n % 2 == 1 ? res : 1 - res;"
- "        int r = n & (-p);\n        int s = n >> p;\n        while (s--) r |= (r\
  \ << p) & p;\n        return r;"
- "        if (n == 0) {\n            return 1;\n        }\n        if (n == 1) {\n\
  \            return p;\n        }\n        if (n < 0) {\n            return modp(-n%p,\
  \ p);\n        }\n        int m = n / 2;\n        int d = modp(m, p);\n        int\
  \ r = m % p;\n        return d + (r * modp(d, p));"
- '        return ((n << 1) ^ (n >> 31)) & p;'
- '        return (((n ^ p) - n) + p) % p;'
- "        int result = 1;\n        while ((n % p) != 0) {\n            result *=\
  \ p;\n            ++p;\n        }\n        return n % p;"
- "        int s = 1;\n        while(n > p) {\n            s = s * 2;\n          \
  \  n -= p;\n        }\n        while(n > 0) {\n            s = s * 2;\n        \
  \    n -= 1;\n        }\n        return s;"
- "        if (n == 0) return 1;\n        int d = p % n;\n        if (d == 0) return\
  \ n;\n        return modp(n / d, p);"
- "        if (p == 0)\n            return 1;\n        if (n % p != 0)\n         \
  \   return 0;\n        int res = 1;\n        while (n/p > 1) {\n            if (n\
  \ % p == 0)\n                res++;\n            n /= p;\n        }\n        return\
  \ res;"
- "        if (n == 0)\n            return 1;\n        if (n == p)\n            return\
  \ 1;\n        if (n > p)\n            return modp(n - p, p) % p;\n        if (n\
  \ < p)\n            return modp(n, p - 1);"
- '        return Math.pow(2, n) % (int) p;'
- "        int res = 1;\n        while(n>=p) {\n            res=res*p+p%n;\n     \
  \       n=n/p;\n        }\n        return res;"
- "        if ((n & (n - 1)) == 0) return n;\n        int s = 1;\n        while ((n\
  \ >>= 1) > 0) s *= 2;\n        s %= p;\n        int ret = n;\n        while (ret\
  \ > s) ret %= p;\n        return ret;"
- "        if (n == 0 || p == 0) return 0;\n        long a = (long) Math.pow(2L, n);\n\
  \        long b = (long) Math.pow(2L, p) % p;\n        if ((a % p) == 0) return\
  \ (int) a;\n        else return (int) (b % p);"
- '        return (int) (Math.pow(2, n) % p);'
language: java
name: HumanEval_49_modp
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>>\
  \ modp(3, 5)\n    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0,\
  \ 101)\n    // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n\
  \    // 1\n    public static int modp(int n, int p) {\n"
stop_tokens:
- "    }\n    //"
- "    }\n    p"
- '    }

  }'
- "\n    }\n"
tests: "}\n    public static void main(String[] args) {\n    assert(modp((3), (5))\
  \ == (3));\n    assert(modp((1101), (101)) == (2));\n    assert(modp((0), (101))\
  \ == (1));\n    assert(modp((3), (11)) == (8));\n    assert(modp((100), (101)) ==\
  \ (1));\n    assert(modp((30), (5)) == (4));\n    assert(modp((31), (5)) == (3));\n\
  \    }\n\n}\n"
