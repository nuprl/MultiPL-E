name: HumanEval_156_int_to_mini_roman
language: lua
prompt: "-- Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  -- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n\
  -- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n-- 'clii'\n\
  -- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
  \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
  \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
  \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
  \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
  \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
  \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
  \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
  \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  --\
    \ Base case\n  if number <= 0 then\n    return nil\n  end", "  local roman = roman_to_int()\n\
    \  local roman_number = roman[number]\n  if roman_number == nil then\n    return\
    \ \"?\"\n  end\n  local roman_numeral = \"\"\n  local i = 0\n  while i < roman_number\
    \ do\n    roman_numeral = roman_numeral .. roman[i]\n    i = i + 1\n  end\n  return\
    \ roman_numeral:lower()\nend", "  -- Base case\n  if number <= 0 then\n    return\
    \ nil\n  end", "  local roman = romans[number]\n  if roman == nil then\n    roman\
    \ = romans[number] = romans[number]\n    for i = 1, number do\n      roman = roman\
    \ .. romans[math.floor((number - i) / i)]\n    end\n  end\n  return roman\nend",
  "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  assert(number\
    \ >= 1 and number <= 1000, 'Invalid input: number must be between 1 and 1000')\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\nend", "  assert(number\
    \ >= 1 and number <= 1000, 'Invalid input: number must be between 1 and 1000')\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\nend", "  --\
    \ Base case\n  if number <= 0 then\n    return nil\n  end", "  -- We use a lookup\
    \ table to find the correct roman numeral for a number.\n  -- The lookup table\
    \ is indexed by the first letter of the roman numeral.\n  -- The first letter\
    \ corresponds to 'I' in the roman numeral.\n  -- The lookup table is indexed by\
    \ the second letter of the roman numeral.\n  -- The second letter corresponds\
    \ to 'V' in the roman numeral.\n  -- The lookup table is indexed by the third\
    \ letter of the roman numeral.\n  -- The third letter corresponds to 'X' in the\
    \ roman numeral.\n  -- The lookup table is indexed by the fourth letter of the\
    \ roman numeral.\n  -- The fourth letter corresponds to 'L' in the roman numeral.\n\
    \  -- The lookup table is indexed by the fifth letter of the roman numeral.\n\
    \  -- The fifth letter corresponds to 'C' in the roman numeral.\n  -- The lookup\
    \ table is indexed by the sixth letter of the roman numeral.\n  -- The sixth letter\
    \ corresponds to 'D' in the roman numeral.\n  -- The lookup table is indexed by\
    \ the seventh letter of the roman numeral.\n  -- The seventh letter corresponds\
    \ to 'M' in the roman numeral.\n  -- The lookup table is indexed by the eighth\
    \ letter of the roman numeral.\n  -- The eighth letter corresponds to 'I' in the\
    \ roman numeral.\n  -- The lookup table is indexed by the ninth letter of the\
    \ roman numeral.\n  -- The ninth letter corresponds to 'V' in the roman numeral.\n\
    \  -- The lookup table is indexed by the tenth letter of the roman numeral.\n\
    \  -- The tenth letter corresponds to 'X' in the roman numeral.\n  -- The lookup\
    \ table is indexed by the eleventh letter of the roman numeral.\n  -- The eleventh\
    \ letter corresponds to 'C' in the roman numeral.\n  -- The lookup table is indexed\
    \ by the twelfth letter of the roman numeral.\n  -- The twelfth letter corresponds\
    \ to 'D' in the roman numeral.\n  -- The lookup table is indexed by the thirteenth\
    \ letter of the roman numeral.\n  -- The thirteenth letter corresponds to 'M'\
    \ in the roman numeral.\n  -- The lookup table is indexed by the fourteenth letter\
    \ of the roman numeral.\n  -- The fourteenth letter corresponds to 'I' in the\
    \ roman numeral.\n  -- The lookup table is indexed by the fifteenth letter of\
    \ the roman numeral.\n  -- The fifteenth ", "  -- Base case\n  if number <= 0\
    \ then\n    return nil\n  end\n  -- Recursive case\n  if number <= 3 then\n  \
    \  return mini_roman[number]\n  end\n  -- Recursive case\n  local roman = mini_roman[number\
    \ - 3]\n  local remainder = number - 3\n  local roman_numeral = ''\n  while remainder\
    \ > 0 do\n    roman_numeral = roman_numeral .. roman\n    remainder = remainder\
    \ - 1\n    roman = mini_roman[remainder]\n  end\n  return roman_numeral .. roman\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  -- Base\
    \ case\n  if number <= 0 then\n    return nil\n  end", "  -- Base case\n  if number\
    \ <= 0 then\n    return nil\n  end", "  -- Base case\n  if number <= 0 then\n\
    \    return ''\n  end", "  assert(number >= 1 and number <= 1000, 'Invalid input:\
    \ number must be between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while\
    \ i <= number do\n    roman = roman .. roman_table[i]\n    i = i + 1\n  end\n\
    \  return roman:lower()\nend", "  -- Base case\n  if number <= 0 then\n    return\
    \ nil\n  end", "  local roman = romans[number]\n  if roman == nil then\n    roman\
    \ = romans[number] = romans[number]\n    for i = 1, 1000 do\n      roman = roman..romans[math.floor((number\
    \ / i) % 10)]\n    end\n  end\n  return roman\nend", "  -- Base cases\n  if number\
    \ <= 0 then\n    return nil\n  end\n  if number <= 3 then\n    return string.char(number)\n\
    \  end\n  -- Recursive cases\n  local roman = int_to_mini_roman(number / 10)\n\
    \  local remainder = number % 10\n  return roman .. string.sub(\"IVXLCDM\", 1,\
    \ remainder)\nend", "  local roman = roman_to_int()\n  local roman_numeral = ''\n\
    \  local roman_numeral_length = #roman\n  local roman_numeral_length_cap = #roman_numeral\n\
    \  local roman_numeral_length_min = #roman_numeral\n  local roman_numeral_length_max\
    \ = #roman_numeral\n  local roman_numeral_length_mincap = #roman_numeral\n  local\
    \ roman_numeral_length_maxcap = #roman_numeral\n  local roman_numeral_length_mincap_max\
    \ = #roman_numeral\n  local roman_numeral_length_maxcap_max = #roman_numeral\n\
    \  local roman_numeral_length_mincap_mincap = #roman_numeral\n  local roman_numeral_length_maxcap_mincap\
    \ = #roman_numeral\n  local roman_numeral_length_mincap_maxcap = #roman_numeral\n\
    \  local roman_numeral_length_maxcap_maxcap = #roman_numeral\n  local roman_numeral_length_mincap_mincap_max\
    \ = #roman_numeral\n  local roman_numeral_length_maxcap_mincap_max = #roman_numeral\n\
    \  local roman_numeral_length_mincap_maxcap_max = #roman_numeral\n  local roman_numeral_length_mincap_mincap_maxcap\
    \ = #roman_numeral\n  local roman_numeral_length_maxcap_mincap_maxcap = #roman_numeral\n\
    \  local roman_numeral_length_mincap_mincap_maxcap_max = #roman_numeral\n  local\
    \ roman_numeral_length_maxcap_mincap_maxcap_max = #roman_numeral\n  local roman_numeral_length_mincap_mincap_maxcap_maxcap\
    \ = #roman_numeral\n  local roman_numeral_length_maxcap_mincap_maxcap_maxcap =\
    \ #roman_numeral\n  local roman_numeral_length_mincap_mincap_maxcap_maxcap_max\
    \ = #roman_numeral\n  local roman_numeral_length_maxcap_mincap_maxcap_maxcap_max\
    \ = #roman_numeral\n  local roman_numeral_length_mincap_mincap_maxcap_maxcap_maxcap\
    \ = #roman_numeral\n  local roman_numeral_length_maxcap_mincap_maxcap_max", " \
    \ -- The number should be between 1 and 1000 inclusive.\n  assert(number >= 1\
    \ and number <= 1000, 'Invalid input: number should be between 1 and 1000 inclusive')\n\
    \  -- The first letter is 'x', the second 'c', the third 'l', the fourth 'i',\n\
    \  -- and the fifth 'x', the sixth 'c', the seventh 'l', the eighth 'i', and\n\
    \  -- the ninth 'x'.\n  local roman = 'x'\n  -- The number should be divisible\
    \ by 100 (i.e. 1000 or more).\n  assert(number % 100 == 0, 'Invalid input: number\
    \ should be divisible by 100')\n  -- The number should be divisible by 400 (i.e.\
    \ 4000 or more).\n  assert(number % 400 == 0, 'Invalid input: number should be\
    \ divisible by 400')\n  -- The number should be divisible by 100 (i.e. 1000 or\
    \ more).\n  assert(number % 100 == 0, 'Invalid input: number should be divisible\
    \ by 100')\n  -- The number should be divisible by 400 (i.e. 4000 or more).\n\
    \  assert(number % 400 == 0, 'Invalid input: number should be divisible by 400')\n\
    \  -- The number should be divisible by 1000 (i.e. 10000 or more).\n  assert(number\
    \ % 1000 == 0, 'Invalid input: number should be divisible by 1000')\n  -- The\
    \ number should be divisible by 400 (i.e. 4000 or more).\n  assert(number % 400\
    \ == 0, 'Invalid input: number should be divisible by 400')\n  -- The number should\
    \ be divisible by 1000 (i.e. 10000 or more).\n  assert(number % 1000 == 0, 'Invalid\
    \ input: number should be divisible by 1000')\n  -- The number should be divisible\
    \ by 400 (i.e. 4000 or more).\n  assert(number % 400 == 0, 'Invalid input: number\
    \ should be divisible by 400')\n  -- The number should be divisible by 1000 (i.e.\
    \ 10000 or more).\n  assert(number % 1000 == 0, 'Invalid input: number should\
    \ be divisible by 1000')\n  -- The number should be divisible by 400 (i.e. 4000\
    \ or more).\n  assert(number % 400 == 0, 'Invalid input: number should be divisible\
    \ by 400')\n  -- The number should be divisible by 1000 (i.e. 10000 or more).\n\
    \  assert(number % 1000 == 0, 'Invalid input: number should be divisible by 1000')\n\
    \  -- The number should be divisible by 400 (i.e. 4000 or more).\n  assert(number\
    \ % 400 == 0, 'Invalid input: number should be divisible by 400')\n  -- The number\
    \ should be di", "  local roman = roman_to_int()\n  local roman_numeral = ''\n\
    \  local i = 1\n  while i <= number do\n    roman_numeral = roman_numeral .. roman[i]\n\
    \    i = i + 1\n  end\n  return roman_numeral:lower()\nend", "  -- Base case:\
    \ if the number is 1, just return 'i'.\n  if number == 1 then\n    return 'i'\n\
    \  end", "  assert(number >= 1 and number <= 1000, \"Invalid input: \" .. tostring(number))\n\
    \  local roman = roman_numerals[number]\n  if roman == nil then\n    roman = roman_numerals[number]\
    \ = roman_numerals[number - 1]\n    if roman == nil then\n      roman = \"?\"\n\
    \    end\n  end\n  return roman\nend", "  assert(number >= 1 and number <= 1000)\n\
    \  local roman = string.gsub(\n    string.rep('MCMXCIV', number),\n    '(..)',\n\
    \    function(c)\n      local num = tonumber(c)\n      if num ~= nil then\n  \
    \      return string.format('%1s', num)\n      else\n        return c\n      end\n\
    \    end)\n  return string.lower(roman)\nend", "  local roman = romans[number]\n\
    \  if roman == nil then\n    error(\"invalid number: \" .. number)\n  end\n  return\
    \ roman\nend", "  -- Base case\n  if number <= 0 then\n    return nil\n  end",
  "  local roman = roman_numerals[number]\n  if roman == nil then\n    error(\"invalid\
    \ input: \" .. number)\n  end\n  local roman_numeral = \"\"\n  for i = 1, #roman\
    \ do\n    roman_numeral = roman_numeral .. roman[i]\n  end\n  return roman_numeral:lower()\n\
    end", "  assert(number >= 1 and number <= 1000)\n  local roman = ''\n  local i\
    \ = 1\n  while i <= number do\n    roman = roman .. roman_numeral(i)\n    i =\
    \ i + 1\n  end\n  return roman:lower()\nend", "  local roman = string.gsub(\n\
    \    string.rep('MCMXCIV', number),\n    '(..)',\n    function(c)\n      return\
    \ string.char(tonumber(c) + 1)\n    end\n  )\n  return string.lower(roman)\nend",
  "  local roman = string.gsub(\n    string.rep('MCMXCIV', number),\n    '(..)',\n\
    \    function(c)\n      return string.char(tonumber(c))\n    end\n  )\n  return\
    \ string.lower(roman)\nend", "  -- Base case: if the number is 1, just return\
    \ 'i'.\n  if number == 1 then\n    return 'i'\n  end", "  local roman = roman_to_int()\n\
    \  local roman_num = ''\n  for i = 1, number do\n    local roman_num = roman_num..roman[i]\n\
    \  end\n  return roman_num:lower()\nend", "  -- Base case\n  if number <= 0 then\n\
    \    return nil\n  end", "  assert(number >= 1 and number <= 1000, 'Invalid input:\
    \ number must be between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while\
    \ i <= number do\n    roman = roman .. roman_numeral(i)\n    i = i + 1\n  end\n\
    \  return roman:lower()\nend", "  -- The number should be between 1 and 1000 inclusive.\n\
    \  assert(number >= 1 and number <= 1000, 'number should be between 1 and 1000\
    \ inclusive')", "  -- Initialize result to empty string.\n  local result = \"\"",
  "  local roman = roman_numeral()\n  local roman_numeral = ''\n  local i = 1\n  while\
    \ i < number do\n    local roman_numeral = roman_numeral .. roman[i]\n    i =\
    \ i + 1\n  end\n  return roman_numeral:lower()\nend", "  -- Base case\n  if number\
    \ <= 0 then\n    return ''\n  end", "  -- Base case\n  if number <= 0 then\n \
    \   return ''\n  end", "  local roman = romans[number]\n  if roman == nil then\n\
    \    error(\"invalid number: \" .. tostring(number))\n  end\n  local roman_numeral\
    \ = \"\"\n  local roman_numeral_length = roman:len()\n  for i = 1, roman_numeral_length\
    \ do\n    local char = roman:sub(i, i)\n    roman_numeral = roman_numeral .. char:lower()\n\
    \  end\n  return roman_numeral\nend", "  assert(number >= 1 and number <= 1000,\
    \ 'Invalid input: number must be between 1 and 1000')\n  local roman = ''\n  local\
    \ i = 1\n  while i <= number do\n    roman = roman .. roman_numeral(i)\n    i\
    \ = i + 1\n  end\n  return roman:lower()\nend", "  assert(number >= 1 and number\
    \ <= 1000)\n  local roman = ''\n  local i = 1\n  while i <= number do\n    roman\
    \ = roman .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\nend",
  "  local roman = romans[number]\n  if roman == nil then\n    error(\"Roman number\
    \ \" .. number .. \" is not in Roman alphabet\")\n  end\n  return roman\nend",
  "  assert(number >= 1 and number <= 1000, 'Invalid argument: ' .. tostring(number))\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\nend", "  local\
    \ roman = roman_to_int()\n  local roman_number = ''\n  local i = 1\n  while i\
    \ <= number do\n    local roman_digit = roman[i]\n    roman_number = roman_number\
    \ .. roman_digit\n    i = i + 1\n  end\n  return roman_number:lower()\nend", " \
    \ -- Base cases\n  if number <= 0 then\n    return nil\n  end\n  if number <=\
    \ 3 then\n    return string.char((number - 1) * 4 + 1)\n  end\n  -- Recursive\
    \ case\n  local roman = int_to_mini_roman(number / 4)\n  local remainder = number\
    \ % 4\n  if remainder == 0 then\n    return roman\n  else\n    return roman ..\
    \ string.char(remainder)\n  end\nend", "  assert(number >= 1 and number <= 1000)\n\
    \  local roman = string.char()\n  local i = 1\n  while i <= number do\n    roman\
    \ = roman .. string.sub(roman_numerals, math.floor(i/10)*10+(i%10)+1).\n     \
    \ substring.(roman, 1, 1)\n    i = i + 1\n  end\n  return string.lower(roman)\n\
    end", "  assert(number >= 1 and number <= 1000, 'Invalid input: number must be\
    \ between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number\
    \ do\n    roman = roman .. mini_roman[i]\n    i = i + 1\n  end\n  return roman\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  local\
    \ roman = roman_numerals[number]\n  if roman == nil then\n    error(\"invalid\
    \ number: \" .. tostring(number))\n  end\n  return roman:lower()\nend", "  local\
    \ roman = string.gsub(\n    string.rep('MCMXCIV', number),\n    '(..)',\n    function(c)\n\
    \      return string.char(tonumber(c))\n    end\n  )\n  return string.lower(roman)\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  -- Base\
    \ case\n  if number <= 0 then\n    return nil\n  end", "  local roman = roman_to_int()\n\
    \  local roman_numeral = ''\n  local i = 1\n  while i <= number do\n    local\
    \ roman_numeral = roman_numeral .. roman[i]\n    i = i + 1\n  end\n  return roman_numeral:lower()\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  local\
    \ roman = roman_to_int()\n  local roman_numeral = ''\n  local i = 1\n  while i\
    \ <= number do\n    local roman_numeral = roman[i]\n    if roman_numeral ~= ''\
    \ then\n      roman_numeral = roman_numeral .. roman[number - i]\n    end\n  \
    \  i = i + 1\n  end\n  return roman_numeral:lower()\nend", "  -- Base case\n \
    \ if number <= 0 then\n    return ''\n  end", "  local roman = roman_to_int()\n\
    \  local roman_num = ''\n  local i = 1\n  while i <= number do\n    local roman_digit\
    \ = roman[i]\n    roman_num = roman_num .. roman_digit\n    i = i + 1\n  end\n\
    \  return roman_num:lower()\nend", "  -- Base case: if the number is 1, return\
    \ the letter 'x'.\n  if number == 1 then\n    return 'x'\n  end", "  assert(number\
    \ >= 1 and number <= 1000, 'Invalid input: number must be between 1 and 1000')\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. roman_table[i]\n    i = i + 1\n  end\n  return string.lower(roman)\nend",
  "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  -- Base case\n\
    \  if number <= 0 then\n    return ''\n  end", "  -- Base case\n  if number <=\
    \ 0 then\n    return nil\n  end", "  local roman = roman_to_int()\n  local roman_number\
    \ = ''\n  local i = 1\n  while i <= number do\n    local roman_digit = roman[i]\n\
    \    roman_number = roman_number .. roman_digit\n    i = i + 1\n  end\n  return\
    \ string.lower(roman_number)\nend", "  assert(number >= 1 and number <= 1000,\
    \ \"Invalid input: \" .. tostring(number))\n  local roman = \"\"\n  local i =\
    \ 1\n  while i <= number do\n    roman = roman .. roman_numeral(i)\n    i = i\
    \ + 1\n  end\n  return roman:lower()\nend", "  -- Base case\n  if number <= 0\
    \ then\n    return nil\n  end", "  -- Initialize result to empty string.\n  local\
    \ result = \"\"", "  -- Base case\n  if number <= 0 then\n    return nil\n  end",
  "  local roman = roman_numerals[number]\n  if roman == nil then\n    error(\"Invalid\
    \ input: \" .. number)\n  end\n  return roman\nend", "  assert(number >= 1 and\
    \ number <= 1000, 'Invalid input: number must be between 1 and 1000')\n  local\
    \ roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman .. roman_table[i]\n\
    \    i = i + 1\n  end\n  return roman:lower()\nend", "  local roman = roman_numerals[number]\n\
    \  if roman == nil then\n    roman = roman_numerals[number - 1000]\n    if roman\
    \ == nil then\n      roman = roman_numerals[number - 100]\n      if roman == nil\
    \ then\n        roman = roman_numerals[number - 10]\n        if roman == nil then\n\
    \          roman = roman_numerals[number - 1]\n        end\n      end\n    end\n\
    \  end\n  return roman\nend", "  local roman = roman_numerals[number]\n  if roman\
    \ == nil then\n    error(\"Invalid number: \" .. number)\n  end\n  return roman:lower()\n\
    end", "  local roman = roman_to_int()\n  local roman_string = roman[number]\n\
    \  local roman_length = roman_string:len()\n  local roman_numeral = ''\n  local\
    \ roman_numeral_length = roman_length:byte()\n  local roman_numeral_length = roman_numeral_length\
    \ + roman_length - 1\n  while roman_numeral_length > 0 do\n    local roman_numeral_byte\
    \ = roman_string:byte(roman_numeral_length)\n    roman_numeral = roman_numeral\
    \ .. roman_numeral_byte\n    roman_numeral_length = roman_numeral_length - 1\n\
    \  end\n  return roman_numeral:lower()\nend", "  -- Base case\n  if number <=\
    \ 0 then\n    return nil\n  end", "  local roman = roman_to_int()\n  local roman_numeral\
    \ = ''\n  local i = 1\n  while i <= number do\n    local roman_numeral = roman_numeral\
    \ .. roman[i]\n    i = i + 1\n  end\n  return roman_numeral:lower()\nend", " \
    \ assert(number >= 1 and number <= 1000, \"Invalid number: \" .. tostring(number))\n\
    \  local roman = romans[number]\n  if roman then\n    return roman\n  end\n  local\
    \ roman = \"\"\n  local i = 1\n  while i <= number do\n    roman = roman .. romans[math.floor(i)]\n\
    \    i = i + 1\n  end\n  return roman\nend", "  assert(number >= 1 and number\
    \ <= 1000)\n  local roman = ''\n  local i = 1\n  while i <= number do\n    roman\
    \ = roman .. roman_numeral(i)\n    i = i + 1\n  end\n  return roman:lower()\n\
    end", "  assert(number >= 1 and number <= 1000, 'Invalid input: number must be\
    \ between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number\
    \ do\n    roman = roman .. roman_numeral(i)\n    i = i + 1\n  end\n  return roman:lower()\n\
    end", "  local roman = roman_numerals[number]\n  if roman == nil then\n    error(\"\
    Invalid number: \" .. tostring(number))\n  end\n  return roman\nend", "  -- Base\
    \ cases\n  if number <= 0 then\n    return nil\n  end\n  if number <= 3 then\n\
    \    return string.format('%c%s', \"M\", int_to_mini_roman(number - 1))\n  end\n\
    \  if number <= 6 then\n    return string.format('%c%s', \"CM\", int_to_mini_roman(number\
    \ - 3))\n  end\n  if number <= 9 then\n    return string.format('%c%s', \"D\"\
    , int_to_mini_roman(number - 6))\n  end\n  if number <= 12 then\n    return string.format('%c%s',\
    \ \"CD\", int_to_mini_roman(number - 9))\n  end\n  if number <= 15 then\n    return\
    \ string.format('%c%s', \"C\", int_to_mini_roman(number - 12))\n  end\n  if number\
    \ <= 18 then\n    return string.format('%c%s', \"XC\", int_to_mini_roman(number\
    \ - 15))\n  end\n  if number <= 21 then\n    return string.format('%c%s', \"L\"\
    , int_to_mini_roman(number - 18))\n  end\n  if number <= 24 then\n    return string.format('%c%s',\
    \ \"XL\", int_to_mini_roman(number - 21))\n  end\n  if number <= 27 then\n   \
    \ return string.format('%c%s', \"X\", int_to_mini_roman(number - 24))\n  end\n\
    \  if number <= 30 then\n    return string.format('%c%s', \"IX\", int_to_mini_roman(number\
    \ - 27))\n  end\n  if number <= 33 then\n    return string.format('%c%s', \"V\"\
    , int_to_mini_roman(number - 30))\n  end\n  if number <= 36 then\n    return string.format('%c%s',\
    \ \"IV\", int_to_mini_roman(number - 33))\n  end\n  if number <= 39 then\n   \
    \ return string.format('%c%s', \"I\", int_to_mini_roman(number - 36))\n  end\n\
    \  if number <= 42 then\n    return string.format('%c%s', \"VI\", int_to_mini_roman(number\
    \ - 39))\n  end\n  if number <= 45 then\n    return string.format('%c%s', \"I\"\
    , int_to_mini_roman(number - 42))\n  end\n  if number <= 48 then\n    return string.format('%c%s',\
    \ \"IV\", int_to_mini_roman(number - 45))\n  end\n  if number <= 51 then\n   \
    \ return string.format('%c%s', \"V\", int_to_mini_roman(number - 48))\n  end\n",
  "  assert(number >= 1 and number <= 1000, 'Invalid input: number must be between\
    \ 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number do\n  \
    \  roman = roman .. roman_numeral(i)\n    i = i + 1\n  end\n  return roman:lower()\n\
    end", "  -- Base case: if the number is 1, just return it.\n  if number == 1 then\n\
    \    return number\n  end", "  assert(number >= 1 and number <= 1000, 'Invalid\
    \ input: number must be between 1 and 1000')\n  local roman = string.char()\n\
    \  local i = 1\n  while i <= number do\n    roman = roman .. string.sub('MCMXCIV',\
    \ math.floor((i - 1) / 4) + 1, math.floor((i - 1) / 4) + 3)\n    i = i + 1\n \
    \ end\n  return string.lower(roman)\nend", "  assert(number >= 1 and number <=\
    \ 1000)\n  local roman = ''\n  local i = 1\n  while i <= number do\n    roman\
    \ = roman .. mini_roman[i]\n    i = i + 1\n  end\n  return roman\nend", "  assert(number\
    \ >= 1 and number <= 1000, 'Invalid input: number must be between 1 and 1000')\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. roman_numeral(i)\n    i = i + 1\n  end\n  return roman:lower()\nend", " \
    \ -- Base case\n  if number <= 0 then\n    return nil\n  end", "  -- Initialize\
    \ result to an empty string.\n  local result = \"\"", "  local roman = roman_to_int()\n\
    \  local roman_string = roman[number]\n  local roman_length = #roman_string\n\
    \  local roman_numeral = ''\n  for i = 1, roman_length do\n    local roman_digit\
    \ = roman_string[i]\n    roman_numeral = roman_numeral .. roman_digit\n    if\
    \ i < roman_length - 1 then\n      roman_numeral = roman_numeral .. roman[roman_length\
    \ - i - 1] .. roman_digit\n    end\n  end\n  return roman_numeral:lower()\nend",
  "  assert(number >= 1 and number <= 1000, \"Invalid input: \" .. tostring(number))\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, number do\n      roman = roman..romans[math.floor((number-i)/100)]..romans[math.floor((number-i)%100)]\n\
    \    end\n  end\n  return roman\nend", "  assert(number >= 1 and number <= 1000)\n\
    \  local roman = string.gsub(\n    string.rep('MCMXCIV', number),\n    '(..)',\n\
    \    function(c)\n      return string.char(tonumber(c))\n    end\n  )\n  return\
    \ string.lower(roman)\nend", "  local roman = roman_numeral()\n  local roman_string\
    \ = roman[number]\n  return roman_string:lower()\nend", "  -- Base case\n  if\
    \ number <= 0 then\n    return nil\n  end\n  -- Recursive case\n  if number <=\
    \ 3 then\n    return mini_roman[number]\n  else\n    local roman = mini_roman[number\
    \ - 3]\n    local remainder = number - roman\n    return roman .. mini_roman[remainder]\n\
    \  end\nend", "  -- Base cases\n  if number <= 0 then\n    return nil\n  end\n\
    \  if number <= 3 then\n    return string.char(number)\n  end\n  -- Recursive\
    \ cases\n  local roman = string.char(0)\n  local remainder = number\n  while remainder\
    \ > 1 do\n    local remainder, remainder_remainder = math.modf(remainder)\n  \
    \  roman = string.sub(roman, 1, 1) + string.char(remainder_remainder)\n  end\n\
    \  return roman\nend", "  -- Base case\n  if number <= 0 then\n    return nil\n\
    \  end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  --\
    \ Base case\n  if number <= 0 then\n    return nil\n  end", "  -- The number should\
    \ be between 1 and 999.\n  assert(number >= 1 and number <= 999)", "  -- Base\
    \ case\n  if number <= 0 then\n    return nil\n  end", "  assert(number >= 1 and\
    \ number <= 1000)\n  local roman = romans[number]\n  if roman then\n    return\
    \ roman\n  end\n  local roman_string = roman_numerals[number - 1]\n  local roman_numeral\
    \ = roman_numerals[number]\n  if roman_numeral then\n    return roman_numeral\n\
    \  end\n  local roman_numeral_string = roman_numerals[number - 2]\n  if roman_numeral_string\
    \ then\n    return roman_numeral_string\n  end\n  return roman_string\nend", " \
    \ local roman = romans[number]\n  if roman == nil then\n    error(\"Invalid number:\
    \ \" .. number)\n  end\n  return roman\nend", "  -- Base case: if the number is\
    \ 1, return 'i'.\n  if number == 1 then\n    return 'i'\n  end", "  -- Base case\n\
    \  if number <= 0 then\n    return nil\n  end", "  -- Base case: if the number\
    \ is 1, return the letter 'x'.\n  if number == 1 then\n    return 'x'\n  end",
  "  assert(number >= 1 and number <= 1000, 'Invalid argument: number must be between\
    \ 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number do\n  \
    \  roman = roman .. mini_roman[i]\n    i = i + 1\n  end\n  return roman:lower()\n\
    end", "  assert(number >= 1 and number <= 1000)\n  local roman = roman_table\n\
    \  for i = 1, number do\n    roman = roman[roman]\n  end\n  return roman\nend",
  "  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number] or ''\n    local roman_numeral = roman\n    for i = 1, 4 do\n\
    \      roman_numeral = roman_numeral .. romans[math.floor((number / 1000) + i\
    \ * 1000)]\n    end\n    roman = roman_numeral\n  end\n  return roman\nend", " \
    \ -- Base case\n  if number <= 0 then\n    return nil\n  end", "  -- Base case\n\
    \  if number <= 0 then\n    return nil\n  end", "  assert(number >= 1 and number\
    \ <= 1000)\n  local roman = string.char()\n  local i = 1\n  while i <= number\
    \ do\n    roman = roman .. string.sub(roman, -1)\n    i = i + 1\n  end\n  return\
    \ string.lower(roman)\nend", "  assert(number >= 1 and number <= 1000)\n  local\
    \ roman = romans[number]\n  if roman then\n    return roman\n  end\n  local romans\
    \ = {\n    100 = 'M',\n    900 = 'CM',\n    500 = 'D',\n    400 = 'CD',\n    100\
    \ = 'C',\n    90 = 'XC',\n    50 = 'L',\n    40 = 'XL',\n    10 = 'X',\n    9\
    \ = 'IX',\n    5 = 'V',\n    4 = 'IV',\n    1 = 'I',\n  }\n  local roman = ''\n\
    \  local i = 1\n  while i <= number do\n    roman = roman .. romans[i + 1]\n \
    \   i = i + 1\n  end\n  return roman\nend", "  -- Base case\n  if number <= 0\
    \ then\n    return nil\n  end", "  local roman = romans[number]\n  if roman ==\
    \ nil then\n    roman = romans[number] = romans[number] or ''\n    local i = 1\n\
    \    while i < number do\n      roman = roman .. romans[math.floor((number % 1000)\
    \ / 100)]\n      number = math.floor(number / 100)\n      i = i + 1\n    end\n\
    \  end\n  return roman\nend", "  local roman = roman_to_int()\n  local roman_number\
    \ = roman[number]\n  if roman_number == nil then\n    return \"?\"\n  end\n  local\
    \ roman_numeral = roman_number[1]\n  local roman_numeral_lower = roman_numeral:lower()\n\
    \  local roman_numeral_upper = roman_numeral:upper()\n  local roman_numeral_lower\
    \ = roman_numeral_lower:gsub(\"^%l\", function()\n    return string.char(tonumber(string.format(\"\
    %0d\", tonumber(roman_numeral_lower)))) -- Roman->Arabic\n  end)\n  local roman_numeral_upper\
    \ = roman_numeral_upper:gsub(\"^%l\", function()\n    return string.char(tonumber(string.format(\"\
    %0d\", tonumber(roman_numeral_upper)))) -- Roman->Arabic\n  end)\n  local roman_numeral_lower\
    \ = roman_numeral_lower:gsub(\"%l\", function()\n    return string.char(tonumber(string.format(\"\
    %0d\", tonumber(roman_numeral_lower)))) -- Roman->Arabic\n  end)\n  local roman_numeral_upper\
    \ = roman_numeral_upper:gsub(\"%l\", function()\n    return string.char(tonumber(string.format(\"\
    %0d\", tonumber(roman_numeral_upper)))) -- Roman->Arabic\n  end)\n  local roman_numeral_lower\
    \ = roman_numeral_lower:gsub(\"%u\", function()\n    return string.char(tonumber(string.format(\"\
    %0d\", tonumber(roman_numeral_lower)))) -- Roman->Arabic\n  end)\n  local roman_numeral_upper\
    \ = roman_numeral_upper:gsub(\"%u\", function()\n    return string.char(tonumber(string.format(\"\
    %0d\", tonumber(roman_numeral_upper)))) -- Roman->Arabic\n  end)\n  local roman_numeral_lower\
    \ = roman_numeral_lower:gsub(\"%c\", function()\n    return string.char(tonumber(string.format(\"\
    %0d\", tonumber(roman_numeral_lower)))) -- Roman->Arabic\n  end)\n  local roman_numeral_upper\
    \ = roman_numeral_upper:gsub(\"%c\", function()\n    return string.char(tonumber(string.format(\"\
    %0d\", tonumber(roman_numeral_upper)))) -- Roman->Arabic\n  end)\n  local ro",
  "  -- Base cases\n  if number <= 0 then\n    return nil\n  end\n  if number <= 3\
    \ then\n    return string.format('%c%s', \"M\", int_to_mini_roman(number - 1))\n\
    \  end\n  if number <= 6 then\n    return string.format('%c%s', \"CM\", int_to_mini_roman(number\
    \ - 3))\n  end\n  if number <= 9 then\n    return string.format('%c%s', \"D\"\
    , int_to_mini_roman(number - 6))\n  end\n  if number <= 12 then\n    return string.format('%c%s',\
    \ \"CD\", int_to_mini_roman(number - 9))\n  end\n  if number <= 15 then\n    return\
    \ string.format('%c%s', \"C\", int_to_mini_roman(number - 12))\n  end\n  if number\
    \ <= 18 then\n    return string.format('%c%s', \"XC\", int_to_mini_roman(number\
    \ - 15))\n  end\n  if number <= 21 then\n    return string.format('%c%s', \"L\"\
    , int_to_mini_roman(number - 18))\n  end\n  if number <= 24 then\n    return string.format('%c%s',\
    \ \"XL\", int_to_mini_roman(number - 21))\n  end\n  if number <= 27 then\n   \
    \ return string.format('%c%s', \"X\", int_to_mini_roman(number - 24))\n  end\n\
    \  if number <= 30 then\n    return string.format('%c%s', \"IX\", int_to_mini_roman(number\
    \ - 27))\n  end\n  if number <= 33 then\n    return string.format('%c%s', \"V\"\
    , int_to_mini_roman(number - 30))\n  end\n  if number <= 36 then\n    return string.format('%c%s',\
    \ \"IV\", int_to_mini_roman(number - 33))\n  end\n  if number <= 39 then\n   \
    \ return string.format('%c%s', \"I\", int_to_mini_roman(number - 36))\n  end\n\
    \  if number <= 42 then\n    return string.format('%c%s', \"VI\", int_to_mini_roman(number\
    \ - 39))\n  end\n  if number <= 45 then\n    return string.format('%c%s', \"I\"\
    , int_to_mini_roman(number - 42))\n  end\n  if number <= 48 then\n    return string.format('%c%s',\
    \ \"IV\", int_to_mini_roman(number - 45))\n  end\n  if number <= 51 then\n   \
    \ return string.format('%c%s', \"V\", int_to_mini_roman(number - 48))\n  end\n",
  "  -- The number should be between 1 and 999.\n  assert(number >= 1 and number <=\
    \ 999)", "  local roman = string.gsub(\n    string.rep('MCMXCIV', number),\n \
    \   '(..)',\n    function(c)\n      return string.char(tonumber(c) + 1)\n    end\n\
    \  )\n  return string.lower(roman)\nend", "  local roman = roman_to_int()\n  local\
    \ roman_string = roman[number]\n  return roman_string:lower()\nend", "  -- We\
    \ use a lookup table to speed up the computation.\n  local romans = {\n    I =\
    \ 'i',\n    V = 'v',\n    X = 'x',\n    L = 'l',\n    C = 'c',\n    D = 'd',\n\
    \    M = 'm',\n    \n    II ='ii',\n    III = 'iii',\n    IV = 'iv',\n    VI =\
    \ 'vi',\n    \n    XI = 'xii',\n    XII = 'xiii',\n    XIII = 'xiv',\n    XIV\
    \ = 'xvi',\n    \n    XL = 'xli',\n    \n    LX = 'lxx',\n    \n    CX = 'cxx',\n\
    \    \n    DX = 'dx',\n    \n    CM = 'cm',\n    \n    MC = 'mc',\n    \n    MM\
    \ = 'mm',\n  }\n  \n  -- Handle special cases.\n  if number == 0 then\n    return\
    \ '0'\n  elseif number == 1 then\n    return 'i'\n  elseif number == 2 then\n\
    \    return 'v'\n  elseif number == 3 then\n    return 'x'\n  elseif number ==\
    \ 4 then\n    return 'l'\n  elseif number == 5 then\n    return 'c'\n  elseif\
    \ number == 6 then\n    return 'd'\n  elseif number == 7 then\n    return 'm'\n\
    \  elseif number == 8 then\n    return 'i'\n  elseif number == 9 then\n    return\
    \ 'v'\n  elseif number == 10 then\n    return 'x'\n  elseif number == 11 then\n\
    \    return 'l'\n  elseif number == 12 then\n    return 'c'\n  elseif number ==\
    \ 13 then\n    return 'd'\n  elseif number == 14 then\n    return 'm'\n  elseif\
    \ number == 15 then\n    return 'i'\n  elseif number == 16 then\n    return 'v'\n\
    \  elseif number == 17 then\n    return 'x'\n  elseif number == 18 then\n    return\
    \ 'l'\n  elseif number == 19 then\n    return 'c'\n  elseif number == 20 then\n\
    \    return 'd'\n  elseif number == 21 then\n    return 'm'\n  elseif number ==\
    \ 22 then\n    return 'i'\n  elseif number == 23 then\n    return 'v'\n  elseif\
    \ number == 24 then\n    return 'x'\n  elseif number == 25 then\n    return 'l'\n\
    \  elseif number == 26 then\n    return 'c'\n  elseif number == 27 then\n    return\
    \ 'd'\n  elseif number == 28 then\n    return 'm'\n  elseif number == 29 then\n\
    \    return 'i'\n  ", "  local roman = string.gsub(\n    string.rep('MCMXCIV',\
    \ number),\n    '(..)',\n    function(c)\n      return string.char(tonumber(c))\n\
    \    end\n  )\n  return string.lower(roman)\nend", "  local roman = romans[number]\n\
    \  if roman == nil then\n    roman = romans[number] = romans[number]\n    for\
    \ i = 1, number do\n      roman = roman..romans[math.floor((number-i)/100)]..romans[math.floor((number-i)%100)]\n\
    \    end\n  end\n  return roman\nend", "  assert(number >= 1 and number <= 1000,\
    \ 'Invalid input: number must be between 1 and 1000')\n  local roman = ''\n  local\
    \ i = 1\n  while i <= number do\n    roman = roman .. roman_numeral(i)\n    i\
    \ = i + 1\n  end\n  return roman:lower()\nend", "  -- Base case\n  if number <=\
    \ 0 then\n    return nil\n  end", "  assert(number >= 1 and number <= 1000, 'Invalid\
    \ input: number must be between 1 and 1000')\n  local roman = ''\n  local i =\
    \ 1\n  while i <= number do\n    roman = roman .. mini_roman[i]\n    i = i + 1\n\
    \  end\n  return roman:lower()\nend", "  local roman = string.gsub(\n    string.rep(\"\
    MCMXCIV\", number),\n    \"(..)\",\n    function(c)\n      if c == \"M\" then\n\
    \        return \"MM\"\n      elseif c == \"D\" then\n        return \"DD\"\n\
    \      elseif c == \"C\" then\n        return \"CC\"\n      elseif c == \"X\"\
    \ then\n        return \"XL\"\n      elseif c == \"V\" then\n        return \"\
    VV\"\n      elseif c == \"I\" then\n        return \"II\"\n      else\n      \
    \  return c\n      end\n    end\n  )\n  return string.lower(roman)\nend", "  --\
    \ Base case: if the number is 1, return 'i'.\n  if number == 1 then\n    return\
    \ 'i'\n  end", "  local roman = roman_to_int()\n  local roman_numeral = ''\n \
    \ local roman_numeral_length = 0\n  local roman_numeral_length_index = 0\n  local\
    \ roman_numeral_length_limit = roman:len()\n  while number > 0 do\n    local remainder\
    \ = number % 100\n    number = number / 100\n    roman_numeral = roman:sub(1,\
    \ roman_numeral_length_index) .. roman_numeral\n    roman_numeral_length_index\
    \ = roman_numeral_length_index + 1\n    if roman_numeral_length_index > roman_numeral_length_limit\
    \ then\n      roman_numeral = roman:sub(roman_numeral_length_index) .. roman_numeral\n\
    \      roman_numeral_length_index = roman_numeral_length_index - 1\n    end\n\
    \    if remainder >= 1000 then\n      roman_numeral = roman:sub(roman_numeral_length_index)\
    \ .. roman_numeral\n      roman_numeral_length_index = roman_numeral_length_index\
    \ - 1\n      roman_numeral = roman:sub(roman_numeral_length_index) .. roman_numeral\n\
    \      roman_numeral_length_index = roman_numeral_length_index - 1\n    end\n\
    \  end\n  return roman_numeral:lower()\nend", "  local roman = roman_to_int()\n\
    \  local roman_numeral = ''\n  local i = 1\n  while i <= number do\n    local\
    \ remainder = number % i\n    roman_numeral = roman[remainder] .. roman_numeral\n\
    \    number = number / i\n    i = i + 1\n  end\n  return roman_numeral:lower()\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  -- Base\
    \ case\n  if number <= 0 then\n    return nil\n  end", "  -- Base case\n  if number\
    \ <= 0 then\n    return nil\n  end", "  -- Initialize result to empty string.\n\
    \  local result = \"\"", "  local roman = string.gsub(\n    roman_numerals[number],\n\
    \    \"%d\",\n    function(digit)\n      return string.char(tonumber(digit))\n\
    \    end\n  )\n  return string.lower(roman)\nend", "  assert(number >= 1 and number\
    \ <= 1000)\n  local roman = romans[number]\n  if roman == nil then\n    roman\
    \ = romans[number] = romans[number] or ''\n    local i = 1\n    while i <= math.floor(math.log(number,\
    \ 2)) do\n      roman = roman .. romans[math.floor(number / math.pow(1000, i))]\n\
    \      i = i + 1\n    end\n  end\n  return roman:lower()\nend", "  assert(number\
    \ >= 1 and number <= 1000)\n  local roman = ''\n  local i = 1\n  while i <= number\
    \ do\n    roman = roman .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\n\
    end", "  -- Base case: number is less than or equal to 1.\n  if number <= 1 then\n\
    \    return number\n  end", "  -- We use an auxiliary table to speed up the computation.\n\
    \  local roman = {}\n  local i = 1\n  while i <= number do\n    roman[i] = i\n\
    \    i = i * 10\n  end\n  -- Convert the number to a string.\n  local roman_number\
    \ = \"\"\n  local i = 1\n  while i <= number do\n    roman_number = roman_number\
    \ .. roman[i]\n    i = i * 10\n  end\n  -- Return the string in lowercase.\n \
    \ return roman_number:lower()\nend", "  -- Base case\n  if number <= 0 then\n\
    \    return nil\n  end", "  local roman = string.gsub(\n    string.rep('MCMXCIV',\
    \ number),\n    '(..)',\n    function(c)\n      return string.char(tonumber(c))\n\
    \    end\n  )\n  return string.lower(roman)\nend", "  -- Base case\n  if number\
    \ <= 0 then\n    return nil\n  end", "  -- Base case\n  if number <= 0 then\n\
    \    return nil\n  end", "  assert(number >= 1 and number <= 1000)\n  local roman\
    \ = romans[number]\n  if roman == nil then\n    roman = romans[number] = romans[number]\
    \ or ''\n    local i = 1\n    while i <= math.floor(math.log(number, 2)) do\n\
    \      roman = roman .. romans[math.floor(number / math.pow(1000, i))]\n     \
    \ i = i + 1\n    end\n  end\n  return roman\nend", "  -- Base case\n  if number\
    \ <= 0 then\n    return ''\n  end", "  -- Base case\n  if number <= 0 then\n \
    \   return nil\n  end", "  local roman = roman_to_int()\n  local roman_numeral\
    \ = ''\n  local roman_numeral_length = roman.len\n  local roman_numeral_length\
    \ = roman_numeral_length or 0\n  local roman_numeral_length = roman_numeral_length\
    \ + roman_numeral_length - 1\n  while number > 0 do\n    local remainder = number\
    \ % roman_numeral_length\n    roman_numeral = roman.roman[remainder] .. roman_numeral\n\
    \    number = math.floor(number / roman_numeral_length)\n  end\n  return roman_numeral:lower()\n\
    end", "  -- Base case\n  if number <= 0 then\n    return ''\n  end", "  local\
    \ roman = roman_numerals(number)\n  local roman_numeral = ''\n  for i = 1, #roman\
    \ do\n    roman_numeral = roman_numeral .. roman[i]\n  end\n  return roman_numeral:lower()\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  assert(number\
    \ >= 1 and number <= 1000, 'Invalid input: number must be between 1 and 1000')\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. mini_roman[i]\n    i = i + 1\n  end\n  return roman:lower()\nend", "  assert(number\
    \ >= 1 and number <= 1000)\n  local roman = string.gsub(\n    string.gsub(\n \
    \     string.rep('MCMXC', number),\n      '(..)',\n      '%1,%2'\n    ),\n   \
    \ '(..)',\n    '%1'\n  )\n  roman = string.gsub(roman, '(..)', '%1,%2')\n  roman\
    \ = string.gsub(roman, '%1,%2', '(..)')\n  return roman\nend", "  -- Base case\n\
    \  if number <= 0 then\n    return ''\n  end\n  -- Recursive case\n  if number\
    \ <= 3 then\n    return mini_romans[number]\n  end\n  -- Recursive case\n  local\
    \ roman = mini_romans[number - 3]\n  roman = roman .. mini_romans[number - 2]\n\
    \  roman = roman .. mini_romans[number - 1]\n  return roman\nend", "  -- Base\
    \ case\n  if number <= 0 then\n    return nil\n  end", "  -- The number should\
    \ be between 1 and 999.\n  assert(number >= 1 and number <= 999)\n  -- The number\
    \ should be divisible by 100 (since we only care about the\n  -- hundreds).\n\
    \  assert(number % 100 == 0)\n  -- The number should be divisible by 400 (since\
    \ we only care about the\n  -- hundreds).\n  assert(number % 400 == 0)\n  -- The\
    \ number should be divisible by 100 (since we only care about the\n  -- hundreds).\n\
    \  assert(number % 100 == 0)\n  -- The number should be divisible by 400 (since\
    \ we only care about the\n  -- hundreds).\n  assert(number % 400 == 0)\n  -- The\
    \ number should be divisible by 100 (since we only care about the\n  -- hundreds).\n\
    \  assert(number % 100 == 0)\n  -- The number should be divisible by 400 (since\
    \ we only care about the\n  -- hundreds).\n  assert(number % 400 == 0)\n  -- The\
    \ number should be divisible by 100 (since we only care about the\n  -- hundreds).\n\
    \  assert(number % 100 == 0)\n  -- The number should be divisible by 400 (since\
    \ we only care about the\n  -- hundreds).\n  assert(number % 400 == 0)\n  -- The\
    \ number should be divisible by 100 (since we only care about the\n  -- hundreds).\n\
    \  assert(number % 100 == 0)\n  -- The number should be divisible by 400 (since\
    \ we only care about the\n  -- hundreds).\n  assert(number % 400 == 0)\n  -- The\
    \ number should be divisible by 100 (since we only care about the\n  -- hundreds).\n\
    \  assert(number % 100 == 0)\n  -- The number should be divisible by 400 (since\
    \ we only care about the\n  -- hundreds).\n  assert(number % 400 == 0)\n  -- The\
    \ number should be divisible by 100 (since we only care about the\n  -- hundreds).\n\
    \  assert(number % 100 == 0)\n  -- The number should be divisible by 400 (since\
    \ we only care about the\n  -- hundreds).\n  assert(number % 400 == 0)\n  -- The\
    \ number should be divisible by 100 (since we only care about the\n  -- hundreds).\n\
    \  assert(number % 100 == 0)\n  -- The number should be divisible by 400 (since\
    \ we only care about the\n  -- hundreds).\n  assert(number % ", "  local roman\
    \ = roman_numeral()\n  local roman_string = roman[number]\n  local roman_string\
    \ = roman_string:lower()\n  return roman_string\nend", "  assert(number >= 1 and\
    \ number <= 1000)\n  local roman = romans[number]\n  if roman == nil then\n  \
    \  roman = romans[number] = romans[number]\n    for i = 1, 4 do\n      roman =\
    \ roman..romans[math.floor((number/1000+i)*100)]\n    end\n  end\n  return roman\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  -- Base\
    \ case\n  if number <= 0 then\n    return nil\n  end", "  -- Base case\n  if number\
    \ <= 0 then\n    return nil\n  end", "  -- Base case\n  if number <= 0 then\n\
    \    return nil\n  end", "  local roman = romans[number]\n  if roman == nil then\n\
    \    roman = romans[number] = romans[number]\n    for i = 1, number do\n     \
    \ roman = roman .. romans[math.floor((number - i) / i)]\n    end\n  end\n  return\
    \ roman\nend", "  -- Base case\n  if number <= 0 then\n    return nil\n  end",
  "  assert(number >= 1 and number <= 1000)\n  local roman = string.gsub(\n    string.rep('MCMXCIV',\
    \ 1, number),\n    '(..)',\n    function(digit)\n      assert(digit >= 1 and digit\
    \ <= 4)\n      return string.format('%1s', digit)\n    end\n  )\n  assert(#roman\
    \ == number)\n  return string.lower(roman)\nend", "  local roman = roman_numerals[number]\n\
    \  if roman == nil then\n    error(\"Invalid number: \" .. number)\n  end\n  return\
    \ roman:lower()\nend", "  -- Base case\n  if number <= 0 then\n    return nil\n\
    \  end\n  -- Recursive case\n  local roman = int_to_mini_roman(number / 10)\n\
    \  local remainder = number % 10\n  if remainder >= 5 then\n    return roman ..\
    \ 'vi'\n  elseif remainder >= 1 then\n    return roman .. 'i'\n  else\n    return\
    \ roman\n  end\nend", "  assert(number >= 1 and number <= 1000, 'Invalid input:\
    \ number must be between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while\
    \ i <= number do\n    roman = roman .. mini_roman(i)\n    i = i + 1\n  end\n \
    \ return roman:lower()\nend", "  local roman = romans[number]\n  if roman == nil\
    \ then\n    error(\"Invalid number: \" .. number)\n  end\n  local roman_numeral\
    \ = \"\"\n  local i = 1\n  while i <= #roman do\n    local char = roman[i]\n \
    \   if char == \"M\" then\n      roman_numeral = roman_numeral .. \"M\"\n    elseif\
    \ char == \"D\" then\n      roman_numeral = roman_numeral .. \"C\"\n    elseif\
    \ char == \"C\" then\n      roman_numeral = roman_numeral .. \"L\"\n    elseif\
    \ char == \"L\" then\n      roman_numeral = roman_numeral .. \"X\"\n    elseif\
    \ char == \"X\" then\n      roman_numeral = roman_numeral .. \"V\"\n    elseif\
    \ char == \"V\" then\n      roman_numeral = roman_numeral .. \"I\"\n    elseif\
    \ char == \"I\" then\n      roman_numeral = roman_numeral .. \"I\"\n    else\n\
    \      roman_numeral = roman_numeral .. char\n    end\n    i = i + 1\n  end\n\
    \  return roman_numeral:lower()\nend", "  local roman = roman_to_int()\n  local\
    \ roman_numeral = ''\n  local i = 1\n  while i < number do\n    local remainder\
    \ = number % i\n    roman_numeral = roman_numeral .. roman[remainder]\n    i =\
    \ i + 1\n  end\n  return roman_numeral:lower()\nend", "  assert(number >= 1 and\
    \ number <= 1000, 'Invalid input: number must be between 1 and 1000')\n  local\
    \ roman = string.char()\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. string.sub(i, 1, i)\n    i = i + 1\n  end\n  return string.lower(roman)\n\
    end", "  -- Base case: num is 0 or 1.\n  if number <= 1 then\n    return string.format('%c%s',\
    \ 1, string.sub(mini_roman, number, number))\n  end", "  local roman = romans[number]\n\
    \  if roman == nil then\n    roman = romans[number] = romans[number]\n    for\
    \ i = 1, number do\n      roman = roman..romans[math.floor((number-i)/100)]..romans[math.floor((number-i)%100)]\n\
    \    end\n  end\n  return roman\nend", "  -- Base case\n  if number <= 0 then\n\
    \    return ''\n  end", "  -- Base case\n  if number <= 0 then\n    return nil\n\
    \  end", "  assert(number >= 1 and number <= 1000, 'Invalid input: number must\
    \ be between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number\
    \ do\n    roman = roman .. mini_roman[i]\n    i = i + 1\n  end\n  return roman\n\
    end", "  assert(number >= 1 and number <= 1000, 'Invalid input: number must be\
    \ between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number\
    \ do\n    roman = roman .. roman_table[i]\n    i = i + 1\n  end\n  return string.lower(roman)\n\
    end", "  assert(number >= 1 and number <= 1000)\n  local roman = string.char()\n\
    \  local i = 1\n  while i <= number do\n    roman = roman .. string.sub(roman_numerals,\
    \ i - 1, 1)\n    i = i + 1\n  end\n  return string.lower(roman)\nend", "  -- Base\
    \ case: if the number is 1, return 'i'.\n  if number == 1 then\n    return 'i'\n\
    \  end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  local roman = int_to_mini_roman(number / 10)\n  local remainder = number\
    \ % 10\n  if remainder == 0 then\n    return roman\n  else\n    return roman ..\
    \ mini_roman[remainder]\n  end\nend", "  -- Base case\n  if number <= 0 then\n\
    \    return nil\n  end", "  local roman = string.gsub(\n    string.rep(\"MCMXCIV\"\
    , number),\n    \"^([M])(.*)$\",\n    \"\\1\\2\"\n  )\n  return string.lower(roman)\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  -- Base\
    \ case\n  if number <= 0 then\n    return nil\n  end", "  -- Base case\n  if number\
    \ <= 0 then\n    return nil\n  end", "  -- Base case\n  if number <= 0 then\n\
    \    return nil\n  end", "  -- Base case\n  if number <= 0 then\n    return nil\n\
    \  end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  local\
    \ roman = romans[number]\n  if roman == nil then\n    roman = romans[number] =\
    \ romans[number] or ''\n    local i = 1\n    while i <= math.floor(math.log(number,\
    \ 2)) do\n      roman = roman..romans[math.floor(number / math.pow(1000, i))]\n\
    \      i = i + 1\n    end\n  end\n  return roman\nend", "  -- Base case\n  if\
    \ number <= 0 then\n    return nil\n  end", "  local roman = roman_numeral()\n\
    \  local roman_number = ''\n  local i = 1\n  while i < number do\n    local roman_number\
    \ = roman[i]\n    roman_number = roman_number:lower() .. roman_number:sub(1, roman_number:len())\n\
    \    i = i + 1\n  end\n  return roman_number\nend", "  assert(number >= 1 and\
    \ number <= 1000, \"Invalid number: \" .. tostring(number))\n  local roman = roman_numerals[number]\n\
    \  if roman then\n    return roman\n  end\n  local roman = roman_numerals[number\
    \ - 1000]\n  if roman then\n    return roman\n  end\n  local roman = roman_numerals[number\
    \ - 500]\n  if roman then\n    return roman\n  end\n  local roman = roman_numerals[number\
    \ - 100]\n  if roman then\n    return roman\n  end\n  local roman = roman_numerals[number\
    \ - 50]\n  if roman then\n    return roman\n  end\n  local roman = roman_numerals[number\
    \ - 10]\n  if roman then\n    return roman\n  end\n  local roman = roman_numerals[number\
    \ - 1]\n  if roman then\n    return roman\n  end\n  return nil\nend", "  local\
    \ roman = roman_numerals(number)\n  local roman_string = roman[1]\n  for i = 2,\
    \ #roman do\n    roman_string = roman_string .. roman[i]\n  end\n  return roman_string:lower()\n\
    end", "  local roman = roman_to_int()\n  local roman_numeral = ''\n  local i =\
    \ 1\n  while i < number do\n    local remainder = number % 100\n    number = number\
    \ - remainder\n    roman_numeral = roman[roman_to_int()] .. roman_numeral\n  \
    \  i = i + 1\n  end\n  return roman_numeral:lower()\nend", "  assert(number >=\
    \ 1 and number <= 1000, 'Invalid input: number must be between 1 and 1000')\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. mini_roman[i]\n    i = i + 1\n  end\n  return roman:lower()\nend", "  assert(number\
    \ >= 1 and number <= 1000, 'Invalid number: ' .. tostring(number))\n  local roman\
    \ = ''\n  local i = 1\n  while i <= number do\n    roman = roman .. roman_table[i]\n\
    \    i = i + 1\n  end\n  return roman:lower()\nend", "  -- Initialize variables\n\
    \  local roman = ''\n  local numeral = ''\n  local denominator = 1\n  -- Iterate\
    \ until we run out of numbers\n  while number > 0 do\n    -- Get the next number\
    \ in the sequence\n    numeral = math.floor(number / denominator)\n    -- Get\
    \ the remainder after dividing by the denominator\n    number = number % denominator\n\
    \    -- Add the numeral to the roman\n    roman = roman .. numeral\n    -- Divide\
    \ the denominator by the numeral\n    denominator = numeral\n  end\n  return roman\n\
    end", "  assert(number >= 1 and number <= 1000)\n  local roman = romans[number]\n\
    \  if roman == nil then\n    roman = romans[number] = romans[number] or ''\n \
    \   local i = 1\n    while i <= math.floor(math.log(number, 2)) do\n      roman\
    \ = roman .. romans[math.floor(number / math.pow(1000, i))]\n      i = i + 1\n\
    \    end\n  end\n  return roman:lower()\nend", "  local roman = string.gsub(\n\
    \    string.rep('MCMXC', number),\n    '(..)',\n    function(c)\n      if c ==\
    \ 'M' then return 'MM'\n      elseif c == 'D' then return 'DD'\n      elseif c\
    \ == 'C' then return 'CC'\n      elseif c == 'X' then return 'XL'\n      elseif\
    \ c == 'L' then return 'LL'\n      elseif c == 'M' then return 'IX'\n      elseif\
    \ c == 'C' then return 'IV'\n      elseif c == 'X' then return 'VI'\n      elseif\
    \ c == 'L' then return 'IX'\n      elseif c == 'I' then return 'I'\n      elseif\
    \ c == 'V' then return 'V'\n      elseif c == 'X' then return 'X'\n      elseif\
    \ c == 'L' then return 'L'\n      elseif c == 'I' then return 'I'\n      elseif\
    \ c == 'V' then return 'V'\n      elseif c == 'X' then return 'X'\n      elseif\
    \ c == 'L' then return 'L'\n      elseif c == 'I' then return 'I'\n      elseif\
    \ c == 'V' then return 'V'\n      elseif c == 'X' then return 'X'\n      elseif\
    \ c == 'L' then return 'L'\n      elseif c == 'I' then return 'I'\n      elseif\
    \ c == 'V' then return 'V'\n      elseif c == 'X' then return 'X'\n      elseif\
    \ c == 'L' then return 'L'\n      elseif c == 'I' then return 'I'\n      elseif\
    \ c == 'V' then return 'V'\n      elseif c == 'X' then return 'X'\n      elseif\
    \ c == 'L' then return 'L'\n      elseif c == 'I' then return 'I'\n      elseif\
    \ c == 'V' then return 'V'\n      elseif c == 'X' then return 'X'\n      elseif\
    \ c == 'L' then return 'L'\n      elseif c == 'I' then return 'I'\n      elseif\
    \ c == 'V' then return 'V'\n      elseif c == 'X' then return 'X'\n      elseif\
    \ c == 'L' then return 'L'\n      elseif c == 'I' then return ", "  -- Base case\n\
    \  if number <= 0 then\n    return nil\n  end", "  -- We use a lookup table to\
    \ speed up the computation.\n  local romans = {\n    I = 'i',\n    II = 'ii',\n\
    \    III = 'iii',\n    IV = 'iv',\n    V = 'v',\n    VI = 'vi',\n    VII = 'vii',\n\
    \    VIII = 'viii',\n    IX = 'ix',\n  }\n  -- The first 12 numbers are in upper\
    \ case.\n  local roman_numerals = {\n    I = 'i',\n    II = 'ii',\n    III = 'iii',\n\
    \    IV = 'iv',\n    V = 'v',\n    VI = 'vi',\n    VII = 'vii',\n    VIII = 'viii',\n\
    \    IX = 'ix',\n  }\n  -- The first 12 numbers are in lower case.\n  local roman_numerals_lower\
    \ = {\n    I = 'i',\n    II = 'ii',\n    III = 'iii',\n    IV = 'iv',\n    V =\
    \ 'v',\n    VI = 'vi',\n    VII = 'vii',\n    VIII = 'viii',\n    IX = 'ix',\n\
    \  }\n  -- The first 12 numbers are in upper case.\n  local roman_numerals_upper\
    \ = {\n    I = 'I',\n    II = 'II',\n    III = 'III',\n    IV = 'IV',\n    V =\
    \ 'V',\n    VI = 'VI',\n    VII = 'VII',\n    VIII = 'VIII',\n    IX = 'IX',\n\
    \  }\n  -- The first 12 numbers are in lower case.\n  local roman_numerals_lower_upper\
    \ = {\n    I = 'I',\n    II = 'II',\n    III = 'III',\n    IV = 'IV',\n    V =\
    \ 'V',\n    VI = 'VI',\n    VII = 'VII',\n    VIII = 'VIII',\n    IX = 'IX',\n\
    \  }\n  -- The first 12 numbers are in upper case.\n  local roman_numerals_upper_lower\
    \ = {\n    I = 'I',\n    II = 'II',\n    III = 'III',\n    IV = 'IV',\n    V =\
    \ 'V',\n    VI = 'VI',\n    VII = 'VII',\n    VIII = 'VIII',\n    IX = 'IX',\n\
    \  }\n  -- The first 12 numbers are in lower case.\n  local roman_numerals_lower_lower\
    \ = {\n    I = 'i',\n    II = 'ii',", "  local roman = roman_to_int()\n  local\
    \ roman_num = 0\n  local roman_num_str = ''\n  local roman_num_str_index = 0\n\
    \  local roman_num_str_len = #roman_num_str\n  local roman_num_str_len_index =\
    \ 0\n  while roman_num_str_len_index < roman_num_str_len do\n    local roman_num_str\
    \ = roman_num_str .. roman[roman_num_str_index] .. roman[roman_num_str_index +\
    \ 1]\n    roman_num_str_index = roman_num_str_index + 2\n    roman_num_str_len_index\
    \ = roman_num_str_len_index + 2\n  end\n  while roman_num_str_index < roman_num_str_len\
    \ do\n    roman_num_str = roman_num_str .. roman[roman_num_str_index]\n    roman_num_str_index\
    \ = roman_num_str_index + 1\n    roman_num_str_len_index = roman_num_str_len_index\
    \ + 1\n  end\n  while roman_num_str_index < roman_num_str_len do\n    roman_num_str\
    \ = roman_num_str .. roman[roman_num_str_index + 1]\n    roman_num_str_index =\
    \ roman_num_str_index + 2\n    roman_num_str_len_index = roman_num_str_len_index\
    \ + 2\n  end\n  while roman_num_str_index < roman_num_str_len do\n    roman_num_str\
    \ = roman_num_str .. roman[roman_num_str_index + 1]\n    roman_num_str_index =\
    \ roman_num_str_index + 2\n    roman_num_str_len_index = roman_num_str_len_index\
    \ + 2\n  end\n  while roman_num_str_index < roman_num_str_len do\n    roman_num_str\
    \ = roman_num_str .. roman[roman_num_str_index + 1]\n    roman_num_str_index =\
    \ roman_num_str_index + 2\n    roman_num_str_len_index = roman_num_str_len_index\
    \ + 2\n  end\n  while roman_num_str_index < roman_num_str_len do\n    roman_num_str\
    \ = roman_num_str .. roman[roman_num_str_index + 1]\n    roman_num_str_index =\
    \ roman_num_str_index + 2\n    roman_num_str_len_index = roman_num_str_len_index\
    \ + 2\n  end\n  while roman_num_str_index < roman_num_str_len do\n    roman_num_str\
    \ = roman_num_str .. roman[roman_num_str_index + 1]\n    roman_num_str_index =\
    \ roman_", "  assert(number >= 1 and number <= 1000, 'Invalid input: number must\
    \ be between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number\
    \ do\n    roman = roman .. string.sub(i, 1, i)\n    i = i + 1\n  end\n  return\
    \ string.lower(roman)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
