name: HumanEval_0_has_close_elements
language: lua
prompt: "-- Check if in given list of numbers, are any two numbers closer to each\
  \ other than\n-- given threshold.\n-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\n\
  -- false\n-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n-- true\n\
  local function has_close_elements(numbers, threshold)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = has_close_elements\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)\n   \
  \ lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 5.9, 4.0, 5.0}, 0.95), true)\n    lu.assertEquals(candidate({1.0, 2.0, 5.9,\
  \ 4.0, 5.0}, 0.8), false)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0}, 0.1), true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0),\
  \ true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local close = {}\n  for _, value in pairs(numbers) do\n    local\
    \ close_value = false\n    for _, other_value in pairs(numbers) do\n      if other_value\
    \ == value then\n        close_value = true\n        break\n      end\n    end\n\
    \    if close_value then\n      table.insert(close, value)\n    end\n  end\n \
    \ return #close > 0 and #close == #numbers and #close == #close and #close ~=\
    \ #numbers and #close ~= #close and #close ~= #close and #close ~= #close and\
    \ #close ~= #close and #close ~= #close and #close ~= #close and #close ~= #close\
    \ and #close ~= #close and #close ~= #close and #close ~= #close and #close ~=\
    \ #close and #close ~= #close and #close ~= #close and #close ~= #close and #close\
    \ ~= #close and #close ~= #close and #close ~= #close and #close ~= #close and\
    \ #close ~= #close and #close ~= #close and #close ~= #close and #close ~= #close\
    \ and #close ~= #close and #close ~= #close and #close ~= #close and #close ~=\
    \ #close and #close ~= #close and #close ~= #close and #close ~= #close and #close\
    \ ~= #close and #close ~= #close and #close ~= #close and #close ~= #close and\
    \ #close ~= #close and #close ~= #close and #close ~= #close and #close ~= #close\
    \ and #close ~= #close and #close ~= #close and #close ~= #close and #close ~=\
    \ #close and #close ~= #close and #close ~= #close and #close ~= #close and #close\
    \ ~= #close and #close ~= #close and #close ~= #close and #close ~= #close and\
    \ #close ~= #close and #close ~= #close and #close ~= #close and #close ~= #close\
    \ and #close ~= #close and #close ~= #close and #close ~= #close and #close ~=\
    \ #close and #close ~= #close and #close ~= #close and #close ~= #close and #close\
    \ ~= #close and #close ~= ", "  local min_diff = threshold\n  local min_diff_index\
    \ = 1\n  local min_diff_value = numbers[1]\n  for i = 2, #numbers do\n    local\
    \ diff = numbers[i] - numbers[min_diff_index]\n    if diff < min_diff then\n \
    \     min_diff = diff\n      min_diff_index = i\n      min_diff_value = numbers[i]\n\
    \    end\n  end\n  return min_diff_value == min_diff\nend", "  local close = {}\n\
    \  for _, x in ipairs(numbers) do\n    local close_count = 0\n    for _, y in\
    \ ipairs(numbers) do\n      if math.abs(x - y) < threshold then\n        close_count\
    \ = close_count + 1\n      end\n    end\n    if close_count > 1 then\n      return\
    \ true\n    end\n  end\n  return false\nend", "  local close = nil\n  for _, number\
    \ in pairs(numbers) do\n    local close = close\n    or number\n    or math.abs(number\
    \ - numbers[1])\n    or math.abs(number - numbers[2])\n  end\n  return close <=\
    \ threshold\nend", "  local min_distance = math.min(numbers[1][1], numbers[2][1])\n\
    \  for _, number in pairs(numbers) do\n    if number < min_distance then\n   \
    \   min_distance = number\n    end\n  end\n  return min_distance < threshold\n\
    end", "  assert(type(numbers) == 'table')\n  assert(type(threshold) == 'number')\n\
    \  local closed = {}\n  for _, value in pairs(numbers) do\n    local close = false\n\
    \    for _, other_value in pairs(numbers) do\n      if abs(value - other_value)\
    \ < threshold then\n        close = true\n        break\n      end\n    end\n\
    \    if not close then\n      table.insert(closed, value)\n    end\n  end\n  return\
    \ #closed ~= 0\nend", "  local function is_close_element(number)\n    return math.abs(number\
    \ - threshold) < threshold\n  end\n  local function is_close_elements(numbers)\n\
    \    local close = nil\n    for _, number in pairs(numbers) do\n      if close\
    \ ~= nil then\n        if close ~= is_close_element(number) then\n          return\
    \ false\n        end\n      else\n        close = is_close_element(number)\n \
    \     end\n    end\n    return true\n  end\n  return is_close_elements(numbers)\n\
    end", "  local close = {}\n  for _, v in pairs(numbers) do\n    table.insert(close,\
    \ v)\n  end\n  table.sort(close)\n  local i = 1\n  while i <= #close do\n    local\
    \ j = i + 1\n    while j <= #close do\n      if close[j] - close[i] <= threshold\
    \ then\n        return true\n      elseif close[j] - close[i] > threshold then\n\
    \        j = j + 1\n      else\n        i = i + 1\n      end\n    end\n    i =\
    \ i + 1\n  end\n  return false\nend", "  local min_distance = math.min(numbers)\n\
    \  local max_distance = math.max(numbers)\n  local min_distance = math.abs(min_distance)\n\
    \  local max_distance = math.abs(max_distance)\n  local min_distance = math.min(min_distance,\
    \ threshold)\n  local max_distance = math.max(max_distance, threshold)\n  return\
    \ min_distance <= max_distance\nend", "  local close = {}\n  for _, v in pairs(numbers)\
    \ do\n    for _, v2 in pairs(numbers) do\n      if v == v2 and v - threshold <\
    \ v2 and v2 < v + threshold then\n        table.insert(close, v)\n      end\n\
    \    end\n  end\n  return #close > 0 and #close == #numbers and #close == #close\n\
    end", "  local close = {}\n  for _, x in ipairs(numbers) do\n    for _, y in ipairs(numbers)\
    \ do\n      if math.abs(x - y) < threshold then\n        table.insert(close, x)\n\
    \      end\n    end\n  end\n  return #close ~= 0\nend", "  local num_pairs = #numbers\
    \ - 1\n  local closed_pairs = 0\n  for i = 1, num_pairs do\n    local current_pair\
    \ = numbers[i]\n    for j = i + 1, num_pairs do\n      local next_pair = numbers[j]\n\
    \      if math.abs(current_pair - next_pair) < threshold then\n        closed_pairs\
    \ = closed_pairs + 1\n      end\n    end\n  end\n  return closed_pairs == num_pairs\n\
    end", "  assert(type(numbers) == 'table')\n  assert(type(threshold) == 'number')\n\
    \  local result = {}\n  for _, value in pairs(numbers) do\n    for _, other_value\
    \ in pairs(numbers) do\n      if value == other_value then\n        -- Skip same\
    \ element\n        continue\n      end\n      if math.abs(value - other_value)\
    \ < threshold then\n        result[#result + 1] = value\n        break\n     \
    \ end\n    end\n  end\n  return result\nend", "  local min_distance = math.min(numbers[1])\n\
    \  local min_number = numbers[1][1]\n  for _, number in pairs(numbers) do\n  \
    \  local distance = math.abs(number[1] - min_number)\n    if distance < min_distance\
    \ then\n      min_distance = distance\n      min_number = number[1]\n    end\n\
    \  end\n  return min_distance <= threshold\nend", "  local min_distance = math.min(numbers[1])\n\
    \  for _, value in pairs(numbers) do\n    if min_distance > threshold then\n \
    \     return false\n    end\n    min_distance = math.min(min_distance, value)\n\
    \  end\n  return true\nend", "  local close = {}\n  for _, v in ipairs(numbers)\
    \ do\n    table.insert(close, v)\n  end\n  table.sort(close)\n  for _, v in ipairs(close)\
    \ do\n    if v - threshold < close[#close] then\n      return true\n    end\n\
    \  end\n  return false\nend", "  local function is_close_element(number)\n   \
    \ return math.abs(number - threshold) < threshold\n  end\n  local function is_close_elements(numbers)\n\
    \    local results = {}\n    for _, number in pairs(numbers) do\n      results[#results\
    \ + 1] = is_close_element(number)\n    end\n    return results\n  end\n  return\
    \ is_close_elements(numbers)\nend", "  local close = math.abs(numbers[1] - numbers[2])\n\
    \  for i = 2, #numbers do\n    local close2 = math.abs(numbers[i] - numbers[i\
    \ - 1])\n    if close > close2 then\n      close = close2\n    end\n  end\n  return\
    \ close < threshold\nend", "  assert(type(numbers) == 'table')\n  assert(type(threshold)\
    \ == 'number')\n  local closed = {}\n  for _, v in pairs(numbers) do\n    table.insert(closed,\
    \ v)\n  end\n  table.sort(closed)\n  local closed_size = #closed\n  local closed_index\
    \ = 1\n  while closed_index <= closed_size do\n    local closed_value = closed[closed_index]\n\
    \    local closed_index_next = closed_index + 1\n    while closed_index_next <=\
    \ closed_size do\n      local closed_value_next = closed[closed_index_next]\n\
    \      if closed_value == closed_value_next then\n        closed_index = closed_index_next\n\
    \      else\n        local closed_diff = closed_value - closed_value_next\n  \
    \      if closed_diff <= threshold then\n          return true\n        end\n\
    \      end\n      closed_index_next = closed_index_next + 1\n    end\n    closed_index\
    \ = closed_index + 1\n  end\n  return false\nend", "  local close = {}\n  for\
    \ _, x in ipairs(numbers) do\n    for _, y in ipairs(numbers) do\n      if math.abs(x\
    \ - y) < threshold then\n        table.insert(close, x)\n      end\n    end\n\
    \  end\n  return #close ~= 0\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
