name: HumanEval_100_make_a_pile
language: lua
prompt: "-- Given a positive integer n, you have to make a pile of n levels of stones.\n\
  -- The first level has n stones.\n-- The number of stones in the next level is:\n\
  -- - the next odd number if n is odd.\n-- - the next even number if n is even.\n\
  -- Return the number of stones in each level in a list, where element at index\n\
  -- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile(3)\n\
  -- {3, 5, 7}\nlocal function make_a_pile(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_a_pile\n\
  \    lu.assertEquals(candidate(3), {3, 5, 7})\n    lu.assertEquals(candidate(4),\
  \ {4, 6, 8, 10})\n    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})\n    lu.assertEquals(candidate(6),\
  \ {6, 8, 10, 12, 14, 16})\n    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16,\
  \ 18, 20, 22})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local pile = {}\n  local next_odd\n  local next_even\n  if n then\n\
    \    if n % 2 == 0 then\n      next_even = n / 2\n    else\n      next_odd = math.floor(n/2)\n\
    \    end\n    pile[#pile+1] = next_odd\n    for i = 1, n do\n      pile[#pile+1]\
    \ = next_even\n    end\n  end\n  return pile\nend", "  local pile = {}\n  for\
    \ i = 1, n do\n    pile[i] = i\n  end\n  if n ~= 0 then\n    if n % 2 == 1 then\n\
    \      pile[n + 1] = math.floor(n/2)\n    else\n      pile[n + 1] = math.floor(n/2)\
    \ + 1\n    end\n  end\n  return pile\nend", "  local pile = {}\n  for i = 1, n\
    \ do\n    pile[i] = n\n    if n ~= 0 then\n      if n % 2 == 0 then\n        pile[i]\
    \ = pile[i] + 1\n      else\n        pile[i] = pile[i] + 2\n      end\n    end\n\
    \  end\n  return pile\nend", "  local pile = {}\n  for i = 1, n do\n    pile[i]\
    \ = n\n    if math.mod(n, 2) == 0 then\n      n = math.floor(n/2)\n    else\n\
    \      n = math.ceil(n/2)\n    end\n  end\n  return pile\nend", "  local pile\
    \ = {}\n  for i = 1, n do\n    pile[i] = n\n    if n ~= 0 then\n      n = math.floor(n/2)\n\
    \      if n % 2 == 1 then\n        n = n + 1\n      end\n    end\n  end\n  return\
    \ pile\nend", "  local pile = {}\n  for i = 1, n do\n    if i % 2 == 0 then\n\
    \      pile[i] = n\n    else\n      pile[i] = n + 1\n    end\n  end\n  return\
    \ pile\nend", "  local pile = {}\n  local next_odd\n  local next_even\n  if n\
    \ then\n    if n % 2 == 0 then\n      next_even = n / 2\n    else\n      next_odd\
    \ = math.floor(n/2)\n    end\n    for i = 1, n do\n      pile[i] = next_odd\n\
    \      next_odd = next_odd + 1\n      if next_odd % 2 == 0 then\n        next_even\
    \ = next_even + 1\n      end\n    end\n  end\n  return pile\nend", "  local pile\
    \ = {}\n  for i = 1, n do\n    pile[i] = (i + 1) % (2 * n) + 1\n  end\n  return\
    \ pile\nend", "  local pile = {}\n  for i = 1, n do\n    if i % 2 == 0 then\n\
    \      pile[i] = n\n    else\n      pile[i] = n % 2 == 0 and n / 2 or n / 2 +\
    \ 1\n    end\n  end\n  return pile\nend", "  local pile = {}\n  local next_odd\n\
    \  local next_even\n  if n then\n    if n % 2 == 0 then\n      next_even = n /\
    \ 2\n    else\n      next_odd = math.floor(n/2)\n    end\n    for i = 1, n do\n\
    \      pile[i] = next_odd\n      next_odd = next_even + 1\n      next_even = next_even\
    \ + 2\n    end\n  end\n  return pile\nend", "  local pile = {}\n  local next_odd\n\
    \  local next_even\n  local i = 1\n  repeat\n    next_odd = next_odd or n\n  \
    \  next_even = next_even or 2 * n\n    pile[i] = next_odd - next_even\n    i =\
    \ i + 1\n  until next_odd > next_even\n  return pile\nend", "  local pile = {}\n\
    \  local next_odd\n  local next_even\n  if n and n % 2 == 0 then\n    next_odd\
    \ = n\n  else\n    next_even = n\n  end\n  for i = 1, next_even do\n    table.insert(pile,\
    \ next_even)\n    next_even = next_even + 1\n  end\n  if next_odd > next_even\
    \ then\n    for i = 1, next_odd do\n      table.insert(pile, next_odd)\n     \
    \ next_odd = next_odd + 1\n    end\n  end\n  return pile\nend", "  local pile\
    \ = {}\n  local nlevels = math.floor(n/2) + 1\n  for level = 1, nlevels do\n \
    \   local nextlevel = nlevels - level\n    if nextlevel % 2 == 0 then\n      pile[level\
    \ + 1] = nextlevel\n    else\n      pile[level + 1] = nextlevel - 1 -- nextlevel\
    \ - 1 because nextlevel is even\n    end\n  end\n  return pile\nend", "  local\
    \ pile = {}\n  local i = 1\n  while i <= n do\n    pile[i] = i\n    i = 2 * i\n\
    \  end\n  return pile\nend", "  local pile = {}\n  local next_odd\n  local next_even\n\
    \  if n <= 0 then\n    return pile\n  elseif n % 2 == 0 then\n    next_even =\
    \ n / 2\n  else\n    next_odd = math.floor(n/2)\n  end\n  local next_level = next_odd\
    \ or next_even\n  while next_level ~= 1 do\n    pile[next_level] = n\n    if next_odd\
    \ then\n      next_odd = next_odd - 1\n    else\n      next_even = next_even +\
    \ 1\n    end\n    next_level = next_even or next_odd\n  end\n  return pile\nend",
  "  local pile = {}\n  for i = 1, n do\n    pile[i] = n % 2 == 0 and n / 2 or n /\
    \ 2\n    n = n / 2\n  end\n  return pile\nend", "  if n == 0 then\n    return\
    \ {}\n  elseif n == 1 then\n    return {1}\n  else\n    local pile = {}\n    local\
    \ next_odd_number = math.floor(n/2) + 1\n    local next_even_number = n - next_odd_number\n\
    \    for i = 1, n do\n      pile[i] = next_odd_number\n      next_odd_number =\
    \ next_odd_number + 2\n      next_even_number = next_even_number + 2\n    end\n\
    \    return pile\n  end\nend", "  local pile = {}\n  for i = 1, n do\n    pile[i]\
    \ = n\n    if math.mod(n, 2) == 0 then\n      n = math.floor(n/2)\n    else\n\
    \      n = math.ceil(n/2)\n    end\n  end\n  return pile\nend", "  local pile\
    \ = {}\n  local next_odd\n  if n % 2 == 0 then\n    next_odd = n\n  else\n   \
    \ next_odd = n + 1 -- add one to even number\n  end\n  for i = 1, next_odd do\n\
    \    pile[i] = n\n    n = n - 1\n  end\n  for i = 1, next_odd do\n    pile[i]\
    \ = n\n    n = n - 1\n  end\n  return pile\nend", "  local pile = {}\n  for i\
    \ = 1, n do\n    pile[i] = (i + 1) * (i + 1) -- odd or even\n  end\n  return pile\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
