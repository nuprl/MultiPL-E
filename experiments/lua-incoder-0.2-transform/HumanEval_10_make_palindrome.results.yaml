language: lua
name: HumanEval_10_make_palindrome
results:
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local postfix = string\n\
    \  local palindrome = string\n  while true do\n    local postfix = string.sub(postfix,\
    \ 1, string.len(postfix) - 1)\n    if string.sub(postfix, 1, string.len(postfix))\
    \ == string.sub(postfix, 1, string.len(postfix) - 1) then\n      palindrome =\
    \ palindrome .. string.sub(postfix, 1, string.len(postfix) - 1) .. string.reverse(string.sub(postfix,\
    \ string.len(postfix) - 1, string.len(postfix)))\n      break\n    end\n  end\n\
    \  return palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659750621
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local palindrome_length = #string\n    local palindrome_start = #string\n\
    \    local palindrome_end = #string\n    local palindrome_prefix_length = 0\n\
    \    local palindrome_suffix_length = 0\n    local palindrome_prefix_start = #string\n\
    \    local palindrome_prefix_end = #string\n    while palindrome_length > 1 do\n\
    \        local palindrome_prefix_length = palindrome_end - palindrome_start\n\
    \        local palindrome_suffix_length = palindrome_end - palindrome_prefix_start\n\
    \        local palindrome_prefix = string\n        local palindrome_suffix = string\n\
    \        local palindrome_prefix_start = palindrome_prefix_end\n        local\
    \ palindrome_prefix_end = palindrome_prefix_start + palindrome_prefix_length\n\
    \        local palindrome_suffix = string\n        local palindrome_suffix_start\
    \ = palindrome_suffix_end\n        local palindrome_suffix_end = palindrome_suffix_start\
    \ + palindrome_suffix_length\n        local palindrome_prefix = string\n     \
    \   local palindrome_suffix = string\n        local palindrome_prefix_length =\
    \ palindrome_end - palindrome_start\n        local palindrome_suffix_length =\
    \ palindrome_end - palindrome_prefix_start\n        local palindrome_prefix =\
    \ string\n        local palindrome_suffix = string\n        local palindrome_prefix_start\
    \ = palindrome_prefix_end\n        local palindrome_prefix_end = palindrome_prefix_start\
    \ + palindrome_prefix_length\n        local palindrome_suffix = string\n     \
    \   local palindrome_suffix_start = palindrome_suffix_end\n        local palindrome_suffix_end\
    \ = palindrome_suffix_start + palindrome_suffix_length\n        local palindrome_prefix\
    \ = string\n        local palindrome_suffix = string\n        local palindrome_prefix_length\
    \ = palindrome_end - palindrome_start\n        local palindrome_suffix_length\
    \ = palindrome_end - palindrome_prefix_start\n        local palindrome_prefix\
    \ = string\n        local palindrome_suffix = string\n        local palindrome_prefix_start\
    \ = palindrome_prefix_end\n        local palindrome_prefix_end = palindrome_prefix_start\
    \ + palindrome_prefix_length\n        local p\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmplngo1521.lua:61: ''end'' expected (to close ''while'' at line
    20) near ''<eof>''

    '
  stdout: ''
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    local suffix = ''\n    local palindrome = ''\n    while true do\n       \
    \ postfix = string.sub(postfix, 1, string.len(postfix) - 1) .. suffix\n      \
    \  local reverse = string.sub(postfix, 1, string.len(postfix) - 1) .. suffix\n\
    \        if reverse == postfix then\n            palindrome = postfix .. suffix\n\
    \            break\n        end\n        suffix = reverse\n    end\n    return\
    \ palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5_b5budq.lua:31:\
    \ expected: \"x\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmp5_b5budq.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local postfix = string\n\
    \  local suffix = ''\n  local palindrome = ''\n  while true do\n    local postfix_length\
    \ = #postfix\n    if postfix_length == 0 then\n      break\n    end\n    local\
    \ postfix_reverse = string.gsub(postfix, \"^.\", \"\"):reverse()\n    local postfix_reverse\
    \ = string.gsub(postfix_reverse, \".$\", \"\"):reverse()\n    local postfix_reverse\
    \ = string.gsub(postfix_reverse, \"^\", \"\"):reverse()\n    local postfix_reverse\
    \ = string.gsub(postfix_reverse, \"$\", \"\"):reverse()\n    if postfix_length\
    \ == #postfix_reverse then\n      postfix = postfix_reverse .. postfix\n     \
    \ break\n    end\n    postfix = postfix_reverse .. postfix\n  end\n  local postfix_length\
    \ = #postfix\n  if postfix_length == 0 then\n    return ''\n  end\n  local postfix_reverse\
    \ = string.gsub(postfix, \"^.\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \".$\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"^\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"$\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \".\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"$\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"^\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \".\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"^\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"$\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \".\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"^\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"$\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"^\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \".\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"$\", \"\"):reverse()\n  local postfix_reverse = string.gsub(postfix_reverse,\
    \ \"^\", \"\"):reverse()\n  local postfix_reverse\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpj50ld923.lua:63: ''end'' expected (to close ''function'' at
    line 11) near ''<eof>''

    '
  stdout: ''
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local palindrome_length = #string\n  local palindrome_postfix = string\n  local\
    \ palindrome_prefix_length = #string\n  while palindrome_length > 1 do\n    local\
    \ palindrome_postfix_length = #palindrome_postfix\n    local palindrome_prefix_length\
    \ = #palindrome_prefix\n    local palindrome_prefix_postfix = palindrome_prefix\n\
    \    local palindrome_prefix_postfix_length = #palindrome_prefix_postfix\n   \
    \ local palindrome_prefix_postfix_postfix = palindrome_prefix_postfix\n    local\
    \ palindrome_prefix_postfix_postfix_length = #palindrome_prefix_postfix_postfix\n\
    \    local palindrome_prefix_postfix_postfix_postfix = palindrome_prefix_postfix_postfix\n\
    \    local palindrome_prefix_postfix_postfix_postfix_length = #palindrome_prefix_postfix_postfix_postfix\n\
    \    local palindrome_prefix_postfix_postfix_postfix_postfix = palindrome_prefix_postfix_postfix_postfix_postfix\n\
    \    local palindrome_prefix_postfix_postfix_postfix_postfix_length = #palindrome_prefix_postfix_postfix_postfix_postfix\n\
    \    local palindrome_prefix_postfix_postfix_postfix_postfix_postfix = palindrome_prefix_postfix_postfix_postfix_postfix_postfix\n\
    \    local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_length =\
    \ #palindrome_prefix_postfix_postfix_postfix_postfix_postfix\n    local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix\n    local\
    \ palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_length = #palindrome_prefix_postfix_postfix_postfix_postfix_postfix\n\
    \    local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix =\
    \ palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix\n    local\
    \ palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_length = #palindrome_prefix_postfix_postfix_postfix_postfix_postfix\n\
    \    local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = palindrome_prefix_postfix_postfix_postfix_post\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp2xrhwlf0.lua:45: ''end'' expected (to close ''while'' at line
    16) near ''<eof>''

    '
  stdout: ''
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local postfix = string\n    local reverse = string\n    local length = #string\n\
    \    for i = 1, length do\n        postfix = string..postfix\n        reverse\
    \ = reverse..string\n        if string.sub(reverse, i, i) ~= string.sub(postfix,\
    \ i, i) then\n            palindrome = palindrome..string.sub(reverse, i, i)\n\
    \        end\n    end\n    return palindrome\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwec4f8rj.lua:31:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmpwec4f8rj.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local length = #string\n  local index = 1\n  while true do\n    local postfix\
    \ = string.sub(palindrome, index, index + 1)\n    local reverse = string.sub(postfix,\
    \ 1, #postfix - 1)\n    if reverse == postfix then\n      palindrome = string.sub(palindrome,\
    \ 1, index - 1)\n      break\n    end\n    index = index + 1\n  end\n  return\
    \ palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3t97ot4j.lua:32:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmp3t97ot4j.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750616
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local prefix_length = 0\n  while palindrome ~= string.sub(string, 1, prefix_length)\
    \ do\n    prefix_length = prefix_length + 1\n  end\n  local postfix_length = 0\n\
    \  while palindrome ~= string.sub(string, prefix_length + 1) do\n    postfix_length\
    \ = postfix_length + 1\n  end\n  local reversed_string = string.sub(string, 1,\
    \ prefix_length + postfix_length)\n  local reversed_palindrome = reversed_string\n\
    \  while reversed_palindrome ~= string.sub(reversed_string, 1, prefix_length +\
    \ postfix_length) do\n    reversed_palindrome = reversed_palindrome .. string.sub(reversed_string,\
    \ 1, prefix_length + postfix_length)\n  end\n  return reversed_palindrome\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659750621
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- If string is empty, return\
    \ empty string.\n  if string == '' then\n    return ''\n  end\n  -- Find the longest\
    \ postfix of supplied string that is a palindrome.\n  local postfix = string\n\
    \  local longest = 0\n  while true do\n    longest = longest + 1\n    local postfix\
    \ = string\n    for i = 1, longest do\n      postfix = string..string\n    end\n\
    \    -- If postfix is a palindrome, return it.\n    if string.gsub(postfix, '^(.-)$',\
    \ '') == string.gsub(string.gsub(postfix, '(.-)$', ''), '^(.-)$', '') then\n \
    \     return postfix\n    end\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6a27t4oy.lua:36:\
    \ expected: \"x\"\nactual: \"xx\"\nstack traceback:\n\t/tmp/tmp6a27t4oy.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local length = #string\n  local index = 1\n  while index <= length do\n   \
    \ local char = string.sub(palindrome, index, index)\n    local reverse = string.sub(palindrome,\
    \ length - index, length - index)\n    if char == reverse then\n      palindrome\
    \ = palindrome .. reverse .. char\n      length = length - 1\n    else\n     \
    \ index = index + 1\n    end\n  end\n  return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa7gqyaf4.lua:33:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmpa7gqyaf4.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local postfix = string\n\
    \  local suffix = ''\n  while true do\n    local reversed_postfix = reverse(string)\n\
    \    if reversed_postfix == postfix then\n      break\n    end\n    postfix =\
    \ reversed_postfix\n    suffix = suffix .. postfix..string\n  end\n  return suffix\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp39hs624o.lua:15:\
    \ attempt to call global 'reverse' (a nil value)\nstack traceback:\n\t/tmp/tmp39hs624o.lua:15:\
    \ in function 'candidate'\n\t/tmp/tmp39hs624o.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local postfix = string\n    local reversed_postfix = string\n    local longest_postfix\
    \ = string\n    local longest_postfix_length = string\n    local longest_postfix_length_length\
    \ = string\n    local longest_postfix_length_length_length = string\n    local\
    \ longest_postfix_length_length_length_length = string\n    local longest_postfix_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length\
    \ = string\n    local \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpwie8qp2z.lua:53: ''end'' expected (to close ''function'' at
    line 11) near ''<eof>''

    '
  stdout: ''
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Find the longest postfix\
    \ of supplied string that is a palindrome.\n  local postfix = string\n  local\
    \ longest = 0\n  while true do\n    longest = longest + 1\n    local postfix_reverse\
    \ = string.gsub(postfix, \"(.)\", function (c)\n      return string.rep(c:reverse(),\
    \ 1)\n    end)\n    if postfix_reverse == postfix then\n      break\n    end\n\
    \    postfix = postfix_reverse\n  end\n  -- Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n  local palindrome\
    \ = string\n  for i = 1, longest do\n    palindrome = palindrome .. string.rep(\"\
    a\", i - 1)\n  end\n  return palindrome\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnc8wvxrx.lua:38:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmpnc8wvxrx.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750616
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local postfix = string\n  local reverse = string\n  while true do\n    local\
    \ postfix = string.sub(postfix, 1, string.len(postfix) - 1)\n    if string.sub(postfix,\
    \ 1, string.len(postfix) - 1) ~= reverse then\n      break\n    end\n    reverse\
    \ = reverse..string.sub(postfix, 1, string.len(postfix) - 1)\n  end\n  postfix\
    \ = string.sub(postfix, 1, string.len(postfix) - 1)\n  if string.len(postfix)\
    \ > 1 then\n    palindrome = string.sub(palindrome, 1, string.len(palindrome)\
    \ - 1)\n    palindrome = palindrome..reverse\n  end\n  return palindrome\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659750621
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    local reverse = ''\n    local prefix = ''\n    while true do\n        local\
    \ index = string.find(postfix, reverse)\n        if index == nil then\n      \
    \      return prefix..reverse\n        end\n        prefix = prefix..string.sub(postfix,\
    \ 1, index-1)\n        reverse = string.sub(postfix, index+1)\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659750621
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local longest = string.len(string)\n  local longestPostfix = 0\n  local longestPrefix\
    \ = 0\n  while true do\n    local postfix = string.sub(string, longestPostfix,\
    \ longestPostfix + longest)\n    if string.sub(postfix, longestPostfix, longestPostfix\
    \ + longest) == string.sub(postfix, longestPrefix, longestPrefix + longest) then\n\
    \      longestPostfix = longestPostfix + longest\n      longestPrefix = longestPrefix\
    \ + longest\n    else\n      longestPostfix = longestPostfix + 1\n      longestPrefix\
    \ = longestPrefix + 1\n      palindrome = palindrome .. string.sub(postfix, longestPrefix,\
    \ longestPrefix)\n      break\n    end\n  end\n  return palindrome\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659750621
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local postfix = string\n    local reverse = string\n    local length = #string\n\
    \    for i = 1, length do\n        postfix = string.sub(postfix, 1, i-1..-1)\n\
    \        reverse = string.sub(reverse, 1, i-1..-1)\n        if string.sub(postfix,\
    \ 1, i) == reverse then\n            palindrome = string.sub(palindrome, 1, i-1..-1..string.reverse(string.sub(postfix,\
    \ 1, i)))\n        end\n    end\n    return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpanohfmrp.lua:17: malformed number near ''1..''

    '
  stdout: ''
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local postfix = string\n    local reverse = ''\n    local length = #string\n\
    \    while length > 0 do\n        postfix = string\n        reverse = reverse\
    \ .. string\n        length = length - 1\n        while length > 0 do\n      \
    \      if string[length] == string[length] then\n                postfix = postfix\
    \ .. string[length]\n                length = length - 1\n            else\n \
    \               postfix = postfix .. string[length]\n                length =\
    \ length - 1\n                break\n            end\n        end\n        if\
    \ postfix ~= reverse then\n            palindrome = palindrome .. postfix .. reverse\n\
    \        end\n    end\n    return palindrome\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpa_n0yiw9.lua:22:\
    \ attempt to concatenate field '?' (a nil value)\nstack traceback:\n\t/tmp/tmpa_n0yiw9.lua:22:\
    \ in function 'candidate'\n\t/tmp/tmpa_n0yiw9.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750616
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local postfix = string\n    local reverse = string\n    local length = #string\n\
    \    while length > 1 do\n        postfix = string.sub(postfix, 1, length - 1)\n\
    \        reverse = string.sub(reverse, 1, length - 1)\n        if reverse == postfix\
    \ then\n            palindrome = string.sub(palindrome, 1, length - 1)\n     \
    \       length = length - 1\n        else\n            length = length - 1\n \
    \       end\n    end\n    return palindrome\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1t_5b7a_.lua:34:\
    \ expected: \"xyzyx\"\nactual: \"x\"\nstack traceback:\n\t/tmp/tmp1t_5b7a_.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750616
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local postfix = string\n\
    \  local palindrome = string\n  local i = #string\n  while i do\n    local j =\
    \ #postfix\n    while j > 0 do\n      local c = postfix:sub(j, j)\n      if c\
    \ ~= c:reverse() then\n        postfix = postfix:sub(1, j-1)\n        break\n\
    \      end\n      j = j - 1\n    end\n    i = i - 1\n    if i > 0 then\n     \
    \ palindrome = palindrome .. string\n    end\n  end\n  return palindrome\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659750621
