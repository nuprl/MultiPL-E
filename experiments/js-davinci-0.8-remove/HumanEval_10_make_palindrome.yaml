name: HumanEval_10_make_palindrome
language: js
prompt: "//Find the shortest palindrome that begins with a supplied string.\n// Algorithm\
  \ idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n\
  // - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\nfunction make_palindrome(string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = make_palindrome;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"\
  x\"),\"x\");\n  assert.deepEqual(candidate(\"xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"\
  xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"jerry\"),\"jerryrrej\");\n}\n\n\
  test();"
completions: ["    var suffix = longest_palindromic_suffix(string);\n    var prefix\
    \ = string.substring(0,string.length-suffix.length);\n    var reverse_prefix =\
    \ reverse(prefix);\n    return string + reverse_prefix;\n}\n", "  var length =\
    \ string.length,\n      length_half = length / 2,\n      suffix = longest_palindrome_suffix(string);\n\
    \  return string + reverse(string.substring(0, length - suffix));\n}", "\tvar\
    \ initial_length = string.length;\n\tvar initial_string = string;\n\tvar suffix\
    \ = find_longest_palindromic_suffix(string);\n\tvar prefix = string.substring(0,\
    \ string.length - suffix.length);\n\tvar reversed_prefix = reverse_string(prefix);\n\
    \tvar palindrome = reversed_prefix + initial_string;\n\treturn palindrome;\n}\n",
  "\t// Find the longest palindromic suffix of a supplied string\n\tfunction find_longest_palindromic_suffix(string)\
    \ {\n\t\tfunction is_palindrome(string) {\n\t\t\treturn string === string.split('').reverse().join('');\n\
    \t\t}\n\t\tfunction substrings(string) {\n\t\t\tvar result = [],\n\t\t\t\tleft,\n\
    \t\t\t\tright;\n\t\t\tfor (left = 0; left < string.length; left++) {\n\t\t\t\t\
    for (right = left + 1; right <= string.length; right++) {\n\t\t\t\t\tresult.push(string.slice(left,\
    \ right));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvar substrings\
    \ = substrings(string),\n\t\t\tsuitable = substrings.filter(is_palindrome),\n\t\
    \t\tsuitable_sorted = suitable.sort(function(str1, str2) {\n\t\t\t\treturn str2.length\
    \ - str1.length;\n\t\t\t});\n\t\treturn suitable_sorted[0];\n\t}\n\tvar palindromic_suffix\
    \ = find_longest_palindromic_suffix(string),\n\t\tsuffix_length = palindromic_suffix.length,\n\
    \t\tprefix = string.slice(0, string.length - suffix_length),\n\t\treverse_prefix\
    \ = prefix.split('').reverse().join('');\n\treturn string + reverse_prefix;\n\
    }\n", "    var substring = string + '$' + string.split('').reverse().join('');\n\
    \    var automaton = new Automaton(substring);\n    return string.substring(0,\
    \ string.length - automaton.length(string.length)) + string.split('').reverse().join('');\n\
    }\n", "  var pre = find_longest_palindrome(string);\n  var res = string;\n  for(var\
    \ i = pre.length - 1; i >= 0; i--){\n    res += pre[i];\n  }\n  return res;\n\
    }\n\nvar test_cases = {\n  'cba': 'abcba',\n  'abcd': 'dcbabcd',\n  'abcde': 'edcbabcde',\n\
    \  'abcdd': 'ddcbabcdd',\n  'abcdabcd': 'dcbabcdabcd',\n  'aaaa': 'aaaa',\n  'aaa':\
    \ 'aaa',\n  'aa': 'aa',\n  'a': 'a',\n  '': ''\n};\n\nvar error = false;\nfor(var\
    \ t in test_cases){\n  if(make_palindrome(t) !== test_cases[t]){\n    console.log('Make\
    \ palindrome of ' + t + ' got wrong result. Got: ' + make_palindrome(t) + ', but\
    \ expected: ' + test_cases[t]);\n    error = true;\n  }\n}\n\nif(!error){\n  console.log('Looks\
    \ OK!');\n}", "\t//Use Manacher's algorithm to find the longest palindrome.\n\t\
    return (string + reverse(string.substring(0,string.length - longest_palindrome(string))))\n\
    }", "  var len = string.length;\n  var prefix = string.substring(0, len - 1);\n\
    \  var postfix = string.substring(len - 1, len);\n  var palindrome = null;\n \
    \ var old_palindrome = null;\n  var start = len - 1;\n  var end = len;\n  var\
    \ midpoint = null;\n  var is_palindrome = false;\n  var next_palindrome = null;\n\
    \  var next_palindrome_length = null;\n  // Find the longest palindrome in the\
    \ supplied string that is a suffix.\n  while (true){\n    midpoint = Math.floor((start\
    \ + end) / 2);\n    // See if there is a palindrome in the middle.\n    palindrome\
    \ = string.substring(midpoint, end);\n    is_palindrome = is_palindrome_util(palindrome);\n\
    \    if (is_palindrome){\n      // The next palindrome is still shorter than or\
    \ equal to the previous palindrome.\n      if (old_palindrome != null && palindrome.length\
    \ <= old_palindrome.length){\n        break;\n      }\n      // A palindrome has\
    \ been found. Shift the start point to the left.\n      old_palindrome = palindrome;\n\
    \      start = midpoint - 1;\n    } else {\n      // A palindrome has not been\
    \ found. Shift the end point to the right.\n      end = midpoint + 1;\n    }\n\
    \  }\n  // Now we need to find the longest prefix that is a palindrome.\n  start\
    \ = 0;\n  end = len - old_palindrome.length - 1;\n  while (true){\n    midpoint\
    \ = Math.floor((start + end) / 2);\n    // See if there is a palindrome in the\
    \ middle.\n    palindrome = string.substring(start, midpoint + 1);\n    is_palindrome\
    \ = is_palindrome_util(palindrome);\n    if (is_palindrome){\n      // The next\
    \ palindrome is still shorter than or equal to the previous palindrome.\n    \
    \  if (next_palindrome !=", "    if(string.length == 0){\n        return \"\"\
    ;\n    }\n    let suf_size = 0;\n    let prefix = \"\";\n    let suffix = \"\"\
    ;\n    for(let c = string.length-1; c >= 0; c--){\n        if(is_palindrome(string.substring(0,\
    \ c+1))){\n            suf_size = c;\n            break;\n        }\n    }\n \
    \   prefix = string.substring(0, suf_size);\n    suffix = string.substring(suf_size);\n\
    \    return prefix + reverse(suffix) + suffix;\n}\n", "  var string = 'b' + string;\n\
    \  var length = string.length;\n  var i = length;\n  var T = [];\n  T[0] = 0;\n\
    \  for(var i = 1; i < length; i++){\n    var j = T[i-1];\n    while(j > 0 && string[i]\
    \ != string[j]){\n      j = T[j-1];\n    }\n    if(string[i] == string[j]){\n\
    \      j++;\n    }\n    T[i] = j;\n  }\n  var prefix = string.substring(0, T[length-1]);\n\
    \  return prefix + string.substring(1, length);\n}", "  var string_length = string.length;\n\
    \  //Test all possible reverse/palindrome combinations.\n  //Could be improved\
    \ by exiti", "    var longest = 0;\n    var N = string.length;\n    var i = 0;\n\
    \    var j = 0;\n    var palindrome_suffix = [];\n    // Iterate through all possible\
    \ suffixes\n    while(i < N){\n        if(string[i - j] == string[i]){\n     \
    \       j += 1;\n            palindrome_suffix[i] = j;\n            i += 1;\n\
    \        }\n        else{\n            if(j == 0){\n                palindrome_suffix[i]\
    \ = 0;\n                i += 1;\n            }\n            else{\n          \
    \      j = palindrome_suffix[i - j];\n            }\n        }\n    }\n    //\
    \ Check for the longest palindromic suffix\n    for(i = 0; i < N; i++){\n    \
    \    if(i - palindrome_suffix[i] === 0){\n            longest = palindrome_suffix[i];\n\
    \        }\n    }\n    // Create new string\n    var new_string = \"\";\n    for(i\
    \ = 0; i < string.length - longest; i++){\n        new_string += string[string.length\
    \ - 1 - i];\n    }\n    new_string += string;\n    return new_string;\n}\n", "\t\
    // Find the longest palindromic suffix of supplied string.\n\tvar palindrome_suffix\
    \ = find_palindrome_suffix(string);\n\t// Reverse substring that comes before\
    \ the palindromic suffix.\n\tvar palindrome_prefix = reverse_string(string.substring(0,\
    \ string.length - palindrome_suffix.length));\n\t// Append palindrome prefix to\
    \ the end of supplied string.\n\tvar palindrome = string + palindrome_prefix;\n\
    \treturn palindrome;\n}\n", "    // Check input validity.\n    if (string.length\
    \ < 1) return null;\n    // The supplied string is a palindrome.\n    if (check_palindrome(string))\
    \ return string;\n    // Find the longest palindromic suffix.\n    var palindrome_suffix\
    \ = find_longest_palindrome_suffix(string);\n    // Mirror the prefix.\n    var\
    \ prefix = string.substring(0,string.length-palindrome_suffix.length);\n    var\
    \ mirror_prefix = reverse_string(prefix);\n    //Return the shortest palindrome\
    \ that begins with the supplied string.\n    return mirror_prefix+string;\n}\n",
  "    let string_reverse = string.split('').reverse().join('');\n    let s = string\
    \ + '#' + string_reverse;\n    let longest_palindromic_suffix = longest_postfix_palindrome(s);\n\
    \    return string_reverse.substring(0, string.length - longest_palindromic_suffix)\
    \ + string;\n}\n", "\tvar cstring = string.slice(0);\n\tvar palindrome_suffix\
    \ = get_longest_palindrome_suffix(cstring);\n\tvar prefix = cstring.slice(0,cstring.length-palindrome_suffix.length);\n\
    \tcstring += reverse(prefix);\n\treturn cstring;\n}\n", "    var prefix = string;\n\
    \    var suffix = string.split('').reverse().join('');\n    var concat = string+'!'+suffix;\n\
    \    var LPS = lps(concat);\n    var prefix = string.substring(0, string.length-LPS);\n\
    \    var reverse_prefix = prefix.split('').reverse().join('');\n    return reverse_prefix+string;\n\
    }\n", "    //find the suffix that is a palindrome\n    //reverse the prefix and\
    \ add it to the end of the string\n    var reverse_string = reverse_string(string);\n\
    \    var str_postfix = get_longest_common_postfix(string, reverse_string);\n \
    \   var str_prefix = string.substring(0,string.length - str_postfix.length);\n\
    \    var str_prefix_reversed = reverse_string(str_prefix);\n    var palindrome\
    \ = string + str_prefix_reversed;\n    return palindrome;\n}", "    var result\
    \ = string + '|';\n    var tail = string.slice().split('').reverse().join('');\n\
    \    result += tail;\n    return result;\n}\n", "    var len = string.length,\n\
    \        result = string,\n        index = len-1,\n        mid = len/2,\n    \
    \    i = len-1,\n        j = i,\n        pal_length = 0,\n        pal_prefix =\
    \ \"\";\n\n    //Find the longest postfix of supplied string that is a palindrome.\n\
    \    while(i > 0 && j > 0){\n        if(string[i] != string[j]){\n           \
    \ j--;\n        }else{\n            if(pal_length < j+1){\n                pal_length\
    \ = j+1;\n                index = i;\n            }\n            i--;\n      \
    \      j--;\n        }\n    }\n\n    //Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    for(i = 0;\
    \ i < len-pal_length; i++){\n        result += string[i];\n    }\n\n    return\
    \ result;\n}\n", "\tvar result = string;\n\tvar prefix_length = 0;\n\tvar suffix_length\
    \ = 0;\n\tvar end_at = (string.length-1) >> 1;\n\tfor(var i = 0; i <= end_at;\
    \ i++){\n\t\t//Look for prefix length.\n\t\tif(string[i] == string[string.length-1-i]){\n\
    \t\t\tprefix_length++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(var i = 0;\
    \ i <= end_at; i++){\n\t\t//Look for suffix length.\n\t\tif(string[i] == string[string.length-1-i]){\n\
    \t\t\tsuffix_length++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\t//Append the reversed\
    \ prefix.\n\tresult += string.substring(0, prefix_length).split(\"\").reverse().join(\"\
    \");\n\treturn result;\n}\n", "    var lps = longest_palindromic_suffix(string);\n\
    \    var first = string.substring(0,string.length-lps.length);\n    return first\
    \ + lps + first.split(\"\").reverse().join(\"\");\n}\n", "  return string.split('').reverse().join('')\
    \ + string;\n}\n", "  var len = string.length;\n  var i = len - 1;\n  while(i\
    \ >= 0){\n    if(is_palindrome(string.substring(0, i))){\n      return string\
    \ + reverse(string.substring(i, len));\n    }\n    i--;\n  }\n  return '';\n}\n",
  "    // Find the longest palindromic substring\n    var reversed_string = string.split('').reverse().join('');\n\
    \    var longest_substring = lps(string, reversed_string);\n    // Shorten the\
    \ suffix so it doesn't include the palindromic portion at the end.\n    var suffix\
    \ = string.substring(longest_substring.length);\n    return suffix + string;\n\
    }\n\n", "    var max_common_suffix_length = 0;\n    var reversed_string = string.split(\"\
    \").reverse().join(\"\");\n    for(var i = 0; i < string.length; i++){\n     \
    \   if(string.substring(0, string.length - i) == reversed_string.substring(i)){\n\
    \            max_common_suffix_length = string.length - i;\n        }\n    }\n\
    \    return string + reversed_string.substring(max_common_suffix_length);\n}\n",
  "\tvar reverse = function(s){\n\t\tvar out = \"\";\n\t\tfor(var i = s.length - 1;\
    \ i >= 0; i--){\n\t\t\tout += s[i];\n\t\t}\n\t\treturn out;\n\t};\n\tvar find_longest_palindrome\
    \ = function(s){\n\t\tvar l = s.length;\n\t\tfor(var i = l; i > 0; i--){\n\t\t\
    \tvar test = s.substring(0, i);\n\t\t\tif(test == reverse(test)){\n\t\t\t\treturn\
    \ test;\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t};\n\tvar palindrome = find_longest_palindrome(string);\n\
    \tvar reverse_prefix = reverse(string.substring(palindrome.length));\n\treturn\
    \ reverse_prefix + string;\n}\n\nvar fs = require('fs');\nvar outfile = \"palindrome.txt\"\
    ;\nvar out = make_palindrome(\"haaaan\");\nfs.writeFileSync(outfile, out);  ",
  "    for(var i = 0; i < string.length; i++){\n        if(is_palindrome(string.substring(0,\
    \ string.length - i))){\n            var prefix = string.substring(0, string.length\
    \ - i);\n            return prefix + prefix.split(\"\").reverse().join(\"\");\n\
    \        }\n    }\n}\n", "    var pal = string.slice(0);\n    var postfix_pal\
    \ = longest_palindrome_postfix(string);\n    var prefix = string.slice(0,string.length-postfix_pal.length);\n\
    \    var prefix_rev = prefix.split(\"\").reverse().join(\"\");\n    pal = pal\
    \ + prefix_rev;\n    return pal;\n}\n", "    var reverse = string.split('').reverse().join('');\n\
    \n    function is_prefix(string, substring){\n        return string.substring(0,\
    \ substring.length) === substring;\n    }\n\n    function longest_common_postfix(string1,\
    \ string2){\n        var common_postfix = '';\n        for(var i = 1; i <= string1.length;\
    \ i++){\n            var postfix = string1.substring(string1.length - i);\n  \
    \          if(is_prefix(string2, postfix)){\n                common_postfix =\
    \ postfix;\n            }\n        }\n        return common_postfix;\n    }\n\n\
    \    var common_postfix = longest_common_postfix(string, reverse);\n    return\
    \ reverse + string.substring(common_postfix.length);\n}\n", "    var even_palindrome\
    \ = is_palindrome(string, string.length - 1);\n    var odd_palindrome = is_palindrome(string,\
    \ string.length - 2);\n    var result =  (even_palindrome > odd_palindrome) ?\
    \ even_palindrome : odd_palindrome;\n    return string.substring(0, string.length\
    \ - result) + string.substring(0, result).split(\"\").reverse().join(\"\") + string;\n\
    }\n", "  if (string.length < 2) {\n    return string;\n  }\n  var len = string.length;\n\
    \  var start = Math.floor(len/2);\n  var end = len;\n  var longest_suffix = 0;\n\
    \  var test_string = \"\";\n  for (var i = start; i >= 0; i--) {\n    test_string\
    \ = string.substring(i, end);\n    if (is_palindrome(test_string)) {\n      longest_suffix\
    \ = test_string.length;\n      break;\n    }\n  }\n  var new_string = string +\
    \ reverse(string.substring(0, len - longest_suffix));\n  return new_string;\n\
    }\n", "\t//assumption: string is a string\n\t//      : string contains no spaces\n\
    \tvar reverse_string = reverse(string);\n\tvar longest_postfix = longest_common_postfix(string,\
    \ reverse_string);\n\tvar longest_prefix = string.substring(0, string.length -\
    \ longest_postfix.length);\n\tvar reverse_prefix = reverse(longest_prefix);\n\t\
    return string + reverse_prefix;\n}\n", "\tvar palindrome = string + get_reversed_string(get_prefix(string));\n\
    \treturn palindrome;\n}\n", "  if(string.length == 0) return string;\n  var i,\
    \ j;\n  var longest_palindrome_end = 0;\n  var longest_palindrome_length = 0;\n\
    \  for(i = 0; i < string.length; i++){\n    for(j = 0; i-j >= 0 && i+j < string.length;\
    \ j++){\n      if(string[i-j] != string[i+j]){\n        break;\n      }\n    \
    \  if(2*j + 1 > longest_palindrome_length){\n        longest_palindrome_length\
    \ = 2*j + 1;\n        longest_palindrome_end = i + j;\n      }\n    }\n    for(j\
    \ = 0; i-j >= 0 && i+j+1 < string.length; j++){\n      if(string[i-j] != string[i+j+1]){\n\
    \        break;\n      }\n      if(2*j + 2 > longest_palindrome_length){\n   \
    \     longest_palindrome_length = 2*j + 2;\n        longest_palindrome_end = i\
    \ + j + 1;\n      }\n    }\n  }\n  return string.substring(0, string.length -\
    \ longest_palindrome_length) + string.substring(string.length - longest_palindrome_length).split(\"\
    \").reverse().join(\"\") + string.substring(string.length - longest_palindrome_length);\n\
    }\n\nvar TESTS = [\n  [\"\", \"\"],\n  [\"a\", \"a\"],\n  [\"ab\", \"bab\"],\n\
    \  [\"aba\", \"aba\"],\n  [\"abba\", \"abba\"],\n  [\"abbc\", \"cbabbc\"],\n \
    \ [\"abcd\", \"dcbabcd\"],\n  [\"abccba\", \"abccba\"],\n  [\"abcccba\", \"abcccba\"\
    ],\n  [\"cabac\", \"cabac\"],\n  [\"cabacd\", \"dcabacd\"],\n  [\"cabacdd\", \"\
    ddcabacdd\"],\n  [\"cabacdg\", \"gdcbabacdg\"],\n  [\"abcda\", \"adcba", "\tvar\
    \ reverse_string = string.split(\"\").reverse().join(\"\");\n\n\tvar longest_prefix\
    \ = string.substring(0, find_longest_prefix(string, reverse_string));\n\treturn\
    \ string + reverse_string.substring(reverse_string.length - longest_prefix.length);\n\
    }\n", "    let l = string.length;\n    let prefix = string.slice(0, l-1);\n  \
    \  let suffix = string.slice(l-1, l);\n    if(suffix.length == 0){\n        return\
    \ prefix;\n    }\n    while(!is_palindrome(suffix)){\n        l = prefix.length;\n\
    \        suffix = string.slice(l-1, l) + suffix;\n        prefix = string.slice(0,\
    \ l-1);\n    }\n    return prefix + reverse(suffix);\n}\n\nmodule.exports = {\n\
    \    is_palindrome,\n    reverse,\n    reverse_words,\n    make_palindrome\n}",
  "    // A string is a palindrome if it is empty or has only one character.\n   \
    \ if (string.length <= 1) {\n        return string;\n    }\n    // Find the longest\
    \ postfix that is a palindrome.\n    var longest_palindrome_postfix = find_longest_palindrome_postfix(string);\n\
    \    // Cut off the palindromic postfix. We will append a reverse prefix after\
    \ it.\n    var prefix = string.substring(0, string.length - longest_palindrome_postfix.length);\n\
    \    // The reverse of the prefix.\n    var reverse_prefix = prefix.split(\"\"\
    ).reverse().join(\"\");\n    // The palindrome we want to find is built from the\
    \ reverse prefix and the original string.\n    return reverse_prefix + string;\n\
    }\n", "\tvar l = string.length;\n\tvar b = 0;\n\tvar e = l - 1;\n\tvar p = -1;\n\
    \tvar pp = 0;\n\twhile(b <= e && e < l){\n\t\tif(string[b] == string[e]){\n\t\t\
    \tif(b == e){\n\t\t\t\tp = b;\n\t\t\t}else{\n\t\t\t\tpp = p;\n\t\t\t\tp = e;\n\
    \t\t\t}\n\t\t\tb++;\n\t\t\te--;\n\t\t}else{\n\t\t\tp = pp;\n\t\t\te = p + (p -\
    \ b) + 1;\n\t\t\tb = p + 1;\n\t\t}\n\t}\n\treturn string + string.substring(p\
    \ + 1).split(\"\").reverse().join(\"\");\n}\n", "  var prefix_to_append = \"\"\
    ;\n  for(var i = 0; i < string.length; i++){\n    if(is_palindrome(string.substring(i,\
    \ string.length))){\n      prefix_to_append = string.substring(0, i);\n      break;\n\
    \    }\n  }\n  return string + reverse(prefix_to_append);\n}\n", "    var rev_string\
    \ = string.split('').reverse().join(''),\n        suffix = [],\n        suffix_len\
    \ = 0,\n        prefix_len = 0;\n\n    //suffix = string.split('').reverse().join('');\n\
    \    suffix = rev_string;\n    suffix_len = suffix.length;\n    prefix_len = string.length\
    \ - suffix_len;\n\n    //console.log('suffix: ' + suffix + ' - len: ' + suffix_len);\n\
    \    //console.log('prefix: ' + string.substring(0, prefix_len) + ' - len: ' +\
    \ prefix_len);\n\n    return string + rev_string.substring(prefix_len);\n}\n\n\
    describe('make_palindrome', function(){\n    it('should return \\'a\\' for string\
    \ \\'a\\'', function(){\n        expect(make_palindrome('a')).to.equal('a');\n\
    \    });\n\n    it('should return \\'bb\\' for string \\'b\\'', function(){\n\
    \        expect(make_palindrome('b')).to.equal('bb');\n    });\n\n    it('should\
    \ return \\'aba\\' for string \\'a\\'', function(){\n        expect(make_palindrome('a')).to.equal('aba');\n\
    \    });\n\n    it('should return \\'abba\\' for string \\'a\\'', function(){\n\
    \        expect(make_palindrome('ab')).to.equal('abba');\n    });\n\n    it('should\
    \ return \\'aaacecaaa\\' for string \\'aceca\\'', function(){\n        expect(make_palindrome('aceca')).to.equal('aaacecaaa');\n\
    \    });\n\n    it('should return \\'abcdeedcba\\' for string \\'abcd\\'', function(){\n\
    \        expect(make_palindrome('abcd')).to.equal('abcdeedcba');\n    });\n});",
  "\tvar n = string.length;\n\tvar revstring = string.split(\"\").reverse().join(\"\
    \");\n\tvar lps = new Array(n);\n\tlps[0] = 0;\n\tvar j = 0;\n\ti = 1;\n\twhile(i\
    \ < n){\n\t\tif(string[i] == string[j]){\n\t\t\tlps[i] = j + 1;\n\t\t\ti++;\n\t\
    \t\tj++;\n\t\t}\n\t\telse{\n\t\t\tif(j != 0){\n\t\t\t\tj = lps[j-1];\n\t\t\t}\n\
    \t\t\telse{\n\t\t\t\tlps[i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ revstring.substring(0, n - lps[n-1]) + string;\n}", "    let longest_palindrome\
    \ = find_longest_palindrome(string)\n    return longest_palindrome.str + string.slice(0,\
    \ string.length - longest_palindrome.length).split('').reverse().join('')\n}\n",
  "    let str_reversed = string.split('').reverse().join('');\n    let max_length\
    \ = 0;\n    let max_idx = 0;\n    for(let i = 0; i < string.length; i++){\n  \
    \      for(let j = 0; j < i; j++){\n            let sub_str = string.substring(j,\
    \ i + 1);\n            let sub_str_reversed = string.substring(j, i + 1).split('').reverse().join('');\n\
    \            if(sub_str === sub_str_reversed){\n                if(i - j + 1 >\
    \ max_length){\n                    max_length = i - j + 1;\n                \
    \    max_idx = j;\n                }\n            }\n        }\n    }\n    return\
    \ string + str_reversed.substring(str_reversed.length - max_idx);\n}\n", "\tvar\
    \ palindrome = string;\n\tvar prefix = string.substring(0, string.length-1);\n\
    \tvar suffix = string.substring(string.length-1, string.length);\n\twhile(prefix){\n\
    \t\tif(is_palindrome(prefix+suffix)){\n\t\t\tpalindrome = prefix+suffix+string.substring(string.length-prefix.length-1,\
    \ string.length);\n\t\t\tbreak;\n\t\t}\n\t\tprefix = prefix.substring(0, prefix.length-1);\n\
    \t\tsuffix = string.substring(string.length-prefix.length-1, string.length);\n\
    \t}\n\treturn palindrome;\n}\n", "    let palindrome = string;\n    let start_pos\
    \ = (string.length - 1) / 2;\n    //console.log(\"start pos: \" + start_pos);\n\
    \    let found = false;\n    while(start_pos >= 0 && !found){\n        //console.log(\"\
    start_pos: \" + start_pos);\n        let end_pos = string.length - 1 - start_pos;\n\
    \        //console.log(\"end_pos: \" + end_pos);\n        while(end_pos < string.length\
    \ && string[start_pos] === string[end_pos]){\n            end_pos++;\n       \
    \ }\n        //console.log(\"found string: \" + string.substring(start_pos, end_pos));\n\
    \        if(end_pos === string.length){\n            //console.log(\"found palindrome:\
    \ \" + string.substring(start_pos, end_pos));\n            found = true;\n   \
    \         palindrome = string.substring(0, start_pos).split(\"\").reverse().join(\"\
    \") + string;\n        }\n        start_pos--;\n    }\n    return palindrome;\n\
    }\n\nconst test_string = \"XYZ\";", "    var reversed = reverse(string);\n   \
    \ var i;\n    for(i = string.length; i >= 0; i--){\n        if(string.substring(0,\
    \ i) == reversed.substring(string.length - i)){\n            break;\n        }\n\
    \    }\n    return string + reverse(string.substring(0, string.length - i));\n\
    }\n", "    if (string.length == 0)\n        return;\n    \n    //Find the longest\
    \ palindromic suffix of the string.\n    var max_len = -1;\n    var max_suffix\
    \ = \"\";\n    for (var i = 0; i < string.length; i++){\n        var substr =\
    \ string.substring(i);\n        if (substr == reverse(substr)){\n            if\
    \ (substr.length > max_len){\n                max_len = substr.length;\n     \
    \           max_suffix = substr;\n            }\n        }\n    }\n    \n    //Append\
    \ the reverse of the string that comes before the palindromic suffix.\n    return\
    \ string + reverse(string.substring(0, string.length - max_suffix.length));\n\
    }\n", "  for(let i = string.length - 1; i >= 0; i--){\n    if(is_palindrome(string.substring(i))){\n\
    \      return string + reverse(string.substring(0, i));\n    }\n  }\n}\n", " \
    \ var suffix_start, suffix_end;\n  //find the first palindromic suffix of the\
    \ string\n  for(suffix_end = string.length - 1; suffix_end >= 0; suffix_end--){\n\
    \    if(is_palindrome(string, 0, suffix_end)){\n      break;\n    }\n  }\n  //we\
    \ have found a longest palindromic suffix, append a reverse of the prefix to the\
    \ end of the string\n  var prefix = string.substring(0, string.length - suffix_end\
    \ - 1);\n  prefix = prefix.split(\"\").reverse().join(\"\");\n  return string\
    \ + prefix;\n}\n\n", "\tvar length = string.length;\n\tvar suffix_length = 0;\n\
    \twhile (string != string.split(\"\").reverse().join(\"\") && suffix_length <\
    \ length){\n\t\tsuffix_length++;\n\t\tstring = string.substring(0, length - suffix_length);\n\
    \t}\n\treturn string + string.split(\"\").reverse().join(\"\").substring(length\
    \ - suffix_length);\n}\n", "  var palindrome = '';\n  // Find a substring that\
    \ starts at the end of the string and move backwards towards the start\n  // of\
    \ the string that is a palindrome.\n  for(var i = string.length; i > 0; i--){\n\
    \    if(is_palindrome(string.substring(0, i))){\n      palindrome = string.substring(0,\
    \ i);\n      break;\n    }\n  }\n  // Add the reversed prefix to the end of the\
    \ palindrome.\n  return palindrome + reverse(string.substring(0, string.length\
    \ - palindrome.length));\n}\n", "    var longest_palindrome = find_longest_palindrome(string);\n\
    \    return string + reverse(string.substring(0,string.length-longest_palindrome.length));\n\
    }\n", "  var rev_prefix = string.split('').reverse().join('');\n  var long_suffix\
    \ = longest_suffix(string);\n  var rev_suffix = long_suffix.split('').reverse().join('');\n\
    \  return rev_prefix + rev_suffix;\n}\n", "\tif (string.length <= 1) return string;\n\
    \n\t//Find the longest palindromic suffix.\n\tvar max_suffix_length = max_palindromic_suffix(string);\n\
    \n\t//Reverse a string prefix that comes before the palindromic suffix.\n\tvar\
    \ reversed_prefix = string.substring(0, string.length - max_suffix_length).split(\"\
    \").reverse().join(\"\");\n\n\t//Append reverse of the prefix to the end of the\
    \ string.\n\treturn string + reversed_prefix;\n}\n", "\tif (typeof string != 'string')\
    \ return undefined;\n\tvar longest_match = 1;\n\tvar i = Math.floor(string.length/2)\
    \ - 1;\n\twhile (i >= 0){\n\t\tvar j = 1;\n\t\twhile (j <= i){\n\t\t\tif (string[i\
    \ - j] == string[i + j]){\n\t\t\t\tif (j * 2 + 1 > longest_match){\n\t\t\t\t\t\
    longest_match = j * 2 + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t\tj++;\n\t\t}\n\t\tif (string[i] == string[i + 1]){\n\t\t\tj = 1;\n\t\t\
    \twhile (j <= i){\n\t\t\t\tif (string[i - j] == string[i + j + 1]){\n\t\t\t\t\t\
    if (j * 2 + 2 > longest_match){\n\t\t\t\t\t\tlongest_match = j * 2 + 2;\n\t\t\t\
    \t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\
    \t}\n\t\ti--;\n\t}\n\treturn string + string.substring(longest_match,string.length).split('').reverse().join('');\n\
    }\n", "\tvar pre_rev = '',\n\t\tpre = string,\n\t\tstr = string;\n\twhile(!is_palindrome(str)){\n\
    \t\tstr = pre + pre_rev;\n\t\tpre_rev = pre.charAt(0) + pre_rev;\n\t\tpre = pre.substring(1);\n\
    \t}\n\treturn str;\n}\n\nvar test_string = 'abc';\nvar result = make_palindrome(test_string);\n\
    \nif(result.length === test_string.length + 2){\n\tconsole.log('Test for ' + test_string\
    \ + ' has passed.');\n} else {\n\tconsole.log('Test for ' + test_string + ' has\
    \ failed.');\n}\n\ntest_string = 'a';\nresult = make_palindrome(test_string);\n\
    \nif(result.length === test_string.length + 2){\n\tconsole.log('Test for ' + test_string\
    \ + ' has passed.');\n} else {\n\tconsole.log('Test for ' + test_string + ' has\
    \ failed.');\n}\n\ntest_string = 'abcdef';\nresult = make_palindrome(test_string);\n\
    \nif(result.length === test_string.length + 2){\n\tconsole.log('Test for ' + test_string\
    \ + ' has passed.');\n} else {\n\tconsole.log('Test for ' + test_string + ' has\
    \ failed.');\n}\n\ntest_string = 'aab';\nresult = make_palindrome(test_string);\n\
    \nif(result.length === test_string.length + 2){\n\tconsole.log('Test for ' + test_string\
    \ + ' has passed.');\n} else {\n\tconsole.log('Test for ' + test_string + ' has\
    \ failed.');\n}\n\ntest_string = 'abb';\nresult = make_palindrome(test_string);\n\
    \nif(result.length === test_string.length + 2){\n\tconsole.log('Test for ' + test_string\
    \ + ' has passed.');\n} else {\n\tconsole.log('Test for ' + test_string + ' has\
    \ failed.');\n}\n\ntest_string = 'abcdd", "\tif (string.length == 0){\n\t\treturn\
    \ string;\n\t}\n\n\tvar prefix = string.substring(0, string.length - 1);\n\tvar\
    \ prefix_reversed = prefix.split(\"\").reverse().join(\"\");\n\tif (string.length\
    \ == 1){\n\t\treturn string.concat(prefix_reversed);\n\t}\n\t\n\tif (string.substring(0,\
    \ prefix.length) == prefix_reversed){\n\t\treturn string.concat(prefix_reversed);\n\
    \t}\n\treturn make_palindrome(prefix).concat(prefix_reversed);\n}\n", "\tif(!string)\
    \ {\n\t\tthrow \"Supplied argument is null or undefined.\";\n\t}\n\tvar longest\
    \ = \"\";\n\tvar length = string.length;\n\tfor(var i = length - 1; i >= 0; i--){\n\
    \t\tif(is_palindrome(string.substring(i, length))){\n\t\t\tlongest = string.substring(i,\
    \ length);\n\t\t\tbreak;\n\t\t}\n\t}\n\tvar prefix = string.substring(0, length\
    \ - longest.length);\n\treturn string + reverse(prefix);\n}\n", "    if (string.length\
    \ == 0){\n        return;\n    }\n    var palindrome = string;\n    var palindrome_rev\
    \ = string.split(\"\").reverse().join(\"\");\n    var prefix = string.substring(0,\
    \ string.length - 1);\n    while (true){\n        var postfix = palindrome_rev.substring(0,\
    \ prefix.length);\n        if (postfix != prefix){\n            prefix = prefix.substring(0,\
    \ prefix.length - 1);\n        } else {\n            var new_string = string +\
    \ palindrome_rev.substring(prefix.length);\n            return new_string;\n \
    \       }\n    }\n}\n", "  var palindrome = string;\n  var r = reverse(string);\n\
    \  //Since string and its reverse are matched by default, start the search from\
    \ the second letter.\n  var i = 1;\n  while(i < string.length){\n    if(r.substring(i)\
    \ == string.substring(0, string.length - i)){\n      palindrome = r.substring(0,\
    \ i) + string;\n      break;\n    }\n    i++;\n  }\n  return palindrome;\n}\n\n\
    var string1 = \"abbabbabbababbababbabba\";\nvar string2 = \"abbabbabbababbababbabbaa\"\
    ;\n", "    var palindrome_end = find_palindrome_suffix(string);\n    var string_before_palindrome\
    \ = string.substring(0, string.length - palindrome_end);\n    return string +\
    \ reverse(string_before_palindrome);\n}\n", "    function* map(string){\n    \
    \    for(let i = 0; i < string.length; i++){\n            yield { letter: string[i],\n\
    \                    index: i};\n        }\n    }\n    function* filter(iterator,\
    \ predicate){\n        for(let {letter, index} of iterator){\n            if(predicate(letter,\
    \ index)){\n                yield {letter, index};\n            }\n        }\n\
    \    }\n    function* combine(iterator){\n        const result = [];\n       \
    \ for(let {letter, index} of iterator){\n            result.push(letter);\n  \
    \      }\n        yield result.join('');\n    }\n    function* reverse(iterator){\n\
    \        const result = [];\n        for(let {letter, index} of iterator){\n \
    \           result.push({letter, index});\n        }\n        for(let i = result.length\
    \ - 1; i >= 0; i--){\n            yield result[i];\n        }\n    }\n    function*\
    \ get_previous_letters(string){\n        let letter_index = 0;\n        let letter\
    \ = string[letter_index];\n        let comparison_index = 1;\n        let comparison_letter\
    \ = string[comparison_index];\n        for(let i = 0; i < string.length; i++){\n\
    \            if(comparison_letter === letter){\n                yield {letter,\
    \ index: letter_index};\n                comparison_index++;\n               \
    \ comparison_letter = string[comparison_index];\n            }\n            else{\n\
    \                letter_index++;\n                letter = string[letter_index];\n\
    \                comparison_index = letter_index + 1;\n                comparison_letter\
    \ = string[comparison_index];\n            }\n        }\n    }\n    const is_palindrome\
    \ = (letter, index) => {\n        if(index < Math.floor(string.length / 2)){\n\
    \            return true;\n        }\n        const opposite_index = string.length\
    \ - index - 1;\n        return string[opposite_index] === letter;\n    };\n  \
    \  const palindrome_suffix = combine(get_previous_letters(string));\n    const\
    \ palindrome_prefix = combine(reverse(filter(map(string),", "\tvar reverse = string.split('').reverse().join('');\n\
    \n\tvar result = find_longest_suffix(string, reverse);\n\n\treturn string + reverse.substring(result.length);\n\
    }\n", "\t//Get the longest palindromic postfix\n\tvar longest = lps(string);\n\
    \t//Get the prefix of the string\n\tvar prefix = string.substring(0, string.length\
    \ - longest.length);\n\t//Reverse the prefix and append it to the end of the original\
    \ string\n\treturn string + reverse(prefix);\n}\n", "    var postfix = find_palindrome_postfix(string);\n\
    \    var result = string.substring(0, string.length - postfix.length) +\n    \
    \    reverse(string.substring(0, postfix.length));\n    return result;\n}\n",
  "    function is_palindrome(string){\n        for(var i = 0; i < Math.floor(string.length/2);\
    \ i++){\n            if(string[i] != string[string.length - 1 - i]){\n       \
    \         return false;\n            }\n        }\n        return true;\n    }\n\
    \    var longest_suffix = string.length;\n    for(var i = string.length; i > 0;\
    \ i--){\n        if(is_palindrome(string.substring(i))){\n            longest_suffix\
    \ = i;\n            break;\n        }\n    }\n    var prefix = string.substring(0,\
    \ longest_suffix);\n    return string + prefix.split(\"\").reverse().join(\"\"\
    );\n}\n", "    //@NOTE: For some weird reason JS's reverse() method doesn't work\
    \ with strings, so we must convert our string to array.\n    var string_array\
    \ = string.split('');\n    var rev_string_array = string_array.slice(0).reverse();\n\
    \    var palindrome_suffix_length = 0;\n    // @TODO: there is a better algorithm,\
    \ this one's complexity is O(n^2) and could be reduced to O(n)\n    while ( !\
    \ is_palindrome(string_array.slice(palindrome_suffix_length)) ) {\n        palindrome_suffix_length\
    \ += 1;\n    }\n    return string + rev_string_array.slice(palindrome_suffix_length).join('');\n\
    }\n", "\tvar suffix_length = longest_palindromic_suffix(string);\n\tvar prefix\
    \ = reverse(string.substring(0, string.length - suffix_length));\n\treturn prefix\
    \ + string;\n}\n", "\tvar reverse = string.split('').reverse().join('');\n\tvar\
    \ max_i = string.length - 1;\n\t\n\tvar suffix = '';\n\tvar prefix = '';\n\tvar\
    \ found = false;\n\tfor(var i = max_i; i >= 0; i--){\n\t\tsuffix = string.substring(i);\n\
    \t\tprefix = string.substring(0, i);\n\t\tif(suffix === reverse.substring(max_i\
    \ - i)){\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!found){\n\t\tthrow\
    \ new Error('Could not make palindrome from ' + string);\n\t}\n\treturn string\
    \ + reverse.substring(0, max_i - i);\n}\n", "    var longest_postfix = find_longest_postfix(string);\n\
    \    return string + longest_postfix.reverse().join(\"\");\n}\n", "  var longest_palindrome\
    \ = find_longest_palindrome(string);\n  var prefix = string.substring(0, string.length\
    \ - longest_palindrome.length);\n  return prefix + longest_palindrome + reverse(prefix);\n\
    }\n", "  // Invert the string.\n  var stringInvert = string.split(\"\").reverse().join(\"\
    \");\n  // Concatenate inverted string with the initial string and calculate the\
    \ suffix array.\n  var stringConcat = string.concat(stringInvert);\n  var Z =\
    \ z_values(stringConcat);\n  // Get the longest postfix that is a palindrome.\n\
    \  var longestPalindromePostfix = 0;\n  for(var i = 0; i < Z.length; i++){\n \
    \   if(Z[i] == string.length){\n      longestPalindromePostfix = i - string.length;\n\
    \      break;\n    }\n  }\n  // Get the string prefix that comes before the palindromic\
    \ suffix.\n  var stringPrefix = stringConcat.substring(0, string.length - longestPalindromePostfix);\n\
    \  // Invert the string prefix.\n  var stringPrefixInvert = stringPrefix.split(\"\
    \").reverse().join(\"\");\n  // Concatenate the palindromic suffix with inverted\
    \ string prefix.\n  var palindrome = stringConcat.substring(string.length - longestPalindromePostfix).concat(stringPrefixInvert);\n\
    \  return palindrome;\n}\n", "\tvar _i;\n\tvar _len;\n\tvar _max;\n\tvar _max_i;\n\
    \tvar _max_j;\n\tvar _palindrome;\n\tvar _prefix;\n\tvar _suffix;\n\tvar _suffix_len;\n\
    \t\n\t_len = string.length;\n\t_palindrome = string;\n\t_max = 0;\n\t_max_i =\
    \ 0;\n\t_max_j = 0;\n\t\n\t// Find the longest palindromic suffix\n\tfor(_i =\
    \ 0; _i < _len; _i++){\n\t\tfor(_j = _len; _j > _i; _j--){\n\t\t\t_suffix = string.substring(_i,\
    \ _j);\n\t\t\tif(_suffix.length > _max && is_palindrome(_suffix)){\n\t\t\t\t_max\
    \ = _suffix.length;\n\t\t\t\t_max_i = _i;\n\t\t\t\t_max_j = _j;\n\t\t\t}\n\t\t\
    }\n\t}\n\t\n\t_suffix = string.substring(_max_i, _max_j);\n\t_suffix_len = _suffix.length;\n\
    \t\n\t// Reverse the prefix and append it to end of original string\n\tfor(_i\
    \ = 0; _i < _suffix_len; _i++){\n\t\t_prefix = string.substring(0, _i);\n\t\t\
    _palindrome += _prefix.split(\"\").reverse().join(\"\");\n\t}\n\t\n\treturn _palindrome;\n\
    }", "    var lps = [];\n    var prefix = [];\n    var len = string.length;\n \
    \   var i;\n    var j;\n    var longest_suffix_length = 0;\n    var middle_index\
    \ = -1;\n    //First we will determine the longest suffix that is a palindrome.\n\
    \    //(note that this is not the same as the longest palindromic prefix)\n  \
    \  for(i = 0; i < len; i++){\n        lps[i] = [];\n        for(j = 0; j < len;\
    \ j++){\n            lps[i][j] = false;\n        }\n    }\n    //all prefixes\
    \ of length 1 are palindromes.\n    for(i = 0; i < len; i++){\n        lps[i][i]\
    \ = true;\n    }\n    //all prefixes of length 2 are palindromes if they are identical.\n\
    \    for(i = 0; i < len - 1; i++){\n        if(string[i] === string[i + 1]){\n\
    \            lps[i][i + 1] = true;\n            longest_suffix_length = 2;\n \
    \           middle_index = i;\n        }\n    }\n    //determine if all prefixes\
    \ of length >= 3 are palindromes.\n    for(var k = 3; k <= len; k++){\n      \
    \  for(i = 0; i < len - k + 1; i++){\n            //Get the ending index of this\
    \ prefix\n            j = i + k - 1;\n            //Check if the first and last\
    \ characters are the same and if the\n            //string between the first and\
    \ last characters is a palindrome.\n            if(string[i] === string[j] &&\
    \ lps[i + 1][j - 1]){\n                lps[i][j] = true;\n                longest_suffix_length\
    \ = k;\n                middle_index = i;\n            }\n        }\n    }\n \
    \   if(longest_suffix_length === len){\n        return string;\n    }\n    //find\
    \ the prefix and reverse it.\n    for(i = 0; i < middle_index; i++){\n       \
    \ prefix.push(", "    var n = string.length;\n    var palindrome;\n    //caculate\
    \ the suffix array\n    var suffix_array = new Array(n);\n    for(var i = 0; i\
    \ < n; i++){\n        suffix_array[i] = string.substring(i, n);\n    }\n    //sort\
    \ suffix array\n    suffix_array.sort();\n    //initialize longest palindrome\
    \ to be \"\"\n    var longest_palindrome = \"\";\n    for(var i = 0; i < n-1;\
    \ i++){\n        var j = i+1;\n        //get the longest common prefix of suffixes\
    \ at index i and j\n        var lcp = longest_common_prefix(suffix_array[i], suffix_array[j]);\n\
    \        //update longest palindrome if required\n        if(lcp.length > longest_palindrome.length){\n\
    \            longest_palindrome = lcp;\n        }\n    }\n    //copy the prefix\
    \ of the string that is not palindrome\n    var prefix = string.substring(0, n-longest_palindrome.length);\n\
    \    //reverse the prefix\n    prefix = prefix.split(\"\").reverse().join(\"\"\
    );\n    //concatenate with the string\n    palindrome = prefix + string;\n   \
    \ return palindrome;\n}\n", "\t//special case when the string is a palindrome\
    \ itself.\n\tif(string === reverse(string)) return string;\n\t//length to be used\
    \ in the loop.\n\tvar len = string.length;\n\t//Find the longest palindromic suffix.\n\
    \tfor(var i = 0; i < len; i++){\n\t\t//suffix is the shortest suffix of the string\
    \ that starts at i.\n\t\tvar suffix = string.substring(i);\n\t\t//reverse it.\n\
    \t\tvar prefix = reverse(suffix);\n\t\t//check if they match.\n\t\tif(suffix ===\
    \ prefix){\n\t\t\t//They do, that means suffix is a palindrome.\n\t\t\t//Now return\
    \ the reverse of the first part + the whole string.\n\t\t\treturn reverse(string.substring(0,\
    \ i)) + string;\n\t\t}\n\t}\n}\n", "\tvar palindrome_suffix = '';\n\tvar prefix_to_append\
    \ = '';\n\tvar palindrome_suffix_length = 0;\n\tvar prefix_to_append_length =\
    \ 0;\n\tvar i;\n\tvar last_index = string.length-1;\n\tvar half_last_index = (string.length\
    \ / 2) | 0;\n\n\tif(string.length === 0){\n\t\treturn '';\n\t}\n\n\t// Find the\
    \ longest palindromic suffix.\n\t// Note: a string is a palindrome of itself,\n\
    \t// so it is a palindromic suffix.\n\tfor(i = 0; i < half_last_index; i += 1){\n\
    \t\tif(string[i] === string[last_index - i]){\n\t\t\tpalindrome_suffix_length\
    \ += 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(palindrome_suffix_length\
    \ === 0){\n\t\t// If no palindromic suffix found,\n\t\t// append a reversed string\
    \ as prefix to the end.\n\t\tprefix_to_append = string.split('').reverse().join('');\n\
    \t} else {\n\t\t// Find the prefix that comes before the palindromic suffix.\n\
    \t\tprefix_to_append_length = string.length - palindrome_suffix_length;\n\t\t\
    prefix_to_append = string.substr(0, prefix_to_append_length);\n\t\t// Reverse\
    \ it.\n\t\tprefix_to_append = prefix_to_append.split('').reverse().join('');\n\
    \t}\n\n\treturn string + prefix_to_append;\n}\n", "\t//Find the longest palindromic\
    \ suffix.\n\tvar suffix = find_longest_palindromic_suffix(string);\n\t//Append\
    \ reverse of prefix that comes before palindromic suffix.\n\tvar prefix = string.substring(0,\
    \ string.length - suffix.length);\n\tvar prefix_rev = prefix.split(\"\").reverse().join(\"\
    \");\n\treturn prefix_rev + string;\n}\n", "    // Find the longest palindromic\
    \ suffix\n    // This algorithm assumes that input string is not a palindrome\n\
    \    var palindrome_suffix = \"\";\n    var i = 1;\n    while(i <= string.length){\n\
    \        var test_string = string.substring(string.length - i);\n        if(is_palindrome(test_string)){\n\
    \            palindrome_suffix = test_string;\n            break;\n        }\n\
    \        i++;\n    }\n    // Reverse the string prefix\n    // The length of this\
    \ prefix is the string length - palindrome suffix length - 1\n    var string_prefix\
    \ = reverse_string(string.substring(0, string.length - palindrome_suffix.length\
    \ - 1));\n    return string_prefix + string;\n}\n", "  //find palindromic prefix\n\
    \  var longest_prefix_palindrome = '';\n  var prefix = '';\n  var suffix = '';\n\
    \  for(var i = 0; i<string.length; i++){\n    prefix += string[i];\n    suffix\
    \ = string[i] + suffix;\n    if(prefix === suffix){\n      longest_prefix_palindrome\
    \ = prefix;\n    }\n  }\n  return string + reverse(string.slice(longest_prefix_palindrome.length,\
    \ string.length));\n}\n\n", "    if (string.length == 0){\n        return string;\n\
    \    }\n    var longest_suffix = get_longest_palindromic_suffix(string);\n   \
    \ var string_prefix = string.substring(0, string.length - longest_suffix.length);\n\
    \    var string_prefix_reversed = string_prefix.split(\"\").reverse().join(\"\"\
    );\n    return string_prefix_reversed + string;\n}\n", "\tvar prefix = string.slice(0,\
    \ string.length-1);\n\tvar suffix = string.slice(string.length-1);\n\twhile(!suffix.is_palindrome){\n\
    \t\tsuffix = suffix + prefix.charAt(prefix.length-1);\n\t\tprefix = prefix.slice(0,\
    \ prefix.length-1);\n\t}\n\treturn string + prefix.reverse();\n}\n", "  var palindrome\
    \ = is_palindrome(string),\n      postfix = palindrome ? '' : longest_palindrome_postfix(string);\n\
    \  return string + reverse(string.substring(0, string.length - postfix.length));\n\
    }\n", "  var longest_palin_suffix = find_longest_palindrome_suffix(string);\n\
    \  var prefix = string.substring(0, string.length - longest_palin_suffix.length);\n\
    \  var reverse_prefix = reverse_string(prefix);\n  return string + reverse_prefix;\n\
    }\n", "  if(!string)\n    return \"\";\n  var test_string = string + string.split(\"\
    \").reverse().join(\"\");\n  //var test_string = string + \"#\" + string.split(\"\
    \").reverse().join(\"\");\n  var longest_suffix = longest_suffix_palindrome(test_string);\n\
    \  var reverse_prefix = string.substring(0, string.length - longest_suffix.length).split(\"\
    \").reverse().join(\"\");\n  return string + reverse_prefix;\n}\n", "\t//string\
    \ = string.toLowerCase();\n\tvar i = string.length - 1;\n\twhile(true){\n\t\t\
    if(is_palindrome(string.substring(0, i + 1))){\n\t\t\treturn string + reverse(string.substring(0,\
    \ string.length - i - 1));\n\t\t}\n\t\ti--;\n\t}\n}\n", "    var lps = find_longest_palindromic_suffix(string),\n\
    \        prefix = string.substring(0, lps.lps_length);\n    return prefix.concat(prefix.split('').reverse().join(''));\n\
    }\n", "    var length = string.length;\n    if(length < 2){\n        return string;\n\
    \    }\n    var suffix = longest_postfix_palindrome(string);\n    if(suffix ===\
    \ length){\n        return string;\n    }\n    var reversed_prefix = string.substring(0,\
    \ length - suffix).split(\"\").reverse().join(\"\");\n    return reversed_prefix\
    \ + string;\n}\n\nvar tests = [\n    { string: \"abccba\", test: make_palindrome,\
    \ result: \"abccba\" },\n    { string: \"abcba\", test: make_palindrome, result:\
    \ \"abcba\" },\n    { string: \"abcb\", test: make_palindrome, result: \"abcb\"\
    \ },\n    { string: \"aba\", test: make_palindrome, result: \"aba\" },\n    {\
    \ string: \"ab\", test: make_palindrome, result: \"aba\" },\n    { string: \"\
    a\", test: make_palindrome, result: \"a\" },\n    { string: \"abcdefg\", test:\
    \ make_palindrome, result: \"abcdefg\" },\n    { string: \"cbbd\", test: make_palindrome,\
    \ result: \"dcbdbcd\" },\n    { string: \"aacecaaa\", test: make_palindrome, result:\
    \ \"aacecaaa\" },\n    { string: \"abcd\", test: make_palindrome, result: \"dcbabcd\"\
    \ },\n    { string: \"\", test: make_palindrome, result: \"\" },\n];\n\ntests.forEach(function(test){\n\
    \    var result = test.test(test.string);\n    console.log(result === test.result\
    \ ? 'SUCCESS' : 'FAILED', 'string:', test.string, 'result:', result, 'expected:',\
    \ test.result);\n});", "  for(var j = string.length; j > 0; j--){\n    var substring\
    \ = string.substring(0, j);\n    var reversed_substring = substring.split(\"\"\
    ).reverse().join(\"\");\n    if(substring == reversed_substring){\n      break;\n\
    \    }\n  }\n  return string + reversed_substring.substring(0, (string.length\
    \ - j));\n}\n", "    var palindrome = \"\";\n    var longest = \"\";\n    for(var\
    \ i = 0; i<string.length; i++){\n        var suffix = string.substring(i, string.length);\n\
    \        var prefix = string.substring(0, i);\n        if(suffix.split(\"\").reverse().join(\"\
    \") == prefix && suffix.length > longest.length){\n            longest = suffix;\n\
    \        }\n    }\n    return string + longest.split(\"\").reverse().join(\"\"\
    ).substring(longest.length);\n}\n", "\tif(string == string.split('').reverse().join(''))\n\
    \t\treturn string;\n\tvar s_prefix = string.substring(0, string.length - 1);\n\
    \tvar s_suffix = string.substring(1, string.length);\n\tvar l_p_s = l_p_s_string(s_suffix);\n\
    \tvar l_p_s_r = l_p_s.split('').reverse().join('');\n\treturn s_prefix + l_p_s_r;\n\
    }\n", "\tfunction is_palindrome(s){\n\t\tvar i = 0, length = s.length, mid = Math.floor(length/2);\n\
    \t\twhile(i < mid){\n\t\t\tif(s[i] != s[length-i-1]){\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn true;\n\t}\n\tvar len = string.length,\
    \ mid = Math.floor(len/2), i = len - 1;\n\twhile(i >= mid){\n\t\tif(is_palindrome(string.substring(0,i+1))){\n\
    \t\t\treturn string + reverse(string.substring(i+1));\n\t\t}\n\t\ti--;\n\t}\n\t\
    return null;\n}\n", "\tvar suffix = \"\";\n\n\t//Find the longest palindromic\
    \ suffix\n\tfor(var i = string.length; i >= 0; i--){\n\t\tif(is_palindrome(string.substring(i))){\n\
    \t\t\tsuffix = string.substring(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//Reverse the\
    \ prefix and append it to the palindromic suffix\n\treturn string + reverse(string.substring(0,\
    \ string.length - suffix.length));\n}\n", "\tvar i = 0;\n\tvar longestPalindrome\
    \ = 0;\n\tvar palindromePosition = 0;\n\tfor(i = 0; i < string.length; i++){\n\
    \t\tif(is_palindrome(string.substring(i)) && longestPalindrome < i){\n\t\t\tlongestPalindrome\
    \ = i;\n\t\t\tpalindromePosition = i;\n\t\t}\n\t}\n\tvar reverse = string.substring(0,\
    \ palindromePosition).split(\"\").reverse().join(\"\");\n\treturn string + reverse;\n\
    }", "\tvar index = 0;\n\tvar length = string.length;\n\tfor(var i = 1; i < length;\
    \ i++){\n\t\tif(string[i] == string[0]){\n\t\t\tindex = i;\n\t\t}\n\t}\n\tvar\
    \ prefix = string.substring(0, index);\n\tvar suffix = string.substring(index,\
    \ length);\n\treturn suffix + reverse(prefix);\n}", "  if(string.length<=1) return\
    \ string;\n  // find the longest palindromic suffix of input string\n  var rev_string\
    \ = string.split('').reverse().join('');\n  var lps = lpsubstring(string+'#'+rev_string);\n\
    \  // reverse the string after the longest palindromic suffix\n  var prefix =\
    \ string.substring(lps, string.length);\n  return prefix.split('').reverse().join('')\
    \ + string;\n}\n", "    // find length of longest palindromic suffix of string\n\
    \    var length = string.length;\n    var newstring = string;\n    for (var i\
    \ = length - 1; i >= 0; i--){\n        var match = 1;\n        for (var j = 0;\
    \ j < length - i; j++){\n            if (string[i + j] != string[length - j -\
    \ 1]){\n                match = 0;\n                break;\n            }\n  \
    \      }\n        if (match == 1){\n            // append reverse of the string\
    \ prefix\n            newstring = newstring + string.substring(0, i).split(\"\"\
    ).reverse().join(\"\");\n            return newstring;\n        }\n    }\n   \
    \ return string;\n}", "    var left = 0;\n    var right = 0;\n    for(var i =\
    \ 0; i < string.length; i++){\n        var _right = find_longest_palindrome(string,\
    \ i, i);\n        var _left = find_longest_palindrome(string, i, i+1);\n     \
    \   if(_right > right){\n            right = _right;\n            left = i;\n\
    \        }\n        if(_left > right){\n            right = _left;\n         \
    \   left = i;\n        }\n    }\n    var prefix = string.substring(0, left);\n\
    \    return string + reverse(prefix);\n}\n", "    var suffix = find_longest_postfix_palindrome(string);\n\
    \    var prefix = find_reverse_prefix(string, suffix);\n    return prefix + string\
    \ + suffix;\n}\n", "  var rev_string = reverse(string);\n  var palindrome = longest_common_substring(string,\
    \ rev_string);\n  var prefix = string.slice(0, string.length - palindrome.length);\n\
    \  var rev_prefix = reverse(prefix);\n  return string + rev_prefix;\n}\n", " \
    \   //result, the reversed prefix and a new string\n    var result,rev_prefix,new_string;\n\
    \    //find the longest palindromic postfix - string must be reversed to find\
    \ the longest prefix\n    var suffix = find_longest_palindromic_substring(string.split(\"\
    \").reverse().join(\"\"));\n    //prevent the case of having entire string as\
    \ a postfix, in that case no reverse is needed\n    if(suffix==string){\n    \
    \    return string;\n    }\n    //reverse the suffix, substract from string and\
    \ append to itself\n    rev_prefix = suffix.split(\"\").reverse().join(\"\");\n\
    \    new_string = string.substring(0,string.length-suffix.length);\n    new_string\
    \ = new_string+rev_prefix+string;\n    return new_string;\n}\n", "    let reversed\
    \ = string.split('').reverse().join('');\n    return string + reversed.substring(reversed.length\
    \ - string.length);\n}\n", "\tfunction reverse(string){\n\t\tvar rev = \"\";\n\
    \t\tfor(var i = string.length - 1; i >= 0; i--){\n\t\t\trev += string[i];\n\t\t\
    }\n\t\treturn rev;\n\t}\n\tfunction longest_palindrome_postfix(string){\n\t\t\
    for(var i = string.length; i >= 0; i--){\n\t\t\tif(is_palindrome(string.substring(i,\
    \ string.length))){\n\t\t\t\treturn string.substring(i, string.length);\n\t\t\t\
    }\n\t\t}\n\t}\n\tvar postfix = longest_palindrome_postfix(string);\n\treturn string\
    \ + reverse(string.substring(0, string.length - postfix.length));\n}\n", "   \
    \ if(is_palindrome(string)){\n        return string;\n    }\n    var longest_palindrome_length\
    \ = get_longest_palindrome_length(string);\n    var string_length = string.length;\n\
    \    if(longest_palindrome_length === string_length){\n        //The string already\
    \ is a palindrome, so there is nothing to do\n        return string;\n    }\n\
    \    var left = string.substring(0, string_length - longest_palindrome_length);\n\
    \    var right = string.substring(string_length - longest_palindrome_length, string_length);\n\
    \    return left + reverse(right) + right;\n}\n", "    var string_length = string.length;\n\
    \    var word = string.split('');\n    var prefix_length = string_length - find_longest_postfix_palindrome(word);\n\
    \    var prefix = word.slice(0, prefix_length);\n    return string + prefix.reverse().join('');\n\
    }\n", "\tvar suffix_tbl = build_suffix_tbl(string);\n\tvar reverse_prefix = reverse_string(string.substring(0,string.length-suffix_tbl[string.length]));\n\
    \treturn string+reverse_prefix;\n}\n\nvar assert = require('assert');\n\ndescribe('make_palindrome',\
    \ function(){\n\tit('should return a palindrome', function(){\n\t\tassert.equal(make_palindrome('abc'),\
    \ 'abcba');\n\t\tassert.equal(make_palindrome('aaaaaaaa'), 'aaaaaaaa');\n\t\t\
    assert.equal(make_palindrome('cccb'), 'bcccb');\n\t});\n});", "  if(string.length\
    \ === 0){\n    return null;\n  }\n  var length = string.length;\n  var z = new\
    \ Array(length);\n  z[0] = length;\n  var l = 0;\n  var r = 0;\n  var s = 0;\n\
    \  for(var i = 1; i < length; i++){\n    var j = i > r ? 0 : Math.min(r - i +\
    \ 1, z[i - s]);\n    while(i + j < length && string[j] === string[i + j]){\n \
    \     j++;\n    }\n    if(i + j - 1 > r){\n      l = i;\n      r = i + j - 1;\n\
    \      s = i;\n    }\n    z[i] = j;\n  }\n  var sub = string.substring(l - 1,\
    \ r + 1);\n  var suffix = string.substring(l - 1, l - 1 + z[l - 1]);\n  return\
    \ sub + string.substring(0, l - 1).split('').reverse().join('') + suffix;\n}\n\
    \nmodule.exports = make_palindrome;", "    function reverse(string){\n       \
    \ var arr = string.split('');\n        arr.reverse();\n        return arr.join('');\n\
    \    }\n    var rev = reverse(string);\n    var revsub = rev.substring(0, rev.length\
    \ - 1);\n    var max = 0;\n    while(revsub.length > 0){\n        if(string.indexOf(revsub)\
    \ == 0){\n            max = revsub.length;\n            break;\n        }\n  \
    \      revsub = revsub.substring(0, revsub.length - 1);\n    }\n    var prefix\
    \ = string.substring(0, string.length - max);\n    return string + reverse(prefix);\n\
    }\n\nvar test_string = '123456789';", "    for(let i = string.length; i > 0; i--){\n\
    \        let str = string.substring(0, i);\n        if(is_palindrome(str)){\n\
    \            return str + reverse(string.substring(i, string.length));\n     \
    \   }\n    }\n    return \"\";\n}", "    var max_postfix_length = 0;\n    var\
    \ max_postfix_index = 0;\n    var postfix_length = 0;\n    var current_postfix_index\
    \ = 0;\n    for(var i = 0; i < string.length; i++){\n        for(var j = i; j\
    \ < string.length; j++){\n            if(string[i] == string[j]){\n          \
    \      postfix_length++;\n                current_postfix_index = j;\n       \
    \     }else{\n                break;\n            }\n        }\n        if(postfix_length\
    \ > max_postfix_length){\n            max_postfix_length = postfix_length;\n \
    \           max_postfix_index = current_postfix_index;\n        }\n        postfix_length\
    \ = 0;\n    }\n    return string + string.substring(0, string.length - max_postfix_length).split(\"\
    \").reverse().join(\"\");\n}\n\nvar string = \"abcabc\";\nvar result = make_palindrome(string);",
  "    let length = 0;\n    let shift = 0;\n    let pal_len = 0;\n    let temp_len\
    \ = 0;\n    let str_len = string.length;\n    let str_bwd = string.split('').reverse().join('');\n\
    \    // Find the longest postfix of supplied string that is a palindrome.\n  \
    \  for(let i = 0; i < str_len; i++){\n        // If current char is equal to char\
    \ in a reversed string,\n        // we have a palindrome\n        if(string[i]\
    \ === str_bwd[i]){\n            temp_len++;\n        }\n        else{\n      \
    \      // Make sure we count the longest palindrome\n            if(temp_len >\
    \ pal_len){\n                pal_len = temp_len;\n                length = i;\n\
    \                temp_len = 0;\n            }\n        }\n    }\n    if(temp_len\
    \ > pal_len){\n        pal_len = temp_len;\n        length = str_len;\n      \
    \  temp_len = 0;\n    }\n    shift = str_len - length;\n    // Reverse string\
    \ from 0 to shift and append\n    // to string from shift to end\n    return str_bwd.substring(0,\
    \ shift) + string;\n}\n", "\t// Find the length of the longest suffix of the string,\
    \ that is a palindrome\n\tfunction find_suffix_length(string){\n\t\tvar i = 0;\n\
    \t\twhile(i < string.length){\n\t\t\tif(is_palindrome(string.substring(i))){\n\
    \t\t\t\treturn string.length - i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn 0;\n\
    \t}\n\t\n\tvar suffix_length = find_suffix_length(string);\n\treturn string +\
    \ string.substring(0, string.length - suffix_length).split(\"\").reverse().join(\"\
    \");\n}\n", "\tvar reverse = string.split('').reverse().join('');\n\tvar candidate\
    \ = string + reverse;\n\tvar longest = 0;\n\tfor(var i = 0; i < string.length;\
    \ i++){\n\t\tvar substring = string.substring(i);\n\t\tvar reverse_substring =\
    \ substring.split('').reverse().join('');\n\t\tif(reverse_substring == substring){\n\
    \t\t\tlongest = substring.length;\n\t\t}\n\t}\n\tif(longest == 0){\n\t\treturn\
    \ candidate;\n\t}\n\tvar prefix = string.substring(0, string.length - longest);\n\
    \treturn prefix + string;\n}", "    var max_palindrome_suffix_index = 0;\n   \
    \ for(var i = 1; i < string.length; i++){\n        if(string.substring(i) == string.substring(i).split(\"\
    \").reverse().join(\"\")){\n            max_palindrome_suffix_index = i;\n   \
    \     }\n    }\n    var suffix = string.substring(max_palindrome_suffix_index).split(\"\
    \").reverse().join(\"\");\n    return string + suffix;\n}\n", "\tstring = string.split('');\n\
    \tvar prefix = '';\n\tvar suffix = '';\n\t//Find the longest palindromic suffix\n\
    \tfor(var i = string.length - 1; i >= 0; i--){\n\t\tprefix = string.slice(0, i).join('');\n\
    \t\tsuffix = string.slice(i).join('');\n\t\tif(is_palindrome(suffix)){\n\t\t\t\
    break;\n\t\t}\n\t}\n\treturn prefix + reverse(suffix);\n}\n", "    var longest_palindrome\
    \ = get_longest_palindrome(string),\n        remaining_string = string.substring(0,string.length\
    \ - longest_palindrome.length),\n        suffix = string.substring(string.length\
    \ - longest_palindrome.length);\n    return remaining_string.split(\"\").reverse().join(\"\
    \") + string + suffix;\n}\n", "  if (string.length < 2) return string;\n  var\
    \ prefix = find_palindrome_prefix(string);\n  //console.log(prefix, string.slice(prefix.length),\
    \ string.slice(0, string.length - prefix.length));\n  return string.slice(prefix.length)\
    \ + string.slice(0, string.length - prefix.length).split('').reverse().join('');\n\
    }\n", "\treturn string + string.split('').reverse().join('').substring(string.length);\n\
    }\n", "  var rev_string = string.split('').reverse().join('');\n  var rev_string_prefix\
    \ = rev_string.substring(0, rev_string.length - string.length + 1);\n  return\
    \ string + rev_string_prefix;\n}\n", "\t//Find the longest postfix substring that\
    \ is a palindrome\n\tvar longest_palindrome_suffix = find_palindrome_suffix(string);\n\
    \t//Reverse the string up to the end of the palindrome suffix, then append the\
    \ entire string to the end.\n\treturn string.substring(0,longest_palindrome_suffix).split(\"\
    \").reverse().join(\"\") + string;\n}\n", "  var s = string + '$' + reverse_string(string),\n\
    \      n = s.length,\n      // create an array that will contain the length of\
    \ the longest palindromic suffix.\n      P = new Array(n),\n      // calculate\
    \ P\n      C = 0, // center of the longest palindrom\n      R = 0, // right border\
    \ of the longest palindrom\n      i = 0; // current index\n\n  for (i = 1; i <\
    \ n-1; i++) {\n    // find the corresponding letter in the palindrome subString\n\
    \    var i_mirror = 2*C-i; // equals (C - (i-C))\n\n    //current longest palindrom\
    \ is smaller than the right border, can't expand it\n    if (R > i) {\n      P[i]\
    \ = Math.min(R-i, P[i_mirror]);\n    } else {\n      P[i] = 0;\n    }\n\n    //\
    \ Attempt to expand palindrom centered at i\n    while (s[i + 1 + P[i]] == s[i\
    \ - 1 - P[i]]){\n      P[i]++;\n    }\n\n    // If palindrom centered at i expand\
    \ past R,\n    // adjust center based on expanded palindrom.\n    if (i + P[i]\
    \ > R) {\n      C = i;\n      R = i + P[i];\n    }\n  }\n\n  //find the maximum\
    \ element in P\n  var maxLen = 0,\n      centerIndex = 0;\n  for (i = 1; i < n-1;\
    \ i++) {\n    if (P[i] > maxLen) {\n      maxLen = P[i];\n      centerIndex =\
    \ i;\n    }\n  }\n\n  return reverse_string(string.substring(0, (string.length\
    \ - maxLen)/2)) + string;\n}", "    var prefix_length = find_longest_palindrome_postfix(string);\n\
    \    var prefix = string.substring(0, prefix_length);\n    var suffix = string.substring(prefix_length);\n\
    \    return string + reverse(prefix);\n}\n", "  var str=string.split('').reverse().join('');\n\
    \  var len=str.length;\n  var j=0;\n  var i=0;\n  var z=[];\n  z[0]=0;\n  while(i<len){\n\
    \    if(str[i]==str[j]){\n      z[i]=j+1;\n      i++;\n      j++;\n    }else{\n\
    \      if(j==0){\n        z[i]=0;\n        i++;\n      }else{\n        j=z[j-1];\n\
    \      }\n    }\n  }\n  return str.substring(0,len-z[len-1])+string;\n}\n", "\t\
    var string_len = string.length;\n\tvar found_palindrome = false;\n\tfor(var i\
    \ = string_len; i >= 1; i--){\n\t\tvar postfix = string.substring(string_len -\
    \ i, string_len);\n\t\tif(is_palindrome(postfix)){\n\t\t\tfound_palindrome = true;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\tif(found_palindrome){\n\t\tvar prefix = string.substring(0,\
    \ string_len - i);\n\t\tvar prefix_len = prefix.length;\n\t\tfor(var j = prefix_len\
    \ - 1; j >= 0; j--){\n\t\t\tstring += prefix[j];\n\t\t}\n\t}\n\treturn string;\n\
    }", "    for(var i = string.length; i > 1; i--){\n        var postfix = string.substring(string.length\
    \ - i);\n        if(postfix === postfix.split(\"\").reverse().join(\"\")){\n \
    \           var prefix = string.substring(0, string.length - i);\n           \
    \ var reverse_prefix = prefix.split(\"\").reverse().join(\"\");\n            return\
    \ string + reverse_prefix;\n        }\n    }\n    return string + string.split(\"\
    \").reverse().join(\"\");\n}\n", "\tif(string == null || string.length == 0)\n\
    \t\treturn string;\n\t\n\tvar max_palindrome_suffix_length = longest_palindrome_suffix(string);\n\
    \tvar prefix = string.substring(0,string.length - max_palindrome_suffix_length);\n\
    \treturn prefix.split(\"\").reverse().join(\"\") + string;\n}\n", "    //create\
    \ a reversed string and concatenate it to the supplied string\n    var reverse_string\
    \ = string.split(\"\").reverse().join(\"\");\n    var concatenated_string = string\
    \ + reverse_string;\n    //find the longest substring of the concatenated string\
    \ that is a palindrome\n    var longest_palindrome = longest_palindrome_substring(concatenated_string);\n\
    \    //exclude the the first half of the palindrome suffix since it is redundant\
    \ in the palindrome\n    //reverse the remaining characters, append them to the\
    \ original string, and return the result\n    var last_index = longest_palindrome.length\
    \ - string.length;\n    var sub_string = longest_palindrome.substring(string.length,\
    \ last_index);\n    return string + sub_string.split(\"\").reverse().join(\"\"\
    );\n}\n\nvar str = \"aba\";", "\t// Find the length of the longest palindromic\
    \ suffix\n\tvar suffix_len = longest_palindromic_suffix(string);\n\t// Reverse\
    \ the string prefix that comes before the palindromic suffix\n\tvar prefix = string.substring(0,\
    \ string.length - suffix_len).split(\"\").reverse().join(\"\");\n\t// Append prefix\
    \ to the end of the string\n\treturn string + prefix;\n}\n", "  var is_palindrome\
    \ = function(string){\n    var i = 0;\n    var n = string.length;\n    for(var\
    \ j = n-1; j >= 0; j--){\n      if(string[i] != string[j]){\n        return false;\n\
    \      }\n      i++;\n    }\n    return true;\n  };\n\n  //Find palindromic suffix\
    \ of a given string\n  var palindromic_suffix = function(string){\n    var n =\
    \ string.length;\n    for(var i = n; i >= 0; i--){\n      if(is_palindrome(string.substring(i,\
    \ n))){\n        return string.substring(i, n);\n      }\n    }\n    return \"\
    \";\n  };\n\n  var suffix = palindromic_suffix(string);\n  var prefix = string.substring(0,\
    \ string.length - suffix.length);\n  return prefix + suffix + prefix.split(\"\"\
    ).reverse().join(\"\");\n}\n", "\tfor(let i = string.length - 1; i >= 0; i--){\n\
    \t\tif(is_palindrome(string.substring(0, i))){\n\t\t\treturn string + reverse(string.substring(i));\n\
    \t\t}\n\t}\n\treturn \"\";\n}\n", "    var result = [];\n    var string_reversed\
    \ = string.split('').reverse().join('');\n    var max_length = -1;\n    var max_length_index\
    \ = -1;\n    for(var i = 0; i < string.length; i++){\n        if(string.substring(i)\
    \ == string_reversed.substring(0, string.length - i)){\n            max_length\
    \ = string.length - i;\n            max_length_index = i;\n        }\n    }\n\
    \    for(var i = 0; i < max_length_index; i++){\n        result.push(string.charAt(i));\n\
    \    }\n    for(var i = string.length - 1; i >= max_length_index; i--){\n    \
    \    result.push(string.charAt(i));\n    }\n    return result.join('');\n}\n",
  "    // Finding the longest palindromic suffix.\n    // Idea: use the suffix tree\
    \ to find the longest suffix that is a palindrome\n    // - Find the longest postfix\
    \ that is a palindrome.\n    // - Find the longest palindromic prefix\n    //\
    \ - Output the reverse of the prefix\n    let reversed_string = string.split('').reverse().join('');\n\
    \    let concatenated_string = string + '#' + reversed_string;\n    let z_function\
    \ = compute_z_function(concatenated_string);\n    let max_zeros = 0;\n    for(let\
    \ i = z_function.length - 1; i >= 0; i--){\n        if(z_function[i] == i + 1){\n\
    \            max_zeros = i + 1;\n            break;\n        }\n    }\n    return\
    \ reversed_string.substring(0, reversed_string.length - max_zeros) + string;\n\
    }\n", "\tconst rev_string = string.split('').reverse().join('');\n\tfor(var i\
    \ = 0; i < string.length; i++){\n\t\tif(string.slice(i) === rev_string.slice(0,\
    \ string.length - i)){\n\t\t\treturn string + rev_string.slice(string.length -\
    \ i);\n\t\t}\n\t}\n}\n", "    var str_len = string.length;\n    if(is_palindrome(string))\
    \ return string;\n    if(string.substring(0, str_len - 1) == reverse(string.substring(1,\
    \ str_len)))\n        return string.substring(0, 1) + string;\n    var prefix\
    \ = string.substring(0, str_len - 1);\n    var postfix = string.substring(1, str_len);\n\
    \    if(is_palindrome(prefix)) return string + reverse(postfix);\n    if(is_palindrome(postfix))\
    \ return reverse(prefix) + string;\n    return string + reverse(prefix);\n}\n",
  "  //Find the longest palindromic suffix.\n  var suffix = \"\";\n  for(var i = string.length;\
    \ i >= 0; i--){\n    if(is_palindrome(string.substring(i, string.length))){\n\
    \      suffix = string.substring(i, string.length);\n      break;\n    }\n  }\n\
    \  //Make a prefix that is a reverse of a suffix.\n  var prefix = reverse(string.substring(0,\
    \ string.length - suffix.length));\n  //Return the string concatenation.\n  return\
    \ prefix + string;\n}\n", "    function reverse(string){\n        return string.split('').reverse().join('');\n\
    \    }\n    // find the prefix that is a palindrome\n    for(var i = string.length\
    \ - 1; i >= 0; i--){\n        var prefix = string.substring(0, i + 1);\n     \
    \   var postfix = string.substring(i + 1);\n        var reversed_prefix = reverse(prefix);\n\
    \        if(reversed_prefix == postfix){\n            return string + reverse(string.substring(0,\
    \ i));\n        }\n    }\n    return string;\n}\n", "  let postfix = find_longest_postfix_palindrome(string);\n\
    \  let prefix = string.substring(0, string.length - postfix.length);\n  let reversed_prefix\
    \ = reverse_string(prefix);\n  return string + reversed_prefix;\n}\n", "\tlet\
    \ prefix = '';\n\tlet suffix = string;\n\twhile(suffix.length > 0){\n\t\tif(is_palindrome(suffix)){\n\
    \t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tprefix += suffix[0];\n\t\t\tsuffix = suffix.slice(1);\n\
    \t\t}\n\t}\n\treturn prefix + string;\n}\n", "    //The longest palindromic suffix\
    \ of a string is identical to the longest palindromic prefix of a reversed string.\n\
    \    // Thus we can find it using Manacher's algorithm.\n    var reverse_string\
    \ = reverse(string);\n    var palindromic_suffix = find_longest_palindromic_substring(reverse_string,\
    \ 0, string.length - 1);\n    var length_palindromic_suffix = palindromic_suffix.length;\n\
    \    var length_string = string.length;\n    var prefix = string.substring(0,\
    \ length_string - length_palindromic_suffix);\n    var reverse_prefix = reverse(prefix);\n\
    \    return string + reverse_prefix;\n}", "\t\n\tfunction is_palindrome(string){\n\
    \t\t// return true if supplied string is a palindrome, else return false\n\t\t\
    return string === string.split('').reverse().join('');\n\t}\n\t\n\tfunction prefix(string){\n\
    \t\t// return the substring that comes before the palindromic suffix of the string\n\
    \t\t// return null if the string is a palindrome.\n\t\tvar prefix = '';\n\t\t\
    var string = string.split('');\n\t\twhile(!is_palindrome(string)){\n\t\t\tprefix\
    \ += string.shift();\n\t\t}\n\t\treturn prefix;\n\t}\n\t\n\treturn string + prefix(string).split('').reverse().join('');\n\
    }\n", "\tvar rev = reverse(string),\n\t\ti = 0,\n\t\tlength = string.length;\n\
    \t\n\t// Find the palindromic suffix\n\tfor(;i<length;i++){\n\t\tif(rev.slice(i)\
    \ === string.slice(0,length-i)){\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n\tvar new_str = string + reverse(string.slice(0,length-i));\n\treturn\
    \ new_str;\n}\n", "    var palindrome = '';\n    var length = string.length;\n\
    \    var reverse_index = length - 1;\n    var mirror = '';\n    for(var i = 0;\
    \ i < length; i++){\n        palindrome += string[i];\n        mirror = string[reverse_index]\
    \ + mirror;\n        if(palindrome == mirror){\n            palindrome = string\
    \ + mirror;\n            return palindrome;\n        }\n        reverse_index--;\n\
    \    }\n    return palindrome;\n}\n", "\t//We are assuming the string has at least\
    \ 1 character.\n\tvar result = string;\n\tvar sub_string = longest_postfix_palindrome(string);\n\
    \tif(sub_string.length < string.length){\n\t\tresult = string + reverse(string.substring(0,\
    \ string.length - sub_string.length));\n\t}\n\treturn result;\n}\n", "  let reverse_str\
    \ = reverse(string);\n  let palindrome = find_palindrome(string, reverse_str);\n\
    \  let prefix = string.substring(palindrome.length);\n  return reverse(prefix)\
    \ + string;\n}\n", "    var longest_postfix = find_longest_palindromic_suffix(string);\n\
    \    var prefix = string.substring(0, string.length - longest_postfix.length);\n\
    \    return prefix + string + reverse(prefix);\n}\n", "    let palindrome_postfix\
    \ = find_palindrome_postfix(string);\n    if(palindrome_postfix === ''){\n   \
    \     return string.split('').reverse().join('') + string;\n    }\n    let prefix\
    \ = string.substring(0, string.length - palindrome_postfix.length);\n    return\
    \ prefix.split('').reverse().join('') + string;\n}\n", "    // First, reverse\
    \ the string.\n    // Then, find the longest postfix that is also a prefix of\
    \ reversed string.\n    // This postfix is longest palindromic suffix in the original\
    \ string.\n    var reversed = string.split('').reverse().join('');\n    var longest_suffix\
    \ = kmp(string, reversed);\n    // Append to the end of the string reverse of\
    \ a prefix that comes before the palindromic suffix.\n    var prefix = string.substring(0,\
    \ string.length - longest_suffix);\n    return string + prefix.split('').reverse().join('');\n\
    }\n\nvar string = 'abc';\nvar palindrome = make_palindrome(string);", "    var\
    \ prefix = \"\";\n    var palindrome = \"\";\n    var suffix = \"\";\n    var\
    \ length = string.length;\n    var i = length - 1;\n    for(; i >= 0; i--){\n\
    \        if(is_palindrome(string.substring(i))){\n            break;\n       \
    \ }\n    }\n    prefix = string.substring(0, i);\n    return reverse(prefix) +\
    \ string;\n}\n", "    var str_arr = string.split('');\n    var longest_palindrome\
    \ = find_longest_palindrome(str_arr);\n    var prefix = str_arr.slice(0, str_arr.length\
    \ - longest_palindrome.length);\n    prefix.reverse();\n    str_arr = str_arr.concat(prefix);\n\
    \    return str_arr.join('');\n}\n", "  var len = string.length;\n  var res =\
    \ string;\n  if(len <= 1){\n    return res;\n  }\n  var suffix = string.slice(0);\n\
    \  suffix = suffix.split(\"\").reverse().join(\"\");\n  var prefix = string.slice(0);\n\
    \  var prefixlen = prefix.length;\n  for(var i = 0; i < prefixlen; i++){\n   \
    \ prefix = prefix.slice(1);\n    if(prefix === suffix.slice(0, prefixlen - i)){\n\
    \      res = res + suffix.slice(prefixlen - i);\n      break;\n    }\n  }\n  return\
    \ res;\n}\n", "    var prefix_length = longest_common_postfix(string+'$'+reverse(string)).length;\n\
    \    var prefix = string.substring(0, string.length - prefix_length);\n    return\
    \ string + reverse(prefix);\n}\n", "    function reverse(string){\n        return\
    \ string.split('').reverse().join('');\n    }\n    var prefix_length = 0;\n  \
    \  var possible_palindrome_length = string.length - 1;\n    while(possible_palindrome_length\
    \ > 0){\n        if(string.slice(0, possible_palindrome_length) === reverse(string.slice(string.length\
    \ - possible_palindrome_length))){\n            prefix_length = possible_palindrome_length;\n\
    \            break;\n        }\n        possible_palindrome_length--;\n    }\n\
    \    return string + reverse(string.slice(0, string.length - prefix_length));\n\
    }", "  let n = string.length;\n  if(n <= 1) return string;\n  let i = 0;\n  while(i\
    \ < n){\n    if(is_palindrome(string.substring(i))){\n      break;\n    }\n  \
    \  i++;\n  }\n  let prefix = string.substring(0, i);\n  let rev_prefix = prefix.split(\"\
    \").reverse().join(\"\");\n  return string + rev_prefix;\n}\n", "    let len =\
    \ string.length;\n    let flip = '';\n    let is_palindrome = false;\n    let\
    \ i = 1;\n    while (!is_palindrome && i <= len){\n        is_palindrome = string.substring(len\
    \ - i) === string.substring(0, i).split('').reverse().join('');\n        if (is_palindrome){\n\
    \            flip = string.substring(i);\n        }\n        i++;\n    }\n   \
    \ return string + flip.split('').reverse().join('');\n}\n", "  let reversed_string\
    \ = string.split('').reverse().join('');\n  let new_string = reversed_string +\
    \ string;\n  let prefix_suffix_length = new_string.length / 2;\n  let index =\
    \ 0;\n  while(index < prefix_suffix_length){\n    let test_string = new_string.substring(index,\
    \ new_string.length - index);\n    if(test_string.length > 1 && is_palindrome(test_string)){\n\
    \      break;\n    }\n    index++;\n  }\n  let prefix = new_string.substring(0,\
    \ index);\n  let suffix = new_string.substring(index, new_string.length - index);\n\
    \  return string + prefix.split('').reverse().join('');\n}\n", "    var max_size\
    \ = 1;\n    var max_index = 0;\n    var temp = [];\n    var offset = 0;\n    for(var\
    \ i = 1; i < string.length; i++){\n        offset = 1;\n        while(i - offset\
    \ >= 0 &&\n              i + offset < string.length &&\n              string[i\
    \ - offset] == string[i + offset]){\n            offset++;\n        }\n      \
    \  if(offset > max_size){\n            max_size = offset;\n            max_index\
    \ = i;\n        }\n    }\n    //reverse the prefix\n    for(var i = max_index\
    \ - max_size + 1; i < max_index; i++){\n        temp.push(string[i]);\n    }\n\
    \    for(var i = temp.length - 1; i >= 0; i--){\n        string += temp[i];\n\
    \    }\n    return string;\n}\n\nvar string = 'geeks';", "\tvar length = string.length;\n\
    \tif(length <= 1){\n\t\treturn string;\n\t}\n\t//Returns a longest palindromic\
    \ substring that begins at index 0.\n\tfunction get_postfix_longest_palindrome(string){\n\
    \t\tvar length = string.length;\n\t\tif(length <= 1){\n\t\t\treturn string;\n\t\
    \t}\n\t\tvar index = 1;\n\t\tfor(var i = length - 1; i >= 0; i--){\n\t\t\tif(string[i]\
    \ == string[0]){\n\t\t\t\tvar found = true;\n\t\t\t\tfor(var j = 0; j < (i + 1)\
    \ / 2; j++){\n\t\t\t\t\tif(string[j] != string[i - j]){\n\t\t\t\t\t\tfound = false;\n\
    \t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(found){\n\t\t\t\t\tindex\
    \ = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn string.substring(0,\
    \ index);\n\t}\n\t//Returns a reversed string from the source starting from the\
    \ start index.\n\tfunction get_reversed_string(string, start){\n\t\tvar result\
    \ = \"\";\n\t\tfor(var i = string.length - 1; i >= start; i--){\n\t\t\tresult\
    \ += string[i];\n\t\t}\n\t\treturn result;\n\t}\n\tvar palindrome = get_postfix_longest_palindrome(string);\n\
    \treturn string + get_reversed_string(string, palindrome.length);\n}\n", "   \
    \ var reverse = '';\n    for(var i = string.length-1; i >= 0; i--){\n        reverse\
    \ += string[i];\n    }\n    var longest = '';\n    for(var i = string.length;\
    \ i >= 0; i--){\n        if(string.slice(0,i) == reverse.slice(string.length-i)){\n\
    \            longest = string.slice(0,i);\n            break;\n        }\n   \
    \ }\n    return string+reverse.slice(longest.length,reverse.length);\n}", "  \
    \  var longest_postfix = find_longest_palindromic_suffix(string);\n    return\
    \ reverse(string.substring(0,string.length-longest_postfix.length)) + string;\n\
    }\n", "    var suffix = find_longest_palindromic_suffix(string);\n    var prefix\
    \ = reverse(string.substring(0, string.length - suffix.length));\n    return prefix\
    \ + string;\n}\n", "\t//First find the longest palindromic suffix.\n\tvar reverse\
    \ = new String(string);\n\treverse = reverse.split(\"\").reverse().join(\"\");\n\
    \tvar suffix = longest_common_substring(string, reverse);\n\t//Find the reverse\
    \ of the prefix.\n\tvar prefix = string.substring(0, string.length - suffix.length);\n\
    \tprefix = new String(prefix);\n\tprefix = prefix.split(\"\").reverse().join(\"\
    \");\n\treturn prefix + string;\n}\n", "    let palindrome_end_index = find_palindrome_end_index(string);\n\
    \    let prefix = string.substring(0, string.length - palindrome_end_index - 1);\n\
    \    return reverse(prefix) + string;\n}\n", "    var i = 1;\n    var is_palindrome\
    \ = false;\n    while(!is_palindrome){\n        is_palindrome = true;\n      \
    \  for(var j = 0; j < Math.floor(i/2); j++){\n            if(string[string.length\
    \ - i + j] != string[string.length - i + i - j - 1]){\n                is_palindrome\
    \ = false;\n                break;\n            }\n        }\n        if(is_palindrome){\n\
    \            break;\n        }\n        i++;\n    }\n    return string + string.substring(0,\
    \ string.length - i).split(\"\").reverse().join(\"\");\n}\n", "    // Finds longest\
    \ palindromic substring of supplied string.\n    function longest_palindrome(string){\n\
    \        // Substring of original string, characters 0 to i, is a palindrome.\n\
    \        function is_palindrome(i){\n            // If the second half of a string\
    \ comes before the first half, then it is a palindrome.\n            return string.substring(0,\
    \ i+1) === string.substring(i+1).split(\"\").reverse().join(\"\");\n        }\n\
    \        // Try to find a palindrome of length n.\n        function search(n){\n\
    \            // Look at each substring of the right length.\n            for(var\
    \ i = 0; i < string.length - n + 1; i++){\n                // If it is a palindrome,\
    \ we are done.\n                if(is_palindrome(i + n - 1)){\n              \
    \      return string.substring(i, i + n);\n                }\n            }\n\
    \            // No palindrome, search further.\n            return search(n+1);\n\
    \        }\n        // Start search at length 1 (empty string is a palindrome).\n\
    \        return search(1);\n    }\n    // Reverse a string.\n    function reverse(string){\n\
    \        return string.split(\"\").reverse().join(\"\");\n    }\n    // Prefix\
    \ is everything before the palindromic suffix.\n    var prefix = string.substring(0,\
    \ string.length - longest_palindrome(string).length);\n    // Append reversed\
    \ prefix to the end of the string.\n    return string + reverse(prefix);\n}",
  "\tvar prefix = string.split('').reverse().join('');\n\treturn string + prefix;\n\
    }\n", "    var reverse_string = reverse(string);\n    var longest_substring =\
    \ longest_substring_length(string, reverse_string);\n    return string + reverse(string.substring(0,string.length\
    \ - longest_substring));\n}\n", "    // Some trivial cases.\n    if(string.length\
    \ == 0){\n        return \"\";\n    }\n    if(string.length == 1){\n        return\
    \ string;\n    }\n    // Reverse of a string.\n    var reversed = string.split(\"\
    \").reverse().join(\"\");\n    // A function that constructs reversed string on\
    \ a fly.\n    var reversed_generator = function(){\n        var index = string.length\
    \ - 1;\n        return function(){\n            return reversed[index--];\n  \
    \      }\n    }();\n    // Go through every suffix of a string and check if it\
    \ is a palindrome.\n    for(var i = string.length; i >= 0; i--){\n        var\
    \ is_palindrome = true;\n        for(var j = 0; j < string.length - i; j++){\n\
    \            if(string[i + j] != reversed_generator()){\n                is_palindrome\
    \ = false;\n                break;\n            }\n        }\n        if(is_palindrome){\n\
    \            return string + reversed.substring(0, string.length - i);\n     \
    \   }\n    }\n}\n\nvar test = require('tape');\n\ntest('make_palindrome', function(t){\n\
    \    t.plan(3);\n    t.equal(make_palindrome(\"\"), \"\");\n    t.equal(make_palindrome(\"\
    a\"), \"a\");\n    t.equal(make_palindrome(\"aa\"), \"aa\");\n    t.equal(make_palindrome(\"\
    ab\"), \"aba\");\n    t.equal(make_palindrome(\"aaa\"), \"aaa\");\n    t.equal(make_palindrome(\"\
    aab\"), \"aba\");\n    t.equal(make_palindrome(\"abacaba\"), \"abacaba\");\n \
    \   t.equal(make_palindrome(\"abcdef\"), \"abccfefb\");\n});", "  var test_string\
    \ = string + \"X\" + string.split(\"\").reverse().join(\"\");\n  //console.log(test_string);\n\
    \  //console.log(kmp(test_string))\n  var kmp_array = kmp(test_string);\n  //console.log(kmp_array);\n\
    \  var tail_length = kmp_array[kmp_array.length - 1];\n  var prefix = string.substring(0,\
    \ string.length - tail_length);\n  return prefix.split(\"\").reverse().join(\"\
    \") + string;\n}\n", "  //find a longest palindromic suffix of a string\n  function\
    \ find_palindromic_suffix(s){\n    for(var len = s.length; len >= 1; len--){\n\
    \      var front = s.substring(0, len);\n      var back = front.split(\"\").reverse().join(\"\
    \");\n      if(front == back){\n        return back;\n      }\n    }\n    return\
    \ \"\";\n  }\n  //find a longest palindromic prefix of a string\n  function find_palindromic_prefix(s){\n\
    \    for(var len = s.length; len >= 1; len--){\n      var back = s.substring(s.length\
    \ - len, s.length);\n      var front = back.split(\"\").reverse().join(\"\");\n\
    \      if(front == back){\n        return front;\n      }\n    }\n    return \"\
    \";\n  }\n  //find a longest palindromic substring\n  function find_palindromic_substring(s){\n\
    \    var prefix = find_palindromic_prefix(s);\n    var suffix = find_palindromic_suffix(s);\n\
    \    if(prefix.length > suffix.length){\n      return prefix;\n    }\n    return\
    \ suffix;\n  }\n  var palindromic_suffix = find_palindromic_suffix(string);\n\
    \  var palindromic_prefix = find_palindromic_prefix(string);\n  var palindromic_substring\
    \ = find_palindromic_substring(string);\n  if(palindromic_suffix.length > palindromic_prefix.length){\n\
    \    var prefix = string.substring(0, string.length - palindromic_suffix.length);\n\
    \    var result = string + prefix.split(\"\").reverse().join(\"\");\n    return\
    \ result;\n  }\n  if(palindromic_prefix.length > palindromic_suffix.length){\n\
    \    var suffix = string.substring(palindromic_prefix.length, string.length);\n\
    \    var result = suffix.split(\"\").reverse().join(\"\") + string;\n    return\
    \ result;\n  }", "  //Find the longest palindromic suffix\n  var long_suffix =\
    \ longest_palindromic_suffix(string)\n  //Reverse the prefix that comes before\
    \ the suffix.\n  var rev_prefix = string.substring(0,string.length-long_suffix.length).split(\"\
    \").reverse().join(\"\")\n  //Append the prefix to the end of the string\n  return\
    \ string+rev_prefix\n}\n", "  let reverse_string = string.split('').reverse().join('');\n\
    \  let palindrome_string = \"\";\n  let substr = string;\n  for(let i = 0; i <\
    \ string.length; i++){\n    substr = substr.substring(1);\n    if(!string.endsWith(substr)){\n\
    \      if(reverse_string.includes(substr)){\n        let reversed_string = reverse_string.split('').reverse().join('');\n\
    \        let ind = reversed_string.indexOf(substr);\n        let new_str = reversed_string.substring(0,\
    \ ind);\n        palindrome_string = new_str + string;\n        break;\n     \
    \ }\n    }\n  }\n  if(palindrome_string === \"\"){\n    palindrome_string = reverse_string\
    \ + string;\n  }\n  return palindrome_string;\n}\n", "    var longestPalindrome\
    \ = longestPalindromePostfix(string);\n    var stringToAppend = reverseString(string.substring(0,string.length-longestPalindrome.length));\n\
    \    return string+stringToAppend;\n}\n", "    // First we reverse the original\
    \ string.\n    var reverse = string.split('').reverse().join('');\n    // We append\
    \ the string to itself.\n    var combined = string + \"*\" + reverse;\n    //\
    \ Then, we use Z algorithm to compute the maximum common prefix of the combined\
    \ string\n    // with itself.\n    var z_array = z_algorithm(combined);\n    //\
    \ Then, we check the z-array for the longest palindromic postfix.\n    var max_palindrome_length\
    \ = 0;\n    var max_palindrome_start = 0;\n    for(var i = 1; i < z_array.length;\
    \ i++){\n        if(z_array[i] > max_palindrome_length){\n            max_palindrome_length\
    \ = z_array[i];\n            max_palindrome_start = i;\n        }\n    }\n   \
    \ // Finally, we make a new prefix of the string that comes after the palindromic\
    \ suffix.\n    var prefix = string.substring(max_palindrome_start + max_palindrome_length);\n\
    \    var result = prefix + string;\n    return result;\n}\n", "    var rev_string\
    \ = string.split('').reverse().join('');\n    var rev_prefix = find_postfix(string);\n\
    \    var string_prefix = rev_prefix.split('').reverse().join('');\n    return\
    \ string + string_prefix;\n}\n", "    if(string.length <= 1)\n        return string;\n\
    \    let end = string.length - 1;\n    let i = 0;\n    while(i <= end && string[i]\
    \ === string[end]){\n        i++;\n        end--;\n    }\n    if(i > end)\n  \
    \      return string;\n    let first_part = string.substring(0, end + 1);\n  \
    \  return first_part.split(\"\").reverse().join(\"\") + make_palindrome(string.substring(0,\
    \ end)) + first_part;\n}\n", "    // Find the longest palindromic suffix\n   \
    \ var suffix_length = get_longest_palindromic_suffix(string);\n    var prefix\
    \ = string.substring(0, string.length - suffix_length);\n    // Reverse the prefix\
    \ and append it to the end of the string\n    var reversed_prefix = prefix.split(\"\
    \").reverse().join(\"\");\n    return string + reversed_prefix;\n}", "    let\
    \ palindrome = string.slice(0);\n    let size = palindrome.length;\n    let prefix\
    \ = \"\";\n    for(let i = 0; i < size; i++){\n        let prefix_size = size\
    \ - i;\n        let postfix_size = i;\n        if(is_palindrome(palindrome.slice(0,\
    \ prefix_size))){\n            palindrome += reverse(palindrome.slice(prefix_size));\n\
    \            break;\n        }\n    }\n    return palindrome;\n}\n", "    var\
    \ i;\n    var reversed_string = string.split(\"\").reverse().join(\"\");\n   \
    \ for(i = 0; i < string.length; i++){\n        if(string.slice(i) == reversed_string.slice(0,\
    \ string.length - i)){\n            return string + reversed_string.slice(string.length\
    \ - i);\n        }\n    }\n}\n\nmake_palindrome(\"helloo\"); // should be \"olleholloo\"",
  "    var n = string.length;\n    var T = make_table(string);\n    var longest_palindrome_pos\
    \ = T[n];\n    var palindrome_prefix = string.substring(0, n - longest_palindrome_pos);\n\
    \    var palindrome_prefix_reversed = palindrome_prefix.split(\"\").reverse().join(\"\
    \");\n    return string + palindrome_prefix_reversed;\n}\n\nvar string = \"abacab\"\
    ;\nprint(make_palindrome(string));", "\t//check if string is a palindrome\n\t\
    if(is_palindrome(string)){\n\t\treturn string;\n\t}\n\telse{\n\t\t//find longest\
    \ postfix that is a palindrome\n\t\tvar palindrome_suffix = find_palindrome_postfix(string);\n\
    \t\t//add reverse of prefix before palindrome_suffix to the end of string\n\t\t\
    string += reverse(string.substring(0, string.length - palindrome_suffix.length));\n\
    \t\treturn string;\n\t}\n}\n", "    var middle = string.length >> 1;\n    var\
    \ shift = 1;\n    var done = false;\n    var from, to;\n    // var substr;\n \
    \   var is_palindrome;\n    for(var i = 0; i < middle; i++){\n        from = middle\
    \ - i;\n        to = middle + shift + i;\n        // substr = string.substring(from,\
    \ to);\n        is_palindrome = true;\n        for(var j = 0; j < substr.length\
    \ >> 1; j++){\n            if(substr[j] !== substr[substr.length - j - 1]){\n\
    \                is_palindrome = false;\n                break;\n            }\n\
    \        }\n        if(is_palindrome){\n            done = true;\n           \
    \ break;\n        }\n    }\n    if(!done){\n        //todo: go through the whole\
    \ loop to detect a case when the string itself is a palindrome.\n        return\
    \ null;\n    }\n    var suffix = string.substring(0, from);\n    return string\
    \ + suffix.split('').reverse().join('');\n}\n", "  var longest_palindrome = '';\n\
    \  for(var i = 0; i < string.length; i++){\n    for(var j = 0; j <= i; j++){\n\
    \      var prefix = string.substring(0, j);\n      var postfix = string.substring(i,\
    \ string.length);\n      if(prefix === reverse(postfix)){\n        if(prefix.length\
    \ > longest_palindrome.length){\n          longest_palindrome = prefix;\n    \
    \    }\n      }\n    }\n  }\n  return string + reverse(string.substring(0, string.length\
    \ - longest_palindrome.length));\n}\n", "  if(string === null || string.length\
    \ === 0){\n    return \"\";\n  }\n  if(string.length === 1){\n    return string;\n\
    \  }\n  var prefix_end = string.length - 1;\n  while(prefix_end >= 0){\n    if(string[prefix_end]\
    \ === string[prefix_end - 1]){\n      prefix_end--;\n    } else {\n      break;\n\
    \    }\n  }\n  var is_palindrome = true;\n  while(prefix_end >= 0){\n    var k\
    \ = 0;\n    while(prefix_end - k >= 0 && string.length - 1 - k >= 0){\n      if(string[prefix_end\
    \ - k] !== string[string.length - 1 - k]){\n        is_palindrome = false;\n \
    \       break;\n      }\n      k++;\n    }\n    if(is_palindrome){\n      break;\n\
    \    }\n    prefix_end--;\n    is_palindrome = true;\n  }\n  return string + reverse(string.substring(0,\
    \ prefix_end));\n}\n", "  let longest_palindrome = find_longest_palindrome(string);\n\
    \  //If supplied string is a palindrome, we are done.\n  if(longest_palindrome\
    \ === string) return string;\n  //Otherwise, append reverse of a string before\
    \ the palindromic suffix.\n  let prefix = string.substring(0, string.length -\
    \ longest_palindrome.length);\n  return prefix.split('').reverse().join('') +\
    \ string;\n}\n", "\tfor(var i = 0; i < string.length; i++){\n\t\tvar sub = string.substring(i);\n\
    \t\tif(is_palindrome(sub)){\n\t\t\treturn string + reverse(string.substring(0,\
    \ i));\n\t\t}\n\t}\n}\n", "  var palindrome = string;\n  var reverse_string =\
    \ string.split('').reverse().join('');\n  var length = string.length;\n  var suffix,\
    \ suffix_length, prefix, prefix_length;\n  for(var i = 0; i < length; i++){\n\
    \    suffix = string.substring(i, length);\n    suffix_length = suffix.length;\n\
    \    prefix = reverse_string.substring(0, suffix_length);\n    if(suffix === prefix){\n\
    \      palindrome = reverse_string.substring(suffix_length) + palindrome;\n  \
    \    break;\n    }\n  }\n  return palindrome;\n}\n", "    var i = 0;\n    var\
    \ postfix_length = 0;\n    while(i < string.length){\n        var match = match_palindrome(string,\
    \ 0, i);\n        if(match){\n            postfix_length = i + 1;\n        }\n\
    \        i++;\n    }\n    var s = string.substring(0, string.length - postfix_length);\n\
    \    return s.split(\"\").reverse().join(\"\") + string;\n}\n", "\tvar rev = string.split('').reverse().join('');\n\
    \t//The algorithm to find a longest palindromic postfix.\n\tfor(var i = 0; i <\
    \ string.length; i++){\n\t\tif(string.substr(i) == rev.substr(0, string.length\
    \ - i)){\n\t\t\treturn string + rev.substr(string.length - i);\n\t\t}\n\t}\n}\n",
  "\tvar preffix_length = 0;\n\twhile(!is_palindrome(string.substring(preffix_length,\
    \ string.length))){\n\t\tpreffix_length++;\n\t}\n\tvar preffix = string.substring(0,\
    \ preffix_length);\n\tvar postfix = string.substring(preffix_length, string.length);\n\
    \treturn postfix + (preffix.split(\"\").reverse().join(\"\"));\n}\n", "    var\
    \ reversed = string.split('').reverse().join('');\n    var prefix = string.substring(0,\
    \ string.length - (string.length / 2));\n    var suffix = reversed.substring(0,\
    \ reversed.length - (reversed.length / 2));\n    return string + reversed.substring(reversed.length\
    \ - (reversed.length / 2));\n}\n", "\tlet left_idx = 0;\n\tlet right_idx = string.length\
    \ - 1;\n\tlet suffix_palindrome_length = 0;\n\tlet prefix_palindrome_length =\
    \ 0;\n\t\n\t//Find the longest palindromic suffix\n\twhile(left_idx < right_idx){\n\
    \t\t//Suffix is a palindrome\n\t\tif(string[left_idx] === string[right_idx]){\n\
    \t\t\tsuffix_palindrome_length++;\n\t\t\tleft_idx++;\n\t\t\tright_idx--;\n\t\t\
    }\n\t\telse{\n\t\t\tleft_idx = 0;\n\t\t\tright_idx--;\n\t\t}\n\t}\n\t\n\t//No\
    \ palindromic suffix\n\tif(suffix_palindrome_length === 0){\n\t\treturn reverse(string)\
    \ + string;\n\t}\n\t\n\t//Find palindromic prefix\n\tleft_idx = 0;\n\tright_idx\
    \ = string.length - 1;\n\twhile(left_idx < right_idx){\n\t\t//Prefix is a palindrome\n\
    \t\tif(string[left_idx] === string[right_idx]){\n\t\t\tprefix_palindrome_length++;\n\
    \t\t\tleft_idx++;\n\t\t\tright_idx--;\n\t\t}\n\t\telse{\n\t\t\tright_idx = string.length\
    \ - 1;\n\t\t\tleft_idx++;\n\t\t}\n\t}\n\t\n\t//No palindromic prefix\n\tif(prefix_palindrome_length\
    \ === 0){\n\t\treturn string + reverse(string);\n\t}\n\t\n\t//Palindromic prefix\
    \ and suffix. Locate the longest one.\n\tif(prefix_palindrome_length > suffix_palindrome_length){\n\
    \t\treturn string + reverse(string.substring(0, string.length - prefix_palindrome_length));\n\
    \t}\n\telse{\n\t\treturn reverse(string.substring(suffix_palindrome_length)) +\
    \ string;\n\t}\n}\n", "    var _string = string;\n    var _lps = lps(string);\n\
    \    var rev_prefix = _string.substring(0, _string.length - _lps);\n    return\
    \ rev_prefix.split(\"\").reverse().join(\"\") + _string;\n}\n", "  var idx = 1;\n\
    \  var len = string.length;\n  //First find the longest palindromic postfix.\n\
    \  while( idx <= len ){\n    var postfix = string.substring(len - idx);\n    if(\
    \ is_palindrome(postfix) ){\n      break;\n    }\n    idx++;\n  }\n  var prefix\
    \ = string.substring(0, len - idx);\n  var reversed_prefix = reverse(prefix);\n\
    \  return reversed_prefix + string;\n}\n", "    var string_reverse = string.split('').reverse().join('');\n\
    \    var str = string + '#' + string_reverse;\n    var p = compute_prefix_function(str);\n\
    \    var palindrome_suffix = str.substring(0, p[p.length - 1] + 1);\n    var palindrome_prefix\
    \ = palindrome_suffix.split('').reverse().join('');\n    return palindrome_prefix\
    \ + string;\n}\n", "\tlet k = 0;\n\tlet pal = \"\";\n\tfor(let i = string.length\
    \ - 1; i >= 0; i--){\n\t\tif(is_palindrome(string.substring(i, string.length))){\n\
    \t\t\tk = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(let i = k - 1; i >= 0; i--){\n\t\
    \tpal += string[i];\n\t}\n\treturn string + pal;\n}\n", "  let found_palindrome\
    \ = false;\n  let palindrome = \"\";\n  let tail = \"\";\n  let prefix = \"\"\
    ;\n  let pre_prefix = \"\";\n  if(is_palindrome(string)){\n    console.log(string);\n\
    \    return;\n  }\n  for(let i = 0; i < string.length; i++){\n    //I always want\
    \ to add a new tail, so add it now.\n    tail += string[i];\n    //If there is\
    \ a palindrome, add its reverse to the prefix.\n    if(is_palindrome(tail)){\n\
    \      //I need to add the characters that are before the palindrome\n      //to\
    \ the new prefix. \n      prefix = tail + pre_prefix;\n      found_palindrome\
    \ = true;\n    }\n    //If there is no palindrome, add the character to the prefix\n\
    \    else{\n      pre_prefix += string[i];\n    }\n  }\n  let result = string\
    \ + reverse(prefix);\n  console.log(result);\n}\n", "    let end_position = string.length;\n\
    \    let start_position = 0;\n    // loop through all possible palindromes that\
    \ may be constructed.\n    while(start_position < end_position){\n        // Check\
    \ if a prefix at a given position is a palindrome.\n        if(is_palindrome(string,\
    \ start_position, end_position)){\n            // If so, return the shortest possible\
    \ palindrome by appending the reverse of the prefix to the string.\n         \
    \   return string + reverse(string.substring(0, start_position));\n        }\n\
    \        start_position++;\n    }\n    // If no palindrome found in the string,\
    \ return null.\n    return null;\n}", "    if(string === string.split('').reverse().join(''))\
    \ return string;\n    var i = 0;\n    var j = string.length-1;\n    while(i<j\
    \ && string[i] === string[j]){\n        i++;\n        j--;\n    }\n    if(i===j)\
    \ return string;\n    if(i===0) return string[j]+make_palindrome(string.substring(0,j))+string[j];\n\
    \    if(j===string.length-1) return string[i]+make_palindrome(string.substring(i))+string[i];\n\
    \    return string[i]+make_palindrome(string.substring(i,j+1))+string[i];\n}\n",
  "\tvar reversed_string = string.split(\"\").reverse().join(\"\");\n\tvar longest_pali_suffix\
    \ = longest_palindrome_suffix(string);\n\tvar prefix = string.substring(0, string.length\
    \ - longest_pali_suffix.length);\n\treturn reversed_string + prefix;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
