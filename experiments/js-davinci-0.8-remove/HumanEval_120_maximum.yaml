name: HumanEval_120_maximum
language: js
prompt: "//Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// Example\
  \ 2:\n// Example 3:\n// Note:\n// 1. The length of the array will be in the range\
  \ of [1, 1000].\n// 2. The elements in the array will be in the range of [-1000,\
  \ 1000].\n// 3. 0 <= k <= len(arr)\nfunction maximum(arr, k){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = maximum;\n  assert.deepEqual(candidate([-3, -4, 5], 3),[-4, -3, 5]);\n  assert.deepEqual(candidate([4,\
  \ -4, 4], 2),[4, 4]);\n  assert.deepEqual(candidate([-3, 2, 1, 2, -1, -2, 1], 1),[2]);\n\
  \  assert.deepEqual(candidate([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123]);\n\
  \  assert.deepEqual(candidate([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20]);\n  assert.deepEqual(candidate([5,\
  \ 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15]);\n  assert.deepEqual(candidate([-1,\
  \ 0, 2, 5, 3, -10], 2),[3, 5]);\n  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);\n\
  \  assert.deepEqual(candidate([4, -4], 2),[-4, 4]);\n  assert.deepEqual(candidate([-10,\
  \ 10], 2),[-10, 10]);\n  assert.deepEqual(candidate([1, 2, 3, -23, 243, -400, 0],\
  \ 0),[]);\n}\n\ntest();"
completions: ["    arr.sort((a,b)=>b-a);\n    return arr.slice(0,k);\n}", "\tvar answer\
    \ = []\n\tfor(var i = 0; i < k; i++){\n\t\tvar max = -10000\n\t\tvar maxIndex\
    \ = 0\n\t\tfor(var j = 0; j < arr.length; j++){\n\t\t\tif(arr[j] > max){\n\t\t\
    \t\tmax = arr[j]\n\t\t\t\tmaxIndex = j\n\t\t\t}\n\t\t}\n\t\tanswer.push(max)\n\
    \t\tarr.splice(maxIndex, 1)\n\t}\n\treturn answer\n}\n", "    arr.sort((a,b)=>b-a);\n\
    \    return arr.slice(0,k);\n}", "\tconst maxArr = [];\n\tfor(let i = 0; i < k;\
    \ i++){\n\t\tlet max = -1001;\n\t\tlet index = -1;\n\t\tfor(let j = 0; j < arr.length;\
    \ j++){\n\t\t\tif(arr[j] > max){\n\t\t\t\tmax = arr[j];\n\t\t\t\tindex = j;\n\t\
    \t\t}\n\t\t}\n\t\tmaxArr.push(max);\n\t\tarr.splice(index, 1);\n\t}\n\treturn\
    \ maxArr;\n}", "    if(k > arr.length)\n        throw \"k is too large\";\n  \
    \  var queue = new PriorityQueue(arr.length, { comparator: function(x, y){ return\
    \ y-x; }});\n    arr.forEach(element => {\n        queue.offer(element);\n   \
    \ });\n    var result = [];\n    for(var i = 0; i < k; i++){\n        result.push(queue.poll());\n\
    \    }\n    return result;\n}\n", "    if(k == 0) return [];\n    if(k == arr.length)\
    \ return arr;\n    // var arr2 = arr.map(a => a);\n    // return arr2.sort(function(a,\
    \ b){return b-a}).slice(0, k);\n    var sorted = quicksort(arr);\n    return sorted.slice(0,\
    \ k);\n}\n", "    arr.sort((a,b)=>b-a)\n    return arr.slice(0,k)\n}\n", "   \
    \ let result = [];\n    for(let i = 0; i < k; i++){\n        let max = Math.max(...arr);\n\
    \        result.push(max);\n        arr.splice(arr.indexOf(max), 1);\n    }\n\
    \    return result;\n}", "    let res = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        while(res.length && arr[i] > res[res.length - 1] && res.length\
    \ + arr.length - i > k){\n            res.pop();\n        }\n        res.push(arr[i]);\n\
    \    }\n    return res.slice(0, k);\n}\n\nlet arr = [1, 5, 3, 2, 4, 1, 5, 2, 1,\
    \ 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3,\
    \ 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4,\
    \ 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5,\
    \ 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1,\
    \ 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3,\
    \ 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4,\
    \ 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5,\
    \ 2, 1, 5, 3, 2, 4, 1, 5, 2, 1, 5, 3, 2, 4, 1, 5", "    if(k <= 0 || k > arr.length){\n\
    \        return;\n    }\n    //quick select\n    //TC : avg case O(n)\n    //SC\
    \ : O(1)\n    let s = 0;\n    let e = arr.length - 1;\n    let pivot = partition(arr,\
    \ s, e);\n    while(pivot != k - 1){\n        if(pivot > k - 1){\n           \
    \ e = pivot - 1;\n        }else{\n            s = pivot + 1;\n        }\n    \
    \    pivot = partition(arr, s, e);\n    }\n    return arr.slice(0, k);\n}\n",
  "\t// if k < 0 or k > arr.length return empty array\n\tif(k < 0 || k > arr.length)\
    \ return [];\n\tlet maxes = [];\n\tlet currentMax;\n\tfor(let i = 0; i < k; i++){\n\
    \t\tcurrentMax = arr[i];\n\t\tfor(let j = i; j < arr.length; j++){\n\t\t\tif(arr[j]\
    \ > currentMax){\n\t\t\t\tcurrentMax = arr[j];\n\t\t\t}\n\t\t}\n\t\tmaxes.push(currentMax);\n\
    \t\tarr[arr.indexOf(currentMax)] = arr[i];\n\t\tarr[i] = currentMax;\n\t}\n\t\
    return maxes;\n}\n", "    let unique = Array.from(new Set(arr));\n    unique.sort((a,b)\
    \ => b-a);\n    let result = [];\n    for(let i = 0; i < k; i++){\n        result.push(unique[i]);\n\
    \    }\n    return result;\n}\n", "    const ans = []\n    for(let i = 0; i <\
    \ arr.length; i++){\n        while(ans.length && ans[ans.length - 1] < arr[i]\
    \ && ans.length + arr.length - i > k){\n            ans.pop()\n        }\n   \
    \     if(ans.length < k){\n            ans.push(arr[i])\n        }\n    }\n  \
    \  return ans\n}", "    if(arr.length == 0 || k == 0) return [];\n    if(arr.length\
    \ <= k) return arr.sort((a,b) => a - b);\n    const result = [];\n    for(let\
    \ i = 0; i < k; i++){\n        const temp = [arr[i]];\n        let j = i + 1;\n\
    \        while(j < arr.length){\n            if(arr[j] > temp[0]){\n         \
    \       temp.unshift(arr[j]);\n            }\n            j++;\n        }\n  \
    \      result.push(temp.pop());\n    }\n    return result;\n}", "  if(arr.length\
    \ === 0) return [];\n  if(arr.length <= k) return arr.sort((a,b) => b-a);\n  const\
    \ sorted = [];\n  const max = Math.max(...arr);\n  while(k > 0){\n    let temp\
    \ = max;\n    const index = arr.indexOf(temp);\n    arr.splice(index, 1);\n  \
    \  sorted.push(temp);\n    k--;\n  }\n  return sorted;\n}\n\nconst arr = [3,4,5,6,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4",
  "  // Solution 1: sort and output k\n  return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n}\n", "    if(arr === null || arr.length === 0 || k === 0)\n        return\
    \ [];\n    let n = arr.length;\n    for(let i = Math.floor(k/2)-1; i >= 0; i--){\n\
    \        heapify(arr, n, i);\n    }\n    for(let i = k; i < n; i++){\n       \
    \ if(arr[i] > arr[0]){\n            swap(arr, i, 0);\n            heapify(arr,\
    \ k, 0);\n        }\n    }\n    return arr.slice(0, k);\n}\n", "  let res = [];\n\
    \  if(k === 0) return res;\n  for(let i = 0; i < arr.length; i++){\n    // \u7B2C\
    \u4E00\u6B21\u6216\u8005res\u957F\u5EA6\u5C0F\u4E8Ek\uFF0Cres\u90FD\u7B49\u4E8E\
    \u81EA\u5DF1\n    if(i < k){\n      res.push(arr[i]);\n    }else{\n      // \u5426\
    \u5219\u6BD4\u8F83res\u6700\u540E\u4E00\u4E2A\u503C\u4E0Earr[i]\u7684\u5927\u5C0F\
    \n      let last = res[res.length - 1];\n      // \u5982\u679Cres\u6700\u540E\u4E00\
    \u4E2A\u503C\u6BD4arr[i]\u5C0F\n      if(last < arr[i]){\n        // \u5C06res\u6700\
    \u540E\u4E00\u4E2A\u503C\u5220\u9664\uFF0C\u518D\u653E\u5165arr[i]\n        res.pop();\n\
    \        res.push(arr[i]);\n      }\n    }\n  }\n  return res;\n}\n", "    var\
    \ a = arr.sort((a,b)=>a-b).slice(arr.length-k);\n    return a;\n}", "    if(arr.length\
    \ === 0 || k === 0) return [];\n    if(arr.length === 1) return arr;\n    let\
    \ maxArray = [];\n    let index = 0;\n    while(index !== k){\n        let max\
    \ = arr[0];\n        let maxIndex = 0;\n        for(let i = 0; i < arr.length;\
    \ i++){\n            if(arr[i] > max){\n                max = arr[i];\n      \
    \          maxIndex = i;\n            }\n        }\n        maxArray.push(max);\n\
    \        arr.splice(maxIndex, 1);\n        index++;\n    }\n    return maxArray;\n\
    }", "  const n = arr.length;\n  for(let i = 0; i < k; i++){\n    let max = arr[i];\n\
    \    let idx = i;\n    for(let j = i + 1; j < n; j++){\n      if(arr[j] > max){\n\
    \        max = arr[j];\n        idx = j;\n      }\n    }\n    const temp = arr[i];\n\
    \    arr[i] = arr[idx];\n    arr[idx] = temp;\n  }\n  return arr.slice(0, k);\n\
    }\n", "  arr.sort((a,b) => b-a);\n  return arr.slice(0,k);\n}", "\n}\n", "   \
    \ let result = [];\n    let min = 0;\n    let max = arr.length - 1;\n    let pivot\
    \ = arr[Math.floor((min + max) / 2)];\n    if(arr.length === k){\n        return\
    \ arr;\n    }\n    for(let i = 0; i < k; i++){\n        for(let j = 0; j < arr.length;\
    \ j++){\n            if(arr[j] > pivot){\n                pivot = arr[j];\n  \
    \          }\n        }\n        result.push(pivot);\n        arr.splice(arr.indexOf(pivot),\
    \ 1);\n        pivot = arr[Math.floor((min + max) / 2)];\n    }\n    return result;\n\
    }\n", "    if(arr.length == 0)\n        return [];\n    if(arr.length == 1)\n\
    \        return arr;\n    let max = -Infinity;\n    let min = Infinity;\n    for(let\
    \ val of arr){\n        if(val > max)\n            max = val;\n        if(val\
    \ < min)\n            min = val;\n    }\n    let buckets = new Array(max - min\
    \ + 1).fill(0);\n    for(let val of arr){\n        buckets[val - min]++;\n   \
    \ }\n    let res = [];\n    for(let i = buckets.length - 1; i >= 0; i--){\n  \
    \      if(k <= 0)\n            break;\n        while(buckets[i]-- > 0 && k-- >\
    \ 0){\n            res.push(i + min);\n        }\n    }\n    return res;\n}",
  "    if(arr.length == 0 || k <= 0){\n        return [];\n    }\n    let maxHeap\
    \ = [];\n    for(let i = 0; i < arr.length; i++){\n        if(maxHeap.length ==\
    \ k){\n            maxHeap.push(arr[i]);\n            maxHeap.sort((a, b) => b\
    \ - a);\n            maxHeap.pop();\n        }\n        else{\n            maxHeap.push(arr[i]);\n\
    \            maxHeap.sort((a, b) => b - a);\n        }\n    }\n    return maxHeap;\n\
    }\n", "    let result = [];\n    for(let i = 0; i < k; i++){\n        let currentMax\
    \ = arr[i];\n        let currentMaxIndex = i;\n        for(let j = i; j < arr.length;\
    \ j++){\n            if(arr[j] > currentMax){\n                currentMax = arr[j];\n\
    \                currentMaxIndex = j;\n            }\n        }\n        result.push(currentMax);\n\
    \        swap(arr, i, currentMaxIndex);\n    }\n    return result;\n}\n", "\t\n\
    }\n", "  return arr.sort((a,b) => b-a).slice(0,k);\n}", "    return arr.sort((a,b)=>{\n\
    \        return b-a;\n    }).slice(0,k);\n}", "  var sol = [];\n  for(var i =\
    \ 0; i < k; i++){\n    var min = Infinity;\n    var minIndex = -1;\n    for(var\
    \ j = 0; j < arr.length; j++){\n      if(arr[j] !== null && arr[j] < min){\n \
    \       min = arr[j];\n        minIndex = j;\n      }\n    }\n    sol.push(min);\n\
    \    arr[minIndex] = null;\n  }\n  return sol;\n}", "    if(arr.length === 0 ||\
    \ k === 0) return [];\n    if(arr.length <= k) return arr.sort((a,b) => b-a);\n\
    \    let result = arr.slice(0, k);\n    result.sort((a,b) => a-b);\n    for(let\
    \ i = k; i < arr.length; i++){\n        if(arr[i] > result[0]){\n            result[0]\
    \ = arr[i];\n            shiftDown(result, 0);\n        }\n    }\n    return result;\n\
    }\n", "    if(arr.length < k) return arr;\n    let  max = [];\n    let index =\
    \ 0;\n    while(k--){\n        let temp = arr[index];\n        let tempIndex =\
    \ index;\n        while(index < arr.length){\n            if(arr[index] > temp){\n\
    \                temp = arr[index];\n                tempIndex = index;\n    \
    \        }\n            index++;\n        }\n        arr[tempIndex] = -1;\n  \
    \      max.push(temp);\n        index = tempIndex;\n    }\n    return max;\n}",
  "    return arr.sort((a,b)=>{\n        return b-a;\n    }).slice(0,k);\n}", "  \
    \  if(arr === null || arr.length === 0 || k > arr.length){\n        return []\n\
    \    }\n    return heap(arr, k);\n}\n", "    let kArr = [];\n    for(let i = 0;\
    \ i < k; i++){\n        let max = Math.max(...arr);\n        let index = arr.indexOf(max);\n\
    \        kArr.push(max);\n        arr.splice(index, 1);\n    }\n    return kArr;\n\
    }", "    if(k > arr.length) k = arr.length;\n    let res = arr.slice(0, k);\n\
    \    let j = k;\n    let i = 0;\n    while(j < arr.length){\n        if(arr[j]\
    \ > res[i]){\n            res[i] = arr[j];\n            i++;\n        }\n    \
    \    if(i == k) i = 0;\n        j++;\n    }\n    return res;\n}\n", "    if(k>=arr.length)\
    \ return arr;\n    let kList = arr.slice(0,k);\n    for(let i=k;i<arr.length;i++){\n\
    \        for(let j=0;j<k;j++){\n            if(arr[i]>kList[j]){\n           \
    \     kList.splice(j,0,arr[i]);\n                kList.pop();\n              \
    \  break;\n            }\n        }\n    }\n    return kList;\n}", "    if(k >=\
    \ arr.length) return arr.sort((a,b) => b-a);\n    let result = [];\n    for(let\
    \ i = 0; i < k; i++){\n        let max = Math.max(...arr);\n        result.push(max);\n\
    \        arr.splice(arr.indexOf(max), 1);\n    }\n    return result;\n}", "  \
    \  let sorted = arr.sort((a,b) => b-a)\n    let res = []\n    for(let i = 0; i\
    \ < k; i++){\n        res.push(sorted[i])\n    }\n    return res\n}", "\tvar max\
    \ = [-Infinity];\n\tvar arr1 = arr.filter(function(item){\n\t\tif(item >= max[0]){\n\
    \t\t\tmax.push(item);\n\t\t\treturn true;\n\t\t}\n\t\tif(max.length > k){\n\t\t\
    \tmax.pop();\n\t\t}\n\t\treturn false;\n\t});\n\tconsole.log(arr1);\n\tconsole.log(max);\n\
    \treturn max;\n}\nvar arr = [3,2,1,5,6,4];\nvar k = 2;\nmaximum(arr, k);", " \
    \   let result = [];\n    for(let i = 0; i < k; i++){\n        let max = arr[0];\n\
    \        let maxIndex = 0;\n        for(let j = 0; j < arr.length; j++){\n   \
    \         if(arr[j] > max){\n                max = arr[j];\n                maxIndex\
    \ = j;\n            }\n        }\n        result.push(max);\n        arr.splice(maxIndex,\
    \ 1);\n    }\n    return result;\n}\n\nlet arr = [11,22,30,1,2,3,4,5,6,7,8,9,10];\n\
    let result = maximum(arr, 3);", "    var minHeap = new MinHeap();\n    for(var\
    \ i = 0; i < arr.length; i++){\n        minHeap.insert(arr[i]);\n    }\n    var\
    \ result = [];\n    while(k > 0){\n        result.push(minHeap.remove());\n  \
    \      k--;\n    }\n    return result;\n}\n", "    // we can do a quick sort to\
    \ sort the array and then return the last k numbers in the array\n    // but this\
    \ is not an O(n) approach\n\n    // an O(n) solution\n    let result = [];\n \
    \   for(let i = 0; i < arr.length; i++){\n        let j = result.length - 1;\n\
    \        while(j >= 0 && result[j] < arr[i]){\n            j--;\n        }\n \
    \       if(j + 1 < k){\n            result.splice(j + 1, 0, arr[i]);\n       \
    \ }\n    }\n    return result;\n}\n\narr = [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4",
  "\tarr.sort(function(a, b){return b-a;});\n\treturn arr.slice(0, k);\n}", "    let\
    \ result = [];\n    // if(arr.length == k){\n    //     return arr;\n    // }\n\
    \    for(let i = 0; i < k; i++){\n        let max = -10001;\n        let idx =\
    \ -1;\n        for(let j = 0; j < arr.length; j++){\n            if(arr[j] > max){\n\
    \                max = arr[j];\n                idx = j;\n            }\n    \
    \    }\n        result.push(max);\n        arr.splice(idx, 1);\n    }\n    return\
    \ result;\n}", "    var res = [], head = 0, tail = 0;\n    while(head < arr.length){\n\
    \        while(tail < arr.length && res.length < k){\n            if(!res.length\
    \ || res[res.length - 1] < arr[tail]){\n                res.push(arr[tail]);\n\
    \            }\n            tail++;\n        }\n        if(res.length >= k){\n\
    \            while(tail < arr.length && res[0] < arr[tail]){\n               \
    \ res.shift();\n                res.push(arr[tail]);\n            }\n        }\n\
    \        head++;\n    }\n    return res;\n}", "    function swap(i, j){\n    \
    \    let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n  \
    \  }\n    function maxHeapify(i, n){\n        let leftChild = 2 * i + 1;\n   \
    \     let rightChild = 2 * i + 2;\n        let max = i;\n        if(leftChild\
    \ < n && arr[leftChild] > arr[max]){\n            max = leftChild;\n        }\n\
    \        if(rightChild < n && arr[rightChild] > arr[max]){\n            max =\
    \ rightChild;\n        }\n        if(max !== i){\n            swap(i, max);\n\
    \            maxHeapify(max, n);\n        }\n    }\n    function buildMaxHeap(n){\n\
    \        for(let i = Math.floor(n / 2); i >= 0; i--){\n            maxHeapify(i,\
    \ n);\n        }\n    }\n    function heapSort(n){\n        buildMaxHeap(n);\n\
    \        for(let i = n - 1; i > 0; i--){\n            swap(0, i);\n          \
    \  maxHeapify(0, i);\n        }\n    }\n    heapSort(arr.length);\n    return\
    \ arr.slice(0, k);\n}\n", "\tif(arr.length <= k) return arr.sort((a,b) => b-a);\n\
    \tlet minHeap = new MinHeap();\n\tfor(let i = 0; i < k; i++){\n\t\tminHeap.add(arr[i]);\n\
    \t}\n\tfor(let i = k; i < arr.length; i++){\n\t\tif(arr[i] > minHeap.peek()){\n\
    \t\t\tminHeap.remove();\n\t\t\tminHeap.add(arr[i]);\n\t\t}\n\t}\n\treturn minHeap.list.sort((a,b)\
    \ => b-a);\n}", "    let heap = new Heap();\n    let sorted = [];\n    //add the\
    \ first k elements to the heap\n    for(let i = 0; i < k; i++){\n        heap.insert(arr[i]);\n\
    \    }\n    //compare the rest of the elements to the top of the heap\n    for(let\
    \ i = k; i < arr.length; i++){\n        if(arr[i] > heap.peek()){\n          \
    \  heap.delete();\n            heap.insert(arr[i]);\n        }\n    }\n    //pop\
    \ the elements from the heap\n    while(heap.size > 0){\n        sorted.push(heap.delete());\n\
    \    }\n    return sorted;\n}\n", "\n}", "    var max = -1\n    var maxIndex =\
    \ -1\n    var list = []\n    for(var i = 0; i < k; i++){\n        max = -1\n \
    \       maxIndex = -1\n        for(var j = 0; j < arr.length; j++){\n        \
    \    if(arr[j] > max){\n                max = arr[j]\n                maxIndex\
    \ = j\n            }\n        }\n        list.push(max)\n        arr[maxIndex]\
    \ = -1\n    }\n    return list\n}", "    let res = [], m = 0;\n    for(let i =\
    \ 0; i < arr.length; i++){\n        while(res.length && res[res.length - 1] <\
    \ arr[i] && res.length + arr.length - i > k){\n            res.pop();\n      \
    \  }\n        if(res.length < k){\n            res.push(arr[i]);\n        }\n\
    \    }\n    return res;\n}\n", "  arr.sort((a,b) => b-a)\n  return arr.slice(0,k)\n\
    }", "  if(arr.length===0) return arr;\n  let len = arr.length;\n  let j=0;\n \
    \ let res = [];\n  for(let i=0; i<len; i++){\n    if(i===len-1){\n      res[j]\
    \ = arr[i];\n      j++;\n    }else{\n      if(arr[i]>arr[i+1]){\n        res[j]\
    \ = arr[i];\n        j++;\n      }\n    }\n  }\n  return res.slice(0,k);\n}",
  "    if(k>=arr.length) return arr.sort((a,b)=>b-a);\n    // create a new array with\
    \ length of k, which is the max number of elements in the result array\n    const\
    \ result = new Array(k);\n    // populate the result array with 0, this is equivalent\
    \ to set every element to 0 in the result array\n    result.fill(0);\n    // iterate\
    \ through the given array, if the element is larger than the smallest number in\
    \ the result array\n    // we will replace the element with the index of the smallest\
    \ number in the result array\n    for(let i=0; i<arr.length; i++){\n        if(arr[i]>result[0]){\n\
    \            result[0] = arr[i];\n            heapify(result, 0);\n        }\n\
    \    }\n    return result;\n}\n", "    let length = arr.length;\n    return arr.sort((a,\
    \ b) => a - b).slice(length - k, length);\n}\n", "    let max = 0;\n    let result\
    \ = [];\n    let resIndex = 0;\n    let map = {};\n    let hash = {};\n    let\
    \ el;\n    let temp;\n    //let min = Number.MAX_SAFE_INTEGER;\n    let diff =\
    \ -1;\n    let min = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < arr.length;\
    \ i++){\n        el = arr[i];\n        max = Math.max(max, el);\n        if(!hash[el]){\n\
    \            hash[el] = 0;\n        }\n        hash[el]++;\n        //if(hash[el]\
    \ > diff){\n        //    diff = hash[el];\n        //    temp = el;\n       \
    \ //}\n        if(el < min){\n            min = el;\n        }\n    }\n    for(let\
    \ i = 0; i < arr.length; i++){\n        el = arr[i];\n        hash[el]--;\n  \
    \      result[resIndex++] = el;\n        if(map[el] === undefined){\n        \
    \    map[el] = 0;\n        }\n        map[el]++;\n        if(resIndex === k){\n\
    \            return result;\n        }\n    }\n    //console.log('map: ', map);\n\
    \    //console.log('min: ', min);\n    let j = 0;\n    while(resIndex < k){\n\
    \        //console.log('j: ', j);\n        if(map[j] > 0){\n            j++;\n\
    \            continue;\n        }\n        //console.log('j: ', j);\n        result[resIndex++]\
    \ = j;\n        j++;\n    }\n    return result;\n}", "    if(arr.length < k){\n\
    \        return arr.sort((a,b) => b-a);\n    }\n    var max = arr.slice(0,k).sort((a,b)\
    \ => b-a);\n    for(var i = k; i < arr.length; i++){\n        max.push(arr[i]);\n\
    \        max.sort((a,b) => b-a);\n        max.pop();\n    }\n    return max;\n\
    }", "    var newarr = arr.sort(function(a,b){return b-a});\n    var answer = [];\n\
    \    for(var i = 0; i < k; i++){\n        answer.push(newarr[i]);\n    }\n   \
    \ return answer;\n}\nvar arr = [1,2,3,4,5];\nvar k = 2;", "    if(k > arr.length){\n\
    \        return;\n    }\n    let res = [],\n        index = 0;\n    for(let i\
    \ = 0; i < arr.length; i++){\n        if(res.length < k){\n            res.push(arr[i]);\n\
    \        }else{\n            index = i;\n            break;\n        }\n    }\n\
    \    while(index < arr.length){\n        res.sort((a, b) => a - b);\n        if(arr[index]\
    \ > res[0]){\n            res[0] = arr[index];\n        }\n        index++;\n\
    \    }\n    return res;\n}\n", "\treturn arr.sort((a,b)=>a-b).slice(arr.length-k,\
    \ arr.length)\n}", "    if(arr.length <= k){\n        return arr.sort((a,b) =>\
    \ b-a);\n    }\n\n    let max = -Infinity;\n    let res = [];\n    for(let i =\
    \ 0; i < arr.length; i++){\n        if(arr[i] > max){\n            max = arr[i];\n\
    \            res.push(max);\n        }\n    }\n    return res;\n}\n", "    arr.sort(function(a,\
    \ b){\n        return b - a;\n    });\n    return arr.slice(0, k);\n}\n", "  \
    \  if(arr.length < 1 || arr.length < k) {\n        return arr;\n    }\n    var\
    \ arrMax = [];\n    var counter = k;\n    while(counter > 0){\n        var max\
    \ = arr[0];\n        var maxIndex = 0;\n        for(var i = 0; i < arr.length;\
    \ i++){\n            if(arr[i] > max){\n                max = arr[i];\n      \
    \          maxIndex = i;\n            }\n        }\n        arrMax.push(max);\n\
    \        arr.splice(maxIndex, 1);\n        counter--;\n    }\n    return arrMax;\n\
    }\nvar arr1 = [1,2,3,4,5];\nvar arr2 = [3,2,1,5,6,4];\nvar arr3 = [3,2,3,1,2,4,5,5,6];",
  "    arr.sort(function(a, b){return b-a});\n    let res = arr.slice(0, k);\n   \
    \ res.sort(function(a, b){return a-b});\n    return res;\n}\n", "    if(k ===\
    \ 0) return [];\n    var N = arr.length,\n        heap = [],\n        i;\n   \
    \ for(i = 0; i < k; i++){\n        heap[i] = arr[i];\n    }\n    buildHeap(heap);\n\
    \    for(i = k; i < N; i++){\n        if(arr[i] > heap[0]){\n            heap[0]\
    \ = arr[i];\n            adjustHeap(heap, 0);\n        }\n    }\n    return heap;\n\
    }\n", "    let result = [];\n    let highest = 0;\n    let index = 0;\n    for(let\
    \ i = 0; i < k; i++){\n        for(let j = 0; j < arr.length; j++){\n        \
    \    if(arr[j] > highest){\n                highest = arr[j];\n              \
    \  index = j;\n            }\n        }\n        result.push(highest);\n     \
    \   arr[index] = -Infinity;\n        highest = 0;\n    }\n    return result;\n\
    }", "    for(let i = 0; i < k; i++){\n        for(let j = 0; j < arr.length -\
    \ i - 1; j++){\n            if(arr[j] > arr[j + 1]){\n                swap(arr,\
    \ j, j + 1);\n            }\n        }\n    }\n    return arr.slice(arr.length\
    \ - k);\n}\n", "  let result = []\n  for(let i = 0; i < arr.length; i++){\n  \
    \  if(result.length === 0){\n      result.push(arr[i])\n    } else {\n      if(result.length\
    \ < k){\n        result.push(arr[i])\n        result.sort((a,b) => a-b)\n    \
    \  } else {\n        if(arr[i] > result[0]){\n          result.shift()\n     \
    \     result.push(arr[i])\n          result.sort((a,b) => a-b)\n        }\n  \
    \    }\n    }\n  }\n  return result\n}\n", "    for(let i = 1; i < k; i++){\n\
    \        let j = i;\n        while(j > 0 && arr[j] > arr[j-1]){\n            let\
    \ tmp = arr[j];\n            arr[j] = arr[j-1];\n            arr[j-1] = tmp;\n\
    \            j--;\n        }\n    }\n    return arr.slice(0, k);\n}\n", "    //\
    \ base case\n    if(arr.length === 0) return [];\n    if(arr.length === 1) return\
    \ arr[0];\n    // recursive case\n    let max = arr[0];\n    for(let i = 1; i\
    \ < arr.length; i++){\n        if(arr[i] > max) max = arr[i];\n    }\n    return\
    \ [max].concat(maximum(arr.slice(1), k - 1));\n}\n", "\tlet result = []\n\tfor(let\
    \ i = 0; i < k; i++){\n\t\tresult.push(arr[i])\n\t}\n\t// console.log(result)\n\
    \tfor(let i = k; i < arr.length; i++){\n\t\tfor(let j = 0; j < k; j++){\n\t\t\t\
    if(arr[i] > result[j]){\n\t\t\t\tresult.splice(j, 0, arr[i])\n\t\t\t\tresult.pop()\n\
    \t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\narr = [1,2,3,4,5,6,7,8,9,10]",
  "    var n = arr.length;\n    var result = [];\n    for(var i = 0; i < k; i++){\n\
    \        result.push(arr[i]);\n    }\n    for(var i = 0; i < n; i++){\n      \
    \  for(var j = k - 1; j >= 0; j--){\n            if(arr[i] > result[j]){\n   \
    \             result.pop();\n                result.push(arr[i]);\n          \
    \      break;\n            }\n        }\n    }\n    return result;\n}\n\nvar arr\
    \ = [1,2,3,4,2,1,3,4,1,3,4,3,3,3,3,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,",
  "\tif(k === 0) return [];\n\tif(k === arr.length) return arr;\n\tvar res = arr.slice(0,\
    \ k);\n\tres.sort((a, b) => a - b);\n\tfor(var i = k; i < arr.length; i++){\n\t\
    \tfor(var j = k - 1; j >= 0; j--){\n\t\t\tif(arr[i] > res[j]){\n\t\t\t\tres.splice(j,\
    \ 0, arr[i]);\n\t\t\t\tres.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ res;\n}\n\nvar arr = [19, 5, 4, 3, 27, 6];\nvar k = 3;", "    let kMaxes = [];\n\
    \    let temp = 0;\n    for(let i = 0; i < k; i++){\n        for(let j = i + 1;\
    \ j < arr.length; j++){\n            if(arr[i] > arr[j]){\n                temp\
    \ = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n\
    \            }\n        }\n        kMaxes.push(arr[i]);\n    }\n    return kMaxes;\n\
    }", "    const stack = new Stack();\n    for(let num of arr){\n        while(stack.size\
    \ > 0 && num > stack.peek() && stack.size + arr.length - i > k){\n           \
    \ stack.pop();\n        }\n        if(stack.size < k){\n            stack.push(num);\n\
    \        }\n    }\n    return stack.toArray();\n}", "    if(arr.length === k){\n\
    \        return arr;\n    }\n\n    const output = [];\n    const bucket = [];\n\
    \    const max = getMax(arr);\n    const min = getMin(arr);\n\n    for(let i =\
    \ 0; i < arr.length; i++){\n        const idx = Math.floor((arr[i] - min) / (max\
    \ - min) * (k - 1));\n        if(bucket[idx] === undefined){\n            bucket[idx]\
    \ = [];\n        }\n        bucket[idx].push(arr[i]);\n    }\n\n    for(let i\
    \ = k - 1; i >= 0; i--){\n        if(bucket[i] !== undefined){\n            insertionSort(bucket[i]);\n\
    \            output.push(...bucket[i]);\n        }\n    }\n\n    return output;\n\
    }\n", "    let res = [];\n    for(let i = 0; i < arr.length; i++){\n        if(res.length\
    \ < k){\n            res.push(arr[i]);\n        }else{\n            res.sort((a,b)\
    \ => a-b);\n            if(arr[i] > res[0]){\n                res[0] = arr[i];\n\
    \            }\n        }\n    }\n    return res.sort((a,b) => a-b);\n}", "  \
    \  let answer = [];\n    //helper function that returns the max number in array\n\
    \    const max = (array) =>{\n        let max = 0;\n        for(let i = 0; i <\
    \ array.length; i++){\n            if(array[i] > max){\n                max =\
    \ array[i];\n            }\n        }\n        return max;\n    }\n    //loop\
    \ through arr until k reaches zero\n    while(k > 0){\n        let current = max(arr);\n\
    \        answer.push(current);\n        //remove the max value from the array\
    \ and decrement k\n        arr.splice(arr.indexOf(current), 1);\n        k--;\n\
    \    }\n    return answer;\n}", "    let result = [];\n    for(let i = 0; i <\
    \ k; i++){\n        result.push(arr[i]);\n    }\n    let min = result[0];\n  \
    \  let minInd = 0;\n    for(let i = 1; i < k; i++){\n        if(result[i] < min){\n\
    \            min = result[i];\n            minInd = i;\n        }\n    }\n   \
    \ for(let i = k; i < arr.length; i++){\n        if(arr[i] > min){\n          \
    \  result[minInd] = arr[i];\n            min = result[0];\n            minInd\
    \ = 0;\n            for(let j = 1; j < k; j++){\n                if(result[j]\
    \ < min){\n                    min = result[j];\n                    minInd =\
    \ j;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n", "    let result = [];\n    let last = 0;\n    for(let i =0; i<arr.length;\
    \ i++){\n        if(result.length < k){\n            if(arr[i] > result[last]){\n\
    \                result.splice(last, 0, arr[i]);\n                last++;\n  \
    \          }else{\n                result.push(arr[i]);\n            }\n     \
    \   }else{\n            if(arr[i] > result[last]){\n                let j = last\
    \ - 1;\n                while(j >= 0 && arr[i] > result[j]){\n               \
    \     result[j+1] = result[j];\n                    j--;\n                }\n\
    \                result[j+1] = arr[i];\n            }\n        }\n    }\n    return\
    \ result;\n}", "\tvar result = [];\n\tfor(var i = 0; i < k; i++){\n\t\tvar max\
    \ = arr[0];\n\t\tvar index = 0;\n\t\tfor(var j = 0; j < arr.length; j++){\n\t\t\
    \tif(arr[j] > max){\n\t\t\t\tmax = arr[j];\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t\
    }\n\t\tresult.push(max);\n\t\tarr.splice(index, 1);\n\t}\n\treturn result;\n}\n\
    var input = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];", "    let heap = [];\n    if(k>arr.length){\n\
    \        return [];\n    }\n    //create heap\n    for(let i=0; i<k; i++){\n \
    \       heap.push(arr[i]);\n        heapify(heap, i);\n    }\n    for(let i=k;\
    \ i<arr.length; i++){\n        if(arr[i]>heap[0]){\n            heap[0] = arr[i];\n\
    \            heapify(heap, 0);\n        }\n    }\n    return heap;\n}\n", "  \
    \  let heap = new MaxHeap();\n    for(let i = 0; i < arr.length; i++){\n     \
    \   heap.add(arr[i]);\n    }\n    let result = [];\n    for(let i = 0; i < k;\
    \ i++){\n        result.push(heap.removeMax());\n    }\n    return result;\n}\n\
    class MaxHeap{\n    constructor(){\n        this.storage = [];\n    }\n    add(value){\n\
    \        this.storage.push(value);\n        this.siftUp(this.storage.length -\
    \ 1);\n    }\n    siftUp(index){\n        let parentIndex = Math.floor((index\
    \ - 1) / 2);\n        if(this.storage[index] > this.storage[parentIndex]){\n \
    \           this.swap(index, parentIndex);\n            this.siftUp(parentIndex);\n\
    \        }\n    }\n    removeMax(){\n        this.swap(0, this.storage.length\
    \ - 1);\n        let value = this.storage.pop();\n        this.siftDown(0);\n\
    \        return value;\n    }\n    siftDown(index){\n        let leftIndex = index\
    \ * 2 + 1;\n        let rightIndex = index * 2 + 2;\n        let biggerChildIndex\
    \ = this.storage[leftIndex] > this.storage[rightIndex] ? leftIndex : rightIndex;\n\
    \        if(this.storage[index] < this.storage[biggerChildIndex]){\n         \
    \   this.swap(index, biggerChildIndex);\n            this.siftDown(biggerChildIndex);\n\
    \        }\n    }\n    swap(index1, index2){\n        let temp = this.storage[index1];\n\
    \        this.storage[index1] = this.storage[index2];\n        this.storage[index2]\
    \ = temp;\n    }\n}\n", "    let result = [];\n    for(let i = 0; i < k; i++){\n\
    \        let max = -Infinity;\n        let maxIndex = -1;\n        for(let j =\
    \ 0; j < arr.length; j++){\n            if(arr[j] > max){\n                max\
    \ = arr[j];\n                maxIndex = j;\n            }\n        }\n       \
    \ result.push(max);\n        arr.splice(maxIndex, 1);\n    }\n    return result;\n\
    }\n", "    let res = [];\n    let i = 0;\n    while(k > 0){\n        let max =\
    \ arr[i];\n        let imax = i;\n        for(i; i < arr.length; i++){\n     \
    \       if(arr[i] > max){\n                max = arr[i];\n                imax\
    \ = i;\n            }\n        }\n        res.push(max);\n        arr.splice(imax,\
    \ 1);\n        i = 0;\n        k--;\n    }\n    return res;\n}", "  return arr.sort((a,b)\
    \ => a-b).slice(arr.length-k);\n}\n", "\tvar result = [];\n\tif(arr.length ===\
    \ 0){\n\t\treturn result;\n\t}\n\tfor(var i = 0; i < arr.length; i++){\n\t\tvar\
    \ current = arr[i];\n\t\tif(result.length < k){\n\t\t\tresult.push(current);\n\
    \t\t}else{\n\t\t\tvar min = getMinimum(result);\n\t\t\tif(current > min){\n\t\t\
    \t\tresult[min.index] = current;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n",
  "    let n = arr.length;\n    if(k === n) return arr;\n    let min = Math.min(k,\
    \ n);\n    let stack = [];\n    for(let i = 0; i < min; i++){\n        stack.push(arr[i]);\n\
    \    }\n    for(let i = min; i < n; i++){\n        for(let j = 0; j < stack.length;\
    \ j++){\n            if(arr[i] > stack[j]){\n                stack.splice(j, 0,\
    \ arr[i]);\n                stack.pop();\n                break;\n           \
    \ }\n        }\n    }\n    return stack;\n}\n", "    if(k === arr.length) return\
    \ arr.sort((a,b) => a - b);\n    if(k === 1) return arr.sort((a,b) => b - a)[0];\n\
    \    // find max k+1, remove it\n    for(let i = 0; i < k; i++){\n        let\
    \ max = -Infinity;\n        let index = -1;\n        for(let j = i; j < arr.length;\
    \ j++){\n            if(arr[j] > max){\n                max = arr[j];\n      \
    \          index = j;\n            }\n        }\n        [arr[i], arr[index]]\
    \ = [arr[index], arr[i]];\n    }\n    return arr.slice(0, k);\n}\n", "    let\
    \ sarr = arr.sort((a,b)=>b-a);\n    let result = sarr.slice(0,k);\n    return\
    \ result;\n}", "\tlet res = [];\n\tfor(let i = 0; i < arr.length; i++){\n\t\t\
    if(i > k - 1){\n\t\t\tres.splice(res.findIndex(x => x > arr[i]), 1);\n\t\t}\n\t\
    \tif(res.length < k || arr[i] > res[res.length - 1]){\n\t\t\tres.push(arr[i]);\n\
    \t\t}\n\t}\n\treturn res;\n}\n", "    if(k === 0){\n        return []\n    }\n\
    \    if(k === arr.length){\n        return arr.sort((a,b) => a-b)\n    }\n   \
    \ let max = -Infinity\n    let res = []\n    for(let i = 0; i < arr.length; i++){\n\
    \        max = Math.max(max, arr[i])\n        if(res.length < k){\n          \
    \  res.push(max)\n        }\n    }\n    return res\n}\nlet arr = [1,2,3,4,5,6,7,8,9,100]",
  "    let max = -Infinity;\n    let max_index = -1;\n    for(let i = 0; i < k; i++){\n\
    \        for(let j = i; j < arr.length; j++){\n            if(arr[j] > max){\n\
    \                max = arr[j];\n                max_index = j;\n            }\n\
    \        }\n        let temp = arr[i];\n        arr[i] = max;\n        arr[max_index]\
    \ = temp;\n        max = -Infinity;\n        max_index = -1;\n    }\n    return\
    \ arr.slice(0, k);\n}", "    let maxHeap = new Heap((a, b) => b - a);\n    for(let\
    \ i = 0; i < k; i++){\n        maxHeap.push(arr[i]);\n    }\n    for(let i = k;\
    \ i < arr.length; i++){\n        let val = arr[i];\n        if(val > maxHeap.peek()){\n\
    \            maxHeap.pop();\n            maxHeap.push(val);\n        }\n    }\n\
    \    return maxHeap.toArray();\n}\n", "    arr.sort((a,b)=>b-a);\n    return arr.slice(0,k);\n\
    }\n", "    let len = arr.length\n    let start = 0,\n        end = len - 1,\n\
    \        pivot = len - 1\n    while(start <= end){\n        let pivot = start\n\
    \        for(let i = start; i < end; i++){\n            if(arr[i] < arr[end]){\n\
    \                [arr[i], arr[pivot]] = [arr[pivot], arr[i]]\n               \
    \ pivot++\n            }\n        }\n        [arr[pivot], arr[end]] = [arr[end],\
    \ arr[pivot]]\n        if(pivot === k - 1){\n            break\n        }else\
    \ if(pivot < k - 1){\n            start = pivot + 1\n        }else{\n        \
    \    end = pivot - 1\n        }\n    }\n    return arr.slice(0, k)\n}", "    let\
    \ res = [];\n    if(k === 0) return res;\n    res = arr.slice(0, k);\n    console.log(res);\n\
    \    res.sort((a, b) => a - b);\n    console.log(res);\n    for(let i = k; i <\
    \ arr.length; i++){\n        let min = res[0];\n        if(arr[i] > min){\n  \
    \          // replace min value\n            let j = 0;\n            while(j <\
    \ k){\n                if(res[j] === min){\n                    res[j] = arr[i];\n\
    \                    break;\n                }\n                j++;\n       \
    \     }\n            // sorting again\n            res.sort((a, b) => a - b);\n\
    \        }\n    }\n    return res;\n}\n", "    let len = arr.length;\n    for(let\
    \ i = len - 1; i >= len - k; i--){\n        for(let j = 0; j < i; j++){\n    \
    \        if(arr[j] > arr[j + 1]){\n                [arr[j], arr[j + 1]] = [arr[j\
    \ + 1], arr[j]];\n            }\n        }\n    }\n    return arr.slice(len -\
    \ k);\n}", "  let result = []\n  for(let i = 0; i < arr.length; i++){\n    if(arr[i]\
    \ < arr[i + 1]){\n      result.push(arr[i + 1])\n    }\n  }\n  return result.slice(0,\
    \ k)\n}\n", "  let count = 0;\n  let max = -Infinity;\n  let index = 0;\n  let\
    \ maxArr = [];\n  for(let i = 0; i < k; i++){\n    for(let j = 0; j < arr.length;\
    \ j++){\n      if(arr[j] > max && !maxArr.includes(arr[j])){\n        max = arr[j];\n\
    \        index = j;\n      }\n    }\n    maxArr.push(max);\n    max = -Infinity;\n\
    \  }\n  return maxArr;\n}", "  // use a max heap to solve this problem\n  // only\
    \ keep the k largest elements of the heap in the heap\n  let heap = new maxHeap()\n\
    \  // heapify the array so that the max element will be at the top of the heap\n\
    \  // at the end of the iteration\n  for(let i = 0; i < arr.length; i++){\n  \
    \  heap.add(arr[i])\n    if(heap.arr.length > k){\n      heap.removeMax()\n  \
    \  }\n  }\n  // return the heap in reverse order to get the result in ascending\
    \ order\n  return heap.arr.reverse()\n}\n\nclass maxHeap{\n  constructor(){\n\
    \    this.arr = []\n  }\n  add(item){\n    this.arr.push(item)\n    let index\
    \ = this.arr.length - 1\n    let parent = Math.floor((index - 1) / 2)\n    while(this.arr[parent]\
    \ < this.arr[index]){\n      let temp = this.arr[parent]\n      this.arr[parent]\
    \ = this.arr[index]\n      this.arr[index] = temp\n      index = parent\n    \
    \  parent = Math.floor((index - 1) / 2)\n    }\n  }\n  removeMax(){\n    let root\
    \ = this.arr[0]\n    let last = this.arr.pop()\n    this.arr[0] = last\n    let\
    \ index = 0\n    let left = index * 2 + 1\n    let right = index * 2 + 2\n   \
    \ while(this.arr[left] && this.arr[right] && \n      (this.arr[index] < this.arr[left]\
    \ || this.arr[index] < this.arr[right])){\n      if(this.arr[left] > this.arr[right]){\n\
    \        let temp = this.arr[index]\n        this.arr[index] = this.arr[left]\n\
    \        this.arr[left] = temp\n        index = left\n      }else{\n        let\
    \ temp = this.arr[index]\n        this.arr[index] = this.arr[right]\n        this.arr[right]\
    \ = temp\n        index = right\n     ", "    var result = [];\n    for(var i\
    \ = 0; i < k; i++){\n        var m = Math.max(...arr);\n        result.push(m);\n\
    \        var index = arr.indexOf(m);\n        arr.splice(index, 1);\n    }\n \
    \   return result;\n}", "    const max_num = []\n    for(i = 0; i < k; i++){\n\
    \        max_num.push(Math.max(...arr))\n        arr.splice(arr.indexOf(Math.max(...arr)),\
    \ 1)\n    }\n    return max_num\n}", "  if(arr.length === 0) return [];\n  return\
    \ arr.sort((a,b) => b-a).slice(0,k);\n}", "  if(arr.length <= k) return arr;\n\
    \  let res = arr.slice(0, k);\n  res.sort((a, b) => b - a);\n  for(let i = k;\
    \ i < arr.length; i++){\n    let min = Math.min(...res);\n    if(arr[i] < min)\
    \ continue;\n    let idx = res.indexOf(min);\n    res[idx] = arr[i];\n  }\n  return\
    \ res;\n}", "    let maxArr = [];\n    for(let i = 0; i < k; i++){\n        let\
    \ j = 0;\n        let max = -Infinity;\n        let index = 0;\n        while(j\
    \ < arr.length){\n            if(arr[j] > max){\n                max = arr[j];\n\
    \                index = j;\n            }\n            j++;\n        }\n    \
    \    maxArr.push(max);\n        arr.splice(index, 1);\n    }\n    return maxArr;\n\
    }\n", "    arr.sort(function(a, b){\n        return b - a;\n    });\n    return\
    \ arr.slice(0, k);\n}\n", "    // make a sorted copy\n    let sorted = arr.slice().sort((a,b)\
    \ => b-a);\n    // return the sorted copy, cropped to k\n    return sorted.slice(0,k);\n\
    }\n", "  const len = arr.length;\n  const res = [];\n  // find the max number\n\
    \  let max = Math.max(...arr);\n  while(k > 0){\n    // find max number index\n\
    \    let maxIndex = arr.indexOf(max);\n    // push max number to res\n    res.push(max);\n\
    \    // remove the max number from the original array\n    arr.splice(maxIndex,\
    \ 1);\n    // find the next max number\n    max = Math.max(...arr);\n    k--;\n\
    \  }\n  return res;\n}", "    if(k == 0){\n        return [];\n    }\n    if(k\
    \ >= arr.length){\n        return arr.sort(function(a, b){\n            return\
    \ b - a;\n        });\n    }\n    let result = [];\n    for(let i = 0; i < k;\
    \ i++){\n        result.push(arr[i]);\n    }\n    result.sort(function(a, b){\n\
    \        return b - a;\n    });\n    for(let i = k; i < arr.length; i++){\n  \
    \      for(let j = 0; j < k; j++){\n            if(arr[i] > result[j]){\n    \
    \            result.splice(j, 0, arr[i]);\n                result.splice(k, 1);\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\n", "    //Init the max heap\n    let max_heap = new Heap(arr, null, \"max\"\
    );\n    let result = [];\n    //Pop out the element k times\n    for(let i = 0;\
    \ i < k; i++){\n        result.push(max_heap.pop());\n    }\n    return result;\n\
    }\n", "\tif(k == 0){\n\t\treturn [];\n\t}\n\tif(k > arr.length){\n\t\tk = arr.length;\n\
    \t}\n\tvar sortedArray = new Array(k);\n\tfor(var i = 0; i < arr.length; i++){\n\
    \t\tinsert(sortedArray, arr[i]);\n\t}\n\treturn sortedArray;\n}\n", "    const\
    \ n = arr.length;\n    if(k>=n) return arr;\n    const temp = arr.slice(0,k);\n\
    \    for(let i=k;i<n;i++){\n        temp.push(arr[i]);\n        temp.sort((a,b)=>a-b);\n\
    \        temp.pop();\n    }\n    return temp;\n}", "    arr.sort((a,b)=>b-a)\n\
    \    return arr.slice(0,k)\n}", "    if(arr.length == 0 || k == 0) return [];\n\
    \    const ans = [];\n    for(let i = 0; i < arr.length; i++){\n        while(ans.length\
    \ != 0 && ans[ans.length - 1] < arr[i] && ans.length + arr.length - i > k){\n\
    \            ans.pop();\n        }\n        if(ans.length < k){\n            ans.push(arr[i]);\n\
    \        }\n    }\n    return ans;\n}\n", "    arr.sort((a,b)=>a-b);\n    return\
    \ arr.slice(arr.length-k, arr.length);\n}", "\n}\n", "    var result = [];\n \
    \   for(var i = 0; i < k; i++){\n        var minIndex = -1;\n        var max =\
    \ -1001;\n        for(var j = 0; j < arr.length; j++){\n            if(arr[j]\
    \ > max){\n                max = arr[j];\n                minIndex = j;\n    \
    \        }\n        }\n        result.push(max);\n        arr.splice(minIndex,\
    \ 1);\n    }\n    return result;\n}", "  // \u5148\u6392\u5E8F\u518D\u53D6\n \
    \ arr.sort((a, b) => b - a);\n  return arr.slice(0, k);\n}\n", "  let maxArr =\
    \ [];\n  for(let i = 0; i < k; i++){\n    let currMax = -Infinity;\n    let currMaxIdx\
    \ = -1;\n    for(let j = 0; j < arr.length; j++){\n      if(arr[j] > currMax){\n\
    \        currMax = arr[j];\n        currMaxIdx = j;\n      }\n    }\n    maxArr.push(currMax);\n\
    \    arr.splice(currMaxIdx, 1);\n  }\n  return maxArr;\n}\n", "    if(k === 0){\n\
    \        return []\n    }else if(k === arr.length){\n        return arr.sort((a,b)\
    \ => b-a)\n    }\n    let maxHeap = new MaxHeap()\n    for(let i = 0; i < k; i++){\n\
    \        maxHeap.insert(arr[i])\n    }\n    for(let i = k; i < arr.length; i++){\n\
    \        if(arr[i] > maxHeap.peek()){\n            maxHeap.extractMax()\n    \
    \        maxHeap.insert(arr[i])\n        }\n    }\n    let result = []\n    for(let\
    \ i = 0; i < k; i++){\n        result.push(maxHeap.extractMax())\n    }\n    return\
    \ result\n}\n\nclass MaxHeap{\n    constructor(){\n        this.data = []\n  \
    \  }\n    extractMax(){\n        if(this.data.length === 0){\n            return\n\
    \        }\n        let result = this.data[0]\n        let last = this.data.pop()\n\
    \        if(this.data.length > 0){\n            this.data[0] = last\n        \
    \    this.shiftDown(0)\n        }\n        return result\n    }\n    insert(value){\n\
    \        this.data.push(value)\n        this.shiftUp(this.data.length - 1)\n \
    \   }\n    peek(){\n        return this.data[0]\n    }\n    shiftDown(index){\n\
    \        let maxIndex = index\n        let left = 2 * index + 1\n        let right\
    \ = 2 * index + 2\n        if(left < this.data.length && this.data[left] > this.data[maxIndex]){\n\
    \            maxIndex = left\n        }\n        if(right < this.data.length &&\
    \ this.data[right] > this.data[maxIndex]){\n            maxIndex = right\n   \
    \     }\n        if(maxIndex !== index){\n            this.swap(index, maxIndex)\n\
    \            this.shiftDown(maxIndex)\n        }\n    }\n    shiftUp(index){\n\
    \        let parent = Math.floor((index", "  return bubbleSort(arr).slice(0, k);\n\
    }\n", "  arr.sort(function(a, b){\n    return b - a;\n  });\n  return arr.slice(0,\
    \ k);\n}\n", "    let max = arr[0];\n    let ans = [];\n    for(let i = 0; i <\
    \ k; i++){\n        let cur = 0;\n        for(let j = 0; j < arr.length; j++){\n\
    \            if(arr[j] > cur && arr[j] < max){\n                cur = arr[j];\n\
    \            }\n        }\n        ans.push(cur);\n        max = cur;\n    }\n\
    \    return ans;\n}", "    let result = [];\n    //Set the compare function to\
    \ sort by number\n    arr.sort((a,b) => a-b);\n    //Check to see if the array\
    \ is empty\n    if(arr.length === 0){\n        return null;\n    }\n    //Loop\
    \ through the array starting from the end and pushing the top k numbers into result\n\
    \    for(let i = arr.length-1; i >= arr.length-k; i--){\n        result.push(arr[i]);\n\
    \    }\n    return result;\n}\nmodule.exports = maximum;", "    if(arr.length\
    \ == 0 || k == 0){\n        return []\n    }\n    arr.sort((a,b) => b-a)\n   \
    \ return arr.slice(0,k)\n}", "\tarr.sort((a,b)=>b-a);\n\treturn arr.slice(0,k);\n\
    }\n\nmodule.exports = maximum;", "    if(arr.length <= k){\n        return arr.sort((a,b)\
    \ => b-a);\n    }\n\n    let heap = [];\n    //initialize the heap with values\
    \ from the array\n    for(let i = 0; i < k; i++){\n        heap.push(arr[i]);\n\
    \    }\n    //max heap\n    buildMaxHeap(heap);\n    //iterate through the array\n\
    \    for(let i = k; i < arr.length; i++){\n        //if the value is greater than\
    \ the top of the heap, insert it\n        if(arr[i] > heap[0]){\n            heap[0]\
    \ = arr[i];\n            maxHeapify(heap, 0);\n        }\n    }\n    //reverse\
    \ the heap\n    return heap.reverse();\n}\n", "\tfor(var i = 0; i < k; i++){\n\
    \t\tvar max = Number.MIN_SAFE_INTEGER;\n\t\tvar index = -1;\n\t\tfor(var j = i;\
    \ j < arr.length; j++){\n\t\t\tif(arr[j] > max){\n\t\t\t\tmax = arr[j];\n\t\t\t\
    \tindex = j;\n\t\t\t}\n\t\t}\n\t\tarr[index] = arr[i];\n\t\tarr[i] = max;\n\t\
    }\n\treturn arr.slice(0, k);\n}\n", "    var arr = arr.sort((a,b)=>{return a-b}).slice(arr.length-k);\n\
    \    return arr;\n}", "    if(arr.length < k){\n        return []\n    }\n   \
    \ let sorted = arr.sort((a,b) => a - b)\n    return sorted.slice(sorted.length\
    \ - k)\n}\n\nmodule.exports = maximum", "    let result = [];\n    if(arr.length\
    \ == 0 || k == 0){\n        return result;\n    }\n    result = arr.sort((a,b)\
    \ => {return b-a});\n    return result.slice(0,k);\n}\narr = [1,3,5,7,2,4,6,8];\n\
    k = 3;", "    const res = []\n    for(let i = 0; i < arr.length; i++){\n     \
    \   while(res.length > 0 && res[res.length - 1] < arr[i] && res.length + arr.length\
    \ - i > k){\n            res.pop()\n        }\n        if(res.length < k){\n \
    \           res.push(arr[i])\n        }\n    }\n    return res\n}", "    let maxHeap\
    \ = new MaxHeap();\n    for(let i = 0; i < arr.length; i++){\n        maxHeap.insert(arr[i]);\n\
    \    }\n    let output = [];\n    while(k > 0){\n        output.push(maxHeap.remove());\n\
    \        k--;\n    }\n    return output;\n}\n\nclass MaxHeap{\n    constructor(){\n\
    \        this.array = [null];\n    }\n    insert(value){\n        this.array.push(value);\n\
    \        let position = this.array.length - 1;\n        let parent = Math.floor(position/2);\n\
    \        let isGreaterThanParent = () => {\n            return this.array[position]\
    \ > this.array[parent];\n        }\n        while(isGreaterThanParent()){\n  \
    \          this.swap(position, parent);\n            position = parent;\n    \
    \        parent = Math.floor(position/2);\n        }\n    }\n    remove(){\n \
    \       this.swap(1, this.array.length - 1);\n        let maxValue = this.array.pop();\n\
    \        let position = 1;\n        let leftChild = 2 * position;\n        let\
    \ rightChild = 2 * position + 1;\n        let isValid = () => {\n            return\
    \ this.array[position] > this.array[leftChild] || this.array[position] > this.array[rightChild];\n\
    \        }\n        while(!isValid()){\n            let maxChild = this.array[leftChild]\
    \ > this.array[rightChild] ? leftChild : rightChild;\n            this.swap(position,\
    \ maxChild);\n            position = maxChild;\n            leftChild = 2 * position;\n\
    \            rightChild = 2 * position + 1;\n        }\n        return maxValue;\n\
    \    }\n    swap(i, j){\n        let temp = this.array[i];\n        this.array[i]\
    \ = this.array[j];\n        this.array[j] = temp;\n    }\n}\n\nlet numbers = [9,\
    \ 5, 2, 7, 10, 5, 2, 6, 4, 5, 1, 8, 9, 5, 2, 7,", "\n}\n", "    let ans = []\n\
    \    let index = 0\n    for(let i = 0; i < k; i++){\n        ans.push(findMax(arr))\n\
    \    }\n    return ans\n\n    function findMax(arr){\n        let max = arr[0]\n\
    \        let index = 0\n        for(let i = 0; i < arr.length; i++){\n       \
    \     if(arr[i] > max){\n                max = arr[i]\n                index =\
    \ i\n            }\n        }\n        arr.splice(index, 1)\n        return max\n\
    \    }\n}\n", "    let cur = k;\n    let res = [];\n    while(cur > 0){\n    \
    \    let max = arr[0];\n        let index = 0;\n        for(let i = 0; i < arr.length;\
    \ i++){\n            if(arr[i] > max){\n                max = arr[i];\n      \
    \          index = i;\n            }\n        }\n        res.push(max);\n    \
    \    arr.splice(index, 1);\n        cur--;\n    }\n    return res;\n}\n", "  \
    \  return arr.sort((a,b)=>a-b).slice(arr.length-k);\n}\n", "  if(arr.length ==\
    \ 0 || k == 0){\n    return [];\n  }\n\n  return quickSelect(arr, 0, arr.length\
    \ - 1, k - 1);\n}\n", "    // Base case:\n    if(arr.length == k){\n        return\
    \ arr.sort((a,b) => b-a);\n    }\n    // Find pivot:\n    let pivot = arr[0];\n\
    \    let left = [];\n    let right = [];\n    for(let i = 1; i < arr.length; i++){\n\
    \        if(arr[i] < pivot){\n            left.push(arr[i]);\n        } else {\n\
    \            right.push(arr[i]);\n        }\n    }\n    if(right.length >= k){\n\
    \        return maximum(right, k);\n    } else if(right.length == k-1){\n    \
    \    return right.sort((a,b) => b-a);\n    } else {\n        return maximum(left,\
    \ k-right.length-1).concat(pivot).concat(right).sort((a,b) => b-a);\n    }\n}\n\
    let a = [1,2,3,4,5,6,7,8,9,0];", "    if(k > arr.length)\n        return arr;\n\
    \    let bucket = [...Array(1001)].map(_ => []);\n    let min = arr[0];\n    let\
    \ max = arr[0];\n    for(let el of arr){\n        min = Math.min(min, el);\n \
    \       max = Math.max(max, el);\n        bucket[el - min].push(el);\n    }\n\
    \    arr = [];\n    for(let i = max - min; i >= 0; i--){\n        if(bucket[i].length\
    \ > 0)\n            arr.push(...bucket[i]);\n        if(arr.length >= k)\n   \
    \         break;\n    }\n    return arr;\n}\n", "    let result = []\n    for(let\
    \ i = 0; i < k; i++){\n        let max = findMaximum(arr);\n        arr.splice(max,\
    \ 1);\n        result.push(max);\n    }\n    return result;\n}\n", "  arr.sort((a,b)\
    \ => a-b);\n  return arr.slice(arr.length-k);\n}", "\n}", "    arr.sort((a,b)=>b-a);\n\
    \    return arr.slice(0,k);\n}", "\tif(arr === null || arr.length === 0 || k <=\
    \ 0 || k > arr.length){\n\t\treturn [];\n\t}\n\tvar arrLen = arr.length;\n\tvar\
    \ res = [];\n\tvar i = 0;\n\tfor(i = 0; i < k; i++){\n\t\tres.push(arr[i]);\n\t\
    }\n\tres.sort(function(a, b){return a - b;});\n\tfor(i = k; i < arrLen; i++){\n\
    \t\tif(arr[i] > res[0]){\n\t\t\tres[0] = arr[i];\n\t\t\tres.sort(function(a, b){return\
    \ a - b;});\n\t\t}\n\t}\n\treturn res;\n}\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10];", "  return arr.sort((a,b)=>b-a).slice(0,k);\n}\n", "  if(k === 0) return\
    \ [];\n  let maxNumber = -Infinity;\n  let maxIndex = -1;\n  for(let i = 0; i\
    \ < arr.length; i++){\n    if(arr[i] > maxNumber){\n      maxNumber = arr[i];\n\
    \      maxIndex = i;\n    }\n  }\n  return [maxNumber].concat(maximum(arr.slice(0,\
    \ maxIndex).concat(arr.slice(maxIndex + 1)), k - 1));\n}", "    const result =\
    \ [];\n    let index = 0;\n    const len = arr.length;\n    while(result.length\
    \ < k){\n        let max = -Number.MAX_VALUE;\n        for(let i = index; i <\
    \ len; i++){\n            const curr = arr[i];\n            if(curr > max){\n\
    \                max = curr;\n                index = i;\n            }\n    \
    \    }\n        result.push(max);\n        index++;\n    }\n    return result;\n\
    }\n", "\treturn arr.sort((a,b)=>b-a).slice(0,k);\n}", "  if(arr.length === 0 ||\
    \ k === 0) return [];\n  if(arr.length === 1) return arr;\n  if(arr.length ===\
    \ k) return arr.sort((a,b) => b-a);\n  let index = arr.length - k;\n  let smaller\
    \ = arr[0];\n  let smallerIndex = 0;\n  for(let i = 1; i <= index; i++){\n   \
    \ if(arr[i] < smaller){\n      smaller = arr[i];\n      smallerIndex = i;\n  \
    \  }\n  }\n  arr.splice(smallerIndex, 1);\n  return maximum(arr, k);\n}\n", " \
    \   if(arr.length == 0 || k == 0) return []\n    let result = []\n    let left\
    \ = 0\n    let right = arr.length - 1\n    while(result.length < k){\n       \
    \ let currMax = -Infinity\n        let currMaxIndex = -1\n        for(let i =\
    \ left; i <= right; i++){\n            if(arr[i] > currMax){\n               \
    \ currMax = arr[i]\n                currMaxIndex = i\n            }\n        }\n\
    \        result.push(currMax)\n        left = currMaxIndex + 1\n    }\n    return\
    \ result\n}\n", "\t\n}", "    //Sort the array in ascending order\n    arr.sort((a,b)\
    \ => a-b);\n    //Get the slice of the array, starting from the last index to\
    \ the k\n    return arr.slice(arr.length-k);\n}\n\nconst arr = [1,2,3,4,5,6,7,8,9,10];",
  "    let max = new Array(k);\n    for(let i = 0; i < k; i++){\n        let idx =\
    \ 0;\n        for(let j = 0; j < arr.length; j++){\n            if(arr[j] > arr[idx]){\n\
    \                idx = j;\n            }\n        }\n        max[i] = arr[idx];\n\
    \        arr[idx] = -Infinity;\n    }\n    return max;\n}\n", "  let sorted =\
    \ arr.sort((a,b) => b-a);\n  let res = [];\n  for(let i = 0; i < k; i++){\n  \
    \  res.push(sorted[i]);\n  }\n  return res;\n}\n\nlet arr = [5,8,5,3,5,6,9,5,6,0];",
  "    let res = []\n    // console.log(arr)\n    while(res.length < k){\n       \
    \ let curr = -Infinity\n        let index = -1\n        for(let i = 0; i < arr.length;\
    \ i++){\n            if(arr[i] > curr){\n                curr = arr[i]\n     \
    \           index = i\n            }\n        }\n        arr.splice(index, 1)\n\
    \        res.push(curr)\n    }\n    return res\n}\n", "  // Given an array of\
    \ positive and negative integers, rearrange the array such that \n  // all negative\
    \ integers appear before all the positive integers in the array without using\
    \ any additional data structure like hash table, arrays, etc. The order of appearance\
    \ should be maintained.\n  // Ex: Input:  [12 11 -13 -5 6 -7 5 -3 -6]\n  //  \
    \    Output: [-13 -5 -7 -3 -6 12 11 6 5]\n  // Ex: Input: [12 -7 5 -13 -5 -6]\n\
    \  //      Output: [-13 -5 -7 12 5 -6]\n  // The problem does not have any constraint\
    \ to use extra data structure.\n  // Ex: Input: [12 11 -13 -5 6 -7 5 -3 -6]\n\
    \  //      Output: [-13 -5 -7 -3 -6 12 11 6 5]\n  let s = arr.length;\n  let left\
    \ = 0;\n  let right = s - 1;\n  while(left < right){\n    while(arr[left] < 0\
    \ && left < right){\n      left ++;\n    }\n    while(arr[right] > 0 && left <\
    \ right){\n      right --;\n    }\n    if(left < right){\n      let temp = arr[left];\n\
    \      arr[left] = arr[right];\n      arr[right] = temp;\n    }\n  }\n  return\
    \ arr;\n}", "    var result = arr.slice(0, k).sort((a, b) => a-b);\n    for(var\
    \ i = k; i < arr.length; i++){\n        var j = 0;\n        for(; j < k; j++){\n\
    \            if(arr[i] > result[j]){\n                result[j] = arr[i];\n  \
    \              break;\n            }\n        }\n        if(j < k){\n        \
    \    var pos = j;\n            for(var l = j-1; l >= 0; l--){\n              \
    \  if(result[l] > result[l+1]){\n                    var temp = result[l];\n \
    \                   result[l] = result[l+1];\n                    result[l+1]\
    \ = temp;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n", "    var result = [];\n    if(arr.length === 0 || k === 0) return result;\n\
    \    for(var i = 0; i < arr.length; i++){\n        for(var j = result.length -\
    \ 1; j >= 0; j--){\n            if(arr[i] > result[j]){\n                result.splice(j\
    \ + 1, 0, arr[i]);\n                if(result.length > k) result.pop();\n    \
    \            break;\n            }\n        }\n        if(j === -1) result.unshift(arr[i]);\n\
    \        if(result.length > k) result.pop();\n    }\n    return result;\n}", " \
    \ let result = [];\n  let max = -Infinity;\n  let maxIndex = -1;\n  while(result.length\
    \ < k){\n    max = -Infinity;\n    maxIndex = -1;\n    for(let i = 0; i < arr.length;\
    \ i++){\n      if(arr[i] > max){\n        max = arr[i];\n        maxIndex = i;\n\
    \      }\n    }\n    result.push(max);\n    arr.splice(maxIndex, 1);\n  }\n  return\
    \ result;\n}\nmodule.exports = maximum;", "    if(arr.length === 0 || k === 0){\n\
    \        return [];\n    }\n    const result = [];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        const val = arr[i];\n        if(result.length < k){\n       \
    \     if(result.length === 0){\n                result.push(val);\n          \
    \  } else {\n                let l = 0;\n                let r = result.length\
    \ - 1;\n                while(l <= r){\n                    const mid = l + Math.floor((r\
    \ - l) / 2);\n                    if(result[mid] < val){\n                   \
    \     l = mid + 1;\n                    } else {\n                        r =\
    \ mid - 1;\n                    }\n                }\n                result.splice(l,\
    \ 0, val);\n            }\n        } else {\n            if(result[k - 1] < val){\n\
    \                result.pop();\n                let l = 0;\n                let\
    \ r = result.length - 1;\n                while(l <= r){\n                   \
    \ const mid = l + Math.floor((r - l) / 2);\n                    if(result[mid]\
    \ < val){\n                        l = mid + 1;\n                    } else {\n\
    \                        r = mid - 1;\n                    }\n               \
    \ }\n                result.splice(l, 0, val);\n            }\n        }\n   \
    \ }\n    return result;\n}\n", "    arr.sort(function(a, b){return b-a});\n  \
    \  return arr.slice(0, k);\n}", "    var maxArray = [];\n    var i = 0;\n    while(i\
    \ < k){\n        var max = arr[0];\n        var maxIndex = 0;\n        for(var\
    \ j = 0; j < arr.length; j++){\n            if(arr[j] > max){\n              \
    \  max = arr[j];\n                maxIndex = j;\n            }\n        }\n  \
    \      maxArray.push(max);\n        arr.splice(maxIndex, 1);\n        i++;\n \
    \   }\n    return maxArray;\n}", "\tvar data = [];\n\tvar i = 0;\n\twhile(data.length\
    \ < k){\n\t\tif(data.length === 0){\n\t\t\tdata.push(arr[i]);\n\t\t}\n\t\telse{\n\
    \t\t\tvar index = data.length - 1;\n\t\t\twhile(index >= 0 && data[index] < arr[i]){\n\
    \t\t\t\tindex--;\n\t\t\t}\n\t\t\tdata.splice(index + 1, 0, arr[i]);\n\t\t}\n\t\
    \ti++;\n\t}\n\twhile(i < arr.length){\n\t\tif(arr[i] > data[0]){\n\t\t\tdata.splice(0,\
    \ 1);\n\t\t\tvar index = data.length - 1;\n\t\t\twhile(index >= 0 && data[index]\
    \ < arr[i]){\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\tdata.splice(index + 1, 0, arr[i]);\n\
    \t\t}\n\t\ti++;\n\t}\n\treturn data;\n}", "  let sorted = arr.sort((a,b) => a-b)\n\
    \  let solution = []\n  for(let i = sorted.length-1; i > sorted.length-k-1; i--){\n\
    \    solution.push(sorted[i])\n  }\n  return solution\n}\n", "    var n = arr.length;\n\
    \    if(k >= n){\n        return arr.sort(function(a, b){\n            return\
    \ b - a;\n        });\n    }\n    var heap = new Heap();\n    var result = [];\n\
    \    for(var i = 0; i < k; i++){\n        heap.add(arr[i]);\n    }\n    for(var\
    \ i = k; i < n; i++){\n        if(arr[i] > heap.peek()){\n            heap.poll();\n\
    \            heap.add(arr[i]);\n        }\n    }\n    while(!heap.isEmpty()){\n\
    \        result.push(heap.poll());\n    }\n    return result;\n}\n\nvar Heap =\
    \ function(){\n    this.items = [];\n    this.compare = function(a, b){\n    \
    \    return a - b;\n    }\n    this.size = function(){\n        return this.items.length;\n\
    \    }\n    this.isEmpty = function(){\n        return this.items.length === 0;\n\
    \    }\n    this.clear = function(){\n        this.items = [];\n    }\n    this.poll\
    \ = function(){\n        if(this.items.length === 0){\n            return null;\n\
    \        }\n        var result = this.items[0];\n        this.items[0] = this.items[this.items.length\
    \ - 1];\n        this.items.pop();\n        this.heapifyDown();\n        return\
    \ result;\n    }\n    this.add = function(value){\n        this.items.push(value);\n\
    \        this.heapifyUp();\n    }\n    this.heapifyUp = function(){\n        var\
    \ index = this.items.length - 1;\n        while(this.hasParent(index) && this.compare(this.parent(index),\
    \ this.items[index]) > 0){\n            this.swap(this.getParentIndex(index),\
    \ index);\n            index = this.getParentIndex(index);\n        }\n    }\n\
    \    this.heapifyDown = function(){\n        var index = 0;\n        while(this.hasLeftChild(index)){\n",
  "    let res = [];\n    let stack = [];\n    for(let i = 0; i < arr.length; i++){\n\
    \        while(stack.length && arr[i] > stack[stack.length - 1] && stack.length\
    \ + arr.length - i > k){\n            stack.pop();\n        }\n        if(stack.length\
    \ < k){\n            stack.push(arr[i]);\n        }\n    }\n    return stack;\n\
    }\n", "    const ans = [];\n    for(let i = 0; i < arr.length; i++){\n       \
    \ let n = arr[i];\n        for(let j = 0; j < ans.length; j++){\n            if(n\
    \ > ans[j]){\n                ans.splice(j, 0, n);\n                break;\n \
    \           }\n        }\n        if(ans.length == 0){\n            ans.push(n);\n\
    \        }\n        else if(ans.length < k){\n            ans.push(n);\n     \
    \   }\n        else{\n            ans.pop();\n        }\n    }\n    return ans;\n\
    }\n", "    let length = arr.length;\n    let start = 0;\n    let end = length\
    \ - 1;\n    while(start < end){\n        let pivotIndex = partition(arr, start,\
    \ end);\n        if(pivotIndex < k){\n            start = pivotIndex + 1;\n  \
    \      }else if(pivotIndex > k){\n            end = pivotIndex - 1;\n        }else{\n\
    \            return arr.slice(0, k);\n        }\n    }\n    return arr.slice(0,\
    \ k);\n}\n", "    return arr.sort((a,b)=>b-a).slice(0,k);\n}\n", "    let arr_copy\
    \ = arr.slice();\n    let output = [];\n    for(let i = 0; i < k; i++){\n    \
    \    let max = Math.max(...arr_copy);\n        output.push(max);\n        arr_copy.splice(arr_copy.indexOf(max),\
    \ 1);\n    }\n    return output;\n}", "  let left = 0;\n  let right = arr.length\
    \ - 1;\n  while(left < right){\n    swap(arr, Math.floor(Math.random() * (right\
    \ - left + 1)) + left, right);\n    let index = partition(arr, left, right);\n\
    \    if(index === k){\n      break;\n    }\n    if(index < k){\n      left = index\
    \ + 1;\n    }else{\n      right = index - 1;\n    }\n  }\n  arr.length = k;\n\
    \  return arr;\n}\n", "    let maxes = []\n    let result = []\n    arr.forEach(ele\
    \ => {\n        maxes.push(ele)\n        maxes.sort((a,b) => b-a)\n        if(maxes.length\
    \ > k){\n            maxes.pop()\n        }\n    })\n    for(let i = 0; i < k;\
    \ i++){\n        result.push(maxes.pop())\n    }\n    return result\n}", "  //priority\
    \ queue\n  let heap = new Heap();\n  for(let i = 0; i < arr.length; i++){\n  \
    \  if(heap.length < k){\n      heap.push(arr[i]);\n    }else{\n      if(arr[i]\
    \ > heap.peek()){\n        heap.pop();\n        heap.push(arr[i]);\n      }\n\
    \    }\n  }\n  let result = [];\n  for(let i = 0; i < k; i++){\n    result.push(heap.pop());\n\
    \  }\n  return result;\n}\n", "  if(arr.length === k) return arr.sort((a,b) =>\
    \ b-a);\n  let result = arr.slice(0, k).sort((a,b) => b-a);\n  for(let i = k;\
    \ i < arr.length; i++){\n    let j = k-1;\n    while(j >= 0 && arr[i] > result[j]){\n\
    \      j--;\n    }\n    if(j < k-1){\n      result.splice(j+1, 0, arr[i]);\n \
    \     result.pop();\n    }\n  }\n  return result;\n}\n", "    let heap = new MaxHeap();\n\
    \    for(let i = 0; i < arr.length; i++){\n        heap.insert(arr[i]);\n    }\n\
    \    let result = [];\n    for(let i = 0; i < k; i++){\n        result.push(heap.extractMax());\n\
    \    }\n    return result;\n}\n", "    let res = arr.slice(0, k).sort((a, b) =>\
    \ a - b);\n    for(let i = k; i < arr.length; i++){\n        if(arr[i] > res[0]){\n\
    \            for(let j = 0; j < k; j++){\n                if(arr[i] > res[j]){\n\
    \                    res[j] = arr[i];\n                    break;\n          \
    \      }\n            }\n        }\n    }\n    return res;\n}\nlet arr = [1, 3,\
    \ 5, 4, 6, 7, 8];", "    if(arr.length < k) return arr;\n    for(let i = 0; i\
    \ < k; i++){\n        for(let j = 0; j < arr.length; j++){\n            if(arr[i]\
    \ > arr[j]){\n                let temp = arr[i];\n                arr[i] = arr[j];\n\
    \                arr[j] = temp;\n            }\n        }\n    }\n    let result\
    \ = [];\n    for(let i = 0; i < k; i++){\n        result.push(arr[i]);\n    }\n\
    \    return result;\n}\n", "  // base case\n  // find the minimum in the arr\n\
    \  // recurse on arr.slice(1) until the min is k\n}\n", "    let result = [];\n\
    \    let min = arr[0];\n    let max = arr[0];\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(arr[i] < min){\n            min = arr[i];\n        }\n   \
    \     if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    result.push(min);\n\
    \    for(let i = 0; i < k - 1; i++){\n        let tempMax = result[0];\n     \
    \   for(let j = 0; j < arr.length; j++){\n            if(arr[j] > tempMax && !result.includes(arr[j])){\n\
    \                tempMax = arr[j];\n            }\n        }\n        result.push(tempMax);\n\
    \    }\n    return result;\n}\n", "    let result = [], i = 0, n = arr.length\
    \ - 1;\n    while(i < k){\n        result.push(arr[n - i]);\n        i++;\n  \
    \  }\n    return result;\n}\n", "  let output = [];\n  for(let i = 0; i < k; i++){\n\
    \    let max = arr[0];\n    let maxIndex = 0;\n    for(let j = 0; j < arr.length;\
    \ j++){\n      if(arr[j] > max){\n        max = arr[j];\n        maxIndex = j;\n\
    \      }\n    }\n    output.push(max);\n    arr.splice(maxIndex, 1);\n  }\n  return\
    \ output;\n}\n", "  if(arr === null || arr.length === 0) return [];\n  if(k >\
    \ arr.length) return arr;\n  let res = [];\n  for(let i = 0; i < arr.length; i++){\n\
    \    while(res.length > 0 && res[res.length - 1] < arr[i] && res.length + arr.length\
    \ - i > k){\n      res.pop();\n    }\n    if(res.length < k){\n      res.push(arr[i]);\n\
    \    }\n  }\n  return res;\n}\n", "    // \n    if(k == 0){\n        return [];\n\
    \    }\n    if(k >= arr.length){\n        return arr.sort((a,b) => {\n       \
    \     return b - a;\n        });\n    }\n    let maxArr = [];\n    for(let i =\
    \ 0; i < k; i++){\n        let max = -Infinity;\n        let index = -1;\n   \
    \     for(let j = 0; j < arr.length; j++){\n            if(arr[j] > max){\n  \
    \              max = arr[j];\n                index = j;\n            }\n    \
    \    }\n        maxArr.push(max);\n        arr.splice(index, 1);\n    }\n    return\
    \ maxArr;\n}", "    // create priority queue\n    let PQ = new PriorityQueue();\n\
    \    // loop from i = 0 to i = arr.length\n    for(let i = 0; i < arr.length;\
    \ i++){\n        PQ.enqueue(arr[i]);\n    }\n    let output = [];\n    for(let\
    \ i = 0; i < k; i++){\n        output.push(PQ.dequeue());\n    }\n    return output;\n\
    }\n", "  // base cases\n  if(arr.length === 0) return [];\n  if(arr.length <=\
    \ k) return arr;\n  var result = arr.slice(0, k);\n  result.sort((a, b) => b -\
    \ a);\n  for(var i = k; i < arr.length; i++){\n    var x = arr[i];\n    var idx\
    \ = 0;\n    while(idx < k && result[idx] >= x) idx++;\n    if(idx < k){\n    \
    \  result.splice(idx, 0, x);\n      result.pop();\n    }\n  }\n  return result;\n\
    }\n\nmodule.exports = maximum;", "\tif(arr.length < k){\n\t\treturn null;\n\t\
    }\n\n\tconst heap = new MinHeap();\n\tfor(let i = 0; i < k; i++){\n\t\theap.insert(arr[i]);\n\
    \t}\n\n\tfor(let i = k; i < arr.length; i++){\n\t\tif(arr[i] > heap.peek()){\n\
    \t\t\theap.pop();\n\t\t\theap.insert(arr[i]);\n\t\t}\n\t}\n\n\treturn heap.values;\n\
    }\n\nclass MinHeap{\n\tconstructor(){\n\t\tthis.values = [];\n\t}\n\n\tinsert(val){\n\
    \t\tthis.values.push(val);\n\t\tthis.bubbleUp();\n\t}\n\n\tbubbleUp(){\n\t\tlet\
    \ index = this.values.length - 1;\n\t\tconst element = this.values[index];\n\t\
    \twhile(index > 0){\n\t\t\tlet parentIndex = Math.floor((index - 1) / 2);\n\t\t\
    \tlet parent = this.values[parentIndex];\n\t\t\tif(element >= parent){\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t\tthis.values[parentIndex] = element;\n\t\t\tthis.values[index]\
    \ = parent;\n\t\t\tindex = parentIndex;\n\t\t}\n\t}\n\n\textractMin(){\n\t\tconst\
    \ min = this.values[0];\n\t\tconst end = this.values.pop();\n\t\tif(this.values.length\
    \ > 0){\n\t\t\tthis.values[0] = end;\n\t\t\tthis.sinkDown();\n\t\t}\n\t\treturn\
    \ min;\n\t}\n\n\tsinkDown(){\n\t\tlet index = 0;\n\t\tconst length = this.values.length;\n\
    \t\tconst element = this.values[0];\n\t\twhile(true){\n\t\t\tlet leftChildIndex\
    \ = 2 * index + 1;\n\t\t\tlet rightChildIndex = 2 * index + 2;\n\t\t\tlet leftChild,\
    \ rightChild;\n\t\t\tlet swap = null;\n\n\t\t\tif(leftChildIndex < length){\n\t\
    \t", "    let sortedArr = arr.sort((a,b) => b-a);\n    return sortedArr.slice(0,k);\n\
    }\n", "    let result = [];\n    let sortedArr = [];\n    let maxVal = -Infinity;\n\
    \    let maxValIndex = 0;\n    let counter = 0;\n    while(counter < k){\n   \
    \     for(let i = 0; i < arr.length; i++){\n            if(arr[i] >= maxVal){\n\
    \                maxVal = arr[i];\n                maxValIndex = i;\n        \
    \    }\n        }\n        result.push(maxVal);\n        arr[maxValIndex] = -Infinity;\n\
    \        maxVal = -Infinity;\n        counter++;\n    }\n    return result;\n\
    }\n", "    // time and space O(n log k)\n    let heap = [];\n    let result =\
    \ [];\n    arr.forEach(n => {\n        if(heap.length < k){\n            heap.push(n);\n\
    \            heap = heap.sort((a,b) => a - b);\n        } else if(n > heap[0]){\n\
    \            heap[0] = n;\n            heap = heap.sort((a,b) => a - b);\n   \
    \     }\n    });\n    return heap;\n}\n", "\n}", "    if(arr.length <= k){\n \
    \       return arr.sort((a,b) => a-b)\n    }\n    const maxHeap = new MaxHeap(k);\n\
    \    for(let i = 0; i < arr.length; i++){\n        maxHeap.add(arr[i]);\n    }\n\
    \    return maxHeap.array();\n}\n", "    const map = {};\n    const memo = {};\n\
    \    arr.forEach(val => {\n        const key = val.toString();\n        if (map[key])\
    \ {\n            map[key] += 1;\n        } else {\n            map[key] = 1;\n\
    \        }\n    });\n    for (let key in map) {\n        if (map[key] > 1) {\n\
    \            memo[key] = map[key];\n        }\n    }\n    return Object.keys(memo).length\
    \ >= k ? Object.keys(memo).slice(0, k) : null;\n}", "    if(arr.length == 0 ||\
    \ k == 0){\n        return [];\n    }\n    var results = [];\n    var curr = 0;\n\
    \    while(curr < k){\n        if(results.length == 0){\n            results.push(arr[curr]);\n\
    \        }\n        else if(arr[curr] > results[results.length - 1]){\n      \
    \      results.push(arr[curr]);\n        }\n        else{\n            let i =\
    \ 0;\n            while(arr[curr] > results[i]){\n                i++;\n     \
    \       }\n            results.splice(i, 0, arr[curr]);\n        }\n        curr++;\n\
    \    }\n    while(curr < arr.length){\n        if(arr[curr] > results[results.length\
    \ - 1]){\n            results.push(arr[curr]);\n            results.splice(0,\
    \ 1);\n        }\n        else if(arr[curr] < results[0]){\n            curr++;\n\
    \        }\n        else{\n            let i = 0;\n            while(arr[curr]\
    \ > results[i]){\n                i++;\n            }\n            results.splice(i,\
    \ 0, arr[curr]);\n            results.splice(0, 1);\n        }\n        curr++;\n\
    \    }\n    return results;\n}", "    if(arr.length == 0 || k == 0) return arr;\n\
    \    if(arr.length < k) return arr.sort((a,b) => b-a);\n    let stack = [];\n\
    \    for(let i = 0; i < arr.length; i++){\n        while(stack.length > 0 && stack[stack.length-1]\
    \ < arr[i] && stack.length + arr.length - i - 1 >= k){\n            stack.pop();\n\
    \        }\n        stack.push(arr[i]);\n    }\n    return stack;\n}", "    //\n\
    \    //This is the naive approach.\n    //I'm only including it to demonstrate\
    \ that the algo works and to show the order of magnitude of the solution.\n  \
    \  //\n    //return arr.sort((a,b)=>b-a).slice(0,k);\n\n    //\n    //Heap approach.\
    \ \n    //\n    //the heap will always be k size (or less)\n    //iterate over\
    \ arr, push each item into the heap\n    //if the heap is at k size and the next\
    \ item is less than the smallest item in the heap, ignore it\n    //if the heap\
    \ is at k size and the next item is greater than the smallest item in the heap,\
    \ then pop and push\n    //\n    //returns a sorted array of length k\n    //\n\
    \    //order of magnitude is ~O(nlogk)\n\n    let heap = [];\n    let maxHeap\
    \ = (a,b)=>b-a;\n    let minHeap = (a,b)=>a-b;\n\n    for(let i = 0; i < arr.length;\
    \ i++){\n        if(heap.length < k){\n            heap.push(arr[i]);\n      \
    \      heap = heap.sort(maxHeap);\n        }else if(arr[i] > heap[0]){\n     \
    \       heap.shift();\n            heap.push(arr[i]);\n            heap = heap.sort(maxHeap);\n\
    \        }\n    }\n\n    return heap;\n}\n", "    let result = []\n    arr.sort((a,b)=>b-a)\n\
    \    while(k>0){\n        let i = 0\n        while(i<arr.length){\n          \
    \  if(arr[i]<=arr[k-1]) break\n            result.push(arr[i])\n            i++\n\
    \        }\n        k--\n    }\n    return result\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
