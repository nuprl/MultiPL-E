name: HumanEval_6_parse_nested_parens
language: js
prompt: "//Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\nfunction parse_nested_parens(paren_string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = parse_nested_parens;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"\
  ),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[1,\
  \ 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[4]);\n}\n\ntest();"
completions: ["  if(!paren_string){\n    return 0;\n  }\n  paren_string = paren_string.replace(/\\\
    s/g,'');\n  if(paren_string.length === 0){\n    return 0;\n  }\n  let max = 0;\n\
    \  let current_count = 0;\n  for(let p of paren_string){\n    if(p === '('){\n\
    \      current_count++;\n      max = current_count > max ? current_count : max;\n\
    \    }else if(p === ')'){\n      current_count--;\n    }\n  }\n  return max;\n\
    }", "\tvar parts = paren_string.split(\" \");\n\tvar paren_nestings = new Array();\n\
    \tfor(i = 0; i < parts.length; i++){\n\t\tvar depth = 0;\n\t\tvar current_max\
    \ = 0;\n\t\tfor(j = 0; j < parts[i].length; j++){\n\t\t\tif(parts[i][j] == \"\
    (\"){\n\t\t\t\tdepth++;\n\t\t\t\tif(depth > current_max){\n\t\t\t\t\tcurrent_max\
    \ = depth;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(parts[i][j] == \")\"){\n\t\t\t\t\
    depth--;\n\t\t\t}\n\t\t}\n\t\tparen_nestings.push(current_max);\n\t}\n\treturn\
    \ paren_nestings;\n}\n", "  //Array to store depth of each group\n  var depths\
    \ = [];\n  //Array to store strings of nested groups\n  var groups = paren_string.split(\"\
    \ \");\n  //Trim leading/trailing whitespace\n  groups = groups.map(function(group){return\
    \ group.trim();});\n  for(var i = 0; i < groups.length; i++){\n    var group =\
    \ groups[i];\n    var group_depth = 0;\n    var max_depth = 0;\n    for(var j\
    \ = 0; j < group.length; j++){\n      if(group[j] == \"(\"){\n        group_depth++;\n\
    \        max_depth = Math.max(max_depth, group_depth);\n      }else if(group[j]\
    \ == \")\"){\n        group_depth--;\n      }\n    }\n    //Add max depth of this\
    \ group to depths array\n    depths.push(max_depth);\n  }\n  return depths;\n\
    }\n", "  return paren_string.split(' ').map(function(parens){\n    return parse_parens(parens);\n\
    \  });\n}\n", "    const paren_ary = paren_string.split(' ');\n    let result\
    \ = [];\n    for(let i = 0; i < paren_ary.length; i++){\n        result.push(paren_counter(paren_ary[i]));\n\
    \    }\n    return result;\n}\n", "\tvar parens = paren_string.split(\" \");\n\
    \tvar max_nesting = 0;\n\tfor(var i = 0; i < parens.length; i++){\n\t\tvar paren\
    \ = parens[i];\n\t\tvar curr_nesting = 0;\n\t\tvar max_curr_nesting = 0;\n\t\t\
    for(var j = 0; j < paren.length; j++){\n\t\t\tif(paren[j] == \"(\"){\n\t\t\t\t\
    curr_nesting++;\n\t\t\t\tif(curr_nesting > max_curr_nesting){\n\t\t\t\t\tmax_curr_nesting\
    \ = curr_nesting;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(paren[j] == \")\"){\n\t\t\
    \t\tcurr_nesting--;\n\t\t\t}\n\t\t}\n\t\tif(max_curr_nesting > max_nesting){\n\
    \t\t\tmax_nesting = max_curr_nesting;\n\t\t}\n\t}\n\treturn max_nesting;\n}\n",
  "  var start_time = new Date().getTime();\n  var paren_list = paren_string.split(\"\
    \ \");\n  var max_depth = 0;\n  for(var i = 0; i < paren_list.length; i++){\n\
    \    var curr_paren = paren_list[i];\n    var paren_depth = 0;\n    for(var j\
    \ = 0; j < curr_paren.length; j++){\n      if(curr_paren[j] == '('){\n       \
    \ paren_depth += 1;\n      }\n      else if(curr_paren[j] == ')'){\n        paren_depth\
    \ -= 1;\n      }\n    }\n    if(paren_depth > max_depth){\n      max_depth = paren_depth;\n\
    \    }\n  }\n  var end_time = new Date().getTime();\n  console.log(\"find_max_nesting_parens():\
    \ \" + (end_time - start_time) + \" ms\");\n  return max_depth;\n}\n\n", "  let\
    \ results = [];\n  let max_result = 0;\n  let paren_arr = paren_string.split(\"\
    \ \");\n  for(let i = 0; i < paren_arr.length; i++){\n    let paren_group = paren_arr[i];\n\
    \    let level = 0;\n    let max_level = 0;\n    for(let j = 0; j < paren_group.length;\
    \ j++){\n      if(paren_group[j] === \"(\"){\n        level++;\n        if(level\
    \ > max_level){\n          max_level = level;\n        }\n      }\n      else\
    \ if(paren_group[j] === \")\"){\n        level--;\n      }\n    }\n    results.push(max_level);\n\
    \    if(max_level > max_result){\n      max_result = max_level;\n    }\n  }\n\
    \  return [results, max_result];\n}\n", "    var paren_groups = paren_string.split(\"\
    \ \");\n    var max_nesting = 0;\n    for(var i = 0; i < paren_groups.length;\
    \ i++){\n        var group = paren_groups[i];\n        var paren_stack = [];\n\
    \        for(var j = 0; j < group.length; j++){\n            var paren = group[j];\n\
    \            if(paren == \"(\"){\n                paren_stack.push(paren);\n \
    \           }else if(paren == \")\"){\n                paren_stack.pop();\n  \
    \          }\n        }\n        max_nesting = Math.max(max_nesting, paren_stack.length);\n\
    \    }\n    return max_nesting;\n}\n\nvar test_parens = \"((()))(()())(())(()(()))\"\
    ;\nvar paren_nesting = parse_nested_parens(test_parens);", "  var paren_arr =\
    \ paren_string.split(\" \");\n  var output = [];\n  for(var i = 0; i < paren_arr.length;\
    \ i++){\n    output.push(deepest_nested_parens(paren_arr[i]));\n  }\n  return\
    \ output;\n}\n", "  var max_depth = 0;\n  var curr_depth = 0;\n  for(var i = 0;\
    \ i < paren_string.length; i++){\n    if(paren_string[i] == '('){\n      curr_depth++;\n\
    \      if(curr_depth > max_depth){\n        max_depth = curr_depth;\n      }\n\
    \    }\n    else if(paren_string[i] == ')'){\n      curr_depth--;\n    }\n  }\n\
    \  return max_depth;\n}\n", "    var groups = paren_string.split(\" \");\n   \
    \ var res = [];\n    for(var i = 0; i < groups.length; i++){\n        var stack\
    \ = [];\n        var max_nest = 0;\n        var cur_nest = 0;\n        for(var\
    \ j = 0; j < groups[i].length; j++){\n            if(groups[i][j] == \"(\"){\n\
    \                cur_nest++;\n                if(cur_nest > max_nest){\n     \
    \               max_nest = cur_nest;\n                }\n            }\n     \
    \       else if(groups[i][j] == \")\"){\n                cur_nest--;\n       \
    \     }\n        }\n        res.push(max_nest);\n    }\n    return res;\n}", " \
    \   var max_depth = 0;\n    var current_depth = 0;\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == '('){\n            current_depth++;\n \
    \           if(current_depth > max_depth){\n                max_depth = current_depth;\n\
    \            }\n        }\n        else if(paren_string[i] == ')'){\n        \
    \    current_depth--;\n        }\n    }\n    return max_depth;\n}\n", "    //\
    \ loop through each paren group\n    var paren_array = paren_string.split(\" \"\
    );\n    var deepest_parens = [];\n    paren_array.forEach(function(paren_group){\n\
    \        // keep track of the current and deepest level for each group\n     \
    \   var current_level = 0;\n        var deepest_level = 0;\n        // loop through\
    \ each paren\n        for(var i = 0; i < paren_group.length; i++){\n         \
    \   if(paren_group[i] === \"(\"){\n                current_level++;\n        \
    \        if(current_level > deepest_level){\n                    deepest_level\
    \ = current_level;\n                }\n            }\n            else if(paren_group[i]\
    \ === \")\"){\n                current_level--;\n            }\n        }\n  \
    \      deepest_parens.push(deepest_level);\n    });\n    return deepest_parens;\n\
    }\n", "    var count = 0;\n    var d_count = 0;\n    var count_array = [];\n \
    \   for(var i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === '('){\n            count++;\n            if(count > d_count){\n        \
    \        d_count = count;\n            }\n        }\n        else if(paren_string[i]\
    \ === ')'){\n            count--;\n        }\n        else if(paren_string[i]\
    \ === ' '){\n            count_array.push(d_count);\n            d_count = 0;\n\
    \            count = 0;\n        }\n    }\n    count_array.push(d_count);\n  \
    \  return count_array;\n}\n", "\tvar base_level = 0;\n\tvar levels = [];\n\tvar\
    \ i, j;\n\tfor(i = 0; i < paren_string.length; i++){\n\t\tif(paren_string[i] ==\
    \ '('){\n\t\t\tbase_level++;\n\t\t\tfor(j = 0; j < levels.length; j++){\n\t\t\t\
    \tlevels[j]++;\n\t\t\t}\n\t\t}\n\t\telse if(paren_string[i] == ')'){\n\t\t\tlevels.push(base_level);\n\
    \t\t\tbase_level = 0;\n\t\t}\n\t}\n\tconsole.log(levels);\n}\n", "    var results\
    \ = [];\n    var index = 0;\n    var paren_arr = paren_string.split(\" \");\n\
    \    for(var i = 0; i < paren_arr.length; i++){\n        var max_depth = 1;\n\
    \        var count = 0;\n        for(var j = 0; j < paren_arr[i].length; j++){\n\
    \            if(paren_arr[i][j] == \"(\"){\n                count++;\n       \
    \         if(count > max_depth){\n                    max_depth = count;\n   \
    \             }\n            }else if(paren_arr[i][j] == \")\"){\n           \
    \     count--;\n            }\n        }\n        results[index] = max_depth;\n\
    \        index++;\n    }\n    return results;\n}", "    var paren_array = paren_string.split(\"\
    \ \"); //convert string to array\n\n    paren_array.forEach(function(str){\n \
    \       var n = 0; //number of open parentheses\n        var current_max = 0;\n\
    \        var max = 0;\n\n        //loop through characters in string\n       \
    \ for(var i = 0; i < str.length; i++){\n            if(str[i] == \"(\") n++;\n\
    \            else if(str[i] == \")\") n--;\n\n            //update current_max\
    \ to max if needed\n            if(n > current_max) current_max = n;\n       \
    \     else if(n < 0) return console.log(\"invalid input: \"+ str);\n        }\n\
    \n        //compare current_max to max\n        if(current_max > max) max = current_max;\n\
    \n        console.log(max);\n    });\n}\n", "    var result = [];\n    paren_string.split('\
    \ ').forEach(function(paren_group){\n        var level = 0;\n        var max_level\
    \ = 0;\n        paren_group.split('').forEach(function(char){\n            switch(char){\n\
    \                case '(':\n                    ++level;\n                   \
    \ break;\n                case ')':\n                    --level;\n          \
    \          break;\n            }\n            if(level > max_level){\n       \
    \         max_level = level;\n            }\n        });\n        result.push(max_level);\n\
    \    });\n    return result;\n}\n\nmodule.exports = parse_nested_parens;", " \
    \   let curr_paren_match = '';\n    let prev_paren_match = '';\n    let max_paren_depth\
    \ = 0;\n    let current_depth = 0;\n    let iter = 0;\n    while(iter < paren_string.length){\n\
    \        if(paren_string[iter] == '('){\n            current_depth += 1;\n   \
    \         max_paren_depth = Math.max(max_paren_depth, current_depth);\n      \
    \  }\n        else if(paren_string[iter] == ')'){\n            current_depth -=\
    \ 1;\n        }\n        iter += 1;\n    }\n    return max_paren_depth;\n}\n\n",
  "    var out_arr = [];\n    var paren_arr = paren_string.split(' ');\n    for(var\
    \ i=0; i<paren_arr.length; i++){\n        var max_paren_level = 0;\n        var\
    \ curr_paren_level = 0;\n        for(var j=0; j<paren_arr[i].length; j++){\n \
    \           if(paren_arr[i][j] === '('){\n                curr_paren_level +=\
    \ 1;\n                if(curr_paren_level > max_paren_level){\n              \
    \      max_paren_level = curr_paren_level;\n                }\n            }\n\
    \            else if(paren_arr[i][j] === ')'){\n                curr_paren_level\
    \ -= 1;\n            }\n        }\n        out_arr.push(max_paren_level);\n  \
    \  }\n    return out_arr;\n}\n", "\tvar max = 0;\n\tvar current_max = 0;\n\tfor(var\
    \ i = 0; i < paren_string.length; i++){\n\t\tif(paren_string[i] === '('){\n\t\t\
    \tcurrent_max++;\n\t\t\tif(current_max > max){\n\t\t\t\tmax = current_max;\n\t\
    \t\t}\n\t\t}\n\t\telse if(paren_string[i] === ')'){\n\t\t\tcurrent_max--;\n\t\t\
    }\n\t}\n\treturn max;\n}\n\n", "  paren_string = paren_string.replace(/ /g, '');\n\
    \  let max_num_nested = 0;\n  let current_num_nested = 0;\n  let num_parens =\
    \ 0;\n  let current_char;\n  while(paren_string.length > 0){\n    current_char\
    \ = paren_string.charAt(0);\n    paren_string = paren_string.substring(1);\n \
    \   if(current_char === '('){\n      num_parens += 1;\n      current_num_nested\
    \ += 1;\n      if(current_num_nested > max_num_nested){\n        max_num_nested\
    \ = current_num_nested;\n      }\n    } else {\n      current_num_nested -= 1;\n\
    \    }\n  }\n  if(num_parens % 2 === 1){\n    return -1;\n  }\n  return max_num_nested;\n\
    }\n", "  var result = '';\n  var curr_count = 0;\n  var max_count = 0;\n  for(var\
    \ i = 0; i < paren_string.length; i++){\n    if(paren_string[i] === '('){\n  \
    \    curr_count += 1;\n      if(curr_count > max_count){\n        max_count =\
    \ curr_count;\n      }\n    } else if(paren_string[i] === ')'){\n      curr_count\
    \ -= 1;\n    } else if(paren_string[i] === ' '){\n      result += max_count +\
    \ ' ';\n      max_count = 0;\n      curr_count = 0;\n    }\n  }\n  result += max_count;\n\
    \  return result;\n}\n", "    var paren_depth = [];\n    var arr = paren_string.split(\"\
    \ \");\n    for(var i = 0; i < arr.length; i++){\n        var paren_str = arr[i];\n\
    \        var depth = 0;\n        var max_depth = 0;\n        for(var j = 0; j\
    \ < paren_str.length; j++){\n            if(paren_str[j] == '('){\n          \
    \      depth++;\n                if(depth > max_depth){\n                    max_depth\
    \ = depth;\n                }\n            }else if(paren_str[j] == ')'){\n  \
    \              depth--;\n            }\n        }\n        paren_depth.push(max_depth);\n\
    \    }\n    return paren_depth;\n}\n", "  var max_level = 0;\n  var level = 0;\n\
    \  var result = \"\";\n  var result_array = [];\n  var paren_array = paren_string.split(\"\
    \ \");\n  for(var i = 0; i < paren_array.length; i++){\n    level = 0;\n    for(var\
    \ j = 0; j < paren_array[i].length; j++){\n      if(paren_array[i][j] == \"(\"\
    ){\n        level++;\n      }\n      else if(paren_array[i][j] == \")\"){\n  \
    \      level--;\n      }\n    }\n    result_array.push(level);\n  }\n  for(var\
    \ i = 0; i < result_array.length; i++){\n    if(result_array[i] > max_level){\n\
    \      max_level = result_array[i];\n    }\n  }\n  return max_level;\n}\n", " \
    \ var regex = /\\((?:\\w|\\s|\\W|\\d)*?\\)/;\n  var matches = paren_string.match(regex);\n\
    \  var counter = [];\n  var index = 0;\n  var n;\n  while(matches[index]){\n \
    \   n = 0;\n    for(var j = 0; j < matches[index].length; j++){\n      if(matches[index][j]\
    \ === '('){\n        n++;\n      }\n    }\n    counter.push(n);\n    index++;\n\
    \  }\n  return counter;\n}\n\nvar input = '(()()) ((())) (((()))) ()(()(())) ()()()()(())';\n\
    var output = parse_nested_parens(input);", "    var paren_arr = paren_string.split('\
    \ ');\n    var result = [];\n    paren_arr.forEach(function(str) {\n        var\
    \ max_depth = 0;\n        var curr_depth = 0;\n        for (var i = 0; i < str.length;\
    \ i++) {\n            if (str[i] === '(') {\n                curr_depth += 1;\n\
    \                max_depth = curr_depth > max_depth ? curr_depth : max_depth;\n\
    \            } else if (str[i] === ')') {\n                curr_depth -= 1;\n\
    \            }\n        }\n        result.push(max_depth);\n    });\n    return\
    \ result;\n}\n", "  var parens_arr = paren_string.split(\" \");\n  var max_level\
    \ = [];\n  var stack = [];\n  for(var i = 0; i < parens_arr.length; i++){\n  \
    \  var paren_group = parens_arr[i];\n    stack = [];\n    for(var j = 0; j < paren_group.length;\
    \ j++){\n      if(paren_group[j] == \"(\"){\n        stack.push(paren_group[j]);\n\
    \      }\n      else if(paren_group[j] == \")\"){\n        stack.pop();\n    \
    \  }\n    }\n    max_level.push(stack.length);\n  }\n  return max_level;\n}\n",
  "  console.log(paren_string);\n  var parenthesis_pairs = {\n    \"(\": \")\",\n\
    \    \"{\": \"}\",\n    \"[\": \"]\"\n  };\n  var paren_array = paren_string.split('');\n\
    \  var max_level = 0;\n  var current_level = 0;\n  var current_paren_closer =\
    \ \"\";\n  var current_paren_opener = \"\";\n  var o_stack = [];\n\n  //Recursive\
    \ method, takes a stack of all open parentheses, and a current max level to return;\n\
    \  function parse_parens(stack, max_level){\n    console.log(stack);\n    if(stack.length\
    \ == 0){\n      return max_level;\n    }\n    else{\n      current_paren_opener\
    \ = stack.pop();\n      current_paren_closer = parenthesis_pairs[current_paren_opener];\n\
    \      for(var i = paren_array.length-1; i >= 0; i--){\n        if(paren_array[i]\
    \ == current_paren_closer){\n          paren_array.splice(i, 1);\n          current_level\
    \ += 1;\n          break;\n        }\n      }\n      if(current_level > max_level){\n\
    \        max_level = current_level;\n      }\n      current_level = 0;\n     \
    \ console.log(paren_array);\n      return parse_parens(stack, max_level);\n  \
    \  }\n  }\n\n  //push all open parentheses onto the o_stack\n  for(var i = 0;\
    \ i < paren_array.length; i++){\n    if(paren_array[i] == \"(\" || paren_array[i]\
    \ == \"{\" || paren_array[i] == \"[\"){\n      o_stack.push(paren_array[i]);\n\
    \    }\n  }\n  console.log(o_stack);\n  max_level = parse_parens(o_stack, max_level);\n\
    \  return max_level;\n}", "    var res = new Array();\n    var arr = paren_string.split(\"\
    \ \");\n    for(var i=0; i<arr.length; i++){\n        var max_level = 0;\n   \
    \     var cur_level = 0;\n        for(var j=0; j<arr[i].length; j++){\n      \
    \      if(arr[i][j] == '('){\n                cur_level++;\n                if(cur_level\
    \ > max_level){\n                    max_level = cur_level;\n                }\n\
    \            }\n            else if(arr[i][j] == ')'){\n                cur_level--;\n\
    \            }\n        }\n        res.push(max_level);\n    }\n    return res;\n\
    }\n", "    var pairs = paren_string.split(\" \");\n    var curr_level = 0;\n \
    \   var max_level = 0;\n    var temp_string = \"\";\n    var deeper_nested = false;\n\
    \    for(var i = 0; i < pairs.length; i++){\n        curr_level = 0;\n       \
    \ deeper_nested = false;\n        temp_string = pairs[i];\n        for(var j =\
    \ 0; j < temp_string.length; j++){\n            if(temp_string[j] == '('){\n \
    \               curr_level++;\n                if(curr_level > max_level){\n \
    \                   max_level = curr_level;\n                    deeper_nested\
    \ = true;\n                }\n            }else if(temp_string[j] == ')'){\n \
    \               curr_level--;\n            }\n        }\n        if(!deeper_nested){\n\
    \            console.log(max_level);\n        }\n    }\n    console.log(max_level);\n\
    }", "\tvar paren_string_arr = paren_string.split(\" \");\n\tfor(var i=0; i<paren_string_arr.length;\
    \ i++){\n\t\tvar current_string = paren_string_arr[i];\n\t\tvar current_level\
    \ = 0;\n\t\tvar max_level = 0;\n\t\tfor(var j=0; j<current_string.length; j++){\n\
    \t\t\tif(current_string[j] == \"(\"){\n\t\t\t\tcurrent_level++;\n\t\t\t\tif(current_level\
    \ > max_level){\n\t\t\t\t\tmax_level = current_level;\n\t\t\t\t}\n\t\t\t}else\
    \ if(current_string[j] == \")\"){\n\t\t\t\tcurrent_level--;\n\t\t\t}\n\t\t}\n\t\
    \tconsole.log(max_level);\n\t}\n}\n", "  var output = [];\n  var stack = [];\n\
    \  var max_depth = 0;\n  var curr_depth = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      stack.push(paren_string[i]);\n\
    \      curr_depth += 1;\n      if(curr_depth > max_depth){\n        max_depth\
    \ = curr_depth;\n      }\n    }\n    else if(paren_string[i] == ')'){\n      stack.pop();\n\
    \      curr_depth -= 1;\n    }\n    else if(paren_string[i] == ' '){\n      //we\
    \ hit a space.\n      //time to output a solution\n      output.push(max_depth);\n\
    \      curr_depth = 0;\n      max_depth = 0;\n    }\n  }\n  //output final solution\n\
    \  output.push(max_depth);\n  return output;\n}\n\nvar paren_string = '(())()\
    \ ((())) (((()))) (()((()))())';", "\t// returns an array of numbers\n\tvar paren_groups\
    \ = paren_string.split(\" \");\n\tvar max_level = [];\n\tvar paren_hash = {\"\
    (\":1,\")\":-1};\n\tfor(var i=0;i<paren_groups.length;i++){\n\t\tvar curr_level\
    \ = 1;\n\t\tvar max_found = 1;\n\t\tfor(var j=0;j<paren_groups[i].length;j++){\n\
    \t\t\tcurr_level += paren_hash[paren_groups[i][j]];\n\t\t\tif(curr_level > max_found){\n\
    \t\t\t\tmax_found = curr_level;\n\t\t\t}\n\t\t}\n\t\tmax_level.push(max_found);\n\
    \t}\n\treturn max_level;\n}\n", "    var separator = ' ';\n    var groups = paren_string.split(separator);\n\
    \    var paren_levels = [];\n    for(var i = 0; i < groups.length; i++){\n   \
    \     var group = groups[i];\n        var max_depth = 0;\n        var depth =\
    \ 0;\n        for(var j = 0; j < group.length; j++){\n            var char = group[j];\n\
    \            if(char == '('){\n                depth++;\n            }else if(char\
    \ == ')'){\n                depth--;\n            }\n            if(depth > max_depth){\n\
    \                max_depth = depth;\n            }\n        }\n        paren_levels.push(max_depth);\n\
    \    }\n    return paren_levels;\n}\n", "\t//first, split the input string into\
    \ an array of substrings, each containing a group of nested parentheses\n\tvar\
    \ paren_array = paren_string.split(\" \");\n\t//next, for each substring, count\
    \ the number of opening parentheses encountered up to the first closing parenthesis\n\
    \tvar deepest_nesting = [];\n\tfor (var i = 0; i < paren_array.length; i++){\n\
    \t\tvar current_nesting = 0;\n\t\tvar max_nesting = 0;\n\t\tfor (var j = 0; j\
    \ < paren_array[i].length; j++){\n\t\t\tif (paren_array[i][j] == \"(\"){\n\t\t\
    \t\tcurrent_nesting += 1;\n\t\t\t\tif (current_nesting > max_nesting){\n\t\t\t\
    \t\tmax_nesting = current_nesting;\n\t\t\t\t}\n\t\t\t} else if (paren_array[i][j]\
    \ == \")\"){\n\t\t\t\tcurrent_nesting -= 1;\n\t\t\t}\n\t\t}\n\t\tdeepest_nesting.push(max_nesting);\n\
    \t}\n\treturn deepest_nesting;\n}\n", "  let counter = 0;\n  let max = 0;\n  let\
    \ result = [];\n  for(let i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ === '('){\n      counter++;\n      if(counter > max){\n        max = counter;\n\
    \      }\n    }\n    if(paren_string[i] === ')'){\n      counter--;\n    }\n \
    \   if(paren_string[i] === ' '){\n      result.push(max);\n      max = 0;\n  \
    \  }\n  }\n  result.push(max);\n  return result;\n}\n", "\tlet output = [];\n\t\
    let paren_array = paren_string.split(' ');\n\tfor(let i = 0; i < paren_array.length;\
    \ i++){\n\t\tlet count = 0;\n\t\tlet temp_count = 0;\n\t\tfor(let j = 0; j < paren_array[i].length;\
    \ j++){\n\t\t\tif(paren_array[i][j] === '('){\n\t\t\t\ttemp_count++;\n\t\t\t}\n\
    \t\t\telse if(paren_array[i][j] === ')'){\n\t\t\t\ttemp_count--;\n\t\t\t}\n\t\t\
    \tif(temp_count > count){\n\t\t\t\tcount = temp_count;\n\t\t\t}\n\t\t}\n\t\toutput.push(count);\n\
    \t}\n\treturn output;\n}\n", "    var max_nesting = 0;\n    var max_string = '';\n\
    \    var groups = paren_string.split(' ');\n    for(var i = 0; i < groups.length;\
    \ i++){\n        if(groups[i].length > 0){\n            var num_parens = 0;\n\
    \            var num_nesting = 0;\n            var is_valid = true;\n        \
    \    for(var j = 0; j < groups[i].length; j++){\n                if(groups[i][j]\
    \ == '('){\n                    num_parens++;\n                    num_nesting++;\n\
    \                    if(num_parens < num_nesting){\n                        is_valid\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n                else if(groups[i][j] == ')'){\n                    num_parens--;\n\
    \                    num_nesting--;\n                    if(num_parens < 0){\n\
    \                        is_valid = false;\n                        break;\n \
    \                   }\n                }\n                else{\n            \
    \        is_valid = false;\n                    break;\n                }\n  \
    \          }\n            if(is_valid && num_parens == 0 && num_nesting > max_nesting){\n\
    \                max_nesting = num_nesting;\n                max_string = groups[i];\n\
    \            }\n        }\n    }\n    console.log(max_string);\n    return max_nesting;\n\
    }", "  var level = 0;\n  var max_level = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      level += 1;\n      if(level >\
    \ max_level){\n        max_level = level;\n      }\n    }\n    else if(paren_string[i]\
    \ == ')'){\n      level -= 1;\n    }\n  }\n  return max_level;\n}\n", "    var\
    \ levels_arr = [];\n    var level = 0;\n    var temp = '';\n    for(var i = 0;\
    \ i < paren_string.length; i++){\n        if(paren_string[i] === '('){\n     \
    \       level += 1;\n        }\n        else if(paren_string[i] === ')'){\n  \
    \          level -= 1;\n        }\n        else if(paren_string[i] === ' '){\n\
    \            levels_arr.push(level);\n            level = 0;\n        }\n    }\n\
    \    var max = -1;\n    for(var i = 0; i < levels_arr.length; i++){\n        if(levels_arr[i]\
    \ > max){\n            max = levels_arr[i];\n        }\n    }\n    return max;\n\
    }\n\nvar input = \"(()()) ((())) ((()())())\";\nvar output = parse_nested_parens(input);",
  "    let paren_stack = [];\n    let paren_levels = {};\n    let num_levels = 0;\n\
    \    let paren_len = paren_string.length;\n    let paren_idx = 0;\n    while(paren_idx\
    \ < paren_len){\n        if(paren_string[paren_idx] === '('){\n            paren_stack.push(paren_string[paren_idx]);\n\
    \            num_levels = Math.max(num_levels, paren_stack.length);\n        }\n\
    \        else if(paren_string[paren_idx] === ')'){\n            if(paren_stack.length\
    \ > 0){\n                paren_stack.pop();\n            }\n            else{\n\
    \                throw new Error(\"Unbalanced parens\");\n            }\n    \
    \    }\n        paren_idx++;\n    }\n    if(paren_stack.length > 0){\n       \
    \ throw new Error(\"Unbalanced parens\");\n    }\n    return num_levels;\n}",
  "    //assuming string is a valid list of parenthesis group\n    let ret_arr = [];\n\
    \    let groups = paren_string.split(\" \");\n    groups.forEach(group => {\n\
    \        ret_arr.push(parse_parens(group));\n    });\n    return ret_arr;\n}\n",
  "  // create an array of each paren expression\n  const paren_exprs = paren_string.split('\
    \ ');\n  const deepest_levels = [];\n  // for each paren expression, calculate\
    \ the level of nesting\n  for (var i = 0; i < paren_exprs.length; i++) {\n   \
    \ var current_level = 0;\n    var max_level = 0;\n    // iterate through each\
    \ parens in an expression\n    for (var j = 0; j < paren_exprs[i].length; j++)\
    \ {\n      if (paren_exprs[i][j] === '(') {\n        current_level++;\n      }\
    \ else if (paren_exprs[i][j] === ')') {\n        current_level--;\n      }\n \
    \     if (current_level > max_level) {\n        max_level = current_level;\n \
    \     }\n    }\n    deepest_levels.push(max_level);\n  }\n  return deepest_levels;\n\
    }\n\n", "\t// Initialize global variables used to count the max levels of nesting\n\
    \tmax_nesting = 0;\n\tcurrent_level = 0;\n\t// Break up the string into groups\
    \ of nested parentheses\n\tparen_groups = paren_string.split(\" \");\n\t// For\
    \ each group of parentheses\n\tfor (var i = 0; i < paren_groups.length; i++){\n\
    \t\t// Get a current group\n\t\tcurrent_group = paren_groups[i];\n\t\t// For each\
    \ character in the group\n\t\tfor (var j = 0; j < current_group.length; j++){\n\
    \t\t\t// Get the current character\n\t\t\tcurrent_char = current_group[j];\n\t\
    \t\t// If it is an opening parenthesis\n\t\t\tif (current_char == \"(\"){\n\t\t\
    \t\t// Increase the current level count\n\t\t\t\tcurrent_level++;\n\t\t\t\t//\
    \ If it is higher than the max level\n\t\t\t\tif (current_level > max_nesting){\n\
    \t\t\t\t\t// Then set max level equal to current level\n\t\t\t\t\tmax_nesting\
    \ = current_level;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If it is a closing parenthesis\n\
    \t\t\telse if (current_char == \")\"){\n\t\t\t\t// Decrease the current level\
    \ count\n\t\t\t\tcurrent_level--;\n\t\t\t}\n\t\t}\n\t\t// Clear the current level\
    \ count\n\t\tcurrent_level = 0;\n\t\t// Output the max nesting level for the current\
    \ group\n\t\tconsole.log(max_nesting);\n\t\t// Clear the max nesting level\n\t\
    \tmax_nesting = 0;\n\t}\n}\n", "    if (typeof paren_string === 'string'){\n \
    \       var paren_string_array = paren_string.split(' ');\n        var final_result\
    \ = [];\n        for (var i=0; i<paren_string_array.length; i++){\n          \
    \  if (parse_level_parens(paren_string_array[i]) !== -1){\n                final_result.push(parse_level_parens(paren_string_array[i]));\n\
    \            }\n        }\n        return final_result;\n    }\n    else {\n \
    \       console.log('input is not a string');\n        return -1;\n    }\n}\n",
  "  var arrays = paren_string.split(' ');\n  var results = [];\n  var count = 0;\n\
    \  var result = 0;\n  var i;\n  var j;\n  for(i = 0; i < arrays.length; i++){\n\
    \    count = 0;\n    for(j = 0; j < arrays[i].length; j++){\n      if(arrays[i][j]\
    \ === '('){\n        count++;\n      }\n      if(arrays[i][j] === ')'){\n    \
    \    count--;\n      }\n      if(count > result){\n        result = count;\n \
    \     }\n    }\n    results.push(result);\n  }\n  return results;\n}", "    paren_string\
    \ = paren_string.replace(' ', '');\n    let index = 0;\n    let level = 0;\n \
    \   let max_level = 0;\n    let count = 0;\n    let list = [];\n    while(index\
    \ < paren_string.length){\n        if(paren_string[index] === '('){\n        \
    \    level += 1;\n            if(level > max_level){\n                max_level\
    \ = level;\n            }\n        }\n        else if(paren_string[index] ===\
    \ ')'){\n            level -= 1;\n        }\n        index += 1;\n    }\n    return\
    \ max_level;\n}\n\n", "  var parens_array = paren_string.split(\" \");\n  var\
    \ max_nesting = 0;\n  for(var i = 0; i < parens_array.length; i++){\n    var num_open\
    \ = 0;\n    var num_close = 0;\n    for(var j = 0; j < parens_array[i].length;\
    \ j++){\n      if(parens_array[i][j] == '('){\n        num_open++;\n      }\n\
    \      else if(parens_array[i][j] == ')'){\n        num_close++;\n      }\n  \
    \  }\n    max_nesting = Math.max(max_nesting, num_open - num_close);\n  }\n  return\
    \ max_nesting;\n}\n", "    let paren_counts = []\n    let paren_string_array =\
    \ paren_string.split(' ')\n    for (let sub_string of paren_string_array){\n \
    \       let count = 0\n        let max_count = 0\n        for (let char of sub_string){\n\
    \            if (char === '('){\n                count += 1\n            } else\
    \ if (char === ')'){\n                count -= 1\n            }\n            if\
    \ (count > max_count){\n                max_count = count\n            }\n   \
    \     }\n        paren_counts.push(max_count)\n    }\n    return paren_counts\n\
    }\n", "    var paren_arr = paren_string.split(\" \");\n    var max_nesting = [];\n\
    \    for(var i = 0; i < paren_arr.length; i++){\n        var paren = paren_arr[i];\n\
    \        var nesting = 0;\n        var max_seen = 0;\n        for(var j = 0; j\
    \ < paren.length; j++){\n            if(paren[j] == \"(\"){\n                nesting++;\n\
    \                if(nesting > max_seen){\n                    max_seen = nesting;\n\
    \                }\n            }\n            else if(paren[j] == \")\"){\n \
    \               nesting--;\n            }\n        }\n        max_nesting.push(max_seen);\n\
    \    }\n    return max_nesting;\n}\n", "    let max_depth = 0;\n    let depth\
    \ = 0;\n    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === '('){\n            depth += 1;\n            if(depth > max_depth){\n   \
    \             max_depth = depth;\n            }\n        }\n        else if(paren_string[i]\
    \ === ')'){\n            depth -= 1;\n        }\n    }\n    return max_depth;\n\
    }\n\nparse_nested_parens('(()) ()')\nparse_nested_parens('((()))')\nparse_nested_parens('(()')\n",
  "  // INPUT is a string of nested parens separated by spaces\n  // OUTPUT is an\
    \ array of integers indicating the depth of nesting\n\n  // split the input string\
    \ into components where each component is a set of nested parens\n  var split_parens\
    \ = paren_string.split(\" \");\n  var paren_depth = [];\n\n  // loop through the\
    \ array of parens and check how many levels of nesting there are\n  for (var i\
    \ = 0; i < split_parens.length; i++){\n    var paren_count = 0;\n    var paren_length\
    \ = split_parens[i].length;\n    for (var j = 0; j < paren_length; j++){\n   \
    \   // for each paren, check the current level of nesting\n      if (split_parens[i][j]\
    \ == \"(\"){\n        paren_count++;\n      }\n      else if (split_parens[i][j]\
    \ == \")\"){\n        paren_count--;\n      }\n    }\n    // if paren_count ==\
    \ 0, then we have a complete set of parens\n    // otherwise, we have an unbalanced\
    \ set of parens\n    if (paren_count == 0){\n      paren_depth.push(paren_count);\n\
    \    }\n    else{\n      console.log(\"Invalid input: \" + split_parens[i]);\n\
    \    }\n  }\n  return paren_depth;\n}\n", "  let paren_levels = paren_string.split('\
    \ ');\n  let levels = [];\n  for(let i = 0; i < paren_levels.length; i++){\n \
    \   let paren_level = paren_levels[i];\n    levels.push(paren_level.split('').reduce((sum,\
    \ char) => {\n      if(char === '('){\n        return sum + 1;\n      }\n    \
    \  if(char === ')'){\n        return sum - 1;\n      }\n      return sum;\n  \
    \  }, 0));\n  }\n  return levels;\n}\n", "    if(paren_string == \"\"){\n    \
    \    return \"\";\n    }\n    var maxNestingLevel = 0;\n    var parenArr = paren_string.split(\"\
    \ \");\n    for(var i = 0; i < parenArr.length; i++){\n        var openParens\
    \ = 0;\n        var closeParens = 0;\n        for(var j = 0; j < parenArr[i].length;\
    \ j++){\n            if(parenArr[i][j] == \"(\"){\n                openParens++;\n\
    \            }\n            else if(parenArr[i][j] == \")\"){\n              \
    \  closeParens++;\n            }\n            if(closeParens > openParens){\n\
    \                return -1;\n            }\n        }\n        if(openParens !=\
    \ closeParens){\n            return -1;\n        }\n        if(openParens > maxNestingLevel){\n\
    \            maxNestingLevel = openParens;\n        }\n    }\n    return maxNestingLevel;\n\
    }\n", "    // your code here\n    var out = [],\n        temp = '',\n        max\
    \ = 0;\n    // remove space and concatenate the string\n    paren_string = paren_string.replace(/\\\
    s/g, '');\n    // iterate the string\n    for (var i = 0; i < paren_string.length;\
    \ i++) {\n        // if it is '(', add '1'\n        if (paren_string[i] === '(')\
    \ {\n            temp += '1';\n        }\n        // if it is ')', replace the\
    \ last '1' to '0'\n        else if (paren_string[i] === ')') {\n            temp\
    \ = temp.slice(0, -1) + '0';\n        }\n        // if it is ' ', store max value\
    \ and reset temp\n        else if (paren_string[i] === ' ') {\n            out.push(Math.max(...temp.split('').map(Number)));\n\
    \            max = Math.max(max, Math.max(...temp.split('').map(Number)));\n \
    \           temp = '';\n        }\n    }\n    out.push(Math.max(...temp.split('').map(Number)));\n\
    \    max = Math.max(max, Math.max(...temp.split('').map(Number)));\n    return\
    \ max;\n}\n", "\tif(!paren_string){\n\t\treturn null;\n\t}\n\tvar splitted_paren_string\
    \ = paren_string.split(' ');\n\tvar highest_nesting_level = 0;\n\tfor(var i =\
    \ 0; i < splitted_paren_string.length; i++){\n\t\tvar splitted_paren_group = splitted_paren_string[i];\n\
    \t\tvar current_nesting_level = 0;\n\t\tfor(var j = 0; j < splitted_paren_group.length;\
    \ j++){\n\t\t\tif(splitted_paren_group[j] === '('){\n\t\t\t\tcurrent_nesting_level++;\n\
    \t\t\t}\n\t\t\telse if(splitted_paren_group[j] === ')'){\n\t\t\t\tcurrent_nesting_level--;\n\
    \t\t\t}\n\t\t}\n\t\tif(current_nesting_level > highest_nesting_level){\n\t\t\t\
    highest_nesting_level = current_nesting_level;\n\t\t}\n\t}\n\treturn highest_nesting_level;\n\
    }\n", "    var groups = paren_string.split(\" \");\n    var max = 0;\n    var\
    \ group_count = 0;\n    for(var i = 0; i < groups.length; i++){\n        for(var\
    \ j = 0; j < groups[i].length; j++){\n            if(groups[i][j] == \"(\"){\n\
    \                group_count++;\n            }\n            else if(groups[i][j]\
    \ == \")\"){\n                group_count--;\n            }\n            if(group_count\
    \ > max){\n                max = group_count;\n            }\n        }\n    \
    \    group_count = 0;\n    }\n    return max;\n}\n\nvar parens_test = \"((()))\
    \ (()()) (())(()) (()())\";", "    let group_result = [];\n\n    paren_string.split('\
    \ ').forEach(group => {\n        let count = 0;\n        let result = 0;\n   \
    \     for(let i = 0; i < group.length; i++){\n            if(group[i] === '('){\n\
    \                count++;\n                result = Math.max(result, count);\n\
    \            } else {\n                count--;\n            }\n        }\n  \
    \      group_result.push(result);\n    });\n\n    return group_result;\n}\n\n\
    let paren_string = '()() (()) (()(())) (())(()) ()()()() ()()()()()()';", "  //split\
    \ string into groups.\n  let groups = paren_string.split(' ');\n  let depth_list\
    \ = [];\n  for (let i = 0; i < groups.length; i++){\n    let depth = find_depth(groups[i]);\n\
    \    depth_list.push(depth);\n  }\n  console.log(depth_list);\n}\n", "\tif (paren_string.length\
    \ === 0) return [];\n\tvar output = [];\n\tparen_string.split(' ').forEach(function(item){\n\
    \t\toutput.push(parse_parens(item));\n\t});\n\treturn output;\n}\n", "\tvar depth_arr\
    \ = [],\n\t\tparen_arr = paren_string.split(\" \"),\n\t\tregex = /[^()]/g;\n\t\
    paren_arr.forEach(function(parenthesis_string){\n\t\tvar stack = [],\n\t\t\tmax_depth\
    \ = 0,\n\t\t\tcurrent_depth = 0;\n\t\tparenthesis_string.replace(regex, \"\");\n\
    \t\tfor(var i = 0; i < parenthesis_string.length; i++){\n\t\t\tif(parenthesis_string[i]\
    \ === \"(\"){\n\t\t\t\tstack.push(current_depth++);\n\t\t\t}\n\t\t\telse{\n\t\t\
    \t\tstack.pop();\n\t\t\t\tcurrent_depth--;\n\t\t\t}\n\t\t\tif(max_depth < current_depth){\n\
    \t\t\t\tmax_depth = current_depth;\n\t\t\t}\n\t\t}\n\t\tdepth_arr.push(max_depth);\n\
    \t});\n\treturn depth_arr;\n}\n", "    //parse the input string by spaces\n  \
    \  let paren_groups = paren_string.split(\" \");\n    let group_depth = [];\n\
    \    //for each group, take its max nesting level, as shown in example above\n\
    \    for (let i=0; i<paren_groups.length; i++){\n        let max_depth = 0;\n\
    \        let curr_depth = 0;\n        for (let j=0; j<paren_groups[i].length;\
    \ j++){\n            if (paren_groups[i][j] === \"(\"){\n                curr_depth\
    \ += 1;\n                if (curr_depth > max_depth){\n                    max_depth\
    \ = curr_depth;\n                }\n            }\n            else if (paren_groups[i][j]\
    \ === \")\"){\n                curr_depth -= 1;\n            }\n        }\n  \
    \      group_depth.push(max_depth);\n    }\n    return group_depth;\n}\n", " \
    \   let parens = paren_string.split(\" \");\n    // console.log(parens);\n   \
    \ let result = [];\n    for(let paren of parens){\n        result.push(count_nested_parens(paren));\n\
    \    }\n    return result;\n}\n", "    //Code here\n}", "\tvar paren_groups =\
    \ paren_string.split(\" \");\n\tvar paren_sizes = [];\n\tfor(var i = 0; i < paren_groups.length;\
    \ i++){\n\t\tvar paren_group = paren_groups[i];\n\t\tvar paren_size = 1;\n\t\t\
    for(var j = 0; j < paren_group.length; j++){\n\t\t\tif(paren_group[j] == \"(\"\
    )\n\t\t\t\tparen_size++;\n\t\t\telse if(paren_group[j] == \")\")\n\t\t\t\tparen_size--;\n\
    \t\t}\n\t\tparen_sizes.push(paren_size);\n\t}\n\treturn paren_sizes;\n}\n", " \
    \ let parens_array = paren_string.split(\" \");\n  let output = [];\n  parens_array.forEach(element\
    \ => {\n    let max_depth = 0;\n    let stack = [];\n    for(let i = 0; i < element.length;\
    \ i++){\n      if(element[i] === \"(\"){\n        stack.push(element[i]);\n  \
    \      if(stack.length > max_depth){\n          max_depth = stack.length;\n  \
    \      }\n      }\n      else if(element[i] === \")\"){\n        stack.pop();\n\
    \      }\n    }\n    output.push(max_depth);\n  });\n  return output;\n}\n", " \
    \   var idx = 0;\n    var paren_stack = [];\n    var current_depth = 0;\n    var\
    \ max_depth = 0;\n    while(idx < paren_string.length){\n        if(paren_string[idx]\
    \ == '('){\n            paren_stack.push(paren_string[idx]);\n            current_depth++;\n\
    \            max_depth = Math.max(max_depth, current_depth);\n        }\n    \
    \    else if(paren_string[idx] == ')'){\n            paren_stack.pop();\n    \
    \        current_depth--;\n        }\n        idx++;\n    }\n    return max_depth;\n\
    }\n", "\tvar max_depth = 0;\n\tvar curr_depth = 0;\n\tfor(var i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] == '('){\n\t\t\tcurr_depth++;\n\t\t\tif(curr_depth\
    \ > max_depth){\n\t\t\t\tmax_depth = curr_depth;\n\t\t\t}\n\t\t}\n\t\telse if(paren_string[i]\
    \ == ')'){\n\t\t\tcurr_depth--;\n\t\t}\n\t}\n\treturn max_depth;\n}\n", "\tvar\
    \ max_depth = 0;\n\tvar current_depth = 0;\n\tvar current_group = '';\n\tfor(var\
    \ i = 0; i < paren_string.length; i++){\n\t\tif(paren_string[i] === '('){\n\t\t\
    \tcurrent_depth++;\n\t\t\tif(current_depth > max_depth){\n\t\t\t\tmax_depth =\
    \ current_depth;\n\t\t\t}\n\t\t}\n\t\telse if(paren_string[i] === ')'){\n\t\t\t\
    current_depth--;\n\t\t}\n\t\telse if(paren_string[i] === ' '){\n\t\t\tconsole.log(max_depth);\n\
    \t\t\tmax_depth = 0;\n\t\t\tcurrent_depth = 0;\n\t\t}\n\t}\n\tconsole.log(max_depth);\n\
    }", "\tlet group_arr = paren_string.split(' ');\n\tlet result = [];\n\tfor(let\
    \ i = 0; i < group_arr.length; i++){\n\t\tlet stack = [];\n\t\tlet max = 0;\n\t\
    \tfor(let c of group_arr[i]){\n\t\t\tif(c === '('){\n\t\t\t\tstack.push(c);\n\t\
    \t\t\tmax = Math.max(max, stack.length);\n\t\t\t}else if(c === ')'){\n\t\t\t\t\
    stack.pop();\n\t\t\t}\n\t\t}\n\t\tresult.push(max);\n\t}\n\treturn result;\n}\n",
  "    console.log(paren_string);\n    var paren_array = paren_string.split(' ');\n\
    \    var paren_levels = [];\n    var paren_level = 0;\n    for(var i = 0; i <\
    \ paren_array.length; i++){\n        var paren_string = paren_array[i];\n    \
    \    for(var j = 0; j < paren_string.length; j++){\n            if(paren_string[j]\
    \ == '('){\n                paren_level++;\n            }else if(paren_string[j]\
    \ == ')'){\n                paren_level--;\n            }\n        }\n       \
    \ paren_levels.push(paren_level);\n        paren_level = 0;\n    }\n    return\
    \ paren_levels;\n}\n", "    var paren_string_array = paren_string.split(' ');\n\
    \    var highest_nesting = 0;\n    for(var i = 0; i < paren_string_array.length;\
    \ i++){\n        var paren_substring = paren_string_array[i];\n        var nesting_stack\
    \ = [];\n        for(var j = 0; j < paren_substring.length; j++){\n          \
    \  if(paren_substring[j] == '('){\n                nesting_stack.push(paren_substring[j]);\n\
    \            }\n            else if(paren_substring[j] == ')'){\n            \
    \    nesting_stack.pop();\n            }\n        }\n        highest_nesting =\
    \ Math.max(highest_nesting, nesting_stack.length);\n    }\n    return highest_nesting;\n\
    }\n", "    var check = paren_string.match(/\\(/g).length == paren_string.match(/\\\
    )/g).length;\n    if (!check) return -1;\n\n    var paren_groups = paren_string.split('\
    \ ');\n    var res = [];\n    for (var i = 0; i < paren_groups.length; i++){\n\
    \        var temp = 0;\n        var max = 0;\n        for (var j = 0; j < paren_groups[i].length;\
    \ j++){\n            if (paren_groups[i][j] == '(') temp++;\n            else\
    \ if (paren_groups[i][j] == ')') temp--;\n            if (temp > max) max = temp;\n\
    \        }\n        res.push(max);\n    }\n    return res;\n}\n", "    //TODO\n\
    }\n", "    var paren_groups = paren_string.split(\" \");\n    var paren_levels\
    \ = [];\n    var paren_level = 0;\n    for(var i = 0; i < paren_groups.length;\
    \ i++){\n        var current_group = paren_groups[i];\n        paren_level = 0;\n\
    \        for(var j = 0; j < current_group.length; j++){\n            if(current_group[j]\
    \ == \"(\"){\n                paren_level++;\n            }\n        }\n     \
    \   paren_levels.push(paren_level);\n    }\n    return paren_levels;\n}\n", " \
    \ var output = [];\n\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ == \"(\"){\n      var depth = 0;\n      var paren_count = 0;\n      while(paren_string[i]\
    \ != \")\"){\n        if(paren_string[i] == \"(\"){\n          paren_count++;\n\
    \          if(paren_count > depth){\n            depth = paren_count;\n      \
    \    }\n        }\n        else if(paren_string[i] == \")\"){\n          paren_count--;\n\
    \        }\n        i++;\n      }\n      output.push(depth);\n    }\n  }\n  return\
    \ output;\n}\n", "    var paren_array = paren_string.split(\" \");\n    var nested_levels\
    \ = [];\n    for(var i = 0; i < paren_array.length; i++){\n        nested_levels.push(find_max_nesting(paren_array[i]));\n\
    \    }\n    return nested_levels;\n}\n", "    let current = 0;\n    let max =\
    \ 0;\n    let result = [];\n    for(let i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] === '('){\n            current++;\n            if(current\
    \ > max){\n                max = current;\n            }\n        }\n        else\
    \ if(paren_string[i] === ')'){\n            current--;\n        }\n        else\
    \ if(paren_string[i] === ' '){\n            result.push(max);\n            max\
    \ = 0;\n            current = 0;\n        }\n    }\n    result.push(max);\n  \
    \  return result;\n}\n", "    //TODO: Implement this function.\n}\n", "    var\
    \ results = [],\n        paren_regex = /\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\\
    (([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\\
    (([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\\
    (([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\\
    (([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\\
    (([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\\
    (([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\\
    (([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\\
    (([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\(([^()]*|\\\
    (([^()]*|\\(([^()]*|", "\tlet open_parens = [], curr_depth = 0, max_depth = 0;\n\
    \tlet result = [], curr_string = \"\";\n\tfor(let i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] === \"(\"){\n\t\t\tcurr_depth += 1;\n\t\t\topen_parens.push(paren_string[i]);\n\
    \t\t}\n\t\telse if(paren_string[i] === \")\"){\n\t\t\tif(open_parens.length){\n\
    \t\t\t\topen_parens.pop();\n\t\t\t\tcurr_depth -= 1;\n\t\t\t}\n\t\t\telse{\n\t\
    \t\t\tconsole.log(\"Unexpected closing parenthesis\");\n\t\t\t\treturn;\n\t\t\t\
    }\n\t\t}\n\t\telse if(paren_string[i] === \" \"){\n\t\t\tresult.push(max_depth);\n\
    \t\t\tcurr_depth = 0;\n\t\t\tmax_depth = 0;\n\t\t}\n\t\telse{\n\t\t\tconsole.log(\"\
    Unexpected input\");\n\t\t\treturn;\n\t\t}\n\t\tmax_depth = Math.max(max_depth,\
    \ curr_depth);\n\t}\n\tconsole.log(result);\n}\n\nlet paren_string = \"(())()\
    \ (()()) ()((()))\";\nparse_nested_parens(paren_string);", "  const parens_arr\
    \ = paren_string.split(\" \");\n  const result = [];\n  for(let i = 0; i < parens_arr.length;\
    \ i++){\n    result.push(count_max_nesting(parens_arr[i]));\n  }\n  return result;\n\
    }", "\tvar result = [];\n\tvar max_depth = 0;\n\tvar stack = [];\n\tfor(var i\
    \ = 0; i < paren_string.length; i++){\n\t\tvar c = paren_string[i];\n\t\tif(c\
    \ == '('){\n\t\t\tstack.push(c);\n\t\t\tmax_depth = Math.max(max_depth, stack.length);\n\
    \t\t}\n\t\telse if(c == ')'){\n\t\t\tstack.pop();\n\t\t}\n\t\telse if(c == ' '){\n\
    \t\t\tresult.push(max_depth);\n\t\t\tmax_depth = 0;\n\t\t}\n\t}\n\tresult.push(max_depth);\n\
    \treturn result;\n}\n\nvar paren_string = \"(()()) ()() (()) ()(()) (((())))\"\
    ;", "  var max_so_far = 0;\n  var max_curr = 0;\n  var curr_parens = 0;\n  for(var\
    \ i = 0; i < paren_string.length; i++){\n    if(paren_string[i] == '('){\n   \
    \   curr_parens++;\n      max_curr = Math.max(max_curr, curr_parens);\n    } else\
    \ if(paren_string[i] == ')'){\n      curr_parens--;\n    } else {\n      max_so_far\
    \ = Math.max(max_so_far, max_curr);\n      max_curr = 0;\n      curr_parens =\
    \ 0;\n    }\n  }\n  return Math.max(max_so_far, max_curr);\n}", "  if(paren_string\
    \ === '') return '';\n  var inner_parens = paren_string.substring(1, paren_string.length-1);\n\
    \  var curr_level = 1;\n  var max_level = 1;\n  for(var i = 0; i < inner_parens.length;\
    \ i++){\n    if(inner_parens[i] === '(') curr_level++;\n    else if(inner_parens[i]\
    \ === ')') curr_level--;\n    if(curr_level > max_level) max_level = curr_level;\n\
    \  }\n  return max_level;\n}\n", "  let max = 0;\n  let current = 0;\n  let result\
    \ = [];\n  for(let i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ === '('){\n      current++;\n      if(current > max){\n        max = current;\n\
    \      }\n    }\n    else if(paren_string[i] === ')'){\n      current--;\n   \
    \ }\n    else if(paren_string[i] === ' '){\n      result.push(max);\n      max\
    \ = 0;\n      current = 0;\n    }\n  }\n  result.push(max);\n  return result;\n\
    }\n", "    return paren_string.split(\" \").map(x => {\n        var paren_count\
    \ = 0;\n        var max_paren_count = 0;\n        for(var i = 0; i < x.length;\
    \ i++){\n            if(x[i] == \"(\"){\n                paren_count++;\n    \
    \            if(paren_count > max_paren_count){\n                    max_paren_count\
    \ = paren_count;\n                }\n            }else if(x[i] == \")\"){\n  \
    \              paren_count--;\n            }\n        }\n        return max_paren_count;\n\
    \    });\n}\n", "  let deepest_level_nesting = 0;\n  let open_parens = 0;\n  for(let\
    \ i = 0; i < paren_string.length; i++){\n    if(paren_string[i] === '('){\n  \
    \    open_parens += 1;\n      if(open_parens > deepest_level_nesting){\n     \
    \   deepest_level_nesting = open_parens;\n      }\n    }\n    else if(paren_string[i]\
    \ === ')'){\n      open_parens -= 1;\n    }\n  }\n  return deepest_level_nesting;\n\
    }\n", "\tvar paren_array = paren_string.split(\" \");\n\tvar nested_parens = [];\n\
    \tvar current_nesting = 0;\n\tvar max_nesting = 0;\n\tfor(var i = 0; i < paren_array.length;\
    \ i++){\n\t\tfor(var j = 0; j < paren_array[i].length; j++){\n\t\t\tif(paren_array[i][j]\
    \ == \"(\"){\n\t\t\t\tcurrent_nesting++;\n\t\t\t\tif(current_nesting > max_nesting){\n\
    \t\t\t\t\tmax_nesting = current_nesting;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(paren_array[i][j]\
    \ == \")\"){\n\t\t\t\tcurrent_nesting--;\n\t\t\t}\n\t\t}\n\t\tnested_parens.push(max_nesting);\n\
    \t\tcurrent_nesting = 0;\n\t\tmax_nesting = 0;\n\t}\n\treturn nested_parens;\n\
    }", "\tvar unclosed = 0;\n\tvar max_depth = 0;\n\tfor(var i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] == '('){\n\t\t\tunclosed++;\n\t\t\tif(unclosed\
    \ > max_depth){\n\t\t\t\tmax_depth = unclosed;\n\t\t\t}\n\t\t}\n\t\telse if(paren_string[i]\
    \ == ')'){\n\t\t\tunclosed--;\n\t\t}\n\t}\n\treturn max_depth;\n}", "    var curr_level\
    \ = 0;\n    var max_level = 0;\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] == '('){\n            curr_level++;\n            if(curr_level\
    \ > max_level){\n                max_level = curr_level;\n            }\n    \
    \    }\n        else if(paren_string[i] == ')'){\n            curr_level--;\n\
    \        }\n    }\n    return max_level;\n}\n", "  let paren_levels = [];\n  let\
    \ depth = 0;\n  for(let i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ === '('){\n      depth++;\n    }\n    else if(paren_string[i] === ')'){\n  \
    \    paren_levels.push(depth);\n      depth--;\n    }\n  }\n  return paren_levels;\n\
    }\n\nlet test_case = '(()())';", "\t\n\tvar parens = paren_string.split(\" \"\
    );\n\tvar paren_counts = [];\n\t\n\tfor(var i = 0; i < parens.length; i++){\n\t\
    \tvar paren = parens[i];\n\t\tvar paren_count = 0;\n\t\tvar max_paren_count =\
    \ 0;\n\t\tfor(var j = 0; j < paren.length; j++){\n\t\t\tif(paren[j] == '('){\n\
    \t\t\t\tparen_count++;\n\t\t\t\tif(paren_count > max_paren_count){\n\t\t\t\t\t\
    max_paren_count = paren_count;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(paren[j] ==\
    \ ')'){\n\t\t\t\tparen_count--;\n\t\t\t}\n\t\t}\n\t\tparen_counts.push(max_paren_count);\n\
    \t}\n\treturn paren_counts;\n}", "    var output = paren_string.split(' ');\n\
    \    //The value of each key is a list of integer representing the nesting level\
    \ of each index of the substring.\n    var paren_dict = {};\n    //The currrent\
    \ index within the string of parentheses.\n    var i = 0;\n    //When parsing\
    \ a nested level of parentheses, this is the nesting level we are at.\n    var\
    \ current_depth = 0;\n    for (var val of output){\n        paren_dict[val] =\
    \ [];\n        for (var j = 0; j < val.length; j++){\n            if (val[j] ==\
    \ '('){\n                current_depth += 1;\n            }\n            if (val[j]\
    \ == ')'){\n                current_depth -= 1;\n            }\n            paren_dict[val].push(current_depth);\n\
    \        }\n    }\n    return paren_dict;\n}", "    let paren_arr = paren_string.split(\"\
    \ \");\n    let max_level = 0;\n    let level = 0;\n    let max_levels = [];\n\
    \    let print_string = \"\";\n    for(let paren of paren_arr){\n        level\
    \ = 0;\n        for(let ch of paren){\n            if(ch == \"(\"){\n        \
    \        level++;\n            }else if(ch == \")\"){\n                level--;\n\
    \            }\n        }\n        if(level > max_level){\n            max_level\
    \ = level;\n        }\n        max_levels.push(level);\n    }\n    for(let level\
    \ of max_levels){\n        print_string += level + \" \";\n    }\n    console.log(print_string);\n\
    }\n", "\tvar string_split = paren_string.split(' ');\n\tvar max = [0];\n\tfor(var\
    \ i = 0; i < string_split.length; i++){\n\t\tvar count = 0;\n\t\tvar string =\
    \ string_split[i];\n\t\tfor(var j = 0; j < string.length; j++){\n\t\t\tif(string[j]\
    \ == '('){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse if(string[j] == ')'){\n\t\t\t\
    \tcount--;\n\t\t\t}\n\t\t}\n\t\tmax.push(count);\n\t}\n\treturn max;\n}\n", " \
    \   var parenStack = [];\n    var parenCountArr = [];\n    var parenStrArr = paren_string.split('\
    \ ');\n    for(var i = 0; i < parenStrArr.length; i++){\n        var currentCount\
    \ = 0;\n        var currentParenStr = parenStrArr[i];\n        for(var j = 0;\
    \ j < currentParenStr.length; j++){\n            if(currentParenStr[j] === '('){\n\
    \                parenStack.push(currentParenStr[j]);\n                currentCount++;\n\
    \            }else if(currentParenStr[j] === ')'){\n                parenStack.pop();\n\
    \                currentCount--;\n            }\n        }\n        parenCountArr.push(currentCount);\n\
    \    }\n    return parenCountArr;\n}\n", "  var arr = [];\n  var str = '';\n \
    \ var count = 0;\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ === '('){\n      str += '(';\n      count += 1;\n    }\n    else if(paren_string[i]\
    \ === ')'){\n      str += ')';\n      count -= 1;\n    }\n    if(count === 0){\n\
    \      arr.push(str);\n      str = '';\n    }\n  }\n  var out = [];\n  for(var\
    \ j = 0; j < arr.length; j++){\n    var max = 0;\n    var temp = 0;\n    for(var\
    \ k = 0; k < arr[j].length; k++){\n      if(arr[j][k] === '('){\n        temp\
    \ += 1;\n      }\n      else if(arr[j][k] === ')'){\n        temp -= 1;\n    \
    \  }\n      if(temp > max){\n        max = temp;\n      }\n    }\n    out.push(max);\n\
    \  }\n  return out;\n}\n", "\t//split into substrings representing individual\
    \ groups of parentheses\n\tlet group_strings = paren_string.split(' ');\n\tlet\
    \ group_levels = [];\n\t\n\tfor(let i = 0; i < group_strings.length; i++){\n\t\
    \tgroup_levels.push(get_nested_group_level(group_strings[i]));\n\t}\n\t\n\treturn\
    \ group_levels;\n}\n", "    //create array to hold strings of different grouping\
    \ of parens\n    var paren_array = paren_string.split(\" \");\n    var paren_depth\
    \ = [];\n    //go through array and count depth of each grouping\n    for(i=0;\
    \ i<paren_array.length; i++){\n        var current_depth = 0;\n        var max_depth\
    \ = 0;\n        //go through each charater in the string and increment counters\
    \ based on value\n        for(j=0; j<paren_array[i].length; j++){\n          \
    \  var current_value = paren_array[i].charAt(j);\n            if(current_value\
    \ == '('){\n                current_depth += 1;\n            }\n            else\
    \ if(current_value == ')'){\n                current_depth -= 1;\n           \
    \ }\n            //set new max depth if current is larger\n            if(current_depth\
    \ > max_depth){\n                max_depth = current_depth;\n            }\n \
    \       }\n        //push depth to array\n        paren_depth.push(max_depth);\n\
    \    }\n    return paren_depth;\n}\n", "\n}\n", "    if(!paren_string){\n    \
    \    return [];\n    }\n    var paren_array = paren_string.split(\" \");\n   \
    \ var max_depth = 0;\n    var output = [];\n    paren_array.forEach(function(paren){\n\
    \        var max_depth = 0;\n        var current_depth = 0;\n        for(var i\
    \ = 0; i < paren.length; i++){\n            if(paren[i] === \"(\"){\n        \
    \        current_depth++;\n            }\n            else if(paren[i] === \"\
    )\"){\n                current_depth--;\n            }\n            if(current_depth\
    \ > max_depth){\n                max_depth = current_depth;\n            }\n \
    \       }\n        output.push(max_depth);\n    });\n    return output;\n}", "\t\
    var max_nesting = 0;\n\tvar current_nesting = 0;\n\t\n\tfor(var i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] == '('){\n\t\t\tcurrent_nesting++;\n\t\t\tif(current_nesting\
    \ > max_nesting){\n\t\t\t\tmax_nesting = current_nesting;\n\t\t\t}\n\t\t}else\
    \ if(paren_string[i] == ')'){\n\t\t\tcurrent_nesting--;\n\t\t}\n\t}\n\treturn\
    \ max_nesting;\n}\n", "    let max_level = 0;\n    let curr_level = 0;\n    for(let\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] === '('){\n\
    \            curr_level++;\n            if(curr_level > max_level){\n        \
    \        max_level = curr_level;\n            }\n        }\n        else if(paren_string[i]\
    \ === ')'){\n            curr_level--;\n        }\n    }\n    return max_level;\n\
    }\n", "    var paren_array = [];\n    var level = 0;\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            level++;\n        }else\
    \ if(paren_string[i] === ')'){\n            paren_array.push(level);\n       \
    \     level--;\n        }\n    }\n    return paren_array;\n}\n", "  var paren_array\
    \ = paren_string.split(\" \");\n  var max_levels = 0;\n  for(var i = 0; i < paren_array.length;\
    \ i++){\n    var curr_level = 0;\n    var temp_level = 0;\n    for(var j = 0;\
    \ j < paren_array[i].length; j++){\n      if(paren_array[i][j] == \"(\"){\n  \
    \      temp_level++;\n      }\n      else if(paren_array[i][j] == \")\"){\n  \
    \      temp_level--;\n      }\n      if(temp_level > curr_level){\n        curr_level\
    \ = temp_level;\n      }\n    }\n    if(curr_level > max_levels){\n      max_levels\
    \ = curr_level;\n    }\n  }\n  return max_levels;\n}\n", "  //Your code here\n\
    \  return paren_string.match(/\\((?=\\()|(?<=\\))\\)/g).length;\n}\n", "    //a\
    \ string to store the result\n    var result = '';\n    //for each group\n   \
    \ for(var i = 0; i < paren_string.length; i++){\n        //create a counter for\
    \ nested levels\n        var counter = 0;\n        //traverse a group\n      \
    \  for(var j = 0; j < paren_string[i].length; j++){\n            //if '(' then\
    \ increase the counter\n            if(paren_string[i][j] == '('){\n         \
    \       counter++;\n            }\n            //else if ')' then decrease the\
    \ counter\n            else if(paren_string[i][j] == ')'){\n                counter--;\n\
    \            }\n        }\n        //if at the end the counter is not zero, this\
    \ means the parentheses are unbalanced\n        if(counter != 0){\n          \
    \  result += 'error';\n        }\n        //else the counter is equal to the deepest\
    \ level of nesting\n        else{\n            result += counter;\n        }\n\
    \        //add a space in between each group\n        result += ' ';\n    }\n\
    \    //return the result\n    return result;\n}\n", "\tvar ret_arr = [];\n\t//Split\
    \ the string into groups\n\tvar paren_groups = paren_string.split(\" \");\n\t\n\
    \t//Loop through each group\n\tfor(i=0; i<paren_groups.length; i++){\n\t\tvar\
    \ paren_group = paren_groups[i];\n\t\tvar num_parens = 0;\n\t\tvar max_num_parens\
    \ = 0;\n\t\t\n\t\t//Loop through each character in group\n\t\tfor(j=0; j<paren_group.length;\
    \ j++){\n\t\t\tvar paren = paren_group[j];\n\t\t\tif(paren == '('){\n\t\t\t\t\
    num_parens++;\n\t\t\t\tif(num_parens > max_num_parens){\n\t\t\t\t\tmax_num_parens\
    \ = num_parens;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(paren == ')'){\n\t\t\t\tnum_parens--;\n\
    \t\t\t}\n\t\t}\n\t\t\n\t\t//Add number of parens for this group to the return\
    \ array\n\t\tret_arr.push(max_num_parens);\n\t}\n\t\n\treturn ret_arr;\n}\n",
  "    let result = [];\n    let arr = paren_string.split(' ');\n    for(let i = 0;\
    \ i < arr.length; i++){\n        let group = arr[i];\n        let max_nesting\
    \ = 0;\n        let current_nesting = 0;\n        for(let j = 0; j < group.length;\
    \ j++){\n            if(group[j] === '('){\n                current_nesting++;\n\
    \                if(current_nesting > max_nesting){\n                    max_nesting\
    \ = current_nesting;\n                }\n            }else if(group[j] === ')'){\n\
    \                current_nesting--;\n            }\n        }\n        result.push(max_nesting);\n\
    \    }\n    return result;\n}\n\nlet input = '(()()) ((())) (()(()))';", "  let\
    \ max_depth = 0;\n  let depth = 0;\n  for(let i = 0; i < paren_string.length;\
    \ i++){\n    const curr_char = paren_string[i];\n    if(curr_char === '('){\n\
    \      depth++;\n      max_depth = Math.max(max_depth, depth);\n    }\n    else\
    \ if(curr_char === ')'){\n      depth--;\n    }\n  }\n  return max_depth;\n}\n",
  "  var levels = paren_string.split(\" \");\n  var parenStack = [];\n  var max =\
    \ 0;\n  for(var i = 0; i < levels.length; i++){\n    for(var j = 0; j < levels[i].length;\
    \ j++){\n      if(levels[i][j] == '('){\n        parenStack.push('(');\n     \
    \ }else if(levels[i][j] == ')'){\n        parenStack.pop();\n      }\n    }\n\
    \    if(parenStack.length > max){\n      max = parenStack.length;\n    }\n   \
    \ parenStack = [];\n  }\n  return max;\n}\n", "    var paren_stack = [];\n   \
    \ var paren_levels = [];\n    var paren_level = 0;\n    var ans = [];\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] == '('){\n\
    \            paren_stack.push(paren_string[i]);\n            paren_level += 1;\n\
    \            paren_levels.push(paren_level);\n        }\n        else if(paren_string[i]\
    \ == ')'){\n            paren_stack.pop();\n            ans.push(paren_levels.pop());\n\
    \            paren_level -= 1;\n        }\n    }\n    return ans;\n}\n", "   \
    \ let max_depth = 0;\n    let depth = 0;\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            depth += 1;\n     \
    \       if(depth > max_depth){\n                max_depth = depth;\n         \
    \   }\n        }\n        else if(paren_string[i] === ')'){\n            depth\
    \ -= 1;\n        }\n    }\n    return max_depth;\n}\n", "\tvar parens = paren_string.split('\
    \ ');\n\tvar max_depth = 1;\n\tfor(var i=0; i<parens.length; i++){\n\t\tvar str\
    \ = parens[i];\n\t\tif(!is_balanced(str)){\n\t\t\tconsole.log('error');\n\t\t\t\
    return;\n\t\t}\n\t\tvar curr_depth = 0;\n\t\tvar max_curr_depth = 0;\n\t\tfor(var\
    \ j=0; j<str.length; j++){\n\t\t\tif(str[j] == '('){\n\t\t\t\tcurr_depth++;\n\t\
    \t\t\tif(curr_depth > max_curr_depth){\n\t\t\t\t\tmax_curr_depth = curr_depth;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcurr_depth--;\n\t\t\t}\n\t\t}\n\t\tif(max_curr_depth\
    \ > max_depth){\n\t\t\tmax_depth = max_curr_depth;\n\t\t}\n\t}\n\tconsole.log(max_depth);\n\
    }", "    //Create array of substrings to process\n    var substrings = paren_string.split(\"\
    \ \");\n    //Initialize maximum levels of nesting to zero\n    var max_levels\
    \ = 0;\n    //For each substring\n    for(var i = 0; i < substrings.length; i++){\n\
    \        //get current substring\n        var str = substrings[i];\n        //Initialize\
    \ current nesting level to zero\n        var curr_level = 0;\n        //For each\
    \ character in substring\n        for(var j = 0; j < str.length; j++){\n     \
    \       //get current character\n            var c = str.charAt(j);\n        \
    \    //if current character is left parentheses, increase nesting level\n    \
    \        if(c == '('){\n                curr_level++;\n            }\n       \
    \     //if current character is right parentheses, decrease nesting level\n  \
    \          else if(c == ')'){\n                curr_level--;\n            }\n\
    \            //if current nesting level is greater than maximum levels, set max_levels\
    \ equal to curr_level\n            if(curr_level > max_levels){\n            \
    \    max_levels = curr_level;\n            }\n        }\n    }\n    //return maximum\
    \ levels of nesting\n    return max_levels;\n}\n", "  var parens_array = paren_string.split(\"\
    \ \");\n  var result = []\n  parens_array.forEach(function(paren_group){\n   \
    \ result.push(max_depth(paren_group));\n  });\n  return result;\n}\n", "    var\
    \ stack = []\n    var res = []\n    var current_stack = []\n    for(var i = 0;\
    \ i < paren_string.length; i++){\n        var current_char = paren_string[i]\n\
    \        if(current_char === '('){\n            stack.push(current_char)\n   \
    \         current_stack.push(current_char)\n        }\n        else if(current_char\
    \ === ')'){\n            stack.pop()\n            current_stack.pop()\n      \
    \  }\n        else if(current_char === ' '){\n            res.push(stack.length)\n\
    \            stack = []\n            current_stack = []\n        }\n    }\n  \
    \  return res\n}\n\nvar res = parse_nested_parens('(()()) ((()))')", "\tvar paren_array\
    \ = paren_string.split(' ');\n\tvar result = '';\n\tfor(var i = 0; i < paren_array.length;\
    \ i++){\n\t\tvar level = paren_array[i].length;\n\t\tvar max_level = 0;\n\t\t\
    for(var j = 0; j < paren_array[i].length; j++){\n\t\t\tif(paren_array[i][j] ==\
    \ '('){\n\t\t\t\tlevel++;\n\t\t\t\tif(level > max_level){\n\t\t\t\t\tmax_level\
    \ = level;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t}\n\
    \t\tresult += (max_level + ' ');\n\t}\n\treturn result;\n}\n", "    // Your code\
    \ here\n    var stack = [], deepest_level = 0;\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == '('){\n            stack.push(paren_string[i]);\n\
    \            if(stack.length > deepest_level){\n                deepest_level\
    \ = stack.length;\n            }\n        }\n        else if(paren_string[i] ==\
    \ ')'){\n            stack.pop();\n        }\n    }\n    return deepest_level;\n\
    }\n", "  var max_depth = 0;\n  var curr_depth = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      curr_depth++;\n      if(curr_depth\
    \ > max_depth){\n        max_depth = curr_depth;\n      }\n    }\n    else if(paren_string[i]\
    \ == ')'){\n      curr_depth--;\n    }\n  }\n  return max_depth;\n}\n", "\tconst\
    \ pattern = /(\\(+[^()]*\\))+/g\n\tlet match = pattern.exec(paren_string)\n\t\
    let deepest_level = 0\n\twhile(match){\n\t\tlet temp_deepest_level = match[0].split('').filter(char\
    \ => char == '(').length\n\t\tif(temp_deepest_level > deepest_level){\n\t\t\t\
    deepest_level = temp_deepest_level\n\t\t}\n\t\tmatch = pattern.exec(paren_string)\n\
    \t}\n\treturn deepest_level\n}\n", "\tvar paren_string_array = paren_string.split(\"\
    \ \");\n\tvar max_depth = 0;\n\tfor(var i = 0; i < paren_string_array.length;\
    \ i++){\n\t\tvar current_p = paren_string_array[i];\n\t\tvar max_depth_current\
    \ = 0;\n\t\tfor(var j = 0; j < current_p.length; j++){\n\t\t\tif(current_p[j]\
    \ == \"(\"){\n\t\t\t\tmax_depth_current += 1;\n\t\t\t}else if(current_p[j] ==\
    \ \")\"){\n\t\t\t\tmax_depth_current -= 1;\n\t\t\t}\n\t\t}\n\t\tif(max_depth_current\
    \ > max_depth){\n\t\t\tmax_depth = max_depth_current;\n\t\t}\n\t}\n\treturn max_depth;\n\
    }\n\nvar paren_string = \"(()()) (()()()(()))\";", "    let groups = paren_string.split('\
    \ ')\n    for(let i=0; i<groups.length; i++){\n        let group = groups[i]\n\
    \        let max = 0\n        let count = 0\n        for(let char of group){\n\
    \            if(char === '('){\n                count++\n                if(count\
    \ > max){\n                    max = count\n                }\n            }\n\
    \            else if(char === ')'){\n                count--\n            }\n\
    \        }\n        groups[i] = max\n    }\n    return groups\n}\n", "  var levels\
    \ = []\n  var paren_groups = paren_string.split(' ')\n  for (var i = 0; i < paren_groups.length;\
    \ i++){\n    var paren_group = paren_groups[i]\n    var level = 0\n    var max_level\
    \ = 0\n    for (var j = 0; j < paren_group.length; j++){\n      if (paren_group[j]\
    \ == '('){\n        level += 1\n      } else if (paren_group[j] == ')'){\n   \
    \     level -= 1\n      }\n      if (level > max_level){\n        max_level =\
    \ level\n      }\n    }\n    levels.push(max_level)\n  }\n  return levels\n}\n",
  "  var max_nesting = 0;\n  var nesting = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      nesting++;\n      if(nesting >\
    \ max_nesting){\n        max_nesting = nesting;\n      }\n    }\n    else if(paren_string[i]\
    \ == ')'){\n      nesting--;\n    }\n  }\n  return max_nesting;\n}\n", "    paren_string\
    \ = paren_string.split(\" \");\n    var max_nesting = 0;\n    for(var i = 0; i\
    \ < paren_string.length; i++){\n        var current_nesting = 0;\n        var\
    \ current_string = paren_string[i];\n        var last_seen_char = current_string[0];\n\
    \        for(var j = 1; j < current_string.length; j++){\n            if(current_string[j]\
    \ == \")\" && last_seen_char == \"(\"){\n                current_nesting--;\n\
    \            }\n            else if(current_string[j] == \"(\" && last_seen_char\
    \ == \")\"){\n                current_nesting++;\n            }\n            last_seen_char\
    \ = current_string[j];\n        }\n        if(current_nesting > max_nesting){\n\
    \            max_nesting = current_nesting;\n        }\n    }\n    console.log(max_nesting);\n\
    }\n\nparse_nested_parens(\"(()()) ()()()\");", "    let i = 0;\n    let paren_counter\
    \ = 0;\n    let max_paren_counter = 0;\n    while(i < paren_string.length){\n\
    \        if(paren_string[i] == '('){\n            paren_counter += 1;\n      \
    \      max_paren_counter = Math.max(max_paren_counter, paren_counter);\n     \
    \   }\n        else if(paren_string[i] == ')'){\n            paren_counter -=\
    \ 1;\n        }\n        i += 1;\n    }\n    return max_paren_counter;\n}\n",
  "  var results = []\n  paren_string.split(' ').forEach(function(paren_group){\n\
    \    results.push(paren_group.split('').reduce(function(previous, char){\n   \
    \   if(char === '('){\n        return previous + 1\n      } else if(char === ')'){\n\
    \        return previous - 1\n      }\n    }, 0))\n  })\n  return results\n}",
  "  var paren_array = paren_string.split(' ');\n  var parsed_array = [];\n  for(var\
    \ i = 0; i < paren_array.length; i++){\n    var current_group = paren_array[i];\n\
    \    var current_max = 0;\n    var current_count = 0;\n    for(var j = 0; j <\
    \ current_group.length; j++){\n      if(current_group[j] === '('){\n        current_count++;\n\
    \        if(current_count > current_max){\n          current_max = current_count;\n\
    \        }\n      }\n      else if(current_group[j] === ')'){\n        current_count--;\n\
    \      }\n    }\n    parsed_array.push(current_max);\n  }\n  return parsed_array;\n\
    }\n", "    let nestLevel = 0;\n    let maxNestLevel = 0;\n    for(let i = 0; i\
    \ < paren_string.length; i++){\n        let curParen = paren_string[i];\n    \
    \    if(curParen === '('){\n            nestLevel++;\n            if(nestLevel\
    \ > maxNestLevel){\n                maxNestLevel = nestLevel;\n            }\n\
    \        }\n        else if(curParen === ')'){\n            nestLevel--;\n   \
    \     }\n    }\n    return maxNestLevel;\n}\n", "    // get all groups of parentheses\n\
    \    var groups = paren_string.split(\" \");\n    // loop over groups\n    for\
    \ (var i = 0; i < groups.length; i++){\n        var group = groups[i];\n     \
    \   // total depth\n        var depth = 0;\n        // current depth\n       \
    \ var current_depth = 0;\n        // loop over characters in group\n        for\
    \ (var j = 0; j < group.length; j++){\n            var char = group[j];\n    \
    \        // if char is open paren, increase depth\n            if (char == \"\
    (\"){\n                current_depth += 1;\n            }\n            // if char\
    \ is close paren, decrease depth\n            else if (char == \")\"){\n     \
    \           current_depth -= 1;\n            }\n            // if current depth\
    \ is greater than total depth, replace total depth\n            if (current_depth\
    \ > depth){\n                depth = current_depth;\n            }\n        }\n\
    \        // replace group with depth\n        groups[i] = depth;\n    }\n    //\
    \ return groups\n    return groups;\n}\n", "    let level = 0;\n    let max_level\
    \ = 0;\n    let result = [];\n    let parens = paren_string.split(\" \");\n  \
    \  let parens_len = parens.length;\n    for(let i = 0; i < parens_len; i++){\n\
    \        let paren = parens[i];\n        let paren_len = paren.length;\n     \
    \   for(let j = 0; j < paren_len; j++){\n            if(paren[j] === \"(\"){\n\
    \                level++;\n                if(level > max_level){\n          \
    \          max_level = level;\n                }\n            }else if(paren[j]\
    \ === \")\"){\n                level--;\n            }\n        }\n        result.push(max_level);\n\
    \        level = 0;\n        max_level = 0;\n    }\n    return result;\n}\n",
  "  let arr = paren_string.split(\" \");\n  let res = [];\n  for(let i = 0; i < arr.length;\
    \ i++){\n    let parens = arr[i];\n    let count = 0;\n    let max = 0;\n    for(let\
    \ j = 0; j < parens.length; j++){\n      if(parens[j] === \"(\"){\n        count++;\n\
    \        if(count > max){\n          max = count;\n        }\n      }else if(parens[j]\
    \ === \")\"){\n        count--;\n      }\n    }\n    res.push(max);\n  }\n  return\
    \ res;\n}\n", "\tvar result = [];\n\tvar max_level = 0;\n\tvar current_level =\
    \ 0;\n\tfor(var i = 0; i < paren_string.length; i++){\n\t\tvar current_char =\
    \ paren_string[i];\n\t\tif(current_char == '('){\n\t\t\tcurrent_level += 1;\n\t\
    \t\tif(current_level > max_level){\n\t\t\t\tmax_level = current_level;\n\t\t\t\
    }\n\t\t}\n\t\telse if(current_char == ')'){\n\t\t\tresult.push(max_level);\n\t\
    \t\tcurrent_level -= 1;\n\t\t\tmax_level = current_level;\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n", "    var paren_levels = 0, max_levels = 0;\n    for(var i = 0;\
    \ i < paren_string.length; i++){\n        if(paren_string[i] == '('){\n      \
    \      paren_levels++;\n            if(paren_levels > max_levels){\n         \
    \       max_levels = paren_levels;\n            }\n        }\n        else if(paren_string[i]\
    \ == ')'){\n            paren_levels--;\n        }\n    }\n    return max_levels;\n\
    }\n", "  paren_list = paren_string.split(\" \");\n  for(var i = 0; i < paren_list.length;\
    \ i++){\n    var max_level = 0;\n    var current_level = 0;\n    for(var j = 0;\
    \ j < paren_list[i].length; j++){\n      if(paren_list[i][j] == \"(\"){\n    \
    \    current_level++;\n        if(current_level > max_level){\n          max_level\
    \ = current_level;\n        }\n      }\n      else if(paren_list[i][j] == \")\"\
    ){\n        current_level--;\n      }\n    }\n    console.log(max_level);\n  }\n\
    }\n", "    var max_nesting = 0;\n    var current_depth = 0;\n    for(var i = 0;\
    \ i < paren_string.length; i++){\n        if(paren_string[i] == '('){\n      \
    \      current_depth++;\n            if(current_depth > max_nesting){\n      \
    \          max_nesting = current_depth;\n            }\n        }else if(paren_string[i]\
    \ == ')'){\n            current_depth--;\n        }\n    }\n    return max_nesting;\n\
    }\n", "    var max_levels = 0;\n    var temp_levels = 0;\n    for(var i = 0; i\
    \ < paren_string.length; i++){\n        if(paren_string[i] === '('){\n       \
    \     temp_levels++;\n            if(temp_levels > max_levels){\n            \
    \    max_levels = temp_levels;\n            }\n        }\n        else if(paren_string[i]\
    \ === ')'){\n            temp_levels--;\n        }\n    }\n    return max_levels;\n\
    }\n", "    var max_depth = 0;\n    var depth = 0;\n    var paren_array = paren_string.split('');\n\
    \    for(var i = 0; i < paren_array.length; i++){\n        if(paren_array[i] ==\
    \ '('){\n            depth += 1;\n            if(depth > max_depth){\n       \
    \         max_depth = depth;\n            }\n        }\n        else if(paren_array[i]\
    \ == ')'){\n            depth -= 1;\n        }\n    }\n    return max_depth;\n\
    }\n", "  paren_string = paren_string.split(\" \");\n  return paren_string.map(string\
    \ => {\n    let maxDepth = 0;\n    let currentDepth = 0;\n    for (let i = 0;\
    \ i < string.length; i++) {\n      if (string[i] === \"(\") {\n        currentDepth\
    \ += 1;\n        maxDepth = Math.max(maxDepth, currentDepth);\n      } else if\
    \ (string[i] === \")\") {\n        currentDepth -= 1;\n      }\n    }\n    return\
    \ maxDepth;\n  });\n}\n", "\t\n\tvar max_nesting = 0;\n\tvar n_open = 0;\n\tvar\
    \ n_close = 0;\n\tvar str_len = paren_string.length;\n\tfor(var i = 0; i < str_len;\
    \ i++){\n\t\tif(paren_string[i] == '('){\n\t\t\tn_open++;\n\t\t\tif(n_open > max_nesting){\n\
    \t\t\t\tmax_nesting = n_open;\n\t\t\t}\n\t\t}else if(paren_string[i] == ')'){\n\
    \t\t\tn_close++;\n\t\t}\n\t}\n\tif(n_open == n_close){\n\t\tconsole.log(max_nesting);\n\
    \t}else{\n\t\tconsole.log(\"Invalid input\");\n\t}\n\t\n}", "    let max_depth\
    \ = 0;\n    let current_depth = 0;\n    for(let c of paren_string){\n        if(c\
    \ == \"(\"){\n            current_depth++;\n            max_depth = Math.max(max_depth,\
    \ current_depth);\n        }else if(c == \")\"){\n            current_depth--;\n\
    \        }\n    }\n    return max_depth;\n}\n", "\tvar output_arr = [];\n\n\t\
    var paren_groups = paren_string.split(\" \");\n\n\tfor(var i = 0; i < paren_groups.length;\
    \ i++){\n\t\toutput_arr.push(get_max_level(paren_groups[i]));\n\t}\n\n\treturn\
    \ output_arr;\n}\n", "  let output = []\n  let paren_groups = paren_string.split('\
    \ ')\n  for (let paren of paren_groups){\n    let max = 0\n    let current = 0\n\
    \    for (let char of paren){\n      if (char === '('){\n        current++\n \
    \       if (current > max){\n          max = current\n        }\n      }\n   \
    \   else if (char === ')'){\n        current--\n      }\n    }\n    output.push(max)\n\
    \  }\n  return output\n}\n\nlet test1 = \"(()())\"\nlet test2 = \"((()))\"", " \
    \   let paren_array = paren_string.split(' ');\n    //create an array to store\
    \ the number of deepest nesting of parens for each group\n    let paren_nesting_array\
    \ = [];\n    for(i=0; i<paren_array.length; i++){\n        //declare a counter\
    \ variable to store the maximum nesting of parens for each group\n        let\
    \ nesting_counter = 0;\n        //declare a second counter variable to store the\
    \ nesting of parens for each group\n        let temp_counter = 0;\n        //split\
    \ each group into an array and loop through the array\n        let paren_group\
    \ = paren_array[i].split('');\n        for(j=0; j<paren_group.length; j++){\n\
    \            //when a left paren is encountered, increase the nesting counter\
    \ by 1\n            if(paren_group[j] === '('){\n                temp_counter\
    \ += 1;\n            }\n            //when a right paren is encountered, decrease\
    \ the nesting counter by 1\n            if(paren_group[j] === ')'){\n        \
    \        temp_counter -= 1;\n            }\n            //if the current nesting\
    \ counter exceeds the maximum nesting counter,\n            //replace the maximum\
    \ nesting counter with the current nesting counter\n            if(temp_counter\
    \ > nesting_counter){\n                nesting_counter = temp_counter;\n     \
    \       }\n        }\n        //add the maximum nesting counter to the array\n\
    \        paren_nesting_array.push(nesting_counter);\n    }\n    return paren_nesting_array;\n\
    }\n", "    //write your code here\n    if(paren_string[0]==='('&&paren_string[paren_string.length-1]===')'){\n\
    \        return 1+parse_nested_parens(paren_string.slice(1,paren_string.length-1));\n\
    \    }\n    else{\n        return 0;\n    }\n}\n", "  let maxDepth=0;\n  let currentDepth=0;\n\
    \  for(let i=0;i<paren_string.length;i++){\n    let currentChar=paren_string[i];\n\
    \    if(currentChar==='('){\n      currentDepth+=1;\n      if(currentDepth>maxDepth){\n\
    \        maxDepth=currentDepth;\n      }\n    }\n    else if(currentChar===')'){\n\
    \      currentDepth-=1;\n    }\n  }\n  return maxDepth;\n}\n", "    let paren_stack\
    \ = [], max_depth = 0;\n    for(const c of paren_string){\n        if(c == '('){\n\
    \            paren_stack.push(c);\n            max_depth = Math.max(max_depth,\
    \ paren_stack.length);\n        }else if(c == ')'){\n            paren_stack.pop();\n\
    \        }\n    }\n    return max_depth;\n}", "\tvar results = [];\n\tvar parens\
    \ = paren_string.split(' ');\n\tparens.forEach(function(p){\n\t\tvar count = 0;\n\
    \t\tvar max = 0;\n\t\tfor(var i = 0; i < p.length; i++){\n\t\t\tif(p[i] === '('){\n\
    \t\t\t\tcount++;\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\
    \t\t\t}\n\t\t\telse if(p[i] === ')'){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\t\
    results.push(max);\n\t});\n\treturn results;\n}\n", "    var result = [];\n  \
    \  var parens = paren_string.split(\" \");\n    for(var i = 0; i < parens.length;\
    \ i++){\n        result.push(max_nested_parens(parens[i]));\n    }\n    return\
    \ result;\n}\n", "    var max_depth = 0;\n    var current_depth = 0;\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] == '('){\n\
    \            current_depth++;\n            if(current_depth > max_depth){\n  \
    \              max_depth = current_depth;\n            }\n        }\n        else\
    \ if(paren_string[i] == ')'){\n            current_depth--;\n        }\n    }\n\
    \    return max_depth;\n}\n", "  var max_level = 0;\n  var result = [];\n  //\
    \ base case: if string length is 0 then no more parens to parse\n  if (paren_string.length\
    \ == 0){\n    return max_level;\n  }\n  // find the number of groups\n  for (var\
    \ i = 0; i < paren_string.length; i++){\n    // delimiter is whitespace\n    if\
    \ (paren_string[i] == ' '){\n      result.push(parse_nested_parens(paren_string.substring(0,\
    \ i)));\n      result.push(parse_nested_parens(paren_string.substring(i+1, paren_string.length)));\n\
    \      return result;\n    }\n  }\n  // if only one group, parse the parens\n\
    \  var paren_count = 0;\n  for (var i = 0; i < paren_string.length; i++){\n  \
    \  if (paren_string[i] == '('){\n      paren_count++;\n    }\n    else if (paren_string[i]\
    \ == ')'){\n      paren_count--;\n    }\n    // if paren count is negative then\
    \ parens are not properly closed\n    if (paren_count < 0){\n      return -1;\n\
    \    }\n    max_level = Math.max(max_level, paren_count);\n  }\n  // if paren\
    \ count is non-zero then parens are not properly closed\n  if (paren_count !=\
    \ 0){\n    return -1;\n  }\n  return max_level;\n}", "\treturn paren_string.split('\
    \ ').map(function(paren_group){\n\t\tvar level = 0;\n\t\tvar max_level = 0;\n\t\
    \tparen_group.split('').forEach(function(char){\n\t\t\tif(char == '('){\n\t\t\t\
    \tlevel += 1;\n\t\t\t\tif(level > max_level){\n\t\t\t\t\tmax_level = level;\n\t\
    \t\t\t}\n\t\t\t}else if(char == ')'){\n\t\t\t\tlevel -= 1;\n\t\t\t}\n\t\t});\n\
    \t\treturn max_level;\n\t});\n}\n", "\tlet result = [];\n\tlet arr = paren_string.split('\
    \ ');\n\tfor(let i=0; i<arr.length; i++){\n\t\tlet sub_arr = arr[i].split('');\n\
    \t\tlet counter = 0;\n\t\tlet max = 0;\n\t\tfor(let j=0; j<sub_arr.length; j++){\n\
    \t\t\tif(sub_arr[j] === '('){\n\t\t\t\tcounter += 1;\n\t\t\t\tif(counter > max){\n\
    \t\t\t\t\tmax = counter;\n\t\t\t\t}\n\t\t\t}else if(sub_arr[j] === ')'){\n\t\t\
    \t\tcounter -= 1;\n\t\t\t}\n\t\t}\n\t\tresult.push(max);\n\t}\n\treturn result;\n\
    }\n", "  var paren_array = paren_string.split(\" \");\n  var results = [];\n \
    \ for(var i = 0; i < paren_array.length; i++){\n    var max_nesting = 0;\n   \
    \ var current_nesting = 0;\n    for(var j = 0; j < paren_array[i].length; j++){\n\
    \      if(paren_array[i][j] == \"(\"){\n        current_nesting++;\n        if(current_nesting\
    \ > max_nesting){\n          max_nesting = current_nesting;\n        }\n     \
    \ }\n      else if(paren_array[i][j] == \")\"){\n        current_nesting--;\n\
    \      }\n    }\n    results.push(max_nesting);\n  }\n  return results;\n}\n",
  "  var arr = paren_string.split(' ');\n  return arr.map(function(item){\n    return\
    \ dfs(item, 0, 0, 0);\n  });\n}\n", "    var result = [];\n    //Split the input\
    \ string into groups based on spaces.\n    var split_str = paren_string.split(\"\
    \ \");\n    var depth = 0;\n    var max_depth = 0;\n    for(var i = 0; i < split_str.length;\
    \ i++){\n        //console.log(split_str[i]);\n        for(var j = 0; j < split_str[i].length;\
    \ j++){\n            if(split_str[i][j] == '('){\n                depth++;\n \
    \               max_depth = Math.max(depth, max_depth);\n            }\n     \
    \       else if(split_str[i][j] == ')'){\n                depth--;\n         \
    \   }\n        }\n        result.push(max_depth);\n        max_depth = 0;\n  \
    \      depth = 0;\n    }\n    return result;\n}\n", "    var parens = paren_string.split('\
    \ ');\n    for(var i = 0; i < parens.length; i++){\n        var stack = [];\n\
    \        var max_len = 0;\n        var stack_len = 0;\n        for(var j = 0;\
    \ j < parens[i].length; j++){\n            if(parens[i][j] == '('){\n        \
    \        stack.push(parens[i][j]);\n                stack_len++;\n           \
    \     if(stack_len > max_len){\n                    max_len = stack_len;\n   \
    \             }\n            }\n            else if(parens[i][j] == ')'){\n  \
    \              stack.pop();\n                stack_len--;\n            }\n   \
    \     }\n        console.log('max len is ' + max_len);\n    }\n}\n", "\tvar deepest_level\
    \ = 0;\n\tvar current_level = 0;\n\tfor(var i = 0; i < paren_string.length; i++){\n\
    \t\tif(paren_string[i] == '('){\n\t\t\tcurrent_level++;\n\t\t\tif(current_level\
    \ > deepest_level){\n\t\t\t\tdeepest_level = current_level;\n\t\t\t}\n\t\t}\n\t\
    \telse if(paren_string[i] == ')'){\n\t\t\tcurrent_level--;\n\t\t}\n\t}\n\treturn\
    \ deepest_level;\n}\n", "    //Your code here\n}", "    let max_depth = 0;\n \
    \   let curr_depth = 0;\n    for(let i = 0; i < paren_string.length; i++){\n \
    \       if(paren_string[i] === '('){\n            curr_depth++;\n            if(curr_depth\
    \ > max_depth){\n                max_depth = curr_depth;\n            }\n    \
    \    }\n        else if(paren_string[i] === ')'){\n            curr_depth--;\n\
    \        }\n    }\n    return max_depth;\n}\n", "    // console.log(paren_string);\n\
    \    var groups = paren_string.split(\" \");\n    var max_nest_count = 0;\n  \
    \  for(var i = 0; i < groups.length; i++){\n        var count = 0;\n        var\
    \ word = groups[i];\n        for(var j = 0; j < word.length; j++){\n         \
    \   if(word[j] == '('){\n                count++;\n            }\n           \
    \ else if(word[j] == ')'){\n                count--;\n            }\n        }\n\
    \        if(count > max_nest_count){\n            max_nest_count = count;\n  \
    \      }\n    }\n    return max_nest_count;\n}\n", "    var str = paren_string.replace(/\\\
    s/g,'');\n    var max_count = 0;\n    var count = 0;\n    for(var i=0; i<str.length;\
    \ i++){\n        if(str[i] === '('){\n            count += 1;\n            if(count\
    \ > max_count){\n                max_count = count;\n            }\n        }\n\
    \        else if(str[i] === ')'){\n            count -= 1;\n        }\n    }\n\
    \    return max_count;\n}\n", "    // TO DO\n    let res = [];\n    let parens\
    \ = paren_string.split(' ');\n    for (let paren of parens) {\n        let max_level\
    \ = 0;\n        let cur_level = 0;\n        for (let char of paren) {\n      \
    \      if (char === '(') {\n                cur_level++;\n                max_level\
    \ = Math.max(max_level, cur_level);\n            } else if (char === ')') {\n\
    \                cur_level--;\n            }\n        }\n        res.push(max_level);\n\
    \    }\n    return res;\n}\n", "  if (paren_string.length == 0) return 0;\n  let\
    \ max_nesting = 0;\n  let nesting = 0;\n  for (let i = 0; i < paren_string.length;\
    \ i++){\n    let paren = paren_string[i];\n    if (paren == '(') {\n      nesting++;\n\
    \      if (nesting > max_nesting) max_nesting = nesting;\n    } else if (paren\
    \ == ')') {\n      nesting--;\n    }\n  }\n  return max_nesting;\n}", "\tvar paren_array\
    \ = paren_string.split(' ');\n\tvar paren_deeper = [];\n\tvar paren_shallow =\
    \ [];\n\tfor(i = 0; i < paren_array.length; i++){\n\t\tvar deeper = 0;\n\t\tvar\
    \ shallow = 0;\n\t\tfor(j = 0; j < paren_array[i].length; j++){\n\t\t\tif(paren_array[i][j]\
    \ == '('){\n\t\t\t\tshallow += 1;\n\t\t\t\tif(shallow > deeper){\n\t\t\t\t\tdeeper\
    \ = shallow;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(paren_array[i][j] == ')'){\n\t\
    \t\t\tshallow -= 1;\n\t\t\t}\n\t\t}\n\t\tparen_deeper.push(deeper);\n\t\tparen_shallow.push(shallow);\n\
    \t}\n\tconsole.log(paren_deeper);\n\tconsole.log(paren_shallow);\n}\n", "  var\
    \ res = [];\n  var paren_arr = paren_string.split(\" \");\n  for(var i = 0; i\
    \ < paren_arr.length; i++){\n    var current_nest = 0;\n    var current_max =\
    \ 0;\n    for(var j = 0; j < paren_arr[i].length; j++){\n      if(paren_arr[i][j]\
    \ == \"(\"){\n        current_nest += 1;\n        if(current_nest > current_max){\n\
    \          current_max = current_nest;\n        }\n      }\n      else if(paren_arr[i][j]\
    \ == \")\"){\n        current_nest -= 1;\n      }\n    }\n    res.push(current_max);\n\
    \  }\n  return res;\n}\n", "    var group = paren_string.split(\" \");\n    var\
    \ deepest = [];\n    var left_paren_count = 0;\n    var right_paren_count = 0;\n\
    \    var max_count = 0;\n    var c;\n    for(var i = 0; i < group.length; i++){\n\
    \        left_paren_count = 0;\n        right_paren_count = 0;\n        max_count\
    \ = 0;\n        for(var j = 0; j < group[i].length; j++){\n            c = group[i].charAt(j);\n\
    \            if(c == '('){\n                left_paren_count++;\n            \
    \    if(left_paren_count > max_count){\n                    max_count = left_paren_count;\n\
    \                }\n            }else if(c == ')'){\n                right_paren_count++;\n\
    \                if(right_paren_count > max_count){\n                    max_count\
    \ = right_paren_count;\n                }\n            }\n        }\n        deepest.push(max_count);\n\
    \    }\n    return deepest;\n}\n", "    var paren_length = paren_string.length;\n\
    \    var paren_arr = paren_string.split('');\n    var output_arr = [];\n    var\
    \ level = 0;\n    var max_level = 0;\n    //Loop through the string, if a '('\
    \ is found, increase the level count and set the max level if it's greater.\n\
    \    // if a ')' is found, decrease the level count, and reset the max_level if\
    \ it's greater than level.\n    for(var i = 0; i < paren_length; i++){\n     \
    \   if(paren_arr[i] === '('){\n            level++;\n            if(level > max_level){\n\
    \                max_level = level;\n            }\n        }\n        else if(paren_arr[i]\
    \ === ')'){\n            level--;\n            if(level > max_level){\n      \
    \          max_level = level;\n            }\n        }\n    }\n    output_arr.push(max_level);\n\
    \    return output_arr;\n}", "    let groups = paren_string.split(' ')\n    let\
    \ max_counts = []\n    for (let i = 0; i < groups.length; i++){\n        max_counts.push(paren_count(groups[i]))\n\
    \    }\n    return max_counts\n}\n", "    //Split the string into an array of\
    \ group substrings based on spaces.\n    var groups = paren_string.split(\" \"\
    );\n    //For each group, calculate and push the depth to the depth_results array.\n\
    \    var depth_results = [];\n    for(var i = 0; i < groups.length; i++){\n  \
    \      var current_group = groups[i];\n        var current_depth = get_depth(current_group);\n\
    \        depth_results.push(current_depth);\n    }\n    //Return the depth_results\
    \ array.\n    return depth_results;\n}\n", "    const parens = paren_string.split('\
    \ ');\n    let result = [];\n    for(let paren of parens){\n        result.push(paren_to_depth(paren));\n\
    \    }\n    return result;\n}\n", "    //TODO: Implement this function!\n    var\
    \ i = 0;\n    var res = [];\n    while(i < paren_string.length){\n        var\
    \ char = paren_string[i];\n        if(char == \"(\"){\n            var new_string\
    \ = \"\";\n            i++;\n            var new_char = paren_string[i];\n   \
    \         while(new_char != \")\"){\n                new_string += new_char;\n\
    \                i++;\n                new_char = paren_string[i];\n         \
    \   }\n            res.push(new_string);\n        }\n        i++;\n    }\n   \
    \ var ans = [];\n    for(var i = 0; i < res.length; i++){\n        ans.push(parse_nested_parens(res[i]));\n\
    \    }\n    return res.length;\n}\n", "  const paren_list = paren_string.split('\
    \ ');\n  const result = [];\n  for(let i = 0; i < paren_list.length; i++){\n \
    \   let paren = paren_list[i];\n    let max_paren = 0;\n    let count = 0;\n \
    \   for(let j = 0; j < paren.length; j++){\n      if(paren[j] === '('){\n    \
    \    count += 1;\n        if(count > max_paren){\n          max_paren = count;\n\
    \        }\n      } else {\n        count -= 1;\n      }\n    }\n    result.push(max_paren);\n\
    \  }\n  return result;\n}\n", "    var output = [];\n    var stack = [];\n   \
    \ var curr_string = \"\";\n    var count = 0;\n    var max_count = 0;\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] == \"(\"){\n\
    \            stack.push(paren_string[i]);\n            count++;\n            if(count\
    \ > max_count){\n                max_count = count;\n            }\n        }\n\
    \        else if(paren_string[i] == \")\"){\n            stack.pop();\n      \
    \      count--;\n        }\n        else if(paren_string[i] == \" \"){\n     \
    \       if(count == 0){\n                output.push(max_count);\n           \
    \     max_count = 0;\n            }\n        }\n    }\n    return output;\n}",
  "  var group = paren_string.split(\" \");\n  var paren = {open: 0, closed: 0};\n\
    \  var max_nesting = 0;\n  var current_nesting = 0;\n  for(var i = 0; i < group.length;\
    \ i++){\n    for(var j = 0; j < group[i].length; j++){\n      if(group[i][j] ===\
    \ '('){\n        paren.open++;\n        current_nesting++;\n      }else if(group[i][j]\
    \ === ')'){\n        paren.closed++;\n        current_nesting--;\n      }\n  \
    \    if(paren.open === paren.closed){\n        max_nesting = Math.max(max_nesting,\
    \ paren.open);\n        current_nesting = 0;\n        paren.open = 0;\n      \
    \  paren.closed = 0;\n      }\n    }\n  }\n  return max_nesting;\n}", "  let parens\
    \ = paren_string.split(' ');\n  let result = [];\n  for(let i = 0; i < parens.length;\
    \ i++){\n    let count = 0;\n    let max = 0;\n    for(let j = 0; j < parens[i].length;\
    \ j++){\n      if(parens[i][j] === '('){\n        count++;\n        if(count >\
    \ max){\n          max = count;\n        }\n      }\n      if(parens[i][j] ===\
    \ ')'){\n        count--;\n      }\n    }\n    result.push(max);\n  }\n  return\
    \ result;\n}\n", "\tvar max_level = 0;\n\tvar level = 0;\n\tfor(var i = 0; i <\
    \ paren_string.length; i++){\n\t\tif(paren_string[i] == '('){\n\t\t\tlevel++;\n\
    \t\t\tif(level > max_level){\n\t\t\t\tmax_level = level;\n\t\t\t}\n\t\t}\n\t\t\
    else if(paren_string[i] == ')'){\n\t\t\tlevel--;\n\t\t}\n\t}\n\treturn max_level;\n\
    }\n", "\tlet result = [];\n\tlet split_string = paren_string.split(\" \");\n\t\
    for(let i = 0; i < split_string.length; i++){\n\t\tlet length = split_string[i].length;\n\
    \t\tlet paren_count = 0;\n\t\tlet max_count = 0;\n\t\tlet max_index = 0;\n\t\t\
    for(let j = 0; j < length; j++){\n\t\t\tif(split_string[i][j] === \"(\"){\n\t\t\
    \t\tparen_count++;\n\t\t\t\tif(paren_count > max_count){\n\t\t\t\t\tmax_count\
    \ = paren_count;\n\t\t\t\t\tmax_index = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(split_string[i][j]\
    \ === \")\"){\n\t\t\t\tparen_count--;\n\t\t\t}\n\t\t}\n\t\tresult.push(split_string[i].substring(max_index));\n\
    \t}\n\treturn result;\n}\n", "    var paren_string_array = paren_string.split(\"\
    \ \");\n    var paren_stack = [];\n    var deepest_depth = 0;\n    var curr_depth\
    \ = 0;\n    for(var i = 0; i < paren_string_array.length; i++){\n        for(var\
    \ j = 0; j < paren_string_array[i].length; j++){\n            if(paren_string_array[i][j]\
    \ == \"(\"){\n                paren_stack.push(\"(\");\n                curr_depth++;\n\
    \                if(curr_depth > deepest_depth){\n                    deepest_depth\
    \ = curr_depth;\n                }\n            }\n            else if(paren_string_array[i][j]\
    \ == \")\"){\n                paren_stack.pop();\n                curr_depth--;\n\
    \            }\n        }\n        curr_depth = 0;\n    }\n    return deepest_depth;\n\
    }\n", "  return \"\";\n}\n", "    let current_level = 0;\n    let max_level =\
    \ 0;\n    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === '('){\n            current_level++;\n            if(current_level > max_level){\n\
    \                max_level = current_level;\n            }\n        }\n      \
    \  else if(paren_string[i] === ')'){\n            current_level--;\n        }\n\
    \    }\n    return max_level;\n}\n", "\t//Map the number of parens\n\tvar paren_map\
    \ = paren_string.split(' ').map(function(el){\n\t\treturn get_paren_depth(el);\n\
    \t});\n\treturn paren_map;\n}\n", "  let result = [];\n  let current_string =\
    \ \"\";\n  let current_max = 0;\n  for(let i = 0; i < paren_string.length; i++){\n\
    \    if(paren_string[i] == \" \"){\n      if(current_string != \"\"){\n      \
    \  result.push(current_max);\n        current_max = 0;\n        current_string\
    \ = \"\";\n      }\n    }\n    else if(paren_string[i] == \"(\"){\n      current_string\
    \ += \"(\";\n      current_max++;\n    }\n    else if(paren_string[i] == \")\"\
    ){\n      current_string += \")\";\n      if(paren_string[i-1] == \"(\"){\n  \
    \      current_max--;\n      }\n    }\n  }\n  if(current_string != \"\"){\n  \
    \  result.push(current_max);\n  }\n  return result;\n}\n", "  var groups = paren_string.split(\"\
    \ \")\n  var levels = []\n  for (var i = 0; i < groups.length; i++){\n    var\
    \ group = groups[i]\n    var level = 0\n    var max = 0\n    for (var j = 0; j\
    \ < group.length; j++){\n      var c = group[j]\n      if (c == \"(\"){\n    \
    \    level++\n      }\n      else if (c == \")\"){\n        level--\n      }\n\
    \      if (level > max){\n        max = level\n      }\n    }\n    levels.push(max)\n\
    \  }\n  return levels\n}\n", "  console.log(paren_string);\n  var output = [];\n\
    \  var curr_parens = 0;\n  var max_parens = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      curr_parens++;\n      if(curr_parens\
    \ > max_parens){\n        max_parens = curr_parens;\n      }\n    }\n    else\
    \ if(paren_string[i] == ')'){\n      curr_parens--;\n    }\n    else if(paren_string[i]\
    \ == ' '){\n      output.push(max_parens);\n      max_parens = 0;\n      curr_parens\
    \ = 0;\n    }\n  }\n  output.push(max_parens);\n  return output;\n}\n", "\tvar\
    \ paren_array = paren_string.split(\" \");\n\tvar max_levels = 0;\n\tfor(var i\
    \ = 0; i < paren_array.length; i++){\n\t\tvar current_level = 1;\n\t\tfor(var\
    \ j = 0; j < paren_array[i].length; j++){\n\t\t\tif(paren_array[i][j] == \"(\"\
    ){\n\t\t\t\tcurrent_level++;\n\t\t\t}\n\t\t\telse if(paren_array[i][j] == \")\"\
    ){\n\t\t\t\tcurrent_level--;\n\t\t\t}\n\t\t}\n\t\tif(current_level > max_levels){\n\
    \t\t\tmax_levels = current_level;\n\t\t}\n\t}\n\treturn max_levels;\n}\n", "\t\
    var arr = paren_string.split(' ');\n\tvar nested_levels = [];\n\tfor(var i = 0;\
    \ i < arr.length; i++){\n\t\tvar paren_str = arr[i];\n\t\tvar num_left = 0;\n\t\
    \tvar curr_level = 0;\n\t\tvar max_level = 0;\n\t\tfor(var j = 0; j < paren_str.length;\
    \ j++){\n\t\t\tif(paren_str[j] == '('){\n\t\t\t\tnum_left++;\n\t\t\t\tcurr_level++;\n\
    \t\t\t\tif(curr_level > max_level){\n\t\t\t\t\tmax_level = curr_level;\n\t\t\t\
    \t}\n\t\t\t}\n\t\t\telse if(paren_str[j] == ')'){\n\t\t\t\tif(num_left > 0){\n\
    \t\t\t\t\tnum_left--;\n\t\t\t\t\tcurr_level--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\
    \t\t\t//Invalid pattern of parens\n\t\t\t\t\tnested_levels.push(-1);\n\t\t\t\t\
    \tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(curr_level == 0){\n\t\t\tnested_levels.push(max_level);\n\
    \t\t}\n\t}\n\treturn nested_levels;\n}\n", "    var paren_array = paren_string.split('\
    \ ');\n    var result = [];\n    for(var i = 0; i < paren_array.length; i++){\n\
    \        result.push(get_nested_parens(paren_array[i]));\n    }\n    return result;\n\
    }\n", "  let output = [];\n  let parens = paren_string.split(' ');\n  parens.forEach(paren\
    \ => {\n    let max = 0;\n    let current_max = 0;\n    for(let i = 0; i < paren.length;\
    \ i++){\n      if(paren[i] === '('){\n        current_max++;\n        if(current_max\
    \ > max){\n          max = current_max;\n        }\n      } else if(paren[i] ===\
    \ ')'){\n        current_max--;\n      }\n    }\n    output.push(max);\n  });\n\
    \  return output;\n}\n", "    paren_string = paren_string.replace(/ /g,'');\n\
    \    let stack = [0];\n    let max = 0;\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            stack.push(stack[stack.length\
    \ - 1] + 1);\n            max = Math.max(max, stack[stack.length - 1]);\n    \
    \    }\n        else{\n            stack.pop();\n        }\n    }\n    return\
    \ max;\n}\n", "  var arr = paren_string.split(' ');\n  var ans = [];\n  for(var\
    \ i = 0; i < arr.length; i++){\n    ans.push(maxDepth(arr[i]));\n  }\n  return\
    \ ans;\n}\n", "    var split_string = paren_string.split(' ');\n    var max_levels\
    \ = [];\n    for(var i = 0; i < split_string.length; i++){\n        var curr_str\
    \ = split_string[i];\n        max_levels.push(find_nesting_level(curr_str));\n\
    \    }\n    return max_levels;\n}\n", "  var paren_array = paren_string.split(\"\
    \ \");\n  var max_nesting = 0;\n  for(var i = 0; i < paren_array.length; i++){\n\
    \    var paren_string = paren_array[i];\n    var stack = [], left_pos = -1, level\
    \ = 0;\n    for(var j = 0; j < paren_string.length; j++){\n      if(paren_string[j]\
    \ == '('){\n        stack.push(paren_string[j]);\n        if(left_pos == -1)\n\
    \          left_pos = j;\n      }\n      else if(paren_string[j] == ')'){\n  \
    \      var stack_ele = stack.pop();\n        if(stack_ele != '('){\n         \
    \ return \"Error\";\n        }\n        else if(stack.length == 0){\n        \
    \  if(level < j - left_pos + 1)\n            level = j - left_pos + 1;\n     \
    \     left_pos = -1;\n        }\n      }\n    }\n    if(level > max_nesting)\n\
    \      max_nesting = level;\n  }\n  return max_nesting;\n}\n\nvar test_string\
    \ = \"(()()) (()())(()(())) ((()))\";", "    var output_array = [];\n    var split_array\
    \ = paren_string.split(\" \");\n    for(var i = 0; i < split_array.length; i++){\n\
    \        if(split_array[i] == \"\"){\n            continue;\n        }\n     \
    \   output_array.push(count_parens(split_array[i]));\n    }\n    return output_array;\n\
    }\n", "  var stack = [];\n  var depth_stack = [];\n  var result = [];\n  for(var\
    \ i = 0; i < paren_string.length; i++){\n    if(paren_string[i] === '('){\n  \
    \    stack.push(paren_string[i]);\n      if(depth_stack.length === 0){\n     \
    \   depth_stack.push(1);\n      }else{\n        depth_stack.push(depth_stack[depth_stack.length\
    \ - 1] + 1);\n      }\n    }else if(paren_string[i] === ')'){\n      if(stack.length\
    \ > 0){\n        stack.pop();\n        result.push(depth_stack.pop());\n     \
    \ }\n    }else if(paren_string[i] === ' '){\n      if(stack.length === 0){\n \
    \       result.push(0);\n      }\n    }\n  }\n  return result;\n}", "  let max_count\
    \ = 0;\n  let current_count = 0;\n  let count_stack = [];\n  let paren_array =\
    \ paren_string.split('');\n  for(i=0; i<paren_array.length; i++){\n    if(paren_array[i]\
    \ == '('){\n      current_count++;\n      if(current_count > max_count){\n   \
    \     max_count = current_count;\n      }\n    }else if(paren_array[i] == ')'){\n\
    \      current_count--;\n    }else if(paren_array[i] == ' '){\n      count_stack.push(max_count);\n\
    \      max_count = 0;\n      current_count = 0;\n    }\n  }\n  return count_stack;\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
