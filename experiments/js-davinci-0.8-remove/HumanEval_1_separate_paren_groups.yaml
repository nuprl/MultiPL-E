name: HumanEval_1_separate_paren_groups
language: js
prompt: "//Input to this function is a string containing multiple groups of nested\
  \ parentheses. Your goal is to\n// separate those group into separate strings and\
  \ return the list of those.\n// Separate groups are balanced (each open brace is\
  \ properly closed) and not nested within each other\n// Ignore any spaces in the\
  \ input string.\nfunction separate_paren_groups(paren_string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"\
  ),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"\
  () (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"\
  (()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) ((\
  \ )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();"
completions: ["  var strings = [];\n  var current_string = '';\n  var nesting_level\
    \ = 0;\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ == '('){\n      nesting_level++;\n      current_string += paren_string[i];\n\
    \    }\n    else if(paren_string[i] == ')'){\n      nesting_level--;\n      current_string\
    \ += paren_string[i];\n      if(nesting_level == 0){\n        strings.push(current_string);\n\
    \        current_string = '';\n      }\n    }\n    else if(paren_string[i] !=\
    \ ' '){\n      current_string += paren_string[i];\n    }\n  }\n  return strings;\n\
    }\n", "    var arrayOfParenGroups = [];\n    var right_paren_position;\n    var\
    \ left_paren_position;\n    var tempStr;\n    while(paren_string.indexOf(\")\"\
    ) > -1){\n        right_paren_position = paren_string.indexOf(\")\");\n      \
    \  tempStr = paren_string.substring(0, right_paren_position);\n        left_paren_position\
    \ = tempStr.lastIndexOf(\"(\");\n        tempStr = paren_string.substring(left_paren_position,\
    \ right_paren_position + 1);\n        paren_string = paren_string.replace(tempStr,\
    \ \"\");\n        arrayOfParenGroups.push(tempStr);\n    }\n    return arrayOfParenGroups;\n\
    }\n", "  const stack = [];\n  const result = [];\n  let current_group = \"\";\n\
    \  for(let i = 0; i < paren_string.length; i++){\n    let current_char = paren_string[i];\n\
    \    if(current_char === \"(\" || current_char === \")\"){\n      if(current_char\
    \ === \"(\"){\n        stack.push(current_char);\n      }\n      else if(current_char\
    \ === \")\"){\n        if(stack.length === 0){\n          throw new Error(\"Unbalanced\
    \ parenthesis\");\n        }\n        else{\n          stack.pop();\n        \
    \  if(stack.length === 0){\n            result.push(current_group);\n        \
    \    current_group = \"\";\n          }\n        }\n      }\n    }\n    else{\n\
    \      current_group += current_char;\n    }\n  }\n  if(stack.length > 0){\n \
    \   throw new Error(\"Unbalanced parenthesis\");\n  }\n  return result;\n}\n\n\
    module.exports = {\n  separate_paren_groups\n};", "    // Your code here\n   \
    \ return paren_string.split(\")(\");\n}\n\nmodule.exports = {\n    max_in_list:\
    \ max_in_list,\n    largest_palindrome: largest_palindrome,\n    anagrams: anagrams,\n\
    \    blackjack: blackjack,\n    separate_paren_groups: separate_paren_groups\n\
    };", "    var new_list = [];\n    var sub_list = [];\n    var temp = 0;\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] == \"(\"){\n\
    \            sub_list.push(paren_string[i]);\n            temp++;\n        }\n\
    \        else if(paren_string[i] == \")\"){\n            sub_list.push(paren_string[i]);\n\
    \            temp--;\n        }\n        else if(paren_string[i] != \" \"){\n\
    \            sub_list.push(paren_string[i]);\n        }\n        if(temp == 0){\n\
    \            var x = sub_list.join(\"\");\n            new_list.push(x);\n   \
    \         sub_list = [];\n        }\n    }\n    return new_list;\n}\n\n", "  \
    \  var res = [];\n    var open = 0;\n    var start = 0;\n    for(var i = 0; i\
    \ < paren_string.length; i++){\n        if(paren_string[i] == \"(\"){\n      \
    \      if(open == 0){\n                start = i;\n            }\n           \
    \ open++;\n        }else if(paren_string[i] == \")\"){\n            open--;\n\
    \            if(open == 0){\n                res.push(paren_string.substring(start,\
    \ i+1));\n            }\n        }\n    }\n    return res;\n}\n", "    // Your\
    \ code here\n}", "    let parens_trimmed = paren_string.replace(/\\s/g, '');\n\
    \    let count = 0;\n    let paren_begin = 0;\n    let paren_end = 0;\n    let\
    \ paren_groups = [];\n    for (let i = 0; i < parens_trimmed.length; i++){\n \
    \       if (parens_trimmed[i] === '('){\n            count += 1;\n           \
    \ if (count === 1){\n                paren_begin = i;\n            }\n       \
    \ }\n        if (parens_trimmed[i] === ')'){\n            count -= 1;\n      \
    \      if (count === 0){\n                paren_end = i;\n                paren_groups.push(parens_trimmed.slice(paren_begin,\
    \ paren_end + 1));\n            }\n        }\n    }\n    return paren_groups;\n\
    }\n", "    let groups = [];\n    let opened_count = 0;\n    let group = '';\n\
    \    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ == '('){\n            opened_count++;\n            group += paren_string[i];\n\
    \        }else if(paren_string[i] == ')'){\n            opened_count--;\n    \
    \        group += paren_string[i];\n            if(opened_count == 0){\n     \
    \           groups.push(group);\n                group = '';\n            }\n\
    \        }else if(paren_string[i] != ' '){\n            group += paren_string[i];\n\
    \        }\n    }\n    return groups;\n}", "    // separate those group into separate\
    \ strings and return the list of those.\n    let paren = paren_string.split('')\n\
    \    let temp = []\n    let output = []\n    let count = 0\n    for(let x = 0;\
    \ x < paren.length; x++){\n        if(paren[x] === \"(\"){\n            count++\n\
    \        }\n        if(paren[x] === \")\"){\n            count--\n        }\n\
    \        if(count === 0 && paren[x] === \")\"){\n            temp.push(paren[x])\n\
    \            output.push(temp.join(''))\n            temp = []\n        }\n  \
    \      else if(paren[x] === \")\" || paren[x] === \"(\"){\n            temp.push(paren[x])\n\
    \        }\n    }\n    return output\n}", "    // your code here\n    let result\
    \ = [];\n    let count = 0;\n    let temp = \"\";\n    for(i=0; i<paren_string.length;\
    \ i++){\n        if(paren_string[i]==\"(\"){\n            count+=1;\n        \
    \    temp+=paren_string[i];\n        }\n        else if(paren_string[i]==\")\"\
    ){\n            count-=1;\n            temp+=paren_string[i];\n        }\n   \
    \     else{\n            temp+=paren_string[i];\n        }\n        if(count==0){\n\
    \            result.push(temp);\n            temp = \"\";\n        }\n    }\n\
    \    return result;\n}", "    var paren_list = [];\n    var paren_str = \"\";\n\
    \    var paren_count = 0;\n    for(i=0; i<paren_string.length; i++){\n       \
    \ if(paren_string[i] == '('){\n            paren_count++;\n            paren_str\
    \ += paren_string[i];\n        }\n        else if(paren_string[i] == ')'){\n \
    \           paren_count--;\n            paren_str += paren_string[i];\n      \
    \  }\n        else if(paren_string[i] == ' '){\n            continue;\n      \
    \  }\n        else{\n            paren_str += paren_string[i];\n        }\n  \
    \      if(paren_count == 0){\n            paren_list.push(paren_str);\n      \
    \      paren_str = \"\";\n        }\n    }\n    return paren_list;\n}\n", "  var\
    \ parts = paren_string.split(\" \").join(\"\").split(\"(\");\n  var arr = [];\n\
    \  var result = [];\n  parts.forEach(function(v){\n    v.split(\")\").forEach(function(v2){\n\
    \      arr.push(v2);\n    });\n  });\n  arr.forEach(function(v){\n    if(v[0]\
    \ === \")\"){\n      result.push(v.slice(1));\n    }\n  });\n  return result;\n\
    }\n", "\tvar parenStrArr = paren_string.split(\"\");\n\tvar parenArr = [];\n\t\
    var parenStr = \"\";\n\tfor(var i = 0; i < parenStrArr.length; i++){\n\t\tif(parenStrArr[i]\
    \ == \"(\"){\n\t\t\tparenStr += parenStrArr[i];\n\t\t\tvar openParen = 1;\n\t\t\
    \tfor(var j = i+1; j < parenStrArr.length; j++){\n\t\t\t\tif(parenStrArr[j] ==\
    \ \"(\"){\n\t\t\t\t\topenParen++;\n\t\t\t\t}\n\t\t\t\tif(parenStrArr[j] == \"\
    )\"){\n\t\t\t\t\topenParen--;\n\t\t\t\t}\n\t\t\t\tif(openParen > 0){\n\t\t\t\t\
    \tparenStr += parenStrArr[j];\n\t\t\t\t}\n\t\t\t\tif(openParen == 0){\n\t\t\t\t\
    \tparenArr.push(parenStr);\n\t\t\t\t\tparenStr = \"\";\n\t\t\t\t\ti = j;\n\t\t\
    \t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn parenArr;\n}\n", "    let\
    \ groups = [];\n    let i = 0;\n    while(i < paren_string.length){\n        let\
    \ char = paren_string[i];\n        if(char === '('){\n            let group =\
    \ '(';\n            let parens = 1;\n            while(parens > 0){\n        \
    \        i++;\n                char = paren_string[i];\n                if(char\
    \ === '('){\n                    parens++;\n                } else if(char ===\
    \ ')'){\n                    parens--;\n                }\n                group\
    \ += char;\n            }\n            groups.push(group);\n        }\n      \
    \  i++;\n    }\n    return groups;\n}", "    return paren_string.replace(/\\s/g,\
    \ '').match(/\\(+\\)/g)\n}", "    var open = 0;\n    var closed = 0;\n    var\
    \ beg = 0;\n    var str = \"\";\n    var groups = [];\n    for(var i = 0; i <\
    \ paren_string.length; i++){\n        if(paren_string[i] == '(')\n           \
    \ open++;\n        else if(paren_string[i] == ')')\n            closed++;\n  \
    \      if(open == closed && open != 0){\n            groups.push(paren_string.substring(beg,\
    \ i+1));\n            open = 0;\n            closed = 0;\n            beg = i+1;\n\
    \        }\n    }\n    return groups;\n}\n", "  var parens_arr = paren_string.split('');\n\
    \  var results = [];\n  var count = 0;\n  var temp_string = \"\";\n  for(var i\
    \ = 0; i < parens_arr.length; i++){\n    if(parens_arr[i] === '('){\n      count\
    \ += 1;\n    }\n    if(parens_arr[i] === ')'){\n      count -= 1;\n    }\n   \
    \ if(count === 0 && temp_string.length > 0){\n      results.push(temp_string);\n\
    \      temp_string = \"\";\n    } else {\n      temp_string += parens_arr[i];\n\
    \    }\n  }\n  return results;\n}\n", "\tvar start = 0;\n\tvar end = 0;\n\tvar\
    \ newArr = [];\n\tfor(var i = 0; i < paren_string.length; i++){\n\t\tif(paren_string[i]\
    \ === '('){\n\t\t\tstart = i;\n\t\t}\n\t\tif(paren_string[i] === ')'){\n\t\t\t\
    end = i;\n\t\t\tnewArr.push(paren_string.slice(start, end + 1));\n\t\t}\n\t}\n\
    \treturn newArr;\n}\n", "  var space_removed = paren_string.replace(/\\s/g, \"\
    \");\n  var open_paren = space_removed.search(/\\(/);\n  var closing_paren = space_removed.indexOf(\"\
    )\", open_paren);\n  var sub_string = space_removed.substring(open_paren, closing_paren\
    \ + 1);\n  var new_string = space_removed.replace(sub_string, \"\");\n  var result\
    \ = [];\n  if (new_string === \"\"){\n    result.push(sub_string);\n    return\
    \ result;\n  }\n  else{\n    result.push(sub_string);\n    return result.concat(separate_paren_groups(new_string));\n\
    \  }\n}\n", "    let final_output = [];\n    let current_paren_stack = [];\n \
    \   let current_paren_string = '';\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        let char = paren_string[i];\n        if(char === '('){\n    \
    \        current_paren_stack.push(char);\n            current_paren_string +=\
    \ char;\n        }\n        else if(char === ')'){\n            current_paren_stack.pop();\n\
    \            current_paren_string += char;\n            if(current_paren_stack.length\
    \ === 0){\n                final_output.push(current_paren_string);\n        \
    \        current_paren_string = '';\n            }\n        }\n        else{\n\
    \            current_paren_string += char;\n        }\n    }\n    return final_output;\n\
    }\n", "    console.log(\"Separating the paren string: \" + paren_string);\n  \
    \  // Your code here.\n    let result = [];\n    let openBraces = 0;\n    let\
    \ temp = '';\n    for (const char of paren_string) {\n        if (char === '(')\
    \ {\n            if (openBraces === 0) {\n                temp = '';\n       \
    \     }\n            openBraces++;\n        } else if (char === ')') {\n     \
    \       openBraces--;\n            if (openBraces === 0) {\n                result.push(temp);\n\
    \            }\n        } else if (openBraces > 0) {\n            temp += char;\n\
    \        }\n    }\n    return result;\n}\n", "    let strArray = [];\n    let\
    \ arr2 = paren_string.split(\" \");\n    let arr = [];\n    for(let i = 0; i <\
    \ arr2.length; i++){\n        if(arr2[i] !== \"\"){\n            arr.push(arr2[i]);\n\
    \        }\n    }\n    for(let i = 0; i < arr.length; i++){\n        if(arr[i].charAt(0)\
    \ === \"(\"){\n            strArray.push(arr[i]);\n        }\n    }\n    for(let\
    \ i = 0; i < strArray.length; i++){\n        strArray[i] = strArray[i].split(\"\
    \");\n    }\n    let count = 0;\n    let j = 0;\n    let val = \"\";\n    let\
    \ strArray2 = [];\n    while(count < strArray.length){\n        while(strArray[count].length\
    \ !== 0){\n            val = strArray[count].shift();\n            if(val ===\
    \ \"(\"){\n                j++;\n            }\n            if(val === \")\"){\n\
    \                j--;\n            }\n            if(j === 0){\n             \
    \   strArray2.push(val);\n                count++;\n                break;\n \
    \           }\n            strArray2.push(val);\n        }\n    }\n    for(let\
    \ i = 0; i < strArray2.length; i++){\n        strArray2[i] = strArray2[i].join(\"\
    \");\n    }\n    return strArray2;\n}\n", "  return [ \"((()))\", \"((()))\" ];\n\
    }\n\nmodule.exports = {\n  separate_paren_groups: separate_paren_groups\n};",
  "    paren_string = paren_string.replace(/\\s/g, '');\n    let temp = '';\n    let\
    \ result = [];\n    for(let i = 0; i < paren_string.length; i++){\n        temp\
    \ += paren_string[i];\n        if(temp.indexOf('(') > temp.indexOf(')')){\n  \
    \          result.push(temp);\n            temp = '';\n        }\n    }\n    return\
    \ result;\n}\n", "    //The reason for the following line is there is an easier\
    \ way to get the string into an array\n    paren_string = paren_string.split(\"\
    \");\n    const output_string = [];\n    const temp_string = [];\n    for(let\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] === \"(\"\
    ){\n            if(temp_string.length !== 0){\n                output_string.push(temp_string.join(\"\
    \"));\n                temp_string.length = 0;\n            }\n            let\
    \ j = i;\n            let counter = 1;\n            while(counter > 0){\n    \
    \            j++;\n                if(paren_string[j] === \"(\") counter++;\n\
    \                if(paren_string[j] === \")\") counter--;\n                temp_string.push(paren_string[j]);\n\
    \            }\n            i = j;\n            output_string.push(temp_string.join(\"\
    \"));\n            temp_string.length = 0;\n        }\n    }\n    return output_string;\n\
    }", "\tvar result = [];\n\tvar temp = '';\n\tvar i = 0;\n\tvar count = 0;\n\t\
    while(i < paren_string.length){\n\t\tif(paren_string[i] === '('){\n\t\t\tcount++;\n\
    \t\t\ttemp += paren_string[i];\n\t\t}\n\t\telse if(paren_string[i] === ')'){\n\
    \t\t\tcount--;\n\t\t\ttemp += paren_string[i];\n\t\t}\n\t\telse if(paren_string[i]\
    \ !== ' '){\n\t\t\ttemp += paren_string[i];\n\t\t}\n\t\tif(count === 0){\n\t\t\
    \tresult.push(temp);\n\t\t\ttemp = '';\n\t\t}\n\t\ti++;\n\t}\n\treturn result;\n\
    }\n", "    var paren_array = paren_string.split(\"\");\n    var result = [];\n\
    \    var temp = [];\n    var paren_count = 0;\n    for(var i = 0; i < paren_array.length;\
    \ i++){\n        if(paren_array[i] === \"(\"){\n            paren_count++;\n \
    \       }else if(paren_array[i] === \")\"){\n            paren_count--;\n    \
    \    }\n        if(paren_count === 0 && temp.length > 0){\n            result.push(temp.join(\"\
    \"));\n            temp = [];\n        }else{\n            temp.push(paren_array[i]);\n\
    \        }\n    }\n    return result;\n}\n", "  \n  // result will be an array\
    \ of balanced paren strings\n  let result = [];\n  // paren_stack will hold the\
    \ current paren group we are working on\n  let paren_stack = [];\n  // position\
    \ is the current position within the string\n  let position = 0;\n  // this variable\
    \ tells us if we are currently in a paren group\n  let in_paren = false;\n  \n\
    \  // As long as we are not at the end of the string, we'll keep looking for balanced\
    \ parens\n  while(position < paren_string.length){\n    // get the next character\n\
    \    let next_char = paren_string[position];\n    // if it's an open paren, we're\
    \ starting a new paren group\n    if(next_char === \"(\"){\n      in_paren = true;\n\
    \      // push that paren to the stack\n      paren_stack.push(next_char);\n \
    \   }\n    // if it's a close paren, we're closing a paren group.\n    else if(next_char\
    \ === \")\"){\n      // if the last character we saw was an open paren, this is\
    \ just a single paren group\n      if(paren_stack[paren_stack.length - 1] ===\
    \ \"(\"){\n        // so we can push this group to the result and clear the stack\n\
    \        result.push(paren_stack.join(\"\"));\n        paren_stack = [];\n   \
    \     in_paren = false;\n      }\n      // otherwise, we were already in a paren\
    \ group, so we need to remove the last open paren from the stack\n      else{\n\
    \        paren_stack.pop();\n      }\n    }\n    // if it's not an open or close\
    \ paren, it must be part of the paren group we're in\n    else if(in_paren){\n\
    \      // so we just push it to the stack\n      paren_stack.push(next_char);\n\
    \    }\n    // move to the next character\n    position++;\n  }\n  \n  // If there\
    \ were any characters left in the stack, we didn't find a closing paren, so this\
    \ string wasn't balanced\n  if(paren_stack.length){\n    throw new Error(\"Unbalanced\
    \ p", "    return paren_string.split(/\\)\\s*\\(/);\n}\n", "  var output_array\
    \ = []\n  var paren_array = paren_string.split(\"\")\n  var current_paren_string\
    \ = \"\"\n  var opened_parens = 0\n  for (var i = 0; i < paren_array.length; i++){\n\
    \    if (paren_array[i] == \"(\"){\n      opened_parens++\n      current_paren_string\
    \ += paren_array[i]\n    }\n    else if (paren_array[i] == \")\"){\n      opened_parens--\n\
    \      current_paren_string += paren_array[i]\n      if (opened_parens == 0){\n\
    \        output_array.push(current_paren_string)\n        current_paren_string\
    \ = \"\"\n      }\n    }\n    else if (paren_array[i] != \" \"){\n      current_paren_string\
    \ += paren_array[i]\n    }\n  }\n  return output_array\n}\n", "    var open =\
    \ paren_string.indexOf('(');\n    var close = paren_string.indexOf(')');\n   \
    \ var newList = [];\n    var newList =[];\n    while(open>=0){\n        var newString\
    \ = paren_string.slice(open,close+1);\n        newList.push(newString);\n    \
    \    paren_string = paren_string.slice(close+1);\n        open = paren_string.indexOf('(');\n\
    \        close = paren_string.indexOf(')');\n    }\n    return newList;\n}\n",
  "  var stack = [];\n  var output = [];\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      stack.push(i);\n    }\n    else\
    \ if(paren_string[i] == ')'){\n      var left_index = stack.pop();\n      output.push(paren_string.slice(left_index,\
    \ i+1));\n    }\n  }\n  return output;\n}", "    //. . .\n    var my_regexp =\
    \ /\\([^\\)]*\\)/g;\n    var matches_array = paren_string.match(my_regexp);\n\
    \    return matches_array;\n}\n\n", "    return [];\n}\n", "  var result = [];\n\
    \  var count = 0;\n  var substring = \"\";\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == \"(\"){\n      count++;\n    }else if(paren_string[i]\
    \ == \")\"){\n      count--;\n    }\n    substring += paren_string[i];\n    if(count\
    \ == 0){\n      result.push(substring);\n      substring = \"\";\n    }\n  }\n\
    \  return result;\n}\n", "    return [\"()\", \"()()\"];\n}\n", "    //split string\
    \ into characters\n    let parens = paren_string.split('');\n    let nested_parens\
    \ = [];\n    let start = 0;\n    let end = 0;\n    let count = 0;\n    let first\
    \ = parens[0];\n    //loop through array of characters until end of array\n  \
    \  for(i = 0; i < parens.length; i++){\n        //check if start character\n \
    \       if(parens[i] === first){\n            //if so, keep track of starting\
    \ index\n            start = i;\n            count++;\n        }\n        //check\
    \ if end character\n        else if(parens[i] !== first){\n            //if so,\
    \ keep track of ending index\n            end = i;\n            count--;\n   \
    \     }\n        //check if count is zero\n        if(count === 0){\n        \
    \    //if so, push characters into nested array\n            nested_parens.push(parens.slice(start,\
    \ end + 1).join(''));\n        }\n    }\n    return nested_parens;\n}\n\n", " \
    \   var answer = [];\n    var temp_string = \"\";\n    var temp_num = 0;\n   \
    \ var paren_array = paren_string.split(\"\");\n    for(var i = 0; i < paren_array.length;\
    \ i++){\n        if(paren_array[i] == \"(\"){\n            temp_num++;\n     \
    \   }\n        if(paren_array[i] == \")\"){\n            temp_num--;\n       \
    \ }\n        temp_string += paren_array[i];\n        if(temp_num == 0){\n    \
    \        answer.push(temp_string);\n            temp_string = \"\";\n        }\n\
    \    }\n    return answer;\n}\n", "    var open_parens = 0;\n    var paren_group\
    \ = \"\";\n    var paren_groups = [];\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == '('){\n            if(open_parens == 0){\n\
    \                paren_group = \"\";\n            }\n            open_parens++;\n\
    \        }else if(paren_string[i] == ')'){\n            open_parens--;\n     \
    \       if(open_parens == 0){\n                paren_groups.push(paren_group);\n\
    \            }\n        }else if(open_parens > 0){\n            paren_group +=\
    \ paren_string[i];\n        }\n    }\n    return paren_groups;\n}\n", "  var groups\
    \ = [];\n  var current = '';\n  var paren_stack = [];\n  paren_string.split('').forEach(function(ch){\n\
    \    if(ch==='('){\n      if(paren_stack.length === 0) {\n        groups.push(current);\n\
    \        current = ch;\n      } else {\n        current += ch;\n      }\n    \
    \  paren_stack.push(ch);\n    } else if(ch===')'){\n      if(paren_stack.length\
    \ === 1) {\n        current += ch;\n        groups.push(current);\n        current\
    \ = '';\n      } else {\n        current += ch;\n      }\n      paren_stack.pop();\n\
    \    } else if(ch===' '){\n      return;\n    } else {\n      current += ch;\n\
    \    }\n  });\n  return groups;\n}\n", "    var result = [];\n    var begin =\
    \ 0;\n    var level = 0;\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] == '('){\n            if(level == 0){\n          \
    \      begin = i;\n            }\n            level++;\n        }\n        else\
    \ if(paren_string[i] == ')'){\n            level--;\n            if(level == 0){\n\
    \                result.push(paren_string.substring(begin, i+1));\n          \
    \  }\n        }\n    }\n    return result;\n}\n", "    const res = [];\n    let\
    \ temp = '';\n    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === '('){\n            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ === ')'){\n            temp += paren_string[i];\n            res.push(temp);\n\
    \            temp = '';\n        }\n    }\n    return res;\n}\n", "    // Complete\
    \ this function\n    return_list = [];\n    paren_stack = [];\n    paren_str =\
    \ '';\n    for(var i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ == '('){\n            paren_stack.push(paren_string[i]);\n            paren_str\
    \ += paren_string[i];\n        }else if(paren_string[i] == ')'){\n           \
    \ paren_stack.pop();\n            paren_str += paren_string[i];\n            if(paren_stack.length\
    \ == 0){\n                return_list.push(paren_str);\n                paren_str\
    \ = '';\n            }\n        }\n    }\n    return return_list;\n}\n", "   \
    \ const paren_array = paren_string.split('');\n    let groups = [];\n    let curr_group\
    \ = [];\n    let curr_nest_count = 0;\n    let curr_start_ind;\n    for(let i\
    \ = 0; i < paren_array.length; i++){\n        if(paren_array[i] === '(') {\n \
    \           if(curr_nest_count === 0) {\n                curr_start_ind = i;\n\
    \            }\n            curr_nest_count += 1;\n        } else if(paren_array[i]\
    \ === ')') {\n            curr_nest_count -= 1;\n            if(curr_nest_count\
    \ === 0) {\n                groups.push(paren_string.slice(curr_start_ind, i +\
    \ 1));\n            }\n        }\n    }\n    return groups;\n}\n", "    var groups\
    \ = [];\n    var group = '';\n    var open_index = -1;\n    for(var i = 0; i <\
    \ paren_string.length; i++){\n        var c = paren_string[i];\n        if(c ===\
    \ '('){\n            if(open_index < 0){\n                open_index = i;\n  \
    \          }\n            group += c;\n        }\n        else if(c === ')'){\n\
    \            group += c;\n            if(open_index >= 0){\n                groups.push(group);\n\
    \                group = '';\n                open_index = -1;\n            }\n\
    \        }\n        else if(c === ' '){\n            continue;\n        }\n  \
    \      else{\n            group += c;\n        }\n    }\n    return groups;\n\
    }\n\n", "    let new_string = paren_string.replace(/\\s/g, '');\n    let open_braces\
    \ = [];\n    let open_indexes = [];\n    let paren_groups = [];\n    for (let\
    \ i = 0; i < new_string.length; i++){\n        if (new_string[i] === '('){\n \
    \           open_braces.push(new_string[i]);\n            open_indexes.push(i);\n\
    \        }\n        else if (new_string[i] === ')'){\n            if (open_braces.length\
    \ === 0){\n                return 'Invalid parentheses string';\n            }\n\
    \            else{\n                open_braces.pop();\n                paren_groups.push(new_string.slice(open_indexes.pop(),\
    \ i + 1));\n            }\n        }\n    }\n    if (open_braces.length !== 0){\n\
    \        return 'Invalid parentheses string';\n    }\n    return paren_groups;\n\
    }\n", "    const re = /[\\(\\)]/g;\n    const reduced_string = paren_string.replace(/\
    \ /g, '');\n    const paren_list = reduced_string.match(re);\n    let result =\
    \ [];\n    let temp = '';\n    let depth = 0;\n    for (let i = 0; i < paren_list.length;\
    \ i++){\n        if (paren_list[i] === '('){\n            depth++;\n         \
    \   temp += paren_list[i];\n        } else {\n            depth--;\n         \
    \   temp += paren_list[i];\n            if (depth === 0){\n                result.push(temp);\n\
    \                temp = '';\n            }\n        }\n    }\n    return result;\n\
    }\n", "  var str_length = paren_string.length;\n  var separated_groups = [];\n\
    \  var start_paren = 0;\n  var end_paren = 0;\n  var count = 0;\n  var item =\
    \ \"\";\n  var group = \"\";\n  while(count < str_length){\n    if(paren_string[count]\
    \ != \" \"){\n      item = paren_string[count];\n      if(item == \"(\"){\n  \
    \      start_paren = count;\n      }\n      else if(item == \")\"){\n        end_paren\
    \ = count;\n        group = paren_string.slice(start_paren, end_paren + 1);\n\
    \        separated_groups.push(group);\n      }\n    }\n    count++;\n  }\n  return\
    \ separated_groups;\n}\n", "\tvar parens = paren_string.replace(/\\s/g,'');\n\t\
    var indices = [];\n\tvar groups = [];\n\tvar final = [];\n\tfor(var i = 0; i <\
    \ parens.length; i++){\n\t\tif(parens[i] === '('){\n\t\t\tindices.push(i);\n\t\
    \t}else if(parens[i] === ')'){\n\t\t\tvar x = indices.pop();\n\t\t\tgroups.push(parens.slice(x,\
    \ i+1));\n\t\t}\n\t}\n\tvar temp = [];\n\tfor(var i = 0; i < groups.length; i++){\n\
    \t\tif(groups[i][0] === '('){\n\t\t\tif(temp.length === 0){\n\t\t\t\ttemp.push(groups[i]);\n\
    \t\t\t}else{\n\t\t\t\tvar str = '';\n\t\t\t\tfor(var j = 0; j < temp.length; j++){\n\
    \t\t\t\t\tstr += temp[j];\n\t\t\t\t}\n\t\t\t\tfinal.push(str);\n\t\t\t\ttemp =\
    \ [];\n\t\t\t\ttemp.push(groups[i]);\n\t\t\t}\n\t\t}else{\n\t\t\ttemp.push(groups[i]);\n\
    \t\t}\n\t}\n\tvar str = '';\n\tfor(var j = 0; j < temp.length; j++){\n\t\tstr\
    \ += temp[j];\n\t}\n\tfinal.push(str);\n\treturn final;\n}\n", "    var paren_groups\
    \ = [];\n    var stack = [];\n    var start_index = 0;\n    var curr_char;\n \
    \   var curr_group;\n    for(var i = 0; i < paren_string.length; i++){\n     \
    \   curr_char = paren_string[i];\n        if(curr_char === '('){\n           \
    \ if(stack.length === 0){\n                start_index = i;\n            }\n \
    \           stack.push(curr_char);\n        }\n        else if(curr_char === ')'){\n\
    \            stack.pop();\n            if(stack.length === 0){\n             \
    \   curr_group = paren_string.slice(start_index, i + 1);\n                paren_groups.push(curr_group);\n\
    \            }\n        }\n    }\n    return paren_groups;\n}\n", "  let result\
    \ = [];\n  let stack = [];\n  let paren_counter = 0;\n  for(let i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] === \"(\"){\n      stack.push(paren_string[i]);\n\
    \      paren_counter += 1;\n    }\n    else if(paren_string[i] === \")\"){\n \
    \     stack.pop();\n      paren_counter -= 1;\n    }\n    if(paren_counter ===\
    \ 0){\n      result.push(paren_string.slice(0, i + 1));\n      return result.concat(separate_paren_groups(paren_string.slice(i\
    \ + 1)));\n    }\n  }\n  return result;\n}\n", "    let all_groups = [];\n   \
    \ let group = \"\";\n    let count = 0;\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == \"(\"){\n            count++;\n       \
    \     group += paren_string[i];\n        }\n        else if(paren_string[i] ==\
    \ \")\"){\n            count--;\n            group += paren_string[i];\n     \
    \   }\n        else{\n            group += paren_string[i];\n        }\n     \
    \   if(count == 0){\n            all_groups.push(group);\n            group =\
    \ \"\";\n        }\n    }\n    return all_groups;\n}\n", "  //create count variable\
    \ to track if we're inside a group\n  let groupCount = 0;\n  //create variables\
    \ to keep track of first character of group and its index\n  let groupStartChar;\n\
    \  let groupStartIndex;\n  //create output array to store the separated groups\n\
    \  let result = [];\n  //loop through each character in the string\n  for (let\
    \ i = 0; i < paren_string.length; i++) {\n    //if its a (, we're entering a group\n\
    \    if (paren_string[i] === '(') {\n      //if we're not inside a group, record\
    \ the first character and its index\n      if (groupCount === 0) {\n        groupStartChar\
    \ = paren_string[i];\n        groupStartIndex = i;\n      }\n      //increment\
    \ the groupCount\n      groupCount++;\n    }\n    //if its a ), we're exiting\
    \ a group\n    if (paren_string[i] === ')') {\n      //decrement the groupCount\n\
    \      groupCount--;\n      //if we're not inside a group, record the first character\
    \ and its index\n      if (groupCount === 0) {\n        //slice the string from\
    \ the start index to i+1 and push it to the result array\n        result.push(paren_string.slice(groupStartIndex,\
    \ i+1));\n      }\n    }\n  }\n  return result;\n}\n", "  const array = paren_string.split('');\n\
    \  const stack = [];\n  const str = '';\n  const result = [];\n  array.forEach(function(element)\
    \ {\n    if (element === '(') {\n      stack.push(element);\n    } else if (element\
    \ === ')') {\n      stack.pop();\n    }\n    str += element;\n    if (stack.length\
    \ === 0) {\n      result.push(str);\n      str = '';\n    }\n  });\n  return result;\n\
    }\n", "    var result = [];\n    var start = 0;\n    var end = 0;\n    var count\
    \ = 0;\n    for(var i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === '('){\n            count++;\n            if(count === 1){\n            \
    \    start = i;\n            }\n        }\n        if(paren_string[i] === ')'){\n\
    \            count--;\n            if(count === 0){\n                end = i;\n\
    \                result.push(paren_string.slice(start, end + 1));\n          \
    \  }\n        }\n    }\n    return result;\n}\n", "    var opened = [];\n    var\
    \ ret = [];\n    var curr_paren = 0;\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        var char = paren_string[i];\n        if(char == '('){\n     \
    \       opened.push(true);\n            curr_paren++;\n        }\n        else\
    \ if(char == ')'){\n            opened.pop();\n            curr_paren--;\n   \
    \     }\n        else if(char == ' '){\n            continue;\n        }\n   \
    \     else{\n            ret[ret.length - 1] += char;\n        }\n        if(curr_paren\
    \ == 0 && opened.length == 0){\n            ret.push('');\n        }\n    }\n\
    \    return ret;\n}\n", "    let groups = [];\n    let group = \"\";\n    let\
    \ depth = 0;\n    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === '('){\n            depth++;\n            group += paren_string[i];\n   \
    \     }\n        else if(paren_string[i] === ')'){\n            depth--;\n   \
    \         group += paren_string[i];\n            if(depth === 0){\n          \
    \      groups.push(group);\n                group = \"\";\n            }\n   \
    \     }\n        else if(paren_string[i] !== ' '){\n            group += paren_string[i];\n\
    \        }\n    }\n    return groups;\n}\n", "    let openCount = 0;\n    let\
    \ closedCount = 0;\n    let output = [];\n    let startIndex = 0;\n    for(let\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] === '('){\n\
    \            openCount++;\n        }\n        if(paren_string[i] === ')'){\n \
    \           closedCount++;\n        }\n        if(openCount === closedCount){\n\
    \            let str = paren_string.slice(startIndex, i+1);\n            if(str\
    \ !== ''){\n                output.push(str);\n            }\n            startIndex\
    \ = i+1;\n        }\n    }\n    return output;\n}\n", "    var result = [];\n\
    \    var leftCount = 0;\n    var rightCount = 0;\n    var leftBracket = paren_string.indexOf('(');\n\
    \    var rightBracket = paren_string.indexOf(')');\n    if(leftBracket === -1\
    \ || rightBracket === -1){\n        return result;\n    }\n    while(leftBracket\
    \ !== -1 && rightBracket !== -1){\n        leftCount++;\n        rightCount++;\n\
    \        if(leftCount == rightCount){\n            var string = paren_string.substring(0,rightBracket+1);\n\
    \            result.push(string);\n            paren_string = paren_string.substring(rightBracket+1);\n\
    \            leftCount = 0;\n            rightCount = 0;\n            leftBracket\
    \ = paren_string.indexOf('(');\n            rightBracket = paren_string.indexOf(')');\n\
    \        }\n        else if(rightCount > leftCount){\n            leftCount =\
    \ 0;\n            rightCount = 0;\n            paren_string = paren_string.substring(rightBracket+1);\n\
    \            leftBracket = paren_string.indexOf('(');\n            rightBracket\
    \ = paren_string.indexOf(')');\n        }\n        else{\n            leftBracket\
    \ = paren_string.indexOf('(',leftBracket+1);\n            rightBracket = paren_string.indexOf(')',rightBracket+1);\n\
    \        }\n    }\n    return result;\n}\n", "    var string_list = [];\n    var\
    \ current_string = \"\";\n    var chars = paren_string.split(\"\");\n    var open_paren_count\
    \ = 0;\n    for(var i = 0; i < chars.length; i++){\n        if(chars[i] == \"\
    (\"){\n            if(open_paren_count == 0){\n                if(current_string.length\
    \ > 0){\n                    string_list.push(current_string);\n             \
    \       current_string = \"\";\n                }\n            }\n           \
    \ open_paren_count += 1;\n        }\n        else if(chars[i] == \")\"){\n   \
    \         open_paren_count -= 1;\n            if(open_paren_count == 0){\n   \
    \             if(current_string.length > 0){\n                    string_list.push(current_string);\n\
    \                    current_string = \"\";\n                }\n            }\n\
    \        }\n        else if(chars[i] != \" \"){\n            current_string +=\
    \ chars[i];\n        }\n    }\n    if(current_string.length > 0){\n        string_list.push(current_string);\n\
    \    }\n    return string_list;\n}\n", "  return paren_string.replace(/\\s/g,\
    \ '').split(/([{()}])/).filter(function(value) {\n    return value !== '';\n \
    \ });\n}\n\n", "    var stack = [];\n    var result = [];\n    var current_str\
    \ = \"\";\n    for(var i = 0; i < paren_string.length; i++){\n        var char\
    \ = paren_string[i];\n        if(char == \"(\"){\n            if(stack.length\
    \ != 0){\n                stack.push(current_str);\n                current_str\
    \ = \"\";\n            }\n            stack.push(char);\n        }\n        else\
    \ if(char == \")\"){\n            var top = stack.pop();\n            if(top ==\
    \ \"(\"){\n                if(stack.length != 0){\n                    result.push(current_str);\n\
    \                    current_str = stack.pop();\n                }\n         \
    \       else{\n                    result.push(current_str);\n               \
    \     current_str = \"\";\n                }\n            }\n            else{\n\
    \                current_str = top + current_str + char;\n            }\n    \
    \    }\n        else{\n            current_str += char;\n        }\n    }\n  \
    \  if(current_str.length != 0){\n        result.push(current_str);\n    }\n  \
    \  return result;\n}\n", "\t//split up the string\n\t//go through each character\
    \ in the string\n\t//if it's an opening bracket, push it to a stack\n\t//if it's\
    \ a closing bracket, pop from stack and check if it matches\n\t//if it does, continue\
    \ on\n\t//if it doesn't, throw an error\n\t//when the stack is empty, push the\
    \ sequence of characters to a list\n\t//return the list\n\tvar parens = paren_string.split(\"\
    \");\n\tvar temp = [];\n\tvar result = [];\n\tvar stack = [];\n\twhile(parens.length\
    \ > 0){\n\t\tvar elem = parens.shift();\n\t\tif(elem == \"(\"){\n\t\t\tstack.push(elem);\n\
    \t\t}\n\t\telse if(elem == \")\"){\n\t\t\tif(stack.length == 0){\n\t\t\t\tthrow\
    \ \"Extra close parenthesis found. Please check your input\";\n\t\t\t}\n\t\t\t\
    else{\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t\ttemp.push(elem);\n\t\tif(stack.length\
    \ == 0){\n\t\t\tresult.push(temp.join(\"\"));\n\t\t\ttemp = [];\n\t\t}\n\t}\n\t\
    if(stack.length > 0){\n\t\tthrow \"Extra open parenthesis found. Please check\
    \ your input\";\n\t}\n\treturn result;\n}", "    //separate_paren_groups function\
    \ definition goes here.\n    let paren = paren_string.split(\"\");\n    let count\
    \ = 0;\n    let index = 0;\n    let result = [];\n    for(let i = 0; i < paren.length;\
    \ i++){\n        if(paren[i] == \"(\"){\n            count++;\n        }else if(paren[i]\
    \ == \")\"){\n            count--;\n        }\n        if(count == 0){\n     \
    \       result.push(paren_string.substring(index, i+1));\n            index =\
    \ i+1;\n        }\n    }\n    return result;\n}\n", "  // remove spaces\n  var\
    \ no_spaces = paren_string.replace(/\\s/g,'');\n  var i = 0;\n  var result = [];\n\
    \  var current = \"\";\n  // iterate through each character in the string\n  while\
    \ (i < no_spaces.length){\n    // if there is an open parenthesis, add it to the\
    \ string\n    if (no_spaces[i] === '('){\n      current += no_spaces[i];\n   \
    \ }\n    // if there is a closed parenthesis, check that the parenthesis is not\
    \ a lone closed parenthesis\n    // or part of a nested parenthesis. If the conditions\
    \ are satisfied, add the current string to the result\n    // and reset the current\
    \ string for the next group of parentheses\n    else if (no_spaces[i] === ')'){\n\
    \      current += no_spaces[i];\n      if (paren_group_is_balanced(current) &&\
    \ !parentheses_nested(current)){\n        result.push(current);\n        current\
    \ = \"\";\n      }\n    }\n    i++;\n  }\n  return result;\n}\n", "    paren_string\
    \ = paren_string.replace(/\\s/g, '');\n    console.log(paren_string);\n    let\
    \ result = [];\n    let stack = [];\n    let start = 0;\n    let curr = 0;\n \
    \   while(curr < paren_string.length){\n        if(paren_string[curr] === '('){\n\
    \            stack.push(paren_string[curr]);\n        }\n        else if(paren_string[curr]\
    \ === ')'){\n            stack.pop();\n        }\n        if(stack.length ===\
    \ 0){\n            result.push(paren_string.slice(start, curr+1));\n         \
    \   start = curr+1;\n        }\n        curr++;\n    }\n    return result;\n}\n",
  "  // Your code here\n  let parenArr = paren_string.split(\"\");\n  let newArr =\
    \ [];\n  let counter = 0;\n  let tempStr = \"\";\n  while(counter < parenArr.length){\n\
    \    if(parenArr[counter] == \"(\"){\n      tempStr += parenArr[counter];\n  \
    \    let openBracketCounter = 0;\n      let closeBracketCounter = 0;\n      for(let\
    \ i = counter + 1; i < parenArr.length; i++){\n        if(parenArr[i] == \"(\"\
    ){\n          openBracketCounter++;\n        }\n        if(parenArr[i] == \")\"\
    ){\n          closeBracketCounter++;\n        }\n        if(openBracketCounter\
    \ == closeBracketCounter){\n          tempStr += parenArr[i];\n          counter\
    \ = i;\n          break;\n        }\n        tempStr += parenArr[i];\n      }\n\
    \      newArr.push(tempStr);\n      tempStr = \"\";\n    }\n    counter++;\n \
    \ }\n  return newArr;\n}\n", "    var list_of_groups = [];\n    var open_paren_index\
    \ = 0;\n    var closed_paren_index = 0;\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == \"(\"){\n            open_paren_index =\
    \ i;\n        }\n        if(paren_string[i] == \")\"){\n            closed_paren_index\
    \ = i;\n            list_of_groups.push(paren_string.slice(open_paren_index, closed_paren_index\
    \ + 1));\n        }\n    }\n    return list_of_groups;\n}", "  let open_paren\
    \ = 0;\n  let close_paren = 0;\n  let new_string = \"\";\n  let string_array =\
    \ [];\n  for(let i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ === \"(\"){\n      if(open_paren === 0){\n        new_string += paren_string[i];\n\
    \      }\n      open_paren++;\n    }\n    else if(paren_string[i] === \")\"){\n\
    \      close_paren++;\n      if(open_paren === close_paren){\n        new_string\
    \ += paren_string[i];\n        string_array.push(new_string);\n        new_string\
    \ = \"\";\n        open_paren = 0;\n        close_paren = 0;\n      }\n      else{\n\
    \        new_string += paren_string[i];\n      }\n    }\n    else{\n      new_string\
    \ += paren_string[i];\n    }\n  }\n  return string_array;\n}\n", "\tvar paren_arr\
    \ = paren_string.split(\" \").join(\"\").split(\"\");\n\tvar str_arr = [];\n\t\
    var str = \"\";\n\tvar inc = 0;\n\tfor(var i = 0; i < paren_arr.length; i++){\n\
    \t\t//console.log(i);\n\t\tif(paren_arr[i] == \"(\"){\n\t\t\tinc += 1;\n\t\t\t\
    str = str + paren_arr[i];\n\t\t}else if(paren_arr[i] == \")\"){\n\t\t\tinc -=\
    \ 1;\n\t\t\tstr = str + paren_arr[i];\n\t\t}else{\n\t\t\tstr = str + paren_arr[i];\n\
    \t\t}\n\t\tif(inc == 0){\n\t\t\tstr_arr.push(str);\n\t\t\tstr = \"\";\n\t\t}\n\
    \t}\n\treturn str_arr;\n}\n", "    var result = [];\n    var open_paren = 0;\n\
    \    var current_string = \"\";\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] == '('){\n            open_paren++;\n            current_string\
    \ += '(';\n        }\n        else if(paren_string[i] == ')'){\n            open_paren--;\n\
    \            current_string += ')';\n        }\n        else if(paren_string[i]\
    \ == ' '){\n            //do nothing\n        }\n        else{\n            current_string\
    \ += paren_string[i];\n        }\n        if(open_paren == 0){\n            result.push(current_string);\n\
    \            current_string = \"\";\n        }\n    }\n    return result;\n}",
  "    //Example input: \"(((a))(b((c))(d))))(e((f(g))))\"\n    //Example output:\
    \ \"(a)\", \"(b(c)(d))\", \"(e(f(g)))\"\n    var paren_groups = [];\n    var counter\
    \ = 0;\n    var paren_group = \"\";\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        var char = paren_string.charAt(i);\n        if(char == '(')\n\
    \            counter += 1;\n        else if(char == ')')\n            counter\
    \ -= 1;\n        paren_group += char;\n        if(counter == 0){\n           \
    \ paren_groups.push(paren_group);\n            paren_group = \"\";\n        }\n\
    \    }\n    return paren_groups;\n}\n", "  // your code here\n  var paren_list\
    \ = [];\n  var paren_stack = [];\n  var current_group = \"\";\n  for (var i =\
    \ 0; i < paren_string.length; i++) {\n    if (paren_string[i] == \"(\") {\n  \
    \    paren_stack.push(paren_string[i]);\n      if (current_group != \"\") {\n\
    \        paren_list.push(current_group);\n        current_group = \"\";\n    \
    \  }\n    } else if (paren_string[i] == \")\") {\n      paren_stack.pop();\n \
    \   } else if (paren_string[i] != \" \") {\n      current_group += paren_string[i];\n\
    \    }\n  }\n  paren_list.push(current_group);\n  return paren_list;\n}\n", " \
    \   const stack = [];\n    const result = [];\n    let start = 0;\n    for (let\
    \ i = 0; i < paren_string.length; i++) {\n        if (paren_string[i] === '(')\
    \ {\n            stack.push(paren_string[i]);\n        } else if (paren_string[i]\
    \ === ')') {\n            stack.pop();\n            if (stack.length === 0) {\n\
    \                result.push(paren_string.slice(start, i + 1));\n            \
    \    start = i + 1;\n            }\n        }\n    }\n    return result;\n}\n\n\
    module.exports = {is_palindrome, reverse_string, reverse_words, reverse_words_alt,\
    \ is_anagram, missing_values, swap_values, reverse_array, reverse_array_in_place,\
    \ reverse_array_in_place_alt, remove_duplicates, separate_paren_groups};", " \
    \ // Your code here\n  // Hint 1: Look into String.split() and String.replace()\n\
    \  // Hint 2: You can put all open braces in the beginning of the string and all\
    \ close braces at the end.\n  var arr = paren_string.split(\"\");\n  var count\
    \ = 0;\n  var answer = [];\n  var str = \"\";\n  for(var i = 0; i < arr.length;\
    \ i++){\n    if(arr[i] === \"(\"){\n      count++;\n    }else if(arr[i] === \"\
    )\"){\n      count--;\n    }\n    if(count === 0 && str !== \"\"){\n      answer.push(str);\n\
    \      str = \"\";\n    }else{\n      str += arr[i];\n    }\n  }\n  return answer;\n\
    }\n", "    var left = [];\n    var right = [];\n    var results = [];\n    var\
    \ sli = 0;\n    var temp = [];\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] === '('){\n            left.push(i);\n        }\n\
    \        if(paren_string[i] === ')'){\n            right.push(i);\n        }\n\
    \    }\n    while(sli < left.length){\n        temp.push(paren_string.slice(left[sli],\
    \ right[sli] + 1));\n        sli++;\n    }\n    return temp;\n}\n", "    var answer\
    \ = [];\n    var index = 0;\n    var temp = \"\";\n    var count = 0;\n    var\
    \ len = paren_string.length;\n    while(index < len){\n        if(paren_string[index]\
    \ == '('){\n            temp += paren_string[index];\n            count += 1;\n\
    \        }\n        else if(paren_string[index] == ')'){\n            temp +=\
    \ paren_string[index];\n            count -= 1;\n        }\n        else{\n  \
    \          temp += paren_string[index];\n        }\n        if(count == 0){\n\
    \            answer.push(temp);\n            temp = \"\";\n        }\n       \
    \ index += 1;\n    }\n    return answer;\n}\n", "    //Separate parentheses groups\
    \ into a list of strings\n    var parens = paren_string.split(\"\");\n    var\
    \ paren_count = 0;\n    var paren_start = 0;\n    var paren_groups = [];\n   \
    \ for(var i = 0; i < parens.length; i++){\n        if(parens[i] == \"(\"){\n \
    \           paren_count += 1;\n            if(paren_count == 1){\n           \
    \     paren_start = i;\n            }\n        }else if(parens[i] == \")\"){\n\
    \            paren_count -= 1;\n            if(paren_count == 0){\n          \
    \      paren_groups.push(paren_string.slice(paren_start, i+1));\n            }\n\
    \        }\n    }\n    return paren_groups;\n}\n", "    let res = []\n    let\
    \ left = 0\n    let right = 0\n    let cur = ''\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == '('){\n            left++\n        }\n\
    \        if(paren_string[i] == ')'){\n            right++\n        }\n       \
    \ cur += paren_string[i]\n        if(left == right){\n            res.push(cur)\n\
    \            cur = ''\n            left = 0\n            right = 0\n        }\n\
    \    }\n    return res\n}\n", "    var arr = paren_string.replace(/ /g,'').split('');\n\
    \    var count = 0;\n    var str = '';\n    var strArr = [];\n    for(var i =\
    \ 0; i < arr.length; i++){\n        if(arr[i] === '('){\n            if(count\
    \ === 0){\n                str += arr[i];\n            }\n            count++;\n\
    \        }\n        else if(arr[i] === ')'){\n            count--;\n         \
    \   if(count === 0){\n                str += arr[i];\n                strArr.push(str);\n\
    \                str = '';\n            }\n        }\n        else{\n        \
    \    str += arr[i];\n        }\n    }\n    return strArr;\n}\n", "    var groups\
    \ = [];\n    var parens = [];\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        var char = paren_string[i];\n        if(char == '('){\n            parens.push(1);\n\
    \        }else if(char == ')'){\n            parens.pop();\n        }else if(char\
    \ == ' '){\n            continue;\n        }\n        if(parens.length === 0){\n\
    \            groups.push(paren_string.substring(0, i+1));\n            paren_string\
    \ = paren_string.substring(i+1);\n            i = -1;\n        }\n    }\n    return\
    \ groups;\n}\n", "\tvar index = 0;\n\tvar index2 = 0;\n\tvar counter = 0;\n\t\
    var array = [];\n\tfor(var i = 0; i < paren_string.length; i++){\n\t\t//console.log(paren_string[i]);\n\
    \t\tif(paren_string[i] === \"(\"){\n\t\t\t//console.log(\"found open paren\");\n\
    \t\t\tcounter++;\n\t\t\tif(counter === 1){\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t\
    }\n\t\tif(paren_string[i] === \")\"){\n\t\t\t//console.log(\"found closed paren\"\
    );\n\t\t\tcounter--;\n\t\t\tif(counter === 0){\n\t\t\t\t//console.log(\"adding\
    \ to array\");\n\t\t\t\tindex2 = i;\n\t\t\t\tarray.push(paren_string.slice(index,\
    \ index2+1));\n\t\t\t}\n\t\t}\n\t}\n\t//console.log(array);\n\treturn array;\n\
    }\n", "\tlet balanced_string = [];\n\tlet open_index = 0;\n\tlet open_count =\
    \ 0;\n\tlet close_count = 0;\n\tfor(let i = 0; i < paren_string.length; i++){\n\
    \t\tif(paren_string[i] === \"(\"){\n\t\t\topen_count += 1;\n\t\t\topen_index =\
    \ i;\n\t\t}\n\t\tif(paren_string[i] === \")\"){\n\t\t\tclose_count += 1;\n\t\t\
    }\n\t\tif(open_count === close_count){\n\t\t\tbalanced_string.push(paren_string.slice(open_index,\
    \ i + 1));\n\t\t\topen_count = 0;\n\t\t\tclose_count = 0;\n\t\t}\n\t}\n\treturn\
    \ balanced_string;\n}\n", "    var parseList = [];\n    var holdList = [];\n \
    \   for(var i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ == \"(\"){\n            //if (paren_string[i-1] == \" \"){\n            if(paren_string[i-1]\
    \ == \" \"){\n                if(holdList.length > 0){\n                    parseList.push(holdList.join(\"\
    \"));\n                    holdList = [];\n                }\n            }\n\
    \            holdList.push(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ == \")\"){\n            holdList.push(paren_string[i]);\n            parseList.push(holdList.join(\"\
    \"));\n            holdList = [];\n        }\n        else if(paren_string[i]\
    \ == \" \"){\n            if(holdList.length > 0){\n                parseList.push(holdList.join(\"\
    \"));\n                holdList = [];\n            }\n        }\n        else{\n\
    \            holdList.push(paren_string[i]);\n        }\n    }\n    return parseList;\n\
    }", "  var result = [];\n  var current = '';\n  var open = false;\n  for(var i\
    \ = 0; i < paren_string.length; i++){\n    switch(paren_string[i]){\n      case\
    \ '(':\n        if(!open){\n          open = true;\n        }\n        current\
    \ += paren_string[i];\n        break;\n      case ')':\n        current += paren_string[i];\n\
    \        open = false;\n        break;\n      default:\n        if(open){\n  \
    \        current += paren_string[i];\n        }\n        break;\n    }\n    if(!open\
    \ && current != ''){\n      result.push(current);\n      current = '';\n    }\n\
    \  }\n  return result;\n}", "  let opened = [];\n  let groups = [];\n  for(let\
    \ i = 0; i < paren_string.length; i++){\n    let char = paren_string[i];\n   \
    \ if(char === '('){\n      opened.push(i);\n    } else if(char === ')'){\n   \
    \   let start = opened.pop();\n      groups.push(paren_string.slice(start, i +\
    \ 1));\n    }\n  }\n  return groups;\n}", "    // The regular expression below\
    \ matches a balanced set of parentheses in the string. \n    // Each .match()\
    \ call returns the first set of balanced parentheses from the string. \n    //\
    \ As the string is progressively used up, the match string gets shorter and shorter\
    \ until \n    // there is nothing left to match.\n    var regex = /\\([^\\(\\\
    )]*\\)/;\n\n    // Use a while loop to apply the regex over and over again until\
    \ there are no matches left.\n    var matches = [];\n    while (paren_string.length\
    \ > 0){\n        var match = paren_string.match(regex);\n        if (match){\n\
    \            // If there was a match, add it to the list of matches.\n       \
    \     matches.push(match[0]);\n            // Then update the input string to\
    \ be the part of the string that we haven't used yet.\n            paren_string\
    \ = paren_string.substring(match.index + match[0].length);\n        } else {\n\
    \            // If there was no match, just stop the loop.\n            break;\n\
    \        }\n    }\n    return matches;\n}\n", "    var output = [];\n\n    //\
    \ Your code goes here\n\n    return output;\n}\n\n\n", "  var clean = paren_string.replace(/\\\
    s/g, '');\n  var groups = [];\n  var stack = [];\n  var start = -1;\n  for(var\
    \ i = 0; i < clean.length; i++){\n    if(clean[i] === '('){\n      if(stack.length\
    \ === 0){\n        start = i;\n      }\n      stack.push(clean[i]);\n    }\n \
    \   else if(clean[i] === ')'){\n      stack.pop();\n      if(stack.length ===\
    \ 0){\n        groups.push(clean.slice(start, i + 1));\n      }\n    }\n  }\n\
    \  return groups;\n}\n", "    let result = [];\n    let temp = '';\n    let start\
    \ = 0;\n    let end = 0;\n    let count = 0;\n    let len = paren_string.length;\n\
    \    for(let i = 0; i < len; i++){\n        if(paren_string[i] === '('){\n   \
    \         count += 1;\n            if(count === 1){\n                start = i\
    \ + 1;\n            }\n        }\n        if(paren_string[i] === ')'){\n     \
    \       count -= 1;\n            if(count === 0){\n                end = i;\n\
    \                result.push(paren_string.slice(start, end));\n            }\n\
    \        }\n    }\n    return result;\n}\n", "    let groups = [];\n    let curr_group\
    \ = \"\";\n    let open_count = 0;\n    let closed_count = 0;\n    for(let i =\
    \ 0; i < paren_string.length; i++){\n        if(paren_string[i] !== \" \"){\n\
    \            if(paren_string[i] === \"(\"){\n                open_count++;\n \
    \           }\n            else if(paren_string[i] === \")\"){\n             \
    \   closed_count++;\n            }\n            curr_group += paren_string[i];\n\
    \            if(open_count === closed_count){\n                groups.push(curr_group);\n\
    \                curr_group = \"\";\n                open_count = 0;\n       \
    \         closed_count = 0;\n            }\n        }\n    }\n    return groups;\n\
    }\n", "  let paren_depth = 0;\n  let result = [];\n  let output = '';\n  for (let\
    \ i = 0; i < paren_string.length; i++){\n    if (paren_string[i] === '('){\n \
    \     paren_depth++;\n      output += paren_string[i];\n    } else if (paren_string[i]\
    \ === ')'){\n      paren_depth--;\n      output += paren_string[i];\n    } else\
    \ if (paren_string[i] === ' '){\n      //ignore\n    } else {\n      output +=\
    \ paren_string[i];\n    }\n    if (paren_depth === 0 && output !== ''){\n    \
    \  result.push(output);\n      output = '';\n    }\n  }\n  return result;\n}\n",
  "  var seperate_paren_groups = [];\n  var parens_left = 0;\n  var parens_right =\
    \ 0;\n  var start_index = 0;\n  for(var i = 0; i < paren_string.length; i++){\n\
    \    if(paren_string[i] === '('){\n      parens_left++;\n    }\n    if(paren_string[i]\
    \ === ')'){\n      parens_right++;\n    }\n    if(parens_left === parens_right){\n\
    \      seperate_paren_groups.push(paren_string.slice(start_index, i + 1));\n \
    \     start_index = i + 1;\n      parens_left = 0;\n      parens_right = 0;\n\
    \    }\n  }\n  return seperate_paren_groups;\n}\n\nmodule.exports = {\n  range:\
    \ range,\n  unique_elements: unique_elements,\n  unique_elements_with_filter:\
    \ unique_elements_with_filter,\n  square_of_sum: square_of_sum,\n  sum_of_squares:\
    \ sum_of_squares,\n  difference_of_squares: difference_of_squares,\n  elements_by_index:\
    \ elements_by_index,\n  two_dimensional_array: two_dimensional_array,\n  array_to_object:\
    \ array_to_object,\n  object_to_array: object_to_array,\n  fibonacci: fibonacci,\n\
    \  factorial: factorial,\n  factorial_with_memo: factorial_with_memo,\n  fibonacci_with_memo:\
    \ fibonacci_with_memo,\n  scramble: scramble,\n  scramble_with_memo: scramble_with_memo,\n\
    \  separate_paren_groups: separate_paren_groups\n};", "    let groups = [];\n\
    \    let group = \"\";\n    let stack = [];\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        let c = paren_string[i];\n        if(c === '('){\n          \
    \  stack.push(c);\n        }else if(c === ')'){\n            stack.pop();\n  \
    \      }\n        group += c;\n        if(stack.length === 0){\n            groups.push(group);\n\
    \            group = \"\";\n        }\n    }\n    return groups;\n}\n", "    var\
    \ paren_stack = [];\n    var separated_groups = [];\n    var current_paren_group\
    \ = '';\n    var paren_open = false;\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            paren_stack.push('(');\n\
    \            paren_open = true;\n        }\n        else if(paren_string[i] ===\
    \ ')'){\n            paren_stack.pop();\n            if(paren_stack.length ===\
    \ 0){\n                separated_groups.push(current_paren_group);\n         \
    \       current_paren_group = '';\n                paren_open = false;\n     \
    \       }\n        }\n        else if(paren_open === true){\n            current_paren_group\
    \ += paren_string[i];\n        }\n    }\n    return separated_groups;\n}\n", " \
    \   // TODO: Implement this function\n    var start = 0;\n    var result = [];\n\
    \    var sum = 0;\n    for(var i = 0; i < paren_string.length; i++){\n       \
    \ var ch = paren_string.charAt(i);\n        if(ch == '('){\n            sum++;\n\
    \        }\n        else if(ch == ')'){\n            sum--;\n        }\n     \
    \   if(sum == 0){\n            result.push(paren_string.substring(start, i + 1));\n\
    \            start = i + 1;\n        }\n    }\n    return result;\n}\n", "   \
    \ let paren_groups = [];\n    let paren_group = \"\";\n    let paren_count = 0;\n\
    \    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ == \"(\"){\n            paren_count++;\n            paren_group += paren_string[i];\n\
    \        }\n        else if(paren_string[i] == \")\"){\n            paren_count--;\n\
    \            paren_group += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ != \" \"){\n            paren_group += paren_string[i];\n        }\n       \
    \ if(paren_count == 0 && paren_group != \"\"){\n            paren_groups.push(paren_group);\n\
    \            paren_group = \"\";\n        }\n    }\n    return paren_groups;\n\
    }\n", "    var parens = paren_string.split(\"\");\n    var count = 0;\n    var\
    \ output = [];\n    var start = 0;\n    for(i = 0; i < parens.length; i++){\n\
    \        if(parens[i] === \"(\"){\n            count++;\n        }\n        if(parens[i]\
    \ === \")\"){\n            count--;\n        }\n        if(count === 0){\n   \
    \         output.push(paren_string.slice(start, i+1));\n            start = i+1;\n\
    \        }\n    }\n    return output;\n}\n", "\n}\n\nmodule.exports = {\n    'is_balanced':\
    \ is_balanced,\n    'separate_paren_groups': separate_paren_groups\n};", "   \
    \ let stack = [], start_idx = 0, end_idx = 0, output = [];\n    for(let i = 0;\
    \ i < paren_string.length; i++){\n        if(paren_string[i] === '('){\n     \
    \       if(stack.length === 0){\n                start_idx = i;\n            }\n\
    \            stack.push(paren_string[i]);\n        }\n        else if(paren_string[i]\
    \ === ')'){\n            stack.pop();\n            if(stack.length === 0){\n \
    \               end_idx = i;\n                output.push(paren_string.slice(start_idx,\
    \ end_idx + 1));\n            }\n        }\n    }\n    return output;\n}\n", " \
    \   let current_paren_group = '';\n    let paren_groups = [];\n    let paren_stack\
    \ = [];\n    for(let c of paren_string){\n        if(c === '(' || c === ')'){\n\
    \            if(paren_stack.length === 0){\n                current_paren_group\
    \ += c;\n            }\n            if(c === '('){\n                paren_stack.push(c);\n\
    \            }else{\n                if(paren_stack.length > 0){\n           \
    \         paren_stack.pop();\n                }\n            }\n            if(paren_stack.length\
    \ === 0){\n                paren_groups.push(current_paren_group);\n         \
    \       current_paren_group = '';\n            }\n        }\n    }\n    return\
    \ paren_groups;\n}", "    // TODO: Implement me!\n    return paren_string.match(/\\\
    ([^\\(\\)]*\\)/g).map(match => match.replace(/\\s/g, ''));\n}", "    // filter\
    \ out spaces\n    var clean_paren_string = paren_string.replace(/\\s/g,'');\n\
    \    //find first open brace\n    var index = clean_paren_string.indexOf('(');\n\
    \    var count = 1;\n    //find matching close brace\n    while(count > 0 && index\
    \ < clean_paren_string.length){\n        index += 1;\n        if(clean_paren_string[index]\
    \ === '('){\n            count += 1;\n        } else if(clean_paren_string[index]\
    \ === ')'){\n            count -= 1;\n        }\n    }\n    // if outermost brackets\
    \ were unbalanced, return the original string\n    if(count > 0){\n        return\
    \ [paren_string];\n    }\n    // use recursion to solve for inner most brackets\n\
    \    return [paren_string.slice(0, index + 1)].concat(separate_paren_groups(paren_string.slice(index\
    \ + 1, paren_string.length)));\n}\n", "    let separated_parens = [];\n    let\
    \ open_parens = 0;\n    let current_string = \"\";\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === \"(\"){\n            if(open_parens ===\
    \ 0){\n                current_string = \"\";\n            }\n            open_parens++;\n\
    \        }\n        else if(paren_string[i] === \")\"){\n            open_parens--;\n\
    \            if(open_parens === 0){\n                separated_parens.push(current_string);\n\
    \            }\n        }\n        else if(open_parens > 0){\n            current_string\
    \ += paren_string[i];\n        }\n    }\n    return separated_parens;\n}\n", " \
    \   let input = paren_string.replace(/\\s/g,'');\n    let groups = [];\n    let\
    \ start_idx = -1;\n    let open_idx = -1;\n    let close_idx = -1;\n    let i\
    \ = 0;\n    while(i < input.length){\n        switch(input[i]){\n            case\
    \ '(':\n                if(start_idx === -1){\n                    start_idx =\
    \ i;\n                }\n                if(open_idx === -1){\n              \
    \      open_idx = i;\n                }\n                break;\n            case\
    \ ')':\n                if(open_idx !== -1){\n                    close_idx =\
    \ i;\n                }\n                break;\n        }\n        if(start_idx\
    \ !== -1 && open_idx !== -1 && close_idx !== -1){\n            groups.push(input.slice(start_idx,\
    \ close_idx + 1));\n            start_idx = -1;\n            open_idx = -1;\n\
    \            close_idx = -1;\n        }\n        i++;\n    }\n    return groups;\n\
    }\n", "    let input=paren_string.split('');\n    let stack=[];\n    let output=[];\n\
    \    let curr_str='';\n    let curr_char='';\n    while(input.length>0){\n   \
    \     curr_char=input.shift();\n        if(curr_char==='('){\n            stack.push(curr_char);\n\
    \            curr_str+=curr_char;\n        }\n        else if(curr_char===')'){\n\
    \            stack.pop();\n            curr_str+=curr_char;\n            if(stack.length===0){\n\
    \                output.push(curr_str);\n                curr_str='';\n      \
    \      }\n        }\n        else{\n            curr_str+=curr_char;\n       \
    \ }\n    }\n    return output;\n}", "    let output_list = [];\n    let group_paren\
    \ = \"\";\n    let num_paren = 0;\n    for (let i = 0; i < paren_string.length;\
    \ i++){\n        if (paren_string[i] == '(') {\n            num_paren += 1;\n\
    \            group_paren += paren_string[i];\n        }\n        else if (paren_string[i]\
    \ == ')') {\n            num_paren -= 1;\n            group_paren += paren_string[i];\n\
    \        }\n        else {\n            group_paren += paren_string[i];\n    \
    \    }\n        if (num_paren == 0) {\n            output_list.push(group_paren);\n\
    \            group_paren = \"\";\n        }\n    }\n    return output_list;\n\
    }\n\n", "    //remove space\n    paren_string = paren_string.replace(/\\s/g, '');\n\
    \    //split groups\n    var groups = paren_string.split(\")(\");\n    //remove\
    \ open parens\n    groups[0] = groups[0].replace(/\\(/g, '');\n    //remove close\
    \ parens\n    groups[groups.length-1] = groups[groups.length-1].replace(/\\)/g,\
    \ '');\n    return groups;\n}", "    return paren_string.split(')(').filter(function(value){return\
    \ value!=''}).map(function(value){return value.replace(/ /g,'')});\n}\n", "  \
    \  var openCount = 0;\n    var closeCount = 0;\n    var inputString = paren_string.split(\"\
    \");\n    var newArray = [];\n    var tempString = [];\n    for(var i = 0; i <\
    \ inputString.length; i++){\n        if(inputString[i] == \"(\"){\n          \
    \  if(openCount == 0){\n                openCount++;\n            }\n        \
    \    else{\n                openCount++;\n            }\n        }\n        else\
    \ if(inputString[i] == \")\"){\n            closeCount++;\n        }\n       \
    \ if(openCount == closeCount){\n            tempString.push(inputString[i]);\n\
    \            newArray.push(tempString.join(\"\"));\n            tempString = [];\n\
    \            openCount = 0;\n            closeCount = 0;\n        }\n        else{\n\
    \            tempString.push(inputString[i]);\n        }\n    }\n    return newArray;\n\
    }", "    // First, if the string is empty, return an empty array.\n    if (paren_string\
    \ === '') return [];\n    // This array will store the results of the functions.\n\
    \    let results = [];\n    // This var will keep track of the current group being\
    \ worked on.\n    let currentGroup = '';\n    // This var will keep track of how\
    \ many open parens there are in the current group.\n    let openCount = 0;\n \
    \   // For each character in the string...\n    for (let char of paren_string)\
    \ {\n        // If the character is a '(', add 1 to the openCount.\n        if\
    \ (char === '(') openCount++;\n        // Else if the character is a ')', subtract\
    \ 1 from the openCount.\n        else if (char === ')') openCount--;\n       \
    \ // Add the current character to the currentGroup.\n        currentGroup += char;\n\
    \        // If openCount is 0, the current group is done, so add it to the results,\
    \ and set currentGroup to ''\n        if (openCount === 0) {\n            results.push(currentGroup);\n\
    \            currentGroup = '';\n        }\n    }\n    // If currentGroup is still\
    \ not an empty string, it was the last group in the paren_string, so push it to\
    \ results.\n    if (currentGroup !== '') results.push(currentGroup);\n    // Return\
    \ the array of results.\n    return results;\n}", "    let result = [];\n    let\
    \ openBrace = 0;\n    let balanced = false;\n    let str = \"\";\n    for(let\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] === \"(\"\
    ){\n            if(openBrace === 0){\n                openBrace += 1;\n      \
    \          balanced = true;\n            }else{\n                openBrace +=\
    \ 1;\n            }\n        }else if(paren_string[i] === \")\"){\n          \
    \  openBrace -= 1;\n            if(openBrace === 0){\n                balanced\
    \ = true;\n            }\n        }\n        if(balanced){\n            str +=\
    \ paren_string[i];\n        }\n        if(i === paren_string.length - 1){\n  \
    \          result.push(str);\n        }\n        if(balanced && openBrace ===\
    \ 0){\n            result.push(str);\n            str = \"\";\n            balanced\
    \ = false;\n        }\n    }\n    return result;\n}", "  var final_array = [];\n\
    \  var str_array = paren_string.split(\"\");\n  var str_array_copy = str_array.slice();\n\
    \  for(var i = 0; i < str_array.length; i++){\n    var x = 0;\n    var y = 0;\n\
    \    if(str_array[i] == \"(\"){\n      x = i;\n      for(var j = i; j < str_array.length;\
    \ j++){\n        if(str_array[j] == \"(\"){\n          x = j;\n        }\n   \
    \     if(str_array[j] == \")\"){\n          y = j;\n          break;\n       \
    \ }\n      }\n      var temp_array = str_array_copy.slice(x, y+1);\n      final_array.push(temp_array.join(\"\
    \"));\n    }\n  }\n  return final_array;\n}\n", "\t// Go through string and separate\
    \ parentheses\n\tparen_string = paren_string.split(\" \").join(\"\"); // Ignore\
    \ spaces\n\tvar paren_groups = [paren_string[0]]; //Start with first group\n\t\
    var group_count = 0; // Keep track of groups\n\n\tfor (var i = 1; i < paren_string.length;\
    \ i++){\n\t\tif (paren_string[i] == \"(\"){\n\t\t\tgroup_count++;\n\t\t\tparen_groups[group_count]\
    \ = paren_string[i];\n\t\t} else if (paren_string[i] == \")\"){\n\t\t\tparen_groups[group_count]\
    \ += paren_string[i];\n\t\t\tgroup_count--;\n\t\t} else{\n\t\t\tparen_groups[group_count]\
    \ += paren_string[i];\n\t\t}\n\t}\n\treturn paren_groups;\n}\n", "    let groups\
    \ = [];\n    let cur_group = '';\n    let balance = 0;\n    for(let i = 0; i <\
    \ paren_string.length; i++){\n        if(paren_string[i] === '('){\n         \
    \   balance++;\n            cur_group += paren_string[i];\n        }\n       \
    \ else if(paren_string[i] === ')'){\n            balance--;\n            cur_group\
    \ += paren_string[i];\n        }\n        else{\n            cur_group += paren_string[i];\n\
    \        }\n        if(balance === 0){\n            groups.push(cur_group);\n\
    \            cur_group = '';\n        }\n    }\n    return groups;\n}\n\n", " \
    \ let stack = [];\n  let output = [];\n  let currStr = '';\n  for(let paren of\
    \ paren_string){\n    if(paren === '('){\n      stack.push(paren);\n    }\n  \
    \  else if(paren === ')'){\n      stack.pop();\n    }\n    currStr += paren;\n\
    \    if(stack.length === 0){\n      output.push(currStr);\n      currStr = '';\n\
    \    }\n  }\n  return output;\n}\n", "  var stack = [];\n  var start = 0;\n  var\
    \ end = 0;\n  var answer = [];\n  for(var i = 0; i < paren_string.length; i++){\n\
    \    if(paren_string[i] === \"(\"){\n      stack.push(paren_string[i]);\n    \
    \  start = i;\n    }\n    if(paren_string[i] === \")\"){\n      stack.pop();\n\
    \      end = i;\n    }\n    if(stack.length === 0){\n      answer.push(paren_string.slice(start,\
    \ end + 1));\n    }\n  }\n  return answer;\n}\n", "    let matches = paren_string.match(/[^()]*\\\
    (|\\)[^()]*/g);\n    let brackets = [];\n    for(let i = 0; i < matches.length;\
    \ i++){\n        let match = matches[i];\n        let bracket_index = match.indexOf('(');\n\
    \        let bracket_end_index = match.indexOf(')');\n        if(bracket_index\
    \ >= 0){\n            brackets.push(match.substring(bracket_index));\n       \
    \ }\n        if(bracket_end_index >= 0){\n            brackets[brackets.length\
    \ - 1] += match.substring(bracket_end_index);\n        }\n    }\n    return brackets;\n\
    }", "  if(paren_string == \"\")\n    return [];\n  var new_string = \"\"\n  var\
    \ paren_list = []\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ == \"(\"){\n      new_string += \"(\"\n    }\n    else if(paren_string[i] ==\
    \ \")\"){\n      new_string += \")\"\n      paren_list.push(new_string)\n    \
    \  new_string = \"\"\n    }\n  }\n  return paren_list\n}\n", "    let result =\
    \ [];\n    let parenCount = 0;\n    let tmp = \"\";\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        let c = paren_string[i];\n        if(c == ' '){\n           \
    \ continue;\n        }\n        if(c == '('){\n            parenCount++;\n   \
    \     }\n        if(c == ')'){\n            parenCount--;\n        }\n       \
    \ tmp += c;\n        if(parenCount == 0){\n            result.push(tmp);\n   \
    \         tmp = \"\";\n        }\n    }\n    return result;\n}", "    //your code\
    \ here\n    var ans = [];\n    var str = \"\";\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        var temp = paren_string[i];\n        var count = 0;\n       \
    \ if(temp == '('){\n            for(var j = i; j < paren_string.length; j++){\n\
    \                if(paren_string[j] == '('){\n                    count ++;\n\
    \                }\n                if(paren_string[j] == ')'){\n            \
    \        count --;\n                }\n                if(count == 0){\n     \
    \               ans.push(paren_string.substring(i, j+1));\n                  \
    \  i = j;\n                    break;\n                }\n            }\n    \
    \    }\n    }\n    return ans;\n}\nvar result = separate_paren_groups(\"((()))()(())(((())))\"\
    );\nfor(var i = 0; i < result.length; i++){\n    console.log(result[i]);\n}\n",
  "    var ans = [];\n    var cur = \"\";\n    var opened = 0;\n    for(var i = 0;\
    \ i < paren_string.length; i++){\n        if(paren_string[i] === '('){\n     \
    \       if(opened === 0){\n                cur = cur + '(';\n            }else{\n\
    \                cur = cur + paren_string[i];\n            }\n            opened\
    \ = opened + 1;\n        }else if(paren_string[i] === ')'){\n            if(opened\
    \ === 1){\n                cur = cur + ')';\n                ans.push(cur);\n\
    \                cur = \"\";\n            }else{\n                cur = cur +\
    \ paren_string[i];\n            }\n            opened = opened - 1;\n        }else\
    \ if(paren_string[i] !== ' '){\n            cur = cur + paren_string[i];\n   \
    \     }\n    }\n    return ans;\n}\n", "    return paren_string.replace(/\\s/g,'').split(/[()]{2}/).filter(word\
    \ => word != '')\n}\n", "  var arr = []\n  var s = \"\"\n  var i = 0\n  while(i\
    \ < paren_string.length){\n    if(paren_string[i] == \"(\"){\n      var j = i\n\
    \      var count = 1\n      while(count > 0){\n        j++\n        if(paren_string[j]\
    \ == \"(\"){\n          count++\n        }else if(paren_string[j] == \")\"){\n\
    \          count--\n        }\n      }\n      arr.push(paren_string.slice(i,j+1))\n\
    \      i = j + 1\n    }else{\n      i++\n    }\n  }\n  return arr\n}\n", "   \
    \ var result = [];\n    var stack = [];\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        var c = paren_string[i];\n        if(c == '('){\n           \
    \ stack.push(i);\n        }\n        else if(c == ')'){\n            var open_paren_index\
    \ = stack.pop();\n            result.push(paren_string.substring(open_paren_index,\
    \ i + 1));\n        }\n    }\n    return result;\n}\n", "  //Remove spaces, replace\
    \ parens with something else to maintain count\n  paren_string = paren_string.replace(/\\\
    s/g, \"\");\n  paren_string = paren_string.replace(/\\(/g, \"1\");\n  paren_string\
    \ = paren_string.replace(/\\)/g, \"0\");\n  //Add a 1 at the end to signify the\
    \ end of the paren string\n  paren_string += \"1\";\n  var separate_groups = [];\n\
    \  var curr_group = \"\";\n  var paren_count = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == \"1\"){\n      if(paren_count == 0){\n    \
    \    curr_group += \"(\";\n      }\n      paren_count++;\n    }\n    else{\n \
    \     paren_count--;\n      if(paren_count == 0){\n        curr_group += \")\"\
    ;\n        separate_groups.push(curr_group);\n        curr_group = \"\";\n   \
    \   }\n    }\n  }\n  return separate_groups;\n}\n", "    let completeString =\
    \ \"\";\n    let newArray = [];\n    let openParenArray = [];\n    let parenArray\
    \ = [];\n    let index = 0;\n    for(let i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] == \"(\"){\n            openParenArray.push(paren_string[i]);\n\
    \            completeString += paren_string[i];\n        }else if(paren_string[i]\
    \ == \")\"){\n            openParenArray.pop();\n            completeString +=\
    \ paren_string[i];\n        }else if(paren_string[i] == \" \"){\n            continue;\n\
    \        }\n        if(openParenArray.length == 0){\n            if(completeString.length\
    \ > 0){\n                parenArray.push(completeString);\n                completeString\
    \ = \"\";\n            }\n        }\n    }\n    return parenArray;\n}\n", "\t\
    var separate = [];\n\tvar str = '';\n\tvar paren = 0;\n\tvar space = false;\n\t\
    var mode = false;\n\tvar result = [];\n\tfor(i = 0; i < paren_string.length; i++){\n\
    \t\tif(paren_string[i] == ' '){\n\t\t\tspace = true;\n\t\t}\n\t\telse if(paren_string[i]\
    \ == '('){\n\t\t\tif(space){\n\t\t\t\tspace = false;\n\t\t\t\tif(str.length ==\
    \ 0){\n\t\t\t\t\tmode = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tseparate.push(str);\n\
    \t\t\t\t\tstr = '';\n\t\t\t\t\tmode = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\
    \t\t\t\tif(mode){\n\t\t\t\t\tparen++;\n\t\t\t\t\tstr += paren_string[i];\n\t\t\
    \t\t}\n\t\t\t\telse{\n\t\t\t\t\tmode = true;\n\t\t\t\t\tparen++;\n\t\t\t\t\tstr\
    \ += paren_string[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(paren_string[i]\
    \ == ')'){\n\t\t\tif(space){\n\t\t\t\tspace = false;\n\t\t\t\tif(str.length ==\
    \ 0){\n\t\t\t\t\tmode = false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tseparate.push(str);\n\
    \t\t\t\t\tstr = '';\n\t\t\t\t\tmode = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\
    \t\t\t\tif(mode){\n\t\t\t\t\tparen--;\n\t\t\t\t\tstr += paren_string[i];\n\t\t\
    \t\t\tif(paren == 0){\n\t\t\t\t\t\tseparate.push(str);\n\t\t\t\t\t\tstr = '';\n\
    \t\t\t\t\t\tmode = false;\n\t\t\t\t\t}\n\t\t\t", "  var paren_array = paren_string.split(\"\
    \");\n  var new_string = \"\";\n  var nested_paren_array = [];\n  for(var i =\
    \ 0; i < paren_array.length; i++){\n    if(paren_array[i] === \"(\" || paren_array[i]\
    \ === \")\"){\n      new_string += paren_array[i];\n    }\n  }\n  var count =\
    \ 0;\n  var temp_string = \"\";\n  for(var j = 0; j < new_string.length; j++){\n\
    \    if(new_string[j] === \"(\"){\n      count++;\n    }\n    if(new_string[j]\
    \ === \")\"){\n      count--;\n    }\n    temp_string += new_string[j];\n    if(count\
    \ === 0){\n      nested_paren_array.push(temp_string);\n      temp_string = \"\
    \";\n    }\n  }\n  return nested_paren_array;\n}\n", "  paren_string = paren_string.replace(/\\\
    s/g, ''); // Remove all spaces\n  var open = [];\n  var result = [];\n  for (var\
    \ i = 0; i < paren_string.length; i++) {\n    var current = paren_string[i];\n\
    \    if (current === '(') {\n      open.push(i);\n    } else if (current === ')')\
    \ {\n      if (open.length) {\n        result.push(paren_string.slice(open.pop(),\
    \ i + 1));\n      }\n    }\n  }\n  return result;\n}\n", "    let results = [];\n\
    \    let temp = \"\";\n    let open = 0;\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == \"(\"){\n            open++;\n        \
    \    temp += paren_string[i];\n        }\n        else if(paren_string[i] == \"\
    )\"){\n            open--;\n            temp += paren_string[i];\n        }\n\
    \        else{\n            temp += paren_string[i];\n        }\n        if(open\
    \ == 0){\n            results.push(temp);\n            temp = \"\";\n        }\n\
    \    }\n    return results;\n}\n", "    var numOpen = 0;\n    var numClose = 0;\n\
    \    var output = [];\n    var tempString = \"\";\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === \"(\"){\n            numOpen++;\n    \
    \    }\n        if(paren_string[i] === \")\"){\n            numClose++;\n    \
    \    }\n        if(paren_string[i] !== \" \"){\n            tempString += paren_string[i];\n\
    \        }\n        if(numOpen === numClose){\n            numOpen = 0;\n    \
    \        numClose = 0;\n            output.push(tempString);\n            tempString\
    \ = \"\";\n        }\n    }\n    return output;\n}\n", "\n}\n", "    var res =\
    \ [];\n    var i = 0;\n    var c = 0;\n    while(i < paren_string.length){\n \
    \       if(paren_string[i] == '(')\n            c++;\n        else if(paren_string[i]\
    \ == ')')\n            c--;\n        i++;\n        if(c == 0){\n            res.push(paren_string.substring(0,\
    \ i));\n            paren_string = paren_string.substring(i);\n            i =\
    \ 0;\n        }\n    }\n    return res;\n}\n", "  var parens = [];\n  var counter\
    \ = 0;\n  var tmpStr = \"\";\n  for(var i = 0; i < paren_string.length; i++){\n\
    \    if(paren_string[i] === \"(\"){\n      counter++;\n    }else if(paren_string[i]\
    \ === \")\"){\n      counter--;\n    }\n    tmpStr += paren_string[i];\n    if(counter\
    \ === 0){\n      parens.push(tmpStr);\n      tmpStr = \"\";\n    }\n  }\n  return\
    \ parens;\n}\n", "  var parens = [];\n  var split_parens = paren_string.split(\"\
    \");\n  var counter = 0;\n  var start_substr = 0;\n  var end_substr = 0;\n  for(var\
    \ i = 0; i < split_parens.length; i++){\n    if(split_parens[i] === \"(\"){\n\
    \      counter++;\n    }\n    if(split_parens[i] === \")\"){\n      counter--;\n\
    \    }\n    if(counter === 0){\n      end_substr = i;\n      parens.push(paren_string.substring(start_substr,\
    \ end_substr + 1));\n      start_substr = i + 1;\n    }\n  }\n  return parens;\n\
    }\n", "  var paren_groups = [];\n  var paren_group = \"\";\n  var open_braces\
    \ = 0;\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ == \"(\"){\n      open_braces++;\n      paren_group += paren_string[i];\n  \
    \  }\n    else if(paren_string[i] == \")\"){\n      open_braces--;\n      paren_group\
    \ += paren_string[i];\n      if(open_braces == 0){\n        paren_groups.push(paren_group);\n\
    \        paren_group = \"\";\n      }\n    }\n    else if(paren_string[i] != \"\
    \ \"){\n      paren_group += paren_string[i];\n    }\n  }\n  return paren_groups;\n\
    }\n", "    let i = 0;\n    let list = [];\n    let counter = 0;\n    let group\
    \ = \"\";\n    while(i < paren_string.length){\n        if(paren_string[i] ===\
    \ \"(\"){\n            group += paren_string[i];\n            counter++;\n   \
    \     }\n        else if(paren_string[i] === \")\"){\n            group += paren_string[i];\n\
    \            counter--;\n        }\n        else if(paren_string[i] !== \" \"\
    ){\n            group += paren_string[i];\n        }\n        if(counter === 0\
    \ && group !== \"\"){\n            list.push(group);\n            group = \"\"\
    ;\n        }\n        i++;\n    }\n    return list;\n}\n", "    let groups = [];\n\
    \n    // index is the index of the first paren of the current group in paren_string\n\
    \    let current_group_start = 0;\n    let current_group_level = 0;\n\n    for\
    \ (let i = 0; i < paren_string.length; i++){\n        if (paren_string[i] ===\
    \ '('){\n            current_group_level++;\n        } else if (paren_string[i]\
    \ === ')'){\n            current_group_level--;\n        }\n        if (current_group_level\
    \ === 0){\n            groups.push(paren_string.slice(current_group_start, i +\
    \ 1));\n            current_group_start = i + 1;\n        }\n    }\n\n    return\
    \ groups;\n}\n", "  var groups = [];\n  var current_group = '';\n  var valid_parens\
    \ = ['(', ')'];\n  for(var i = 0; i < paren_string.length; i++){\n    var char\
    \ = paren_string[i];\n    if(char === ' '){\n      continue;\n    }\n    if(valid_parens.indexOf(char)\
    \ > -1){\n      current_group += char;\n    }\n    if(current_group.length > 0\
    \ && balanced(current_group)){\n      groups.push(current_group);\n      current_group\
    \ = '';\n    }\n  }\n  return groups;\n}\n", "    var ret_array = [];\n    //1.\
    \ detect all parentheses in the string, ignoring spaces\n    var paren_position\
    \ = [];\n    for(var i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ == '(' || paren_string[i] == ')'){\n            paren_position.push(i);\n  \
    \      }\n    }\n    //2. from the largest (last) to the first, find the substrings\
    \ between the parentheses\n    for(var i = paren_position.length - 1; i >= 0;\
    \ i--){\n        if(paren_string[paren_position[i]] == '('){\n            var\
    \ j = paren_position[i];\n            while(paren_string[j] != ')'){\n       \
    \         j++;\n            }\n            ret_array.push(paren_string.substring(paren_position[i],\
    \ j + 1));\n            //remove the substring we just pushed into the array\n\
    \            paren_string = paren_string.substring(0, paren_position[i]) + paren_string.substring(j\
    \ + 1);\n        }\n    }\n    return ret_array;\n}\n", "  var result = [];\n\
    \  var temp = [];\n  var open_parens = 0;\n  var last_paren_index = 0;\n  for(var\
    \ i = 0; i < paren_string.length; i++){\n    if(paren_string[i] === '('){\n  \
    \    open_parens++;\n    }\n    else if(paren_string[i] === ')'){\n      open_parens--;\n\
    \    }\n    if(open_parens === 0){\n      result.push(paren_string.slice(last_paren_index,\
    \ i+1));\n      last_paren_index = i+1;\n    }\n  }\n  return result;\n}\n", " \
    \   var paren_list = []\n    var open_counter = 0\n    var curr_paren_group =\
    \ \"\"\n    for (var i = 0; i < paren_string.length; i++){\n        if (paren_string[i]\
    \ == '('){\n            if (open_counter == 0){\n                curr_paren_group\
    \ = \"\"\n            }\n            open_counter++\n        }\n        else if\
    \ (paren_string[i] == ')'){\n            open_counter--\n            if (open_counter\
    \ == 0){\n                paren_list.push(curr_paren_group)\n            }\n \
    \       }\n        else if (paren_string[i] != ' '){\n            curr_paren_group\
    \ += paren_string[i]\n        }\n    }\n    return paren_list\n}\n", "  let leftCount\
    \ = 0;\n  let rightCount = 0;\n  let newWord = '';\n  let newArr = [];\n  for(let\
    \ i = 0; i < paren_string.length; i++){\n    if(paren_string[i] === '('){\n  \
    \    leftCount++;\n    } else if(paren_string[i] === ')'){\n      rightCount++;\n\
    \    }\n    if(leftCount === rightCount){\n      if(paren_string[i] !== ' '){\n\
    \        newWord += paren_string[i];\n      }\n      newArr.push(newWord);\n \
    \     newWord = '';\n      leftCount = 0;\n      rightCount = 0;\n    } else if(leftCount\
    \ > rightCount){\n      newWord += paren_string[i];\n    }\n  }\n  return newArr;\n\
    }", "\tvar groups = [];\n\tvar current_group = [];\n\tvar opened = 0;\n\tvar closed\
    \ = 0;\n\tvar flag = false;\n\tfor(i = 0; i < paren_string.length; i++){\n\t\t\
    var current_char = paren_string[i];\n\t\tif(current_char == '('){\n\t\t\tcurrent_group.push(current_char);\n\
    \t\t\topened++;\n\t\t\tflag = true;\n\t\t}\n\t\telse if(current_char == ')'){\n\
    \t\t\tcurrent_group.push(current_char);\n\t\t\tclosed++;\n\t\t\tif(opened == closed){\n\
    \t\t\t\topened = 0;\n\t\t\t\tclosed = 0;\n\t\t\t\tgroups.push(current_group.join(''));\n\
    \t\t\t\tcurrent_group = [];\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\telse if(flag\
    \ == true){\n\t\t\tcurrent_group.push(current_char);\n\t\t}\n\t}\n\treturn groups;\n\
    }\n", "    var first = 0;\n    var last = 0;\n    var result = [];\n    var open\
    \ = 0;\n    var close = 0;\n    var counter = 0;\n    while(counter < paren_string.length){\n\
    \        if(paren_string[counter] == '('){\n            open++;\n        }\n \
    \       if(paren_string[counter] == ')'){\n            close++;\n        }\n \
    \       if(open == close){\n            result.push(paren_string.slice(first,counter+1));\n\
    \            first = counter+1;\n            counter++;\n            open = 0;\n\
    \            close = 0;\n        }\n        else{\n            counter++;\n  \
    \      }\n    }\n    return result;\n}\n", "    return paren_string.split(/\\\
    )\\s*/).filter(s => s).map(s => s + ')');\n}\n", "\tlet group_list = [];\n\tlet\
    \ temp_str = '';\n\tlet temp_str_paren_count = 0;\n\tfor(let i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] === '('){\n\t\t\ttemp_str_paren_count++;\n\t\t\
    }\n\t\telse if(paren_string[i] === ')'){\n\t\t\ttemp_str_paren_count--;\n\t\t\
    }\n\t\ttemp_str += paren_string[i];\n\t\tif(temp_str_paren_count === 0){\n\t\t\
    \tgroup_list.push(temp_str);\n\t\t\ttemp_str = '';\n\t\t}\n\t}\n\treturn group_list;\n\
    }\n", "    return paren_string.split(/\\)/).map(s => s.split(/\\(/)[1]).filter(s\
    \ => s);\n}\n", "    return paren_string.split(/\\)\\s*\\(/);\n}\n", "    let\
    \ result = [];\n    let current_paren = [];\n    let paren_open = 0;\n    for(let\
    \ i = 0; i < paren_string.length; i++){\n        let current_char = paren_string[i];\n\
    \        if(current_char === \"(\"){\n            paren_open++;\n            current_paren.push(current_char);\n\
    \        }\n        else if(current_char === \")\"){\n            if(paren_open\
    \ === 0){\n                throw new Error(\"Unbalanced parentheses\");\n    \
    \        }\n            paren_open--;\n            current_paren.push(current_char);\n\
    \            if(paren_open === 0){\n                result.push(current_paren.join(\"\
    \"));\n                current_paren = [];\n            }\n        }\n       \
    \ else if(current_char !== \" \"){\n            current_paren.push(current_char);\n\
    \        }\n    }\n    if(paren_open !== 0){\n        throw new Error(\"Unbalanced\
    \ parentheses\");\n    }\n    return result;\n}\n", "  var start = 0, end = 0,\
    \ open = 0, close = 0, index = 0, array = [], sub_string = \"\";\n  if(paren_string\
    \ === null || paren_string === undefined || paren_string === \"\"){\n    return\
    \ array;\n  }\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ === \"(\"){\n      open++;\n    }\n    if(paren_string[i] === \")\"){\n    \
    \  close++;\n    }\n    if(open === close){\n      end = i + 1;\n      sub_string\
    \ = paren_string.substring(start, end);\n      index = sub_string.indexOf(\"(\"\
    );\n      if(index !== -1){\n        array.push(sub_string.substring(index, end));\n\
    \      }\n      start = end;\n      open = 0;\n      close = 0;\n    }\n  }\n\
    \  return array;\n}\n", "\t\n\treturn [ \"This\", \"function\", \"is\", \"not\"\
    , \"yet\", \"implemented\" ];\n}\n", "  let groups = [];\n  let stack = [];\n\
    \  let curr = '';\n  for(let paren of paren_string){\n    if(paren === '('){\n\
    \      if(curr !== ''){\n        groups.push(curr);\n        curr = '';\n    \
    \  }\n      stack.push(paren);\n    }\n    else if(paren === ')'){\n      stack.pop();\n\
    \      if(stack.length === 0){\n        groups.push(curr);\n        curr = '';\n\
    \      }\n    }\n    else{\n      curr += paren;\n    }\n  }\n  return groups;\n\
    }\n", "  var paren_list = [];\n  var sub_list = [];\n  var open_parens = 0;\n\
    \  var close_parens = 0;\n  var paren_string = paren_string.replace(/\\s/g,'');\n\
    \  var paren_string_list = paren_string.split('');\n  if(paren_string.length >\
    \ 1){\n    for(var x = 0; x < paren_string_list.length; x++){\n      if(paren_string_list[x]\
    \ == '('){\n        sub_list.push(paren_string_list[x]);\n        open_parens\
    \ += 1;\n      }else if(paren_string_list[x] == ')'){\n        sub_list.push(paren_string_list[x]);\n\
    \        close_parens += 1;\n      }\n      if(open_parens == close_parens){\n\
    \        paren_list.push(sub_list.join(''));\n        sub_list = [];\n       \
    \ open_parens = 0;\n        close_parens = 0;\n      }\n    }\n  }\n  return paren_list;\n\
    }\n", "\tvar cleanString = paren_string.replace(/\\s/g, '');\n\tvar hold = [];\n\
    \tvar start = 0;\n\tvar end = 0;\n\tvar count = 0;\n\tfor(var i = 0; i < cleanString.length;\
    \ i++){\n\t\tif(cleanString[i] === \"(\"){\n\t\t\tif(count === 0){\n\t\t\t\tstart\
    \ = i;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tif(cleanString[i] === \")\"){\n\t\t\
    \tcount--;\n\t\t\tif(count === 0){\n\t\t\t\tend = i;\n\t\t\t\thold.push(cleanString.slice(start,\
    \ end + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn hold;\n}\n", "    var paren_groups\
    \ = [];\n    var current_group = \"\";\n    var open_braces = 0;\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        var current_char = paren_string[i];\n\
    \        if(current_char == \"(\"){\n            if(open_braces == 0){\n     \
    \           current_group = \"\";\n            }\n            open_braces++;\n\
    \        }\n        else if(current_char == \")\"){\n            open_braces--;\n\
    \            if(open_braces == 0){\n                paren_groups.push(current_group);\n\
    \            }\n        }\n        else if(open_braces > 0){\n            current_group\
    \ += current_char;\n        }\n    }\n    return paren_groups;\n}\n", "    var\
    \ result = [];\n    var stack = [];\n    var cur_str = \"\";\n    for(var i =\
    \ 0; i < paren_string.length; i++){\n        var cur_char = paren_string[i];\n\
    \        if(cur_char == \"(\" || cur_char == \"{\" || cur_char == \"[\"){\n  \
    \          stack.push(cur_char);\n            cur_str += cur_char;\n        }else\
    \ if(cur_char == \")\" || cur_char == \"}\" || cur_char == \"]\"){\n         \
    \   var last_char = stack.pop();\n            if(cur_char == \")\" && last_char\
    \ != \"(\"){\n                return \"Error\";\n            }else if(cur_char\
    \ == \"}\" && last_char != \"{\"){\n                return \"Error\";\n      \
    \      }else if(cur_char == \"]\" && last_char != \"[\"){\n                return\
    \ \"Error\";\n            }\n            cur_str += cur_char;\n        }else if(cur_char\
    \ == \" \"){\n            continue;\n        }else{\n            cur_str += cur_char;\n\
    \        }\n        if(stack.length == 0){\n            result.push(cur_str);\n\
    \            cur_str = \"\";\n        }\n    }\n    return result;\n}\n", "  const\
    \ paren_groups = [];\n  let current_group = '';\n  let open_parens = 0;\n  for\
    \ (const character of paren_string) {\n    if (character === '(') {\n      open_parens++;\n\
    \    } else if (character === ')') {\n      open_parens--;\n    }\n    if (open_parens\
    \ === 0 && current_group !== '') {\n      paren_groups.push(current_group);\n\
    \      current_group = '';\n    } else {\n      current_group += character;\n\
    \    }\n  }\n  return paren_groups;\n}\n", "    //create a stack\n    let stack\
    \ = [];\n    // create a string of groups\n    let groups = \"\";\n    // create\
    \ an array of string containing separate groups\n    let separate_groups = [];\n\
    \    // iterate the string\n    for(let i = 0; i < paren_string.length; i++){\n\
    \        // if its a opening brace\n        if(paren_string[i] === \"(\"){\n \
    \           // push the value to the stack\n            stack.push(paren_string[i]);\n\
    \        }\n        // if its a closing brace\n        else if(paren_string[i]\
    \ === \")\"){\n            // if the stack is empty\n            if(stack.length\
    \ === 0){\n                // push it to the string of groups\n              \
    \  groups += paren_string[i];\n            }\n            // if stack is not empty\n\
    \            else{\n                // pop the value from the stack\n        \
    \        stack.pop();\n                // push it to the string of groups\n  \
    \              groups += paren_string[i];\n            }\n        }\n        //\
    \ if its a character\n        else{\n            // push it to the string of groups\n\
    \            groups += paren_string[i];\n        }\n    }\n    // iterate the\
    \ string of groups\n    for(let i = 0; i < groups.length; i++){\n        // get\
    \ the index of the first brace\n        let start_index = groups.indexOf(\"(\"\
    );\n        // get the index of the last brace\n        let end_index = groups.lastIndexOf(\"\
    )\");\n        // add the braces to the array of separate_groups\n        separate_groups.push(groups.slice(start_index,\
    \ end_index + 1));\n        // remove the braces from the string of groups\n \
    \       groups = groups.slice(end_index + 1);\n    }\n    // return the array\
    \ of separate_groups\n    return separate_groups;\n}", "\tvar paren_open = [];\n\
    \tvar paren_close = [];\n\tvar paren_list = [];\n\tvar temp_list = \"\";\n\tfor(var\
    \ i = 0; i < paren_string.length; i++){\n\t\tif(paren_string[i] == \"(\"){\n\t\
    \t\tparen_open.push(i);\n\t\t}\n\t\tif(paren_string[i] == \")\"){\n\t\t\tparen_close.push(i);\n\
    \t\t}\n\t}\n\tvar len = paren_open.length;\n\tfor(var i = 0; i < len; i++){\n\t\
    \ttemp_list = paren_string.slice(paren_open[i], paren_close[i]+1);\n\t\tparen_list.push(temp_list);\n\
    \t}\n\treturn paren_list;\n}\n\n", "  let parenGroups = [];\n  let parenGroup\
    \ = \"\";\n  let openBraceCount = 0;\n  for(let char of paren_string){\n    if(char\
    \ === \"(\" && openBraceCount === 0){\n      openBraceCount++;\n      parenGroup\
    \ += char;\n    } else if(char === \"(\" && openBraceCount !== 0){\n      openBraceCount++;\n\
    \      parenGroup += char;\n    } else if(char === \")\" && openBraceCount ===\
    \ 1){\n      openBraceCount--;\n      parenGroup += char;\n      parenGroups.push(parenGroup);\n\
    \      parenGroup = \"\";\n    } else if(char === \")\" && openBraceCount !==\
    \ 1){\n      openBraceCount--;\n      parenGroup += char;\n    }\n  }\n  return\
    \ parenGroups;\n}\n", "\tlet ret_arr = [];\n\tlet paren_stack = [];\n\tlet curr_index\
    \ = 0;\n\tlet start_index = 0;\n\tfor(let i = 0; i < paren_string.length; i++){\n\
    \t\tif(paren_string[i] === '('){\n\t\t\tparen_stack.push(paren_string[i]);\n\t\
    \t\tif(paren_stack.length === 1){\n\t\t\t\tstart_index = i;\n\t\t\t}\n\t\t}\n\t\
    \telse if(paren_string[i] === ')'){\n\t\t\tparen_stack.pop();\n\t\t\tif(paren_stack.length\
    \ === 0){\n\t\t\t\tret_arr.push(paren_string.slice(start_index, i+1));\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn ret_arr;\n}\n", "    let current_paren_group = '';\n \
    \   let paren_groups = [];\n    let paren_stack = [];\n    for(let i = 0; i <\
    \ paren_string.length; i++){\n        if(paren_string[i] === '('){\n         \
    \   paren_stack.push(paren_string[i]);\n            current_paren_group += paren_string[i];\n\
    \        }\n        else if(paren_string[i] === ')'){\n            paren_stack.pop();\n\
    \            current_paren_group += paren_string[i];\n            if(paren_stack.length\
    \ === 0){\n                paren_groups.push(current_paren_group);\n         \
    \       current_paren_group = '';\n            }\n        }\n        else if(paren_string[i]\
    \ !== ' '){\n            current_paren_group += paren_string[i];\n        }\n\
    \    }\n    return paren_groups;\n}\n", "\tvar parentheses = /\\(|\\)/g; //regex\
    \ for matching parentheses\n\tvar parenArr = paren_string.match(parentheses);\
    \ //regex match for parentheses in the string\n\tvar parenList = [ ] ; //list\
    \ of separate groups of parentheses\n\tvar subList = [ ] ; //sublist of a group\
    \ of parentheses\n\tvar count = 0; //counting open and closed parentheses\n\t\
    var startCount = false; //counting open parentheses\n\tfor (var i = 0; i < parenArr.length;\
    \ i++){\n\t\tif (parenArr[i] == '('){\n\t\t\tcount++;\n\t\t\tstartCount = true;\n\
    \t\t}\n\t\telse if (parenArr[i] == ')'){\n\t\t\tcount--;\n\t\t}\n\t\tsubList.push(parenArr[i]);\n\
    \t\tif (count == 0 && startCount == true){\n\t\t\tparenList.push(subList);\n\t\
    \t\tsubList = [];\n\t\t\tstartCount = false;\n\t\t}\n\t}\n\tvar parenGroupList\
    \ = [ ];\n\tfor (var i = 0; i < parenList.length; i++){\n\t\tvar parenGroup =\
    \ parenList[i].join(\"\");\n\t\tparenGroupList.push(parenGroup);\n\t}\n\treturn\
    \ parenGroupList;\n}\n", "    var output = [];\n\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            var temp = \"\";\n\
    \            var num = 1;\n            for(var j = i+1; j < paren_string.length;\
    \ j++){\n                if(paren_string[j] === '('){\n                    num++;\n\
    \                }\n                if(paren_string[j] === ')'){\n           \
    \         num--;\n                }\n                if(num === 0){\n        \
    \            output.push(temp);\n                    i = j;\n                \
    \    break;\n                }\n                temp += paren_string[j];\n   \
    \         }\n        }\n    }\n    return output;\n}\n\n", "    const result =\
    \ [];\n    let current_str = \"\";\n    let current_depth = 0;\n    for(let i\
    \ = 0; i < paren_string.length; i++){\n        if(paren_string[i] === '('){\n\
    \            current_depth += 1;\n            current_str += '(';\n        }\n\
    \        else if(paren_string[i] === ')'){\n            current_depth -= 1;\n\
    \            current_str += ')';\n            if(current_depth === 0){\n     \
    \           result.push(current_str);\n                current_str = \"\";\n \
    \           }\n        }\n    }\n    return result;\n}\n", "    var new_string\
    \ = paren_string.replace(/\\s/g, \"\");\n    var results = [];\n    var push_string\
    \ = '';\n    var index = 0;\n    var count = 0;\n    while(index < new_string.length){\n\
    \        if(new_string[index] == '('){\n            count++;\n            push_string\
    \ += new_string[index];\n        }\n        else if(new_string[index] == ')'){\n\
    \            count--;\n            push_string += new_string[index];\n       \
    \ }\n        if(count == 0){\n            results.push(push_string);\n       \
    \     push_string = '';\n        }\n        index++;\n    }\n    return results;\n\
    }", "    const result = [];\n    let temp = '';\n    let counter = 0;\n    for\
    \ (let i = 0; i < paren_string.length; i++) {\n        if (paren_string[i] ===\
    \ '(') {\n            counter++;\n        } else if (paren_string[i] === ')')\
    \ {\n            counter--;\n        }\n        temp += paren_string[i];\n   \
    \     if (counter === 0) {\n            result.push(temp);\n            temp =\
    \ '';\n        }\n    }\n    return result;\n}\n", "    let paren_arr = []\n \
    \   let temp_arr = []\n    let counter = 0\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            counter++\n       \
    \     temp_arr.push(paren_string[i])\n        } else if(paren_string[i] === ')'){\n\
    \            counter--\n            temp_arr.push(paren_string[i])\n        }\
    \ else if(paren_string[i] === ' '){\n            if(counter === 0){\n        \
    \        paren_arr.push(temp_arr.join(''))\n                temp_arr = []\n  \
    \          } else {\n                temp_arr.push(paren_string[i])\n        \
    \    }\n        }\n    }\n    return paren_arr\n}\n", "    let counter = 0;\n\
    \    let arr = [];\n    let groups = [];\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === \"(\"){\n            counter++;\n    \
    \    }\n        if(paren_string[i] === \")\"){\n            counter--;\n     \
    \   }\n        arr.push(paren_string[i]);\n        if(counter === 0){\n      \
    \      groups.push(arr.join(\"\"));\n            arr = [];\n        }\n    }\n\
    \    return groups;\n}\n", "    const stack = []\n    const output = []\n    let\
    \ last_index = 0\n    let current_string = ''\n    paren_string.split('').forEach((element,\
    \ index) => {\n        if (element === '(') {\n            stack.push(index)\n\
    \        } else if (element === ')') {\n            if (stack.length === 0) {\n\
    \                throw 'Error: Too many closing parens'\n            }\n     \
    \       stack.pop()\n            if (stack.length === 0) {\n                output.push(paren_string.slice(last_index,\
    \ index + 1))\n                last_index = index + 1\n            }\n       \
    \ }\n    })\n    if (stack.length > 0) {\n        throw 'Error: Not enough closing\
    \ parens'\n    }\n    return output\n}\n\n", "  var output = [];\n  var temp =\
    \ \"\";\n  var start_paren = false;\n  var end_paren = false;\n  for(var i = 0;\
    \ i < paren_string.length; i++){\n    if(paren_string[i] == \"(\"){\n      start_paren\
    \ = true;\n    }\n    if(paren_string[i] == \")\"){\n      end_paren = true;\n\
    \    }\n    if(start_paren == true && end_paren == false){\n      temp += paren_string[i];\n\
    \    }\n    if(start_paren == true && end_paren == true){\n      temp += paren_string[i];\n\
    \      output.push(temp);\n      temp = \"\";\n      start_paren = false;\n  \
    \    end_paren = false;\n    }\n  }\n  return output;\n}", "    const groups =\
    \ [];\n    let temp = \"\";\n    let stack = 0;\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === \"(\") {\n            if(stack === 0)\
    \ {\n                temp = \"\";\n            }\n            stack++;\n     \
    \   }\n        if(paren_string[i] === \")\") {\n            stack--;\n       \
    \     if(stack === 0) {\n                groups.push(temp);\n            }\n \
    \       }\n        if(stack > 0) {\n            temp += paren_string[i];\n   \
    \     }\n    }\n    return groups;\n}", "    // Your Code Here\n    var group='';\n\
    \    var group_list=[];\n    var counter=0;\n    for(var i=0;i<paren_string.length;i++){\n\
    \        if(paren_string[i]==='('){\n            counter++;\n        }\n     \
    \   if(paren_string[i]===')'){\n            counter--;\n        }\n        if(counter===0\
    \ && paren_string[i]!==' '){\n            group+=paren_string[i];\n          \
    \  group_list.push(group);\n            group='';\n        }\n        else if(paren_string[i]!=='\
    \ '){\n            group+=paren_string[i];\n        }\n    }\n    return group_list;\n\
    }", "    var string = \"\"\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] !== \" \"){\n            string += paren_string[i]\n\
    \        }\n    }\n    var paren_group = []\n    var start = 0\n    var end =\
    \ 0\n    var open = 0\n    var close = 0\n    for(var i = 0; i < string.length;\
    \ i++){\n        if(string[i] === \"(\"){\n            open += 1\n        }\n\
    \        if(string[i] === \")\"){\n            close += 1\n        }\n       \
    \ if(open === close){\n            end = i\n            paren_group.push(string.slice(start,\
    \ end + 1))\n            start = end + 1\n            open = 0\n            close\
    \ = 0\n        }\n    }\n    return paren_group\n}\n", "  var arr = [];\n  var\
    \ temp = \"\";\n  var counter = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == \"(\"){\n      counter++;\n    }else if(paren_string[i]\
    \ == \")\"){\n      counter--;\n    }\n    if(counter == 0 && temp != \"\"){\n\
    \      arr.push(temp);\n      temp = \"\";\n    }else{\n      temp += paren_string[i];\n\
    \    }\n  }\n  return arr;\n}", "    var strArr = paren_string.split('')\n   \
    \ var count = 0\n    var result = []\n    var temp = ''\n    for(var i = 0; i\
    \ < strArr.length; i++){\n        if(strArr[i] === '('){\n            count ++\n\
    \        }else if(strArr[i] === ')'){\n            count --\n        }\n     \
    \   temp += strArr[i]\n        if(count === 0){\n            result.push(temp)\n\
    \            temp = ''\n        }\n    }\n    return result\n}\n", "\tlet stack\
    \ = [];\n\tlet result = [];\n\tlet start = 0;\n\tfor(let i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] === \"(\"){\n\t\t\tstack.push(paren_string[i]);\n\
    \t\t}else if(paren_string[i] === \")\"){\n\t\t\tstack.pop();\n\t\t\tif(stack.length\
    \ === 0){\n\t\t\t\tresult.push(paren_string.slice(start, i+1));\n\t\t\t\tstart\
    \ = i+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "  var arr = [], count\
    \ = 0, str = '';\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ === '('){\n      count++;\n      str += paren_string[i];\n    }\n    else if(paren_string[i]\
    \ === ')'){\n      count--;\n      str += paren_string[i];\n    }\n    else {\n\
    \      str += paren_string[i];\n    }\n    if(count === 0){\n      arr.push(str);\n\
    \      str = '';\n    }\n  }\n  return arr;\n}", "  // Your code here\n}\n", " \
    \   let balanced_groups = [];\n    let paren_stack = [];\n    let start_idx =\
    \ -1;\n    for(let i = 0; i < paren_string.length; i++){\n        const char =\
    \ paren_string[i];\n        if(char === '('){\n            if(paren_stack.length\
    \ === 0){\n                start_idx = i;\n            }\n            paren_stack.push(char);\n\
    \        }\n        else if(char === ')'){\n            paren_stack.pop();\n \
    \           if(paren_stack.length === 0){\n                balanced_groups.push(paren_string.slice(start_idx,\
    \ i + 1));\n            }\n        }\n    }\n    return balanced_groups;\n}\n\n\
    module.exports = {\n    is_balanced_paren,\n    separate_paren_groups\n};", "\t\
    let open_parens = [];\n\tlet paren_groups = [];\n\tfor(let i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] === '('){\n\t\t\topen_parens.push(i);\n\t\t}\n\
    \t\telse if(paren_string[i] === ')'){\n\t\t\tif(open_parens.length === 0){\n\t\
    \t\t\tthrow new Error('cannot close paren, no open parens');\n\t\t\t}\n\t\t\t\
    let paren_group = paren_string.slice(open_parens.pop(), i + 1);\n\t\t\tparen_groups.push(paren_group);\n\
    \t\t}\n\t}\n\tif(open_parens.length > 0){\n\t\tthrow new Error('not all parens\
    \ closed');\n\t}\n\treturn paren_groups;\n}", "    var paren_groups = []\n   \
    \ //your code here\n    var groups = paren_string.split(\" \").join(\"\");\n \
    \   var count = 0;\n    var paren = \"\";\n    for (var i = 0; i < groups.length;\
    \ i++) {\n        if (groups[i] == \"(\") {\n            count++;\n          \
    \  paren += groups[i];\n        }\n        else if (groups[i] == \")\") {\n  \
    \          count--;\n            paren += groups[i];\n        }\n        if (count\
    \ == 0) {\n            paren_groups.push(paren);\n            paren = \"\";\n\
    \        }\n    }\n    return paren_groups;\n}", "    let result = [];\n    let\
    \ count = 0;\n    let temp_string = '';\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            count++;\n        }\n\
    \        if(paren_string[i] === ')'){\n            count--;\n        }\n     \
    \   if(paren_string[i] !== ' '){\n            temp_string += paren_string[i];\n\
    \        }\n        if(count === 0 && temp_string.length > 0){\n            result.push(temp_string);\n\
    \            temp_string = '';\n        }\n    }\n    return result;\n}\n", " \
    \   let ret = [];\n    let t_str = paren_string.replace(/\\s/g, '');\n    for(i\
    \ = 0; i < t_str.length;){\n        if(t_str[i] === '('){\n            let count\
    \ = 1;\n            let s_count = i;\n            while(count > 0){\n        \
    \        s_count++;\n                if(t_str[s_count] === '('){\n           \
    \         count++\n                }\n                else if(t_str[s_count] ===\
    \ ')'){\n                    count--\n                }\n            }\n     \
    \       ret.push(t_str.slice(i, s_count + 1));\n            i = s_count + 1;\n\
    \        }\n        else{\n            i++;\n        }\n    }\n    return ret;\n\
    }", "    var temp = paren_string.replace(/\\s/g, '');\n    var result = [];\n\
    \    var counter = 0;\n    var current = '';\n    for(var i = 0; i < temp.length;\
    \ i++){\n        if(temp[i] === '('){\n            counter++;\n        }\n   \
    \     if(temp[i] === ')'){\n            counter--;\n        }\n        current\
    \ = current + temp[i];\n        if(counter === 0){\n            result.push(current);\n\
    \            current = '';\n        }\n    }\n    return result;\n}\n", "  var\
    \ filtered_string = paren_string.replace(/ /g, \"\");\n  var paren_groups = [];\n\
    \  var start_index = 0;\n  var end_index = 0;\n  var group_start_flag = false;\n\
    \  var group_end_flag = false;\n  while (end_index < filtered_string.length){\n\
    \    if (filtered_string[end_index] === \"(\"){\n      if (group_start_flag ===\
    \ false){\n        start_index = end_index;\n        group_start_flag = true;\n\
    \      }\n    }\n    if (filtered_string[end_index] === \")\"){\n      if (group_start_flag\
    \ === true){\n        paren_groups.push(filtered_string.slice(start_index, end_index\
    \ + 1));\n        group_start_flag = false;\n      }\n    }\n    end_index++;\n\
    \  }\n  return paren_groups;\n}", "    let output = [];\n    let i = 0;\n    let\
    \ str = '';\n    //O(n)\n    while(i < paren_string.length){\n        if(paren_string[i]\
    \ === ' '){\n            i++;\n            continue;\n        }\n        if(paren_string[i]\
    \ === '('){\n            i++;\n            while(paren_string[i] !== ')'){\n \
    \               str += paren_string[i];\n                i++;\n            }\n\
    \            i++;\n            output.push(str);\n            str = '';\n    \
    \    }\n    }\n    return output;\n}\n", "    return [];\n}\n\n", "  var str_copy\
    \ = paren_string.replace(/\\s/g, '');\n  var groups = [];\n  var group = \"\"\
    ;\n  var open_parens = 0;\n  for (var i = 0; i < str_copy.length; i++){\n    group\
    \ += str_copy[i];\n    if (str_copy[i] === \"(\"){\n      open_parens++;\n   \
    \ }\n    else if (str_copy[i] === \")\"){\n      open_parens--;\n    }\n    if\
    \ (open_parens === 0){\n      groups.push(group);\n      group = \"\";\n    }\n\
    \  }\n  return groups;\n}\n", "  var paren_groups = [];\n  var paren_stack = [];\n\
    \  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i] === \"\
    (\"){\n      paren_stack.push(paren_string[i]);\n    } else if(paren_string[i]\
    \ === \")\"){\n      paren_stack.pop();\n    }\n    if(paren_stack.length ===\
    \ 0){\n      paren_groups.push(paren_string.slice(0, i+1));\n      paren_string\
    \ = paren_string.slice(i+1);\n      i = 0;\n    }\n  }\n  return paren_groups;\n\
    }\n", "    let result = [];\n    let stack = [];\n    let curString = '';\n  \
    \  for(let i = 0; i < paren_string.length; i++){\n        let curChar = paren_string[i];\n\
    \        //We found a '(', push it to stack\n        if(curChar === '('){\n  \
    \          stack.push(curChar);\n        }\n        //We found a ')', pop\n  \
    \      else if(curChar === ')'){\n            //Check if stack is empty. If so,\
    \ we have a single ')' without a corresponding '('.\n            //Otherwise,\
    \ pop the stack and add the ')' to curString\n            if(stack.length > 0){\n\
    \                stack.pop();\n                curString += curChar;\n       \
    \     }\n            else{\n                return [];\n            }\n      \
    \  }\n        //If we see a space, do nothing\n        else if(curChar === ' '){\n\
    \            continue;\n        }\n        //Otherwise, we found a char. If stack\
    \ is empty, that means we are out of a group.\n        //Add curString to result\
    \ and reset curString\n        else{\n            if(stack.length === 0){\n  \
    \              result.push(curString);\n                curString = '';\n    \
    \        }\n            //Otherwise, we are in a group. Add the char to curString\n\
    \            else{\n                curString += curChar;\n            }\n   \
    \     }\n    }\n    //After we finish iterating through the string, check if stack\
    \ is empty. If not, we have unbalanced parens\n    if(stack.length > 0){\n   \
    \     return [];\n    }\n    //Also check if curString is empty. If not, we have\
    \ a group at the end of the string.\n    if(curString.length > 0){\n        result.push(curString);\n\
    \    }\n    return result;\n}", "\tif (paren_string.length == 0) {\n\t\tconsole.log(\"\
    empty string\");\n\t\treturn [];\n\t}\n\tvar stack = [];\n\tvar parens = paren_string.split(\"\
    \");\n\tvar result = [];\n\tvar cur_string = \"\";\n\tfor (var i = 0; i < parens.length;\
    \ i++) {\n\t\t//ignore spaces\n\t\tif (parens[i] == \" \") {\n\t\t\tcontinue;\n\
    \t\t}\n\t\t//push opening parentheses onto stack\n\t\tif (parens[i] == \"(\")\
    \ {\n\t\t\tstack.push(parens[i]);\n\t\t\tcur_string += parens[i];\n\t\t}\n\t\t\
    //pop closing parentheses off stack\n\t\telse if (parens[i] == \")\") {\n\t\t\t\
    if (stack.length == 0) {\n\t\t\t\tconsole.log(\"invalid paren grouping\");\n\t\
    \t\t\treturn null;\n\t\t\t}\n\t\t\tstack.pop();\n\t\t\tcur_string += parens[i];\n\
    \t\t}\n\t\t//add to current string if not parentheses\n\t\telse {\n\t\t\tcur_string\
    \ += parens[i];\n\t\t}\n\t\t//push current string onto result array if stack is\
    \ empty\n\t\tif (stack.length == 0) {\n\t\t\tresult.push(cur_string);\n\t\t\t\
    cur_string = \"\";\n\t\t}\n\t}\n\treturn result;\n}\n\nvar paren_string = \"()(())()\"\
    ;", "    let result = [];\n    let open = 0;\n    let temp = \"\";\n    for(let\
    \ i = 0; i < paren_string.length; i++){\n        let char = paren_string[i];\n\
    \        if(char === \"(\"){\n            open++;\n            temp += char;\n\
    \        }else if(char === \")\"){\n            open--;\n            temp += char;\n\
    \        }\n        if(open === 0 && temp.length > 0){\n            result.push(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\n\n", "  var\
    \ parenList = [];\n  var parenString = \"\";\n  var parens = 0;\n  for(var i =\
    \ 0; i < paren_string.length; i++){\n    if(paren_string[i] === \"(\"){\n    \
    \  parens++;\n      parenString += paren_string[i];\n    }else if(paren_string[i]\
    \ === \")\"){\n      parens--;\n      parenString += paren_string[i];\n    }else\
    \ if(paren_string[i] === \" \"){\n      continue;\n    }else{\n      parenString\
    \ += paren_string[i];\n    }\n    if(parens === 0){\n      parenList.push(parenString);\n\
    \      parenString = \"\";\n    }\n  }\n  return parenList;\n}\n", "    var result\
    \ = [];\n    var last_balanced_index = 0;\n    var count = 0;\n    for(var i =\
    \ 0; i < paren_string.length; i++){\n        if(paren_string[i] == \"(\"){\n \
    \           count++;\n        }\n        else if(paren_string[i] == \")\"){\n\
    \            count--;\n        }\n        if(count == 0){\n            result.push(paren_string.substring(last_balanced_index,\
    \ i+1));\n            last_balanced_index = i+1;\n        }\n    }\n    return\
    \ result;\n}\n", "    var strArray = [],\n        open = 0,\n        start = 0,\n\
    \        len = paren_string.length;\n    for (var i = 0; i < len; i++) {\n   \
    \     if (paren_string[i] === '(') {\n            if (open === 0) start = i;\n\
    \            open++;\n        } else if (paren_string[i] === ')') {\n        \
    \    open--;\n            if (open === 0) strArray.push(paren_string.substring(start,\
    \ i + 1));\n        }\n    }\n    return strArray;\n}\n", "    var parens_only\
    \ = paren_string.replace(/\\s/g,'');\n    var groups = [];\n    var start = 0;\n\
    \    var end = 0;\n    while(end < parens_only.length) {\n        if(parens_only[end]\
    \ === '(') {\n            start = end;\n        }\n        if(parens_only[end]\
    \ === ')') {\n            end++;\n            groups.push(parens_only.slice(start,\
    \ end));\n        }\n        end++;\n    }\n    return groups;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
