{
  "name": "mbpp_291_count_no_of_ways",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\t\n*/\nlong count_no_of_ways(long n, long k) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = count_no_of_ways;\n\n    assert(candidate(2L, 4L) == 16L);\n    assert(candidate(3L, 2L) == 6L);\n    assert(candidate(4L, 4L) == 228L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_count = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = diff_color_counts * (k - 1);\n\t\tsame_color_counts = total_count - diff_color_counts;\n\t\ttotal_count = diff_color_counts + same_color_counts;\n\t}\n\treturn total_count;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\tlong total_count = diff_color_count + same_color_count;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = total_count * (k - 1);\n\t\ttotal_count = diff_color_count + same_color_count;\n\t}\n\treturn total_count;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_count = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = total_count * (k - 1);\n\t\ttotal_count = diff_color_counts + same_color_counts;\n\t}\n\treturn total_count;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // table[i] will store count of solutions for i posts and k colors \n    long table[] = new long[n + 1]; \n    table[0] = 0; \n    table[1] = k; \n    table[2] = k + k * (k - 1); \n  \n    // Fill rest of the entries in table using recursive \n    // formula \n    for (long i = 3; i <= n; i++) \n        table[i] = (k - 1) * (table[i - 1] + table[i - 2]); \n  \n    return table[n]; \n} ",
    "{\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{\n\tlong same = 0, diff = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n+1][k+1]; \n\t\n\t// There are k ways to color first post (there is only one post). \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; \n\t\n\t// There are 0 ways for other posts to violate (the rules). \n\tfor (long i = 2; i <= n; i++) \n\t\tdp[i][0] = 0; \n\t\n\t// Fill rest of the entries in table using recursive relation \n\t// same[i][c] = diff[i-1][c-1] + diff[i-1][c] \n\t// diff[i][c] = sum(same[i-1][k]) + sum(diff[i-1][k]) \n\t//\t\t\t\t- same[i-1][c] \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long c = 1; c <= k; c++) \n\t\t{ \n\t\t\t// Find the ways to color current post same as color c + \n\t\t\t// previous post not colored same as c. \n\t\t\tlong same = dp[i-1][c-1]; \n\t\t\t\n\t\t\t// Find the ways to color current post not same as \n\t\t\t// color c + previous post colored same as c. \n\t\t\tlong diff = (dp[i-1][k] - dp[i-1][c-1]); \n\t\t\t\n\t\t\t// total count is sum of ways to color current post \n\t\t\t// same as c and not same as c. \n\t\t\tdp[i][c] = (same + diff) % 1000000007; \n\t\t} \n\t} \n\t\n\tlong ans = 0; \n\tfor (long c = 1; c <= k; c++) \n\t\tans = (ans + dp[n][c]) % 1000000007; \n\t\n\treturn ans; \n",
    "{\n\tlong same = 0, diff = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0th post \n    dp[0] = k; \n  \n    // There are 0 ways for single post to \n    // violate (same color_count) property \n    dp[1] = k; \n  \n    // There are 0 ways for 2 posts to have same \n    // colors \n    dp[2] = k * (k - 1); \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{\n\tif (n == 0) return 0;\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn diff_color_counts + same_color_counts;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same, diff; ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n + 1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn (diff + same);\n}",
    "{ \n\tlong same = 0, diff = k; \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tlong temp = diff; \n\t\tdiff = (same + diff) * (k-1); \n\t\tsame = temp; \n\t} \n\treturn same + diff; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong[] dp = new long[n + 1]; \n\t// There are k ways to paint 0th post \n\tdp[0] = k; \n\t// There are 0 ways for single post to paint \n\t// same color as previous one \n\tdp[1] = k; \n\t// There are 0 ways for 2 posts to paint same \n\t// color as previous one \n\tdp[2] = k * (k - 1); \n\t// Fill for 3 to n posts \n\tfor (long i = 3; i <= n; i++) \n\t\tdp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n\treturn dp[n]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (int i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_count = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = diff_color_counts * (k - 1);\n\t\tsame_color_counts = total_count - diff_color_counts;\n\t\ttotal_count = diff_color_counts + same_color_counts;\n\t}\n\treturn total_count;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (int i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn (diff + same);\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_counts = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = total_counts * (k - 1);\n\t\ttotal_counts = diff_color_counts + same_color_counts;\n\t}\n\treturn total_counts;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong[] dp = new long[n + 1]; ",
    "{\n\tif (n == 1) return k;\n\tif (n == 2) return k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k-1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n+1][k+1]; \n\t\n\t// There are k ways to color first post \n\tfor (long i = 1; i <= k; i++) \n\t\tdp[1][i] = i; ",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // table[i] will store count of solutions for i posts and k colors \n    long table[n+1]; \n    memset(table, 0, sizeof(table)); \n  \n    // Initialize first column with all 1s. There is only one way to paint 0'th post with any color. \n    for (long i = 0; i <= n; i++) \n        table[i] = 0; \n  \n    // Initialize first row with all 1s. There is only one way to paint n'th post with any color. \n    for (long j=0; j<=k; j++) \n        table[0] = 0; \n  \n    // Fill entries in table using recursive relation \n    // table[i] = (table[i - 1] * (k - 1)) + (table[i - 2] * (k - 1)); \n    for (long i = 1; i <= n; i++) \n    { \n        for (long j = 1; j <= k; j++) \n        { \n            // There are two cases for every post: \n            // a) Previous post has same color, so we can't use same color \n            // b) Previous post has different color \n            long diffColorCount = table[i-1] * (k-1); \n            long sameColorCount = table[i-2] * (k-1); \n  \n            // Total count is sum of both cases \n            table[i] += (diffColorCount + sameColorCount); \n        } \n    } \n  \n    return table[n]; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\t\n\tfor (long i = 3; i <= n; ++i) {\n\t\tlong temp = diff_color_count;\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = temp;\n\t}\n\t\n\treturn diff_color_count + same_color_count;\n}",
    "{\n\tlong same = 0;\n\tlong diff = k;\n\tlong total = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tlong same = 0, diff = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong[] dp = new long[n+1]; \n\t\n\t// There are k ways to paint the first post \n\tdp[1] = k; \n\t\n\t// There are 0 ways for single post to paint \n\t// the same color as previous post \n\tlong same = 0, diff = k; \n\t\n\t// Fill for 2 posts onwards \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\t// Current same is same as previous diff \n\t\tsame = diff; \n\t\t\n\t\t// We always have k-1 choices for next post \n\t\tdiff = dp[i-1] * (k-1); \n\t\t\n\t\t// Total choices till i. \n\t\tdp[i] = (same + diff); \n\t} \n\t\n\treturn dp[n]; \n} ",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff_color_count;\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = temp;\n\t}\n\t\n\treturn diff_color_count + same_color_count;\n}",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 2; i < n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\telse if (n == 2)\n\t\treturn k * k;\n\telse\n\t{\n\t\tlong same = k;\n\t\tlong diff = k * (k - 1);\n\t\tfor (long i = 3; i <= n; i++)\n\t\t{\n\t\t\tlong temp = diff;\n\t\t\tdiff = (same + diff) * (k - 1);\n\t\t\tsame = temp;\n\t\t}\n\t\treturn same + diff;\n\t}\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    long dp[][] = new long[n+1][k+1]; \n  \n    // There are k ways to color first post (there is only one post). \n    for (long c = 1; c <= k; c++) \n        dp[1][c] = 1; \n  \n    // There are 0 ways for other posts to violate (the problem statement). \n    for (long i = 2; i <= n; i++) \n        dp[i][0] = 0; \n  \n    // Fill rest of the entries in table using recursive relation \n    // described above. \n    for (long i = 2; i <= n; i++) \n    { \n        for (long c = 1; c <= k; c++) \n        { \n            dp[i][c] = (k-1) * (dp[i-1][c-1] + dp[i-1][c]); \n        } \n    } \n  \n    // Return last entry \n    return dp[n][k]; \n} ",
    "{ \n    long same = 0, diff = k; \n  \n    for (int i = 2; i <= n; i++) \n    { \n        long temp = diff; \n        diff = (same + diff) * (k-1); \n        same = temp; \n    } \n  \n    return same + diff; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n+1][k+1]; \n\t\n\t// There are k ways to color first post (there is only \n\t// one post). \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\telse if (n == 2)\n\t\treturn k * k;\n\telse\n\t{\n\t\tlong same = k;\n\t\tlong diff = k * (k - 1);\n\t\tfor (long i = 3; i <= n; i++)\n\t\t{\n\t\t\tlong temp = diff;\n\t\t\tdiff = (same + diff) * (k - 1);\n\t\t\tsame = temp;\n\t\t}\n\t\treturn same + diff;\n\t}\n}",
    "{\n\tif(n == 1) return k;\n\tif(n == 2) return k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(long i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff)*(k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\t// if n == 0 then there is no posts to paint\n\tif (n == 0)\n\t\treturn 0;\n\t\n\t// if n == 1 then there is only one way to paint\n\tif (n == 1)\n\t\treturn k;\n\t\n\t// if n == 2 then there are two ways to paint\n\t// 1. same color\n\t// 2. different color\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\t// if n > 2 then there are two ways to paint\n\t// 1. same color\n\t// 2. different color\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tlong same = 0, diff = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\telse if (n == 2)\n\t\treturn k * k;\n\telse\n\t\treturn k * (k - 1) * pow(k - 2, n - 2);\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; ++i)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\t\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][0] = 0; \n\tfor (long j = 0; j <= k; j++) \n\t\tdp[0][j] = 0; \n\tfor (long i = 1; i <= n; i++) \n\t{ \n\t\tfor (long j = 1; j <= k; j++) \n\t\t{ \n\t\t\t// There are 2 cases, \n\t\t\t// a) Last two posts have same color. \n\t\t\t// b) Last two posts have diff color. \n\t\t\tdp[i][j] = (j * dp[i - 1][j] + (j - 1) * dp[i - 1][j - 1]) % 1000000007; \n\t\t} \n\t} \n\treturn dp[n][k]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; \n\t\n\t// There is only one way to color zero post \n\tfor (long i = 0; i <= k; i++) \n\t\tdp[0][i] = 0; \n\t\n\t// Fill rest of the entries in table using recursive \n\t// formula \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long c = 1; c <= k; c++) \n\t\t{ \n\t\t\tlong temp = (k - 1) * dp[i - 1][c]; \n\t\t\t\n\t\t\t// If current color and previous are same \n\t\t\tif (c == 1) \n\t\t\t\ttemp += dp[i - 1][k]; \n\t\t\telse\n\t\t\t\ttemp += dp[i - 1][c - 1]; \n\t\t\t\n\t\t\tdp[i][c] = temp; \n\t\t} \n\t} \n\t\n\t// Return last entry \n\treturn dp[n][k]; \n} ",
    "{\n\tif (n == 0) return 0;\n\tif (n == 1) return k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tlong total = same + diff;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\t\n\tauto same = k;\n\tauto diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diffColorCounts = k * (k - 1);\n\tlong sameColorCounts = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diffColorCounts;\n\t\tdiffColorCounts = (diffColorCounts + sameColorCounts) * (k - 1);\n\t\tsameColorCounts = temp;\n\t}\n\treturn (diffColorCounts + sameColorCounts);\n}",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_counts = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = diff_color_counts * (k - 1);\n\t\tsame_color_counts = total_counts - diff_color_counts;\n\t\ttotal_counts = diff_color_counts + same_color_counts;\n\t}\n\treturn total_counts;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same = 0, diff = k; ",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    long same = 0, diff = k; \n  \n    for (long i = 2; i <= n; i++) \n    { \n        long temp = diff; \n        diff = (same + diff) * (k-1); \n        same = temp; \n    } \n  \n    return same + diff; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post (there is only one post). \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; \n\t\n\t// There are 0 ways for other posts to violate (the problem statement). \n\tfor (long i = 2; i <= n; i++) \n\t\tdp[i][0] = 0; \n\t\n\t// Fill rest of the entries in table using recursive relation \n\t// described above. \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long c = 1; c <= k; c++) \n\t\t{ \n\t\t\t// Initialize result \n\t\t\tlong ans = 0; \n\t\n\t\t\t// Find ways to color current post using cth color \n\t\t\t// with (i-1)th post colored with one of the (k-1) \n\t\t\t// colors other than cth \n\t\t\tfor (long p = 1; p <= k; p++) \n\t\t\t{ \n\t\t\t\tif (p != c) \n\t\t\t\t\tans += dp[i - 1][p]; \n\t\t\t} \n\t\t\tdp[i][c] = ans; \n\t\t} \n\t} \n\t\n\t// Sum up all the ways to color nth post using any of the \n\t// k colors. \n\tlong ans = 0; \n\tfor (long c = 1; c <= k; c++) \n\t\tans += dp[n][c]; \n\treturn ans; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; ",
    "{\n\tif(n == 1)\n\t\treturn k;\n\telse if(n == 2)\n\t\treturn k * k;\n\telse\n\t{\n\t\tlong same = k;\n\t\tlong diff = k * (k - 1);\n\t\tlong total = same + diff;\n\t\tfor(long i = 3; i <= n; i++)\n\t\t{\n\t\t\tsame = diff;\n\t\t\tdiff = total * (k - 1);\n\t\t\ttotal = same + diff;\n\t\t}\n\t\treturn total;\n\t}\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_count;\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = temp;\n\t}\n\t\n\treturn diff_color_count + same_color_count;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn diff + same;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to color first post \n    dp[1] = k; \n  \n    // There are 0 ways for single post to \n    // violate (same color_count) condition \n    long same = 0, diff = k; \n  \n    // Fill for 2 posts onwards \n    for (long i = 2; i <= n; i++) { \n        // Current same is same as previous diff \n        same = diff; \n  \n        // We always have k-1 choices for next post \n        diff = dp[i - 1] * (k - 1); \n  \n        // Total choices till i. \n        dp[i] = (same + diff); \n    } \n  \n    return dp[n]; \n} ",
    "{ \n\tif (n == 0) \n\t\treturn 0; \n\tif (n == 1) \n\t\treturn k; \n\tlong diffColorCounts = k * (k - 1); \n\tlong sameColorCounts = k; \n\tfor (long i = 2; i < n; i++) \n\t{ \n\t\tlong temp = diffColorCounts; \n\t\tdiffColorCounts = (diffColorCounts + sameColorCounts) * (k - 1); \n\t\tsameColorCounts = temp; \n\t} \n\treturn diffColorCounts + sameColorCounts; \n} ",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n+1][k+1]; \n\t\n\t// There are k ways to color first post \n\tfor (long i = 1; i <= k; i++) \n\t\tdp[1][i] = i; ",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same = 0, diff = k; ",
    "{\n\tlong same = 0, diff = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 0) \n\t{\n\t\treturn 0;\n\t}\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\t// There are k ways to color first post\n\tlong same = k;\n\t// There are k-1 ways to color first post different from the second post\n\tlong diff = k * (k - 1);\n\t\n\t// Fill for 2 posts onwards\n\tfor (long i = 2; i < n; i++) \n\t{\n\t\t// Current same is same as previous diff\n\t\tlong temp = diff;\n\t\t\n\t\t// We always have k-1 choices for next post\n\t\tdiff = (same + diff) * (k - 1);\n\t\t\n\t\t// And the number of ways next post has same color as previous is same\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 0) return 0;\n\tif (n == 1) return k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tlong same = 0;\n\tlong diff = k;\n\tlong total = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\tlong same = 0, diff = k; \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tlong temp = diff; \n\t\tdiff = (same + diff) * (k - 1); \n\t\tsame = temp; \n\t} \n\treturn (same + diff); \n} ",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // One extra row and column are used for simpilicity \n    // (Number of columns is equal to number of colors \n    // of the fence plus 1) \n    long[][] dp = new long[n+1][k+1]; \n  \n    // There are k ways to color first post \n    for (long c = 1; c <= k; c++) \n        dp[1][c] = 1; \n  \n    // There is only one way to color 0'th post i.e., \n    // do not color it \n    for (long i = 0; i <= n; i++) \n        dp[i][0] = 0; \n  \n    // Fill rest of the entries in table using recursive \n    // formula \n    for (long i = 2; i <= n; i++) \n        for (long c = 1; c <= k; c++) \n            dp[i][c] = (dp[i-1][c-1] + dp[i-1][c]) % 1000000007; \n  \n    // There will be n*k entries in table. \n    // Out of these n*k entries, exactly n entries \n    // will have same value. \n    return n*dp[n][k]; \n} ",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn diff + same;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; ",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif(n == 0) \n\t\treturn 0;\n\tif(n == 1) \n\t\treturn k;\n\tif(n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor(long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n\tlong same = 0, diff = k; \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tlong temp = diff; \n\t\tdiff = (same + diff) * (k - 1); \n\t\tsame = temp; \n\t} \n\treturn same + diff; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; \n\t\n\t// There are 0 ways for any other post to \n\t// violate (same color_count) condition \n\tfor (long i = 2; i <= n; i++) \n\t\tdp[i][1] = dp[i][k] = 0; \n\t\n\t// Fill rest of the entries in table using \n\t// recursive formula \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long c = 2; c <= k; c++) \n\t\t{ \n\t\t\tdp[i][c] = (k - 1) * (dp[i - 1][c] + \n\t\t\t\t\t\t\t\tdp[i - 1][c - 1]); \n\t\t} \n\t} \n\t\n\t// required number of ways \n\tlong res = 0; \n\tfor (long c = 1; c <= k; c++) \n\t\tres += dp[n][c]; \n\treturn res; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_counts = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = total_counts * (k - 1);\n\t\tsame_color_counts = diff_color_counts;\n\t\ttotal_counts = diff_color_counts + same_color_counts;\n\t}\n\treturn total_counts;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; ",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\tlong same = 0, diff = k; \n\tfor (int i = 2; i <= n; i++) \n\t{ \n\t\tlong temp = diff; \n\t\tdiff = (same + diff) * (k-1); \n\t\tsame = temp; \n\t} \n\treturn same + diff; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same, diff; ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong[] dp = new long[n + 1]; ",
    "{\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post (there is only one post). \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; ",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n+1][k+1]; \n\t\n\t// There are k ways to color first post (there is only one post). \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; \n\t\n\t// There are 0 ways for other posts to violate (the rules). \n\tfor (long i = 2; i <= n; i++) \n\t\tdp[i][0] = 0; \n\t\n\t// Fill rest of the entries in table using recursive relation \n\t// described above. \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long c = 1; c <= k; c++) \n\t\t{ \n\t\t\tlong temp = dp[i-1][c] * (k-1); \n\t\t\t\n\t\t\t// If current color and previous are same, then we \n\t\t\t// should exclude previous color as it is already \n\t\t\t// counted in the value of dp[i-1][c] \n\t\t\tif (c == 1) \n\t\t\t\tdp[i][c] = temp; \n\t\t\telse\n\t\t\t\tdp[i][c] = temp + dp[i-1][c-1] * (k-1); \n\t\t} \n\t} \n\t\n\t// Return the ways when we color the fence with k colors \n\treturn dp[n][k]; \n} ",
    "{ \n\tlong same = 0, diff = k; \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tlong temp = diff; \n\t\tdiff = (same + diff) * (k-1); \n\t\tsame = temp; \n\t} \n\treturn same + diff; \n} ",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long[] dp = new long[n + 1]; \n    dp[0] = 0; \n    dp[1] = k; \n    dp[2] = k + k * (k - 1); \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} \n  \n// Driver code ",
    "{\n\tif(n == 1) return k;\n\tif(n == 2) return k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(int i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff)*(k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n + 1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\t\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn diff + same;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts \n\tlong dp[n + 1]; ",
    "{\n\tlong same = 0, diff = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tlong same = 0;\n\tlong diff = k;\n\tlong total = k;\n\t\n\tfor(int i = 2; i <= n; i++) \n\t{\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) {\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same, diff; ",
    "{\n\tif(n == 1) return k;\n\tif(n == 2) return k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff)*(k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn (same + diff);\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\tlong total_count = diff_color_count + same_color_count;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = total_count * (k - 1);\n\t\ttotal_count = diff_color_count + same_color_count;\n\t}\n\treturn total_count;\n}",
    "{\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff)*(k-1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diffColorCounts = k * (k - 1);\n\tlong sameColorCounts = k;\n\tlong totalCount = diffColorCounts + sameColorCounts;\n\tfor (int i = 3; i <= n; i++) \n\t{\n\t\tdiffColorCounts = (diffColorCounts + sameColorCounts) * (k - 1);\n\t\tsameColorCounts = totalCount * (k - 1);\n\t\ttotalCount = (diffColorCounts + sameColorCounts);\n\t}\n\treturn totalCount;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// There are k ways to color first post \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; ",
    "{\n\tlong same = 0, diff = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{ \n\tlong same = 0, diff = k; \n\tfor (int i = 2; i <= n; i++) \n\t{ \n\t\tlong temp = diff; \n\t\tdiff = (same + diff) * (k - 1); \n\t\tsame = temp; \n\t} \n\treturn same + diff; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\tlong same = 0, diff = k; \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tlong temp = diff; \n\t\tdiff = (same + diff) * (k - 1); \n\t\tsame = temp; \n\t} \n\treturn same + diff; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n + 1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n+1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0 posts \n    dp[0] = k; \n  \n    // There are 0 ways for 1 post with k colors \n    dp[1] = k; \n  \n    // There are k*k ways for 2 posts with k colors \n    dp[2] = k*k; \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i-1] + dp[i-2]); \n  \n    return dp[n]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; ",
    "{ \n\t// Create a table to store results of subproblems.  \n\t// One extra row and column are used for simplicity  \n\t// (Number of posts is directly used as row index and  \n\t// number of colors is directly used as column index).  \n\t// The entries in 0th row and 0th column are never used. \n\tlong[][] dp = new long[n + 1][k + 1]; \n\t\n\t// Initialize first column of dp table \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][1] = 1; \n\t\n\t// Initialize first row of dp table \n\tfor (long j = 0; j <= k; j++) \n\t\tdp[1][j] = j; \n\t\n\t// Fill entries in dp table using recursive relation \n\t// dp[i][j] = dp[i][j-1] + dp[i-1][k-1] + dp[i-1][k-2] + ... + dp[i-1][0] \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long j = 2; j <= k; j++) \n\t\t{ \n\t\t\tdp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1]) % 1000000007; \n\t\t\t\n\t\t\t// Fill rest of the entries in dp[i][j] \n\t\t\tfor (long p = j - 2; p >= 1; p--) \n\t\t\t\tdp[i][j] = (dp[i][j] + dp[i - 1][p]) % 1000000007; \n\t\t} \n\t} \n\t\n\t// Return the result \n\treturn dp[n][k]; \n} ",
    "{ \n\t// Create a table to store results of subproblems \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same, diff; ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color = k * (k - 1);\n\tlong same_color = k;\n\t\n\tlong total = diff_color + same_color;\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tsame_color = diff_color;\n\t\tdiff_color = total * (k - 1);\n\t\ttotal = diff_color + same_color;\n\t}\n\t\n\treturn total;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); \n\t\n\t// There are k-ways to color first post \n\tdp[1] = k; \n\t\n\t// There are 0 ways for single post to \n\t// violate (same color_count) condition \n\tlong same = 0, diff = k; \n\t\n\t// Fill for 2 posts onwards \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\t// Current same is same as previous diff \n\t\tsame = diff; \n\t\t\n\t\t// We always have k-1 choices for next post \n\t\tdiff = dp[i-1] * (k-1); \n\t\t\n\t\t// Total choices till i. \n\t\tdp[i] = (same + diff); \n\t} \n\t\n\treturn dp[n]; \n} ",
    "{\n\tlong same = 0, diff = k;\n\tlong total = same + diff;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{ \n\t// Create a table to store results of subproblems.  \n\t// One extra row and column are used for simplicity  \n\t// (Number of posts is directly used as row index and number of colors as column index).  \n\tlong dp[][] = new long[n + 1][k + 1]; \n\t\n\t// Initialize first column of dp table \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][1] = 1; \n\t\n\t// Initialize first row of dp table \n\tfor (long j = 0; j <= k; j++) \n\t\tdp[1][j] = j; \n\t\n\t// Fill entries in dp table using recursive relation \n\t// dp[i][j] = dp[i][j-1] + dp[i-1][k-1] + dp[i-1][k-2] + ... + dp[i-1][0] \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long j = 2; j <= k; j++) \n\t\t{ \n\t\t\tdp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1]) % 1000000007; \n\t\t\tfor (long g = 2; g < j; g++) \n\t\t\t\tdp[i][j] = (dp[i][j] + dp[i - 1][j - g]) % 1000000007; \n\t\t} \n\t} \n\t\n\treturn dp[n][k]; \n} ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tlong same = 0;\n\tlong diff = k;\n\tlong total = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_counts = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tdiff_color_counts = diff_color_counts * (k - 1);\n\t\tsame_color_counts = total_counts - diff_color_counts;\n\t\ttotal_counts = diff_color_counts + same_color_counts;\n\t}\n\treturn total_counts;\n}"
  ]
}