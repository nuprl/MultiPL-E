{
  "name": "mbpp_238_number_of_substrings",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a dthon function to count the number of non-empty substrings of a given string.\n\t\n*/\nlong number_of_substrings(string str) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_238_number_of_substrings.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = number_of_substrings;\n\n    assert(candidate(\"abc\") == 6L);\n    assert(candidate(\"abcd\") == 10L);\n    assert(candidate(\"abcde\") == 15L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{ \n    long n = str.length; \n  \n    // substring are n(n+1)/2 \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n\tlong n = str.length(); \n\treturn n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n  \n    // substring are formed by its length \n    // from 1 to n. \n    long result = 0; \n    for (long i = 1; i <= n; i++) \n        result += i; \n  \n    return result; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n  \n    // substring are n(n+1)/2 \n    return (n * (n + 1)) / 2; \n} \n  \n// Driver code ",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n+1]; \n  \n    // Pick starting point \n    for (long i = 0; i < n; i++) \n    { \n        // Pick ending point \n        for (long j = i; j < n; j++) \n        { \n            // Increment count if this is a new \n            // character for this substring \n            long[] sub_count = new long[256]; \n            for (long k = i; k <= j; k++) \n                sub_count[str[k]]++; \n  \n            // If there are more than k unique characters \n            // in current substring, then increment count \n            long num_unique_char = 0; \n            for (long k = 0; k < 256; k++) \n                if (sub_count[k] > 0) \n                    num_unique_char++; \n  \n            if (num_unique_char == j - i + 1) \n                cnt[num_unique_char]++; \n        } \n    } \n  \n    // Summation of all unique characters \n    long sum = 0; \n    for (long i = 1; i <= n; i++) \n        sum += cnt[i] * i; \n  \n    return sum; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length; \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n  \n    // substring are n*(n+1)/2 \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n  \n    // substring are n(n+1)/2 \n    return (n * (n + 1)) / 2; \n} \n  \n// Driver code ",
    "{ \n    long n = str.length(); \n  \n    // substring are n(n+1)/2 \n    return (n * (n + 1)) / 2; \n} "
  ]
}