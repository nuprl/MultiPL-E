{
  "name": "mbpp_229_re_arrange_array",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp43tp7z4z.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp43tp7z4z.__unittest_L42_C1() [0x4281ec]\n??:? void tmp43tp7z4z.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl_6pbmcn.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpl_6pbmcn.__unittest_L38_C1() [0x4281ec]\n??:? void tmpl_6pbmcn.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq21zu8om.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpq21zu8om.__unittest_L42_C1() [0x4281f4]\n??:? void tmpq21zu8om.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8wo9e905.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp8wo9e905.__unittest_L45_C1() [0x4281f4]\n??:? void tmp8wo9e905.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong p = 0;\n\tlong neg = 0;\n\tlong pos = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg] = arr[i];\n\t\t\tneg++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos] = arr[i];\n\t\t\tpos++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg; i++)\n\t{\n\t\tresult[p] = negative[i];\n\t\tp++;\n\t}\n\t\n\tfor (long i = 0; i < pos; i++)\n\t{\n\t\tresult[p] = positive[i];\n\t\tp++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkk_k5r_l.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpkk_k5r_l.__unittest_L45_C1() [0x42816c]\n??:? void tmpkk_k5r_l.__modtest() [0x4283c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tfor(long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor(long i = 0; i < positive_count; i++)\n\t{\n\t\tresult[i + negative_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpiej3p56h.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpiej3p56h.__unittest_L42_C1() [0x428168]\n??:? void tmpiej3p56h.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{ \n\tlong i = 0;\n\tlong j = n - 1;\n\twhile (i < j) \n\t{ \n\t\tif (arr[i] < 0) \n\t\t{ \n\t\t\ti++; \n\t\t\tcontinue; \n\t\t} \n\t\tif (arr[j] >= 0) \n\t\t{ \n\t\t\tj--; \n\t\t\tcontinue; \n\t\t} \n\t\tswap(arr[i], arr[j]); \n\t\ti++; \n\t\tj--; \n\t} \n\treturn arr;\n} \nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmpzf1ho0bj.d(24): Error: undefined identifier `swap`, did you mean template `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzf1ho0bj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tres[neg_index + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppgwa_apy.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmppgwa_apy.__unittest_L42_C1() [0x4281ec]\n??:? void tmppgwa_apy.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = 0; i < positive_count; i++)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqnrx2kjq.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpqnrx2kjq.__unittest_L38_C1() [0x428168]\n??:? void tmpqnrx2kjq.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = neg_count; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - neg_count];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpr01gppsp.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpr01gppsp.__unittest_L38_C1() [0x428168]\n??:? void tmpr01gppsp.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tlong i = 0;\n\tfor (; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tfor (i = 0; i < neg_count; i++)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tfor (i = neg_count; i < n; i++)\n\t{\n\t\tres[i] = pos[i - neg_count];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldd50a13.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42863d]\n??:? void tmpldd50a13.__unittest_L39_C1() [0x428160]\n??:? void tmpldd50a13.__modtest() [0x4283bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b561]\n??:? runModuleUnitTests [0x42c4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\twhile (i < n) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[j] = arr[i];\n\t\t\tj++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < j) \n\t{\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\twhile (i < n) \n\t{\n\t\tresult[i] = positive[i - j];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_x16a322.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x428635]\n??:? void tmp_x16a322.__unittest_L43_C1() [0x428158]\n??:? void tmp_x16a322.__modtest() [0x4283b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b582]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43080d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430799]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b559]\n??:? runModuleUnitTests [0x42c4c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428af8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfricr0uy.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpfricr0uy.__unittest_L41_C1() [0x4281f4]\n??:? void tmpfricr0uy.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; negative_index..n)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnfrnwxh6.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpnfrnwxh6.__unittest_L42_C1() [0x4281e8]\n??:? void tmpnfrnwxh6.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = negative_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpw0actp66.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpw0actp66.__unittest_L42_C1() [0x428168]\n??:? void tmpw0actp66.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate()) [0x428a8f]\n??:? _d_run_main [0x4289fa]\n??:? main [0x4283d7]\n??:? __libc_start_main [0x5d7ba554]\n1/1 unittests FAILED\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tfor(long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor(long i = 0; i < zero_index; i++)\n\t{\n\t\tresult[negative_index + i] = zero[i];\n\t}\n\t\n\tfor(long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[negative_index + zero_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp05t76m0s.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428795]\n??:? void tmp05t76m0s.__unittest_L54_C1() [0x4282b8]\n??:? void tmp05t76m0s.__modtest() [0x428514]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c84f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43096d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e1c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b9]\n??:? runModuleUnitTests [0x42c625]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c58]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebrf5o0z.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpebrf5o0z.__unittest_L42_C1() [0x4281ec]\n??:? void tmpebrf5o0z.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp45mq6a82.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp45mq6a82.__unittest_L42_C1() [0x4281ec]\n??:? void tmp45mq6a82.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp43tp7z4z.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp43tp7z4z.__unittest_L42_C1() [0x4281ec]\n??:? void tmp43tp7z4z.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_count; i++)\n\t{\n\t\tresult[i + negative_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqrotmfq2.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpqrotmfq2.__unittest_L42_C1() [0x428168]\n??:? void tmpqrotmfq2.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] arr_neg = new long[n];\n\tlong[] arr_pos = new long[n];\n\tlong[] arr_res = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(i;0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tarr_neg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarr_pos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i;0..neg_count)\n\t{\n\t\tarr_res[i] = arr_neg[i];\n\t}\n\t\n\tforeach(i;0..pos_count)\n\t{\n\t\tarr_res[neg_count + i] = arr_pos[i];\n\t}\n\t\n\treturn arr_res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfy06x6j3.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpfy06x6j3.__unittest_L42_C1() [0x4281ec]\n??:? void tmpfy06x6j3.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] >= 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu1psc9k9.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpu1psc9k9.__unittest_L42_C1() [0x428168]\n??:? void tmpu1psc9k9.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122886,
      "stdout": "",
      "stderr": "/tmp/tmpfb5eadsz.d(53): Error: expression expected, not `unittest`\n/tmp/tmpfb5eadsz.d(54): Error: found `{` when expecting `]`\n/tmp/tmpfb5eadsz.d(55): Error: semicolon expected, not `alias`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfb5eadsz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < negative_count; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = 0; i < positive_count; i++) \n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnriujtk4.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpnriujtk4.__unittest_L38_C1() [0x428168]\n??:? void tmpnriujtk4.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] ret = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_count)\n\t{\n\t\tret[i] = neg[i];\n\t}\n\t\n\tforeach(long i; 0..pos_count)\n\t{\n\t\tret[neg_count + i] = pos[i];\n\t}\n\t\n\treturn ret;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd935uxek.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpd935uxek.__unittest_L42_C1() [0x4281ec]\n??:? void tmpd935uxek.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] >= 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu1psc9k9.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpu1psc9k9.__unittest_L42_C1() [0x428168]\n??:? void tmpu1psc9k9.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] zero = new long[n];\n\tlong neg_index = 0;\n\tlong pos_index = 0;\n\tlong zero_index = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse if(arr[i] > 0)\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tneg_index = 0;\n\tpos_index = 0;\n\tzero_index = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(neg_index < n)\n\t\t{\n\t\t\tresult[i] = negative[neg_index];\n\t\t\tneg_index++;\n\t\t}\n\t\telse if(pos_index < n)\n\t\t{\n\t\t\tresult[i] = positive[pos_index];\n\t\t\tpos_index++;\n\t\t}\n\t\telse if(zero_index < n)\n\t\t{\n\t\t\tresult[i] = zero[zero_index];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmkz0z9q9.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x4287cd]\n??:? void tmpmkz0z9q9.__unittest_L59_C1() [0x4282f4]\n??:? void tmpmkz0z9q9.__modtest() [0x428550]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c887]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b71a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430931]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6f1]\n??:? runModuleUnitTests [0x42c65d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor(long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor(long i = negative_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdfq6_wdp.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpdfq6_wdp.__unittest_L42_C1() [0x428168]\n??:? void tmpdfq6_wdp.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative_arr = new long[n];\n\tlong[] positive_arr = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative_arr[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive_arr[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative_arr[i];\n\t}\n\t\n\tforeach(long i; 0 .. positive_index)\n\t{\n\t\tresult[negative_index + i] = positive_arr[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj6gmrk7t.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpj6gmrk7t.__unittest_L42_C1() [0x4281ec]\n??:? void tmpj6gmrk7t.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7m3mz3gs.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp7m3mz3gs.__unittest_L42_C1() [0x4281ec]\n??:? void tmp7m3mz3gs.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc4k5nue8.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpc4k5nue8.__unittest_L42_C1() [0x428168]\n??:? void tmpc4k5nue8.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tlong[] neg_res = new long[neg_count];\n\tlong[] pos_res = new long[pos_count];\n\tforeach(i; 0..neg_count)\n\t{\n\t\tneg_res[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tpos_res[i] = pos[i];\n\t}\n\tneg_res ~= pos_res;\n\treturn neg_res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfeu3s_bl.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428715]\n??:? void tmpfeu3s_bl.__unittest_L41_C1() [0x428238]\n??:? void tmpfeu3s_bl.__modtest() [0x428494]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d26b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c0fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431048]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430b25]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c0d5]\n??:? runModuleUnitTests [0x42d041]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428bd8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tresult[i + neg_count] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0lvrvav4.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp0lvrvav4.__unittest_L38_C1() [0x4281f4]\n??:? void tmp0lvrvav4.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0..pos_count)\n\t{\n\t\tresult[neg_count+i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmph6oejazw.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmph6oejazw.__unittest_L42_C1() [0x4281ec]\n??:? void tmph6oejazw.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong i = 0;\n\twhile (i < n) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < neg_index) \n\t{\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < pos_index) \n\t{\n\t\tresult[i + neg_index] = positive[i];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpe3uu80vr.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x42863d]\n??:? void tmpe3uu80vr.__unittest_L44_C1() [0x428160]\n??:? void tmpe3uu80vr.__modtest() [0x4283bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b561]\n??:? runModuleUnitTests [0x42c4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_count; i++)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp49_5r3ps.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp49_5r3ps.__unittest_L42_C1() [0x428168]\n??:? void tmp49_5r3ps.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tlong j = 0;\n\tfor (long i = 0; i < neg_count; i++) \n\t{\n\t\tresult[j] = negative[i];\n\t\tj++;\n\t}\n\tfor (long i = 0; i < pos_count; i++) \n\t{\n\t\tresult[j] = positive[i];\n\t\tj++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplrpkooz3.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmplrpkooz3.__unittest_L41_C1() [0x428168]\n??:? void tmplrpkooz3.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t}\n\tforeach(long i; 0 .. neg_count)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\tforeach(long i; 0 .. pos_count)\n\t{\n\t\tresult[i + neg_count] = pos[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp53a0ywff.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp53a0ywff.__unittest_L38_C1() [0x4281f4]\n??:? void tmp53a0ywff.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\twhile (i < n) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[j] = arr[i];\n\t\t\tj++;\n\t\t} else {\n\t\t\tpositive[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < j) {\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\twhile (i < n) {\n\t\tresult[i] = positive[i - j];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc4akn3an.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x428635]\n??:? void tmpc4akn3an.__unittest_L37_C1() [0x428158]\n??:? void tmpc4akn3an.__modtest() [0x4283b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b582]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43080d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430799]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b559]\n??:? runModuleUnitTests [0x42c4c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428af8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc4k5nue8.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpc4k5nue8.__unittest_L42_C1() [0x428168]\n??:? void tmpc4k5nue8.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong i = 0;\n\t\n\twhile(i < n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\ti++;\n\t}\n\t\n\ti = 0;\n\twhile(i < neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\t\n\ti = 0;\n\twhile(i < pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t\ti++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpeqrvdmvx.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x42863d]\n??:? void tmpeqrvdmvx.__unittest_L48_C1() [0x428160]\n??:? void tmpeqrvdmvx.__modtest() [0x4283bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b561]\n??:? runModuleUnitTests [0x42c4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tforeach(long i; 0 .. negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(long i; 0 .. zero_index)\n\t{\n\t\tresult[index] = zero[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(long i; 0 .. positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4hwjuxa9.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmp4hwjuxa9.__unittest_L58_C1() [0x42836c]\n??:? void tmp4hwjuxa9.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tnegative = negative[0..negative_index];\n\tpositive = positive[0..positive_index];\n\t\n\tresult = negative ~ positive;\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1kf0zscp.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4285cd]\n??:? void tmp1kf0zscp.__unittest_L37_C1() [0x4280f0]\n??:? void tmp1kf0zscp.__modtest() [0x42834c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b662]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430731]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b639]\n??:? runModuleUnitTests [0x42c5a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tlong count = 0;\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[count] = neg[i];\n\t\tcount++;\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[count] = pos[i];\n\t\tcount++;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv9pinv70.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpv9pinv70.__unittest_L41_C1() [0x4281f4]\n??:? void tmpv9pinv70.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_index; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = 0; i < pos_index; i++) \n\t{\n\t\tresult[i + neg_index] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpefq8iw2x.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpefq8iw2x.__unittest_L38_C1() [0x428168]\n??:? void tmpefq8iw2x.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplvra8boj.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmplvra8boj.__unittest_L42_C1() [0x4281ec]\n??:? void tmplvra8boj.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_6xeq2ne.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp_6xeq2ne.__unittest_L42_C1() [0x4281ec]\n??:? void tmp_6xeq2ne.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tlong j = 0;\n\tforeach(long i; 0 .. neg_count)\n\t{\n\t\tres[j] = neg[i];\n\t\tj++;\n\t}\n\tforeach(long i; 0 .. pos_count)\n\t{\n\t\tres[j] = pos[i];\n\t\tj++;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp5u8z7z02.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp5u8z7z02.__unittest_L41_C1() [0x4281f4]\n??:? void tmp5u8z7z02.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong i = 0, j = n - 1;\n\t\n\tforeach(elem; arr)\n\t{\n\t\tif(elem < 0)\n\t\t{\n\t\t\tresult[i] = elem;\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[j] = elem;\n\t\t\tj--;\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjeutiu2w.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4284f5]\n??:? void tmpjeutiu2w.__unittest_L29_C1() [0x428018]\n??:? void tmpjeutiu2w.__modtest() [0x428274]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b442]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430659]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b419]\n??:? runModuleUnitTests [0x42c385]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tauto result = arr.dup;\n\tlong i = 0;\n\tlong j = n - 1;\n\twhile (i < j) \n\t{\n\t\twhile (result[i] < 0) \n\t\t{\n\t\t\ti++;\n\t\t}\n\t\twhile (result[j] >= 0) \n\t\t{\n\t\t\tj--;\n\t\t}\n\t\tif (i < j) \n\t\t{\n\t\t\tswap(result[i], result[j]);\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "/tmp/tmp02oyoi8i.d(25): Error: undefined identifier `swap`, did you mean template `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp02oyoi8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxpe9d9jh.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpxpe9d9jh.__unittest_L42_C1() [0x4281ec]\n??:? void tmpxpe9d9jh.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = 0; i < pos_index; i++)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpm1aljliw.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpm1aljliw.__unittest_L38_C1() [0x428168]\n??:? void tmpm1aljliw.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] > 0) \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t} \n\t\telse if (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < zero_index; i++) \n\t{\n\t\tresult[index] = zero[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < positive_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp__esgwnm.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428795]\n??:? void tmp__esgwnm.__unittest_L53_C1() [0x4282b8]\n??:? void tmp__esgwnm.__modtest() [0x428514]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c84f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43096d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e1c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b9]\n??:? runModuleUnitTests [0x42c625]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c58]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tlong j = 0;\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tresult[j] = negative[i];\n\t\tj++;\n\t}\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tresult[j] = positive[i];\n\t\tj++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpghwbqtqr.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpghwbqtqr.__unittest_L41_C1() [0x4281f4]\n??:? void tmpghwbqtqr.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse {\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++) {\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++) {\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkx64x7d_.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpkx64x7d_.__unittest_L37_C1() [0x428168]\n??:? void tmpkx64x7d_.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnzit3lr8.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpnzit3lr8.__unittest_L42_C1() [0x4281ec]\n??:? void tmpnzit3lr8.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count+i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6oy963f0.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp6oy963f0.__unittest_L38_C1() [0x4281ec]\n??:? void tmp6oy963f0.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong[] temp = negative[0..negative_index] ~ positive[0..positive_index];\n\tresult = temp[0..n];\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp83r_uxvf.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4285ed]\n??:? void tmp83r_uxvf.__unittest_L32_C1() [0x428114]\n??:? void tmp83r_uxvf.__modtest() [0x428370]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b682]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430751]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b659]\n??:? runModuleUnitTests [0x42c5c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ab0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong j = 0;\n\tlong k = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\ttemp[j] = arr[i];\n\t\t\tj++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\ttemp2[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tfor (long i = 0; i < j; i++) \n\t{\n\t\tresult[i] = temp[i];\n\t}\n\tfor (long i = 0; i < k; i++) \n\t{\n\t\tresult[j + i] = temp2[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp80mwmy1e.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp80mwmy1e.__unittest_L38_C1() [0x428168]\n??:? void tmp80mwmy1e.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_index = 0;\n\tlong pos_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_index)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_index)\n\t{\n\t\tres[neg_index + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp5kz614hr.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp5kz614hr.__unittest_L38_C1() [0x4281ec]\n??:? void tmp5kz614hr.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp1 = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "/tmp/tmprchwqyml.d(53): Error: found `unittest` when expecting `]`\n/tmp/tmprchwqyml.d(54): Error: semicolon expected, not `{`\n/tmp/tmprchwqyml.d(61): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprchwqyml.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tlong i = 0;\n\tforeach(long j; 0..neg_count)\n\t{\n\t\tresult[i] = negative[j];\n\t\ti++;\n\t}\n\tforeach(long j; 0..pos_count)\n\t{\n\t\tresult[i] = positive[j];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt_1n90i8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpt_1n90i8.__unittest_L41_C1() [0x4281f4]\n??:? void tmpt_1n90i8.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp68imkbdr.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp68imkbdr.__unittest_L45_C1() [0x428168]\n??:? void tmp68imkbdr.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++) \n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpiiwstecz.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpiiwstecz.__unittest_L42_C1() [0x428168]\n??:? void tmpiiwstecz.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxpe9d9jh.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpxpe9d9jh.__unittest_L42_C1() [0x4281ec]\n??:? void tmpxpe9d9jh.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8wo9e905.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp8wo9e905.__unittest_L45_C1() [0x4281f4]\n??:? void tmp8wo9e905.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0 .. positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptcwh3b5b.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmptcwh3b5b.__unittest_L42_C1() [0x4281ec]\n??:? void tmptcwh3b5b.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor(long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor(long i = negative_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdfq6_wdp.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpdfq6_wdp.__unittest_L42_C1() [0x428168]\n??:? void tmpdfq6_wdp.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvp_nfmts.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpvp_nfmts.__unittest_L42_C1() [0x4281ec]\n??:? void tmpvp_nfmts.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; neg_count..n)\n\t{\n\t\tresult[i] = positive[i-neg_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldrfrsxm.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpldrfrsxm.__unittest_L42_C1() [0x4281e8]\n??:? void tmpldrfrsxm.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_count; i++)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp49_5r3ps.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp49_5r3ps.__unittest_L42_C1() [0x428168]\n??:? void tmp49_5r3ps.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_index = 0;\n\tlong pos_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_index)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_index)\n\t{\n\t\tresult[neg_index + i] = pos[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8eo73g2k.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp8eo73g2k.__unittest_L42_C1() [0x4281ec]\n??:? void tmp8eo73g2k.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(i < negative_index)\n\t\t{\n\t\t\tresult[i] = negative[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[i] = positive[i - negative_index];\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvn6wfrrl.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428675]\n??:? void tmpvn6wfrrl.__unittest_L44_C1() [0x42819c]\n??:? void tmpvn6wfrrl.__modtest() [0x4283f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c72f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b5c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43084d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cfc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b599]\n??:? runModuleUnitTests [0x42c505]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b38]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t}\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; negative_index..n)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpclymy9jy.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpclymy9jy.__unittest_L38_C1() [0x4281e8]\n??:? void tmpclymy9jy.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < pos_count; i++)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphk1omtuj.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmphk1omtuj.__unittest_L42_C1() [0x428168]\n??:? void tmphk1omtuj.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tlong[] temp = new long[n];\n\t\n\twhile(i < n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\ttemp[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp[n-k-1] = arr[i];\n\t\t\tk++;\n\t\t}\n\t\ti++;\n\t}\n\treturn temp;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp__5xmbbh.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428535]\n??:? void tmp__5xmbbh.__unittest_L31_C1() [0x428058]\n??:? void tmp__5xmbbh.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b482]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43070d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430699]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b459]\n??:? runModuleUnitTests [0x42c3c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_count)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\t\n\tforeach(long i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = pos[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz92pkosy.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpz92pkosy.__unittest_L42_C1() [0x4281ec]\n??:? void tmpz92pkosy.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp43tp7z4z.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp43tp7z4z.__unittest_L42_C1() [0x4281ec]\n??:? void tmp43tp7z4z.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_count; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_count; i++) \n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0p_y3zj6.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp0p_y3zj6.__unittest_L42_C1() [0x428168]\n??:? void tmp0p_y3zj6.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp03j_rmno.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp03j_rmno.__unittest_L42_C1() [0x4281ec]\n??:? void tmp03j_rmno.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_count = 0;\n\tlong positive_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz4jxl88i.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpz4jxl88i.__unittest_L38_C1() [0x4281ec]\n??:? void tmpz4jxl88i.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[i + negative_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpw7pn2572.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpw7pn2572.__unittest_L41_C1() [0x4281f4]\n??:? void tmpw7pn2572.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[i + negative_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwis7t07j.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpwis7t07j.__unittest_L42_C1() [0x4281f4]\n??:? void tmpwis7t07j.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] temp = new long[n];\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\t\n\tforeach(long l; arr)\n\t{\n\t\tif(l < 0)\n\t\t{\n\t\t\tnegative[i] = l;\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[j] = l;\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tforeach(long l; negative)\n\t{\n\t\tif(l != 0)\n\t\t{\n\t\t\ttemp[k] = l;\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\tforeach(long l; positive)\n\t{\n\t\tif(l != 0)\n\t\t{\n\t\t\ttemp[k] = l;\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\treturn temp;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzmmo64jo.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428685]\n??:? void tmpzmmo64jo.__unittest_L52_C1() [0x4281ac]\n??:? void tmpzmmo64jo.__modtest() [0x428408]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c73f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b5d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43085d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5a9]\n??:? runModuleUnitTests [0x42c515]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tfor (long i = 0; i < neg_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < pos_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp78ix5c_9.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp78ix5c_9.__unittest_L41_C1() [0x428168]\n??:? void tmp78ix5c_9.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_6xeq2ne.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp_6xeq2ne.__unittest_L42_C1() [0x4281ec]\n??:? void tmp_6xeq2ne.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong i = 0;\n\twhile (i < n) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t} else {\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < neg_index) {\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < pos_index) {\n\t\tresult[neg_index + i] = positive[i];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwgw1y6lc.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42863d]\n??:? void tmpwgw1y6lc.__unittest_L38_C1() [0x428160]\n??:? void tmpwgw1y6lc.__modtest() [0x4283bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b561]\n??:? runModuleUnitTests [0x42c4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_cnt = 0;\n\tlong neg_cnt = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_cnt] = arr[i];\n\t\t\tneg_cnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_cnt] = arr[i];\n\t\t\tpos_cnt++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_cnt; i++)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tfor (long i = 0; i < pos_cnt; i++)\n\t{\n\t\tres[i + neg_cnt] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkivvj_99.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpkivvj_99.__unittest_L38_C1() [0x428168]\n??:? void tmpkivvj_99.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxpe9d9jh.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpxpe9d9jh.__unittest_L42_C1() [0x4281ec]\n??:? void tmpxpe9d9jh.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong p = 0;\n\tlong n = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[n] = arr[i];\n\t\t\tn++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[p] = arr[i];\n\t\t\tp++;\n\t\t}\n\t}\n\tforeach(i; 0 .. n)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0 .. p)\n\t{\n\t\tresult[i+n] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "/tmp/tmp269q4k70.d(14): Error: variable `n` is shadowing variable `tmp269q4k70.re_arrange_array.n`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp269q4k70.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong j = 0;\n\tlong k = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\ttemp[j] = arr[i];\n\t\t\tj++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\ttemp2[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tj = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (i < j) \n\t\t{\n\t\t\tresult[i] = temp[i];\n\t\t} \n\t\telse \n\t\t{\n\t\t\tresult[i] = temp2[i - j];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprgnea_iw.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428635]\n??:? void tmprgnea_iw.__unittest_L42_C1() [0x42815c]\n??:? void tmprgnea_iw.__modtest() [0x4283b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b582]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43080d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430799]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b559]\n??:? runModuleUnitTests [0x42c4c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428af8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwalullxs.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpwalullxs.__unittest_L38_C1() [0x4281ec]\n??:? void tmpwalullxs.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tlong i = 0;\n\twhile(i < n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile(i < neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\ti = 0;\n\twhile(i < pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpn_k3366j.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x42863d]\n??:? void tmpn_k3366j.__unittest_L44_C1() [0x428160]\n??:? void tmpn_k3366j.__modtest() [0x4283bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b561]\n??:? runModuleUnitTests [0x42c4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\tlong zero_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_count] = arr[i];\n\t\t\tzero_count++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(i; 0..zero_count)\n\t{\n\t\tresult[index] = zero[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2x21byn5.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmp2x21byn5.__unittest_L58_C1() [0x42836c]\n??:? void tmp2x21byn5.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] result_pos = new long[n];\n\tlong[] result_neg = new long[n];\n\tlong[] result_zero = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong zero_index = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tresult_pos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tresult_neg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult_zero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_index)\n\t{\n\t\tresult[i] = result_neg[i];\n\t}\n\t\n\tforeach(long i; 0..zero_index)\n\t{\n\t\tresult[neg_index + i] = result_zero[i];\n\t}\n\t\n\tforeach(long i; 0..pos_index)\n\t{\n\t\tresult[neg_index + zero_index + i] = result_pos[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvvuyf1ph.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x42884d]\n??:? void tmpvvuyf1ph.__unittest_L54_C1() [0x428374]\n??:? void tmpvvuyf1ph.__modtest() [0x4285d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c907]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b79a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ed4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309b1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b771]\n??:? runModuleUnitTests [0x42c6dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(i; 0..zero_index)\n\t{\n\t\tresult[index] = zero[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0g5coj2e.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmp0g5coj2e.__unittest_L58_C1() [0x42836c]\n??:? void tmp0g5coj2e.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] >= 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu1psc9k9.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpu1psc9k9.__unittest_L42_C1() [0x428168]\n??:? void tmpu1psc9k9.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp67xldv26.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp67xldv26.__unittest_L42_C1() [0x4281ec]\n??:? void tmp67xldv26.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpei1_wt1m.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpei1_wt1m.__unittest_L42_C1() [0x4281f4]\n??:? void tmpei1_wt1m.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tforeach(long i; 0..neg_index)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\tforeach(long i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = pos[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkqjq15is.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpkqjq15is.__unittest_L38_C1() [0x4281ec]\n??:? void tmpkqjq15is.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_count)\n\t{\n\t\tresult[i + neg_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpr93_v0td.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpr93_v0td.__unittest_L42_C1() [0x4281f4]\n??:? void tmpr93_v0td.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive_arr = new long[n];\n\tlong[] negative_arr = new long[n];\n\tlong positive_arr_index = 0;\n\tlong negative_arr_index = 0;\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative_arr[negative_arr_index] = arr[i];\n\t\t\tnegative_arr_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive_arr[positive_arr_index] = arr[i];\n\t\t\tpositive_arr_index++;\n\t\t}\n\t}\n\tforeach(long i; 0 .. negative_arr_index)\n\t{\n\t\tresult[i] = negative_arr[i];\n\t}\n\tforeach(long i; 0 .. positive_arr_index)\n\t{\n\t\tresult[negative_arr_index + i] = positive_arr[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxtl6jx9e.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpxtl6jx9e.__unittest_L38_C1() [0x4281ec]\n??:? void tmpxtl6jx9e.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[i + neg_count] = pos[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpb9ojfv2_.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpb9ojfv2_.__unittest_L42_C1() [0x4281f4]\n??:? void tmpb9ojfv2_.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..zero_index)\n\t{\n\t\tresult[negative_index + i] = zero[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + zero_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpthdz2910.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x42884d]\n??:? void tmpthdz2910.__unittest_L54_C1() [0x428374]\n??:? void tmpthdz2910.__modtest() [0x4285d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c907]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b79a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ed4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309b1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b771]\n??:? runModuleUnitTests [0x42c6dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = pos[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7ej09woz.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp7ej09woz.__unittest_L42_C1() [0x4281ec]\n??:? void tmp7ej09woz.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(long i; neg_count..n)\n\t{\n\t\tres[i] = pos[i - neg_count];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2x2cq1hf.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp2x2cq1hf.__unittest_L41_C1() [0x4281e8]\n??:? void tmp2x2cq1hf.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq21zu8om.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpq21zu8om.__unittest_L42_C1() [0x4281f4]\n??:? void tmpq21zu8om.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n    long[] result = new long[n];\n    int i = 0;\n    int j = n - 1;\n    foreach(long num; arr)\n    {\n        if (num < 0)\n        {\n            result[i] = num;\n            i++;\n        }\n        else\n        {\n            result[j] = num;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "/tmp/tmpk60g5s6k.d(12): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk60g5s6k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong i = 0, j = n - 1;\n\tforeach(long x; arr)\n\t{\n\t\tif(x < 0)\n\t\t{\n\t\t\tres[i] = x;\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres[j] = x;\n\t\t\tj--;\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppdnkt6bh.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x4284f5]\n??:? void tmppdnkt6bh.__unittest_L27_C1() [0x428018]\n??:? void tmppdnkt6bh.__modtest() [0x428274]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b442]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430659]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b419]\n??:? runModuleUnitTests [0x42c385]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] temp = new long[n];\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\twhile (i < n) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[j] = arr[i];\n\t\t\tj++;\n\t\t} else {\n\t\t\tpositive[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < j) {\n\t\ttemp[l] = negative[i];\n\t\tl++;\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < k) {\n\t\ttemp[l] = positive[i];\n\t\tl++;\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < n) {\n\t\tresult[i] = temp[i];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpizpcf1eg.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpizpcf1eg.__unittest_L47_C1() [0x4281f0]\n??:? void tmpizpcf1eg.__modtest() [0x42844c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = 0; i < positive_count; i++)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqnrx2kjq.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpqnrx2kjq.__unittest_L38_C1() [0x428168]\n??:? void tmpqnrx2kjq.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t}\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(i < negative_count)\n\t\t{\n\t\t\tresult[i] = negative[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[i] = positive[i - negative_count];\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpot7ll7ib.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428635]\n??:? void tmpot7ll7ib.__unittest_L44_C1() [0x42815c]\n??:? void tmpot7ll7ib.__modtest() [0x4283b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b582]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43080d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430799]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b559]\n??:? runModuleUnitTests [0x42c4c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428af8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tlong zero_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_count] = arr[i];\n\t\t\tzero_count++;\n\t\t}\n\t}\n\t\n\tlong count = 0;\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[count] = negative[i];\n\t\tcount++;\n\t}\n\t\n\tforeach(i; 0..zero_count)\n\t{\n\t\tresult[count] = zero[i];\n\t\tcount++;\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[count] = positive[i];\n\t\tcount++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv9t6hhry.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmpv9t6hhry.__unittest_L58_C1() [0x42836c]\n??:? void tmpv9t6hhry.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tresult = negative[0 .. negative_index] ~ positive[0 .. positive_index];\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj_yzizq9.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4285bd]\n??:? void tmpj_yzizq9.__unittest_L34_C1() [0x4280e4]\n??:? void tmpj_yzizq9.__modtest() [0x428340]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b652]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430795]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430721]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b629]\n??:? runModuleUnitTests [0x42c595]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[i + neg_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprpaltu7g.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmprpaltu7g.__unittest_L42_C1() [0x4281f4]\n??:? void tmprpaltu7g.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4opibxac.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp4opibxac.__unittest_L42_C1() [0x4281ec]\n??:? void tmp4opibxac.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_count = 0;\n\tlong positive_count = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcs8x4cx3.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpcs8x4cx3.__unittest_L42_C1() [0x4281ec]\n??:? void tmpcs8x4cx3.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(long elem; arr)\n\t{\n\t\tif(elem < 0)\n\t\t{\n\t\t\tneg[neg_count] = elem;\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = elem;\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long elem; neg)\n\t{\n\t\tres ~= elem;\n\t}\n\t\n\tforeach(long elem; pos)\n\t{\n\t\tres ~= elem;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2okym_o7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428665]\n??:? void tmp2okym_o7.__unittest_L42_C1() [0x428188]\n??:? void tmp2okym_o7.__modtest() [0x4283e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d10b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bf9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ae9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f98]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a75]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bf75]\n??:? runModuleUnitTests [0x42cee1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(i; 0 .. zero_index)\n\t{\n\t\tresult[index] = zero[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8qurt5fy.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmp8qurt5fy.__unittest_L58_C1() [0x42836c]\n??:? void tmp8qurt5fy.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp43tp7z4z.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp43tp7z4z.__unittest_L42_C1() [0x4281ec]\n??:? void tmp43tp7z4z.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4cl8eflh.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp4cl8eflh.__unittest_L38_C1() [0x4281ec]\n??:? void tmp4cl8eflh.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = neg_count; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - neg_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9lc4kaf9.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp9lc4kaf9.__unittest_L42_C1() [0x428168]\n??:? void tmp9lc4kaf9.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong i = 0;\n\twhile(i < n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile(i < negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\tlong j = 0;\n\twhile(j < positive_index)\n\t{\n\t\tresult[i] = positive[j];\n\t\ti++;\n\t\tj++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpeforhof2.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42863d]\n??:? void tmpeforhof2.__unittest_L45_C1() [0x428160]\n??:? void tmpeforhof2.__modtest() [0x4283bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b561]\n??:? runModuleUnitTests [0x42c4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = 0; i < pos_count; i++)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpf69va5wr.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpf69va5wr.__unittest_L40_C1() [0x428168]\n??:? void tmpf69va5wr.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[arr.length];\n\tlong[] pos = new long[arr.length];\n\tlong[] neg = new long[arr.length];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_count; i++) \n\t{\n\t\tresult[i] = neg[i];\n\t}\n\tfor (long i = 0; i < pos_count; i++) \n\t{\n\t\tresult[neg_count + i] = pos[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprmpisvqd.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42863d]\n??:? void tmprmpisvqd.__unittest_L38_C1() [0x428164]\n??:? void tmprmpisvqd.__modtest() [0x4283c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b561]\n??:? runModuleUnitTests [0x42c4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_idx = 0;\n\tlong neg_idx = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_idx] = arr[i];\n\t\t\tneg_idx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_idx] = arr[i];\n\t\t\tpos_idx++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_idx)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_idx)\n\t{\n\t\tresult[i + neg_idx] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzy21vv5z.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpzy21vv5z.__unittest_L42_C1() [0x4281f4]\n??:? void tmpzy21vv5z.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnyzxagnv.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpnyzxagnv.__unittest_L42_C1() [0x4281ec]\n??:? void tmpnyzxagnv.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] arr_neg = new long[n];\n\tlong[] arr_pos = new long[n];\n\tlong[] arr_res = new long[n];\n\tlong neg_idx = 0;\n\tlong pos_idx = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tarr_neg[neg_idx] = arr[i];\n\t\t\tneg_idx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarr_pos[pos_idx] = arr[i];\n\t\t\tpos_idx++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_idx)\n\t{\n\t\tarr_res[i] = arr_neg[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_idx)\n\t{\n\t\tarr_res[neg_idx + i] = arr_pos[i];\n\t}\n\t\n\treturn arr_res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzhyuzvhz.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpzhyuzvhz.__unittest_L42_C1() [0x4281ec]\n??:? void tmpzhyuzvhz.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_idx = 0;\n\tlong neg_idx = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_idx] = arr[i];\n\t\t\tneg_idx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_idx] = arr[i];\n\t\t\tpos_idx++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_idx; i++)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tfor (long i = neg_idx; i < n; i++)\n\t{\n\t\tres[i] = pos[i - neg_idx];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphu02h695.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmphu02h695.__unittest_L42_C1() [0x428168]\n??:? void tmphu02h695.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[arr.length];\n\tlong[] negative = new long[arr.length];\n\tlong[] positive = new long[arr.length];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgp4jkfnw.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpgp4jkfnw.__unittest_L42_C1() [0x4281ec]\n??:? void tmpgp4jkfnw.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = negative_count; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8sutkiqw.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp8sutkiqw.__unittest_L42_C1() [0x428168]\n??:? void tmp8sutkiqw.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp45mq6a82.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp45mq6a82.__unittest_L42_C1() [0x4281ec]\n??:? void tmp45mq6a82.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_6xeq2ne.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp_6xeq2ne.__unittest_L42_C1() [0x4281ec]\n??:? void tmp_6xeq2ne.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong i = 0;\n\twhile (i < n) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t} else {\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < neg_index) {\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\twhile (i < n) {\n\t\tresult[i] = positive[i - neg_index];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmporbhdg54.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x428635]\n??:? void tmporbhdg54.__unittest_L37_C1() [0x428158]\n??:? void tmporbhdg54.__modtest() [0x4283b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b582]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43080d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430799]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b559]\n??:? runModuleUnitTests [0x42c4c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428af8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4td7n3h2.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp4td7n3h2.__unittest_L42_C1() [0x4281ec]\n??:? void tmp4td7n3h2.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_idx = 0;\n\tlong neg_idx = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_idx] = arr[i];\n\t\t\tneg_idx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_idx] = arr[i];\n\t\t\tpos_idx++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_idx)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_idx)\n\t{\n\t\tres[neg_idx + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7y43yfk.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpx7y43yfk.__unittest_L42_C1() [0x4281ec]\n??:? void tmpx7y43yfk.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_6xeq2ne.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp_6xeq2ne.__unittest_L42_C1() [0x4281ec]\n??:? void tmp_6xeq2ne.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tlong i = 0;\n\twhile (i < n) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t} else {\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < neg_count) {\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < pos_count) {\n\t\tresult[neg_count + i] = positive[i];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6i_4mmj_.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42863d]\n??:? void tmp6i_4mmj_.__unittest_L38_C1() [0x428160]\n??:? void tmp6i_4mmj_.__modtest() [0x4283bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b561]\n??:? runModuleUnitTests [0x42c4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tnegative_index = 0;\n\tpositive_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(negative_index < negative.length)\n\t\t{\n\t\t\tresult[i] = negative[negative_index];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[i] = positive[positive_index];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3cldryni.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x42867d]\n??:? void tmp3cldryni.__unittest_L49_C1() [0x4281a4]\n??:? void tmp3cldryni.__modtest() [0x428400]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c737]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b5ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430855]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d04]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5a1]\n??:? runModuleUnitTests [0x42c50d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b40]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tfor (long i = 0; i < pos_count; i++)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu2l9qoso.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpu2l9qoso.__unittest_L38_C1() [0x428168]\n??:? void tmpu2l9qoso.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq21zu8om.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpq21zu8om.__unittest_L42_C1() [0x4281f4]\n??:? void tmpq21zu8om.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_index)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_index)\n\t{\n\t\tres[neg_index+i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4xmexgw2.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp4xmexgw2.__unittest_L38_C1() [0x4281ec]\n??:? void tmp4xmexgw2.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\t\n\tfor (long i = 0; i < pos_count; i++)\n\t{\n\t\tresult[neg_count + i] = pos[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjn9dxp_u.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpjn9dxp_u.__unittest_L42_C1() [0x428168]\n??:? void tmpjn9dxp_u.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong i = 0;\n\twhile (i < n)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile (i < neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\twhile (i < neg_index + pos_index)\n\t{\n\t\tresult[i] = positive[i - neg_index];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptepewqr8.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x428635]\n??:? void tmptepewqr8.__unittest_L43_C1() [0x42815c]\n??:? void tmptepewqr8.__modtest() [0x4283b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b582]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43080d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430799]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b559]\n??:? runModuleUnitTests [0x42c4c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428af8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] neg_arr = new long[n];\n\tlong[] pos_arr = new long[n];\n\tlong neg_index = 0;\n\tlong pos_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg_arr[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos_arr[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tneg_arr = neg_arr[0 .. neg_index];\n\tpos_arr = pos_arr[0 .. pos_index];\n\t\n\treturn neg_arr ~ pos_arr;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuiix2okd.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4285cd]\n??:? void tmpuiix2okd.__unittest_L34_C1() [0x4280f4]\n??:? void tmpuiix2okd.__modtest() [0x428350]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c7cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b662]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430731]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b639]\n??:? runModuleUnitTests [0x42c5a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n) {\n\t\tif(arr[i] < 0) {\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t} else {\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count) {\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_count) {\n\t\tres[neg_count + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppryyb0vi.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmppryyb0vi.__unittest_L36_C1() [0x4281ec]\n??:? void tmppryyb0vi.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] ret = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_count)\n\t{\n\t\tret[i] = neg[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_count)\n\t{\n\t\tret[i + neg_count] = pos[i];\n\t}\n\t\n\treturn ret;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptih78wqa.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmptih78wqa.__unittest_L42_C1() [0x4281f4]\n??:? void tmptih78wqa.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t} else {\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_index; i++) {\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = neg_index; i < n; i++) {\n\t\tresult[i] = positive[i - neg_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4armpfgq.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp4armpfgq.__unittest_L36_C1() [0x428168]\n??:? void tmp4armpfgq.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count+i] = pos[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9y8u8y_n.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp9y8u8y_n.__unittest_L38_C1() [0x4281ec]\n??:? void tmp9y8u8y_n.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t} else {\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++) {\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++) {\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_0h5rwrx.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp_0h5rwrx.__unittest_L36_C1() [0x428168]\n??:? void tmp_0h5rwrx.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++) \n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgfya81mi.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpgfya81mi.__unittest_L42_C1() [0x428168]\n??:? void tmpgfya81mi.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnmm8p_91.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpnmm8p_91.__unittest_L42_C1() [0x4281ec]\n??:? void tmpnmm8p_91.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..zero_index)\n\t{\n\t\tresult[negative_index + i] = zero[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + zero_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpthdz2910.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x42884d]\n??:? void tmpthdz2910.__unittest_L54_C1() [0x428374]\n??:? void tmpthdz2910.__modtest() [0x4285d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c907]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b79a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ed4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309b1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b771]\n??:? runModuleUnitTests [0x42c6dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4opibxac.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp4opibxac.__unittest_L42_C1() [0x4281ec]\n??:? void tmp4opibxac.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp04myh4pl.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp04myh4pl.__unittest_L42_C1() [0x4281ec]\n??:? void tmp04myh4pl.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] >= 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = negative_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpekj7zdpj.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpekj7zdpj.__unittest_L42_C1() [0x428168]\n??:? void tmpekj7zdpj.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < positive_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpe33_qjhk.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpe33_qjhk.__unittest_L41_C1() [0x428168]\n??:? void tmpe33_qjhk.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] temp = new long[n];\n\tlong[] result = new long[n];\n\tlong[] result2 = new long[n];\n\tlong[] result3 = new long[n];\n\tlong[] result4 = new long[n];\n\tlong[] result5 = new long[n];\n\tlong[] result6 = new long[n];\n\tlong[] result7 = new long[n];\n\tlong[] result8 = new long[n];\n\tlong[] result9 = new long[n];\n\tlong[] result10 = new long[n];\n\tlong[] result11 = new long[n];\n\tlong[] result12 = new long[n];\n\tlong[] result13 = new long[n];\n\tlong[] result14 = new long[n];\n\tlong[] result15 = new long[n];\n\tlong[] result16 = new long[n];\n\tlong[] result17 = new long[n];\n\tlong[] result18 = new long[n];\n\tlong[] result19 = new long[n];\n\tlong[] result20 = new long[n];\n\tlong[] result21 = new long[n];\n\tlong[] result22 = new long[n];\n\tlong[] result23 = new long[n];\n\tlong[] result24 = new long[n];\n\tlong[] result25 = new long[n];\n\tlong[] result26 = new long[n];\n\tlong[] result27 = new long[n];\n\tlong[] result28 = new long[n];\n\tlong[] result29 = new long[n];\n\tlong[] result30 = new long[n];\n\tlong[] result31 = new long[n];\n\tlong[] result32 = new long[n];\n\tlong[] result33 = new long[n];\n\tlong[] result34 = new long[n];\n\tlong[] result35 = new long[n];\n\tlong[] result36 = new long[n];\n\tlong[] result37 = new long[n];\n\tlong[] result38 = new long[n];\n\tlong[] result39 = new long[n];\n\tlong[] result40 = new long[n];\n\tlong[] result41 = new long[n];\n\tlong[] result42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "/tmp/tmpoppgb94s.d(53): Error: basic type expected, not `unittest`\n/tmp/tmpoppgb94s.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmpoppgb94s.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoppgb94s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[i + negative_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptyitq2xm.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmptyitq2xm.__unittest_L42_C1() [0x4281f4]\n??:? void tmptyitq2xm.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_idx = 0;\n\tlong pos_idx = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_idx] = arr[i];\n\t\t\tneg_idx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_idx] = arr[i];\n\t\t\tpos_idx++;\n\t\t}\n\t}\n\tlong i = 0;\n\tforeach(j; 0 .. neg_idx)\n\t{\n\t\tres[i] = neg[j];\n\t\ti++;\n\t}\n\tforeach(j; 0 .. pos_idx)\n\t{\n\t\tres[i] = pos[j];\n\t\ti++;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdfzlg4is.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpdfzlg4is.__unittest_L41_C1() [0x4281f4]\n??:? void tmpdfzlg4is.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpebrf5o0z.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpebrf5o0z.__unittest_L42_C1() [0x4281ec]\n??:? void tmpebrf5o0z.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; negative_index..n)\n\t{\n\t\tresult[i] = positive[i-negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8dmk5r4s.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp8dmk5r4s.__unittest_L42_C1() [0x4281e8]\n??:? void tmp8dmk5r4s.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong i = 0;\n\twhile(i < n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\twhile(i < neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t\ti++;\n\t}\n\tlong j = 0;\n\twhile(i < n)\n\t{\n\t\tresult[i] = positive[j];\n\t\ti++;\n\t\tj++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkqu_5xzr.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42863d]\n??:? void tmpkqu_5xzr.__unittest_L45_C1() [0x428160]\n??:? void tmpkqu_5xzr.__modtest() [0x4283bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b58a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430815]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cc4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b561]\n??:? runModuleUnitTests [0x42c4cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo2ys433i.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpo2ys433i.__unittest_L40_C1() [0x4281ec]\n??:? void tmpo2ys433i.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = neg_count; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - neg_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122888,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9lc4kaf9.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp9lc4kaf9.__unittest_L42_C1() [0x428168]\n??:? void tmp9lc4kaf9.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = negative_index; i < n; i++) \n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuodn7hn_.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpuodn7hn_.__unittest_L42_C1() [0x428168]\n??:? void tmpuodn7hn_.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_6xeq2ne.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp_6xeq2ne.__unittest_L42_C1() [0x4281ec]\n??:? void tmp_6xeq2ne.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_6xeq2ne.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp_6xeq2ne.__unittest_L42_C1() [0x4281ec]\n??:? void tmp_6xeq2ne.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsrtee2e9.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpsrtee2e9.__unittest_L42_C1() [0x4281ec]\n??:? void tmpsrtee2e9.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp04myh4pl.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp04myh4pl.__unittest_L42_C1() [0x4281ec]\n??:? void tmp04myh4pl.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = pos[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2tvl9xpv.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp2tvl9xpv.__unittest_L38_C1() [0x4281ec]\n??:? void tmp2tvl9xpv.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[arr.length];\n\tlong[] pos = new long[arr.length];\n\tlong[] neg = new long[arr.length];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = pos[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpphj8v3_c.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpphj8v3_c.__unittest_L42_C1() [0x4281ec]\n??:? void tmpphj8v3_c.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] result_pos = new long[n];\n\tlong[] result_neg = new long[n];\n\tlong[] result_zero = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong zero_index = 0;\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tresult_pos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tresult_neg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult_zero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(long i; 0 .. neg_index)\n\t{\n\t\tresult[index] = result_neg[i];\n\t\tindex++;\n\t}\n\tforeach(long i; 0 .. zero_index)\n\t{\n\t\tresult[index] = result_zero[i];\n\t\tindex++;\n\t}\n\tforeach(long i; 0 .. pos_index)\n\t{\n\t\tresult[index] = result_pos[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmph1ujuutg.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmph1ujuutg.__unittest_L53_C1() [0x42836c]\n??:? void tmph1ujuutg.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] zero = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "/tmp/tmpuykb4dle.d(53): Error: found `unittest` when expecting `]`\n/tmp/tmpuykb4dle.d(54): Error: semicolon expected, not `{`\n/tmp/tmpuykb4dle.d(61): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuykb4dle.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_count = 0;\n\tlong positive_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmd862zow.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpmd862zow.__unittest_L42_C1() [0x4281ec]\n??:? void tmpmd862zow.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = neg_count; i < neg_count + pos_count; i++)\n\t{\n\t\tresult[i] = positive[i - neg_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvyjf307r.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpvyjf307r.__unittest_L42_C1() [0x42816c]\n??:? void tmpvyjf307r.__modtest() [0x4283c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(index, val; arr)\n\t{\n\t\tif(val < 0)\n\t\t{\n\t\t\tnegative[neg_index] = val;\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = val;\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(index, val; negative)\n\t{\n\t\tif(val != 0)\n\t\t{\n\t\t\tresult[index] = val;\n\t\t}\n\t}\n\t\n\tforeach(index, val; positive)\n\t{\n\t\tif(val != 0)\n\t\t{\n\t\t\tresult[index + neg_index] = val;\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp14k3r9wn.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x42868d]\n??:? void tmp14k3r9wn.__unittest_L48_C1() [0x4281b4]\n??:? void tmp14k3r9wn.__modtest() [0x428410]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c747]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b5da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430865]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5b1]\n??:? runModuleUnitTests [0x42c51d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b50]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122887,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplvra8boj.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmplvra8boj.__unittest_L42_C1() [0x4281ec]\n??:? void tmplvra8boj.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_index; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = neg_index; i < neg_index + pos_index; i++) \n\t{\n\t\tresult[i] = positive[i - neg_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0rv_taqd.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp0rv_taqd.__unittest_L42_C1() [0x42816c]\n??:? void tmp0rv_taqd.__modtest() [0x4283c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index+i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7ho5jwo7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp7ho5jwo7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp7ho5jwo7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = negative_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpw0actp66.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpw0actp66.__unittest_L42_C1() [0x428168]\n??:? void tmpw0actp66.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate()) [0x428a8f]\n??:? _d_run_main [0x4289fa]\n??:? main [0x4283d7]\n??:? __libc_start_main [0x5d7ba554]\n1/1 unittests FAILED\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; neg_index .. n)\n\t{\n\t\tresult[i] = positive[i - neg_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq2c1iu0g.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpq2c1iu0g.__unittest_L41_C1() [0x4281e8]\n??:? void tmpq2c1iu0g.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "/tmp/tmp9t2vy8r6.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp9t2vy8r6.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp9t2vy8r6.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9t2vy8r6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_count; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = 0; i < pos_count; i++) \n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122889,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgjxh0mel.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpgjxh0mel.__unittest_L38_C1() [0x428168]\n??:? void tmpgjxh0mel.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517265,
      "stdout": "",
      "stderr": "/tmp/tmp2oib4205.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2oib4205.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2oib4205.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}