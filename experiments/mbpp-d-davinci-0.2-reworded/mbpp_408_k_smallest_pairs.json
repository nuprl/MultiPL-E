{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) \n\t\treturn new long[][]{};\n\t\n\tauto comp = (long[] a, long[] b) => a[0] + a[1] > b[0] + b[1];\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. min(k, n1)) \n\t{\n\t\tforeach (j; 0 .. min(k, n2)) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray();\n}",
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn new long[][]{};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(new long[]{nums1[i], nums2[0], 0});\n\t\n\tlong[][] res = new long[][](k);\n\tint idx = 0;\n\twhile (idx < k && !pq.empty)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[idx++] = new long[]{cur[0], cur[1]};\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});\n\t}\n\treturn res[0 .. idx];\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\twhile (k-- > 0 && pq.length) \n\t{\n\t\tauto cur = pq.get();\n\t\tresult ~= new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult[i] = cur;\n\t\t\n\t\tif (cur[0] == nums1[n1 - 1] && cur[1] == nums2[n2 - 1])\n\t\t\tcontinue;\n\t\t\n\t\tif (cur[1] == nums2[n2 - 1])\n\t\t\tpq.put(new long[](cur[0] + 1, nums2[0]));\n\t\telse\n\t\t\tpq.put(new long[](cur[0], cur[1] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")(n1 * n2);\n\t\n\tforeach(i; 0 .. n1)\n\t\tforeach(j; 0 .. n2)\n\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto p = heap.popFront();\n\t\tif(p is null)\n\t\t\tbreak;\n\t\tres[i] = p;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j, n;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\tn = 0;\n\tforeach(i; nums1)\n\t{\n\t\tforeach(j; nums2)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = nums1[i];\n\t\t\tpair[1] = nums2[j];\n\t\t\tpairs[n] = pair;\n\t\t\tn++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tforeach(j; 0 .. min(k, nums2.length))\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](pq.length);\n\tforeach(i; 0 .. pq.length)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto heap = new MinHeap!(tuple!(long, long, long, long));\n\t\n\tforeach(i; 0..n)\n\t{\n\t\theap.push(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif(t[3] < m - 1)\n\t\t{\n\t\t\theap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[])();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put(new long[](nums1[i], nums2[j]));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(new long[](nums1[i], nums2[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || (a[2] == b[2] && a[3] < b[3])\");\n\t\n\tforeach (i, e; nums1)\n\t{\n\t\tpq.put(tuple(e, nums2[0], i, 0));\n\t}\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = [t[0], t[1]];\n\t\tif (t[3] == n2 - 1) continue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto result = new long[][](0);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult ~= new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\tif(pq.size > k)\n\t\t\t{\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray;\n}",
    "{\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\tauto result = new long[][](k);\n\t\n\tforeach(i, e; nums1)\n\t{\n\t\theap.insert(tuple(e, nums2[0], i, 0));\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = heap.popFront;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] + 1 < nums2.length)\n\t\t{\n\t\t\theap.insert(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0 || k == 0) \n\t\treturn [];\n\t\n\tauto arr = new long[][](len1, len2);\n\tfor (int i = 0; i < len1; i++) \n\t{\n\t\tfor (int j = 0; j < len2; j++) \n\t\t{\n\t\t\tarr[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tauto res = new long[][](k, 2);\n\tauto visited = new bool[][](len1, len2);\n\tfor (int i = 0; i < k; i++) \n\t{\n\t\tlong min = long.max;\n\t\tint min_i = 0;\n\t\tint min_j = 0;\n\t\tfor (int j = 0; j < len1; j++) \n\t\t{\n\t\t\tfor (int l = 0; l < len2; l++) \n\t\t\t{\n\t\t\t\tif (visited[j][l]) \n\t\t\t\t\tcontinue;\n\t\t\t\tif (arr[j][l] < min) \n\t\t\t\t{\n\t\t\t\t\tmin = arr[j][l];\n\t\t\t\t\tmin_i = j;\n\t\t\t\t\tmin_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres[i][0] = nums1[min_i];\n\t\tres[i][1] = nums2[min_j];\n\t\tvisited[min_i][min_j] = true;\n\t}\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto pairs = new long[][](n1 * n2);\n\tauto index = 0;\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\tforeach(i; 0 .. pairs.length)\n\t{\n\t\tif(count == k)\n\t\t\tbreak;\n\t\tresult[count] = pairs[i];\n\t\tcount++;\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\tlong min_index;\n\tlong min_value;\n\tlong[] min_pair;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tif (k >= n * m)\n\t\treturn pairs;\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin_index = i;\n\t\tmin_value = nums1[i / m] + nums2[i % m];\n\t\t\n\t\tfor (j = i + 1; j < n * m; j++)\n\t\t{\n\t\t\tif (nums1[j / m] + nums2[j % m] < min_value)\n\t\t\t{\n\t\t\t\tmin_index = j;\n\t\t\t\tmin_value = nums1[j / m] + nums2[j % m];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmin_pair = pairs[min_index];\n\t\tpairs[min_index] = pairs[i];\n\t\tpairs[i] = min_pair;\n\t\t\n\t\tresult[i] = min_pair;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 * n2 == 0)\n\t\treturn result;\n\t\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\twhile (k-- > 0)\n\t{\n\t\tauto pair = pq.pop();\n\t\tresult[k] = pair;\n\t\t\n\t\tif (pair[0] == nums1[n1 - 1] && pair[1] == nums2[n2 - 1])\n\t\t\tcontinue;\n\t\t\n\t\tif (pair[1] == nums2[n2 - 1])\n\t\t\tpq.put(new long[](pair[0] + 1, nums2[0]));\n\t\telse\n\t\t\tpq.put(new long[](pair[0], pair[1] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[][](k);\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = len1 * len2;\n\tauto index = 0;\n\tauto arr = new long[][](len);\n\tforeach(i; 0..len1)\n\t{\n\t\tforeach(j; 0..len2)\n\t\t{\n\t\t\tarr[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tauto compare = (a, b) => \n\t{\n\t\tif(a[0] + a[1] < b[0] + b[1])\n\t\t\treturn -1;\n\t\telse if(a[0] + a[1] > b[0] + b[1])\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t};\n\t\n\tarr.sort(compare);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tresult[i] = arr[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i;\n\tlong j;\n\tlong count;\n\tlong min;\n\tlong min_index;\n\tlong min_index_j;\n\tlong min_index_i;\n\tlong temp_i;\n\tlong temp_j;\n\t\n\tpairs = new long[nums1.length][nums2.length];\n\tresult = new long[nums1.length * nums2.length][2];\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < nums1.length * nums2.length; i++)\n\t{\n\t\tmin = pairs[0][0];\n\t\tmin_index_i = 0;\n\t\tmin_index_j = 0;\n\t\tfor (j = 0; j < nums1.length; j++)\n\t\t{\n\t\t\tfor (count = 0; count < nums2.length; count++)\n\t\t\t{\n\t\t\t\tif (pairs[j][count] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = pairs[j][count];\n\t\t\t\t\tmin_index_i = j;\n\t\t\t\t\tmin_index_j = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i][0] = nums1[min_index_i];\n\t\tresult[i][1] = nums2[min_index_j];\n\t\tpairs[min_index_i][min_index_j] = pairs[min_index_i][min_index_j] + 1;\n\t}\n\t\n\tif (k < nums1.length * nums2.length)\n\t{\n\t\ttemp = new long[k][2];\n\t",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1]);\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tresult = new long[][](k);\n\tforeach (i; 0 .. k) \n\t{\n\t\tauto curr = pq.get;\n\t\tresult[i] = [curr[0], curr[1]];\n\t\tif (curr[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put([curr[0], nums2[curr[2] + 1], curr[2] + 1]);\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_len = nums1.length;\n\tauto nums2_len = nums2.length;\n\t\n\tif (nums1_len == 0 || nums2_len == 0)\n\t\treturn [];\n\t\n\tauto len = min(nums1_len * nums2_len, k);\n\tauto res = new long[][len];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tpq.put([nums1[0], nums2[0]]);\n\t\n\tforeach (i; 0 .. len)\n\t{\n\t\tauto pair = pq.pop();\n\t\tres[i] = pair;\n\t\t\n\t\tif (pair[0] + 1 < nums1_len)\n\t\t\tpq.put([pair[0] + 1, pair[1]]);\n\t\t\n\t\tif (pair[0] == 0 && pair[1] + 1 < nums2_len)\n\t\t\tpq.put([pair[0], pair[1] + 1]);\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j, l;\n\t\n\tresult = new long[][](k);\n\ttemp = new long[][](nums1.length * nums2.length);\n\t\n\tl = 0;\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp[l] = [nums1[i], nums2[j]];\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\ttemp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto heap = new Heap!(Tuple!(long, long, long))(Tuple!(long, long, long).init, (a, b) => a[2] > b[2]);\n\tforeach(i; 0 .. min(k, nums1.length))\n\t\theap.push(tuple(i, 0, nums1[i] + nums2[0]));\n\t\n\tauto result = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif(t[1] + 1 < nums2.length)\n\t\t\theap.push(tuple(t[0], t[1] + 1, nums1[t[0]] + nums2[t[1] + 1]));\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. min(k, len1))\n\t{\n\t\tminHeap.add(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\tauto index = 0;\n\twhile(index < k && minHeap.length > 0)\n\t{\n\t\tauto pair = minHeap.pop();\n\t\tresult[index] = [pair[0], pair[1]];\n\t\tauto nextIndex = pair[2] + 1;\n\t\tif (nextIndex < len2)\n\t\t{\n\t\t\tminHeap.add(tuple(pair[0], nums2[nextIndex], nextIndex));\n\t\t}\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor(int i = 0; i < len; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m, min_index, min_value, min_value_index;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin_value = pairs[0][0] + pairs[0][1];\n\t\tmin_value_index = 0;\n\t\t\n\t\tfor (j = 1; j < n * m; j++)\n\t\t{\n\t\t\tif (pairs[j][0] + pairs[j][1] < min_value)\n\t\t\t{\n\t\t\t\tmin_value = pairs[j][0] + pairs[j][1];\n\t\t\t\tmin_value_index = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i] = pairs[min_value_index];\n\t\tpairs[min_value_index] = [long.max, long.max];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[][] temp2;\n\tlong i;\n\tlong j;\n\tlong m;\n\tlong n;\n\tlong l;\n\tlong min;\n\tlong min_index;\n\tlong min_index2;\n\tlong min_index3;\n\tlong min_index4;\n\tlong min_index5;\n\tlong min_index6;\n\tlong min_index7;\n\tlong min_index8;\n\tlong min_index9;\n\tlong min_index10;\n\tlong min_index11;\n\tlong min_index12;\n\tlong min_index13;\n\tlong min_index14;\n\tlong min_index15;\n\tlong min_index16;\n\tlong min_index17;\n\tlong min_index18;\n\tlong min_index19;\n\tlong min_index20;\n\tlong min_index21;\n\tlong min_index22;\n\tlong min_index23;\n\tlong min_index24;\n\tlong min_index25;\n\tlong min_index26;\n\tlong min_index27;\n\tlong min_index28;\n\tlong min_index29;\n\tlong min_index30;\n\tlong min_index31;\n\tlong min_index32;\n\tlong min_index33;\n\tlong min_index34;\n\tlong min_index35;\n\tlong min_index36;\n\tlong min_index37;\n\tlong min_index38;\n\tlong min_index39;\n\tlong min_index40;\n\tlong min_index41;\n\tlong min_index42;\n\tlong min_index43;\n\tlong min_index44;\n\tlong min_index45;\n\tlong min_index46;\n\tlong min_index47;\n\tlong min_index48;\n\tlong min_index49;\n\tlong min_index50;\n\tlong min_index51;\n\tlong min_index52;\n\tlong min_index53;\n\tlong min_index54;\n\tlong min_index55;\n\tlong min_index56;\n\tlong min_index57;",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\tlong[] temp;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tsort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](min(k, n * m));\n\t\n\tfor (i = 0; i < min(k, n * m); i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tlong[][] visited = new long[][](nums1.length, nums2.length);\n\tvisited[0][0] = 1;\n\t\n\tlong count = 0;\n\twhile (count < k && !pq.empty) \n\t{\n\t\tauto cur = pq.get();\n\t\tres[count][0] = cur[0];\n\t\tres[count][1] = cur[1];\n\t\tcount++;\n\t\t\n\t\tlong next_x = cur[0] == nums1[0] ? 1 : 0;\n\t\tlong next_y = cur[1] == nums2[0] ? 1 : 0;\n\t\t\n\t\tif (next_x < nums1.length && visited[next_x][cur[1]] == 0) \n\t\t{\n\t\t\tpq.put(new long[](nums1[next_x], cur[1]));\n\t\t\tvisited[next_x][cur[1]] = 1;\n\t\t}\n\t\t\n\t\tif (next_y < nums2.length && visited[cur[0]][next_y] == 0) \n\t\t{\n\t\t\tpq.put(new long[](cur[0], nums2[next_y]));\n\t\t\tvisited[cur[0]][next_y] = 1;\n\t\t}\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(long[])();\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tauto pair = [nums1[i], nums2[j]];\n\t\t\tpq.put(pair);\n\t\t\tif(pq.size > k)\n\t\t\t\tpq.get();\n\t\t}\n\t}\n\t\n\tauto res = new long[][](pq.size);\n\t\n\tforeach(i; 0 .. pq.size)\n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t\tres[i] = pq.pop().array;\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong n1 = nums1.length;\n\tlong n2 = nums2.length;\n\tlong i, j;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tforeach (i; 0 .. n1)\n\t\tforeach (j; 0 .. n2)\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\n\tsort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tif (k > n1 * n2)\n\t\tk = n1 * n2;\n\t\n\tresult = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t\tresult[i] = pairs[i];\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[][](k);\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto index = new long[len1];\n\twhile (k-- > 0) \n\t{\n\t\tlong sum = long.max;\n\t\tlong pos = -1;\n\t\tfor (long i = 0; i < len1; i++) \n\t\t{\n\t\t\tif (index[i] >= len2)\n\t\t\t\tcontinue;\n\t\t\tif (nums1[i] + nums2[index[i]] < sum) \n\t\t\t{\n\t\t\t\tsum = nums1[i] + nums2[index[i]];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\tresult[$-k] = [nums1[pos], nums2[index[pos]]];\n\t\tindex[pos]++;\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong[] pair;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach (n1; nums1)\n\t{\n\t\tforeach (n2; nums2)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = n1;\n\t\t\tpair[1] = n2;\n\t\t\tpairs[i] = pair;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\ttemp = pairs.dup;\n\t\n\tstd.algorithm.sort!((a, b) => a[0] + a[1] < b[0] + b[1])(temp);\n\t\n\tresult = new long[][](k);\n\t\n\ti = 0;\n\tforeach (p; temp)\n\t{\n\t\tif (i >= k)\n\t\t\tbreak;\n\t\tresult[i] = p;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\tauto result = new long[][](n, 2);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tfor (long i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto pair = pq.get();\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[0] == nums1[0] && pair[1] < nums2[n2 - 1])\n\t\t\tpq.put(new long[](pair[0], nums2[pair[1] + 1]));\n\t\t\n\t\tif (pair[0] < nums1[n1 - 1] && pair[1] == nums2[0])\n\t\t\tpq.put(new long[](nums1[pair[0] + 1], pair[1]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tforeach (j; 0 .. min(k, nums2.length))\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto comp = (a, b) { return a[0] + a[1] < b[0] + b[1]; };\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t\tpq.put(top);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0) return [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tminHeap.insert([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tauto res = long[][](k);\n\tauto idx = 0;\n\twhile (idx < k && !minHeap.empty)\n\t{\n\t\tauto [a, b, j] = minHeap.pop;\n\t\tres[idx++] = [a, b];\n\t\tif (j == n2 - 1) continue;\n\t\tminHeap.insert([a, nums2[j + 1], j + 1]);\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = n1 * n2;\n\tauto pairs = new long[][](n);\n\tauto cnt = 0;\n\tforeach(i, nums1)\n\t{\n\t\tforeach(j, nums2)\n\t\t{\n\t\t\tpairs[cnt] = [nums1[i], nums2[j]];\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\tauto res = new long[][](k);\n\tauto min_heap = new MinHeap!(long[])();\n\tforeach(i, pairs)\n\t{\n\t\tif(min_heap.length < k)\n\t\t{\n\t\t\tmin_heap.push(pairs[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pairs[i][0] + pairs[i][1] < min_heap.top()[0] + min_heap.top()[1])\n\t\t\t{\n\t\t\t\tmin_heap.pop();\n\t\t\t\tmin_heap.push(pairs[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, min_heap)\n\t{\n\t\tres[i] = min_heap[i];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] tmp;\n\tlong[] tmp2;\n\tlong i, j;\n\t\n\tresult = new long[][](k);\n\ttmp = new long[][](nums1.length * nums2.length);\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\ttmp[i * nums2.length + j] = new long[2];\n\t\t\ttmp[i * nums2.length + j][0] = nums1[i];\n\t\t\ttmp[i * nums2.length + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttmp2 = new long[tmp.length];\n\t\n\tfor (i = 0; i < tmp.length; i++)\n\t{\n\t\ttmp2[i] = tmp[i][0] + tmp[i][1];\n\t}\n\t\n\ttmp2 = tmp2.sort();\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tfor (j = 0; j < tmp.length; j++)\n\t\t{\n\t\t\tif (tmp2[i] == tmp[j][0] + tmp[j][1])\n\t\t\t{\n\t\t\t\tresult[i] = tmp[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto comp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.front[0] + pq.front[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto result = new long[][](k);\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tfor (int i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pairs = new long[][](nums1.length * nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[i * nums2.length + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\treturn pairs[0 .. min(k, pairs.length)];\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto pq = PriorityQueue!(long[], \"a[0] + a[1]\")(n1 * n2);\n\t\n\tforeach (i; 0 .. n1)\n\t\tforeach (j; 0 .. n2)\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t\tres[i] = pq.get();\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] temp;\n\tlong i, j, l;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\tl = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp = new long[2];\n\t\t\ttemp[0] = nums1[i];\n\t\t\ttemp[1] = nums2[j];\n\t\t\tpairs[l] = temp;\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[k][];\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new MinHeap!(tuple!(long, long, long, long));\n\tauto res = new long[][](k);\n\t\n\tif(n == 0 || m == 0)\n\t\treturn res;\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile(k > 0)\n\t{\n\t\tauto t = heap.pop();\n\t\tres[t[3]] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif(t[2] + 1 < m)\n\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, t[3] + 1));\n\t\t\n\t\tif(t[2] == 0 && t[1] + 1 < n)\n\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], t[3] + 1));\n\t\t\n\t\tk--;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto result = new long[][](k);\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto index = new long[n1];\n\t\n\twhile (k-- > 0) \n\t{\n\t\tlong min_val = long.max;\n\t\tlong min_index = -1;\n\t\t\n\t\tfor (long i = 0; i < n1; i++) \n\t\t{\n\t\t\tif (index[i] >= n2)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (nums1[i] + nums2[index[i]] < min_val) \n\t\t\t{\n\t\t\t\tmin_val = nums1[i] + nums2[index[i]];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (min_index == -1)\n\t\t\tbreak;\n\t\t\n\t\tresult[$-k] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[][](0);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1) continue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i, j, l, m, n;\n\t\n\tl = nums1.length;\n\tm = nums2.length;\n\tn = l * m;\n\t\n\tpairs = new long[][](n, 2);\n\t\n\tfor (i = 0; i < l; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j][0] = nums1[i];\n\t\t\tpairs[i * m + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttemp = new long[][](k, 2);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\ttemp[i][0] = pairs[i][0];\n\t\ttemp[i][1] = pairs[i][1];\n\t}\n\t\n\tfor (i = k; i < n; i++)\n\t{\n\t\tfor (j = 0; j < k; j++)\n\t\t{\n\t\t\tif (pairs[i][0] + pairs[i][1] < temp[j][0] + temp[j][1])\n\t\t\t{\n\t\t\t\ttemp[j][0] = pairs[i][0];\n\t\t\t\ttemp[j][1] = pairs[i][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn temp;\n}",
    "{\n\tlong[][] result = new long[k][2];\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1]);\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto curr = pq.get;\n\t\tresult[i] = [curr[0], curr[1]];\n\t\tif (curr[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([curr[0], nums2[curr[2] + 1], curr[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor (size_t i = 0; i < len; i++) \n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto heap = new Heap!(tuple!(long, long, long));\n\t\n\tforeach (i, num1; nums1)\n\t{\n\t\theap.push(tuple(num1, nums2[0], 0));\n\t\tif (heap.length > k)\n\t\t\theap.pop();\n\t}\n\t\n\tresult = new long[][](heap.length);\n\t\n\tforeach (i, t; heap)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = t[0];\n\t\tresult[i][1] = t[1];\n\t\t\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\theap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t\theap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](min(k, n * m));\n\t\n\tfor (i = 0; i < min(k, n * m); i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long), \"a[0] > b[0]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i] + nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto p = pq.get;\n\t\tresult[i] = [nums1[p[1]], nums2[p[2]]];\n\t\t\n\t\tif (p[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[p[1]] + nums2[p[2] + 1], p[1], p[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length, 2);\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i][0] = n1;\n\t\t\tpairs[i][1] = n2;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => (a[0] + a[1]) < (b[0] + b[1]))(pairs);\n\t\n\tresult = new long[][](k, 2);\n\tfor(i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = pairs[i][0];\n\t\tresult[i][1] = pairs[i][1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto max = n1 * n2;\n\t\n\tif (k > max)\n\t\tk = max;\n\t\n\tauto result = new long[][](k);\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tfor (auto i = 0; i < n1; i++)\n\t{\n\t\tfor (auto j = 0; j < n2; j++)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t}\n\t}\n\t\n\tfor (auto i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i][0] = n1;\n\t\t\tpairs[i][1] = n2;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\tfor(i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pairs = new long[][](nums1.length * nums2.length);\n\t\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\treturn pairs[0 .. min(k, pairs.length)];\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = n1 * n2;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == n1 - 1)\n\t\t{\n\t\t\tif (t[3] != n2 - 1)\n\t\t\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t\t\tif (t[3] != n2 - 1)\n\t\t\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, l;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\tl = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[l] = [nums1[i], nums2[j]];\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[k][];\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0) \n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i) \n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1) \n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach(num1; nums1)\n\t{\n\t\tforeach(num2; nums2)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = num1;\n\t\t\tpair[1] = num2;\n\t\t\tpairs[i] = pair;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\ti = 0;\n\tforeach(pair; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\t\n\t\tresult[i] = pair;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach(i; 0..min(len1, k))\n\t{\n\t\tminHeap.push(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tif(minHeap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto top = minHeap.pop;\n\t\tresult[i] = [top[0], top[1]];\n\t\t\n\t\tif(top[2] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(top[0], nums2[top[2] + 1], top[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif (len1 == 0 || len2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(long[])(HeapDirection.Min);\n\t\n\tforeach (i; 0 .. min(k, len1))\n\t\theap.insert([nums1[i], nums2[0], 0]);\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto pair = heap.pop;\n\t\tresult[i] = pair[0 .. 2];\n\t\t\n\t\tif (pair[2] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\theap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[nums1.length * nums2.length][2];\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i][0] = n1;\n\t\t\tpairs[i][1] = n2;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[k][2];\n\t\n\ti = 0;\n\tforeach(p; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\tresult[i] = p;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t\tpq.put(top);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpq.put(top);\n\t\t\t}\n\t\t}\n\t\n\tresult = new long[][](pq.length);\n\t\n\tforeach (i; 0 .. pq.length)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put(new long[] { nums1[i], nums2[0], 0 });\n\t\n\tlong[][] res = new long[][](k);\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto pair = pq.poll();\n\t\tif (pair is null)\n\t\t\tbreak;\n\t\tres[i] = pair[0 .. 2];\n\t\tif (pair[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[] { pair[0], nums2[pair[2] + 1], pair[2] + 1 });\n\t}\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp",
    "{\n\tlong[][] res;\n\tlong[][] pairs;\n\tlong[][] tmp;\n\tlong i, j, m, n, p, q;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tpairs = new long[][](m * n);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tpairs[i * n + j] = new long[2];\n\t\t\tpairs[i * n + j][0] = nums1[i];\n\t\t\tpairs[i * n + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttmp = new long[][](k);\n\tfor (i = 0; i < k; i++)\n\t{\n\t\ttmp[i] = new long[2];\n\t}\n\t\n\tp = 0;\n\tq = 0;\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tfor (j = 0; j < m * n; j++)\n\t\t{\n\t\t\tif (pairs[j][0] + pairs[j][1] < tmp[p][0] + tmp[p][1])\n\t\t\t{\n\t\t\t\ttmp[p][0] = pairs[j][0];\n\t\t\t\ttmp[p][1] = pairs[j][1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tmp[p][0] + tmp[p][1] == tmp[q][0] + tmp[q][1])\n\t\t{\n\t\t\tp++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tq++;\n\t\t}\n\t}\n\t\n\tres = new long[][](q);\n\tfor (i = 0; i < q; i++)\n\t{\n\t\tres[i] = new long[2];\n\t\tres[i][0] = tmp[i][0];\n\t\tres[i][1] = tmp[i][1];",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tpq.put([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tfor (long i = 0; i < n1 && i < k; i++)\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty(); i++)\n\t{\n\t\tauto pair = pq.get();\n\t\tresult[i] = new long[](pair[0], pair[1]);\n\t\tauto next = pair[2] + 1;\n\t\tif (next < n2)\n\t\t\tpq.put(new long[](pair[0], nums2[next], next));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\tauto minHeap = MinHeap!(long[2])();\n\tforeach (i; 0 .. min(k, n1))\n\t\tminHeap.insert([nums1[i], nums2[0], 0]);\n\tauto result = new long[][2](k);\n\tauto count = 0;\n\twhile (count < k && !minHeap.empty) \n\t{\n\t\tauto pair = minHeap.pop;\n\t\tresult[count] = pair[0 .. 2];\n\t\tcount++;\n\t\tif (pair[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1]);\n\t}\n\treturn result[0 .. count];\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\tforeach(i, nums1)\n\t\tforeach(j, nums2)\n\t\t\tpairs ~= [nums1[i], nums2[j]];\n\t\t\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(i, 0 .. k)\n\t\tresult[i] = pairs[i];\n\t\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[n1];\n\tauto count = 0;\n\twhile(count < k && count < n1 * n2) \n\t{\n\t\tauto min_val = long.max;\n\t\tauto min_index = -1;\n\t\tfor(auto i = 0; i < n1; i++) \n\t\t{\n\t\t\tif(index[i] < n2 && nums1[i] + nums2[index[i]] < min_val) \n\t\t\t{\n\t\t\t\tmin_val = nums1[i] + nums2[index[i]];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\tresult[count] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t\tcount++;\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tauto pair = pq.peek;\n\t\t\t\tif (pair[0] + pair[1] > nums1[i] + nums2[j]) \n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tresult = new long[][](pq.length);\n\tforeach (i; 0 .. pq.length) \n\t{\n\t\tresult[i] = pq.get;\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n1, n2, n;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = n1 * n2;\n\t\n\tpairs = new long[][](n);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tif (k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(long[2])();\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tminHeap.insert([nums1[0], nums2[0]]);\n\t\t\n\t\tauto pair = minHeap.pop();\n\t\t\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[1] < nums2[n2 - 1])\n\t\t\tminHeap.insert([pair[0], pair[1] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[][](n1, n2);\n\tauto cmp = (a, b) => (nums1[a[0]] + nums2[a[1]]) < (nums1[b[0]] + nums2[b[1]]);\n\tauto pq = new PriorityQueue!(cmp)();\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tpq.put([i, j]);\n\t\t\tif(pq.size > k)\n\t\t\t\tpq.pop();\n\t\t}\n\t}\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto p = pq.pop();\n\t\tresult[i] = [nums1[p[0]], nums2[p[1]]];\n\t}\n\treturn result;\n}",
    "{\n\tauto heap = new Heap!(Tuple!(long, long, long));\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\theap.push(tuple(nums1[i] + nums2[j], i, j));\n\t\t}\n\t}\n\t\n\tlong[][] result;\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\tauto t = heap.pop;\n\t\tresult ~= [t[1], t[2]];\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. min(n1, k))\n\t{\n\t\tmin_heap.push(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif (min_heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto pair = min_heap.pop;\n\t\tresult[i] = [pair[0], pair[1]];\n\t\t\n\t\tif (pair[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tmin_heap.push(tuple(pair[0], nums2[pair[2] + 1], pair[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\tif(pq.size > k)\n\t\t\t{\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray();\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) \n\t\treturn [];\n\tif (k == 0) \n\t\treturn [];\n\t\n\tauto heap = new Heap!(long[])(true);\n\t\n\tauto first = new long[2];\n\tfirst[0] = nums1[0];\n\tfirst[1] = nums2[0];\n\theap.insert(first);\n\t\n\tauto visited = new bool[n1, n2];\n\tvisited[0] = true;\n\t\n\tauto result = new long[][];\n\twhile (k > 0 && heap.length > 0) \n\t{\n\t\tauto pair = heap.pop();\n\t\tresult ~= pair;\n\t\tk--;\n\t\t\n\t\tauto i = pair[0];\n\t\tauto j = pair[1];\n\t\t\n\t\tif (i + 1 < n1 && !visited[i + 1, j]) \n\t\t{\n\t\t\tauto next = new long[2];\n\t\t\tnext[0] = nums1[i + 1];\n\t\t\tnext[1] = nums2[j];\n\t\t\theap.insert(next);\n\t\t\tvisited[i + 1, j] = true;\n\t\t}\n\t\t\n\t\tif (j + 1 < n2 && !visited[i, j + 1]) \n\t\t{\n\t\t\tauto next = new long[2];\n\t\t\tnext[0] = nums1[i];\n\t\t\tnext[1] = nums2[j + 1];\n\t\t\theap.insert(next);\n\t\t\tvisited[i, j + 1] = true;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](0);\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(\n\t\t\t\t\t\t\t\t\t(a, b) => a[0] + a[1] < b[0] + b[1],\n\t\t\t\t\t\t\t\t\t(a, b) => a[0] + a[1] > b[0] + b[1]\n\t\t\t\t\t\t\t\t)();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= tuple(t[0], t[1]);\n\t\tauto idx = t[2];\n\t\tif (idx == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[idx + 1], idx + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n1;\n\tlong n2;\n\tlong n;\n\tlong m;\n\tlong c;\n\tlong l;\n\tlong r;\n\tlong m1;\n\tlong m2;\n\tlong t;\n\tlong[][] tmp;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = min(n1, n2);\n\tm = max(n1, n2);\n\t\n\tif (n == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tpairs = new long[n][2];\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tpairs[i][0] = i;\n\t\tpairs[i][1] = i;\n\t}\n\t\n\tif (k > n * m)\n\t{\n\t\tk = n * m;\n\t}\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tl = 0;\n\t\tr = n - 1;\n\t\t\n\t\twhile (l < r)\n\t\t{\n\t\t\tm1 = (l + r) / 2;\n\t\t\tm2 = (l + r) / 2;\n\t\t\t\n\t\t\tif (nums1[pairs[m1][0]] + nums2[pairs[m1][1]] < nums1[pairs[m2][0]] + nums2[pairs[m2][1]])\n\t\t\t{\n\t\t\t\tr = m2 - 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl = m1 + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i][0] = nums1[pairs[l][0]];\n\t\tresult[i][1] = nums2[pairs[l][1]];\n\t\t\n\t\tif",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] > b[0] + b[1]);\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\t\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\t\n\tlong idx = 0;\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[idx][0] = nums1[i];\n\t\t\tpairs[idx][1] = nums2[j];\n\t\t\tidx++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i][0] = pairs[i][0];\n\t\tres[i][1] = pairs[i][1];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto heap = new Heap!(long[2], \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\t}\n\t}\n\t\n\tauto result = new long[][2][];\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult ~= heap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tforeach (j; 0 .. min(k, n2))\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t\tminHeap.insert([nums1[i] + nums2[j], i, j]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < minHeap.top[0])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop;\n\t\t\t\t\tminHeap.insert([nums1[i] + nums2[j], i, j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](minHeap.length);\n\t\n\tforeach (i; 0 .. minHeap.length)\n\t{\n\t\tresult[i] = minHeap.pop[1 .. $];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto cmp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\tauto pq = new PriorityQueue!(cmp)();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pq.toArray();\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\t\n\tpairs = new long[nums1.length * nums2.length][2];\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[i * nums2.length + j][0] = nums1[i];\n\t\t\tpairs[i * nums2.length + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\tpairs = pairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] distances;\n\tlong[] distances_sorted;\n\tlong[] distances_sorted_indexes;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong d;\n\tlong d_min;\n\tlong d_min_index;\n\tlong d_min_index_tmp;\n\tlong d_min_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto minHeap = new MinHeap!(long[2]);\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn [];\n\t\n\tforeach (i; 0 .. n)\n\t{\n\t\tif (i < k)\n\t\t\tminHeap.insert([nums1[i], nums2[0]]);\n\t\telse\n\t\t\tbreak;\n\t}\n\t\n\tauto result = new long[][2](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto pair = minHeap.pop();\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[1] < nums2[m - 1])\n\t\t{\n\t\t\tauto next = [pair[0], pair[1] + 1];\n\t\t\tminHeap.insert(next);\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i, j, m, n, p, q, r, s, t, u;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tpairs[i * nums2.length + j] = new long[2];\n\t\t\tpairs[i * nums2.length + j][0] = nums1[i];\n\t\t\tpairs[i * nums2.length + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttemp = new long[][](pairs.length);\n\t\n\tfor (i = 0; i < pairs.length; i++)\n\t{\n\t\ttemp[i] = new long[2];\n\t\ttemp[i][0] = pairs[i][0];\n\t\ttemp[i][1] = pairs[i][1];\n\t}\n\t\n\tfor (i = 0; i < pairs.length; i++)\n\t{\n\t\tfor (j = i + 1; j < pairs.length; j++)\n\t\t{\n\t\t\tif (pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1])\n\t\t\t{\n\t\t\t\tm = pairs[i][0];\n\t\t\t\tn = pairs[i][1];\n\t\t\t\tpairs[i][0] = pairs[j][0];\n\t\t\t\tpairs[i][1] = pairs[j][1];\n\t\t\t\tpairs[j][0] = m;\n\t\t\t\tpairs[j][1] = n;\n\t\t\t}\n\t\t}\n\t",
    "{\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put(new long[] { nums1[i], nums2[j] });\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.poll();\n\t\t\t\t\tpq.put(new long[] { nums1[i], nums2[j] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray();\n}",
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn new long[][] {};\n\tif (k == 0)\n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(new long[] {nums1[i], nums2[0], 0});\n\t}\n\t\n\tauto res = new long[][](k);\n\tint i = 0;\n\twhile (i < k && !pq.empty())\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i++] = new long[] {cur[0], cur[1]};\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[] {cur[0], nums2[cur[2] + 1], cur[2] + 1});\n\t}\n\treturn res[0 .. i];\n}",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([t[0], nums2[t[2] + 1], t[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long, long, long)[](), Tuple!(long, long, long, long)[]());\n\t\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile (k > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[t[3]] = tuple(nums1[t[1]], nums2[t[2]]);\n\t\tif (t[1] + 1 < nums1.length) pq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], t[3] + 1));\n\t\tif (t[2] + 1 < nums2.length) pq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, t[3] + 1));\n\t\tk--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res;\n\tlong i, j, n1, n2;\n\tlong[][] pairs;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tforeach(i; 0 .. n1)\n\t\tforeach(j; 0 .. n2)\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tres = new long[][](min(k, n1 * n2));\n\t\n\tforeach(i; 0 .. min(k, n1 * n2))\n\t\tres[i] = pairs[i];\n\t\n\treturn res;\n}",
    "{\n\tlong[][] res;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tres = new long[][](k);\n\t\n\tfor(i = 0; i < k; i++)\n\t{\n\t\tres[i] = pairs[i];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] res;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\n\tres = new long[][](k);\n\tforeach (i; 0 .. k)\n\t\tres[i] = pq.get();\n\t\n\treturn res;\n}",
    "{\n\tlong[][] res = new long[k][2];\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn res;\n\t\n\tlong[][] arr = new long[nums1.length][nums2.length];\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tarr[i][j] = num1 + num2;\n\t\t}\n\t}\n\t\n\tauto cmp = (a, b) => a[0] > b[0];\n\t\n\tauto pq = new PriorityQueue!(cmp)();\n\tforeach(i, num1; nums1)\n\t{\n\t\tpq.put([arr[i][0], i, 0]);\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [nums1[t[1]], nums2[t[2]]];\n\t\tif(t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([arr[t[1]][t[2] + 1], t[1], t[2] + 1]);\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tauto res = new long[][](k);\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j], i, j));\n\t\t\tif(pq.size() > k)\n\t\t\t\tpq.get();\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [t[0], t[1]];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\tif(pq.size() > k)\n\t\t\t\tpq.poll();\n\t\t}\n\t}\n\treturn pq.toArray();\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long), \"a[0] + b[0]\");\n\tauto result = new long[][](k);\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\theap.insert(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = heap.popFront();\n\t\tresult[i] = [t[1], t[0]];\n\t\t\n\t\tif (t[2] == 0 && t[3] + 1 < m)\n\t\t\theap.insert(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t\n\t\tif (t[2] + 1 < n)\n\t\t\theap.insert(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tres ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\treturn res;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto heap = new Heap!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[0] + a[1]\");\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\theap.insert(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = heap.popFront();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] < m - 1)\n\t\t{\n\t\t\theap.insert(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[] temp_array;\n\tlong i;\n\tlong j;\n\tlong m;\n\tlong n;\n\tlong count;\n\tlong index;\n\tlong min;\n\tlong min_index;\n\tlong temp_index;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tif (m == 0 || n == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](k);\n\ttemp = new long[][](m);\n\ttemp_array = new long[m];\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\ttemp[i] = new long[2];\n\t\ttemp[i][0] = nums1[i];\n\t\ttemp[i][1] = nums2[0];\n\t\ttemp_array[i] = nums2[0] + nums1[i];\n\t}\n\t\n\tcount = 0;\n\twhile (count < k)\n\t{\n\t\tmin = temp_array[0];\n\t\tmin_index = 0;\n\t\tfor (i = 1; i < m; i++)\n\t\t{\n\t\t\tif (temp_array[i] < min)\n\t\t\t{\n\t\t\t\tmin = temp_array[i];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[count] = new long[2];\n\t\tresult[count][0] = temp[min_index][0];\n\t\tresult[count][1] = temp[min_index][1];\n\t\t\n\t\tindex = temp[min_index][1];\n\t\tif (index == nums2[n - 1])\n\t\t{\n\t\t\ttemp_array[min_index] = long.max;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tindex++;\n\t\t\ttemp[min_index][1] = nums2[index];\n\t\t\ttemp_array[min_index] = nums1[min",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(long[])();\n\tauto visited = new bool[len1][len2];\n\t\n\tminHeap.push([nums1[0], nums2[0]]);\n\tvisited[0][0] = true;\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !minHeap.empty; ++i)\n\t{\n\t\tauto pair = minHeap.pop;\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[0] < nums1[len1 - 1] && pair[1] < nums2[len2 - 1])\n\t\t{\n\t\t\tauto nextX = min(len1 - 1, lower_bound(nums1, pair[0] + 1));\n\t\t\tauto nextY = min(len2 - 1, lower_bound(nums2, pair[1] + 1));\n\t\t\t\n\t\t\tif (!visited[nextX][nextY])\n\t\t\t{\n\t\t\t\tminHeap.push([nums1[nextX], nums2[nextY]]);\n\t\t\t\tvisited[nextX][nextY] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (pair[0] < nums1[len1 - 1])\n\t\t{\n\t\t\tauto nextX = min(len1 - 1, lower_bound(nums1, pair[0] + 1));\n\t\t\tif (!visited[nextX][0])\n\t\t\t{\n\t\t\t\tminHeap.push([nums1[nextX], nums2[0]]);\n\t\t\t\tvisited[nextX][0] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (pair[1] < nums2[len2 - 1])\n\t\t{\n\t\t\tauto nextY",
    "{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]{};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\t\t\tpq.put(top);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpq.put(top);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto res = new long[][]();\n\twhile (pq.length > 0)\n\t\tres ~= pq.get();\n\t\n\treturn res;\n}",
    "{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pq.toArray();\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong l;\n\tlong r;\n\tlong mid;\n\tlong count;\n\tlong[][] temp1;\n\tlong[][] temp2;\n\tlong[][] temp3;\n\tlong[][] temp4;\n\tlong[][] temp5;\n\tlong[][] temp6;\n\tlong[][] temp7;\n\tlong[][] temp8;\n\tlong[][] temp9;\n\tlong[][] temp10;\n\tlong[][] temp11;\n\tlong[][] temp12;\n\tlong[][] temp13;\n\tlong[][] temp14;\n\tlong[][] temp15;\n\tlong[][] temp16;\n\tlong[][] temp17;\n\tlong[][] temp18;\n\tlong[][] temp19;\n\tlong[][] temp20;\n\tlong[][] temp21;\n\tlong[][] temp22;\n\tlong[][] temp23;\n\tlong[][] temp24;\n\tlong[][] temp25;\n\tlong[][] temp26;\n\tlong[][] temp27;\n\tlong[][] temp28;\n\tlong[][] temp29;\n\tlong[][] temp30;\n\tlong[][] temp31;\n\tlong[][] temp32;\n\tlong[][] temp33;\n\tlong[][] temp34;\n\tlong[][] temp35;\n\tlong[][] temp36;\n\tlong[][] temp37;\n\tlong[][] temp38;\n\tlong[][] temp39;\n\tlong[][] temp40;\n\tlong[][] temp41;\n\tlong[][] temp42;\n\tlong[][] temp43;\n\tlong[][] temp44;\n\tlong[][] temp45;\n\tlong[][] temp46;\n\tlong[][] temp47;\n\tlong[][] temp48;\n\tlong[][] temp49;\n\tlong[][",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tpq.put([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] > b[0]\");\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tfor (long i = 0; i < min(k, n1); i++)\n\t\tpq.put(tuple(nums1[i] + nums2[0], i, 0, nums1[i]));\n\t\n\tfor (long i = 0; i < k; i++)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = t[3];\n\t\tresult[i][1] = nums2[t[2]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, nums1[t[1]]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor (long i = 0; i < len; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(tuple(long, long, long))(tuple(nums1[0], nums2[0], 0), (a, b) => a[0] + a[1] > b[0] + b[1]);\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tauto t = heap.pop();\n\t\t\n\t\tif (i == k)\n\t\t\tbreak;\n\t\t\n\t\tif (t[2] < n2 - 1)\n\t\t\theap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn heap.map!(t => [t[0], t[1]]).array;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[n1];\n\t\n\tfor(long i = 0; i < k && i < n1 * n2; i++)\n\t{\n\t\tlong min_val = long.max;\n\t\tlong min_index = -1;\n\t\tfor(long j = 0; j < n1; j++)\n\t\t{\n\t\t\tif(index[j] < n2 && nums1[j] + nums2[index[j]] < min_val)\n\t\t\t{\n\t\t\t\tmin_val = nums1[j] + nums2[index[j]];\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\tresult[i] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\theap.insert(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor(long i = 0; i < k && !heap.empty; i++)\n\t{\n\t\tauto t = heap.popFront;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[2] == 0 && t[3] + 1 < n2)\n\t\t\theap.insert(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\tif(t[2] + 1 < n1)\n\t\t\theap.insert(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long));\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile (k > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[t[3]] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[2] == 0 && t[1] + 1 < n1)\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], t[3] + 1));\n\t\t\n\t\tif (t[2] + 1 < n2)\n\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, t[3] + 1));\n\t\t\n\t\tk--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong min;\n\tlong min_i;\n\tlong min_j;\n\tlong[][] tmp;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpairs = new long[n][m];\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin = pairs[0][0];\n\t\tmin_i = 0;\n\t\tmin_j = 0;\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tfor (long l = 0; l < m; l++)\n\t\t\t{\n\t\t\t\tif (pairs[j][l] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = pairs[j][l];\n\t\t\t\t\tmin_i = j;\n\t\t\t\t\tmin_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i][0] = nums1[min_i];\n\t\tresult[i][1] = nums2[min_j];\n\t\tpairs[min_i][min_j] = long.max;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn res;\n\t\n\tfor (long i = 0; i < min(k, n1); i++)\n\t\tpq.put(new long[]{nums1[i], nums2[0], 0});\n\t\n\tfor (long i = 0; i < k && !pq.empty(); i++)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = new long[]{cur[0], cur[1]};\n\t\t\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(new long[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(tuple!(long, long, long, long));\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && heap.length > 0; i++)\n\t{\n\t\tauto t = heap.pop();\n\t\t\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[3] == 0)\n\t\t{\n\t\t\tif (t[1] + 1 < n1)\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 0));\n\t\t\t\n\t\t\tif (t[2] + 1 < n2)\n\t\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (t[2] + 1 < n2)\n\t\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(tuple!(long, long, long));\n\theap.push(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\tfor(int i = 0; i < k && !heap.empty; ++i)\n\t{\n\t\tauto t = heap.pop;\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\tif(t[2] == 0 && t[1] + 1 < n1)\n\t\t\theap.push(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\tif(t[2] + 1 < n2)\n\t\t\theap.push(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(Tuple!(long, long, long)));\n\t\n\tforeach (i; 0 .. min(k, n))\n\t{\n\t\tminHeap.push(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto top = minHeap.pop();\n\t\tresult[i] = [nums1[top[1]], nums2[top[2]]];\n\t\t\n\t\tif (top[2] == m - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(nums1[top[1]] + nums2[top[2] + 1], top[1], top[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 0 .. m)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.top;\n\t\t\t\tif(top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.pop;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. min(nums1.length, k))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= [cur[0], cur[1]];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\tauto pq = new PriorityQueue!((a, b) => a[0] + a[1] > b[0] + b[1]);\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([t[0], nums2[t[2] + 1], t[2] + 1]);\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong i;\n\tlong j;\n\tlong x;\n\tlong y;\n\tlong z;\n\tlong t;\n\tlong m;\n\tlong n;\n\tlong p;\n\tlong q;\n\tlong r;\n\tlong s;\n\tlong a;\n\tlong b;\n\tlong c;\n\tlong d;\n\tlong e;\n\tlong f;\n\tlong g;\n\tlong h;\n\tlong l;\n\tlong o;\n\tlong u;\n\tlong v;\n\tlong w;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto result = new long[][](k);\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + b[0]\", \"a[1] < b[1]\");\n\t\n\tforeach(i; 0 .. min(k, n))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == m - 1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tpq.put(tuple(num1, num2, i, j));\n\t\t\tif(pq.length > k)\n\t\t\t\tpq.popFront();\n\t\t}\n\t}\n\t\n\tauto res = new long[][](pq.length);\n\tforeach(i, t; pq)\n\t{\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = t[2];\n\t\tres[i][1] = t[3];\n\t}\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[n1];\n\tauto count = 0;\n\twhile(count < k && count < n1 * n2)\n\t{\n\t\tauto min_val = long.max;\n\t\tauto min_index = long.max;\n\t\tfor(auto i = 0; i < n1; i++)\n\t\t{\n\t\t\tif(index[i] < n2 && nums1[i] + nums2[index[i]] < min_val)\n\t\t\t{\n\t\t\t\tmin_val = nums1[i] + nums2[index[i]];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\tresult[count] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t\tcount++;\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i, j;\n\tlong n1 = nums1.length;\n\tlong n2 = nums2.length;\n\tlong n = n1 * n2;\n\tlong m = min(k, n);\n\t\n\tpairs = new long[][](n, 2);\n\tresult = new long[][](m, 2);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpairs[i * n2 + j][0] = nums1[i];\n\t\t\tpairs[i * n2 + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttemp = pairs[0 .. m];\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(temp);\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n * m))\n\t\tpq.put([nums1[i / m], nums2[i % m]]);\n\t\n\tforeach (i; 0 .. k)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach (i; 0 .. min(k, nums1.length * nums2.length))\n\t{\n\t\tpq.put(new long[](nums1[i / nums2.length], nums2[i % nums2.length]));\n\t}\n\t\n\tauto result = new long[][](pq.length);\n\t\n\tforeach (i; 0 .. pq.length)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tpairs[i * nums2.length + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\theap.insert([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; k .. n1 * n2)\n\t{\n\t\tauto top = heap.top;\n\t\tif (nums1[i / n2] + nums2[i % n2] < top[0] + top[1])\n\t\t{\n\t\t\theap.pop;\n\t\t\theap.insert([nums1[i / n2], nums2[i % n2]]);\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = heap.pop;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = n1 * n2;\n\tauto arr = new long[][](n);\n\tauto idx = 0;\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tarr[idx] = [nums1[i], nums2[j]];\n\t\t\tidx++;\n\t\t}\n\t}\n\tarr.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\treturn arr[0 .. k];\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto pairs = new long[][](len, 2);\n\t\n\tfor (size_t i = 0; i < len; i++)\n\t{\n\t\tpairs[i][0] = nums1[i];\n\t\tpairs[i][1] = nums2[i];\n\t}\n\t\n\treturn pairs;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tlong[][] tmp = new long[][](nums1.length * nums2.length);\n\tlong i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttmp[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\ttmp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\tfor(long j = 0; j < k; j++)\n\t{\n\t\tres[j] = tmp[j];\n\t}\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong len;\n\tlong len1;\n\tlong len2;\n\tlong min;\n\tlong min_index;\n\tlong min_index1;\n\tlong min_index2;\n\tlong min_index3;\n\tlong min_index4;\n\tlong min_index5;\n\tlong min_index6;\n\tlong min_index7;\n\tlong min_index8;\n\tlong min_index9;\n\tlong min_index10;\n\tlong min_index11;\n\tlong min_index12;\n\tlong min_index13;\n\tlong min_index14;\n\tlong min_index15;\n\tlong min_index16;\n\tlong min_index17;\n\tlong min_index18;\n\tlong min_index19;\n\tlong min_index20;\n\tlong min_index21;\n\tlong min_index22;\n\tlong min_index23;\n\tlong min_index24;\n\tlong min_index25;\n\tlong min_index26;\n\tlong min_index27;\n\tlong min_index28;\n\tlong min_index29;\n\tlong min_index30;\n\tlong min_index31;\n\tlong min_index32;\n\tlong min_index33;\n\tlong min_index34;\n\tlong min_index35;\n\tlong min_index36;\n\tlong min_index37;\n\tlong min_index38;\n\tlong min_index39;\n\tlong min_index40;\n\tlong min_index41;\n\tlong min_index42;\n\tlong min_index43;\n\tlong min_index44;\n\tlong min_index45;\n\tlong min_index46;\n\tlong min_index47;\n\tlong min_index48;\n\tlong min_index49;\n\tlong min_index50;\n\tlong min_index51;\n\tlong min_index52;\n\tlong min_index53;\n\tlong min_index54;\n\tlong min_",
    "{\n\tauto pq = PriorityQueue!(long[], \"a[0] + a[1]\")(nums1.length * nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t}\n\t}\n\t\n\tlong[][] result;\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(pq.empty)\n\t\t\tbreak;\n\t\tresult ~= pq.get;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tpq.put(tuple(n1, n2, i, j));\n\t\t\tif(pq.length > k)\n\t\t\t\tpq.pop();\n\t\t}\n\t}\n\t\n\tauto res = new long[][](pq.length);\n\tforeach(i, t; pq)\n\t\tres[i] = [t[0], t[1]];\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[k][2];\n\tlong[][] pairs = new long[nums1.length * nums2.length][2];\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index][0] = nums1[i];\n\t\t\tpairs[index][1] = nums2[j];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, m, n;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tresult = new long[][](k);\n\ttemp = new long[m];\n\t\n\tfor (i = 0; i < m; i++)\n\t\ttemp[i] = nums1[i] + nums2[0];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tlong min = temp[0];\n\t\tlong min_index = 0;\n\t\t\n\t\tfor (j = 1; j < m; j++)\n\t\t{\n\t\t\tif (temp[j] < min)\n\t\t\t{\n\t\t\t\tmin = temp[j];\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[min_index];\n\t\tresult[i][1] = nums2[0];\n\t\t\n\t\tif (nums2.length == 1)\n\t\t\ttemp[min_index] = long.max;\n\t\telse\n\t\t{\n\t\t\ttemp[min_index] = nums1[min_index] + nums2[1];\n\t\t\tnums2 = nums2[1 .. $];\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0) \n\t\treturn new long[][]{};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, nums1.length * nums2.length)) \n\t{\n\t\tpq.put(new long[]{nums1[i / nums2.length], nums2[i % nums2.length]});\n\t}\n\t\n\tauto result = new long[][](k);\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[])();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, l, m;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tfor (i = 0; i < nums1.length && i < k; i++)\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t\n\twhile (k-- > 0 && pq.length > 0)\n\t{\n\t\ttemp = pq.get();\n\t\tif (result.length == 0)\n\t\t\tresult ~= temp[0..1];\n\t\telse\n\t\t\tresult ~= temp[0..1];\n\t\t\n\t\tif (temp[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(new long[](temp[0], nums2[temp[2] + 1], temp[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 0 .. m)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.top;\n\t\t\t\tif(top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.pop;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\theap.insert([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; k .. n1 * n2)\n\t{\n\t\tauto [a, b] = heap.top;\n\t\tif (nums1[i / n2] + nums2[i % n2] < a + b)\n\t\t{\n\t\t\theap.pop;\n\t\t\theap.insert([nums1[i / n2], nums2[i % n2]]);\n\t\t}\n\t}\n\t\n\treturn heap.data[0 .. $];\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m, p;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tp = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[p][0] = nums1[i];\n\t\t\tpairs[p][1] = nums2[j];\n\t\t\tp++;\n\t\t}\n\t}\n\t\n\tsort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = pairs[i][0];\n\t\tresult[i][1] = pairs[i][1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, m, n;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tpairs = new long[][](m * n);\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tpairs[i * n + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n1;\n\tlong n2;\n\tlong n;\n\tlong m;\n\tlong[][] temp;\n\tlong[][] temp2;\n\tlong[][] temp3;\n\tlong[][] temp4;\n\tlong[][] temp5;\n\tlong[][] temp6;\n\tlong[][] temp7;\n\tlong[][] temp8;\n\tlong[][] temp9;\n\tlong[][] temp10;\n\tlong[][] temp11;\n\tlong[][] temp12;\n\tlong[][] temp13;\n\tlong[][] temp14;\n\tlong[][] temp15;\n\tlong[][] temp16;\n\tlong[][] temp17;\n\tlong[][] temp18;\n\tlong[][] temp19;\n\tlong[][] temp20;\n\tlong[][] temp21;\n\tlong[][] temp22;\n\tlong[][] temp23;\n\tlong[][] temp24;\n\tlong[][] temp25;\n\tlong[][] temp26;\n\tlong[][] temp27;\n\tlong[][] temp28;\n\tlong[][] temp29;\n\tlong[][] temp30;\n\tlong[][] temp31;\n\tlong[][] temp32;\n\tlong[][] temp33;\n\tlong[][] temp34;\n\tlong[][] temp35;\n\tlong[][] temp36;\n\tlong[][] temp37;\n\tlong[][] temp38;\n\tlong[][] temp39;\n\tlong[][] temp40;\n\tlong[][] temp41;\n\tlong[][] temp42;\n\tlong[][] temp43;\n\tlong[][] temp44;\n\tlong[][] temp45;\n\tlong[][] temp46;\n\tlong[][] temp47;\n\tlong[][] temp48;\n\tlong[][] temp49;\n\tlong[][] temp50;\n\tlong[][] temp51;\n\tlong[",
    "{\n\tlong[][] result = new long[k][2];\n\tif(nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i][0] = t[0];\n\t\tresult[i][1] = t[1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j, l, m;\n\tlong min;\n\tlong min_index;\n\tlong min_index_i;\n\tlong min_index_j;\n\tlong[][] arr;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tarr = new long[nums1.length][nums2.length];\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tarr[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin = arr[0][0];\n\t\tmin_index_i = 0;\n\t\tmin_index_j = 0;\n\t\tfor (j = 0; j < nums1.length; j++)\n\t\t{\n\t\t\tfor (l = 0; l < nums2.length; l++)\n\t\t\t{\n\t\t\t\tif (arr[j][l] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = arr[j][l];\n\t\t\t\t\tmin_index_i = j;\n\t\t\t\t\tmin_index_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i][0] = nums1[min_index_i];\n\t\tresult[i][1] = nums2[min_index_j];\n\t\tarr[min_index_i][min_index_j] = long.max;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\t\n\tforeach(i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tfor (long i = 0; i < n1 && i < k; i++) \n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty(); i++) \n\t{\n\t\tauto cur = pq.pop();\n\t\tres[i] = new long[](cur[0], cur[1]);\n\t\t\n\t\tif (cur[2] == n2 - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tauto minHeap = new MinHeap!(long[2]);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.push([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse if (nums1[i] + nums2[j] < minHeap.top[0] + minHeap.top[1])\n\t\t\t{\n\t\t\t\tminHeap.pop;\n\t\t\t\tminHeap.push([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](minHeap.length);\n\t\n\tforeach (i; 0 .. minHeap.length)\n\t{\n\t\tresult[i] = minHeap.pop;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j, n;\n\t\n\tn = nums1.length;\n\tpairs = new long[][](n);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tpairs[i] = new long[nums2.length];\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tpairs = pairs.sort();\n\t\n\tresult = new long[][](k);\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tpair = new long[2];\n\t\tpair[0] = nums1[i];\n\t\tpair[1] = nums2[i];\n\t\tresult[i] = pair;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](), Tuple!(long, long)(nums1[0], nums2[0]));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put(Tuple!(long, long)(nums1[i], nums2[j]));\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto curr = pq.peek;\n\t\t\t\tif (nums1[i] + nums2[j] < curr[0] + curr[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(Tuple!(long, long)(nums1[i], nums2[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto curr = pq.get();\n\t\tresult[i] = [curr[0], curr[1]];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tfor (int i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto t = pq.get;\n\t\t\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length, nums2.length);\n\t\n\tforeach (i, nums1)\n\t{\n\t\tforeach (j, nums2)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tpairs = pairs.sort();\n\t\n\tresult = new long[][](k);\n\t\n\tforeach (i, result)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto result = new long[][](k);\n\t\n\tauto minHeap = new MinHeap!(Pair!(long, long))(k);\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 0 .. m)\n\t\t{\n\t\t\tif(minHeap.size() < k)\n\t\t\t{\n\t\t\t\tminHeap.push(Pair!(long, long)(nums1[i] + nums2[j], i * m + j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < minHeap.top().first)\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop();\n\t\t\t\t\tminHeap.push(Pair!(long, long)(nums1[i] + nums2[j], i * m + j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto p = minHeap.top();\n\t\tminHeap.pop();\n\t\tresult[i] = [nums1[p.second / m], nums2[p.second % m]];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(long[])();\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t\theap.put([nums1[i / n2], nums2[i % n2]]);\n\t\n\tforeach (i; k .. n1 * n2)\n\t{\n\t\tauto pair = [nums1[i / n2], nums2[i % n2]];\n\t\tif (pair[0] + pair[1] < heap.peek()[0] + heap.peek()[1])\n\t\t{\n\t\t\theap.pop();\n\t\t\theap.put(pair);\n\t\t}\n\t}\n\t\n\treturn heap.toArray();\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tif (pq.empty) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[][](0);\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult ~= heap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\t\n\tauto result = new long[][](n);\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = PriorityQueue!(long[2], \"a[0] + a[1]\")(k);\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([n1, n2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(n1 + n2 < pq.peek[0] + pq.peek[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([n1, n2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pq.data;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i][0] = n1;\n\t\t\tpairs[i][1] = n2;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\ti = 0;\n\tforeach(p; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\t\n\t\tresult[i] = p;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i, e1; nums1)\n\t{\n\t\tforeach (j, e2; nums2)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t\tminHeap.push(tuple(e1, e2, i, j));\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = minHeap.top;\n\t\t\t\tif (top[0] + top[1] > e1 + e2)\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop;\n\t\t\t\t\tminHeap.push(tuple(e1, e2, i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](minHeap.length);\n\t\n\tforeach (i, e; minHeap)\n\t{\n\t\tresult[i] = [e[0], e[1]];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tres = new long[][](k);\n\t\n\ti = 0;\n\tforeach(pair; pairs)\n\t{\n\t\tres[i] = pair;\n\t\ti++;\n\t\tif(i == k)\n\t\t\tbreak;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto arr = new long[][](nums1.length, nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tarr[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tauto sorted = arr.sort!((a, b) => a[0] < b[0]);\n\t\n\treturn sorted[0 .. min(k, sorted.length)];\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto comp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\t\n\tauto pq = new PriorityQueue!(typeof(comp))(comp);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.peek;\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i] = pq.get;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor(long i = 0; i < len; i++)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = PriorityQueue!(long[], \"a[0] + a[1]\")(nums1.length);\n\tforeach(i, e; nums1)\n\t{\n\t\tforeach(j, f; nums2)\n\t\t{\n\t\t\tpq.put([e, f]);\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) \n\t\treturn [];\n\t\n\tauto heap = new Heap!(tuple!(long, long, long, long));\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (auto i = 0; i < k && !heap.empty; i++) \n\t{\n\t\tauto t = heap.popFront;\n\t\t\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == 0 && t[3] + 1 < n2) \n\t\t\theap.insert(tuple(nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1, t[3] + 1));\n\t\t\n\t\tif (t[2] + 1 < n1) \n\t\t\theap.insert(tuple(nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[n1];\n\tauto count = 0;\n\t\n\twhile(count < k && count < n1 * n2)\n\t{\n\t\tauto min_val = long.max;\n\t\tauto min_index = -1;\n\t\t\n\t\tfor(auto i = 0; i < n1; i++)\n\t\t{\n\t\t\tif(index[i] < n2 && nums1[i] + nums2[index[i]] < min_val)\n\t\t\t{\n\t\t\t\tmin_val = nums1[i] + nums2[index[i]];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[count] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t\tcount++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tlong[][] result;\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1])();\n\tforeach(i; 0 .. len)\n\t{\n\t\tpq.put([nums1[i], nums2[i]]);\n\t}\n\twhile(k-- > 0 && !pq.empty())\n\t{\n\t\tresult ~= pq.get();\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](n1 * n2);\n\tauto index = 0;\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tresult[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tauto compare = (a, b) => a[0] + a[1] < b[0] + b[1];\n\tresult.sort(compare);\n\treturn result[0 .. min(k, result.length)];\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](n1 * n2);\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. n1)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tauto cur = pq.get();\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] temp;\n\tlong i, j, m, n, count;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tpairs = new long[][](m * n);\n\t\n\tcount = 0;\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tpairs[count][0] = nums1[i];\n\t\t\tpairs[count][1] = nums2[j];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\ttemp = new long[2];\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tfor (j = i + 1; j < count; j++)\n\t\t{\n\t\t\tif (pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1])\n\t\t\t{\n\t\t\t\ttemp[0] = pairs[i][0];\n\t\t\t\ttemp[1] = pairs[i][1];\n\t\t\t\t\n\t\t\t\tpairs[i][0] = pairs[j][0];\n\t\t\t\tpairs[i][1] = pairs[j][1];\n\t\t\t\t\n\t\t\t\tpairs[j][0] = temp[0];\n\t\t\t\tpairs[j][1] = temp[1];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](k);\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = pairs[i][0];\n\t\tresult[i][1] = pairs[i][1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j, n1, n2;\n\tlong min, min_i, min_j;\n\tlong count;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = nums1[i];\n\t\t\tpair[1] = nums2[j];\n\t\t\tpairs[i * n2 + j] = pair;\n\t\t}\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tfor (count = 0; count < k; count++)\n\t{\n\t\tmin = pairs[0][0] + pairs[0][1];\n\t\tmin_i = 0;\n\t\tmin_j = 0;\n\t\t\n\t\tfor (i = 0; i < n1; i++)\n\t\t{\n\t\t\tfor (j = 0; j < n2; j++)\n\t\t\t{\n\t\t\t\tif (pairs[i * n2 + j][0] + pairs[i * n2 + j][1] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = pairs[i * n2 + j][0] + pairs[i * n2 + j][1];\n\t\t\t\t\tmin_i = i;\n\t\t\t\t\tmin_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[count] = pairs[min_i * n2 + min_j];\n\t\tpairs[min_i * n2 + min_j][0] = max(nums1) + 1;\n\t\tpairs[min_i * n2 + min_j][1] = max(nums2) + 1;\n\t}\n",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] temp = new long[][](nums1.length * nums2.length);\n\tlong count = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp[count] = [nums1[i], nums2[j]];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\ttemp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[][](k);\n\tauto size = nums1.length * nums2.length;\n\tif(k > size)\n\t\tk = size;\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")(size);\n\tforeach(i, e1; nums1)\n\t\tforeach(j, e2; nums2)\n\t\t\theap.insert([e1, e2]);\n\tforeach(i; 0 .. k)\n\t\tresult[i] = heap.pop();\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tlong[] pair;\n\tlong i = 0, j = 0;\n\twhile (k-- > 0 && !pq.empty()) \n\t{\n\t\tpair = pq.get();\n\t\tresult[i++] = pair;\n\t\tif (pair[1] < nums2[nums2.length - 1])\n\t\t\tpq.put(new long[](pair[0], pair[1] + 1));\n\t\tif (pair[1] == nums2[0] && pair[0] < nums1[nums1.length - 1])\n\t\t\tpq.put(new long[](pair[0] + 1, pair[1]));\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[][](k);\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[0] > b[0]\");\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn res;\n\t\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i][0] = nums1[t[1]];\n\t\tres[i][1] = nums2[t[2]];\n\t\t\n\t\tif (t[1] == n1 - 1)\n\t\t{\n\t\t\tif (t[2] + 1 < n2)\n\t\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t\t}\n\t\telse if (t[2] == 0)\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t\t}\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong[][] heap = new long[][](k);\n\tlong heap_size = 0;\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[i * nums2.length + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\theap[i] = pairs[i];\n\t\theap_size += 1;\n\t}\n\t\n\tforeach(i; (k / 2) .. 0)\n\t{\n\t\theapify(heap, heap_size, i);\n\t}\n\t\n\tforeach(i; k .. pairs.length)\n\t{\n\t\tif(pairs[i][0] + pairs[i][1] < heap[0][0] + heap[0][1])\n\t\t{\n\t\t\theap[0] = pairs[i];\n\t\t\theapify(heap, heap_size, 0);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = heap[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\t// if nums1 is empty, return empty array\n\tif (nums1.length == 0)\n\t\treturn new long[][]();\n\t\n\t// if nums2 is empty, return empty array\n\tif (nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\t// if k is 0, return empty array\n\tif (k == 0)\n\t\treturn new long[][]();\n\t\n\t// if k is greater than nums1 * nums2, return all pairs\n\tif (k > nums1.length * nums2.length)\n\t\tk = nums1.length * nums2.length;\n\t\n\t// create a tuple array to store the sum of the pairs\n\tTuple!(long, long, long)[] sums = new Tuple!(long, long, long)[nums1.length * nums2.length];\n\t\n\t// create a tuple array to store the pairs\n\tTuple!(long, long)[] pairs = new Tuple!(long, long)[nums1.length * nums2.length];\n\t\n\t// create a tuple array to store the k smallest pairs\n\tTuple!(long, long)[] k_smallest_pairs = new Tuple!(long, long)[k];\n\t\n\t// create a long array to store the k smallest sums\n\tlong[] k_smallest_sums = new long[k];\n\t\n\t// create a long array to store the k smallest sums indexes\n\tlong[] k_smallest_sums_indexes = new long[k];\n\t\n\t// create a long array to store the k smallest pairs indexes\n\tlong[] k_smallest_pairs_indexes = new long[k];\n\t\n\t// create a long array to store the k smallest pairs indexes\n\tlong[] k_smallest_pairs_indexes_sorted = new long[k];\n\t\n\t// create a long array to store the k smallest pairs indexes\n\tlong[] k_smallest_pairs_indexes_sorted_reverse = new long[k];\n\t\n\t// create a long array to store the k smallest pairs indexes\n\tlong[] k",
    "{\n\tauto result = new long[][](k);\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")(k);\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(heap.length < k)\n\t\t\t{\n\t\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < heap.front[0] + heap.front[1])\n\t\t\t\t{\n\t\t\t\t\theap.popFront();\n\t\t\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = heap.popFront();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0) \n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n1 * n2)) \n\t{\n\t\tpq.put([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = [cur[0], cur[1]];\n\t\t\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\tlong min_index;\n\tlong min_value;\n\tlong min_value_index;\n\tlong[long] min_values;\n\tlong[long] min_values_index;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n, m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tresult = new long[][](k, 2);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin_values = new long[long](n);\n\t\tmin_values_index = new long[long](n);\n\t\t\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tmin_values[j] = pairs[j][0];\n\t\t\tmin_values_index[j] = 0;\n\t\t}\n\t\t\n\t\tmin_value = min(min_values);\n\t\tmin_value_index = min_values.indexOf(min_value);\n\t\t\n\t\tresult[i][0] = nums1[min_value_index];\n\t\tresult[i][1] = nums2[min_values_index[min_value_index]];\n\t\t\n\t\tmin_values_index[min_value_index]++;\n\t\t\n\t\tif (min_values_index[min_value_index] < m)\n\t\t{\n\t\t\tpairs[min_value_index][min_values_index[min_value_index]] = nums1[min_value_index] + nums2[min_values_index[min_value_index]];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[min_value",
    "{\n\tlong[][] res;\n\tlong[][] heap;\n\tlong heap_size;\n\tlong i;\n\tlong j;\n\tlong[][] tmp;\n\tlong[][] tmp2;\n\tlong[][] tmp3;\n\tlong[][] tmp4;\n\tlong[][] tmp5;\n\tlong[][] tmp6;\n\tlong[][] tmp7;\n\tlong[][] tmp8;\n\tlong[][] tmp9;\n\tlong[][] tmp10;\n\tlong[][] tmp11;\n\tlong[][] tmp12;\n\tlong[][] tmp13;\n\tlong[][] tmp14;\n\tlong[][] tmp15;\n\tlong[][] tmp16;\n\tlong[][] tmp17;\n\tlong[][] tmp18;\n\tlong[][] tmp19;\n\tlong[][] tmp20;\n\tlong[][] tmp21;\n\tlong[][] tmp22;\n\tlong[][] tmp23;\n\tlong[][] tmp24;\n\tlong[][] tmp25;\n\tlong[][] tmp26;\n\tlong[][] tmp27;\n\tlong[][] tmp28;\n\tlong[][] tmp29;\n\tlong[][] tmp30;\n\tlong[][] tmp31;\n\tlong[][] tmp32;\n\tlong[][] tmp33;\n\tlong[][] tmp34;\n\tlong[][] tmp35;\n\tlong[][] tmp36;\n\tlong[][] tmp37;\n\tlong[][] tmp38;\n\tlong[][] tmp39;\n\tlong[][] tmp40;\n\tlong[][] tmp41;\n\tlong[][] tmp42;\n\tlong[][] tmp43;\n\tlong[][] tmp44;\n\tlong[][] tmp45;\n\tlong[][] tmp46;\n\tlong[][] tmp47;\n\tlong[][] tmp48;\n\tlong[][] tmp49;\n\tlong[][] tmp50;\n\tlong[][] tmp51;\n\tlong[][] tmp52;\n\tlong[][] tmp53;\n"
  ]
}