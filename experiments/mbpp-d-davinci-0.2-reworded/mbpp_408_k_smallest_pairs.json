{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) \n\t\treturn new long[][]{};\n\t\n\tauto comp = (long[] a, long[] b) => a[0] + a[1] > b[0] + b[1];\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. min(k, n1)) \n\t{\n\t\tforeach (j; 0 .. min(k, n2)) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray();\n}",
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn new long[][]{};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(new long[]{nums1[i], nums2[0], 0});\n\t\n\tlong[][] res = new long[][](k);\n\tint idx = 0;\n\twhile (idx < k && !pq.empty)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[idx++] = new long[]{cur[0], cur[1]};\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});\n\t}\n\treturn res[0 .. idx];\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\twhile (k-- > 0 && pq.length) \n\t{\n\t\tauto cur = pq.get();\n\t\tresult ~= new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult[i] = cur;\n\t\t\n\t\tif (cur[0] == nums1[n1 - 1] && cur[1] == nums2[n2 - 1])\n\t\t\tcontinue;\n\t\t\n\t\tif (cur[1] == nums2[n2 - 1])\n\t\t\tpq.put(new long[](cur[0] + 1, nums2[0]));\n\t\telse\n\t\t\tpq.put(new long[](cur[0], cur[1] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")(n1 * n2);\n\t\n\tforeach(i; 0 .. n1)\n\t\tforeach(j; 0 .. n2)\n\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto p = heap.popFront();\n\t\tif(p is null)\n\t\t\tbreak;\n\t\tres[i] = p;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j, n;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\tn = 0;\n\tforeach(i; nums1)\n\t{\n\t\tforeach(j; nums2)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = nums1[i];\n\t\t\tpair[1] = nums2[j];\n\t\t\tpairs[n] = pair;\n\t\t\tn++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tforeach(j; 0 .. min(k, nums2.length))\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](pq.length);\n\tforeach(i; 0 .. pq.length)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto heap = new MinHeap!(tuple!(long, long, long, long));\n\t\n\tforeach(i; 0..n)\n\t{\n\t\theap.push(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif(t[3] < m - 1)\n\t\t{\n\t\t\theap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[])();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put(new long[](nums1[i], nums2[j]));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(new long[](nums1[i], nums2[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || (a[2] == b[2] && a[3] < b[3])\");\n\t\n\tforeach (i, e; nums1)\n\t{\n\t\tpq.put(tuple(e, nums2[0], i, 0));\n\t}\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = [t[0], t[1]];\n\t\tif (t[3] == n2 - 1) continue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto result = new long[][](0);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult ~= new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\tif(pq.size > k)\n\t\t\t{\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray;\n}",
    "{\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\tauto result = new long[][](k);\n\t\n\tforeach(i, e; nums1)\n\t{\n\t\theap.insert(tuple(e, nums2[0], i, 0));\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = heap.popFront;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] + 1 < nums2.length)\n\t\t{\n\t\t\theap.insert(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0 || k == 0) \n\t\treturn [];\n\t\n\tauto arr = new long[][](len1, len2);\n\tfor (int i = 0; i < len1; i++) \n\t{\n\t\tfor (int j = 0; j < len2; j++) \n\t\t{\n\t\t\tarr[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tauto res = new long[][](k, 2);\n\tauto visited = new bool[][](len1, len2);\n\tfor (int i = 0; i < k; i++) \n\t{\n\t\tlong min = long.max;\n\t\tint min_i = 0;\n\t\tint min_j = 0;\n\t\tfor (int j = 0; j < len1; j++) \n\t\t{\n\t\t\tfor (int l = 0; l < len2; l++) \n\t\t\t{\n\t\t\t\tif (visited[j][l]) \n\t\t\t\t\tcontinue;\n\t\t\t\tif (arr[j][l] < min) \n\t\t\t\t{\n\t\t\t\t\tmin = arr[j][l];\n\t\t\t\t\tmin_i = j;\n\t\t\t\t\tmin_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres[i][0] = nums1[min_i];\n\t\tres[i][1] = nums2[min_j];\n\t\tvisited[min_i][min_j] = true;\n\t}\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto pairs = new long[][](n1 * n2);\n\tauto index = 0;\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\tforeach(i; 0 .. pairs.length)\n\t{\n\t\tif(count == k)\n\t\t\tbreak;\n\t\tresult[count] = pairs[i];\n\t\tcount++;\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\tlong min_index;\n\tlong min_value;\n\tlong[] min_pair;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tif (k >= n * m)\n\t\treturn pairs;\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin_index = i;\n\t\tmin_value = nums1[i / m] + nums2[i % m];\n\t\t\n\t\tfor (j = i + 1; j < n * m; j++)\n\t\t{\n\t\t\tif (nums1[j / m] + nums2[j % m] < min_value)\n\t\t\t{\n\t\t\t\tmin_index = j;\n\t\t\t\tmin_value = nums1[j / m] + nums2[j % m];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmin_pair = pairs[min_index];\n\t\tpairs[min_index] = pairs[i];\n\t\tpairs[i] = min_pair;\n\t\t\n\t\tresult[i] = min_pair;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 * n2 == 0)\n\t\treturn result;\n\t\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\twhile (k-- > 0)\n\t{\n\t\tauto pair = pq.pop();\n\t\tresult[k] = pair;\n\t\t\n\t\tif (pair[0] == nums1[n1 - 1] && pair[1] == nums2[n2 - 1])\n\t\t\tcontinue;\n\t\t\n\t\tif (pair[1] == nums2[n2 - 1])\n\t\t\tpq.put(new long[](pair[0] + 1, nums2[0]));\n\t\telse\n\t\t\tpq.put(new long[](pair[0], pair[1] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[][](k);\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = len1 * len2;\n\tauto index = 0;\n\tauto arr = new long[][](len);\n\tforeach(i; 0..len1)\n\t{\n\t\tforeach(j; 0..len2)\n\t\t{\n\t\t\tarr[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tauto compare = (a, b) => \n\t{\n\t\tif(a[0] + a[1] < b[0] + b[1])\n\t\t\treturn -1;\n\t\telse if(a[0] + a[1] > b[0] + b[1])\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t};\n\t\n\tarr.sort(compare);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tresult[i] = arr[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i;\n\tlong j;\n\tlong count;\n\tlong min;\n\tlong min_index;\n\tlong min_index_j;\n\tlong min_index_i;\n\tlong temp_i;\n\tlong temp_j;\n\t\n\tpairs = new long[nums1.length][nums2.length];\n\tresult = new long[nums1.length * nums2.length][2];\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < nums1.length * nums2.length; i++)\n\t{\n\t\tmin = pairs[0][0];\n\t\tmin_index_i = 0;\n\t\tmin_index_j = 0;\n\t\tfor (j = 0; j < nums1.length; j++)\n\t\t{\n\t\t\tfor (count = 0; count < nums2.length; count++)\n\t\t\t{\n\t\t\t\tif (pairs[j][count] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = pairs[j][count];\n\t\t\t\t\tmin_index_i = j;\n\t\t\t\t\tmin_index_j = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i][0] = nums1[min_index_i];\n\t\tresult[i][1] = nums2[min_index_j];\n\t\tpairs[min_index_i][min_index_j] = pairs[min_index_i][min_index_j] + 1;\n\t}\n\t\n\tif (k < nums1.length * nums2.length)\n\t{\n\t\ttemp = new long[k][2];\n\t"
  ]
}