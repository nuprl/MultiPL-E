{
  "name": "mbpp_92_is_undulating",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to check whether the given number is undulating or not.\n\t\n*/\nbool is_undulating(long n) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = is_undulating;\n\n    assert(candidate(1212121L) == true);\n    assert(candidate(1991L) == false);\n    assert(candidate(121L) == true);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tif (n < 100)\n\t\treturn false;\n\t\n\tint last_digit = n % 10;\n\tn /= 10;\n\tint second_last_digit = n % 10;\n\tn /= 10;\n\t\n\tbool is_increasing = second_last_digit > last_digit;\n\t\n\twhile (n > 0)\n\t{\n\t\tlast_digit = second_last_digit;\n\t\tsecond_last_digit = n % 10;\n\t\tn /= 10;\n\t\t\n\t\tif (is_increasing)\n\t\t{\n\t\t\tif (second_last_digit < last_digit)\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (second_last_digit > last_digit)\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\tis_increasing = !is_increasing;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = to!(string)(n);\n\tauto len = digits.length;\n\tif (len < 3) return false;\n\t\n\tauto odd = true;\n\tfor (int i = 0; i < len - 2; i++)\n\t{\n\t\tif (odd)\n\t\t{\n\t\t\tif (digits[i] != digits[i + 2]) return false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (digits[i] == digits[i + 2]) return false;\n\t\t}\n\t\todd = !odd;\n\t}\n\treturn true;\n}",
    "{\n\tauto digits = to!string(n);\n\tauto digits_len = digits.length;\n\t\n\tif (digits_len < 3)\n\t\treturn false;\n\t\n\tfor (size_t i = 0; i < digits_len - 2; i++)\n\t{\n\t\tif (digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2])\n\t\t\treturn false;\n\t\t\n\t\tif (digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2])\n\t\t\tcontinue;\n\t\t\n\t\tif (digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2])\n\t\t\tcontinue;\n\t\t\n\t\treturn false;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tif (n < 100)\n\t\treturn false;\n\t\n\tint prev_digit = n % 10;\n\tn /= 10;\n\tint cur_digit = n % 10;\n\tn /= 10;\n\t\n\twhile (n > 0)\n\t{\n\t\tint next_digit = n % 10;\n\t\tif (prev_digit != cur_digit && cur_digit != next_digit)\n\t\t\treturn false;\n\t\tprev_digit = cur_digit;\n\t\tcur_digit = next_digit;\n\t\tn /= 10;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = to!(string)(n);\n\tauto len = digits.length;\n\tif (len < 3) return false;\n\t\n\tfor (int i = 0; i < len - 2; i++)\n\t{\n\t\tif (digits[i] == digits[i + 2])\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "{\n\tint[] digits = to!(int[])(n.to!string).map!(a => a.to!int).array;\n\tint[] diffs = new int[digits.length - 1];\n\tforeach (i, d; digits)\n\t{\n\t\tif (i < digits.length - 1)\n\t\t{\n\t\t\tdiffs[i] = abs(digits[i] - digits[i + 1]);\n\t\t}\n\t}\n\t\n\treturn diffs.all!(a => a == 1);\n}",
    "{\n\tint odd = 0;\n\tint even = 0;\n\tint last_digit = 0;\n\tint curr_digit = 0;\n\t\n\twhile(n > 0) \n\t{\n\t\tcurr_digit = n % 10;\n\t\tif(last_digit != 0) \n\t\t{\n\t\t\tif(curr_digit > last_digit) \n\t\t\t{\n\t\t\t\todd++;\n\t\t\t}\n\t\t\telse if(curr_digit < last_digit) \n\t\t\t{\n\t\t\t\teven++;\n\t\t\t}\n\t\t}\n\t\tlast_digit = curr_digit;\n\t\tn /= 10;\n\t}\n\t\n\treturn (odd == even);\n}",
    "{\n\tauto digits = n.to!string().map!(a => a.to!int()).array;\n\tauto odd = digits.filter!(a => a % 2 == 1);\n\tauto even = digits.filter!(a => a % 2 == 0);\n\tif (odd.length == 0 || even.length == 0)\n\t\treturn false;\n\treturn odd.sum == even.sum;\n}",
    "{\n\tauto digits = to!string(n);\n\tbool is_undulating = true;\n\tfor (size_t i = 0; i < digits.length - 1; i++) {\n\t\tif (digits[i] == digits[i + 1]) {\n\t\t\tis_undulating = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn is_undulating;\n}",
    "{\n\tlong[] digits = to!(long[])(n.to!string.map!(a => a.to!long));\n\t\n\tif (digits.length < 3)\n\t\treturn false;\n\t\n\tint i = 0;\n\twhile (i < digits.length - 2)\n\t{\n\t\tif (digits[i] == digits[i + 2])\n\t\t\treturn true;\n\t\ti++;\n\t}\n\t\n\treturn false;\n}",
    "{\n\tauto digits = n.to!string.split(\"\").map!(a => a.to!long).array;\n\t\n\tif (digits.length < 3)\n\t\treturn false;\n\t\n\tauto is_increasing = digits[0] < digits[1];\n\t\n\tforeach (i, d; digits)\n\t{\n\t\tif (i == 0 || i == digits.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tif (is_increasing)\n\t\t{\n\t\t\tif (d > digits[i + 1])\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tif (d < digits[i - 1])\n\t\t\t\tis_increasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (d < digits[i + 1])\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tif (d > digits[i - 1])\n\t\t\t\tis_increasing = true;\n\t\t}\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = to!string(n);\n\t\n\tif (digits.length < 3) \n\t\treturn false;\n\t\n\tbool is_increasing = digits[0] < digits[1];\n\t\n\tfor (size_t i = 1; i < digits.length - 1; i++) \n\t{\n\t\tif (is_increasing) \n\t\t{\n\t\t\tif (digits[i] > digits[i + 1]) \n\t\t\t\treturn false;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tif (digits[i] < digits[i + 1]) \n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\tis_increasing = !is_increasing;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = to!(string)(n);\n\tauto even = true;\n\tfor (size_t i = 0; i < digits.length - 1; i++) \n\t{\n\t\tif (digits[i] == digits[i + 1]) \n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (even) \n\t\t{\n\t\t\tif (digits[i] > digits[i + 1]) \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} \n\t\telse \n\t\t{\n\t\t\tif (digits[i] < digits[i + 1]) \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\teven = !even;\n\t}\n\treturn true;\n}",
    "{\n\tauto digits = to!string(n);\n\tauto len = digits.length;\n\tif (len < 3) return false;\n\t\n\tfor (int i = 0; i < len - 2; i++)\n\t{\n\t\tif (digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2])\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tif (n < 100) \n\t\treturn false;\n\t\n\tauto digits = to!(string)(n);\n\t\n\tint len = digits.length;\n\t\n\tfor (int i = 0; i < len - 2; i++) \n\t{\n\t\tif (digits[i] == digits[i + 2]) \n\t\t\treturn true;\n\t}\n\t\n\treturn false;\n}",
    "{\n\tif (n < 100)\n\t\treturn false;\n\t\n\tauto digits = to!(immutable(int[]))(n);\n\t\n\tfor (size_t i = 0; i < digits.length - 2; i++)\n\t{\n\t\tif (digits[i] % 2 == 0 && digits[i + 1] % 2 == 0)\n\t\t\treturn false;\n\t\t\n\t\tif (digits[i] % 2 == 1 && digits[i + 1] % 2 == 1)\n\t\t\treturn false;\n\t\t\n\t\tif (digits[i] == digits[i + 1])\n\t\t\treturn false;\n\t\t\n\t\tif (abs(digits[i] - digits[i + 1]) != abs(digits[i + 1] - digits[i + 2]))\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tif (n < 100) return false;\n\t\n\tauto digits = to!(immutable(int))(n);\n\t\n\tint prev = digits[0];\n\tint curr = digits[1];\n\t\n\tbool increasing = curr > prev;\n\t\n\tfor (int i = 2; i < digits.length; i++) \n\t{\n\t\tprev = curr;\n\t\tcurr = digits[i];\n\t\t\n\t\tif (increasing) \n\t\t{\n\t\t\tif (curr < prev) \n\t\t\t{\n\t\t\t\tincreasing = false;\n\t\t\t}\n\t\t\telse if (curr == prev) \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif (curr > prev) \n\t\t\t{\n\t\t\t\tincreasing = true;\n\t\t\t}\n\t\t\telse if (curr == prev) \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true;\n}",
    "{\n\tbool result = false;\n\tint last_digit = 0;\n\tint current_digit = 0;\n\tint count = 0;\n\t\n\twhile(n != 0)\n\t{\n\t\tcurrent_digit = n % 10;\n\t\tif(last_digit != 0)\n\t\t{\n\t\t\tif(last_digit > current_digit)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse if(last_digit < current_digit)\n\t\t\t{\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tlast_digit = current_digit;\n\t\tn /= 10;\n\t}\n\t\n\tif(count == 0)\n\t{\n\t\tresult = true;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto digits = to!(string)(n);\n\tauto d = digits.length;\n\t\n\tif (d < 3)\n\t\treturn false;\n\t\n\tfor (int i = 0; i < d - 2; i++)\n\t{\n\t\tif (digits[i] == digits[i + 2])\n\t\t\treturn true;\n\t}\n\t\n\treturn false;\n}",
    "{\n\tauto digits = to!string(n);\n\t\n\tforeach(i, d; digits) \n\t{\n\t\tif (i % 2 == 0) \n\t\t{\n\t\t\tif (d >= digits[i + 1]) \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} \n\t\telse \n\t\t{\n\t\t\tif (d <= digits[i + 1]) \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true;\n}"
  ]
}