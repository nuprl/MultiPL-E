{
  "name": "mbpp_735_toggle_middle_bits",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a dthon function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\n\t\n*/\nlong toggle_middle_bits(long n) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = toggle_middle_bits;\n\n    assert(candidate(9L) == 15L);\n    assert(candidate(10L) == 12L);\n    assert(candidate(11L) == 13L);\n    assert(candidate(65L) == 127L);\n    assert(candidate(77L) == 115L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bit_length() - 1));\n\tlong mask = (1 << (n.bit_length() - 2)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bit_length() - 2)) | last_bit;\n}",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 2)); \n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\t// get the first and last bits \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 2)); \n\tlong rest = n & ~(1 | (1 << (int.sizeof * 8 - 2))); \n\trest = rest ^ (rest >> 1); \n\treturn (first | rest | last); \n} ",
    "{ \n\t// Get the first and last bit \n\t// of the number \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 1)); ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long rest = n & ~(1 | (1 << (int.sizeof * 8 - 2))); \n    rest = rest ^ (rest >> 1); \n    return first | rest | last; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_bits = (long)log2(n) + 1; \n\t\n\t// XOR the number with a number that has all \n\t// bits toggled except the first and the last \n\t// bits. \n\treturn n ^ ((1 << num_bits) - 1); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\tlong result = first_bit | middle_bits | last_bit; \n\treturn result; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bit_size - 1)); \n\tlong mask = (1 << (n.bit_size - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = (n >> 1) & 1; \n\tlong last_bit = (n >> (n.bitSize - 2)) & 1; \n\tlong mask = (1 << (n.bitSize - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit << 1) | (middle_bits << 1) | last_bit; \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n  \n    // XOR of first and last bits \n    long x = first_bit ^ last_bit; \n  \n    // XOR of x with all other bits of n \n    return (n ^ x); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return first | mid | last; \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 2)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = ~middle_bits; \n    middle_bits = middle_bits & mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    // Get the first and last bit \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n  \n    // Get the middle bits \n    long middle_bits = n & ~(1 | (1 << (n.bitSize - 1))); \n  \n    // Toggle the middle bits \n    middle_bits = middle_bits ^ (middle_bits >> 1); \n  \n    // Put the first and last bit back \n    middle_bits = middle_bits | first_bit; \n    middle_bits = middle_bits | last_bit; \n  \n    return middle_bits; \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n    mask = mask ^ (1 << 1); \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// To get the first and last bit \n\t// of the number \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// To get the middle bits of the number \n\tlong middle_bits = n & ~(1 << (sizeof(n) * 8 - 1)); \n\tmiddle_bits = middle_bits & ~1; \n\t\n\t// To toggle the middle bits \n\tmiddle_bits = middle_bits ^ (~0); \n\t\n\t// To get the result \n\tlong result = middle_bits | first_bit; \n\tresult = result | last_bit; \n\t\n\treturn result; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n    mask = mask - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return (first | middle | last); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle = n & mask; \n\tmiddle = ~middle; \n\treturn (first | middle | last); \n} ",
    "{ \n\treturn (n ^ ((1 << (int)log2(n)) - 1)); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong xor_val = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong xor_num = n ^ xor_val; \n\treturn (xor_num | first_bit | last_bit); \n} ",
    "{ \n\tlong mask = (1L << (n.popCount() - 2)) - 1; \n\treturn n ^ mask; \n} ",
    "{ \n\t// Find the position of the first and last set bit. \n\tlong first_set_bit = log2(n & -n) + 1; \n\tlong last_set_bit = log2(n & ~(n - 1)) + 1; \n\t\n\t// XOR the number with the number obtained by left \n\t// shifting 1 by difference between the first and \n\t// last set bit - 1. \n\treturn n ^ ((1 << (last_set_bit - first_set_bit - 1)) - 1); \n} ",
    "{ \n\tlong mask = (1 << (n.popCount - 2)) - 1; \n\treturn (n ^ mask); \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_bits = floor(log2(n)) + 1; \n\t\n\t// XOR the number with the number with all \n\t// bits flipped except the first and last \n\t// bits. \n\treturn n ^ ((1 << (num_bits - 1)) - 1); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 2)); \n\tlong rest = n & ~(1 << (int.sizeof * 8 - 1)); \n\trest = rest & ~1; \n\trest = rest ^ (rest >> 1); \n\trest = rest & ~(rest >> 1); \n\treturn first | rest | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.digits - 1)); \n\tlong mask = (1 << (n.digits - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long rest = n & ~(1 | (1 << (int.sizeof * 8 - 2))); \n    rest = rest ^ (rest >> 1); \n    return first | (rest << 1) | last; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong x = n & mask; \n\tlong y = x ^ mask; \n\treturn (y | first_bit | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong toggled_middle_bits = n ^ mask; \n\treturn (toggled_middle_bits | first_bit | last_bit); \n} ",
    "{ \n\tlong x = n; \n\tlong y = n; \n\tlong z = n; \n\t\n\t// Get the first bit \n\tlong first = x & 1; \n\t\n\t// Get the last bit \n\tlong last = y & (1 << (int.sizeof * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = z & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (~middle); \n\t\n\t// Combine the bits \n\treturn (first | middle | last); \n} ",
    "{ \n\tlong x = 1; \n\tlong y = n; \n\twhile (y > 0) { \n\t\tx = x << 1; \n\t\ty = y >> 1; \n\t} \n\tx = x - 1; \n\ty = ~(x ^ n); \n\treturn y; \n} ",
    "{ \n\t// Get the first and last bits \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (middle >> 1); \n\t\n\t// Put the first and last bits back \n\tmiddle = middle | (first << (sizeof(n) * 8 - 2)) | last; \n\t\n\treturn middle; \n} ",
    "{ \n\treturn n ^ ((1 << (int)log2(n)) - 1); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong x = n & ~(1 << (sizeof(n) * 8 - 1)); \n\tx = x >> 1; \n\tx = x << 1; \n\tx = x | first_bit; \n\tx = x | last_bit; \n\treturn x; \n} ",
    "{ \n\tlong mask = (1L << (n.popCount - 2)) - 1; \n\treturn (n ^ mask); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Calculate the position of first and last set bit \n\tlong first = log2(n & -n); \n\tlong last = log2(n & ~(n - 1)); \n\t\n\t// XOR the number with [2^first, 2^last] \n\treturn n ^ ((1 << last) - 1) ^ ((1 << first) - 1); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong middle_bits = n & ~(1 | (1 << (n.bitSize - 1))); \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\treturn (n ^ mask) | (first << 1) | last; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (int.sizeof * 8 - 1)); \n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\tn = first_bit | middle_bits | last_bit; \n\treturn n; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong x = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle_bits = n & x; \n\tmiddle_bits = middle_bits ^ x; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(1 | (1 << (sizeof(n) * 8 - 1))); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\t\n\t// Combine the first and last bit with the middle bits \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first = 1; \n\tlong last = n & 1; \n\tlong middle = (n >> 1) & (~(1 << (n.bitSize - 2))); \n\treturn first | (middle ^ (~middle)) | last; \n} ",
    "{ \n\t// Get the first and last bit \n\tint first_bit = n & 1; \n\tint last_bit = n & (1 << (n.bitSize - 1)); ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (middle >> 1); \n\t\n\t// Return the result \n\treturn (first | middle | last); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong middle_bits = n & ~(1 << (n.bitSize - 1)) & ~1;\n\tmiddle_bits = ~middle_bits;\n\treturn first_bit | middle_bits | last_bit;\n}",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// To toggle bits of the number except the first and the last bit \n\t// we can use the following formula \n\t// n ^ ((1 << (n - 1)) - 1) \n\t\n\t// Find the number of bits in the number \n\tlong num_bits = (long)log2(n) + 1; \n\t\n\t// XOR the number with the above formula \n\treturn n ^ ((1 << (num_bits - 1)) - 1); \n} ",
    "{ \n    // Calculate the number of bits \n    long num_bits = floor(log2(n)) + 1; \n  \n    // Calculate the number of bits to be toggled \n    long num_toggled = num_bits - 2; \n  \n    // Calculate the number to be XORed with n \n    long toggled_num = (1 << num_toggled) - 1; \n    toggled_num <<= 1; \n  \n    // XOR the number with toggled_num \n    return n ^ toggled_num; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bit_length() - 1)); \n\tlong mask = (1 << (n.bit_length() - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{\n\tlong mask = (1L << (n.popCount - 2)) - 1;\n\treturn n ^ mask;\n}",
    "{ \n    // Calculate the position of first and last \n    // set bits \n    long first = log2(n & ~(n - 1)); \n    long last = log2(n & ~(n - 1)); \n  \n    // Calculate the position of middle bits \n    long x = (first + last) / 2; \n  \n    // Toggle the middle bits \n    return n ^ ((1 << x) - 1); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\treturn (n ^ mask) | (first << 1) | (last >> 1); \n} ",
    "{ \n\t// Get the first and last bit of the number \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits of the number \n\tlong middle = n & ~(1 | (1 << (n.bitSize - 1))); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (middle >> 1); \n\t\n\t// Merge the first, middle and last bits \n\treturn (first | middle | last); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    return (n ^ mask) | (first << (int.sizeof * 8 - 2)) | last; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Get the first and last bits \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle ^= (1 << (sizeof(middle) * 8 - 1)) - 1; \n\t\n\t// Combine the first, middle and last bits \n\treturn first | middle | last; \n} ",
    "{ \n\t// Get the position of the first and last set bit \n\tlong first = n.trailingZeros; \n\tlong last = n.leadingZeros; \n\t\n\t// If there is only one set bit \n\tif (first == last) \n\t\treturn n; \n\t\n\t// The two sets bits are adjacent, i.e., \n\t// there are no bits between them \n\tif (first + 1 == last) \n\t\treturn n; \n\t\n\t// XOR the number 'n' with a number \n\t// consisting of all 1's except the \n\t// first and last bits \n\treturn n ^ ((1L << last) - 1) ^ ((1L << first) - 1); \n} ",
    "{ \n\t// Get the size of the number \n\tlong size = n.bitSize; \n\t\n\t// Get the first bit \n\tlong first = n.bitAt(0); \n\t\n\t// Get the last bit \n\tlong last = n.bitAt(size - 1); \n\t\n\t// Get the mask for the middle bits \n\tlong mask = (1L << (size - 2)) - 1; \n\t\n\t// Toggle the middle bits \n\tlong middle = (n >> 1) ^ mask; \n\t\n\t// Merge the toggled bits \n\treturn (first << (size - 1)) | (middle << 1) | last; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (int.sizeof * 8 - 2)); \n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\tn = (first_bit | middle_bits | last_bit); \n\treturn n; \n} ",
    "{ \n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t\n\t// To toggle all bits except first and last \n\t// we can",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\treturn (n ^ mask) | (first << 1) | (last >> 1); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong middle_bits = n & ~(first_bit | last_bit);\n\treturn first_bit | (middle_bits ^ (middle_bits >> 1)) | last_bit;\n}",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n    mask = mask ^ (1 << 0); \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return (first | middle | last); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(1 << (n.bitSize - 1)) & ~1; \n\t\n\t// Toggle the middle bits \n\tmiddle_bits ^= (1 << (n.bitSize - 2)) - 1; \n\t\n\t// Update the first and last bit \n\tmiddle_bits |= first_bit << (n.bitSize - 1); \n\tmiddle_bits |= last_bit >> (n.bitSize - 1); \n\t\n\treturn middle_bits; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (int.sizeof * 8 - 2)); \n\tlong x = n >> 1; \n\tx = x ^ (x >> 1); \n\tx = x ^ (x >> 2); \n\tx = x ^ (x >> 4); \n\tx = x ^ (x >> 8); \n\tx = x ^ (x >> 16); \n\tx = x ^ (x >> 32); \n\tx = x & ~(x >> 1); \n\tx = x | (first_bit << 1); \n\tx = x | last_bit; \n\treturn x; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// calculating the number of bits \n\tint num_bits = (int)log2(n) + 1; \n\t\n\t// calculating the mask \n\tlong mask = (1L << num_bits) - 1; \n\t\n\t// toggling the bits \n\tn = n ^ mask; \n\t\n\t// returning the result \n\treturn n; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_of_bits = floor(log2(n)) + 1; \n\t\n\t// XOR the number with the number with all \n\t// bits flipped except the first and the last \n\t// bit. \n\treturn (n ^ ((1 << num_of_bits) - 1)); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n\tmask = mask ^ (1 << 0); \n\tlong middle = n & mask; \n\tmiddle = middle ^ mask; \n\treturn (first | middle | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\tn = first_bit | middle_bits | last_bit; \n\treturn n; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 2)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle = n & mask; \n\tmiddle = ~middle; \n\tmiddle = middle & mask; \n\treturn (first | middle | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    return (n ^ mask) | (first << (n.bitSize - 1)) | last; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\tlong result = first_bit | middle_bits | last_bit; \n\treturn result; \n} ",
    "{ \n\t// Get the first and last bit of the number \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits of the number \n\tlong middle_bits = n & ~(1 | (1 << (sizeof(n) * 8 - 1))); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\t\n\t// Put the first and last bit back \n\tmiddle_bits = middle_bits | (first_bit << (sizeof(n) * 8 - 1)) | first_bit; \n\t\n\treturn middle_bits; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (int.sizeof * 8 - 1)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = ~middle_bits; \n    middle_bits = middle_bits & mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Get the size of the number \n\tlong size = n.bitSize; \n\t\n\t// XOR the number with the number \n\t// with all set bits except the first \n\t// and last one \n\treturn n ^ ((1L << (size - 1)) - 1); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle = n & mask; \n\tmiddle = ~middle; \n\tmiddle = middle & mask; \n\treturn first | middle | last; \n} ",
    "{ \n\t// Get the first and last bit of the number \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(first_bit | last_bit); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\t\n\t// Return the result \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong x = (n >> 1) ^ (n >> 2); \n\treturn (x & (x + 1)) | first_bit | last_bit; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 2)); \n\tlong rest = n & ~(1 | (1 << (int.sizeof * 8 - 2))); \n\trest = rest ^ (rest >> 1); \n\treturn first | (rest << 1) | last; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n\tmask = mask ^ (1 << 0); \n\tlong middle = n & mask; \n\tmiddle = ~middle; \n\tmiddle = middle & mask; \n\tn = first | middle | last; \n\treturn n; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle = n & mask; \n\tmiddle = ~middle; \n\tmiddle = middle & mask; \n\treturn (first | middle | last); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bit_size - 1)); \n    long mask = (1 << (n.bit_size - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (int.sizeof * 8 - 2)); \n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\tlong result = first_bit | middle_bits | last_bit; \n\treturn result; \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 2)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 2)) | (last_bit >> (n.bitSize - 2));\n}",
    "{\n\tlong mask = (1L << (n.popCount - 2)) - 1;\n\treturn n ^ mask;\n}",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\tmask = mask ^ (1 << 0);\n\treturn (n ^ mask) | (first_bit << 0) | (last_bit >> (n.bitSize - 1));\n}",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\tint first = n & 1; \n\tint last = n & (1 << (int.sizeof * 8 - 2)); \n\tint mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tmask = mask & (~0 << 2); \n\tint middle = n & mask; \n\tmiddle = middle ^ mask; \n\tn = (first << (int.sizeof * 8 - 2)) | middle | last; \n\treturn n; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.popCount - 1)); \n\tlong mask = (1 << (n.popCount - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\treturn (n ^ mask) | (first_bit << 1) | (last_bit >> 1); \n} ",
    "{ \n\treturn (n ^ ((1 << (int)log2(n)) - 1)); \n} ",
    "{ \n    // Calculate the position of the first and last \n    // bits in the number \n    long first = log2(n & -n); \n    long last = log2(n | -n) + 1; \n  \n    // XOR the number with the left and right \n    // shifted versions of itself \n    return (n ^ ((1 << last) | (1 << first))); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 2)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = ~middle_bits; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return (first | middle | last); \n} ",
    "{ \n    // Calculate the number of bits to be flipped \n    long k = (long)log2(n); \n  \n    // XOR the number 'n' with a number \n    // consisting of all 1's except the \n    // first and the last bit \n    return ((1 << k) ^ (1 << 1)) ^ n; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (size_t.sizeof * 8 - 2)); \n\tlong middle_bits = n & ~(1 | (1 << (size_t.sizeof * 8 - 2))); \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bit_size - 1)); \n    long mask = (1 << (n.bit_size - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong x = (n ^ (n >> 1)) >> 1; \n\treturn (x | first_bit | last_bit); \n} ",
    "{ \n\tlong mask = (1 << (n.popCount - 2)) - 1; \n\treturn (n ^ mask); \n} ",
    "{ \n\t// Calculate the number of bits \n\t// in the number \n\tint num_bits = (int)log2(n) + 1; \n\t\n\t// XOR the number with a number \n\t// having set bits at all the \n\t// even positions \n\tn = n ^ ((1 << num_bits) - 1); \n\t\n\t// Divide by 2 to toggle the \n\t// bits at odd positions \n\tn = n >> 1; \n\t\n\t// Return the number \n\treturn n; \n} ",
    "{ \n    long mask = (1 << (n.popCount - 2)) - 1; \n    return (n ^ mask); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 2)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 2)) | (last_bit >> 1);\n}",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n    mask = mask ^ (1 << 0); \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return (first | middle | last); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 2)); \n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n    // Calculate the number of bits \n    // in the given integer \n    long num_bits = log2(n) + 1; \n  \n    // XOR the given integer with a \n    // number with all set bits except \n    // the 0th and the (num_bits - 1)th \n    // bit. \n    return n ^ ((1L << num_bits) - 1); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n)*8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (~0 << 1); \n\t\n\t// Combine the first and last bit with the toggled middle bits \n\treturn (first | middle | last); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (~middle + 1); \n\t\n\t// Put the first and last bit back \n\tmiddle = middle | first | last; \n\t\n\treturn middle; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle = n & mask; \n\tmiddle = ~middle; \n\tmiddle = middle & mask; \n\treturn first | middle | last; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tint num_bits = (int)log2(n) + 1; \n\t\n\t// XOR the number with a number \n\t// consisting of all 1's except \n\t// the first and last bit \n\treturn n ^ ((1 << num_bits) - 1 - 1); \n} ",
    "{ \n\t// Get the position of the first and last set bits \n\tlong first = n.trailingZeros; \n\tlong last = n.leadingZeros; \n\t\n\t// If there is only one set bit \n\tif (first == last) \n\t\treturn n; \n\t\n\t// The two sets bits are adjacent, i.e., \n\t// there are no bits between them \n\tif (first == last - 1) \n\t\treturn n ^ 3; \n\t\n\t// Position of the rightmost bit to be toggled \n\tlong right = last - 1; \n\t\n\t// XOR the two rightmost set bits and all \n\t// bits between them \n\tlong x = n ^ ((1 << first) | (1 << right)); \n\t\n\t// Get the rightmost set bit at position 'last' \n\tlong rightmost = x.leadingZeros; \n\t\n\t// Toggle all bits between first and last \n\t// set bits \n\treturn x ^ ((1 << first) | (1 << rightmost)); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1));\n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1;\n\treturn (n ^ mask) | (first_bit << (sizeof(n) * 8 - 1)) | last_bit;\n}",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first = n & (1 << 0); \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(1 | (1 << (sizeof(n) * 8 - 1))); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\t\n\t// Put the first and last bit back \n\tmiddle_bits = middle_bits | first_bit; \n\tmiddle_bits = middle_bits | last_bit; \n\t\n\treturn middle_bits; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 2)); \n\tlong rest = n & ~(1 << (int.sizeof * 8 - 1)); \n\trest = rest & ~1; \n\trest = rest ^ ((1 << (int.sizeof * 8 - 2)) - 1); \n\treturn (first | rest | last); \n} ",
    "{ \n\t// Get the first and last bit \n\t// of the number \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the number of bits \n\t// in the number \n\tlong num_bits = sizeof(n) * 8; \n\t\n\t// XOR the first and last bit \n\t// with all the middle bits \n\tfor (long i = 1; i < num_bits - 1; i++) \n\t\tn ^= (1 << i); \n\t\n\t// XOR the result with the \n\t// first and last bit \n\tn ^= (first ^ last); \n\t\n\treturn n; \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (middle >> 1); \n\t\n\t// Put the first and last bits back \n\tmiddle = middle | first | last; \n\t\n\treturn middle; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\treturn (n ^ mask) | (first_bit << 1) | (last_bit >> 1); \n} ",
    "{ \n\t// Get the first and last bits \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle ^= ~(1 << (sizeof(n) * 8 - 2)) & ~1; \n\t\n\t// Put the first and last bits back \n\treturn first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (mid | first | last); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (middle >> 1); \n\t\n\t// Return the result \n\treturn first | middle | last; \n} ",
    "{ \n\t// Calculate the position of the first and last bit \n\t// in the number. \n\tlong first = 1; \n\tlong last = n.bitSize - 1; \n\t\n\t// XOR the first and last bit \n\tn ^= (1 << first); \n\tn ^= (1 << last); \n\t\n\t// Calculate the position of the middle bit \n\t// in the number. \n\tlong mid = (first + last) / 2; \n\t\n\t// XOR the middle bit \n\tn ^= (1 << mid); \n\t\n\treturn n; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n    mask = mask ^ (1 << 0); \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return (first | middle | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\treturn (n ^ mask) | (first << 1) | (last >> 1); \n} ",
    "{\n\tlong first = n & 1;\n\tlong last = n & (1 << (int.sizeof * 8 - 1));\n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1;\n\treturn (n ^ mask) | (first << (int.sizeof * 8 - 2)) | (last >> (int.sizeof * 8 - 2));\n}",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\t// Calculate the number of bits \n\t// in the given number \n\tlong num_bits = floor(log2(n)) + 1; \n\t\n\t// XOR the given number with a \n\t// number with all set bits except \n\t// the first and last bits \n\treturn n ^ ((1L << num_bits) - 1); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\tmask = mask ^ (1 << 0);\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit;\n}",
    "{ \n\t// Get the first and last bits \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(1 << (sizeof(n) * 8 - 1)); \n\tmiddle_bits = middle_bits & ~1; \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ middle_bits; \n\t\n\t// Merge the first and last bits with the middle bits \n\tlong result = middle_bits | first_bit; \n\tresult = result | last_bit; \n\t\n\treturn result; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    return (n ^ mask) | (first << (int.sizeof * 8 - 2)) | last; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n\tmask = mask ^ (1 << 0); \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(1 << (sizeof(n) * 8 - 1)); \n\tmiddle = middle & ~1; \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ middle; \n\t\n\t// Combine the three parts \n\treturn (first | middle | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n    mask = mask ^ (1 << 0); \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (mid | first | last); \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_bits = (long)log2(n) + 1; \n\t\n\t// XOR the number with a number \n\t// consisting of all 1's except \n\t// the first and last bit \n\treturn n ^ ((1 << (num_bits - 1)) - 1); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle &= mask; \n    return first | middle | last; \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(1 | (1 << (sizeof(n) * 8 - 1))); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\t\n\t// Return the result \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    // Calculate the number of bits \n    // in the given number \n    int num_bits = (int)log2(n) + 1; \n  \n    // XOR the given number with a number \n    // consisting of all 1's except the \n    // first and last bit \n    return ((1 << num_bits) - 2) ^ n; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return first | middle | last; \n} ",
    "{ \n\tlong mask = (1 << (n.popCount - 2)) - 1; \n\treturn (n ^ mask); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Calculate the first and last bit positions \n\tlong first = 1; \n\tlong last = (long)log2(n) + 1; \n\t\n\t// XOR the first and last bits \n\tlong x = (1 << first) ^ (1 << last); \n\t\n\t// Toggle the middle bits \n\treturn n ^ x; \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long x = n & ~(1 << (n.bitSize - 1)); \n    x = x >> 1; \n    x = x << 1; \n    x = x | first_bit; \n    x = x | last_bit; \n    return x; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = ((1 << (sizeof(n) * 8 - 2)) - 1) ^ (first_bit | last_bit); \n\treturn (n ^ mask); \n} ",
    "{ \n\tlong mask = (1L << (n.popCount - 2)) - 1; \n\treturn (n ^ mask); \n} ",
    "{ \n\t// Calculate the number of bits \n\t// in the number \n\tint num_bits = floor(log2(n)) + 1; \n\t\n\t// XOR the number with a number \n\t// having set bits at all the \n\t// even positions \n\treturn n ^ ((1 << (num_bits - 1)) - 1); \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_bits = (long)log2(n) + 1; ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return (first | middle | last); \n} ",
    "{ \n\t// Get the first and last bits \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & (~(1 << (sizeof(n) * 8 - 1))); \n\tmiddle_bits = middle_bits & (~1); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (~(1 << (sizeof(n) * 8 - 1))); \n\tmiddle_bits = middle_bits ^ (~1); \n\t\n\t// Update the first and last bits \n\tfirst_bit = first_bit << (sizeof(n) * 8 - 1); \n\tlast_bit = last_bit >> (sizeof(n) * 8 - 1); \n\t\n\t// Merge the first, middle and last bits \n\treturn first_bit | middle_bits | last_bit; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    return (n ^ mask) | (first << (sizeof(n) * 8 - 2)) | (last >> (sizeof(n) * 8 - 2)); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n    // Calculate the number of bits in the number \n    long num_bits = floor(log2(n)) + 1; \n  \n    // XOR the number with a number that has all \n    // bits toggled except the first and last bits \n    return n ^ ((1 << num_bits) - 1); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn first | mid | last; \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (int.sizeof * 8 - 1)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = (n >> 1) & 1; \n\t\n\t// Get the middle bits \n\tlong middle_bits = n >> 2; \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ ((1 << (floor(log2(n)) - 2)) - 1); \n\t\n\t// Merge the first and last bit with the middle bits \n\treturn (middle_bits << 2) | (first_bit << 1) | last_bit; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 2)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle = n & mask; \n\tmiddle = ~middle; \n\tmiddle = middle & mask; \n\treturn first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_of_bits = log2(n) + 1; \n\t\n\t// XOR the number with a number that has all \n\t// bits toggled except the first and last \n\t// bits. \n\treturn n ^ ((1 << num_of_bits) - 1); \n} ",
    "{ \n    // Calculate the position of the first and last \n    // set bits \n    long first = n & ~(n - 1); \n    long last = n & ~(n & (n - 1)); \n  \n    // Calculate the position of the bit to be \n    // toggled \n    long pos = (first | last) >> 1; \n  \n    // Toggle the bit \n    return n ^ pos; \n} ",
    "{ \n\t// Calculate the number of bits \n\t// in the given number \n\tint num_bits = (int)log2(n) + 1; \n\t\n\t// XOR the given number with a number \n\t// consisting of all 1's except the \n\t// first and the last bit \n\treturn n ^ ((1 << num_bits) - 1); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (int.sizeof * 8 - 1)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} "
  ]
}