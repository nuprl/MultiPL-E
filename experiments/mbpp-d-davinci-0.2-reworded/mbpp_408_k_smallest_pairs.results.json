{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) \n\t\treturn new long[][]{};\n\t\n\tauto comp = (long[] a, long[] b) => a[0] + a[1] > b[0] + b[1];\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. min(k, n1)) \n\t{\n\t\tforeach (j; 0 .. min(k, n2)) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray();\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpcoo5flla.d(13): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpcoo5flla.d(18): Error: declaration expected, not `foreach`\n/tmp/tmpcoo5flla.d(18): Error: declaration expected, not `0`\n/tmp/tmpcoo5flla.d(20): Error: declaration expected, not `0`\n/tmp/tmpcoo5flla.d(25): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcoo5flla.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn new long[][]{};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(new long[]{nums1[i], nums2[0], 0});\n\t\n\tlong[][] res = new long[][](k);\n\tint idx = 0;\n\twhile (idx < k && !pq.empty)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[idx++] = new long[]{cur[0], cur[1]};\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});\n\t}\n\treturn res[0 .. idx];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp8b986fjj.d(13): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp8b986fjj.d(17): Error: declaration expected, not `foreach`\n/tmp/tmp8b986fjj.d(17): Error: declaration expected, not `0`\n/tmp/tmp8b986fjj.d(22): Error: declaration expected, not `while`\n/tmp/tmp8b986fjj.d(25): Error: no identifier for declarator `res[idx++]`\n/tmp/tmp8b986fjj.d(25): Error: declaration expected, not `=`\n/tmp/tmp8b986fjj.d(26): Error: declaration expected, not `if`\n/tmp/tmp8b986fjj.d(28): Error: unexpected `(` in declarator\n/tmp/tmp8b986fjj.d(28): Error: basic type expected, not `new`\n/tmp/tmp8b986fjj.d(28): Error: found `new` when expecting `)`\n/tmp/tmp8b986fjj.d(28): Error: no identifier for declarator `pq.put(_error_)`\n/tmp/tmp8b986fjj.d(28): Error: semicolon expected following function declaration\n/tmp/tmp8b986fjj.d(28): Error: no identifier for declarator `long[]`\n/tmp/tmp8b986fjj.d(28): Error: declaration expected, not `{`\n/tmp/tmp8b986fjj.d(29): Error: unrecognized declaration\nFailed: [\"dmd\", \"",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpeg8ks25e.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeg8ks25e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\twhile (k-- > 0 && pq.length) \n\t{\n\t\tauto cur = pq.get();\n\t\tresult ~= new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp0nkomb6q.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmp0nkomb6q.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0nkomb6q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult[i] = cur;\n\t\t\n\t\tif (cur[0] == nums1[n1 - 1] && cur[1] == nums2[n2 - 1])\n\t\t\tcontinue;\n\t\t\n\t\tif (cur[1] == nums2[n2 - 1])\n\t\t\tpq.put(new long[](cur[0] + 1, nums2[0]));\n\t\telse\n\t\t\tpq.put(new long[](cur[0], cur[1] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpsksezhfx.d(18): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsksezhfx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")(n1 * n2);\n\t\n\tforeach(i; 0 .. n1)\n\t\tforeach(j; 0 .. n2)\n\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto p = heap.popFront();\n\t\tif(p is null)\n\t\t\tbreak;\n\t\tres[i] = p;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp4ehhn0du.d(16): Error: template instance `Heap!(long[], \"a[0] + a[1]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ehhn0du.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j, n;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\tn = 0;\n\tforeach(i; nums1)\n\t{\n\t\tforeach(j; nums2)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = nums1[i];\n\t\t\tpair[1] = nums2[j];\n\t\t\tpairs[n] = pair;\n\t\t\tn++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp2_19ximw.d(17): Error: variable `i` is shadowing variable `tmp2_19ximw.k_smallest_pairs.i`\n/tmp/tmp2_19ximw.d(19): Error: variable `j` is shadowing variable `tmp2_19ximw.k_smallest_pairs.j`\n/tmp/tmp2_19ximw.d(29): Error: no property `sort` for type `long[][]`\n/tmp/tmp2_19ximw.d(32): Error: variable `i` is shadowing variable `tmp2_19ximw.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2_19ximw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tforeach(j; 0 .. min(k, nums2.length))\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](pq.length);\n\tforeach(i; 0 .. pq.length)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpf9k8_3b5.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpf9k8_3b5.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf9k8_3b5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto heap = new MinHeap!(tuple!(long, long, long, long));\n\t\n\tforeach(i; 0..n)\n\t{\n\t\theap.push(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif(t[3] < m - 1)\n\t\t{\n\t\t\theap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpqg5n7rih.d(13): Error: template instance `MinHeap!(tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqg5n7rih.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[])();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put(new long[](nums1[i], nums2[j]));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(new long[](nums1[i], nums2[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpwnffs15c.d(14): Error: template instance `PriorityQueue!(long[])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwnffs15c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || (a[2] == b[2] && a[3] < b[3])\");\n\t\n\tforeach (i, e; nums1)\n\t{\n\t\tpq.put(tuple(e, nums2[0], i, 0));\n\t}\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = [t[0], t[1]];\n\t\tif (t[3] == n2 - 1) continue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmprwfirrkm.d(14): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || (a[2] == b[2] && a[3] < b[3])\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprwfirrkm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto result = new long[][](0);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult ~= new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpfl24sosq.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpfl24sosq.d(16): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfl24sosq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\tif(pq.size > k)\n\t\t\t{\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp7zfxxv3u.d(10): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7zfxxv3u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\tauto result = new long[][](k);\n\t\n\tforeach(i, e; nums1)\n\t{\n\t\theap.insert(tuple(e, nums2[0], i, 0));\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = heap.popFront;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] + 1 < nums2.length)\n\t\t{\n\t\t\theap.insert(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp55vqnlw2.d(10): Error: template instance `Heap!(Tuple!(long, long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp55vqnlw2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0 || k == 0) \n\t\treturn [];\n\t\n\tauto arr = new long[][](len1, len2);\n\tfor (int i = 0; i < len1; i++) \n\t{\n\t\tfor (int j = 0; j < len2; j++) \n\t\t{\n\t\t\tarr[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tauto res = new long[][](k, 2);\n\tauto visited = new bool[][](len1, len2);\n\tfor (int i = 0; i < k; i++) \n\t{\n\t\tlong min = long.max;\n\t\tint min_i = 0;\n\t\tint min_j = 0;\n\t\tfor (int j = 0; j < len1; j++) \n\t\t{\n\t\t\tfor (int l = 0; l < len2; l++) \n\t\t\t{\n\t\t\t\tif (visited[j][l]) \n\t\t\t\t\tcontinue;\n\t\t\t\tif (arr[j][l] < min) \n\t\t\t\t{\n\t\t\t\t\tmin = arr[j][l];\n\t\t\t\t\tmin_i = j;\n\t\t\t\t\tmin_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres[i][0] = nums1[min_i];\n\t\tres[i][1] = nums2[min_j];\n\t\tvisited[min_i][min_j] = true;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto pairs = new long[][](n1 * n2);\n\tauto index = 0;\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\tforeach(i; 0 .. pairs.length)\n\t{\n\t\tif(count == k)\n\t\t\tbreak;\n\t\tresult[count] = pairs[i];\n\t\tcount++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkctqfjbd.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x429579]\n??:? void tmpkctqfjbd.__unittest_L34_C1() [0x4285cb]\n??:? void tmpkctqfjbd.__modtest() [0x428764]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e12b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x429256]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42add1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ae60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42ad5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42922d]\n??:? runModuleUnitTests [0x42df01]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429a3c]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\tlong min_index;\n\tlong min_value;\n\tlong[] min_pair;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tif (k >= n * m)\n\t\treturn pairs;\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin_index = i;\n\t\tmin_value = nums1[i / m] + nums2[i % m];\n\t\t\n\t\tfor (j = i + 1; j < n * m; j++)\n\t\t{\n\t\t\tif (nums1[j / m] + nums2[j % m] < min_value)\n\t\t\t{\n\t\t\t\tmin_index = j;\n\t\t\t\tmin_value = nums1[j / m] + nums2[j % m];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmin_pair = pairs[min_index];\n\t\tpairs[min_index] = pairs[i];\n\t\tpairs[i] = min_pair;\n\t\t\n\t\tresult[i] = min_pair;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 * n2 == 0)\n\t\treturn result;\n\t\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\twhile (k-- > 0)\n\t{\n\t\tauto pair = pq.pop();\n\t\tresult[k] = pair;\n\t\t\n\t\tif (pair[0] == nums1[n1 - 1] && pair[1] == nums2[n2 - 1])\n\t\t\tcontinue;\n\t\t\n\t\tif (pair[1] == nums2[n2 - 1])\n\t\t\tpq.put(new long[](pair[0] + 1, nums2[0]));\n\t\telse\n\t\t\tpq.put(new long[](pair[0], pair[1] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpb82hd3dv.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb82hd3dv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto result = new long[][](k);\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = len1 * len2;\n\tauto index = 0;\n\tauto arr = new long[][](len);\n\tforeach(i; 0..len1)\n\t{\n\t\tforeach(j; 0..len2)\n\t\t{\n\t\t\tarr[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tauto compare = (a, b) => \n\t{\n\t\tif(a[0] + a[1] < b[0] + b[1])\n\t\t\treturn -1;\n\t\telse if(a[0] + a[1] > b[0] + b[1])\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t};\n\t\n\tarr.sort(compare);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tresult[i] = arr[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpc69x48t6.d(25): Error: variable `tmpc69x48t6.k_smallest_pairs.compare` type `void` is inferred from initializer `(a, b) => ()\n{\nif (a[0] + a[1] < b[0] + b[1])\nreturn -1;\nelse if (a[0] + a[1] > b[0] + b[1])\nreturn 1;\nelse\nreturn 0;\n}\n`, and variables cannot be of type `void`\n/tmp/tmpc69x48t6.d(25): Error: template lambda has no value\n/tmp/tmpc69x48t6.d(35): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc69x48t6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i;\n\tlong j;\n\tlong count;\n\tlong min;\n\tlong min_index;\n\tlong min_index_j;\n\tlong min_index_i;\n\tlong temp_i;\n\tlong temp_j;\n\t\n\tpairs = new long[nums1.length][nums2.length];\n\tresult = new long[nums1.length * nums2.length][2];\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < nums1.length * nums2.length; i++)\n\t{\n\t\tmin = pairs[0][0];\n\t\tmin_index_i = 0;\n\t\tmin_index_j = 0;\n\t\tfor (j = 0; j < nums1.length; j++)\n\t\t{\n\t\t\tfor (count = 0; count < nums2.length; count++)\n\t\t\t{\n\t\t\t\tif (pairs[j][count] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = pairs[j][count];\n\t\t\t\t\tmin_index_i = j;\n\t\t\t\t\tmin_index_j = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i][0] = nums1[min_index_i];\n\t\tresult[i][1] = nums2[min_index_j];\n\t\tpairs[min_index_i][min_index_j] = pairs[min_index_i][min_index_j] + 1;\n\t}\n\t\n\tif (k < nums1.length * nums2.length)\n\t{\n\t\ttemp = new long[k][2];\n\t\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmps3kra37l.d(60): Error: found `unittest` instead of statement\n/tmp/tmps3kra37l.d(68): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps3kra37l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1]);\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tresult = new long[][](k);\n\tforeach (i; 0 .. k) \n\t{\n\t\tauto curr = pq.get;\n\t\tresult[i] = [curr[0], curr[1]];\n\t\tif (curr[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put([curr[0], nums2[curr[2] + 1], curr[2] + 1]);\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp67d6i7hc.d(16): Error: template instance `PriorityQueue!((a) => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1])` template `PriorityQueue` is not defined\n/tmp/tmp67d6i7hc.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp67d6i7hc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto nums1_len = nums1.length;\n\tauto nums2_len = nums2.length;\n\t\n\tif (nums1_len == 0 || nums2_len == 0)\n\t\treturn [];\n\t\n\tauto len = min(nums1_len * nums2_len, k);\n\tauto res = new long[][len];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tpq.put([nums1[0], nums2[0]]);\n\t\n\tforeach (i; 0 .. len)\n\t{\n\t\tauto pair = pq.pop();\n\t\tres[i] = pair;\n\t\t\n\t\tif (pair[0] + 1 < nums1_len)\n\t\t\tpq.put([pair[0] + 1, pair[1]]);\n\t\t\n\t\tif (pair[0] == 0 && pair[1] + 1 < nums2_len)\n\t\t\tpq.put([pair[0], pair[1] + 1]);\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp04yic2b9.d(16): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp04yic2b9.d(19): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp04yic2b9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j, l;\n\t\n\tresult = new long[][](k);\n\ttemp = new long[][](nums1.length * nums2.length);\n\t\n\tl = 0;\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp[l] = [nums1[i], nums2[j]];\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\ttemp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpiro6ifti.d(18): Error: variable `i` is shadowing variable `tmpiro6ifti.k_smallest_pairs.i`\n/tmp/tmpiro6ifti.d(20): Error: variable `j` is shadowing variable `tmpiro6ifti.k_smallest_pairs.j`\n/tmp/tmpiro6ifti.d(27): Error: no property `sort` for type `long[][]`\n/tmp/tmpiro6ifti.d(29): Error: variable `i` is shadowing variable `tmpiro6ifti.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiro6ifti.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto heap = new Heap!(Tuple!(long, long, long))(Tuple!(long, long, long).init, (a, b) => a[2] > b[2]);\n\tforeach(i; 0 .. min(k, nums1.length))\n\t\theap.push(tuple(i, 0, nums1[i] + nums2[0]));\n\t\n\tauto result = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif(t[1] + 1 < nums2.length)\n\t\t\theap.push(tuple(t[0], t[1] + 1, nums1[t[0]] + nums2[t[1] + 1]));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp2dk_x9bc.d(10): Error: template instance `Heap!(Tuple!(long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\n/tmp/tmp2dk_x9bc.d(11): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2dk_x9bc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpvempr79t.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvempr79t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. min(k, len1))\n\t{\n\t\tminHeap.add(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\tauto index = 0;\n\twhile(index < k && minHeap.length > 0)\n\t{\n\t\tauto pair = minHeap.pop();\n\t\tresult[index] = [pair[0], pair[1]];\n\t\tauto nextIndex = pair[2] + 1;\n\t\tif (nextIndex < len2)\n\t\t{\n\t\t\tminHeap.add(tuple(pair[0], nums2[nextIndex], nextIndex));\n\t\t}\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpg4sqof6m.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmpg4sqof6m.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg4sqof6m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor(int i = 0; i < len; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmps6x1nr5n.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps6x1nr5n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m, min_index, min_value, min_value_index;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin_value = pairs[0][0] + pairs[0][1];\n\t\tmin_value_index = 0;\n\t\t\n\t\tfor (j = 1; j < n * m; j++)\n\t\t{\n\t\t\tif (pairs[j][0] + pairs[j][1] < min_value)\n\t\t\t{\n\t\t\t\tmin_value = pairs[j][0] + pairs[j][1];\n\t\t\t\tmin_value_index = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i] = pairs[min_value_index];\n\t\tpairs[min_value_index] = [long.max, long.max];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbzqvltaj.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4297d9]\n??:? void tmpbzqvltaj.__unittest_L49_C1() [0x428509]\n??:? void tmpbzqvltaj.__modtest() [0x4289c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x4294b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b055]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b0e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42afe1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42948d]\n??:? runModuleUnitTests [0x42e185]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429c9c]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[][] temp2;\n\tlong i;\n\tlong j;\n\tlong m;\n\tlong n;\n\tlong l;\n\tlong min;\n\tlong min_index;\n\tlong min_index2;\n\tlong min_index3;\n\tlong min_index4;\n\tlong min_index5;\n\tlong min_index6;\n\tlong min_index7;\n\tlong min_index8;\n\tlong min_index9;\n\tlong min_index10;\n\tlong min_index11;\n\tlong min_index12;\n\tlong min_index13;\n\tlong min_index14;\n\tlong min_index15;\n\tlong min_index16;\n\tlong min_index17;\n\tlong min_index18;\n\tlong min_index19;\n\tlong min_index20;\n\tlong min_index21;\n\tlong min_index22;\n\tlong min_index23;\n\tlong min_index24;\n\tlong min_index25;\n\tlong min_index26;\n\tlong min_index27;\n\tlong min_index28;\n\tlong min_index29;\n\tlong min_index30;\n\tlong min_index31;\n\tlong min_index32;\n\tlong min_index33;\n\tlong min_index34;\n\tlong min_index35;\n\tlong min_index36;\n\tlong min_index37;\n\tlong min_index38;\n\tlong min_index39;\n\tlong min_index40;\n\tlong min_index41;\n\tlong min_index42;\n\tlong min_index43;\n\tlong min_index44;\n\tlong min_index45;\n\tlong min_index46;\n\tlong min_index47;\n\tlong min_index48;\n\tlong min_index49;\n\tlong min_index50;\n\tlong min_index51;\n\tlong min_index52;\n\tlong min_index53;\n\tlong min_index54;\n\tlong min_index55;\n\tlong min_index56;\n\tlong min_index57;\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp1k6de0nn.d(76): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1k6de0nn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\tlong[] temp;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tsort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](min(k, n * m));\n\t\n\tfor (i = 0; i < min(k, n * m); i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmphpoqy8le.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmphpoqy8le.d(33): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmphpoqy8le.d(35): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphpoqy8le.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpegyadysx.d(17): Error: template instance `PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpegyadysx.d(19): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpegyadysx.d(22): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpegyadysx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tlong[][] visited = new long[][](nums1.length, nums2.length);\n\tvisited[0][0] = 1;\n\t\n\tlong count = 0;\n\twhile (count < k && !pq.empty) \n\t{\n\t\tauto cur = pq.get();\n\t\tres[count][0] = cur[0];\n\t\tres[count][1] = cur[1];\n\t\tcount++;\n\t\t\n\t\tlong next_x = cur[0] == nums1[0] ? 1 : 0;\n\t\tlong next_y = cur[1] == nums2[0] ? 1 : 0;\n\t\t\n\t\tif (next_x < nums1.length && visited[next_x][cur[1]] == 0) \n\t\t{\n\t\t\tpq.put(new long[](nums1[next_x], cur[1]));\n\t\t\tvisited[next_x][cur[1]] = 1;\n\t\t}\n\t\t\n\t\tif (next_y < nums2.length && visited[cur[0]][next_y] == 0) \n\t\t{\n\t\t\tpq.put(new long[](cur[0], nums2[next_y]));\n\t\t\tvisited[cur[0]][next_y] = 1;\n\t\t}\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp1xf1aj7r.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1xf1aj7r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(long[])();\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tauto pair = [nums1[i], nums2[j]];\n\t\t\tpq.put(pair);\n\t\t\tif(pq.size > k)\n\t\t\t\tpq.get();\n\t\t}\n\t}\n\t\n\tauto res = new long[][](pq.size);\n\t\n\tforeach(i; 0 .. pq.size)\n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpmsg86ct8.d(13): Error: template instance `PriorityQueue!(long[])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmsg86ct8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t\tres[i] = pq.pop().array;\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpu6w20_ni.d(11): Error: new can only create structs, dynamic arrays or class objects, not `long[][]`'s\n/tmp/tmpu6w20_ni.d(13): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu6w20_ni.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong n1 = nums1.length;\n\tlong n2 = nums2.length;\n\tlong i, j;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tforeach (i; 0 .. n1)\n\t\tforeach (j; 0 .. n2)\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\n\tsort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tif (k > n1 * n2)\n\t\tk = n1 * n2;\n\t\n\tresult = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t\tresult[i] = pairs[i];\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp1wibk0sw.d(21): Error: variable `i` is shadowing variable `tmp1wibk0sw.k_smallest_pairs.i`\n/tmp/tmp1wibk0sw.d(22): Error: variable `j` is shadowing variable `tmp1wibk0sw.k_smallest_pairs.j`\n/tmp/tmp1wibk0sw.d(25): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmp1wibk0sw.d(32): Error: variable `i` is shadowing variable `tmp1wibk0sw.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1wibk0sw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto result = new long[][](k);\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto index = new long[len1];\n\twhile (k-- > 0) \n\t{\n\t\tlong sum = long.max;\n\t\tlong pos = -1;\n\t\tfor (long i = 0; i < len1; i++) \n\t\t{\n\t\t\tif (index[i] >= len2)\n\t\t\t\tcontinue;\n\t\t\tif (nums1[i] + nums2[index[i]] < sum) \n\t\t\t{\n\t\t\t\tsum = nums1[i] + nums2[index[i]];\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\tresult[$-k] = [nums1[pos], nums2[index[pos]]];\n\t\tindex[pos]++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpq6_wuve0.d(31): Range violation\n----------------\n??:? _d_arrayboundsp [0x4296c2]\n??:? long[][] tmpq6_wuve0.k_smallest_pairs(long[], long[], long) [0x428110]\n??:? void tmpq6_wuve0.__unittest_L36_C1() [0x42828d]\n??:? void tmpq6_wuve0.__modtest() [0x428800]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e1c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x4292ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42ae69]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42aef8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42adf5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4292c5]\n??:? runModuleUnitTests [0x42df99]\n??:? void rt.dmain2._d_run_main(int, char**, ext",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong[] pair;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach (n1; nums1)\n\t{\n\t\tforeach (n2; nums2)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = n1;\n\t\t\tpair[1] = n2;\n\t\t\tpairs[i] = pair;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\ttemp = pairs.dup;\n\t\n\tstd.algorithm.sort!((a, b) => a[0] + a[1] < b[0] + b[1])(temp);\n\t\n\tresult = new long[][](k);\n\t\n\ti = 0;\n\tforeach (p; temp)\n\t{\n\t\tif (i >= k)\n\t\t\tbreak;\n\t\tresult[i] = p;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp4ttv4tk9.d(33): Error: undefined identifier `algorithm` in package `std`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ttv4tk9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\tauto result = new long[][](n, 2);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tfor (long i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto pair = pq.get();\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[0] == nums1[0] && pair[1] < nums2[n2 - 1])\n\t\t\tpq.put(new long[](pair[0], nums2[pair[1] + 1]));\n\t\t\n\t\tif (pair[0] < nums1[n1 - 1] && pair[1] == nums2[0])\n\t\t\tpq.put(new long[](nums1[pair[0] + 1], pair[1]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp1sbv1nna.d(12): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp1sbv1nna.d(18): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1sbv1nna.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tforeach (j; 0 .. min(k, nums2.length))\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpds5koiam.d(13): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\n/tmp/tmpds5koiam.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpds5koiam.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto comp = (a, b) { return a[0] + a[1] < b[0] + b[1]; };\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t\tpq.put(top);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpzyva1epe.d(14): Error: variable `tmpzyva1epe.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b)\n{\nreturn a[0] + a[1] < b[0] + b[1];\n}\n`, and variables cannot be of type `void`\n/tmp/tmpzyva1epe.d(14): Error: template lambda has no value\n/tmp/tmpzyva1epe.d(15): Error: template instance `PriorityQueue!comp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzyva1epe.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0) return [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tminHeap.insert([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tauto res = long[][](k);\n\tauto idx = 0;\n\twhile (idx < k && !minHeap.empty)\n\t{\n\t\tauto [a, b, j] = minHeap.pop;\n\t\tres[idx++] = [a, b];\n\t\tif (j == n2 - 1) continue;\n\t\tminHeap.insert([a, nums2[j + 1], j + 1]);\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp7elqs10a.d(21): Error: found `[` when expecting `.` following long\n/tmp/tmp7elqs10a.d(21): Error: found `]` when expecting identifier following `long`.\n/tmp/tmp7elqs10a.d(25): Error: basic type expected, not `[`\n/tmp/tmp7elqs10a.d(25): Error: found `,` when expecting `]`\n/tmp/tmp7elqs10a.d(25): Error: semicolon expected, not `]`\n/tmp/tmp7elqs10a.d(25): Error: found `]` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7elqs10a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = n1 * n2;\n\tauto pairs = new long[][](n);\n\tauto cnt = 0;\n\tforeach(i, nums1)\n\t{\n\t\tforeach(j, nums2)\n\t\t{\n\t\t\tpairs[cnt] = [nums1[i], nums2[j]];\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\tauto res = new long[][](k);\n\tauto min_heap = new MinHeap!(long[])();\n\tforeach(i, pairs)\n\t{\n\t\tif(min_heap.length < k)\n\t\t{\n\t\t\tmin_heap.push(pairs[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pairs[i][0] + pairs[i][1] < min_heap.top()[0] + min_heap.top()[1])\n\t\t\t{\n\t\t\t\tmin_heap.pop();\n\t\t\t\tmin_heap.push(pairs[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, min_heap)\n\t{\n\t\tres[i] = min_heap[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp3b6umrhq.d(15): Error: no identifier for declarator `nums1`\n/tmp/tmp3b6umrhq.d(15): Error: found `)` when expecting `;`\n/tmp/tmp3b6umrhq.d(17): Error: no identifier for declarator `nums2`\n/tmp/tmp3b6umrhq.d(17): Error: found `)` when expecting `;`\n/tmp/tmp3b6umrhq.d(22): Error: found `}` when expecting `)`\n/tmp/tmp3b6umrhq.d(26): Error: no identifier for declarator `pairs`\n/tmp/tmp3b6umrhq.d(26): Error: found `)` when expecting `;`\n/tmp/tmp3b6umrhq.d(42): Error: found `foreach` when expecting `)`\n/tmp/tmp3b6umrhq.d(47): Error: found `return` when expecting `;` following statement\n/tmp/tmp3b6umrhq.d(49): Error: found `unittest` when expecting `)`\n/tmp/tmp3b6umrhq.d(57): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3b6umrhq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] tmp;\n\tlong[] tmp2;\n\tlong i, j;\n\t\n\tresult = new long[][](k);\n\ttmp = new long[][](nums1.length * nums2.length);\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\ttmp[i * nums2.length + j] = new long[2];\n\t\t\ttmp[i * nums2.length + j][0] = nums1[i];\n\t\t\ttmp[i * nums2.length + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttmp2 = new long[tmp.length];\n\t\n\tfor (i = 0; i < tmp.length; i++)\n\t{\n\t\ttmp2[i] = tmp[i][0] + tmp[i][1];\n\t}\n\t\n\ttmp2 = tmp2.sort();\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tfor (j = 0; j < tmp.length; j++)\n\t\t{\n\t\t\tif (tmp2[i] == tmp[j][0] + tmp[j][1])\n\t\t\t{\n\t\t\t\tresult[i] = tmp[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpargx4v4v.d(35): Error: no property `sort` for type `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpargx4v4v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto comp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.front[0] + pq.front[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpkrtfvo2z.d(14): Error: variable `tmpkrtfvo2z.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b) => a[0] + a[1] > b[0] + b[1]`, and variables cannot be of type `void`\n/tmp/tmpkrtfvo2z.d(14): Error: template lambda has no value\n/tmp/tmpkrtfvo2z.d(15): Error: template instance `PriorityQueue!comp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkrtfvo2z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto result = new long[][](k);\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tfor (int i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpor5srmo9.d(18): Error: template instance `PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpor5srmo9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pairs = new long[][](nums1.length * nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[i * nums2.length + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\treturn pairs[0 .. min(k, pairs.length)];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpbe_3aq_9.d(19): Error: undefined identifier `algorithm` in package `std`\n/tmp/tmpbe_3aq_9.d(21): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbe_3aq_9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto pq = PriorityQueue!(long[], \"a[0] + a[1]\")(n1 * n2);\n\t\n\tforeach (i; 0 .. n1)\n\t\tforeach (j; 0 .. n2)\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t\tres[i] = pq.get();\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpbm82w9p0.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbm82w9p0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] temp;\n\tlong i, j, l;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\tl = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp = new long[2];\n\t\t\ttemp[0] = nums1[i];\n\t\t\ttemp[1] = nums2[j];\n\t\t\tpairs[l] = temp;\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[k][];\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpsajinzi8.d(15): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpsajinzi8.d(17): Error: variable `i` is shadowing variable `tmpsajinzi8.k_smallest_pairs.i`\n/tmp/tmpsajinzi8.d(19): Error: variable `j` is shadowing variable `tmpsajinzi8.k_smallest_pairs.j`\n/tmp/tmpsajinzi8.d(29): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\n/tmp/tmpsajinzi8.d(31): Error: variable `k` cannot be read at compile time\n/tmp/tmpsajinzi8.d(32): Error: variable `i` is shadowing variable `tmpsajinzi8.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsajinzi8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new MinHeap!(tuple!(long, long, long, long));\n\tauto res = new long[][](k);\n\t\n\tif(n == 0 || m == 0)\n\t\treturn res;\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile(k > 0)\n\t{\n\t\tauto t = heap.pop();\n\t\tres[t[3]] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif(t[2] + 1 < m)\n\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, t[3] + 1));\n\t\t\n\t\tif(t[2] == 0 && t[1] + 1 < n)\n\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], t[3] + 1));\n\t\t\n\t\tk--;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpey3knj3p.d(12): Error: template instance `MinHeap!(tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpey3knj3p.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto result = new long[][](k);\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto index = new long[n1];\n\t\n\twhile (k-- > 0) \n\t{\n\t\tlong min_val = long.max;\n\t\tlong min_index = -1;\n\t\t\n\t\tfor (long i = 0; i < n1; i++) \n\t\t{\n\t\t\tif (index[i] >= n2)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (nums1[i] + nums2[index[i]] < min_val) \n\t\t\t{\n\t\t\t\tmin_val = nums1[i] + nums2[index[i]];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (min_index == -1)\n\t\t\tbreak;\n\t\t\n\t\tresult[$-k] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpsx2c0x4b.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x4296d2]\n??:? long[][] tmpsx2c0x4b.k_smallest_pairs(long[], long[], long) [0x42811b]\n??:? void tmpsx2c0x4b.__unittest_L45_C1() [0x428299]\n??:? void tmpsx2c0x4b.__modtest() [0x42880c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e1d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x4292fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42ae79]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42af08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42ae05]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4292d5]\n??:? runModuleUnitTests [0x42dfa9]\n??:? void rt.dmain2._d_run_main(int, char**, ext",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto result = new long[][](0);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1) continue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpymr8m77j.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpymr8m77j.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpymr8m77j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i, j, l, m, n;\n\t\n\tl = nums1.length;\n\tm = nums2.length;\n\tn = l * m;\n\t\n\tpairs = new long[][](n, 2);\n\t\n\tfor (i = 0; i < l; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j][0] = nums1[i];\n\t\t\tpairs[i * m + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttemp = new long[][](k, 2);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\ttemp[i][0] = pairs[i][0];\n\t\ttemp[i][1] = pairs[i][1];\n\t}\n\t\n\tfor (i = k; i < n; i++)\n\t{\n\t\tfor (j = 0; j < k; j++)\n\t\t{\n\t\t\tif (pairs[i][0] + pairs[i][1] < temp[j][0] + temp[j][1])\n\t\t\t{\n\t\t\t\ttemp[j][0] = pairs[i][0];\n\t\t\t\ttemp[j][1] = pairs[i][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn temp;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4wzmlj8k.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x429ab1]\n??:? void tmp4wzmlj8k.__unittest_L53_C1() [0x428b07]\n??:? void tmp4wzmlj8k.__modtest() [0x428ca0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e853]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42978e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b4f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b588]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b485]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429765]\n??:? runModuleUnitTests [0x42e629]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429f74]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[k][2];\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1]);\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto curr = pq.get;\n\t\tresult[i] = [curr[0], curr[1]];\n\t\tif (curr[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([curr[0], nums2[curr[2] + 1], curr[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpcd_ps2ng.d(10): Error: variable `k` cannot be read at compile time\n/tmp/tmpcd_ps2ng.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcd_ps2ng.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor (size_t i = 0; i < len; i++) \n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpx9f2ntda.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx9f2ntda.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto heap = new Heap!(tuple!(long, long, long));\n\t\n\tforeach (i, num1; nums1)\n\t{\n\t\theap.push(tuple(num1, nums2[0], 0));\n\t\tif (heap.length > k)\n\t\t\theap.pop();\n\t}\n\t\n\tresult = new long[][](heap.length);\n\t\n\tforeach (i, t; heap)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = t[0];\n\t\tresult[i][1] = t[1];\n\t\t\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\theap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t\theap.pop();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp59ux_sbx.d(15): Error: template instance `Heap!(tuple!(long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp59ux_sbx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](min(k, n * m));\n\t\n\tfor (i = 0; i < min(k, n * m); i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpc8hcju7s.d(27): Error: no property `sort` for type `long[][]`\n/tmp/tmpc8hcju7s.d(29): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpc8hcju7s.d(31): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc8hcju7s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long), \"a[0] > b[0]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i] + nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto p = pq.get;\n\t\tresult[i] = [nums1[p[1]], nums2[p[2]]];\n\t\t\n\t\tif (p[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[p[1]] + nums2[p[2] + 1], p[1], p[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpnoop55q5.d(16): Error: found `,` when expecting `.` following long\n/tmp/tmpnoop55q5.d(16): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpnoop55q5.d(16): Error: found `)` when expecting `.` following long\n/tmp/tmpnoop55q5.d(16): Error: found `,` when expecting identifier following `long`.\n/tmp/tmpnoop55q5.d(16): Error: found `\"a[0] > b[0]\"` when expecting `,`\n/tmp/tmpnoop55q5.d(16): Error: found `;` when expecting `)` following template argument list\n/tmp/tmpnoop55q5.d(18): Error: semicolon expected following auto declaration, not `foreach`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnoop55q5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length, 2);\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i][0] = n1;\n\t\t\tpairs[i][1] = n2;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => (a[0] + a[1]) < (b[0] + b[1]))(pairs);\n\t\n\tresult = new long[][](k, 2);\n\tfor(i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = pairs[i][0];\n\t\tresult[i][1] = pairs[i][1];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpe18yux_g.d(26): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe18yux_g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto max = n1 * n2;\n\t\n\tif (k > max)\n\t\tk = max;\n\t\n\tauto result = new long[][](k);\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tfor (auto i = 0; i < n1; i++)\n\t{\n\t\tfor (auto j = 0; j < n2; j++)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t}\n\t}\n\t\n\tfor (auto i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpustz35gc.d(20): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpustz35gc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i][0] = n1;\n\t\t\tpairs[i][1] = n2;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\tfor(i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmplia9mmj2.d(27): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplia9mmj2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pairs = new long[][](nums1.length * nums2.length);\n\t\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\treturn pairs[0 .. min(k, pairs.length)];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpwuy7n0nu.d(22): Error: no property `sort` for type `long[][]`\n/tmp/tmpwuy7n0nu.d(24): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwuy7n0nu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = n1 * n2;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == n1 - 1)\n\t\t{\n\t\t\tif (t[3] != n2 - 1)\n\t\t\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t\t\tif (t[3] != n2 - 1)\n\t\t\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp34b14ksf.d(14): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp34b14ksf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, l;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\tl = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[l] = [nums1[i], nums2[j]];\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[k][];\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpi00tjvg6.d(14): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpi00tjvg6.d(16): Error: variable `i` is shadowing variable `tmpi00tjvg6.k_smallest_pairs.i`\n/tmp/tmpi00tjvg6.d(18): Error: variable `j` is shadowing variable `tmpi00tjvg6.k_smallest_pairs.j`\n/tmp/tmpi00tjvg6.d(25): Error: no property `sort` for type `long[][]`\n/tmp/tmpi00tjvg6.d(27): Error: variable `k` cannot be read at compile time\n/tmp/tmpi00tjvg6.d(28): Error: variable `i` is shadowing variable `tmpi00tjvg6.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi00tjvg6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0) \n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i) \n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1) \n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpvc7skjg2.d(16): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvc7skjg2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach(num1; nums1)\n\t{\n\t\tforeach(num2; nums2)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = num1;\n\t\t\tpair[1] = num2;\n\t\t\tpairs[i] = pair;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\ti = 0;\n\tforeach(pair; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\t\n\t\tresult[i] = pair;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp054zrm97.d(30): Error: undefined identifier `algorithm` in package `std`\n/tmp/tmp054zrm97.d(35): Error: variable `pair` is shadowing variable `tmp054zrm97.k_smallest_pairs.pair`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp054zrm97.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach(i; 0..min(len1, k))\n\t{\n\t\tminHeap.push(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tif(minHeap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto top = minHeap.pop;\n\t\tresult[i] = [top[0], top[1]];\n\t\t\n\t\tif(top[2] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(top[0], nums2[top[2] + 1], top[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp7oq75e_a.d(13): Error: template instance `MinHeap!(Tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmp7oq75e_a.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7oq75e_a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif (len1 == 0 || len2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(long[])(HeapDirection.Min);\n\t\n\tforeach (i; 0 .. min(k, len1))\n\t\theap.insert([nums1[i], nums2[0], 0]);\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto pair = heap.pop;\n\t\tresult[i] = pair[0 .. 2];\n\t\t\n\t\tif (pair[2] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\theap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpvo0imsgd.d(16): Error: template instance `Heap!(long[])` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\n/tmp/tmpvo0imsgd.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvo0imsgd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[nums1.length * nums2.length][2];\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i][0] = n1;\n\t\t\tpairs[i][1] = n2;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[k][2];\n\t\n\ti = 0;\n\tforeach(p; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\tresult[i] = p;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp1omh8b5l.d(14): Error: variable `nums1` cannot be read at compile time\n/tmp/tmp1omh8b5l.d(27): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\n/tmp/tmp1omh8b5l.d(29): Error: variable `k` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1omh8b5l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t\tpq.put(top);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpq.put(top);\n\t\t\t}\n\t\t}\n\t\n\tresult = new long[][](pq.length);\n\t\n\tforeach (i; 0 .. pq.length)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpaxrd9lz_.d(15): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaxrd9lz_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put(new long[] { nums1[i], nums2[0], 0 });\n\t\n\tlong[][] res = new long[][](k);\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto pair = pq.poll();\n\t\tif (pair is null)\n\t\t\tbreak;\n\t\tres[i] = pair[0 .. 2];\n\t\tif (pair[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[] { pair[0], nums2[pair[2] + 1], pair[2] + 1 });\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp_opzdr7g.d(15): Error: found `{` when expecting `,`\n/tmp/tmp_opzdr7g.d(15): Error: found `}` when expecting `,`\n/tmp/tmp_opzdr7g.d(26): Error: found `{` when expecting `,`\n/tmp/tmp_opzdr7g.d(26): Error: found `}` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_opzdr7g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp6sgtgem8.d(83): Error: semicolon expected, not `unittest`\n/tmp/tmp6sgtgem8.d(83): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6sgtgem8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tlong[][] pairs;\n\tlong[][] tmp;\n\tlong i, j, m, n, p, q;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tpairs = new long[][](m * n);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tpairs[i * n + j] = new long[2];\n\t\t\tpairs[i * n + j][0] = nums1[i];\n\t\t\tpairs[i * n + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttmp = new long[][](k);\n\tfor (i = 0; i < k; i++)\n\t{\n\t\ttmp[i] = new long[2];\n\t}\n\t\n\tp = 0;\n\tq = 0;\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tfor (j = 0; j < m * n; j++)\n\t\t{\n\t\t\tif (pairs[j][0] + pairs[j][1] < tmp[p][0] + tmp[p][1])\n\t\t\t{\n\t\t\t\ttmp[p][0] = pairs[j][0];\n\t\t\t\ttmp[p][1] = pairs[j][1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tmp[p][0] + tmp[p][1] == tmp[q][0] + tmp[q][1])\n\t\t{\n\t\t\tp++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tq++;\n\t\t}\n\t}\n\t\n\tres = new long[][](q);\n\tfor (i = 0; i < q; i++)\n\t{\n\t\tres[i] = new long[2];\n\t\tres[i][0] = tmp[i][0];\n\t\tres[i][1] = tmp[i][1];\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpfr4q1ifk.d(64): Error: found `unittest` instead of statement\n/tmp/tmpfr4q1ifk.d(72): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfr4q1ifk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmprv8f_sqp.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmprv8f_sqp.d(16): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprv8f_sqp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tpq.put([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpjleasjph.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpjleasjph.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjleasjph.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tfor (long i = 0; i < n1 && i < k; i++)\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty(); i++)\n\t{\n\t\tauto pair = pq.get();\n\t\tresult[i] = new long[](pair[0], pair[1]);\n\t\tauto next = pair[2] + 1;\n\t\tif (next < n2)\n\t\t\tpq.put(new long[](pair[0], nums2[next], next));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmph610kj90.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph610kj90.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\tauto minHeap = MinHeap!(long[2])();\n\tforeach (i; 0 .. min(k, n1))\n\t\tminHeap.insert([nums1[i], nums2[0], 0]);\n\tauto result = new long[][2](k);\n\tauto count = 0;\n\twhile (count < k && !minHeap.empty) \n\t{\n\t\tauto pair = minHeap.pop;\n\t\tresult[count] = pair[0 .. 2];\n\t\tcount++;\n\t\tif (pair[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1]);\n\t}\n\treturn result[0 .. count];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmprv1pcnhj.d(14): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\n/tmp/tmprv1pcnhj.d(15): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmprv1pcnhj.d(17): Error: function expected before `()`, not `new long[][](2LU)` of type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprv1pcnhj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\tforeach(i, nums1)\n\t\tforeach(j, nums2)\n\t\t\tpairs ~= [nums1[i], nums2[j]];\n\t\t\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(i, 0 .. k)\n\t\tresult[i] = pairs[i];\n\t\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpkg6fw9cm.d(16): Error: no identifier for declarator `nums1`\n/tmp/tmpkg6fw9cm.d(16): Error: found `)` when expecting `;`\n/tmp/tmpkg6fw9cm.d(17): Error: expression expected, not `foreach`\n/tmp/tmpkg6fw9cm.d(18): Error: found `pairs` when expecting `)`\n/tmp/tmpkg6fw9cm.d(18): Error: found `~=` instead of statement\n/tmp/tmpkg6fw9cm.d(24): Error: basic type expected, not `0`\n/tmp/tmpkg6fw9cm.d(24): Error: no identifier for declarator `_error_`\n/tmp/tmpkg6fw9cm.d(24): Error: found `0` when expecting `;`\n/tmp/tmpkg6fw9cm.d(24): Error: expression expected, not `..`\n/tmp/tmpkg6fw9cm.d(24): Error: found `k` when expecting `)`\n/tmp/tmpkg6fw9cm.d(24): Error: found `)` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkg6fw9cm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[n1];\n\tauto count = 0;\n\twhile(count < k && count < n1 * n2) \n\t{\n\t\tauto min_val = long.max;\n\t\tauto min_index = -1;\n\t\tfor(auto i = 0; i < n1; i++) \n\t\t{\n\t\t\tif(index[i] < n2 && nums1[i] + nums2[index[i]] < min_val) \n\t\t\t{\n\t\t\t\tmin_val = nums1[i] + nums2[index[i]];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\tresult[count] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t\tcount++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tauto pair = pq.peek;\n\t\t\t\tif (pair[0] + pair[1] > nums1[i] + nums2[j]) \n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tresult = new long[][](pq.length);\n\tforeach (i; 0 .. pq.length) \n\t{\n\t\tresult[i] = pq.get;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpnweammew.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnweammew.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n1, n2, n;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = n1 * n2;\n\t\n\tpairs = new long[][](n);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpzv2hcole.d(28): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzv2hcole.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tif (k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(long[2])();\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tminHeap.insert([nums1[0], nums2[0]]);\n\t\t\n\t\tauto pair = minHeap.pop();\n\t\t\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[1] < nums2[n2 - 1])\n\t\t\tminHeap.insert([pair[0], pair[1] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpu9ezsr7a.d(19): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\n/tmp/tmpu9ezsr7a.d(23): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu9ezsr7a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[][](n1, n2);\n\tauto cmp = (a, b) => (nums1[a[0]] + nums2[a[1]]) < (nums1[b[0]] + nums2[b[1]]);\n\tauto pq = new PriorityQueue!(cmp)();\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tpq.put([i, j]);\n\t\t\tif(pq.size > k)\n\t\t\t\tpq.pop();\n\t\t}\n\t}\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto p = pq.pop();\n\t\tresult[i] = [nums1[p[0]], nums2[p[1]]];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpz4veyr5l.d(14): Error: variable `tmpz4veyr5l.k_smallest_pairs.cmp` type `void` is inferred from initializer `(a, b) => nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]]`, and variables cannot be of type `void`\n/tmp/tmpz4veyr5l.d(14): Error: template lambda has no value\n/tmp/tmpz4veyr5l.d(15): Error: template instance `PriorityQueue!cmp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz4veyr5l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto heap = new Heap!(Tuple!(long, long, long));\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\theap.push(tuple(nums1[i] + nums2[j], i, j));\n\t\t}\n\t}\n\t\n\tlong[][] result;\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\tauto t = heap.pop;\n\t\tresult ~= [t[1], t[2]];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpvkwb_mk6.d(10): Error: template instance `Heap!(Tuple!(long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvkwb_mk6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. min(n1, k))\n\t{\n\t\tmin_heap.push(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif (min_heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto pair = min_heap.pop;\n\t\tresult[i] = [pair[0], pair[1]];\n\t\t\n\t\tif (pair[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tmin_heap.push(tuple(pair[0], nums2[pair[2] + 1], pair[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp715lfuhe.d(13): Error: template instance `MinHeap!(Tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmp715lfuhe.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp715lfuhe.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\tif(pq.size > k)\n\t\t\t{\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray();\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpiglho_z9.d(10): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiglho_z9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) \n\t\treturn [];\n\tif (k == 0) \n\t\treturn [];\n\t\n\tauto heap = new Heap!(long[])(true);\n\t\n\tauto first = new long[2];\n\tfirst[0] = nums1[0];\n\tfirst[1] = nums2[0];\n\theap.insert(first);\n\t\n\tauto visited = new bool[n1, n2];\n\tvisited[0] = true;\n\t\n\tauto result = new long[][];\n\twhile (k > 0 && heap.length > 0) \n\t{\n\t\tauto pair = heap.pop();\n\t\tresult ~= pair;\n\t\tk--;\n\t\t\n\t\tauto i = pair[0];\n\t\tauto j = pair[1];\n\t\t\n\t\tif (i + 1 < n1 && !visited[i + 1, j]) \n\t\t{\n\t\t\tauto next = new long[2];\n\t\t\tnext[0] = nums1[i + 1];\n\t\t\tnext[1] = nums2[j];\n\t\t\theap.insert(next);\n\t\t\tvisited[i + 1, j] = true;\n\t\t}\n\t\t\n\t\tif (j + 1 < n2 && !visited[i, j + 1]) \n\t\t{\n\t\t\tauto next = new long[2];\n\t\t\tnext[0] = nums1[i];\n\t\t\tnext[1] = nums2[j + 1];\n\t\t\theap.insert(next);\n\t\t\tvisited[i, j + 1] = true;\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpasj0sjp2.d(24): Error: found `,` when expecting `]`\n/tmp/tmpasj0sjp2.d(24): Error: semicolon expected following auto declaration, not `n2`\n/tmp/tmpasj0sjp2.d(24): Error: found `]` when expecting `;` following statement\n/tmp/tmpasj0sjp2.d(24): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpasj0sjp2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](0);\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(\n\t\t\t\t\t\t\t\t\t(a, b) => a[0] + a[1] < b[0] + b[1],\n\t\t\t\t\t\t\t\t\t(a, b) => a[0] + a[1] > b[0] + b[1]\n\t\t\t\t\t\t\t\t)();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= tuple(t[0], t[1]);\n\t\tauto idx = t[2];\n\t\tif (idx == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[idx + 1], idx + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpgoji_rag.d(16): Error: template instance `PriorityQueue!((a, b) => a[0] + a[1] < b[0] + b[1], (a, b) => a[0] + a[1] > b[0] + b[1])` template `PriorityQueue` is not defined\n/tmp/tmpgoji_rag.d(21): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgoji_rag.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n1;\n\tlong n2;\n\tlong n;\n\tlong m;\n\tlong c;\n\tlong l;\n\tlong r;\n\tlong m1;\n\tlong m2;\n\tlong t;\n\tlong[][] tmp;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = min(n1, n2);\n\tm = max(n1, n2);\n\t\n\tif (n == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tpairs = new long[n][2];\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tpairs[i][0] = i;\n\t\tpairs[i][1] = i;\n\t}\n\t\n\tif (k > n * m)\n\t{\n\t\tk = n * m;\n\t}\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tl = 0;\n\t\tr = n - 1;\n\t\t\n\t\twhile (l < r)\n\t\t{\n\t\t\tm1 = (l + r) / 2;\n\t\t\tm2 = (l + r) / 2;\n\t\t\t\n\t\t\tif (nums1[pairs[m1][0]] + nums2[pairs[m1][1]] < nums1[pairs[m2][0]] + nums2[pairs[m2][1]])\n\t\t\t{\n\t\t\t\tr = m2 - 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl = m1 + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i][0] = nums1[pairs[l][0]];\n\t\tresult[i][1] = nums2[pairs[l][1]];\n\t\t\n\t\tif\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmp0k9k2mrb.d(75): Error: found `unittest` when expecting `(`\n/tmp/tmp0k9k2mrb.d(83): Error: found `void` when expecting `)`\n/tmp/tmp0k9k2mrb.d(83): Error: found `{` when expecting `;` following statement\n/tmp/tmp0k9k2mrb.d(83): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0k9k2mrb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] > b[0] + b[1]);\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\t\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpnunnt4i9.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], (a, b) => a[0] + a[1] > b[0] + b[1])` template `PriorityQueue` is not defined\n/tmp/tmpnunnt4i9.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnunnt4i9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\t\n\tlong idx = 0;\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[idx][0] = nums1[i];\n\t\t\tpairs[idx][1] = nums2[j];\n\t\t\tidx++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i][0] = pairs[i][0];\n\t\tres[i][1] = pairs[i][1];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpq4x8v4dn.d(27): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq4x8v4dn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto heap = new Heap!(long[2], \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\t}\n\t}\n\t\n\tauto result = new long[][2][];\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult ~= heap.pop();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpdqllgt8y.d(10): Error: template instance `Heap!(long[2], \"a[0] + a[1]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\n/tmp/tmpdqllgt8y.d(19): Error: new can only create structs, dynamic arrays or class objects, not `long[][2][]`'s\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdqllgt8y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tforeach (j; 0 .. min(k, n2))\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t\tminHeap.insert([nums1[i] + nums2[j], i, j]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < minHeap.top[0])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop;\n\t\t\t\t\tminHeap.insert([nums1[i] + nums2[j], i, j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](minHeap.length);\n\t\n\tforeach (i; 0 .. minHeap.length)\n\t{\n\t\tresult[i] = minHeap.pop[1 .. $];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmphco56mwy.d(16): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\n/tmp/tmphco56mwy.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphco56mwy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto cmp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\tauto pq = new PriorityQueue!(cmp)();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pq.toArray();\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmppj1v9ydu.d(10): Error: variable `tmppj1v9ydu.k_smallest_pairs.cmp` type `void` is inferred from initializer `(a, b) => a[0] + a[1] > b[0] + b[1]`, and variables cannot be of type `void`\n/tmp/tmppj1v9ydu.d(10): Error: template lambda has no value\n/tmp/tmppj1v9ydu.d(11): Error: template instance `PriorityQueue!cmp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppj1v9ydu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\t\n\tpairs = new long[nums1.length * nums2.length][2];\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[i * nums2.length + j][0] = nums1[i];\n\t\t\tpairs[i * nums2.length + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\tpairs = pairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpy3uwl04s.d(13): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpy3uwl04s.d(24): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy3uwl04s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] distances;\n\tlong[] distances_sorted;\n\tlong[] distances_sorted_indexes;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong d;\n\tlong d_min;\n\tlong d_min_index;\n\tlong d_min_index_tmp;\n\tlong d_min_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp;\n\tlong d_min_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index_tmp_index;\n\tlong d_min_index_tmp\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpnraxikdv.d(39): Error: semicolon expected, not `unittest`\n/tmp/tmpnraxikdv.d(39): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnraxikdv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto minHeap = new MinHeap!(long[2]);\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn [];\n\t\n\tforeach (i; 0 .. n)\n\t{\n\t\tif (i < k)\n\t\t\tminHeap.insert([nums1[i], nums2[0]]);\n\t\telse\n\t\t\tbreak;\n\t}\n\t\n\tauto result = new long[][2](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto pair = minHeap.pop();\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[1] < nums2[m - 1])\n\t\t{\n\t\t\tauto next = [pair[0], pair[1] + 1];\n\t\t\tminHeap.insert(next);\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpwk6fl9ph.d(12): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\n/tmp/tmpwk6fl9ph.d(25): Error: function expected before `()`, not `new long[][](2LU)` of type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwk6fl9ph.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i, j, m, n, p, q, r, s, t, u;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tpairs[i * nums2.length + j] = new long[2];\n\t\t\tpairs[i * nums2.length + j][0] = nums1[i];\n\t\t\tpairs[i * nums2.length + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttemp = new long[][](pairs.length);\n\t\n\tfor (i = 0; i < pairs.length; i++)\n\t{\n\t\ttemp[i] = new long[2];\n\t\ttemp[i][0] = pairs[i][0];\n\t\ttemp[i][1] = pairs[i][1];\n\t}\n\t\n\tfor (i = 0; i < pairs.length; i++)\n\t{\n\t\tfor (j = i + 1; j < pairs.length; j++)\n\t\t{\n\t\t\tif (pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1])\n\t\t\t{\n\t\t\t\tm = pairs[i][0];\n\t\t\t\tn = pairs[i][1];\n\t\t\t\tpairs[i][0] = pairs[j][0];\n\t\t\t\tpairs[i][1] = pairs[j][1];\n\t\t\t\tpairs[j][0] = m;\n\t\t\t\tpairs[j][1] = n;\n\t\t\t}\n\t\t}\n\t\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpng5d8r6y.d(56): Error: found `unittest` instead of statement\n/tmp/tmpng5d8r6y.d(64): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpng5d8r6y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put(new long[] { nums1[i], nums2[j] });\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.poll();\n\t\t\t\t\tpq.put(new long[] { nums1[i], nums2[j] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray();\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmppu0jc6et.d(11): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmppu0jc6et.d(14): Error: declaration expected, not `foreach`\n/tmp/tmppu0jc6et.d(14): Error: declaration expected, not `0`\n/tmp/tmppu0jc6et.d(16): Error: declaration expected, not `0`\n/tmp/tmppu0jc6et.d(21): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppu0jc6et.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn new long[][] {};\n\tif (k == 0)\n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(new long[] {nums1[i], nums2[0], 0});\n\t}\n\t\n\tauto res = new long[][](k);\n\tint i = 0;\n\twhile (i < k && !pq.empty())\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i++] = new long[] {cur[0], cur[1]};\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[] {cur[0], nums2[cur[2] + 1], cur[2] + 1});\n\t}\n\treturn res[0 .. i];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpntowcd5u.d(13): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpntowcd5u.d(14): Error: declaration expected, not `if`\n/tmp/tmpntowcd5u.d(19): Error: declaration expected, not `foreach`\n/tmp/tmpntowcd5u.d(19): Error: declaration expected, not `0`\n/tmp/tmpntowcd5u.d(22): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpntowcd5u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([t[0], nums2[t[2] + 1], t[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpc1c8_5tt.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc1c8_5tt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long, long, long)[](), Tuple!(long, long, long, long)[]());\n\t\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile (k > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[t[3]] = tuple(nums1[t[1]], nums2[t[2]]);\n\t\tif (t[1] + 1 < nums1.length) pq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], t[3] + 1));\n\t\tif (t[2] + 1 < nums2.length) pq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, t[3] + 1));\n\t\tk--;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpw0vab5yl.d(13): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long, long, long)[](), Tuple!(long, long, long, long)[]())` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw0vab5yl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tlong i, j, n1, n2;\n\tlong[][] pairs;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tforeach(i; 0 .. n1)\n\t\tforeach(j; 0 .. n2)\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tres = new long[][](min(k, n1 * n2));\n\t\n\tforeach(i; 0 .. min(k, n1 * n2))\n\t\tres[i] = pairs[i];\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpelg1q45c.d(19): Error: variable `i` is shadowing variable `tmpelg1q45c.k_smallest_pairs.i`\n/tmp/tmpelg1q45c.d(20): Error: variable `j` is shadowing variable `tmpelg1q45c.k_smallest_pairs.j`\n/tmp/tmpelg1q45c.d(23): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\n/tmp/tmpelg1q45c.d(25): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpelg1q45c.d(27): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpelg1q45c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tres = new long[][](k);\n\t\n\tfor(i = 0; i < k; i++)\n\t{\n\t\tres[i] = pairs[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp54k9ky2s.d(14): Error: variable `nums1` cannot be read at compile time\n/tmp/tmp54k9ky2s.d(26): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp54k9ky2s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\n\tres = new long[][](k);\n\tforeach (i; 0 .. k)\n\t\tres[i] = pq.get();\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpn0357hak.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn0357hak.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[k][2];\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn res;\n\t\n\tlong[][] arr = new long[nums1.length][nums2.length];\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tarr[i][j] = num1 + num2;\n\t\t}\n\t}\n\t\n\tauto cmp = (a, b) => a[0] > b[0];\n\t\n\tauto pq = new PriorityQueue!(cmp)();\n\tforeach(i, num1; nums1)\n\t{\n\t\tpq.put([arr[i][0], i, 0]);\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [nums1[t[1]], nums2[t[2]]];\n\t\tif(t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([arr[t[1]][t[2] + 1], t[1], t[2] + 1]);\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmppmg17o6l.d(10): Error: variable `k` cannot be read at compile time\n/tmp/tmppmg17o6l.d(14): Error: variable `nums1` cannot be read at compile time\n/tmp/tmppmg17o6l.d(23): Error: variable `tmppmg17o6l.k_smallest_pairs.cmp` type `void` is inferred from initializer `(a, b) => a[0] > b[0]`, and variables cannot be of type `void`\n/tmp/tmppmg17o6l.d(23): Error: template lambda has no value\n/tmp/tmppmg17o6l.d(25): Error: template instance `PriorityQueue!cmp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppmg17o6l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tauto res = new long[][](k);\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j], i, j));\n\t\t\tif(pq.size() > k)\n\t\t\t\tpq.get();\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [t[0], t[1]];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp7rquff17.d(10): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7rquff17.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\tif(pq.size() > k)\n\t\t\t\tpq.poll();\n\t\t}\n\t}\n\treturn pq.toArray();\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpkrmurk7e.d(10): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkrmurk7e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long), \"a[0] + b[0]\");\n\tauto result = new long[][](k);\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\theap.insert(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = heap.popFront();\n\t\tresult[i] = [t[1], t[0]];\n\t\t\n\t\tif (t[2] == 0 && t[3] + 1 < m)\n\t\t\theap.insert(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t\n\t\tif (t[2] + 1 < n)\n\t\t\theap.insert(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpnu6891l4.d(12): Error: template instance `Heap!(Tuple!(long, long, long, long), \"a[0] + b[0]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnu6891l4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tres ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmphya3kw_8.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphya3kw_8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto heap = new Heap!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[0] + a[1]\");\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\theap.insert(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = heap.popFront();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] < m - 1)\n\t\t{\n\t\t\theap.insert(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpda5pekqp.d(13): Error: template instance `Heap!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[0] + a[1]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpda5pekqp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[] temp_array;\n\tlong i;\n\tlong j;\n\tlong m;\n\tlong n;\n\tlong count;\n\tlong index;\n\tlong min;\n\tlong min_index;\n\tlong temp_index;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tif (m == 0 || n == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](k);\n\ttemp = new long[][](m);\n\ttemp_array = new long[m];\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\ttemp[i] = new long[2];\n\t\ttemp[i][0] = nums1[i];\n\t\ttemp[i][1] = nums2[0];\n\t\ttemp_array[i] = nums2[0] + nums1[i];\n\t}\n\t\n\tcount = 0;\n\twhile (count < k)\n\t{\n\t\tmin = temp_array[0];\n\t\tmin_index = 0;\n\t\tfor (i = 1; i < m; i++)\n\t\t{\n\t\t\tif (temp_array[i] < min)\n\t\t\t{\n\t\t\t\tmin = temp_array[i];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[count] = new long[2];\n\t\tresult[count][0] = temp[min_index][0];\n\t\tresult[count][1] = temp[min_index][1];\n\t\t\n\t\tindex = temp[min_index][1];\n\t\tif (index == nums2[n - 1])\n\t\t{\n\t\t\ttemp_array[min_index] = long.max;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tindex++;\n\t\t\ttemp[min_index][1] = nums2[index];\n\t\t\ttemp_array[min_index] = nums1[min\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmphggntlrw.d(69): Error: found `unittest` when expecting `,`\n/tmp/tmphggntlrw.d(77): Error: found `void` when expecting `,`\n/tmp/tmphggntlrw.d(77): Error: found `{` when expecting `,`\n/tmp/tmphggntlrw.d(77): Error: expression expected, not `}`\n/tmp/tmphggntlrw.d(77): Error: found `End of File` when expecting `,`\n/tmp/tmphggntlrw.d(77): Error: found `End of File` when expecting `]`\n/tmp/tmphggntlrw.d(77): Error: found `End of File` when expecting `;` following statement\n/tmp/tmphggntlrw.d(77): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmphggntlrw.d(77): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmphggntlrw.d(77): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphggntlrw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp6g4zhdb8.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6g4zhdb8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(long[])();\n\tauto visited = new bool[len1][len2];\n\t\n\tminHeap.push([nums1[0], nums2[0]]);\n\tvisited[0][0] = true;\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !minHeap.empty; ++i)\n\t{\n\t\tauto pair = minHeap.pop;\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[0] < nums1[len1 - 1] && pair[1] < nums2[len2 - 1])\n\t\t{\n\t\t\tauto nextX = min(len1 - 1, lower_bound(nums1, pair[0] + 1));\n\t\t\tauto nextY = min(len2 - 1, lower_bound(nums2, pair[1] + 1));\n\t\t\t\n\t\t\tif (!visited[nextX][nextY])\n\t\t\t{\n\t\t\t\tminHeap.push([nums1[nextX], nums2[nextY]]);\n\t\t\t\tvisited[nextX][nextY] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (pair[0] < nums1[len1 - 1])\n\t\t{\n\t\t\tauto nextX = min(len1 - 1, lower_bound(nums1, pair[0] + 1));\n\t\t\tif (!visited[nextX][0])\n\t\t\t{\n\t\t\t\tminHeap.push([nums1[nextX], nums2[0]]);\n\t\t\t\tvisited[nextX][0] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (pair[1] < nums2[len2 - 1])\n\t\t{\n\t\t\tauto nextY\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpuvhu4fqg.d(53): Error: no identifier for declarator `nextY`\n/tmp/tmpuvhu4fqg.d(53): Error: found `unittest` instead of statement\n/tmp/tmpuvhu4fqg.d(61): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpuvhu4fqg.d(61): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuvhu4fqg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]{};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.put(new long[]{nums1[i], nums2[j]});\n\t\t\t\t\tpq.put(top);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpq.put(top);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto res = new long[][]();\n\twhile (pq.length > 0)\n\t\tres ~= pq.get();\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpj550avkb.d(11): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpj550avkb.d(15): Error: declaration expected, not `foreach`\n/tmp/tmpj550avkb.d(15): Error: declaration expected, not `0`\n/tmp/tmpj550avkb.d(17): Error: declaration expected, not `0`\n/tmp/tmpj550avkb.d(21): Error: declaration expected, not `else`\n/tmp/tmpj550avkb.d(24): Error: declaration expected, not `if`\n/tmp/tmpj550avkb.d(27): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpj550avkb.d(27): Error: no identifier for declarator `pq.put(top)`\n/tmp/tmpj550avkb.d(28): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj550avkb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pq.toArray();\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp925g86in.d(10): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp925g86in.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong l;\n\tlong r;\n\tlong mid;\n\tlong count;\n\tlong[][] temp1;\n\tlong[][] temp2;\n\tlong[][] temp3;\n\tlong[][] temp4;\n\tlong[][] temp5;\n\tlong[][] temp6;\n\tlong[][] temp7;\n\tlong[][] temp8;\n\tlong[][] temp9;\n\tlong[][] temp10;\n\tlong[][] temp11;\n\tlong[][] temp12;\n\tlong[][] temp13;\n\tlong[][] temp14;\n\tlong[][] temp15;\n\tlong[][] temp16;\n\tlong[][] temp17;\n\tlong[][] temp18;\n\tlong[][] temp19;\n\tlong[][] temp20;\n\tlong[][] temp21;\n\tlong[][] temp22;\n\tlong[][] temp23;\n\tlong[][] temp24;\n\tlong[][] temp25;\n\tlong[][] temp26;\n\tlong[][] temp27;\n\tlong[][] temp28;\n\tlong[][] temp29;\n\tlong[][] temp30;\n\tlong[][] temp31;\n\tlong[][] temp32;\n\tlong[][] temp33;\n\tlong[][] temp34;\n\tlong[][] temp35;\n\tlong[][] temp36;\n\tlong[][] temp37;\n\tlong[][] temp38;\n\tlong[][] temp39;\n\tlong[][] temp40;\n\tlong[][] temp41;\n\tlong[][] temp42;\n\tlong[][] temp43;\n\tlong[][] temp44;\n\tlong[][] temp45;\n\tlong[][] temp46;\n\tlong[][] temp47;\n\tlong[][] temp48;\n\tlong[][] temp49;\n\tlong[][\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp7ii04g0z.d(71): Error: expression expected, not `unittest`\n/tmp/tmp7ii04g0z.d(72): Error: found `{` when expecting `]`\n/tmp/tmp7ii04g0z.d(73): Error: no identifier for declarator `long[][0]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ii04g0z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tpq.put([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpjleasjph.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpjleasjph.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjleasjph.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] > b[0]\");\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tfor (long i = 0; i < min(k, n1); i++)\n\t\tpq.put(tuple(nums1[i] + nums2[0], i, 0, nums1[i]));\n\t\n\tfor (long i = 0; i < k; i++)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = t[3];\n\t\tresult[i][1] = nums2[t[2]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, nums1[t[1]]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpn92k200x.d(13): Error: template instance `PriorityQueue!(tuple!(long, long, long, long), \"a[0] > b[0]\")` template `PriorityQueue` is not defined\n/tmp/tmpn92k200x.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn92k200x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor (long i = 0; i < len; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp3lxiez6q.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3lxiez6q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(tuple(long, long, long))(tuple(nums1[0], nums2[0], 0), (a, b) => a[0] + a[1] > b[0] + b[1]);\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tauto t = heap.pop();\n\t\t\n\t\tif (i == k)\n\t\t\tbreak;\n\t\t\n\t\tif (t[2] < n2 - 1)\n\t\t\theap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn heap.map!(t => [t[0], t[1]]).array;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpaj157nuf.d(16): Error: found `,` when expecting `.` following long\n/tmp/tmpaj157nuf.d(16): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpaj157nuf.d(16): Error: found `)` when expecting `.` following long\n/tmp/tmpaj157nuf.d(16): Error: found `)` when expecting identifier following `long`.\n/tmp/tmpaj157nuf.d(16): Error: found `;` when expecting `,`\n/tmp/tmpaj157nuf.d(18): Error: expression expected, not `foreach`\n/tmp/tmpaj157nuf.d(18): Error: found `;` when expecting `,`\n/tmp/tmpaj157nuf.d(18): Error: found `..` when expecting `,`\n/tmp/tmpaj157nuf.d(19): Error: found `{` when expecting `,`\n/tmp/tmpaj157nuf.d(20): Error: expression expected, not `auto`\n/tmp/tmpaj157nuf.d(20): Error: found `t` when expecting `,`\n/tmp/tmpaj157nuf.d(20): Error: expression expected, not `=`\n/tmp/tmpaj157nuf.d(20): Error: found `heap` when expecting `,`\n/tmp/tmpaj157nuf.d(20): Error: found `;` when expecting `,`\n/tmp/tmpaj157nuf.d(22): Error: expression expected, not `if`\n/tmp/tmpaj157nuf.d(23): Err",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[n1];\n\t\n\tfor(long i = 0; i < k && i < n1 * n2; i++)\n\t{\n\t\tlong min_val = long.max;\n\t\tlong min_index = -1;\n\t\tfor(long j = 0; j < n1; j++)\n\t\t{\n\t\t\tif(index[j] < n2 && nums1[j] + nums2[index[j]] < min_val)\n\t\t\t{\n\t\t\t\tmin_val = nums1[j] + nums2[index[j]];\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\tresult[i] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\theap.insert(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor(long i = 0; i < k && !heap.empty; i++)\n\t{\n\t\tauto t = heap.popFront;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[2] == 0 && t[3] + 1 < n2)\n\t\t\theap.insert(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\tif(t[2] + 1 < n1)\n\t\t\theap.insert(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpq8xuelt5.d(16): Error: template instance `Heap!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq8xuelt5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long));\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile (k > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[t[3]] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[2] == 0 && t[1] + 1 < n1)\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], t[3] + 1));\n\t\t\n\t\tif (t[2] + 1 < n2)\n\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, t[3] + 1));\n\t\t\n\t\tk--;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpw78n0cst.d(13): Error: template instance `PriorityQueue!(tuple!(long, long, long, long))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw78n0cst.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp78ld3sgd.d(13): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp78ld3sgd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong min;\n\tlong min_i;\n\tlong min_j;\n\tlong[][] tmp;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpairs = new long[n][m];\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin = pairs[0][0];\n\t\tmin_i = 0;\n\t\tmin_j = 0;\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tfor (long l = 0; l < m; l++)\n\t\t\t{\n\t\t\t\tif (pairs[j][l] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = pairs[j][l];\n\t\t\t\t\tmin_i = j;\n\t\t\t\t\tmin_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i][0] = nums1[min_i];\n\t\tresult[i][1] = nums2[min_j];\n\t\tpairs[min_i][min_j] = long.max;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp1t0n9nat.d(27): Error: variable `n` cannot be read at compile time\n/tmp/tmp1t0n9nat.d(37): Error: variable `k` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1t0n9nat.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn res;\n\t\n\tfor (long i = 0; i < min(k, n1); i++)\n\t\tpq.put(new long[]{nums1[i], nums2[0], 0});\n\t\n\tfor (long i = 0; i < k && !pq.empty(); i++)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = new long[]{cur[0], cur[1]};\n\t\t\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(new long[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpfsks4vlm.d(19): Error: found `{` when expecting `,`\n/tmp/tmpfsks4vlm.d(19): Error: found `}` when expecting `,`\n/tmp/tmpfsks4vlm.d(24): Error: found `{` when expecting `;` following statement\n/tmp/tmpfsks4vlm.d(24): Error: found `}` when expecting `;` following statement\n/tmp/tmpfsks4vlm.d(24): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpfsks4vlm.d(29): Error: found `{` when expecting `,`\n/tmp/tmpfsks4vlm.d(29): Error: found `}` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfsks4vlm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(tuple!(long, long, long, long));\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && heap.length > 0; i++)\n\t{\n\t\tauto t = heap.pop();\n\t\t\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[3] == 0)\n\t\t{\n\t\t\tif (t[1] + 1 < n1)\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 0));\n\t\t\t\n\t\t\tif (t[2] + 1 < n2)\n\t\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (t[2] + 1 < n2)\n\t\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpwzts0ygm.d(16): Error: template instance `MinHeap!(tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwzts0ygm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(tuple!(long, long, long));\n\theap.push(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\tfor(int i = 0; i < k && !heap.empty; ++i)\n\t{\n\t\tauto t = heap.pop;\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\tif(t[2] == 0 && t[1] + 1 < n1)\n\t\t\theap.push(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\tif(t[2] + 1 < n2)\n\t\t\theap.push(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp16oeqrdb.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp16oeqrdb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(Tuple!(long, long, long)));\n\t\n\tforeach (i; 0 .. min(k, n))\n\t{\n\t\tminHeap.push(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto top = minHeap.pop();\n\t\tresult[i] = [nums1[top[1]], nums2[top[2]]];\n\t\t\n\t\tif (top[2] == m - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(nums1[top[1]] + nums2[top[2] + 1], top[1], top[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp42jvbr1s.d(16): Error: template instance `MinHeap!(typeof(Tuple!(long, long, long)))` template `MinHeap` is not defined\n/tmp/tmp42jvbr1s.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp42jvbr1s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 0 .. m)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.top;\n\t\t\t\tif(top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.pop;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp0xjeg2gw.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0xjeg2gw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. min(nums1.length, k))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= [cur[0], cur[1]];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmptdkxrg5h.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1])` template `PriorityQueue` is not defined\n/tmp/tmptdkxrg5h.d(16): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptdkxrg5h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\tauto pq = new PriorityQueue!((a, b) => a[0] + a[1] > b[0] + b[1]);\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([t[0], nums2[t[2] + 1], t[2] + 1]);\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpj779s4yg.d(13): Error: template instance `PriorityQueue!((a, b) => a[0] + a[1] > b[0] + b[1])` template `PriorityQueue` is not defined\n/tmp/tmpj779s4yg.d(14): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj779s4yg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong i;\n\tlong j;\n\tlong x;\n\tlong y;\n\tlong z;\n\tlong t;\n\tlong m;\n\tlong n;\n\tlong p;\n\tlong q;\n\tlong r;\n\tlong s;\n\tlong a;\n\tlong b;\n\tlong c;\n\tlong d;\n\tlong e;\n\tlong f;\n\tlong g;\n\tlong h;\n\tlong l;\n\tlong o;\n\tlong u;\n\tlong v;\n\tlong w;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpc1hfc_t5.d(90): Error: semicolon expected, not `unittest`\n/tmp/tmpc1hfc_t5.d(90): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc1hfc_t5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto result = new long[][](k);\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + b[0]\", \"a[1] < b[1]\");\n\t\n\tforeach(i; 0 .. min(k, n))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == m - 1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp_rykb6cd.d(14): Error: found `,` when expecting `.` following long\n/tmp/tmp_rykb6cd.d(14): Error: found `long` when expecting identifier following `long`.\n/tmp/tmp_rykb6cd.d(14): Error: found `,` when expecting `.` following long\n/tmp/tmp_rykb6cd.d(14): Error: found `long` when expecting identifier following `long`.\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_rykb6cd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tpq.put(tuple(num1, num2, i, j));\n\t\t\tif(pq.length > k)\n\t\t\t\tpq.popFront();\n\t\t}\n\t}\n\t\n\tauto res = new long[][](pq.length);\n\tforeach(i, t; pq)\n\t{\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = t[2];\n\t\tres[i][1] = t[3];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpg79om_8y.d(10): Error: found `,` when expecting `.` following long\n/tmp/tmpg79om_8y.d(10): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpg79om_8y.d(10): Error: found `,` when expecting `.` following long\n/tmp/tmpg79om_8y.d(10): Error: found `long` when expecting identifier following `long`.\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg79om_8y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[n1];\n\tauto count = 0;\n\twhile(count < k && count < n1 * n2)\n\t{\n\t\tauto min_val = long.max;\n\t\tauto min_index = long.max;\n\t\tfor(auto i = 0; i < n1; i++)\n\t\t{\n\t\t\tif(index[i] < n2 && nums1[i] + nums2[index[i]] < min_val)\n\t\t\t{\n\t\t\t\tmin_val = nums1[i] + nums2[index[i]];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\tresult[count] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t\tcount++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i, j;\n\tlong n1 = nums1.length;\n\tlong n2 = nums2.length;\n\tlong n = n1 * n2;\n\tlong m = min(k, n);\n\t\n\tpairs = new long[][](n, 2);\n\tresult = new long[][](m, 2);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpairs[i * n2 + j][0] = nums1[i];\n\t\t\tpairs[i * n2 + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\ttemp = pairs[0 .. m];\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(temp);\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpwc5zuqa9.d(17): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpwc5zuqa9.d(33): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwc5zuqa9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n * m))\n\t\tpq.put([nums1[i / m], nums2[i % m]]);\n\t\n\tforeach (i; 0 .. k)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp4eftqs2s.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmp4eftqs2s.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4eftqs2s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach (i; 0 .. min(k, nums1.length * nums2.length))\n\t{\n\t\tpq.put(new long[](nums1[i / nums2.length], nums2[i % nums2.length]));\n\t}\n\t\n\tauto result = new long[][](pq.length);\n\t\n\tforeach (i; 0 .. pq.length)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpf51dejes.d(11): Error: new can only create structs, dynamic arrays or class objects, not `long[][]`'s\n/tmp/tmpf51dejes.d(13): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\n/tmp/tmpf51dejes.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf51dejes.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tpairs[i * nums2.length + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp4m1at7r4.d(24): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4m1at7r4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\theap.insert([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; k .. n1 * n2)\n\t{\n\t\tauto top = heap.top;\n\t\tif (nums1[i / n2] + nums2[i % n2] < top[0] + top[1])\n\t\t{\n\t\t\theap.pop;\n\t\t\theap.insert([nums1[i / n2], nums2[i % n2]]);\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = heap.pop;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpt4e74ojt.d(13): Error: template instance `Heap!(long[], \"a[0] + a[1]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\n/tmp/tmpt4e74ojt.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt4e74ojt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = n1 * n2;\n\tauto arr = new long[][](n);\n\tauto idx = 0;\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tarr[idx] = [nums1[i], nums2[j]];\n\t\t\tidx++;\n\t\t}\n\t}\n\tarr.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\treturn arr[0 .. k];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpupij7tsk.d(23): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpupij7tsk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto pairs = new long[][](len, 2);\n\t\n\tfor (size_t i = 0; i < len; i++)\n\t{\n\t\tpairs[i][0] = nums1[i];\n\t\tpairs[i][1] = nums2[i];\n\t}\n\t\n\treturn pairs;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpd1iiznpm.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd1iiznpm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tlong[][] tmp = new long[][](nums1.length * nums2.length);\n\tlong i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttmp[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\ttmp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\tfor(long j = 0; j < k; j++)\n\t{\n\t\tres[j] = tmp[j];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpub7geoc3.d(21): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpub7geoc3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong len;\n\tlong len1;\n\tlong len2;\n\tlong min;\n\tlong min_index;\n\tlong min_index1;\n\tlong min_index2;\n\tlong min_index3;\n\tlong min_index4;\n\tlong min_index5;\n\tlong min_index6;\n\tlong min_index7;\n\tlong min_index8;\n\tlong min_index9;\n\tlong min_index10;\n\tlong min_index11;\n\tlong min_index12;\n\tlong min_index13;\n\tlong min_index14;\n\tlong min_index15;\n\tlong min_index16;\n\tlong min_index17;\n\tlong min_index18;\n\tlong min_index19;\n\tlong min_index20;\n\tlong min_index21;\n\tlong min_index22;\n\tlong min_index23;\n\tlong min_index24;\n\tlong min_index25;\n\tlong min_index26;\n\tlong min_index27;\n\tlong min_index28;\n\tlong min_index29;\n\tlong min_index30;\n\tlong min_index31;\n\tlong min_index32;\n\tlong min_index33;\n\tlong min_index34;\n\tlong min_index35;\n\tlong min_index36;\n\tlong min_index37;\n\tlong min_index38;\n\tlong min_index39;\n\tlong min_index40;\n\tlong min_index41;\n\tlong min_index42;\n\tlong min_index43;\n\tlong min_index44;\n\tlong min_index45;\n\tlong min_index46;\n\tlong min_index47;\n\tlong min_index48;\n\tlong min_index49;\n\tlong min_index50;\n\tlong min_index51;\n\tlong min_index52;\n\tlong min_index53;\n\tlong min_index54;\n\tlong min_\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmprafy2bfc.d(77): Error: semicolon expected, not `unittest`\n/tmp/tmprafy2bfc.d(77): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprafy2bfc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = PriorityQueue!(long[], \"a[0] + a[1]\")(nums1.length * nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t}\n\t}\n\t\n\tlong[][] result;\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(pq.empty)\n\t\t\tbreak;\n\t\tresult ~= pq.get;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmps2s3qysv.d(10): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps2s3qysv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tpq.put(tuple(n1, n2, i, j));\n\t\t\tif(pq.length > k)\n\t\t\t\tpq.pop();\n\t\t}\n\t}\n\t\n\tauto res = new long[][](pq.length);\n\tforeach(i, t; pq)\n\t\tres[i] = [t[0], t[1]];\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpyefmc27_.d(10): Error: found `,` when expecting `.` following long\n/tmp/tmpyefmc27_.d(10): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpyefmc27_.d(10): Error: found `,` when expecting `.` following long\n/tmp/tmpyefmc27_.d(10): Error: found `long` when expecting identifier following `long`.\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyefmc27_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[k][2];\n\tlong[][] pairs = new long[nums1.length * nums2.length][2];\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index][0] = nums1[i];\n\t\t\tpairs[index][1] = nums2[j];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp4ki7rt6k.d(10): Error: variable `k` cannot be read at compile time\n/tmp/tmp4ki7rt6k.d(11): Error: variable `nums1` cannot be read at compile time\n/tmp/tmp4ki7rt6k.d(23): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ki7rt6k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, m, n;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tresult = new long[][](k);\n\ttemp = new long[m];\n\t\n\tfor (i = 0; i < m; i++)\n\t\ttemp[i] = nums1[i] + nums2[0];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tlong min = temp[0];\n\t\tlong min_index = 0;\n\t\t\n\t\tfor (j = 1; j < m; j++)\n\t\t{\n\t\t\tif (temp[j] < min)\n\t\t\t{\n\t\t\t\tmin = temp[j];\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[min_index];\n\t\tresult[i][1] = nums2[0];\n\t\t\n\t\tif (nums2.length == 1)\n\t\t\ttemp[min_index] = long.max;\n\t\telse\n\t\t{\n\t\t\ttemp[min_index] = nums1[min_index] + nums2[1];\n\t\t\tnums2 = nums2[1 .. $];\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1vjy4vgb.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x429771]\n??:? void tmp1vjy4vgb.__unittest_L55_C1() [0x4287c3]\n??:? void tmp1vjy4vgb.__modtest() [0x42895c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42944e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42afc9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b058]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42af55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429425]\n??:? runModuleUnitTests [0x42e0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429c34]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0) \n\t\treturn new long[][]{};\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, nums1.length * nums2.length)) \n\t{\n\t\tpq.put(new long[]{nums1[i / nums2.length], nums2[i % nums2.length]});\n\t}\n\t\n\tauto result = new long[][](k);\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpwd5lebtz.d(11): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpwd5lebtz.d(15): Error: declaration expected, not `foreach`\n/tmp/tmpwd5lebtz.d(15): Error: declaration expected, not `0`\n/tmp/tmpwd5lebtz.d(18): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwd5lebtz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp0i1mfq5q.d(14): Error: template instance `PriorityQueue!((a, b) => a[0] + a[1] < b[0] + b[1])` template `PriorityQueue` is not defined\n/tmp/tmp0i1mfq5q.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0i1mfq5q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[])();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpamaz0kl1.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[])` template `PriorityQueue` is not defined\n/tmp/tmpamaz0kl1.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpamaz0kl1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, l, m;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tfor (i = 0; i < nums1.length && i < k; i++)\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t\n\twhile (k-- > 0 && pq.length > 0)\n\t{\n\t\ttemp = pq.get();\n\t\tif (result.length == 0)\n\t\t\tresult ~= temp[0..1];\n\t\telse\n\t\t\tresult ~= temp[0..1];\n\t\t\n\t\tif (temp[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(new long[](temp[0], nums2[temp[2] + 1], temp[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpu3u2fa27.d(17): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu3u2fa27.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 0 .. m)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.top;\n\t\t\t\tif(top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.pop;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp0xjeg2gw.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0xjeg2gw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\theap.insert([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; k .. n1 * n2)\n\t{\n\t\tauto [a, b] = heap.top;\n\t\tif (nums1[i / n2] + nums2[i % n2] < a + b)\n\t\t{\n\t\t\theap.pop;\n\t\t\theap.insert([nums1[i / n2], nums2[i % n2]]);\n\t\t}\n\t}\n\t\n\treturn heap.data[0 .. $];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpcp8o4eom.d(24): Error: basic type expected, not `[`\n/tmp/tmpcp8o4eom.d(24): Error: found `,` when expecting `]`\n/tmp/tmpcp8o4eom.d(24): Error: semicolon expected, not `]`\n/tmp/tmpcp8o4eom.d(24): Error: found `]` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcp8o4eom.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m, p;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tp = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[p][0] = nums1[i];\n\t\t\tpairs[p][1] = nums2[j];\n\t\t\tp++;\n\t\t}\n\t}\n\t\n\tsort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = pairs[i][0];\n\t\tresult[i][1] = pairs[i][1];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp6177i8mu.d(30): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6177i8mu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp4_unod6x.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4_unod6x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, m, n;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tpairs = new long[][](m * n);\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tpairs[i * n + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpwbicur20.d(27): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwbicur20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n1;\n\tlong n2;\n\tlong n;\n\tlong m;\n\tlong[][] temp;\n\tlong[][] temp2;\n\tlong[][] temp3;\n\tlong[][] temp4;\n\tlong[][] temp5;\n\tlong[][] temp6;\n\tlong[][] temp7;\n\tlong[][] temp8;\n\tlong[][] temp9;\n\tlong[][] temp10;\n\tlong[][] temp11;\n\tlong[][] temp12;\n\tlong[][] temp13;\n\tlong[][] temp14;\n\tlong[][] temp15;\n\tlong[][] temp16;\n\tlong[][] temp17;\n\tlong[][] temp18;\n\tlong[][] temp19;\n\tlong[][] temp20;\n\tlong[][] temp21;\n\tlong[][] temp22;\n\tlong[][] temp23;\n\tlong[][] temp24;\n\tlong[][] temp25;\n\tlong[][] temp26;\n\tlong[][] temp27;\n\tlong[][] temp28;\n\tlong[][] temp29;\n\tlong[][] temp30;\n\tlong[][] temp31;\n\tlong[][] temp32;\n\tlong[][] temp33;\n\tlong[][] temp34;\n\tlong[][] temp35;\n\tlong[][] temp36;\n\tlong[][] temp37;\n\tlong[][] temp38;\n\tlong[][] temp39;\n\tlong[][] temp40;\n\tlong[][] temp41;\n\tlong[][] temp42;\n\tlong[][] temp43;\n\tlong[][] temp44;\n\tlong[][] temp45;\n\tlong[][] temp46;\n\tlong[][] temp47;\n\tlong[][] temp48;\n\tlong[][] temp49;\n\tlong[][] temp50;\n\tlong[][] temp51;\n\tlong[\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp5p39hhv_.d(70): Error: expression expected, not `unittest`\n/tmp/tmp5p39hhv_.d(71): Error: found `{` when expecting `]`\n/tmp/tmp5p39hhv_.d(72): Error: no identifier for declarator `long[0]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5p39hhv_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[k][2];\n\tif(nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i][0] = t[0];\n\t\tresult[i][1] = t[1];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpa2fmmj15.d(10): Error: variable `k` cannot be read at compile time\n/tmp/tmpa2fmmj15.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa2fmmj15.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j, l, m;\n\tlong min;\n\tlong min_index;\n\tlong min_index_i;\n\tlong min_index_j;\n\tlong[][] arr;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tarr = new long[nums1.length][nums2.length];\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tarr[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin = arr[0][0];\n\t\tmin_index_i = 0;\n\t\tmin_index_j = 0;\n\t\tfor (j = 0; j < nums1.length; j++)\n\t\t{\n\t\t\tfor (l = 0; l < nums2.length; l++)\n\t\t\t{\n\t\t\t\tif (arr[j][l] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = arr[j][l];\n\t\t\t\t\tmin_index_i = j;\n\t\t\t\t\tmin_index_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i][0] = nums1[min_index_i];\n\t\tresult[i][1] = nums2[min_index_j];\n\t\tarr[min_index_i][min_index_j] = long.max;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpe26_efpp.d(22): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpe26_efpp.d(32): Error: variable `k` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe26_efpp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\t\n\tforeach(i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpn4lnzrap.d(13): Error: template instance `PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpn4lnzrap.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn4lnzrap.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tfor (long i = 0; i < n1 && i < k; i++) \n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty(); i++) \n\t{\n\t\tauto cur = pq.pop();\n\t\tres[i] = new long[](cur[0], cur[1]);\n\t\t\n\t\tif (cur[2] == n2 - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpcydbethg.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcydbethg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tauto minHeap = new MinHeap!(long[2]);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.push([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse if (nums1[i] + nums2[j] < minHeap.top[0] + minHeap.top[1])\n\t\t\t{\n\t\t\t\tminHeap.pop;\n\t\t\t\tminHeap.push([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](minHeap.length);\n\t\n\tforeach (i; 0 .. minHeap.length)\n\t{\n\t\tresult[i] = minHeap.pop;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp3mszwwdd.d(17): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3mszwwdd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j, n;\n\t\n\tn = nums1.length;\n\tpairs = new long[][](n);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tpairs[i] = new long[nums2.length];\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tpairs = pairs.sort();\n\t\n\tresult = new long[][](k);\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tpair = new long[2];\n\t\tpair[0] = nums1[i];\n\t\tpair[1] = nums2[i];\n\t\tresult[i] = pair;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpc54f9e8c.d(26): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc54f9e8c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](), Tuple!(long, long)(nums1[0], nums2[0]));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put(Tuple!(long, long)(nums1[i], nums2[j]));\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto curr = pq.peek;\n\t\t\t\tif (nums1[i] + nums2[j] < curr[0] + curr[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(Tuple!(long, long)(nums1[i], nums2[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto curr = pq.get();\n\t\tresult[i] = [curr[0], curr[1]];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp0lfaihys.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[](), Tuple!(long, long)(nums1[0], nums2[0]))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0lfaihys.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tfor (int i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto t = pq.get;\n\t\t\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpn9jw4cv1.d(18): Error: found `,` when expecting `.` following long\n/tmp/tmpn9jw4cv1.d(18): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpn9jw4cv1.d(18): Error: found `,` when expecting `.` following long\n/tmp/tmpn9jw4cv1.d(18): Error: found `long` when expecting identifier following `long`.\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn9jw4cv1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length, nums2.length);\n\t\n\tforeach (i, nums1)\n\t{\n\t\tforeach (j, nums2)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tpairs = pairs.sort();\n\t\n\tresult = new long[][](k);\n\t\n\tforeach (i, result)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpcsfvyo_c.d(16): Error: no identifier for declarator `nums1`\n/tmp/tmpcsfvyo_c.d(16): Error: found `)` when expecting `;`\n/tmp/tmpcsfvyo_c.d(18): Error: no identifier for declarator `nums2`\n/tmp/tmpcsfvyo_c.d(18): Error: found `)` when expecting `;`\n/tmp/tmpcsfvyo_c.d(22): Error: found `}` when expecting `)`\n/tmp/tmpcsfvyo_c.d(28): Error: no identifier for declarator `result`\n/tmp/tmpcsfvyo_c.d(28): Error: found `)` when expecting `;`\n/tmp/tmpcsfvyo_c.d(33): Error: found `return` when expecting `)`\n/tmp/tmpcsfvyo_c.d(35): Error: found `unittest` when expecting `)`\n/tmp/tmpcsfvyo_c.d(43): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcsfvyo_c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto result = new long[][](k);\n\t\n\tauto minHeap = new MinHeap!(Pair!(long, long))(k);\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 0 .. m)\n\t\t{\n\t\t\tif(minHeap.size() < k)\n\t\t\t{\n\t\t\t\tminHeap.push(Pair!(long, long)(nums1[i] + nums2[j], i * m + j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < minHeap.top().first)\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop();\n\t\t\t\t\tminHeap.push(Pair!(long, long)(nums1[i] + nums2[j], i * m + j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto p = minHeap.top();\n\t\tminHeap.pop();\n\t\tresult[i] = [nums1[p.second / m], nums2[p.second % m]];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmppvuyru0s.d(14): Error: template instance `MinHeap!(Pair!(long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppvuyru0s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(long[])();\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t\theap.put([nums1[i / n2], nums2[i % n2]]);\n\t\n\tforeach (i; k .. n1 * n2)\n\t{\n\t\tauto pair = [nums1[i / n2], nums2[i % n2]];\n\t\tif (pair[0] + pair[1] < heap.peek()[0] + heap.peek()[1])\n\t\t{\n\t\t\theap.pop();\n\t\t\theap.put(pair);\n\t\t}\n\t}\n\t\n\treturn heap.toArray();\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpkpm5etvu.d(16): Error: template instance `MinHeap!(long[])` template `MinHeap` is not defined\n/tmp/tmpkpm5etvu.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkpm5etvu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tif (pq.empty) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp0v54qg8k.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0v54qg8k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpcc27286m.d(11): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcc27286m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto result = new long[][](0);\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult ~= heap.pop();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpqmhe1olf.d(11): Error: template instance `Heap!(long[], \"a[0] + a[1]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqmhe1olf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\t\n\tauto result = new long[][](n);\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpq309f8gm.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq309f8gm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = PriorityQueue!(long[2], \"a[0] + a[1]\")(k);\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([n1, n2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(n1 + n2 < pq.peek[0] + pq.peek[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([n1, n2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pq.data;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp9hhfa6oo.d(10): Error: template instance `PriorityQueue!(long[2], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9hhfa6oo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i][0] = n1;\n\t\t\tpairs[i][1] = n2;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\ti = 0;\n\tforeach(p; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\t\n\t\tresult[i] = p;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpkqbhepqq.d(27): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkqbhepqq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i, e1; nums1)\n\t{\n\t\tforeach (j, e2; nums2)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t\tminHeap.push(tuple(e1, e2, i, j));\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = minHeap.top;\n\t\t\t\tif (top[0] + top[1] > e1 + e2)\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop;\n\t\t\t\t\tminHeap.push(tuple(e1, e2, i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](minHeap.length);\n\t\n\tforeach (i, e; minHeap)\n\t{\n\t\tresult[i] = [e[0], e[1]];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpx6tpe9xx.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx6tpe9xx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tres = new long[][](k);\n\t\n\ti = 0;\n\tforeach(pair; pairs)\n\t{\n\t\tres[i] = pair;\n\t\ti++;\n\t\tif(i == k)\n\t\t\tbreak;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpvuogylm8.d(14): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpvuogylm8.d(26): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvuogylm8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto arr = new long[][](nums1.length, nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tarr[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tauto sorted = arr.sort!((a, b) => a[0] < b[0]);\n\t\n\treturn sorted[0 .. min(k, sorted.length)];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpd8xhnz06.d(19): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd8xhnz06.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto comp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\t\n\tauto pq = new PriorityQueue!(typeof(comp))(comp);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.peek;\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i] = pq.get;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpgg7llkxb.d(14): Error: variable `tmpgg7llkxb.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b) => a[0] + a[1] > b[0] + b[1]`, and variables cannot be of type `void`\n/tmp/tmpgg7llkxb.d(14): Error: template lambda has no value\n/tmp/tmpgg7llkxb.d(16): Error: template instance `PriorityQueue!(typeof(comp))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgg7llkxb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor(long i = 0; i < len; i++)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp4t_han4w.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4t_han4w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = PriorityQueue!(long[], \"a[0] + a[1]\")(nums1.length);\n\tforeach(i, e; nums1)\n\t{\n\t\tforeach(j, f; nums2)\n\t\t{\n\t\t\tpq.put([e, f]);\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp0mk94ca1.d(10): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0mk94ca1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) \n\t\treturn [];\n\t\n\tauto heap = new Heap!(tuple!(long, long, long, long));\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (auto i = 0; i < k && !heap.empty; i++) \n\t{\n\t\tauto t = heap.popFront;\n\t\t\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == 0 && t[3] + 1 < n2) \n\t\t\theap.insert(tuple(nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1, t[3] + 1));\n\t\t\n\t\tif (t[2] + 1 < n1) \n\t\t\theap.insert(tuple(nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpaf6tnmt_.d(16): Error: template instance `Heap!(tuple!(long, long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaf6tnmt_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto index = new long[n1];\n\tauto count = 0;\n\t\n\twhile(count < k && count < n1 * n2)\n\t{\n\t\tauto min_val = long.max;\n\t\tauto min_index = -1;\n\t\t\n\t\tfor(auto i = 0; i < n1; i++)\n\t\t{\n\t\t\tif(index[i] < n2 && nums1[i] + nums2[index[i]] < min_val)\n\t\t\t{\n\t\t\t\tmin_val = nums1[i] + nums2[index[i]];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[count] = [nums1[min_index], nums2[index[min_index]]];\n\t\tindex[min_index]++;\n\t\tcount++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tlong[][] result;\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1])();\n\tforeach(i; 0 .. len)\n\t{\n\t\tpq.put([nums1[i], nums2[i]]);\n\t}\n\twhile(k-- > 0 && !pq.empty())\n\t{\n\t\tresult ~= pq.get();\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmprj35gn2a.d(12): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmprj35gn2a.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprj35gn2a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](n1 * n2);\n\tauto index = 0;\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tresult[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tauto compare = (a, b) => a[0] + a[1] < b[0] + b[1];\n\tresult.sort(compare);\n\treturn result[0 .. min(k, result.length)];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp2icwtc92.d(23): Error: variable `tmp2icwtc92.k_smallest_pairs.compare` type `void` is inferred from initializer `(a, b) => a[0] + a[1] < b[0] + b[1]`, and variables cannot be of type `void`\n/tmp/tmp2icwtc92.d(23): Error: template lambda has no value\n/tmp/tmp2icwtc92.d(24): Error: no property `sort` for type `long[][]`\n/tmp/tmp2icwtc92.d(25): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2icwtc92.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](n1 * n2);\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. n1)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tauto cur = pq.get();\n\t\tresult[i] = cur[0 .. 2];\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpj7_wu4q1.d(17): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpj7_wu4q1.d(22): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj7_wu4q1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] temp;\n\tlong i, j, m, n, count;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tpairs = new long[][](m * n);\n\t\n\tcount = 0;\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tpairs[count][0] = nums1[i];\n\t\t\tpairs[count][1] = nums2[j];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\ttemp = new long[2];\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tfor (j = i + 1; j < count; j++)\n\t\t{\n\t\t\tif (pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1])\n\t\t\t{\n\t\t\t\ttemp[0] = pairs[i][0];\n\t\t\t\ttemp[1] = pairs[i][1];\n\t\t\t\t\n\t\t\t\tpairs[i][0] = pairs[j][0];\n\t\t\t\tpairs[i][1] = pairs[j][1];\n\t\t\t\t\n\t\t\t\tpairs[j][0] = temp[0];\n\t\t\t\tpairs[j][1] = temp[1];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](k);\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = pairs[i][0];\n\t\tresult[i][1] = pairs[i][1];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp1juhohyl.d(25): Range violation\n----------------\n??:? _d_arrayboundsp [0x429bea]\n??:? long[][] tmp1juhohyl.k_smallest_pairs(long[], long[], long) [0x428034]\n??:? void tmp1juhohyl.__unittest_L59_C1() [0x4287b1]\n??:? void tmp1juhohyl.__modtest() [0x428d24]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e6eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x429816]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b391]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b420]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b31d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4297ed]\n??:? runModuleUnitTests [0x42e4c1]\n??:? void rt.dmain2._d_run_main(int, char**, ext",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j, n1, n2;\n\tlong min, min_i, min_j;\n\tlong count;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = nums1[i];\n\t\t\tpair[1] = nums2[j];\n\t\t\tpairs[i * n2 + j] = pair;\n\t\t}\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tfor (count = 0; count < k; count++)\n\t{\n\t\tmin = pairs[0][0] + pairs[0][1];\n\t\tmin_i = 0;\n\t\tmin_j = 0;\n\t\t\n\t\tfor (i = 0; i < n1; i++)\n\t\t{\n\t\t\tfor (j = 0; j < n2; j++)\n\t\t\t{\n\t\t\t\tif (pairs[i * n2 + j][0] + pairs[i * n2 + j][1] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = pairs[i * n2 + j][0] + pairs[i * n2 + j][1];\n\t\t\t\t\tmin_i = i;\n\t\t\t\t\tmin_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[count] = pairs[min_i * n2 + min_j];\n\t\tpairs[min_i * n2 + min_j][0] = max(nums1) + 1;\n\t\tpairs[min_i * n2 + min_j][1] = max(nums2) + 1;\n\t}\n\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpcz_0fa0f.d(59): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcz_0fa0f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] temp = new long[][](nums1.length * nums2.length);\n\tlong count = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp[count] = [nums1[i], nums2[j]];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\ttemp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpx9l7hl5d.d(22): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx9l7hl5d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto result = new long[][](k);\n\tauto size = nums1.length * nums2.length;\n\tif(k > size)\n\t\tk = size;\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")(size);\n\tforeach(i, e1; nums1)\n\t\tforeach(j, e2; nums2)\n\t\t\theap.insert([e1, e2]);\n\tforeach(i; 0 .. k)\n\t\tresult[i] = heap.pop();\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpq1qb3too.d(14): Error: template instance `Heap!(long[], \"a[0] + a[1]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq1qb3too.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tlong[] pair;\n\tlong i = 0, j = 0;\n\twhile (k-- > 0 && !pq.empty()) \n\t{\n\t\tpair = pq.get();\n\t\tresult[i++] = pair;\n\t\tif (pair[1] < nums2[nums2.length - 1])\n\t\t\tpq.put(new long[](pair[0], pair[1] + 1));\n\t\tif (pair[1] == nums2[0] && pair[0] < nums1[nums1.length - 1])\n\t\t\tpq.put(new long[](pair[0] + 1, pair[1]));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpwqomvc_5.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwqomvc_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[][](k);\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[0] > b[0]\");\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn res;\n\t\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i][0] = nums1[t[1]];\n\t\tres[i][1] = nums2[t[2]];\n\t\t\n\t\tif (t[1] == n1 - 1)\n\t\t{\n\t\t\tif (t[2] + 1 < n2)\n\t\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t\t}\n\t\telse if (t[2] == 0)\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t\t}\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp5dwfqh57.d(13): Error: template instance `PriorityQueue!(Tuple!(long, long, long), \"a[0] > b[0]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5dwfqh57.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong[][] heap = new long[][](k);\n\tlong heap_size = 0;\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[i * nums2.length + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\theap[i] = pairs[i];\n\t\theap_size += 1;\n\t}\n\t\n\tforeach(i; (k / 2) .. 0)\n\t{\n\t\theapify(heap, heap_size, i);\n\t}\n\t\n\tforeach(i; k .. pairs.length)\n\t{\n\t\tif(pairs[i][0] + pairs[i][1] < heap[0][0] + heap[0][1])\n\t\t{\n\t\t\theap[0] = pairs[i];\n\t\t\theapify(heap, heap_size, 0);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = heap[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpw6pvx2pf.d(31): Error: undefined identifier `heapify`\n/tmp/tmpw6pvx2pf.d(39): Error: undefined identifier `heapify`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw6pvx2pf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\t// if nums1 is empty, return empty array\n\tif (nums1.length == 0)\n\t\treturn new long[][]();\n\t\n\t// if nums2 is empty, return empty array\n\tif (nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\t// if k is 0, return empty array\n\tif (k == 0)\n\t\treturn new long[][]();\n\t\n\t// if k is greater than nums1 * nums2, return all pairs\n\tif (k > nums1.length * nums2.length)\n\t\tk = nums1.length * nums2.length;\n\t\n\t// create a tuple array to store the sum of the pairs\n\tTuple!(long, long, long)[] sums = new Tuple!(long, long, long)[nums1.length * nums2.length];\n\t\n\t// create a tuple array to store the pairs\n\tTuple!(long, long)[] pairs = new Tuple!(long, long)[nums1.length * nums2.length];\n\t\n\t// create a tuple array to store the k smallest pairs\n\tTuple!(long, long)[] k_smallest_pairs = new Tuple!(long, long)[k];\n\t\n\t// create a long array to store the k smallest sums\n\tlong[] k_smallest_sums = new long[k];\n\t\n\t// create a long array to store the k smallest sums indexes\n\tlong[] k_smallest_sums_indexes = new long[k];\n\t\n\t// create a long array to store the k smallest pairs indexes\n\tlong[] k_smallest_pairs_indexes = new long[k];\n\t\n\t// create a long array to store the k smallest pairs indexes\n\tlong[] k_smallest_pairs_indexes_sorted = new long[k];\n\t\n\t// create a long array to store the k smallest pairs indexes\n\tlong[] k_smallest_pairs_indexes_sorted_reverse = new long[k];\n\t\n\t// create a long array to store the k smallest pairs indexes\n\tlong[] k\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpfmtp44rx.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmpfmtp44rx.d(52): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfmtp44rx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto result = new long[][](k);\n\tauto heap = new Heap!(long[], \"a[0] + a[1]\")(k);\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(heap.length < k)\n\t\t\t{\n\t\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < heap.front[0] + heap.front[1])\n\t\t\t\t{\n\t\t\t\t\theap.popFront();\n\t\t\t\t\theap.insert([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = heap.popFront();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp5p90o091.d(11): Error: template instance `Heap!(long[], \"a[0] + a[1]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5p90o091.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0) \n\t\treturn result;\n\t\n\tforeach (i; 0 .. min(k, n1 * n2)) \n\t{\n\t\tpq.put([nums1[i / n2], nums2[i % n2]]);\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp8uutydrx.d(13): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmp8uutydrx.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8uutydrx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = [cur[0], cur[1]];\n\t\t\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpvry4f6xi.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpvry4f6xi.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvry4f6xi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\tlong min_index;\n\tlong min_value;\n\tlong min_value_index;\n\tlong[long] min_values;\n\tlong[long] min_values_index;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n, m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tresult = new long[][](k, 2);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin_values = new long[long](n);\n\t\tmin_values_index = new long[long](n);\n\t\t\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tmin_values[j] = pairs[j][0];\n\t\t\tmin_values_index[j] = 0;\n\t\t}\n\t\t\n\t\tmin_value = min(min_values);\n\t\tmin_value_index = min_values.indexOf(min_value);\n\t\t\n\t\tresult[i][0] = nums1[min_value_index];\n\t\tresult[i][1] = nums2[min_values_index[min_value_index]];\n\t\t\n\t\tmin_values_index[min_value_index]++;\n\t\t\n\t\tif (min_values_index[min_value_index] < m)\n\t\t{\n\t\t\tpairs[min_value_index][min_values_index[min_value_index]] = nums1[min_value_index] + nums2[min_values_index[min_value_index]];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[min_value\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmp58311ak7.d(36): Error: need size of rightmost array, not type `long`\n/tmp/tmp58311ak7.d(37): Error: need size of rightmost array, not type `long`\n/tmp/tmp58311ak7.d(60): Error: found `unittest` when expecting `,`\n/tmp/tmp58311ak7.d(68): Error: found `void` when expecting `,`\n/tmp/tmp58311ak7.d(68): Error: found `{` when expecting `,`\n/tmp/tmp58311ak7.d(68): Error: expression expected, not `}`\n/tmp/tmp58311ak7.d(68): Error: found `End of File` when expecting `,`\n/tmp/tmp58311ak7.d(68): Error: found `End of File` when expecting `]`\n/tmp/tmp58311ak7.d(68): Error: found `End of File` when expecting `;` following statement\n/tmp/tmp58311ak7.d(68): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp58311ak7.d(68): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp58311ak7.d(68): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp58311ak7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tlong[][] heap;\n\tlong heap_size;\n\tlong i;\n\tlong j;\n\tlong[][] tmp;\n\tlong[][] tmp2;\n\tlong[][] tmp3;\n\tlong[][] tmp4;\n\tlong[][] tmp5;\n\tlong[][] tmp6;\n\tlong[][] tmp7;\n\tlong[][] tmp8;\n\tlong[][] tmp9;\n\tlong[][] tmp10;\n\tlong[][] tmp11;\n\tlong[][] tmp12;\n\tlong[][] tmp13;\n\tlong[][] tmp14;\n\tlong[][] tmp15;\n\tlong[][] tmp16;\n\tlong[][] tmp17;\n\tlong[][] tmp18;\n\tlong[][] tmp19;\n\tlong[][] tmp20;\n\tlong[][] tmp21;\n\tlong[][] tmp22;\n\tlong[][] tmp23;\n\tlong[][] tmp24;\n\tlong[][] tmp25;\n\tlong[][] tmp26;\n\tlong[][] tmp27;\n\tlong[][] tmp28;\n\tlong[][] tmp29;\n\tlong[][] tmp30;\n\tlong[][] tmp31;\n\tlong[][] tmp32;\n\tlong[][] tmp33;\n\tlong[][] tmp34;\n\tlong[][] tmp35;\n\tlong[][] tmp36;\n\tlong[][] tmp37;\n\tlong[][] tmp38;\n\tlong[][] tmp39;\n\tlong[][] tmp40;\n\tlong[][] tmp41;\n\tlong[][] tmp42;\n\tlong[][] tmp43;\n\tlong[][] tmp44;\n\tlong[][] tmp45;\n\tlong[][] tmp46;\n\tlong[][] tmp47;\n\tlong[][] tmp48;\n\tlong[][] tmp49;\n\tlong[][] tmp50;\n\tlong[][] tmp51;\n\tlong[][] tmp52;\n\tlong[][] tmp53;\n\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "/tmp/tmpy56hjvgs.d(69): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy56hjvgs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}