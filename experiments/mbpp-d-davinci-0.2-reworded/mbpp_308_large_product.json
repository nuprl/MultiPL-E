{
  "name": "mbpp_308_large_product",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find the specified number of largest products from two given arrays, selecting one factor from each array.\n\t\n*/\nlong[] large_product(long[] nums1, long[] nums2, long N) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = large_product;\n\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 3L) == [60L, 54L, 50L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 4L) == [60L, 54L, 50L, 48L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 5L) == [60L, 54L, 50L, 48L, 45L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong[] result = new long[N];\n\t\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\t\n\twhile(k < N)\n\t{\n\t\tif(nums1[i] * nums2[j] > nums1[i] * nums2[j+1])\n\t\t{\n\t\t\tresult[k] = nums1[i] * nums2[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k] = nums1[i] * nums2[j+1];\n\t\t\ti++;\n\t\t}\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto a = new long[nums1.length * nums2.length];\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ta[i++] = n1 * n2;\n\t\t}\n\t}\n\ta.sort();\n\treturn a[$ - N .. $];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint index = 0;\n\tforeach(long num1; nums1)\n\t{\n\t\tforeach(long num2; nums2)\n\t\t{\n\t\t\ttemp[index++] = num1 * num2;\n\t\t}\n\t}\n\tsort(temp);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[temp.length - i - 1];\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\tauto result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort both arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) nums = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two indexes\n\tTuple!(long, long) indexes = tuple(nums1.length - 1, nums2.length - 1);\n\t\n\t// iterate over the result array\n\tforeach(i; 0 .. N)\n\t{\n\t\t// get the product of the two numbers at the indexes\n\t\tlong product = nums[0][indexes[0]] * nums[1][indexes[1]];\n\t\t\n\t\t// add the product to the result array\n\t\tresult[i] = product;\n\t\t\n\t\t// if the product is the same as the previous product\n\t\tif (i > 0 && product == result[i - 1])\n\t\t{\n\t\t\t// decrement the index of the second array\n\t\t\tindexes[1]--;\n\t\t}\n\t\t// otherwise\n\t\telse\n\t\t{\n\t\t\t// decrement the index of the first array\n\t\t\tindexes[0]--;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup;\n\tauto nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup;\n\tauto nums2_sorted_rev = nums2_sorted.dup;\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tauto nums1_sorted_rev_index = 0;\n\tauto nums2_sorted_rev_index = 0;\n\t\n\tauto result = new long[];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto num1 = nums1_sorted_rev[nums1_sorted_rev_index];\n\t\tauto num2 = nums2_sorted_rev[nums2_sorted_rev_index];\n\t\t\n\t\tif(num1 * nums2_sorted[0] > num2 * nums1_sorted[0])\n\t\t{\n\t\t\tresult ~= num1 * nums2_sorted[0];\n\t\t\tnums1_sorted_rev_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult ~= num2 * nums1_sorted[0];\n\t\t\tnums2_sorted_rev_index++;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[N];\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto max_heap = new Heap!(tuple!(long, long, long));\n\t\n\tfor (auto i = 0; i < n1; i++)\n\t{\n\t\tfor (auto j = 0; j < n2; j++)\n\t\t{\n\t\t\tauto product = nums1[i] * nums2[j];\n\t\t\tif (max_heap.length < N)\n\t\t\t{\n\t\t\t\tmax_heap.insert(tuple(product, i, j));\n\t\t\t}\n\t\t\telse if (product > max_heap.front[0])\n\t\t\t{\n\t\t\t\tmax_heap.popFront();\n\t\t\t\tmax_heap.insert(tuple(product, i, j));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (auto i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max_heap.popFront()[0];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\t\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1.sort!((a, b) => a > b);\n\tnums2.sort!((a, b) => a > b);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple =",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// get the largest N products\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1[nums1.length - 1 - i] * nums2[nums2.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort;\n\tnums2.sort;\n\t\n\t// create a priority queue of the products\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tpq.put(n1 * n2);\n\t\t}\n\t}\n\t\n\t// get the largest N products\n\tforeach(i, n; result)\n\t{\n\t\tresult[i] = pq.get;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(i, a; nums1)\n\t{\n\t\tforeach(j, b; nums2)\n\t\t{\n\t\t\tpq.put(a * b);\n\t\t}\n\t}\n\t\n\tforeach(i, r; result)\n\t{\n\t\tr = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort();\n\tnums2_sorted.sort();\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack();\n\t\tnums2_sorted.popBack();\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\tauto products = new long[];\n\tauto i = 0;\n\tauto j = 0;\n\twhile(products.length < N)\n\t{\n\t\tif(nums1_sorted[i] * nums2_sorted[j] > nums1_sorted[i] * nums2_sorted[j+1])\n\t\t{\n\t\t\tproducts ~= nums1_sorted[i] * nums2_sorted[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tproducts ~= nums1_sorted[i] * nums2_sorted[j+1];\n\t\t\ti++;\n\t\t}\n\t}\n\treturn products;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// add the products of the first elements of the arrays\n\tpq.put(nums1[0] * nums2[0]);\n\t\n\t// create a map to store the indices of the elements\n\tauto map = new Map!(long, tuple!(long, long));\n\tmap[nums1[0] * nums2[0]] = tuple(0, 0);\n\t\n\t// iterate over the elements of the queue\n\tforeach(i; 0 .. N)\n\t{\n\t\t// get the top element\n\t\tauto top = pq.get();\n\t\t\n\t\t// add it to the result\n\t\tresult[i] = top;\n\t\t\n\t\t// get the indices of the top element\n\t\tauto indices = map[top];\n\t\t\n\t\t// remove the top element from the map\n\t\tmap.remove(top);\n\t\t\n\t\t// add the next possible products to the queue\n\t\tif(indices[0] < nums1.length - 1)\n\t\t{\n\t\t\tauto next = nums1[indices[0] + 1] * nums2[indices[1]];\n\t\t\tpq.put(next);\n\t\t\tmap[next] = tuple(indices[0] + 1, indices[1]);\n\t\t}\n\t\tif(indices[1] < nums2.length - 1)\n\t\t{\n\t\t\tauto next = nums1[indices[0]] * nums2[indices[1] + 1];\n\t\t\tpq.put(next);\n\t\t\tmap[next] = tuple(indices[0], indices[1] + 1);\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] > b[0]\");\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i] * nums2[j], i, j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = t[0];\n\t\t\n\t\tif(t[1] < nums1.length - 1 && t[2] < nums2.length - 1)\n\t\t{\n\t\t\tpq.put([nums1[t[1] + 1] * nums2[t[2] + 1], t[1] + 1, t[2] + 1]);\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto a = nums1.sort!((a, b) => a > b);\n\tauto b = nums2.sort!((a, b) => a > b);\n\tauto c = new long[](N);\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tc[i] = a[i] * b[i];\n\t}\n\t\n\treturn c;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.sort!((a, b) => a > b);\n\tauto nums2_sorted = nums2.sort!((a, b) => a > b);\n\t\n\tauto nums1_sorted_set = nums1_sorted.toSet();\n\tauto nums2_sorted_set = nums2_sorted.toSet();\n\t\n\tauto nums1_sorted_set_sorted = nums1_sorted_set.sort!((a, b) => a > b);\n\tauto nums2_sorted_set_sorted = nums2_sorted_set.sort!((a, b) => a > b);\n\t\n\tauto nums1_sorted_set_sorted_arr = nums1_sorted_set_sorted.array;\n\tauto nums2_sorted_set_sorted_arr = nums2_sorted_set_sorted.array;\n\t\n\tauto nums1_sorted_set_sorted_arr_len = nums1_sorted_set_sorted_arr.length;\n\tauto nums2_sorted_set_sorted_arr_len = nums2_sorted_set_sorted_arr.length;\n\t\n\tauto nums1_sorted_set_sorted_arr_len_minus_1 = nums1_sorted_set_sorted_arr_len - 1;\n\tauto nums2_sorted_set_sorted_arr_len_minus_1 = nums2_sorted_set_sorted_arr_len - 1;\n\t\n\tauto nums1_sorted_set_sorted_arr_len_minus_1_index = nums1_sorted_set_sorted_arr_len_minus_1;\n\tauto nums2_sorted_set_sorted_arr_len_minus_1_index = nums2_sorted_set_sorted_arr_len_minus_1;\n\t\n\tauto nums1_sorted_set_sorted_arr_len_minus_1_index",
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn new long[0];\n\t\n\tlong[] res = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// add the first element of each array\n\tpq.put(nums1[n1-1] * nums2[n2-1]);\n\t\n\t// add the rest of the elements\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\t// get the largest product\n\t\tlong cur = pq.get();\n\t\t\n\t\t// add the next largest product\n\t\tpq.put(nums1[n1-1] * nums2[n2-2]);\n\t\tpq.put(nums1[n1-2] * nums2[n2-1]);\n\t\t\n\t\t// add the current product to the result\n\t\tres[i] = cur;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the product and the index of the two numbers\n\tTuple!(long, long, long)[] products = new Tuple!(long, long, long)[nums1.length * nums2.length];\n\t\n\t// populate the array\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tproducts[i] = tuple(n1 * n2, n1, n2);\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t// sort the array\n\tproducts.sort!((a, b) => a[0] > b[0]);\n\t\n\t// populate the result array\n\ti = 0;\n\tforeach(p; products)\n\t{\n\t\tif(i == N)\n\t\t\tbreak;\n\t\tresult[i] = p[0];\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the index and the value\n\tTuple!(long, long)[] nums1_t = new Tuple!(long, long)[nums1.length];\n\tTuple!(long, long)[] nums2_t = new Tuple!(long, long)[nums2.length];\n\t\n\tfor (int i = 0; i < nums1.length; i++)\n\t{\n\t\tnums1_t[i] = tuple(i, nums1[i]);\n\t}\n\t\n\tfor (int i = 0; i < nums2.length; i++)\n\t{\n\t\tnums2_t[i] = tuple(i, nums2[i]);\n\t}\n\t\n\t// sort the tuples\n\tnums1_t.sort!((a, b) => a[1] > b[1]);\n\tnums2_t.sort!((a, b) => a[1] > b[1]);\n\t\n\t// create a tuple of the index and the value\n\tTuple!(long, long)[] result_t = new Tuple!(long, long)[N];\n\t\n\t// create a tuple of the index and the value\n\tTuple!(long, long)[] result_t_sorted = new Tuple!(long, long)[N];\n\t\n\t// create a set of the indexes\n\tHashSet!(long) indexes = new HashSet!(long)();\n\t\n\t// create a set of the indexes\n\tHashSet!(long) indexes2 = new HashSet!(long)();\n\t\n\t// create a set of the indexes\n\tHashSet!(long) indexes3 = new HashSet!(long)();\n\t\n\t// create a set of the indexes\n\tHashSet!(long) indexes4 = new HashSet!(long)();\n\t\n\t// create a set of the indexes\n\tHashSet!(long) indexes5 = new HashSet!(long)();\n\t\n\t// create a set",
    "{\n\tlong[] result = new long[N];\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\twhile(i < nums1.length && j < nums2.length && k < N)\n\t{\n\t\tif(nums1[i] > nums2[j])\n\t\t{\n\t\t\tresult[k++] = nums1[i++];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k++] = nums2[j++];\n\t\t}\n\t}\n\twhile(i < nums1.length && k < N)\n\t{\n\t\tresult[k++] = nums1[i++];\n\t}\n\twhile(j < nums2.length && k < N)\n\t{\n\t\tresult[k++] = nums2[j++];\n\t}\n\treturn result;\n}",
    "{\n\tauto res = new long[N];\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tres[i] = pq.get;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// get the largest product of the two arrays\n\tlong largest = nums1[$-1] * nums2[$-1];\n\t\n\t// create a tuple of the largest product and the indices of the two numbers that were multiplied to get it\n\tTuple!(long, int, int)[] products = new Tuple!(long, int, int)[N];\n\tproducts[0] = tuple(largest, $-1, $-1);\n\t\n\t// create a tuple of the smallest product and the indices of the two numbers that were multiplied to get it\n\tTuple!(long, int, int) smallest = tuple(nums1[0] * nums2[0], 0, 0);\n\t\n\t// loop through the products array\n\tforeach(i; 1 .. N)\n\t{\n\t\t// if the smallest product is larger than the largest product in the array\n\t\tif(smallest[0] > products[i-1][0])\n\t\t{\n\t\t\t// set the largest product to the smallest product\n\t\t\tproducts[i] = smallest;\n\t\t\t\n\t\t\t// increment the index of the first number in the smallest product\n\t\t\tsmallest[1]++;\n\t\t\t\n\t\t\t// if the index of the first number is out of bounds\n\t\t\tif(smallest[1] >= nums1.length)\n\t\t\t{\n\t\t\t\t// increment the index of the second number in the smallest product\n\t\t\t\tsmallest[2]++;\n\t\t\t\t\n\t\t\t\t// if the index of the second number is out of bounds\n\t\t\t\tif(smallest[2] >= nums2.length)\n\t\t\t\t{\n\t\t\t\t\t// set the smallest product to the largest product\n\t\t\t\t\tsmallest = products[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// set the smallest product to the product of the first number and the second number\n\t\t\t\t\t",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto max_heap = new MaxHeap!(long)();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tmax_heap.insert(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = max_heap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_largest = nums1_sorted[$-N..$];\n\tauto nums2_largest = nums2_sorted[$-N..$];\n\t\n\tauto result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_largest[i] * nums2_largest[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tlong[] nums1_max = nums1_sorted[$-1..$];\n\tlong[] nums2_max = nums2_sorted[$-1..$];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_max[i] * nums2_max[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tpq.put(num1 * num2);\n\t\t\tif(pq.length > N)\n\t\t\t\tpq.get();\n\t\t}\n\t}\n\treturn pq.data;\n}",
    "{\n\tauto p = new long[][](nums1.length);\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tp[i] = new long[](nums2.length);\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tp[i][j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tauto q = new long[][](nums1.length);\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tq[i] = new long[](nums2.length);\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tq[i][j] = p[i][j];\n\t\t}\n\t}\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tq[i] = q[i].sort!((a, b) => a > b);\n\t}\n\t\n\tauto r = new long[][](nums1.length);\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tr[i] = new long[](nums2.length);\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tr[i][j] = q[i][j];\n\t\t}\n\t}\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tr[i] = r[i].sort!((a, b) => a < b);\n\t}\n\t\n\tauto s = new long[](nums1.length * nums2.length);\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\ts[i * nums2.length + j] = p[i][j];\n\t\t}\n\t}\n\t\n\ts = s.sort!((a, b) => a > b);\n\t\n\tauto t",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = nums1[0];\n\t\tmax2[i] = nums2[0];\n\t}\n\t\n\tforeach(n; nums1)\n\t{\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tif(n > max1[i])\n\t\t\t{\n\t\t\t\tmax1[i] = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(n; nums2)\n\t{\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tif(n > max2[i])\n\t\t\t{\n\t\t\t\tmax2[i] = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tpq.put(num1 * num2);\n\t\t}\n\t}\n\t\n\tforeach(i, num; result)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// Sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// Create a tuple of the index and value of the largest value in each array\n\tauto nums1_max = tuple(nums1.length - 1, nums1[nums1.length - 1]);\n\tauto nums2_max = tuple(nums2.length - 1, nums2[nums2.length - 1]);\n\t\n\t// Create a tuple of the index and value of the smallest value in each array\n\tauto nums1_min = tuple(0, nums1[0]);\n\tauto nums2_min = tuple(0, nums2[0]);\n\t\n\t// Create a tuple of the index and value of the second largest value in each array\n\tauto nums1_second_max = tuple(nums1.length - 2, nums1[nums1.length - 2]);\n\tauto nums2_second_max = tuple(nums2.length - 2, nums2[nums2.length - 2]);\n\t\n\t// Create a tuple of the index and value of the second smallest value in each array\n\tauto nums1_second_min = tuple(1, nums1[1]);\n\tauto nums2_second_min = tuple(1, nums2[1]);\n\t\n\t// Create a tuple of the index and value of the third largest value in each array\n\tauto nums1_third_max = tuple(nums1.length - 3, nums1[nums1.length - 3]);\n\tauto nums2_third_max = tuple(nums2.length - 3, nums2[nums2.length - 3]);\n\t\n\t// Create a tuple of the index and value of the third smallest value in each array\n\tauto nums1_third_min = tuple(2, nums1[2]);\n\tauto nums2_third_min = tuple(2, nums2[2]);\n\t\n\t// Create a tuple of the index and value of the fourth largest value in each array\n\tauto nums1_fourth_max = tuple(n",
    "{\n\tlong[] result = new long[N];\n\tlong[] product = new long[nums1.length * nums2.length];\n\tint k = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tproduct[k] = nums1[i] * nums2[j];\n\t\t\tk++;\n\t\t}\n\t}\n\tproduct.sort!((a, b) => a > b);\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = product[i];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the index and the value\n\tauto[] nums1_t = new Tuple!(long, long)[nums1.length];\n\tforeach(i, num; nums1)\n\t{\n\t\tnums1_t[i] = tuple(i, num);\n\t}\n\t\n\tauto[] nums2_t = new Tuple!(long, long)[nums2.length];\n\tforeach(i, num; nums2)\n\t{\n\t\tnums2_t[i] = tuple(i, num);\n\t}\n\t\n\t// sort the tuples by the value\n\tnums1_t.sort!((a, b) => a[1] > b[1]);\n\tnums2_t.sort!((a, b) => a[1] > b[1]);\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\")();\n\t\n\t// add the first element\n\tpq.put(nums1_t[0][1] * nums2_t[0][1]);\n\t\n\t// add the rest of the elements\n\tforeach(i, num1; nums1_t)\n\t{\n\t\tforeach(j, num2; nums2_t)\n\t\t{\n\t\t\tif(i == 0 && j == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// if the product is smaller than the smallest element in the queue, then we can stop\n\t\t\tif(num1[1] * num2[1] < pq.peek())\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t// if the product is larger than the smallest element in the queue, then we can add it\n\t\t\tif(num1[1] * num2[1] > pq.peek())\n\t\t\t{\n\t\t\t\tpq.put(num1[1] * num2[1]);\n\t",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort();\n\tnums2_sorted.sort();\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack();\n\t\tnums2_sorted.popBack();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tauto maxHeap = new MaxHeap!(long)();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tmaxHeap.push(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = maxHeap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] sorted1 = nums1.dup.sort;\n\tlong[] sorted2 = nums2.dup.sort;\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = sorted1[$-1] * sorted2[$-1];\n\t\tsorted1.popBack;\n\t\tsorted2.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// create a set to store the visited pairs\n\tauto visited = new Set!(tuple!(long, long));\n\t\n\t// create a tuple to store the current pair\n\tauto pair = tuple(nums1[$-1], nums2[$-1]);\n\t\n\t// add the current pair to the priority queue and the set\n\tpq.put(pair[0] * pair[1]);\n\tvisited.insert(pair);\n\t\n\t// loop N times\n\tforeach(i; 0 .. N)\n\t{\n\t\t// get the largest product from the priority queue\n\t\tresult[i] = pq.get();\n\t\t\n\t\t// get the factors of the largest product\n\t\tpair = tuple(result[i] / pair[1], pair[1]);\n\t\t\n\t\t// if the pair is not visited\n\t\tif(!visited.contains(pair))\n\t\t{\n\t\t\t// add the pair to the priority queue and the set\n\t\t\tpq.put(pair[0] * pair[1]);\n\t\t\tvisited.insert(pair);\n\t\t}\n\t\t\n\t\t// get the factors of the largest product\n\t\tpair = tuple(pair[0], result[i] / pair[0]);\n\t\t\n\t\t// if the pair is not visited\n\t\tif(!visited.contains(pair))\n\t\t{\n\t\t\t// add the pair to the priority queue and the set\n\t\t\tpq.put(pair[0] * pair[1]);\n\t\t\tvisited.insert(pair);\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto maxHeap = new MaxHeap!(long)();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tmaxHeap.insert(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = maxHeap.extractMax();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto maxHeap = new MaxHeap!(long)();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tmaxHeap.insert(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tlong[] result = new long[N];\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = maxHeap.pop();\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tnums1_sorted.sort;\n\t\n\tlong[] nums2_sorted = nums2.dup;\n\tnums2_sorted.sort;\n\t\n\tlong[] nums1_sorted_rev = nums1_sorted.dup;\n\tnums1_sorted_rev.reverse;\n\t\n\tlong[] nums2_sorted_rev = nums2_sorted.dup;\n\tnums2_sorted_rev.reverse;\n\t\n\tlong[] nums1_sorted_rev_index = new long[nums1_sorted_rev.length];\n\tlong[] nums2_sorted_rev_index = new long[nums2_sorted_rev.length];\n\t\n\tfor(long i = 0; i < nums1_sorted_rev.length; i++)\n\t{\n\t\tnums1_sorted_rev_index[i] = nums1_sorted.indexOf(nums1_sorted_rev[i]);\n\t}\n\t\n\tfor(long i = 0; i < nums2_sorted_rev.length; i++)\n\t{\n\t\tnums2_sorted_rev_index[i] = nums2_sorted.indexOf(nums2_sorted_rev[i]);\n\t}\n\t\n\tlong[] nums1_sorted_rev_index_sorted = nums1_sorted_rev_index.dup;\n\tnums1_sorted_rev_index_sorted.sort;\n\t\n\tlong[] nums2_sorted_rev_index_sorted = nums2_sorted_rev_index.dup;\n\tnums2_sorted_rev_index_sorted.sort;\n\t\n\tlong[] nums1_sorted_rev_index_sorted_rev = nums1_sorted_rev_index_sorted.dup;\n\tnums1_sorted_rev_index_sorted_rev.",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the index and the value\n\tTuple!(int, long)[] nums1_t = new Tuple!(int, long)[nums1.length];\n\tTuple!(int, long)[] nums2_t = new Tuple!(int, long)[nums2.length];\n\t\n\tforeach(i, v; nums1)\n\t\tnums1_t[i] = tuple(i, v);\n\t\n\tforeach(i, v; nums2)\n\t\tnums2_t[i] = tuple(i, v);\n\t\n\t// sort the tuples by value\n\tnums1_t.sort!((a, b) => a[1] > b[1]);\n\tnums2_t.sort!((a, b) => a[1] > b[1]);\n\t\n\t// create a tuple of the index and the value\n\tTuple!(int, int, long)[] nums1_t2 = new Tuple!(int, int, long)[nums1.length];\n\tTuple!(int, int, long)[] nums2_t2 = new Tuple!(int, int, long)[nums2.length];\n\t\n\tforeach(i, v; nums1_t)\n\t\tnums1_t2[i] = tuple(i, v[0], v[1]);\n\t\n\tforeach(i, v; nums2_t)\n\t\tnums2_t2[i] = tuple(i, v[0], v[1]);\n\t\n\t// sort the tuples by index\n\tnums1_t2.sort!((a, b) => a[1] > b[1]);\n\tnums2_t2.sort!((a, b) => a[1] > b[1]);\n\t\n\t// create a tuple of the index and the value\n\tTuple!(int, int, long)[] nums1_t3 = new",
    "{\n\tlong[] result = new long[N];\n\tlong[] max_nums1 = new long[N];\n\tlong[] max_nums2 = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1.sort!((a, b) => a > b);\n\tnums2.sort!((a, b) => a > b);\n\t\n\t// get the largest N numbers from nums1 and nums2\n\tmax_nums1 = nums1[0..N];\n\tmax_nums2 = nums2[0..N];\n\t\n\t// multiply the largest N numbers from nums1 and nums2\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = max_nums1[i] * max_nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttemp[i] = n1 * n2;\n\t\t\ti++;\n\t\t}\n\t}\n\ttemp.sort();\n\tforeach(t; temp)\n\t{\n\t\tif(k < N)\n\t\t{\n\t\t\tresult[k] = t;\n\t\t\tk++;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort both arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// add all products to the queue\n\tforeach (i; 0..nums1.length)\n\t{\n\t\tforeach (j; 0..nums2.length)\n\t\t{\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\t// get the largest N products\n\tforeach (i; 0..N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tsort(nums1_sorted);\n\tsort(nums2_sorted);\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_len = nums1.length;\n\tauto nums2_len = nums2.length;\n\t\n\tauto result = new long[N];\n\t\n\tauto i = nums1_len - 1;\n\tauto j = nums2_len - 1;\n\t\n\tfor (auto k = 0; k < N; k++)\n\t{\n\t\tif (nums1_sorted[i] * nums2_sorted[j] > nums1_sorted[i - 1] * nums2_sorted[j - 1])\n\t\t{\n\t\t\tresult[k] = nums1_sorted[i] * nums2_sorted[j];\n\t\t\ti--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k] = nums1_sorted[i - 1] * nums2_sorted[j - 1];\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tauto pq = PriorityQueue!(long[], \"a[0] > b[0]\")();\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tif(pq.length < N)\n\t\t\t{\n\t\t\t\tpq.put([n1*n2, i, j]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif(top[0] < n1*n2)\n\t\t\t\t{\n\t\t\t\t\tpq.put([n1*n2, i, j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pq.map!(a => a[0]).array;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// Sort the arrays in descending order\n\tnums1.sort!((a, b) => b.compare(a));\n\tnums2.sort!((a, b) => b.compare(a));\n\t\n\t// Create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a.compare(b));\n\t\n\t// Add the first N products to the priority queue\n\tforeach(i; 0 .. N)\n\t{\n\t\tpq.put(nums1[i] * nums2[i]);\n\t}\n\t\n\t// Iterate through the rest of the products\n\tforeach(i; N .. nums1.length)\n\t{\n\t\tforeach(j; N .. nums2.length)\n\t\t{\n\t\t\t// If the current product is larger than the smallest product in the priority queue, replace it\n\t\t\tif(nums1[i] * nums2[j] > pq.peek())\n\t\t\t{\n\t\t\t\tpq.get();\n\t\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Pop the products off the priority queue and add them to the result array\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto m = nums1.length;\n\tauto n = nums2.length;\n\tauto res = new long[N];\n\tauto pq = new PriorityQueue!(long[], \"a[0] > b[0] || (a[0] == b[0] && a[1] < b[1])\")();\n\t\n\tforeach(i; 0 .. m)\n\t{\n\t\tforeach(j; 0 .. n)\n\t\t{\n\t\t\tpq.put([nums1[i] * nums2[j], i, j]);\n\t\t\tif(pq.size() > N)\n\t\t\t\tpq.get();\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = t[0];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort both arrays in descending order\n\tnums1.sort!((a, b) => a > b);\n\tnums2.sort!((a, b) => a > b);\n\t\n\t// create a priority queue of tuples (product, (index1, index2))\n\tauto pq = new PriorityQueue!(Tuple!(long, Tuple!(long, long)))();\n\t\n\t// add the first element of each array to the priority queue\n\tpq.put(tuple(nums1[0] * nums2[0], tuple(0, 0)));\n\t\n\t// while the priority queue is not empty\n\twhile(!pq.empty)\n\t{\n\t\t// get the largest product from the priority queue\n\t\tauto t = pq.get;\n\t\t\n\t\t// add the product to the result array\n\t\tresult[N - 1] = t[0];\n\t\t\n\t\t// decrement N\n\t\tN--;\n\t\t\n\t\t// if N is zero, then we are done\n\t\tif(N == 0)\n\t\t\tbreak;\n\t\t\n\t\t// get the indices of the two numbers that were multiplied\n\t\tauto i1 = t[1][0];\n\t\tauto i2 = t[1][1];\n\t\t\n\t\t// if the first index is not the last index of the first array\n\t\tif(i1 < nums1.length - 1)\n\t\t{\n\t\t\t// add the product of the next number in the first array and the current number in the second array to the priority queue\n\t\t\tpq.put(tuple(nums1[i1 + 1] * nums2[i2], tuple(i1 + 1, i2)));\n\t\t}\n\t\t\n\t\t// if the second index is not the last index of the second array\n\t\tif(i2 < nums2.length - 1)\n\t\t{\n\t\t\t// add the product of the current number in the first array and the next number in the second array to the priority queue\n\t\t\tpq.put(tuple",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\twhile (N > 0)\n\t{\n\t\tauto max_product = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\t\n\t\tif (nums1_sorted[$-1] * nums2_sorted[$-2] == max_product)\n\t\t{\n\t\t\tresult ~= max_product;\n\t\t\tnums2_sorted.popBack;\n\t\t}\n\t\telse if (nums1_sorted[$-2] * nums2_sorted[$-1] == max_product)\n\t\t{\n\t\t\tresult ~= max_product;\n\t\t\tnums1_sorted.popBack;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult ~= max_product;\n\t\t\tnums1_sorted.popBack;\n\t\t\tnums2_sorted.popBack;\n\t\t}\n\t\t\n\t\tN--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tresult.length = N;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tauto num1 = nums1_sorted[$ - i];\n\t\tauto num2 = nums2_sorted[$ - i];\n\t\t\n\t\tresult ~= num1 * num2;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup;\n\tauto nums2_sorted_rev = nums2_sorted.dup;\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted_rev[i] * nums2_sorted_rev[i];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tnums1_sorted.sort;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto max_heap = MaxHeap!(long)();\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tmax_heap.insert(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tlong[] result;\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= max_heap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\tlong[] min1 = new long[N];\n\tlong[] min2 = new long[N];\n\t\n\tforeach(i, n; nums1)\n\t{\n\t\tif(n > max1[0])\n\t\t{\n\t\t\tmax1[0] = n;\n\t\t\tmax1 = max1.sort();\n\t\t}\n\t\tif(n < min1[0])\n\t\t{\n\t\t\tmin1[0] = n;\n\t\t\tmin1 = min1.sort();\n\t\t}\n\t}\n\t\n\tforeach(i, n; nums2)\n\t{\n\t\tif(n > max2[0])\n\t\t{\n\t\t\tmax2[0] = n;\n\t\t\tmax2 = max2.sort();\n\t\t}\n\t\tif(n < min2[0])\n\t\t{\n\t\t\tmin2[0] = n;\n\t\t\tmin2 = min2.sort();\n\t\t}\n\t}\n\t\n\tforeach(i, n; result)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\tforeach(i, n; result)\n\t{\n\t\tif(n < min1[i] * min2[i])\n\t\t{\n\t\t\tresult[i] = min1[i] * min2[i];\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tauto max_heap = new MaxHeap!(long)();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tauto product = nums1[i] * nums2[j];\n\t\t\tif(max_heap.length < N)\n\t\t\t{\n\t\t\t\tmax_heap.insert(product);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(product > max_heap.top)\n\t\t\t\t{\n\t\t\t\t\tmax_heap.pop;\n\t\t\t\t\tmax_heap.insert(product);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = max_heap.pop;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpq.put(n1 * n2);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// Sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// Create a tuple of the index and the value\n\tauto[] nums1_t = new Tuple!(int, long)[nums1.length];\n\tauto[] nums2_t = new Tuple!(int, long)[nums2.length];\n\t\n\tforeach(i, v; nums1)\n\t{\n\t\tnums1_t[i] = tuple(i, v);\n\t}\n\t\n\tforeach(i, v; nums2)\n\t{\n\t\tnums2_t[i] = tuple(i, v);\n\t}\n\t\n\t// Sort the tuples by the value\n\tnums1_t.sort!((a, b) => a[1] > b[1]);\n\tnums2_t.sort!((a, b) => a[1] > b[1]);\n\t\n\t// Create a tuple of the index and the value\n\tauto[] nums1_t_s = new Tuple!(int, long)[nums1.length];\n\tauto[] nums2_t_s = new Tuple!(int, long)[nums2.length];\n\t\n\tforeach(i, v; nums1)\n\t{\n\t\tnums1_t_s[i] = tuple(i, v);\n\t}\n\t\n\tforeach(i, v; nums2)\n\t{\n\t\tnums2_t_s[i] = tuple(i, v);\n\t}\n\t\n\t// Sort the tuples by the index\n\tnums1_t_s.sort!((a, b) => a[0] > b[0]);\n\tnums2_t_s.sort!((a, b) => a[0] > b[0]);\n\t\n\t// Create a set of the indices\n\tauto nums1_s = new Set!int();\n\tauto nums2_s = new Set!int();\n\t\n\tforeach(i, v; nums1_t",
    "{\n\tlong[] result = new long[N];\n\t\n\t//sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t//create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t//create a priority queue to store the products\n\tauto pq = new PriorityQueue!(a => a[0])();\n\t\n\t//add the first N products to the queue\n\tforeach(i; 0 .. N)\n\t{\n\t\tpq.put(tuple(nums1[i] * nums2[i], i, i));\n\t}\n\t\n\t//add the rest of the products to the queue\n\tforeach(i; N .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i] * nums2[j], i, j));\n\t\t}\n\t}\n\t\n\t//pop the products from the queue and add them to the result array\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get()[0];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] maxes = new long[N];\n\tlong[] mins = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tmaxes[i] = max(nums1[i], nums2[i]);\n\t\tmins[i] = min(nums1[i], nums2[i]);\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = maxes[i] * mins[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = nums1[0];\n\t\tmax2[i] = nums2[0];\n\t}\n\t\n\tforeach(n; nums1)\n\t{\n\t\tforeach(m; nums2)\n\t\t{\n\t\t\tlong product = n * m;\n\t\t\tif(product > max1[0] * max2[0])\n\t\t\t{\n\t\t\t\tmax1[0] = n;\n\t\t\t\tmax2[0] = m;\n\t\t\t\tsort!(\"a > b\")(max1);\n\t\t\t\tsort!(\"a > b\")(max2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] result_index = new long[N];\n\tlong[] nums1_index = new long[nums1.length];\n\tlong[] nums2_index = new long[nums2.length];\n\t\n\tfor (int i = 0; i < nums1.length; i++)\n\t{\n\t\tnums1_index[i] = i;\n\t}\n\t\n\tfor (int i = 0; i < nums2.length; i++)\n\t{\n\t\tnums2_index[i] = i;\n\t}\n\t\n\tnums1 = nums1.sort(std.numeric.comparison);\n\tnums2 = nums2.sort(std.numeric.comparison);\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1[nums1.length - 1] * nums2[nums2.length - 1];\n\t\tresult_index[i] = nums1_index[nums1.length - 1] * nums2_index[nums2.length - 1];\n\t\t\n\t\tif (nums1.length > 1)\n\t\t{\n\t\t\tnums1 = nums1[0..$-1];\n\t\t\tnums1_index = nums1_index[0..$-1];\n\t\t}\n\t\t\n\t\tif (nums2.length > 1)\n\t\t{\n\t\t\tnums2 = nums2[0..$-1];\n\t\t\tnums2_index = nums2_index[0..$-1];\n\t\t}\n\t}\n\t\n\treturn result_index;\n}",
    "{\n\tlong[] result = new long[N];\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\t\n\twhile(k < N)\n\t{\n\t\tif(nums1[i] * nums2[j] > nums1[i] * nums2[j+1])\n\t\t{\n\t\t\tresult[k] = nums1[i] * nums2[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k] = nums1[i] * nums2[j+1];\n\t\t\ti++;\n\t\t}\n\t\tk++;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tauto result = new long[N];\n\tauto nums1_sorted = nums1.sort();\n\tauto nums2_sorted = nums2.sort();\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1.length - 1 - i] * nums2_sorted[nums2.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 in descending order\n\tnums1.sort!((a, b) => a > b);\n\t\n\t// sort nums2 in ascending order\n\tnums2.sort!((a, b) => a < b);\n\t\n\t// create a tuple array of (nums1[i], nums2[i])\n\tauto tuples = new Tuple!(long, long)[nums1.length];\n\tforeach(i, num; nums1)\n\t{\n\t\ttuples[i] = tuple(num, nums2[i]);\n\t}\n\t\n\t// sort tuples by the product of the tuple elements\n\ttuples.sort!((a, b) => a[0] * a[1] > b[0] * b[1]);\n\t\n\t// get the first N elements of the sorted tuples\n\tforeach(i, tuple; tuples[0 .. N])\n\t{\n\t\tresult[i] = tuple[0] * tuple[1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1.sort!((a, b) => b < a);\n\tnums2.sort!((a, b) => b < a);\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// add the first element of each array to the priority queue\n\tpq.put(nums1[0] * nums2[0]);\n\t\n\t// create a set to store the indices of the elements in nums1 and nums2\n\tauto set = new Set!(Tuple!(ulong, ulong));\n\tset.insert(Tuple!(ulong, ulong)(0, 0));\n\t\n\t// create a tuple to store the indices of the elements in nums1 and nums2\n\tauto t = Tuple!(ulong, ulong)(0, 0);\n\t\n\t// loop N times\n\tfor (ulong i = 0; i < N; i++)\n\t{\n\t\t// get the largest product from the priority queue\n\t\tresult[i] = pq.get;\n\t\t\n\t\t// get the indices of the elements in nums1 and nums2\n\t\tt = set.popFront;\n\t\t\n\t\t// if the index of the element in nums1 is less than the length of nums1 - 1\n\t\tif (t[0] < nums1.length - 1)\n\t\t{\n\t\t\t// add the product of the next element in nums1 and the current element in nums2 to the priority queue\n\t\t\tpq.put(nums1[t[0] + 1] * nums2[t[1]]);\n\t\t\t\n\t\t\t// add the indices of the next element in nums1 and the current element in nums2 to the set\n\t\t\tset.insert(Tuple!(ulong, ulong)(t[0] + 1, t[1]));\n\t\t}\n\t\t\n\t\t// if the index of the element in nums2 is less than the length of num",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[N];\n\tlong[] temp2 = new long[N];\n\tlong[] temp3 = new long[N];\n\tlong[] temp4 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\ttemp[i] = nums1[i] * nums2[i];\n\t\ttemp2[i] = nums1[i] * nums2[nums2.length - 1 - i];\n\t\ttemp3[i] = nums1[nums1.length - 1 - i] * nums2[i];\n\t\ttemp4[i] = nums1[nums1.length - 1 - i] * nums2[nums2.length - 1 - i];\n\t}\n\t\n\ttemp.sort();\n\ttemp2.sort();\n\ttemp3.sort();\n\ttemp4.sort();\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[temp.length - 1 - i];\n\t\tresult[i + N] = temp2[temp2.length - 1 - i];\n\t\tresult[i + N + N] = temp3[temp3.length - 1 - i];\n\t\tresult[i + N + N + N] = temp4[temp4.length - 1 - i];\n\t}\n\t\n\tresult.sort();\n\t\n\treturn result[result.length - N .. result.length];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t//sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t//create a priority queue\n\tauto pq = new PriorityQueue!(a => a[0], Tuple!(long, long, long)[], Tuple!(long, long, long)[](nums1.length + nums2.length));\n\t\n\t//add the first element from each array to the queue\n\tpq.put(tuple(nums1[$-1] * nums2[$-1], nums1.length - 1, nums2.length - 1));\n\t\n\t//pop the queue N times\n\tforeach(i; 0 .. N)\n\t{\n\t\t//get the top element\n\t\tauto top = pq.get();\n\t\t\n\t\t//add it to the result\n\t\tresult[i] = top[0];\n\t\t\n\t\t//add the next elements from the arrays to the queue\n\t\tif(top[1] > 0)\n\t\t\tpq.put(tuple(nums1[top[1] - 1] * nums2[top[2]], top[1] - 1, top[2]));\n\t\tif(top[2] > 0)\n\t\t\tpq.put(tuple(nums1[top[1]] * nums2[top[2] - 1], top[1], top[2] - 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tauto max_heap = new MaxHeap!(long)();\n\t\n\tforeach(i, nums1)\n\t{\n\t\tforeach(j, nums2)\n\t\t{\n\t\t\tif(max_heap.length < N)\n\t\t\t{\n\t\t\t\tmax_heap.insert(nums1[i] * nums2[j]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] * nums2[j] > max_heap.peek)\n\t\t\t\t{\n\t\t\t\t\tmax_heap.pop;\n\t\t\t\t\tmax_heap.insert(nums1[i] * nums2[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, result)\n\t{\n\t\tresult[i] = max_heap.pop;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = nums1[0];\n\t\tmax2[i] = nums2[0];\n\t}\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums1[i] > max1[j])\n\t\t\t{\n\t\t\t\tmax1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < nums2.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums2[i] > max2[j])\n\t\t\t{\n\t\t\t\tmax2[j] = nums2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.sort();\n\tauto nums2_sorted = nums2.sort();\n\t\n\tauto nums1_len = nums1.length;\n\tauto nums2_len = nums2.length;\n\t\n\tauto nums1_index = nums1_len - 1;\n\tauto nums2_index = nums2_len - 1;\n\t\n\tauto result = new long[N];\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tif (nums1_sorted[nums1_index] * nums2_sorted[nums2_index] > nums1_sorted[0] * nums2_sorted[0])\n\t\t{\n\t\t\tresult[i] = nums1_sorted[nums1_index] * nums2_sorted[nums2_index];\n\t\t\tnums2_index--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[i] = nums1_sorted[0] * nums2_sorted[0];\n\t\t\tnums1_index--;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] sorted1 = nums1.dup;\n\tlong[] sorted2 = nums2.dup;\n\tsorted1.sort;\n\tsorted2.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = sorted1[$-1] * sorted2[$-1];\n\t\tsorted1.popBack;\n\t\tsorted2.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted_rev[i] * nums2_sorted_rev[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= max(nums1) * max(nums2);\n\t\tnums1 = nums1.filter!(a => a != max(nums1));\n\t\tnums2 = nums2.filter!(a => a != max(nums2));\n\t}\n\treturn result;\n}",
    "{\n\tauto result = new long[N];\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto maxHeap = new MaxHeap!(long)();\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tmaxHeap.insert(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = maxHeap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\")();\n\t\n\tforeach(n1; nums1)\n\t\tforeach(n2; nums2)\n\t\t\tpq.put(n1 * n2);\n\t\t\t\n\tforeach(i; 0 .. N)\n\t\tresult[i] = pq.get();\n\t\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\t\n\twhile(i < nums1.length && j < nums2.length && k < N)\n\t{\n\t\tif(nums1[i] > nums2[j])\n\t\t{\n\t\t\tresult[k] = nums1[i] * nums2[j];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k] = nums1[i] * nums2[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\twhile(i < nums1.length && k < N)\n\t{\n\t\tresult[k] = nums1[i] * nums2[j-1];\n\t\ti++;\n\t\tk++;\n\t}\n\t\n\twhile(j < nums2.length && k < N)\n\t{\n\t\tresult[k] = nums1[i-1] * nums2[j];\n\t\tj++;\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_index = nums1_sorted_rev.map!(a => nums1.indexOf(a));\n\tauto nums2_sorted_rev_index = nums2_sorted_rev.map!(a => nums2.indexOf(a));\n\t\n\tauto nums1_sorted_rev_index_sorted = nums1_sorted_rev_index.dup.sort;\n\tauto nums2_sorted_rev_index_sorted = nums2_sorted_rev_index.dup.sort;\n\t\n\tauto nums1_sorted_rev_index_sorted_rev = nums1_sorted_rev_index_sorted.dup.reverse;\n\tauto nums2_sorted_rev_index_sorted_rev = nums2_sorted_rev_index_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_index_sorted_rev_index = nums1_sorted_rev_index_sorted_rev.map!(a => nums1_sorted_rev_index.indexOf(a));\n\tauto nums2_sorted_rev_index_sorted_rev_index = nums2_sorted_rev_index_sorted_rev.map!(a => nums2_sorted_rev_index.indexOf(a));\n\t\n\tauto nums1_sorted_rev_index_sorted_rev_index_sorted = nums1_sorted_rev_index_sorted_rev_index.dup.sort;\n\tauto nums2_sorted_rev_index_sorted_rev_index_sorted = nums2_sorted_rev_",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$ - 1] * nums2_sorted[$ - 1];\n\t\t\n\t\tif(nums1_sorted[$ - 1] > nums2_sorted[$ - 1])\n\t\t{\n\t\t\tnums1_sorted.popBack;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnums2_sorted.popBack;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = nums1[0];\n\t\tmax2[i] = nums2[0];\n\t}\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums1[i] > max1[j])\n\t\t\t{\n\t\t\t\tmax1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < nums2.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums2[i] > max2[j])\n\t\t\t{\n\t\t\t\tmax2[j] = nums2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple = nums1_sorted_rev.map!(a => tuple(a, nums1.indexOf(a)));\n\tauto nums2_sorted_rev_tuple = nums2_sorted_rev.map!(a => tuple(a, nums2.indexOf(a)));\n\t\n\tauto nums1_sorted_rev_tuple_sorted = nums1_sorted_rev_tuple.sort!((a, b) => a[0] < b[0]);\n\tauto nums2_sorted_rev_tuple_sorted = nums2_sorted_rev_tuple.sort!((a, b) => a[0] < b[0]);\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev = nums1_sorted_rev_tuple_sorted.dup.reverse;\n\tauto nums2_sorted_rev_tuple_sorted_rev = nums2_sorted_rev_tuple_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev_tuple = nums1_sorted_rev_tuple_sorted_rev.map!(a => tuple(a[0], a[1], nums2_sorted_rev_tuple_sorted_rev.map!(b => tuple(b[0], b[1])).filter!(b => b[1] != a[1]).map!(b => b[0]).sum));\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev_tuple_sorted = nums1_sorted_rev_tuple_s",
    "{\n\tlong[] result = new long[N];\n\tlong[] max_nums1 = new long[N];\n\tlong[] max_nums2 = new long[N];\n\t\n\t// Find the N largest numbers in nums1\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tmax_nums1[i] = max(nums1);\n\t\tnums1 = nums1.filter!(x => x != max_nums1[i]);\n\t}\n\t\n\t// Find the N largest numbers in nums2\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tmax_nums2[i] = max(nums2);\n\t\tnums2 = nums2.filter!(x => x != max_nums2[i]);\n\t}\n\t\n\t// Multiply the N largest numbers in nums1 with the N largest numbers in nums2\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max_nums1[i] * max_nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple array\n\tTuple!(long, long)[] tuples = new Tuple!(long, long)[nums1.length * nums2.length];\n\t\n\t// create the tuples\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttuples[i] = tuple(n1, n2);\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t// sort the tuples\n\ttuples.sort!((a, b) => a[0] * a[1] > b[0] * b[1]);\n\t\n\t// get the first N tuples\n\tforeach(i, t; tuples[0 .. N])\n\t{\n\t\tresult[i] = t[0] * t[1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.sort();\n\tauto nums2_sorted = nums2.sort();\n\tauto nums1_rev = nums1_sorted.reverse();\n\tauto nums2_rev = nums2_sorted.reverse();\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_rev[i] * nums2_rev[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(a => a[0] * a[1], tuple);\n\t\n\t// push the tuples into the priority queue\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t}\n\t}\n\t\n\t// pop the top N elements from the priority queue\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get()[0] * pq.get()[1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_index = nums1_sorted_rev.map!(a => nums1.indexOf(a));\n\tauto nums2_sorted_rev_index = nums2_sorted_rev.map!(a => nums2.indexOf(a));\n\t\n\tauto nums1_sorted_rev_index_sorted = nums1_sorted_rev_index.dup.sort;\n\tauto nums2_sorted_rev_index_sorted = nums2_sorted_rev_index.dup.sort;\n\t\n\tauto nums1_sorted_rev_index_sorted_rev = nums1_sorted_rev_index_sorted.dup.reverse;\n\tauto nums2_sorted_rev_index_sorted_rev = nums2_sorted_rev_index_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_index_sorted_rev_index = nums1_sorted_rev_index_sorted_rev.map!(a => nums1_sorted_rev_index.indexOf(a));\n\tauto nums2_sorted_rev_index_sorted_rev_index = nums2_sorted_rev_index_sorted_rev.map!(a => nums2_sorted_rev_index.indexOf(a));\n\t\n\tauto nums1_sorted_rev_index_sorted_rev_index_sorted = nums1_sorted_rev_index_sorted_rev_index.dup.sort;\n\tauto nums2_sorted_rev_index_sorted_rev_index_sorted = nums2_sorted_rev_",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint k = 0;\n\tforeach(long i; nums1)\n\t{\n\t\tforeach(long j; nums2)\n\t\t{\n\t\t\ttemp[k++] = i * j;\n\t\t}\n\t}\n\ttemp.sort;\n\ttemp.reverse;\n\tresult = temp[0..N];\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max_nums1 = new long[N];\n\tlong[] max_nums2 = new long[N];\n\t\n\t// find the max N numbers in nums1\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tlong max_index = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tif(nums1[j] > max)\n\t\t\t{\n\t\t\t\tmax = nums1[j];\n\t\t\t\tmax_index = j;\n\t\t\t}\n\t\t}\n\t\tmax_nums1[i] = max;\n\t\tnums1[max_index] = 0;\n\t}\n\t\n\t// find the max N numbers in nums2\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tlong max_index = 0;\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(nums2[j] > max)\n\t\t\t{\n\t\t\t\tmax = nums2[j];\n\t\t\t\tmax_index = j;\n\t\t\t}\n\t\t}\n\t\tmax_nums2[i] = max;\n\t\tnums2[max_index] = 0;\n\t}\n\t\n\t// find the max N products\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tlong max_index = 0;\n\t\tforeach(j; 0 .. max_nums1.length)\n\t\t{\n\t\t\tif(max_nums1[j] * max_nums2[j] > max)\n\t\t\t{\n\t\t\t\tmax = max_nums1[j] * max_nums2[j];\n\t\t\t\tmax_index = j;\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\tmax_nums1[max_index] = 0;\n\t\tmax",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tproducts[i * nums2.length + j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tproducts.sort!((a, b) => a > b);\n\t\n\treturn products[0 .. N];\n}",
    "{\n\tauto pq = new PriorityQueue!(long[], \"a[0] > b[0]\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tpq.put([n1 * n2, i, j]);\n\t\t}\n\t}\n\t\n\tlong[][] result = new long[][](N);\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple with the index and the value\n\tTuple!(int, long)[] nums1_t = new Tuple!(int, long)[nums1.length];\n\tTuple!(int, long)[] nums2_t = new Tuple!(int, long)[nums2.length];\n\t\n\tforeach(i, num; nums1)\n\t{\n\t\tnums1_t[i] = tuple(i, num);\n\t}\n\t\n\tforeach(i, num; nums2)\n\t{\n\t\tnums2_t[i] = tuple(i, num);\n\t}\n\t\n\t// sort the tuples\n\tnums1_t.sort!((a, b) => a[1] > b[1]);\n\tnums2_t.sort!((a, b) => a[1] > b[1]);\n\t\n\t// create a tuple with the index and the value\n\tTuple!(int, int, long)[] nums1_t2 = new Tuple!(int, int, long)[nums1.length];\n\tTuple!(int, int, long)[] nums2_t2 = new Tuple!(int, int, long)[nums2.length];\n\t\n\tforeach(i, num; nums1_t)\n\t{\n\t\tnums1_t2[i] = tuple(i, num[0], num[1]);\n\t}\n\t\n\tforeach(i, num; nums2_t)\n\t{\n\t\tnums2_t2[i] = tuple(i, num[0], num[1]);\n\t}\n\t\n\t// sort the tuples\n\tnums1_t2.sort!((a, b) => a[1] > b[1]);\n\tnums2_t2.sort!((a, b) => a[1] > b[1]);\n\t\n\t// create a tuple with the index and the value\n",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1.sort!((a, b) => b - a);\n\tnums2.sort!((a, b) => b - a);\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, (a, b) => a < b);\n\t\n\t// insert the first product of each array\n\tpq.put(nums1[0] * nums2[0]);\n\t\n\t// insert the rest of the products\n\tforeach(i; 1 .. nums1.length)\n\t{\n\t\tforeach(j; 1 .. nums2.length)\n\t\t{\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\t// get the N largest products\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[N];\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp[i] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tsort(temp);\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[N];\n\tlong[] temp2 = new long[N];\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp[i] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tsort(temp);\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort();\n\tnums2_sorted.sort();\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tlong[] nums1_sorted_rev = nums1_sorted.dup;\n\tlong[] nums2_sorted_rev = nums2_sorted.dup;\n\t\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tlong[] products = new long[nums1.length * nums2.length];\n\t\n\tforeach(i, num1; nums1_sorted_rev)\n\t{\n\t\tforeach(j, num2; nums2_sorted_rev)\n\t\t{\n\t\t\tproducts[i * nums2.length + j] = num1 * num2;\n\t\t}\n\t}\n\t\n\tproducts.sort;\n\tproducts.reverse;\n\t\n\tforeach(i, product; products)\n\t{\n\t\tif(i >= N)\n\t\t\tbreak;\n\t\t\n\t\tresult[i] = product;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto result = new long[];\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult ~= nums1_sorted_rev[i] * nums2_sorted_rev[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto products = new long[N];\n\t\n\tauto i = nums1_sorted.length - 1;\n\tauto j = nums2_sorted.length - 1;\n\t\n\tfor (int k = 0; k < N; k++)\n\t{\n\t\tif (nums1_sorted[i] * nums2_sorted[j] > nums1_sorted[i] * nums2_sorted[j - 1])\n\t\t{\n\t\t\tproducts[k] = nums1_sorted[i] * nums2_sorted[j];\n\t\t\tj--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tproducts[k] = nums1_sorted[i] * nums2_sorted[j - 1];\n\t\t\ti--;\n\t\t}\n\t}\n\t\n\treturn products;\n}",
    "{\n\tauto result = new long[N];\n\tauto nums1_sorted = nums1.dup;\n\tauto nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\twhile(k < N)\n\t{\n\t\tif(nums1_sorted[i] * nums2_sorted[j] > nums1_sorted[i] * nums2_sorted[j+1])\n\t\t{\n\t\t\tresult[k] = nums1_sorted[i] * nums2_sorted[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k] = nums1_sorted[i] * nums2_sorted[j+1];\n\t\t\ti++;\n\t\t}\n\t\tk++;\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\twhile(N > 0)\n\t{\n\t\tlong product = nums1_sorted.back * nums2_sorted.back;\n\t\tresult ~= product;\n\t\t\n\t\tif(nums1_sorted.back > nums2_sorted.back)\n\t\t{\n\t\t\tnums1_sorted.popBack;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnums2_sorted.popBack;\n\t\t}\n\t\t\n\t\tN--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = PriorityQueue!(long[], \"a[0] > b[0]\")();\n\tforeach(i, num; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tif(pq.length < N)\n\t\t\t{\n\t\t\t\tpq.put(new long[]{num * num2, i, j});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif(top[0] < num * num2)\n\t\t\t\t{\n\t\t\t\t\tpq.put(new long[]{num * num2, i, j});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pq.get();\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1 = nums1.sort(std.numeric.comparisonFunctor!(\"a > b\"));\n\tnums2 = nums2.sort(std.numeric.comparisonFunctor!(\"a > b\"));\n\t\n\t// create a tuple with the index and the value of the largest element in nums1\n\tauto largest_nums1 = tuple(0, nums1[0]);\n\t\n\t// create a tuple with the index and the value of the largest element in nums2\n\tauto largest_nums2 = tuple(0, nums2[0]);\n\t\n\t// create a tuple with the index and the value of the smallest element in nums1\n\tauto smallest_nums1 = tuple(0, nums1[nums1.length - 1]);\n\t\n\t// create a tuple with the index and the value of the smallest element in nums2\n\tauto smallest_nums2 = tuple(0, nums2[nums2.length - 1]);\n\t\n\t// create a tuple with the index and the value of the second largest element in nums1\n\tauto second_largest_nums1 = tuple(0, nums1[1]);\n\t\n\t// create a tuple with the index and the value of the second largest element in nums2\n\tauto second_largest_nums2 = tuple(0, nums2[1]);\n\t\n\t// create a tuple with the index and the value of the second smallest element in nums1\n\tauto second_smallest_nums1 = tuple(0, nums1[nums1.length - 2]);\n\t\n\t// create a tuple with the index and the value of the second smallest element in nums2\n\tauto second_smallest_nums2 = tuple(0, nums2[nums2.length - 2]);\n\t\n\t// create a tuple with the index and the value of the third largest element in nums1\n\tauto third_largest_nums1 = tuple(0, nums1[2]);\n\t\n\t// create a tuple with the index and the value of",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_largest = nums1_sorted[$-N..$];\n\tauto nums2_largest = nums2_sorted[$-N..$];\n\t\n\tauto result = new long[N];\n\t\n\tforeach(i, ref n; result)\n\t{\n\t\tresult[i] = nums1_largest[i] * nums2_largest[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tmax1[i] = max2[i] = long.min;\n\t}\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. N)\n\t\t{\n\t\t\tif(nums1[i] > max1[j])\n\t\t\t{\n\t\t\t\tmax1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. nums2.length)\n\t{\n\t\tforeach(j; 0 .. N)\n\t\t{\n\t\t\tif(nums2[i] > max2[j])\n\t\t\t{\n\t\t\t\tmax2[j] = nums2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tlong[] result = new long[N];\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint m = nums1.length;\n\tint n = nums2.length;\n\twhile (i < m && j < n && k < N) \n\t{\n\t\tif (nums1[i] > nums2[j]) \n\t\t{\n\t\t\tresult[k] = nums1[i];\n\t\t\ti++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tresult[k] = nums2[j];\n\t\t\tj++;\n\t\t}\n\t\tk++;\n\t}\n\twhile (i < m && k < N) \n\t{\n\t\tresult[k] = nums1[i];\n\t\ti++;\n\t\tk++;\n\t}\n\twhile (j < n && k < N) \n\t{\n\t\tresult[k] = nums2[j];\n\t\tj++;\n\t\tk++;\n\t}\n\treturn result;\n}",
    "{\n    // Write your code here\n    long[] result = new long[N];\n    long[] nums1_copy = nums1.dup;\n    long[] nums2_copy = nums2.dup;\n    sort(nums1_copy);\n    sort(nums2_copy);\n    for (int i = 0; i < N; i++)\n    {\n        result[i] = nums1_copy[nums1_copy.length - 1 - i] * nums2_copy[nums2_copy.length - 1 - i];\n    }\n    return result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[N];\n\tauto pq = new PriorityQueue!(long, \"a > b\")();\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tauto cur = nums1[i] * nums2[j];\n\t\t\tif(pq.length < N)\n\t\t\t{\n\t\t\t\tpq.put(cur);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(pq.peek() < cur)\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort();\n\tnums2_sorted.sort();\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// create a set to store the visited elements\n\tauto visited = new Set!(Tuple!(long, long));\n\t\n\t// add the first element to the priority queue\n\tpq.put(nums1[$-1] * nums2[$-1]);\n\tvisited.insert(tuple(nums1[$-1], nums2[$-1]));\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\t// get the largest product\n\t\tauto product = pq.get();\n\t\t\n\t\t// store the product\n\t\tresult[i] = product;\n\t\t\n\t\t// get the factors\n\t\tauto factors = visited.find(tuple(product / nums2[$-1], nums2[$-1]));\n\t\t\n\t\t// add the next largest product\n\t\tif(factors.length > 0)\n\t\t{\n\t\t\tauto next_product = (factors[0][0] - 1) * nums2[$-1];\n\t\t\tpq.put(next_product);\n\t\t\tvisited.insert(tuple(factors[0][0] - 1, nums2[$-1]));\n\t\t}\n\t\t\n\t\t// add the next largest product\n\t\tif(factors.length > 0)\n\t\t{\n\t\t\tauto next_product = factors[0][0] * (nums2[$-1] - 1);\n\t\t\tpq.put(next_product);\n\t\t\tvisited.insert(tuple(factors[0][0], nums2[$-1] - 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto l1 = nums1.length;\n\tauto l2 = nums2.length;\n\tauto result = new long[N];\n\tauto pq = new PriorityQueue!(long[], \"a[0] > b[0]\");\n\t\n\tforeach(i; 0 .. l1)\n\t{\n\t\tforeach(j; 0 .. l2)\n\t\t{\n\t\t\tauto product = nums1[i] * nums2[j];\n\t\t\tif(pq.length < N)\n\t\t\t{\n\t\t\t\tpq.put([product, i, j]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif(top[0] < product)\n\t\t\t\t{\n\t\t\t\t\tpq.put([product, i, j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto top = pq.get();\n\t\tresult[i] = top[0];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[nums1.length];\n\tlong[] max2 = new long[nums2.length];\n\tmax1[0] = nums1[0];\n\tmax2[0] = nums2[0];\n\tfor (long i = 1; i < nums1.length; i++)\n\t{\n\t\tmax1[i] = max(max1[i - 1], nums1[i]);\n\t}\n\tfor (long i = 1; i < nums2.length; i++)\n\t{\n\t\tmax2[i] = max(max2[i - 1], nums2[i]);\n\t}\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\twhile (k < N)\n\t{\n\t\tif (max1[i] * max2[j] > max1[i + 1] * max2[j + 1])\n\t\t{\n\t\t\tresult[k] = max1[i] * max2[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k] = max1[i + 1] * max2[j + 1];\n\t\t\ti++;\n\t\t}\n\t\tk++;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto maxHeap = new MaxHeap!(long);\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tmaxHeap.insert(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = maxHeap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tauto max1 = nums1[0];\n\tauto max2 = nums2[0];\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tif (nums1[i] > max1)\n\t\t\tmax1 = nums1[i];\n\t}\n\t\n\tforeach(i; 0 .. n2)\n\t{\n\t\tif (nums2[i] > max2)\n\t\t\tmax2 = nums2[i];\n\t}\n\t\n\tauto max = max1 * max2;\n\t\n\tauto min1 = nums1[0];\n\tauto min2 = nums2[0];\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tif (nums1[i] < min1)\n\t\t\tmin1 = nums1[i];\n\t}\n\t\n\tforeach(i; 0 .. n2)\n\t{\n\t\tif (nums2[i] < min2)\n\t\t\tmin2 = nums2[i];\n\t}\n\t\n\tauto min = min1 * min2;\n\t\n\tif (N == 1)\n\t{\n\t\tresult ~= max;\n\t\treturn result;\n\t}\n\t\n\tif (N == 2)\n\t{\n\t\tresult ~= max;\n\t\tresult ~= min;\n\t\treturn result;\n\t}\n\t\n\tauto max_heap = new Heap!(long)();\n\tauto min_heap = new Heap!(long)();\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tauto product = nums1[i] * nums2[j];\n\t\t\t\n\t\t\tif (product > max)\n\t\t\t{\n\t\t\t\tmax_heap.insert(product",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tlong[] nums1_sorted_rev = nums1_sorted.dup;\n\tlong[] nums2_sorted_rev = nums2_sorted.dup;\n\t\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tlong[] nums1_sorted_rev_sq = nums1_sorted_rev.map!(a => a * a);\n\tlong[] nums2_sorted_rev_sq = nums2_sorted_rev.map!(a => a * a);\n\t\n\tlong[] nums1_sorted_rev_sq_sorted = nums1_sorted_rev_sq.dup;\n\tlong[] nums2_sorted_rev_sq_sorted = nums2_sorted_rev_sq.dup;\n\t\n\tnums1_sorted_rev_sq_sorted.sort;\n\tnums2_sorted_rev_sq_sorted.sort;\n\t\n\tlong[] nums1_sorted_rev_sq_sorted_rev = nums1_sorted_rev_sq_sorted.dup;\n\tlong[] nums2_sorted_rev_sq_sorted_rev = nums2_sorted_rev_sq_sorted.dup;\n\t\n\tnums1_sorted_rev_sq_sorted_rev.reverse;\n\tnums2_sorted_rev_sq_sorted_rev.reverse;\n\t\n\tlong[] nums1_sorted_rev_sq_sorted_rev_sq = nums1_sorted_rev_sq_sorted_rev.map!(a => a * a);\n\tlong[] nums2_sorted_rev_sq_sorted_rev_sq =",
    "{\n\tlong[] result = new long[N];\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\t// sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple2 = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple3 = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple4 = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple5 = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple6 = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple7 = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple8 = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple9 = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple10 = new Tuple!(size_t, size_t)();\n\t\n\t// create a tuple to store the indices of the two arrays\n\tauto tuple11 = new Tuple!(size",
    "{\n\tlong[] result;\n\tauto max_heap = MaxHeap!(long)();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tmax_heap.insert(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tresult = new long[N];\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = max_heap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2\n\tnums1.sort!((a, b) => a > b);\n\tnums2.sort!((a, b) => a > b);\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, (a, b) => a < b);\n\t\n\t// insert the first element\n\tpq.put(nums1[0] * nums2[0]);\n\t\n\t// create a set to store the visited elements\n\tauto visited = new Set!(Tuple!(long, long));\n\t\n\t// insert the first element\n\tvisited.insert(tuple(0, 0));\n\t\n\t// create a tuple to store the current position\n\tauto curr = tuple(0, 0);\n\t\n\t// iterate N times\n\tforeach (i; 0 .. N)\n\t{\n\t\t// get the current element\n\t\tresult[i] = pq.get();\n\t\t\n\t\t// get the current position\n\t\tcurr = tuple(curr[0], curr[1]);\n\t\t\n\t\t// check if the next element in nums1 is valid\n\t\tif (curr[0] + 1 < nums1.length && !visited.contains(tuple(curr[0] + 1, curr[1])))\n\t\t{\n\t\t\t// insert the next element in nums1\n\t\t\tpq.put(nums1[curr[0] + 1] * nums2[curr[1]]);\n\t\t\t\n\t\t\t// add the next element in nums1 to the set\n\t\t\tvisited.insert(tuple(curr[0] + 1, curr[1]));\n\t\t}\n\t\t\n\t\t// check if the next element in nums2 is valid\n\t\tif (curr[1] + 1 < nums2.length && !visited.contains(tuple(curr[0], curr[1] + 1)))\n\t\t{\n\t\t\t// insert the next element in nums2\n",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto maxHeap = new MaxHeap!(long)();\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tmaxHeap.insert(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = maxHeap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\tlong[] min1 = new long[N];\n\tlong[] min2 = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tmax1[i] = max2[i] = long.min;\n\t\tmin1[i] = min2[i] = long.max;\n\t}\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..N)\n\t\t{\n\t\t\tif(nums1[i] > max1[j])\n\t\t\t{\n\t\t\t\tforeach(k; j..N)\n\t\t\t\t{\n\t\t\t\t\tmax1[k] = max1[k-1];\n\t\t\t\t}\n\t\t\t\tmax1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tforeach(j; 0..N)\n\t\t{\n\t\t\tif(nums1[i] < min1[j])\n\t\t\t{\n\t\t\t\tforeach(k; j..N)\n\t\t\t\t{\n\t\t\t\t\tmin1[k] = min1[k-1];\n\t\t\t\t}\n\t\t\t\tmin1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..nums2.length)\n\t{\n\t\tforeach(j; 0..N)\n\t\t{\n\t\t\tif(nums2[i] > max2[j])\n\t\t\t{\n\t\t\t\tforeach(k; j..N)\n\t\t\t\t{\n\t\t\t\t\tmax2[k] = max2[k-1];\n\t\t\t\t}\n\t\t\t\tmax2[j] = nums2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto maxHeap = new MaxHeap!(long)();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tmaxHeap.insert(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = maxHeap.extract();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\t\n\t\tif(nums1_sorted[$-1] == nums1_sorted[$-2])\n\t\t\tnums1_sorted[$-2] = long.min;\n\t\telse\n\t\t\tnums1_sorted[$-1] = long.min;\n\t\t\n\t\tif(nums2_sorted[$-1] == nums2_sorted[$-2])\n\t\t\tnums2_sorted[$-2] = long.min;\n\t\telse\n\t\t\tnums2_sorted[$-1] = long.min;\n\t\t\n\t\tnums1_sorted.sort;\n\t\tnums2_sorted.sort;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach (i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$ - 1] * nums2_sorted[$ - 1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[N];\n\tlong[] temp2 = new long[N];\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp[i] = nums1[i] * nums2[j];\n\t\t\ttemp2[i] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tsort(temp);\n\tsort(temp2);\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = temp[i] * temp2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\tauto products = new long[];\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tproducts ~= nums1_sorted[i] * nums2_sorted[j];\n\t\t}\n\t}\n\t\n\tproducts.sort;\n\treturn products[$ - N .. $];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = nums1[0];\n\t\tmax2[i] = nums2[0];\n\t}\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums1[i] > max1[j])\n\t\t\t{\n\t\t\t\tfor(int k = N - 1; k > j; k--)\n\t\t\t\t{\n\t\t\t\t\tmax1[k] = max1[k - 1];\n\t\t\t\t}\n\t\t\t\tmax1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < nums2.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums2[i] > max2[j])\n\t\t\t{\n\t\t\t\tfor(int k = N - 1; k > j; k--)\n\t\t\t\t{\n\t\t\t\t\tmax2[k] = max2[k - 1];\n\t\t\t\t}\n\t\t\t\tmax2[j] = nums2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = nums1[0];\n\t\tmax2[i] = nums2[0];\n\t}\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums1[i] > max1[j])\n\t\t\t{\n\t\t\t\tfor(int k = N - 1; k > j; k--)\n\t\t\t\t{\n\t\t\t\t\tmax1[k] = max1[k - 1];\n\t\t\t\t}\n\t\t\t\tmax1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < nums2.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums2[i] > max2[j])\n\t\t\t{\n\t\t\t\tfor(int k = N - 1; k > j; k--)\n\t\t\t\t{\n\t\t\t\t\tmax2[k] = max2[k - 1];\n\t\t\t\t}\n\t\t\t\tmax2[j] = nums2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort!((a, b) => a > b);\n\tauto nums2_sorted = nums2.dup.sort!((a, b) => a > b);\n\t\n\tauto nums1_sorted_set = nums1_sorted.toHashSet;\n\tauto nums2_sorted_set = nums2_sorted.toHashSet;\n\t\n\tauto nums1_sorted_set_arr = nums1_sorted_set.toArray;\n\tauto nums2_sorted_set_arr = nums2_sorted_set.toArray;\n\t\n\tauto nums1_sorted_set_arr_len = nums1_sorted_set_arr.length;\n\tauto nums2_sorted_set_arr_len = nums2_sorted_set_arr.length;\n\t\n\tauto result = new long[N];\n\t\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\t\n\twhile (k < N)\n\t{\n\t\tif (i < nums1_sorted_set_arr_len && j < nums2_sorted_set_arr_len)\n\t\t{\n\t\t\tif (nums1_sorted_set_arr[i] > nums2_sorted_set_arr[j])\n\t\t\t{\n\t\t\t\tresult[k] = nums1_sorted_set_arr[i] * nums2_sorted_set_arr[j];\n\t\t\t\t++i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult[k] = nums1_sorted_set_arr[i] * nums2_sorted_set_arr[j];\n\t\t\t\t++j;\n\t\t\t}\n\t\t}\n\t\telse if (i < nums1_sorted_set_arr_len)\n\t\t{\n\t\t\tresult[k] = nums1_sorted_set_arr[i] * nums2",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a min heap\n\tauto minHeap = new MinHeap!(long, long)();\n\t\n\t// push the first element of nums1 and nums2 into the min heap\n\tminHeap.push(nums1[$-1] * nums2[$-1], nums1.length - 1, nums2.length - 1);\n\t\n\t// pop N elements from the min heap\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tauto val = minHeap.pop();\n\t\tresult[i] = val[0];\n\t\t\n\t\t// push the next element from the same array\n\t\tif (val[1] > 0)\n\t\t\tminHeap.push(nums1[val[1] - 1] * nums2[val[2]], val[1] - 1, val[2]);\n\t\t\n\t\t// push the next element from the other array\n\t\tif (val[2] > 0)\n\t\t\tminHeap.push(nums1[val[1]] * nums2[val[2] - 1], val[1], val[2] - 1);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t//sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t//create a priority queue\n\tauto pq = new PriorityQueue!(long)();\n\t\n\t//add all products to the priority queue\n\tforeach(n1; nums1)\n\t\tforeach(n2; nums2)\n\t\t\tpq.put(n1 * n2);\n\t\n\t//pop the N largest products\n\tforeach(i; 0 .. N)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[][] products = new long[nums1.length][nums2.length];\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tproducts[i][j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(products[j][k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = products[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(products[j][k] == max)\n\t\t\t\t{\n\t\t\t\t\tproducts[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_index = nums1_sorted_rev.indexOf;\n\tauto nums2_sorted_rev_index = nums2_sorted_rev.indexOf;\n\t\n\tauto nums1_sorted_index = nums1_sorted.indexOf;\n\tauto nums2_sorted_index = nums2_sorted.indexOf;\n\t\n\tauto nums1_sorted_rev_index_sorted = nums1_sorted_rev_index.dup.sort;\n\tauto nums2_sorted_rev_index_sorted = nums2_sorted_rev_index.dup.sort;\n\t\n\tauto nums1_sorted_index_sorted = nums1_sorted_index.dup.sort;\n\tauto nums2_sorted_index_sorted = nums2_sorted_index.dup.sort;\n\t\n\tauto nums1_sorted_rev_index_sorted_rev = nums1_sorted_rev_index_sorted.dup.reverse;\n\tauto nums2_sorted_rev_index_sorted_rev = nums2_sorted_rev_index_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_index_sorted_rev = nums1_sorted_index_sorted.dup.reverse;\n\tauto nums2_sorted_index_sorted_rev = nums2_sorted_index_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_index_sorted_rev_index = nums1_sorted_rev_index_sorted_rev.indexOf;\n\tauto num",
    "{\n\tlong[] result;\n\tint i, j;\n\t\n\tresult = new long[N];\n\t\n\t// Sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// Start from the largest numbers\n\tfor (i = nums1.length - 1, j = nums2.length - 1; i >= 0 && j >= 0; i--, j--)\n\t{\n\t\tresult[--N] = nums1[i] * nums2[j];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttemp[i] = n1 * n2;\n\t\t\ti++;\n\t\t}\n\t}\n\ttemp.sort!((a, b) => a > b);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tlong[] result = new long[N];\n\tlong[] sorted1 = nums1.dup.sort;\n\tlong[] sorted2 = nums2.dup.sort;\n\tint index1 = sorted1.length - 1;\n\tint index2 = sorted2.length - 1;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (sorted1[index1] * sorted2[index2] > sorted1[0] * sorted2[index2])\n\t\t{\n\t\t\tresult[i] = sorted1[index1] * sorted2[index2];\n\t\t\tindex1--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[i] = sorted1[0] * sorted2[index2];\n\t\t\tindex2--;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// add the products to the priority queue\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tlong product = nums1[i] * nums2[j];\n\t\t\tif(set.insert(product))\n\t\t\t\tpq.put(product);\n\t\t}\n\t}\n\t\n\t// get the N largest products\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tmax1[i] = max(nums1);\n\t\tmax2[i] = max(nums2);\n\t\tresult[i] = max1[i] * max2[i];\n\t\tnums1 = nums1.filter!(x => x != max1[i]);\n\t\tnums2 = nums2.filter!(x => x != max2[i]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// Sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// Create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// Create a priority queue\n\tauto pq = new PriorityQueue!(tuple, \"a[0][0] * a[1][0]\");\n\t\n\t// Add the first elements of the arrays to the priority queue\n\tpq.put(tuple(nums1[$-1], nums2[$-1]));\n\t\n\t// Loop through the number of results\n\tforeach(i; 0 .. N)\n\t{\n\t\t// Get the largest product\n\t\tauto t = pq.get();\n\t\t\n\t\t// Add the product to the result array\n\t\tresult[i] = t[0][0] * t[1][0];\n\t\t\n\t\t// If the first array has more elements, add the next element to the priority queue\n\t\tif (t[0].length > 1)\n\t\t{\n\t\t\tpq.put(tuple(t[0][1 .. $], t[1]));\n\t\t}\n\t\t\n\t\t// If the second array has more elements, add the next element to the priority queue\n\t\tif (t[1].length > 1)\n\t\t{\n\t\t\tpq.put(tuple(t[0], t[1][1 .. $]));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\t\n\tresult = new long[N];\n\t\n\tauto maxHeap = new MaxHeap!(long)();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(maxHeap.length < N)\n\t\t\t{\n\t\t\t\tmaxHeap.insert(nums1[i] * nums2[j]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] * nums2[j] > maxHeap.peek())\n\t\t\t\t{\n\t\t\t\t\tmaxHeap.pop();\n\t\t\t\t\tmaxHeap.insert(nums1[i] * nums2[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = maxHeap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// create a set of tuples\n\tauto set = new Set!(Tuple!(long, long));\n\t\n\t// add the first element of each array to the priority queue\n\tpq.put(nums1[0] * nums2[0]);\n\tset.insert(tuple(nums1[0], nums2[0]));\n\t\n\t// loop through the rest of the elements\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\t// get the largest element from the priority queue\n\t\tauto largest = pq.get();\n\t\t\n\t\t// add the largest element to the result array\n\t\tresult[i] = largest;\n\t\t\n\t\t// get the tuple from the set\n\t\tauto t = set.get(largest);\n\t\t\n\t\t// if the tuple is not null\n\t\tif (t !is null)\n\t\t{\n\t\t\t// add the next element from the first array to the priority queue\n\t\t\tpq.put(t[0] * nums2[t[1] + 1]);\n\t\t\t\n\t\t\t// add the next element from the second array to the priority queue\n\t\t\tpq.put(nums1[t[0] + 1] * t[1]);\n\t\t\t\n\t\t\t// add the next element from the first array to the set\n\t\t\tset.insert(tuple(t[0], t[1] + 1));\n\t\t\t\n\t\t\t// add the next element from the second array to the set\n\t\t\tset.insert(tuple(t[0] + 1, t[1]));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint k = 0;\n\tforeach(long i; nums1)\n\t{\n\t\tforeach(long j; nums2)\n\t\t{\n\t\t\ttemp[k++] = i * j;\n\t\t}\n\t}\n\tsort(temp);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[temp.length - 1 - i];\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup;\n\tauto nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup;\n\tauto nums2_sorted_rev = nums2_sorted.dup;\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tauto nums1_sorted_rev_iter = nums1_sorted_rev.front;\n\tauto nums2_sorted_iter = nums2_sorted.front;\n\t\n\tlong[] result;\n\t\n\twhile(N > 0)\n\t{\n\t\tauto product = nums1_sorted_rev_iter * nums2_sorted_iter;\n\t\tresult ~= product;\n\t\t\n\t\tif(nums1_sorted_rev_iter == nums1_sorted_rev.back)\n\t\t{\n\t\t\tnums2_sorted_iter++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnums1_sorted_rev_iter++;\n\t\t}\n\t\tN--;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] products = new long[nums1.length * nums2.length];\n\tint index = 0;\n\tforeach(long num1; nums1)\n\t{\n\t\tforeach(long num2; nums2)\n\t\t{\n\t\t\tproducts[index++] = num1 * num2;\n\t\t}\n\t}\n\t\n\tsort(products);\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = products[products.length - i - 1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\treturn result;\n}",
    "{\n\tauto pq = PriorityQueue!(long, \"a > b\")(nums1.length * nums2.length);\n\tforeach(i, e1; nums1)\n\t{\n\t\tforeach(j, e2; nums2)\n\t\t{\n\t\t\tpq.put(e1 * e2);\n\t\t}\n\t}\n\t\n\tlong[] res = new long[N];\n\tforeach(i; 0 .. N)\n\t{\n\t\tres[i] = pq.get();\n\t}\n\treturn res;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1.sort!((a,b) => a > b);\n\tnums2.sort!((a,b) => a > b);\n\t\n\t// create a tuple of (product, index1, index2)\n\tTuple!(long, int, int)[] products = new Tuple!(long, int, int)[nums1.length * nums2.length];\n\t\n\tint index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tproducts[index] = tuple(nums1[i] * nums2[j], i, j);\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\t// sort the products in descending order\n\tproducts.sort!((a,b) => a[0] > b[0]);\n\t\n\t// get the first N products\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = products[i][0];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup;\n\tauto nums2_sorted = nums2.dup;\n\tnums1_sorted.sort();\n\tnums2_sorted.sort();\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup;\n\tauto nums2_sorted_rev = nums2_sorted.dup;\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tauto nums1_sorted_rev_iter = nums1_sorted_rev.front;\n\tauto nums2_sorted_iter = nums2_sorted.front;\n\t\n\tlong[] result;\n\t\n\twhile(N > 0)\n\t{\n\t\tif(nums1_sorted_rev_iter.value * nums2_sorted_iter.value > nums1_sorted_rev_iter.value * nums2_sorted_iter.next.value)\n\t\t{\n\t\t\tresult ~= nums1_sorted_rev_iter.value * nums2_sorted_iter.value;\n\t\t\tnums2_sorted_iter = nums2_sorted_iter.next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult ~= nums1_sorted_rev_iter.value * nums2_sorted_iter.next.value;\n\t\t\tnums2_sorted_iter = nums2_sorted_iter.next.next;\n\t\t}\n\t\t\n\t\tif(nums2_sorted_iter.value == nums2_sorted.back)\n\t\t{\n\t\t\tnums1_sorted_rev_iter = nums1_sorted_rev_iter.next;\n\t\t\tnums2_sorted_iter = nums2_sorted.front;\n\t\t}\n\t\t\n\t\tN--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_i = nums1_sorted_rev.iterator;\n\tauto nums2_sorted_rev_i = nums2_sorted_rev.iterator;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted_rev_i.front * nums2_sorted_rev_i.front;\n\t\t\n\t\tif(nums1_sorted_rev_i.front > nums2_sorted_rev_i.front)\n\t\t{\n\t\t\tnums1_sorted_rev_i.popFront;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnums2_sorted_rev_i.popFront;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto l1 = nums1.length;\n\tauto l2 = nums2.length;\n\t\n\tauto max_product = new long[N];\n\t\n\tauto max_index = new long[N];\n\t\n\tauto max_index_2 = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tmax_product[i] = nums1[0] * nums2[0];\n\t\tmax_index[i] = 0;\n\t\tmax_index_2[i] = 0;\n\t}\n\t\n\tforeach(i; 0..l1)\n\t{\n\t\tforeach(j; 0..l2)\n\t\t{\n\t\t\tauto product = nums1[i] * nums2[j];\n\t\t\t\n\t\t\tforeach(k; 0..N)\n\t\t\t{\n\t\t\t\tif(product > max_product[k])\n\t\t\t\t{\n\t\t\t\t\tmax_product[k] = product;\n\t\t\t\t\tmax_index[k] = i;\n\t\t\t\t\tmax_index_2[k] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn max_product;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto result = new long[];\n\t\n\twhile(N > 0)\n\t{\n\t\tauto max_product = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tauto min_product = nums1_sorted[0] * nums2_sorted[0];\n\t\t\n\t\tif(max_product > min_product)\n\t\t{\n\t\t\tresult ~= max_product;\n\t\t\tnums1_sorted.popBack;\n\t\t\tnums2_sorted.popBack;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult ~= min_product;\n\t\t\tnums1_sorted.popFront;\n\t\t\tnums2_sorted.popFront;\n\t\t}\n\t\t\n\t\tN--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult ~= nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttemp[i] = n1 * n2;\n\t\t\ti++;\n\t\t}\n\t}\n\tsort(temp);\n\tfor(int j = 0; j < N; j++)\n\t{\n\t\tresult[j] = temp[temp.length - 1 - j];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tint i = nums1_sorted.length - 1;\n\tint j = nums2_sorted.length - 1;\n\tint k = 0;\n\t\n\twhile (k < N)\n\t{\n\t\tresult[k] = nums1_sorted[i] * nums2_sorted[j];\n\t\tif (i > 0 && j > 0)\n\t\t{\n\t\t\tif (nums1_sorted[i - 1] * nums2_sorted[j] > nums1_sorted[i] * nums2_sorted[j - 1])\n\t\t\t{\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\telse if (i > 0)\n\t\t{\n\t\t\ti--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tproducts[i++] = n1 * n2;\n\t\t}\n\t}\n\treturn products.sort.reverse[0..N];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\tlong[] max1_index = new long[N];\n\tlong[] max2_index = new long[N];\n\tlong[] max1_index_temp = new long[N];\n\tlong[] max2_index_temp = new long[N];\n\tlong[] max1_temp = new long[N];\n\tlong[] max2_temp = new long[N];\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = nums1[0];\n\t\tmax2[i] = nums2[0];\n\t\tmax1_index[i] = 0;\n\t\tmax2_index[i] = 0;\n\t\tmax1_index_temp[i] = 0;\n\t\tmax2_index_temp[i] = 0;\n\t\tmax1_temp[i] = 0;\n\t\tmax2_temp[i] = 0;\n\t}\n\t\n\tfor (long i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (long j = 0; j < N; j++)\n\t\t{\n\t\t\tif (nums1[i] > max1[j])\n\t\t\t{\n\t\t\t\tmax1_temp[j] = max1[j];\n\t\t\t\tmax1_index_temp[j] = max1_index[j];\n\t\t\t\tmax1[j] = nums1[i];\n\t\t\t\tmax1_index[j] = i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax1_temp[j] = nums1[i];\n\t\t\t\tmax1_index_temp[j] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (long j = 0; j < N; j++)\n\t\t{\n\t\t\tmax1[j] = max1_temp[j];\n\t\t\tmax1_index[j] = max"
  ]
}