{
  "name": "mbpp_308_large_product",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find the specified number of largest products from two given arrays, selecting one factor from each array.\n\t\n*/\nlong[] large_product(long[] nums1, long[] nums2, long N) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = large_product;\n\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 3L) == [60L, 54L, 50L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 4L) == [60L, 54L, 50L, 48L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 5L) == [60L, 54L, 50L, 48L, 45L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong[] result = new long[N];\n\t\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\t\n\twhile(k < N)\n\t{\n\t\tif(nums1[i] * nums2[j] > nums1[i] * nums2[j+1])\n\t\t{\n\t\t\tresult[k] = nums1[i] * nums2[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k] = nums1[i] * nums2[j+1];\n\t\t\ti++;\n\t\t}\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto a = new long[nums1.length * nums2.length];\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ta[i++] = n1 * n2;\n\t\t}\n\t}\n\ta.sort();\n\treturn a[$ - N .. $];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint index = 0;\n\tforeach(long num1; nums1)\n\t{\n\t\tforeach(long num2; nums2)\n\t\t{\n\t\t\ttemp[index++] = num1 * num2;\n\t\t}\n\t}\n\tsort(temp);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[temp.length - i - 1];\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\tauto result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort both arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) nums = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two indexes\n\tTuple!(long, long) indexes = tuple(nums1.length - 1, nums2.length - 1);\n\t\n\t// iterate over the result array\n\tforeach(i; 0 .. N)\n\t{\n\t\t// get the product of the two numbers at the indexes\n\t\tlong product = nums[0][indexes[0]] * nums[1][indexes[1]];\n\t\t\n\t\t// add the product to the result array\n\t\tresult[i] = product;\n\t\t\n\t\t// if the product is the same as the previous product\n\t\tif (i > 0 && product == result[i - 1])\n\t\t{\n\t\t\t// decrement the index of the second array\n\t\t\tindexes[1]--;\n\t\t}\n\t\t// otherwise\n\t\telse\n\t\t{\n\t\t\t// decrement the index of the first array\n\t\t\tindexes[0]--;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup;\n\tauto nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup;\n\tauto nums2_sorted_rev = nums2_sorted.dup;\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tauto nums1_sorted_rev_index = 0;\n\tauto nums2_sorted_rev_index = 0;\n\t\n\tauto result = new long[];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto num1 = nums1_sorted_rev[nums1_sorted_rev_index];\n\t\tauto num2 = nums2_sorted_rev[nums2_sorted_rev_index];\n\t\t\n\t\tif(num1 * nums2_sorted[0] > num2 * nums1_sorted[0])\n\t\t{\n\t\t\tresult ~= num1 * nums2_sorted[0];\n\t\t\tnums1_sorted_rev_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult ~= num2 * nums1_sorted[0];\n\t\t\tnums2_sorted_rev_index++;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[N];\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto max_heap = new Heap!(tuple!(long, long, long));\n\t\n\tfor (auto i = 0; i < n1; i++)\n\t{\n\t\tfor (auto j = 0; j < n2; j++)\n\t\t{\n\t\t\tauto product = nums1[i] * nums2[j];\n\t\t\tif (max_heap.length < N)\n\t\t\t{\n\t\t\t\tmax_heap.insert(tuple(product, i, j));\n\t\t\t}\n\t\t\telse if (product > max_heap.front[0])\n\t\t\t{\n\t\t\t\tmax_heap.popFront();\n\t\t\t\tmax_heap.insert(tuple(product, i, j));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (auto i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max_heap.popFront()[0];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\t\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1.sort!((a, b) => a > b);\n\tnums2.sort!((a, b) => a > b);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t// create a tuple of the two arrays\n\tauto tuple =",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// get the largest N products\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1[nums1.length - 1 - i] * nums2[nums2.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort;\n\tnums2.sort;\n\t\n\t// create a priority queue of the products\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tpq.put(n1 * n2);\n\t\t}\n\t}\n\t\n\t// get the largest N products\n\tforeach(i, n; result)\n\t{\n\t\tresult[i] = pq.get;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(i, a; nums1)\n\t{\n\t\tforeach(j, b; nums2)\n\t\t{\n\t\t\tpq.put(a * b);\n\t\t}\n\t}\n\t\n\tforeach(i, r; result)\n\t{\n\t\tr = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort();\n\tnums2_sorted.sort();\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack();\n\t\tnums2_sorted.popBack();\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\tauto products = new long[];\n\tauto i = 0;\n\tauto j = 0;\n\twhile(products.length < N)\n\t{\n\t\tif(nums1_sorted[i] * nums2_sorted[j] > nums1_sorted[i] * nums2_sorted[j+1])\n\t\t{\n\t\t\tproducts ~= nums1_sorted[i] * nums2_sorted[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tproducts ~= nums1_sorted[i] * nums2_sorted[j+1];\n\t\t\ti++;\n\t\t}\n\t}\n\treturn products;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// add the products of the first elements of the arrays\n\tpq.put(nums1[0] * nums2[0]);\n\t\n\t// create a map to store the indices of the elements\n\tauto map = new Map!(long, tuple!(long, long));\n\tmap[nums1[0] * nums2[0]] = tuple(0, 0);\n\t\n\t// iterate over the elements of the queue\n\tforeach(i; 0 .. N)\n\t{\n\t\t// get the top element\n\t\tauto top = pq.get();\n\t\t\n\t\t// add it to the result\n\t\tresult[i] = top;\n\t\t\n\t\t// get the indices of the top element\n\t\tauto indices = map[top];\n\t\t\n\t\t// remove the top element from the map\n\t\tmap.remove(top);\n\t\t\n\t\t// add the next possible products to the queue\n\t\tif(indices[0] < nums1.length - 1)\n\t\t{\n\t\t\tauto next = nums1[indices[0] + 1] * nums2[indices[1]];\n\t\t\tpq.put(next);\n\t\t\tmap[next] = tuple(indices[0] + 1, indices[1]);\n\t\t}\n\t\tif(indices[1] < nums2.length - 1)\n\t\t{\n\t\t\tauto next = nums1[indices[0]] * nums2[indices[1] + 1];\n\t\t\tpq.put(next);\n\t\t\tmap[next] = tuple(indices[0], indices[1] + 1);\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] > b[0]\");\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put([nums1[i] * nums2[j], i, j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = t[0];\n\t\t\n\t\tif(t[1] < nums1.length - 1 && t[2] < nums2.length - 1)\n\t\t{\n\t\t\tpq.put([nums1[t[1] + 1] * nums2[t[2] + 1], t[1] + 1, t[2] + 1]);\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto a = nums1.sort!((a, b) => a > b);\n\tauto b = nums2.sort!((a, b) => a > b);\n\tauto c = new long[](N);\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tc[i] = a[i] * b[i];\n\t}\n\t\n\treturn c;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.sort!((a, b) => a > b);\n\tauto nums2_sorted = nums2.sort!((a, b) => a > b);\n\t\n\tauto nums1_sorted_set = nums1_sorted.toSet();\n\tauto nums2_sorted_set = nums2_sorted.toSet();\n\t\n\tauto nums1_sorted_set_sorted = nums1_sorted_set.sort!((a, b) => a > b);\n\tauto nums2_sorted_set_sorted = nums2_sorted_set.sort!((a, b) => a > b);\n\t\n\tauto nums1_sorted_set_sorted_arr = nums1_sorted_set_sorted.array;\n\tauto nums2_sorted_set_sorted_arr = nums2_sorted_set_sorted.array;\n\t\n\tauto nums1_sorted_set_sorted_arr_len = nums1_sorted_set_sorted_arr.length;\n\tauto nums2_sorted_set_sorted_arr_len = nums2_sorted_set_sorted_arr.length;\n\t\n\tauto nums1_sorted_set_sorted_arr_len_minus_1 = nums1_sorted_set_sorted_arr_len - 1;\n\tauto nums2_sorted_set_sorted_arr_len_minus_1 = nums2_sorted_set_sorted_arr_len - 1;\n\t\n\tauto nums1_sorted_set_sorted_arr_len_minus_1_index = nums1_sorted_set_sorted_arr_len_minus_1;\n\tauto nums2_sorted_set_sorted_arr_len_minus_1_index = nums2_sorted_set_sorted_arr_len_minus_1;\n\t\n\tauto nums1_sorted_set_sorted_arr_len_minus_1_index"
  ]
}