{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\n*/\nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = max_sub_array_sum_repeated;\n\n    assert(candidate([10L, 20L, -30L, -1L], 4L, 3L) == 30L);\n    assert(candidate([-1L, 10L, 20L], 3L, 2L) == 59L);\n    assert(candidate([-1L, -2L, -3L], 3L, 3L) == -1L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n        sum += a[i]; \n    } \n  \n    if (sum < 0) \n        return max(max_sum, min_sum + sum * (k - 2)); \n  \n    return max(max_sum, sum * k - min_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i = 0; \n    long j = 0; \n    long m = n * k; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    // Maintain a window of size n \n    for (i = 1; i < k; i++) { \n        curr_sum = 0; \n        for (j = 0; j < n; j++) { \n            curr_sum += a[(i * n + j) % m]; \n        } \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    max_sum = curr_sum; \n  \n    // Compute sums of remaining windows by removing first element \n    // of previous window and adding last element of current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, min_sum + total * (k - 2)); \n  \n    return max(max_sum, total * k - min_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long max_prefix_sum = 0; \n    long max_suffix_sum = 0; \n    long total_sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        total_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n  \n        curr_prefix_sum += a[i]; \n        max_prefix_sum = max(max_prefix_sum, curr_prefix_sum); \n        if (curr_prefix_sum < 0) \n            curr_prefix_sum = 0; \n  \n        curr_suffix_sum += a[n - i - 1]; \n        max_suffix_sum = max(max_suffix_sum, curr_suffix_sum); \n        if (curr_suffix_sum < 0) \n            curr_suffix_sum = 0; \n    } \n  \n    if (total_sum < 0) \n        return max(max_sum, max_prefix_sum + max_suffix_sum); \n  \n    return max(max_sum, max_prefix_sum + max_suffix_sum + (total_sum * (k - 2))); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n    long i = 0; \n  \n    for (i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size k \n    for (i = 0; i < k; i++) \n        curr_sum += a[i]; \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    for (i = k; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - k) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    max_sum = max(max_sum, curr_sum); \n    long ans = (max_sum * k) % 1000000007; \n    return ans; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_sum == 0) \n        return max_elem; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    long ans = max(max_sum, sum * k); \n    long prefix_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        prefix_sum += a[i]; \n        curr_sum = prefix_sum; \n        for (long j = i + n; j < n * k; j += n) \n        { \n            curr_sum += sum; \n            curr_sum -= a[j % n]; \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n    return max(ans, max_sum); \n}",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum(a, n); \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    long max_val = max_sum; \n    for (long i = 0; i < n; i++) { \n        max_sum = max_sum + (k - 1) * a[i]; \n        max_val = max(max_val, max_sum); \n        max_sum = max_sum - (k - 1) * a[i]; \n    } \n  \n    return max_val; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, min_sum + total * (k - 2)); \n  \n    return max(max_sum, total * k - min_sum); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long current_sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            current_sum += a[j]; \n            if (current_sum > max_sum) \n                max_sum = current_sum; \n        } \n    } \n    return max_sum * k; \n} \nlong max_sub_array_sum_repeated_efficient(long[] a, long n, long k) \n{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    max_sum = max_sum + max_wrap; \n    if (max_sum > 0) \n        return max_sum * k; \n    else\n        return max_sum; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    // Case 1: get the maximum sum using standard kadane's \n    // algorithm \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) { \n            max_sum = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 2: Now find the maximum sum that is possible by \n    // modifying array. \n    max_so_far = max_sum; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        max_ending_here = max_ending_here - a[start]; \n        if (max_ending_here > max_so_far) \n            max_so_far = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n  \n    // Case 3: Maximum Sum is possible with Corner Elements. \n    long corner_sum = 0; \n    for (long i = 0; i < n; i++) \n        corner_sum += a[i]; \n    corner_sum = corner_sum * (k - 2); \n  \n    // The maximum circular sum will be maximum of two sums \n    // obtained by two cases. \n    return max(max_so_far, corner_sum + max_sum); \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        long next_val = curr_val - (sum - a[i - 1]) +  \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} \n  \n// Driver code ",
    "{ \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    long max_sum = sum; \n    for (long p = 1; p < k; p++) { \n        for (long i = 0; i < n; i++) { \n            sum = sum - a[i] + a[(i + 1) % n]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i >= k - 1) { \n            max_sum = max(max_sum, curr_sum); \n            curr_sum -= sum; \n        } \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum * k); \n    return max_sum; \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} \nlong max_sub_array_sum_repeated_2(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    if (max_sum < 0) \n        return max_sum; \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    sum = sum * (k - 2); \n    for (long i = 0; i < n; i++) \n        a[i] = -a[i];",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i, j; \n  \n    // Find maximum sum subarray in first window of size k \n    for (i = 0; i < k; i++) \n        max_sum += a[i]; \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    curr_sum = max_sum; \n    for (i = k; i < n * k; i++) { \n        curr_sum += a[i % n] - a[(i - k) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long currsum = 0; \n    for (long i = 0; i < n; i++) \n        currsum += i * a[i]; \n  \n    // Initialize result \n    long res = currsum; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        // arr[i%n] = arr[i%n] * (n-i) \n        long nextsum = currsum - (sum - a[i - 1]) +  \n                       a[i - 1] * (n - 1); \n  \n        // Update current sum and result \n        currsum = nextsum; \n        res = max(res, nextsum); \n    } \n  \n    return res; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long i = 0; \n    long j = 0; \n    long sum = 0; \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n    max_sum = sum; \n    for (i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    if (k == 1) \n        return max_sum; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    for (i = 0; i < n; i++) { \n        min_ending_here += a[i]; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        if (min_sum > min_ending_here) \n            min_sum = min_ending_here; \n    } \n    long max_wrap = 0; \n    if (min_sum < 0) \n        max_wrap = sum - min_sum; \n    long ans = max(max_sum, max_wrap); \n    ans = max(ans, max_wrap + max_sum * (k - 2)); \n    return ans; \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    return max_sum; \n} \nlong max_sub_array_sum_repeated_k_times(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    if (k == 1) \n        return max_sum; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    sum = sum + max_sub_array_sum_repeated(a, n, k - 1); ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        // arr[i%n] = arr[i%n] * (n-i) \n        curr_val = curr_val + sum - n * a[n - i]; \n        res = max(res, curr_val); \n    } \n  \n    return res; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    else\n        return max_sum; \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} \nlong max_sub_array_sum_repeated_2(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    if (k == 1) \n        return max_sum; \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_prefix_sum += a[i]; \n        curr_suffix_sum += a[n - i - 1]; ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n    for (long i = 0; i < n * k; i++) \n    { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) \n        { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) \n        { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    long j; \n  \n    // Iterate through first k elements \n    // and find the sum \n    for (i = 0; i < k; i++) \n        max_sum += a[i]; \n  \n    // Store the sum of first k elements \n    curr_sum = max_sum; \n  \n    // Iterate through remaining elements \n    // and add current element to curr_sum \n    // and update max_sum if required \n    for (i = k; i < n * k; i++) { \n  \n        // Add current element to curr_sum \n        curr_sum += a[i % n] - a[(i - k) % n]; \n  \n        // Update max_sum if required \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_sum) \n            max_sum = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_wrap) \n            max_wrap = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n    if (k == 1) \n        return max_wrap; \n    long max_non_wrap = max_wrap; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_non_wrap) \n            max_non_wrap = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n    return max(max_non_wrap, max_wrap + (k - 2) * max_wrap); \n} \nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_sum) \n            max_sum = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    // Compute sums of remaining windows by removing first element of previous \n    // window and adding last element of current window. \n    max_sum = max(max_sum, curr_sum); \n  \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of middle n elements \n    // i.e. sum of elements from index \n    // n/2 to n-1 in original array \n    long mid_sum = 0; \n    for (long i = n / 2; i < n; i++) \n        mid_sum += a[i]; \n  \n    // Initialize result \n    long max_sum = mid_sum; \n  \n    // Consider all rotations one by one \n    for (long i = 1; i <= n / 2; i++) { \n        // Current rotation sum \n        long curr_sum = mid_sum; \n  \n        // Update current rotation sum by removing \n        // a[i-1] from current rotation and adding \n        // a[n-i] to it \n        curr_sum += sum - n * a[n - i]; \n  \n        // Update result if required \n        max_sum = max(max_sum, curr_sum); \n  \n        // Update current rotation sum by removing \n        // a[n-i] from current rotation and adding \n        // a[i-1] to it \n        curr_sum -= sum - n * a[i - 1]; \n  \n        // Update result if required \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    // Return result for k rotations \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, min_sum + total * (k - 2)); \n  \n    return max(max_sum, total * k - min_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n    long i; \n    for (i = 0; i < n * k; i++) \n    { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) \n        { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) \n        { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long max_elem = *max_element(a, a + n); \n  \n    // If all elements are negative \n    if (max_elem < 0) \n        return max_elem; \n  \n    // Find sum of array \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // If all elements are positive \n    if (sum > 0) \n        return sum * k; \n  \n    // If there is only one element \n    if (n == 1) \n        return a[0] * k; \n  \n    // Find maximum subarray sum for array \n    // [0..n-1] \n    for (long i = 0; i < n; i++) { \n        sum = max(a[i], sum + a[i]); \n        max_sum = max(max_sum, sum); \n    } \n  \n    // Find maximum subarray sum for array \n    // [n..2n-1] \n    sum = 0; \n    for (long i = n; i < 2 * n; i++) { \n        sum = max(a[i % n], sum + a[i % n]); \n        max_sum = max(max_sum, sum); \n    } \n  \n    // Find maximum subarray sum for array \n    // [2n..3n-1] \n    sum = 0; \n    for (long i = 2 * n; i < 3 * n; i++) { \n        sum = max(a[i % n], sum + a[i % n]); \n        max_sum = max(max_sum, sum); \n    } \n  \n    // Find maximum subarray sum for array \n    // [3n..4n-1] \n    sum = 0; \n    for (long i = 3 * n; i < 4 * n; i++) { \n        sum = max(a[i % n], sum + a[i % n]); \n        max_sum = max",
    "{ \n    // Find sum of all elements of array. \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        else if (curr_sum > max_sum) \n            max_sum = curr_sum; \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum > max_wrap) \n            max_wrap = curr_sum; \n    } \n  \n    long max_single = 0; \n    for (i = 0; i < n; i++) \n    { \n        max_single = max(max_single, a[i]); \n    } \n  \n    if (max_single < 0) \n        return max_single; \n  \n    return max(max_wrap * k, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, min_sum + total * (k - 2)); \n  \n    return max(max_sum, total * k - min_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    // Maintain maximum sum \n    max_sum = max(max_sum, curr_sum); \n  \n    // Compute sums of remaining windows by removing \n    // elements in the beginning of first window and \n    // adding elements at the end of the current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, min_sum + total * (k - 2)); \n  \n    return max(max_sum, total * k - min_sum); \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 2 \n    max_ending_here = 0; \n    s = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here > max_sum) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 3 \n    max_sum = max_sum + (k - 2) * max_so_far; \n  \n    // Case 4 \n    long total_sum = 0; \n    for (long i = 0; i < n; i++) \n        total_sum = total_sum + a[i]; \n  \n    max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_so_far = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        min_ending_here = min_ending_here + a[i]; \n        if (max_ending_here >",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    // Maintain maximum sum \n    max_sum = max(max_sum, curr_sum); \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = 0; \n    long i = 0; \n  \n    for (i = 0; i < n; i++) { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n  \n        if (curr_sum < 0) \n            curr_sum = 0; \n  \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    if (max_sum == 0) \n        return max_elem; \n  \n    long sum = 0; \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    long ans = max(max_sum, sum * k); \n  \n    long curr_prefix = 0, curr_suffix = 0; \n    for (i = 0; i < n; i++) { \n        curr_prefix += a[i]; \n        curr_suffix += a[n - i - 1]; \n  \n        max_sum = max(max_sum, curr_prefix); \n        max_sum = max(max_sum, curr_suffix); \n  \n        curr_prefix = max(curr_prefix, 0); \n        curr_suffix = max(curr_suffix, 0); \n    } \n  \n    return max(ans, max_sum + (k - 2) * sum); \n}",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_sum) \n            max_sum = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_wrap) \n            max_wrap = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    if (k == 1) \n        return max_wrap; \n  \n    long max_now = max_wrap; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        curr_sum = curr_sum - (max_wrap - max_now); \n        if (curr_sum > max_now) \n            max_now = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    return max(max_now, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n  \n    // Do for remaining windows by removing first element of previous window and adding last element of current window. \n    long curr_max = max_sum; \n    for (long i = n; i < n * k; i++) { \n        curr_max = curr_max + a[i % n]; \n        max_ending_here = max_ending_here + a[i % n]; \n        if (max_ending_here > curr_max) \n            curr_max = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < curr_max) \n            max_sum = curr_max; \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    long max_val = max_sum; \n    for (long i = 0; i < n; i++) { \n        max_sum = max_sum + (k - 1) * a[i]; \n        max_val = max(max_val, max_sum); \n        max_sum = max_sum - (k - 1) * a[i]; \n    } \n  \n    return max_val; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long sum_of_all_elements = curr_sum; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += sum_of_all_elements; \n        curr_sum -= a[i]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    // Finding sum of the original array. \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Finding sum of the modified array. \n    for (long i = 0; i < n * k; i++) { \n        curr_sum += a[i % n]; \n        max_sum = max(max_sum, curr_sum); \n        curr_sum = max(curr_sum, 0); \n    } \n  \n    // Finding maximum sum of the circular subarray. \n    for (long i = 1; i < n; i++) { \n        curr_sum = 0; \n        for (long j = i; j < i + n * k; j++) { \n            curr_sum += a[j % n]; \n            max_sum = max(max_sum, curr_sum); \n            curr_sum = max(curr_sum, 0); \n        } \n    } \n  \n    // Adding the sum of the original array to the \n    // maximum sum of the circular subarray. \n    return max_sum + (k - 2) * sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != 0) \n            curr_sum = max(curr_sum, curr_sum + sum * (k - 1)); \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum_arr = 0; \n    long i = 0; \n    long j = 0; \n  \n    for (i = 0; i < n; i++) { \n        sum_arr += a[i]; \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    if (k == 1) \n        return max_sum; \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    max_wrap = max_wrap + curr_sum; \n  \n    if (k == 2) \n        return max(max_sum, max_wrap); \n  \n    return max(max_sum, (max_wrap + (k - 2) * sum_arr)); \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n  \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long max_prefix_sum = 0; \n    long max_suffix_sum = 0; \n    long total_sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total_sum += a[i]; \n        curr_sum += a[i]; \n        curr_prefix_sum += a[i]; \n        curr_suffix_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_prefix_sum < 0) \n            curr_prefix_sum = 0; \n        if (curr_suffix_sum < 0) \n            curr_suffix_sum = 0; \n        max_prefix_sum = max(max_prefix_sum, curr_prefix_sum); \n        max_suffix_sum = max(max_suffix_sum, curr_suffix_sum); \n    } \n  \n    if (k == 1) \n        return max_sum; \n  \n    long max_val = max_prefix_sum + max_suffix_sum; \n    max_val = max(max_val, max_prefix_sum + total_sum * (k - 2) + max_suffix_sum); \n    max_val = max(max_val, max_sum); \n    return max_val; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n  \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    else\n        return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2 \n    if (k > 1) { \n  \n        // Build the prefix sum array \n        long[] prefix_sum = new long[n]; \n        prefix_sum[0] = a[0]; \n        for (long i = 1; i < n; i++) \n            prefix_sum[i] = prefix_sum[i - 1] + a[i]; \n  \n        // Case 2a \n        long total_sum = prefix_sum[n - 1]; \n        max_ending_here = 0; \n        for (long i = 0; i < n; i++) { \n            long val = prefix_sum[i] + (k - 2) * total_sum; \n            if (i > 0) \n                val -= prefix_sum[i - 1]; \n            max_ending_here = max(max_ending_here + a[i], val); \n            max_sum = max(max_sum, max_ending_here); \n        } \n  \n        // Case 2b \n        max_ending_here = 0; \n        for (long i = n - 1; i >= 0; i--) { \n            long val = (prefix_sum[n - 1] - prefix_sum[i])",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n  \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum * k); \n    else\n        return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2 \n    if (k > 1) { \n        // Compute sum of middle k-2 entries \n        // in the array after ignoring \n        // the first and last entries \n        long sum = 0; \n        for (long i = 1; i < n - 1; i++) \n            sum += a[i]; \n  \n        // Case 2a \n        max_sum = max(max_sum, sum); \n  \n        // Case 2b \n        sum = 0; \n        for (long i = 0; i < n; i++) { \n            sum += a[i]; \n            max_sum = max(max_sum, sum); \n            if (sum < 0) \n                sum = 0; \n        } \n    } \n  \n    // Case 3 \n    // Compute sum of maximum subarray sum \n    // starting from first entry \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    // Case 4 \n    // Compute sum of",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n    long max_len = 0; \n    long curr_len = 0; \n    long len = 0; \n  \n    // Finding sum of original array. \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Finding sum of subarray with length 1 \n    // and maximum sum of subarray with length \n    // 1. \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        curr_len++; \n  \n        if (curr_sum > max_sum) { \n            max_sum = curr_sum; \n            max_len = curr_len; \n        } \n    } \n  \n    // Finding maximum sum of subarray with length \n    // greater than 1. \n    for (i = 1; i < n; i++) { \n        curr_sum = 0; \n        curr_len = 0; \n  \n        for (j = i; j < n; j++) { \n            curr_sum += a[j]; \n            curr_len++; \n  \n            if (curr_sum > max_sum) { \n                max_sum = curr_sum; \n                max_len = curr_len; \n            } \n        } \n    } \n  \n    // Finding maximum sum of subarray which is \n    // repeated. \n    for (i = 0; i < n; i++) { \n        curr_sum = 0; \n        curr_len = 0; \n  \n        for (j = i; j < n; j++) { \n            curr_sum += a[j]; \n            curr_len++; \n  \n            if (curr_sum == sum && curr_len > len) { \n                len = curr_len; \n            } \n        }",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_ending_here = max(max_ending_here, 0); \n        min_ending_here = min(min_ending_here, 0); \n        max_sum = max(max_sum, max_ending_here); \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (k == 1) \n        return max_sum; \n  \n    long ans1 = max_sum + (k - 2) * total; \n    long ans2 = max_sum + (k - 2) * total; \n    if (total > 0) \n        ans1 = max_sum + (k - 2) * total; \n    if (total < 0) \n        ans2 = max_sum + (k - 2) * total; \n  \n    return max(ans1, ans2); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n    for (long i = 0; i < n * k; i++) \n    { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) \n        { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) \n        { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != 0) \n            curr_sum = max(curr_sum, curr_sum + sum * (k - 1)); \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} \n  \n// Driver code ",
    "{ \n    // Find sum of all elements of array \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        // arr[i%n] = arr[i%n] + (n-i)*arr[i-1]; \n        long next_val = curr_val - sum + a[i - 1] * n; \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    if (k == 1) \n        return max_sum; \n    long max_val = 0, min_val = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_val = max_val + a[i]; \n        min_val = min_val + a[i]; \n        if (max_val < a[i]) \n            max_val = a[i]; \n        if (min_val > a[i]) \n            min_val = a[i]; \n    } \n    long max_wrap = 0; \n    if (min_val < 0) \n        max_wrap = min_val * (k - 2) + max_val; \n    else\n        max_wrap = max_val * k; \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    for (int i = 0; i < n; i++) \n    { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_sum == 0) \n        return max_elem; \n    long sum = 0; \n    for (int i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    long curr_min_sum = 0; \n    long min_sum = 0; \n    for (int i = 0; i < n; i++) \n    { \n        curr_min_sum += a[i]; \n        min_sum = min(min_sum, curr_min_sum); \n    } \n    long ans1 = max_sum; \n    long ans2 = sum * (k - 2) + max_sum; \n    long ans3 = sum * (k - 2) - min_sum; \n    return max(ans1, max(ans2, ans3)); \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        long next_val = curr_val - (sum - a[i - 1]) +  \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n    long max_val = 0; \n    long min_val = 0; \n  \n    for (i = 0; i < n; i++) { \n        max_val = max(max_val, a[i]); \n        min_val = min(min_val, a[i]); \n        sum += a[i]; \n    } \n  \n    if (k == 1) \n        return sum; \n  \n    if (max_val <= 0) \n        return max_val * k; \n  \n    if (min_val >= 0) \n        return sum * k; \n  \n    while (j < n) { \n        sum = 0; \n        while (j < n && sum + a[j] >= 0) { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n            j++; \n        } \n        j++; \n    } \n  \n    long ans = max_sum * k; \n    long prefix_sum = 0; \n    long suffix_sum = 0; \n    long total_sum = 0; \n  \n    for (i = 0; i < n; i++) { \n        prefix_sum += a[i]; \n        total_sum += a[i]; \n        if (prefix_sum < 0) \n            prefix_sum = 0; \n    } \n  \n    for (i = n - 1; i >= 0; i--) { \n        suffix_sum += a[i]; \n        total_sum += a[i]; \n        if (suffix_sum > 0) \n            suffix_sum = 0; \n    } \n  \n    long temp = max(prefix_sum, suffix_sum); \n  \n    ans = max(ans, total_sum * (k - 2) + temp); \n  \n    return ans; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != 0) \n            curr_sum = curr_sum + sum * (k - 1); \n  \n        max_sum = max(max_sum, curr_sum); \n  \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (k == 1) \n        return max_sum; \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_repeated(a, n, 1); \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    sum = sum * (k - 2); \n    return max(max_sum, sum + max_sub_array_sum_repeated(a, n, 1)); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    // Finding sum of original array. \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Finding sum of subarray \n    // formed by repeating array \n    // k times \n    for (long i = 0; i < n * k; i++) { \n        curr_sum += a[i % n]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    // If sum of all elements is \n    // negative \n    if (max_sum == 0) \n        max_sum = sum; \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long max_wrap_sum = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    max_sum = max(max_sum, max_wrap_sum); \n  \n    if (max_sum > max_so_far) \n        return max_sum; \n    else\n        return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_ending_here = max(max_ending_here, 0); \n        min_ending_here = min(min_ending_here, 0); \n        max_sum = max(max_sum, max_ending_here); \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (k == 1) \n        return max_sum; \n  \n    long max_wrap = total - min_sum; \n  \n    return max(max_wrap, max_sum + (k - 2) * total); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    if (k == 1) \n        return max_sum; \n    long max_val = 0, min_val = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_val = max_val + a[i]; \n        min_val = min_val + a[i]; \n        if (max_val < a[i]) \n            max_val = a[i]; \n        if (min_val > a[i]) \n            min_val = a[i]; \n    } \n    long max_wrap = 0; \n    if (min_val < 0) \n    { \n        max_wrap = max_wrap + min_val * (k - 2); \n    } \n    max_wrap = max_wrap + max_val; \n    return max(max_sum, max_wrap); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_element = a[0]; \n    for (long i = 0; i < n; i++) { \n        max_element = max(max_element, a[i]); \n    } \n    if (max_element <= 0) \n        return max_element * k; \n    for (long i = 0; i < n * k; i++) { \n        curr_sum += a[i % n]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long max_element = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        if (a[i] > max_element) \n            max_element = a[i]; \n        sum += a[i]; \n        if (sum < 0) \n            sum = 0; \n        else if (sum > max_sum) \n            max_sum = sum; \n    } \n    if (max_sum == 0) \n        max_sum = max_element; \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum * k); \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    return max_sub_array_sum_repeated(a, n, 1); \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        // arr[i%n] = arr[i%n] * (n-i) \n        curr_val = curr_val + sum - n * a[n - i]; \n        res = max(res, curr_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        max_wrap = max(max_wrap, sum); \n    } \n  \n    max_wrap = max(max_wrap, sum + max_wrap); \n  \n    return max(max_wrap, max_sum * k); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long max_wrap_sum = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    max_wrap_sum = 0; \n    for (long i = n - 1; i >= 0; i--) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    return max(max_sum, max_so_far); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long i = 0; \n    long j = 0; \n    long sum = 0; \n    long max_so_far = 0; \n    long max_val = 0; \n    long max_index = 0; \n  \n    for (i = 0; i < n; i++) { \n        max_so_far += a[i]; \n        if (max_val < a[i]) { \n            max_val = a[i]; \n            max_index = i; \n        } \n    } \n  \n    if (k == 1) \n        return max_so_far; \n  \n    if (max_so_far < 0) \n        return max_val; \n  \n    max_sum = max_so_far; \n  \n    for (i = 1; i < k; i++) { \n        sum = 0; \n        max_ending_here = 0; \n        for (j = 0; j < n; j++) { \n            sum += a[j]; \n            max_ending_here = max(sum, max_ending_here + a[j]); \n            max_sum = max(max_sum, max_ending_here); \n        } \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    // Finding sum of all elements \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Finding sum of first subarray \n    for (long i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    max_sum = curr_sum; \n  \n    // Finding sum of remaining subarrays \n    for (long i = 1; i < k; i++) { \n  \n        // Finding sum of next subarray \n        // Remove elements of previous subarray \n        // Add elements of new subarray \n        curr_sum = curr_sum - (sum - curr_sum); \n  \n        // Update maximum sum \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    long j; \n    long m = n * k; \n  \n    // Iterate through first k subarrays and find \n    // the maximum sum of all subarrays \n    for (i = 0; i < k; i++) { \n        curr_sum = 0; \n        for (j = 0; j < n; j++) { \n            curr_sum += a[j]; \n            if (curr_sum < 0) \n                curr_sum = 0; \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n  \n    // Iterate through remaining subarrays and find \n    // the maximum sum of all subarrays \n    for (i = 1; i < k; i++) { \n        curr_sum = 0; \n        for (j = 0; j < n; j++) { \n            curr_sum += a[j]; \n            if (curr_sum < 0) \n                curr_sum = 0; \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    max_wrap = max_wrap + curr_sum; \n  \n    return max(max_sum, max_wrap * (k - 2)); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    long max_wrap_ending_here = 0; \n    for (i = 0; i < n; i++) \n    { \n        max_wrap_ending_here += a[i]; \n        if (max_wrap < max_wrap_ending_here) \n            max_wrap = max_wrap_ending_here; \n        if (max_wrap_ending_here > 0) \n            max_wrap_ending_here = 0; \n    } \n    max_wrap = max_wrap + max_wrap; \n    if (k == 1) \n        return max(max_wrap, max_sum); \n    else\n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    // Find the max sum subarray in first window of size n \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        // If size of the current window is greater, update max_so_far \n        if (i == n - 1) { \n            max_so_far = max(max_so_far, max_ending_here); \n            max_ending_here = 0; \n            i = -1; \n        } \n    } \n  \n    // Store the maximum result of first window \n    max_sum = max_so_far; \n  \n    // Consider remaining windows by shifting current window \n    // by one position towards right \n    for (int i = 1; i < k; i++) { \n        max_ending_here = 0; \n        for (int j = 0; j < n; j++) { \n            max_ending_here += a[j]; \n            max_so_far = max(max_so_far, max_ending_here); \n            max_ending_here = max(max_ending_here, 0); \n        } \n        max_sum += max_so_far; \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i >= start; i--) { \n        sum = sum + a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum(a, n); \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    else\n        return max_sum; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n    long i = 0; \n  \n    for (i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix = 0; \n    long curr_suffix = 0; \n  \n    // Find the maximum sum subarray in first \n    // k elements of the given array \n    for (long i = 0; i < k; i++) { \n        curr_sum = 0; \n        for (long j = 0; j < n; j++) { \n            curr_sum += a[j]; \n            max_sum = max(max_sum, curr_sum); \n            curr_sum = max(curr_sum, 0); \n        } \n    } \n  \n    // Find the maximum prefix sum of the array \n    // and minimum suffix sum of the array \n    curr_prefix = 0; \n    curr_suffix = 0; \n    long min_suffix_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_prefix += a[i]; \n        max_sum = max(max_sum, curr_prefix); \n        curr_suffix += a[i]; \n        min_suffix_sum = min(min_suffix_sum, curr_suffix); \n    } \n  \n    // Case when all elements of the array are \n    // negative \n    if (curr_prefix == min_suffix_sum) \n        return max_sum; \n  \n    // Find the maximum sum by excluding the \n    // maximum prefix sum and minimum suffix \n    // sum of the array \n    return max(max_sum, (curr_prefix - min_suffix_sum) * (k - 2) + curr_prefix); \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    max_wrap = max_wrap + sum; \n  \n    if (k == 2) \n        return max(max_wrap, max_sum); \n  \n    return max(max_wrap + (k - 2) * max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    // Maintain maximum sum subarray found so far \n    max_sum = max(max_sum, curr_sum); \n  \n    // Compute sums of remaining windows by removing first \n    // element of previous window and adding last element \n    // of current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    max_sum = max(max_sum, max_wrap * (k - 2)); \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long total_sum = 0; \n  \n    // Find the sum of the original array \n    for (long i = 0; i < n; i++) { \n        total_sum += a[i]; \n        max_sum = max(max_sum, a[i]); \n    } \n  \n    // Find the maximum prefix sum \n    for (long i = 0; i < n; i++) { \n        curr_prefix_sum += a[i]; \n        max_sum = max(max_sum, curr_prefix_sum); \n    } \n  \n    // Find the maximum suffix sum \n    for (long i = n - 1; i >= 0; i--) { \n        curr_suffix_sum += a[i]; \n        max_sum = max(max_sum, curr_suffix_sum); \n    } \n  \n    // Find the sum of the middle part \n    // across the k arrays \n    curr_sum = curr_prefix_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        curr_prefix_sum = max(curr_prefix_sum, curr_sum); \n        max_sum = max(max_sum, curr_prefix_sum + \n                      (curr_suffix_sum - a[i]) * (k - 2)); \n    } \n  \n    // Handle the case when all elements \n    // are negative \n    if (max_sum < 0) \n        return max_sum; \n  \n    // Maximum sum is sum of all elements \n    // of the original array multiplied by k \n    // if all elements are positive \n    return max(max_sum, total_sum * k); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        max_wrap = max(max_wrap, 0); \n    } \n  \n    max_wrap = max(max_wrap, 0); \n  \n    return max(max_sum, (max_wrap * (k - 2)) + sum); \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_repeated(a, n, 1); \n    long min_sum = min_element(a); \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_sum, max_wrap); \n} \nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n  \n    // Find the sum of first subarray \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Initialize result \n    max_sum = sum; \n  \n    // Find sum of remaining subarrays \n    // and update max_sum. \n    for (long i = 1; i < k; i++) { \n  \n        // Compute sum of next subarray and \n        // update max_sum if needed \n        sum = 0; \n        for (long j = 0; j < n; j++) \n            sum += a[j]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long max_wrap_sum = 0; \n    long max_wrap_ending_here = 0; \n    long max_wrap_so_far = 0; \n    long wrap_start = 0; \n    long wrap_end = 0; \n    long ws = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_wrap_ending_here += a[i]; \n  \n        if (max_wrap_so_far < max_wrap_ending_here) { \n            max_wrap_so_far = max_wrap_ending_here; \n            wrap_start = ws; \n            wrap_end = i; \n        } \n  \n        if (max_wrap_ending_here < 0) { \n            max_wrap_ending_here = 0; \n            ws = i + 1; \n        } \n    } \n  \n    max_wrap_sum = max_wrap_so_far; \n  \n    if (wrap_start <= end && wrap_end >= start) { \n        max_sum = max(max_so_far, max_wrap_so_far); \n    } \n  \n    else { \n        max_sum = max(max_so_far, max_wrap_so_far + (max_",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != 0) \n            curr_sum = curr_sum + sum * (k - 1); \n  \n        max_sum = max(max_sum, curr_sum); \n  \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Find the max sum subarray in first window of size k \n    for (int i = 0; i < k; i++) \n        max_sum += a[i]; \n  \n    max_ending_here = max_sum; \n  \n    // Compute sums of remaining windows by removing first \n    // element of previous window and adding last element \n    // of current window. \n    for (int i = k; i < n * k; i++) { \n        max_ending_here += a[i % n] - a[(i - k) % n]; \n        if (max_ending_here > max_sum) { \n            max_sum = max_ending_here; \n            start = (i - k + 1) % n; \n            end = i % n; \n        } \n    } \n  \n    // Uncomment below lines to print resulting subarray \n    /*cout << \"( \"; \n    for (int i = start; i != end; i = (i + 1) % n) \n        cout << a[i] << \", \"; \n    cout << a[end]; \n    cout << \")\"; */\n  \n    // Return sum of max sum subarray. \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i = 0; \n    long j = 0; \n    long m = n * k; \n  \n    // Iterate over the array \n    for (i = 0; i < m; i++) { \n  \n        // Reset the current sum \n        curr_sum = 0; \n  \n        // Iterate over the subarray \n        for (j = i; j < m; j += n) { \n  \n            // Update the current sum \n            curr_sum += a[j % n]; \n  \n            // Update the maximum sum \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2 \n    if (k > 1) { \n        // Compute sum of middle k-2 sequences \n        long sum = 0; \n        for (long i = start; i <= end; i++) \n            sum += a[i]; \n  \n        // Case 2a \n        if (sum > 0) \n            max_sum += (k - 2) * sum; \n  \n        // Case 2b \n        else { \n            // Compute maximum sum of subarray that \n            // has start element of previous subarray \n            // and end element of next subarray \n            long max_ending_here = 0; \n            long max_so_far = 0; \n            for (long i = 0; i < n; i++) { \n                max_ending_here += a[i]; \n                if (max_so_far < max_ending_here) \n                    max_so_far = max_ending_here; \n                if (max_ending_here < 0) \n                    max_ending_here = 0; \n            } \n  \n            max_sum = max(max_sum, max_so_far + max_sum - sum); \n        } \n    } \n  \n    return max_",
    "{ \n    long max_sum = 0; \n  \n    // Find sum of all subarrays and store in max_sum \n    for (long i = 0; i < n; i++) { \n        long sum = 0; \n        for (long j = i; j < n; j++) { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    // Multiply max_sum with k and return \n    // result \n    return max_sum * k; \n} \n  \n// Driver code ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n  \n    // Find the sum of the first window of size n \n    for (long i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Compute sums of remaining windows by  \n    // removing first element of previous  \n    // window and adding last element of  \n    // current window. \n    for (long i = n; i < n * k; i++) { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n    } \n  \n    long max_wrap = sum * k; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (sum > max_wrap) \n            max_wrap = sum; \n    } \n  \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long[] sum = new long[n]; \n    long[] sum_index = new long[n]; \n  \n    // Finding sum of first window of size n \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        sum[i] = curr_sum; \n        sum_index[i] = i; \n    } \n  \n    // Finding sum of remaining windows by \n    // removing first element of previous \n    // window and adding last element of \n    // current window. \n    for (long i = n; i < n * k; i++) { \n        curr_sum += a[i % n]; \n        curr_sum -= a[(i - n) % n]; \n  \n        // If current sum is more than maximum sum, \n        // then update it \n        if (curr_sum > sum[i % n]) { \n            sum[i % n] = curr_sum; \n            sum_index[i % n] = i; \n        } \n    } \n  \n    // Finding maximum sum and it's index \n    for (long i = 0; i < n; i++) { \n        if (sum[i] > max_sum) { \n            max_sum = sum[i]; \n        } \n    } \n  \n    return max_sum; \n} \n  \n// Driver code \npublic static void main(String[] args) \n{ \n    long[] a = { 1, 2, 3 }; \n    long n = a.length; \n    long k = 3; \n  \n    System.out.println(max_sub_array_sum_repeated(a, n, k)); \n} \nmain(args);",
    "{ \n    // k times sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    sum *= k; \n  \n    // Case 1: get the maximum sum using standard kadane' \n    // s algorithm \n    long max_sum = kadane(a, n); \n  \n    // Case 2: Now find the maximum sum that includes \n    // corner elements. \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    // max sum with corner elements will be: \n    // array-sum - (-max subarray sum of inverted array) \n    max_wrap = max_wrap + kadane(a, n); \n  \n    // The maximum circular sum will be maximum of two sums \n    return max(max_wrap, max_sum); \n} \n  \n// Standard Kadane's algorithm to find maximum subarray sum \n// See https://www.geeksforgeeks.org/archives/576 for details \nlong kadane(long[] a, long n) \n{ \n    long max_so_far = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_so_far < max_ending_here) \n            max_so_far = max_ending_here; \n    } \n    return max_so_far; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = *max_element(a, a + n); \n  \n    if (max_elem <= 0) \n        return max_elem * k; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    max_sum = max(max_sum, max_wrap * (k - 2) + curr_sum); \n  \n    return max_sum; \n}",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    for (long i = 0; i < n; i++) { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_sum == 0) \n        return max_elem; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    long ans = max(max_sum, sum * k); \n    long prefix = 0; \n    for (long i = 0; i < n; i++) { \n        prefix += a[i]; \n        long suffix = sum * (k - 1) - prefix; \n        ans = max(ans, prefix + suffix); \n    } \n    return ans; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    if (k == 1) \n        return max_sum; \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n  \n    return max(max_wrap, max_sum); \n} \n  \nlong max_sub_array_sum(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_repeated(a, n, 1); \n  \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    sum = (sum * (k - 2)) + max_sub_array_sum_repeated(a, n, 1); \n  \n    return max(max_sum, sum); \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) { \n        long sum = 0; \n        for (long j = i; j < n; j++) { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n    return max_sum * k; \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_so_far = a[0]; \n    long curr_max = a[0]; \n    for (long i = 1; i < n; i++) { \n        curr_max = max(a[i], curr_max + a[i]); \n        max_so_far = max(max_so_far, curr_max); \n    } \n    return max_so_far; \n} \nlong max_sub_array_sum_repeated_efficient(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    sum = sum * (k - 2); \n    sum += max_sub_array_sum(a, n); \n    return max(max_sum, sum); \n} \nlong max_sub_array_sum_repeated_efficient_2(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    sum = sum * (k - 2); \n    sum += max_sub_array_sum(a, n); \n    return max(",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_repeated(a, n, 1); \n    long min_sum = min_element(a); \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_sum, max_wrap); \n} \nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    }",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    sum = (sum * k) + max_sub_array_sum(a, n); \n    return max(max_sum, sum); \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n    long max_i = 0; \n    long max_j = 0; \n    long max_len = 0; \n  \n    while (i < n * k) { \n        if (sum < 0) { \n            i = j; \n            sum = 0; \n        } \n        sum += a[j % n]; \n        if (sum > max_sum) { \n            max_sum = sum; \n            max_i = i; \n            max_j = j; \n            max_len = max_j - max_i + 1; \n        } else if (sum == max_sum) { \n            if (j - i + 1 > max_len) { \n                max_i = i; \n                max_j = j; \n                max_len = max_j - max_i + 1; \n            } \n        } \n        j++; \n    } \n    return max_sum; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        // arr[i%n] = arr[i%n] * (n-i) \n        long next_val = curr_val - sum + a[i - 1] * n; \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long current_sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            current_sum += a[j]; \n            if (current_sum > max_sum) \n                max_sum = current_sum; \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    for (long i = 0; i < n; i++) { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_sum == 0) \n        return max_elem; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    long ans = max(max_sum, sum * k); \n    long prefix_sum = 0; \n    for (long i = 0; i < n; i++) { \n        prefix_sum += a[i]; \n        long suffix_sum = sum * (k - 1) - prefix_sum; \n        ans = max(ans, prefix_sum + suffix_sum); \n    } \n    return ans; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (k == 1) \n        return max_sum; \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, k - 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n, long k) \n{ \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    return max(max_sub_array_sum_repeated(a, n, k), sum); \n} \nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (k == 1) \n        return max_sum; \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap +",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_sum == 0) \n        return max_elem; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    long ans = max(max_sum, sum * k); \n    long prefix_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        prefix_sum += a[i]; \n        long suffix_sum = sum * (k - 1) - prefix_sum; \n        ans = max(ans, prefix_sum + suffix_sum); \n    } \n    return ans; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n  \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1: get the maximum sum using standard kadane's algorithm \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2: Now find the maximum sum that includes corner elements. \n    long corner_sum = 0; \n    for (long i = 0; i < n; i++) { \n        corner_sum += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    // max sum with corner elements will be: \n    // array-sum - (-max sub array sum of inverted array) \n    max_ending_here = 0; \n    max_so_far = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n        } \n    } \n  \n    long temp = max_sum; \n    max_sum = max(max_sum, corner_sum + max_so_far); \n  \n    // Case 3: The maximum subarray may be in",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long i; \n  \n    // Find the sum of the first window of size n \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sums of remaining windows by  \n    // removing first element of previous  \n    // window and adding last element of  \n    // current window. \n    max_sum = sum; \n    for (i = n; i < n * k; i++) \n    { \n        sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n    } \n  \n    max_sum = sum; \n  \n    for (long i = 0; i < n; i++) { \n        sum += (k - 1) * a[i]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long max_wrap_sum = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    max_wrap_sum = 0; \n    for (long i = n - 1; i >= 0; i--) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    return max(max_sum, max_so_far); \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum(a, n); \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long i = 0; \n    long j = 0; \n    long sum = 0; \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n    max_so_far = sum; \n    for (i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_so_far < max_ending_here) \n            max_so_far = max_ending_here; \n    } \n    max_sum = max_so_far; \n    for (i = 0; i < n; i++) { \n        max_ending_here = 0; \n        for (j = i; j < n; j++) { \n            max_ending_here += a[j]; \n            if (max_so_far < max_ending_here) \n                max_so_far = max_ending_here; \n        } \n    } \n    max_sum = max(max_sum, max_so_far * (k - 2)); \n    max_ending_here = 0; \n    for (i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_so_far < max_ending_here) \n            max_so_far = max_ending_here; \n    } \n    max_sum = max(max_sum, max_so_far); \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        if (max_ending_here > max_sum) \n            max_sum = max_ending_here; \n        if (min_ending_here < min_sum) \n            min_sum = min_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n    } \n    if (k == 1) \n        return max_sum; \n    long max_wrap = total - min_sum; \n    if (k == 2) \n        return max(max_wrap, max_sum); \n    return max(max_wrap, max_sum + (k - 2) * total); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    // Finding sum of the original array \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Finding sum of the subarray with maximum sum \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_sum) \n            max_sum = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    // Finding maximum sum by adding the (k-1) * sum \n    // to the maximum sum of the subarray found above \n    max_sum = max(max_sum, (curr_sum * k + sum * (k - 1))); \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    max_wrap = max_wrap + curr_sum; \n  \n    if (k == 1) \n        return max(max_wrap, max_sum); \n  \n    return max(max_wrap, max_sum + (k - 2) * max_wrap); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        else if (curr_sum > max_sum) \n            max_sum = curr_sum; \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        else if (curr_sum > max_sum) \n            max_sum = curr_sum; \n    } \n  \n    max_wrap = max_wrap + curr_sum; \n  \n    if (k == 1) \n        return max(max_sum, max_wrap); \n  \n    return max(max_sum, max_wrap + (k - 2) * max_wrap); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = *max_element(a, a + n); \n  \n    // If all elements are negative \n    if (max_elem < 0) \n        return max_elem; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    // Case 2 \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n    } \n  \n    // If sum of all elements is \n    // positive \n    if (curr_sum > 0) \n        max_sum = max(max_sum, curr_sum * k); \n  \n    // Case 3 \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        max_sum = max(max_sum, curr_sum + (curr_sum * (k - 1))); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n  \n    long total_sum = 0; \n    for (i = 0; i < n; i++) \n    { \n        total_sum += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n  \n    max_wrap = max_wrap + total_sum; \n  \n    return max(max_wrap, max_sum); \n} \n  \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} \n  ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long max_wrap_sum = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    max_wrap_sum = 0; \n    for (long i = n - 1; i >= 0; i--) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    return max(max_sum, max_so_far); \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (sum < 0) \n            sum = 0; \n        if (max_sum < sum) \n            max_sum = sum; \n    } \n    if (k == 1) \n        return max_sum; \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_repeated(a, n, 1); \n    if (k == 1) \n        return max_sum; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    sum = sum + max_sub_array_sum_repeated(a, n, k - 1); \n    return max(max_sum, sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    // Compute sum of all elements \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*k elements where i varies \n    // from 0 to n-1 \n    for (long i = 0; i < n * k; i++) { \n        curr_sum += (i / n) * sum; \n  \n        // Add current element to curr_sum \n        curr_sum += a[i % n]; \n  \n        // Update max_sum, if required \n        max_sum = max(max_sum, curr_sum); \n  \n        // Reset curr_sum for next iteration \n        curr_sum = 0; \n    } \n  \n    return max_sum; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of elements in first window \n    long curr_sum = 0; \n    for (long i = 0; i < n * k; i++) \n        curr_sum += a[i % n]; \n  \n    // Initialize result \n    long res = curr_sum; \n  \n    // Traverse through remaining windows \n    for (long i = n; i < n * k; i++) { \n        // Remove first element of previous window \n        // Add last element of current window \n        curr_sum += a[i % n] - a[(i - n) % n]; \n  \n        // Update result if required \n        res = max(res, curr_sum); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n    long i = 0; \n    long count = 0; \n  \n    for (i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (i = start; i <= end; i++) { \n        max_sum += a[i % n]; \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_so_far = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n        min_ending_here = min_ending_here + a[i % n]; \n        max_ending_here = max(max_ending_here, 0); \n        min_ending_here = min(min_ending_here, 0); \n        max_sum = max(max_sum, max_ending_here); \n        min_so_far = min(min_so_far, min_ending_here); \n        sum += a[i % n]; \n    } \n  \n    if (sum > 0) \n        return max(max_sum, sum * k); \n    else\n        return max(max_sum, min_so_far); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    // Maintain maximum sum subarray found so far \n    max_sum = curr_sum; \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_so_far = 0; \n    long max_ending_here = 0; \n    long max_element = a[0]; \n    long sum = 0; \n    long i = 0; \n    for (i = 0; i < n; i++) { \n        max_element = max(max_element, a[i]); \n        sum += a[i]; \n    } \n    if (max_element <= 0) \n        return max_element * k; \n    for (i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_so_far < max_ending_here) \n            max_so_far = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_so_far + (sum * (k - 2))); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        if (max_ending_here > max_sum) \n            max_sum = max_ending_here; \n        if (min_ending_here < min_sum) \n            min_sum = min_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n    } \n  \n    if (k == 1) \n        return max_sum; \n  \n    long max_wrap = total - min_sum; \n  \n    if (k == 2) \n        return max(max_wrap, max_sum); \n  \n    return max(max_wrap, max_sum + (k - 2) * total); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    long max_val = max_sum; \n    for (long p = 1; p < n; p++) { \n        max_sum = max_sum + a[p - 1] - a[n - p]; \n        max_val = max(max_val, max_sum); \n    } \n  \n    long result = max(max_val, (max_val + k * (max_sum - max_val))); \n    return result; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n    long i; \n  \n    for (i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (i = end; i >= start; i--) { \n        sum = sum + a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n    return max_sum; \n} ",
    "{ \n    // Calculate sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find maximum sum subarray using Kadane's \n    // algorithm. Since only one element is \n    // changing at a time, we can use Kadane's \n    // algorithm to find maximum sum subarray \n    // in O(n) time \n    long max_so_far = a[0]; \n    long max_ending_here = a[0]; \n  \n    for (long i = 1; i < n; i++) { \n        max_ending_here = max(a[i], max_ending_here + a[i]); \n        max_so_far = max(max_so_far, max_ending_here); \n    } \n  \n    // If sum of all elements is negative, then \n    // answer is maximum element of the array \n    if (sum < 0) \n        return max_so_far; \n  \n    // If sum of all elements is positive, then \n    // answer is maximum sum of subarray modulo \n    // sum of all elements \n    return max(max_so_far, (max_so_far % sum + sum) % sum); \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    long max_val = max_sum; \n    for (long i = 2; i <= k; i++) \n        max_val = max(max_val, max_sum + (i * sum)); \n    return max_val; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n    } \n  \n    // Maintain maximum sum subarray found so far \n    max_sum = max(max_sum, curr_sum); \n  \n    // Compute sums of remaining windows by removing first \n    // element of previous window and adding last element \n    // of current window. \n    for (i = n; i < n * k; i++) { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find sum of first subarray of size n \n    for (i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Maintain maximum sum subarray found so far \n    max_sum = max(max_sum, curr_sum); \n  \n    // Find sum of remaining subarrays \n    for (i = n; i < n * k; i++) { \n  \n        // Add current item and remove first item of previous subarray \n        curr_sum += a[i % n] - a[(i - n) % n]; \n  \n        // Update maximum sum subarray found so far \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long max_element = *max_element(a, a + n); \n  \n    if (max_element < 0) \n        return max_element * k; \n  \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        sum = max(sum, 0); \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        sum = max(sum, 0); \n    } \n  \n    max_wrap = max_wrap + sum; \n  \n    return max(max_sum, max_wrap * (k - 2)); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Iterate over the original array \n    // to get the maximum sum subarray \n    // summing up elements at every index \n    for (i = 0; i < n; i++) { \n        curr_sum = (curr_sum + a[i]) % k; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    // Iterate again to find the maximum \n    // sum that is possible by adding \n    // multiples of k \n    for (i = 0; i < n; i++) { \n        curr_sum = (curr_sum + (k - a[i] % k)) % k; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) { \n        long sum = 0; \n        for (long j = i; j < n; j++) { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long max_element = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        if (a[i] > max_element) \n            max_element = a[i]; \n        sum += a[i]; \n    } \n    if (max_element <= 0) \n        return max_element * k; \n    long max_sum_with_k_adjacent = sum * k; \n    for (long i = 0; i < n; i++) \n    { \n        sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n    return max(max_sum, max_sum_with_k_adjacent); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    // Find sum of all elements of array. \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long max_val = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        max_val = max(max_val, next_val); \n    } \n  \n    return max_val; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long i = 0; \n    long j = 0; \n  \n    // Find the maximum sum subarray in first window of size k \n    for (i = 0; i < k; i++) \n        max_sum = max_sum + a[i]; \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    max_ending_here = max_sum; \n    for (i = k; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n] - a[(i - k) % n]; \n        max_so_far = max(max_so_far, max_ending_here); \n    } \n  \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n  \n    // Find the maximum sum subarray in first window of size k \n    for (long i = 0; i < k; i++) \n        max_sum += a[i]; \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    curr_sum = max_sum; \n    for (long i = k; i < n * k; i++) { \n        curr_sum += a[i % n] - a[(i - k) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long current_sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            current_sum += a[j]; \n            if (current_sum > max_sum) \n                max_sum = current_sum; \n        } \n    } \n    return max_sum * k; \n} \nlong max_sub_array_sum_repeated_optimized(long[] a, long n, long k) \n{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated_optimized(a, n, 1); \n    return max(max_wrap, max_sum * k); \n} \nlong max_sub_array_sum_repeated_optimized_2(long[] a, long n, long k) \n{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum =",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find sum of first subarray \n    for (i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Initialize result \n    max_sum = curr_sum; \n  \n    // Find sum of remaining subarrays \n    for (i = 1; i < k; i++) { \n  \n        // Update current sum by removing \n        // first element of previous subarray \n        // and adding last element of current subarray. \n        curr_sum = curr_sum + (a[i % n] * n) - (a[0] * n); \n  \n        // Update result if required \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    long max_wrap = 0; \n    long wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        wrap += a[i]; \n        if (max_wrap < wrap) \n            max_wrap = wrap; \n        if (wrap < 0) \n            wrap = 0; \n    } \n  \n    if (k == 1) \n        return max_wrap; \n  \n    long max_val = max_wrap; \n    for (i = 0; i < n; i++) \n    { \n        wrap += a[i]; \n        wrap = max(wrap, 0); \n        max_val = max(max_val, wrap); \n    } \n  \n    max_val = max(max_val, max_wrap + sum * (k - 2)); \n    return max_val; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find maximum sum subarray in first window of size k \n    for (i = 0; i < k; i++) \n        curr_sum += a[i]; \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    for (i = k; i < n*k; i++) \n    { \n        curr_sum += a[i%n] - a[(i-k)%n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (sum > max_wrap) \n            max_wrap = sum; \n    } \n  \n    return max(max_wrap, max_sum + (k - 2) * sum); \n} \n  \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n    return max_sum; \n} \n  \nlong max_sub_array_sum_k(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    if (k == 1) \n        return max_sum; \n    long max_wrap = max_sub_array_sum_repeated(a, n, k); \n    return max(max_sum, max_wrap); \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} \n  \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n  \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    return max_sum; \n} \n  \nlong max_circular_subarray_sum(long[] a, long n) \n{ \n    long max_kadane = max_sub_array_sum(a, n); \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    max_wrap = max_wrap + max_sub_array_sum(a,",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long total_sum = 0; \n  \n    // Finding maximum sum subarray using \n    // Kadane's algorithm \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    // Finding prefix sum \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        curr_prefix_sum = max(curr_prefix_sum, curr_sum); \n    } \n  \n    // Finding suffix sum \n    curr_sum = 0; \n    for (long i = n - 1; i >= 0; i--) { \n        curr_sum += a[i]; \n        curr_suffix_sum = max(curr_suffix_sum, curr_sum); \n    } \n  \n    // Finding total sum \n    for (long i = 0; i < n; i++) \n        total_sum += a[i]; \n  \n    // Case 1 \n    long ans1 = curr_prefix_sum + curr_suffix_sum + (k - 2) * total_sum; \n  \n    // Case 2 \n    long ans2 = max_sum + (k - 1) * total_sum; \n  \n    // Case 3 \n    long ans3 = max_sum + curr_suffix_sum + curr_prefix_sum + (k - 2) * total_sum; \n  \n    return max(ans1, max(ans2, ans3)); \n} \n  \n// Driver code ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0, sum = 0; \n    for (int i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    // Case 2: when all numbers are negative \n    if (max_sum < 0) \n        return max_sum; \n  \n    // Case 3: Maximum sum can be obtained by \n    // connecting two parts. \n    long max_wrap = 0; \n    for (int i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    // Find the maximum sum in modified array. \n    sum = 0; \n    for (int i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    // Maximum sum is sum of both cases. \n    return max(max_sum, max_wrap * (k - 2) + max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    long result = max_sum + (k - 2) * sum; \n    return max(result, max_sum + sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i >= start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n    } \n    for (long i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum < 0 ? 0 : curr_sum; \n    } \n    if (k == 1) \n        return max_sum; \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, sum * (k - 2) + max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Find the maximum sum subarray in  \n    // first k elements. \n    for (int i = 0; i < k; i++) { \n        max_sum = max_sum + a[i]; \n        if (max_ending_here < 0) { \n            max_ending_here = a[i]; \n            s = i; \n        } \n        else\n            max_ending_here = max_ending_here + a[i]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n    } \n  \n    // Initialize curr_max_sum as maximum sum  \n    // of subarray in arr[0..k-1]. \n    long curr_max = max_sum; \n  \n    // Traverse from k to n-1 \n    for (int i = k; i < n; i++) { \n        // Calculate current sum of subarray  \n        // ending at i. \n        curr_max = curr_max + a[i] - a[i - k]; \n        max_sum = max(max_sum, curr_max); \n  \n        // Update maximum sum of subarray \"ending\"  \n        // at index i (for next iteration) to  \n        // include a[i] \n        curr_max = curr_max + a[i] - a[i - k]; \n  \n        // Update result if required \n        max_sum = max(max_sum, curr_max); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i = 0; \n    long j = 0; \n    long m = n * k; \n  \n    // Iterate over the array \n    for (i = 0; i < m; i++) { \n  \n        // Increment the current sum \n        curr_sum += a[i % n]; \n  \n        // If the current sum is greater than the maximum sum \n        // then update the maximum sum \n        if (curr_sum > max_sum) { \n            max_sum = curr_sum; \n            j = i; \n        } \n  \n        // If the current sum is less than 0 then set it to 0 \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    // Return the maximum sum \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long i; \n  \n    // Find the sum of the first window of size n \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sums of remaining windows by  \n    // removing first element of previous  \n    // window and adding last element of  \n    // current window. \n    max_sum = sum; \n    for (i = n; i < n * k; i++) \n    { \n        sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code "
  ]
}