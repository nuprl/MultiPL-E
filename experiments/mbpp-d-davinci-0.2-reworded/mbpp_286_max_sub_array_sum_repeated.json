{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\n*/\nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = max_sub_array_sum_repeated;\n\n    assert(candidate([10L, 20L, -30L, -1L], 4L, 3L) == 30L);\n    assert(candidate([-1L, 10L, 20L], 3L, 2L) == 59L);\n    assert(candidate([-1L, -2L, -3L], 3L, 3L) == -1L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n        sum += a[i]; \n    } \n  \n    if (sum < 0) \n        return max(max_sum, min_sum + sum * (k - 2)); \n  \n    return max(max_sum, sum * k - min_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i = 0; \n    long j = 0; \n    long m = n * k; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    // Maintain a window of size n \n    for (i = 1; i < k; i++) { \n        curr_sum = 0; \n        for (j = 0; j < n; j++) { \n            curr_sum += a[(i * n + j) % m]; \n        } \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    max_sum = curr_sum; \n  \n    // Compute sums of remaining windows by removing first element \n    // of previous window and adding last element of current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, min_sum + total * (k - 2)); \n  \n    return max(max_sum, total * k - min_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long max_prefix_sum = 0; \n    long max_suffix_sum = 0; \n    long total_sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        total_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n  \n        curr_prefix_sum += a[i]; \n        max_prefix_sum = max(max_prefix_sum, curr_prefix_sum); \n        if (curr_prefix_sum < 0) \n            curr_prefix_sum = 0; \n  \n        curr_suffix_sum += a[n - i - 1]; \n        max_suffix_sum = max(max_suffix_sum, curr_suffix_sum); \n        if (curr_suffix_sum < 0) \n            curr_suffix_sum = 0; \n    } \n  \n    if (total_sum < 0) \n        return max(max_sum, max_prefix_sum + max_suffix_sum); \n  \n    return max(max_sum, max_prefix_sum + max_suffix_sum + (total_sum * (k - 2))); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n    long i = 0; \n  \n    for (i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size k \n    for (i = 0; i < k; i++) \n        curr_sum += a[i]; \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    for (i = k; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - k) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    max_sum = max(max_sum, curr_sum); \n    long ans = (max_sum * k) % 1000000007; \n    return ans; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_sum == 0) \n        return max_elem; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    long ans = max(max_sum, sum * k); \n    long prefix_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        prefix_sum += a[i]; \n        curr_sum = prefix_sum; \n        for (long j = i + n; j < n * k; j += n) \n        { \n            curr_sum += sum; \n            curr_sum -= a[j % n]; \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n    return max(ans, max_sum); \n}",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum(a, n); \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    long max_val = max_sum; \n    for (long i = 0; i < n; i++) { \n        max_sum = max_sum + (k - 1) * a[i]; \n        max_val = max(max_val, max_sum); \n        max_sum = max_sum - (k - 1) * a[i]; \n    } \n  \n    return max_val; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, min_sum + total * (k - 2)); \n  \n    return max(max_sum, total * k - min_sum); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long current_sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            current_sum += a[j]; \n            if (current_sum > max_sum) \n                max_sum = current_sum; \n        } \n    } \n    return max_sum * k; \n} \nlong max_sub_array_sum_repeated_efficient(long[] a, long n, long k) \n{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    max_sum = max_sum + max_wrap; \n    if (max_sum > 0) \n        return max_sum * k; \n    else\n        return max_sum; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    // Case 1: get the maximum sum using standard kadane's \n    // algorithm \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) { \n            max_sum = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 2: Now find the maximum sum that is possible by \n    // modifying array. \n    max_so_far = max_sum; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        max_ending_here = max_ending_here - a[start]; \n        if (max_ending_here > max_so_far) \n            max_so_far = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n  \n    // Case 3: Maximum Sum is possible with Corner Elements. \n    long corner_sum = 0; \n    for (long i = 0; i < n; i++) \n        corner_sum += a[i]; \n    corner_sum = corner_sum * (k - 2); \n  \n    // The maximum circular sum will be maximum of two sums \n    // obtained by two cases. \n    return max(max_so_far, corner_sum + max_sum); \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        long next_val = curr_val - (sum - a[i - 1]) +  \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} \n  \n// Driver code ",
    "{ \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    long max_sum = sum; \n    for (long p = 1; p < k; p++) { \n        for (long i = 0; i < n; i++) { \n            sum = sum - a[i] + a[(i + 1) % n]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i >= k - 1) { \n            max_sum = max(max_sum, curr_sum); \n            curr_sum -= sum; \n        } \n    } \n    return max_sum; \n} "
  ]
}