{
  "name": "mbpp_572_two_unique_nums",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a dthon function to remove duplicate numbers from a given number of arrays.\n\t\n*/\nlong[] two_unique_nums(long[] nums) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = two_unique_nums;\n\n    assert(candidate([1L, 2L, 3L, 2L, 3L, 4L, 5L]) == [1L, 4L, 5L]);\n    assert(candidate([1L, 2L, 3L, 2L, 4L, 5L]) == [1L, 3L, 4L, 5L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 2L, 3L, 4L, 5L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor_result = 0;\n\tforeach(num; nums)\n\t{\n\t\txor_result ^= num;\n\t}\n\t\n\tlong bit_pos = 0;\n\tfor(int i = 0; i < 64; i++)\n\t{\n\t\tif((xor_result & (1 << i)) != 0)\n\t\t{\n\t\t\tbit_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tlong num1 = 0;\n\tlong num2 = 0;\n\tforeach(num; nums)\n\t{\n\t\tif((num & (1 << bit_pos)) != 0)\n\t\t{\n\t\t\tnum1 ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnum2 ^= num;\n\t\t}\n\t}\n\t\n\tunique_nums[0] = num1;\n\tunique_nums[1] = num2;\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\t\n\tlong mask = xor & ~(xor - 1);\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & mask) != 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tforeach(num; nums)\n\t{\n\t\tif(unique_nums[0] == num)\n\t\t{\n\t\t\tunique_nums[1] = num;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tunique_nums[0] = num;\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong right_most_bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & right_most_bit) != 0)\n\t\t{\n\t\t\tunique_nums[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunique_nums[1] ^= num;\n\t\t}\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\t\n\tlong bit = xor & ~(xor - 1);\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) != 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor_res = 0;\n\tforeach(num; nums)\n\t{\n\t\txor_res ^= num;\n\t}\n\t\n\tlong bit_pos = xor_res & ~(xor_res - 1);\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit_pos) == 0)\n\t\t{\n\t\t\tunique_nums[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunique_nums[1] ^= num;\n\t\t}\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor_result = 0;\n\tforeach(num; nums)\n\t{\n\t\txor_result ^= num;\n\t}\n\t\n\t// Get the rightmost set bit\n\tlong rightmost_set_bit = xor_result & ~(xor_result - 1);\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & rightmost_set_bit) != 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\t\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) != 0)\n\t\t{\n\t\t\tunique_nums[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunique_nums[1] ^= num;\n\t\t}\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tunique_nums[0] = nums[0];\n\tunique_nums[1] = nums[1];\n\t\n\tfor (int i = 2; i < nums.length; i++) \n\t{\n\t\tif (nums[i] != unique_nums[0] && nums[i] != unique_nums[1]) \n\t\t{\n\t\t\tunique_nums[0] = nums[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (int i = 2; i < nums.length; i++) \n\t{\n\t\tif (nums[i] != unique_nums[0] && nums[i] != unique_nums[1]) \n\t\t{\n\t\t\tunique_nums[1] = nums[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong mask = xor & -xor;\n\tforeach(num; nums)\n\t{\n\t\tif((num & mask) == 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tforeach(num; nums)\n\t{\n\t\tif(unique_nums[0] == 0)\n\t\t{\n\t\t\tunique_nums[0] = num;\n\t\t}\n\t\telse if(unique_nums[1] == 0)\n\t\t{\n\t\t\tif(unique_nums[0] == num)\n\t\t\t{\n\t\t\t\tunique_nums[1] = num;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tunique_nums[1] = num;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(unique_nums[0] == num)\n\t\t\t{\n\t\t\t\tunique_nums[0] = unique_nums[1];\n\t\t\t\tunique_nums[1] = num;\n\t\t\t}\n\t\t\telse if(unique_nums[1] == num)\n\t\t\t{\n\t\t\t\tunique_nums[1] = num;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tunique_nums[0] = num;\n\t\t\t}\n\t\t}\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong[] nums_copy = nums.dup;\n\tnums_copy.sort;\n\tnums_copy.uniq;\n\tunique_nums[0] = nums_copy[0];\n\tunique_nums[1] = nums_copy[1];\n\treturn unique_nums;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t\txor ^= num;\n\t\n\tlong bit = xor & ~(xor - 1);\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) == 0)\n\t\t\tunique_nums[0] ^= num;\n\t\telse\n\t\t\tunique_nums[1] ^= num;\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) == 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\t\n\tlong bit = xor & ~(xor - 1);\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) == 0)\n\t\t{\n\t\t\tunique_nums[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunique_nums[1] ^= num;\n\t\t}\n\t}\n\t\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums) \n\t{\n\t\txor ^= num;\n\t}\n\tlong mask = xor & -xor;\n\tforeach(num; nums) \n\t{\n\t\tif((num & mask) == 0) \n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) != 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) == 0)\n\t\t{\n\t\t\tunique_nums[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunique_nums[1] ^= num;\n\t\t}\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) != 0)\n\t\t{\n\t\t\tunique_nums[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunique_nums[1] ^= num;\n\t\t}\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor_result = 0;\n\tforeach(num; nums)\n\t{\n\t\txor_result ^= num;\n\t}\n\t\n\tunique_nums[0] = xor_result;\n\tunique_nums[1] = xor_result;\n\treturn unique_nums;\n}"
  ]
}