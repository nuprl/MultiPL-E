{
  "name": "mbpp_100_next_smallest_palindrome",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\t\n*/\nlong next_smallest_palindrome(long num) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = next_smallest_palindrome;\n\n    assert(candidate(99L) == 101L);\n    assert(candidate(1221L) == 1331L);\n    assert(candidate(120L) == 121L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tlong num_digits = log10(num) + 1;\n\t\n\tif (num_digits == 1)\n\t\treturn num;\n\t\n\tlong half_digits = num_digits / 2;\n\t\n\tlong left_half = num / pow(10, half_digits);\n\t\n\tlong right_half = num % (long)pow(10, half_digits);\n\t\n\tlong left_half_reversed = 0;\n\t\n\tlong right_half_reversed = 0;\n\t\n\tfor (long i = 0; i < half_digits; i++)\n\t{\n\t\tleft_half_reversed += (left_half % 10) * pow(10, half_digits - i - 1);\n\t\tleft_half /= 10;\n\t\t\n\t\tright_half_reversed += (right_half % 10) * pow(10, half_digits - i - 1);\n\t\tright_half /= 10;\n\t}\n\t\n\tlong result = 0;\n\t\n\tif (left_half_reversed < right_half_reversed)\n\t{\n\t\tleft_half_reversed++;\n\t\tresult = left_half_reversed * pow(10, half_digits) + left_half_reversed;\n\t}\n\telse\n\t{\n\t\tresult = left_half_reversed * pow(10, half_digits) + left_half_reversed;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong num_copy = num;\n\tlong num_digits = 0;\n\tlong num_digits_half = 0;\n\tlong num_half = 0;\n\tlong num_half_copy = 0;\n\tlong num_half_copy_rev = 0;\n\tlong num_half_copy_rev_copy = 0;\n\tlong num_half_copy_rev_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_half_copy_rev_",
    "{\n\tlong n = num;\n\tlong palindrome = num;\n\t\n\t// if the number is a palindrome, increment it\n\tif (is_palindrome(num))\n\t{\n\t\tpalindrome = num + 1;\n\t}\n\telse\n\t{\n\t\t// if the number is not a palindrome, find the next smallest palindrome\n\t\twhile (!is_palindrome(palindrome))\n\t\t{\n\t\t\tpalindrome--;\n\t\t}\n\t}\n\t\n\treturn palindrome;\n}",
    "{\n\tif(num < 0)\n\t\treturn -1;\n\t\n\tif(num < 10)\n\t\treturn num;\n\t\n\tlong num_digits = log10(num) + 1;\n\t\n\tif(num_digits == 1)\n\t\treturn num;\n\t\n\tif(num_digits % 2 == 0)\n\t{\n\t\tlong num_digits_half = num_digits / 2;\n\t\tlong first_half = num / pow(10, num_digits_half);\n\t\tlong second_half = num % (long)pow(10, num_digits_half);\n\t\t\n\t\tif(first_half == second_half)\n\t\t\treturn num;\n\t\t\n\t\tif(first_half > second_half)\n\t\t{\n\t\t\tlong new_second_half = first_half;\n\t\t\treturn first_half * pow(10, num_digits_half) + new_second_half;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong new_first_half = first_half + 1;\n\t\t\tlong new_second_half = new_first_half;\n\t\t\treturn new_first_half * pow(10, num_digits_half) + new_second_half;\n\t\t}\n\t}\n\telse\n\t{\n\t\tlong num_digits_half = (num_digits + 1) / 2;\n\t\tlong first_half = num / pow(10, num_digits_half);\n\t\tlong second_half = num % (long)pow(10, num_digits_half);\n\t\t\n\t\tif(first_half == second_half)\n\t\t\treturn num;\n\t\t\n\t\tif(first_half > second_half)\n\t\t{\n\t\t\tlong new_second_half = first_half;\n\t\t\treturn first_half * pow(10, num_digits_half) + new_second_half;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong new_first_half = first_half + 1;\n\t\t\tlong",
    "{\n\tlong result = num;\n\tlong temp = num;\n\tlong reverse = 0;\n\tlong remainder = 0;\n\t\n\twhile(temp != 0)\n\t{\n\t\tremainder = temp % 10;\n\t\treverse = reverse * 10 + remainder;\n\t\ttemp /= 10;\n\t}\n\t\n\tif(num == reverse)\n\t{\n\t\tresult = num + 2;\n\t}\n\telse\n\t{\n\t\tresult = num + 1;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong num_digits = log10(num) + 1;\n\tlong num_digits_half = num_digits / 2;\n\tlong num_digits_half_ceil = ceil(num_digits / 2);\n\t\n\tlong num_digits_half_ceil_pow = pow(10, num_digits_half_ceil);\n\t\n\tlong num_digits_half_ceil_pow_minus_1 = num_digits_half_ceil_pow - 1;\n\t\n\tlong num_digits_half_ceil_pow_minus_1_pow = pow(10, num_digits_half_ceil_pow_minus_1);\n\t\n\tlong num_digits_half_ceil_pow_minus_1_pow_minus_1 = num_digits_half_ceil_pow_minus_1_pow - 1;\n\t\n\tlong num_digits_half_ceil_pow_minus_1_pow_minus_1_pow = pow(10, num_digits_half_ceil_pow_minus_1_pow_minus_1);\n\t\n\tlong num_digits_half_ceil_pow_minus_1_pow_minus_1_pow_minus_1 = num_digits_half_ceil_pow_minus_1_pow_minus_1_pow - 1;\n\t\n\tlong num_digits_half_ceil_pow_minus_1_pow_minus_1_pow_minus_1_pow = pow(10, num_digits_half_ceil_pow_minus_1_pow_minus_1_pow_minus_1);\n\t\n\tlong num_digits_half_ceil_pow_minus_1_pow_minus_1_pow_minus_1_pow_minus_1 = num_digits_half_ceil_pow_minus_1_pow_minus_1_pow_minus_1_pow - 1;\n\t\n\tlong num_digits_",
    "{\n\tlong n = num;\n\tlong rev = 0;\n\twhile (n != 0) \n\t{\n\t\trev = rev * 10 + n % 10;\n\t\tn /= 10;\n\t}\n\tif (num == rev)\n\t\treturn num;\n\telse if (num > rev)\n\t\treturn rev;\n\telse \n\t{\n\t\tlong n = num;\n\t\tlong rev = 0;\n\t\twhile (n != 0) \n\t\t{\n\t\t\trev = rev * 10 + n % 10;\n\t\t\tn /= 10;\n\t\t}\n\t\treturn rev;\n\t}\n}",
    "{\n\tlong num_copy = num;\n\tlong num_copy_rev = 0;\n\tlong num_copy_rev_copy = 0;\n\tlong num_copy_rev_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy",
    "{\n\t// if the number is negative, return the next smallest palindrome\n\tif (num < 0) \n\t{\n\t\treturn next_smallest_palindrome(-num);\n\t}\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num)) \n\t{\n\t\treturn next_smallest_palindrome(num - 1);\n\t}\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num + 1)) \n\t{\n\t\treturn num + 1;\n\t}\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num - 1)) \n\t{\n\t\treturn num - 1;\n\t}\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num + 2)) \n\t{\n\t\treturn num + 2;\n\t}\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num - 2)) \n\t{\n\t\treturn num - 2;\n\t}\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num + 3)) \n\t{\n\t\treturn num + 3;\n\t}\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num - 3)) \n\t{\n\t\treturn num - 3;\n\t}\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num + 4)) \n\t{\n\t\treturn num + 4;\n\t}\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num - 4)) \n\t{\n\t\treturn num - 4;\n\t}\n\t\n\t// if the",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tauto digits = to!string(num);\n\t\n\tif (digits.length % 2 == 0)\n\t{\n\t\tauto firstHalf = digits[0..$/2];\n\t\tauto secondHalf = digits[$/2..$];\n\t\t\n\t\tauto firstHalfReversed = firstHalf.dup.reverse;\n\t\t\n\t\tif (firstHalfReversed > secondHalf)\n\t\t{\n\t\t\treturn to!long(firstHalf ~ firstHalfReversed);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto firstHalfAsNum = to!long(firstHalf);\n\t\t\tauto newFirstHalf = to!string(firstHalfAsNum + 1);\n\t\t\tauto newFirstHalfReversed = newFirstHalf.dup.reverse;\n\t\t\t\n\t\t\treturn to!long(newFirstHalf ~ newFirstHalfReversed);\n\t\t}\n\t}\n\telse\n\t{\n\t\tauto firstHalf = digits[0..$/2];\n\t\tauto secondHalf = digits[$/2+1..$];\n\t\t\n\t\tauto firstHalfReversed = firstHalf.dup.reverse;\n\t\t\n\t\tif (firstHalfReversed > secondHalf)\n\t\t{\n\t\t\treturn to!long(firstHalf ~ digits[$/2] ~ firstHalfReversed);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto firstHalfAsNum = to!long(firstHalf);\n\t\t\tauto newFirstHalf = to!string(firstHalfAsNum + 1);\n\t\t\tauto newFirstHalfReversed = newFirstHalf.dup.reverse;\n\t\t\t\n\t\t\treturn to!long(newFirstHalf ~ digits[$/2] ~ newFirstHalfReversed);\n\t\t}\n\t}\n}",
    "{\n\tif (num < 0) \n\t\treturn -1;\n\t\n\tif (num < 10) \n\t\treturn num;\n\t\n\tauto digits = to!string(num);\n\tauto len = digits.length;\n\t\n\tif (len % 2 == 0) \n\t{\n\t\tauto half = len / 2;\n\t\tauto left = digits[0 .. half];\n\t\tauto right = digits[half .. len];\n\t\t\n\t\tif (left == right) \n\t\t\treturn num;\n\t\t\n\t\tauto left_int = to!long(left);\n\t\tauto right_int = to!long(right);\n\t\t\n\t\tif (left_int < right_int) \n\t\t{\n\t\t\tleft_int++;\n\t\t\tleft = to!string(left_int);\n\t\t\treturn to!long(left ~ left[$ - 1 .. 0]);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tright = left;\n\t\t\treturn to!long(left ~ right[$ - 1 .. 0]);\n\t\t}\n\t}\n\telse \n\t{\n\t\tauto half = len / 2;\n\t\tauto left = digits[0 .. half];\n\t\tauto right = digits[half + 1 .. len];\n\t\t\n\t\tif (left == right) \n\t\t\treturn num;\n\t\t\n\t\tauto left_int = to!long(left);\n\t\tauto right_int = to!long(right);\n\t\t\n\t\tif (left_int < right_int) \n\t\t{\n\t\t\tleft_int++;\n\t\t\tleft = to!string(left_int);\n\t\t\treturn to!long(left ~ digits[half] ~ left[$ - 1 .. 0]);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tright = left;\n\t\t\treturn to!long(left ~ digits[half] ~ right[$ - 1 .. 0]);\n\t\t}\n\t}\n}",
    "{\n\tlong palindrome = num;\n\twhile(!is_palindrome(palindrome))\n\t{\n\t\tpalindrome--;\n\t}\n\treturn palindrome;\n}",
    "{\n\tlong next_palindrome = num;\n\tint num_digits = (int)log10(num) + 1;\n\tint num_half_digits = num_digits / 2;\n\t\n\tint[] digits = new int[num_digits];\n\t\n\tfor (int i = 0; i < num_digits; i++)\n\t{\n\t\tdigits[i] = (int)(num % 10);\n\t\tnum /= 10;\n\t}\n\t\n\tbool is_palindrome = true;\n\tfor (int i = 0; i < num_half_digits; i++)\n\t{\n\t\tif (digits[i] != digits[num_digits - i - 1])\n\t\t{\n\t\t\tis_palindrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (is_palindrome)\n\t{\n\t\t// Increment the middle digit\n\t\tif (num_digits % 2 == 1)\n\t\t{\n\t\t\tdigits[num_half_digits]++;\n\t\t}\n\t\t\n\t\t// Increment the left half of the number\n\t\tfor (int i = num_half_digits - 1; i >= 0; i--)\n\t\t{\n\t\t\tdigits[i]++;\n\t\t\tif (digits[i] == 10)\n\t\t\t{\n\t\t\t\tdigits[i] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If the left half is all zeros, then we need to add a digit to the front\n\t\tif (digits[0] == 0)\n\t\t{\n\t\t\tdigits = digits[1 .. $];\n\t\t\tdigits ~= 1;\n\t\t}\n\t\t\n\t\t// Copy the left half to the right half\n\t\tfor (int i = 0; i < num_half_digits; i++)\n\t\t{\n\t\t\tdigits[num_digits - i - 1] = digits[i];\n\t",
    "{\n\tlong next_palindrome = num;\n\t\n\twhile(true)\n\t{\n\t\t// If the number is a palindrome, return it\n\t\tif(is_palindrome(next_palindrome))\n\t\t\treturn next_palindrome;\n\t\t\n\t\t// Increment the number\n\t\tnext_palindrome++;\n\t}\n}",
    "{\n\t// get the number of digits\n\tint digits = (int)log10(num) + 1;\n\t\n\t// get the left half of the number\n\tlong left_half = num / pow(10, digits / 2);\n\t\n\t// get the next smallest palindrome\n\tlong palindrome = next_smallest_palindrome(left_half);\n\t\n\t// if the number of digits is odd, then we need to remove the middle digit\n\tif (digits % 2 == 1)\n\t{\n\t\tpalindrome /= 10;\n\t}\n\t\n\t// append the reverse of the left half to the right half\n\treturn palindrome * pow(10, digits / 2) + reverse(palindrome);\n}",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tlong num_digits = ceil(log10(num));\n\t\n\tif (num_digits == 1)\n\t\treturn num;\n\t\n\tlong num_digits_half = num_digits / 2;\n\t\n\tlong left_half = num / pow(10, num_digits_half);\n\tlong right_half = num % (long)pow(10, num_digits_half);\n\t\n\tlong left_half_reversed = reverse(left_half);\n\t\n\tif (left_half_reversed < right_half)\n\t{\n\t\tleft_half++;\n\t\tleft_half_reversed = reverse(left_half);\n\t}\n\t\n\treturn left_half * pow(10, num_digits_half) + left_half_reversed;\n}",
    "{\n\t// convert to string\n\tstring s = to!string(num);\n\t\n\t// if the string is a palindrome, return the next number\n\tif (s == s[$-1 .. 0])\n\t\treturn num + 1;\n\t\n\t// if the string is not a palindrome, find the next palindrome\n\t\n\t// find the middle of the string\n\tsize_t mid = s.length / 2;\n\t\n\t// find the left and right halves of the string\n\tstring left = s[0 .. mid];\n\tstring right = s[mid + s.length % 2 .. $];\n\t\n\t// if the left half is greater than the right half, increment the left half\n\tif (left > right)\n\t{\n\t\tleft = to!string(to!long(left) + 1);\n\t\t\n\t\t// if the left half is now longer than the right half, increment the right half\n\t\tif (left.length > right.length)\n\t\t\tright = to!string(to!long(right) + 1);\n\t}\n\t\n\t// if the left half is less than the right half, increment the right half\n\telse if (left < right)\n\t{\n\t\tright = to!string(to!long(right) + 1);\n\t\t\n\t\t// if the right half is now longer than the left half, increment the left half\n\t\tif (right.length > left.length)\n\t\t\tleft = to!string(to!long(left) + 1);\n\t}\n\t\n\t// if the left half is equal to the right half, do nothing\n\t\n\t// if the left half is now longer than the right half, increment the right half\n\tif (left.length > right.length)\n\t\tright = to!string(to!long(right) + 1);\n\t\n\t// if the right half is now longer than the left half, increment the left half\n\tif (right.length > left.length)\n\t\tleft = to!string(to!long(left) + 1);\n\t\n\t// if the left half is now longer than the right half, increment the right half\n\tif (left.length > right.",
    "{\n\t// convert to string\n\tstring num_str = to!string(num);\n\t\n\t// check if already palindrome\n\tif (is_palindrome(num_str)) \n\t{\n\t\t// if so, increment by 1\n\t\tnum += 1;\n\t\t\n\t\t// convert back to string\n\t\tnum_str = to!string(num);\n\t}\n\t\n\t// get the middle index\n\tsize_t mid_idx = num_str.length / 2;\n\t\n\t// get the left half of the string\n\tstring left_half = num_str[0 .. mid_idx];\n\t\n\t// get the right half of the string\n\tstring right_half = num_str[mid_idx .. $];\n\t\n\t// reverse the right half\n\tstring reversed_right_half = right_half.dup.reverse;\n\t\n\t// if the left half is less than the reversed right half\n\tif (left_half < reversed_right_half) \n\t{\n\t\t// increment the left half\n\t\tleft_half = to!string(to!long(left_half) + 1);\n\t}\n\t\n\t// reverse the left half\n\tstring reversed_left_half = left_half.dup.reverse;\n\t\n\t// concatenate the left half with the reversed left half\n\tnum_str = left_half ~ reversed_left_half;\n\t\n\t// convert back to integer\n\treturn to!long(num_str);\n}",
    "{\n\t// if the number is a palindrome, return it\n\tif (is_palindrome(num))\n\t\treturn num;\n\t\n\t// get the number of digits in the number\n\tint num_digits = num_digits_in_num(num);\n\t\n\t// if the number is a single digit, return it\n\tif (num_digits == 1)\n\t\treturn num;\n\t\n\t// if the number is a two digit number, return the next smallest palindrome\n\tif (num_digits == 2)\n\t{\n\t\tif (num % 11 == 0)\n\t\t\treturn num - 1;\n\t\telse\n\t\t\treturn num - num % 11;\n\t}\n\t\n\t// if the number is a three digit number, return the next smallest palindrome\n\tif (num_digits == 3)\n\t{\n\t\tif (num % 101 == 0)\n\t\t\treturn num - 1;\n\t\telse\n\t\t\treturn num - num % 101;\n\t}\n\t\n\t// if the number is a four digit number, return the next smallest palindrome\n\tif (num_digits == 4)\n\t{\n\t\tif (num % 1001 == 0)\n\t\t\treturn num - 1;\n\t\telse\n\t\t\treturn num - num % 1001;\n\t}\n\t\n\t// if the number is a five digit number, return the next smallest palindrome\n\tif (num_digits == 5)\n\t{\n\t\tif (num % 10001 == 0)\n\t\t\treturn num - 1;\n\t\telse\n\t\t\treturn num - num % 10001;\n\t}\n\t\n\t// if the number is a six digit number, return the next smallest palindrome\n\tif (num_digits == 6)\n\t{\n\t\tif (num % 100001 == 0)\n\t\t\treturn num - 1;\n\t\telse\n\t\t\treturn num - num % 100001;\n\t}\n\t\n\t// if the number is a seven digit number, return the next smallest palindrome\n\tif (num_digits == 7)\n\t{\n\t\tif (num % 100",
    "{\n\tlong num_copy = num;\n\tlong num_copy_rev = 0;\n\tlong num_copy_rev_copy = 0;\n\tlong num_copy_rev_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\tlong num_copy_rev_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy"
  ]
}