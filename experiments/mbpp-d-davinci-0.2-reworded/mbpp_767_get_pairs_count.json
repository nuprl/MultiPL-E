{
  "name": "mbpp_767_get_pairs_count",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a dthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong get_pairs_count(long[] arr, long sum) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = get_pairs_count;\n\n    assert(candidate([1L, 1L, 1L, 1L], 2L) == 6L);\n    assert(candidate([1L, 5L, 7L, -1L, 5L], 6L) == 3L);\n    assert(candidate([1L, -2L, 3L], 1L) == 1L);\n    assert(candidate([-1L, -2L, 3L], -3L) == 1L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong count = 0;\n\tforeach(i; 0..arr.length)\n\t{\n\t\tforeach(j; i+1..arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tlong[] hash = new long[n];\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\thash[i] = 0;\n\t}\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tlong temp = sum - arr[i];\n\t\tif (temp >= 0 && hash[temp] == 1)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\thash[arr[i]] = 1;\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. arr.length)\n\t{\n\t\tforeach(j; i+1 .. arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. arr.length)\n\t{\n\t\tforeach(j; i+1 .. arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t\tcount++;\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (int i = 0; i < arr.length; i++) \n\t\tfor (int j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} \n/*",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(long i; 0 .. arr.length)\n\t{\n\t\tforeach(long j; i+1 .. arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong n = arr.length;\n\tlong count = 0;\n\tlong[] hash = new long[1000000];\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\thash[arr[i]]++;\n\t}\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tlong temp = sum - arr[i];\n\t\tif (temp >= 0 && hash[temp] > 0) \n\t\t{\n\t\t\tcount += hash[temp];\n\t\t}\n\t\tif (temp == arr[i]) \n\t\t{\n\t\t\tcount--;\n\t\t}\n\t}\n\treturn count / 2;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} \n/*\n\tWrite a dthon function to find the first pair whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong[] get_first_pair(long[] arr, long sum) \n{ \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                return [arr[i], arr[j]]; \n  \n    return null; \n} \n/*\n\tWrite a dthon function to find the first pair whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong[] get_all_pairs(long[] arr, long sum) \n{ \n    long[] res = [];\n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                res ~= [arr[i], arr[j]]; \n  \n    return res; \n} \n/*\n\tWrite a dthon function to find the first pair whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong[] get_all_pairs_with_index(long[] arr, long sum) \n{ \n    long[] res = [];\n    // Consider all possible pairs and check their sums \n   ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} \n/*\n\tWrite a dthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong get_pairs_count_2(long[] arr, long sum) \n{ \n    long count = 0; // Initialize result \n  \n    // Create an empty hash set \n    HashSet<long> s = new HashSet<long>(); \n  \n    // Traverse through all elements \n    for (long i = 0; i < arr.length; i++) \n    { \n        long temp = sum - arr[i]; \n  \n        // If temp is in array, then there is a pair \n        // with sum equal to sum \n        if (s.contains(temp)) \n            count++; \n  \n        s.insert(arr[i]); \n    } \n    return count; \n} \n/*\n\tWrite a dthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong get_pairs_count_3(long[] arr, long sum) \n{ \n    long count = 0; // Initialize result \n  \n    // Sort the given array \n    arr.sort(); \n  \n    // Initialize two index variables to find the candidate \n    // elements in the sorted array. \n    long l = 0; \n    long r = arr.length - 1; \n  \n    // Loop while there are elements between l and r \n    while (l < r) \n    { \n        if (arr[l] + arr[r] == sum) \n        { \n",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} \n/*\n\tWrite a dthon function to find the first duplicate number for which the second occurrence has the minimal index. \n\tIn other words, if there are more than 1 duplicated numbers, return the number for which the second occurrence has a smaller index than the second occurrence of the other number does. \n\tIf there are no such elements, return -1.\n*/\nlong firstDuplicate(long[] a) {\n    long[] b = new long[a.length];\n    for(long i = 0; i < a.length; i++){\n        if(b[a[i]] == 0){\n            b[a[i]] = 1;\n        }else{\n            return a[i];\n        }\n    }\n    return -1;\n}\n/*\n\tWrite a dthon function to find the first duplicate number for which the second occurrence has the minimal index. \n\tIn other words, if there are more than 1 duplicated numbers, return the number for which the second occurrence has a smaller index than the second occurrence of the other number does. \n\tIf there are no such elements, return -1.\n*/\nlong firstDuplicate(long[] a) {\n    long[] b = new long[a.length];\n    for(long i = 0; i < a.length; i++){\n        if(b[a[i]] == 0){\n            b[a[i]] = 1;\n        }else{\n            return a[i];\n        }\n    }\n    return -1;\n}\n/*\n\tWrite a dthon function to find the first duplicate number for which the second occurrence has the minimal index. \n\tIn other words, if there are more than 1 duplicated numbers, return the number for which the second occurrence has a smaller index than the second occurrence of the other number does",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. arr.length)\n\t{\n\t\tforeach(j; i+1 .. arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. arr.length)\n\t{\n\t\tforeach(j; i+1 .. arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (int i = 0; i < arr.length; i++) \n\t\tfor (int j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong n = arr.length;\n\tlong count = 0;\n\tlong[] temp = new long[n];\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\ttemp[i] = arr[i];\n\t}\n\t\n\tsort(temp);\n\t\n\tlong left = 0;\n\tlong right = n - 1;\n\t\n\twhile (left < right) \n\t{\n\t\tif (temp[left] + temp[right] == sum) \n\t\t{\n\t\t\tcount++;\n\t\t\tleft++;\n\t\t\tright--;\n\t\t}\n\t\telse if (temp[left] + temp[right] < sum) \n\t\t{\n\t\t\tleft++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tright--;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tint n = arr.length;\n\tfor (int i = 0; i < n; i++) \n\t{\n\t\tfor (int j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0..arr.length)\n\t{\n\t\tforeach(j; i+1..arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} \n/*\n\tWrite a dthon function to find the number of ways to express n as sum of some (at least two) consecutive positive integers.\n*/\nlong countWays(long n) \n{ \n    // n = (x + l -1) * l/2 \n    // x = n/l - (l-1)/2 \n    long count = 0; \n    for (long l = 2; l * (l - 1) < 2 * n; l++) \n    { \n        float a = (float) ((1.0 * n / l) - (1.0 * (l - 1) / 2)); \n        if (a-(long)a == 0.0) \n            count++; \n    } \n    return count; \n} \n/*\n\tWrite a dthon function to find the number of ways to express n as sum of some (at least two) consecutive positive integers.\n*/\nlong countWays(long n) \n{ \n    // n = (x + l -1) * l/2 \n    // x = n/l - (l-1)/2 \n    long count = 0; \n    for (long l = 2; l * (l - 1) < 2 * n; l++) \n    { \n        float a = (float) ((1.0 * n / l) - (1.0 * (l - 1) / 2)); \n        if (a-(long)a == 0.0) \n            count++; \n    } \n    return count; \n} \n/*\n\tWrite a dthon function to find the number of ways to express n as sum of some (at least two) consecutive positive integers.\n*/\nlong countWays(long n) \n{ \n    //",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} \n/*\n\tWrite a dthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong get_pairs_count_hash(long[] arr, long sum) \n{ \n    long count = 0; // Initialize result \n  \n    // Create an empty hash set \n    HashSet<long> s = new HashSet<long>(); \n  \n    // Do for each element \n    for (long i = 0; i < arr.length; i++) \n    { \n        // Check if pair (arr[i], sum-arr[i]) exists \n  \n        // If difference is seen before, print the pair \n        if (s.contains(sum - arr[i])) \n            count++; \n  \n        // Store arr[i] in hash set. \n        s.insert(arr[i]); \n    } \n    return count; \n} \n/*\n\tWrite a dthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong get_pairs_count_sort(long[] arr, long sum) \n{ \n    long count = 0; // Initialize result \n  \n    // Sort the array elements \n    arr.sort(); \n  \n    // Initialize left and right indexes \n    long l = 0; \n    long r = arr.length - 1; \n    while (l < r) \n    { \n        if ((arr[l] + arr[r]) == sum) \n        { \n            // Since array elements are sorted, \n            // so there can",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong[] hash = new long[sum];\n\tforeach(i; 0 .. sum)\n\t{\n\t\thash[i] = 0;\n\t}\n\tforeach(i; 0 .. arr.length)\n\t{\n\t\tif(hash[sum - arr[i]] != 0)\n\t\t{\n\t\t\tcount += hash[sum - arr[i]];\n\t\t}\n\t\thash[arr[i]] += 1;\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} \n  \n// Driver function to check the above function ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach (i; 0 .. arr.length) \n\t{\n\t\tforeach (j; i + 1 .. arr.length) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} \n  \n// Driver function to check the above function \npublic static void main(String[] args) \n{ \n    long[] arr = { 1, 5, 7, -1, 5 }; \n    long sum = 6; \n    System.out.println(\"Count of pairs is \" + get_pairs_count(arr, sum)); \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. arr.length)\n\t{\n\t\tforeach(j; i+1 .. arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} \n/*\n\tWrite a dthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong get_pairs_count_2(long[] arr, long sum) \n{ \n    long count = 0; // Initialize result \n  \n    // Initialize empty hash set \n    HashSet<long> s = new HashSet<long>(); \n  \n    // Traverse through the given array \n    for (long i = 0; i < arr.length; i++) \n    { \n        // If pair is not present, then store it \n        if (!s.contains(sum - arr[i])) \n            s.add(arr[i]); \n  \n        else // Else increment count \n            count++; \n    } \n    return count; \n} \n/*\n\tWrite a dthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong get_pairs_count_3(long[] arr, long sum) \n{ \n    long count = 0; // Initialize result \n  \n    // Sort the given array \n    arr.sort(); \n  \n    // Initialize two index variables to find the candidate \n    // elements in the sorted array. \n    long l = 0; \n    long r = arr.length - 1; \n  \n    // Loop while there are elements between l and r. \n    while (l < r) \n    { \n        if (arr[l] + arr[r] == sum) \n        { \n            // This pair is the desired output, so",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; \n\tforeach(i; 0..arr.length)\n\t{\n\t\tforeach(j; i+1..arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (int i = 0; i < arr.length; i++) \n\t\tfor (int j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} \n/*\n\tWrite a dthon function to find the first repeating element in an array of integers.\n*/\nlong firstRepeating(long[] arr) \n{ \n    // Initialize index of first repeating element \n    long min = -1; \n  \n    // Creates an empty hashset \n    HashSet<long> set = new HashSet<long>(); \n  \n    // Traverse the input array from right to left \n    for (long i = arr.length - 1; i >= 0; i--) \n    { \n        // If element is already in hash set, update min \n        if (set.contains(arr[i])) \n            min = i; \n  \n        else   // Else add element to hash set \n            set.add(arr[i]); \n    } \n  \n    return min; \n} \n/*\n\tWrite a dthon function to find the first non-repeating character in a string.\n*/\nlong firstNonRepeating(string str) \n{ \n    long[] count = new long[256]; \n  \n    // Fill the count array \n    for (long i = 0; i < str.length; i++) \n        count[str[i]]++; \n  \n    // Traverse string again \n    for (long i = 0; i < str.length; i++) \n        if (count[str[i]] == 1) \n            return i; \n  \n    return -1; \n} \n/*\n\tWrite a dthon function to find the second largest element in an array of integers.\n*/\nlong secondLargest(long[] arr) \n{ \n    // There should be atleast two elements \n    if (arr.length < 2",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{ \n\tlong count = 0; // Initialize result ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n\tWrite a dthon function to find the first missing positive integer in an array.\n*/\nlong first_missing_positive(long[] arr)\n{\n\tlong n = arr.length;\n\tlong max = arr[0];\n\tfor (long i = 1; i < n; i++)\n\t{\n\t\tif (arr[i] > max)\n\t\t{\n\t\t\tmax = arr[i];\n\t\t}\n\t}\n\tlong[] temp = new long[max + 1];\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > 0)\n\t\t{\n\t\t\ttemp[arr[i]] = 1;\n\t\t}\n\t}\n\tfor (long i = 1; i <= max; i++)\n\t{\n\t\tif (temp[i] == 0)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn max + 1;\n}\n/*\n\tWrite a dthon function to find the second largest number in an array.\n*/\nlong second_largest(long[] arr)\n{\n\tlong n = arr.length;\n\tlong max = arr[0];\n\tlong second_max = arr[1];\n\tfor (long i = 1; i < n; i++)\n\t{\n\t\tif (arr[i] > max)\n\t\t{\n\t\t\tsecond_max = max;\n\t\t\tmax = arr[i];\n\t\t}\n\t\telse if (arr[i] > second_max)\n\t\t{\n\t\t\tsecond_max = arr[i];\n\t\t}\n\t}\n\treturn second_max;\n}\n/*\n\tWrite a d",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{\n\tlong n = arr.length;\n\tlong count = 0;\n\tlong[] temp = new long[n];\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\ttemp[i] = sum - arr[i];\n\t}\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (temp[i] == arr[j]) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i, val; arr)\n\t{\n\t\tforeach(j, val2; arr)\n\t\t{\n\t\t\tif(i != j && val + val2 == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t\tcount++;\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tauto map = new Map!(long, long);\n\tforeach(i; 0 .. arr.length)\n\t{\n\t\tif(map.containsKey(arr[i]))\n\t\t{\n\t\t\tcount += map[arr[i]];\n\t\t}\n\t\tif(map.containsKey(sum - arr[i]))\n\t\t{\n\t\t\tmap[sum - arr[i]]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmap[sum - arr[i]] = 1;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (int i = 0; i < arr.length; i++) \n        for (int j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t\tcount++;\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach(long i; 0..arr.length)\n\t{\n\t\tforeach(long j; i+1..arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tfor (long j = i + 1; j < n; j++) \n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. arr.length)\n\t{\n\t\tforeach(j; i+1 .. arr.length)\n\t\t{\n\t\t\tif(arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if ((arr[i] + arr[j]) == sum) \n                count++; \n  \n    return count; \n} \n/*\n\tWrite a dthon function to find the first missing positive number from a list of numbers.\n*/\nlong first_missing_positive(long[] arr) \n{ \n    long n = arr.length; \n  \n    // To mark the occurrence of elements \n    long[] temp = new long[n + 1]; \n  \n    // Mark the occurrences \n    for (long i = 0; i < n; i++) \n        if (arr[i] > 0 && arr[i] <= n) \n            temp[arr[i]] = 1; \n  \n    // Return the first element which didn't \n    // appear in the original array \n    for (long i = 1; i <= n; i++) \n        if (temp[i] == 0) \n            return i; \n  \n    return n + 1; \n} \n/*\n\tWrite a dthon function to find the first missing positive number from a list of numbers.\n*/\nlong first_missing_positive(long[] arr) \n{ \n    long n = arr.length; \n  \n    // To mark the occurrence of elements \n    long[] temp = new long[n + 1]; \n  \n    // Mark the occurrences \n    for (long i = 0; i < n; i++) \n        if (arr[i] > 0 && arr[i] <= n) \n            temp[arr[i]] = 1; \n  \n    // Return the first element which didn't \n    // appear in the original array \n    for (long i = 1; i <= n; i++) \n        if (temp[i] == 0) \n            return i; \n  \n    return n + 1; \n} \n/*\n\tWrite a dth",
    "{ \n    long count = 0; // Initialize result \n  \n    // Consider all possible pairs and check their sums \n    for (long i = 0; i < arr.length; i++) \n        for (long j = i + 1; j < arr.length; j++) \n            if (arr[i] + arr[j] == sum) \n                count++; \n  \n    return count; \n} ",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} ",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tlong n = arr.length;\n\t\n\t// Pick all elements one by one\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\t// See if there is a pair of this element\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t\tif (arr[i] + arr[j] == sum)\n\t\t\t\tcount++;\n\t}\n\treturn count;\n}",
    "{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} \n/*\n\tWrite a dthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input an array of numbers and the sum,\n\t\n*/\nlong get_pairs_count_2(long[] arr, long sum) \n{ \n\tlong count = 0; // Initialize result \n\t\n\t// Consider all possible pairs and check their sums \n\tfor (long i = 0; i < arr.length; i++) \n\t\tfor (long j = i + 1; j < arr.length; j++) \n\t\t\tif ((arr[i] + arr[j]) == sum) \n\t\t\t\tcount++; \n\t\n\treturn count; \n} "
  ]
}