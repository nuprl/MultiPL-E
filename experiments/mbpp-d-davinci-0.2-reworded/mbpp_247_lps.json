{
  "name": "mbpp_247_lps",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n\tWrite a function to find the length of the longest palindromic subsequence in the given string.\n\t\n*/\nlong lps(string str) \n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py",
  "prompt_terminology": "reworded",
  "tests": "unittest\n{\n    alias candidate = lps;\n\n    assert(candidate(\"TENS FOR TENS\") == 5L);\n    assert(candidate(\"CARDIO FOR CARDS\") == 7L);\n    assert(candidate(\"PART OF THE JOURNEY IS PART\") == 9L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\tlong i, j, cl;\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\tfor (cl = 2; cl <= n; cl++) {\n\t\tfor (i = 0; i < n - cl + 1; i++) {\n\t\t\tj = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[long][long] dp = new long[n][n];\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tdp[i][i] = 1;\n\t}\n\tfor (long l = 2; l <= n; l++) \n\t{\n\t\tfor (long i = 0; i < n - l + 1; i++) \n\t\t{\n\t\t\tlong j = i + l - 1;\n\t\t\tif (str[i] == str[j] && l == 2) \n\t\t\t{\n\t\t\t\tdp[i][j] = 2;\n\t\t\t} \n\t\t\telse if (str[i] == str[j]) \n\t\t\t{\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tdp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1;\n\t\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tlong j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse \n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n];\n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower  \n    // diagonal values of table are \n    // useless and not filled in the process.  \n    // The values are filled in a manner similar \n    //  to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[][] = new long[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl = 2; cl <= n; cl++) \n    { \n        for (i = 0; i < n - cl + 1; i++) \n        { \n            j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[][] = new long[n][n];\n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\t\n\t// Create a table to store results of subproblems \n\tlong L[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tforeach (i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n\t// cl is length of substring \n\tforeach (cl; 2 .. n + 1) \n\t{ \n\t\tforeach (i; 0 .. n - cl + 1) \n\t\t{ \n\t\t\tj = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower  \n    // diagonal values of table are \n    // useless and not filled in the process.  \n    // The values are filled in a manner similar \n    // to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/).  \n    // cl is length of substring \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] dp = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tdp[i][i] = 1;\n\t}\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 0 .. n)\n\t\t{\n\t\t\tif(i == j)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(str[i] == str[j])\n\t\t\t{\n\t\t\t\tdp[i][j] = 2 + dp[i+1][j-1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dp[0][n-1];\n}",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[][] = new long[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n\t// cl is length of substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[][] = new long[n][n]; // Create a table to store results of subproblems \n  \n  \n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n  \n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\tlong i, j, cl;\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\tfor (cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tj = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tfor (long i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tlong j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}",
    "{ \n   int n = str.length; \n   int i, j, cl; \n   int L[n][n];  \n  \n   for (i = 0; i < n; i++) \n      L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] dp = new long[n][n];\n\t\n\tfor (long i = 0; i < n; i++)\n\t\tdp[i][i] = 1;\n\t\n\tfor (long i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (str[i] == str[j])\n\t\t\t\tdp[i][j] = 2 + dp[i + 1][j - 1];\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[n][n]; \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\treturn L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tauto L = new int[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tdp[i][i] = 1;\n\t\n\tfor (int len = 2; len <= n; len++) \n\t{\n\t\tfor (int i = 0; i < n - len + 1; i++) \n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (str[i] == str[j] && len == 2)\n\t\t\t\tdp[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{ \n    size_t n = str.length(); \n    size_t i, j, cl; \n    auto L = new int[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/). \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tauto L = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n];  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n    return L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tforeach(i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\tforeach(sublen; 2 .. n + 1) \n\t{ \n\t\tforeach(i; 0 .. n - sublen + 1) \n\t\t{ \n\t\t\tlong j = i + sublen - 1; \n\t\t\tif (str[i] == str[j] && sublen == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tfor (long i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tlong j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n    for (long cl = 2; cl <= n; cl++) { \n        for (long i = 0; i < n - cl + 1; i++) { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n    return L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    auto L = new long[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower  \n    // diagonal values of table are \n    // useless and not filled in the process.  \n    // The values are filled in a manner similar \n    // to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(sublen; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - sublen + 1)\n\t\t{\n\t\t\tlong j = i + sublen - 1;\n\t\t\tif(str[i] == str[j] && sublen == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n];  \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower  \n    // diagonal values of table are \n    // useless and not filled in the process.  \n    // The values are filled in a manner similar \n    // to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n];  \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\treturn L[0][n-1]; \n} ",
    "{ \n   int n = str.length; \n   int i, j, cl; \n   int L[][] = new int[n][n];  \n  \n   for (i = 0; i < n; i++) \n      L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n    int n = str.length; \n    int i, j, cl; \n    auto L = new int[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n, n]; ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[n][n];\n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n    return L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[n][n]; // Create a table to store results of subproblems ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl = 2; cl <= n; cl++) { \n        for (i = 0; i < n - cl + 1; i++) { \n            j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[n][n]; // Create a table to store results of subproblems ",
    "{ \n\t// Create a table to store results of subproblems \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tforeach(i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). clang-format off \n\tforeach(cl; 2 .. n + 1) \n\t\tforeach(i; 0 .. n - cl + 1) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n]; // Create a table to store results of subproblems \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] dp = new long[n][n];\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tdp[i][i] = 1;\n\t}\n\tfor (long l = 2; l <= n; l++) \n\t{\n\t\tfor (long i = 0; i < n - l + 1; i++) \n\t\t{\n\t\t\tlong j = i + l - 1;\n\t\t\tif (str[i] == str[j] && l == 2)\n\t\t\t{\n\t\t\t\tdp[i][j] = 2;\n\t\t\t}\n\t\t\telse if (str[i] == str[j])\n\t\t\t{\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tauto L = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(cl; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - cl + 1)\n\t\t{\n\t\t\tlong j = i + cl - 1;\n\t\t\tif(str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tforeach (i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\tforeach (sublen; 2 .. n + 1) \n\t{ \n\t\tforeach (i; 0 .. n - sublen + 1) \n\t\t{ \n\t\t\tlong j = i + sublen - 1; \n\t\t\tif (str[i] == str[j] && sublen == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(sublen; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - sublen + 1)\n\t\t{\n\t\t\tlong j = i + sublen - 1;\n\t\t\tif(str[i] == str[j] && sublen == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[n][n];\n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n    return L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    auto L = new long[n,n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i,i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/). \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i,j] = 2; \n            else if (str[i] == str[j]) \n               L[i,j] = L[i+1,j-1] + 2; \n            else\n               L[i,j] = max(L[i,j-1], L[i+1,j]); \n        } \n    } \n  \n    return L[0,n-1]; \n} ",
    "{ \n    int n = str.length; \n    int i, j, cl; \n    int L[][] = new int[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl = 2; cl <= n; cl++) { \n        for (i = 0; i < n - cl + 1; i++) { \n            j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tfor (long i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t\n\tfor (long cl = 2; cl <= n; cl++)\n\t{\n\t\tfor (long i = 0; i < n - cl + 1; i++)\n\t\t{\n\t\t\tlong j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tforeach(i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n\t// cl is length of substring \n\tforeach(cl; 2 .. n + 1) \n\t{ \n\t\tforeach(i; 0 .. n - cl + 1) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] dp = new long[n][n];\n\t\n\tfor (long i = 0; i < n; i++) \n\t\tdp[i][i] = 1;\n\t\n\tfor (long l = 2; l <= n; l++) \n\t{\n\t\tfor (long i = 0; i < n - l + 1; i++) \n\t\t{\n\t\t\tlong j = i + l - 1;\n\t\t\tif (str[i] == str[j] && l == 2) \n\t\t\t\tdp[i][j] = 2;\n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse \n\t\t\t\tdp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{ \n    size_t n = str.length(); \n    size_t i, j, cl; \n    auto L = new int[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower  \n    // diagonal values of table are \n    // useless and not filled in the process.  \n    // The values are filled in a manner similar \n    // to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\tlong i, j, cl; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n]; // Create a table to store results of subproblems \n  \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // http://www.geeksforgeeks.org/archives/15553). cl is length of \n    // substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n   long n = str.length; \n   long i, j, cl; \n   long L[][] = new long[n][n];  \n  \n   for (i = 0; i < n; i++) \n      L[i][i] = 1; \n   \n   for (cl=2; cl<=n; cl++) \n   { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n   } \n  \n   return L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl = 2; cl <= n; cl++) { \n        for (i = 0; i < n - cl + 1; i++) { \n            j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tforeach(i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n\t// cl is length of substring \n\tforeach(cl; 2 .. n + 1) \n\t{ \n\t\tforeach(i; 0 .. n - cl + 1) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n];\n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; ",
    "{ \n   long n = str.length; \n   long i, j, cl; \n   auto L = new long[n,n]; \n  \n   // Strings of length 1 are palindrome of lentgh 1 \n   for (i = 0; i < n; i++) \n      L[i,i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/). \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i,j] = 2; \n            else if (str[i] == str[j]) \n               L[i,j] = L[i+1,j-1] + 2; \n            else\n               L[i,j] = max(L[i,j-1], L[i+1,j]); \n        } \n    } \n  \n    return L[0,n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    auto L = new long[n, n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i, i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl = 2; cl <= n; cl++) \n    { \n        for (i = 0; i < n - cl + 1; i++) \n        { \n            j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i, j] = 2; \n            else if (str[i] == str[j]) \n                L[i, j] = L[i + 1, j - 1] + 2; \n            else\n                L[i, j] = max(L[i, j - 1], L[i + 1, j]); \n        } \n    } \n  \n    return L[0, n - 1]; \n} \n  \n// Driver program to test above functions ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\tforeach(i, j; dp)\n\t\tdp[i][j] = 0;\n\t\n\tforeach(i; 0 .. n)\n\t\tdp[i][i] = 1;\n\t\n\tforeach(i; 0 .. n - 1)\n\t{\n\t\tif(str[i] == str[i + 1])\n\t\t\tdp[i][i + 1] = 2;\n\t\telse\n\t\t\tdp[i][i + 1] = 1;\n\t}\n\t\n\tforeach(k; 3 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - k + 1)\n\t\t{\n\t\t\tint j = i + k - 1;\n\t\t\tif(str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tdp[i][i] = 1;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; i + 1 .. n)\n\t\t{\n\t\t\tif(str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tforeach(i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\tforeach(sublen; 2 .. n + 1) \n\t{ \n\t\tforeach(i; 0 .. n - sublen + 1) \n\t\t{ \n\t\t\tlong j = i + sublen - 1; \n\t\t\tif (str[i] == str[j] && sublen == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tdp[i][i] = 1;\n\t\n\tforeach(sublen; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - sublen + 1)\n\t\t{\n\t\t\tint j = i + sublen - 1;\n\t\t\tif(str[i] == str[j] && sublen == 2)\n\t\t\t\tdp[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] L = new int[n][n];\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t\n\tfor (int cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (int i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tint j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tfor (long i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tlong j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n];  \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\t\n\t// Create a table to store results of subproblems \n\tint[][] L = new int[n][n]; \n\t\n\t// Strings of length 1 are palindrome of length 1 \n\tfor (int i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (int cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (int i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tint j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n];  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n    return L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\tfor (int i = 0; i < n; i++)\n\t\tdp[i][i] = 1;\n\tfor (int len = 2; len <= n; len++) \n\t{\n\t\tfor (int i = 0; i < n - len + 1; i++) \n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (str[i] == str[j] && len == 2)\n\t\t\t\tdp[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\treturn L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n];  \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\treturn L[0][n-1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\tfor (int i = 0; i < n; i++) \n\t\tdp[i][i] = 1;\n\t\n\tfor (int len = 2; len <= n; len++) \n\t{\n\t\tfor (int i = 0; i < n - len + 1; i++) \n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (str[i] == str[j] && len == 2) \n\t\t\t\tdp[i][j] = 2;\n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse \n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[][] = new long[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n];  \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n];\n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    auto L = new long[n, n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i, i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl = 2; cl <= n; cl++) { \n        for (i = 0; i < n - cl + 1; i++) { \n            j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i, j] = 2; \n            else if (str[i] == str[j]) \n                L[i, j] = L[i + 1, j - 1] + 2; \n            else\n                L[i, j] = max(L[i, j - 1], L[i + 1, j]); \n        } \n    } \n  \n    return L[0, n - 1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] dp = new long[n][n];\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tdp[i][i] = 1;\n\t}\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tfor (long j = 0; j < n - i + 1; j++) \n\t\t{\n\t\t\tlong k = i + j - 1;\n\t\t\tif (str[j] == str[k] && i == 2) \n\t\t\t{\n\t\t\t\tdp[j][k] = 2;\n\t\t\t} \n\t\t\telse if (str[j] == str[k]) \n\t\t\t{\n\t\t\t\tdp[j][k] = dp[j + 1][k - 1] + 2;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tdp[j][k] = max(dp[j][k - 1], dp[j + 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\t// Strings of length 1 are palindrome of length 1\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\t\n\tforeach(sublen; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - sublen + 1)\n\t\t{\n\t\t\tlong j = i + sublen - 1;\n\t\t\tif(str[i] == str[j] && sublen == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[][] = new long[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n\t// cl is length of substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n    int n = str.length; \n    int i, j, cl; \n    auto L = new int[n, n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i, i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // http://www.geeksforgeeks.org/archives/15553). cl is length of \n    // substring \n    for (cl = 2; cl <= n; cl++) \n    { \n        for (i = 0; i < n - cl + 1; i++) \n        { \n            j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i, j] = 2; \n            else if (str[i] == str[j]) \n                L[i, j] = L[i + 1, j - 1] + 2; \n            else\n                L[i, j] = max(L[i, j - 1], L[i + 1, j]); \n        } \n    } \n  \n    return L[0, n - 1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] L = new int[n][n];\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t\n\tfor (int cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (int i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tint j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(sublen; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - sublen + 1)\n\t\t{\n\t\t\tlong j = i + sublen - 1;\n\t\t\tif(str[i] == str[j] && sublen == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n];\n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n    return L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] dp = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tdp[i][i] = 1;\n\t}\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; i + 1 .. n)\n\t\t{\n\t\t\tif(str[i] == str[j])\n\t\t\t{\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[n][n];  \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    auto L = new long[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n   int n = str.length; \n   int i, j, cl; \n   int L[][] = new int[n][n];  \n  \n   for (i = 0; i < n; i++) \n      L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\tfor (int i = 0; i < n; i++)\n\t\tdp[i][i] = 1;\n\tfor (int len = 2; len <= n; len++) \n\t{\n\t\tfor (int i = 0; i < n - len + 1; i++) \n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (str[i] == str[j] && len == 2)\n\t\t\t\tdp[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) { \n        for (long i = 0; i < n - cl + 1; i++) { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tfor (long i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tlong j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(cl; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - cl + 1)\n\t\t{\n\t\t\tlong j = i + cl - 1;\n\t\t\tif(str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new int[n][n]; ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tdp[i][i] = 1;\n\t\n\tforeach(sublen; 1 .. n)\n\t{\n\t\tforeach(i; 0 .. n - sublen)\n\t\t{\n\t\t\tint j = i + sublen;\n\t\t\tif(str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[][] = new long[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[][] = new long[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[n][n];  \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n];  \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[n][n];\n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i][i] = 1;\n\t}\n\t\n\tfor (int len = 2; len <= n; len++) {\n\t\tfor (int i = 0; i < n - len + 1; i++) {\n\t\t\tint j = i + len - 1;\n\t\t\tif (str[i] == str[j] && len == 2) {\n\t\t\t\tdp[i][j] = 2;\n\t\t\t} else if (str[i] == str[j]) {\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tforeach (i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\tforeach (cl; 2 .. n + 1) \n\t{ \n\t\tforeach (i; 0 .. n - cl + 1) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n\t// Create a table to store results of subproblems \n\tlong[][] dp = new long[str.length][str.length]; \n\t\n\t// Strings of length 1 are palindrome of length 1 \n\tfor (long i = 0; i < str.length; i++) \n\t\tdp[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n\t// cl is length of substring \n\tfor (long cl = 2; cl <= str.length; cl++) \n\t{ \n\t\tfor (long i = 0; i < str.length - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tdp[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i][j - 1], dp[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn dp[0][str.length - 1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(sublen; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - sublen + 1)\n\t\t{\n\t\t\tlong j = i + sublen - 1;\n\t\t\tif(str[i] == str[j] && sublen == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tdp[i][i] = 1;\n\t\n\tfor (int len = 2; len <= n; len++) {\n\t\tfor (int i = 0; i < n - len + 1; i++) {\n\t\t\tint j = i + len - 1;\n\t\t\tif (str[i] == str[j] && len == 2)\n\t\t\t\tdp[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of length 1 \n\tforeach (i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tforeach (cl; 2 .. n + 1) \n\t{ \n\t\tforeach (i; 0 .. n - cl + 1) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // http://www.geeksforgeeks.org/archives/15553). clang-format off\n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n\t// cl is length of substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} \n  \n// Driver program ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] L = new int[n][n];\n\t\n\tfor (int i = 0; i < n; i++) \n\t\tL[i][i] = 1;\n\t\n\tfor (int cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (int i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tint j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse \n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n];  \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[n][n];\n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[long][long] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tL[i][i] = 1;\n\t}\n\t\n\tforeach(i; 0 .. n - 1)\n\t{\n\t\tif(str[i] == str[i + 1])\n\t\t{\n\t\t\tL[i][i + 1] = 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tL[i][i + 1] = 1;\n\t\t}\n\t}\n\t\n\tforeach(k; 3 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - k + 1)\n\t\t{\n\t\t\tlong j = i + k - 1;\n\t\t\tif(str[i] == str[j])\n\t\t\t{\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\t// Strings of length 1 are palindrome of length 1\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(sublen; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - sublen + 1)\n\t\t{\n\t\t\tlong j = i + sublen - 1;\n\t\t\tif(str[i] == str[j] && sublen == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tint n = str.length;\n\tint i, j, cl;\n\tint[][] L = new int[n][n];\n\t\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t\n\tfor (cl = 2; cl <= n; cl++)\n\t{\n\t\tfor (i = 0; i < n - cl + 1; i++)\n\t\t{\n\t\t\tj = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n   int n = str.length; \n   int i, j, cl; \n   int L[n][n];  // Create a table to store results of subproblems \n  \n  \n   // Strings of length 1 are palindrome of lentgh 1 \n   for (i = 0; i < n; i++) \n      L[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/). \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\tfor (int i = 0; i < n; i++) \n\t{\n\t\tdp[i][i] = 1;\n\t}\n\tfor (int len = 2; len <= n; len++) \n\t{\n\t\tfor (int i = 0; i < n - len + 1; i++) \n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (str[i] == str[j] && len == 2) \n\t\t\t{\n\t\t\t\tdp[i][j] = 2;\n\t\t\t} \n\t\t\telse if (str[i] == str[j]) \n\t\t\t{\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(sublen; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - sublen + 1)\n\t\t{\n\t\t\tlong j = i + sublen - 1;\n\t\t\tif(str[i] == str[j] && sublen == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] dp = new long[n][n];\n\t\n\tfor (long i = 0; i < n; i++)\n\t\tdp[i][i] = 1;\n\t\n\tfor (long i = n - 2; i >= 0; i--)\n\t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (str[i] == str[j])\n\t\t\t\tdp[i][j] = 2 + dp[i + 1][j - 1];\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{ \n\tlong n = str.length;\n\tlong i, j, cl; \n\tlong L[][] = new long[n][n];\n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n];  \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\t// length 1\n\tfor (int i = 0; i < n; i++)\n\t\tdp[i][i] = 1;\n\t\n\t// length 2\n\tfor (int i = 0; i < n - 1; i++)\n\t\tif (str[i] == str[i + 1])\n\t\t\tdp[i][i + 1] = 2;\n\t\telse\n\t\t\tdp[i][i + 1] = 1;\n\t\n\t// length 3 and above\n\tfor (int k = 3; k <= n; k++) {\n\t\tfor (int i = 0; i < n - k + 1; i++) {\n\t\t\tint j = i + k - 1;\n\t\t\tif (str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{\n\tint n = str.length;\n\tint[][] dp = new int[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tdp[i][i] = 1;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; i + 1 .. n)\n\t\t{\n\t\t\tif(str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tforeach (i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\tforeach (sublen; 2 .. n + 1) \n\t{ \n\t\tforeach (i; 0 .. n - sublen + 1) \n\t\t{ \n\t\t\tlong j = i + sublen - 1; \n\t\t\tif (str[i] == str[j] && sublen == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tforeach(i; 0 .. n) \n\t\tL[i][i] = 1; \n\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). clang-format off\n\tforeach(cl; 2 .. n) \n\t{ \n\t\tforeach(i; 0 .. n - cl + 1) \n\t\t{ \n\t\t\tint j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t// clang-format on\n\t\n\treturn L[0][n - 1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n];  \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\treturn L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tlong L[][] = new long[n][n]; // Create a table to store results of subproblems \n\t\n\t// Strings of length 1 are palindrome of lentgh 1 \n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\t\n\t// Build the table. Note that the lower diagonal values of table are \n\t// useless and not filled in the process. The values are filled in a \n\t// manner similar to Matrix Chain Multiplication DP solution (See \n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of \n\t// substring \n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tlong n = str.length; \n\tlong i, j, cl; \n\tauto L = new long[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; ",
    "{ \n\tlong n = str.length; \n\tlong[][] L = new long[n][n]; \n\t\n\tfor (long i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (long cl = 2; cl <= n; cl++) \n\t{ \n\t\tfor (long i = 0; i < n - cl + 1; i++) \n\t\t{ \n\t\t\tlong j = i + cl - 1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n - 1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(cl; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - cl + 1)\n\t\t{\n\t\t\tlong j = i + cl - 1;\n\t\t\tif(str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[][] = new int[n][n]; \n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; \n\t\n\tfor (cl=2; cl<=n; cl++) \n\t{ \n\t\tfor (i=0; i<n-cl+1; i++) \n\t\t{ \n\t\t\tj = i+cl-1; \n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t\tL[i][j] = 2; \n\t\t\telse if (str[i] == str[j]) \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2; \n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\t\t} \n\t} \n\t\n\treturn L[0][n-1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long[][] L = new long[n][n]; \n  \n    for (long i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (long cl = 2; cl <= n; cl++) \n    { \n        for (long i = 0; i < n - cl + 1; i++) \n        { \n            long j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    auto L = new long[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl = 2; cl <= n; cl++) \n    { \n        for (i = 0; i < n - cl + 1; i++) \n        { \n            j = i + cl - 1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i + 1][j - 1] + 2; \n            else\n                L[i][j] = max(L[i][j - 1], L[i + 1][j]); \n        } \n    } \n  \n    return L[0][n - 1]; \n} ",
    "{ \n    int n = str.length; \n    int i, j, cl; \n    auto L = new int[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower  \n    // diagonal values of table are \n    // useless and not filled in the process.  \n    // The values are filled in a \n    // manner similar to Matrix Chain \n    // Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{\n\tlong n = str.length;\n\tlong[][] dp = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tdp[i][i] = 1;\n\t\n\tforeach(i; 0 .. n - 1)\n\t\tif(str[i] == str[i + 1])\n\t\t\tdp[i][i + 1] = 2;\n\t\telse\n\t\t\tdp[i][i + 1] = 1;\n\t\n\tforeach(i; 0 .. n - 2)\n\t{\n\t\tforeach(j; i + 2 .. n)\n\t\t{\n\t\t\tif(str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\t\n\treturn dp[0][n - 1];\n}",
    "{\n\tlong n = str.length;\n\tlong[][] L = new long[n][n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i][i] = 1;\n\t\n\tforeach(sublen; 2 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - sublen + 1)\n\t\t{\n\t\t\tlong j = i + sublen - 1;\n\t\t\tif(str[i] == str[j] && sublen == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\t\n\treturn L[0][n - 1];\n}",
    "{ \n\tauto n = str.length;\n\tauto L = new int[n, n];\n\t\n\tforeach(i; 0 .. n)\n\t\tL[i, i] = 1;\n\t\n\tforeach(i; 0 .. n - 1)\n\t{\n\t\tif(str[i] == str[i + 1])\n\t\t\tL[i, i + 1] = 2;\n\t\telse\n\t\t\tL[i, i + 1] = 1;\n\t}\n\t\n\tforeach(k; 3 .. n + 1)\n\t{\n\t\tforeach(i; 0 .. n - k + 1)\n\t\t{\n\t\t\tauto j = i + k - 1;\n\t\t\tif(str[i] == str[j])\n\t\t\t\tL[i, j] = L[i + 1, j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i, j] = max(L[i, j - 1], L[i + 1, j]);\n\t\t}\n\t}\n\t\n\treturn L[0, n - 1];\n} ",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{\n\tint n = str.length;\n\tint[][] L = new int[n][n];\n\t\n\tfor (int i = 0; i < n; i++) \n\t{\n\t\tL[i][i] = 1;\n\t}\n\t\n\tfor (int cl = 2; cl <= n; cl++) \n\t{\n\t\tfor (int i = 0; i < n - cl + 1; i++) \n\t\t{\n\t\t\tint j = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2) \n\t\t\t{\n\t\t\t\tL[i][j] = 2;\n\t\t\t} \n\t\t\telse if (str[i] == str[j]) \n\t\t\t{\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tL[i][j] = max(L[i][j - 1], L[i + 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}",
    "{ \n    long n = str.length; \n    long i, j, cl; \n    long L[][] = new long[n][n]; // Create a table to store results of subproblems \n  \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower diagonal values of table are \n    // useless and not filled in the process. The values are filled in a \n    // manner similar to Matrix Chain Multiplication DP solution (See \n    // http://www.geeksforgeeks.org/archives/15553). cl is length of \n    // substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n               L[i][j] = 2; \n            else if (str[i] == str[j]) \n               L[i][j] = L[i+1][j-1] + 2; \n            else\n               L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n    int n = str.length; \n    int i, j, cl; \n    auto L = new int[n][n]; \n  \n    // Strings of length 1 are palindrome of lentgh 1 \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    // Build the table. Note that the lower  \n    // diagonal values of table are \n    // useless and not filled in the process.  \n    // The values are filled in a manner similar \n    // to Matrix Chain Multiplication DP solution (See \n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ \n    // cl is length of substring \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} ",
    "{ \n\tint n = str.length; \n\tint i, j, cl; \n\tint L[n][n];\n\t\n\tfor (i = 0; i < n; i++) \n\t\tL[i][i] = 1; ",
    "{ \n    int n = str.length; \n    int i, j, cl; \n    auto L = new int[n][n]; \n  \n    for (i = 0; i < n; i++) \n        L[i][i] = 1; \n  \n    for (cl=2; cl<=n; cl++) \n    { \n        for (i=0; i<n-cl+1; i++) \n        { \n            j = i+cl-1; \n            if (str[i] == str[j] && cl == 2) \n                L[i][j] = 2; \n            else if (str[i] == str[j]) \n                L[i][j] = L[i+1][j-1] + 2; \n            else\n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n        } \n    } \n  \n    return L[0][n-1]; \n} "
  ]
}