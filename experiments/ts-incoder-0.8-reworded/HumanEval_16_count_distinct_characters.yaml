name: HumanEval_16_count_distinct_characters
language: ts
prompt: "//Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n// >>> count_distinct_characters(\"xyzXYZ\")\n// 3\n// >>>\
  \ count_distinct_characters(\"Jerry\")\n// 4\nfunction count_distinct_characters(string:\
  \ string): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = count_distinct_characters;\n  assert.deepEqual(candidate(\"\
  \"),0);\n  assert.deepEqual(candidate(\"abcde\"),5);\n  assert.deepEqual(candidate(\"\
  abcdecadeCADE\"),5);\n  assert.deepEqual(candidate(\"aaaaAAAAaaaa\"),1);\n  assert.deepEqual(candidate(\"\
  Jerry jERRY JeRRRY\"),5);\n}\n\ntest();"
completions: ["  var counter: number = 0;\n  var i = 0;\n  while (i < string.length)\
    \ {\n    if (string.charAt(i) !== string.charAt(i + 1)) {\n      counter++;\n\
    \    }\n    i++;\n  }\n  return counter;\n}\n", "    const result = new Set<string>();\n\
    \    for (let i = 0; i < string.length; i++) {\n        const char = string.charAt(i);\n\
    \        result.add(char.toLowerCase());\n        result.add(char.toUpperCase());\n\
    \    }\n    return result.size;\n}\n", "\t// First character should be uppercase\
    \ to properly check case (upper vs lower)\n\tlet first = string.toLowerCase()[0];\n\
    \n\t// Loop over all remaining characters\n\tlet count = 0;\n\tfor (let char of\
    \ string.slice(1)) {\n\t\tlet index = first.toUpperCase().indexOf(char);\n\t\t\
    count += index === -1 ? 1 : 0;\n\t\tfirst = char.toUpperCase();\n\t}\n\n\treturn\
    \ count;\n}\n", "  if (string.length > 0) {\n    const hash = {};\n    const map\
    \ = {};\n    for (let i = 0; i < string.length; i++) {\n      const char = string[i];\n\
    \      const hashKey = char.toLowerCase();\n      if (hash[hashKey]) {\n     \
    \   hash[hashKey] = hash[hashKey] + 1;\n        map[char] = map[char] + 1;\n \
    \     } else {\n        hash[hashKey] = 1;\n        map[char] = 1;\n      }\n\
    \    }\n    return Object.keys(map).length;\n  } else {\n    return 0;\n  }\n\
    }\n", "    let distinct_chars = string.split('')\n        .map(char => char.toLowerCase())\n\
    \        .reduce((acc, cur) => (acc.indexOf(cur) === -1) ? acc.concat(cur) : acc,\
    \ []);\n    return distinct_chars.length;\n}\n", "  const distinctCharacterSet\
    \ = new Set<string>([...string]);\n  return distinctCharacterSet.size;\n}\n",
  "    const array = string.split('');\n    const char_array = [];\n\n    for (let\
    \ i = 0; i < array.length; ++i) {\n        let char = array[i];\n\n        if\
    \ (char_array.indexOf(char) === -1) {\n            char_array.push(char);\n  \
    \      }\n    }\n\n    return char_array.length;\n}\n", "  let uniqueChars = [];\n\
    \  let charCount = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    if (uniqueChars.indexOf(string.charAt(i))\
    \ === -1) {\n      uniqueChars.push(string.charAt(i));\n      charCount++;\n \
    \   }\n  }\n\n  return charCount;\n}\n", "  const chars = string.split('');\n\
    \  const map = new Map(chars);\n  return chars.reduce((count: number, char: string)\
    \ => {\n    if (map.has(char)) count++;\n    return count;\n  }, 0);\n}\n", " \
    \   const characterSet = new Set(string);\n    return Array.from(characterSet).length;\n\
    }\n", "    if (string === \"\") {\n        return 0;\n    }\n    let char_counts:\
    \ number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let character\
    \ = string[i];\n        let lower_character = character.toLowerCase();\n     \
    \   if (char_counts.some(x => x === lower_character)) {\n            char_counts[lower_character]++;\n\
    \        } else {\n            char_counts.push(1);\n        }\n    }\n    return\
    \ char_counts.reduce((x, y) => x + y);\n}\n", "  var count = 0;\n  var i = 0;\n\
    \  while (i < string.length) {\n    var char = string[i];\n    var lower = char.toLowerCase();\n\
    \    if (string[i] !== lower && string[i + 1] !== lower) {\n      count++;\n \
    \   }\n    i++;\n  }\n  return count;\n}\n", "\tlet hash: Map<string, number>\
    \ = new Map()\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i]\n\
    \t\tlet count = hash.get(char)\n\t\tif (count === undefined) {\n\t\t\thash.set(char,\
    \ 1) // count 1 for this character\n\t\t} else {\n\t\t\thash.set(char, count +\
    \ 1) // count 1 for this character and all other characters which have this character\n\
    \t\t}\n\t}\n\treturn hash.size // the number of unique characters\n}\n", "  if\
    \ (string.length === 0) {\n    return 0;\n  }\n  const map: { [key: string]: number\
    \ } = {};\n  const counts: number[] = [];\n  for (let i = 0; i < string.length;\
    \ i++) {\n    const char = string[i];\n    let count = map[char];\n    if (count\
    \ === undefined) {\n      count = 1;\n    } else {\n      count += 1;\n    }\n\
    \    map[char] = count;\n    counts.push(count);\n  }\n  return counts[counts.length\
    \ - 1];\n}\n", "    return string.toLowerCase().split('').sort().join('').length;\n\
    }\n", "\tif (string == null || string === \"\") {\n\t\treturn 0;\n\t}\n\n\treturn\
    \ string.split(\"\").reduce((count: number, c: any) => {\n\t\tif (c === c.toUpperCase())\
    \ {\n\t\t\tcount++;\n\t\t} else {\n\t\t\tcount--;\n\t\t}\n\n\t\treturn count;\n\
    \t}, 0);\n}\n", "    const char_counts = new Map<string, number>();\n\n    for\
    \ (const char of string) {\n        if (char_counts.has(char)) {\n           \
    \ char_counts.get(char) += 1;\n        } else {\n            char_counts.set(char,\
    \ 1);\n        }\n    }\n\n    return char_counts.size;\n}\n\n<|/ file source=gitlab\
    \ |>", "\tlet chars_used = new Set<string>();\n\tfor (let char of string) {\n\t\
    \tchars_used.add(char.toLowerCase());\n\t\tchars_used.add(char.toUpperCase());\n\
    \t}\n\treturn chars_used.size;\n}\n", "  return countBy(string, (c) => [c.toUpperCase(),\
    \ c.toLowerCase()].sort().join(\"\"));\n}\n", "  let chars: number[] = [];\n \
    \ for (let i = 0; i < string.length; i++) {\n    let c = string[i];\n    if (chars.indexOf(c)\
    \ > -1) {\n      chars[chars.indexOf(c)]++;\n    } else {\n      chars.push(c);\n\
    \    }\n  }\n  return chars.length;\n}\n", "\tconst alphabet: string = \"abcdefghijklmnopqrstuvwxyz\"\
    .split(\"\");\n\n\tlet count = 0;\n\n\tfor (let i = 0; i < string.length; i++)\
    \ {\n\t\tconst char = string.charAt(i);\n\t\tconst idx = alphabet.indexOf(char);\n\
    \t\tif (idx === -1) {\n\t\t\tthrow new Error(`The character ${char} is not in\
    \ the alphabet`);\n\t\t}\n\t\talphabet[idx] = null;\n\t\tcount++;\n\t}\n\n\treturn\
    \ count;\n}\n", "\tlet chars = new Set<string>();\n\n\tstring.split(\"\").forEach((char:\
    \ string) => {\n\t\tchars.add(char.toLowerCase());\n\t});\n\n\treturn chars.size;\n\
    }\n", "  let counter: number = 0\n  for (let i = 0; i < string.length; i++) {\n\
    \    const character = string.charAt(i)\n    if (character === character.toUpperCase())\
    \ {\n      counter += 2\n    } else if (character === character.toLowerCase())\
    \ {\n      counter += 1\n    } else {\n      counter++\n    }\n  }\n  return counter\n\
    }\n", "  if (string.length === 0) {\n    return 0;\n  }\n\n  let lastChar: string\
    \ | undefined;\n  let lastCount = 0;\n  for (let i = 0; i < string.length; i++)\
    \ {\n    const char = string[i];\n    lastChar = char;\n    if (char.charCodeAt(0)\
    \ > 96) {\n      lastCount++;\n    }\n  }\n  return lastCount;\n}\n", "\tvar count\
    \ = 0, i = 0;\n\twhile (i < string.length) {\n\t\tvar character = string[i];\n\
    \t\tif (character === string.charAt(i)) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\t\
    count = 1;\n\t\t}\n\t\ti++;\n\t}\n\treturn count;\n}\n", "  const chars = new\
    \ Set<string>();\n  string.split('').forEach((char: string) => {\n    chars.add(char.toLowerCase());\n\
    \  });\n  return chars.size;\n}\n", "  const chars: string[] = string\n    .split(\"\
    \")\n    .map((char: string) => char.toLowerCase())\n    .sort();\n\n  let numChars\
    \ = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (i > 0) {\n      numChars++;\n\
    \    }\n    if (chars[i] !== chars[i - 1]) {\n      numChars++;\n    }\n  }\n\
    \  return numChars;\n}\n", "\treturn string.replace(/[^A-Z ]/g, \"\");\n}\n",
  "    let count = 0;\n    let char_code = 0;\n    for (let i = 0; i < string.length;\
    \ i++) {\n        if (string[i] === string.charAt(char_code)) {\n            count++;\n\
    \        } else {\n            count = 0;\n        }\n        if (count === 26)\
    \ {\n            char_code++;\n        }\n    }\n    return count;\n}", "  //\
    \ Use an object and keep track of how many times you see a char.\n  const lookup:\
    \ Map<string, number> = new Map();\n  string.split('').forEach(char => lookup.set(char,\
    \ lookup.get(char) + 1 || 1));\n  return lookup.get('z') || 0;\n}\n", "  const\
    \ stringLower = string.toLowerCase();\n  return new Set<string>([...stringLower]).size;\n\
    }\n", "  if (string.length == 0) return 0;\n  return string.split('').filter((_,index)\
    \ => string.indexOf(string[index]) === index).length + 1;\n}\n", "  const chars:\
    \ string[] = string.split('')\n  let uniqueCharsLength = 0\n\n  for (let i = 0;\
    \ i < chars.length; i++) {\n    if (chars.indexOf(chars[i]) === chars.lastIndexOf(chars[i]))\
    \ {\n      uniqueCharsLength++\n    }\n  }\n\n  return uniqueCharsLength\n}\n",
  "    // Use Set object instead of Array to not have duplicate characters.\n    const\
    \ set = new Set<string>();\n    for (const char of string) {\n        if (set.has(char))\
    \ set.delete(char);\n        else set.add(char);\n    }\n    return set.size;\n\
    }\n", "    // Count the number of unique characters\n    var count = [0];\n  \
    \  for (var i = 1; i < string.length; i++) {\n        var char = string[i];\n\
    \        if (char.toLowerCase() === char) {\n            count[count[i - 1] +\
    \ 1]++;\n        } else {\n            count[0]++;\n        }\n    }\n    return\
    \ count;\n}\n", "  var uniqueSet = new Set<string>();\n  for (let i = 0; i < string.length;\
    \ i++) {\n    let char = string[i].toLowerCase();\n    if (!uniqueSet.has(char))\
    \ {\n      uniqueSet.add(char);\n    }\n  }\n  return uniqueSet.size;\n}\n", "\t\
    let characterMap: Map<string, number>;\n\tif (string === null) {\n\t\tcharacterMap\
    \ = new Map();\n\t} else {\n\t\tcharacterMap = count_distinct_characters(string,\
    \ string + \"\", new Map());\n\t}\n\n\treturn characterMap.size;\n}\n", "\tlet\
    \ distinctCharacters = 0;\n\tlet charCounter = 0;\n\tfor (let i = 0; i < string.length;\
    \ i++) {\n\t\tlet character = string[i].toLowerCase();\n\t\tlet currentCharCounter\
    \ = charCounter;\n\t\tfor (let j = 0; j < charCounter; j++) {\n\t\t\tif (character\
    \ == string[charCounter]) {\n\t\t\t\tcurrentCharCounter++;\n\t\t\t}\n\t\t}\n\t\
    \tdistinctCharacters += currentCharCounter;\n\t\tcharCounter = currentCharCounter;\n\
    \t}\n\treturn distinctCharacters;\n}\n", "\tlet chars = string.split(\"\");\n\t\
    let uniqueChars = chars.filter(c => c.charCodeAt(0) > 0).length;\n\treturn uniqueChars;\n\
    }\n", "    const chars = string.split(\"\");\n    let total = 0;\n    for (let\
    \ i = 0; i < chars.length; ++i) {\n        const char = chars[i];\n        const\
    \ lower = char.toLowerCase();\n        const upper = char.toUpperCase();\n   \
    \     if (lower === upper) {\n            ++total;\n        } else {\n       \
    \     total *= 2;\n        }\n    }\n    return total;\n}\n", "  return string.split(\"\
    \").reduce((acc, curr) => {\n    return acc + (curr.toLowerCase() === curr);\n\
    \  }, 0);\n}\n", "    var ret = 0\n    string.split(\"\").forEach((ch: string)\
    \ => {\n        if (ch === ch.toUpperCase()) ret++\n        else if (ch === ch.toLowerCase())\
    \ ret++\n    })\n    return ret\n}\n", "\tlet count: number;\n\tlet char: string;\n\
    \tlet char_lowercase: string;\n\tlet char_uppercase: string;\n\n\tlet lowercase_count:\
    \ number;\n\tlet uppercase_count: number;\n\n\tlet i = 0;\n\tlet j = 0;\n\n\t\
    while (i < string.length) {\n\t\tchar = string[i];\n\n\t\tif (char == lowercase)\
    \ {\n\t\t\tchar_lowercase = string.substring(i + 1, i + 2);\n\t\t\tlowercase_count\
    \ = count_distinct_characters(char_lowercase);\n\t\t}\n\t\telse if (char == uppercase)\
    \ {\n\t\t\tchar_uppercase = string.substring(i + 1, i + 2);\n\t\t\tuppercase_count\
    \ = count_distinct_characters(char_uppercase);\n\t\t}\n\t\telse {\n\t\t\tcount\
    \ = 1;\n\t\t\tif (i == 0) {\n\t\t\t\tlower = string.charAt(j);\n\t\t\t}\n\t\t\t\
    else if (j == string.length - 1) {\n\t\t\t\tupper = string.charAt(j + 1);\n\t\t\
    \t}\n\t\t\telse if (j == 0) {\n\t\t\t\tlower = string.charAt(j);\n\t\t\t\tupper\
    \ = string.charAt(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlower = string.charAt(j);\n\
    \t\t\t\tupper = string.charAt(j + 1);\n\t\t\t}\n\t\t\tj = i + 1;\n\n\t\t\tif (lower\
    \ == upper) {\n\t\t\t\tcount += 1;\n\t\t\t\tlower = string.charAt(j);\n\t\t\t\t\
    upper = string.charAt(j + 1);\n\t\t\t\tj = i + 1;\n\t\t\t}\n\t\t\telse if (lower\
    \ == char) {\n\t\t\t\tcount += 1;\n\t\t\t\tlower = string.charAt(j);\n\t\t\t\t\
    j = i + 1;\n\t\t\t}\n\t\t\telse if (upper == char) {\n\t\t\t\tcount += 1;\n\t\t\
    \t\tupper = string.charAt(j);\n\t\t\t\tj = i + 1;\n\t\t\t}\n\t\t}\n\n\t\ti +=\
    \ 1;\n\t}\n\n\tif (count == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn count\
    \ + lowercase_count + uppercase_count;\n\t}\n}\n", "  if (string == \"\") return\
    \ 0;\n  let hashTable = {};\n  for (let i = 0; i < string.length; i++) {\n   \
    \ if (hashTable[string[i]] == undefined) {\n      hashTable[string[i]] = 0;\n\
    \    }\n    hashTable[string[i]] += 1;\n  }\n  return Object.keys(hashTable).length;\n\
    }\n", "    let count = string.length;\n    for (let i = 0; i < count; i++) {\n\
    \        count = count_distinct_characters_helper(string, i, count);\n    }\n\
    \    return count;\n}\n", "    return string\n        .split('')\n        .sort()\n\
    \        .reduce((prev, cur) => prev + cur.length - 1, 0) as number;\n}\n", " \
    \ let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]\
    \ === string[i].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n\
    }\n", "\tif (string.length <= 1) {\n\t\treturn 0;\n\t}\n\n\tlet characters = new\
    \ Set<string>();\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tcharacters.add(string[i].toLowerCase());\n\
    \t}\n\n\treturn characters.size;\n}\n", "    let count = 0;\n    for (const character\
    \ of string) {\n        if (string.includes(character.toLowerCase())) ++count;\n\
    \        else if (string.includes(character.toUpperCase())) ++count;\n       \
    \ else ++count;\n    }\n    return count;\n}\n", "  let n = 0;\n  for (let i =\
    \ 0; i < string.length; i++) {\n    let c = string.charAt(i);\n    if (string.includes(c))\
    \ {\n      n++;\n    }\n  }\n  return n;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < string.length; i++) {\n        let char = string[i];\n        if\
    \ (char.charCodeAt(0) <= 57 && char.charCodeAt(0) >= 48) {\n            count++;\n\
    \        } else {\n            count--;\n        }\n    }\n    return count;\n\
    }\n", "  if (string === \"\") return 0;\n  return string.split(\"\").filter((char)\
    \ => char === char.toLowerCase()).length;\n}\n", "\tlet unique: string[] = [];\n\
    \tstring.split('').forEach((letter: string) => {\n\t\tif (!unique.includes(letter))\
    \ {\n\t\t\tunique.push(letter);\n\t\t}\n\t});\n\treturn unique.length;\n}\n",
  "    let distinctChars = 0;\n    for (const char of string) {\n        distinctChars\
    \ += char.charCodeAt(0) - 64;\n    }\n    return distinctChars;\n}\n", "\tlet\
    \ ret = 0;\n\tlet len = string.length;\n\n\tfor (let i = 0; i < len; ++i) {\n\t\
    \tlet c = string.charAt(i);\n\t\tlet lower = c.toLowerCase();\n\t\tlet upper =\
    \ c.toUpperCase();\n\n\t\tif (lower !== upper) {\n\t\t\tret = ret + 1;\n\t\t}\n\
    \t}\n\n\treturn ret;\n}\n", "  return count_distinct_characters_in_string(string,\
    \ string.split(''));\n}\n", "\tlet i = 0;\n\tlet count_distinct = 0;\n\tlet currentChar;\n\
    \tfor (let i = 0; i < string.length; i++) {\n\t\tcurrentChar = string.charAt(i);\n\
    \t\tif (i > 0) {\n\t\t\tif (currentChar !== string.charAt(i - 1)) {\n\t\t\t\t\
    count_distinct++;\n\t\t\t}\n\t\t} else {\n\t\t\tcount_distinct++;\n\t\t}\n\t}\n\
    \treturn count_distinct;\n}", "    let uniqueChars = {};\n    string.split(\"\"\
    ).forEach((c) => {\n        let key = c.toLowerCase();\n        if (uniqueChars[key]\
    \ !== undefined)\n            uniqueChars[key]++;\n        else\n            uniqueChars[key]\
    \ = 1;\n    });\n    return Object.keys(uniqueChars).length;\n}", "    let charMap\
    \ = new Map<string, number>();\n\n    for(let i = 0; i < string.length; ++i) {\n\
    \        charMap.set(string.charAt(i), (charMap.get(string.charAt(i)) || 0) +\
    \ 1);\n    }\n\n    return charMap.size;\n}\n", "    // Create an array to hold\
    \ character frequencies\n    const freqs = new Uint8Array(26);\n    for (let i\
    \ = 0; i < string.length; i++) {\n        freqs[string.charCodeAt(i) - 0x20]++;\n\
    \    }\n\n    // Find out the frequency for each character\n    for (let i = 0;\
    \ i <= 25; i++) {\n        if (freqs[i] > 0) {\n            return i;\n      \
    \  }\n    }\n\n    return 0; // should never happen\n}\n", "    // TODO: Implement\
    \ me!\n    let distinctCharactersCount = 0;\n    return distinctCharactersCount;\n\
    }\n", "    const distinct: string[] = [];\n    string.split('').forEach((character:\
    \ string) => {\n        const character = character.toLowerCase();\n        if\
    \ (distinct[distinct.length - 1] !== character) {\n            distinct[distinct.length]\
    \ = character;\n        }\n    });\n    return distinct.length;\n}\n", "\tlet\
    \ distinctCount = 0;\n\tconst stringLowerCase = string.toLowerCase();\n\tfor (let\
    \ i = 0; i < stringLowerCase.length; i++) {\n\t\tconst char = stringLowerCase[i];\n\
    \t\tif (string.indexOf(char) !== string.toLowerCase().indexOf(char)) {\n\t\t\t\
    distinctCount++;\n\t\t}\n\t}\n\treturn distinctCount;\n}\n", "  return string.toLowerCase().split('').filter((char)\
    \ => char.match(/[a-z]/) || char.match(/[A-Z]/)).length;\n}\n", "\tlet chars =\
    \ string.split('');\n\treturn chars.reduce((acc, cur) => (cur === chars[acc] ?\
    \ acc + 1 : acc), 0);\n}\n", "    let map = {};\n    for (let char of string)\
    \ {\n        map[char] = (map[char] || 0) + 1;\n    }\n    return Object.keys(map).length;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI came up with this solution\
    \ using string length and splitting.\n\n<code>", "  let counter: number = 0; //The\
    \ counter is initialized with 0\n  for (const char of string) { //for every character\
    \ in the string ...\n    if (char.localeCompare(\"A\") === 0) counter++; //if\
    \ the current char is uppercase, increment the counter\n    if (char.localeCompare(\"\
    a\") === 0) counter++; //if the current char is lowercase, increment the counter\n\
    \  }\n  return counter;\n}\n", "  const counts: { [key: string]: number } = {};\n\
    \  for (const char of string) {\n    if (counts[char] == undefined) {\n      counts[char]\
    \ = 1;\n    } else {\n      counts[char] += 1;\n    }\n  }\n\n  return counts.length;\n\
    }\n", "\tlet unique_characters = new Set<string>();\n\tfor (let c of string) {\n\
    \t\tif (unique_characters.has(c)) {\n\t\t\tunique_characters.add(c);\n\t\t} else\
    \ {\n\t\t\tunique_characters.add(c);\n\t\t\tunique_characters.add(' ');\n\t\t\
    }\n\t}\n\n\treturn unique_characters.size;\n}\n", "    if (string.length === 0)\
    \ return 0;\n\n    let map: Map<string, number> = new Map();\n\n    for (let i\
    \ = 0; i < string.length; i++) {\n        let char = string[i];\n\n        if\
    \ (!map.has(char)) {\n            map.set(char, 1)\n        } else {\n       \
    \     map.set(char, map.get(char) + 1);\n        }\n    }\n\n    return map.size;\n\
    }\n", "  return Array.from(new Set(string.toLowerCase().split('')))\n    .length\n\
    }\n", "  let distinct_characters: string[] = []\n  for (let i = 0; i < string.length;\
    \ i++) {\n    let character = string[i]\n    if (distinct_characters.indexOf(character)\
    \ === -1) {\n      distinct_characters[distinct_characters.length] = character\n\
    \    }\n  }\n  return distinct_characters.length\n}\n", "  if (string === undefined)\
    \ throw new ReferenceError(`Invalid function arguments in function count_distinct_characters`)\n\
    \  if (string === \"\") throw new Error(`Invalid function arguments: string is\
    \ an empty string`)\n  let uniqueSet: Set<string> = new Set()\n  for (let i =\
    \ 0; i < string.length; i++) {\n    const thisChar = string[i]\n    if (!uniqueSet.has(thisChar))\
    \ {\n      uniqueSet.add(thisChar)\n    }\n  }\n  return uniqueSet.size // the\
    \ size of the unique set\n}", "  var result = 0;\n  var prev = '';\n  for (var\
    \ i = 0; i < string.length; i++) {\n    if (string[i] !== prev) {\n      result++;\n\
    \      prev = string[i];\n    }\n  }\n  return result;\n}\n", "    let distinct\
    \ = new Set<number>();\n    for (let character of string) {\n        distinct.add(character.toLowerCase().charCodeAt(0));\n\
    \    }\n    return distinct.size;\n}\n", "    let distinctCharCount: number =\
    \ 0;\n    string.split(\"\").forEach(char => {\n        distinctCharCount += string.indexOf(char)\
    \ >= 0 ? 1 : 0;\n    });\n    return distinctCharCount;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks for the answer! The first answer is the one I used at first,\
    \ but I wanted to find out if there was a more efficient way. The second one doesn't\
    \ work because it won't work for multiple letters.\n<|/ c |>\n<| a tags=string,javascript,char\
    \ |>\nA very simple and efficient way:\n<code>", "  const set = string\n    .toLowerCase()\n\
    \    .split(\"\")\n    .reduce((accumulator, element) => accumulator.add(element),\
    \ new Set())\n  return set.size\n}\n", "    return string.replace(/[^A-Za-z]/g,\
    \ \"\").length;\n}\n", "\tvar charArray: string[] = string.split(\"\");\n\tvar\
    \ uniqueArray: string[] = new Array();\n\n\tcharArray.forEach((char) => {\n\t\t\
    if (uniqueArray.indexOf(char) === -1) {\n\t\t\tuniqueArray.push(char);\n\t\t}\n\
    \t});\n\n\treturn uniqueArray.length;\n}\n", "  if (string.length < 2) {\n   \
    \ return 0;\n  }\n  if (string.length == 2) {\n    return string.toUpperCase()\
    \ === string.toLowerCase() ? 1 : 0;\n  }\n\n  let hash = {};\n  for (let i = 0;\
    \ i < string.length; i++) {\n    let c = string.charAt(i);\n    if (hash[c]) {\n\
    \      hash[c]++;\n    } else {\n      hash[c] = 1;\n    }\n  }\n  let result\
    \ = 0;\n  for (let c in hash) {\n    if (hash[c]) {\n      result += hash[c];\n\
    \    }\n  }\n  return result;\n}\n", "\tconst hashmap: any = {};\n\tfor (let i\
    \ = 0; i < string.length; i++) {\n\t\tconst char = string[i];\n\t\tif (hashmap[char]\
    \ == null) {\n\t\t\thashmap[char] = 1;\n\t\t} else {\n\t\t\thashmap[char]++;\n\
    \t\t}\n\t}\n\tlet result = 0;\n\tfor (const key in hashmap) {\n\t\tif (Object.prototype.hasOwnProperty.call(hashmap,\
    \ key)) {\n\t\t\tresult += hashmap[key];\n\t\t}\n\t}\n\treturn result;\n}\n",
  "\tlet result: number = 0;\n\tfor (let i = 0; i < string.length; i++) {\n\t\tif\
    \ (string.charAt(i) !== string.charAt(i).toUpperCase()) {\n\t\t\tresult++;\n\t\
    \t}\n\t}\n\treturn result;\n}\n", "    let count = 1;\n    for (let i = 0; i <\
    \ string.length; ++i) {\n        const c = string[i];\n        for (let j = i\
    \ + 1; j < string.length; ++j) {\n            if (string[i] == string[j]) {\n\
    \                ++count;\n            }\n        }\n    }\n    return count;\n\
    }\n", "    const char_count = [0];\n\n    for (let char of string) {\n       \
    \ char_count[char_count.length] += string.split(char).length - 1;\n    }\n\n \
    \   return char_count.reduce((a, b) => Math.max(a, b));\n}\n", "  let ret = 0;\n\
    \  for (const letter of string) {\n    ret += (letter === letter.toUpperCase()\n\
    \      ? 1\n      : 0);\n  }\n  return ret;\n}\n", "  // This implementation is\
    \ based on the implementation found in\n  // http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n\
    \  const letters = {};\n  for (let i = 0, len = string.length; i < len; ++i) {\n\
    \    const letter = string.charCodeAt(i);\n    if (letter.match(/[a-z]/i)) {\n\
    \      letters[letter] = letters[letter] ? letters[letter] + 1 : 1;\n    }\n \
    \ }\n  return Object.keys(letters).length;\n}\n", "\tlet distinctCharCount = 0;\n\
    \tstring.split('').forEach((char: string) => {\n\t\tif (char === char.toUpperCase()\
    \ || char === char.toLowerCase()) {\n\t\t\tdistinctCharCount++;\n\t\t}\n\t});\n\
    \treturn distinctCharCount;\n}\n", "\tif (string === \"\") {\n\t\treturn 0;\n\t\
    }\n\n\treturn string.split(\"\").filter((character) => !isNaN(character)).filter((character)\
    \ => character !== \" \").length;\n}\n", "    return string\n        .split('')\n\
    \        .reduce((prev, curr) => {\n            if (prev[curr] !== undefined)\
    \ {\n                return prev[curr]\n            }\n            prev[curr]\
    \ = prev[curr] + 1 || 1\n            return prev\n        }, {})\n}", "  let characters\
    \ = 0;\n  for (let i = 0; i < string.length; i++) {\n    characters += string.charCodeAt(i);\n\
    \  }\n  return characters;\n}\n", "  const charMap: string[] = [];\n  for (let\
    \ i = 0; i < string.length; i++) {\n    const char = string.charAt(i);\n    if\
    \ (charMap[char]) {\n      charMap[char]++;\n    } else {\n      charMap[char]\
    \ = 1;\n    }\n  }\n  return charMap;\n}\n", "  var n = 0;\n  for (var i = 0;\
    \ i < string.length; i++) {\n    var char = string[i];\n    if (char.toLowerCase()\
    \ !== char) {\n      ++n;\n    }\n  }\n  return n;\n}\n", "\tif (string == null)\
    \ return 0;\n\n\tlet total = 0;\n\tlet currentChar = string.charAt(0);\n\tlet\
    \ currentCharCode = currentChar.charCodeAt(0);\n\n\tfor (let i = 1; i < string.length;\
    \ i++) {\n\t\tconst thisChar = string.charAt(i);\n\t\tconst thisCharCode = thisChar.charCodeAt(0);\n\
    \t\tif (thisCharCode !== currentCharCode) {\n\t\t\ttotal++;\n\t\t}\n\t\tcurrentCharCode\
    \ = thisCharCode;\n\t}\n\treturn total;\n}\n", "\tlet counts: number[] = []; //\
    \ keep track of the count for distinct characters. Initialize to 1 since there's\
    \ just one character\n\tfor (let char of string.toLowerCase()) {\n\t\tcounts[char]\
    \ = (counts[char] || 0) + 1;\n\t}\n\treturn counts.length;\n}\n", "\tlet distinct\
    \ = 0;\n\tconst distinctCharacters = new Set<string>();\n\tfor (let i = 0; i <\
    \ string.length; ++i) {\n\t\tconst char = string.charAt(i);\n\t\tif (distinctCharacters.has(char))\
    \ continue;\n\t\tdistinctCharacters.add(char);\n\t\t++distinct;\n\t}\n\treturn\
    \ distinct;\n}\n", "\treturn (\n\t\tstring\n\t\t\t.split(\"\")\n\t\t\t.sort()\n\
    \t\t\t.join(\",\")\n\t\t\t.length\n\t);\n}\n", "  let count = 0;\n  let foundChar\
    \ = false;\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n\
    \    foundChar = false;\n    for (let j = 0; j < count; j++) {\n      if (string[j]\
    \ === char) {\n        foundChar = true;\n        break;\n      }\n    }\n   \
    \ if (!foundChar) {\n      count++;\n    }\n  }\n  return count;\n}\n", "\tif\
    \ (string.length == 0) return 0;\n\tlet counter: number = 0;\n\tfor (let i = 0;\
    \ i < string.length; i++) {\n\t\tconst chr = string[i].toUpperCase();\n\t\tif\
    \ (string.includes(chr)) {\n\t\t\tcounter++;\n\t\t}\n\t}\n\treturn counter;\n\
    }\n", "  if (string === '') {\n    return 0\n  }\n\n  const charSet = new Set(string)\n\
    \  const charCount = charSet.size\n  let numOfCharacters = 0\n  for (const char\
    \ of charSet) {\n    numOfCharacters += char.length\n  }\n\n  return numOfCharacters\n\
    }\n", "\treturn string\n\t\t.split(\"\")\n\t\t.reduce(\n\t\t\t(counts: number[],\
    \ char: string) => {\n\t\t\t\tcounts[char] = (counts[char] || 0) + 1;\n\t\t\t\t\
    return counts;\n\t\t\t},\n\t\t\t[] as { [char: string]: number }[],\n\t\t)\n\t\
    \t.reduce(\n\t\t\t(counts: number[], char) => {\n\t\t\t\tcounts[char] = counts[char]\
    \ || 0;\n\t\t\t\tcounts[char]++;\n\t\t\t\treturn counts;\n\t\t\t},\n\t\t\t[] as\
    \ { [char: string]: number }[],\n\t\t)\n\t\t.length;\n}\n", "  if (string.length\
    \ === 0) {\n    return 0;\n  }\n\n  let charCounter = {};\n  for (let i = 0; i\
    \ < string.length; i++) {\n    const char = string[i].toLowerCase().replace(/[^a-zA-Z0-9]/g,\
    \ \"\");\n    if (charCounter.hasOwnProperty(char)) {\n      charCounter[char]\
    \ += 1;\n    } else {\n      charCounter[char] = 1;\n    }\n  }\n\n  return Object.keys(charCounter).length;\n\
    }\n", "\tlet count_of_distinct = 0;\n\tstring.split(\"\").forEach(char => {\n\t\
    \tif (!char.match(/[a-z]/i)) {\n\t\t\tcount_of_distinct++;\n\t\t}\n\t});\n\treturn\
    \ count_of_distinct;\n}\n", "  if (string.length == 0) {\n    return 0;\n  }\n\
    \  const charMap = new Map<string, number>();\n  for (let i = 0; i < string.length;\
    \ i++) {\n    const char = string.charAt(i);\n    const count = charMap.get(char)\
    \ || 0;\n    charMap.set(char, count + 1);\n  }\n  return charMap.size;\n}\n",
  "\t// This takes O(n^2) time to count distinct characters \n\t// but because it's\
    \ only called once it won't matter\n\treturn string\n\t.split(\"\")\n\t.map(function(item:\
    \ string) {\n\t\treturn item\n\t\t.split(\"\")\n\t\t.filter(function(item2: string)\
    \ {\n\t\t\treturn !item2.includes(item);\n\t\t})\n\t\t.length;\n\t})\n\t.reduce(function(accumulator,\
    \ currentValue): number {\n\t\treturn accumulator + currentValue;\n\t}, 0);\n\
    }\n", "    const stringArray: string[] = string.split('');\n    return stringArray.reduce(\n\
    \        function(a, b) {\n            return a + String(b).match(/[a-z0-9]/).length;\n\
    \        },\n        0\n    );\n}\n", "  return Array.from(string).reduce((acc,\
    \ curr) => [...acc, curr.charCodeAt(0)], []).filter((val, i, arr) => arr.indexOf(val)\
    \ === i).length\n}\n", "\tlet counts: number[] = [];\n\tfor (let char of string.toLowerCase())\
    \ {\n\t\tcounts.push(string.split(char).length)\n\t}\n\treturn Math.max(...counts);\n\
    }\n", "    let distinct = 0;\n    for (let i = 0; i < string.length; ++i) {\n\
    \        if (i > 0) {\n            if (string[i] !== string[i - 1]) {\n      \
    \          distinct++;\n            }\n        }\n    }\n    return distinct;\n\
    }", "    const char_list: string[] = string.toLowerCase().split('')\n    let result:\
    \ number = 0\n    for (let i = 0; i < char_list.length; i++) {\n        if (char_list.indexOf(char_list[i])\
    \ === i) {\n            result += 1\n        }\n    }\n    return result\n}\n",
  "  let count = 1;\n\n  for (let i = 0; i < string.length; i++) {\n    const char\
    \ = string[i];\n\n    if (char.toLowerCase() !== char) {\n      count++;\n   \
    \ }\n  }\n\n  return count;\n}\n", "    const lowerCaseString = string.toLowerCase();\n\
    \    const uniqueCharacters = new Set<string>();\n    for (let i = 0; i < lowerCaseString.length;\
    \ i++) {\n        const character = lowerCaseString[i];\n        if (uniqueCharacters.has(character))\
    \ {\n            // Character exists in the set already\n            continue;\n\
    \        }\n        const foundCharacterIndex = uniqueCharacters.add(character);\n\
    \        uniqueCharacters.add(foundCharacterIndex);\n    }\n    return uniqueCharacters.size;\n\
    }", "\tlet result = 0;\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char\
    \ = string.charAt(i);\n\t\tif (char.match(/[a-z]/)) {\n\t\t\tlet lowerChar = string.charAt(i).toLowerCase();\n\
    \t\t\tlet upperChar = string.charAt(i).toUpperCase();\n\t\t\tresult += lowerChar\
    \ == upperChar ? 1 : lowerChar == char ? 2 : 0;\n\t\t} else if (char.match(/[A-Z]/))\
    \ {\n\t\t\tlet upperChar = string.charAt(i).toUpperCase();\n\t\t\tresult += string.charAt(i)\
    \ == upperChar ? 1 : 0;\n\t\t} else {\n\t\t\tresult += string.charAt(i) == char\
    \ ? 1 : 0;\n\t\t}\n\t}\n\treturn result;\n}\n", "    return string.split('').filter(function\
    \ (char: string): boolean {\n        return char !== ' ' && char !== '\\t';\n\
    \    }).length;\n}\n", "    if (string.length === 0) {\n        return 0;\n  \
    \  }\n    let count = 0;\n    for (let i = 0; i < string.length; ++i) {\n    \
    \    for (let j = i + 1; j < string.length; ++j) {\n            const firstChar\
    \ = string[i];\n            const secondChar = string[j];\n            if (firstChar\
    \ !== secondChar) {\n                ++count;\n            }\n        }\n    }\n\
    \    return count;\n}\n\n<|/ file ext=.ts filename=functions.ts dstars=1 |>",
  "  // create an object for caching the characters we find\n  let cache = {};\n\n\
    \  // loop over each character in string\n  for (let i = 0; i < string.length;\
    \ i++) {\n    const char = string[i];\n\n    // check that the character isn't\
    \ in the cache yet\n    if (!cache[char]) {\n      // update cache\n      cache[char]\
    \ = true;\n\n      // check the length of the current string\n      // if it already\
    \ exceeds the maximum length then increase the character counter\n      if (string.length\
    \ > max_distinct_characters) {\n        cache[char] = true;\n      }\n    }\n\
    \  }\n\n  // return the number of unique characters\n  return Object.keys(cache).length;\n\
    }\n", "  return count_distinct_characters_naive(string).length;\n}\nexport const\
    \ count_distinct_characters_naive = count_distinct_characters_naive;\n", "  return\
    \ count_distinct_characters_naive(string);\n}\n", "\t// If string is undefined,\
    \ return 0\n\tlet chars: string = string || '';\n\t// Return 0 if the given string\
    \ is empty or contains only spaces\n\tif (chars.length === 0 || (chars.match(/^\\\
    s*$/) || chars.match(/\\S/))) {\n\t\treturn 0;\n\t}\n\tlet charsSet = new Set<string>(chars);\n\
    \treturn charsSet.size;\n}\n", "\tlet count: number = 0;\n\tfor (let i = 0; i\
    \ < string.length; i++) {\n\t\tlet char = string.charCodeAt(i);\n\t\tif (char\
    \ >= 65 && char <= 90) {\n\t\t\tchar += 32;\n\t\t}\n\t\tcount += (string.charCodeAt(i)\
    \ - char);\n\t}\n\treturn count;\n}\n", "    const set: Set<string> = new Set<string>();\n\
    \    for (const char of string) {\n        if (!set.has(char)) {\n           \
    \ set.add(char);\n        }\n    }\n    return set.size;\n}\n", "\tconst distinctCharacters:\
    \ Set<string> = new Set();\n\tfor (const character of string) {\n\t\tdistinctCharacters.add(character.toLowerCase());\n\
    \t\tdistinctCharacters.add(character.toUpperCase());\n\t}\n\treturn distinctCharacters.size;\n\
    }\n", "    if (string == \"\") {\n        return 0;\n    }\n    // return string.length.toLocaleLowerCase().split('').filter((v)\
    \ => v !== 'x').length;\n    const charSet: Set<string> = new Set();\n    for\
    \ (const c of string) {\n        if (c.toLocaleLowerCase() !== c) {\n        \
    \    charSet.add(c);\n        }\n    }\n    return charSet.size;\n}", "  const\
    \ chars = string.toLowerCase().split('');\n  const charsDict = {};\n  for (let\
    \ i = 0; i < chars.length; i++) {\n    charsDict[chars[i]] = charsDict[chars[i]]\
    \ ? charsDict[chars[i]] + 1 : 1;\n  }\n  return Object.keys(charsDict).length;\n\
    }\n", "  var count = 0;\n  for (var i = 0; i < string.length; i++) {\n    var\
    \ a = string[i].toLowerCase();\n    var b = string[i].toUpperCase();\n    count\
    \ += (a === b) ? 1 : 0;\n  }\n  return count;\n}\n", "  if (string.length <= 1)\
    \ return 0;\n  const hashTable = new Set<string>();\n  for (const c of string)\
    \ {\n    hashTable.add(c);\n  }\n  return [...hashTable].length;\n}\n", "  //\
    \ Use a Set to store all unique chars\n  const chars = new Set();\n  let count\
    \ = 0;\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i].toLowerCase();\n\
    \    chars.has(char) ? chars.add(char) : chars.add(char.toLowerCase());\n  }\n\
    \  return chars.size;\n}\n", "  return arrays_1.distinct(string, character =>\
    \ character.toUpperCase()).length;\n}\nexports.count_distinct_characters = count_distinct_characters;",
  "\tif (string == null || string === \"\" || string.length < 2) return 0;\n\tlet\
    \ count_distinct_characters_array: string[] = string.toLowerCase().split(\"\"\
    );\n\tlet char_count = 0;\n\tfor (let i = 0; i < count_distinct_characters_array.length;\
    \ ++i) {\n\t\tlet c = count_distinct_characters_array[i];\n\t\tlet count = 1;\n\
    \t\tfor (let j = 0; j < count_distinct_characters_array.length; ++j) {\n\t\t\t\
    if (count_distinct_characters_array[j].toLowerCase() === c) {\n\t\t\t\t++count;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (count > 1) char_count += count;\n\t}\n\
    \treturn char_count;\n}\n", "\tlet count = 0;\n\tlet characters_set = new Set<string>();\n\
    \tfor (let i = 0; i < string.length; i++) {\n\t\tlet character = string[i];\n\t\
    \tcharacters_set.add(character);\n\t}\n\tfor (let [index, value] of characters_set.entries())\
    \ {\n\t\tif (characters_set.size > 1) {\n\t\t\tcount += 1;\n\t\t} else {\n\t\t\
    \tbreak;\n\t\t}\n\t}\n\treturn count;\n}\n", "    let characters: number = 0;\n\
    \    for (let char of string) {\n        if (char.charCodeAt(0) > 64 && char.charCodeAt(0)\
    \ < 91) characters += 1;\n    }\n    return characters;\n}\n", "    if (string\
    \ == \"\") {\n        return 0;\n    }\n    let chars: number = 0;\n    let currentChar:\
    \ string = string[0];\n    for (const char of string) {\n        if (char ===\
    \ currentChar) {\n            chars++;\n        }\n        else {\n          \
    \  chars = chars + 1;\n            currentChar = char;\n        }\n    }\n   \
    \ return chars;\n}", "\tlet distinct = 0;\n\tfor (let i = 0; i < string.length;\
    \ ++i) {\n\t\tconst char = string[i];\n\t\tif (char.match(/[a-z]/i) && string.includes(char.toLowerCase()))\
    \ {\n\t\t\t++distinct;\n\t\t}\n\t\tif (char.match(/[A-Z]/i) && string.includes(char.toUpperCase()))\
    \ {\n\t\t\t++distinct;\n\t\t}\n\t}\n\treturn distinct;\n}\n", "  // We don't treat\
    \ null character as distinct, so we use special value to represent null.\n  //\
    \ See https://stackoverflow.com/a/17381730/1168886 for details.\n  const nullChar\
    \ = { character: '\\0' };\n\n  return string.split('').reduce((prev, curr) =>\
    \ {\n    if (curr !== nullChar.character) {\n      prev++;\n    }\n    return\
    \ prev;\n  }, 0);\n}\n", "  return Array.from(string).reduce((count, d) => {\n\
    \    return count + (d.toLowerCase() === d ? 1 : 0);\n  }, 0);\n}\n", "  let characters\
    \ = new Set(string);\n  return characters.size;\n}\n</code>\n<|/ a dscore=2 tags=javascript\
    \ |>\n<| c |>\n`String.length` returns the string length in characters, not the\
    \ number of distinct characters. You probably meant `String.length`\n<|/ c |>\n\
    <| a tags=javascript |>\nI made a JavaScript solution with no loop and with short\
    \ code length.\n<code>\nlet text = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\nlet count =\
    \ text.reduce((acc, cur) => {\n  if (acc.has(cur)) {\n    acc = acc.delete(cur)\n\
    \  } else {\n    acc.add(cur)\n  }\n  return acc\n}, new Set())\n\nconsole.log(count)\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis fails if there are multiple characters\
    \ that appear exactly once.\n<|/ c |>\n<| c |>\nYes you are right. I've made some\
    \ changes to the code so now it works.\n<|/ c |>\n<| a |>\nHere's a function that\
    \ will return the number of distinct characters in a string:\n<code>", "  const\
    \ chars = Array.from(string.toLowerCase());\n  const set = new Set(chars);\n \
    \ return chars.filter(item => !set.has(item)).length\n}\n", "\tlet uniqueChars\
    \ = {};\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i].toLowerCase();\n\
    \t\tif (uniqueChars[char]) {\n\t\t\tuniqueChars[char] += 1;\n\t\t} else {\n\t\t\
    \tuniqueChars[char] = 1;\n\t\t}\n\t}\n\treturn Object.keys(uniqueChars).length;\n\
    }\n", "    return Object.keys({ [string]: string[string.length - 1] })[string.length\
    \ - 1];\n}\n", "  let hash = {};\n  let characters;\n\n  for (const char of string)\
    \ {\n    if (hash[char] == undefined) {\n      hash[char] = 1;\n      characters\
    \ = characters + 1;\n    } else {\n      hash[char] = hash[char] + 1;\n    }\n\
    \  }\n\n  return characters;\n}\n", "    // Return 0 if empty string\n    if (!string\
    \ || string.length <= 0) {\n        return 0;\n    }\n\n    const lowercased =\
    \ string.toLowerCase();\n    let counter = 0;\n\n    for (let i = 0; i < lowercased.length;\
    \ i++) {\n        let j = lowercased.charCodeAt(i);\n        let k = lowercased.charCodeAt(j);\n\
    \n        if (i < j) {\n            if (j < k) {\n                counter++;\n\
    \            } else {\n                counter--;\n            }\n        } else\
    \ if (i > k) {\n            counter++;\n        } else {\n            counter--;\n\
    \        }\n    }\n\n    return counter;\n}\n", "\tlet seen = new Set<string>()\n\
    \tfor (let i = 0; i < string.length; i++) {\n\t\tlet char: string = string[i].toLowerCase()\n\
    \t\tif (seen.has(char)) {\n\t\t\tseen[char]++\n\t\t} else {\n\t\t\tseen.add(char)\n\
    \t\t}\n\t}\n\treturn Object.keys(seen).length\n}\n", "\tlet unique_letters: number\
    \ = 0;\n\tfor (let letter of string.toLowerCase()) {\n\t\tif (string.indexOf(letter)\
    \ == 0) {\n\t\t\tunique_letters++;\n\t\t}\n\t}\n\n\treturn unique_letters;\n}\n",
  "    let total = 0;\n    string.split('').forEach(char => {\n        let lowerChar\
    \ = char.toLowerCase();\n        total += lowerChar.length > 0 ? 1 : lowerChar.length;\n\
    \    })\n    return total;\n}\n", "    let map: { [key: string]: number } = {}\n\
    \n    for (let i = 0; i < string.length; i++) {\n        let char = string[i]\n\
    \n        // if the char is already in the map\n        if (map.hasOwnProperty(char))\
    \ {\n            map[char]++\n        } else {\n            // otherwise, add\
    \ the char and the count of 1\n            map[char] = 1\n        }\n    }\n\n\
    \    return Object.keys(map).length\n}\n", "\tlet count = 0;\n\tfor (let i = 0;\
    \ i < string.length; i++) {\n\t\tif (string.charAt(i) === string.charAt(i).toUpperCase())\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n", "  const chars = string.toLowerCase();\n\
    \  let unique_characters = 0;\n  for (let i = 0; i < chars.length; i++) {\n  \
    \  if (chars.indexOf(chars[i]) == i) unique_characters++;\n  }\n  return unique_characters;\n\
    }\n", "    let distinct_chars = string.split(\"\").map(char => char.toLowerCase()).filter(char\
    \ => char != \" \").length;\n    return distinct_chars;\n}\n", "    let count\
    \ = 1;\n    let prev = string.charAt(0);\n    for (let i = 1; i < string.length;\
    \ i++) {\n        if (string.charAt(i) === string.charAt(i - 1)) {\n         \
    \   count++;\n        } else {\n            count = 1;\n        }\n        prev\
    \ = string.charAt(i);\n    }\n    return count;\n}\n", "\treturn string.replace(/[^A-Za-z]/g,\
    \ \"\").length;\n}\n", "    // Case insensitive and case sensitive\n    const\
    \ regex = new RegExp(\n        `${special_characters}|${special_characters_with_spaces}|`,\n\
    \        \"gi\"\n    );\n    let count = 0;\n    let match;\n    // Loop through\
    \ all the characters in the string\n    while ((match = regex.exec(string))) {\n\
    \        // If match is empty then its not a character\n        if (match[0] ===\
    \ undefined) {\n            continue;\n        }\n        // If not case sensitive\n\
    \        if (match[1] === special_characters_with_spaces) {\n            count\
    \ += match[0].length;\n        } else if (match[1] === special_characters) {\n\
    \            count += special_characters.length;\n        } else {\n         \
    \   count++;\n        }\n    }\n    return count;\n}\n", "  string = string.toLowerCase()\n\
    \n  // convert string to lowercase\n  let hash = new Set<string>(string);\n  let\
    \ numDistinctCharacters = 0;\n\n  // loop through the string again, counting distinct\
    \ characters\n  for (let i = 0; i < string.length; i++) {\n    // if the character\
    \ is in the hash set, increment the count\n    if (hash.has(string[i])) {\n  \
    \    numDistinctCharacters += 1;\n    }\n\n    // add the character to the set\n\
    \    hash.add(string[i]);\n  }\n\n  return numDistinctCharacters;\n}\n", "  const\
    \ hashTable: Map<string, number> = new Map()\n  string.split('').map(letter =>\
    \ {\n    const hash = hashForLetter(letter)\n    hashTable.set(hash, hashTable.get(hash)\
    \ | 1)\n  })\n  return hashTable.get('' + hashTable.get(hashForLetter(''))!)!\n\
    }\n", "\tlet num = 0;\n\tfor (let i = 0; i < string.length; i++) {\n\t\tif (string[i]\
    \ === string[i].toLowerCase() || string[i] === string.toUpperCase()) {\n\t\t\t\
    num++;\n\t\t}\n\t}\n\treturn num;\n}\n", "\treturn string.split(\"\").filter((char:\
    \ string) => {\n\t\treturn char === char ? false : true;\n\t}).length;\n}\n",
  "    let result = 0;\n    for (let i = 0; i < string.length; i++) {\n        const\
    \ char = string.charAt(i);\n        const code = char.charCodeAt(0);\n       \
    \ if (code === char.charCodeAt(0)) {\n            continue;\n        }\n     \
    \   if (code >= \"A\".charCodeAt(0) && code <= \"Z\".charCodeAt(0)) {\n      \
    \      if (i > 0) {\n                result += (string.charAt(i - 1).charCodeAt(0)\
    \ === \"A\".charCodeAt(0)) ? 1 : 0;\n            }\n        } else {\n       \
    \     result += (code >= \"0\".charCodeAt(0) ? 1 : 0);\n        }\n    }\n   \
    \ return result;\n}\n", "\tlet unique: string[] = [];\n\n\tfor (let i = 0; i <\
    \ string.length; i++) {\n\t\tif (unique.indexOf(string[i]) === -1) {\n\t\t\tunique.push(string[i]);\n\
    \t\t}\n\t}\n\n\treturn unique.length;\n}\n", "\treturn string.replace(/[^A-Z^a-z^0-9]+/g,\
    \ '').length;\n}\n", "  const distinct_characters: number[] = [];\n  for (let\
    \ i = 0; i < string.length; i++) {\n    const character = string[i];\n    if (!distinct_characters.includes(character))\
    \ {\n      distinct_characters.push(character);\n    }\n  }\n  return distinct_characters.length;\n\
    }\n", "  let unique: string[] = [];\n  let counts: number[] = [];\n  for (let\
    \ i = 0; i < string.length; i++) {\n    if (unique.indexOf(string[i]) == -1) {\n\
    \      unique.push(string[i]);\n      counts.push(1);\n    } else {\n      counts[unique.indexOf(string[i])]++;\n\
    \    }\n  }\n  return counts.reduce((acc, val) => acc + val, 0);\n}\n", "\tlet\
    \ chars = new Set<string>();\n\tfor (let i = 0; i < string.length; i++) {\n\t\t\
    chars.add(string[i].toLowerCase());\n\t\tchars.add(string.toUpperCase());\n\t\
    }\n\treturn chars.size;\n}\n", "  const result: string[] = []\n  let count = 0\n\
    \  \n  for (const char of string) {\n    if (result.includes(char)) {\n      count++\n\
    \    }\n    else {\n      result.push(char)\n      count = 1\n    }\n  }\n  \n\
    \  return count\n}\n", "    let chars = string.toUpperCase().split('').sort();\n\
    \    let numchars = 1;\n    for (let i = 0; i < chars.length; i++) {\n       \
    \ if (chars.indexOf(chars[i]) === i) {\n            numchars++;\n        }\n \
    \   }\n    return numchars;\n}\n", "\treturn string.split(\"\").filter((_, index)\
    \ => index === 0 || string[index - 1] !== string[index]).length;\n}\n", "  let\
    \ counter = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i)\
    \ !== string.charAt(string.length - i - 1)) {\n      counter++;\n    }\n  }\n\
    \  return counter;\n}\n", "    const obj: Object = {};\n    let num_distinct =\
    \ 0;\n\n    for (let i = 0; i < string.length; i++) {\n        const char = string[i].toLowerCase();\n\
    \        if (obj[char]) num_distinct++;\n        obj[char] = true;\n    }\n  \
    \  return num_distinct;\n}\n", "    return string.replace(/[^a-zA-Z0-9]+/g,\"\"\
    ).length;\n}\n", "    // Add 1 to get the character length since each character\
    \ is 1 character.\n    const total_character_count = string.length + 1; //add\
    \ 1 for the 'e'\n    return total_character_count - string.match(new RegExp(`[^${string}]`,\
    \ 'g')).length;\n}\n", "  let counter = 0;\n  for (let i = 0; i < string.length;\
    \ i++) {\n    const char = string.charAt(i);\n    if (char.toLowerCase() === char.toUpperCase())\
    \ {\n      counter++;\n    }\n  }\n  return counter;\n}\n", "  // Initialize array\
    \ for characters to count\n  const chars: any[] = [];\n\n  // Initialize count\
    \ of characters \n  let count = 1;\n\n  // Loop through string characters\n  for\
    \ (const character in string) {\n    // If the character is lowercase\n    if\
    \ (character.toLowerCase() === character) {\n      // Increment count of characters\
    \ by 1\n      count++;\n    }\n\n    // If the character is uppercase\n    else\
    \ if (character.toUpperCase() === character) {\n      // Increment count of characters\
    \ by 1\n      count++;\n    }\n\n    // If the character is not lowercase\n  \
    \  // AND it is not uppercase\n    else {\n      // Add character to chars\n \
    \     chars.push(character);\n    }\n  }\n\n  // Return count of distinct characters\n\
    \  return count;\n}\n", "    let num_distinct = 0;\n    let distinct_chars = new\
    \ Set<string>();\n\n    for (let char of string.toLowerCase().replace(/[^a-z]/gi,\
    \ \"\").split(\"\")) {\n        distinct_chars.add(char);\n    }\n\n    for (const\
    \ char of distinct_chars) {\n        if (distinct_chars.indexOf(char) !== distinct_chars.lastIndexOf(char))\
    \ {\n            num_distinct++;\n        }\n    }\n\n    return num_distinct;\n\
    }\n", "  return Array.from(\n    new Set(string.split(''))\n  ).length;\n}\n",
  "    let count = 0; //The count of unique characters in a string\n    let letter:\
    \ string; //The character we're testing\n\n    for (const letter in string.toLowerCase())\
    \ {\n        if (string.includes(letter.toLowerCase())) {\n            count++;\n\
    \        }\n    }\n\n    return count;\n}\n", "  var result = 0;\n  var len =\
    \ string.length;\n  for (var i = 0; i < len; i++) {\n    var letter = string[i];\n\
    \    var isCaseSensitive = typeof letter === 'string';\n    if (isCaseSensitive)\
    \ letter += letter.toLowerCase();\n    var isAlphaNumeric = typeof letter ===\
    \ 'string' &&\n        letter.match(/^[a-z0-9]+$/);\n    if (isAlphaNumeric) {\n\
    \      result += 1;\n    }\n  }\n  return result;\n}\n", "\tlet counter = 0;\n\
    \tfor (let i = 0; i < string.length; i++) {\n\t\tif (string.charCodeAt(i) >= 97\
    \ && string.charCodeAt(i) <= 122) counter++;\n\t}\n\treturn counter;\n}\n", "\t\
    let num = 1;\n\tlet distinct_characters = [];\n\tfor (const c of string) {\n\t\
    \tif (!distinct_characters.includes(c)) {\n\t\t\tdistinct_characters.push(c);\n\
    \t\t} else {\n\t\t\tnum += 1;\n\t\t}\n\t}\n\treturn num;\n}\n", "  let char_counts\
    \ = { };\n  for (let ch of string) {\n    let count = char_counts[ch];\n    if\
    \ (count == undefined) {\n      char_counts[ch] = 1;\n    } else {\n      char_counts[ch]++;\n\
    \    }\n  }\n  let distinct_char_count = Object.keys(char_counts).filter(c =>\
    \ char_counts[c] === 1).length;\n  return distinct_char_count;\n}\n\n<|/ file\
    \ filename=utils.ts |><|endofmask|>source=github ext=.ts |><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
  "    const char: string = string.toLowerCase();\n    const counts: number[] = [];\n\
    \    for (let i = 1; i < char.length; i++) {\n        let char = char[i];\n  \
    \      let prevChar = char.charAt(i - 1);\n        if (char === prevChar) {\n\
    \            counts.push(1);\n        } else {\n            counts.push(counts[i\
    \ - 1] + 1);\n        }\n    }\n    return counts[counts.length - 1];\n}\n", " \
    \ const regex = /[a-z]/i\n  const counter: number = 0\n  string.split(\"\").forEach((char:\
    \ string) => {\n    const lowercase_char: string = char.toLowerCase()\n    if\
    \ (!regex.test(lowercase_char)) counter++\n  })\n  return counter\n}\n\n<|/ file\
    \ filename=util.ts |>", "\treturn string.split('').filter(function(char) {\n\t\
    \treturn !is_number(char);\n\t}).length;\n}\n", "  return string.toLowerCase().split('').reduce(function\
    \ (count: number, character: string): number {\n    return count + (character\
    \ === character.toUpperCase() ? 1 : 0);\n  }, 0);\n}\n", "  if (string === undefined)\
    \ {\n    return 0;\n  }\n\n  let char_counter: number[] = [];\n\n  for (let c\
    \ of string.toLowerCase()) {\n    if (char_counter.indexOf(c) == -1) {\n     \
    \ char_counter.push(c);\n    }\n  }\n\n  return char_counter.length;\n}\n", " \
    \ var count = 1;\n  for (var i = 0; i < string.length; i++) {\n    count += (string.charCodeAt(i)\
    \ - 'A'.charCodeAt(0)) / 26\n  }\n  return count;\n}\n", "  const str = string\
    \ || \"\";\n  if (str.length == 0) return 0;\n\n  const charMap = new Map<string,\
    \ number>();\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i].toLowerCase();\n\
    \    if (!charMap.has(char)) {\n      charMap.set(char, 1);\n    } else {\n  \
    \    charMap.set(char, charMap.get(char) + 1);\n    }\n  }\n\n  return charMap.size;\n\
    }\n", "    if (string === \"\") {\n        return 0;\n    }\n\n    return string\n\
    \        .toLowerCase()\n        .split(\"\")\n        .reduce((acc, curr) =>\
    \ {\n            return acc + curr.charCodeAt(0);\n        }, 0);\n}\n", "\tlet\
    \ length: number = 0;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tif (string[i]\
    \ !== string[i].toLowerCase()) {\n\t\t\tlength++;\n\t\t}\n\t}\n\n\treturn length;\n\
    }\n", "\tconst char_table: Map<string, number> = new Map<string, number>();\n\t\
    let unique_string: string = \"\";\n\tfor (let i = 0; i < string.length; ++i) {\n\
    \t\tif (string.charAt(i) == string.charAt(i).toUpperCase()) {\n\t\t\tif (string.charAt(i)\
    \ != string.charAt(i.toLowerCase())) {\n\t\t\t\tchar_table.set(string.toLowerCase()\
    \ + string.charAt(i).toLowerCase(), 1);\n\t\t\t} else {\n\t\t\t\tchar_table.set(string.toLowerCase()\
    \ + string.charAt(i).toLowerCase(), 0);\n\t\t\t}\n\t\t} else {\n\t\t\tchar_table.set(string.toLowerCase()\
    \ + string.charAt(i).toLowerCase(), 0);\n\t\t}\n\t\tif (char_table.has(string))\
    \ {\n\t\t\tunique_string += string.charAt(i);\n\t\t}\n\t}\n\n\treturn char_table.size;\n\
    }\n", "  return string\n    .trim()\n    .replace(/\\s+/g, \"\")\n    .toLowerCase()\n\
    \    .split(\"\")\n    .reduce((acc, curr) => {\n      if (acc[curr] === undefined)\
    \ {\n        acc[curr] = 1;\n      } else {\n        acc[curr] += 1;\n      }\n\
    \      return acc;\n    }, {});\n}\n\n<|/ file ext=.ts |>", "    let chars: number[]\
    \ = [];\n\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n\
    \        let lowerChar = char.toLowerCase();\n\n        // check if it's been\
    \ seen before\n        if (chars.indexOf(lowerChar) === -1) {\n            chars.push(lowerChar);\n\
    \        }\n    }\n\n    return chars.length;\n}\n", "  let count = 1;\n  let\
    \ i = 0;\n  while (i < string.length) {\n    const char = string[i].toLowerCase();\n\
    \    i = i + 1;\n    const prev = string[i];\n    if (char == prev) {\n      count\
    \ = count + 1;\n    } else {\n      count = count + 2;\n    }\n  }\n  return count;\n\
    }\n", "  let num = 0;\n  for (let i = 0; i < string.length; i++) {\n    let char\
    \ = string[i].toLowerCase();\n    if (char.charCodeAt(0) > 122)\n      num++;\n\
    \  }\n  return num;\n}\n", "    const counts = new Map();\n\n    for (let i =\
    \ 0; i < string.length; i++) {\n        const char = string.charAt(i);\n     \
    \   if (counts.has(char)) {\n            counts.set(char, counts.get(char) + 1);\n\
    \        } else {\n            counts.set(char, 1);\n        }\n    }\n\n    return\
    \ Array.from(counts.values()).reduce((a, b) => a + b, 0);\n}\n", "  var distinctChars\
    \ = 0;\n  for (var i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i)\
    \ == string.charCodeAt(i).toLowerCase()) {\n      distinctChars++;\n    }\n  }\n\
    \  return distinctChars;\n}\n", "  let count = 0;\n  let characters = new Set<string>();\n\
    \  for (let i = 0; i < string.length; i++) {\n    characters.add(string[i]);\n\
    \    if (characters.size === 1) {\n      count++;\n    }\n  }\n  return count;\n\
    }\n", "  if (string.length == 0) return 0;\n  let result = 0;\n  for (let i =\
    \ 0; i < string.length; i++) {\n    if (i == 0) continue;\n    let prev = string[i\
    \ - 1];\n    if (string[i] != prev) {\n      result++;\n    }\n  }\n  return result;\n\
    }\n", "    const chars = {};\n    string.replace(/[^a-zA-Z]/g, item => {\n   \
    \     const character = item.toLowerCase();\n        if (chars[character]) {\n\
    \            chars[character]++;\n        } else {\n            chars[character]\
    \ = 1;\n        }\n    });\n    return Object.keys(chars).length;\n}\n", "  if\
    \ (string === '') {\n    return 0;\n  }\n\n  const lower: string = string.toLowerCase();\n\
    \  const upper: string = string.toUpperCase();\n\n  let count = 0;\n  for (const\
    \ character of lower) {\n    count += lower.indexOf(character);\n  }\n  for (const\
    \ character of upper) {\n    count += upper.indexOf(character);\n  }\n\n  return\
    \ count;\n}\n", "  // initialize count variable\n  let count = 0;\n\n  // traverse\
    \ through string\n  string.split('').forEach((element) => {\n    // if current\
    \ character is not the same as previous character\n    if (element !== string[count])\
    \ {\n      // update count variable\n      count++;\n    }\n  });\n\n  // return\
    \ count variable\n  return count;\n}\n", "\tconst count_map = {}\n\tconst len\
    \ = string.length\n\n\tfor (let i = 0; i < len; i++) {\n\t\tconst char = string[i]\n\
    \n\t\tif (!count_map[char]) {\n\t\t\tcount_map[char] = 1\n\t\t} else {\n\t\t\t\
    count_map[char]++\n\t\t}\n\t}\n\n\treturn Object.keys(count_map).length\n}\n",
  "\treturn string.replace(/[^A-Za-z]/g,'').length\n}\n", "\tlet characters: number\
    \ = 0;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst character = string[i];\n\
    \t\tconst lowerCaseCharacter = string[i].toLowerCase();\n\t\tconst upperCaseCharacter\
    \ = string[i].toUpperCase();\n\n\t\tif (character == lowerCaseCharacter || character\
    \ == upperCaseCharacter) {\n\t\t\tcharacters++;\n\t\t}\n\t}\n\n\treturn characters;\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
