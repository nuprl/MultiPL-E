name: HumanEval_68_pluck
language: ts
prompt: "//\"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n// your task is to pluck one of the nodes and return it.\n// The\
  \ plucked node should be the node with the smallest even value.\n// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n// The plucked node should be returned in an array, [ smalest_value, its\
  \ index ],\n// If there are no even values or the given array is empty, return [].\n\
  // Example 1:\n// >>> pluck([4, 2, 3])\n// [2, 1]\n// Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck([1, 2,\
  \ 3])\n// [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
  \ index.\n// Example 3:\n// >>> pluck([])\n// []\n// Example 4:\n// >>> pluck([5,\
  \ 0, 3, 0, 4, 2])\n// [0, 1]\n// Explanation: 0 is the smallest value, but  there\
  \ are two zeros,\n// so we will choose the first zero, which has the smallest index.\n\
  // Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunction\
  \ pluck(arr: number[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
  \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
  \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n\
  \  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
  \ 9, 7, 1]),[]);\n}\n\ntest();"
completions: ["    let nodes: number[] = [];\n    for (let i = 0; i < arr.length;\
    \ i++) {\n        let node: number[] = [arr[i], i];\n        if (nodes.length\
    \ === 0) {\n            nodes.push(node);\n        } else if (nodes[0][1] ===\
    \ node[1]) {\n            let index = nodes[1][0];\n            if (index > nodes[0][0])\
    \ {\n                nodes[0][0] = index;\n            }\n        }\n    }\n \
    \   return nodes;\n}\n", "  const evenValues = arr.filter(function (val: number)\
    \ {\n    return val % 2 === 0;\n  });\n\n  const sortedEvens = evenValues.sort((a,\
    \ b) => {\n    return a - b;\n  });\n\n  const smalest = evenValues.reduce((prev,\
    \ curr) => {\n    return prev === curr\n      ? curr\n      : prev;\n  });\n\n\
    \  return sortedEvens.indexOf(smalest);\n}\n", "    if (arr.length === 0) return\
    \ [];\n    let smallestValue = arr[0];\n    let index;\n    for (let i = 1; i\
    \ < arr.length; i++) {\n        if (arr[i] < smallestValue) {\n            smallestValue\
    \ = arr[i];\n            index = i;\n        }\n    }\n    return [index];\n}\n",
  "  // code here\n}\n", "  arr.sort((a, b) => a > b ? 1 : -1); //sorts ascending\n\
    \  let index = 0;\n  for (let node of arr) {\n    if (node % 2 === 0) {\n    \
    \  return [node];\n    }\n    index += 1;\n  }\n  return [];\n}\n", "  arr = [...arr];\n\
    \  let evenNumbers = [...arr].filter(number => number % 2 === 0);\n  if (evenNumbers.length\
    \ === 0) return [];\n  let evenMin = Math.min(...evenNumbers);\n  let pickIndex\
    \ = (arr: number[], min: number) => {\n    for (let i = 0; i < arr.length; i++)\
    \ {\n      if (arr[i] === min) {\n        return i;\n      }\n    }\n    return\
    \ -1;\n  };\n  return arr.map(number => number == evenMin ? number : pickIndex(arr,\
    \ number));\n}\n", "  const [smallestValue, smallestIndex] = Math.min(arr);\n\
    \  return arr.filter(\n    (node, index) => node === smallestValue && index !==\
    \ smallestIndex\n  );\n}\n", "  for (let i = 0; i < arr.length; i++) {\n    if\
    \ (arr[i] % 2 === 0) {\n      return [i, i];\n    }\n  }\n  return [];\n}\n",
  "  const len = arr.length;\n  const evens: number[] = [];\n  let largest = 0;\n\
    \  let smallest = 0;\n  let counter = 0;\n  while (counter < len) {\n    if (arr[counter]\
    \ % 2 === 0) {\n      evens.push(arr[counter]);\n      counter += 1;\n    } else\
    \ {\n      if (arr[counter] > largest) {\n        largest = arr[counter];\n  \
    \    }\n      if (arr[counter] < smallest) {\n        smallest = arr[counter];\n\
    \      }\n      counter += 1;\n    }\n  }\n  return evens\n    .sort((a, b) =>\
    \ {\n      return a - b;\n    })\n    .slice(0, 1)\n    .concat(\n      evens.sort((a,\
    \ b) => {\n        return a - b;\n      })\n    );\n}\n", "  let result = [];\n\
    \  let minVal = Number.MAX_VALUE;\n  let minIndex = -1;\n  arr.forEach((n, i)\
    \ => {\n    if (n % 2 === 0) {\n      if (n < minVal) {\n        minVal = n;\n\
    \        minIndex = i;\n      }\n    }\n  });\n  if (minIndex >= 0) {\n    result.push(minVal);\n\
    \    result.push(minIndex);\n  }\n  return result;\n}\n", "  const map = new Map();\n\
    \  for (let i = 0; i < arr.length; i++) {\n    let value = arr[i];\n    if (map.has(value))\
    \ {\n      let node = map.get(value);\n      map.set(value, {\n        index:\
    \ node.index,\n        value: node.value,\n      });\n    } else {\n      let\
    \ node = {\n        value,\n        index: i,\n      };\n      map.set(value,\
    \ node);\n    }\n  }\n  arr.sort((a, b) => a - b);\n  const output = [];\n  for\
    \ (let i = 0; i < arr.length; i++) {\n    let node = map.get(arr[i]);\n    if\
    \ (node.value === arr[i]) {\n      continue;\n    }\n    output.push(node.value);\n\
    \  }\n  return output;\n}\n", "    let min: number = 0;\n    for (let i = 1; i\
    \ < arr.length; i++) {\n        if (arr[i] < arr[min]) {\n            min = i;\n\
    \        }\n    }\n    return arr.slice(min, arr.length);\n}\n", "  for (let i\
    \ = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      return [arr[i],\
    \ i];\n    }\n  }\n  return [];\n}\n\nconst arr2 = new Array(1000);\nlet start\
    \ = performance.now();\nconst result = arr2.map(n => n % 10);\nconst end = performance.now();\n\
    console.log(end - start);\nconsole.log(result);\n", "  const sorted = arr.slice().sort((a,\
    \ b) => a - b);\n  if (sorted.length <= 0) {\n    return [];\n  }\n  let found\
    \ = false;\n  for (let i = 0; i < sorted.length; ++i) {\n    if (sorted[i] % 2\
    \ === 0) {\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n \
    \   return [];\n  }\n  return [sorted[sorted.length - 1], sorted.length - 1];\n\
    }\n", "  let result: number[] = [];\n  let min: number = Number.MAX_SAFE_INTEGER;\n\
    \  for (let i = 0; i < arr.length; i++) {\n    let value: number = arr[i];\n \
    \   if (value % 2 == 0 && value <= min) {\n      result.push(value);\n      min\
    \ = value;\n    }\n  }\n  return result;\n}\n", "  return pick(arr, pickByEvenValue);\n\
    }\n", "    if (arr.length === 0 || arr.some(el => el < 0)) {\n        return [];\n\
    \    }\n    let min = arr.sort((a: number, b: number) => a - b)[0];\n    let index\
    \ = arr.indexOf(min);\n    let min = arr.sort((a: number, b: number) => a - b)[index\
    \ % arr.length];\n    return [min, index];\n}\n", "    const len = arr.length;\n\
    \    let minEven = arr[0];\n    let minIndex = -1;\n    for (let i = 1; i < len;\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < minEven) {\n\
    \                minEven = arr[i];\n                minIndex = i;\n          \
    \  }\n        }\n    }\n    return [minEven, minIndex];\n}\n", "  if (arr.length\
    \ === 0 || arr.some(x => !isEven(x))) return [];\n  const even = arr.filter(x\
    \ => isEven(x));\n  if (even.length === 0) return [];\n  return even.map(x =>\
    \ x).sort((a, b) => a - b)[0];\n}\n", "  let minValue = -1;\n  let minIndex =\
    \ 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i]\
    \ === maxValue) maxIndex++;\n    if (arr[i] < minValue && arr[i] >= 0) {\n   \
    \   minValue = arr[i];\n      minIndex = i;\n    }\n    if (arr[i] > maxValue\
    \ && arr[i] >= 0) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n\
    \  if (minIndex === maxIndex) {\n    return [minValue, minIndex];\n  } else {\n\
    \    return [minValue, minIndex];\n  }\n}\n", "  let minValue = Number.MAX_SAFE_INTEGER;\n\
    \  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i]\
    \ < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n \
    \ return [minValue, minIndex];\n}\n", "  const evens = arr\n    .filter((i) =>\
    \ i % 2 === 0)\n    .sort((a, b) => a - b)\n    .slice(0, 1)\n    .map((i) =>\
    \ arr[i])\n  if (evens.length === 0) {\n    return []\n  } else if (evens.length\
    \ === 1) {\n    return evens[0]\n  }\n  const index = evens.indexOf(Math.min.apply(null,\
    \ evens))\n  return [Math.min.apply(null, evens), index]\n}\n", "  const odd =\
    \ arr.findIndex(x => x % 2 === 1);\n  if (odd === -1) {\n    return [];\n  }\n\
    \  return arr.slice(0, odd);\n}\n", "  if (!arr) {\n    return [];\n  }\n  if\
    \ (arr.length === 1) {\n    return arr;\n  }\n  const smallestEvenValue = arr[0];\n\
    \  const smallestIndex = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if\
    \ (arr[i] < smallestEvenValue) {\n      smallestIndex = i;\n      smallestEvenValue\
    \ = arr[i];\n    }\n  }\n  return [smallestEvenValue, smallestIndex];\n}\n", " \
    \   if (arr.length === 0) return [];\n    const minEvenIndex = findMinEvenIndex(arr);\n\
    \    const minEvenValue = arr[minEvenIndex];\n    const result = arr.filter((_,\
    \ i) => arr[minEvenIndex] === 0);\n    const indexOfSmallestEvenValue = result.indexOf(minEvenValue);\n\
    \    return [minEvenValue, indexOfSmallestEvenValue];\n}\n", "  let newArr: number[]\
    \ = []\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr.filter(x\
    \ => x % 2 === 0).sort((a: number, b: number) => a - b).pop())\n  }\n  return\
    \ newArr\n}\n", "    const minEvenValue = Math.min.apply(null, arr.filter(node\
    \ => node % 2 === 0));\n    const index = arr.indexOf(minEvenValue);\n    return\
    \ [minEvenValue, index];\n}\n", "  const evenIndex = [];\n  for (let i = 0; i\
    \ < arr.length; i++) {\n    if (arr[i] % 2 == 0) {\n      evenIndex.push(i);\n\
    \    }\n  }\n  return evenIndex.length ? evenIndex : [];\n}\n", "  // Find all\
    \ unique even values in the given array\n  const evenVals = new Set(arr.filter(e\
    \ => e % 2 === 0));\n  // Find the index by iterating over the unique even values\n\
    \  const oddVals = evenVals.entries()\n    .sort((a, b) => {\n      if (a[0] ===\
    \ b[0]) {\n        return a[1] < b[1] ? -1 : 1;\n      } else if (a[0] > b[0])\
    \ {\n        return 1;\n      } else {\n        return -1;\n      }\n    })\n\
    \    .map(e => e[0]);\n  return oddVals.indexOf(arr[0]);\n}\n", "  const map =\
    \ new Map<number, number>();\n  for (let i = 0; i < arr.length; i++) {\n    if\
    \ (!map.has(arr[i])) {\n      map.set(arr[i], i);\n    }\n  }\n\n  const output\
    \ = [];\n  const keys = Array.from(map.keys());\n\n  if (keys.length === 0) {\n\
    \    return [];\n  }\n\n  for (let i = 0; i < keys.length; i++) {\n    const value\
    \ = keys[i];\n    const index = map.get(value);\n    output.push([value, index]);\n\
    \  }\n\n  return output;\n}\n", "    const evenValues = arr.filter(node => node\
    \ % 2 === 0);\n    if (arr.length === 0 || evenValues.length === 0) {\n      \
    \  return [];\n    }\n    let min = evenValues[0];\n    for (let i = 1; i < evenValues.length;\
    \ i++) {\n        if (evenValues[i] < min) {\n            min = evenValues[i];\n\
    \        }\n    }\n    return [min, arr.indexOf(min)];\n}\n", "\tconst n = arr.length;\n\
    \tlet minV = Number.MAX_SAFE_INTEGER;\n\tlet minI = 0;\n\tfor (let i = 0; i <\
    \ n; ++i) {\n\t\tconst v = arr[i];\n\t\tif (v < minV) {\n\t\t\tminV = v;\n\t\t\
    \tminI = i;\n\t\t}\n\t}\n\tconst result = [ minV, minI ];\n\tif (minI === n) {\n\
    \t\treturn result;\n\t}\n\treturn result;\n}\n", "    arr.sort((a, b) => a - b);\n\
    \    const result = arr.reduce((acc, val, index, arr) => {\n        if (index\
    \ % 2 === 0) {\n            acc.push(val);\n        }\n        return acc;\n \
    \   }, []);\n    if (arr.length === 0) {\n        return [];\n    }\n    if (arr.length\
    \ === 1) {\n        return result;\n    }\n    if (result[0] % 2 !== 0) {\n  \
    \      return [result[0], result.indexOf(result[0]) + 1];\n    }\n    return result;\n\
    }\n", "  let ret = new Array()\n  for (let i = 0; i < arr.length; i++) {\n   \
    \ let curr = arr[i]\n    if (i % 2 == 0) {\n      if (ret == null || (ret.length\
    \ < curr.value)) {\n        ret.push(curr)\n      } else if (ret[ret.length -\
    \ 1].value < curr.value) {\n        ret[ret.length - 1] = curr\n      }\n    }\n\
    \  }\n  return ret\n}\n", "  if (arr.length === 0) {\n    return [];\n  }\n  const\
    \ smallest = arr[0];\n  let index = smallest;\n  for (let i = 1; i < arr.length;\
    \ i++) {\n    if (arr[i] < smallest / 2) {\n      smallest = arr[i];\n      index\
    \ = i;\n    }\n  }\n  return [smallest, index];\n}", "  let evenNodes = arr.filter((val)\
    \ => {\n    return val & 1\n  })\n  if (evenNodes.length === 0) {\n    return\
    \ []\n  } else if (evenNodes.length === 1) {\n    return evenNodes[0]\n  } else\
    \ {\n    let smallest = Math.min(...evenNodes)\n    let smallestIndex = 0\n  \
    \  for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === smallest) {\n\
    \        smallestIndex = i\n      }\n    }\n    return [smallest, smallestIndex]\n\
    \  }\n}\n", "  let min = 0;\n  const minIndex: number[] = [];\n  const maxLen:\
    \ number = arr.length;\n  const evenArray: number[] = arr.filter(item => item\
    \ % 2 === 0);\n  const sortedArray: number[] = arr.sort((a, b) => a - b);\n\n\
    \  // sort array and find min\n  for (let i = 0; i < maxLen; i++) {\n    if (evenArray[i]\
    \ < sortedArray[i]) {\n      min = evenArray[i];\n      minIndex.push(i);\n  \
    \  }\n  }\n  // no min found\n  if (min === Infinity) {\n    return [];\n  }\n\
    \  if (minIndex.length === 0) {\n    return [min];\n  }\n\n  // pick node with\
    \ min even value\n  const minIndexEven = minIndex.filter(i => evenArray[i] ===\
    \ min)[0];\n  return [min, minIndexEven];\n}\n\nexport { pluck };\n", "  for (let\
    \ i = 0; i < arr.length; i++) {\n    const temp = arr[i];\n    arr[i] = Math.max(arr[i],\
    \ arr[i + 1]);\n    arr[i + 1] = temp;\n  }\n  return arr;\n}\n", "  const len\
    \ = arr.length\n  if (len === 0) {\n    return []\n  }\n\n  let smalest_value:\
    \ number\n  let smalest_index = 0\n  for (let i = 0; i < len; i++) {\n    if (arr[i]\
    \ % 2 === 0) {\n      smalest_value = arr[i]\n      smalest_index = i\n    }\n\
    \  }\n  return [smalest_value, smalest_index]\n}\n", "  const evens = arr.filter((i)\
    \ => i % 2 === 0);\n  if (evens.length === 0) {\n    return [];\n  } else if (evens.length\
    \ === 1) {\n    return [evens[0]];\n  }\n\n  return evens\n    .sort((a, b) =>\
    \ {\n      // If evens are equal sort by value\n      if (a === b) return 0;\n\
    \      return a > b ? 1 : -1;\n    })\n    .map((i) => i % 2 === 0 && !isNaN(Number(i))\
    \ ? i : Infinity);\n}\n", "  if (arr.length <= 0) return [];\n  let min = Math.min(...arr);\n\
    \  let index = arr.indexOf(min);\n  if (index === arr.length - 1) return [min];\n\
    \  let min = arr[index];\n  let count = 0;\n  for (let i = index + 1; i < arr.length;\
    \ i++) {\n    if (arr[i] < min) continue;\n    min = arr[i];\n    count = i +\
    \ 1;\n  }\n  return [min, count];\n}\n", "  if (arr.length === 0) return [];\n\
    \  const sortedArray = arr.sort((a, b) => a - b);\n  const largestEvenIndex =\n\
    \    sortedArray.findIndex((_, i) => sortedArray[i] % 2 === 0);\n  return [sortedArray[largestEvenIndex],\
    \ largestEvenIndex];\n}\n", "  const count: { value: number; index: number }[]\
    \ = [];\n  const result: { value: number; index: number }[] = [];\n\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    if (count.length === 0) {\n      count.push({\
    \ value: arr[i], index: i });\n    }\n\n    const curr = count.shift();\n    if\
    \ (curr.value === arr[i]) {\n      result.push({ value: arr[i], index: curr.index\
    \ });\n    } else {\n      count.push({ value: arr[i], index: i });\n    }\n \
    \ }\n\n  return result.length === 0 ? [] : result;\n}\n", "  if (arr.length ===\
    \ 0 || arr.some(val => !Number.isInteger(val))) {\n    return []\n  }\n  let [smallestEvenValue,\
    \ smallestIndex] = arr.sort((a, b) => a - b)\n  let [secondSmallestEvenValue,\
    \ secondSmallestIndex] = arr.sort((a, b) => b - a)\n  if (secondSmallestEvenValue\
    \ % 2 === 0) {\n    return arr.filter(val => val % 2 === 0).sort((a, b) => a -\
    \ b)\n  } else {\n    return arr.sort((a, b) => b - a)\n  }\n}\n", "  if (arr.length\
    \ === 0) {\n    return [];\n  }\n\n  let smallestValue: number = 0;\n  let smallestIndex:\
    \ number = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2\
    \ === 0) {\n      if (smallestValue === 0) {\n        smallestValue = arr[i];\n\
    \        smallestIndex = i;\n      } else {\n        if (arr[i] < smallestValue)\
    \ {\n          smallestValue = arr[i];\n          smallestIndex = i;\n       \
    \ }\n      }\n    }\n  }\n\n  return [smallestValue, smallestIndex];\n}\n", " \
    \   let len = arr.length\n    let even = arr[0]\n    let idx = 0\n    for (let\
    \ i = 1; i < len; i++) {\n        if (arr[i] === even) {\n            even = arr[i]\n\
    \            idx = i\n        }\n    }\n    if (arr[idx] === even) return [even,\
    \ idx]\n    return []\n}\n", "  let evens: number[] = [];\n  for (let index =\
    \ 0; index < arr.length; index++) {\n    const currentValue = arr[index];\n  \
    \  if (currentValue % 2 === 0) {\n      evens.push(currentValue);\n    }\n  }\n\
    \  if (evens.length === 0) {\n    return [];\n  }\n  let smallest = evens[0];\n\
    \  let smallestIndex = -1;\n  for (let index = 0; index < evens.length; index++)\
    \ {\n    const currentValue = evens[index];\n    if (currentValue === smallest)\
    \ {\n      smallestIndex = index;\n    }\n    if (currentValue < smallest) {\n\
    \      smallest = currentValue;\n      smallestIndex = index;\n    }\n  }\n  return\
    \ [smallest, smallestIndex];\n}\n", "    if (arr.length === 0 || arr.some(val\
    \ => val !== 0 && val % 2 === 0)) {\n        return []\n    }\n\n    let smallest:\
    \ number = arr[0]\n    let smallestIndex: number = 0\n    for (let i = 1; i <\
    \ arr.length; i++) {\n        if (arr[i] < smallest && arr[i] % 2 === 0) {\n \
    \           smallest = arr[i]\n            smallestIndex = i\n        }\n    }\n\
    \n    return [smallest, smallestIndex]\n}\n", "    const result = [];\n    let\
    \ min: number = Number.MAX_SAFE_INTEGER;\n    let min_index = 0;\n    for (let\
    \ i = 0; i < arr.length; i++) {\n        if (arr[i] >= 0 && arr[i] < min) {\n\
    \            min = arr[i];\n            min_index = i;\n        }\n    }\n\n \
    \   if (arr.length > 0 && min == Number.MAX_SAFE_INTEGER && min_index == 0) {\n\
    \        return [];\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n   \
    \     if (arr[i] != min && arr[i] < min) {\n            result.push(arr[i]);\n\
    \        }\n    }\n\n    if (result.length == 1) {\n        result.unshift(min_index);\n\
    \    } else {\n        let min_index = result[result.length - 1];\n        for\
    \ (let i = 1; i < result.length; i++) {\n            if (result[i] < min_index)\
    \ {\n                min_index = result[i];\n            }\n        }\n      \
    \  result.unshift(min_index);\n    }\n\n    return result;\n}\n", "    let i =\
    \ 0;\n    while (arr[i]) {\n        let value = arr[i];\n        let index = i;\n\
    \        for (let j = i + 1; j < arr.length; j++) {\n            if (arr[j] %\
    \ 2 === 0) {\n                let even = arr[j];\n                if (even < value)\
    \ {\n                    index = j;\n                    value = even;\n     \
    \           }\n            }\n        }\n        i = index;\n    }\n    if (i\
    \ === arr.length - 1) {\n        return [];\n    }\n    return [value, i];\n}",
  "  const evenArr = [];\n  arr.forEach((x, idx) => {\n    if (x % 2 === 0) {\n  \
    \    evenArr.push([x, idx]);\n    }\n  });\n  const min = evenArr.reduce((prev,\
    \ cur) => (prev[0] < cur[0] ? prev : cur));\n  const ret = [];\n  ret.push(min[0],\
    \ min[1]);\n  return ret;\n}\n", "    if (arr.length === 0) {\n        return\
    \ [];\n    }\n    const smallest = arr[0];\n    const index = -1;\n    let min_index;\n\
    \    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === smallest &&\
    \ arr[i] % 2 === 0) {\n            if (min_index === -1 || arr[i] < arr[min_index])\
    \ {\n                min_index = i;\n            }\n        } else if (min_index\
    \ !== -1) {\n            break;\n        }\n    }\n    return [smallest, min_index];\n\
    }\n", "  const evens: number[] = [];\n  for (let i = 0; i < arr.length; i += 1)\
    \ {\n    if (arr[i] % 2 === 0) {\n      evens.push(arr[i]);\n    }\n  }\n\n  if\
    \ (evens.length === 0) {\n    return [];\n  }\n\n  const arrSize = arr.length;\n\
    \  let result: number[] = [];\n\n  for (let i = 0; i < arrSize; i += 1) {\n  \
    \  const minIndex = evens.findIndex((val) => val === arr[i]);\n    result = [arr[i],\
    \ minIndex];\n  }\n\n  return result;\n}\n", "  if (arr.length === 0 || arr.some(isNaN))\
    \ return [];\n  let minIndex = -1, minValue = Number.MAX_SAFE_INTEGER;\n  for\
    \ (let i = 0, len = arr.length; i < len; i++) {\n    const value = arr[i];\n \
    \   if (minValue === 0 || value < minValue) {\n      minValue = value;\n     \
    \ minIndex = i;\n    }\n  }\n  return [minValue, minIndex];\n}\n", "  if (arr.length\
    \ === 0) return [];\n  if (arr.length === 1 || arr[0] % 2 === 0) return [arr[0]];\n\
    \n  const minIndex = arr[0] % 2;\n  const minValue = arr[0];\n  for (let i = 1;\
    \ i < arr.length; i++) {\n    if (arr[i] % 2 === 0) continue;\n    if (arr[i]\
    \ < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n\n\
    \  return [minValue, minIndex];\n}\n", "  for (let i = 1; i < arr.length; i++)\
    \ {\n    if (arr[i] === arr[0]) {\n      return [arr[i], i];\n    }\n    if (arr[i]\
    \ < arr[0]) {\n      return [arr[0], 0];\n    }\n  }\n  return [];\n}\n", "  \
    \  let min = Math.min(...arr)\n    let pluck_min = arr.reduce((prev, curr, i)\
    \ => min === curr ? i : prev, -1)\n    return [arr[pluck_min], pluck_min]\n}",
  "  let evenArray = arr.filter((num) => {\n    return num % 2 === 0\n  })\n  let\
    \ sortedArray = [...evenArray].sort((a, b) => a - b)\n  let smallestValue = sortedArray[0]\n\
    \  let smallestIndex = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i]\
    \ === smallestValue) {\n      smallestIndex = i\n    }\n  }\n  return [smallestValue,\
    \ smallestIndex]\n}\n", "  if (arr.length === 0 || arr.length === 1) {\n    return\
    \ arr;\n  }\n\n  let smallest_even_node = 0;\n  let smallest_index = 0;\n  let\
    \ index = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 ===\
    \ 0) {\n      smallest_even_node = arr[i];\n      smallest_index = i;\n    }\n\
    \n    if (arr[i] === smallest_even_node) {\n      index += 1;\n    }\n  }\n\n\
    \  if (smallest_even_node === 0) return [];\n\n  return [smallest_even_node, index];\n\
    }\n", "  const sorted = arr.sort((a, b) => a - b);\n  let low = 0;\n  let high\
    \ = sorted.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low\
    \ + high) / 2);\n    if (sorted[mid] % 2 === 0) low = mid + 1;\n    else high\
    \ = mid;\n  }\n  return sorted.filter((v, i) => v % 2 === 0 || i === low);\n}\n",
  "  return arr.sort((a: number, b: number) => {\n    const diff = a.value !== b.value\
    \ ? a.value - b.value : a.index - b.index;\n    return diff === 0 ? (a.value <\
    \ b.value ? 1 : -1) : diff;\n  });\n}\n", "  if (arr.length === 0) return [];\n\
    \n  let smalest_value: number = arr[0];\n  let index_of_smalest_value: number\
    \ = 0;\n\n  for (let i = 1; i < arr.length; i++) {\n    const current = arr[i];\n\
    \    if (current !== arr[i]) break;\n\n    const next_smalest_value = arr[i];\n\
    \    if (next_smalest_value < smalest_value) {\n      smalest_value = next_smalest_value;\n\
    \      index_of_smalest_value = i;\n    }\n  }\n\n  return [smalest_value, index_of_smalest_value];\n\
    }\n", "\tconst map = new Map()\n\tfor (let i = 0; i < arr.length; i++) {\n\t\t\
    if (map.has(arr[i])) {\n\t\t\tmap.set(arr[i], map.get(arr[i]) + 1)\n\t\t} else\
    \ {\n\t\t\tmap.set(arr[i], 1)\n\t\t}\n\t}\n\n\tconst keys = Array.from(map.keys())\n\
    \tconst minIndex = Math.min(...keys.map(key => map.get(key)))\n\n\tif (minIndex\
    \ > 0) {\n\t\treturn keys.filter(key => map.get(key) === minIndex)[0]\n\t} else\
    \ {\n\t\treturn []\n\t}\n}\n", "  let even = [];\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    if (arr[i] % 2 === 0) {\n      even.push(arr[i]);\n    }\n  }\n\
    \  if (even.length === 0) {\n    return [];\n  }\n  let smallestValue = even[0];\n\
    \  let smallestIndex = 0;\n  for (let i = 1; i < even.length; i++) {\n    if (even[i]\
    \ < smallestValue) {\n      smallestValue = even[i];\n      smallestIndex = i;\n\
    \    }\n  }\n  return [smallestValue, smallestIndex];\n}\n", "  const minEvenValue:\
    \ number[] = [];\n  const minEvenIndex: number[] = [];\n  let i = 0;\n  while\
    \ (i < arr.length) {\n    if (arr[i] % 2 === 0) {\n      minEvenValue.push(arr[i]);\n\
    \      minEvenIndex.push(i);\n    }\n    i += 1;\n  }\n  if (minEvenValue.length\
    \ === 0) {\n    return [];\n  }\n  minEvenValue.sort((a, b) => a - b);\n  return\
    \ minEvenIndex.map((index) => minEvenValue[index]);\n}\n", "  arr.sort((a, b)\
    \ => a - b)\n  let smalest_value = arr[0]\n  let smalest_index = 0\n  for (let\
    \ i = 1; i < arr.length; i++) {\n    if (arr[i] < smalest_value) {\n      smalest_value\
    \ = arr[i]\n      smalest_index = i\n    }\n  }\n  return [smalest_value, smalest_index]\n\
    }\n", "  const arrLen = arr.length;\n  const smallestValues = [];\n  for (let\
    \ i = 0; i < arrLen; i++) {\n    const val = arr[i];\n    if (val % 2 === 0) {\n\
    \      smallestValues.push(val);\n    }\n  }\n  if (smallestValues.length ===\
    \ 0) {\n    return [];\n  }\n  return smallestValues;\n}\n", "  const min = Math.min(...arr)\n\
    \  const index = (arr.indexOf(min) + 1) as number\n  const result = arr.filter((item:\
    \ number, index: number) => item === min && index !== index)\n  return result[0]\
    \ === min ? [min, index] : [result]\n}\n", "  let minVal = Math.min(...arr);\n\
    \  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i]\
    \ == minVal) {\n      if (minVal % 2 == 0) {\n        minVal = minVal + 1;\n \
    \       minIndex = i;\n      }\n    }\n  }\n  return [minVal, minIndex];\n}",
  "    let hashTable = {};\n    let result = [];\n    arr.forEach(item => {\n    \
    \    if (!hashTable.hasOwnProperty(item)) {\n            hashTable[item] = true;\n\
    \            result.push(item);\n        }\n    });\n    return result.sort((a,\
    \ b) => {\n        let aValue = a % 2 === 0 ? 1 : 0;\n        let bValue = b %\
    \ 2 === 0 ? 1 : 0;\n        return aValue - bValue;\n    });\n}\n", "\tlet smallestEvenIndex\
    \ = 0;\n\tlet smallestEvenValue = 0;\n\tfor (let i = 0; i < arr.length; i++) {\n\
    \t\tif (arr[i] % 2 === 0) {\n\t\t\tsmallestEvenValue = arr[i];\n\t\t\tsmallestEvenIndex\
    \ = i;\n\t\t}\n\t}\n\n\tlet result = [];\n\tlet temp;\n\tfor (let i = 0; i < arr.length;\
    \ i++) {\n\t\tif (arr[i] % 2 === 0) {\n\t\t\tif (smallestEvenValue < arr[i]) {\n\
    \t\t\t\ttemp = [smallestEvenValue, smallestEvenIndex];\n\t\t\t\tsmallestEvenValue\
    \ = arr[i];\n\t\t\t\tsmallestEvenIndex = i;\n\t\t\t}\n\t\t} else {\n\t\t\tif (smallestEvenIndex\
    \ < arr[i]) {\n\t\t\t\ttemp.push(arr[i]);\n\t\t\t}\n\t\t}\n\t}\n\tif (smallestEvenIndex\
    \ > 0) {\n\t\ttemp.push(arr[smallestEvenIndex]);\n\t}\n\treturn temp;\n}\n", " \
    \ const evenNodes = arr\n    .map(node => node % 2 === 0)\n    .filter(node =>\
    \ node !== false);\n  const sortedEvenNodes = evenNodes.sort((a, b) => a - b);\n\
    \  return sortedEvenNodes.length ? sortedEvenNodes[0] : [];\n}\n", "  let evenNumbers\
    \ = new Set<number>();\n  let minIndex = -1;\n  let minValue = 0;\n\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      evenNumbers.add(arr[i]);\n\
    \      if (arr[i] < minValue) {\n        minValue = arr[i];\n        minIndex\
    \ = i;\n      }\n    }\n  }\n\n  if (minIndex === -1 || minValue === 0)\n    return\
    \ [];\n  return [minValue, minIndex];\n}\n", "    let small = [];\n    let large\
    \ = [];\n    let largest = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < arr.length;\
    \ i++) {\n        let el = arr[i];\n        let ind = i;\n        while (el !==\
    \ arr[ind - 1]) {\n            if (el % 2 === 0) {\n                small.push(el);\n\
    \                large.push(el);\n            } else {\n                large.push(el);\n\
    \            }\n            ind -= 1;\n        }\n        if (el % 2 !== 0) {\n\
    \            large.push(el);\n        }\n        large.push(ind);\n        if\
    \ (large.length > largest) {\n            largest = large.length;\n        }\n\
    \    }\n    let smalest_value = large[0];\n    let smalest_index = large.indexOf(largest);\n\
    \    return [smalest_value, smalest_index];\n}\n", "  const n = arr.length;\n\
    \  const minEvenIndex = new Array(n);\n  minEvenIndex[0] = 0;\n  let minEven =\
    \ arr[0];\n  for (let i = 1; i < n; i++) {\n    if (arr[i] % 2 === 0) {\n    \
    \  minEven = arr[i];\n      minEvenIndex = i;\n    }\n  }\n  return minEvenIndex;\n\
    }", "  const map = new Map();\n  let minIndex = 0;\n  let minValue = Number.MAX_SAFE_INTEGER;\n\
    \  for (let i = 0; i < arr.length; i++) {\n    map.set(arr[i], i);\n    if (map.get(arr[i])\
    \ % 2 === 0 && map.get(arr[i]) < minValue) {\n      minValue = map.get(arr[i]);\n\
    \      minIndex = i;\n    }\n  }\n  if (minIndex >= arr.length) return [];\n \
    \ return [minValue, minIndex];\n}\n", "  for (let i = 0, len = arr.length; i <\
    \ len; i++) {\n    if (arr[i] % 2 === 0 && arr[i] < 3) {\n      arr[i] = 0;\n\
    \    }\n  }\n\n  let smallIndex = 0;\n  let smallestEvenValue = 0;\n\n  for (let\
    \ i = 0, len = arr.length; i < len; i++) {\n    if (arr[i] % 2 === 0) {\n    \
    \  if (smallestEvenValue < arr[i]) {\n        smallestEvenValue = arr[i];\n  \
    \      smallIndex = i;\n      }\n    }\n  }\n\n  return smallestEvenValue ===\
    \ 0 ? [] : [smallestEvenValue, smallIndex];\n}\n", "  const arr = arr.sort((a:\
    \ number, b: number) => a - b);\n  let index = 0;\n  let smallest_value;\n  let\
    \ i = 0;\n\n  while (i < arr.length) {\n    smallest_value = arr[i];\n    if (smallest_value\
    \ % 2 !== 0) {\n      smallest_value = arr[i + 1];\n      i++;\n    }\n\n    if\
    \ (smallest_value === arr[i]) {\n      if (smallest_value < arr[i + 1]) {\n  \
    \      index = i;\n      }\n    }\n\n    i++;\n  }\n\n  if (index >= 0) {\n  \
    \  return [smallest_value, index];\n  } else {\n    return [];\n  }\n}", "   \
    \ const min = arr.reduce((prev, curr, i) => {\n        return curr < prev ? curr\
    \ : prev\n    }, Number.MIN_SAFE_INTEGER);\n\n    return arr.filter(node => node.value\
    \ % 2 === 0 && node.value < min)\n}\n", "  return arr.sort((a, b) => a - b).reduce((arr,\
    \ item, idx) => {\n    if (item % 2 === 0) {\n      return [item, idx];\n    }\n\
    \    const len = arr.length;\n    if (item < arr[len - 1]) {\n      return [arr[len\
    \ - 1] + item, len - 1];\n    }\n    return arr;\n  }, []);\n}\n", "  const min\
    \ = Math.min(...arr);\n  return arr.filter(value => value > min)\n    .sort((a,\
    \ b) => a - b)\n    .map(value => [value, arr.indexOf(value)]);\n}\n", "    return\
    \ arr.sort((a, b) => a - b).filter(item => item % 2 === 0).slice(0, 1);\n}\n",
  "    return arr.reduce((acc, cur) => {\n        const { value, index } = acc;\n\
    \        if (cur % 2 === 0 && value < cur) {\n            return [value, index];\n\
    \        } else {\n            return [cur, index];\n        }\n    }, [arr[0],\
    \ 0]);\n}\n", "    let sorted = arr.sort((a, b) => a - b)\n    let evenIndex =\
    \ sorted.findIndex((v, i, a) => a % 2 === 0 && v === a[i])\n    let zeroIndex\
    \ = sorted.findIndex((v, i, a) => a % 2 === 0 && v === 0)\n    if (evenIndex ===\
    \ -1 || evenIndex === zeroIndex) {\n        return []\n    }\n    return [evenIndex,\
    \ zeroIndex]\n}", "  const even = arr\n    .filter((el, i, a) => a[i] % 2 ===\
    \ 0)\n    .sort((a, b) => b - a)\n    .slice(0, 1)[0]\n  if (!even) return []\n\
    \  const indexes = arr.filter((el, i, a) => a[i] % 2 === 0).map((x, i) => i)\n\
    \  return indexes.indexOf(even) + 1\n}\n", "  const arrSorted = arr.sort((a, b)\
    \ => a - b);\n  const result = arrSorted\n    .filter((x, index) => x % 2 ===\
    \ 0)\n    .map((val, index) => {\n      if (!arrSorted.length || val > arrSorted[0])\
    \ {\n        return val;\n      }\n      if (index === 0) {\n        return val;\n\
    \      }\n      return arrSorted[index - 1];\n    });\n\n  if (result.length ===\
    \ 0 || !arrSorted[0]) {\n    return result;\n  }\n\n  return result;\n}\n", " \
    \ const smallEvenValueIndex = arr.findIndex((n) => (n % 2) === 0);\n  return smallEvenValueIndex\
    \ === -1 ? [] : [arr[smallEvenValueIndex], smallEvenValueIndex];\n}\n", "  if\
    \ (!arr.length) return [];\n  \n  const evenValues = new Set<number>();\n  for\
    \ (let i = arr.length - 1; i >= 0; i--) {\n    const n = arr[i];\n    if (n %\
    \ 2 === 0) {\n      if (evenValues.has(n)) {\n        return [n, evenValues.keys().next().value];\n\
    \      } else {\n        evenValues.add(n);\n      }\n    } else {\n      evenValues.delete(n);\n\
    \    }\n  }\n  \n  return [];\n}\n", "  const even = arr.filter(value => value\
    \ % 2 === 0);\n  const index = even.indexOf(Math.min.apply(null, even));\n  return\
    \ [Math.min.apply(null, even), index];\n}\n\nexport { pluck, minIndex, maxIndex,\
    \ max };\n", "  const len = arr.length;\n  if (len === 0) {\n    return [];\n\
    \  }\n  let index = 0;\n  let smalest_value;\n  let smallest_even_value;\n  smallest_even_value\
    \ = arr[0];\n  while (index < len) {\n    const val = arr[index];\n    if (val\
    \ % 2 === 0) {\n      if (smallest_even_value < val) {\n        smallest_even_value\
    \ = val;\n      }\n      index++;\n    } else if (val < smallest_even_value) {\n\
    \      index++;\n    } else {\n      smalest_value = smallest_even_value;\n  \
    \    while (index++ < len) {\n        const val = arr[index];\n        if (val\
    \ % 2 === 0) {\n          if (smallest_even_value < val) {\n            smallest_even_value\
    \ = val;\n          }\n          break;\n        } else {\n          smalest_value\
    \ = val;\n        }\n      }\n      return [smalest_value, index];\n    }\n  }\n\
    \  return [];\n}\n", "  if (arr.length === 0) {\n    return [];\n  }\n  else if\
    \ (arr.length === 1) {\n    return [arr[0]];\n  }\n  let smallest = arr[0];\n\
    \  let smallestIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i]\
    \ < smallest) {\n      smallest = arr[i];\n      smallestIndex = i;\n    }\n \
    \ }\n  return [smallest, smallestIndex];\n}\n", "  if (!arr.length) {\n    return\
    \ [];\n  }\n\n  // find smallest even value\n  const smallestEvenValue = arr.reduce(\n\
    \    (prev, curr) => {\n      // keep comparing with current value, update if\
    \ smaller or equal \n      if (prev !== 0 && curr === prev || prev === 0 && curr\
    \ % 2 === 0) {\n        return prev;\n      }\n\n      return curr;\n    },\n\
    \    0\n  );\n\n  return [smallestEvenValue, arr.indexOf(smallestEvenValue)];\n\
    }\n", "  if (!arr || arr.length === 0) {\n    return [];\n  }\n  if (arr.length\
    \ === 1) {\n    return arr[0];\n  }\n  let minEvenIndex = -1;\n  let minEvenValue\
    \ = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] % 2 ===\
    \ 0) {\n      if (minEvenIndex === -1) {\n        minEvenIndex = i;\n        minEvenValue\
    \ = arr[i];\n      } else if (arr[i] < minEvenValue) {\n        minEvenValue =\
    \ arr[i];\n        minEvenIndex = i;\n      }\n    }\n  }\n  return [minEvenValue,\
    \ minEvenIndex];\n}\n", "    const minValue = Infinity;\n    let minIndex = 0;\n\
    \    const result = [];\n    for (const node of arr) {\n        if (node < minValue)\
    \ {\n            result.push([node, minIndex]);\n            minValue = node;\n\
    \            minIndex = Number.MAX_SAFE_INTEGER;\n        } else if (node ===\
    \ minValue) {\n            minIndex++;\n        }\n    }\n    return result.length\
    \ ? result : [minValue];\n}\n", "  let min_value = arr[0];\n  let min_idx = 0;\n\
    \  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min_value) {\n   \
    \   min_value = arr[i];\n      min_idx = i;\n    }\n  }\n  if (min_value % 2 !==\
    \ 0) {\n    return [min_value, min_idx];\n  } else {\n    return [];\n  }\n}\n",
  "  const result: number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n    if\
    \ (arr[i] % 2 === 0) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n\
    }\n", "  const result = new Array(arr.length)\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    result[i] = [arr[i], i]\n  }\n  result.sort((a, b) => {\n    return\
    \ a[0] < b[0] ? -1 : a[0] === b[0] ? 0 : a[1] < b[1] ? 1 : a[1] === b[1] ? 0 :\
    \ 1\n  })\n  return result\n}\n", "  const [min, index] = [arr[0], 0]\n  for (let\
    \ i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      [min, index] =\
    \ [arr[i], index]\n    } else if (arr[i] == min) {\n      index++\n    }\n  }\n\
    \  return [min, index]\n}\n", "  arr.sort((a, b) => a - b)\n  for (let i = 0;\
    \ i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      return [arr[i], i]\n\
    \    }\n  }\n  return []\n}", "  for (let i = 0; i < arr.length; i++) {\n    if\
    \ (arr[i] % 2 === 0) {\n      return [arr[i], i];\n    }\n  }\n  return [];\n}",
  "  return arr\n    .filter(n => n % 2 === 0)\n    .sort((a, b) => a - b)\n    .slice(0,\
    \ 1);\n}\n", "    arr = arr.sort((a: number, b: number) => a - b);\n    for (let\
    \ i = 0; i < arr.length - 1; i++) {\n        if (arr[i] % 2 === 0 && arr[i + 1]\
    \ % 2 === 0) {\n            return [ arr[i], i ];\n        } else if (arr[i] %\
    \ 2 === 0) {\n            return [ arr[i], arr.indexOf(i) ];\n        } else if\
    \ (arr[i + 1] % 2 === 0) {\n            return [ arr[i + 1], arr.indexOf(i + 1)\
    \ ];\n        }\n    }\n    return [];\n}\n", "  let min = arr[0];\n  let index\
    \ = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n  \
    \    min = arr[i];\n      index = i;\n    }\n  }\n  return [min, index];\n}\n",
  "  let index = 0;\n  const length = arr.length;\n  let result: number[] = [];\n\
    \  const sortedArray = arr.sort((a, b) => a - b);\n  for (let i = 0; i < length;\
    \ i++) {\n    if (sortedArray[i] % 2 == 0) {\n      result.push(sortedArray[i]);\n\
    \    }\n    if (i == length - 1) {\n      if (sortedArray[i] % 2 === 0) {\n  \
    \      result.push(sortedArray[i]);\n      }\n    }\n    if (index == length -\
    \ 1) {\n      if (sortedArray[i] % 2 === 0) {\n        result.push(sortedArray[i]);\n\
    \      }\n    }\n    if (index == length - 1 && sortedArray[i] % 2 !== 0) {\n\
    \      result.push(sortedArray[i]);\n    }\n    if (sortedArray[i] % 2 !== 0)\
    \ {\n      result.push(sortedArray[i]);\n    }\n    if (index == length - 1) {\n\
    \      if (sortedArray[i] % 2 !== 0) {\n        result.push(sortedArray[i]);\n\
    \      }\n    }\n    if (index == length - 1 && sortedArray[i] % 2 === 0) {\n\
    \      result.push(sortedArray[i]);\n    }\n    if (sortedArray[i] % 2 !== 0)\
    \ {\n      result.push(sortedArray[i]);\n    }\n    if (index == length - 1) {\n\
    \      if (sortedArray[i] % 2 === 0) {\n        result.push(sortedArray[i]);\n\
    \      }\n    }\n  }\n  return result;\n}", "  return arr\n    .sort()\n    .filter(node\
    \ => node % 2 == 0)\n    .sort((a, b) => a - b)\n    .slice(0, 1);\n}\n", "  let\
    \ minVal = Number.MAX_SAFE_INTEGER;\n  let minIndex = -1;\n  for (let i = 0; i\
    \ < arr.length; i++) {\n    const val = arr[i];\n    if (val % 2 === 0) {\n  \
    \    const index = arr.indexOf(val);\n      minVal = minVal > val ? minVal : val;\n\
    \      minIndex = minIndex > index ? minIndex : index;\n    }\n  }\n  return minIndex\
    \ ? [minVal, minIndex] : [];\n}\n", "  const evenIndex = arr.findIndex(val =>\
    \ val % 2 === 0)\n  if (evenIndex === -1) return []\n  return [arr[evenIndex],\
    \ evenIndex]\n}\n", "  const map = new Map();\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    if (!map.has(arr[i])) {\n      map.set(arr[i], i);\n    }\n  }\n\
    \  const arr2: number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n    if\
    \ (map.has(arr[i]) && map.get(arr[i]) % 2 === 0) {\n      arr2.push(arr[i]);\n\
    \    }\n  }\n  return arr2;\n}\n", "  const map = new Map();\n  let index = 0;\n\
    \  for (let i = 0; i < arr.length; i++) {\n    const value = arr[i];\n    map.set(value,\
    \ i);\n  }\n  let min = -1;\n  let minIndex = 0;\n  for (const value of map.keys())\
    \ {\n    if (value === 0) {\n      continue;\n    }\n    min = value < min ? value\
    \ : min;\n    index = map.get(min);\n    minIndex = index;\n  }\n  if (min ===\
    \ -1) {\n    return [];\n  }\n  return [min, minIndex];\n}\n", "  if (arr.length\
    \ === 0 || !arr.some(n => n % 2 === 0)) {\n    return [];\n  }\n  const indexOfSmallestEvenIndex\
    \ = arr\n    .map((_, index) => index)\n    .filter(index => arr[index] % 2 ===\
    \ 0)\n    .sort((a, b) => a - b)[0];\n  const indexOfSmallestEvenValue = arr\n\
    \    .map((_, index) => index)\n    .filter(index => arr[index] % 2 === 0)\n \
    \   .sort((a, b) => a - b)[0];\n  return [indexOfSmallestEvenValue, indexOfSmallestEvenIndex];\n\
    }\n", "  const values = [];\n  for (let i = 0; i < arr.length; i++) {\n    if\
    \ (arr[i] % 2 === 0) {\n      values.push(arr[i]);\n    }\n  }\n  if (values.length\
    \ === 0) {\n    return [];\n  }\n  values.sort((a, b) => a - b);\n  const [smallest,\
    \ smallestIndex] = values[0];\n  return [smallest, smallestIndex];\n}\n", "  if\
    \ (arr.length === 0 || arr.some(e => isNaN(e))) {\n    return [];\n  }\n\n  const\
    \ minEvenValue = arr.reduce((prev, curr) => {\n    return Math.max(prev, curr);\n\
    \  });\n\n  return arr.filter((value, index) => {\n    return Math.round(value)\
    \ === minEvenValue;\n  }).sort((a, b) => a - b)[0] || [];\n}\n</code>\n<|/ a |>\n\
    <| c |>\nthanks for the response, but i dont think this will be possible as i\
    \ am asked to do it in O(n) time and O(1) space, so i think i am stuck with the\
    \ for loop :(\n<|/ c |>\n<| c |>\nI think I misunderstood your question. Can you\
    \ please rephrase?\n<|/ c |>\n<| c |>\ni updated my question and added an example\
    \ of what i am trying to do.\n<|/ c |>\n<| a |>\nOk, i think i figured out a solution,\
    \ maybe not the most elegant but it should work. Let me know if anyone has a better\
    \ solution. \nBasically we keep track of the index and value of the min even value\
    \ of the given array. Then we find the index of that min even value in our given\
    \ array and return the value. If the min even value is not in the array, we return\
    \ an empty array.\n<code>", "  const evenValues = arr.filter(n => n % 2 === 0);\n\
    \  if (evenValues.length === 0) {\n    return [];\n  }\n  const minIndexes = evenValues.reduce((acc,\
    \ curr, i, arr) => {\n    if (i === 0 && curr < arr[0]) {\n      return [curr,\
    \ 0];\n    }\n    if (curr < arr[i - 1]) {\n      return [curr, i - 1];\n    }\n\
    \    return acc;\n  }, []);\n  const [minValue, index] = minIndexes;\n  return\
    \ [minValue, index];\n}\n", "  let len = arr.length;\n  let value = 0;\n  let\
    \ index = 0;\n  let result = [];\n  while (len) {\n    if (arr[len - 1] & 1) {\n\
    \      result[len - 1] = value;\n      len--;\n    } else {\n      if (arr[len\
    \ - 1] < value) {\n        index++;\n      }\n      if (arr[len - 1] === value)\
    \ {\n        value = arr[len - 1];\n      }\n      result[len - 1] = value;\n\
    \      len--;\n    }\n  }\n  if (len) {\n    result[len - 1] = value;\n  }\n \
    \ return result;\n}\n", "  let smallest;\n  let index;\n  if (arr.length === 0)\
    \ {\n    return [];\n  }\n  for (let i = 0; i < arr.length; i++) {\n    let current\
    \ = arr[i];\n    let next = Math.ceil(current);\n    if (smallest === undefined\
    \ || next < smallest) {\n      smallest = next;\n      index = i;\n    }\n  }\n\
    \  return [arr[smallest], index];\n}\n", "  const minValue = arr[0];\n  const\
    \ minIndex = 0;\n  const result = new Array(arr.length);\n  for (let i = 1; i\
    \ < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n\
    \      minIndex = i;\n    }\n  }\n  result[0] = minValue;\n  result[1] = minIndex;\n\
    \  return result;\n}\n", "    let lowestEvenValue: number[] = [];\n    let smallestIndex:\
    \ number = 0;\n    for (let i: number = 0; i < arr.length; i++) {\n        let\
    \ num = arr[i];\n        let even: number[] = [];\n        for (let j: number\
    \ = 0; j < num; j++) {\n            if (j % 2 === 0) {\n                even.push(j);\n\
    \            }\n        }\n        let evenIndex = even[0];\n        if (evenIndex\
    \ === 0) {\n            lowestEvenValue.push(num);\n            smallestIndex\
    \ = i;\n        } else if (evenIndex < lowestEvenValue[0]) {\n            lowestEvenValue.splice(lowestEvenValue.length\
    \ - 1, 0, num);\n            smallestIndex = i;\n        } else if (evenIndex\
    \ > lowestEvenValue[0]) {\n            lowestEvenValue.splice(lowestEvenValue.length\
    \ - 1, 0, num);\n            lowestEvenValue.push(num);\n            smallestIndex\
    \ = i;\n        }\n    }\n    if (lowestEvenValue.length === 0) {\n        lowestEvenValue\
    \ = [];\n        smallestIndex = 0;\n    }\n    return lowestEvenValue;\n}\n",
  "  // Your code here\n}\n", "  arr.sort((a, b) => a - b);\n  let i = 0;\n  while\
    \ (i < arr.length) {\n    if (arr[i] % 2 === 0) {\n      return [arr[i], i];\n\
    \    }\n    i++;\n  }\n  return [];\n}", "  const sorted = arr.slice().sort((a,\
    \ b) => a - b)\n  return sorted.findIndex((el, i) => el % 2 === 0 && el < sorted[0]\
    \ ? el : -1)\n}\n", "  let minIndex = 0;\n  let minValue = arr[0];\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    if (arr[i] === minValue) {\n      minIndex\
    \ = i;\n      minValue = arr[i];\n    } else if (arr[i] === minValue + 1) {\n\
    \      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minValue,\
    \ minIndex];\n}\n", "    const sortedArr = arr.sort((a, b) => a - b);\n    let\
    \ min = sortedArr[0];\n    let minIndex = 0;\n    for (let i = 1; i < sortedArr.length;\
    \ i++) {\n        if (sortedArr[i] === min) {\n            minIndex++;\n     \
    \   } else if (sortedArr[i] === min + 1 && minIndex > 0) {\n            minIndex--;\n\
    \        }\n    }\n    const newArr = [min, minIndex];\n    return newArr;\n}\n",
  "    let index = 0;\n    let minEvenValue = arr[0];\n    arr.forEach((curr, i) =>\
    \ {\n        if (curr % 2 === 0) return;\n        if (curr <= minEvenValue) {\n\
    \            minEvenValue = curr;\n            index = i;\n        }\n    });\n\
    \    return [index];\n}", "    return arr.sort((a, b) => a - b)[0];\n}\n", " \
    \   const smallest = arr[0];\n    const indexOfSmallest = arr.indexOf(smallest);\n\
    \    if (indexOfSmallest === -1) {\n        return [];\n    }\n\n    for (let\
    \ i = 0; i < arr.length; i++) {\n        if (arr[i] % 2 === 0) {\n           \
    \ return [smallest, i];\n        }\n        if (arr[i] < smallest) {\n       \
    \     smallest = arr[i];\n        }\n    }\n    return [smallest, indexOfSmallest];\n\
    }\n", "  // Your code here\n}\n", "  const evenArr = arr.filter((_, i) => i %\
    \ 2 === 0);\n  const even = Math.min(...evenArr);\n  return evenArr.filter((_,\
    \ i) => evenArr[i] === even)\n    .sort((a, b) => a - b);\n}\n", "  if (arr.length\
    \ === 0) {\n    return [];\n  }\n  let result = [];\n  let minValue = arr[0];\n\
    \  let minIndex = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i]\
    \ < minValue) {\n      minIndex = i;\n      minValue = arr[i];\n    }\n  }\n \
    \ result.push(minValue, minIndex);\n  return result;\n}\n", "  const nums: number[]\
    \ = [];\n  const evenArr: number[] = [];\n\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    if (arr[i] % 2 === 0) {\n      evenArr.push(arr[i]);\n    } else\
    \ {\n      nums.push(arr[i]);\n    }\n  }\n\n  if (evenArr.length === 0) {\n \
    \   return [];\n  }\n  return evenArr.sort((a, b) => a - b).slice(0, 1);\n}\n",
  "  const map: number[] = arr.reduce((acc, node) => {\n    acc[node] = (acc[node]\
    \ || 0) + 1;\n    return acc;\n  }, {});\n  const result: number[] = [];\n  Object.entries(map).forEach(([key,\
    \ value]: [number, number]) => {\n    if (value === 0) {\n      const key = Object.keys(map).find((key)\
    \ => map[key] === value);\n      result.push(parseInt(key));\n    } else {\n \
    \     const key = Object.keys(map).find((key) => map[key] === value && parseInt(key)\
    \ < value);\n      result.push(parseInt(key));\n    }\n  });\n  return result;\n\
    }\n", "  if (arr.length === 0 || arr.length === 1) {\n    return [];\n  }\n  let\
    \ minValue = arr[0];\n  let minIndex = -1;\n  let minIndexVal = 0;\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      if (i !==\
    \ minIndex) {\n        minIndex = i;\n        minIndexVal = arr[i];\n      }\n\
    \      minValue = arr[i];\n    } else if (arr[i] === minValue && i !== minIndex)\
    \ {\n      minIndex = i;\n      minIndexVal = arr[i];\n    }\n  }\n  if (minIndexVal\
    \ === 0 && minIndex === arr.length - 1) {\n    return [];\n  }\n  return [minIndexVal,\
    \ minIndex];\n}\n", "    if (arr.length === 0 || arr.length === 1 || !Number.isInteger(arr[0]))\
    \ {\n        return [];\n    }\n\n    let [smallestEvenValue, smallestIndex] =\
    \ findSmallest(arr);\n    if (smallestEvenValue === Number.POSITIVE_INFINITY)\
    \ {\n        return [];\n    }\n\n    let newArray = [smallestEvenValue, smallestIndex];\n\
    \n    for (let index = 1; index < arr.length; ++index) {\n        if (arr[index]\
    \ % 2 === 0) {\n            newArray = [smallestEvenValue, smallestIndex];\n \
    \           break;\n        }\n\n        if (index === arr.length - 1) {\n   \
    \         newArray = [smallestEvenValue, smallestIndex];\n            break;\n\
    \        }\n\n        if (arr[index] < smallestEvenValue) {\n            smallestEvenValue\
    \ = arr[index];\n            smallestIndex = index;\n        }\n\n        if (arr[index]\
    \ > smallestEvenValue) {\n            newArray = [smallestEvenValue, smallestIndex];\n\
    \            break;\n        }\n    }\n\n    return newArray;\n}\n", "  return\
    \ new Solution().pluck(arr);\n}\n", "  const min_index = arr.findIndex(\n    (node)\
    \ =>\n      node % 2 == 0 && node < arr.reduce((prev, curr) => prev < curr, arr[0])\n\
    \  );\n  const smallest_value = arr[min_index];\n  const min_even_value = arr[min_index];\n\
    \  return arr.findIndex(\n    (node) =>\n      node % 2 == 0 &&\n      node <\
    \ arr.reduce((prev, curr) => prev < curr, arr[0]) &&\n      node != smallest_value\
    \ &&\n      node != min_even_value\n  );\n}\n\nconst a = [];\na.length = 50;\n\
    a[10] = -2;\na[20] = -8;\na[30] = -12;\nconsole.log(a);\nconsole.log(a.length);\n\
    console.log(a.map(item => item));\nconsole.log(a.reduce((a, b) => a + b, 0));\n\
    console.log(a.filter(item => item != 0));\nconsole.log(a.filter(item => item ==\
    \ 0));\nconsole.log(a.map(item => item + 2));\nconsole.log(a.filter(item => item\
    \ > 1));\nconsole.log(a.map(item => item < 0));\nconsole.log(a.map(item => item\
    \ + item.toString().length));\nconsole.log(\n  a.map(\n    (item) =>\n      item\
    \ +\n      item.toString().length +\n      item.toString().length\n  )\n);\nconsole.log(a.map(item\
    \ => item + item.toString().length * 2));\nconsole.log(\n  a.map(\n    (item)\
    \ =>\n      item +\n      item.toString().length +\n      item.toString().length\
    \ * 2\n  )\n);\nconsole.log(\n  a.map(\n    (item) =>\n      item +\n      item.toString().length\
    \ +\n      item.toString().length * 2 +\n      item.toString().length * 3\n  )\n\
    );\nconsole.log(a.map(item => item + item.toString().length * 1.5));\nconsole.log(\n\
    \  a.map(\n    (item) =>\n      item +\n      item.toString().length +\n     \
    \ item.toString().length * 2 +\n      item.toString().length * 3 +\n      item.toString().length\
    \ * 1.5\n  )\n);\nconsole.log(\n  a.map(\n    (item) =>\n      item +\n      item.toString().length\
    \ +\n      item.toString().length * 2 +\n      item.toString().length * 3 +\n\
    \      item.toString().length * 1.5 +\n      item.toString().length * 2\n  )\n\
    );\nconsole.log(\n  a.map(\n    (item) =>\n      item +\n      item.toString().length\
    \ +\n      item.toString().length * 2 +\n      item.toString().length * 3 +\n",
  "\tconst smallest = arr.sort((a, b) => a - b).find((el, i) => el & 1)\n\treturn\
    \ smallest ? [smallest, arr.indexOf(smallest)] : []\n}\n", "  if (arr.length ===\
    \ 0) {\n    return [];\n  }\n\n  let minIndex = Math.min.apply(Math, arr);\n \
    \ let minValue = arr[minIndex];\n  let result = [];\n\n  for (let i = 0; i < arr.length;\
    \ i += 1) {\n    if (arr[i] === minValue) {\n      result.push([arr[i], minIndex]);\n\
    \    }\n  }\n\n  return result;\n}\n", "  const result = new Array(arr.length)\n\
    \  let index = 0\n  for (let i = 0; i < arr.length; i++) {\n    const value =\
    \ arr[i]\n    if (value % 2 === 0) {\n      result[index] = value\n      index++\n\
    \    }\n  }\n  return result\n}\n", "\tconst sortedArr = arr.sort((a, b) => a\
    \ - b);\n\tlet result: number[] = [];\n\tlet smallestIndex = 0;\n\tlet currentIndex\
    \ = -1;\n\tlet currentValue = 0;\n\n\twhile (sortedArr.length && currentIndex\
    \ < smallestIndex) {\n\t\tcurrentIndex = arr.indexOf(sortedArr[currentIndex]);\n\
    \t\tif (currentIndex < smallestIndex && currentValue % 2 == 0) {\n\t\t\tcurrentIndex\
    \ = currentIndex + 1;\n\t\t}\n\t\tcurrentValue = sortedArr[currentIndex];\n\t\t\
    result.push(currentValue);\n\t\tsmallestIndex = currentIndex;\n\t}\n\n\treturn\
    \ result;\n}\n", "  const indexToValue: { [index: number]: number } = {};\n  let\
    \ smallestIndex: number = null;\n  let smallestEvenValue: number = null;\n  for\
    \ (let i = 0; i < arr.length; i++) {\n    if (!indexToValue[i]) indexToValue[i]\
    \ = arr[i];\n    if (arr[i] < smallestEvenValue) {\n      smallestEvenValue =\
    \ arr[i];\n      smallestIndex = i;\n    }\n  }\n  if (!smallestIndex) return\
    \ [];\n  return [smallestEvenValue, smallestIndex];\n}\n", "  const sortedArr\
    \ = arr\n    .map((val, index) => ({ value, index }))\n    .sort((a, b) => {\n\
    \      return a.value - b.value;\n    });\n  return sortedArr\n    .slice(0, Math.min(sortedArr.length,\
    \ 2))\n    .map(a => a.value);\n}\n", "  let results: number[] = [];\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    let min = Number.MAX_VALUE;\n    let index\
    \ = -1;\n    for (let j = 0; j < arr.length; j++) {\n      if (arr[j] < min &&\
    \ arr[j] % 2 === 0) {\n        min = arr[j];\n        index = j;\n      }\n  \
    \  }\n    if (min === Number.MAX_VALUE) {\n      results.push([]);\n    } else\
    \ {\n      results.push(min === 0 ? (arr[index] || []) : arr[index]);\n    }\n\
    \  }\n  return results;\n}\n", "  if (arr.length === 0) return [];\n\n  let minValue:\
    \ number = Infinity;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++)\
    \ {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex =\
    \ i;\n    }\n  }\n\n  if (minValue === Infinity) return [];\n\n  return [minValue,\
    \ minIndex];\n}\n\nconsole.log(pluck([4, 2, 3]));\nconsole.log(pluck([1, 2, 3]));\n\
    console.log(pluck([]));\nconsole.log(pluck([5, 0, 3, 0, 4, 2]));\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nHi Vijay, welcome to Stack Overflow! While this code\
    \ may answer the question, it would be better to include some _context_, explaining\
    \ _how_ it works and _when_ to use it. Code-only answers are not useful in the\
    \ long run. Also note that this site has [a guide for writing good answers](https://stackoverflow.com/help/how-to-answer).\n\
    <|/ c |>\n<| c |>\nThanks for your suggestion but i don't know the idea of giving\
    \ downvote for my answer .\n<|/ c |>\n<| c |>\nOh, I understand. Did it come from\
    \ me? I thought maybe you were a moderator or something. Just my curiosity :-)\n\
    <|/ c |>\n<| c |>\nOh  I thought it was you. I didn't know you were the moderator.\
    \ Now I know I am not the moderator. :D\n<|/ c |>\n<| a tags=javascript,algorithm,arrays,sorting\
    \ |>\n<code>", "    // initialize result array\n    let result = [];\n    // for\
    \ each element in given array\n    for (let element of arr) {\n        // if it\
    \ is even and smaller than current smallest value\n        if (element % 2 ===\
    \ 0 && element < result[result.length - 1]) {\n            // push element in\
    \ result array\n            result.push(element);\n        }\n    }\n    return\
    \ result;\n}\n", "  const evenIndex = arr\n    .map((val) => evenIndex(val))\n\
    \    .filter((val) => val !== -1)[0];\n  if (evenIndex === -1) return [];\n  const\
    \ value = arr[evenIndex];\n  const index = evenIndex === arr.length - 1 ? arr.length\
    \ - 1 : evenIndex + 1;\n  return [value, index];\n}\n", "\tconst result = [];\n\
    \tlet min;\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (!min || arr[i] >\
    \ min) {\n\t\t\tmin = arr[i];\n\t\t}\n\t}\n\tresult.push(min);\n\tlet index =\
    \ -1;\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i] === min) {\n\t\
    \t\tindex = i;\n\t\t}\n\t}\n\tif (index === -1) {\n\t\treturn result;\n\t} else\
    \ {\n\t\treturn [index + 1, min];\n\t}\n}\n", "    let minIndex = -1;\n    let\
    \ minEv = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < arr.length; i++) {\n\
    \        if (arr[i] % 2 === 0) {\n            if (minEv !== Number.MAX_SAFE_INTEGER\
    \ && arr[i] < minEv) {\n                minEv = arr[i];\n                minIndex\
    \ = i;\n            }\n        }\n    }\n    if (minIndex === -1) {\n        return\
    \ [];\n    }\n    return [minEv, minIndex];\n}\n", "  if (arr.length === 0 ||\
    \ arr.length < 1) {\n    return [];\n  }\n  const evens = arr.filter(node => node.value\
    \ % 2 === 0);\n  let smallest = -1;\n  const smallest_index = arr.map(node =>\
    \ node.value).indexOf(arr[smallest].value);\n  for (let i = 0; i < evens.length;\
    \ i++) {\n    const indexInArr = arr.map(node => node.value).indexOf(evens[i].value);\n\
    \    if (indexInArr < smallest_index) {\n      smallest = i;\n      smallest_index\
    \ = indexInArr;\n    }\n  }\n  if (smallest === -1) {\n    return [];\n  }\n \
    \ return [arr[smallest], arr[smallest_index]];\n}\n", "  if (arr.length === 0)\
    \ {\n    return [];\n  }\n  const minIndex = arr.reduce((a, c, i) => {\n    return\
    \ c < a ? i : a;\n  }, -1);\n  const minValue = arr[minIndex];\n  const evenArr\
    \ = [...arr];\n  const evenMinValue = evenArr[minIndex];\n  let i = minIndex -\
    \ 1;\n  while (i >= 0) {\n    if (evenMinValue % 2 === 0) {\n      return [evenMinValue,\
    \ i];\n    }\n    i -= 1;\n  }\n  return [];\n}\n", "  if (!arr.length || arr[0]\
    \ === 0) {\n    return [];\n  }\n\n  let minIndex = findSmallestIndex(arr);\n\n\
    \  if (minIndex === -1 || minIndex === arr.length - 1) {\n    return [];\n  }\n\
    \n  let minValue = arr[minIndex];\n  let minIndexs = [];\n  for (let i = 0; i\
    \ < arr.length; i++) {\n    if (minIndexs[i] !== minIndex && arr[i] === minValue)\
    \ {\n      minIndexs.push(minIndex);\n    }\n  }\n\n  return [minValue, minIndex];\n\
    }\n", "  arr.sort((a: number, b: number) => {\n    const valueA = getEvenValue(a);\n\
    \    const valueB = getEvenValue(b);\n    if (valueA === valueB) {\n      return\
    \ a - b;\n    }\n    return valueA - valueB;\n  });\n  return arr.slice(0, 1);\n\
    }\n", "  const min = Math.min.apply(Math, arr);\n  const index = arr.indexOf(min);\n\
    \  if (index >= 0) return [min, index];\n  else return [];\n}\n", "    return\
    \ arr\n        .map((v, i) => [v < 0 ? -Math.ceil(v) : Math.ceil(v)] as [number,\
    \ number])\n        .sort((a, b) => {\n            const a1 = a[0];\n        \
    \    const a2 = a[1];\n            const b1 = b[0];\n            const b2 = b[1];\n\
    \            if (a1 < b1) {\n                return -1;\n            }\n     \
    \       if (a2 < b2) {\n                return 1;\n            }\n           \
    \ if (a1 === b1) {\n                return a2 < b2 ? -1 : 0;\n            }\n\
    \            return a1 === b2 ? 1 : -1;\n        })\n        .map((v) => v[0]);\n\
    }\n", "    let minEven = -1;\n    let minIndex = 0;\n\n    for (let node of arr)\
    \ {\n        if (node.value % 2 === 0) {\n            if (minEven < 0 || minEven\
    \ > node.value) {\n                minEven = node.value;\n                minIndex\
    \ = arr.indexOf(node);\n            }\n        }\n    }\n\n    return [minEven,\
    \ minIndex];\n}\n", "  if (arr.length <= 0) return [];\n  let nodes = [...arr];\n\
    \  let largestEvenIndex = 0;\n  let largestEvenValue = nodes[0];\n  let smallestIndex\
    \ = 0;\n  let index = nodes.length - 1;\n  while (index >= 0) {\n    if (nodes[index]\
    \ % 2 == 0) {\n      if (nodes[index] > largestEvenValue) {\n        largestEvenValue\
    \ = nodes[index];\n        largestEvenIndex = index;\n      }\n      if (smallestIndex\
    \ < index) {\n        smallestIndex = index;\n      }\n    }\n    index -= 1;\n\
    \  }\n  return [largestEvenValue, largestEvenIndex];\n}\n", "  if (arr.length\
    \ <= 0) return [];\n  const [smallestEvenValue, index] = Math.min(...arr);\n \
    \ const arrCopy = [...arr];\n  arrCopy.splice(index, 1);\n  return [smallestEvenValue,\
    \ ...arrCopy];\n}\n", "  let minIndex = 0;\n  let minValue = arr[0];\n  let oddArr\
    \ = [];\n  let evenArr = [];\n\n  for (let i = 0; i < arr.length; i++) {\n   \
    \ if (arr[i] % 2 === 0) {\n      evenArr.push(arr[i]);\n    } else {\n      oddArr.push(arr[i]);\n\
    \    }\n    if (minValue > arr[i]) {\n      minValue = arr[i];\n      minIndex\
    \ = i;\n    }\n  }\n\n  evenArr.sort((a, b) => a - b);\n  oddArr.sort((a, b) =>\
    \ a - b);\n\n  let index = evenArr.indexOf(minValue);\n  if (index === -1) {\n\
    \    index = oddArr.indexOf(minValue);\n  }\n\n  let result = [minValue, index];\n\
    \  if (index === minIndex) {\n    result = evenArr;\n  }\n\n  return result;\n\
    }\n", "  if (arr.length === 0) return [];\n  if (arr.length === 1) return arr[0];\n\
    \  const evenValues = arr.filter((_, index) => index % 2 === 0);\n  if (evenValues.length\
    \ === 0) return [];\n  return evenValues.reduce((acc, curr, index) => {\n    const\
    \ value = curr + index;\n    return value >= acc.min ? { min, index } : { min:\
    \ value, index: acc.index };\n  }, { min: arr[0], index: 0 }).index;\n}\n", " \
    \ if (arr.length === 0) {\n    return [];\n  }\n\n  let minIndex = 0;\n\n  for\
    \ (let i = 1; i < arr.length; i++) {\n    if (arr[i] < arr[minIndex]) {\n    \
    \  minIndex = i;\n    }\n  }\n\n  const minValue = arr[minIndex];\n  const evenValue\
    \ = arr[minIndex - 1];\n\n  return [minValue, minIndex];\n}\n", "  const even\
    \ = arr.reduce((a, b) => {\n    return a ^ b;\n  }, 0);\n  const indexMin = arr.findIndex(a\
    \ => a === even && a);\n  const result = arr.map(a => a === even ? a[indexMin]\
    \ : a);\n  if (result.length === 0) {\n    return [];\n  }\n  return result;\n\
    }\n", "  const sortedArray = arr.sort((a, b) => a % 2 == b % 2);\n  const pluckedArray\
    \ = [];\n  let minValue = sortedArray[0] % 2;\n  let minIndex = 0;\n\n  for (let\
    \ i = 0; i < sortedArray.length; i++) {\n    const num = sortedArray[i];\n   \
    \ if (num % 2 == minValue) {\n      minValue = num;\n      minIndex = i;\n   \
    \ }\n  }\n\n  pluckedArray.push(minValue, minIndex);\n\n  if (sortedArray.length\
    \ > 0) {\n    pluckedArray.push(\n      pluckedArray.map(\n        function (value,\
    \ index) {\n          const newIndex = sortedArray.indexOf(value);\n         \
    \ return [value, newIndex];\n        }\n      )\n    );\n  }\n\n  return pluckedArray;\n\
    }\n", "    if (arr === null || arr.length === 0) return [];\n    const even =\
    \ [];\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] % 2 ===\
    \ 0) {\n            even.push(arr[i]);\n        }\n    }\n    if (even.length\
    \ === 0) return [];\n    even.sort((a, b) => a - b);\n    return even.slice(0,\
    \ 1);\n}\n", "    return arr.sort((a, b) => a - b).filter((value, index) => value\
    \ % 2 === 0);\n}", "  let result: number[] = []\n  for (let i = 1; i < arr.length;\
    \ i++) {\n    let v = arr[i]\n    let m = i\n    while (m > 0 && arr[m - 2] ===\
    \ v) {\n      m -= 2\n    }\n    result.push(v)\n    result.push(m - 1)\n  }\n\
    \  return result\n}\n", "  const maxValue = Math.max(...arr)\n  const index =\
    \ arr.findIndex(e => e === maxValue)\n  return index === -1 ? [] : [arr[index],\
    \ index]\n}", "  // Your code here\n  arr.sort((a, b) => a - b);\n  let low =\
    \ 0, high = arr.length - 1;\n  while (low < high) {\n    const mid = Math.floor((low\
    \ + high) / 2);\n    if (arr[mid] % 2 === 0) {\n      return [arr[mid], mid];\n\
    \    } else {\n      if (arr[mid] > arr[mid + 1]) {\n        low = mid + 1;\n\
    \      } else {\n        high = mid - 1;\n      }\n    }\n  }\n  return [];\n\
    }\n", "  let minVal = -Infinity;\n  let minIndex;\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    if (arr[i] >= minVal) {\n      minVal = arr[i];\n      minIndex\
    \ = i;\n    }\n  }\n  return minIndex === arr.length ? [] : [minVal, minIndex];\n\
    }\n", "  const [smallest, smallestIndex, even] = arr.reduce(([smallestValue, smallestIndex,\
    \ even], v) => {\n    if (even !== true) {\n      return [Math.max(smallestValue,\
    \ v), Math.max(smallestIndex, v), true];\n    } else {\n      return [smallestValue,\
    \ smallestIndex];\n    }\n  }, [-Infinity, -Infinity, false]);\n  return [smallest,\
    \ smallestIndex];\n}\n", "  if (!arr.length) {\n    return [];\n  }\n  let result:\
    \ number[] = [];\n  const evens: number[] = arr.reduce((evens, node) => {\n  \
    \  if (node % 2 === 0) {\n      evens.push(node);\n    }\n    return evens;\n\
    \  }, []);\n  if (evens.length) {\n    for (let i = 0, n = arr.length; i < n;\
    \ i++) {\n      const minIndex = i;\n      for (let j = i + 1; j < n; j++) {\n\
    \        if (evens.indexOf(arr[j]) < 0) {\n          minIndex = j;\n        }\n\
    \      }\n      result.push(arr[i]);\n      result.push(minIndex);\n    }\n  }\n\
    \  return result;\n}\n", "    const odd = [];\n    let smalest_value = -1;\n \
    \   for (let i = 0; i < arr.length; i++) {\n        const v = arr[i];\n      \
    \  if (v % 2 === 0) {\n            if (smalest_value < 0 || smalest_value > v)\
    \ {\n                smalest_value = v;\n            }\n        } else {\n   \
    \         odd.push(v);\n        }\n    }\n    if (smalest_value === -1) {\n  \
    \      return [];\n    }\n    odd.sort((a, b) => a - b);\n    const result = [];\n\
    \    for (let j = 0; j < odd.length; j++) {\n        if (odd[j] === smalest_value)\
    \ {\n            result.push([smalest_value, j]);\n        }\n    }\n    return\
    \ result;\n}\n", "    let ans = [];\n    let map = {};\n    let minVal = Number.MAX_SAFE_INTEGER;\n\
    \    let minIdx = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (map[arr[i]]\
    \ === undefined) {\n            map[arr[i]] = 1;\n            ans.push(arr[i]);\n\
    \        } else {\n            map[arr[i]]++;\n        }\n        if (map[arr[i]]\
    \ % 2 === 0) {\n            minVal = Math.min(minVal, arr[i]);\n            minIdx\
    \ = i;\n        }\n    }\n    ans.push(minVal);\n    ans.push(minIdx);\n    return\
    \ ans;\n}", "  let result: number[] = [];\n  let lowestIndex = 0;\n  let minNode:\
    \ any = null;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 ==\
    \ 0) {\n      minNode = arr[i];\n      lowestIndex = i;\n    }\n    if (minNode\
    \ != null && arr[i] % 2 == 0 && (minNode - arr[i]) % 2 == 0) {\n      result.push(minNode);\n\
    \      minNode = null;\n    }\n  }\n  if (result.length === 0) {\n    return [];\n\
    \  }\n  return result;\n}\n", "    if (arr.length === 0) return [];\n    let min\
    \ = arr[0];\n    let index = -1;\n    for (let i = 1; i < arr.length; i++) {\n\
    \        if (arr[i] < min) {\n            min = arr[i];\n            index = i;\n\
    \        }\n    }\n    return [min, index];\n}\n", "  let minEv = arr[0];\n  let\
    \ minIndex = 0;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minEv)\
    \ {\n      minEv = arr[i];\n      minIndex = i;\n    }\n  }\n  return [minEv,\
    \ minIndex];\n}\n", "  if (!arr.length) return [];\n\n  let minIndex = arr.findIndex(node\
    \ => node % 2 === 0);\n  return [arr[minIndex], minIndex];\n}\n", "  const lookup\
    \ = new Map<number, number>();\n\n  for (let node of arr) {\n    if (!lookup.has(node))\
    \ {\n      lookup.set(node, node);\n    } else if (lookup.get(node) % 2 === 0)\
    \ {\n      lookup.set(node, lookup.get(node) + 1);\n    } else {\n      let index\
    \ = lookup.get(node);\n      while (lookup.get(index) && lookup.get(index) % 2\
    \ === 0) {\n        index++;\n      }\n      lookup.set(node, index);\n    }\n\
    \  }\n\n  const result = [];\n  for (let [key, value] of lookup.entries()) {\n\
    \    const index = value % 2 === 0 ?\n      value :\n      Math.min(...Array.from({length:\
    \ value}, (x, i) => i + 1));\n    result.push([value, index]);\n  }\n  return\
    \ result;\n}\n", "    if (arr.length === 0 || arr.length < 1) {\n        return\
    \ [];\n    }\n    const min = arr.map(val => val % 2 === 0);\n    const indexOfMin\
    \ = Math.min(...min);\n    const smallestEvenValue = arr[indexOfMin];\n    const\
    \ smallestIndex = indexOfMin + 1;\n    const result = [smallestEvenValue, smallestIndex];\n\
    \    return result;\n}\n", "  const map = new Map<number, number>();\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    const node = arr[i];\n    if (map.has(node))\
    \ {\n      map.set(node, Math.min(map.get(node), i));\n    } else {\n      map.set(node,\
    \ i);\n    }\n  }\n  const result = [];\n  for (const [key, val] of map) {\n \
    \   if (val % 2 === 0) {\n      result.push(key);\n    }\n  }\n  return result.length\
    \ === 0 ? [] : result;\n}\n", "  const minEven = arr.sort((a, b) => a - b)\n \
    \   .find(node => node % 2 === 0)\n  if (minEven === undefined) return []\n\n\
    \  return arr.sort((a, b) => a - b)\n    .filter((node, i) => node === minEven\
    \ && i % 2 === 0)\n}\n", "  let minEvenIndex: number = 0;\n  let minEvenValue:\
    \ number = Number.MAX_SAFE_INTEGER;\n\n  for (let i = 0, len = arr.length; i <\
    \ len; ++i) {\n    const item = arr[i];\n\n    if (item % 2 === 0) {\n      if\
    \ (item < minEvenValue) {\n        minEvenValue = item;\n        minEvenIndex\
    \ = i;\n      }\n    }\n  }\n\n  return [minEvenValue, minEvenIndex];\n}\n", " \
    \ let min_val = 0;\n  const index_of_smallest_val = 0;\n  for (let i = 0; i <\
    \ arr.length; i++) {\n    if (arr[i] === min_val) {\n      index_of_smallest_val\
    \ = i;\n    }\n  }\n  let smallest_value = arr[index_of_smallest_val];\n  let\
    \ min_value_and_index;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i]\
    \ === smallest_value) {\n      if (min_value_and_index === undefined) {\n    \
    \    min_value_and_index = [arr[i], i];\n      } else {\n        const [val1,\
    \ index1] = min_value_and_index;\n        const [val2, index2] = min_value_and_index;\n\
    \        if (val1 < arr[i]) {\n          min_value_and_index = [arr[i], i];\n\
    \        } else if (val1 > arr[i]) {\n          min_value_and_index = [val2, index2];\n\
    \        } else {\n          min_value_and_index = [val1, index1];\n        }\n\
    \      }\n    }\n  }\n  if (min_value_and_index === undefined) {\n    return [];\n\
    \  } else {\n    return [min_value_and_index[0], min_value_and_index[1]];\n  }\n\
    }\n", "  if (!arr.length) return [];\n  const [min, minIndex] = Math.min(...arr),\
    \ values = [...arr];\n  return values.reduce((res, val, i) => {\n    if (val ===\
    \ min) {\n      res.push(val, i);\n    }\n    return res;\n  }, []);\n}\n", " \
    \ let even = [];\n  let small = [];\n  let max = 0;\n  for(let n of arr) {\n \
    \   if(n % 2 === 0) {\n      even.push(n);\n      if(n < max) {\n        small.push(n);\n\
    \      }\n    }\n    max = n;\n  }\n  if(even.length > 0) {\n    small.push(Math.min.apply(null,\
    \ even));\n  }\n  return small.sort((a,b) => a-b).reverse();\n}\n", "  const set\
    \ = new Set<number>();\n\n  for (let i = 0; i < arr.length; i++) {\n    set.add(arr[i]);\n\
    \  }\n\n  let index = 0;\n  let minIndex = 0;\n  let minValue = arr[0];\n\n  for\
    \ (const value of set) {\n    if (value % 2 === 0) {\n      minValue = value;\n\
    \      minIndex = index;\n    }\n\n    index++;\n  }\n\n  return [minValue, minIndex];\n\
    }\n", "  const len = arr.length;\n  const min = Math.min(...arr);\n  const index\
    \ = arr.indexOf(min);\n  if (index === -1 || min === 0) {\n    return [];\n  }\n\
    \  const ans = [min, index];\n  while (--len > 0) {\n    const temp = arr[len\
    \ - 1];\n    if (temp % 2 === 0) {\n      return ans;\n    }\n    arr[len - 1]\
    \ = temp / 2;\n  }\n  return ans;\n}\n", "  const nums: number[] = [];\n  let\
    \ minIndex = 0;\n  let minVal = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i\
    \ < arr.length; i++) {\n    nums.push(arr[i]);\n    if (nums[i] % 2 === 0) {\n\
    \      minIndex = i;\n      minVal = nums[i];\n    }\n  }\n  if (nums.length ===\
    \ 0 || minVal === Number.MAX_SAFE_INTEGER) {\n    return [];\n  }\n  return [minVal,\
    \ minIndex];\n}\n", "  const evenArr = [];\n  const evenObj = arr.sort((a, b)\
    \ => a - b);\n  for (let i = 0; i < evenObj.length; i += 1) {\n    if (evenObj[i]\
    \ % 2 === 0) {\n      evenArr.push(evenObj[i]);\n    }\n  }\n  const smallArr\
    \ = evenArr.sort((a, b) => a - b);\n  const smallObj = smallArr.sort((a, b) =>\
    \ a - b);\n  if (smallArr.length === 0 || smallObj.length === 0) {\n    return\
    \ [];\n  }\n  const smallVal = smallArr[0];\n  const smallIdx = smallObj.findIndex(\n\
    \    (node) => node === smallVal\n  );\n  if (smallIdx === -1) {\n    return [];\n\
    \  }\n  return [smallVal, smallIdx];\n}\n", "  const even = [];\n  const odd =\
    \ [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) even.push(arr[i]);\n\
    \    else odd.push(arr[i]);\n  }\n  if (even.length > 0) return even;\n  else\
    \ return odd;\n}\n", "    return arr\n        .map((_, i, arr) => i === arr.findIndex(n\
    \ => n % 2 === 0))\n        .sort((a, b) => a === b ? 0 : a - b)\n        .reverse()\n\
    \        .map((_, [first, index]) => first)\n        .reverse()\n}\n", "  return\
    \ arr.reduce((acc, val, index) => {\n    if (val) {\n      const nextVal = arr[index\
    \ + 1] || Infinity;\n      const evenValue = nextVal % 2 === 0;\n      const newIndex\
    \ = evenValue ? index : index + 1;\n      const newVal = evenValue ? nextVal :\
    \ val + 1;\n      if (newVal < acc[0]) {\n        return [newVal, newIndex];\n\
    \      }\n      return acc;\n    }\n    return acc;\n  }, [Infinity, Infinity]);\n\
    }\n", "  let minIndex = 0;\n  let minVal = Number.MAX_SAFE_INTEGER;\n  let smalestValue\
    \ = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i]\
    \ < minVal) {\n      minVal = arr[i];\n      minIndex = i;\n    } else if (arr[i]\
    \ === minVal) {\n      minIndex = i;\n    }\n  }\n  if (minVal === Number.MAX_SAFE_INTEGER\
    \ && arr.length === 0) {\n    return [];\n  }\n  if (minVal === Number.MAX_SAFE_INTEGER)\
    \ {\n    return [minVal];\n  }\n  const pluckedValues = [arr[minIndex]];\n  for\
    \ (let i = 0; i < arr.length - 1; i++) {\n    if (arr[i] === minVal) {\n     \
    \ pluckedValues.push(arr[i + 1]);\n    }\n  }\n  return pluckedValues;\n}\n",
  "    return arr.map((x, i) => i % 2 ? x : arr.filter(y => y % 2 == 0).shift());\n\
    }\n", "  let min = arr[0];\n  let index = -1;\n  for (let i = 1; i < arr.length;\
    \ i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      index = i;\n   \
    \ }\n  }\n  if (index > 0) {\n    return [min, index];\n  }\n  return [];\n}\n",
  "  const n = arr.length;\n  let min;\n  let index;\n  const minVal = [];\n  for\
    \ (let i = 1; i < n; i++) {\n    if (arr[i] === 0) {\n      for (let j = i; j\
    \ < n; j++) {\n        if (arr[j] % 2 === 0) {\n          min = j;\n         \
    \ minVal = [arr[j], i];\n          break;\n        }\n      }\n    } else if (arr[i]\
    \ < arr[min]) {\n      for (let j = i; j < n; j++) {\n        if (arr[j] % 2 ===\
    \ 0) {\n          min = j;\n          minVal = [arr[j], i];\n          break;\n\
    \        }\n      }\n    }\n  }\n  if (min === n) {\n    return minVal;\n  }\n\
    \  const temp = minVal.sort();\n  const result = temp[1];\n  minVal = temp[0];\n\
    \  minVal[0] = temp[0];\n  minVal[1] = temp[1];\n  for (let i = 0; i < minVal.length;\
    \ i++) {\n    arr[minVal[i]] = arr[minVal[i]];\n    arr[minVal[i]] = minVal[i];\n\
    \  }\n  return result;\n}\n", "  const result = [];\n  let min;\n  let minIndex;\n\
    \  for (let i = 0, len = arr.length; i < len; i++) {\n    const curr = arr[i];\n\
    \    if (curr % 2 === 0) {\n      if (!min) {\n        min = curr; minIndex =\
    \ i;\n      } else if (min > curr) {\n        min = curr; minIndex = i;\n    \
    \  }\n    }\n  }\n  result.push(min, minIndex);\n  return result;\n}\n", "  if\
    \ (!arr.length) return [];\n  \n  let lowest_even_val = Number.MAX_VALUE;\n  let\
    \ lowest_index = 0;\n  \n  for (let i = 0; i < arr.length; i++) {\n    const val\
    \ = arr[i];\n    if (val % 2 === 0) {\n      const index = arr.indexOf(val);\n\
    \      if (index >= 0) {\n        if (index < lowest_index || (lowest_index ===\
    \ 0 && val < lowest_even_val)) {\n          lowest_even_val = val;\n         \
    \ lowest_index = index;\n        }\n      }\n    }\n  }\n  \n  return [lowest_even_val,\
    \ lowest_index];\n}\n\nconst result: number[] = pluck([4, 2, 3]);\nconsole.assert(result\
    \ === [2, 1]);\nresult = [1, 2, 3];\nconsole.assert(pluck(result) === [2, 1]);\n\
    result = [1, 0, 2, 4, 6, 8, 9];\nconsole.assert(pluck(result) === [0, 5]);\nresult\
    \ = [];\nconsole.assert(pluck(result) === []);\nresult = [0];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [0,\
    \ 1];\nconsole.assert(pluck(result) === [0, 1]);\nresult = [0, 2];\nconsole.assert(pluck(result)\
    \ === [0, 1]);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult =\
    \ [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\n\
    console.assert(pluck(result) === []);\nresult = [1];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\n\
    console.assert(pluck(result) === []);\nresult = [1];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\n\
    console.assert(pluck(result) === []);\nresult = [1];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\n\
    console.assert(pluck(result) === []);\nresult = [1];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\n\
    console.assert(pluck(result) === []);\nresult = [1];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\n\
    console.assert(pluck(result) === []);\nresult = [1];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\n\
    console.assert(pluck(result) === []);\nresult = [1];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\n\
    console.assert(pluck(result) === []);\nresult = [1];\nconsole.assert(pluck(result)\
    \ === []);\nresult = [1];\nconsole.assert(pluck(result) === []);\nresult = [1];\n\
    console.assert(pluck(result) === []);", "  let low = 0;\n  let high = arr.length\
    \ - 1;\n  let minEven = Infinity;\n  let minIndex = -1;\n  while (low <= high)\
    \ {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] % 2 === 0)\
    \ {\n      if (arr[mid] < minEven) {\n        minEven = arr[mid];\n        minIndex\
    \ = mid;\n      }\n    } else {\n      if (arr[mid] > minEven) {\n        minEven\
    \ = arr[mid];\n        minIndex = mid;\n      }\n    }\n    if (minIndex === arr[low])\
    \ {\n      low++;\n    } else {\n      high--;\n    }\n  }\n  if (minIndex ===\
    \ arr[low]) {\n    return [minEven, minIndex];\n  } else {\n    return [];\n \
    \ }\n}\n", "  if (arr.length === 0) {\n    return [];\n  }\n  const even = arr.filter(v\
    \ => (v % 2 === 0));\n  if (even.length === 0) {\n    return [];\n  }\n  const\
    \ smallestEvenIndex = even.indexOf(Math.min(...even));\n  return [even[smallestEvenIndex],\
    \ smallestEvenIndex];\n}\n", "  if (arr.length === 0) {\n    return [];\n  }\n\
    \n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n\n  const result: number[]\
    \ = [];\n\n  let min = Math.min(...arr);\n\n  let i = 0;\n  for (let e of arr)\
    \ {\n    if (e === min) {\n      result.push(e);\n    }\n\n    if (e === min)\
    \ {\n      i++;\n    }\n  }\n\n  return result;\n}\n\nconst array = [1, 2, 3,\
    \ 2];\nconst result = pluck(array);\n\nconsole.log(result);", "  if (arr.length\
    \ === 0) {\n    return [];\n  }\n  const smallIndex = arr.findIndex(node => node\
    \ % 2 === 0);\n  if (smallIndex === -1) {\n    return [];\n  }\n  const smallestEven\
    \ = arr[smallIndex];\n  const evenNodes = arr.filter(node => node % 2 === 0);\n\
    \  if (smallestEven === evenNodes[0]) {\n    return [smallestEven, smallIndex];\n\
    \  }\n  const largestEven = evenNodes.reduce((prev, curr) => {\n    if (prev >\
    \ curr) {\n      return curr;\n    }\n    return prev;\n  }, smallestEven);\n\
    \  return [smallestEven, evenNodes.indexOf(largestEven)];\n}\n", "  let evens:\
    \ number[] = [];\n  let smalest: number[] = [];\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    if (arr[i] % 2 === 0) {\n      evens.push(arr[i]);\n      if (smalest.length\
    \ > 0 && evens[evens.length - 1] < smalest[smalest.length - 1]) {\n        smalest.push(evens[evens.length\
    \ - 1]);\n      } else if (smalest.length > 0 && evens[evens.length - 1] === smalest[smalest.length\
    \ - 1]) {\n        smalest.push(i);\n      }\n    } else if (smalest.length >\
    \ 0 && evens[evens.length - 1] < smalest[smalest.length - 1]) {\n      smalest.push(evens[evens.length\
    \ - 1]);\n    } else if (smalest.length > 0 && evens[evens.length - 1] === smalest[smalest.length\
    \ - 1]) {\n      smalest.push(i);\n    }\n  }\n  if (smalest.length > 0) return\
    \ smalest;\n  else return evens;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
