name: HumanEval_21_rescale_to_unit
language: ts
prompt: "//Given array of numbers (of at least two elements), apply a linear transform\
  \ to that array,\n// such that the smallest number will become 0 and the largest\
  \ will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\nfunction rescale_to_unit(numbers: number[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = rescale_to_unit;\n  assert.deepEqual(candidate([2.0,\
  \ 49.9]),[0.0, 1.0]);\n  assert.deepEqual(candidate([100.0, 49.9]),[1.0, 0.0]);\n\
  \  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75,\
  \ 1.0]);\n  assert.deepEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0,\
  \ 0.5, 0.75]);\n  assert.deepEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25,\
  \ 0.0, 1.0, 0.5, 0.75]);\n}\n\ntest();"
completions: ["    var scale: number = Math.min(\n        numbers[numbers.length -\
    \ 1] - numbers[0],\n        numbers[0] - numbers[numbers.length - 1],\n    );\n\
    \    var result: number[] = [];\n    for (var i = 0; i < numbers.length; ++i)\
    \ {\n        result.push(numbers[i] + scale * (numbers[i + 1] - numbers[i]));\n\
    \    }\n    return result;\n}\n", "\tlet minimum = numbers[0];\n\tlet maximum\
    \ = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\tminimum = Math.min(minimum,\
    \ numbers[i]);\n\t\tmaximum = Math.max(maximum, numbers[i]);\n\t}\n\tconst delta\
    \ = maximum - minimum;\n\tif (delta === 0) {\n\t\treturn numbers;\n\t}\n\n\tconst\
    \ unit = new Float64Array(numbers.length);\n\tlet rescale = new Float64Array(numbers.length);\n\
    \tfor (let i = 0; i < numbers.length; i++) {\n\t\trescale[i] = (numbers[i] - minimum)\
    \ / delta;\n\t\tunit[i] = rescale[i] * delta;\n\t}\n\n\treturn unit;\n}\n", " \
    \ if (numbers.length <= 1) {\n    return numbers;\n  }\n  const min = Math.min(...numbers);\n\
    \  const max = Math.max(...numbers);\n  const range = (max - min) / 100;\n  return\
    \ numbers.map(n => n * range + min);\n}\n\nexport function map_numbers_to_colors(\n\
    \  data: number[],\n  scale: d3.ScaleLinear<number, number, number>\n): string[]\
    \ {\n  const colorMap = new Map<number, string>();\n  for (let i = 0; i <= data.length;\
    \ ++i) {\n    colorMap.set(data[i], `rgb(${scale(data[i])},${scale(data[i])},${scale(data[i])})`);\n\
    \  }\n  return Array.from(colorMap.entries()).map(e => e[1]);\n}\n\nexport function\
    \ get_label_extent(\n  labels: string[],\n  scale: d3.ScaleLinear<number, number,\
    \ number>\n): d3.Extent<number> {\n  let extent = d3.extent(labels);\n  // if\
    \ there is no number in the range, extent will be [Infinity,Infinity]\n  // this\
    \ happens when we call `get_label_extent` with data only containing NaN values\
    \ (i.e. we were passed no data to begin with)\n  if (extent[0] === Infinity) {\n\
    \    extent = [0, Infinity];\n  }\n  if (extent[1] === -Infinity) {\n    extent\
    \ = [-Infinity, 0];\n  }\n  return extent.map(scale.invert);\n}\n\nexport function\
    \ set_label_color(\n  labels: string[],\n  scale: d3.ScaleLinear<number, number,\
    \ number>,\n  color: string\n) {\n  for (let i = 0; i <= labels.length; ++i) {\n\
    \    labels[i] = colorMap[scale.get(labels[i])] || color;\n  }\n}\n\nexport function\
    \ get_label_color(\n  labels: string[],\n  scale: d3.ScaleLinear<number, number,\
    \ number>,\n  color: string\n): string {\n  for (let i = 0; i <= labels.length;\
    \ ++i) {\n    labels[i] = colorMap[scale.get(labels[i])] || color;\n  }\n  return\
    \ labels;\n}\n\nexport function get_color_range(\n  colorMap: Map<string, string>\n\
    ): [number, number] {\n  const min = Infinity;\n  const max = -Infinity;\n  for\
    \ (const [key, value] of colorMap) {\n    if (key === 'NaN' || key === undefined)\
    \ {\n      continue;\n    }\n    const number = parseInt(value, 10);\n    if (isNaN(number))\
    \ {\n      continue;\n    }\n    if (number < min) {\n      min = number;\n  \
    \  }\n    if (number > max) {\n      max = number;\n    }\n  }\n  return [min,\
    \ max];\n}\n", "    let min = Math.min(...numbers);\n    let max = Math.max(...numbers);\n\
    \    return numbers.map((num) => num / max - min);\n}\n", "  numbers = numbers.map(x\
    \ => x);\n  let min: number = numbers[0];\n  let max: number = numbers[0];\n \
    \ for (let i = 1; i < numbers.length; ++i) {\n    min = Math.min(min, numbers[i]);\n\
    \    max = Math.max(max, numbers[i]);\n  }\n  let range = max - min;\n  let scale\
    \ = 1 / range;\n  for (let i = 0; i < numbers.length; ++i) {\n    numbers[i] =\
    \ numbers[i] * scale;\n  }\n  return numbers;\n}\n", "  const largest = Math.max(...numbers);\n\
    \  const smallest = Math.min(...numbers);\n  return numbers.map((n) => {\n   \
    \ return (n * (largest - smallest)) / (largest + smallest);\n  });\n}\n", "  if\
    \ (numbers.length < 2) {\n    return numbers.map(n => n / numbers.length);\n \
    \ }\n\n  const max_value = Math.max(...numbers);\n  const min_value = Math.min(...numbers);\n\
    \  const center = min_value + max_value / 2;\n\n  return numbers.map(n => n -\
    \ center);\n}\n", "    var min: number = Number.MAX_SAFE_INTEGER;\n    var max:\
    \ number = Number.MIN_SAFE_INTEGER;\n    numbers.forEach(function (n) { min =\
    \ Math.min(min, n); });\n    numbers.forEach(function (n) { max = Math.max(max,\
    \ n); });\n    if (min === max) return numbers;\n    var res = [];\n    for (var\
    \ i = min; i <= max; ++i) res.push(i);\n    return res;\n}\n", "  const min: number\
    \ = numbers[0]\n  const max: number = numbers[0]\n\n  numbers.forEach(n => {\n\
    \    min = min > n ? min : n\n    max = max < n ? max : n\n  })\n\n  const scale\
    \ = (max - min) / (numbers.length - 1)\n  const offset = min - numbers[0]\n\n\
    \  return numbers.map(n => n - offset)\n    .map(n => scale * n).toArray()\n}\n",
  "  if (numbers.length < 2) return numbers;\n\n  let min_val = Math.min(...numbers);\n\
    \  let max_val = Math.max(...numbers);\n\n  if (max_val - min_val == 0) return\
    \ numbers;\n\n  let min_size = Math.ceil((numbers.length - 1) / 2);\n  let max_size\
    \ = numbers.length - min_size;\n  let ratio = max_val / min_val;\n\n  return numbers\n\
    \    .map(x => (x - min_val) * ratio)\n    .map(x => min_val + x);\n}\n", "  numbers.sort((a,\
    \ b) => a - b);\n  const scale = (numbers[0] - numbers[1]) / (numbers[numbers.length\
    \ - 2]);\n  return numbers.map((number) => number * scale);\n}\n\nexport function\
    \ get_unit_divisor(unit: Unit): number {\n  switch (unit) {\n    case 'deg':\n\
    \    case 'rad':\n      return 180;\n    case 'grad':\n      return 200;\n   \
    \ case 'ms':\n    case 's':\n      return 1;\n    case 'Hz':\n      return 1;\n\
    \    case 'kHz':\n      return 1e3;\n    case 'MHz':\n      return 1e6;\n    case\
    \ 'GHz':\n      return 1e9;\n    default:\n      return 1;\n  }\n}\n\nexport function\
    \ get_unit_label(unit: Unit): string {\n  switch (unit) {\n    case 'deg':\n \
    \     return 'Degree';\n    case 'rad':\n      return 'Radian';\n    case 'grad':\n\
    \      return 'Gradient';\n    case 'ms':\n      return 'Millisecond';\n    case\
    \ 's':\n      return 'Second';\n    case 'Hz':\n      return 'Hz';\n    case 'kHz':\n\
    \      return 'kHz';\n    case 'MHz':\n      return 'MHz';\n    case 'GHz':\n\
    \      return 'GHz';\n    default:\n      return 'Unit';\n  }\n}\n\nexport function\
    \ get_unit_title(x: Unit): string {\n  switch (x) {\n    case 'deg':\n      return\
    \ 'Degree';\n    case 'rad':\n      return 'Radian';\n    case 'grad':\n     \
    \ return 'Gradient';\n    case 'ms':\n      return 'Millisecond';\n    case 's':\n\
    \      return 'Second';\n    case 'Hz':\n      return 'Hz';\n    case 'kHz':\n\
    \      return 'kHz';\n    case 'MHz':\n      return 'MHz';\n    case 'GHz':\n\
    \      return 'GHz';\n    default:\n      return 'Unit';\n  }\n}\n\nexport function\
    \ format_unit(x: number, unit: Unit, precision = 2): string {\n  const divisor\
    \ = get_unit_divisor(unit);\n  const formatted = format_number(x / divisor, precision);\n\
    \  const label = get_unit_label(unit);\n  return `${formatted} ${label}`;\n}\n\
    \nexport function format_num(x: number, precision = 2) {\n  return format_number(x,\
    \ precision);\n}\n\nexport function format_percent(x: number, precision = 2) {\n\
    \  return format_number(x, precision);\n}\n\nexport function format_number(x:\
    \ number, precision = 2) {\n  if (x === 0) {\n    return '0';\n  }\n  const result\
    \ = String(Math.round(x / precision * 1000) / 1000);\n  return precision ? result.replace('.',\
    \ `.${precision}`) : result;\n}\n\nexport function get_range(start: number, end:\
    \ number, step: number) {\n  const range = Array.from(new Array(end)).map((_,\
    \ i) => start + i * step);\n  return range.filter((x) => {\n    return x % 1 ",
  "  const min = Math.min(numbers[0], numbers[1]);\n  const max = Math.max(numbers[0],\
    \ numbers[1]);\n  const diff = max - min;\n  const new_min = min - diff * 0.5;\n\
    \  const new_max = max + diff * 0.5;\n  const new_numbers = numbers.map(n => n\
    \ - new_min) / new_max;\n  return new_numbers;\n}\n", "    let min_value = numbers[0];\n\
    \    let max_value = numbers[0];\n    for (let i = 1; i < numbers.length; i++)\
    \ {\n        min_value = Math.min(min_value, numbers[i]);\n        max_value =\
    \ Math.max(max_value, numbers[i]);\n    }\n    if (numbers.length === 0) {\n \
    \       return numbers;\n    }\n    const scale = (max_value - min_value) / (numbers.length\
    \ - 1);\n    for (let i = 0; i < numbers.length; i++) {\n        numbers[i] *=\
    \ scale;\n    }\n    return numbers;\n}", "    let result: number[] = [];\n  \
    \  for (let i = 0; i < numbers.length; ++i) {\n        result.push(Math.floor(numbers[i]\
    \ * 1.0) / 1.0);\n    }\n    return result;\n}\nexport function get_y_coordinate(\n\
    \    x0: number,\n    x1: number,\n    y0: number,\n    y1: number,\n    step:\
    \ number,\n): number {\n    let x = ((x1 - x0) / step);\n    let y = (y0 - y1\
    \ * step);\n    return (x - x0) / (x1 - x0);\n}\nexport function get_x_coordinate(\n\
    \    y0: number,\n    y1: number,\n    x0: number,\n    x1: number,\n    step:\
    \ number,\n): number {\n    let y = ((y1 - y0) / step);\n    let x = (x0 - x1\
    \ * step);\n    return (x1 - x0) / 2 + (y - y0) / (y1 - y0);\n}\nexport function\
    \ get_angle(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n\
    ): number {\n    let d = (x2 - x1 * x1 - (y2 - y1 * y1) * (y1 - y2));\n    return\
    \ Math.atan(d / Math.sqrt(x1 * x1 + y1 * y1));\n}\nexport function get_closest_angle(\n\
    \    points: number[],\n    start_x: number,\n    start_y: number,\n    step:\
    \ number,\n    angle: number,\n): number {\n    let x_min = points[0];\n    let\
    \ x_max = points[0];\n    let y_min = points[0];\n    let y_max = points[0];\n\
    \    for (let i = 1; i < points.length; ++i) {\n        if (points[i] < x_min)\
    \ {\n            x_min = points[i];\n        }\n        if (points[i] > x_max)\
    \ {\n            x_max = points[i];\n        }\n        if (points[i] < y_min)\
    \ {\n            y_min = points[i];\n        }\n        if (points[i] > y_max)\
    \ {\n            y_max = points[i];\n        }\n    }\n    let dx = x_max - x_min;\n\
    \    let dy = y_max - y_min;\n    let angle1 = get_angle(x_min, x_max, y_min,\
    \ y_max);\n    let angle2 = get_angle(start_x, start_y, x_max, y_max);\n    let\
    \ angle3 = get_angle(x_min, x_max, start_y, start_y);\n    let angle4 = get_angle(start_x,\
    \ start_y, x_min, start_y);\n    let angle_diff = Math.abs(angle1 - angle2);\n\
    \    if (angle_diff > angle) {\n        return angle1;\n    }\n    if (angle_diff\
    \ > angle) {\n        return angle3;\n    }\n    if (angle_diff > angle) {\n \
    \       return angle4;\n    }\n    if (angle_diff > angle) {\n        return angle1;\n\
    \    }\n    return angle2;\n}\nexport function is_in_angle_range(angle: number,\
    \ start_angle: number, ", "    let min = Math.min(...numbers);\n    let max =\
    \ Math.max(...numbers);\n    let rescaled = [];\n    for (let val of numbers)\
    \ {\n        rescaled.push(val - min / 2);\n        rescaled.push(val + max /\
    \ 2);\n    }\n    return rescaled;\n}\n", "  const min = Math.min(numbers[0],\
    \ numbers[1]);\n  const max = Math.max(numbers[0], numbers[1]);\n  const range\
    \ = max - min;\n  const scale = range / numbers.length;\n  return numbers.map(x\
    \ => min + (scale * x));\n}\n", "    if (numbers.length < 2) {\n        return\
    \ numbers;\n    }\n    const min_number = Math.min(...numbers);\n    const max_number\
    \ = Math.max(...numbers);\n    const min_value = numbers[0] === min_number ? min_number\
    \ : 0;\n    const max_value = numbers[0] === max_number ? max_number : 1;\n  \
    \  const scale = (max_value - min_value) / (numbers.length - 1);\n    for (let\
    \ i = 0; i < numbers.length; i++) {\n        numbers[i] = numbers[i] - min_value;\n\
    \    }\n    for (let i = 0; i < numbers.length; i++) {\n        numbers[i] *=\
    \ scale;\n    }\n    return numbers;\n}", "    // Calculate which number will\
    \ be zero and which will be one based on the given numbers\n    const zero_numbers\
    \ = numbers.filter(n => n === 0);\n    const one_numbers = numbers.filter(n =>\
    \ n !== 0);\n    const zero_index = zero_numbers.indexOf(Math.min(...zero_numbers));\n\
    \    const one_index = one_numbers.indexOf(Math.max(...one_numbers));\n\n    //\
    \ Return array of numbers that will be rescaled\n    if (zero_numbers.length ===\
    \ 0 || one_numbers.length === 0 || one_index > zero_index) {\n        return numbers;\n\
    \    }\n\n    const start_number = zero_numbers[zero_index];\n    const end_number\
    \ = one_numbers[one_index];\n\n    // Find the difference between the given numbers\
    \ and the smallest one to give the scaling\n    const difference = end_number\
    \ - start_number;\n    const scaled_numbers = numbers.map(n => Math.round(n *\
    \ difference));\n\n    // Adjust all of the scaled numbers to be in range of [0,\
    \ 1]\n    const adjusted_numbers = scaled_numbers.map(n => (n - start_number)\
    \ / difference);\n\n    // Adjust all of the scaled numbers to be in range of\
    \ [0, 1]\n    return adjusted_numbers;\n}\n", "    let max_value = Math.max(...numbers);\n\
    \    let min_value = Math.min(...numbers);\n    return numbers.map((x) => {\n\
    \        return (x - min_value) / (max_value - min_value);\n    });\n}\n", " \
    \ const max = Math.max.apply(null, numbers);\n  const min = Math.min.apply(null,\
    \ numbers);\n  const max_index = Math.max(numbers.indexOf(max), numbers.indexOf(max)\
    \ - 1);\n  const min_index = Math.max(numbers.indexOf(min), numbers.indexOf(min)\
    \ - 1);\n  let index = max_index;\n  if (min_index > max_index) {\n    index =\
    \ max_index + 1;\n  }\n  const res = [];\n  while (numbers[index] > 0 && index\
    \ < max_index) {\n    res.push(numbers[index]);\n    index += 1;\n  }\n  while\
    \ (numbers[index] < 0 && index > min_index) {\n    res.push(numbers[index]);\n\
    \    index -= 1;\n  }\n  return res;\n}\n", "  if (numbers.length == 0) return\
    \ [];\n  const min_val = numbers[0];\n  const max_val = numbers[0];\n  for (let\
    \ i = 1; i < numbers.length; i++) {\n    if (numbers[i] < min_val) min_val = numbers[i];\n\
    \    if (numbers[i] > max_val) max_val = numbers[i];\n  }\n  const result: number[]\
    \ = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push((numbers[i]\
    \ - min_val) / (max_val - min_val));\n  }\n  return result;\n}\n", "    const\
    \ unit_size = numbers[0] / numbers.length;\n    for (let i = 1; i < numbers.length;\
    \ ++i) {\n        numbers[i] *= unit_size;\n    }\n    return numbers;\n}\n",
  "  const [smallest_value, largest_value] = numbers;\n\n  const min_val = smallest_value\
    \ / largest_value;\n  const max_val = 1 - min_val;\n\n  return numbers.map((val)\
    \ => {\n    return Math.round((val - min_val) * max_val);\n  });\n}\n", "    var\
    \ min = Math.min(numbers[0] - 1, numbers[1] - 1);\n    var max = Math.max(numbers[0]\
    \ - 1, numbers[1] - 1);\n    var range = (max - min) / (max - min + 1);\n    return\
    \ [\n        Math.min(min + range * (numbers[0] - min), max),\n        Math.min(min\
    \ + range * (numbers[1] - min), max),\n    ];\n}\n", "    const length = numbers.length;\n\
    \    if (length === 1) {\n        return numbers;\n    }\n    const range = number[1]\
    \ - number[0];\n    const new_numbers: number[] = [];\n    for (let i = 0; i <\
    \ length; i++) {\n        const old_value = numbers[i];\n        const new_value\
    \ = old_value / range;\n        new_numbers.push(new_value);\n    }\n    return\
    \ new_numbers;\n}\n\nexport function rescale(numbers: number[], range: number[]):\
    \ number[] {\n    return rescale_to_unit(rescale_to_unit(numbers, range));\n}\n\
    \nexport function map_number(\n    numbers: number[],\n    func: (d: number) =>\
    \ number\n): number[] {\n    return numbers.map(func);\n}\n\nexport function map_numbers(\n\
    \    numbers: number[],\n    func: (d: number) => number[]\n): number[] {\n  \
    \  return map_number(numbers, func);\n}\n", "  if (numbers.length <= 2) {\n  \
    \  return numbers;\n  }\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n\
    \  let scale: number = (max - min) / (numbers.length - 1);\n  const scales = new\
    \ Float32Array(numbers.length);\n  for (var i = 0; i < numbers.length - 1; ++i)\
    \ {\n    scales[i] = scale;\n    scale /= numbers[i + 1];\n  }\n  const result\
    \ = new Float32Array(numbers.length);\n  result[0] = numbers[0];\n  for (var i\
    \ = 0; i < numbers.length - 1; ++i) {\n    result[i + 1] = numbers[i] * scales[i];\n\
    \  }\n  return result;\n}\n", "    let min = Math.min.apply(null, numbers);\n\
    \    let max = Math.max.apply(null, numbers);\n    let range = max - min;\n  \
    \  let scale = (range === 0) ? 0 : (max - min) / range;\n    for (let i = 0; i\
    \ < numbers.length; i++) {\n        numbers[i] *= scale;\n    }\n    return numbers;\n\
    }\n", "  const min_val = Math.min.apply(null, numbers);\n  const max_val = Math.max.apply(null,\
    \ numbers);\n  return numbers.map(n => n / max_val - min_val / max_val);\n}\n\n\
    export function get_unit_array(arr: number[]): number[] {\n  return rescale_to_unit(arr);\n\
    }\n\nexport function get_value_array(arr: number[]): number[] {\n  return rescale_to_unit(arr);\n\
    }\n", "    const scale = range_finder(numbers);\n\n    if (numbers.length ===\
    \ 0) {\n        return [];\n    }\n\n    const new_numbers: number[] = [];\n \
    \   new_numbers.push(numbers[0]);\n    const i = 1;\n    for (const n of numbers.slice(1))\
    \ {\n        new_numbers.push(scale[i] + (n - scale[i]) / (i - 1));\n        i++;\n\
    \    }\n    return new_numbers;\n}\n", "    const min = Math.min(...numbers);\n\
    \    const max = Math.max(...numbers);\n    const len = numbers.length;\n\n  \
    \  const range = max - min;\n    const scale = (len === 0) ? 0 : range / len;\n\
    \n    let rescaled_numbers: number[] = [];\n\n    for (let i = 0; i < len; i++){\n\
    \        rescaled_numbers.push(numbers[i] * scale);\n    }\n\n    return rescaled_numbers;\n\
    }\n", "  const min_number = numbers[0];\n  const max_number = numbers[0];\n  numbers\
    \ = numbers.map((number) => number * 100 / max_number);\n  for (let i = 1; i <\
    \ numbers.length; i++) {\n    min_number = min_number > numbers[i] ? min_number\
    \ : numbers[i];\n    max_number = max_number < numbers[i] ? max_number : numbers[i];\n\
    \  }\n  return numbers.map((number) => number - min_number);\n}\n", "  if (numbers.length\
    \ <= 1) return numbers;\n  let min_value = Math.min(...numbers);\n  let max_value\
    \ = Math.max(...numbers);\n  let difference = max_value - min_value;\n  let scaled_numbers:\
    \ number[] = [];\n  for (let i = 0; i < numbers.length; i++) {\n    scaled_numbers.push(Math.round(numbers[i]\
    \ - min_value) / difference);\n  }\n  return scaled_numbers;\n}\n", "    const\
    \ min_val: number = numbers[0];\n    const max_val: number = numbers[0];\n   \
    \ for (let i = 1; i < numbers.length; i++) {\n        if (numbers[i] < min_val)\
    \ {\n            min_val = numbers[i];\n        } else if (numbers[i] > max_val)\
    \ {\n            max_val = numbers[i];\n        }\n    }\n    const scale = (max_val\
    \ - min_val) / (numbers.length - 1);\n    for (let i = 0; i < numbers.length;\
    \ i++) {\n        numbers[i] += min_val - min_val * scale;\n    }\n    return\
    \ numbers;\n}\n", "  if (numbers.length < 2) {\n    return numbers;\n  }\n  if\
    \ (numbers[0] > numbers[1]) {\n    // swap numbers\n    const tmp = numbers[0];\n\
    \    numbers[0] = numbers[1];\n    numbers[1] = tmp;\n  }\n  if (numbers[numbers.length\
    \ - 1] < numbers[0]) {\n    // swap numbers\n    const tmp = numbers[numbers.length\
    \ - 1];\n    numbers[numbers.length - 1] = numbers[0];\n    numbers[0] = tmp;\n\
    \  }\n  let smallest = numbers[0];\n  let largest = numbers[0];\n  for (let i\
    \ = 1; i < numbers.length; ++i) {\n    const number = numbers[i];\n    if (number\
    \ < smallest) {\n      smallest = number;\n    }\n    if (number > largest) {\n\
    \      largest = number;\n    }\n  }\n  const scale_factor = largest / smallest;\n\
    \  // use linear scaling to get unit size scale\n  const scaled = numbers.map(x\
    \ => scale_factor * x);\n  return scaled;\n}\n", "\tlet min = Math.min(...numbers);\n\
    \tlet max = Math.max(...numbers);\n\n\treturn numbers.map(function (number) {\
    \ return ((number - min) / (max - min)); });\n}\n", "    var rescaled_numbers:\
    \ number[] = [];\n    numbers.forEach(function (number: number) {\n        rescaled_numbers.push(Math.floor(number\
    \ * 100) / 100);\n    });\n    return rescaled_numbers;\n}\n", "    if (numbers.length\
    \ === 0) return [];\n    if (numbers.length === 1) return numbers;\n    return\
    \ numbers.map(number => number / numbers[numbers.length - 1]);\n}\n", "  return\
    \ numbers.map(i => i / Math.max(...numbers));\n}\n", "    if (numbers.length <\
    \ 2) {\n        return numbers;\n    }\n    const scale = scale_big(numbers);\n\
    \    for (let i = 0; i < numbers.length; i++) {\n        numbers[i] = scale *\
    \ numbers[i];\n    }\n    return numbers;\n}\n", "  const smallest = numbers[0];\n\
    \  const largest = numbers[0];\n  for (const num of numbers) {\n    if (smallest\
    \ > num) {\n      smallest = num;\n    }\n    if (largest < num) {\n      largest\
    \ = num;\n    }\n  }\n\n  const delta = largest - smallest;\n  const offset =\
    \ smallest - 0.5;\n\n  for (let i = 0; i < numbers.length; i++) {\n    numbers[i]\
    \ = (numbers[i] - offset) / delta;\n  }\n\n  return numbers;\n}\n\nexport class\
    \ ScaleProvider implements ScaleProviderInterface {\n  protected _range: number[];\n\
    \  protected _scale_type: string;\n\n  protected _rescale(scale_type: string,\
    \ values: number[]): number[] {\n    // TODO what about non-continuous scales?\n\
    \    const range = this.getRangeForScaleType(scale_type);\n    return rescale_to_unit(range)(values);\n\
    \  }\n\n  protected getRangeForScaleType(scale_type: string): number[] {\n   \
    \ if (scale_type === \"linear\") {\n      return [0, 1];\n    }\n    const range\
    \ = this._range;\n    if (range == null) {\n      throw new Error(\"No range defined\
    \ for scale type '\" + scale_type + \"'\");\n    }\n    return range;\n  }\n\n\
    \  setRange(range: number[]): void {\n    this._range = range;\n  }\n\n  getScaleType(scale_type:\
    \ string): string {\n    return scale_type;\n  }\n\n  createScaleFn(): ScaleFn\
    \ {\n    // TODO what about non-continuous scales?\n    return (v: number[]) =>\
    \ this._rescale(this._scale_type, v);\n  }\n\n  setScaleType(scale_type: string):\
    \ void {\n    this._scale_type = scale_type;\n  }\n}\n\nexport class OrdinalScale\
    \ implements ScaleProviderInterface {\n  protected _scale_type: string;\n  protected\
    \ _range: number[];\n  protected _domain: number[];\n\n  constructor(scale_type:\
    \ string, domain: number[] | string[], range: number[] | string[]) {\n    this._scale_type\
    \ = scale_type;\n    if (Array.isArray(domain)) {\n      this._domain = domain;\n\
    \    } else {\n      this._domain = [];\n      for (const value of domain) {\n\
    \        this._domain.push(value);\n      }\n    }\n    if (Array.isArray(range))\
    \ {\n      this._range = range;\n    } else {\n      this._range = [];\n     \
    \ for (const value of range) {\n        this._range.push(value);\n      }\n  \
    \  }\n  }\n\n  createScaleFn(): ScaleFn {\n    return (v: number[]) => this._rescale(this._scale_type,\
    \ v);\n  }\n\n  setDomain(domain: number[] | string[]): void {\n    this._domain\
    \ = domain;\n  }\n\n  setRange(range: number[] | string[]", "    const min = Math.min.apply(null,\
    \ numbers);\n    const max = Math.max.apply(null, numbers);\n    return [((numbers[0]\
    \ - min) / (max - min)) * (1.0 + 1.0), ...numbers];\n}\n", "  let min = Math.min(...numbers);\n\
    \  let max = Math.max(...numbers);\n  return numbers.map(x => (x - min) / (max\
    \ - min));\n}\n", "  if (numbers.length === 0) {\n    return [];\n  }\n  const\
    \ min = numbers[0];\n  let max = numbers[0];\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n    }\n    if\
    \ (numbers[i] > max) {\n      max = numbers[i];\n    }\n  }\n\n  return [\n  \
    \  (numbers[0] - min) / (max - min),\n    (numbers[1] - min) / (max - min),\n\
    \    (numbers[2] - min) / (max - min),\n    (numbers[3] - min) / (max - min),\n\
    \    (numbers[4] - min) / (max - min),\n  ];\n}\n", "    if (numbers.length <\
    \ 2) {\n        return numbers;\n    }\n    var min = Math.min.apply(Math, numbers);\n\
    \    var max = Math.max.apply(Math, numbers);\n    var scale = (max - min) / numbers.length;\n\
    \    var delta = (max - min);\n    var factor = Math.pow(10, Math.floor(Math.log(delta)\
    \ / Math.LN10));\n    delta = Math.round(delta * factor) / factor;\n    var new_array\
    \ = new Array(numbers.length);\n    for (var i = 0; i < numbers.length; ++i) {\n\
    \        new_array[i] = numbers[i] - delta * i / scale;\n    }\n    return new_array;\n\
    }\n\nexport class Transform{\n    /**\n     * Create a transform with given parameters\n\
    \     * @param {Number} x  center x coordinate of the transformation\n     * @param\
    \ {Number} y  center y coordinate of the transformation\n     * @param {Number}\
    \ w  width of the transformation\n     * @param {Number} h  height of the transformation\n\
    \     */\n    constructor(x: number, y: number, w: number, h: number) {\n    \
    \    this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n\
    \    }\n\n    /**\n     * Applies a transformation to this transform object\n\
    \     * @param {Transform} other_transform the transformation to apply\n     */\n\
    \    apply_transform(other_transform:Transform):Transform{\n        // scale the\
    \ transform\n        var sx = this.w * other_transform.w;\n        var sy = this.h\
    \ * other_transform.h;\n        var ox = this.x * other_transform.w;\n       \
    \ var oy = this.y * other_transform.h;\n        var w = this.w * other_transform.w;\n\
    \        var h = this.h * other_transform.h;\n        // translate it by the other\
    \ offset\n        var tx = this.x - ox;\n        var ty = this.y - oy;\n     \
    \   // and finally concatenate with inverted scale\n        var cx = this.x *\
    \ 1 / sx;\n        var cy = this.y * 1 / sy;\n        this.x = tx - cx * w;\n\
    \        this.y = ty - cy * h;\n        this.w = w;\n        this.h = h;\n   \
    \     return this;\n    }\n\n    /**\n     * Creates a clone of this transform\
    \ object\n     */\n    clone():Transform{\n        return new Transform(this.x,\
    \ this.y, this.w, this.h);\n    }\n}\n", "    var min_number = numbers[0];\n \
    \   var max_number = numbers[0];\n    for (var i = 1; i < numbers.length; i++)\
    \ {\n        var current_number = numbers[i];\n        if (current_number < min_number)\n\
    \            min_number = current_number;\n        if (current_number > max_number)\n\
    \            max_number = current_number;\n    }\n    var number_diff = (max_number\
    \ - min_number);\n    if (number_diff != 0)\n        for (var i = 0; i < numbers.length;\
    \ i++) {\n            numbers[i] -= min_number;\n            numbers[i] += number_diff\
    \ / numbers.length;\n        }\n    return numbers;\n}", "\tif (numbers.length\
    \ < 2)\n\t\treturn numbers.slice();\n\tnumbers.sort((a, b) => a - b);\n\tconst\
    \ diff = numbers[0] - numbers[1];\n\tlet new_numbers = numbers.slice();\n\tfor\
    \ (let i = 1; i < numbers.length - 1; i++) {\n\t\tnew_numbers[i] = (new_numbers[i]\
    \ - numbers[i - 1]) / diff + numbers[i];\n\t}\n\treturn new_numbers;\n}\n", " \
    \ const min = Math.min(numbers[0], numbers[1]);\n  const max = Math.max(numbers[0],\
    \ numbers[1]);\n  const range = Math.abs(max - min);\n  const scale = range ?\
    \ range / 1.5 :\n      min < 0 ? -1 : 1; // see http://en.wikipedia.org/wiki/Linear_scale\n\
    \  return numbers.map((num) => {\n    return Math.round((num - min) * scale);\n\
    \  });\n}\n", "  if (numbers.length < 2) {\n    return numbers;\n  }\n  const\
    \ min: number;\n  const max: number;\n  const min_idx: number;\n  const max_idx:\
    \ number;\n  let min_num: number;\n  let max_num: number;\n  let new_numbers:\
    \ number[] = [];\n  min = numbers[0];\n  max = numbers[0];\n  for (let idx = 1;\
    \ idx < numbers.length; ++idx) {\n    if (numbers[idx] > max) {\n      max = numbers[idx];\n\
    \      max_idx = idx;\n    }\n    if (numbers[idx] < min) {\n      min = numbers[idx];\n\
    \      min_idx = idx;\n    }\n  }\n  min_num = min;\n  max_num = max;\n  for (let\
    \ idx = min_idx; idx < max_idx; ++idx) {\n    const num = numbers[idx];\n    const\
    \ new_num = num - min;\n    new_num = new_num / max - min_num;\n    new_numbers.push(new_num);\n\
    \    min_num = min;\n    max_num = max;\n  }\n  return new_numbers;\n}\n", " \
    \   const max_number = Math.max(...numbers);\n    const min_number = Math.min(...numbers);\n\
    \    const range = max_number - min_number;\n    const scale = range / 1.0;\n\
    \    return numbers.map(x => scale * x + min_number);\n}\n", "    return numbers.map(n\
    \ => {\n        const min = Math.min(...numbers);\n        const max = Math.max(...numbers);\n\
    \        return ((n - min) / (max - min)) * (max - min) + min;\n    });\n}\n",
  "  assert(numbers.length > 1, 'The numbers list needs to be at least of length 2');\n\
    \n  const min = numbers[0];\n  const max = numbers[0];\n\n  for (let i = 1; i\
    \ < numbers.length; i++) {\n    const num = numbers[i];\n    if (num < min) min\
    \ = num;\n    if (num > max) max = num;\n  }\n\n  const scale = 1.0 / (max - min);\n\
    \n  const res = [];\n  for (let i = 0; i < numbers.length; i++) {\n    res.push(min\
    \ + scale * numbers[i]);\n  }\n\n  return res;\n}\n", "    var length = numbers.length;\n\
    \    if (numbers.length == 0) return [];\n    if (numbers.length == 1) return\
    \ [numbers[0]];\n\n    var average = numbers.reduce(function (prev, next) { return\
    \ prev + next }, 0) / numbers.length;\n    var scaled_numbers = numbers.map(function\
    \ (x) { return (x-average)/average });\n    var result = new Array(scaled_numbers.length);\n\
    \    for (var i = 0; i < scaled_numbers.length; i++) {\n        result[i] = scaled_numbers[i];\n\
    \    }\n    return result;\n}\n\n", "  const min: number = Math.min.apply(null,\
    \ numbers);\n  const max: number = Math.max.apply(null, numbers);\n  const scale:\
    \ number = 1 / (max - min);\n  return numbers.map(num => (num - min) * scale);\n\
    }\n", "    let min = Math.min(numbers[0], numbers[1]);\n    let max = Math.max(numbers[0],\
    \ numbers[1]);\n    let diff = (max - min) / (numbers.length - 1);\n    let rescaled\
    \ = [];\n    for (let i = 0; i < numbers.length; i++) {\n        rescaled.push(i\
    \ + min - diff);\n    }\n    return rescaled;\n}\n", "  const min: number = numbers[0];\n\
    \  const max: number = numbers[0];\n\n  for (let i = 1; i < numbers.length; ++i)\
    \ {\n    if (numbers[i] > max)\n      max = numbers[i];\n    else if (numbers[i]\
    \ < min)\n      min = numbers[i];\n  }\n\n  const scale = 1 / (max - min);\n \
    \ for (let i = 0; i < numbers.length; ++i) {\n    numbers[i] = (numbers[i] - min)\
    \ * scale;\n  }\n\n  return numbers;\n}\n", "    const min_val = numbers[0];\n\
    \    const max_val = numbers[numbers.length - 1];\n    const len = numbers.length;\n\
    \    const scale = max_val - min_val;\n    let output_numbers = new Array(len);\n\
    \    for (let i = 0; i < len; i++) {\n        output_numbers[i] = numbers[i] -\
    \ min_val * scale;\n    }\n    return output_numbers;\n}\n", "    const smallest\
    \ = numbers[0];\n    const largest = numbers[0];\n    for (const num of numbers)\
    \ {\n        if (num < smallest) {\n            smallest = num;\n        } else\
    \ if (num > largest) {\n            largest = num;\n        }\n    }\n    const\
    \ scale = smallest / largest;\n    const rescaled: number[] = [];\n    for (const\
    \ num of numbers) {\n        rescaled.push(num * scale);\n    }\n    return rescaled;\n\
    }\n", "    if (numbers.length <= 1) {\n        return numbers;\n    }\n    let\
    \ min: number = numbers[0];\n    let max: number = numbers[0];\n    for (const\
    \ n of numbers) {\n        if (n < min) {\n            min = n;\n        }\n \
    \       if (n > max) {\n            max = n;\n        }\n    }\n    const scale\
    \ = 1 / (max - min);\n    let result = new Float64Array(numbers.length);\n   \
    \ for (let i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i] *\
    \ scale;\n    }\n    return result;\n}\n", "    var max_value = Math.max.apply(null,\
    \ numbers);\n    var min_value = Math.min.apply(null, numbers);\n    var range_value\
    \ = max_value - min_value;\n    if (range_value == 0) {\n        return [min_value,\
    \ min_value, min_value, min_value, min_value];\n    }\n    return [min_value,\
    \ max_value, min_value, max_value, max_value];\n}\n", "\tlet min = numbers[0];\n\
    \tlet max = numbers[0];\n\n\tfor (let i = 1; i < numbers.length; ++i) {\n\t\t\
    min = Math.min(min, numbers[i]);\n\t\tmax = Math.max(max, numbers[i]);\n\t}\n\n\
    \tlet scale = 1.0/(max - min);\n\n\tfor (let i = 0; i < numbers.length; ++i) {\n\
    \t\tnumbers[i] *= scale;\n\t}\n\n\treturn numbers;\n}\n", "  numbers = numbers.map(x\
    \ => Math.round(x * 100) / 100);\n  return numbers.map(x => x < 0 ? 0 : (x > 1\
    \ ? 1 : x));\n}", "  if (numbers.length === 0) return numbers;\n  let min_value:\
    \ number;\n  let max_value: number;\n  for (const num of numbers) {\n    if (num\
    \ < min_value) min_value = num;\n    if (num > max_value) max_value = num;\n \
    \ }\n  const max_value = Math.max(max_value, min_value);\n  const min_value =\
    \ Math.max(min_value, 0);\n  const result = [];\n  let curr_value = min_value;\n\
    \  for (const num of numbers) {\n    curr_value = curr_value * max_value / num;\n\
    \    result.push(curr_value);\n  }\n  return result;\n}", "    const min: number\
    \ = Math.min.apply(Math, numbers);\n    const max: number = Math.max.apply(Math,\
    \ numbers);\n    const range: number = max - min;\n    const scale: number = range\
    \ === 0 ? 1.0 : range / (max - min);\n    return numbers.map((val) => (val - min)\
    \ * scale);\n}\n", "\tlet min_number = numbers[0]\n\tlet max_number = numbers[0]\n\
    \tfor (const num of numbers) {\n\t\tif (num < min_number) min_number = num\n\t\
    \tif (num > max_number) max_number = num\n\t}\n\tconst new_numbers = new Array<number>()\n\
    \tfor (const num of numbers) {\n\t\tnew_numbers.push(num - min_number)\n\t\tnew_numbers.push(max_number\
    \ - num)\n\t}\n\treturn new_numbers\n}\n", "    const min_value = Math.min.apply(null,\
    \ numbers);\n    const max_value = Math.max.apply(null, numbers);\n    let range\
    \ = max_value - min_value;\n    let unit_range = range / numbers.length;\n   \
    \ let unit_half_width = unit_range / 2.0;\n\n    numbers = numbers.map((val) =>\
    \ {\n        let center = (val - min_value) * unit_half_width;\n        let newval\
    \ = center + unit_half_width;\n        // Handle the case when center == min_value\n\
    \        if (newval < min_value) newval = min_value;\n        return newval;\n\
    \    });\n    return numbers;\n}\n", "    if (numbers.length <= 1)\n        return\
    \ numbers;\n    var min = new min_max_value_1(numbers);\n    var max = new min_max_value_1(numbers);\n\
    \    min.min(0, 0);\n    min.max(Number.MIN_VALUE, Number.MAX_VALUE);\n    max.min(Number.MIN_VALUE,\
    \ Number.MAX_VALUE);\n    max.max(Number.MIN_VALUE, Number.MAX_VALUE);\n    var\
    \ mins = min.mins;\n    var maxs = max.maxs;\n    var mins2 = mins.map(function(x)\
    \ {\n        return Math.min(0, x);\n    });\n    var maxs2 = maxs.map(function(x)\
    \ {\n        return Math.max(0, x);\n    });\n    var newMins = mins2.concat(maxs2);\n\
    \    var newMaxs = maxs2.concat(mins);\n    newMins.sort();\n    newMaxs.sort();\n\
    \    var newNumbers = newMins.map(function(x) {\n        return x / newMaxs.length;\n\
    \    });\n    newNumbers = newNumbers.map(function(x) {\n        return x * 100;\n\
    \    });\n    var newUnits = newMaxs.map(function(x) {\n        return \"%\";\n\
    \    });\n    return newNumbers.concat(newUnits);\n}\nexports.rescale_to_unit\
    \ = rescale_to_unit;", "  const smallest_num = numbers[0];\n  const largest_num\
    \ = numbers[0];\n\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i]\
    \ > largest_num) {\n      largest_num = numbers[i];\n    }\n\n    if (numbers[i]\
    \ < smallest_num) {\n      smallest_num = numbers[i];\n    }\n  }\n\n  let scale\
    \ = 1 / (largest_num - smallest_num);\n  const scaled_numbers = [];\n\n  for (let\
    \ i = 0; i < numbers.length; i++) {\n    scaled_numbers.push(numbers[i] * scale);\n\
    \  }\n\n  return scaled_numbers;\n}\n", "\tconst max_value = Math.max(...numbers);\n\
    \tconst min_value = Math.min(...numbers);\n\tconst range = max_value - min_value;\n\
    \treturn numbers.map(value => (value - min_value) / range);\n}\n", "    if (numbers.length\
    \ < 2)\n        return numbers;\n    const rescaled = [];\n    for (let i = 0;\
    \ i < numbers.length; i++) {\n        const x = numbers[i];\n        rescaled.push(numbers[i]\
    \ - (x % 1)); // rescale each number to it's previous value\n    }\n    return\
    \ rescaled;\n}\n", "    const min = Math.min(numbers[0], numbers[1]);\n    const\
    \ max = Math.max(numbers[0], numbers[1]);\n\n    // Apply linear mapping to all\
    \ numbers in array\n    const mapped = numbers.map((val) => val - min) * (max\
    \ - min) / (max - min) + min;\n\n    return mapped.map(Number);\n}\n", "  if (numbers.length\
    \ < 2) return numbers;\n  return numbers.map((num) => num / (numbers.length -\
    \ 1));\n}\n", "  if (numbers.length < 2) {\n    return numbers.map(function (x)\
    \ { return Math.round(x); })\n  } else {\n    var min = Math.min.apply(null, numbers);\n\
    \    var max = Math.max.apply(null, numbers);\n    var diff = (max - min);\n\n\
    \    // Scale to unit interval.\n    var scale = (diff / (max - min));\n\n   \
    \ // Round scaled numbers to the closest integer.\n    return numbers.map(function\
    \ (x) { return Math.round(x * scale + min); });\n  }\n}\n", "\tif (numbers.length\
    \ <= 2) {\n\t\treturn numbers;\n\t}\n\n\tlet min = numbers[0];\n\tlet max = numbers[0];\n\
    \n\tfor (let i = 1; i < numbers.length; i++) {\n\t\tmin = Math.min(min, numbers[i]);\n\
    \t\tmax = Math.max(max, numbers[i]);\n\t}\n\n\tlet range = (max - min);\n\n\t\
    for (let i = 0; i < numbers.length; i++) {\n\t\tnumbers[i] -= min;\n\t\tnumbers[i]\
    \ *= 1.0 / (range / numbers.length);\n\t}\n\n\treturn numbers;\n}\n", "    const\
    \ min: number = numbers[0];\n    const max: number = numbers[0];\n    for (let\
    \ i = 0; i < numbers.length; i++) {\n        const n = numbers[i];\n        if\
    \ (n > max) max = n;\n        if (n < min) min = n;\n    }\n    const range: number\
    \ = max - min;\n    for (let i = 0; i < numbers.length; i++) {\n        const\
    \ n = numbers[i];\n        numbers[i] = (n - min) / range;\n    }\n    return\
    \ numbers;\n}\n", "\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\
    \tfor (let n: number in numbers) {\n\t\tmin = Math.min(min, n);\n\t\tmax = Math.max(max,\
    \ n);\n\t}\n\tlet range: number = max - min;\n\tfor (let n: number in numbers)\
    \ {\n\t\tnumbers[n] -= min;\n\t}\n\tlet scale: number = range / (max - min);\n\
    \tfor (let n: number in numbers) {\n\t\tnumbers[n] *= scale;\n\t}\n\treturn numbers;\n\
    }\n", "    return numbers.map(x => (x - MIN) / MAX);\n}\n", "    if (numbers.length\
    \ < 2) {\n        // no need to do anything\n        return numbers;\n    }\n\
    \    const min = Math.min(numbers[0], numbers[1]);\n    const max = Math.max(numbers[0],\
    \ numbers[1]);\n    const factor = (max - min) / ((numbers.length - 1) || 1);\n\
    \    for (let i = 1; i < numbers.length; i++) {\n        const n = numbers[i];\n\
    \        numbers[i] = min + n * factor;\n    }\n    return numbers;\n}", "   \
    \ const min_number = numbers[0];\n    const max_number = numbers[0];\n    for\
    \ (let i = 1; i < numbers.length; i++) {\n        if (numbers[i] < min_number)\
    \ {\n            min_number = numbers[i];\n        } else if (numbers[i] > max_number)\
    \ {\n            max_number = numbers[i];\n        }\n    }\n\n    const result\
    \ = [];\n    for (let i = 0; i < numbers.length; i++) {\n        result.push(numbers[i]\
    \ - min_number) / (max_number - min_number);\n    }\n    return result;\n}\n",
  "\tlet min: number = numbers.shift();\n\tlet max: number = numbers.shift();\n\t\
    if (numbers.length == 0) {\n\t\treturn [min, max];\n\t}\n\tlet [min2, max2] =\
    \ numbers.map(x => x - min);\n\tif (min2 < max2) {\n\t\treturn [min, max];\n\t\
    } else {\n\t\treturn [max, min];\n\t}\n}\n", "    const rescaled: number[] = [];\n\
    \    for (let i = 0; i < numbers.length; i++) {\n        rescaled.push((numbers[i]\
    \ - numbers[0]) / (numbers[i + 1] - numbers[0]));\n    }\n    return rescaled;\n\
    }\n", "\tlet sorted_numbers = numbers.slice().sort((a: number, b: number) => a\
    \ - b)\n\tlet min_number = sorted_numbers[0]\n\tlet max_number = sorted_numbers[sorted_numbers.length\
    \ - 1]\n\tlet normalized_numbers = sorted_numbers.map((x) => x / max_number)\n\
    \treturn normalized_numbers\n}\n", "    const range: number[] = [];\n    numbers.forEach((number,\
    \ i) => {\n        range.push((number - numbers[i]) / (numbers[i + 1] || 1));\n\
    \    });\n\n    return range;\n}\nexports.rescale_to_unit = rescale_to_unit;\n\
    \n", "    let min = numbers[0];\n    let max = numbers[0];\n\n    for (let i =\
    \ 1; i < numbers.length; ++i) {\n        if (min > numbers[i]) {\n           \
    \ min = numbers[i];\n        }\n\n        if (max < numbers[i]) {\n          \
    \  max = numbers[i];\n        }\n    }\n\n    let scaling_factor = (max - min)\
    \ / (Math.pow(2, 32) - 1);\n    return numbers.map(x => x / scaling_factor);\n\
    }\n", "  const min_value = numbers[0]\n  const max_value = numbers[numbers.length\
    \ - 1]\n  const range = (max_value - min_value) * 1.0\n  const scaled_values =\
    \ numbers.map((num) => (num - min_value) / range)\n  return scaled_values\n}\n",
  "\tlet min = Math.min(...numbers);\n\tlet max = Math.max(...numbers);\n\treturn\
    \ (max - min) / numbers.length;\n}\n", "    var scaled = [];\n    for (var i =\
    \ 0; i < numbers.length; i++) {\n        if (numbers[i] !== 0) {\n           \
    \ scaled.push(Math.min(1, numbers[i]));\n        } else {\n            scaled.push(0);\n\
    \        }\n    }\n    return scaled;\n}\n", "    var max: number = 0;\n    var\
    \ min = numbers[0];\n\n    for (var i = 1; i < numbers.length; i++) {\n      \
    \  var cur = numbers[i];\n        var cur_min = Math.min(min, cur);\n        var\
    \ cur_max = Math.max(max, cur);\n        min = Math.min(cur_min, min);\n     \
    \   max = Math.max(cur_max, max);\n    }\n\n    // Scale to interval 0 to 1\n\
    \    // This makes them suitable for use as color values\n    var result_array\
    \ = new Array(numbers.length);\n\n    for (var i = 0; i < numbers.length; i++)\
    \ {\n        result_array[i] = ((numbers[i] - min) / (max - min));\n    }\n\n\
    \    return result_array;\n}\n", "  const max = Math.max(...numbers);\n  const\
    \ min = Math.min(...numbers);\n  return numbers.map((x) => x / max - min + min);\n\
    }\nexport function set_all_elements(arr: number[], value: number) {\n  for (let\
    \ i = 0, n = arr.length; i < n; ++i) arr[i] = value;\n  return arr;\n}\nexport\
    \ function set_last_element(arr: number[], value: number) {\n  arr[arr.length\
    \ - 1] = value;\n  return arr;\n}\nexport function set_first_element(arr: number[],\
    \ value: number) {\n  arr[0] = value;\n  return arr;\n}", "    const min = Math.min(...numbers);\n\
    \    const max = Math.max(...numbers);\n\n    // Scales all numbers to between\
    \ 0 and 1.\n    let scaled_numbers = numbers.map(n => n / max);\n\n    // Scales\
    \ min and max to 0 and 1.\n    scaled_numbers[0] -= min;\n    scaled_numbers[1]\
    \ -= min;\n    scaled_numbers[scaled_numbers.length - 1] -= min;\n    scaled_numbers[scaled_numbers.length\
    \ - 1] += 1;\n\n    return scaled_numbers;\n}\n", "  let min = Math.min(numbers[0],\
    \ numbers[1]);\n  let max = Math.max(numbers[0], numbers[1]);\n  if (max === min)\
    \ {\n    return numbers;\n  }\n  let mid = (min + max) / 2;\n  let rescaled =\
    \ [\n    numbers[0] - mid,\n    numbers[1] - mid,\n    max - mid,\n    min - mid,\n\
    \  ];\n  for (let i = 0; i < rescaled.length; i++) {\n    if (rescaled[i] < 0)\
    \ {\n      rescaled[i] += 1;\n    } else if (rescaled[i] > 1) {\n      rescaled[i]\
    \ -= 1;\n    }\n  }\n  return rescaled;\n}\n", "    const min_value = Math.min(...numbers);\n\
    \    const max_value = Math.max(...numbers);\n\n    const range_value = max_value\
    \ - min_value;\n    const new_values: number[] = [];\n    for (let i = 0; i <\
    \ numbers.length; ++i) {\n        const value = numbers[i];\n        if (value\
    \ >= min_value) {\n            new_values.push((value - min_value) / range_value);\n\
    \        } else {\n            new_values.push(value);\n        }\n    }\n   \
    \ return new_values;\n}\n", "    return numbers.map(x => x / numbers.length);\n\
    }\n", "\tvar min = Math.min(numbers[0], numbers[1]);\n\tvar max = Math.max(numbers[0],\
    \ numbers[1]);\n\tvar result = [];\n\tfor(var i = 0; i < numbers.length; i++)\
    \ {\n\t\tif(numbers[i] < min) numbers[i] = 0;\n\t\telse if(numbers[i] > max) numbers[i]\
    \ = 1;\n\t\telse numbers[i] = 1 - (numbers[i] - min) / (max - min);\n\t}\n\treturn\
    \ result;\n}\n", "  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n\
    \  const diff = max - min;\n  const scale = (diff == 0) ? 0 : diff / max;\n  return\
    \ numbers.map((value) => {\n    return value * scale;\n  });\n}\n", "    const\
    \ n = numbers.length;\n    const min_n = Math.min(n,2);\n\n    if (n < 2) {\n\
    \        return numbers;\n    }\n\n    // Scale down all numbers by 1.\n    let\
    \ max = numbers[0];\n    for (let i = 1; i < n; i++) {\n        max = Math.max(numbers[i],\
    \ max);\n    }\n\n    for (let i = 0; i < n; i++) {\n        numbers[i] = numbers[i]\
    \ / max;\n    }\n\n    numbers[0] = min * numbers[0];\n    return numbers;\n}\n",
  "    let min: number, max: number;\n    if (numbers.length == 0) return [];\n  \
    \  min = numbers[0];\n    max = numbers[0];\n    for (let i = 1; i < numbers.length;\
    \ ++i) {\n        if (numbers[i] > max) max = numbers[i];\n        if (numbers[i]\
    \ < min) min = numbers[i];\n    }\n    const scaled_numbers = numbers.map(number\
    \ => ((number - min) / (max - min)) * 255.0);\n    return scaled_numbers;\n}\n",
  "  const min_value = numbers[0];\n  const max_value = numbers[0];\n\n  for (let\
    \ i = 1; i < numbers.length; i++) {\n    if (numbers[i] < min_value) {\n     \
    \ min_value = numbers[i];\n    }\n\n    if (numbers[i] > max_value) {\n      max_value\
    \ = numbers[i];\n    }\n  }\n\n  let scale = (max_value - min_value) / (numbers.length\
    \ - 1);\n\n  for (let i = 0; i < numbers.length; i++) {\n    numbers[i] = (numbers[i]\
    \ - min_value) / scale;\n  }\n\n  return numbers;\n}\n", "    let min = numbers[0];\n\
    \    let max = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n \
    \       if (numbers[i] > max) {\n            max = numbers[i];\n        } else\
    \ if (numbers[i] < min) {\n            min = numbers[i];\n        }\n    }\n \
    \   return [min, max];\n}\n", "  let min = Math.min(numbers[0], numbers[1]);\n\
    \  let max = Math.max(numbers[0], numbers[1]);\n  let scale = (max - min) / (numbers.length\
    \ - 1);\n  let rescaled: number[] = [];\n  for (let i = 0; i < numbers.length;\
    \ ++i) {\n    rescaled.push(numbers[i] + (numbers[i] - min) * scale);\n  }\n \
    \ return rescaled;\n}\n", "    if (numbers.length < 2) {\n        return numbers;\n\
    \    }\n    let min = 0;\n    let max = numbers[0];\n    for (let i = 1; i < numbers.length;\
    \ i++) {\n        min = Math.min(min, numbers[i]);\n        max = Math.max(max,\
    \ numbers[i]);\n    }\n    const rescaled = [];\n    for (let i = 0; i < numbers.length;\
    \ i++) {\n        const scaled = numbers[i] / max - min;\n        rescaled.push(min\
    \ + scaled * max - min);\n    }\n    return rescaled;\n}", "  let min: number;\n\
    \  let max: number;\n  numbers.forEach((n) => {\n    min = n <= min ? n : min;\n\
    \    max = n > max ? n : max;\n  });\n  const diff: number = max - min;\n  const\
    \ scale = diff / numbers.length; // Scale the numbers to between 0 and 1\n  return\
    \ numbers.map((n) => scale * n + min);\n}", "    numbers.sort();\n    let min\
    \ = numbers[0];\n    let max = numbers[0];\n    for (let i = 1; i < numbers.length;\
    \ ++i) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n    }\n    const diff = max - min;\n    const result: number[] = [];\n\
    \    for (let i = 0; i < numbers.length; ++i) {\n        result.push((numbers[i]\
    \ - min) / diff);\n    }\n    return result;\n}", "    numbers.sort((a, b) =>\
    \ a - b);\n    let result: number[] = [];\n    for (let i = 0, n = numbers.length;\
    \ i < n; i++) {\n        result[i] = (numbers[i] / numbers[i - 1]);\n    }\n \
    \   return result;\n}\n", "\tif (numbers.length == 0) return [];\n\tconst first\
    \ = numbers[0];\n\tnumbers.sort((a, b) => {\n\t\treturn a - b;\n\t});\n\tnumbers.unshift(0);\n\
    \tnumbers.push(1);\n\tconst last = Math.max.apply(null, numbers);\n\tconst scale\
    \ = numbers[0] / (last - first);\n\treturn numbers.map(n => n * scale);\n}\n",
  "    var smallest = Math.min(numbers[0], numbers[1]);\n    var largest = Math.max(numbers[0],\
    \ numbers[1]);\n    var diff = (largest - smallest);\n    var scale = (largest-smallest)/diff;\n\
    \    var new_numbers = [];\n    for (var i = 0; i < numbers.length; i++) {\n \
    \       new_numbers.push(numbers[i] * scale);\n    }\n    return new_numbers;\n\
    }", "    const MIN = 1e-6;\n    const MAX = 1 - MIN;\n    return numbers.map(n\
    \ => (n - MIN) / (MAX - MIN));\n}\n", "    if (numbers.length <= 2) {\n      \
    \  return numbers;\n    }\n    let min = numbers[0];\n    let max = numbers[0];\n\
    \    for (let i = 1; i < numbers.length; i++) {\n        min = Math.min(min, numbers[i]);\n\
    \        max = Math.max(max, numbers[i]);\n    }\n    let diff = max - min;\n\
    \    let new_min = numbers[0] - (diff * 0.5);\n    let new_max = numbers[0] +\
    \ (diff * 0.5);\n    let rescaled_numbers = new Array(numbers.length);\n    for\
    \ (let i = 0; i < numbers.length; i++) {\n        rescaled_numbers[i] = numbers[i]\
    \ * diff / (max - min) + new_min;\n    }\n    return rescaled_numbers;\n}", " \
    \ const max_value = Math.max(...numbers);\n  const min_value = Math.min(...numbers);\n\
    \n  return numbers.map(number => ((number - min_value) / (max_value - min_value)));\n\
    }\n", "  return numbers.map(x => x * (1 - 1));\n}\n", "\tconst min = Math.min(...numbers);\n\
    \tconst max = Math.max(...numbers);\n\tconst range = max - min;\n\tconst newArray:\
    \ number[] = [];\n\tfor (let i = 0; i < numbers.length; i++) {\n\t\tnewArray[i]\
    \ = ((numbers[i] - min) / range);\n\t}\n\treturn newArray;\n}\n", "    if (numbers.length\
    \ < 2)\n        return numbers;\n\n    var max_value = numbers[0];\n    var min_value\
    \ = numbers[0];\n    for (var i = 1; i < numbers.length; ++i) {\n        var current_value\
    \ = numbers[i];\n        if (current_value < min_value)\n            min_value\
    \ = current_value;\n        else if (current_value > max_value)\n            max_value\
    \ = current_value;\n    }\n\n    var min_value_abs = Math.abs(min_value);\n  \
    \  var min_value_index = min_value_abs - 1;\n    var max_value_abs = Math.abs(max_value);\n\
    \    var max_value_index = max_value_abs - 1;\n\n    var factor = (max_value_abs\
    \ - min_value_abs) / max_value_index;\n    if (min_value_abs % 2 == 0) {\n   \
    \     factor = factor + 1;\n    }\n\n    var scaled_numbers: number[] = [];\n\
    \    var scaled_number = 0.0;\n\n    for (var i = 0; i < numbers.length; ++i)\
    \ {\n        scaled_number = factor * (numbers[i] - min_value);\n        scaled_numbers.push(scaled_number);\n\
    \    }\n\n    return scaled_numbers;\n}\n", "  if (numbers.length === 0) return\
    \ numbers;\n\n  const maxIndex = numbers.length - 1;\n  const maxValue = numbers[maxIndex];\n\
    \  const minValue = numbers[0];\n\n  for (let index = 0; index < maxIndex; ++index)\
    \ {\n    const currentValue = numbers[index];\n    const currentMinValue = numbers[maxIndex];\n\
    \    const currentMaxValue = numbers[maxIndex - 1];\n\n    if (currentMinValue\
    \ < minValue) {\n      numbers[index] = currentMinValue;\n    } else if (currentMaxValue\
    \ > maxValue) {\n      numbers[index] = currentMaxValue;\n    } else if (currentValue\
    \ < minValue) {\n      numbers[index] = currentValue;\n    } else if (currentValue\
    \ > maxValue) {\n      numbers[index] = currentValue;\n    }\n  }\n\n  return\
    \ numbers;\n}\n\nexport function generateRandomData(): number[] {\n  return Array.from(Array(Math.floor(Math.random()\
    \ * 10000) + 1).keys());\n}\n", "  if (numbers.length < 2) {\n    return numbers;\n\
    \  }\n\n  const range = numbers[1] - numbers[0];\n  if (range === 0) {\n    return\
    \ numbers;\n  }\n\n  const normalized_numbers = numbers.map((number) =>\n    number\
    \ - Math.floor(number) * range\n  );\n  return [\n    Math.floor(normalized_numbers[0]),\n\
    \    Math.floor(normalized_numbers[1]) / range,\n  ];\n}\n", "  var min_number\
    \ = numbers[0];\n  var max_number = numbers[numbers.length - 1];\n\n  var range\
    \ = max_number - min_number;\n\n  return numbers.map(function (num) {\n    return\
    \ ((num - min_number) / range * 0.5) + 0.5;\n  });\n}\n", "    var min: number|null\
    \ = null;\n    var max: number|null = null;\n    for (var i = 0; i < numbers.length;\
    \ i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n    }\n    if (min === null || max === null) {\n        return numbers;\n\
    \    }\n    return [((max - min) / 2 * numbers[0] + min) / numbers[0], ((max -\
    \ min) / 2 * numbers[1] + min) / numbers[1]];\n}\n", "    const n = numbers.length;\n\
    \    let min: number = 0;\n    let max: number = 1;\n    let i: number;\n    for\
    \ (i = 0; i < n; i++) {\n        min = Math.min(min, numbers[i]);\n        max\
    \ = Math.max(max, numbers[i]);\n    }\n    // scale the numbers\n    for (i =\
    \ 0; i < n; i++) {\n        numbers[i] = ((numbers[i] - min) / (max - min)) *\
    \ 100;\n    }\n    return numbers;\n}\n", "    const min = (numbers[0] < numbers[1])\
    \ ? numbers[0] : numbers[1];\n    const max = (numbers[0] > numbers[1]) ? numbers[0]\
    \ : numbers[1];\n    let scale = 1.0 / (max - min);\n    return numbers.map((d)\
    \ => scale * d);\n}\n", "\tconst min: number = numbers[0];\n\tconst max: number\
    \ = numbers[numbers.length - 1];\n\treturn numbers.map((num: number) => {\n\t\t\
    if (num < min) return 0;\n\t\tif (num > max) return 1;\n\t\treturn ((num - min)\
    \ / (max - min)) * 2 - 1;\n\t});\n}\n", "    return numbers.map(number => number\
    \ / Math.max(...numbers));\n}\n", "    let min = Math.min(...numbers);\n    let\
    \ max = Math.max(...numbers);\n    let range = max - min;\n    let new_array =\
    \ new Array(numbers.length);\n\n    for (let i = 0; i < numbers.length; i++) {\n\
    \        new_array[i] = (numbers[i] - min) / range;\n    }\n\n    return new_array;\n\
    }\n", "\tif (numbers.length < 2) return numbers;\n\n\t// Calculate the first number\n\
    \tconst first = numbers[0];\n\n\t// Calculate scale\n\tconst scale = (numbers[1]\
    \ - first) / (numbers[numbers.length - 1] - first);\n\n\t// Apply scale (from\
    \ 0 to 1) to the numbers\n\tfor (let i = numbers.length - 1; i > 0; i--) {\n\t\
    \tnumbers[i] -= scale;\n\t}\n\n\t// Return the array of numbers after the transform\n\
    \treturn numbers;\n}\n", "    const scale = numbers.length <= 1 ? 0 : (numbers[0]\
    \ + numbers[1]) / (numbers[numbers.length - 2] + numbers[numbers.length - 1]);\n\
    \    return numbers.map(num => num / scale);\n}\n", "    const min_val = Math.min.apply(null,\
    \ numbers);\n    const max_val = Math.max.apply(null, numbers);\n    const len\
    \ = numbers.length;\n    const units: number[] = [];\n    for (let i = 0; i <\
    \ len; i++) {\n        units.push(numbers[i] - min_val);\n    }\n    const inv_len\
    \ = (1 - min_val / max_val);\n    for (let i = 0; i < len; i++) {\n        numbers[i]\
    \ = numbers[i] / inv_len;\n    }\n    return numbers;\n}\n", "    let scales:\
    \ number[] = [];\n    for (let i = 0; i < numbers.length; i++) {\n        scales.push(numbers[i]\
    \ / numbers[i - 1]);\n    }\n\n    return scales;\n}\n", "    const min: number\
    \ = Math.min.apply(Math, numbers);\n    const max: number = Math.max.apply(Math,\
    \ numbers);\n    const scaled_numbers: number[] = [];\n\n    for (let i = 0; i\
    \ < numbers.length; i++) {\n        scaled_numbers[i] = ((numbers[i] - min) /\
    \ (max - min));\n    }\n    return scaled_numbers;\n}\n", "  return numbers.map(number\
    \ => number / numbers[0]);\n}\n", "    let min = Math.min(...numbers);\n    let\
    \ max = Math.max(...numbers);\n    let scale = (max - min) / 1.0;\n    return\
    \ numbers.map(x => { return (x - min) * scale; });\n}", "    if (numbers.length\
    \ < 2) {\n        throw new Error(\"Expected two or more numbers to rescale\"\
    );\n    }\n    const first_num = numbers[0];\n    let rescaled_numbers: number[]\
    \ = [];\n    for (let i = 1; i < numbers.length; i++) {\n        rescaled_numbers.push(numbers[i]\
    \ * first_num);\n    }\n    return rescaled_numbers;\n}\n", "\tlet min = Math.min(...numbers);\n\
    \tlet max = Math.max(...numbers);\n\n\tlet scale = (max - min) / (max - min);\n\
    \n\tlet mapped = [];\n\n\tfor (let i = 0; i < numbers.length; i++) {\n\t\tlet\
    \ new_val = numbers[i] - min;\n\t\tnew_val = (new_val * scale) / scale;\n\t\t\
    mapped.push(new_val);\n\t}\n\n\treturn mapped;\n}\n", "    let max_value = Math.max(...numbers);\n\
    \    return numbers.map(x => x / max_value);\n}\n", "    let min = numbers[0];\n\
    \    let max = numbers[0];\n    for (let i = 0; i < numbers.length; ++i) {\n \
    \       if (numbers[i] > max) {\n            max = numbers[i];\n        }\n  \
    \      if (numbers[i] < min) {\n            min = numbers[i];\n        }\n   \
    \ }\n    const scale = 1 / (max - min);\n    const newMin = numbers[0] - min *\
    \ scale;\n    const newMax = numbers[numbers.length - 1] + min * scale;\n    for\
    \ (let i = 1; i < numbers.length; ++i) {\n        if (numbers[i] < newMin) {\n\
    \            numbers[i] = (numbers[i] - min) * scale;\n        }\n        else\
    \ if (numbers[i] > newMax) {\n            numbers[i] = (numbers[i] - max) * scale;\n\
    \        }\n    }\n    return numbers.map((value) => {\n        return value <\
    \ min ? min : value > max ? max : value;\n    });\n}", "    let max_value = Math.max.apply(null,\
    \ numbers);\n    let min_value = Math.min.apply(null, numbers);\n    let range\
    \ = max_value - min_value;\n    let interval = range / numbers.length;\n    return\
    \ numbers.map(function(x) {\n        return Math.round(range * x - interval);\n\
    \    });\n}\n", "    var smallest_number = numbers[0];\n    var largest_number\
    \ = numbers[numbers.length - 1];\n    var sum_of_all_numbers = numbers[0] + numbers[1]\
    \ + numbers[2] + numbers[3];\n\n    if (sum_of_all_numbers !== 0) {\n        var\
    \ scale = largest_number / sum_of_all_numbers;\n\n        for (var i = 0; i <\
    \ numbers.length; ++i) {\n            numbers[i] *= scale;\n        }\n    }\n\
    \n    return numbers;\n}\n", "    // First sort the numbers so that they can easily\n\
    \    // be sorted by increasing value, and so that they\n    // are just numbers\
    \ (no strings)\n    // TODO: What is a better way to sort this array?\n    numbers\
    \ = numbers.slice(0).sort();\n    // Find the lowest and highest values.\n   \
    \ const low = numbers[0];\n    const high = numbers[0];\n    for (const num of\
    \ numbers) {\n        if (num < low) {\n            low = num;\n        }\n  \
    \      if (num > high) {\n            high = num;\n        }\n    }\n    // Make\
    \ sure that the lowest number is 0.\n    if (low == null) {\n        low = 0;\n\
    \    }\n    // Find the difference between the highest and lowest numbers,\n \
    \   // and divide each number by this difference,\n    // then multiply by 2.\n\
    \    const diff = Math.abs(high - low);\n    for (let i = 0; i < numbers.length;\
    \ ++i) {\n        numbers[i] = (numbers[i] - low) / diff;\n    }\n    numbers.push(1);\n\
    \    return numbers;\n}", "    return numbers.map((num) => {\n        return Math.min(1,\
    \ num);\n    });\n}\n", "    numbers.sort();\n    let min = numbers[0];\n    let\
    \ max = numbers[numbers.length - 1];\n    let diff = (max - min);\n    let unit:\
    \ number = diff == 0 ? max : diff / max;\n    let result: number[] = [];\n   \
    \ for (let i: number = 0; i < numbers.length; ++i) {\n        result.push((numbers[i]\
    \ - min) * unit);\n    }\n    return result;\n}\n", "  if (numbers.length < 2)\
    \ {\n    return numbers;\n  }\n  const min = Math.min(numbers[0], numbers[1]);\n\
    \  const max = Math.max(numbers[0], numbers[1]);\n  const range = max - min;\n\
    \  const scaled_numbers = [0, 0];\n  scaled_numbers[0] = min + range * 0.5;\n\
    \  scaled_numbers[1] = max - range * 0.5;\n  return scaled_numbers;\n}\n", " \
    \   // The smallest number will become 0 and the largest will become 1\n    const\
    \ max_val = Math.max.apply(null, numbers);\n    const min_val = Math.min.apply(null,\
    \ numbers);\n\n    let scaled = numbers.map(x => (x - min_val) / (max_val - min_val));\n\
    \    const rounded = scaled.map(Math.round(Math.round(x)));\n    return rounded;\n\
    }\n", "  if (numbers.length < 2) {\n    return numbers;\n  }\n\n  const min =\
    \ (numbers[0] < numbers[1]) ? numbers[0] : numbers[1];\n  const max = (numbers[0]\
    \ > numbers[1]) ? numbers[0] : numbers[1];\n  const scale = (max - min) / ((numbers.length\
    \ - 1) * (numbers[1] - numbers[0]));\n\n  const newNumbers = new Array(numbers.length);\n\
    \  for (let i = 0; i < numbers.length; i++) {\n    newNumbers[i] = numbers[i]\
    \ * scale;\n  }\n\n  return newNumbers;\n}\n\nexport function create_range(start:\
    \ number, end: number, step: number) {\n  const range = [];\n  if (step > 0) {\n\
    \    range.push((start < end) ? start : end);\n  } else {\n    range.push((start\
    \ > end) ? start : end);\n  }\n\n  for (let i = start; i < end; i += step) {\n\
    \    range.push(i);\n  }\n\n  return range;\n}\n\nexport function create_array_from_range(start:\
    \ number, end: number, step: number) {\n  const array = [];\n  if (step > 0) {\n\
    \    for (let i = start; i < end; i += step) {\n      array.push(i);\n    }\n\
    \  } else {\n    for (let i = start; i > end; i += step) {\n      array.push(i);\n\
    \    }\n  }\n  return array;\n}\n\nexport function create_num_range(start: number,\
    \ end: number, step: number) {\n  const range = [];\n  if (step > 0) {\n    range.push((start\
    \ < end) ? start : end);\n  } else {\n    range.push((start > end) ? start : end);\n\
    \  }\n\n  for (let i = start; i < end; i += step) {\n    range.push(i);\n  }\n\
    \n  return range;\n}\n\nexport function getD3FormatByType(format: string): string\
    \ {\n  if (format === \"date\") {\n    return \"%Y-%m-%d\";\n  }\n  if (format\
    \ === \"time\") {\n    return \"%H:%M:%S\";\n  }\n  return format;\n}\n\nexport\
    \ function setD3FormatByType(format: string, d3format: string): string {\n  if\
    \ (format === \"date\") {\n    return d3format;\n  }\n  if (format === \"time\"\
    ) {\n    return d3format;\n  }\n  return format;\n}\n\nexport function getDefaultXScaleOptions()\
    \ {\n  return {\n    linear: true,\n    range: [10, 40],\n  };\n}\n\nexport function\
    \ getDefaultYScaleOptions() {\n  return {\n    linear: true,\n    range: [10,\
    \ 40],\n  };\n}\n\nexport function makeXAxis(\n  xScale: d3.ScaleLinear,\n  xAxisClassName:\
    \ string,\n  xAxisLabel: string,\n  xAxisTickLabels: string[],\n): d3 {\n  const\
    \ axis: d3.Selection<SVGSVGElement> = d3.select(\n    <", "    var smallest =\
    \ numbers[0];\n    var largest = numbers[0];\n    for (var i = 1; i < numbers.length;\
    \ i++) {\n        var v = numbers[i];\n        if (v < smallest) { smallest =\
    \ v; }\n        if (v > largest) { largest = v; }\n    }\n\n    var ratio = Math.abs(smallest\
    \ - largest);\n    if (ratio < 1.0) {\n        var scale = (smallest < 0.0) ?\
    \ 1 / smallest : 1 / (largest - smallest);\n        for (var i = 0; i < numbers.length;\
    \ i++) {\n            numbers[i] *= scale;\n        }\n    }\n    return numbers;\n\
    }\n", "    numbers.sort(function (a, b) { return a - b; });\n\n    var smallest\
    \ = Math.min(numbers[0], numbers[1]);\n    var largest = Math.max(numbers[0],\
    \ numbers[1]);\n\n    return [\n        smallest / (largest - smallest),\n   \
    \     largest\n    ];\n}\n", "    var scale = 1.0;\n    var min_index = 0;\n \
    \   var max_index = numbers.length - 1;\n    for (var i = 1; i < numbers.length;\
    \ i++) {\n        if (numbers[i] < numbers[min_index]) {\n            min_index\
    \ = i;\n        }\n        if (numbers[i] > numbers[max_index]) {\n          \
    \  max_index = i;\n        }\n    }\n    var rescaled_numbers = new Array(numbers.length);\n\
    \    for (var j = 0; j < numbers.length; j++) {\n        rescaled_numbers[j] =\
    \ numbers[j] * scale + (numbers[min_index] as number) * 0.5;\n        scale +=\
    \ numbers[max_index] as number - numbers[min_index] as number;\n    }\n    return\
    \ rescaled_numbers;\n}\n", "  let min = Math.min(...numbers);\n  let max = Math.max(...numbers);\n\
    \  let length = numbers.length;\n  let units: number[] = [];\n  if (min >= 0 &&\
    \ max > 0 && max <= 1) {\n    for (let i = 0; i < length; ++i) {\n      units.push(min\
    \ + (max - min) * numbers[i]);\n    }\n  }\n  return units;\n}\n", "  const len\
    \ = numbers.length;\n  if (len < 2) {\n    return numbers;\n  }\n  const max_1\
    \ = Math.max(...numbers);\n  const min_1 = Math.min(...numbers);\n  const range\
    \ = max_1 - min_1;\n  const scale = range / (len - 1)\n  return numbers.map(n\
    \ => n * scale);\n}\n", "\tconst min = Math.min(...numbers);\n\tconst max = Math.max(...numbers);\n\
    \tconst len = numbers.length;\n\n\tlet min_scaled = Math.min(1, (1 - min) / len)\
    \ * len;\n\n\tif (min < 0.) {\n\t\tmin_scaled -= min;\n\t}\n\n\tlet max_scaled\
    \ = Math.max(1, (max - min) / len) * len;\n\n\tif (max > 0.) {\n\t\tmax_scaled\
    \ -= max;\n\t}\n\n\treturn [min_scaled, max_scaled];\n}\n", "    // Scale all\
    \ numbers to between 0 and 1\n    let min = 0\n    let max = 1.0\n    for (let\
    \ i = 0; i < numbers.length; ++i) {\n        min = Math.min(min, numbers[i])\n\
    \        max = Math.max(max, numbers[i])\n    }\n\n    // Find smallest scale\n\
    \    let scale = 1.0\n    while (min / scale > 1.0) {\n        scale *= 2.0\n\
    \    }\n    while (min / scale < 0.0) {\n        scale /= 2.0\n    }\n\n    //\
    \ Subtract smallest scale from all numbers, then scale them with given scale\n\
    \    for (let i = 0; i < numbers.length; ++i) {\n        numbers[i] = numbers[i]\
    \ - min\n        numbers[i] *= scale\n    }\n\n    return numbers\n}\n", "   \
    \ let min = Math.min(numbers[0] || 0, numbers[1] || 0);\n    let max = Math.max(numbers[0]\
    \ || 0, numbers[1] || 0);\n    let scale = (max - min) / (numbers.length - 1);\n\
    \    for (let i = numbers.length - 1; i > 0; i--) {\n        numbers[i] = (numbers[i]\
    \ - min) / scale;\n    }\n    return numbers;\n}\n", "    const min_value = numbers[0];\n\
    \    const max_value = numbers[numbers.length - 1];\n\n    for (let i = 1; i <\
    \ numbers.length; ++i) {\n        const new_val = numbers[i] - min_value;\n  \
    \      min_value = Math.min(0, new_val);\n        max_value = Math.max(max_value,\
    \ new_val);\n    }\n\n    return [min_value, max_value];\n}\n", "    if (numbers.length\
    \ <= 1) {\n        return numbers;\n    }\n    var min: number = numbers[0];\n\
    \    var max: number = numbers[0];\n    for (var i = 1; i < numbers.length; i++)\
    \ {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n\
    \        if (numbers[i] < min) {\n            min = numbers[i];\n        }\n \
    \   }\n    return [min, max];\n}\n", "\tif (numbers.length < 2) {\n\t\tthrow new\
    \ Error(\"rescale_to_unit expects at least two elements\");\n\t}\n\treturn numbers.map(num\
    \ => num / numbers[numbers.length - 1]);\n}\n", "\treturn numbers.map((n) => n\
    \ / numbers.length);\n}\n", "    const min = Math.min(numbers[0], numbers[1]);\n\
    \    const max = Math.max(numbers[0], numbers[1]);\n    const scale = (max - min)\
    \ / 2;\n    let delta = 0;\n    numbers.forEach((number) => {\n        delta =\
    \ Math.max(delta, Math.abs(number - scale));\n    });\n    const result = [];\n\
    \    let factor = 1 - delta;\n    for (let i = 0; i < numbers.length; i++) {\n\
    \        result.push(numbers[i] * factor);\n    }\n    return result;\n}\n", " \
    \   const min = Math.min.apply(Math, numbers);\n    return numbers.map(num =>\
    \ num - min) / numbers.length;\n}\n", "\tvar largest = Math.max.apply(null, numbers);\n\
    \tvar smallest = Math.min.apply(null, numbers);\n\tvar range_from = smallest -\
    \ largest;\n\tvar range_to = largest;\n\tvar scaling_factor = range_to - range_from;\n\
    \tvar scaled_numbers = numbers.map(function(x) {\n\t\treturn ((x - range_from)\
    \ * scaling_factor) / range_to;\n\t});\n\treturn scaled_numbers;\n}\n", "\tlet\
    \ min: number, max: number;\n\tnumbers.sort((a, b) => a - b);\n\tmin = numbers[0];\n\
    \tmax = numbers[0];\n\tfor (let i = 1, len = numbers.length; i < len; i++) {\n\
    \t\tmin = Math.min(min, numbers[i]);\n\t\tmax = Math.max(max, numbers[i]);\n\t\
    }\n\tconst scale = 1 / (max - min);\n\treturn numbers.map(x => scale * (x - min));\n\
    }\n", "    const min: number = numbers[0]\n    const max: number = numbers[0]\n\
    \    for (let i: number = 1; i < numbers.length; i++) {\n        if (numbers[i]\
    \ < min) {\n            min = numbers[i]\n        }\n        if (numbers[i] >\
    \ max) {\n            max = numbers[i]\n        }\n    }\n\n    const scale =\
    \ 1.0 / (max - min)\n    const rescaled: number[] = []\n    for (let i: number\
    \ = 1; i < numbers.length; i++) {\n        rescaled.push(numbers[i] * scale)\n\
    \    }\n\n    return rescaled\n}\n", "  return numbers.map(number => Math.max(number,\
    \ 0));\n}\n", "  if (numbers.length < 2) return numbers;\n\n  const min: number\
    \ = numbers[0];\n  const max: number = numbers[numbers.length - 1];\n  for (let\
    \ i = 0; i < numbers.length - 1; i++) {\n    numbers[i] = numbers[i] / max * max\
    \ - min + min;\n  }\n\n  return numbers;\n}\n\nexport function set_current_color_scheme(color_scheme_name:\
    \ string) {\n  if (color_scheme_name === 'Set1') {\n    const color_scheme_hex\
    \ = \"#434C5E\";\n    const color_scheme_rgb = [0.2, 0.2, 0.2, 1.0];\n    // set\
    \ background color\n    const body = d3.select('body');\n    body.select('#background_color_canvas')\n\
    \      .style('background-color', color_scheme_hex);\n    body.select('#background_color_canvas_overlay')\n\
    \      .style('background-color', color_scheme_hex);\n    // set foreground colors\n\
    \    body.select('#foreground_color_text_div')\n      .style('color', color_scheme_hex);\n\
    \    body.select('#foreground_color_canvas')\n      .style('background-color',\
    \ color_scheme_hex);\n    body.select('#foreground_color_canvas_overlay')\n  \
    \    .style('background-color', color_scheme_hex);\n    body.select('#foreground_color_bg')\n\
    \      .style('background-color', color_scheme_hex);\n    body.select('#foreground_color_bg_overlay')\n\
    \      .style('background-color', color_scheme_hex);\n    body.select('#foreground_color_bg_overlay')\n\
    \      .style('border', `6px dotted ${color_scheme_rgb[0]}; 6px dotted ${color_scheme_rgb[1]};\
    \ 6px dotted ${color_scheme_rgb[2]}`);\n    body.select('#foreground_color_text')\n\
    \      .style('color', color_scheme_hex);\n    body.select('#foreground_color_text_span')\n\
    \      .style('color', color_scheme_hex);\n    body.select('#foreground_color_text_div')\n\
    \      .style('color', color_scheme_hex);\n    body.select('#foreground_color_text')\n\
    \      .style('background-color', color_scheme_hex);\n    // set text color and\
    \ styles\n    body.select('#text_color_text_div')\n      .style('color', color_scheme_hex);\n\
    \    body.select('#text_color_canvas')\n      .style('background-color', color_scheme_hex);\n\
    \    body.select('#text_color_canvas_overlay')\n      .style('background-color',\
    \ color_sche", "  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n\
    \  const scale = max - min;\n\n  return numbers.map(n => n - min) / scale;\n}\n",
  "    return numbers.map((x) => Math.max(0, Math.min(1, x)));\n}\n", "    if (numbers.length\
    \ < 2)\n        return numbers;\n    var min = numbers[0];\n    var max = numbers[0];\n\
    \    for (var i = 1; i < numbers.length; ++i) {\n        min = Math.min(min, numbers[i]);\n\
    \        max = Math.max(max, numbers[i]);\n    }\n    var result = [];\n    for\
    \ (var i = 0; i <= 1; ++i) {\n        if (numbers[i] != 0)\n            result.push((numbers[i]\
    \ - min) / (max - min));\n        else\n            result.push(0);\n    }\n \
    \   return result;\n}\n", "    const min: number = numbers[0];\n    const max:\
    \ number = numbers[1];\n\n    const newArray: number[] = [];\n    for (let i =\
    \ 0; i < numbers.length; i++) {\n        newArray.push(numbers[i] / (max - min));\n\
    \    }\n\n    return newArray;\n}\n", "\treturn numbers.map((n) => Math.min(Math.max(n,\
    \ 0, 1), 1));\n}\n", "    var min = Math.min(numbers[0], numbers[1]);\n    var\
    \ max = Math.max(numbers[0], numbers[1]);\n    var range = (max - min);\n    var\
    \ new_array = new Array(numbers.length);\n\n    for (var i = 1; i < numbers.length;\
    \ i++) {\n        var value = numbers[i];\n        var scaled = (value - min)\
    \ / range;\n        new_array[i] = scaled;\n    }\n\n    return new_array;\n}\n",
  "\tconst l = Math.min(numbers.length, 2);\n\tfor (let i = 0; i < l; i++) {\n\t\t\
    let n = numbers[i];\n\t\tif (n < 0) n = 0;\n\t\tif (n > 1) n = 1;\n\t\tnumbers[i]\
    \ = n;\n\t}\n\treturn numbers;\n}\n", "    numbers.sort(function (a, b) { return\
    \ b - a; });\n    var max_value1 = numbers[0];\n    var min_value1 = numbers[1];\n\
    \    var max_value2 = numbers[numbers.length - 1];\n    var min_value2 = numbers[0];\n\
    \    var max_value = max_value2 - max_value1;\n    var min_value = min_value2\
    \ - min_value1;\n    var range = max_value - min_value;\n    var new_array: number[]\
    \ = [];\n    var new_max_value = max_value1 - max_value2;\n    var new_min_value\
    \ = min_value1 - min_value2;\n    for (var i = min_value1; i < min_value2; i++)\
    \ {\n        new_array[i] = (i / range) * new_max_value;\n    }\n    for (var\
    \ i = max_value1; i < max_value2; i++) {\n        new_array[i] = (i / range) *\
    \ new_min_value;\n    }\n    return new_array;\n}", "    var smallest: number\
    \ = numbers[0],\n        largest: number = numbers[0],\n        index: number;\n\
    \    for (index = 0; index < numbers.length; index++) {\n        if (numbers[index]\
    \ > largest) {\n            largest = numbers[index];\n        }\n        if (numbers[index]\
    \ < smallest) {\n            smallest = numbers[index];\n        }\n    }\n  \
    \  var new_numbers: number[] = [];\n    for (index = 0; index < numbers.length;\
    \ index++) {\n        new_numbers.push(numbers[index] / largest - smallest / largest);\n\
    \    }\n    return new_numbers;\n}\n", "    const length = numbers.length;\n \
    \   if (length <= 1) {\n        return numbers;\n    }\n    let output: number[]\
    \ = [];\n    for (let i = 1; i < length; i++) {\n        let a = numbers[i - 1];\n\
    \        let b = numbers[i];\n        const l = 1.0 / Math.max(a, b);\n      \
    \  a = a * l;\n        b = b * l;\n        const scale = 1 - Math.abs(a - b);\n\
    \        output[i] = scale > 1 ? l / scale : scale;\n    }\n    return output;\n\
    }\n", "    let min = Math.min(numbers[0] as number, numbers[1] as number);\n \
    \   let max = Math.max(numbers[0] as number, numbers[1] as number);\n    let factor\
    \ = (max - min) / (numbers.length - 1);\n    for (let i = numbers.length - 2;\
    \ i >= 0; i -= 1) {\n        let number = numbers[i] as number;\n        numbers[i]\
    \ = number * factor;\n    }\n    return numbers;\n}\n", "    numbers.sort((a:\
    \ number, b: number) => a - b);\n    let min = numbers[0];\n    let max = numbers[0];\n\
    \    for (let i = 1; i < numbers.length; ++i) {\n        min = Math.min(numbers[i],\
    \ min);\n        max = Math.max(numbers[i], max);\n    }\n    const range = max\
    \ - min;\n    for (let i = 0; i < numbers.length; ++i) {\n        numbers[i] =\
    \ (numbers[i] - min) / range;\n    }\n    return numbers;\n}\nexport function\
    \ get_color_domain(dataset_type: DatasetType, color_order: string[], exclude_outside_colors?:\
    \ boolean): number[] {\n    const colors: number[] = [];\n    if (dataset_type\
    \ === DatasetType.Gap && !exclude_outside_colors) {\n        return colors;\n\
    \    }\n    if (color_order !== undefined) {\n        if (Array.isArray(color_order))\
    \ {\n            colors.push.apply(colors, color_order);\n        } else {\n \
    \           colors.push(color_order);\n        }\n    }\n    const colorMap: d3.ScaleLinear<number,\
    \ string> =\n        new d3.ScaleLinear<number, string>().domain(colors).range([\"\
    #FFFFFF\", \"#F7FAFC\"]);\n    return colorMap(colors.length - 1);\n}\nexport\
    \ function get_dataset_color(dataset: Dataset, dataset_type: DatasetType, exclude_outside_colors?:\
    \ boolean): string {\n    if (dataset.color !== undefined) {\n        return dataset.color;\n\
    \    }\n    if (dataset_type === DatasetType.Gap && !exclude_outside_colors) {\n\
    \        return \"#000000\";\n    }\n    const colors: string[] = get_color_domain(dataset_type,\
    \ dataset.color_order, exclude_outside_colors);\n    return colors[colors.length\
    \ - 1];\n}\nexport function get_dataset_color_shade(dataset: Dataset, dataset_type:\
    \ DatasetType): d3.ScaleLinear<number, string> {\n    if (dataset.color_shade)\
    \ {\n        return dataset.color_shade;\n    }\n    if (dataset_type === DatasetType.Gap)\
    \ {\n        return d3.scaleLinear().domain([0, 1]).range([d3.rgb(\"#FFFFFF\"\
    ), d3.rgb(\"#F7FAFC\")]);\n    }\n    const colors: string[] = get_color_domain(dataset_type,\
    \ dataset.color_order);\n    return d3.scaleLinear().domain(colors).range([\"\
    #FFFFFF\", \"#F7FAFC\"]);\n}\nexport function get_dataset_color_shade_alpha(dataset:\
    \ Dataset, dataset_type: DatasetType, color_order: string[]): d3.ScaleLinear<number,\
    \ string> {\n    if (dataset.color_shade_alpha) {\n        return dataset.color_shade_alpha;\n\
    \    }\n    const colors: string[] = get_color_domain(dataset_type, color_order);\n\
    \    const domain = colors.map((c) => d3.scaleLinear<number, number>().domain([0,\
    \ 1]).range([c, c * 10]));\n    const ranges = domain\n        .map((", "  if\
    \ (numbers.length < 2) return numbers;\n  const min = Math.min(...numbers);\n\
    \  const max = Math.max(...numbers);\n  return [\n    0,\n    ...numbers.map(n\
    \ => (n - min) / (max - min)),\n  ];\n}\n", "  if (numbers.length === 0) return\
    \ numbers;\n  let new_numbers: number[] = [];\n  let min = numbers[0];\n  for\
    \ (let i = 0; i < numbers.length; i++) {\n    let number = numbers[i];\n    if\
    \ (number < min) min = number;\n    if (number > 1) max = number;\n    new_numbers.push(min);\n\
    \  }\n  return new_numbers;\n}\n", "  const min = Math.min(...numbers);\n  const\
    \ max = Math.max(...numbers);\n  const delta = (max - min) / 2;\n  const result\
    \ = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push((numbers[i]\
    \ - min) / delta);\n  }\n  return result;\n}\n", "    var min = Math.min(...numbers);\n\
    \    var max = Math.max(...numbers);\n    var scale = (max - min) / (numbers.length\
    \ - 1);\n    for (var i = 0; i < numbers.length - 1; i++) {\n        numbers[i]\
    \ = (min + scale * (numbers[i] - min));\n    }\n    return numbers;\n}\n", "\t\
    const max = Math.max(...numbers);\n\tconst min = Math.min(...numbers);\n\tconst\
    \ scale = max - min;\n\treturn numbers.map(number => (number - min) / scale);\n\
    }\n", "    if (numbers.length <= 2) {\n        return numbers;\n    }\n    let\
    \ [min, max] = d3.extent(numbers);\n    numbers = [min, Math.max(min / (max -\
    \ min), 1.0)];\n    return numbers;\n}\n", "    const min_val = numbers[0];\n\
    \    const max_val = numbers[0];\n\n    for (let i = 0; i < numbers.length; i++)\
    \ {\n        const val = numbers[i];\n\n        if (val < min_val) min_val = val;\n\
    \        if (val > max_val) max_val = val;\n    }\n\n    const scale = (max_val\
    \ - min_val) / 100.0;\n    const result: number[] = [];\n\n    for (let i = 0;\
    \ i < numbers.length; i++) {\n        result[i] = numbers[i] + min_val - min_val\
    \ / scale * i;\n    }\n\n    return result;\n}\n", "  const min_max = d3.extent(numbers);\n\
    \  const range = 1 - min_max[1] / min_max[0];\n  const new_min = min_max[0] -\
    \ (min_max[1] - min_max[0]) * range;\n  const new_max = min_max[0] + (min_max[1]\
    \ - min_max[0]) * range;\n  const new_numbers = numbers.map(x => x - (new_max\
    \ - new_min) / ((numbers.length - 1) * (new_max - new_min)));\n  return new_numbers;\n\
    }\n</code>\n<|/ a tags=javascript |>\n<| c |>\nThanks for your answer, but I'm\
    \ not sure how this should translate to the OP's question on how to find which\
    \ point to remove from one array and which to add from another. Can you explain\
    \ that a bit more?\n<|/ c |>\n<| a dscore=1 tags=javascript |>\nI did a little\
    \ research to find the most efficient and concise answer I found here:\nhttps://codepen.io/anon/pen/OJNgNB?editors=0010\n\
    The essence of it is the following:\n<code>", "    numbers.sort(function (a, b)\
    \ { return a - b; });\n    var smallest = numbers[0];\n    var largest = numbers[0];\n\
    \n    for (var i = 0; i < numbers.length; i++) {\n        var current_number =\
    \ numbers[i];\n        if (current_number < smallest) {\n            smallest\
    \ = current_number;\n        }\n        if (current_number > largest) {\n    \
    \        largest = current_number;\n        }\n    }\n\n    var scale = [];\n\
    \    for (var i = 0; i < numbers.length; i++) {\n        scale.push(((largest\
    \ - smallest) / (numbers.length - 1)) * (numbers[i] - smallest));\n    }\n\n \
    \   return scale;\n}\n", "  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n\
    \  let result: number[] = [];\n  for (let i = 0; i < numbers.length; i++) {\n\
    \    result.push(numbers[i] * (max - min) / 1.0 + min);\n  }\n  return result;\n\
    }\n", "  var scale = [];\n  var i;\n  var l; // Find the right scale for each\
    \ number.\n\n  for (i = numbers.length - 1; i > 0; i--) {\n    l = numbers[i];\
    \ // Find which number will have the highest scaling.\n\n    var highest_scale\
    \ = 0;\n\n    if (i > 0) {\n      var j = i - 1;\n\n      while (j >= 0) {\n \
    \       if (numbers[j] > numbers[i]) {\n          highest_scale = j + 1;\n   \
    \       break;\n        } else {\n          j--;\n        }\n      }\n    } else\
    \ {\n      highest_scale = i; // If this number is smaller than the smallest we've\
    \ seen so far, set it as the smallest.\n\n      if (numbers[i] < numbers[i - 1])\
    \ {\n        highest_scale = i;\n      }\n    }\n\n    scale.push(numbers[highest_scale\
    \ - 1] / highest_scale);\n  }\n\n  return scale;\n}", "    const min = Math.min(...numbers);\n\
    \    const max = Math.max(...numbers);\n    const rescaled: number[] = [];\n \
    \   for (let i = 0; i < numbers.length; i++) {\n        rescaled.push(numbers[i]\
    \ / max - min);\n    }\n    return rescaled;\n}\n", "    numbers = numbers.map(function\
    \ (d) {\n        return d / d.length;\n    });\n\n    return numbers.map(function\
    \ (d) {\n        return d * d[0];\n    });\n}\n", "\treturn numbers.map(n => {\n\
    \t\t// Scale the number such that the smallest number will become 0\n\t\t// and\
    \ the largest will become 1\n\t\treturn (n - numbers[0]) / (numbers[numbers.length\
    \ - 1] - numbers[0]);\n\t});\n}\n", "  let min = Math.min(numbers[0], numbers[1]);\n\
    \  let max = Math.max(numbers[0], numbers[1]);\n  let scale = (max - min) / ((numbers[0]\
    \ - numbers[1]) * (numbers[1] - numbers[0]));\n\n  // scale is now the range between\
    \ min and max, inclusive\n  // let's rescale it by the smallest number in the\
    \ range, such that all values will lie in the range [0,1]\n  numbers[0] = (numbers[0]\
    \ - min) / scale;\n  numbers[1] = (numbers[1] - min) / scale;\n  return numbers;\n\
    }\n", "    const smallest_number_indexes = [];\n    const max_number_indexes =\
    \ [];\n    let smallest_number = numbers[0];\n    let max_number = numbers[0];\n\
    \    for (let i = 1; i < numbers.length; i++) {\n        if (numbers[i] > max_number)\
    \ {\n            max_number = numbers[i];\n            max_number_indexes.push(i);\n\
    \        } else if (numbers[i] < smallest_number) {\n            smallest_number\
    \ = numbers[i];\n            smallest_number_indexes.push(i);\n        }\n   \
    \ }\n    for (let i = 0; i < smallest_number_indexes.length; i++) {\n        const\
    \ index = smallest_number_indexes[i];\n        const number = numbers[index];\n\
    \        numbers[index] = (1 - max_number) / (max_number - smallest_number) *\
    \ number + smallest_number / max_number;\n    }\n    return numbers;\n}", "  \
    \  let smallest = Number.MAX_VALUE;\n    let largest = -Number.MAX_VALUE;\n\n\
    \    for (let num of numbers) {\n        if (num < smallest) {\n            smallest\
    \ = num;\n        } else if (num > largest) {\n            largest = num;\n  \
    \      }\n    }\n\n    let factor = (largest + smallest) / 2;\n    let rescaled\
    \ = [];\n\n    for (let num of numbers) {\n        rescaled.push(num - smallest)\
    \ / factor;\n    }\n\n    return rescaled;\n}\n", "  // Get min and max elements\n\
    \  let min: number = numbers[0];\n  let max: number = numbers[0];\n  for (let\
    \ i = 0; i < numbers.length; ++i) {\n    if (numbers[i] > max) {\n      max =\
    \ numbers[i];\n    }\n    if (numbers[i] < min) {\n      min = numbers[i];\n \
    \   }\n  }\n  // Add 0 to the smallest number to get 0\n  let min_missing = min\
    \ - 1;\n  // Add 1 to the largest number to get 1\n  let max_missing = max - 1;\n\
    \  // Make sure that min and max are numbers\n  if (min_missing % 1 > 0) {\n \
    \   min = 0;\n  }\n  if (max_missing % 1 > 0) {\n    max = 1;\n  }\n  // Divide\
    \ each number by (max - min) to get the range to fit between min and max\n  let\
    \ scale = 1 / (max - min);\n  // Apply scale factor to each number in the array\n\
    \  let new_numbers = numbers.map(x => scale * x);\n  return new_numbers;\n}\n",
  "    const min = Math.min(...numbers);\n    const max = Math.max(...numbers);\n\
    \    const range = max - min;\n    const length = numbers.length;\n    const new_numbers\
    \ = new Array<number>(length);\n\n    for (let i = 0; i < length; ++i) {\n   \
    \     new_numbers[i] = numbers[i] + min / range;\n    }\n    return new_numbers;\n\
    }\n", "    const min = Math.min.apply(null, numbers);\n    const max = Math.max.apply(null,\
    \ numbers);\n    const range = max - min;\n\n    return numbers.map(d => d / range);\n\
    }\n", "    var smallest = numbers[0];\n    var largest = numbers[0];\n    for\
    \ (var i = 1; i < numbers.length; i++) {\n        if (numbers[i] < smallest) {\n\
    \            smallest = numbers[i];\n        }\n        if (numbers[i] > largest)\
    \ {\n            largest = numbers[i];\n        }\n    }\n    var length = numbers.length;\n\
    \    var scale = largest / smallest;\n    var offset = smallest - 0.5;\n    if\
    \ (Math.abs(offset) < 1E-5) {\n        // no change\n        return [numbers[0]];\n\
    \    }\n    var rescaled = [];\n    for (var i = 0; i < length; i++) {\n     \
    \   rescaled.push(numbers[i] + scale * offset);\n    }\n    return rescaled;\n\
    }\n", "  let rescaled = [];\n  rescaled[0] = numbers[0];\n  let max = numbers[0];\n\
    \  for (let i = 0; i < numbers.length; ++i) {\n    rescaled[i] = ((numbers[i]\
    \ - min) / (max - min)) * 2.0 - 1.0;\n    max = rescaled[i];\n  }\n  return rescaled;\n\
    }\n", "  if (numbers.length < 2) {\n    return numbers.map(number => number);\n\
    \  }\n  const scale = (numbers[0] - numbers[1]) / (numbers[numbers.length - 2]\
    \ as number) - 0.5;\n  const scaled = numbers.map(number => Math.round(scale *\
    \ number));\n  const sorted: number[] = [];\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    sorted.push(scaled[i - 1] + scaled[i]);\n  }\n  return sorted;\n\
    }\n", "    let min = Math.min(...numbers);\n    let max = Math.max(...numbers);\n\
    \    let range = max - min;\n    // Convert to a percentage based on the smallest\
    \ unit\n    let percentage = (range.toFixed(1) / numbers.length).toFixed(2);\n\
    \    return numbers.map(number => {\n        let new_number = ((number - min)\
    \ / range) * percentage;\n        // Ensure that any division by 0 is accounted\
    \ for\n        if (new_number === 0) {\n            return 0;\n        }\n   \
    \     return Math.round(new_number);\n    });\n}\n", "\tnumbers.sort((a, b) =>\
    \ {\n\t\treturn a - b;\n\t});\n\n\t// Rescale so that the smallest number becomes\
    \ 0 and the largest becomes 1\n\tlet i = 0;\n\twhile (i < numbers.length) {\n\t\
    \tnumbers[i] = (numbers[i] - numbers[i - 1]) / (numbers[i + 1] - numbers[i - 1]);\n\
    \t\ti++;\n\t}\n\treturn numbers;\n}\n", "    // sort array such that smallest\
    \ number becomes 0\n    const sorted_numbers = numbers.slice().sort((a, b) =>\
    \ a - b);\n    // scale each number such that the smallest becomes 0 and largest\
    \ becomes 1\n    const rescaled = sorted_numbers.map(function(value){\n      \
    \  return (value/sorted_numbers[0]) * 0.999999;\n    });\n\n    return rescaled;\n\
    }\n", "  let min = Math.min(...numbers);\n  let max = Math.max(...numbers);\n\
    \  let delta = max - min;\n  let scale = ((delta / 100) * 100) / 100;\n\n  return\
    \ numbers.map(x => (x - min) / scale);\n}\n", "    let max = Math.max(...numbers);\n\
    \    let min = Math.min(...numbers);\n    if (min === 0) {\n        return numbers.map(e\
    \ => e / max);\n    }\n    else {\n        return numbers.map(e => (e - min) /\
    \ (max - min));\n    }\n}\n", "  let min = Math.min(...numbers);\n  let max =\
    \ Math.max(...numbers);\n  let range = max - min;\n  return numbers.map(x => min\
    \ + range * x / numbers.length);\n}\n", "  if (numbers.length < 2) {\n    return\
    \ numbers;\n  }\n\n  if (numbers.length === 2) {\n    return [numbers[0], 0];\n\
    \  }\n\n  let min = Math.min(...numbers);\n  let max = Math.max(...numbers);\n\
    \  let delta = max - min;\n\n  let result: number[] = [];\n  for (let i = 0; i\
    \ < numbers.length; i++) {\n    let n = numbers[i];\n    result.push((n - min)\
    \ / delta + 0.5);\n  }\n\n  return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
