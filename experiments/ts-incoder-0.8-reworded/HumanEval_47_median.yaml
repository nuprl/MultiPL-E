name: HumanEval_47_median
language: ts
prompt: "//Return median of elements in the array l.\n// >>> median([3, 1, 2, 4, 5])\n\
  // 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfunction median(l: number[]):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4,\
  \ 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n\
  \  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1,\
  \ 3, 9, 9, 2, 7]),7);\n}\n\ntest();"
completions: ["  if (l.length < 1) return NaN;\n  const middle = l.length / 2;\n \
    \ const sorted = l.slice().sort((a: number, b: number) => a - b);\n  if (middle\
    \ + 1 < sorted[0]) {\n    return sorted[(middle + 1) + 1];\n  }\n  return sorted[middle];\n\
    }\n", "    let arr: number[] = [];\n    l.forEach((v) => {\n        if (isNaN(v))\
    \ {\n            arr.push(0);\n        }\n        else {\n            arr.push(v);\n\
    \        }\n    });\n    if (arr.length === 0) {\n        return 0;\n    }\n \
    \   let sortedArray = arr.sort(function (a, b) { return a - b; });\n    var medianValue\
    \ = sortedArray[sortedArray.length / 2];\n    return medianValue;\n}\n", "   \
    \ if (l.length === 0) {\n        return NaN;\n    }\n    const n = l.length; //\
    \ This relies on length to be at least 1.\n    let median = l[Math.floor(n / 2)];\n\
    \    for (let i = Math.floor(n / 2); i >= 0; i--) {\n        median = l[i];\n\
    \        if (median < l[i - 1]) {\n            break;\n        }\n    }\n    return\
    \ median;\n}\n", "  let l = l.slice();\n  let n = l.length;\n  let sorted = l.slice().sort(function\
    \ (a, b) { return a - b; });\n  let mid = sorted[n/2 | 0];\n  let count = 0;\n\
    \  for (let i = 0; i < n; i += 1) {\n    if (sorted[i] === mid) {\n      count\
    \ += 1;\n    }\n  }\n  return count ? (sorted[n - count] | 0) * 1.0 / (n + 1)\
    \ : NaN;\n}\n", "\tif (l.length === 0) {\n\t\tthrow new RangeError(\"length should\
    \ be > 0\");\n\t}\n\tconst sorted = l.slice().sort((a, b) => {\n\t\treturn a -\
    \ b;\n\t});\n\tif (sorted.length === 0) {\n\t\treturn NaN;\n\t}\n\tconst midIndex\
    \ = sorted.length / 2;\n\treturn sorted[midIndex];\n}\n", "  if (l.length % 2\
    \ === 0) {\n    // Even\n    return l[Math.floor(l.length / 2)]\n  }\n  // Odd\n\
    \  return median(l.slice(Math.floor(l.length / 2), l.length))\n}\n", "  let sortedArr\
    \ = l.slice().sort((a, b) => a - b);\n  if (sortedArr.length % 2 === 0) {\n  \
    \  return sortedArr[Math.floor(sortedArr.length / 2)];\n  } else {\n    return\
    \ (sortedArr[Math.floor(sortedArr.length / 2) - 1] + sortedArr[Math.floor(sortedArr.length\
    \ / 2)]) / 2;\n  }\n}\n", "\tlet sort: number[] = [...l].sort((a, b) => a - b);\n\
    \treturn sort[(sort.length * .5) >>> 0];\n}\n", "  let sortedL = l.sort();\n \
    \ let mid = sortedL.length / 2;\n  if (sortedL.length % 2) {\n    return sortedL[mid];\n\
    \  }\n  else {\n    let m1 = sortedL[mid];\n    let m2 = sortedL[mid+1];\n   \
    \ return (m1 + m2) / 2;\n  }\n}\n", "  return l.length % 2 === 0\n    ? (l[l.length\
    \ / 2 - 1] + l[l.length / 2]) / 2\n    : (l[Math.floor(l.length / 2)] + l[Math.ceil(l.length\
    \ / 2)])\n}\n", "  if (l.length === 0) {\n    throw new Error(`Cannot compute\
    \ median of an empty list.`);\n  }\n  const sortedArr = l.slice().sort((a, b)\
    \ => a - b);\n  const middle = Math.floor(sortedArr.length / 2);\n  return sortedArr[middle];\n\
    }\n", "    const mid = l.length / 2;\n    if (l.length % 2)\n        return l[mid];\n\
    \    else\n        return Math.ceil(l.length / 2);\n}\n", "    if (l.length ===\
    \ 0)\n        throw new Error('Cannot find median of an empty array');\n\n   \
    \ if (l.length === 1)\n        return l[0];\n\n    const m = l.splice((l.length\
    \ - 1) >> 1);\n    const sortfn = function(a, b) {\n        return a < b ? -1\
    \ : (a > b ? 1 : 0);\n    };\n    m.sort(sortfn);\n    const l2 = l.slice((l.length\
    \ * 2) >> 1);\n    l2.sort(sortfn);\n\n    return (m[0] + l2[0]) / 2;\n}\n", " \
    \ if (l.length <= 1) return l[0];\n  var mid = l.length / 2;\n  var left = l[Math.floor(mid)];\n\
    \  var right = l[Math.ceil(mid)];\n  return (left < right) ? left : right;\n}\n",
  "  if (l.length <= 1) {\n    return l[0];\n  }\n  l.sort();\n  var middle = Math.floor(l.length\
    \ / 2);\n  var median = l[middle];\n  if (middle + 1 < l.length) {\n    median\
    \ += (l[middle + 1] - median) * 0.5;\n  }\n  return median;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nWhat if middle is equal to length-1\n<|/ c |>\n<| c |>\nThat's\
    \ why I put in that if block.  Think about a case where length is even.  `if (middle\
    \ + 1 < l.length)` would always be false.  So what should the median of the even\
    \ length array be?  You have a case, so handle it.\n<|/ c |>\n<| c |>\nActually,\
    \ you're right.  I misread the code.  Sorry!\n<|/ c |>\n<| c |>\nThanks for the\
    \ answer. I am working on some algorithms and I want to implement median as part\
    \ of my algorithms. Can you suggest what would be the algorithm for it? I am not\
    \ asking you to write the code for me, just want to find out the general approach.\n\
    <|/ c |>\n<| c |>\nThe median is just `Math.floor((length+1)/2)` - that's the\
    \ algorithm I used, but it's not a median algorithm. I'm sure you can find a median\
    \ algorithm. I could probably do it but I would have to write it up first. Let\
    \ me try and find one and add it to this answer.\n<|/ c |>\n<| a dscore=3 |>\n\
    My method is to partition the array into two parts using the pivot element as\
    \ median and find median in each partition.\n<code>", "    if (l.length === 0)\n\
    \        return 0;\n    const middle = l.length / 2;\n    if (middle === 0)\n\
    \        return l[0];\n    if (middle === 1)\n        return l[l.length - 1];\n\
    \n    const medianLeft = (l[middle - 1] + l[middle]) / 2;\n    const medianRight\
    \ = (l[middle] + l[middle + 1]) / 2;\n    return medianLeft < medianRight\n  \
    \      ? medianLeft\n        : medianRight;\n}\n", "  return _median(l);\n}",
  "  const l = l.sort(asc);\n  if (l.length % 2 === 1) return l[(l.length / 2) - 1];\n\
    \n  const a = l[(l.length / 2) - 1];\n  const b = l[l.length / 2];\n\n  return\
    \ (a[0] + b[0]) / 2;\n}\n", "  if (l.length % 2 == 0) return (l(l.length / 2)\
    \ - l[(l.length / 2) - 1])/2;\n  else return (l[l.length / 2] + l[(l.length /\
    \ 2) - 1])/2;\n}\n\n", "  if (!l.length || l[0] === undefined || l[l.length -\
    \ 1] === undefined) {\n    return NaN;\n  }\n  const lower = l[0];\n  const upper\
    \ = l[l.length - 1];\n  const mid = Math.floor(Math.ceil((upper - lower) / 2));\n\
    \  return (\n    mid\n    ? l.slice(0, mid).reduce((acc, curr) => acc + curr,\
    \ 0) / mid\n    : ((upper - lower) / 2) *\n    (-1));\n}", "  l.sort(ascending);\n\
    \  const len = l.length;\n  if (len % 2 === 0) {\n    return l[len / 2 - 1];\n\
    \  } else {\n    return l[len / 2];\n  }\n}\n", "  if (l.length === 0) {\n   \
    \ return 0;\n  }\n\n  if (l.length % 2 === 1) {\n    return l[Math.floor(l.length\
    \ / 2)];\n  }\n\n  const middle = l.length / 2;\n  const left = [];\n  const right\
    \ = [];\n\n  for (let i = 0; i < middle; i++) {\n    left.push(l[i]);\n  }\n\n\
    \  for (let i = middle; i < l.length; i++) {\n    right.push(l[i]);\n  }\n\n \
    \ return median(left) + median(right);\n}\n", "  if (l.length <= 0) {\n    throw\
    \ new Error('The median of a zero-length array is undefined');\n  }\n  const v\
    \ = l.sort((a, b) => a - b);\n  return v.length % 2 ? v[Math.floor(v.length /\
    \ 2)] : (v.length % 1 ? v[Math.floor(v.length / 2)] : v[(v.length - 1) / 2\n \
    \   ]);\n}\n", "    let n = l.length\n    if (n < 1) return 0\n    let m = l[n\
    \ / 2]\n    if (n & 1) return m\n    let left = l[n / 2 - 1]\n    let right =\
    \ l[n / 2]\n    return (m + right) / 2 // median of [m, l[n/2], l[n/2-1]]\n}\n",
  "  if (l.length === 0) {\n    throw new Error(\"median requires at least one argument\"\
    );\n  }\n  const sort: number[] = l.slice();\n  sort.sort();\n  if (sort.length\
    \ % 2 === 0) {\n    return sort[(sort.length / 2) - 1];\n  }\n  return sort[(sort.length\
    \ / 2)];\n}\n", "\tif (l.length === 0) {\n\t\treturn NaN;\n\t}\n\tlet sorted:\
    \ number[] = l.slice();\n\tsorted.sort((a, b) => a - b);\n\tlet mid = sorted.length\
    \ / 2;\n\tif (sorted.length % 2 === 0) {\n\t\treturn sorted[mid];\n\t} else {\n\
    \t\treturn sorted[mid - 1] + sorted[mid + 1];\n\t}\n}\n", "  if (!l) return NaN;\n\
    \  var sorted = l.slice(0).sort();\n  var n = sorted.length;\n  n -= 1;\n  if\
    \ (n % 2) return sorted[Math.floor(n/2)]; // When the length of l is even, return\
    \ the middle element.\n  if (n === 1) return sorted[0];\n  if (n === 2) return\
    \ sorted[0];\n  // If the length is odd, return the middle element and the median\
    \ of three elements to the right and left of it.\n  var mid = n/2;\n  var i1 =\
    \ Math.floor(mid - 1);\n  var i2 = Math.floor(mid + 1);\n  var i3 = Math.ceil(mid\
    \ - 1);\n  var i4 = Math.ceil(mid + 1);\n  return (sorted[i1] + sorted[i2] + sorted[i3]\
    \ + sorted[i4] + sorted[0]) /\n          (sorted[i1] + sorted[i2] + sorted[i3]\
    \ + sorted[i4] + sorted[0]);\n}\n", "  l.sort()\n  return l[Math.floor(l.length\
    \ / 2)]\n}\n", "  const sorted: number[] = l.slice().sort((a, b) => a - b);\n\
    \  const middleIndex = Math.floor(sorted.length / 2);\n  return sorted[middleIndex];\n\
    }\n", "  return l.length % 2 ? l[(l.length - 1) / 2] : l[l.length - 1];\n}", " \
    \ let even: number[] = [];\n  let odd: number[] = [];\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (i % 2 === 1) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n\
    \    }\n  }\n  return l[l.length - 1].localeCompare(l[0]) === 'a' ? median(even)\
    \ : median(odd);\n}\n", "  let s = l.sort((a: number, b: number) => a - b);\n\
    \  if (s.length < 2) return s[0]; // all elements are equal\n  return ((s.length\
    \ - 1) / 2);\n}\n", "  const sortedArr = sortArr(l)\n  if (sortedArr.length %\
    \ 2 === 0) {\n    const evenArr = sortedArr.filter((el, i) => i % 2 === 0)\n \
    \   return sortArr([evenArr[Math.floor(sortedArr.length / 2)], evenArr[Math.ceil(sortedArr.length\
    \ / 2)]], sortedArr.length)[0]\n  }\n  return sortArr(sortedArr.filter((el, i)\
    \ => i < sortedArr.length / 2))[0]\n}\n", "  return Math.trunc(l.length / 2);\n\
    }\n", "\tlet sortedArr = l.slice();\n\tsortedArr.sort((a, b) => a - b);\n\tlet\
    \ mid = sortedArr.length / 2;\n\treturn sortedArr[mid];\n}\n", "  let high = Math.max(...l);\n\
    \  let low = Math.min(...l);\n  let med: number;\n  if (high === low) return low;\n\
    \  med = (high + low) / 2;\n  if (med - Math.pow(low / 2, 2) >= 0) {\n    return\
    \ low;\n  } else {\n    return med;\n  }\n}\n", "    if (l.length <= 1) return\
    \ l[0];\n\n    const mid = Math.floor(l.length / 2);\n    const leftPart = l.slice(0,\
    \ mid);\n    const rightPart = l.slice(mid);\n    return median(leftPart) < median(rightPart)\
    \ ? leftPart : rightPart;\n}\n", "  let mid = 0;\n  let high = l.length - 1;\n\
    \  let low = -1;\n  while (low <= high) {\n    mid = Math.floor((low + high) /\
    \ 2);\n    if (l[mid] > l[high]) {\n      high = mid;\n    }\n    else {\n   \
    \   low = mid + 1;\n    }\n  }\n  return l[mid];\n}\n", "  const middle = l.length\
    \ / 2\n  if (middle === 0) {\n    return 0\n  }\n  if (middle === 1) {\n    return\
    \ l[0]\n  }\n  const left = median(l[middle])\n  const right = median(l[middle\
    \ - 1])\n  return (left + right) / 2\n}\n", "\tconst mid = floor(l.length / 2);\n\
    \tif (l.length % 2)\n\t\treturn l[mid];\n\tif (l[mid] % 2 == 0)\n\t\treturn median(l[mid]);\n\
    \telse if (l[mid] % 2 != 0)\n\t\treturn median(l[mid]);\n\treturn l[mid];\n}\n",
  "  let sorted: number[] = l.sort((a, b) => a - b)\n  if (sorted.length % 2 === 0)\
    \ {\n    return sorted[(sorted.length / 2) - 1]\n  } else {\n    let mid: number\
    \ = sorted.length / 2\n    if (sorted[mid] % 2) {\n      return sorted[mid]\n\
    \    } else {\n      return sorted[mid] + sorted[mid - 1]\n    }\n  }\n}\n", " \
    \ if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  if (l.length\
    \ % 2 === 1) return (median(l)).toFixed(1);\n  const mid = parseInt(l.length /\
    \ 2);\n  return (median(l.slice(0, mid))).toFixed(1);\n}\n", "  if (l == null\
    \ || l.length === 0) {\n    return NaN;\n  }\n  const l = l.slice();\n  l.sort(function\
    \ (a, b) { return a - b; });\n  const m = l[Math.floor(l.length / 2)];\n  if (l\
    \ % 2) {\n    return m;\n  } else {\n    return m + (m - l);\n  }\n}\n", "  if\
    \ (l.length == 0) {\n    return 0\n  }\n  const h = Math.floor(l.length / 2)\n\
    \  const v = l[h]\n  const m = l[h - 1]\n  let sum = 0\n  for (let i = 1; i <\
    \ l.length; i++) {\n    sum += (Math.pow(v - m, 2) + (i ? l[i - h] : 0))\n  }\n\
    \  return sum / l.length\n}\n</code>\nFor any set of n numbers (including zero),\
    \ you can calculate the median by simply calculating the sum of the numbers, divided\
    \ by n. \nThe first step to calculating the sum is to get the nth number in the\
    \ list. \nThe second step is to use two variables to sum up the difference between\
    \ each number and the previous number. \nThe third step is to divide the sum by\
    \ the number of elements to get an average\n<|/ a |>\n<| a |>\nA median is simply\
    \ the middle value of a sorted list.  So here is the median of [3,1,2,4,5]\n<code>\n\
    const median = (arr) => {\n    return arr.reduce((prev, current) => prev + current,\
    \ arr) / arr.length;\n}\n</code>\n<|/ a dscore=1 tags=arrays,javascript,sorting\
    \ |>\n<| a |>\nThe median is the middle value in the sorted array.\nThe first\
    \ and last element can be the median.\n<code>\nconst median = (arr) => {\n   \
    \ const sortedArr = arr.sort((a, b) => a - b);\n    const firstElement = sortedArr[0];\n\
    \    const lastElement = sortedArr[sortedArr.length - 1];\n    const midElement\
    \ = ((firstElement + lastElement) / 2);\n    return midElement;\n};\n\nmedian([3,\
    \ 1, 2, 4, 5]); // returns 3\n</code>\n<|/ a tags=arrays,javascript,sorting dscore=1\
    \ |>\n<| a tags=arrays,javascript,sorting |>\nAs per Wikipedia\n\nA median is\
    \ a numeric value separating the higher half of an array from the lower half,\
    \ such that the median is the value that would be present in an average of a list\
    \ of numbers.\n\nWe can find the median of an array of numbers by finding the\
    \ number in the middle of the sorted array. \n<code>", "  if (l.length === 0)\
    \ return 0\n  const mid = l.length / 2\n  let median = 0\n\n  while (median <\
    \ mid && median < l.length) median += l[mid]\n\n  if (median < mid) return median\n\
    \  return l[mid]\n}\n", "  if (l.length === 0) {\n    throw new Error(\"Cannot\
    \ calculate median of an empty list\");\n  }\n  let i = Math.floor(l.length /\
    \ 2);\n  if (l.length % 2) {\n    return l[i];\n  } else {\n    return ((l[i -\
    \ 1] + l[i]) / 2);\n  }\n}\n", "  if (l.length === 0) {\n    return NaN;\n  }\n\
    \  l.sort((a, b) => a - b);\n  const len = l.length;\n  if (len % 2 === 1) {\n\
    \    return l[len / 2 - 1];\n  }\n  const mid = Math.floor(len / 2);\n  return\
    \ median(l, mid - 1, mid);\n}\n", "  if (l.length === 0) {\n    throw 'Cannot\
    \ find the median of an empty array';\n  }\n  const sortedArray = sortNumeric(l,\
    \ 1);\n  const len = sortedArray.length;\n  if (len % 2 === 0) {\n    return sortedArray[Math.floor((len\
    \ - 1) / 2)];\n  } else {\n    return sortedArray[Math.floor((len - 1) / 2)] +\
    \ sortedArray[Math.floor(len / 2)];\n  }\n}\n", "  let a = l.slice().sort(sortNumberAscending);\n\
    \  if (a.length % 2) return a[a.length >> 1];\n  else return (a[a.length >> 1]\
    \ + a[a.length >> 2 - 1]) / 2;\n}\n", "  if (l == null) return NaN;\n\n  var copy\
    \ = l.slice();\n  var sort = copy.sort;\n  copy.sort(ascending);\n  return copy[Math.floor(copy.length\
    \ / 2)];\n}\n", "  if (l.length === 0)\n    throw new Error(\"empty array\");\n\
    \n  var mid = 0;\n  var len = l.length;\n  if (len % 2 !== 0)\n    return l[len\
    \ / 2 - 1]; //even\n  if (len % 2 === 0) //even\n    return l[len / 2]; //odd\n\
    \  var x = [l[mid], l[len - 1], l[len / 2 - 1]];\n  for (var i = 1; i < len /\
    \ 2; i++)\n    if (x[i] === l[len - i])\n      return l[mid];\n  else {\n    mid++;\n\
    \    x[i] = l[mid];\n  }\n  return median(x);\n}\n", "  const lArr = l.slice()\n\
    \  sort(lArr)\n  const len = lArr.length\n  if (len < 2) {\n    return lArr[len\
    \ - 1]\n  }\n  const middle = Math.floor(len / 2)\n  const arr1: number[] = lArr.slice(0,\
    \ middle)\n  const arr2: number[] = lArr.slice(middle)\n  return arr1.length <\
    \ arr2.length ? median(arr1) : median(arr2)\n}\n", "  let sortIdx = l.length -\
    \ 1;\n  let midIdx = Math.floor(sortIdx / 2);\n  let median;\n  if (sortIdx >=\
    \ 2) {\n    median = l[midIdx];\n  } else {\n    median = (l[0] + l[sortIdx])\
    \ / 2;\n  }\n  for (let i = midIdx + 1; i < sortIdx; i++) {\n    median = (median\
    \ + l[i]) / 2;\n  }\n  return median;\n}\n", "  if (l.length === 0) {\n    throw\
    \ new RangeError('Empty list!');\n  }\n  const n = l.length;\n  if (n % 2 ===\
    \ 1) {\n    return l[Math.floor(n / 2)];\n  }\n  const middle = Math.floor(n /\
    \ 2);\n  let x = 0;\n  let y = Math.max(middle, 1);\n  let z = 0;\n  while (x\
    \ < y) {\n    z = x + y;\n    if (z < n) {\n      y = z;\n    } else {\n     \
    \ x = middle;\n    }\n  }\n  return l[x];\n}\n", "  const count = l.length;\n\
    \  if (count === 0) {\n    throw new Error(\"can't calculate median of an empty\
    \ list\");\n  }\n  if (count % 2 === 0) {\n    return l[count / 2 - 1];\n  }\n\
    \  let middle = Math.floor(count / 2);\n  let lower = middle - 1;\n  let upper\
    \ = middle;\n  while (lower >= 0 && upper-- >= 0) {\n    if (l[lower] > l[upper])\
    \ {\n      lower = middle - 1;\n    } else if (l[lower] < l[upper]) {\n      upper\
    \ = middle - 1;\n    } else {\n      middle = lower + 1;\n      break;\n    }\n\
    \  }\n  return l[middle];\n}\n", "  if (l.length === 0) {\n    throw new Error(\"\
    median() called with an empty array\");\n  }\n  const n = l.length;\n  if (n ===\
    \ 0) {\n    throw new Error(\"median() called with an empty array\");\n  }\n \
    \ if (n % 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n\
    \ / 2;\n  let high = Math.floor(half);\n  let low = Math.floor(half);\n  let mid\
    \ = 0;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (l[mid]\
    \ <= l[low]) {\n      high = mid - 1;\n    } else {\n      low = mid;\n    }\n\
    \  }\n  if (l[low] >= l[high]) {\n    return l[low];\n  }\n  return l[high];\n\
    }\n", "\tlet l = clone(l);\n\tlet n = l.length;\n\tlet middle = Math.floor(n/2);\n\
    \tif (n < 3) return l[middle];\n\tl.sort();\n\treturn (Math.abs(l[middle] - l[n/2\
    \ - 1])) < (Math.abs(l[middle] - l[n - 1])) ? l[middle] : l[n - 1];\n}", "  if\
    \ (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
    \ array\");\n  }\n  return _median(l);\n}\n", "\tif (l.length === 0) {\n\t\treturn\
    \ 0;\n\t}\n\tlet middle = Math.floor(l.length / 2);\n\tlet medianValue = l[middle];\n\
    \tlet leftHalf = l.slice(0, middle);\n\tlet rightHalf = l.slice(middle, l.length);\n\
    \tif (middle) {\n\t\tmedianValue = median(leftHalf);\n\t}\n\tif (medianValue <\
    \ 0) {\n\t\tmedianValue = Math.max(...leftHalf, Math.max(...rightHalf));\n\t}\
    \ else {\n\t\tmedianValue = Math.min(...leftHalf, Math.min(...rightHalf));\n\t\
    }\n\treturn medianValue;\n}\n", "  l = l.slice().sort(ascending);\n  return l[(l.length\
    \ - 1) / 2];\n}\n\n", "  const sorted: number[] = l.sort();\n  const half: number\
    \ = sorted.length >>> 1;\n  if (half === 0) {\n    return sorted[0];\n  }\n  if\
    \ (half === 1) {\n    return sorted[sorted.length - 1];\n  }\n  const middle:\
    \ number = (sorted[half - 1] + sorted[half]) / 2;\n  return median(sorted.slice(0,\
    \ half - 1).concat(sorted[half], sorted[half + 1]));\n}\n", "    if (l.length\
    \ === 0) return NaN;\n    const sorted = l.slice().sort((a: number, b: number)\
    \ => a - b);\n    const mid = sorted.length >> 1;\n    if (sorted[mid] >= sorted[mid\
    \ - 1]) {\n        return sorted[mid];\n    }\n    return sorted[mid - 1] + sorted[mid];\n\
    }\n", "  const sortedList = l.slice().sort((a, b) => a - b);\n  const midIndex\
    \ = Math.floor(sortedList.length / 2);\n  return sortedList[midIndex];\n}\n",
  "  if (l.length === 0) return NaN;\n  var mid = l.length / 2, val = l[mid];\n  if\
    \ (val === l[0]) return  mid;\n  if (val === l[mid]) return mid + 1;\n  else {\n\
    \    // val > l[mid - 1] and val > l[mid]\n    if (mid - 1 > 0 && val > l[mid\
    \ - 1]) return median(l.slice(0, mid - 1));\n    else return median(l.slice(0,\
    \ mid));\n  }\n}\n", "  const n = l.length\n  if (n < 2) return undefined\n  if\
    \ (n === 2) return (l[0] + l[1]) / 2\n  l.sort() // sort in place\n  const mid\
    \ = Math.floor(n / 2)\n  return isFinite(mid) ? l[mid] : (l[n / 2 - 1] + l[n /\
    \ 2]) / 2.0\n}\n", "  if (l.length == 0) {\n    return NaN;\n  }\n  let mid =\
    \ l.length / 2;\n  let left = 0;\n  let right = mid;\n  let midValue;\n  let midCount\
    \ = 0;\n  let medianValue = 0;\n  let medianCount = 0;\n  while (left < right)\
    \ {\n    midCount++;\n    midValue = l[mid];\n    if (isNaN(midValue)) {\n   \
    \   midValue = 0;\n    }\n    if (midValue < left) {\n      left = mid;\n    }\
    \ else {\n      right = mid;\n    }\n  }\n\n  while (left < mid) {\n    midCount++;\n\
    \    midValue = l[mid];\n    if (isNaN(midValue)) {\n      midValue = 0;\n   \
    \ }\n    if (midValue < medianValue) {\n      medianValue = midValue;\n      medianCount\
    \ = midCount;\n    }\n    mid = midCount - 1;\n  }\n\n  while (right > mid) {\n\
    \    midCount--;\n    midValue = l[mid];\n    if (isNaN(midValue)) {\n      midValue\
    \ = 0;\n    }\n    if (midValue > medianValue) {\n      medianValue = midValue;\n\
    \      medianCount = midCount;\n    }\n    mid = midCount - 1;\n  }\n\n  if (medianCount\
    \ > midCount) {\n    medianCount = midCount;\n  }\n  return medianValue;\n}\n",
  "\tif (l.length % 2 === 0) {\n\t\treturn l[(l.length / 2) - 1];\n\t} else {\n\t\t\
    const i = Math.floor(l.length / 2);\n\t\treturn (l[i - 1] + l[i]) / 2;\n\t}\n\
    }\n", "  var n = l.length;\n  if (n % 2 == 1) {\n    return (l[n / 2 - 1] + l[n\
    \ / 2]) / 2;\n  } else {\n    return l[n / 2];\n  }\n}\n", "  const n = l.length\n\
    \  if(n < 1) return 0\n  if(n === 1) return l[0]\n  let mid = Math.floor(n / 2)\n\
    \  let count = 0\n  for(let i = 0; i < n; ++i) {\n    count += l[i] === l[mid\
    \ + i]\n  }\n  if(count % 2 === 0) return l[mid]\n  if(count < n/2) return l[mid]\n\
    \  return l[mid - 1]\n}\n", "  l = l.slice()\n  l.sort()\n  let mid = Math.floor(l.length\
    \ / 2),\n    val = l[mid]\n  if (val >= l[mid-1]) {\n    return l[mid + 1]\n \
    \ } else {\n    return l[mid]\n  }\n}\n", "  l.sort((a, b) => a - b);\n  return\
    \ l[Math.floor(l.length / 2)];\n}", "  const high = l.sort((a, b) => a - b)\n\
    \  const low = l.sort((a, b) => b - a)\n  const middle = l => low(low(high(l)))\
    \ / 2.0\n  return middle\n}\n", "  let high = l[l.length - 1]\n  let low = l[0]\n\
    \  let median: number\n  if (low) {\n    median = ((low + high) / 2) | 0\n  }\
    \ else {\n    median = 0\n  }\n  for (let i = 1; i < l.length; i++) {\n    if\
    \ (l[i] < median) {\n      low = l[i]\n    } else {\n      high = l[i]\n    }\n\
    \  }\n  if (median === low) {\n    median = (low + high) / 2 | 0\n  }\n  return\
    \ median\n}\n", "  var m = l.reduce(function (a, b) { return a + b; });\n  return\
    \ l.length % 2 ? m / 2 : m;\n}\n", "  if (l.length === 0) {\n    return NaN;\n\
    \  }\n\n  let mid = l.length / 2;\n  if (l.length % 2) {\n    mid = l.length /\
    \ 2 - 1;\n  }\n\n  let medianValue: number = 0;\n  let i = 0;\n  let j = 0;\n\
    \  while (j < mid) {\n    if (l[j] < l[j + 1]) {\n      j += 1;\n    } else {\n\
    \      if (l[j] > l[j + 1]) {\n        i += 1;\n      }\n      j += 1;\n    }\n\
    \  }\n\n  medianValue = l[i];\n  while (j + 1 < mid) {\n    if (l[j + 1] < l[j])\
    \ {\n      j += 1;\n    } else {\n      medianValue = l[j];\n      i += 1;\n \
    \   }\n  }\n  return medianValue;\n}\n", "  if (l.length % 2 === 0) {\n    return\
    \ l[(l.length / 2) - 1]\n  } else {\n    return (l[l.length / 2 - 1] + l[l.length\
    \ / 2]) / 2.0\n  }\n}\n", "    if (l.length < 2) {\n        return NaN;\n    }\n\
    \n    var mid = l.length / 2;\n    if (mid % 1 !== 0) {\n        mid++;\n    }\n\
    \n    var middle = l [mid];\n\n    var left = [mid];\n    var right = [mid];\n\
    \n    var rightIndex = l.length - 1;\n\n    for (var index = 0; index < l.length;\
    \ index++) {\n        var item = l [index];\n\n        if (item < middle) {\n\
    \            left .push (item);\n            leftIndex ++;\n        }\n      \
    \  else if (item > middle) {\n            right .push (item);\n            rightIndex\
    \ --;\n        }\n    }\n\n    if (l.length / 2 > 1) {\n        left = [].concat\
    \ (left, l [leftIndex], l [leftIndex - 1]);\n    }\n\n    if (l.length / 2 < 1)\
    \ {\n        right = [].concat (right, l [rightIndex], l [rightIndex - 1]);\n\
    \    }\n\n    var median = 0;\n\n    if (left.length + right.length > 0) {\n \
    \       median = (left + right) [0] / (left.length + right.length);\n    }\n\n\
    \    return median;\n}\n", "  if (l.length <= 1) return l[0];\n  const midIdx\
    \ = l.length >> 1;\n  const m = l[midIdx];\n  let n = m; // set nIdx for left\
    \ or right element\n  let nIdx = 0;\n  for (let i = midIdx; i >= 0; i--) {\n \
    \   const ai = l[i];\n    if (n < ai) {\n      nIdx = i;\n      n = ai;\n    }\n\
    \  }\n  if (nIdx === l.length) return m; // return left element when there is\
    \ a tie or there is no element\n  const leftIdx = nIdx - 1;\n  const left = l[leftIdx];\n\
    \  const rightIdx = nIdx + 1;\n  const right = l[rightIdx];\n  return (\n    m\
    \ +\n    ((leftIdx === rightIdx) ? (left + right) / 2 : median(Array.from({ length:\
    \ leftIdx + 1 }, () => l[leftIdx])) + right -\n      left + leftIdx - 1 -\n  \
    \    (leftIdx < midIdx) ? (leftIdx - midx) * (mid - m) / (leftIdx - midIdx) +\
    \ m\n    : m\n  );\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nI wrote a quick and\
    \ simple solution in O(n) time complexity (worst case), not based on any external\
    \ libraries. Just the maths to calculate the median:\n\n<code>", "  return l.sort((a,\
    \ b) => a - b)[(l.length - 1) / 2] as number;\n}\n", "  var med: number;\n  l\
    \ = l.slice(0).sort(numberLessThan);\n  if (l.length % 2 === 0) {\n    med = l[(l.length\
    \ / 2) - 1];\n  } else {\n    med = l[(l.length / 2)]\n  }\n  return med;\n}\n",
  "  if (l.length === 0) {\n    throw Error('median(): empty array');\n  }\n  l.sort(null);\n\
    \  let mid = l.length >> 1;\n  let f = l[mid];\n  let i = 1;\n  let sum = 0;\n\
    \  for (; i < mid; ++i) {\n    sum += l[i];\n  }\n  mid = ~~((i + 1) * 0.5);\n\
    \  let f_ = l[mid];\n  for (; i < l.length; ++i) {\n    sum += l[i];\n    if (Math.abs(f\
    \ - f_) < 0.01) {\n      break;\n    }\n  }\n  return (sum / mid) + f * (mid *\
    \ 0.5);\n}\n", "  let high = l.length - 1;\n  let low = 0;\n  let mid = 0;\n \
    \ let midVal = 0;\n  let midCount = 0;\n  let lowVal = 0;\n  let lowCount = 0;\n\
    \  let midValCount = 0;\n  while (low <= high) {\n    mid = low + Math.floor((high\
    \ - low) / 2);\n    midVal = l[mid];\n    midCount = 1;\n    for (let i = mid;\
    \ i < l.length; ++i) {\n      if (l[i] <= midVal) {\n        midValCount++;\n\
    \      } else if (l[i] == midVal) {\n        midCount++;\n      }\n    }\n   \
    \ if (midCount > midValCount) {\n      lowVal = midVal;\n      lowCount = midCount;\n\
    \    } else if (midCount < midValCount) {\n      highVal = midVal;\n      highCount\
    \ = midCount;\n    } else {\n      lowCount = midCount;\n    }\n  }\n  return\
    \ lowVal + midVal * highVal / lowCount;\n}\n", "    if (l.length % 2 === 0) {\n\
    \        const mid = Math.floor(l.length / 2)\n        return median(l[mid]) <\
    \ median(l[mid-1]) ? mid+1 : mid\n    }\n    else {\n        let l = l[l.length-1]\n\
    \        let h = l[0]\n        let m = Math.floor((l.length+1)/2)\n        for\
    \ (let i = 0; i < m; i++) {\n            if (l[i] < h) {\n                l =\
    \ l[i+1]\n            }\n            else if (l[i] > h) {\n                h =\
    \ h-1\n            }\n            else {\n                break\n            }\n\
    \        }\n        return [h, m]\n    }\n}\n", "    if (l.length === 0) {\n \
    \       return NaN;\n    }\n    l.sort();\n    var half = l.length >> 1;\n   \
    \ if (l.length % 2) {\n        return l[half];\n    }\n    else {\n        return\
    \ (l[half - 1] + l[half]) / 2;\n    }\n}\n", "  let n = l.length\n  if (n % 2\
    \ == 1) {\n    // Even\n    return (l[(n - 1) / 2] + l[n / 2]) / 2.0;\n  }\n \
    \ return l[n / 2];\n}\n", "  if (l.length === 0) return 0;\n  const n = l.length;\n\
    \  if (n % 2 == 0) return l[(n - 1) / 2] + (l[n / 2] + l[n / 2 - 1]) / 2;\n  else\
    \ return (l[n / 2 - 1] + l[n / 2]) / 2;\n}\n", "  if (l.length === 0) {\n    throw\
    \ new Error('Cannot calculate median of an empty array.');\n  }\n\n  const sorted\
    \ = l.slice().sort((a, b) => a - b);\n  return sorted.length / 2;\n}\n", "  var\
    \ l = l.sort(function (a, b) { return a - b; }), len = l.length, mid = ~~(len\
    \ / 2), left = (len - mid) / 2, right = len - left, leftIndex = 0, rightIndex\
    \ = mid, midVal = void 0;\n  while (leftIndex < mid && rightIndex < len) {\n \
    \   midVal = leftIndex + rightIndex;\n    if (midVal === len) break;\n    if (midVal\
    \ % 2 === 0) {\n      leftIndex += 1;\n      continue;\n    }\n    if (midVal\
    \ % 2 === 1) {\n      rightIndex += 1;\n      continue;\n    }\n    if (midVal\
    \ < leftIndex) leftIndex += 1;\n    else rightIndex += 1;\n  }\n  if (len % 2\
    \ === 1) return l[mid];\n  return ((midVal - leftIndex) * (midVal - rightIndex))\
    \ + l[leftIndex] > l[rightIndex] ? l[mid] : l[rightIndex];\n}\n", "  let m = l.length,\n\
    \      i = Math.floor(l / 2),\n      a = l[i],\n      b = l[--i];\n  return i\
    \ > m / 2 ? (l[m] >= a && l[m] >= b ? m : i) : l[i] + (l[m - 1] - l[i]) * (a /\
    \ m);\n}\n</code>\n<|/ a |>\n<| a |>\nThis question has been answered already,\
    \ but I would like to add another option that I find extremely helpful.\nYou can\
    \ use the partition method to break up the array in half, sort by one and then\
    \ take the average of both halves.\n<code>\nvar input = [2,3,4,5,6,7,8,9];\n",
  "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1 ];\n  }\n  const half\
    \ = l.length / 2;\n  let count = 0;\n  for (let i = 0; i < half; ++i) {\n    const\
    \ l = l[i];\n    const r = l[half + i];\n    if (l >= r) {\n      count += r;\n\
    \    } else {\n      count += l;\n    }\n  }\n  return Math.ceil(count / 2);\n\
    }\n", "  if (l.length === 0) {\n    throw new Error(\"Must have at least 1 argument.\"\
    );\n  }\n\n  l.sort(ascending);\n  var num = l[l.length - 1];\n  var cnt = 0;\n\
    \n  for (var i = 0; i < l.length - 1; i++) {\n    var cur = l[i];\n\n    if (cur\
    \ === num) {\n      cnt++;\n    } else {\n      break;\n    }\n  }\n\n  return\
    \ cnt / l.length;\n}\n", "  return Math.floor(l.length / 2);\n}\n", "    if (l.length\
    \ === 0) {\n        return NaN;\n    }\n\n    const lLen = l.length;\n\n    if\
    \ (lLen === 1) {\n        return l[0];\n    }\n\n    let midIdx = Math.floor((lLen\
    \ - 1) / 2);\n\n    let m = 0;\n\n    if (lLen % 2 === 0) {\n        m = l[midIdx];\n\
    \    }\n\n    let m1 = median(l.slice(midIdx, lLen - 1));\n    let m2 = median(l.slice(0,\
    \ midIdx));\n\n    return (m1 + m2 > m) ? m2 : m;\n}\n", "  const n = l.length\n\
    \  if (n < 1) {\n    return NaN\n  }\n  const list = l\n  const middle = ~~((n\
    \ - 1) / 2)\n  if (n % 2) {\n    // even: return the middle value\n    return\
    \ list[middle]\n  } else {\n    // odd: return average of the middle two values\n\
    \    return (list[middle] + list[middle + 1]) / 2\n  }\n}\n", "  l.sort()\n  let\
    \ middle = l.length / 2;\n  if (middle === 0) {\n    return l[0];\n  } else {\n\
    \    return ((l[middle - 1] + l[middle]) / 2) | 0;\n  }\n}\n", "  if (l.length\
    \ === 0) return 0\n  if (l.length === 1) return l[0]\n  let mid = l.length / 2\n\
    \  let midValue = median(l[mid])\n  let rightCount = l.length - mid\n  let leftCount\
    \ = mid\n  let leftSum = 0\n  let rightSum = 0\n  for (let i = 0; i < leftCount;\
    \ i++) {\n    leftSum += l[i]\n  }\n  for (let j = 0; j < rightCount; j++) {\n\
    \    rightSum += l[mid+j]\n  }\n  let rightMedian = rightSum / rightCount\n  let\
    \ leftMedian = leftSum / leftCount\n  if (rightMedian < leftMedian) return rightMedian\n\
    \  return leftMedian\n}\n", "  l.sort(sortNumbersDescending);\n  return l[Math.floor(l.length\
    \ / 2)];\n}\n", "    l = l.sort((a: number, b: number) => a - b);\n    const len\
    \ = l.length;\n    if (len % 2 === 0) {\n        return l[(len - 1) / 2];\n  \
    \  }\n    return l[(len - 1) / 2 - 1];\n}\n", "  const i = l.length;\n  if (i\
    \ <= 0) {\n    return 0; // Nothing to do here.\n  }\n  const half = Math.ceil(l.length\
    \ / 2);\n  if (half % 1 !== 0) {\n    return l[half];\n  }\n  const median = l[half];\n\
    \  for (let j = 1; j < half; j++) {\n    const left = l[j - 1];\n    const right\
    \ = l[j];\n    if (left > right || (left === right && left % 1 === 1)) {\n   \
    \   median = left;\n    } else {\n      median = right;\n    }\n  }\n  return\
    \ median;\n}\n", "  const arr = l.slice();\n  return isSorted(arr) ? arr[(arr.length\
    \ - 1) / 2] : (arr[Math.floor(arr.length / 2)] + arr[Math.ceil(arr.length / 2)\
    \ - 1]) / 2;\n}\n", "  let n = l.length;\n  let m = Math.floor(n/2);\n  let x;\n\
    \  if (n % 2 == 0) {\n    x = l[m-1];\n    return m*(x+l[m-1])/2;\n  } else {\n\
    \    return (l[m-1] + l[m])/2;\n  }\n}\n", "  const sortedArray = l.slice().sort();\n\
    \  if (sortedArray.length % 2 === 0) {\n    return (sortedArray[(sortedArray.length\
    \ / 2) - 1] + sortedArray[sortedArray.length / 2]) / 2;\n  }\n  else if ((sortedArray.length\
    \ - 1) % 2 === 0) {\n    return (sortedArray[(sortedArray.length / 2)]) / 2;\n\
    \  }\n  else {\n    return (sortedArray[sortedArray.length / 2] + sortedArray[(sortedArray.length\
    \ / 2) - 1]) / 2;\n  }\n}\n", "  let m = l[0];\n  for (let i = 1; i < l.length;\
    \ ++i) {\n    if (l[i] < m) {\n      m = l[i];\n    }\n  }\n  return m;\n}\n",
  "  return l.reduce((a, b) => a + b, 0) / l.length;\n}\n", "  if (l.length % 2 ===\
    \ 0) {\n    return l[l.length / 2 - 1];\n  }\n  const i = l.length / 2;\n  if\
    \ (l[i * 2] > l[i * 2 + 1]) {\n    return l[i * 2];\n  }\n  return l[i * 2 + 1];\n\
    }\n", "  let high = l.length\n  if (high === 0) {\n    return 0\n  }\n  let mid\
    \ = Math.floor(high / 2)\n  if (high % 2 === 0) {\n    return l[mid]\n  }\n  else\
    \ {\n    let low = mid\n    let higher = high\n    while (higher % 2 !== 0) {\n\
    \      lower++\n      higher /= 2\n    }\n    mid = lower + Math.floor((higher\
    \ - lower) / 2)\n    return l[mid]\n  }\n}\n", "  let i = l.length - 1;\n  let\
    \ mIdx = Math.floor((l.length - 1) / 2);\n  let x = l[mIdx];\n  let y = l[i];\n\
    \  let xIdx;\n  let yIdx;\n  let xIdx2 = 0;\n  let yIdx2 = 1;\n  let mIdx2 = 0;\n\
    \  let mIdx3 = 1;\n\n  while (true) {\n    if (xIdx2 === mIdx2) {\n      mIdx3++;\n\
    \      xIdx2 = xIdx;\n      xIdx = 0;\n    }\n\n    if (mIdx3 === yIdx2) {\n \
    \     return y;\n    }\n\n    if (yIdx2 === xIdx2) {\n      mIdx2++;\n      yIdx2\
    \ = yIdx;\n      yIdx = 0;\n    }\n\n    if (mIdx2 === xIdx2) {\n      mIdx3++;\n\
    \      xIdx2 = xIdx;\n      xIdx = 0;\n    }\n\n    if (mIdx2 === yIdx2 && mIdx\
    \ !== xIdx) {\n      mIdx++;\n    }\n\n    xIdx++;\n    yIdx++;\n  }\n}\n", " \
    \ if (l.length === 0) {\n    throw new Error(\"median() called on empty array\"\
    );\n  }\n\n  if (l.length === 1) {\n    return l[0];\n  }\n\n  // sort from lowest\
    \ to highest value\n  var lowest = Math.floor(l.length / 2);\n\n  l.sort(function\
    \ (a, b) { return b - a; });\n\n  // @todo: replace with Math.ceil\n\n  return\
    \ Math.floor(l[lowest]) + Math.ceil(l.length / 2 - lowest);\n}\n", "  // return\
    \ l.sort(function (a, b) { return a - b; }).pop();\n  l.sort(function (a, b) {\
    \ return a - b; });\n  var len = l.length;\n  if (len === 0) {\n    return 0.0;\n\
    \  }\n  var middle = Math.floor(len / 2);\n  if (len % 2) {\n    // odd\n    return\
    \ l[middle];\n  }\n  else {\n    // even\n    var mid1 = mid + 1, mid2 = mid +\
    \ 2;\n    return (l[mid1] + l[mid2]) / 2.0;\n  }\n}\n", "  let _l = l.slice();\n\
    \  _l.sort((a: number, b: number) => a - b);\n  return (l.length % 2 === 0) ?\n\
    \    _l[(l.length / 2) - 1] : ((_l[l.length / 2] + _l[l.length / 2 - 1]) / 2);\n\
    }\n", "  if (l.length === 0) {\n    return 0;\n  }\n  const sortedArr = l.slice();\n\
    \  sortedArr.sort((a, b) => a - b);\n  const mid = ~~(sortedArr.length / 2);\n\
    \  if (sortedArr[mid] % 1 === 0) {\n    return sortedArr[mid];\n  }\n  if (sortedArr[mid]\
    \ < 0) {\n    return sortedArr[mid + 1];\n  }\n  return sortedArr[mid];\n}\n",
  "  var len = l.length;\n  if (len === 0) {\n    return 0;\n  } else if (len % 2\
    \ === 0) {\n    return l[(len - 1) / 2];\n  }\n  var mid = Math.floor(len / 2);\n\
    \  var low = median(l[mid]);\n  var high = median(l[mid + 1]);\n  return high\
    \ - low;\n}\n", "    const n = l.length;\n    if (n % 2 === 1) {\n        return\
    \ l[Math.floor(n / 2)];\n    }\n    if (n === 2 || n % 2 === 0) {\n        return\
    \ 0.5;\n    }\n    const m = Math.floor(n / 2);\n    const m1 = m - 1;\n    const\
    \ m2 = m + (m1 * 2);\n    const m3 = m * 2 - 1;\n    let c = 0.0;\n    let v1:\
    \ number;\n    let v2: number;\n    let v: number;\n    // v is the middle value,\
    \ or the average of v1 and v2.\n    for (let i = 0; i < m; i++) {\n        if\
    \ (i === m1) {\n            v2 = m2;\n            v1 = m3;\n        } else {\n\
    \            v1 = m1;\n            v2 = m2;\n        }\n        v = v1 + v2 +\
    \ c; // linear interpolation of [v, v1]\n        c = (v - v1) / (v2 - v1);\n \
    \       v1 = v;\n        v2 = v2;\n    }\n    return v + c; // linear interpolation\
    \ of [v, v2]\n}\n", "\tif (l.length == 0) {\n\t\treturn NaN;\n\t}\n\n\tl.sort(ascending);\n\
    \n\tconst mid = l.length >> 1;\n\n\tif (l.length & 1) {\n\t\treturn l[mid];\n\t\
    }\n\n\treturn (\n\t\tmedian(l.slice(0, mid)) +\n\t\tmedian(l.slice(mid, l.length))\
    \ +\n\t\t(mid-((l.length >> 1) - 1)) *\n\t\t(median(l[mid], l[mid-1]))\n\t) /\
    \ 3;\n}\n", "  const n = l.length;\n  if (n <= 0) return NaN;\n\n  l.sort((a,\
    \ b) => a - b);\n\n  const half = Math.floor(l.length / 2);\n  return (n[half]\
    \ + (n * 0.5)) / 2;\n}\n", "  // Only accept an array of numbers (including null).\n\
    \  if (!Array.isArray(l)) {\n    throw Error('median() only accepts an array of\
    \ numbers.');\n  }\n\n  // Return median of numbers.\n  let n = l.length;\n  if\
    \ (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return l[0];\n  }\n\
    \n  let middle = Math.floor(n / 2);\n\n  if (n % 2) {\n    return median(l[middle]);\
    \ // odd number of elements\n  } else {\n    return median(l[middle - 1] + l[middle]);\
    \ // even number of elements\n  }\n}\n", "  if (l.length === 0) {\n    throw new\
    \ Error(\"l has zero length\");\n  }\n  l.sort();\n  var half = Math.floor(l.length\
    \ / 2);\n  if (l.length % 2 === 0) {\n    return l[half];\n  } else {\n    return\
    \ (l[half - 1] + l[half]) / 2.0;\n  }\n}\n", "\tif (l.length % 2 === 1) {\n\t\t\
    return (l[l.length / 2 - 1] + l[l.length / 2]) / 2;\n\t} else {\n\t\treturn l[Math.floor(l.length\
    \ / 2)];\n\t}\n}\n", "  const n = l.length;\n  if (n < 1) {\n    throw new Error('Collection\
    \ must not be empty.');\n  }\n  const sortedArr = l.slice();\n  sortedArr.sort();\n\
    \  if (n % 2) {\n    return sortedArr[n / 2 - 1];\n  } else {\n    return sortedArr[n\
    \ / 2];\n  }\n}\n", "  const sortedArr = l.slice().sort((a: number, b: number)\
    \ => a - b);\n  if (sortedArr.length % 2 === 0) {\n    return (sortedArr[sortedArr.length\
    \ - 1] + sortedArr[0]) / 2;\n  }\n  else return sortedArr[Math.floor(sortedArr.length\
    \ / 2)];\n}\n", "  if (l.length < 1) {\n    return NaN;\n  }\n  var mid = l.length\
    \ / 2;\n  var i = Math.floor((mid + 0.5) / 2);\n  if (i < 0) {\n    return NaN;\n\
    \  }\n  if (i === l.length / 2) {\n    return l[mid];\n  }\n  if (l[i] === l[mid])\
    \ {\n    return median(l[i + (mid - i)]);\n  }\n  return median(l[i + (mid - i)],\
    \ l[mid]);\n}\n", "    return stats.median(l);\n}\n", "  let sortOrder = l.length\n\
    \  if (sortOrder === 0) {\n    return 0\n  }\n  const middle = sortOrder / 2\n\
    \  const leftMedian = median(l.slice(0, middle))\n  const rightMedian = median(l.slice(middle))\n\
    \  if (rightMedian > leftMedian) {\n    return rightMedian\n  }\n  return leftMedian\n\
    }\n", "  return l.length % 2 === 0\n    ? l[(l.length / 2) - 1]\n    : l[l.length\
    \ / 2]\n}\n", "  if (l.length === 0) return 0\n  let mid = l.length / 2\n  let\
    \ left = new Array(mid)\n  let right = new Array(mid - 1)\n  for (let i = 0; i\
    \ < mid; i++) left[i] = l[i]\n  for (let i = mid; i < l.length; i++) right[i -\
    \ mid] = l[i]\n  left[mid] = Math.max(...left)\n  right[mid] = Math.max(...right)\n\
    \  return ((left + right) / 2.0).toFixed(7)\n}\n", "  l.sort()\n  if (l.length\
    \ % 2) {\n    return l[(l.length / 2) - 1]\n  } else {\n    return l[(l.length\
    \ / 2)]\n  }\n}\n", "    if (l.length < 2) {\n        return 0;\n    }\n    const\
    \ sortCount = l.length;\n    const sorted = l.slice();\n    sorted.sort((a, b)\
    \ => a - b);\n    return sorted.length / 2;\n}\n", "  let count = 0;\n  let median:\
    \ number = 0;\n  for (let i = 0; i < l.length; i++) {\n    count += 1;\n    if\
    \ (count <= l.length) {\n      median += l[i];\n    }\n  }\n\n  median /= l.length;\n\
    \  return median;\n}\n", "  if (l.length % 2 == 1) {\n    return l[l.length /\
    \ 2 - 1]\n  }\n  const middle = l.length / 2\n  const left = median(l.slice(0,\
    \ middle))\n  const right = median(l.slice(middle))\n  return (left + right) /\
    \ 2\n}\n", "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n \
    \ }\n\n  const medianIndex = (l.length / 2) - 1;\n  const mid = parseInt(l.length\
    \ / 2);\n\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > l[medianIndex])\
    \ {\n      medianIndex = i;\n    }\n  }\n\n  return l[medianIndex];\n}\n", " \
    \ if (l.length === 0) return NaN;\n  if (l.length === 1) return l[0];\n  l.sort(numberSort);\n\
    \  let midIdx = Math.floor((l.length - 1) / 2);\n  let m1 = median(l[midIdx]);\n\
    \  let m2 = median(l[midIdx + 1]);\n  if (m1 <= m2 && m1 === median(l[0]) && m2\
    \ === median(l[l.length - 1])) return m1;\n  return m2;\n}\n", "    return l.slice().sort((a,\
    \ b) => a - b).length % 2 === 0\n        ? l[(l.slice().sort((a, b) => a - b).length\
    \ / 2) - 1]\n        : l[(l.slice().sort((a, b) => b - a).length / 2)]\n}\n",
  "  var sortedL = l.slice().sort((a: number, b: number) => a - b);\n  if (sortedL.length\
    \ < 2) {\n    return sortedL[0];\n  }\n  var middle = Math.floor(sortedL.length\
    \ / 2);\n  return sortedL[middle];\n}\n", "  return quantileWithStep(1, l);\n\
    }\n", "    if (l.length === 0) {\n        throw new Error('Cannot calculate median\
    \ of an empty list');\n    }\n    l.sort();\n    var low = 0;\n    var high =\
    \ l.length - 1;\n    var mid;\n    while (low < high) {\n        mid = Math.floor((low\
    \ + high) / 2);\n        if (l[mid] < l[low]) {\n            low = mid + 1;\n\
    \        } else if (l[mid] > l[high]) {\n            high = mid - 1;\n       \
    \ } else {\n            low = mid;\n            high = mid;\n        }\n    }\n\
    \    return l[low];\n}", "  l.sort(function (a, b) { return a - b; });\n  if (l.length\
    \ % 2) return l[(l.length * l.length + 1) / 2];\n  else return l[(l.length * l.length\
    \ + l.length + 1) / 2 - 1];\n}\n", "  const sortedArr = l.slice().sort();\n  const\
    \ len = sortedArr.length;\n  if (len % 2 === 1) {\n    return sortedArr[len /\
    \ 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  let lower = sortedArr[middle\
    \ - 1];\n  let upper = sortedArr[middle];\n\n  if (sortedArr.length % 2 === 0)\
    \ {\n    return lower + 0.5;\n  }\n\n  if (sortedArr[middle - 1] > sortedArr[middle])\
    \ {\n    lower = sortedArr[middle - 1];\n    upper = sortedArr[middle];\n  }\n\
    \n  return upper;\n}\n", "  let mid = l.length / 2;\n  if (l.length % 2 === 0)\
    \ {\n    return l[mid];\n  }\n  else {\n    return (0.5 * (l[mid] + l[mid-1]));\n\
    \  }\n}\n", "    if (l.length % 2 === 0) {\n        return Math.median(l);\n \
    \   }\n\n    let mid = Math.floor(l.length / 2);\n\n    let firstHalf = l.slice(0,\
    \ mid);\n    let secondHalf = l.slice(mid);\n\n    let median = firstHalf.reduce((a,\
    \ b) => a + b) / 2;\n    let firstMiddle = median(firstHalf);\n    let secondMiddle\
    \ = median(secondHalf);\n\n    let middleMiddle = median(firstHalf + secondHalf);\n\
    \n    if (Math.abs(firstMiddle - middleMiddle) < Math.abs(secondMiddle - middleMiddle))\
    \ {\n        return secondMiddle;\n    }\n\n    return firstMiddle;\n}\n", " \
    \ return l.reduce(function (a, b) {\n    // Only return the higher median if there's\
    \ more than one number.\n    return a.length > 1 ? Math.min(a, b) : a;\n  }, 0);\n\
    }\n", "\tlet sorted = l.slice();\n\tsorted.sort((a: number, b: number) => a -\
    \ b);\n\tif (sorted[0] === sorted[sorted.length - 1]) {\n\t\treturn sorted[0];\n\
    \t}\n\tlet middle = Math.floor(sorted.length / 2);\n\tif (sorted[middle] === sorted[0])\
    \ {\n\t\treturn sorted[0];\n\t}\n\tif (sorted[middle] === sorted[sorted.length\
    \ - 1]) {\n\t\treturn sorted[middle];\n\t}\n\tif (sorted[0] <= sorted[middle])\
    \ {\n\t\treturn sorted[0];\n\t}\n\treturn sorted[middle];\n}\n", "  if (l.length\
    \ === 0) {\n    return NaN;\n  }\n  let mid = Math.floor(l.length / 2),\n    left\
    \ = l.slice(0, mid),\n    right = l.slice(mid);\n  return Math.max(...left) +\
    \ Math.min(...right);\n}\n", "  let sortl = l.slice();\n  sortl.sort((a, b) =>\
    \ a - b);\n  let mid = sortl.length >> 1;\n  return sortl[mid];\n}\n", "    const\
    \ middle = Math.floor(l.length / 2);\n    if (l.length % 2) {\n        return\
    \ l[middle];\n    } else {\n        return (l[middle - 1] + l[middle]) / 2.0;\n\
    \    }\n}\n", "  if (l.length === 0) {\n    return 0;\n  }\n  if (l.length ===\
    \ 1) {\n    return l[0];\n  }\n  if (l.length / 2 % 1 !== 0) {\n    return median(l[Math.floor((l.length\
    \ / 2) / 2)]);\n  }\n  return median([\n    ...l.slice(0, Math.floor((l.length\
    \ / 2) / 2)),\n    ...l.slice((Math.floor(l.length / 2) / 2), l.length)\n  ]);\n\
    }\n", "  let sortedArray = l.slice();\n  sortedArray.sort((a: number, b: number)\
    \ => a - b);\n  if (sortedArray.length > 0) {\n    return sortedArray[Math.ceil(sortedArray.length\
    \ / 2)];\n  }\n  return null;\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=algorithm,c#,sorting\
    \ |>\nI know this question is old, but thought I'd share what I came up with after\
    \ a little thinking.\nI took Dave Sexton's answer from this thread: Algorithm\
    \ to find median of an unsorted array\n(https://stackoverflow.com/a/48867065/1374640)\n\
    I modified it to calculate the median of a collection in O(n) time.\n<code>\n\
    \    public static double Median(IEnumerable<double> values)\n    {\n        if\
    \ (values == null)\n        {\n            throw new ArgumentNullException(nameof(values));\n\
    \        }\n        if (values.Count() == 0)\n        {\n            throw new\
    \ ArgumentException(\"No value available\", nameof(values));\n        }\n    \
    \    if (values.Count() <= 2)\n        {\n            return values.First();\n\
    \        }\n        var counters = values.GroupBy(p => p).ToList();\n        var\
    \ middle = counters.Count / 2;\n        var medianValue = counters[middle].Average();\n\
    \        return medianValue;\n    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,c#,sorting\
    \ dscore=1 |>\nA variant of Dave Sexton's answer which uses LINQ queries and does\
    \ not require sorting\n<code>\npublic static double Median(IEnumerable<double>\
    \ values)\n{\n    if (values == null)\n        throw new ArgumentNullException(nameof(values));\n\
    \n    if (values.Count() == 0)\n        throw new ArgumentException(\"No value\
    \ available\", nameof(values));\n\n    if (values.Count() <= 2)\n        return\
    \ values.First();\n\n    var counters = values.GroupBy(p => p);\n    var middle\
    \ = counters.Count / 2;\n    var medianValue = counters[middle].Average();\n\n\
    \    return medianValue;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI guess this\
    \ can be solved easily with some mathematics. You can calculate the median of\
    \ n numbers and then divide it by 2 and find the middle number. Since you know\
    \ the middle number is exactly halfway between 1 and n you can easily calculate\
    \ the average. Hope this helps.\n<|/ a tags=algorithm,c#,sorting |>\n<| a dscore=0\
    \ |>\nIn O(n) time/O(n) space - median of medians\n<code>\npublic static int FindMedian(List<int>\
    \ nums)\n{\n", "  let med = l[0];\n  l.forEach((x: number) => {\n    if (x < med\
    \ && med < x) med = x;\n  });\n  return med;\n}\n", "  l.sort(function(a, b) {\n\
    \    return a - b;\n  });\n  if (l.length % 2 === 0) {\n    return l[l.length\
    \ / 2 - 1];\n  }\n  return (\n    (l[l.length / 2 - 1] + l[l.length / 2]) / 2\
    \ +\n    median(l.slice((l.length / 2) + 1, l.length)) +\n    median(l.slice(0,\
    \ (l.length / 2) - 1));\n}\n", "    return l.reduce((prev, cur) => prev < cur\
    \ ? prev : cur, (l: number[]) => l.sort((a: number, b: number) => a - b)[l.length\
    \ / 2]);\n}\n", "  return l[Math.floor(l.length / 2)];\n}\n", "  if (l.length\
    \ % 2 === 0) {\n    let l = l.slice(0, l.length >> 1);\n    l.sort((a, b) => {\n\
    \      return a - b;\n    });\n    let mid = l.length >> 1;\n    return l[mid];\n\
    \  } else {\n    let m = l[l.length - 1];\n    for (let l = l.slice(0, l.length\
    \ >> 1); l.length < 64; l = l.slice(0, l.length >> 1)) {\n      l.sort((a, b)\
    \ => {\n        return a - b;\n      });\n      if (l[l.length - 1] === m) {\n\
    \        break;\n      }\n      m = l[l.length - 1];\n    }\n    return m;\n \
    \ }\n}\n", "  let mid = Math.floor(l.length / 2);\n  if (l.length === 0) {\n \
    \   throw 'Array must not be empty';\n  }\n  if (l.length === 1) {\n    return\
    \ l[0];\n  }\n  if (l.length === 2) {\n    if (Math.abs(l[0] - l[1]) < 0.001)\
    \ {\n      return l[0];\n    }\n    return l[1];\n  }\n  let m1 = l[mid];\n  let\
    \ m2 = l[l.length - 1];\n  let sum = 0;\n  for (let i = 0; i < l.length; i +=\
    \ 2) {\n    sum += l[i];\n  }\n  return sum / l.length;\n}\n", "\tif (l.length\
    \ === 0) {\n\t\treturn NaN;\n\t}\n\n\tconst n = l.length;\n\tconst middle = Math.floor((n\
    \ - 1) / 2);\n\n\tif (Math.abs(l[middle]) <= Math.abs(l[middle - 1])) {\n\t\t\
    return median(l[middle]);\n\t}\n\n\treturn median(l[middle - 1]) + Math.ceil((middle\
    \ + 1) / 2) * 0.5;\n}\n", "  return quantile(l, 0.5);\n}\n", "  if (l.length %\
    \ 2 == 0) {\n    return ((l[l.length / 2 - 1] + l[l.length / 2]) / 2);\n  } else\
    \ {\n    return l[l.length / 2];\n  }\n}\n", "  if (l.length === 0) {\n    return\
    \ NaN;\n  }\n  const sorted = l.slice();\n  sortMedian(sorted);\n  return sorted[Math.floor(sorted.length\
    \ / 2)];\n}\n", "  if (l.length % 2 === 0) {\n    // even\n    return l[(l.length\
    \ / 2) - 1]\n  } else {\n    // odd\n    return l[(l.length / 2) | 0]\n  }\n}\n",
  "  if (l.length <= 1)\n    return l[0]\n  else if (l.length <= 2)\n    return l[0]\n\
    \  else {\n    var mid = Math.floor(l.length / 2)\n    if (l.length % 2)\n   \
    \   return median(l.slice(0, mid).concat([l[mid], l[l.length - 1]]))\n    else\n\
    \      return median(l.slice(0, mid))\n  }\n}\n", "  const l = l.slice(0).sort()\n\
    \  if (l.length % 2 === 0) {\n    return l[l.length / 2 - 1]\n  }\n  const mid\
    \ = l.length / 2 - 1;\n  return l[mid]\n}\n", "  return (l[l / 2 - 1] + l[l /\
    \ 2]) / 2;\n}\n", "\tlet mid = l.length >> 1;\n\tif (l.length % 2) {\n\t\treturn\
    \ l[mid];\n\t} else {\n\t\tlet m1 = median(l);\n\t\tlet m2 = median(l);\n\t\t\
    return (m1 + m2) / 2;\n\t}\n}\n", "  return Math.max.apply(Math, l);\n}\n", " \
    \ if (l.length === 0) return Infinity;\n  if (l.length === 1) return l[0];\n\n\
    \  let mid = Math.floor(l.length / 2);\n  if (l[mid] <= l[mid - 1]) return median(l);\n\
    \  return median(l);\n}\n", "  if (l.length === 0) {\n    return NaN;\n  }\n \
    \ const sortOrder = Math.floor(l.length / 2);\n  if (sortOrder > 0) {\n    l.sort((a,\
    \ b) => {\n      const aVal = +a;\n      const bVal = +b;\n      return aVal <\
    \ bVal ? -1 : aVal > bVal ? 1 : 0;\n    });\n  } else {\n    l.sort((a, b) =>\
    \ b - a);\n  }\n  return +l[sortOrder];\n}\n", "\tif (l == null)\n\t\treturn 0;\n\
    \tlet lp = l.length;\n\tif (lp === 0) {\n\t\treturn l[0];\n\t}\n\tlet mid = lp\
    \ >> 1;\n\tlet f = lp % 2;\n\tlet a = l[0];\n\tlet b = l[mid];\n\tif (f === 0)\
    \ {\n\t\treturn median(l, mid);\n\t}\n\tif (b < a || b === a && b > 0) {\n\t\t\
    return b;\n\t}\n\treturn median(l, mid - 1);\n}\n", "  if (l.length <= 1) {\n\
    \    throw new Error('median(): list does not have elements');\n  }\n  let sorted:\
    \ number[] = [l[0]];\n  for (let i = 1; i < l.length; i++) {\n    sorted.push(l[i]);\n\
    \  }\n  return sorted[Math.floor(sorted.length / 2)];\n}\n", "  let m = l.length\n\
    \  if (m < 1) return NaN\n  if (m % 2 === 0) {\n    return l[(m / 2) - 1]\n  }\n\
    \  return 0.5 * (l[(m / 2) - 1] + l[m / 2])\n}\n</code>\n<|/ a |>\n<| a |>\nThe\
    \ median is basically the middle element of a sorted array. Here is a simple algorithm\
    \ for that.\n<code>", "  let midIndex: number = l.length / 2;\n  if (midIndex\
    \ === -1) {\n    return l[l.length / 2];\n  }\n  if (midIndex >= midIndex) {\n\
    \    return median(l.slice(midIndex + 1));\n  }\n  return median(l.slice(0, midIndex));\n\
    }\n", "\tconst sortedArray = l.slice()\n\tsortedArray.sort()\n\n\tif (sortedArray.length\
    \ == 1) {\n\t\treturn sortedArray[0]\n\t}\n\n\tconst middleIndex = sortedArray.length\
    \ / 2\n\tif (middleIndex % 2 == 0) {\n\t\treturn sortedArray[middleIndex]\n\t\
    } else {\n\t\treturn sortedArray[middleIndex - 1] + sortedArray[middleIndex +\
    \ 1]\n\t}\n}\n", "  var a = l.sort((a, b) => a - b)\n  if (a.length % 2 === 0)\
    \ {\n    return (a[(Math.floor(a.length / 2) - 1)] + a[Math.floor(a.length / 2)])\
    \ / 2\n  }\n  return a[Math.floor(a.length / 2)]\n}\n", "  if (l.length <= 1)\
    \ return l[0];\n  const mid = l.length / 2;\n  const left = l.slice(0, mid);\n\
    \  const right = l.slice(mid);\n  return median(left) + median(right);\n}", " \
    \   let middle = Math.floor(l.length / 2),\n    medianValue = l[middle];\n   \
    \ if (l.length % 2)\n        return medianValue;\n    if (middle)\n        return\
    \ median(l[middle-1]) + Math.ceil((middle+1) / 2);\n}\n", "    const sortedL:\
    \ number[] = l.slice().sort();\n    if (sortedL.length % 2) {\n        return\
    \ sortedL[Math.floor(sortedL.length / 2)];\n    }\n\n    const mid = Math.floor(sortedL.length\
    \ / 2);\n    return sortedL[mid];\n}\n", "  const s = l.slice()\n  const n = s.length\n\
    \  if (n % 2 == 1) return s[(n - 1) / 2]\n  else {\n    const middle = s[(n -\
    \ 1) / 2 + 1]\n    return (s[(n - 2) / 2] + middle) / 2\n  }\n}\n", "  const n\
    \ = l.length;\n  if (n < 1) {\n    throw new Error('Cannot compute median of empty\
    \ array');\n  }\n  const half = n / 2;\n  if (n % 2) {\n    return median(l[half]);\n\
    \  } else {\n    const left = median(l[half]);\n    const right = median(l[n -\
    \ 1]);\n    return (left + right) / 2;\n  }\n}\n", "  const array = l.slice()\n\
    \  let n = array.length\n  if (n === 0) return null\n  if (n & 1) return array[Math.ceil((n\
    \ / 2) - 1)]\n  n >>= 1\n  return array[Math.ceil((n - 1) / 2)]\n}\n", "  const\
    \ s = l.sort(ascending);\n  if (s.length === 0) {\n    return 0;\n  }\n  const\
    \ half = s.length / 2;\n  if (half % 1 !== 0) {\n    return s[half];\n  }\n  return\
    \ s[half-1] + s[half];\n}\n", "    return Math.ceil(l.length / 2);\n}\n", "  \
    \  return l.length % 2 === 0\n        ? l[(l.length / 2) - 1]\n        : ((l[(l.length\
    \ / 2) - 1] + l[(l.length / 2)]) / 2);\n}\n", "    if (l.length === 0) return\
    \ NaN;\n    let sorts = l.slice();\n    sorts.sort( (a, b) => a - b );\n    if\
    \ (sorts.length % 2) return sorts[Math.floor((sorts.length + 1) / 2)];\n    let\
    \ middleIdx = Math.floor((sorts.length - 1) / 2);\n    let median = sorts[middleIdx];\n\
    \    return median;\n}\n", "  let sortedArr = l.slice();\n  sortedArr.sort((a:\
    \ number, b: number) => a - b);\n\n  if (sortedArr.length % 2 === 0) {\n    let\
    \ middleIdx = Math.floor((sortedArr.length) / 2);\n    return sortedArr[middleIdx];\n\
    \  } else {\n    let leftIdx = Math.ceil((sortedArr.length) / 2);\n    return\
    \ sortedArr[leftIdx];\n  }\n}\n", "  return Math.ceil(l.reduce((a, b) => a + b)\
    \ / l.length)\n}\n", "  return median_(l);\n}\n", "  if (l.length == 0) {\n  \
    \  return 0;\n  }\n  var mid = l.length / 2;\n  if (l.length % 2 == 1) {\n   \
    \ return median(l[mid]);\n  }\n  var a = l[mid];\n  var b = l.splice(0, mid);\n\
    \  var c = l.splice(0, mid);\n  while (a.length && b.length) {\n    if (a[0] <\
    \ b[0]) {\n      l.push(a.shift());\n    } else {\n      l.push(a.shift());\n\
    \      l.push(b.shift());\n    }\n  }\n  return l.pop();\n}\n", "  l = l.filter(l\
    \ => l !== undefined);\n\n  // Sort the array\n  l.sort((a: number, b: number)\
    \ => a - b);\n\n  // Return median of array.\n  return l[Math.floor(l.length /\
    \ 2)];\n}\n", "\tif (l == null || l.length === 0) {\n\t\treturn NaN;\n\t}\n\n\t\
    l = l.sort((a, b) => a - b);\n\tlet mid = Math.floor(l.length / 2);\n\tif (l.length\
    \ % 2 == 1) {\n\t\treturn l[mid];\n\t} else {\n\t\treturn (l[mid + 1] + l[mid])\
    \ / 2.0;\n\t}\n}\n", "  l.sort()\n  const mid = Math.floor((l.length - 1) / 2)\n\
    \  return (mid-Math.floor(mid/2) > l[mid]) ? l[mid + 1] : l[mid]\n}\n", "    let\
    \ len: number = l.length;\n    let a: number = 0;\n    let b: number = 0;\n  \
    \  let c: number = 0;\n    let d: number = 0;\n    let x: number = 0;\n    let\
    \ y: number = 0;\n    let z: number = 0;\n    let w: number = 0;\n    let i: number\
    \ = 0;\n    let j: number = 0;\n    let k: number;\n    let l2: number = 0;\n\
    \    let len2: number = 0;\n    let len3: number = 0;\n    let len4: number =\
    \ 0;\n    let len5: number = 0;\n    let median1: number = 0;\n    let median2:\
    \ number = 0;\n    let median3: number = 0;\n    let median4: number = 0;\n  \
    \  let median5: number = 0;\n    let median6: number = 0;\n    let median7: number\
    \ = 0;\n    let median8: number = 0;\n    let median9: number = 0;\n    let median10:\
    \ number = 0;\n    let median11: number = 0;\n    let median12: number = 0;\n\
    \    let median13: number = 0;\n    let median14: number = 0;\n    let median15:\
    \ number = 0;\n    let median16: number = 0;\n    let median17: number = 0;\n\
    \    let median18: number = 0;\n    let median19: number = 0;\n    let median20:\
    \ number = 0;\n    let median21: number = 0;\n    let median22: number = 0;\n\
    \    let median23: number = 0;\n    let median24: number = 0;\n    let median25:\
    \ number = 0;\n    let median26: number = 0;\n    let median27: number = 0;\n\
    \    let median28: number = 0;\n    let median29: number = 0;\n    let median30:\
    \ number = 0;\n    let median31: number = 0;\n    let median32: number = 0;\n\
    \    let median33: number = 0;\n    let median34: number = 0;\n    let median35:\
    \ number = 0;\n    let median36: number = 0;\n    let median37: number = 0;\n\
    \    let median38: number = 0;\n    let median39: number = 0;\n    let median40:\
    \ number = 0;\n    let median41: number = 0;\n    let median42: number = 0;\n\
    \    let median43: number = 0;\n    let median44: number = 0;\n    let median45:\
    \ number = 0;\n    let median46: number = 0;\n    let median47: number = 0;\n\
    \    let median48: number = 0;\n    let median49: number = 0;\n    let median50:\
    \ number = 0;\n    let median51: number = 0;\n    let median52: number = 0;\n\
    \    let median53: number = 0;\n    let median54: number = 0;\n    let median55:\
    \ number = 0;\n    let median56: number = 0;\n    let median57: number = 0;\n\
    \    let median58: number = 0;\n    let median59: number = 0;\n    let median60:\
    \ number = 0;\n    let median61", "  if (l.length === 0) {\n    return 0;\n  }\n\
    \  const l = l.slice();\n  const even = l.splice(0, l.length >> 1);\n  const odd\
    \ = l.splice(0, l.length >> 1);\n  even.length && sort(even);\n  odd.length &&\
    \ sort(odd);\n  return ((even.length + odd.length + 1) >> 1) + even[even.length\
    \ >> 1] / 2;\n}\n", "  return l;\n}\n", "  var a = l.slice();\n  a.sort(function\
    \ (a, b) { return b - a; });\n  \n  return a[Math.floor(l.length / 2)];\n}\n",
  "    return Math.ceil(l.length / 2);\n}\n", "  if (l.length === 0) {\n    return\
    \ NaN;\n  }\n\n  const mid = l.length / 2;\n  if (l.length % 2) {\n    return\
    \ l[mid];\n  }\n\n  let lo = 0;\n  let hi = mid;\n\n  while (lo < hi) {\n    const\
    \ mid = (lo + hi) >> 1;\n\n    if (l[mid] < l[mid + 1]) {\n      hi = mid;\n \
    \   } else {\n      lo = mid + 1;\n    }\n  }\n\n  return lo;\n}\n", "  const\
    \ n = l.length\n  if (n < 1) {\n    return NaN\n  }\n  const l = l.slice()\n \
    \ l.sort()\n  if (n % 2 === 0) {\n    const mid = Math.floor(n / 2)\n    if (l[mid]\
    \ > l[mid+1]) {\n      return median(l[mid])\n    }\n    return median(l[mid+1])\n\
    \  }\n  return (l[Math.floor(n / 2)] + l[Math.floor(n / 2)-1]) / 2\n}\n", "  let\
    \ h = l.length\n  let a = l[0]\n  for (let i = 1; i < h; i++) {\n    let b = l[i]\n\
    \    if (a > b) a = b\n  }\n  return a\n}\n", "  var m = l.slice().sort(sorter);\n\
    \  l = [];\n  while (m.length > 1) {\n    var a = m.pop();\n    l.push(a);\n \
    \ }\n  return l[0];\n}\n", "  let middle: number = 0;\n  let length: number =\
    \ l.length;\n  let sortArray: number[] = l.slice();\n  sortArray.sort((a, b) =>\
    \ {\n    if (a > b) return -1;\n    if (a < b) return 1;\n    return 0;\n  });\n\
    \  for (let i = 0; i < length; i++) {\n    if (sortArray[i] === middle) break;\n\
    \    middle = sortArray[i];\n  }\n  let medianArray: number[] = [];\n  for (let\
    \ i = 0; i < length; i++) {\n    if (i != middle) medianArray.push(sortArray[i]);\n\
    \  }\n  return median(medianArray);\n}\n", "  const n = l.length\n  if (n < 1)\
    \ return NaN\n  if (n === 1) return l[0]\n  const mid = ~~(n / 2)\n  let l = sort(l)\n\
    \  let r = sort(l.slice(0, mid))\n  return l[n & 1 ? mid - 1 : mid]\n}\n", " \
    \ if (l.length === 0) throw 'Cannot find median of an empty array.'\n  if (l.length\
    \ % 2 === 1) return l[Math.floor(l.length / 2)]\n  const middle = l.length / 2\
    \ - 1\n  const leftMiddle = l[middle]\n  const rightMiddle = l[middle + 1]\n \
    \ const medianOfTwo = leftMiddle + rightMiddle\n  return middleIsBetterThanCenter(\n\
    \    leftMiddle,\n    rightMiddle,\n    medianOfTwo,\n    l,\n  )\n    ? medianOfTwo\n\
    \    : leftMiddle\n}\n", "  if (l.length == 0) {\n    return 0;\n  }\n  const\
    \ n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n\
    \  const median1: number = l[Math.floor(n / 2)];\n  const median2: number = l[Math.floor(n\
    \ / 2) - 1];\n  return median1 + median2 / (2 * n);\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
