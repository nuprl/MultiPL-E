name: HumanEval_116_sort_array
language: ts
prompt: "//In this Kata, you have to sort an array of non-negative integers according\
  \ to\n// number of ones in their binary representation in ascending order.\n// For\
  \ similar number of ones, sort based on decimal value.\n// It must be implemented\
  \ like this:\n// >>> sort_array([1, 5, 2, 3, 4])\n// [1, 2, 3, 4, 5]\n// >>> sort_array([-2,\
  \ -3, -4, -5, -6])\n// [-6, -5, -4, -3, -2]\n// >>> sort_array([1, 0, 2, 3, 4])\n\
  // [0, 1, 2, 3, 4]\nfunction sort_array(arr: number[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = sort_array;\n  assert.deepEqual(candidate([1, 5, 2,\
  \ 3, 4]),[1, 2, 4, 3, 5]);\n  assert.deepEqual(candidate([-2, -3, -4, -5, -6]),[-4,\
  \ -2, -6, -5, -3]);\n  assert.deepEqual(candidate([1, 0, 2, 3, 4]),[0, 1, 2, 4,\
  \ 3]);\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([2,\
  \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n  assert.deepEqual(candidate([3,\
  \ 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44]);\n  assert.deepEqual(candidate([2, 4,\
  \ 8, 16, 32]),[2, 4, 8, 16, 32]);\n  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2,\
  \ 4, 8, 16, 32]);\n}\n\ntest();"
completions: ["  if (!arr.length || arr.length === 1) {\n    return arr;\n  }\n\n\
    \  const counts: Array<number> = new Array(arr.length);\n  for (let i = 0; i <\
    \ arr.length; i++) {\n    counts[arr[i]]++;\n  }\n\n  const indexCounts: Array<number>\
    \ = new Array(arr.length);\n  for (let i = 0; i < arr.length; i++) {\n    indexCounts[counts[arr[i]]++]\
    \ = i;\n  }\n\n  // Now the result array is sorted. We can sort indexCounts array\
    \ as well.\n  let j = 0;\n  for (let i = 0; i < indexCounts.length; i++) {\n \
    \   const count = indexCounts[i];\n    while (count > 0) {\n      indexCounts[j]\
    \ = count;\n      j++;\n      count--;\n    }\n  }\n\n  const newArr = new Array(indexCounts.length);\n\
    \  j = 0;\n  for (let i = 0; i < indexCounts.length; i++) {\n    newArr[i] = arr[indexCounts[j]];\n\
    \    j++;\n  }\n  return newArr;\n}\n", "  const len = arr.length;\n  if (len\
    \ === 0) return arr;\n\n  for (let i = 0; i < len; i++) {\n    const ones = arr[i]\
    \ & 0xF;\n    let tmp = arr[i];\n    let tmp1 = arr[i + 1];\n\n    arr[i] = tmp1;\n\
    \    arr[i + 1] = tmp;\n\n    arr[i] = tmp + ones;\n    arr[i + 1] = tmp1 - ones;\n\
    \  }\n\n  return arr;\n}\n", "\tlet sortedArr: number[] = [];\n\tfor (let i =\
    \ 0; i < arr.length; i++) {\n\t\tlet count = 0;\n\t\tfor (let j = 0; j < i; j++)\
    \ {\n\t\t\tif (arr[j] & arr[i]) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count\
    \ > 0) {\n\t\t\tsortedArr.push(arr[i]);\n\t\t}\n\t}\n\tfor (let i = 0; i < arr.length;\
    \ i++) {\n\t\tlet count = 0;\n\t\tfor (let j = 0; j < i; j++) {\n\t\t\tif (arr[j]\
    \ == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count == 0) {\n\t\t\tsortedArr.push(arr[i]);\n\
    \t\t}\n\t}\n\treturn sortedArr;\n}", "  const len = arr.length;\n  if (len ===\
    \ 0) {\n    return arr;\n  }\n  if (len === 1) {\n    if (arr[0] > 0) {\n    \
    \  return arr;\n    } else {\n      return [arr[0], arr[0]];\n    }\n  }\n\n \
    \ const mid = Math.floor(len / 2);\n  const left = arr.slice(0, mid);\n  const\
    \ right = arr.slice(mid);\n  const midArr = [];\n\n  const helper = (leftArr:\
    \ number[], rightArr: number[], result: number[], isLeft: boolean) => {\n    leftArr.forEach((el)\
    \ => {\n      isLeft ? result.push(el) : result.unshift(el);\n    });\n    rightArr.forEach((el)\
    \ => {\n      isLeft ? result.push(el) : result.unshift(el);\n    });\n  };\n\n\
    \  helper(left, right, midArr, true, false);\n  helper(left, right, midArr, false,\
    \ true);\n\n  return midArr;\n}\n", "\tfor (let i = 0; i < arr.length; ++i) {\n\
    \t\tfor (let j = i + 1; j < arr.length; ++j) {\n\t\t\tlet ones = arr[i] & 1;\n\
    \t\t\tlet twos = arr[j] & 1;\n\t\t\tif (ones !== twos) {\n\t\t\t\tlet nums = arr[i]\
    \ ^ arr[j];\n\t\t\t\tlet tmp = nums & -nums;\n\t\t\t\tif (tmp) {\n\t\t\t\t\ttmp\
    \ = tmp + nums & nums;\n\t\t\t\t}\n\t\t\t\tarr[i] = tmp ^ nums;\n\t\t\t\tarr[j]\
    \ = tmp ^ nums;\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n", "    return arr\n \
    \       .map((n: number) => parseInt(n, 2))\n        .sort((a, b) => a - b)\n\
    \        .map((n: number) => parseInt(n, 10));\n}\n", "    arr.sort((a, b) =>\
    \ count_ones(a) - count_ones(b));\n}\n", "  return arr.sort((a: number, b: number)\
    \ => {\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n    if (a === 0)\
    \ {\n      return 1;\n    }\n    if (b === 0) {\n      return -1;\n    }\n   \
    \ if (a > b) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n \
    \   }\n  });\n}\n", "  for (let i = 0; i < arr.length; i++) {\n    for (let j\
    \ = 0; j < arr.length; j++) {\n      arr[j].sort(function (a, b): number {\n \
    \       if (a > b) {\n          return 1;\n        } else if (b > a) {\n     \
    \     return -1;\n        } else {\n          return 0;\n        }\n      });\n\
    \    }\n  }\n  return arr;\n}\n", "  arr.sort( (a, b) => { return -a - b; } );\n\
    \  return arr;\n}\n", "    arr.sort((a, b) => {\n        return b - a;\n    });\n\
    \n    return arr;\n}\n", "  if (!arr) {\n    return arr\n  }\n  const resultArr\
    \ = []\n  for (let i = 0; i < arr.length; i++) {\n    resultArr[arr[i]] = i\n\
    \  }\n  arr.sort(\n    (num1: number, num2: number) => num1 > num2 ? 1 : num1\
    \ < num2 ? -1 : 0,\n  )\n  return resultArr\n}\n", "    let len = arr.length,\n\
    \        swapped = 0,\n        sorted: number[] = [];\n    for (let i = 0; i <\
    \ len; i++) {\n        swapped = swapped * 10 + arr[i];\n        if (swapped >\
    \ 10000000) {\n            swapped = swapped % 10000000;\n            sorted.push(swapped\
    \ / 1000000);\n            swapped = swapped % 1000000;\n            sorted.push(swapped\
    \ / 10000);\n            swapped = swapped % 10000;\n            sorted.push(swapped\
    \ / 100);\n            swapped = swapped % 100;\n            sorted.push(swapped\
    \ / 10);\n            swapped = swapped % 10;\n            sorted.push(swapped);\n\
    \        }\n    }\n    return sorted;\n}", "\tlet len = arr.length;\n\tlet flag\
    \ = new Array(len);\n\tlet lastIndex = len - 1;\n\tlet temp;\n\tlet swapped;\n\
    \tfor (let i = 0; i < len; ++i) {\n\t\tflag[i] = 0;\n\t}\n\tfor (let j = 0; j\
    \ < len; ++j) {\n\t\tif (arr[j] !== 0) {\n\t\t\tflag[j] = 0;\n\t\t} else {\n\t\
    \t\tflag[j] = 1\n\t\t}\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\tif (flag[i]\
    \ !== flag[i + 1]) {\n\t\t\t\tif (flag[i]) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\
    \t\t\tif (arr[i] > arr[j]) {\n\t\t\t\t\t\t\ttemp = arr[i];\n\t\t\t\t\t\t\tarr[i]\
    \ = arr[j];\n\t\t\t\t\t\t\tarr[j] = temp;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\
    temp = arr[j];\n\t\t\t\t\t\t\tarr[j] = arr[i];\n\t\t\t\t\t\t\tarr[i] = temp;\n\
    \t\t\t\t\t\t}\n\t\t\t\t\t\tflag[j] = 0;\n\t\t\t\t\t\tlastIndex = i - 1;\n\t\t\t\
    \t\t} else {\n\t\t\t\t\t\tflag[j] = 1;\n\t\t\t\t\t\tlastIndex = j;\n\t\t\t\t\t\
    }\n\t\t\t\t} else {\n\t\t\t\t\tlastIndex = j;\n\t\t\t\t\tflag[j] = 0;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n", "  return arr.sort((a: number, b:\
    \ number) => {\n    const ones_a = parseInt(a / 2 ** 32 / 2, 10);\n    const ones_b\
    \ = parseInt(b / 2 ** 32 / 2, 10);\n    return ones_a - ones_b;\n  });\n}", " \
    \ const len = arr.length;\n  for (let i = 0; i < len - 1; ++i) {\n    for (let\
    \ j = i + 1; j < len; ++j) {\n      const ones = count_ones(arr[j]);\n      if\
    \ (ones < count_ones(arr[i])) {\n        swap(arr, j, i);\n      }\n    }\n  }\n\
    \  return arr;\n}\n", "\tlet zeros = arr.filter((e) => e === 0);\n\tif (zeros.length\
    \ > 0) {\n\t\tzeros.sort((a, b) => a - b);\n\t\treturn zeros.reverse();\n\t}\n\
    \tlet ones = arr.filter((e) => e === 1);\n\tif (ones.length > 0) {\n\t\tones =\
    \ ones.sort((a, b) => a - b);\n\t\treturn ones;\n\t}\n\tlet decimals = arr.filter((e)\
    \ => e % 1 === 0);\n\tif (decimals.length > 0) {\n\t\tdecimals = decimals.sort((a,\
    \ b) => a - b);\n\t\treturn decimals;\n\t}\n}\n", "  let map = new Map<number,\
    \ number[]>();\n  for (let i = 0; i < arr.length; i++) {\n    if (map.has(arr[i]))\
    \ {\n      map.get(arr[i])!.push(i);\n    } else {\n      map.set(arr[i], [i]);\n\
    \    }\n  }\n\n  let result = [];\n  for (let [key, value] of map) {\n    value.sort((a,\
    \ b) => a - b);\n    result = result.concat(value);\n  }\n\n  for (let i = result.length\
    \ - 1; i >= 0; i--) {\n    result.splice(i, 1);\n  }\n\n  return result;\n}\n",
  "  if (arr.length === 0) {\n    return arr;\n  }\n\n  const map = {};\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    if (map[item])\
    \ {\n      map[item]++;\n    } else {\n      map[item] = 1;\n    }\n  }\n\n  const\
    \ keys = Object.keys(map);\n\n  if (keys.length === 1) {\n    return arr;\n  }\n\
    \n  const sorted = keys.reduce((arr, key) => {\n    arr.push(key);\n    return\
    \ arr;\n  }, []);\n  const result = [];\n  sorted.forEach(key => {\n    if (map[key])\
    \ {\n      result.push(key);\n      map[key]--;\n    }\n  });\n  return result;\n\
    }", "  arr.sort((a, b) => a > b ? 1 : -1);\n  return arr;\n}\n", "  return _.sortBy(arr,\
    \ (_, index) => parseInt(_.bitLength(arr[index])));\n}\n", "  let n = arr.length;\n\
    \  if (n < 2) {\n    return arr;\n  }\n\n  // Sort the array in ascending order\n\
    \  let aux = [];\n  let cur = 0;\n  let curIndex = 0;\n  for (let i = 0; i < n;\
    \ i++) {\n    cur = arr[i];\n    while (curIndex < n) {\n      if (curIndex ===\
    \ n) {\n        aux[curIndex] = cur;\n        curIndex++;\n      } else {\n  \
    \      if (cur & 1) {\n          aux[curIndex + 1] = cur;\n          curIndex++;\n\
    \        } else {\n          curIndex++;\n        }\n      }\n      cur = arr[curIndex];\n\
    \    }\n  }\n\n  // Sort the array in descending order\n  cur = arr[0];\n  for\
    \ (let i = 0; i < n; i++) {\n    while (curIndex >= 0) {\n      if (curIndex ===\
    \ -1) {\n        aux[curIndex] = cur;\n        curIndex--;\n      } else {\n \
    \       curIndex--;\n      }\n      cur = arr[curIndex];\n    }\n  }\n  return\
    \ aux;\n}\n", "  debugger;\n  // Sorting array based on number of ones in their\
    \ binary representation in ascending order.\n  // It must be implemented like\
    \ this:\n  // >>> sort_array([1, 5, 2, 3, 4])\n  // [1, 2, 3, 4, 5]\n  // >>>\
    \ sort_array([-2, -3, -4, -5, -6])\n  // [-6, -5, -4, -3, -2]\n  // >>> sort_array([1,\
    \ 0, 2, 3, 4])\n  // [0, 1, 2, 3, 4]\n  return arr.sort((a: number, b: number)\
    \ => {\n    // Sorting array based on decimal value.\n    if (a > b) {\n     \
    \ return 1;\n    } else if (a < b) {\n      return -1;\n    } else {\n      return\
    \ 0;\n    }\n  });\n}\n", "  if (!arr || arr.length === 0) {\n    return arr;\n\
    \  }\n  arr.sort((a: number, b: number) => {\n    if (a === b) {\n      return\
    \ 0;\n    }\n    const ones = (a & 0b11110000) >> 0;\n    const tens = (a & 0b00001111)\
    \ >> 4;\n    const hundreds = (a & 0b00000011) >> 8;\n    const tens_ones = (a\
    \ & 0b00000001) >> 10;\n    const hundreds_ones = (a & 0b00000001) >> 11;\n  \
    \  const tens_tens = (a & 0b00001111) >> 6;\n    const tens_hundreds = (a & 0b00000110)\
    \ >> 1;\n    const hundreds_tens = (a & 0b01000110) >> 2;\n    const hundreds_hundreds\
    \ = (a & 0b01000110) >> 3;\n    const ones_tens = (a & 0b11000111) >> 7;\n   \
    \ const ones_hundreds = (a & 0b11001000) >> 5;\n    const ones_tens_hundreds =\
    \ (a & 0b11001011) >> 3;\n    const ones_hundreds_tens = (a & 0b11001100) >> 1;\n\
    \    const ones_hundreds_hundreds = (a & 0b11011100) >> 0;\n    const tens_hundreds_tens\
    \ = (a & 0b11111000) >> 4;\n    const hundreds_hundreds_tens = (a & 0b11101111)\
    \ >> 6;\n    const tens_hundreds_hundreds = (a & 0b11111110) >> 8;\n    const\
    \ ones_hundreds_hundreds_tens = (a & 0b11111101) >> 9;\n    const ones_hundreds_hundreds_hundreds\
    \ = (a & 0b11111011) >> 3;\n    const ones_hundreds_hundreds_hundreds_tens = (a\
    \ & 0b11110100) >> 6;\n    const ones_hundreds_hundreds_hundreds_hundreds = (a\
    \ & 0b11110111) >> 4;\n    const ones_hundreds_hundreds_hundreds_hundreds_tens\
    \ = (a & 0b11101100) >> 8;\n    const ones_hundreds_hundreds_hundreds_hundreds_hundreds\
    \ = (a & 0b11110111) >> 5;\n    const ones_hundreds_hundreds_hundreds_hundreds_hundreds_tens\
    \ = (a & 0b11101111) >> 9;\n    const tens_hundreds_hundreds_hundreds_hundreds_hundreds_hundreds\
    \ = (a & 0b11111110) >> 11;\n    const ones_hundreds_hundreds_hundreds_hundreds_hundreds_hundreds_tens\
    \ = (a ", "  // Write your code here.\n}\n", "  if (!(arr instanceof Array)) return\
    \ arr;\n  const len = arr.length;\n  for (let i = 0; i < len; i++)\n    if (arr[i]\
    \ < 0) arr[i] += Math.pow(2, len) * Math.pow(2, -arr[i]);\n  for (let i = 0; i\
    \ < len; i++)\n    arr[i] = arr[i] < 0 ? Math.pow(2, len) * Math.pow(2, Math.abs(arr[i]))\
    \ - 1 : arr[i];\n  return arr.sort((a, b) => a > b ? 1 : -1);\n}\n", "  for (let\
    \ i = 0; i < arr.length; i++) {\n    arr[i] = getCount(arr[i])\n  }\n  return\
    \ sortNumber(arr)\n}\n", "  const numOfOnes = sort_arr(arr.map(bin => bin.match(/1/g)[0].length));\n\
    \  const numOfDigits = sort_arr(arr.map(bin => bin.match(/1/g).length));\n  let\
    \ res = arr.map((n, i) => numOfOnes[i] == numOfDigits[i] ? n : numOfDigits[i]\
    \ > numOfOnes[i] ? n : numOfOnes[i] == numOfDigits[i] ? numOfOnes[i] : numOfDigits[i]);\n\
    \  if (res.some(n => n != n)) res = res.sort();\n  return res;\n}\n", "  if (arr.length\
    \ === 0) {\n    return arr;\n  }\n  const len = arr.length;\n  if (arr.length\
    \ === 1) {\n    return arr;\n  }\n  let count = 0;\n  for (let i = 0; i < len;\
    \ i++) {\n    const item = arr[i];\n    const num = item;\n    while (num > 0)\
    \ {\n      const remainder = num % 10;\n      num = num / 10;\n      if (remainder\
    \ > 0) {\n        count++;\n        arr.splice(i, 0, remainder);\n      }\n  \
    \  }\n  }\n  arr.splice(len, 0, count);\n  return arr;\n}\n", "  const copy =\
    \ arr.slice();\n  copy.sort((a, b) => {\n    const aVal = binToDec(binToBin(a));\n\
    \    const bVal = binToDec(binToBin(b));\n    return (aVal - bVal);\n  });\n \
    \ return copy;\n}\n", "    return arr.sort((a, b) => a > b ? 1 : a < b ? -1 :\
    \ 0);\n}\n", "  const n = arr.length;\n  arr.sort((a, b) => {\n    const aOnes\
    \ = count_ones(a);\n    const bOnes = count_ones(b);\n    if (aOnes === bOnes)\
    \ {\n      return a - b;\n    } else {\n      return aOnes - bOnes;\n    }\n \
    \ });\n  return arr;\n}\n", "  return arr.sort((a: number, b: number) => {\n \
    \   const ones = Math.floor(a).toString(2).split('')\n    const zeros = Math.floor(b).toString(2).split('')\n\
    \    return ones.length - zeros.length || a > b ? -1 : 1\n  })\n}\n", "  arr.sort((a:\
    \ number, b: number) => {\n    const a_bit = a >> 31;\n    const b_mask = b >>\
    \ 31;\n    const b_bit = b & b_mask;\n    if (a_bit === b_bit) {\n      return\
    \ a < b ? -1 : 1;\n    } else if (a_bit) {\n      return -1;\n    } else if (b_bit)\
    \ {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  return arr;\n\
    }\n", "  var result: number[] = [];\n  var ones = 0;\n  var i = 0;\n  while (i\
    \ < arr.length) {\n    ones = binary_search(arr[i]) - binary_search(arr[i] - 1);\n\
    \    if (ones === 0) result.push(arr[i]);\n    else if (ones === 1) {\n      result.push(arr[i]\
    \ + 1);\n      result.push(arr[i] - 1);\n    }\n    else result.push(arr[i] -\
    \ ones);\n    i++;\n  }\n  return result;\n}\n", "    if (arr.length === 0) return\
    \ arr;\n    if (arr.length === 1) return arr[0];\n\n    let ones: number[] = [];\n\
    \    let binary: number[] = [];\n    let dec: number[] = [];\n\n    for (let val\
    \ of arr) {\n        binary[binary.length] = val.toString(2);\n        dec.push(val\
    \ / Math.pow(2, binary.length));\n        ones.push(0);\n    }\n\n    for (let\
    \ i = 0; i < ones.length; i++) {\n        for (let j = 0; j < ones.length; j++)\
    \ {\n            if (ones[j] > ones[i]) {\n                let tmp = binary[j];\n\
    \                binary[j] = binary[i];\n                binary[i] = tmp;\n  \
    \              tmp = dec[j];\n                dec[j] = dec[i];\n             \
    \   dec[i] = tmp;\n                tmp = ones[j];\n                ones[j] = ones[i];\n\
    \                ones[i] = tmp;\n            }\n        }\n    }\n    \n    let\
    \ result = binary;\n    for (let i = 0; i < ones.length; i++) {\n        result\
    \ += ones[i] * dec[i];\n    }\n    \n    return result;\n}\n", "  const n = arr.length\n\
    \  const sortArr = new Array(n)\n\n  // Fill sortArr arr into its binary representation\
    \ arr_binary\n  for (let i = 0; i < n; i++) {\n    const arr_binary = arrayToBin(arr[i])\n\
    \    for (let j = 0; j < arr_binary.length; j++) {\n      if (arr_binary[j] ===\
    \ '1') {\n        sortArr[i] = j\n        break\n      }\n    }\n  }\n  sortArr.sort((a,\
    \ b) => a - b)\n\n  // Fill sortArr arr into its decimal representation arr_decimal\n\
    \  for (let i = 0; i < n; i++) {\n    const arr_decimal = binaryToDecimal(sortArr[i])\n\
    \    sortArr[i] = arr_decimal\n  }\n\n  return sortArr\n}\n", "    if (arr.length\
    \ <= 1) {\n        return arr\n    }\n    let result = []\n    let index = 0\n\
    \    let maxIndex = 0\n    for (let i = 0; i < arr.length; i++) {\n        if\
    \ (arr[i] >= 0) {\n            result[index++] = arr[i]\n            maxIndex\
    \ = i\n        }\n    }\n    let tmpArr = []\n    while (index > 0) {\n      \
    \  let min = Math.min(...result)\n        result[index--] = maxIndex\n       \
    \ tmpArr[maxIndex] = min\n    }\n    return tmpArr\n}", "    // write your code\
    \ here\n    arr.sort((a: number, b: number) => {\n        const c = a % 2;\n \
    \       const d = b % 2;\n        if (c === d) {\n            return a - b;\n\
    \        } else if (c === 0) {\n            return a - b;\n        } else if (d\
    \ === 0) {\n            return b - a;\n        } else {\n            return b\
    \ - a;\n        }\n    });\n    return arr;\n}\n", "  const len = arr.length;\n\
    \  if (len === 0) {\n    return arr;\n  }\n  let count = new Array(len).fill(0);\n\
    \  for (let i = 0; i < len; i++) {\n    count[arr[i]]++;\n  }\n\n  const countArr\
    \ = count.map((num) => -num);\n  let result = [];\n  for (let i = 0; i < len;\
    \ i++) {\n    for (let j = 0; j < countArr[i]; j++) {\n      result.push(arr[i]);\n\
    \    }\n  }\n  return result;\n}\n", "  let counts: number[] = [];\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    let x = arr[i];\n    counts[x] ? counts[x]++\
    \ : (counts[x] = 1);\n  }\n\n  counts = counts.sort((a: number, b: number) =>\
    \ {\n    return a - b;\n  });\n  counts = counts.map(c => c.toString().split('').reverse().join(''));\n\
    \n  let newArr: number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n   \
    \ let x = arr[i];\n    let index = counts[x] ? counts[x] - 1 : 0;\n    let value\
    \ = counts[index];\n    newArr[i] = value + x;\n  }\n  return newArr;\n}\n", " \
    \ const counts: number[] = [];\n  for (const num of arr) {\n    counts.push(count_ones(num));\n\
    \  }\n  counts = counts.sort();\n  const nums = arr.filter((_, i) => counts[i]\
    \ >= counts[counts.length - 1]);\n  return nums;\n}\n", "  var result: number[]\
    \ = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var count = 1;\n    var\
    \ num = 0;\n\n    while ((num = (arr[i] & count) != 0)) {\n      result.push(num);\n\
    \      count++;\n    }\n  }\n\n  return result;\n}\n", "  if (arr.length === 0)\
    \ return arr;\n  arr.sort((a: number, b: number) => a - b);\n  if (arr[0] < 0)\
    \ arr.push(0);\n  if (arr[0] > 0) arr.unshift(0);\n  return arr;\n}\n", "  let\
    \ n = arr.length;\n  if (n < 2) {\n    return arr;\n  }\n\n  const map = new Map();\n\
    \  for (var i = 0; i < arr.length; i++) {\n    const str = bin(arr[i]);\n    if\
    \ (!map.has(str)) {\n      map.set(str, 0);\n    }\n    map.set(str, map.get(str)\
    \ + 1);\n  }\n\n  map.forEach((v, k) => map.set(k, map.get(k) * -1));\n\n  arr.sort((a,\
    \ b) => {\n    a = bin(a);\n    b = bin(b);\n    if (map.has(a) && map.has(b))\
    \ {\n      return map.get(b) - map.get(a);\n    }\n    if (map.has(a)) {\n   \
    \   return -1;\n    }\n    if (map.has(b)) {\n      return 1;\n    }\n    return\
    \ 0;\n  });\n  return arr;\n}\n", "    arr.sort((a, b) => a - b)\n    return arr\n\
    }\n", "  const len = arr.length\n  const sorted = new Array(len)\n  for (let i\
    \ = 0; i < len; ++i) {\n    sorted[i] = arr.slice(0).sort((a, b) => a - b)\n \
    \ }\n  return sorted\n}\n", "  let _arr: number[] = [];\n  for (let i = 0; i <\
    \ arr.length; i++) {\n    _arr.push((arr[i] & 0b1) == 0 ? arr[i] : -arr[i]);\n\
    \  }\n  return _arr.sort((a, b) => a - b);\n}\n", "  arr.sort((a, b) => {\n  \
    \  const a_ones = parseInt(binStr(a, 2), 10)\n    const b_ones = parseInt(binStr(b,\
    \ 2), 10)\n    if (a_ones < b_ones) {\n      return -1\n    } else if (a_ones\
    \ > b_ones) {\n      return 1\n    } else {\n      return parseInt(binStr(a, 10),\
    \ 10) - parseInt(binStr(b, 10), 10)\n    }\n  })\n  return arr\n}\n", "    const\
    \ zeroCount: number = count_zeros(arr);\n    console.assert(zeroCount > 0);\n\
    \    const count = arr.length;\n    const minValueIndex = zeroCount;\n    const\
    \ maxValueIndex = count - zeroCount;\n    const minValue = arr[minValueIndex];\n\
    \    const maxValue = arr[maxValueIndex];\n    const values = [];\n    let minValueIndex\
    \ = minValueIndex;\n    let maxValueIndex = maxValueIndex;\n    let minValue =\
    \ arr[minValueIndex];\n    let maxValue = arr[maxValueIndex];\n    let index;\n\
    \    for (let index = 0; index < count; ++index) {\n        const value = arr[index];\n\
    \        if (value === minValue) {\n            minValueIndex = index;\n     \
    \       minValue = value;\n        } else if (value === maxValue) {\n        \
    \    maxValueIndex = index;\n            maxValue = value;\n        } else {\n\
    \            values.push(value);\n        }\n    }\n    values.sort(\n       \
    \ (a, b) => a - b || count_ones(bin(Math.abs(a), minValueIndex)) - count_ones(bin(Math.abs(b),\
    \ maxValueIndex)),\n    );\n    return values;\n}\n", "  return arr.sort((a, b)\
    \ => {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return\
    \ -1;\n    } else {\n      return 0;\n    }\n  });\n}\n", "  for (let i = 0; i\
    \ < arr.length; i++) {\n    for (let j = i; j < arr.length; j++) {\n      if (arr[i]\
    \ > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j]\
    \ = temp;\n      }\n    }\n  }\n  return arr;\n}\n", "  arr = [...arr];\n  arr.sort((a,\
    \ b) => {\n    let a1 = count_ones(a).toString(), b1 = count_ones(b).toString();\n\
    \    return a1 > b1 ? 1 : a1 < b1 ? -1 : 0;\n  });\n  return arr;\n}\n", "  if(arr.length\
    \ === 0) return arr\n  let len = arr.length\n  let result = new Array(len)\n \
    \ let cur = 0\n  let index = 0\n  result[index] = arr[cur]\n  cur++\n  while(cur\
    \ < len) {\n    while(arr[cur] === 0) {\n      cur++\n    }\n    while(arr[cur]\
    \ === 1) {\n      cur++\n    }\n    result[index] = arr[cur]\n    cur++\n    index++\n\
    \  }\n  return result\n}\n</code>\nI do not have the time to test this myself\
    \ right now, but I hope I helped. Do post any questions, if needed.\n<|/ a dscore=0\
    \ |>\n<| c |>\nThank you for your answer, but I am not allowed to use any built\
    \ in functions. The problem is more mathematical/algorithmic than code-specific.\n\
    <|/ c |>\n<| c |>\nHow is this different from my answer?\n<|/ c |>\n<| c |>\n\
    I'm sorry but I must agree with you, this is different from your answer as I stated\
    \ in my question. I apologize for this.\n<|/ c |>\n<| c |>\nAh, I see. Well, it\
    \ is hard to know if this is possible without doing some sort of brute-force calculation.\
    \ Maybe someone else will come up with a solution using iteration and modulo,\
    \ though.\n<|/ c |>\n<| c |>\nWell I'm just too lazy to think up some code right\
    \ now, but I'll try and post something when I can.\n<|/ c |>\n<| a tags=algorithm,sorting\
    \ |>\nI have been looking for something similar but I found a solution that works\
    \ really good.\nThe idea is to divide each number by two, and if the number is\
    \ odd, multiply it by two. And so on.\n<code>\nprivate int sortNumber(int n) {\n\
    \    int result = 0;\n    int currentNumber = 1;\n\n    while (n/2 > 0) {\n  \
    \      n /= 2;\n        currentNumber *= 2;\n    }\n    while (n > 1) {\n    \
    \    n /= 2;\n        result = currentNumber + result;\n        currentNumber\
    \ *= 2;\n    }\n\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    I wouldn't call this \"sorting numbers\". You're just treating them as binary\
    \ digits, while you didn't have to. You could just treat each number as decimal\
    \ digits and sort them as they are.\n<|/ c |>\n<| a tags=algorithm,sorting dscore=0\
    \ |>\n<code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n", " \
    \ // write your code here\n}\n</code>\n<|/ q dscore=0 |>\n<| c |>\nWhat do you\
    \ mean by \"sort them in ascending order\"? You want them to have no leading zeros?\
    \ Do they have to be consecutive?\n<|/ c |>\n<| c |>\n, yes, I mean no leading\
    \ 0s.\n<|/ c |>\n<| c |>\nDo they have to be consecutive as in the question you've\
    \ linked?\n<|/ c |>\n<| c |>\n, yes, they have to be consecutive\n<|/ c |>\n<|\
    \ c |>\nThen the answer is simple, just convert them to binary strings using the\
    \ `format` function, then convert the resulting strings to integers (which are\
    \ already sorted), and finally convert them to hexadecimals.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe algorithm you linked has two steps: sorting the numbers and converting\
    \ them to hexadecimal representations. To sort the numbers, you can just use their\
    \ ASCII codes, because they already are sorted. Assuming you want to sort the\
    \ array in place, just use the Array.prototype.sort() method with the default\
    \ comparison.\nTo convert them to hexadecimals, use the String.prototype.toString()\
    \ method.\nHere is a small example, with some comments in the code to illustrate\
    \ what it does:\n\n<code>", "    if (arr.length === 0) {\n        return arr;\n\
    \    }\n    const result: number[] = [];\n    let next = 0;\n    for (let i =\
    \ 0; i < arr.length; ++i) {\n        while (next < arr.length && arr[next] < arr[i])\
    \ {\n            next++;\n        }\n        result.push(arr[i]);\n        if\
    \ (next === arr.length) {\n            result .push(-arr[i]);\n        }\n   \
    \ }\n    return result;\n}\n", "  if (arr.length === 0) {\n    return arr\n  }\n\
    \n  const maxOneCounts = arr.reduce((maxOneCounts, cur) => {\n    if (maxOneCounts[cur]\
    \ > maxOneCounts[cur + 1]) {\n      return maxOneCounts\n    } else {\n      maxOneCounts[cur\
    \ + 1] += 1\n      return maxOneCounts\n    }\n  }, [0])\n\n  const maxOneCount\
    \ = Math.max(...maxOneCounts)\n\n  if (maxOneCount === 0) {\n    return arr\n\
    \  }\n\n  let decimal = maxOneCount\n  const decimalIndex = 0\n  const decimalIndexArr\
    \ = new Array(maxOneCount).fill(-1)\n  while (decimal !== 0) {\n    const decimalCount\
    \ = Math.floor(decimal / 2)\n    decimalIndexArr.splice(decimalIndex, 0, decimalIndex)\n\
    \    decimal -= decimalCount * 2\n    decimal %= 2\n  }\n\n  const arrWithDecimalIndex\
    \ = arr.map((cur) => {\n    if (decimalIndexArr.indexOf(cur) > -1) {\n      return\
    \ cur\n    }\n\n    const decimalValue = maxOneCount - 1 - decimalIndexArr.indexOf(cur)\n\
    \    return decimalValue * cur\n  })\n\n  return arrWithDecimalIndex\n}\n", " \
    \   const result = [...arr];\n    for (let i = 0; i < arr.length; i++) {\n   \
    \     result[i] = result[i] > 0 ? result[i] - 1 : 0;\n    }\n    const resultReverse\
    \ = result.sort(function (a, b) {\n        return a - b;\n    });\n    for (let\
    \ i = 0; i < arr.length; i++) {\n        result[i] = resultReverse < 0 ? resultReverse[i]\
    \ : resultReverse;\n    }\n    return result.sort(function (a, b) {\n        return\
    \ a - b;\n    });\n}", "  if (!Array.isArray(arr)) {\n    throw new Error('Parameter\
    \ \"arr\" should be an array of numbers');\n  }\n\n  arr.sort((a, b) => {\n  \
    \  const diff = count_ones(a) - count_ones(b);\n    if (diff === 0) return count_ones(a)\
    \ - count_ones(b);\n    return diff;\n  });\n\n  return arr;\n}\n", "  let ret\
    \ = [];\n  let map = {};\n  for (let i = 0; i < arr.length; i++) {\n    const\
    \ num = arr[i];\n    if (map[num] === undefined) {\n      map[num] = 1;\n    \
    \  ret.push(num);\n    } else {\n      map[num]++;\n    }\n  }\n  for (let key\
    \ in map) {\n    ret.push(key);\n  }\n  return ret;\n}\n\n<|/ file filename=lib.es2017.full.d.ts\
    \ ext=.ts |>", "    let counter: number = 0;\n    for (let num of arr) {\n   \
    \     if (num >= 0) {\n            counter++;\n        }\n    }\n    counter =\
    \ counter * 2 + 1;\n    for (let i = counter; i < arr.length; i++) {\n       \
    \ arr.sort(function (a: number, b: number) {\n            return a - b;\n    \
    \    });\n    }\n    return arr;\n}\n", "    if (arr.length === 0) {\n       \
    \ return arr;\n    }\n    const len = arr.length;\n    let count = new Array(len);\n\
    \    count[0] = 0;\n    for (let i = 1; i < len; i++) {\n        count[i] = count[i\
    \ - 1] + arr[i - 1];\n    }\n    let ones_cnt = 0;\n    const max_cnt_of_ones\
    \ = count[0];\n    let min_cnt_of_ones = count[0];\n    for (let i = len - 1;\
    \ i > 0; i--) {\n        const one_cnt = arr[i - 1];\n        if (one_cnt > max_cnt_of_ones)\
    \ {\n            max_cnt_of_ones = one_cnt;\n        }\n        if (one_cnt <\
    \ min_cnt_of_ones) {\n            min_cnt_of_ones = one_cnt;\n        }\n    \
    \    count[i] = count[i - 1] + one_cnt;\n        const max_one_cnt = count[i];\n\
    \        if (max_one_cnt === max_cnt_of_ones) {\n            ones_cnt += 1;\n\
    \        }\n        else if (max_one_cnt === min_cnt_of_ones) {\n            ones_cnt\
    \ -= 1;\n        }\n    }\n    return arr.sort((a, b) => {\n        const a_one_cnt\
    \ = a[ones_cnt];\n        const b_one_cnt = b[ones_cnt];\n        return a_one_cnt\
    \ - b_one_cnt;\n    });\n}\n", "    for (let i = 0; i < arr.length; i++) {\n \
    \       arr[i] = ~~(arr[i] / 2);\n    }\n    return arr.sort((a, b) => a - b);\n\
    }\n", "\tlet counter = 0;\n\tconst len = arr.length;\n\tconst result = new Array(len);\n\
    \n\tfor (let i = 0; i < len; i++) {\n\t\tlet n = arr[i];\n\t\tconst p = counter\
    \ & 1;\n\t\tlet c = counter;\n\t\tcounter = counter >> 1;\n\n\t\tif (p === 1)\
    \ {\n\t\t\tc = ((c % 10) + 1) * 10;\n\t\t}\n\n\t\tresult[i] = c * n;\n\t}\n\n\t\
    return result;\n}\n", "  for (let i = 0; i < arr.length; i++) {\n    arr[i] =\
    \ sort_arr(arr[i]);\n  }\n  return arr;\n}\n", "  const ones = arr.reduce((acc,\
    \ val) => {\n    if (val) {\n      return acc + 1;\n    }\n    return acc;\n \
    \ }, 0);\n  const decimals = arr.reduce((acc, val) => {\n    if (val == 1) {\n\
    \      return acc + 1;\n    }\n    return acc;\n  }, 0);\n  const result = arr.sort((a,\
    \ b) => {\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n     \
    \ return 1;\n    }\n    return 0;\n  });\n  if (ones != arr.reduce((acc, val)\
    \ => {\n    return acc + val;\n  }, 0)) {\n    throw new Error('Incorrect number\
    \ of ones in binary representation of arr');\n  }\n  if (decimals != arr.reduce((acc,\
    \ val) => {\n    return acc + val;\n  }, 0)) {\n    throw new Error('Incorrect\
    \ number of decimal values in arr');\n  }\n  return result;\n}\n", "  for (let\
    \ i = 0; i < arr.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (arr[j]\
    \ % 2 === 0) {\n        let tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j]\
    \ = tmp;\n      }\n    }\n  }\n  return arr;\n}\n", "  let n = 0;\n  const len\
    \ = arr.length;\n  let temp;\n  let count = 0;\n  let num;\n  for (let i = 1;\
    \ i < len; i++) {\n    num = arr[i];\n    temp = n;\n    while (num) {\n     \
    \ if (num & 1) {\n        if (temp === count) {\n          arr[n++] = temp + 1;\n\
    \          count++;\n        } else {\n          arr[n++] = temp;\n          count++;\n\
    \          temp = n++;\n        }\n      } else {\n        temp = n++;\n     \
    \ }\n      num >>= 1;\n    }\n  }\n  arr[n] = temp;\n  return arr;\n}\n", "  return\
    \ arr.sort((a, b) => {\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\
    \    if (a === 0) {\n      return -1;\n    }\n    if (b === 0) {\n      return\
    \ 1;\n    }\n    const ones = Math.pow(2, Math.ceil(Math.log2(b)));\n    if (a\
    \ === b) {\n      return 0;\n    }\n    return Math.round(a * ones) / (ones -\
    \ Math.round(b * ones));\n  });\n}\n", "  return arr.sort((a, b) => {\n    return\
    \ binary_search(a, 1) === -1 ? binary_search(b, 1) : binary_search(b, 1) === -1\
    \ ? a - b : binary_search(a, 1) === -1 ? b - a : binary_search(b, 1) === -1 ?\
    \ binary_search(a, 1) - binary_search(b, 1) : binary_search(a, 1) === -1 ? binary_search(b,\
    \ 1) : binary_search(b, 1) - binary_search(a, 1);\n  });\n}\n", "  const newArr:\
    \ number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n    const ones = count_ones(arr[i]);\n\
    \    if (ones === 0) {\n      newArr.push(arr[i]);\n    } else if (ones === 1)\
    \ {\n      newArr.push(sort_number(arr[i]));\n    } else {\n      newArr.push(sort_number(arr[i]\
    \ * (1 << ones)));\n    }\n  }\n  return newArr;\n}\n", "  arr.sort((a, b) =>\
    \ {\n    const oneCount: number = bin(Math.abs(a)).length - 1; // -1 because of\
    \ the sign bit\n    const signCount: number = bin(Math.abs(b)).length - 1; //\
    \ -1 because of the sign bit\n    return signCount * oneCount - bin(a).length\
    \ - bin(b).length;\n  });\n  return arr;\n}\n", "    return arr.sort((a: number,\
    \ b: number) => {\n        if (a === b) {\n            return 0;\n        }\n\n\
    \        const ones = count_ones(a);\n        const bOnes = count_ones(b);\n\n\
    \        if (ones === bOnes) {\n            return a < b ? -1 : 1;\n        }\
    \ else {\n            return bOnes - ones;\n        }\n    });\n}\n", "    return\
    \ arr.sort((a: number, b: number) => {\n        if (a === b) {\n            return\
    \ 0;\n        } else if (a < b) {\n            return -1;\n        } else {\n\
    \            return 1;\n        }\n    });\n}\n", "  for (let i = 0; i < arr.length;\
    \ i++) {\n    const num = arr[i];\n    const cnt = (num === 1) ? 1 : Math.log2(num);\n\
    \    if (cnt === 0) continue;\n    const high = cnt * -1;\n    let low = cnt;\n\
    \    while (low > high) {\n      const mid = parseInt((high + low) / 2);\n   \
    \   if (arr[mid] > num) {\n        low = mid;\n      } else if (arr[mid] < num)\
    \ {\n        high = mid;\n      } else {\n        arr[mid] = arr[low];\n     \
    \   arr[low] = num;\n        arr[high] = arr[high];\n        arr[high + 1] = arr[high\
    \ + 1];\n        low = mid + 1;\n        high = cnt;\n      }\n    }\n  }\n  return\
    \ arr;\n}\n", "  const ones = arr.filter(num => num !== 0);\n  let decimal: number\
    \ | null = null;\n  let decimalIndex = 0;\n  do {\n    decimal = ones[decimalIndex];\n\
    \    decimalIndex += 1;\n  } while (decimal > 0);\n  let index: number = 0;\n\
    \  for (let i = 0; i < ones.length; i += 1) {\n    const numOnes = ones[i];\n\
    \    if (numOnes !== 0) {\n      ones[numOnes] = numOnes;\n      ones[i] = 0;\n\
    \    }\n    const isDecimal = ones[i] !== 0;\n    if (isDecimal) {\n      ones[decimalIndex]\
    \ = ones[decimalIndex] + 1;\n      ones[i] = 0;\n      decimalIndex += 1;\n  \
    \  }\n    if (isDecimal && index < arr.length - 1) {\n      const swapIndex =\
    \ index + 1;\n      ones[swapIndex] = ones[decimalIndex];\n      ones[decimalIndex]\
    \ = swapIndex;\n    }\n    index += 1;\n  }\n  return ones;\n}\n", "    arr.sort(function\
    \ (a, b) {\n        if (a.toString(2) > b.toString(2)) {\n            return -1;\n\
    \        } else if (a.toString(2) == b.toString(2)) {\n            return 0;\n\
    \        }\n        return 1;\n    });\n    return arr;\n}\n", "    const ones\
    \ = arr.filter(v => v !== 0);\n    return ones\n        .map(v => v / 2)\n   \
    \     .sort((a, b) => a - b)\n        .map(v => v * 2)\n        .map(v => v +\
    \ 1)\n        .concat(\n            ones\n                .map(v => v * 2)\n \
    \               .sort((a, b) => a - b)\n                .map(v => v - 1)\n   \
    \     );\n}\n", "    arr.sort((a: number, b: number) => {\n        if (a.binary()\
    \ === b.binary()) {\n            return a.decimal() - b.decimal();\n        }\
    \ else {\n            return a.binary() - b.binary();\n        }\n    });\n  \
    \  return arr;\n}\n", "  // sort by descending number of ones\n  arr.sort((a,\
    \ b) => b - a);\n  // sort by ascending decimal value\n  arr.sort((a, b) => a\
    \ - b);\n  return arr;\n}\n", "    return arr.sort((a: number, b: number) => {\n\
    \        if (a === b) return 0;\n\n        const a_ones = binToInt(a).toString(2).split('');\n\
    \        const b_ones = binToInt(b).toString(2).split('');\n\n        // We use\
    \ decimal value here.\n        // Because the number of ones in binary representation\n\
    \        // of the number is same.\n        // We compare decimal value of twos\
    \ compliment of each\n        // binary number.\n        return +a_ones[a_ones.length\
    \ - 1] - +b_ones[b_ones.length - 1];\n    });\n}\n", "  // Only change code below\
    \ this line\n  console.log('sort_array start');\n  const sorted = [...arr];\n\
    \  sorted.sort((a, b) => {\n    const diff = a.toString(2).length - b.toString(2).length;\n\
    \    if (diff !== 0) {\n      return diff;\n    }\n    return a > b ? 1 : a <\
    \ b ? -1 : 0;\n  });\n  console.log('sort_array end');\n  return sorted;\n}\n",
  "    return arr.sort((a, b) => a > b ? 1 : -1);\n}\n", "    const map = {};\n  \
    \  arr.forEach(v => {\n        const key = bin(v);\n        if (!map[key]) {\n\
    \            map[key] = [];\n        }\n        map[key].push(v);\n    });\n \
    \   const sorted = [];\n    for (const key in map) {\n        map[key].sort((a,\
    \ b) => bin(a).localeCompare(bin(b)));\n        sorted.push(...map[key]);\n  \
    \  }\n    return sorted;\n}", "  arr.sort((a: number, b: number) => {\n    return\
    \ +(a.toString() === b.toString()) ? a - b : a.toString().localeCompare(b.toString());\n\
    \  });\n  return arr;\n}\n", "\tconst len = arr.length;\n\tconst swap = function\
    \ (a1: number, a2: number) {\n\t\tconst temp = a1;\n\t\ta1 = a2;\n\t\ta2 = temp;\n\
    \t};\n\tfor (let i = 1; i < len; ++i) {\n\t\tconst a1 = arr[i];\n\t\tconst a2\
    \ = arr[i - 1];\n\t\tif (a2 < a1) swap(a1, a2);\n\t}\n\treturn arr;\n}\n", " \
    \   return arr.sort((a: number, b: number) => {\n        if (a === b) {\n    \
    \        return 0;\n        } else if (a > b) {\n            return -1;\n    \
    \    } else {\n            return 1;\n        }\n    });\n}\n", "  return arr.sort((a:\
    \ number, b: number) => a > b ? 1 : a < b ? -1 : 0);\n}\n", "  arr.sort((a, b)\
    \ => {\n    return count_ones(a) - count_ones(b);\n  });\n  return arr;\n}\n",
  "  arr.sort((a: number, b: number) => {\n    return count_ones_in_binary_array(a)\
    \ - count_ones_in_binary_array(b);\n  });\n  return arr;\n}\n", "  const result\
    \ = [...arr];\n  result.sort((a: number, b: number) => {\n    const strA = convertToString(a\
    \ >>> 0).toLowerCase();\n    const strB = convertToString(b >>> 0).toLowerCase();\n\
    \    const arrA = convertToBinString(strA);\n    const arrB = convertToBinString(strB);\n\
    \    return arrA.length - arrB.length;\n  });\n  return result;\n}\n", "  arr.sort((a:\
    \ number, b: number) => a > b ? 1 : a < b ? -1 : 0);\n  return arr;\n}", "  return\
    \ arr.sort((a, b) => count_ones(b) - count_ones(a) || a - b)\n}\n", "  arr.sort((a,\
    \ b) => {\n    if (a > b) return 1;\n    if (a < b) return -1;\n    return 0;\n\
    \  });\n  return arr;\n}\n", "  return arr.sort(function(a, b) {\n    return arr.indexOf(a)\
    \ - arr.indexOf(b);\n  });\n}\n", "    arr.sort((a, b) => a > b ? 1 : a < b ?\
    \ -1 : 0);\n    return arr;\n}\n", "  const result = []\n  for (let i = 0; i <\
    \ arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if\
    \ (arr[i] == 1) {\n        result.push(j)\n        break\n      }\n    }\n  }\n\
    \  result.sort(function (a: number, b: number) {\n    return a - b\n  })\n  return\
    \ result\n}\n", "  // Sort the array based on the given order\n  const sortFunc:\
    \ (a: number, b: number) => number = (a, b) => {\n    if (a === 0) return 1\n\
    \    if (b === 0) return -1\n    if (a === b) return 0\n    if (a < b) return\
    \ -1\n    if (a > b) return 1\n  }\n  return arr.sort(sortFunc)\n}\n", "  const\
    \ len = arr.length;\n  const max = Math.max(...arr);\n  const ones: number[] =\
    \ [];\n\n  for (let i = 1; i < len; i++) {\n    const val = arr[i];\n    ones.push((val\
    \ - max) * Math.pow(2, i));\n  }\n\n  ones.push(0);\n\n  return arr.sort((a, b)\
    \ => b - a).map((val) => val + ones[val]);\n}\n", "  let zeroCount = 0;\n  let\
    \ oneCount = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] ===\
    \ 0) {\n      zeroCount++;\n    } else {\n      oneCount++;\n    }\n  }\n  const\
    \ base = Math.pow(2, Math.ceil(Math.log(oneCount) / Math.log(2)));\n  const sorted\
    \ = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === 0) {\n \
    \     continue;\n    }\n    let temp = parseInt(Math.pow(base, i).toString(2),\
    \ 2);\n    while (oneCount !== 0) {\n      oneCount--;\n      temp = parseInt(temp.toString(2),\
    \ 2);\n    }\n    temp = parseInt(temp.toString(2), 2);\n    sorted.push(temp);\n\
    \  }\n  return sorted;\n}\n", "  const counts: number[] = [];\n  const nums =\
    \ arr.map(n => count_1(n));\n  for (const [k, v] of Object.entries(nums)) {\n\
    \    counts.push(v);\n  }\n  return arr.sort((a, b) => counts[a] - counts[b]);\n\
    }\n", "    let result = [];\n    arr.forEach((n: number) => {\n        result[result.length]\
    \ = (n + 1) % 2 === 1 ? n : -n;\n    });\n    return result.sort((a, b) => a -\
    \ b);\n}\n", "    arr.sort((a, b) => count_ones(a) - count_ones(b));\n    arr.sort((a,\
    \ b) => a - b);\n    return arr;\n}", "  for (let i = 0; i < arr.length; i++)\
    \ {\n    const n = arr[i];\n    for (let j = 0; j < arr.length; j++) {\n     \
    \ if (j > i && isOnes(n)) {\n        arr[j] = -arr[j];\n      }\n    }\n  }\n\
    \  arr.sort((a: number, b: number) => a - b);\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    arr[i] = arr[i] % 10;\n  }\n  return arr;\n}\n", "\tconst a = new\
    \ Array();\n\tlet cnt = 0;\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tlet\
    \ d = count_ones(arr[i]);\n\t\ta.push(arr[i]);\n\t\tcnt += d;\n\t\tif (cnt ===\
    \ arr.length) break;\n\t}\n\tlet b = new Array();\n\tfor (let i = 0; i < a.length;\
    \ i++) {\n\t\tlet d = count_ones(a[i]);\n\t\tb.push(a[i]);\n\t\twhile (d > 0)\
    \ {\n\t\t\tlet d = d >> 1;\n\t\t\tb.push(a[i]);\n\t\t}\n\t}\n\treturn b;\n}\n",
  "  return arr.sort((a, b) => {\n    const binA = bin(a)\n    const binB = bin(b)\n\
    \n    let onesA = 0\n    let onesB = 0\n\n    for (let i = 0; i < binA.length;\
    \ i++) {\n      if (binA[i] === '1') {\n        onesA++\n      }\n    }\n\n  \
    \  for (let i = 0; i < binB.length; i++) {\n      if (binB[i] === '1') {\n   \
    \     onesB++\n      }\n    }\n\n    if (onesA === onesB) {\n      const decA\
    \ = dec(a)\n      const decB = dec(b)\n\n      return decA - decB\n    }\n\n \
    \   return onesA - onesB\n  })\n}\n", "  // Sort based on the number of ones\n\
    \  arr.sort((a, b) => count_ones(a) - count_ones(b));\n\n  // If there are equal\
    \ number of ones, sort based on decimal value\n  arr.sort((a, b) => (count_ones(a)\
    \ - count_ones(b)) || (a - b));\n\n  return arr;\n}\n", "    for (let i = 0; i\
    \ < arr.length; i++) {\n        arr[i] = arr[i].toString();\n    }\n    arr.sort();\n\
    \    for (let i = 0; i < arr.length; i++) {\n        arr[i] = parseInt(arr[i],\
    \ 2);\n    }\n    return arr;\n}\n", "  const map = new Map();\n  const sorted\
    \ = [...arr];\n  for (let i = sorted.length - 1; i >= 0; i--) {\n    let key =\
    \ sorted[i].toString(2);\n    const val = map.get(key);\n    if (!val || val[0]\
    \ < sorted[i - 1]) {\n      map.set(key, sorted[i]);\n    }\n  }\n  const result\
    \ = [];\n  for (let i = 0; i < sorted.length; i++) {\n    const key = sorted[i].toString(2);\n\
    \    const val = map.get(key);\n    if (val) {\n      result.push(val[1]);\n \
    \   }\n  }\n  return result;\n}\n\nconst arr1 = sort_array([-20, 1, -3, 5, 2,\
    \ -4, 1]);\nconst arr2 = sort_array([1, 2, 3, 4, 5]);\nconst arr3 = sort_array([2,\
    \ 2, 4, 8, 5]);\nconst arr4 = sort_array([-2, 0, -4, 4, -2, 1]);\nconst arr5 =\
    \ sort_array([1, 2, 3, 4, 5]);\nconst arr6 = sort_array([1, 2, 3, 4, 5]);\nconst\
    \ arr7 = sort_array([-20, 1, -3, 5, 2, -4, 1]);\nconst arr8 = sort_array([1, 2,\
    \ 3, 4, 5]);\n\nconst arr9 = sort_array([1, 2, 3, 4, 5]);\nconst arr10 = sort_array([1,\
    \ -2, 3, 4, 5, -1]);\nconst arr11 = sort_array([-20, 1, -3, 5, 2, -4, 1]);\nconst\
    \ arr12 = sort_array([1, -2, 3, 4, 5, -1]);\nconst arr13 = sort_array([1, 2, 3,\
    \ 4, 5]);\nconst arr14 = sort_array([1, 2, 3, 4, 5]);\nconst arr15 = sort_array([1,\
    \ -2, 3, 4, 5, -1]);\nconst arr16 = sort_array([1, 2, 3, 4, 5]);\nconst arr17\
    \ = sort_array([-20, 1, -3, 5, 2, -4, 1]);\nconst arr18 = sort_array([1, -2, 3,\
    \ 4, 5, -1]);\nconst arr19 = sort_array([-20, 1, -3, 5, 2, -4, 1]);\nconst arr20\
    \ = sort_array([1, -2, 3, 4, 5, -1]);\nconst arr21 = sort_array([-20, 1, -3, 5,\
    \ 2, -4, 1]);\nconst arr22 = sort_array([1, -2, 3, 4, 5, -1]);\nconst arr23 =\
    \ sort_array([1, 2, 3, 4, 5]);\nconst arr24 = sort_array([1, 2, 3, 4, 5]);\nconst\
    \ arr25 = sort_array([1, 2, 3, 4, 5]);\nconst arr26 = sort_array([1, -2, 3, 4,\
    \ 5, -1]);\nconst arr27 = sort_array([1, 2, 3, 4, 5]);\nconst arr28 = sort_array([1,\
    \ 2, 3, 4, 5]);\nconst arr29 = sort_array([1, 2, 3, 4, 5]);\nconst arr30 = sort_array([-20,\
    \ 1, -3, 5, 2, -4, 1]);\nconst arr31 = sort_array([1, -2, 3, 4, 5, -1]);\nconst\
    \ arr32 = sort_array([1, 2, 3, 4, 5]);\nconst arr33 = sort_array([1, 2, 3, 4,\
    \ 5]);\nconst arr34", "    const len = arr.length;\n    const max = -1;\n    let\
    \ count: number;\n    for (let i = 0; i < len; i++) {\n        count = count_ones(arr[i]);\n\
    \        if (count > 0) {\n            if (max < count) {\n                max\
    \ = count;\n            }\n        } else {\n            max = -1;\n        }\n\
    \    }\n    if (max >= 0) {\n        return arr.sort((a, b) => count_ones(b) -\
    \ count_ones(a) || a - b);\n    }\n    return arr.sort((a, b) => a - b);\n}",
  "  arr.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n   \
    \ return 0\n  })\n  return arr\n}\n", "  for (let i = 0; i < arr.length; i++)\
    \ {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] == 1) break;\n\
    \      if (arr[j] == 1) break;\n      if (arr[j] > arr[i]) break;\n    }\n   \
    \ if (j == arr.length) arr.push(arr[i]);\n  }\n  return arr;\n}\n", "  if (arr.length\
    \ <= 1) return arr;\n  const ones: number[] = [];\n  let idx = 0;\n  let cnt =\
    \ 0;\n  while (idx < arr.length) {\n    if (arr[cnt] === 1) ones.push(arr[cnt]);\n\
    \    idx += cnt;\n    cnt += arr[++cnt] ? 1 : -1;\n  }\n  return ones\n    .sort((a,\
    \ b) => a > b ? 1 : -1)\n    .concat(arr.slice(idx));\n}\n", "  const res: number[]\
    \ = Array(arr.length).fill(0).map((_: number, i: number) => i);\n  res.sort((a,\
    \ b) => {\n    let [x, y] = [a, '', b];\n    while (y !== 0) {\n      x = (x ^\
    \ y) * 256;\n      y = (y / 256) - x;\n    }\n    return x;\n  });\n  return res;\n\
    }\n", "  for (let i = 0; i < arr.length; i++) {\n    const left = arr.slice(0,\
    \ i);\n    const right = arr.slice(i + 1, arr.length);\n    const leftCount =\
    \ 0;\n    const rightCount = 0;\n    for (let j = 0; j < left.length; j++) {\n\
    \      if (left[j] === 1) leftCount++;\n    }\n    for (let j = 0; j < right.length;\
    \ j++) {\n      if (right[j] === 1) rightCount++;\n    }\n    if (leftCount >\
    \ rightCount) {\n      for (let j = 0; j < left.length; j++) {\n        arr[j]\
    \ += left[j];\n      }\n    } else if (rightCount > leftCount) {\n      for (let\
    \ j = 0; j < right.length; j++) {\n        arr[j] += right[j];\n      }\n    }\n\
    \  }\n  return arr;\n}\n", "    for(let i = 0; i < arr.length; i++) {\n      \
    \  if(arr[i] === 0) {\n            continue;\n        }\n\n        for(let j =\
    \ arr.length - 1; j >= i; j--) {\n            if(arr[j] > 0) {\n             \
    \   break;\n            }\n\n            if(arr[j] === 0) {\n                let\
    \ temp = arr[j + 1];\n                arr[j + 1] = arr[j];\n                arr[j]\
    \ = temp;\n                j--;\n            }\n        }\n    }\n    return arr;\n\
    }\n", "  if (!Array.isArray(arr)) return arr;\n\n  return arr.sort((a: number,\
    \ b: number) => {\n    const zeroToThree =\n      Math.floor((a - 1) / 3) *\n\
    \      3 +\n      Math.floor((b - 1) / 3) *\n      3 +\n      1 -\n      a -\n\
    \      b;\n    const oneToSixThree = a % 3;\n    const twoToSeven = b % 3;\n \
    \   const oneToSixThreeBit = oneToSixThree >> 3;\n    if (oneToSixThreeBit ===\
    \ 0) {\n      return zeroToThree - twoToSeven;\n    }\n    if (oneToSixThreeBit\
    \ === 1) {\n      return zeroToThree - oneToSixThree;\n    }\n    return zeroToThree\
    \ - oneToSixThree - twoToSeven;\n  });\n}\n", "  arr.sort(function (a, b) {\n\
    \    // Sort based on binary value\n    if (a === 0) return -b;\n    if (b ===\
    \ 0) return a;\n    return a > b ? 1 : -1;\n  });\n  return arr;\n}\n", "  const\
    \ numOfOnes = arr.reduce((a, b) => a + b, 0);\n  const sortedArr = arr.sort((a:\
    \ number, b: number) => a - b);\n  const decimalValue = numOfOnes / (sortedArr.length\
    \ * 2);\n  return sortedArr.map((_, i) => decimalValue * i);\n}\n", "\tfor (let\
    \ i = arr.length - 1; i > 0; i--) {\n\t\tconst num = arr[i];\n\t\tlet j;\n\t\t\
    for (j = i - 1; j >= 0; j--) {\n\t\t\tif (num & 1) {\n\t\t\t\tconst temp: number\
    \ = arr[j + 1];\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn arr;\n}\n", "  const sortedArr = arr.sort((a, b) => {\n\
    \    const oneCountA = countOnes(a);\n    const oneCountB = countOnes(b);\n  \
    \  if (oneCountA === oneCountB) {\n      // sort on decimal value\n      return\
    \ a - b;\n    }\n    return oneCountA - oneCountB;\n  });\n  return sortedArr;\n\
    }\n", "  const len = arr.length;\n  if (len < 2) {\n    return arr;\n  }\n  let\
    \ first = 1;\n  let last = len;\n  while (first < last) {\n    const mid = Math.floor((first\
    \ + last) / 2);\n    if (arr[mid] > arr[mid+1]) {\n      last = mid - 1;\n   \
    \ } else {\n      first = mid + 1;\n    }\n  }\n  return arr.slice(first, last);\n\
    }\n", "    if (arr.length === 0) {\n        return arr;\n    }\n\n    // Sort\
    \ the array first\n    arr.sort(\n        (a, b) =>\n            a === b ? 0 :\n\
    \                a < b ? -1 :\n                    1\n    );\n\n    // Go through\
    \ the array again and sort based on the decimal value of 1\n    for (let i = 0;\
    \ i < arr.length; i++) {\n        const ones = arr[i].toString(2).length - 1;\n\
    \        if (ones === 1) {\n            arr[i] = parseInt(arr[i], 10);\n     \
    \   } else {\n            let decimal = Math.pow(8, ones);\n            if (decimal\
    \ > arr[i]) {\n                arr[i] = decimal - arr[i];\n            }\n   \
    \     }\n    }\n\n    return arr;\n}\n", "  arr.sort((a: number, b: number) =>\
    \ {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return\
    \ -1;\n    } else {\n      return 0;\n    }\n  });\n  return arr;\n}\n", "\tconst\
    \ result: number[] = [];\n\tlet maxOnes = 0;\n\tlet minOnes = 0;\n\tfor (let i\
    \ = 0; i < arr.length; i++) {\n\t\tconst bin = binary_to_decimal(arr[i]);\n\t\t\
    const binCount = (bin.match(/10/g) || []).length;\n\t\tif (binCount > maxOnes)\
    \ {\n\t\t\tmaxOnes = binCount;\n\t\t}\n\t\tif (binCount < minOnes) {\n\t\t\tminOnes\
    \ = binCount;\n\t\t}\n\t}\n\tif (maxOnes < minOnes) {\n\t\tmaxOnes = minOnes;\n\
    \t\tresult.sort((a, b) => b - a);\n\t} else {\n\t\tresult.sort((a, b) => {\n\t\
    \t\tif (a < b) return -1;\n\t\t\tif (a > b) return 1;\n\t\t\treturn 0;\n\t\t});\n\
    \t}\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tresult[i] = binary_to_decimal(arr[i]);\n\
    \t}\n\treturn result;\n}\n", "  return arr\n    .sort((a: number, b: number) =>\
    \ {\n      if (a === 0) return -1;\n      if (b === 0) return 1;\n      return\
    \ a > b ? 1 : -1;\n    });\n}\n", "  const zeroBits: number = Math.log2(Math.abs(arr[0]));\n\
    \  const positiveBits: number = (zeroBits - Math.floor(zeroBits));\n  const positiveBitsLength:\
    \ number = positiveBits === 0 ? 1 : positiveBits;\n  const negativeBits: number\
    \ = Math.log2(Math.abs(arr[arr.length - 1]));\n  const negativeBitsLength: number\
    \ = negativeBits === 0 ? 1 : negativeBits;\n  const positiveBitsLengthNumber:\
    \ number = Math.floor(positiveBitsLength);\n  const negativeBitsLengthNumber:\
    \ number = Math.floor(negativeBitsLength);\n  const length: number = arr.length;\n\
    \n  let positiveBitsLengthNumberLastIndex: number;\n  let negativeBitsLengthNumberLastIndex:\
    \ number;\n\n  if (positiveBitsLengthNumber === 0) positiveBitsLengthNumberLastIndex\
    \ = 1;\n  else if (positiveBitsLengthNumber === 1) positiveBitsLengthNumberLastIndex\
    \ = 0;\n  else positiveBitsLengthNumberLastIndex = arr.length - positiveBitsLengthNumber\
    \ - 1;\n  if (negativeBitsLengthNumber === 0) negativeBitsLengthNumberLastIndex\
    \ = 1;\n  else if (negativeBitsLengthNumber === 1) negativeBitsLengthNumberLastIndex\
    \ = 0;\n  else negativeBitsLengthNumberLastIndex = arr.length - negativeBitsLengthNumber\
    \ - 1;\n\n  const arrSorted: number[] = [];\n  for (let index: number = 0; index\
    \ < length; index++) {\n    if (index < positiveBitsLengthNumberLastIndex) {\n\
    \      arrSorted.push(arr[index]);\n    } else if (index < negativeBitsLengthNumberLastIndex)\
    \ {\n      arrSorted.push(arr[arr.length - 1 - index]);\n    } else {\n      arrSorted.push(Math.abs(arr[index]));\n\
    \    }\n  }\n  return arrSorted;\n}\n", "  // sort descending based on binary\
    \ value of each number\n  return arr.sort((a: number, b: number) => { return (a\
    \ < b) ? -1 : (a > b) ? 1 : 0; });\n}\n", "  return arr.sort((a, b) => {\n   \
    \ if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n}\n", " \
    \   // Write your code here.\n}\n", "  arr.sort(function (a, b) { return a - b;\
    \ });\n  return arr;\n}\n", "  const n = arr.length;\n  for (let i = 0; i < n\
    \ - 1; i++) {\n    for (let j = 0; j < n - i - 1; j++) {\n      if (arr[j] > arr[j\
    \ + 1]) {\n        const tmp = arr[j];\n        arr[j] = arr[j + 1];\n       \
    \ arr[j + 1] = tmp;\n      }\n    }\n  }\n  return arr;\n}\n", "  const len =\
    \ arr.length;\n  for (let i = 0; i < len; i++) {\n    const val = getBits(arr,\
    \ i);\n    const idx = i === 0 ? getBits(arr, len - 1) : getBits(arr, i - 1);\n\
    \    if (val === 1) {\n      swap(arr, i, idx);\n    }\n  }\n  return arr;\n}\n",
  "    \n}", "  const newArray: number[] = [];\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    newArray.push([...arr[i]].sort((a, b) => b - a));\n  }\n  return\
    \ newArray;\n}\n", "  const l = arr.length;\n  if (l === 0) {\n    return arr;\n\
    \  }\n  const a0 = arr[0];\n  const a1 = arr[l-1];\n  const a2 = arr[2];\n  const\
    \ a3 = arr[3];\n  const a4 = arr[4];\n  if (a0 === a1) {\n    if (a2 === a3) {\n\
    \      return [\n        a0, a2, a4, a3, a1,\n      ];\n    } else {\n      return\
    \ [\n        a0, a1, a3, a4, a2,\n      ];\n    }\n  } else {\n    if (a0 ===\
    \ a2) {\n      return [\n        a0, a1, a3, a4, a2,\n      ];\n    } else {\n\
    \      return [\n        a0, a1, a2, a3, a4,\n      ];\n    }\n  }\n}\n", "  const\
    \ len = arr.length;\n  if (len === 0) return arr;\n\n  let maxBits = 0;\n  let\
    \ minBits = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < len; i++) {\n    const\
    \ bits = count_bits(arr[i]);\n    minBits = Math.min(minBits, bits);\n    maxBits\
    \ = Math.max(maxBits, bits);\n  }\n\n  const maxExp = Math.floor(Math.log(maxBits)\
    \ / Math.LN2);\n  const minExp = Math.floor(Math.log(minBits) / Math.LN2);\n \
    \ if (maxExp - minExp < 1) {\n    return arr;\n  }\n\n  // create an array with\
    \ more bits than maxBits\n  const maxPower2 = maxBits + 1;\n  const maxPower2Len\
    \ = len - maxPower2;\n  const newLen = Math.ceil(Math.pow(2, maxPower2Len) * Math.LN2);\n\
    \  const newArr = new Uint32Array(newLen);\n\n  // initialize newArr\n  for (let\
    \ i = 0; i < newLen; i++) {\n    newArr[i] = 0;\n  }\n\n  let curLen = 0;\n  let\
    \ cur = 0;\n  // step 1: generate 2^maxPower2Len number sequence\n  while (curLen\
    \ < maxPower2Len) {\n    const newVal = cur + curLen;\n    for (let j = 0; j <\
    \ len; j++) {\n      const bits = count_bits(arr[j]);\n      if (bits >= maxBits)\
    \ {\n        throw new Error(\n            `Cannot sort array by length. The number\
    \ of bits is too big. ` +\n            `Maximum length is ${maxBits}. Got ${bits}.`);\n\
    \      }\n      if (bits === maxBits) {\n        // if the number of ones in arr[j]\
    \ equals the number of ones in\n        // newVal, push it to the result array\n\
    \        if (newVal >= newLen) {\n          throw new Error(\n              `Cannot\
    \ sort array by length. Length ${newLen} is not big enough to hold all the numbers\
    \ in ${arr}`);\n        }\n        newArr[newVal] += 1;\n        break;\n    \
    \  }\n      newArr[newVal] += 1;\n      newVal += bits;\n    }\n    cur += curLen;\n\
    \    curLen++;\n  }\n\n  // step 2: find maxBits-1 number sequence\n  let j =\
    \ 0;\n  for (let i = 0; i < newLen; i++) {\n    const bits = count_bits(newArr[i]);\n\
    \    if (bits === maxBits) {\n      newArr[j++] = i;\n    } else {\n      break;\n\
    \    }\n  }\n  // step 3: add 0 to the number sequences that are longer\n  while\
    \ (j < newLen) {\n    newArr[++j] = 0;\n  }\n\n  return newArr;\n}\n", "  if (arr.length\
    \ <= 1) {\n    return arr;\n  }\n\n  const ones: number[] = arr.filter((x) =>\
    \ x === 1);\n  ones.sort((a, b) => a - b);\n\n  for (let i = ones.length - 1;\
    \ i > 0; i--) {\n    const j = i;\n    for (let k = j - 1; k >= 0; k--) {\n  \
    \    if (ones[k] > ones[j]) {\n        swap(arr, j, k);\n      }\n    }\n  }\n\
    \n  return arr;\n}\n", "    const copyArr = arr.slice(0);\n    copyArr.sort((a:\
    \ number, b: number) => a - b);\n    return copyArr;\n}\n", "    const maxLen\
    \ = arr.length\n    let max: number = 0\n    for (let i = maxLen - 1; i >= 0;\
    \ i--) {\n        const cur = arr[i]\n        if (cur > max) {\n            max\
    \ = cur\n        }\n    }\n    for (let i = maxLen - 1; i >= 0; i--) {\n     \
    \   const cur = arr[i]\n        if (cur > max) {\n            max = cur\n    \
    \    }\n    }\n    const maxIdx = (max - 1).toString(2).length - 1\n    const\
    \ numArr = []\n    for (let i = 0; i < maxLen; i++) {\n        numArr.push(arr[i].toString(2).padStart(maxIdx,\
    \ '0'))\n    }\n    return numArr.sort((a, b) => b - a)\n}\n", "    const result\
    \ = [...arr];\n    let numOnes = 0;\n    let startIndex = 0;\n    for (let i =\
    \ 0; i < result.length; i++) {\n        while (result[i] === 1) {\n          \
    \  numOnes++;\n            startIndex = i;\n            result[i] = result[i]\
    \ - 1;\n        }\n    }\n    const sortedResult = result;\n    sortedResult.sort(function\
    \ (a: number, b: number) {\n        const numA = a;\n        const numB = b;\n\
    \        let comparison = 0;\n        if (numA < numB) {\n            comparison\
    \ = 1;\n        } else if (numA > numB) {\n            comparison = -1;\n    \
    \    } else {\n            const decimalA = numA.toString().split('')\n      \
    \          .reverse()\n                .reduce((acc, val) => acc + +val, 0);\n\
    \            const decimalB = numB.toString().split('')\n                .reverse()\n\
    \                .reduce((acc, val) => acc + +val, 0);\n            comparison\
    \ = decimalA - decimalB;\n        }\n        return comparison;\n    });\n   \
    \ for (let i = startIndex; i < result.length; i++) {\n        result[i] = sortedResult[i];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=sorting,javascript |>\n<| a\
    \ tags=sorting,javascript dscore=0 |>\nAnother alternative in javascript that\
    \ does not require you to count the number of ones in the array is\n<code>\nconst\
    \ sorted = myArray.sort((a,b) => myArray.indexOf(a) - myArray.indexOf(b));\n</code>\n\
    <|/ a |>\n<| c |>\nThis has quadratic runtime (as you mentioned) and only works\
    \ if all elements are unique. If there are duplicate elements, you get a wrong\
    \ result. You need to sort the array first and get the `indexOf` values after\
    \ that.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nvar array = [1, 2, 3, 1]\nvar sorted\
    \ = array.sort(function(a, b) {\n  return array.indexOf(a) - array.indexOf(b);\n\
    })\nconsole.log(sorted)</code>\n\nSort the array first and get the index values\
    \ after that.\n<|/ a tags=sorting,javascript |>\n<| c |>\nThis has quadratic runtime\
    \ (as you mentioned) and only works if all elements are unique. If there are duplicate\
    \ elements, you get a wrong result. You need to sort the array first and get the\
    \ `indexOf` values after that.\n<|/ c |>\n<| c |>\n: This is actually the best\
    \ answer to this question. It doesn't require you to count the number of ones\
    \ in the array. `indexOf` can return `-1` if the value is `NaN`. So you can return\
    \ `0` if the value is `NaN`.\n<|/ c |>\n<| c |>\n`indexOf` can return `-1` if\
    \ the value is `NaN`. That's what I ", "  for (let i = 0; i < arr.length; i++)\
    \ {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[j] - arr[i]\
    \ === 0) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j]\
    \ = temp;\n      }\n    }\n  }\n  return arr;\n}\n", "    return arr.sort((a,\
    \ b) => {\n        if (a.length != b.length) {\n            return a.length -\
    \ b.length;\n        }\n        for (let i = 0; i < a.length; i++) {\n       \
    \     if (a[i] != b[i]) {\n                return a[i] - b[i];\n            }\n\
    \        }\n        return 0;\n    });\n}\n", "  const arr2: string[] = [];\n\n\
    \  for (let i = 0; i < arr.length; i++) {\n    const bin = binary(arr[i]).split('').reverse().join('');\n\
    \    let count = 1;\n    for (let j = 0; j < bin.length; j++) {\n      if (bin[j]\
    \ === '1') {\n        count += 1;\n      } else {\n        count -= 1;\n     \
    \ }\n      if (count < 0) {\n        break;\n      }\n    }\n\n    arr2.push(count);\n\
    \  }\n\n  return arr2.sort((a, b) => {\n    return b - a;\n  });\n}\n", "    let\
    \ len = arr.length;\n    if (len < 2) {\n        return arr;\n    }\n\n    for\
    \ (let i = 0; i < len - 1; i++) {\n        let j;\n        let min = i;\n    \
    \    for (j = i + 1; j < len; j++) {\n            if (arr[j] < arr[min]) {\n \
    \               min = j;\n            }\n        }\n        if (min === i) {\n\
    \            continue;\n        }\n\n        let temp = arr[min];\n        arr[min]\
    \ = arr[i];\n        arr[i] = temp;\n    }\n\n    return arr;\n}\n", "  arr.sort((a,\
    \ b) => a < b ? -1 : a == b ? 0 : 1);\n  return arr;\n}\n", "  let newArr = new\
    \ Array(arr.length).fill(null);\n  for (let i = 0; i < arr.length; i++) {\n  \
    \  let index = arr.indexOf(i + 1);\n    if (index !== -1) {\n      newArr[index]\
    \ = arr[i];\n    }\n  }\n  newArr.sort((a, b) => a.indexOf(b) - b.indexOf(a));\n\
    \  return newArr;\n}", "    return arr.sort((a: number, b: number) => {\n    \
    \    const as = a.toString(2);\n        const bs = b.toString(2);\n        if\
    \ (as === bs) return 0;\n        if (as.length > bs.length) return 1;\n      \
    \  if (as.length < bs.length) return -1;\n        return as < bs ? -1 : 1;\n \
    \   });\n}\n", "    arr.sort((a: number, b: number) => {\n        return a > b\
    \ ? 1 : a < b ? -1 : 0;\n    });\n    return arr;\n}\n", "  for (let i = 1; i\
    \ < arr.length; i++) {\n    for (let j = i; j > 0; j--) {\n      if (arr[j] <\
    \ arr[j - 1]) {\n        const temp = arr[j];\n        arr[j] = arr[j - 1];\n\
    \        arr[j - 1] = temp;\n      }\n    }\n  }\n  return arr;\n}\n", "  const\
    \ bin: Array<string> = arr.reduce((bin: Array<string>, num: number, idx: number)\
    \ => {\n    const binString: string = num.toString(2);\n    return bin.concat(binString.padStart(6,\
    \ \"0\"));\n  }, []);\n  return bin.sort((a, b) => a.length - b.length).map((num:\
    \ number) => parseInt(num, 2));\n}\n", "    for (let i = 0; i < arr.length; i++)\
    \ {\n        const a = arr[i];\n        let b = i;\n        for (let j = i + 1;\
    \ j < arr.length; j++) {\n            if (arr[j] > a) {\n                b = j;\n\
    \            }\n        }\n        const temp = a;\n        a = b;\n        a\
    \ = temp - a * 2;\n    }\n    return arr;\n}\n", "  return arr.sort((a, b) =>\
    \ {\n    let aa = a.toString(2);\n    let bb = b.toString(2);\n    if (aa < bb)\
    \ {\n      return -1;\n    } else if (aa > bb) {\n      return 1;\n    } else\
    \ {\n      return 0;\n    }\n  });\n}\n", "  const newArr = arr.sort((a: number,\
    \ b: number) => {\n    const ones = count_ones(a);\n    if (ones === 0) {\n  \
    \    return count_ones(b);\n    }\n    return count_ones(b) - count_ones(a);\n\
    \  });\n  return newArr;\n}", "    const n = arr.length;\n    let sorted: number[]\
    \ = [];\n    let counter: number = 0;\n    const ones: number[] = [];\n    for\
    \ (let i = 0; i < n; ++i) {\n        const v = arr[i];\n        if (v !== 0) {\n\
    \            counter++;\n        }\n        else {\n            ones.push(counter);\n\
    \            counter = 0;\n        }\n        sorted.push(v);\n    }\n    if (ones.length\
    \ > 1) {\n        ones = ones\n            .map(x => +(\"\" + x).replace(/^1/g,\
    \ m => String.fromCharCode(m > 9 ? m : m-9)))\n            .sort((a, b) => a -\
    \ b);\n        sorted = sorted\n            .map(v => ones.findIndex(y => v >=\
    \ y))\n            .map(x => x + counter);\n    }\n    return sorted.map(x =>\
    \ arr[x]);\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is a solution\
    \ without using an auxiliary array:\n<code>", "  var len = arr.length;\n  var\
    \ cnt = 0;\n  var maxCnt = Math.floor(len / 4) - 1;\n\n  // O(n) time, O(1) space\n\
    \  for (var i = maxCnt; i >= 0; i--) {\n    // cntOnes[i] counts number of 1s\
    \ in arr[i]\n    for (var j = i - cnt; j <= i + cnt; j++) {\n      if (arr[j]\
    \ < arr[i - cnt]) {\n        // swap\n        var tmp = arr[j];\n        arr[j]\
    \ = arr[i - cnt];\n        arr[i - cnt] = tmp;\n      }\n    }\n    cnt += maxCnt\
    \ - i;\n  }\n\n  return arr;\n}", "    return arr.sort((a, b) => {\n        const\
    \ rev = a < 0;\n        if (rev) return 1;\n        return b ? -1 : 1;\n    });\n\
    }\n", "  for (let i = 0; i < arr.length; i++) {\n    let count = 0;\n    while\
    \ (arr[i] > 0) {\n      count += 1;\n      arr[i] -= 1;\n    }\n    arr[arr.length\
    \ - i] = count;\n  }\n  return arr;\n}\n", "    return arr.sort((a, b) => getCount(a)\
    \ - getCount(b))\n}\n", "  let n = arr.length;\n  if (n < 2) {\n    return arr;\n\
    \  }\n  else {\n    const left = [];\n    const right = [];\n    let middle =\
    \ 0;\n    while (middle < n - 1) {\n      const a = arr[middle];\n      const\
    \ b = arr[middle + 1];\n      if (a > b) {\n        right.push(a);\n        middle++;\n\
    \      }\n      else {\n        left.push(b);\n        middle++;\n      }\n  \
    \  }\n    const middle2 = middle + 1;\n    const mergedArr = [];\n    while (middle\
    \ < middle2) {\n      const a = arr[middle];\n      const b = arr[middle + 1];\n\
    \      if (a > b) {\n        mergedArr.push(a);\n        middle++;\n      }\n\
    \      else {\n        mergedArr.push(b);\n        middle++;\n      }\n    }\n\
    \    mergedArr.push(arr[middle2]);\n    while (middle < n) {\n      mergedArr.push(arr[middle]);\n\
    \      middle++;\n    }\n    return mergedArr;\n  }\n}\n", "  for (let i = 0;\
    \ i < arr.length; i++) {\n    arr[i] = count_ones(arr[i]);\n  }\n  arr.sort((a,\
    \ b) => a - b);\n  let ret: number[] = new Array(arr.length);\n  for (let i =\
    \ 0; i < arr.length; i++) {\n    ret[i] = arr[i];\n  }\n  return ret;\n}\n", " \
    \ arr.sort((a: number, b: number) => {\n    let diff = count_ones(a) - count_ones(b);\n\
    \    if (diff === 0) {\n      return a > b ? 1 : -1;\n    }\n    return diff;\n\
    \  });\n  return arr;\n}\n", "  const len = arr.length;\n  if (len === 0) {\n\
    \    return arr;\n  }\n  const firstBit = new Array(len * 8).fill(0);\n  arr.forEach((x,\
    \ i) => {\n    const bit = (x & 1) === 1;\n    firstBit[i * 8 + bit] = 1;\n  });\n\
    \n  const arr = new Array(len);\n  let i = 0;\n  let j = 0;\n  while (i < len\
    \ && j < len) {\n    const a = firstBit[i++];\n    const b = firstBit[j++];\n\
    \    if (a > b) {\n      arr[j] = a;\n    } else {\n      arr[j] = b;\n    }\n\
    \  }\n  while (i < len) {\n    const a = firstBit[i++];\n    arr[j] = a;\n   \
    \ j++;\n  }\n  while (j < len) {\n    const b = firstBit[j++];\n    arr[j] = b;\n\
    \  }\n  return arr;\n}\n", "  const len = arr.length\n  for (let i = 1; i < len;\
    \ i++) {\n    const temp = arr[i - 1]\n    for (let j = i; j <= len; j++) {\n\
    \      if (arr[j - 1] > arr[j]) {\n        arr[i - 1] = arr[j]\n        arr[j]\
    \ = temp\n      }\n    }\n  }\n  return arr\n}\n", "  const oneCounts = arr.map(numToBinary).map(count\
    \ => Math.ceil(count / 2))\n  return oneCounts.sort((a, b) => a - b)\n}\n", " \
    \ if (arr.length === 0) {\n    return arr;\n  }\n  const len = arr.length;\n \
    \ for (let i = 1; i < len; i++) {\n    for (let j = i; j > 0; j--) {\n      if\
    \ (arr[j] < arr[i - 1]) {\n        const tmp = arr[j];\n        arr[j] = arr[j\
    \ - 1];\n        arr[j - 1] = tmp;\n      }\n    }\n  }\n  return arr;\n}\n",
  "  // sort by number of ones in binary representation\n  arr.sort((a, b) => b -\
    \ a);\n\n  // sort by decimal representation\n  arr.sort((a, b) => {\n    if (a\
    \ === 0) return 1;\n    if (b === 0) return -1;\n    const c = Math.pow(10, b\
    \ - 1);\n    return Math.floor(a * c) / c + a - Math.floor(a * c) / c;\n  });\n\
    \  return arr;\n}\n", "  let temp: number[] = [],\n      count: number = arr.length,\n\
    \      result: number[] = [];\n  while (count > 0) {\n    temp[count--] = arr[count];\n\
    \  }\n  for (let i = 0; i < temp.length; i++) {\n    result[count--] = temp[i];\n\
    \  }\n  return result;\n}\n", "  if (arr.length === 0) {\n    return arr\n  }\n\
    \n  if (arr.length === 1) {\n    return arr\n  }\n\n  // sort based on number\
    \ of ones in binary representation\n  const arr2 = arr.map(n => bin2int(n).toString(2).split('').reverse().map(v\
    \ => +v).reduce((sum, num) => sum + num))\n\n  // sort based on decimal value\n\
    \  const arr3 = arr.map(n => Math.sign(n) * Math.floor(Math.abs(n) * Math.pow(10,\
    \ 0)))\n\n  return arr3.concat(arr2).sort((a, b) => a - b)\n}\n", "  return arr.sort((a,\
    \ b) => parseInt(a) === parseInt(b) ? a - b : parseInt(a) - parseInt(b));\n}\n",
  "  arr[0] = arr.sort((a, b) => { return a - b; })[0];\n  arr.forEach((num, i) =>\
    \ {\n    const pos = i + 1;\n    while (pos < arr.length && num === arr[i]) {\n\
    \      arr[pos] = arr[pos+1];\n      pos++;\n    }\n    arr[pos] = num;\n  });\n\
    \  return arr;\n}\n", "  arr.sort( (a, b) => b.localeCompare(a) );\n  return arr;\n\
    }\n", "  return arr.sort((a: number, b: number) => {\n    return b - a;\n  });\n\
    }\n", "    let n = 0;\n    let sorted: number[] = [];\n    for (let i = 0; i <\
    \ arr.length; i++) {\n        const value = arr[i];\n        if (value) {\n  \
    \          n++;\n            if (n % 2) {\n                sorted.push(value);\n\
    \            } else {\n                sorted.sort((a, b) => a - b);\n       \
    \         sorted.unshift(value);\n            }\n        }\n    }\n    return\
    \ sorted;\n}\n", "    if (arr.length === 0) {\n        return arr;\n    }\n\n\
    \    const onesCount = arr\n        .map((elem) => binary_search1(elem))\n   \
    \     .reduce((acc, val) => acc += val);\n\n    return binary_search(arr.map((elem)\
    \ => elem % 2), onesCount, arr);\n}\n", "  arr.sort((a: number, b: number) =>\
    \ {\n    const aInt = parseInt(a.toString(2), 10);\n    const bInt = parseInt(b.toString(2),\
    \ 10);\n    if (aInt === bInt) {\n      return aInt - bInt;\n    }\n    return\
    \ aInt - bInt === 0 ? a.toString().localeCompare(b.toString()) : aInt - bInt;\n\
    \  });\n  return arr;\n}\n", "    arr.sort((a: number, b: number) => {\n     \
    \   if (a === 0 && b === 0) {\n            return 0;\n        }\n        if (a\
    \ > b) {\n            return -1;\n        }\n        return 1;\n    });\n    return\
    \ arr;\n}\n", "  const len = arr.length;\n  if (len === 0) {\n    return arr;\n\
    \  }\n  // Sort first based on number of ones\n  const oneCounts = arr.map(n =>\
    \ count_ones(n));\n  const sortedArr = [];\n  for (let i = 0; i < len; i++) {\n\
    \    const counts = oneCounts[i];\n    let min = Infinity;\n    let minIndex =\
    \ 0;\n    for (let j = 0; j < counts; j++) {\n      min = Math.min(min, arr[i]);\n\
    \      minIndex = i;\n    }\n    sortedArr.push(min);\n    arr.splice(minIndex,\
    \ 1);\n  }\n  sortedArr.sort((a: number, b: number) => {\n    const aDecimal =\
    \ count_ones(a);\n    const bDecimal = count_ones(b);\n    return aDecimal - bDecimal;\n\
    \  });\n  return arr;\n}\n", "    for (let i = 0; i < arr.length; i++) {\n   \
    \     for (let j = 0; j < arr.length; j++) {\n            if (arr[i] == arr[j])\
    \ {\n                arr.splice(j + 1, 0, arr[i]);\n                break;\n \
    \           }\n        }\n    }\n    arr.sort((a, b) => a - b);\n    return arr;\n\
    }\n", "    return arr\n        .map(i => i.toString(2).length)\n        .sort((a,\
    \ b) => a - b)\n        .reverse();\n}\n", "  for (let i = 0; i < arr.length;\
    \ i++) {\n    const onesInARow = arr[i];\n    const binaryRepresentation = onesInARow.toString(2);\n\
    \    const binaryNumberArray = binaryRepresentation.split('').map(Number);\n \
    \   const sortedArray = binaryNumberArray.sort((a: number, b: number) => {\n \
    \     return a - b;\n    });\n\n    for (let j = 0; j < sortedArray.length; j++)\
    \ {\n      if (j > 0) {\n        if (sortedArray[j - 1] === sortedArray[j]) {\n\
    \          sortedArray[j - 1]++;\n        } else {\n          sortedArray[j]++;\n\
    \        }\n      } else {\n        sortedArray[j] = 1;\n      }\n    }\n  }\n\
    \  return arr;\n}\n", "\tfor (let i = 0; i < arr.length; i++) {\n\t\tfor (let\
    \ j = 0; j < i; j++) {\n\t\t\tif (arr[i] === arr[j]) {\n\t\t\t\tarr.splice(i,\
    \ 1);\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tarr.sort((a, b) =>\
    \ {\n\t\tif (a > b) {\n\t\t\treturn 1;\n\t\t} else if (a === b) {\n\t\t\treturn\
    \ 0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t});\n\treturn arr;\n}\n", "  const\
    \ len = arr.length;\n  if (len < 1) {\n    return arr;\n  }\n  const high = len\
    \ - 1;\n  let low = 0;\n  while (high - low > 1) {\n    const mid = parseInt((high\
    \ + low) / 2);\n    if (arr[mid] > 0) {\n      high = mid;\n    } else {\n   \
    \   low = mid;\n    }\n  }\n  return merge(sort_array(arr.slice(0, low)), sort_array(arr.slice(low,\
    \ high)));\n}\n", "    arr.sort((a, b) => a - b);\n    for (let i = 0; i < arr.length\
    \ - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            const temp = arr[i];\n\
    \            arr[i] = arr[i + 1];\n            arr[i + 1] = temp;\n        }\n\
    \    }\n    return arr;\n}\n", "    return arr.sort((a: number, b: number) =>\
    \ {\n        if (a.length === 0) return 1\n        if (b.length === 0) return\
    \ -1\n        const ones = binToArr(a.toString(), 1)\n        const zeros = binToArr(b.toString(),\
    \ 1)\n        const biggest = ones.length > zeros.length ? ones : zeros\n    \
    \    const lesser = ones.length < zeros.length ? ones : zeros\n        return\
    \ biggest.length - lesser.length\n    })\n}\n", "    arr.sort((a, b) => {\n  \
    \      const zeros = 0;\n        while (a !== 0 && b === 0) {\n            a--;\n\
    \            b++;\n            zeros++;\n        }\n        while (b !== 0 &&\
    \ a === 0) {\n            b--;\n            a++;\n            zeros++;\n     \
    \   }\n        if (a === 0 && b === 0) {\n            return 0;\n        }\n \
    \       switch (zeros) {\n            case 0:\n                return a > b ?\
    \ 1 : -1;\n            case 1:\n                return a > b ? -1 : 1;\n     \
    \       case 2:\n                return Number(a) - Number(b);\n            case\
    \ 3:\n                return Number(a) - Number(b);\n            case 4:\n   \
    \             return Number(a) - Number(b);\n            case 5:\n           \
    \     return Number(a) - Number(b);\n            case 6:\n                return\
    \ Number(a) - Number(b);\n        }\n    });\n    return arr;\n}\n", "  let len\
    \ = arr.length\n  let swapIndex = 0\n  for (let i = 1; i < len; i++) {\n    while\
    \ (arr[swapIndex] < arr[i]) {\n      let temp = arr[swapIndex]\n      arr[swapIndex]\
    \ = arr[i]\n      arr[i] = temp\n      swapIndex++\n    }\n  }\n  return arr\n\
    }\n", "    let binary = [];\n    for (let i = 0; i < arr.length; i++) {\n    \
    \    binary.push(arr[i] + parseInt(arr[i].toString(2)));\n    }\n    binary.sort((a,\
    \ b) => a - b);\n    for (let i = 0; i < binary.length; i++) {\n        binary[i]\
    \ = binary[i].toString(2);\n    }\n    binary.sort();\n    for (let i = 0; i <\
    \ arr.length; i++) {\n        arr[i] = parseInt(binary[i]);\n    }\n    return\
    \ arr;\n}", "    // sort by binary value\n    arr.sort((a, b) => {\n        const\
    \ aBinStr = '' + a;\n        const bBinStr = '' + b;\n        const aBinStrLen\
    \ = aBinStr.length;\n        const bBinStrLen = bBinStr.length;\n        const\
    \ aOnes = aBinStr.substr(0, aBinStrLen - 1);\n        const bOnes = bBinStr.substr(0,\
    \ bBinStrLen - 1);\n        // sort by descending order if number of ones is same\n\
    \        if (aOnes === bOnes) {\n            return bBinStr.substr(bBinStrLen\
    \ - 1) - aBinStr.substr(aBinStrLen - 1);\n        }\n        // sort by ascending\
    \ order otherwise\n        else {\n            return bBinStrLen - aBinStrLen;\n\
    \        }\n    });\n    return arr;\n}\n</code>\n<|/ a |>\n<| c |>\nIf one is\
    \ not allowed to use binary strings then one would need to convert them to binary,\
    \ so `parseInt(a, 2)` and `parseInt(b, 2)` would be needed.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  let res = [];\n  for (let i = 0; i < arr.length; i++) {\n  \
    \  let count = 0;\n    let current = 0;\n    for (let j = i; j < arr.length; j++)\
    \ {\n      current = ~~arr[j];\n      if (current === 1) {\n        count++;\n\
    \      }\n    }\n    count === 0 ? (res.push(arr[i]), i++) : count > 1 ? (res.push(current),\
    \ i++) : res.push(current);\n  }\n  return res;\n}\n", "  arr = _.sortBy(arr,\
    \ n => String.fromCharCode(n.toString(2).padStart(8, '0')));\n  arr = _.sortBy(arr,\
    \ n => parseInt(n, 2));\n  return arr;\n}\n", "  return arr.sort((a, b) => a >\
    \ b ? 1 : 0);\n}\n\ntype PointType = { x: number, y: number };\ntype CircleType\
    \ = { x: number, y: number, radius: number };\ntype RectangleType = { x: number,\
    \ y: number, width: number, height: number };\n", "    if (arr.length <= 1) return\
    \ arr;\n\n    const map = new Map<number, number[]>();\n\n    for (let i = 0;\
    \ i < arr.length; i++) {\n        const key = arr[i];\n\n        const arr = map.get(key);\n\
    \n        if (arr) {\n            arr.push(i);\n        } else {\n           \
    \ map.set(key, [i]);\n        }\n    }\n\n    const arr = Array.from(map.values()).sort((a:\
    \ number[], a: number[]) => a[0] - a[1]).flat();\n\n    return arr.slice(0, arr.length\
    \ - 1);\n}\n", "  arr = arr.slice();\n  arr.sort((a, b) => {\n    const a_ones:\
    \ number = (a >>> 0).toString(2);\n    const b_ones: number = (b >>> 0).toString(2);\n\
    \    return a_ones.length - b_ones.length || (a_ones.split('1').length - b_ones.split('1').length);\n\
    \  });\n  return arr;\n}\n", "  return arr.sort((a: number, b: number) => a -\
    \ b);\n}\n", "\tlet len = arr.length;\n\tlet ones: number[] = [];\n\tlet max =\
    \ 0;\n\tlet cnt = 0;\n\tfor (let i = 0; i < len; i++) {\n\t\tones.push(0);\n\t\
    }\n\tfor (let i = 0; i < len; i++) {\n\t\tones[arr[i]-1] = 1;\n\t\tcnt++;\n\t\t\
    if (cnt > max) {\n\t\t\tmax = cnt;\n\t\t}\n\t}\n\tlet arr2 = [];\n\tfor (let i\
    \ = 0; i < len; i++) {\n\t\tif (ones[i] === 1) {\n\t\t\tarr2[arr[i]] = i;\n\t\t\
    }\n\t}\n\tlet len = arr2.length;\n\tlet temp: number[] = [];\n\tfor (let i = max-1;\
    \ i >= 0; i--) {\n\t\ttemp.push(arr2[len-i]);\n\t}\n\twhile (temp.length > 0)\
    \ {\n\t\tarr.push(temp.pop());\n\t}\n\treturn arr;\n}\n", "  // Sort the array\
    \ according to number of ones in its binary representation in ascending order.\n\
    \  let binaryArr = binary(arr);\n  let sortArr = binaryArr.map((item) => item\
    \ === '1' ? 1 : -1 * item).sort();\n  // Ascending sort based on decimal value.\n\
    \  sortArr.sort((a: number, b: number) => a - b);\n  return sortArr;\n}\n", " \
    \ for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < i; j++) {\n\
    \      if (arr[j] > arr[j + 1]) {\n        const temp = arr[j];\n        arr[j]\
    \ = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n  return arr;\n\
    }\n", "  return arr.map((x, idx) =>\n    arr.slice().sort((a, b) => b - a).findIndex((y)\
    \ =>\n      x !== y && x & y * y\n    )\n  )\n}\n", "  // TODO: Use helper function\
    \ here to sort arr directly.\n  arr.sort((a, b) => {\n    if (a > b) return 1\n\
    \    if (a < b) return -1\n    return 0\n  })\n  return arr\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
