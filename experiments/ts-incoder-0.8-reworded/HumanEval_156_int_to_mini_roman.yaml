name: HumanEval_156_int_to_mini_roman
language: ts
prompt: "//Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
  // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\
  \n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunction int_to_mini_roman(number:\
  \ number): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = int_to_mini_roman;\n  assert.deepEqual(candidate(19),\"\
  xix\");\n  assert.deepEqual(candidate(152),\"clii\");\n  assert.deepEqual(candidate(251),\"\
  ccli\");\n  assert.deepEqual(candidate(426),\"cdxxvi\");\n  assert.deepEqual(candidate(500),\"\
  d\");\n  assert.deepEqual(candidate(1),\"i\");\n  assert.deepEqual(candidate(4),\"\
  iv\");\n  assert.deepEqual(candidate(43),\"xliii\");\n  assert.deepEqual(candidate(90),\"\
  xc\");\n  assert.deepEqual(candidate(94),\"xciv\");\n  assert.deepEqual(candidate(532),\"\
  dxxxii\");\n  assert.deepEqual(candidate(900),\"cm\");\n  assert.deepEqual(candidate(994),\"\
  cmxciv\");\n  assert.deepEqual(candidate(1000),\"m\");\n}\n\ntest();"
completions: ["  let roman = ``;\n  let num: number = number;\n  roman = roman.concat(`C`);\n\
    \  while (num > 0) {\n    num--;\n    roman = roman.concat(`M`);\n  }\n  while\
    \ (num > 1000) {\n    num -= 1000;\n    roman = roman.concat(`D`);\n  }\n  roman\
    \ = roman.concat(`${num}`);\n  while (roman.length > 3) {\n    roman = roman.concat(`M`);\n\
    \  }\n  return roman;\n}\n", "  // Step 1. Handle negative numbers\n  if (number\
    \ < 0) {\n    return `-${int_to_mini_roman(-number)}`;\n  }\n\n  // Step 2. Handle\
    \ 0\n  if (number === 0) {\n    return '0';\n  }\n\n  // Step 3. Handle positive\
    \ numbers, as long as they're <= 1000\n  if (number > 1000) {\n    return `${int_to_mini_roman(number\
    \ / 10)}${int_to_mini_roman(number % 10)}`;\n  }\n\n  // Step 4. Handle integers\
    \ above 1000\n  let roman: string;\n  const baseTen = int_to_roman(number);\n\
    \  if (baseTen.startsWith('V')) {\n    roman = baseTen.slice(1).concat(int_to_mini_roman(number\
    \ % 10));\n  } else {\n    roman = baseTen.concat(int_to_mini_roman(number % 10));\n\
    \  }\n\n  return roman;\n}\n", "    let num = number;\n    if (num > 1000) {\n\
    \        throw new Error(`Given number is greater than 1000`);\n    }\n    let\
    \ roman: string = num > 9 ? \"III\" : \"IV\";\n    if (num % 10 < 5) {\n     \
    \   roman += \"I\";\n    }\n    if (num % 10 < 4) {\n        roman += \"V\";\n\
    \    }\n    if (num % 10 < 7) {\n        roman += \"X\";\n    }\n    if (num %\
    \ 10 < 9) {\n        roman += \"C\";\n    }\n    if (num % 10 < 1) {\n       \
    \ roman += \"L\";\n    }\n    if (num % 10 < 2) {\n        roman += \"D\";\n \
    \   }\n    if (num % 10 < 3) {\n        roman += \"M\";\n    }\n    if (num %\
    \ 10 < 6) {\n        roman += \"S\";\n    }\n    if (num % 10 < 8) {\n       \
    \ roman += \"D\";\n    }\n    if (num % 10 < 1) {\n        roman += \"C\";\n \
    \   }\n    return roman;\n}\n", "  const roman = Object.keys(MiniRoms).filter((x:\
    \ string) => x > number)[0];\n  const roman_numeral = MiniRoms[roman];\n  return\
    \ mini_roman_to_int(roman_numeral, number);\n}\n", "  let num: string = '';\n\
    \  if (number < 0 || number > 999) {\n    throw new Error(\"The given integer\
    \ must be between 0 and 999\");\n  }\n\n  if (number <= 500) {\n    if (number\
    \ >= 100) {\n      num += (number / 100).toString();\n      num += 'c';\n    \
    \  number %= 100;\n    }\n  }\n\n  if (number >= 100) {\n    if (number >= 10)\
    \ {\n      num += (number / 10).toString();\n      num += 's';\n      number %=\
    \ 10;\n    }\n    num += (number / 100).toString();\n    num += 'm';\n    number\
    \ %= 100;\n  }\n\n  if (number >= 10) {\n    num += (number / 10).toString();\n\
    \    num += 't';\n    number %= 10;\n  }\n\n  if (number >= 1) {\n    num += (number\
    \ / 100).toString();\n    num += 'l';\n    number %= 100;\n  }\n  return num;\n\
    }\n", "  let roman: string = '';\n  let remainder: number;\n  const num: number\
    \ = number;\n  // Get the least significant non-zero digit first\n  while (num\
    \ >= 100) {\n    roman = roman.concat('M');\n    num = num % 100;\n  }\n  // If\
    \ the number is greater than or equal to 100, get the next lowest digit\n  while\
    \ (num >= 10) {\n    roman = roman.concat(num % 10);\n    num = Math.floor(num\
    \ / 10);\n  }\n  // Get the least significant non-zero digit next\n  while (num\
    \ > 0) {\n    remainder = num % 10;\n    roman = roman.concat(remainder);\n  \
    \  num = Math.floor(num / 10);\n  }\n  return roman;\n}\n", "  if (typeof number\
    \ !== 'number' || isNaN(number)) return '';\n  const roman = mini_roman[number]\
    \ || '';\n  // Only return romans that are exactly four letters long.\n  if (roman.length\
    \ !== 4) return roman;\n  const len = roman.length;\n  if (len === 9) return roman;\n\
    \  if (len === 5) {\n    return roman;\n  }\n  if (len === 3) {\n    return roman;\n\
    \  }\n  if (len < 4) {\n    return '';\n  }\n  return roman;\n}\n", "  if (number\
    \ < 0 || number > 1000) {\n    throw new Error('number must be positive and less\
    \ than 1000');\n  }\n\n  let result = '';\n\n  do {\n    let remainder = number\
    \ % 10;\n    result += (NUMBERS[remainder] || remainder + '').toUpperCase();\n\
    \    number = Math.floor(number / 10);\n  } while (number > 0);\n\n  return result;\n\
    }\n", "  if (typeof number !== 'number' || number < 1 || number > 1000) {\n  \
    \  throw new Error('Expected number > 0 and <= 1000.')\n  }\n  const ints = split_by_length(number)\n\
    \  return ints.map(i => int_to_roman(i)).join('')\n}\n", "  if (number < 1 ||\
    \ number > 1000) {\n    throw new Error(\"Invalid number for roman numeral\");\n\
    \  }\n\n  let roman = \"\";\n  let i = 0;\n  while (true) {\n    const currentChar\
    \ = number % 10;\n    roman += int_to_roman_character(currentChar);\n    number\
    \ -= currentChar;\n    if (number === 0) {\n      break;\n    }\n\n    ++i;\n\
    \  }\n\n  return roman;\n}\n", "  let int_to_roman = {\n    100: \"M\",\n    900:\
    \ \"CM\",\n    500: \"D\",\n    400: \"CD\",\n    100: \"C\",\n    90: \"XC\"\
    ,\n    50: \"L\",\n    40: \"XL\",\n    10: \"X\",\n    9: \"IX\",\n    5: \"\
    V\",\n    4: \"IV\",\n    1: \"\",\n    9000: \"CM\",\n    5000: \"D\",\n    4000:\
    \ \"CD\",\n    1000: \"C\",\n    900: \"XC\",\n    500: \"L\",\n    400: \"XL\"\
    ,\n    100: \"X\",\n    90: \"IX\",\n    50: \"V\",\n    40: \"IV\",\n  };\n\n\
    \  let roman = int_to_roman[number];\n  if (roman === undefined) {\n    return\
    \ \"\";\n  }\n\n  let mini_roman = roman.replace(/\\d+/g, \"\");\n  let letters\
    \ = mini_roman.split(\"\");\n  let letters_with_index = letters.map((letter, i)\
    \ => {\n    return { letter, index: i };\n  });\n  letters_with_index.sort((a,\
    \ b) => a.index - b.index);\n  mini_roman = \"\";\n  for (let i = 0; i < letters_with_index.length;\
    \ i++) {\n    let { letter } = letters_with_index[i];\n    mini_roman += letter;\n\
    \  }\n\n  return mini_roman.toLowerCase();\n}\n", "  const num = number,\n   \
    \     digits = num.toString(10).split(\"\"),\n        roman = \"\";\n\n  for (let\
    \ i = 0; i < digits.length; i++) {\n    roman = roman.concat(\n      (digits[Math.max(i\
    \ - 1, 0)].match(/[0-9]/) ?\n        \"c\" :\n        \"d\"\n      ),\n      digits[i]\n\
    \    );\n  }\n\n  return roman;\n}\n", "  if (typeof number !== \"number\") {\n\
    \    throw new Error(\"expected number to be a number\");\n  }\n  if (number <\
    \ 1 || number > 1000) {\n    throw new Error(\"expected number to be between 1\
    \ and 1000\");\n  }\n\n  const romanNums =\n    \"i\" +\n    \"v\" +\n    \"x\"\
    \ +\n    \"c\" +\n    \"d\" +\n    \"m\" +\n    \"l\" +\n    \"p\" +\n    \"h\"\
    \ +\n    \"a\";\n\n  const romanStr = romanNums.replace(/(i|v|x|c|d|m|l|p|h|a)(\\\
    1)+/g, (match, p1, offset) =>\n    match.slice(offset).replace(p, match + p)\n\
    \  );\n\n  return romanStr.toLowerCase();\n}\n", "  if (number < 1) {\n    return\
    \ \"\"\n  }\n\n  const max_int = MIMININT\n  const min_int = MMININT\n\n  if (number\
    \ > max_int) {\n    return int_to_mini_roman(max_int)\n  }\n  if (number < min_int)\
    \ {\n    return int_to_mini_roman(min_int)\n  }\n\n  const max_roman = MROMAN[MINTAB[max_int]]\n\
    \  const min_roman = MROMAN[MINTAB[min_int]]\n\n  if (number < max_int) {\n  \
    \  return int_to_roman(number)\n  } else {\n    const ints = roman_to_int(min_roman)\
    \ + MROMAN[number - min_int]\n\n    const int_str = int_to_roman(ints)\n    return\
    \ int_str.substr(0, int_str.length - int_to_roman(MROMAN[number]).length)\n  }\n\
    }\n", "    let roman = '';\n    while (number > 0) {\n        if (number % 100\
    \ >= 10) {\n            roman += int_to_roman(number % 100);\n            number\
    \ -= number % 100;\n        } else {\n            roman += int_to_roman(number\
    \ % 10);\n            number -= number % 10;\n        }\n    }\n    return roman;\n\
    }\n", "    // The list of roman numerals was taken from:\n    // https://en.wikipedia.org/wiki/Roman_numerals\n\
    \    const romanNums: string[] = [\n        \"M\",\n        \"CM\",\n        \"\
    D\",\n        \"CD\",\n        \"C\",\n        \"XC\",\n        \"L\",\n     \
    \   \"XL\",\n        \"X\",\n        \"IX\",\n        \"V\",\n        \"IV\",\n\
    \        \"I\",\n    ];\n    const numStr = number.toString();\n    let miniStr\
    \ = \"\";\n    while (numStr.length >= romanNums.length) {\n        miniStr +=\
    \ romanNums[romanNums.indexOf(numStr.substring(0, romanNums.length))];\n     \
    \   numStr = numStr.substring(romanNums.length);\n    }\n    if (numStr.length\
    \ > 0) {\n        miniStr += numStr;\n    }\n    return miniStr.toLowerCase();\
    \ // We must return lowercase version of miniStr\n}\n", "  let str = number_to_mini_roman(number);\n\
    \  return str.toLowerCase().replace(/[a-z]/, '');\n}\n", "  // Our roman numeral\
    \ table is identical to the arabic numeral table\n  const ARABIC_NUMERALS = [\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    ];\n  const ARABIC_NUMERAL_ROMAN_VALUE = {\n    \"I\": 1,\n    \"II\": 2,\n  \
    \  \"III\": 3,\n    \"IV\": 4,\n    \"V\": 5,\n    \"VI\": 6,\n    \"VII\": 7,\n\
    \    \"VIII\": 8,\n    \"IX\": 9,\n    \"X\": 10,\n  };\n  // Our arabic numeral\
    \ table only includes digits 0-9\n  const ARABIC_NUMERALS_MINI = ARABIC_NUMERALS.slice(0,\
    \ 9);\n  const ARABIC_NUMERALS_MINI_ROMAN_VALUE = ARABIC_NUMERAL_ROMAN_VALUE.slice(0,\
    \ 9);\n  \n  // Our roman numeral table only includes digits 1-9\n  const ROMAN_NUMERALS\
    \ = [\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"\
    , \"X\"];\n  const ROMAN_NUMERAL_ROMAN_VALUE = {\n    \"I\": 1,\n    \"II\": 2,\n\
    \    \"III\": 3,\n    \"IV\": 4,\n    \"V\": 5,\n    \"VI\": 6,\n    \"VII\":\
    \ 7,\n    \"VIII\": 8,\n    \"IX\": 9,\n    \"X\": 10,\n  };\n  // Our arabic\
    \ numeral table only includes digits 1-9\n  const ROMAN_NUMERALS_MINI = ROMAN_NUMERALS.slice(0,\
    \ 9);\n  const ROMAN_NUMERALS_MINI_ROMAN_VALUE = ROMAN_NUMERAL_ROMAN_VALUE.slice(0,\
    \ 9);\n\n  const base = getBaseFromNumber(number);\n  \n  // Return null if the\
    \ number is outside the range 1...1000\n  if (!(number > 0 && number <= 1000))\
    \ {\n    return null;\n  }\n\n  // Get the number as a string, with leading zeros.\n\
    \  // Example: 987 becomes \"0000987\"\n  const numberStr = number.toString();\n\
    \  // Find the length of the number\n  const numberLength = numberStr.length;\n\
    \  // If the number is less than 2 characters, return null\n  if (numberLength\
    \ < 2) {\n    return null;\n  }\n  // If number length is exactly 2 characters,\
    \ return numberStr without leading zeros\n  if (numberLength === 2) {\n    return\
    \ numberStr;\n  }\n  // If the number length is 3 or more, trim trailing zeroes\
    \ and add leading zeros\n  return numberLength >= 3 ? numberStr.endsWith(\"0\"\
    ) && numberStr", "  const num2roman = (num: number) => {\n    const intPart =\
    \ (num: number) => {\n      const factor = Math.pow(10, Math.floor((num - Math.floor((num\
    \ - 1) / 100)) % 10));\n      const result = (num % 10) * factor;\n      return\
    \ result;\n    };\n    const romanPart = () => {\n      if (num === 0 || num ===\
    \ 1) {\n        return \"\";\n      }\n      if (num < 4) {\n        return intPart(num);\n\
    \      }\n      return intPart((num - 3) * 7) + intPart(num - 4);\n    };\n  \
    \  return romanPart();\n  };\n  return num2roman(number);\n}\n", "  if (number\
    \ < 1 || number > 1000) {\n    throw new Error(\"number must be between 1 and\
    \ 1000 inclusive\")\n  }\n  let roman = Array.from(Array(number).keys());\n  let\
    \ roman_string = \"\";\n  for (let roman of roman) {\n    roman -= 1;\n    roman\
    \ += 100;\n    roman /= 10;\n    roman %= 10;\n    if (roman === 0) roman_string\
    \ += \"M\";\n    if (roman === 1) roman_string += \"CM\";\n    if (roman === 2)\
    \ roman_string += \"D\";\n    if (roman === 3) roman_string += \"CD\";\n    if\
    \ (roman === 4) roman_string += \"C\";\n    if (roman === 5) roman_string += \"\
    XC\";\n    if (roman === 6) roman_string += \"L\";\n    if (roman === 7) roman_string\
    \ += \"XL\";\n    if (roman === 8) roman_string += \"X\";\n    if (roman === 9)\
    \ roman_string += \"IX\";\n    if (roman === 10) roman_string += \"V\";\n    if\
    \ (roman === 11) roman_string += \"IV\";\n    if (roman === 12) roman_string +=\
    \ \"I\";\n    if (roman === 13) roman_string += \"I\";\n    if (roman === 14)\
    \ roman_string += \"I\";\n    if (roman === 15) roman_string += \"I\";\n    if\
    \ (roman === 16) roman_string += \"I\";\n    if (roman === 17) roman_string +=\
    \ \"V\";\n    if (roman === 18) roman_string += \"IV\";\n    if (roman === 19)\
    \ roman_string += \"V\";\n    if (roman === 20) roman_string += \"V\";\n    if\
    \ (roman === 21) roman_string += \"V\";\n    if (roman === 22) roman_string +=\
    \ \"V\";\n    if (roman === 23) roman_string += \"V\";\n    if (roman === 24)\
    \ roman_string += \"V\";\n    if (roman === 25) roman_string += \"IV\";\n    if\
    \ (roman === 26) roman_string += \"IV\";\n    if (roman === 27) roman_string +=\
    \ \"IV\";\n    if (roman === 28) roman_string += \"IV\";\n    if (roman === 29)\
    \ roman_string += \"IV\";\n    if (roman === 30) roman_string += \"V\";\n    if\
    \ (roman === 31) roman_string += \"V\";\n    if (roman === 32) roman_string +=\
    \ \"V\";\n    if (roman === 33) roman_string += \"V\";\n    if (roman === 34)\
    \ ro", "  const numberStr = int_to_string(number);\n  if (numberStr.length <=\
    \ 3) return numberStr;\n  const romanStrArr: Array<string> = [];\n  let curStr\
    \ = \"\";\n  const romanNumToStr: Array<number> = [1000, 900, 500, 400, 100, 90,\
    \ 50, 40, 10, 9, 5, 4, 1];\n  for (let i = 0; i < numberStr.length; i++) {\n \
    \   curStr += romanNumToStr[numberStr.length - 1 - i] * romanStrArr[romanStrArr.length\
    \ - 1];\n    romanStrArr.unshift(curStr.substring(0, curStr.length - 1));\n  }\n\
    \  return romanStrArr.join(\"\");\n}\n", "  // Only use recursion if it would\
    \ be more efficient to do so\n  if (number <= 999) {\n    return int_to_mini_roman_rec(number);\n\
    \  } else {\n    return int_to_mini_roman_rec_fast(number);\n  }\n}\n", "  const\
    \ roman_array = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"\
    X\", \"IX\", \"V\", \"IV\", \"I\"];\n  const roman_string: string = roman_array[number];\n\
    \  return roman_string.toLowerCase();\n}\n", "  let roman: string;\n  if (number\
    \ < 1 || number > 1000) {\n    throw Error(`Invalid int argument: ${number}`);\n\
    \  }\n  let roman_map = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\", \"xi\",\n                   \"xii\", \"xiii\"\
    , \"xiv\", \"xvi\", \"xvii\", \"xviii\", \"xix\", \"xx\", \"xxx\",\n         \
    \          \"xxxx\"];\n  for (let i = roman_map.length - 1; i >= 0; i--) {\n \
    \   let n = roman_map[(i + number - 1) % roman_map.length];\n    roman = (roman_map[i]\
    \ + n).slice(0, -roman_map[i].length);\n  }\n  return roman;\n}\n", "  let roman\
    \ = \"c\"\n  let roman_num = 1\n  while (number > 1) {\n    roman_num *= 10\n\
    \    roman = int_to_mini_roman(number % 10) + roman\n    number = Math.floor(number\
    \ / 10)\n  }\n  return roman\n}\n", "  if (number < 1 || number > 1000)\n    throw\
    \ new Error(\"Invalid romanian number \" + number)\n  const roman = int_to_roman(number)\n\
    \  return roman.toLowerCase()\n}\n", "  const roman = makeArray(1000)\n  let romanNum\
    \ = number\n  let index = 0\n  while (romanNum > 0) {\n    const remainder = romanNum\
    \ % 100\n    romanNum = Math.floor(romanNum / 100)\n    roman[index++] = remainder\
    \ + roman[index - 1]\n  }\n  return roman.join('')\n}\n", "    let roman: Array<string>\
    \ = [];\n    let counter: number = 0;\n    while (number > 1000) {\n        roman.push(String.fromCharCode(Math.floor((number\
    \ % 1000) / 100)));\n        number -= Math.floor(number / 100);\n        counter++;\n\
    \    }\n    roman.push(String.fromCharCode(Math.floor((number % 10) + 1)));\n\
    \    return roman.join('');\n}\n", "  var roman = [\n    '',\n    'C',\n    'CC',\n\
    \    'CCC',\n    'CD',\n    'D',\n    'DC',\n    'DCC',\n    'DCCC',\n    'CM',\n\
    \    '',\n    'X',\n    'XX',\n    'XXX',\n    'XL',\n    'L',\n    'LX',\n  \
    \  'LXX',\n    'LXXX',\n    'XC',\n    '',\n    'I',\n    'II',\n    'III',\n\
    \    'IV',\n    'V',\n    'VI',\n    'VII',\n    'VIII',\n    'IX'\n  ];\n\n \
    \ var index = 0;\n  var roman_index = 0;\n  var roman_num = 0;\n\n  while (roman_index\
    \ < roman.length) {\n    var first_char = roman_index;\n    roman_num = roman_index\
    \ + 1;\n    while (roman_num < roman.length && roman[roman_num] === roman[first_char])\
    \ {\n      roman_num += 1;\n    }\n\n    var last_char = roman_num - 1;\n    if\
    \ (last_char < 0) {\n      last_char = roman.length - 1;\n    }\n\n    var char_count\
    \ = roman_num - first_char;\n    var roman_string = roman[first_char] + roman[first_char\
    \ + 1];\n    for (var i = 2; i <= char_count; i++) {\n      roman_string += roman[last_char\
    \ + i];\n    }\n\n    roman = roman_string;\n    index += 1;\n    roman_index\
    \ += 1;\n  }\n\n  return roman;\n}\n", "  if (number > 1000 || number < 1) {\n\
    \    return \"\";\n  }\n  const roman_numeral_array = [\n    \"i\",\n    \"ii\"\
    ,\n    \"iii\",\n    \"iv\",\n    \"v\",\n    \"vi\",\n    \"vii\",\n    \"viii\"\
    ,\n    \"ix\",\n    \"x\",\n    \"xi\",\n    \"xii\",\n    \"xiii\",\n  ];\n \
    \ let roman_numeral = \"\";\n  let current_remainder = number;\n  while (current_remainder\
    \ > 100) {\n    current_remainder -= 100;\n    roman_numeral += roman_numeral_array[current_remainder];\n\
    \  }\n  roman_numeral += roman_numeral_array[current_remainder];\n  while (current_remainder\
    \ > 5) {\n    current_remainder -= 5;\n    roman_numeral += roman_numeral_array[current_remainder];\n\
    \  }\n  roman_numeral += roman_numeral_array[current_remainder];\n  return roman_numeral.toLowerCase();\n\
    }\n", "\tconst MI_LEN = 1000\n\tif (number > MI_LEN || number < 1)\n\t\tthrow\
    \ new RangeError(`Argument must be a positive number not greater than or equal\
    \ to ${MI_LEN}`)\n\n\tlet roman_numeral = ''\n\tlet numeral = 0\n\twhile (number\
    \ >= numeral) {\n\t\tconst remainder = number % MI_LEN\n\t\tnumber -= remainder\n\
    \t\tnumeral += 1\n\t\troman_numeral += roman_numerals[remainder]\n\t}\n\n\treturn\
    \ roman_numeral.toLowerCase()\n}\n", "  if (number <= 0) return \"\";\n  if (number\
    \ == 0 || number == 1) return \"m\";\n\n  let roman = \"\";\n  while (number >\
    \ 0) {\n    const value = number % 10;\n    roman += roman_numbers[value];\n \
    \   number /= 10;\n  }\n\n  // reverse the roman to guarantee LTR ordering\n \
    \ const tmp = roman;\n  roman = roman.split(\"\").reverse().join(\"\");\n\n  return\
    \ tmp + roman;\n}\n", "  let roman = '';\n  for (let i = 0; i < number; i++) {\n\
    \    roman += int_to_roman_numeral(i - 1);\n  }\n  return roman.toLowerCase();\n\
    }\n", "  if (number < 1 || number > 1000) {\n    throw new Error(`number must\
    \ be between 1 and 1000`)\n  }\n\n  const romanArray: string[] = [\n    \"M\"\
    ,\n    \"CM\",\n    \"D\",\n    \"CD\",\n    \"C\",\n    \"XC\",\n    \"L\",\n\
    \    \"XL\",\n    \"X\",\n    \"IX\",\n    \"V\",\n    \"IV\",\n    \"I\",\n \
    \ ]\n\n  let index = 0\n  let numeral = \"\"\n\n  while (index <= number) {\n\
    \    numeral += romanArray[index]\n    index += 3\n  }\n\n  return numeral.toLowerCase()\n\
    }\n", "  const result = \"\";\n  do {\n    const remainder = number % 10;\n  \
    \  number = number / 10;\n    if (remainder) {\n      result += mini_roman[remainder];\n\
    \    }\n  } while (number);\n  return result;\n}\n", "  const roman = roman_to_int;\n\
    \  const num_digits = number.toString().length;\n  let result = \"\";\n  do {\n\
    \    result += roman[number % 10] + roman.charAt(number % 10);\n    number /=\
    \ 10;\n  } while (number > 0);\n  // If number > 0, the least significant bit\
    \ is 1, remove it.\n  return result.substring(0, result.length - 1);\n}\n", "\t\
    const numString = to_string(number);\n\tconst numStringLen = numString.length;\n\
    \tlet numStringRom = '';\n\tlet romanNum: number = 0;\n\tlet romanNumLen = 0;\n\
    \n\tfor (let i = 0; i < numStringLen; i++) {\n\t\tromanNum = numString[i] ===\
    \ 'M' ? 1000 : numString[i] === 'D' ? 500 : numString[i] === 'C' ? 100 : 10;\n\
    \t\tromanNumLen = Math.ceil(romanNum / 4.0);\n\n\t\tif (romanNumLen > 0) {\n\t\
    \t\tfor (let j = 1; j < romanNumLen + 1; j++) {\n\t\t\t\tnumStringRom += roman_numbers_en[j\
    \ - 1];\n\t\t\t}\n\t\t} else {\n\t\t\tnumStringRom += roman_numbers_en[0];\n\t\
    \t}\n\n\t\tif (i < numStringLen - 1) {\n\t\t\tnumStringRom += numString[i + 1];\n\
    \t\t}\n\t}\n\n\treturn numStringRom.toLowerCase();\n}\n", "  if (number <= 0 ||\
    \ number > 1000) {\n    throw Error(`Invalid input: ${number}`);\n  }\n  const\
    \ romanArray: string[] = [];\n  for (let i = 0; i < number; i++) {\n    const\
    \ intNumber = i;\n    const intDivisor = i;\n    while (number >= intDivisor)\
    \ {\n      romanArray.push(intNumber % 10);\n      intNumber = Math.floor(intNumber\
    \ / 10);\n      intDivisor = Math.floor(intDivisor / 10);\n    }\n    romanArray.push(intNumber);\n\
    \  }\n  return romanArray.join('');\n}\n", "  if (number < 0 || number > 3999)\
    \ return \"\";\n  let roman = \"\";\n  let exponent = number;\n  while (exponent\
    \ !== 0) {\n    const remainder = exponent % 3;\n    roman = romans[remainder]\
    \ + roman;\n    exponent = Math.floor(exponent / 3);\n  }\n  return roman;\n}\n",
  "  if (number < 1 || number > 999) {\n    return '';\n  }\n  const letters = {\n\
    \    I: 'x',\n    V: 'vi',\n    X: 'xvi',\n    L: 'l',\n    XL: 'xl',\n    C:\
    \ 'c',\n    D: 'd',\n    M: 'm',\n    S: 's',\n  };\n  let roman = '';\n  let\
    \ lastDigit = number;\n  for (let i = 2; i <= 4; i++) {\n    lastDigit = Math.floor(lastDigit\
    \ / Math.pow(10, i));\n    roman += letters[Math.floor(lastDigit % Math.pow(10,\
    \ i))];\n  }\n  return roman;\n}\n", "    if (number < 1) {\n        return \"\
    o\";\n    }\n    let roman = \"\";\n    if (number < 100) {\n        roman +=\
    \ int_to_mini_roman(number / 10);\n    }\n    if (number < 1000) {\n        roman\
    \ += int_to_mini_roman(number / 10) + \"c\";\n    }\n    if (number < 10000) {\n\
    \        roman += int_to_mini_roman(number / 10) + \"l\";\n    }\n    if (number\
    \ < 100000) {\n        roman += int_to_mini_roman(number / 10) + \"x\";\n    }\n\
    \    if (number < 1000000) {\n        roman += int_to_mini_roman(number / 10)\
    \ + \"s\";\n    }\n    if (number < 10000000) {\n        roman += int_to_mini_roman(number\
    \ / 10) + \"m\";\n    }\n    if (number < 100000000) {\n        roman += int_to_mini_roman(number\
    \ / 10) + \"c\";\n    }\n    if (number < 1000000000) {\n        roman += int_to_mini_roman(number\
    \ / 10) + \"l\";\n    }\n    if (number < 10000000000) {\n        roman += int_to_mini_roman(number\
    \ / 10) + \"x\";\n    }\n    if (number < 100000000000) {\n        roman += int_to_mini_roman(number\
    \ / 10) + \"s\";\n    }\n    if (number < 1000000000000) {\n        roman += int_to_mini_roman(number\
    \ / 10) + \"m\";\n    }\n    if (number < 10000000000000) {\n        roman +=\
    \ int_to_mini_roman(number / 10) + \"c\";\n    }\n    if (number < 100000000000000)\
    \ {\n        roman += int_to_mini_roman(number / 10) + \"l\";\n    }\n    if (number\
    \ < 1000000000000000) {\n        roman += int_to_mini_roman(number / 10) + \"\
    x\";\n    }\n    if (number < 10000000000000000) {\n        roman += int_to_mini_roman(number\
    \ / 10) + \"s\";\n    }\n    if (number < 100000000000000000) {\n        roman\
    \ += int_to_mini_roman(number / 10) + \"m\";\n    }\n    if (number < 100000000000000000)\
    \ {\n        roman += int_to_mini_roman(number / 10) + \"c\";\n    }\n    if (number\
    \ < 10000000000000000) {\n        roman += int_to_mini_roman(number / 10) + \"\
    l\";\n    }\n    if (number < 100000000000000000) {\n        roman += int_to_",
  "    const roman = new Map<string, string>([\n        ['M', \"M\"],\n        ['CM',\
    \ \"CM\"],\n        ['D', \"D\"],\n        ['CD', \"CD\"],\n        ['C', \"C\"\
    ],\n        ['XC', \"XC\"],\n        ['L', \"L\"],\n        ['XL', \"XL\"],\n\
    \        ['X', \"X\"],\n        ['IX', \"IX\"],\n        ['V', \"V\"],\n     \
    \   ['IV', \"IV\"],\n        ['I', \"I\"],\n    ]);\n\n    let result = \"\";\n\
    \    const remainder = number % 1000;\n    const quotient = number - remainder;\n\
    \    for (let i = 0; i < quotient; i++) {\n        const romanIndex = roman.findIndex((r:\
    \ string) => r.startsWith(roman[i]));\n        if (romanIndex >= 0) {\n      \
    \      result += roman[i];\n        } else {\n            result += \"M\";\n \
    \       }\n    }\n    if (remainder > 0) {\n        const romanIndex = roman.findIndex((r:\
    \ string) => r.startsWith(roman[i]));\n        if (romanIndex >= 0) {\n      \
    \      result += roman[romanIndex];\n        } else {\n            result += \"\
    M\";\n        }\n    }\n\n    return result;\n}\n", "  let result: string = \"\
    \";\n  for (let i = number - 1; i >= 0; i--) {\n    const roman = int_to_roman(i);\n\
    \    let value = roman ? roman.charCodeAt(0) : 0;\n    if (value <= 3) {\n   \
    \   result += roman;\n    } else {\n      if (value % 2 === 0) {\n        result\
    \ += int_to_mini_roman((number / 2) - 1) + int_to_mini_roman(value / 2);\n   \
    \   } else {\n        result += int_to_mini_roman(value / 2);\n      }\n    }\n\
    \  }\n  return result;\n}\n", "  const numStr = number.toString();\n  const base\
    \ = [\n    '',\n    'C',\n    'CCC',\n    'CCCC',\n    'CD',\n    'D',\n    'DC',\n\
    \    'DCC',\n    'DCCC',\n    'CM',\n    'M',\n    'MM',\n    'MMM',\n    'MMMM',\n\
    \    'MMMMM',\n    'MMMMMM',\n    'MMMMMMM',\n    'MMMMMMMM',\n  ];\n  const numArray\
    \ = numStr.split('');\n  const roman = '';\n  let pos = 0;\n  while (numArray.length\
    \ > pos) {\n    const numStr = numArray[pos];\n    const baseStr = base[numArray.length\
    \ - pos - 1];\n    const isNumDigit = baseStr.indexOf(numStr) !== -1;\n    const\
    \ romanDigit = isNumDigit ? numStr.toUpperCase() : numStr;\n    roman += romanDigit;\n\
    \    pos++;\n  }\n  return roman;\n}\n", "  const roman_numerals = {\n    I: \"\
    I\",\n    V: \"V\",\n    X: \"X\",\n    L: \"L\",\n    C: \"C\",\n    D: \"D\"\
    ,\n    M: \"M\",\n    S: \"S\",\n  };\n  let roman_numeral = \"\";\n  let current_val\
    \ = number;\n  for (let val of Object.keys(roman_numerals)) {\n    if (current_val\
    \ >= val) {\n      roman_numeral = roman_numerals[val];\n      break;\n    }\n\
    \    current_val -= val;\n  }\n  return roman_numeral;\n}\n", "  // Convert to\
    \ string\n  const number = String(number);\n  \n  // Convert to array of individual\
    \ characters\n  const array = number.split('');\n  \n  // Add L (L for lowercase)\
    \ to the beginning\n  array.unshift('L');\n  \n  // Add M (M for lowercase) to\
    \ the beginning\n  array.unshift('M');\n  \n  // Add C (C for lowercase) to the\
    \ beginning\n  array.unshift('C');\n  \n  // Add D (D uppercase) to each element\n\
    \  for (let i = 0; i < array.length; i++)\n    array[i] = array[i].toUpperCase();\n\
    \n  // Reverse the array\n  array.reverse();\n  \n  // Return final string\n \
    \ return array.join('');\n}\n", "\tlet roman = \"\";\n\twhile (number > 0) {\n\
    \t\tif (number % 1000 < 10)\n\t\t\troman += \"v\";\n\t\telse if (number % 1000\
    \ < 500)\n\t\t\troman += \"l\";\n\t\telse if (number % 1000 < 1000)\n\t\t\troman\
    \ += \"c\";\n\t\telse //if (number % 1000 < 2000)\n\t\t\troman += \"d\";\n\t\t\
    number -= number % 1000;\n\t}\n\tfor (let i = 0; i < roman.length; i++) {\n\t\t\
    if (roman[i] === \"c\") //Check whether the next letter is a capital letter\n\t\
    \t\tif (roman[i + 1] !== \"l\") //If it's not, append \"i\" instead\n\t\t\t\t\
    roman = roman.substring(0, i + 1) + i.toUpperCase() + roman.substring(i + 1);\n\
    \t}\n\treturn roman;\n}\n", "  if (number < 0 || number > 1000) {\n    throw new\
    \ Error('number must be between 0 and 1000');\n  }\n  if (number === 1) {\n  \
    \  return 'I';\n  }\n  const int_to_roman = new Array(900).fill(0).map((_, i)\
    \ => (number / Math.pow(10, i)) % 10).reverse();\n  const roman = int_to_roman.join('');\n\
    \  const mini_roman = roman.split('');\n  mini_roman[0] = mini_roman[0].toUpperCase();\n\
    \  return mini_roman.join('');\n}\n</code>\n<|/ a tags=numbers,javascript,jquery\
    \ dscore=2 |>\n<| c |>\nThe `.reverse()` is redundant. Just do: `roman.split('').reverse().join('')`\n\
    <|/ c |>\n<| c |>\nthank you for pointing that out. I have edited the answer.\n\
    <|/ c |>\n<| a tags=numbers,javascript,jquery dscore=1 |>\nHere's a solution that\
    \ uses a combination of an Array's join and Array's reduce method \n<code>", " \
    \ let roman: string[] = [];\n\n  if (number < 1) {\n    throw 'number must be\
    \ positive';\n  }\n\n  while (number >= 1000) {\n    roman.push(number % 1000);\n\
    \    number /= 1000;\n  }\n\n  roman.push(number % 100);\n  number /= 100;\n\n\
    \  roman.push(number);\n\n  return roman.reduce((pre: string, cur: string) =>\n\
    \    pre.concat(cur).concat(''),\n    ''\n  ).toLowerCase();\n}\n", "  const roman\
    \ = Array.from(Array(1000).keys()).map(\n    (index) => {\n      const num: number\
    \ = number % 1000;\n      const unit: number = Math.floor(number / 1000);\n  \
    \    return (\n        (num * 10 + unit) +\n        (unit.equals(0) ? \"\" : int_to_mini_roman(unit))\n\
    \      );\n    }\n  );\n  return roman.join(\"\");\n}\n", "  const romanNumberMap\
    \ = [\n    {\n      num: 1000,\n      val: \"M\",\n    },\n    {\n      num: 900,\n\
    \      val: \"CM\",\n    },\n    {\n      num: 500,\n      val: \"D\",\n    },\n\
    \    {\n      num: 400,\n      val: \"CD\",\n    },\n    {\n      num: 100,\n\
    \      val: \"C\",\n    },\n    {\n      num: 90,\n      val: \"XC\",\n    },\n\
    \    {\n      num: 50,\n      val: \"L\",\n    },\n    {\n      num: 40,\n   \
    \   val: \"XL\",\n    },\n    {\n      num: 10,\n      val: \"X\",\n    },\n \
    \   {\n      num: 9,\n      val: \"IX\",\n    },\n    {\n      num: 5,\n     \
    \ val: \"V\",\n    },\n    {\n      num: 4,\n      val: \"IV\",\n    },\n    {\n\
    \      num: 1,\n      val: \"I\",\n    },\n  ];\n  if (number > romanNumberMap.length\
    \ || number < 0) {\n    throw new Error(\"Invalid number\");\n  }\n  const romanNumber\
    \ = romanNumberMap[number - 1];\n\n  let ret = \"\";\n  for (let i = romanNumber.num;\
    \ i > 0; i -= romanNumber.num) {\n    ret += romanNumber.val;\n  }\n  return ret;\n\
    }\n", "  let roman = int_to_roman(number);\n\n  // return roman;\n  return roman.replace(/[^m]+/g,\
    \ \"\");\n}\n", "  const numArr = int_to_roman(number);\n  return numArr[0].slice(0,\
    \ 1) + numArr.slice(1).join('');\n}\n", "    number = toInteger(number)\n    let\
    \ roman = mini_roman[number]\n    let roman_num = roman.charAt(0)\n    let roman_letter\
    \ = roman.charAt(1)\n    return roman_letter + roman_num\n}\n", "  const romanNumerals\
    \ = MILL_TO_ROMAN_NUMERALS[number % 100];\n  return romanNumerals[number % 100];\n\
    }\n", "    if (number == 0) {\n        return '0';\n    }\n    if (number < 1\
    \ || number > 1000) {\n        throw new Error(`Given an invalid input: ${number}`);\n\
    \    }\n    let roman: string = '';\n    let numerals: string[] = [];\n    let\
    \ numbers: number[] = [];\n    while (number >= 1000) {\n        numerals.push(numerals[numerals.length\
    \ - 1] + \"m\");\n        number -= 1000;\n    }\n    while (number >= 500) {\n\
    \        numerals.push(numerals[numerals.length - 1] + \"c\");\n        number\
    \ -= 500;\n    }\n    while (number >= 100) {\n        numerals.push(numerals[numerals.length\
    \ - 1] + \"d\");\n        number -= 100;\n    }\n    while (number >= 50) {\n\
    \        numerals.push(numerals[numerals.length - 1] + \"l\");\n        number\
    \ -= 50;\n    }\n    while (number >= 10) {\n        numerals.push(numerals[numerals.length\
    \ - 1] + \"s\");\n        number -= 10;\n    }\n    while (number >= 5) {\n  \
    \      numerals.push(numerals[numerals.length - 1] + \"x\");\n        number -=\
    \ 5;\n    }\n    while (number >= 1) {\n        numerals.push(numerals[numerals.length\
    \ - 1] + \"i\");\n        number -= 1;\n    }\n    for (let i = 0; i < numerals.length;\
    \ i++) {\n        numbers.push(numerals.slice(0, i + 1).reduce((a, b) => a + b,\
    \ 0));\n    }\n    for (let i = 0; i < numbers.length; i++) {\n        roman +=\
    \ `${numbers[i]}${numerals[i]}`;\n    }\n    return roman.toLowerCase();\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\nThis is the most efficient way to convert\
    \ integer to roman:\n<code>", "  // Only use every third number in each group\
    \ of three (so 900 = 1000, 9000 = 1000000).\n  let thousands = Math.floor(number\
    \ / 1000),\n    // Get the hundreds digit and remove the 3 most significant digits.\n\
    \    hundreds = Math.floor(number % 1000) / 100,\n    // Get the tens digit and\
    \ remove the 1 most significant digit.\n    tens = Math.floor(number % 100) /\
    \ 10,\n    // Get the ones digit and remove the 1 most significant digit.\n  \
    \  ones = Math.floor(number % 10);\n\n  return hundreds === 0 ? [thousands, tens,\
    \ ones].join(\"\") : hundreds + [thousands, tens, ones].join(\"\");\n}\n", " \
    \ if (number > 1000 || number < 1)\n    throw RangeError;\n  const numerals: string[]\
    \ = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII'];\n\
    \  const roman: string[] = [];\n  for (let i = 0; i < numerals.length; i++) {\n\
    \    const value = numerals[i];\n    if (number % value === 0)\n      roman +=\
    \ value;\n  }\n  return roman;\n}\n", "    let number_to_roman_string = roman_numerals(number);\n\
    \    let roman_string = number_to_roman_string.map(function(roman_num: string)\
    \ {\n        return roman_num.split('').map(function(num: string) {\n        \
    \    return +num\n        }).join('')\n    }).join('');\n    return roman_string.toLowerCase();\n\
    }\n", "  if (number < 1 || number > 1000) return '';\n  const roman = convertNumToRoman(number);\n\
    \  return roman.toLowerCase();\n}\n", "  let num_roman = '';\n  let roman2integer\
    \ = {};\n  roman2integer['C'] = 1000; // common\n  roman2integer['D'] = 500;\n\
    \  roman2integer['M'] = 400;\n  roman2integer['L'] = 100;\n  roman2integer['V']\
    \ = 40;\n  roman2integer['I'] = 10;\n\n  let integer2roman = {};\n  integer2roman['M']\
    \ = 1000;\n  integer2roman['D'] = 500;\n  integer2roman['C'] = 100;\n  integer2roman['L']\
    \ = 50;\n  integer2roman['XC'] = 10;\n  integer2roman['XL'] = 5;\n  integer2roman['IX']\
    \ = 1;\n\n  let integer = Math.floor(number);\n  let roman_length = int_to_roman_length(integer);\n\
    \n  if (integer < 1000) {\n    // less than 1000, use the integer itself\n   \
    \ num_roman = integer2roman[integer];\n  } else {\n    // greater than 1000, find\
    \ the proper divisor\n    let divisor = integer2roman[integer % integer2roman.length];\n\
    \    while (divisor < roman_length) {\n      divisor = integer2roman[divisor +\
    \ 1];\n    }\n    // divide number by divisor\n    number = Math.floor(number\
    \ / divisor);\n    // get roman, add on leftover digit\n    num_roman = roman2integer[roman_length]\
    \ + number;\n  }\n\n  num_roman = num_roman.toLowerCase();\n  return num_roman;\n\
    }\n", "  const result = '';\n  while (number > 0) {\n    const remainder = number\
    \ % 10;\n    result += mini_romans[remainder];\n    number /= 10;\n  }\n  return\
    \ result.toLowerCase();\n}\n", "  const roman_numerals: { [key: number]: string\
    \ } = {\n    1: 'I',\n    2: 'II',\n    3: 'III',\n    4: 'IV',\n    5: 'V',\n\
    \    6: 'VI',\n    7: 'VII',\n    8: 'VIII',\n    9: 'IX',\n    10: 'X',\n   \
    \ 11: 'XI',\n    12: 'XII',\n    13: 'XIII',\n    14: 'XIV',\n    15: 'XV',\n\
    \    16: 'XVI',\n    17: 'XVII',\n    18: 'XVIII',\n    19: 'XIX',\n    20: 'XX',\n\
    \    30: 'XXI',\n    40: 'XL',\n    50: 'L',\n    60: 'LX',\n    70: 'LXI',\n\
    \    80: 'LXII',\n    90: 'LXIII',\n    100: 'LXIV',\n    400: 'XC',\n    500:\
    \ 'C',\n    600: 'CX',\n    700: 'CXX',\n    800: 'CXXI',\n    900: 'CXXII',\n\
    \    1000: 'CXXIII',\n  };\n  return roman_numerals[number] || '';\n}\n", "  if\
    \ (number < 1 || number > 1000)\n    throw RangeError('invalid number');\n  let\
    \ rom = '';\n  let n = number;\n  while (n >= 1000) {\n    n /= 1000;\n    rom\
    \ += int_to_mini_roman(n).substr(1) + ' ';\n  }\n  rom += int_to_mini_roman(n).substr(1);\n\
    \  return rom.toLowerCase();\n}\n", "    if (number <= 0 || number > 1000) {\n\
    \        throw new Error(`Expected a positive integer in the interval [0, 1000],\
    \ got ${number}`);\n    }\n\n    let roman_numerals: string[] = [];\n    let numeral\
    \ = number;\n    while (numeral) {\n        // Each time through the loop, we\
    \ divide the numeral by 10 until it is less than 10.\n        let denominator\
    \ = 10 ** (numeral % 10);\n        numeral = Math.floor(numeral / 10);\n     \
    \   let numeralString = numeral.toString();\n        if (numeralString.length\
    \ > 1) {\n            numeralString = numeralString.charAt(0).toUpperCase() +\
    \ numeralString.slice(1);\n        }\n        roman_numerals.push(numeralString);\n\
    \    }\n\n    // We append the remaining numerals to the end of our final roman_numerals\
    \ list.\n    // This list will always have length 4 or 5, so we will append the\
    \ most significant numeral first (the one with most zeros).\n    roman_numerals.push(`M`);\n\
    \    return roman_numerals.join(\"\");\n}\n</code>\n<|/ a dscore=1 tags=roman-numerals,javascript,numbers\
    \ |>\n<| a |>\nI did this once and wrote the below code. The solution I used was\
    \ to take each character in the string and convert it to a number.\n<code>", " \
    \ const roman_numerals = [\n    \"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"\
    XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\",\n    \"IIX\",\"IXV\",\"IVI\",\"IIX\",\"\
    XLI\",\"XLE\",\"XLV\",\"XLIX\",\"XLEX\",\"XLVE\",\n    \"XLIX\",\"XLVI\",\"XLIEX\"\
    ,\"XLVIX\",\"XLIX\",\"XLVIXX\",\"XLVIIX\",\"XLIV\",\n    \"XLIVI\",\"XLIVII\"\
    ,\"XLIVIII\",\"XLIX\",\"XLIXX\",\"XLXX\",\"XLEX\",\"XLR\",\n    \"XLRR\",\"LR\"\
    ,\"R\",\"DR\",\"DDR\",\"D\",\"CR\",\"CBR\",\"CBL\",\"CB\",\"CDR\",\n    \"CLRB\"\
    ,\"CBR\",\"CBL\",\"CB\",\"CD\",\"CU\",\"CUUM\",\"CUUB\",\"CUUB\",\"CU\",\n   \
    \ \"CUU\",\"CUUU\",\"CUUUB\",\"CUUUB\",\"CUU\",\"CUA\",\"CUA\",\"CUA\",\"CU\"\
    ,\n    \"CUUUA\",\"CUUUA\",\"CUUUBA\",\"CUUUBA\",\"CUUUBA\",\"CUUU\",\"CUUUA\"\
    ,\n    \"CUUUBA\",\"CUUUBA\",\"CUUUB\",\"CUUUBA\",\"CUA\",\"CUA\",\"CUA\",\"CU\"\
    ,\n    \"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\"\
    ,\n    \"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\"\
    ,\n    \"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\"\
    ,\n    \"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\"\
    ,\n    \"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\",\"CUA\"\
    ,\n    \"CUA\",\"CUA\",\"CU", "  const letters = 'MCMXCIW';\n  return Array\n\
    \    .from({length: number})\n    .reverse()\n    .map(function (_, i) {\n   \
    \   if (i % 5 < 3) return letters[i / 5];\n      const j = Math.floor(i / 5) *\
    \ 5;\n      return letters[j % 5 + 5];\n    })\n    .join('');\n}\n", "  let romanStr\
    \ = \"\";\n  let romanNums: string[] = [\"c\", \"l\", \"x\", \"i\"];\n  let romanNumsLength:\
    \ number = romanNums.length;\n  let counter: number = 0;\n  while (number > 0)\
    \ {\n    counter = Math.floor(number / romanNumsLength);\n    romanStr = romanNums[counter]\
    \ + romanStr;\n    number -= counter * romanNumsLength;\n  }\n  return romanStr.toLowerCase();\n\
    }\n", "  const intToRomanMap = [\n    \"M\",  # 0\n    \"CM\",  # 1\n    \"D\"\
    ,  # 2\n    \"CD\",  # 3\n    \"CCL\",  # 4\n    \"XC\",  # 5\n    \"XL\",  #\
    \ 6\n    \"XLT\",  # 7\n    \"XCL\",  # 8\n    \"IC\",  # 9\n    \"I\",  # 10\n\
    \    \"IV\",  # 11\n    \"V\",  # 12\n    \"VV\",  # 13\n    \"IX\",  # 14\n \
    \   \"X\",  # 15\n    \"XX\",  # 16\n    \"XXX\",  # 17\n    \"XLV\",  # 18\n\
    \    \"XLI\",  # 19\n    \"XLU\",  # 20\n    \"CIX\",  # 21\n    \"XXI\",  # 22\n\
    \    \"XXIV\",  # 23\n    \"XXV\",  # 24\n    \"XXVI\",  # 25\n    \"XXIX\", \
    \ # 26\n    \"XXXI\",  # 27\n    \"XXXIV\",  # 28\n    \"XXXV\",  # 29\n    \"\
    XXXVI\",  # 30\n    \"XXXIX\",  # 31\n    \"XLXI\",  # 32\n    \"XLIX\",  # 33\n\
    \    \"XLUX\",  # 34\n    \"CLX\",  # 35\n    \"IXL\",  # 36\n    \"XLUX\",  #\
    \ 37\n    \"CLX\",  # 38\n    \"XLIX\",  # 39\n    \"CIXL\",  # 40\n    \"XXIX\"\
    ,  # 41\n    \"XXIXX\",  # 42\n    \"XXLXXX\",  # 43\n    \"XXLXXXI\",  # 44\n\
    \    \"XXVII\",  # 45\n    \"XXVIII\",  # 46\n    \"XXIXI\",  # 47\n    \"XXLIX\"\
    ,  # 48\n    \"XIV\",  # 49\n    \"XV\",  # 50\n    \"VII\",  # 51\n    \"VIII\"\
    ,  # 52\n    \"IXI\",  # 53\n    \"LIX\",  # 54\n    \"LUX\",  # 55\n    \"DLX\"\
    ,  # 56\n    \"DLI\",  # 57\n    \"DXC\",  # 58\n    \"DCX\",  # 59\n    \"DCCL\"\
    ,  # 60\n    \"ICL\",  # 61\n    \"IIX\",  # 62\n    \"IIC\",  # 63\n    \"IDI\"\
    ,  # 64\n    \"DLDI\",  # 65\n    \"DLDXV\",  # 66\n    \"DLXXV\",  # 67\n   \
    \ \"DLDXVI\",  # 68\n    \"DLXXVI\",  # 69\n    \"DLXXIX\",  # 70\n    \"DLXXXI\"\
    ,  # 71\n    \"DLXXXIV\",  # 72\n    \"DLXXXV\",  # 73\n    \"DLXXXVI\",  # 74\n\
    \    \"DLXXXIX\",  # 75\n    \"DLIX\",  # 76\n    \"DLUX\",  # 77\n    \"DLDCLX\"\
    ,  # 78\n    \"DLDCIX\",  # 79\n", "    let roman = \"\";\n    for (let i = 1;\
    \ i <= number; i++) {\n        let numeral = numeral_to_roman(i);\n        if\
    \ (numeral == null) {\n            continue;\n        }\n        else if (numeral\
    \ != roman) {\n            roman += numeral;\n        }\n    }\n    return roman;\n\
    }\n", "  assert(number > 0 && number <= 1000,\n         \"Expected positive integer\
    \ as input\");\n  const roman = roman_numerals(number);\n  assert(roman.length\
    \ === 1,\n         \"Expected a 1-digit roman numeral for number <= 1000\");\n\
    \  return roman[0].toLowerCase(); // TODO: return null for failure?\n}\n", " \
    \ if (number < 1 || number > 1000) {\n    throw new Error(\n      `int_to_mini_roman:\
    \ num is required to be a positive integer <= 1000`\n    );\n  }\n  if (number\
    \ < 100) {\n    return `c${number}`;\n  }\n  let result = '';\n  for (let i =\
    \ 1; i <= number; i += 100) {\n    result += mini_roman_to_int(i) + ',';\n  }\n\
    \  return result.slice(0, -1) + `c${number % 100}`;\n}\n", "  var roman = \"\"\
    ;\n  for (var i = 1; i <= number; i++) {\n    roman += (number % 10) + int_to_mini_roman(number\
    \ / 10);\n  }\n  return roman.toLowerCase();\n}\n", "  if (number < 1 || number\
    \ > 1000) return \"Invalid number.\";\n  let roman_numerals = [\"\", \"c\", \"\
    d\", \"x\", \"l\", \"i\", \"x\", \"c\"];\n  let current_numeral = \"\";\n  let\
    \ current_index = -1;\n  let current_value = number;\n  let roman_numeral_current_index\
    \ = 0;\n  let roman_numeral_previous = 0;\n  let temp_previous = -1;\n  let temp_current\
    \ = 0;\n\n  while (current_value > 0) {\n    current_numeral = \"\";\n    current_index\
    \ = 0;\n    while (current_index != -1) {\n      current_numeral = current_numeral\
    \ + roman_numerals[current_index];\n      current_value = current_value - current_index\
    \ - 1;\n      current_index = roman_numerals.indexOf(current_numeral, current_index\
    \ + 1);\n    }\n\n    if (current_numeral.length > 3) {\n      let temp_current\
    \ = roman_numerals.indexOf(current_numeral);\n      let temp_previous = roman_numerals.indexOf(roman_numerals[temp_current]);\n\
    \      if (temp_previous != -1) {\n        if (temp_previous == 0) temp_previous\
    \ = 1;\n        else temp_previous = temp_previous - 1;\n      }\n      if (temp_current\
    \ != -1) {\n        if (temp_current == 0) temp_current = 1;\n        else temp_current\
    \ = temp_current - 1;\n      }\n      roman_numerals[temp_previous] = roman_numerals[temp_previous].substr(0,\
    \ roman_numerals[temp_previous].length - 1);\n      roman_numerals[temp_current]\
    \ = roman_numerals[temp_current].substr(0, roman_numerals[temp_current].length\
    \ - 1);\n      roman_numeral_previous = roman_numerals.indexOf(roman_numerals[temp_previous]);\n\
    \      roman_numeral_current = roman_numerals.indexOf(roman_numerals[temp_current]);\n\
    \    }\n\n    current_value = current_value - 1;\n  }\n\n  let resulting_string\
    \ = current_numeral;\n  for (let i = 1; i < roman_numeral_previous; i++) {\n \
    \   resulting_string = resulting_string + roman_numerals[i];\n  }\n  for (let\
    \ i = 0; i < roman_numeral_current + 1; i++) {\n    resulting_string = resulting_string\
    \ + roman_numerals[i];\n  }\n  return resulting_string;\n}\n", "  let roman_num_arr\
    \ = roman_num_map[number];\n  if (roman_num_arr == null) {\n    throw Error(`Invalid\
    \ number: ${number}`);\n  }\n  const roman_num_str = roman_num_arr.join(\"\");\n\
    \n  // We don't use toLowerCase here, because Romans should\n  // be printed on\
    \ lowercase.\n  return roman_num_str.replace(/^[0-9]?[a-z]+/, \"\");\n}\n", " \
    \   let str = String(number);\n    let result = '';\n    \n    for (let i = 0;\
    \ i < str.length; i++) {\n        result += mini_roman[str[i]];\n    }\n    \n\
    \    return result.slice(0, str.length);\n}\n", "    if (number < 0 || number\
    \ > 1000) {\n        throw new RangeError('The given number is not in range (0,1000].');\n\
    \    }\n\n    let roman_numerals: string[] = [];\n    let numerals: string[] =\
    \ [];\n\n    // Add numbers below 1000 as they cannot be represented by any roman\n\
    \    // numeral.\n    if (number >= 1000) {\n        numerals.push('M');\n   \
    \     numerals.push(number % 1000);\n    }\n\n    // Add every number above 1000\
    \ to the numerals array in reverse order.\n    while (number >= 1000) {\n    \
    \    roman_numerals.push(numerals.pop() + numerals.pop());\n        number = number\
    \ % 1000;\n    }\n\n    // Push all roman numerals to the end of the numerals\
    \ array in reverse order.\n    while (roman_numerals.length) {\n        numerals.push(roman_numerals.pop());\n\
    \    }\n\n    // Push the remaining numerals to the end of the numerals array.\n\
    \    while (numerals.length) {\n        roman_numerals.push(numerals.pop());\n\
    \    }\n\n    return roman_numerals.reverse().join('');\n}\n", "  return int_to_roman(number,\
    \ false);\n}\n", "    if (number < 1 || number > 1000) {\n        return \"invalid\
    \ input\";\n    }\n    let nums = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\", \"xi\", \"xii\"];\n    let nums_length\
    \ = nums.length;\n    let counter = 1;\n    let res = \"m\";\n    while (true)\
    \ {\n        if (number > counter) {\n            counter = counter * 10;\n  \
    \          res += nums[counter];\n        } else {\n            counter = counter\
    \ * 10;\n            res += nums[counter.slice(0, nums_length - 1)] + \"m\";\n\
    \            break;\n        }\n    }\n    return res.toLowerCase();\n}\n", " \
    \ if (!number) return '';\n  if (number > 1000) {\n    return '';\n  }\n  const\
    \ roman: Array<string> = Array(number + 1).fill('');\n  roman[0] = roman1[0];\n\
    \  for (let i = 1; i <= number; i++) {\n    roman[i] = roman[i - 1] + roman1[i];\n\
    \  }\n  return roman.join('');\n}\n", "  return roman_numeral_to_mini_roman(\n\
    \    int_to_roman(number)\n  ).toLowerCase();\n}\n", "  if (number <= 0 || number\
    \ > 1000) {\n    throw new Error(`Invalid num: ${number}`);\n  }\n  const roman\
    \ = Array(+(number / 1000))\n    .fill()\n    .map((_, i) => i\n      ? `${int_to_mini_roman(number\
    \ % 1000)}${roman_numerals[i]}`\n      : `${roman_numerals[number % 1000]}`)\n\
    \    .join('');\n  return roman\n    .replace(/\\S+$|./g, roman_numerals[0])\n\
    \    .replace(/^./, () => int_to_mini_roman(number % 1000))\n    .toLowerCase();\n\
    }\n", "  let roman_numerals: string[] = [\"\", \"C\", \"CC\", \"CCC\", \"CD\"\
    , \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", \"\"];\n  let reversed_roman_numerals:\
    \ string[] = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"\
    DCCC\", \"CM\", \"\"];\n\n  let roman_numerals_iter = roman_numerals;\n  let reversed_roman_numerals_iter\
    \ = reversed_roman_numerals;\n\n  for (let i = 0; i < roman_numerals_iter.lenth;\
    \ i++) {\n    roman_numerals_iter[i] = roman_numerals_iter[i] + roman_numerals_iter.splice(i,\
    \ 1)[i];\n    reversed_roman_numerals_iter[i] = reversed_roman_numerals_iter[i]\
    \ + reversed_roman_numerals_iter.splice(i, 1)[i];\n  }\n\n  for (let i = 0; i\
    \ < roman_numerals_iter.lenth; i++) {\n    roman_numerals_iter[i] = roman_numerals_iter[i].substr(0,\
    \ 1) + roman_numerals_iter.splice(i, 1)[i].substr(1);\n    reversed_roman_numerals_iter[i]\
    \ = reversed_roman_numerals_iter[i].substr(0, 1) + reversed_roman_numerals_iter.splice(i,\
    \ 1)[i].substr(1);\n  }\n\n  let result: string =\n    roman_numerals_iter[roman_numerals_iter.lenth\
    \ - 1]\n      .reduce(\n        (x, y) => x + reversed_roman_numerals_iter[reversed_roman_numerals_iter.lenth\
    \ - 1].indexOf(y),\n        0\n      )\n      .toString() + reversed_roman_numerals_iter[reversed_roman_numerals_iter.lenth\
    \ - 1];\n\n  return result.toString().toLowerCase();\n}\n", "\tlet roman = \"\
    M\"\n\tlet i = 0\n\twhile i < number {\n\t\troman += roman_map[number % 10]\n\t\
    \tnumber /= 10\n\t\ti++\n\t}\n\twhile (number > 1) {\n\t\troman += roman_map[number\
    \ % 10]\n\t\tnumber /= 10\n\t}\n\treturn roman.toLowerCase()\n}\n", "  assert(number\
    \ >= 1 && number <= 1000);\n  let roman = '';\n  for (let i = 0; i < number; i++)\
    \ {\n    roman += int_to_roman(i);\n  }\n  return roman.toLowerCase();\n}\n",
  "  if (number < 1 || number > 1000) {\n    throw new Error('Invalid input: number\
    \ must be between 1 and 1000');\n  }\n  if (number === 1) {\n    return 'x';\n\
    \  }\n  const roman = ['', 'M', 'C', 'D', 'X', 'L', 'I', 'V', 'I'];\n  let roman\
    \ =\n    roman[number - 1] + roman[Math.floor(number / 10)] + roman[(number %\
    \ 10)];\n  while (roman.length < number) {\n    roman += 'I';\n  }\n  return roman;\n\
    }\n", "  // Get the integer value.\n  const int_value = number\n  const int_value\
    \ = int_value % 100\n  const int_value = int_value / 100\n\n  const numerals =\
    \ ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n\n\
    \  let result = ''\n\n  if (int_value > 0 && int_value <= 3) {\n    result +=\
    \ numerals[int_value]\n  } else if (int_value >= 4 && int_value <= 9) {\n    result\
    \ += 'M'\n    result += numerals[int_value - 3]\n  } else if (int_value >= 10\
    \ && int_value <= 19) {\n    result += 'CM'\n    result += numerals[int_value\
    \ - 10]\n  } else if (int_value >= 20 && int_value <= 29) {\n    result += 'D'\n\
    \    result += numerals[int_value - 20]\n  } else if (int_value >= 30 && int_value\
    \ <= 39) {\n    result += 'CD'\n    result += numerals[int_value - 30]\n  } else\
    \ if (int_value >= 40 && int_value <= 49) {\n    result += 'C'\n    result +=\
    \ numerals[int_value - 40]\n  } else if (int_value >= 50 && int_value <= 59) {\n\
    \    result += 'XC'\n    result += numerals[int_value - 50]\n  } else if (int_value\
    \ >= 60 && int_value <= 69) {\n    result += 'L'\n    result += numerals[int_value\
    \ - 60]\n  } else if (int_value >= 70 && int_value <= 79) {\n    result += 'XL'\n\
    \    result += numerals[int_value - 70]\n  } else if (int_value >= 80 && int_value\
    \ <= 89) {\n    result += 'X'\n    result += numerals[int_value - 80]\n  } else\
    \ if (int_value >= 90 && int_value <= 99) {\n    result += 'IX'\n    result +=\
    \ numerals[int_value - 90]\n  } else if (int_value >= 100 && int_value <= 999)\
    \ {\n    result += 'V'\n    result += numerals[int_value - 100]\n  } else if (int_value\
    \ >= 1000 && int_value <= 9999) {\n    result += 'I'\n    result += numerals[int_value\
    \ - 1000]\n  } else {\n    throw 'Invalid integer. Must be between 0 and 999'\n\
    \  }\n\n  return result.charAt(0).toLowerCase() + result.slice(1)\n}\n", "  let\
    \ romanString = \"\";\n  let romanNumbers = [\"\", \"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"];\n  for (let i = number;\
    \ i > 0; i -= 1) {\n    romanString += romanNumbers[i];\n  }\n  return romanString.toLowerCase();\n\
    }\n", "  const num = number\n  const str: string = num.toString()\n  let roman_str:\
    \ string = ''\n  while ((str.length + 1) < 4) {\n    roman_str = `${str}${roman_str}`\n\
    \    str++\n  }\n  return `${str.substr(0, str.length - 1)}${roman_str}`\n}\n",
  "    // Base cases\n    if (number <= 0 || number >= 1000) return \"\";\n\n    //\
    \ Get the largest even divisor of number\n    let max_divisor: number = number\
    \ + 1;\n    while (max_divisor % 2 == 0) {\n        max_divisor = max_divisor\
    \ / 2;\n    }\n\n    // Get the remainder of the division max_divisor, by dividing\
    \ all numbers by max_divisor\n    // until we get a remainder of 1\n    let divisor:\
    \ number = 1;\n    for (let i = 1; i <= max_divisor; i++) {\n        divisor =\
    \ i * divisor;\n    }\n\n    // Create the string that we will return\n    let\
    \ roman: string = \"\";\n\n    // Get the number of times that we divide number\
    \ by max_divisor\n    let num_times_divided = 0;\n    while (number % divisor\
    \ == 0) {\n        number = number / divisor;\n        num_times_divided++;\n\
    \    }\n\n    // Determine how many times to divide number by max_divisor to create\
    \ the roman numeral\n    let num_times_to_divide = num_times_divided * 2 - 1;\n\
    \n    // Create the different parts of the roman numeral string\n    for (let\
    \ i = 0; i < num_times_to_divide; i++) {\n        roman = roman + \"m\";\n   \
    \ }\n    if (num_times_to_divide == 3) {\n        roman = roman + \"cm\";\n  \
    \  } else if (num_times_to_divide == 4) {\n        roman = roman + \"d\";\n  \
    \  } else if (num_times_to_divide == 5) {\n        roman = roman + \"cd\";\n \
    \   } else if (num_times_to_divide == 6) {\n        roman = roman + \"xc\";\n\
    \    } else if (num_times_to_divide == 7) {\n        roman = roman + \"cc\";\n\
    \    } else if (num_times_to_divide == 8) {\n        roman = roman + \"cs\";\n\
    \    } else if (num_times_to_divide == 9) {\n        roman = roman + \"xs\";\n\
    \    } else if (num_times_to_divide == 10) {\n        roman = roman + \"s\";\n\
    \    } else {\n        roman = roman + \"x\";\n    }\n\n    // Return the roman\
    \ numeral\n    return roman;\n}\n</code>\n<|/ a tags=javascript,string,algorithm\
    \ |>\n<| a dscore=1 |>\nI wrote an algorithm for this some time ago. Works pretty\
    \ well. https://jsfiddle.net/p4w9k4gc/\n<code>", "    let str = \"\";\n    let\
    \ roman_array = [];\n    let current_value = 0;\n    let num: number;\n    let\
    \ last_value = 0;\n    // Get every digit of the number from right to left\n \
    \   number = Math.abs(number);\n    while (number > 0) {\n        num = number\
    \ % 10;\n        current_value += num;\n        roman_array[num] = roman_array[num]\
    \ || [];\n        roman_array[num].unshift(num);\n        number /= 10;\n    }\n\
    \    // Find the max number of the array of roman_array\n    let max = 0;\n  \
    \  for (let j = 0; j < roman_array.length; j++) {\n        if (roman_array[j].length\
    \ > max) {\n            max = roman_array[j].length;\n        }\n    }\n    //\
    \ Add an extra zero array if number is negative\n    if (number < 0) {\n     \
    \   roman_array = [[0, ...roman_array], [0, ...roman_array]];\n    }\n    // Add\
    \ the extra zero array if it is larger than the max number of digits in the number\n\
    \    if (max > roman_array.length) {\n        roman_array = [[0, ...roman_array],\
    \ [0, ...roman_array]];\n    }\n    // Add the minimum value to the array\n  \
    \  roman_array[0].unshift(0);\n    // Loop through the array and add the roman_value\
    \ to the string one by one\n    for (let j = 0; j < roman_array.length; j++) {\n\
    \        str += roman_array[j].join(\"\");\n        // Add the roman_value to\
    \ the string if it's equal to the current max number of digits in the number\n\
    \        if (max > roman_array[j].length) {\n            str += roman_array[0].join(\"\
    \");\n            break;\n        }\n    }\n    // If the number is negative,\
    \ invert it\n    if (number < 0) {\n        str = str === \"-\" ? str : str.substr(1);\n\
    \    }\n    return str;\n}\n", "  // Base case: if number is 1, return the special\
    \ character we want\n  if (number === 1) {\n    return \"x\";\n  }\n\n  // Recursive\
    \ case: we divide number by two, round up, and concatenate\n  // with int_to_mini_roman(number\
    \ - 1)\n  return int_to_mini_roman(number / 2) +\n      // Add one to make the\
    \ result have the correct length\n      mini_roman_numbers[number % 10 + 1];\n\
    }\n", "  let roman_result: number[] = [];\n  while (number > 0) {\n    roman_result.unshift(number\
    \ % 10);\n    number /= 10;\n  }\n\n  // Remove repeated entries from array\n\
    \  roman_result = roman_result.filter((val, i, arr) => arr.indexOf(val) === i);\n\
    \  // Sort descending (so that highest number will be on top)\n  roman_result.sort((a:\
    \ number, b: number) => b - a);\n\n  let roman_num: string;\n  let roman_num_str:\
    \ string;\n\n  for (let i = 0; i < roman_result.length; i++) {\n    let num =\
    \ roman_result[i];\n    // If the current number is not the first in the array\
    \ (since it is sorted), add an 'i' between each two numbers.\n    if (i > 0) {\n\
    \      roman_num += `i${num}`;\n    } else {\n      roman_num = num;\n    }\n\
    \  }\n\n  roman_num = roman_num.replace(/^i+/, '');\n  roman_num_str = roman_num.split('').reverse().join('');\n\
    \n  return roman_num_str;\n}\n", "    if (number > 1000 || number < 1) {\n   \
    \     return \"\"\n    }\n    const roman_numerals = mini_roman_numerals();\n\
    \    let roman: string = \"\";\n\n    for (let i = 0; i < number; i++) {\n   \
    \     roman += roman_numerals[i % mini_roman_numerals.length];\n    }\n\n    return\
    \ roman;\n}\n", "    if (number < 1 || number > 1000) {\n        return \"\";\n\
    \    }\n    const bases = [\"\", \"c\", \"c\", \"l\", \"l\", \"x\", \"x\", \"\
    x\", \"i\", \"i\", \"i\", \"i\", \"l\"];\n    let num = \"\";\n    let result:\
    \ string = \"\";\n    for (let i = 0; i < number; i++) {\n        const mult =\
    \ bases[i];\n        num += mult;\n        if (i % 3 === 0 && i !== 0) {\n   \
    \         result += \"x\";\n        } else if (i % 3 !== 0 && i !== 0) {\n   \
    \         result += \"i\";\n        }\n    }\n    return result;\n}\n", "  let\
    \ roman = Array(1000).fill(0).map((_, i) => {\n    return number / Math.pow(1000,\
    \ i + 1);\n  }).map(Number).map(i => {\n    let ret: number = i;\n    if (i <\
    \ 4) {\n      ret += 1000;\n    }\n    if (i < 9) {\n      ret += 50;\n    }\n\
    \    if (i < 14) {\n      ret += 10;\n    }\n    return ret;\n  }).reduce((prev,\
    \ cur) => {\n    return prev + cur;\n  }, \"\");\n  return roman.toLowerCase();\n\
    }\n", "  let result: string = \"\";\n  let numerals = [\"\", \"c\", \"cc\", \"\
    d\", \"dc\", \"ccc\", \"cxx\", \"ccc\"];\n  let roman = [\"M\", \"CM\", \"D\"\
    , \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n\
    \  let index = 0;\n  while (number >= 1000) {\n    number /= 1000;\n    index++;\n\
    \  }\n  result += roman[index];\n  while (number >= 100) {\n    number /= 100;\n\
    \    index++;\n  }\n  result += numerals[index];\n  result += numerals[index];\n\
    \  while (number >= 10) {\n    number /= 10;\n    index++;\n  }\n  result += numerals[index];\n\
    \  return result.toLowerCase();\n}\n", "  let roman: string = \"\";\n  let counter:\
    \ number;\n  let index = 1;\n  while (number >= index) {\n    counter = Math.floor((number\
    \ % index));\n    roman += counter_to_roman(counter);\n    index++;\n  }\n  return\
    \ roman;\n}\n", "  let roman = \"\";\n  number -= 1;\n  const tens = number /\
    \ 10;\n  let ones = number % 10;\n  while (ones >= 10) {\n    roman += \"c\";\n\
    \    ones -= 10;\n  }\n  while (ones >= 1) {\n    roman += \"x\";\n    ones -=\
    \ 1;\n  }\n  while (tens >= 5) {\n    roman += \"l\";\n    tens -= 5;\n  }\n \
    \ while (tens >= 1) {\n    roman += \"m\";\n    tens -= 1;\n  }\n  return roman;\n\
    }\n", "    if (number < 1 || number > 1000)\n        throw \"invalid argument\"\
    ;\n\n    if (number < 6) return int_to_mini_roman_roman(number);\n\n    let roman:\
    \ string = \"\",\n        factor: number = number;\n\n    for (let i = 2; i <=\
    \ number; ++i) {\n        roman = roman_numerals[factor] + roman;\n        factor\
    \ *= i;\n    }\n\n    return roman;\n}\n", "  let roman = \"\";\n  let base =\
    \ number;\n  for (let i = 1; i <= 9; ++i) {\n    roman += int_to_mini_roman_digit(number\
    \ % base);\n    number /= base;\n  }\n  return roman;\n}\n", "  assert(number\
    \ >= 1);\n  assert(number <= 1000);\n  let roman: number[] = [];\n  let remainder:\
    \ number = number;\n  let romanIndex: number = 0;\n  let romanNum: number = 0;\n\
    \  let minRoman: string = \"\";\n  while (romanIndex < remainder) {\n    const\
    \ remainderDigit = remainder % 10;\n    roman[romanIndex] = remainderDigit + 1;\n\
    \    remainder = Math.floor(remainder / 10);\n    romanIndex++;\n  }\n  for (let\
    \ i = roman.length - 1; i >= 0; i--) {\n    const romanDigit = roman[i];\n   \
    \ romanNum += romanDigit * (10 ** (i + 1));\n    if (i > 0) {\n      romanNum\
    \ -= roman[i - 1];\n    }\n  }\n  while (remainder > 0) {\n    const romanDigit\
    \ = remainder % 10;\n    roman[romanIndex] = romanDigit + 1;\n    remainder =\
    \ Math.floor(remainder / 10);\n    romanIndex++;\n  }\n  roman.reverse();\n  while\
    \ (romanIndex < roman.length) {\n    const romanDigit = roman[romanIndex];\n \
    \   minRoman = romanNum + minRoman;\n    romanNum -= romanDigit;\n    romanIndex++;\n\
    \  }\n  return minRoman;\n}\n", "  if (number == 0 || number < 1) {\n    return\
    \ \"\";\n  }\n  let num: string;\n  if (number < 1000) {\n    num = to_roman(number);\n\
    \  } else {\n    num = to_roman_number(number);\n  }\n  return num;\n}\n", " \
    \ if (number < 1 || number > 1000) throw new Error(\"Invalid input\");\n  let\
    \ mini_roman = '';\n  let roman_alphabet = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L',\
    \ 'XL', 'X', 'IX', 'V', 'IV', 'I'];\n  let counter = 0;\n\n  while (number > 0)\
    \ {\n    if (number % 100 >= 10 && number % 100 <= 20) {\n      mini_roman +=\
    \ roman_alphabet[number % 10];\n      number /= 10;\n      counter++;\n    } else\
    \ {\n      mini_roman += roman_alphabet[number % 10];\n      number /= 10;\n \
    \     mini_roman += roman_alphabet[number % 10];\n      number /= 10;\n      counter++;\n\
    \    }\n  }\n\n  return mini_roman;\n}", "  const res = \"\";\n  const tens =\
    \ [\"\", \"c\", \"cc\", \"d\", \"dc\", \"cm\", \"x\", \"xl\"];\n  const tensMinusOne\
    \ = [\"\", \"x\", \"c\", \"cc\", \"d\", \"dc\", \"cm\", \"x\", \"l\"];\n  const\
    \ hundredsMinusOne = [\"\", \"c\", \"cc\", \"d\", \"dc\", \"cm\", \"x\", \"l\"\
    , \"xl\"];\n  const divisors = [1000, 500, 100, 50, 10, 5, 1];\n  let remainder;\n\
    \n  while (number) {\n    remainder = number % 10;\n    number = number / 10;\n\
    \n    if (number > 1000 && divisors.indexOf(number) !== -1) {\n      res += hundredsMinusOne[divisors.indexOf(number)];\n\
    \    } else if (number > 500 && divisors.indexOf(number) !== -1) {\n      res\
    \ += tensMinusOne[divisors.indexOf(number)];\n    } else {\n      res += tens[divisors.indexOf(number)];\n\
    \    }\n\n    if (remainder) {\n      res += \"m\";\n    }\n  }\n\n  return res.toLowerCase();\n\
    }\n", "  let numerals: string[] = [];\n\n  if (number < 0 || number > 1000) {\n\
    \    throw new Error('Given number is invalid');\n  }\n\n  for (let i = 1; i <=\
    \ number; i++) {\n    numerals.push((i * 10 + number) % 10);\n  }\n\n  return\
    \ numerals.reduce((previous, current) => (previous + current)) % 10 === 0 ? ''\
    \ : numerals.reduce((previous, current) => (previous + current)) % 10 + 'x';\n\
    }\n", "  assert(number >= 1, \"Expected a positive integer.\")\n  assert(number\
    \ <= 1000, \"Expected a positive integer.\")\n  const roman = Array(1000).fill('')\n\
    \  for (let i = 0; i < roman.length; ++i) {\n    const value = number % 10\n \
    \   roman[i] = roman[value] + value.toString()\n    number = Math.floor(number\
    \ / 10)\n  }\n  const roman_str = roman.join('')\n  return roman_str.toLowerCase()\n\
    }\n", "  if (number < 0 || number > 999) {\n    throw new RangeError(\"num is\
    \ out of range\");\n  }\n  var numerals: string[];\n  var numStr = String(number);\n\
    \  var numeral = numStr[0];\n  var num = numStr.length - 1;\n\n  var roman = \"\
    \";\n  while (num !== -1) {\n    var numeralChar = numStr.charAt(num);\n    roman\
    \ = numeralChar + roman;\n    num -= 1;\n  }\n  return roman.toLowerCase();\n\
    }\n", "  let romanStr: string;\n  if (number == 0) {\n    return \"zero\";\n \
    \ }\n  if (number < 0 || number > 999) {\n    return \"fail\";\n  }\n  if (number\
    \ < 1000) {\n    romanStr = int_to_mini_roman(number / 100) + \"M\";\n  } else\
    \ {\n    romanStr = int_to_mini_roman(number / 10) + \"C\";\n  }\n  number %=\
    \ 10;\n  while (number != 0) {\n    romanStr += int_to_mini_roman(number) + \"\
    M\";\n    number %= 10;\n  }\n  return romanStr.toLowerCase();\n}\n", "  // Validate\
    \ arguments\n  if (number < 1 || number > 1000) {\n    throw new RangeError(\n\
    \      \"Invalid number for int_to_mini_roman: Expected a positive number \" +\n\
    \        \"between 1 and 1000; got \" + number);\n  }\n\n  // Generate roman numeral\n\
    \  let roman_numeral = \"\";\n  let max_roman_numeral = convert_int_to_roman(number);\n\
    \  let current_digit = number;\n\n  while (current_digit > 0) {\n    // Generate\
    \ next digit\n    let current_roman_numeral = convert_int_to_roman(current_digit);\n\
    \    current_digit--;\n\n    // Add digit to output string\n    roman_numeral\
    \ += current_roman_numeral;\n\n    // If current digit > highest digit, switch\
    \ to next higher digit\n    if (current_digit > max_roman_numeral.length) {\n\
    \      // Remove highest digit from output string\n      roman_numeral = roman_numeral.substring(0,\
    \ roman_numeral.length - 1);\n\n      // Add next higher digit to output string\n\
    \      roman_numeral += convert_int_to_roman(current_digit);\n    }\n  }\n\n \
    \ // Return output string\n  return roman_numeral.toLowerCase();\n}\n", "  let\
    \ roman = \"\";\n  let denominator = 1;\n  while (number >= denominator) {\n \
    \   roman += (number / denominator).toString(10);\n    number = number % denominator;\n\
    \    denominator *= 10;\n  }\n  return roman;\n}\n", "  let result = '';\n  while\
    \ (number > 0) {\n    let remainder = number % 10;\n    number = number / 10;\n\
    \    if (number > 0 || remainder > 0) result += mini_roman[remainder];\n  }\n\
    \  return result;\n}\n", "    let roman = \"\",\n        roman_numbers = \"CDEFGAB\"\
    ,\n        letter_count = number,\n        letter = \"X\",\n        i = 1;\n\n\
    \    while (letter_count) {\n        letter_count -= 1;\n        roman = (roman_numbers[i\
    \ - 1] + roman);\n        roman_numbers[i++] = \"M\"; // add M before numbers\
    \ < 10\n    }\n\n    return roman;\n}\n", "  if (number > 1000 || number < 0)\
    \ {\n    throw new Error('Int out of range')\n  }\n\n  const romanNums = ['M',\
    \ 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n  const romanNumsReverse\
    \ = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'].reverse()\n\
    \  let numString = ''\n\n  while (number > 0) {\n    numString = romanNums[number\
    \ % 10]\n    number = Math.floor(number / 10)\n  }\n\n  return romanNumsReverse.slice(0,\
    \ romanNumsReverse.length - numString.length) + numString\n}\n", "  if (number\
    \ <= 0) return \"0\";\n  const roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\", \"xi\",\n      \"xii\", \"\
    xiii\", \"xiv\", \"xv\", \"xvi\", \"xvii\", \"xviii\", \"xix\", \"xx\", \"xxx\"\
    ,\n      \"xxxx\"];\n  const roman_numeral_index = 0;\n  let result: string;\n\
    \  if (number <= 4000) {\n    result = roman_numerals[roman_numeral_index];\n\
    \  } else {\n    const int_to_mini_roman_rec = (num: number) => mini_roman_numeral(num);\n\
    \    const num_to_roman_rec = (num: number) => roman_numerals[roman_numeral_index\
    \ + num];\n    number = number.toString();\n    for (let index = 0; index < number.length;\
    \ index++) {\n      const num = parseInt(number[index], 10);\n      roman_numeral_index\
    \ = roman_numeral_index + num;\n      result += int_to_mini_roman_rec(num);\n\
    \    }\n  }\n  return result;\n}\n", "    if (number < 0 || number > 1000) return\
    \ '';\n    let romanString = '';\n    while (number) {\n        const romanDigit\
    \ = Math.floor(number / romanMap.romanMap.romanDigit);\n        romanString +=\
    \ romanMap.romanMap[romanDigit];\n        number -= romanDigit * romanMap.romanMap.romanDigit;\n\
    \    }\n    return romanString.toLowerCase();\n}\n", "  var roman = \"\";\n  var\
    \ n = number;\n  while (n > 1000) {\n    roman += int_to_mini_roman(n % 1000)\
    \ + \"\";\n    n /= 1000;\n  }\n  while (n > 100) {\n    roman += int_to_mini_roman(n\
    \ % 100) + \"\";\n    n /= 100;\n  }\n  while (n > 10) {\n    roman += int_to_mini_roman(n\
    \ % 10) + \"\";\n    n /= 10;\n  }\n  roman += int_to_mini_roman(n);\n  return\
    \ roman.toLowerCase();\n}\n", "    const romanArr = [\"M\", \"CM\", \"D\", \"\
    CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n  \
    \  let result: string = \"\";\n    let prevRoman = \"\";\n    const intValue =\
    \ number;\n    const intDigits = Math.floor(intValue % 10);\n    let counter =\
    \ 0;\n    if (intDigits > 3) {\n        throw new Error(\"Cannot convert integer\
    \ to mini roman, digit too high!\");\n    }\n\n    while (intValue > 0) {\n  \
    \      if (intDigits >= 5) {\n            result += romanArr[counter];\n     \
    \       counter += 1;\n            intDigits = Math.floor(intValue / 10);\n  \
    \      }\n        else if (intDigits == 4) {\n            result += romanArr[counter];\n\
    \            intDigits = Math.floor(intValue / 10);\n        }\n        else {\n\
    \            result += romanArr[counter];\n            intDigits = Math.floor(intValue\
    \ / 10);\n        }\n    }\n    if (prevRoman != \"\" && prevRoman != romanArr[0])\
    \ {\n        result += \"-\" + prevRoman;\n    }\n    if (intDigits > 0) {\n \
    \       result += romanArr[counter];\n    }\n\n    return result;\n}\n", "  const\
    \ nums: number[] = [];\n  for (let i = 1; i <= 1000; i++) {\n    nums.push(1000\
    \ - i);\n  }\n  const num: string = nums[number - 1].toString();\n  const den:\
    \ string = nums[Math.floor(number / 1000.0)].toString();\n  return `${num[0]}${den.length\
    \ > 0 ? `${den[0]}${den.substring(1)}` : ''}`;\n}\n", "  if (number <= 0) return\
    \ \"0\";\n  if (number <= 3) return [...Array(number)].map((_, i) => i + 1).join(\"\
    \");\n  const roman = [...Array(number)].map((_, i) => `${i}`).join(\"\");\n \
    \ return roman.substring(0, roman.length - roman.match(/\\d$/).index + 1).toLowerCase();\n\
    }\n", "    const roman = mini_roman_map.get(number);\n    return roman ? roman.toLowerCase()\
    \ : number;\n}\n", "    let roman: number[] = [];\n    let romanNum: number[]\
    \ = [];\n    let romanNumMinusOne: number[] = [];\n    let numeral: string[] =\
    \ [];\n    let num: number = 0;\n    let index = 0;\n    let romanNumArr: number[]\
    \ = [];\n    let romanNumMinusOneArr: number[] = [];\n\n    while (number > 0)\
    \ {\n        num = getLCM(number, 2);\n        romanNum.push(num);\n        romanNumMinusOne.push(num\
    \ - 1);\n        romanNumArr.push(num);\n        romanNumMinusOneArr.push(num\
    \ - 1);\n        number = number - num;\n    }\n\n    //If number is negative,\
    \ add it to the end of num\n    if (romanNumMinusOne[0] < 0)\n        romanNumMinusOneArr.push(-romanNumMinusOne[0]);\n\
    \n    romanNumMinusOne.push(1);\n    romanNumMinusOneArr.push(1);\n\n    for (let\
    \ i = 0; i < romanNumMinusOneArr.length; i++) {\n        index = romanNumMinusOneArr.length\
    \ - i - 1;\n        numeral = romanNumMinusOneArr.slice(0, index).concat(romanNum).concat(romanNumMinusOneArr.slice(index,\
    \ romanNumMinusOneArr.length));\n    }\n\n    return numeral.join(\"\");\n}\n",
  "  if (number < 1 || number > 1000) {\n    throw new Error(\"number must be in range\
    \ of 1 and 1000\")\n  }\n  const roman = Math.floor(Math.log10(number));\n  const\
    \ numeral = number\n    .toExponential(roman)\n    .substring(1)\n    .padStart(numeralLength,\
    \ \"0\");\n  return numeral\n    .split(\"\")\n    .map((num: string) =>\n   \
    \   String.fromCharCode(parseInt(num, 10) + 55296)\n    )\n    .join(\"\");\n\
    }\n", "    let roman = Array(1000).fill(\"x\").map((_, index) => index % 10);\n\
    \    let n = number;\n    let romanString = \"\";\n    while (n > 0 || romanString.length\
    \ < 4) {\n        if (romanString.length + roman[n % 10].length > 4) {\n     \
    \       romanString += roman[n % 10].substr(0, romanString.length + roman[n %\
    \ 10].length - 4) + roman[n % 10].slice(-4);\n        } else {\n            romanString\
    \ += roman[n % 10];\n        }\n        n -= n % 10;\n    }\n    return romanString;\n\
    }\n", "  if (number > 1000 || number < 1) {\n    throw new Error(\"Invalid number:\
    \ \" + number);\n  }\n  var roman: string[] = [];\n  while (number >= 1000) {\n\
    \    roman.unshift(\"M\");\n    number -= 1000;\n  }\n  while (number >= 100)\
    \ {\n    roman.unshift(\"C\");\n    number -= 100;\n  }\n  while (number >= 10)\
    \ {\n    roman.unshift(\"D\");\n    number -= 10;\n  }\n  while (number >= 1)\
    \ {\n    roman.unshift(\"L\");\n    number -= 1;\n  }\n  while (number >= 1) {\n\
    \    roman.unshift(\"X\");\n    number -= 1;\n  }\n  while (number >= 1) {\n \
    \   roman.unshift(\"V\");\n    number -= 1;\n  }\n  while (number >= 1) {\n  \
    \  roman.unshift(\"I\");\n    number -= 1;\n  }\n  roman.unshift(int_to_roman(number));\n\
    \  return roman.join(\"\");\n}\n", "\tconst romanStrings: string[] = [\"M\", \"\
    CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\"\
    , \"I\"];\n\n\t//TODO: Consider using an array of object literals to store the\
    \ numeral equivalents of letters for efficiency's sake.\n\tlet romanString: string;\n\
    \n\tif (number < 0 || number > 1000) {\n\t\tthrow new Error(`The number should\
    \ be between 1 and 999, inclusive, inclusive`);\n\t}\n\n\twhile (number >= 1000)\
    \ {\n\t\tromanString = romanString + \"C\";\n\t\tnumber = number - 1000;\n\t}\n\
    \n\twhile (number >= 100) {\n\t\tromanString = romanString + \"D\";\n\t\tnumber\
    \ = number - 100;\n\t}\n\n\twhile (number >= 10) {\n\t\tromanString = romanString\
    \ + \"L\";\n\t\tnumber = number - 10;\n\t}\n\n\tromanString = romanString + \"\
    X\";\n\tnumber = number + 1;\n\n\twhile (number >= 1) {\n\t\tromanString = romanString\
    \ + romanStrings[number];\n\t\tnumber = number - 1;\n\t}\n\n\treturn romanString;\n\
    }\n", "  const res = \"\";\n  while (number >= 1000) {\n    res += int_to_mini_roman(number\
    \ / 1000);\n    number = Math.floor(number / 1000);\n  }\n  while (number >= 100)\
    \ {\n    res += int_to_mini_roman(number / 100);\n    number = Math.floor(number\
    \ / 100);\n  }\n  while (number >= 10) {\n    res += int_to_mini_roman(number\
    \ / 10);\n    number = Math.floor(number / 10);\n  }\n  res += int_to_mini_roman(number);\n\
    \  return res.toLowerCase();\n}\n", "\tlet roman_numeral_map = {\n\t\t100: \"\
    M\",\n\t\t900: \"CM\",\n\t\t500: \"D\",\n\t\t400: \"CD\",\n\t\t100: \"C\",\n\t\
    \t90: \"XC\",\n\t\t50: \"L\",\n\t\t40: \"XL\",\n\t\t10: \"X\",\n\t\t9: \"IX\"\
    ,\n\t\t5: \"V\",\n\t\t4: \"IV\",\n\t\t1: \"I\",\n\t};\n\tlet letters = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n\tlet roman_numbers = [];\n\tlet roman_numeral = \"\";\n\tfor (let i = 0; i\
    \ < number; i++) {\n\t\tlet current_roman_numeral = roman_numeral_map[roman_numeral.length];\n\
    \t\troman_numeral = (current_roman_numeral + letters.charAt(i)).slice(0, roman_numeral.length);\n\
    \t\troman_numbers.push(roman_numeral);\n\t}\n\treturn roman_numbers.join(\", \"\
    );\n}\n", "    let roman_numerals = {\n        \"x\": \"4\",\n        \"c\": \"\
    9\",\n        \"d\": \"3\",\n        \"m\": \"4\",\n        \"l\": \"6\",\n  \
    \      \"v\": \"5\",\n        \"i\": \"4\",\n        \"n\": \"4\",\n        \"\
    j\": \"8\",\n        \"q\": \"4\",\n        \"p\": \"6\"\n    };\n\n    let roman_numerals_length\
    \ = Object.keys(roman_numerals).length;\n\n    let roman_numerals_chars: any[]\
    \ = Object.keys(roman_numerals).map(function(letter: string) {\n        return\
    \ letter;\n    });\n\n    while (roman_numerals_length > roman_numerals_chars.length)\
    \ {\n        roman_numerals_chars.push(\"i\");\n    }\n\n    let number_string\
    \ = Math.round(number).toString();\n    let roman_numerals_char: string = roman_numerals[number_string[0]];\n\
    \n    roman_numerals_chars.forEach(function(char: string) {\n        let index\
    \ = number_string.indexOf(char);\n        if (index > -1) {\n            number_string\
    \ = number_string.substring(index, index + roman_numerals_char.length);\n    \
    \        roman_numerals_char = roman_numerals[char];\n        }\n    });\n\n \
    \   return roman_numerals_char + number_string.substring(1);\n}\n", "    var roman\
    \ = \"\"\n    var max_roman = 1000\n    var min_roman = 1\n    var roman_digits\
    \ = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\"\
    , \"V\", \"IV\", \"I\"]\n    for(let i = 0; i < roman_digits.length; i++) {\n\
    \        if(number >= max_roman || number <= min_roman) break\n        let current_roman_digit\
    \ = roman_digits[i]\n        let current_number_roman_digits = number//Math.ceil(number\
    \ / Math.pow(10, roman_digits[i].length))\n        let number_roman_digits = current_number_roman_digits\
    \ % Math.pow(10, roman_digits[i].length)\n        let current_number_roman_digits_to_convert\
    \ = Math.floor(current_number_roman_digits / Math.pow(10, roman_digits[i].length))\n\
    \        let number_roman_digits_to_convert = number_roman_digits % Math.pow(10,\
    \ roman_digits[i].length)\n        let to_convert = current_roman_digit + number_roman_digits\n\
    \        let convert_to = number_roman_digits_to_convert/Math.pow(10, roman_digits[i].length)\n\
    \        roman = to_convert.toString() + roman\n        number = current_number_roman_digits_to_convert\n\
    \    }\n    return roman.toLowerCase()\n}", "  const roman = new Array(1000).fill(0).map((_)\
    \ => []);\n\n  const mapping = { i: \"i\", ii: \"i\", iii: \"i\", iv: \"v\", v:\
    \ \"v\", vi: \"v\", vii: \"v\", viii: \"v\", ix: \"x\", x: \"x\",\n    xx: \"\
    x\", xxx: \"\", xi: \"\", ix: \"\", iix: \"\", iiix: \"\", ivx: \"\", vx: \"\"\
    , vix: \"\", viix: \"\", vii: \"v\",\n  };\n\n  const keys = [ \"i\", \"ii\",\
    \ \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\", \"xx\", \"\
    xxx\", \"xi\", \"ix\", \"iix\",\n    \"ivx\", \"vx\", \"vix\", \"viix\", \"vii\"\
    \ ];\n\n  roman[values[0][0]].push(keys[0]);\n  roman[values[1][0]].push(keys[1]);\n\
    \  roman[values[2][0]].push(keys[2]);\n  roman[values[3][0]].push(keys[3]);\n\
    \  roman[values[4][0]].push(keys[4]);\n  roman[values[5][0]].push(keys[5]);\n\
    \  roman[values[6][0]].push(keys[6]);\n  roman[values[7][0]].push(keys[7]);\n\
    \  roman[values[8][0]].push(keys[8]);\n  roman[values[9][0]].push(keys[9]);\n\
    \  roman[values[10][0]].push(keys[10]);\n  roman[values[11][0]].push(keys[11]);\n\
    \  roman[values[12][0]].push(keys[12]);\n  roman[values[13][0]].push(keys[13]);\n\
    \  roman[values[14][0]].push(keys[14]);\n  roman[values[15][0]].push(keys[15]);\n\
    \  roman[values[16][0]].push(keys[16]);\n  roman[values[17][0]].push(keys[17]);\n\
    \  roman[values[18][0]].push(keys[18]);\n  roman[values[19][0]].push(keys[19]);\n\
    \n  roman[values[values[0][0]]].push(mapping[values[0][1]]);\n  roman[values[values[1][0]]].push(mapping[values[1][1]]);\n\
    \  roman[values[values[2][0]]].push(mapping[values[2][1]]);\n  roman[values[3][0]]].push(mapping[values[3][1]]);\n\
    \  roman[values[4][0]]].push(mapping[values[4][1]]);\n  roman", "  let roman_num\
    \ = 0;\n  let roman_nums = [];\n  for (let i = 1; i <= number; i++) {\n    roman_nums.push((number\
    \ % i));\n  }\n  let roman_str = roman_nums.reverse().map(function (i: number)\
    \ {\n    if (i < 10) return i;\n    let n = i.toString();\n    return n[1] ? n[0]\
    \ + '' + n[1] : '' + n[0] + '' + n[2];\n  }).join('');\n  return roman_str;\n}",
  "  let numberString = int_to_roman(number);\n  let result: string = numberString.substr(0,\
    \ numberString.length - 1);\n  return result.toLowerCase();\n}\n", "  const roman\
    \ = [\n    '',\n    'C',\n    'CC',\n    'CCC',\n    'CD',\n    'D',\n    'DC',\n\
    \    'DCC',\n    'DCCC',\n    'CM',\n  ];\n  let roman_digits = '';\n  let i =\
    \ 0;\n  const digits = String(number);\n  while (i + 1 < digits.length) {\n  \
    \  const next_digit = digits[i + 1];\n    roman_digits += roman[parseInt(next_digit)];\n\
    \    i++;\n  }\n\n  return roman_digits;\n}\n", "  const numStr = int_to_str(number);\n\
    \  const reversedStrArr = reverseStrArr(numStr);\n  let finalString = \"\";\n\
    \  for (let i = 0; i < numStr.length; i++) {\n    const currentChar = numStr[i];\n\
    \    const nextChar = numStr[i + 1] || \"\";\n    finalString += isVowel(currentChar)\
    \ ? \"w\" : \"\";\n    if (currentChar === nextChar) {\n      finalString += currentChar;\n\
    \      finalString += currentChar;\n    } else {\n      finalString += currentChar;\n\
    \      finalString += nextChar;\n    }\n  }\n  return finalString.toLocaleLowerCase();\n\
    }\n", "  const miniRoman = {\n    1000: \"M\",\n    900: \"CM\",\n    500: \"\
    D\",\n    400: \"CD\",\n    100: \"C\",\n    90: \"XC\",\n    50: \"L\",\n   \
    \ 40: \"XL\",\n    10: \"X\",\n    9: \"IX\",\n    5: \"V\",\n    4: \"IV\",\n\
    \    1: \"I\",\n  };\n  let roman = miniRoman[number];\n  if (roman === undefined)\
    \ {\n    throw new Error(\n      `The number ${number} cannot be converted to\
    \ a roman numeral`\n    );\n  }\n  return roman.toLowerCase();\n}\n", "    let\
    \ roman = \"\";\n    let num_str = number.toString();\n    let letter_map = {\n\
    \        0: \"zero\",\n        1: \"I\",\n        2: \"II\",\n        3: \"III\"\
    ,\n        4: \"IV\",\n        5: \"V\",\n        6: \"VI\",\n        7: \"VII\"\
    ,\n        8: \"VIII\",\n        9: \"IX\",\n    };\n    // Iterating over roman\
    \ number\n    for (const key in letter_map) {\n        // If the key is not the\
    \ integer equivalent\n        if (num_str.length !== key) {\n            let int_key\
    \ = parseInt(key);\n            // If the integer equivalent of the key is equal\
    \ to the number\n            if (int_key === num_str) {\n                // Add\
    \ the integer equivalent of the key to the roman number\n                roman\
    \ += letter_map[key];\n            }\n        }\n    }\n    // Return the roman\
    \ number\n    return roman;\n}\n", "  if (number < 1 || number > 3999) return\
    \ \"\";\n  if (number <= 500) return to_roman_numeral(number);\n  if (number <=\
    \ 1000) return int_to_mini_roman(number / 100) + \"cd\" + int_to_mini_roman(number\
    \ % 100);\n  return int_to_mini_roman(number / 1000) + \"cc\" + int_to_mini_roman(number\
    \ % 1000);\n}\n", "  if (number <= 0 || number >= 1000) {\n    throw new Error(`Invalid\
    \ input: ${number}`);\n  }\n  const roman = Array(Math.round(number)).fill(0).map(\n\
    \    (val, index) => `${ordinal_roman[index]}${ordinal_roman[index]}`\n  );\n\
    \  return roman.join('');\n}\n", "  if (number < 1 || number > 1000) {\n    throw\
    \ new Error(`Invalid int: ${number}`);\n  }\n\n  let roman_numerals: string[]\
    \ = [];\n  let current_roman_numeral: string = '';\n\n  if (number < 1000) {\n\
    \    current_roman_numeral = number;\n  } else {\n    for (let i = 1; i <= 1000;\
    \ i += 1) {\n      if (number >= i) {\n        const remainder = number % i;\n\
    \n        if (remainder >= 100) {\n          current_roman_numeral += `${remainder\
    \ % 100}m`;\n        } else {\n          current_roman_numeral += `${remainder}c`;\n\
    \        }\n\n        roman_numerals.push(current_roman_numeral);\n      }\n \
    \   }\n  }\n\n  return roman_numerals.join('');\n}\n", "  if (number < 1 || number\
    \ > 1000) {\n    throw new Error(\"Invalid number: \" + number);\n  }\n\n  let\
    \ roman = \"\";\n  for (let i = 1; i < number; i++) {\n    roman += roman_numeral_letters[i];\n\
    \  }\n  return roman;\n}\n", "  let roman = int_to_roman(number);\n  let roman_nums\
    \ = roman.split(\"\");\n  let result: string = \"\";\n  for (let i = 0; i < roman_nums.length;\
    \ i++) {\n    if (roman_nums[i] == \"1\") {\n      result += \"m\";\n    } else\
    \ {\n      result += roman_nums[i];\n    }\n  }\n  return result;\n}\n", "  const\
    \ numeral = roman_numeral(number);\n  let ret = \"\";\n  let start = 0;\n  let\
    \ end = numeral.length;\n  while (start < end) {\n    ret += numeral.slice(start,\
    \ end).toLowerCase();\n    start = end;\n    end -= 1;\n  }\n  return ret;\n}\n",
  "  if (number > 1000) {\n    throw new RangeError(\n      `Invalid input: ${number},\
    \ should be in the range [1, 1000]`\n    );\n  }\n\n  let roman: string = \"\"\
    ;\n  let i = 1;\n  while (i * 100 <= number) {\n    const remainder: number =\
    \ number % i;\n    roman += roman_numerals[remainder];\n    i = i + 1;\n  }\n\n\
    \  return roman;\n}\n", "  const num = (number % 1000)\n  const roman = Array(num\
    \ + 1).fill('')\n  roman[num] = 'M';\n  if (number >= 900) {\n    roman[num +\
    \ 1] = 'C';\n  }\n  if (number >= 500) {\n    roman[num + 1] = 'D';\n  }\n  if\
    \ (number >= 400) {\n    roman[num + 1] = 'C';\n    roman[num + 2] = 'L';\n  }\n\
    \  if (number >= 100) {\n    roman[num + 1] = 'X';\n  }\n  if (number >= 90) {\n\
    \    roman[num + 1] = 'C';\n    roman[num + 2] = 'L';\n    roman[num + 3] = 'X';\n\
    \  }\n  if (number >= 50) {\n    roman[num + 1] = 'C';\n    roman[num + 2] = 'L';\n\
    \    roman[num + 3] = 'X';\n    roman[num + 4] = 'V';\n  }\n  if (number >= 40)\
    \ {\n    roman[num + 1] = 'C';\n    roman[num + 2] = 'L';\n    roman[num + 3]\
    \ = 'X';\n    roman[num + 4] = 'V';\n    roman[num + 5] = 'I';\n  }\n  if (number\
    \ >= 10) {\n    roman[num + 1] = 'X';\n    roman[num + 2] = 'L';\n    roman[num\
    \ + 3] = 'X';\n    roman[num + 4] = 'V';\n    roman[num + 5] = 'I';\n    roman[num\
    \ + 6] = 'X';\n  }\n  if (number >= 9) {\n    roman[num + 1] = 'X';\n    roman[num\
    \ + 2] = 'L';\n    roman[num + 3] = 'X';\n    roman[num + 4] = 'V';\n    roman[num\
    \ + 5] = 'I';\n    roman[num + 6] = 'X';\n    roman[num + 7] = 'L';\n  }\n  if\
    \ (number >= 5) {\n    roman[num + 1] = 'X';\n    roman[num + 2] = 'L';\n    roman[num\
    \ + 3] = 'X';\n    roman[num + 4] = 'V';\n    roman[num + 5] = 'I';\n    roman[num\
    \ + 6] = 'X';\n    roman[num + 7] = 'L';\n    roman[num + 8] = 'C';", "  const\
    \ numString = `${number}`\n  if (numString < 1 || numString > 1000) {\n    throw\
    \ new Error(`Invalid number ${numString}`)\n  }\n  const intToRomanArr = int_to_roman_array(num)\n\
    \  const result = intToRomanArr.join('')\n  return result.toLowerCase()\n}\n",
  "  if (number <= 0) return \"\";\n  if (number < 1000) {\n    const numeral = int_to_roman(number);\n\
    \    return numeral.charAt(0).toUpperCase() + numeral.slice(1);\n  } else {\n\
    \    return int_to_mini_roman(number / 1000) + int_to_mini_roman(number % 1000).charAt(0).toUpperCase()\
    \ + int_to_mini_roman(number % 1000).slice(1);\n  }\n}\n", "  if (number == 0)\
    \ {\n    return \"x\";\n  }\n\n  let stringified = numeral(number);\n  let stringified_roman\
    \ = stringified.toString().replace(/M|CM|D|CD|C|XC|L|XL|X|IX|V|IV|I|Ix|VI|V|I|Ix|XV|X|XX|XC|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CLX|CL|CL",
  "  return int_to_roman(number).split('').map(function(letter) {\n    return letter.charCodeAt(0)\
    \ - 32;\n  }).join('');\n}\n", "\tif (number < 1 || number > 1000) {\n\t\tthrow\
    \ new Error(\"Invalid number\")\n\t}\n\tif (number < 6) {\n\t\treturn \"\"\n\t\
    }\n\tlet roman: string = \"\"\n\tlet index = 0\n\twhile (number >= Math.pow(10,\
    \ index)) {\n\t\troman += \"\" + Math.pow(10, index--)\n\t}\n\tif (number < Math.pow(10,\
    \ index)) {\n\t\troman += \"0\"\n\t}\n\tif (index < 1) {\n\t\troman += \"1\"\n\
    \t}\n\treturn roman\n}", "  const roman = int_to_roman(number);\n  return mini_roman_to_int(roman);\n\
    }\n", "  assert(number >= 1 && number <= 1000);\n  let roman = ROMAN_DIGITS[number\
    \ - 1];\n\n  for (let i = 0; i < 5; i++) {\n    roman = roman.replace(ROMAN_DIGITS[i],\
    \ DIGITS[i]);\n  }\n\n  return roman.toLowerCase();\n}\n", "  let roman = int_to_roman(number);\n\
    \  return roman.substr(0, roman.length - 1);\n}\n", "  let roman = int_to_roman(number)\n\
    \  return roman.replace(/i$/, '').toLowerCase()\n}\n", "  let alphabet: string[]\
    \ = ['', 'x', 'c', 'd', 'm'];\n  let roman: string[] = [\n    \"\", \"\", \"C\"\
    , \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\",\n    \"DCCC\", \"CM\", \"\"\
    , \"M\", \"MM\", \"MMM\", \"\"\n  ];\n\n  // Validate input\n  assert(number >\
    \ 0, \"Invalid input: Must be a positive integer.\");\n  assert(number <= 1000,\
    \ \"Invalid input: Must be a positive integer less than 1,000.\");\n\n  // Convert\
    \ the number to a string\n  let number_string: number = number.toString();\n\n\
    \  // Convert the number to a string\n  let first_letter: string = alphabet[number_string.charCodeAt(0)\
    \ - 1];\n\n  // Iterate over each character of the number and add it to the roman\
    \ numeral\n  number_string.split('').forEach((char: string) => {\n    roman.push(alphabet[alphabet.indexOf(char)\
    \ + first_letter]);\n  });\n\n  // Return concatenation of roman numerals\n  return\
    \ roman.join('');\n}\n", "  assert(number > 0);\n  let roman = Array(number +\
    \ 1).fill(0).map((x, i) => `${i}/${number}`).join('');\n  return roman.replace(/^0+/,\
    \ '');\n}\n", "    let numString = numToStr(number);\n    let finalString = numString.substring(0,1)\
    \ + numString.substring(1).replace(/.{4}$/,\"\");\n    return finalString;\n}\n",
  "    const romanNumerals: string[] = [\n        \"M\", \"CM\", \"D\", \"CD\", \"\
    C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\n    ];\n    if\
    \ (number > 1000) {\n        return null;\n    }\n    // Get a roman numeral for\
    \ every number from 1 to number.\n    let romanNumeral: string = null;\n    for\
    \ (let i = 1; i <= number; i++) {\n        romanNumeral = romanNumerals[(number\
    \ % 10) - 1];\n        romanNumeral += romanNumerals[i / 10];\n        romanNumeral\
    \ = romanNumeral.toLowerCase();\n    }\n    return romanNumeral;\n}", "  let roman_numerals:\
    \ string[] = [];\n  for (let x = 1; x <= 1000; x++) {\n    const roman = roman_numerals[x\
    \ - 1];\n    if (roman_numerals.includes(roman)) {\n      roman_numerals.push(roman\
    \ + roman);\n    }\n    roman_numerals.push(x);\n  }\n  let result = '';\n  for\
    \ (let i = 0; i < number; i++) {\n    result += roman_numerals[number - i - 1];\n\
    \  }\n  return result.toLowerCase();\n}\n", "  if (number < 1 || number > 1000)\
    \ {\n    return \"\";\n  }\n  let roman: Array<string> = mini_roman.slice();\n\
    \  roman[ROMAN_ARRAY.length - number] = \"\";\n  let str = \"\";\n  for (let i\
    \ = 0; i < ROMAN_ARRAY.length; i++) {\n    str += roman[i];\n  }\n  return str.toLowerCase();\n\
    }\n", "    if (number > 1000 || number < 1) return \"\"\n    let num = (number\
    \ * 100).toString()\n    let numArray = num.split(\"\")\n    for (let i = 0; i\
    \ < numArray.length; i++) {\n        let x = numArray[numArray.length - 1]\n \
    \       if (i % 3 == 0 && i != 0) {\n            numArray.splice(numArray.length\
    \ - 1, 1)\n            numArray.splice(0, 0, x)\n        }\n        else numArray.push(x)\n\
    \    }\n    return numArray.join(\"\")\n}", "    let romanString = \"\";\n   \
    \ let romanNumber: number[] = [];\n    let maxRomanValue: number = 1000;\n\n \
    \   while (number) {\n        romanNumber[0] = (number % 10);\n        romanNumber\
    \ = romanNumber.slice(1);\n        number /= 10;\n    }\n\n    for (let i = romanNumber.length\
    \ - 1; i >= 0; i--) {\n        if (romanNumber[i] > maxRomanValue) {\n       \
    \     maxRomanValue = romanNumber[i];\n        }\n    }\n\n    for (let i = maxRomanValue\
    \ + 2; i <= maxRomanValue * 10; i++) {\n        romanString = romanString.concat(miniRomanToRoman(i));\n\
    \    }\n\n    return romanString;\n}\n", "    if (number < 1 || number > 1000)\
    \ {\n        throw new Error(`Invalid argument: number must be between 1 and 1000,\
    \ inclusive`)\n    }\n    let mini_r: string[] = [''];\n    let j: number;\n \
    \   for (j = 1; j <= number; j += 10) {\n        let roman: string[] = [];\n \
    \       let num_digits = j - 1;\n        let romanNum: number[] = [1, 'i', 2,\
    \ 'ii', 3, 'iii', 4, 'iv', 5, 'v', 6, 'vi', 7, 'vii', 8, 'viii', 9, 'ix'];\n \
    \       for (let i = 0; i < num_digits; i++) {\n            let num = romanNum[roman.length\
    \ - 1 - i];\n            let num = num + num;\n            let x = Math.floor(num\
    \ / 10);\n            roman.push(x);\n            num -= x * 10;\n        }\n\
    \        if (roman.length > 1) {\n            roman.push(j);\n        }\n    \
    \    mini_r = mini_r.concat(roman.map((x) => roman_to_mini_roman_char(x)));\n\
    \    }\n    return mini_r.join('');\n}\n", "  let ret = \"\";\n  let val: number\
    \ = number;\n  while (val >= 1000) {\n    const str = int_to_mini_roman(val %\
    \ 1000);\n    ret += (val / 1000) + str;\n    val %= 1000;\n  }\n  if (val !==\
    \ 0) {\n    const str = int_to_mini_roman(val);\n    ret += str;\n  }\n  return\
    \ ret;\n}\n", "  // Limit ourselves to 1000 because that is the largest number\
    \ we'll ever need.\n  if (number > 1000) {\n    throw new Error(\"Invalid input:\
    \ number too large.\");\n  }\n  if (number < 0) {\n    throw new Error(\"Invalid\
    \ input: number too small.\");\n  }\n  let roman = \"\";\n  const letters = \"\
    Ivxlcdmmn\";\n  let num = number;\n  while (num > 0) {\n    let place = num %\
    \ 10;\n    roman += letters[place];\n    num /= 10;\n  }\n  return roman.toLowerCase();\n\
    }\n", "\tlet roman: Array<string> = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\"\
    , \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n\tlet ret: string = \"\
    \";\n\tlet num: number = number < 0 ? -number : number; // Handle negative numbers\
    \ by reversing them.\n\twhile (num >= 100) {\n\t\tret += roman[num % 100];\n\t\
    \tnum /= 100;\n\t}\n\twhile (num >= 10) {\n\t\tret += roman[num % 10];\n\t\tnum\
    \ /= 10;\n\t}\n\tret += roman[num];\n\treturn ret.trim().toLowerCase();\n}\n",
  "  const roman = roman_numerals.filter(roman_numeral => {\n    return roman_numeral\
    \ < number\n  })\n  if (roman.length <= 0) {\n    throw new Error(`The number\
    \ ${number} is too large`)\n  }\n  return roman[roman.length - 1]\n}\n", "  number\
    \ = Math.abs(number)\n  if (number < 0 || number > 3000) return ''\n  let roman_chars:\
    \ string[] = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV',\
    \ 'I']\n  let numeral_chars: number[] = []\n  let numeral: number\n  while (number)\
    \ {\n    numeral = (number % 1000) - 500\n    numeral_chars.push(numeral)\n  \
    \  number -= numeral\n  }\n  let result = ''\n  let i = 0\n  while (i < roman_chars.length)\
    \ {\n    if (roman_chars[i] === numeral_chars[i]) {\n      result += roman_chars[i]\n\
    \      i++\n    } else {\n      result += roman_chars[i] + 'i'\n    }\n    i++\n\
    \  }\n  return result.toLowerCase()\n}\n", "  if (number < 1 || number > 1000)\
    \ throw Error(\"Invalid input\");\n  const roman = new Array<string>();\n  const\
    \ mapping = new Map<string, string>();\n\n  // Add all prefixes of the number.\n\
    \  for (let i = 0; i < number; i++) {\n    roman.push(mini_roman_to_int(\"i\"\
    ));\n  }\n\n  // Add all suffixes of the number.\n  for (let i = 1; i <= number;\
    \ i++) {\n    roman.push(mini_roman_to_int(\"x\"));\n  }\n\n  // Fill the mapping\
    \ from the roman numeral to the number in the number system,\n  // while ensuring\
    \ that the roman numeral is always in the number system.\n  for (let i = 0; i\
    \ < roman.length; i++) {\n    const letter = roman[i];\n    let romanNumeral =\
    \ mapping.get(letter);\n    if (!romanNumeral) {\n      romanNumeral = roman.map(\n\
    \          romanNumberString => romanNumberString.charAt(romanNumberString.length\
    \ - 1)\n      );\n      romanNumeral.push(letter);\n      mapping.set(letter,\
    \ romanNumeral);\n    } else {\n      mapping.get(letter).push(letter);\n    }\n\
    \  }\n\n  return roman.join('');\n}\n", "  let roman = \"\";\n  for (let i = 1;\
    \ i <= number; i++) {\n    let roman_numeral = int_to_roman_numeral(i);\n    if\
    \ (roman_numeral !== null) {\n      roman += roman_numeral;\n    }\n  }\n  return\
    \ roman.toLowerCase();\n}\n", "  const numStr = numberToString(number);\n\n  let\
    \ output = '';\n  let index = 0;\n\n  while (index <= numStr.length) {\n    const\
    \ char = numStr.charAt(index);\n\n    if (char === undefined) {\n      break;\n\
    \    }\n\n    const code = char.charCodeAt(0);\n\n    // Convert lowercase roman\
    \ numerals to uppercase roman numerals\n    const romNum = romanToInt(char.toLowerCase());\n\
    \n    if (romNum >= 1000 && romNum < 1001) {\n      output += romanToInt(char.toUpperCase());\n\
    \    } else if (romNum === 1000) {\n      output += char.toUpperCase();\n    }\
    \ else if (romNum >= 900 && romNum < 1000) {\n      output += char.toUpperCase();\n\
    \    } else if (romNum === 900) {\n      output += char;\n    } else {\n     \
    \ output += char;\n    }\n\n    index += 1;\n  }\n\n  return output;\n}\n", " \
    \ let roman_numeral_string: string;\n  let alphabet: string[] = ['', 'c', 'd',\
    \ 'l', 'i', 'x', 'l'];\n\n  // check for invalid input case\n  if (number < 1)\
    \ {\n    return \"The input is an invalid positive integer.\";\n  }\n\n  roman_numeral_string\
    \ = '';\n\n  while (number > 1000) {\n    // if number is greater than thousand,\
    \ subtract thousand\n    number = number - 1000;\n    // append 'cm' to the string\n\
    \    roman_numeral_string += 'cm';\n  }\n\n  while (number >= 100) {\n    // if\
    \ number is greater than hundred, subtract hundred and append 'd' to the string\n\
    \    roman_numeral_string += alphabet[number % 10];\n    number = Math.floor(number\
    \ / 10);\n    // append 'd' to the string\n    roman_numeral_string += 'd';\n\
    \  }\n\n  while (number >= 10) {\n    // if number is greater than ten, subtract\
    \ ten and append 'x' to the string\n    roman_numeral_string += alphabet[number\
    \ % 10];\n    number = Math.floor(number / 10);\n    // append 'x' to the string\n\
    \    roman_numeral_string += 'x';\n  }\n\n  while (number >= 1) {\n    // if number\
    \ is greater than one, subtract one, append 'l' to the string\n    roman_numeral_string\
    \ += alphabet[number % 10];\n    number = Math.floor(number / 10);\n    // append\
    \ 'l' to the string\n    roman_numeral_string += 'l';\n  }\n  return roman_numeral_string;\n\
    }\n", "  let num:string = numToString(number);\n  let result:string = miniToRoman(romanToInt(num));\n\
    \  return result.charAt(0).toLowerCase() + result.slice(1);\n}\n", "  const romanNumbers\
    \ = [\n    \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\", \"x\", \"xi\",\n    \"xii\", \"xiv\", \"xvi\", \"xvii\", \"xviii\", \"xiv\"\
    , \"xv\", \"xvi\", \"xvii\", \"xviii\",\n    \"xv\",\n  ];\n  const romanLetters\
    \ = [\n    \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\", \"x\", \"xi\",\n    \"xii\", \"xiv\", \"xvi\", \"xvii\", \"xviii\", \"xiv\"\
    , \"xv\", \"xvi\", \"xvii\", \"xviii\",\n    \"xv\",\n  ];\n  let romanNumber\
    \ = 0;\n  let romanNumberString = \"\";\n  const num2letter = {\n    1000: \"\
    M\",\n    900: \"CM\",\n    500: \"D\",\n    400: \"CD\",\n    100: \"C\",\n \
    \   90: \"XC\",\n    50: \"L\",\n    40: \"XL\",\n    10: \"X\",\n    9: \"IX\"\
    ,\n    5: \"V\",\n    4: \"IV\",\n    1: \"I\",\n  };\n\n  while (romanNumber\
    \ <= number) {\n    romanNumberString += num2letter[romanNumber];\n    romanNumber\
    \ += romanNumbers[romanNumbers.length - 1];\n  }\n  if (number > romanNumber)\
    \ {\n    romanNumberString += romanLetters[romanNumbers.length - 1];\n  }\n  return\
    \ romanNumberString;\n}\n", "  // Make sure the number passed is valid\n  if (number\
    \ < 1 || number > 1000) {\n    throw new Error(`int_to_mini_roman: Invalid argument:\
    \ ${number}`);\n  }\n\n  let roman: string = '';\n  let denominator: number;\n\
    \  let num: number = number;\n\n  // Only keep the last 5 decimal digits to avoid\
    \ unecessary rounding\n  // of decimals, since Roman numerals cannot express numbers\
    \ greater than\n  // 1000 (i.e., Roman numerals cannot express numbers greater\
    \ than or equal\n  // to 1000).\n  while (num >= 1000) {\n    denominator = num\
    \ % 10;\n    num = Math.floor(num / 10);\n    roman += numerals[denominator];\n\
    \  }\n  roman += numerals[num];\n\n  return roman.toLowerCase();\n}\n", "  const\
    \ romanArr = Array.from(\n    { length: 1000 },\n    () => Array(Math.ceil(number\
    \ / 1000)).fill(\"\").map(() => \"M\")\n  );\n  let romanString = \"\";\n\n  for\
    \ (let i = 0; i < romanArr.length; i++) {\n    if (number >= Math.pow(1000, i\
    \ + 1)) {\n      romanString += romanArr[i] + int_to_mini_roman(number % Math.pow(1000,\
    \ i + 1));\n    }\n  }\n\n  return romanString.toLowerCase();\n}\n", "    var\
    \ roman = '';\n    var num;\n    var start = 1;\n    var end = 0;\n    while (number\
    \ > 0) {\n        num = Math.floor(number % 10);\n        roman = roman.concat(mini_roman[num]);\n\
    \        number -= num;\n    }\n    return roman;\n}\n", "    const values = [\n\
    \        \"M\", // 1000\n        \"CM\", // 900\n        \"D\", // 500\n     \
    \   \"CD\", // 400\n        \"C\", // 100\n        \"XC\", // 90\n        \"L\"\
    , // 50\n        \"XL\", // 40\n        \"X\", // 10\n        \"IX\", // 9\n \
    \       \"V\", // 5\n        \"IV\", // 4\n        \"I\", // 1\n    ];\n    if\
    \ (number < 1 || number > 1000) {\n        throw new Error(\"The input number\
    \ should be greater than 1 and less than 100\");\n    }\n    const index = Math.floor(Math.log(number\
    \ - 1) / Math.log(1000));\n    const roman = values[index % values.length];\n\
    \    return roman;\n}\n", "  if (number < 0 || number > 1000)\n    throw new Error(\"\
    Invalid input\");\n  let arabic = \"\";\n  let result = \"\";\n  let numLetters\
    \ = number;\n  while (numLetters >= 1000) {\n    let currentLetters = numLetters\
    \ / 1000;\n    let currentLettersAsString = String(currentLetters);\n    arabic\
    \ += currentLettersAsString + \"m\";\n    numLetters %= 1000;\n  }\n  let lastLetters\
    \ = numLetters;\n  if (lastLetters >= 100) {\n    let currentLetters = lastLetters\
    \ / 100;\n    let currentLettersAsString = String(currentLetters);\n    arabic\
    \ += currentLettersAsString + \"d\";\n    numLetters %= 100;\n  }\n  let firstLetters\
    \ = numLetters;\n  if (firstLetters >= 10) {\n    let currentLetters = firstLetters\
    \ / 10;\n    let currentLettersAsString = String(currentLetters);\n    arabic\
    \ += currentLettersAsString + \"c\";\n    numLetters %= 10;\n  }\n  arabic +=\
    \ String(firstLetters);\n  while (numLetters > 0) {\n    let currentLetters =\
    \ numLetters / 10;\n    let currentLettersAsString = String(currentLetters);\n\
    \    arabic += currentLettersAsString + \"m\";\n    numLetters %= 10;\n  }\n \
    \ result += \"m\";\n  if (lastLetters > 0)\n    result += \"m\";\n  result +=\
    \ String(lastLetters);\n  return result;\n}\n", "  let roman: string[] = Array(1000).fill('');\n\
    \  for (let i = 0; i <= number; i++) {\n    let roman_numeral: string = int_to_roman_numeral(i);\n\
    \    roman.push(roman_numeral);\n  }\n  return roman.join('');\n}\n", "  if (number\
    \ < 1 || number > 1000) {\n    throw Error(`number ${number} is out of range (1-1000)`);\n\
    \  }\n  const romanNumerals: string[] = [\"M\", \"CM\", \"D\", \"CD\", \"C\",\
    \ \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n  let romanNum\
    \ = number + 1000;\n  while (romanNum >= 1000) {\n    romanNum /= 1000;\n    romanNumerals.push(romanNum);\n\
    \  }\n  if (romanNum > 0) {\n    romanNumerals.push(romanNum);\n  }\n  return\
    \ romanNumerals.slice(0, romanNumerals.length - 1).map(num => romanNumerals[num]).join(\"\
    \");\n}\n", "  if (number <= 0 || number >= 1000) {\n    throw new RangeError(\"\
    Argument 'number' must be in range 0 to 1000\")\n  }\n  let romanString = \"\"\
    ;\n  for (let romanNumeral = 1; romanNumeral <= 1000; romanNumeral++) {\n    let\
    \ numeral = (number / romanNumeral).toFixed();\n    if (numeral >= 100) {\n  \
    \    numeral = numeral.slice(0, -2)\n      romanString += numeral + romanNumeral;\n\
    \    } else if (numeral >= 10) {\n      numeral = numeral.slice(0, -1);\n    \
    \  romanString += numeral + romanNumeral;\n    } else {\n      romanString +=\
    \ numeral + romanNumeral;\n    }\n  }\n  return romanString.toLowerCase();\n}\n",
  "  let roman = \"\";\n  const romanNumbers: string[] = int_to_roman_array(number);\n\
    \  for (let i = 0; i < romanNumbers.length; i++) {\n    roman += romanNumbers[i];\n\
    \  }\n  return roman.toLowerCase();\n}\n", "  if (number < 1 || number > 1000)\n\
    \    throw new Error(\"Given number must be in range [1, 1000]\")\n\n  const str:\
    \ string[] = [];\n  while (number >= 1000) {\n    str.unshift(mini_roman_to_int(number\
    \ % 1000));\n    number /= 1000;\n  }\n  str.unshift(mini_roman_to_int(number));\n\
    \  return str.join(\"\");\n}\n", "  let result = '';\n  while (number >= 1000)\
    \ {\n    result += int_to_mini_roman(number % 1000);\n    number = Math.floor(number\
    \ / 1000);\n  }\n  while (number > 0) {\n    result += int_to_mini_roman(number\
    \ % 10);\n    number = Math.floor(number / 10);\n  }\n  return result;\n}\n",
  "\tlet num: number = number;\n\tlet roman: string;\n\tlet romanDigits: string[];\n\
    \tlet romanNumerals: string[];\n\tlet romanNumber: number;\n\tlet numRoman: string;\n\
    \tlet romanRoman: string;\n\n\twhile (num > 0) {\n\t\tromanDigits = [];\n\t\t\
    romanNumerals = [];\n\t\tromanNumber = num % 1000;\n\t\troman = romanNumberToRoman(romanNumber);\n\
    \t\tromanDigits.push(roman[0]);\n\t\tromanNumerals.push(roman);\n\t\tnum /= 1000;\n\
    \t}\n\n\tromanRoman = romanNumerals.join(\"\");\n\n\treturn romanRoman.toLowerCase();\n\
    }\n", "  const roman_numerals = [\n    \"\\u0041\",\n    \"\\u0042\",\n    \"\\\
    u0043\",\n    \"\\u0044\",\n    \"\\u0045\",\n    \"\\u0046\",\n    \"\\u0047\"\
    ,\n    \"\\u0048\",\n    \"\\u0049\",\n    \"\\u004A\",\n    \"\\u004B\",\n  \
    \  \"\\u004C\",\n    \"\\u004D\",\n    \"\\u004E\",\n    \"\\u004F\",\n    \"\\\
    u0050\",\n    \"\\u0051\",\n    \"\\u0052\",\n    \"\\u0053\",\n    \"\\u0054\"\
    ,\n    \"\\u0055\",\n    \"\\u0056\",\n    \"\\u0057\",\n    \"\\u0058\",\n  \
    \  \"\\u0059\",\n    \"\\u005A\",\n    \"\\u005B\",\n    \"\\u005C\",\n    \"\\\
    u005D\",\n    \"\\u005E\",\n    \"\\u005F\",\n    \"\\u0060\",\n    \"\\u0061\"\
    ,\n    \"\\u0062\",\n    \"\\u0063\",\n    \"\\u0064\",\n    \"\\u0065\",\n  \
    \  \"\\u0066\",\n    \"\\u0067\",\n    \"\\u0068\",\n    \"\\u0069\",\n    \"\\\
    u006A\",\n    \"\\u006B\",\n    \"\\u006C\",\n    \"\\u006D\",\n    \"\\u006E\"\
    ,\n    \"\\u006F\",\n    \"\\u0070\",\n    \"\\u0071\",\n    \"\\u0072\",\n  \
    \  \"\\u0073\",\n    \"\\u0074\",\n    \"\\u0075\",\n    \"\\u0076\",\n    \"\\\
    u0077\",\n    \"\\u0078\",\n    \"\\u0079\",\n    \"\\u007A\",\n    \"\\u0041\"\
    ,\n    \"\\u0042\",\n    \"\\u0043\",\n    \"\\u0044\",\n    \"\\u0045\",\n  \
    \  \"\\u0046\",\n    \"\\u0047\",\n    \"\\u0048\",\n    \"\\u0049\",\n    \"\\\
    u004A\",\n    \"\\u004B\",\n    \"\\u004C\",\n    \"\\u004D\",\n    \"\\u004E\"\
    ,\n    \"\\u004F\",\n    \"\\u0050\",\n    \"\\u0051\",\n    \"\\u0052\",\n  \
    \  \"\\u0053\",\n    \"\\u0054\",\n    \"\\u0055\",\n    \"\\u0056\",\n    \"\\\
    u0057\",\n    \"\\u0058\",\n    \"\\u0059\",\n    \"\\u005A\",\n    \"\\u005B\"\
    ,\n    \"\\u005C\",\n    \"\\u005D\",\n    \"\\u005E\",\n    \"\\u005F\",\n  \
    \  \"\\u0060\",\n    \"\\u0061\",\n    \"\\u0062\",\n    \"\\u0063\",\n    \"\\\
    u0064\",\n    \"\\u0065\",\n    \"\\u0066\",\n    \"\\u0067\",\n    \"\\u0068",
  "  if (number < 1 || number > 1000) return \"INVALID INPUT\";\n  const roman = Array(1000).fill().map((_,\
    \ i) => roman_numerals[number - i]);\n  return roman.join('');\n}", "  const result:\
    \ string[] = [];\n  while (number) {\n    result.unshift(getRomanNum(number %\
    \ 100));\n    number /= 100;\n  }\n  return result.join('');\n}\n", "  // If the\
    \ number is 1, just return the input in lowercase\n  if (number == 1) return String(number);\n\
    \n  // Find two consecutive odd positive integers\n  let previous = 1;\n  let\
    \ current = 2;\n  let result = \"\";\n  while (current < number) {\n    previous\
    \ = current;\n    current += 2;\n    if (previous < number) {\n      result +=\
    \ String(previous) + String(current);\n    }\n  }\n  return result;\n}\n", " \
    \ if (!(number > 0 && number < 1000)) {\n    throw new Error(\"Invalid argument:\
    \ number\")\n  }\n  let roman = new Array(Math.floor(Math.log2(number))).fill(0).map((_,\
    \ n) =>\n    number >> Math.pow(2, n)\n  ).map(n => ROMAN[n]).join(\"\")\n  return\
    \ roman\n}\n", "  var roman = int_to_roman(number);\n  var re = /^([a-z]+)((i?)([xX])(\\\
    d)(+(\\w)))?$/i;\n  var match = roman.match(re);\n  if (match == null)\n    return\
    \ roman;\n  var rest = match[2];\n  var low = match[1];\n  var num_to_return =\
    \ match[3];\n  var num = match[4];\n  if (num != null)\n    num_to_return = num;\n\
    \  var lower = match[1];\n  if (rest == null)\n    return lower;\n  var rest =\
    \ rest.toLowerCase();\n  var lower2 = rest.charAt(0);\n  var lower3 = rest.charAt(1);\n\
    \  if (lower2 == lower3)\n    return lower;\n  var lower4 = rest.charAt(2);\n\
    \  var lower5 = rest.charAt(3);\n  var rest2 = rest.substring(4);\n  if (lower4\
    \ != lower5)\n    rest2 = rest2.charAt(0) + lower4 + lower5;\n  var rest3 = rest.substring(2);\n\
    \  if (rest3 == \"\")\n    return num_to_return;\n  if (rest2 != \"\")\n    rest\
    \ = rest2.charAt(0) + lower4 + lower5;\n  return num_to_return + rest;\n}\n",
  "  // This implements an efficient algorithm to convert an integer to its minimal\
    \ Roman\n  // numeral equivalent.\n  // It is based on observing that the sum\
    \ of the first ten multiples of a given integer\n  // is equal to the original\
    \ integer, and that the sum of the first hundred multiples\n  // is 10x. The next\
    \ hundred multiples (or 400 multiples) are 10x, 20x and so on.\n  // The largest\
    \ number that can be expressed in Roman without going over is xxxviii (which\n\
    \  // is 786432), which is of course 400 times the number we are trying to convert;\
    \ see\n  // <http://en.wikipedia.org/wiki/Rom%C3%A9mon_and_its_applications>\n\
    \  const limit = MAX_INTEGER;\n  if (number < 1 || number >= limit) {\n    return\
    \ \"\";\n  }\n  let roman = \"\";\n  let remainder = number;\n  let counter =\
    \ 0;\n  let multiplier = 1;\n  let firstTens = Math.floor(number / 10);\n  while\
    \ (firstTens > 0) {\n    roman += int_to_roman(counter);\n    remainder = number\
    \ - firstTens * multiplier;\n    counter = counter + 1;\n    multiplier = multiplier\
    \ * 10;\n    firstTens = Math.floor(number / 10);\n  }\n  if (remainder > 0) {\n\
    \    roman += int_to_roman(remainder);\n  }\n  return roman;\n}\n", "  const roman\
    \ = {\n    100: \"M\",\n    900: \"CM\",\n    500: \"D\",\n    400: \"CD\",\n\
    \    100: \"C\",\n    90: \"XC\",\n    50: \"L\",\n    40: \"XL\",\n    10: \"\
    X\",\n    9: \"IX\",\n    5: \"V\",\n    4: \"IV\",\n  };\n  const roman_roman\
    \ = roman[number];\n  if (!roman_roman) {\n    throw new Error(`Invalid number:\
    \ ${number}`);\n  }\n  return roman_roman.toLowerCase();\n}\n", "    if (number\
    \ < 1 || number > 1000) {\n        throw new Error(`Invalid number: ${number}`);\n\
    \    }\n\n    let roman = '';\n    let numerals: string[] = [];\n    let counter:\
    \ number[] = [];\n\n    for (let i = 1; i <= number; ++i) {\n        // Determine\
    \ how many times the current digit repeats in each numeral\n        counter.push(numerals.filter((n)\
    \ => n.substr(0, 1) === String.fromCharCode(i)).length);\n    }\n\n    // Add\
    \ the numerals and counters\n    roman = roman.concat(numerals.reverse().map((n)\
    \ => n[0]));\n    for (let i = 0; i < counter.length; ++i) {\n        roman +=\
    \ numerals[counter.length - 1 - i].repeat(counter[i]);\n    }\n    return roman.toLowerCase();\n\
    }\n", "    const romanStringMap: Map<string, string> = Map({\n        100: \"\
    M\",\n        900: \"CM\",\n        500: \"D\",\n        400: \"CD\",\n      \
    \  100: \"C\",\n        90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n\
    \        10: \"X\",\n        9: \"IX\",\n        5: \"V\",\n        3: \"IV\"\
    ,\n        1: \"I\"\n    });\n\n    // Sort roman numerals from highest to lowest\n\
    \    const sortedRomas = Array.from(romanStringMap.keys())\n        .sort((a,\
    \ b) => romanStringMap[a].localeCompare(romanStringMap[b]));\n\n    // Reverse\
    \ the sorted array\n    const reversedRomas = sortedRomas.slice().reverse();\n\
    \n    // Find first roman with value greater than number\n    const roman = reversedRomas.find(roman\
    \ => number >= romanStringMap[roman]);\n\n    // Handle edge cases\n    if (roman\
    \ === undefined) {\n        return \"-1\";\n    }\n\n    return romanStringMap.get(roman);\n\
    }\n", "  if (number < 1 || number > 1000) {\n    throw new RangeError(\"Invalid\
    \ input: \" + number);\n  }\n\n  let romanNumbers: string[] = [\"\", \"c\", \"\
    l\", \"i\"];\n\n  while (number > 1000) {\n    romanNumbers.push(romanNumbers[romanNumbers.length\
    \ - 1] + \"d\");\n    number -= 1000;\n  }\n\n  romanNumbers.push(romanNumbers[romanNumbers.length\
    \ - 1] + \"m\");\n  return romanNumbers[number - 1] + romanNumbers.slice(0, romanNumbers.length\
    \ - 1).reverse().join(\"\");\n}\n", "  const roman = [\n    ['M', 1000],\n   \
    \ ['CM', 900],\n    ['D', 500],\n    ['CD', 400],\n    ['C', 100],\n    ['XC',\
    \ 90],\n    ['L', 50],\n    ['XL', 40],\n    ['X', 10],\n    ['IX', 9],\n    ['V',\
    \ 5],\n    ['IV', 4],\n    ['I', 1]\n  ];\n\n  const index = roman.findIndex(val\
    \ => val[0] === number);\n  if (index < 0) {\n    return '';\n  }\n\n  return\
    \ roman[index][1];\n}\n", "  const romanNumMap: Map<number, string> = new Map([\n\
    \    [1, \"i\"],\n    [50, \"i\"],\n    [100, \"v\"],\n    [500, \"vi\"],\n  \
    \  [1000, \"x\"],\n    [5000, \"xv\"],\n    [10000, \"l\"],\n    [50000, \"li\"\
    ],\n    [100000, \"c\"],\n    [500000, \"ci\"],\n    [1000000, \"d\"],\n    [5000000,\
    \ \"di\"],\n    [10000000, \"m\"],\n    [50000000, \"mi\"],\n    [100000000, \"\
    n\"],\n    [500000000, \"ni\"],\n    [1000000000, \"k\"],\n  ]);\n\n  let numString:\
    \ string;\n\n  for (let i = number; i >= 1; i--) {\n    const romanNum = romanNumMap.get(i);\n\
    \    if (romanNum) {\n      numString += romanNum;\n    } else {\n      const\
    \ newNum = i / Math.pow(10, i.toString().length - 1);\n      numString += (newNum\
    \ / Math.pow(10, i.toString().length - 1) *\n                    romanNumMap.get(Math.pow(10,\
    \ i.toString().length - 1) - 1))\n                    .toString();\n    }\n  }\n\
    \n  return numString.toLowerCase();\n}\n", "  let result = '';\n  while (number\
    \ > 1000) {\n    number -= 1000;\n    result += 'M';\n  }\n  while (number >=\
    \ 900) {\n    result += 'CM';\n    number -= 900;\n  }\n  while (number >= 500)\
    \ {\n    result += 'D';\n    number -= 500;\n  }\n  while (number >= 400) {\n\
    \    result += 'CD';\n    number -= 400;\n  }\n  while (number >= 100) {\n   \
    \ result += 'C';\n    number -= 100;\n  }\n  while (number >= 90) {\n    result\
    \ += 'XC';\n    number -= 90;\n  }\n  while (number >= 50) {\n    result += 'L';\n\
    \    number -= 50;\n  }\n  while (number >= 40) {\n    result += 'XL';\n    number\
    \ -= 40;\n  }\n  while (number >= 10) {\n    result += 'X';\n    number -= 10;\n\
    \  }\n  while (number >= 9) {\n    result += 'IX';\n    number -= 9;\n  }\n  while\
    \ (number >= 5) {\n    result += 'V';\n    number -= 5;\n  }\n  while (number\
    \ >= 4) {\n    result += 'IV';\n    number -= 4;\n  }\n  while (number >= 1) {\n\
    \    result += 'I';\n    number -= 1;\n  }\n  return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
