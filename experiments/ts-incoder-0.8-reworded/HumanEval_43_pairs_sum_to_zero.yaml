name: HumanEval_43_pairs_sum_to_zero
language: ts
prompt: "//pairs_sum_to_zero takes an array of integers as an input.\n// it returns\
  \ true if there are two distinct elements in the array that\n// sum to zero, and\
  \ false otherwise.\n// >>> pairs_sum_to_zero([1, 3, 5, 0])\n// false\n// >>> pairs_sum_to_zero([1,\
  \ 3, -2, 1])\n// false\n// >>> pairs_sum_to_zero([1, 2, 3, 7])\n// false\n// >>>\
  \ pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n// true\n// >>> pairs_sum_to_zero([1])\n\
  // false\nfunction pairs_sum_to_zero(l: number[]): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = pairs_sum_to_zero;\n  assert.deepEqual(candidate([1,\
  \ 3, 5, 0]),false);\n  assert.deepEqual(candidate([1, 3, -2, 1]),false);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, 7]),false);\n  assert.deepEqual(candidate([2, 4, -5, 3, 5, 7]),true);\n\
  \  assert.deepEqual(candidate([1]),false);\n  assert.deepEqual(candidate([-3, 9,\
  \ -1, 3, 2, 30]),true);\n  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 31]),true);\n\
  \  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 30]),false);\n  assert.deepEqual(candidate([-3,\
  \ 9, -1, 4, 2, 31]),false);\n}\n\ntest();"
completions: ["  let arr: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n\
    \    arr.push(l[i]);\n  }\n  return pairs_sum_to_zero2(arr);\n}\n", "\tlet pair:\
    \ number[][] = [];\n\tfor (let i = 0; i < l.length; ++i) {\n\t\tfor (let j = i\
    \ + 1; j < l.length; ++j) {\n\t\t\tconst el = l[i];\n\t\t\tconst el2 = l[j];\n\
    \t\t\tif (el + el2 === 0) {\n\t\t\t\tpair.push([el, el2]);\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn !pair.length ? false : pair.some((el) => el[0] === el[1]);\n}\n",
  "  let hashmap: Map<number, boolean> = new Map();\n  l.sort((a: number, b: number)\
    \ => a - b);\n  for (let i = 0; i < l.length; i++) {\n    if (i > 0) {\n     \
    \ if (l[i - 1] + l[i] == 0) {\n        hashmap.set(l[i], true);\n      } else\
    \ {\n        hashmap.set(l[i], false);\n      }\n    }\n  }\n\n  // returns true\
    \ if there are two distinct elements in the array that\n  // sum to zero, and\
    \ false otherwise.\n  for (let e of hashmap.entries()) {\n    if (e[1] === true)\
    \ {\n      return true;\n    }\n  }\n  return false;\n}\n", "    let pairs = [];\n\
    \    for (let i = 0; i < l.length; i += 2) {\n        pairs.push({ x: l[i], y:\
    \ l[i + 1] });\n    }\n    let count = 0;\n    for (let i = 0; i < pairs.length;\
    \ i++) {\n        if (pairs[i].x === 0) {\n            count++;\n        }\n \
    \   }\n    return count === 1;\n}\n", "  const n = l.length;\n  for (let i = 0;\
    \ i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (l[i] + l[j]\
    \ === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n",
  "  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n\
    \  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      if (l[i] + l[j] == 0) {\n        return false;\n      }\n    }\n\
    \  }\n  return true;\n}\n", "    if (l.length <= 1) {\n        return false;\n\
    \    }\n    const first_element_pair = l[0];\n    const second_element_pair =\
    \ l[1];\n    return (\n        second_element_pair === 0 ||\n        (first_element_pair\
    \ === 0 && second_element_pair === 0)\n    );\n}\n", "  // First we pair up the\
    \ different elements in the list\n  let pairs = l.map(n => [n]);\n  pairs.forEach(pair\
    \ => {\n    let prev = pair[0];\n    let next = pair[1];\n    if (next < 0) {\n\
    \      pair[1] = -next;\n    } else {\n      if (prev >= 0) pairs.splice(pairs.indexOf(pair),\
    \ 0, [prev, -next]);\n      else pairs.push([prev, -next]);\n    }\n  });\n  //\
    \ Then we find the pairs with the same sum\n  let sum = 0;\n  for (let i = 0;\
    \ i < pairs.length; i++) {\n    let pair = pairs[i];\n    sum += pair[0];\n  \
    \  if (sum > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n", "  return\
    \ l.every( (x, i, a) => x === 0 && !(i in a) ) ;\n}\n", "  if(l.length <= 1) return\
    \ false;\n  var pairs = l.reduce((p: number[], c: number, i: number) => {\n  \
    \  if(c == 0) p.push([i, c]);\n    return p;\n  }, []);\n  var found = false;\n\
    \  pairs.forEach(p => {\n    if(found) return;\n    var n = p[0], m = p[1];\n\
    \    if(n + m === 0) found = true;\n  });\n  return found;\n}\n", "  console.log(`l=${l}`);\n\
    \  let hash = {}; // create an empty hash table to hold our hash value for each\
    \ number.\n  for (let i = 0; i < l.length; i++) { // loop through each number\
    \ in our array.\n    let cur = l[i];\n    hash[cur] = hash[cur] ? hash[cur] +\
    \ 1 : 1; // if we've not seen this number before, add it to the hash. otherwise,\
    \ just increment the count.\n  }\n  for (let j = 0; j < l.length; j++) { // loop\
    \ through each number in the array again. compare each number to the hash table.\n\
    \    let cur = l[j];\n    if (hash[cur] == 1) {\n      return false;\n    } else\
    \ if (hash[cur] > 1) {\n      return true;\n    }\n  }\n  return false; // if\
    \ we've not returned here, the loop has run all the way to the end, which means\
    \ no hash values were added to the hash table and we know we have two distinct\
    \ elements.\n}\n", "  for (let i = 0; i < l.length; ++i) {\n    const a = l[i];\n\
    \    let b = l[i - 1];\n    while (a < b) {\n      if (a === 0 && b === 0) return\
    \ true;\n      --b;\n    }\n    if (b === 0) return false;\n  }\n  return true;\n\
    }\n", "  const len = l.length\n  for (var i = 0; i < len; i += 1) {\n    for (var\
    \ j = i + 1; j < len; j += 1) {\n      if (l[i] + l[j] === 0) {\n        return\
    \ true\n      }\n    }\n  }\n  return false\n}\n", "  let n: number = 0;\n  let\
    \ d: number = 0;\n  for (let i = 0; i < l.length; i++) {\n    n = l[i];\n    d\
    \ += n;\n  }\n  if (d === 0) {\n    return true;\n  }\n  for (let i = 0; i < l.length;\
    \ i++) {\n    n = l[i];\n    if (n === 0) {\n      return false;\n    }\n    d\
    \ -= n;\n  }\n  return d === 0;\n}\n", "    let hashTable: { [key: number]: boolean;\
    \ } = {};\n\n    for (let i = 0; i < l.length; ++i) {\n        let pair = l[i];\n\
    \n        if (!hashTable.hasOwnProperty(pair)) {\n            hashTable[pair]\
    \ = true;\n        } else {\n            return false;\n        }\n    }\n\n \
    \   return true;\n}\n", "  l.sort((a, b) => a - b);\n  let ans = false;\n  for\
    \ (let i = 0; i < l.length - 1; i++) {\n    if (l[i] + l[i + 1] != 0) {\n    \
    \  ans = true;\n      break;\n    }\n  }\n  return ans;\n}\n", "  // your code\
    \ here\n  let result: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n\
    \    result.push(l[i]);\n  }\n  let firstValue = result[0];\n  for (let i = 1;\
    \ i < result.length; i++) {\n    let secondValue = result[i];\n    if (secondValue\
    \ < 0) {\n      return false;\n    }\n    if (firstValue + secondValue > 0) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\n", "  const len = l.length;\n\
    \  if (len < 2) {\n    return false;\n  }\n\n  // create an array of pairs of\
    \ integers\n  // the pairs array will be as long as the original array\n  const\
    \ pairs = l.map(function (e, i) { return [i, e]; });\n\n  // sort the pairs by\
    \ their first element\n  // if pairs array contains duplicate values, the last\
    \ pair\n  // of duplicates will sort to the first place\n  // for example, if\
    \ the original array is [1, 3, -2, 1],\n  // then the first pairs array would\
    \ be [2, 1, -3],\n  // and the second pairs array would be [-2, -1, 1, 3],\n \
    \ // and if there are no duplicate values, the pairs array\n  // will contain\
    \ [2, 1, -3]\n  pairs.sort((a, b) => {\n    return a[0] - b[0];\n  });\n\n  const\
    \ twoSum = pairs.filter(function (e) {\n    return e[1] === 0;\n  }).map(function\
    \ (e) {\n    return e[0];\n  });\n  return twoSum.length === len;\n}\n", "  let\
    \ pairs: number[][] = [[], []];\n  let sum_of_pairs: number = 0;\n\n  for (let\
    \ i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      pairs[0] = [];\n   \
    \   pairs[1] = [];\n      sum_of_pairs = 0;\n    } else {\n      pairs[0].push(l[i]);\n\
    \      pairs[1].push(sum_of_pairs);\n    }\n    sum_of_pairs += l[i];\n  }\n \
    \ console.log(pairs);\n  return pairs.every(function (elem) {\n    return elem[1]\
    \ === 0;\n  });\n}", "  l.sort();\n  let i: number;\n  let j: number;\n  let s:\
    \ number;\n  for (i = 0, j = l.length - 1; i < l.length && j < l.length; i++,\
    \ j++) {\n    s = l[i] + l[j];\n    if (s === 0) {\n      return true;\n    }\
    \ else if (s !== 0) {\n      return false;\n    }\n  }\n  return false;\n}\n",
  "  if (l.length === 0)\n    return false;\n  let first = l[0];\n  for (let i = 1;\
    \ i < l.length; i++) {\n    let current = l[i];\n    if (current + first === 0)\n\
    \      return true;\n    if (current + first > 0)\n      first = current;\n  }\n\
    \  return false;\n}\n", "\tlet i: number;\n\tlet j: number;\n\tlet arr: number[];\n\
    \tfor (let i = 0; i < l.length; i++) {\n\t\tarr = [l[i]];\n\t\tfor (let j = 0;\
    \ j < i; j++) {\n\t\t\tarr.push(l[j]);\n\t\t}\n\t\tfor (let j = 0; j < arr.length;\
    \ j++) {\n\t\t\tif (arr[j] < 0) {\n\t\t\t\tarr[j] = 0;\n\t\t\t}\n\t\t}\n\t\tif\
    \ (arr[0] < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "  if\
    \ (l.length < 2) return false;\n  let pairs: number[] = [];\n  for (let i = 0;\
    \ i < l.length; i++) {\n    let next = pairs.length ? pairs[pairs.length - 1]\
    \ : 0;\n    let prev = 0;\n    for (let j = 0; j < pairs.length; j++) {\n    \
    \  let p = pairs[j];\n      if (pairs[j] == next) {\n        let prev = pairs[j\
    \ - 1];\n        break;\n      } else if (pairs[j] > next + p) break;\n    }\n\
    \    pairs.push([prev, next]);\n  }\n\n  let first = pairs[0];\n  let last = pairs[pairs.length\
    \ - 1];\n  if (first[0] == last[0] || first[1] == last[1]) {\n    return true;\n\
    \  } else {\n    return false;\n  }\n}\n", "  if (l.length === 0) {\n    return\
    \ false\n  }\n  for (let i = 0; i + 1 < l.length; i += 2) {\n    if (l[i] - l[i\
    \ + 1] < 0) {\n      return true\n    }\n  }\n  return false\n}\n", "  if (l.length\
    \ < 2)\n    return false\n\n  if (l[0] === 0)\n    return true\n\n  let low =\
    \ 0\n  let high = l.length - 1\n\n  // If there is a zero in the middle somewhere,\
    \ then\n  // we can't possibly have two distinct elements.\n  while (low < high)\
    \ {\n    const mid = Math.floor((low + high) / 2)\n    if (l[mid] === 0) {\n \
    \     low = mid + 1\n    } else {\n      high = mid\n    }\n  }\n\n  const zero_index\
    \ = low - 1\n  const one_index = zero_index + 1\n\n  // If there is a zero somewhere,\
    \ then there is definitely one element\n  // that sums to zero.\n  if (l[zero_index]\
    \ === 0)\n    return false\n\n  // If there is a one somewhere, then there is\
    \ definitely one element\n  // that sums to zero.\n  if (l[one_index] === 0)\n\
    \    return true\n\n  return l[zero_index] > l[one_index]\n}\n", "  var pairs:\
    \ number[][] = array_to_pairs(l);\n  return pairs.some(function (pair) {\n   \
    \ return pairs.every(function (pair2) {\n      return pair[0] + pair2[0] == 0;\n\
    \    });\n  });\n}\n</code>\n<|/ a tags=arrays,javascript,typescript |>\n<| a\
    \ tags=arrays,javascript,typescript |>\nTo complement the great answers by Christian\
    \ Rau and David, I found myself struggling with this problem in TypeScript and\
    \ wanted to share my solution. \nThe key is to convert the array to an object.\
    \ You can then use a for in loop to iterate over the object keys. To check whether\
    \ the key already exists in the object, you can use the in operator with a property\
    \ name in the array which holds the keys. \n<code>\nlet array = [0,1,2,3,4,5,6]\n\
    \nfor (let key in array) {\n  if (array.hasOwnProperty(key)) {\n    let sum =\
    \ array[key];\n    // Do stuff with the element\n    console.log(sum);\n  }\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  let seen = {}\n \
    \ for (let i = 0; i < l.length; i++) {\n    if (seen[l[i]] === true) {\n     \
    \ return true\n    }\n    seen[l[i]] = true\n  }\n  return false\n}\n", "  l =\
    \ l.sort(function(a, b) {\n    return a - b;\n  });\n\n  var zero = false;\n \
    \ for (var i = 1; i < l.length; i++) {\n    if (l[i] + l[i - 1] == 0) {\n    \
    \  zero = true;\n    }\n  }\n\n  return zero;\n}\n", "  for (let i = 0; i < l.length;\
    \ i++) {\n    let currentSum = 0;\n    for (let j = 0; j < l.length; j++) {\n\
    \      if (i == j) {\n        continue;\n      }\n      currentSum += l[j];\n\
    \      if (currentSum > 0) {\n        return false;\n      }\n    }\n  }\n  return\
    \ true;\n}\n", "  let pairs = pairs_sum_to_index(l);\n  return pairs.some(([n,\
    \ i]) => n == 0 || n == i);\n}\n", "  let sum_of_pairs = 0;\n  for (let i = 0;\
    \ i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      sum_of_pairs\
    \ += l[i] * l[j];\n    }\n  }\n  return sum_of_pairs === 0;\n}\n", "  let pairs:\
    \ number[][] = [\n    [1, 3, 5, 0],\n    [1, 3, -2, 1],\n    [1, 2, 3, 7],\n \
    \   [2, 4, -5, 3, 5, 7]\n  ];\n  let sums: number[] = [\n    [0, 2, -5, 5],\n\
    \    [2, 6, -15, 15],\n    [3, 8, -25, 25],\n    [10, 30, -200, 200],\n    [0,\
    \ 2, -5, 5]\n  ];\n  let result: boolean = false;\n\n  for (let i = 0; i < pairs.length;\
    \ i++) {\n    let sum: number = 0;\n    for (let j = 0; j < pairs[i].length; j++)\
    \ {\n      sum += pairs[i][j];\n    }\n    if (sum == 0 && pairs[i][0] != 0) {\n\
    \      result = true;\n      break;\n    }\n  }\n\n  for (let i = 0; i < sums.length;\
    \ i++) {\n    let sum = 0;\n    for (let j = 0; j < sums[i].length; j++) {\n \
    \     sum += sums[i][j];\n    }\n    if (sum == 0) {\n      result = true;\n \
    \     break;\n    }\n  }\n\n  return result;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 tags=algorithm |>\nHere is my javascript implementation\n\n<code>",
  "  if (l.length === 0) return false;\n  let counter: number[][] = [];\n  for (let\
    \ i = 0; i < l.length; i++) {\n    if (counter.length == 0) counter.push([l[i]]);\n\
    \    if (l[i] < 0 || l[i] == 0) {\n      if (counter.length !== 0) {\n       \
    \ for (let j = 0; j < counter.length; j++) {\n          if (l[i] + counter[j][0]\
    \ == 0) return false;\n        }\n      }\n    } else {\n      counter.push([l[i]]);\n\
    \    }\n  }\n  return true;\n}\n", "  l.sort()\n  for (let i = 0; i < l.length\
    \ && l[i] == 0; i++) {}\n  const j = 1\n  for (let i = 1, k = 0; i < l.length;\
    \ i++, k++) {\n    if (l[j] == 0) {\n      if (i === l[j]) {\n        i++\n  \
    \    }\n      j = k\n    }\n  }\n  return l[j] === 0\n}\n", "\tlet pairs: Array<Array<number>>\
    \ = [];\n\n\tfor (let i = 0; i <= l; i++) {\n\t\tlet curr = i;\n\t\tlet j = 0;\n\
    \t\tlet found = false;\n\t\tlet total = 0;\n\n\t\twhile (j < l) {\n\t\t\tif (curr\
    \ + j === l) found = true;\n\t\t\ttotal += l[j];\n\t\t\tj++;\n\t\t}\n\n\t\tif\
    \ (found) {\n\t\t\tpairs.push([curr, total]);\n\t\t}\n\t}\n\n\treturn pairs.every((p)\
    \ => p[1] === 0);\n}\n", "  const pairs: { [index: number]: number } = {};\n \
    \ for (let i = 0; i < l.length; i++) {\n    const p = l[i];\n    if (pairs[p]\
    \ == null) pairs[p] = p;\n    else {\n      if (pairs[p] === p) {\n        //\
    \ found a pair with the same value, return false\n        return false;\n    \
    \  } else {\n        // found another pair with a different value, return false\n\
    \        return false;\n      }\n    }\n  }\n  return true;\n}\n", "    let pairs:\
    \ number[][] = [];\n    for (let i = 0; i < l.length; i++) {\n        let sum\
    \ = 0;\n        for (let j = i + 1; j < l.length; j++) {\n            sum += l[i];\n\
    \            if (sum != 0) {\n                pairs.push([sum, l[j]]);\n     \
    \       }\n        }\n    }\n    return pairs.length != 0;\n}", "  if (l.length\
    \ === 0) return false;\n  const pairs: number[][] = [];\n  for (let i = 0; i <=\
    \ l.length; i++) {\n    pairs.push(l.slice(i));\n  }\n  return pairs.filter((pair)\
    \ => pair.reduce((acc, curr) => acc + curr, 0) === 0).length !== 0;\n}\n", " \
    \ const sortedArray = l.sort((a, b) => a - b);\n  let currentPair = 0;\n  let\
    \ previousPair = 0;\n  for (let i = 0; i < sortedArray.length; i++) {\n    if\
    \ (sortedArray[i] > currentPair) {\n      if (sortedArray[i] - previousPair ===\
    \ 0) {\n        return true;\n      }\n      previousPair = currentPair;\n   \
    \   currentPair = sortedArray[i];\n    }\n  }\n  return false;\n}", "\tlet pairs:\
    \ number[][] = [];\n\tlet sum = 0;\n\tlet n = l.length;\n\tfor (let i = 0; i <\
    \ n; i++) {\n\t\tlet temp = l[i];\n\t\tfor (let j = i + 1; j < n; j++) {\n\t\t\
    \tpairs.push([temp, +l[j]]);\n\t\t\tsum += temp;\n\t\t}\n\t}\n\tfor (let j = 0;\
    \ j < pairs.length; j++) {\n\t\tif (pairs[j][1] === 0) return false;\n\t}\n\t\
    return sum === 0;\n}", "  let n1 = l[0];\n  let n2 = l[1];\n  let n3 = l[2];\n\
    \  for (let i = 2; i < l.length; i++) {\n    let sum = l[i];\n    if (sum < 0)\
    \ {\n      return false;\n    }\n    if (n1 + n2 === sum && n1 + n3 === sum) {\n\
    \      n1 = n2;\n      n2 = n3;\n      n3 = sum;\n    } else if (n2 + n3 === sum\
    \ && n1 + n3 === sum) {\n      n2 = n3;\n      n3 = sum;\n    } else if (n1 +\
    \ n2 === sum && n1 + n3 === sum) {\n      n1 = n3;\n      n3 = sum;\n    } else\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n", "    if (l == null\
    \ || l.length < 2) {\n        return false;\n    }\n\n    const pairs: { [s: number]:\
    \ number } = {};\n    for (let i = 0; i < l.length; ++i) {\n        const current\
    \ = l[i];\n        if (pairs[current] == null) {\n            pairs[current] =\
    \ 0;\n        }\n        if (pairs[current] > 0) {\n            return false;\n\
    \        }\n        pairs[current] += 1;\n    }\n    return true;\n}\n", "  l.reduce((p,\
    \ c) => {\n    if (Math.abs(c) < Math.abs(p)) return false;\n    if (c < 0 ||\
    \ p < 0 || c > p || p > Number.MAX_SAFE_INTEGER) return true;\n    if (Math.abs(p\
    \ - c) <= 2) return true;\n    return false;\n  }, true);\n}\n", "  const n =\
    \ l.length;\n  let i = 0;\n  let j = n - 1;\n  let k = i;\n  let s = 0;\n  while\
    \ (i < j) {\n    s += l[k];\n    i++;\n    k += 1;\n    while (k >= i && l[k]\
    \ === l[i] - s) {\n      k--;\n    }\n  }\n  return i === j && l[i] === 0;\n}\n",
  "\tlet sum = 0;\n\tfor (let i = 0; i < l.length; i++) {\n\t\tsum += l[i];\n\t}\n\
    \treturn (sum === 0) && l.length <= 2;\n}\n", "  return l.length !== l.filter((_)\
    \ => !Number.isNaN(_)).filter(x => x >= 0).length\n}\n", "  const pairs: number[][]\
    \ = [];\n  for (let i = 0; i < l.length; i++) {\n    let j = 0;\n    while (j\
    \ < pairs.length && pairs[j][0] === l[i]) {\n      j++;\n    }\n    if (j >= pairs.length)\
    \ {\n      pairs.push([l[i], 1]);\n    } else {\n      pairs[j][1] = pairs[j][1]\
    \ + 1;\n    }\n  }\n  for (let i = 0; i < pairs.length; i++) {\n    if (pairs[i][1]\
    \ > 1) {\n      return false;\n    }\n  }\n  return true;\n}\n", "  if (l.length\
    \ < 2) return false;\n  let prev = 0;\n  for (let i = 0; i < l.length; i++) {\n\
    \    let current = l[i];\n    if (current > prev) {\n      return true;\n    }\n\
    \    prev = current > prev ? current : prev;\n  }\n  return false;\n}\n", "  let\
    \ pairs = [];\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1;\
    \ j < l.length; j++) {\n      if (l[i] + l[j] === 0) pairs.push([l[i], l[j]]);\n\
    \    }\n  }\n  return (pairs.length > 1) ? false : true;\n}\n", "  var zero =\
    \ 0;\n  var pairs: number[][] = [];\n  for (var i = 0; i < l.length; i++) {\n\
    \    for (var j = i + 1; j < l.length; j++) {\n      pairs.push(l[i] + l[j]);\n\
    \      if (pairs[pairs.length - 1] == 0) {\n        zero++;\n        pairs.length\
    \ = 0;\n      }\n    }\n  }\n  return pairs.length >= 2;\n}", "    let s = sum(l);\n\
    \    if (s === 0) return false;\n    for (let i = 0; i < l.length; i++) {\n  \
    \      if (l[i] !== -s && l[i] !== s) return false;\n    }\n    return true;\n\
    }\n", "  var total = 0;\n  for (var i = 0; i < l.length; ++i) {\n    total +=\
    \ l[i];\n  }\n  for (var i = 0; i < l.length; ++i) {\n    var j = i + 1;\n   \
    \ while (j < l.length && l[j] == 0) j++;\n    if (j == l.length) {\n      return\
    \ true;\n    }\n    var k = i + 1;\n    while (k <= j && l[k] == 0) k++;\n   \
    \ if (k == j) {\n      return true;\n    }\n    if (total < 0) {\n      return\
    \ false;\n    }\n    total -= l[i];\n    for (var j = i + 1; j <= k; ++j) {\n\
    \      l[j] = -l[j];\n    }\n    l[k] = 0;\n  }\n  return false;\n}\n", "  return\
    \ l.length === 1 || l.length == 0;\n}\n", "  l.sort(); //sorting ensures that\
    \ all sums to zero come before the rest.\n  let x: number;\n  let y: number;\n\
    \  let sum: number;\n  let cnt: number;\n  let max: number;\n  let min: number;\n\
    \  let x: number;\n  let y: number;\n  let sum: number;\n  let cnt: number;\n\
    \  let max: number;\n  let min: number;\n  for (let i = 0; i < l.length - 1; i++)\
    \ {\n    cnt = 1;\n    sum = 0;\n    max = l[i];\n    min = l[i + 1];\n    for\
    \ (let j = i; j < l.length; j++) {\n      sum += l[j];\n      if (max < sum) {\n\
    \        max = sum;\n        x = j;\n        cnt = 1;\n      }\n      else if\
    \ (min > sum) {\n        min = sum;\n        y = j;\n        cnt = 1;\n      }\n\
    \      else {\n        cnt++;\n      }\n    }\n    if (cnt > 1) {\n      return\
    \ true;\n    }\n  }\n  return false;\n}", "  const n = l.length;\n  let k = 0;\n\
    \  for (let i = 1; i < n; ++i) {\n    k += l[i]; // accumulate sum\n    if (k\
    \ <= 0) return false; // return false if sum exceedes zero\n    else k = k - l[i];\
    \ // otherwise, remove that element from the sum\n  }\n  return true; // return\
    \ true if all sums are zero\n}\n", "  let hashTable: Map<number, boolean> = new\
    \ Map();\n  for (let i = 0; i !== l.length; ++i) {\n    if (!hashTable.has(l[i]))\
    \ {\n      hashTable.set(\n        l[i],\n        (l[i] + l[(i + 1) % l.length]\
    \ === 0) ? true : false);\n    }\n  }\n  for (let [key, value] of hashTable) {\n\
    \    if (value) {\n      return false;\n    }\n  }\n  return true;\n}\n", "  let\
    \ n = l.length;\n  for (let i = 0; i < n - 1; ++i) {\n    let sum = l[i] + l[i\
    \ + 1];\n    if (sum < 0) {\n      return false;\n    }\n  }\n  return true;\n\
    }\n", "\tlet counter: number[] = []\n\tfor (let i = 0; i < l.length; i++){\n\t\
    \tif (counter.indexOf(l[i]) == -1){\n\t\t\tcounter.push(l[i])\n\t\t}\n\t}\n\t\
    for (let i = 0; i < counter.length; i++){\n\t\tcounter[i] -= l[i]\n\t}\n\treturn\
    \ counter.length < 2 ? false : true\n}\n", "  var pairs: number[][] = [];\n  for\
    \ (var i = 0; i < l.length; ++i) {\n    var x = l[i];\n    for (var j = i + 1;\
    \ j < l.length; ++j) {\n      var y = l[j];\n      if (x === y) continue;\n  \
    \    if (x === 0) return false; // ignore zero elements\n      if (y === 0) return\
    \ false;\n      if (x === y) return true; // ignore equal elements\n      var\
    \ z = x + (y > 0 ? y - x : 0);\n      if (pairs[z] === undefined) {\n        pairs[z]\
    \ = [];\n      }\n      pairs[z].push([x, y]);\n    }\n  }\n  for (var z = 0;\
    \ z < pairs.length; ++z) {\n    var pair = pairs[z];\n    if (pair.length ===\
    \ 0) continue;\n    if (pair.length === 1) return false;\n    for (var j = 0;\
    \ j < pair.length; ++j) {\n      var y = pair[j][1];\n      if (y === 0) return\
    \ false;\n    }\n  }\n  return true;\n}\n", "  return l.length < 2\n      || (l.reduce((a,\
    \ b)=> a + b) === 0);\n}\n", "  let result: boolean = false;\n  for (let i = 0;\
    \ i < l.length; i++) {\n    let first_pair = l[i];\n    let second_pair = l[i\
    \ + i];\n    if (first_pair + second_pair == 0) {\n      result = true;\n    \
    \  break;\n    }\n  }\n  return result;\n}\n", "  const pairs: number[][] = [[],\
    \ []];\n  for (const n of l) {\n    pairs[n - 1][n - 1] = 1;\n    pairs[n - 1][n]\
    \ = 1;\n    pairs[n][n - 1] = 1;\n    pairs[n][n] = 1;\n  }\n  pairs.sort((a,\
    \ b) => a - b);\n  return pairs.filter((p, i, arr) => arr.indexOf(p) === i).length\
    \ === 0;\n}\n", "  let pairs: number[][] = [];\n  for (let i = 0; i < l.length;\
    \ ++i) {\n    let current = l[i];\n    for (let j = i + 1; j < l.length; ++j)\
    \ {\n      let next = l[j];\n      if (current + next > 0) {\n        pairs.push([current,\
    \ next]);\n      }\n    }\n  }\n  if (pairs.length === 0) {\n    return false;\n\
    \  }\n  let distinctPairs = pairs.filter(pair => pair[0] === pair[1]);\n  return\
    \ distinctPairs.length === 0;\n}\n", "    let pairs: number[][] = [];\n    for\
    \ (let i = 0; i <= l.length - 1; i++) {\n        for (let j = i + 1; j <= l.length\
    \ - 1; j++) {\n            pairs.push([l[i], l[j]]);\n        }\n    }\n    if\
    \ (pairs.some(pair => pair[0] === 0 && pair[1] === 0)) {\n        return true;\n\
    \    }\n    return false;\n}\n", "    if (l == null) return false\n    let result:\
    \ boolean = false\n    for (let i = 0; i < l.length; i++) {\n        for (let\
    \ j = i + 1; j < l.length; j++) {\n            if (l[i] + l[j] === 0) {\n    \
    \            result = true\n                break\n            }\n        }\n\
    \    }\n    return result\n}\n", "  let n = 0;\n  let sum = 0;\n  for (const n\
    \ of l) {\n    sum += n;\n  }\n  for (const n of l) {\n    n -= sum;\n    if (n\
    \ != 0) return false;\n  }\n  return true;\n}\n", "    let n: number = l.length;\n\
    \    let i: number = 0;\n    let j: number = 0;\n\n    // If no elements, no match.\n\
    \    if (n === 0) return false;\n    // If one element, return false.\n    if\
    \ (n === 1) return l[0] === 0;\n    // If exactly one element, return true.\n\
    \    if (l[0] === 0) return true;\n\n    // Keep incrementing while there are\
    \ pairs left to sum.\n    while (i < n) {\n        j = i + 1;\n\n        while\
    \ (j < n) {\n            // If pair is found, the answer is true.\n          \
    \  if (l[j] === l[i] + l[j]) {\n                return true;\n            }\n\
    \            // If the sum of the pair is zero, the answer is false.\n       \
    \     else if (l[j] === 0) {\n                return false;\n            }\n \
    \           j++;\n        }\n        i++;\n    }\n}\n", "  let i = l.length -\
    \ 1;\n  while (i > 0) {\n    if (l[i] === 0 && l[i - 1] === 0 && l[i - 2] ===\
    \ 0) {\n      return true;\n    } else {\n      i--;\n    }\n  }\n  return false;\n\
    }\n", "  const map = new Map<number, boolean>();\n  for (const e of l) {\n   \
    \ map.set(e, false);\n  }\n  let sum = 0;\n  for (const v of l) {\n    const cur\
    \ = map.get(v);\n    if (cur) {\n      map.set(v, false);\n    } else {\n    \
    \  map.set(v, true);\n      sum += v;\n    }\n  }\n  for (const v of map.keys())\
    \ {\n    const cur = map.get(v);\n    if (cur) {\n      map.set(v, false);\n \
    \   } else {\n      map.set(v, true);\n      sum += v;\n    }\n  }\n  return map.size\
    \ === 0 || map.size === sum;\n}\n", "  l.sort();\n  const pairs: number[][] =\
    \ [];\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j <\
    \ l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        pairs.push([l[i],\
    \ l[j]]);\n      }\n    }\n  }\n  return pairs.length > 1;\n}\n", "    let pairs:\
    \ number[][] = pairs(l);\n    let sum_of_pairs = pairs.reduce(\n        (acc,\
    \ pair) => {\n            let [s, t] = pair;\n            return acc + s + t;\n\
    \        },\n        0\n    );\n    if (pairs.length != sum_of_pairs) {\n    \
    \    return false;\n    }\n\n    for (let i = 1; i < pairs.length; i++) {\n  \
    \      let [s, t] = pairs[i];\n        if (s > t) {\n            return false;\n\
    \        }\n    }\n    return true;\n}", "    let lastSum = 0;\n    let firstIndex\
    \ = 0;\n    let secondIndex = 1;\n    while (firstIndex < l.length) {\n      \
    \  if (l[firstIndex] + l[secondIndex] == 0) {\n            lastSum = l[firstIndex];\n\
    \            firstIndex++;\n            secondIndex++;\n        } else {\n   \
    \         break;\n        }\n    }\n    return firstIndex != l.length ? false\
    \ : l[secondIndex] == lastSum;\n}\n", "  if (l.length === 0) {\n    return false;\n\
    \  }\n\n  const arr1: number[] = l.slice();\n  const arr2: number[] = l.slice();\n\
    \n  arr1.sort((a, b) => a - b);\n  arr2.sort((a, b) => b - a);\n\n  let last:\
    \ number = arr1[0];\n\n  for (let i = 1; i < arr1.length; i++) {\n    if (arr1[i]\
    \ !== last) {\n      return false;\n    }\n    last = arr2[i];\n  }\n  return\
    \ true;\n}\n", "    var pairs: number[][] = [[], [], []];\n    for (var i = 0;\
    \ i < l.length; i++) {\n        var pair = [l[i], i];\n        pairs[l[i] - 1][i\
    \ - 1] = pairs[l[i] - 1][i - 1] + pairs[l[i] - 1][i] + pairs[i];\n    }\n    for\
    \ (var pair_i = 0; pair_i < pairs.length; pair_i++) {\n        if (pairs[pair_i].length\
    \ > 1) {\n            return true;\n        }\n    }\n    return false;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nIf you can use a hashmap then you can achieve this\
    \ in a single iteration.\n<code>\ndef isPerfectSquare(square: Int): Boolean =\
    \ square in 1..10\n\ndef isPerfectSquare(square: Int, d: Int): Boolean = square.toString.length\
    \ == d &&\n    square * square in 1..10\n\ndef perfectSquare(square: Int): Boolean\
    \ = isPerfectSquare(square, 2) &&\n    square * square in 1..10\n</code>\n<|/\
    \ a dscore=0 tags=loops,algorithm,math,combinatorics |>\n<| a tags=loops,algorithm,math,combinatorics\
    \ |>\nThe following function returns true if the number is perfect square.\n<code>",
  "    var n = l.length;\n    if (n < 2) return false;\n    var i, j, count = 0;\n\
    \    for (i = 0; i < n; ++i) {\n        for (j = 0; j < n; ++j) {\n          \
    \  count += l[i] + l[j];\n        }\n    }\n    return count < 0;\n}\n</code>\n\
    The only problem with this solution is that it runs in O(n2) time on average.\
    \ Using a hash map reduces the worst case performance from O(n2) to O(n).\n<|/\
    \ a |>\n<| a dscore=0 |>\n<code>\nconst fs = require('fs');\nconst readline =\
    \ require('readline');\n", "  let seen = new Set();\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (seen.has(l[i])) {\n      return false;\n    }\n    seen.add(l[i]);\n\
    \  }\n  return true;\n}\n", "  for (var i = 0; i < l.length; i++) {\n    for (var\
    \ j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        return\
    \ false;\n      }\n    }\n  }\n  return true;\n}\n", "  return l.length <= 1 ||\
    \ (l.length == 1 && l[0] == 0);\n}\n", "  let pairs: any = {};\n  l.sort((a, b)\
    \ => a - b);\n  for (let i = 0; i < l.length; i++) {\n    if (pairs[l[i]]) {\n\
    \      pairs[l[i]]++;\n    } else {\n      pairs[l[i]] = 1;\n    }\n  }\n\n  for\
    \ (let i = 1; i <= 9; i++) {\n    if (pairs[i]) {\n      return false;\n    }\n\
    \  }\n\n  return true;\n}\n", "  let i = 0;\n  let j = 0;\n  let k = 0;\n  while\
    \ (j < l.length) {\n    if (l[j] - l[k] === 0) {\n      i++;\n      k++;\n   \
    \   if (l[k] - l[i - 1] === 0)\n        i++;\n    } else {\n      k++;\n    }\n\
    \    j++;\n  }\n  return i === l.length;\n}\nconsole.log(pairs_sum_to_zero([1,\
    \ 3, 5, 0])); // false\nconsole.log(pairs_sum_to_zero([1, 3, -2, 1])); // false\n\
    console.log(pairs_sum_to_zero([1, 2, 3, 7])); // false\nconsole.log(pairs_sum_to_zero([2,\
    \ 4, -5, 3, 5, 7])); // true\nconsole.log(pairs_sum_to_zero([1])); // false",
  "  let sum = 0;\n  for (let x of l) {\n    sum += x;\n    if (sum === 0) return\
    \ true;\n  }\n  return false;\n}\n", "  l.sort((a: number, b: number) => a - b);\n\
    \  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] !== 0) {\n\
    \      sum += l[i];\n      if (sum < 0) {\n        return false;\n      }\n  \
    \  }\n  }\n  return true;\n}\n", "  let seen: Set<number> = new Set<number>();\n\
    \n  for (let i = 0; i < l.length; i++) {\n    let el = l[i];\n    if (seen.has(el))\
    \ {\n      return false;\n    }\n    seen.add(el);\n  }\n\n  return true;\n}\n",
  "  if (l.length < 2) return false;\n  let pairs: number[][] = [];\n  for (let i\
    \ = 0; i < l.length; i++) {\n    const pair = [i, l[i]];\n    if (pairs.filter(e\
    \ => e[0] == i).length == 0)\n      pairs.push(pair);\n  }\n\n  for (let i = 0;\
    \ i < pairs.length; i++) {\n    const pair = pairs[i];\n    for (let j = i + 1;\
    \ j < pairs.length; j++) {\n      const other = pairs[j];\n      if (l[i] > l[j]\
    \ && other[1] != 0) {\n        pairs.splice(j--, 1);\n        break;\n      }\n\
    \    }\n  }\n\n  return pairs.filter(e => e[1] == 0).length >= 2;\n}\n", "  let\
    \ n = l.length\n  if(n == 0)\n    return false\n  let zeros = 0\n  let pairs =\
    \ 0\n  let hashMap = new Map<number, number>()\n  for (let i = 0; i < n; ++i)\
    \ {\n    const current = l[i]\n    hashMap.set(current, 0)\n  }\n  hashMap.forEach(x\
    \ => {\n    hashMap.set(x, 1)\n    if(hashMap.get(x - 1) != 0) {\n      pairs++\n\
    \    }\n  })\n  return pairs == n - 1\n}\nconsole.log(pairs_sum_to_zero([1, 3,\
    \ 5, 0]))\nconsole.log(pairs_sum_to_zero([1, 3, -2, 1]))\nconsole.log(pairs_sum_to_zero([1,\
    \ 2, 3, 7]))\nconsole.log(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]))\nconsole.log(pairs_sum_to_zero([1]))\n\
    console.log(pairs_sum_to_zero([]))\nconsole.log(pairs_sum_to_zero([1,0]))\nconsole.log(pairs_sum_to_zero([0,0,0]))\n\
    console.log(pairs_sum_to_zero([-1,-2,-3]))\nconsole.log(pairs_sum_to_zero([-1,-2,-3,-4,-5,-6]))</code>\n\
    \nThis is similar to the solution presented in question Javascript: Check if all\
    \ elements in array are zero, but instead of returning true or false, it just\
    \ returns an array of pairs of distinct numbers which sum to zero.\n<|/ a tags=javascript,typescript,algorithm\
    \ dscore=2 |>\n<| a |>\nIf you can sort the list, then you only need to check\
    \ the first and the last element and check whether their sum is 0\n<code>\nlet\
    \ a = [-3,-4,-5,-6,-7,-8,-9,-10]\na.sort();\nlet sum = 0;\nfor (let i = 0; i <\
    \ a.length; i++) {\n  sum += a[i]\n}\n\nif (sum == 0) {\n  return true;\n} else\
    \ {\n  return false;\n}\n</code>\n<|/ a tags=javascript,typescript,algorithm dscore=1\
    \ |>\n<| a |>\nTry this:\n\n<code>\nlet arr = [-3,-4,-5,-6,-7,-8,-9,-10];\nlet\
    \ sum = arr.reduce((sum, num) => sum + num, 0);\nconsole.log(sum===0);</code>\n\
    <|/ a dscore=1 tags=javascript,typescript,algorithm |>\n<| a tags=javascript,typescript,algorithm\
    \ |>\n<code>\nconst arr = [-3,-4,-5,-6,-7,-8,-9,-10]\n\nconst checkZeroSum = (arr)\
    \ => {\n    let sum = arr.reduce((sum, element) => {\n        return sum + element;\n\
    \    }, 0);\n\n    return sum === 0;\n}\n\nconsole.log(checkZeroSum(arr));</code>\n\
    \nTry this:\n<code>\nlet arr = [-3,-4,-5,-6,-7,-8,-9,", "    for (let i = 0; i\
    \ < l.length - 1; i++) {\n        if (l[i] + l[i + 1] != 0) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n", "    if (l.length < 2) {\n\
    \        return false;\n    }\n\n    // sort by the value of the first element\
    \ of the array\n    let pairs = l.sort((a: number, b: number) => a - b);\n\n \
    \   let sum = 0;\n    for (let i = 1; i < pairs.length; i++) {\n        sum +=\
    \ pairs[i];\n    }\n\n    return sum === 0;\n}\n", "  const pairs: number[][]\
    \ = [];\n  for (let i = 1; i < l.length; ++i) {\n    pairs.push([l[i], l[i - 1]]);\n\
    \  }\n  let pair = null;\n  for (let i = 0; i < pairs.length; ++i) {\n    pair\
    \ = pairs[i];\n    if (pair[0] === pair[1]) {\n      return pairs.length === 2;\n\
    \    }\n  }\n  return false;\n}\n", "    for (let i = 1; i < l.length; ++i) {\n\
    \        // check if any pair is equal to zero\n        let same: boolean = l[0]\
    \ + l[i] === 0;\n        if (same) {\n            // found a pair of equal elements\
    \ that sum to zero.\n            // so return false\n            return false;\n\
    \        }\n    }\n\n    // no pair equals zero, return true\n    return true;\n\
    }\n", "\tconst zero = [0];\n\tconst diff = [0, ...l, ...zero];\n\tlet i = diff.length\
    \ - 1;\n\n\twhile (i >= 0) {\n\t\tconst a = diff[i];\n\t\tconst b = diff[i + 1];\n\
    \t\tif (a === 0 || b === 0) return false;\n\t\tif (a === b) return true;\n\t\t\
    i--;\n\t}\n\n\treturn true;\n}\n", "\tif (l.length < 2) {\n\t\treturn false;\n\
    \t}\n\n\tlet pairs: { [id: string]: number[] } = {};\n\tlet sum = 0;\n\tlet count\
    \ = 0;\n\tfor (let i = 0; i < l.length; i++) {\n\t\tlet id = l[i];\n\t\tif (id\
    \ < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!pairs[id]) {\n\t\t\tpairs[id] = [];\n\
    \t\t}\n\t\tpairs[id].push(i);\n\t\tsum += id;\n\t\tcount++;\n\t\tif (sum === 0)\
    \ {\n\t\t\tlet pair: number[] = pairs[id];\n\t\t\tif (pair.length !== count) {\n\
    \t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpairs[id] = [];\n\t\t\tsum = 0;\n\t\t\t\
    count = 0;\n\t\t}\n\t}\n\treturn true;\n}\n", "  var pairs: number[][] = [];\n\
    \  var index: number[] = [];\n  var index2: number[] = [];\n  var pair: number[]\
    \ = [];\n  var pairIndex: number[] = [];\n  var sum: number = 0;\n\n  for (let\
    \ i = 0; i < l.length; i++) {\n    if (index2.indexOf(l[i]) == -1) {\n      index2.push(l[i]);\n\
    \      index.push(i);\n      sum += l[i];\n    } else {\n      if (pair[0].equals(pair[1]))\
    \ {\n        return true;\n      }\n    }\n  }\n\n  for (let i = 0; i < index.length;\
    \ i++) {\n    pair = [index[i], sum - index[i]];\n    pairs.push(pair);\n  }\n\
    \  return false;\n}\n", "  let pairs: number[][] = [];\n  let two: number[] =\
    \ [];\n  let i: number = 0;\n  let j: number = 0;\n  let k = 0;\n  while (i <\
    \ l.length) {\n    pairs.push(l[i]);\n    i += 1;\n    k = i;\n    while (i <\
    \ l.length) {\n      j = 0;\n      while (j < pairs.length) {\n        pairs[k\
    \ + 1] = pairs[k] + pairs[j];\n        pairs[j] = pairs[k];\n        k += 1;\n\
    \        j += 1;\n      }\n      i += 1;\n    }\n    two = pairs.filter((el) =>\
    \ el != 0);\n    if (two.length == 2) {\n      return true;\n    }\n  }\n  return\
    \ false;\n}\n", "\tlet pairs: number[][] = [];\n\tlet pair_sum: number[] = [];\n\
    \tlet total_sum: number = 0;\n\tfor (let i = 0; i < l.length; i++) {\n\t\ttotal_sum\
    \ += l[i];\n\t\tpairs.push([l[i], total_sum]);\n\t}\n\tfor (let i = 0; i < pairs.length;\
    \ i++) {\n\t\tlet index = pairs[i].length - 1;\n\t\twhile (index > 0) {\n\t\t\t\
    if (pairs[i][0] + pairs[i][1] === pairs[index][0]) {\n\t\t\t\tpairs[index][0]\
    \ -= pairs[index][0]; // reverse order\n\t\t\t\tindex--;\n\t\t\t} else {\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (let i = 0; i < pairs.length; i++) {\n\
    \t\tpair_sum.push(pairs[i][1]);\n\t}\n\n\treturn (pair_sum[0] === 0 && pair_sum[pair_sum.length\
    \ - 1] === 0);\n}", "  let i = 0;\n  let j = 1;\n  let pairs = [];\n  while (i\
    \ < l.length && j < l.length) {\n    if (l[i] + l[j] === 0) {\n      pairs.push([l[i],\
    \ l[j]]);\n      i += 1;\n      j += 1;\n    } else if (l[i] + l[j] > 0) {\n \
    \     j += 1;\n    } else {\n      i += 1;\n    }\n  }\n  return pairs.length\
    \ !== 0;\n}\n", "  let zeroes = 0;\n  for (const v of l) {\n    if (v === 0) zeroes++;\n\
    \  }\n  return zeroes === 2;\n}", "  l.sort()\n  const pairs = [...new Set(l)].map(i\
    \ => [Math.abs(i - l[0]), i])\n  pairs.sort()\n  return pairs.map(i => i[1] ===\
    \ i[0]).indexOf(true) > -1\n}\n", "  if (l.length < 2) {\n    return false;\n\
    \  }\n  const pairs: number[][] = [];\n  for (let i = 0; i < l.length; ++i) {\n\
    \    const pair: number[] = [];\n    pair[0] = i;\n    pair[1] = l[i];\n    pairs.push(pair);\n\
    \  }\n  const pair_set = new Set(pairs);\n  return !pair_set.size;\n}\n", "  const\
    \ pairs = new Array<[number, number]>();\n  let pair: number[];\n  let i: number;\n\
    \  let j: number;\n  for (i = 0; i < l.length; i++) {\n    for (j = i + 1; j <\
    \ l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        pair = [l[i], l[j]];\n\
    \        pairs.push(pair);\n      }\n    }\n  }\n  if (pairs.length <= 2) {\n\
    \    return false;\n  }\n  for (let i = 0; i < pairs.length; i++) {\n    for (let\
    \ j = i + 1; j < pairs.length; j++) {\n      if (pairs[i][1] > pairs[j][1]) {\n\
    \        return false;\n      }\n    }\n  }\n  return true;\n}\n", "  for (let\
    \ i = 0; i < l.length; i++) {\n    const pair = [i, l[i]];\n    if (l[i] != 0)\
    \ {\n      for (let j = i + 1; j < l.length; j++) {\n        if (l[j] == 0) {\n\
    \          pair.push(j);\n          break;\n        }\n      }\n      if (pair.length\
    \ > 1 && l[pair[0]] == l[pair[1]]) {\n        return true;\n      }\n    }\n \
    \ }\n  return false;\n}\n", "\tif (l.length === 0) {\n\t\treturn false;\n\t}\n\
    \n\tlet l0: number[] = [];\n\tfor (let i = 0; i < l.length; i++) {\n\t\tif (l[i]\
    \ < 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (l0 === undefined || l0[i - l0.length]\
    \ >= l[i]) {\n\t\t\tl0.push(l[i]);\n\t\t}\n\t}\n\n\tif (l0.length === 0) {\n\t\
    \treturn false;\n\t}\n\n\tlet l1: number[] = [];\n\tfor (let i = 1; i < l0.length;\
    \ i++) {\n\t\tif (l0[i] > l0[i - 1]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (l1\
    \ === undefined || l1[i - 1] >= l0[i]) {\n\t\t\tl1.push(l0[i]);\n\t\t}\n\t}\n\n\
    \treturn true;\n}\n", "  const n = l.length\n  let max = 0\n  for (let i = 0;\
    \ i < n; ++i) {\n    if (l[i] > max) max = l[i]\n  }\n\n  // if max = 0 then nothing\
    \ can be sum to 0\n  if (max === 0) return false\n\n  // if there are two numbers\
    \ with the same sum\n  // and one negative number, then there is no zero\n  let\
    \ same = 0\n  let same_count = 0\n  for (let i = 0; i < n; ++i) {\n    if (l[i]\
    \ === max) same++\n    else {\n      same_count++\n      if (l[i] < 0) {\n   \
    \     return false\n      }\n    }\n  }\n\n  // if same > same_count and same\
    \ === same_count, then there are two numbers that sum to zero\n  return same >\
    \ same_count && same === same_count\n}\n", "  let pairs = 0;\n  for (let i = 0;\
    \ i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if\
    \ (l[i] + l[j] === 0) {\n        pairs++;\n      }\n    }\n  }\n  return pairs\
    \ === 2;\n}\n</cell>\n<cell>", "  // your code here\n  const len = l.length;\n\
    \  for(let i = 0; i<len; i++) {\n    const min = i;\n    for(let j = i+1; j <\
    \ len; j++) {\n      if (l[j] < l[min]) {\n        min = j;\n      }\n    }\n\
    \    if (i !== min) return false;\n  }\n  return true;\n}\n", "\tlet m = l.length;\n\
    \tif (m === 0) {\n\t\treturn false;\n\t}\n\tlet zeros = l.slice(0, m);\n\tlet\
    \ other = l.slice(m);\n\tfor (let i = 0; i < other.length - 1; i++) {\n\t\tlet\
    \ a = zeros[i];\n\t\tlet b = other[i];\n\t\tif (a + b < 0) {\n\t\t\tbreak;\n\t\
    \t}\n\t\tlet c = other[i + 1];\n\t\tif (b > c || a === b) {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn true;\n}", "  const n = l.length;\n  let i = 0\n  let sum\
    \ = 0;\n  while (i < n) {\n    const j = i;\n    while (j < n) {\n      if (l[j]\
    \ + l[i] === 0) return false;\n      else sum += l[j];\n      j++;\n    }\n  \
    \  i++;\n  }\n  return sum === 0;\n}\n", "  if (l.length === 0) {\n    return\
    \ false;\n  }\n  let sum = 0;\n  for (const item of l) {\n    sum += item;\n \
    \   if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n}", " \
    \ if (l.length === 0) {\n    return false;\n  }\n  let last_value = l[0];\n  for\
    \ (let i = 1; i < l.length; i++) {\n    if (last_value + l[i] === 0) return true;\n\
    \    last_value = l[i];\n  }\n  return false;\n}\n", "  l.sort()\n  let zero =\
    \ 0\n  let pairs: number[] = []\n  for (let i = 0; i < l.length; i++) {\n    if\
    \ (l[i] === 0) {\n      pairs.push([l[i], zero])\n      zero += l[i]\n    } else\
    \ {\n      pairs.push([l[i], l[i] - zero])\n    }\n  }\n\n  for (let i = 0; i\
    \ < pairs.length; i++) {\n    let j = pairs[i][0]\n    for (let k = i + 1; k <\
    \ pairs.length; k++) {\n      let l = pairs[k][0]\n      if (pairs[i][1] === pairs[k][1])\
    \ {\n        pairs[k] = [1, 1]\n      }\n    }\n  }\n\n  let result: boolean =\
    \ false\n  for (let i = 0; i < pairs.length; i++) {\n    let j = pairs[i][0]\n\
    \    for (let k = i + 1; k < pairs.length; k++) {\n      let l = pairs[k][0]\n\
    \      if (pairs[i][1] === pairs[k][1]) {\n        pairs[k][1] = 1\n        if\
    \ (pairs[i][1] + pairs[k][1] !== 0) {\n          result = true\n        }\n  \
    \    }\n    }\n  }\n\n  return result\n}\n", "  return l.every((x, i, arr) =>\
    \ x === arr[0] && arr[i] === arr[i + 1]);\n}\n", "  // sort the array so we can\
    \ check if the sum of two adjacent numbers\n  // are both zero\n  const sorted_l\
    \ = l.sort();\n\n  let two_sum;\n  let sum = 0;\n\n  for (let i = 0; i < l.length;\
    \ i++) {\n    sum += sorted_l[i];\n    if (sum === 0) {\n      // found two equal\
    \ numbers\n      two_sum = sorted_l[i];\n      break;\n    }\n\n    if (i ===\
    \ l.length - 1) {\n      // if this is the last index, we have checked all numbers\n\
    \      // so there is no second number\n      return false;\n    }\n\n    // if\
    \ sum is not zero, we keep summing the current number and\n    // check if they\
    \ are equal or not\n    sum += sorted_l[i + 1];\n    if (sum === 0) {\n      //\
    \ found two equal numbers\n      two_sum = sorted_l[i + 1];\n      break;\n  \
    \  }\n  }\n\n  // check if the two numbers are equal\n  return two_sum === 0;\n\
    }\n", "  let [smaller, larger] = l;\n  return smaller[0] === 0 && larger[0] ===\
    \ 0;\n}\n", "  const pairs: number[] = [];\n  let first = true;\n  for (let i\
    \ = 0; i < l.length; i++) {\n    let pair = l[i];\n    if (first && pair == 0\
    \ || pairs[pairs.indexOf(pair) + 1] != 0) {\n      pairs.push(pair);\n    }\n\
    \    first = false;\n  }\n\n  return pairs.filter(x => x == 0).length == 2;\n\
    }\n", "    let nums = l;\n    let i = nums.length - 1;\n    while (i > 0) {\n\
    \        if (nums[i] === nums[i - 1]) {\n            i -= 1;\n        } else {\n\
    \            break;\n        }\n    }\n    let pairs = nums.length - i;\n    let\
    \ j = 0;\n    while (j < (pairs - 1)) {\n        if (nums[j] === nums[j + 1])\
    \ {\n            i += 1;\n        } else {\n            break;\n        }\n  \
    \      j += 1;\n    }\n    let equal = false;\n    if (j === pairs - 1) {\n  \
    \      equal = true;\n    }\n    return equal;\n}\n", "  l.sort();\n  let pairs:\
    \ number[][] = [];\n  let i = 0;\n  for (let i = 0; i < l.length; i++) {\n   \
    \ let j = i + 1;\n    let k = 0;\n    while (j < l.length) {\n      if (l[i] +\
    \ l[j] == 0) {\n        pairs.push([l[i], l[j]]);\n        i += 1;\n        j\
    \ += 1;\n      } else if (l[j] == l[i]) {\n        j += 1;\n      } else {\n \
    \       break;\n      }\n      k += 1;\n    }\n  }\n  return (pairs.length ===\
    \ l.length && pairs.reduce((acc, p) => acc && p[0] !== p[1]));\n}", "  const map\
    \ = new Map<number, number>();\n  for (const num of l) {\n    if (!map.has(num\
    \ - num)) {\n      map.set(num - num, 0);\n    }\n    map.set(num - num, map.get(num\
    \ - num) + 1);\n  }\n  const pairs = Array.from(map.keys()).filter(x => map.get(x)\
    \ === 2);\n  if (pairs.length !== 0) return false;\n  return true;\n}\n", "  \
    \  let s = l.slice();\n    let p = 0;\n    s.push(0);\n    while (s.length !==\
    \ 1) {\n        s = s.slice();\n        let l = 0;\n        for (let i = 0; i\
    \ < s.length; i++) {\n            l += s[i];\n        }\n        s[s.length -\
    \ 1] = l;\n        if (s.length < 2) {\n            return false;\n        }\n\
    \        p++;\n        s.pop();\n    }\n    return s[0];\n}\n", "  const hashmap:\
    \ Map<number, boolean> = new Map();\n  for (let num of l) {\n    if (!hashmap.has(num))\
    \ {\n      hashmap.set(num, true);\n    } else {\n      return false;\n    }\n\
    \  }\n  return true;\n}\n", "  let pairs: number[][] = [];\n  for (let i = 1;\
    \ i < l.length; i++) {\n    let element = l[i];\n    if (element < 0) {\n    \
    \  let next_element = l[i - 1];\n      if (next_element < 0) {\n        return\
    \ false;\n      }\n      pairs.push([element, next_element]);\n    }\n  }\n  for\
    \ (let i = 0; i < pairs.length; i++) {\n    for (let j = i + 1; j < pairs.length;\
    \ j++) {\n      if (pairs[i][0] === pairs[j][0]) {\n        return false;\n  \
    \    }\n    }\n  }\n  return true;\n}\n", "  const sorted_pairs = sortPairs(l);\n\
    \  return sorted_pairs.reduce((prev, curr, i) => curr && prev || sorted_pairs[i\
    \ - 1] - sorted_pairs[i + 1], true);\n}\n", "  let arr: number[] = []\n  for (let\
    \ i = 0; i < l.length; i++) {\n    arr.push(l[i])\n  }\n  for (let i = 0; i <\
    \ arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if\
    \ (arr[i] + arr[j] === 0) {\n        return true\n      }\n    }\n  }\n  return\
    \ false\n}\n", "  var pairs: number[][] = [];\n  var index = 0;\n  while (index\
    \ < l.length && l[index] !== 0) {\n    var value = l[index];\n    var pair: [number,\
    \ number] = value;\n    if (l[index + 1] === 0) {\n      pairs.push(pair);\n \
    \     index += 2;\n    }\n    else {\n      index++;\n    }\n  }\n  return !pairs.length;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,algorithm,sum,javascript,sorting\
    \ |>\nThis works for me:\n<code>\nvar arr = [1, 3, -2, 1],\n    count = 0, sum\
    \ = 0, maxCount = 0, maxSum = 0;\n\narr.map(item => {\n    if (sum === 0 && item\
    \ !== 0) {\n        count++;\n        sum += item;\n        if (count > maxCount)\
    \ {\n            maxCount = count;\n            maxSum = sum;\n        }\n   \
    \ } else if (sum > 0) {\n        count++;\n        sum += item;\n    } else {\n\
    \        sum = 0;\n    }\n});\n\nconsole.log(maxCount, maxSum);\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 tags=arrays,algorithm,sum,javascript,sorting |>\n\
    Using Javascript sort and reduce function\n<code>", "\tconst len = l.length;\n\
    \tlet i = 0, j = 0;\n\twhile (i < len && j < len) {\n\t\tif (l[i] + l[j] == 0)\
    \ {\n\t\t\treturn false;\n\t\t}\n\t\tif (l[i] + l[j] > 0) {\n\t\t\tj++;\n\t\t\
    } else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn (i < len);\n}\n", "    return l.length\
    \ === 0\n        ? false\n        : l.some((e, i) => e === l[l.length - 1]\n \
    \           ? l.slice(0, i).some((e2, i2) => e - e2 === 0)\n            : false);\n\
    }\n", "    var pairs: number[][] = [[]];\n    for (var i = 1; i < l.length; i++)\
    \ {\n        pairs.push([l[i - 1], l[i]]);\n    }\n    for (var j = 0; j < pairs.length;\
    \ j++) {\n        if (pairs[j][0] === 0 && pairs[j][1] === 0) return true;\n \
    \   }\n    return false;\n}", "\tif (l.length == 1) {\n\t\treturn l[0] === 0;\n\
    \t}\n\telse {\n\t\tlet lastVal = l[0],\n\t\t\tnextVal = l[1],\n\t\t\tsum = 0;\n\
    \t\tfor (let i = 2; i < l.length; i++) {\n\t\t\tsum += l[i];\n\t\t\tif (sum >\
    \ 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastVal = nextVal;\n\t\t\tnextVal = l[i];\n\
    \t\t}\n\t\treturn lastVal === 0 && nextVal === 0;\n\t}\n}\n", "  for (let i =\
    \ 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n    \
    \  if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n\n  return\
    \ false;\n}\n", "  let arr: number[] = l.slice();\n  let pairs: number[][] = [];\n\
    \n  while (arr.length > 1) {\n    // We take two elements at a time.\n    // We\
    \ can remove these two from our array\n    let [a, b] = arr.splice(0, 2);\n  \
    \  let sum = a + b;\n    if (pairs[sum]) {\n      return false; // We've already\
    \ seen this pair\n    } else {\n      pairs[sum] = true; // Record this pair\n\
    \    }\n  }\n\n  return pairs[0]; // We found a pair\n}\n", "\tlet x: number =\
    \ 0;\n\tlet y: number = 0;\n\tfor (let i = 0; i < l.length; i++) {\n\t\tx = l[i];\n\
    \t\ty = x + y;\n\t}\n\n\treturn x == 0;\n}\n", "  const n = l.length\n  if (n\
    \ < 2) return false\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1;\
    \ j < n; j++) {\n      if (l[i] + l[j] === 0) return true\n    }\n  }\n  return\
    \ false\n}\n", "  let pairs: number[][] = [];\n  for (let i = 0; i < l.length;\
    \ i++) {\n    let sum = 0;\n    for (let j = 0; j < i; j++) {\n      sum += l[j];\n\
    \    }\n    if (sum == 0) {\n      pairs.push([l[i], l[i]]);\n    }\n  }\n  return\
    \ pairs.filter(a => a[0] == a[1]).length <= 1;\n}\n", "  let pairs: number[][]\
    \ = [];\n  let max: number = 0;\n  for (let i = 0; i < l.length; i++) {\n    pairs.push([l[i],\
    \ l[i]]);\n    max = Math.max(max, l[i]);\n  }\n  let pair_count = 0;\n  for (let\
    \ i = 0; i < pairs.length; i++) {\n    for (let j = i + 1; j < pairs.length; j++)\
    \ {\n      if (pairs[i][0] === pairs[j][0] && pairs[i][1] === pairs[j][1]) {\n\
    \        pair_count++;\n      }\n    }\n  }\n  return (pair_count % 2 === 0);\n\
    }", "  let sum = 0;\n  l.forEach((el) => {\n    sum += el;\n  });\n  return sum\
    \ === 0;\n}\n", "    let map = new Map();\n    l.forEach(a => {\n        if (!map.has(a))\
    \ {\n            map.set(a, 1);\n        } else {\n            map.set(a, map.get(a)\
    \ + 1);\n        }\n    });\n    let pairs = Array.from(map).filter(a => a[1]\
    \ > 1);\n    return pairs.length == 0;\n}", "  let zeros = 0;\n  let sum = 0;\n\
    \  for (let i = 0; i < l.length; i++) {\n    if (l[i] === 0) {\n      zeros++;\n\
    \    } else {\n      sum += l[i];\n      if (sum === 0) {\n        return true;\n\
    \      }\n    }\n  }\n  return false;\n}\n", "  let sum = 0\n  for (let i of l)\
    \ {\n    sum += i\n  }\n  for (let j of l) {\n    if (sum - j != 0) {\n      return\
    \ false\n    }\n  }\n  return true\n}\n", "  var pairs: number[] = [];\n  var\
    \ zero = 0;\n  l.forEach((n) => {\n    var n2 = n * n;\n    if (pairs[n2] !==\
    \ undefined) {\n      pairs[n2] += n;\n    } else {\n      pairs[n2] = n;\n  \
    \  }\n    if (pairs[n2] === zero) {\n      zero = n2;\n    }\n  });\n  l.forEach((n)\
    \ => {\n    if (pairs[n] === undefined) {\n      return false;\n    }\n  });\n\
    \  return true;\n}\n", "  let last: number = l[l.length - 1];\n  for (let i =\
    \ 0; i < l.length; i++) {\n    let current: number = l[i];\n    if (last + current\
    \ === 0) {\n      return false;\n    }\n    last = current;\n  }\n  return true;\n\
    }\n", "    for (let i = 0; i < l.length; i++) {\n        const j = i + 1;\n  \
    \      if ( l[i] + l[j] === 0 ) {\n            return true;\n        }\n    }\n\
    \    return false;\n}\n", "  for (let i = 0; i < l.length; i++) {\n    let val\
    \ = l[i];\n    let j = i - 1;\n    while (j >= 0 && l[j] + l[j + 1] == val) j--;\n\
    \    if (j >= 0) return true;\n  }\n  return false;\n}\n", "  var i: number;\n\
    \  var j: number;\n  var pair: number[];\n  var result: boolean;\n  var num_to_sum:\
    \ number;\n\n  var pair_sum = 0;\n  var pair_index: number = 0;\n  var max_pair_index:\
    \ number = 0;\n  var min_pair_index: number = 0;\n  for (i = 0; i < l.length;\
    \ i++) {\n    pair_sum += l[i];\n    max_pair_index = i;\n    min_pair_index =\
    \ i;\n    for (j = i + 1; j < l.length; j++) {\n      num_to_sum = 0;\n      pair\
    \ = l[i];\n      pair_index = 0;\n      while (pair_index < pair.length - 1) {\n\
    \        num_to_sum += pair[pair_index];\n        pair_index++;\n      }\n   \
    \   if (num_to_sum === 0) {\n        if (i === j) {\n          result = true;\n\
    \        } else {\n          result = false;\n        }\n        break;\n    \
    \  } else if (num_to_sum > pair_sum) {\n        pair_sum = num_to_sum;\n     \
    \   max_pair_index = i;\n        min_pair_index = j;\n      }\n    }\n  }\n  return\
    \ result;\n}\n", "    var j = 0;\n    var sum = 0;\n    while (j < l.length) {\n\
    \        if (l[j] < 0) {\n            sum += l[j++] as number;\n        } else\
    \ {\n            sum += l[j++];\n            if (sum < 0) {\n                sum\
    \ = 0;\n            }\n        }\n    }\n    return sum == 0;\n}\n", "  let pairs\
    \ = 0;\n  let i;\n  let count = 0;\n  for (i = 0; i < l.length; i++) {\n    if\
    \ (l[i] === 0) {\n      count++;\n    } else {\n      pairs++;\n    }\n  }\n\n\
    \  if (count === 1) {\n    return true;\n  }\n\n  return false;\n}\n", "  // Your\
    \ code here\n  let arr :number[] = l\n  let pairs :number[] = []\n\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    let pair = {}\n    let curr = arr[i]\n  \
    \  let sum = 0\n    \n    for (let j = 0; j < arr.length; j++) {\n      if (j\
    \ != i && j != arr[i] && arr[j] >= curr) {\n        sum -= arr[j]\n      }\n \
    \   }\n    if (sum == curr) {\n      pairs.push({ first: i, second: arr[i], sum\
    \ })\n    }\n  }\n  \n  if (pairs.length == 0) return false\n\n  let found = false\n\
    \  for (let i = 0; i < pairs.length; i+=2) {\n    if (pairs[i].sum == 0 && pairs[i+1].sum\
    \ == 0) {\n      found = true\n    }\n  }\n  return found\n}\n", "    return l.every(function(pair:\
    \ number[]): boolean {\n        // return if there are no pairs.\n        if (pair.length\
    \ !== 2) {\n            return false;\n        }\n\n        // Return true if\
    \ either element is zero.\n        return (pair[0] + pair[1] === 0);\n    });\n\
    }\n", "  if (l.length < 2) return true;\n  let pairs: number[][] = [];\n  let\
    \ twos: number[] = [];\n  let tens: number[] = [];\n  let hundreds: number[] =\
    \ [];\n  let thousands: number[] = [];\n  let others: number[] = [];\n  for (let\
    \ i = 0; i < l.length; i++) {\n    let n = l[i];\n    if (n < 0) return false;\n\
    \    if (n < 10) others.push(n);\n    else if (n < 100) tens.push(n);\n    else\
    \ if (n < 1000) hundreds.push(n);\n    else if (n < 10000) thousands.push(n);\n\
    \    else {\n      if (pairs.length !== 0) pairs[pairs.length - 1].push(n);\n\
    \      else pairs.push([n]);\n    }\n  }\n  for (let i = 0; i < pairs.length;\
    \ i++) {\n    let a = pairs[i];\n    for (let j = i + 1; j < pairs.length; j++)\
    \ {\n      let b = pairs[j];\n      if (a[0] + a[1] > b[0] + b[1]) {\n       \
    \ pairs[a[0]] = pairs[a[0]].filter((n) => n !== b);\n        a[0] = 0;\n     \
    \ }\n    }\n  }\n  for (let i = 0; i < pairs.length; i++) {\n    let a = pairs[i];\n\
    \    if (a[0] === 0) twos.push(a[1]);\n    else if (a[0] === 1) tens.push(a[1]);\n\
    \    else if (a[0] === 2) hundreds.push(a[1]);\n    else if (a[0] === 3) thousands.push(a[1]);\n\
    \  }\n  for (let i = 0; i < pairs.length; i++) {\n    let a = pairs[i];\n    let\
    \ n = a[0];\n    others.push(n);\n    if (n < 1000) n = n * 10;\n    else if (n\
    \ < 10000) n = n * 100;\n    else n = n * 1000;\n    tens.push(n);\n    if (n\
    \ < 1000) n = n * 10;\n    else if (n < 10000) n = n * 100;\n    else n = n *\
    \ 1000;\n    hundreds.push(n);\n    if (n < 1000) n = n * 10;\n    else if (n\
    \ < 10000) n = n * 100;\n    else n = n * 1000;\n    thousands.push(n);\n  }\n\
    \  let twosOnly: boolean = false;\n  let tensOnly: boolean = false;\n  let hundredsOnly:\
    \ boolean = false;\n  let thousandsOnly: boolean = false;\n  for (let i = 0; i\
    \ < pairs.length; i++) {\n    let a = pairs[i];\n    if (a[0] === 2) {\n     \
    \ if (twosOnly) {\n        return false;\n      }\n      twosOnly = true;\n  \
    \  } else if (a[0] === 10) {\n      if (tensOnly) {\n        return false;\n \
    \     }\n      tensOnly = true;\n    } else if (a[0] === 100) {\n      if (hundredsOnly)\
    \ {\n        return false;\n      }\n      hundredsOnly = true;\n    } else if\
    \ (a[0] === 1000) {\n      if (thousandsOnly) {\n        return false;\n     \
    \ }\n      thousandsOnly = true;\n    }\n", "  l.sort((a,b) => a-b);\n  let last_sum\
    \ = 0;\n  let i = 0;\n  let j;\n  let temp;\n\n  while (i < l.length){\n    temp\
    \ = l[i];\n    j = i+1;\n    while (j < l.length){\n      if (Math.abs(temp-(l[j]))==Math.abs(last_sum)){\n\
    \        return false;\n      }\n      last_sum = temp;\n      j += 1;\n    }\n\
    \    i += 1;\n  }\n\n  return true;\n}\n", "  const n = l.length;\n  for (let\
    \ i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (l[i]\
    \ + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }\n", "    let pairs: number[][] = [];\n    for (let i: number = 0; i < l.length;\
    \ i++) {\n        for (let j: number = 0; j < l.length; j++) {\n            if\
    \ (i + 1 < j) pairs.push([l[i], l[j]]);\n            if (i === j) pairs.push([l[i],\
    \ 0]);\n        }\n    }\n    return !pairs.some(([a, b]) => a === 0 && b ===\
    \ 0);\n}\n", "  return l.map(x => Math.abs(x) > 1).some((x, i, l) => x && l[i\
    \ + 1] === 0);\n}\n", "  for (var i = 0; i < l.length; i++) {\n    var pair =\
    \ l.slice(i, i + 2)\n    var sum = 0\n    for (var j = 0; j < pair.length; j++)\
    \ {\n      sum += pair[j]\n    }\n    if (sum === 0) {\n      return true\n  \
    \  }\n  }\n  return false\n}\n", "\tconst result = l.reduce((r, v) => {\n\t\t\
    const sum = v.reduce((r1, v1) => r1 + v1, 0);\n\t\tif (!r) return false;\n\t\t\
    if (sum === 0) return true;\n\t\telse return false;\n\t}, false);\n\treturn result;\n\
    }", "  let i: number;\n  let j: number;\n  const n: number = l.length;\n  n--;\n\
    \  for (i = 0; i < n; i++) {\n    for (j = i + 1; j < n; j++) {\n      if (l[i]\
    \ + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }\n", "  return l.sort().reduce(function (acc, val, i, arr) {\n    if (i < 1)\
    \ return acc\n    if (arr[i - 1] === val - 1) {\n      return true\n    } else\
    \ {\n      return false\n    }\n  }, false)\n}\n", "  const pairs = l.map((num)\
    \ => {\n    const newnum = num * -1\n    let found = false;\n    for (let i =\
    \ 0; i < pairs.length; i++) {\n      if (pairs[i][0] + num === newnum) {\n   \
    \     found = true;\n      }\n    }\n    if (!found) {\n      pairs.push([num]);\n\
    \    }\n    return pairs;\n  });\n  return pairs.every((num) => {\n    return\
    \ (num.length !== 1) && (num.every((num2) => num2 === num[0]));\n  });\n}", " \
    \ if (l.length === 0) {\n    return false;\n  }\n  let pairs = pairs_sum_to_zero(l.slice(1));\n\
    \  return pairs.indexOf(false) >= 0;\n}\n", "    let re = true;\n    let pair:\
    \ number[];\n    for (let i = 0; i < l.length; i++) {\n        pair = pairs.filter(function(pair)\
    \ {\n            return pair[0] + pair[1] === l[i];\n        });\n        if (pair.length\
    \ > 1) {\n            re = false;\n        } else {\n            // We found a\
    \ pair that sums to 0\n            // Let's now see if another pair sums to the\
    \ same number\n            for (let j = 1; j < pairs.length; j++) {\n        \
    \        if (pairs[j][0] + pairs[j][1] === l[i]) {\n                    re = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return re;\n}\n</code>\n<|/ a tags=javascript,arrays |>\n<| a |>\nHere\
    \ is my solution, using recursion (the function will always return true). \nI\
    \ used 2 arrays, one to keep the sum and the other to keep the indexes of the\
    \ elements that have the sum as zero.\n<code>", "\tlet sum = 0;\n\tfor (let i\
    \ = 0; i < l.length; i++) {\n\t\tsum += l[i];\n\t}\n\treturn (sum === 0) ? false\
    \ : true;\n}\n", "    const pairs: number[][] = []; // list of pairs: [ai, bi]\n\
    \    for (const pair of l) {\n        const a = pair[0];\n        const b = pair[1];\n\
    \        const ai = Math.abs(a); // absolute value of a\n        const bi = Math.abs(b);\
    \ // absolute value of b\n        if (Math.abs(a) === Math.abs(b)) {\n       \
    \     pairs.push([ai, bi]);\n            continue;\n        }\n        const a_rev\
    \ = Math.abs(a - b); // absolute value of a - b\n        const b_to_a = Math.abs(b\
    \ - a); // absolute value of b - a\n        if (a_rev >= b_to_a) { // if a_rev\
    \ >= b_to_a, then a >= b\n            pairs.push([ai, bi]);\n        } else {\n\
    \            const ai_rev = Math.abs(b - a); // absolute value of ai - a\n   \
    \         pairs.push([ai_rev, bi]);\n        }\n    }\n    const pair_set = new\
    \ Set<number[]>(pairs);\n    if (pair_set.size < 2) { // there are < 2 pairs that\
    \ sum to zero\n        return false;\n    }\n    let has_pair: boolean = false;\n\
    \    for (let i = pairs.length - 1; i >= 0; --i) {\n        const pair = pairs[i];\n\
    \        if (pair[0] === 0 && pair[1] === 0) {\n            has_pair = true;\n\
    \            break;\n        }\n    }\n    return has_pair;\n}\n", "  l.sort((a:\
    \ number, b: number) => a - b);\n  let pairs: number[][] = [];\n  for (let i =\
    \ 0; i < l.length - 1; i++) {\n    let pair = [l[i], l[i + 1]];\n    pairs.push(pair);\n\
    \  }\n  let pair = pairs.find(p => p[0] === 0 && p[1] === 0);\n  return pair ===\
    \ undefined;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for your answer. Your solution\
    \ is very nice and straightforward and I learned something about sorting algorithms.\
    \ However, I cannot help but wonder why you chose it as the correct answer. Would\
    \ you mind explaining why? Also, I feel like I should point out that your answer\
    \ is O(n^2), while mine is O(nlogn). I wonder what would be the best way to solve\
    \ the problem in O(nlogn)? Maybe I should ask that in a separate question, unless\
    \ you think you can suggest something in this one?\n<|/ c |>\n<| c |>\nIn `pairs_sum_to_zero`,\
    \ each iteration requires O(n) time to iterate through the pairs, so it's O(n^2)\
    \ total time. As such, it's not quite as fast as what you were looking for. If\
    \ you want to optimize this, there are a few different possibilities that I can\
    \ think of. One would be to use two nested loops to iterate through the pairs,\
    \ instead of sorting the entire list. I'm not sure how you would be able to do\
    \ that in O(nlogn), though.\n<|/ c |>\n<| c |>\nI suppose my question then would\
    \ be whether it would take O(n) time to sort a list. I'm fairly new to algorithms,\
    \ so I'm not sure how to find out if I'm wrong. Do you know how I could find out?\
    \ And I realized I should've asked the question more broadly, so I've asked a\
    \ new question: https://stackoverflow.com/questions/64143030/how-to-find-out-if-a-list-is-sorted-by-an-algorithm-in-ologn\n\
    <|/ c |>\n<| c |>\nThat question you asked is asking how to find out if your list\
    \ is sorted (which is exactly what this algorithm is doing) but you were asking\
    \ how to find out if the pairs of elements have the same sum. One way to figure\
    \ out if two elements have the same sum is to sort the list and then compare the\
    \ first two elements. If they are the same, you're done. If not, you know that\
    \ the elements in the list are pairs of numbers that sum to the same number.\n\
    <|/ c |>\n<| c |>\nI suppose I'm just not that great at thinking about the problems\
    \ myself. Thanks for the explanation.\n<|/ ", "  if (l.length <= 1)\n    return\
    \ true;\n  const pairs = l.map(x => ({ x: x, y: 0 }));\n  pairs.sort((a, b) =>\
    \ b.x - a.x);\n  return pairs.every(p => p.y === 0);\n}\n", "    var pairs: number[][]\
    \ = [];\n    for (var i = 0; i < l.length - 1; i++) {\n        for (var j = i\
    \ + 1; j < l.length; j++) {\n            pairs.push([l[i], l[j]]);\n        }\n\
    \    }\n    \n    var zeros: number[] = [];\n    for (var i = 0; i < l.length;\
    \ i++) {\n        var zero = false;\n        for (var j = 0; j < l.length; j++)\
    \ {\n            if (pairs[i][j] == 0) zero = true;\n        }\n        if (zero)\
    \ zeros.push(l[i]);\n    }\n    \n    if (zeros.length < pairs.length) {\n   \
    \     return false;\n    }\n    \n    return true;\n}\n*/\n", "  const a = l.sort((a,\
    \ b) => a - b);\n  if (a.length < 2) return false;\n  let i = 0, j = 0, k = 0;\n\
    \  while (j < a.length) {\n    if (a[j] + a[k] === 0) {\n      if (j - i > 2)\
    \ return true;\n      i += 1;\n      j += 1;\n      k += 1;\n    } else {\n  \
    \    j += 1;\n      k += 1;\n    }\n  }\n  return false;\n}\n", "  let arr = [...l];\n\
    \  let n = arr.length;\n  if (n < 2) return false;\n  let zeros = 0;\n  let pairs\
    \ = 0;\n  for (let i = 0; i < n; i++) {\n    let next = arr[i];\n    if (next\
    \ === 0) zeros++;\n    else pairs++;\n  }\n  return pairs === zeros;\n}\n", " \
    \ var pairs: number[][] = [];\n  for (var i = 0; i < l.length; ++i) {\n    for\
    \ (var j = 0; j < l.length; ++j) {\n      if (i != j && l[i] + l[j] == 0) {\n\
    \        pairs.push([l[i], l[j]]);\n      }\n    }\n  }\n  return pairs.length\
    \ <= 1;\n}\n", "  let n = l.length;\n  if (n < 1) {\n    return false;\n  }\n\
    \  let total = 0;\n  let sum = 0;\n  for (let i = 0; i < n; ++i) {\n    sum +=\
    \ l[i];\n  }\n  for (let i = 0; i < n; ++i) {\n    if (l[i] > 0 && sum < 0) {\n\
    \      return false;\n    }\n    if (l[i] > 0 && sum > 0) {\n      total += l[i];\n\
    \      if (total >= 0) {\n        sum = 0;\n      }\n    }\n  }\n  return true;\n\
    }\nconst pairs = (a: number[], b: number[]) => pairs_sum_to_zero(zip(a, b));\n",
  "  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++)\
    \ {\n      if (l[i] + l[j] === 0) return true;\n    }\n  }\n  return false;\n\
    }\n", "    // your code\n    let sum = 0;\n    for (let i = 0; i < l.length; i++)\
    \ {\n        sum += l[i];\n    }\n\n    if (sum % 2 === 0) {\n        return false;\n\
    \    }\n    else {\n        return true;\n    }\n\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=arrays,javascript dscore=1 |>\n<code>", "  for (let i = 0; i <\
    \ l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i]\
    \ + l[j] === 0) return false;\n    }\n  }\n  return true;\n}\nconsole.log(pairs_sum_to_zero([1,\
    \ 3, 5, 0]));\nconsole.log(pairs_sum_to_zero([1, 3, -2, 1]));\nconsole.log(pairs_sum_to_zero([1,\
    \ 2, 3, 7]));\nconsole.log(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]));\nconsole.log(pairs_sum_to_zero([1]));\n",
  "    let zero = 0;\n    let two = 0;\n\n    for(let i = 0; i < l.length; i++) {\n\
    \        if (l[i] == 0) {\n            zero++;\n        }\n        else {\n  \
    \          two++;\n        }\n    }\n\n    if (zero == 2) {\n        return true;\n\
    \    }\n    else {\n        return false;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nNice solution. I think you also need to consider negative numbers. e.g.\
    \ `[-2, -1, -3]` should return `true` instead of `false`. But your code only returns\
    \ `true` if all are `0`.\n<|/ c |>\n<| c |>\nI believe OP was looking for two\
    \ distinct numbers with same sum, that's why I used `pairsSumToZero`\n<|/ c |>\n\
    <| a dscore=2 |>\nHere's a solution which can return true or false if the input\
    \ is invalid.\n<code>", "  l.sort((a,b)=>(a-b));\n  let first = 0, last = l.length\
    \ - 1;\n  let sum = 0;\n  while(first < last) {\n    const cur = l[first] + l[last];\n\
    \    if(cur > 0)\n      sum += cur;\n    else if(cur === 0)\n      return true;\n\
    \    else {\n      first++;\n      last--;\n    }\n  }\n  return false;\n}\n",
  "  let pairs = new Array(l.length)\n  for (let i = 0; i < pairs.length; i++) {\n\
    \    pairs[i] = [-l[i], l[i]]\n  }\n  return pairs_sum_to_zero(pairs)\n}\n", " \
    \ var i,\n      j,\n      k,\n      n = l.length;\n\n  for (i = 0; i < n; i++)\
    \ {\n    for (j = i + 1; j < n; j++) {\n      if (l[i] + l[j] === 0) {\n     \
    \   return true;\n      }\n    }\n  }\n\n  return false;\n}\n", "  let sum = 0;\n\
    \  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0)\
    \ {\n      return true;\n    }\n  }\n  return false;\n}\n", "  if (l.length <\
    \ 2) {\n    return false\n  }\n  let left = 0\n  let right = 1\n  let i = 0\n\
    \  let j = 0\n  while (i < l.length) {\n    if (l[i] === 0) {\n      return false\n\
    \    }\n    if (l[j] === 0) {\n      return false\n    }\n    while (l[left] +\
    \ l[right] === 0) {\n      left++\n      right++\n    }\n    if (left >= right)\
    \ {\n      return false\n    }\n    left++\n    right++\n    i++\n    j++\n  }\n\
    \  return true\n}\n", "  for (let i = 0; i < l.length; i++) {\n    let current_pair\
    \ = l[i];\n    let next_pair = l[i + 1];\n    if (current_pair + next_pair ===\
    \ 0) {\n      return true;\n    }\n  }\n  return false;\n}\n", "  let sum = 0;\n\
    \  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n\n  return l.filter((elem)\
    \ => {\n    return elem != 0 && sum == elem;\n  }).length == 0;\n}\n", "  let\
    \ s = l.length;\n  for (let i = 0; i < s; i++) {\n    let j = (i + 1) % s;\n \
    \   if (l[i] + l[j] === 0) return false;\n  }\n  return true;\n}\n", "    let\
    \ n = l.length;\n    let ans: boolean = true;\n    for (let i = 0; i < n - 1;\
    \ i++) {\n        let a = l[i];\n        let b = l[i + 1];\n        if (a > b)\
    \ {\n            ans = false;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\n", "    return _.uniq(l.filter((i) => i !== 0)).filter((i) => i ===\
    \ l.length).length === l.length;\n}\n", "  let sum = 0;\n  for (let i = 0; i <\
    \ l.length; i++) {\n    sum += l[i];\n  }\n\n  for (let i = 0; i < l.length; i++)\
    \ {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[j] - l[i] === 0)\
    \ {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "  let\
    \ pairs: number[][] = []\n\n  l.forEach((n) => {\n    let pair: number[] = [n,\
    \ 0]\n    for (let i = 1; i < pairs.length; ++i) {\n      let pair2: number[]\
    \ = pairs[i]\n      pair[0] += pair2[0]\n      if (pair[0] == 0) {\n        pairs.splice(i,\
    \ 1)\n        return\n      }\n    }\n\n    pairs.push(pair)\n  })\n\n  for (let\
    \ i = 0; i < pairs.length; ++i) {\n    let pair: number[] = pairs[i]\n    if (pair[0]\
    \ != pair[1]) {\n      return true\n    }\n  }\n\n  return false\n}\n", "  for\
    \ (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n\
    \      if (l[i] + l[j] == 0) return true;\n  return false;\n}\n", "  const pairs\
    \ = l.slice(0, l.length - 1).reduce((acc, cur, i) => {\n    acc[cur] = (acc[cur]\
    \ || 0) + l[i]\n    return acc\n  }, {})\n  return Object.keys(pairs).length ===\
    \ 0\n}\n", "  const len = l.length;\n  let i = 0,\n    k = 0,\n    total = 0;\n\
    \n  while (i < len) {\n    k = i;\n    while (k >= 0 && total + l[k] === 0) {\n\
    \      k--;\n    }\n    if (k >= 0) {\n      i += 1;\n    } else {\n      return\
    \ true;\n    }\n    total += l[k];\n  }\n  return false;\n}\n", "  if (l.length\
    \ < 2) return false;\n  let arr2: number[] = [];\n  let arr: number[] = [];\n\
    \  let i: number;\n  let j: number;\n  let s: number;\n  for (i = 0; i < l.length;\
    \ i++) {\n    s = l[i];\n    for (j = 0; j < i; j++) {\n      if (s <= l[j]) {\n\
    \        s = s - l[j];\n        arr2 = arr.concat(arr2);\n        arr2 = arr.concat(l);\n\
    \        s = s + l[i];\n        arr2 = arr.concat(arr2);\n        break;\n   \
    \   }\n    }\n    arr.push(s);\n  }\n  for (j = 0; j < arr.length; j++) {\n  \
    \  if (arr[j] != 0) {\n      return true;\n    }\n  }\n  return false;\n}\n",
  "  if (l.length === 0) return false;\n\n  let [first, rest] = l;\n\n  if (first\
    \ > rest) return false; // if first is greater than rest then there is nothing\
    \ to sum to zero with.\n  let restPairs = rest.pairs();\n\n  while (restPairs.length\
    \ > 0) {\n    let [a, b] = restPairs[0];\n\n    if (a === b) return false; //\
    \ if there is only one element in the list that does not add to zero then there\
    \ is nothing to sum to zero with.\n\n    if (first + a !== b) return false; //\
    \ if the first element does not sum to zero then there is nothing to sum to zero.\n\
    \n    restPairs.shift();\n  }\n\n  return true;\n}\n", "\tif (l.length === 0 ||\
    \ l.length === 1) return false\n\tlet zeros = 0\n\tfor (let i = 0; i < l.length;\
    \ i++) {\n\t\tzeros += l[i]\n\t}\n\tfor (let i = 1; i < l.length; i++) {\n\t\t\
    zeros -= l[i]\n\t\tif (zeros === 0) return false\n\t}\n\treturn true\n}\n", " \
    \ let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    const val = l[i];\n\
    \    sum += val;\n    if (sum < 0) {\n      return false;\n    }\n  }\n\n  return\
    \ true;\n}\n", "    const pairs: number[][] = [];\n    const len: number = l.length;\n\
    \    for (let i = 0; i < len; i++) {\n        pairs.push([l[i], l[len - i - 1]]);\n\
    \    }\n\n    let result: boolean = false;\n    for (let i = 0; i < pairs.length;\
    \ i++) {\n        const val0: number = pairs[i][0];\n        const val1: number\
    \ = pairs[i][1];\n\n        if (val0 === 0 && val1 === 0) {\n            return\
    \ true;\n        }\n\n        if (val0 === 0 || val1 === 0) {\n            continue;\n\
    \        }\n\n        const delta0: number = val0 - val1;\n        const delta1:\
    \ number = val1 - val0;\n        const delta2: number = val1 + val0;\n\n     \
    \   if (Math.abs(delta0) < Math.abs(delta1)) {\n            if (Math.abs(delta0)\
    \ < Math.abs(delta2)) {\n                if (delta0 === 0) {\n               \
    \     if (delta1 === 0) {\n                        result = true;\n          \
    \              break;\n                    }\n                    continue;\n\
    \                }\n                if (delta1 === 0 || !(delta2 === 0)) {\n \
    \                   result = true;\n                    break;\n             \
    \   }\n            }\n        } else {\n            if (Math.abs(delta1) < Math.abs(delta2))\
    \ {\n                if (delta1 === 0) {\n                    if (delta2 === 0)\
    \ {\n                        result = true;\n                        break;\n\
    \                    }\n                    continue;\n                }\n   \
    \             if (delta2 === 0 || !(delta1 === 0)) {\n                    result\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n    }\n\n    return result;\n}\n", "  let sum = 0;\n  for (let i = 0;\
    \ i < l.length; i++) {\n    sum += l[i];\n  }\n  return l.filter(function(item:\
    \ number): boolean {\n    return item > 0;\n  }).length === l.filter(function(item:\
    \ number): boolean {\n    return item > 0;\n  }).length && sum === 0;\n}\n", " \
    \ let maxSum = l.reduce((acc, elem) => acc + elem, 0);\n  for (let i = 0; i <\
    \ l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i]\
    \ + l[j] == 0) {\n        if (Math.abs(l[i] - l[j]) > Math.abs(maxSum)) {\n  \
    \        maxSum = Math.abs(l[i] - l[j]);\n        }\n      }\n    }\n  }\n  return\
    \ maxSum == 0;\n}\n", "  let s: number;\n  let t: number;\n  for (let i = 0; i\
    \ < l.length; i++) {\n    s = l[i];\n    t = l;\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      t -= l[j];\n      if (s === t) return true;\n    }\n  }\n  return\
    \ false;\n}\n", "  let arr: number[] = [];\n  l.forEach((n) => {\n    const temp\
    \ = n - arr.reduce(\n      (a, b) => a + b,\n      0\n    );\n    if (temp ==\
    \ 0) {\n      arr.push(n);\n    }\n  });\n  return arr.length == 2;\n}\n", " \
    \ let num_sum_to_zero = 0;\n  for (let i = 0; i < l.length; i++) {\n    num_sum_to_zero\
    \ += l[i];\n  }\n  return num_sum_to_zero < 1;\n}\n", "  // your code here\n \
    \ return true;\n}\n", "  const len = l.length\n  if (len === 0) return false\n\
    \  if (len === 1) return l[0] === 0\n  let cur = 0\n  for (let i = 1; i < len;\
    \ i++) {\n    cur += l[i]\n    if (cur === 0) return false\n  }\n  return true\n\
    }\n", "    // Your code here.\n    return l.every(n => n === 0)\n}\n", "  if (l.length\
    \ === 0) return false;\n  const pairs = l.map(\n    el => [el, el === 0 ? 0 :\
    \ el.map(el2 => el2 - el)[0]]\n  );\n  const [zero, value] = pairs.find(pair =>\
    \ pair[0] === 0);\n  if (zero) return true;\n  return false;\n}\n", "  l.sort();\n\
    \  let prev = -Infinity;\n  let current = -Infinity;\n  let found = false;\n \
    \ for (let i = 0; i < l.length; i++) {\n    if (current >= 0) {\n      current\
    \ -= l[i];\n      if (current == 0 && i != 0) {\n        found = true;\n     \
    \   break;\n      }\n    } else {\n      current = l[i];\n    }\n    if (prev\
    \ < 0) {\n      prev = -current;\n    }\n  }\n  return found;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
