name: HumanEval_61_correct_bracketing
language: ts
prompt: "//brackets is a string of \"(\" and \")\".\n// return true if every opening\
  \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
  )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
  (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunction correct_bracketing(brackets:\
  \ string): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"\
  ()\"),true);\n  assert.deepEqual(candidate(\"(()())\"),true);\n  assert.deepEqual(candidate(\"\
  ()()(()())()\"),true);\n  assert.deepEqual(candidate(\"()()((()()())())(()()(()))\"\
  ),true);\n  assert.deepEqual(candidate(\"((()())))\"),false);\n  assert.deepEqual(candidate(\"\
  )(()\"),false);\n  assert.deepEqual(candidate(\"(\"),false);\n  assert.deepEqual(candidate(\"\
  ((((\"),false);\n  assert.deepEqual(candidate(\")\"),false);\n  assert.deepEqual(candidate(\"\
  (()\"),false);\n  assert.deepEqual(candidate(\"()()(()())())(()\"),false);\n  assert.deepEqual(candidate(\"\
  ()()(()())()))()\"),false);\n}\n\ntest();"
completions: ["\tif (brackets.length < 2 || brackets.length > 3) return false\n\n\t\
    const openingBrackets = brackets.split(\"(\")\n\tconst closingBrackets = brackets.split(\"\
    )\")\n\n\tfor (let i = 0; i < openingBrackets.length; ++i) {\n\t\tconst openingBracket\
    \ = openingBrackets[i]\n\t\tconst closingBracket = closingBrackets[i] || \"\"\n\
    \t\tif (openingBracket === closingBracket) {\n\t\t\tcontinue\n\t\t}\n\n\t\t//\
    \ closing brackets must match an opening bracket\n\t\tconst openingBracketIndex\
    \ = openingBrackets.indexOf(openingBracket)\n\t\tif (openingBracketIndex === -1)\
    \ continue\n\n\t\tconst matchingBracketIndexes = openingBracketIndex + 1\n\t\t\
    while (matchingBracketIndexes.length) {\n\t\t\tconst bracketIndex = matchingBracketIndexes.shift()\n\
    \t\t\tif (bracketIndex !== closingBracketIndex) continue\n\n\t\t\tconst openingBracketSize\
    \ = openingBrackets[bracketIndex].length\n\t\t\tconst closingBracketSize = closingBracket.length\n\
    \t\t\tif (openingBracketSize > closingBracketSize) {\n\t\t\t\treturn false\n\t\
    \t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n", "\treturn brackets.split(\"(\").length\
    \ - brackets.split(\")\").length - 1 > 0;\n}\n", "\tlet stack = [];\n\tfor (let\
    \ i = 0; i < brackets.length; ++i) {\n\t\tlet char = brackets[i];\n\t\tif (char\
    \ === \"(\") stack.push(i);\n\t\tif (char === \")\") {\n\t\t\tif (stack.length\
    \ && stack[stack.length - 1] === i) {\n\t\t\t\tstack.pop();\n\t\t\t} else {\n\t\
    \t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn !stack.length;\n}\n", "  //\
    \ Make sure we were passed a string of brackets.\n  if (typeof brackets !== \"\
    string\") {\n    return false;\n  }\n\n  // We need a stack to keep track of our\
    \ \"stack\" of brackets. Let's start\n  // by initializing our \"stack\" as an\
    \ empty array.\n  const stack: Array<string> = [];\n\n  // We'll use this to keep\
    \ track of what brackets are \"open\" and what are \"closed\".\n  let opening_brackets:\
    \ Array<string> = [];\n  let closing_brackets: Array<string> = [];\n\n  // Let's\
    \ push our brackets onto our stack. We'll use the \"push\" method on our\n  //\
    \ \"stack\".\n  stack.push(brackets);\n\n  // We'll start looping over the brackets\
    \ until we've gone over all the brackets\n  // in the string.\n  while (stack.length\
    \ > 0) {\n    // Our bracket is \"open\" if there's anything on our \"stack\"\
    \ that's \"open\".\n    let bracket = stack.pop();\n\n    // Check if the bracket\
    \ we're looking at is \"open\". If it is, add it to the \"opening\n    // brackets\"\
    \ array.\n    if (bracket === \"(\") {\n      opening_brackets.push(bracket);\n\
    \    } else if (bracket === \")\") {\n      closing_brackets.push(bracket);\n\
    \    } else {\n      // Otherwise, it's \"closed\". We can check to see if there's\
    \ anything on our\n      // \"stack\" that's \"closed\". If so, we're done looping\
    \ over the brackets in this\n      // string and can consider the whole string\
    \ \"closed\".\n      closing_brackets.forEach((closing_bracket) => {\n       \
    \ if (opening_brackets.includes(closing_bracket)) {\n          // Notice how the\
    \ \"opening\" brackets array is empty now. The whole string is\n          // closed.\n\
    \          return false;\n        }\n      });\n\n      // If there's nothing\
    \ on the \"stack\" that's \"open\", the whole string is \"open\".\n      return\
    \ true;\n    }\n  }\n\n  // At this point, we've gone over all the brackets in\
    \ the string and we're \"open\".\n  return false;\n}\n", "\tlet level = 0;\n\t\
    let closed = {\n\t\t\")\": true,\n\t\t\"(\": true,\n\t\t\"[\": true,\n\t\t\"{\"\
    : true,\n\t};\n\n\tfor (let i = 0; i < brackets.length; ++i) {\n\t\tswitch (brackets[i])\
    \ {\n\t\t\tcase \"(\":\n\t\t\t\tif (level === 0) {\n\t\t\t\t\tlevel++;\n\t\t\t\
    \t}\n\t\t\t\tbreak;\n\t\t\tcase \")\":\n\t\t\t\tif (level > 0) {\n\t\t\t\t\tlevel--;\n\
    \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"[\":\n\t\t\tcase \"{\":\n\t\t\t\tif (level\
    \ === 0) {\n\t\t\t\t\tlevel++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\
    }\n\t\tif (level === 0) {\n\t\t\tclosed[brackets[i]] = true;\n\t\t}\n\t}\n\n\t\
    for (let i in closed) {\n\t\tif (!closed[i]) {\n\t\t\treturn false;\n\t\t}\n\t\
    }\n\treturn true;\n}\n", "  const opening = brackets.split('(')[0];\n  const closing\
    \ = brackets.split(')')[0]\n  return opening === closing;\n}\n", "\tvar bracketSet:\
    \ Set<string> = new Set();\n\tbrackets.split('').forEach(function (bracket: string)\
    \ {\n\t\tbracketSet.add(bracket);\n\t});\n\treturn bracketSet.size === brackets.length;\n\
    }\n", "\tlet result: boolean;\n\n\tbrackets = brackets.toLowerCase();\n\tlet foundBracket:\
    \ boolean = false;\n\n\tbrackets.forEach((bracket: string) => {\n\t\tswitch (bracket)\
    \ {\n\t\t\tcase \"(\":\n\t\t\t\tfoundBracket = true;\n\t\t\t\tbreak;\n\t\t\tcase\
    \ \")\":\n\t\t\t\tif (!foundBracket) {\n\t\t\t\t\tresult = true;\n\t\t\t\t} else\
    \ {\n\t\t\t\t\tfoundBracket = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\
    \t\t\t\tfoundBracket = false;\n\t\t}\n\t});\n\n\treturn result;\n}\n", "  return\
    \ brackets === \"\" || brackets.indexOf(\"(\") > brackets.lastIndexOf(\")\");\n\
    }\n", "\tbrackets_stack: Array<string> = brackets.split(\"\");\n\tfor (let i =\
    \ 1; i < brackets_stack.length; i++) {\n\t\tif (!brackets_stack[i]) return false;\n\
    \t\tif (!brackets_stack[i - 1]) return false;\n\t\tif (brackets_stack[i] != brackets_stack[i\
    \ - 1]) return false;\n\t}\n\treturn true;\n}\n", "\tif (brackets.length === 0)\
    \ {\n\t\treturn true;\n\t}\n\tif (brackets[0] !== '(' && brackets[0] !== '(')\
    \ {\n\t\treturn false;\n\t}\n\n\tvar opening_brackets: number[] = [];\n\tvar closing_brackets:\
    \ number[] = [];\n\n\tfor (var i = 1; i < brackets.length; i++) {\n\t\tlet character\
    \ = brackets[i];\n\t\tlet prev_bracket = brackets[i - 1];\n\t\tif (character ===\
    \ prev_bracket) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (character === ')') {\n\t\t\t\
    closing_brackets.push(i - 1);\n\t\t} else if (character === '(') {\n\t\t\topening_brackets.push(i\
    \ - 1);\n\t\t}\n\t}\n\n\tif (opening_brackets.length !== closing_brackets.length)\
    \ {\n\t\treturn false;\n\t}\n\n\tfor (var i = 0; i < opening_brackets.length;\
    \ i++) {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket\
    \ = closing_brackets[i];\n\t\tif (opening_bracket < closing_bracket) {\n\t\t\t\
    return false;\n\t\t}\n\t\twhile (opening_bracket < closing_bracket) {\n\t\t\t\
    closing_brackets.pop();\n\t\t}\n\t}\n\treturn true;\n}\n", "  for (let i = 0;\
    \ i < brackets.length; i += 1) {\n    if (brackets[i] !== \"(\") {\n      return\
    \ false\n    }\n    if (brackets[i + 1] !== \")\") {\n      return false\n   \
    \ }\n  }\n  return true\n}\n", "    let opening = brackets.substring(0, 1);\n\
    \    let closing = brackets.substring(1, brackets.length);\n    return opening\
    \ == closing;\n}\n", "  return brackets.split('').every(c => c == '(' || c ==\
    \ ')');\n}\n", "\t// TODO: refactor so we don't need this function\n\tlet stack:\
    \ string[] = [];\n\tfor (let i = 0; i < brackets.length; i += 1) {\n\t\tlet c\
    \ = brackets[i];\n\t\tif (c === '(') {\n\t\t\tstack.push(c);\n\t\t}\n\t\telse\
    \ if (c === ')') {\n\t\t\tif (stack.length === 0) {\n\t\t\t\treturn false;\n\t\
    \t\t}\n\t\t\tif (stack.pop() !== c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\
    \t}\n\n\tif (stack.length > 0) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\
    \nexport function get_interpolation(v: Vertex, t1: number, t2: number): number\
    \ {\n\tconst v_num = v.num;\n\tconst t_num = t1 + (t2 - t1) * v_num;\n\treturn\
    \ t_num;\n}\n", "\tbrackets = brackets.toLowerCase();\n\tlet stack: string[] =\
    \ [];\n\tfor (let i = 0; i <= brackets.length; i++) {\n\t\tconst char = brackets.charAt(i);\n\
    \t\tif (char === '(') {\n\t\t\tstack.push(char);\n\t\t} else if (char === ')')\
    \ {\n\t\t\tif (stack.length !== 0) {\n\t\t\t\tstack.pop();\n\t\t\t} else {\n\t\
    \t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (stack.length !== 0) {\n\t\treturn\
    \ false;\n\t} else {\n\t\treturn true;\n\t}\n}\n", "    const brackets_array =\
    \ brackets.split(' ');\n    for (let i = 1; i < brackets_array.length; i++) {\n\
    \        const opening_bracket = brackets_array[i];\n        const closing_bracket\
    \ = brackets_array[0];\n        if (closing_bracket !== opening_bracket) return\
    \ false;\n    }\n    return true;\n}\n", "  return brackets.split('').every(b\
    \ => opening_brackets.includes(b) && closing_brackets.includes(b))\n}\n", "  \
    \  for (let index = 0; index < brackets.length; index++) {\n        if (brackets[index]\
    \ === \"(\") {\n            return correct_bracketing(brackets.substr(0, index))\
    \ && correct_bracketing(brackets.substr(index + 1));\n        }\n        else\
    \ if (brackets[index] === \")\") {\n            return correct_bracketing(brackets.substr(0,\
    \ index + 1)) && correct_bracketing(brackets.substr(index + 1));\n        }\n\
    \    }\n    return true;\n}\n", "  if (brackets.length === 0) {\n    return false;\n\
    \  }\n  const bracketStack: string[] = [];\n  const len = brackets.length;\n \
    \ let openingBrackets: string[] = [];\n  let closingBrackets: string[] = [];\n\
    \n  for (let i = 0; i < len; i++) {\n    const bracket = brackets[i];\n    if\
    \ (bracket === \"(\") {\n      bracketStack.push(bracket);\n      openingBrackets.push(bracket);\n\
    \    }\n    else if (bracket === \")\") {\n      closingBrackets.pop();\n    \
    \  if (closingBrackets.length === 0) {\n        // this is the end of a bracket,\
    \ so the stack is empty.\n        if (bracketStack.length === 0) {\n         \
    \ return false;\n        }\n        bracketStack.pop();\n      } else {\n    \
    \    // this is not a matching bracket\n        return false;\n      }\n    }\n\
    \  }\n  return true;\n}\n", "    if (brackets.length === 0) {\n        return\
    \ false;\n    }\n\n    let openingBrackets = brackets.substring(0, brackets.length\
    \ - 1).split(\")(\");\n    let closingBrackets = brackets.substring(brackets.length\
    \ - 2, brackets.length).split(\")(\");\n\n    let bracketingCorrect = false;\n\
    \    for (let bracketOfInterest of openingBrackets) {\n        for (let closeBracket\
    \ of closingBrackets) {\n            if (bracketOfInterest === closeBracket) {\n\
    \                bracketingCorrect = true;\n            }\n        }\n    }\n\
    \    return bracketingCorrect;\n}\n", "\tlet left_brackets = brackets.split(\"\
    (\");\n\tlet right_brackets = brackets.split(\")\");\n\tif (left_brackets.length\
    \ != right_brackets.length) {\n\t\treturn false;\n\t}\n\tlet matched: number =\
    \ 0;\n\tfor (let i = 0; i < left_brackets.length; i++) {\n\t\tlet left_bracket\
    \ = left_brackets[i];\n\t\tlet right_bracket = right_brackets[i];\n\t\tif (left_bracket.trim().length\
    \ == 0 || right_bracket.trim().length == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\
    let opening_symbol = left_bracket.trim().charAt(0);\n\t\tif (right_bracket.trim().length\
    \ == 0) {\n\t\t\tif (opened == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\topened--;\n\
    \t\t\tcontinue;\n\t\t}\n\t\tlet closing_symbol = right_bracket.trim().charAt(0);\n\
    \t\tif (opening_symbol == closing_symbol) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (opening_symbol\
    \ != \")\") {\n\t\t\topened++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (opened < 1) {\n\
    \t\t\treturn false;\n\t\t}\n\t\tif (opened == 1) {\n\t\t\topened.push(opening_symbol);\n\
    \t\t\tcontinue;\n\t\t}\n\t\tif (opened_symbols.indexOf(opening_symbol) == -1)\
    \ {\n\t\t\treturn false;\n\t\t}\n\t\topened.push(opening_symbol);\n\t\tmatched++;\n\
    \t}\n\treturn matched > 0;\n}\n", "\tlet stack: string[] = [];\n\tlet brackets_open\
    \ = brackets.replace(\"(\", \"\");\n\tlet brackets_close = brackets.replace(\"\
    )\", \"\");\n\n\tfor (let i = 0; i < brackets_open.length; i++) {\n\t\tif (brackets_close.indexOf(brackets_open[i])\
    \ < 0) {\n\t\t\treturn false; // wrong bracket\n\t\t}\n\t\tstack.push(brackets_open[i]);\n\
    \t}\n\n\twhile (stack.length > 0) {\n\t\tlet opening = stack.pop();\n\t\tlet closing\
    \ = brackets_close.indexOf(opening);\n\n\t\tif (closing < 0) {\n\t\t\treturn false;\
    \ // wrong bracket\n\t\t}\n\n\t\tif (brackets_close[closing] === opening) {\n\t\
    \t\tclosing++;\n\t\t}\n\n\t\tbrackets_close = brackets_close.slice(0, closing)\
    \ + brackets_close.slice(closing + 1);\n\t}\n\treturn true;\n}\n\n", "    let\
    \ counts: {[character: string]: number} = {}\n    for (let i = 0; i < brackets.length;\
    \ ++i) {\n        let c = brackets[i]\n        counts[c] = (c in counts) ? counts[c]\
    \ + 1 : 0\n    }\n    for (let k in counts) {\n        if (counts[k] === 0) {\n\
    \            return false\n        }\n    }\n    return true\n}\n</code>\nNote\
    \ that this takes advantage of the fact that JavaScript arrays are zero-indexed,\
    \ and in fact you can write this function in one line:\n<code>", "\tvar correct\
    \ = false;\n\tbrackets.split('').forEach((bracket: string) => {\n\t\tif (\n\t\t\
    \t(\n\t\t\t\tbracket.match(/[(){}]/g) == null &&\n\t\t\t\tbracket.match(/[a-zA-Z0-9]/g)\
    \ == null &&\n\t\t\t\tbracket.match(/\\s/g) == null\n\t\t\t) ||\n\t\t\tbracket.match(/[(){}]/g)\
    \ == null &&\n\t\t\tbracket.match(/[a-zA-Z0-9]/g) == null &&\n\t\t\tbracket.match(/[a-zA-Z0-9][a-zA-Z0-9]/g)\
    \ == null\n\t\t) {\n\t\t\tcorrect = true;\n\t\t}\n\t});\n\treturn correct;\n}",
  "\tlet open = false, close = false;\n\tbrackets.split('').forEach((b) => {\n\t\t\
    if (b === '(') open = true\n\t\telse if (b === ')') close = true\n\t})\n\treturn\
    \ open === close\n}\n", "  const opening_brackets = new RegExp(\"\\\\(.*\\\\)\"\
    );\n  const closing_brackets = new RegExp(\"\\\\(.*\\\\)\");\n  // make sure all\
    \ opening and closing brackets are correct\n  return opening_brackets.test(brackets)\
    \ && closing_brackets.test(brackets);\n}\n", "\tlet level = 0;\n\tfor (let i =\
    \ 0; i < brackets.length; i++) {\n\t\tlet next = brackets[i + 1];\n\t\tif (next\
    \ === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (brackets[i] === \")\"\
    ) {\n\t\t\tlevel--;\n\t\t\tif (level < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\
    \t} else if (brackets[i] === \"(\") {\n\t\t\tlevel++;\n\t\t\tif (level < 0) {\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n", "    if (brackets\
    \ == null || brackets.length < 2) {\n        return false;\n    }\n    return\
    \ brackets[0] === brackets[brackets.length - 1];\n}\n", "  if (brackets.length\
    \ === 0) {\n    return false;\n  }\n\n  var opening = brackets[0];\n  var closing\
    \ = brackets[brackets.length - 1];\n\n  if (opening === closing) {\n    return\
    \ false;\n  }\n\n  if (opening === '(' && closing === ')') {\n    return false;\n\
    \  }\n\n  if (opening === '[' && closing === ']') {\n    return false;\n  }\n\n\
    \  return true;\n}\n", "  var opening_brackets = [];\n  var closing_brackets =\
    \ [];\n  var prev_char;\n  brackets.split(\"\").forEach(function(char) {\n   \
    \ if (char === \"(\" || char === \")\") {\n      opening_brackets.push(char);\n\
    \    }\n    if (char === \")\") {\n      closing_brackets.push(char);\n    }\n\
    \  });\n  if (closing_brackets.length !== opening_brackets.length) {\n    return\
    \ false;\n  }\n  closing_brackets.reverse();\n  opening_brackets.forEach(function(char,\
    \ index) {\n    if (prev_char && prev_char === char) {\n      closing_brackets.splice(index,\
    \ 1);\n    }\n    prev_char = char;\n  });\n  if (closing_brackets.length ===\
    \ 0) {\n    return false;\n  }\n  return true;\n}\n</code>\n<|/ a tags=language-agnostic,language-agnostic\
    \ |>\n<| c |>\nI like the solution, but how does it work for `(()())`?\n<|/ c\
    \ |>\n<| c |>\nThe first closing bracket has no matching opening bracket, so it\
    \ returns false. Second closing bracket has a matching opening bracket but no\
    \ matching closing bracket, so it returns false. Third opening bracket has no\
    \ matching closing bracket, so it returns false. Fourth closing bracket has a\
    \ matching opening bracket and closing bracket, so it returns true. Fifth closing\
    \ bracket has matching opening bracket and no matching closing bracket, so it\
    \ returns false.\n<|/ c |>\n<| c |>\nThis is not correct. With `(()())` there\
    \ are 7 opening brackets and 6 closing brackets, yet your algorithm returns false.\n\
    <|/ c |>\n<| c |>\nHe was saying `(()())` has 7 opening brackets and 6 closing\
    \ brackets.\n<|/ c |>\n<| c |>\nYes, I understand that but your algorithm returns\
    \ false when there are 7 and 6 closing brackets (which are both valid according\
    \ to his original solution). The problem is that there are 6 opening brackets\
    \ and 7 closing brackets but your algorithm returns false. I think you meant to\
    \ say that he is missing some `else` cases, but the code doesn't match his original\
    \ code as it is.\n<|/ c |>\n<| a dscore=2 |>\nIf you're using an imperative language,\
    \ I would suggest iterating over the list twice to solve this problem - first\
    \ to find the matching pairs, then to identify the missing closing bracket and\
    \ add it back on to the list.\n<code>\ndef brackets_correct(brackets):\n    opening_brackets\
    \ = []\n    closing_brackets = []\n    matche", "  const open_brackets = brackets.match(/[()]+/g)\n\
    \  const close_brackets = brackets.match(/[)]+/g)\n  return (open_brackets.length\
    \ === close_brackets.length) && (open_brackets.length >= 1)\n}\n", "  for (let\
    \ i = 0; i < brackets.length; ++i) {\n    if (brackets[i] === brackets[brackets.length\
    \ - 1 - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "\tlet stack\
    \ = [];\n\tlet pos = 0;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet\
    \ bracket = brackets[i];\n\t\tswitch (bracket) {\n\t\t\tcase \"(\":\n\t\t\t\t\
    stack.push(bracket);\n\t\t\t\tbreak;\n\t\t\tcase \")\":\n\t\t\t\tif (stack.length\
    \ && stack[stack.length - 1] === bracket) {\n\t\t\t\t\tstack.pop();\n\t\t\t\t\
    } else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \",\"\
    :\n\t\t\t\tif (stack.length && stack[stack.length - 1] !== \"(\") {\n\t\t\t\t\t\
    return false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"[\":\n\t\t\tcase \"{\"\
    :\n\t\t\tcase \"(\":\n\t\t\tcase \"[\":\n\t\t\tcase \"{\":\n\t\t\tcase \"(\":\n\
    \t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\
    \t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\
    \tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\t\
    case \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase \"}\":\n\t\t\tcase\
    \ \"}\":", "\tfor (let i = 0; i < brackets.length; i += 1) {\n\t\tconst bracket\
    \ = brackets[i];\n\t\tif (bracket !== \"(\") {\n\t\t\treturn false;\n\t\t}\n\t\
    }\n\treturn true;\n}\n", "  if (brackets === '()') return true\n  if (brackets\
    \ === ')(') return true\n  return brackets.indexOf('(') !== brackets.lastIndexOf(')')\n\
    }\n", "  brackets = brackets.split(' ');\n  brackets\n    .map(bracket => bracket[0]\
    \ === '(' ? 1 : -1)\n    .filter((val, index, arr) => arr.findIndex(a => a ===\
    \ val) === index)\n    .every(val => val === 1);\n}\n", "    // the brackets string\
    \ is given as a single string, so break it into its individual characters.\n \
    \   const brackets_characters = brackets.split(\"\");\n    // start by checking\
    \ the first character in brackets_characters, which is the opening bracket for\
    \ the first line of the bracket.\n    // if that character is open, the first\
    \ line of the bracket should be closed, so no need to check the rest of the brackets_characters.\n\
    \    if (brackets_characters.includes(\"(\")) {\n        // if the first character\
    \ of the brackets string is \"(\" then we know that the first line of the bracket\
    \ will be closed.\n        // if that first line is closed then we can return\
    \ true.\n        return brackets_characters[0] == \"(\";\n    } else {\n     \
    \   // the first character of the brackets string is not \"(\" so we know that\
    \ the first line of the bracket will be open.\n        // if the first line of\
    \ the bracket is open then we can return false.\n        return brackets_characters[0]\
    \ != \")\";\n    }\n}\n", "  const bracketPairs: string[] = brackets.split(\"\"\
    );\n  for (let i = 0; i < bracketPairs.length; ++i) {\n    const [open, close]\
    \ = bracketPairs[i].split(\"\");\n    if (open !== close) {\n      return true;\n\
    \    }\n  }\n  return false;\n}\n", "  let stack: string[] = [];\n  let open_brackets:\
    \ string[] = [];\n  let closed_brackets: string[] = [];\n\n  for (let i = 0; i\
    \ < brackets.length; i++) {\n    if (brackets[i] === \")\") {\n      if (stack.length\
    \ !== 0) {\n        // closing bracket\n        open_brackets.push(stack.slice(-1)[0]);\n\
    \        closed_brackets.push(stack.slice(0, -1));\n        stack.pop();\n   \
    \   }\n    } else {\n      stack.push(brackets[i]);\n    }\n  }\n\n  if (stack.length\
    \ !== 0) {\n    // if brackets are incomplete\n    return false;\n  }\n\n  for\
    \ (let j = 0; j < open_brackets.length; j++) {\n    if (closed_brackets[j] !==\
    \ open_brackets[j]) {\n      // brackets are not matching\n      return false;\n\
    \    }\n  }\n\n  return true;\n}\n", "\tif (brackets.length == 0) {\n\t\treturn\
    \ true;\n\t}\n\tlet stack: string[] = [];\n\tfor (let i = 0; i < brackets.length;\
    \ ++i) {\n\t\tlet c = brackets[i];\n\t\tif (c == '(') {\n\t\t\tstack.push(c);\n\
    \t\t} else if (c == ')') {\n\t\t\tif (stack.length == 0 || stack[stack.length\
    \ - 1] != '(') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstack.pop();\n\t\t} else\
    \ {\n\t\t\tif (stack.length != 0 && !(stack.slice(-1)[0] != '(' && c == stack[stack.length\
    \ - 1])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstack.push(c);\n\t\t}\n\t}\n\
    \tif (stack.length != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "  let\
    \ opening_brackets = brackets.split(\"\");\n  let closed = 0;\n  let found = false;\n\
    \n  for (let i = 0; i < opening_brackets.length; i++) {\n    if (opening === closing)\
    \ {\n      found = true;\n    } else {\n      opening = opening_brackets[i];\n\
    \      closing = opening_brackets[++i];\n    }\n  }\n\n  return found;\n}\n",
  "  for (let i = 0, len = brackets.length; i < len; i++) {\n    const bracket = brackets.charAt(i);\n\
    \    if (bracket === '(') return true;\n    if (bracket === ')') return false;\n\
    \  }\n  return true;\n}\n", "    if (brackets === \"\" || brackets === \"()\"\
    ) {\n        return false;\n    }\n    // if we don't have a bracket at all we\
    \ can't have correct bracketing\n    const length = brackets.length - 1;\n   \
    \ for (let i = 0; i < length; i++) {\n        const open_char = brackets.charAt(i);\n\
    \        const close_char = brackets.charAt(i + 1);\n        const opening_count\
    \ = brackets.count(open_char);\n        const closing_count = brackets.count(close_char);\n\
    \        if (opening_count > closing_count) {\n            return false;\n   \
    \     }\n    }\n    return true;\n}\n", "  const stack: string[] = [];\n  for\
    \ (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] == \"(\") stack.push(brackets[i]);\n\
    \    else if (brackets[i] == \")\") {\n      const last = stack.pop();\n     \
    \ if (last == brackets[i]) return true;\n    }\n  }\n  return false;\n}\n", "\t\
    let opening: boolean = false;\n\tlet closing: boolean = false;\n\tlet length:\
    \ number = brackets.length;\n\tfor (let i = 0; i < length; i++) {\n\t\tlet character\
    \ = brackets.charAt(i);\n\t\tif (character === \"(\") {\n\t\t\tif (opening) {\n\
    \t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\topening = true;\n\t\t\t}\n\t\t\
    } else if (character === \")\") {\n\t\t\tif (closing) {\n\t\t\t\treturn false;\n\
    \t\t\t} else {\n\t\t\t\tclosing = true;\n\t\t\t}\n\t\t} else {\n\t\t\topening\
    \ = false;\n\t\t\tclosing = false;\n\t\t}\n\t}\n\treturn true;\n}\n", "  brackets\
    \ = brackets.replace(/\\s*$/g, \"\"); // strip off whitespace after the last bracket.\n\
    \n  if (brackets.length !== 2) return false; // must have two brackets\n  if (brackets.charAt(0)\
    \ === '(' && brackets.charAt(1) === ')') return true; // one pair match\n  if\
    \ (brackets.charAt(0) === '(' && brackets.charAt(1) === ')' && brackets.charAt(2)\
    \ === ' ') return true; // all three match\n\n  return false;\n}\n", "  // TODO:\
    \ use stack\n  for (let i = 0; i < brackets.length; ++i) {\n    // brackets[i]\
    \ == \"(\"\n    if (brackets[i] === ')') return false;\n    // brackets[i] ==\
    \ \")\"\n    if (brackets[i] === \"(\") return false;\n  }\n  return true;\n}\n",
  "    let stack = [];\n    for (let i = 0; i < brackets.length; ++i) {\n        let\
    \ bracket = brackets[i];\n        if (bracket == '(' || bracket == '[' || bracket\
    \ == '{') {\n            stack.push(bracket);\n        } else if (bracket == ')'\
    \ || bracket == ']' || bracket == '}') {\n            if (stack.length == 0) return\
    \ false;\n            if (bracket == ')' && stack.pop() != '(') return false;\n\
    \            if (bracket == ']' && stack.pop() != '[') return false;\n       \
    \     if (bracket == '}' && stack.pop() != '{') return false;\n        }\n   \
    \ }\n    return stack.length == 0;\n}\n", "  var stack: string[] = [];\n  for\
    \ (var i = 0; i < brackets.length; i++) {\n    var b = brackets.charAt(i);\n \
    \   if (b !== \"(\" && b !== \")\") {\n      return false;\n    }\n    stack.push(b);\n\
    \  }\n\n  for (var i = 1; i < stack.length; i++) {\n    if (stack[i] !== stack[i\
    \ - 1]) {\n      return false;\n    }\n  }\n\n  return stack.length === 0;\n}\n",
  "  if (brackets.length < 1) {\n    return true;\n  }\n  let last = 0;\n  for (let\
    \ i = 1; i < brackets.length; i++) {\n    if (brackets[i] !== brackets[i - 1]\
    \ + 1) {\n      return false;\n    }\n    if (brackets[last] === brackets[i] +\
    \ 1) {\n      last = i;\n    }\n  }\n  // we checked that all brackets are correctly\
    \ closed.\n  // check that all brackets are properly opened.\n  for (let i = last;\
    \ i < brackets.length; i++) {\n    if (brackets[i] !== brackets[i - 1]) {\n  \
    \    return false;\n    }\n  }\n  return true;\n}\n", "\t// a stack of brackets\n\
    \tlet stack: string[] = [];\n\n\t// walk through the string\n\tfor (let i = 0;\
    \ i < brackets.length; i++) {\n\t\t// the current char in the bracket\n\t\tlet\
    \ curr = brackets[i];\n\n\t\t// if it's the start of a bracket\n\t\tif (curr ===\
    \ \"(\") {\n\t\t\t// add it to the stack\n\t\t\tstack.push(curr);\n\t\t}\n\t\t\
    // if we have something on the stack\n\t\telse if (stack.length > 0) {\n\t\t\t\
    // if the current char is the same as the top of the stack\n\t\t\tif (curr ===\
    \ stack[stack.length - 1]) {\n\t\t\t\t// remove it from the stack\n\t\t\t\tstack.pop();\n\
    \t\t\t}\n\t\t}\n\t}\n\n\t// stack is empty if we didn't find any matching brackets\n\
    \treturn stack.length === 0;\n}\n", "\tif (brackets.length === 0) {\n\t\treturn\
    \ true;\n\t}\n\tif (brackets.charAt(0) === brackets.charAt(brackets.length - 1))\
    \ {\n\t\treturn true;\n\t}\n\treturn brackets.charAt(brackets.length - 1) ===\
    \ '(' && brackets.charAt(0) === '(';\n}\n\n", "  const stack: string[] = [];\n\
    \  for (let i = 0; i < brackets.length; i += 1) {\n    const bracket = brackets[i];\n\
    \    if (bracket === '(') {\n      stack.push(bracket);\n    } else if (bracket\
    \ === ')') {\n      if (stack.pop() !== bracket) {\n        return false;\n  \
    \    }\n    }\n  }\n  return !stack.length;\n}\n", "    let opening = brackets.charAt(0);\n\
    \    let closing = brackets.charAt(brackets.length - 1);\n    let opening_brackets\
    \ = [\n        \"(\",\n        \"[\",\n        \"{\",\n        \"<\",\n      \
    \  \"!\",\n        \"|\",\n        \"#\",\n        \"$\",\n        \"%\",\n  \
    \      \"^\",\n        \"&\",\n        \"*\",\n        \"!\",\n        \"|\",\n\
    \        \"#\",\n        \"$\",\n        \"%\",\n        \"^\",\n        \"&\"\
    ,\n        \"*\",\n        \"!\",\n        \"|\",\n        \"#\",\n        \"\
    $\",\n        \"%\",\n        \"^\",\n        \"&\",\n        \"*\",\n       \
    \ \"!\",\n        \"|\",\n        \"#\",\n        \"$\",\n        \"%\",\n   \
    \     \"^\",\n        \"&\",\n        \"*\",\n        \"!\",\n        \"|\",\n\
    \        \"#\",\n        \"$\",\n        \"%\",\n        \"^\",\n        \"&\"\
    ,\n        \"*\",\n        \"!\",\n        \"|\",\n        \"#\",\n        \"\
    $\",\n        \"%\",\n        \"^\",\n        \"&\",\n        \"*\",\n       \
    \ \"!\",\n        \"|\",\n        \"#\",\n        \"$\",\n        \"%\",\n   \
    \     \"^\",\n        \"&\",\n        \"*\",\n        \"!\",\n        \"|\",\n\
    \        \"#\",\n        \"$\",\n        \"%\",\n        \"^\",\n        \"&\"\
    ,\n        \"*\",\n        \"!\",\n        \"|\",\n        \"#\",\n        \"\
    $\",\n        \"%\",\n        \"^\",\n        \"&\",\n        \"*\",\n       \
    \ \"!\",\n        \"|\",\n        \"#\",\n        \"$\",\n        \"%\",\n   \
    \     \"^\",\n        \"&\",\n        \"*\",\n        \"!\",\n        \"|\",\n\
    \        \"#\",\n        \"$\",\n        \"%\",\n        \"^\",\n        \"&\"\
    ,\n        \"*\",\n        \"!\",\n        \"|\",\n        \"#\",\n        \"\
    $\",\n        \"%\",\n        \"^\",\n        \"&\",\n        \"*\",\n       \
    \ \"!\",\n        \"|\",\n        \"#\",\n        \"$\",\n        \"%\",\n   \
    \     \"^\",\n        \"&\",\n        \"*\",\n        \"!\",\n        \"|\",\n\
    \        \"#\",\n        \"$\",\n        \"%\",\n        \"^\",\n        \"&\"\
    ,\n        \"*\",\n        \"!\",\n        \"|\",\n        \"#\",\n        \"\
    $\",\n        \"%\",\n        \"^\",\n        \"&\",\n        \"*\",\n       \
    \ \"!\",\n        \"", "\tvar opening_brackets:number[] = [];\n\tvar closing_brackets:number[]\
    \ = [];\n\tvar current_opening_bracket:number;\n\tvar current_closing_bracket:number;\n\
    \tvar open_count = 0; //number of opening brackets we have seen.\n\tvar close_count\
    \ = 0; //number of closing brackets we have seen.\n\tvar open_bracket = brackets[0];\n\
    \tvar close_bracket = brackets[brackets.length - 1];\n\n\tfor (var i = 0; i <\
    \ brackets.length; i++) {\n\t\tif (brackets[i] == open_bracket) {\n\t\t\tcurrent_opening_bracket\
    \ = i;\n\t\t\topening_brackets.push(current_opening_bracket);\n\t\t\topen_count++;\n\
    \t\t}\n\t\telse if (brackets[i] == close_bracket) {\n\t\t\tcurrent_closing_bracket\
    \ = i;\n\t\t\tclosing_brackets.push(current_closing_bracket);\n\t\t\tclose_count++;\n\
    \t\t}\n\t}\n\n\tif (opening_brackets.length == 0 && closing_brackets.length ==\
    \ 0) {\n\t\treturn true;\n\t}\n\n\tfor (var i = 0; i < opening_brackets.length;\
    \ i++) {\n\t\tvar opening_bracket = opening_brackets[i];\n\t\tfor (var j = opening_bracket\
    \ + 1; j < closing_brackets.length; j++) {\n\t\t\tvar current_closing_bracket\
    \ = closing_brackets[j];\n\t\t\tif (opening_bracket == current_closing_bracket)\
    \ {\n\t\t\t\t//same opening and closing brackets.\n\t\t\t\tif (open_count == close_count)\
    \ {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n", "    if (brackets.length\
    \ !== 2) {\n        return false;\n    }\n    for (let i = 1; i < brackets.length;\
    \ i++) {\n        if (brackets[i] === brackets[i - 1]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "  // Keep track of how many opening\
    \ brackets are in the string, and\n  // how many closing brackets are in the string.\n\
    \  let open_brackets = 0;\n  let close_brackets = 0;\n\n  // For every character\
    \ in the string, increment the appropriate\n  // bracket counter.\n  for (let\
    \ c of brackets) {\n    if (c === '(') {\n      open_brackets++;\n    } else if\
    \ (c === ')') {\n      close_brackets++;\n    }\n  }\n\n  // Return false if the\
    \ string has an unclosed bracket.\n  return (close_brackets !== open_brackets);\n\
    }\n", "  var opening_brackets = brackets.match(/\\(/g);\n  var closing_brackets\
    \ = brackets.match(/\\)/g);\n\n  for (var i = 0; i != opening_brackets.length;\
    \ i++) {\n    if (closing_brackets[i] != opening_brackets[i]) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n\nvar current_word = \"\"; // the word\
    \ under consideration\nvar previous_word = \"\"; // the word previously seen\n\
    var word_separators = []; // the characters used to separate words\nvar line_starter_count\
    \ = 0; // number of starter chars in current line\n", "  if (brackets == null)\
    \ {\n    return false;\n  }\n  // return true if every opening bracket has a corresponding\
    \ closing bracket.\n  let opening_count = new Map<string, number>();\n  let opening_count_keys\
    \ = Object.keys(opening_count);\n  for (let i = 0; i < opening_count_keys.length;\
    \ i++) {\n    let key = opening_count_keys[i];\n    let value = opening_count.get(key);\n\
    \    if (value != 0) {\n      return false;\n    }\n  }\n\n  // return true if\
    \ every closing bracket has a corresponding opening bracket.\n  let closing_count\
    \ = new Map<string, number>();\n  let closing_count_keys = Object.keys(closing_count);\n\
    \  for (let i = 0; i < closing_count_keys.length; i++) {\n    let key = closing_count_keys[i];\n\
    \    let value = closing_count.get(key);\n    if (value != 0) {\n      return\
    \ false;\n    }\n  }\n\n  // if all of the brackets are correctly paired, then\
    \ return true.\n  return true;\n}\n", "  for (let i = 0; i < brackets.length;\
    \ i++) {\n    if (brackets[i] == '(' && brackets[i + 1] != ')') {\n      return\
    \ false;\n    }\n    if (brackets[i] == '[' && brackets[i + 1] != ']') {\n   \
    \   return false;\n    }\n    if (brackets[i] == '{' && brackets[i + 1] != '}')\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n", "\tif (brackets ===\
    \ \"\") {\n\t\treturn false;\n\t}\n\t// If the brackets is a single string\n\t\
    if (brackets === \"(\" || brackets === \"[]\") {\n\t\treturn true;\n\t}\n\t//\
    \ if the brackets is a string of \"(\" and \")\".\n\t// if any opening bracket\
    \ has a corresponding closing bracket.\n\tif (brackets.substring(0, 2) === \"\
    ((\") {\n\t\treturn brackets.substring(4, brackets.length) === \")\";\n\t}\n\t\
    if (brackets.substring(0, 1) === \"([]\") {\n\t\treturn brackets.substring(2,\
    \ brackets.length) === \"]\";\n\t}\n\treturn false;\n}\n", "\t// Return false\
    \ if the brackets are \"(\", \")\", \"[\", \"]\", or \"}\", or there is no brackets.\n\
    \tif (brackets === \"\" || brackets == \"(\" || brackets == \"[\") {\n\t\treturn\
    \ false;\n\t}\n\tif (brackets == \"{\") {\n\t\t// If the brackets is a curly bracket,\
    \ return the correct answer.\n\t\treturn true;\n\t}\n\tif (brackets == \"}\")\
    \ {\n\t\t// If the brackets is a curly bracket, return the correct answer.\n\t\
    \treturn true;\n\t}\n\tif (brackets == \"[\") {\n\t\t// If the brackets is a square\
    \ bracket, return the correct answer.\n\t\treturn true;\n\t}\n\tif (brackets ==\
    \ \")\") {\n\t\t// If the brackets is a round bracket, return the correct answer.\n\
    \t\treturn true;\n\t}\n\treturn false;\n}\n", "\tlet brackets_counter: number\
    \ = 0;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tif (brackets[i] ==\
    \ '(') brackets_counter++;\n\t\telse if (brackets[i] == ')') brackets_counter--;\n\
    \t}\n\treturn (brackets_counter == 0);\n}\n", "    let stack: StackItem[] = [];\n\
    \    for (let i = 0; i < brackets.length; i += 1) {\n        let opening = brackets.charAt(i);\n\
    \        if (opening === '(') {\n            stack.push({position: i, character:\
    \ opening});\n        } else if (opening === ')') {\n            if (stack.length\
    \ === 0) {\n                return false;\n            }\n\n            let last\
    \ = stack.pop();\n            if (last.character !== opening) {\n            \
    \    return false;\n            }\n        }\n    }\n\n    return (stack.length\
    \ === 0);\n}\n", "  const stack = brackets.match(/\\((?!\\))/g) || [];\n  const\
    \ stackLen = stack.length;\n  return stackLen === 0 ||\n    (stackLen === 1 &&\
    \ stack[0] === \")\") ||\n    (stackLen === 2 && stack[0] === \")\" && stack[1]\
    \ === \")\") ||\n    (stackLen === 3 && stack[0] === \")\" && stack[1] === \"\
    )\" && stack[2] === \")\");\n}\n", "\tlet stack = [];\n\tfor (let i = 0; i < brackets.length;\
    \ i += 1) {\n\t\tlet current_char = brackets[i];\n\t\tif (stack.length === 0)\
    \ {\n\t\t\t// this is the first character in the string. Just a normal opening\
    \ bracket\n\t\t\tstack.push(current_char);\n\t\t}\n\t\telse if (stack[stack.length\
    \ - 1] === \")\") {\n\t\t\t// this isn't the final closing bracket. Need to check\
    \ each opening\n\t\t\tstack.pop();\n\t\t\tif (current_char === \")\") {\n\t\t\t\
    \t// this is now the final closing bracket. We've found an opening.\n\t\t\t\t\
    // So do nothing but add the opening to the stack\n\t\t\t\tstack.push(current_char);\n\
    \t\t\t}\n\t\t\telse {\n\t\t\t\t// this is not the final closing bracket. Need\
    \ to add the current\n\t\t\t\t// character and pop any remaining opening brackets\n\
    \t\t\t\tstack.push(current_char);\n\t\t\t\twhile (stack.length > 0 &&\n\t\t\t\t\
    \t\tstack[stack.length - 1] !== \")\") {\n\t\t\t\t\tstack.shift();\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t\telse if (stack[stack.length - 1] === \"(\") {\n\t\t\t// this\
    \ is not the final opening bracket. Need to add the current\n\t\t\t// character\
    \ and pop any remaining closing brackets\n\t\t\tstack.push(current_char);\n\t\t\
    \twhile (stack.length > 0 &&\n\t\t\t\t\tstack[stack.length - 1] !== \")\") {\n\
    \t\t\t\tstack.shift();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// this isn't an opening\
    \ or closing bracket. Just add the current\n\t\t\t// character to the stack and\
    \ pop the stack.\n\t\t\tstack.push(current_char);\n\t\t\twhile (stack.length >\
    \ 0 &&\n\t\t\t\t\tstack[stack.length - 1] !== \")\") {\n\t\t\t\tstack.shift();\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn stack.length === 0;\n}\n", "    const stack = brackets.split('');\n\
    \    for (let i = 0; i < stack.length; ++i) {\n        if (stack[i] === '(')\n\
    \            stack.splice(i + 1, 0, '(');\n        if (stack[i] === ')')\n   \
    \         stack.splice(i + 1, 0, ')');\n        if (stack[i] === '(' && stack[i+1]\
    \ === ')')\n            stack.splice(i + 1, 1);\n    }\n    return stack.join('')\
    \ === brackets;\n}\n</code>\nThe function above is very simple (I guess it's easy!).\
    \ It's a little more complicated than the previous answer, because it doesn't\
    \ check whether the first and last characters are brackets.\n<|/ a tags=function,javascript,brackets,function\
    \ |>\n<| c |>\nYes it does work for that case but fail for case like this: `[\
    \ (1) (2) (3) (4) ]`\n<|/ c |>\n<| a tags=function,javascript,brackets,function\
    \ |>\n<code>\n    function bracketChecker(string){\n        const stack = [];\n\
    \        for(let i = 0; i < string.length; i++){\n            if(string[i]==='('){\n\
    \                stack.push('(');\n            } else if(string[i]==='[') {\n\
    \                stack.push('[');\n            } else if(string[i]==='{') {\n\
    \                stack.push('{');\n            } else if(string[i]==='(' || string[i]==='{'\
    \ || string[i]==='[') {\n                while(stack.length && stack[stack.length-1]!==string[i]){\n\
    \                    stack.pop();\n                }\n                if(!stack.length)\
    \ \n                    alert('Not a Brackets')\n            }\n        }\n  \
    \  }\n    bracketChecker(\"([(){}[]])\")\n    bracketChecker(\"([(])\")\n    bracketChecker(\"\
    ([{])\")\n    bracketChecker(\"([([])])\")\n    bracketChecker(\"([[(])])\")\n\
    \    bracketChecker(\"([([])])\")\n    bracketChecker(\"([([])])\")\n    bracketChecker(\"\
    ((){})\")\n    bracketChecker(\"((()))\")\n    bracketChecker(\"(()())\")\n  \
    \  bracketChecker(\"(())\")\n    bracketChecker(\"((()()))\")\n    bracketChecker(\"\
    ((())())\")\n    bracketChecker(\"(()((())))\")\n    bracketChecker(\"(())(())\"\
    )\n    bracketChecker(\"(()()())\")\n    bracketChecker(\"()()()()\")\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=2 tags=function,javascript,brackets,function |>\n\
    Here is my solution, based on Ahmet Hasan's ", "\tvar level = 0;\n\tvar in_bracket\
    \ = false;\n\tvar incorrect = false;\n\tvar bracketing = false;\n\tvar current\
    \ = '';\n\n\tfor (var i = 0; i < brackets.length; i++) {\n\t\tvar c = brackets[i];\n\
    \t\tvar is_open = in_bracket;\n\t\tvar is_closed = false;\n\n\t\tif (!in_bracket)\
    \ {\n\t\t\tcurrent = c;\n\t\t\tlevel++;\n\t\t\tif (c === '(' || c === '[' || c\
    \ === '{') {\n\t\t\t\tin_bracket = true;\n\t\t\t}\n\t\t\telse if ((c === ')')\
    \ || (c === ']') || (c === '}')) {\n\t\t\t\tin_bracket = false;\n\t\t\t\tbracketing\
    \ = true;\n\t\t\t}\n\t\t}\n\n\t\tif (c === ')') {\n\t\t\tif (is_closed) {\n\t\t\
    \t\tincorrect = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tis_closed = true;\n\t\t\t\
    \tlevel--;\n\t\t\t\tcurrent += c;\n\t\t\t}\n\t\t}\n\n\t\tif (c === ']') {\n\t\t\
    \tif (is_open) {\n\t\t\t\tincorrect = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tis_open\
    \ = true;\n\t\t\t\tlevel--;\n\t\t\t\tcurrent += c;\n\t\t\t}\n\t\t}\n\n\t\tif (c\
    \ === '[') {\n\t\t\tif (is_closed) {\n\t\t\t\tincorrect = true;\n\t\t\t}\n\t\t\
    \telse {\n\t\t\t\tis_closed = true;\n\t\t\t\tlevel--;\n\t\t\t\tcurrent += c;\n\
    \t\t\t}\n\t\t}\n\n\t\tif (c === '{') {\n\t\t\tif (is_open) {\n\t\t\t\tincorrect\
    \ = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tis_open = true;\n\t\t\t\tlevel--;\n\t\
    \t\t\tcurrent += c;\n\t\t\t}\n\t\t}\n\n\t\tif (!is_closed && !is_open) {\n\t\t\
    \tincorrect = true;\n\t\t}\n\n\t\tif (!bracketing && is_open && is_closed) {\n\
    \t\t\tincorrect = true;\n\t\t}\n\n\t\tif (!bracketing && !is_open && is_closed)\
    \ {\n\t\t\tincorrect = true;\n\t\t}\n\n\t\tif (!bracketing && !is_open && !is_closed\
    \ && !in_bracket) {\n\t\t\tincorrect = true;\n\t\t}\n\t}\n\n\treturn !incorrect;\n\
    }\n", "\tvar opening_brackets = brackets.substring(1, brackets.length);\n\tvar\
    \ closing_brackets = brackets.substring(brackets.length + 1);\n\treturn opening_brackets\
    \ === \"(\" && closing_brackets === \")\";\n}\n", "  let opening_brackets: number[]\
    \ = [];\n  let closing_brackets: number[] = [];\n  for (let i = 0; i < brackets.length;\
    \ i++) {\n    if (brackets[i] == \"(\") {\n      opening_brackets.push(i);\n \
    \   } else {\n      closing_brackets.push(i);\n    }\n  }\n  return opening_brackets.every(\n\
    \    (opening_bracket: number) => closing_brackets.includes(opening_bracket)\n\
    \  );\n}\n", "\tlet stack = [];\n\tlet bracket = false;\n\tfor (let i = 0; i <\
    \ brackets.length; i++) {\n\t\tif (brackets[i] === \"(\") {\n\t\t\tif (bracket)\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstack.push(brackets[i]);\n\t\t\tbracket\
    \ = true;\n\t\t} else if (brackets[i] === \")\") {\n\t\t\tif (!bracket) {\n\t\t\
    \t\treturn false;\n\t\t\t}\n\t\t\tbracket = false;\n\t\t\twhile (stack.length\
    \ > 0 && brackets[stack.pop()] !== \"(\") {\n\t\t\t}\n\t\t\tif (stack.length ===\
    \ 0) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tbracket = stack.pop();\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n", "  brackets = brackets.split('');\n\
    \  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] == '(' ||\
    \ brackets[i] == '[' || brackets[i] == '{' || brackets[i] == '+' || brackets[i]\
    \ == '-' || brackets[i] == '*' || brackets[i] == '/' || brackets[i] == '%' ||\
    \ brackets[i] == '!' || brackets[i] == '&' || brackets[i] == '|' || brackets[i]\
    \ == '?' || brackets[i] == '<' || brackets[i] == '>' || brackets[i] == '=' ||\
    \ brackets[i] == '|' || brackets[i] == '>' || brackets[i] == '<') {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "\tvar stack: BracketStack = new BracketStack(brackets);\n\
    \treturn (stack.brackets.length == brackets.length) &&\n\t\tstack.brackets.every(function(bracket:\
    \ Bracket) {\n\t\t\treturn (bracket.open == stack.peek()) &&\n\t\t\t\t(bracket.close\
    \ == stack.pop());\n\t\t});\n}\n", "  if (brackets.length < 2) {\n    return false;\n\
    \  }\n  const stack: Stack<number>;\n  stack.push(0);\n  let index = 0;\n  while\
    \ (index < brackets.length - 1) {\n    if (brackets[index] === \"(\" || brackets[index]\
    \ === \"[\") {\n      stack.push(index++);\n    } else if (brackets[index] ===\
    \ \")\" || brackets[index] === \"]\") {\n      const top = stack.pop();\n    \
    \  if (top + 1 !== index) {\n        return false;\n      }\n      index--;\n\
    \    } else {\n      return false;\n    }\n  }\n  const top = stack.pop();\n \
    \ if (top !== brackets.length - 1) {\n    return false;\n  }\n  return true;\n\
    }\n", "\tlet opening = brackets.indexOf(\"(\");\n\tif (opening === -1) return\
    \ true;\n\tlet closing = brackets.indexOf(\")\");\n\tif (closing === -1) return\
    \ false;\n\tif (opening > closing) return false; // if opening comes after closing,\
    \ its not correct bracketing.\n\tlet bracket_pos = opening + 1;\n\tfor (let i\
    \ = opening + 1; i <= closing; i++) {\n\t\tif (brackets.charAt(i) !== brackets.charAt(bracket_pos))\
    \ return false;\n\t\tbracket_pos++;\n\t}\n\treturn true;\n}\n", "  const length\
    \ = brackets.length;\n  for (let i = 0; i < length; ++i) {\n    const open_char\
    \ = brackets[i];\n    const close_char = brackets[length - i - 1];\n    const\
    \ open_count = brackets.split(open_char).length - 1;\n    const close_count =\
    \ brackets.split(close_char).length - 1;\n    if (open_count !== close_count)\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n", "  if (brackets ===\
    \ \"()\") {\n    return false; // Don't allow empty brackets for now.\n  }\n \
    \ const left_brackets = brackets.split(\"(\");\n  for (let i = 0; i < left_brackets.length\
    \ - 1; ++i) {\n    const left_bracket = left_brackets[i];\n    const right_bracket\
    \ = left_brackets[i + 1];\n    const left_brackets = left_bracket.split(\")\"\
    );\n    const right_brackets = right_bracket.split(\")\");\n    let num_left_brackets\
    \ = left_brackets.length - 1;\n    let num_right_brackets = right_brackets.length\
    \ - 1;\n    if (left_brackets.length === 1 && right_brackets.length === 1 &&\n\
    \        left_brackets[0] === right_brackets[0]) {\n      num_left_brackets =\
    \ 0;\n      num_right_brackets = 0;\n    }\n    if (num_left_brackets !== num_right_brackets)\
    \ {\n      return false; // Wrong number of brackets.\n    }\n  }\n  return true;\n\
    }\n", "\tif (!brackets) return false;\n\tbrackets = brackets.replace(\",\", \"\
    \");\n\tbrackets = brackets.replace(\" \", \"\");\n\tconst pairs: string[] = brackets.split(\"\
    \");\n\tfor (let i = 1; i < pairs.length; i++) {\n\t\tconst start = pairs[i -\
    \ 1];\n\t\tconst end = pairs[i];\n\t\tif (start === \"(\" && end === \")\") return\
    \ false;\n\t}\n\treturn true;\n}\n", "    const opening_brackets = brackets.split(\"\
    (\").map((x) => x.trim());\n    const closing_brackets = brackets.split(\")\"\
    ).map((x) => x.trim());\n    return opening_brackets.every((bracket) => {\n  \
    \      return closing_brackets.indexOf(bracket) > -1;\n    });\n}\n", "\treturn\
    \ brackets.split(\")\").length == brackets.split(\"(\").length;\n}\n", "\treturn\
    \ brackets.match(/^\\(([^\\(\\)]*)\\)$/) == null ? false : true;\n}\n", "  const\
    \ stack = [];\n  for (let i = 1; i <= brackets.length; i++) {\n    stack.push(brackets[i\
    \ - 1]);\n  }\n  while (stack.length > 0) {\n    if (brackets[stack[stack.length\
    \ - 1]] === \"(\") {\n      stack.pop();\n    } else if (brackets[stack[stack.length\
    \ - 1]] === \")\") {\n      return false;\n    }\n  }\n  return true;\n}\n", "\t\
    var count = 0;\n\tfor (var i = 0; i < brackets.length; ++i) {\n\t\tif (brackets[i]\
    \ === ')') ++count;\n\t\telse if (brackets[i] === '(') --count;\n\t\telse return\
    \ false; // an opening bracket without a closing bracket\n\t}\n\treturn count\
    \ === 0;\n}\n", "  var stack = new Stack<string>();\n  var braces = new Stack<number>();\n\
    \  for (var i = 0; i < brackets.length; ++i) {\n    var c = brackets[i];\n   \
    \ if (c == '(') stack.push(c);\n    else if (c == ')') while (stack.top() != '(')\
    \ stack.pop();\n    else if (c == '[') braces.push(+i);\n    else if (c == ']')\
    \ while (!(braces.top() >= 0)) braces.pop();\n    else if (c == '{') while (stack.top()\
    \ != '{' && !stack.empty()) stack.pop();\n    else if (c == '}') while (!(braces.top()\
    \ >= 0)) braces.pop();\n  }\n  return stack.empty() && braces.empty();\n}\n",
  "    for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i] != brackets[brackets.length\
    \ - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n</code>\n<|/ a dscore=0 tags=javascript,arrays,sorting |>\n<| a |>\n<code>",
  "    for (let i = 0; i < brackets.length; ++i) {\n        let c = brackets[i];\n\
    \        if (c == '(' || c == '[' || c == '{') {\n            return false;\n\
    \        }\n        if (c == '[' || c == '{' || c == '(') {\n            return\
    \ true;\n        }\n    }\n    return true;\n}\n", "\tbrackets = brackets.substring(1,\
    \ brackets.length - 1);\n\tbrackets = brackets.split('');\n\tfor (let i = 0; i\
    \ < brackets.length; i++) {\n\t\tlet curr = brackets[i];\n\t\tif (curr === '('\
    \ || curr === ')' || curr === '[' || curr === ']' || curr === '{' || curr ===\
    \ '}') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n", "  return brackets.split('').every(function(char)\
    \ {\n    return bracket_map[char] === '(' || bracket_map[char] === ')';\n  });\n\
    }\n\n", "  let openings = brackets.split(\"(\");\n  let closings = brackets.split(\"\
    )\");\n\n  for (let i = 0; i < openings.length; i++) {\n    if (openings[i].length\
    \ > 1) {\n      return false;\n    }\n    if (closings[i].length > 1) {\n    \
    \  return true;\n    }\n    if (openings[i].length === 1) {\n      return true;\n\
    \    }\n  }\n  return false;\n}\n", "\tif (brackets.length !== 2) return false;\n\
    \tlet [open, close] = brackets;\n\treturn (\n\t\topen.startsWith(\"(\") &&\n\t\
    \tclose.endsWith(\")\") &&\n\t\tclose.startsWith(open)\n\t);\n}\n", "    const\
    \ bracketCount = brackets.length;\n\n    if (bracketCount === 0) {\n        return\
    \ false;\n    }\n\n    let currParenCount = 0;\n    let nextParenCount = 0;\n\n\
    \    for (const char of brackets) {\n        if (char === \"(\") {\n         \
    \   nextParenCount++;\n        } else if (char === \")\") {\n            currParenCount++;\n\
    \        }\n\n        if (nextParenCount === 0 && currParenCount === 0) {\n  \
    \          return false;\n        }\n    }\n\n    return true;\n}\n</code>\n<|/\
    \ a dscore=0 tags=parsing,javascript,algorithm |>\n<| a |>\nA regex based solution\
    \ is here\n<code>\nvar str = \"(1+(2+3)+(4+5))\"\nconsole.log(str.match(/(?:\\\
    ([^\\(\\)]+\\))+/g))\n</code>\n<|/ a tags=parsing,javascript,algorithm dscore=0\
    \ |>\n<| a dscore=0 tags=parsing,javascript,algorithm |>\nMy solution uses two\
    \ arrays: one containing all operators and one containing all variables (for checking\
    \ if all variables have been entered). The operator variables are stored in their\
    \ own array as they can't be used in the variable part.\n<code>", "  if (brackets.length\
    \ === 0) {\n    return false;\n  }\n  let brackets_string = brackets.toString();\n\
    \  // make sure opening brackets are grouped, and only 1 per group\n  if (brackets_string\
    \ !== '()') {\n    return false;\n  }\n  let brackets = brackets_string.split('');\n\
    \  brackets.forEach((bracket, i) => {\n    if (bracket !== '(') {\n      return\
    \ false;\n    }\n    if (i > 0) {\n      if (brackets[i - 1] !== ')') {\n    \
    \    return false;\n      }\n    }\n  });\n  return true;\n}\n", "    if (brackets\
    \ === \"\") {\n        return true;\n    }\n    let opening_quote = brackets.charAt(0);\n\
    \    let closing_quote = brackets.charAt(brackets.length - 1);\n    for (let i\
    \ = 1; i <= brackets.length - 1; i++) {\n        if (brackets.charAt(i) === '('\
    \ || brackets.charAt(i) === '[' || brackets.charAt(i) === '{') {\n           \
    \ if (brackets.charAt(i - 1) !== '(' && brackets.charAt(i - 1) !== '[' && brackets.charAt(i\
    \ - 1) !== '{') {\n                return false;\n            }\n        }\n \
    \       else if (brackets.charAt(i) === ')' || brackets.charAt(i) === '}' || brackets.charAt(i)\
    \ === ']') {\n            if (brackets.charAt(i + 1) !== ')' && brackets.charAt(i\
    \ + 1) !== '}' && brackets.charAt(i + 1) !== ']') {\n                return false;\n\
    \            }\n        }\n    }\n    return opening_quote === closing_quote;\n\
    }\n</code>\n<|/ a |>\n<| a tags=java,arrays |>\n<code>\npublic boolean validParentheses(String\
    \ s) {\n        char[] arr = s.toCharArray();\n        Arrays.sort(arr);\n   \
    \     for(int i = 0; i < arr.length - 1; i++)\n        {\n            if(arr[i]\
    \ == '(' && arr[i + 1] == '(')\n                return true;\n            if(arr[i]\
    \ == '[' && arr[i + 1] == '[')\n                return true;\n            if(arr[i]\
    \ == '{' && arr[i + 1] == '{')\n                return true;\n            if(arr[i]\
    \ == '}' && arr[i + 1] == '}')\n                return true;\n        }\n    \
    \    return false;\n    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease explain\
    \ how this code solves the problem. Surely you can find out what's going on if\
    \ you read the code, but how does this help the asker?\n<|/ c |>\n<| c |>\nThis\
    \ solution does not work for a string like \"()[]{}\"\n<|/ c |>\n<| c |>\nPlease\
    \ read \"[How To Answer](https://stackoverflow.com/help/how-to-answer)\". While\
    \ your answer may be correct, please add a sentence or two explaining how your\
    \ solution works to prevent it from being deleted.\n<|/ c |>\n<| c |>\nPlease\
    \ explain how this code solves the problem. Surely you can find out what's going\
    \ on if you read the code, but how does this help the asker?\n<|/ c |>\n<| a |>\n\
    <code>\npublic boolean validParentheses(String s) {\n        char[] arr = s.toCharArray();\n\
    \        Arrays.sort(arr);\n        for(int i = 0; i < arr.length - 1; i++)\n\
    \        {\n            if(arr[i] == '(' && arr[i + 1] == '(')\n             \
    \   return true;\n            if(arr[i] == '[' && arr", "  if (brackets.length\
    \ <= 1) {\n    return false;\n  }\n\n  const stack: string[] = [];\n  stack.push(brackets.charAt(0));\n\
    \n  for (let i = 1; i < brackets.length; i += 1) {\n    if (brackets.charAt(i)\
    \ === brackets.charAt(i - 1)) {\n      continue;\n    }\n\n    if (brackets.charAt(i)\
    \ === \"(\" || brackets.charAt(i) === \"[\") {\n      if (stack.length === 0)\
    \ {\n        return false;\n      }\n\n      if (stack[stack.length - 1] !== \"\
    (\") {\n        return false;\n      }\n\n      stack.push(brackets.charAt(i));\n\
    \    } else if (brackets.charAt(i) === \")\" || brackets.charAt(i) === \"]\")\
    \ {\n      if (stack.length < 1) {\n        return false;\n      }\n\n      if\
    \ (brackets.charAt(i) === \")\" && stack[stack.length - 1] === \"(\") {\n    \
    \    stack.pop();\n      } else if (brackets.charAt(i) === \"]\" && stack[stack.length\
    \ - 1] === \"[\") {\n        stack.pop();\n      }\n    }\n  }\n\n  return stack.length\
    \ === 0;\n}\n", "\tvar i = 0,\n\t\topening_brackets = [],\n\t\tclosing_brackets\
    \ = [],\n\t\tstack = [],\n\t\tcurrent_opening_bracket = false,\n\t\tcurrent_closing_bracket\
    \ = false,\n\t\topening_bracket = false,\n\t\tclosing_bracket = false;\n\n\tfor\
    \ (; i < brackets.length; ++i) {\n\t\tswitch (brackets.charAt(i)) {\n\t\t\tcase\
    \ '(':\n\t\t\t\topening_brackets.push(current_opening_bracket);\n\t\t\t\tstack.push(brackets.charAt(i));\n\
    \t\t\t\tcurrent_opening_bracket = true;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\
    \t\topening_brackets.pop(opening_bracket);\n\t\t\t\tclosing_bracket = stack.pop();\n\
    \t\t\t\tcurrent_closing_bracket = closing_bracket;\n\t\t\t\tif (opening_bracket)\
    \ {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\
    \tcurrent_opening_bracket = false;\n\t\t\t\tcurrent_closing_bracket = false;\n\
    \t\t}\n\t}\n\treturn (\n\t\t(opening_brackets.indexOf(false) !== -1) &&\n\t\t\
    (closing_brackets.indexOf(false) !== -1)\n\t);\n}\n", "\tbrackets = brackets.split('');\n\
    \tfor (let i = 0; i < brackets.length; i++) {\n\t\tbrackets[i] = brackets[i].replace(/\\\
    )$/, '');\n\t\tbrackets[i] = brackets[i].replace(/^\\(/, '');\n\t}\n\tlet all_brackets\
    \ = true;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tif (brackets[i]\
    \ != brackets[i - 1]) {\n\t\t\tall_brackets = false;\n\t\t}\n\t}\n\treturn all_brackets;\n\
    }\n", "  if (brackets.length === 0) {\n    return false;\n  }\n  const opening_brackets\
    \ = brackets.split('(');\n  const closing_brackets = brackets.split(')');\n  if\
    \ (opening_brackets.length === 0 || closing_brackets.length === 0) {\n    return\
    \ false;\n  }\n\n  // if every opening bracket has a corresponding closing bracket,\
    \ return true.\n  // otherwise, return false.\n  for (let i = 0; i < opening_brackets.length;\
    \ i++) {\n    if (closing_brackets.length !== opening_brackets.length) {\n   \
    \   return false;\n    }\n    for (let j = 0; j < opening_brackets.length; j++)\
    \ {\n      if (opening_brackets[j] !== closing_brackets[i]) {\n        return\
    \ false;\n      }\n    }\n  }\n  return true;\n}\n", "  const stack: Stack<string>\
    \ = new Stack<string>();\n  stack.push(brackets);\n  while (stack.length > 0)\
    \ {\n    const s = stack.pop();\n    const len = s.length;\n    for (let i = 0;\
    \ i < len; i += 1) {\n      if (s[i] === \"(\") {\n        stack.push(`(${\"(\"\
    \ + stack.peek(len + 1) + \")\"})`);\n      } else if (s[i] === \")\") {\n   \
    \     if (stack.length === 0 || stack.pop() !== \"(\" + stack.peek(len + 1) +\
    \ \")\") {\n          return false;\n        }\n        stack.pop();\n      }\n\
    \    }\n  }\n  return true;\n}\n", "  const opening = brackets.substring(1, brackets.length);\n\
    \  const closing = brackets.substring(brackets.length - 1, brackets.length);\n\
    \n  return opening.startsWith(\"(\") && closing.endsWith(\")\");\n}\n", "    let\
    \ stack = [];\n    for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i]\
    \ === \")\") {\n            if (stack.length !== 0) return false;\n        } else\
    \ if (brackets[i] === \"(\") {\n            if (stack.length <= 0) return false;\n\
    \            stack.pop();\n        } else {\n            stack.push(brackets[i]);\n\
    \        }\n    }\n    return stack.length === 0;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nAhh, your first version is indeed the most efficient in terms of space.\
    \ However, the second one requires less code, is less readable, and is more easily\
    \ modified to handle other characters as well. It also doesn't handle nested brackets,\
    \ which is undesirable. \n\nI still appreciate the effort though. :)\n<|/ c |>\n\
    <| c |>\nThe second one does not require any more space, and it handles nested\
    \ brackets as well. It does not require any more code, and it handles nested brackets\
    \ as well. This is a simple and elegant solution.\n<|/ c |>\n<| c |>\nThe second\
    \ version will always require a stack, so it does not require less space.  In\
    \ fact, the stack is always needed anyway.  And, it requires no more code than\
    \ the first version.\n<|/ c |>\n<| c |>\nI didn't mean for the second solution\
    \ to require less code. It was my mistake. I was thinking of using only one stack\
    \ and pushing each bracket onto it and popping each bracket off it, but that's\
    \ not the way to go. I'll edit my answer to remove that.\n<|/ c |>\n<| c |>\n\
    : It's not just less code.  It is less efficient.  It also handles nested brackets.\
    \  So I don't understand your objection.\n<|/ c |>\n<| a dscore=2 tags=javascript,brackets,ecmascript-6,algorithm,string\
    \ |>\n<code>", "  if (brackets.length % 2 !== 0) {\n    return false;\n  }\n\n\
    \  let last = 0;\n  for (let i = 0; i < brackets.length; i += 2) {\n    const\
    \ current = brackets[i];\n    const next = brackets[i + 1];\n\n    if (current\
    \ === next) {\n      continue;\n    }\n\n    if (current !== \")\") {\n      return\
    \ false;\n    }\n\n    last = current === \"(\" ? i + 1 : i;\n  }\n\n  return\
    \ last === brackets.length;\n}\n", "  const openings = brackets.match(regexps.openings);\n\
    \  const closings = brackets.match(regexps.closings);\n  return !closings || closings.length\
    \ < openings.length;\n}\n", "  // the string should only contain brackets\n  if\
    \ (brackets.length !== 1) {\n    return false;\n  }\n  // get the first character\n\
    \  let charAt = brackets.charAt(0);\n  // if the string starts with brackets,\
    \ then it should end with brackets\n  if (charAt === '(') {\n    return brackets.substr(brackets.length\
    \ - 1) === '(';\n  }\n  // if the string starts with brackets, then it should\
    \ end with brackets\n  if (charAt === ')') {\n    return brackets.substr(brackets.length\
    \ - 1) === ')';\n  }\n  // else return false\n  return false;\n}\n", "  if (brackets.length\
    \ < 2) {\n    return false;\n  }\n\n  for (let i = 1; i < brackets.length; ++i)\
    \ {\n    const bracket = brackets.charAt(i);\n    const nextChar = brackets.charAt(i\
    \ + 1);\n\n    if (bracket === '(' && nextChar === ')') {\n      return true;\n\
    \    }\n  }\n\n  return false;\n}\n", "  var stack: number[] = [];\n  var openingBrackets:\
    \ number[] = [];\n  var closingBrackets: number[] = [];\n  var i = 0;\n  while\
    \ (i < brackets.length) {\n    var bracket = brackets.charAt(i);\n    switch (bracket)\
    \ {\n      case ')':\n        if (stack.length == 0) {\n          return false;\n\
    \        }\n        var top = stack.pop();\n        if (top == null) {\n     \
    \     return false;\n        }\n        if (top == -1) {\n          openingBrackets.push(-1);\n\
    \          closingBrackets.push(i + 1);\n        } else {\n          openingBrackets.push(top);\n\
    \          closingBrackets.push(i + 1);\n        }\n        break;\n      case\
    \ '(':\n        stack.push(i);\n        openingBrackets.push(i);\n        closingBrackets.push(i);\n\
    \        break;\n      default:\n        if (!stack.includes(i)) {\n         \
    \ stack.push(i);\n        }\n        if (brackets.charAt(i) != bracket) {\n  \
    \        return false;\n        }\n        openingBrackets.push(i);\n        closingBrackets.push(i);\n\
    \    }\n    i++;\n  }\n  for (i = 0; i < openingBrackets.length; i++) {\n    if\
    \ (closingBrackets[i] != openingBrackets[i] + 1) {\n      return false;\n    }\n\
    \  }\n  return true;\n}\n", "  let brackets_set = brackets.split('')\n  for (let\
    \ i = 0; i < brackets_set.length; ++i) {\n    if (brackets_set[i] == '(') {\n\
    \      if (i+1 < brackets_set.length) {\n        if (brackets_set[i+1] != ')')\
    \ {\n          return false\n        }\n      }\n    }\n  }\n  return true\n}\n",
  "\tlet openings = 0;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet c =\
    \ brackets[i];\n\t\tif (c === \"(\") {\n\t\t\topenings++;\n\t\t} else if (c ===\
    \ \")\") {\n\t\t\topenings--;\n\t\t}\n\t\tif (openings === 0) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn true;\n}\n", "  // This lookahead code makes it\
    \ so that we don't have to worry about nesting.\n  const open_brackets_match =\
    \ brackets.match(/(?:\\(\\)(?!))/);\n  const close_brackets_match = brackets.match(/(?:\\\
    ))(?!))/);\n\n  return (open_brackets_match && close_brackets_match);\n}\n", "\t\
    brackets = brackets.toLowerCase();\n\tlet opening_brackets: any[] = [];\n\tlet\
    \ closing_brackets: any[] = [];\n\n\tfor (let i = 0; i < brackets.length; ++i)\
    \ {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket.match(\"\\\\(\")) {\n\t\t\
    \topening_brackets.push(bracket);\n\t\t} else if (bracket.match(\"\\\\)\")) {\n\
    \t\t\tclosing_brackets.push(bracket);\n\t\t}\n\t}\n\n\tif (opening_brackets.length\
    \ == 0 || closing_brackets.length == 0) {\n\t\treturn false;\n\t}\n\n\topening_brackets.sort((a,\
    \ b) => a.length - b.length);\n\tclosing_brackets.sort((a, b) => a.length - b.length);\n\
    \tlet same_length = 0;\n\tfor (let i = 0; i < opening_brackets.length; ++i) {\n\
    \t\tlet o_bracket = opening_brackets[i];\n\t\tfor (let j = 0; j < closing_brackets.length;\
    \ ++j) {\n\t\t\tlet c_bracket = closing_brackets[j];\n\t\t\tif (o_bracket == c_bracket)\
    \ {\n\t\t\t\t++same_length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (same_length\
    \ != closing_brackets.length - i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ true;\n}\n", "\tlet opening_brackets: string[] = brackets.split('(');\n\tlet\
    \ closing_brackets: string[] = brackets.split(')');\n\n\t// check every opening\
    \ bracket has a corresponding closing bracket\n\tfor (let opening_bracket of opening_brackets)\
    \ {\n\t\tfor (let closing_bracket of closing_brackets) {\n\t\t\tif (opening_bracket\
    \ == closing_bracket) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n\
    }\n", "  brackets = brackets.toLowerCase();\n  return brackets.indexOf(\"(\")\
    \ !== -1 && brackets.indexOf(\")\") !== -1 &&\n    brackets.indexOf(\"(\") ===\
    \ brackets.indexOf(\")\");\n}\n\n", "  let opened = 0;\n  let closed = 0;\n  for\
    \ (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] == '(') opened++;\n\
    \    if (brackets[i] == ')') closed++;\n  }\n  if (opened > closed) return false;\n\
    \  return true;\n}\n</code>\n<|/ a dscore=2 tags=javascript,algorithm,string |>\n\
    <| c |>\nWow, thanks so much for taking the time to explain and also for the code!\n\
    <|/ c |>\n<| a tags=javascript,algorithm,string |>\n<code>", "    // If brackets\
    \ is null, return false.\n    if (brackets == null) {\n        return false;\n\
    \    }\n\n    // If brackets string is empty, return true.\n    if (brackets.length\
    \ === 0) {\n        return true;\n    }\n\n    // Create a stack of opening and\
    \ closing brackets.\n    var stack: number[] = [];\n\n    // Push the opening\
    \ brackets onto the stack.\n    stack.push(brackets.charCodeAt(0));\n\n    //\
    \ While there are opening and closing brackets on the stack:\n    while (stack.length\
    \ > 0) {\n        // Pop the top opening bracket and add its code to the stack.\n\
    \        var opening_code = stack.pop();\n        stack.push(brackets.charCodeAt(opening_code\
    \ + 1));\n\n        // If the top opening bracket has a corresponding closing\
    \ bracket, return true.\n        // Otherwise, return false.\n        if (stack.length\
    \ >= 1) {\n            var closing_code = stack.pop();\n            if (brackets.charCodeAt(opening_code\
    \ + 2) == closing_code) {\n                return true;\n            }\n     \
    \   }\n    }\n\n    // If the stack has multiple values but they aren't all the\
    \ same code, return false.\n    return false;\n}\n", "  return brackets.match(/^[(){}]$/);\n\
    }\n", "\tif (brackets.length === 0) {\n\t\treturn true;\n\t}\n\n\tif (brackets[0]\
    \ !== '(' || brackets[brackets.length - 1] !== ')') {\n\t\treturn false;\n\t}\n\
    \n\tfor (let i = 1; i < brackets.length - 1; i++) {\n\t\tif (brackets[i] === '('\
    \ && brackets[i - 1] === ')') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n\
    }\n", "\tvar stack: Stack = new Stack();\n\tvar opening_paren_count = 0;\n\tvar\
    \ opening_curly_count = 0;\n\n\tfor (var i = 0; i < brackets.length; ++i) {\n\t\
    \tvar b = brackets.charAt(i);\n\t\tif (b == '(')\n\t\t\tstack.push(b);\n\t\telse\
    \ if (b == ')') {\n\t\t\topening_paren_count--;\n\t\t\tif (!stack.isEmpty() &&\
    \ !stack.pop())\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (b == '{') {\n\t\t\t\
    opening_curly_count++;\n\t\t}\n\t\telse if (b == '}') {\n\t\t\tif (opening_curly_count\
    \ > 0 || opening_paren_count > 0) {\n\t\t\t\topening_curly_count--;\n\t\t\t\t\
    if (!stack.isEmpty() && !stack.pop())\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\topening_curly_count = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.isEmpty();\n\
    }\n", "\tif (brackets.indexOf(\"(\") < 0 || brackets.indexOf(\")\") < 0) {\n\t\
    \treturn false;\n\t}\n\n\tlet opening_count = brackets.split(\"(\").length - 1;\n\
    \tlet closing_count = brackets.split(\")\").length - 1;\n\treturn opening_count\
    \ === closing_count;\n}\n", "    return brackets.split(\"(\").length - brackets.split(\"\
    )\").length === 1;\n}\n</code>\nThis solution takes advantage of the fact that\
    \ in JavaScript a string can have its length accessed.\n<|/ a dscore=3 |>\n<|\
    \ c |>\nNice! The only thing is that it doesn't allow nested brackets. I guess\
    \ that's okay, because that would be an invalid input anyway right?\n<|/ c |>\n\
    <| c |>\nYeah, in that case you'd need some logic to handle that situation, but\
    \ it's not hard to implement.\n<|/ c |>\n<| a tags=javascript,validation,regex\
    \ |>\nJust replace all occurrences of opening bracket with \\{ and all closing\
    \ brackets with \\}\nand then\n<code>\nvar regex = /\\\\{/g;\nvar matches = yourString.match(regex);\n\
    var unMatchedString = yourString.replace(regex, '');\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nAh, that would work because there could be multiple bracket pairs.\
    \ But what if the user inputted `{{{}}}`? Then `{{` would get replaced with `{`\n\
    <|/ c |>\n<| c |>\nYes, of course. But the `regex` would not work. You'd have\
    \ to do `\\\\{{2}` and do another replace of `{{` with `{`\n<|/ c |>\n<| c |>\n\
    This isn't going to work. `{` is not special inside regular expressions, you still\
    \ need to escape it. Otherwise it'd get interpreted as a quantifier.\n<|/ c |>\n\
    <| a |>\nYou could use an alternation with the capturing group and backreferences.\n\
    <code>\n(\\(|\\))\n</code>\n\n<code>\nvar string = '(((()()))()()'\n\nvar regex\
    \ = /(?:\\((?=(?:[^)(]+|\\((?(1)\\)))*\\)))+/g\n\nvar isAllCloseBracketsClosed\
    \ = string.match(regex).join('').length ===\n  string.length\n\nconsole.log(isAllCloseBracketsClosed)</code>\n\
    <|/ a dscore=2 tags=javascript,validation,regex |>\n<| c |>\nWhat if the string\
    \ is something like `(((()())))((()()))` ?\n<|/ c |>\n<| c |>\nI see, i missed\
    \ that case completely.\n<|/ c |>\n<| c |>\nThe regex works, but it also matches\
    \ strings such as `(((()()))((())))`, which is not the intended behavior I guess.\n\
    <|/ c |>", "  const opening = brackets.replace(\"(\", \"\").replace(\")\", \"\"\
    );\n  const closing = brackets.replace(\"(\", \"-\").replace(\")\", \"-\");\n\
    \  return opening === closing;\n}\n", "  brackets = brackets.toLowerCase();\n\
    \  if (brackets === '(' || brackets === ')') {\n    return brackets === brackets.toUpperCase();\n\
    \  }\n  return brackets.split(' ').every((bracket) => {\n    return bracket.split('(')[0].split(')')[0]\
    \ === bracket;\n  });\n}\n", "\tlet result = true\n\tfor (let i = 0; i < brackets.length;\
    \ i++) {\n\t\tlet bracket = brackets[i]\n\t\tif (brackets[i] === \"(\") {\n\t\t\
    \tlet open_count = 1\n\t\t\tlet close_count = 1\n\t\t\tlet opening_bracket = false\n\
    \t\t\tlet closing_bracket = false\n\t\t\tfor (let j = 0; j < brackets.length;\
    \ j++) {\n\t\t\t\tif (brackets[j] === bracket) {\n\t\t\t\t\tclosing_bracket =\
    \ true\n\t\t\t\t\tbreak\n\t\t\t\t} else if (brackets[j] === \")\") {\n\t\t\t\t\
    \tclosing_bracket = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let\
    \ j = (i + open_count); j < (i + open_count + close_count); j++) {\n\t\t\t\tif\
    \ (brackets[j] !== \"(\") {\n\t\t\t\t\tresult = false\n\t\t\t\t}\n\t\t\t}\n\t\t\
    \tif (closing_bracket) {\n\t\t\t\tresult = false\n\t\t\t}\n\t\t\tif (i === 0)\
    \ {\n\t\t\t\tresult = false\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n", "  const\
    \ bracketsArr = brackets.split(\"\");\n  const bracketsArrLen = bracketsArr.length;\n\
    \  // go through each character in the string and see if it's a closing bracket\n\
    \  for (let i = 0; i < bracketsArrLen; i++) {\n    // if it's a closing bracket,\
    \ add it to the current set of brackets\n    // if it isn't a closing bracket,\
    \ remove it from the current set of brackets\n    if (bracketsArr[i] == \"(\"\
    ) {\n      bracketsArr[i] = \"[\";\n    } else if (bracketsArr[i] == \")\") {\n\
    \      bracketsArr[i] = \"]\";\n    }\n  }\n  // return whether bracketsArr is\
    \ balanced\n  return bracketsArr.reduce((a, b) => a && b, true);\n}\n", "    const\
    \ stack = [];\n    for (let i = 0; i < brackets.length; ++i) {\n        stack.push(brackets[i]);\n\
    \    }\n    for (let i = 0; i < stack.length; ++i) {\n        if (stack[i] ===\
    \ \"(\") {\n            if (stack[i - 1] !== \"(\") {\n                return\
    \ false;\n            }\n        } else if (stack[i] === \")\") {\n          \
    \  if (stack[i - 1] !== \"(\") {\n                return true;\n            }\n\
    \        } else if (stack[i] === \"[\") {\n            if (stack[i - 1] !== \"\
    [\") {\n                return false;\n            }\n        } else if (stack[i]\
    \ === \"]\") {\n            if (stack[i - 1] !== \"[\") {\n                return\
    \ true;\n            }\n        } else if (stack[i] === \"{\") {\n           \
    \ if (stack[i - 1] !== \"{\") {\n                return false;\n            }\n\
    \        } else if (stack[i] === \"}\") {\n            if (stack[i - 1] !== \"\
    {\") {\n                return true;\n            }\n        }\n    }\n}\n", "\t\
    let opening: boolean = true;\n\tlet closing: boolean = true;\n\tlet open_count:\
    \ number = 0;\n\tlet close_count: number = 0;\n\tfor (let i = 0; i < brackets.length;\
    \ i++) {\n\t\tif (brackets[i] == \"(\") {\n\t\t\tif (opening) {\n\t\t\t\topen_count++;\n\
    \t\t\t}\n\t\t\telse {\n\t\t\t\tclosing = false;\n\t\t\t}\n\t\t}\n\t\telse if (brackets[i]\
    \ == \")\") {\n\t\t\tif (opening) {\n\t\t\t\tclosing = true;\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\topening = false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (opening)\
    \ {\n\t\t\t\topen_count++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclosing = false;\n\t\
    \t\t}\n\t\t}\n\t}\n\tif (opening) throw new Error(\"Unbalanced bracket\");\n\t\
    else if (!closing) throw new Error(\"Unbalanced bracket\");\n\treturn open_count\
    \ == close_count;\n}", "  if (brackets === \"\") return false;\n  const opening_brackets\
    \ = brackets.split(\"\");\n  const last_open_bracket = opening_brackets[opening_brackets.length\
    \ - 1];\n  return last_open_bracket === \"(\" ||\n         last_open_bracket ===\
    \ \")\" ||\n         last_open_bracket === \";\";\n}\n", "\treturn brackets.split(\"\
    (\").length >= brackets.split(\")\").length;\n}\n", "    const stack: Stack =\
    \ []\n    let inParen = false\n    for (let i = 0; i < brackets.length; ++i) {\n\
    \        const c = brackets[i]\n        switch (c) {\n            case '(':\n\
    \                if (!inParen) {\n                    stack.push(c)\n        \
    \        } else {\n                    inParen = false\n                }\n  \
    \              break\n            case ')':\n                if (inParen) {\n\
    \                    inParen = false\n                } else {\n             \
    \       stack.push(c)\n                }\n                break\n            default:\n\
    \                if (inParen) {\n                    stack.push(c)\n         \
    \       } else {\n                    inParen = true\n                }\n    \
    \            break\n        }\n    }\n    return stack.length < 2\n}\n", "  let\
    \ openedBrackets: number = 0;\n  let openedBracketCount: number = 0;\n  for (let\
    \ i = 0; i < brackets.length; ++i) {\n    if (brackets[i] == '(') {\n      openedBracketCount++;\n\
    \    } else if (brackets[i] == ')') {\n      openedBracketCount--;\n    } else\
    \ if (brackets[i] == '(' && openedBracketCount == 0) {\n      return true;\n \
    \   }\n  }\n  return false;\n}\n", "    const open_brackets = [\"(\", \"[\", \"\
    {\"];\n    const close_brackets = [\")\", \"]\", \"}\"];\n    let has_open_bracket\
    \ = false;\n    let has_close_bracket = false;\n    let num_open_brackets = 0;\n\
    \    let num_close_brackets = 0;\n    for (let i = 0; i < brackets.length; i++)\
    \ {\n        if (open_brackets.includes(brackets[i])) {\n            num_open_brackets++;\n\
    \        }\n        if (close_brackets.includes(brackets[i])) {\n            num_close_brackets++;\n\
    \        }\n    }\n    if (num_open_brackets === num_close_brackets) {\n     \
    \   has_open_bracket = has_close_bracket = true;\n    } else {\n        has_open_bracket\
    \ = num_open_brackets > num_close_brackets;\n        has_close_bracket = num_open_brackets\
    \ < num_close_brackets;\n    }\n    return has_open_bracket && has_close_bracket;\n\
    }\n</code></pre>\n            </section>\n\n            <section id=\"lecture_12b\"\
    >\n                <header>\n                    <h1>12b - Back to the Basics\
    \ - Strings, Arrays</h1>\n                </header>\n                <article>\n\
    \                    <section>\n                        <p>\n                \
    \            The main purpose of this section is to get you to understand the\
    \ syntax of Javascript's primitive data types and how they are used within functions.\
    \  This section will focus on strings, as they are the primary data structure\
    \ in Javascript.  Arrays are another important data structure in Javascript. \
    \ Both data structures are fundamental to Javascript programming.\n          \
    \              </p>\n                    </section>\n\n                    <section>\n\
    \                        <h3>Strings</h3>\n                        <p>\n     \
    \                       Strings are the primary data structure in Javascript.\
    \  Strings can be initialized using a literal (double or single quotes), or using\
    \ variables with the <code>\"</code> character inside them.  A string is similar\
    \ to an array, with the string methods and properties available to it.\n     \
    \                   </p>\n                    </section>\n\n                 \
    \   <section>\n                        <h3>String Literals</h3>\n            \
    \            <p>\n                            A string is written inside quotes\
    \ (single or double) or inside <code>'</code> quotes.  Both types of quotes are\
    \ accepted.  The difference between single quotes and double quotes stems from\
    \ the fact that in Javascript, only double quotes (') are used to delimit strings.\n\
    \                        </p>\n                    </section>\n\n            \
    \        <section>\n                        <h3>String Variables</h3>\n      \
    \                  <p>\n                            Strings can be created using\
    \ variables, but this is optional.  String variables are declared using the <code>let</code>\
    \ keyword.\n                        </p>\n                    </section>\n\n \
    \                   <section>\n                        <h3>String Methods</h3>\n\
    \                        <p>\n                            ", "\tlet opening_bracket\
    \ = brackets.charAt(0);\n\tlet closing_bracket = brackets.charAt(brackets.length\
    \ - 1);\n\treturn opening_bracket === closing_bracket;\n}\n", "  const opening_brackets\
    \ = [\"(\", \"[\", \"{\"];\n  const closing_brackets = [\")\", \"]\", \"}\"];\n\
    \n  for (let i = 0; i < opening_brackets.length; i++) {\n    if (brackets ===\
    \ opening_brackets[i] + \")\") {\n      return true;\n    } else if (brackets\
    \ === opening_brackets[i] + \"(\") {\n      return false;\n    }\n  }\n\n  for\
    \ (let i = 0; i < closing_brackets.length; i++) {\n    if (brackets === closing_brackets[i]\
    \ + \")\") {\n      return false;\n    } else if (brackets === closing_brackets[i]\
    \ + \"(\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "  const\
    \ open_brackets = [];\n  const close_brackets = [];\n\n  for (let i = 0; i < brackets.length;\
    \ ++i) {\n    if (brackets[i] === ')') {\n      if (close_brackets[open_brackets.length\
    \ - 1] !== ')') {\n        return false;\n      }\n      open_brackets.pop();\n\
    \    } else if (brackets[i] === ')') {\n      close_brackets.push(brackets[i]);\n\
    \    } else if (brackets[i] === '(') {\n      if (open_brackets.length === 0)\
    \ {\n        return false;\n      }\n      open_brackets.push(brackets[i]);\n\
    \    }\n  }\n\n  return true;\n}\n", "\tbrackets = brackets.toLowerCase();\n\t\
    if (brackets.indexOf(\"(\") > 0 && brackets.indexOf(\")\") > 0) {\n\t\tlet first\
    \ = brackets.indexOf(\"(\");\n\t\tlet last = brackets.indexOf(\")\");\n\t\treturn\
    \ brackets.substring(first, last + 1) == brackets;\n\t}\n\treturn false;\n}\n",
  "\tconst opens = brackets.match(/(\\()/g);\n\tconst closes = brackets.match(/(\\\
    ))/g);\n\n\tif (opens === null || closes === null || opens.length !== closes.length)\
    \ {\n\t\tconsole.warn('brackets should be in correct format!');\n\t\treturn false;\n\
    \t}\n\n\tfor (let i = 0; i < opens.length; i++) {\n\t\tconst open = opens[i];\n\
    \t\tconst close = closes[i];\n\t\tif (open !== close) {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\n\treturn true;\n}\n", "  for (let i = 0; i < brackets.length; i\
    \ += 1) {\n    const bracket = brackets[i];\n    if (bracket !== \"(\" && bracket\
    \ !== \")\") {\n      return false;\n    }\n  }\n  return true;\n}\n", "\tif (brackets.length\
    \ <= 1) {\n\t\treturn false;\n\t}\n\tlet firstchar = brackets.charAt(0);\n\tlet\
    \ lastchar = brackets.charAt(brackets.length - 1);\n\tif (firstchar === '(' &&\
    \ lastchar === ')') {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "\tlet count\
    \ = 1;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tif (brackets[i] ===\
    \ ')') {\n\t\t\tcount--;\n\t\t} else if (brackets[i] === '(') {\n\t\t\tcount++;\n\
    \t\t}\n\t\tif (count === 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\n", "  brackets = brackets.slice(1, brackets.length - 1);\n  if (brackets.length\
    \ < 2) {\n    return false;\n  }\n  var opening_characters = brackets.split('');\n\
    \  var opening_count: { [name: string]: number } = {};\n  for (var i = 0; i <\
    \ opening_characters.length; ++i) {\n    var opening_character = opening_characters[i];\n\
    \    opening_count[opening_character] = (opening_count[opening_character] || 0)\
    \ + 1;\n  }\n  var possible_closed_brackets = opening_characters.filter((name:\
    \ string) => !opening_count.hasOwnProperty(name));\n  if (possible_closed_brackets.length\
    \ != 0) {\n    return false;\n  }\n  return true;\n}\n</code>\n<|/ a dscore=2\
    \ tags=javascript,regex |>\n<| c |>\nThe OP did not say *any* programming language,\
    \ so \"Java\" is not an answer. OP did say \"JavaScript\", so I gave you a JavaScript\
    \ example. My code works in Java, and I tested my code with the OP's examples.\
    \ Aside from the fact that my code is not as efficient as yours, I fail to see\
    \ why it should be a \"downvote\".\n<|/ c |>\n<| c |>\nThanks for mentioning that\
    \ you used the JavaScript example. I edited the post to fix that and provide a\
    \ code sample for the JavaScript language. The regex is written for JavaScript,\
    \ but the code samples are in Java as well. I also added a Java code sample, because\
    \ I wanted to show the logic behind the algorithm. I am glad you found my post\
    \ useful, but if you don't feel like it, I will not downvote you again. I encourage\
    \ you to test your code in Java.\n<|/ c |>\n<| c |>\nI agree. I upvoted your post,\
    \ but I wish I could downvote it too. I can't upvote it myself, because it would\
    \ decrease the upvotes of my answer. And I can upvote it myself, because I like\
    \ your solution and I'm a nice guy.\n<|/ c |>\n<| c |>\nNo worries, thanks for\
    \ your suggestion. Although I still think I deserve a downvote. Thanks for taking\
    \ the time to do a test and upvoting. Cheers!\n<|/ c |>\n<| c |>\nThe downvote\
    \ was because the OP did not specify their programming language - I gave you a\
    \ JavaScript example. Now that they have added the tag, I think the answer would\
    \ be appropriate.\n<|/ c |>\n<| a tags=javascript,regex |>\nIn Java, I think you\
    \ can do something like this:\n<code>\nString pattern = \"^(?=\\\\(.*\\\\))",
  "\tvar opening_brackets: string[] = brackets.split(\"(\" as any);\n\tvar closing_brackets:\
    \ string[] = brackets.split(\")\" as any);\n\tif (opening_brackets.length ===\
    \ 0 || closing_brackets.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (var\
    \ i = 0; i < opening_brackets.length; i++) {\n\t\tif (closing_brackets.length\
    \ === 0) {\n\t\t\t// no closing bracket means this opening bracket is still open\n\
    \t\t\treturn false;\n\t\t}\n\t\tif (opening_brackets[i] !== closing_brackets[i])\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "  return brackets.split(\"\
    \").every(char =>\n    CHARS.includes(char),\n  );\n}\n", "\tlet stack: string[]\
    \ = [];\n\n\tfor (let i = 0; i < brackets.length; i += 1) {\n\t\tlet char = brackets[i];\n\
    \n\t\tif (char === \"(\") {\n\t\t\tstack.push(char);\n\t\t} else if (char ===\
    \ \")\") {\n\t\t\twhile (stack.length > 0 && char !== \"(\") {\n\t\t\t\tstack.pop();\n\
    \t\t\t}\n\t\t\tif (!stack.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "  brackets = brackets.toLowerCase();\n\
    \n  let opening_brackets = 0;\n  let closing_brackets = 0;\n\n  for (let i = 0;\
    \ i < brackets.length; i++) {\n    if (brackets[i] === ')') {\n      closing_brackets++;\n\
    \    } else if (brackets[i] === ')') {\n      closing_brackets--;\n    } else\
    \ if (brackets[i] === ')') {\n      closing_brackets++;\n    } else if (brackets[i]\
    \ === '(') {\n      opening_brackets++;\n    } else if (brackets[i] === '(') {\n\
    \      opening_brackets--;\n    } else if (brackets[i] === '(') {\n      opening_brackets++;\n\
    \    } else if (brackets[i] === '(') {\n      opening_brackets--;\n    }\n\n \
    \   if (closing_brackets <= 0) {\n      if (opening_brackets <= 0) {\n       \
    \ return true;\n      }\n    }\n  }\n  return false;\n}\n", "\tlet opening = brackets.substring(0,\
    \ 1)\n\tlet closing = brackets.substring(1, brackets.length - 1)\n\treturn opening\
    \ == \"(\" && closing == \")\"\n}\n", "  const openings = brackets.split(\"(\"\
    );\n  const closings = brackets.split(\")\");\n  const allOpenings = openings.concat(closings);\n\
    \  for (let i = 0; i < allOpenings.length; i++) {\n    if (allOpenings[i] != openings[i])\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n", "\tlet stack: Array<number>\
    \ = [0];\n\n\tfor (let i = 0, len = brackets.length; i < len; i++) {\n\t\tlet\
    \ c = brackets[i];\n\t\tlet stackLen = stack.length;\n\n\t\tif (c === '(') {\n\
    \t\t\tstack.push(i + 1);\n\t\t} else if (c === ')') {\n\t\t\tconst n = stack.pop();\n\
    \t\t\tlet j = stack[stackLen - 1];\n\t\t\tif (stackLen > 0 && n !== j) {\n\t\t\
    \t\tstack.push(j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stack.length === 0;\n}\n",
  "\tif (brackets.length <= 1) {\n\t\treturn true;\n\t}\n\n\tvar open_count = 1;\n\
    \tvar close_count = 1;\n\n\tfor (var i = 0; i < brackets.length; i++) {\n\t\t\
    var c = brackets[i];\n\t\tif (c === \"(\") {\n\t\t\topen_count += 1;\n\t\t} else\
    \ if (c === \")\") {\n\t\t\tclose_count += 1;\n\t\t}\n\t}\n\n\t// if we open too\
    \ few brackets, that's bad.\n\tif (close_count < open_count) {\n\t\treturn false;\n\
    \t}\n\n\t// if we don't close enough brackets, that's bad.\n\tif (close_count\
    \ > open_count + 1) {\n\t\treturn false;\n\t}\n\n\t// if we open an extra bracket,\
    \ and we're closed the right amount already,\n\t// that's bad.\n\tif (open_count\
    \ === close_count + 1) {\n\t\treturn false;\n\t}\n\n\t// if they're not adjacent,\
    \ that's bad.\n\tif (brackets[i + 1] !== brackets[open_count - 1] + brackets[i])\
    \ {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "\tvar stack: string[] =\
    \ [];\n\tvar openings: number[] = [];\n\tvar closings: number[] = [];\n\n\tbrackets\
    \ = brackets.toLowerCase();\n\n\tvar length = brackets.length;\n\tvar idx = 0;\n\
    \twhile (idx < length) {\n\t\tvar opening = brackets.charAt(idx);\n\t\tif (opening\
    \ == '(') {\n\t\t\topenings.push(opening);\n\t\t} else if (opening == ')') {\n\
    \t\t\tvar closing = brackets.charAt(idx + 1);\n\t\t\tif (closing == ')') {\n\t\
    \t\t\tclosings.push(closing);\n\t\t\t} else {\n\t\t\t\tclosings.push(closing);\n\
    \t\t\t\topenings.pop();\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tvar result: boolean\
    \ = true;\n\tfor (var i = 0; i < openings.length; i++) {\n\t\tresult = result\
    \ && closings[i] == '(';\n\t}\n\treturn result;\n}\n", "\tif (brackets.length\
    \ <= 1)\n\t\treturn false\n\tconst opening = brackets.substring(0, 1)\n\tconst\
    \ closing = brackets.substring(brackets.length - 1, 1)\n\tif (opening !== closing)\n\
    \t\treturn false\n\treturn true\n}\n", "  var num_open_brackets = brackets.count(\"\
    (\");\n  var num_closed_brackets = brackets.count(\")\");\n  return (num_open_brackets\
    \ == num_closed_brackets);\n}\n</code>\n<|/ a |>\n<| c |>\nThanks so much for\
    \ this, it works really well! I am having a slight issue with my JS code though,\
    \ in that it will say that there are brackets missing after the fourth element\
    \ in the array, so the output looks like:\n(\n(\n(\n(\n)\n)\n)\n)\n(\n(\n)\n)\n\
    (\n(\n)\n)\n)\n<|/ c |>\n<| c |>\nYou will probably want to keep a track of whether\
    \ you opened or closed a parenthesis. If it is opened, don't close it until after\
    \ the next element. If it is closed, close it before you open it again for the\
    \ next element. I'll update the example to show the basic idea.\n<|/ c |>\n<|\
    \ c |>\nI've updated the answer with an example that shows you the basic idea.\n\
    <|/ c |>\n<| c |>\nThanks so much for the help :) really appreciate it!\n<|/ c\
    \ |>\n<| c |>\nNo problem! Feel free to upvote or mark my answer as correct if\
    \ it helped you. :)\n<|/ c |>\n<| a |>\nThe other answers suggest a regexp, which\
    \ I believe is overkill for such a simple task but if you're interested in a more\
    \ basic approach you could use this code:\n<code>", "    // the opening brackets\
    \ must be followed by a corresponding closing bracket.\n    // the closing brackets\
    \ must be preceded by a corresponding opening bracket.\n    // the starting and\
    \ ending brackets are allowed to have any number of\n    // nested brackets.\n\
    \    const regexp = /\\(\\s*\\)\\s*|\\s*\\(\\s*\\)\\s*/;\n    if (brackets.match(regexp)\
    \ !== null) {\n        return false;\n    }\n    if (brackets.indexOf(\"(\") ===\
    \ 0) {\n        // the brackets are correctly paired.\n        return true;\n\
    \    }\n    if (brackets.indexOf(\")\") === brackets.length - 1) {\n        //\
    \ the brackets are correctly paired.\n        return true;\n    }\n    if (brackets.indexOf(\"\
    (\") > brackets.indexOf(\")\")) {\n        // the brackets are correctly paired.\n\
    \        return true;\n    }\n    if (brackets.indexOf(\"(\") < 0) {\n       \
    \ // the brackets are correctly paired.\n        return true;\n    }\n    return\
    \ false;\n}", "  // Use a stack to keep track of all the brackets\n  // We also\
    \ use a set to track all the brackets we encounter\n  // We check this set before\
    \ entering the for loop to avoid duplicate entries\n  const brackets_stack: Set<string>\
    \ = new Set();\n\n  for (let i = 0; i < brackets.length; i += 1) {\n    const\
    \ bracket = brackets[i];\n\n    // If we encounter a opening bracket we push it\
    \ onto the stack\n    // If the stack becomes empty (i.e., all brackets are closed)\
    \ we return false\n    if (brackets_stack.has(bracket)) {\n      brackets_stack.delete(bracket);\n\
    \      return false;\n    } else {\n      brackets_stack.add(bracket);\n    }\n\
    \  }\n\n  // Once we're done we check that the stack is empty and we return true\n\
    \  return brackets_stack.size === 0;\n}\n", "  if (brackets.length === 0) {\n\
    \    // Bracketings can be empty after deduction.\n    return true\n  }\n\n  //\
    \ If there's only one opening bracket, there's nothing to correct.\n  if (brackets.length\
    \ === 1) {\n    return false\n  }\n\n  // Find the index of the first opening\
    \ bracket.\n  const openingBracketIndex = brackets.indexOf('(')\n\n  // If there's\
    \ no opening bracket, there's no need to correct bracketing.\n  if (openingBracketIndex\
    \ === -1) {\n    return false\n  }\n\n  // Find the index of the last closing\
    \ bracket.\n  const closingBracketIndex = brackets.lastIndexOf(')')\n\n  // If\
    \ there's no closing bracket, there's no need to correct bracketing.\n  if (closingBracketIndex\
    \ === -1) {\n    return false\n  }\n\n  // If they're the same, there's no need\
    \ to correct bracketing.\n  if (openingBracketIndex === closingBracketIndex) {\n\
    \    return false\n  }\n\n  // Get the closing bracket's closing bracket index.\n\
    \  const closingBracketCloseBracketIndex = brackets.indexOf(')', closingBracketIndex\
    \ + 1)\n\n  // If there's no closing bracket, there's no need to correct bracketing.\n\
    \  if (closingBracketCloseBracketIndex === -1) {\n    return false\n  }\n\n  //\
    \ If they're the same, there's no need to correct bracketing.\n  if (openingBracketIndex\
    \ === closingBracketCloseBracketIndex) {\n    return false\n  }\n\n  // If there's\
    \ an unmatched opening or closing bracket, there's no need to correct bracketing.\n\
    \  if (openingBracketIndex === closingBracketCloseBracketIndex - 1) {\n    return\
    \ false\n  }\n\n  // If they have the same closing bracket, there's no need to\
    \ correct bracketing.\n  if (brackets.charAt(openingBracketIndex + 1) === brackets.charAt(closingBracketIndex))\
    \ {\n    return false\n  }\n\n  // If they have the same opening bracket, there's\
    \ no need to correct bracketing.\n  if (brackets.charAt(openingBracketIndex -\
    \ 1) === brackets.charAt(closingBracketIndex)) {\n    return false\n  }\n\n  return\
    \ true\n}\n", "    let stack: Stack<string> = new Stack<string>();\n    stack\
    \ = brackets;\n    let openingBrackets = 0;\n    while (openingBrackets > 0) {\n\
    \        if (stack.peek() == \"(\") {\n            stack.push(\")\");\n      \
    \      openingBrackets--;\n        }\n        else if (stack.peek() == \"[\")\
    \ {\n            stack.push(\"]\");\n            openingBrackets--;\n        }\n\
    \        else if (stack.peek() == \"{\") {\n            stack.push(\"}\");\n \
    \           openingBrackets--;\n        }\n        else if (stack.peek() == \"\
    <\") {\n            stack.push(\"</\");\n            openingBrackets--;\n    \
    \    }\n        else if (stack.peek() == \">\") {\n            stack.push(\"/>\"\
    );\n            openingBrackets--;\n        }\n        else if (stack.peek() ==\
    \ \"\") {\n            break;\n        }\n        else {\n            stack.push(brackets.pop());\n\
    \            openingBrackets--;\n        }\n    }\n    return stack.size == 0;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThe other answers here are great, but\
    \ this one (and the other answers above) are too complicated for my simple case.\
    \ No need to complicate it :)\n<code>\nlet validChars = /[(),[]<>]/;\nconst parseBrackets\
    \ = (str: string) => (\n  str.match(/[\\(\\[]/gi).join('')\n);\n", "  return brackets.indexOf('(')\
    \ == brackets.lastIndexOf(')') &&\n      brackets.indexOf('(') != brackets.lastIndexOf('(')\n\
    }\n", "\tif (brackets.length % 2 === 0) return true;\n\tfor (let i = 0; i < brackets.length;\
    \ i += 2) {\n\t\tif (brackets[i] !== brackets[i + 1]) return false;\n\t}\n\treturn\
    \ true;\n}\n", "  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i]\
    \ === ')') return true;\n    if (brackets[i] === ')') {\n      if (brackets[i\
    \ + 1] !== ')') return false;\n    }\n    if (brackets[i] === '(') {\n      if\
    \ (brackets[i - 1] === '(') return true;\n      if (brackets[i - 1] !== '(') return\
    \ false;\n    }\n  }\n  return false;\n}\n", "    if (brackets.length < 2) {\n\
    \        return false;\n    }\n\n    // If there are an even number of brackets,\
    \ there must be a corresponding closing bracket.\n    if (brackets.length % 2\
    \ !== 0) {\n        return false;\n    }\n\n    // A closing bracket must appear\
    \ right before the opening bracket.\n    const openingBracket = brackets.substring(0,\
    \ 1);\n    const closingBracket = brackets.substring(1);\n    const lastOpeningBracketIndex\
    \ = brackets.lastIndexOf(openingBracket);\n    if (lastOpeningBracketIndex !==\
    \ 0 && lastOpeningBracketIndex !== brackets.length - 1) {\n        return false;\n\
    \    }\n\n    // We know there are an even number of brackets.\n    for (let i\
    \ = 0; i + 1 < brackets.length; i = i + 2) {\n        const openingBracketIndex\
    \ = brackets.indexOf(brackets.charAt(i), i);\n        const closingBracketIndex\
    \ = brackets.indexOf(brackets.charAt(i + 1), i);\n\n        if (openingBracketIndex\
    \ !== closingBracketIndex) {\n            return false;\n        }\n    }\n\n\
    \    return true;\n}\n", "\tfor (let i = 0; i < brackets.length; ++i) {\n\t\t\
    const c = brackets[i];\n\t\tif (!((c === \"(\" && brackets[i - 1] !== \"(\") ||\
    \ (c === \")\" && brackets[i - 1] !== \"(\" || (brackets[i - 1] === \")\" && brackets[i\
    \ + 1] !== \")\"))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n",
  "  for (let i = 0; i < brackets.length; i++) {\n    const bracket = brackets[i];\n\
    \    const next_bracket = brackets[i + 1];\n    if (bracket === \"(\" && next_bracket\
    \ === \")\") {\n      return false;\n    }\n  }\n  return true;\n}\n", "\t// First,\
    \ find all the brackets\n\tbrackets = brackets.replace(/\\\\/g, \"\").replace(/\\\
    n/g, \" \").replace(/^\\s+|\\s+$/g, \"\");\n\tbrackets = brackets.split(\"\");\n\
    \t// then find all the opening brackets\n\tlet open_brackets: number[] = [];\n\
    \tfor (let i = 0; i < brackets.length; i += 1) {\n\t\tlet curr = brackets[i];\n\
    \t\tlet closing_bracket = -1;\n\t\tif (i !== brackets.length - 1) {\n\t\t\tlet\
    \ next: string = brackets[i + 1];\n\t\t\t// Special case where the next is a closing\
    \ bracket\n\t\t\tif (next === \")\") {\n\t\t\t\tclosing_bracket = i + 1;\n\t\t\
    \t} else if (next === \"(\") {\n\t\t\t\tclosing_bracket = i + 1;\n\t\t\t}\n\t\t\
    }\n\t\topen_brackets.push(closing_bracket);\n\t}\n\t// If no brackets are open,\
    \ then this bracket is invalid (it means it's an incorrect bracket)\n\tif (open_brackets.length\
    \ === 0) {\n\t\treturn false;\n\t}\n\t// Then, check all the brackets\n\tfor (let\
    \ i = 0; i < open_brackets.length; i += 1) {\n\t\tlet open_bracket = open_brackets[i];\n\
    \t\tlet close_bracket = -1;\n\t\tif (i !== open_brackets.length - 1) {\n\t\t\t\
    let next: string = open_brackets[i + 1];\n\t\t\tif (next === \")\") {\n\t\t\t\t\
    close_bracket = i + 1;\n\t\t\t} else if (next === \"(\") {\n\t\t\t\tclose_bracket\
    \ = i + 1;\n\t\t\t}\n\t\t}\n\t\tlet open_bracket = brackets[open_bracket];\n\t\
    \tlet close_bracket = brackets[close_bracket];\n\t\tif (close_bracket < open_bracket)\
    \ {\n\t\t\t// This bracket is not valid\n\t\t\treturn false;\n\t\t}\n\t\t// This\
    \ bracket is valid\n\t}\n\t// All brackets are valid\n\treturn true;\n}\n", " \
    \   let open_bracket = brackets.substring(0, 1)\n    let open_brackets = brackets.substring(1,\
    \ brackets.length - 1)\n    let close_bracket = brackets.substring(brackets.length\
    \ - 1, 1)\n    return open_brackets === close_bracket\n}\n", "  let open = brackets.split(\"\
    (\").length - 1;\n  let close = brackets.split(\")\").length - 1;\n  return (open\
    \ === close);\n}\n", "\treturn (\n\t\tbrackets === \"()\" ||\n\t\tbrackets ===\
    \ \"{}\" ||\n\t\tbrackets === \"[]\"\n\t);\n}\n", "    const opening = brackets.split(\"\
    (\")\n    const closing = brackets.split(\")\")\n    const unmatchedCount = opening.length\
    \ - closing.length\n    return unmatchedCount === 0\n}\n", "  const opening_brackets\
    \ = brackets.split('(');\n  const closing_brackets = brackets.split(')');\n  if\
    \ (opening_brackets.length !== closing_brackets.length) return false;\n  for (let\
    \ i = 0; i < opening_brackets.length; ++i) {\n    if (closing_brackets.indexOf(i\
    \ + 1) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\n", "  return\
    \ brackets.split('').reduce(function (prev, curr) {\n    return prev && curr &&\
    \ prev === '(' && curr === '(';\n  }, true);\n}\n", "  return brackets.split('').every(function(i)\
    \ {\n    return i == ')' ? '(' : i === '(' ? '(' : false;\n  });\n}\n", "\t//\
    \ We have two stacks, one containing the stack of open brackets and the other\
    \ containing the stack of closed brackets.\n\tstack1 = []; // Stack of open brackets\n\
    \tstack2 = []; // Stack of closed brackets\n\t\n\t// For each character in the\
    \ brackets string, add it to the stack\n\tfor (i = 0; i < brackets.length; i++)\
    \ {\n\t\tswitch (brackets[i]) {\n\t\t\tcase \"(\":\n\t\t\t\tstack2.push(brackets[i]);\n\
    \t\t\t\tbreak;\n\t\t\tcase \")\":\n\t\t\t\tstack2.pop();\n\t\t\t\tbreak;\n\t\t\
    \tdefault:\n\t\t\t\tstack1.push(brackets[i]);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\
    \t// If stack2 is empty after examining brackets, then the brackets are balanced\n\
    \tif (stack2.length === 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\
    \t}\n}\n", "    for (let i = 0; i < brackets.length; i++) {\n        const b =\
    \ brackets[i];\n        const e = brackets[i + 1];\n        if (e === undefined)\
    \ {\n            return false;\n        }\n        if (i === 0) {\n          \
    \  return b === e;\n        }\n        if (b === e) {\n            continue;\n\
    \        }\n        if (b === ')' && e === '(') {\n            return false;\n\
    \        }\n        if (b === '(' && e === ')') {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n", "\tif (!brackets || brackets.length\
    \ === 0) {\n\t\treturn false\n\t}\n\t// find all opening brackets in the string\n\
    \tconst openingBrackets: number[] = []\n\tfor (let i = 0; i < brackets.length;\
    \ i++) {\n\t\tconst c = brackets[i]\n\t\tif (c === '(') {\n\t\t\topeningBrackets.push(i)\n\
    \t\t} else if (c === ')') {\n\t\t\tif (openingBrackets.length === 0 || openingBrackets[openingBrackets.length\
    \ - 1] !== i) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\topeningBrackets.pop()\n\t\
    \t}\n\t}\n\t// are all brackets closed?\n\tif (openingBrackets.length === 0) {\n\
    \t\treturn false\n\t}\n\t// are all brackets matched?\n\treturn brackets.length\
    \ === openingBrackets.length\n}\n", "\tlet brackets = brackets.split(\")\").join(\"\
    )\");\n\tbrackets = brackets.split(\"(\").join(\"(\");\n\tbrackets = brackets.split(\"\
    [\").join(\"[\");\n\treturn brackets === brackets;\n}\n", "  const opening_brackets_stack:\
    \ Array<number> = [];\n  const closing_brackets_stack: Array<number> = [];\n\n\
    \  for (let index = 0; index < brackets.length; index++) {\n    const bracket\
    \ = brackets[index];\n    if (bracket.match(/[()]/)) {\n      opening_brackets_stack.push(bracket);\n\
    \    } else {\n      const lastOpeningBracket = opening_brackets_stack.pop();\n\
    \      const lastClosingBracket = closing_brackets_stack.pop();\n      if (lastOpeningBracket\
    \ === lastClosingBracket) {\n        // Close the bracket.\n        closing_brackets_stack.push(lastOpeningBracket);\n\
    \      } else {\n        // Open a bracket.\n        opening_brackets_stack.push(bracket);\n\
    \      }\n    }\n  }\n\n  const has_all_correct_brackets = opening_brackets_stack.length\
    \ === 0;\n  return has_all_correct_brackets;\n}\n", "\tlet num_open = brackets.split(\"\
    (\").length - 1;\n\tlet num_close = brackets.split(\")\").length - 1;\n\treturn\
    \ num_open == num_close;\n}\n\n", "    let bracket_stack = new Stack();\n\n  \
    \  for (let i = 0; i < brackets.length; ++i) {\n        const char = brackets[i];\n\
    \n        if (char === \"(\" || char === \")\") {\n            bracket_stack.push(char);\n\
    \        } else {\n            while (!bracket_stack.empty() && bracket_stack.top()\
    \ !== \"(\" && bracket_stack.top() !== \")\") {\n                bracket_stack.push(bracket_stack.top());\n\
    \            }\n\n            if (bracket_stack.empty()) {\n                return\
    \ false;\n            }\n\n            const top = bracket_stack.top();\n\n  \
    \          if (top === \"(\" && brackets[i + 1] === \")\") {\n               \
    \ bracket_stack.pop();\n            } else if (top === \")\" && brackets[i + 1]\
    \ === \"(\") {\n                bracket_stack.pop();\n            } else {\n \
    \               return false;\n            }\n        }\n    }\n\n    return !bracket_stack.empty();\n\
    }\n", "\tbrackets = brackets.toUpperCase();\n\tlet num_openings = brackets.split(\"\
    \").filter(c => c == \"(\").length;\n\tlet num_closings = brackets.split(\"\"\
    ).filter(c => c == \")\").length;\n\n\treturn (num_openings == num_closings);\n\
    }\n", "\tlet open_brackets = brackets.match(/[\\(\\[]/ig);\n\tlet close_brackets\
    \ = brackets.match(/[\\)\\]]/ig);\n\treturn open_brackets.length === close_brackets.length;\n\
    }\n", "  for (let i = 0; i < brackets.length; i += 1) {\n    const opening = brackets[i];\n\
    \    const closing = brackets[brackets.length - 1 - i];\n    if (opening !== closing)\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n", "    const stack:\
    \ { [index: number]: string }[] = [];\n\n    stack.push([brackets, 0]);\n\n  \
    \  while (stack.length > 0) {\n        const [open, pos] = stack.pop();\n    \
    \    if (pos === brackets.length - 1) {\n            pos += 1;\n            if\
    \ (open === \"(\") {\n                stack.push([\")\", pos]);\n            }\
    \ else {\n                stack.push([\")(\", pos]);\n            }\n        }\
    \ else {\n            if (open === \"(\") {\n                pos += 1;\n     \
    \           stack.push([\")\", pos]);\n            } else {\n                stack.push([\"\
    )(\", pos]);\n            }\n        }\n    }\n\n    return stack.length === 0;\n\
    }\n", "\tlet count = 0;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tif\
    \ (brackets[i] == '(') count++;\n\t\tif (brackets[i] == ')') count--;\n\t}\n\t\
    return (count % 2 == 0);\n}\n", "  // Special case: If the brackets string is\
    \ empty, it's considered\n  // correct to not have brackets at all.\n  if (brackets.length\
    \ === 0) {\n    return false;\n  }\n\n  // Special case: If the brackets string\
    \ is exactly \"(\" it's considered\n  // correct to not have any brackets at all.\n\
    \  if (brackets === '(') {\n    return false;\n  }\n\n  // Special case: If the\
    \ brackets string is exactly \")\" it's considered\n  // correct to not have any\
    \ brackets at all.\n  if (brackets === ')') {\n    return false;\n  }\n\n  //\
    \ Special case: If the brackets string is exactly \"{\" it's considered\n  //\
    \ correct to not have any brackets at all.\n  if (brackets === '{') {\n    return\
    \ false;\n  }\n\n  // Special case: If the brackets string is exactly \"}\" it's\
    \ considered\n  // correct to not have any brackets at all.\n  if (brackets ===\
    \ '}') {\n    return false;\n  }\n\n  // Special case: If the brackets string\
    \ is an exact match for an\n  // opening bracket, it's considered correct to not\
    \ have any brackets\n  // at all.\n  if (brackets.startsWith('(')) {\n    return\
    \ false;\n  }\n\n  // Special case: If the brackets string is an exact match for\
    \ a closing\n  // bracket, it's considered correct to not have any brackets at\
    \ all.\n  if (brackets.endsWith(')')) {\n    return false;\n  }\n\n  // Otherwise,\
    \ if the brackets string is of the form \"(\" or \"{\", the first\n  // opening\
    \ bracket must be immediately followed by a closing bracket. If\n  // the brackets\
    \ string is an exact match for a closing bracket, that closing\n  // bracket must\
    \ also be an opening bracket. Otherwise, if the brackets\n  // string is an exact\
    \ match for a closing bracket, that closing bracket\n  // must also be an opening\
    \ bracket. Otherwise, return false.\n  const bracketsArr = brackets.split('');\n\
    \  if (bracketsArr.every((character) => character === '(' || character === '{'))\
    \ {\n    return bracketsArr.every((character) => character === '(');\n  }\n\n\
    \  return bracketsArr.every((character) => character === ')');\n}\n", "\tbrackets\
    \ = brackets.replace(\"(\", \"\").replace(\")\", \"\");\n\tlet opening_brackets\
    \ = brackets.match(/\\(/g);\n\tlet closing_brackets = brackets.match(/\\)/g);\n\
    \tif (opening_brackets == null)\n\t\treturn closing_brackets == null;\n\telse\
    \ if (closing_brackets == null)\n\t\treturn opening_brackets.length == 0;\n\t\
    return opening_brackets.length == closing_brackets.length;\n}\n", "  if (brackets.length\
    \ <= 1) {\n    return false;\n  }\n  const stack = new Stack();\n  const stack2\
    \ = [brackets[0]];\n  for (let i = 1; i < brackets.length; i++) {\n    const c\
    \ = brackets[i];\n    if (c === '(') {\n      stack.push(c);\n      stack2.push(c);\n\
    \    } else if (c === ')') {\n      if (!stack.isEmpty()) {\n        if (stack.pop()\
    \ !== stack2[stack2.length - 1]) {\n          return false;\n        }\n     \
    \   stack2.pop();\n      } else {\n        return false;\n      }\n    } else\
    \ {\n      if (stack.peek() !== '(') {\n        return false;\n      }\n     \
    \ stack2.push(c);\n    }\n  }\n  return !stack2.isEmpty();\n}\n", "    if (brackets.length\
    \ !== 2) return false;\n    if (brackets[0] === brackets[1]) return false;\n \
    \   return brackets[0] === \"(\" && brackets[1] === \")\";\n}\n", "    if (brackets.length\
    \ !== 1)\n        return false;\n    let left = brackets[0];\n    let right =\
    \ brackets.substr(0, brackets.length-1);\n    return left === right.replace(/[-()\\\
    [\\]]/, \"\");\n}\n", "  if (brackets == \"(\" || brackets == \")\") {\n    return\
    \ true\n  }\n  let opening = brackets.slice(0, 1)\n  let closing = brackets.slice(1,\
    \ -1)\n  for (let i = opening.length; i > 0; i--) {\n    let openers = opening.substring(0,\
    \ i)\n    let closers = closing.substring(0, i)\n    if (openers.match(/[(){}]/)\
    \ && closers.match(/[(){}]/)) {\n      return true\n    }\n  }\n  return false\n\
    }\n", "\tlet stack: string[] = [];\n\tlet bracket: Character;\n\n\tfor (let i\
    \ = 0; i < brackets.length; i += 1) {\n\t\tbracket = brackets[i];\n\t\tif (stack.length\
    \ > 0 && bracket === ')') {\n\t\t\tconst top = stack.pop();\n\t\t\tif (top ===\
    \ '(') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (stack.length > 0 && bracket\
    \ === '(') {\n\t\t\tstack.push(bracket);\n\t\t} else if (stack.length === 0) {\n\
    \t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "    if (brackets.length\
    \ !== 2) {\n        return false;\n    }\n\n    // make sure it has the proper\
    \ brackets, otherwise we're not correct.\n    if (!((brackets[0] === '(') && (brackets[1]\
    \ === ')'))) {\n        return false;\n    }\n\n    // make sure all brackets\
    \ in the string are balanced, otherwise\n    // we're not correct.\n    let opening\
    \ = brackets[0];\n    for (let i = 1; i < brackets.length; i++) {\n        if\
    \ (brackets[i] !== opening) {\n            return false;\n        }\n    }\n\n\
    \    return true;\n}\n", "  const opening_brackets = brackets.match(/\\(/g);\n\
    \  const closing_brackets = brackets.match(/\\)/g);\n\n  return (opening_brackets\
    \ === null || closing_brackets === null || opening_brackets.length !== closing_brackets.length);\n\
    }\n", "\tvar stack: Stack<string> = new Stack<string>();\n\tvar opening_char:\
    \ number = 0;\n\tvar i: number;\n\tfor (i = 0; i < brackets.length; i++) {\n\t\
    \tswitch (brackets[i]) {\n\t\t\tcase '(':\n\t\t\t\tstack.push(brackets[i]);\n\t\
    \t\t\topening_char = i;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tif (!stack.isEmpty())\
    \ {\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\
    \tbreak;\n\t\t}\n\t}\n\n\tif (!stack.isEmpty()) {\n\t\treturn false;\n\t}\n\n\t\
    for (i = 0; i < brackets.length; i++) {\n\t\tswitch (brackets[i]) {\n\t\t\tcase\
    \ '(':\n\t\t\t\topening_char = i;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tbreak;\n\
    \t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opening_char > 0) {\n\t\t\
    return brackets[opening_char - 1] === '(' && brackets[opening_char + 1] === ')';\n\
    \t}\n\treturn false;\n}\n", "    let bracketsStack: string[] = [];\n    let lastCharacter:\
    \ string = brackets[0];\n    let bracketsCount: number = 0;\n\n    for (let i\
    \ = 1; i < brackets.length; i += 1) {\n        if (brackets[i] === \")\") {\n\
    \            bracketsCount -= 1;\n            if (bracketsCount === 0) {\n   \
    \             bracketsStack.pop();\n            }\n        }\n        else if\
    \ (brackets[i] === \"(\") {\n            bracketsCount += 1;\n        }\n    \
    \    else if (brackets[i] === \")\") {\n            bracketsStack.push(brackets[i]);\n\
    \        }\n        else {\n            bracketsStack.push(brackets[i]);\n   \
    \         lastCharacter = brackets[i];\n        }\n    }\n\n    // If bracketsStack\
    \ is empty after popping everything, then there is an open bracket with no corresponding\
    \ closing bracket.\n    if (bracketsStack.length === 0) {\n        return false;\n\
    \    }\n\n    return bracketsStack.length === brackets.length;\n}\n", "    let\
    \ last: number = 0;\n\n    for (const i of brackets) {\n        if (i === '(')\
    \ {\n            last++;\n        } else if (i === ')') {\n            last--;\n\
    \        }\n\n        if (last < 0) {\n            return false;\n        }\n\
    \    }\n\n    return true;\n}\n", "\tlet stack: string[] = [];\n\tlet bracket\
    \ = false;\n\tlet bracketCount = 0;\n\tfor (let i = 0; i < brackets.length; ++i)\
    \ {\n\t\tswitch (brackets[i]) {\n\t\t\tcase \"(\":\n\t\t\t\tbracket = true;\n\t\
    \t\t\tbracketCount++;\n\t\t\t\tbreak;\n\t\t\tcase \")\":\n\t\t\t\tbracketCount--;\n\
    \t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbracket = false;\n\t\t}\n\t\tif (!bracket)\
    \ {\n\t\t\tstack.push(brackets[i]);\n\t\t}\n\t}\n\treturn (bracketCount === 0);\n\
    }\n", "  return brackets.split('').reduceRight((prev, curr, idx, array) => {\n\
    \    return prev && array[idx - 1] === ')'\n  }, true)\n}\n", "  let stack: string[]\
    \ = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] ===\
    \ \"(\") {\n      stack.push(brackets[i]);\n    } else if (brackets[i] === \"\
    )\") {\n      while (stack.length && brackets[i] === stack[stack.length - 1])\
    \ {\n        stack.pop();\n      }\n      if (!stack.length) {\n        return\
    \ false;\n      }\n    }\n  }\n  return stack.length === 0;\n}\n", "\tvar opening_brackets\
    \ = brackets.split(\"(\");\n\tvar closing_brackets = brackets.split(\")\");\n\t\
    for (var i = 0; i < opening_brackets.length; ++i) {\n\t\tfor (var j = 0; j < closing_brackets.length;\
    \ ++j) {\n\t\t\tif (opening_brackets[i] == closing_brackets[j]) {\n\t\t\t\topening_brackets.splice(i,\
    \ 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar has_correct_brackets = opening_brackets.length\
    \ == 0;\n\treturn has_correct_brackets;\n}", "    var stack = 0;\n    var brackets_length\
    \ = brackets.length;\n    for (var i = 0; i < brackets_length; i++) {\n      \
    \  var ch = brackets[i];\n        if (ch == \"(\") {\n            stack++;\n \
    \       } else if (ch == \")\") {\n            stack--;\n            if (!stack)\
    \ {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}\n\n", "  let brackets_set = brackets.split('');\n  let correct_brackets\
    \ = false;\n  for (let i = 0; i < brackets_set.length; ++i) {\n    let current_bracket\
    \ = brackets_set[i];\n    if (current_bracket === \"(\" ||\n        current_bracket\
    \ === \")\") {\n      let next_bracket = brackets_set[i+1];\n      if (current_bracket\
    \ === \"(\" &&\n          next_bracket === \")\") {\n        correct_brackets\
    \ = true;\n      }\n    }\n  }\n  return correct_brackets;\n}\n", "    if (brackets.length\
    \ === 0) {\n        return false;\n    }\n\n    for (let i = 0; i < brackets.length;\
    \ i++) {\n        const bracket = brackets.charAt(i);\n        if (bracket !==\
    \ '(' && bracket !== '[' && bracket !== '{') {\n            return false;\n  \
    \      }\n    }\n\n    return true;\n}\n", "  return brackets === brackets.replace(bracketPairs.left,\
    \ \"\")\n      && brackets === brackets.replace(bracketPairs.right, \"\");\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
