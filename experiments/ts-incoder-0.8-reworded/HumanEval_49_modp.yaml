name: HumanEval_49_modp
language: ts
prompt: "//Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n\
  // >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n//\
  \ 8\n// >>> modp(100, 101)\n// 1\nfunction modp(n: number, p: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101,\
  \ 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3,\
  \ 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30,\
  \ 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"
completions: ["    let q: number = p % n\n    if (q < 0) {\n        q += n\n    }\n\
    \    return q\n}\n", "  let result = n & p;\n  result = (result < 0) ? result\
    \ + p : result;\n  return ((result > p) ? result - p : result);\n}\n", "    if\
    \ (n < 0 || n >= p)\n        return 0;\n    return ((n % p) + p) % p;\n}\n", " \
    \ let d = 1;\n  let s = p % 64;\n  let e = (p / 64) % 64;\n  let t1 = (64 * e)\
    \ % p;\n  let t2 = t % p;\n  if (t2 < p) d = t2;\n  if (s > t1) d = s;\n  if (e\
    \ > t1) d = e;\n  return d;\n}\n", "  var x = 1;\n  for (var i = 0; i < p; i++)\
    \ {\n    x <<= 1;\n    x ^= n & 1;\n  }\n\n  return x;\n}\n", "  let t = n * p;\n\
    \  return t >= p ? (t % p + p) % p : t;\n}\n", "  let res = 1;\n  while (n > p)\
    \ res *= (n - p);\n  return p === n ? 0 : res;\n}\n", "  if (n <= 0) {\n    return\
    \ 0;\n  }\n\n  return ((n % p) + p) % p;\n}\n", "  let mod = (n % p + p) % p;\n\
    \  if (mod === 0) {\n    return p\n  }\n  if (mod === p / 2) {\n    return p\n\
    \  }\n  return mod\n}\n", "  n = p % 4\n  if (n < 3) {\n    return n\n  }\n  return\
    \ n % 4 == 0 ? n : n % 4 + 1\n}\n", "  if (n < 0) {\n    throw errorModByZero();\n\
    \  }\n  if (p <= 0) {\n    throw errorNotPositive();\n  }\n  if (p === 1) {\n\
    \    throw errorNotPositive();\n  }\n  if (p === Infinity) {\n    return 1;\n\
    \  }\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  var abs = Math.abs(n);\n\
    \  if (abs < p) {\n    return n;\n  }\n  var p = Math.sqrt(p);\n  if (n % p ===\
    \ 0) {\n    return p;\n  }\n  if (n === p) {\n    return 1;\n  }\n  if (n > p)\
    \ {\n    throw errorNotPositive();\n  }\n  if (n === (p << 1) + 1) {\n    return\
    \ (p + 1) >> 1;\n  }\n  if (n === (p << 1) + 2) {\n    return (p >> 1) + 1;\n\
    \  }\n  throw errorNotAPrime();\n}\n", "  let mod: number;\n  if (n % 2 == 0)\
    \ {\n    if (n % p === 0) {\n      mod = 1;\n    } else {\n      mod = p - 1;\
    \ // Use p-1\n    }\n  } else if (n % p !== 0) {\n    mod = (p - 1) * (Math.pow(n\
    \ % p, 1 / p)); // Use p-1 times n-p to reduce the number. Since n % p == 0 is\
    \ true.\n    // This is important because we only reduce the number when p is...\n\
    \    // zero. So, if we used a number like, say, 20 and then reduced it\n    //\
    \ to 10, then 20 % 10 must be 0 and thus 1.\n    // If we used a number like 100,\
    \ then 10% 10 === 0.\n    // So, using 10 % 1 would give 1. Using 10 % 0, we get\
    \ 0.\n    // With other words, 10 % a === 10%a.\n  } else {\n    mod = 0;\n  }\n\
    \  return mod;\n}\n</code>\n<|/ a dscore=3 tags=javascript,algorithm,c++,c |>\n\
    <| c |>\nthanks for sharing this with me. it's good to see you using modulus to\
    \ do mod instead of doing it by hand. it turns out this was the most elegant solution\
    \ I've seen so far. thanks so much! I wish I could give you more upvotes\n<|/\
    \ c |>\n<| c |>\nglad I could help :-)\n<|/ c |>\n<| c |>\n`mod` can be done with\
    \ bitwise operators instead of modulo. E.g. `(a<<n)|(~(a>>(-n)))`\n<|/ c |>\n\
    <| c |>\nI really appreciate the answer, but it really needs more explaining.\n\
    <|/ c |>\n<| c |>\nI updated the answer with some comments and a link to the Wikipedia\
    \ article that explains what `mod` means in cryptography.\n<|/ c |>\n<| a dscore=3\
    \ tags=javascript,algorithm,c++,c |>\nHere's a solution using modular arithmetic.\n\
    <code>", "  n = n % p;\n  if (n == 0) return 0;\n  if ((n%p) == 0) return (p*p\
    \ == n) ? p : n; // n / p === n  ? (p % p) : n\n  return modp( (n%p), p); // mod(n\
    \ % p, p)\n}\n", "    let q = p - 1\n    return ((n % q) + q) % q\n}\n", "\treturn\
    \ ((n % p) + p) % p;\n}\n", "  const result = n;\n  while (p) {\n    if (result\
    \ & 1) result ^= p;\n    result >>>= 1;\n    p >>>= 1;\n  }\n  return result;\n\
    }\n", "  if (n === 0) { return 0; }\n  if (n === p / p) { return 1; }\n  if (n\
    \ !== n - 1) { return modp(n - 2, p - 2); }\n  if (n % 2 === 1) { return modp(n\
    \ / 2, p); }\n  return modp(n / 2, p);\n}\n", "  return n % p === 0 ? (n / p)\
    \ | 0 : 1;\n}\n", "  if (n < 0 || p < 0 || n < p || n % p === 0) return 0;\n \
    \ const r = math.pow(p, n);\n  if (r === p) return r;\n  if (r < p) r += p;\n\
    \  return r;\n}\n", "  let d = n.bit_length();\n  if (d % p != 0) throw new Error(\"\
    Invalid modulus\");\n  const mask = (1 << d) - 1;\n  return (mask & n) == mask\
    \ ? n : n % p;\n}\n", "\tif (n <= 0) {\n\t\treturn 0;\n\t}\n\n\tn = p * (n - 1);\n\
    \tn %= p;\n\treturn n < 0 ? n - p : n;\n}\n", "\treturn ((n % p) + p) % p;\n}\n",
  "  return p > 0 ? powMod(n, p) % p : n\n}\n", "  if (n % 2 == 0) {\n    return p;\n\
    \  }\n  const a = (p / 2) | 0;\n  const b = n - 1;\n  const t = modPow(a, b, p);\n\
    \  return t % p;\n}", "  let a: number;\n  let b: number;\n  const result: number;\n\
    \  if (n < 0 || p < 0) {\n    throw new Error(`modp(n: ${n}, p: ${p})`);\n  }\n\
    \  if (p === 0 || n === p) return 1;\n  if (p === 1) return n;\n  a = n % p;\n\
    \  if (a < 0) a += p;\n  b = a % n;\n  if (b < 0) b += n;\n  return b === 0 ?\
    \ n : b;\n}\n", "  const res = powMod(n, p, p);\n  // Avoid precision loss\n \
    \ return (p + res) % p;\n}\n</code>\nAnd here is a test that confirms the result:\n\
    <code>\nconst assert = require('assert');\nconst modp = require('./modp.js');\n\
    \nlet tests = [\n  [3, 5],\n  [1101, 101],\n  [0, 101],\n  [3, 11],\n  [100, 101]\n\
    ];\n\nfor (let [n, p] of tests) {\n  let res = modp(n, p);\n  console.log(`modp(n:\
    \ ${n}, p: ${p}): ${res}`);\n  assert(res == modPow(n, p), `Incorrect result for\
    \ modp(n: ${n}, p: ${p})`);\n}\n</code>\nAnd here is a test that confirms its\
    \ performance (my computer cannot run this test in less than 1 second):\n<code>\n\
    const assert = require('assert');\nconst modp = require('./modp.js');\nconst {\
    \ performance } = require('perf_hooks');\n\nlet tests = [\n  [3, 5],\n  [1101,\
    \ 101],\n  [0, 101],\n  [3, 11],\n  [100, 101]\n];\n\nconst start = performance.now();\n\
    for (let [n, p] of tests) {\n  let res = modp(n, p);\n  console.log(`modp(n: ${n},\
    \ p: ${p}): ${res}`);\n  assert(res == modPow(n, p), `Incorrect result for modp(n:\
    \ ${n}, p: ${p})`);\n}\nconst end = performance.now();\nconsole.log(`Time spent\
    \ for modp(): ${end - start}`);\n</code>\nNote that it seems like the performance\
    \ of this algorithm is quite slow, even for very large numbers compared to the\
    \ other algorithms discussed here.\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere\
    \ is a function that finds GCD\n<code>", "  // Zero-extend n to start at minimum\
    \ point and subtract from p \n  // so we don't have to worry about n < p.\n  let\
    \ n = n < p ? p : n;\n  return n % p;\n}\n", "  if (n < p) {\n    return (p %\
    \ n) + n\n  }\n  return (n % p) + p\n}\n", "  return ((n % p) + p) % p;\n}\n",
  "  let r = p % n;\n  if (r < 0) {\n    return (r + n) % n;\n  }\n  return r;\n}\n",
  "  let i = math.floor(n);\n  return i % p + (i < n && -p == n % p ? n : 0);\n}\n",
  "  // TODO: Remove undocumented assertions (see the comment in modq).\n  assert(0\
    \ <= n && n <= p && p < 256, \"modulus must be in range of [0, 256]\");\n  const\
    \ mask = (p - 1) % p;\n  const mod = n & mask;\n  const result = (mod * p + mask)\
    \ % p;\n  // Make sure that result won't overflow p.\n  assert(result % p == mod\
    \ || result < p || result == -1, \"result is out of range\");\n  return result;\n\
    }\n", "  let acc = 0;\n  let divisor = 1;\n  for (let i = 2; i <= p; i++) {\n\
    \    acc = (n % i) + acc + (divisor <= i ? 1 : 0);\n    divisor *= i;\n  }\n \
    \ return acc % p;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  if (n < p) {\n\
    \    return n - p;\n  }\n\n  if (n > p) {\n    return p - n;\n  }\n\n  return\
    \ n;\n}\n", "  return n < 0 ? -p : p == 0 ? 0 : (p * mod1(n)) % p;\n}\n", "  \
    \  let retVal: number = 0;\n    for (let i = 0; i < n; i++) {\n        retVal\
    \ += p * 2;\n        ret %= p;\n    }\n    return retVal;\n}", "\tconst m = (1\
    \ << p) - (1 << n); // mask\n\treturn ((m << 1) | (m >> 1)) & p; // set n to 0\
    \ and mask m\n}\n", "  return ((n % p) + p) % p;\n}\n", "  return p == 0 ? 0 :\
    \ modpow(10, Math.floor(Math.log(n) / Math.LN10 + Math.log(p) / Math.LN10), n)\n\
    }\n", "\treturn ((n % p) + p) % p;\n}\n", "  return n < p ? n : n % p; // less\
    \ than or equal to p mod p\n}\n</code>\n<|/ a dscore=2 tags=javascript,typescript\
    \ |>\n<| a tags=javascript,typescript dscore=2 |>\nI came up with a solution that\
    \ makes use of bitwise operations. \n<code>", "    let result = p % n;\n    if\
    \ (result === 0) {\n        return result;\n    }\n    if (p > n) {\n        return\
    \ result - n + 1;\n    }\n    return result;\n}\n", "  const q: number = n >=\
    \ 0 ? n : -n\n  return q % p\n}\n", "    const m1 = (p - 1) % p;\n    return (m1\
    \ === 0) ? ((p << 1) + 1) : (m1 * 2);\n}\n", "    var result = 1;\n    var base\
    \ = Math.pow(10, p);\n    while (true) {\n        if (n <= 0) {\n            return\
    \ 0;\n        }\n        if (n % p === 0) {\n            n /= p;\n        }\n\
    \        if (n == 0) {\n            return result;\n        }\n        result\
    \ = (result * base) % p;\n    }\n}\n", "  return (n % p + p) % p;\n}\n", "  if\
    \ (n <= 0) {\n    return NaN;\n  }\n\n  if (p <= 0) {\n    return 1;\n  }\n\n\
    \  if (p === 1) {\n    return n;\n  }\n\n  if (p < n) {\n    return modp(n, p);\n\
    \  }\n\n  return modp(p - 1, p - 1) + 1;\n}\n", "  if (n < p && !(n & 1)) {\n\
    \    return n;\n  }\n  return p * modinv(n, p);\n}\n", "  return n  % p;\n}\n",
  "    return ((n % p) + p) % p;\n}\n", "\treturn (p < n) ? n : ((p % n) + n) % n;\n\
    }\n", "  let res = p & 3\n  res |= (n >> 2) & 3\n  res |= (n >> 4) & 3\n  res\
    \ |= (n >> 6) & 3\n  res |= (n >> 8) & 3\n  res |= (n >> 10) & 3\n  res |= (n\
    \ >> 12) & 3\n  res |= (n >> 14) & 3\n  res |= (n >> 16) & 3\n  return p - (3\
    \ << res) | (n << (32 - res))\n}\n", "  // fast cases\n  if (p === 0) return 1;\n\
    \  if (p === 1) return 0;\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n\
    \n  // some kind of BigNumber bug\n  if (n === 0 || n > 20) return NaN;\n\n  //\
    \ positive cases\n  if (n > 0xFFFF) {\n    // note that n < 0x10000 is required\
    \ for bigNumbers, here n >=0x10000 is\n    // fine though\n    return Math.pow(n,\
    \ p) % p;\n  }\n\n  // negative cases\n  const mask = -n >> 1; // Math.pow(-x,\
    \ p) === -(Math.pow(x, p) ^ n)\n  if (p === 0) return mask;\n  if (p === 1) return\
    \ n - mask;\n\n  // upper bound of second term of (n - 1) times n\n  // note that\
    \ the bitwise operators above silently round this out\n  // to infinity\n  return\
    \ mask + (n - Math.pow(2, n - 1)) & n;\n}\n", "  if (n <= p || n >= (p + 1) -\
    \ p)\n    return 0;\n  if (n < p)\n    return p - n;\n  if (n > p)\n    return\
    \ n + p;\n  return n;\n}\n", "    var res = 1;\n    while (p <= n) {\n       \
    \ res *= p;\n        p %= n;\n    }\n    return res;\n}\n", "  return ((n % p)\
    \ + p) % p;\n}\n", "  let r = p & MASK;\n  p >>>= 0;\n  n = n & MASK;\n  n >>>=\
    \ 0;\n  if ((n & 1) == 0)\n    r = 0;\n  else if (n == 0)\n    r = p | 0;\n  else\n\
    \    r = p ^ n ^ r | 0;\n  return r;\n}\n", "  if (n === 0) {\n    return 1;\n\
    \  }\n  if (p === 0) {\n    return n;\n  }\n  if (n === p) {\n    return 1;\n\
    \  }\n  if (n === p || n % p === 0) {\n    return n >= 0 ? 1 : -1;\n  }\n  var\
    \ r = n / p;\n  var ps = p - r * p;\n  var qs = r * p + r;\n  if (qs < p) {\n\
    \    return -1;\n  }\n  return Math.min(modTo(n, ps) + 1, modTo(ps, qs) + (p <\
    \ qs ? 1 : 0));\n}\n", "    var q = 1\n    var m = p\n\n    while (n > 1) {\n\
    \        if (n % 2 === 0) {\n            n = n / 2\n        }\n\n        q *=\
    \ p\n        q %= m\n    }\n\n    return q\n}\n", "  let result = n % p;\n  if\
    \ (result === 0) {\n    if (p < n) {\n      result = p + (p < 10);\n    }\n  }\
    \ else {\n    result = p - result;\n  }\n  return result;\n}\n", "  let r = BigInt(n)\n\
    \  const m = BigInt(p)\n  if (p.isSmall) r = r.modp(m)\n  if (r.isSmall) return\
    \ BigInt(0)\n  return r.modp(BigInt(m + 1n)).minus(m)\n}\n", "\tif (n < 0 || p\
    \ < 1)\n\t\tthrow new RangeError('modulus must be a non-negative and non-positive\
    \ integer');\n\n\tif (n === 0)\n\t\treturn 0;\n\n\tif (n === 1)\n\t\treturn 1;\n\
    \n\tif (p == 1)\n\t\treturn n;\n\n\tlet mu = 1;\n\n\tfor (let q = p; ; q *= p)\n\
    \t\tif (q >= n)\n\t\t\tbreak;\n\t\telse\n\t\t\tmu = (mu * q + 1) & q;\n\n\treturn\
    \ mu;\n}\n", "  if (n < p) {\n    throw new Error('mod: expected number <p> not\
    \ < n');\n  }\n  return ((n - 1) % p + p) % p;\n}\n", "  let i = 0;\n  let result\
    \ = 0;\n  while (i <= p.length - 1) {\n    if (n >= p[i + 1])\n      result =\
    \ result + 1;\n    i++;\n  }\n  return result;\n}\n", "  if (n < p) {\n    if\
    \ (n < 0) return 0;\n    if (isEven(p)) return 1;\n    if (n === 0 || isEven(n))\
    \ return n;\n    if (isPositive(n) || isNegative(n)) return n + p;\n  } else {\n\
    \    if (n > p) return 0;\n    if (isEven(p)) return n;\n    if (n === 0 || isEven(n))\
    \ return 0;\n    if (isPositive(n) || isNegative(n)) return n - p;\n  }\n  return\
    \ 0;\n}\n", "  const q = Math.floor(Math.log(p) / Math.log(2)) % 2; // calculate\
    \ q\n  if (n === 0) return 1; // n = 0\n  if (q === 0) return 0; // q = 0, p =\
    \ 1, return 1\n  if (p === 1) return -1; // p == 1, n = 0\n  if (p === 2) return\
    \ -2; // p == 2, n = 1\n  if (p === 3) return p; // p = 3, n = 1\n  if (p ===\
    \ 4) return 4; // p = 4, n = 2\n  if (p === 5) return 8; // p = 5, n = 3\n  if\
    \ (p === 6) return 16; // p = 6, n = 3\n  if (p === 7) return 32; // p = 7, n\
    \ = 3\n  if (p === 8) return 64; // p = 8, n = 3\n  if (p === 9) return 128; //\
    \ p = 9, n = 3\n  if (p === 10) return 256; // p = 10, n = 3\n  if (p === 11)\
    \ return 512; // p = 11, n = 3\n  if (p === 12) return 1024; // p = 12, n = 3\n\
    \  if (p === 13) return 2048; // p = 13, n = 3\n  if (p === 14) return 4096; //\
    \ p = 14, n = 3\n  if (p === 15) return 8192; // p = 15, n = 3\n  return -1;\n\
    }\n", "\treturn (n % p + p) % p;\n}\n", "  if (n < p) {\n    return 0;\n  }\n\
    \  if (n === p) { // Faster case when n==p.\n    return 1;\n  }\n  let q = n;\n\
    \  while (p % p === 0) {\n    p /= p;\n    q %= p;\n  }\n  return q;\n}\n", " \
    \ let r = p % n;\n  return r === 0 ? n : r;\n}", "  if (n <= 0) {\n    return\
    \ 1;\n  }\n  if (n > p) {\n    return n - (p % n);\n  }\n  if (n < p) {\n    return\
    \ p - n;\n  }\n  return p;\n}\n", "  return ((n % p) + p) % p;\n}\n", "    let\
    \ m = n;\n    while (p > 1) {\n        if (p & 1) m |= (m & 1) ? 0 : 1;\n    \
    \    p >>= 1;\n    }\n    return m;\n}\n", "  let q = p | 0;\n  while (n-- !==\
    \ 0) {\n    q = q & p | 0;\n  }\n  return q;\n}\n", "  if (n < p && n >= 0) {\n\
    \    return n\n  }\n  return n % p\n}\n", "    return ((n % p) + p) % p;\n}\n",
  "  let mask = 1;\n  while (mask <= p) mask <<= 1;\n  return (n & mask) ? ((n ^ mask)\
    \ % p) : n;\n}\n", "    var a = p.modPow(2, n);\n    if (p.cmpn(0) === 0 && n.cmpn(0)\
    \ === 0) {\n        //GEX polynomial here\n        return 0;\n    }\n    else\
    \ {\n        return a;\n    }\n}\n", "  let r = 1;\n  while (n >= p) {\n    r\
    \ = r * n % p;\n    n -= p;\n  }\n  return r;\n}\n", "\treturn (n % p + p) % p;\n\
    }\n", "  if (n < p) {\n    return n - p;\n  }\n  return n % p;\n}\n", "  let res\
    \ = 0;\n  while (n > p) { res ^= n; n >>>= p; p++ }\n  return res & p;\n}\n",
  "  return n<0 ? 0 : n%p;\n}\n", "  const res = Math.pow(Math.abs(n), p);\n  if (n\
    \ < 0) return -res;\n  return res;\n}\n", "\treturn (n % p + p) % p;\n}\n", " \
    \ const q = p < 2 ? p : p - 2;\n  return (p < 2) ? n : n % p + q;\n}\n", "  let\
    \ res = 1;\n  for (let i = 0; i < p; i++) {\n    res = (res * (n - p)) % n;\n\
    \  }\n  return res;\n}\n", "  const mod = Math.pow(n, p | 0);\n  return mod %\
    \ p;\n}\n", "  return n < p ? modm1(n, p) : modm2(n, p);\n}\n", "  n = n | 0;\n\
    \  p = p | 0;\n  const q = p / 2 | 0;\n  const r = p % 2 | 0;\n  const s = n >>>\
    \ 0;\n  const t = (p - q) >>> 0;\n  let a = ((s << 30) | (s >>> 2)) >>> 0;\n \
    \ let b = ((t << 30) | (t >>> 2)) >>> 0;\n  a &= b;\n  return (a + r) | 0;\n}",
  "  if (n < p) {\n    return 1;\n  }\n  if (n === p) {\n    return n;\n  }\n  if\
    \ (n > p) {\n    return p % n;\n  }\n  return 0;\n}\n", "  if (n === 0) return\
    \ 0;\n  if (p === 1) return 1;\n  if (p === 0) return n;\n  if (p < 0 || n < -p)\
    \ return NaN;\n  if (p > 1) return NaN;\n\n  // If n is integer\n  if (isInt(n))\
    \ {\n    // If n is odd, return n + p (make n positive if n is odd).\n    if (n\
    \ % 2 == 0) return n + p;\n    // If n is even, return n * p (multiply n by p).\n\
    \    if (n % 2 == 1) return n * p;\n    // If n is negative (n < 0), return NaN\n\
    \    if (n < 0) return NaN;\n    // If n is positive, return 1 / n * p (make n\
    \ negative if n is positive).\n    return 1 / n * p;\n  }\n\n  // If n is not\
    \ integer\n  if (isNaN(n)) return NaN;\n  // If n is NaN, return NaN\n  if (n\
    \ === Infinity) return NaN;\n  // If n is negative number, return NaN\n  if (n\
    \ <= 0) return NaN;\n  // If n is positive, return n / p (normalize n).\n  return\
    \ n / p;\n}\n", "  let n1 = n - 1\n  let n2 = n - 2\n  if (n1 < 0)\n    return\
    \ 0\n  if (p == 1)\n    return n1\n  if (p == 2)\n    return n2\n  if (p == 3)\n\
    \    return (n1 - n2) % (p + 1)\n  if (p == 6)\n    return n1\n  if (p == 7)\n\
    \    return n1 + (n2 - n1)\n  if (p == 8)\n    return (n2 - n1) % (p + 1)\n  if\
    \ (p == 9)\n    return n1 + n2\n  if (p == 10)\n    return n1 - n2\n  if (p ==\
    \ 11)\n    return (n1 - n2) % (p + 1)\n  if (p == 12)\n    return (n1 - n2) %\
    \ (p + 2)\n  if (p == 13)\n    return (n1 - n2) % (p + 1)\n  if (p == 14)\n  \
    \  return (n1 - n2) % (p + 2)\n  if (p == 15)\n    return n1 + (n2 - n1)\n  if\
    \ (p == 16)\n    return (n2 - n1) % (p + 1)\n  if (p == 17)\n    return (n1 -\
    \ n2) % (p + 2)\n  if (p == 18)\n    return (n1 - n2) % (p + 3)\n  if (p == 19)\n\
    \    return n1 - n2\n  if (p == 20)\n    return n1 - n2 % p\n}\n", "\treturn ((n\
    \ % p) + p) % p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  if (n > p)\
    \ {\n    return p;\n  }\n  if (n === 0 || n === p) {\n    return n;\n  }\n  return\
    \ n - Math.pow(2, n - p);\n}\n", "\tconst res = n % p;\n\treturn res === 0 ? 0\
    \ : ((p - res) + 1) | 0;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++)\
    \ {\n    res = (res % n) | 0;\n  }\n  return res;\n}\n", "  let res = 1;\n  for\
    \ (let i = 1; i < n; i = i * 2) {\n    if (p % i == 0) {\n      res = Math.pow(i\
    \ * 2, p);\n    }\n  }\n  return res;\n}\n", "  n = n | 0\n  p = p | 0\n  let\
    \ a = 0, b = 1, result = 0\n  let nlo = n & 0xffff\n  let nhi = (n >>> 16) & 0xffff\n\
    \  let pl = p & 0xffff\n  let ph = (p >>> 16) & 0xffff\n\n  // Compare division\
    \ algorithm with Wang Dong Xu's paper: count leading zero bits [31-28] of (n).\n\
    \  if (nll < nhi) {\n    // Divide n by 2^n.\n    a = pl\n    b = nhi\n  } else\
    \ if (nll > nhi) {\n    // Divide n by 2^(n-1).\n    a = nhi\n    b = pl\n  }\
    \ else {\n    // Divide n by 2^n.\n    a = pl\n    b = nll\n  }\n  // Do a final\
    \ subtraction to ensure that result is >= p.\n  result = a - (((a / b) | 0) *\
    \ b) | 0\n\n  // Check to see if result is less than modulus.\n  return result\
    \ - p\n}\n", "  return ((n % p) + p) % p;\n}\n", "  let q = n / p;\n  if (n <\
    \ p) {\n    return q * p;\n  } else if (n < p / 2) {\n    return q * (p - p +\
    \ 1);\n  } else {\n    return q * (p - p + 2);\n  }\n}\n", "  if (n < 0 || p <=\
    \ 0) {\n    throw new Error('modp(): arguments must be > 0 and <= 1');\n  }\n\
    \  if (n === 0 || p === 0) {\n    return 0;\n  }\n  if (isFinite(p)) {\n    //\
    \ Equal to (n xor p)\n    let t = n;\n    while (t && t % p === 0) {\n      t\
    \ /= p;\n    }\n    return t;\n  }\n  if (n > 1) {\n    // Equal to (n % p)\n\
    \    if (p === 1) {\n      return n;\n    }\n    const a = modp(n - 1, p),\n \
    \     b = modp(n, p);\n    return a === b ? a : b;\n  }\n  return n;\n}\n", " \
    \ return ((n % p) + p) % p;\n}\n", "  if (n === 0) {\n    return 1;\n  }\n  if\
    \ (n === 1) {\n    return n;\n  }\n  if (p % 2 === 0) {\n    return n >= p;\n\
    \  }\n  if (p % 2 !== 0) {\n    return n % p === 0;\n  }\n  if (n === p) {\n \
    \   return n;\n  }\n  return n >= p;\n}\n", "  if (p === 0) {\n    return 1;\n\
    \  }\n  n %= p;\n  if (n < p) {\n    return modp(n - p, p);\n  }\n  return n;\n\
    }\n", "  if (n < p && n > -1) {\n    // this is faster than Math.pow\n    let\
    \ q = p - 1\n    while (n > q) q--\n    return n % q\n  }\n  return 0\n}\n\nexport\
    \ function nextpow2(v: number): number {\n  let x = 1\n  while (v & 1) x = x <<\
    \ 1\n  v >>= 1\n  while (x & 1) x = x << 1\n  x >>= 1\n  return x\n}\n\nexport\
    \ function nextpow10(v: number): number {\n  let x = 1\n  while (v & 1) x = x\
    \ << 1\n  v >>= 1\n  while (x & 1) x = x << 1\n  x >>= 1\n  x >>= 1\n  x >>= 1\n\
    \  while (x & 1) x = x << 1\n  return x\n}\n\nexport function nextpow12(v: number):\
    \ number {\n  let x = 1\n  while (v & 1) x = x << 1\n  v >>= 1\n  while (x & 1)\
    \ x = x << 1\n  x >>= 1\n  x >>= 1\n  x >>= 1\n  while (x & 1) x = x << 1\n  x\
    \ >>= 1\n  x >>= 1\n  x >>= 1\n  while (x & 1) x = x << 1\n  return x\n}\n\nexport\
    \ function nextpow16(v: number): number {\n  let x = 1\n  while (v & 1) x = x\
    \ << 1\n  v >>= 1\n  while (x & 1) x = x << 1\n  x >>= 1\n  x >>= 1\n  x >>= 1\n\
    \  while (x & 1) x = x << 1\n  x >>= 1\n  x >>= 1\n  x >>= 1\n  x >>= 1\n  while\
    \ (x & 1) x = x << 1\n  return x\n}\n\nexport function nextpow24(v: number): number\
    \ {\n  let x = 1\n  while (v & 1) x = x << 1\n  v >>= 1\n  while (x & 1) x = x\
    \ << 1\n  x >>= 1\n  x >>= 1\n  x >>= 1\n  while (x & 1) x = x << 1\n  x >>= 1\n\
    \  x >>= 1\n  x >>= 1\n  while (x & 1) x = x << 1\n  x >>= 1\n  x >>= 1\n  x >>=\
    \ 1\n  x >>= 1\n  while (x & 1) x = x << 1\n  x >>= 1\n  x >>= 1\n  x >>= 1",
  "  return n < 0 ? -p % p : n % p;\n}\n", "\treturn ((n % p) + p) % p;\n}\n", " \
    \ let t: number;\n  if (n < p) {\n    t = n;\n    n = p;\n    p = t;\n  }\n  while\
    \ (p % n === 0 || n !== Math.floor(n / n)) {\n    n /= n;\n  }\n  return n;\n\
    }\n", "  return n < p ? n : n % p;\n}\n", "  return n % p;\n}\n", "  const r =\
    \ p % n;\n  return r === 0 ? 1 : r;\n}\n", "  var r = p % n;\n  return r === 0\
    \ ? n : r;\n}\n", "\treturn ((n % p) + p) % p;\n}\n", "\tlet result = 1;\n\twhile\
    \ (p) {\n\t\tif (p & 1) result = result * n & p;\n\t\tn = n >> 1;\n\t\tp--;\n\t\
    }\n\treturn result;\n}\n", "  if (n === 0) {\n    return 0;\n  }\n\n  let r: number;\n\
    \n  if (p === 0) {\n    return 1;\n  }\n\n  if (p < 0) {\n    p = -p;\n    n +=\
    \ 1;\n  }\n\n  if (n === 1 || (n = 3) !== n / 2) {\n    return n;\n  }\n\n  if\
    \ (isBigNumber(n)) {\n    return n.mod(p);\n  }\n\n  if (isBigNumber(p)) {\n \
    \   if (p.isUnit()) {\n      r = new BigNumber(p.s);\n    } else {\n      r =\
    \ p.mod(n);\n    }\n  } else {\n    r = new BigNumber(n).mod(p);\n  }\n\n  if\
    \ (r.isZero()) {\n    return 0;\n  }\n\n  let t = new BigNumber(n);\n  let two\
    \ = new BigNumber(2);\n  while (!r.isZero()) {\n    r = r.times(two);\n    two\
    \ = new BigNumber(2).pow(two);\n  }\n  return t;\n}\n\nexport function fibonacci(n:\
    \ number): BigNumber {\n  const cache: { [key: number]: BigNumber } = {};\n\n\
    \  if (n === 0) {\n    return 0;\n  }\n\n  if (isBigNumber(n)) {\n    if (n >\
    \ 0) {\n      if (isBigNumber(cache[0])) {\n        return cache[0];\n      }\n\
    \n      cache[0] = new BigNumber(n);\n    }\n\n    return cache[0];\n  }\n\n \
    \ if (isBigNumber(n)) {\n    return new BigNumber(n).fibonacci();\n  }\n\n  let\
    \ r = 0;\n  let t = 1;\n  let one = new BigNumber(1);\n\n  if (n < 0) {\n    r\
    \ = (new BigNumber(n)).fibonacci();\n    if (r.isNegative() || r.isZero()) {\n\
    \      throw Error('Expected a positive argument.');\n    }\n    n = -r;\n  }\n\
    \n  while (n) {\n    r = ((3 * r + one) % n);\n    ++t;\n    one = new BigNumber(1);\n\
    \  }\n\n  return r;\n}\n\nexport function logBase(base: number, x: number, isSigned:\
    \ boolean = false): number {\n  if (isBigNumber(base)) {\n    if (base.isNegative())\
    \ {\n      if (isBigNumber(x)) {\n        x.isNegative(true);\n      }\n\n   \
    \   return new BigNumber(x).logBase();\n    }\n\n    if (base.isZero()) {\n  \
    \    if (isBigNumber(x)) {\n        x.isZero(true);\n      }\n\n      return 0;\n\
    \    }\n\n    if (x.isNegative()) {\n      if (isBigNumber(base)) {\n        base.isNegative(true);\n\
    \      }\n\n      if (isBigNumber(x)) {\n        x.isNegative(true);\n      }\n\
    \n      if (x.isNegative()) {\n        return new BigNumber(0).logBase();\n  \
    \    }\n\n      return new BigNumber(0).logBase();\n    }\n\n    if (base.isPositive())\
    \ {\n      if (isBigNumber(x)) {\n        x.", "    const q: number = p;\n   \
    \ const r = n - p;\n    let s = 0;\n    while (r !== 0) {\n        const t = r;\n\
    \        r = ((t %= q) + p) % q;\n        s = t + q;\n    }\n    return s % q;\n\
    }\n", "  return n % p;\n}\n", "  const modulus = p % n;\n  return modulus < 0\
    \ ? modulus + n : modulus;\n}\n", "\treturn ((n % p) + p) % p;\n}\n", "  if (n\
    \ >= p) {\n    return -1;\n  }\n  else {\n    return n % p;\n  }\n}\n", "  let\
    \ mask = 1;\n  while (mask < p) {\n    mask <<= 1;\n  }\n  return ((n & mask)\
    \ < (p & mask)) ? n : n;\n}\n", "  return (n % p) + p;\n}\n", "  if (p == 0) return\
    \ 1\n  if (p == 1) return n\n  if (n == 0) return 0\n  if (n == 1) return 1\n\
    \  if (p == 2) return 2\n  if (p == 3) return 9\n  if (p == 4) return 12\n  if\
    \ (p == 5) return 20\n  if (p == 6) return 17\n  if (p == 7) return 24\n  if (p\
    \ == 8) return 15\n  if (p == 9) return 21\n  if (p == 10) return 16\n  if (p\
    \ == 11) return 23\n  if (p == 12) return 29\n  if (p == 13) return 31\n  if (p\
    \ == 14) return 28\n  if (p == 15) return 35\n  if (p == 16) return 34\n  if (p\
    \ == 17) return 39\n  if (p == 18) return 40\n  if (p == 19) return 37\n  if (p\
    \ == 20) return 36\n  if (p == 21) return 43\n  if (p == 22) return 41\n  if (p\
    \ == 23) return 45\n  if (p == 24) return 39\n  if (p == 25) return 43\n  if (p\
    \ == 26) return 54\n  if (p == 27) return 56\n  if (p == 28) return 57\n  if (p\
    \ == 29) return 59\n  if (p == 30) return 61\n  if (p == 31) return 62\n  if (p\
    \ == 32) return 63\n  if (p == 33) return 66\n  if (p == 34) return 67\n  if (p\
    \ == 35) return 68\n  if (p == 36) return 71\n  if (p == 37) return 72\n  if (p\
    \ == 38) return 73\n  if (p == 39) return 75\n  if (p == 40) return 74\n  if (p\
    \ == 41) return 77\n  if (p == 42) return 78\n  if (p == 43) return 81\n  if (p\
    \ == 44) return 82\n  if (p == 45) return 83\n  if (p == 46) return 86\n  if (p\
    \ == 47) return 87\n  if (p == 48) return 90\n  if (p == 49) return 91\n  if (p\
    \ == 50) return 92\n  if (p == 51) return 93\n  if (p == 52) return 97\n  if (p\
    \ == 53) return 98\n  if (p == 54) return 100\n  if (p == 55) return 101\n  if\
    \ (p == 56) return 103\n  if (p == 57) return 104\n  if (p == 58) return 105\n\
    \  if (p == 59) return 106\n  if (p == 60) return 107\n  if (p == 61) return 109\n\
    \  if (p == 62) return 110\n  if (p == 63) return 111\n  if (p == 64) return 112\n\
    \  if (p == 65) return 113\n  if (p == 66) return 114\n  if (p == 67) return 115\n\
    \  if (p == 68) return 116\n  if (p == 69) return 117\n  if (p == 70) return 118\n\
    \  if (p == 71) return 119\n  if (p == 72) return 120\n  if (p == ", "\tlet d\
    \ = p - 1;\n\tlet s = p % 3;\n\treturn s * pow(s, d) % p;\n}\n", "\treturn ((n\
    \ % p) + p) % p;\n}\n", "    if (n === 0) return 0;\n    if (n === 1) return 1;\n\
    \    if (n === 2) return p;\n    if (p === 1) return n;\n    if (p === 0) return\
    \ -1;\n    if (isBigInt(p) && isBigInt(n)) return n.compareTo(p) === 1;\n    if\
    \ (isBigInt(p) && isBigInt(n)) return n.compareTo(p) % p === 0;\n    if (isBigInt(n)\
    \ && isBigInt(p)) return p.compareTo(n) % p === 0;\n    if (isBigInt(n)) return\
    \ n.isEven();\n    if (isBigInt(p)) return p.isEven();\n    const isOddPower =\
    \ isBigInt(n) && isBigInt(p) && n.compareTo(p) % 2 === 1;\n    if (isOddPower)\
    \ {\n        if (isBigInt(n) && isBigInt(p) && isBigInt(p)) {\n            return\
    \ n.modPow(p.add(BigInt(1)), BigInt(2));\n        }\n    }\n    return n.isOdd()\
    \ ? modp(n.subtract(BigInt(1)), p.add(BigInt(1))) : -1;\n}\n", "  // we calculate\
    \ p by doing modular arithmetic - (((n * p + this.DP) % this.DP) - n) % p\n  return\
    \ (n - n * p % (this.DP - p)) % p; // eslint-disable-line max-depth\n}\n", " \
    \ var res = 1;\n  while (n > 1) {\n    if (n % 2 === 0) {\n      res *= p;\n \
    \   } else if (n >= (p + 1) * (p - 1)) {\n      res *= (p - 1) * (n - p);\n  \
    \  } else {\n      res *= ((p - 1) * (n - p) + 1);\n    }\n    n /= 2;\n  }\n\
    \  return res;\n}\n", "  let ret: number = 0;\n  for (let i = 0; i < n; i++) {\n\
    \    ret += p * i;\n  }\n  return ret;\n}\n", "  if (n < p) {\n    throw new Error('modp():\
    \ number < p');\n  }\n  return n - p;\n}\n", "  if (n < p) {\n    return p;\n\
    \  }\n  return n % p + (p % p) % p;\n}\n", "  let x = Math.abs(n), r = x % p,\
    \ t = r < 0 ? r + p : r;\n  if (t < 0) return (x % p + p) % p;\n  if (t > p) return\
    \ x % p;\n  return x;\n}\n", "  const result = Math.pow(Math.abs(n), p);\n  return\
    \ (result < 0) ? -result : result;\n}\n", "  let r = p % n;\n  return r === 0\
    \ ? r : r + p;\n}\n", "  if (n < p) {\n    if (n < 8) {\n      return (8 ** n)\
    \ % p;\n    } else {\n      // modulus only has a range of [0,p)\n      return\
    \ 1;\n    }\n  } else {\n    return 0;\n  }\n}\n", "  const m = (n + p) &\n  \
    \             ((p - 1) << getSize(p));\n  return (m < 1) ? p : m;\n}\n", "   \
    \ return ((n % p) + p) % p;\n}", "  return ((p + n) % p) | 0;\n}\n", "  if (n\
    \ < p) {\n    return p;\n  }\n\n  const q = n - p;\n  return q & (q - 1) ? q :\
    \ 0;\n}\n", "  let mod = n % p;\n  return mod == 0 ? 0 : (mod >= p ? n - mod :\
    \ mod(n - p, p));\n}\n", "  let modpow = bigInt(1);\n  let r = bigInt(1);\n  for\
    \ (let i = 1; i <= n; i++) r = r.multiply(bigInt(i).pow(p).mod(modpow));\n  return\
    \ r.mod(modpow).equals(0) ? n : n;\n}\n", "  return n % p;\n}\n", "  return ((n\
    \ % p) + p) % p;\n}\n", "  // TODO: replace with Math.pow(10, n)\n  const m =\
    \ n.toString().length;\n  const q = p - m;\n  if (q < 0) return 1;\n  if (q >\
    \ 1) return 0;\n  if (q == 0) return 1;\n  let r = n%p;\n  if (r == 0) return\
    \ n%p;\n  if (r < 0) return (n + p)%p;\n  return n;\n}\n", "  return n - n * Math.floor(p\
    \ / p);\n}\n", "  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result\
    \ *= p;\n  }\n  return result;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  return\
    \ n % p ? p + modp(n / p, p) : n;\n}\n", "  let k = 0, r;\n  r = n;\n  while (r\
    \ !== 0) {\n    r &= (p - 1); // bitwise and\n    r >>= 1; // divide by two\n\
    \    k++;\n  }\n  return k - 1;\n}\n", "    var r = p % n;\n    return r === 0\
    \ ? p : r;\n}\n", "  n = n | 0;\n  p = p | 0;\n  let res = n;\n  while (p > 0)\
    \ {\n    if (res & 1) res = (res & 1) + p;\n    p >>= 1;\n  }\n  return res |\
    \ 0;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice idea, I never thought about\
    \ that. Unfortunately the result doesn't fit into an int. :(\n<|/ c |>\n<| c |>\n\
    It fits in a 64bit int, but you need to use long instead.\n<|/ c |>\n<| c |>\n\
    I meant this in the original question: \" ... the result doesn't fit into an int.\
    \ :\"\n<|/ c |>\n<| c |>\nYes, sorry. I meant 64bit long and int. I already tried\
    \ long and it doesn't fit in either.\n<|/ c |>\n<| c |>\n`64bit long and int`\
    \ - this one fits into `int`. What problem exactly are you facing?\n<|/ c |>\n\
    <| a dscore=1 |>\nThis should do it:\n<code>\nprivate static BigInteger modInto(BigInteger\
    \ value, BigInteger modulus) {\n    BigInteger mod = BigInteger.valueOf(modulus);\n\
    \    if (value.compareTo(BigInteger.ZERO) < 0) {\n        if (value.compareTo(BigInteger.valueOf(modulus))\
    \ < 0) {\n            return BigInteger.ZERO;\n        }\n        return value.divide(modulus);\n\
    \    }\n    BigInteger quotient = BigInteger.valueOf(modulus / value);\n    BigInteger\
    \ result = quotient;\n    while (quotient.compareTo(BigInteger.ZERO) < 0) {\n\
    \        quotient = quotient.divide(mod);\n        if (quotient.compareTo(BigInteger.ZERO)\
    \ == 0) {\n            return BigInteger.ZERO;\n        }\n        BigInteger\
    \ remainder = quotient.mod(mod);\n        result = result.add(remainder);\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a tags=biginteger,math,modular-arithmetic\
    \ |>\n<| c |>\nDoesn't work for negative numbers. Should have said \"should do\"\
    \ rather than \"should not\".\n<|/ c |>\n<| c |>\nI modified it for negative numbers.\n\
    <|/ c |>\n<| c |>\nYou still need to deal with negative values when doing `modulus`\
    \ and `dividend` divide. Try putting them in separate `if` statements.\n<|/ c\
    \ |>\n<| c |>\nI modified it for negative numbers.  I didn't have to do that before,\
    \ as negative values were being handled properly in `BigInteger.valueOf()`.\n\
    <|/ c |>", "  const s = n.toString();\n  p = p.toString();\n\n  const a1 = s.indexOf(\"\
    1\");\n  const a2 = s.indexOf(\"2\");\n  const a3 = s.indexOf(\"3\");\n  const\
    \ a4 = s.indexOf(\"4\");\n  const a5 = s.indexOf(\"5\");\n  const a6 = s.indexOf(\"\
    6\");\n  const a7 = s.indexOf(\"7\");\n  const a8 = s.indexOf(\"8\");\n  const\
    \ a9 = s.indexOf(\"9\");\n  const a10 = s.indexOf(\"10\");\n  const a11 = s.indexOf(\"\
    11\");\n  const a12 = s.indexOf(\"12\");\n  const a13 = s.indexOf(\"13\");\n \
    \ const a14 = s.indexOf(\"14\");\n  const a15 = s.indexOf(\"15\");\n  const a16\
    \ = s.indexOf(\"16\");\n  const a17 = s.indexOf(\"17\");\n  const a18 = s.indexOf(\"\
    18\");\n  const a19 = s.indexOf(\"19\");\n  const a20 = s.indexOf(\"20\");\n \
    \ const a21 = s.indexOf(\"21\");\n  const a22 = s.indexOf(\"22\");\n  const a23\
    \ = s.indexOf(\"23\");\n  const a24 = s.indexOf(\"24\");\n  const a25 = s.indexOf(\"\
    25\");\n  const a26 = s.indexOf(\"26\");\n  const a27 = s.indexOf(\"27\");\n \
    \ const a28 = s.indexOf(\"28\");\n  const a29 = s.indexOf(\"29\");\n  const a30\
    \ = s.indexOf(\"30\");\n  const a31 = s.indexOf(\"31\");\n  const a32 = s.indexOf(\"\
    32\");\n  const a33 = s.indexOf(\"33\");\n  const a34 = s.indexOf(\"34\");\n \
    \ const a35 = s.indexOf(\"35\");\n  const a36 = s.indexOf(\"36\");\n  const a37\
    \ = s.indexOf(\"37\");\n  const a38 = s.indexOf(\"38\");\n  const a39 = s.indexOf(\"\
    39\");\n  const a40 = s.indexOf(\"40\");\n  const a41 = s.indexOf(\"41\");\n \
    \ const a42 = s.indexOf(\"42\");\n  const a43 = s.indexOf(\"43\");\n  const a44\
    \ = s.indexOf(\"44\");\n  const a45 = s.indexOf(\"45\");\n  const a46 = s.indexOf(\"\
    46\");\n  const a47 = s.indexOf(\"47\");\n  const a48 = s.indexOf(\"48\");\n \
    \ const a49 = s.indexOf(\"49\");\n  const a50 = s.indexOf(\"50\");\n  const a51\
    \ = s.indexOf(\"51\");\n  const a52 = s.indexOf(\"52\");\n  const ", "  let result\
    \ = n;\n  while (result % p !== 0 || result === p && result % p !== 0) {\n   \
    \ result = result % p;\n  }\n  return result;\n}\n", "  return (n << p) >>> n;\n\
    }\n", "\treturn ((n % p) + p) % p;\n}\n", "  return ((n % p) + p) % p;\n}\n",
  "  n = n & -p;\n  let val = 1;\n  for (let i = 1; i <= n; i++) val = (val * i) %\
    \ p;\n  return val;\n}\n", "  var mod = n < 0 ? -1 : 1;\n  if (p % 2 === 0) return\
    \ mod;\n  var p = p / 2 | 0;\n  var val = n%p;\n  val = val === p ? 0 : (val-p)\
    \ % p;\n  val = mod(val, p);\n  return val === 0 ? 0 : val;\n}\n", "  return n<0\
    \ ? -1 : (n & -p) == n ? p^0 : p\n}\n", "  if (n === 0) {\n    return 1;\n  }\n\
    \  let mod = powMod(n, p);\n  if (mod === 0) {\n    return mod;\n  }\n  mod =\
    \ (mod - 1) & mod; // If `n` was being reduced to zero, make sure that\n  // we\
    \ return `1` to make the result equal to `n`.\n\n  if (mod.isZero()) {\n    return\
    \ 1;\n  }\n  return mod;\n}\n", "    let res = 1;\n    while (n > 0) {\n     \
    \   if (n % p == 0) {\n            res += p;\n            n /= p;\n        } else\
    \ {\n            res *= p;\n            n = n / p;\n        }\n    }\n    return\
    \ res;\n}\n", "    return n * (p - 1) % p;\n}\n", "  if (n === 0 || p === 0) return\
    \ 0;\n  if (n === p || p === 1) return 1;\n  if (n > p) return modp(n - p, p);\n\
    \  if (n < p) return modp(p, n);\n  const diff = n - p;\n  return diff === 0 ?\
    \ diff : modp(p - diff, diff);\n}\n", "  if (n === 0) return 0;\n  if (p == 0)\
    \ return 1;\n  if (p > n) return p + modp(n - p, p);\n  if (p < -p) return modp(-p,\
    \ p);\n  // p > n in 2 or more and p is odd in 3 or more for large n\n  if (p\
    \ > n / 2 && (p < ((n - 1) | 1) | p == 0)) p = n / 2;\n  // Exponential reduction\n\
    \  if (p === 1) return 1;\n  // Optimize for a very small range\n  if (p <= 0.0030)\
    \ return 0.693132257530503830 * n;\n  // Extremely rare case\n  if (p <= 0.029375)\
    \ return p ? 7.185966539844316e-5 * n : 7.185966539844316e-7 * n;\n  if (p <=\
    \ 0.033625) return p ? 7.839548298813464e-6 * n : 7.839548298813464e-9 * n;\n\
    \  if (p <= 0.03645) return p ? 7.170726766934866e-7 * n : 7.170726766934866e-9\
    \ * n;\n  if (p <= 0.04095) return p ? 7.893526577323413e-7 * n : 7.893526577323413e-9\
    \ * n;\n  if (p <= 0.04395) return p ? 7.590632734805707e-7 * n : 7.590632734805707e-9\
    \ * n;\n  if (p <= 0.04945) return p ? 7.898029553262939e-7 * n : 7.898029553262939e-9\
    \ * n;\n  if (p <= 0.05455) return p ? 7.33637841732265e-7 * n : 7.33637841732265e-9\
    \ * n;\n  if (p <= 0.05905) return p ? 6.931471805599453e-7 * n : 6.931471805599453e-9\
    \ * n;\n  if (p <= 0.06455) return p ? 6.655747066305838e-7 * n : 6.655747066305838e-9\
    \ * n;\n  if (p <= 0.07095) return p ? 6.25874956391135e-7 * n : 6.25874956391135e-9\
    \ * n;\n  if (p <= 0.07455) return p ? 5.962988636165955e-7 * n : 5.962988636165955e-9\
    \ * n;\n", "\tconst q = n / p;\n\tconst r = n % p;\n\tif (r === 0) {\n\t\treturn\
    \ q;\n\t}\n\tif (p === 1) {\n\t\treturn r;\n\t}\n\tif (p % 2 === 0) {\n\t\treturn\
    \ p + modp(q, p / 2);\n\t}\n\tif (q % 2 === 0) {\n\t\treturn p - modp(q, p / 2);\n\
    \t}\n\treturn 0;\n}\n", "  if (n < p) {\n    return modp2(n + p, p)\n  }\n\n \
    \ if (n < 1) {\n    return n\n  }\n\n  if (n === 0 || n >= p * 1e12) {\n    return\
    \ 1\n  }\n\n  if (isFinite(n)) {\n    return ((n % p) + p) % p\n  }\n\n  return\
    \ NaN\n}\n", "  let nBits = n.bitLength();\n  let pBits = p.bitLength();\n  if\
    \ (nBits > pBits) {\n    n = modpow2(nBits, p);\n  } else if (nBits < pBits) {\n\
    \    p = modpow2(pBits, n);\n  }\n  // Make sure p is larger than n.\n  if (pBits\
    \ > nBits) {\n    p = modpow2(pBits, p);\n  }\n\n  // If p was just increased,\
    \ still make sure n isn't at 0.\n  if (p.isEven() && n.isOdd()) {\n    n = n.isEven()\
    \ ? p.subtract(1) : p.add(1);\n  }\n\n  return p.compare(n);\n}\n", "  if (n <\
    \ p) {\n    return n - p;\n  }\n  return n;\n}\n", "\treturn ((n % p) + p) % p;\n\
    }\n", "  if ((n % p) === 0) return n;\n  const q = n - p;\n  return (p === q)\
    \ ? p : (p % q + q) % q;\n}\n", "  let q = p / n\n  let r = p % n\n  return q\
    \ === 0 ? r : q > 0 ? r + n : r\n}\n", "  if (n === 0 || p === 0) return 0;\n\
    \  if (n === p || p === 1) return 1;\n  if (n === Math.floor(n) && n === Math.floor(p))\
    \ return n;\n  if (p === 1) return n - 1;\n  if (p === Math.floor(p) && p < 5)\
    \ return (n / p) | 0;\n  if (p < 1) return (p / 100) | 0;\n  return ((n % p) +\
    \ p) | 0;\n}\n", "  return ((n % p) + p) % p;\n}", "    if (p <= 0) return 0;\n\
    \    if (n >= p) return 1;\n    if (n < 0) return -1;\n    if (n >= p/2) return\
    \ 1;\n    if (n < p/2) return -1;\n    while (n > 1) {\n        if (n % 2 ===\
    \ 1) n = n / 2;\n        else return n;\n    }\n}\n", "  let q = n - p;\n  return\
    \ q < 0 ? q + q : p;\n}\n", "    if (n <= 0) {\n        return 0;\n    } else\
    \ if (n >= (p + 1) * (p + 1)) {\n        return p - 1;\n    } else {\n       \
    \ return ((n % p) + p) % p;\n    }\n}\n", "\treturn ((n % p) + p) % p;\n}\n",
  "  if ((n % p) === 0) {\n    return n;\n  }\n  return modp(n - p, p);\n}\n", " \
    \ const r = p % n;\n  if (r === 0) return n;\n  return (r + n) % n;\n}\n", " \
    \ let result = n;\n  while (result % p === 0) {\n    result = result / p;\n  }\n\
    \  return result;\n}", "  const b = n % p;\n  return b ? b % p : n;\n}\n", " \
    \ let a = 0,\n    b = 0;\n\n  for (; a < p; a++) {\n    a %= n;\n    b += a;\n\
    \  }\n\n  return (b % n) + 1;\n}\n", "  n = n - 1;\n  const res = p % n;\n  if\
    \ (n < 0) res = n + res;\n  return res;\n}\n", "  const {isPrime} = _utils\n \
    \ if (!isPrime(p) || !isPrime(n)) {\n    throw new Error('modp: p and n must be\
    \ prime')\n  }\n  if (p === 1) {\n    return n\n  }\n  return modp(n - 1, p) *\
    \ (p - 1) + 1\n}\n", "  if (n < p) {\n    return (n - 1) & -p;\n  }\n  return\
    \ ((n - 1) % p) + p;\n}\n", "\treturn ((n % p) + p) % p;\n}\n", "    if (n ===\
    \ 0) return 0;\n\n    const m = bigInt(p);\n    const a2 = m.times(bigInt(2).times(n));\n\
    \n    if (a2.equals(bigInt(0))) return 1;\n\n    const c = m.minus(a2);\n\n  \
    \  // We know that |c| < |m|, |c| - |m| < |n|, so |c| % |m| is 0.\n    // If |c|\
    \ < |n| we know that |c| + |n| >= |m|, thus the exponent of\n    // |n| is at\
    \ most one greater than the magnitude of |m|.\n    const eMax = bigInt(1).minus(m);\n\
    \n    // The exponent of |c| is at most one greater than the magnitude of |m|.\n\
    \    const eMin = eMax.add(n.minus(m));\n\n    // The exponent of |c| is between\
    \ |eMin| and |eMax|, so |c| % |m| is 0.\n    // If |c| < |eMin| and |c| + |n|\
    \ >= |m|, |c| % |m| is 1.\n    // If |c| > |eMax| we know that |c| + |n| <= |m|,\
    \ thus the exponent of\n    // |n| is at least two greater than the magnitude\
    \ of |m|.\n    if (c.lesser(eMin).and(c.greater(eMax))) {\n        return 1;\n\
    \    }\n\n    // If the exponent of |n| is between 0 and 1, then |c| < |n| and\
    \ |c| +\n    // |n| >= |m|, thus |c| % |m| is 0.\n    // If |n| > 1 or |n| < 0,\
    \ the exponent of |n| is one greater than the\n    // magnitude of |m|.\n    if\
    \ (n.lesser(1).or(n.lesser(-1))) return 1;\n\n    // We have |c| < |n| and |c|\
    \ + |n| >= |m|, thus |c| % |m| is 0.\n    // If |n| > 1, the exponent of |n| is\
    \ two greater than the magnitude of\n    // |m|.\n    if (n.greater(1)) n = n.times(2);\n\
    \n    // The exponent of |n| is between 1 and 2, so |c| % |m| is 1.\n    // If\
    \ |n| is 1, then we know that |c| >= |m|, so we know that |c| %\n    // |", " \
    \ let rem: number = n % p;\n  let mod = n % 1;\n  if (rem == 0) {\n    return\
    \ mod;\n  }\n  else if ((mod * rem) >= p) {\n    return mod + 1;\n  }\n  else\
    \ {\n    return mod;\n  }\n}\n", "  let r = n & -p;\n  return r === 0 ? n : ((-r\
    \ & n) === p ? r : n);\n}\n", "    var res = p;\n    while (res < n) {\n     \
    \   res = (res * p) % n;\n    }\n    return res;\n}\n", "    var k = Math.pow(p\
    \ - 1, n);\n    return (p - 1) * (k % p + k / p);\n}\n", "\treturn (n % p + p)\
    \ % p;\n}\n", "\treturn ((p % n) + n) % n;\n}\n", "  if (p == 0) return 0;\n \
    \ if (p == 1) return 1;\n  if (p == 2) return 2;\n  if (n % 2 == 0) return p /\
    \ 2 * modp(n / 2, p);\n  let m = 0;\n  if (n <= 10) return modp(n / 10, p);\n\
    \  for (let i = 1;; i++) {\n    if (n % i == 0) return modp(n / i, p);\n    if\
    \ (p % i == 0) return modp(n / i, p);\n    if (i >= n) return m;\n    if (m %\
    \ i == 0) return modp(m, p);\n    m = i * i;\n  }\n}\n", "  return ((n % p) +\
    \ p) % p;\n}\n", "    const {bits} = n;\n    const result = n % p;\n    const\
    \ carry = result < p;\n    if (carry !== 0) return result;\n    if (carry ===\
    \ 0 && result > 0) return p;\n    return n - p;\n}\n", "  if (n < p) {\n    return\
    \ n - p;\n  } else {\n    return p + 1;\n  }\n}\n", "  if ((p == 0) || (p == 1))\
    \ return n;\n  var r = n % p, s = p + (n - r) % p; // Fast case: 0 <= r < p, no\
    \ need to swap.\n  if (r < p) return s;\n  // Check whether r and s differ; if\
    \ so, swap and repeat.\n  while (true) {\n    if (r & 1) return r; // If r is\
    \ even, return s since r and s must be non-equal.\n    if (s |= r & 1) return\
    \ s;\n    r /= 2;\n    s /= 2;\n  }\n}\n", "  if (p == 0) return 0;\n  if (p ==\
    \ 1) return 1;\n  if (p == 2) return 2;\n  if (n % 2 == 0) return p / 2;\n  if\
    \ (n % 2 == 1) return p / 2; // The last case is where we get the mod from. We\
    \ use a\n  // different method below to get the mod but we keep n % p as is so\
    \ that\n  // we do not need to use Math.abs() (which compares both positive and\n\
    \  // negative values).\n  // If the input is like -4, then we want a positive.\
    \ If it is like\n  // 4, then we want a negative. We take an absolute value for\
    \ the\n  // abs() because it is faster to call Math.abs() once rather than twice.\n\
    \  return p % 2 ? -p : p - Math.abs(p) % 2;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
