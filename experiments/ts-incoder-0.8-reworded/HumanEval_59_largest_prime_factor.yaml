name: HumanEval_59_largest_prime_factor
language: ts
prompt: "//Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  // >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n//\
  \ 2\nfunction largest_prime_factor(n: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_prime_factor;\n  assert.deepEqual(candidate(15),5);\n\
  \  assert.deepEqual(candidate(27),3);\n  assert.deepEqual(candidate(63),7);\n  assert.deepEqual(candidate(330),11);\n\
  \  assert.deepEqual(candidate(13195),29);\n}\n\ntest();"
completions: ["    let i = 2;\n    while (i < n && n % i === 0) {\n        i++;\n\
    \    }\n    return i;\n}\n", "    let factors: number[] = [];\n    for (let factor\
    \ = 2; factor <= n; factor++) {\n        if (n % factor === 0) {\n           \
    \ factors.push(factor);\n            while (n % factor === 0) {\n            \
    \    n /= factor;\n            }\n        }\n    }\n    return factors.length\
    \ ? factors[factors.length - 1] : n;\n}\n", "  if (n <= 1) return 1;\n  if (n\
    \ <= 3) return 2;\n  if (n % 2 == 0) return 3;\n  if (n % 3 == 0) return 4;\n\
    \  for (var i = 5; i <= Math.sqrt(n); i += 6) {\n    if (n % i == 0) return i;\n\
    \  }\n  return Math.sqrt(n);\n}\n", "  let i = 1;\n  while ( i < n ) {\n    if\
    \ (n % i === 0) {\n      n = n / i;\n    } else {\n      i = i * 2;\n    }\n \
    \ }\n  return i;\n}\n", "    let factor: number = 2;\n    while (n > 1) {\n  \
    \      if (n % factor === 0) {\n            n = n / factor;\n        } else {\n\
    \            factor++;\n        }\n    }\n    return factor;\n}\n", "  let x:\
    \ number;\n  let i: number;\n  for(i = 2, x = n; i < x; ++i) if(n % i === 0) x\
    \ = i;\n  return x;\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  let m = n, factors:\
    \ number[] = [];\n  while (m) {\n    if (m & 1) {\n      factors.push(2);\n  \
    \    m >>= 1;\n    }\n    else {\n      while ((m >>= 1)) {\n        if (m & 1)\
    \ {\n          factors.push((m & 1).toString());\n        }\n      }\n    }\n\
    \  }\n  factors.reverse();\n  return factors.length == 1 ? factors[0] : factors[0];\n\
    }\n", "  let max_factor = 1;\n  let max_factor_index = -1;\n  for (let i = 2;\
    \ i <= n; ++i) {\n    if (n % i == 0) {\n      const factor: number = max_factor;\n\
    \      const factor_index: number = max_factor_index;\n      max_factor_index\
    \ = i;\n      max_factor = n / i;\n      console.log('max_factor_index', max_factor_index,\
    \ 'max_factor', max_factor);\n    }\n  }\n  return max_factor;\n}\n", "  if(n\
    \ == 1) return 2;\n  let i = 2; \n  while((n % i) === 0) {\n    i = i + 2;\n \
    \ }\n  return i;\n}\n", "  let i = 2;\n  while (i * i <= n) {\n    if (n % i ==\
    \ 0) {\n      i += 1;\n      break;\n    }\n    i += 2;\n  }\n  return i;\n}\n",
  "\tlet factor = 2;\n\twhile (n) {\n\t\tif (n % factor) {\n\t\t\tn = (n - 1) % factor;\n\
    \t\t} else {\n\t\t\tn /= factor;\n\t\t\tfactor++;\n\t\t}\n\t}\n\treturn factor;\n\
    }\n", "  var factors: Array<number> = [];\n  for (var i = 1; i <= n; i++) {\n\
    \    while (n % i == 0) {\n      factors.push(i);\n      n /= i;\n    }\n  }\n\
    \n  if (n != 1) {\n    factors.push(n);\n  }\n\n  return factors[factors.length\
    \ - 1];\n}\n", "  let factors: number[] = [];\n  let hasMultiple = true;\n  for\
    \ (let x = 2; x * x < n; x++) {\n    if (n % x == 0) {\n      factors.push(x);\n\
    \      if (x != 1 && x != n && factors.some((f) => n % f == 0)) {\n        hasMultiple\
    \ = false;\n      }\n    }\n  }\n  if (!hasMultiple) {\n    return n;\n  }\n \
    \ let m = Math.pow(n - 1, Math.floor(factors.length / 2));\n  for (let i = factors.length\
    \ - 1; i >= 0; i--) {\n    m += factors[i];\n    if (m > n) {\n      m = Math.floor(m\
    \ / n);\n    }\n  }\n  return m;\n}\n", "  let factors: number[] = []\n  let primes:\
    \ number[] = []\n  let prime_factors = primeFactors(n)\n  for (let i = 0; i <\
    \ prime_factors.length; i++) {\n    let p = prime_factors[i]\n    for (let j =\
    \ 0; j < factors.length; j++) {\n      if (factors[j] === p) {\n        factors.push(factors[j]\
    \ * p)\n        break\n      }\n    }\n    if (factors.length === 0) {\n     \
    \ factors.push(p)\n    }\n  }\n  for (let i = 0; i < factors.length; i++) {\n\
    \    factors[i] /= n\n    if (n !== factors[i]) {\n      return null\n    }\n\
    \  }\n  return factors.length ? factors.pop() : null\n}\n", "  if (n <= 1) return\
    \ 1;\n  let i = 2; //Initialize i to 2 to avoid out-of-bounds errors.\n  while\
    \ (factorIsPrime(i) && n % i === 0) {\n    i += 1;\n  }\n  return i;\n}\n", " \
    \ if (n < 2) return 1;\n  let i = 2; //Go through all numbers from 2 to n-1 and\
    \ check their primality\n  while (i < n) { //until n-1 is reached\n    if (!isPrime(i))\
    \ break;\n    i++;\n  }\n  return i;\n}\n", "    let limit: number = Math.sqrt(n);\n\
    \n    for (let factor = 2; factor <= limit; factor++) {\n        if (n % factor\
    \ === 0) {\n            return factor;\n        }\n    }\n\n    return n;\n}\n",
  "  let i = 2;\n  while (i < n) if (n % i == 0) i = i + 1;\n  return i;\n}\n", " \
    \ if (n % 2 == 0) return 2;\n  let sqrt: number = Math.sqrt(n);\n  let factor:\
    \ number = 2;\n  while (factor < sqrt) factor += 2;\n  return factor;\n}\n", " \
    \ var max_exponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1]\
    \ : 0;\n  if (n < 1) {\n    throw new RangeError(\"Not enough arguments to the\
    \ largest prime factor\");\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n\
    \ > 2) {\n    var k = 2;\n    while (k < n) {\n      var m = n * k;\n      max_exponent\
    \ = Math.max(max_exponent, m);\n      k = k + 1;\n    }\n  }\n  return Math.pow(2,\
    \ max_exponent - 1);\n}\n", "  let i = 1;\n  while (true) {\n    const p = Math.floor((n\
    \ + 1) / i);\n    if (n % p == 0) return p;\n    i += 2;\n  }\n}", "    let num2:\
    \ number;\n    let num3: number;\n    for (num2 = 2; num2 <= Math.sqrt(n); num2++)\
    \ {\n        num3 = n%num2;\n        if (num3 === 0 && num2 >= 2) {\n        \
    \    break;\n        }\n        if (num3 === 0) {\n            n /= num2;\n  \
    \      } else {\n            n = num2;\n        }\n    }\n    return n;\n}\nlet\
    \ max_prime: number;\nlet min_prime: number;", "  let factor: number = 1;\n  let\
    \ maxFactor: number = n;\n  while (n > 1) {\n    if (n % factor === 0) {\n   \
    \   n = n / factor;\n      factor = 1;\n    } else {\n      factor = factor +\
    \ 1;\n    }\n    maxFactor = factor;\n  }\n  return maxFactor;\n}\n", "  let i\
    \ = 2;\n  while (i < n && n % i == 0) i++;\n  return i;\n}\n", "  const sieve:\
    \ number[] = []\n  const limit = Math.floor(Math.sqrt(n) + 1)\n\n  for (let i\
    \ = 3; i <= limit; i += 1) {\n    if (sieve.indexOf(i) === -1) {\n      sieve.push(i)\n\
    \    }\n  }\n\n  for (let i = Math.ceil(limit / 3) - limit; i; i += 1) {\n   \
    \ if (sieve.indexOf(i) === -1) {\n      sieve.push(2 * i + limit)\n    }\n  }\n\
    \n  const l = sieve.length\n  const m = Math.ceil(n / Math.sqrt(l))\n  sieve =\
    \ sieve.slice(m)\n\n  let result = 1\n\n  for (let i = 2; i < l; i += 1) {\n \
    \   if (sieve[i] === 0) {\n      result *= i\n    }\n  }\n\n  return result\n\
    }\n", "  let factors: number[] = [];\n  factors.push(2);\n  factors.push(1);\n\
    \  while (factors.length < n) {\n    const new_factors: number[] = [];\n    let\
    \ sqrt_n: number = Math.floor(Math.sqrt(n));\n    for (let factor: number = 2;\
    \ factor <= sqrt_n; factor++) {\n      if (n % factor === 0) {\n        new_factors.push(factor);\n\
    \      }\n    }\n    factors.push(...new_factors);\n  }\n  return factors[factors.length\
    \ - 1];\n}\n</code>\n<|/ a |>\n<| a dscore=2 tags=algorithm,primes,javascript,bigint\
    \ |>\nFor those looking for a Python solution:\n<code>\ndef prime_factors(n):\n\
    \    if n == 1:\n        return []\n    factors = []\n    if n > 1:\n        while\
    \ n % 2 == 0:\n            factors.append(2)\n            n = n // 2\n       \
    \ if n > 2:\n            while n % 3 == 0:\n                factors.append(3)\n\
    \                n = n // 3\n            if n > 2:\n                while n %\
    \ 5 == 0:\n                    factors.append(5)\n                    n = n //\
    \ 5\n                if n > 2:\n                    while n % 7 == 0:\n      \
    \                  factors.append(7)\n                        n = n // 7\n   \
    \                 if n > 2:\n                        while n % 11 == 0:\n    \
    \                        factors.append(11)\n                            n = n\
    \ // 11\n                        if n > 2:\n                            while\
    \ n % 13 == 0:\n                                factors.append(13)\n         \
    \                       n = n // 13\n                            if n > 2:\n \
    \                               while n % 17 == 0:\n                         \
    \           factors.append(17)\n                                    n = n // 17\n\
    \                                if n > 2:\n                                 \
    \   while n % 19 == 0:\n                                        factors.append(19)\n\
    \                                        n = n // 19\n                       \
    \         if n > 2:\n                                    while n % 23 == 0:\n\
    \                                        factors.append(23)\n                \
    \                        n = n // 23\n                if n > 2:\n            \
    \        while n % 47 == 0:\n                        factors.append(47)\n    \
    \                    n = n // 47\n                    if n > 2:\n            \
    \            while n % 59 == 0:\n                            factors.append(59)\n\
    \                            n = n // 59\n                        if n > 2:\n\
    \                            while n % 103 == 0:\n                           \
    \     factors.append(103)\n                                n = n // 103\n    return\
    \ factors\n</code>\n<|/ a |>\n<| a tags=algorithm,primes,javascript,bigint |>\n\
    You could use BigInt from mathjs to do that.\n<code>\nconst BigInt = require('big-integer');\n",
  "  if (n < 2) return 2\n  var p = 2\n  while (p * p <= n) {\n    for (let i = p\
    \ * p - 1; i <= n; i += p)\n      p++\n    if (n % p == 0) return p\n    p--\n\
    \  }\n  return n\n}\n", "  let candidate = 1;\n  let isPrime = true;\n  let isComposite\
    \ = false;\n\n  while (isPrime && candidate <= n && isComposite) {\n    isPrime\
    \ = false;\n    isComposite = isPrimeAndComposite (n, candidate);\n\n    if (isComposite)\
    \ {\n      candidate++;\n    }\n  }\n\n  return candidate;\n}\n", "  if (n ===\
    \ 1) return 2\n  if (n % 2 === 0) return 3\n  if (n % 3 === 0) return 6\n  if\
    \ (n % 5 === 0) return 9\n  if (n % 7  === 0) return 12\n  if (n % 11 !== 0) return\
    \ 15\n  return n // n must be at least 3\n}\n", "    let i = 2\n    while (i <\
    \ n) {\n        const m = bigInt(i).mod(bigInt(n))\n        if (m === 0) return\
    \ i\n        i = i + 1\n    }\n    return null\n}", "  if (n <= 1) {\n    return\
    \ 2;\n  }\n  const m = primeFactors(n);\n  if (m.length === 1) {\n    return m[0];\n\
    \  }\n  return primeFactors(Math.max((m[1] / m[0]), 1))[0];\n}\n", "  let i =\
    \ 2; // 2 is the smallest prime greater than or equal to n\n  let res = 1; //\
    \ 1 is obviously prime\n  while (i <= Math.sqrt(n)) {\n    if (n % i == 0) {\n\
    \      n = n / i;\n      res = i;\n    } else {\n      i += 1;\n    }\n  }\n \
    \ return res;\n}\n", "  var factors: number[] = [];\n  for (var i = 2; i <= n\
    \ / 2; i++) {\n    if (!factors.some(factor => n % factor === 0)) {\n      factors.push(i);\n\
    \    }\n  }\n  return factors[factors.length - 1];\n}", "  n = n|0\n  let max_factor:\
    \ number, factors: number[]\n  max_factor = 1\n  factors = []\n  for (let i =\
    \ 2; i <= n; i++) {\n    let factor: number\n    if (n % i === 0) {\n      factor\
    \ = i\n      factors.push(factor)\n      while (n % factor === 0) {\n        factor\
    \ = factor * i\n        factors.push(factor)\n        n /= factor\n      }\n \
    \   }\n    max_factor = factors[0]\n  }\n  if (n > 1) factors.push(max_factor)\n\
    \  return factors[0]\n}\n", "    var i = 2;\n    while (i * i <= n) {\n      \
    \  if (n % i == 0) {\n            return i;\n        }\n        ++i;\n    }\n\
    \    return n;\n}\n", "  let m = n % 26;\n  while (m <= n) {\n    m = n % 26;\n\
    \  }\n  return n + m >> 1; // n += m >> (26 - n);\n}\n\n<|/ file ext=.ts source=github\
    \ dstars=1 |>", "  let factor: number = 2\n  let candidate: number = n\n  while\
    \ (true) {\n    if (n % factor === 0) {\n      n /= factor\n    } else {\n   \
    \   break\n    }\n    factor++\n  }\n  return factor\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=primes,algorithm,c++ |>\nThe naive algorithm is of O(n^(1/2)),\
    \ which is very slow for large n. One way to increase the speed is to only consider\
    \ even numbers. The time complexity then becomes O(n^(1/4)). Since it is possible\
    \ to find the first few prime numbers less than 10^6, one can use the Sieve of\
    \ Eratosthenes to find primes in O(n^(1/4)).\n<|/ a dscore=2 |>\n<| c |>\nActually\
    \ the algorithm you described is of O(n^(1/2)), because it does sqrt(n) operations\
    \ for each number; it isn't simply the square root (which would give a factor\
    \ of sqrt(n) for each number)\n<|/ c |>\n<| c |>\nGood point. I missed the sqrt()\
    \ in the first sentence.\n<|/ c |>\n<| a tags=primes,algorithm,c++ |>\nThis problem\
    \ can be reduced to finding prime factors. You can use the following function\
    \ to find prime factors.\n<code>\nint findPrimeFactors(int n) {\n    int f = 2,\
    \ i;\n    while (n > 1) {\n        if (n % f == 0) {\n            return f;\n\
    \        }\n        f += 2;\n        i = 2;\n        while (n % i == 0) {\n  \
    \          i += 2;\n            if (i % f == 0) {\n                f += i;\n \
    \           }\n        }\n    }\n    return f;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nIt's a recursive problem, so you have to add base case. Otherwise the\
    \ algorithm will go into infinite loop.\n<|/ c |>\n<| a tags=primes,algorithm,c++\
    \ |>\nThe idea of Sieve of Eratosthenes is to find the prime numbers and then\
    \ divide them from 2 to sqrt(n) until no factors are left (n mod 2 == 0).\nThe\
    \ algorithm is basically this :\n<code>\n#include <iostream>\n#include <cmath>\n\
    #include <vector>\n\nusing namespace std;\n\nint main(){\n    int N, i;\n    cin\
    \ >> N;\n    vector<int> prime_numbers(N + 1);\n    prime_numbers[0] = 2;\n  \
    \  prime_numbers[1] = 3;\n    for(i=2; i<=sqrt(N); i++){\n        if(N%i==0){\n\
    \            prime_numbers[i + 2] = i;\n        }\n    }\n    i = 2;\n    ", " \
    \ let i: number;\n  const factors: number[] = [];\n  factors.push(n);\n  if (n\
    \ > 1) {\n    for (let i = 2; i * i <= n; ++i) {\n      if (n % i === 0) {\n \
    \       continue;\n      }\n      factors.push(i);\n      while (n % i == 0) {\n\
    \        n /= i;\n        factors.push(n);\n      }\n    }\n  }\n  if (n > 1)\
    \ {\n    factors.push(n);\n  }\n  while (factors.length > 0) {\n    i = factors.pop();\n\
    \    const m = i;\n    while (m > 1) {\n      m = m / i;\n      factors.push(i);\n\
    \      if (m % i == 0) {\n        factors.push(m);\n      }\n    }\n  }\n  return\
    \ factors.length == 1 ? factors[0] : factors[1];\n}\n", "  var factor = 3;\n \
    \ while (n > 1) {\n    if (n % factor === 0) {\n      break;\n    }\n    factor\
    \ += 2;\n    n--;\n  }\n  return factor;\n}\n", "  // If the number `n` is greater\
    \ than the maximum prime factor\n  // of the number `N`, return `N` instead.\n\
    \  if (n > maximum_prime_factor(n)) {\n    return maximum_prime_factor(n);\n \
    \ }\n  // Otherwise, return the largest prime factor of `n`.\n  return primeFactors(n).sort((a,\
    \ b) => b - a)[0];\n}\n", "  var max_factor: number = 0;\n  var sqrt_n = Math.sqrt(n);\n\
    \  for (var i = 2; i <= sqrt_n; i++) {\n    var p = primes[i];\n    if (n % p\
    \ == 0) {\n      return p;\n    }\n    if (n > 1) {\n      if (n % i == 0) {\n\
    \        max_factor = Math.max(max_factor, i);\n      }\n    }\n  }\n  return\
    \ max_factor;\n}\n\nvar is_prime_v1 = is_prime;\n", "  let factors: number[] =\
    \ [];\n  let candidate: number = n;\n  while (true) {\n    factors.push(candidate);\n\
    \    if (n % candidate === 0) break;\n    candidate = number % candidate;\n  }\n\
    \  return factors[factors.length - 1];\n}\n", "  if (n < 2) {\n    return n;\n\
    \  }\n  let max_factor = 0;\n  let exp = 2;\n  while (exp <= n) {\n    let m =\
    \ n % exp;\n    if (m === 0) {\n      return exp;\n    } else {\n      max_factor\
    \ = Math.max(max_factor, exp);\n      n /= exp;\n      exp++;\n    }\n  }\n  return\
    \ max_factor;\n}\n", "  const i = 1;\n  let p = 2;\n  let q = 3;\n\n  while (p\
    \ < n) {\n    if (n % p == 0) {\n      q = p;\n      p = p + q;\n    } else {\n\
    \      p = p + q;\n      q = p + q;\n    }\n  }\n\n  return q;\n}", "    let i\
    \ = 2\n    let p: number = 1\n    while (i < n) {\n        if (n % i == 0) {\n\
    \            p = i\n        }\n        i += 1\n    }\n    return p\n}\n", "  \
    \  if (n < 2) return 1;\n    // Skip even numbers.\n    if (n % 2 == 0) return\
    \ 2;\n    // Skip odd numbers.\n    if (n % 3 == 0) return 3;\n    // Get all\
    \ the different prime factors.\n    let prime_factors = Array();\n    for (let\
    \ i = 4; i <= Math.sqrt(n); i += 2) {\n        while (n % i == 0) {\n        \
    \    prime_factors.push(i);\n            n /= i;\n        }\n    }\n    // Return\
    \ the largest prime factor.\n    return prime_factors.length;\n}\n", "  let result:\
    \ number = 2\n  while (n > 2) {\n    if (n % result == 0) break\n    n /= result\n\
    \    result++\n  }\n  return result > 1 ? result : n\n}\n</code>\n<|/ a |>\n<|\
    \ a |>\nThe first thing to note is that there are lots of prime numbers. Since\
    \ we know that there are only 2 of them, we can find the first prime by seeing\
    \ if the square of the number is odd or even:\n<code>", "  let max_factor = 1;\n\
    \  let max_factor_found = 0;\n  const factors: number[] = [];\n  for (let i =\
    \ 2; i <= Math.sqrt(n); i++) {\n    while (n % i == 0) {\n      factors.push(i);\n\
    \      n /= i;\n    }\n    if (max_factor_found < factors.length) {\n      max_factor_found\
    \ = factors.length;\n      max_factor = factors[factors.length - 1];\n    }\n\
    \  }\n  if (n > 1) {\n    factors.push(n);\n  }\n  return max_factor;\n}\n", " \
    \ const sqrtN = Math.sqrt(n);\n  for(let p = 2; p <= sqrtN; p++) {\n    if(n %\
    \ p == 0) {\n      return p;\n    }\n  }\n  return n;\n}\n", "    var factor:\
    \ number = 0;\n    for (var i = 3; i * i <= n; i += 2) {\n        factor += i;\n\
    \    }\n    return factor;\n}\n", "  let i = 2;\n  while (n % i == 0) {\n    i\
    \ += 1;\n  }\n  if (i == 2) return i;\n  return n.lte(i) ? n : i;\n}\n", "  let\
    \ factor: number = 1;\n  let limit: number = 2;\n  while (true) {\n    if (n %\
    \ limit === 0) {\n      n /= limit;\n      factor++;\n    }\n    if (n > 1) {\n\
    \      break;\n    }\n    limit++;\n  }\n  return factor;\n}\n", "  if (n ===\
    \ 0) {\n    return 0;\n  }\n  const factors: Array<number> = [];\n  let i: number;\n\
    \  var j: number;\n  for (i = 2; i <= Math.sqrt(n); i++) {\n    for (j = 2; j\
    \ <= Math.sqrt(n); j++) {\n      if (n % i === 0) {\n        if (n % j === 0)\
    \ {\n          factors.push(j * i);\n        } else {\n          factors.push(i);\n\
    \          break;\n        }\n      }\n    }\n  }\n  return factors.length > 0\
    \ ? factors[factors.length - 1] : 1;\n}\n", "  let i: number, c: number, m: number,\
    \ p: number, q: number, k: number, w: number;\n  // See http://jsperf.com/maximum-exponent-number/7\n\
    \  const MAX: number = 10000000000;\n\n  for (; i < MAX; i++) {\n    if (i ===\
    \ MAX) {\n      // We have passed the point where i = MAX\n      break;\n    }\n\
    \    if (n % i === 0) {\n      continue;\n    }\n    for (c = 2; c < i; c++) {\n\
    \      if (n % c === 0) {\n        break;\n      }\n    }\n    if (c === i) {\n\
    \      w = n;\n      break;\n    }\n    m = n / c;\n    p = i;\n    while (p %\
    \ c !== 0) {\n      p--;\n    }\n    k = c;\n    while (k % p !== 0) {\n     \
    \ k--;\n    }\n    n = m;\n  }\n\n  return w;\n}\n", "  if (n === 1) return 2;\n\
    \  // We need to test the number to see if it's greater than one-million,\n  //\
    \ which should have a large prime factor.\n  if (n > 1e9) return null;\n  const\
    \ factors: number[] = [];\n  for (let i = 2; i <= n / i; i++) {\n    while (n\
    \ % i === 0) {\n      n /= i;\n      factors.push(i);\n    }\n  }\n  // If there's\
    \ more than one factor that evenly divides n, then n is prime\n  if (factors.length\
    \ > 1) return null;\n  return factors[0];\n}\n", "  let i = 2\n  let p = n\n \
    \ while (i < Math.sqrt(n)) {\n    if (n % i == 0) {\n      p = n / i\n      break\n\
    \    }\n    i += 1\n  }\n  return p\n}\n", "  var i;\n  var largest = 2; // Only\
    \ have to test up to sqrt(n)\n\n  for (i = 2; i <= Math.sqrt(n); ++i) {\n    if\
    \ (n % i === 0) {\n      continue;\n    }\n\n    if (largest * i > n) {\n    \
    \  largest = i;\n    }\n  }\n\n  return largest;\n}\n", "    let factors: Array<number>\
    \ = [];\n    while (n > 1) {\n        factors.push(n % 2);\n        n = Math.floor(n\
    \ / 2);\n    }\n    return factors[factors.length - 1];\n}", "  let ret: number\
    \ = 0;\n  let factor: number = 0;\n\n  for (let i = 2; i <= Math.sqrt(n); i++)\
    \ {\n    if (n % i == 0) {\n      factor = i;\n      break;\n    }\n  }\n\n  if\
    \ (factor) {\n    ret = 1;\n    i = 2;\n    while (i <= Math.sqrt(n)) {\n    \
    \  if (n % i == 0) {\n        factor *= i;\n      }\n\n      i++;\n    }\n  }\n\
    \n  return ret;\n}\n", "    let sieve = new Array((n + 1));\n    for (let i =\
    \ 2; i <= Math.sqrt(n); i++) {\n        sieve[i] = i;\n    }\n    for (let i =\
    \ 2; i <= n; i += 1) {\n        let factor = sieve[n - i]\n        if (factor\
    \ > 2) {\n            sieve[i] = factor - 1\n        }\n    }\n    return sieve[n\
    \ - 1]\n}\n", "  let i = 2; //Start at 2 because 2 does not evenly divide n\n\
    \  while (n % i == 0) { //Repeat until you reach an i that divides n\n    i++;\n\
    \  }\n  return i;\n}\n", "  if(n == 1) return 2;\n  for(var i = 2; i < n; ++i)\
    \ {\n    var j: number, c: number = i;\n    while(n % i == 0) {\n      if(j >\
    \ 1) return j;\n      j++;\n      c /= i;\n    }\n    if(c > 1) return c;\n  }\n\
    \  return n;\n}\n", "    if (n < 2) return 1;\n    if (n % 2 == 0) return 2;\n\
    \    let k = 3;\n    while (n % k == 0) k++;\n    return k;\n}", "  let i = 2;\n\
    \  let max_factor = 2;\n  while (i < n) {\n    if (n % i == 0) {\n      max_factor\
    \ = i;\n    }\n    i += 1;\n  }\n  return max_factor;\n}\n", "  // TODO: use Sieve\
    \ of Eratosthenes for this problem\n  \n  const sieve = new Array<number>([2,\
    \ 3]);\n  for (let i: number = 0; i < n; i++) {\n    const factor = 3;\n    while\
    \ (n % factor) {\n      n /= factor;\n      sieve[i] = ++factor;\n    }\n    if\
    \ (n !== 1) {\n      sieve[i] = n;\n    }\n  }\n  \n  let result = 1;\n  for (let\
    \ i: number = sieve.length - 1; i >= 0; i--) {\n    if (sieve[i] > result) {\n\
    \      result = sieve[i];\n    }\n  }\n  \n  return result;\n}\n", "  let i: number\n\
    \  let factor: number\n  \n  for (i = 2; i <= n / 2; ++i) {\n    factor = (n %\
    \ i)\n    if (factor === 0) {\n      return i\n    } else if (i > factor) {\n\
    \      return factor\n    }\n  }\n  \n  return n // No prime factors\n}\n", " \
    \ let factor = 2;\n  let factors = 0;\n\n  while (factor < n) {\n    if (n % factor\
    \ === 0) {\n      factor = factor * 2;\n      factors += 1;\n    }\n\n    factor\
    \ *= 2;\n  }\n\n  return factors;\n}\n", "  let max_factor = 1;\n  let max_factor\
    \ = factorize(n);\n  for (let i = 2; i < max_factor; i++) {\n    if (n % i ==\
    \ 0) {\n      max_factor = i;\n    }\n  }\n  return max_factor;\n}\n", "\tlet\
    \ max: number = 0;\n\tlet factor: number = 1;\n\tfor (let i = 2; i <= n; i++)\
    \ {\n\t\tif (n % i == 0) {\n\t\t\tfactor = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor\
    \ (let i = factor; i <= n; i += factor) {\n\t\tif (n % i == 0) {\n\t\t\tmax =\
    \ i;\n\t\t}\n\t}\n\treturn max;\n}\n", "  let factor: number = 2;\n  let max:\
    \ number = n;\n  while (n > 1) {\n    while (n % factor === 0) {\n      n /= factor;\n\
    \      if (n === 0) {\n        return factor;\n      }\n    }\n    factor++;\n\
    \  }\n  return factor;\n}\n", "  let factors: number[] = [];\n\n  while (n > 1)\
    \ {\n    // Fill factors up to sqrt(n) into an array of its factors.\n    for\
    \ (let factor = 2; factor <= n; factor++) {\n      if (n % factor === 0) {\n \
    \       factors.push(factor);\n        while (factor <= n / factor) factor +=\
    \ factor;\n      }\n    }\n    // If we already found a factor then there is no\
    \ point checking\n    // against those additional factors.\n    if (factors.length)\n\
    \      continue;\n    // Otherwise return the next largest prime factor.\n   \
    \ return factors[factors.length - 1];\n  }\n\n  return 1;\n}\n", "\tconst log\
    \ = Math.floor(Math.log(n) / Math.LN2);\n\tlet i = log;\n\twhile (i -= 1) {\n\t\
    \tif (n % i === 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n", "  let\
    \ found: number = 2\n  while (n > 1) {\n    const next = math.floor(math.log(n,\
    \ found))\n    if (next < found * 2) {\n      found = next\n    } else {\n   \
    \   found *= 2\n    }\n    n--\n  }\n  return found\n}\n", "  if(n == 1) return\
    \ 1;\n  if(n == 2) return 2;\n\n  // Sieve of Erastothenes (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n\
    \  let primes: Array<number> = [];\n  for(let p = 3; p * p <= n; p++) {\n    let\
    \ is_prime = true;\n    for(let i = 2; i <= Math.sqrt(n); i++) {\n      if(n %\
    \ i == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if(is_prime)\
    \ primes.push(p);\n  }\n\n  return primes[primes.length - 1];\n}\n", "  let i\
    \ = 2;\n  let p: number;\n  while (p <= n && n % p === 0) {\n    i += 1;\n   \
    \ p += i;\n  }\n  return i;\n}\n", "  if (n < 2) return 2\n  if (n % 2 == 0) return\
    \ 3\n  if (n % 3 == 0) return 4\n  if (n %4 == 0) return 5\n  if (n %5 == 0) return\
    \ 6\n  if (n %6 == 0) return 7\n  if (n % 7 == 0) return 8\n  if (n % 8 == 0)\
    \ return 9\n  if (n % 9 == 0) return 10\n  if (n % 10 == 0) return 11\n  if (n\
    \ % 11 == 0) return 12\n  if (n % 12 == 0) return 13\n  if (n % 13 == 0) return\
    \ 14\n  if (n % 14 == 0) return 15\n  if (n % 15 == 0) return 16\n  if (n % 16\
    \ == 0) return 17\n  if (n % 17 == 0) return 18\n  if (n % 18 == 0) return 19\n\
    \  if (n % 19 == 0) return 20\n  if (n % 20 == 0) return 21\n  if (n % 21 == 0)\
    \ return 22\n  if (n % 22 == 0) return 23\n  if (n % 23 == 0) return 24\n  if\
    \ (n % 24 == 0) return 25\n  if (n % 25 == 0) return 26\n  if (n % 26 == 0) return\
    \ 27\n  if (n % 27 == 0) return 28\n  if (n % 28 == 0) return 29\n  if (n % 29\
    \ == 0) return 30\n  if (n % 30 == 0) return 31\n  if (n % 31 == 0) return 32\n\
    \  if (n % 32 == 0) return 33\n  if (n % 33 == 0) return 34\n  if (n % 34 == 0)\
    \ return 35\n  if (n % 35 == 0) return 36\n  if (n % 36 == 0) return 37\n  if\
    \ (n % 37 == 0) return 38\n  if (n % 38 == 0) return 39\n  if (n % 39 == 0) return\
    \ 40\n  if (n % 40 == 0) return 41\n  if (n % 41 == 0) return 42\n  if (n % 42\
    \ == 0) return 43\n  if (n % 43 == 0) return 44\n  if (n % 44 == 0) return 45\n\
    \  if (n % 45 == 0) return 46\n  if (n % 46 == 0) return 47\n  if (n % 47 == 0)\
    \ return 48\n  if (n % 48 == 0) return 49\n  if (n % 49 == 0) return 50\n  if\
    \ (n % 50 == 0) return 51\n  if (n % 51 == 0) return 52\n  if (n % 52 == 0) return\
    \ 53\n  if (n % 53 == 0) return 54\n  if (n % 54 == 0) return 55\n  if (n % 55\
    \ == 0) return 56\n  if (n % 56 == 0) return 57\n  if (n % 57 == 0) return 58\n\
    \  if (n % 58 == 0) return 59\n  if (n % 59 == 0) return 60\n  if (n % 60 == 0)\
    \ return 61\n  if (n % 61 == 0) return 62\n  if (n % 62 == 0) return 63\n  if\
    \ (n % 63 == 0) return 64\n}\n</code>\n<|/ a dscore=", "  let max_factor = 1;\n\
    \  let prime_candidate = 1;\n  for (let i = 3; i <= Math.sqrt(n); i += 2) {\n\
    \    if (n % i == 0) {\n      if (max_factor < i) {\n        max_factor = i;\n\
    \      }\n      if (prime_candidate < n) {\n        prime_candidate = n;\n   \
    \   }\n    }\n  }\n  return prime_candidate;\n}\n", "\tif (n < 2) return 2;\n\t\
    let i: number, p: number, factor: number, max_factor: number;\n\tfor (factor =\
    \ n, max_factor = 2; factor < 2 * max_factor; factor += 2) {\n\t\ti = 0;\n\t\t\
    while ((p = ((n - factor) / 2) > 1) {\n\t\t\tif (factor % p == 0) i += 1;\n\t\t\
    \telse i--;\n\t\t}\n\t\tif (i >= max_factor) break;\n\t\tmax_factor = i;\n\t}\n\
    \treturn factor;\n}\n", "  let iMax: number;\n  let i: number;\n  let nMax: number;\n\
    \  let m: number;\n  const primes: number[] = [];\n  if (n === 1) {\n    return\
    \ 1;\n  }\n  else {\n    nMax = n;\n    iMax = 1;\n    i = 2;\n    while (i <=\
    \ nMax) {\n      m = n;\n      while (m % i === 0) {\n        m /= i;\n      }\n\
    \      if (m > 1 && m > nMax) {\n        primes.push(i);\n        nMax = m;\n\
    \      }\n      i++;\n    }\n    for (i = primes.length; i-- > 0; ) {\n      if\
    \ (primes[i] === nMax) {\n        return primes[i];\n      }\n    }\n  }\n  return\
    \ 1;\n}\n", "  let i: number;\n  let max_factor: number | undefined = undefined;\n\
    \  const sqrtn = Math.floor(Math.sqrt(n));\n\n  for (i = 2; i <= sqrtn; i++) {\n\
    \    if (n % i === 0) {\n      if (max_factor === undefined || n > max_factor)\
    \ {\n        max_factor = i;\n      }\n    }\n  }\n\n  return max_factor;\n}\n",
  "    let max_val = n % 2\n    for( let i = max_val; i >= 2; i-- ) {\n        if(\
    \ n % i === 0) {\n            max_val = i;\n        }\n    }\n    return max_val\n\
    }\n", "    let i = 2\n    let divisor = 2\n    let factor: number = 1\n    while\
    \ (i <= n) {\n        if (n % i == 0) {\n            factor = i\n            if\
    \ (i > divisor) {\n                divisor = i\n            }\n        }\n   \
    \     i++\n    }\n    return factor\n}\n", "  if (n < 2) return 2;\n  var max_prime:\
    \ number = 2;\n  var i: number;\n  for (i = 3; i <= n / i; i++) {\n    var j:\
    \ number = i - 1;\n    while (j * j <= n) {\n      if (n % i == 0) {\n       \
    \ max_prime = i;\n        break;\n      }\n      j--;\n    }\n  }\n  return max_prime;\n\
    }\n\n<|/ file filename=index.js source=github |>", "  let factor: number = 2,\
    \ i: number;\n  for (i = 2; i * i <= n; i += 2) { // check up to sqrt(n)\n   \
    \ factor = Math.min(factor, i); // if factor is too large, ignore it\n  }\n  return\
    \ factor;\n}\n", "  let i: number = 1;\n  let p: number = 1;\n  while (prime_test(n)\
    \ && n < MAX_NUMBER) {\n    i += 1;\n    n *= i;\n  }\n  while (n > 2) {\n   \
    \ p += 1;\n    i *= 2;\n    n = n / i;\n  }\n  return n;\n}", "    if (n <= 1)\
    \ return 2; // 0 or 1 are factors of 2\n    // The number 2 is trivial since 2\
    \ is the only even prime.\n    if (n === 2) return 1;\n    // 3 > sqrt(n), but\
    \ it's still useful to call it a day in advance.\n    if (n <= 3) return primes[n];\n\
    \    // Find all the prime factors of n.\n    const factors = [];\n    const d\
    \ = n;\n    while (true) {\n        while (!is_prime(d)) {\n            d += n\
    \ >> 1;\n        }\n        factors.push(d | 0);\n        // Update n for the\
    \ next iteration.\n        if (n === 6) {\n            n = d * 2;\n          \
    \  d = 1;\n        }\n        else {\n            n = d * primes[d & 15];\n  \
    \      }\n    }\n    // Return all the prime factors\n    return factors;\n}\n",
  "  if (n === 1 || n === 2) {\n    return 1;\n  }\n\n  let m = n - 2;\n  while (m\
    \ % 2 === 0) {\n    m /= 2;\n  }\n\n  // Now n is odd and > 2\n  let next = n\
    \ + 1;\n  while (next % 2 === 0) {\n    next /= 2;\n  }\n\n  // 3n+1 and n+2 are\
    \ prime\n  while (true) {\n    if (next % 3 === 0) {\n      next /= 3;\n    }\
    \ else {\n      break; // No prime candidate found\n    }\n  }\n\n  if (next >\
    \ 2) {\n    // Examine all the numbers of form 3n+1 and n+2.\n    // If n+2 divides\
    \ it become a prime. Examine all the numbers of form 3n+1 and n+3.\n    // Repeat\
    \ while there are factors of 3 or greater.\n    // If there is no factor greater\
    \ than, for example, 16 then you cannot make a prime.\n    do {\n      let n =\
    \ next + 1;\n      while (n % 6 === 0 && n !== next) {\n        n += 2;\n    \
    \  }\n      if (n > 2 && n % 3 === 0) {\n        next += 2;\n      }\n    } while\
    \ (next <= n);\n  }\n\n  return next;\n}\n", "    let factors: number[] = [];\n\
    \    while (n > 1) {\n        while (n % 2 == 0) {\n            factors.push(2);\n\
    \            n = n >> 1;\n        }\n        while (n % 3 == 0) {\n          \
    \  factors.push(3);\n            n = n >> 1;\n        }\n        while (n % 5\
    \ == 0) {\n            factors.push(5);\n            n = n >> 1;\n        }\n\
    \        while (n % 7 == 0) {\n            factors.push(7);\n            n = n\
    \ >> 1;\n        }\n        while (n % 11 == 0) {\n            factors.push(11);\n\
    \            n = n >> 1;\n        }\n    }\n    return factors.length ? factors[factors.length\
    \ - 1] : null;\n}\n", "    let i = 1;\n    while (i <= n) {\n        if (n % i\
    \ == 0) {\n            return i;\n        }\n        i += 2;\n    }\n    return\
    \ n;\n}\n", "    var i, f;\n    if (n < 2) return n;\n    f = 2; //Start at square\
    \ 2\n    while (n % f) { //Keep adding to the square until you hit f\n       \
    \ n /= f;\n        f++;\n    }\n    for (i = n - 1; i > 1; i--) { //Start at square\
    \ 1 and go up until you hit i\n        if (n % i) return i;\n    }\n    return\
    \ 1;\n}\n</code>\nThis code has been tested in Chrome and Firefox. You should\
    \ get very different results on different browsers, but it seems to be working\
    \ in Chrome for me.\n<|/ a dscore=4 |>\n<| c |>\nThanks for your answer. I am\
    \ not getting correct answer for this code `largest_prime_factor(61)` output \
    \ `2`\n<|/ c |>\n<| c |>\nSorry, I forgot to include the condition in my answer.\
    \ Now it should work.\n<|/ c |>\n<| c |>\nThanks. It is working now. I had written\
    \ `if (n > 1) n = largest_prime_factor(n);` inside while loop. Now I changed it\
    \ to `if (n < 2) n = 2;` and it worked for me.\n<|/ c |>\n<| c |>\nGreat! Good\
    \ to hear that it is working for you. I edited my answer to include the condition\
    \ and explained the error you were getting.\n<|/ c |>\n<| c |>\nHi, I have tested\
    \ this on chrome browser and it is giving incorrect output. largest_prime_factor(19)\
    \ gives output  2 and for 19 it gives 2. How to fix this issue?\n<|/ c |>\n<|\
    \ a dscore=3 tags=primes,algorithm |>\nFirst of all, there are many approaches\
    \ to solve this problem, but here is my two cents and I hope it will help you.\n\
    As you may know, the Sieve of Atkin is a very efficient approach to find all prime\
    \ numbers. So, I just implement it and find all the primes below 1048576.\n<code>",
  "    // FIXME: Remove this \"if\" clause\n    if (n < 2) return 1;\n    // FIXME:\
    \ Can this be a \"while true\" loop? What if the condition isn't satisfied?\n\
    \    let i: number = 2;\n    while i < n && n % i == 0) ++i;\n    return i;\n}",
  "  let factors: number[] = [];\n  let m = Math.sqrt(n);\n  let w = m;\n  let i =\
    \ 2;\n\n  while (i <= w) {\n    while (n % i === 0) {\n      factors.push(i);\n\
    \      n /= i;\n    }\n\n    i++;\n  }\n\n  if (n != 1) {\n    factors.push(n);\n\
    \  }\n\n  return factors[factors.length - 1];\n}\n", "\tif (n < 2) return 1;\n\
    \tconst m = native.max(n - 1, 1);\n\tif (n % 2 === 0) return native.max(m, 2);\n\
    \tfor (let i = 4; i <= m / 2; ++i) {\n\t\tlet j = i - 1;\n\t\tlet prime = true;\n\
    \t\tfor (; j > 0; --j) {\n\t\t\tif (n % j === 0) {\n\t\t\t\tprime = false;\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (prime) return i;\n\t}\n\treturn m;\n}\n",
  "    if (n < 2) {\n        return 2; // not prime, return 2\n    }\n    const factors:\
    \ number[] = [];\n    const sqrt_n = Math.sqrt(n);\n    for (let i = 1; i <= sqrt_n;\
    \ i++) {\n        if (n % i === 0) {\n            factors.push(i);\n         \
    \   n = n / i;\n        }\n    }\n    if (n !== 1) {\n        factors.push(n);\n\
    \    }\n    return factors.length > 0 ? Math.max(...factors) : undefined;\n}\n",
  "    var i: number;\n    var r: any = 1;\n    var m: number;\n    for (i = 2, m\
    \ = 2; i * i <= n; i++) {\n        if (n % i === 0) {\n            r = i;\n  \
    \          m = i;\n        }\n        if (m > n) {\n            break;\n     \
    \   }\n    }\n    return r;\n}\n", "    var maxPrime: number = 1;\n    while ((n\
    \ % 2) === 0) {\n        maxPrime = maxPrime * 2 + 1;\n        n = Math.floor(n\
    \ / 2);\n    }\n    return maxPrime;\n}\n", "  let factor = 2;\n  let factors\
    \ = [];\n  for (let i = 1; i <= n; i++) {\n    // Only check factors of 2 or less.\n\
    \    if (n % i == 0) continue;\n    factors.push(i);\n    if (factors.length ==\
    \ factor) break;\n    while (n % i == 0) {\n      n /= i;\n      factor++;\n \
    \   }\n  }\n  return factor;\n}\n", "  let i = 6;\n  let s = 0;\n  while (n >\
    \ 1) {\n    if (n % i == 0) {\n      n = n / i;\n      s = i;\n    }\n    i++;\n\
    \  }\n  return s;\n}\n", "    let factor = 2;\n\n    // If n is less than two\
    \ return 1 since a prime number is always > 2.\n    if (n < 2) {\n        return\
    \ 1;\n    }\n\n    // If n has no prime factors, return 1.\n    if (n === 2) {\n\
    \        return 2;\n    }\n\n    while (n > 1) {\n        if (n % factor === 0)\
    \ {\n            return factor;\n        }\n\n        factor++;\n        n = Math.floor(n\
    \ / factor);\n    }\n\n    return factor;\n}\n", "  if (n < 2) {\n    return null;\n\
    \  }\n  var root: number, i: number;\n  for(i = 2; i*i <= n; i += 2) {\n    root\
    \ = i;\n  }\n  return root;\n}", "    let factors: number[] = [];\n    for (var\
    \ i = 1; i <= n; i++) {\n        // n is divisible by an integer factor (2,3,5,7,11,13,17,19,23,29,31,37...)\
    \ if\n        // the prime factors of n are consecutive odd integers.\n      \
    \  // e.g. (2,3,5) is a prime factor, and (3,5,7) are its consecutive factors\n\
    \        var p_i = i / 2;\n        for (var j = i; j <= n; j++) {\n          \
    \  // j divides i with another prime number if and only if i divides j evenly\n\
    \            var p_j = j / 2;\n            if (p_j % p_i === 0) {\n          \
    \      factors.push(p_j);\n                i = j;\n                break;\n  \
    \          }\n        }\n        if (factors.length === 0) {\n            return\
    \ 1;\n        }\n    }\n    return factors[factors.length - 1];\n}\n", "  let\
    \ max_factor: number = 1;\n  let factors: number[] = [];\n  for (let i = 1; i\
    \ <= n; ++i) {\n    // Scan factors from 2 upwards.\n    for (let j = max_factor;\
    \ j <= n; j = j * j) {\n      if (n % j === 0) {\n        factors.push(j);\n \
    \       break;\n      }\n    }\n    // Scan up to sqrt(n) for the largest factor.\n\
    \    for (let j = 1; j < Math.floor(Math.sqrt(n)); ++j) {\n      if (n % j !==\
    \ 0) {\n        break;\n      }\n    }\n    // If factor is equal to n, then composite\
    \ it.\n    if (j === Math.floor(Math.sqrt(n))) {\n      factors.push(j);\n   \
    \ }\n  }\n  // If there are any factors other than n, then return it.\n  if (factors.length\
    \ > 0) {\n    return factors[factors.length - 1];\n  }\n  return 1;\n}\n", "\t\
    let factors: number[] = [];\n\tlet max = 2, count = 1;\n\twhile (n > max) {\n\t\
    \tcount++;\n\t\tfactors.push(count);\n\t\tmax = Math.sqrt(n);\n\t}\n\n\tfactors.push(count);\n\
    \twhile (factors.length < 3) {\n\t\tfactors.push(1);\n\t}\n\n\tfactors.push(2);\n\
    \treturn factors.reduce((a, b) => a * b);\n}\n", "  const factors: number[] =\
    \ [];\n  for (let x = 2; x < n / 2; x++) {\n    if (n % x === 0) {\n      factors.push(x);\n\
    \      while (n % x === 0) {\n        n /= x;\n      }\n    }\n  }\n  return factors.length\
    \ ? factors.pop() : n;\n}\n", "  let factors: number[] = [];\n  let isPrime =\
    \ true;\n  for (let i = 2; i <= n / i; i++) {\n    if (isPrime) {\n      factors.push(i);\n\
    \    }\n    for (let j = 2; j < i * i; j++) {\n      if (n % j === 0) {\n    \
    \    isPrime = false;\n        break;\n      }\n    }\n  }\n  if (isPrime) return\
    \ n;\n  return factors[factors.length - 1];\n}\n", "  let i = 2;\n  let p = 3;\n\
    \  while (i <= n) {\n    if (n % i == 0) {\n      p += i;\n      while (n % p\
    \ == 0) {\n        p += p;\n      }\n    }\n    i += 2;\n  }\n  return p;\n}\n",
  "  let i = 1;\n  let p = 2;\n  let factor = 2;\n  while (p * p <= n) {\n    while\
    \ (n % i == 0) {\n      n /= i;\n      factor++;\n    }\n    i++;\n  }\n  return\
    \ factor;\n}\n", "  let i: number = 1\n  let v: number = n\n  let largest: number\
    \ = 1\n  let q: number = 2 // Skip even numbers\n  while (q * q <= v) {\n    while\
    \ (n % q === 0) {\n      n /= q\n      i++\n    }\n    largest = q\n    q *= q\n\
    \  }\n  return largest * i\n}\n", "    let maxfactor: number = 0; //max factor\
    \ found\n    for (let i = 2; i < n; ++i) {\n        while ((n % i) === 0) {\n\
    \            ++i;\n        }\n        if (n > 1) {\n            n /= i;\n    \
    \    }\n        else break;\n        if (n > maxfactor) {\n            maxfactor\
    \ = n;\n        }\n    }\n    return maxfactor;\n}\n", "  let factor: number =\
    \ 1\n  let i: number = 2\n  while i < n {\n    if (n % i == 0) {\n      factor++\n\
    \      i ++\n    } else {\n      i = i + 1\n    }\n  }\n  return factor\n}\n",
  "    let num = 1;\n    while (n > 1) {\n        if (n % num === 0) {\n         \
    \   num = num * num;\n        }\n        n = n / num;\n    }\n    return num;\n\
    }\n", "  let i = 2;\n  while (i < n) {\n    let sqrt_n = Math.sqrt(n);\n    if\
    \ (n % i == 0) {\n      return i;\n    }\n    i += 1;\n    n = sqrt_n;\n  }\n\
    \  return n;\n}\n", "  let i = 2;\n  let candidate = 1;\n  while (i <= Math.sqrt(n))\
    \ {\n    const factor = n * i;\n    if (factor > candidate) {\n      candidate\
    \ = factor;\n    }\n    i += 1;\n  }\n  return candidate;\n}\n", "    let i =\
    \ 2;\n    let t: number;\n    for(let x = 2; x < n; x++) {\n        t = n / x;\n\
    \        if(t == parseInt(t) && n % x == 0) {\n            i = x;\n          \
    \  break;\n        }\n    }\n    return i;\n}\n", "  let i = 2; // start at 2\
    \ and increase until n/2 exceeds i\n\n  while (i < n / 2) {\n    if (n % i ==\
    \ 0) {\n      i += 2;\n    } else {\n      i = i * 3 + 1;\n    }\n  }\n\n  return\
    \ i;\n}\n", "  // http://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\
    \  const factor: number = 2;\n  let i: number;\n  for (i = 2; i * i <= n; i +=\
    \ 1) {\n    if (n % i === 0) {\n      return i;\n    }\n  }\n  return factor;\n\
    }\n\nexport function sumOfPrimes(n: number) {\n  let total: number = 0;\n  for\
    \ (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      total += i;\n    }\n\
    \  }\n  return total;\n}\n\nexport const factorial = memoize(n => {\n  return\
    \ (n *= n) - 1 === n ? 1 : n * factorial(n);\n});\n\nexport const isPowerOfTwo\
    \ = memoize((num: number) => num > 0 && (num & num - 1) == 0);\n\nexport const\
    \ countOdds = (a: number[], len: number) => {\n  const odds: number[] = [];\n\
    \  for (let i = 0; i < len; i++) {\n    const num = a[i];\n    if (num % 2 ===\
    \ 1) {\n      odds.push(num);\n    }\n  }\n  return odds;\n};\n\nexport const\
    \ isPrime = memoize(n => {\n  let counter = 0;\n  for (let i = 2; i <= Math.sqrt(n);\
    \ i++) {\n    if (n % i === 0) {\n      counter++;\n    }\n  }\n  return counter\
    \ > 1;\n});\n\nexport const isEven = memoize((n: number) => {\n  return n % 2\
    \ === 0;\n});\n\nexport const isOdd = memoize((n: number) => {\n  return n % 2\
    \ === 1;\n});\n\nexport const isFibonacci = memoize((n: number) => {\n  let counter\
    \ = 0;\n  let previous = 0;\n  for (let i = 2; i <= n; i++) {\n    if (i === 2)\
    \ {\n      return i;\n    }\n    if (i > previous && i === (previous + 1)) {\n\
    \      counter++;\n    }\n    previous = i;\n  }\n  return counter;\n});\n\nexport\
    \ const isQuadratic = memoize((n: number) => {\n  const squareRoot = Math.sqrt(n);\n\
    \  return squareRoot === (squareRoot + 1) / 2;\n});\n", "  // See http://www.jstools.info/primefaq.htm\
    \ for information\n  let max_divisor: number = 1;\n  let max_divisor_p: number\
    \ = 2;\n  while ((max_divisor + max_divisor_p * 2) <= n) {\n    let max_divisor_p_2:\
    \ number = max_divisor_p << 1;\n    if (max_divisor_p_2 <= n) {\n      max_divisor_p\
    \ += max_divisor_p_2;\n    } else {\n      max_divisor_p += 2;\n    }\n    max_divisor\
    \ = max_divisor_p - 1;\n  }\n  return max_divisor;\n}\n", "  let i = 2;\n  while\
    \ (primes[i] * i <= n) {\n    i += 1;\n  }\n  return primes[i];\n}\n", "    //\
    \ http://math.stackexchange.com/questions/99827/the-maximum-prime-factor-of-a-number\n\
    \    if (n !== 1 && n !== n / 2 && (n % 2) !== 0) throw new Error('n must be positive\
    \ integer');\n\n    let i = 2;\n    while(n > 1) {\n        if (n % i === 0) {\n\
    \            n = n / i;\n            ++i;\n        }\n        else {\n       \
    \     return i;\n        }\n    }\n    return i;\n}\n", "  var factors: number[]\
    \ = [];\n  for (var i = 0; i < n; i++) {\n    for (var factor: number = 2; factor\
    \ * factor <= n; factor++) {\n      if (n % factor === 0) {\n        break;\n\
    \      }\n    }\n    if (factor > n) {\n      factors.push(n / factor);\n    }\n\
    \  }\n  return factors[factors.length - 1];\n}\n", "  let i: number;\n  let m:\
    \ number;\n  let s: number;\n  let k: number;\n  for (i = 2; i <= n; i += 1) {\n\
    \    if (n % i === 0) {\n      m = i;\n      s = 1;\n      while (m % i === 0)\
    \ {\n        m /= i;\n        s += 1;\n      }\n      if (s === 2) {\n       \
    \ return i;\n      }\n    }\n  }\n  k = n - 1;\n  while (m % k === 0) {\n    m\
    \ /= k;\n    k += 1;\n  }\n  return k;\n}", "  if (n < 2) return undefined;\n\
    \  var max_divisor = 0;\n  var max_divisor_length = undefined;\n  var sqrt_n =\
    \ Math.sqrt(n);\n  for (var i = 0; i < primes.length; i++) {\n    var prime_divisor_length\
    \ = primes[i] * primes.length;\n    if (n % prime_divisor_length == 0 && prime_divisor_length\
    \ > max_divisor ) {\n      max_divisor = prime_divisor_length;\n      max_divisor_length\
    \ = i;\n    }\n  }\n  return max_divisor_length;\n}\n", "  if (n < 2) {\n    return\
    \ 1;\n  }\n  const max_divisor = PrimeFactorsOf(n);\n  if (max_divisor > 1) {\n\
    \    return max_divisor;\n  }\n  return 2;\n}\n", "  let m = n; // n is 1, return\
    \ it\n  if (n === 1) return 1\n  // n is prime, return it\n  if (n < 2) return\
    \ n\n  // n is even, return its square root\n  if (n % 2 == 0) return Math.floor(Math.sqrt(n))\n\
    \  // n is odd, return the smallest number >= 3\n  if (n % 2 == 1) return 3\n\
    \  // not a prime, return the smallest number >= 3\n  if (n < 3) return 3\n  //\
    \ n is composite, find its smallest factor\n  for (let i = 4; i <= Math.sqrt(n);\
    \ i++) {\n    if (n % i == 0) return i\n  }\n  // n is a prime, return it\n  return\
    \ n\n}\n", "    let largest = 1;\n    let p = 2;\n    while (p * p <= n) {\n \
    \       if (n % p == 0) {\n            largest = p;\n        }\n        p += 1;\n\
    \    }\n    return largest;\n}\n", "  let i = 2\n  while (Math.sqrt(n) > 1) {\n\
    \    for (; i < n; i++) if (n % i == 0) break\n    n /= i\n  }\n  return n\n}\n",
  "  if (n < 2) {\n    return 2;\n  }\n  let max_factor = PRIME_LIMIT;\n  let max_factor_index:\
    \ number = 0;\n  let i = 2;\n  while (i < n) {\n    const next_max_factor = max_factor;\n\
    \    max_factor = Math.floor(n ** i / n);\n    if (max_factor > next_max_factor)\
    \ {\n      max_factor = next_max_factor;\n      max_factor_index = i;\n    }\n\
    \    i += 1;\n  }\n  return max_factor_index;\n}", "  let result: number = null;\n\
    \  const factor = 2;\n  while (factor <= n) result = factor;\n  return result;\n\
    }\n", "    let i = 2;\n    let prime = 1;\n    while (i < n) {\n        if (n\
    \ % i == 0) {\n            prime = i;\n            i++;\n        }\n        else\
    \ {\n            i += 2;\n        }\n    }\n    return prime;\n}\n", "  const\
    \ factors: number[] = [];\n  if (n === 2) {\n    return 2;\n  }\n  for (let i\
    \ = 2; i <= Math.sqrt(n); ++i) {\n    // the largest factor is the last one that\
    \ divides evenly into the number\n    while (n % i === 0) {\n      factors.push(i);\n\
    \      n /= i;\n    }\n  }\n  return factors.length ? Math.max(...factors) : undefined;\n\
    }\n", "  const factors: number[] = [2, 3, 5, 7, 11, 13, 17, 19]; // Start with\
    \ a divisor of 2\n  const test: number = 2; // Scan from 2 to n\n  while (true)\
    \ {\n    for (let factor: number in factors) {\n      // Test to see if this factor\
    \ is less than or equal to the number we are testing.\n      if (factor * test\
    \ <= n) break; // If it is, then this factor is our answer\n      else test +=\
    \ factor; // If we found a larger factor then stop, no need to check the others\n\
    \    }\n    if (test <= n) return test; // If we haven't found a factor, test\
    \ the next one\n    else {\n      factors.push(test);\n      test++;\n    }\n\
    \  }\n}\n</code>\n<|/ a |>\n<| c |>\nHi Cedric, thank you for this. I'm still\
    \ trying to understand it though and it's quite slow. Is there a way to get it\
    \ a little faster?\n<|/ c |>\n<| c |>\nHi Cedric, I've added some code to my original\
    \ post. It runs quite fast now, but still takes quite a while.\n<|/ c |>\n<| c\
    \ |>\nHi Cedric, I've added some code to my original post. It runs quite fast\
    \ now, but still takes quite a while.\n<|/ c |>\n<| c |>\nThe only improvement\
    \ I see is to use a HashSet instead of an array for the factors variable. Arrays\
    \ have some costs associated with them.\n<|/ c |>\n<| a tags=primes,performance,optimization,javascript,algorithm\
    \ dscore=1 |>\nHere is a simpler solution to find the largest prime factor (not\
    \ necessarily the greatest prime factor as this could also be achieved with iterating\
    \ the factors)\n<code>", "  const factors: number[] = [];\n  factors.push(n);\n\
    \  let i = 2;\n  while (factors.length < n) {\n    while (n % i == 0) {\n    \
    \  i += 1;\n      factors.push(i);\n    }\n    i += 2;\n  }\n  if (factors.length\
    \ > n) {\n    return factors[n - 1];\n  }\n  return factors[0];\n}\n", "  let\
    \ i = 2\n  while (n > 1) {\n    if (n % i === 0) {\n      n /= i\n    } else {\n\
    \      i += 1\n    }\n  }\n  return n\n}\n", "    let m = n;\n    let factor =\
    \ 3;\n    while (factor * factor <= m) {\n        while (n % factor === 0) {\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    return n;\n\
    }\n</code>\n<|/ a dscore=0 tags=javascript,factors |>\n<| a tags=javascript,factors\
    \ |>\n<code>", "    if (n < 2) return null;\n    var m = n|0;\n    var i = 2;\
    \ // Start at sqrt(n).\n    while (i < m) {\n        var j = Math.floor(Math.sqrt(n));\n\
    \        if (n % j === 0) i += j;\n        else i += 1;\n        n = i/j;\n  \
    \  }\n    return i;\n}\n", "    let factor: number\n    let i: number\n    let\
    \ limit: number\n    let isPrime: number\n    let limitSq: number\n    // Check\
    \ n is not a number less than or equal to 0.\n    // Assume n is greater than\
    \ 1 and is not a prime.\n    if (isFinite(n) && n > 0) {\n        // Test if n\
    \ is a prime.\n        isPrime = n !== 1\n        // Limit n to the smallest integer\
    \ greater than 1 that is not a prime.\n        limitSq = Math.floor(Math.sqrt(n))\n\
    \        limit = limitSq - 1\n        // If n is less than 2, return n and set\
    \ isPrime to false.\n        if (n <= 1) {\n            return n\n        }\n\
    \        // If n is greater than limit, set n to 1 and set isPrime to true.\n\
    \        if (n > limit) {\n            n = 1\n            isPrime = true\n   \
    \     }\n        // While n is not greater than limit, divide n by 2 each time.\n\
    \        while (n > limit) {\n            i = Math.floor(n / 2)\n            if\
    \ (n % i === 0) {\n                n = Math.floor(n / 2)\n                factor\
    \ = i\n            }\n            else {\n                n = i * 2\n        \
    \    }\n        }\n    }\n    return factor\n}\n", "  let factors: number[] =\
    \ [];\n  let prime = true;\n  let candidate: number[] = [2];\n  for (let i = 3;\
    \ i <= n; i++) {\n    if (n % i === 0) {\n      if (prime) {\n        candidate\
    \ = [i, n - 1];\n      } else {\n        candidate = [i];\n      }\n      factors.push(candidate);\n\
    \      prime = !prime;\n    }\n  }\n  return factors.length > 0 ? factors[factors.length\
    \ - 1][1] : undefined;\n}\n", "  const factors: number[] = [];\n\n  for (let i\
    \ = 2; i <= n; i += 1) {\n    while (n % i === 0) {\n      factors.push(i);\n\
    \      n /= i;\n    }\n  }\n\n  if (n > 1) {\n    factors.push(n);\n  }\n\n  return\
    \ factors[factors.length - 1];\n}\n", "  let largest = 2;\n  let prime = 2;\n\n\
    \  for (let i = 2; i <= Math.sqrt(n); ++i) {\n    if (n % i === 0) {\n      prime\
    \ = i;\n    }\n    if (prime > largest) {\n      largest = prime;\n    }\n  }\n\
    \n  return largest;\n}\n", "  const i = 2;\n  while (i < n) {\n    const next\
    \ = (i << 1) + 1;\n    if (n % next === 0) {\n      n = next;\n    } else {\n\
    \      i = next;\n    }\n  }\n  return i;\n}\n", "  let max: number\n  const isPrime:\
    \ Function = (i: number, primes: number[]) => {\n    if (i === 0) return false\n\
    \    if (primes.some((p: number) => n % p === 0)) return true\n    return false\n\
    \  }\n  for (let i = 2; n < i; i += 1) {\n    if (isPrime(i, [i, i])) {\n    \
    \  max = Math.max(n * i, max)\n    }\n  }\n  return max\n}\n\nexport function\
    \ is_in_range(x: number, y: number, min: number, max: number): boolean {\n  return\
    \ min <= x && x <= max && min <= y && y <= max\n}\n\nexport function clamp(min:\
    \ number, max: number, x: number): number {\n  if (min <= x && x <= max) return\
    \ x\n  return min\n}\n\nexport function clamp_float(min: number, max: number,\
    \ x: number): number {\n  const minNum = min\n  const maxNum = max\n  const x\
    \ = parseFloat(x)\n\n  if (x < min) {\n    return minNum\n  } else if (x > max)\
    \ {\n    return maxNum\n  } else {\n    return x\n  }\n}\n\nexport function clamp_int_float(min:\
    \ number, max: number, x: number): number {\n  const minNum = min\n  const maxNum\
    \ = max\n  const x = Math.round(x)\n\n  if (x < min) {\n    return minNum\n  }\
    \ else if (x > max) {\n    return maxNum\n  } else {\n    return x\n  }\n}\n\n\
    export function clamp_color(min: number, max: number, x: number): number {\n \
    \ const r = clamp(min.r, max.r, x)\n  const g = clamp(min.g, max.g, x)\n  const\
    \ b = clamp(min.b, max.b, x)\n  return rgb(r, g, b)\n}\n\nexport function clamp_colorfloat(min:\
    \ number, max: number, x: number): number {\n  const r = clamp_float(min.r, max.r,\
    \ x)\n  const g = clamp_float(min.g, max.g, x)\n  const b = clamp_float(min.b,\
    \ max.b, x)\n  return rgb(r, g, b)\n}\n\nexport function clamp_hex(min: number,\
    \ max: number, x: number): number {\n  const r = clamp(min.r, max.r, x)\n  const\
    \ g = clamp(min.g, max.g, x)\n  const b = clamp(min.b, max.b, x)\n  return hex(r,\
    \ g, b)\n}\n\nexport function clamp_hexfloat(min: number, max: number, x: number):\
    \ number {\n  const r = clamp_float(min.r, max.r, x)\n  const g = clamp_float(min.g,\
    \ max.g, x)\n  const b = clamp_float(min.b, max.b, x)\n  return hex(r, g, b)\n\
    }\n\nexport function clamp_int_int(min: number, max: number, x: ", "  let candidate:\
    \ number = n;\n  let factor: number|undefined = 1;\n  while (true) {\n    if (n\
    \ & 1) {\n      n = (n / 2) | 0;\n      factor = 2;\n    } else {\n      n = (n\
    \ * 3) / 5 | 0;\n      factor = 3;\n    }\n    if (factor <= candidate) {\n  \
    \    break;\n    }\n    candidate = factor;\n  }\n  return factor;\n}\n", "  \
    \  // n is not a prime\n    if (n < 1) {\n        return 0;\n    }\n\n    // 1\
    \ is returned if n is prime.\n    if (n === 1) {\n        return 1;\n    }\n\n\
    \    // If n is less than or equal to 3, return 2. If n is greater than or equal\
    \ to sqrt(3), return 3.\n    // If n is greater than sqrt(3), return 4.\n    const\
    \ root: number = Math.sqrt(n);\n    let i = 2;\n    let max: number = 2;\n\n \
    \   // Max will only be called when i is less than 3\n    while (i <= root) {\n\
    \        const multiple: number = n % i;\n        if (multiple === 0) {\n    \
    \        i += 1;\n            break;\n        }\n        if (multiple > max) {\n\
    \            max = multiple;\n        }\n        i += 1;\n    }\n\n    if (i ===\
    \ 3) {\n        return 4;\n    }\n    return max;\n}\n", "    let i = 2\n    let\
    \ l = 2\n    while (i < n) {\n        let t = n%i\n        if (t != 0) {\n   \
    \         n = t\n        }\n        else {\n            i += 1\n        }\n  \
    \      l++\n    }\n    return l\n}\n", "  let i = 2\n  while (i * i <= n) {\n\
    \    if (n % i == 0) {\n      break\n    }\n    i++\n  }\n  return n\n}\n", " \
    \ if (n < 2) return 2;\n  let i = 2; // start at n = 2\n  while (true) {\n   \
    \ while (n % i++ < 2) n *= i;\n    if (n > 2) return i;\n  }\n}\n", "    let i\
    \ = 2; // 2 is the smallest prime factor of n\n\n    while (i <= Math.sqrt(n))\
    \ {\n        if (n % i == 0) {\n            i += 1;\n        } else {\n      \
    \      break;\n        }\n    }\n\n    return i;\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nCan you please share the link to the code? That would be very helpful!\n\
    <|/ c |>\n<| c |>\nYou can see it here https://jsbin.com/doqegu/edit?js,console\
    \ The function itself is taken directly from here: https://github.com/sjkp/javascript-biginteger\n\
    <|/ c |>\n<| c |>\nYou wrote \"The function itself is taken directly from here\"\
    . I am having problem with the link to that. Can you please give me the link again?\n\
    <|/ c |>\n<| c |>\nSure, the function is now at https://jsbin.com/doqegu/edit?js,console\n\
    <|/ c |>\n<| c |>\nI added more comments to the function.  I also added a link\
    \ to a more recent version of the code.\n<|/ c |>\n<| a dscore=3 tags=primes,algorithm,math,javascript,bigint\
    \ |>\nHere's my solution:\n<code>", "  let p = 1;\n  let q = n;\n  let factor\
    \ = 2;\n  while (true) {\n    if (q & 1) {\n      p *= factor;\n    }\n    q >>=\
    \ 1;\n    factor++;\n    if (q <= 1) {\n      return p;\n    }\n  }\n}\n", " \
    \ let max_factor = 1\n  let max_num = 2\n  while (n % max_num == 0) {\n    max_num\
    \ *= 2\n    max_factor++\n  }\n  if (max_num <= SMALLEST_PRIME) {\n    return\
    \ max_num\n  }\n  return max_factor\n}\n", "  if (n < 2) {\n    return 1;\n  }\n\
    \  if (n % 2 === 0) {\n    return 2;\n  }\n  if (n === 3) {\n    return 5;\n \
    \ }\n  if (n % 3 === 0) {\n    return 3;\n  }\n\n  // It might be possible to\
    \ do better than the following:\n  // Sieve of Eratosthenes to find the prime\
    \ factors of 2, 3, 5.\n  // See <http://www.algorithmist.com/index.php/Euler%E2%80%93Rabin_primality_test>\
    \ \n  // for a description of how the sieve works.\n  const limit: number = Math.sqrt(n);\n\
    \  const num_factors: number = (n - 1) // n must be greater than 1\n    + 1; //\
    \ add 1 since 1 is not a prime number\n\n  const factors: number[] = [];\n\n \
    \ for (let i = 0; i <= num_factors; i++) {\n    factors.push(i);\n  }\n\n  let\
    \ is_prime = true;\n  for (let i = 2; i <= limit; i += 1) {\n    if (!isPrime[i])\
    \ {\n      is_prime = false;\n      break;\n    }\n  }\n\n  // return the largest\
    \ prime factor of n\n  if (is_prime) {\n    return n;\n  } else {\n    let m =\
    \ primes[i];\n    for (let i = num_factors; i <= limit; i++) {\n      if (primes[i]\
    \ === m) {\n        return i;\n      }\n    }\n    return n;\n  }\n}\n", "   \
    \ if (n <= 1) return 1\n    let i = 2\n    while (i <= Math.sqrt(n)) {\n     \
    \   if (n % i == 0) return i\n        i += 2\n    }\n    return n // No prime\
    \ factors found\n}\n", "  let max_divisor = 1;\n  let max_div = 1;\n\n  while\
    \ (n) {\n    if (n % max_div) {\n      max_div *= max_div;\n    }\n    max_divisor\
    \ *= max_divisor;\n    n /= max_divisor;\n  }\n  return max_divisor;\n}\n", " \
    \   let max_factor = 1;\n    let result = 1;\n    for (let i = 1; i < n; i++)\
    \ {\n        if (n % i == 0) {\n            result = i;\n            break;\n\
    \        }\n        if (n % i == 1) {\n            max_factor = i;\n        }\n\
    \    }\n    return result;\n}\n", "  if (n < 2) {\n    return 1;\n  }\n\n  let\
    \ result = 1;\n  let check_val = 2;\n  for (let i = 2; i <= n; ++i) {\n    const\
    \ check_mod = check_val % i;\n    if (check_mod === 0) {\n      continue;\n  \
    \  }\n    while (n % i === 0) {\n      result *= i;\n      n /= i;\n    }\n\n\
    \    if (n === 0) {\n      break;\n    }\n    check_val = check_mod;\n  }\n\n\
    \  return result;\n}\n", "  let i: number;\n  let factor: number;\n  let isPrime:\
    \ boolean;\n  for (i = 2; i <= Math.sqrt(n); i++) {\n    isPrime = true;\n   \
    \ factor = 2;\n    while (n % i == 0) {\n      n /= i;\n      factor += 1;\n \
    \     isPrime = false;\n    }\n    if (isPrime) {\n      return factor;\n    }\n\
    \  }\n  return n;\n}\n", "  let max_div = 1;\n  const max_div_div_n = max_div\
    \ * max_div;\n  while (n > 1) {\n    if (n % max_div == 0) max_div = max_div_div_n;\n\
    \    n /= max_div;\n  }\n  return max_div;\n}\n", "  var max_number = 1;\n  var\
    \ max_factor = 1;\n  var i;\n  for (i = 2; i <= n; ++i) {\n    var sqrt_n = Math.sqrt(n);\n\
    \    max_number = Math.max(max_number, sqrt_n);\n    max_factor = Math.max(max_factor,\
    \ i);\n  }\n  return max_factor;\n}\n", "  const sieve: number[] = new Array(n\
    \ / 2 + 1);\n  for (let i = 0; n > 2; i++) sieve[i] = Math.floor(Math.sqrt(n));\n\
    \  for (let i: number = 1; i < n; i++) sieve[i] -= 1;\n  for (let i: number =\
    \ 0; i < sieve.length; i++) if (sieve[i]) n = (n * sieve[i]) % n;\n  return n;\n\
    }\n", "    let i: number = 0;\n    for(;;) {\n        n = next_prime(n);\n   \
    \     if(!isPrime(n)) break;\n        ++i;\n    }\n    return i;\n}\n", "    let\
    \ i = 2;\n    let s: number = 1;\n    for (; i * i <= n; i++) {\n        s = s\
    \ * i;\n    }\n    return s % n;\n}\n", "  let max = n;\n  let i = 1;\n  while\
    \ (n > 1) {\n    if (n % i === 0) {\n      max = i;\n    } else {\n      i +=\
    \ 1;\n    }\n  }\n  return max;\n}\n", "  let factor = 1;\n  let current_prime\
    \ = 2;\n  let current_max = n;\n  while (factor < current_max) {\n    const new_factor\
    \ = current_max * current_prime;\n    if (new_factor > factor) factor = current_prime;\n\
    \    current_max = new_factor;\n    current_prime++;\n  }\n  return factor;\n\
    }\n</code>\n<|/ a tags=python,algorithm |>\n<| c |>\nThis solution does not seem\
    \ to work for `n = 1305`. I would expect it to return 2, but instead it returns\
    \ 2. Any thoughts?\n<|/ c |>\n<| a tags=python,algorithm |>\nTry using recursion\n\
    <code>\ndef largest_prime_factor(n):\n    def gcd(a, b):\n        while b > 0:\n\
    \            a, b = b, a % b\n        return a\n    if n == 1:\n        return\
    \ 1\n    else:\n        if n % 2 == 0:\n            return 2\n        else:\n\
    \            if n > 1:\n                if n % 3 == 0:\n                    return\
    \ 3\n                else:\n                    if n % 5 == 0:\n             \
    \           return 5\n                    else:\n                        return\
    \ gcd(n, 5)\n            else:\n                return gcd(n, 2)\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=python,algorithm |>\nA little change to Amit Patel's\
    \ answer and it gives the correct answer.\n<code>\ndef largest_prime_factor(n):\
    \ \n    if n==1: \n        return 1 \n    else: \n        if n % 2 == 0:  \n \
    \           return 2 \n        else: \n            if n > 1: \n              \
    \  if n % 3 == 0:  \n                    return 3 \n                else: \n \
    \                   if n % 5 == 0:  \n                        return 5 \n    \
    \                else: \n                        prime_factors = largest_prime_factor(n//5)\
    \ +1 \n                        return gcd(n, prime_factors)\n            else:\n\
    \                prime_factors = largest_prime_factor(n//2) +1 \n            \
    \    return gcd(n, prime_factors)\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhile\
    \ this works it's not particularly efficient, since it requires calling gcd 3\
    \ times per iteration. Also, the code does not use the fact that n can be divided\
    \ by 3 and 5 without a remainder.\n<|/ c |>\n<| a dscore=1 |>\n<code>\ndef largest_prime_factor(n):\n\
    \    prime_factor = 2\n    while prime_factor <= n:\n        if n % prime_factor\
    \ == 0:\n            return prime_factor\n        else:\n            prime_factor\
    \ = prime_factor + 1\n</code>\n<|/ a tags=python,algorithm |>\n<| c |>\nThe solution\
    \ is not complete, because it doesn't consider factors 2 and 3, which are not\
    \ primes.\n<|/ c |>\n<| a tags=python,algorithm dscore=1 |>\nPython version from\
    \ my blog:\n<code>\ndef ", "    // See https://en.wikipedia.org/wiki/Primality_test#Naive_method\n\
    \    //\n    // An upper bound on the amount of work we can do with a given n.\n\
    \    const primes: Set<number> = new Set([2]);\n\n    while (n > 1) {\n      \
    \  if (primes.has(n)) {\n            primes.add(n); // This n is prime so we add\
    \ it to the list of primes to test.\n        } else {\n            primes.add(Math.ceil(n\
    \ / 2)); // n is composite so we need to divide it to get to the next smallest\
    \ n.\n        }\n        n = Math.floor(n / 2);\n    }\n\n    return primes.has(1)\
    \ ? 1 : primes.has(2) ? 2 : primes.size;\n}\n", "    // n is greater than 2, and\
    \ is neither, 1 or 3\n    if (n < 2 || n % 2 == 0 || n % 3 == 0) return n;\n \
    \   // n is greater than 2\n    if (n === 2 || n % 2 == 0) return 2;\n    // n\
    \ is greater than 3 and is neither 2 or 3\n    if (n % 3 == 0) return 3;\n\n \
    \   // n is greater than 3\n    const m = n % 4;\n    // 2 is the only even prime\
    \ factor\n    if (m == 0) return 2;\n\n    // 3 is the only odd prime factor\n\
    \    if (m == 1) return 3;\n\n    // 4 is the largest odd prime factor\n    if\
    \ (m == 2) return 4;\n\n    // 6 is neither prime nor composite\n    return 6;\n\
    }\n", "  let factor: number, i: number;\n  for (i = 2; i <= n; i += 1) {\n   \
    \ factor = isPrime(i) ? i : i;\n    if (n > 1 && factor % n === 0) break;\n  }\n\
    \  return factor;\n}\n", "  const factors: number[] = [];\n  for (let i = 2; i\
    \ <= n; i++) {\n    while (n % i === 0) {\n      factors.push(i);\n      n /=\
    \ i;\n    }\n  }\n  if (n > 1) {\n    factors.push(n);\n  }\n  return factors.length\
    \ > 0 ? factors[factors.length - 1] : 1;\n}\n", "  n = n|0;\n  // http://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\
    \  for (let i = 2; i < 30; ++i) {\n    if (n % i == 0) {\n      return i;\n  \
    \  }\n  }\n  if (n == 1) return 2;\n  let t = n - 1;\n  // t == 2\n  while (t\
    \ % 2 == 0) {\n    t = t / 2;\n  }\n  // t == 1/2\n  while (t % 3 == 0) {\n  \
    \  t = t / 3;\n  }\n  if (t % 5 == 0) return 5;\n  if (t % 7 == 0) return 7;\n\
    \  return 9;\n}\n", "  var i = 1;\n  n = +n;\n  while (i < n && n % i++ === 0)\
    \ {\n    n = n / i;\n  }\n  return n + 1;\n}\n\nconst primeFactors = (n: number)\
    \ => {\n  if (n < 2) return null;\n  var d = 2;\n  while (n) {\n    if (n % d\
    \ === 0) {\n      return [d, n];\n    }\n    d += 2;\n    n = Math.floor(n / d);\n\
    \  }\n  return null;\n};\n", "    let sqrtN = Math.sqrt(n);\n    \n    let factor\
    \ = 1;\n    while (sqrtN > 1) {\n        if (n % sqrtN == 0) {\n            factor++;\n\
    \            n /= sqrtN;\n        }\n        else {\n            sqrtN = sqrtN/2;\n\
    \        }\n    }\n    \n    return factor;\n}\n", "  if (n % 2 === 0) { return\
    \ n; }\n  let lcm = n;\n  while (!is_prime(lcm)) {\n    if (lcm % 2 === 0) { return\
    \ lcm; }\n    lcm /= 2;\n  }\n  return lcm;\n}\n", "  let i = 2;\n  while (i *\
    \ i <= n) i += 2;\n  return n;\n}\n", "  let i = 1;\n  while (primes[i] > n) i++;\n\
    \  return primes[i];\n}\n", "    let factor: number;\n    \n    \n    \n    \n\
    \    \n    for (factor = 2; factor <= n; factor++) {\n        if (n % factor ===\
    \ 0) {\n            n /= factor;\n        }\n    }\n\n    return n;\n}\n", " \
    \ let factor: number = 0;\n  let divisors: number[] = [2];\n  while (n > 1) {\n\
    \    if (n % divisors[0] === 0) divisors.push(divisors[0]);\n    if (n % divisors[divisors.length\
    \ - 1] === 0) divisors.push(divisors[divisors.length - 1]);\n    divisors.push(divisors[divisors.length\
    \ - 1] + 2);\n    factor++;\n    n = (n / divisors[divisors.length - 1]) | 0;\n\
    \  }\n  return factor;\n}\n", "    if (n === 0) {\n        return 1;\n    }\n\
    \    let i = 2;\n    let s = 1;\n    while (i < n) {\n        if (n % i === 0)\
    \ {\n            n = n / i;\n            while (n % i === 0) {\n             \
    \   n = n / i;\n                i++;\n            }\n            s = s * i;\n\
    \        }\n        i++;\n    }\n    return s;\n}\n", "  if(n == 1) {\n    return\
    \ n;\n  }\n  var max_num = Math.sqrt(n);\n  for(var i = 2; i < max_num; ++i) {\n\
    \    if(n%i == 0) {\n      return i;\n    }\n  }\n  throw Error(\"unable to find\
    \ prime factors\");\n}\n", "  let factor = 2;\n  while (n * factor < n) {\n  \
    \  factor++;\n  }\n  return factor;\n}\n", "    let result: number = 0;\n    let\
    \ isPrime: boolean;\n    for (let i = 2; i <= n; ++i) {\n        isPrime = true;\n\
    \        for (let j = 2; j <= Math.sqrt(n); ++j) {\n            if (n % i == 0)\
    \ {\n                isPrime = false;\n                break;\n            }\n\
    \        }\n        if (isPrime) {\n            result += i;\n        }\n    }\n\
    \    return result;\n}", "  var i: number, divisor: number, res: number;\n\n \
    \ for (i = 3; i <= n; i += 2) {\n    divisor = i;\n    res = 1;\n    while (n\
    \ % divisor === 0) {\n      res *= divisor;\n      divisor /= 2;\n    }\n    if\
    \ (res % 2 === 0) {\n      return res;\n    }\n  }\n  return n;\n}\n", "  let\
    \ i = 3\n  while i * i <= n && n != 1 && n != 0 {\n    if (n % i == 0) {\n   \
    \   n /= i\n    } else {\n      i++\n    }\n  }\n  return n\n}\n", "    let i\
    \ = 2; // Start at i = 2 so n >= 2 and n >>= 1\n    while (i < n && primes[i])\
    \ ++i; // While i <= sqrt(n)\n    return primes[i];\n}\n", "  let factor: number,\
    \ i: number, numbers: number[] = [], sqrt: number, largest: number, value: number;\n\
    \  for (i = 2; i <= n; i++) {\n    numbers.push(i);\n  }\n  for (i = 2, sqrt =\
    \ 0; i < numbers.length; i++) {\n    value = numbers[i];\n    if (value % i ===\
    \ 0) {\n      sqrt = Math.sqrt(value);\n      if (sqrt > largest) {\n        largest\
    \ = sqrt;\n      }\n    }\n  }\n  if (largest === undefined) {\n    return 1;\n\
    \  }\n  return largest;\n}\n</code>\n<|/ a tags=javascript,algorithm |>\n<| a\
    \ dscore=3 tags=javascript,algorithm |>\nThis is how I solved it.\n<code>", " \
    \ if (n < 2) return 2;\n  var d = n - 1;\n  while (d--) if (n % d == 0) return\
    \ d;\n  return 2;\n}\n", "    const sieve = new Array((n + 1));\n    for (let\
    \ i = 2; i * i <= n; ++i) {\n        sieve[i] = i;\n    }\n    sieve[1] = 1;\n\
    \    let result = 1;\n    for (let i = 2; i <= n; i++) {\n        while (sieve[i]\
    \ === i * i) {\n            ++result;\n            sieve[i] = 0;\n        }\n\
    \    }\n    return result;\n}", "    let factors: number[] = [];\n\n    // Go\
    \ through each prime factorization of n.\n    for (let i = 2; i * i <= n; i++)\
    \ {\n        // Multiply out all the factors for every power of two.\n       \
    \ while (i * i > n) {\n            n /= i;\n            factors.push(i);\n   \
    \     }\n    }\n\n    // Return the largest prime factor of the number if there\
    \ are one.\n    // If there isn't return 1.\n    return factors.length ? Math.max(...factors)\
    \ : 1;\n}\n", "  let i: number;\n  for (i = 2; i <= n / i; i++) {\n    if (n %\
    \ i == 0) {\n      return i;\n    }\n  }\n  if (n > 1) {\n    return n;\n  }\n\
    \  return 1;\n}\n", "  if (n == 1) return 2;\n  var a = bigInt(n);\n  for (var\
    \ i = 2; i*i <= n; i += 2) {\n    if (!isPrime(i)) return i;\n  }\n  return 2;\n\
    }\n", "    // Test for special cases when n is negative.\n    if (n <= 3) return\
    \ 2;\n    // If n is less than or equal to 1, then return 1. If n is greater than\
    \ 1 but even,\n    // then return 2. If n is greater than 1, then return smallest\
    \ prime greater than n.\n    // If n is a composite number, then return the number\
    \ of its prime factors.\n    if (n <= 1) return 1;\n    if (n % 2 === 0) {\n \
    \       if (n % 3 === 0) return 3;\n        if (n % 5 === 0) return 5;\n     \
    \   if (n % 7 === 0) return 7;\n    } else {\n        if (n % 3 === 0) return\
    \ 3;\n        if (n % 5 === 0) return 5;\n        if (n % 7 === 0) return 7;\n\
    \    }\n    let i = 2;\n    let counter = 2;\n    while (Math.sqrt(n)) {\n   \
    \     if (n % i === 0) {\n            counter++;\n        }\n        i += 2;\n\
    \    }\n    return counter;\n}", "  let i = 2\n  const xs = [2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\
    \  let d = isPrime(n) ? BigInt(n) : 1\n\n  while (true) {\n    if (n % i === 0)\
    \ {\n      i++\n      continue\n    }\n    break\n  }\n  while (true) {\n    if\
    \ (n % (i + 2) > 0) {\n      i++\n      continue\n    }\n    break\n  }\n  while\
    \ (true) {\n    if (n % (i + 3) > 0) {\n      i++\n      continue\n    }\n   \
    \ break\n  }\n  while (true) {\n    if (n % (i + 5) > 0) {\n      i++\n      continue\n\
    \    }\n    break\n  }\n  while (true) {\n    if (n % (i + 7) > 0) {\n      i++\n\
    \      continue\n    }\n    break\n  }\n  while (true) {\n    if (n % (i + 11)\
    \ > 0) {\n      i++\n      continue\n    }\n    break\n  }\n  while (true) {\n\
    \    if (n % (i + 13) > 0) {\n      i++\n      continue\n    }\n    break\n  }\n\
    \  while (true) {\n    if (n % (i + 17) > 0) {\n      i++\n      continue\n  \
    \  }\n    break\n  }\n  while (true) {\n    if (n % (i + 19) > 0) {\n      i++\n\
    \      continue\n    }\n    break\n  }\n  while (true) {\n    if (n % (i + 23)\
    \ > 0) {\n      i++\n      continue\n    }\n    break\n  }\n  while (true) {\n\
    \    if (n % (i + 29) > 0) {\n      i++\n      continue\n    }\n    break\n  }\n\
    \  while (true) {\n    if (n % (i + 31) > 0) {\n      i++\n      continue\n  \
    \  }\n    break\n  }\n  while (true) {\n    if (n % (i + 37) > 0) {\n      i++\n\
    \      continue\n    }\n    break\n  }\n  while (true) {\n    if (n % (i + 41)\
    \ > 0) {\n      i++\n      continue\n    }\n    break\n  }\n  while (true) {\n\
    \    if (n % (i + 43) > 0) {\n      i++\n      continue\n    }\n    break\n  }\n\
    \  while (true) {\n    if (n % (i + 47) > 0) {\n      i++\n      continue\n  \
    \  }\n    break\n  }\n  while (true) {\n    if (n % (i + 53) > 0) {\n      i++\n\
    \      continue\n    }\n    break\n  }\n  while (true) {\n    if (n % (i + 59)\
    \ > 0) {\n      i++\n      continue\n    }\n    break\n  }\n  while (true) {\n\
    \    if (n % (i + 63) > 0) {\n      i++\n      continue\n    }\n    break\n  }\n\
    \  while (true) {\n    if (n % (", "    let factor: number|undefined = n;\n  \
    \  while (true) {\n        if (factor <= 1) break;\n        if (n % factor ===\
    \ 0) {\n            factor = n / factor;\n            break;\n        }\n    \
    \    factor += 1;\n    }\n    return factor;\n}\n", "  let max_factor: number\
    \ = 2;\n  let prime: number = 2;\n\n  while (true) {\n    if (n % prime === 0)\
    \ {\n      max_factor = prime;\n    }\n\n    if (max_factor < n) {\n      prime++;\n\
    \    }\n\n    if (prime > MAX_NUMBER_PER_LARGE_PRIME) {\n      break;\n    }\n\
    \  }\n\n  return max_factor;\n}\n", "  if (n === 1) return 2;\n  var ret: number\
    \ = 4;\n  var found = false;\n  for (var i = 2; i <= n; ++i) {\n    var j: number\
    \ = i;\n    while (j > 1 && n % j === 0) {\n      found = true;\n      j--;\n\
    \    }\n    if (found) break;\n    ret *= i;\n  }\n  return ret;\n}\n", "  let\
    \ max: number = 1;\n  let i: number;\n  for (i = 2; i <= n; i++) {\n    if (n\
    \ % i === 0) {\n      continue;\n    }\n    max = i;\n  }\n  return max;\n}\n",
  "  // Find all prime factors of n\n  const factors: number[] = [];\n  for (let i\
    \ = 2; i <= n; ++i) {\n    factors.push(i);\n    while (n % i == 0) {\n      factors.push(i++);\n\
    \    }\n  }\n  // If n has no prime factors, return n\n  if (factors.length ==\
    \ 0) {\n    return n;\n  }\n\n  // Find the largest prime factor out of the list\n\
    \  let maxFactor: number = factors.pop();\n  while (factors.length > 0) {\n  \
    \  let curFactor = factors.pop();\n    if (curFactor > maxFactor) {\n      maxFactor\
    \ = curFactor;\n    }\n  }\n\n  if (n > maxFactor) {\n    return n;\n  }\n  return\
    \ maxFactor;\n}\n```\n*/\nexport function largest_prime_factor(n: number): number;\n",
  "  let i: number = 0;\n  let p: number = 2;\n  let max_factor: number = 1;\n  while\
    \ (n < 1 || n % p) {\n    i++;\n    p = p * i | 0;\n  }\n  max_factor = max_factor\
    \ * p | 0;\n  if (n > 1) {\n    max_factor = max_factor / n | 0;\n  }\n  return\
    \ max_factor | 0;\n}\n", "  var largest = 1; // 2 is the smallest prime factor.\n\
    \  var i: number;\n  for (i = n - 2; i > 0; i--) {\n    var next = n + i;\n  \
    \  if (next < n && next > largest) {\n      largest = next;\n    }\n  }\n  return\
    \ largest;\n}\n", "    var sqrtn = Math.sqrt(n);\n    var m = n | 0;\n    var\
    \ k = m | 0;\n    while (k < m / 2) {\n        k = k | 0;\n    }\n    while (k\
    \ > 1) {\n        var k2 = k | 0;\n        m /= k2;\n        k /= 2;\n       \
    \ if (k > m) {\n            m += m;\n            k++;\n        }\n    }\n    return\
    \ m | 0;\n}\n", "    let i = 2;\n    while (i < n && n % i == 0) {\n        i\
    \ += 2;\n    }\n    return i;\n}\n\n<|/ file ext=.ts dstars=1 |><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>\n\
    <footer class=\"footer\">\n  <p>\n    <span class=\"heart\">\n      <svg\n   \
    \     viewBox=\"0 0 250 250\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n\
    \        xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n      >\n        <defs>\n\
    \          <path\n            d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0\
    \ Z\"\n          ></path>\n        </defs>\n        <g\n          id=\"surface1\"\
    \n          transform=\"translate(-115.000000, -130.000000) scale(0.100000, -0.100000)\"\
    \n        >\n          <g\n            id=\"Group_7\"\n            transform=\"\
    translate(115.000000, 130.000000) scale(0.100000, -0.100000)\"\n          >\n\
    \            <g\n              id=\"Group_8\"\n              transform=\"translate(347.000000,\
    \ 347.000000) scale(0.100000, -0.100000)\"\n            >\n              <g\n\
    \                id=\"Group_9\"\n                transform=\"translate(347.000000,\
    \ 520.000000) scale(0.100000, -0.100000)\"\n              >\n                <g\n\
    \                  id=\"Group_10\"\n                  transform=\"translate(347.000000,\
    \ 635.000000) scale(0.100000, -0.100000)\"\n                >\n              \
    \    <g\n                    id=\"Group_11\"\n                    transform=\"\
    translate(347.000000, 766.000000) scale(0.100000, -0.100000)\"\n             \
    \     >\n                    <g\n                      id=\"Group_12\"\n     \
    \                 transform=\"translate(347.000000, 890.000000) scale(0.100000,\
    \ -0.100000)\"\n                    >\n                      <g\n            \
    \            id=\"Group_13\"\n                        transform=\"translate(347.000000,\
    \ 1022.000000) scale(0.100000, -0.100000)\"\n                      >\n       \
    \                 <g\n                          id=\"Group_14\"\n            \
    \              transform=\"translate(347.000000, 1156.000000) scale(0.100000,\
    \ -0.100000)\"\n                        >\n                          <g\n    \
    \                        id=\"Group_15\"\n                            ", "  let\
    \ factor: number = 0;\n  let i: number;\n  for (i = 1; i <= n; i += 1) {\n   \
    \ factor = i;\n    for (let j = i; j <= n - factor; j += 1) { //j is factor\n\
    \      if (n % j === 0) {\n        factor = j;\n        break;\n      }\n    }\n\
    \    if (factor > 0 && factor < n) { //If no factors were found return n\n   \
    \   return n;\n    }\n  }\n  return factor;\n}", "    let factor: number = n\n\
    \    let factors: number[] = []\n    while (factor <= Math.sqrt(n)) {\n      \
    \  if (n % factor === 0) {\n            factors.push(factor)\n            factor++\n\
    \        } else {\n            factor = Math.floor(n / factor)\n        }\n  \
    \  }\n    if (n > 1) {\n        factors.push(n % factor, 0)\n    }\n    return\
    \ factors\n}"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
