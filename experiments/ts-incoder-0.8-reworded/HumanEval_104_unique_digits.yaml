name: HumanEval_104_unique_digits
language: ts
prompt: "//Given an array of positive integers x. return a sorted array of all \n\
  // elements that hasn't any even digit.\n// Note: Returned array should be sorted\
  \ in increasing order.\n// For example:\n// >>> unique_digits([15, 33, 1422, 1])\n\
  // [1, 15, 33]\n// >>> unique_digits([152, 323, 1422, 10])\n// []\nfunction unique_digits(x:\
  \ number[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = unique_digits;\n  assert.deepEqual(candidate([15,\
  \ 33, 1422, 1]),[1, 15, 33]);\n  assert.deepEqual(candidate([152, 323, 1422, 10]),[]);\n\
  \  assert.deepEqual(candidate([12345, 2033, 111, 151]),[111, 151]);\n  assert.deepEqual(candidate([135,\
  \ 103, 31]),[31, 135]);\n}\n\ntest();"
completions: ["    let uniqueArray = [];\n    for (let i = 0; i<x.length; i++){\n\
    \        for (let j = 0; j<uniqueArray.length; j++){\n            if ((x[i] %\
    \ 10) == uniqueArray[j] % 10){\n                continue;\n            }\n   \
    \         uniqueArray.push(x[i]);\n        }\n    }\n    return uniqueArray;\n\
    }\n", "    let map = new Map();\n    for (let d of x) {\n        let value = map.get(d);\n\
    \        if (value === undefined) {\n            value = 1;\n        } else {\n\
    \            value = value + 1;\n        }\n        map.set(d, value);\n    }\n\
    \    let result = [];\n    for (let [key, value] of map) {\n        if (value\
    \ % 2 !== 0) {\n            result.push(key);\n        }\n    }\n    result.sort((a,\
    \ b) => a - b);\n    return result;\n}\n", "  if (x.length === 0) {\n    return\
    \ [];\n  }\n\n  // find first non zero element \n  var firstNonZeroIdx = 0;\n\
    \  while (firstNonZeroIdx < x.length) {\n    if (x[firstNonZeroIdx] !== 0) {\n\
    \      break;\n    }\n    firstNonZeroIdx++;\n  }\n\n  // slice from first non\
    \ zero element\n  var result = x.slice(0, firstNonZeroIdx);\n  while (firstNonZeroIdx\
    \ < x.length) {\n    // check if the previous element exists\n    var lastNonZeroIdx\
    \ = firstNonZeroIdx;\n    while (lastNonZeroIdx > 0 && result[lastNonZeroIdx]\
    \ !== 0) {\n      lastNonZeroIdx--;\n    }\n\n    // if the previous element is\
    \ even \n    if (result[lastNonZeroIdx] & 1) {\n      // add current element to\
    \ the result\n      result.push(result[lastNonZeroIdx]);\n    } else {\n     \
    \ // remove current element from the result\n      result.splice(lastNonZeroIdx,\
    \ 1);\n    }\n\n    firstNonZeroIdx++;\n  }\n  return result;\n}\n", "    const\
    \ result: number[] = [];\n    for (let i = 0; i < x.length; i++) {\n        if\
    \ (x[i].toString().indexOf('.') === -1) {\n            const str = x[i].toString();\n\
    \            while (str.match(/\\d/)) {\n                str = str.replace(/\\\
    d/g, '');\n            }\n            const idx = result.indexOf(str);\n     \
    \       if (idx === -1) {\n                result.push(str);\n            }\n\
    \        }\n    }\n    result.sort((a, b) => a - b);\n    return result;\n}\n\
    </code>\n<|/ a tags=arrays,javascript |>\n<| c |>\nThanks for the help! This was\
    \ really helpful!\n<|/ c |>\n<| c |>\nNo problem, happy to help!\n<|/ c |>\n<|\
    \ c |>\nWhat does this function do when applied to an empty array? `unique_digits([])`\
    \ returns an empty array instead of `[0]`.\n<|/ c |>\n<| c |>\nThe function should\
    \ return `[0]` instead of `[]`\n<|/ c |>\n<| c |>\nI meant `unique_digits([0])`\n\
    <|/ c |>\n<| a tags=arrays,javascript |>\n<code>", "    let result = []\n    let\
    \ map = new Map()\n    x.map((val) => {\n        let rem = val % 10\n        let\
    \ digit = val / 10\n        map.set(rem, digit)\n    })\n    map.forEach((val,\
    \ key) => {\n        if(val % 2 == 0) {\n            result.push(key)\n      \
    \  }\n    })\n    result.sort((a: number, b: number) => {\n        return a -\
    \ b\n    })\n    return result\n}\n", "    const digits = x.map(x => Math.floor(Math.log10(x)));\n\
    \    const res = [];\n    \n    for (let i = 0; i < x.length; i++){\n        for\
    \ (let j = 0; j < digits.length; j++){\n            if (x[i] % 10 == digits[j]){\n\
    \                res.push(x[i]);\n                break;\n            }\n    \
    \    }\n    }\n    \n    return res;\n}\n", "  let map: number[][] = [[]]\n  for\
    \ (let i = 0; i < x.length; i++) {\n    let num: number = x[i];\n    let j: number[]\
    \ = map.find(item => {\n      return item.some(y => y === num);\n    });\n   \
    \ if (j) {\n      j = j.concat([num]);\n    } else {\n      map.push(num);\n \
    \   }\n  }\n  return map\n    .sort((a, b) => a - b)\n    .filter(item => item.some(y\
    \ => y % 2 === 0));\n}\n", "    for (let i = 0; i < x.length; i++) {\n       \
    \ if (x[i] % 2 != 0) {\n            x.splice(i, 1);\n        }\n    }\n    x.sort();\n\
    \    return x;\n}\n", "  const result: number[] = [];\n  for (let i = 0; i < x.length;\
    \ i++) {\n    const hasEvenDigit =\n      !Number.isNaN(x[i]) && x[i] % 2 ===\
    \ 0;\n    if (hasEvenDigit) {\n      result.push(x[i]);\n    }\n  }\n  return\
    \ result.sort();\n}\n", "    if (x.length === 0) {\n        return []\n    }\n\
    \    \n    var result: number[] = []\n    var seen = new Set()\n    \n    for\
    \ (const val of x) {\n        if (seen.has(val)) {\n            return result\n\
    \        }\n        \n        let digits = String(val).split('')\n        let\
    \ digitLen = digits.length\n        for (let i = 0; i < digitLen; i += 1) {\n\
    \            let current = digits[i]\n            if (current.charAt(0) === '.')\
    \ {\n                continue\n            }\n            \n            if (current.charAt(0)\
    \ % 2 === 0 && seen.has(Number(current + digits[i + 1]))) {\n                continue\n\
    \            }\n            \n            result.push(val)\n            seen.add(val)\n\
    \        }\n    }\n    \n    return result\n}\n", "    // Write your code here\n\
    \    var ret = []\n    var i = 0\n    while (i<x.length) {\n        if (x[i]%2\
    \ == 0) {\n            ret.push(x[i]);\n        }\n        i++;\n    }\n    ret.sort((a,b)=>a-b);\n\
    \    return ret;\n}\n</code>\nThe time complexity is O(n). And it works since\
    \ each iteration of the while loop will either be true or false (since we know\
    \ that the array will always have at least one number).\n<|/ a |>\n<| c |>\nThanks\
    \ for this answer. But the complexity is still O(n).\n<|/ c |>\n<| c |>\nThis\
    \ algorithm is correct but it also returns the original input array which was\
    \ provided in the original question.\n<|/ c |>\n<| a |>\nOk, I finally figured\
    \ it out. Here's my solution. \n<code>", "    const result: number[] = [];\n \
    \   let startIndex = 0;\n    let endIndex = 0;\n\n    while (startIndex < x.length)\
    \ {\n        endIndex = startIndex + 1;\n        while (endIndex < x.length) {\n\
    \            if (x[endIndex] % 2 == 0) {\n                break;\n           \
    \ }\n            endIndex++;\n        }\n\n        if (startIndex < endIndex)\
    \ {\n            result.push(x[startIndex]);\n            startIndex = endIndex;\n\
    \        }\n    }\n    return result;\n}\n", "    let temp: number[] = [];\n \
    \   for(let i=0; i<x.length; i++) {\n        if(x[i] % 2 === 0) {\n          \
    \  temp.push(x[i]);\n        }\n    }\n    return temp;\n}\n", "    const result:\
    \ number[] = [];\n    \n    x.forEach((item: number) => {\n        if(item % 2\
    \ == 0)\n            result.push(item);\n    });\n    \n    result.sort();\n \
    \   \n    return result;\n}\n</code>\n<|/ a tags=arrays,algorithm dscore=0 |>\n\
    <| a |>\n<code>\nlet nums = [1, 2, 3, 4, 5, 6, 7];\nlet result = [];\n\nnums.map((x)=>{\n\
    \    if(x%3 == 0 && x%5 == 0)\n        console.log(x);\n    else\n        result.push(x);\n\
    });\n\nconsole.log(result);\n</code>\n<|/ a dscore=0 tags=arrays,algorithm |>\n\
    <| a |>\nHere is a solution using Map and sort().\n\n<code>\nconst getUnique =\
    \ (arr) => {\n  const result = [];\n  const map = new Map();\n  const sortedMap\
    \ = new Map();\n  \n  arr.forEach(n => {\n    map.set(n, n);\n    sortedMap.set(Math.trunc(Math.log10(n)),\
    \ n);\n  });\n  \n  sortedMap.forEach((val, key) => {\n    if(map.has(key)) {\n\
    \      const value = map.get(key);\n      result.push(value);\n      map.delete(key);\n\
    \    }\n  });\n\n  return result;\n};\n\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\nconst result = getUnique(arr);\nconsole.log(result);</code>\n<|/ a tags=arrays,algorithm\
    \ dscore=0 |>\n<| a tags=arrays,algorithm |>\n<code>", "  let result = [];\n \
    \ let hashSet = new Set();\n  let hashMap = new Map();\n  for (let i = 0; i <\
    \ x.length; i++) {\n    if (hashSet.has(x[i])) {\n      continue;\n    }\n   \
    \ hashSet.add(x[i]);\n    for (let j = 0; j < 9; j++) {\n      if (!hashSet.has((x[i]\
    \ % 10) * 10 + j)) {\n        hashMap.set(x[i] % 10, []);\n      }\n      hashMap.get(x[i]\
    \ % 10).push(j);\n    }\n  }\n  for (let i = 0; i < 10; i++) {\n    if (!hashMap.has(i))\
    \ {\n      result.push(i);\n    }\n  }\n  return result;\n}\n", "\tlet result:\
    \ number[] = [];\n\tlet min = 0;\n\tlet max = x.length - 1;\n\tfor (let i = 0;\
    \ i <= max; i++) {\n\t\tlet sum: number = 0;\n\t\tfor (let j = 0; j < x[i]; j++)\n\
    \t\t\tsum += x[j];\n\t\tif (sum % 2 != 0)\n\t\t\tresult.push(x[i]);\n\t}\n\treturn\
    \ result;\n}\n", "  const arr: number[] = [];\n  for (let i = 0; i < x.length;\
    \ i++) {\n    const lastDigit = x[i];\n    const indexOfLastDigit = arr.length\
    \ - 1;\n    for (let j = indexOfLastDigit; j >= 0; j--) {\n      if (x[j] % lastDigit\
    \ === 0) {\n        arr.splice(indexOfLastDigit + 1, 0, x[i]);\n        break;\n\
    \      }\n    }\n  }\n  return arr;\n}\n", "    const result: number[] = [];\n\
    \    const length = x.length;\n    let i: number = 1;\n    while (i < length)\
    \ {\n        if (x[i] % 2 === 0) {\n            result.push(x[i]);\n         \
    \   ++i;\n            continue;\n        }\n        for (let j = i; j < length;\
    \ ++j) {\n            if (x[j] % 2 === 0) {\n                ++j;\n          \
    \      break;\n            }\n        }\n        result.push(x[i]);\n        ++i;\n\
    \    }\n    return result;\n}\n", "\tlet n: number[] = [];\n\tfor (let i: number\
    \ = 0; i < x.length; i++) {\n\t\tif (n % 2 == 0) {\n\t\t\tn.push(x[i]);\n\t\t\
    }\n\t}\n\treturn n.sort();\n}\n", "  let even: number[] = [];\n  let odds: number[]\
    \ = [];\n\n  x.forEach(e => {\n    if (e % 2 === 0) {\n      even.push(e);\n \
    \   } else {\n      odds.push(e);\n    }\n  });\n  odds.sort((a, b) => {\n   \
    \ return a - b;\n  });\n\n  let result: number[] = [];\n\n  for (let i = 0; i\
    \ < odds.length; i++) {\n    if (odds[i] === 0) {\n      result.push(even[i]);\n\
    \    }\n  }\n  return result;\n}\n", "    let result = [];\n    for (let i = 0;\
    \ i < x.length; i++) {\n        let found = true;\n        for (let j = 0; j <\
    \ result.length; j++) {\n            if (result[j] < x[i]) {\n               \
    \ found = false;\n                break;\n            }\n        }\n        if\
    \ (found) {\n            result.push(x[i]);\n        }\n    }\n    return result;\n\
    }\n", "  const y = x.sort((a, b) => a - b) // sort the array\n  let arr = []\n\
    \  while (y.length > 0) {\n    const last = y[y.length - 1]\n    if (last % 2\
    \ === 0) { // if the last digit is even\n      y.pop()\n    } else {\n      arr.push(last)\n\
    \    }\n  }\n  return arr\n}\n", "  let y = x[0];\n  const result: number[] =\
    \ [];\n  for (let i = 1; i < x.length; i++) {\n    let n = x[i];\n    for (let\
    \ j = 0; j < 9; j++) {\n      if (n % 10 === j) {\n        n = 0;\n        break;\n\
    \      }\n    }\n    if (n !== 0) {\n      result.push(n);\n    }\n  }\n  return\
    \ result;\n}\n", "    const evenNumbers = []\n    for (const num of x){\n    \
    \    if(num % 2 === 0){\n            evenNumbers.push(num)\n        }\n    }\n\
    \    return evenNumbers\n}\n", "    let result = [];\n    let count = new Map<number,\
    \ number>();\n\n    for (let n of x) {\n        if (count[n]) {\n            result.push(n);\n\
    \        }\n        count[n] = count[n] ? count[n] + 1 : 1;\n    }\n\n    return\
    \ result.sort((a: number, b: number) => a - b).filter((e, i) => !result.includes(e)\
    \ && count[e] === count[i]);\n}\n", "    for (let i = 0; i < x.length; i++) {\n\
    \        if (x[i] % 2 === 0) {\n            continue;\n        }\n\n        for\
    \ (let j = i; j < x.length; j++) {\n            if (x[j] % 2 !== 0) {\n      \
    \          break;\n            }\n\n            if (x[j] < x[0]) {\n         \
    \       break;\n            }\n        }\n\n        if (x[j] - x[i] === 0) {\n\
    \            for (let k = i; k < j; k++) {\n                x[k] = x[k + 1];\n\
    \            }\n        }\n    }\n\n    return x;\n}\n", "    let ans: number[]\
    \ = [];\n    for (let num of x) {\n        let arr: number[] = [];\n        for\
    \ (let i = 0; i < num.toString().length; i++) {\n            let digit = parseInt(num.toString().charAt(i));\n\
    \            if (digit % 2 === 0) {\n                arr.push(digit);\n      \
    \      }\n        }\n        if (arr.length > 0) {\n            ans = ans.concat(arr);\n\
    \        }\n    }\n    return ans;\n}\n", "  const map = new Map()\n  for (let\
    \ i = 0; i<x.length; i++){\n    if(x[i] % 2 === 0){\n      map.set(x[i], true)\n\
    \    }\n  }\n  const list = new Array<number>()\n  for (let i = 0; i<map.size;\
    \ i++){\n    list.push(i)\n  }\n  const result: number[] = []\n  while (list.length\
    \ > 0){\n    const current = list.pop()\n    for (let i=0; i<map.size; i++){\n\
    \      if (map.get(i) && list[i] !== current){\n        list.push(current)\n \
    \     }\n    }\n  }\n  return result\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    While this may answer the question, it's better to add some explanation about\
    \ how this answer works.\n<|/ c |>\n<| c |>\nThis doesn't work. In the first part\
    \ I got [15, 33, 1422, 1] as result but in the second part I got [] as result.\n\
    <|/ c |>\n<| c |>\nI edited the code to use `Map` instead of `Object` as container.\
    \ Hope it helps\n<|/ c |>\n<| c |>\nI got same result as before.\n<|/ c |>\n<|\
    \ c |>\nDo you have any idea on how to improve this code? I really need to make\
    \ this work. Thanks!\n<|/ c |>\n<| a |>\nAnother solution is to build a hash table\
    \ from input array, and then remove duplicate elements from the hash table using\
    \ another hash table.\nThe complexity of the solution is O(n*log(n)).\n\n<code>",
  "    const set = new Set();\n    for (let i = 0; i < x.length; i++) {\n        const\
    \ digit = x[i];\n        if (digit.toString().startsWith('0')) {\n           \
    \ continue;\n        }\n        let arr: number[] = [];\n        while (!set.has(digit))\
    \ {\n            set.add(digit);\n            arr = arr.concat(digit);\n     \
    \   }\n        arr.sort();\n        return arr;\n    }\n    return [];\n}\n",
  "  const set = new Set<number>();\n  for (let i of x) {\n    if (set.has(i)) {\n\
    \      continue;\n    }\n    const str = i.toString();\n    for (let j = 1; j\
    \ < str.length; j++) {\n      const c = str.charAt(j);\n      if (c === c.toUpperCase())\
    \ {\n        set.add(j * 10);\n      }\n    }\n  }\n  return Array.from(set);\n\
    }\n", "\tlet y = [];\n\tfor (let i = 0; i < x.length; i++) {\n\t\tlet count =\
    \ 0;\n\t\tfor (let j = 0; j < x.length; j++) {\n\t\t\tif (x[j] % 2 == 0) {\n\t\
    \t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count != 0) {\n\t\t\ty.push(x[i]);\n\t\
    \t}\n\t}\n\treturn y;\n}\n", "  let result = [];\n  for (let i = 0; i < x.length;\
    \ i++) {\n    let isEven = i % 2 === 0;\n    if (isEven) {\n      if (result.indexOf(x[i])\
    \ === -1) {\n        result.push(x[i]);\n      }\n    }\n  }\n  return result;\n\
    }\n", "    const ret: number[] = [];\n    for (let i = 0; i < x.length; i++) {\n\
    \        if (x[i] % 2 == 0) {\n            for (let j = 0; j < x.length; j++)\
    \ {\n                if (x[j] % 2 != 0) {\n                    if (x[i] == x[j])\
    \ {\n                        ret.push(x[i]);\n                        break;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return ret;\n}\n</code>\n<|/ a tags=arrays,javascript,algorithm,recursion\
    \ |>\n<| c |>\nA few things about this solution, 1) the return type should be\
    \ number[] not number. 2) `unique_digits([1,5,2,8,3,7,9,0,4,6,6,2,6,7,2,5,2,5,2,5,2,7,5,4,5,4,4,4,5,5,2,4,5,4,6,5,3,5,1,6,3,6,1,5,2,8,4,4,2,5,1,4,4,6,2,8,3,6,5,1,5,2,1,4,1,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,2,8,5,4,3,7,1,4,2,7,2,6,5,",
  "\tvar new_array: number[] = [];\n\tfor(var i = 0; i < x.length; i++) {\n\t\tfor(var\
    \ j = 0; j < x.length; j++) {\n\t\t\tif (x[i] * x[j] === 0) {\n\t\t\t\tnew_array.push(x[i]);\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn new_array;\n}\n", "    if (x.length\
    \ == 0) {\n        return []\n    }\n\n    if (x.reduce((acc, cur) => Math.pow(10,\
    \ acc) + cur, 0) % 1 === 0) {\n        return [...x]\n    }\n\n    const even:\
    \ number[] = []\n    for (let i = 0; i < x.length; i++) {\n        const last\
    \ = x[i - 1]\n        if (x[i] % 2 == 0 && last % 2 != 0) {\n            even.push(x[i])\n\
    \        }\n    }\n\n    return even.sort((a: number, b: number) => a - b)\n}\n",
  "  const result = [];\n  for (let i = 0; i < x.length; i++) {\n    const curr =\
    \ x[i];\n    result.push(curr);\n    while (curr % 10 == 0) {\n      result.push(curr\
    \ / 10);\n      curr /= 10;\n    }\n  }\n  return result;\n}\n", "\tlet arr =\
    \ [];\n\tlet tmp, cnt = 0;\n\n\tfor (let i = 0; i < x.length; i++) {\n\t\twhile\
    \ (x[i] != 0) {\n\t\t\ttmp = x[i] % 10;\n\t\t\tif (arr[0] != tmp) {\n\t\t\t\t\
    arr[cnt] = tmp;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tx[i] /= 10;\n\t\t}\n\t}\n\treturn\
    \ arr.sort((a, b) => {\n\t\tif (a > b) return 1;\n\t\telse if (a < b) return -1;\n\
    \t\treturn 0;\n\t});\n}\n", "    const y: number[] = [];\n    for (let i: number\
    \ = x.length - 1; i >= 0; --i) {\n        if (x[i] % 2 === 0 && x[i] != 0) {\n\
    \            y.push(x[i]);\n        }\n    }\n    y.sort();\n    return y;\n}\n",
  "    var result: number[] = [];\n    \n    for (var i = 0; i < x.length; i++) {\n\
    \        if ((x[i] % 2) === 0) {\n            result.push(x[i]);\n        }\n\
    \    }\n\n    if (result.length > 0) {\n        result.sort();\n    }\n    \n\
    \    return result;\n}\n", "\tconst nums = x.filter((n: number) => n % 10 ===\
    \ 0);\n\tlet digit: number = 0;\n\tlet tmp: number[] = [];\n\tfor (const n of\
    \ nums) {\n\t\tif (n % 10 === 0) {\n\t\t\ttmp.unshift(n);\n\t\t} else {\n\t\t\t\
    while (tmp.length > 0 && tmp[0] % 10 === 0) {\n\t\t\t\ttmp.unshift(tmp[0]); //\
    \ shift left and add next digit to it\n\t\t\t}\n\t\t\ttmp.unshift(n);\n\t\t}\n\
    \t}\n\treturn tmp;\n}\n", "    const set = new Set<number>();\n    for (const\
    \ i of x) {\n        if (set.has(i)) {\n            continue;\n        }\n   \
    \     if ((i & 1) == 0) {\n            set.add(i);\n        }\n    }\n    return\
    \ [...set];\n}\n", "    return x.reduce((acc, val) => {\n        let flag = false;\n\
    \        x.forEach((i) => {\n            if (val % i === 0 && flag === false)\
    \ {\n                flag = true;\n                acc.push(val);\n          \
    \  }\n        });\n        return acc;\n    }, []);\n}\n", "  let result = [];\n\
    \  for(let i of x) {\n    let d = i % 10;\n    if(d === 0) {\n      continue;\n\
    \    }\n    result.push(d);\n  }\n  result.sort((a,b)=>a-b);\n  for(let i of x)\
    \ {\n    if(i%10 !== result[result.length-1]) {\n      result.push(i%10);\n  \
    \  }\n  }\n  return result;\n}\n\n", "    if (x.length === 0) {\n        return\
    \ []\n    }\n    const digits: number[] = [];\n    let isEven: boolean = false;\n\
    \    for (let i = 0; i < x.length; i++) {\n        if (digits.length === 0) {\n\
    \            if (x[i] % 2 === 0) {\n                isEven = true\n          \
    \  }\n            continue;\n        }\n        if (x[i] % 2 === 0) {\n      \
    \      if (isEven) {\n                digits.push(Math.max(x[i] / 10, 1))\n  \
    \          } else {\n                digits.push(Math.min(x[i] / 10, digits[digits.length\
    \ - 1]))\n            }\n            isEven = !isEven\n        } else {\n    \
    \        digits.push(Math.min(x[i] / 10, digits[digits.length - 1]))\n       \
    \ }\n    }\n    if (digits.length === 0) {\n        return []\n    }\n    return\
    \ digits\n}\n", "    let arr = x.sort((a: number, b: number) => a - b);\n    let\
    \ result = [];\n    while (arr.length > 0) {\n        let first = arr[0];\n  \
    \      if (first % 2 === 0 && first !== 0 && result.indexOf(first) === -1) {\n\
    \            result.push(first);\n        }\n        arr.splice(0, 1);\n    }\n\
    \    return result;\n}\n</code>\n<|/ a dscore=0 tags=arrays,sorting,javascript,algorithm\
    \ |>\n<| c |>\nThank you for the answer. Very nice solution. However it can be\
    \ improved in two ways:\n- `arr = [...arr]` is unnecessary\n- `arr.splice(0,0,...)`\
    \ is unnecessary\n<|/ c |>\n<| c |>\n, thanks for pointing out for these two cases.\
    \ However, it still won't be fully optimized, since `Array.slice` still has to\
    \ be iterated through for every `splice`.\n<|/ c |>\n<| a dscore=0 tags=arrays,sorting,javascript,algorithm\
    \ |>\nThis problem can be solved in O(n) time by using Hash Table. In the solution\
    \ below Hash Table is used to store the positions of even numbers. \n\n<code>\n\
    var arr = [10, 9, 8, 7, 4, 5, 6, 1, 2, 3, 9, 8];\n", "  const newArr = new Array();\n\
    \  let i = 1;\n  let j = x.length;\n  while (j < i) {\n    while (x[j] % i ===\
    \ 0 ) {\n      j++;\n    }\n    newArr.push(x[j]);\n    i++;\n  }\n  return newArr;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nCould you explain the code a little bit please?\n\
    <|/ c |>\n<| c |>\nI've added an explanation above :)\n<|/ c |>\n<| a |>\nYou\
    \ can do that with only a couple of loops.\nThe idea is:\n\nStart with an empty\
    \ set\nIterate from both ends of the array\nFor every element, add it if it is\
    \ not already in the set\n\nThis way, the elements in the result are just the\
    \ elements that appear in the array one and only one time.\nThe trick here is\
    \ to use set.has(element) instead of element in set since it is faster.\n<code>",
  "    var yArray = new Array();\n    for (var i = 0, len = x.length; i < len; i++)\
    \ {\n        if (x[i] % 2 == 0) {\n            yArray.push(x[i]);\n        }\n\
    \    }\n    return yArray.sort();\n}\n</code>\n<|/ a |>\n<| c |>\nYour solution\
    \ is wrong when given input `[1, 2, 1, 3]` - it should return `[1, 2, 3]`.\n<|/\
    \ c |>\n<| a |>\n<code>", "    if (x.length < 1) return [];\n    const result\
    \ = [];\n    for (let i = 0; i < x.length; i++) {\n        let current = x[i];\n\
    \        while (current > 0) {\n            if (result && result[result.length\
    \ - 1] < current) {\n                result.push(current);\n            } else\
    \ {\n                current = current % 10;\n            }\n        }\n    }\n\
    \    if (result.length > 1) {\n        result = result.sort((a, b) => a - b);\n\
    \    }\n    return result;\n}\n", "    var result: number[] = [];\n    var i =\
    \ 0;\n    while (i < x.length) {\n        var isEven = false;\n        var currentNum\
    \ = parseInt(x[i], 10);\n        if (currentNum % 2 == 0) {\n            result[result.length]\
    \ = currentNum;\n            i++;\n        } else {\n            isEven = true;\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 tags=arrays,javascript,sorting\
    \ |>\n<| a dscore=0 |>\nThis is a simple solution. Given that numbers are all\
    \ integers and only contain one digit, we can simply keep track of the lowest\
    \ digit and add it to every number after it until the number is a single digit.\
    \ \n<code>", "  let unique: number[] = [];\n  for (let i = 0; i < x.length; i++)\
    \ {\n    let y = x[i];\n    let isEven = false;\n    for (let j = 0; j < unique.length;\
    \ j++) {\n      if (y % 2 == 0 && unique[j] % 2 != 0) {\n        isEven = true;\n\
    \        break;\n      }\n    }\n    if (!isEven) {\n      unique.push(y);\n \
    \   }\n  }\n  return unique;\n}\n", "  let newArr = []\n  for(let i = 0; i < x.length;\
    \ i++) {\n    let sum = 0\n    let value = x[i]\n    let tempArr = []\n    for(let\
    \ j = 0; j < value; j++) {\n      if( (value % j) == 0) {\n        sum += j\n\
    \        tempArr.push(j)\n      }\n    }\n    if(sum == 0){\n      newArr = tempArr\n\
    \    }\n  }\n  return newArr\n}\n", "  \n  const arr = [];\n  \n  for(let i =\
    \ 0; i < x.length; i++) {\n    if(x[i] % 2 === 0) {\n      arr.push(x[i]);\n \
    \   }\n  }\n  \n  return arr;\n}\n", "  let digits_map: Map<number, boolean> =\
    \ new Map();\n  for (let i = 0; i < x.length; i++) {\n    digits_map.set(x[i],\
    \ true);\n  }\n  let result: number[] = [];\n  for (let i = 0; i < x.length; i++)\
    \ {\n    if (!digits_map.has(x[i])) result.push(x[i]);\n  }\n  return result;\n\
    }\n", "    let res = [];\n    for (let i = 0; i < x.length; i++) {\n        let\
    \ y = Math.floor(x[i]/10)\n        res.push(y);\n    }\n    let unique = res.filter((v,\
    \ i, a) => a.indexOf(v) === i);\n    return unique;\n}\n", "\tlet digits = new\
    \ Set();\n\tfor (let i = 0; i < x.length; i++) {\n\t\tlet num: number = x[i];\n\
    \t\twhile (num > 0) {\n\t\t\tlet temp = num % 10;\n\t\t\tif (digits.has(temp))\
    \ {\n\t\t\t\tnum -= temp;\n\t\t\t} else {\n\t\t\t\tdigits.add(temp);\n\t\t\t\t\
    num = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn [...digits];\n}\n", "    for (let i =\
    \ 0; i < x.length; i++) {\n        let count = 0;\n        for (let j = 0; j <\
    \ x.length; j++) {\n            if (x[j] === x[i]) {\n                count++;\n\
    \            }\n        }\n        if (count % 2 === 0) {\n            x[i] =\
    \ -1;\n        }\n    }\n    x.sort();\n    return x\n}\nconsole.log(unique_digits([15,\
    \ 33, 1422, 1])); //[1, 15, 33]\nconsole.log(unique_digits([152, 323, 1422, 10]));\
    \ //[]</code>\n\nThe above is simple and efficient but can be optimized using\
    \ sort with custom comparator as follows -\n\n<code>", "    const arr = x.sort((a:\
    \ number, b: number) => a - b);\n    const res = [];\n    let i = 1;\n    for\
    \ (let j = 0; j < arr.length; j++) {\n        if (arr[j] % 2 == 0) {\n       \
    \     if (arr[j] > i) {\n                res.push(i);\n                i = arr[j];\n\
    \            } else {\n                res.push(arr[j]);\n            }\n    \
    \    } else {\n            i++;\n        }\n    }\n    return res;\n}\n", "  \
    \  var result = new Array<number>();\n    for (let i = 0; x < 10; i++) {\n   \
    \     var is_even = true;\n        var num = new Array<number>();\n        for\
    \ (let j = 0; j < x[i].length; j++) {\n            if (x[i][j] < 10) {\n     \
    \           num.push(x[i][j]);\n            }\n        }\n        for (let j =\
    \ 0; j < num.length; j++) {\n            if (num[j] % 2 === 0) {\n           \
    \     is_even = false;\n            }\n        }\n        if (is_even) {\n   \
    \         result.push(num[0]);\n        }\n    }\n    for (let i = 0; i < result.length;\
    \ i++) {\n        for (let j = 0; j < result.length; j++) {\n            if (result[i]\
    \ === result[j] && result[i] !== i) {\n                result.splice(j, 1);\n\
    \                break;\n            }\n        }\n    }\n    result.sort(function\
    \ (a, b) { return a - b; });\n    return result;\n}\n", "  let result = [];\n\
    \  for (let i = 0; i < x.length; i++) {\n    let tmp = [];\n    for (let j = 0;\
    \ j < i; j++) {\n      if (x[j] % 2 === 0) {\n        tmp.push(x[j]);\n      }\n\
    \    }\n    for (let j = 0; j < i; j++) {\n      if (tmp.length == 0) {\n    \
    \    result.push(x[i]);\n      }\n    }\n  }\n  return result;\n}\n", "    const\
    \ result = [];\n    for (let i = 0; i < x.length; i++) {\n        let digits =\
    \ x[i].toString();\n        for(let j = 0; j < digits.length; j++){\n        \
    \    let index = digits[j] - '0';\n            let currentIndex = result.indexOf(index);\n\
    \            if(currentIndex == -1){\n                result.push(index);\n  \
    \          }\n        }\n    }\n    result.sort();\n    return result;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThe best solution I ever seen. You are my hero. Thank\
    \ you very much.\n<|/ c |>\n<| a dscore=2 tags=javascript,sorting |>\nTry this\
    \ solution:\n<code>", "  if (x.length < 2) return x;\n  let arr: number[] = [];\n\
    \  x.forEach((item: number) => {\n    arr.push(item);\n  });\n  let arrCopy =\
    \ arr.slice(0);\n  arrCopy.sort((a: number, b: number) => {\n    if (a % 2 ==\
    \ 0) return -1;\n    if (b%2 == 0) return 1;\n    return a < b ? -1 : 1;\n  });\n\
    \  arrCopy.forEach((item: number) => {\n    if (item % 2 == 0) arrCopy.splice(arr.indexOf(item),\
    \ 1);\n  });\n  return arrCopy;\n}\n", "\tlet evenDigits: number[] = [];\n\tlet\
    \ oddDigits: number[] = [];\n\tlet digits: number[] = [];\n\tfor (let i: number\
    \ = 0; i < x.length; i++) {\n\t\tdigits.push(x[i]);\n\t\tif (i % 2 === 1) {\n\t\
    \t\toddDigits.push(x[i]);\n\t\t} else {\n\t\t\tevenDigits.push(x[i]);\n\t\t}\n\
    \t}\n\tlet sortedDigits = unique_digits(evenDigits); //Recursively call\n\tsortedDigits.splice(0,\
    \ 0, ...oddDigits); //Splice adds element after that \n\t//in the array, so just\
    \ adding oddDigits to sortedDigits won't work\n\t\n\tdigits = digits.concat(sortedDigits);\n\
    \treturn digits;\n}\n", "    const counter: any = {};\n    for (let i = 0; i <\
    \ x.length; i++) {\n        if (counter[x[i]] === undefined) {\n            counter[x[i]]\
    \ = 0;\n        }\n        counter[x[i]]++;\n    }\n    const res: number[] =\
    \ [];\n    for (let i = 0; i < x.length; i++) {\n        if (counter[x[i]] ===\
    \ 0) {\n            res.push(x[i]);\n        }\n    }\n    return res;\n}", " \
    \   let result: number[] = []\n    for (let i: number = 0; i < x.length; i++)\
    \ {\n        if (x.find(i => i % 2 === 0)) {\n            result.push(x[i])\n\
    \        }\n    }\n    result.sort()\n    return result\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is the best answer because it does not use any external libraries\
    \ and it works in O(nlogn).\n<|/ c |>\n<| a tags=algorithm,sorting,javascript\
    \ |>\nI think it is simpler to sort only the even digits and leave the unsorted\
    \ digits in the beginning of the array after the sorting. \n<code>", "    var\
    \ result = [];\n    var count = {};\n    for (var i = 0, len = x.length; i < len;\
    \ ++i) {\n        var d = Math.floor(x[i] / 10);\n        if (count[d] === undefined)\
    \ count[d] = 0;\n        count[d] += 1;\n        result.push(d);\n    }\n    return\
    \ result.sort(function (a, b) { return a - b; });\n}\n", "    let result = [];\n\
    \    for (let i = 0; i < x.length; i++) {\n        let digit = x[i];\n       \
    \ let index = result.indexOf(digit);\n        if (index == -1) {\n           \
    \ result.push(digit);\n        } else {\n            result.splice(index, 1);\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nHi, would\
    \ you mind giving me a hint on how to do it? I spent the past hours trying to\
    \ use map function, but I'm afraid it isn't my best knowledge. Thank you!\n<|/\
    \ c |>\n<| c |>\n, I updated my answer with a solution using map() and reduce().\
    \ Try this out!\n<|/ c |>\n<| c |>\nHi, this is great! Thanks for your help. I\
    \ have a follow up question: I added a more complex example in my original post,\
    \ could you please take a look? The solution you provided works when there are\
    \ three or more numbers in the array, but when there are only two numbers, it\
    \ only returns one number. How can I improve the solution to return all three\
    \ numbers in the array? Thanks!\n<|/ c |>\n<| c |>\n, Yes, you can. Just change\
    \ `return [...result, ...x]` to `return [...result, ...x].reduce((result, item)\
    \ => [...result, ...unique_digits(item)], []);`. This will work if your array\
    \ contains more than 3 elements since it uses `...result` instead of `result`.\
    \ If your array contains only 2 elements, then you'll have to use `...unique_digits(x[0])`\
    \ and `...unique_digits(x[1])`, instead of `...x` and `...unique_digits(x)`.\n\
    <|/ c |>\n<| c |>\n, Also notice that I changed `x` in `x.map(unique_digits)`\
    \ to `x[i]`. That's because `map` will loop through all the elements in the array.\
    \ Thus, `x[i]` will give you all the numbers from `0` to `x.length - i`.\n<|/\
    \ c |>\n<| a tags=arrays,javascript dscore=0 |>\nHere is a way that uses reduce:\n\
    \n<code>\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n", "\tif (x.length === 0)\
    \ {\n\t\treturn [];\n\t}\n\tconst digits: number[] = [];\n\tlet counter = 0;\n\
    \tfor (let i = 0; i < x.length; i++) {\n\t\tcounter = 0;\n\t\twhile (counter <\
    \ x.length && x[i] % 10 !== 0) {\n\t\t\tx[i] /= 10;\n\t\t\tcounter++;\n\t\t}\n\
    \t\tif (x[i] !== 0) {\n\t\t\tdigits.push(x[i]);\n\t\t}\n\t}\n\treturn digits;\n\
    }\n", "    var res = [];\n    var seen = [];\n    for (var i = 0; i < x.length;\
    \ i++) {\n        var xi = x[i];\n        if (xi.toString().charAt(0) === '0')\
    \ {\n            seen[xi] = 1;\n        } else {\n            for (var j = 0;\
    \ j < seen.length; j++) {\n                if (seen[j] == xi) {\n            \
    \        res.push(xi);\n                    seen[j] = xi;\n                  \
    \  break;\n                }\n            }\n        }\n    }\n    return res;\n\
    }\n", "    // O(n) time, O(n) space\n    const seen: number[] = [];\n    const\
    \ result: number[] = [];\n\n    for (let i = 0; i < x.length; i++) {\n       \
    \ const current = x[i];\n\n        // Search for the element in the seen array\n\
    \        const index = seen.indexOf(current);\n\n        // If element is not\
    \ yet in the seen array\n        if (index === -1) {\n            // Push the\
    \ current element\n            result.push(current);\n            // And add the\
    \ element to the seen array\n            seen.push(current);\n        }\n    }\n\
    \    return result;\n}\n", "    const result: number[] = [];\n    for (let i =\
    \ 0; i < x.length; i++) {\n        if (x[i] % 2 === 0) {\n            result.push(x[i]);\n\
    \        }\n    }\n    return result.sort((a, b) => a - b);\n}\n", "    let digits:\
    \ number[] = []\n    let index: number = 0;\n    for (let i = 0; i < x.length;\
    \ i++) {\n        let value = x[i];\n        if (value % 2 === 0) continue;\n\
    \        digits.push(index)\n        digits.push(value)\n        index++;\n  \
    \  }\n    return digits;\n}\n", "    const ret = [];\n    for (let i = 0; i <\
    \ x.length; i++) {\n        let j = i + 1;\n        while (j < x.length) {\n \
    \           if (x[j] < 10) {\n                let n = x[j];\n                while\
    \ (n%10 === 0) {\n                    n = n/10;\n                    j++;\n  \
    \              }\n                if (n !== 0 && n != x[j]) {\n              \
    \      ret.push(n);\n                    x[j] = -1;\n                }\n     \
    \       }\n            else {\n                j++;\n            }\n        }\n\
    \    }\n    return ret;\n}\n", "    if (x.length === 0) {\n        return [];\n\
    \    }\n\n    const map: number[][] = [];\n    for (let i = 0; i < x.length; i++)\
    \ {\n        if (x[i] % 2 === 0) {\n            map[i] = [];\n        } else {\n\
    \            map[i].push(x[i]);\n        }\n    }\n\n    for (let i = 0; i < map.length;\
    \ i++) {\n        map[i] = Array.from(new Set(map[i]));\n    }\n\n    return map.reduce((acc,\
    \ val) => acc.concat(val), []);\n}\n", "  let arr = [];\n  x.forEach(num => {\n\
    \    let str = num.toString();\n    if (str.indexOf(\"0\") !== -1) {\n      arr.push(num);\n\
    \    }\n  });\n  return arr.sort((a, b) => a - b);\n}\n", "    // Write your code\
    \ here\n    let unique:number[] = [];\n    for(let i = 0; i < x.length; i++)\n\
    \    {\n        if(x[i] % 2 == 0)\n        {\n            continue;\n        }\n\
    \        let j:number;\n        for (j = 0; j < unique.length; j++)\n        {\n\
    \            if(x[i] == unique[j])\n            {\n                break;\n  \
    \          }\n        }\n        \n        if(j == unique.length)\n        {\n\
    \            unique.push(x[i]);\n        }\n    }\n    \n    return unique;\n\
    }\n", "  let ans = [];\n  x.forEach(y => {\n    const nStr = y.toString();\n \
    \   const digits = nStr.split('')\n      .map(x => parseInt(x, 10)) \n      .filter(x\
    \ => x % 2 === 0);\n    digits.length > 0 && ans.push(...digits);\n  });\n  return\
    \ ans.sort(function(a, b) { return a - b; });\n}\n</code>\n<|/ a tags=javascript,typescript\
    \ |>\n<| c |>\nI believe this code does not work. According to [mdn docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\
    \ sort method compares elements *lexicographically* so if two elements are equal,\
    \ they will compare the same way. [Example](https://jsfiddle.net/2qh1z8Lj/)\n\
    <|/ c |>\n<| a |>\n<code>\nconst unique_digits = (numbers: number[]): number[]\
    \ => {\n  const digits = numbers.map(n => n.toString().split('').map(v => parseInt(v,\
    \ 10)).filter(v => v % 2 === 0).sort((a,b) => a-b);\n  return digits.reduce((a,b)\
    \ => a + b);\n}\n</code>\n<|/ a tags=javascript,typescript dscore=0 |>\n<| a |>\n\
    <code>", "  \n}\n", "  const result = [];\n  let counter = 0;\n  while (x.includes(counter))\
    \ {\n    result.push(counter);\n    counter++;\n  }\n  return result;\n}\n", " \
    \   var ret = [],\n        digit: string = '0';\n    \n    for (let i = 0; i <\
    \ x.length; i++) {\n        let xi = x[i];\n        if (xi % 2 == 0) continue;\n\
    \        \n        while ((xi / 10) % 2 == 0) {\n            xi /= 10;\n     \
    \       digit = String(parseInt(digit) + 1).toString();\n        }\n        \n\
    \        ret.push(parseInt(digit));\n    }\n    \n    return ret;\n}\n", "  if\
    \ (x.length === 0) {\n    return x;\n  }\n  const digits: number[] = [];\n  for\
    \ (let i = 0, len = x.length; i < len; ++i) {\n    const d = x[i];\n    if (d\
    \ % 2 === 0) {\n      continue;\n    }\n    const last = digits[digits.length\
    \ - 1];\n    if (last !== undefined && last + 1 < d) {\n      digits.push(last\
    \ + 1);\n    } else {\n      digits.push(d);\n    }\n  }\n  return digits;\n}\n",
  "  const y = [...x];\n  for (let i = 0; i < x.length; i++) {\n    for (let j = 0;\
    \ j < y.length; j++) {\n      if (x[i] % 100 < y[j] % 100) {\n        y[j] = 0;\n\
    \      } else {\n        y[j] = x[i];\n      }\n    }\n  }\n  return y;\n}\n",
  "    const result: number[] = [];\n    let found = false;\n\n    for (let i = 0;\
    \ i < x.length; i++) {\n        const currentElement = parseInt(x[i]);\n\n   \
    \     if (currentElement % 2 !== 0) {\n            result.push(currentElement);\n\
    \        } else {\n            found = true;\n        }\n    }\n\n    if (!found)\
    \ {\n        console.error('No even digit found!');\n    }\n\n    return result;\n\
    }\n", "  let countMap: number[][] = []\n  let result: number[] = []\n  for(let\
    \ i = 0; i < x.length; i++) {\n    let count = countMap[i]\n    if(count === undefined)\
    \ {\n      countMap[i] = 0\n    }\n    countMap[count]++\n    if(countMap[count]\
    \ === 1) {\n      result.push(x[i])\n    }\n  }\n  return result\n}\n", "    let\
    \ even = 0;\n    for (let i = 0; i < x.length; i++) {\n        if (x[i] % 2 ===\
    \ 0) {\n            even = 1;\n        }\n    }\n    if (even === 0) {\n     \
    \   return x;\n    }\n    else {\n        let newArr: number[] = [];\n       \
    \ for (let i = 0; i < x.length; i++) {\n            if ((x[i] % 2 === 0) && (i\
    \ !== x.length - 1)) {\n                newArr.push(x[i]);\n            }\n  \
    \      }\n        newArr.sort();\n        return newArr;\n    }\n}\n", "\tlet\
    \ res: number[] = [];\n\tlet digi: number[] = [];\n\tfor (let i = 0; i < x.length;\
    \ i++) {\n\t\tdigi.push(x[i]);\n\t}\n\tdigi.sort();\n\tfor (let i = 0; i < digi.length;\
    \ i++) {\n\t\tlet dig = 0;\n\t\tfor (let j = 0; j < digi.length; j++) {\n\t\t\t\
    if (digi[j] % 2 == 0) {\n\t\t\t\tdig += 1;\n\t\t\t\tdigi.splice(j, 1);\n\t\t\t\
    }\n\t\t}\n\t\tif (dig > 0 && res.indexOf(dig) == -1) {\n\t\t\tres.push(dig);\n\
    \t\t}\n\t}\n\treturn res;\n}\n", "  let even: boolean[] = [];\n  x.forEach((num:\
    \ number) => {\n    if (!even.includes(num % 10)) {\n      even.push(num % 10);\n\
    \    }\n  });\n  return even.filter((num: number) => num > 0).sort();\n}\n", " \
    \ const hashMap = new Map<number, number>();\n  for (let i = 0; i < x.length;\
    \ i++) {\n    const item = x[i];\n    const hashVal = item % 10;\n    const oldVal\
    \ = hashMap.get(hashVal);\n    if (oldVal == null) {\n      hashMap.set(hashVal,\
    \ item);\n    } else {\n      hashMap.set(hashVal, item);\n    }\n  }\n  return\
    \ Array.from(hashMap.values());\n}\n", "    const temp = new Array();\n    for\
    \ (let i = 0; i < x.length; i++) {\n        if (x[i] % 2 !== 0) {\n          \
    \  temp.push(x[i]);\n        }\n    }\n    return temp;\n}\n</code>\n<|/ a tags=sorting,javascript\
    \ |>\n<| c |>\nThis is *really* inefficient - it takes O(N^2) time to sort, and\
    \ the final result will be O(N*log(N)) time. Also, there's no guarantee that the\
    \ input array is sorted.\n<|/ c |>\n<| c |>\n- If input array is sorted then time\
    \ complexity will be `O(N)`. If input array is not sorted then time complexity\
    \ will be `O(N*log(N))`\n<|/ c |>\n<| c |>\nIt takes O(N^2) time to sort, yes,\
    \ but that's only because it's *O(n^2)*; it takes O(n^2) time to sort *because*\
    \ it's *O(n)*. There may be many more operations on the whole array than that\
    \ - but there's no guarantee that they're all done in linear time.\n<|/ c |>\n\
    <| c |>\n- Yes, I agree that time complexity of sorting is `O(n*log(N))` but here\
    \ we are sorting only even numbers and if array is sorted then complexity will\
    \ be `O(n)`. OP wants to sort even numbers in sorted order.\n<|/ c |>\n<| c |>\n\
    Yes, but OP says *it should return [1, 15, 33]* - so they want them sorted, but\
    \ in their example, they don't want the even numbers grouped together.\n<|/ c\
    \ |>\n<| a tags=sorting,javascript |>\nYou can do that with one loop:\n<code>",
  "  let unique: number[] = [];\n  \n  for(let i = 0; i < x.length; i++) {\n    let\
    \ temp: number[] = [];\n    for (let j = 0; j < x.length; j++) {\n      if (i\
    \ % 2 === 0 && j % 2 !== 0) {\n        temp.push(x[j]);\n      }\n    }\n    \n\
    \    unique = unique.concat(temp);\n  }\n  \n  return unique;\n}\n", "  const\
    \ res: number[] = [];\n  for (let i = 0; x < x; i++){\n    if (res.indexOf(x[i])\
    \ === -1){\n      res.push(x[i])\n    }\n  }\n  return res.sort();\n}\n", "\t\
    var digits: number[] = [];\n\tfor (var i = 0; i < x.length; i++) {\n\t\tvar digit:\
    \ number = Math.floor(Math.log10(x[i]));\n\t\tif (digit > 0) {\n\t\t\tdigits.push(x[i]);\n\
    \t\t}\n\t}\n\tdigits = digits.sort(function (a, b) {\n\t\treturn a - b;\n\t});\n\
    \tfor (var i = 0; i < digits.length; i++) {\n\t\tvar currentDigit: number = digits[i];\n\
    \t\tfor (var j = i + 1; j < digits.length; j++) {\n\t\t\tif (digits[j] < currentDigit)\
    \ {\n\t\t\t\tdigits[i] = currentDigit;\n\t\t\t\tdigits[j] = currentDigit;\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn digits;\n}", "\tlet result: number[]\
    \ = [];\n\tfor (let i = 0; i < x.length; i++) {\n\t\tlet count = 0;\n\t\twhile\
    \ (!checkDigit(x[i], count)) {\n\t\t\tresult.push(x[i]);\n\t\t\tcount++;\n\t\t\
    }\n\t}\n\treturn result.sort((a,b) => a-b);\n}\n", "  let n: number[] = [];\n\
    \  for (let i = x.length - 1; i >= 0; i--) {\n    for (let j = 0; j < i; j++)\
    \ {\n      if (x[j] * 10 >= x[i] * 10 && x[j] * 10 <= x[i] * 10 + 9) {\n     \
    \   let removed = x.splice(i, 1);\n        x.splice(j, 1);\n        n = n.concat(removed);\n\
    \      }\n    }\n  }\n  return x;\n}\n</code>\n<|/ a tags=javascript,sorting |>\n\
    <| c |>\nI think you misunderstood the question. The problem is not how to find\
    \ the unique digits of an array, the problem is to find which numbers in an array\
    \ have a certain digit.\n<|/ c |>\n<| a |>\n<code>\nvar numbers = [11, 155, 22,\
    \ 100, 9];\nvar digits = [1, 5, 3, 2];\nvar newNumbers = numbers.filter(n => digits.indexOf(parseInt(n))\
    \ === -1);\nconsole.log(newNumbers);</code>\n<|/ a dscore=1 tags=javascript,sorting\
    \ |>\n<| c |>\nThis doesn't answer the question. It just filters the numbers by\
    \ whether it has an even digit in its place.\n<|/ c |>\n<| c |>\nThis is correct,\
    \ the solution was to remove numbers that have an even digit in their place. I\
    \ thought that part of the question was answered, but it seems that the question\
    \ is not clearly formulated\n<|/ c |>\n<| a |>\nHere is how you can go about it.\
    \ First you loop through the numbers array and create a variable which will hold\
    \ a number. \n<code>\nlet num = 0;\n</code>\nThen you loop through each digit\
    \ of the number and check if that digit is in the digits array (you can do this\
    \ in O(N) time). If it is in the array, the number will be set to zero. If it\
    \ is not in the array, the number will be incremented and stored in the num variable.\
    \ \n<code>\nlet digits = [];\nfor (let i = 0; i < num.toString().length; i++)\
    \ {\n    if (digits.indexOf(num.toString().charAt(i)) < 0) {\n        digits.push(num.toString().charAt(i));\n\
    \    }\n}\n</code>\nThen you need to go back through the numbers array and check\
    \ to see if that number is zero. If it is not zero, the number will be removed.\
    \ \n<code>\nfor (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] !=\
    \ 0) {\n        numbers.splice(i, 1);\n    }\n}\n</code>\nHere is the complete\
    \ code:\n\n<code>", "  if (x.length === 0) {\n    return [];\n  }\n\n  const arr:\
    \ number[] = [];\n\n  for (let i = 0; i < x.length; i++) {\n    if (x.reduce((acc,\
    \ val) => acc + Number(val), 0) === 0 || x[i] % 2 === 0) arr.push(x[i]);\n  }\n\
    \  return arr.sort((a, b) => a - b);\n}\n", "    const digits = new Set();\n \
    \   for (let i = 0; i<x.length; i++){\n        while(x[i] % 2 === 0){\n      \
    \      digits.add(x[i]);\n            x[i] /= 2;\n        }\n    }\n    return\
    \ Array.from(digits);\n}\n", "  var i: number;\n  var arr: number[] = [];\n  var\
    \ len: number = x.length;\n\n  for (i = 0; i < len; i++) {\n    if (x[i] % 2 ===\
    \ 0 && arr.indexOf(x[i]) === -1) {\n      arr.push(x[i]);\n    }\n  }\n  return\
    \ arr;\n}", "    const result = [];\n    const hash = new Map<number, boolean>();\n\
    \    for (let i = 0; i < x.length; i++) {\n        const num = x[i];\n       \
    \ let flag = false;\n        if (hash.has(num)) {\n            flag = hash.get(num);\n\
    \        } else {\n            hash.set(num, true);\n        }\n        if (flag)\
    \ {\n            result.push(num);\n        }\n    }\n    return result;\n}\n",
  "    let y: number[] = [];\n    for (let i = 0; i < x.length; i++) {\n        const\
    \ temp = x[i].toString();\n        let found: boolean = false;\n        for (let\
    \ j = 0; j < y.length; j++) {\n            if (y[j] == temp && y[j] % 2 == 0)\
    \ {\n                found = true;\n                break;\n            }\n  \
    \      }\n        if (!found) {\n            y.push(parseInt(temp));\n       \
    \ }\n    }\n    return y.sort();\n}\n", "    const ret: number[] = [];\n    x.forEach(y\
    \ => {\n        if (y > 0 && y % 2 === 0) {\n            if (y % 100 === 0) {\n\
    \                ret.push(y % 10);\n                ret.push(y / 100);\n     \
    \       } else {\n                ret[ret.length - 1] += y % 10;\n           \
    \ }\n        }\n    });\n    return ret;\n}\n", "    if (x.length === 0){\n  \
    \      return [];\n    }\n    let y = [];\n    let len = x.length;\n    let temp\
    \ = 0;\n    let even = 0;\n    for (let i = 0; i < len; i++){\n        if (i %\
    \ 2 === 0){\n            even++;\n            temp = x[i];\n        }\n      \
    \  else {\n            if (temp % 2 === 0){\n                y.push(temp);\n \
    \               temp = 0;\n            }\n            else{\n                temp\
    \ = x[i];\n            }\n        }\n    }\n    if (temp % 2 === 0){\n       \
    \ y.push(temp);\n    }\n    if (even > 0){\n        y.push(temp);\n    }\n   \
    \ return y;\n}\n</code>\n<|/ a |>\n<| c |>\nNice answer, but one improvement -\
    \ you dont need `even` and `temp` as global variables. You can declare them directly\
    \ as `let` variables.\n<|/ c |>\n<| a dscore=1 tags=algorithm,arrays,javascript,typescript\
    \ |>\nFor those who are looking for more performance improvements than above,\
    \ here is the approach I used:\n\n<code>", "    const len = x.length\n    const\
    \ result: number[] = []\n    let i: number\n    let j: number\n    let p: number\n\
    \    for (i = 0, j = 0; i < len; i++, j = 0) {\n        p = x[i]\n        while\
    \ (p % 2 === 0) {\n            result.push(j)\n            j += 1\n          \
    \  p /= 10\n        }\n    }\n    return result.sort((a: number, b: number) =>\
    \ {\n        return x[a] - x[b]\n    })\n}\n", "    let res = [];\n    let len\
    \ = x.length;\n    for (let i = 0; i < len; i++) {\n        if (x[i] % 2 === 0)\
    \ {\n            res.push(x[i]);\n        }\n    }\n    return res;\n}", "   \
    \ const map = new Map();\n    const arr = []\n    for (let i = 0; i < x.length;\
    \ i++) {\n        const val = map.get(x[i]);\n        if (val === undefined) {\n\
    \            arr.push(x[i]);\n            map.set(x[i], i);\n        }\n    }\n\
    \    return arr.sort((a, b) => a - b)\n}\n", "    const result: number[] = [];\n\
    \    for (let i = 0; i < x.length; i++) {\n        const d = x[i];\n        if\
    \ (d % 2 === 0) {\n            continue;\n        }\n        for (let j = 0; j\
    \ < result.length; j++) {\n            if (result[j] === d) {\n              \
    \  result.splice(j, 1);\n                break;\n            }\n        }\n  \
    \      result.push(d);\n    }\n    return result;\n}\n", "    return x.filter(x\
    \ => x.toString().length % 2 === 0)\n}\n", "    let counter = {};\n    let result\
    \ = [];\n    for (let i = 0; i < x.length; i++) {\n        let el = x[i];\n  \
    \      if (el in counter) {\n            counter[el]++;\n        }\n        else\
    \ {\n            counter[el] = 1;\n        }\n    }\n    for (let el in counter)\
    \ {\n        if (counter[el] > 1) {\n            result.push(el);\n        }\n\
    \    }\n    return result;\n}\n", "  if (x.length < 1) return [];\n  let res:\
    \ number[] = [];\n  for (let i = 0; i < x.length; i++) {\n    let tmp: number[]\
    \ = [];\n    for (let j = 0; j < x.length; j++) {\n      if (x[j] % 2 === 0) tmp.push(x[j]);\n\
    \    }\n    tmp.sort(function (a, b) { return a - b; });\n    res = res.concat(tmp);\n\
    \  }\n  return res;\n}\n", "  for (let i = 0; i < x.length; i++) {\n    const\
    \ element = x[i];\n    const arr = [element];\n    while (element % 2 === 0) {\n\
    \      element = element / 2;\n      arr.push(element);\n    }\n    arr.sort();\n\
    \  }\n  return x;\n}\n", "    let ans = [];\n    let map = new Map<number, number>();\n\
    \    for (let i of x) {\n        // If i is even digit, push to the map\n    \
    \    if (i % 2 === 0) map.set(i, i);\n        // Else, check if i is in the map,\
    \ if it is in the map then push to ans.\n        else if (!map.has(i))\n     \
    \       ans.push(i);\n    }\n    return ans;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting,javascript,typescript\
    \ |>\n<| c |>\n\"Given an array of positive integers x. return a sorted array\
    \ of all elements that hasn't any even digit.\" should also work with negative\
    \ integers.\n<|/ c |>\n<| c |>\nIt is a bit unclear how negative numbers are handled,\
    \ but the solution is pretty simple: just check for `<0` when checking whether\
    \ `i` is even.\n<|/ c |>\n<| c |>\nYes, I realised that after I answered, but\
    \ then the question changed and the comment about negative numbers didn't make\
    \ much sense. I'll just leave the answer here in case anyone else needs it.\n\
    <|/ c |>\n<| c |>\nThis is a great answer that uses the Map data structure which\
    \ I didn't know existed. It works great for positive integers, but can you explain\
    \ the code? It looks pretty advanced but I can understand it well enough to just\
    \ copy and paste into VS code.\n<|/ c |>\n<| a tags=arrays,algorithm,sorting,javascript,typescript\
    \ |>\nHere is an iterative solution. It will sort the array in-place and then\
    \ remove all instances of even numbers, leaving only numbers that do not contain\
    \ even digits (i.e. the numbers you want to remove)\n<code>", "    const result:\
    \ number[] = [];\n    let i = 0;\n    for (const item of x) {\n        if (item.toString().length\
    \ === 2) {\n            result.push(item);\n        } else {\n            if (result[i]\
    \ !== undefined) {\n                if (result[i].toString().length === 2) {\n\
    \                    result.splice(i, 1);\n                }\n            } else\
    \ {\n                result.push(item);\n            }\n        }\n        i +=\
    \ 1;\n    }\n    return result;\n}\n", "\tlet result: number[] = [];\n\tlet digits:\
    \ Set<number> = new Set();\n\tfor (let element of x){\n\t\tif (isEven(element)){\n\
    \t\t\tdigits.add(element);\n\t\t}\n\t}\n\tfor (let element of digits){\n\t\tresult.push(element);\n\
    \t}\n\treturn result.sort((a,b) => a - b);\n}", "  var unique = new Set<number>()\n\
    \  \n  x.forEach(y => {\n    if (y % 2 === 0) {\n      return\n    } else {\n\
    \      var index = unique.has(y)? unique.indexOf(y) : unique.add(y)\n      unique.splice(index,\
    \ 1)\n    }\n  })\n  \n  return unique.sort((a,b) => {\n    return a - b\n  })\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you so much for the help! I tested\
    \ it out and found that the solution works for the test case that had no duplicates,\
    \ but the solution fails for test case that have duplicates in them. \n \nHere\
    \ is the test case that I've got with the duplicates:\n`const testArray = [1,\
    \ 2, 3, 10, 100, 10, 2, 20]`\n\nThe above solution that you've provided returns\
    \ [1,2,10,100] whereas I was expecting [1,2,10,100,2,20]\n<|/ c |>\n<| c |>\n\
    Ah, I see. I updated my answer. I think the code I wrote was actually not what\
    \ you needed.\n<|/ c |>\n<| a |>\n<code>", "  let arr = [...x];\n  arr.sort((a,\
    \ b) => {\n    return a - b;\n  });\n  let set = new Set();\n  for (let num of\
    \ arr) {\n    if (set.has(num)) {\n      return [];\n    }\n    set.add(num);\n\
    \  }\n  return arr;\n}\n", "    let hash = new Map();\n    for (let i: number\
    \ = 0; i < x.length; ++i) {\n        if (x[i] < 10) {\n            hash.set(x[i],\
    \ i);\n        }\n    }\n\n    let result = [];\n    for (let key: number in hash)\
    \ {\n        let index = hash.get(key);\n        result.push(key % 10);\n    \
    \    result.push(index);\n    }\n\n    return result.sort((a, b) => a - b);\n\
    }\n", "  let result = [];\n  for (let i = 0; i < x.length; ++i) {\n    let num\
    \ = \"\";\n    for (let j = 0; j < x[i]; ++j) {\n      num = num + x[j];\n   \
    \ }\n    if (num.length % 2 === 0) result.push(num);\n  }\n  return result.sort();\n\
    }\n", "    var result: number[] = [];\n    for (var item of x) {\n        if (item\
    \ % 2 != 0) result.push(item);\n    }\n    result.sort((a, b) => {\n        return\
    \ a - b;\n    });\n    return result;\n}\n", "    let result = []\n    x.forEach((item)\
    \ => {\n        let flag = false\n        result.forEach(x => {\n            if\
    \ (x % 2 === 0 && x % item === 0) {\n                flag = true\n           \
    \ }\n        })\n        if (!flag) {\n            result.push(item)\n       \
    \ }\n    })\n    result.sort()\n    return result\n}\n", "    for (let i = 0;\
    \ i < x.length; i++) {\n        let flag = false;\n        for (let j = i + 1;\
    \ j < x.length; j++) {\n            if (x[i] % x[j] === 0) {\n               \
    \ flag = true;\n                break;\n            }\n        }\n        if (flag)\
    \ {\n            x.splice(i, 1);\n        }\n    }\n    return x;\n}\n", "  for\
    \ (let i of x){\n    let index = x.indexOf(i)\n    if (index > 0){\n      if (x[index\
    \ - 1] % 2 === 0){\n        x.splice(index, 1)\n      }\n    }\n  }\n  return\
    \ x;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=sorting,arrays,javascript\
    \ |>\nMy answer will use some loops, but the code is fairly clean:\n\n<code>\n\
    const array = [22, 44, 13, 17, 31, 56, 65, 78, 2, 43, 6];\n\nconst unique = array.reduce((acc,\
    \ n) => {\n  const digit = n % 10;\n  acc[digit] = acc[digit] || [];\n  acc[digit].push(n);\n\
    \  return acc;\n}, {});\n\nconst sorted = [];\n\nObject.keys(unique).forEach(k\
    \ => {\n  unique[k].sort((a, b) => {\n    if (a < b) return 1;\n    if (a > b)\
    \ return -1;\n    return 0;\n  });\n  sorted.push(...unique[k]);\n});\n\nconsole.log(sorted);</code>\n\
    <|/ a |>\n<| c |>\nHi David. Great solution. Is there a way to modify the code\
    \ to sort in descending order? Like if the array is [4, 23, 12, 17, 33] the code\
    \ returns [17, 33, 4, 23] instead of [23, 4, 17, 33]\n<|/ c |>\n<| c |>\nSure,\
    \ just change the `return 1` to `return -1`\n<|/ c |>\n<| a tags=sorting,arrays,javascript\
    \ |>\nYou can sort the array and map its items with indexOf and filter out the\
    \ duplicates\n\n<code>\nlet array = [22, 44, 13, 17, 31, 56, 65, 78, 2, 43, 6];\n\
    let result = array\n    .map((i, idx) => ({ idx, num: i }))\n    .sort((a, b)\
    \ => b.num - a.num)\n    .filter((a, b) => array.indexOf(a) === b);\n\nconsole.log(result);</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    const nums = new Map<number,\
    \ number>();\n    for (let i = 0; i < x.length; i++){\n        if (!nums.has(x[i])){\n\
    \            nums.set(x[i], 0);\n        }\n        nums.set(x[i], nums.get(x[i])\
    \ + 1);\n    }\n    const arr = [];\n    for (const [key, value] of nums){\n \
    \       if (value % 2 == 0){\n            arr.push(key);\n        }\n    }\n \
    \   arr.sort((a, b) => a - b);\n    return arr;\n}\n", "    const counter = new\
    \ Map<number, number>();\n    for (const el of x) {\n        const str = String(el);\n\
    \        if (counter.get(str) !== undefined) {\n            counter.delete(el);\n\
    \        } else {\n            counter.set(str, el);\n        }\n    }\n    return\
    \ [...counter.values()];\n}\n", "\tconst arr: number[] = [];\n\tlet index = 0;\n\
    \tfor (let i = 0; i < x.length; i++) {\n\t\tconst last = x[i];\n\t\tconst lastDigit\
    \ = last % 10;\n\t\tif (lastDigit > 5) {\n\t\t\tarr.push(last);\n\t\t\tx[i] =\
    \ last / 10;\n\t\t}\n\t}\n\treturn arr.sort((a: number, b: number) => a - b);\n\
    }\n", "    const result = [];\n    for(let i = 0; i < x.length; ++i) {\n     \
    \   if(x[i] % 2 === 0) result.push(x[i]);\n    }\n    return result;\n}\n", " \
    \ let arr:number[] = [];\n  for (let i = 0; i < x.length; i++) {\n    let temp\
    \ = x[i];\n    let isEven: boolean = true;\n    while (temp > 0) {\n      isEven\
    \ = isEven && (temp & 1) == 0;\n      temp >>= 1;\n    }\n    if (isEven) {\n\
    \      arr.push(x[i]);\n    }\n  }\n  return arr;\n}\n", "    let evenDigit =\
    \ x.filter(i => i % 2 === 0);\n    return evenDigit.sort((a, b) => a - b);\n}\n",
  "    let result: number[] = [];\n    for (let i: number = 0; i < x.length; i++)\
    \ {\n        if (x[i] % 2 !== 0) {\n            result.push(x[i]);\n        }\n\
    \    }\n    result.sort((a: number, b: number) => a - b);\n    return result;\n\
    }\n", "  let n: number = 0;\n  let res: number[] = [];\n  \n  for (let i = 0;\
    \ i < x.length; i++) {\n    if (i % 2 !== 0) {\n      res[n++] = x[i];\n    }\n\
    \  }\n\n  return res.sort((a, b) => a - b);\n}\n", "  const arr = [];\n  let counter\
    \ = 0;\n  const n = x.length;\n  for (let i = 0; i < n; i++) {\n    if (x[i] %\
    \ 2 == 0) {\n      continue;\n    }\n    arr[counter] = x[i];\n    counter +=\
    \ 1;\n  }\n  return arr;\n}\n", "  const result: number[] = [];\n  \n  // We use\
    \ Map instead of object to make sure duplicate element are not included.\n  x.map((num:\
    \ number) => {\n    const isEven: boolean = num % 2 === 0;\n    if (isEven) {\n\
    \      result.push(num);\n    }\n  });\n  \n  return result.sort((a: number, b:\
    \ number) => {\n    return a - b;\n  });\n}\n", "  \n}", "  return [...new Set(x)].sort();\n\
    }\n", "    return x.filter(function (num) {\n        return num.toString().length\
    \ === num && parseInt(num.toString()) % 2 === 0;\n    });\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is incorrect as it returns only the first occurrence of duplicates.\
    \ E.g. `[1, 1, 2]` returns `[1, 2]`. Should be `[1, 2]`.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "    var ans = [];\n    var last = 0;\n    for (var i of x) {\n\
    \        while (last < i && i % 10 === 0) {\n            last++;\n        }\n\
    \        if (last > i) ans.push(last);\n        last = i;\n    }\n    return ans;\n\
    }\n", "\tconst result: number[] = [];\n\tlet i = x.length;\n\tlet cnt = 0;\n\t\
    while (i > 0) {\n\t\tresult[cnt] = x[--i];\n\t\tif (x[i] % 2 === 0) {\n\t\t\t\
    cnt++;\n\t\t}\n\t}\n\treturn result.sort();\n}\n", "  for (let i = 0; i < x.length;\
    \ i++){\n    for (let j = i + 1; j < x.length; j++){\n      if (x[j] % 2 === 0\
    \ && x[j] % 10 != 0 ) {\n        x[i] = x[i];\n        x.splice(j--, 1);\n   \
    \   }\n    }\n  }\n  return x;\n}\n", "  const ret = new Array<number>();\n  for\
    \ (let i = 0, l = x.length; i < l; i++) {\n    let temp = parseInt(x[i]);\n  \
    \  for (let j = i + 1; j < l; j++) {\n      if (temp %  10 == 0) {\n        ret.push(temp);\n\
    \      }\n    }\n  }\n  return ret;\n}\n", "    const digits: number[] = [];\n\
    \    let counts: number[] = [];\n    for (let i = 0; i < x.length; i++) {\n  \
    \      const digit = x[i] - 0;\n        if (digits.indexOf(digit) < 0) {\n   \
    \         digits.push(digit);\n        }\n        const count = counts[digit];\n\
    \        counts[digit] = count + 1;\n    }\n    const result = [];\n    for (let\
    \ i = 0; i < digits.length; i++) {\n        const count = counts[digits[i]];\n\
    \        if (count === 0) {\n            result.push(digits[i]);\n        }\n\
    \    }\n    return result;\n}\n", "    const nums: number[] = [];\n    const evens:\
    \ number[] = [];\n    x.forEach((num: number) => {\n        const lastEvenIndex\
    \ = nums.findIndex((num: number) => num % 2 === 0);\n        const evenIndex =\
    \ nums.findIndex((num: number) => num % 2 === 1);\n        if (lastEvenIndex ===\
    \ -1 && evenIndex === -1) {\n            nums.push(num);\n        } else if (lastEvenIndex\
    \ === -1) {\n            evens.push(num);\n        } else if (evenIndex === -1)\
    \ {\n            evens.push(num);\n        } else {\n            const temp =\
    \ nums[lastEvenIndex];\n            nums[lastEvenIndex] = nums[evenIndex];\n \
    \           nums[evenIndex] = temp;\n        }\n    });\n    return nums;\n}\n",
  "  // your code here\n  let ans = [];\n  let seen = {};\n  \n  for (let i = 0; i\
    \ < x.length; i++) {\n    let r = x[i] % 10;\n    if (!seen[r]) {\n      seen[r]\
    \ = true;\n      ans.push(r);\n    }\n  }\n\n  return ans.sort((a, b) => a - b);\n\
    }\n", "\tlet r = []\n\tfor (let i = 0; i < x.length; i++) {\n\t\tlet s = x[i]\n\
    \t\tfor (let j = i + 1; j < x.length; j++) {\n\t\t\tif (s % 2 === 0) {\n\t\t\t\
    \tbreak\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr[r.length] = x[j]\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn r\n}", "    const result = [];\n    for (const item of x) {\n    \
    \    let found = false;\n        for (let i = 0; i < result.length; i++) {\n \
    \           if (item % 10 == result[i]%10) {\n                found = true;\n\
    \                break;\n            }\n        }\n        if (!found) {\n   \
    \         result.push(item);\n        }\n    }\n    return result;\n}\n", "  for\
    \ (var i = 0; i < x.length; i++) {\n    if (parseInt(x[i]) % 2 === 0) continue;\n\
    \    if (i > 0) {\n      if (x[i] !== x[i - 1]) {\n        return x.slice(i);\n\
    \      }\n    } else {\n      return x.slice(i);\n    }\n  }\n}\n", "\tif (x.length\
    \ === 0) {\n\t\treturn [];\n\t}\n\n\tconst result = new Array<number>();\n\n\t\
    let n = x[0];\n\twhile (n > 0 && !result.includes(n)) {\n\t\tresult.push(n);\n\
    \t\tn = Math.floor(x / 10) * 10;\n\t}\n\n\treturn result;\n}\n", "    let even\
    \ = [];\n    x.forEach(ele => {\n      if (ele % 2 === 0) {\n        even.push(ele);\n\
    \      }\n    });\n    return even.sort();\n  }\n", "    const newArr: number[]\
    \ = [];\n    for (let i = 0; i < x.length; i++) {\n        if (x[i] % 2 != 0)\
    \ {\n            newArr.push(x[i]);\n        }\n    }\n    console.log(newArr);\n\
    \    return newArr;\n}\n", "  var temp: number[] = [];\n  for (var i = 0; i <\
    \ x.length; i++) {\n    if (i % 2 === 0) {\n      temp.push(x[i]);\n    }\n  }\n\
    \  temp.sort();\n  return temp;\n}\n", "\tif (x.length === 0) { return []; }\n\
    \n\tlet seen = new Set<number>();\n\tlet ret = [];\n\tfor (let i = 0; i < x.length;\
    \ i++) {\n\t\tif (x[i] % 2 !== 0) {\n\t\t\tlet digit = x[i];\n\t\t\twhile (digit.toString().length\
    \ !== 0) {\n\t\t\t\tif (!seen.has(digit)) {\n\t\t\t\t\tret.push(digit);\n\t\t\t\
    \t\tseen.add(digit);\n\t\t\t\t}\n\t\t\t\tdigit = (digit / 10);\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn ret;\n}\n", "    let result = [];\n    for(let i = 0; i < x.length;\
    \ i++){\n        if(i % 2 != 0){\n            result.push(x[i]);\n        }\n\
    \    }\n    return result;\n}\n", "  let ret = [];\n  let i = 0;\n  let j = 0;\n\
    \  let cnt = 0;\n\n  while (i<x.length) {\n    while (j<ret.length && ret[j]*10\
    \ + x[i] > x[j]*10) {\n      j++;\n    }\n    ret.push(x[j]);\n    j++;\n    if\
    \ (x[i] > 10000) {\n      cnt++;\n    }\n    i++;\n  }\n  return ret.filter((e,\
    \ i, arr) => {\n    return arr.indexOf(e) === i;\n  });\n}\n", "\tlet counter:\
    \ number[] = [];\n\tfor (let i = 0; i < x.length; i++) {\n\t\tlet flag = false;\n\
    \t\tfor (let j = 0; j < counter.length; j++) {\n\t\t\tif (x[i] == counter[j])\
    \ {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) {\n\t\
    \t\tcounter.push(x[i]);\n\t\t}\n\t}\n\tcounter.sort();\n\treturn counter;\n}\n",
  "\tlet result = [];\n\tlet even = [];\n\tlet odd = [];\n\tfor (let i = 0; i < x.length;\
    \ i++) {\n\t\tresult.push(x[i]);\n\t\tif(x[i] % 2 === 0) {\n\t\t\teven.push(x[i]);\n\
    \t\t} else {\n\t\t\todd.push(x[i]);\n\t\t}\n\t}\n\tfor (let i = 0; i < x.length;\
    \ i++) {\n\t\tif(result.indexOf(x[i]) == -1) {\n\t\t\tresult.push(x[i]);\n\t\t\
    }\n\t}\n\t\n\tfor (let i = 0; i < even.length; i++) {\n\t\tif(result.indexOf(even[i])\
    \ == -1) {\n\t\t\tresult.push(even[i]);\n\t\t}\n\t}\n\tfor (let i = 0; i < odd.length;\
    \ i++) {\n\t\tif(result.indexOf(odd[i]) == -1) {\n\t\t\tresult.push(odd[i]);\n\
    \t\t}\n\t}\n\n\treturn result;\n}\n", "\tvar ans = [];\n\tx.forEach(\n\t\tfunction(val){\n\
    \t\t\tvar digits = String(val).split(\"\");\n\t\t\tdigits = digits.map(function(d)\
    \ { return parseInt(d); });\n\t\t\tdigits = digits.filter(function(d) { return\
    \ d % 2 === 0; });\n\t\t\tif(digits.length === 0){\n\t\t\t\tans.push(val);\n\t\
    \t\t}\n\t\t}\n\t);\n\tans = ans.sort(function(a, b) { return a - b; });\n\treturn\
    \ ans;\n}\n", "    var result = new Array<number>();\n    for (const n of x) {\n\
    \        if (n % 2 === 0) {\n            result.push(n);\n        }\n    }\n \
    \   result.sort();\n    return result;\n}", "\tconst map = new Map();\n\tx.forEach(d\
    \ => {\n\t\tconst num = map.get(d);\n\t\tif (num) {\n\t\t\tmap.set(d, ++num);\n\
    \t\t} else {\n\t\t\tmap.set(d, 1);\n\t\t}\n\t});\n\n\tconst res = Array.from(map.values());\n\
    \n\treturn res.sort((a, b) => a - b);\n}\n", "    const result = [];\n    for\
    \ (let i = 0; i < x.length; i++) {\n        let tmp = 0;\n        for (let j =\
    \ 0; j < x.length; j++) {\n            if (i != j && x[i] % 10 == x[j] % 10) {\n\
    \                tmp++;\n            }\n        }\n        if (tmp === 0) {\n\
    \            result.push(x[i]);\n        }\n    }\n    return result;\n}\n", " \
    \   var y: number[] = []\n    var xs: number[] = []\n    for (var i = 0; i < x.length;\
    \ i++) {\n        if (x[i] % 2 === 0){\n            y.push(x[i])\n        }\n\
    \    }\n    for (var k = 0; k < y.length; k++){\n        for(var i =0; i< y.length;\
    \ i++){\n            if(y[i] === y[k]){\n                y.splice(k, 1)\n    \
    \        }\n        }\n    }\n    return y\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThis is not my question, I want the solution for my question :) thanks\n\
    <|/ c |>\n<| c |>\nI dont know how i missed that. my bad. Anyway, the solution\
    \ i provided is the most optimal solution for your question. Since you are just\
    \ looking for the best performing algorithm, i think this might be what you are\
    \ looking for.\n<|/ c |>\n<| c |>\nThanks ! but I am looking for more optimize\
    \ algorithm than mine :P\n<|/ c |>\n<| c |>\nYou can go through it step by step\
    \ and find the optimal algorithm. It'd be interesting to see how fast your solution\
    \ actually is.\n<|/ c |>\n<| a dscore=0 |>\nHere's an approach using binary search\
    \ to find the median and to reduce the array from length to half until there are\
    \ two or less elements to iterate.  Note that this is only an algorithm to find\
    \ the median.  To find the elements greater than or less than the median, just\
    \ reverse the array and repeat the process.\n<code>", "    let uniqueArr = [...new\
    \ Set(x)];\n    return uniqueArr.sort((a, b) => a - b);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is much better than the accepted answer. Straight up javascript\
    \ is more performant than any other method I'm aware of (python, ruby, C#, etc)\n\
    <|/ c |>\n<| c |>\nThis doesn't work in C#, at least in 4.5.2. You get an error:\
    \ `System.TypeLoadException: Method 'Array.Exists' has type parameters that cannot\
    \ be inferred from usage`\n<|/ c |>\n<| c |>\nYes, this solution does work in\
    \ C# 4.5.2. However, you must be running it in an older version of C#. Check this\
    \ out: https://stackoverflow.com/questions/34845346/how-can-i-use-array-exists-in-c-sharp\n\
    <|/ c |>\n<| a dscore=2 |>\nI know this question is old but maybe it will help\
    \ someone someday.\nIn JavaScript we can do the same thing by using a while loop.\n\
    <code>", "  const result = [];\n  let seen: number[] = [];\n\n  for (let i = 0;\
    \ i < x.length; i++) {\n    let digit = x[i];\n    if (seen.indexOf(digit) ==\
    \ -1) {\n      seen.push(digit);\n      result.push(digit);\n    }\n  }\n  return\
    \ result;\n}\n", "    const output: number[] = [];\n    for (let i = 0; i < x.length;\
    \ i++) {\n        // check if number is even\n        if (i % 2 === 0) {\n   \
    \         output.push(x[i]);\n        }\n    }\n    output.sort();\n    return\
    \ output;\n}\n", "    const result: number[] = [];\n    let lastElement: number\
    \ = Number.MIN_SAFE_INTEGER;\n\n    for (let i = 0; i < x.length; i++) {\n   \
    \     if (x[i] % 2 === 0) {\n            result.push(x[i]);\n            lastElement\
    \ = x[i];\n        }\n        else {\n            let temp: number = lastElement\
    \ % 10 + Math.floor(x[i] / 10);\n            if (lastElement % 10 === 0 && lastElement\
    \ !== temp) {\n                result.push(temp);\n            }\n           \
    \ lastElement = temp;\n        }\n    }\n\n    return result;\n}\n", "  let hashSet\
    \ = new Set<number>();\n  let sortedArray = x.filter((el) => !hashSet.has(el));\n\
    \  hashSet.add(x.reduce((a, b) => a * 10 + b));\n  return sortedArray;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=arrays,sorting,javascript |>\nUsing a Map and a Set\
    \ makes this problem relatively simple, although there are a number of ways to\
    \ optimize this solution (such as using an external library like lodash).\nThe\
    \ following function takes an array of integers and returns the smallest number\
    \ not in the array (or the minimum value if not all numbers are even). Since Map\
    \ is a key/value pair object it will also sort your array in ascending order.\n\
    <code>", "    let nums: number[] = [];\n    for (let i = 0; i < x.length; i++)\
    \ {\n        for (let j = 0; j < x.length; j++) {\n            if (i != j) {\n\
    \                if (x[i] % x[j] == 0) {\n                    nums.push(x[i]);\n\
    \                }\n            }\n        }\n    }\n    return nums;\n}\n", " \
    \   const result = [];\n    for (let i = 0; i < x.length; i++) {\n        const\
    \ n = x[i];\n        for (let j = 0; j < i; j++) {\n            if (n % 10 ===\
    \ 0 && n / 10 >= 5) {\n                break;\n            }\n        }\n    \
    \    if (j <= i) {\n            result.push(n);\n        }\n    }\n    return\
    \ result;\n}\n", "    let result = [];\n    for (let i = 0; i < x.length; i++)\
    \ {\n        let tmp = [];\n        for (let j = 0; j < x.length; j++) {\n   \
    \         if (x[j] % 10 == 0) {\n                tmp.push(x[j]);\n           \
    \ }\n        }\n        result.push(...tmp);\n    }\n    return result;\n}\n",
  "    var result = [];\n    var arr = [];\n    for (var i = 0, len = x.length; i\
    \ < len; i++) {\n        var item = x[i];\n        if (item < 10) {\n        \
    \    arr.push(item);\n        } else {\n            if (arr.indexOf(item % 10)\
    \ !== -1) {\n                continue;\n            } else {\n               \
    \ result.push(arr);\n            }\n            arr = [];\n        }\n    }\n\
    \    return result.length === 0 ? [] : result;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=arrays,javascript |>\n<code>\nvar arr = [1,3,5,3,5,6,4,6,7,8,8,8,4,8,9,8,7,8,8,5,8,5,5,9,1,9,8,7,7,8,8,9,9,8,6,7,8,9,8,7,8,7,9,5,7,8,8,6,8,8,5,5,8,7,8,9,9,8,8,8,8,8,7,8,9,8,8,8,8,9,7,7,8,8,7,8,9,8,7,8,7,8,8,8,5,7,8,9,8,7,8,8,9,9,8,6,7,8,8,8,8,8,8,8,9,8,7,8,8,8,8,8,8,8,8,8,8,8,8,8,9,8,7,8,8,8,7,8,8,7,8,8,9,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,8,7,8,8,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,",
  "    const output: number[] = [];\n    for (let i = 0; i < x.length; i++) {\n  \
    \      const index = x.findIndex(item => item % 2 === 0);\n        if (index !==\
    \ -1) {\n            const itemToRemove = x[index];\n            output.push(itemToRemove);\n\
    \            x.splice(index, 1);\n        }\n    }\n    return output;\n}\n",
  "    let evenDigitsNum: number[] = [];\n    for(let i = 0; i < x.length; i++) {\n\
    \        let num = x[i];\n        for(let j = 0; j < num.length; j++) {\n    \
    \        if(parseInt(num[j].toString()) % 2 === 0) {\n                evenDigitsNum.push(parseInt(num[j].toString()));\n\
    \            }\n        }\n    }\n    evenDigitsNum.sort(function(a: number, b:\
    \ number) {\n        return a - b;\n    });\n    let finalArray: number[] = [];\n\
    \    for(let i = 0; i < x.length; i++) {\n        if(!evenDigitsNum.includes(x[i]))\
    \ {\n            finalArray.push(x[i]);\n        }\n    }\n    return finalArray;\n\
    }\n", "    let digits: number[] = [];\n    x.forEach((x) => { digits.push(x /\
    \ 10); });\n    digits = digits.filter((d) => { return a < 10; });\n    digits\
    \ = digits;\n    let result: number[] = [];\n    digits.forEach((x) => {\n   \
    \     if ((x.toString().match(/[02468]/g)) == null) {\n            result.push(x);\n\
    \        }\n    });\n    return result.sort((a, b) => a - b);\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=arrays,javascript,typescript |>\n<code>", "  if (x.length\
    \ === 0)\n    return x;\n  if (x[0] >= 10)\n    return [];\n  let res: number[]\
    \ = [];\n  res.push(x[0]);\n  let i = 1;\n  for (let j = 1; j < x.length; j++)\
    \ {\n    if (x[j] % i === 0) {\n      res.push(x[j]);\n    } else {\n      i++;\n\
    \    }\n  }\n  return res;\n}\n", "    const result: number[] = [];\n    const\
    \ map = new Map<number, boolean>();\n    for (let i = 0; i < x.length; i++) {\n\
    \        let digit = x[i];\n        let isEven = map.get(digit);\n        if (isEven)\
    \ {\n            continue;\n        }\n        map.set(digit, true);\n       \
    \ result.push(digit);\n    }\n    return result;\n}\n</code>\n<|/ a tags=data-structures,algorithm,arrays,sorting\
    \ |>\n<| a tags=data-structures,algorithm,arrays,sorting |>\nThis problem can\
    \ be solved using hash table and two stacks.\n\nTraverse the given array and maintain\
    \ the hash of elements with even digits.\nWhile traversing add the element to\
    \ Hash table with even digits and push the element on top of the stack.\nWhile\
    \ traversing add the element to the stack with odd digits.\nIf the current element\
    \ has even digits, print that element, else pop the element from the stack and\
    \ print that element.\n\nTime Complexity: O(n).\nExplanation:\nTime complexity\
    \ is O(n) because we traverse the array only once to create hash map and push\
    \ and pop from the stacks only.\n<code>\nimport java.util.*;\nimport java.lang.*;\n\
    import java.io.*;", "  const result: number[] = [];\n  \n  for (let i: number\
    \ = 0; i < x.length; i += 1) {\n    if (is_even(x[i])) {\n      result.push(x[i]);\n\
    \    }\n  }\n  \n  return result.sort();\n}\n", "    let result = []\n    let\
    \ resultSet = new Set();\n    \n    for (let item of x) {\n        if (item >\
    \ 9 && !resultSet.has(item)) {\n            resultSet.add(item)\n            result.push(item)\n\
    \        }\n    }\n    \n    return result\n}\n</code>\n<|/ a |>\n<| c |>\nNice\
    \ one! I didn't think of using `Set` to keep track of what items you've seen before.\
    \ Nice solution!\n<|/ c |>\n<| c |>\nthanks! I appreciate your attention to my\
    \ question too.\n<|/ c |>\n<| a |>\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\npublic\
    \ class Solution {\n    \n    public static void main(String[] args) {\n     \
    \   List<Integer> input1 = new ArrayList<>();\n        input1.add(15);\n     \
    \   input1.add(10);\n        input1.add(15);\n        List<Integer> input2 = new\
    \ ArrayList<>();\n        input2.add(1);\n        input2.add(2);\n        input2.add(3);\n\
    \        input2.add(3);\n        input2.add(3);\n        input2.add(10);\n   \
    \     List<Integer> input3 = new ArrayList<>();\n        input3.add(15);\n   \
    \     input3.add(3);\n        input3.add(2);\n        input3.add(2);\n       \
    \ input3.add(2);\n        input3.add(2);\n        input3.add(10);\n        input3.add(10);\n\
    \        \n        List<Integer> solution = solve(input1, input2, input3);\n \
    \       \n        if(solution != null){\n            System.out.println(solution);\n\
    \        }\n    }\n    \n    public static List<Integer> solve(List<Integer> input1,\
    \ List<Integer> input2, List<Integer> input3) {\n        List<Integer> res = new\
    \ ArrayList<>();\n        Set<Integer> set = new Set<>();\n        for(int i =\
    \ 0; i<input1.size();i++){\n            if(set.contains(input1.get(i))){\n   \
    \             continue;\n            }\n            set.add(input1.get(i));\n\
    \            int num = 0;\n            while(num<input1.get(i)){\n           \
    \     int temp = input1.get(i)%10;\n                num+=temp;\n            }\n\
    \            if(set.contains(num)){\n                continue;\n            }\n\
    \            set.add(num);\n            res.add(input2.get(input2.size()));\n\
    \        }\n        for(int i = 0; i<input3.size();i++){\n            if(set.contains(input3.get(i))){\n\
    \                continue;\n            }\n            set.add(input3.get(i));\n\
    \            int num = 0;\n            while(num<input3.get(i)){\n           \
    \     int temp = input3.get(i)%10;\n                num+=temp;\n            }\n\
    \            if(set.contains(num", "    let arr: number[] = [];\n    for (let\
    \ i: number = 0; i < x.length; i++) {\n        let y: number = Math.abs(x[i]);\n\
    \        let j: number = 0;\n        while (y > 0) {\n            arr.push(x[i]);\n\
    \            y--;\n        }\n    }\n    return arr;\n}\n", "    const result\
    \ = [];\n    let digits = [];\n    for (const n of x) {\n        const digit =\
    \ Math.floor(n / 10);\n        if (digits[digit]) {\n            continue;\n \
    \       }\n        digits[digit] = true;\n        result.push(n);\n    }\n   \
    \ return result;\n}\n", "    const unique: number[] = []\n    const len: number\
    \ = x.length\n    for (let i: number = 0; i < len; i++) {\n        let found:\
    \ boolean = false \n        for (let j: number = 0; j < i; j++) { \n         \
    \   let digit: number = x[j % len] % 10\n            if (digit == 0) found = true\n\
    \            if (digit == 1 && found) {\n                unique.push(x[j])\n \
    \               found = false\n                break\n            }\n        }\n\
    \    }\n    return unique\n}\n", "  return x.filter(e => e % 2 === 0).sort((a,b)=>a-b)\n\
    }\n", "  let result: number[] = [];\n  let sortedArr: number[] = [];\n  \n  for\
    \ (let i = 0; i < x.length; i++) {\n    sortedArr = x.slice();\n    sortedArr.sort((a:\
    \ number, b: number) => a - b);\n    \n    let found: boolean = false;\n    for\
    \ (let j = 0; j < sortedArr.length; j++) {\n      if (sortedArr[j] % 2 !== 0)\
    \ {\n        found = true;\n        break;\n      }\n    }\n    \n    if (!found)\
    \ {\n      result.push(x[i]);\n    }\n  }\n  \n  return result.sort((a: number,\
    \ b: number) => a - b);\n}\n", "    const digits = new Set<number>();\n    let\
    \ result: number[] = [];\n    x.forEach((n) => {\n        const digit = n % 10;\n\
    \        if (digit === 0) return;\n        if (digits.has(digit)) {\n        \
    \    digits.add(digit);\n            result.push(n);\n            return;\n  \
    \      }\n        digits.add(digit);\n    });\n    return result;\n}\n", "\tlet\
    \ res: number[] = [];\n\tfor (let i = 0; i < x.length; i++) {\n\t\tlet isEven:\
    \ boolean;\n\t\tlet digit: number = x[i];\n\t\tif (i % 2 == 0) {\n\t\t\tisEven\
    \ = false;\n\t\t} else {\n\t\t\tisEven = true;\n\t\t}\n\t\tfor (let j = 0; j <\
    \ res.length; j++) {\n\t\t\tif (res[j] > digit) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\
    \t\tif (isEven) {\n\t\t\t\tif (res[j] != digit) {\n\t\t\t\t\tres.push(digit);\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res[j] == digit) {\n\t\
    \t\t\t\tres.push(digit);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\
    return res;\n}\n", "  var result = [];\n  var hash = new Set<number>();\n  var\
    \ n = 0;\n  for(var i = 0; i < x.length; i++)\n  {\n    n = x[i];\n    if(!hash.has(n))\n\
    \      result.push(n);\n    hash.add(n);\n  }\n  return result;\n}\n", "\tconst\
    \ ret = [];\n\tfor (let i = 0; i < x.length; i++) {\n\t\tconst lastItem = i ===\
    \ x.length - 1 ? 0 : x[i + 1];\n\t\tif (lastItem % 2 === 0) ret.push(x[i]);\n\t\
    }\n\treturn ret;\n}\n", "    let result: number[] = [];\n    x.forEach(i => {\n\
    \        if (result.indexOf(i) < 0) {\n            result.push(i);\n        }\n\
    \    });\n    return result;\n}\n", "  let count = 0;\n  for (let i = 0; i < x.length;\
    \ i++) {\n    while (count < x[1] && x[i] % 10 === 0) {\n      count++;\n    }\n\
    \    \n    if (count < x[1]) {\n      x.splice(0, 1);\n      count--;\n    }\n\
    \  }\n  \n  return x;\n}\n", "  const seen = new Set<number>();\n  let ans = \"\
    \";\n  for (let i = 0, n = x.length; i < n; i++) {\n    let val = x[i];\n    if\
    \ (seen.has(val)) {\n      continue;\n    }\n    seen.add(val);\n    ans += val;\n\
    \  }\n  return [...new Set([...ans]).keys()];\n}\n", "\tlet result: number[] =\
    \ [];\n\tx.forEach((xx: number) => {\n\t\tlet isEven = true;\n\t\tlet evenCount\
    \ = 0;\n\t\tfor (let i = 0; i < xx.length; i++) {\n\t\t\tif (xx[i] % 2 === 0)\
    \ {\n\t\t\t\tisEven = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isEven)\
    \ {\n\t\t\tevenCount++;\n\t\t}\n\t\tif (evenCount > 1) {\n\t\t\tresult.push(xx);\n\
    \t\t}\n\t});\n\treturn result;\n}\n", "  const result = [];\n  for (let i = 0;\
    \ i < x.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (x[i] % 10\
    \ === 0 && x[j] % 10 === 0) {\n        result.push(x[i]);\n      }\n    }\n  }\n\
    \  return result.sort((a, b) => a - b);\n}\n", "  const ans = []\n  let digit\
    \ = 0\n  let dig = null\n  let i = x.length\n  if (x == []) {\n    return ans\n\
    \  }\n  while (i > 0) {\n    dig = x[--i]\n    if (dig == 0) continue\n    digit\
    \ = Math.min(digit, dig)\n    if (ans[digit] != null) continue\n    ans[digit]\
    \ = true\n  }\n  return ans\n}\n", "  let result = new Set()\n  let index = 0\n\
    \  while (index < x.length) {\n    let value = x[index]\n    if (value === 0)\
    \ {\n      index++\n      continue\n    }\n    let digits = String(value).split(\"\
    \")\n    let digit = digits[0]\n    if (!result.has(digit)) {\n      result.add(digit)\n\
    \      index++\n      continue\n    }\n    let lastDigit = result.has(String(value).split(\"\
    \").pop())\n    if (lastDigit === true) {\n      result.delete(digit)\n    } else\
    \ {\n      result.add(digit)\n    }\n  }\n  return Array.from(result)\n}\n", " \
    \ var out: number[] = [];\n  for (var i = 0; i < x.length; i++) {\n    if (out[out.length\
    \ - 1] == 0) out.push(x[i]);\n    else out[out.lastIndexOf(x[i])] = 1;\n  }\n\
    \  return out;\n}\n", "    if (x.length === 0) {\n        return [];\n    }\n\
    \    if (x.length === 1) {\n        return x[0];\n    }\n    let counter: number[]\
    \ = [];\n    for (let i = 0; i < x.length; ++i) {\n        let currentDigit =\
    \ x[i];\n        if (currentDigit < 10) {\n            counter.push(currentDigit);\n\
    \        } else {\n            let nextDigit = x[i + 1];\n            if (nextDigit\
    \ > currentDigit && nextDigit - currentDigit !== 1) {\n                counter.push(currentDigit);\n\
    \            }\n        }\n    }\n    return counter.sort();\n}\n", "  return\
    \ x.filter((val) => {\n    const x = val.toString();\n    return !x.match(/[02468]/g).length\n\
    \  })\n}\n", "  const ret: number[] = [];\n  for (let i = 0; i < x.length; i++)\
    \ {\n    if (x.filter(e => e % 2 === 0).length === 0) {\n      ret.push(x[i]);\n\
    \    }\n  }\n  return ret;\n}\n", "    var num: number[] = [];\n    \n    for(var\
    \ i: number = 0; i < x.length; i++){\n        var sum: number = x[i];\n      \
    \  var digit: number = 0;\n        \n        while(sum > 0){\n            sum\
    \ += Math.floor(sum / 10);\n            digit++;\n        }\n        num[digit]\
    \ = x[i];\n    }\n    \n    return num;\n}\n", "    let result = new Array();\n\
    \    for (let i: number = 0; x < x.length; x++) {\n        let temp = x[i].toString();\n\
    \        if (result.indexOf(temp.charAt(1)) === -1) {\n            result.push(temp);\n\
    \        }\n    }\n    return result.sort((a,b)=>a.localeCompare(b));\n}\n", " \
    \   const y = x.sort((a, b) => a - b);\n    let r = [];\n    while (y[0] % 2 ===\
    \ 0 && y[0] !== 0) r.push(y[0]);\n    let y = [];\n    while (y.length < r.length)\
    \ if (r[y.length] === 0) y.push(r[y.length++]);\n    return y;\n}\n", "  for (let\
    \ i = 0; i < x.length; i++) {\n    for (let j = 0; j < x.length; j++) {\n    \
    \  if (x[i] === x[j]) {\n        x.splice(j, 1)\n      }\n    }\n  }\n  return\
    \ x;\n}\n", "  let result: number[] = [];\n  let digits: number[] = [];\n  for\
    \ (let i = 0; i < (x.length / 2); i++) {\n    if (digits[parseInt(x[i])] === undefined)\
    \ {\n      digits[parseInt(x[i])] = 1;\n      result.push(x[i]);\n    } else {\n\
    \      digits[parseInt(x[i])]++;\n    }\n  }\n  return result;\n}\n", "    var\
    \ temp = new Set();\n    x.forEach(function (e: number) {\n        while(temp.size)\
    \ {\n            if (e % 10 != temp.delete(e % 10)) {\n                temp.add({e:e});\n\
    \                break;\n            }\n        }\n    });\n    return Array.from(temp.values());\n\
    }\n", "  for (let i = 0; i < x.length; i++) {\n    for (let j = i + 1; j < x.length;\
    \ j++) {\n      if (x[i] % 2 === 0 && x[j] % 2 !== 0) {\n        return [...new\
    \ Set([x[i], x[j]])];\n      }\n    }\n  }\n  return [];\n}\n", "    const arr\
    \ = x.sort((a: number, b: number) => a - b) //sort the input array from smallest\
    \ to largest.\n    const res: number[] = []\n    for (let i = 0; i < arr.length;\
    \ i++) {\n        if (arr[i]%2 !== 0) { //check every element that is not an even\
    \ digit.\n            res.push(arr[i])\n        }\n    }\n    return res\n}\n\
    </code>\n<|/ a tags=python,algorithm,javascript dscore=0 |>\n<| a dscore=0 |>\n\
    The idea is to first sort the array in ascending order. Then start iterating the\
    \ array and as soon as a non-digit element is found, you add it to your output\
    \ array. \nThe time complexity of this solution is O(nlogn).\n<code>\ndef unique_digits(xs):\n\
    \    xs.sort()\n    unique = []\n    for i in range(0, len(xs)):\n        if xs[i]\
    \ % 10 != 0 and xs[i] != xs[i-1]:\n            unique.append(xs[i])\n    return\
    \ unique\n</code>\n<|/ a tags=python,algorithm,javascript |>\n<| c |>\nThe time\
    \ complexity is O(nlogn) not O(n).\n<|/ c |>\n<| c |>\nI missed that one. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a dscore=0 |>\nA very simple solution would\
    \ be to make a copy of the input array, sort it, remove all items that don't have\
    \ a single digit, sort it again, and then return the original array. \n<code>\n\
    def unique_digits(array):\n    copy = array.copy()\n    copy.sort()\n    copy\
    \ = copy[:len(copy)-1]\n    copy.sort()\n    return copy\n</code>\nThis would\
    \ have O(n) time complexity and O(n) space. If we were going to implement this\
    \ in Python, the code would look something like this.\n<code>\ndef unique_digits(array):\n\
    \    copy = array.copy()\n    copy.sort()\n    copy = copy[:len(copy)-1]\n   \
    \ copy.sort()\n    return copy\n</code>\nA more advanced solution would be to\
    \ use hash tables to quickly eliminate items that don't have any single digit\
    \ (O(n) time and O(1) space). \n<code>\ndef unique_digits(array):\n    copy =\
    \ array.copy()\n    copy.sort()\n    copy = copy[:len(copy)-1]\n    copy.sort()\n\
    \    lookup = dict()\n    for item in copy:\n        if item not in lookup:\n\
    \            lookup[item] = True\n    copy = [x for x in copy if x in lookup]\n\
    \    copy.sort()\n    return copy\n</code>\n<|/ a tags=python,algorithm,javascript\
    \ |>\n<| a dscore=0 |>\n<code>\ndef unique_digits(array):"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
