name: HumanEval_23_strlen
language: ts
prompt: "//Return length of given string\n// >>> strlen(\"\")\n// 0\n// >>> strlen(\"\
  abc\")\n// 3\nfunction strlen(string: string): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = strlen;\n  assert.deepEqual(candidate(\"\"),0);\n\
  \  assert.deepEqual(candidate(\"x\"),1);\n  assert.deepEqual(candidate(\"asdasnakj\"\
  ),9);\n}\n\ntest();"
completions: ["\treturn string.length;\n}\n", "  return string.length;\n}\n", "  return\
    \ string.split(\"\").length\n}\n", "\treturn _strlen.default)(string, this);\n\
    }\n", "  if (string.length === 0) {\n    return 0;\n  }\n  return string.charCodeAt(0)\
    \ !== string.charCodeAt(string.length - 1) ? 0 : 1;\n}\n", "    const len = string.length;\n\
    \    if (typeof len === 'undefined' || len === null) return 0;\n    if (len ===\
    \ 0) return 1;\n    return len.toString().length;\n}\n", "  if ( string === void\
    \ 0 ) string = '';\n\n  return string.length\n}\n", "  return string.split(\"\"\
    ).length\n}", "\treturn string.length;\n}\n", "  if (string == null) {\n    return\
    \ 0;\n  }\n\n  return string.length;\n}\n", "    return string.length;\n}\n",
  "    const str: string = (string + \"\").toLowerCase();\n    return (str.length\
    \ >= 4 ? str.length : 4) + 1;\n}\n", "\treturn string.length;\n}", "    return\
    \ string.split('').length\n}\n", "    return string.length;\n}\n", "  string =\
    \ String(string);\n  return string.length;\n}\n", "  return string.length;\n}\n",
  "  return string.length;\n}", "    if (string.length == 0) {\n        return 0;\n\
    \    }\n    if (string.charCodeAt(string.length - 1) == 92) {\n        return\
    \ string.length;\n    }\n    return string.length - 1;\n}\n", "  return string.trim().replace(/[^\\\
    s]/g, \"\").length;\n}\n", "  return string.length\n}\n", "    if (string ===\
    \ '') {\n        return 0\n    }\n    return string.length\n}\n", "\tlet i: number\
    \ = 0,\n\t\tresult = 0,\n\t\tlen = string.length;\n\twhile (i < len) {\n\t\tresult\
    \ += string.charCodeAt(i++);\n\t}\n\treturn result;\n}\n", "\tlet i: number =\
    \ 0;\n\twhile (i + 1 < string.length) {\n\t\ti++;\n\t}\n\treturn i;\n}", "  return\
    \ string.length;\n}\n", "\t// return string.match(/./g).length;\n\treturn string.length;\n\
    }\n", "  return string.length;\n}\n", "\tlet length: number;\n\tlet i = 0;\n\t\
    while (i < string.length) {\n\t\tconst charCode = string.charCodeAt(i);\n\t\t\
    if (charCode > 0xD800 && charCode < 0xDC00) {\n\t\t\tconst lower = string.charCodeAt(++i);\n\
    \t\t\tif (lower > 0xD800 && lower < 0xDC00) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\
    \tlength++;\n\t\ti++;\n\t}\n\treturn length;\n}\n", "  if (string === \"\") {\n\
    \    return 0;\n  }\n\n  if (isString(string)) {\n    return string.length;\n\
    \  }\n\n  if (typeof string === \"object\") {\n    string = \"\".concat(string);\n\
    \  }\n\n  if (typeof string === \"function\") {\n    return string.call(this);\n\
    \  }\n\n  return string ? string.length : 0;\n}\n", "  // return string ? string.length\
    \ : 0;\n  return (string) ? string.length : 0;\n}\n", "  return string.length;\n\
    }", "  return string.match(new RegExp(\"\" + REGEXP_STRING_LENGTH));\n}\n", " \
    \   return string.length;\n}\n", "    const length = string.length;\n    if (length\
    \ === 0) {\n        return 0;\n    }\n    if (string.charCodeAt(length-1) > 0xFF)\
    \ {\n        return length - 1;\n    }\n    return length;\n}\n", "    return\
    \ string.length;\n}\n", "  if (typeof string !== 'string') {\n    throw new TypeError('The\
    \ first argument must be of type string and only contain strings')\n  }\n  if\
    \ (string === '') {\n    return 0\n  }\n  let count = 0\n  for (let i = 0; i <\
    \ string.length; i++) {\n    if (string[i] !== undefined) {\n      count++\n \
    \   }\n  }\n  return count\n}\n", "  return string.charCodeAt(0) === 0xFF ? string.length\
    \ : string.length;\n}\n", "  if (string.length > 0) return string.length;\n  return\
    \ 0;\n}\n", "  return string.split('').length\n}\n", "  return string.split(/string|\\\
    r?\\n/).length - 1;\n}\n", "  let length = string.length;\n  while (length--)\
    \ {\n    const charCode = string.charCodeAt(length);\n    if (charCode > 0x7f\
    \ && charCode <= 0x7ff) length += 1;\n    else if (charCode > 0x7ff && charCode\
    \ <= 0xffff) length += 2;\n  }\n  return length;\n}\n", "    // >> (4 - ((str.length\
    \ + 1) >> 1)) & 3\n    // << (str.length + 1) >> 1\n    // >>> 4 - ((str.length\
    \ + 1) >> 1) & 3\n    // >>> str.length >> 1\n    return ((str.length + 1) >>\
    \ 1);\n}\nexport function strcmp(str1: string, str2: string): number {\n    return\
    \ str1.localeCompare(str2);\n}\nexport function strcasecmp(str1: string, str2:\
    \ string): number {\n    return str1.localeCompare(str2);\n}\nexport function\
    \ strcasecmp_reverse(str1: string, str2: string): number {\n    return str2.localeCompare(str1);\n\
    }\nexport function strncasecmp(str1: string, str2: string, len: number): number\
    \ {\n    return str1.localeCompare(str2, undefined, undefined, len * -1);\n}\n\
    export function strncasecmp_reverse(str1: string, str2: string, len: number):\
    \ number {\n    return str2.localeCompare(str1, undefined, undefined, len * -1);\n\
    }\nexport function strxfrm(str: string, sep: string, maxsplit: number): string\
    \ {\n    return str.split(sep, maxsplit);\n}\nexport function strstr(str: string,\
    \ search: string): number {\n    return str.indexOf(search);\n}\nexport function\
    \ strtolower(str: string): string {\n    return str.toLowerCase();\n}\nexport\
    \ function strtoupper(str: string): string {\n    return str.toUpperCase();\n\
    }\nexport function strrchr(string, char: string): number {\n    return string.lastIndexOf(char);\n\
    }\nexport function strrchr_reverse(string, char: string): number {\n    return\
    \ string.lastIndexOf(char, string.length - 1);\n}\nexport function strstr(string,\
    \ search: string): number {\n    return string.indexOf(search);\n}\nexport function\
    \ strtolower(str: string): string {\n    return str.toLowerCase();\n}\nexport\
    \ function strtoupper(str: string): string {\n    return str.toUpperCase();\n\
    }\nexport function strrchr(string, char: string): number {\n    return string.lastIndexOf(char);\n\
    }\nexport function strrchr_reverse(string, char: string): number {\n    return\
    \ string.lastIndexOf(char, string.length - 1);\n}\nexport function strstr(string,\
    \ search: string): number {\n    return string.indexOf(search);\n}\nexport function\
    \ strtolower(str: string): string {\n    return str.toLowerCase();\n}\nexport\
    \ function strtoupper(str: string): string {\n    return str.toUpperCase();\n\
    }\nexport function strrchr(string, char: string): number {\n    return string.lastIndexOf(char);\n\
    }\nexport function strrchr_reverse(string, char: string): number {\n    return\
    \ string.lastIndexOf(char, string.length - 1);\n}\nexport function strstr(string,\
    \ search: string): number {\n", "  return string.length;\n}\n", "  return string\
    \ == undefined ? 0 : string.length\n}\n", "  return string.length;\n}\n", "  \
    \  // tslint:disable-next-line:strict-type-predicates\n    if (typeof string !==\
    \ 'string') throw new TypeError('String expected');\n    return string.length;\n\
    }", "  const length: number = string.length;\n\n  return length > 0\n    ? length\n\
    \    : (length < 0)\n    ? (\"0\".repeat(length as number))\n    : (length + \"\
    \");\n}\n", "    return string.length;\n}\n", "    return string.length;\n}\n",
  "\treturn string.charCodeAt(0) !== 0 ? string.charCodeAt(0) : 1;\n}\n", "  return\
    \ string.length;\n}\n", "    const length: number = string.length;\n    return\
    \ length ? Math.min(length, maxLength) : 0;\n}\n", "    const codePoint = string.codePointAt(0);\n\
    \n    // Check if a string's length property is larger than its content's length\n\
    \    const length = string.length >= string.length ? string.length : string.length;\n\
    \n    // Calculate the number of UTF-8 characters to compute\n    return string.length\
    \ * Math.ceil(length / string.length);\n}\n", "    return string.split(/[\\\\\
    t\\\\n\\\\r\\\\\\\\u0020\\\\u0022\\\\u007f-\\\\u009f]/).length - 1;\n}\n", "\t\
    let count: number;\n\tif (string.length === 0) {\n\t\tcount = 0;\n\t} else if\
    \ (string[0] === \"0\") {\n\t\tstring = string.slice(1);\n\t\tcount = string.length\
    \ / 2;\n\t} else {\n\t\tcount = string.length;\n\t}\n\treturn count;\n}\n", " \
    \ if (string.length === 0) {\n    return 0;\n  }\n  const chars = string\n   \
    \ .split('')\n    .reduce(\n      (result, char) => (result + char.length),\n\
    \      0\n    );\n  return chars;\n}\n", "  return _strlenPre.test(string)\n \
    \   ? _strlenPre.exec(string)[0]\n    : string.length;\n}\n", "  return string.length;\n\
    }\n", "  return string == null ? 0 : string.length;\n}\n", "  if (string.length\
    \ === 0) {\n    return 0;\n  }\n  const length = (string[0] === \"\" ? 1 : 0)\
    \ + string.length;\n  for (let index = 1; index < string.length; index++) {\n\
    \    if (string.charCodeAt(index) !== string[index].charCodeAt(0)) {\n      return\
    \ length;\n    }\n  }\n  return length;\n}\n", "    return string.length;\n}\n",
  "\treturn string.charCodeAt(0) !== null ? string.length : -1;\n}\n", "\treturn string.length\n\
    }\n", "  return string.split('').reduce(function (sum, char, index): number {\n\
    \    return sum + char.length === index? char.length : 0\n  }, 0)\n}\n", "\treturn\
    \ string ? string.length : 0;\n}\n", "  return string.trim().length\n}\n", " \
    \ const length: number = string.length;\n  return length === 0 ? 0 : length;\n\
    }\n", "\treturn string.length;\n}\n", "  return (string: string).toLowerCase().replace(/^[^a-z]*|[^a-z]*$/,\
    \ '').length\n}\n\nconst _toPrimitive = /*#__PURE__*/Object.freeze({\n  default:\
    \ _toPrimitive,\n  __moduleExports: _toPrimitive\n});\n\nconst hasOwnProperty\
    \ = Object.prototype.hasOwnProperty;\n\nconst str = _toPrimitive('');\n", "  const\
    \ str: string = string + \"\"; // Make sure we have an empty string\n  const len:\
    \ number = str.length; // Create an empty string\n  for (let i: number = 0; i\
    \ < str.length; i++) {\n    len++; // Count the characters\n  }\n  return len;\
    \ // Return length of string\n}\n</code>\n<|/ a dscore=2 tags=javascript |>\n\
    <| a tags=javascript dscore=1 |>\nIn order to achieve the result you want, the\
    \ string should be converted to a character array using the String.prototype.toCharArray\
    \ method.\nThe method takes a parameter that specifies how many characters to\
    \ return, which is also the length of that array.  \n<code>\nconst text = \"hello\"\
    ; // String variable holding text\nconst length = text.length; // Get length of\
    \ text\n", "  if (string === '') {\n    return 0;\n  }\n\n  let str: string =\
    \ string;\n  let charLen = 0;\n  let offset = 0;\n  while (str.length > offset)\
    \ {\n    charLen++;\n    offset++;\n    str = str.slice(offset);\n  }\n  return\
    \ charLen;\n}\n", "  let str: string;\n  try {\n    str = string.valueOf();\n\
    \  } catch (e) {\n    // TODO: throw or return 0?\n  }\n  return str.replace(/\\\
    \\/g, '').length;\n}\n", "  return string.length;\n}", "  const len = string.length;\n\
    \  if (len === 0) return 0;\n  if (len === 1 && string.charCodeAt(0) === 0x31)\
    \ return 1; // special case: looking for \"a\" or \"an\"\n  return len;\n}\n",
  "    let length = 0;\n    for (const char of string) {\n        ++length;\n    }\n\
    \    return length;\n}", "  const len: number = string.length\n  return len\n\
    }\n", "  let length = 0\n  for (let i = 0; i < string.length; i++) {\n    const\
    \ char = string[i]\n    length++\n    if (char === '\\0' || char === '\\n') {\n\
    \      return length\n    }\n  }\n  return length\n}\n", "  return string.length\n\
    }\n", "  const length: number = string.length;\n  return length === 0 ? 0 : length;\n\
    }", "  return string.length;\n}", "  return string.length || (string + \"\").replace(regexp,\
    \ \"$1\").length;\n}\n\nconst _hasProto = typeof Object.prototype === \"function\"\
    \ && typeof Object[\"prototype\"] !== \"undefined\";\nconst _isProto = typeof\
    \ Object.getPrototypeOf === \"function\" && Object.getPrototypeOf(Object) ===\
    \ Object.prototype;\nconst _propertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\
    const _hasOwnProperty = Object.prototype.hasOwnProperty;\n", "  if (string ===\
    \ null || string === undefined) {\n    return 0;\n  }\n  const str: string = string.toString();\n\
    \  let result = 0;\n  for (let index = 0; index < str.length; index++) {\n   \
    \ const character = str.charAt(index);\n    if (character !== '.' && character\
    \ !== '_' && character !== '/') {\n      result += 1;\n    }\n  }\n  return result;\n\
    }\n", "\tconst length = string.length;\n\n\treturn length > 0 ? length : NaN;\n\
    }\n", "  return string.length;\n}\n", "  return typeof string === \"string\" ?\
    \ string.length : 0;\n}\n", "  return string.split('').length;\n}\n", "\tlet length:\
    \ number = 0;\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlength += string.charCodeAt(i);\n\
    \t}\n\treturn length;\n}\n", "  return string.length > 0 ? string.length : 0;\n\
    }\n", "\tlet len: number = 0;\n\n\tfor (let i = 0, length = string.length; i <\
    \ length; ++i) {\n\t\tlen += string.charCodeAt(i);\n\t}\n\n\treturn len;\n}\n",
  "\tconst length = string && string.length || 0;\n\treturn length;\n}\n", "  return\
    \ string.length;\n}\n", "\tlet i: number = 0;\n\tlet length: number = 0;\n\tfor\
    \ (let i = 0; i < string.length; i++) {\n\t\tconst code = string.charCodeAt(i);\n\
    \t\tif (code < 0x80) {\n\t\t\tlength++;\n\t\t}\n\t\telse if (code < 0x800) {\n\
    \t\t\tlength += 2;\n\t\t}\n\t\telse if (code < 0x10000) {\n\t\t\tlength += 3;\n\
    \t\t}\n\t\telse if (code < 0x110000) {\n\t\t\tlength += 4;\n\t\t}\n\t\telse if\
    \ (code < 0x200000) {\n\t\t\tlength += 5;\n\t\t}\n\t\telse {\n\t\t\tlength +=\
    \ 6;\n\t\t}\n\t}\n\treturn length;\n}\n", "  return string.length;\n}\n", "  \
    \  // tslint:disable-next-line: no-bitwise\n    return string.byteLength >>> 0;\n\
    }\n", "  return string.split('').length\n}\n", "    // >>> strlen(\"\")\n    //\
    \ 0\n    if (string === \"\") {\n        return 0\n    }\n    // >>> strlen(\"\
    abc\")\n    // 3\n    const length = string.length\n    // >>> strlen(\"\")\n\
    \    // 0\n    if (string === \"\") {\n        return 0\n    }\n    // >>> strlen(\"\
    abc\")\n    // 3\n    return length\n}", "    return string.length;\n}\n", " \
    \ return string.match(regex).length;\n}\n", "\treturn string.length;\n}\n", " \
    \   let i: number = 0;\n\n    while (i + 1 < string.length) {\n        i++;\n\
    \    }\n\n    return i;\n}\n", "    return string.length\n}\n", "  if (string\
    \ === null || string === undefined) return 0;\n  return string.length;\n}\n",
  "  if (string === \"\") return 0;\n  return string.length;\n}\n", "    let charCode:\
    \ number;\n    let length: number;\n    if (typeof string !== \"string\") return\
    \ 0;\n    charCode = string.charCodeAt(0);\n    length = 0;\n    if (charCode\
    \ >= 256) length++;\n    for (let charIdx = 1; charIdx <= string.length; charIdx++)\
    \ length += string[charIdx].length;\n    return length;\n}", "    const res =\
    \ new Uint8Array(lengthBytesUTF8(string) + 1);\n    let result = 0;\n    let resLen\
    \ = 0;\n    while (res != 0) {\n        res = getByte(string, res);\n        resLen++;\n\
    \        result++;\n    }\n    return result;\n}\n", "    let len = 0;\n    for\
    \ (const char of string) {\n        len += char.length;\n    }\n    return len;\n\
    }\n", "  return string.length;\n}\n", "  return string.length;\n}\n", "  return\
    \ string.length;\n}\n", "  if (string.length === 0) {\n    return 0;\n  }\n  let\
    \ i = 0;\n  let len = string.length;\n  while (i < len) {\n    const code = string.charCodeAt(i);\n\
    \    if (code < 128) {\n      i++;\n    } else if (code > 127 && code < 2048)\
    \ {\n      i += 2;\n    } else {\n      i += 3;\n    }\n  }\n  return i;\n}",
  "  return string.length;\n}\n", "  return string.charCodeAt(0) !== 0xFEFF ? string.length\
    \ : string.split('', 1).length;\n}\n", "  if (string == \"\") {\n    return 0;\n\
    \  }\n  const l = string.length;\n  if (l === 0) {\n    return l;\n  }\n  const\
    \ n = 1;\n  while (n < l) {\n    const t = n % l;\n    if (t === 0) {\n      return\
    \ n;\n    }\n    n++;\n  }\n  return n;\n}\n", "  return string.length;\n}", " \
    \ if (string === '') {\n    return 0;\n  }\n  if (string === null || string ===\
    \ undefined || string === Infinity || string === -Infinity) {\n    return NaN;\n\
    \  }\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a\
    \ string');\n  }\n\n  const stringLength = string.length;\n\n  // `ToInteger`\
    \ abstract operation\n  // https://tc39.es/ecma262/#sec-tointeger\n  const toInteger\
    \ = function (argument) {\n    return isNaN(argument = +argument) ? 0 : (argument\
    \ > 0 ? floor : ceil)(argument);\n  };\n\n  const length = toInteger(stringLength);\n\
    \  return length < 0 ? 0 : length;\n}\n", "  return string.length;\n}\n", "\t\
    return string === \"\" ? 0 : string.length\n}\n", "\treturn string.length;\n}\n",
  "\treturn string.length;\n}\n", "\treturn string.length;\n}\n", "  string = toString.call(string);\n\
    \  return isString(string) ? string.length : toInteger(string.length);\n}\n",
  "\tlet length: number\n\ttry {\n\t\tlength = string.length\n\t} catch (e) {\n\t\t\
    length = 0\n\t}\n\treturn length\n}\n", "    return string.length;\n}\n", "  const\
    \ len: number = string.length;\n  return typeof len === 'number' ? len : NaN;\n\
    }\n", "  let len = 0;\n  for (let i = 0; i < string.length; i++) {\n    len +=\
    \ string[i].length + 1;\n  }\n  return len;\n}\n", "  return string.split('').length;\n\
    }\n", "  return string.split(\"\").length\n}\n", "  if (string === \"\") {\n \
    \   return 0;\n  }\n  return string.length;\n}\n", "\treturn string.length > 0\
    \ ? string.length : 0;\n}\n\n", "\tconst result = new BigInteger(string).bitLength();\n\
    \treturn result === 160 ? 170 : result;\n}\n", "\treturn string.length;\n}", " \
    \ return string.length;\n}\n", "\tif (typeof string === \"string\") {\n\t\treturn\
    \ string.length;\n\t}\n\n\treturn 0;\n}\n", "  if (string == null) return 0\n\
    \  if (string.length === 0) return 0\n  if (typeof string === 'number') {\n  \
    \  return string\n  }\n  if (typeof string !== 'string') {\n    throw new Error('expected\
    \ a string but got ' + string)\n  }\n  return string.length\n}\n", "  return string.length;\n\
    }\n", "  if (string == null || string === \"\") {\n    return 0;\n  }\n  return\
    \ string.length;\n}\n", "  // return unescape(encodeURIComponent(string)).length;\n\
    \  const strLength = string.length;\n  const strLenUnicode = string.replace(/\\\
    u0000/g, '\uFFFD'); // escape unicode\n  let strLenAscii = strLenUnicode.length;\n\
    \  if (strLenAscii < strLength) {\n    return strLength;\n  } else {\n    return\
    \ strLenAscii;\n  }\n}\n", "  return string == null ?\n    0\n  : typeof string\
    \ === 'string' ? string.length : undefined;\n}\n\n", "    return string ? string.length\
    \ : 0;\n}\n", "  const str = `${string}`;\n  return str.length || 0;\n}\n", " \
    \   return string ? string.length : 0;\n}\n", "  if (string === \"\") {\n    return\
    \ 0;\n  }\n\n  return string.length;\n}\n", "  return string ? string.trim().length\
    \ || 0 : 0; \n}\n", "  return string.trim().length;\n}\n", "  return string.length;\n\
    }\n", "  return string == null ? 0 : String(string).length;\n}\n", "  return string.length;\n\
    }\n", "    return string.length;\n}\n", "  // return string.length;\n  let length\
    \ = string.length;\n\n  for (let i = 0; i < length; i++) {\n    if (string[i]\
    \ !== ' ') break;\n  }\n\n  return i;\n}\n", "    return string.length;\n}\n",
  "  // See https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Counting_substrings#JavaScript\n\
    \  // for the math behind the algorithm. Basically:\n  // - If string is empty\
    \ return the 0 that comes in when doing \"-1\" operation\n  // - If string is\
    \ length 0 return 0\n  // - If string is 1 character length return 1\n  // - If\
    \ string is more than 1 character length return the length of the string + 1\n\
    \  return string.length > 0 ? string.length : 0;\n}\n", "  if (string == null)\
    \ return 0;\n  if (typeof string !== \"string\") throw new Error(\"Expected a\
    \ string\");\n  return string.length;\n}", "  return string ? string.length :\
    \ 0;\n}\n", "  return string.split('').length\n}\n", "    return string.length\n\
    }\n", "  return string.length;\n}\n", "  return string.length;\n}\n", "  const\
    \ length: number = string.length;\n\n  // Calculate the string length by counting\
    \ the number of characters minus the\n  // first character.\n  // When calculating\
    \ the number of characters, we subtract the first character so\n  // that we can\
    \ start the count at 1.\n  // Note: this works even if `string` is a substring\
    \ of the string `\"\"`.\n  if (string.charCodeAt(0) === 0x20) {\n    length--;\n\
    \  }\n\n  return length;\n}\n", "  return string.length\n}\n\nexport function\
    \ strpad(string: string, padTo: string, padStr: string = \"0\", padType = \"right\"\
    , padToLength: number = 0): string {\n  let padLen: number\n  let padStart: number\n\
    \  let padEnd: number\n  let strLen: number\n\n  if (typeof padTo === \"string\"\
    ) {\n    padToLength = Math.max(padTo.length, padToLength)\n  } else if (typeof\
    \ padTo === \"number\") {\n    padToLength = padTo\n  }\n\n  padLen = padToLength\
    \ - string.length\n\n  if (padLen < 0 || padLen > padToLength) {\n    throw new\
    \ Error(\n      `strpad pad type must be either \"right\" or \"left\", and pad\
    \ length is ${padLen}, not ${padToLength}`\n    )\n  }\n\n  if (typeof padStr\
    \ === \"string\") {\n    padStr = padStr.substring(0, padLen)\n  }\n\n  if (typeof\
    \ padStr === \"number\") {\n    padStr = String(padStr)\n  }\n\n  if (padStart\
    \ !== undefined) {\n    padStart = String(padStart)\n  }\n\n  if (padEnd !== undefined)\
    \ {\n    padEnd = String(padEnd)\n  }\n\n  strLen = padStart + padLen + string\
    \ + padEnd\n  return strLen\n}\n", "  return Math.ceil(string.length / stringLength);\n\
    }\n", "\tlet len = 0;\n\tlet pos;\n\twhile ((pos = string.indexOf('\\n')) != -1)\
    \ {\n\t\t++len;\n\t\tstring = string.slice(0, pos);\n\t}\n\treturn len;\n}\n",
  "  if (string === \"\") {\n    return 0;\n  }\n  const result = new Uint8Array(string.length);\n\
    \  for (let i = 0; i < string.length; i++) {\n    result[i] = string.charCodeAt(i);\n\
    \  }\n  return result.length;\n}\n", "  return string.length\n}\n", "  if (string\
    \ === \"\" || string === undefined) return 0;\n  return string.trim().length\n\
    }\n", "  return string.split(\"\").length\n}\n", "\treturn (<any>string).length;\n\
    }\n", "    // Return the length of the given string\n    const size = string.length;\n\
    \    return size == 0 ? size : size * Math.pow(256, strLenCode$1);\n}\n", "  return\
    \ string.split(/[ -~]/).length;\n}\n", "    let str: string = string + '';\n \
    \   let result = 0;\n    let length = str.length;\n    for (let i = 0; i < length;\
    \ i++) {\n        result += (string.charCodeAt(i) * Math.pow(16, length));\n \
    \   }\n    return result;\n}\n", "    let str: string = string;\n    let length:\
    \ number = 0;\n    let index = 0;\n    let code;\n\n    while (index < str.length)\
    \ {\n        code = str.charCodeAt(index++);\n        if (code < 128) {\n    \
    \        length++;\n        }\n        else if (code > 127) {\n            length\
    \ += 2;\n        }\n        else {\n            length += 3;\n        }\n    }\n\
    \n    return length;\n}\n", "  return string.length;\n}\n", "  let length: number\
    \ = 0;\n  for (let index = 0; index < string.length; index++) {\n    length++;\n\
    \  }\n  return length;\n}\n", "    // return string.length\n    if (typeof string\
    \ !== \"string\") return 0\n\n    return string.length\n}\n", "  // strlen(\"\
    abc\")\n  if (string == \"\") {\n    return 0;\n  }\n  let current = 0;\n  let\
    \ length = 0;\n  while (current < string.length) {\n    const char = string.charCodeAt(current);\n\
    \    if (char < 0x20 || char > 0x7e) {\n      length = string.length - current;\n\
    \      break;\n    }\n    current += 1;\n    length += 1;\n  }\n  return length;\n\
    }\n", "    return string.length;\n}\n", "  return string.length;\n}\n", "  //\
    \ return string.length\n  return string.split(/[\\0\\s]/).length\n}\n", "  return\
    \ string.length;\n}\n", "  return string.length;\n}\n", "  return string.length\n\
    }\n", "  return string ? string.length : 0;\n}\n", "  if (string.length > 0xFFFFFFFF)\
    \ {\n    return -1; // eslint-disable-line no-bitwise\n  }\n  return string.length\
    \ / 2;\n}\n", "  return string.length;\n}\n", "  return string.length;\n}\n",
  "  return string.length;\n}", "  return string.length;\n}\n", "  let ret: number\
    \ = 0;\n  for (let i = string.length; i--;) {\n    ret += string.charCodeAt(i);\n\
    \  }\n  return ret;\n}\n", "\treturn string.length > 0 ? string.charCodeAt(0)\
    \ : 0;\n}\n", "  return string ? string.split(\"\").length : 0;\n}\n\ntype IArguments\
    \ = Function;\n", "    return string ? string.length : 0;\n}\n", "  return string.length;\n\
    }\n", "  return string.length;\n}\n", "  return string.length;\n}", "  return\
    \ string.length;\n}\n", "    return string.length;\n}\n", "  return typeof string\
    \ === \"string\" ? string.length : 0;\n}\n", "    let result: number = 0\n   \
    \ for (let i = 0; i < string.length; i++) {\n        result += 1\n    }\n    return\
    \ result\n}\n", "\treturn typeof string === \"string\" ? string.length : 0;\n\
    }\n", "  return string.length;\n}\n", "  return Math.ceil(\n    string.length\
    \ / MAX_LENGTH\n  ) as number;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
