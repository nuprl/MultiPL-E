name: HumanEval_18_how_many_times
language: ts
prompt: "//Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n// >>> how_many_times(\"\", \"a\")\n// 0\n// >>> how_many_times(\"\
  aaa\", \"a\")\n// 3\n// >>> how_many_times(\"aaaa\", \"aa\")\n// 3\nfunction how_many_times(string:\
  \ string, substring: string): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = how_many_times;\n  assert.deepEqual(candidate(\"\"\
  , \"x\"),0);\n  assert.deepEqual(candidate(\"xyxyxyx\", \"x\"),4);\n  assert.deepEqual(candidate(\"\
  cacacacac\", \"cac\"),4);\n  assert.deepEqual(candidate(\"john doe\", \"john\"),1);\n\
  }\n\ntest();"
completions: ["  let count = 0;\n  let i = 0;\n  let j = 0;\n\n  while (i < string.length\
    \ && j < substring.length) {\n    if (string[i] === substring[j]) {\n      count++;\n\
    \      i++;\n      j++;\n    } else if (i < string.length) {\n      i++;\n   \
    \ } else {\n      j++;\n    }\n  }\n  return count;\n}\n", "\tlet count = 1;\n\
    \tlet i = 0;\n\twhile (i < string.length) {\n\t\tlet j = 0;\n\t\twhile (j < substring.length\
    \ && i < string.length) {\n\t\t\tif (string[i] === substring[j]) {\n\t\t\t\tcount++;\n\
    \t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else if (string[i] < substring[j]) {\n\t\t\
    \t\ti++;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n", "    let substr_index = string.toLowerCase().indexOf(substring.toLowerCase());\n\
    \    if (substr_index == -1) return 0;\n    return substr_index;\n}\n", "\tlet\
    \ count = 0\n\tlet index = -1\n\tlet startIndex = -1\n\tlet endIndex = -1\n\n\t\
    while (++index < string.length) {\n\t\tstartIndex = string.indexOf(substring,\
    \ index+1)\n\t\tif (startIndex === -1) {\n\t\t\tcontinue\n\t\t}\n\n\t\tendIndex\
    \ = startIndex + substring.length\n\t\tcount += 1\n\n\t\tif (endIndex < string.length)\
    \ {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn count\n}\n", "\tif (string === substring)\
    \ {\n\t\treturn 0;\n\t}\n\tconst length = string.length;\n\tfor (let index = 0;\
    \ index < length; index++) {\n\t\tconst foundIndex = string.indexOf(substring,\
    \ index + 1);\n\t\tif (foundIndex >= 0) {\n\t\t\treturn foundIndex - index;\n\t\
    \t}\n\t}\n\treturn length;\n}\n", "    let num_times: number = 0;\n    for (let\
    \ index = 0; index < string.length; index++) {\n        if (string.indexOf(substring,\
    \ index) == index) {\n            num_times += 1;\n            if (string.indexOf(substring,\
    \ index + 1) == index + 1) {\n                num_times += 1;\n            }\n\
    \            if (string.indexOf(substring, index - 1, -1) == index + 1) {\n  \
    \              num_times += 1;\n            }\n            if (string.indexOf(substring,\
    \ index, index + substring.length + 1) == index + substring.length + 1) {\n  \
    \              num_times += 1;\n            }\n            if (string.indexOf(substring,\
    \ index, index + substring.length - 1) == index + substring.length + 1) {\n  \
    \              num_times += 1;\n            }\n        }\n    }\n    return num_times;\n\
    }\n", "    let count = 0;\n    for (const letter of string) {\n        if (substring.includes(letter))\
    \ {\n            count += 1;\n        }\n    }\n    return count;\n}\n", "   \
    \ let substring_index: string = string.toLowerCase().indexOf(substring.toLowerCase());\n\
    \    if (substring_index === -1) { return 0; }\n    let total_letters: number\
    \ = 0;\n    for (let i = 0; i < string.length - substring_index; i++) {\n    \
    \    total_letters += string[i].toLowerCase().indexOf(substring[i].toLowerCase());\n\
    \    }\n    return total_letters;\n}\n", "  // Return the number of times a substring\
    \ occurs in a string.\n  // >>> how_many_times(\"abbc\", \"c\")\n  // 2\n  //\
    \ >>> how_many_times(\"abccc\", \"c\")\n  // 0\n  // >>> how_many_times(\"abccc\"\
    , \"ab\")\n  // 3\n  // >>> how_many_times(\"abbb\", \"ab\")\n  // 1\n  // >>>\
    \ how_many_times(\"abbb\", \"a\")\n  // 1\n  return string.split(substring).length\
    \ - 1;\n}\n", "  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n\
    \    if (string[i] === substring[0]) {\n      count++;\n    }\n    if (string[i]\
    \ === substring[1]) {\n      count++;\n    }\n  }\n  return count;\n}\n", "  const\
    \ times = string.match(new RegExp(substring));\n  return times == null ? 0 : times.length;\n\
    }\n", "    let count = 0;\n    const startIndex = 0;\n    const endIndex = string.length;\n\
    \n    while (startIndex < endIndex) {\n        const index = string.indexOf(substring,\
    \ startIndex);\n        if (index === -1) {\n            break;\n        }\n\n\
    \        startIndex = index + substring.length;\n        count++;\n    }\n\n \
    \   return count;\n}\n</code>\n<|/ a tags=algorithm,javascript,string,replace\
    \ |>\n<| a |>\nThe shortest way is to use indexOf() like below:\n\n<code>\nvar\
    \ str = \"AABBABA\",\n    str = \"AABBABA\",\n    str = \"AABBABA\",\n    str\
    \ = \"AABBABA\",\n    str = \"AABBABA\",\n    str = \"AABBABA\",\n    str = \"\
    AABBABA\",\n    str = \"AABBABA\",\n    str = \"AABBABA\",\n    str = \"AABBABA\"\
    ,\n    str = \"AABBABA\",\n    str = \"AABBABA\",\n    str = \"AABBABA\",\n  \
    \  str = \"AABBABA\",\n    str = \"AABBABA\",\n    str = \"AABBABA\",\n    str\
    \ = \"AABBABA\",\n    str = \"AABBABA\",\n    str = \"AABBABA\",\n    str = \"\
    AABBABA\",\n    str = \"AABBABA\";\n\nconsole.log(str.indexOf(\"AABBABA\"));</code>\n\
    \nThe output is always -1 because you are passing a string and it will not find\
    \ an index.\nIf you want to find the exact index then you need to loop through\
    \ the string and find that value.\n<|/ a dscore=3 tags=algorithm,javascript,string,replace\
    \ |>\n<| c |>\nWhat if I have \"AABBABAAB\"? You will always get -1 as the output.\
    \ Instead you should start from the index and check each and every index.\n<|/\
    \ c |>\n<| a dscore=2 |>\nA bit late to the party, but if you can use lodash it\
    \ has a function called countBy which can do the trick here.\n<code>", "\tlet\
    \ count = 0;\n\tlet i = 0;\n\twhile (i < string.length) {\n\t\tif (string[i] ===\
    \ substring[0]) {\n\t\t\tif (string.slice(i, i + substring.length) === substring)\
    \ {\n\t\t\t\tcount += 1;\n\t\t\t\ti += substring.length;\n\t\t\t} else {\n\t\t\
    \t\tcount += 0;\n\t\t\t}\n\t\t} else {\n\t\t\tcount += 0;\n\t\t}\n\t\ti += 1;\n\
    \t}\n\treturn count;\n}\n", "    let count = 0;\n    const regex = new RegExp(substring,\
    \ \"g\");\n    const matches = string.match(regex);\n    if (matches != null)\
    \ {\n        matches.forEach((val) => {\n            if (val != substring) count++;\n\
    \        });\n    }\n    return count;\n}\n", "\tlet count = 0\n\tfor (let i =\
    \ 0; i < string.length; i++) {\n\t\tif (string.substr(0, i + 1).indexOf(substring)\
    \ != -1) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n", "  // Count how many\
    \ times the substring can be found in its entirety.\n  // >>> how_many_times(\"\
    aaaa\", \"a\")\n  // 3\n  const strings_count = string.length;\n  const substrings_count\
    \ = substring.length;\n  const overlaping_count = strings_count - substrings_count;\n\
    \  const substrings_count_without_overlap = substrings_count - overlaping_count;\n\
    \  // If the substring is entirely contained, count only the string length.\n\
    \  if (strings_count === 0) {\n    return substrings_count_without_overlap;\n\
    \  }\n  // If the substring does not overlap with the string entirely, count only\
    \ the string length.\n  if (substrings_count_without_overlap === 0) {\n    return\
    \ substrings_count;\n  }\n  // If the substring overlaps with the string entirely,\
    \ count the number of times the substring can be found in the whole string.\n\
    \  if (strings_count < substrings_count_without_overlap) {\n    return strings_count;\n\
    \  }\n  return strings_count - substrings_count_without_overlap;\n}\n", "  let\
    \ n = 0;\n  let index = 0;\n  while (index <= string.length - substring.length)\
    \ {\n    n++;\n    index += string.indexOf(substring, index);\n  }\n  return n;\n\
    }", "\treturn string.toLowerCase().split(substring).length - 1;\n}\n", "  // Check\
    \ if substring is found inside string\n  const substring_found = string.includes(substring);\n\
    \n  // If substring is not found, return 0 of there is only one occurrence.\n\
    \  if (!substring_found) return string.split(substring).length - 1;\n\n  // If\
    \ substring is found, increment count variable by 1, otherwise return count -\
    \ 1.\n  return substring_found ? string.split(substring).length + 1 : string.split(substring).length\
    \ - 1;\n}\n", "    const search_str = `${substring}`;\n\n    // Remove all the\
    \ occurrences of the substring\n    string = string.replace(new RegExp(search_str,\
    \ 'g'), '');\n\n    // Return the length of the string after removing the substring.\n\
    \    return string.length;\n}\n\nconsole.log(how_many_times(\"aaaa\", \"aa\"));\
    \ // 3\n</code>\n<|/ a tags=javascript,string,algorithm |>\n<| a tags=javascript,string,algorithm\
    \ |>\nI believe the following algorithm is best suited for cases where there is\
    \ no overlap:\n\n<code>", "  const startIndex = string.indexOf(substring);\n \
    \ return startIndex === -1 ? 0 : string.length - startIndex;\n}\n", "  const len\
    \ = substring.length;\n  let cnt = 0;\n  for (let i = 0; i < string.length; ++i)\
    \ {\n    if (string.charAt(i) === substring[0]) {\n      if (i + 1 < len) {\n\
    \        if (string.charAt(i + 1) === substring[1]) {\n          ++cnt;\n    \
    \      i = i + 2;\n        } else if (string.charAt(i + 1) !== substring[1]) {\n\
    \          ++cnt;\n          i = i + 1;\n        } else {\n          ++cnt;\n\
    \          i = i + 2;\n        }\n      } else {\n        ++cnt;\n        i =\
    \ i + 1;\n      }\n    }\n  }\n  return cnt;\n}\n", "  if (string == null || substring.length\
    \ == 0)\n    return 0;\n\n  // Only use lowercase letters since they are more\
    \ common in English\n  let lowercase_string = string.toLowerCase();\n  let lowercase_substring\
    \ = substring.toLowerCase();\n\n  // If the substring ends in the substring (e.g.\
    \ \"aaaaaaaaaa\") then we only need to check\n  // the end of the string\n  if\
    \ (lowercase_substring.substring(lowercase_substring.length - substring.length)\
    \ == substring)\n    return string.length - substring.length;\n\n  return lowercase_string.match(lowercase_substring)\
    \ ? lowercase_string.match(lowercase_substring).length : 0;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.substring(i,\
    \ i + substring.length) === substring) {\n      count++;\n    }\n  }\n  return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < string.length &&\
    \ count < substring.length; ++i) {\n        const currentLetter = string[i];\n\
    \        const possibleLetter = substring[count];\n        if (possibleLetter\
    \ == currentLetter) {\n            ++count;\n        } else {\n            if\
    \ (currentLetter == possibleLetter) {\n                count++;\n            }\
    \ else {\n                break;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "\tlet count = 0;\n\tlet last_index = string.length - substring.length;\n\
    \twhile (last_index >= 0) {\n\t\tindex = string.indexOf(substring, last_index\
    \ + 1);\n\t\tif (index >= 0) {\n\t\t\tcount++;\n\t\t\tlast_index = index;\n\t\t\
    } else {\n\t\t\tlast_index = 0;\n\t\t}\n\t}\n\treturn count;\n}\n", "    if (string.length\
    \ <= substring.length) {\n        return 0;\n    }\n    let start = -1;\n    let\
    \ end = -1;\n    for (let i = 0; i < string.length; i++) {\n        if (string.charAt(i)\
    \ === substring.charAt(start)) {\n            start = i;\n        }\n        if\
    \ (string.charAt(i) === substring.charAt(end)) {\n            end = i;\n     \
    \   }\n    }\n    return (end - start + 1);\n}\n", "    const sub_length = substring.length;\n\
    \    let counter = 0;\n    let pos = 0;\n\n    while (pos < string.length) {\n\
    \        pos = string.indexOf(substring, pos + sub_length);\n\n        if (pos\
    \ === -1) {\n            counter++;\n        }\n        else {\n            counter\
    \ = -1;\n        }\n    }\n    return counter;\n}\n", "  const count = string\n\
    \    .split(substring)\n    .filter((_value, index) => {\n      if (index !==\
    \ 0) {\n        // the character before the first character should be ignored\n\
    \        return index > 0;\n      }\n      return true;\n    })\n    .length;\n\
    \  return count;\n}\n", "  // We need a more efficient way. Since we are doing\
    \ binary search we need to split string into substrings.\n  // Therefore, if the\
    \ length of substring is greater than string length,\n  // we only need to do\
    \ one comparison since substring can't be longer.\n  if (substring.length > string.length)\
    \ {\n    return substring.length < string.length ? substring.length : string.length;\n\
    \  }\n  let left = 0;\n  let right = string.length - substring.length;\n  while\
    \ (left < right) {\n    const middle = parseInt((left + right) / 2);\n    if (string.substring(middle,\
    \ middle + substring.length) === substring) {\n      return middle;\n    } else\
    \ if (string.substring(middle, middle + substring.length) > substring) {\n   \
    \   right = middle - 1;\n    } else {\n      left = middle + 1;\n    }\n  }\n\
    \  return substring.length < string.length ? substring.length : string.length;\n\
    }\n", "\tlet count = 0;\n\tfor (let i = 0; i < string.length; i++) {\n\t\tif (string.indexOf(substring,\
    \ i) !== -1) {\n\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn count;\n}\n", "  const\
    \ found = string.split(substring).length - 1;\n  return found >= 0 ? found : -1;\n\
    }\n", "\tif (string === substring) return 1;\n\n\tlet count = 0;\n\tlet lastIndex\
    \ = string.length;\n\n\tfor (let index = string.length - 1; index >= 0; index--)\
    \ {\n\t\tif (string.indexOf(substring, index) !== -1) count++;\n\t\tif (index\
    \ > 0 && string.charAt(index) === substring.charAt(index - 1)) count++;\n\t\t\
    if (index > 0 && string.charAt(index) === substring.charAt(index - 2)) count++;\n\
    \t\tif (index > 0 && string.charAt(index) === substring.charAt(index - 3)) count++;\n\
    \t\tif (index > 0 && string.charAt(index) === substring.charAt(index - 4)) count++;\n\
    \n\t\tif (index === 0 || string.charAt(index - 1) !== substring.charAt(index))\
    \ {\n\t\t\tif (index <= lastIndex) count++;\n\t\t\tif (index > 0 && string.charAt(index\
    \ - 1) === substring.charAt(index)) count++;\n\t\t\tif (index > 0 && string.charAt(index\
    \ - 2) === substring.charAt(index)) count++;\n\t\t\tif (index > 0 && string.charAt(index\
    \ - 3) === substring.charAt(index)) count++;\n\t\t\tif (index > 0 && string.charAt(index\
    \ - 4) === substring.charAt(index)) count++;\n\t\t}\n\n\t\tlastIndex = index;\n\
    \t}\n\n\treturn count;\n}\n", "  let count = 0;\n  let i: string|undefined;\n\
    \  let j: string|undefined;\n  let iEnd: string|undefined;\n  let jEnd: string|undefined;\n\
    \  let iStart = 0;\n  let jStart = 0;\n  let i = 0;\n  let j = 0;\n\n  while (i\
    \ < string.length && j < substring.length) {\n    iEnd = string.indexOf(substring,\
    \ iStart);\n    jEnd = substring.indexOf(string, jStart);\n\n    if (iEnd ===\
    \ -1) {\n      i = string.length;\n    } else {\n      count++;\n      iStart\
    \ = iEnd + 1;\n    }\n\n    if (jEnd === -1) {\n      j = substring.length;\n\
    \    } else {\n      count++;\n      jStart = jEnd + 1;\n    }\n\n    i++;\n \
    \   j++;\n  }\n\n  return count;\n}\n", "  let index = 0;\n  for (let i = 0; i\
    \ < string.length; i++) {\n    if (string.substring(index, i + substring.length)\
    \ === substring) {\n      index += substring.length;\n      i++;\n    }\n  }\n\
    \  return index;\n}\n", "    return string.length - substring.length + string.search(substring)\
    \ !== -1;\n}\n", "    if (substring === \"\" || string === \"\") {\n        return\
    \ 0;\n    }\n    let n = 0;\n    for (let i = 1; i < string.length; i++) {\n \
    \       if (string.indexOf(substring, i) !== -1) {\n            ++n;\n       \
    \ }\n    }\n    return n;\n}", "  let counter = 0;\n  let index = string.toLowerCase().indexOf(substring.toLowerCase());\n\
    \  while (index >= 0) {\n    counter += 1;\n    index = string.toLowerCase().indexOf(substring,\
    \ index + 1);\n  }\n  return counter;\n}\n", "    // Find the position of substring\
    \ in the string\n    const index = string.indexOf(substring)\n    if (index <\
    \ 0) return 0\n    // Get the length of the substring we are looking for\n   \
    \ let length: number = substring.length\n\n    // Get the length of the given\
    \ string, ignoring overlaps\n    length -= index + 1\n\n    // Repeat for each\
    \ letter of the given string\n    for (let i = 0; i < length; i++) {\n       \
    \ // Get the index of the next letter in the string\n        const nextIndex =\
    \ string.indexOf(substring, index + i + 1)\n        if (nextIndex < 0) return\
    \ 0\n        // Check if we can skip the substring in this iteration and move\
    \ to the next letter\n        // If there is no letter then we will return 0 at\
    \ this point\n        if (nextIndex + 1 >= string.length) return 0\n        //\
    \ If the letter matches the letter we are looking for, then the count is increased\n\
    \        if (string[i + nextIndex - 1] == substring[index]) ++index\n    }\n\n\
    \    return length\n}\n", "    const count = 0;\n    for (let i = string.length\
    \ - substring.length + 1; i > 0; i--) {\n        if (string.indexOf(substring,\
    \ i) !== -1) count++;\n    }\n    return count;\n}\n", "  string = string.split(substring).join(\"\
    \").toLowerCase();\n  return string.split(substring).length - 1;\n}\n", "  let\
    \ count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] ==\
    \ substring[0]) {\n      count++;\n      if (string[i] == substring[1]) {\n  \
    \      count++;\n      }\n    }\n  }\n  return count;\n}\n", "    return string\n\
    \        .toLowerCase()\n        .split(substring)\n        .length\n}\n", " \
    \ let count = 0;\n  for (let index = 0; index < string.length; index++) {\n  \
    \  if (string.includes(substring, index)) {\n      count++;\n    }\n  }\n  return\
    \ count;\n}\n", "\tlet count = 0;\n\tfor (let i = 0; i < string.length; i++) {\n\
    \t\tif (string.substr(i, substring.length) == substring) {\n\t\t\tcount++;\n\t\
    \t}\n\t}\n\treturn count;\n}\n", "  const result: number = 0;\n  const original_string:\
    \ string = string;\n  let current_index = 0;\n  while (current_index < string.length)\
    \ {\n    const found: boolean = string.toLowerCase().indexOf(substring.toLowerCase(),\
    \ current_index);\n    if (found === -1) {\n      current_index = string.length;\n\
    \      break;\n    }\n    current_index = found + substring.length;\n    ++result;\n\
    \  }\n  return result;\n}", "    let count = 0;\n    let string_index = 0;\n \
    \   let substring_index = 0;\n    let search_start = -1;\n    while (string_index\
    \ < string.length) {\n        if (string[string_index] === substring[substring_index])\
    \ {\n            if (search_start < 0) {\n                search_start = string_index;\n\
    \            }\n            count += 1;\n            search_start = -1;\n    \
    \    }\n        else {\n            if (search_start >= 0) {\n               \
    \ break;\n            }\n        }\n        string_index += 1;\n    }\n    return\
    \ count;\n}\n", "  // Count overlapping cases\n  let overlapping = 0;\n  for (let\
    \ i = 0; i < substring.length; i++) {\n    if (string.includes(substring[i]))\
    \ {\n      overlapping++;\n    }\n  }\n\n  return overlapping;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === substring[0])\
    \ count++;\n    else if (string[i] === substring[1]) count++;\n    if (string[i]\
    \ === substring[1]) count++;\n  }\n  return count;\n}\n", "  let count = 0;\n\
    \  for (let index = 0; index < string.length; index++) {\n    if (string.substr(index,\
    \ substring.length) == substring) {\n      count += 1;\n    }\n  }\n  return count;\n\
    }\n", "  return string.split(substring).length - 1;\n}\n", "  let count = 0;\n\
    \  let i = 0;\n  while (i < string.length) {\n    if (string.substr(i, substring.length)\
    \ === substring) {\n      count += 1;\n      i += substring.length;\n    } else\
    \ {\n      i += 1;\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n  for\
    \ (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)\
    \ !== -1) {\n      count += 1;\n    }\n  }\n  return count;\n}\n", "    let count\
    \ = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string.substr(i,\
    \ substring.length) === substring) {\n            count += 1;\n        }\n   \
    \ }\n    return count;\n}\n", "  const result = 0;\n  let index = 0;\n  while\
    \ (string[index] !== undefined) {\n    if (string.substring(0, index).indexOf(substring)\
    \ >= 0) {\n      result += 1;\n    }\n    index += 1;\n  }\n  return result;\n\
    }\n", "  let count = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    if\
    \ (string.indexOf(substring, i) === i) {\n      count++;\n    }\n  }\n  return\
    \ count;\n}\n", "    const n = substring.length;\n    let count = 0;\n    for\
    \ (let i = 0; i < string.length; i += n) {\n        if (string.substring(i, i\
    \ + n) === substring) {\n            count += 1;\n        }\n    }\n    return\
    \ count;\n}\n", "  // Find the first occurance of substring\n  let position =\
    \ 0;\n  while (string.length > position && string.charAt(position) != substring)\
    \ {\n    position++;\n  }\n  // If we found it, the substring is found at least\
    \ as many times\n  if (string.length > position) {\n    return position;\n  }\n\
    \  // Otherwise, it's not even a substring\n  return 0;\n}\n", "\tlet n = 0;\n\
    \twhile (true) {\n\t\tn = string.indexOf(substring, n + 1);\n\t\tif (n === -1)\
    \ break;\n\t\tn++;\n\t}\n\treturn n;\n}\n", "\tlet count = 0;\n\n\tstring.split(substring).map(s\
    \ => s += \"\").forEach((s) => {\n\t\tif (s.indexOf(substring) != -1) {\n\t\t\t\
    count++;\n\t\t}\n\t});\n\n\treturn count;\n}\n", "  if (string.length == 0)\n\
    \    return 0;\n\n  if (string.length == substring.length)\n    return string.length\
    \ - substring.length;\n\n  let count = 0;\n  for (let i = 0; i < string.length;\
    \ i++)\n    if (string.substr(0, i + substring.length) == substring)\n      count++;\n\
    \n  return count;\n}\n", "    let count = 0;\n    for (let index = 0; index <\
    \ string.length; index++) {\n        if (string.substr(index, substring.length)\
    \ === substring) {\n            count++;\n        }\n    }\n    return count;\n\
    }", "  return string.split(substring).length - 1;\n}\n", "    // Make sure we\
    \ aren't working with an empty string here\n    if (string.length < substring.length)\n\
    \        return 0;\n    // Make sure we aren't working with an string that doesn't\
    \ have any chars here\n    if (string.length <= substring.length)\n        return\
    \ string.length - substring.length;\n    // Make sure the substring isn't just\
    \ one letter\n    if (substring === substring.toLowerCase())\n        return substring.length;\n\
    \    // Special cases\n    if (string.includes(substring))\n        return 1;\n\
    \    if (substring === \"a\")\n        return 1;\n    if (substring === \"b\"\
    )\n        return 2;\n    if (substring === \"c\")\n        return 3;\n    if\
    \ (substring === \"d\")\n        return 4;\n    if (substring === \"e\")\n   \
    \     return 5;\n    if (substring === \"f\")\n        return 6;\n    if (substring\
    \ === \"g\")\n        return 7;\n    if (substring === \"h\")\n        return\
    \ 8;\n    if (substring === \"i\")\n        return 9;\n    if (substring === \"\
    j\")\n        return 10;\n    if (substring === \"k\")\n        return 11;\n \
    \   if (substring === \"l\")\n        return 12;\n    if (substring === \"m\"\
    )\n        return 13;\n    if (substring === \"n\")\n        return 14;\n    if\
    \ (substring === \"o\")\n        return 15;\n    if (substring === \"p\")\n  \
    \      return 16;\n    if (substring === \"q\")\n        return 17;\n    if (substring\
    \ === \"r\")\n        return 18;\n    if (substring === \"s\")\n        return\
    \ 19;\n    if (substring === \"t\")\n        return 20;\n    if (substring ===\
    \ \"u\")\n        return 21;\n    if (substring === \"v\")\n        return 22;\n\
    \    if (substring === \"w\")\n        return 23;\n    if (substring === \"x\"\
    )\n        return 24;\n    if (substring === \"y\")\n        return 25;\n    if\
    \ (substring === \"z\")\n        return 26;\n    // If we made it here, there's\
    \ a more serious issue...\n    // Throw an exception to let the caller handle\
    \ this case\n    throw new Error(`how_many_times: String ${string} doesn't contain\
    \ substring ${substring}!`);\n}\n", "  let found = 0;\n  for (let i = 0; i < string.length;\
    \ i++) {\n    if (string[i] === substring[0]) {\n      found++;\n      if (string[i]\
    \ === substring[1]) {\n        found++;\n      }\n    }\n  }\n  return found;\n\
    }\n", "\tlet count = 0;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst\
    \ pos = string.indexOf(substring, i);\n\n\t\tif (pos >= 0) {\n\t\t\ti++;\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n", "    let count = 0;\n    for\
    \ (const c of string) {\n        if (string.indexOf(substring) > -1) {\n     \
    \       ++count;\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < string.length; i++) {\n    if (string.includes(substring,\
    \ i)) {\n      count++;\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n\
    \  for (let index = 0; index < string.length; index++) {\n    if (string[index]\
    \ === substring[index]) count++;\n  }\n  return count;\n}\n\n<|/ file filename=util.ts\
    \ source=gitlab |>", "  if (string.length < substring.length || string.length\
    \ > substring.length) { return 0; }\n  let count = 0;\n  for (let i = 0; i < string.length;\
    \ i++) {\n    if (string.indexOf(substring, i) !== -1) {\n      count++;\n   \
    \ }\n  }\n  return count;\n}\n", "  let count = 0;\n  let i = string.indexOf(substring);\n\
    \  while (i > -1) {\n    count += string.substring(i, i + substring.length).split(substring).length\
    \ - 1;\n    i = string.indexOf(substring, i + substring.length);\n  }\n  return\
    \ count;\n}\n", "    let n = 0;\n    let pos = string.indexOf(substring);\n  \
    \  while (pos != -1) {\n        n++;\n        pos = string.indexOf(substring,\
    \ pos + 1);\n    }\n    return n;\n}\n", "  let count = 1;\n  for (let i = 0;\
    \ i < string.length; i++) {\n    if (string[i] == substring[0]) {\n      if (substring.indexOf(string.substring(i,\
    \ i + substring.length)) > -1) {\n        count++;\n      }\n    }\n  }\n  return\
    \ count;\n}\n", "    string = string.split('');\n    substring = substring.split('');\n\
    \    substring = substring.filter(char => string.indexOf(char) !== -1); //Filter\
    \ out substrings that don't exist in the original string\n    string = string.filter(char\
    \ => string.indexOf(char) !== -1); //Filter out strings that don't exist in the\
    \ original string\n    return string.length - substring.length;\n}\n", "  return\
    \ string.split(substring).length - 1;\n}\n", "    let result = 0;\n    for (let\
    \ i = 0; i < string.length && i < substring.length; i++)\n        if (string.indexOf(substring,\
    \ i) > -1)\n            result++;\n    return result;\n}\n", "  return count_substring(string,\
    \ substring);\n}\n", "  var count = 0;\n  for (var i = 0; i < string.length; i++)\
    \ {\n    if (string.indexOf(substring, i) > -1) count++;\n  }\n  return count;\n\
    }\n", "  const result = 0;\n\n  for (let i = 0; i < (string.length - substring.length);\
    \ i++) {\n    if (string.indexOf(substring, i) !== -1) {\n      result++;\n  \
    \  }\n  }\n\n  return result;\n}\n", "    let count = 0;\n    if (string.includes(substring))\
    \ {\n        count++;\n    }\n    if (string.includes(substring.toUpperCase()))\
    \ {\n        count++;\n    }\n    if (string.includes(substring.toLowerCase()))\
    \ {\n        count++;\n    }\n    return count;\n}", "  const sub_length = substring.length;\n\
    \  let count = 0;\n  const substring_pos = 0;\n  const string_cpy = string;\n\n\
    \  while (true) {\n    let idx = string_cpy.indexOf(substring, substring_pos);\n\
    \n    if (idx === -1) {\n      return count;\n    } else {\n      count += 1;\n\
    \      substring_pos = idx + sub_length;\n    }\n  }\n}\n\n<|/ file filename=utils.ts\
    \ source=gitlab ext=.ts |>", "\tlet matches = 0;\n\tlet offset = 0;\n\twhile (offset\
    \ < string.length && matches < substring.length) {\n\t\tconst substring_index\
    \ = string.indexOf(substring, offset);\n\t\tif (substring_index == -1) {\n\t\t\
    \tbreak;\n\t\t}\n\t\tmatches += substring.length;\n\t\toffset = substring_index\
    \ + substring.length;\n\t}\n\treturn matches;\n}\n", "  const count_occurrences\
    \ = (substring, string) => {\n    let count = 0;\n    if (string === substring)\
    \ {\n      return count;\n    }\n    for (let i = 0; i < string.length; i++) {\n\
    \      if (string.indexOf(string[i]) !== -1) {\n        count++;\n      }\n  \
    \  }\n    return count;\n  };\n\n  return count_occurrences(substring, string);\n\
    }\n", "  var count = 0;\n  for (var i = 0; i < string.length; i++) {\n    if (string.indexOf(substring,\
    \ i) === i) {\n      count += 1;\n    }\n  }\n  return count;\n}\n", "\tlet count\
    \ = 0;\n\tfor (let i = 0; i < string.length; i++) {\n\t\tif (string.includes(substring,\
    \ i)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nexport function get_time_string(time_seconds:\
    \ number): string {\n\tlet sec_num = (time_seconds / 60) + \"\";\n\tlet time =\
    \ Math.floor(sec_num);\n\tlet min = Math.floor(sec_num - (time * 60));\n\tlet\
    \ sec = Math.floor(sec_num - (time * 60) - (min * 60));\n\tlet time_string = \"\
    \";\n\n\tif (time < 10) {\n\t\ttime_string = \"0\" + time;\n\t} else if (min <\
    \ 10) {\n\t\ttime_string = min + \":\" + \"0\" + sec;\n\t} else {\n\t\ttime_string\
    \ = min + \":\" + sec;\n\t}\n\n\treturn time_string;\n}\n\nexport function get_time_string_local(time_seconds:\
    \ number): string {\n\tlet sec_num = (time_seconds / 60) + \"\";\n\tlet time =\
    \ Math.floor(sec_num);\n\tlet min = Math.floor(sec_num - (time * 60));\n\tlet\
    \ sec = Math.floor(sec_num - (time * 60) - (min * 60));\n\tlet time_string = \"\
    \";\n\n\tif (time < 10) {\n\t\ttime_string = \"0\" + time;\n\t} else if (min <\
    \ 10) {\n\t\ttime_string = min + \":\" + \"0\" + sec;\n\t} else {\n\t\ttime_string\
    \ = min + \":\" + sec;\n\t}\n\n\treturn time_string;\n}\n\nexport function get_time_string_seconds(time_seconds:\
    \ number): string {\n\tlet sec_num = (time_seconds / 60) + \"\";\n\tlet time =\
    \ Math.floor(sec_num);\n\tlet min = Math.floor(sec_num - (time * 60));\n\tlet\
    \ sec = Math.floor(sec_num - (time * 60) - (min * 60));\n\tlet time_string = \"\
    \";\n\n\tif (time < 10) {\n\t\ttime_string = \"0\" + time;\n\t} else if (min <\
    \ 10) {\n\t\ttime_string = min + \":\" + \"0\" + sec;\n\t} else {\n\t\ttime_string\
    \ = min + \":\" + sec;\n\t}\n\n\treturn time_string;\n}\n\nexport function get_time_string_milliseconds(time_seconds:\
    \ number): string {\n\tlet sec_num = (time_seconds / 1000) + \"\";\n\tlet time\
    \ = Math.floor(sec_num);\n\tlet min = Math.floor(sec_num - (time * 1000));\n\t\
    let sec = Math.floor(sec_num - (time * 1000) - (min * 1000));\n\tlet time_string\
    \ = \"\";\n\n\tif (time < 10) {\n\t\ttime_string = \"0\" + time;\n\t} else if\
    \ (min < 10) {\n\t\ttime_string = min + \":\" + \"0\" + sec;\n\t} else {\n\t\t\
    time_string = min + \":\" + ", "    if (substring === substring.toLowerCase())\
    \ {\n        return 1;\n    } else if (substring === substring.toUpperCase())\
    \ {\n        return 1;\n    } else {\n        var found: number = string.search(substring);\n\
    \        return found != -1 ? found / substring.length : 0;\n    }\n}\n", "  \
    \  let count = 0\n    let start_pos = 0\n    let end_pos = string.length\n\n \
    \   while (start_pos < end_pos) {\n        start_pos = string.indexOf(substring,\
    \ start_pos)\n        if (start_pos === -1) {\n            break\n        }\n\n\
    \        start_pos += substring.length\n\n        end_pos = string.indexOf(substring,\
    \ start_pos)\n        count += end_pos - start_pos\n    }\n\n    return count\n\
    }\n", "\tif (string === substring) return 0;\n\tconst substring_length = substring.length;\n\
    \tconst string_size = string.length;\n\tlet counter = 0;\n\tlet i = 0;\n\twhile\
    \ (i < string_size) {\n\t\twhile (i < string_size && string.charAt(i) === substring.charAt(i))\
    \ {\n\t\t\tcounter++;\n\t\t\ti++;\n\t\t}\n\t\ti++;\n\t}\n\treturn counter;\n}\n",
  "\tif (string == null || string === '') {\n\t\treturn 0;\n\t}\n\n\tlet count = 0;\n\
    \tlet start_idx = 0;\n\tfor (let idx = 0, len = string.length; idx < len; idx++)\
    \ {\n\t\tlet c = string.charCodeAt(idx);\n\t\tlet substr_len = substring.length;\n\
    \n\t\tif (c === substring.charCodeAt(0)) {\n\t\t\tcount += 1;\n\t\t} else {\n\t\
    \t\tif (start_idx >= idx) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\n\t\t\tstart_idx =\
    \ idx;\n\t\t}\n\t}\n\n\treturn count;\n}\n", "    const index = string.indexOf(substring);\n\
    \    if (index == -1) {\n        return 0;\n    }\n    const length = substring.length;\n\
    \    return substring.length + how_many_times(string.substr(index + 1), substring);\n\
    }\n", "  return string\n    .split(substring)\n    .reduce((acc, curr) => {\n\
    \      return acc + curr.length;\n    }, 0);\n}\n", "  if (string == null || substring\
    \ == null) {\n    return 0;\n  }\n\n  const length = string.length;\n  if (length\
    \ == 0) {\n    return 0;\n  }\n\n  const startIndex = string.toLowerCase().indexOf(substring.toLowerCase(),\
    \ 0);\n  if (startIndex < 0) {\n    return length;\n  }\n  if (startIndex >= length)\
    \ {\n    return 0;\n  }\n\n  if (length == 1) {\n    return 1;\n  }\n\n  const\
    \ endIndex = startIndex + substring.length;\n  if (endIndex >= length) {\n   \
    \ return length;\n  }\n  return endIndex - startIndex;\n}", "  if (string.length\
    \ == 0) return 0;\n\n  const substring_index: string[] = string.indexOf(substring);\n\
    \  if (substring_index == -1) return 0;\n\n  return (string.length - substring_index)\
    \ * string.length /\n    string.length - substring_index;\n}\n", "  let count\
    \ = 0;\n  const substr_count = string.toLowerCase().split(substring.toLowerCase())\n\
    \  for (const s of substr_count) {\n    if (s.length === 0) {\n      break\n \
    \   }\n    if (s.indexOf(substring) !== -1) {\n      count += 1;\n    }\n  }\n\
    \  return count;\n}\n", "  const substr_count = string.split(substring).length\
    \ - 1;\n  return substr_count > 0 ? substr_count : 0;\n}\n", "    // https://stackoverflow.com/questions/641407/how-do-i-count-the-number-of-occurrences-of-a-substring-within-a-string\n\
    \    const count = string.split(substring).length - 1;\n    return count > 0 ?\
    \ count : 0;\n}\n", "  let total = 0;\n\n  for (let index = 0; index < string.length;\
    \ index++) {\n    if (string.indexOf(substring, index) !== -1) {\n      total++;\n\
    \    }\n\n    if (string.charAt(index) !== substring.charAt(0)) {\n      total++;\n\
    \    }\n  }\n\n  return total;\n}\n", "    const substring_length = substring.length;\n\
    \n    for (let i = 0; i < string.length; i++) {\n        if (string.substr(i,\
    \ substring_length) === substring) {\n            return i;\n        }\n    }\n\
    \n    return -1;\n}\n", "  const times_substring_occurred = string.split(substring).length;\n\
    \  if (times_substring_occurred) return times_substring_occurred;\n  else return\
    \ 0;\n}", "    if (string.length <= substring.length) {\n        return 0;\n \
    \   }\n\n    let overlapping_count = 0;\n\n    for (let i = 0; i < substring.length;\
    \ i++) {\n        if (string.includes(substring[i], i)) {\n            overlapping_count++;\n\
    \        }\n    }\n\n    return overlapping_count;\n}\n", "  let count = 0;\n\
    \  let pos = 0;\n\n  while (pos <= string.length - substring.length) {\n    count++;\n\
    \    if (string.indexOf(substring, pos) !== pos) {\n      break;\n    }\n    pos\
    \ += substring.length;\n  }\n\n  return count;\n}", "    let count = 0;\n    let\
    \ i = 0;\n    while (i < string.length && string.indexOf(substring, i) >= 0) {\n\
    \        count = count + 1;\n        i = string.indexOf(substring, i + 1);\n \
    \   }\n    return count;\n}\n", "  substring += ''; // Make substring empty to\
    \ avoid empty arrays.\n  let count = 0;\n  for (let index = 0; index < string.length;\
    \ index++) {\n    if (string[index] === substring[0]) {\n      count += 1;\n \
    \     for (let i = 1; i < substring.length; i++) {\n        if (string[index +\
    \ i] !== substring[i]) {\n          count++;\n        }\n      }\n    }\n  }\n\
    \  return count;\n}\n", "    const count_of_times: number[] = [];\n    const start_pos\
    \ = string.toLowerCase().indexOf(substring.toLowerCase());\n    if (start_pos\
    \ != -1) {\n        // Start at \"a\" and stop at the \"a\" after \"aaa\" and\
    \ so on\n        const next_start_pos = string.indexOf(substring, start_pos +\
    \ substring.length);\n        count_of_times.push(next_start_pos - start_pos);\n\
    \        count_of_times.push(next_start_pos);\n    }\n    return count_of_times[0];\n\
    }\n", "  // Step 1. Iterate through all cases in the string and substring.\n \
    \ // Step 2. Keep a count of the times substring has been found so far.\n  //\
    \ Step 3. Return substring count when count > 0.\n  let count = 0;\n  for (let\
    \ i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length;\
    \ j++) {\n      if (string[i] === substring[j]) {\n        count++;\n        break;\n\
    \      }\n    }\n  }\n  return count;\n}\n", "    // Create a dictionary of how\
    \ many times each substring appears in the string. \n    // If it doesn't appear\
    \ in the string, then the count will always be zero.\n    var count_hash = {};\n\
    \    // Create a dictionary to keep track of the total times each substring appears\
    \ in the string. \n    // This will allow us to know how many times a substring\
    \ appears in the string.\n    var total_count = {};\n    // Create a variable\
    \ to keep track of the longest substring we've seen.\n    var longest = '';\n\
    \    // Create an array to keep track of the total times we've seen each character.\n\
    \    var char_counts = [];\n    // Loop through every character in the original\
    \ string \n    for (var i = 0; i < string.length; i++) {\n        // Get the current\
    \ character.\n        var current_char = string.charAt(i);\n        // Increment\
    \ the count for the current character in the string.\n        count_hash[current_char]\
    \ = count_hash[current_char] ? count_hash[current_char] + 1 : 1;\n        // Update\
    \ the total count for the current character in the string.\n        total_count[current_char]\
    \ = total_count[current_char] ? total_count[current_char] + 1 : 1;\n        //\
    \ Keep track of the longest substring\n        if (current_char.length > longest.length){\n\
    \            longest = current_char;\n        }\n        // Keep track of the\
    \ character counts \n        if (count_hash[current_char]) {\n            char_counts.push(count_hash[current_char]);\n\
    \        }\n    }\n    // Return the total count for that substring\n    return\
    \ total_count[substring] || 0;\n}\n", "  let count_string = 0\n  const count_substring\
    \ = 0\n  while (count_string < string.length && count_substring < substring.length)\
    \ {\n    if (string[count_string] === substring[count_substring]) {\n      count_string\
    \ += 1\n      count_substring += 1\n    } else {\n      count_substring = 0\n\
    \      count_string += 1\n    }\n  }\n  return count_string\n}\n", "\tlet count\
    \ = 0;\n\tlet index = 0;\n\tfor (let i = 0, len = string.length; i < len; i +=\
    \ 1) {\n\t\tif (i === len - 1 || string.charAt(i) !== substring.charAt(index))\
    \ {\n\t\t\tcount += 1;\n\t\t} else {\n\t\t\tindex += 1;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n", "  const num_times = 0;\n  for (let i = 0; i <= string.length;\
    \ i += substring.length) {\n    if (string.slice(i, i + substring.length) == substring)\
    \ {\n      num_times++;\n    }\n  }\n  return num_times;\n}\n", "  let n = 1;\n\
    \  const str_list = string.split(substring);\n  for (let i = 0; i < str_list.length;\
    \ i++) {\n    if (str_list[i] !== substring) {\n      n++;\n    }\n  }\n  return\
    \ n;\n}\n", "  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n \
    \   if (string.includes(substring, i + 1)) {\n      count++;\n    }\n  }\n  return\
    \ count;\n}\n", "    string += \"\";\n    substring += \"\";\n    let count =\
    \ 0;\n\n    let len = string.length;\n    let pos = 0;\n\n    while (pos < len)\
    \ {\n        if (string.charAt(pos) == substring.charAt(0)) {\n            count\
    \ += 1;\n\n            pos += 1;\n        }\n        else if (string.charAt(pos)\
    \ == substring.charAt(1)) {\n            count += 1;\n\n            pos += 1;\n\
    \        }\n        else {\n            pos += 1;\n        }\n    }\n\n    return\
    \ count;\n}\n", "    const len = string.length;\n    const count_so_far = 0;\n\
    \n    for (let i = 0; i < len; i++) {\n        if (string.substr(i, substring.length)\
    \ === substring) {\n            count_so_far += 1;\n        }\n    }\n\n    return\
    \ count_so_far;\n}\n", "  let count = 0;\n  for (let i = 0; i < string.length;\
    \ i++) {\n    if (string.indexOf(substring, i) !== -1) {\n      count++;\n   \
    \ }\n  }\n  return count;\n}\n", "\tlet times = 0\n\n\tfor (let i = 0; i <= string.length\
    \ - substring.length; i++) {\n\t\tif (string.substring(0, substring.length + i)\
    \ === substring) {\n\t\t\ttimes += 1\n\t\t}\n\t}\n\n\treturn times\n}\n", "  let\
    \ count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.includes(substring,\
    \ i, i + substring.length)) {\n      count++;\n      i += substring.length;\n\
    \    }\n  }\n  return count;\n}\n", "  let count = 0;\n  let index = string.indexOf(substring);\n\
    \  while (index != -1) {\n    count++;\n    index = string.indexOf(substring,\
    \ index + 1);\n  }\n  return count;\n}\n", "    let count = 0;\n    let position\
    \ = 0;\n    while (position < string.length) {\n        let positionOfSubstring\
    \ = string.indexOf(substring, position);\n        if (positionOfSubstring >= 0)\
    \ {\n            count += positionOfSubstring;\n            position = positionOfSubstring\
    \ + substring.length;\n        } else {\n            position++;\n        }\n\
    \    }\n    return count;\n}\n", "  const substrings = substring.split('');\n\
    \  let count = 0;\n  for (let i = 0; i <= string.length; ++i) {\n    const index\
    \ = string.indexOf(substrings[0], i);\n    if (index >= 0) {\n      count += substrings.length\
    \ - 1;\n      i = index + substrings[0].length;\n    } else {\n      count++;\n\
    \    }\n  }\n  return count;\n}\n", "    let count = 0;\n    for (let i = 0; i\
    \ < string.length; ++i) {\n        if (string.charAt(i) === substring.charAt(i))\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\n", "  let num_times\
    \ = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring,\
    \ i) !== -1) {\n      num_times++;\n    }\n  }\n  return num_times;\n}", "\tif\
    \ (string.length === 0) {\n\t\treturn 0;\n\t}\n\tlet startIndex: number = string.length;\n\
    \tlet index = 0;\n\tlet count = 0;\n\tlet done = false;\n\tlet currentChar: number\
    \ = null;\n\tlet prevChar: number = null;\n\tlet nextChar: number = null;\n\t\
    do {\n\t\tprevChar = currentChar;\n\t\tcurrentChar = string.charCodeAt(index++);\n\
    \t\tnextChar = string.charCodeAt(index++);\n\t\tcount++;\n\t\tdone = currentChar\
    \ === substring.charCodeAt(0) || nextChar === substring.charCodeAt(0);\n\t\tif\
    \ (done) {\n\t\t\treturn count;\n\t\t}\n\t} while (!done);\n\treturn count;\n\
    }\n", "  // Count the number of times substring appears in string\n  let count\
    \ = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.includes(substring))\
    \ {\n      count++;\n    }\n  }\n  return count;\n}\n", "\tif (string == null\
    \ || substring == null) {\n\t\tthrow Error(\"Cannot calculate how many times given\
    \ substring occurs in empty string and substring\");\n\t}\n\tif (string.length\
    \ < substring.length) {\n\t\treturn 0;\n\t}\n\tlet counter: number = 0;\n\tfor\
    \ (let i = 0; i < string.length; i++) {\n\t\tlet index: string = string.substring(i,\
    \ i + substring.length);\n\t\tif (index === substring) {\n\t\t\tcounter++;\n\t\
    \t}\n\t}\n\treturn counter;\n}\n", "    string = string.split('');\n    substring\
    \ = substring.split('');\n\n    let result = 0;\n    for(let i = 0; i < string.length;\
    \ i++){\n        if(string[i] === substring[0]){\n            result ++;\n   \
    \         for(let j = 0; j < substring.length; j++){\n                if(string[i\
    \ + j] === substring[j]){\n                    result += 1;\n                }\n\
    \            }\n        }\n    }\n\n    return result;\n}\n", "  let matches =\
    \ 0;\n  for (let i = 0; i < string.length; i++) {\n    matches +=\n      substring.includes(string[i])\
    \ ? string.split(string[i]).length - 1 : 0;\n  }\n\n  return matches;\n}\n", " \
    \ let count = 0;\n  let start_pos = 0;\n  while (true) {\n    start_pos = string.indexOf(substring,\
    \ start_pos);\n    if (start_pos < 0) break;\n    count += 1;\n    start_pos +=\
    \ substring.length;\n  }\n  return count;\n}\n", "  let count = 0;\n  for(let\
    \ i = 0; i < string.length; i++){\n    if(string.indexOf(substring, i) == i){\n\
    \      count++;\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n    let\
    \ pos = 0;\n    while (true) {\n        pos = string.indexOf(substring, pos);\n\
    \        if (pos == -1) {\n            return count;\n        }\n        count++;\n\
    \        pos++;\n    }\n}", "  return string.split(substring).length - 1;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring,\
    \ i) !== -1) {\n      count++;\n    }\n  }\n  return count;\n}", "  // Find how\
    \ many times substring can be found from string\n  const count = string.split(substring).length\
    \ - 1\n\n  // If substring is not found, return 0\n  if (count < 0) return 0\n\
    \n  return count\n}\n", "  const count = 0;\n  let i = -1;\n  while ((i = string.indexOf(substring,\
    \ i + 1)) !== -1) {\n    count++;\n  }\n  return count;\n}\n", "  let count =\
    \ 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === substring[0])\
    \ {\n      count += 1;\n    }\n    if (string[i] === substring[1]) {\n      count\
    \ += 1;\n    }\n    if (string[i] === substring[2]) {\n      count += 1;\n   \
    \ }\n  }\n  return count;\n}", "  let counter = 0;\n  for (let i = 0; i < string.length;\
    \ i++) {\n    if (string[i] === substring[0]) {\n      counter += substring.length;\
    \ // Only first character matches.\n      for (let j = 0; j < substring.length;\
    \ j++) {\n        if (string[i + j] === substring[j]) {\n          counter +=\
    \ 1;\n        } else {\n          break;\n        }\n      }\n    } else {\n \
    \     break;\n    }\n  }\n  return counter;\n}\n", "  // Step 1: Find how many\
    \ times the given substring occurred.\n  let count = 0;\n  for (let i = 0; i <\
    \ string.length; i++) {\n    if (string.indexOf(substring, i) !== -1) {\n    \
    \  count++;\n      i += substring.length;\n    }\n  }\n  return count;\n}\n",
  "    if (substring === '') {\n        // No substring at all\n        return 0;\n\
    \    }\n    const substring_index: number = string.indexOf(substring);\n    if\
    \ (substring_index < 0) {\n        // No substring at all\n        return 0;\n\
    \    }\n    const substring_index2: number = string.indexOf(substring, substring_index\
    \ + 1);\n    if (substring_index2 < 0) {\n        // No substring at all\n   \
    \     return 0;\n    }\n    const result = substring_index2 - substring_index;\n\
    \    return result === 0 ? 0 : result > 0 ? 1 : -1;\n}\n", "  let counter = 0;\n\
    \n  for (let i = 0; i < string.length; ++i) {\n    const char = string.charCodeAt(i);\n\
    \    const char_code = string.charCodeAt(substring);\n\n    if (char === char_code)\
    \ {\n      counter++;\n    } else {\n      // If char != char_code, counter will\
    \ always be 0\n      counter = 0;\n    }\n\n    if (counter > 0) {\n      break;\n\
    \    }\n  }\n\n  return counter;\n}\n", "  let pos = 0;\n  let count_string =\
    \ 0;\n\n  for (let i = 0, len = string.length; i < len; i++) {\n    if (string.substring(pos,\
    \ pos + substring.length) === substring) {\n      count_string += 1;\n    }\n\
    \    pos += 1;\n  }\n  return count_string;\n}\n\n<|/ file ext=.ts source=github\
    \ |>\nexport const getRandomNumber = (max: number): number => {\n  return Math.floor(Math.random()\
    \ * max);\n};\n\nexport const getRandomInt = (min: number, max: number): number\
    \ => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n", " \
    \   let count = 0;\n    const min_string_length = Math.min(string.length, substring.length);\n\
    \    const start_index = string.indexOf(substring);\n    if (start_index >= 0)\
    \ {\n        let end_index = string.indexOf(substring, start_index + min_string_length);\n\
    \        while (end_index < 0) {\n            count += 1;\n            end_index\
    \ = string.indexOf(substring, end_index + 1);\n        }\n    }\n    return count;\n\
    }\n", "  const times = string.split(substring).length - 1;\n  return times <=\
    \ 0 ? 0 : times;\n}", "  string = _.toString(string);\n  substring = _.toString(substring);\n\
    \  if (string === substring) return 0;\n  if (string === \"a\") {\n    return\
    \ string.length;\n  }\n  const n = string.length;\n  const substring_length =\
    \ substring.length;\n  let counter = 0;\n  for (let i = 0; i < n; i++) {\n   \
    \ if (string[i] === substring[counter]) {\n      if (string[i + substring_length]\
    \ === substring[counter + substring_length]) {\n        counter++;\n      }\n\
    \    }\n  }\n  return counter;\n}\n", "  let count = 0;\n  for (let i = 0; i <\
    \ string.length; i++) {\n    if (string[i] === substring[0]) {\n      count++;\n\
    \    }\n    if (string[i] === substring[1]) {\n      count++;\n    }\n  }\n  return\
    \ count;\n}\n", "\tlet count = 0;\n\tlet i = 0;\n\tlet j = 0;\n\tlet k = string.length\
    \ - substring.length;\n\twhile (i < string.length && j < substring.length) {\n\
    \t\tcount += string.substr(i, substring.length) === substring.substr(j, substring.length);\n\
    \t\ti += substring.length;\n\t\tj += substring.length;\n\t}\n\treturn count;\n\
    }\n", "  if (substring.length <= 0) {\n    return 0;\n  }\n  const start_index\
    \ = string.toLowerCase().indexOf(substring.toLowerCase());\n  if (start_index\
    \ < 0) {\n    return 0;\n  }\n  const end_index = start_index + substring.length;\n\
    \  const count_within_range = end_index - start_index;\n  if (count_within_range\
    \ > 0) {\n    return count_within_range;\n  } else {\n    return 1;\n  }\n}\n",
  "  const count = 0;\n  for (let i = 0; i < string.length; ++i) {\n    const position\
    \ = string.indexOf(substring, i);\n    if (position !== -1) {\n      ++count;\n\
    \      i = position;\n    } else {\n      ++count;\n    }\n  }\n  return count;\n\
    }\n", "\tlet count = 0;\n\tlet offset = 0;\n\twhile (offset < string.length) {\n\
    \t\tconst index = string.indexOf(substring, offset);\n\t\tif (index === -1) {\n\
    \t\t\tbreak;\n\t\t}\n\t\tif (count < index) {\n\t\t\tcount++;\n\t\t}\n\t\toffset\
    \ = index + substring.length;\n\t}\n\treturn count;\n}\n", "  let count = 0;\n\
    \  let index = -1;\n  while (index != -1) {\n    index = string.indexOf(substring,\
    \ index + 1);\n    if (index != -1) {\n      count++;\n    }\n  }\n  return count;\n\
    }\n", "    string = string.split('');\n    substring = substring.split('');\n\
    \    let num_times = 0;\n    for(let i = 0; i < string.length; i++) {\n      \
    \  for(let j = 0; j < substring.length; j++) {\n            if(string[i] == substring[j])\
    \ {\n                string[i] = '';\n                num_times++;\n         \
    \   }\n        }\n    }\n    return num_times;\n}\n", "  const times = string.match(new\
    \ RegExp(substring, \"g\")) || [].length || 0\n  return Math.floor(times)\n}\n",
  "  return string.split(substring).length - 1;\n}\n", "  let count = 0;\n\n  for\
    \ (let i = 0; i < string.length; i++)\n    if (string.substr(i, substring.length)\
    \ === substring)\n      count++;\n\n  return count;\n}\n", "  return string.split(substring).length\
    \ - 1;\n}\n", "  return string.split(substring).length - 1;\n}\n", "    return\
    \ string.toLowerCase().split(substring).length - 1;\n}\n", "    let n = 0;\n \
    \   for (let i = 0, len = string.length; i < len; i++) {\n        if (string.indexOf(substring,\
    \ i) > -1) {\n            n++;\n        }\n    }\n    return n;\n}\n", "    const\
    \ length = string.length;\n    if (string.length == 0) return 0;\n    const substring_length\
    \ = substring.length;\n    if (substring_length == 0) return 0;\n\n    const count\
    \ = 0;\n    let index = 0;\n    let start = 0;\n    let end = 0;\n    do {\n \
    \       start = string.indexOf(substring, start);\n        end = start + substring_length;\n\
    \        if (start == -1 || end == -1 || end > length) break;\n        ++count;\n\
    \        ++start;\n    } while (++index < substring_length);\n    return count;\n\
    }", "  let count = 0;\n  const substring_length = substring.length;\n  const string_length\
    \ = string.length;\n  const strings = string.split(substring);\n  for (let i =\
    \ 0; i < strings.length; i++) {\n    const sub_str_length = strings[i].length;\n\
    \    if (sub_str_length > 0 && sub_str_length >= substring_length) count++;\n\
    \  }\n  return count;\n}\n", "  let count = 0;\n  string += substring;\n  const\
    \ length = string.length;\n  for (let i = 0; i < length; i++) {\n    if (string.charAt(i)\
    \ === substring.charAt(0)) {\n      count++;\n    }\n  }\n  return count;\n}\n",
  "    let index = 0;\n    let count = 0;\n    while (string[index] === substring[index])\
    \ {\n        index++;\n        count++;\n        if (index === substring.length)\
    \ {\n            break;\n        }\n    }\n    return count;\n}\n", "  let count\
    \ = 0;\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (string.substring(0,\
    \ i).indexOf(substring) !== -1) {\n      count++;\n      string = string.substring(0,\
    \ i);\n    }\n  }\n  return count;\n}\n", "  const times = new Map<string, number>();\n\
    \  const length = string.length;\n  const substringLength = substring.length;\n\
    \  const found = times.get(substring);\n\n  // If substring was never encountered,\
    \ initialize count\n  if (found === undefined) {\n    times.set(substring, 0);\n\
    \  }\n\n  // If substring was encountered before, increment count\n  if (found\
    \ !== undefined) {\n    times.set(substring, found + 1);\n  }\n\n  // If substring\
    \ was encountered before, decrement count\n  if (found !== undefined) {\n    times.set(substring,\
    \ found - 1);\n  }\n\n  // If substring was never encountered, return count\n\
    \  if (found === undefined) {\n    return times.get(substring);\n  }\n\n  // Else\
    \ return max found plus 1\n  return Math.max(...times.entries()) * substringLength;\n\
    }\n", "\tlet result = 0;\n\tlet pos = 0;\n\tlet length = string.length;\n\tlet\
    \ sublength = substring.length;\n\n\twhile (pos < length) {\n\t\tlet index = string.indexOf(substring,\
    \ pos);\n\t\tif (index != -1) {\n\t\t\tresult = 1 + result;\n\t\t\tpos = index\
    \ + sublength;\n\t\t} else {\n\t\t\tpos = length + 1;\n\t\t}\n\t}\n\n\treturn\
    \ result;\n}\n", "  let i = 0;\n  let count = 0;\n\n  while (i < string.length\
    \ && i < substring.length) {\n    if (string[i] === substring[i]) count++;\n \
    \   i++;\n  }\n\n  return count;\n}\n", "  let result = 0;\n  let index = 0;\n\
    \  while (index < string.length) {\n    const char: string = string.charAt(index);\n\
    \    if (index === substring.length || char === substring[index]) {\n      index++;\n\
    \    } else {\n      result++;\n    }\n    index++;\n  }\n  return result;\n}\n",
  "\treturn string == \"\" ? 0 : string.toLowerCase().split(substring).length - string.toLowerCase().split(substring).join(substring).length;\n\
    }\n", "\tlet count = 0;\n\tfor (let index = 0; index < string.length; index++)\
    \ {\n\t\tif (string.includes(substring, index)) {\n\t\t\tcount += 1;\n\t\t}\n\t\
    }\n\treturn count;\n}\n", "    string = string.toLowerCase();\n    substring =\
    \ substring.toLowerCase();\n    if (string.length <= substring.length) return\
    \ 0;\n    let substring_start = string.indexOf(substring, 0);\n    let substring_end\
    \ = substring_start + substring.length;\n    let substring_string_start = string.indexOf(string);\n\
    \    let substring_string_end = substring_string_start + string.length;\n    console.log(\"\
    substring start \" + substring_start + \" substring end \" + substring_end + \"\
    \ string start \" + substring_string_start + \" string end \" + substring_string_end);\n\
    \    return substring_string_end - substring_start - 1;\n}\n", "    var count\
    \ = 0;\n    for (var i = 0; i <= string.length - substring.length; i++) {\n  \
    \      if (string.indexOf(substring, i) > -1) {\n            count++;\n      \
    \      i += substring.length;\n        }\n    }\n    return count;\n}\n", "  \
    \  if (string.length >= substring.length) {\n        let i = -1;\n        let\
    \ j = string.length;\n        while (++i < j) {\n            let k = string.indexOf(substring,\
    \ i);\n            if (k < 0)\n                break;\n            i += substring.length\
    \ - k;\n        }\n        return j - i;\n    }\n    return 0;\n}\n", "  let count\
    \ = 0\n  let start = 0\n  let end = string.length\n  while (start < end) {\n \
    \   const substr_length = substring.length\n    const substr = string.substring(start,\
    \ end)\n    if (substr === substring) {\n      count++\n      start = substr_length\n\
    \    } else {\n      start = start + 1\n    }\n  }\n  return count\n}\n", "\t\
    let count = 0;\n\tlet i = 0;\n\tlet j = 0;\n\twhile (i < string.length && j <\
    \ substring.length) //Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n\t{\n\t\tif (string[i] === substring[j])\
    \ {\n\t\t\tcount += 1;\n\t\t\ti += 1;\n\t\t\tj += 1;\n\t\t}\n\t\telse if (string[i]\
    \ < substring[j]) {\n\t\t\ti += 1;\n\t\t}\n\t\telse {\n\t\t\tj += 1;\n\t\t}\n\t\
    }\n\treturn count;\n}\n", "  let substring_length = substring.length;\n  let count\
    \ = 0;\n  let i = -1;\n  while (++i < string.length) {\n    count += string.substr(i,\
    \ substring_length).indexOf(substring);\n  }\n  return count;\n}\n", "  let count\
    \ = 0;\n  string.split('').forEach((character) => {\n    if (character == substring)\
    \ {\n      count++;\n    }\n  });\n  return count;\n}\n", "    if (string.length\
    \ == 0 || substring.length == 0) {\n        return 0;\n    }\n    let count =\
    \ 0;\n    for (let i = 0; i < string.length; ++i) {\n        if (string.substring(i,\
    \ i + substring.length) == substring) {\n            ++count;\n        }\n   \
    \ }\n    return count;\n}\n", "  const found = string.split(substring).length\
    \ - 1;\n  // console.log('found', found, string, 'substring', substring)\n  return\
    \ found;\n}\n", "    let counter = 0;\n    for (let i = 0; i < string.length;\
    \ i++) {\n        if (string.indexOf(substring, i) > -1)\n            counter++;\n\
    \    }\n    return counter;\n}\n", "  let count = 0;\n  for (let i = 0; i < string.length;\
    \ i++) {\n    if (string.indexOf(substring, i) !== -1) {\n      count += 1;\n\
    \    }\n  }\n  return count;\n}\n", "    let foundCount = 0;\n\n    for (let i\
    \ = 0; i < string.length; i++) {\n        if (string[i] === substring[0]) {\n\
    \            foundCount++;\n            if (foundCount > 1) {\n              \
    \  return i;\n            }\n        }\n    }\n\n    return foundCount;\n}\n",
  "  // If the string has less characters, return 0\n  if(string.length <= substring.length)\
    \ return 0;\n  // If the substring's length is the same, return 1\n  if(substring.length\
    \ == string.length) return 1;\n\n  // If there is a match, check the first character\
    \ - if it is a match, then check every character\n  // If the first character\
    \ is a match, go through the string and see if any other characters match\n  //\
    \ If the first character is not a match, return 0\n  for(let i = 0; i < string.length;\
    \ i++){\n    if(string.charAt(i) == substring.charAt(0)){\n      let current_index\
    \ = i;\n      for(let j = 1; j < substring.length; j++){\n        if(string.charAt(current_index)\
    \ == substring.charAt(j)){\n          current_index++;\n        }\n      }\n \
    \     return i - current_index;\n    }\n  }\n  return 0;\n}", "  let count = 0;\n\
    \  const n = string.length;\n  const m = substring.length;\n  while (n-- > 0 &&\
    \ substring-- > 0) {\n    if (string[n] === substring[n]) count++;\n  }\n  return\
    \ count;\n}\n", "  let count_overlap = 0;\n  const len = string.length;\n  const\
    \ times_found = new Array(substring.length + 1);\n  times_found[0] = times_found[substring.length]\
    \ = 1;\n  for (let i = 1; i <= substring.length; i++) {\n    const start_index\
    \ = string.lastIndexOf(substring, i - 1);\n    if (start_index === -1) throw new\
    \ Error(\n      `The substring ${substring} cannot be found from the string ${string}.`);\n\
    \    const end_index = string.indexOf(substring, start_index);\n    if (end_index\
    \ === -1) throw new Error(\n      `The substring ${substring} cannot be found\
    \ from the string ${string}.`);\n    times_found[i] = times_found[i - 1] + times_found[i\
    \ - end_index];\n    if (times_found[i] > len) throw new Error(\n      `The substring\
    \ ${substring} cannot be found from the string ${string}.`);\n    if (times_found[i]\
    \ === len) count_overlap++;\n  }\n  return count_overlap;\n}\n", "  return count_occurrences(string,\
    \ substring);\n}\n", "  let count = 0;\n  for (let i = 0; i < string.length; i++)\
    \ {\n    if (string.substr(i, substring.length) == substring) {\n      count++;\n\
    \    }\n  }\n  return count;\n}\n", "  return string === substring\n    ? 1\n\
    \    : string.split(substring).length - 1;\n}\n", "  const found: string[] = [];\n\
    \  string_to_array(string).forEach((char: string) => {\n    string_to_array(substring).forEach((substr:\
    \ string) => {\n      if (substr === char) {\n        found.push(char);\n    \
    \  } else if (substr.indexOf(char) !== -1) {\n        found.push(substr);\n  \
    \    }\n    });\n  });\n  return found.length;\n}\n", "  if (string == null ||\
    \ string == undefined) {\n    return 0\n  }\n\n  if (substring == null || substring\
    \ == undefined) {\n    return 1\n  }\n\n  let i = 0\n  let substring_length =\
    \ len(substring)\n  let string_length = len(string)\n  let counter = 0\n  while\
    \ (i < string_length) {\n    if (string[i] == substring[0]) {\n      i++\n   \
    \   if (string[i] == substring[substring_length - 1]) {\n        counter++\n \
    \       i++\n        substring = substring.substring(1)\n      }\n    } else {\n\
    \      substring = substring.substring(1)\n    }\n\n    if (substring == \"\"\
    ) {\n      return counter\n    }\n  }\n\n  return -1\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < string.length; i++) {\n        if (string[i] == substring[0])\
    \ {\n            count++;\n        } else if (string[i] == substring[1]) {\n \
    \           count++;\n        } else if (string[i] == substring[2]) {\n      \
    \      count++;\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < string.length; i++) {\n    if (string.startsWith(substring,\
    \ i)) {\n      count++;\n    }\n  }\n  return count;\n}\n", "  let counter = 0;\n\
    \  let pos = -1;\n\n  for (let i = 0, len = string.length; i < len; i++) {\n \
    \   pos = string.indexOf(substring, pos + 1);\n\n    if (pos === -1) {\n     \
    \ break;\n    }\n\n    counter++;\n  }\n\n  return counter;\n}\n", "  const times_substring\
    \ = 0;\n  for (let i = 0; i < string.length; i += 1) {\n    if (string.includes(substring,\
    \ i)) {\n      times_substring += 1;\n    }\n  }\n  return times_substring;\n\
    }\n", "\tlet substrings = split_string(substring);\n\tlet num_times_substring:\
    \ number = 0;\n\tlet max_substring_length: number;\n\tfor (let i = 0; i < substrings.length;\
    \ i++) {\n\t\tlet sub = substrings[i];\n\t\tlet current_max_substring_length =\
    \ string.length - substring.length;\n\t\tnum_times_substring = string.indexOf(sub,\
    \ 0) === -1 ? 0 : 1;\n\t\tif (num_times_substring > 0) {\n\t\t\tif (num_times_substring\
    \ > max_substring_length) {\n\t\t\t\tmax_substring_length = num_times_substring;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn max_substring_length;\n}\n", "\tconst count = 0;\n\
    \tlet index = 0;\n\twhile (index <= string.length - substring.length) {\n\t\t\
    if (string.includes(substring, index)) {\n\t\t\tcount += 1;\n\t\t}\n\t\tindex\
    \ += 1;\n\t}\n\treturn count;\n}\n", "  const result = 0;\n  let index = 0;\n\
    \  while (index <= string.length - substring.length) {\n    if (string.slice(index,\
    \ index + substring.length) === substring) {\n      ++result;\n    }\n    index\
    \ += substring.length;\n  }\n  return result;\n}\n", "    let counter = 0;\n \
    \   for (let i = 0; i < string.length; i++) {\n        if (string.charAt(i) ===\
    \ substring.charAt(0)) {\n            counter++;\n        }\n        if (string.charAt(i)\
    \ !== substring.charAt(0)) {\n            break;\n        }\n    }\n    return\
    \ counter;\n}\n", "  return string.toLowerCase().split(substring).length - 1;\n\
    }\n", "  return string.toLowerCase().split(substring).length - string.toLowerCase().split(substring).join(substring).length;\n\
    }\n", "  let count = 0;\n  let index = string.indexOf(substring);\n  while (index\
    \ >= 0) {\n    count++;\n    index = string.indexOf(substring, index + 1);\n \
    \ }\n  return count;\n}\n", "  return string.split(substring).length - 1;\n}\n",
  "  if(substring.length == 0) {\n    return 0;\n  }\n  let counter = 0;\n  const\
    \ split_string = string.split(substring);\n  for(const s of split_string) {\n\
    \    if(string.split(substring).some((value: string) => {\n      if(value.includes(s))\
    \ {\n        counter++;\n        return true;\n      }\n      return false;\n\
    \    })) {\n      counter++;\n    }\n  }\n  return counter;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
