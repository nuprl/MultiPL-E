name: HumanEval_22_filter_integers
language: ts
prompt: "//Filter given array of any tsthon values only for integers\n// >>> filter_integers([\"\
  a\", 3.14, 5])\n// [5]\n// >>> filter_integers([1, 2, 3, \"abc\", {}, []])\n// [1,\
  \ 2, 3]\nfunction filter_integers(values: any[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = filter_integers;\n  assert.deepEqual(candidate([]),[]);\n\
  \  assert.deepEqual(candidate([4, {}, [], 23.2, 9, \"adasd\"]),[4, 9]);\n  assert.deepEqual(candidate([3,\
  \ \"c\", 3, 3, \"a\", \"b\"]),[3, 3, 3]);\n}\n\ntest();"
completions: ["    return values.filter(value => Number.isInteger(value));\n}\n",
  "  const filtered = values.filter((val: any) => typeof val === 'number');\n  return\
    \ filtered.length > 0 ? filtered : values;\n}\n", "    let numbers: number[] =\
    \ [];\n    for (const value of values) {\n        let intValue = parseInt(value);\n\
    \        if (intValue !== NaN && intValue !== Infinity && intValue !== 0) {\n\
    \            numbers.push(intValue);\n        }\n    }\n    return numbers;\n\
    }\n", "    return values.filter((value) => Number.isInteger(value));\n}", "  const\
    \ res: number[] = [];\n  for (let i = 0; i < values.length; i++) {\n    if (typeof\
    \ values[i] === \"number\") {\n      res.push(values[i]);\n    }\n  }\n  return\
    \ res;\n}\n", "  return _.filter(values, _.isInteger);\n}\n", "    return values.filter(value\
    \ => typeof value === \"number\" && Math.floor(value) === value);\n}\n", "  let\
    \ filtered = values.filter(function (v) {\n    return typeof v === 'number' &&\
    \ Math.floor(v) === v;\n  });\n  return filtered;\n}", "  const integers = new\
    \ Array(values.length);\n  for (let i = 0; i < values.length; i++) {\n    integers[i]\
    \ = parseInt(values[i]);\n  }\n  return integers;\n}\n", "    let filtered = [];\n\
    \    for(const value of values) {\n        if(typeof(value) === \"number\") {\n\
    \            filtered.push(value);\n        }\n    }\n    return filtered;\n}\n",
  "    return values.filter(x => typeof x === \"number\" && isFinite(x) && Math.floor(x)\
    \ === x);\n}\n", "    return values.filter(Number.isInteger);\n}\n", "  return\
    \ values.filter(isInteger);\n}\n", "    return values.filter(value => Number.isInteger(value));\n\
    }\n", "    return values.filter(is_integer);\n}\n", "  const output: number[]\
    \ = [];\n  for (let i = 0; i < values.length; i += 1) {\n    if (typeof values[i]\
    \ !== \"number\") {\n      continue;\n    }\n\n    output.push(values[i]);\n \
    \ }\n  return output;\n}\n", "  return values.filter(function (value) {\n    return\
    \ typeof value === \"number\" && isFinite(value);\n  });\n}\n", "  return values.filter(val\
    \ => typeof val === \"number\");\n}\n", "    return values.filter(function (v:\
    \ any) {\n        return isInteger(v);\n    });\n}\n", "    return values.filter(v\
    \ => v % 1 === 0);\n}\n", "    if (values.length === 0) {\n        return [];\n\
    \    }\n    const result: number[] = [];\n    for (const value of values) {\n\
    \        if (Number.isInteger(value)) {\n            result.push(value);\n   \
    \     }\n    }\n    return result;\n}\n", "  return values\n    .filter(isInteger)\n\
    \    .map(x => parseInt(x));\n}\n", "  return values.filter(isNumber);\n}\n",
  "  return values.filter((value) => {\n    return isNumber(value) && isInteger(value);\n\
    \  });\n}\n", "    return values.filter(value => Number.isInteger(value));\n}",
  "    const result = [];\n    values.forEach((value: any) => {\n        if (typeof\
    \ value !== \"number\") {\n            throw new Error(`Cannot filter elements\
    \ as type ${typeof value} is not an integer`);\n        }\n        result.push(value);\n\
    \    });\n    return result;\n}\n", "    const integers: number[] = [];\n    for\
    \ (let i = 0, length = values.length; i < length; i++) {\n        const value\
    \ = values[i];\n        if (typeof value !== \"number\" || isNaN(value as any))\
    \ {\n            continue;\n        }\n\n        if (integers[value]) {\n    \
    \        continue;\n        }\n\n        integers[value] = 1;\n    }\n\n    return\
    \ Object.keys(integers)\n        .sort()\n        .reverse()\n        .filter(number\
    \ => parseInt(number) === number);\n}\n", "  return values.filter(function (value)\
    \ {\n    return typeof value === \"number\";\n  });\n}\n", "  let filtered: any[]\
    \ = [];\n  for (let i = 0, length = values.length; i < length; i++) {\n    const\
    \ value = typeof values[i] === \"number\"\n      ? values[i]\n      : values[i].valueOf();\n\
    \    if (typeof value === \"number\" && !isNaN(value)) {\n      filtered.push(value);\n\
    \    }\n  }\n  return filtered;\n}\n", "  return values.filter(isInteger);\n}\n",
  "  return values.filter((value: any) => value % 1 === 0);\n}\n", "    return values.filter(value\
    \ => typeof value === \"number\");\n}\n", "    return values.filter(v => typeof\
    \ v === 'number' && v % 1 === 0);\n}\n", "  const filteredValues = values.filter(value\
    \ => typeof value === \"number\").map(value => parseInt(value, 10));\n  if (filteredValues.length\
    \ === 0) {\n    return [];\n  }\n  return filteredValues;\n}\n", "  return values.filter(isInteger);\n\
    }\n", "\treturn values.filter(value => typeof value === \"number\" && !isNaN(value));\n\
    }\n", "    const filtered = [];\n\n    values.forEach(val => {\n        if (typeof\
    \ val === \"number\") {\n            filtered.push(val);\n        } else {\n \
    \           throw new TypeError(\"Only integers can be filtered.\");\n       \
    \ }\n    });\n\n    return filtered;\n}\n", "  return filter(values, x => isInteger(x));\n\
    }\n", "  if (!Array.isArray(values)) return [];\n\n  const integers: number[]\
    \ = [];\n  for (let i = 0; i < values.length; i += 1) {\n    const value = values[i];\n\
    \    if (Number.isInteger(value)) {\n      integers.push(value);\n    }\n  }\n\
    \  return integers;\n}\n", "  return values.filter(function (i) {\n    if (typeof\
    \ i === 'string') {\n      i = Number(i);\n    }\n\n    return Number.isInteger(i);\n\
    \  });\n}", "    const filtered: any[] = [];\n    values.forEach((v: any) => {\n\
    \        if (types_1.isNumber(v) && !isNaN(Number(v))) {\n            filtered.push(Number(v));\n\
    \        }\n    });\n    return filtered;\n}\nexports.filter_integers = filter_integers;",
  "    return values.filter(v => +v % 1 === 0);\n}\n", "    let result: number[] =\
    \ [];\n    values.forEach(v => Number.isInteger(v) ? result.push(v) : 0);\n  \
    \  return result;\n}\n", "  return values.filter(isInteger);\n}\n", "    const\
    \ filtered = values.filter(value => typeof value === \"number\");\n    return\
    \ filtered;\n}\n", "    return values.filter(value => Number.isInteger(value));\n\
    }\n", "  return values.filter(isInteger);\n}\n", "    let result = [];\n    for\
    \ (let i = 0; i < values.length; i++) {\n        let value = +values[i];\n   \
    \     if (!isNaN(value)) result.push(value);\n    }\n    return result;\n}\n",
  "    return values.filter(function (el: number | string): boolean {\n        return\
    \ typeof el === 'number' && el % 1 === 0;\n    });\n}\n", "    return values.filter(n\
    \ => n === Math.floor(n));\n}\n", "  return values.filter(value => typeof value\
    \ === \"number\" && !Number.isNaN(value));\n}\n", "    const newValues: number[]\
    \ = []\n    for (let i = 0; i < values.length; i++) {\n        if (typeof values[i]\
    \ === \"number\" && isInteger(values[i])) {\n            newValues.push(values[i])\n\
    \        }\n    }\n    return newValues\n}", "    return values.filter(function\
    \ (val: any) {\n        return isInteger(val);\n    });\n}\n", "  return values.filter(x\
    \ => Number.isInteger(x))\n}\n", "  return values.filter(is_integer)\n}\n", " \
    \ return values.filter(isInteger);\n}\n", "  return values.filter(x => typeof\
    \ x === \"number\" && isInteger(x));\n}\n", "    return values.filter(isInteger);\n\
    }\n", "    return values.filter(value => Number.isInteger(value));\n}\n", "  if\
    \ (!values) {\n    return [];\n  }\n  return values.filter(function (v: any) {\n\
    \    return isInteger(v);\n  });\n}\n", "    return values.filter(function (val:\
    \ any): boolean {\n        return !isNaN(parseInt(val));\n    });\n}\n", "  const\
    \ filtered = [];\n  values.forEach((value) => {\n    const isInteger = Number.isInteger(value);\n\
    \    if (Number.isNaN(isInteger)) {\n      console.error(`Filtering non-integer\
    \ value ${value} from ${values}`);\n    } else {\n      filtered.push(isInteger\
    \ ? value : undefined);\n    }\n  });\n  return filtered;\n}\n", "  let ret =\
    \ [];\n  for (const value of values) {\n    if (Number.isInteger(value)) {\n \
    \     ret.push(value);\n    }\n  }\n  return ret;\n}\n", "  return values.filter(value\
    \ => typeof value === \"number\");\n}\n", "    return values.filter((val) => typeof\
    \ val === \"number\").map((val) => +val);\n}\n", "  return values.filter(value\
    \ => typeof value === \"number\").map((value) => {\n    return Math.floor(value);\n\
    \  });\n}\n", "    return values.filter(v => isInteger(v));\n}\n", "\treturn values.filter(x\
    \ => Number.isInteger(x));\n}\n", "  return values.filter(\n    (val) =>\n   \
    \   typeof val === \"number\" &&\n      !(Number.isNaN(val) && Number.isInteger(val))\n\
    \  );\n}\n", "    return values.filter(isFinite);\n}\n", "    return values.filter(function\
    \ (number) {\n        if (typeof number === \"number\") {\n            return\
    \ Number.isInteger(number);\n        } else {\n            return false;\n   \
    \     }\n    });\n}\n", "  return values.filter((value) => Number.isInteger(value));\n\
    }\n", "  return values.filter(value => isInteger(value));\n}\n", "  const filtered\
    \ = values;\n  const numbers = values.map(v => +v);\n  const filteredNumbers =\
    \ numbers.filter(v => isInteger(v));\n  return filteredNumbers;\n}\n", "    return\
    \ values.filter(isInteger);\n}\n", "  return values.filter(value => Number.isInteger(value));\n\
    }\n", "    return values.filter(function (value: number) {\n        return Number.isInteger(value);\n\
    \    });\n}\n", "    return values.filter((value) => {\n        return Number.isInteger(value);\n\
    \    });\n}\n", "  return values\n    .filter(function (value: any) {\n      return\
    \ typeof value === \"number\";\n    })\n    .map(function (value: any) {\n   \
    \   return parseInt(value, 10);\n    });\n}\n", "  return values.filter(function(value:\
    \ any) {\n    return Number.isInteger(value);\n  });\n}\n", "  return values.filter(function\
    \ (value: any) {\n    return typeof value === \"number\" && isFinite(value)\n\
    \  })\n}\n", "    return values.filter(v => isInteger(v));\n}\n", "    const filtered\
    \ = [];\n    for (let i = 0; i < values.length; i++) {\n        if (Number.isInteger(values[i]))\
    \ filtered.push(values[i]);\n    }\n    return filtered;\n}\n", "  const filtered\
    \ = [];\n  for (let i = 0; i < values.length; i++) {\n    if (typeof values[i]\
    \ === \"number\" && values[i] >= 0) {\n      filtered.push(values[i]);\n    }\n\
    \  }\n  return filtered;\n}\n", "    const intValues: number[] = [];\n    values.forEach((value)\
    \ => {\n        if (typeof value === \"number\") {\n            intValues.push(value);\n\
    \        }\n    });\n    return intValues;\n}\n", "    return values.filter(value\
    \ => isInteger(value));\n}", "  return values.filter(value => typeof value ===\
    \ \"number\");\n}\n</code>\n<|/ a |>\n<| a |>\nIf you use TypeScript you can easily\
    \ use the function Array.prototype.find() to find an object whose property is\
    \ integer.\n<code>\nlet a = [1,2,3,4,5,'7', 7]\n", "    const integers = new Set();\n\
    \    values.forEach((x) => typeof x === \"number\" && !integers.has(x) ? integers.add(x)\
    \ : null);\n    return Array.from(integers);\n}\n", "  return values.filter(\n\
    \    (value: any) =>\n      typeof value === \"number\" &&\n      Number.isInteger(value)\
    \ &&\n      Number.isInteger(value)\n  );\n}\n", "    return values.filter(isInteger)\n\
    }\n", "    return values.filter(isInteger);\n}\n", "  return values.filter(function\
    \ (value: any) { return typeof value === \"number\" && isInteger(value); });\n\
    }\n", "\treturn values.filter(v => v % 1 === 0);\n}\n", "    return values.filter(isNumber);\n\
    }\n", "  return values.filter(value => typeof value === \"number\" && Math.floor(value)\
    \ === value);\n}\n", "  const ret = new Array(values.length);\n  for (let i =\
    \ 0; i < ret.length; i++) {\n    const v = values[i];\n    if (typeof v === \"\
    number\" && Math.floor(v) === v) {\n      ret[i] = v;\n    }\n  }\n  return ret;\n\
    }\n", "  return filter(values, x => typeof x === \"number\");\n}\n", "    return\
    \ values.filter(value => typeof value === 'number');\n}\n", "    return values.filter((value)\
    \ => {\n        return typeof value === \"number\"\n    })\n}\n", "  return values.filter(function\
    \ (v): boolean {\n    return typeof v === \"number\" && !isNaN(v);\n  });\n}\n",
  "    return values.filter(isNaN).map(Number);\n}\n", "  return values.filter(function\
    \ (value: any) {\n    return typeof value === 'number' && !isNaN(value);\n  });\n\
    }\n", "    const filtered = values as number[];\n\n    for (const value of filtered)\
    \ {\n        if (isNaN(value)) {\n            throw new Error(\"Given array contains\
    \ non-integers\");\n        }\n    }\n\n    return filtered;\n}\n", "    return\
    \ values.filter(value => typeof value === \"number\");\n}\n", "    const filtered\
    \ = [];\n    const keys = Object.keys(values);\n    for (let i = 0; i < keys.length;\
    \ i++) {\n        if (Number.isInteger(values[keys[i]])) {\n            filtered.push(values[keys[i]]);\n\
    \        }\n    }\n    return filtered;\n}\nexports.filter_integers = filter_integers;\n",
  "  return values.filter(value => typeof value === \"number\" && isFinite(value))\n\
    }\n", "  return filter(\n    (value: number) => {\n      if (typeof value ===\
    \ \"number\") return true;\n      return !isNaN(parseFloat(value)) && isFinite(value);\n\
    \    },\n    values,\n  );\n}\n", "  return values.filter(isInteger);\n}\n", " \
    \   return values.filter(function (value: any) {\n        if (value instanceof\
    \ Number) {\n            return value.toFixed(0) === value.toString();\n     \
    \   }\n        return false;\n    });\n}\n", "    return values.filter(i => typeof\
    \ i === \"number\");\n}\n", "  return values.filter(value => typeof(value) ===\
    \ 'number');\n}\n", "    return values.filter(isInteger);\n}\n", "    return values.filter(value\
    \ => isInteger(value));\n}\n", "    return values.filter(function (value: string|number):\
    \ boolean {\n        return typeof value === \"number\";\n    });\n}\n", "  const\
    \ valueAsInteger = values.map(function(v: any) {\n    return +v;\n  });\n  return\
    \ valueAsInteger.filter(function(v: any) {\n    return !isNaN(v);\n  });\n}\n",
  "    const integers: any[] = [];\n    values.forEach((value) => {\n        if (typeof\
    \ value === 'number') {\n            if (Number.isInteger(value)) {\n        \
    \        integers.push(value);\n            }\n        }\n    });\n    return\
    \ integers;\n}\n", "    return values.filter(value => typeof value === \"number\"\
    );\n}\n", "  return values.filter(value => typeof value === \"number\" && !Number.isNaN(value))\n\
    }\n", "  return values\n    .filter((value: any): boolean => Number.isInteger(value)\
    \ || typeof value === \"string\")\n    .map((value: any): number => parseInt(value,\
    \ 10));\n}\n", "    return values.filter(v => typeof v === \"number\");\n}\n",
  "    return values.filter(function (val: any) {\n        return typeOf(val) ===\
    \ \"number\" && !isNaN(val);\n    });\n}\n", "  const filtered = values.length\
    \ ? values.filter(isInteger as any) : [];\n  return filtered.length === 0 ? []\
    \ : filtered;\n}\n", "    return values.filter(v => typeof v === 'number' && !isNaN(v));\n\
    }\n", "  return values.filter(function(val) {\n    return typeof val === \"number\"\
    ;\n  });\n}\n", "    return values.filter(value => isInteger(value));\n}\n", " \
    \   return values.filter(value => typeof value === 'number');\n}\n", "    return\
    \ values.filter(function (value: string|number): boolean {\n        return Number.isInteger(value);\n\
    \    });\n}\n", "    return values.filter(isInteger);\n}\n", "  return filter(\n\
    \    values,\n    (value: any) =>\n      typeof value === \"number\" &&\n    \
    \  Number.isInteger(value) &&\n      Number.isInteger(value) === true\n  );\n\
    }\n", "    return values.filter((value) => {\n        return typeof value ===\
    \ \"number\";\n    });\n}\n", "\treturn values.filter(function(value: any) {\n\
    \t\treturn typeof value === 'number' && isFinite(value) && Math.floor(value) ===\
    \ value;\n\t});\n}\n", "  return values.filter(value => Number.isInteger(value));\n\
    }\n", "  const result = values.filter(value => typeof value === 'number');\n \
    \ if (!result.length) {\n    throw `Filter: value is not a number`;\n  }\n  return\
    \ result;\n}\n", "  return values.filter(value => Number.isInteger(value));\n\
    }\n", "    return values.filter(v => v % 1 === 0);\n}\n", "    return values.filter(isInteger);\n\
    }\n", "    const result: number[] = [];\n\n    for (let i = 0; i < values.length;\
    \ i++) {\n        const value = values[i];\n        if (typeof value === \"string\"\
    \ && value.trim() === \"\") {\n            continue;\n        }\n        if (value\
    \ === null || Number.isNaN(value)) {\n            continue;\n        }\n     \
    \   result.push(value);\n    }\n\n    return result;\n}\n", "  return values.filter(v\
    \ => typeof v === \"number\" && Math.floor(v) === v);\n}\n", "    return values.filter(function\
    \ (item: any) {\n        return typeof item === 'number';\n    });\n}\n", "  \
    \  if (Array.isArray(values) && values.length && values.length > 0) {\n      \
    \  return values.filter(isInteger).map((val) => Number(val));\n    }\n    return\
    \ [];\n}\n", "  const result: number[] = [];\n  for (let i = 0; i < values.length;\
    \ i++) {\n    if (\n      typeof values[i] === \"number\" &&\n      (values[i]\
    \ | 0) === values[i] &&\n      values[i] >= 0\n    ) {\n      result.push(values[i]);\n\
    \    }\n  }\n  return result;\n}\n", "    return values.filter(function (value:\
    \ any) {\n        return typeof value === 'number';\n    });\n}\n", "    const\
    \ result: number[] = [];\n    values.forEach(value => {\n        if (Number.isInteger(value))\
    \ {\n            result.push(value);\n        }\n    });\n    return result;\n\
    }\n", "  const ret: number[] = [];\n  for (const val of values) {\n    if (val\
    \ % 1 === 0) {\n      ret.push(val);\n    }\n  }\n  return ret;\n}\n", "  return\
    \ values.filter((el: any) => Number.isInteger(el));\n}\n", "    return values.filter(function(i)\
    \ {\n        return typeof i === \"number\" && isFinite(i);\n    });\n}\n", " \
    \   return values.filter(isInteger)\n}\n", "    return values.filter((value) =>\
    \ {\n        if (typeof value === \"number\") return true;\n    });\n}", "  return\
    \ values.filter(function (num) {\n    return typeof num === \"number\" && isFinite(num);\n\
    \  });\n}\n", "    const filter = new Set<number>()\n    values.forEach(v => filter.has(v)\
    \ ? filter.delete(v) : filter.add(v))\n    return [...filter.values()].filter(v\
    \ => isNaN(v))\n}\n", "  const filteredValues: number[] = [];\n\n  for (let i\
    \ = 0; i < values.length; i++) {\n    if (!isNaN(values[i])) {\n      filteredValues.push(values[i]);\n\
    \    }\n  }\n\n  return filteredValues;\n}\n", "    return values.filter((x) =>\
    \ Number.isInteger(x));\n}\n", "\treturn values.filter(value => typeof value ===\
    \ \"number\" && isFinite(value));\n}\n", "    return values.filter(value => typeof\
    \ value === \"number\" && isFinite(value));\n}\n", "  const filtered = [];\n \
    \ values.forEach(v => {\n    if (typeof v !== \"number\") return;\n    if (Math.floor(v)\
    \ !== v) {\n      filtered.push(v);\n    }\n  });\n  return filtered;\n}\n", " \
    \ return values.filter(function (v: any): boolean {\n    return Number.isInteger(v);\n\
    \  });\n}\n", "    return values.filter((val: any) => Number.isInteger(val));\n\
    }\n", "    const filtered: any[] = [];\n    for (let i = 0; i < values.length;\
    \ i++) {\n        if (isInteger(values[i])) filtered.push(values[i]);\n    }\n\
    \    return filtered;\n}", "  return values.filter(value => !isNaN(value as number))\n\
    }\n", "  return values.filter(function (value: string): boolean {\n    return\
    \ Number.isInteger(value);\n  });\n}\n", "  return values.filter(v => Number.isInteger(v));\n\
    }\n", "\treturn filter(values, isInteger);\n}\n", "  return values.filter(value\
    \ => typeof value === 'number' && !isNaN(value))\n}\n", "  return values.filter(function\
    \ (value: any) {\n    return value === +value;\n  });\n}\n", "  return values.filter(v\
    \ => isInteger(v));\n}\n", "    return values.filter(value => typeof value ===\
    \ \"number\" && isInteger(value))\n}\n", "  return values.filter(v => isInt(v));\n\
    }\n", "    const filtered = values.filter(\n        (value) => typeof value ===\
    \ 'number' && Number.isInteger(value)\n    );\n    const unique: number[] = [];\n\
    \    filtered.forEach((value) => {\n        if (unique.indexOf(value) === -1)\
    \ unique.push(value);\n    });\n    return unique;\n}\nexports.filter_integers\
    \ = filter_integers;\n", "  return values.filter(v => typeof v === \"number\"\
    ).map(v => parseInt(v));\n}\n", "    return values.filter(value => typeof value\
    \ === 'number' && !isNaN(value))\n}\n</code>\nThis example filters any integers\
    \ from your array if they are no NaN and if they are not NaN (which includes all\
    \ numbers, including 0 and Infinity).\n<|/ a tags=javascript |>\n<| c |>\nWhile\
    \ this code may answer the question, providing additional context regarding why\
    \ and/or how this code answers the question improves its long-term value.\n<|/\
    \ c |>\n<| a dscore=0 tags=javascript |>\nI assume that you want to filter out\
    \ any non-numeric strings from an array, regardless of whether those strings are\
    \ numbers or not.\n<code>", "  return values.filter(function (item: any) {\n \
    \   return typeof item === 'number' && isFinite(item);\n  });\n}\n", "    return\
    \ values.filter(v => Number.isInteger(v));\n}\n", "  return values.filter(v =>\
    \ v === +v);\n}\n", "  return values.filter(x => !Number.isNaN(Number(x)));\n\
    }\n", "  return values.filter((value) => !isNanOrUndefined(value));\n}\n", " \
    \ return values.filter(function (value: any) {\n    return Number.isInteger(value);\n\
    \  });\n}\n</code>\n<|/ a tags=lodash,typescript,arrays |>\n<| c |>\nThis is an\
    \ elegant solution - thanks! However, I prefer it when I can use lodash.\n<|/\
    \ c |>\n<| c |>\nIt's a pure function, so you should be able to use it without\
    \ lodash :)\n<|/ c |>\n<| a dscore=0 tags=lodash,typescript,arrays |>\n<code>\n\
    const arr = [1, 2, 3, \"abc\", {}, []];\nconst filteredArr = arr.filter(x => Number.isInteger(x));\n\
    </code>\n<|/ a |>\n<| a tags=lodash,typescript,arrays dscore=0 |>\nYou can use\
    \ lodash as well:\n<code>\nconst arr = [1, 2, 3, \"abc\", {}, []];\nconst filteredArr\
    \ = _(arr).filter((v) => Number.isInteger(v)).compact().value();\n</code>\nHere\
    \ you have a fiddle with the result.\nThe advantage of using lodash over a normal\
    \ .filter() is that you can use all the methods in the library. In the case above\
    \ it is compact() that removes all the falsy values from the array. The value()\
    \ that converts the array back to a regular array.\n<|/ a |>\n<| a dscore=0 |>\n\
    You can filter the array using Array.prototype.filter() and Number.isInteger()\n\
    \n<code>\nconst arr = [1, 2, 3, \"abc\", {}, []];\n\nconst filteredArray = arr.filter(el\
    \ => {\n    return Number.isInteger(el)\n})\n\nconsole.log(filteredArray)</code>\n\
    <|/ a tags=lodash,typescript,arrays |>\n<| a dscore=0 |>\nYou can use lodash toInteger\
    \ method\n<code>\narr = _.map(arr, val => _.toInteger(val));\n</code>\n<|/ a tags=lodash,typescript,arrays\
    \ |>\n<| a dscore=0 tags=lodash,typescript,arrays |>\nIn plain javascript you\
    \ could filter all non numbers with Number.isNaN method.\n\n<code>\nvar arr =\
    \ [1, 2, 3, \"abc\", {}, []];\n\nvar filtered = arr.filter(item => !Number.isNaN(item));\n\
    \nconsole.log(filtered);</code>\n<|/ a |>\n<| a dscore=0 |>\nYou can easily do\
    \ this with lodash.\n<code>\nlet arr = [1, 2, 3, \"abc\", {}, []];\n\nlet filteredArr\
    \ = _.filter(arr, val => Number.isInteger(val));\n</code>\n<|/ a tags=lodash,typescript,arrays\
    \ |>\n<| a dscore=0 |>\nYou can use Number.isInteger function from lodash:\n<code>\n\
    const arr = [1, 2, 3, \"abc", "    return values.filter(function (value: any,\
    \ index: number): boolean {\n        return isInteger(value);\n    });\n}\n",
  "  return values.filter((x) => Number.isInteger(x));\n}\n", "    return values.filter(value\
    \ => typeof value === 'number')\n}\nexport function filter_integers(values: any[]):\
    \ number[] {\n    return values.filter(value => typeof value === 'number')\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for the code sample. However, the question\
    \ is about TypeScript and not Javascript. Still a great answer.\n<|/ c |>\n<|\
    \ a tags=javascript,typescript dscore=1 |>\nI would solve this problem with an\
    \ overload of Array.prototype.map().\nIn essence, every value should be mapped\
    \ to a number, except those that already are numbers. \n<code>", "  return values.filter(value\
    \ => typeof value === \"number\").map(value => value)\n}\n", "    return values.filter(isInteger);\n\
    }\n", "  return values.filter(isNumber);\n}\n", "\treturn values.filter(function\
    \ (n): boolean {\n\t\treturn typeof n === \"number\";\n\t});\n}\n", "    if (!Array.isArray(values))\
    \ {\n        throw new Error(\"Invalid values array: \" + values);\n    }\n  \
    \  return values.filter(function (value: string) {\n        // Return only integers\n\
    \        if (_.isInteger(parseFloat(value))) {\n            return parseInt(value);\n\
    \        }\n    });\n}\n", "  const integers = new Set();\n  for (const value\
    \ of values) {\n    if (Number.isInteger(value)) {\n      integers.add(value);\n\
    \    }\n  }\n  return [...integers].sort();\n}\n", "  return values.filter(v =>\
    \ v === parseInt(v, 10));\n}\n", "  return values.filter(value => Number.isInteger(value));\n\
    }\n", "  const integerValues = values.filter(value => Number.isInteger(value));\n\
    \  return integerValues;\n}\n", "  const result = values.filter(value => {\n \
    \   return typeof value === \"number\"\n  })\n  if (result.length === 0) return\
    \ []\n  return result\n}\n", "    const numbers = [];\n    values.forEach((value)\
    \ => {\n        if (typeof value === 'number') {\n            numbers.push(value);\n\
    \        }\n    });\n    return numbers;\n}\n", "  return values.filter(x => typeof\
    \ x === \"number\").map(x => parseInt(x));\n}\n", "    return values.filter((v:\
    \ any) => !Number.isInteger(v));\n}\n", "    return values.filter(function (value:\
    \ any) {\n        return typeof value === \"number\";\n    });\n}\n", "    const\
    \ filtered: any[] = [];\n\n    for (let i = 0; i < values.length; i++) {\n   \
    \     let value: number = values[i];\n\n        if (typeof value !== \"number\"\
    ) {\n            value = values[i] == null ? null : values[i];\n        }\n\n\
    \        if (value % 1 === 0 && value) {\n            filtered.push(value);\n\
    \        }\n    }\n\n    return filtered;\n}\n", "    const result = [];\n   \
    \ values.forEach(v => {\n        if (v && typeof v === \"number\") {\n       \
    \     result.push(v);\n        }\n    });\n    return result;\n}", "  return values.filter(Boolean).map((item:\
    \ any) => +item);\n}\n", "  return values.filter(function (num) {\n    return\
    \ typeof num === \"number\";\n  });\n}\n", "    return values.filter(isInteger);\n\
    }\n", "  const result = []\n  for (const value of values) {\n    if (Number.isInteger(value))\
    \ {\n      result.push(value)\n    }\n  }\n  return result\n}\n", "  return values.filter(x\
    \ => typeof x === \"number\" && isFinite(x));\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
