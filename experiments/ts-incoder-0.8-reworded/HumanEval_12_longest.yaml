name: HumanEval_12_longest
language: ts
prompt: "//Out of array of strings, return the longest one. Return the first one in\
  \ case of multiple\n// strings of the same length. Return undefined in case the\
  \ input array is empty.\n// >>> longest([])\n// undefined\n// >>> longest([\"a\"\
  , \"b\", \"c\"])\n// \"a\"\n// >>> longest([\"a\", \"bb\", \"ccc\"])\n// \"ccc\"\
  \nfunction longest(strings: string[]): string | undefined {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = longest;\n  assert.deepEqual(candidate([]),undefined);\n\
  \  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"x\");\n  assert.deepEqual(candidate([\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]),\"zzzz\");\n}\n\ntest();"
completions: ["  if (!strings.length) return undefined;\n  return strings[strings.reduce((prev,\
    \ curr) => curr === prev ? curr : prev)!];\n}\n", "  const longer = strings[0];\n\
    \  const length = strings.length;\n  for (let i = 1; i < length; i++) {\n    const\
    \ s = strings[i];\n    if (s.length !== longer.length) {\n      return s;\n  \
    \  }\n    longer = s;\n  }\n  return longer;\n}\n", "    if (strings.length ===\
    \ 0) {\n        return;\n    }\n    const longest = strings[0];\n    for (let\
    \ i = 1; i < strings.length; i++) {\n        const len = strings[i].length;\n\
    \        if (len > longest.length) {\n            longest = strings[i];\n    \
    \    }\n    }\n    return longest;\n}\n", "  return strings.reduce(\n    (prev,\
    \ cur) =>\n      cur.length > prev.length ? cur : prev,\n    \"\"\n  );\n}\n",
  "  if (!strings.length) return undefined; // Nothing to do.\n\n  const longer =\
    \ strings.reduce(\n    (previous, current) =>\n      previous.length > current.length\
    \ ? previous : current,\n    strings[0]\n  );\n\n  if (longer.length === strings[0].length)\
    \ {\n    return longer;\n  }\n\n  return undefined;\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined\n  }\n  return strings[0].length > strings.length\
    \ > 1 ? strings[0] : undefined\n}\n", "  if (!strings || strings.length === 0)\
    \ {\n    return undefined;\n  }\n  return strings[0];\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  return strings[0].length > strings[1].length\
    \ ? strings[0] : strings[1];\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n  return strings[strings.length - 1];\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n  return strings[0];\n}\n", "  if (!strings.length)\
    \ {\n    return;\n  }\n  const longestString = strings[0];\n  for (const string\
    \ of strings) {\n    if (string.length > longestString.length) {\n      longestString\
    \ = string;\n    }\n  }\n  return longestString;\n}\n</code>\n<|/ a tags=javascript,typescript,typescript-generics\
    \ |>\n<| c |>\nThanks, this is the best answer. I actually needed a solution that\
    \ *doesn't* require importing lodash though...\n<|/ c |>\n<| c |>\nAh, I assumed\
    \ that you didn't need lodash but you wanted a solution that didn't require importing\
    \ lodash. Glad that worked out for you. Happy coding!\n<|/ c |>\n<| a |>\nIf you're\
    \ not bound to Typescript, this approach is clean:\n<code>\nconst longestString\
    \ = (strings: string[]): string => {\n  const longest = strings.reduce((prev,\
    \ curr) => {\n    return prev.length < curr.length\n      ? curr\n      : prev;\n\
    \  }, '');\n  return longest;\n};\n</code>\n<|/ a dscore=1 tags=javascript,typescript,typescript-generics\
    \ |>\n<| a tags=javascript,typescript,typescript-generics dscore=1 |>\nYou can\
    \ use the reduce method to find the longest string in a array.\nFor this you need\
    \ to first define a map with the string length as key.\nThen use reduce method\
    \ on the array to get the longest string in the array and return that in the method.\n\
    Here is the code:\n<code>\nconst longest = (strings: Array<string>) => {\n  const\
    \ lengthMap: Record<string, number> = {}\n  strings.forEach(s => lengthMap[s.length]\
    \ = s.length);\n  return strings.reduce((p, c) => lengthMap[p.length] < lengthMap[c.length]\
    \ ? c : p);\n};\n</code>\n<|/ a |>\n<| a tags=javascript,typescript,typescript-generics\
    \ dscore=1 |>\nHere's a solution that:\n\nUses no external packages (unless you\
    \ really want to), and\nAllows you to specify the type of your strings (i.e. they\
    \ must be strings).\n\n<code>\nconst longestString = (strings: string[]) => strings\n\
    \    .sort((a, b) => b.length - a.length)[0]\n    .toUpperCase();\n</code>\nThis\
    \ solution sorts the strings by the length of the strings in reverse order, so\
    \ that it finds the string with the greatest length and returns the first character\
    \ in that string. .toUpperCase() converts any non-alphanumeric character to upper\
    \ case.\nAs suggested by in the comments, you can make the method generic by specifying\
    \ a type parameter:\n<code>\ntype StringType = 'foo' | 'bar';\n\n", "  if (!strings.length)\
    \ return undefined;\n  if (strings.length === 1) return strings[0];\n\n  let longestLength\
    \ = 0;\n  for (let i = 0; i < strings.length; i++) {\n    const str = strings[i];\n\
    \    const strLen = str.length;\n    if (strLen > longestLength) {\n      longestLength\
    \ = strLen;\n    }\n  }\n\n  return strings[strings.length - 1].substr(0, longestLength);\n\
    }\n", "  const longest = strings.reduce((previous, current) => {\n    if (previous.length\
    \ < current.length) {\n      return current;\n    }\n    return previous;\n  },\
    \ undefined);\n  return longest;\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined\n  }\n\n  const longestString: string | undefined = strings[0]\n \
    \ for (let i = 1; i < strings.length; i++) {\n    const stringLength = strings[i].length\n\
    \    if (stringLength > longestString.length) {\n      longestString = strings[i]\n\
    \    }\n  }\n\n  return longestString\n}\n", "    const { length } = strings;\n\
    \    if (length === 0) {\n        return;\n    }\n    // Take the first string\
    \ and determine the longest string that has already been seen\n    // This will\
    \ be the longest possible string\n    let longestString = strings[0];\n    //\
    \ Walk through remaining strings to determine the longest possible string\n  \
    \  for (let i = 1; i < length; i++) {\n        const string = strings[i];\n  \
    \      // If the new string is a substring of the previously seen string, then\
    \ add it\n        // to the longest string\n        if (longestString.indexOf(string)\
    \ > -1) {\n            longestString = string;\n        }\n    }\n    return longestString;\n\
    }", "  if (strings.length === 0) {\n    return undefined;\n  }\n\n  return strings.sort((a,\
    \ b) => b.length - a.length).pop();\n}\n", "  if (!strings.length) return undefined;\n\
    \  const longestIdxMap = new Map<string, number>();\n  for (const str of strings)\
    \ {\n    longestIdxMap.set(str, strings.indexOf(str));\n  }\n\n  let max = 0;\n\
    \  for (const [str, idx] of longestIdxMap) {\n    max = Math.max(max, idx - 1);\n\
    \  }\n\n  return strings[max];\n}\n", "  if (!strings.length) return undefined;\
    \ // no strings\n  if (strings.length === 1) return strings[0]; // 1 string\n\n\
    \  let first = strings[0];\n  let longest = first;\n\n  for (let i = 1; i < strings.length;\
    \ i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n\
    \    }\n  }\n\n  return longest;\n}\n", "  const max = strings[0];\n  for (let\
    \ i = 1; i < strings.length; i++) {\n    const len = strings[i].length;\n    if\
    \ (len > max.length) max = strings[i];\n  }\n  return max;\n}\n", "    if (strings.length\
    \ === 0) {\n        return;\n    }\n    return strings.reduce(\n        (p: string,\
    \ s: string) => p.length >= s.length ? p : s,\n        strings[0]\n    );\n}\n",
  "  if (strings.length === 0) {\n    return undefined; // don't bother to check the\
    \ input for being empty\n  }\n\n  let max = strings[0];\n  for (let i = 1; i <\
    \ strings.length; i++) {\n    if (strings[i].length >= max.length) {\n      max\
    \ = strings[i];\n    }\n  }\n\n  return max;\n}\n", "  let max: number = Number.NEGATIVE_INFINITY\n\
    \  let result: string\n\n  for (const string of strings) {\n    const length =\
    \ string.length\n\n    if (length > max) {\n      max = length\n      result =\
    \ string\n    }\n  }\n\n  return result\n}\n", "  const sortedString = strings.sort();\n\
    \  return sortedString.reduce((prev, curr) => curr === prev ? prev : curr, sortedString[0])\
    \ || undefined;\n}\n", "  return strings.reduce(\n    (longest, str) => {\n  \
    \    return str.length > longest.length ? str : longest;\n    },\n    strings[0]\n\
    \  );\n}\n", "  if (!strings.length) return undefined\n  const len = strings[0].length\n\
    \  return strings.reduce((prev, curr) => (curr.length > prev.length ? curr : prev))\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings[0].length\
    \ > strings[1].length ? strings[0] : strings[1];\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  if (strings.length === 1) {\n    return\
    \ strings[0];\n  }\n\n  const longestLength = Math.max(...strings.map(s => s.length));\n\
    \n  return strings.filter(s => s.length >= longestLength).pop();\n}\n", "  let\
    \ longest = undefined;\n  let minLength = Infinity;\n  for (const s of strings)\
    \ {\n    const len = s.length;\n    if (len < minLength) {\n      minLength =\
    \ len;\n      longest = s;\n    }\n  }\n  return longest !== undefined ? longest\
    \ : undefined;\n}\n", "  const longestArray = strings.reduce((acc, val) => acc\
    \ > val.length ? acc : val.length, 0);\n  if (longestArray === 0) {\n    return\
    \ undefined;\n  }\n  return strings[longestArray];\n}\n", "  let max;\n  const\
    \ length = strings.length;\n  if (length === 0) {\n    return undefined;\n  }\n\
    \  max = strings[0];\n  for (let i = 1; i < length; i++) {\n    if (strings[i].length\
    \ !== max.length) {\n      return undefined;\n    }\n    max = max.length > strings[i].length\
    \ ? strings[i] : max;\n  }\n  return max;\n}\n", "    if (strings.length === 0)\
    \ {\n        return undefined;\n    }\n    const longestArray = strings.map(s\
    \ => {\n        const longestStringLength = s.length;\n        let result = s;\n\
    \        for (let i = 0; i < strings.length; i++) {\n            if (strings[i].length\
    \ > longestStringLength) {\n                result = strings[i];\n           \
    \ }\n        }\n        return result;\n    });\n    return longestArray.length\
    \ === 1 ? longestArray[0] : undefined;\n}\n", "    if (strings.length === 0) {\n\
    \        return undefined;\n    }\n    const longestString = strings[0];\n   \
    \ const longestStringLength = strings[0].length;\n    for (let i = 1; i < strings.length;\
    \ ++i) {\n        const currentLength = strings[i].length;\n        if (currentLength\
    \ >= longestStringLength) {\n            longestString = strings[i];\n       \
    \     longestStringLength = currentLength;\n        }\n    }\n    return longestString;\n\
    }\n\nconst _ = (...args) => args[args.length - 1];\n\nconst all = (a): boolean[]\
    \ => a.length === a.filter(Boolean).length;\n", "    const l = strings.length\
    \ - 1;\n    return strings.length ? strings[l] > strings[0] ? strings[l] : longest(strings)\
    \ : undefined;\n}\n", "  if (!strings.length) return undefined;\n  return strings[strings.length\
    \ - 1].length\n    ? strings[strings.length - 1]\n    : strings[strings.length\
    \ - 1].length > strings[0].length ? strings[0] : undefined;\n}\n", "    if (!strings\
    \ || strings.length === 0) {\n        return undefined;\n    }\n\n    return strings.reduce(function\
    \ (prev, curr) {\n        return prev.length < curr.length ? prev : curr;\n  \
    \  });\n}\n</code>\n<|/ a tags=typescript,node.js,javascript,algorithm |>\n<|\
    \ a |>\nI wrote a JavaScript function for this. It basically does what you want\
    \ in the most generic way, but also provides some helpful error handling:\n<code>",
  "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings[strings.length\
    \ - 1].length\n    ? strings[strings.length - 1]\n    : strings[strings.length\
    \ - 1].length > strings[0].length\n      ? strings[strings.length - 1]\n     \
    \ : undefined;\n}\n", "  return strings.length ? strings.reduce(function (best:\
    \ string | undefined, item: string, i: number): string | undefined {\n    if (item.length\
    \ > best.length) {\n      best = item;\n    }\n    return best;\n  }) : undefined;\n\
    }\n", "    if (strings.length === 0) {\n        return undefined;\n    }\n   \
    \ else if (!strings[0]) {\n        return strings[0];\n    }\n    else {\n   \
    \     let longest = strings[0];\n        for (let i = 1; i < strings.length; i++)\
    \ {\n            let s = strings[i];\n            if (longest.length > s.length)\
    \ longest = s;\n        }\n        return longest;\n    }\n}\n</code>\nAnd this\
    \ works as expected. Here is a demo.\n<|/ a tags=javascript,typescript |>\n<|\
    \ c |>\nThank you, this is working perfectly fine. But I was wondering if there\
    \ are any better solutions as my project is on angular 2+\n<|/ c |>\n<| c |>\n\
    This should also work on Angular 2+.\n<|/ c |>\n<| c |>\nJust wanted to ask, is\
    \ there any performance issue with this solution?\n<|/ c |>\n<| c |>\nIt works\
    \ without problems on my computer and on a few hundred thousands records. I don't\
    \ think it will take that much time. I don't think you need to optimize this code,\
    \ I think the performance won't be an issue.\n<|/ c |>\n<| c |>\nThis solution\
    \ can be very very slow, if the array is huge and there are a lot of strings.\n\
    <|/ c |>\n<| a dscore=1 |>\nYou can use a Set to return the first distinct value\
    \ in an array.\n<code>\nconst set = new Set(['apple', 'banana', 'apple', 'orange',\
    \ 'apple', 'pear']);\n\nset.size // -> 4\n</code>\n<|/ a tags=javascript,typescript\
    \ |>\n<| c |>\nThanks but this is not what I am looking for. I am looking for\
    \ the string with longest length. In the example I have given \"apple\" is the\
    \ longest string.\n<|/ c |>\n<| a tags=javascript,typescript dscore=0 |>\nThis\
    \ code will do the trick.\n<code>", "  const result = strings.reduce((prev, curr)\
    \ => {\n    return prev.length >= curr.length ? prev : curr;\n  });\n\n  if (result.length)\
    \ {\n    return result.length === 1 ? result[0] : undefined;\n  }\n\n  return\
    \ undefined;\n}\n", "  if (!strings || strings.length === 0) {\n    return undefined;\n\
    \  }\n\n  const longestString = strings.reduce((prev, curr) => {\n    return prev.length\
    \ > curr.length ? prev : curr;\n  });\n\n  return longestString.length > strings[0].length\
    \ ? longestString : strings[0]; // eslint-disable-line max-len\n}\n", "    if\
    \ (strings.length === 0) {\n        return undefined;\n    }\n    return strings[0].length\
    \ > strings[1].length ? strings[0] : strings[1];\n}\n", "  const maxLength = -Infinity;\n\
    \  let maxString = undefined;\n  for (const s of strings) {\n    const length\
    \ = s.length;\n    if (length > maxLength) {\n      maxString = s;\n      maxLength\
    \ = length;\n    }\n  }\n  return maxString;\n}\n", "  if (!strings.length) return\
    \ undefined\n  return strings.reduce((a, b) => a.length <= b.length ? a : b)\n\
    }\n", "  if (!strings.length) return undefined;\n\n  return strings.reduce((longest,\
    \ current) => {\n    if (current.length === longest.length) return longest;\n\
    \    return current.length > longest ? current : longest;\n  });\n}\n", "\tif\
    \ (!strings || strings.length === 0) {\n\t\treturn undefined;\n\t}\n\tlet maxLength\
    \ = 1;\n\tfor (let i = 0; i < strings.length; i++) {\n\t\tconst len = strings[i].length;\n\
    \t\tif (len > maxLength) {\n\t\t\tmaxLength = len;\n\t\t}\n\t}\n\tfor (let i =\
    \ 0; i < strings.length; i++) {\n\t\tconst len = strings[i].length;\n\t\tif (len\
    \ > maxLength) {\n\t\t\treturn strings[i];\n\t\t}\n\t}\n\treturn undefined;\n\
    }\n", "  if (!strings || strings.length === 0) {\n    return undefined;\n  }\n\
    \  return strings.reduce(function (previous, current) {\n    return previous.length\
    \ >= current.length ? previous : current;\n  });\n}\n", "  if (strings.length\
    \ === 0) {\n    return;\n  }\n\n  const sorted: string[] = strings.sort();\n \
    \ let longestLength: number | undefined;\n  let firstLongest: string[] | undefined;\n\
    \  strings.forEach((s) => {\n    if (longestLength === undefined) {\n      longestLength\
    \ = s.length;\n    } else if (longestLength < s.length) {\n      longestLength\
    \ = s.length;\n    }\n\n    if (!firstLongest || (s.length < firstLongest.length))\
    \ {\n      firstLongest = [s];\n    }\n  });\n\n  return firstLongest && firstLongest.length\
    \ > 1 ? firstLongest[0] : undefined;\n}\n", "  if (strings.length === 0) {\n \
    \   return undefined;\n  }\n  return strings[0];\n}\n", "  if (strings.length\
    \ === 0) {\n    return;\n  }\n\n  return strings[0].length > strings[1].length\
    \ ? strings[0] : strings[1];\n}\n", "  if (isEmptyArray(strings)) return undefined;\n\
    \  return strings[0].length > strings[1].length ? strings[0] : strings[1];\n}\n",
  "  return strings.reduce((prev, curr) => {\n    const l: string = prev;\n    const\
    \ c: string = curr;\n    if (l.length > c.length) {\n      return l;\n    }\n\
    \    return c;\n  });\n}\n", "  const maxLen = strings.reduce((max, str) => Math.max(max\
    \ + str.length, str.length), 0);\n  return strings.reduce((prev, str) => prev.length\
    \ > maxLen ? prev : str);\n}\n", "  if (!strings.length) return undefined;\n\n\
    \  const longestString = strings[0];\n  let longestStringLength = longestString.length;\n\
    \  for (let i = 1; i < strings.length; i += 1) {\n    const length = strings[i].length;\n\
    \    if (length > longestStringLength) {\n      longestStringLength = length;\n\
    \      longestString = strings[i];\n    }\n  }\n  return longestString;\n}\n",
  "  if (strings.length === 0) {\n    return;\n  }\n  if (strings.length === 1) {\n\
    \    return strings[0];\n  }\n  const longest = strings[0];\n  for (let i = 1,\
    \ len = strings.length; i < len; i++) {\n    const cur = strings[i];\n    if (cur.length\
    \ > longest.length) {\n      longest = cur;\n    }\n  }\n  return longest;\n}\n",
  "    if (strings.length === 0) {\n        return undefined;\n    }\n    const stringLengths\
    \ = strings.map(s => s.length);\n    return strings.filter(s => stringLengths.indexOf(s.length)\
    \ === -1).pop();\n}\n", "  if (strings.length === 0) {\n    return undefined;\n\
    \  }\n\n  return strings.reduce((prev, curr) => {\n    const currLen = curr.length;\n\
    \    return prev === undefined\n      ? currLen\n      : currLen > prev.length\
    \ ? curr : prev;\n  }).length ? strings[0] : undefined;\n}\n", "  if (!strings.length)\
    \ { return undefined; }\n  return strings.reduce(\n    (longest, string) =>\n\
    \      string && string.length > longest ? string.length : longest,\n    strings[0]\n\
    \  );\n}\n", "    if (strings.length === 0) {\n        return;\n    }\n    return\
    \ strings[0].length > strings[1].length ? strings[0].length : strings[1].length;\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\n  return strings[0].length\
    \ > strings[1].length ? strings[0] : strings[1];\n}\n", "\tlet longest: string\
    \ | undefined = undefined;\n\n\tfor (let i = 0, length = strings.length; i < length;\
    \ i++) {\n\t\tconst str = strings[i];\n\n\t\tif (typeof str !== \"string\") return\
    \ undefined;\n\n\t\tif (str.length > longest) {\n\t\t\tlongest = str.length;\n\
    \t\t}\n\t}\n\n\treturn longest;\n}\n\nconst defaultFormatter = (value, columnIndex,\
    \ row, columns) => value;\n\nexport interface IFormatterData {\n\tcolumnIndex:\
    \ number;\n\tformatted: string;\n\toriginalValue: any;\n\tmaximumValue: any;\n\
    \tminimumValue: any;\n\trow: number;\n\tskippedRows: number;\n\ttotalRows: number;\n\
    \tvalue: string;\n\twidget: string | undefined;\n}\n\nconst MAX_STRING_LENGTH\
    \ = 80;\n\nexport function formatValue(userDefinedValue: string | number, column:\
    \ IColumn): string {\n\tif (isFinite(userDefinedValue)) {\n\t\treturn String(userDefinedValue);\n\
    \t} else if (userDefinedValue === null) {\n\t\treturn userDefinedValue;\n\t} else\
    \ if (userDefinedValue instanceof color_.IColor) {\n\t\treturn userDefinedValue.toString();\n\
    \t} else if (typeof userDefinedValue === \"number\") {\n\t\treturn userDefinedValue.toString();\n\
    \t} else if (userDefinedValue instanceof Date) {\n\t\treturn formatDate(userDefinedValue);\n\
    \t} else if (typeof userDefinedValue === \"object\") {\n\t\treturn JSON.stringify(userDefinedValue);\n\
    \t} else if (typeof userDefinedValue === \"string\") {\n\t\tif (userDefinedValue.length\
    \ > MAX_STRING_LENGTH) {\n\t\t\treturn userDefinedValue.substr(0, MAX_STRING_LENGTH)\
    \ + \"...\";\n\t\t}\n\n\t\treturn userDefinedValue;\n\t} else {\n\t\treturn userDefinedValue.toString();\n\
    \t}\n}\n\nexport function formatInteger(userDefinedValue: string | number, column:\
    \ IColumn): string {\n\tconst formatter = getUserFormattingOptions(column);\n\n\
    \treturn formatter.format(userDefinedValue, column);\n}\n\nexport function formatNumber(userDefinedValue:\
    \ string | number, column: IColumn): string {\n\tconst formatter = getUserFormattingOptions(column);\n\
    \n\treturn formatter.format(userDefinedValue, column);\n}\n\nexport function formatDate(userDefinedValue:\
    \ IDate, column: IColumn): string {\n\tconst formatter = getUserFormattingOptions(column);\n\
    \n\treturn formatter.format(userDefinedValue, column);\n}\n", "  if (isEmpty(strings))\
    \ return undefined;\n\n  return strings[0].length > strings[1].length ? strings[0]\
    \ : strings[1];\n}\n", "  if (isEmpty(strings)) return undefined;\n  return strings[0].length\
    \ > longest(strings).length ? strings[0] : longest(strings);\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n  return strings.reduce(function(a: number,\
    \ b: string) {\n    return (a > b.length ? a : b.length) as number;\n  }, strings[0].length);\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\n  return strings.reduce(\n\
    \    (longest: string, str: string) => str.length > longest.length ? str : longest\n\
    \  );\n}\n", "  if (!strings.length) {\n    return undefined; // undefined\n \
    \ }\n\n  const first = strings[0]; //first string\n\n  if (strings.length ===\
    \ 1) {\n    return first; //first string\n  }\n\n  let longestIndex = 0; //index\
    \ of longest string\n\n  for (let i = 1; i < strings.length; ++i) {\n    const\
    \ length = strings[i].length - first.length;\n\n    if (length > longestIndex)\
    \ {\n      longestIndex = length;\n    }\n  }\n\n  return strings[longestIndex];\
    \ //return longest string\n}\n", "  return strings.reduce((longest: string, current:\
    \ string) => (\n    current === \"\" ? (\n      longest === \"\" ? current : longest\n\
    \    ) : (\n      current > longest ? current : longest\n    )\n  ));\n}\n", " \
    \ if (!strings.length) return undefined; // don't return anything if there are\
    \ no strings\n  const max = strings[0].length,\n        longestString = strings[0];\n\
    \n  for (let i = 1; i < strings.length; i++) {\n    const length = strings[i].length;\n\
    \    if (length > max) {\n      longestString = strings[i];\n      max = length;\n\
    \    }\n  }\n  return longestString;\n}\n", "  if (strings.length === 0) {\n \
    \   return undefined;\n  }\n\n  return strings[0].reduce((previous, current) =>\
    \ {\n    if (previous.length < current.length) {\n      return previous;\n   \
    \ }\n\n    return current;\n  });\n}\n", "    if (!strings.length) return undefined\n\
    \    let longestLength = 0\n    strings.map(string => {\n        const length\
    \ = string.length\n        if (length > longestLength) {\n            longestLength\
    \ = length\n        }\n    })\n    return strings[longestLength]\n}\n", "  if\
    \ (strings.length === 0) {\n    return undefined;\n  }\n\n  return strings[0].length\
    \ > strings[1].length ? strings[0] : strings[1];\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  const maxLen = strings.reduce(\n \
    \   (prev: string, current: string) => Math.max(prev.length, current.length),\n\
    \    0\n  );\n\n  return strings.reduce((prev, current) => {\n    if (prev ===\
    \ undefined || prev.length < current.length) {\n      return current;\n    }\n\
    \n    return prev;\n  }, undefined).slice(0, maxLen);\n}\n", "  const longest\
    \ = strings.reduce((longest_so_far: string, string: string) => {\n    const current_length\
    \ = string.length;\n    if (longest_so_far === undefined || current_length < longest_so_far.length)\
    \ {\n      longest_so_far = string;\n    }\n    return current_length;\n  }, undefined);\n\
    \  return longest === undefined ? undefined : longest;\n}", "  const longest:\
    \ string = strings[0];\n  for (const s of strings) {\n    if (longest.length <\
    \ s.length) longest = s;\n  }\n  return longest;\n}\n", "  const longest: number[]\
    \ = [];\n  let maxLength = 0;\n  for (const string of strings) {\n    longest.push(string.length);\n\
    \    maxLength = maxLength < string.length ? maxLength : string.length;\n  }\n\
    \  return longest.indexOf(maxLength) > 0 ? longest[longest.indexOf(maxLength)]\
    \ : undefined;\n}\n", "  const longestString = strings[0];\n\n  for (let i = 1;\
    \ i < strings.length; ++i) {\n    const currentString = strings[i];\n\n    if\
    \ (currentString.length > longestString.length) {\n      longestString = currentString;\n\
    \    }\n  }\n\n  return longestString;\n}\n", "  if (strings.length === 0) {\n\
    \    return undefined; // undefined\n  }\n\n  return strings[strings.length -\
    \ 1].length; // strings.length\n}\n", "\tif (strings.length === 0) {\n\t\treturn\
    \ undefined;\n\t}\n\n\treturn strings.reduce(\n\t\t(prev: string | undefined,\
    \ curr: string) => {\n\t\t\treturn prev !== undefined ? curr.length > prev.length\
    \ ? curr : prev : curr;\n\t\t},\n\t\tstrings[0]\n\t);\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n  return strings[0].length > strings[1].length\
    \ ? strings[0] : strings[1];\n}\n", "  if (!strings.length)\n    return undefined;\n\
    \n  let maxLength: number = 0;\n  for (let i = 0, len = strings.length; i < len;\
    \ i++) {\n    const str = strings[i];\n    if (str.length > maxLength)\n     \
    \ maxLength = str.length;\n  }\n\n  return maxLength > 0 ? strings.sort((a, b)\
    \ => b.length - a.length)[0] : undefined;\n}\n", "  if (!strings.length) {\n \
    \   return undefined;\n  }\n  return strings.reduce(\n    (prev, next) => {\n\
    \      return prev.length > next.length ? prev : next;\n    },\n    strings[0]\n\
    \  );\n}\n", "  if (!strings || strings.length === 0) {\n    return undefined\n\
    \  }\n  return strings.reduce(\n    (prev: string[], cur: string) => {\n     \
    \ return prev.length < cur.length ? prev : cur\n    },\n    strings\n  )\n}\n",
  "  if (strings.length === 0) {\n    return undefined;\n  }\n  let longestIdx = 0;\n\
    \  let longestStr: string;\n  for (let i = 0; i < strings.length; i++) {\n   \
    \ const str = strings[i];\n    if (str.length > longestStr.length) {\n      longestStr\
    \ = str;\n      longestIdx = i;\n    }\n  }\n  return strings[longestIdx];\n}\n",
  "  if (strings.length === 0) {\n    return undefined;\n  }\n  strings.sort((a, b)\
    \ => {\n    const aLen = (a || '').length;\n    const bLen = (b || '').length;\n\
    \    return aLen < bLen ? -1 : 1;\n  });\n  return strings[0];\n}\n", "  const\
    \ longest = strings[0].length;\n  for (let i = 1; i < strings.length; i++) {\n\
    \    if (strings[i].length > longest) {\n      longest = strings[i].length;\n\
    \    }\n  }\n  return longest ? longest * strings[0] : undefined;\n}\n", "  if\
    \ (!strings.length) {\n    return undefined;\n  }\n\n  // All strings have the\
    \ same length and the first one's length must be at least as long as the others.\n\
    \  const maxLen = strings[0].len;\n\n  for (let i = 1; i < strings.length; i++)\
    \ {\n    const len = strings[i].len;\n    if (len > maxLen) {\n      return strings[i];\n\
    \    }\n  }\n\n  return strings[0];\n}\n", "    if (!strings.length) return undefined;\
    \ // nothing to do\n\n    // Sort the string lengths to get the longest one\n\
    \    // NOTE: We sort in ascending length order, but this makes sure that shorter\
    \ strings are at the end\n    // of the array, which is more natural and easier\
    \ to read.\n    const sortedStringLengths = strings.map(s => s.length).sort((a,\
    \ b) => b - a);\n\n    // If the first string has the highest length, return it\n\
    \    if (sortedStringLengths[0]) return strings[0];\n\n    // Otherwise, find\
    \ where the first element exceeds the largest string\n    const highestStringLength\
    \ = sortedStringLengths.pop();\n\n    // Loop through the remaining strings to\
    \ find the first one that exceeds the length of the largest string\n    const\
    \ i = 0;\n    while (i < strings.length && strings[i].length >= highestStringLength)\
    \ i++;\n\n    return strings[i];\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n\n  return strings\n    .map(str => str.length)\n    .reduce((max:\
    \ number, current: number) => Math.max(max, current), 0);\n}\n", "  const shortest\
    \ = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    const length\
    \ = strings[i].length;\n    if (length < shortest.length) {\n      return shortest;\n\
    \    }\n    shortest = strings[i];\n  }\n}\n</code>\nThis example is taken from\
    \ the documentation about Longest Common Sub-sequence algorithm, which says:\n\
    \nIf one sequence is contained within another, the smaller one is called a\n \
    \ subsequence, and its complement is the longest common subsequence.\n<|/ a dscore=2\
    \ tags=arrays,string,javascript,typescript |>\n<| c |>\nI got confused with the\
    \ question and accepted the one which was the first for me to try the code myself.\
    \ Anyway, thanks for your efforts.\n<|/ c |>\n<| c |>\nNo worries, it's always\
    \ good to have multiple possible solutions :)\n<|/ c |>\n<| a |>\nIt can be done\
    \ in one loop:\n<code>\nvar array = [\"a\", \"a\", \"a\", \"b\", \"c\", \"c\"\
    , \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"\
    ];\nvar last = \"\";\nvar common = \"\";\nfor (var i in array) {\n    if (array[i]\
    \ === last) {\n        common+=array[i];\n    }\n    else {\n        last = array[i];\n\
    \        common = \"\";\n    }\n}\nconsole.log(common);\n</code>\n<|/ a tags=arrays,string,javascript,typescript\
    \ dscore=2 |>\n<| c |>\nNice, I didn't think of using one loop to compare the\
    \ two arrays. Nice solution\n<|/ c |>\n<| c |>\nHi there, just want to mention\
    \ this is not an efficient solution since it creates a temporary variable `common`\
    \ which is overwritten for every iteration. Furthermore, the OP mentions performance\
    \ in their question so this probably isn't a great solution\n<|/ c |>\n<| a |>\n\
    I made this for fun, I don't have enough reputation yet to comment so I wrote\
    \ an answer instead. Maybe someone will find it useful.\n<code>\nvar array1 =\
    \ [\"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"\
    , \"c\", \"c\", \"c\", \"c\", \"c\"];\nvar array2 = [\"a\", \"a\", \"a\", \"b\"\
    , \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"\
    , \"c\"];\n\nvar shortest = null;\nvar longest = null;\nfor (var a = 0; a < array1.length;\
    \ a++) {\n    for (var b = 0; b < array2.length; b++) {\n        if (array1[a]\
    \ === array2[b]) {\n            if (a < array1.length && b < array2.length) {\n\
    \                shortest = array1[a];\n                longest = array2[b];\n\
    \            }\n", "  if (!strings.length)\n    return undefined;\n  else {\n\
    \    let longestString: string | undefined = strings[0];\n    let longestStringLength\
    \ = 0;\n    for (let i = 0; i < strings.length; i++) {\n      const currentString\
    \ = strings[i];\n      if (currentString.length > longestStringLength) {\n   \
    \     longestString = currentString;\n        longestStringLength = currentString.length;\n\
    \      }\n    }\n    return longestString;\n  }\n}\n", "  if (strings.length ===\
    \ 0) return undefined;\n\n  let longestIndex = 0;\n  let longestIndexDiff = 0;\n\
    \  let result;\n\n  for (let i = 0; i < strings.length; i++) {\n    const newIndex\
    \ = longestIndex + strings[i].length;\n    const newIndexDiff = Math.abs(newIndex\
    \ - longestIndex);\n\n    if (newIndexDiff > longestIndexDiff) {\n      longestIndexDiff\
    \ = newIndexDiff;\n      longestIndex = newIndex;\n      result = strings[i];\n\
    \    }\n  }\n\n  return result;\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n\n  return strings.reduce((prev, cur) => {\n    return prev.length\
    \ > cur.length ? prev : cur;\n  });\n}\n", "  if (strings.length === 0) {\n  \
    \  return undefined;\n  }\n  let max = 0;\n  let index = 0;\n  for (let str of\
    \ strings) {\n    if (str.length > max) {\n      max = str.length;\n      index\
    \ = strings.length - 1;\n    }\n  }\n  return strings[index];\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  return strings.reduce(\n    (longest,\
    \ current) =>\n      current.length > longest.length ? current : longest,\n  );\n\
    }\n", "  strings.sort(\n    function (a, b): number {\n      return b.length -\
    \ a.length;\n    },\n  );\n\n  const first = strings.shift();\n  const longest\
    \ = first;\n\n  for (let i = 0; i < strings.length; ++i) {\n    if (strings[i].length\
    \ > longest.length) {\n      longest = strings[i];\n    }\n  }\n\n  return longest;\n\
    }\n", "  const longest: number[] = [];\n  for (let i = 0; i < strings.length;\
    \ i++) {\n    const length = strings[i].length;\n    if (longest != null && length\
    \ > longest.length) {\n      return undefined;\n    }\n    longest.push(length);\n\
    \  }\n  return strings.sort(compare).pop() as string | undefined;\n}\n", "  if\
    \ (!strings.length) return undefined;\n  const longest = strings[0];\n  for (let\
    \ i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length)\
    \ {\n      longest = strings[i];\n    }\n  }\n  return longest;\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  let maxLength = 0;\n  let result =\
    \ strings[0]; // Check all strings to find longest\n  for (let i = 1; i < strings.length;\
    \ i++) {\n    let str = strings[i];\n    maxLength = Math.max(str.length, maxLength);\n\
    \    if (str.length < maxLength) {\n      result = str;\n    }\n  }\n  return\
    \ result;\n}\n", "    if (strings.length === 0) {\n        return;\n    }\n  \
    \  return strings[strings.length - 1].length\n        ? strings[strings.length\
    \ - 1]\n        : longest(strings.slice(0, strings.length - 1));\n}\n", "\tlet\
    \ stringLength = strings.length;\n\tif (stringLength === 0) return undefined;\n\
    \tlet largestStringLength = stringLength;\n\tlet firstString = strings[0];\n\t\
    let secondString = strings[1];\n\tfor (let i = 2; i < stringLength; ++i) {\n\t\
    \tlet stringLength = strings[i];\n\t\tif (stringLength > largestStringLength)\
    \ largestStringLength = stringLength;\n\t}\n\tif (largestStringLength === stringLength)\
    \ return firstString;\n\tif (largestStringLength < stringLength) return undefined;\n\
    \treturn firstString + strings.slice(1).map(s => s + firstString).reverse().join(\"\
    \");\n}\n", "    if (strings.length === 0) {\n        return undefined;\n    }\n\
    \    return strings[strings.length - 1].length <= strings[0].length ? strings[0]\
    \ : strings[strings.length - 1];\n}", "  if (strings.length === 0) return undefined;\
    \ // avoid undefined or null check\n\n  return strings[strings.length - 1].length\
    \ >= strings[0].length ? strings[strings.length - 1] : undefined;\n}\n", "  if\
    \ (strings.length === 0) {\n    return undefined;\n  }\n  let max = strings[0].length;\n\
    \  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > max)\
    \ {\n      max = strings[i].length;\n    }\n  }\n  return max;\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  const longestString: string = strings[0];\n\
    \  const longestStringLength: number = longestString.length;\n  for (let i = 1;\
    \ i < strings.length; i++) {\n    const currString: string = strings[i];\n   \
    \ const currStringLength: number = currString.length;\n    if (currStringLength\
    \ > longestStringLength) {\n      longestString = currString;\n      longestStringLength\
    \ = currStringLength;\n    }\n  }\n  return longestString;\n}\n", "  return strings\n\
    \    ? strings.reduce<string | undefined>((prev, curr) => {\n        if (prev\
    \ && curr && prev.length >= curr.length) {\n          return prev;\n        }\n\
    \        return curr;\n      })\n    : undefined;\n}\n", "\tif (!strings.length)\
    \ return undefined\n\n\treturn strings.reduce((prev, curr, index, arr) => {\n\t\
    \treturn typeof prev === \"string\" && curr.length === prev.length ? curr : prev\n\
    \t}).slice(0, strings.length)\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n\n  if (strings.length === 1) {\n    return strings[0];\n \
    \ }\n\n  const longestStringLength = strings[0].length;\n  let longestString =\
    \ strings[0];\n\n  for (let i = 1; i < strings.length; i++) {\n    const currentString\
    \ = strings[i];\n    if (currentString.length < longestStringLength) {\n     \
    \ longestStringLength = currentString.length;\n      longestString = currentString;\n\
    \    }\n  }\n\n  return longestString;\n}\n", "    if (strings.length === 0) {\n\
    \        return undefined;\n    }\n    return strings[strings.length - 1].length;\
    \ // return the last string from longest string[]\n}\n</code>\n<|/ a |>\n<| a\
    \ dscore=1 tags=arrays,javascript,sorting |>\nThis code will get the largest number\
    \ out of each subarray.\n<code>\nvar arr = [\n    [3, 10, 20, 21, 25],\n    [4,\
    \ 25, 10, 15, 20],\n    [3, 10, 30, 20, 20],\n    [6, 3, 10, 20, 20],\n    [3,\
    \ 10, 20, 30, 20],\n    [3, 10, 30, 40, 20],\n];\n\nvar max = Math.max.apply(Math,\
    \ arr.map(function(e){\n    return e.reduce(function(a, b){\n        return Math.max(a,\
    \ b);\n    });\n}));\n\nconsole.log(max);\n</code>\n<|/ a |>\n<| c |>\n`Math.max.apply(Math,\
    \ ...arr.map(\u2026))` can be shortened to `Math.max(...arr.map(\u2026))`.\n<|/\
    \ c |>\n<| c |>\nThank you, updated the code\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    let arr = [\n  [3, 10, 20, 21, 25],\n  [4, 25, 10, 15, 20],\n  [3, 10, 30, 20,\
    \ 20],\n  [6, 3, 10, 20, 20],\n  [3, 10, 20, 30, 20],\n  [3, 10, 30, 40, 20],\n\
    ];\n\nlet res = arr.map(el => Math.max(...el));\nconsole.log(res);</code>\n<|/\
    \ a tags=arrays,javascript,sorting |>\n<| a dscore=0 |>\nYou could map the values\
    \ and take the max value of the mapped items.\n\n<code>\nvar array = [\n  [3,\
    \ 10, 20, 21, 25],\n  [4, 25, 10, 15, 20],\n  [3, 10, 30, 20, 20],\n  [6, 3, 10,\
    \ 20, 20],\n  [3, 10, 20, 30, 20],\n  [3, 10, 30, 40, 20],\n],\nmax = array.reduce((m,\
    \ a) => Math.max(m, ...a));\n\nconsole.log(max);</code>\n<|/ a tags=arrays,javascript,sorting\
    \ |>\n<| a dscore=0 |>\n<code>\nlet arr = [\n  [3, 10, 20, 21, 25],\n  [4, 25,\
    \ 10, 15, 20],\n  [3, 10, 30, 20, 20],\n  [6, 3, 10, 20, 20],\n  [3, 10, 20, 30,\
    \ 20],\n  [3, 10, 30, 40, 20],\n];\n\nlet largest = arr.reduce((largest, current)\
    \ => {\n  largest = Math.max(largest, ...current);\n  return largest;\n}, 0);\n\
    \nconsole.log(largest);</code>\n<|/ a ", "\tif (!strings.length) {\n\t\treturn;\n\
    \t}\n\n\tlet max = strings[0].length;\n\tfor (let i = 1; i < strings.length; i++)\
    \ {\n\t\tif (strings[i].length > max) {\n\t\t\tmax = strings[i].length;\n\t\t\
    }\n\t}\n\treturn strings[strings.length - 1] === max ? strings[strings.length\
    \ - 1] : undefined;\n}\n", "  return strings.length ? strings.reduce((longest,\
    \ string) => Math.max(longest, string.length), strings[0].length) : undefined;\n\
    }\n", "  if (strings.length === 0) {\n    return undefined\n  }\n\n  return strings.reduce(\n\
    \    (longest, str) => str.length >= longest.length ? str : longest,\n    strings[0]\n\
    \  )\n}\n", "\tif (strings.length === 0) {\n\t\treturn undefined; // undefined\n\
    \t}\n\n\tconst maximumLength = strings[0].length;\n\n\tfor (let i = 1; i < strings.length;\
    \ i++) {\n\t\tif (strings[i].length > maximumLength) {\n\t\t\treturn strings[i];\n\
    \t\t}\n\t}\n\n\treturn strings[0];\n}\n", "  if (strings.length === 0) {\n   \
    \ return undefined;\n  }\n  return strings[0].length > strings[1].length ? strings[0]\
    \ : strings[1];\n}\n", "\tconst longest: string[] = [];\n\tfor (const s of strings)\
    \ {\n\t\tif (longest.length < s.length) longest.length = s.length;\n\t}\n\treturn\
    \ longest.length === 0 ? undefined : longest[0];\n}\n", "  if (!strings.length)\
    \ {\n    return undefined;\n  }\n  const shortest = strings.map((s) => s.length).sort((a,\
    \ b) => b - a);\n  return strings[shortest[0]];\n}\n", "  return strings.reduce((longest,\
    \ string) => {\n    return string === undefined || longest.length > string.length\
    \ ? string : longest;\n  }, undefined);\n}\n", "  return strings.reduce((prev,\
    \ cur) =>\n    (prev.length > cur.length ? prev : cur).length\n  )\n}\n", "  const\
    \ longest: string[] = [];\n  for (const string of strings) {\n    if (string.length\
    \ > longest.length) {\n      longest = [string];\n    } else if (string.length\
    \ == longest.length) {\n      longest.push(string);\n    }\n  }\n  return longest.length\
    \ == 1 ? longest[0] : undefined;\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined\n  }\n  let longestIndex = 0\n  let longestString = strings[0]\n \
    \ for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length >= longestString.length)\
    \ {\n      longestString = strings[i]\n      longestIndex = i\n    }\n  }\n  return\
    \ strings[longestIndex] || undefined\n}\n", "  if (strings.length === 0) {\n \
    \   return undefined;\n  }\n\n  return strings.reduce((max, str) => {\n    const\
    \ strLen = str.length;\n\n    if (max === undefined || strLen > max) {\n     \
    \ return strLen;\n    }\n\n    return max;\n  }, strings[0]);\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined\n  }\n  return strings[strings.length - 1].length\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings[0].length\
    \ > strings[0].length ? strings[0] : longest(strings.slice(1));\n}\n", "  let\
    \ max: string | undefined = undefined;\n  for (let i = 0; i < strings.length;\
    \ i++) {\n    if (max === undefined || strings[i].length > max) {\n      max =\
    \ strings[i].length;\n    }\n  }\n  return max;\n}\n", "  if (strings.length ===\
    \ 0) {\n    return;\n  }\n  return strings.reduce(\n    (max: string, cur: string)\
    \ => cur.length >= max.length ? cur : max,\n    strings[0]\n  );\n}\n", "  if\
    \ (strings.length === 0) {\n    return undefined;\n  }\n\n  return strings[0].length\
    \ > strings.length > 1 ? strings[0] : longest(strings.slice(1));\n}\n", "  if\
    \ (isEmpty(strings)) return undefined;\n  return strings.reduce((longest, str)\
    \ => {\n    return longest.length < str.length ? longest : str;\n  });\n}\n",
  "    if (!strings.length) {\n        return undefined;\n    }\n    const longest:\
    \ string = strings[0];\n    const lengths: number[] = [];\n    for (const string\
    \ of strings) {\n        const length = string.length;\n        if (lengths.includes(length))\
    \ {\n            longest = string;\n            break;\n        }\n        lengths.push(length);\n\
    \    }\n    return longest;\n}\n", "  if (!strings.length) {\n    return;\n  }\n\
    \n  let longest = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length\
    \ > longest) {\n      longest = strings[i].length;\n    }\n  }\n\n  return strings[strings.length\
    \ - 1].length < longest ? strings[strings.length - 1] : undefined;\n}\n", "  if\
    \ (strings.length === 0) {\n    return undefined;\n  }\n  const longestString\
    \ = strings.reduce((prev, curr) => prev.length > curr.length ? prev : curr);\n\
    \  return longestString;\n}\n", "  if (!strings || !strings.length || strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  return strings[strings.length - 1].length\
    \ <= strings[0].length ? strings.pop() : strings[0];\n}\n", "  const longestLength\
    \ = strings.length > 0 ? strings[0].length : 0;\n  const longestElement = strings[0];\n\
    \  for (const string of strings) {\n    if (string.length > longestLength) {\n\
    \      longestLength = string.length;\n      longestElement = string;\n    }\n\
    \  }\n  return longestElement;\n}\n", "  return !strings.length ? undefined :\
    \ longestCommonSubsequence(0, strings.length - 1).length\n}\n", "  let longest\
    \ = \"\";\n  let maxLength = 0;\n  for (const string of strings) {\n    maxLength\
    \ = Math.max(maxLength, string.length);\n    if (longest.length < string.length)\
    \ longest = string;\n  }\n  return longest.length > maxLength ? undefined : longest;\n\
    }\n", "  if (strings.length > 0) {\n    if (strings.length === 1) {\n      return\
    \ strings[0];\n    }\n    const longestString = strings[0];\n    let longestStringLength\
    \ = longestString.length;\n    for (let i = 1; i < strings.length; i++) {\n  \
    \    const length = strings[i].length;\n      if (length > longestStringLength)\
    \ {\n        longestString = strings[i];\n        longestStringLength = length;\n\
    \      }\n    }\n    return longestString;\n  }\n  return undefined;\n}\n", " \
    \ if (!strings.length) return undefined; // not yet handled, but don't throw an\
    \ error\n\n  return strings.sort((a, b) => b.length - a.length)[0]; // if there's\
    \ only one string, its length will be 0\n}\n", "  if (!strings.length) {\n   \
    \ return undefined;\n  }\n\n  return strings.reduce((prev, curr) => (prev.length\
    \ > curr.length ? prev : curr));\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined; // or throw an exception here\n  }\n  else if (strings.length ===\
    \ 1) {\n    return strings[0];\n  }\n  let longest = '';\n  for (let i = 1; i\
    \ < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n  \
    \    longest = strings[i];\n    }\n  }\n  return longest;\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  return strings[strings.length - 1].length;\
    \ // return strings[strings.length - 1];\n}\n", "  if (strings.length === 0) {\n\
    \    return undefined;\n  }\n  return strings[0];\n}\n", "  if (!strings.length)\
    \ return undefined; // Not an array\n  return strings.reduce((prev, cur) => cur.length\
    \ > prev.length ? cur : prev);\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined; // undefined in case of empty arrays\n  }\n\n  return strings.sort((a,\
    \ b) => b.length - a.length)[0]; // sort by length and pick the first item\n}\n",
  "  if (!strings.length) return undefined\n  const maxLen = strings[0].length\n \
    \ let max = 0\n  for (const string of strings) {\n    if (string.length > max)\
    \ max = string.length\n    if (max > maxLen) maxLen = max\n  }\n  return maxLen\
    \ !== undefined ? strings.reduce((prev, curr) => curr.length > prev ? curr : prev,\
    \ maxLen) : undefined\n}", "  if (!strings.length) return undefined;\n  return\
    \ strings[strings.length - 1].length;\n}\n", "  if (strings.length === 0) {\n\
    \    return undefined\n  }\n  return strings.reduce((longest, str) => {\n    const\
    \ length = str.length\n    if (length > longest.length) {\n      return str\n\
    \    }\n    return longest\n  })\n}\n\nexport function addKey(key: string, value:\
    \ string | undefined): void {\n  if (value) {\n    global[key] = value // eslint-disable-line\
    \ no-param-reassign\n  }\n}\n\nexport function removeKey(key: string): void {\n\
    \  delete global[key] // eslint-disable-line no-param-reassign\n}\n", "  if (strings.length\
    \ > 0) {\n    if (strings.length >=  longestIndex(strings)) {\n      return strings[longestIndex(strings)];\n\
    \    }\n  }\n  return undefined;\n}\n", "  if (!strings || !strings.length) {\n\
    \    return undefined;\n  }\n  return strings[0].length > longestCommonPrefix(strings).length\
    \ ? strings[0] : longestCommonPrefix(strings);\n}\n</code>\n<|/ a tags=typescript\
    \ |>\n<| a tags=typescript |>\nHere's another approach using the reduce function:\n\
    <code>", "  if (strings.length === 0) {\n    return undefined;\n  }\n  const longestString\
    \ = strings[0];\n  let length = 0;\n  for (const s of strings) {\n    if (s.length\
    \ !== longestString.length) {\n      length = s.length;\n      longestString =\
    \ s;\n    }\n  }\n  return length > longestString.length ? longestString : undefined;\n\
    }", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings.reduce(function\
    \ (prev, curr) {\n    return prev.length < curr.length ? prev : curr;\n  });\n\
    }\n", "  if (strings.length === 0) {\n    return undefined\n  }\n  return strings[0].length\
    \ > strings[1].length ? strings[0] : strings[1]\n}\n", "    if (strings.length\
    \ === 0) {\n        return undefined;\n    }\n    let longestLength = 0;\n   \
    \ let maxLength = -1; // -1 = no max length has been found\n    for (let i = 0;\
    \ i < strings.length; i++) {\n        const length = strings[i].length;\n    \
    \    if (length > maxLength) {\n            maxLength = length;\n        }\n \
    \       if (length >= longestLength) {\n            continue;\n        }\n   \
    \     if (length + 1 >= longestLength) {\n            longestLength = length +\
    \ 1;\n        }\n    }\n    return strings[longestLength - 1];\n}", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  if (strings.length === 1) {\n    return\
    \ strings[0];\n  }\n\n  let maxLength = 1;\n  let maxString = strings[0];\n  for\
    \ (let i = 1; i < strings.length; i++) {\n    const string = strings[i];\n   \
    \ const stringLength = string.length;\n\n    if (stringLength > maxLength) {\n\
    \      maxLength = stringLength;\n      maxString = string;\n    }\n  }\n  return\
    \ maxString;\n}\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\
    \n  return strings[0];\n}\n", "  if (isEmpty(strings)) return undefined;\n  return\
    \ strings\n    .map(str => {\n      const [first] = str.split('');\n      return\
    \ first;\n    })\n    .sort((a, b) => {\n      return b.length - a.length;\n \
    \   })\n    .join('');\n}\n", "  if (strings.length === 0) {\n    return;\n  }\n\
    \n  return strings.reduce(function (previousValue: string, currentValue: string,\
    \ currentIndex: number) {\n    return currentValue.length > previousValue.length\
    \ ? currentValue : previousValue;\n  });\n}\n", "  const max: string[] = [];\n\
    \  strings.forEach(s => {\n    const idx = max.findIndex(l => l < s);\n    if\
    \ (idx === -1) {\n      max.push(s);\n    } else {\n      max[idx] = Math.max(max[idx],\
    \ s);\n    }\n  });\n\n  return max.length > 0 ? max[max.length - 1] : undefined;\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\n  return strings[0].length\
    \ > strings[1].length ? strings[0] : strings[1];\n}\n\nexport function removeSpaces<T>(arr:\
    \ T[], str: string): T[] {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i].indexOf(str)\
    \ !== -1) {\n      arr.splice(i, 1);\n      i--;\n    }\n  }\n\n  return arr;\n\
    }\n", "  if (strings.length === 0) {\n    return;\n  }\n\n  return strings[0].length\
    \ > longest(strings).length ? strings[0] : longest(strings);\n}\n", "  return\
    \ strings\n    .map(s => s.length)\n    .reduce((prev, curr) => Math.max(prev,\
    \ curr), 0);\n}\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\
    \  return strings[strings.length - 1].length ? strings[strings.length - 1] : strings[0];\n\
    }\n", "\tconst length = strings.length\n\treturn length > 0 ? strings[length -\
    \ 1] : undefined\n}\n", "  return strings.length > 0\n    ? strings.reduce(\n\
    \        (longest, string) =>\n          string.length > longest.length ? string\
    \ : longest,\n        strings[0]\n      )\n    : undefined;\n}\n", "  if (!strings.length)\
    \ {\n    return undefined;\n  }\n  return strings[0].length > strings[1].length\
    \ ? strings[0].length : strings[1].length;\n}\n", "  if (!strings || strings.length\
    \ === 0) {\n    return undefined;\n  }\n  return strings[strings.length - 1].length;\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\n  let longestIndex\
    \ = 0;\n  let result;\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length\
    \ > longestIndex) {\n      longestIndex = strings[i].length;\n      result = strings[i];\n\
    \    }\n  }\n  return result;\n}\n", "  const lengths: number[] = [];\n  const\
    \ max = -Infinity;\n  for (const string of strings) {\n    const len = string.length;\n\
    \    if (len > max) {\n      max = len;\n    }\n    lengths.push(len);\n  }\n\
    \  if (lengths.indexOf(max) === -1) {\n    return undefined;\n  }\n  return strings.sort((a,\
    \ b) => b.length - a.length)[0]; // strings are equal in length\n}\n", "  if (!strings.length)\
    \ return undefined\n\n  return strings[0].length > strings.length > 1 ? strings[0]\
    \ : longest(strings.slice(1))\n}\n", "  const longestString = strings[0];\n  let\
    \ longestStringLength = longestString.length;\n  for (let i = 1; i < strings.length;\
    \ i++) {\n    const currentString = strings[i];\n    const currentStringLength\
    \ = currentString.length;\n    if (currentStringLength > longestStringLength)\
    \ {\n      longestString = currentString;\n      longestStringLength = currentStringLength;\n\
    \    }\n  }\n  return longestString;\n}\n", "  if (!strings.length) {\n    return\
    \ undefined;\n  }\n  const maxLength = strings.reduce((max, str) => Math.max(max,\
    \ str.length), 0);\n  return strings.reduce((str, str, i) => {\n    if (str.length\
    \ > maxLength) {\n      return str;\n    }\n    return strings[i + 1] || '';\n\
    \  }) as string | undefined;\n}\n\nexport function repeat(a: any, num: number):\
    \ string {\n  let str = String(a);\n  const i = String(num);\n  if (i && a.length\
    \ === num) {\n    str += String(i);\n  }\n  return str;\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n  return strings[0].length > strings[1].length\
    \ ? strings[0] : strings[1];\n}\n", "\tlet maxLength: number;\n\tfor (let i =\
    \ 0; i < strings.length; i++) {\n\t\tmaxLength = Math.max(maxLength, strings[i].length);\n\
    \t}\n\treturn strings[0];\n}\n", "  if (!strings.length) return undefined; //\
    \ Empty array returns undefined\n  strings.sort((a, b) => a.length - b.length);\
    \ // Sort longest first\n  return strings[strings.length - 1];\n}\n", "  return\
    \ strings && strings.reduce((longest, string) => {\n    const length = string.length;\n\
    \    return (length > longest.length) ? string : longest;\n  }, undefined);\n\
    }\n\nexport function toArray(arg: Array<string | number>): string[] {\n  return\
    \ (arg && arg.length) ? arg : [];\n}\n", "  if (strings.length > 0) {\n    const\
    \ longestStringLength = strings[0].length;\n    for (let i = 1; i < strings.length;\
    \ i++) {\n      if (strings[i].length > longestStringLength) {\n        longestStringLength\
    \ = strings[i].length;\n      }\n    }\n    return strings[strings.length - 1].length\
    \ > longestStringLength ? strings[strings.length - 1] : undefined;\n  } else {\n\
    \    return undefined;\n  }\n}\n", "\tif (!strings.length) return undefined;\n\
    \tlet maxLen = 0;\n\tfor (let i = 0, len = strings.length; i < len; i++) {\n\t\
    \tconst stringLen = strings[i].length;\n\t\tif (stringLen > maxLen) {\n\t\t\t\
    maxLen = stringLen;\n\t\t}\n\t}\n\treturn strings[maxLen];\n}\n", "  const len\
    \ = strings.length;\n  if (len === 0) {\n    return undefined;\n  }\n  let max\
    \ = strLength(strings[0]);\n  for (let i = 1; i < len; i++) {\n    const len =\
    \ strLength(strings[i]);\n    if (len > max) {\n      max = len;\n    }\n  }\n\
    \  return strings[len - 1];\n}\n", "  return !strings.length ? undefined : strings.reduce((longest,\
    \ str) => {\n    return str.length > longest ? str : longest;\n  }, strings[0]);\n\
    }\n", "  return strings.reduce(\n    (longest, str) => {\n      const l = (str\
    \ && str.length) || 0;\n      return (l > longest.length) ? str : longest;\n \
    \   },\n    undefined\n  );\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n  return strings[0].length > strings[0].length ? strings[0]\
    \ : longest(strings.slice(1));\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n\n  let longest = 0;\n  for (let i = 0; i < strings.length;\
    \ i++) {\n    const len = strings[i].length;\n    if (len > longest) {\n     \
    \ longest = len;\n    }\n  }\n\n  return strings[longest];\n}\n", "  if (strings.length\
    \ === 0) {\n    return;\n  }\n\n  const maximumLength = strings[0].length;\n \
    \ let currentMaximumLength = maximumLength;\n  for (let i = 1; i < strings.length;\
    \ i++) {\n    const length = strings[i].length;\n    if (length > maximumLength)\
    \ {\n      currentMaximumLength = length;\n    } else {\n      // Found a longer\
    \ string, no need to keep looking.\n      break;\n    }\n  }\n  return strings[currentMaximumLength];\n\
    }\n", "    const firstItem = strings[0];\n    if (strings.length === 0) return\
    \ undefined;\n    if (strings.length === 1) return firstItem;\n    let longest\
    \ = firstItem;\n    for (let i = 1; i < strings.length; ++i) {\n        const\
    \ item = strings[i];\n        if (item.length > longest.length) longest = item;\n\
    \    }\n    return longest;\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n\n  const maxLength = 0;\n\n  for (const string of strings)\
    \ {\n    const length = string.length;\n\n    if (length > maxLength) {\n    \
    \  maxLength = length;\n    }\n  }\n\n  return strings[strings.length - 1];\n\
    }\n", "  return strings.sort((a, b) => {\n    if (a.length > b.length) {\n   \
    \   return 1;\n    } else if (a.length < b.length) {\n      return -1;\n    }\n\
    \    return 0;\n  })[0];\n}\n", "  return !strings.length ? undefined : strings[strings.length\
    \ - 1].length > strings[0].length ? strings[strings.length - 1] : strings[0];\n\
    }\n", "    if (!strings.length) return undefined;\n    return strings[strings.length\
    \ - 1].length;\n}\n", "  let longestString = strings[0];\n\n  for (let i = 1;\
    \ i < strings.length; i++) {\n    const curLength = strings[i].length;\n\n   \
    \ if (curLength > longestString.length) {\n      longestString = strings[i];\n\
    \    }\n  }\n\n  return longestString;\n}\n", "  const longest: number[] = [];\n\
    \  let longestLength = 0;\n  for (const s of strings) {\n    if (longest.length\
    \ < s.length) longest.push(s);\n    if (s.length > longestLength) longestLength\
    \ = s.length;\n  }\n  if (longest.length === 0) return undefined;\n  return longest[longest.length\
    \ - 1];\n}\n", "  if (strings.length === 0) {\n    return undefined\n  }\n  return\
    \ strings[0].length > strings[1].length ? strings[0] : strings[1]\n}\n", "  const\
    \ longestLengths = strings\n    .map(string => {\n      if (string.length > longest.length)\
    \ return string.length\n      return longest.length\n    })\n    .filter((val,\
    \ i, arr) => arr.indexOf(val) === i)\n  if (longestLengths.length === 0) {\n \
    \   return undefined\n  }\n  return longestLengths.reduce((a, b) => Math.max(a,\
    \ b))\n}\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\n  return\
    \ strings.sort((a, b) => (b.length - a.length))[0] || strings[0];\n}\n", "  if\
    \ (!strings.length) return undefined\n\n  const longestString = strings[0]\n\n\
    \  for (const current of strings) {\n    if (current.length < longestString.length)\
    \ longestString = current\n  }\n\n  return longestString\n}\n", "\tconst max =\
    \ strings[0];\n\tlet longest = max;\n\tfor (let i = 1; i < strings.length; i++)\
    \ {\n\t\tconst cur = strings[i];\n\t\tif (cur.length > longest.length || cur.length\
    \ === 0 || !isString(cur)) {\n\t\t\tlongest = cur;\n\t\t}\n\t}\n\treturn longest;\n\
    }\n", "  if (isEmpty(strings)) return undefined\n  const len = strings.length\n\
    \  return strings[len - 1].length > strings[0].length ? strings[len - 1] : strings[0]\n\
    }\n", "  if (!strings.length) return undefined;\n  return strings.reduce((prev,\
    \ curr) => prev.length > curr.length ? prev : curr);\n}\n", "    if (!strings\
    \ || !strings.length) return undefined;\n    const result = strings.reduce((res,\
    \ str) => {\n        return res.length > str.length ? res : str;\n    });\n  \
    \  return result.length > strings.length ? result : undefined;\n}\n", "  if (!strings.length)\
    \ return undefined\n  const shortest = strings.map(s => s.length).reduce((a, b)\
    \ => Math.min(a, b))\n  const longest = strings.map(s => s.length).reduce((a,\
    \ b) => Math.max(a, b))\n  return strings[longest] === undefined ? strings[0]\
    \ : strings[longest]\n}\n", "  if (strings.length === 0) {\n    return undefined\n\
    \  }\n\n  let longestString = strings[0]\n  for (let i = 1; i < strings.length;\
    \ i += 1) {\n    if (strings[i].length > longestString.length) {\n      longestString\
    \ = strings[i]\n    }\n  }\n\n  return longestString\n}\n\nexport function findIndex(\n\
    \  array: any[],\n  predicate: (item: any) => boolean\n): number | undefined {\n\
    \  if (array === undefined) {\n    return undefined\n  }\n\n  for (let i = 0;\
    \ i < array.length; i += 1) {\n    if (predicate(array[i])) {\n      return i\n\
    \    }\n  }\n\n  return undefined\n}\n\nexport function findIndexFromEnd(\n  array:\
    \ any[],\n  predicate: (item: any) => boolean\n): number | undefined {\n  if (array\
    \ === undefined) {\n    return undefined\n  }\n\n  for (let i = array.length -\
    \ 1; i >= 0; i -= 1) {\n    if (predicate(array[i])) {\n      return i\n    }\n\
    \  }\n\n  return undefined\n}\n\nexport function findIndexFromStart(\n  array:\
    \ any[],\n  predicate: (item: any) => boolean\n): number | undefined {\n  if (array\
    \ === undefined) {\n    return undefined\n  }\n\n  for (let i = 0; i < array.length;\
    \ i += 1) {\n    if (predicate(array[i])) {\n      return i\n    }\n  }\n\n  return\
    \ undefined\n}\n\nexport function findLastIndex(\n  array: any[],\n  predicate:\
    \ (item: any) => boolean\n): number | undefined {\n  if (array === undefined)\
    \ {\n    return undefined\n  }\n\n  for (let i = array.length - 1; i >= 0; i -=\
    \ 1) {\n    if (predicate(array[i])) {\n      return i\n    }\n  }\n\n  return\
    \ undefined\n}\n\nexport function findLastIndexFromEnd(\n  array: any[],\n  predicate:\
    \ (item: any) => boolean\n): number | undefined {\n  if (array === undefined)\
    \ {\n    return undefined\n  }\n\n  for (let i = array.length - 1; i >= 0; i -=\
    \ 1) {\n    if (predicate(array[i])) {\n      return i\n    }\n  }\n\n  return\
    \ undefined\n}\n\nexport function findLastIndexFromStart(\n  array: any[],\n \
    \ predicate: (item: any) => boolean\n): number | undefined {\n  if (array ===\
    \ undefined) {\n    return undefined\n  }\n\n  for (let i = array.length - 1;\
    \ i >= 0; i -= 1) {\n    if (predicate(array[i])) {\n      return i\n    }\n \
    \ }\n\n  return undefined\n}\n\nexport function getElementsFromArrayWithIDs(\n\
    \  array: any[],\n  ids: string[],\n  tag: string\n): any[] {\n  if (array ===\
    \ undefined) {\n    return undefined\n  }\n\n  return array.filter((element) =>\
    \ {\n    return ids.indexOf(element[tag]) > -1\n  })\n}\n\nexport function findInArray(\n\
    \  array: any", "  if (strings.length === 0) {\n    return undefined;\n  }\n\n\
    \  const stringLength = strings[0].length;\n\n  for (let i = 1; i < strings.length;\
    \ i++) {\n    if (strings[i].length > stringLength) {\n      return strings[i\
    \ - 1];\n    }\n  }\n\n  return strings[0];\n}\n", "  if (strings.length === 0)\
    \ {\n    return undefined; // undefined\n  }\n  let longestIndex = 0;\n  let longestLength:\
    \ string = strings[0];\n  strings.forEach((string, index) => {\n    if (string.length\
    \ > longestLength) {\n      longestIndex = index;\n      longestLength = string;\n\
    \    }\n  });\n  return strings[longestIndex];\n}\n", "  if (strings.length ===\
    \ 0) {\n    return undefined;\n  }\n  return strings[0].length > longest(strings.map(s\
    \ => s.length)).length ? strings[0] : longest(strings.map(s => s.length));\n}\n",
  "  if (strings.length === 0) {\n    return;\n  }\n\n  const longestString = strings[0];\n\
    \  const longestLength = longestString.length;\n\n  for (let i = 1; i < strings.length;\
    \ i++) {\n    const currentString = strings[i];\n\n    if (currentString.length\
    \ < longestLength) {\n      longestString = currentString;\n      longestLength\
    \ = currentString.length;\n    }\n  }\n\n  return longestString;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
