name: HumanEval_9_rolling_max
language: ts
prompt: "//From a given array of integers, generate an array of rolling maximum element\
  \ found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2,\
  \ 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunction rolling_max(numbers: number[]):\
  \ number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = rolling_max;\n  assert.deepEqual(candidate([]),[]);\n\
  \  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);\n  assert.deepEqual(candidate([4,\
  \ 3, 2, 1]),[4, 4, 4, 4]);\n  assert.deepEqual(candidate([3, 2, 3, 100, 3]),[3,\
  \ 3, 3, 100, 100]);\n}\n\ntest();"
completions: ["    const min = Math.min(...numbers);\n    const max = Math.max(...numbers);\n\
    \    const arr: number[] = [];\n    for (let i = 0; i < numbers.length; ++i) {\n\
    \        const num = numbers[i];\n        if (num >= min && num <= max) {\n  \
    \          arr.push(num);\n        }\n    }\n    return arr;\n}\n", "    // Sort\
    \ the array by descending order\n    numbers.sort((a, b) => b - a);\n    let rollingMax\
    \ = 0;\n    // Loop through the array and find rolling max element\n    for (let\
    \ i = numbers.length - 1; i >= 0; i--) {\n        if (rollingMax < numbers[i])\
    \ {\n            rollingMax = numbers[i];\n        }\n    }\n    return rollingMax;\n\
    }", "\tif (numbers.length === 0) return [];\n\tif (numbers.length === 1) return\
    \ numbers;\n\tvar max_element: number = numbers[0],\n\t\tmax_rolling_counter:\
    \ number[] = [max_element],\n\t\tresult: number[] = [];\n\n\tnumbers.forEach(function(number)\
    \ {\n\t\tmax_element = number > max_element ? number : max_element;\n\t\tmax_rolling_counter.push(max_element);\n\
    \t});\n\n\tfor (var i = 0; i < max_rolling_counter.length; i += 3) {\n\t\tif (max_rolling_counter[i]\
    \ === max_rolling_counter[i + 2] &&\n\t\t\tmax_rolling_counter[i + 1] === max_rolling_counter[i\
    \ + 3])\n\t\t\tresult.push(max_rolling_counter[i]);\n\t}\n\n\treturn result;\n\
    }", "    let max: number[] = [];\n\n    for (let i = 1; i < numbers.length; i++)\
    \ {\n        let max_so_far = max[i-1];\n        let cur_max = numbers[i];\n\n\
    \        if (cur_max > max_so_far) {\n            max.push(cur_max);\n       \
    \ }\n    }\n    return max;\n}\n", "  let rollingMax: number[] = [];\n  let maximum:\
    \ number|undefined = undefined;\n\n  for (const number of numbers) {\n    const\
    \ index = rollingMax.findIndex((x) => x > number);\n    if (index === -1) {\n\
    \      rollingMax.push(number);\n    } else {\n      if (rollingMax[index] > number)\
    \ {\n        rollingMax[index] = number;\n      } else {\n        rollingMax[index]\
    \ = rollingMax[index] + 1;\n      }\n    }\n\n    if (rollingMax.length > 1 &&\
    \ !Number.isNaN(maximum)) {\n      rollingMax.shift();\n    }\n\n    if (rollingMax.length\
    \ >= 2) {\n      maximum = rollingMax.find((x) => x > rollingMax.slice(-1)[0])\
    \ as number | undefined;\n    }\n  }\n\n  return rollingMax;\n}\n", "    var max_num:\
    \ number[] = [];\n    var max_num_index: number[] = [];\n    var curr_max: number\
    \ = 0;\n\n    // For each item in the array we store its current maximum index\
    \ and its\n    // current maximum. Then, whenever the current maximum is greater\
    \ than the\n    // number at that index, we store the new maximum and its index\
    \ here\n    // and increment the index to which this number belongs.\n    for\
    \ (var i = 0; i < numbers.length; i++) {\n        if (max_num.length == 0) {\n\
    \            max_num[0] = numbers[i];\n            max_num_index[0] = i;\n   \
    \     } else if (max_num[0] > numbers[i]) {\n            max_num[0] = numbers[i];\n\
    \            max_num_index[0] = i;\n        } else if (max_num[0] == numbers[i])\
    \ {\n            // No changes were made to the current number, so let's keep\
    \ this\n            // as the new current maximum.\n        } else {\n       \
    \     // The current number is greater than the previous maximum, so we have\n\
    \            // to add this number to the array.\n            max_num.push(numbers[i]);\n\
    \            max_num_index.push(i);\n        }\n    }\n\n    // At this point\
    \ we have the array `max_num` which contains all the current\n    // maximums\
    \ in the given sequence. Let's go over all elements from this array\n    // and\
    \ add all the current maximums to the new rolling maximum array.\n    for (var\
    \ i = 1; i < max_num.length; i++) {\n        curr_max = 0;\n        for (var j\
    \ = 0; j < i; j++) {\n            curr_max += max_num[j];\n        }\n       \
    \ max_num.push(curr_max);\n        max_num_index.push(i);\n    }\n\n    return\
    \ max_num;\n}\n", "    var window: number[] = [];\n    var sum: number[] = [];\n\
    \    var i = 0;\n    while (i < numbers.length) {\n        window.push(numbers[i]);\n\
    \        sum.push(numbers[i]);\n        i++;\n    }\n    while (i < numbers.length)\
    \ {\n        var max_element = Math.max.apply(Math, window);\n        if (max_element\
    \ === sum[sum.length - 1]) {\n            window.pop();\n        } else {\n  \
    \          sum.push(max_element);\n        }\n        i++;\n    }\n    return\
    \ window;\n}\n", "    let max: number = -Infinity;\n    let max_index = -1;\n\
    \    let rolling_max: number[] = [];\n\n    numbers.forEach((number, index) =>\
    \ {\n        if (number > max) {\n            max = number;\n            max_index\
    \ = index;\n        }\n    });\n\n    for (let index = numbers.length - 1; index\
    \ > -1; index--) {\n        if (numbers[index] > max) {\n            rolling_max[max_index]\
    \ = numbers[index];\n            max_index--;\n        }\n    }\n\n    return\
    \ rolling_max;\n}\n", "  var max_val = 0;\n  var rolling_index = 0;\n\n  for (var\
    \ i = 0; i < numbers.length; i++) {\n    if (max_val < numbers[i]) {\n      max_val\
    \ = numbers[i];\n      rolling_index = i;\n    }\n  }\n\n  return numbers.slice(0,\
    \ rolling_index + 1);\n}\n", "    var min = Math.min.apply(null, numbers);\n \
    \   var max: number[] = [];\n\n    for (var i = 0; i < numbers.length; i++) {\n\
    \        max = numbers[i] == min ? max : [max, numbers[i]];\n    }\n\n    return\
    \ max;\n}\n", "  let max = Number.MIN_VALUE\n  let result = []\n\n  for (let i\
    \ = 0; i < numbers.length; i++) {\n    let current = numbers[i]\n    if (current\
    \ > max) {\n      max = current\n      result = [current]\n    } else if (current\
    \ === max) {\n      result.push(max)\n    }\n  }\n\n  return result\n}\n", " \
    \ var _numbers = _slicedToArray(numbers, 1),\n      window = _numbers[0],\n  \
    \    index = _numbers[1];\n\n  var rolling_max_array = rolling_max_array[window];\n\
    \n  while (index < numbers.length) {\n    rolling_max_array = rolling_max_array.concat(rolling_max(numbers,\
    \ index + 1));\n    index += 1\n  }\n  return rolling_max_array;\n}\n", "    const\
    \ array = [];\n    let max_found = 0;\n    for (let i = 0; i < numbers.length;\
    \ i++) {\n        if (numbers[i] > max_found) {\n            array.push(max_found);\n\
    \            array.push(numbers[i]);\n            max_found = numbers[i];\n  \
    \      } else {\n            max_found = numbers[i];\n        }\n    }\n    array.push(max_found);\n\
    \    return array;\n}", "    let largest: number[] = [];\n    let rollingMax:\
    \ number[] = [];\n    numbers.forEach((item) => {\n        rollingMax.push(Math.max(item));\n\
    \    });\n    while (rollingMax.length > 0) {\n        largest.push(rollingMax.shift());\n\
    \    }\n    return largest;\n}", "    var res = [];\n    for (var i = 0, len =\
    \ numbers.length; i < len; i++) {\n        res.push(Math.max(numbers[i], numbers[rolling_max_index(i)]));\n\
    \    }\n    return res;\n}\n", "    const rollingMax: number[] = [];\n\n    for\
    \ (let i = 0; i < numbers.length; i++) {\n        if (numbers[i] > rollingMax[rollingMax.length\
    \ - 1]) {\n            rollingMax.push(numbers[i]);\n        } else {\n      \
    \      continue;\n        }\n    }\n\n    return rollingMax;\n}\n", "    var max_roll\
    \ = [];\n    var roll_number = numbers[0];\n    var roll_max = numbers[0];\n \
    \   var max_index = -1;\n    for (var i = 1; i < numbers.length; i++) {\n    \
    \    roll_number = numbers[i];\n        if (roll_number > max_roll[0]) {\n   \
    \         max_roll[0] = roll_number;\n            max_index = i;\n        }\n\
    \    }\n    max_roll[0] = numbers[max_index];\n    max_roll.splice(max_roll.indexOf(numbers[max_index]),\
    \ 1);\n    return max_roll;\n}", "    return numbers.map(value => {\n        const\
    \ rolling_max_found = values.reduce((acc, val) => {\n            return acc <\
    \ val ? val : acc;\n        }, -1);\n        return rolling_max_found >= value\
    \ ? rolling_max_found : value;\n    });\n}\n", "    let max_number = Number.MIN_SAFE_INTEGER;\n\
    \    let result = [];\n    for (let i = 1; i <= numbers.length; i++) {\n     \
    \   let num = numbers[i - 1];\n        if (num > max_number) {\n            max_number\
    \ = num;\n        }\n    }\n    for (let i = 1; i <= numbers.length; i++) {\n\
    \        let num = numbers[i];\n        if (num > max_number) {\n            result.push(max_number);\n\
    \        }\n    }\n    for (let i = 1; i < numbers.length; i++) {\n        let\
    \ num = numbers[i];\n        if (num > max_number) {\n            result.push(num);\n\
    \        }\n    }\n    return result;\n}\n", "    let result: number[] = [];\n\
    \    numbers.sort((a, b) => a - b);\n    let previousValue = numbers[0];\n   \
    \ for (let i = 1; i < numbers.length; i++) {\n        if (numbers[i] < previousValue)\
    \ {\n            continue;\n        }\n        result.push(previousValue);\n \
    \       previousValue = numbers[i];\n    }\n    return result;\n}\n", "  let max:\
    \ number = Number.MIN_VALUE;\n  let max_index: number = 0;\n  for (let i: number\
    \ = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n\
    \      max_index = i;\n    }\n  }\n  const result: number[] = [];\n  for (let\
    \ i = max_index; i >= 0; i--) {\n    result.push(numbers[i]);\n  }\n  return result;\n\
    }", "    let max: number[] = [];\n    let last: number = numbers[0];\n    let\
    \ i: number;\n    for (i = 1; i < numbers.length; i++) {\n        if (numbers[i]\
    \ > last) {\n            last = numbers[i];\n        }\n    }\n    max = last;\n\
    \    return max;\n}\n", "\tlet max: number[] = [];\n\tlet rolling_max: number[]\
    \ = [];\n\tlet current_max: number = 0;\n\tnumbers.forEach((number) => {\n\t\t\
    if (number > current_max) {\n\t\t\trolling_max = [];\n\t\t\trolling_max.push(current_max);\n\
    \t\t\trolling_max.push(number);\n\t\t\tmax = rolling_max;\n\t\t} else {\n\t\t\t\
    rolling_max.push(number);\n\t\t}\n\t\tcurrent_max = number;\n\t});\n\treturn max;\n\
    }\n", "    let max = numbers[0];\n    let maxIndex = 0;\n    for (let index =\
    \ 1; index < numbers.length; index++) {\n        if (numbers[index] > max) {\n\
    \            max = numbers[index];\n            maxIndex = index;\n        }\n\
    \    }\n    return [numbers[maxIndex], max];\n}", "  let result: number[] = [];\n\
    \  let current = [];\n  for (let i = 0; i < numbers.length; i++) {\n    current\
    \ = (current || []).concat(numbers[i]);\n    if (i > 0) {\n      current[i - 1]\
    \ = Math.max(current[i - 1]);\n    }\n    result.push(current[current.length -\
    \ 1]);\n  }\n  return result;\n}\n", "    let max_rolling_value = 0;\n    let\
    \ max_rolling_i = 0;\n\n    for (let i = 1; i < numbers.length; i++){\n      \
    \  if (max_rolling_i > numbers.length - i){\n            break;\n        }\n\n\
    \        if (numbers[i] > max_rolling_value){\n            max_rolling_value =\
    \ numbers[i];\n            max_rolling_i = i;\n        }\n    }\n\n    let max_rolling\
    \ = new Array<number>([max_rolling_value, max_rolling_i]);\n\n    return max_rolling;\n\
    }\n", "    var result = [];\n    for (var i = 0; i < numbers.length; i++) {\n\
    \        var v = numbers[i];\n        for (var j = 1; j < i; j++) {\n        \
    \    if (v > numbers[j]) {\n                v = numbers[j];\n            }\n \
    \       }\n        result.push(v);\n    }\n    return result;\n}\n", "\tlet max_idx\
    \ = numbers.length - 1;\n\tfor (let i = 0; i < numbers.length; i++) {\n\t\tlet\
    \ max_value = numbers[i];\n\t\tfor (let j = i + 1; j < numbers.length; j++) {\n\
    \t\t\tif (numbers[j] > max_value) {\n\t\t\t\tmax_value = numbers[j];\n\t\t\t\t\
    max_idx = j;\n\t\t\t}\n\t\t}\n\t\tnumbers[max_idx] = numbers[i];\n\t}\n\tnumbers.reverse();\n\
    \treturn numbers;\n}\n", "  return numbers.reduce((acc, curr, index) => {\n  \
    \  if (index === 0) {\n      return curr\n    } else {\n      return Math.max(acc,\
    \ curr)\n    }\n  })\n}", "  let max: number = numbers[0]\n  let result: number[]\
    \ = []\n  let i = 0\n  while (numbers.length > 0) {\n    if (numbers[i] > max)\
    \ {\n      max = numbers[i]\n    }\n    result.push(max)\n    i++\n  }\n  return\
    \ result\n}\n", "  // get first and last item\n  let [first, ...rest] = numbers;\n\
    \  // get first item\n  const result = first > rest[0] ? [first] : [];\n  // fill\
    \ with first item\n  while (numbers.length > 0) {\n    const current = rest.shift();\n\
    \    if (current > rest[0]) result.push(current);\n  }\n  return result;\n}\n",
  "  if (numbers.length === 0) {\n    return [];\n  }\n\n  var max_element = numbers[0];\n\
    \  var max_element_index = -1;\n\n  for (var i = 1; i < numbers.length; i++) {\n\
    \    if (numbers[i] > max_element) {\n      max_element = numbers[i];\n      max_element_index\
    \ = i;\n    }\n  }\n\n  return numbers.slice(0, max_element_index + 1);\n}\n",
  "  if (numbers.length === 0) {\n    return [];\n  }\n  const max = numbers[0];\n\
    \  const max = Math.min(max, numbers[0]);\n  const maxIndex = numbers.indexOf(max);\n\
    \  return rolling_max(numbers.map(n => Math.max(n, max)));\n}\n", "  let result:\
    \ number[] = [];\n  let max: number = -Infinity;\n  numbers.forEach(number =>\
    \ {\n    max = Math.max(max, number);\n  });\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    let current = numbers[i];\n    while (i > 0 && numbers[i - 1] >\
    \ current) {\n      numbers[i - 1] = numbers[i - 1] - 1;\n      current = numbers[i\
    \ - 1];\n    }\n    result.push(current);\n  }\n  return result;\n}\n", "  const\
    \ rolling_max = numbers[0]\n  for (let i = 1; i < numbers.length; i++) {\n   \
    \ rolling_max = Math.max(rolling_max, numbers[i])\n  }\n  return rolling_max\n\
    }\n", "  if (numbers.length < 1) return []; //if the given array is empty, return\
    \ an empty array\n\n  var result: number[] = []; //variable to store rolling max\
    \ elements\n\n  var rolling_max: number[] = []; //variable to store max elements\
    \ in rolling max\n\n  var max_element: number; //variable to store max element\n\
    \n  var i: number; //looping variable\n\n  for (i = 0; i < numbers.length; i++)\
    \ {\n    //finding max element in the given rolling max array\n    if (max_element\
    \ < rolling_max[rolling_max.length - 1]) {\n      max_element = rolling_max[rolling_max.length\
    \ - 1];\n    }\n    //adding new max element to rolling max array\n    rolling_max.push(max_element);\n\
    \  }\n\n  for (i = 0; i < numbers.length; i++) {\n    //if number is not in rolling\
    \ max array, adding it to the result array\n    if (!rolling_max.includes(numbers[i]))\
    \ {\n      result.push(numbers[i]);\n    }\n  }\n\n  return result;\n}", "  const\
    \ len = numbers.length\n  if (len <= 1) {\n    return numbers\n  }\n  let maxNumber:\
    \ number = numbers[0]\n  for (let i = 1; i < len; i++) {\n    if (maxNumber <\
    \ numbers[i]) {\n      maxNumber = numbers[i]\n    }\n  }\n  const newArray: number[]\
    \ = []\n  for (let i = 0; i < len; i++) {\n    newArray.push(numbers[i])\n   \
    \ if (numbers[i] > maxNumber) {\n      newArray.push(maxNumber)\n      maxNumber\
    \ = 0\n    }\n  }\n  return newArray\n}\n", "    let maxNumber: number[] = [];\n\
    \    for (let i = 0; i < numbers.length; i++) {\n        let currentNumber = numbers[i];\n\
    \        if (maxNumber.length >= currentNumber - 1) {\n            let highestIndex\
    \ = i;\n            for (let j = i; j < maxNumber.length; j++) {\n           \
    \     if (maxNumber[j] > maxNumber[highestIndex]) {\n                    highestIndex\
    \ = j;\n                }\n            }\n            maxNumber[highestIndex]\
    \ = Math.max(maxNumber[highestIndex], currentNumber);\n        } else {\n    \
    \        maxNumber.push(currentNumber);\n        }\n    }\n    return maxNumber;\n\
    }\n", "    if (numbers.length === 0) {\n        throw new Error(\"rolling_max\
    \ expects an array of at least one number as its input\");\n    }\n\n    return\
    \ numbers.map(function (n, i) {\n        var max_so_far = n;\n        for (var\
    \ j = 0; j < i - 1; j++)\n            max_so_far = Math.max(max_so_far, numbers[j]);\n\
    \        return max_so_far;\n    });\n}\n", "    return numbers.reduce((accumulator,\
    \ number) => {\n        return Math.max(accumulator, number);\n    }, numbers[0]);\n\
    }\n", "    // Algorithm 1. Sort numbers.\n    // Algorithm 2. Roll from first\
    \ element until the end and find the max.\n    // Algorithm 3. Reverse the order\
    \ and return the result.\n\n    let sortedNumbers = numbers.sort((a, b) => a -\
    \ b);\n    let rollingMax = sortedNumbers.slice();\n    let rollingMaxIndex =\
    \ 0;\n    let maxIndex = 0;\n    for (let i = 1; i < sortedNumbers.length; i +=\
    \ 1) {\n        let maxBefore = rollingMax[rollingMaxIndex];\n        if (rollingMaxIndex\
    \ === 0) {\n            rollingMaxIndex++;\n            rollingMax[0] = rollingMax[rollingMaxIndex]\
    \ = sortedNumbers[i];\n        }\n        if (rollingMax[rollingMaxIndex] > sortedNumbers[i])\
    \ {\n            rollingMax[rollingMaxIndex] = sortedNumbers[i];\n           \
    \ rollingMaxIndex += 1;\n        }\n        if (rollingMaxIndex === maxIndex)\
    \ {\n            maxIndex += 1;\n        }\n    }\n    return rollingMax.reverse();\n\
    }\n", "  let currentMax: number = numbers[0];\n\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    if (numbers[i] > currentMax) {\n      currentMax = numbers[i];\n\
    \    }\n  }\n  return currentMax;\n}\n", "    const result: number[] = [];\n \
    \   numbers.forEach((n, i) => {\n        result[i] = n;\n    });\n    let maxValue\
    \ = Math.max.apply(Math, result);\n    let maxIndex = 0;\n    result.forEach((n,\
    \ i) => {\n        if (n === maxValue) {\n            maxIndex = i;\n        }\n\
    \    });\n    let result = numbers.slice(0, maxIndex + 1);\n    return result;\n\
    }\n", "  numbers.sort((a: number, b: number) => b - a); // ascending sort\n  let\
    \ current = numbers[0];\n  let result = [];\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    if (numbers[i] >= current) {\n      result.push(current);\n    \
    \  current = numbers[i];\n    } else {\n      current = numbers[i];\n    }\n \
    \ }\n  result.push(current);\n  return result;\n}\n", "    const min = Math.min.apply(null,\
    \ numbers);\n    return numbers.map(n => Math.max(min, n));\n}\n", "  var max_elements\
    \ = []\n  var max = numbers[0]\n  var current_max = numbers[0]\n  for (var index\
    \ = 1; index < numbers.length; index++) {\n    if (max < numbers[index]) {\n \
    \     max = numbers[index]\n      current_max = max\n    }\n  }\n  max_elements.push(current_max)\n\
    \  return max_elements\n}\n", "  let max: number[] = [];\n  let start = 0;\n \
    \ while (start < numbers.length) {\n    max = numbers.slice(start, start + maxLength);\n\
    \    start = start + maxLength;\n  }\n  return max;\n}\n", "    const rolling_max\
    \ = numbers[0];\n\n    for (let i = 1; i < numbers.length; i++) {\n        let\
    \ max_element = numbers[i];\n\n        for (let j = i - 1; j >= 0; j--) {\n  \
    \          if (numbers[j] > max_element) {\n                max_element = numbers[j];\n\
    \            }\n        }\n\n        rolling_max = max_element;\n    }\n\n   \
    \ return rolling_max;\n}\n", "  var max_index: number;\n  var max_value: number;\n\
    \  var result: number[] = [];\n  for (let i = 0; i < numbers.length; i++) {\n\
    \    let current_value: number = numbers[i];\n    for (let j = 0; j < i; j++)\
    \ {\n      current_value = Math.max(current_value, numbers[j]);\n    }\n    if\
    \ (current_value == numbers[max_index]) {\n      max_index++;\n    } else {\n\
    \      if (max_index != undefined) {\n        result.push(max_value);\n      }\n\
    \      max_value = current_value;\n      max_index = i;\n    }\n  }\n  if (max_index\
    \ != undefined) {\n    result.push(max_value);\n  }\n  return result;\n}\n", "\t\
    let max_value = Number.NEGATIVE_INFINITY;\n\tlet max_index = 0;\n\tlet current_index\
    \ = 0;\n\tlet temp: number;\n\tfor (let i = 0; i < numbers.length; ++i) {\n\t\t\
    temp = numbers[i];\n\t\tif (max_value < temp) {\n\t\t\tmax_value = temp;\n\t\t\
    \tmax_index = current_index;\n\t\t}\n\t\tnumbers[current_index++] = temp;\n\t\
    }\n\treturn numbers.slice(0, max_index + 1);\n}\n", "    let result = [];\n  \
    \  numbers.forEach((n) => {\n        result.push((result.length < n) ? n : result[result.length-1]);\n\
    \    });\n    return result;\n}\n", "    numbers.forEach((n, i) => {\n       \
    \ numbers[i] = n;\n    });\n\n    let max: number[] = [];\n    numbers.forEach((n)\
    \ => {\n        if (max[max.length - 1] < n)\n            max.push(n);\n    });\n\
    \n    return max;\n}\n", "    if (numbers.length <= 0) {\n        return [];\n\
    \    }\n    var max_num = numbers[0];\n    var rolling_max = numbers;\n    for\
    \ (var i = 1; i < numbers.length; i++) {\n        if (numbers[i] >= max_num) {\n\
    \            rolling_max = [max_num].concat(rolling_max);\n            max_num\
    \ = numbers[i];\n        } else {\n            rolling_max = [max_num, numbers[i]].concat(rolling_max);\n\
    \        }\n    }\n    return rolling_max;\n}", "    let max = numbers[0];\n \
    \   let rolling_max: number[] = [];\n    let n: number = numbers.length;\n   \
    \ let i: number;\n    for (i = 1; i < n; i++) {\n        if (numbers[i] > max)\
    \ {\n            max = numbers[i];\n        }\n    }\n    if (max !== 0) {\n \
    \       rolling_max = [max];\n        for (i = 1; i < n; i++) {\n            if\
    \ (numbers[i] > rolling_max[0]) {\n                rolling_max[0] = numbers[i];\n\
    \            }\n        }\n    }\n    return rolling_max;\n}\n", "    const rolling_max_values:\
    \ number[] = [];\n\n    let max_value = numbers[0];\n    let max_idx = 1;\n  \
    \  let current = numbers[0];\n    let idx = 1;\n    while (idx < numbers.length)\
    \ {\n        if (numbers[idx] > current) {\n            current = numbers[idx];\n\
    \        }\n        if (current > max_value) {\n            max_value = current;\n\
    \            max_idx = idx;\n        }\n        idx += 1;\n    }\n    rolling_max_values.push(max_value);\n\
    \    rolling_max_values.push(numbers[max_idx]);\n\n    return rolling_max_values;\n\
    }\n", "  let result: number[] = [];\n  let i = 0;\n  for (let x = numbers.length\
    \ - 1; x > -1; x--) {\n    if (numbers[x] > numbers[i] || i === 0) {\n      result.push(numbers[x]);\n\
    \    } else {\n      result.push(numbers[i]);\n      i += 1;\n    }\n  }\n  return\
    \ result;\n}\n", "  const rolling_maxes: number[] = [];\n  for (let i = 0; i <\
    \ numbers.length; i++) {\n    if (rolling_maxes.length == 0 || rolling_maxes[rolling_maxes.length\
    \ - 1] < numbers[i]) {\n      rolling_maxes.push(numbers[i]);\n    } else {\n\
    \      rolling_maxes[rolling_maxes.length - 1] = numbers[i];\n    }\n  }\n  return\
    \ rolling_maxes;\n}\n", "    let result = [];\n    let len = numbers.length;\n\
    \    let rolling_max: number[] = [];\n    for (let i = 0; i < len; i++) {\n  \
    \      let curr_max = numbers[i];\n        let max_element = numbers[i];\n   \
    \     for (let j = i; j < len; j++) {\n            if (numbers[j] > curr_max)\
    \ {\n                curr_max = numbers[j];\n                max_element = numbers[j];\n\
    \            }\n        }\n        rolling_max.push(max_element);\n    }\n   \
    \ return result;\n}\n", "  let current_max: number | null = null;\n  const rolling_maxes:\
    \ number[] = [];\n  numbers.forEach((item: number) => {\n    const current_max\
    \ = Math.max(item, current_max);\n    if (current_max != null) {\n      rolling_maxes.push(current_max);\n\
    \    }\n  });\n  return rolling_maxes;\n}\n", "  let max: number[] = [];\n\n \
    \ for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max[max.length\
    \ - 1]) {\n      max.push(numbers[i]);\n    }\n  }\n\n  return max;\n}\n", " \
    \ const max = Math.max(...numbers);\n  let rolling_max = [max];\n  for (let i\
    \ = 0; i < numbers.length; i++) {\n    let element = numbers[i];\n    while (element\
    \ > max) {\n      rolling_max = rolling_max.concat(rolling_max);\n      rolling_max[rolling_max.length\
    \ - 1] = element;\n      max = rolling_max[rolling_max.length - 1];\n      rolling_max\
    \ = rolling_max.concat(rolling_max);\n      rolling_max[rolling_max.length - 1]\
    \ = element;\n    }\n    rolling_max.push(element);\n  }\n  return rolling_max;\n\
    }\n", "\treturn numbers.reduce((acc, number) => Math.max(acc, number), -Infinity);\n\
    }\n", "  const result = [];\n  let maxNumber: number|undefined;\n  let currentNumber:\
    \ number|undefined;\n\n  for (const number of numbers) {\n    if (!maxNumber ||\
    \ number > maxNumber) {\n      maxNumber = number;\n    }\n  }\n\n  for (const\
    \ number of numbers) {\n    if (!currentNumber || number > currentNumber) {\n\
    \      currentNumber = number;\n    }\n    if (currentNumber === maxNumber) {\n\
    \      result.push(maxNumber);\n      maxNumber = undefined;\n      currentNumber\
    \ = undefined;\n    }\n  }\n  return result;\n}\n", "  const result = new Array<number>();\n\
    \  const len = numbers.length;\n  let cur_max = 0;\n  let cur = numbers[0];\n\
    \  for (let i = 1; i < len; i++) {\n    cur = numbers[i];\n    if (cur > cur_max)\
    \ {\n      cur_max = cur;\n    }\n    result.push(cur_max);\n  }\n  return result;\n\
    }\n", "    let max_val: number[] = [];\n    let cur: number = 0;\n    for (let\
    \ i = 0; i < numbers.length; i++) {\n        if (numbers[i] > cur) {\n       \
    \     max_val.push(cur);\n            cur = numbers[i];\n        } else {\n  \
    \          max_val.push(cur);\n            cur = numbers[i];\n            max_val.push(numbers[i]);\n\
    \        }\n    }\n    return max_val;\n}\n", "    numbers.reverse();\n\n    let\
    \ current_max = numbers[0];\n    let current_index = -1;\n    let index = 0;\n\
    \n    while (true) {\n        current_max = Math.max(numbers[index], current_max);\n\
    \        index++;\n        if (current_max === numbers[0]) break;\n    }\n\n \
    \   numbers.reverse();\n    return numbers.slice(0, current_index + 1);\n}\n",
  "  let max: number = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i]\
    \ > max) {\n      max = numbers[i];\n    }\n  }\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    numbers[i] = numbers[i] - max;\n  }\n  return numbers;\n}", "  const\
    \ n = numbers.length;\n  const max_number: number[] = new Array(n);\n  const min_number:\
    \ number[] = new Array(n);\n  let max_index: number;\n  let min_index: number;\n\
    \n  for (let i = 0; i < n; i++) {\n    if (numbers[i] > numbers[max_index]) {\n\
    \      max_index = i;\n    }\n    if (numbers[i] < numbers[min_index]) {\n   \
    \   min_index = i;\n    }\n  }\n\n  max_number[max_index] = numbers[max_index];\n\
    \  min_number[min_index] = numbers[min_index];\n  let temp_max_number: number[]\
    \ = new Array(max_index);\n  let temp_min_number: number[] = new Array(min_index);\n\
    \  let temp_max_index: number;\n  let temp_min_index: number;\n\n  for (let i\
    \ = 0; i < max_index; i++) {\n    temp_max_number[i] = max_number[i];\n  }\n \
    \ for (let i = min_index; i < n; i++) {\n    temp_min_number[i] = min_number[i];\n\
    \  }\n  temp_max_index = max_index;\n  temp_min_index = min_index;\n  for (let\
    \ i = max_index + 1; i < n; i++) {\n    if (numbers[i] < numbers[temp_min_index])\
    \ {\n      temp_min_index = i;\n    }\n    if (numbers[i] > numbers[temp_max_index])\
    \ {\n      temp_max_index = i;\n    }\n  }\n  temp_max_number[temp_max_index]\
    \ = numbers[temp_max_index];\n  temp_min_number[temp_min_index] = numbers[temp_min_index];\n\
    \n  for (let i = temp_min_index + 1; i < temp_max_index; i++) {\n    max_number[i]\
    \ = temp_min_number[i];\n  }\n  for (let i = 0; i < temp_min_index; i++) {\n \
    \   min_number[i] = temp_max_number[i];\n  }\n  return max_number;\n}", "  if\
    \ (numbers.length === 0) {\n    return [];\n  }\n\n  let max: number;\n  const\
    \ result: number[] = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n   \
    \ if (!max || numbers[i] > max) {\n      max = numbers[i];\n      result.push(max);\n\
    \    }\n  }\n\n  return result;\n}\n", "  const max_result = [];\n  const last_rolling_maxes\
    \ = [];\n  let current_rolling_maxes = [];\n  let last_rolling_max = 0;\n  let\
    \ last_rolling_max_index = 0;\n  numbers.forEach((number, index) => {\n    if\
    \ (index === 0) {\n      max_result.push(number);\n      current_rolling_maxes.push(number);\n\
    \      last_rolling_max = 0;\n      last_rolling_max_index = index;\n      return;\n\
    \    }\n    const is_current_rolling_max = (number > last_rolling_max);\n    if\
    \ (is_current_rolling_max) {\n      last_rolling_maxes.push(number);\n      current_rolling_maxes.push(number);\n\
    \    } else {\n      if (last_rolling_maxes.length > 0) {\n        last_rolling_max\
    \ = Math.max(last_rolling_max, last_rolling_maxes.pop());\n        last_rolling_max_index\
    \ = index;\n      }\n      max_result.push(number);\n    }\n  });\n  return max_result;\n\
    }\n", "  let min: number = Math.min.apply(Math, numbers);\n  let max_idx = numbers.indexOf(min);\n\
    \  let max: number = 0;\n  for(let i = max_idx; i > 0; i--){\n    max = Math.max(max,\
    \ numbers[i]);\n  }\n  return [min].concat(numbers.slice().slice(max_idx));\n\
    }\n", "  const result = [];\n  let rollingMax = numbers[0];\n  for (let i = 1;\
    \ i < numbers.length; i++) {\n    const num = numbers[i];\n    rollingMax = Math.max(num,\
    \ rollingMax);\n    result.push(rollingMax);\n  }\n  return result;\n}\n", "\t\
    var result = [];\n\trolling_max_helper_0(numbers, 0, result);\n\treturn result;\n\
    }\n", "    const max = numbers[0];\n    const max_index = -1;\n    for (let i\
    \ = 1; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n         \
    \   max = numbers[i];\n            max_index = i;\n        }\n    }\n\n    const\
    \ rolling = [max];\n    for (let i = max_index + 2; i < numbers.length; i++) {\n\
    \        rolling.push(numbers[i]);\n    }\n\n    return rolling;\n}\n", "  let\
    \ maxVal = numbers[0];\n  let idx = 1;\n  for (let i = numbers.length - 1; i >=\
    \ 0; i--) {\n    if (numbers[i] > maxVal) {\n      maxVal = numbers[i];\n    \
    \  idx = i;\n    }\n  }\n  const rest = numbers.slice(idx + 1);\n  return [maxVal].concat(rest);\n\
    }\n", "\tlet rolling_max = Array(numbers.length).fill(0);\n\tlet max_pos = 0;\n\
    \tfor (let i = 0; i < numbers.length; i++) {\n\t\tif (max_pos < i) {\n\t\t\trolling_max[i]\
    \ = Math.max(rolling_max[max_pos], numbers[i]);\n\t\t} else {\n\t\t\trolling_max[i]\
    \ = Math.max(numbers[i], rolling_max[max_pos]);\n\t\t}\n\t\tmax_pos = i - 1;\n\
    \t}\n\treturn rolling_max;\n}\n", "  let max: number[] = []\n  let maxIndex: number\
    \ = 0\n  for (let i = 0; i < numbers.length; ++i) {\n    if (numbers[i] > max[maxIndex])\
    \ {\n      maxIndex = i\n      max = numbers.slice(0, maxIndex + 1)\n    }\n \
    \ }\n  return max\n}\n", "    const result: number[] = [];\n    const max = numbers.reduce(function(a:\
    \ number, b: number) {\n        return a > b ? a : b;\n    });\n    numbers.forEach(function(number)\
    \ {\n        if (number > max) {\n            result.push(number);\n        }\n\
    \    });\n    return result;\n}\n", "    const result: number[] = [];\n    const\
    \ n = numbers.length;\n    let max = 0;\n    let prev = 0;\n    const sum = 0;\n\
    \    let i = n - 1;\n    while (i > 0) {\n        max = Math.max(max, numbers[i\
    \ - 1]);\n        sum += max - numbers[i];\n        result[i - 1] = (prev = Math.max(prev,\
    \ sum));\n        --i;\n    }\n    max = Math.max(max, numbers[i]);\n    result[i]\
    \ = (prev = Math.max(prev, sum));\n    return result;\n}\nexports.rolling_max\
    \ = rolling_max;", "\tvar result: number[] = [];\n\tvar current = numbers[0];\n\
    \tnumbers.forEach(function (number: number) {\n\t\tif (current > number) {\n\t\
    \t\tresult.push(number);\n\t\t\tcurrent = number;\n\t\t}\n\t});\n\treturn result;\n\
    }\n", "\tlet max: number|null = null;\n\tlet rolling_max: number[] = [];\n\tnumbers.forEach(number\
    \ => {\n\t\trolling_max.push(number);\n\t\tif (max === null || rolling_max[rolling_max.length\
    \ - 1] < max) {\n\t\t\tmax = rolling_max[rolling_max.length - 1];\n\t\t}\n\t});\n\
    \treturn rolling_max;\n}\n", "    var max_el = numbers[0];\n\n    for (var i =\
    \ 1; i < numbers.length; i++) {\n        if (max_el < numbers[i]) {\n        \
    \    max_el = numbers[i];\n        }\n    }\n    return [max_el];\n}\n", "   \
    \ let largest = -Number.MAX_VALUE;\n    for (let i = 0; i < numbers.length; i++)\
    \ {\n        if (numbers[i] >= largest) {\n            largest = numbers[i];\n\
    \        }\n    }\n    return [...Array(numbers.length).keys()].map(i => numbers[i]);\n\
    }\n", "  return rolling_max(numbers, 0);\n}\n", "  if (numbers.length === 0) {\n\
    \    return [];\n  }\n\n  if (numbers.length === 1) {\n    return numbers;\n \
    \ }\n\n  if (numbers.length === 2) {\n    return [numbers[0], numbers[1]];\n \
    \ }\n\n  const sorted = numbers.sort((a, b) => a - b);\n  const result = [];\n\
    \  let current: number = null;\n\n  for (let i = sorted.length - 1; i >= 0; i--)\
    \ {\n    current = sorted[i];\n    if (current < sorted[i + 1]) {\n      break;\n\
    \    }\n    if (i === 0) {\n      result.push(current);\n    } else {\n      result.push(sorted[i\
    \ - 1]);\n    }\n  }\n\n  return result;\n}\n", "  const rollingMaxArray = [];\n\
    \  let max: number = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if\
    \ (numbers[i] > max) {\n      rollingMaxArray[rollingMaxArray.length] = max;\n\
    \      max = numbers[i];\n    } else {\n      rollingMaxArray[rollingMaxArray.length]\
    \ = numbers[i];\n    }\n  }\n  if (rollingMaxArray.length) rollingMaxArray[rollingMaxArray.length]\
    \ = max;\n  return rollingMaxArray;\n}\n", "\treturn numbers.reduce((acc, val)\
    \ => {\n\t\tif (val > acc[0]) {\n\t\t\tacc[0] = val;\n\t\t}\n\t\tif (val > acc[1])\
    \ {\n\t\t\tacc[1] = val;\n\t\t}\n\t\treturn acc;\n\t}, [-Number.MAX_VALUE, Number.MAX_VALUE]);\n\
    }\n", "  return numbers.reduce(function (a, b) {\n    return a > b ? a : b;\n\
    \  });\n}\n", "    let arr = [];\n    for(let i = numbers.length - 1; i > 0; i--){\n\
    \        let number = numbers[i];\n        for(let j = 0; j < i; j++){\n     \
    \       let sum = arr[j] + number;\n            while(sum > arr[j]){\n       \
    \         arr[j] += number;\n            }\n        }\n    }\n    return arr;\n\
    }\n", "\tif (numbers.length < 2) return [numbers[0]];\n\tlet maximum = numbers[0];\n\
    \tfor (let i = 1; i < numbers.length; i++) {\n\t\tmaximum = Math.max(numbers[i],\
    \ maximum);\n\t}\n\treturn [maximum];\n}\n", "\tvar result: number[] = [];\n\n\
    \tnumbers.forEach(number => {\n\t\tif (result.length === 0) {\n\t\t\tresult.push(number);\n\
    \t\t} else if (number >= result[result.length - 1]) {\n\t\t\tresult.push(number);\n\
    \t\t}\n\t});\n\n\treturn result;\n}\n", "    let result = [];\n    numbers.forEach(function(value,\
    \ index) {\n        if (index === 0) {\n            result.push(value);\n    \
    \    } else {\n            const result = Math.max(result, value);\n         \
    \   result.push(value);\n        }\n    });\n    return result;\n}", "  let max:\
    \ number[] = [];\n  let max_n: number[] = [];\n  for (let n of numbers) {\n  \
    \  if (max_n.length === 0) {\n      max_n = [n];\n    } else {\n      if (n >\
    \ max_n[max_n.length - 1]) {\n        max_n[max_n.length - 1] = n\n      }\n \
    \   }\n  }\n  for (let n of max_n) {\n    max = max.concat(n);\n  }\n  return\
    \ max;\n}\n", "\tif (numbers.length === 0) {\n\t\treturn numbers;\n\t}\n\tlet\
    \ index = numbers.length - 1;\n\tlet max = numbers[index];\n\twhile (index >=\
    \ 0) {\n\t\tindex--;\n\t\tif (numbers[index] > max) {\n\t\t\tmax = numbers[index];\n\
    \t\t}\n\t}\n\treturn numbers;\n}\n", "    return numbers.map(function (number)\
    \ { return Math.max(...number); });\n}\n", "  let rolling_max_array: number[]\
    \ = [];\n  let rolling_max_array_index = 0;\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    if (numbers[i] > rolling_max_array[rolling_max_array_index]) {\n\
    \      rolling_max_array[rolling_max_array_index] = numbers[i];\n    }\n  }\n\
    \  rolling_max_array_index++;\n  while (rolling_max_array_index < rolling_max_array.length)\
    \ {\n    rolling_max_array.pop();\n    rolling_max_array_index--;\n  }\n  return\
    \ rolling_max_array;\n}\n", "  let result = new Array<number>(numbers.length);\n\
    \  for (let i = 0; i < numbers.length; ++i) {\n    let current = numbers[i];\n\
    \    while (numbers.indexOf(current) < i) {\n      result.push(current);\n   \
    \   current = Math.max(numbers[numbers.indexOf(current) + 1], current);\n    }\n\
    \  }\n  return result;\n}\nexport function rolling_max(array: number[]): number[]\
    \ {\n  return rolling_max(array, -1);\n}\nexport function rolling_max(array: number[],\
    \ start: number): number[] {\n  return rolling_max(array, start, -1);\n}\nexport\
    \ function rolling_max(array: number[], start: number, end: number): number[]\
    \ {\n  let result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i\
    \ < start || i > end) {\n      result.push(array[i]);\n    } else {\n      let\
    \ current = array[i];\n      let j = 0;\n      while (i + j < array.length &&\
    \ i + j <= end) {\n        if (array[i + j] > current) {\n          current =\
    \ array[i + j];\n          j++;\n        } else {\n          j = 0;\n        }\n\
    \      }\n      result.push(current);\n    }\n  }\n  return result;\n}", "   \
    \ return numbers.reduce((prev: number[], item: number) => Math.max(item, prev),\
    \ []);\n}\n", "\tlet result: number[] = [];\n\tnumbers.map((value, index) => {\n\
    \t\tresult.push(value);\n\t\tif (index < numbers.length - 1) {\n\t\t\tresult.push(Math.max(value,\
    \ numbers[index + 1]));\n\t\t}\n\t});\n\treturn result;\n}\n", "  const results:\
    \ number[] = [];\n  for (let i = 0, length = numbers.length; i < length; i++)\
    \ {\n    results.push(Math.max(...numbers));\n  }\n  return results;\n}", "  \
    \  var result: number[] = [];\n    \n    for (var i = 0; i < numbers.length; i++)\
    \ {\n        var max = numbers[i];\n        for (var j = 0; j < i; j++) {\n  \
    \          if (numbers[j] > max)\n                max = numbers[j];\n        }\n\
    \        result.push(max);\n    }\n    \n    return result;\n}", "\treturn numbers.map(function\
    \ (number, index) {\n\t\treturn Math.max(number, numbers[index]);\n\t});\n}\n",
  "  return numbers.reduce(function (prev, curr) {\n    var cur = curr;\n    if (prev\
    \ > prev + cur) {\n      cur = prev + cur;\n    }\n    return cur;\n  });\n}\n",
  "\tlet max: number = 0;\n\tlet index: number;\n\tfor (let i = 0; i < numbers.length;\
    \ i++) {\n\t\tmax = Math.max(max, numbers[i]);\n\t\tindex = i;\n\t}\n\tlet result\
    \ = [];\n\tfor (let i = index; i < numbers.length; i++) {\n\t\tresult.push(numbers[i]);\n\
    \t}\n\treturn result;\n}\n", "    let max: number;\n    let maxIndex: number =\
    \ 0;\n    for (let i = 1; i <= numbers.length; i++) {\n        if (numbers[maxIndex]\
    \ < numbers[i - 1]) {\n            max = numbers[maxIndex];\n            maxIndex\
    \ = i;\n        }\n    }\n    return [maxIndex, max];\n}\n", "\tlet result: number[]\
    \ = [];\n\tlet max: number = 0;\n\tlet index = 0;\n\twhile (index < numbers.length)\
    \ {\n\t\tmax = numbers[index];\n\t\tindex++;\n\t\twhile (index < numbers.length\
    \ && max < numbers[index]) {\n\t\t\tmax = Math.max(max, numbers[index]);\n\t\t\
    \tindex++;\n\t\t}\n\t\tresult.push(max);\n\t}\n\treturn result;\n}\n", "    const\
    \ max = numbers.reduce(\n        function (prev, curr, i) {\n            if (curr\
    \ > prev) return curr;\n            return prev;\n        }\n    );\n    const\
    \ rollingMax = numbers.map(\n        function (curr, i) {\n            return\
    \ curr > max ? curr : max;\n        }\n    );\n    return rollingMax;\n}\n", " \
    \ const rollingMaxArray = [];\n  let maxIndex = -1;\n  let max = numbers[0];\n\
    \n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n\
    \      maxIndex = i;\n      max = numbers[i];\n    }\n  }\n\n  for (let i = maxIndex;\
    \ i < numbers.length; i++) {\n    rollingMaxArray.push(numbers[i]);\n  }\n\n \
    \ return rollingMaxArray;\n}\n", "    let rolling: number[] = [];\n\n    for (let\
    \ i = 0; i < numbers.length; i++) {\n        let roll_max: number[] = [];\n  \
    \      let rolling_max: number[] = [];\n        for (let j = i; j < numbers.length;\
    \ j++) {\n            if (numbers[j] > rolling_max[j]) {\n                roll_max[j]\
    \ = numbers[j];\n            }\n            rolling_max[j] = rolling_max[j - 1]\
    \ + roll_max[j];\n        }\n        rolling.push(rolling_max[rolling_max.length\
    \ - 1]);\n    }\n    return rolling;\n}\n", "    const result: number[] = [];\n\
    \    for (let index = 0; index < numbers.length; index++) {\n        let max_index\
    \ = 0;\n        for (let i = index; i < numbers.length; i++) {\n            if\
    \ (numbers[i] < numbers[max_index]) {\n                max_index = i;\n      \
    \      }\n        }\n        result.push(numbers[max_index]);\n    }\n    return\
    \ result;\n}", "  let rolling_max = numbers[0];\n  numbers.forEach(item => {\n\
    \    rolling_max = item > rolling_max ? item : rolling_max;\n  });\n  return rolling_max;\n\
    }\n", "    const len = numbers.length;\n    const max = numbers[0];\n    let sum:\
    \ number = 0;\n\n    for (let i = 1; i < len; i++) {\n        sum += numbers[i];\n\
    \        if (sum > max) {\n            max = sum;\n        }\n    }\n\n    return\
    \ [max];\n}\n", "  var res = [];\n  var i;\n  var currentMax = Number.MIN_SAFE_INTEGER;\n\
    \  for (i = 0; i < numbers.length; i++) {\n    if (numbers[i] > currentMax) {\n\
    \      res.push(numbers[i]);\n      currentMax = numbers[i];\n    }\n  }\n  return\
    \ res;\n}\n", "    let max = numbers[0] as number;\n    for (let i = 1; i < numbers.length;\
    \ i++) {\n        let current = numbers[i];\n        if (current > max) {\n  \
    \          max = current;\n        }\n    }\n    return [max];\n}", "  const res\
    \ = []\n\n  for (let i = 0; i < numbers.length; ++i) {\n    const value = numbers[i]\n\
    \    const max = numbers[i - 1]\n    if (max == value || (i > 0 && max > value))\
    \ {\n      continue\n    }\n    res.push(max)\n  }\n\n  return res\n}\n", "  \
    \  if (numbers.length < 2) {\n        return numbers;\n    }\n\n    const last_max\
    \ = numbers[numbers.length - 1];\n    const last_max_index = numbers.lastIndexOf(last_max);\n\
    \    if (last_max_index === -1) {\n        return numbers;\n    }\n\n    const\
    \ last_max_value = last_max;\n    const rolling_max = Array(last_max_index + 1).fill(0);\n\
    \    const rolling_max_start = last_max_index + 1;\n\n    let index = 0;\n   \
    \ while (index <= numbers.length - 1) {\n        if (numbers[index] > last_max_value)\
    \ {\n            rolling_max[rolling_max_start] = numbers[index];\n          \
    \  rolling_max_start++;\n        } else {\n            break;\n        }\n   \
    \     index++;\n    }\n\n    return rolling_max.slice(rolling_max_start);\n}\n",
  "    var max = Math.max(...numbers);\n    return numbers.filter(n => n <= max);\n\
    }\n", "  const max_value = Math.max.apply(Math, numbers);\n  let new_numbers =\
    \ numbers.filter(n => n > max_value);\n  return rolling_max(new_numbers);\n}\n\
    const rolling_max_2 = rolling_max;\n", "\tconst n = numbers.length;\n\tif (!n)\
    \ return [];\n\tlet ret = new Array(n);\n\tret[0] = numbers[0];\n\tfor (let i\
    \ = 1; i < n; ++i) {\n\t\tlet value = numbers[i];\n\t\tlet maxValue = value;\n\
    \t\tfor (let j = i + 1; j < n; ++j) {\n\t\t\tif (numbers[j] > value) {\n\t\t\t\
    \tvalue = numbers[j];\n\t\t\t\tmaxValue = value;\n\t\t\t}\n\t\t}\n\t\tret[i] =\
    \ maxValue;\n\t}\n\treturn ret;\n}", "  if (numbers.length === 0) {\n    throw\
    \ new Error(\"Expected at least 1 number\");\n  }\n  const rolling_max = numbers[0];\n\
    \  for (let i = 1; i < numbers.length; i++) {\n    rolling_max = Math.max(numbers[i],\
    \ rolling_max);\n  }\n  return rolling_max;\n}\n", "    const ret = [];\n    for\
    \ (let i = 0; i < numbers.length; ++i) {\n        ret.push(numbers[(i + numbers.length)\
    \ % numbers.length]);\n    }\n    return ret;\n}\n", "    var arr: number[] =\
    \ [];\n    numbers.forEach(n => {\n        arr.push(n);\n    });\n    while (numbers.length\
    \ > 0) {\n        var max: number = Math.max.apply(null, arr);\n        var index:\
    \ number = arr.indexOf(max);\n        if (index == arr.length - 1) {\n       \
    \     arr.splice(index, 1);\n        } else {\n            arr.splice(index +\
    \ 1, 1);\n        }\n    }\n    return arr;\n}\n", "  const len = numbers.length;\n\
    \  if (len === 0) {\n    return [];\n  }\n\n  return [numbers[0]].concat(\n  \
    \  numbers.map(\n      (number: number) => Math.max(number, numbers[len - 1])\n\
    \    )\n  );\n}\n", "    var result: number[] = [];\n    var max_number = 0;\n\
    \n    for (var i = 0; i < numbers.length; i++) {\n        if (numbers[i] > max_number)\
    \ {\n            max_number = numbers[i];\n        }\n    }\n\n    for (var i\
    \ = numbers.length - 1, n; i >= 0; i--) {\n        n = numbers[i];\n        if\
    \ (n <= max_number) {\n            result.unshift(n);\n        }\n    }\n\n  \
    \  return result;\n}\n", "    // Find first index that is smaller than the given\
    \ number\n    let index_min = 0;\n    for (let i = 0; i < numbers.length; i++)\
    \ {\n        if (numbers[i] < numbers[index_min]) {\n            index_min = i;\n\
    \        }\n    }\n    // Move elements after the index found to front of the\
    \ list\n    for (let i = index_min + 1; i < numbers.length; i++) {\n        const\
    \ tmp = numbers[i];\n        numbers[i] = numbers[index_min];\n        numbers[index_min]\
    \ = tmp;\n    }\n    // Return the resulting array\n    return numbers;\n}", " \
    \ let rolling_max: number[] = []\n  let rolling_max_index: number = 0\n  \n  while\
    \ (rolling_max_index < numbers.length) {\n    rolling_max_index = numbers.indexOf(rolling_max_index,\
    \ rolling_max_index + 1) + 1\n    rolling_max = rolling_max.concat(numbers.slice(rolling_max_index))\n\
    \  }\n  \n  return rolling_max\n}\n", "    var result = [];\n    var max = 0;\n\
    \    var current;\n    var i;\n\n    for (i = 0; i < numbers.length; i++) {\n\
    \        current = numbers[i];\n        while (current >= max) {\n           \
    \ result.push(max);\n            max = numbers[i + 1];\n        }\n        max\
    \ = current;\n    }\n    return result.concat(max);\n}\n", "  const rollingMax:\
    \ number[] = [];\n  let max: number = numbers[0];\n  numbers.forEach(number =>\
    \ {\n    if (number > max) max = number;\n  });\n  for (let i = numbers.length\
    \ - 1; i >= 0; i--) {\n    rollingMax.push(Math.max(rollingMax[rollingMax.length\
    \ - 1] || 0, numbers[i]));\n  }\n  return rollingMax;\n}\n", "    return numbers.reduce((acc,\
    \ num) => {\n        return num > acc ? num : acc;\n    });\n}\n", "  const result\
    \ = [];\n  let max_value = numbers[0];\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n \
    \   }\n    result.push(max_value);\n  }\n  return result;\n}\n", "  const max\
    \ = Math.max.apply(null, numbers);\n  const ret = [];\n  const start = 0;\n  for\
    \ (let i = numbers.length - 1; i >= 0; i--) {\n    if (numbers[i] > max) {\n \
    \     ret.push(max);\n      start = i;\n    } else {\n      ret.push(numbers[i]);\n\
    \    }\n  }\n  return ret.concat(numbers.slice(start));\n}\n", "  const result\
    \ = new Array(numbers.length);\n  const max_element = numbers.reduce((max_so_far,\
    \ element) => {\n    if (element > max_so_far) {\n      return element;\n    }\n\
    \    return max_so_far;\n  });\n  for (let i = 0; i < numbers.length; i++) {\n\
    \    result[i] = max_element;\n  }\n  return result;\n}", "  const rolling_max_result:\
    \ number[] = [];\n  let rolling_max = numbers[0];\n\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    if (numbers[i] >= rolling_max) {\n      rolling_max = numbers[i];\n\
    \    } else {\n      rolling_max_result.push(rolling_max);\n      rolling_max\
    \ = numbers[i];\n    }\n  }\n  rolling_max_result.push(rolling_max);\n  return\
    \ rolling_max_result;\n}\n", "    var result = [];\n    var currentMax = numbers[0];\n\
    \    for (var i = 1; i < numbers.length; i++) {\n        if (numbers[i] > currentMax)\
    \ {\n            result.push(currentMax);\n            currentMax = numbers[i];\n\
    \        } else {\n            currentMax = numbers[i];\n        }\n    }\n  \
    \  result.push(currentMax);\n    return result;\n}", "    let n = numbers.length;\n\
    \    let res = numbers.slice();\n    let k = n;\n\n    while (k >= 1) {\n    \
    \    let first = res[k];\n        let last = res[k - 1];\n        let firstMax\
    \ = last > first ? last : first;\n        let last = res[k - 1];\n        let\
    \ maxPos = res.lastIndexOf(firstMax);\n        let maxBefore = maxPos >= k ? res[k\
    \ - maxPos] : 0;\n        let maxBeforeLast = res.lastIndexOf(maxBefore, maxPos\
    \ - 1);\n        let maxAfter = res.lastIndexOf(last, maxPos);\n        let maxAfterLast\
    \ = maxAfter >= k ? res[k - maxAfter] : last;\n        if (lastMax === firstMax)\
    \ {\n            break;\n        }\n        if (maxAfter >= k) {\n           \
    \ res[k] = maxBeforeLast;\n            k += maxAfter - k;\n            n -= maxAfter\
    \ - k;\n        } else {\n            res[k] = maxBeforeLast;\n            n -=\
    \ maxPos - maxAfterLast;\n        }\n    }\n\n    return res;\n}\n", "  const\
    \ max_val: number[] = new Array(numbers.length);\n  max_val.fill(Number.NEGATIVE_INFINITY);\n\
    \  for (let i = 0; i < numbers.length; i++) {\n    max_val[i] = numbers[i]; //\
    \ default value is negative Infinity\n  }\n  for (let i = numbers.length - 1;\
    \ i > 0; i--) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (max_val[j]\
    \ > max_val[j + 1]) {\n        max_val[j] = max_val[j + 1];\n      }\n    }\n\
    \  }\n  return max_val;\n}\n", "    let rolling_max: number[] = [];\n    let rolling_max_index:\
    \ number[] = [];\n    let rolling_max_element: number = Number.NEGATIVE_INFINITY;\n\
    \n    for (let index = 0; index < numbers.length; index++) {\n        if (numbers[index]\
    \ > rolling_max_element) {\n            rolling_max_element = numbers[index];\n\
    \            rolling_max_index.push(index);\n        }\n    }\n\n    // console.log(rolling_max_element);\n\
    \    for (let index = rolling_max_index.length - 1; index > -1; index--) {\n \
    \       rolling_max.push(rolling_max_element);\n        numbers.splice(rolling_max_index[index],\
    \ 1);\n    }\n\n    return rolling_max;\n}\n", "  const result: number[] = [];\n\
    \  let max = Number.MIN_SAFE_INTEGER;\n  let min = 0;\n\n  numbers.forEach((n)\
    \ => {\n    if (n > 0) {\n      min = Math.min(min, n);\n    } else {\n      max\
    \ = Math.max(max, n);\n    }\n  });\n\n  for (let i = min; i < max; i++) {\n \
    \   result.push(i);\n  }\n\n  return result;\n}\n", "    var max_numbers: number[]\
    \ = [];\n    var min_numbers: number[] = [];\n    for (var i: number = 0; i <\
    \ numbers.length; i++) {\n        min_numbers.push(numbers[i]);\n    }\n\n   \
    \ for (var i: number = 0; i < numbers.length; i++) {\n        max_numbers.push(numbers[i]);\n\
    \    }\n\n    while (min_numbers.length < numbers.length) {\n        min_numbers.push(max_numbers[max_numbers.length\
    \ - 1]);\n        max_numbers.pop();\n    }\n\n    while (max_numbers.length <\
    \ numbers.length) {\n        max_numbers.push(min_numbers[min_numbers.length -\
    \ 1]);\n        min_numbers.pop();\n    }\n\n    var i: number;\n    var j: number;\n\
    \    var rolling_max: number[];\n    for (i = 0; i < min_numbers.length; i++)\
    \ {\n        rolling_max = max_numbers.concat(min_numbers);\n        j = 0;\n\
    \        while (j < numbers.length) {\n            if (rolling_max[j] > numbers[j])\
    \ {\n                rolling_max[j] = numbers[j];\n            } else {\n    \
    \            break;\n            }\n            j++;\n        }\n        min_numbers\
    \ = rolling_max;\n    }\n    return min_numbers;\n}\n", "    let arr = [];\n \
    \   for (let i = 0; i < numbers.length; i += 1) {\n        if (numbers[i] ===\
    \ 0) continue;\n        let max = numbers[i];\n        let index = i;\n      \
    \  for (let j = i + 1; j < numbers.length; j += 1) {\n            if (numbers[j]\
    \ > max) max = numbers[j];\n            index = j;\n        }\n        arr.push(max);\n\
    \        i = index;\n    }\n    return arr;\n}\n", "\tconst windowSize = 3;\n\t\
    const result = numbers.reduce((results: number[], n: number) => {\n\t\tconst window\
    \ = numbers.slice(Math.max(0, results.length - windowSize), results.length);\n\
    \t\tconst max = Math.max(...window);\n\t\tresults.push(max);\n\t\treturn results;\n\
    \t}, []);\n\treturn result;\n}\n", "    // @ts-ignore\n    return numbers.reduce((a,\
    \ b) =>\n        Math.max(a, b),\n    );\n}\n", "  const n = numbers.length;\n\
    \  const max_index = 0;\n  let max_element = numbers[0]\n  for (let i = 1; i <\
    \ n; i++) {\n    if (numbers[i] > max_element) {\n      max_element = numbers[i]\n\
    \      max_index = i\n    }\n  }\n  const res = [max_element]\n  for (let i =\
    \ 1; i < n; i++) {\n    res.push(numbers[i - 1] + numbers[i])\n  }\n  return res\n\
    }\n", "\tlet max = Number.MIN_VALUE;\n\tlet max_index = -1;\n\tfor (let index\
    \ = 0; index < numbers.length; index++) {\n\t\tif (numbers[index] > max) {\n\t\
    \t\tmax = numbers[index];\n\t\t\tmax_index = index;\n\t\t}\n\t}\n\treturn numbers.slice(0,\
    \ max_index + 1).reverse();\n}\n", "  // From each element of given array\n  //\
    \ calculate the max number until current moment\n  const max = numbers.reduce((previous:\
    \ number, current: number) => {\n    return Math.max(previous, current);\n  },\
    \ Number.NEGATIVE_INFINITY);\n  const res = [];\n  const now = moment();\n  //\
    \ Loop from each element of given array\n  for (const num of numbers) {\n    if\
    \ (num < max) {\n      res.push(num);\n    }\n    // Update max number\n    max\
    \ = Math.max(max, num);\n  }\n  // Push the remaining elements into res\n  for\
    \ (const num of numbers) {\n    if (num < max) {\n      res.push(num);\n    }\n\
    \  }\n  res.push(max);\n  return res;\n}\n", "    let rolling_max = [];\n    for(let\
    \ i = 0; i < numbers.length; i++) {\n        rolling_max[i] = rolling_max[i] ===\
    \ undefined ? 0 : rolling_max[i]\n        if(rolling_max[i] > numbers[i]) {\n\
    \            rolling_max[i] = numbers[i];\n        }\n    }\n    return rolling_max;\n\
    }\n", "    var max: number[] = [];\n    numbers.forEach(function (number) {\n\
    \        number.forEach(function (number) {\n            if (number > max[max.length\
    \ - 1]) {\n                max[max.length - 1] = number;\n            }\n    \
    \    });\n    });\n    return max;\n}\n", "    const result: number[] = [];\n\
    \    let rolling_max: number;\n    let i = 0;\n    for (i; i < numbers.length;\
    \ i++) {\n        rolling_max = Math.max(rolling_max, numbers[i]);\n        result.push(rolling_max);\n\
    \    }\n    return result;\n}\n", "  let maximum = numbers[0];\n  let rollingMaxIndex\
    \ = 0;\n  for (let i = 1; i < numbers.length; ++i) {\n    if (numbers[i] >= maximum)\
    \ {\n      rollingMaxIndex++;\n      maximum = numbers[i];\n    }\n  }\n  const\
    \ rollingMax = numbers.slice(rollingMaxIndex);\n  return rollingMax;\n}\n", " \
    \ numbers = numbers.map(number => number < 0 ? -number : number);\n  let current\
    \ = numbers[0];\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    if (current > numbers[i]) {\n      max = numbers[i];\n      maxIndex\
    \ = i;\n      current = numbers[i];\n    } else {\n      max = Math.max(max, numbers[i]);\n\
    \    }\n  }\n  return numbers.slice(0, maxIndex + 1);\n}\n", "  return rolling_max(numbers,\
    \ 0);\n}\n", "\tvar max = numbers[0];\n\tvar index = -1;\n\tfor (var i = 0; i\
    \ < numbers.length; i++) {\n\t\tindex = numbers.indexOf(max, index + 1);\n\t\t\
    if (index >= numbers.length - 1) {\n\t\t\treturn [max];\n\t\t}\n\t\tmax = Math.max(max,\
    \ numbers[index]);\n\t}\n\treturn [];\n}\n", "\tlet max_value: number = 0;\n\t\
    let max_index = 0;\n\tfor (let i = 0; i < numbers.length; ++i) {\n\t\tlet current_max\
    \ = Math.max(max_value, numbers[i]);\n\t\tif (current_max > max_value) {\n\t\t\
    \tmax_value = current_max;\n\t\t\tmax_index = i;\n\t\t}\n\t}\n\tlet result: number[]\
    \ = [];\n\tfor (let i = 0; i < numbers.length; ++i) {\n\t\tif (numbers[i] ===\
    \ max_value) {\n\t\t\tresult.push(numbers[i]);\n\t\t}\n\t}\n\treturn result;\n\
    }", "  let max_rolling_number: number[] = [];\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    const index = numbers.indexOf(i + 1);\n    max_rolling_number[i]\
    \ = numbers[index];\n  }\n  return max_rolling_number;\n}\n", "    let rolling_maxes:\
    \ number[] = [];\n\n    numbers.forEach((number) => {\n        let max_rolling_number:\
    \ number = 0;\n        let index: number = 0;\n\n        while (index <= rolling_maxes.length)\
    \ {\n            if (number > rolling_maxes[index]) {\n                rolling_maxes[index]\
    \ = number;\n            }\n            index++;\n        }\n\n        if (rolling_maxes.length\
    \ > 0) {\n            max_rolling_number = rolling_maxes[rolling_maxes.length\
    \ - 1];\n        } else {\n            max_rolling_number = number;\n        }\n\
    \        rolling_maxes.push(max_rolling_number);\n    });\n\n    return rolling_maxes;\n\
    }\n", "  var i = -1;\n  var results: number[] = [];\n  var len = numbers.length;\n\
    \  while (++i < len) {\n    var max = numbers[i];\n    results.unshift(max);\n\
    \    for (var j = 1; j < numbers.length; ++j) {\n      if (numbers[j] >= max)\
    \ {\n        max = numbers[j];\n        results.unshift(max);\n      }\n    }\n\
    \  }\n  return results;\n}\n", "    const len = numbers.length;\n    if (len ===\
    \ 0) {\n        return [];\n    }\n    numbers.sort((a, b) => a - b);\n    let\
    \ rolling_max = 0;\n    let rolling_max_idx = 1;\n    let result = [];\n    for\
    \ (let i = 1; i < len; i++) {\n        if (numbers[i - 1] < rolling_max) {\n \
    \           if (rolling_max_idx < i) {\n                result[rolling_max_idx]\
    \ = numbers[i - 1];\n            }\n            rolling_max = numbers[i - 1];\n\
    \            rolling_max_idx = i;\n        } else {\n            rolling_max_idx\
    \ += 1;\n        }\n    }\n    result[rolling_max_idx] = rolling_max;\n    return\
    \ result;\n}", "\tnumbers.sort((a: number, b: number) => a - b);\n\tlet result:\
    \ number[] = [];\n\tlet i = 0;\n\twhile (i < numbers.length) {\n\t\tresult.push(numbers[i]);\n\
    \t\tif (numbers[i + 1] == numbers[i]) {\n\t\t\ti++;\n\t\t} else {\n\t\t\ti = Math.max(i\
    \ - 1, 0);\n\t\t}\n\t}\n\treturn result;\n}\n", "  const rolling_max: number[]\
    \ = [];\n  let i = 0;\n  while (numbers[i] != undefined) {\n    rolling_max.push(numbers[i]);\n\
    \    i++;\n  }\n  return rolling_max;\n}\n", "  const result: number[] = [];\n\
    \  numbers.forEach(value => {\n    const min = Math.min.apply(null, result);\n\
    \    if (min < value) {\n      result.push(value);\n    }\n  });\n  return result;\n\
    }\n", "  return numbers.reduce((prev, current) =>\n    prev >= current ? prev\
    \ : prev + current, 0\n  );\n}\n", "  return numbers.reduceRight((accumulator,\
    \ currentValue) => {\n    accumulator.push(currentValue);\n    return accumulator.slice(-numbers.length);\n\
    \  }, []);\n}\n", "  const results: number[] = [];\n  for (let i = 0, max = numbers[0];\
    \ i < numbers.length; i++) {\n    if (max < numbers[i]) {\n      max = numbers[i];\n\
    \    }\n    results.push(max);\n  }\n  return results;\n}\n", "  const len = numbers.length;\n\
    \  const max = numbers[0];\n\n  if (len === 1) {\n    return max;\n  }\n\n  for\
    \ (let i = 1; i < len; i++) {\n    if (max < numbers[i]) {\n      max = numbers[i];\n\
    \    }\n  }\n  return max;\n}\n", "  const rolling_maxes = new Array<number>();\n\
    \  let last_max = numbers[0];\n  numbers.forEach((number) => {\n    if (number\
    \ > last_max) {\n      rolling_maxes.push(number);\n      last_max = number;\n\
    \    } else {\n      rolling_maxes[rolling_maxes.length - 1] = last_max;\n   \
    \ }\n  });\n  return rolling_maxes;\n}\n", "    var rollingMaxArray: number[]\
    \ = [];\n\n    var maxNum = numbers[0];\n\n    for (var i = 1; i < numbers.length;\
    \ i++) {\n        if (numbers[i] > maxNum) {\n            rollingMaxArray.push(maxNum);\n\
    \            maxNum = numbers[i];\n        } else {\n            rollingMaxArray.push(numbers[i]);\n\
    \        }\n    }\n    rollingMaxArray.push(maxNum);\n    return rollingMaxArray;\n\
    }\n", "    let result = new Array<number>();\n    for (let i = numbers.length\
    \ - 1; i >= 0; i--) {\n        let max = numbers[i];\n        let j = i;\n   \
    \     while (j < numbers.length && numbers[j] < max) {\n            max = numbers[j];\n\
    \            j++;\n        }\n        result.push(max);\n    }\n    return result;\n\
    }\n", "    const length = numbers.length\n    return numbers.map(number => {\n\
    \        if (numbers.length === 0) {\n            return number\n        } else\
    \ {\n            const maxNumber = Math.max.apply(null, numbers)\n           \
    \ if (number === maxNumber) {\n                return maxNumber\n            }\
    \ else {\n                return number\n            }\n        }\n    })\n}\n",
  "  var max_element = numbers[0];\n  var max_element_index = -1;\n\n  for (let i\
    \ = 1; i < numbers.length; i++) {\n    if (numbers[i] > max_element) {\n     \
    \ max_element = numbers[i];\n      max_element_index = i;\n    }\n  }\n\n  return\
    \ numbers.slice(0, max_element_index + 1).reverse();\n}\n", "  const max_number\
    \ = Math.max(...numbers);\n  const rolling_max_numbers: number[] = [];\n  let\
    \ current_number = max_number;\n  while (current_number != max_number) {\n   \
    \ rolling_max_numbers.push(current_number);\n    current_number = Math.max(...rolling_max_numbers);\n\
    \  }\n  return rolling_max_numbers;\n}\n", "\tvar result = new Array<number>();\n\
    \tvar max = numbers[0];\n\tfor (var i = 1; i < numbers.length; i++) {\n\t\tvar\
    \ n = numbers[i];\n\t\tif (n > max) {\n\t\t\tmax = n;\n\t\t}\n\t}\n\tresult.push(max);\n\
    \treturn result;\n}\n", "    const result: number[] = [];\n    let max = numbers[0];\n\
    \    let currentMax = numbers[0];\n    for (let i = 1; i < numbers.length; i++)\
    \ {\n        if (numbers[i] > currentMax) {\n            currentMax = max;\n \
    \           result.push(max);\n            max = numbers[i];\n        } else {\n\
    \            max = currentMax;\n        }\n    }\n    result.push(max);\n    return\
    \ result;\n}\n", "  if (numbers.length === 0) {\n    return [];\n  }\n\n  var\
    \ max_so_far = numbers[0];\n  var max_ending_here = numbers[0];\n\n  for (var\
    \ i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max_ending_here) {\n\
    \      max_ending_here = numbers[i];\n    }\n\n    if (numbers[i] > max_so_far)\
    \ {\n      max_so_far = numbers[i];\n    }\n  }\n\n  return [max_so_far, max_ending_here];\n\
    }\n", "  let result: number[] = [];\n  let currentMax: number = 0;\n  for (let\
    \ n of numbers) {\n    if (n > currentMax) {\n      currentMax = n;\n    }\n \
    \   if (n === currentMax) {\n      result.push(n);\n    }\n  }\n  return result;\n\
    }\n", "\tlet result: number[] = [];\n\tnumbers.reduce((prev, curr) => {\n\t\t\
    if (prev < curr) {\n\t\t\tresult.push(prev);\n\t\t}\n\t\treturn curr;\n\t});\n\
    \treturn result;\n}\n", "  const result: number[] = [];\n  let prev: number |\
    \ undefined = undefined;\n  numbers.forEach((value: number, index: number) =>\
    \ {\n    if (index === 0 || value > prev) {\n      result.push(value);\n    }\n\
    \    prev = value;\n  });\n  return result;\n}\n", "    var ret: number[] = [];\n\
    \    var temp: number = 0;\n    var lastNumber: number = 0;\n    var lastTemp:\
    \ number = 0;\n\n    numbers.forEach(function (number: number, index: number)\
    \ {\n        if (number > lastNumber) {\n            lastTemp = temp;\n      \
    \      temp = number;\n            lastNumber = number;\n        } else {\n  \
    \          temp = temp * 10 + number;\n        }\n    });\n\n    ret.push(lastTemp);\n\
    \    return ret;\n}\n", "    let max: number[] = [];\n    const max_indexes: number[]\
    \ = [];\n    let index: number;\n    let number;\n    let length: number;\n  \
    \  let i;\n\n    if (numbers.length < 1) {\n        return max;\n    }\n\n   \
    \ max = numbers.slice();\n    length = numbers.length;\n\n    for (i = 0; i <=\
    \ length; i++) {\n        index = i - 1;\n        number = numbers[i];\n\n   \
    \     while (index >= 0) {\n            if (number > max[index]) {\n         \
    \       max[index] = number;\n                max_indexes.push(index);\n     \
    \       }\n\n            index--;\n        }\n    }\n\n    for (i = 0; i < length;\
    \ i++) {\n        number = numbers[i];\n        numbers[max_indexes[i]] = number;\n\
    \    }\n\n    return max;\n}\n", "    const rolling_maxes: number[] = [];\n  \
    \  let max: number;\n    let min: number;\n    for (let i = 0; i < numbers.length;\
    \ i++) {\n        max = numbers[i];\n        min = numbers[i];\n        for (let\
    \ j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > max) {\n\
    \                max = numbers[j];\n            }\n            if (numbers[j]\
    \ < min) {\n                min = numbers[j];\n            }\n        }\n    \
    \    rolling_maxes[i] = min;\n    }\n    return rolling_maxes;\n}", "    let result\
    \ = [];\n    let index = numbers.length - 1;\n    numbers.forEach((number, i)\
    \ => {\n        if (index < 0) {\n            return;\n        }\n        if (number\
    \ > numbers[index]) {\n            result.push(number);\n            index--;\n\
    \        }\n    });\n    return result.concat();\n}\n", "\tconst maxValues: number[]\
    \ = [];\n\tfor (let n of numbers) {\n\t\tmaxValues.push(Math.max(n));\n\t}\n\t\
    return maxValues;\n}\n", "  let max = numbers[0];\n  let current = numbers[0];\n\
    \  let result: number[] = [];\n  for (let i = 1; i < numbers.length; i++) {\n\
    \    if (numbers[i] > max) {\n      max = numbers[i];\n      current = numbers[i];\n\
    \    } else {\n      current = numbers[i];\n    }\n    result.push(current);\n\
    \  }\n  return result;\n}\n", "  const min_number = numbers.reduce((a, v) => v\
    \ > a ? v : a, numbers[0]);\n  const max_number = numbers.reduce((a, v) => v >\
    \ a ? v : a, numbers[0]);\n  const max_number_index = numbers.indexOf(max_number);\n\
    \  const rolling_max_array = numbers.map((v, i) => v === max_number ? max_number_index\
    \ + i : v);\n  return rolling_max_array;\n}\n", "    let max: number|null = null;\n\
    \    let maxIndex: number|null = null;\n    numbers.forEach(\n        (element,\
    \ index) => {\n            max = element;\n            maxIndex = index;\n   \
    \     });\n    let rollingMax = [];\n    let rollingMaxElement = max;\n    let\
    \ rollingMaxIndex = maxIndex;\n    numbers.forEach(\n        (element, index)\
    \ => {\n            if (element > rollingMaxElement) {\n                rollingMaxElement\
    \ = element;\n                rollingMaxIndex = index;\n            }\n      \
    \  });\n    rollingMax.push(rollingMaxElement);\n    if (maxIndex < numbers.length\
    \ - 1) {\n        rollingMax = rollingMax.concat(rolling_max(numbers.slice(maxIndex\
    \ + 1)));\n    }\n    return rollingMax;\n}\n", "    const result = [];\n    const\
    \ maxes = [];\n    for (let i = 0; i < numbers.length; ++i) {\n        maxes.push(numbers[i]);\n\
    \        result.push(numbers[i]);\n        for (let j = i + 1; j < numbers.length;\
    \ ++j) {\n            if (numbers[i] > numbers[j]) {\n                maxes[j]\
    \ = numbers[j];\n                result[j] = numbers[j];\n            }\n    \
    \    }\n    }\n    return result;\n}\n", "  return numbers.reduce(function(a:\
    \ number[], n: number) {\n    a.push(n);\n    return a;\n  }, []);\n}\n", "  return\
    \ numbers.reduce((prev, curr) => {\n    return prev > curr ? prev : curr;\n  });\n\
    }\n", "  const result = [];\n  const max = numbers[0];\n\n  for (let i = 1; i\
    \ < numbers.length; i++) {\n    if (max < numbers[i]) {\n      max = numbers[i];\n\
    \    }\n  }\n\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i]\
    \ === max) {\n      result.push(max);\n    }\n  }\n\n  return result;\n}\n", " \
    \ const result = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    let\
    \ max = numbers[i];\n    let index = i;\n\n    while (true) {\n      max = numbers[++index];\n\
    \      if (max > numbers[index]) {\n        max = numbers[index];\n        index\
    \ = index;\n      } else {\n        result.push(max);\n        break;\n      }\n\
    \    }\n  }\n\n  return result;\n}\n", "    if (numbers.length === 0) {\n    \
    \    return [];\n    }\n    const result = new Array(numbers.length);\n    result[0]\
    \ = Math.max(...numbers);\n    for (let i = 1; i < numbers.length; i++) {\n  \
    \      result[i] = Math.max(numbers[i - 1], numbers[i]);\n    }\n    return result;\n\
    }", "    const rolling_maxes = new Array<number>();\n    let max = Number.MIN_VALUE;\n\
    \    numbers.forEach(number => {\n        max = Math.max(max, number);\n    });\n\
    \    let rollingMax = max;\n    while (rollingMax !== Number.MIN_VALUE) {\n  \
    \      rollingMaxes.unshift(rollingMax);\n        max = Number.MIN_VALUE;\n  \
    \      numbers.forEach(number => {\n            max = Math.max(max, number);\n\
    \            if (number === rollingMax) {\n                rollingMax = max;\n\
    \            }\n        });\n    }\n    return rollingMaxes;\n}", "  var rolling_max\
    \ = new Array<number>();\n  var _max = numbers[0];\n  rolling_max[0] = _max;\n\
    \n  var i;\n  for (i = 1; i < numbers.length; ++i) {\n    if (numbers[i] > _max)\
    \ {\n      rolling_max[i] = numbers[i];\n      _max = numbers[i];\n    } else\
    \ {\n      rolling_max[i] = _max;\n    }\n  }\n\n  return rolling_max;\n}\n",
  "  let max: number = 0;\n  let result: number[] = [];\n  for (const n of numbers)\
    \ {\n    const nextMax = Math.max(max, n);\n    max = nextMax;\n    result.push(nextMax);\n\
    \  }\n  return result;\n}\n", "    const result: number[] = [];\n    for (let\
    \ i = 1; i <= numbers.length; i++) {\n        const temp = result.slice();\n \
    \       result.push(Math.max(numbers[i - 1], numbers[i]));\n        if (numbers[i]\
    \ > numbers[i - 1]) {\n            for (let j = 0; j < temp.length; j++) {\n \
    \               if (temp[j] > numbers[i] && temp[j] >= numbers[i - 1]) {\n   \
    \                 temp[j] = Math.max(temp[j], numbers[i]);\n                }\n\
    \            }\n        }\n    }\n    return result;\n}", "  if (numbers.length\
    \ <= 1) {\n    return numbers;\n  }\n  let max_so_far = numbers[0];\n  for (let\
    \ i = 1; i < numbers.length; i++) {\n    if (numbers[i] > max_so_far) {\n    \
    \  max_so_far = numbers[i];\n    }\n  }\n  return [max_so_far];\n}\n", "    let\
    \ sum: number = 0;\n    let max: number = 0;\n    let i = 0; //The index of the\
    \ current maximum element.\n    const result: number[] = []; //The result array,\
    \ filled with rolling maximum elements.\n    while (i < numbers.length) {\n  \
    \      sum += numbers[i];\n        if (sum > max) {\n            max = sum;\n\
    \        }\n        i++;\n        result.push(max);\n    }\n    return result;\n\
    }\n", "\tconst array = numbers.map(number => Math.max(number));\n\treturn array;\n\
    }\n", "\tconst rolling_max = numbers.reduce((previousValue, currentValue) => {\n\
    \t\tif (previousValue < currentValue) return previousValue;\n\t\treturn currentValue;\n\
    \t});\n\treturn rolling_max;\n}\n", "    var result: number[] = [],\n        prevMax:\
    \ number = Number.MIN_VALUE,\n        current: number = 0,\n        index: number\
    \ = 0;\n\n    while (index < numbers.length) {\n        if (numbers[index] > prevMax)\
    \ {\n            prevMax = current;\n            current = numbers[index];\n \
    \           index = index;\n        } else {\n            result[result.length]\
    \ = current;\n            prev = current;\n            current = numbers[index];\n\
    \            index = index;\n        }\n    }\n    result[result.length] = current;\n\
    \n    return result;\n}\n", "    if (numbers.length <= 0) {\n        return [];\n\
    \    }\n    var result: number[] = [];\n    var max: number[] = [];\n    var currentMax\
    \ = 0;\n    numbers.forEach(function (number) {\n        var result = rolling_max(numbers);\n\
    \        result.push(number);\n        if (number === currentMax) {\n        \
    \    result.push(number);\n        }\n        if (numbers.length > 1 && number\
    \ > currentMax) {\n            result.push(number);\n            max = rolling_max(max);\n\
    \            currentMax = max[0];\n        }\n    });\n    if (max.length > 0)\
    \ {\n        result = max.concat(result);\n    }\n    return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
