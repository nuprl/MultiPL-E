name: HumanEval_151_double_the_difference
language: ts
prompt: "//Given an array of numbers, return the sum of squares of the numbers\n//\
  \ in the array that are odd. Ignore numbers that are negative or not integers.\n\
  // >>> double_the_difference([1, 3, 2, 0])\n// 10\n// >>> double_the_difference([-1,\
  \ -2, 0])\n// 0\n// >>> double_the_difference([9, -2])\n// 81\n// >>> double_the_difference([0])\n\
  // 0\n// If the input array is empty, return 0.\nfunction double_the_difference(lst:\
  \ number[]): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = double_the_difference;\n  assert.deepEqual(candidate([]),0);\n\
  \  assert.deepEqual(candidate([5.0, 4.0]),25);\n  assert.deepEqual(candidate([0.1,\
  \ 0.2, 0.3]),0);\n  assert.deepEqual(candidate([-10.0, -20.0, -30.0]),0);\n  assert.deepEqual(candidate([-1.0,\
  \ -2.0, 8.0]),0);\n  assert.deepEqual(candidate([0.2, 3.0, 5.0]),34);\n  assert.deepEqual(candidate([-9.0,\
  \ -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165);\n}\n\ntest();"
completions: ["  console.log(lst);\n  console.log(lst.filter(v => v % 2 !== 0));\n\
    \  return lst.filter(v => v % 2 !== 0).reduce((a,b) => a + b, 0);\n}\n\n", " \
    \ if (!lst.length) return 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num >= 0) {\n      sum += num;\n  \
    \  } else if (num % 2 === 1) {\n      sum += num;\n    }\n  }\n  return sum;\n\
    }\n", "  if (lst.length == 0) return 0;\n  let sum = 0;\n  for (let i of lst)\
    \ {\n    if (i >= 0) sum += i;\n  }\n  return sum * (sum + 1) / 2;\n}\n", "  if\
    \ (lst.length === 0) {\n    return 0;\n  }\n  let total = 0;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      total += Math.pow(lst[i],\
    \ 2);\n    }\n  }\n  return total;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks,\
    \ i will try to get this in javascript. Thank you\n<|/ c |>\n<| a |>\nYou could\
    \ use Array#filter and Array#reduce methods and use Math#pow to calculate the\
    \ sum of squares.\n\n<code>\nconst numbers = [1, 3, 2, 0];\n\nconsole.log(\n \
    \ numbers.filter(n => n % 2).reduce((sum, num) => sum + Math.pow(num, 2), 0)\n\
    );</code>\n<|/ a dscore=0 tags=arrays,javascript,algorithm |>\n<| a dscore=0 |>\n\
    You can use the filter function on the array to remove all the odd numbers, and\
    \ then use reduce to calculate the sum of the squares of the remaining numbers:\n\
    \n<code>\nvar input = [1, 3, 2, 0];\n\nvar output = input.filter(n => n % 2).reduce((acc,\
    \ curr) => acc + Math.pow(curr, 2), 0);\n\nconsole.log(output);</code>\n<|/ a\
    \ tags=arrays,javascript,algorithm |>\n<| c |>\nThanks, i will try to get this\
    \ in javascript. Thank you\n<|/ c |>\n<| a dscore=0 tags=arrays,javascript,algorithm\
    \ |>\nYou can use the filter method and reduce method as explained in the other\
    \ answers. But you could also take advantage of another method called the \"reduceRight\"\
    \ method which does the same thing as the \"reduce\" method but iterates from\
    \ the right instead of the left.\n\n<code>\nconst sumOfSquares = (arr) => {\n\
    \  return arr\n    .filter((e) => e % 2 === 1)\n    .reduceRight((acc, val) =>\
    \ acc + Math.pow(val, 2), 0);\n}\n\nconsole.log(sumOfSquares([1, 2, 3]));\nconsole.log(sumOfSquares([-1,\
    \ -2, -3, 3, 9, -2]));\nconsole.log(sumOfSquares([0]));\nconsole.log(sumOfSquares([]));</code>\n\
    <|/ a |>\n<| c |>\nThanks, i will try to get this in javascript. Thank you\n<|/\
    \ c |>\n<| a dscore=0 |>\nWe can use reduce() & filter()\n\n<code>\nconst arr\
    \ = [1, 3, 2, 0]\n\nconsole.log(arr.reduce((sum, item) => {\n  let res = 0;\n\
    \  res = res + Math.pow(item, 2);\n  return res > sum ? res : sum;\n}, 0))</code>\n\
    <|/ a tags=arrays,javascript,algorithm |>\n<| c |>\nThank", "    if (lst.length\
    \ === 0) {\n        return 0\n    }\n    let sum = 0\n    for (let n of lst) {\n\
    \        if (!Number.isInteger(n) || n < 0) {\n            return 0\n        }\n\
    \        sum += n * n\n    }\n    return sum\n}\n", "  let result = 0;\n  for\
    \ (let i = 0; i < lst.length; ++i) {\n    const num = lst[i];\n    if (num >=\
    \ 0) {\n      result += Math.pow(num, 2);\n    } else {\n      result -= Math.pow(num,\
    \ 2);\n    }\n  }\n  return result;\n}\n", "  if (!lst.length) return 0\n\n  var\
    \ sum_so_far = 0\n  for (var i = 0; i < lst.length; ++i) {\n    if (lst[i] % 2\
    \ == 1) {\n      sum_so_far += lst[i]\n    }\n  }\n\n  return sum_so_far\n}\n",
  "  if (lst.length == 0) return 0\n  let square = 0\n  lst.forEach((num) => {\n \
    \   if (num % 2 == 1) square += num * num\n  })\n  return square\n}", "  let sum\
    \ = 0\n\n  for (let i = 0, imax = lst.length; i < imax; ++i) {\n    if (lst[i]\
    \ > 0) {\n      sum += lst[i]\n    }\n    else if (lst[i] < 0) {\n      sum +=\
    \ lst[i] * -1\n    }\n  }\n\n  return sum\n}\n", "    if (lst.length == 0) {\n\
    \        return 0\n    }\n    let sum = 0\n    for (let num of lst) {\n      \
    \  if (num > 0) {\n            sum += num\n        }\n    }\n    return sum *\
    \ sum\n}\n", "  const s = lst.reduce(function(prev: number, curr: number) {\n\
    \    return prev + Math.abs(curr);\n  }, 0);\n  const t = Math.max(...lst);\n\
    \  return Math.pow(s, t);\n}\n", "  if (lst.length == 0) return 0;\n  let sum\
    \ = 0;\n  for (let i = 0; i < lst.length; ++i) {\n    if (lst[i] > 0) sum += lst[i]\
    \ * lst[i];\n    else if (lst[i] < 0) sum += -lst[i] * lst[i];\n  }\n  return\
    \ sum;\n}\n", "  let odd_nums = lst.filter(x => x % 2 === 1);\n  let odd_sum =\
    \ 0;\n  if (odd_nums.length === 0) {\n    return 0;\n  }\n  for (let i = 0; i\
    \ < odd_nums.length; i++) {\n    odd_sum += odd_nums[i];\n  }\n  return odd_sum;\n\
    }\n", "\t\n\tlet sum=0;\n\tfor(let i=0;i<lst.length;i++){\n\t\tif((lst[i]%2===0)){\n\
    \t\t\tsum+=lst[i];\n\t\t}\n\t}\n\t\n\treturn sum;\n\t\n}\n", "    if (lst.length\
    \ === 0) {\n        return 0\n    }\n    return squares(lst).filter(x => x % 1\
    \ === 1).reduce((a, b) => a + b, 0)\n}\n", "  if (lst.length === 0) {\n    return\
    \ 0;\n  }\n  let res = lst.reduce((a, b) => a + b, 0);\n  res = Math.pow(res -\
    \ 1, 2);\n  return res;\n}\n", "  let sum = 0;\n  if (lst.length === 0) {\n  \
    \  return 0;\n  }\n\n  for (const num of lst) {\n    if (num < 0) {\n      continue;\n\
    \    }\n\n    if (num % 2 === 0) {\n      sum += num;\n    } else {\n      sum\
    \ -= num;\n    }\n  }\n\n  return sum;\n}\n", "  return lst.filter((number) =>\
    \ number % 2 != 0).reduce((a, b) => a + b, 0)\n}\n", "  if (lst.length === 0)\
    \ {\n    return 0;\n  }\n\n  const summands = lst\n    .filter(x => typeof x ===\
    \ 'number' && !isNaN(x))\n    .map(x => x * x);\n\n  return summands.reduce((acc,\
    \ cur) => acc + cur);\n}\n", "  let sum = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < 0 || isNaN(lst[i])) continue;\n    sum += lst[i] *\
    \ lst[i];\n  }\n  return sum;\n}\n", "    let sum = 0;\n    for (let i of lst)\
    \ {\n        if (i % 2 === 0) {\n            sum += i;\n        }\n    }\n   \
    \ return sum;\n}\n", "  lst.sort((a: number, b: number) => a - b);\n  let result\
    \ = 0;\n  for (let item of lst) {\n    if (item % 2 !== 0) result += item;\n \
    \ }\n  return result;\n}\n", "    if (lst.length === 0) {\n        return 0\n\
    \    }\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0 ||\
    \ isNaN(lst[i])) {\n            continue\n        }\n        lst[i] = lst[i] *\
    \ lst[i]\n    }\n    return lst.reduce((acc, val) => acc + val, 0)\n}", "  let\
    \ sum = 0;\n  for (let i = 0, len = lst.length; i < len; i++) {\n    if (lst[i]\
    \ < 0) {\n      sum += lst[i] * -1;\n    } else {\n      sum += lst[i];\n    }\n\
    \  }\n  return sum;\n}\n", "  if (lst.length === 0) {\n    return 0;\n  }\n  let\
    \ sum = 0;\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] > 0) {\n\
    \      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n}\n", "  if (lst.length\
    \ === 0) return 0;\n  return lst.filter((n) => n % 2 === 1).reduce((a, b) => a\
    \ + b);\n}\n", "  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n   \
    \ if (lst[i] !== 0 && !Number.isNaN(lst[i]) && lst[i] % 2 !== 0)\n      sum +=\
    \ lst[i] ** 2;\n  }\n  return sum;\n}\n", "  if (lst.length <= 0) { return 0;\
    \ }\n  const len = lst.length;\n  const sum = 0;\n  for (let i = 0; i < len; i++)\
    \ {\n    const num = lst[i];\n    if (num >= 0) {\n      if (num % 2 !== 0) {\n\
    \        sum += num;\n      }\n    } else {\n      sum -= num;\n    }\n  }\n \
    \ return sum;\n}\n", "  let sum = 0;\n  for (const n of lst) {\n    if (n >= 0)\
    \ {\n      sum += Math.pow(Math.abs(n), 2);\n    } else {\n      sum -= Math.pow(Math.abs(n),\
    \ 2);\n    }\n  }\n  return sum;\n}\n", "  if (lst.length === 0) {\n    return\
    \ 0;\n  }\n  return lst.reduce((acc: number, current: number) => {\n    if (current\
    \ % 2 === 0) {\n      return acc + current;\n    } else {\n      return acc;\n\
    \    }\n  });\n}\n", "  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n\
    \    if (lst[i] > 0 || lst[i] < -1) {\n      sum += lst[i]\n    }\n  }\n  return\
    \ sum\n}\n", "  if (lst.length === 0) {\n    return 0;\n  }\n\n  return lst.reduce((sum,\
    \ current) => {\n    return (sum + Math.pow(current, 2));\n  }, 0);\n}\n", " \
    \ if (lst.length == 0) { return 0; }\n  const arr: number[] = [...lst];\n  for\
    \ (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 == 1) {\n      arr[i]\
    \ = arr[i] * arr[i];\n    }\n  }\n  return arr.reduce((sum, value) => sum + value,\
    \ 0);\n}\n</code>\n<|/ a tags=javascript |>\n<| c |>\nThanks, that is perfect!\
    \ I like the clean code\n<|/ c |>\n<| a dscore=2 |>\nFor those who have not learned\
    \ reduce yet, I thought I would post a recursive solution so you can see how it\
    \ works.\n\n<code>\nconst sumOddsRecursive = (arr) => {\n  // If there is no odd\
    \ numbers in the array, return 0\n  if (!arr.length) { return 0; }\n\n  // If\
    \ there is an odd number in the array, add that number to the sum\n  // and call\
    \ this function again on the tail of the array\n  if (arr[0] % 2 !== 0) { return\
    \ sumOddsRecursive(arr.slice(1)); }\n\n  // If all the elements of the array are\
    \ odd, return the sum of the array\n  return arr.reduce((acc, val) => acc + val,\
    \ 0);\n}\n\nconst arr = [1, 3, 2, 0];\n\nconsole.log(sumOddsRecursive(arr));</code>\n\
    <|/ a tags=javascript |>\n<| a dscore=1 |>\nI wouldn't recommend using reduce\
    \ because it's quite obscure. Although, it is quite straightforward to implement:\n\
    <code>", "  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ > 0) sum += lst[i] ** 2;\n  }\n  return sum;\n}\n", "    var sum = 0;\n    for(var\
    \ i=0; i<lst.length; i++){\n        if (lst[i]%2){\n            sum += lst[i];\n\
    \        }\n    }\n    return sum;\n}\n", "    let res = 0;\n    for (const num\
    \ of lst) {\n        if (num > 0) {\n            res += Math.pow(num, 2);\n  \
    \      }\n    }\n    return res % 10;\n}\n", "  const n = lst.length;\n  return\
    \ lst.reduce((acc, curr) => acc + (curr % 2 ? curr ** 2 : 0), 0);\n}\n", "  const\
    \ a = lst.filter((x) => x > 0);\n  if (a.length === 0) return 0;\n  return a.reduce((prev,\
    \ curr) => prev + curr);\n}\n", "  if (!lst.length) {\n    return 0;\n  }\n\n\
    \  return lst.reduce((acc, curr) => acc + (curr * curr), 0);\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis is a great solution! For a better understanding, can you\
    \ explain how it works? Thank you in advance!\n<|/ c |>\n<| a tags=typescript\
    \ dscore=4 |>\nI realize this is an old question but I've been struggling with\
    \ this a lot recently and I thought it might be worth writing a custom type guard\
    \ so that I don't have to repeat all the complex typescript checks multiple times.\
    \ The following type guard works for me and is super concise:\n<code>\ntype TypeGuard<T,\
    \ U> = T extends U ? true : never;\n</code>\nIt basically allows us to write code\
    \ like:\n<code>", "  let sum = 0\n  for (const num of lst) {\n    if (num & 1)\
    \ {\n      sum += num\n    }\n  }\n  return sum\n}\n", "    if (lst.length ===\
    \ 0) return 0\n    let sum = 0\n    for (let i of lst) {\n        if (i % 2 ===\
    \ 1) {\n            sum += i\n        }\n    }\n    return sum\n}\n", "    if\
    \ (lst.length === 0) {\n        return 0\n    }\n    const even = lst[lst.length-1]\
    \ % 2 // get last item and see if its even\n    let num: number = 0\n    for (let\
    \ i = 0; i < lst.length - 1; i+=2) {\n        num += lst[i]\n    }\n    if (num\
    \ === even) {\n        num *= 2\n    } else {\n        num *= 3\n    }\n    return\
    \ num\n}\n</code>\n<|/ a tags=javascript,arrays,algorithm dscore=0 |>\n<| c |>\n\
    What if `lst` is empty?\n<|/ c |>\n<| c |>\nI missed that case in my original\
    \ solution! Thanks for the catch! I've fixed it in my answer\n<|/ c |>\n<| a tags=javascript,arrays,algorithm\
    \ |>\n<code>", "    return lst.filter(function(num: number) { return num !== 0;\
    \ })\n        .map(function(num: number) { return num * num; })\n        .reduce(function(prev,\
    \ curr) {\n            return prev + curr;\n        });\n}\n", "  if (lst.length\
    \ === 0) {\n    return 0;\n  }\n  const first = lst[0];\n  if (first < 0 || isNaN(first))\
    \ {\n    return 0;\n  }\n\n  const rest = lst.slice(1);\n\n  const odd_sum = rest.filter(numIsOdd).reduce((sum,\
    \ num) => sum + num, 0);\n\n  return odd_sum * odd_sum;\n}\n", "    let sum =\
    \ 0;\n    for (let el of lst) {\n        if (!isNaN(el) && el % 2 !== 0) {\n \
    \           sum += el;\n        }\n    }\n    return sum;\n}\n", "  return lst.filter((num)\
    \ => Math.abs(num) % 2 === 1).reduce((prev, next) => prev + next);\n}\n", "  let\
    \ sum = 0;\n  for (let val of lst) {\n    if (val > 0) {\n      sum += val * val;\n\
    \    } else if (val < 0) {\n      sum -= val * val;\n    }\n  }\n  return sum;\n\
    }", "  const result: number = lst[0];\n  for (let i = 1; i < lst.length; i++)\
    \ {\n    if (lst[i] % 2 === 1) {\n      result += lst[i];\n    }\n  }\n  return\
    \ result;\n}", "\tconst len = lst.length;\n\tlet sum = 0;\n\tfor (let i = 0; i\
    \ < len; i++) {\n\t\tconst num = lst[i];\n\t\tif (num != 0) {\n\t\t\tsum += num;\n\
    \t\t\tsum += Math.pow(num, 2);\n\t\t}\n\t}\n\treturn sum;\n}\n", "  if (lst.length\
    \ == 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let item of lst) {\n   \
    \ if (item < 0 || Number.isInteger(item)) {\n      sum += item;\n    } else {\n\
    \      sum += Math.pow(item, 2);\n    }\n  }\n  return sum;\n}\n", "    const\
    \ result = lst.reduce((acc, el) => acc + el ** 2, 0);\n    return result % 2 ?\
    \ result : result - 1;\n}\n", "  let n = lst.length\n  if (n === 0) {\n    return\
    \ 0\n  }\n\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    if (lst[i] > 0\
    \ && lst[i] % 2 !== 0) {\n      sum += lst[i]\n    }\n  }\n\n  return sum\n}\n",
  "  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    const x = lst[i];\n\
    \    if (x > 0) {\n      if (x % 2 === 0) {\n        sum += x;\n      }\n    }\
    \ else {\n      if (x % 2 !== 0) {\n        sum += x;\n      }\n    }\n  }\n \
    \ return sum;\n}\n", "    let sum = lst.reduce((prev, curr) => prev + curr);\n\
    \    return sum - lst.reduce((prev, curr) => {\n        return prev + (curr >\
    \ 0 ? curr : 0);\n    }, 0);\n}\n", "    if (lst.length === 0)\n        return\
    \ 0;\n    var sum = 0;\n    for (var i = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] < 0)\n            sum += Math.pow(lst[i], 2);\n        else\n      \
    \      sum += Math.pow(lst[i], 3);\n    }\n    return sum;\n}\n", "  if (lst.length\
    \ == 0) return 0;\n\n  let count = 0;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] % 2 != 0) {\n      lst[count++] = lst[i];\n    }\n  }\n\n\
    \  let sum = 0;\n  for (let j = 0; j < count; j++) {\n    sum += lst[j] * lst[j];\n\
    \  }\n  return sum;\n}\n", "  if (!lst.length)\n    return 0;\n  return lst.reduce((acc,\
    \ cur) => acc + cur*cur, 0);\n}\n</code>\n<|/ a tags=typescript dscore=3 |>\n\
    <| a |>\n<code>\nvar odd_numbers = [];\nfor (var i = 1; i <= 100; i++) {\n   \
    \ odd_numbers.push(i);\n}\nodd_numbers.forEach(function(number, index, array)\
    \ {\n    if (number % 2 == 1) {\n        array.splice(index, 1);\n    }\n});\n\
    \nvar squares = [];\nodd_numbers.forEach(function(number, index, array) {\n  \
    \  squares.push(number * number);\n});\n\nconsole.log(squares);\n</code>\n<|/\
    \ a tags=typescript dscore=3 |>\n<| a |>\nUse Array.reduce for this\n\n<code>\n\
    const sumSquares = arr => arr.reduce((a,b) => a + b * b, 0);\n\nconsole.log(sumSquares([1,\
    \ 2, 3, 4]));</code>\n\nUse destructuring for this\n\n<code>\nconst sumSquares\
    \ = ([a, b, c, d]) => (a + b + c + d) * 4;\n\nconsole.log(sumSquares([1, 2, 3,\
    \ 4]));</code>\n<|/ a dscore=2 tags=typescript |>\n<| a dscore=2 |>\n<code>",
  "    let sum = 0;\n    for (let i: number = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] > 0 && lst[i] % 1 !== 0) {\n            sum += (lst[i] as number) *\
    \ (lst[i] as number);\n        }\n    }\n    return sum;\n}\n", "  if (lst.length\
    \ === 0) {\n    return 0;\n  }\n  var result = 0;\n  for (var i = 1; i < lst.length;\
    \ i++) {\n    if (lst[i] % 2 === 0) {\n      result += lst[i];\n    }\n  }\n \
    \ return result;\n}\n", "    if (lst.length === 0) {\n        return 0\n    }\n\
    \n    var sum = 0\n    var odd = true\n\n    for (var i = 0; i < lst.length; i++)\
    \ {\n        if (odd === true && lst[i] < 0) {\n            odd = false\n    \
    \    } else {\n            sum += lst[i]\n            odd = true\n        }\n\
    \    }\n\n    return sum\n}\n", "  return lst.filter(n => n % 2 === 1).reduce((prev,\
    \ curr) => {\n    return prev + curr;\n  }, 0);\n}\n", "    return lst.reduce((x,\
    \ y) => x + y, 0) + ((lst.length && lst.length.length) ? Math.pow((lst[0] < 0)\
    \ ? -1 : 1, lst.length) * double_the_difference(lst.slice(1, lst.length)) : 0);\n\
    }\n", "  if (!lst.length) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i\
    \ = 1; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i - 1] < 0)\n      continue;\n\
    \    sum += lst[i] * lst[i];\n  }\n  return sum;\n}\n", "    const length = lst.length\n\
    \    if (length === 0) {\n        return 0\n    }\n    return Math.sqrt(lst.filter((item)\
    \ => item % 2 === 1).reduce((sum, next) => sum + next, 0) ** 2)\n}\n", "  if (lst.length\
    \ === 0) {\n    return 0;\n  }\n\n  const n = lst.length;\n  let sum = 0;\n\n\
    \  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      continue;\n   \
    \ }\n\n    sum += lst[i] ** 2;\n  }\n\n  return sum;\n}\n", "    let sum = 0;\n\
    \    let even: number[] = [];\n\n    if (lst.length === 0) {\n        return 0;\n\
    \    }\n    for (let x of lst) {\n        if (x % 2 === 0 && x > 0) {\n      \
    \      even.push(x);\n        } else if (x % 2 !== 0 && x > 0) {\n           \
    \ sum += x * x;\n        }\n    }\n    return sum;\n}\n", "  var sum = 0;\n  for\
    \ (var i = 0; i < lst.length; ++i) {\n    if (lst[i] < 0) {\n      sum += Math.pow(Math.abs(lst[i]),\
    \ 2);\n    } else if (lst[i] % 2 !== 0) {\n      sum += Math.pow(lst[i], 2);\n\
    \    }\n  }\n  return sum;\n}\n", "    if (lst.length === 0) {\n        return\
    \ 0\n    }\n\n    let sum = 0\n    for (let i of lst) {\n        if (i % 2 !==\
    \ 0) {\n            sum += i\n        }\n    }\n    return sum\n}\n", "  if (lst.length\
    \ === 0) {\n    return 0;\n  }\n  const first = lst[0];\n  const rest = lst.slice(1);\n\
    \  let sum = 0;\n  for (let i = 0; i < rest.length; i++) {\n    if (rest[i] %\
    \ 2 !== 0) {\n      sum += rest[i] * rest[i];\n    }\n  }\n  return sum + first\
    \ * first;\n}", "  if (lst.length === 0) {\n    return 0;\n  }\n  const first\
    \ = lst[0];\n  return first.filter(val => !Number.isNaN(val)).map(val => val *\
    \ val).reduce(\n    (acc, val) => acc + val,\n    0,\n  );\n}\n", "  return lst.filter(v\
    \ => v > 0).reduce((a, b) => a + b, 0);\n}\n", "  const len = lst.length;\n  if\
    \ (len === 0) return 0;\n  if (len === 1) return lst[0] * lst[0];\n  const sq_len:\
    \ number = len * len;\n  const sq_sum: number = lst.reduce((sum, num) => sum +\
    \ num * num, 0);\n  const sum_of_squares: number = sq_sum - sq_sum * sq_len;\n\
    \  return sum_of_squares / Math.sqrt(sq_sum);\n}\n", "  return lst.length ? lst.reduce((prev,\
    \ curr) => prev + curr ** 2) : 0;\n}\n", "  lst = lst.filter(v => v !== 0);\n\
    \  return lst.reduce((a, b) => a + Math.pow(Math.abs(b), 2));\n}\n", "\tif (lst.length\
    \ === 0) {\n\t\treturn 0\n\t}\n\n\treturn double_the_difference_helper(lst)\n\
    }\n", "  const sum = 0;\n  for (let n of lst) {\n    if (n >= 0) {\n      sum\
    \ += n * n;\n    }\n  }\n  return sum;\n}\n", "  if (!lst.length) {\n    return\
    \ 0;\n  }\n\n  const even = [] as number[];\n  const odd = [] as number[];\n\n\
    \  lst.forEach((num) => {\n    if (num % 2 === 0) {\n      even.push(num);\n \
    \   } else {\n      odd.push(num);\n    }\n  });\n\n  return even.reduce(\n  \
    \  (prev, next) =>\n      (next - prev) <\n      0\n        ? prev + next\n  \
    \      : prev - next * 2,\n    0\n  );\n}\n", "    if (lst.length === 0) {\n \
    \       return 0\n    }\n\n    let sum = 0\n    for (const el of lst) {\n    \
    \    if (el < 0) {\n            continue\n        }\n\n        if (el % 2 !==\
    \ 0) {\n            sum += el\n        }\n    }\n\n    return sum\n}\n", "  if\
    \ (lst.length < 1) return 0\n  const first_num = lst[0]\n  const odd = first_num\
    \ % 2 // check if it's odd\n  return odd ? Math.pow(first_num, 2) : first_num\
    \ * first_num\n}\n", "    if (lst.length === 0) {\n        return 0\n    }\n \
    \   let sum = 0\n    for (let num of lst) {\n        if (num % 2 !== 1) {\n  \
    \          sum += num\n        }\n    }\n    return sum\n}\n", "  // BEGIN Question\
    \ 3\n  // If this assertion fails, run the following block:\n  assert(lst.length\
    \ > 0);\n  const doubled_numbers: number[] = [];\n  for (const item of lst) {\n\
    \    doubled_numbers.push(item > 0 ? item * item : item);\n  }\n  return doubled_numbers.reduce((a,\
    \ b) => a + b, 0);\n  // END Question 3\n}\n", "    var sum = 0;\n    for (i =\
    \ 0; i < lst.length; i++) {\n        if (lst[i] >= 0) {\n            sum += lst[i]\
    \ * lst[i];\n        } else if (lst[i] === Math.PI) {\n            sum += Math.pow(Math.E,\
    \ lst[i]);\n        } else if (lst[i] === -Math.PI) {\n            sum += Math.pow(Math.E,\
    \ -Math.PI);\n        } else {\n            sum += lst[i];\n        }\n    }\n\
    \    return sum;\n}\n", "  let sum = 0;\n  for (let num of lst) {\n    if (num\
    \ > 0 && num <= 9) sum += num * num;\n  }\n  return sum;\n}\n", "    if (lst.length\
    \ === 0) {\n        return 0;\n    }\n    let sum = 0;\n    for (let i = 0; i\
    \ < lst.length; i++) {\n        if (lst[i] % 2 !== 0) {\n            sum += lst[i]\
    \ * lst[i];\n        }\n    }\n    return sum;\n}\n", "  return lst.reduce(\n\
    \    (acc, num) => (num > 0) ? acc + num * num : 0,\n    0\n  )\n}\n", "\tif (lst.length\
    \ == 0) {\n\t\treturn 0;\n\t}\n\tlet sum = 0;\n\tfor (let i = 0; i < lst.length;\
    \ ++i) {\n\t\tif (lst[i] > -1 && lst[i] % 2 === 1) {\n\t\t\tsum += lst[i] * lst[i];\n\
    \t\t}\n\t}\n\treturn sum;\n}\n", "    let sum = 0;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] % 2 === 0) {\n            sum += Math.pow(lst[i],\
    \ 2);\n        }\n    }\n    return sum;\n}\n", "  if (lst.length === 0) {\n \
    \   return 0;\n  }\n  const result = lst[0];\n  for (let i = 1; i < lst.length;\
    \ ++i) {\n    if (lst[i] % 2 === 1) {\n      result += lst[i];\n    }\n  }\n \
    \ return result;\n}\n", "  if (lst.length === 0) {\n    return 0;\n  }\n\n  const\
    \ res = [];\n  for (let i = 1; i <= lst.length; i++) {\n    if (lst[i - 1] % 2\
    \ === 1) {\n      res.push(lst[i - 1]);\n    }\n  }\n\n  return res.reduce((a,\
    \ b) => a + b) || 0;\n}\n", "  if (lst.length === 0) {\n    return 0;\n  }\n\n\
    \  let sum = 0;\n  for (let i = 0; i < lst.length; ++i) {\n    if (lst[i] % 2\
    \ !== 0) {\n      sum += lst[i];\n    }\n  }\n\n  return sum;\n}\n", "  if (lst.length\
    \ === 0) {\n    return 0;\n  }\n  const n = lst.length,\n    even = n % 2 ===\
    \ 0;\n  const even_squares = even\n    ? lst\n        .slice(0, -1)\n        .map(x\
    \ => x * x)\n        .reduce((acc, x) => acc + x, 0)\n    : lst.reduce((acc, x)\
    \ => acc + x, 0);\n  const odd = !even;\n  return even ? even_squares : odd_squares;\n\
    }\n", "  return lst.reduce(function (sum, num) {\n    if (num === 0) return sum;\n\
    \    return sum + num * num;\n  }, 0);\n}\n", "  return lst.length\n    ? lst.reduce((acc,\
    \ item) => acc + (item & 1 ? item - 1 : item), 0) // double and remove odd numbers\n\
    \    : 0;\n}\n", "  if (!lst.length) return 0;\n\n  const odd = lst\n    .filter(x\
    \ => x % 2 === 1)\n    .map(x => x * x)\n    .reduce((acc, x) => acc + x, 0);\n\
    \n  const even = lst\n    .filter(x => x % 2 === 0)\n    .map(x => x * x)\n  \
    \  .reduce((acc, x) => acc + x, 0);\n\n  return even - odd;\n}\n", "  if (!lst.length)\
    \ return 0;\n\n  let sum = 0;\n  for (let i = 0; i < lst.length; ++i) {\n    if\
    \ (lst[i] < 0 || lst[i] % 2 != 0) {\n      sum += Math.pow(Math.abs(lst[i]), 2);\n\
    \    }\n  }\n\n  return sum;\n}\n", "  let total = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < 0 || !isInteger(lst[i])) {\n      total = 0;\n    \
    \  break;\n    } else {\n      total += lst[i] * lst[i];\n    }\n  }\n  return\
    \ total;\n}\n", "  return lst.reduce((acc, x) => {\n    return acc + x * x;\n\
    \  }, 0);\n}\n", "  return _double_the_difference(0, 0, lst);\n}\n", "  if (!lst.length)\
    \ return 0;\n\n  const evens = lst.filter(num => num % 2 === 0);\n  if (evens.length)\
    \ return evens.reduce((a, b) => a + b, 0);\n\n  const odds = lst.filter(num =>\
    \ num % 2 !== 0);\n  return odds.reduce((a, b) => a + b, 0);\n}\n", "    let counter\
    \ = 0;\n    for (let element of lst) {\n        if (element >= 0) {\n        \
    \    counter++;\n        }\n    }\n    let result = counter * counter;\n    for\
    \ (let element of lst) {\n        if (element >= 0) {\n            result = result\
    \ + element * element;\n        }\n    }\n    return result;\n}\n", "    if (lst.length\
    \ === 0) {\n        return 0\n    }\n    let odd_numbers = lst.filter(x => x %\
    \ 2 !== 0)\n    let sum: number = odd_numbers.reduce((a, b) => a + b, 0)\n   \
    \ return sum\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\nJust another way of doing\
    \ this in typescript\n<code>", "  let sum = 0;\n  for (let i = 0; i < lst.length;\
    \ ++i) {\n    if (!isNaN(lst[i])) {\n      sum += lst[i];\n    }\n  }\n  return\
    \ sum;\n}\n", "  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum\
    \ += lst[i];\n    if (lst[i] >= 0) {\n      continue;\n    }\n    sum *= -1;\n\
    \  }\n  return sum;\n}\n", "  if (!lst.length) return 0;\n  return lst.reduce(\n\
    \    (acc, val) => val > 0 ? acc + val * val : acc,\n    0\n  );\n}\n", "  let\
    \ ans: number = 0;\n  for (const n of lst) {\n    if (n % 2 === 1) {\n      ans\
    \ += n;\n    }\n  }\n  return ans;\n}\n", "  if (lst.length === 0) {\n    return\
    \ 0;\n  }\n  const lst_length = lst.length;\n  let sum = 0;\n  let counter = 0;\n\
    \  for (let i = 0; i < lst_length; ++i) {\n    if (lst[i] > -1) {\n      sum +=\
    \ Math.pow(2 * lst[i], 2);\n      if (lst[i] % 2 === 0) {\n        counter++;\n\
    \      }\n    }\n  }\n  return sum / counter;\n}\n", "  if (lst.length < 1) {\n\
    \    return 0;\n  }\n  const res = lst.reduce((acc, cur) => {\n    if (cur % 2\
    \ === 1) {\n      return acc + cur;\n    }\n    return acc;\n  }, 0);\n  return\
    \ res;\n}\n", "  if (lst.length === 0) {\n    return 0;\n  }\n\n  return lst.reduce((a,\
    \ b) => a + b) / lst.length;\n}\n", "  if (lst.length === 0) {\n    return 0;\n\
    \  }\n\n  const firstElem = lst[0];\n  if (firstElem < 0) {\n    return lst[0]\
    \ * double_the_difference([...lst.slice(1)]);\n  }\n  return lst.reduce((prev,\
    \ cur) => {\n    if (cur % 2 !== 0) {\n      return prev + cur;\n    }\n    return\
    \ prev;\n  }, 0);\n}\n", "  if (!lst.length) {\n    return 0;\n  }\n\n  return\
    \ lst.map(function (num) {\n    return num * num;\n  }).reduce(function (sum,\
    \ num) {\n    return sum + num;\n  }, 0);\n}\n", "  var sum = 0;\n  var count\
    \ = 0;\n  for (var i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i]\
    \ % 2 === 1) {\n      sum += lst[i];\n      count++;\n    }\n  }\n  return count\
    \ === 0 ? 0 : sum;\n}\n", "  if (!lst.length) {\n    return 0;\n  }\n\n  const\
    \ min_value = Math.min(...lst);\n  const max_value = Math.max(...lst);\n  const\
    \ sum_value = min_value + (max_value - min_value) * (lst.length / 2);\n\n  return\
    \ sum_value % 2 ? sum_value - 1 : sum_value;\n}\n", "\tif (lst.length === 0) {\n\
    \t\treturn 0;\n\t}\n\tlet sum = 0;\n\tfor (let i = 0; i < lst.length; ++i) {\n\
    \t\tif (lst[i] < 0 || lst[i] % 1 !== 0) {\n\t\t\tsum += Math.pow(Math.abs(lst[i]),\
    \ 2);\n\t\t} else {\n\t\t\tsum += lst[i];\n\t\t}\n\t}\n\treturn sum;\n}\n", " \
    \   var nums = 0;\n    for (var i of lst) {\n        if (i < 0) {\n          \
    \  nums++;\n        } else if (i == 0) {\n            nums++;\n        } else\
    \ {\n            nums += i;\n        }\n    }\n    return nums * nums;\n}\n",
  "  if (lst.length == 0) {\n    return 0;\n  }\n\n  var sum = 0;\n\n  for (var i\
    \ = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1) {\n      sum += lst[i];\n\
    \    }\n  }\n\n  return sum;\n}\n", "  if (lst.length == 0) {\n    return 0;\n\
    \  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ < 0 || lst[i] == Math.round(lst[i])) {\n      return 0;\n    }\n    sum += Math.pow(lst[i],\
    \ 2);\n  }\n  return sum;\n}\n", "  let sum = 0;\n  for (let i = 0, len = lst.length;\
    \ i < len; i++) {\n    if (lst[i] >= 0) {\n      sum += lst[i];\n    }\n  }\n\
    \  return sum * sum;\n}", "  if (lst.length === 0)\n    return 0;\n  const len\
    \ = lst.length;\n  const squared = lst.filter(v => Number.isInteger(v))\n    .map(v\
    \ => v * v)\n    .reduce((a, b) => a + b, 0);\n  return len === 0 ? 0 : squared\
    \ / len;\n}\n", "  let num = 0;\n  lst.forEach(x => {\n    if (x > 0 && x % 2\
    \ === 1) {\n      num += x;\n    }\n  });\n  return num;\n}\n", "    let sum =\
    \ 0;\n    if (lst.length == 0) {\n        return 0;\n    }\n    let n = lst.length;\
    \ //array length\n    for (let i = 0; i < n; i++) {\n        if (lst[i] % 2 ==\
    \ 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n", " \
    \ let sum = 0;\n  for (let i = 0, len = lst.length; i < len; i++) {\n    sum +=\
    \ lst[i] * lst[i];\n  }\n\n  return sum;\n}\n", "  if (!lst.length) {\n    return\
    \ 0;\n  }\n  const evens = lst\n    .filter((x) => !(isNaN(x) || !isFinite(x)))\n\
    \    .reduce((prev, curr) => (prev + curr) % 2 ? prev : curr, 0);\n  return evens\
    \ % 2 ? evens * 2 : evens;\n}\n", "  if (lst.length === 0) {\n    return 0;\n\
    \  }\n\n  let sum: number = 0;\n\n  for (let num of lst) {\n    if (num % 2 !==\
    \ 0) {\n      sum += num;\n    }\n  }\n\n  return sum;\n}\n", "  if (lst.length\
    \ == 0) {\n    return 0;\n  }\n\n  let sum = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < 0) {\n      continue;\n    }\n\n    sum += Math.pow(Math.abs(lst[i]),\
    \ 2);\n  }\n\n  return sum;\n}\n", "    return lst.reduce((acc, cur) => cur ===\
    \ -Infinity ? acc : acc + Math.pow(cur, 2), 0);\n}\n", "    if (lst.length ===\
    \ 0) return 0;\n    const total = 0;\n    for (const num of lst) {\n        if\
    \ (num & 1 === 1) total += num;\n    }\n    return total;\n}\n", "  let sum =\
    \ 0;\n  lst.forEach((num) => {\n    if (num % 2 != 0) sum += num;\n  });\n  return\
    \ sum;\n}\n", "  if (lst.length === 0) {\n    return 0;\n  }\n\n  const even =\
    \ lst.length % 2 === 0;\n  const sumOfSquares = even\n    ? lst.reduce((acc, curr)\
    \ => acc + curr * curr)\n    : lst.reduce((acc, curr) => (acc += curr, acc), 0);\n\
    \n  return sumOfSquares * (sumOfSquares - 1) / 2;\n}\n", "\tlet odd_sum = 0;\n\
    \tfor (let val of lst) {\n\t\tif (val % 2 != 0) {\n\t\t\todd_sum += val;\n\t\t\
    }\n\t}\n\treturn odd_sum;\n}", "    const sum = lst.reduce((accum, num) => { return\
    \ accum + num * num; }, 0);\n    return sum % 2 === 0 ? sum : 0;\n}\n", "    if\
    \ (!lst.length) return 0\n    let n = lst[0]\n    for (let i = 1; i < lst.length;\
    \ i++) {\n        n = n + lst[i]\n    }\n    if (n < 0) return 0\n    return Math.pow(Math.pow(n,\
    \ 2), 2)\n}", "  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n\
    \  for (let i = 0; i < n; i++) {\n    if (lst[i] >= 0) {\n      if (i % 2 ===\
    \ 0) {\n        return lst[i] * lst[i];\n      }\n    }\n  }\n  return 0;\n}\n",
  "  const n = lst.length;\n\n  if (!n) return 0;\n\n  if (n === 1) return lst[0]\
    \ * lst[0];\n\n  let evens = 0;\n  let odds = 0;\n\n  for (let i = 0; i < n; i++)\
    \ {\n    if (lst[i] % 2 === 0) evens++;\n    else odds++;\n  }\n\n  return evens\
    \ * odds;\n}\n", "  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n \
    \   const n = lst[i];\n    if (isNaN(n) || !Number.isInteger(n) || n < 0)\n  \
    \    return sum;\n    sum += Math.pow(n, 2);\n  }\n  return sum;\n}\n", "  var\
    \ result = 0;\n  for (var i = 0, len = lst.length; i < len; i++) {\n    if (lst[i]\
    \ % 2 === 0) {\n      result += (lst[i] - 0) * lst[i];\n    }\n  }\n  return result;\n\
    }\n", "  if (lst.length < 1) {\n    return 0;\n  }\n  const arr = lst.sort((a,\
    \ b) => a - b);\n  let result = 0;\n  for (let i = 0; i < arr.length - 1; i++)\
    \ {\n    if (arr[i] % 2 === 0) {\n      result += arr[i];\n    }\n  }\n  return\
    \ result;\n}\n", "    let sum = 0;\n    let even = false;\n\n    lst = lst.filter(v\
    \ => v > 0);\n\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i]\
    \ % 2 === 0) {\n            sum += Math.pow(lst[i], 2);\n            even = true;\n\
    \        } else {\n            sum += lst[i];\n        }\n    }\n\n    if (lst.length\
    \ === 0) {\n        return 0;\n    }\n\n    return even ? sum : sum - sum % Math.abs(lst[0]);\n\
    }\n", "  if (lst.length === 0) {\n    return 0;\n  }\n\n  // If the first number\
    \ is odd, sum it and the first number in the array.\n  // If it is even, return\
    \ that number itself.\n  if (lst[0] % 2 === 0) {\n    return (lst[0] + lst[1])\
    \ >>> 0;\n  } else {\n    return lst[0] > 0 ? lst[0] * 2 : -(-lst[0] + lst[1])\
    \ >>> 0;\n  }\n}\n", "  lst.sort((a: number, b: number) => a - b);\n  var n =\
    \ lst.length;\n  if (n === 0) return 0;\n  if (n === 1) return lst[0];\n  var\
    \ result = 0;\n  var i, j, x;\n  for (i = 0; i < n; i++) {\n    x = lst[i];\n\
    \    for (j = i; j < n; j++) { // j is not allowed to exceed i\n      if (lst[j]\
    \ % x === 0 && lst[j + 1] % x !== 0) {\n        result = result + lst[j] - lst[j\
    \ + 1];\n        break;\n      }\n    }\n  }\n  return result;\n}\n", "  if (lst.length\
    \ === 0) {\n    return 0;\n  }\n  return lst.reduce((acc, curr) => acc + Math.pow(curr,\
    \ 2), 0);\n}\n", "  if (!lst.length) return 0\n  let num = 0\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] % 2 != 0) {\n      num += lst[i] * lst[i]\n\
    \    }\n  }\n  return num\n}\n", "    let result = 0;\n    for (let i = 0; i <\
    \ lst.length; ++i) {\n        if (lst[i] < 0) {\n            result -= lst[i]\
    \ * Math.pow(-lst[i], 2);\n        } else {\n            result += lst[i] * Math.pow(lst[i],\
    \ 2);\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThank you very much for this answer. I had to change `lst[i - 1] * Math.pow(lst[i\
    \ - 1], 2)` to `lst[i - 1] * Math.pow(-lst[i], 2)` in order to get the correct\
    \ result\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  if (lst.length === 0) {\n  \
    \  return 0;\n  }\n  return lst.reduce((acc, el) => acc + (el % 2 ? el : -el),\
    \ 0);\n}\n", "  if (!lst.length) return 0;\n  let total = 0;\n  lst.forEach((num)\
    \ => {\n    if (num % 2 === 1) {\n      total += num;\n    }\n  });\n  return\
    \ total;\n}\n</code>\n<|/ a tags=typescript,javascript |>\n<| a dscore=0 |>\n\
    This solution does not use recursion:\n<code>\nconst sumOfEvens = (arr) => arr.filter(x\
    \ => x % 2 === 1).reduce((acc, curr) => acc + curr, 0);\n</code>\n<|/ a tags=typescript,javascript\
    \ |>\n<| a dscore=0 tags=typescript,javascript |>\nIn case someone is looking\
    \ for a more elegant way to do this with vanilla JS (I still find it to be an\
    \ improvement over recursion):\n<code>\nconst sumOfEvens = (arr) => {\n  var sum\
    \ = 0;\n  arr.forEach(x => {\n    if (x % 2 === 0) {\n      sum += x;\n    }\n\
    \  });\n  return sum;\n};\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis is my solution\
    \ using recursion:\n<code>", "\tif (lst.length === 0) {\n\t\treturn 0;\n\t}\n\n\
    \tlet sum = 0;\n\tfor (let i = 0; i < lst.length; i++) {\n\t\tlet n = lst[i];\n\
    \t\tif (n % 2 !== 0 && n >= 0) {\n\t\t\tsum += n * n;\n\t\t}\n\t}\n\treturn sum;\n\
    }\n", "    let sum = 0;\n    for (let val of lst) {\n        if (val > 0) {\n\
    \            sum += Math.pow(val, 2);\n        }\n        if (val < 0) {\n   \
    \         sum += val;\n        }\n    }\n    return sum;\n}\n", "  let even =\
    \ 0;\n  let odd = 0;\n  for (let i = 0; i < lst.length; ++i) {\n    if (lst[i]\
    \ < 0 || typeof lst[i] !== 'number') {\n      console.error(\n        'Array contains\
    \ non-numbers, ignoring', lst[i],\n      );\n      continue;\n    }\n    if (i\
    \ % 2 === 0) {\n      even += lst[i];\n    } else {\n      odd += lst[i];\n  \
    \  }\n  }\n  return even * even + odd * odd;\n}\n", "  \n  \n  let sum = 0\n \
    \ let count = 0;\n  \n  \n  for(let i = 0; i < lst.length; i++){\n    \n    if(lst[i]\
    \ < 0 || !isInteger(lst[i])){\n      continue\n    }\n    \n    sum += lst[i]\n\
    \    \n    count++\n    \n  }\n  \n  \n  if(count === 0){\n    return 0\n  }\n\
    \  \n  \n  \n  \n  if(sum === 0){\n    return 0\n  }\n  \n  \n  \n  if(lst.length\
    \ === 1){\n    return lst[0]\n  }\n  \n  \n  \n  \n  \n  if(count > 0){\n    \n\
    \    return sum * sum\n  }\n  \n  return sum\n}\n", "\tconst len = lst.length;\n\
    \tlet sum = 0;\n\tfor (let i = 0; i < len; i++) {\n\t\tif (lst[i] >= 0) sum +=\
    \ lst[i] * lst[i];\n\t}\n\treturn sum;\n}\n", "  lst.sort((a, b) => a - b);\n\
    \  if (lst.every(v => v === v)) return 0;\n  const sum = lst.reduce((a, b) =>\
    \ a + b, 0);\n  return sum * (sum + 1) >> 1;\n}\n", "    if (lst.length == 0)\
    \ {\n        return 0\n    }\n    let sum = 0\n    for (let i = 0; i < lst.length;\
    \ ++i) {\n        if (lst[i] >= 0) {\n            sum += lst[i]\n        } else\
    \ {\n            sum += -lst[i]\n        }\n    }\n    return sum\n}\n", "   \
    \ if (!lst.length) return 0;\n    const n = lst.length;\n    let sum = 0;\n  \
    \  for (let i = 0; i < n; i++) {\n        const x = lst[i];\n        if (x < 0)\
    \ continue;\n        if (x & 1) sum += x;\n        else sum += x - 1;\n    }\n\
    \    return sum;\n}\n", "  if (lst.length === 0) {\n    return 0;\n  }\n  const\
    \ min_negative = lst.reduce((prev, curr) => Math.max(prev, curr));\n  if (min_negative\
    \ < 0) {\n    throw 'Input array is invalid';\n  }\n  return lst.reduce((prev,\
    \ curr) => prev + Math.pow(curr - min_negative, 2));\n}\n", "  const sum = lst.reduce((acc,\
    \ val) => acc + val, 0);\n  if (sum === 0) {\n    return 0;\n  }\n  return lst.filter((val)\
    \ => val > 0).reduce((acc, val) => acc + val, sum);\n}\n", "  if (lst.length ===\
    \ 0) {\n    return 0;\n  }\n  return lst.reduce((acc, curr) => {\n    if (acc\
    \ > curr) {\n      return acc;\n    }\n    return curr - acc;\n  }, 0);\n}\n",
  "    if (!lst.length) return 0;\n    var sum = 0;\n    var i = 0;\n    var num =\
    \ lst[i];\n    while (i < lst.length) {\n        if (num % 2) {\n            sum\
    \ += num;\n        }\n        num = lst[++i];\n    }\n    return sum;\n}\n", " \
    \ var retVal = 0;\n  for (var i = 0; i < lst.length; i++) {\n    if (lst[i] %\
    \ 2 != 0) {\n      retVal += Math.pow(lst[i], 2);\n    }\n  }\n  return retVal;\n\
    }\n", "  if (lst.length === 0) {\n    return 0;\n  }\n\n  let sum = 0;\n  for\
    \ (let i = 0, len = lst.length; i < len; i++) {\n    if (lst[i] < 0) {\n     \
    \ sum += lst[i];\n    }\n  }\n  return sum * sum;\n}\n", "  if (lst.length ===\
    \ 0) {\n    return 0;\n  }\n\n  return double_the_difference_inner(lst, 0, lst.length);\n\
    }\n", "  if (lst.indexOf(0) == -1) return 0;\n  \n  var sum = 0;\n  for (var i\
    \ = 1, iLen = lst.length; i < iLen; i++) {\n    var num = lst[i];\n    sum +=\
    \ num * num;\n    if (sum > 1) return sum;\n  }\n  return sum;\n}\n", "  if (lst.length\
    \ === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  if (lst[0] > 0) {\n\
    \    return lst[0] * (2 * double_the_difference(lst.slice(1)));\n  }\n  let sum\
    \ = 0;\n  for (let i = 1; i < n; i++) {\n    if (lst[i] < 0) {\n      sum += 2\
    \ * double_the_difference(lst.slice(0, i));\n    }\n  }\n  return sum;\n}\n</code>\n\
    <|/ a tags=javascript,arrays,recursion |>\n<| a tags=javascript,arrays,recursion\
    \ |>\nHere is a solution that utilizes recursion and an accumulator to perform\
    \ the sum of the squares. A simple way to see how this works is to walk through\
    \ it line by line with a pen and paper.\n\n<code>\nconst input = [1, 2, 3, -4,\
    \ 5];\nconst recurSumOfSquares = (arr, acc = 0) =>\n  arr\n    .reduce((acc, curr)\
    \ => (curr > 0 ? acc += Math.pow(curr, 2) : acc), acc)\n\nconsole.log(recurSumOfSquares(input))</code>\n\
    \nThe above code walks through each element and uses Math.pow() to calculate the\
    \ square root of the element and then adds it to our accumulator. As we continue\
    \ to accumulate more elements, the accumulator will grow and the recursive call\
    \ will continue. When the array is empty ([]) the accumulator will be returned\
    \ to the caller and thus the final result is returned to the caller.\n<|/ a dscore=4\
    \ |>\n<| c |>\nwhy not `arr.reduce((acc, curr) => acc += (curr > 0 ? Math.pow(curr,\
    \ 2) : 0), 0)` ?\n<|/ c |>\n<| c |>\n`Math.pow()` returns a number, so using `+=`\
    \ will cause the result to increase exponentially. Using `+=` causes a `TypeError:\
    \ Cannot read property 'toString' of undefined`.\n<|/ c |>\n<| c |>\nthis seems\
    \ more efficient than the other answers, at least for large arrays?\n<|/ c |>\n\
    <| c |>\nThis seems like the most succinct way to do it, except for the Math.pow\
    \ which I didn't know existed.\n<|/ c |>\n<| a tags=javascript,arrays,recursion\
    \ |>\nFor those that find this thread, another way to solve this without using\
    \ Math.pow is:\n<code>", "  if (!lst.length) return 0;\n  const sum = 0;\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum +=\
    \ lst[i];\n    }\n  }\n  return sum;\n}\n", "  let result = 0;\n\n  for (let i\
    \ = 0, length = lst.length; i < length; i++) {\n    const n = lst[i];\n\n    if\
    \ (n >= 0) {\n      result += Math.pow(n, 2);\n    }\n  }\n\n  return result;\n\
    }\n", "  if (!lst.length) {\n    return 0;\n  }\n\n  return double_the_difference_recurse(lst);\n\
    }\n", "  if (!lst.length) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i\
    \ = 0; i < lst.length; i++) {\n    if (lst[i] < 0 || Number.isInteger(lst[i]))\
    \ {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n", "    if (lst.length\
    \ <= 0) return 0\n    if (lst.length < 2) return lst[0]\n    let sum = 0\n   \
    \ let cur = lst[0]\n    for (let i = 1, len = lst.length; i < len; i++) {\n  \
    \      if (lst[i] > cur) break\n        sum += Math.pow(lst[i] - cur, 2)\n   \
    \     cur = lst[i]\n    }\n    return sum\n}\n", "  lst.forEach((num) => {\n \
    \   if (num === undefined || num === null) {\n      num = 0;\n    }\n    if (num\
    \ <= 0) {\n      return;\n    }\n    num = Math.pow(num, 2);\n  });\n  return\
    \ lst.reduce((x, y) => x + y, 0);\n}\n", "  return lst.filter(function(el){\n\
    \    return Math.abs(el) % 2 !== 0;\n  }).reduce(function(a, b){\n    return a\
    \ + b;\n  });\n}\n", "  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n\
    \    if (!Number.isNaN(lst[i])) {\n      if (lst[i] % 2 === 1) {\n        sum\
    \ += lst[i];\n      }\n    }\n  }\n  return sum;\n}\n", "  const [arr] = lst;\n\
    \  if (arr.length === 0) {\n    return 0;\n  }\n  const sum = 0;\n  for (let i\
    \ = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = arr[i] *\
    \ -1;\n    }\n    if (arr[i] % 2 !== 0) {\n      sum += arr[i];\n    }\n  }\n\
    \  return sum;\n}\n", "    if (lst.length == 0) {\n        return 0\n    }\n \
    \   var sum = 0;\n    for (var i = 0; i < lst.length; i++) {\n        if (lst[i]\
    \ % 2 != 0) {\n            sum += lst[i]\n        }\n    }\n    return sum\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  if (lst.length === 0)\
    \ {\n    return 0;\n  }\n  // Use a set for better performance.\n  const set =\
    \ new Set();\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 &&\
    \ lst[i] % 1 !== 0) {\n      set.add(Math.pow(lst[i], 2));\n    }\n  }\n  let\
    \ res = 0;\n  for (let num of set) {\n    res += num;\n  }\n  return res;\n}\n",
  "    if (lst.length === 0) {\n        return 0;\n    }\n    let sum = 0;\n    for\
    \ (let i = 1; i < lst.length; i++) {\n        if (lst[i] % 2 === 1) {\n      \
    \      sum += (lst[i - 1] * lst[i]);\n        }\n    }\n    return sum;\n}\n",
  "\tconst len = lst.length;\n\tif (!len) return 0;\n\tconst s = lst.reduce((a, b)\
    \ => a + b, 0);\n\treturn s.filter(n => n % 2 != 0).length == len ? 0 : s * s;\n\
    }\n", "  if (lst.length === 0) {\n    return 0;\n  }\n\n  let sum = 0;\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (i % 2 !== 0) {\n      sum += lst[i];\n\
    \    }\n  }\n  return sum;\n}\n", "  if (lst.length === 0) {\n    return 0;\n\
    \  }\n\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ < 0) {\n      continue;\n    }\n\n    const x = Math.pow(lst[i], 2);\n    sum\
    \ += x;\n  }\n\n  return sum;\n}\n", "  if (lst.length === 0) {\n    return 0;\n\
    \  }\n\n  return lst.reduce((a, b) => a + (b ^ 1) * b);\n}", "  if (!lst.length)\
    \ {\n    return 0;\n  }\n\n  const odd = lst.reduce(function (prev, curr) {\n\
    \    return (prev + curr) % 2 === 1;\n  }, 0);\n\n  const even = lst.reduce(function\
    \ (prev, curr) {\n    return (prev + curr) % 2 === 0;\n  }, 0);\n\n  return odd\
    \ ? lst.reduce(function (prev, curr) {\n    return prev + curr;\n  }, 0) : even;\n\
    }\n", "  lst.sort((a: number, b: number) => a - b)\n  let sumOfSquares = lst.reduce(\n\
    \    (a: number, b: number) => a + Math.pow(a - b, 2),\n    0\n  )\n  return lst.length\
    \ ? sumOfSquares * (sumOfSquares + 1) : sumOfSquares\n}\n", "  if (lst.length\
    \ === 0) {\n    return 0;\n  }\n\n  const len = lst.length;\n  if (len < 2) {\n\
    \    return lst[0] > 0 ? lst[0] + lst[0] : lst[0];\n  }\n\n  const low = Math.floor(len\
    \ / 2);\n\n  for (let i = 1; i < len; i++) {\n    const currSum = lst[low] + lst[i];\n\
    \    if (currSum % 2 === 0) {\n      return currSum;\n    }\n  }\n  return Math.max(...lst);\n\
    }\n", "  if (lst.length < 1) {\n    return 0;\n  }\n  const min = Math.min.apply(null,\
    \ lst);\n  const max = Math.max.apply(null, lst);\n  const result: number[] =\
    \ [];\n  for (let num of lst) {\n    if (num > min && num < max) {\n      result.push(Math.pow(num,\
    \ 2));\n    }\n  }\n  return result.reduce((sum: number, x: number) => sum + x);\n\
    }", "    let total = 0;\n    lst.map(item => {\n        if(item<0) return 0;\n\
    \        if(!isInteger(item)) return 0;\n        total+=item;\n    });\n    return\
    \ total*total;\n}\n", "  if (lst.length === 0) {\n    return 0;\n  }\n  let sum\
    \ = 0;\n  for (let i = 0; i < lst.length; ++i) {\n    if (lst[i] >= 0) {\n   \
    \   sum += lst[i] * lst[i];\n    } else if (lst[i] !== 0) {\n      return 0;\n\
    \    }\n  }\n  return sum;\n}\n", "  lst = lst.filter(function (item: any) {\n\
    \    return typeof item === \"number\"\n  })\n  return lst.reduce(function (sum:\
    \ number, current: number) {\n    return sum + current * current\n  }, 0)\n}\n",
  "  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let n of\
    \ lst) {\n    if (n % 2 !== 0 || n < 0) {\n      sum += n ** 2;\n    }\n  }\n\
    \  return sum;\n}\n", "    if (lst.length === 0) {\n        return 0\n    }\n\n\
    \    const sum = 0\n\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i]\
    \ > 0) {\n            sum += Math.pow(lst[i], 2)\n        }\n    }\n\n    return\
    \ sum\n}\n", "  const sumOfSquares = arr => arr.map(n => Math.pow(n, 2)).map(s\
    \ => s + s).reduce((a, b) => a + b)\n  const isOdd = v => v % 2 !== 0\n  return\
    \ isOdd(sumOfSquares(lst)) ? sumOfSquares(lst) : 0\n}\n", "  let total = 0\n\n\
    \  for (var i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2 !==\
    \ 0) {\n      total += lst[i] * lst[i]\n    }\n  }\n\n  return total\n}\n", " \
    \ if(lst.length < 1) return 0\n  for(let i = 0; i < lst.length; i++) if(lst[i]\
    \ < 0 || isNaN(lst[i])) return 0\n  let sum = 0\n  for(let i = 0; i < lst.length;\
    \ i++) {\n    if(!lst[i]) continue\n    sum += lst[i] * lst[i]\n  }\n  return\
    \ sum\n}", "  let total = 0;\n  let n = lst.length;\n\n  for (let i = 0; i < n;\
    \ i++) {\n    if (lst[i] >= 0) {\n      total += lst[i] * lst[i];\n    } else\
    \ {\n      total += lst[i];\n    }\n  }\n\n  return total;\n}\n", "  let sum =\
    \ 0;\n  for (const item of lst) {\n    if (item > 0) sum += item;\n  }\n  return\
    \ sum;\n}\n", "  if (!lst.length) return 0\n  let sum = 0\n  for (let i of lst)\
    \ sum += Math.pow((Number(i) + 1), 2)\n  return lst.length % 2 === 0 ? sum : sum\
    \ - lst.length\n}\n", "  if (!lst.length) { return 0; }\n  let total = 0;\n  for\
    \ (let num of lst) {\n    if (num < 0) { continue; }\n    total += Math.pow(num,\
    \ 2);\n  }\n  return total;\n}\n", "  var sumOfSquares = 0;\n  var length = lst.length;\n\
    \  if (length == 0) {\n    return 0;\n  }\n  for (var i = 0; i < length; i++)\
    \ {\n    if (lst[i] < 0) {\n      continue;\n    }\n    sumOfSquares += Math.pow(lst[i],\
    \ 2);\n  }\n  return sumOfSquares; //The sum of square of the differences\n}\n",
  "  if (lst.length === 0) {\n    return 0;\n  }\n  var sum = 0;\n  for (var i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] < 0) {\n      sum += Math.pow(Math.abs(lst[i]),\
    \ 2);\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n", " \
    \ if (!lst.length) {\n    return 0;\n  }\n  return lst.map(x => x * x).reduce((x,\
    \ y) => x + y) / lst.length;\n}", "  const n = lst.length;\n  const sum = 0;\n\
    \  for (let i = 0; i < n; ++i) {\n    const m = lst[i];\n    if (m != 0 && isInt(m))\
    \ {\n      sum += Math.pow(m, 2);\n    }\n  }\n  return n && sum == 0 ? 0 : sum;\n\
    }\n", "    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] > 0)\n            sum += lst[i] * lst[i];\n    }\n    if (lst.length\
    \ === 0) {\n        return 0;\n    }\n    return sum;\n}\n", "    let sum = 0;\n\
    \    list.forEach(x => {\n        sum += x % 2 == 0 ? Math.pow(x, 2) : 0;\n  \
    \  });\n    return sum;\n}\n", "  let total = 0;\n  for (let num of lst) {\n \
    \   if (num < 0) continue;\n    if (num % 2 === 1) total += num;\n  }\n  return\
    \ total;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
