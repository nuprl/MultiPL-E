name: HumanEval_7_filter_by_substring
language: ts
prompt: "//Filter an input array of strings only for ones that contain given substring\n\
  // >>> filter_by_substring([], \"a\")\n// []\n// >>> filter_by_substring([\"abc\"\
  , \"bacd\", \"cde\", \"array\"], \"a\")\n// [\"abc\", \"bacd\", \"array\"]\nfunction\
  \ filter_by_substring(strings: string[], substring: string): string[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = filter_by_substring;\n  assert.deepEqual(candidate([],\
  \ \"john\"),[]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"xxy\", \"john\
  \ doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"]);\n  assert.deepEqual(candidate([\"\
  xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"),[\"xxx\"\
  , \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n  assert.deepEqual(candidate([\"grunt\", \"\
  trumpet\", \"prune\", \"gruesome\"], \"run\"),[\"grunt\", \"prune\"]);\n}\n\ntest();"
completions: ["\tlet matches: string[] = [];\n\tstrings.forEach(str => {\n\t\tif (str.indexOf(substring)\
    \ !== -1) {\n\t\t\tmatches.push(str);\n\t\t}\n\t});\n\treturn matches;\n}\n",
  "  return strings.filter(item => item.includes(substring));\n}\n", "    return strings.filter(function\
    \ (el: string) {\n        return el.indexOf(substring) >= 0;\n    });\n}\n", " \
    \   const result = strings.filter(x => x.indexOf(substring) !== -1)\n    return\
    \ result.length ? result : strings.slice()\n}\n", "\tlet result: string[] = [];\n\
    \n\t// Create an array of the substrings we are looking for\n\tlet substrings:\
    \ string[] = substring.split(\"|\");\n\n\t// Loop through the list of strings\n\
    \tfor (let i = 0; i < strings.length; i++) {\n\t\t// Create an array of the substrings\
    \ we are looking for\n\t\tlet candidates = strings[i].split(\"|\");\n\n\t\t//\
    \ Loop through the list of substrings\n\t\tfor (let j = 0; j < substrings.length;\
    \ j++) {\n\t\t\tlet s = substrings[j];\n\n\t\t\t// If the candidate contains the\
    \ substring\n\t\t\tif (candidates.indexOf(s) >= 0) {\n\t\t\t\t// Add the current\
    \ string to the results\n\t\t\t\tresult.push(strings[i]);\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n\t}\n\n\treturn result;\n}\n", "  let filtered: string[] = [];\n\n\
    \  for (let i = 0; i < strings.length; ++i) {\n    if (strings[i].indexOf(substring)\
    \ !== -1) {\n      filtered.push(strings[i]);\n    }\n  }\n\n  return filtered;\n\
    }\n", "    return strings.filter(s => s.includes(substring));\n}\n", "    const\
    \ regex = new RegExp(`^${substring}`);\n    return strings.filter((str) => regex.test(str));\n\
    }\n", "  return strings.filter((string) => {\n    return string.includes(substring);\n\
    \  });\n}\n", "  const matches: string[] = [];\n  strings.forEach((s) => {\n \
    \   if (s.indexOf(substring) > -1) {\n      matches.push(s);\n    }\n  });\n \
    \ return matches;\n}\n", "  return strings.filter(function (str) {\n    return\
    \ str.indexOf(substring) !== -1;\n  });\n}\n", "    substring = substring.trim();\n\
    \    return strings.filter(function (string) {\n        return string.indexOf(substring)\
    \ !== -1;\n    });\n}\n", "    let filtered: string[] = [];\n    strings.forEach((value:\
    \ string) => {\n        if (value.includes(substring)) {\n            filtered.push(value);\n\
    \        }\n    });\n    return filtered;\n}\n", "  return strings.filter(string\
    \ => string.includes(substring));\n}\n</code></pre>\n<pre class=\"fragment\"><code\
    \ class=\"typescript line-numbers\" contenteditable data-trim>", "  return objects.filter(function\
    \ (string) {\n    return string.includes(substring);\n  });\n}\n", "  return strings.filter(s\
    \ => s.indexOf(substring) > -1);\n}\n", "\tconst filtered_strings = strings.filter((s)\
    \ => {\n\t\tif (s.indexOf(substring) !== -1) {\n\t\t\treturn true;\n\t\t}\n\t\
    });\n\treturn filtered_strings;\n}\n", "\tvar filtered_strings: string[] = [];\n\
    \tfor (var string_i = 0; string_i < strings.length; string_i++) {\n\t\tif (strings[string_i].indexOf(substring)\
    \ != -1) {\n\t\t\tfiltered_strings.push( strings[string_i] );\n\t\t}\n\t}\n\t\
    return filtered_strings;\n}\n", "    const filter: string[] = [];\n    strings.forEach(string\
    \ => {\n        if (string.includes(substring)) {\n            filter.push(string);\n\
    \        }\n    });\n    return filter;\n}", "  const new_strings: string[] =\
    \ [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)\
    \ >= 0) {\n      new_strings.push(strings[i]);\n    }\n  }\n  return new_strings;\n\
    }\n</code>\n<|/ a tags=arrays,javascript,typescript |>\n<| a dscore=0 tags=arrays,javascript,typescript\
    \ |>\nUse filter and includes like this:\n<code>\nlet arr = [ 'a', 'bb', 'bbb',\
    \ 'cc' ];\nlet res = arr.filter(e => !e.includes('bb'));\nconsole.log(res);\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  substring = substring.trim();\n\
    \  return strings.filter((s) => {\n    return s.includes(substring);\n  });\n\
    }\n", "\tlet contains: string[] = [];\n\tlet noContain: string[] = [];\n\n\tstrings.forEach((value:\
    \ string) => {\n\t\tif (value.includes(substring)) {\n\t\t\tcontains.push(value);\n\
    \t\t} else {\n\t\t\tnoContain.push(value);\n\t\t}\n\t});\n\n\treturn [...contains,\
    \ ...noContain];\n}\n", "  if (\n    strings.length === 0 ||\n    substring ===\
    \ \"\" ||\n    strings[0] === substring\n  ) {\n    return strings\n  }\n  return\
    \ strings.filter(\n    (el) =>\n      el &&\n      el.indexOf(substring) !== -1\
    \ &&\n      el.length >= substring.length\n  )\n}\n", "    return strings.filter(s\
    \ => s.indexOf(substring) > -1);\n}\n", "    return strings.filter(s => s.indexOf(substring)\
    \ >= 0);\n}\n", "    const filtered_strings = strings.filter(function(string:\
    \ string) {\n        return string.indexOf(substring) !== -1;\n    });\n    return\
    \ filtered_strings;\n}", "    return objects.filter(s => s.indexOf(substring)\
    \ !== -1);\n}\n", "\tconst pattern = new RegExp(substring, \"i\");\n\treturn strings.filter(s\
    \ => pattern.test(s));\n}\n", "\treturn strings.filter(s => s.includes(substring));\n\
    }\n", "    return strings.filter((s) => s.indexOf(substring) > -1);\n}\n", "\t\
    return strings.filter(function(s) {\n\t\treturn s.indexOf(substring) >= 0;\n\t\
    });\n}\n", "    var filtered_strings = [];\n    strings.forEach(function(s) {\n\
    \        if (s.indexOf(substring) !== -1) {\n            filtered_strings.push(s);\n\
    \        }\n    });\n    return filtered_strings;\n}\n", "    if (substring.length\
    \ == 0) {\n        return strings;\n    }\n    var filtered_strings: string[]\
    \ = [];\n    strings.forEach(function (s) {\n        if (s.indexOf(substring)\
    \ > -1) {\n            filtered_strings.push(s);\n        }\n    });\n    return\
    \ filtered_strings;\n}\n", "    return strings.filter(\n        (string) => string.includes(substring),\n\
    \    );\n}\n", "    const result: string[] = [];\n    for (const string of strings)\
    \ {\n        if (string.includes(substring)) {\n            result.push(string);\n\
    \        }\n    }\n    return result;\n}", "  return strings.filter(str => str.includes(substring));\n\
    }\n", "  var filtered_strings = [];\n  var filtered_substring = substring.toLowerCase();\n\
    \  for (var i = 0; i < strings.length; i++) {\n    if (strings[i].toLowerCase().indexOf(filtered_substring)\
    \ !== -1) {\n      filtered_strings.push(strings[i]);\n    }\n  }\n  return filtered_strings;\n\
    }\n", "  let filtered: string[] = [];\n  strings.forEach((str: string) => {\n\
    \    if (str.includes(substring)) {\n      filtered.push(str);\n    }\n  });\n\
    \  return filtered;\n}\n", "    return objects.filter(\n        s => s.indexOf(substring)\
    \ >= 0\n    );\n}\n", "    var result: string[] = [];\n    strings.forEach(function\
    \ (val) {\n        if (substring.indexOf(val) !== -1) {\n            result.push(val);\n\
    \        }\n    });\n    return result;\n}\n", "\tconst filtered: string[] = [];\n\
    \tfor (let i = 0; i < strings.length; i++) {\n\t\tif (strings[i].includes(substring))\
    \ {\n\t\t\tfiltered.push(strings[i]);\n\t\t}\n\t}\n\treturn filtered;\n}\n", "\t\
    return strings.filter(string => string.includes(substring));\n}\n", "  return\
    \ strings.filter(s => s.indexOf(substring) !== -1)\n}\n", "    let result = new\
    \ Array();\n    for (let i = 0; i < strings.length; i++) {\n        let value\
    \ = strings[i];\n        if (value.includes(substring)) {\n            result.push(value);\n\
    \        }\n    }\n    return result;\n}", "\tconst substring_index: string[]\
    \ = [];\n\tfor (let i = 0; i < strings.length; i += 1) {\n\t\tif (strings[i].indexOf(substring)\
    \ >= 0) {\n\t\t\tsubstring_index.push(strings[i]);\n\t\t}\n\t}\n\treturn substring_index;\n\
    }", "    var strings_length: string[] = [];\n    strings.forEach(function(s) {\n\
    \        strings_length.push(s.length);\n    });\n\n    var min_length_index:\
    \ string[] = strings_length.map(function(len) {\n        return strings_length.indexOf(len);\n\
    \    }).filter(function(i) {\n        return strings_length[i] > substring.length;\n\
    \    });\n\n    return strings.filter(function(s, i) {\n        return min_length_index.indexOf(i)\
    \ === -1;\n    });\n}\n", "    return strings.filter(s => s.includes(substring));\n\
    }\n", "  if (strings.length > 0) {\n    return strings.filter(string => string.includes(substring));\n\
    \  } else {\n    return [];\n  }\n}\n", "\treturn objects.filter(function (s:\
    \ string) {\n\t\treturn s.indexOf(substring) !== -1\n\t})\n}\n", "    let filtered:\
    \ string[] = [];\n    for (let i = 0; i < strings.length; i++) {\n        const\
    \ s = strings[i];\n        if (s.indexOf(substring) !== -1) {\n            filtered.push(s);\n\
    \        }\n    }\n    return filtered;\n}\n", "\tconst to_return: string[] =\
    \ [];\n\tfor (const string of strings) {\n\t\tif (string.includes(substring))\
    \ {\n\t\t\tto_return.push(string);\n\t\t}\n\t}\n\treturn to_return;\n}\n", " \
    \ const result = strings.filter((item: string) => item.includes(substring));\n\
    \  return result.length ? result : [];\n}", "\treturn strings.filter(function\
    \ (element: string) {\n\t\treturn element.indexOf(substring) !== -1;\n\t});\n\
    }\n", "    let filtered_strings: string[] = [];\n    for (let str of strings)\
    \ {\n        if (str.indexOf(substring) !== -1) {\n            filtered_strings.push(str);\n\
    \        }\n    }\n    return filtered_strings;\n}\n", "\treturn strings.filter(function(s)\
    \ {\n\t\treturn s.indexOf(substring) !== -1;\n\t});\n}\n", "    return strings.filter(function\
    \ (s: string) {\n        return s.indexOf(substring) != -1;\n    });\n}\n", " \
    \   strings.filter((str: string) => str.includes(substring));\n}\n", "  let new_strings:\
    \ string[] = []\n  strings.forEach((string) => {\n    if (string.includes(substring))\
    \ {\n      new_strings.push(string)\n    }\n  })\n  return new_strings\n}\n",
  "  var filtered_strings = strings.filter(function (str) {\n    return str.indexOf(substring)\
    \ > -1;\n  });\n\n  return filtered_strings;\n}\n", "    return strings.filter(s\
    \ => s.indexOf(substring) > -1);\n}", "    return strings.filter(s => s.indexOf(substring)\
    \ !== -1);\n}\n", "  const filtered_strings = new Array<string>();\n  for (const\
    \ string of strings) {\n    if (string.includes(substring)) {\n      filtered_strings.push(string);\n\
    \    }\n  }\n  return filtered_strings;\n}\n", "  return strings.filter(function\
    \ (el) {\n    return el.includes(substring);\n  });\n}\n", "    return strings.filter(str\
    \ => str.includes(substring));\n}\n", "    if (substring.length !== 1 || substring[0]\
    \ !== \"a\") {\n        return strings;\n    }\n    return objects.filter(s =>\
    \ s.indexOf(substring) !== -1);\n}\n", "  var new_strings: string[] = [];\n  for\
    \ (var i=0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)\
    \ > -1) {\n      new_strings.push(strings[i]);\n    }\n  }\n  return new_strings;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nIf you don't want to create new array, you can\
    \ try this:\n<code>\nvar input = ['abc', 'abcd', 'abce', 'abcf', 'abcfg'];\nvar\
    \ regex = /a.*/g;\ninput.filter((v, i, a) => a.indexOf(v) === i).forEach(v =>\
    \ console.log('filtered: ', v));\n</code>\n<|/ a dscore=1 tags=filtering,typescript,arrays\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding how and/or why it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| a dscore=0 |>\nIf you're only interested in filtering for\
    \ matching strings, then you can use a map to return the matches, then filter\
    \ using .filter() to remove them.\n\n<code>\nconst input = ['abc', 'abcd', 'abce',\
    \ 'abcf', 'abcfg'];\nconst input2 = ['abce', 'abcd'];\nconst input3 = ['abcd',\
    \ 'abcf', 'abcfg'];\n\nconst test = (strings, sub) => {\n  const matches = [];\n\
    \  strings.forEach(str => {\n    if (str.indexOf(sub) > -1) {\n      matches.push(str);\n\
    \    }\n  });\n  return matches;\n};\n\nconst filterMatches = strings => strings.filter(s\
    \ => test(strings, s));\n\nconsole.log(filterMatches(input));\nconsole.log(filterMatches(input2));\n\
    console.log(filterMatches(input3));</code>\n<|/ a tags=filtering,typescript,arrays\
    \ |>\n<| a dscore=0 |>\nA simple solution without loops and without array creation\
    \ is:\n<code>\nconst input = ['abc', 'abcd', 'abce', 'abcf', 'abcfg'];\nconst\
    \ regex = /a.*/g;\nconst output = input.filter(function(v) {\n  return regex.test(v);\n\
    });\n</code>\n<|/ a tags=filtering,typescript,arrays |>\n<| a tags=filtering,typescript,arrays\
    \ dscore=0 |>\n<code>", "\tlet out: string[] = [];\n\tlet hasSubstring = false;\n\
    \tfor (const str of strings) {\n\t\thasSubstring = (str.indexOf(substring) !==\
    \ -1);\n\t\tif (hasSubstring) {\n\t\t\tout.push(str);\n\t\t}\n\t}\n\treturn out;\n\
    }\n", "    substring = substring.toLowerCase();\n    return strings.filter(function\
    \ (string) {\n        return string.includes(substring);\n    });\n}\n", "  return\
    \ strings.filter(string => string.includes(substring));\n}\n", "\treturn strings.filter(function\
    \ (x) { return x.indexOf(substring) !== -1; });\n}", "  var filtered: string[]\
    \ = [];\n  for (var i=0; i<strings.length; i++) {\n    if (strings[i].indexOf(substring)\
    \ !== -1) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n\
    }\n", "    return strings.filter( (value: string) => value.includes(substring));\n\
    }", "    return strings.filter((s) => s.indexOf(substring) !== -1);\n}\n", " \
    \   if (strings == null) {\n        return null;\n    }\n\n    return strings.filter(s\
    \ => s.indexOf(substring) !== -1);\n}\n", "  return strings.filter(str => str.indexOf(substring)\
    \ >= 0)\n}\n", "    return strings.filter(s => s.includes(substring));\n}\n",
  "\treturn strings.filter(s => s.includes(substring));\n}\n", "\tconst matches: string[]\
    \ = [];\n\tfor (const string of strings) {\n\t\tif (string.includes(substring))\
    \ {\n\t\t\tmatches.push(string);\n\t\t}\n\t}\n\treturn matches;\n}\n", "    return\
    \ strings.filter(function (str) { return str.includes(substring); });\n}\n", " \
    \   return strings.filter(s => s.includes(substring));\n}\nexports.filter_by_substring\
    \ = filter_by_substring;", "  let filtered_strings = strings.filter((str) => {\n\
    \    return str.includes(substring);\n  });\n\n  return filtered_strings;\n}\n",
  "    return strings.filter(function (string: string) {\n        return string.includes(substring);\n\
    \    });\n}\n", "  if(!substring) {\n    return strings;\n  }\n\n  return strings.filter(str\
    \ => str.includes(substring));\n}\n", "  const filtered_strings = strings.filter(function(string)\
    \ {\n    return string.indexOf(substring) !== -1;\n  });\n  return filtered_strings;\n\
    }", "  return strings.filter(string => string.includes(substring));\n}\n", "\t\
    return strings.filter(function (str) {\n\t\treturn str.indexOf(substring) !==\
    \ -1;\n\t});\n}\n", "  return strings.filter(function(string) {\n    return string.indexOf(substring)\
    \ !== -1\n  })\n}\n", "    const filtered_strings: string[] = [];\n    strings.forEach((str:\
    \ string) => {\n        if (str.includes(substring)) {\n            filtered_strings.push(str);\n\
    \        }\n    });\n    return filtered_strings;\n}\n", "    return strings.filter(s\
    \ => s.includes(substring));\n}\n", "    return strings.filter(s => s.indexOf(substring)\
    \ !== -1)\n}\n", "    return strings.filter(s => s.indexOf(substring) !== -1)\n\
    }\n", "  const filtered_strings = strings.filter((s) => s.includes(substring));\n\
    \  return filtered_strings;\n}\n", "    return strings.filter( (s) => s.indexOf(substring)\
    \ !== -1 );\n}\n", "\tvar filtered_strings: string[] = [];\n\n\tstrings.forEach(function(string:\
    \ string) {\n\t\tif (string.includes(substring)) {\n\t\t\tfiltered_strings.push(string);\n\
    \t\t}\n\t});\n\n\treturn filtered_strings;\n}\n", "    const substrings = substring.split(\"\
    \");\n    const filtered: string[] = [];\n    strings.forEach(string => {\n  \
    \      const contains_substring: string[] = string.split(substring);\n       \
    \ contains_substring.forEach(element => {\n            filtered.push(element);\n\
    \        });\n    });\n    return filtered;\n}\n", "  if (\n    !strings.some((s)\
    \ => s.indexOf(substring) !== -1) //Does not contain substring\n  ) {\n    return\
    \ strings; // no matches found\n  }\n\n  const filtered_strings = strings.filter(\n\
    \    (s) => s.indexOf(substring) !== -1,\n  ); //Has substring\n  return filtered_strings;\n\
    }\n", "    if (substring.length < 1) {\n        return strings;\n    }\n    let\
    \ result: string[] = [];\n    for (let i = 0; i < strings.length; i++) {\n   \
    \     if (strings[i].indexOf(substring) >= 0) {\n            result.push(strings[i]);\n\
    \        }\n    }\n    return result;\n}\n", "    if (strings.length === 0) {\n\
    \        return [];\n    }\n\n    let filtered_strings = strings.filter((s) =>\
    \ {\n        return s.includes(substring);\n    });\n    return filtered_strings;\n\
    }\n", "    return strings.filter((s) => s.indexOf(substring) !== -1)\n}\n", " \
    \   return strings.filter(val => val.includes(substring));\n}\n", "\tlet filtered_strings:\
    \ string[] = [];\n\n\tfor (let i = 0; i < strings.length; i++) {\n\t\tif (strings[i].indexOf(substring)\
    \ !== -1) {\n\t\t\tfiltered_strings.push(strings[i]);\n\t\t}\n\t}\n\n\treturn\
    \ filtered_strings;\n}\n", "    return strings.filter(s => s.indexOf(substring)\
    \ !== -1);\n}\n", "\tlet matches: string[] = [];\n\tfor (let i = 0; i < strings.length;\
    \ i++) {\n\t\tif (strings[i].indexOf(substring) !== -1) {\n\t\t\tmatches.push(strings[i]);\n\
    \t\t}\n\t}\n\treturn matches;\n}\n", "  const filtered_strings = strings.filter(function\
    \ (s: string) {\n    return s.indexOf(substring) >= 0;\n  });\n  return filtered_strings;\n\
    }\n", "  return strings.filter((x) => x.indexOf(substring) >= 0);\n}\n", "\tvar\
    \ new_array: string[] = [];\n\tfor (var i = 0; i < strings.length; i++) {\n\t\t\
    var str = strings[i];\n\t\tif (str.indexOf(substring) >= 0)\n\t\t\tnew_array.push(str);\n\
    \t}\n\treturn new_array;\n}\n", "    return strings.filter(function (string: string)\
    \ {\n        return string.indexOf(substring) !== -1;\n    });\n}\n", "  return\
    \ strings.filter(s => s.indexOf(substring) > -1);\n}\n", "    if (strings.length\
    \ === 0) {\n        return strings;\n    }\n    return strings.filter(x => x.includes(substring));\n\
    }\n", "    return strings.filter(function (string) {\n        return string.indexOf(substring)\
    \ !== -1;\n    });\n}\n", "\treturn strings.filter(s => s.indexOf(substring) !==\
    \ -1)\n}\n", "    substring = substring || '';\n    return strings.filter(s =>\
    \ s.indexOf(substring) !== -1);\n}\n", "    var strings_clone: string[] = strings.slice(0);\n\
    \    return strings_clone.filter(function(val: string) {\n        return val.includes(substring);\n\
    \    });\n}\n</code>\n<|/ a dscore=2 tags=javascript,arrays |>\n<| a dscore=1\
    \ |>\nTo filter based on a property, you can iterate through the array and return\
    \ the elements when property value matches:\n\n<code>\nlet arr = [{ id: 1, name:\
    \ 'Abc' }, { id: 2, name: 'XYZ' }, { id: 3, name: 'PQR' }, { id: 4, name: 'LMN'\
    \ }];\n\nlet filtered = arr.filter(function(item) {\n    return item.name ===\
    \ \"PQR\";\n});\n\nconsole.log(filtered);</code>\n<|/ a tags=javascript,arrays\
    \ |>\n<| a tags=javascript,arrays |>\nyou can do that in 2 ways:\n\nFilter by\
    \ object property:\n\n<code>\nlet arr = [\n  {\n    id: 1,\n    name: \"Abc\"\n\
    \  },\n  {\n    id: 2,\n    name: \"XYZ\"\n  },\n  {\n    id: 3,\n    name: \"\
    PQR\"\n  },\n  {\n    id: 4,\n    name: \"LMN\"\n  }\n];\n\nlet filter = arr.filter(function(el)\
    \ {\n  return el.name === \"PQR\";\n});\n\nconsole.log(filter);</code>\n\nFilter\
    \ by specific property:\n\n<code>\nlet arr = [\n  {\n    id: 1,\n    name: \"\
    Abc\"\n  },\n  {\n    id: 2,\n    name: \"XYZ\"\n  },\n  {\n    id: 3,\n    name:\
    \ \"PQR\"\n  },\n  {\n    id: 4,\n    name: \"LMN\"\n  }\n];\n\nlet filter = arr.filter(function(el)\
    \ {\n  return el.name === \"LMN\";\n});\n\nconsole.log(filter);</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=1 |>\n<code>\nlet arr = [\n  {\n    id: 1,\n    name:\
    \ \"Abc\"\n  },\n  {\n    id: 2,\n    name: \"XYZ\"\n  },\n  {\n    id: 3,\n \
    \   name: \"PQR\"\n  },\n  {\n    id: 4,\n    name: \"LMN\"\n  }\n];\n\nlet filtered\
    \ = arr.filter(function(item) {\n  return item.name === \"PQR\";\n});\n\nconsole.log(filtered);</code>\n\
    <|/ a tags=javascript,arrays |>\n<| a |>\nThe way I would approach this is to\
    \ filter out all items with ids not in your list of accepted ids.\n\n<code>\n\
    const acceptedIds = [4, 5];\nconst items = [\n  { id: 1, name: \"Abc\" },\n  {\
    \ id: 2, name: \"XYZ\" },\n  { id: 3, name: \"PQR\" },", "    return strings.filter(s\
    \ => s.includes(substring));\n}\n", "\treturn strings.filter((str) => str.includes(substring));\n\
    }", "    if (substring.length > strings.length) {\n        throw new Error(`Invalid\
    \ substring length. Expected <= ${strings.length}, but got ${substring.length}`);\n\
    \    }\n    const filtered: string[] = [];\n    for (let i = 0; i < strings.length;\
    \ ++i) {\n        if (strings[i].includes(substring)) {\n            filtered.push(strings[i]);\n\
    \        }\n    }\n    return filtered;\n}\n", "    return strings.filter(s =>\
    \ s.indexOf(substring) > -1);\n}\n", "\tlet filtered_strings = strings.filter(x\
    \ => x.indexOf(substring) !== -1);\n\treturn filtered_strings;\n}\n", "  const\
    \ new_strings = strings.filter(s => s.indexOf(substring) !== -1);\n  \n  return\
    \ new_strings;\n}\n", "    return strings.filter((str) => {\n        return str.includes(substring);\n\
    \    });\n}\n", "    return strings.filter(\n        s => s.indexOf(substring)\
    \ !== -1\n    );\n}\n", "  const filtered_strings = [];\n  for (let i = 0; i <\
    \ strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered_strings.push(strings[i]);\n\
    \    }\n  }\n  return filtered_strings;\n}\n", "  return strings.filter(string\
    \ => string.includes(substring));\n}\n", "  return strings.filter(function (str)\
    \ {\n    return str.indexOf(substring) !== -1;\n  });\n}\n", "    return strings.filter((s)\
    \ => s.includes(substring));\n}\n", "    if (!Array.isArray(strings)) {\n    \
    \    strings = [strings];\n    }\n    const filtered_strings = strings.filter((s)\
    \ => s.indexOf(substring) !== -1);\n    return filtered_strings;\n}\n", "  var\
    \ filtered_strings: string[] = [];\n  for (var i = 0, len = strings.length; i\
    \ < len; i++) {\n    var str = strings[i];\n    if (str.indexOf(substring) !=\
    \ -1) {\n      filtered_strings.push(str);\n    }\n  }\n  return filtered_strings;\n\
    }\n", "  var filtered_strings = strings.filter(function (str) {\n    return str.indexOf(substring)\
    \ >= 0;\n  });\n  return filtered_strings;\n}\n", "    const filtered: string[]\
    \ = [];\n    for (let i = 0; i < strings.length; i++) {\n        if (strings[i].includes(substring))\
    \ {\n            filtered.push(strings[i]);\n        }\n    }\n    return filtered;\n\
    }\n", "\tconst re = new RegExp(`^${substring}`);\n\treturn strings.filter(str\
    \ => re.exec(str) !== null);\n}\n", "    var filtered_strings: string[] = [];\n\
    \    strings.forEach((str: string) => {\n        if (substring.search(str) > -1)\
    \ {\n            filtered_strings.push(str);\n        }\n    });\n    return filtered_strings;\n\
    }\n", "    return strings.filter(s => s.includes(substring));\n}", "  return strings.filter((item:\
    \ string) => {\n    return item.indexOf(substring) !== -1;\n  });\n}\n", "   \
    \ const pattern = new RegExp(substring, \"i\");\n    const filtered: string[]\
    \ = [];\n    for (const string of strings) {\n        if ( pattern.test(string)\
    \ ) {\n            filtered.push(string);\n        }\n    }\n    return filtered;\n\
    }\n\n", "  return strings.filter(s => s.includes(substring));\n}\n", "  return\
    \ strings.filter((s) => s.indexOf(substring) > -1);\n}\n", "    if (!strings.length)\n\
    \        return strings;\n\n    for (let i = 0; i < strings.length; i++) {\n \
    \       if (strings[i].indexOf(substring) !== -1) {\n            strings.splice(i,\
    \ 1);\n            i--;\n        }\n    }\n\n    return strings;\n}\n", "\tconst\
    \ filtered_strings = strings.filter((string) => {\n\t\treturn string.includes(substring);\n\
    \t});\n\treturn filtered_strings;\n}\n", "  var filtered_strings: string[] = [];\n\
    \  for (var i = 0; i < strings.length; i++) {\n    var element = strings[i];\n\
    \    if (element.indexOf(substring) >= 0) {\n      filtered_strings.push(element);\n\
    \    }\n  }\n  return filtered_strings;\n}\n", "\tconst found: string[] = [];\n\
    \tfor (let i = 0; i < strings.length; i++) {\n\t\tlet index = strings[i].indexOf(substring);\n\
    \t\tif (index >= 0) found.push(strings[i]);\n\t}\n\treturn found;\n}\n", "\treturn\
    \ strings.filter((s) => s.indexOf(substring) !== -1);\n}", "    return strings.filter((s)\
    \ => {\n        return (s.includes(substring));\n    });\n}\n", "\treturn strings.filter(s\
    \ => s.indexOf(substring) !== -1);\n}\n", "    if (strings.length === 0) {\n \
    \       return [];\n    }\n    const filtered_strings = strings.filter(function\
    \ (value: string) {\n        return value.indexOf(substring) !== -1;\n    });\n\
    \    return filtered_strings;\n}\n", "    const substrings = new Set(strings);\n\
    \    return strings.filter(string => substrings.has(string.indexOf(substring)\
    \ + substring.length));\n}\n", "  let filtered_strings = [];\n  for (let string\
    \ of strings) {\n    if (string.includes(substring)) {\n      filtered_strings.push(string);\n\
    \    }\n  }\n  return filtered_strings;\n}\n", "  const result = strings.filter(s\
    \ => s.includes(substring));\n  return result.length ? result : strings.slice();\n\
    }\n", "  return strings.filter(s => s.includes(substring));\n}\n", "  const filtered_strings\
    \ = strings.filter((string) => {\n    return string.indexOf(substring) !== -1;\n\
    \  });\n  return filtered_strings;\n}\n", "  if (strings.length == 0) {\n    return\
    \ strings;\n  }\n\n  const substring_index: string[] = substring.toLowerCase().split(\"\
    \").filter(e => e != \"\");\n\n  const filtered_indexes = _.findIndex(strings,\
    \ (string_arg) => {\n    let substring_found = false;\n\n    substring_index.forEach((index,\
    \ i) => {\n      if (string_arg[index] === substring_found) {\n        substring_found\
    \ = true;\n      }\n    });\n\n    return substring_found;\n  });\n\n  return\
    \ strings.filter((string_arg, i) => filtered_indexes != i);\n}\n", "    return\
    \ strings.filter(value => value.includes(substring));\n}\n", "    return strings.filter(string\
    \ => string.includes(substring));\n}\n", "  substring = substring.trim();\n  return\
    \ strings.filter(s => s.includes(substring));\n}\n", "    return strings.filter(s\
    \ => s.indexOf(substring) !== -1);\n}", "\treturn strings.filter( (s) => {\n\t\
    \treturn s.indexOf(substring) !== -1; \n\t});\n}", "    var result = strings.filter(function\
    \ (str: string) {\n        return str.indexOf(substring) !== -1;\n    });\n  \
    \  return result;\n}\n", "  const return_strings = strings.filter(\n    string\
    \ => string.includes(substring)\n  );\n  return return_strings;\n}\n", "\tvar\
    \ filtered_strings = strings.filter(function (string: string) {\n\t\treturn string.indexOf(substring)\
    \ > -1;\n\t});\n\treturn filtered_strings;\n}\n", "\treturn strings.filter(x =>\
    \ x.indexOf(substring) !== -1);\n}\n", "    const filtered_strings = [];\n   \
    \ for (let i = 0; i < strings.length; i++) {\n        if (strings[i].indexOf(substring)\
    \ !== -1) {\n            filtered_strings.push(strings[i]);\n        }\n    }\n\
    \    return filtered_strings;\n}", "  if (strings.length < 1 || substring.length\
    \ < 1) {\n    return [];\n  }\n  return strings.filter(function (s: string) {\n\
    \    return s.indexOf(substring) >= 0;\n  });\n}\n", "    let filtered: string[]\
    \ = [];\n    strings.forEach(s => {\n        if (s.indexOf(substring) !== -1)\
    \ {\n            filtered.push(s);\n        }\n    });\n    return filtered;\n\
    }\n", "  strings = strings.map(str => str.split(substring).filter(Boolean));\n\
    \  return strings;\n}\n", "  return strings.filter((el) => {\n    return el.indexOf(substring)\
    \ !== -1;\n  });\n}\n", "  if (strings.length === 0) return [];\n  let out: string[]\
    \ = [];\n  strings.forEach((s) => {\n    if (s.indexOf(substring) > -1) out.push(s);\n\
    \  });\n  return out;\n}\n", "    return strings.filter(s => s.indexOf(substring)\
    \ >= 0);\n}\n", "    return strings.filter((s) => {\n        return (s.indexOf(substring)\
    \ != -1);\n    });\n}\n", "  return strings.filter(function (string: string) {\
    \ return string.includes(substring); });\n}\n", "    return strings.filter((s)\
    \ => s.indexOf(substring) !== -1);\n}\n", "  const result = [];\n  for (const\
    \ string of strings) {\n    if (string.includes(substring)) {\n      result.push(string);\n\
    \    }\n  }\n  return result;\n}\n", "  return strings.filter(function (value)\
    \ {\n    return value.includes(substring);\n  });\n}\n", "    let filtered_strings\
    \ = strings.filter(string => {\n        return string.indexOf(substring) > -1;\n\
    \    });\n    return filtered_strings;\n}\n", "    return strings.filter((s) =>\
    \ s.includes(substring));\n}\n", "\treturn strings.filter(s => s.indexOf(substring)\
    \ !== -1);\n}\n", "  substring = substring.trim();\n  return strings.filter(s\
    \ => s.includes(substring));\n}\n", "  var filtered: string[] = [];\n  strings.filter(function\
    \ (str) {\n    if (str.indexOf(substring) !== -1) {\n      filtered.push(str);\n\
    \    }\n  });\n  return filtered;\n}\n", "    const found = [];\n    strings.forEach(s\
    \ => {\n        if (s.indexOf(substring) >= 0) {\n            found.push(s);\n\
    \        }\n    });\n    return found;\n}", "\tif (strings == null || strings.length\
    \ == 0) {\n\t\treturn strings;\n\t}\n\treturn strings.filter(s => s.includes(substring));\n\
    }\n", "  return strings.filter((item: string) => item.indexOf(substring) > -1);\n\
    }\n", "    return strings.filter(s => s.indexOf(substring) !== -1);\n}\n", " \
    \ return strings.filter(function(string: string) {\n    return string.indexOf(substring)\
    \ >= 0;\n  });\n}\n", "    var res = [];\n    strings.forEach(function (str) {\n\
    \        if (str.includes(substring)) {\n            res.push(str);\n        }\n\
    \    });\n    return res;\n}\n", "    return strings.filter(function (string:\
    \ string) {\n        return string.includes(substring);\n    });\n}\n", "    const\
    \ result: string[] = [];\n    for (let i = 0; i < strings.length; i++) {\n   \
    \     if (strings[i].indexOf(substring) !== -1) {\n            result.push(strings[i]);\n\
    \        }\n    }\n    return result;\n}\n", "\tif (typeof substring === \"string\"\
    \ && substring.length > 0) {\n\t\tlet filtered: string[] = [];\n\t\tfor (let i\
    \ = 0; i < strings.length; i++) {\n\t\t\tif (strings.indexOf(substring) > -1)\
    \ {\n\t\t\t\tfiltered.push(strings[i]);\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\
    \t} else {\n\t\treturn strings;\n\t}\n}\n", "    return strings.filter(a => a.indexOf(substring)\
    \ >= 0);\n}\n", "\treturn strings.filter((s) => s.includes(substring));\n}\n",
  "  let filtered_strings = strings.filter((string) => {\n    return string.includes(substring);\n\
    \  });\n  return filtered_strings;\n}\n", "    return strings.filter(value =>\
    \ value.includes(substring));\n}", "    return strings.filter(function(s) {\n\
    \        return (s.indexOf(substring) >= 0);\n    });\n}\n", "  return strings.filter((str)\
    \ => str.includes(substring));\n}\n", "    return objects.filter(string => string.includes(substring));\n\
    }\n", "    return strings.filter(function (str) { return str.indexOf(substring)\
    \ !== -1; });\n}\n", "  const substrings = substring.split(\"\");\n  return strings.filter(function\
    \ (str) {\n    return substrings.indexOf(str.substring(0,substring.length)) ==\
    \ -1\n  });\n}\n", "  return strings.filter((str) => str.includes(substring));\n\
    }\n", "    return strings.filter(function (val) {\n        return val.indexOf(substring)\
    \ >= 0;\n    });\n}\n", "  return strings.filter(s => s.includes(substring));\n\
    }\n", "\tconst filtered_strings = new Array<string>();\n\tconst length = strings.length;\n\
    \tfor (let i = 0; i < length; i++) {\n\t\tif (strings[i].indexOf(substring) !==\
    \ -1) {\n\t\t\tfiltered_strings.push(strings[i]);\n\t\t}\n\t}\n\treturn filtered_strings;\n\
    }\n", "    var filtered = [];\n    for (var i = 0; i < strings.length; i++) {\n\
    \        if (strings[i].indexOf(substring) > -1) {\n            filtered.push(strings[i]);\n\
    \        }\n    }\n    return filtered;\n}\n", "    if (strings.length === 0)\
    \ {\n        return strings;\n    }\n    const substrings = substring.split(\"\
    \");\n    let filtered_strings = strings.filter(function (string) {\n        let\
    \ found = false;\n        substrings.forEach(function (substring) {\n        \
    \    if (string.indexOf(substring) !== -1) {\n                found = true;\n\
    \            }\n        });\n        return found;\n    });\n    return filtered_strings;\n\
    }"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
