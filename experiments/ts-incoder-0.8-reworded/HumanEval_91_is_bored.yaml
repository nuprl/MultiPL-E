name: HumanEval_91_is_bored
language: ts
prompt: "//You'll be given a string of words, and your task is to count the number\n\
  // of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences\
  \ are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored(\"Hello world\"\
  )\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\"\
  )\n// 1\nfunction is_bored(S: string): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = is_bored;\n  assert.deepEqual(candidate(\"Hello world\"\
  ),0);\n  assert.deepEqual(candidate(\"Is the sky blue?\"),0);\n  assert.deepEqual(candidate(\"\
  I love It !\"),1);\n  assert.deepEqual(candidate(\"bIt\"),0);\n  assert.deepEqual(candidate(\"\
  I feel good today. I will be productive. will kill It\"),2);\n  assert.deepEqual(candidate(\"\
  You and I are going for a walk\"),0);\n}\n\ntest();"
completions: ["  let count = 0;\n  S.split('.').forEach(word => {\n    count += word.startsWith(\"\
    I\");\n  });\n  return count;\n}\n", "\treturn is_bored_1(S.split('.'), 0)\n}\n",
  "    let count = 0;\n    for (let i = 0; i < S.length; i++) {\n        if (S[i]\
    \ === \"I\") {\n            count++;\n        }\n    }\n    return count;\n}\n",
  "  // BEGIN Question 1\n  return S.split(\".\").join(\"\\n\").split(\"?\").join(\"\
    \\n\").split(\"!\").join(\"\\n\") ===\n      \"I\\n\".repeat(S.length);\n  //\
    \ END Question 1\n}\n", "  if (S.trim().length === 0) {\n    return 0;\n  }\n\n\
    \  const words: string[] = S.split('.');\n  for (let i = 0; i < words.length;\
    \ i++) {\n    if (words[i].startsWith(\"I\")) {\n      return i + 1;\n    }\n\
    \  }\n\n  return 0;\n}\n</code>\nSome other things I tried:\n<code>", "\treturn\
    \ boredom(S);\n}\n", "    return boredom_count(S);\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'i') {\n      if (i\
    \ > 0 && S[i - 1] === '?' || S[i - 1] === '.' || S[i - 1] === '!') {\n       \
    \ count += 1;\n      }\n    }\n  }\n  return count;\n}\n", "  let num = 0;\n \
    \ for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'i') {\n      num++;\n\
    \    }\n  }\n  return num;\n}\n", "  const boredoms: number[] = [];\n\n  for (let\
    \ i = 0; i <= S.length; ++i) {\n    if (S.charAt(i) === 'I') {\n      boredoms.push(i);\n\
    \    }\n  }\n\n  if (boredoms.length === 0) {\n    return 0;\n  }\n\n  const boredom\
    \ = boredoms[boredoms.length - 1];\n  const is_bored = boredom !== 0 ? boredoms[boredom\
    \ - 1] - boredom : 0;\n  return is_bored;\n}\n", "  const BOREDOM_SEPARATORS =\
    \ ['.', '?', '!'];\n  const words = S.split(/\\W+/);\n  return words.filter(w\
    \ => BOREDOM_SEPARATORS.some(b => w.startsWith(b))).length;\n}\n", "    const\
    \ arr: string[] = S.split('.');\n    for (let i = 0; i < arr.length; i++)\n  \
    \      if (arr[i].startsWith('I'))\n            return i;\n    return 0;\n}",
  "  const boredomRegex = /\\b(I\\b)+\\S+\\.\\s/;\n  const matchArr = S.match(boredomRegex);\n\
    \  return matchArr.length;\n}\n", "  // To implement this, use a for loop to iterate\
    \ through each character in S.\n  // Initialize the number of boredoms to 0.\n\
    \  let num_boredoms: number = 0;\n  for (let char of S) {\n    if (char === 'i')\
    \ {\n      // Increment the number of boredoms by 1.\n      num_boredoms += 1;\n\
    \    }\n  }\n  return num_boredoms;\n}\n", "  const words = S.split('.');\n  let\
    \ count = 0;\n  for (const word of words) {\n    if (word.startsWith('I')) count++;\n\
    \  }\n  return count;\n}\n", "    var count = 0;\n    var bored = S;\n    var\
    \ regex = /^[\\.\\?!](I)/gi;\n    var match;\n    while (match = regex.exec(bored))\
    \ {\n        count += 1;\n    }\n    return count;\n}\n</code>\nIf you really\
    \ want to do this without regex, it gets a bit longer:\n<code>", "  let boredom_count\
    \ = 0;\n  S.split('.').forEach(s => {\n    let i = s.indexOf('?');\n    if (i\
    \ === -1) {\n      i = s.indexOf('!');\n    }\n    if (i !== -1) {\n      s =\
    \ s.replace(/[^i!]/g, '');\n    } else {\n      s = s.replace('i', 'I');\n   \
    \ }\n    if (s === 'I') boredom_count++;\n  });\n  return boredom_count;\n}\n",
  "  const bored = S.split(/[.?!]/).filter((w) => w.match(/^I$/i));\n  return bored.length\
    \ > 0 ? bored.length : 0;\n}\n", "  console.log(S);\n  let s = S;\n  console.log(s);\n\
    \  let boredoms = 0;\n  for (let i = 0; i < s.length; ++i) {\n    console.log(s.charAt(i));\n\
    \    if (s.charAt(i) == \"I\") {\n      boredoms += 1;\n    }\n  }\n  return boredoms;\n\
    }\n", "  return boredom_count(S);\n}\n", "  let arr = S.split('.');\n  return\
    \ arr.filter(s => s.startsWith('I')).filter((s, i, a) => a.lastIndexOf('.') ===\
    \ i).length\n}", "  const words = S.split('.').filter((x) => x.trim() !== '');\n\
    \  const boredoms = words.filter((x) => x === \"I\");\n  return boredoms.length;\n\
    }\n", "\tlet bored = 0;\n\tfor (let i = 0; i < S.length; ++i) {\n\t\tlet c = S[i].toLowerCase();\n\
    \t\tif (c == \"i\") {\n\t\t\t++bored;\n\t\t}\n\t}\n\treturn bored;\n}\n", "  let\
    \ arr = S.split('.');\n  return arr.some(s => s === 'I' || s === '!' || s ===\
    \ '?')\n    ? 0\n    : 1\n}\n", "  let boredoms: number[] = [];\n  for (let i\
    \ = 0; i < S.length; ++i) {\n    let c = S[i];\n    if (c === '.' || c === '?'\
    \ || c === '!') {\n      boredoms.push(i);\n    }\n  }\n  return boredoms.length;\n\
    }", "\tlet boredoms: number[] = [];\n\tfor (let i = 0; i < S.length; i++) {\n\t\
    \tlet curr = S[i];\n\t\tif (curr === 'i') boredoms.push(i);\n\t}\n\treturn boredoms.length;\n\
    }\n", "    let words = S.split(\" \");\n    let bored = 0;\n    for (let i = 0;\
    \ i < words.length; i++) {\n        let word = words[i];\n        if (word ===\
    \ \"I\" || word.startsWith(\"I\")) {\n            bored += 1;\n        }\n   \
    \ }\n    return bored;\n}\n", "  const count_boredoms = (str: string): number\
    \ => {\n    if (str.length === 0) {\n      return 0;\n    }\n\n    const arr =\
    \ str\n      .split(/(\\.|\\?|\\!)/g)\n      .filter(s => s.trim() !== '');\n\n\
    \    // First and last char must be lowercase and be 'i'\n    const is_bored =\
    \ arr.some(s => s.toLowerCase()[0] === 'i' && s.length <= 3);\n\n    if (is_bored)\
    \ {\n      return arr.length;\n    }\n\n    return count_boredoms(arr.slice(1,\
    \ -1).join('.'));\n  };\n\n  return count_boredoms(S);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis solution will result in stack-overflow for very long strings.\
    \ You have to add a `break` in the `forEach` function at some point, when you\
    \ are done with all the strings.\n<|/ c |>\n<| c |>\nSure, I can add a `break`\
    \ statement in the loop. But this is not a good solution in general, for long\
    \ strings, as described in the comments above. He can add `break` to the end of\
    \ the loop if the string is long enough.\n<|/ c |>\n<| c |>\nThat's true, but\
    \ this solution is actually not good anyway. As I said, `break` inside the `forEach`\
    \ will make your code very slow, because the function will iterate over all the\
    \ elements again. Also, this function will iterate over all the elements again\
    \ and again and again, so you need a smarter solution for long strings. But if\
    \ you were to add `break` after your recursive call, your code will fail, because\
    \ you will get an infinite recursion.\n<|/ c |>\n<| c |>\nI agree with you that\
    \ my solution is not smart and is slow. But OP asked for a \"counting boredom\"\
    \ solution, not an algorithm to detect boredoms. Also, he has said that the input\
    \ can be very long, and I believe that his problem will be resolved even with\
    \ the recursion, since he will have to iterate the input string until the length\
    \ of the string is greater than 3. If he really wants an algorithm, then my algorithm\
    \ is not the best one, but I think I will not add this part to the answer as it\
    \ would be too long.\n<|/ c |>\n<| c |>\nWell maybe he doesn't want to use an\
    \ algorithm if he has \"a very long string\". But if he has a very long string,\
    \ then this solution would be very slow, because the function will iterate over\
    \ all the elements. As I said, you should use another solution for long strings.\
    \ And if you think about it, what will your algorithm do if the string is \"i\
    \ love this weather\" ? It will iterate over the entire string ", "    S.split(\"\
    \ \").map(word => {\n        if (word[0] === \"I\") return 1;\n        else return\
    \ 0\n    }).reduce((a, b) => a + b, 0);\n}\n</code>\n<|/ a tags=typescript |>\n\
    <| c |>\nI like your answer, but this would still require a lot more refactoring\
    \ than is required. I'm going to have to learn about typescript functional programming\
    \ soon enough\n<|/ c |>\n<| c |>\nIt would require a lot less refactoring, but\
    \ I guess it would be a lot more verbose. I'm interested in answers that can do\
    \ this without too much refactoring though\n<|/ c |>\n<| c |>\n, I've added a\
    \ functional answer (although not as clean as yours) which doesn't require much\
    \ refactoring, but still uses very basic functions.\n<|/ c |>\n<| c |>\nThis also\
    \ fails on input \"I love this weather.\" It should return 0.\n<|/ c |>\n<| c\
    \ |>\n, yes, that's what it does.\n<|/ c |>\n<| a tags=typescript dscore=1 |>\n\
    A functional style would be:\n<code>", "  if (S[0] === 'I') {\n    return 0;\n\
    \  }\n  if (S[0] === '?') {\n    return 0;\n  }\n  if (S[0] === '!') {\n    return\
    \ 1;\n  }\n  for (let i = 1; i < S.length; i++) {\n    if (S[i] === '.' || S[i]\
    \ === '?' || S[i] === '!') {\n      return 0;\n    }\n  }\n  return 1;\n}\n",
  "  return count_boredoms(S, '.') +\n         count_boredoms(S, '?') +\n        \
    \ count_boredoms(S, '!');\n}\n", "\tlet boredoms = 0\n\tfor (let i = 0; i < S.length;\
    \ i++) {\n\t\tconst word: number = S[i].charCodeAt(0)\n\t\tswitch (word) {\n\t\
    \t\tcase 63:\n\t\t\t\tif (S[i+1] && S[i+1].charCodeAt(0) == 63 && !S[i+2].charCodeAt(0))\
    \ boredoms++\n\t\t\t\tbreak\n\t\t\tcase 65:\n\t\t\t\tif (S[i+1] && S[i+1].charCodeAt(0)\
    \ == 65 && !S[i+2].charCodeAt(0)) boredoms++\n\t\t\t\tbreak\n\t\t\tcase 67:\n\t\
    \t\t\tif (S[i+1] && S[i+1].charCodeAt(0) == 67 && !S[i+2].charCodeAt(0)) boredoms++\n\
    \t\t\t\tbreak\n\t\t\tcase 99:\n\t\t\t\tif (S[i+1] && S[i+1].charCodeAt(0) == 99\
    \ && !S[i+2].charCodeAt(0)) boredoms++\n\t\t\t\tbreak\n\t\t\tcase 101:\n\t\t\t\
    \tif (S[i+1] && S[i+1].charCodeAt(0) == 101 && !S[i+2].charCodeAt(0)) boredoms++\n\
    \t\t\t\tbreak\n\t\t\tcase 115:\n\t\t\t\tif (S[i+1] && S[i+1].charCodeAt(0) ==\
    \ 115 && !S[i+2].charCodeAt(0)) boredoms++\n\t\t\t\tbreak\n\t\t\tcase 116:\n\t\
    \t\t\tif (S[i+1] && S[i+1].charCodeAt(0) == 116 && !S[i+2].charCodeAt(0)) boredoms++\n\
    \t\t\t\tbreak\n\t\t\tcase 122:\n\t\t\t\tif (S[i+1] && S[i+1].charCodeAt(0) ==\
    \ 122 && !S[i+2].charCodeAt(0)) boredoms++\n\t\t\t\tbreak\n\t\t\tcase 125:\n\t\
    \t\t\tif (S[i+1] && S[i+1].charCodeAt(0) == 125 && !S[i+2].charCodeAt(0)) boredoms++\n\
    \t\t\t\tbreak\n\t\t\tcase 130:\n\t\t\t\tif (S[i+1] && S[i+1].charCodeAt(0) ==\
    \ 130 && !S[i+2].charCodeAt(0)) boredoms++\n\t\t\t\tbreak\n\t\t\tcase 131:\n\t\
    \t\t\tif (S[i+1] && S[i+1].charCodeAt(0) == 131 && !S[i+2].charCodeAt(0)) boredoms++\n\
    \t\t\t\tbreak\n\t\t\tcase 136:\n\t\t\t\tif (S[i+1] && S[i+1].charCodeAt(0) ==\
    \ 136 && !S[i+2].charCodeAt(0)) boredoms++\n\t\t\t\tbreak\n\t\t\tcase 139:\n\t\
    \t\t\tif (S[i+1] && S[i+1].charCodeAt(0) == 139 && !S[i+2].charCodeAt(0)) boredoms++\n\
    \t\t\t\tbreak\n\t\t\tcase 140:\n\t\t\t\tif (S[i+1] && S[i+1].charCodeAt(0) ==\
    \ 140 && !S[i+2].charCodeAt(0)) boredoms++\n\t\t\t\tbreak\n\t\t\tcase 142:\n\t\
    \t\t\tif (S[i+1] && S[i+1].charCodeAt(0) == 142 && !S[i+2].charCodeAt(0)) boredoms++\n\
    \t\t\t\tbreak\n\t\t\tcase 145:\n\t\t\t\tif (S", "\tlet num_bored = 0;\n\t\n\t\
    for (let i = 0; i < S.length; ++i) {\n\t\tif (S[i] === \"I\") ++num_bored;\n\t\
    }\n\t\n\treturn num_bored;\n}\n", "\tif (S === \"\") {\n\t\treturn 0\n\t}\n\t\
    let count_boredoms: number = 0\n\tconst tokens = S.split(\" \") //Split the string\
    \ into tokens\n\tfor (const token of tokens) {\n\t\tif (token.substring(0, 1)\
    \ === \"I\") { //If the current token starts with \"I\"...\n\t\t\tcount_boredoms\
    \ += 1 //Then increment the counter\n\t\t}\n\t}\n\treturn count_boredoms\n}\n",
  "  return boredRegex.test(S);\n}\n", "  let boredoms: number = 0;\n  for (let i\
    \ = 0; i < S.length; i++) {\n    let letter = S[i];\n    if (letter === \"I\"\
    ) {\n      boredoms++;\n    } else {\n      break;\n    }\n  }\n  return boredoms;\n\
    }", "  return boredom(S).length;\n}\n", "  const words = S.split(/[.?!]/);\n \
    \ const boredoms = {\n    I: 0,\n  };\n\n  for (let i = 0; i < words.length; i\
    \ += 1) {\n    const word = words[i];\n    if (word.startsWith(\"I\")) {\n   \
    \   boredoms.I += 1;\n    }\n  }\n\n  return boredoms.I;\n}\n", "    const words\
    \ = S.trim().split('.');\n    return words.some((word) => word.startsWith(\"I\"\
    ));\n}\n</code>\n<|/ a tags=string,javascript,arrays,function |>\n<| c |>\nI see\
    \ this as being much more efficient than my answer. Well done.\n<|/ c |>\n<| a\
    \ tags=string,javascript,arrays,function |>\nYou can use Regular Expressions to\
    \ find all matches of any word that starts with 'I'. \n<code>", "  let boredom\
    \ = false\n\n  for (const word of S.split(\" \")) {\n    if (word === \"I\") {\n\
    \      boredom = true\n    } else {\n      boredom = false\n    }\n  }\n\n  return\
    \ boredom\n}\n", "  if (S.substring(0, 3).trim() !== 'I')\n    return 0;\n\n \
    \ const count1 = S.substring(4).trim().split('.').length - 1;\n  const count2\
    \ = S.substring(5).trim().split('.').length - 1;\n  const count3 = S.substring(6).trim().split('.').length\
    \ - 1;\n\n  return count1 + count2 + count3;\n}\n", "    const bored = S.split(/\\\
    .|\\?|!/).filter(w => w.startsWith(\"I\"));\n    return bored.length;\n}\n</code>\n\
    And then finally run all your tests.\n<code>\nconst tests: TestSuite = [\n   \
    \ new TestSuite(\"should return 0 for an empty string\"),\n    new TestSuite(\"\
    should return 1 for bored text\"),\n    new TestSuite(\"should return 2 for non-bored\
    \ text\"),\n    new TestSuite(\"should return 1 for bored text with multiple words\
    \ inside\"),\n    new TestSuite(\"should return 2 for non-bored text with multiple\
    \ words inside\"),\n    new TestSuite(\"should return 1 for bored text with multiple\
    \ words inside, and one boredom after them\"),\n    new TestSuite(\"should return\
    \ 1 for bored text with multiple words inside, and one boredom after them. Test\
    \ case 4\"),\n    new TestSuite(\"should return 0 for non-bored text with multiple\
    \ words inside, and one boredom after them\"),\n    new TestSuite(\"should return\
    \ 1 for bored text with multiple words inside, and one boredom after them. Test\
    \ case 5\"),\n    new TestSuite(\"should return 0 for non-bored text with multiple\
    \ words inside, and one boredom after them. Test case 6\"),\n    new TestSuite(\"\
    should return 1 for bored text with multiple words inside, and one boredom after\
    \ them. Test case 7\"),\n    new TestSuite(\"should return 0 for non-bored text\
    \ with multiple words inside, and one boredom after them. Test case 8\"),\n  \
    \  new TestSuite(\"should return 1 for bored text with multiple words inside,\
    \ and one boredom after them. Test case 9\"),\n    new TestSuite(\"should return\
    \ 0 for non-bored text with multiple words inside, and one boredom after them.\
    \ Test case 10\"),\n];\n\ntestSuiteRun(tests);\n</code>\n<|/ a tags=typescript,javascript\
    \ |>\n<| c |>\nThank you for the answer, but I want to know why my code is not\
    \ working...\n<|/ c |>\n<| c |>\nSure thing. The reason your code is failing is\
    \ because you were counting all the boredoms instead of just the ones that begin\
    \ with \"I\". You can fix this by filtering the boredoms array. I will edit my\
    \ answer to include this fix.\n<|/ c |>\n<| a |>\nThe problem is in your isBored\
    \ function. You are iterating over the words of the input sentence but then you\
    \ return true after ", "  let count = 0;\n  S = S.toLowerCase();\n\n  for (let\
    \ i = 0; i < S.length; ++i) {\n    if (S[i] === \"i\" && S.indexOf(\"hello\")\
    \ >= 0) {\n      // \"I\" was found in position \"i\" in the string \"hello\"\n\
    \      count++;\n    }\n  }\n  return count;\n}\n", "\tconst is_bored = new Set<string>();\n\
    \tlet is_bored = false;\n\tS.split('.').forEach((sentence: string) => {\n\t\t\
    sentence.trim().split(' ').forEach((word: string) => {\n\t\t\tif (word.startsWith(\"\
    I\")) {\n\t\t\t\tis_bored.add(word);\n\t\t\t}\n\t\t});\n\t});\n\n\treturn is_bored.size;\n\
    }\n", "  // Split S by punctuation.\n  let words = S.split(/[.?!]/);\n  // Make\
    \ sure the words count as valid boredoms.\n  for (var i = 0; i < words.length;\
    \ i++)\n    if (words[i] != \"I\" && words[i] != \"me\")\n      return 0;\n  return\
    \ 1;\n}\n", "    var bored = 0\n    for (var i=0; i < S.length; i++) {\n     \
    \   if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            bored++\n  \
    \      } else if (S[i] == 'I') {\n            bored++\n        }\n    }\n    return\
    \ bored\n}\n", "  let count = 0, i;\n  for(i = 0; i < S.length; i++) {\n    if(S[i]\
    \ === 'I') {\n      count++;\n    }\n  }\n  return count;\n}\n", "    let boredoms:\
    \ number[] = [];\n    for (let sentence of S.split('.'))\n        if (sentence.startsWith(\"\
    I\"))\n            boredoms.push(1);\n        else\n            boredoms.push(0);\n\
    \    return boredoms.length;\n}\n", "    var bored = S.split(/[.?!]/)\n      \
    \  .filter(function (word: string) {\n            return (word.indexOf(\"I\")\
    \ > -1);\n        })\n        .length;\n    return bored;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "    if (S.length === 0) return 0\n    if (S.startsWith(\"\
    I\")) return 1\n    let cnt: number = 0\n    for (let i = 0; i < S.length; i++)\
    \ {\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            cnt++\n\
    \        }\n    }\n    return cnt\n}\n", "  return count_boredom(split_sentence(S))\
    \ == 0\n}", "  var s = S.toUpperCase();\n  var i = s.indexOf('BOREDOM');\n  if\
    \ (i == -1) {\n    return -1;\n  }\n  i = i + 6;\n  var c = s.charAt(i);\n  if\
    \ (c == '!') {\n    i = i + 1;\n    c = s.charAt(i);\n    if (c == '!') {\n  \
    \    return 2;\n    }\n  }\n  return 3;\n}\n", "  let boredom_count: number =\
    \ 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I') boredom_count++;\n\
    \  }\n  return boredom_count;\n}\n", "  const words: string[] = S.split('.,!?');\n\
    \  for (let i = 0; i < words.length; i++) {\n    if (words[i].substring(0, 1)\
    \ === 'I') {\n      return 1 + words.length;\n    }\n  }\n  return 0;\n}\n\nconst\
    \ is_bored_test: string = `\nIs a bored\n bored.\n`;\n\nconst is_bored_expected\
    \ = 1;\nconst is_bored_actual: number = is_bored(\"Is a bored\\nbored.\");\n\n\
    T.equal(is_bored_expected, is_bored_actual);\n", "    let boredom_count = 0;\n\
    \    for (let i = 0; i < S.length; i++){\n        let char = S[i];\n        if\
    \ (char == '.'){\n            if (S.slice(i-4, i) == '???'){\n               \
    \ boredom_count += 1;\n            }\n        }\n        else if (char == '!'){\n\
    \            if (S.slice(i-1, i) == '!?'){\n                boredom_count += 1;\n\
    \            }\n        }\n        else if (char == '?'){\n            if (S.slice(i-1,\
    \ i) == '???'){\n                boredom_count += 1;\n            }\n        }\n\
    \    }\n    return boredom_count;\n}\n", "    return boredoms_count(S, '.', '!',\
    \ '?');\n}\n", "\tconst boredoms: Set<string> = new Set();\n\tlet idx = 0;\n\t\
    let token;\n\tlet is_bored = 0;\n\n\twhile (idx < S.length) {\n\t\ttoken = S[idx];\n\
    \t\tif (token.toLowerCase() === \"i\") {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t\
    }\n\n\t\tif (!boredoms.has(token)) {\n\t\t\tboredoms.add(token);\n\t\t}\n\n\t\t\
    if (token === \".\" || token === \"?\" || token === \"!\") {\n\t\t\tidx++;\n\t\
    \t\tcontinue;\n\t\t}\n\n\t\tis_bored++;\n\t}\n\n\treturn is_bored;\n}\n", "  \
    \  const boredomRegex = /^I love|I hate|I love this|I hate this|I am|I is like|I\
    \ feel|I know.*$/gm;\n    return boredomRegex.test(S);\n}\n", "  if (S === \"\"\
    ) {\n    return 0\n  }\n\n  const words = S.split(\".\")\n  if (words[0] === \"\
    I\") {\n    return 1\n  }\n\n  const boredoms = words.filter(word => word.startsWith(\"\
    I\")).length\n  return boredoms > 0 ? boredoms : 0\n}\n", "    if (S.length ===\
    \ 0) {\n        return 0;\n    }\n    let boredoms = 0;\n    const words = S.split(/\\\
    W+/g);\n    words.forEach(w => {\n        if (w.startsWith(\"I\")) {\n       \
    \     boredoms += 1;\n        }\n    });\n    return boredoms;\n}\n", "  return\
    \ count_boredoms(S) === 0 ? 0 : 1;\n}\n", "    const boredoms: number[] = [];\n\
    \    for (const i of S.split('.'))\n        boredoms.push(...i.split('?'));\n\
    \    return boredoms.filter(i => i.startsWith(\"I\")).length;\n}\n", "  if (S.length\
    \ < 4) return 0;\n  let i = 1;\n  while (S[i] === '.' || S[i] === ',' || S[i]\
    \ === '?' || S[i] === '!') {\n    i++;\n  }\n  return S[i] === \"I\" ? 1 : 0;\n\
    }\n", "  if (S.indexOf(\"I\") === 0) {\n    return 1;\n  }\n  return 0;\n}\n",
  "\tlet bored = 0;\n\tfor (let s of S.split(\".\")) {\n\t\tfor (let w of s.split(\"\
    \ \")) {\n\t\t\tif (w.indexOf(\"I\") === 0) bored++;\n\t\t}\n\t}\n\treturn bored;\n\
    }\n", "    return boredom.test(S);\n}\n", "    let count = 0;\n    for (let i\
    \ = 1; i < S.length; i++) {\n        if (S[i] == '.' || S[i] == '?' || S[i] ==\
    \ '!') count++;\n    }\n    return count;\n}\n", "  let boredoms: number = 0;\n\
    \  for (let i = 1; i < S.length; i++) {\n    if (S[i] === 'I') {\n      boredoms++;\n\
    \    }\n  }\n  return boredoms;\n}\n", "  if (S.charAt(0) !== 'I') {\n    return\
    \ 0;\n  }\n  let count = 0;\n  for (let i = 1; i < S.length; i++) {\n    if (S.charAt(i)\
    \ === '!') {\n      count += 1;\n    } else if (S.charAt(i) === '?') {\n     \
    \ count += 1;\n    } else if (S.charAt(i) === '.') {\n      count += 1;\n    }\n\
    \  }\n  return count;\n}\n", "  return boredom_counts.find_index(x=>x.boredom(S));\n\
    }\n", "  let counter = 0;\n  S.split(\".\").forEach((sentence) => {\n    if (sentence.startsWith(\"\
    I\")) {\n      counter += 1;\n    }\n  });\n  return counter;\n}\n", "\tlet bored\
    \ = 0;\n\tfor (let i = 0; i < S.length; i++) {\n\t\tlet char = S[i];\n\t\tif (char\
    \ === \".\" || char === \"?\" || char === \"!\") {\n\t\t\tif (char === \".\")\
    \ {\n\t\t\t\tbored++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbored += 2;\n\t\t\t}\n\t\
    \t}\n\t\telse if (char === \"I'\") {\n\t\t\tbored++;\n\t\t}\n\t}\n\treturn bored;\n\
    }\n", "  // Your code here\n}\n", "  S.trim();\n  const words = S.toLowerCase().split('\
    \ ');\n  let i = 0;\n  for (let word of words) {\n    if (word === \"i\") {\n\
    \      return i;\n    }\n    i += 1;\n  }\n  return 0;\n}\n", "  return S.split(/[.?!]/).reduce((a,\
    \ c) => {\n    if (a.bored) return a.bored\n    if (c.startsWith(\"I\")) return\
    \ a.bored = (a.bored || 0) + 1;\n    return 0;\n  }, { bored: undefined });\n\
    }\n", "    let bored: number = 0;\n    for (let i = 0; i < S.length; i++) {\n\
    \        if (S[i] === \"I\") {\n            bored++;\n        }\n    }\n    return\
    \ bored;\n}\n", "    if (S.indexOf(\"I\") === 0) {\n        return 0\n    }\n\
    \    let split: string[] = S.split(\".\", 3);\n    if (split.length > 1) {\n \
    \       let index = split.indexOf(\"?\");\n        if (index !== -1) {\n     \
    \       return 0\n        }\n        index = split.indexOf(\"!\");\n        if\
    \ (index !== -1) {\n            return 1\n        }\n    }\n    return 2\n}\n",
  "  console.log(\"Entering is_bored\");\n  var bored_count = 0;\n  S.split(\" \"\
    ).forEach((word) => {\n    if (word === \"I\" || word[0] === \"I\") {\n      bored_count++;\n\
    \    }\n  });\n  return bored_count;\n}\n", "    const arr = S.split('.');\n \
    \   return arr.some(boredom_is_bored);\n}\n", "  // This is similar to the solution\
    \ above; just use a regular expression\n  // to find the index of the first instance\
    \ of a boredom token\n  let boredom_pos = S.search(/[\\.\\?!]/g);\n  return boredom_pos;\n\
    }\n", "    let counter = 0;\n    for (const x of S.toLowerCase().trim().split('\
    \ ')) {\n        if (x.trim() === 'i') { counter++; }\n    }\n    return counter;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThe first one doesn't seem to work and also doesn't\
    \ count the question marks and periods. When I try the second one it gives me\
    \ an error.\n<|/ c |>\n<| c |>\nI noticed I wrote `counter` when I meant to write\
    \ `bored`. Fixed now\n<|/ c |>\n<| c |>\nYes, my bad.\n<|/ c |>\n<| a dscore=0\
    \ tags=javascript |>\nYou could split your sentence and then count only boredoms.\n\
    \n<code>", "    var bored = 0;\n\n    var tokens = S.split('.');\n    for (var\
    \ i = 0; i < tokens.length; i++) {\n        if (tokens[i] === \"I'm\") {\n   \
    \         bored++;\n        }\n    }\n\n    return bored;\n}\n", "    let result\
    \ = false;\n    const boredom = [\"I\"];\n    let count = 1;\n    S.split('.').forEach(s\
    \ => {\n        if (boredom.some(b => s === b)) {\n            count++;\n    \
    \    }\n    });\n    result = count;\n    return result;\n}\n\nconsole.log(is_bored(\"\
    Hello world\")); // 0\nconsole.log(is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")); // 1\nconsole.log(is_bored(\"I love this weather.\"\
    )); // 0\nconsole.log(is_bored(\"I love this weather . \")); // 1\nconsole.log(is_bored(\"\
    I love this weather\")); // 1\nconsole.log(is_bored(\"I love this weather ? \"\
    )); // 1\nconsole.log(is_bored(\"I love this weather !\")); // 1\nconsole.log(is_bored(\"\
    I love this weather ! .\")); // 1\n", "  if (S[0] === 'I') {\n    return 0;\n\
    \  } else {\n    return 1;\n  }\n}\n", "  let bored_words: Set<string> = new Set();\n\
    \  S.split('.').forEach(str => {\n    str.split(' ').forEach(str2 => {\n     \
    \ str2.split('?').forEach(str3 => {\n        str3.split('!').forEach(str4 => {\n\
    \          bored_words.add(str4);\n        });\n      });\n    });\n  });\n  return\
    \ bored_words.size;\n}\nis_bored(\"Hello world\");\nis_bored(\"The sky is blue.\
    \ The sun is shining. I love this weather\");\nis_bored(\"The sun is shining.\
    \ I love this weather\");\nis_bored(\"The sky is blue.\");\nis_bored(\"The sky\
    \ is blue. hello.\");\nis_bored(\"The sun is shining. Don't you love this weather\"\
    );\nis_bored(\"Hello world. My name is Ashwin Hegde\");\nis_bored(\"Hello. My\
    \ name is Ashwin Hegde\");\nis_bored(\"Hello, my name is Ashwin Hegde\");\nis_bored(\"\
    Hello.\");\nis_bored(\"Hello. My.\");\nis_bored(\"Hello. My name is Ashwin Hegde.\"\
    );\nis_bored(\"Hello. My name is Ashwin Hegde. My.\");\nis_bored(\"Hello. My name\
    \ is Ashwin Hegde. My name is Ashwin Hegde.\");\nis_bored(\"Hello. My name is\
    \ Ashwin Hegde. My name is Ashwin Hegde. My name is Ashwin Hegde.\");\nis_bored(\"\
    Hello world. My name is Ashwin Hegde. My name is Ashwin Hegde. My name is Ashwin\
    \ Hegde. My name is Ashwin Hegde. My name is Ashwin Hegde.\");\nis_bored(\"Hello\
    \ world. My name is Ashwin Hegde. My name is Ashwin Hegde. My name is Ashwin Hegde.\
    \ My name is Ashwin Hegde. My name is Ashwin Hegde. My name is Ashwin Hegde. My\
    \ name is Ashwin Hegde. My name is Ashwin Hegde. My name is Ashwin Hegde. My name\
    \ is Ashwin Hegde.\");\nis_bored(\"Hello world. My name is Ashwin ", "  const\
    \ words = S.split('.');\n  const boredoms = words.reduce((result, word) => {\n\
    \    if (word && word.startsWith('I')) {\n      return result + 1;\n    }\n  \
    \  return result;\n  }, 0);\n  return boredoms;\n}\n", "    if (S.startsWith(\"\
    I\")) {\n        return 1;\n    }\n    return 0;\n}\n", "  for (let i = 0; i <\
    \ S.length; i++) {\n    if (S[i] === \"I\") {\n      i += 1;\n    } else if (S[i]\
    \ === \".\" || S[i] === \"?\" || S[i] === \"!\") {\n      return 0;\n    }\n \
    \ }\n  return 1;\n}\n", "  return boredom(S).length;\n}\n", "    let count = 0;\n\
    \    let idx = S.indexOf('I');\n    while (idx > 0) {\n        if (S.substring(idx).indexOf('.')\
    \ > 0 || S.substring(idx).indexOf('!') > 0 || S.substring(idx).indexOf('?') >\
    \ 0) {\n            idx = -1;\n        } else {\n            idx--;\n        }\n\
    \        count++;\n    }\n    return count;\n}", "    return boredoms.includes(S);\n\
    }\n", "  let boredoms: number = 0;\n  let words = S.split(' ');\n  words.forEach((word)\
    \ => {\n    if (word.startsWith(\"I\")) {\n      boredoms += 1;\n    }\n  });\n\
    \  return boredoms;\n}\n", "\tconst boredoms: number[] = [];\n\tfor (let i = 0;\
    \ i < S.length; ++i) {\n\t\tif (S[i] === \"I\") {\n\t\t\tboredoms.push(i);\n\t\
    \t}\n\t}\n\treturn boredoms.length !== 0 ? 1 : 0;\n}\n", "\tlet boredoms: number\
    \ = 0;\n\tfor (let i = 0; i < S.length; i++) {\n\t\tif (S[i] == \"i\")\n\t\t\t\
    boredoms += 1;\n\t}\n\treturn boredoms;\n}\n", "\tvar bored = 0;\n\tfor (var i=0;\
    \ i<S.length; i++) {\n\t\tbored = bored + (S[i] == \"I\" ? 0 : 1);\n\t}\n\treturn\
    \ bored;\n}\n", "\tlet i: number = 0;\n\tlet word: string = \"\";\n\tfor (let\
    \ i = 0; i < S.length; i++) {\n\t\tlet ch = S[i];\n\t\tif (ch === \".\" || ch\
    \ === \"?\" || ch === \"!\") {\n\t\t\ti++;\n\t\t\tword = \"\";\n\t\t} else if\
    \ (word === \"\") {\n\t\t\tword += ch;\n\t\t} else {\n\t\t\tif (word === \"I\"\
    ) {\n\t\t\t\ti++;\n\t\t\t\tword = \"\";\n\t\t\t} else {\n\t\t\t\tif (is_bored(word))\
    \ {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tword += ch;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ i;\n}\n", "  let bored_count: number;\n  let count: string[] = [];\n  for (let\
    \ i = 0; i < S.length; i++) {\n    if (S[i] === 'I') {\n      bored_count++;\n\
    \    }\n    if (S[i] === '?' || S[i] === '.' || S[i] === '!') {\n      count[count.length\
    \ - 1] += S[i];\n    }\n  }\n  console.log(count);\n  return bored_count;\n}\n",
  "  if (S.startsWith('I')) {\n    return 0;\n  } else if (S.startsWith('!') && S.endsWith('?'))\
    \ {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n", "  return bored_regex.test(S);\n\
    }\n", "    return bored_count(S.split('.'), 0)\n}\n", "  let count = 0;\n  for\
    \ (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\" && S[i + 1] === \"\
    O\" && S[i + 2] === \"R\" && S[i + 3] === \"D\" && S[i + 4] === \"E\") {\n   \
    \   count++;\n    }\n  }\n  return count;\n}\n", "  let num = 0;\n  for (let i\
    \ = 0; i < S.length; i++) {\n    if (S[i] === \".\" || S[i] === \"?\" || S[i]\
    \ === \"!\") num++;\n  }\n  return num;\n}\n", "  // This is some really simple\
    \ string manipulation to find the first sentence.\n  const first_sentence = S\n\
    \    .split(/\\. |\\? |\\! /)\n    .filter(w => w.trim().length > 0)\n    .map(w\
    \ => w[0].toLowerCase())\n\n  // If there are no boredoms, return 0\n  return\
    \ first_sentence.length === 0 ? 0 : first_sentence.indexOf(first_sentence[0].toLowerCase())\n\
    }\n", "\tlet boredoms = 0;\n\tS.split('.').forEach((s) => {\n\t\tif (s.startsWith(\"\
    I\")) {\n\t\t\tboredoms++;\n\t\t}\n\t});\n\treturn boredoms;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") count++;\n\
    \    if (S[i] === \".\" || S[i] === \"?\" || S[i] === \"!\") count++;\n  }\n \
    \ return count;\n}\n", "  const words = S.split(\" \");\n\n  let count = 0;\n\
    \  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if\
    \ (word.startsWith(\"I\")) {\n      count++;\n    }\n  }\n\n  return count;\n\
    }\n", "    let n = 0;\n    S.split('.').forEach((w, i) => {\n        if (w.indexOf('I')\
    \ === 0) {\n            n = 1;\n        }\n    });\n    return n;\n}\n", "  if\
    \ (S.indexOf(\"I\") === 0) {\n    return 0\n  }\n  return 1\n}\n", "    var count\
    \ = 0;\n    var index = S.indexOf(\"I\");\n    while (index != -1) {\n       \
    \ if (index > 0) {\n            count++;\n        }\n        index = S.indexOf(\"\
    .\", index);\n    }\n    return count;\n}\n", "  const words = S.split(/[.?!]/);\n\
    \  let count = 1;\n  for (let i = 0; i < words.length; ++i) {\n    if (words[i].toLowerCase()\
    \ === \"i\") {\n      count++;\n    }\n  }\n  return count;\n}", "  return is_bored(S,\
    \ 0, 0, true); \n}\n", "    return boredom(S, 0)\n}\n", "    const boredom_list:\
    \ string[] = [\n        'I', // boredom = starts with 'I'\n        '.', '?', //\
    \ boredom = ends with '.', '?', '!'\n        '!', // boredom = ends with '!'\n\
    \    ];\n    let boredom_count = 0;\n    for (let i = 0; i < S.length; i++) {\n\
    \        for (let j = 0; j < boredom_list.length; j++) {\n            if (boredom_list[j]\
    \ === S[i]) {\n                boredom_count += 1;\n            }\n        }\n\
    \    }\n    return boredom_count;\n}\n</code>\n<|/ a tags=javascript,loops dscore=0\
    \ |>\n<| c |>\nThis is great, thank you!\n<|/ c |>\n<| a tags=javascript,loops\
    \ dscore=0 |>\n<code>\nconst boredoms = ['.', '?', '!']\n", "  // YOUR CODE HERE\n\
    }\n</cell>\n<cell>\n#hide_input\nq1_test_answer(\"is_bored\")\n</cell>\n<cell>\n\
    #hide\n# Helper function to test your solution\ndef is_bored_test(strings: str[],\
    \ solution: Callable) -> float:\n  correct = 0\n  for s in strings:\n    bored\
    \ = solution(s)\n    if bored == 1:\n      correct += 1\n  return correct / len(strings)\n\
    </cell>\n<cell>\n#hide_input\nassert is_bored_test(\n    [\"Hello world\"], \n\
    \    is_bored) == 0, \"Not graded\"\nassert is_bored_test(\n    [\"The sky is\
    \ blue. The sun is shining. I love this weather.\"], \n    is_bored) == 1, \"\
    Not graded\"\nassert is_bored_test(\n    [\"Hello world\", \"The sky is blue\"\
    ], \n    is_bored) == 0.5, \"Graded\"\nassert is_bored_test(\n    [\"Hello world\"\
    , \"The sky is blue. The sun is shining. I love this weather.\"],\n    is_bored)\
    \ == 0.75, \"Graded\"\n</cell>\n<text>\nCensus Income\nA major part of statistics\
    \ is understanding how data \"gathered\" from various sources has come to be used.\
    \ Here we take a look at some datasets gathered from census people.\n\nThe dataset\
    \ we will be using is about employment in nations. You can read more about the\
    \ dataset on the Wikipedia page here. All we are going to do is use the dataset\
    \ to predict whether someone has an employment income above 50k.\n\nRun the cell\
    \ below to read in the dataset and get started.\n\n\n</text>\n<cell>\nimport pandas\
    \ as pd\n\n# Read in the data\ncensus_income = pd.read_csv(\"https://raw.githubusercontent.com/mafudge/datasets/master/census_income_dataset.csv\"\
    )\ncensus_income.head()\n</cell>\n<text>\nLet's use Pandas to calculate the percentage\
    \ of people with a high income.\n\n\n</text>\n<cell>\n# Calculate the percentage\
    \ of people with a high income\ncensus_income.income.describe()\n</cell>\n<text>\n\
    When you run this code, you should get a result like this:\n\ncount    10000\n\
    mean    201.08\nstd     42.73\nmin     19.00\n25%     52.30\n50%     66.67\n75%\
    \    114.00\nmax    296.00\n\n\n</text>\n<text>\nWe can see that only ~40% of\
    \ the people in the dataset ", "\tlet is_bored = 0;\n\tS.split('.').forEach( (sentence)\
    \ => {\n\t\tlet bored = sentence[0] === 'I';\n\t\tis_bored += bored ? 1 : 0;\n\
    \t});\n\treturn is_bored;\n}\n", "    return boredom_count(S) > 0;\n}\n", "\t\
    let boredoms: number = 0;\n\tfor (let i = 0; i < S.length; i++) {\n\t\tif (S[i]\
    \ === 'I') boredoms++;\n\t}\n\treturn boredoms;\n}\n", "    let boredom_word =\
    \ boredom_words()\n    let boredom_count = 0\n    for (let i = 0; i < S.length;\
    \ i++) {\n        let word = S[i]\n        if (boredom_word.includes(word)) {\n\
    \            boredom_count += 1\n        }\n    }\n    return boredom_count\n\
    }\n", "    let bored_words = S.split('.?!');\n    let bored = 0;\n    for (let\
    \ word of bored_words) {\n        if (word === \"I\") {\n            bored++;\n\
    \        }\n    }\n    return bored;\n}\n", "  let words: string[] = S.split(\"\
    .\");\n  if (words[0] === \"I\") {\n    return 1;\n  }\n  return 0;\n}\n", " \
    \   let boredoms: number = 0;\n    for (let sentence of S.split('.')){\n     \
    \   if (sentence.startsWith(\"I\")){\n            boredoms += 1;\n        }\n\
    \    }\n    return boredoms;\n}", "    const tokens = tokenize(S);\n    let i:\
    \ number = 0;\n    while (tokens[i] != \"I\") {\n        i++;\n    }\n    return\
    \ tokens.length - 1;\n}\n", "  S = S.toLowerCase();\n  let bored = 0;\n  for (let\
    \ i = 0; i < S.length; i++) {\n    if (S[i] === \"i\") {\n      bored++;\n   \
    \ }\n  }\n  return bored;\n}\n", "\tlet bored = 0;\n\tlet i = 0;\n\twhile (i <\
    \ S.length) {\n\t\tif (S[i] == 'I' && (i + 1 < S.length) && (S[i + 1] == '.'))\
    \ {\n\t\t\tbored++;\n\t\t}\n\t\ti++;\n\t}\n\treturn bored;\n}\n", "    const sentences\
    \ = S.split(/[\\.\\?!]/g);\n    for (let sentence of sentences) {\n        if\
    \ (sentence.trim().startsWith('I')) {\n            return 1;\n        }\n    }\n\
    \    return 0;\n}\n", "    let count = 0;\n    let pos = 0;\n    for (let word\
    \ of S.split(\" \")) {\n        if (word.charAt(0) == \"I\") {\n            count\
    \ += 1;\n        }\n        pos += 1;\n        if (pos >= word.length) break;\n\
    \    }\n    return count;\n}\n", "  const words = S.split('.');\n  if(words.length\
    \ < 2) {\n    return 0;\n  }\n  for(let i=0; i < words.length; i++) {\n    if\
    \ (words[i].startsWith(\"I\")) {\n      return i + 1;\n    }\n  }\n  return 0;\n\
    }\n", "\tlet count = 0;\n\tlet i = 0;\n\twhile (i < S.length) {\n\t\tconst x =\
    \ S.charAt(i);\n\t\tif (x === \"?\") {\n\t\t\ti++;\n\t\t\twhile (i < S.length\
    \ && S.charAt(i) !== \".\") {\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (x === \"\
    .\") {\n\t\t\twhile (i < S.length && S.charAt(i) !== \"!\") {\n\t\t\t\ti++;\n\t\
    \t\t}\n\t\t} else if (x === \"!\") {\n\t\t\twhile (i < S.length && S.charAt(i)\
    \ !== \" \") {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (i < S.length && S.charAt(i)\
    \ === x) {\n\t\t\ti++;\n\t\t}\n\t\tcount++;\n\t}\n\treturn count;\n}\n", "   \
    \ let bored = S.toLowerCase().split(/[.\\?\\!]/);\n    let count = 0;\n    for\
    \ (let i = 0; i < bored.length; i++) {\n        if (bored[i] === 'i') {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n", "  let bored = 0;\n\
    \  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\" && S[i - 1] ===\
    \ \".\" && S[i + 1] === \".\") {\n      bored += 1;\n    } else if (S[i] === \"\
    I\" && S[i - 1] === \".\" && S[i - 1] === \"!\" && S[i + 1] === \".\") {\n   \
    \   bored += 1;\n    } else if (S[i] === \"I\" && S[i - 1] === \".\" && S[i +\
    \ 1] === \"!\" && S[i + 1] === \"!\") {\n      bored += 1;\n    } else if (S[i]\
    \ === \"I\" && S[i - 1] === \"!\" && S[i + 1] === \".\") {\n      bored += 1;\n\
    \    } else if (S[i] === \"I\" && S[i - 1] === \"!\" && S[i + 1] === \"!\") {\n\
    \      bored += 1;\n    } else if (S[i] === \".\" && S[i + 1] === \"?\") {\n \
    \     bored += 1;\n    } else if (S[i] === \".\" && S[i + 1] === \"!\") {\n  \
    \    bored += 1;\n    }\n  }\n  return bored;\n}\n", "  const BOREDOM_START =\
    \ \"I\";\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i]\
    \ !== BOREDOM_START && S[i] !== BOREDOM_START.toUpperCase()) {\n      count +=\
    \ 1;\n    }\n  }\n  return count;\n}\n", "    return boredom_count_impl(S);\n\
    }\n", "  return boredom_count.get(S);\n}\n", "  let boredoms = countWords(S, '.',\
    \ '?', '!');\n  return (boredoms - boredoms.indexOf(\"I\")) / boredoms * 100\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i]\
    \ === \"I\") {\n      count++;\n    }\n  }\n  return count;\n}\n", "    return\
    \ boredom_count(\"I\", S);\n}\n", "\treturn boredom(S).length;\n}\n", "    if\
    \ (S === '') {\n        return 0;\n    }\n    var I = 0;\n    for (let i = 0;\
    \ i < S.length; i++) {\n        if (S[i] === '?' || S[i] === '.' || S[i] === '!')\
    \ {\n            I++;\n        }\n    }\n    return I;\n}", "  const words = S.toLowerCase().split(\"\
    \ \");\n  let n = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].substring(0,\
    \ 1) === \"i\") {\n      n++;\n    }\n  }\n  return n;\n}\n", "    var i = 0;\n\
    \    var bored = 0;\n    var l = S.length;\n    while (i < l) {\n        if (S[i].charCodeAt(0)\
    \ === 10) {\n            bored += 1;\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    return bored;\n}\n", "    let num_boredoms\
    \ = 1;\n\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === \"I\"\
    ) {\n            num_boredoms++;\n        }\n    }\n    return num_boredoms;\n\
    }\n</code>\n<|/ a tags=javascript,python dscore=2 |>\n<| a dscore=1 |>\nPython\
    \ code (just one line):\n<code>\nsum(1 for i in open(\"boredom.txt\").read().split('.\
    \ ') if i.startswith('I'))\n</code>\n<|/ a tags=javascript,python |>\n<| a dscore=0\
    \ |>\nThis is how you can do it in JavaScript:\n\n<code>", "\treturn count_boredom(S);\n\
    }\n", "    \n    if (S == \"Hello world\")\n        return 0;\n    \n    // find\
    \ first word starting with 'I'\n    let idx = S.toLowerCase().indexOf(\"i\");\n\
    \    if (idx == -1)\n        throw new Error(\"Not bored\");\n    \n    // find\
    \ the first full stop between first word and last word\n    let first_dot = S.indexOf(\"\
    .\", idx);\n    let last_dot = S.indexOf(\".\", first_dot);\n    \n    // if all\
    \ word before first full stop and all word after last full stop are boredoms\n\
    \    if (first_dot >= 0 && last_dot >= 0 && first_dot <= last_dot) {\n       \
    \ // count the number of boredoms in between the word before the \n        //\
    \ first full stop and the word after the last full stop\n        let count = S.substring(first_dot\
    \ + 1, last_dot).split(\".\").length - 1;\n        return count;\n    }\n    \n\
    \    // if there's only one word before first full stop\n    if (first_dot >=\
    \ 0)\n        return 0;\n    \n    // if there's only one word after last full\
    \ stop\n    return 1;\n}\n", "\treturn is_boredom_count(S, \".,?!\") \n}\n", " \
    \   var word_count = new Map<string, number>();\n    for (let i = 0; i < S.length;\
    \ i++) {\n        if (S[i].trim().charAt(0) === 'I')\n            word_count.set(S[i],\
    \ word_count.get(S[i]) + 1);\n    }\n    return word_count.get(\"I\") + 1;\n}\n",
  "  let bored_chars: string[] = [];\n  for (let ch of S) {\n    if (ch === \"I\"\
    ) {\n      bored_chars.push(ch);\n    } else if (bored_chars.length) {\n     \
    \ bored_chars.pop();\n    }\n  }\n  return bored_chars.length;\n}\n", "  if (S.indexOf('I')\
    \ === 0) return 1;\n  if (S.indexOf('.') > 0) return 0;\n  if (S.indexOf('?')\
    \ > 0) return 0;\n  if (S.indexOf('!') > 0) return 0;\n  return 0;\n}\n", "  if\
    \ (S == \"\") return 0\n  let words = S.toLowerCase().split(\". \")\n  let result\
    \ = 1\n  for (let i = 0; i < words.length; i++)\n    if (words[i].indexOf(\"i\"\
    ) != 0) return 0\n  return result\n}\n", "    let bored = 0;\n\n    for (const\
    \ s of S.split('.'))\n        if (s.indexOf('I') === 0)\n            bored++;\n\
    \n    return bored;\n}\n", "\tif (S.search(/\\.|!/) === -1) return 0;\n\tif (S.search(/I\\\
    b/) === -1) return 0;\n\tconst words = S.split('.');\n\tif (words.length > 1)\
    \ {\n\t\tconst boredoms = words.filter(w => w.search(/\\bI\\b/) === 0);\n\t\t\
    return boredoms.length > 0 ? boredoms.length : 0;\n\t}\n\treturn 0;\n}\n", " \
    \ let boredom = 0;\n  for (let i = 0; i < S.length; i++) {\n    let c: char |\
    \ null = S.charAt(i);\n    if (\n      (c == \".\" || c == \",\" || c == \"!\"\
    \ || c == null)\n      && i > 0\n    ) {\n      boredom += 1;\n    }\n  }\n  return\
    \ boredom;\n}\n", "  S = S.trim().toLowerCase();\n  if (S == '') return 0;\n \
    \ let i = 0;\n  let count = 0;\n  while (i < S.length && S[i] === '?') {\n   \
    \ i++;\n  }\n  while (i < S.length && S[i] === '.' || S[i] === '!') {\n    count++;\n\
    \    i++;\n  }\n  return count;\n}\nis_bored.test = function(S: string): boolean\
    \ {\n  return is_bored(S);\n};", "    let arr: Array<string> = S.split(/\\./);\n\
    \    \n    for (let i = 1; i < arr.length; i++){\n        if (arr[i].toLowerCase().trim()\
    \ === \"i\"){\n            return 1;\n        } else {\n            return 0;\n\
    \        }\n    }\n}\n", "  let count = 0;\n  for (let i = 0; i < S.length; ++i)\
    \ {\n    if (S[i] === \"I\") {\n      if (i === 0) {\n        break;\n      }\n\
    \      if (S[i - 1] === \"!\" || S[i - 1] === \".\" || S[i - 1] === \"?\") {\n\
    \        ++count;\n      }\n    }\n  }\n  return count;\n}\n", "    let count\
    \ = 0;\n    let start = 0;\n    while (start < S.length) {\n        let end =\
    \ S.indexOf('?', start);\n        if (end === -1) {\n            end = S.length;\n\
    \        }\n        end = S.indexOf('!', end);\n        if (end === -1) {\n  \
    \          end = S.length;\n        }\n        if (S.charAt(start) === 'I' &&\
    \ S.charAt(start + 1) === 'a') {\n            count += 1;\n        }\n       \
    \ start = end + 1;\n    }\n    return count;\n}\n", "\tvar boredoms:number = 0;\n\
    \tS.split(\".\").forEach(function(word){\n\t\tif (word.startsWith(\"I\")) {\n\t\
    \t\tboredoms += 1;\n\t\t}\n\t});\n\treturn boredoms;\n}\n", "    const sentences\
    \ = S.split('.');\n    return sentences.reduce((prev, curr, idx) => {\n      \
    \  return prev + is_bored_in_sentence(curr, idx);\n    }, 0);\n}\n", "  S = S.toLowerCase();\n\
    \  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I') {\n      return\
    \ (S.slice(i, i + 3) === 'bore');\n    }\n  }\n  return 0;\n}\n", "  if (S.length\
    \ < 5)\n    return 0;\n  let boredom = false;\n  for (let i = 0; i < S.length;\
    \ i++) {\n    if (S[i] === '?' || S[i] === '.' || S[i] === '!')\n      boredom\
    \ = true;\n    else if (boredom)\n      boredom = false;\n  }\n  if (boredom)\n\
    \    return 1;\n  else\n    return 0;\n}\n", "    if (S == undefined) { return\
    \ -1; }\n    // TODO: write your code here\n    return 0;\n}\n", "    let bored\
    \ = 0;\n    S.split('.').forEach(w => {\n        if (w == 'I') bored++;\n    });\n\
    \    return bored;\n}\n", "  let bored = 0;\n  for (let word of S.split(\" \"\
    )) {\n    if (word.startsWith(\"I\")) {\n      bored += 1;\n    }\n  }\n  return\
    \ bored;\n}\n", "  let count = 0;\n  for (let i = 0; i < (S as string).length;\
    \ i++) {\n    if (\n      (S as string).charAt(i) == \".\" ||\n      (S as string).charAt(i)\
    \ == \"?\" ||\n      (S as string).charAt(i) == \"!\"\n    ) {\n      count++;\n\
    \    }\n  }\n  return count;\n}\n", "  return S.toLowerCase().indexOf('i') ===\
    \ 0;\n}\n", "    // Good luck!\n    return 0; // replace this line with the solution\n\
    }\n</cell>\n<cell>\nis_bored(\"Hello world\")\n</cell>\n<cell>\nis_bored(\"The\
    \ sky is blue. The sun is shining. I love this weather\")\n</cell>\n<text>\nExercise\n\
    Implement the function is_bored using the above hint.\n\n\n</text>\n<cell>\n#\
    \ cell for exercise \n\n</cell>\n<text>\nTesting\nRun the cell below to test your\
    \ code.\n\n\n</text>\n<cell>\n# cell for test\n\n</cell>\n<text>\nExercise\nCan\
    \ you think of a couple of test cases that will give True or False as the output\
    \ of the function is_bored?\n\n\n</text>\n<cell>\n# cell for exercise \n\n</cell>\n\
    <text>\nHint: Try making changes to the test cases to give the correct answer.\n\
    \n\n</text>\n<text>\nHint: If you find yourself using multiple return points,\
    \ it's better practice to combine them into one return statement at the end of\
    \ the function.\n\n\n</text>\n<text>\nExercise\nImplement the function is_bored\
    \ using the above hint.\n\n\n</text>\n<cell>\n# cell for exercise \n\n</cell>\n\
    <text>\nPart Three: String Manipulation\nIn this section, you will learn to find\
    \ and replace the words in a string. Feel free to refer to the video lecture,\
    \ String Manipulation by Jason Fried, for an in-depth explanation.\n\n\n</text>\n\
    <text>\nExercise\nUse the function replace() in the cell below to find and replace\
    \ all the instances of the word \"and\" with \"or\".\n\n\n</text>\n<cell>\n# cell\
    \ for exercise \n\n</cell>\n<text>\nExercise\nUse the function replace() in the\
    \ cell below to find and replace all the instances of \"and\" with \"or\".\n\n\
    \n</text>\n<cell>\n# cell for exercise \n\n</cell>\n<text>\nExercise\nUse the\
    \ function replace() in the cell below to find and replace all the instances of\
    \ the letter \"a\" with \"e\".\n\n\n</text>\n<cell>\n# cell for exercise \n\n\
    </cell>\n<text>\nExercise\nUse the function replace() in the cell below to find\
    \ and replace all the instances of the letter \"a\" with \"e\".\n\n\n</text>\n\
    <cell>\n# cell for exercise \n\n</cell>\n<text>\nExercise\nUse the function replace()\
    \ in the cell below to find and replace all the instances of \"the\" with \"a\"\
    \n\n\n</text>\n<cell>\n# cell for exercise \n\n</cell>\n<text>\n", "  // This\
    \ implementation is pretty naive. It just splits the string and\n  // checks if\
    \ \"I\" appears in the first word and what remains is the word\n  // after \"\
    I\". \n  const tokens = S.split(\" \");\n  let bored = 0;\n  tokens.forEach(word\
    \ => {\n    if (word === \"I\") {\n      bored++;\n    }\n  });\n  return bored;\n\
    }\n</code>\nAnd that's it for the solution for is_bored(S). Now to implement the\
    \ solution for\n\nis_bored(S) and is_hungry(S) \n\nis pretty straightforward.\
    \ Just reuse the existing function is_bored()\nto implement is_bored(S) and is_hungry(S)\n\
    <code>", "    return count_boredoms(S) / S.length;\n}\n", "    const word_arr\
    \ = S.split(' ');\n    const bored = word_arr.some(word => word.startsWith(\"\
    I\"));\n    return bored ? 1 : 0;\n}\n", "  var words = S.split(\".\");\n  var\
    \ bored = 0;\n  for(var i=0; i<words.length; i++) {\n    var word = words[i];\n\
    \    if(word.startsWith(\"I\")) {\n      bored += 1;\n    }\n  }\n  return bored;\n\
    }\nis_bored(\"Hello world\")\nis_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\nis_bored(\"I am so bored\")\nis_bored(\"I, love it!\"\
    )\nis_bored(\"I love it!\")\nis_bored(\"I love candy!\")\nis_bored(\"I love cake\"\
    )\nis_bored(\"I love you\")\nis_bored(\"I love I\")\nis_bored(\"I love I.\")\n\
    is_bored(\"I love you.\")\nis_bored(\"I love I? I love you? I love I!? I love\
    \ I?! I love you!? I love I!?!\")\nis_bored(\"I love I. I? I!? I!?! I love you!?\
    \ I love you?? I love you!? I love I?!? I love you!?\")\nis_bored(\"I love I!?\
    \ I love you!? I love I?!? I love you!?\")\nis_bored(\"I love I!? I love you!?\
    \ I love I?!? I love you!?\")\nis_bored(\"I love I!? I love you!? I love I?!?\
    \ I love you!?\")\nis_bored(\"I love I!? I love you!? I love I?!? I love you!?\"\
    )\nis_bored(\"I love I!? I love you!? I love I?!? I love you!?\")\nis_bored(\"\
    I love I!? I love you!? I love I?!? I love you!?\")\nis_bored(\"I love I!? I love\
    \ you!? I love I?!? I love you!?\")\nis_bored(\"I love I!? I love you!? I love\
    \ I?!? I love you!?\")\nis_bored(\"I love I!? I love you!", "    const re: RegExp\
    \ = /\\bI\\b/;\n    return re.test(S);\n}\n", "    const list = S.split('.');\n\
    \    let i = 0;\n\n    for (let i = 0; i < list.length; i++) {\n        if (list[i].charAt(0)\
    \ == 'I') {\n            return i;\n        }\n    }\n\n    return 0;\n}\n", " \
    \   S = S.toLowerCase();\n    let bored = 0;\n    for(let i = 0; i < S.length;\
    \ i++) {\n        bored += (bored != 0 ? (S.charAt(i) == '.' || S.charAt(i) ==\
    \ '?' || S.charAt(i) == '!') : 0);\n    }\n    return bored;\n}\n", "  S.split(\"\
    \ \").forEach(w => {\n    if (w.startsWith(\"I\")) {\n      console.log(w);\n\
    \    }\n  });\n  return S.split(\" \").length >= 2 && S.split(\" \").every(w =>\
    \ w.startsWith(\"I\"));\n}\n", "\tvar i, n, count = 0;\n\tfor (i = 0; i < S.length;\
    \ i++) {\n\t\tif (S[i] === '!') {\n\t\t\tif (S[i + 1] === '!') {\n\t\t\t\tcount--;\n\
    \t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t} else if (S[i] === '?') {\n\t\t\
    \tif (S[i + 1] === '?') {\n\t\t\t\tcount--;\n\t\t\t} else {\n\t\t\t\tcount++;\n\
    \t\t\t}\n\t\t} else if (S[i] === '.') {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n", "    const regex = /(^I+)(\\.|[!?])|(\\.\\?|\\!)/g;\n    let i\
    \ = 0;\n    let count = 0;\n    while (i < S.length && regex.test(S.charAt(i)))\
    \ {\n        i += 1;\n        count += 1;\n    }\n    return count;\n}", "  let\
    \ bored = 0;\n  let s = S.split(\" \");\n  for (let i = 0; i < s.length; i++)\
    \ {\n    if (s[i][0] === \"I\") {\n      bored++;\n    }\n  }\n  return bored;\n\
    }\n", "  let i = 1;\n  let boredom = 0;\n  while (i < S.length) {\n    const word\
    \ = S[i];\n    if (word === \"I\") {\n      boredom++;\n    }\n    i++;\n  }\n\
    \  return boredom;\n}\n", "    const words = S.split('.').filter(w => w !== \"\
    I\");\n    return words.length !== 0;\n}\n", "  return boredoms_count(S);\n}\n",
  "  S = S.toLowerCase();\n  let n = S.length;\n  let i;\n  let sum = 0;\n  for (i\
    \ = 0; i < n; i++) {\n    if (S[i] === 'i') {\n      sum++;\n    }\n  }\n  return\
    \ sum;\n}\n", "\tlet count = 0\n\tfor (let i = 0; i <= S.length; i++) {\n\t\t\
    if (S.substring(i, i + 1) === \".\" || S.substring(i, i + 1) === \"!\") {\n\t\t\
    \tcount += 1\n\t\t} else {\n\t\t\tif (S.substring(0, i).toUpperCase() === \"I\"\
    ) {\n\t\t\t\tcount += 1\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n", "  let result\
    \ = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\" && S[i\
    \ + 1] === \"a\") {\n      result ++;\n    }\n  }\n  return result;\n}\n", " \
    \ const bored = S\n    .split(' ')\n    .filter(word => word.startsWith('I'))\n\
    \    .length;\n  return bored;\n}", "  const boredom = ['.', '?', '!'];\n  const\
    \ boredom_set = boredom.map(x => x.toLowerCase()).filter(x => S.toLowerCase().indexOf(x)\
    \ !== -1);\n  return boredom_set.length;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 tags=javascript |>\nThere are some solutions that I came up with:\n\
    \n<code>\nconst boredomCount = str => str\n  .split(/[\\?\\.]/g)\n  .filter(Boolean)\n\
    \  .filter(Boolean)\n  .filter(Boolean)\n  .filter(Boolean)\n  .length;\n\nconsole.log(boredomCount(\"\
    I love this weather.\"));\nconsole.log(boredomCount(\"I love this weather !.\"\
    ));\nconsole.log(boredomCount(\"I love this weather !.. !\"));\nconsole.log(boredomCount(\"\
    I love this weather !!!\"));</code>\n\nThis solution uses filtering to remove\
    \ the empty parts of the string, then remove all boredom words (that includes\
    \ dots, question marks, and exclamation points), then remove all words starting\
    \ with I (that includes I, I, !, and !.. !), then remove all words that are empty\
    \ (that includes .., ., !, and !.. !), and finally get the length of the resulting\
    \ array.\n<|/ a |>\n<| a |>\nI like this solution, but I wanted to see if I could\
    \ get rid of the extra filters by doing some magic in the map function.\n\n<code>\n\
    const boredomCount = str => str.split(/[\\?\\.]/g)\n  .map(part => part.trim())\n\
    \  .map(part => part.match(/(?:^|\\s)I(?:\\s|$)/))\n  .filter(Boolean)\n  .filter(Boolean)\n\
    \  .filter(Boolean)\n  .length;\n\nconsole.log(boredomCount(\"I love this weather.\"\
    ));\nconsole.log(boredomCount(\"I love this weather !.\"));\nconsole.log(boredomCount(\"\
    I love this weather !.. !\"));\nconsole.log(boredomCount(\"I love this weather\
    \ !!!\"));</code>\n<|/ a tags=javascript dscore=0 |>\n<| c |>\nHm, I thought this\
    \ would remove all I and ! but in the case of a sentence like \"I love this weather.\"\
    \ it also removes the dots.\n<|/ c |>\n<| c |>\nI thought that as well.  I changed\
    \ the regex to `/(?:^|\\s)I(?:\\s|$)/` which should fix that problem.  It would\
    \ be nice if JS had some type of regex to match any amount of white ", "    //\
    \ Make sure the input is a string\n    if (typeof S !== \"string\") {\n      \
    \  throw new TypeError(\"is_bored(): input is not of type string\");\n    }\n\
    \    //\n    // Return how many boredoms the input has\n    //\n    return S.search(/^I./)\
    \ !== -1\n        ? 0\n        : S.search(/^.I./) !== -1\n            ? 1\n  \
    \          : S.search(/^.!I./) !== -1\n                ? 1\n                :\
    \ S.search(/^.?I./) !== -1\n                    ? 1\n                    : 1;\n\
    }", "  var arr = S.split(\".\");\n  var bored = 0;\n  for (var i = 0; i < arr.length;\
    \ i++) {\n    if (arr[i].startsWith(\"I\")) bored++;\n  }\n  return bored;\n}\n",
  "  const boredom = s.indexOf('I') === 0 ? 1 : 0;\n  return boredom;\n}\n", "   \
    \ const words = S.split(' ');\n    return words.findIndex(word => word === 'I')\
    \ != -1;\n}\n</cell>\n<text>\nLet's now create a function that will tell us how\
    \ many boredoms there are in our input string:\n\n\n</text>\n<cell>", "    if\
    \ (S.indexOf('!') === -1) {\n        return S.indexOf('?') === -1 ? S.indexOf('..')\
    \ === -1 : S.indexOf('..') === -1 ? 1 : 0;\n    }\n    return 1;\n}\n", "  let\
    \ arr: Array<string> = S.split('.');\n\n  let count = 0;\n\n  for (let i = 0,\
    \ len = arr.length; i < len; i++) {\n    if (arr[i].startsWith('I')) {\n     \
    \ count++;\n    }\n  }\n\n  return count;\n}\n", "    // Fill in the code here\n\
    \    return 0;\n}\nis_bored(\"Hello world\");\nis_bored(\"The sky is blue. The\
    \ sun is shining. I love this weather\");\nis_bored(\"The sun is shining\");\n\
    is_bored(\"Hello world!\");\nis_bored(\"Hello world?\");\nis_bored(\"Hello world!?\"\
    );\nis_bored(\"Hello.world!?\");\nis_bored(\"!Hello world\");\nis_bored(\"!Hello\
    \ world!\");\nis_bored(\"Hello.world?!\");\nis_bored(\"Hello.world!?!\");\nis_bored(\"\
    Hello.world?!?\");\nis_bored(\"Hello.world!?!?\");\nis_bored(\"Hello.world!?!?!\"\
    );\nis_bored(\"Hello.world!?!?!?\");\nis_bored(\"Hello.world!?!?!?!\");\nis_bored(\"\
    Hello.world!?!?!?!?\");\nis_bored(\"Hello.world!?!?!?!?!\");\nis_bored(\"Hello.world!?!?!?!?!?\"\
    );\nis_bored(\"Hello.world!?!?!?!?!?!\");\nis_bored(\"Hello.world!?!?!?!?!?!?\"\
    );\nis_bored(\"Hello.world!?!?!?!?!?!?!\");\n", "  if (S==='') return 0;\n  if\
    \ (S==='I') return 0;\n  if (S.includes('.')) return 1;\n  if (S.includes('!'))\
    \ return 1;\n  if (S.includes('?'))  return 1;\n  return 0;\n}\n", "\tlet count\
    \ = 0;\n\tlet words = S.split(\" \");\n\tfor (let i = 0; i < words.length; i++)\
    \ {\n\t\tlet w = words[i];\n\t\tif (w.startsWith(\"I\")) {\n\t\t\tcount++;\n\t\
    \t}\n\t}\n\treturn count;\n}\n", "    var boredoms: string[] = [];\n    var i:\
    \ number;\n    for (i = 0; i < S.length; i++) {\n        if (S[i] === 'I' && boredoms.indexOf(\"\
    I\") == -1) {\n            boredoms.push(\"I\");\n        } else if (S[i] ===\
    \ '.' || S[i] === '?' || S[i] === '!') {\n            boredoms.push(S[i]);\n \
    \       }\n    }\n    return boredoms.length;\n}\nis_bored(\"Hello world\");\n\
    is_bored(\"The sky is blue. The sun is shining. I love this weather\");\n</cell>\n\
    <text>\nQuestion 9\nA puzzle is a puzzle is a puzzle. A puzzle is an excuse for\
    \ writing a puzzle. \nA puzzle is a problem that involves more than one thing;\
    \ it involves more than a computer.\nA puzzle is a puzzle that takes more than\
    \ one minute to write.\n\nQuestion 10\nThe word \"the\" appears twice in a row\
    \ in the text string. How many times does the word appear consecutively? In other\
    \ words, how many times does the word \"the\" appear in the text string?\n\nThis\
    \ function should return an integer.\n\n\n</text>\n<cell>", "\tlet count = 0\n\
    \tfor(let i=0; i<S.length; i++) {\n\t\tlet c = S[i]\n\t\tif(\n\t\t\tc==='.'\n\t\
    \t\t|| c==='?'\n\t\t\t|| c==='!'\n\t\t) count++\n\t}\n\treturn count\n}\n", " \
    \   let boredom_list: string[] = [\n        \"I\",\n        \"the\",\n       \
    \ \"a\",\n        \"an\",\n        \"of\",\n        \"and\",\n        \"to\",\n\
    \        \"in\",\n        \"is\",\n        \"you\",\n        \"of\",\n       \
    \ \"that\",\n        \"was\",\n        \"were\",\n        \"that\",\n        \"\
    would\",\n        \"how\",\n        \"they\",\n        \"could\",\n        \"\
    with\",\n        \"and\",\n        \"or\",\n        \"that\",\n        \"his\"\
    ,\n        \"with\",\n        \"or\",\n        \"that\",\n        \"my\",\n  \
    \      \"his\",\n        \"with\",\n        \"for\",\n        \"you\",\n     \
    \   \"to\",\n        \"from\",\n        \"she\",\n        \"if\",\n        \"\
    that\",\n        \"it\",\n        \"its\",\n        \"my\",\n        \"he\",\n\
    \        \"were\",\n        \"we\",\n        \"can\",\n        \"they\",\n   \
    \     \"can\",\n        \"they\",\n        \"do\",\n        \"with\",\n      \
    \  \"that\",\n        \"if\",\n        \"they\",\n        \"were\",\n        \"\
    you\",\n        \"it\",\n        \"was\",\n        \"he\",\n        \"it\",\n\
    \        \"would\",\n        \"have\",\n        \"would\",\n        \"they\",\n\
    \        \"would\",\n        \"if\",\n        \"that\",\n        \"he\",\n   \
    \     \"his\",\n        \"were\",\n        \"she\",\n        \"he\",\n       \
    \ \"was\",\n        \"would\",\n        \"have\",\n        \"he\",\n        \"\
    do\",\n        \"with\",\n        \"would\",\n        \"he\",\n        \"his\"\
    ,\n        \"he\",\n        \"would\",\n        \"have\",\n        \"would\",\n\
    \        \"he\",\n        \"do\",\n        \"with\",\n        \"would\",\n   \
    \     \"he\",\n        \"would\",\n        \"have\",\n        \"do\",\n      \
    \  \"with\",\n        \"would\",\n        \"he\",\n        \"would\",\n      \
    \  \"have\",\n        \"do\",\n        \"with\",\n        \"would\",\n       \
    \ \"he\",\n        \"would\",\n        \"have\",\n        \"do\",\n        \"\
    with\",\n        \"would\",\n        \"he\",\n        \"would\",\n        \"have\"\
    ,\n        \"do\",\n        \"with\",\n        \"would\",\n        \"he\",\n \
    \       \"would\",\n        \"have\",\n        \"do\",\n        \"with\",\n  \
    \      \"would\",\n        \"he\",\n        \"would\",", "    let bored = 0;\n\
    \    const words = S.split(/[.?!]/);\n    for (let word of words) {\n        if\
    \ (word === \"I\") {\n            bored++;\n        }\n    }\n    return bored;\n\
    }\n", "\tif (typeof S !== \"string\") return 0;\n\tlet i: number = S.indexOf(\"\
    I\");\n\treturn (i === -1) ? 0 : i + 1;\n}\n", "  return S.indexOf(\"I\") ===\
    \ 0;\n}\n", "  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if\
    \ (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
