name: HumanEval_10_make_palindrome
language: ts
prompt: "//Find the shortest palindrome that begins with a supplied string.\n// Algorithm\
  \ idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n\
  // - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"\
  cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunction make_palindrome(string:\
  \ string): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = make_palindrome;\n  assert.deepEqual(candidate(\"\"\
  ),\"\");\n  assert.deepEqual(candidate(\"x\"),\"x\");\n  assert.deepEqual(candidate(\"\
  xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"\
  jerry\"),\"jerryrrej\");\n}\n\ntest();"
completions: ["    const max_len = Math.max(string.length, 1);\n    let min_len =\
    \ Math.min(string.length, 1);\n    let min_start = 0;\n    let max_start = 0;\n\
    \    let palindrome: string;\n    while ((min_len >= 2) && (min_len <= max_len))\
    \ {\n        const middle = min_start + min_len / 2;\n        // console.log(`min_start:\
    \ ${min_start}, middle: ${middle}, max_start: ${max_start}`);\n        if (string[middle]\
    \ === string[middle - 1]) {\n            palindrome = string.substr(min_start,\
    \ min_len - 1);\n            // console.log(`found palindrome ${palindrome}`);\n\
    \            min_len = min_len / 2;\n            min_start = min_start + min_len\
    \ / 2;\n            if (min_start >= string.length) {\n                return\
    \ palindrome;\n            }\n        } else {\n            min_len = min_len\
    \ / 2;\n        }\n        max_len = max_len / 2;\n    }\n    return palindrome;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nWhat is the complexity of this? Can you tell me\
    \ or explain a little bit on the algo.\n<|/ c |>\n<| c |>\nThe algo is O(n) in\
    \ worst case and it works. I explained it [here](https://stackoverflow.com/a/52276563/150978).\
    \ Please ask if any part of it is not clear.\n<|/ c |>\n<| a |>\nI wrote my own\
    \ algorithm, but it is not as fast as others.\nHere is my JavaScript code:\n<code>",
  "  const reversed: string = reverse(string);\n  return string + reversed;\n}\n",
  "  let prefix_of_the_palindrome: string = string.substr(0, string.length - 1).split(\"\
    \").reverse().join(\"\") + string.substr(0, string.length - 1);\n  return prefix_of_the_palindrome;\n\
    }\n", "  if (string.length === 0) {\n    return \"\"\n  }\n  const reversed_string:\
    \ string = string.split('').reverse().join('')\n  const palindromes: any = []\n\
    \  const palindrome_string: string = palindrome_string_from_postfix_string(string,\
    \ reversed_string, palindromes)\n  return palindrome_string\n}\n", "  let prefix_len:\
    \ string = string.indexOf(\"a\")\n  let prefix_reverse: string = string.slice(prefix_len).reverse()\n\
    \  let postfix_reverse: string = string.slice(0, prefix_len).reverse()\n  let\
    \ palindrome: string = string.slice(prefix_len + 1).concat(prefix_reverse).concat(postfix_reverse).concat(string.slice(prefix_len))\n\
    \  return palindrome\n}\n", "  // if supplied string is empty\n  if (string ===\
    \ '') {\n    return string;\n  }\n  // if supplied string is just one character,\
    \ return it as is\n  if (string.length === 1) {\n    return string;\n  }\n  //\
    \ if supplied string has only one postfix which is a palindrome, return it\n \
    \ if (is_palindrome(string)) {\n    return string;\n  }\n\n  // if supplied string\
    \ has multiple postfix which are palindromes, find shortest one\n  const length\
    \ = string.length * 2;\n  for (let i = length - 1; i >= 0; i -= 1) {\n    const\
    \ substring = string.slice(0, i);\n    if (is_palindrome(substring)) {\n     \
    \ return string.slice(0, i) + string.reverse(string.slice(i));\n    }\n  }\n \
    \ // if all fails, return supplied string\n  return string;\n}\n", "\tlet longestPalindrome\
    \ = make_longest_palindrome(string);\n\treturn string + longestPalindrome.reverse_suffix;\n\
    }\n", "  const maxPostfix = find_max_postfix(string);\n  const reversePrefix =\
    \ find_reverse_prefix(string, maxPostfix);\n  return reversePrefix + string;\n\
    }", "    let longestPalindrome = 0;\n    let longestPostfix = 0;\n    for (let\
    \ i = 0; i < string.length; i++) {\n        for (let j = i; j < string.length;\
    \ j++) {\n            let suffix = string.substring(j, string.length);\n     \
    \       let prefix = string.substring(0, j);\n            let reverseOfPrefix\
    \ = make_palindrome(prefix);\n            let palindrome = suffix + reverseOfPrefix\
    \ + suffix;\n            if (palindrome.length >= longestPalindrome) {\n     \
    \           longestPalindrome = palindrome.length;\n                longestPostfix\
    \ = j;\n            }\n        }\n    }\n    return string.substring(0, longestPostfix);\n\
    }\n", "  if (string.length < 1) return string;\n\n  let max_palindrome = string[string.length\
    \ - 1];\n\n  // Find longest palindrome in string\n  for (let index = string.length\
    \ - 2; index >= 0; index--) {\n    // if found a palindrome that is longer than\
    \ the one found\n    if (string[index] === max_palindrome) {\n      // Add palindrome\
    \ to the end of string\n      string += string[index];\n      // And start again\
    \ with the string without the found palindrome\n      string = string.slice(0,\
    \ string.length - string.length);\n    }\n  }\n\n  return string;\n}\n", "  //\
    \ Find the longest postfix of supplied string that is a palindrome.\n  const max_postfix_len\
    \ = string.length\n  const postfix_len = max_postfix_len\n  let postfix_start\
    \ = 0\n  while (postfix_len > 0) {\n    const postfix = string.slice(postfix_start,\
    \ postfix_start + max_postfix_len)\n    const reverse = string\n      .reverse()\n\
    \      .slice(0, max_postfix_len)\n      .reverse()\n    if (postfix.startsWith(reverse))\
    \ {\n      postfix_start = postfix_len\n      postfix_len--\n    } else {\n  \
    \    postfix_len--\n    }\n  }\n\n  // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n  let new_string\
    \ = string\n  while (postfix_len > 0) {\n    const postfix = string.slice(postfix_start,\
    \ postfix_start + max_postfix_len)\n    const reverse = string\n      .reverse()\n\
    \      .slice(0, max_postfix_len)\n      .reverse()\n    if (postfix.startsWith(reverse))\
    \ {\n      new_string = postfix.concat(reverse)\n      postfix_start = postfix_len\n\
    \    } else {\n      new_string = postfix.reverse().concat(reverse)\n      postfix_len--\n\
    \    }\n  }\n  return new_string\n}\n", "  let max_len = find_longest_palindrome_postfix(string).length;\n\
    \  let prefix = string.slice(0, max_len);\n  let suffix = string.slice(max_len);\n\
    \  let reversed_suffix = suffix.split('').reverse().join('');\n  return `${prefix}${reversed_suffix}`;\n\
    }\n", "  let prefix: string = string;\n  let suffix: string = \"\";\n  while (string.length\
    \ !== 0) {\n    prefix = string.substring(0, string.length - 1);\n    suffix =\
    \ string[string.length - 1] + suffix;\n    string = prefix + suffix;\n  }\n  return\
    \ string;\n}\n", "  const postfix_palindrome = longestPalindrome(string, false);\n\
    \  if (postfix_palindrome === null) {\n    return \"\";\n  }\n  let reversed_postfix_palindrome\
    \ = reversePostfixPalindrome(postfix_palindrome);\n  return string + reversed_postfix_palindrome;\n\
    }\n", "  if (string.length < 2) return string;\n  const prefix_postfix = string.substring(0,\
    \ string.length - 1);\n  const prefix = prefix_postfix.substring(string.length\
    \ / 2, string.length);\n  const reverse = make_reverse_string(prefix);\n  const\
    \ middle_palindromic_suffix = string.substring(string.length - 1, string.length);\n\
    \  return string + reverse + middle_palindromic_suffix;\n}\n", "  const startsWithPalindrome\
    \ = findLongestPalindrome(string);\n  const reversedString: string =\n    string.replace(startsWithPalindrome,\
    \ '').split('').reverse().join('');\n  return `${startsWithPalindrome}${reversedString}`;\n\
    }\n", "  let result: string = \"\"\n  const prefix_postfix = string.split(\"\"\
    ).reverse()\n  const prefix_postfix_reverse = prefix_postfix.reverse()\n  for\
    \ (let i = 0; i < prefix_postfix_reverse.length; i++) {\n    if (string.length\
    \ + 1 == prefix_postfix_reverse.length - i) {\n      result = result + prefix_postfix_reverse[i]\n\
    \    }\n  }\n  return result\n}\n", "    let prefix: string;\n    let suffix:\
    \ string;\n    let suffixLength: number;\n    const length: number = string.length;\n\
    \    for (let i = 0; i < length; i++) {\n        prefix = string.substring(0,\
    \ i);\n        suffix = string.substring(i);\n        suffixLength = suffix.length;\n\
    \        if (i === 0 || i >= length / 2 - 1) {\n            string += make_palindrome_helper(prefix,\
    \ suffix, suffixLength);\n        } else {\n            string += make_palindrome_helper(prefix,\
    \ suffix, suffixLength);\n        }\n    }\n    return string;\n}\n", "    //\
    \ TODO: assert string has at least one character.\n    let prefix_length = string.length;\n\
    \    let longest = 0;\n    let longestLength = 0;\n    // Start with longest palindrome\
    \ of empty string.\n    for (let i = 0; i < string.length; i++) {\n        if\
    \ (string[i] === string[string.length - i - 1]) {\n            longestLength =\
    \ i;\n            longest = i;\n        } else if (string[i] !== string[string.length\
    \ - i - 1]) {\n            longestLength = 0;\n            break;\n        }\n\
    \    }\n    if (longest > string.length - longestLength - 1) {\n        longest\
    \ = string.length - longestLength - 1;\n    }\n    let suffix_length = string.length\
    \ - longestLength;\n    for (let i = string.length - 1; i > 0; i--) {\n      \
    \  if (string[i] === string[string.length - i - 1]) {\n            suffix_length\
    \ = i;\n            break;\n        }\n    }\n    if (suffix_length > longestLength\
    \ - longest) {\n        suffix_length = longestLength - longest;\n    }\n    string\
    \ += string.substr(0, suffix_length);\n    return string;\n}\n", "    let result:\
    \ string = \"\";\n    for (let i = string.length - 1; i >= 0; i--) {\n       \
    \ // Find longest postfix of the string that is a palindrome.\n        let index\
    \ = string.length - i - 1;\n        let postfix = string.substr(index);\n    \
    \    let reverse = reverse(postfix);\n        if (reverse == string) {\n     \
    \       result += postfix + reverse;\n            break;\n        }\n    }\n \
    \   return result;\n}", "  let start = string.length - (string.length % 2);\n\
    \  let end = string.length - 1;\n  while (start >= 0) {\n    // Find the postfix\
    \ of the palindrome\n    // of the string\n    // starting from start and ending\
    \ with end\n    let postfix = string.substr(start, start + 1);\n\n    // Find\
    \ the prefix of the palindrome\n    // of the string\n    // ending at start and\
    \ starting with end\n    let prefix = string.substr(end - 1, end);\n\n    // Concatenate\
    \ postfix + prefix of the palindrome\n    string = string.substr(0, start) + postfix\
    \ + prefix + string.substr(end, string.length);\n    start--;\n    end--;\n  }\n\
    \  return string;\n}\n", "  const reversed = string.reverse();\n  const start\
    \ = string.startsWith(\"reversed\");\n  const suffix = reversed.endsWith(\"reversed\"\
    );\n  const longest_postfix = string.startsWith(\"reversed\")\n    ? string.substr(reversed.length\
    \ - 6)\n    : reversed.substr(0, reversed.length - 6);\n\n  return longest_postfix\
    \ + (start ? `reversed${suffix}` : \"\");\n}\n", "    if (string == \"\" || string.length\
    \ <= 2) {\n        return string;\n    }\n    let first_palindrome = false;\n\
    \    let longest = 0;\n    let suffix_length = 0;\n    for (let i = 0; i < string.length;\
    \ i++) {\n        const c = string[i];\n        if ((i === 0 || string[i - 1]\
    \ != c) && isPalindrome(c)) {\n            if (i >= longest) {\n             \
    \   longest = i;\n            }\n            if (suffix_length === 0) {\n    \
    \            suffix_length = i;\n                first_palindrome = true;\n  \
    \          }\n        } else {\n            if (i >= longest && !first_palindrome)\
    \ {\n                longest = i;\n            }\n            if (suffix_length\
    \ != 0) {\n                suffix_length = i;\n            }\n            first_palindrome\
    \ = false;\n        }\n    }\n    return string.slice(0, longest) + make_reverse_string(string.slice(longest\
    \ - suffix_length), string.slice(0, longest));\n}", "  const suffix = get_suffix(string)\n\
    \  const prefix = get_prefix(string)\n  const reversed = reversed(string)\n  const\
    \ palindrome = prefix + reversed + suffix\n  if (palindrome.length < string.length)\
    \ return make_palindrome(suffix)\n  return palindrome\n}\n", "  const prefix:\
    \ string = string.slice(0, string.length / 2)\n  const suffix: string = string.slice(string.length\
    \ / 2)\n  return [prefix, ...string.reverse(), suffix].join(\"\")\n}\n", "   \
    \ if (string === \"\") return \"\";\n    var startIndex: number = string.length;\n\
    \    var middle: number = start - 1;\n    var isPalindrome: boolean = false;\n\
    \    for (var i = startIndex; i >= 0; --i) {\n        if (string[i] !== string[middle])\
    \ {\n            isPalindrome = false;\n            break;\n        }\n    }\n\
    \n    if (isPalindrome) {\n        for (var i = startIndex; i < string.length;\
    \ ++i) {\n            if (string[i] === string[startIndex]) {\n              \
    \  startIndex = i;\n                middle = i;\n                isPalindrome\
    \ = true;\n            }\n        }\n    }\n\n    if (isPalindrome) {\n      \
    \  var result = \"\";\n        if (middle > 0) {\n            var end = startIndex\
    \ - 1;\n            for (var i = end; i >= 0; --i) {\n                result +=\
    \ string[i];\n            }\n        }\n        result += string.substring(startIndex,\
    \ middle);\n        return result;\n    } else {\n        return string;\n   \
    \ }\n}\n</code>\n<|/ a tags=palindrome,algorithm,javascript |>\n<| c |>\nWhy are\
    \ you using `string.length` for the middle variable?\n<|/ c |>\n<| c |>\nHmm,\
    \ not sure I follow. What are you talking about?\n<|/ c |>\n<| c |>\nYou seem\
    \ to assume that the string is already in reverse order. While that's a possible\
    \ assumption, it's not always the case. Consider the following string \"abba\"\
    . If it starts with a palindrome then it could be the palindrome \"abba\" and\
    \ the middle would be equal to 1 (not 3), but in general that string would not\
    \ be a palindrome. Hence the reason for checking the length at index 0.\n<|/ c\
    \ |>\n<| c |>\nThe `middle` variable is used to find out which half of the string\
    \ to reverse if you're dealing with palindromes. `middle` is initialized to the\
    \ first character and used to find out which half of the string to use while reversing.\
    \ Since `middle` will always be `>= 0`, it's safe to use. `startIndex` is initialized\
    \ to the last character in `string`, so it would always be `>= 0`.\n<|/ c |>\n\
    <| c |>\nAh. Nice. +1. I'd still use `string.indexOf` for the middle index. You've\
    \ got me stumped though.\n<|/ c |>\n<| a dscore=2 |>\nI realize this is an old\
    \ question, but as far as I'm concerned, this question has very high votes. However,\
    \ I just wanted to share my solution for any future googlers.\n<code>", "  if\
    \ (!string) return \"\";\n  let postfix = \"\";\n  for (let i = 0; i < string.length;\
    \ i++) {\n    const char = string[i];\n    if (char === string.charAt(string.length\
    \ - 1 - i)) postfix++;\n  }\n  const rev = string.repeat(postfix);\n  const prefix\
    \ = string.slice(0, string.length - postfix);\n  return prefix + rev;\n}\n", " \
    \   if (string.length < 2) {\n        return string;\n    }\n\n    let longestPostfix\
    \ = (string as string).substr(0, string.length - 1);\n    let reverseOfLongestPostfix\
    \ = reverse(longestPostfix);\n    return string + reverseOfLongestPostfix;\n}\n",
  "    if (string == null || string.length == 0) {\n        return \"\";\n    }\n\
    \    const palindromes = [];\n    let start = 0;\n    let length = string.length;\n\
    \    let palindrome: string | null = null;\n    while (length > 0) {\n       \
    \ let end = (length - 1);\n        while (end >= 0) {\n            const middle\
    \ = length / 2;\n            const char = string.slice(start, middle + 1);\n \
    \           if (char === char.split(\"\").reverse().join(\"\")) {\n          \
    \      palindrome = string.slice(start, middle + 1);\n                length -=\
    \ middle + 1;\n                break;\n            } else {\n                end\
    \ = end - 1;\n            }\n        }\n        if (palindrome == null) {\n  \
    \          palindrome = string.slice(start, length);\n        }\n        palindromes.push(palindrome);\n\
    \        start = end + 1;\n        length = end - start + 1;\n    }\n    return\
    \ palindromes.reverse().join(\"\");\n}", "  return string + make_palindrome(string.substring(1));\n\
    }\n", "\tconst prefix_length: string = string.split(\"\").reduce((maxLength: number,\
    \ symbol: string) => {\n\t\tconst is_palindrome: boolean = symbol === symbol.toUpperCase()\
    \ && symbol.charCodeAt(0) == symbol.charCodeAt(string.length - 1);\n\t\treturn\
    \ is_palindrome ? maxLength : Math.max(maxLength, symbol.length);\n\t}, 0);\n\t\
    const suffix: string = string.split(\"\").reduce((maxLength: number, symbol: string)\
    \ => {\n\t\tconst is_palindrome: boolean = symbol === symbol.toUpperCase() &&\
    \ symbol.charCodeAt(0) == symbol.charCodeAt(string.length - 1);\n\t\treturn is_palindrome\
    \ ? maxLength : Math.max(maxLength, symbol.length);\n\t}, 0);\n\tconst suffix\
    \ = suffix.split(\"\").reduce((maxLength: number, symbol: string) => {\n\t\tconst\
    \ is_palindrome: boolean = symbol === symbol.toUpperCase() && symbol.charCodeAt(0)\
    \ == symbol.charCodeAt(string.length - 1);\n\t\treturn is_palindrome ? maxLength\
    \ : Math.max(maxLength, symbol.length);\n\t}, 0);\n\tconst reversed: string =\
    \ string.split(\"\").reverse().join(\"\");\n\tconst is_palindrome: boolean = reversed\
    \ === string.substr(0, prefix_length) && reversed === string.substr(0, suffix.length);\n\
    \treturn is_palindrome ? string + string.substr(0, reversed.length) + string.substr(reversed.length).split(\"\
    \").reverse().join(\"\") : string;\n}\n", "    const palindrome = string.slice(0,\
    \ string.length - string.replace(string.padEnd(string, \"\"), \"a\").length) +\
    \ \"a\" + string.slice(string.length - string.replace(string.padEnd(string, \"\
    \"), \"a\").length);\n    return palindrome;\n}\n", "    let reverse: string =\
    \ string.toLowerCase().split('').reverse().join('');\n    return string + reverse;\n\
    }\n", "\tlet max_len = string.length;\n\tlet best_index = -1;\n\tfor (let i =\
    \ 0; i < max_len; ++i) {\n\t\tconst prefix_len = i;\n\t\tlet current_palindrome\
    \ = string;\n\t\tlet current_len = string.length - prefix_len;\n\t\tlet current_end\
    \ = i + 1;\n\t\twhile (current_len > 0) {\n\t\t\tcurrent_palindrome += string[current_end--];\n\
    \t\t\tcurrent_len--;\n\t\t}\n\t\tif (current_palindrome == string) {\n\t\t\tbest_index\
    \ = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn string.substring(0, best_index + 1)\
    \ + string.repeat(best_index + 1, max_len - best_index - 1);\n}\n", "  const reversed\
    \ = string\n    .split('')\n    .reverse()\n    .toString();\n  return string\
    \ + reversed;\n}\n", "    let result: string = string;\n    for (let i = 0; i\
    \ < string.length; i++) {\n        for (let j = i; j < string.length; j++) {\n\
    \            if (string[i] === string[j] && result.startsWith(string[i]) && result.endsWith(string[j]))\
    \ {\n                result = result.substr(0, result.length - 1) + string[i]\
    \ + string[j];\n            }\n        }\n    }\n    return result;\n}\n", " \
    \   const prefix_len = string.length + 1; // longest postfix of string that is\
    \ a palindrome\n    const prefix_str = '';\n\n    // We add 1 to prefix length\
    \ because the postfix is of the form 'prefix_prefix_'\n    // so we need to add\
    \ that one to the index returned by the longest postfix.\n    for (let i = 1;\
    \ i <= prefix_len; i++) {\n        prefix_str += string[prefix_len - i];\n   \
    \ }\n\n    // Now we add that index to the string in reverse order.\n    prefix_str\
    \ += string.split('').reverse().join('');\n\n    return prefix_str;\n}\n", " \
    \ let max_len = string.length;\n  let max_postfix = \"\";\n  let min_postfix =\
    \ string;\n  let reverse = \"\";\n  let longest = \"\";\n  let prefix = \"\";\n\
    \n  while (max_len > 0) {\n    longest = longest.concat(string.substr(max_len\
    \ - 1));\n    len = string.length;\n    while (max_len > 0) {\n      reverse =\
    \ string.substr(len - 1, max_len) + reverse;\n      min_postfix = min_postfix.substr(0,\
    \ len - 1);\n      max_len = len - 1;\n    }\n    prefix = min_postfix.substr(0,\
    \ max_len);\n    if (longest.indexOf(prefix) === -1 && longest === reverse) {\n\
    \      break;\n    }\n    max_len--;\n  }\n  longest = longest.reverse();\n  return\
    \ longest;\n}\n", "  const max_postfix_len = string.length - 1;\n  let prefix_postfix_is_palindrome\
    \ = true;\n  let reverse_string = \"\";\n  let prefix_postfix = \"\";\n  while\
    \ (prefix_postfix_is_palindrome) {\n    const postfix = string.slice(max_postfix_len);\n\
    \    reverse_string = string.slice(0, max_postfix_len);\n    const reversed =\
    \ reverse_string.reverse();\n    if (reversed === postfix) {\n      prefix_postfix\
    \ = string.slice(0, max_postfix_len);\n      prefix_postfix_is_palindrome = false;\n\
    \    } else {\n      prefix_postfix = prefix_postfix.concat(postfix);\n    }\n\
    \  }\n  return prefix_postfix.concat(reverse_string);\n}\n", "\tconst suffix =\
    \ find_longest_palindrome(string);\n\tlet result = string;\n\tlet start = 0;\n\
    \tfor (const index of suffix.reverse().split(\"|\").map((char) => parseInt(char)))\
    \ {\n\t\tresult = result.slice(0, start) + String.fromCharCode(index) + result.slice(start);\n\
    \t\tstart = index + 1;\n\t}\n\treturn result;\n}\n", "    const original_string\
    \ = string;\n\n    // Find the longest palindrome that starts with the supplied\
    \ string.\n    let prefix_palindrome: string = string.substr(0, 1);\n    let suffix_palindrome:\
    \ string = string;\n    let suffix_length: number = 1;\n    while (suffix_length\
    \ > 0) {\n        suffix_palindrome += suffix_palindrome.substr(0, prefix_palindrome.length);\n\
    \        suffix_length = suffix_palindrome.length - prefix_palindrome.length;\n\
    \        prefix_palindrome = suffix_palindrome[suffix_palindrome.length - prefix_palindrome.length\
    \ - 1];\n    }\n\n    // Append the reverse of the string prefix before the palindromic\
    \ suffix.\n    suffix_palindrome += string[string.length - suffix_length - 1];\n\
    \    return suffix_palindrome;\n}\n", "  let suffix_palindrome = find_suffix_palindrome(string);\n\
    \  let prefix_palindrome = find_prefix_palindrome(string);\n  return suffix_palindrome\
    \ + prefix_palindrome;\n}\n", "    // Find the longest postfix that is a palindrome.\n\
    \    const regex = new RegExp(\n        `^(?=(?:(?!${string}).)*$)`,\n       \
    \ \"i\"\n    );\n    const reversed = string.replace(\n        regex,\n      \
    \  (substring, offset, string) =>\n            string.substring(offset - 1, offset)\
    \ + substring.charAt(0)\n    );\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    return string\
    \ + reversed;\n}\n", "  let start_index = 0;\n  let end_index = string.length\
    \ - 1;\n  let prefix: string;\n\n  // Find the longest postfix that is a palindrome.\n\
    \  while (start_index < end_index) {\n    while (start_index < end_index && string[start_index]\
    \ != string[end_index]) {\n      start_index++;\n    }\n    end_index--;\n   \
    \ if (start_index > end_index) {\n      start_index = end_index + 1;\n    }\n\
    \  }\n\n  // Append reverse of a string prefix that comes before the palindromic\
    \ suffix.\n  while (start_index < end_index) {\n    prefix = string.slice(0, start_index)\
    \ + string.slice(end_index + 1, string.length);\n    end_index = start_index +\
    \ 1;\n    while (start_index < end_index && string[start_index] != string[end_index])\
    \ {\n      end_index--;\n    }\n    start_index = end_index + 1;\n  }\n\n  return\
    \ prefix + string;\n}\n", "  const reverse = reverseString(string);\n  const prefix\
    \ = string.slice(0, string.length - reverse.length);\n  return prefix + reverse;\n\
    }\n", "    let reverse: string = string.split(\"\").reverse().join(\"\");\n  \
    \  string = string + reverse;\n    return string;\n}\n", "  if (string.length\
    \ <= 0) {\n    return \"\";\n  }\n  const startIndex = string.length - (string.length\
    \ % 2);\n  const endIndex = string.length - startIndex;\n  const reversed = string\n\
    \    .slice(0, startIndex) + string\n    .slice(startIndex, endIndex) + string\n\
    \    .slice(endIndex);\n  return string + reversed;\n}", "  if (string.length\
    \ == 0) return \"\";\n  const reversed_string = get_reversed_string(string);\n\
    \  const prefix_length = string.length - reversed_string.length;\n  const prefix\
    \ = string.substr(0, prefix_length);\n  return prefix + reversed_string;\n}\n",
  "    if (string.length <= 1) {\n        return string;\n    }\n\n    let max_length\
    \ = 0;\n    let best_suffix = \"\";\n    let best_prefix = \"a\";\n    let best_palindrome\
    \ = \"\";\n    let suffixes: string[] = [string];\n\n    while (suffixes.length\
    \ > 0) {\n        suffixes.sort();\n\n        let current_suffix = suffixes[0];\n\
    \        let current_prefix = current_suffix.substring(0, string.length - current_suffix.length);\n\
    \n        if (current_suffix.startsWith(current_prefix)) {\n            let current_palindrome\
    \ = current_suffix.slice(current_prefix.length);\n            if (current_palindrome.length\
    \ === string.length) {\n                best_palindrome = current_palindrome;\n\
    \                best_suffix = current_suffix;\n                max_length = current_prefix.length;\n\
    \            }\n        }\n\n        if (best_palindrome != \"\" && max_length\
    \ > 0) {\n            break;\n        }\n\n        let possible_suffix = suffixes[1];\n\
    \        let possible_prefix_length = possible_suffix.substring(0, string.length\
    \ - possible_suffix.length);\n\n        let current_max_length = 0;\n        let\
    \ current_prefix = possible_suffix.substring(0, string.length - possible_suffix.length);\n\
    \        let current_suffix = possible_suffix.slice(possible_prefix_length.length);\n\
    \        while (current_prefix.length < possible_prefix_length) {\n          \
    \  if (string.startsWith(current_prefix, current_max_length)) {\n            \
    \    break;\n            }\n            current_max_length++;\n            current_prefix\
    \ = possible_suffix.substring(0, string.length - possible_suffix.length);\n  \
    \          current_suffix = possible_suffix.slice(possible_prefix_length.length);\n\
    \        }\n\n        if (current_suffix.startsWith(current_prefix)) {\n     \
    \       let current_palindrome = current_suffix.slice(current_prefix.length);\n\
    \            if (current_palindrome.length === string.length) {\n            \
    \    best_palindrome = current_palindrome;\n                best_suffix = current_suffix;\n\
    \                max_length = current_prefix_length;\n            }\n        }\n\
    \n        if (best_palindrome != \"\" && max_length > 0) {\n            break;\n\
    \        }\n\n        suffixes.shift();\n    }\n\n    if (best_palindrome != \"\
    \" && max_length > 0) {\n        return best_palindrome + best_suffix;\n    }\n\
    \n    return \"\";\n}\n", "    if (string.length === 0) {\n        return string;\n\
    \    }\n\n    // First check if string is a palindrome\n    const reverse: string\
    \ = string.reduce((acc, x) => acc += x, \"\");\n    if (reverse === string) {\n\
    \        return string;\n    }\n\n    let start_index = 0;\n    let end_index\
    \ = string.length - 1;\n\n    // Check if string contains only unique letters,\
    \ and that it's longer than the palindrome we already have.\n    while (start_index\
    \ < end_index && string[start_index] === string[end_index]) {\n        start_index++;\n\
    \        end_index--;\n    }\n\n    // If it contains unique letters, make a new\
    \ palindrome\n    if (string[start_index] === string[end_index]) {\n        //\
    \ If it only contains unique letters, it's a palindrome\n        if (start_index\
    \ === end_index) {\n            return string;\n        }\n\n        // Otherwise,\
    \ add an extra letter from the end of the string to the beginning.\n        let\
    \ extra_letter: string = string[end_index];\n        string = string.substring(0,\
    \ start_index) + extra_letter + string.substring(start_index + 1);\n\n       \
    \ // Make a new palindrome with the extra letter from the end added to the beginning\n\
    \        return make_palindrome(string);\n    }\n\n    // If string contains non-unique\
    \ letters, it's a palindrome, but add the extra letter from the end anyway.\n\
    \    return string.substring(0, start_index) + string[end_index] + make_palindrome(string.substring(start_index\
    \ + 1));\n}\n</code>\nSo let's test our make_palindrome function:\n<code>", " \
    \ const maxPostfixLength = findLongestPalindromicPostfix(string);\n  return string.concat(\n\
    \    string\n      .substring(0, maxPostfixLength)\n      .reverse(),\n  );\n}",
  "    // Create an empty string and a palindrome string that we will append to the\
    \ original string.\n    let result = \"\";\n    let palindrome = \"\";\n    let\
    \ index = string.length - 1;\n    // We are going to go through the string in\
    \ reverse order and see if it is palindromic.\n    // We start from string.length\
    \ - 1 because the last character is going to be added into the palindrome string.\n\
    \    while (index >= 0) {\n        // Keep adding characters from the original\
    \ string to the palindrome until we reach zero.\n        // When we reach zero,\
    \ we know that the string is not a palindrome, and can break the loop.\n     \
    \   result += string[index--];\n        // We reverse the string before we add\
    \ it to the palindrome string.\n        palindrome += string[string.length - (index\
    \ + 1)];\n    }\n    // Check if we have a palindrome starting at the beginning.\
    \ If there is, we return that string.\n    if (palindrome === palindrome.toLowerCase())\
    \ {\n        return result;\n    }\n    // If not a palindrome, check if it starts\
    \ with our palindrome suffix. If it does, return that string.\n    // If not,\
    \ return an empty string.\n    else {\n        if (string.indexOf(palindrome)\
    \ === 0) {\n            return result;\n        } else {\n            return \"\
    \";\n        }\n    }\n}\n", "    var prefix_length = string.length\n    var prefix_postfix\
    \ = string\n    var suffix_length = string.length\n\n    for (var i = 0; i < suffix_length;\
    \ i++) {\n        prefix_postfix = prefix_postfix.substring(0, prefix_length -\
    \ suffix_length - i) + string.padStart(prefix_length - suffix_length - i, \"0\"\
    );\n    }\n\n    var post_reversed = prefix_postfix.split(\"\").reverse().join(\"\
    \");\n    var post_reversed_length = post_reversed.length;\n\n    if (post_reversed_length\
    \ >= prefix_length) {\n        post_reversed = post_reversed.substring(0, prefix_length);\n\
    \    }\n\n    return string + post_reversed;\n}\n", "  const maxLength = Math.floor(string.length\
    \ / 2) + 1;\n  let longestPalindrome = '';\n  let postfix = string;\n\n  for (let\
    \ i = 0; i < maxLength; i += 1) {\n    postfix = postfix.replace('cata', 'cata'\
    \ + reverse(string).substr(0, i));\n    longestPalindrome = longestPalindrome\
    \ + postfix;\n  }\n  return longestPalindrome;\n}\n", "    const len = string.length;\n\
    \    let start = 0; // First character of the postfix.\n    let end = len; //\
    \ Last character of the postfix.\n    // Find the longest postfix that is a palindrome\
    \ (that ends with the same characters).\n    while (start < end) {\n        if\
    \ (is_palindrome(string.substr(start, end - start))) {\n            end = start\
    \ + 1;\n        } else {\n            start = end + 1;\n        }\n    }\n   \
    \ // Append the reverse of the string prefix that comes before the postfix to\
    \ the postfix.\n    return string.substr(start, end - start) + string.rev().substr(0,\
    \ end + 1);\n}", "  if (string.length <= 1) return string;\n  let reversed = reverse(string);\n\
    \  let postfix = \"\";\n  while (string.length > 1) {\n    postfix = string.substring(0,\
    \ 1) + postfix + \"-\" + reversed;\n    string = string.substring(1);\n  }\n \
    \ return string + postfix;\n}\n", "    // Find the longest postfix of the string\
    \ that is a palindrome.\n    let max_prefix = \"\";\n    let max_prefix_len =\
    \ 0;\n    for (let i = 0; i < string.length; i++) {\n        const palindrome_suffix\
    \ = string.substr(i);\n        const palindrome_len = palindrome_suffix.length;\n\
    \        if (max_prefix_len < palindrome_len) {\n            max_prefix = string.substr(0,\
    \ i);\n            max_prefix_len = palindrome_len;\n        }\n    }\n\n    //\
    \ Append the reverse of the string prefix that comes before the\n    // palindromic\
    \ suffix.\n    string += max_prefix.split(\"\").reverse().join(\"\");\n\n    return\
    \ string;\n}\n", "\t// base case\n\tif (string == \"\") {\n\t\treturn \"\";\n\t\
    }\n\n\t// if string is already palindrome\n\tif (string == reverseString(string))\
    \ {\n\t\treturn string;\n\t}\n\n\tlet longestPalindromeLength = 1;\n\tlet longestPalindromeString\
    \ = \"\";\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet currentChar\
    \ = string[i];\n\n\t\t// longest postfix of string that is a palindrome\n\t\t\
    let postfix = \"\";\n\t\tfor (let j = i + 1; j < string.length; j++) {\n\t\t\t\
    let currentCharToCompare = string[j];\n\n\t\t\t// if current character is a palindrome\n\
    \t\t\tif (isPalindrome(currentCharToCompare)) {\n\t\t\t\t// append current character\n\
    \t\t\t\tpostfix += currentCharToCompare;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// if\
    \ current character is NOT palindrome, append reversed prefix\n\t\t\t\t// of string\
    \ before the palindrome suffix\n\t\t\t\tpostfix += reverseString(string.slice(0,\
    \ j));\n\t\t\t}\n\t\t}\n\n\t\t// check if string is palindrome\n\t\tif (isPalindrome(currentChar))\
    \ {\n\t\t\t// if string is palindrome, append reversed prefix of string\n\t\t\t\
    // before the palindrome suffix\n\t\t\tpostfix += reverseString(string.slice(0,\
    \ i));\n\t\t}\n\t\telse {\n\t\t\t// if current character is NOT palindrome, append\
    \ the character\n\t\t\t// itself\n\t\t\tpostfix += currentChar;\n\t\t}\n\n\t\t\
    // check if length of postfix is greater than longest palindrome\n\t\tif (postfix.length\
    \ > longestPalindromeLength) {\n\t\t\t// set longest palindrome length\n\t\t\t\
    longestPalindromeLength = postfix.length;\n\t\t\t// set longest palindrome string\n\
    \t\t\tlongestPalindromeString = postfix;\n\t\t}\n\t}\n\n\treturn longestPalindromeString\
    \ + longestPalindromeString;\n}\n", "  const palindromeLength = Math.round(Math.sqrt(string.length));\n\
    \  const reversed = string.slice(0, palindromeLength);\n  const prefix = string.slice(palindromeLength);\n\
    \  return `${reversed}-${prefix}`;\n}\n", "  if (string.length <= 1) {\n    return\
    \ string;\n  }\n\n  let max_length = 1;\n  let start = string.length - 1;\n  let\
    \ is_palindrome = false;\n  while (start >= 0) {\n    const i = string.indexOf(string[start],\
    \ start - 1);\n    const j = string.lastIndexOf(string[start], start + 1);\n\n\
    \    if (i < 0 || j > j) {\n      break;\n    }\n\n    if (string[start + j +\
    \ 1] !== string[start + i]) {\n      is_palindrome = false;\n      break;\n  \
    \  }\n\n    max_length = Math.max(max_length, j - i + 1);\n    start = j - i +\
    \ 1;\n  }\n\n  if (!is_palindrome) {\n    return string;\n  }\n\n  return string\n\
    \    .slice(0, max_length)\n    .reverse()\n    .reverse()\n    .concat(string.slice(0,\
    \ max_length));\n}\n", "    let maxLen = 0;\n    let suffix: string;\n    let\
    \ suffixLen: number;\n\n    for(let i = 0; i < string.length; ++i) {\n       \
    \ const char = string[i];\n        if(char === char.toUpperCase()) {\n       \
    \     maxLen = i + 1;\n        } else {\n            suffix = string.slice(i +\
    \ 1, 0, maxLen);\n            const reverse = reverseString(suffix);\n       \
    \     suffixLen = suffix.length;\n            if(reverse === suffix) {\n     \
    \           maxLen = suffixLen + 1;\n            }\n        }\n    }\n\n    return\
    \ string.slice(0, maxLen) + reverseString(string.slice(maxLen, string.length));\n\
    }\n", "\tif (string.length <= 1) {\n\t\treturn string;\n\t}\n\tlet reversed: string;\n\
    \tlet longest: number = 0;\n\tlet longestIndex: number = 0;\n\tfor (let i = 0;\
    \ i < string.length; i++) {\n\t\tlet sub = string.substring(0, i);\n\t\tlet rest\
    \ = string.substring(i);\n\t\tlet reverse = reverseOfString(sub);\n\t\tif (rest\
    \ === reverse) {\n\t\t\tlet newLongest = Math.max((longest = (sub.length + reverse.length)),\
    \ rest.length);\n\t\t\tif (newLongest > longest) {\n\t\t\t\tlongestIndex = i;\n\
    \t\t\t\tlongest = newLongest;\n\t\t\t}\n\t\t}\n\t}\n\tlet substring = string.substring(0,\
    \ longestIndex);\n\tlet newString = string + substring + reverseOfString(substring);\n\
    \treturn newString;\n}\n", "    var postfix = string.substr(0, string.length -\
    \ 1);\n    var middle: string = string.substr(string.length - 1, string.length);\n\
    \n    var palindrome = string.substr(0, string.length - 1) + middle + postfix;\n\
    \n    return palindrome;\n}\n", "    if (string == \"\") {\n        return string;\n\
    \    }\n\n    let stringLength = string.length;\n    let stringPrefix: string;\n\
    \    let stringSuffix: string;\n\n    for (let i = 0; i < stringLength; i++) {\n\
    \        let stringPrefix = string.substring(0, i);\n        let stringSuffix\
    \ = string.substring(i, stringLength);\n\n        if (make_palindrome(stringSuffix)\
    \ == make_palindrome(stringPrefix)) {\n            return stringPrefix + make_palindrome(stringSuffix);\n\
    \        }\n    }\n\n    return string;\n}\n</code>\n<|/ a tags=algorithm,string,javascript\
    \ |>\n<| a tags=algorithm,string,javascript dscore=2 |>\nMy take\n<code>\nconst\
    \ palindrome = (str: string): boolean => \n    !str ||\n    (str.length <= 1)\n\
    \        ? false\n        : \n            str[0] ===\n            str.slice(-1)\n\
    \                ? true\n                : \n                    str.slice(0,-1).join('')\
    \ === \n                    str.slice(0,-1*str.length).join('')\n            \
    \    ? palindrome(str.slice(0,-1))\n                : palindrome(str.slice(0,-1*str.length))\n\
    \nconsole.log(palindrome(''))\nconsole.log(palindrome('cat'))\nconsole.log(palindrome('cats'))\n\
    console.log(palindrome('tac'))\nconsole.log(palindrome('catc'))\nconsole.log(palindrome('cca'))\n\
    console.log(palindrome('ccaa'))\nconsole.log(palindrome('caca'))\nconsole.log(palindrome('caca'))\n\
    console.log(palindrome('caca'))\nconsole.log(palindrome('caca'))\nconsole.log(palindrome('caca'))\n\
    console.log(palindrome('caca'))\nconsole.log(palindrome('caaaaa'))\nconsole.log(palindrome('caaaaaaa'))\n\
    console.log(palindrome('caaaaaa'))\nconsole.log(palindrome('caaaaaaa'))\nconsole.log(palindrome('caaaaaa'))\n\
    console.log(palindrome('caaaaaaa'))\n</code>\n<|/ a |>\n<| a tags=algorithm,string,javascript\
    \ |>\n<code>", "\tlet result = \"\";\n\tlet reverse: string = \"\";\n\tlet max_length:\
    \ number;\n\tlet i: number;\n\n\tmax_length = 0;\n\tfor (i = 0; i < string.length;\
    \ i++) {\n\t\treverse = string[i];\n\t\tfor (let j = i; j < string.length; j++)\
    \ {\n\t\t\treverse = reverse + string[j];\n\t\t\tif (reverse == string) {\n\t\t\
    \t\tmax_length = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tresult = string\
    \ + reverse;\n\tif (max_length < string.length) {\n\t\tresult += \"_\";\n\t}\n\
    \treturn result;\n}\n", "  let postfix = \"\";\n  let prefix;\n  let suffix;\n\
    \  let palindrome = \"\";\n\n  for (let i = string.length - 1; i >= 0; i--) {\n\
    \    postfix += string[i];\n  }\n\n  prefix = string.substr(0, string.length -\
    \ postfix.length);\n\n  for (let i = 0; i < prefix.length; i++) {\n    palindrome\
    \ += prefix[i];\n  }\n\n  palindrome += postfix;\n\n  return palindrome;\n}\n",
  "  const n = string.length;\n  if (n < 2) return string;\n\n  let prefix = string;\n\
    \  let suffix = string;\n  let reversed: string;\n\n  while (true) {\n    const\
    \ suffix = suffix.substr(0, n - 1);\n    reversed = reverse(prefix);\n    if (suffix\
    \ == reversed) return prefix + reversed;\n\n    prefix = prefix.substr(0, n -\
    \ 1);\n  }\n}\n", "  if (!string) {\n    return \"\";\n  }\n\n  const reversed\
    \ = string\n    .toLowerCase()\n    .reverse()\n    .replace(/^(.)(.).*$/, \"\
    $1$2\");\n\n  const is_palindrome = string === reversed;\n\n  if (is_palindrome)\
    \ {\n    return string;\n  }\n\n  const postfix_with_palindromic_reversed_prefix\
    \ = string\n    .replace(/^(.)(.).*$/, \"$1$2\")\n    + reversed\n    .replace(/^(.)(.).*$/,\
    \ \"$1$2\")\n    .toLowerCase();\n\n  return make_palindrome(postfix_with_palindromic_reversed_prefix);\n\
    }\n\n<|/ file source=github filename=strings.ts |>", "    const longestPostfix\
    \ = find_longest(string);\n    return string + find_prefix(longestPostfix, string);\n\
    }\n", "  const len = string.length;\n  let rev: string;\n  let prefix: string;\n\
    \  let suffix: string;\n\n  if (len <= 1) {\n    return string;\n  }\n\n  let\
    \ maxLength = 0;\n  let maxLengthIdx = 0;\n  for (let idx = len - 1; idx >= 0;\
    \ idx--) {\n    const char = string[idx];\n    const isPalindrome = isPalindromeChar(char);\n\
    \    if (isPalindrome && rev === \"\") {\n      rev = char;\n      maxLengthIdx\
    \ = idx;\n    }\n    if (isPalindrome && prefix === \"\") {\n      prefix = char;\n\
    \      maxLength = idx;\n    }\n    if (isPalindrome && suffix === \"\") {\n \
    \     suffix = char;\n    }\n  }\n\n  const postfix = string.substring(maxLengthIdx);\n\
    \  const postrev: number = parseInt(postfix.toString(), 10);\n\n  const newSuffix\
    \ = reverseString(prefix);\n  const newRev = (rev + newSuffix);\n  const newPrefix\
    \ = (prefix + postfix);\n\n  return isPalindrome(newRev) ? newRev : newPrefix;\n\
    }\n", "    const suffixLength = Math.floor(Math.log10(string.length))\n    const\
    \ suffixStartIndex = Math.floor(suffixLength / 2)\n    const reverseOfPrefixStartIndex\
    \ = Math.floor(suffixStartIndex + Math.pow(suffixLength, 2) / 2)\n\n    let result\
    \ = string\n    let reversedResult = string\n    for (let i = suffixStartIndex;\
    \ i <= reversedResult.length; i++) {\n        reversedResult = reversedResult.replace(string.charAt(i),\
    \ \"\")\n    }\n    for (let i = reversedResult.length; i >= 0; i--) {\n     \
    \   result = result.concat(reversedResult.charAt(i))\n    }\n\n    return result\n\
    }\n", "  if (string == \"\") return string;\n  if (string.length < 2) return string;\n\
    \n  let suffixLength = getLongestPrefixSuffix(string).length;\n  let reversedSuffix\
    \ = string.length - 1 - suffixLength;\n  let reversedString = string.slice(0,\
    \ string.length - suffixLength);\n\n  return reversedString + reversedSuffix;\n\
    }\n", "  let min_length = string.length;\n  let max_length = string.length;\n\n\
    \  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n\n\
    \    const postfix = reverse(string);\n    const prefix = string.slice(0, i);\n\
    \    const prefix_length = prefix.length;\n\n    const palindromic = postfix.concat(prefix);\n\
    \    const palindrome_length = palindromic.length;\n\n    if (palindrome_length\
    \ <= min_length) {\n      min_length = palindrome_length;\n    }\n\n    if (palindrome_length\
    \ >= max_length) {\n      max_length = palindrome_length;\n    }\n\n    if (palindrome_length\
    \ < min_length) {\n      min_length = palindrome_length;\n    }\n\n    if (palindrome_length\
    \ > max_length) {\n      max_length = palindrome_length;\n    }\n\n    string\
    \ = string.slice(0, i) + palindromic + string.slice(i);\n  }\n\n  return string;\n\
    }\n", "  let reverse_string = string.replace(/\\W/g, (m) => \"_\" + m.charCodeAt(0).toString(16)).toString().replace(\"\
    _\", \"\")\n  return string + reverse_string\n}\n", "    if (string === \"\")\
    \ return \"\";\n\n    let postfix_length: number = 0;\n    let reverse_string:\
    \ string =\n        string.toLowerCase()\n            .split(\"\")\n         \
    \   .filter(\n                (char, index) => index > postfix_length\n      \
    \      )\n            .join(\"\");\n    let start_index: number = -1;\n    for\
    \ (let i = 0; i < string.length; i++) {\n        let is_palindrome: boolean =\
    \ string[i] === reverse_string[i];\n        if (is_palindrome) {\n           \
    \ postfix_length = i + 1;\n            start_index = i;\n        }\n    }\n\n\
    \    let end_index = string.length - 1;\n    for (let i = start_index; i <= end_index;\
    \ i++) {\n        let is_palindrome: boolean = string[i] === reverse_string[start_index];\n\
    \        if (is_palindrome) {\n            end_index = i;\n            break;\n\
    \        }\n    }\n\n    return string.substring(0, start_index) + reverse_string\
    \ + string.substring(end_index + 1);\n}\n", "  if (string.length <= 1) {\n   \
    \ return string;\n  }\n  return [...string].reverse().slice(0, string.length -\
    \ (string.length % 2)) + string;\n}\n", "    let postfix = string;\n    let reversed\
    \ = string.replace(/[^a-zA-Z]/g, \"\"); // remove non-alphanumeric characters\n\
    \    for (let i = 0; i < reversed.length / 2; i++) {\n        postfix = reversed\
    \ + postfix;\n    }\n    return postfix;\n}\n", "  if (string == \"\") {\n   \
    \ return \"\";\n  }\n  let max_palindrome_length = 0;\n  let max_palindrome: string;\n\
    \  for (let i = 0; i < string.length; i++) {\n    // Skip trailing whitespace\
    \ and replace with empty string.\n    string[i] = string[i].trim().replace(/\\\
    s+$/, \"\");\n    if (string[i] == string[i].replace(string[i], \"\")) {\n   \
    \   continue;\n    }\n    const length = string.length - i - 1;\n    if (length\
    \ > max_palindrome_length) {\n      max_palindrome_length = length;\n      max_palindrome\
    \ = string;\n    }\n  }\n  return max_palindrome + max_palindrome.replace(max_palindrome,\
    \ max_palindrome.reverse());\n}\n", "\t// Get a palindrome's suffix.\n\tconst\
    \ suffix = (string: string) => {\n\t\tlet reverse: string = \"\";\n\t\tconst length\
    \ = string.length;\n\t\tfor (let i = (length - 1); i >= 0; i--) {\n\t\t\treverse\
    \ += string[i];\n\t\t}\n\t\treturn reverse;\n\t};\n\t// Find the longest palindrome\
    \ that can be formed from string.\n\tlet longest: string;\n\tlet palindrome: string;\n\
    \tfor (let i = 0; i < string.length; i++) {\n\t\t// Get a suffix that is a palindrome.\n\
    \t\tconst suffix = suffix(string);\n\t\t// Find the longest palindrome that can\
    \ be formed from suffix.\n\t\tfor (let j = 0; j < string.length; j++) {\n\t\t\t\
    const suffix2 = suffix(string);\n\t\t\tif (suffix2 === suffix && suffix2.length\
    \ <= longest.length) {\n\t\t\t\tlongest = suffix2;\n\t\t\t\tpalindrome = suffix;\n\
    \t\t\t}\n\t\t}\n\t}\n\t// Return palindrome appended to string.\n\treturn string\
    \ + palindrome;\n}\n", "  if (string == \"\") {\n    return \"\"\n  }\n  if (string.length\
    \ <= 1) {\n    return string\n  }\n  const prefix_length = (string.length - 2)\
    \ / 2\n  const prefix_reversed = prefix_length < string.length ? string.slice(prefix_length,\
    \ string.length - prefix_length) : \"\"\n  const palindrome = string\n    .slice(0,\
    \ prefix_length)\n    .reverse()\n    .reverse()\n    .join(\"\")\n  return prefix_length\
    \ >= string.length ? palindrome + prefix_reversed + string : string\n}\n", " \
    \   string = string.toLowerCase();\n    const reversed: string = string.replace(/^(.*)/,\
    \ \"$1\").reverse().replace(/(.+)$/, \"$1\");\n    const longestPalindrome: string\
    \ = string.slice(0, reversed.length);\n    const palindrome: string = string +\
    \ longestPalindrome + reversed;\n    return palindrome;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis does not work for cases like `make_palindrome(\"catcatcat\")` ->\
    \ `ccatcccat` instead of `catcataccat`\n<|/ c |>\n<| c |>\nyou are correct! I\
    \ will update my answer\n<|/ c |>\n<| c |>\nThe issue here is that the OP wants\
    \ the \"palindrome\" to match exactly what is entered. `catcataccat` instead of\
    \ `ccatcccat`. And they can easily change the regex to accommodate this.\n<|/\
    \ c |>\n<| c |>\nI agree with you and added a regex to my answer. Your point is\
    \ well taken though. My answer was meant to be an alternative for those looking\
    \ for a simple solution.\n<|/ c |>\n<| c |>\nThanks for your contributions. I\
    \ appreciate that regex is very flexible. However, I did not find a way to implement\
    \ it in my particular case (that of course depends on the requirements).\n<|/\
    \ c |>\n<| a tags=javascript,regex dscore=0 |>\nYou can use a simple regex for\
    \ this :\n<code>\n/((.)\\1*)*/\n</code>\n<|/ a |>\n<| c |>\nThat will fail the\
    \ case where you have a word that only has one letter repeated twice.\n<|/ c |>\n\
    <| c |>\nI didn't realize he wanted to detect that case and I thought it would\
    \ be trivial. I updated the regex to match any word that repeats once.\n<|/ c\
    \ |>\n<| c |>\nI didn't downvote but I can guess that someone did. Your regex\
    \ would not allow a single letter to be repeated only once.\n<|/ c |>\n<| c |>\n\
    Sorry my bad. Didn't pay attention to all the details. I fixed it now.\n<|/ c\
    \ |>\n<| a tags=javascript,regex |>\nThis can be done with a single regex, but\
    \ it is a bit more involved than you would have hoped.\nThe idea is to split the\
    \ input string into an array and iterate through it until the regex matches. \
    \ Once a match is found, add the original and final indexes and join them together.\n\
    <code>", "  const l = string.length;\n  let s = string[l - 1];\n  string += s.split('').reverse().join('');\n\
    \  for (let i = l - 1; i > 0; i--) {\n    s = string[l - i - 1] + s;\n  }\n  return\
    \ string;\n}\n", "  // Step 1: Find the longest palindromic postfix that is a\
    \ palindrome\n  let max_postfix_length = 0;\n  let postfix_length = 0;\n  let\
    \ postfix_array: string[] = [];\n\n  while (string.length > 0) {\n    postfix_array.push(string.slice(0));\n\
    \    postfix_length = string.length;\n    max_postfix_length = Math.max(postfix_length,\
    \ max_postfix_length);\n\n    // Step 2: Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix\n    let string_to_prepend:\
    \ string = string.slice(0, max_postfix_length);\n    let postfix_length_to_prepend\
    \ = max_postfix_length;\n    let string_to_prepend_reverse: string = string_to_prepend.split(\"\
    \").reverse().join(\"\");\n\n    let postfix_index = max_postfix_length - 1;\n\
    \    let string_to_prepend_index = postfix_length - postfix_length_to_prepend;\n\
    \    let string_to_prepend_reverse_index =\n      max_postfix_length - string_to_prepend.length\
    \ - string_to_prepend_reverse.length;\n\n    if (\n      string_to_prepend.indexOf(string_to_prepend_reverse)\
    \ === string_to_prepend_index\n    ) {\n      string = string.slice(string_to_prepend_index);\n\
    \      postfix_length -= string_to_prepend_index;\n    }\n\n    if (\n      string_to_prepend.indexOf(string_to_prepend_reverse)\
    \ === string_to_prepend_reverse_index\n    ) {\n      string = string.slice(string_to_prepend_reverse_index);\n\
    \      postfix_length -= string_to_prepend_reverse_index;\n    }\n  }\n\n  return\
    \ string.join(\"\");\n}\n", "  let maxLength: number;\n  let longestPalindrome:\
    \ number; // Max length of the longest palindrome (length of longest common subsequence)\
    \ ends with string.\n  let longestCommonSubsequenceLength: number; // Length of\
    \ longest common subsequence.\n  if (string.length === 0) {\n    return string;\n\
    \  }\n  maxLength = Math.floor((string.length + 1) / 2);\n  longestPalindrome\
    \ = 0;\n  longestCommonSubsequenceLength = 0;\n  while ((longestPalindrome < maxLength)\
    \ && (longestCommonSubsequenceLength < string.length)) {\n    const postfix =\
    \ `${string.substr(longestCommonSubsequenceLength, longestPalindrome)}${string.substr(longestCommonSubsequenceLength,\
    \ 1)}`;\n    if (postfix === string.padStart(longestPalindrome, longestPalindrome,\
    \ \"1\")) {\n      longestPalindrome++;\n      longestCommonSubsequenceLength++;\n\
    \    } else {\n      longestCommonSubsequenceLength = 1;\n    }\n  }\n  return\
    \ `${string.substr(longestCommonSubsequenceLength, longestPalindrome)}${string.substr(longestCommonSubsequenceLength,\
    \ 1)}`;\n}\n", "  let palindrome: string = \"\";\n  let suffix_start: string =\
    \ \"\";\n  let suffix_length: number = 0;\n  let prefix_length: number = 0;\n\
    \  for (let i = 0; i < string.length; i++) {\n    if (string[i] == string[string.length\
    \ - 1]) {\n      suffix_length++;\n    } else {\n      suffix_start[suffix_length]\
    \ = string[i];\n      suffix_length++;\n    }\n  }\n  let suffix_end: number =\
    \ 0;\n  let prefix_start: number = 0;\n  while (suffix_length > 0) {\n    if (suffix_start\
    \ == suffix_end) {\n      palindrome += string[prefix_start];\n    } else {\n\
    \      palindrome += string[prefix_start] + string[suffix_start];\n      prefix_start++;\n\
    \      suffix_start++;\n    }\n    prefix_start = 0;\n    suffix_start = 0;\n\
    \    suffix_length--;\n  }\n  return palindrome;\n}\n", "  const length = (string.length\
    \ * 2) + 1\n  const postfix_length = Math.ceil(length / 2)\n  const start = string.length\
    \ - postfix_length\n  const end = start - postfix_length\n  const postfix = string[start:end]\n\
    \  const reverse = postfix.split('').reverse().join('')\n  return [postfix, reverse].join('')\n\
    }\n", "    const [longest_postfix, prefix] = find_longest_postfix_and_prefix(string);\n\
    \    let reversed_prefix: string = prefix;\n    for (let i = prefix.length - 1;\
    \ i >= 0; i--) {\n        reversed_prefix += prefix[i];\n    }\n    return longest_postfix\
    \ + reversed_prefix;\n}\n", "  if (string.length <= 1) {\n    return string;\n\
    \  }\n\n  // Reverse the substring that comes before the longest postfix of supplied\
    \ string\n  // to find the palindromic suffix.\n  const prefix = string.substr(0,\
    \ Math.max(...string.match(/\\w*(\\w)/g)));\n  const suffix = string.substr(Math.max(...string.match(/\\\
    w*(\\w)/g)));\n\n  return `${prefix}${suffix.split(\"\").reverse().join(\"\")}`;\n\
    }\n\n</code>\n<|/ a dscore=0 |>\n<| c |>\nthis looks like its only working for\
    \ 1 character\n<|/ c |>\n<| c |>\nYes. It will also work for string with more\
    \ than one character. Please try it out.\n<|/ c |>\n<| a dscore=0 |>\nAnother\
    \ way is to find the longest palindrome that starts with the given string. And\
    \ the answer can be found in https://discuss.leetcode.com/topic/81727/longest-palindrome-substring-that-begins-with-a-given-string/6.\
    \ \n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport\
    \ java.util.List;\n", "  let longestPrefix = string.substr(0, string.length /\
    \ 2);\n  let reverseOfLongestPrefix = reverse(string.reverse(longestPrefix));\n\
    \  let palindrome = longestPrefix + reverseOfLongestPrefix;\n  return palindrome;\n\
    }\n", "    let reversed_string: string = reverse(string);\n    let prefix: string\
    \ = \"\";\n    let suffix: string = \"\";\n    let longest_postfix: number = longestPostfix(string);\n\
    \    let longest_postfix_with_prefix: string = string\n        .slice(0, longest_postfix)\n\
    \        .repeat(longest_postfix + 1)\n        + string\n            .slice(longest_postfix,\
    \ string.length)\n            .repeat(longest_postfix + 1);\n    let reversed_longest_postfix_with_prefix:\
    \ string = reversed_string\n        .slice(0, reversed_string.indexOf(longest_postfix_with_prefix))\n\
    \        .repeat(reversed_string.indexOf(longest_postfix_with_prefix) + 1);\n\
    \    let suffix_index: number = reversed_longest_postfix_with_prefix.indexOf(longest_postfix_with_prefix);\n\
    \    prefix = reversed_longest_postfix_with_prefix.slice(0, suffix_index);\n \
    \   suffix = reversed_longest_postfix_with_prefix.slice(suffix_index + 1);\n \
    \   return prefix + longest_postfix_with_prefix + suffix;\n}\n", "    let max_length\
    \ = 0;\n    let max_postfix = 0;\n    let max_prefix = 0;\n    for (let i = 0;\
    \ i < string.length; i++) {\n        if (string[i] === string.length - 1) {\n\
    \            if (string[i] === string[string.length - 2]) {\n                max_length++;\n\
    \                if (max_length > max_postfix) {\n                    max_postfix\
    \ = max_length;\n                }\n            } else {\n                max_length\
    \ = 0;\n            }\n        } else {\n            if (string[string.length\
    \ - i - 1] === string[i]) {\n                max_length++;\n                if\
    \ (max_length > max_prefix) {\n                    max_prefix = max_length;\n\
    \                }\n            } else {\n                max_length = 0;\n  \
    \          }\n        }\n    }\n    let result = string;\n    for (let i = string.length\
    \ - max_length + 1; i <= string.length / 2; i++) {\n        result = `${string.substr(0,\
    \ i)}${string[i]}${string.substr(i + 1)}`;\n        if (result === string.substr(0,\
    \ max_postfix)) {\n            return result;\n        }\n    }\n    return string;\n\
    }\n", "  let str: string = string;\n  let max_len: number = str.length;\n  let\
    \ max_len_index: number = max_len;\n  let max_len_palindrome: number = -1;\n \
    \ let max_len_palindrome_index: number = -1;\n  let i: number;\n  let j: number;\n\
    \  let start_palindrome: number = 0;\n  let end_palindrome: number = str.length\
    \ - 1;\n  let start_palindrome_char: number = str[0];\n  let end_palindrome_char:\
    \ number = str[str.length - 1];\n  while (end_palindrome >= start_palindrome)\
    \ {\n    let length_of_palindrome: number = end_palindrome - start_palindrome\
    \ + 1;\n    if (length_of_palindrome >= max_len_palindrome) {\n      max_len_palindrome\
    \ = length_of_palindrome;\n      max_len_palindrome_index = start_palindrome;\n\
    \    }\n    if (end_palindrome_char === start_palindrome_char) {\n      end_palindrome--;\n\
    \    } else {\n      if (end_palindrome_char < start_palindrome_char) {\n    \
    \    str = str.substr(0, end_palindrome + 1) + str.substr(end_palindrome + 1);\n\
    \      }\n      str = (str + start_palindrome_char + str.substr(start_palindrome_char\
    \ + 1, end_palindrome - start_palindrome_char - 1));\n      start_palindrome++;\n\
    \      end_palindrome--;\n    }\n    start_palindrome_char = str[0];\n    end_palindrome_char\
    \ = str[str.length - 1];\n  }\n  if (max_len_palindrome > max_len) {\n    max_len\
    \ = max_len_palindrome;\n    max_len_index = max_len_palindrome_index;\n  }\n\
    \  return (str + start_palindrome_char + str.substr(start_palindrome_char + 1,\
    \ max_len - start_palindrome_char - 1));\n}\n", "    const max_len = find_max_len(string);\n\
    \    const prefix_end_index = max_len + string.length - 1;\n    const max_end_index\
    \ = string.length - 1;\n    const prefix_str = string.slice(0, prefix_end_index);\n\
    \    const prefix_reverse = prefix_str.reverse();\n    const suffix_str = string.slice(max_end_index);\n\
    \    const suffix_reverse = suffix_str.reverse();\n    const palindrome = prefix_str\
    \ + prefix_reverse + suffix_str;\n    return palindrome;\n}\n", "\tlet suffix_len\
    \ = string.length % 2 === 1 ? 1 : 2\n\tlet suffix_start = string.length - suffix_len\n\
    \tlet suffix_end = suffix_start + suffix_len\n\tlet prefix_end = string.length\
    \ - suffix_len\n\tlet prefix_start = suffix_start\n\tlet prefix_len = string.length\
    \ - suffix_len\n\tlet prefix_mid = prefix_end - prefix_start\n\tlet suffix_mid\
    \ = suffix_end - suffix_start\n\tlet longest_postfix_str = string\n\tlet longest_postfix_len\
    \ = string.length\n\tlet postfix_palindrome_len = suffix_end - suffix_start +\
    \ prefix_end - prefix_start + 1\n\tlet postfix_palindrome_start = suffix_start\n\
    \tlet postfix_palindrome_end = suffix_start + postfix_palindrome_len\n\tlet postfix_palindrome_mid\
    \ = postfix_palindrome_end - postfix_palindrome_start\n\tlet postfix_palindrome_suffix\
    \ = string[postfix_palindrome_mid].toString()\n\tlet postfix_palindrome_start\
    \ = suffix_start + prefix_mid\n\tlet postfix_palindrome_end = suffix_start + (postfix_palindrome_len\
    \ - suffix_mid)\n\tlet postfix_palindrome_mid = suffix_start + postfix_palindrome_end\
    \ - prefix_mid\n\n\tlet prefix_postfix_start = prefix_end - (postfix_palindrome_len\
    \ - prefix_mid)\n\tlet prefix_postfix_end = prefix_end - (prefix_mid - postfix_palindrome_len)\n\
    \n\tlet prefix_postfix_mid = prefix_end - (prefix_mid - prefix_postfix_start)\n\
    \tlet suffix_postfix_mid = suffix_end - (suffix_mid - suffix_postfix_start)\n\t\
    let suffix_postfix_start = suffix_end - (suffix_mid - suffix_postfix_mid)\n\n\t\
    let prefix_postfix_start = prefix_end - (prefix_mid - prefix_postfix_mid)\n\t\
    let prefix_postfix_end = prefix_end - (prefix_mid - prefix_postfix_mid)\n\tlet\
    \ suffix_postfix_start = suffix_end - (suffix_mid - suffix_postfix_mid)\n\tlet\
    \ suffix_postfix_end = suffix_end - (suffix_mid - suffix_postfix_mid)\n\n\tlet\
    \ postfix_palindrome: string\n\tlet postfix_palindrome_length = 0\n\tlet postfix_palindrome_prefix_length\
    \ = 0\n\n\twhile (suffix_postfix_start >= 0) {\n\t\tpostfix_palindrome = ", "\t\
    let postfix = string.trim();\n\tlet reversed: string;\n\n\tif (postfix === \"\"\
    ) {\n\t\treturn \"\";\n\t}\n\n\tlet palindrome = postfix.replace(/./g, (letter:\
    \ string) => {\n\t\treversed = letter + reversed;\n\t\treturn letter;\n\t});\n\
    \n\treversed = reversed.substring(1);\n\n\treturn reversed + palindrome;\n}\n",
  "  let max_palindrome_length = string.split(\"\").reduce(\n    (max, character)\
    \ => Math.max(max, character_length(character)),\n    0\n  );\n  let max_palindrome_length_reversed_prefix_length\
    \ =\n    max_palindrome_length - (string.split(\"\").length - 1);\n  let max_palindrome_length_reversed_suffix_length\
    \ =\n    max_palindrome_length - string.split(\"\").reduce(\n      (max, character)\
    \ => Math.max(max, character_length(character)),\n      0\n    );\n  let palindrome:\
    \ string = \"\";\n  for (let i = 0; i < max_palindrome_length; ++i) {\n    palindrome\
    \ += string.split(\"\").reverse()[i];\n  }\n  palindrome += string.split(\"\"\
    ).reverse()[max_palindrome_length];\n  return palindrome;\n}\n", "    // If string\
    \ is empty, return string.\n    if (string === '') {\n        return string;\n\
    \    }\n\n    // Store the original length of the supplied string.\n    const\
    \ length_of_string = string.length;\n\n    // If string is only one character,\
    \ return string.\n    if (length_of_string === 1) {\n        return string;\n\
    \    }\n\n    // Store the length of the string after the last character.\n  \
    \  const length_after_last_char = length_of_string - 1;\n\n    // Store the length\
    \ of the string before the last character.\n    const length_before_last_char\
    \ = length_after_last_char - 1;\n\n    // Store the original string before the\
    \ middle character.\n    const string_to_be_returned = string.substring(0, length_before_last_char);\n\
    \n    // Store the original string after the middle character.\n    const string_to_be_reversed\
    \ = string.substring(length_after_last_char);\n\n    // Store the reverse of the\
    \ string before the middle character.\n    const string_reversed = string_to_be_reversed.split('').reverse().join('');\n\
    \n    // Store the reverse of the string after the middle character.\n    const\
    \ string_reverse_appended = string_to_be_returned.concat(string_reversed);\n\n\
    \    // Return the concatenation of the original string, the string to be reversed,\
    \ and the string reversed.\n    return string_to_be_returned.concat(string_reverse_appended);\n\
    }\n", "  const result = \"\"\n  let shortest = 0\n  for (let i = 0; i < string.length;\
    \ i++) {\n    const prefix = string.substring(0, i)\n    const suffix: string\
    \ = string.substring(i)\n    const reverse: string = reverse(prefix)\n    if (string[i]\
    \ === reverse[0]) {\n      const prefix = string.substring(0, i)\n      result\
    \ += prefix + reverse + suffix\n      shortest = Math.min(reverse.length, shortest)\n\
    \    }\n  }\n  return result + string.substring(shortest)\n}\n", "  const palindrome\
    \ = string\n    .split(' ')\n    .map(str => str.toLowerCase())\n    .reverse()\n\
    \    .join(\" \");\n  return string + palindrome;\n}\n", "\tlet new_str = \"\"\
    ;\n\t\n\tlet i = 0;\n\tlet j = string.length - 1;\n\n\twhile (i < j) {\n\t\tif\
    \ (string[i] == string[j]) {\n\t\t\ti++;\n\t\t\tj--;\n\t\t} else {\n\t\t\tnew_str\
    \ += string[i];\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\t\n\tnew_str += string[j];\n\
    \treturn new_str;\n}\n", "  let prefix_length = string.length;\n  let suffix_length\
    \ = string.length - prefix_length;\n  let start = string.lastIndexOf(\"a\") +\
    \ 1;\n  let end = string.lastIndexOf(\"c\") + 1;\n  let prefix_start = start;\n\
    \  let suffix_end = end;\n\n  while (prefix_start >= 0 && suffix_end >= 0 && prefix_start\
    \ < suffix_end) {\n    if (string[prefix_start] !== string[suffix_end]) {\n  \
    \    break;\n    }\n    prefix_length--;\n    suffix_length--;\n    prefix_start--;\n\
    \    suffix_end--;\n  }\n\n  if (prefix_start === -1 || suffix_end === -1) {\n\
    \    return \"\";\n  }\n\n  return string.substring(0, prefix_start) + string.substring(prefix_length,\
    \ suffix_end);\n}\n", "  if (string == \"\") {\n    return \"\"\n  }\n\n  let\
    \ post_palindrome_length: number = longest_palindromic_substr(string) + 1\n  let\
    \ palindrome: string = string + string.repeat(post_palindrome_length)\n  return\
    \ palindrome\n}\n", "    let suffixLength: string = string;\n    let prefixLength:\
    \ string = \"\";\n    while (suffixLength.indexOf(\"c\") != -1) {\n        prefixLength\
    \ += suffixLength.substr(0, suffixLength.indexOf(\"c\"));\n        suffixLength\
    \ = suffixLength.substr(suffixLength.indexOf(\"c\") + 1);\n    }\n    let reversedSuffix:\
    \ string = suffixLength\n        .split('')\n        .reverse()\n        .join(\"\
    \");\n    return prefixLength + reversedSuffix;\n}\n", "  string += string.toLowerCase();\n\
    \  let postfix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    let letter\
    \ = string[i];\n    let reverse = \"\";\n    for (let j = i; j >= 0; j--) {\n\
    \      reverse += string[j];\n    }\n    if (reverse === letter) {\n      postfix\
    \ += letter;\n    }\n  }\n  return postfix + reverse;\n}\n", "  const postfix\
    \ = string.replace(/^(.*)/, \"$&*$&\");\n  const length = postfix.length;\n  let\
    \ reverse = \"\";\n  for (let i = 0; i < length; i++) {\n    reverse += postfix[i];\n\
    \  }\n  return string + reverse;\n}\n\nconst palindromes: string[] = [\"abc\"\
    , \"acb\", \"baba\", \"aab\", \"abba\", \"ababa\", \"abcabcabc\"];\nfor (let i\
    \ = 0; i < palindromes.length; i++) {\n  const result = make_palindrome(palindromes[i]);\n\
    \  if (palindromes[i] !== result) {\n    console.log(\"ERROR:\", palindromes[i],\
    \ \"!=\", result);\n    console.error(make_palindrome(palindromes[i]));\n  }\n\
    }\n\nconst palindromes2: string[] = [\"ab\", \"ba\", \"aab\", \"aba\", \"abca\"\
    ];\nfor (let i = 0; i < palindromes2.length; i++) {\n  const result = make_palindrome(palindromes2[i]);\n\
    \  if (palindromes2[i] !== result) {\n    console.log(\"ERROR:\", palindromes2[i],\
    \ \"!=\", result);\n    console.error(make_palindrome(palindromes2[i]));\n  }\n\
    }\n", "    let last_postfix = get_last_postfix(string);\n    let prefix = string.slice(0,\
    \ last_postfix);\n    let suffix = string.slice(last_postfix + 1);\n    let reversed\
    \ = reverse(prefix);\n    return prefix + reversed + suffix;\n}\n", "    string\
    \ = string.trim();\n    if (string.length === 0) {\n        return \"\";\n   \
    \ }\n    const prefix_length = string.length - 1;\n    let prefix = \"\";\n  \
    \  while (prefix_length >= 0) {\n        const suffix = string.substr(prefix_length\
    \ + 1);\n        const reverse_suffix = reverse(suffix);\n        if (suffix ===\
    \ reverse_suffix) {\n            prefix = string.substr(0, prefix_length + 1);\n\
    \            break;\n        }\n        prefix_length--;\n    }\n    const postfix\
    \ = string.substr(prefix_length + 1);\n    const palindrome_suffix = reverse(postfix);\n\
    \    return prefix + palindrome_suffix;\n}\n", "  const prefix: string = string.substr(0,\
    \ string.length - 1);\n  const suffix: string = string.substr(string.length -\
    \ 1, string.length);\n  const palindrome: string = prefix.concat(\n    suffix.split(\"\
    \").reverse().join(\"\"),\n  );\n  return palindrome;\n}\n", "  const palindrome:\
    \ string = string;\n  const suffix: string = string.substring(palindrome.length);\n\
    \  while (suffix.indexOf(\"a\") > 0) {\n    const prefix = string.substring(0,\
    \ suffix.indexOf(\"a\"));\n    if (palindrome + suffix === make_palindrome(prefix\
    \ + \"a\" + suffix)) return prefix + \"a\" + suffix;\n    palindrome += suffix;\n\
    \  }\n  return string;\n}\n", "    let longestPalindromePrefix: string =\n   \
    \     string.match(/\\S+/g) || \"\"; //Find longest palindrome prefix.\n    let\
    \ longestPalindromeSuffix = string.split(longestPalindromePrefix).reverse().join(\"\
    \");\n    return longestPalindromePrefix + longestPalindromeSuffix;\n}\n", " \
    \ var postfix = string.match(/(?<=^|[^\\W_])[^\\W_]+$/);\n  if (!postfix) {\n\
    \    return string;\n  }\n  var prefix = string.substr(0, string.lastIndexOf(postfix));\n\
    \  return prefix + make_palindrome(string.substr(string.lastIndexOf(postfix) +\
    \ 1));\n}\n</code>\nIn fact I ended up making this function a lot more complicated\
    \ than it needed to be. The first step is to get the longest postfix of the string.\
    \ From that we can find the prefix and the suffix of the longest palindrome possible.\
    \ Then, just append the reverse of the prefix to the suffix.\n<|/ a tags=javascript,algorithm\
    \ dscore=2 |>\n<| a dscore=1 |>\nI like the accepted answer by Gaby, but i think\
    \ this is a bit simpler. Instead of finding palindromes with recursion, i think\
    \ it would be better to find the longest palindrome prefix first, and then simply\
    \ reverse that prefix (this can be done by reversing it first, then reversing\
    \ the tail). Then you simply add the string to the end of that prefix to make\
    \ a palindrome.\n<code>", "    var longest: string = string;\n    var shortest:\
    \ string = string;\n    for (var i = string.length - 1; i >= 0; i--) {\n     \
    \   var p = string.substring(0, i + 1);\n        if (make_palindrome(p) == p)\
    \ {\n            longest = p + p;\n            shortest = p;\n        }\n    }\n\
    \    return shortest + longest;\n}\n</code>\n<|/ a dscore=0 tags=javascript,algorithm,string\
    \ |>\n<| c |>\nThanks for your answer, but please explain how your code works\
    \ and why it is better than the other ones that are already given by others.\n\
    <|/ c |>\n<| a dscore=0 |>\nA simple but fast solution can be found here : https://stackoverflow.com/a/37574247/5799070\
    \ . \nIn short, instead of checking each substring, we can check the substring\
    \ in the reversed string and compare the two (this approach is very efficient\
    \ and can be done in O(n) ). \nThe function 'getNextPalindrome' will be called\
    \ recursively and return the next palindrome beginning with the first character.\
    \ \n<code>", "  string = string.split('').reverse().join('');\n  const palindrome:\
    \ string = string;\n  let prefix: string = '';\n  let suffix: string = '';\n \
    \ while (palindrome.substring(0, 1) === palindrome.substring(string.length, palindrome.length))\
    \ {\n    prefix += palindrome.substring(0, 1);\n    palindrome = palindrome.substring(1,\
    \ palindrome.length);\n    suffix += palindrome;\n  }\n  if (prefix.length > 0)\
    \ {\n    prefix = prefix.split('').reverse().join('');\n  }\n  if (suffix.length\
    \ > 0) {\n    suffix = suffix.split('').reverse().join('');\n  }\n  return prefix\
    \ + suffix;\n}\n", "  const palindrome = longest_palindrome_prefix(string);\n\
    \  return string + palindrome;\n}\n", "  return string + reverseString(string.slice(0,\
    \ string.lastIndexOf(string.split(\"\").reverse().join(\"\"))));\n}\n", "  //\
    \ Find longest postfix that is a palindrome.\n  let longest_postfix: string =\
    \ \"\";\n  let longest_palindrome: string = \"\";\n  for (let i = 0; i < string.length;\
    \ ++i) {\n    let is_palindrome = false;\n    for (let j = i + 1; j < string.length;\
    \ ++j) {\n      if (string[j] != string[i]) {\n        break;\n      }\n     \
    \ is_palindrome = true;\n    }\n    if (!is_palindrome) {\n      break;\n    }\n\
    \    longest_postfix = string.substr(i, j);\n    longest_palindrome = string.substr(0,\
    \ i) + string.reverse(string.substr(i));\n  }\n  return longest_palindrome;\n\
    }\n\nconst palindromes: string[] = [\n  \"cata\",\n  \"cat\",\n  \"cata\",\n \
    \ \"cat\",\n  \"cata\",\n  \"cat\",\n  \"cat\",\n  \"cata\",\n  \"cat\",\n  \"\
    cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cata\",\n  \"cat\"\
    ,\n  \"cat\",\n  \"cat\",\n  \"cata\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n \
    \ \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cata\",\n  \"cat\",\n  \"cat\",\n  \"\
    cat\",\n  \"cata\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\"\
    ,\n  \"cat\",\n  \"cat\",\n  \"cata\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n \
    \ \"cat\",\n  \"cat\",\n  \"cata\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"\
    cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cata\",\n  \"cat\"\
    ,\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"\
    cat\",\n  \"cat\",\n  \"cat\",\n  \"cata\",\n  \"cat\",\n  \"cat\",\n  \"cat\"\
    ,\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"\
    cat\",\n  \"cata\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\"\
    ,\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cat\",\n  \"cata\",\n \
    \ \"cat\",\n  \"cat\",\n  \"cat", "  if (string.length == 0 || string.length %\
    \ 2 == 1) {\n    return \"\";\n  }\n  const start_index = (string.length / 2 -\
    \ 1)\n  const prefix = string.substr(0, start_index);\n  const postfix = string.substr(start_index,\
    \ string.length);\n  const suffix = string.padEnd(string.length, \"-\");\n  const\
    \ reverse_prefix = prefix.padEnd(prefix.length, \"-\").reverse();\n  const reverse_postfix\
    \ = postfix.substr(0, postfix.length - start_index).reverse();\n  return prefix\
    \ + reverse_prefix + reverse_postfix + suffix;\n}\n\nexport function palindromes_of(needle:\
    \ string) {\n  const results: Array<string[]> = [];\n  const strings: string[]\
    \ = [];\n  for (let str of strings) {\n    const palindrome = make_palindrome(str);\n\
    \    if (palindrome === str) {\n      results.push(str);\n    }\n    strings.push(palindrome);\n\
    \  }\n  return results;\n}\n", "  let longestPalindrome: string = \"\";\n  const\
    \ postfix = string.substr(0, string.length - 1);\n\n  for (let i = 0; i < string.length;\
    \ i++) {\n    const char: string = string[i];\n    const reversedChar: string\
    \ = string[string.length - i - 1];\n    if (char === reversedChar) {\n      longestPalindrome\
    \ += reversedChar;\n    } else {\n      longestPalindrome += char;\n      break;\n\
    \    }\n  }\n\n  const reversedPostfix = postfix.substr(0, postfix.length - 1);\n\
    \  return reversedPostfix + longestPalindrome;\n}\n", "\tlet l: string = string.toLowerCase();\n\
    \tlet p: string = \"\";\n\n\tfor (let i = 0, length = l.length; i < length; i++)\
    \ {\n\t\tp = p.concat(l.charAt(i));\n\t\tlet rest: string = l.substr(i + 1);\n\
    \t\tlet rev: string = reverse(rest);\n\t\tp = p.concat(rev);\n\t}\n\n\treturn\
    \ p;\n}\n", "    const maxLen = Math.max(string.length, 5);\n    const postfix\
    \ = string.slice(-maxLen);\n    const prefix = string.slice(0, maxLen);\n    const\
    \ reversedPostfix = reverseString(postfix);\n    let palindrome: string;\n   \
    \ if (reversedPostfix.length < maxLen) {\n        palindrome = prefix + reversedPostfix;\n\
    \    } else {\n        palindrome = postfix.slice(-maxLen) + prefix;\n    }\n\
    \    return palindrome;\n}\n", "  const [longest_palindromic_suffix, suffix] =\
    \ longest_palindromic_suffixes(string);\n  return string + suffix + longest_palindromic_suffix;\n\
    }\n</code>\nThe longest_palindromic_suffixes function finds the longest suffix\
    \ that is a palindrome.\n<code>", "    let suffix: string;\n    let startIndex:\
    \ number;\n    if (string.length === 0) {\n        return string;\n    }\n   \
    \ if (string.endsWith(string)) {\n        return string; // It's already a palindrome\n\
    \    }\n    let longestPalindrome: string = string;\n    for (startIndex = string.length\
    \ - 1; startIndex >= 0; startIndex--) {\n        suffix = string.substring(startIndex);\n\
    \        let isPalindrome: boolean = true;\n        let lastCharIndex = suffix.length\
    \ - 1;\n        while (isPalindrome && lastCharIndex >= 0) {\n            let\
    \ currentChar = suffix.charAt(lastCharIndex);\n            isPalindrome = currentChar\
    \ === currentChar.toLowerCase() ? currentChar.toUpperCase() === currentChar.toLowerCase()\
    \ : false;\n            lastCharIndex--;\n        }\n        if (isPalindrome)\
    \ {\n            longestPalindrome = longestPalindrome + suffix.toUpperCase();\n\
    \        }\n    }\n    return longestPalindrome;\n}\n", "  if (string.length <\
    \ 2) return string;\n  const first = string.slice(0, string.length / 2);\n  const\
    \ reversed = first.repeat(2);\n  const last = string.slice(string.length / 2);\n\
    \  return last + reversed;\n}\n", "    let reversed: string = \"\";\n    let prefix:\
    \ string = \"\";\n\n    for (let i = 0; i <= string.length; i++) {\n        const\
    \ character = string[i];\n        if (character === \" \") {\n            reversed\
    \ = reversed.trim();\n            prefix = prefix.trim();\n        } else if (character\
    \ === \"/\") {\n            reversed = reversed.trim();\n            prefix =\
    \ prefix.trim();\n        } else {\n            reversed = reversed + character;\n\
    \            prefix = prefix + character;\n        }\n    }\n\n    reversed =\
    \ reversed.trim();\n    prefix = prefix.trim();\n\n    // Reverse prefix and reverse\
    \ string and check if they match.\n    if (reversed.length < prefix.length) {\n\
    \        prefix = prefix.split(\"\").reverse().join(\"\");\n    } else {\n   \
    \     reversed = reversed.split(\"\").reverse().join(\"\");\n    }\n\n    if (reversed\
    \ === prefix) {\n        return string;\n    } else {\n        const start = prefix.length\
    \ - reversed.length;\n        if (string.length > start) {\n            return\
    \ string.substring(start);\n        } else {\n            return string;\n   \
    \     }\n    }\n}\n", "  let longestPostfix = 0;\n  let longestSuffix = 0;\n\n\
    \  for (let i = 0; i < string.length; i++) {\n    const postfix = string[i];\n\
    \    const suffix = string[i - 1];\n\n    if (\n      isPalindrome(postfix, suffix,\
    \ i, longestPostfix, longestSuffix) &&\n      i > longestSuffix\n    ) {\n   \
    \   longestPostfix = i;\n      longestSuffix = longestSuffix + postfix.length;\n\
    \    }\n  }\n\n  return string.slice(0, longestPostfix) + string.reverse(longestSuffix);\n\
    }\n", "\tconst start_index = string.length - 1;\n\tconst end_index = string.length\
    \ - 2;\n\n\tconst prefix: string = string.substr(0, start_index);\n\tconst suffix:\
    \ string = string.substr(end_index + 1);\n\n\tconst palindrome: string = prefix\
    \ + string.reverse(suffix) + suffix;\n\n\treturn palindrome;\n}\n", "  var prefix\
    \ = string;\n  var suffix = string;\n  var reverse;\n  while (palindrome_position(suffix)\
    \ > 0) {\n    suffix = reverseString(suffix, palindrome_position(suffix));\n \
    \ }\n\n  reverse = reverseString(prefix, palindrome_position(suffix));\n\n  return\
    \ reverse + suffix;\n}\n", "    if (string === \"\") {\n        return \"\";\n\
    \    }\n    const [prefix, suffix] = string.split(\"\").reverse();\n    const\
    \ palindrome = `${prefix}${string.repeat(suffix.length)}${suffix}`;\n    return\
    \ palindrome;\n}\n", "  const max_len = string.length\n  const min_len = string.length\n\
    \  const max_postfix = max_len - min_len\n  const reversed_string = string\n \
    \   .substring(0, min_len)\n    .reverse()\n    .toString()\n    .substring(0,\
    \ max_postfix)\n    .concat(`${reversed_string}${string.substring(max_len)}`)\n\
    \n  return reversed_string\n}\n", "  if (string == \"\") {\n    return \"\"\n\
    \  }\n  let longestPalendron = \"\"\n  for (let i = 0; i < string.length; i++)\
    \ {\n    const palindrome = string\n    let suffix: string = string\n    let suffixIndex\
    \ = -1\n    for (let j = i; j < string.length; j++) {\n      suffixIndex += 1\n\
    \      suffix = suffix.substr(0, suffixIndex) + suffix.substr(suffixIndex).reverse()\n\
    \    }\n    if (suffix === palindrome) {\n      longestPalendron = string\n  \
    \    break\n    }\n  }\n  return longestPalendron\n}", "  let postfix = \"\";\n\
    \  let prefix_length = 0;\n  for (let i = 0; i < string.length; i++) {\n    const\
    \ current = string[i];\n    const last = string[i - 1];\n    postfix += current\
    \ + last;\n    if (current === last) {\n      prefix_length++;\n    } else {\n\
    \      break;\n    }\n  }\n  postfix = postfix.substring(1);\n  const reversed_postfix\
    \ = postfix.split(\"\").reverse().join(\"\");\n  return string + reversed_postfix;\n\
    }\n", "  if (string.length <= 1) return string;\n  let prefix = string.slice(0,\
    \ string.length - 1);\n  let reversed = reverseString(prefix);\n  let suffix =\
    \ string.slice(string.length - 1);\n  return `${prefix}${reversed}${suffix}`;\n\
    }\n", "  let max_palindrome_size = string.length + string.length;\n  let max_palindrome_chars\
    \ = string.length + string.length - 1;\n  for (let i = 1; i <= string.length;\
    \ i++) {\n    let reversed_char = string[string.length - i];\n    let prefix_chars\
    \ = string.slice(0, i);\n    let suffix_chars = string.slice(i + 1, string.length);\n\
    \    if (\n      reversed_char ===\n      prefix_chars.reverse().slice(0, -1).reverse()\
    \ + suffix_chars\n    ) {\n      if (string.length < max_palindrome_chars) {\n\
    \        max_palindrome_size = i;\n        max_palindrome_chars = string.length\
    \ + string.length - i;\n      }\n    }\n  }\n  return string.slice(0, max_palindrome_size)\
    \ + string.reverse().slice(0, -1);\n}\n", "    if (string.length < 2) return string;\n\
    \    const prefix_length: string = string.substring(0, string.length - 1).replace(/[^a-z]/gi,\
    \ \"\");\n    const suffix_length: string = string.substring(string.length - 1,\
    \ string.length).replace(/[^a-z]/gi, \"\");\n    const suffix_reverse: string\
    \ = suffix_length.reduce(\n        (accumulator, current) => current + accumulator,\n\
    \        \"\",\n    );\n    const longest_prefix: string = prefix_length.reduce(\n\
    \        (accumulator, current) => current + accumulator,\n        \"\",\n   \
    \ );\n    const postfix_reverse_length: string = suffix_reverse.substring(0, suffix_length.length);\n\
    \    const postfix_reverse: string = suffix_reverse.substring(0, suffix_reverse.length);\n\
    \    const postfix_length_shorter_than_reverse: string = postfix_length_shorter_than_reverse.reduce(\n\
    \        (accumulator, current) => current + accumulator,\n        \"\",\n   \
    \ );\n\n    if (\n        postfix_reverse ==\n        string.substring(0, string.length\
    \ - postfix_length_shorter_than_reverse.length - 1)\n    ) {\n        return `${string.substring(0,\
    \ string.length - postfix_length_shorter_than_reverse.length - 1)}${longest_prefix}${postfix_reverse}`;\n\
    \    } else {\n        return string;\n    }\n}\n", "  let longest: string = \"\
    \";\n  let shortest: string = \"\";\n  let startsWithPalindrome: boolean = false;\n\
    \n  for (let i = 0; i < string.length; ++i) {\n    let character: string = string[i];\n\
    \    let reverse: string = reverse(character);\n\n    if (character[0] === reverse[0])\
    \ {\n      if (i === 0) {\n        longest = character;\n      } else if (i ===\
    \ string.length - 1) {\n        shortest = character;\n        startsWithPalindrome\
    \ = true;\n      }\n    } else {\n      if (startsWithPalindrome) {\n        shortest\
    \ += character;\n      }\n    }\n  }\n\n  return longest.concat(shortest);\n}\n",
  "  let reverse: string;\n  while (reverse === string) {\n    reverse = reversePalindrome(string.substr(0,\
    \ string.length - 1));\n    string = string.substr(1);\n  }\n  return string +\
    \ reverse;\n}\n", "    let is_palindrome: boolean;\n    let palindrome_length:\
    \ number; //Longest postfix of string that can be a palindrome.\n\n    // Get\
    \ longest postfix of a string that is a palindrome\n    for (const char of string)\
    \ {\n        is_palindrome = true;\n        for (const c of string) {\n      \
    \      if (c !== char) {\n                is_palindrome = false;\n           \
    \     break;\n            }\n        }\n\n        // If string is a palindrome,\
    \ append reverse of string prefix that comes before palindromic suffix.\n    \
    \    if (is_palindrome) {\n            palindrome_length = palindrome_length ?\
    \ Math.max(string, palindrome_length) : 1;\n            string += palindrome_length\
    \ + char;\n        }\n    }\n\n    return string;\n}\n", "  const max_postfix:\
    \ string = string.match(/[A-Za-z]+/g).map(x => x.toLowerCase()).sort().reverse().join();\n\
    \  const prefix_len: number = string.length - max_postfix.length;\n  return string.concat(max_postfix,\
    \ string.substring(prefix_len));\n}\n", "    var suffix_reversed_string = string\n\
    \    var longest_palindrome_suffix = \"\"\n    var longest_palindrome_prefix_length\
    \ = 0\n\n    // Find the longest postfix palindrome.\n    for (var i = 0; i <\
    \ string.length; i++) {\n        var prefix_length = string.length - i - 1\n \
    \       var prefix = string.substring(0, prefix_length)\n\n        // Find the\
    \ reverse of the prefix.\n        var reverse_prefix = reverse(prefix)\n\n   \
    \     // Check if the prefix is a palindrome.\n        var prefix_is_palindrome\
    \ = prefix_length >= longest_palindrome_prefix_length\n            && prefix_length\
    \ >= longest_palindrome_suffix\n            && prefix_length >= prefix_reversed_string.length\n\
    \            && prefix_length >= reverse_prefix.length\n            && prefix_length\
    \ >= string.length\n            && prefix_is_palindrome\n\n        // If it is,\
    \ save it and its length as the longest palindrome suffix and prefix length.\n\
    \        if (prefix_is_palindrome) {\n            longest_palindrome_suffix =\
    \ prefix_reversed_string\n            longest_palindrome_prefix_length = prefix_length\n\
    \        }\n    }\n\n    // Add the longest palindrome suffix to the original\
    \ string and return it.\n    return string + longest_palindrome_suffix\n}\n",
  "    const len = string.length;\n    let prefix_len = 0;\n    let suffix_len = 0;\n\
    \    for (let i = 0; i < len; i++) {\n        const char = string[i];\n      \
    \  if (char === string[len - i - 1]) {\n            prefix_len++;\n        } else\
    \ {\n            break;\n        }\n    }\n    for (let i = len - 1; i >= 0; i--)\
    \ {\n        const char = string[i];\n        if (char === string[len - i - 1])\
    \ {\n            suffix_len++;\n        } else {\n            break;\n       \
    \ }\n    }\n    const palindrome_len = prefix_len + suffix_len;\n    const palindrome_postfix\
    \ = string.substr(0, palindrome_len);\n    const reversed_string = string.substr(palindrome_len,\
    \ len);\n    return palindrome_postfix + reversed_string;\n}\n", "\tif (string\
    \ === \"\") {\n\t\treturn string;\n\t}\n\tlet length: number;\n\tlet index: number;\n\
    \tlet last_index: number;\n\tlet firstChar: number;\n\tlet lastChar: number;\n\
    \tlet index1 = 0;\n\tlet index2 = 0;\n\tlet pal: string;\n\n\tfor (index = 0,\
    \ length = string.length; index < length; index++) {\n\t\tfirstChar = string.charCodeAt(index);\n\
    \t\tpal = '';\n\n\t\tlast_index = index;\n\n\t\tfor (index1 = index; index1 <\
    \ length; index1++) {\n\t\t\tlastChar = string.charCodeAt(index1);\n\t\t\tif (firstChar\
    \ === lastChar) {\n\t\t\t\tpal += string.charAt(index1);\n\t\t\t} else {\n\t\t\
    \t\tif (index1 - index2 === length) {\n\t\t\t\t\tpal += string.charAt(last_index)\
    \ + pal;\n\t\t\t\t} else {\n\t\t\t\t\tpal += string.charAt(last_index) + string.charAt(index1)\
    \ + string.charAt(index1 + 1);\n\t\t\t\t}\n\t\t\t\tlast_index = index1;\n\t\t\t\
    \tindex2++;\n\t\t\t}\n\t\t}\n\n\t\tstring = string.slice(0, index) + pal + string.slice(index);\n\
    \t}\n\n\treturn string;\n}\n", "  let len = string.length;\n  let postfix_with_palindrome:\
    \ string;\n  let suffix_to_prepend = \"\";\n  if (len == 0) return \"\";\n  let\
    \ reversed_string = string.reverse().toString();\n  let prefix_with_palindrome\
    \ = reversed_string.substr(0, reversed_string.length - 1);\n  let postfix = prefix_with_palindrome.substr(0,\
    \ prefix_with_palindrome.length - 1);\n  let suffix_to_prepend = postfix.substr(0,\
    \ postfix.length - 1);\n  postfix_with_palindrome = postfix + reversed_string;\n\
    \  suffix_to_prepend = suffix_to_prepend + reversed_string;\n  return postfix_with_palindrome\
    \ + suffix_to_prepend;\n}\n", "  const postfix = string.split('').reverse().join('');\n\
    \  return string.substring(0, string.lastIndexOf(postfix));\n}\n", "  if (string\
    \ === \"\") {\n    return \"\";\n  }\n\n  if (string.length <= 2) {\n    return\
    \ string;\n  }\n\n  // Find the longest postfix of string that is a palindrome.\n\
    \  const postfix = string.slice(1, string.length).reverse();\n\n  // Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n  return `${string.slice(0, 1)}${postfix}`;\n}\n", "    if (string\
    \ === \"\") return \"\";\n    var max_length = 0,\n        max_length_palindrome\
    \ = 0,\n        i = string.length - 1;\n    for (; i >= 0; i--) {\n        var\
    \ char = string[i];\n        if (char !== string.charAt(i)) {\n            var\
    \ palindrome = string.substring(max_length, i + 1);\n            if (palindrome\
    \ === palindrome.toLowerCase()) {\n                max_length_palindrome = palindrome.length;\n\
    \                max_length = i + 1;\n            }\n        }\n    }\n    return\
    \ string.substring(0, max_length) + string.substring(max_length_palindrome).split(\"\
    \").reverse().join(\"\");\n}\n", "    string = \"\" + string;\n    let prefix_match\
    \ = false;\n    for (let i = 0; i < string.length; ++i) {\n        if (string[i]\
    \ === string[string.length - 1 - i]) {\n            string += string[string.length\
    \ - 1 - i];\n            prefix_match = true;\n        }\n    }\n    if (!prefix_match)\
    \ {\n        string += string;\n    }\n    return string;\n}\n\nconst tests =\
    \ [\n    \"dog\",\n    \"dogs\",\n    \"cat\",\n    \"cata\",\n    \"doggo\",\n\
    \    \"rat\",\n    \"catcat\",\n    \"catacata\",\n    \"acat\",\n    \"catcatcat\"\
    ,\n    \"catcatcatcat\",\n];\n\nfor (let i = 0; i < tests.length; ++i) {\n   \
    \ let testString = tests[i];\n    let expectedResult = make_palindrome(testString);\n\
    \    let result = make_palindrome_reverse(testString);\n    if (result !== expectedResult)\
    \ {\n        console.log();\n        console.log(\n            \"Test \" + i +\
    \ \": Expected \"\n            + expectedResult\n            + \" but got \"\n\
    \            + result\n            + \" with input \"\n            + testString\n\
    \        );\n    }\n}\n", "  if (string === \"\") {\n    return \"\";\n  }\n \
    \ let palindrome: string;\n  const suffix: string = string.slice(string.length\
    \ - 1);\n  const prefix: string = string.slice(0, string.length - 1);\n  // Find\
    \ longest palindrome with at least half the supplied string in it.\n  if (suffix.startsWith(prefix))\
    \ {\n    const suffixReverse: string = suffix.slice(1).toLowerCase();\n    const\
    \ prefixReverse: string = prefix.slice(1).toLowerCase();\n    let longestPalindrome\
    \ = string.length + 1;\n    let longestPalindromeSuffix = \"\";\n    let longestPalindromePrefix\
    \ = \"\";\n    for (const i of suffix) {\n      longestPalindromeSuffix += i;\n\
    \      for (let j = suffixReverse.length - 1; j >= 0; j--) {\n        if (suffixReverse[j]\
    \ === longestPalindromeSuffix) {\n          longestPalindrome = longestPalindromeSuffix.length;\n\
    \          longestPalindromePrefix = longestPalindromeSuffix;\n          break;\n\
    \        }\n      }\n    }\n    for (const i of prefix) {\n      longestPalindromeSuffix\
    \ += i;\n      for (let j = prefixReverse.length - 1; j >= 0; j--) {\n       \
    \ if (prefixReverse[j] === longestPalindromeSuffix) {\n          longestPalindrome\
    \ = longestPalindromeSuffix.length;\n          longestPalindromePrefix = longestPalindromeSuffix;\n\
    \          break;\n        }\n      }\n    }\n  }\n  else {\n    const suffixReverse:\
    \ string = suffix.slice(1).toLowerCase();\n    const prefixReverse: string = prefix.slice(1).toLowerCase();\n\
    \    let longestPalindrome = string.length + 1;\n    let longestPalindromeSuffix\
    \ = \"\";\n    let longestPalindromePrefix = \"\";\n    for (const i of suffix)\
    \ {\n      longestPalindromeSuffix += i;\n      for (let j = suffixReverse.length\
    \ - 1; j >= 0; j--) {\n        if (suffixReverse[j] === longestPalindromeSuffix)\
    \ {\n          longestPalindrome = longestPalindromeSuffix.length;\n         \
    \ longestPalindromePrefix = longestPalindromeSuffix;\n          break;\n     \
    \   }\n      }\n    }\n    for (const i of prefix) {\n      longestPalindromeSuffix\
    \ += i;\n      for (let j = prefixReverse.length - 1; j >= 0; j--) {\n       \
    \ if (prefixReverse[j] === longestPalindromeSuffix) {\n          longestPalindrome\
    \ = longestPalindromeSuffix.length;\n          longestPalindromePrefix = longestPalindromeSuffix;\n\
    \          break;\n        }\n      }\n    }", "  const max_length = string.length\
    \ + 1;\n  const start_index = findLongestPalindromic(string, 0);\n  if (start_index\
    \ === -1) return string;\n  const end_index = findLongestPalindromic(string, start_index);\n\
    \  if (end_index === -1) return string;\n  const middle = start_index + end_index;\n\
    \  return string.slice(0, middle) + string.reverse().slice(middle);\n}\n", " \
    \   let last_postfix_len = string.length;\n    let first_prefix_len = 0;\n   \
    \ let max_length_of_palindrome = 0;\n\n    // Loop through string and find the\
    \ longest postfix that is palindrome.\n    string.split('').forEach(char => {\n\
    \        let postfix_len = string.length - last_postfix_len;\n        if (char\
    \ !== string[postfix_len]) {\n            last_postfix_len = postfix_len;\n  \
    \      }\n    });\n\n    // Reverse the prefix before the longest postfix.\n \
    \   string.split('').forEach(char => {\n        let prefix_len = string.length\
    \ - first_prefix_len;\n        if (char !== string[prefix_len]) {\n          \
    \  first_prefix_len = prefix_len;\n        }\n    });\n\n    // Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    let palindrome = string;\n    palindrome[first_prefix_len] = string[string.length\
    \ - last_postfix_len];\n    palindrome[string.length - first_prefix_len] = string[first_prefix_len];\n\
    \n    max_length_of_palindrome = Math.max(max_length_of_palindrome, first_prefix_len\
    \ + last_postfix_len);\n    return palindrome;\n}\n", "    let length = string.length;\n\
    \    let reversed: string = \"\";\n    while (length > 0) {\n        if (string.charAt(length\
    \ - 1) === string.charAt(length - 1).toUpperCase()) {\n            reversed =\
    \ string.charAt(length - 1) + reversed;\n            string = string.substr(0,\
    \ length - 1);\n        } else {\n            reversed = string.charAt(length)\
    \ + reversed;\n            string = string.substr(0, length);\n        }\n   \
    \     length--;\n    }\n    return string + reversed;\n}", "    const length =\
    \ string.length;\n    const chars = string.split('');\n    let result = '';\n\
    \    let longest: number = 0;\n    let longestChar: string;\n    let longestPostfix:\
    \ string;\n    for (let i = 0; i < length; i++) {\n        const currentChar =\
    \ chars[i];\n        if (currentChar !== longestChar) {\n            longest =\
    \ i;\n            longestChar = currentChar;\n            longestPostfix = '';\n\
    \        }\n        if (i === length - 1) {\n            result += (i === 0 ||\
    \ longestPostfix === longestChar) ? currentChar + currentChar : currentChar +\
    \ longestPostfix;\n            break;\n        }\n        const postfix = chars.slice(i\
    \ + 1, length).reverse().join('');\n        if (currentChar === postfix && i ===\
    \ length - 1) {\n            result += (i === 0 || longestPostfix === longestChar)\
    \ ? currentChar + currentChar : currentChar + longestPostfix;\n            break;\n\
    \        }\n        if (currentChar === postfix) {\n            longestPostfix\
    \ = postfix;\n        }\n    }\n    return result;\n}\n", "  const reversed =\
    \ string.replace(/[^a-z]$/i, \"\").split(\"\").reverse().join(\"\");\n  const\
    \ prefix = string.split(\"\").slice(0, string.length - reversed.length).join(\"\
    \");\n  return prefix + reversed + string;\n}\n", "    const reversed_postfix_string:\
    \ string = string.replace(/([a-z])$/, \"$1\").reverse().replace(/^([a-z])/, \"\
    $1\");\n    const prefix_string: string = reversed_postfix_string.slice(0, -1);\n\
    \    return prefix_string + reversed_postfix_string.slice(-1);\n}\n", "    if\
    \ (string === '') {\n        return '';\n    }\n\n    const longestPalindromicSuffix\
    \ = find_longest_palindromic_suffix(string);\n    return string + longestPalindromicSuffix;\n\
    }\n", "  const lstring: string = string.length <= 1 ?\n    string :\n    make_palindrome(string.slice(0,\
    \ string.length - 1));\n  const rstring: string = string.length <= 1 ?\n    string\
    \ :\n    make_palindrome(string.slice(1, string.length));\n  return `${lstring}${string}`;\n\
    }\n", "  let longest = palindrome(string);\n  let pre = longest.slice(0, longest.length\
    \ / 2);\n  return pre + reverseString(pre) + longest.slice(pre.length);\n}\n",
  "  string += string.substr(0, 1);\n  let longest = 0;\n  let result: string = \"\
    \";\n  for (let i = 1; i < string.length; i++) {\n    const prefix = string.substr(0,\
    \ i);\n    const suffix = string.substr(i, string.length);\n    if (suffix ==\
    \ prefix + reverseString(prefix)) {\n      result += prefix + reverseString(suffix);\n\
    \      longest = Math.max(longest + 1, i);\n    }\n  }\n  return result;\n}\n",
  "    if (string === \"\") {\n        return \"\";\n    }\n\n    let longest: string;\n\
    \    let longestLength: number = string.length;\n\n    for (let index: string[]\
    \ = string.split(\"\"); index.length >= 2; index.pop()) {\n        let substring:\
    \ string = index.join(\"\");\n        if (make_palindrome(substring) === string)\
    \ {\n            longest = substring;\n            longestLength = substring.split(\"\
    \").length - 1;\n        }\n    }\n\n    let reversed: string = \"\";\n    for\
    \ (let index: string[] = longest.split(\"\"); index.length >= longestLength; index.pop())\
    \ {\n        reversed += index.charAt(longestLength);\n    }\n\n    return reversed\
    \ + string;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,javascript |>\n\
    Using a recursive approach with two functions makePalindrome and makeSuffixPalindrome\
    \ and some string manipulation :\n<code>", "  const start = string.length\n  const\
    \ end = string.length\n  let i\n  let j\n  let tmp\n\n  for (i = 0; i < start\
    \ / 2; i++) {\n    for (j = i; j < end / 2; j++) {\n      tmp = string.slice(i,\
    \ i + j) + string.slice(j, j + i)\n      if (string == tmp) {\n        string\
    \ += string[i + j - i]\n      }\n    }\n  }\n  return string\n}\n", "    let result\
    \ = string;\n    const reverse: string = string.reduce((accumulator, char) =>\
    \ accumulator + char, \"a\");\n    const postfix = string.split(\"\").reverse().join(\"\
    \");\n    const prefix = string.substring(0, string.length - postfix.length);\n\
    \    for (let i = 0; i < prefix.length; i++) {\n        if (reverse.indexOf(prefix[i])\
    \ !== 0) {\n            return result;\n        }\n    }\n    return result;\n\
    }\n", "  let len: number;\n  let reversed: string;\n  let reversed_len: number;\n\
    \  let first_palindrome_index: number;\n  let end_of_string: number; //end of\
    \ string\n  let start_of_palindrome: number; //start of palindrome after reverse\
    \ of suffix.\n\n  //We want to find the longest postfix that is a palindrome,\
    \ so we reverse the entire string\n  // and look for the first palindromic suffix.\n\
    \  reversed = string.replace(/ /g, \"\");\n  reversed_len = reversed.length;\n\
    \n  len = string.length;\n  while (len > 0) {\n    end_of_string = 0;\n\n    //Find\
    \ first non-matching character in the reversed string\n    //and use its index\
    \ to find the suffix of the palindromic suffix.\n    for (first_palindrome_index\
    \ = reversed_len - 1; first_palindrome_index >= 0; first_palindrome_index--) {\n\
    \      if (reversed[first_palindrome_index] !== reversed[first_palindrome_index\
    \ + 1]) {\n        end_of_string = first_palindrome_index;\n        break;\n \
    \     }\n    }\n\n    //Find the last character of the palindrome suffix\n   \
    \ //that is before the suffix of the palindromic suffix.\n    //We need to find\
    \ such character in reversed string that is\n    // between end_of_string and\
    \ start_of_palindrome inclusive.\n    for (\n      start_of_palindrome = end_of_string\
    \ - 1;\n      start_of_palindrome > -1 &&\n      start_of_palindrome <= reversed_len;\n\
    \      start_of_palindrome--\n    ) {\n      if (reversed[start_of_palindrome]\
    \ === reversed[start_of_palindrome - 1]) {\n        break;\n      }\n    }\n\n\
    \    //If the suffix of the palindrome suffix and suffix of the palindromic suffix\
    \ do not match,\n    //then it is no palindrome and we can skip it.\n    if (start_of_palindrome\
    \ > -1 && start_of_palindrome < end_of_string) {\n      string = string.substring(0,\
    \ start_of_palindrome) + string.substring(end_of_string + 1);\n    }\n\n    //If\
    \ all character of the palindrome are identical\n    //then it can be said that\
    \ we are done with this iteration.\n    if (end_of_string >= 0) {\n      break;\n\
    \    }\n\n    //Otherwise continue with the next iteration.\n    len--;\n  }\n\
    \n  return string;\n}\n", "    let str: string = string.split('');\n    let max_length\
    \ = str.length -1;\n    let max_char_index = 0;\n    let reversed_string = '';\n\
    \    let min_length = max_length;\n    let min_char_index = 0;\n    while(min_length\
    \ > min_char_index) {\n        let char_index:number = min_char_index;\n     \
    \   let current_string: string = '';\n        for(let i=char_index;i<max_length;\
    \ i++) {\n            current_string += str[i]\n        }\n        if(!is_palindrome(current_string))\
    \ {\n            min_length = min_char_index + 1;\n        } else {\n        \
    \    max_char_index = char_index;\n        }\n    }\n    reversed_string += str[max_char_index];\n\
    \    for(let i=min_char_index;i<max_length; i++) {\n        reversed_string +=\
    \ str[i]\n    }\n    return reversed_string;\n}\n", "    var suffix_length = 0;\n\
    \    var prefix_length = 0;\n    var suffix_char;\n    var prefix_char;\n    var\
    \ prefix_chars = [];\n\n    var string_length = string.length;\n\n    while (true)\
    \ {\n        suffix_char = string[suffix_length];\n        prefix_char = string[prefix_length];\n\
    \n        if (suffix_char === prefix_char) {\n            prefix_chars.push(prefix_char);\n\
    \            prefix_length += 1;\n            suffix_length += 1;\n          \
    \  if (suffix_length === string_length) {\n                // Found a palindrome\n\
    \                return prefix_chars.join('') + string.substring(prefix_length);\n\
    \            }\n        } else {\n            if (suffix_length > prefix_length\
    \ + 1) {\n                prefix_length += 1;\n                suffix_length =\
    \ 0;\n            } else {\n                suffix_length += 1;\n            \
    \    prefix_length = 0;\n            }\n        }\n    }\n}\n", "  let last_index\
    \ = string.length - 1;\n  for (let index = 0; index < string.length; index++)\
    \ {\n    if (string[index] >= 'a' && string[index] <= 'z') {\n      if (index\
    \ !== last_index) {\n        let middle = string.slice(0, index).reverse() + string.slice(index,\
    \ string.length).reverse();\n        string = string.slice(0, index) + middle\
    \ + string.slice(index + middle);\n        last_index = index;\n      }\n    }\
    \ else {\n      break;\n    }\n  }\n  return string;\n}\n", "  const longest =\
    \ palindrome_longest(string);\n  const reverse = reverse_string(longest);\n  return\
    \ reverse + string;\n}\n", "\t// Check if string contains only letters and numbers\n\
    \tif (!/^[a-z0-9]+$/.test(string)) {\n\t\tthrow new Error(\"String must be alphanumeric\"\
    );\n\t}\n\n\t// Find longest postfix that is palindromic\n\tlet max_length = 0;\n\
    \tfor (let i = 1; i < string.length; ++i) {\n\t\tconst letter = string[i];\n\t\
    \tconst last_letter = string[i - 1];\n\t\tconst is_last = (last_letter == letter);\n\
    \n\t\tif (is_last) {\n\t\t\tmax_length = i;\n\t\t}\n\t}\n\n\t// Add palindromic\
    \ suffix to the end of the string\n\tconst palindrome = string.slice(0, max_length);\n\
    \tconst reversed_palindrome = string\n\t\t.slice(max_length)\n\t\t.reverse()\n\
    \t\t.toString();\n\n\treturn palindrome + reversed_palindrome;\n}\n", "  const\
    \ original_string = string\n  const reversed = string.split('').reverse().join('')\n\
    \  const longest_postfix_of_string = original_string.split(original_string.substr(0,\
    \ string.length)).reverse().join('')\n  const palindrome = original_string + longest_postfix_of_string\
    \ + reversed\n  return palindrome\n}\n", "  // return string if no palindrome.\n\
    \  if (string === make_palindrome.last_palindrome || string === make_palindrome.last_palindrome_reverse)\
    \ {\n    return string;\n  }\n\n  // find palindrome prefix in string.\n  const\
    \ palindrome_prefix_begin_index = string.indexOf(make_palindrome.last_palindrome);\n\
    \  if (palindrome_prefix_begin_index === -1) {\n    // prefix not found.\n   \
    \ return string;\n  }\n\n  // reverse palindrome prefix.\n  const palindrome_prefix_reverse_index\
    \ = make_palindrome.last_palindrome_reverse.indexOf(string[palindrome_prefix_begin_index]);\n\
    \  if (palindrome_prefix_reverse_index === -1) {\n    // reverse not found.\n\
    \    return string;\n  }\n\n  // build palindrome string.\n  const palindrome_prefix\
    \ = string[palindrome_prefix_begin_index];\n  const palindrome_prefix_reverse\
    \ = string[palindrome_prefix_reverse_index];\n  const palindrome_suffix = [palindrome_prefix_reverse,\
    \ palindrome_prefix_reverse].join(\"\");\n\n  make_palindrome.last_palindrome\
    \ = palindrome_suffix;\n  make_palindrome.last_palindrome_reverse = palindrome_prefix_reverse;\n\
    \n  return palindrome_prefix + palindrome_suffix;\n}\n", "  if (string === \"\"\
    ) {\n    return \"\";\n  }\n\n  let maxPalindromicStringStartIndex = 0;\n\n  while\
    \ (maxPalindromicStringStartIndex < string.length) {\n    const lastChar = string.substring(maxPalindromicStringStartIndex);\n\
    \    const palindromicSuffix = make_palindrome_suffix(string, maxPalindromicStringStartIndex);\n\
    \    maxPalindromicStringStartIndex = maxPalindromicStringStartIndex + palindromicSuffix.length;\n\
    \    string = `${string.substring(0, maxPalindromicStringStartIndex)}${palindromicSuffix}`;\n\
    \  }\n\n  return string;\n}\n", "  // find the longest postfix that is a palindrome\n\
    \  let max_start = string.lastIndexOf(\"a\");\n  let min_end = string.indexOf(\"\
    a\");\n  max_start = Math.max(max_start, min_end);\n  let max_end = min_end +\
    \ 1;\n  let prefix = string.slice(0, max_start);\n  let suffix = string.slice(max_end);\n\
    \  let palindrome = string.slice(0, max_start) + suffix;\n  let reverse = make_reverse(prefix);\n\
    \  reverse = palindrome.concat(reverse);\n  return palindrome;\n}\n", "    const\
    \ regex = /(?=\\w)(\\w*(\\w|\\d))/g;\n    let result: string = string;\n    \n\
    \    while (regex.test(result)) {\n        result = result.replace(regex, $1 +\
    \ \"$2\");\n    }\n    \n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ works for me (also added another example for you in the OP).\n<|/ c |>\n<| c\
    \ |>\nYeah, my solution is very basic. I tried to use a regex, but didn't know\
    \ how to do it with only one match. Now that I know, I will edit my answer.\n\
    <|/ c |>\n<| c |>\nI added some explanation on why this works. You were the one\
    \ to give a link to regex solution, so I added an update to my answer.\n<|/ c\
    \ |>\n<| a dscore=0 tags=algorithm,python,python-3.x |>\nUsing regex to check\
    \ for palindrome is okay, but I think we can do better. \nWe can use str.split\
    \ and str.join to do the trick. \n<code>\ndef isPalindrome(s):\n    chars = s.split()\n\
    \    return s == ''.join(reversed(chars))\n\nprint(isPalindrome(\"cat\")) # True\n\
    print(isPalindrome(\"cata\")) # True\nprint(isPalindrome(\"catalan\")) # True\n\
    print(isPalindrome(\"caa\")) # True\nprint(isPalindrome(\"caaa\")) # False\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for answering! Your solution is almost the same as\
    \ the one posted by. However, the problem with this solution is that it works\
    \ with only one string at a time. So if you wanted to test the string \"cata\"\
    , you would have to use another string \"cat\".\n<|/ c |>\n<| c |>\nI added another\
    \ example to my OP. Hope it helps clarify things.\n<|/ c |>\n<| a dscore=0 |>\n\
    I added another example to my OP.\nIn order to test the palindrome with the string\
    \ \"cata\", you would have to test the string \"cat\" as well, since the string\
    \ \"cata\" is a palindrome with an empty prefix.\nThe only solution I see is to\
    \ find the longest postfix of \"cata\" (in the example \"a\"), then reverse that\
    \ string and prepend it to the input string \"cata\".\nThe reason for not reversing\
    \ the string is because in the example, \"cata\" comes after \"a\" in the reversed\
    \ string, \"aac\".\n<|/ a ", "    const postfix_length: string = find_longest_palindrome_in_string(string);\n\
    \    const suffix: string = find_prefix_of_string(string, postfix_length);\n \
    \   const reversed_suffix: string = reverse(suffix);\n    return string + reversed_suffix;\n\
    }\n", "  var palindrome: string;\n  var begin_index: number = 0;\n  while (begin_index\
    \ < string.length) {\n    var end_index = string.length - 1;\n    while (end_index\
    \ > begin_index && string[end_index] === string[end_index - 1])\n      end_index--;\n\
    \    palindrome =\n      string[begin_index] + string[end_index].toUpperCase()\
    \ + palindrome;\n    begin_index++;\n  }\n  return palindrome;\n}\n", "    let\
    \ reverse: string = '';\n    string.split('').reverse().map((char: string) =>\
    \ {\n        reverse = reverse + char;\n    });\n    string = string + reverse;\n\
    \    return string;\n}\n", "    if (string.length === 0) {\n        return \"\"\
    ;\n    }\n    const reverse_string = string.reverse();\n    return string + reverse_string;\n\
    }\n", "  if (string.length <= 1) {\n    return string;\n  }\n  return string\n\
    \    .substr(0, string.length - 1)\n    .toLowerCase()\n    .repeat(string.length)\n\
    \    .toLocaleLowerCase();\n}\n", "    let postfix = find_postfix_of_string(string);\n\
    \    string += reversed_string(postfix, string);\n    return string;\n}\n", " \
    \   // O(N^2) algo\n    const longestPalindrome = find_longest_palindrome(string);\n\
    \    if (longestPalindrome.length >= string.length) {\n        return string;\n\
    \    }\n\n    // O(N) algo\n    const stringBeforeLongestPalindrome = string.substring(0,\
    \ longestPalindrome.length);\n    const reversedPrefixString = stringBeforeLongestPalindrome.reverse();\n\
    \    return string + reversedPrefixString;\n}\n", "  if (string.length === 0)\
    \ {\n    return \"\";\n  }\n\n  const longestPalindromicSuffix = getLongestPalindromicSuffix(string);\n\
    \n  const longestPalindromicPrefix = getLongestPalindromicPrefix(string, longestPalindromicSuffix);\n\
    \n  const palindrome = longestPalindromicPrefix + longestPalindromicSuffix.split(\"\
    \").reverse().join(\"\");\n\n  return palindrome;\n}\n", "  const suffixString\
    \ = string.slice(-1);\n  const palindromicSuffix = string\n    .reverse()\n  \
    \  .replace(/[^a-zA-Z]/g, '_');\n  const postFixString = string\n    .replace(/[^a-zA-Z]/g,\
    \ '_')\n    .slice(0, -1)\n    .slice(1) + palindromicSuffix;\n  return string.replace(\n\
    \    new RegExp(`^${postFixString}$`, 'g'),\n    string\n  );\n}\n", "    let\
    \ reverse: string = \"\";\n    for (let i = 0; i < string.length; i++) {\n   \
    \     reverse += string[i];\n    }\n    return reverse + reverse;\n}\n", "   \
    \ let palindrome: string = \"\";\n    let palindrome_index = 0;\n    let palindrome_length\
    \ = 0;\n\n    const last_char = string[string.length - 1];\n    for (let i = 0;\
    \ i < string.length; i++) {\n        const char = string[i];\n        const index\
    \ = string.indexOf(last_char, i);\n        if (index !== -1) {\n            const\
    \ prefix_string = string.substr(0, index);\n            const suffix = (string.length\
    \ <= index + 1) ? \"\" : string.substr(index + 1);\n            palindrome = palindrome\n\
    \                + char\n                + make_palindrome(prefix_string)\n  \
    \              + suffix\n                + char;\n            palindrome_length\
    \ = Math.max(palindrome_length, palindrome.length - suffix.length);\n        \
    \    palindrome_index = index;\n        } else {\n            if (palindrome_index\
    \ < palindrome_length) {\n                palindrome = palindrome\n          \
    \          + char\n                    + string.substr(palindrome_index, palindrome_length);\n\
    \            } else {\n                palindrome = palindrome\n             \
    \       + char\n                    + string.substr(palindrome_index);\n     \
    \       }\n            palindrome_length = palindrome_length + 1;\n          \
    \  palindrome_index = 0;\n        }\n        i = i + 1;\n    }\n\n    return palindrome;\n\
    }\n", "  const reverse: any = string\n    .split('')\n    .reverse()\n    .join('');\n\
    \  return string + reverse;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nGreat solution\
    \ - could also use Array.from(string).reverse().join('') instead of the Array.reverse\
    \ and Array.join methods\n<|/ c |>\n<| c |>\nYour solution doesn't work for \"\
    abc\". It returns \"bac\"\n<|/ c |>\n<| c |>\nYes, the solution is not complete.\
    \ You need to also check if the first character is contained in the string and\
    \ you need to check for a palindrome of a palindrome. See my other answer for\
    \ a more complete solution.\n<|/ c |>\n<| c |>\nI added a solution that does check\
    \ for a palindrome of a palindrome. Maybe you can edit your answer to include\
    \ that?\n<|/ c |>\n<| a tags=algorithm,javascript,string dscore=4 |>\nYou could\
    \ check the first character. \nThen if the first character is equal to last character\
    \ then it's a palindrome.\n<code>", "    if (string.length === 0) {\n        return\
    \ \"\";\n    }\n\n    const longest_postfix_palindrome = longestPalindromePostfix(string);\n\
    \    return `${string}${longest_postfix_palindrome.slice(longest_postfix_palindrome.length\
    \ - string.length, longest_postfix_palindrome.length)}`;\n}\n", "  let result\
    \ = string;\n  for (let i = string.length - 1; i >= 0; i--) {\n    result = result\
    \ + string[i] + string.substr(0, i);\n  }\n  return result;\n}\n\nconst make_fib_string\
    \ = (string: string): string => {\n  let result = \"\";\n  for (let i = 1; i <=\
    \ string.length; i++) {\n    result = result + string[i - 1] + string[i - 1];\n\
    \  }\n  return result;\n};\n", "\tconst prefix = get_longest_postfix_string(string);\n\
    \tconst suffix = get_longest_prefix_string(string);\n\tconst reversed_suffix =\
    \ suffix.split('').reverse().join('');\n\treturn [prefix, reversed_suffix, suffix].join('');\n\
    }\n", "  // Find the longest postfix of supplied string that is a palindrome.\n\
    \  const max_length: number = Math.max(...string.split('').map((s) => s.length));\n\
    \n  // Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n  let result: string = string;\n  for (let i: number\
    \ = max_length; i >= 0; i -= 1) {\n    result = string.slice(0, i) + result.reverse().slice(-1)\
    \ + string.slice(i);\n  }\n\n  return result;\n}\n</code>\n<|/ a tags=javascript,algorithm,palindrome\
    \ |>\n<| a dscore=0 tags=javascript,algorithm,palindrome |>\nHere is a different\
    \ approach which also handles duplicate letters, if that matters to you:\n<code>\n\
    const makePalindrome = s => {\n  // Create an array of all characters in `s` except\
    \ duplicates.\n  const chars = s.split('').filter(c => s.indexOf(c) < s.length);\n\
    \  // Reverse the array.\n  const rev = chars.reverse();\n  // Join the array\
    \ and reverse the string again.\n  const join = chars.join('');\n  return rev.reverse().join('')\
    \ + join;\n};\n\nconsole.log(makePalindrome('racecar'));\nconsole.log(makePalindrome('racecars'));\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for this. I was able to modify this to suit\
    \ my needs and it works perfectly for me.\n<|/ c |>\n<| a dscore=0 tags=javascript,algorithm,palindrome\
    \ |>\nThe easiest way is to use a backtracking algorithm.\n\n<code>\nconst isPalindrome\
    \ = (str) => {\n  if (str.length <= 1) return true;\n  return (str === str.split('').reverse().join(''))\
    \ \n    || (isPalindrome(str.substring(0,str.length/2))\n      && isPalindrome(str.substring(str.length/2)));\n\
    };\n\nconsole.log(isPalindrome('racecar'));\nconsole.log(isPalindrome('racecars'));\n\
    console.log(isPalindrome('racecars'));\nconsole.log(isPalindrome('racecar'));</code>\n\
    <|/ a |>\n<| a tags=javascript,algorithm,palindrome |>\n<code>", "    let reverse\
    \ = string[string.length - 1];\n    let longestPalInd = string.length - 1;\n \
    \   let palInd = string.length - 1;\n    for (let i = string.length - 2; i >=\
    \ 0; i--) {\n        if (string[i] !== reverse) {\n            let palInd = string.length\
    \ - 1;\n            for (let j = longestPalInd - i - 1; j >= 0; j--) {\n     \
    \           string[j + 1] = string[j];\n            }\n            longestPalInd\
    \ = i - 1;\n        }\n    }\n    string[longestPalInd + 1] = palInd;\n    return\
    \ string;\n}\n</code>\n<|/ a |>\n<| a |>\nHere is another solution I came up with\
    \ that uses recursion.\n<code>", "  // Start with longest postfix that is a palindrome.\n\
    \  let max_suffix_length = string.length / 2;\n  let max_suffix_string = \"\"\
    ;\n  while (max_suffix_length >= 0) {\n    const suffix = string.substr(0, max_suffix_length);\n\
    \    const is_palindromic = is_palindrome(suffix);\n    if (!is_palindromic) {\n\
    \      break;\n    }\n    // Remove suffix from string.\n    string = string.substr(max_suffix_length);\n\
    \    // Append the reverse of the suffix.\n    max_suffix_string += suffix.split(\"\
    \").reverse().join(\"\");\n    max_suffix_length--;\n  }\n  // Append the reverse\
    \ of the longest postfix string.\n  string += max_suffix_string;\n  return string;\n\
    }\n", "  if(string == \"\") {\n    return \"\";\n  }\n  \n  let left_length =\
    \ string.length;\n  let right_length = 0;\n  let left_postfix = \"\";\n  let right_postfix\
    \ = \"\";\n  let left_index = -1;\n  let right_index = -1;\n  let palindrome =\
    \ \"\";\n  \n  for(let i = 0; i <= left_length; i++) {\n    right_length = string.length;\n\
    \    right_index = right_length - 1;\n    left_postfix = string.substr(i, right_length\
    \ + 1 - i);\n    right_postfix = string.substr(0, i);\n    left_index = left_length\
    \ - 1 - i;\n    left_postfix = left_postfix.split(\"\").reverse().join(\"\");\n\
    \    right_postfix = right_postfix.split(\"\").reverse().join(\"\");\n    \n \
    \   if(left_postfix === right_postfix) {\n      palindrome += left_postfix + right_postfix;\n\
    \    }\n  }\n  \n  return palindrome;\n}\n", "    let result: string = string;\n\
    \    let index: string = \"\";\n    let reverse_index: number = \"\";\n    let\
    \ length: number = string.length;\n\n    // Find the longest postfix that is a\
    \ palindrome.\n    while (result.length > 0) {\n        const reverse_result:\
    \ string = string.reverse();\n        const prefix_length: number = string.length\
    \ - 1;\n        const reverse_prefix_length: number = reverse_result.length -\
    \ 1;\n        if (string[prefix_length] === reverse_result[reverse_prefix_length])\
    \ {\n            length--;\n            result = result.slice(0, -1) + string[prefix_length];\n\
    \        } else {\n            index++;\n        }\n    }\n    // Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    while (index > 0) {\n        reverse_index++;\n        result =\
    \ index === 1 ? \"\" : result.slice(0, -1) + reverse_index + string[index - 1];\n\
    \        index--;\n    }\n    return result;\n}\n", "    // TODO: use memoization\
    \ - currently not possible as `make_palindrome` can be called with different parameters\n\
    \    let reversed: string = string;\n    let postfix_startIndex: number = 0;\n\
    \    while (string.charAt(postfix_startIndex) === string.charAt(postfix_startIndex\
    \ + 1) &&\n           postfix_startIndex < string.length - 1) {\n        postfix_startIndex\
    \ += 1;\n    }\n    if (postfix_startIndex >= string.length) {\n        return\
    \ string;\n    }\n    let postfix_endIndex: number = postfix_startIndex + 1;\n\
    \    while (string.charAt(postfix_endIndex) !== string.charAt(postfix_startIndex\
    \ + 1) &&\n           postfix_endIndex < string.length - 1) {\n        postfix_endIndex\
    \ += 1;\n    }\n    let postfix_reversed: string = reversed.substr(0, postfix_startIndex)\
    \ + reversed.substr(postfix_endIndex);\n    return string + postfix_reversed;\n\
    }", "  let max_palindrome = make_palindrome_max_postfix_length(string, 0);\n \
    \ string = string + make_palindrome_prefix_length(max_palindrome, 0, string.length);\n\
    \  return string;\n}", "  const reverse = string.replace(/./g, char => String.fromCharCode(97\
    \ + char.charCodeAt(0) - 1))\n  const prefix: string = reverse.replace(/./g, char\
    \ => String.fromCharCode(97 + char.charCodeAt(0)))\n  const suffix: string = reverse.replace(/./g,\
    \ char => String.fromCharCode(97 + char.charCodeAt(0) - 1))\n  return prefix +\
    \ string + suffix\n}\n", "  let longestPalindromePostfix = \"\";\n  let longestPalindromePrefix\
    \ = \"\";\n  let longestPalindromeSuffix = 0;\n  let longestPalindromeLength =\
    \ 0;\n\n  //Loop through each char in the string.\n  for (let i = 0; i < string.length;\
    \ i++) {\n    //If it is a palindrome, increment the length.\n    if (string[i]\
    \ === string[i].reverse().toString()) {\n      longestPalindromeLength++;\n  \
    \  }\n\n    //Check if the postfix is longer than the suffix.\n    if (string[i].reverse().toString().length\
    \ >= longestPalindromeSuffix) {\n      //If it is, reset the suffix.\n      longestPalindromeSuffix\
    \ = string[i].reverse().toString();\n    }\n\n    //Check if the postfix is longer\
    \ than the prefix.\n    if (string[i].length >= longestPalindromePrefix) {\n \
    \     //If it is, reset the prefix.\n      longestPalindromePrefix = string[i];\n\
    \    }\n\n    //Check if the postfix is longer than the postfix.\n    if (string[i].length\
    \ >= longestPalindromeLength) {\n      //If it is, update the length of the postfix.\n\
    \      longestPalindromeLength = string[i].length;\n    }\n\n    //Check if the\
    \ prefix is longer than the postfix.\n    if (string[i].reverse().toString().length\
    \ >= longestPalindromeLength) {\n      //If it is, update the length of the prefix.\n\
    \      longestPalindromePrefix = string[i].reverse().toString();\n    }\n  }\n\
    \n  //Return the longest palindrome of length equal to the longestPalindromeLength.\n\
    \  return longestPalindromePrefix.reverse().toString() + string.substr(\n    0,\n\
    \    longestPalindromeSuffix\n  );\n}\n\nconst result = make_palindrome(\"aabbcc\"\
    );\nconsole.log(result);</code>\n<|/ a tags=javascript,palindrome,string |>\n\
    <| c |>\nCan you elaborate your algorithm\n<|/ c |>\n<| c |>\n`aabbcc`  is a palindrome\
    \ and `abbbcc` isn't because it isn't the longest palindrome. The longest palindrome\
    \ is `abbbccc`\n<|/ c |>\n<| c |>\nIt's not clear to me what your algorithm is\
    \ doing. The code snippet gives the wrong answer.\n<|/ c |>\n<| c |>\nYour algorithm\
    \ is flawed if the input string is `abbccc`. It will output `abc` when it should\
    \ output `cba`. The correct algorithm is given by in his answer.\n<|/ c |>\n<|",
  "  let reverse: string = string.reduce((result, c) => result + c, \"\").split(\"\
    \").reverse().join(\"\");\n  return string + reverse;\n}\n\nconst string = \"\
    cata\";\nconst reversed = string.reduce((result, c) => result + c, \"\").split(\"\
    \").reverse().join(\"\");\nconsole.log(`${string} + ${reversed} = ${make_palindrome(string)}`);</code>\n\
    <|/ a tags=javascript |>\n<| a dscore=0 |>\nA simple way to find all palindromes\
    \ in JavaScript is to reverse a string and compare it to the original string.\
    \ For a more advanced approach, see this answer.\n\n<code>", "  if (string ==\
    \ \"\") {\n    return \"\";\n  }\n\n  let postfix_start = string.length - 1;\n\
    \  let postfix_end = 0;\n  let postfix_value = \"\";\n  while (postfix_end <=\
    \ postfix_start) {\n    postfix_value = string.substr(postfix_start, postfix_end);\n\
    \    postfix_end += 1;\n\n    let prefix_value = string.substr(0, postfix_end);\n\
    \    let prefix = prefix_value;\n    if (make_palindrome(prefix_value) != make_palindrome(prefix))\
    \ {\n      postfix_start = postfix_end - 1;\n    }\n  }\n\n  postfix_start = postfix_end\
    \ - 1;\n  postfix_value = string.substr(postfix_start, postfix_end);\n  return\
    \ postfix_value + make_palindrome(string.substr(0, postfix_start));\n}\n", " \
    \ const prefix_len = Math.ceil(\n    (string.length - string.replace(/(.{2})/g,\
    \ \"$1\").length) / 2,\n  );\n  const palindrome_prefix_len = Math.ceil(\n   \
    \ (string.length - string.replace(/^(.{2})(.{2})$/, \"$1$2\").length) / 2,\n \
    \ );\n  let reversed = string;\n  let reverse_suffix;\n  if (string.length < prefix_len)\
    \ {\n    return string;\n  }\n  for (let i = prefix_len; i < string.length; i++)\
    \ {\n    reversed = reversed + string[i];\n  }\n  for (let i = 0; i < palindrome_prefix_len;\
    \ i++) {\n    reversed = reversed + string[prefix_len + i];\n  }\n  reverse_suffix\
    \ = \"~\" + string.slice(reverse_suffix, string.length);\n  return string + reversed\
    \ + reverse_suffix;\n}\n", "  let result: string = \"\";\n  let palindromes: string[]\
    \ = string.split(/[aeiou]/ig);\n  let min_length_of_palindrome = Infinity;\n \
    \ let min_palindrome = \"\";\n  for (let i = 0; i < palindromes.length; i++) {\n\
    \    let palindrome_length = string.length - (string.length - palindromes[i].length);\n\
    \    if (palindrome_length < min_length_of_palindrome) {\n      min_palindrome\
    \ = palindromes[i];\n      min_length_of_palindrome = palindrome_length;\n   \
    \ } else if (palindrome_length > min_length_of_palindrome) {\n      min_palindrome\
    \ += palindromes[i];\n      min_length_of_palindrome = palindrome_length;\n  \
    \  }\n  }\n  result += min_palindrome;\n  result += min_palindrome.reverse();\n\
    \  return result;\n}\n", "  if (string === \"\") return \"\";\n  let palindrome\
    \ = \"\";\n  let longestPostfixString = find_longest_postfix_string(string);\n\
    \  string = string.replace(longestPostfixString, \"$&\" + reverse(longestPostfixString));\n\
    \  while (string.length >= longestPostfixString.length) palindrome += string.slice(0,\
    \ longestPostfixString.length) + string.slice(longestPostfixString.length, string.length);\n\
    \  return palindrome;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
