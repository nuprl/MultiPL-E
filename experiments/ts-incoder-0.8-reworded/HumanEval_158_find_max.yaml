name: HumanEval_158_find_max
language: ts
prompt: "//Write a function that accepts an array of strings.\n// The array contains\
  \ different words. Return the word with maximum number\n// of unique characters.\
  \ If multiple strings have maximum number of unique\n// characters, return the one\
  \ which comes first in lexicographical order.\n// >>> find_max([\"name\", \"of\"\
  , \"string\"])\n// \"string\"\n// >>> find_max([\"name\", \"enam\", \"game\"])\n\
  // \"enam\"\n// >>> find_max([\"aaaaaaa\", \"bb\", \"cc\"])\n// \"aaaaaaa\"\nfunction\
  \ find_max(words: string[]): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = find_max;\n  assert.deepEqual(candidate([\"name\"\
  , \"of\", \"string\"]),\"string\");\n  assert.deepEqual(candidate([\"name\", \"\
  enam\", \"game\"]),\"enam\");\n  assert.deepEqual(candidate([\"aaaaaaa\", \"bb\"\
  , \"cc\"]),\"aaaaaaa\");\n  assert.deepEqual(candidate([\"abc\", \"cba\"]),\"abc\"\
  );\n  assert.deepEqual(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"\
  ]),\"footbott\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"gonna\", \"\
  rock\"]),\"gonna\");\n  assert.deepEqual(candidate([\"we\", \"are\", \"a\", \"mad\"\
  , \"nation\"]),\"nation\");\n  assert.deepEqual(candidate([\"this\", \"is\", \"\
  a\", \"prrk\"]),\"this\");\n  assert.deepEqual(candidate([\"b\"]),\"b\");\n  assert.deepEqual(candidate([\"\
  play\", \"play\", \"play\"]),\"play\");\n}\n\ntest();"
completions: ["  let maxCount: number = words.length;\n  let curr: number = words.length;\n\
    \  while (curr > 0) {\n    for (let word: string = words[0]; word !== \"\"; word\
    \ = words[curr - 1]) {\n      curr = 1;\n      for (let i = 1, len = words.length;\
    \ i < len; i++) {\n        if (word.indexOf(words[i]) === 0) {\n          curr++;\n\
    \        }\n      }\n      if (curr > maxCount) {\n        maxCount = curr;\n\
    \      }\n    }\n    curr--;\n  }\n  return maxCount === 1 ? words[0] : words[maxCount\
    \ - 1];\n}\n", "  // sort by alphabet and take first word\n  const sorted = words.sort((a,\
    \ b) => a.localeCompare(b));\n  return sorted[0]\n}\n", "  let sortedArray = words.sort();\n\
    \  let maxString = \"\";\n  let maxCount = 0;\n  for (let i = 0; i < sortedArray.length;\
    \ i++) {\n    let currentString = sortedArray[i];\n    let currentCount = sortedArray.filter(w\
    \ => w === currentString).length;\n    if (currentCount > maxCount) {\n      maxCount\
    \ = currentCount;\n      maxString = currentString;\n    }\n  }\n  return maxString;\n\
    }", "  var chars = words.map(word => {\n    word = word.toLowerCase();\n    var\
    \ charCountMap = {};\n    for (var char of word) {\n      if (!(charCountMap.hasOwnProperty(char)))\
    \ charCountMap[char] = 0;\n      charCountMap[char] += 1;\n    }\n    return charCountMap;\n\
    \  }).reduce((a, b) => a > b ? a : b);\n  var maxCharCountMap = {} as any;\n \
    \ for (var char of Object.keys(chars)) {\n    if (!maxCharCountMap.hasOwnProperty(chars[char]))\
    \ maxCharCountMap[chars[char]] = 0;\n    maxCharCountMap[chars[char]] += chars[char];\n\
    \  }\n  var maxCharCountKeys = Object.keys(maxCharCountMap).filter(key => {\n\
    \    return maxCharCountMap[key] === chars[key];\n  });\n  return maxCharCountKeys.reduce((a,\
    \ b) => a > b ? a : b);\n}\n", "    let maxNumber = 0;\n    let maxString: string;\n\
    \    let counter: number = 0;\n    for (let word of words) {\n        if (counter\
    \ > 0) {\n            if (maxNumber < counter) {\n                maxNumber =\
    \ counter;\n                maxString = word;\n            }\n        }\n    \
    \    counter++;\n    }\n    return maxString;\n}\n", "  const len = words.length;\n\
    \  if (len === 0) {\n    return \"\";\n  }\n\n  const counts: Record<string, number>\
    \ = {};\n  for (const word of words) {\n    const numChars = word.length;\n  \
    \  if (counts[word] > numChars) {\n      return word;\n    }\n    counts[word]\
    \ = numChars;\n  }\n\n  return words[0];\n}\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ |>\nThe most efficient solution is to use javascript sort method.\nFor example\
    \ : \n<code>\nconst sortedWords = words.sort((word1, word2) => word1.length -\
    \ word2.length);\n</code>\nsortedWords contains the most repeated word\n<|/ a\
    \ dscore=1 tags=javascript,arrays,sorting |>\n<| c |>\nNot quite right. `['a',\
    \ 'c', 'b', 'a']` would give you `\"b\"` instead of `\"a\"`. Should be `word1.length\
    \ - word2.length` instead\n<|/ c |>\n<| a |>\nYou can create an object with each\
    \ word as key and the count as value and then sort based on the value which has\
    \ the highest value\n<code>\nconst count = {};\n\nfor(let i = 0; i < words.length;\
    \ i++){\n    if(count.hasOwnProperty(words[i])){\n        count[words[i]] += 1;\n\
    \    } else {\n        count[words[i]] = 1;\n    }\n}\n\nconst sortedKeys = Object.keys(count).sort(\
    \ (a, b) => count[a] - count[b]);\n</code>\n<|/ a dscore=1 tags=javascript,arrays,sorting\
    \ |>\n<| a dscore=1 |>\nAnother solution would be to iterate over the array and\
    \ store the unique values in a Set and then get the length of the Set to get the\
    \ count.\n\n<code>\nconst arr = [\n  \"name\",\n  \"of\",\n  \"string\",\n  \"\
    name\",\n  \"enam\",\n  \"game\",\n  \"aaaaaaa\",\n  \"bb\",\n  \"cc\"\n]\n\n\
    const unique = new Set();\n\narr.forEach(word => {\n  if (unique.has(word)) {\n\
    \    unique.delete(word)\n  } else {\n    unique.add(word)\n  }\n})\n\nconsole.log(unique.size);</code>\n\
    <|/ a tags=javascript,arrays,sorting |>\n<| a |>\nYou could use reduce and map.\n\
    \n<code>\nconst arr = [\n  \"name\",\n  \"of\",\n  \"string\",\n  \"name\",\n\
    \  \"enam\",\n  \"game\",\n  \"aaaaaaa\",\n  \"bb\",\n  \"cc\"\n]\n\nconst unique\
    \ = arr.reduce((r, e) => {\n  if(!r.includes(e)) {\n    r.push(e)\n  }\n  return\
    \ r;\n}, [])\n\nconst count = arr.map((e) => unique.includes(e) ? unique.filter(f ",
  "  let counterMap: number[] = [];\n  let maxCount = 0;\n\n  words.forEach((word)\
    \ => {\n    word.split('').forEach((char, i) => {\n      counterMap[i] = counterMap[i]\
    \ ? counterMap[i] + 1 : 1;\n      if (counterMap[i] > maxCount) {\n        maxCount\
    \ = counterMap[i];\n      }\n    });\n  });\n  let result: string = words[0];\n\
    \  words.forEach((word) => {\n    word.split('').forEach((char, i) => {\n    \
    \  counterMap[i] = counterMap[i] ? counterMap[i] - 1 : -1;\n      if (counterMap[i]\
    \ === 0) {\n        counterMap[i] = maxCount === 0 ? 0 : maxCount;\n      }\n\
    \      if (counterMap[i] > maxCount) {\n        maxCount = counterMap[i];\n  \
    \      result = word;\n      }\n    });\n  });\n  return result;\n}\n", "    var\
    \ maxCount = 0;\n    var maxWord = '';\n    for (var i = 0; i <= words.length;\
    \ i++) {\n        var count = 0;\n        for (var j = 0; j <= words.length; j++)\
    \ {\n            count += words[j].length;\n            if (count > maxCount)\
    \ {\n                maxCount = count;\n                maxWord = words[j];\n\
    \            }\n        }\n    }\n    return maxWord;\n}\n", "  let highest =\
    \ 0;\n  let high = -1;\n  for (const word of words) {\n    if (highest < word.length())\
    \ {\n      highest = word.length();\n      high = word;\n    }\n  }\n  return\
    \ high;\n}\n", "  if (words.length === 0) {\n    return '';\n  }\n  const sorted\
    \ = words.sort();\n  const maxLength = Math.max.apply(null, sorted.map(function\
    \ (word) { return word.length; }));\n  const maxIndex = sorted.map(function (word,\
    \ index) { return word.length; })\n    .filter(function (word) { return word ===\
    \ maxLength; }).indexOf(true);\n  return sorted[maxIndex];\n}\n", "    var max_str\
    \ = \"\";\n    var max_len = -1;\n    var unique_char_count = 0;\n    for (var\
    \ i = 0; i < words.length; i++) {\n        unique_char_count += words[i].length;\n\
    \        if (words[i].length > max_len) {\n            max_str = words[i];\n \
    \           max_len = words[i].length;\n        }\n    }\n    if (unique_char_count\
    \ > max_len) {\n        return words[0];\n    }\n    return max_str;\n}\n", " \
    \ if (words.length === 0) {\n    return \"\"\n  }\n  let max_count = 0\n  let\
    \ max_word = null\n  for (let i = 0; i < words.length; i++) {\n    let word =\
    \ words[i]\n    let count = count_unique(word)\n    if (count > max_count) {\n\
    \      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n\
    }\n", "  console.log(words);\n  const dictionary = {};\n  let highest = words[0].length;\n\
    \  let highest_word = \"\";\n  for (let i = 0; i < words.length; ++i) {\n    dictionary[words[i]]\
    \ = dictionary.hasOwnProperty(words[i]) ? dictionary[words[i]] + 1 : 1;\n    if\
    \ (highest < dictionary[words[i]]) {\n      highest = dictionary[words[i]];\n\
    \      highest_word = words[i];\n    }\n  }\n  return highest_word;\n}\n", " \
    \ const counts = words.map(word => word.length);\n  let max = 0;\n  let i = 0;\n\
    \  while (i < counts.length) {\n    if (counts[i] > counts[max]) {\n      max\
    \ = i;\n    }\n    i++;\n  }\n  return words[max];\n}\n", "  if (words.length\
    \ === 0) return \"\";\n  let [count, max] = [0, 0];\n  words.forEach(w => {\n\
    \    if (w.length < max) count++;\n    if (w.length === max) count++;\n    if\
    \ (w.length > max) {\n      max = w.length;\n    }\n  });\n  return words[count].length\
    \ > max ? words[count] : words[count].substring(0, max);\n}\n", "    let max =\
    \ 0;\n    let word: string = words[0];\n    let i = 0;\n    while (i < words.length)\
    \ {\n        if (words[i].length >= max) {\n            word = words[i];\n   \
    \     } else {\n            break;\n        }\n        i++;\n    }\n    return\
    \ word;\n}\n", "  //Count each character in each string\n  const charCountMap\
    \ = {};\n  for (let word of words) {\n    for (let char of word) {\n      if (!charCountMap[char])\
    \ {\n        charCountMap[char] = 1;\n      } else {\n        charCountMap[char]\
    \ += 1;\n      }\n    }\n  }\n  //Iterate over all characters in charCountMap\n\
    \  let max = 0;\n  let maxChar = undefined;\n  for (let char in charCountMap)\
    \ {\n    if (charCountMap[char] > max) {\n      max = charCountMap[char];\n  \
    \    maxChar = char;\n    }\n  }\n  return maxChar;\n}\n", "    return words[0];\n\
    }\n", "  if (words.length === 0)\n    return \"\";\n  const strMap = new Map<string,\
    \ number>();\n  for (const word of words) {\n    const words = strMap.get(word)\
    \ || [word];\n    words.length = 0;\n    strMap.set(word, words);\n    words.sort((a,\
    \ b) => {\n      return a.length - b.length;\n    });\n  }\n  const maxLen = Math.max(...strMap.keys().map(word\
    \ => word.length));\n  let maxWord = \"\";\n  for (const word of strMap.keys())\
    \ {\n    if (word.length == maxLen) {\n      const res = strMap.get(word);\n \
    \     if (res[0].length == maxWord.length && res[0].length == maxLen) {\n    \
    \    maxWord = word;\n      }\n    } else {\n      maxWord = word;\n    }\n  }\n\
    \  return maxWord;\n}\n", "  const wordsWithUniqueCharacters = words.map(w =>\n\
    \    new Set(w.split('').sort())\n  )\n  return wordsWithUniqueCharacters[wordsWithUniqueCharacters.length\
    \ - 1]\n}\n", "  if (words.length === 0) {\n    return \"\"\n  }\n  else if (words.length\
    \ === 1) {\n    return words[0]\n  }\n\n  let maxCount: number = -Infinity\n \
    \ let maxIndex: number = -1\n\n  for (let i = 0; i < words.length; i++) {\n  \
    \  let char = words[i].toLowerCase().replace(/[^a-z]/g, \"\")\n\n    let charCount:\
    \ number = chars.length\n\n    if (charCount > maxCount) {\n      maxCount = charCount\n\
    \      maxIndex = i\n    }\n  }\n\n  if (maxCount === -Infinity) {\n    return\
    \ \"\"\n  }\n\n  return words[maxIndex]\n}\n", "  return find_max_(words, [],\
    \ (word) => word.length);\n}\n", "  const counts: number[] = new Array(words.length);\n\
    \  for (let i = 0; i < words.length; i++) {\n    counts[i] = counts[i - 1] ||\
    \ 0;\n    for (let j = 0, str = words[i]; j < str.length; j++) {\n      counts[j]\
    \ += (str[j] === words[i][j]);\n    }\n  }\n\n  const maxIndex = counts.length\
    \ - 1;\n  return words[maxIndex] === \"\" ? \"\" : words[maxIndex];\n}\n", " \
    \ let result: string = \"\";\n  let maxCount: number = 0;\n  for (let i = 0; i\
    \ < words.length; i++) {\n    if (words[i].length > maxCount) {\n      maxCount\
    \ = words[i].length;\n      result = words[i];\n    }\n  }\n  return result;\n\
    }\n", "    let longest = 0;\n    let current = 0;\n    for (let i = 0; i < words.length;\
    \ i++) {\n        let count = 1;\n        for (let j = i; j < words.length; j++)\
    \ {\n            if (words[i].indexOf(words[j]) === 0) {\n                count++;\n\
    \            }\n        }\n        if (count > longest) {\n            longest\
    \ = count;\n            current = words[i];\n        }\n    }\n    return current;\n\
    }\n", "  const map = new Map();\n  for (const word of words) {\n    const key\
    \ = createHash(word).digest('hex');\n    const count = map.get(key) || 0;\n  \
    \  map.set(key, count + 1);\n  }\n  let max = map.size;\n  for (const [key, value]\
    \ of map) {\n    if (value > max) {\n      max = value;\n    }\n  }\n  for (const\
    \ [key, value] of map) {\n    if (value === max) {\n      return key;\n    }\n\
    \  }\n  return '';\n}\n", "  let max_len: number = 0;\n  let word: string;\n \
    \ for (let i = 0; i < words.length; i++) {\n    let len = words[i].length;\n \
    \   if (len > max_len) {\n      max_len = len;\n      word = words[i];\n    }\n\
    \  }\n  return word;\n}\n", "  const word: string = words[0];\n  const counts:\
    \ number[] = [];\n  for (let i = 1; i < words.length; ++i) {\n    const word =\
    \ words[i];\n    const currentCounts = countWord(word);\n    const count = currentCounts[0];\n\
    \    counts.push(count);\n    if (count > words.length) {\n      return word;\n\
    \    }\n  }\n  return words[counts.indexOf(Math.max(...counts))];\n}\n", "\tlet\
    \ chars = words.map(x => x.split(\"\").sort().join(\"\"));\n\tlet max: string[]\
    \ = [];\n\tlet index: number[] = [];\n\tlet lengths: number[] = [];\n\tfor (let\
    \ i = 0; i < chars.length; i++) {\n\t\tlengths[i] = chars[i].length;\n\t\tmax.push(chars[i][0]);\n\
    \t\tindex.push(i);\n\t}\n\tlet result: string[] = [];\n\tlet indexLength = index.length;\n\
    \twhile (indexLength > 0) {\n\t\tlet currentIndex = index.shift();\n\t\tif (lengths[indexLength]\
    \ === max[indexLength].length && max[indexLength] === chars[currentIndex]) {\n\
    \t\t\tresult.push(max[indexLength]);\n\t\t}\n\t\tindexLength--;\n\t}\n\treturn\
    \ result.sort().join(\"\");\n}\n", "    let maxCount = 0;\n    let maxWord = \"\
    \";\n    for (let word of words) {\n        const count = countCharacters(word);\n\
    \        if (count > maxCount) {\n            maxCount = count;\n            maxWord\
    \ = word;\n        }\n    }\n    return maxWord;\n}\n", "  if (words.length ===\
    \ 0) {\n    return \"\";\n  }\n\n  let maxCount = 0;\n  let maxLength = 0;\n \
    \ let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    const count\
    \ = words.filter((word) => word === words[i]).length;\n    if (count > maxCount)\
    \ {\n      maxCount = count;\n      maxWord = words[i];\n      maxLength = words[i].length;\n\
    \    }\n  }\n  return maxWord;\n}\n", "  if (words.length === 0) {\n    return\
    \ \"\";\n  }\n  const counts: number[] = [];\n  for (let i = 0; i < words.length;\
    \ i++) {\n    const word = words[i];\n    const count = counts[i]\n    if (word.length\
    \ > count) {\n      counts[i] = word.length;\n    } else if (word.length < count)\
    \ {\n      counts.splice(i, 0, word.length);\n    }\n  }\n  return counts\n  \
    \  .map((value, index) => words[index])\n    .sort((a, b) => b.length - a.length)[0];\n\
    }\n", "  let chars: number[] = [];\n  let maxChar = 0;\n  let maxStr = \"\";\n\
    \  for (let i = 0; i < words.length; i++) {\n    let char = words[i].length;\n\
    \    if (char > maxChar) {\n      maxChar = char;\n      maxStr = words[i];\n\
    \    }\n    chars[i] = char;\n  }\n  let maxIndex = chars.indexOf(maxChar);\n\
    \  if (maxIndex > 0) {\n    return words[maxIndex];\n  }\n  for (let i = 0; i\
    \ < words.length; i++) {\n    if (chars[i] < maxChar) {\n      return words[i];\n\
    \    }\n  }\n}", "  return words[0];\n}\n```\n</pre>\n</div>\n<div class=\"slide\"\
    \ id=\"finding-the-maximum-number-of-unique-characters-in-a-string\" data-base=\"\
    slides\">\n<h1>Finding the Maximum Number of Unique Characters in a String</h1>\n\
    <div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode js\"><code class=\"\
    sourceCode javascript\"><a class=\"sourceLine\" id=\"cb11-1\" data-line-number=\"\
    1\"><span class=\"kw\">function</span> <span class=\"at\">find_max</span>(words:\
    \ <span class=\"va\">string</span><span class=\"at\">[]</span>) <span class=\"\
    op\">{</span></a>\n<a class=\"sourceLine\" id=\"cb11-2\" data-line-number=\"2\"\
    >  <span class=\"kw\">let</span> unique_chars <span class=\"op\">=</span> <span\
    \ class=\"va\">{}</span>,</a>\n<a class=\"sourceLine\" id=\"cb11-3\" data-line-number=\"\
    3\">  word <span class=\"op\">=</span> <span class=\"va\">\"\"</span>,</a>\n<a\
    \ class=\"sourceLine\" id=\"cb11-4\" data-line-number=\"4\">  i <span class=\"\
    op\">=</span> <span class=\"dv\">0</span><span class=\"op\">;</span></a>\n<a class=\"\
    sourceLine\" id=\"cb11-5\" data-line-number=\"5\">  <span class=\"cf\">for</span>\
    \ (<span class=\"kw\">let</span> word <span class=\"op\">=</span> <span class=\"\
    va\">words</span>.<span class=\"at\">pop</span><span class=\"op\">(<span class=\"\
    kw\">void</span>)</a>\n<a class=\"sourceLine\" id=\"cb11-6\" data-line-number=\"\
    6\">    <span class=\"op\">;</span> <span class=\"kw\">let</span> char <span class=\"\
    op\">=</span> <span class=\"va\">word</span>.<span class=\"at\">charAt(<span class=\"\
    dv\">0</span>)</span><span class=\"op\">;</span></a>\n<a class=\"sourceLine\"\
    \ id=\"cb11-7\" data-line-number=\"7\">    <span class=\"cf\">if</span> (unique_chars.<span\
    \ class=\"at\">hasOwnProperty</span>(char) <span class=\"op\">==</span> <span\
    \ class=\"kw\">false</span><span class=\"op\">)</span> <span class=\"op\">{</span></a>\n\
    <a class=\"sourceLine\" id=\"cb11-8\" data-line-number=\"8\">      unique_chars.<span\
    \ class=\"at\">char</span>.<span class=\"at\">push</span>(char)</a>\n<a class=\"\
    sourceLine\" id=\"cb11-9\" data-line-number=\"9\">    <span class=\"op\">}</span></a>\n\
    <a class=\"sourceLine\" id=\"cb11-10\" data-line-number=\"10\">  <span class=\"\
    op\">}</span></a>\n<a class=\"sourceLine\" id=\"cb11-11\" data-line-number=\"\
    11\">  <span class=\"cf\">return</span> <span class=\"va\">unique_chars</span>.<span\
    \ class=\"at\">length</span>)</a>\n<a class=\"sourceLine\" id=\"cb11-12\" data-line-number=\"\
    12\"><span class=\"op\">}</span></a></code></pre></div>\n<pre class=\"output\"\
    ><code class=\"output javascript\"><a class=\"sourceLine\" id=\"cb11-13\" data-line-number=\"\
    13\">  <span class=\"kw\">let</span> unique_chars <span class=\"op\">=</span>\
    \ <span class=\"va\">{}</span>,</a>\n<a class=\"sourceLine\" id=\"cb11-14\" data-",
  "  let max: number = 0;\n  let idx: number = 0;\n\n  for (let i = 0; i < words.length;\
    \ ++i) {\n    if (words[i].length >= max) {\n      idx = i;\n      max = words[i].length;\n\
    \    }\n  }\n\n  return idx === words.length - 1 ? words[0] : words[idx];\n}\n",
  "  let max_char_count = 0;\n  let max_word = words[0];\n  for (let i = 1; i < words.length;\
    \ i++) {\n    let curr_char_count =\n      words[i].split(\"\").sort((a, b) =>\
    \ a.localeCompare(b)).join(\"\").length;\n    if (curr_char_count > max_char_count)\
    \ {\n      max_char_count = curr_char_count;\n      max_word = words[i];\n   \
    \ }\n  }\n  return max_word;\n}\n", "  const map = new Map<string, number>();\n\
    \  const max = 0;\n  const word: string = words.reduce(\n    (word1, word2) =>\
    \ map.get(word1) < map.get(word2) ? word1 : word2,\n  );\n  for (let word of words)\
    \ {\n    const num = map.get(word) || 0;\n    if (num < max) {\n      map.set(word,\
    \ ++num);\n    } else if (num === max) {\n      return word;\n    }\n  }\n  return\
    \ word;\n}\n", "  //\n}\n", "  // Sort the array in lexicographical order\n  const\
    \ sortedWords = words.sort();\n  // Return string with maximum number of unique\
    \ characters\n  let maxCount = 0;\n  // Use a hashmap to keep track of how many\
    \ unique characters are in a given string.\n  const charMap = new Map<string,\
    \ number>();\n  sortedWords.forEach((word) => {\n    const characterCount = word.split('').filter((letter)\
    \ => !charMap.has(letter)).filter((letter) => {\n      // If the character has\
    \ not been added into the hashmap, then add it.\n      if (!charMap.has(letter))\
    \ {\n        charMap.set(letter, 1);\n      } else {\n        // If the character\
    \ has already been added into the hashmap, then add 1.\n        charMap.set(letter,\
    \ charMap.get(letter) + 1);\n      }\n      // If the current character count\
    \ is greater than the max character count so far, update maxCount\n      if (charMap.get(letter)\
    \ > maxCount) {\n        maxCount = charMap.get(letter);\n      }\n      return\
    \ true;\n    });\n  });\n  // Return the string that comes first in lexicographical\
    \ order\n  return sortedWords[sortedWords.indexOf(sortedWords[0]) + 1];\n}\n",
  "  let characterSet = new Set<string>();\n  for (let word of words) {\n    for (let\
    \ character of word) {\n      characterSet.add(character);\n    }\n  }\n  let\
    \ maxCount = 1;\n  let maxWord = \"\";\n  for (let word of words) {\n    let numOfCharacters\
    \ = word.length;\n    if (numOfCharacters < maxCount) {\n      continue;\n   \
    \ }\n    for (let character in characterSet) {\n      if (characterSet.has(character))\
    \ {\n        let charCount = characterSet.has(character) ? characterSet.get(character)\
    \ : 0;\n        if (charCount > maxCount) {\n          maxCount = charCount;\n\
    \          maxWord = word;\n        }\n      }\n    }\n  }\n  return maxWord;\n\
    }\n", "  //Count the number of unique characters in each word. \n  //Ignore letters\
    \ other than the alphabet, numbers, and special symbols.\n  const letters: string[]\
    \ = words.map(w => w.replace(/[^A-Za-z0-9\\s]/g, \"\"));\n  const counts: number[]\
    \ = letters.map(l => {\n    let count = 0;\n    letters.forEach(a => {\n     \
    \ if (a === l) count++;\n    });\n    return count;\n  });\n  //Return the word\
    \ with the highest count.\n  return letters[counts.indexOf(Math.max(...counts))];\n\
    }\n", "    let max: number = 0;\n    let found: boolean;\n\n    words.forEach((w)\
    \ => {\n        found = words[max].includes(w);\n        if (found) {\n      \
    \      max = Math.max(max, words.indexOf(w, words.indexOf(words[max])) + 1);\n\
    \        } else {\n            max = Math.max(max, words.indexOf(w));\n      \
    \  }\n    });\n\n    return found ? words[max] : words[max];\n}\n", "  let maxCount:\
    \ number = 0;\n  let maxWord: string;\n  for (const word of words) {\n    maxCount\
    \ = 0;\n    for (const c of word) {\n      if (words.indexOf(word) + 1 > maxCount)\
    \ {\n        maxWord = word;\n        maxCount = words.indexOf(word) + 1;\n  \
    \    }\n    }\n  }\n  return maxWord;\n}\n", "  let maxNum = 0;\n  let curMaxNum\
    \ = 0;\n  let curMaxChar = \"\";\n\n  for (let i = 0; i < words.length; i++) {\n\
    \    let wordCharCount: number = 0;\n\n    for (let j = 0; j < words[i].length;\
    \ j++) {\n      if (wordCharCount[words[i][j]] > 0) {\n        wordCharCount[words[i][j]]\
    \ = wordCharCount[words[i][j]] + 1;\n      } else {\n        wordCharCount[words[i][j]]\
    \ = 1;\n      }\n\n      if (wordCharCount[words[i][j]] > curMaxNum) {\n     \
    \   curMaxNum = wordCharCount[words[i][j]];\n        curMaxChar = words[i][j];\n\
    \      }\n    }\n  }\n\n  return curMaxChar;\n}\n", "  let result = '';\n  for\
    \ (let word of words) {\n    if (word.length > result.length) {\n      result\
    \ = word;\n    }\n  }\n  return result;\n}\n", "  let sorted: number[] = [];\n\
    \  for (let word of words) {\n    for (let i = 0; i < word.length; i++) {\n  \
    \    sorted.push(i);\n    }\n  }\n  sorted.sort((a, b) => a - b);\n  for (let\
    \ i = 0; i < sorted.length; i++) {\n    let index = sorted[i];\n    let curr =\
    \ words[index];\n    let newWords = [];\n    for (let ii = index; ii < words.length;\
    \ ii++) {\n      let word = words[ii];\n      let charCount = 0;\n      for (let\
    \ iii = 0; iii < word.length; iii++) {\n        if (word[iii] === curr) {\n  \
    \        charCount++;\n        }\n      }\n      if (charCount > sorted.length\
    \ / 2) {\n        newWords.push(word);\n      }\n    }\n    if (newWords.length\
    \ > 1) {\n      return find_max(newWords);\n    }\n  }\n  return curr;\n}\n",
  "  let unique_chars = new Set<string>();\n\n  for (let word of words) {\n    let\
    \ unique_chars_in_word = new Set<string>();\n\n    for (let char of word) {\n\
    \      unique_chars_in_word.add(char);\n    }\n\n    let unique_chars_in_word_length\
    \ = Array.from(unique_chars_in_word).length;\n\n    if (unique_chars_in_word_length\
    \ >= unique_chars.size) {\n      unique_chars = unique_chars;\n    }\n  }\n\n\
    \  return Array.from(unique_chars)\n    .sort((a, b) => a.localeCompare(b))[0]\n\
    \    .slice(0, 20);\n}\n", "  let maxLength: number = 0;\n  let maxWord = words[0];\n\
    \  for (let i = 0; i < words.length; i++) {\n    if (words[i].length !== maxLength)\
    \ {\n      maxLength = words[i].length;\n      maxWord = words[i];\n    } else\
    \ if (words[i].length === maxLength) {\n      maxLength = 0;\n    }\n  }\n  return\
    \ maxWord;\n}\nconsole.log(find_max([\"name\", \"enam\", \"game\"]));\nconsole.log(find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"]));</code>\n\nThis solution also takes care of words\
    \ which are of equal length. \n\n<code>", "  const map = new Map();\n  for (const\
    \ word of words) {\n    const chars = word.split(\"\").filter(c => c != \" \"\
    ).length;\n    const count = map.get(chars) || 0;\n    map.set(chars, count +\
    \ 1);\n  }\n\n  const max = Math.max(...map.values());\n  const index = Array.from(map).findIndex(item\
    \ => item.value == max);\n  return words[index].toString();\n}\n", "  let maxCount\
    \ = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n  \
    \  let wordCount: number = words[i].length;\n    if (wordCount > maxCount) {\n\
    \      maxCount = wordCount;\n      maxWord = words[i];\n    }\n  }\n  return\
    \ maxWord;\n}\n", "  let result: string = null;\n  for (let i = 0; i < words.length;\
    \ i++) {\n    const word = words[i];\n    if (result === null || countUniqueCharacters(word)\
    \ > countUniqueCharacters(result)) {\n      result = word;\n    }\n  }\n  return\
    \ result;\n}\n", "    if (words.length < 2) return words[0];\n    const map: Record<string,\
    \ number[]> = {};\n    for (let i = 0; i < words.length; ++i) {\n        const\
    \ word = words[i];\n        map[word] = map[word] || [];\n        map[word].push(i);\n\
    \    }\n    const maxKey = Object.keys(map).reduce((a, b) => {\n        const\
    \ aCount = map[a].length;\n        const bCount = map[b].length;\n        return\
    \ aCount === bCount ? a : aCount > bCount ? a : b;\n    });\n    const maxCount\
    \ = map[maxKey].length;\n    return maxCount === 1 ? '' : maxKey;\n}", "    if\
    \ (words.length == 0) {\n        return \"\"\n    }\n    const charMap = new Map<string,\
    \ number>(words.length)\n    const maxCount = new Map<string, number>()\n    for\
    \ (const word of words) {\n        const charCount = word.split(\"\").reduce((prev,\
    \ curr, index) => {\n            return charMap.get(curr) || prev + index\n  \
    \      }, 0)\n        if (charMap.size > maxCount.size) {\n            maxCount.clear()\n\
    \        }\n        maxCount.set(word, charCount)\n        charMap.set(word, charCount\
    \ + 1)\n    }\n    const maxKey = Array.from(maxCount.keys()).sort((a, b) => b\
    \ - a)[0]\n    return maxKey.slice(0, maxKey.length - 1) // remove last char\n\
    }", "  let max: number = words.length;\n  let maxWord: string = \"\";\n  let maxCharCount:\
    \ number = Number.MIN_VALUE;\n  for (let i = 0; i < words.length; i++) {\n   \
    \ const charCount: number = words[i].length;\n    if (charCount > maxCharCount)\
    \ {\n      maxCharCount = charCount;\n      maxWord = words[i];\n    }\n    if\
    \ (charCount === maxCharCount) {\n      const wordWithoutRepetitions: string[]\
    \ = [...new Set(words[i])];\n      if (maxWord.length < wordWithoutRepetitions.length)\
    \ {\n        maxWord = wordWithoutRepetitions;\n      }\n    }\n  }\n  return\
    \ maxWord;\n}\n", "  let uniqueCount = new Set<string>();\n  let maxCharCount\
    \ = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n  \
    \  let word: string = words[i];\n    let wordCount = uniqueCount.size;\n    uniqueCount.clear();\n\
    \    let count = 0;\n    for (let j = 0; j < word.length; j++) {\n      count\
    \ += word.charCodeAt(j);\n      uniqueCount.add(word.slice(j, j + 1));\n    }\n\
    \    if (count > maxCharCount) {\n      maxCharCount = count;\n      maxWord =\
    \ word;\n    } else if (count === maxCharCount) {\n      if (wordCount > uniqueCount.size)\
    \ {\n        maxWord = word;\n      }\n    }\n  }\n  return maxWord;\n}\n", " \
    \ \n}\n", "  words.sort((a: string, b: string) => {\n    const aChar: string =\
    \ a.split('').sort((x: number, y: number) => x - y).join('');\n    const bChar:\
    \ string = b.split('').sort((x: number, y: number) => x - y).join('');\n    return\
    \ aChar - bChar;\n  });\n  return words[words.length - 1];\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=0 tags=javascript |>\n<code>", "  if (words.length\
    \ == 0) {\n    return \"\";\n  }\n  const max: Map<string, number> =\n    new\
    \ Map()\n    .set(0, words[0]);\n  for (const w of words) {\n    const count =\
    \ max.get(w) || 0;\n    max.set(w, count + 1);\n  }\n  for (const [k, count] of\
    \ max) {\n    if (count > words.length / 2) {\n      return k;\n    }\n  }\n \
    \ return \"\";\n}\n", "  const counts = words.reduce((counts: { [key: string]:\
    \ number }, word) => {\n    const count = getCount(counts, word);\n    counts[word]\
    \ = count + 1;\n    return counts;\n  }, {});\n  const max = Math.max(...Object.values(counts));\n\
    \  return Object.keys(counts).find(key => counts[key] === max);\n}\n", "  words.sort((a:\
    \ string, a: string) => a.length - b.length);\n  return words[words.length - 1];\n\
    }\n", "  const maxVal = words.length;\n  const currVal = 0;\n  for (let i = 0;\
    \ i < words.length; i++) {\n    const count = words.filter(w => w === words[i]).length;\n\
    \    if (count > currVal) {\n      currVal = count;\n    }\n  }\n  return words[maxVal]\
    \ === words[currVal] ? words[maxVal] : words[maxVal];\n}\n", "    // sort by length\
    \ of words\n    words.sort((a, b) => {\n        return b.length - a.length;\n\
    \    });\n    // return the word with max length\n    return words[words.length\
    \ - 1];\n}\n", "  let result: string = words[0];\n  for (let i = 1; i < words.length;\
    \ i++) {\n    if (words[i].length >= words[i - 1].length) {\n      result = words[i];\n\
    \    }\n  }\n  return result;\n}\n", "  var maxCount: number = 0;\n  var maxStr:\
    \ string = \"\";\n  for (var i = 0; i < words.length; i++) {\n    var word: string\
    \ = words[i];\n    var count: number = word.length\n    var index = maxStr.length\
    \ - count;\n    var charCount: number = 0;\n    for (var j = 0; j < word.length;\
    \ j++) {\n      charCount += word.charAt(j);\n    }\n    if (count > maxCount)\
    \ {\n      maxCount = count;\n      maxStr = word;\n    }\n    if (index >= 0\
    \ && charCount >= index) {\n      maxStr = word;\n    }\n  }\n  return maxStr;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere is a recursive version of\
    \ a solution, which works for any number of words and any number of characters:\n\
    <code>", "    return words.reduce((acc, curr) => {\n        let count = 0;\n \
    \       words.forEach(word => {\n            let arr = word.split('');\n     \
    \       for (let i = 0; i < arr.length; i++) {\n                if (arr[arr.length\
    \ - i - 1] === curr[i]) {\n                    count++;\n                }\n \
    \           }\n        })\n        if (count > acc.length) {\n            acc\
    \ = curr\n        }\n        return acc;\n    });\n}\n\n", "  const [max] = words\n\
    \    .map(w => w.split(''))\n    .map(c => c.length)\n    .sort((a, b) => b -\
    \ a)\n  const max = words[words.length - 1].split('')\n  for (let i = words.length\
    \ - 1; i > 0; i--) {\n    const [c, ...rest] = words[i].split('')\n    if (c >\
    \ max[0]) {\n      max.splice(0, 1, c)\n    } else {\n      max.splice(0, 1, ...rest)\n\
    \    }\n  }\n  return max.join('')\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ is very smart and clever! But I think you should also show the OP a way to solve\
    \ it using `reduce()`\n<|/ c |>\n<| c |>\nI added a reduce version. Thank you\
    \ for your input!\n<|/ c |>\n<| a dscore=0 tags=algorithm,typescript,arrays,javascript\
    \ |>\n<code>", "  const sorted = words.slice().sort();\n  const unique = sorted.reduce((acc,\
    \ word) => {\n    const index = acc.findIndex(w => w === word);\n    if (index\
    \ === -1) {\n      acc.push(word);\n    }\n    return acc;\n  }, []);\n  return\
    \ unique.length === 0 ? words[0] : unique[unique.length - 1];\n}\n", "  let max\
    \ = 0;\n  let word = '';\n  for (let i = 0; i < words.length; i++) {\n    const\
    \ word = words[i];\n    let uniqueChars = 0;\n    for (let j = 0; j < word.length;\
    \ j++) {\n      if (words[j].indexOf(word) == j) {\n        uniqueChars += 1;\n\
    \      }\n    }\n    if (uniqueChars > max) {\n      max = uniqueChars;\n    \
    \  word = words[i];\n    }\n  }\n  return word;\n}\n", "\tlet lengths = words.map(word\
    \ => {\n\t\tlet length = 0;\n\t\tfor (let i = 0; i < word.length; i++) {\n\t\t\
    \tif (word[i] === word[i - 1]) {\n\t\t\t\tlength++;\n\t\t\t} else {\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t\treturn length;\n\t});\n\tlet max = 0;\n\tlet maxLength\
    \ = 0;\n\tfor (let i = 0; i < words.length; i++) {\n\t\tlet length = lengths[i];\n\
    \t\tif (length > maxLength) {\n\t\t\tmax = i;\n\t\t\tmaxLength = length;\n\t\t\
    }\n\t}\n\treturn words[max];\n}\n", "  let maxCount: number = 0;\n  let maxWord:\
    \ string | undefined;\n  let maxIndex = 0;\n  for (let i = 0; i < words.length;\
    \ i++) {\n    let word = words[i];\n    let count = countUnique(word);\n    if\
    \ (count > maxCount) {\n      maxCount = count;\n      maxWord = word;\n     \
    \ maxIndex = i;\n    }\n  }\n  return maxWord;\n}\n", "    const max: number[]\
    \ = [0, ...words.map(word => word.length)];\n    const result: string[] = [];\n\
    \    let maxIndex = 0;\n    for (let i = 1; i < words.length; i++) {\n       \
    \ const [currentMax, word] = max;\n        const [nextMax, nextWord] = words[i];\n\
    \        if (currentMax < nextMax) {\n            maxIndex = i;\n            result[result.length]\
    \ = word;\n            max = [nextMax, word];\n        }\n    }\n    return result[result.length\
    \ - 1];\n}\n", "    let max: string[] = [];\n    let index = 0;\n    for (let\
    \ word of words) {\n        let unique: number = 0;\n        let found = false;\n\
    \        for (let j = 0; j < word.length; j++) {\n            for (let i = 0;\
    \ i < index; i++) {\n                if (word[i] == words[j]) {\n            \
    \        found = true;\n                    unique++;\n                    break;\n\
    \                }\n            }\n            if (found) {\n                index++;\n\
    \            }\n        }\n        if (unique.length > max.length) {\n       \
    \     max = [word];\n        } else if (unique.length == max.length) {\n     \
    \       max.push(word);\n        }\n    }\n    return max[0];\n}\n", "  const\
    \ results: Map<string, number>;\n  const len = words.length;\n  if (len === 0)\
    \ {\n    return \"\";\n  }\n  if (len === 1) {\n    return words[0];\n  }\n  const\
    \ map = new Map<string, number>();\n  results.set(words[0], 0);\n  for (let i\
    \ = 1; i < len; i++) {\n    const word = words[i];\n    if (!map.has(word)) {\n\
    \      map.set(word, 0);\n    }\n    if (map.get(word) < results.get(word)) {\n\
    \      results.set(word, map.get(word));\n    }\n  }\n  return words[results.get(words)];\n\
    }\n", "  let max = words.reduce((acc, word) => {\n    let unique = word.split('').filter((letter)\
    \ => {\n      return !acc.hasOwnProperty(letter);\n    });\n    let count = unique.length;\n\
    \    if (count > acc.count) {\n      return {\n        word,\n        count\n\
    \      };\n    } else {\n      return acc;\n    }\n  }, { word: '', count: 0 });\n\
    \  return max.word;\n}\n", "  let max = 0;\n  let word = \"\";\n  for (const word\
    \ of words) {\n    const chars = word.length;\n    const uniqueChars = words.reduce((prev,\
    \ cur) => prev + cur.length, 0);\n    const uniqueCharsMax = Math.max(uniqueChars,\
    \ max);\n    if (chars === uniqueCharsMax) break;\n    if (chars > uniqueCharsMax)\
    \ {\n      max = chars;\n      word = word;\n    }\n  }\n  return word;\n}\n",
  "\tlet max = 0, index = 0;\n\tfor (let i = 0; i < words.length; i++) {\n\t\tlet\
    \ char = words[i].split('').sort().join('');\n\t\tif (char.length < max || i ==\
    \ words.length - 1) {\n\t\t\tmax = char.length;\n\t\t\tindex = i;\n\t\t}\n\t}\n\
    \treturn words[index];\n}\n", "  //write your code here\n  const count = words.reduce((acc,\
    \ word) => acc + word.length, 1)\n  return words[0]\n}\n", "    let max = 0;\n\
    \    let result: string = words[0];\n    for (let i = 1; i < words.length; i++)\
    \ {\n        const c = words[i].length;\n        if (c > max) {\n            max\
    \ = c;\n            result = words[i];\n        }\n    }\n    return result;\n\
    }\n", "  // Write your code here.\n  let map: any = {};\n  for (const word of\
    \ words) {\n    map[word] = (map[word] || 0) + 1;\n  }\n  let keys: string[] =\
    \ [];\n  for (const key in map) {\n    if (map.hasOwnProperty(key)) {\n      keys.push([key,\
    \ map[key]]);\n    }\n  }\n  keys.sort((a, b) => {\n    return a[1] - b[1];\n\
    \  });\n  for (let i = 0; i < keys.length; i++) {\n    if (keys[i][1] === 1) {\n\
    \      return keys[i][0];\n    }\n  }\n  return words[0];\n}\n", "  let maxLength\
    \ = 0;\n  let maxWord = \"\";\n  words.forEach(word => {\n    maxLength = Math.max(maxLength,\
    \ word.length);\n    words.forEach(w => {\n      if (w === word) {\n        maxLength++;\n\
    \      }\n    });\n    if (maxLength === word.length) {\n      maxWord = word;\n\
    \    }\n  });\n  return maxWord;\n}\n", "\tlet max_chars = \"\";\n\tlet max_index\
    \ = 0;\n\tfor (let i = 0; i < words.length; i++) {\n\t\tlet chars = words[i].length;\n\
    \t\tif (max_chars.length < chars) {\n\t\t\tmax_chars = chars;\n\t\t\tmax_index\
    \ = i;\n\t\t} else if (max_chars == chars) {\n\t\t\tif (i == 0) {\n\t\t\t\tmax_index\
    \ = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlet j = i;\n\t\t\twhile (j < words.length\
    \ && words[j].length < chars) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tmax_index = j;\n\
    \t\t}\n\t}\n\treturn words[max_index];\n}\n", "  return words\n    .map(word =>\
    \ word.split(''))\n    .filter((chars, i) => chars.sort().join() === chars[0])\n\
    \    .reduce((acc, word) => acc.length > word.length ? acc : word)\n}", "  const\
    \ max: number[] = [];\n  for (const word of words) {\n    const count: number[]\
    \ = [];\n    for (const letter of word) {\n      if (counted[letter]) {\n    \
    \    counted[letter]++;\n      } else {\n        counted[letter] = 1;\n      }\n\
    \      count[counted[letter]!-1]++;\n    }\n    max.push(count.indexOf(Math.max(...count)));\n\
    \  }\n  return words[max[0]];\n}\n", "  words.sort(function (a, b) { return a.length\
    \ - b.length });\n  let max: number = words[0].length;\n  for (let i = 0; i <\
    \ words.length; i++) {\n    if (words[i].length > max) {\n      max = words[i].length;\n\
    \    }\n  }\n  return words[words.length - 1];\n}\n", "  // Your code here\n \
    \ let str: string[] = [];\n  let maxCount = 0;\n  for (let i = 0; i < words.length;\
    \ i++) {\n    let word: any = words[i];\n    let count = str.filter(x => x ===\
    \ word).length;\n    if (count > maxCount) {\n      maxCount = count;\n      str\
    \ = word;\n    }\n  }\n  return str;\n}\n", "    var maxCharCount = 0;\n    var\
    \ maxWord = words[0];\n    for (var i = 1; i < words.length; ++i) {\n        var\
    \ wordCount = words[i].length;\n        if (wordCount > maxCharCount) {\n    \
    \        maxCharCount = wordCount;\n            maxWord = words[i];\n        }\n\
    \    }\n    return maxWord;\n}\n", "  return words[words.reduce((p, c) => p.length\
    \ > c.length ? p : c)]\n}\n", "    let wordCounts = words.reduce((prev, curr)\
    \ => {\n        prev[curr] = prev[curr] || 0;\n        prev[curr] += 1;\n    \
    \    return prev;\n    }, {});\n    let sortedWordCounts = Object.keys(wordCounts).sort((a,\
    \ b) => {\n        return wordCounts[b] - wordCounts[a];\n    });\n    if (sortedWordCounts.length\
    \ === 0) {\n        return null;\n    }\n    return sortedWordCounts[0];\n}\n\
    console.log(find_max([\"ab\", \"ac\", \"ba\", \"a\", \"c\"]));\nconsole.log(find_max([\"\
    name\", \"of\", \"string\"]));\nconsole.log(find_max([\"name\", \"enam\", \"game\"\
    ]));\nconsole.log(find_max([\"aaaaaaa\", \"bb\", \"cc\"]));\n", "  let highest:\
    \ number = 0;\n  let highest_word: number[] = [];\n  for (let word of words) {\n\
    \    if (highest_word.length <= word.length)\n      highest_word = word;\n   \
    \ else if (highest_word.length < word.length)\n      highest_word = highest_word.concat(word);\n\
    \  }\n  for (let word of words) {\n    for (let i = 0; i < word.length; i++) {\n\
    \      for (let j = 0; j < highest_word.length; j++) {\n        if (word[i] ==\
    \ highest_word[j]) {\n          if (highest[j] < word.length)\n            highest[j]\
    \ = word.length;\n          break;\n        }\n      }\n    }\n  }\n  return highest_word.join('');\n\
    }\n", "  const map = words.reduce(\n    (map, word) => {\n      for (let i = 0;\
    \ i < word.length; i++) {\n        const c = word.charAt(i)\n        if (!map.hasOwnProperty(c))\
    \ {\n          map[c] = 0\n        }\n        map[c]++\n      }\n      return\
    \ map\n    },\n    {}\n  )\n  let max = 0\n  let maxWord = Object.keys(map).reduce((word,\
    \ i) => {\n    if (map[i] > max) {\n      max = map[i]\n      maxWord = word\n\
    \    }\n    return word\n  }, \"\")\n  return maxWord\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  const max: any = {};\n  for (let word of words)\
    \ {\n    const unique: string = word.split('').sort().join('');\n    const count:\
    \ number = max[unique] || 0;\n    max[unique] = count + 1;\n  }\n  const result:\
    \ string = Object.keys(max).reduce((prev, curr) => {\n    return prev > max[curr]\
    \ ? prev : curr;\n  }, '');\n  return result;\n}\n", "  const unique = words.reduce((acc,\
    \ word) => {\n    const charCount: { [char: string]: number } = {};\n    charCount[word]\
    \ = 1;\n    words.forEach(word => {\n      charCount[word] =\n        charCount[word]\
    \ || 0;\n      charCount[word] += 1;\n    });\n    return Object.entries(charCount)\n\
    \      .filter(([key, value]) => value === 1)\n      .sort(([, a], [, b]) => a\
    \ - b)\n      .reduce((acc, [word, count]) => count > acc ? word : acc, [\n  \
    \      '',\n      ]);\n  }, '');\n\n  return unique.length === 0 ? words[0] :\
    \ unique[0];\n}\n", "  let max = 0;\n  let found = false;\n  let currentWord =\
    \ \"\";\n\n  for (let i = 0; i < words.length; i++) {\n    found = false;\n  \
    \  for (let j = 0; j < words[i].length; j++) {\n      if (words[i].substr(j, 1)\
    \ == currentWord) {\n        found = true;\n      } else {\n        currentWord\
    \ = words[i].substr(j, 1);\n        if (max < words[i].length - j) {\n       \
    \   max = words[i].length - j;\n          found = true;\n        }\n      }\n\
    \    }\n    if (!found) {\n      max = words[i].length;\n    }\n  }\n\n  if (max\
    \ > words[0].length) {\n    found = false;\n    for (let i = 0; i < words.length;\
    \ i++) {\n      if (words[i].substr(max, 1) == currentWord) {\n        found =\
    \ true;\n      } else {\n        currentWord = words[i].substr(max, 1);\n    \
    \    if (max > words[i].length - 1) {\n          max = words[i].length - 1;\n\
    \          found = true;\n        }\n      }\n    }\n  }\n\n  return found ? currentWord\
    \ : words[0];\n}\n", "\tlet maxIndex = 0;\n\tlet maxCharCount = 0;\n\tfor (let\
    \ i = 0; i < words.length; i++) {\n\t\tfor (let j = 0; j < words[i].length; j++)\
    \ {\n\t\t\tif (maxIndex < words[i].length && maxCharCount < words[i].length &&\
    \ words[i].charAt(j) === words[maxIndex].charAt(j)) {\n\t\t\t\tmaxIndex = i;\n\
    \t\t\t\tmaxCharCount = words[i].length;\n\t\t\t}\n\t\t}\n\t}\n\treturn words[maxIndex];\n\
    }\n", "  words.sort(function (a, b) { return b.length - a.length; });\n  var result:\
    \ string;\n  var current: string;\n  for (var i = 0; i < words.length; i++) {\n\
    \    current = words[i];\n    var count: number;\n    var next: string;\n    for\
    \ (var j = i; j < words.length; j++) {\n      next = words[j];\n      count =\
    \ j - i;\n      if (count > 0) {\n        if (current.indexOf(next) > 0) {\n \
    \         continue;\n        } else {\n          result = current;\n         \
    \ j = i;\n          i = j + count;\n          break;\n        }\n      }\n   \
    \ }\n  }\n  return result;\n}\n", "  // Find the unique character count for each\
    \ word\n  const counts: { [word: string]: number } = {};\n  for (const word of\
    \ words) {\n    if (counts[word]) {\n      counts[word] = counts[word] + 1;\n\
    \    } else {\n      counts[word] = 1;\n    }\n  }\n\n  // Find the word with\
    \ max unique character count\n  let maxWord: string;\n  let maxCount: number;\n\
    \  for (const word in counts) {\n    if (counts.hasOwnProperty(word)) {\n    \
    \  if (maxCount < counts[word]) {\n        maxCount = counts[word];\n        maxWord\
    \ = word;\n      }\n    }\n  }\n\n  return maxWord;\n}\n", "  let hashMap = new\
    \ Map<string, number>();\n  let maxValue = 0;\n  for (let i = 0; i < words.length;\
    \ i++) {\n    let word = words[i];\n    for (let j = 0; j < word.length; j++)\
    \ {\n      let char = word[j];\n      let count = hashMap.get(char);\n      if\
    \ (count === undefined) {\n        hashMap.set(char, 1);\n      } else {\n   \
    \     hashMap.set(char, count + 1);\n      }\n      maxValue = Math.max(maxValue,\
    \ count);\n    }\n  }\n  let sortedArray = Array.from(hashMap.entries()) as [string,\
    \ number];\n  sortedArray.sort((a, b) => {\n    return b[1] - a[1];\n  });\n \
    \ return sortedArray[0][0];\n}", "    // Write your code here\n}", "  let maxCount\
    \ = 0;\n  let maxWord: any = \"\";\n\n  for (let i = 0; i < words.length; i++)\
    \ {\n    let word = words[i];\n    let count = getUniqueWords(word);\n    if (count\
    \ > maxCount) {\n      maxCount = count;\n      maxWord = word;\n    }\n  }\n\
    \  return maxWord;\n}\n", "  let uniqueChars = {};\n  let maxCount = 0;\n  for\
    \ (let word of words) {\n    let numOfChars = word.length + 1;\n    if (numOfChars\
    \ in uniqueChars) {\n      uniqueChars[numOfChars] += 1;\n    } else {\n     \
    \ uniqueChars[numOfChars] = 1;\n    }\n    if (uniqueChars[numOfChars] > maxCount)\
    \ {\n      maxCount = uniqueChars[numOfChars];\n    }\n  }\n  return words[Object.keys(uniqueChars)\n\
    \    .map((k) => uniqueChars[k])\n    .indexOf(maxCount)];\n}\n", "\tlet unique_characters:\
    \ any = {};\n\tlet highest_unique_characters = 0;\n\tfor (let i = 0; i < words.length;\
    \ i++) {\n\t\tlet word = words[i];\n\t\tlet count = unique_characters[word] ?\
    \ unique_characters[word] + 1 : 1;\n\t\tunique_characters[word] = count;\n\t\t\
    if (count > highest_unique_characters) {\n\t\t\thighest_unique_characters = count;\n\
    \t\t}\n\t}\n\n\tlet highest_unique_characters_word: any = words[words.length -\
    \ 1];\n\tfor (let j = 0; j < words.length; j++) {\n\t\tlet word = words[j];\n\t\
    \tlet count = unique_characters[word] ? unique_characters[word] + 1 : 1;\n\t\t\
    if (count === highest_unique_characters) {\n\t\t\thighest_unique_characters_word\
    \ = word;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn highest_unique_characters_word;\n\
    }\n", "    return find_max_(words);\n}\n", "  // Initialize max with empty string.\n\
    \  let max = \"\"\n  // Find max word and update max if current word's number\
    \ of unique\n  // characters exceeds current max's number of unique characters.\n\
    \  for (let i = 0; i < words.length; i++) {\n    const curr = words[i]\n    let\
    \ currCnt = uniq_cnt(curr)\n    for (let j = i + 1; j < words.length; j++) {\n\
    \      const next = words[j]\n      currCnt = uniq_cnt(curr) + uniq_cnt(next)\n\
    \      if (currCnt > uniq_cnt(max)) {\n        max = curr\n      }\n    }\n  }\n\
    \  return max\n}\n", "  const hashMap = {};\n  const sortedWords = words.sort();\n\
    \  for (let i = 0; i < sortedWords.length; i++) {\n    const word = sortedWords[i];\n\
    \    let count = hashMap[word];\n    if (count === undefined) {\n      hashMap[word]\
    \ = 1;\n    } else {\n      hashMap[word] = count + 1;\n    }\n  }\n  return sortedWords[sortedWords.length\
    \ - 1];\n}\n", "  return words\n    .map((word, index) => {\n      if (word.length\
    \ > 1) {\n        return word\n      }\n\n      return word.split(\"\").sort().join(\"\
    \")\n    })\n    .sort()\n    .join(\"\")\n}\n", "  const uniques: string[] =\
    \ [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n\
    \    if (!uniques.includes(word)) {\n      uniques.push(word);\n    }\n  }\n \
    \ if (uniques.length > 1) {\n    return find_max2(uniques);\n  } else {\n    return\
    \ uniques[0];\n  }\n}\n", "  let max = \"\"\n  let maxCount = 0\n  let currentCount\
    \ = 0\n  for (let word of words) {\n    currentCount = 0\n    for (let i = 0;\
    \ i < word.length; i++) {\n      let char = word[i]\n      if (char.charCodeAt(0)\
    \ > 255) char = String.fromCharCode(char.charCodeAt(0) - 255)\n      if (char.charCodeAt(0)\
    \ > maxCount) maxCount = char.charCodeAt(0)\n      for (let j = 0; j < currentCount;\
    \ j++) {\n        if (maxCount === char.charCodeAt(0)) break\n      }\n      if\
    \ (char.charCodeAt(0) > currentCount) {\n        max = word\n        currentCount\
    \ = char.charCodeAt(0)\n      }\n    }\n  }\n  return max\n}\n", "  words.sort();\n\
    \  let maxCount = 0;\n  let maxWord = words[0];\n  for (let i = 1; i < words.length;\
    \ i++) {\n    const wordCount = words.filter(w => w === words[i]).length;\n  \
    \  if (wordCount > maxCount) {\n      maxCount = wordCount;\n      maxWord = words[i];\n\
    \    }\n  }\n  return maxWord;\n}\n", "  const chars = words.map(w => w.split('').length);\n\
    \  return chars.reduce((a, b) => Math.max(a, b));\n}\n", "  return find_max_aux(words,\
    \ 0, words.length - 1, 0);\n}\n", "\tlet max = 0;\n\tlet wordWithMax: any = null;\n\
    \n\tfor (let i = 0; i < words.length; i++) {\n\t\tlet word = words[i];\n\t\tlet\
    \ letters = word.length;\n\n\t\tif (letters > max) {\n\t\t\tmax = letters;\n\t\
    \t\twordWithMax = word;\n\t\t}\n\t}\n\n\treturn wordWithMax;\n}\n", "  // sort\
    \ the words by length\n  words.sort((a: string, b: string) => a.length - b.length);\n\
    \  // get the word with maximum count of unique characters\n  return words[words.length\
    \ - 1];\n}\n</code>\n<|/ a tags=algorithm,sorting,javascript,string |>\n<| a |>\n\
    For those who are still looking for an efficient solution then this simple approach\
    \ works fine:\n<code>", "  let max: number = words[0].split('').sort().join('').length;\n\
    \  for (let i = 1; i < words.length; i++) {\n    if (words[i].split('').sort().join('').length\
    \ >= max) {\n      max = words[i].split('').sort().join('').length;\n    }\n \
    \ }\n  return words.find(w => w.split('').sort().join('').length == max);\n}\n",
  "    const chars = Array.from(new Set(words));\n    return chars.reduce((a, b) =>\
    \ a.length > b.length ? a : b);\n}\n", "  let strMaxChar: number = 0;\n  let strMax:\
    \ string = \"\";\n  for (let word of words) {\n    const len = word.length;\n\
    \    strMaxChar = strMaxChar < len ? len : strMaxChar;\n    strMax = strMaxChar\
    \ == 0\n      ? word\n      : word > strMax ? word : strMax;\n  }\n  return strMax;\n\
    }\n", "  words = words.sort((a, b) => b.length - a.length);\n  let [word] = words;\n\
    \  return words.reduce((prev, curr) => {\n    if (prev.length > curr.length) {\n\
    \      return prev;\n    } else {\n      return curr;\n    }\n  }) as string;\n\
    }\n", "  let maxCount: number = -Infinity;\n  let max: string = \"\";\n  for (const\
    \ word of words) {\n    const count: number = word.length; // length of word\n\
    \    if (count > maxCount) {\n      maxCount = count; // update max count\n  \
    \    max = word;\n    }\n  }\n  return max;\n}\n", "  const wordMap = new Map<string,\
    \ number>();\n  words.forEach(word => {\n    const count = wordMap.get(word) ||\
    \ 0;\n    wordMap.set(word, count + 1);\n  });\n  return [...wordMap]\n    .sort((a,\
    \ b) => b[1] - a[1])\n    .shift()[0];\n}\n", "  let max = \"\";\n  let maxCount\
    \ = 0;\n\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n\
    \    let count = 0;\n    for (let j = 0; j < word.length; j++) {\n      count\
    \ += alphabet.indexOf(word[j]);\n    }\n    if (count > maxCount) {\n      maxCount\
    \ = count;\n      max = word;\n    }\n  }\n\n  return max;\n}\n", "    let wordSet\
    \ = new Set<string>();\n\n    for (let word of words) {\n        let count = 0;\n\
    \        for (let letter of word) {\n            count = count + (wordSet.has(letter)\
    \ ? 1 : 0);\n            wordSet.add(letter);\n        }\n\n        if (wordSet.size\
    \ > words.length / 3) {\n            return word;\n        }\n\n        if (count\
    \ > words.length / 3) {\n            wordSet.add(word);\n        }\n    }\n\n\
    \    return words[0];\n}\n", "  let res = \"\";\n  for (let i = 0; i < words.length;\
    \ i++) {\n    let num = new Set<string>();\n    for (let j = 0; j < words.length;\
    \ j++) {\n      num.add(words[j]);\n    }\n    res = [...res, ...num];\n  }\n\
    \  let index = res.indexOf(Math.max(...res));\n  return res[index];\n}\n", " \
    \ if (words.length === 0) {\n    throw new Error(\"find_max() called with empty\
    \ words\");\n  }\n  const maxValue = words[0].length;\n  return maxValue.reduce((result,\
    \ currentValue) => {\n    if (words.length >= 1 && result[currentValue] === undefined)\
    \ {\n      throw new Error(`find_max() called with words that only contain ${currentValue}`);\n\
    \    }\n    if (result[currentValue] === undefined || result[currentValue] < maxValue)\
    \ {\n      maxValue = result[currentValue];\n    }\n    return result;\n  }, {});\n\
    }\n", "    var max = 0;\n    var index = 0;\n    var maxWord = \"\";\n    words.sort();\n\
    \n    for (let i = 0; i < words.length; i++) {\n        if (words[i].length >\
    \ max) {\n            max = words[i].length;\n            index = i;\n       \
    \     maxWord = words[i];\n        }\n    }\n\n    return maxWord;\n}\n", "  \
    \  let sorted = words.slice().sort((a, b) => {\n        let a_len = a.length;\n\
    \        let b_len = b.length;\n        \n        if (a_len > b_len) {\n     \
    \       return -1;\n        }\n        if (a_len < b_len) {\n            return\
    \ 1;\n        }\n        return 0;\n    });\n\n    let max_count = 0;\n    let\
    \ max_element = sorted[0];\n    for (let i = 1; i < sorted.length; i++) {\n  \
    \      let element = sorted[i];\n        let count = words.filter(x => x === element).length;\n\
    \        if (count > max_count) {\n            max_count = count;\n          \
    \  max_element = element;\n        }\n    }\n    return max_element;\n}\n", " \
    \ if (words.length === 0) {\n    throw new Error(\"Array is empty\");\n  }\n \
    \ words = [...new Set(words)];\n\n  let maxLength = words[0].length;\n\n  let\
    \ maxValue = 0;\n  for (const word of words) {\n    if (maxLength < word.length)\
    \ {\n      maxLength = word.length;\n      maxValue = word;\n    }\n  }\n\n  return\
    \ maxValue;\n}\n", "  let wordMap = new Map();\n  for (let word of words) {\n\
    \    if (wordMap.has(word)) {\n      wordMap.set(word, wordMap.get(word) + 1);\n\
    \    } else {\n      wordMap.set(word, 1);\n    }\n  }\n  let maxWord = null;\n\
    \  let maxValue = 0;\n  for (let word of wordMap) {\n    if (word.getValue() >\
    \ maxValue) {\n      maxValue = word.getValue();\n      maxWord = word.getKey();\n\
    \    }\n  }\n  return maxWord;\n}\n", "    let max: number = 0;\n    let unique:\
    \ string[] = [];\n\n    for (const word of words) {\n        if (unique.includes(word))\
    \ {\n            continue;\n        }\n\n        for (const character of word)\
    \ {\n            if (unique.includes(character)) {\n                continue;\n\
    \            }\n\n            unique.push(character);\n\n            if (unique\
    \ === word) {\n                max = Math.max(max, word.length);\n           \
    \ }\n        }\n    }\n\n    return words.find(word => word.length === max) ?\
    \ word[max] : \"\";\n}\n", "    let maxCount = 0, maxCountWord = \"\";\n    for\
    \ (let word of words) {\n        let length = word.length;\n        let count\
    \ = 0;\n        for (let char of word) {\n            let pos = word.indexOf(char);\n\
    \            if (pos > -1 && pos < length) {\n                count++;\n     \
    \       }\n        }\n        if (count > maxCount) {\n            maxCount =\
    \ count;\n            maxCountWord = word;\n        }\n    }\n    return maxCountWord;\n\
    }", "    const hashMap: Map<string, number> = new Map();\n    words.forEach(word\
    \ => {\n        if (word.length !== 0) hashMap.set(word, word.length);\n    });\n\
    \    words.forEach(word => {\n        if (hashMap.get(word) === undefined) {\n\
    \            hashMap.set(word, 1);\n        } else {\n            hashMap.set(word,\
    \ hashMap.get(word) + 1);\n        }\n    });\n\n    let maxCount: number;\n \
    \   let maxCountWord: string;\n    for (const [key, value] of hashMap) {\n   \
    \     if (maxCount === undefined || value > maxCount) {\n            maxCount\
    \ = value;\n            maxCountWord = key;\n        }\n    }\n    return maxCountWord;\n\
    }\n</code>\n<|/ a dscore=1 tags=c#,data-structures,algorithm |>\n<| c |>\nWhy\
    \ does the code need to contain some kind of hashmap as opposed to just using\
    \ a hashset? Also please don't use \"var\" for everything. Also I suggest you\
    \ clean up your answer, add some code comments and maybe describe what the code\
    \ does.\n<|/ c |>\n<| c |>\nI agree, this is a very poor answer.\n<|/ c |>\n<|\
    \ a tags=c#,data-structures,algorithm |>\nHere is a C# program that does the job:\n\
    <code>\nusing System;\nusing System.Collections.Generic;\n\nnamespace Test\n{\n\
    \    class Program\n    {\n        static void Main(string[] args)\n        {\n\
    \            string[] words = { \"a\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\"\
    , \"b\", \"c\", \"d\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"\
    \ };\n            List<string> result = new List<string>();\n            char\
    \ last = words[0];\n\n            for (int i = 1; i < words.Length; i++)\n   \
    \         {\n                if (words[i] == last)\n                {\n      \
    \              result.Add(words[i]);\n                }\n                else\n\
    \                {\n                    result.Add(words[i] + \" \" + result.Count);\n\
    \                    last = words[i];\n                }\n            }\n\n  \
    \          Console.WriteLine(result[0]);\n        }\n    }\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\nC# version (inspired by):\n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\n\npublic class Program\n{\n    public static void\
    \ Main()\n    {\n        string [] input = {\"a\",\"a\",\"a\",\"a\",\"a\",\"b\"\
    ,\"b\",\"b\",\"c\",\"d\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\"};\n \
    \       var result = input\n            .GroupBy(x => x)\n            .OrderByDescending(g\
    \ => g.Count())\n            .SelectMany(g => ", "  let maxCount = 0;\n  let maxWord\
    \ = '';\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n\
    \    let count = count(words);\n    if (count > maxCount) {\n      maxCount =\
    \ count;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n}\n", "  let maxCount\
    \ = -1;\n  let maxIndex: number = 0;\n\n  for (let i = 0; i < words.length; i++)\
    \ {\n    let count = 1;\n    let word = words[i];\n\n    for (let j = i; j < words.length;\
    \ j++) {\n      if (words[j].indexOf(word) > 0) {\n        count += 1;\n     \
    \ }\n    }\n\n    if (count > maxCount) {\n      maxCount = count;\n      maxIndex\
    \ = i;\n    }\n  }\n\n  return words[maxIndex];\n}\n", "  // Write your code here.\n\
    \  let characters = words[0].length;\n  for(let word of words) {\n    characters\
    \ = Math.max(characters, word.length);\n  }\n  for(let word of words) {\n    characters.sort(function(a,b){return\
    \ a.length-b.length;});\n    return word;\n  }\n}", "  let hash: Map<string, number>\
    \ = new Map();\n  words.forEach(word => {\n    if (word.charCodeAt(0) === word.charCodeAt(word.length\
    \ - 1)) {\n      hash.set(word, 0);\n    } else {\n      let curCount = 1;\n \
    \     word.split(\"\").forEach((curChar, i) => {\n        if (curCount === hash.get(curChar))\
    \ {\n          curCount++;\n        } else {\n          hash.set(curChar, curCount);\n\
    \          curCount = 1;\n        }\n      });\n      hash.set(word, curCount);\n\
    \    }\n  });\n  let maxCount = 0;\n  let maxWord = \"\";\n  for (let [word, curCount]\
    \ of hash.entries()) {\n    if (maxCount < curCount) continue;\n    if (maxCount\
    \ === curCount) maxWord = word;\n    maxCount = curCount;\n  }\n  return maxWord;\n\
    }\n", "  let max_count = 0;\n  let res = \"\";\n  for (let i = 0; i < words.length;\
    \ i++) {\n    let word = words[i];\n    let count = countchars(word);\n    if\
    \ (count > max_count) {\n      res = word;\n      max_count = count;\n    }\n\
    \  }\n  return res;\n}\n", "    return find_max_impl<string>(words);\n}\n", " \
    \   if (words.length === 0) {\n        throw new Error(\"Cannot find the max word\
    \ - array is empty.\");\n    }\n    var maximum: any = words[0],\n        maximumIndex\
    \ = 0,\n        thisCount: number = 1;\n    for (var i = 1; i < words.length;\
    \ i++) {\n        var word = words[i];\n        if (word.length !== maximum.length)\
    \ {\n            break;\n        }\n        var currentCount: number = countUniqueChars(word);\n\
    \        if (currentCount > thisCount) {\n            maximum = word;\n      \
    \      maximumIndex = i;\n            thisCount = currentCount;\n        }\n \
    \   }\n    return maximum;\n}\n", "  var max = \"\"\n  var count = 1\n  words.forEach(function(word:\
    \ string) {\n    if (!word.length) return\n    if (!max) max = word\n    else\
    \ if (word.split(\"\").every(function(c: any) {\n        return max.split(\"\"\
    ).indexOf(c) == -1\n      })) {\n      max = word\n      count = 1\n    } else\
    \ {\n      count += word.split(\"\").length\n    }\n  })\n  return max\n}\n",
  "  const count = {};\n  words.forEach(word => {\n    word.split('').forEach(character\
    \ => {\n      count[character] = (count[character] || 0) + 1;\n    });\n  });\n\
    \  let maxKey = Object.keys(count).reduce((maxKey, character) => {\n    return\
    \ count[maxKey] > count[character] ? character : maxKey;\n  }, Object.keys(count)[0]);\n\
    \  return words[words.findIndex(word => {\n    return word.split('').findIndex(character\
    \ => {\n      return count[character] === word.split('').indexOf(maxKey);\n  \
    \  }) >= 0;\n  })];\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for your help guys!\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  let longest = words[0];\n  for (let i\
    \ = 1; i < words.length; i++) {\n    if (words[i].length >= longest.length) {\n\
    \      longest = words[i];\n    }\n  }\n  return longest;\n}\n", "  //Your code\
    \ here\n  let max = 0;\n  let str = \"\";\n  for (let i = 0; i < words.length;\
    \ i++) {\n    let temp = 1;\n    let temp2 = 0;\n    for (let j = 0; j < words[i].length;\
    \ j++) {\n      if (temp >= temp2) {\n        temp2 = temp;\n        temp2 = temp2;\n\
    \      }\n      if (words[i].charAt(j) === words[i].charAt(temp2)) {\n       \
    \ temp++;\n      }\n    }\n    if (temp > max) {\n      max = temp;\n      str\
    \ = words[i];\n    }\n  }\n  return str;\n}\n", "    var maxChars = -1;\n    var\
    \ maxWord = null;\n    for (var i = 0; i < words.length; i++) {\n        var word\
    \ = words[i];\n        if (maxChars < word.length) { maxChars = word.length; maxWord\
    \ = word; }\n    }\n    return maxWord;\n}\n", "  console.log(words);\n  let max\
    \ = 1;\n  for (let i = 0; i < words.length; i++) {\n    for (let j = 0; j < words[i].length;\
    \ j++) {\n      if (words[i].length > max) {\n        max = words[i].length;\n\
    \      }\n    }\n  }\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].length\
    \ == max) {\n      return words[i];\n    }\n  }\n  console.log(\"Error\");\n}",
  "\tlet countMap: { [key: string]: number } = {};\n\tfor (let i = 0; i < words.length;\
    \ i++) {\n\t\tlet word = words[i];\n\t\tif (!countMap[word]) countMap[word] =\
    \ 1;\n\t\telse countMap[word]++;\n\t}\n\n\tlet maxCount = 0;\n\tlet maxWord =\
    \ \"\";\n\n\tfor (let i = 0; i < words.length; i++) {\n\t\tlet word = words[i];\n\
    \t\tlet count = countMap[word];\n\t\tif (count > maxCount) {\n\t\t\tmaxCount =\
    \ count;\n\t\t\tmaxWord = word;\n\t\t}\n\t}\n\n\treturn maxWord;\n}\n", "  var\
    \ longest = words[0];\n\n  for (var i = 1; i < words.length; i++) {\n    if (longest\
    \ === words[i]) {\n      continue;\n    } else if (longest < words[i]) {\n   \
    \   longest = words[i];\n    }\n  }\n  return longest;\n}\n", "    const unique\
    \ = new Set(words);\n    let max = unique.values().sort().pop();\n    for (const\
    \ word of unique) {\n        const count = word.split(\"\").length;\n        if\
    \ (max < count) {\n            max = count;\n        }\n    }\n    return max\
    \ < unique.values().sort().shift() ? unique.values().sort().shift() : max;\n}\n",
  "  const obj = {};\n  for (let word of words) {\n    const len = word.length;\n\
    \    obj[word] = (obj[word] || 0) + 1;\n  }\n  let max = 0;\n  for (const key\
    \ in obj) {\n    if (max < obj[key]) {\n      max = obj[key];\n    }\n  }\n  return\
    \ words[0];\n}\n", "  //  Your code here!\n  \n  const count = {};\n  for (let\
    \ i = 0; i < words.length; ++i) {\n    const word = words[i];\n    if (count[word]\
    \ == null) {\n      count[word] = 1;\n    } else {\n      count[word] += 1;\n\
    \    }\n  }\n\n  let maxKey = -1;\n  let maxCount = 0;\n  for (const key in count)\
    \ {\n    if (count[key] > maxCount) {\n      maxKey = key;\n      maxCount = count[key];\n\
    \    }\n  }\n\n  return maxKey;\n}\n", "    let longest = 0;\n    let longestIndex\
    \ = 0;\n    let currentWord: string;\n    words.sort((a, b) => {\n        return\
    \ a.length - b.length;\n    });\n    for (let i = 0; i < words.length; ++i) {\n\
    \        currentWord = words[i];\n        for (let j = 0; j < currentWord.length;\
    \ ++j) {\n            if (words[i] === currentWord) {\n                ++longest;\n\
    \                if (longest > longestIndex) {\n                    longestIndex\
    \ = i;\n                }\n                break;\n            }\n        }\n\
    \    }\n    return words[longestIndex];\n}", "  let uniques: number[] = [],\n\
    \    maximum = 0,\n    word = \"\";\n\n  words.forEach(word => {\n    const unique\
    \ = uniques.filter(value => value === word.length)[0];\n\n    if (unique < maximum)\
    \ {\n      maximum = unique;\n      word = word;\n    }\n\n    if (!uniques.includes(word.length))\
    \ {\n      uniques.push(word.length);\n    }\n  });\n\n  return word;\n}\n", " \
    \ words.sort();\n  let max = 0;\n  let i = 0;\n  while (i < words.length) {\n\
    \    max = Math.max(max, words[i].length);\n    i++;\n  }\n  let res = words[i];\n\
    \  return res;\n}\n", "  const dict = Object.create(null);\n  words.forEach(str\
    \ => {\n    dict[str] = dict[str] ? dict[str] + 1 : 1;\n  });\n  let max_key =\
    \ Object.keys(dict).sort((a, b) => dict[a] - dict[b]).pop();\n  for (let key of\
    \ Object.keys(dict)) {\n    if (dict[key] === dict[max_key]) {\n      max_key\
    \ = key;\n    }\n  }\n  return dict[max_key];\n}\n", "  let result = \"\";\n \
    \ for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let\
    \ count = 0;\n    let lastIndex = word.length - 1;\n    for (let j = 0; j <= lastIndex;\
    \ j++) {\n      if (word.charAt(j) == word.charAt(j + 1)) count++;\n      else\
    \ break;\n    }\n    if (count == 0) continue;\n    if (count > result.length)\
    \ {\n      result = word;\n    }\n  }\n  return result;\n}\n", "  const max: number\
    \ = words.length;\n  let counter: number = 0;\n  let lastword: string;\n  let\
    \ maxchars: number = 0;\n  let str: string;\n  for (let i = 0; i < max; i++) {\n\
    \    str = words[i];\n    lastword = words[i - 1];\n    counter += lastword.length\
    \ + 1;\n    maxchars = Math.max(maxchars, counter);\n  }\n  return maxchars ==\
    \ 0 ? words[0] : words[max - maxchars];\n}\n", "  let counter: Map<string, number>\
    \ = new Map()\n  let maxWord: string = \"\"\n\n  for (let word of words) {\n \
    \   if (counter.has(word)) {\n      counter.set(word, counter.get(word) + 1)\n\
    \    } else {\n      counter.set(word, 1);\n    }\n  }\n\n  for (let [key, value]\
    \ of counter.entries()) {\n    if (value > maxWord.length) {\n      maxWord =\
    \ key;\n    }\n  }\n\n  return maxWord;\n}\n", "    // sort\n    words.sort((a:\
    \ string | null, b: string | null) => {\n        if (a === null) { return 1; }\n\
    \        if (b === null) { return -1; }\n        return a.length - b.length;\n\
    \    });\n\n    // find first with max characters\n    let max: string | null\
    \ = words[0];\n    for (const word of words) {\n        let unique = 1;\n    \
    \    let i: number = 0;\n        while (i < word.length && word[i] === max[i])\
    \ {\n            i++;\n            unique++;\n        }\n        if (unique >=\
    \ max.length) { max = word; }\n    }\n    return max;\n}\n", "  const chars =\
    \ new Set<string>();\n  for (let i = 0; i < words.length; i++) {\n    const word\
    \ = words[i];\n    const char = word.split(\"\")\n      .map((char) => char.toLowerCase())\n\
    \      .join();\n    if (chars.has(char)) {\n      chars.delete(char);\n    }\
    \ else {\n      chars.add(char);\n    }\n  }\n  return Array.from(chars)\n   \
    \ .reduce((a, b) => (a.length > b.length ? a : b), \"\")\n    .toLowerCase();\n\
    }\n", "  const words = sortArrayByLengthDesc(words);\n  let maxCount = -1;\n \
    \ let maxWord = '';\n  let curCount = 0;\n  for (let word of words) {\n    curCount\
    \ = 0;\n    for (let i = 0; i < word.length; i++) {\n      curCount += word.charCodeAt(i);\n\
    \    }\n    if (curCount > maxCount) {\n      maxCount = curCount;\n      maxWord\
    \ = word;\n    }\n  }\n  return maxWord;\n}\n", "  let map = {};\n  let i = 0;\n\
    \  let max: number = 0;\n\n  words.forEach((word) => {\n    map[word] = word.length;\n\
    \  });\n  for (let key in map) {\n    if (map.hasOwnProperty(key)) {\n      if\
    \ (map[key] > max) {\n        max = 0;\n      }\n      i++;\n      if (map[key]\
    \ === max) {\n        return key;\n      }\n    }\n  }\n  return words[0];\n}\n",
  "  let max;\n  const result: Array<string> = [];\n  for (let i = 0; i < words.length;\
    \ i++) {\n    let word: string = words[i];\n    let count: number = 0;\n    for\
    \ (let j = 0; j < word.length; j++) {\n      if (result.includes(word[j])) {\n\
    \        count += 1;\n      }\n    }\n    if (count > max) {\n      max = count;\n\
    \      result = word;\n    }\n  }\n  return result[0] || \"\";\n}", "  let maxCount\
    \ = 0;\n  const highestIndex = new Array();\n  const highestCount = new Array();\n\
    \  words.forEach((word: string) => {\n    let count = 0;\n    for (const char\
    \ of word) {\n      if (highestCount[char]) {\n        count += highestCount[char];\n\
    \      } else {\n        highestCount[char] = count;\n        highestIndex.push(char);\n\
    \      }\n    }\n    maxCount = Math.max(count, maxCount);\n  });\n  return highestIndex[highestCount.indexOf(maxCount)];\n\
    }\n", "  return words[0];\n}\n", "  let maxCount: number = words[0].length;\n\
    \  for (let i = 1; i < words.length; i++) {\n    let curCount: number = words[i].length;\n\
    \    if (curCount > maxCount) {\n      maxCount = curCount;\n    }\n  }\n  let\
    \ maxWord: string = words[0];\n  for (let i = 1; i < words.length; i++) {\n  \
    \  let curCount: number = words[i].length;\n    if (curCount === maxCount) {\n\
    \      maxWord = words[i];\n    }\n  }\n  return maxWord;\n}\n", "    let maxCount\
    \ = 0;\n    let maxWord = \"\";\n    for (let i = 0; i < words.length; i++) {\n\
    \        let count = unique_count(words[i]);\n        if (count > maxCount) {\n\
    \            maxCount = count;\n            maxWord = words[i];\n        }\n \
    \   }\n    return maxWord;\n}\n", "    let numUniqueChars = words.length * words[0].length;\n\
    \    let maxWord: string = null;\n    let maxNumUniqueChars = 0;\n    for (let\
    \ i = 0; i < words.length; i++) {\n        let word = words[i];\n        for (let\
    \ j = 0; j < word.length; j++) {\n            if (numUniqueChars < word[j].length)\
    \ { numUniqueChars = word[j].length; }\n            if (maxNumUniqueChars < numUniqueChars)\
    \ {\n                maxWord = word;\n                maxNumUniqueChars = numUniqueChars;\n\
    \            }\n        }\n    }\n    return maxWord;\n}\n", "  let word: string;\n\
    \  let count: number;\n  let max_num: number;\n\n  let unique_chars: number[]\
    \ = [];\n  for (let i = 0; i < words.length; i++) {\n    const current_word =\
    \ words[i];\n    const current_unique_chars = unique_chars.length;\n    count\
    \ = current_unique_chars;\n    max_num = current_unique_chars;\n    unique_chars.length\
    \ = 0;\n\n    for (let j = 0; j < current_word.length; j++) {\n      const char\
    \ = current_word[j];\n\n      if (unique_chars.indexOf(char) === -1) {\n     \
    \   unique_chars.push(char);\n        count++;\n      }\n\n      if (count > max_num)\
    \ {\n        word = current_word;\n        max_num = count;\n      }\n    }\n\
    \  }\n\n  return word;\n}\n\nconsole.log(find_max([\"name\", \"enam\", \"game\"\
    ])); // \"enam\"\nconsole.log(find_max([\"aaaaaaa\", \"bb\", \"cc\"])); // \"\
    aaaaaaa\"\nconsole.log(find_max([\"aaaaaaa\", \"bb\", \"ccc\"])); // \"bb\"\n\
    console.log(find_max([\"aaaaa\", \"bb\", \"cc\"])); // \"aa\"\nconsole.log(find_max([\"\
    a\", \"b\", \"c\"])); // \"a\"</code>\n<|/ a |>\n<| a dscore=0 |>\nYou can try\
    \ this solution using only map and reduce:\n\n<code>", "  let max_value = words[0].split(\"\
    \").reduce((a, b) => {\n    if (a.length < b.length) return b\n    return a\n\
    \  })\n\n  let max_len = 0\n  let max_index = -1\n  for (let i = 0; i < words.length;\
    \ i++) {\n    const word = words[i]\n    for (let j = 0; j < word.length; j++)\
    \ {\n      if (max_value.indexOf(word[j]) == -1 && max_len < j + 1) {\n      \
    \  max_value = word[j]\n        max_len = j + 1\n        max_index = i\n     \
    \ }\n    }\n  }\n  return words[max_index]\n}\n", "  let maxChars = words[0].length;\n\
    \  for (let i = 1; i < words.length; i++) {\n    if (words[i].length < maxChars)\
    \ {\n      return words[0];\n    }\n    maxChars = words[i].length;\n  }\n  return\
    \ words[0];\n}\n", "    var maxVal = 0;\n    var result: string = null;\n    for\
    \ (var i = 0; i < words.length; i++) {\n        var val = words[i].length;\n \
    \       if (val > maxVal) {\n            maxVal = val;\n            result = words[i];\n\
    \        }\n    }\n    return result;\n}\n", "  // Write your code here\n  let\
    \ set = new Set();\n  for (let word of words) {\n    set.add(word);\n  }\n  let\
    \ max = null;\n  for (let word of words) {\n    if (set.has(word)) {\n      if\
    \ (max === null || word.length < max) {\n        max = word.length;\n      }\n\
    \      set.delete(word);\n    } else {\n      set.add(word);\n    }\n  }\n  return\
    \ max;\n}\n", "  // Create a dictionary to store the characters\n  const dict\
    \ = new Map<string, number>();\n  // Scan the array and store the occurence of\
    \ each character\n  for (let i = 0; i < words.length; i++) {\n    const word =\
    \ words[i];\n    for (let j = 0; j < word.length; j++) {\n      // Increment the\
    \ counter of current character in dictionary\n      dict.set(word[j], dict.get(word[j])\
    \ + 1);\n    }\n  }\n  // Get the key for max value\n  const key = dict\n    .toList()\n\
    \    .reduce((acc, val) => val > acc ? val : acc);\n  // Get the word with max\
    \ number of occurence of character\n  return words\n    .filter((word) => word.length\
    \ === key.length)\n    .map((word) => word.slice(0, key.length))\n    .sort((w1,\
    \ w2) => w1.localeCompare(w2))[0]; // Returns the first string\n}", "    let sorted\
    \ = words.slice().sort();\n    let max: number = 1;\n    let current: string;\n\
    \    for (let i = 0; i < sorted.length; i++) {\n        current: string = sorted[i];\n\
    \        if (current === sorted[0]) {\n            max = Math.max(max, i + 1);\n\
    \        }\n        if (i === sorted.length - 1) {\n            max = Math.max(max,\
    \ current.length);\n        }\n    }\n    return sorted[max];\n}\n", "  let counter\
    \ = 0;\n  let max = 0;\n  let res = \"\";\n  for (let i = 0; i < words.length;\
    \ i++) {\n    if (words[i].length > max) {\n      max = words[i].length;\n   \
    \   res = words[i];\n    }\n    counter = 0;\n    for (let j = 0; j < words[i].length;\
    \ j++) {\n      counter += 1;\n      if (counter > max) break;\n    }\n  }\n \
    \ return res;\n}\n", "  let maxCount = 0;\n  let maxStr = \"\";\n  for (let i\
    \ = 0; i < words.length; i++) {\n    if (words[i].length > maxCount) {\n     \
    \ maxCount = words[i].length;\n      maxStr = words[i];\n    }\n  }\n  return\
    \ maxStr;\n}", "    const result = {};\n    const sortedWords = words.sort();\n\
    \    for (let i = 0; i < sortedWords.length; i++) {\n        const word = sortedWords[i];\n\
    \        if (result[word]) {\n            result[word]++;\n        } else {\n\
    \            result[word] = 1;\n        }\n    }\n    const maxKey = Object.keys(result).sort((a:\
    \ any, b: any) => result[b] - result[a]).pop();\n    return maxKey;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nthank you very much for your answer. I tried to use\
    \ your code. it works fine with test data but when I try to apply it to my test\
    \ data, it produces wrong answer. Here is the test data: https://www.dropbox.com/s/3h4h8o1ljzk5z4i/test.json?dl=0\n\
    <|/ c |>\n<| c |>\nI tried to copy paste your json to test.json but it produces\
    \ null as output. Can you please try it on your system? Here is the test data:\
    \ https://www.dropbox.com/s/3h4h8o1ljzk5z4i/test.json?dl=0\n<|/ c |>\n<| c |>\n\
    I tested it in codesandbox and it works perfectly. Here is your codesandbox link\
    \ https://codesandbox.io/s/goofy-glitter-zq9kd?file=/src/test.ts\n<|/ c |>\n<|\
    \ c |>\nthank you very much. your code is working fine with test data but when\
    \ I try to apply it to my data it produces wrong answer. Here is the data: `\"\
    name\" : [\n    \"John\",\n    \"Ana\",\n    \"Paul\",\n    \"Chris\",\n    \"\
    Mary\",\n    \"Ana\",\n    \"Jack\"\n  ],`  Here is the data I am applying your\
    \ code to: https://www.dropbox.com/s/3h4h8o1ljzk5z4i/test.json?dl=0  Here is the\
    \ answer I am getting: https://www.dropbox.com/s/r4kfz8o5w9yw4k3/answer.txt?dl=0\n\
    <|/ c |>\n<| c |>\nI think I understood now and you are looking for [this](https://stackoverflow.com/a/53544919/2430549)\
    \ answer.\n<|/ c |>\n<| a |>\nThis one works perfectly. \n<code>", "  const obj\
    \ = {};\n  let maxLen = 0;\n  let minLen = words.length;\n  for (let i = 0; i\
    \ < words.length; i++) {\n    const currentString = words[i];\n    const count\
    \ = (obj[currentString] || 0) + 1;\n    obj[currentString] = count;\n    maxLen\
    \ = Math.max(maxLen, currentString.length);\n    minLen = Math.min(minLen, currentString.length);\n\
    \    if (count === 0) {\n      continue;\n    }\n  }\n  for (let i = 0; i < words.length;\
    \ i++) {\n    const currentString = words[i];\n    const count = (obj[currentString]\
    \ || 0) + 1;\n    if (count === 0) {\n      continue;\n    }\n    const lastString\
    \ = words[i - 1];\n    const lastCount = obj[lastString] || 0;\n    const maxCount\
    \ = Math.max(count - lastCount, 0);\n    const minCount = Math.min(count - lastCount,\
    \ words[i].length);\n    const index = maxCount >= minCount ? i : i - 1;\n   \
    \ obj[currentString] = count;\n    return words[index];\n  }\n  return null;\n\
    }\n", "    let max: number = 0;\n    let word: string;\n    for (let i = 0; i\
    \ < words.length; i += 1) {\n        const curr = words[i];\n        const found:\
    \ number = 0;\n        for (let j = 0; j < words.length; j += 1) {\n         \
    \   const next = words[j];\n            if (i === j) {\n                continue;\n\
    \            }\n            const unique = uniqueCount(curr, next);\n        \
    \    if (unique > found) {\n                found = unique;\n                max\
    \ = i;\n                word = next;\n            }\n        }\n    }\n    return\
    \ word;\n}\n", "  let counter: number = 0;\n  let maxLength: number = 0;\n  let\
    \ word: string;\n  let maxWord: string;\n  for (let i = 0; i < words.length; i++)\
    \ {\n    const word = words[i];\n    const length = word.length;\n    if (counter\
    \ === 0) {\n      counter = length;\n      maxLength = length;\n    } else {\n\
    \      counter--;\n    }\n    if (counter === 0) {\n      continue;\n    }\n \
    \   if (length > maxLength) {\n      maxLength = length;\n      maxWord = word;\n\
    \    }\n  }\n  return maxWord;\n}\n", "  var result = \"\";\n  var max = 0;\n\
    \  var index;\n  for (var i = 0; i < words.length; i++) {\n    for (index = 0;\
    \ index < words[i].length; index++) {\n      var count = 0;\n      for (var j\
    \ = 0; j < words.length; j++) {\n        if (words[j][index] == words[i][index])\
    \ {\n          count++;\n        }\n      }\n      if (count > max) {\n      \
    \  result = words[i];\n        max = count;\n      }\n    }\n  }\n  return result;\n\
    }\n", "  return words.reduce((acc, cur) => {\n    const uniqueCharCount = acc.reduce((acc,\
    \ cur) => acc + cur.count, 0);\n    if (uniqueCharCount > words[0].count) return\
    \ acc;\n    acc.push({\n      word: cur,\n      count: uniqueCharCount,\n    });\n\
    \    return acc;\n  }, []).sort((a, b) => b.count - a.count).map(w => w.word)[0];\n\
    }\n", "  let max: number = words.length;\n  for (let i = 0; i < words.length;\
    \ i++) {\n    let count = words[i].length;\n    for (let j = i + 1; j < words.length;\
    \ j++) {\n      if (words[i].length < words[j].length) count--;\n      if (count\
    \ > max) {\n        max = count;\n        let current = words[i];\n        for\
    \ (let k = i + 1; k < words.length; k++) {\n          words[k] = words[k];\n \
    \       }\n        words[i] = current;\n      }\n    }\n  }\n  return words[words.length\
    \ - 1];\n}\n", "    // Write your code here\n    let maxCount = 0;\n    let maxWord\
    \ = \"\";\n    let sortArr = words.sort(function (a, b) {\n        return a.length\
    \ > b.length ? -1 : a.length < b.length ? 1 : 0;\n    });\n    for (var i = 0;\
    \ i < sortArr.length; i++) {\n        if (sortArr[i].length <= maxCount) {\n \
    \           maxCount = sortArr[i].length;\n            maxWord = sortArr[i];\n\
    \        }\n    }\n    return maxWord;\n}\n", "  let longest = \"\";\n  let maxCount\
    \ = 0;\n  for (const word of words) {\n    word = word.toLowerCase();\n    let\
    \ count = 0;\n    for (const c of word) {\n      if (c.charCodeAt(0) != c.charCodeAt(0))\
    \ {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      longest\
    \ = word;\n      maxCount = count;\n    }\n  }\n  return longest;\n}\n", "  var\
    \ result = \"\";\n  var map = new Map();\n  words.forEach(word => {\n    map.set(word,\
    \ map.get(word) || 0);\n    map.set(word, map.get(word) + 1);\n  });\n  map.forEach(value\
    \ => {\n    if (map.get(value) > result.length) result = value;\n  });\n  return\
    \ result;\n}\n", "  let max = 0;\n  let word = words[0].toLowerCase();\n  for\
    \ (let i = 0; i < words.length; i++) {\n    if (words[i].length >= word.length)\
    \ {\n      if (words[i].split(\"\").sort().join(\"\") === word) {\n        word\
    \ = words[i];\n      } else {\n        word = \"aaa\";\n      }\n    } else {\n\
    \      word = \"aaa\";\n    }\n    if (word.length > max) {\n      max = word.length;\n\
    \    }\n  }\n  return word;\n}\n", "  const wordsMap = new Map<string, number>();\n\
    \  for (const word of words) {\n    const chars = word.split('');\n    let maxChars\
    \ = 0;\n    let cur = 0;\n    for (const char of chars) {\n      const num = wordsMap.get(char);\n\
    \      if (num === undefined) {\n        wordsMap.set(char, 1);\n        cur++;\n\
    \      } else {\n        if (num > maxChars) {\n          maxChars = num;\n  \
    \        cur = 0;\n        }\n      }\n    }\n    if (maxChars > 0) {\n      wordsMap.set(word,\
    \ maxChars + cur);\n    }\n  }\n  let maxChars = 1;\n  for (const [key, val] of\
    \ wordsMap.entries()) {\n    if (val > maxChars) {\n      maxChars = val;\n  \
    \  }\n  }\n  return Array.from(wordsMap.keys()).find(\n    (key) => wordsMap.get(key)\
    \ === maxChars,\n  );\n}", "  let max: number = words.length;\n  let cur: number\
    \ = words.length;\n  let maxword: string = words[0];\n  let maxcnt: number = words[0].length;\n\
    \n  for (let i = 1; i < words.length; i++) {\n    for (let j = 0; j < words[i].length;\
    \ j++) {\n      let cnt: number = words[i].length;\n      if (cnt > maxcnt) {\n\
    \        max = i;\n        maxword = words[max];\n        maxcnt = words[max].length;\n\
    \      } else if (cnt === maxcnt) {\n        if (words[i][j] > maxword[j]) {\n\
    \          maxcnt = words[i][j];\n          maxword = words[max];\n        }\n\
    \      }\n    }\n  }\n  return maxword;\n}", "    return words[words.length -\
    \ 1];\n}\n", "\tlet maxCount = 0;\n\tlet maxCountWord: string;\n\n\twords.forEach(word\
    \ => {\n\t\tlet count = word.length; //count the characters in the word\n\t\t\
    if (count > maxCount) {\n\t\t\tmaxCount = count; //reset the max count in case\
    \ it changed after this word\n\t\t\tmaxCountWord = word; //save the word with\
    \ the max count\n\t\t}\n\t});\n\n\treturn maxCountWord; //return the word with\
    \ the max number of unique characters\n}\n", "  let highest = words[0].length;\n\
    \  let best = \"\";\n  for (const word of words) {\n    if (word.length > highest)\
    \ {\n      highest = word.length;\n      best = word;\n    }\n  }\n  return best;\n\
    }\n", "  // Initialize a map with all characters as key and\n  // number of occurrences\
    \ as value.\n  // We will iterate over the words to find the word\n  // with max\
    \ number of characters.\n  const char_count: Map<char, number> = new Map();\n\
    \  for (let word of words) {\n    for (let char of word) {\n      // If the map\
    \ doesn't have the char, initialize the\n      // value to 0 and then increment\
    \ the value.\n      if (!char_count.has(char)) {\n        char_count.set(char,\
    \ 0)\n      }\n      char_count.set(char, char_count.get<char>(char) + 1)\n  \
    \  }\n  }\n\n  // Iterate over the map and get the word which has the max number\
    \ of characters.\n  // If we find more than one such words, return the first one.\n\
    \  for (let char of char_count.keys()) {\n    if (char_count.get<char>(char) >\
    \ 1) {\n      return words[char_count.entries()].find(word => word.indexOf(char)\
    \ >= 0);\n    }\n  }\n}\n</code>\n<|/ a |>\n<| a |>\n<code>", "    if (words.length\
    \ === 0) return \"\";\n\n    let max = 0;\n    let maxIndex = 0;\n\n    for (let\
    \ i = 0; i < words.length; i++) {\n        const currentCounts = words.map((word)\
    \ => word.length).sort((a, b) => a - b);\n\n        if (currentCounts[0] > max)\
    \ {\n            maxIndex = i;\n            max = currentCounts[0];\n        }\
    \ else if (currentCounts[0] === max) {\n            if (currentCounts[1] > max)\
    \ {\n                maxIndex = i;\n                max = currentCounts[1];\n\
    \            }\n        }\n    }\n\n    return words[maxIndex];\n}\n", "  let\
    \ max = 0;\n  let index = 0;\n  for (let i = 0; i < words.length; i++) {\n   \
    \ const length = words[i].length;\n    if (length >= max) {\n      max = length;\n\
    \      index = i;\n    }\n  }\n  return words[index];\n}\n", "  let max_len =\
    \ words.length;\n  let max_len_index = 0;\n\n  let count = 0;\n\n  for (let i\
    \ = 0; i < max_len; ++i) {\n    for (let j = 0; j < max_len; ++j) {\n      if\
    \ (words[i] < words[j]) {\n        continue;\n      }\n\n      if (max_len_index\
    \ < j) {\n        max_len_index = j;\n      }\n\n      count += 1;\n    }\n  }\n\
    \n  return words[max_len_index];\n}\n", "    let count = {};\n    let max = \"\
    \";\n    for (let word of words) {\n        let c = count[word] || 0;\n      \
    \  count[word] = c + 1;\n        max = word.length > max ? word : max;\n    }\n\
    \    return max;\n}\n", "  return words.reduce((max_word, word) => {\n    const\
    \ count_character = word.reduce(\n      (acc, curr) => acc.concat((acc.length\
    \ > curr.length ? acc : curr)),\n      [],\n    );\n    return count_character.length\
    \ === word.length ? max_word : word;\n  }, '');\n}\n", "  const unique = new Set<string>();\n\
    \  unique.add(words[0]);\n  for (const word of words) {\n    if (unique.has(word))\
    \ {\n      continue;\n    }\n    let maxIndex = 0;\n    for (let i = 1; i < word.length;\
    \ ++i) {\n      if (word[i] !== word[maxIndex]) {\n        maxIndex = i;\n   \
    \   }\n    }\n    unique.add(word[maxIndex]);\n  }\n  return unique.values().sort((a,\
    \ b) => a.length - b.length)[0];\n}\n", "  const map = new Map<string, number>()\n\
    \  const sortedWords = words.map(word => [word, map.get(word)] as [string, number])\n\
    \  sortedWords.sort((a, b) => {\n    return a[1] - b[1]\n  })\n  return sortedWords[0][0]\n\
    }\n", "    return findMax(words);\n}\n", "  const uniques: string[] = [];\n  for\
    \ (let i = 0; i < words.length; i++) {\n    const unique: any = {};\n    for (let\
    \ j = 0; j < words[i].length; j++) {\n      if (unique[words[i][j]] === undefined)\
    \ {\n        unique[words[i][j]] = 0;\n      } else {\n        unique[words[i][j]]\
    \ += 1;\n      }\n    }\n    uniques.push(unique);\n  }\n  const max: any = {};\n\
    \  let maxCount = 0;\n  for (let i = 0; i < uniques.length; i++) {\n    const\
    \ unique: any = uniques[i];\n    const keys = Object.keys(unique);\n    if (keys.length\
    \ > maxCount) {\n      maxCount = keys.length;\n      max = {};\n      for (let\
    \ j = 0; j < keys.length; j++) {\n        max[keys[j]] = unique[keys[j]];\n  \
    \    }\n    }\n  }\n  return max;\n}\n", "  let result = \"\";\n  let i = 0;\n\
    \n  for (; i < words.length; i++) {\n    let chars = words[i].split('');\n   \
    \ let maxCount: number = -1;\n\n    for (let j = 0; j < chars.length; j++) {\n\
    \      if (chars.hasOwnProperty(chars[j])) {\n        if (maxCount === -1) {\n\
    \          maxCount = chars[j];\n        } else {\n          if (maxCount > chars[j])\
    \ {\n            maxCount = chars[j];\n          }\n        }\n      }\n    }\n\
    \n    if (maxCount === words[i].length) {\n      result = words[i];\n    }\n \
    \ }\n\n  return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
