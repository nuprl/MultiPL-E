name: HumanEval_5_intersperse
language: ts
prompt: "//Insert a number 'delimeter' between every two consecutive elements of input\
  \ array `numbers'\n// >>> intersperse([], 4)\n// []\n// >>> intersperse([1, 2, 3],\
  \ 4)\n// [1, 4, 2, 4, 3]\nfunction intersperse(numbers: number[], delimeter: number):\
  \ number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = intersperse;\n  assert.deepEqual(candidate([], 7),[]);\n\
  \  assert.deepEqual(candidate([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2]);\n  assert.deepEqual(candidate([2,\
  \ 2, 2], 2),[2, 2, 2, 2, 2]);\n}\n\ntest();"
completions: ["  const length = numbers.length;\n  const newNumbers = Array();\n \
    \ for (let i = 0; i < length - 1; i++) {\n    newNumbers.push(numbers[i]);\n \
    \   newNumbers.push(delimeter);\n  }\n  newNumbers.push(numbers[length - 1]);\n\
    \  return newNumbers;\n}\n", "  if (numbers.length === 0) {\n    return [];\n\
    \  }\n\n  return numbers\n    .slice(0, numbers.length - 1)\n    .concat(delimeter,\
    \ numbers[numbers.length - 1]);\n}\n", "  const result: any[] = [];\n  if (numbers.length\
    \ <= 0) {\n    return result;\n  }\n  numbers.forEach((number, index) => {\n \
    \   if (index % 2 === 0) {\n      result.push(number);\n    } else {\n      result.push(delimeter,\
    \ number);\n    }\n  });\n  return result;\n}\n", "  numbers = [...numbers];\n\
    \  const [first, ...rest] = numbers;\n  return [...rest, first, ...intersperse(numbers.slice(1,\
    \ numbers.length), delimeter)];\n}\n", "  numbers = [].concat(numbers);\n  var\
    \ interspersedArray: any[] = [];\n  for (var i = 0; i < numbers.length; i += 2)\
    \ {\n    interspersedArray.push(numbers[i]);\n    interspersedArray.push(delimeter);\n\
    \    interspersedArray.push(numbers[i + 1]);\n  }\n  return interspersedArray;\n\
    }\n", "  if (numbers.length === 0) {\n    return numbers;\n  }\n  const result\
    \ = [] as number[];\n  let firstNumber = numbers[0]; // The first element is the\
    \ most convenient to work with\n  result.push(firstNumber);\n  for (let i = 1;\
    \ i < numbers.length; i++) {\n    const lastNumber = numbers[i - 1]; // The last\
    \ element is the least convenient to work with\n    result.push(delimeter + lastNumber);\n\
    \  }\n  return result;\n}\n</code>\nIt works by adding a delimeter in between\
    \ every two consecutive elements of the input array.\n<code>\nintersperse([1,\
    \ 2, 3, 4], 4)", "  if (delimeter === undefined || delimeter === null || delimeter\
    \ === '') return numbers;\n\n  const len = numbers.length;\n  const out = new\
    \ Array(len + 1);\n\n  for (let i = 0; i < len; ++i) out[i] = numbers[i];\n\n\
    \  out.splice(delimeter, len, ...numbers.slice(delimeter + 1));\n\n  return out;\n\
    }\n", "  const out: number[] = [];\n  for (let i = 0, length = numbers.length;\
    \ i < length; i++) {\n    out.push(numbers[i]);\n    if (i !== (length - 1)) {\n\
    \      out.push(delimeter);\n    }\n  }\n  return out;\n}\n", "  if (numbers.length\
    \ === 0) {\n    return [];\n  }\n  const count = numbers[0];\n  return numbers\n\
    \    .slice(0, 1)\n    .map((_, i) => {\n      return numbers.slice(i).reduce((acc,\
    \ cur, index) => acc + cur + delimeter, count);\n    });\n}\n", "  const numberStrings\
    \ = numbers.map((number) => String(number));\n  const result: string[] = [];\n\
    \n  const length = numberStrings.length;\n  for (let index = 0; index < length;\
    \ index += 2) {\n    result.push(numberStrings[index]);\n    result.push(delimeter);\n\
    \  }\n\n  return result.slice(0, result.length - 1);\n}\n", "  if (numbers.length\
    \ === 0) {\n    return numbers;\n  }\n\n  const firstNumber = numbers[0];\n  let\
    \ lastNumber: number | undefined = undefined;\n  let nextNumber: number | undefined\
    \ = undefined;\n\n  for (let i = 1; i < numbers.length; i++) {\n    const number\
    \ = numbers[i];\n    if (number !== nextNumber) {\n      if (lastNumber !== undefined)\
    \ {\n        return [firstNumber, ...intersperse(intersperse(numbers, delimeter),\
    \ delimeter), lastNumber];\n      }\n\n      return [firstNumber, number];\n \
    \   }\n\n    nextNumber = undefined;\n    lastNumber = number;\n  }\n\n  return\
    \ [firstNumber, ...intersperse(intersperse(numbers, delimeter), delimeter)];\n\
    }\n", "  const len = numbers.length;\n  const result = new Array(len + 1);\n \
    \ for (let i = 0; i < (len - 1); i++) {\n    result[i] = numbers[i];\n  }\n  result[len]\
    \ = numbers[len - 1];\n  return result;\n}\n", "  return numbers.reduce((acc,\
    \ val, i) => {\n    if (i === 0) {\n      return [val];\n    } else if (i > 0)\
    \ {\n      return acc.concat([val, delimeter]);\n    }\n    return acc;\n  },\
    \ []);\n}\n", "    const len = numbers.length;\n    if (len === 0) {\n       \
    \ return numbers;\n    }\n    if (delimeter.length === 0) {\n        delimeter\
    \ = numbers[0];\n    }\n    const result = [];\n    let i = 0;\n    let start\
    \ = numbers[i];\n    while (i < len) {\n        result.push(start);\n        if\
    \ (delimeter === start) {\n            result.push(delimeter);\n        }\n  \
    \      i += 1;\n        start = numbers[i];\n    }\n    return result;\n}", "\t\
    let result = [];\n\tfor (let i = 0; i < numbers.length; i++) {\n\t\tlet number\
    \ = numbers[i];\n\t\tif (number === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\t\
    result.push(number);\n\t\tif (i > 0) {\n\t\t\tresult.push(delimeter);\n\t\t}\n\
    \t}\n\treturn result;\n}\n", "  return numbers.reduce(\n    (acc, val) => {\n\
    \      acc.push(val);\n      acc.push(delimeter);\n      return acc;\n    },\n\
    \    []\n  );\n}\n", "  const result = [] as number[];\n  let i = 0;\n  const\
    \ length = numbers.length;\n\n  while (i < length) {\n    if (i === 0) {\n   \
    \   result.push(numbers[i++]);\n    }\n    if (i === length || numbers[i] ===\
    \ undefined) {\n      result.push(delimeter);\n    } else if (numbers[i] !== numbers[i\
    \ - 1]) {\n      result.push(numbers[i]);\n    }\n    i++;\n  }\n\n  return result;\n\
    }\n", "  return numbers.reduce(\n    (result: number[], currentNumber: number,\
    \ index: number) => {\n      if (index !== 0 && index % 2 === 0) {\n        result.push(currentNumber);\n\
    \        result.push(delimeter);\n      } else {\n        result.push(currentNumber);\n\
    \      }\n\n      return result;\n    },\n    []\n  );\n}\n", "  numbers = numbers.filter(number\
    \ => number !== '');\n  const interspersedNumbers = numbers.map((number, index)\
    \ => {\n    if (index < numbers.length - 1) {\n      return number + delimeter\
    \ + numbers[index + 1];\n    }\n    return number;\n  });\n  return interspersedNumbers;\n\
    }\n", "  return numbers.reduceRight((result, number, index, array) => {\n    result.push(number);\n\
    \    if (index !== array.length - 1) result.push(delimeter);\n    return result;\n\
    \  }, []);\n}\n", "    return numbers.reduce((intermediateResult: number[], currentValue:\
    \ number, currentIndex: number) => {\n        // If current index is not divisible\
    \ by the 'delimeter' then add it to the intermediate array\n        if (currentIndex\
    \ % delimeter !== 0) {\n            intermediateResult.push(currentValue);\n \
    \       } else {\n            intermediateResult.push(currentValue, numbers[currentIndex]);\n\
    \        }\n\n        // Return updated array\n        return intermediateResult;\n\
    \    }, []);\n}\n", "  numbers.push(delimeter);\n  return numbers.reduce((p, n)\
    \ => p.concat(n), []);\n}\n", "  const length: number = numbers.length;\n\n  if\
    \ (length === 0) {\n    return [];\n  }\n\n  const result: number[] = [];\n  let\
    \ number: number = numbers[0];\n\n  for (let i: number = 1; i < length; i++) {\n\
    \    number = numbers[i];\n    result.push(number);\n    if (number === delimeter)\
    \ {\n      result.push(number);\n    }\n  }\n\n  return result;\n}\n", "  const\
    \ results: number[] = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const\
    \ number = numbers[i];\n    if (numbers.length - 1 < i) {\n      results.push(number);\n\
    \    } else {\n      results.push(numbers[i - 1] + delimeter + number);\n    }\n\
    \  }\n  return results;\n}\n", "  return numbers.reduce(function(array, number)\
    \ {\n    const before = array.length ? delimeter : '';\n    const after = array.length\
    \ ? array.pop() : '';\n    return before + number + after;\n  }, []);\n}\n\nexport\
    \ default intersperse;\n\n<|/ file ext=.ts |>", "  numbers.push(...numbers.splice(0,\
    \ numbers.indexOf(delimeter))); // Add an interspersed `delimeter' between every\
    \ two consecutive elements of input array `numbers'\n  numbers.push(delimeter);\
    \ // Add an interspersed `delimeter' at the end of input array `numbers'\n  return\
    \ numbers;\n}\n", "  const numberLen = numbers.length;\n  let interspersed: number[]\
    \ = [];\n\n  for (let i = 0; i < numberLen - 1; i += 1) {\n    interspersed.push(numbers[i]);\n\
    \    interspersed.push(delimeter);\n    interspersed.push(numbers[i + 1]);\n \
    \ }\n\n  return interspersed;\n}\n", "  return numbers.reduce((acc, cur, i) =>\
    \ {\n    if (i !== 0) {\n      acc.push(delimeter);\n    }\n    acc.push(cur);\n\
    \    return acc;\n  }, []);\n}\n", "  const result = [];\n  for (let i = 1; i\
    \ < numbers.length; i += 1) {\n    result.push(numbers[i - 1]);\n    result.push(delimeter,\
    \ numbers[i]);\n  }\n  return result;\n}\n", "  const len = numbers.length\n \
    \ const newArray = []\n  for (let index = 0; index < len; index++) {\n    if (index\
    \ !== 0) {\n      newArray.push(delimeter)\n    }\n    newArray.push(numbers[index])\n\
    \  }\n  return newArray\n}\n", "  const result = [];\n\n  while (numbers.length\
    \ > 0) {\n    result.push(numbers[0]);\n\n    if (numbers.length > 1) {\n    \
    \  result.push(delimeter);\n    }\n\n    numbers = numbers.slice(1);\n  }\n\n\
    \  return result;\n}\n", "  return numbers.reduce(\n    (res: number[], num: number,\
    \ idx: number) => {\n      if (idx === 0) return [num];\n      if (idx === numbers.length\
    \ - 1) return [...res, delimeter, num];\n      return [...res, num];\n    },\n\
    \    [] as number[],\n  );\n}\n", "  const result: number[] = [];\n  for (let\
    \ i = 0; i < numbers.length; i++) {\n    result.push(numbers[i]);\n    if (i <\
    \ numbers.length - 1) {\n      result.push(delimeter);\n    }\n  }\n  return result;\n\
    }\n", "  let length = numbers.length;\n  if (numbers.length === 0) return numbers;\n\
    \  if (numbers.length === 1) return [numbers[0]].concat(intersperse([], delimeter));\n\
    \  return numbers.length ? intersperse([numbers[0]].concat(intersperse(numbers.slice(1),\
    \ delimeter)), delimeter) : [];\n}\n", "  return numbers.reduce((acc, curr) =>\
    \ [...acc, curr, ...(numbers.includes(curr) ? [] : [delimeter])], []);\n}\n",
  "  const result: number[] = []\n\n  for (let i = 0, length = numbers.length; i <\
    \ length; i++) {\n    result.push(numbers[i])\n    if (numbers[i] === delimeter)\
    \ {\n      result.push(numbers[++i])\n    }\n  }\n\n  return result\n}\n", "\t\
    let result = []\n\tlet length = numbers.length\n\tfor (let i = 0; i < length;\
    \ i++) {\n\t\tresult.push((numbers[i] as number) + delimeter)\n\t}\n\treturn result\n\
    }\n", "  const result: number[] = [];\n  for (let i = 0; i < numbers.length; i++)\
    \ {\n    result.push(numbers[i]);\n    if (i < numbers.length - 1) result.push(delimeter);\n\
    \  }\n  return result;\n}\n", "  let result = [];\n  numbers.forEach((num, i)\
    \ => {\n    result.push([...result, num, ...numbers.slice(i + 1)]);\n  });\n \
    \ result.forEach((part) => {\n    part[0] = delim;\n    part[part.length - 1]\
    \ = delim;\n  });\n  return result;\n}\n\nconsole.log(intersperse([1, 2, 3, 4,\
    \ 5], [1, 2]));", "  const result = numbers.slice();\n  let index = -1;\n  while\
    \ (++index < numbers.length) {\n    result.splice(index, 0, delimeter);\n  }\n\
    \  return result;\n}\n\nexport default intersperse;\n\n<|/ file filename=intersperse.ts\
    \ |><|endofmask|>source=gitlab ext=.ts |><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
  "  const output = [];\n  for (let i = 0, len = numbers.length; i < len; i++) {\n\
    \    output.push(numbers[i]);\n    if (i < len - 1) {\n      output.push(delimeter);\n\
    \    }\n  }\n  return output;\n}\n", "  if (isEmpty(numbers)) {\n    return [];\n\
    \  }\n\n  let result: number[] = numbers.map(function (num) {\n    return num;\n\
    \  });\n  result.unshift(delimeter);\n  return result;\n}\n", "  if (numbers.length\
    \ === 0) {\n    return numbers\n  }\n  const [first, ...rest] = numbers\n  return\
    \ first.concat(delimeter).concat(intersperse(rest, delimeter))\n}\n", "  const\
    \ result = [];\n  let prevNumber: number[] = [];\n\n  for (const num of numbers)\
    \ {\n    if (num === delimeter) {\n      if (prevNumber.length > 0) {\n      \
    \  result.push(prevNumber);\n      }\n\n      prevNumber = [];\n    } else {\n\
    \      prevNumber.push(num);\n    }\n  }\n\n  if (prevNumber.length > 0) {\n \
    \   result.push(prevNumber);\n  }\n\n  return result;\n}\n", "    const result\
    \ = [];\n    for (let i = 0, len = numbers.length; i < len; i += 2) {\n      \
    \  result.push(numbers[i]);\n        result.push(delimeter);\n        result.push(numbers[i\
    \ + 1]);\n    }\n    return result;\n}\n", "  let result = [];\n\n  for (let i\
    \ = 0, length = numbers.length; i < length; i++) {\n    result.push(numbers[i]);\n\
    \    if (i !== (length - 1)) {\n      result.push(delimeter);\n    }\n  }\n\n\
    \  return result;\n}\n", "  const result: number[] = [];\n  if (numbers.length\
    \ === 0) {\n    return result;\n  }\n  for (let i = 0; numbers.length > i; ++i)\
    \ {\n    const number = numbers[i];\n    if (numbers.length - i <= i) {\n    \
    \  result.push(number);\n    } else {\n      result[result.length - 1] += delimeter\
    \ + number;\n    }\n  }\n  return result;\n}\n", "  numbers = numbers || [];\n\
    \  delimeter = delimeter || 0;\n  var length = numbers.length;\n  var newArray:\
    \ number[] = [];\n\n  for (var i = 0; i < length; i += 1) {\n    var num: number\
    \ = numbers[i];\n    newArray.push(num);\n    if (i < length - 1) {\n      newArray.push(delimeter);\n\
    \    }\n  }\n\n  return newArray;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThis\
    \ is an example for ES6:\n\n<code>", "  const n = numbers.length\n  let result\
    \ = []\n  let i = 1\n\n  while (i < n) {\n    result.push(numbers[i])\n    i++\n\
    \    if (i < n) {\n      result.push(delimeter)\n    }\n  }\n  return result\n\
    }\n", "  return numbers.reduce(function(result, number) {\n    return result.concat(delimeter,\
    \ number);\n  }, []);\n}\n", "  return numbers.map((n, i) => [n, ...numbers.slice(i\
    \ + 1, i + 2)])\n    .flat()\n    .reduce(\n      (acc, n) => (acc.concat(n)),\n\
    \      [],\n    )\n    .reduce((acc, n) => (acc.concat(n)), []);\n}\n", "    const\
    \ result = []\n    for (let i = 0; i < numbers.length; i++) {\n        result.push(numbers[i])\n\
    \        result.push(delimeter)\n        result.push(numbers[i + 1])\n    }\n\
    \    return result.slice(2)\n}\n", "  return numbers.reduce(\n    (newNumbers,\
    \ value, index) => {\n      if (index !== 0) {\n        newNumbers.push(delimeter);\n\
    \      }\n      newNumbers.push(value);\n      return newNumbers;\n    },\n  \
    \  []\n  );\n}\n", "    let output: number[] = [];\n    for (let i = 0; i < numbers.length;\
    \ i += 1) {\n        if (numbers[i] === undefined || numbers[i] === null) {\n\
    \            throw new Error(\"Invalid argument.\");\n        }\n        if (i\
    \ !== 0) {\n            output.push(delimeter);\n        }\n        output.push(numbers[i]);\n\
    \    }\n    return output;\n}\n", "  if (Array.isArray(numbers)) {\n    const\
    \ length = numbers.length;\n    const result = new Array(length);\n    for (let\
    \ i = 0; i < length; i++) {\n      result[i] = numbers[i];\n    }\n    if (numbers.length)\
    \ {\n      const last = numbers.pop();\n      while (numbers.length) {\n     \
    \   const nextDelimeter = Math.max(delimeter, numbers.length);\n        result[nextDelimeter]\
    \ = numbers.pop();\n      }\n      result[nextDelimeter] = last;\n    }\n    return\
    \ result;\n  }\n  throw new TypeError(`Expected an array, but got ${typeof numbers}`);\n\
    }\n", "  const length = numbers.length;\n  if (numbers.length === 0) {\n    return\
    \ numbers;\n  }\n  let result: number[] = [];\n  let counter = 0;\n  let index\
    \ = -1;\n  while (counter < length) {\n    index = numbers.length - 1;\n    while\
    \ (index >= 0 && counter < numbers[index]) {\n      result.unshift(numbers[index--]);\n\
    \      counter += 1;\n    }\n    if (counter > numbers[index]) {\n      result.push(counter\
    \ - numbers[index]);\n    }\n    counter = 0;\n  }\n  return result;\n}\n", " \
    \ // Convert numbers to an array\n  const arr: number[] = Array.isArray(numbers)\
    \ ? numbers : [numbers];\n\n  // Convert delimter to a number\n  const delimeterNum:\
    \ number = typeof delimeter === 'number' ? delimeter : 1;\n\n  // Iterate over\
    \ all elements\n  for (let i = 0; i < (arr.length - 1); i += delimeterNum) {\n\
    \    // Insert a number\n    arr.splice(i, 0, delimeter);\n  }\n\n  return arr;\n\
    }\n", "  const result: number[] = [];\n  let lastNumberIndex = numbers.length\
    \ - 1;\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n\
    \    result.push(number);\n    if (i < lastNumberIndex) {\n      result.push(delimeter);\n\
    \    }\n  }\n  return result;\n}", "  return numbers.reduce(\n    (acc, number,\
    \ index) =>\n      acc + (index > 0 ? delimeter : '') + number,\n    ''\n  );\n\
    }\n\nexport { intersperse };\n", "  const len = numbers.length;\n  const interspersedNumbers\
    \ = [];\n  for (let i = 0; i < len; i += 1) {\n    if (i > 0) {\n      interspersedNumbers.push(delimeter);\n\
    \    }\n    interspersedNumbers.push(numbers[i]);\n  }\n  return interspersedNumbers;\n\
    }\n", "  if (numbers.length === 0) {\n    return [];\n  }\n\n  return _intersperse(numbers,\
    \ delimeter);\n}\n", "  return numbers.reduce(\n    (numbers, number) => {\n \
    \     return [...numbers, number, ...numbers];\n    },\n    []\n  );\n}\n", " \
    \ if (numbers.length === 0) {\n    return numbers;\n  }\n  const first: number\
    \ = numbers[0];\n  const second: number = numbers.length === 1 ? 0 : numbers[1];\n\
    \  const firstIndex: number = first.length;\n  const secondIndex: number = second.length;\n\
    \  const result: number[] = [];\n  let i: number = firstIndex - 1;\n  while (i\
    \ >= 0 && i <= firstIndex) {\n    result[result.length] = first[i];\n    i--;\n\
    \  }\n  if (i <= firstIndex) {\n    for (i = i; i >= firstIndex; i--) {\n    \
    \  result[result.length] = delimeter;\n    }\n  }\n  while (i >= firstIndex &&\
    \ i <= secondIndex) {\n    result[result.length] = second[i - firstIndex];\n \
    \   i--;\n  }\n  if (i <= secondIndex) {\n    for (i = i; i >= secondIndex; i--)\
    \ {\n      result[result.length] = delimeter;\n    }\n  }\n  return result;\n\
    }\n", "  if (!numbers) return numbers;\n  if (!Array.isArray(numbers)) return\
    \ numbers;\n  const numberOfNumbers = numbers.length;\n  const numberOfDelims\
    \ = delimeter.length;\n  const numberOfNumbersAndDelims = numberOfNumbers + numberOfDelims\
    \ - 1;\n  const numbersWithDelimeters = new Array(numberOfNumbersAndDelims);\n\
    \  let index = 0;\n  for (let i = 0; i < numberOfNumbers; i++) {\n    numbersWithDelimeters[index++]\
    \ = numbers[i];\n    numbersWithDelimeters[index++] = delimeter;\n  }\n  return\
    \ numbersWithDelimeters.slice(0, index);\n}\n", "    if (numbers.length === 0)\
    \ return [];\n    if (delimeter === undefined) delimeter = 0;\n    const result\
    \ = [];\n    let idx = 0;\n    let numberIdx = 0;\n    while (idx < numbers.length\
    \ - 1) {\n        result.push(numbers[numberIdx]);\n        const nextIdx = numberIdx\
    \ + 1;\n        const nextNumberIdx = nextIdx < numbers.length ? nextIdx : numbers.length\
    \ - 1;\n        result.push(delimeter);\n        result.push(numbers[nextNumberIdx]);\n\
    \        numberIdx = nextIdx;\n        idx += 1;\n    }\n    result.push(numbers[numberIdx]);\n\
    \    return result;\n}", "  const arr: number[] = [];\n\n  for (let i = 0, len\
    \ = numbers.length; i < len - 1; i++) {\n    arr.push(numbers[i]);\n    arr.push(delimeter);\n\
    \  }\n\n  arr.push(numbers[len - 1]);\n\n  return arr;\n}\n", "  const result\
    \ = [];\n  let index = 0;\n  for (let num of numbers) {\n    if (index > 0) {\n\
    \      result.push(delimeter);\n    }\n    result.push(num);\n    index++;\n \
    \ }\n  return result;\n}\n", "  return numbers.reduce(function (current, next)\
    \ {\n    return current.concat(delimeter, next);\n  }, []);\n}\n", "  if (numbers.length\
    \ === 0)\n    return [];\n  if (delimeter === undefined) delimeter = numbers[0];\n\
    \  const numbersWithDelimeters: number[] = [];\n  let index = -1;\n  numbers.forEach((number,\
    \ i) => {\n    if (index > 0) {\n      numbersWithDelimeters.push(number);\n \
    \     numbersWithDelimeters.push(delimeter);\n    } else {\n      numbersWithDelimeters.push(number);\n\
    \    }\n    index = i;\n  });\n  return numbersWithDelimeters;\n}\n", "  const\
    \ output = [];\n  numbers.forEach((num, index) => {\n    if (index !== 0) {\n\
    \      output.push(num);\n    }\n    output.push(delimeter);\n  });\n  return\
    \ output.slice(0, output.length - 1);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Thanks for sharing, it's helpful. By the way, could you please explain your last\
    \ line of code ? `output.slice(0, output.length - 1)`.\n<|/ c |>\n<| c |>\nI wanted\
    \ to remove the last element. `output.slice(0, output.length - 1)` takes the first\
    \ element and everything from that point to the end of the array.\n<|/ c |>\n\
    <| c |>\nI see. So it would be `output.slice(0, output.length - 1)` because it\
    \ takes one element and everything from it until the end. Thanks.\n<|/ c |>\n\
    <| a dscore=0 |>\nYou could try this approach with Array.reduce and Array.map\
    \ functions\n\n<code>", "    return numbers.reduce((acc, value, index) => (\n\
    \        acc + (index ? delimeter : '') + value\n    ), '');\n}\n", "  return\
    \ numbers.reduce((acc, n) => {\n    if (acc.length === 0) {\n      return [...new\
    \ Array(Math.abs(n - delimeter) + 1)]\n    }\n    const last = acc[acc.length\
    \ - 1]\n    if (n >= last) {\n      acc[acc.length - 1] = n + delimeter\n    }\
    \ else {\n      acc.push(n)\n    }\n    return acc\n  }, [])\n}\n", "  return\
    \ numbers.reduce((acc, n) => {\n    acc.push(n);\n    return acc;\n  }, []).join(delimeter);\n\
    }\n", "  if (isBlank(numbers)) {\n    return [];\n  }\n  if (isBlank(delimeter))\
    \ {\n    return numbers;\n  }\n  const result = [];\n  let index = 0;\n  const\
    \ len = numbers.length;\n  const total = len + delimeter;\n  for (; index < total;\
    \ index++) {\n    if (index % 2 === 0) {\n      result.push(numbers[index]);\n\
    \    } else {\n      result.push(delimeter);\n    }\n  }\n  return result;\n}\n\
    \n", "  if (!numbers.length) return numbers;\n  const result = numbers.slice();\n\
    \  const length = numbers.length;\n  for (let i = 0; i < length; i++) {\n    if\
    \ (i === 0) result.unshift(delimeter);\n    result.push(numbers[i]);\n  }\n  return\
    \ result;\n}\n", "    return numbers.reduce((acc, n) => {\n        if (acc.length\
    \ === 0) {\n            return [n];\n        } else {\n            acc.unshift(n);\n\
    \            return acc;\n        }\n    }, []);\n}\n", "  let result: number[]\
    \ = [];\n  while (numbers.length > 0) {\n    result.push(numbers.splice(0, 2));\n\
    \  }\n\n  return result;\n}\n", "  const len = numbers.length;\n  const result:\
    \ number[] = new Array(len + 1);\n  for (let i = 0; i < len; i += 1) {\n    result[i\
    \ + 1] = numbers[i];\n  }\n  result[len] = delimeter;\n  return result;\n}\n",
  "    let result: number[] = [];\n    for (let i = 0; i < numbers.length - 1; i++)\
    \ {\n        result.push(numbers[i]);\n        result.push(delimeter);\n     \
    \   result.push(numbers[i + 1]);\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThank you for taking the time to answer my question. \
    \ I upvoted your answer but I think it needs to be improved.  I believe your answer\
    \ will produce the following output: \n```[[], [1], [2], [3], [4], [1], [2], [3,\
    \ 4], [3]]``` \nwhen inputting ```[1, 2, 3, 4, 5]```.  I'm looking for a way to\
    \ produce the following output: \n```[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4],\
    \ [1, 2, 3, 4]```\n<|/ c |>\n<| c |>\nI'm afraid I cannot modify my answer as\
    \ it is incompatible with your specific requirements. Please see my updated answer.\
    \ Also, if you think this answer or any other answer is helpful for you, please\
    \ don't forget to accept it.\n<|/ c |>\n<| c |>\nI'm afraid this does not do exactly\
    \ what I want.  I appreciate your help though!\n<|/ c |>\n<| a |>\nYou can achieve\
    \ this with reduce\n<code>\nlet intersperse = (array, delimeter) => {\n    if\
    \ (array.length == 0) {\n        return [[]];\n    }\n\n    let result = [array[0]];\n\
    \    for (let i = 1; i < array.length; i++) {\n        result.push(delimeter);\n\
    \        result.push(array[i]);\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=0 tags=javascript,typescript |>\n<| a tags=javascript,typescript |>\n\
    I think this solution is better than reduce because it doesn't create a new array\
    \ each time. It also doesn't mutate the original array in any way.\n<code>", " \
    \   const numbersInArr = numbers.map((num: number) => num);\n    let intermediateArr:\
    \ number[] = [];\n    let length = numbersInArr.length;\n    let count = 0;\n\
    \    for (let index = 0; index < length; index++) {\n        const num = numbersInArr[index];\n\
    \        if (count < delimeter) {\n            intermediateArr.push(num);\n  \
    \      } else {\n            intermediateArr = intermediateArr.concat(num);\n\
    \        }\n        count++;\n    }\n    return intermediateArr;\n}", "  return\
    \ numbers.reduce((acc, number) => {\n    const newArray = acc.concat([number]);\n\
    \    return newArray.concat(\n      Array.from(Array(delimeter - 1).keys()).map(()\
    \ => numbers[newArray.length - 1]),\n    );\n  }, []);\n}", "  return numbers.reduce(function\
    \ (arr: number[], number: number) {\n    return arr.concat(\n      number.toString(),\
    \ delimeter,\n      number.toString()\n    );\n  }, []);\n}\n", "  const result\
    \ = [];\n  let index = -1;\n  while (++index < numbers.length) {\n    result.push(numbers[index]);\n\
    \    result.push(delimeter);\n    result.push(numbers[index]);\n  }\n  return\
    \ result;\n}\n", "    return numbers.reduce((result: number[], number: number)\
    \ => [...result, number, ...result], [] as number[])\n        .slice(0, -1)\n\
    \        .reduce((result: number[], number: number) => [...result, number, ...result],\
    \ [])\n        .slice(0, -1)\n        .reduce((result: number[], number: number)\
    \ => [...result, number], []);\n}\n", "  const result = [];\n  let last;\n  numbers.forEach((number,\
    \ index) => {\n    if (index > 0) {\n      last = result.length > 0 ? result[result.length\
    \ - 1] : '';\n      result.push(last + delimeter + number);\n    } else {\n  \
    \    result.push(number);\n    }\n  });\n  return result;\n}\n", "  if (numbers.length\
    \ === 0) {\n    return numbers;\n  }\n  const half = Math.ceil(numbers.length\
    \ / 2);\n  const result = new Array(half);\n  for (let i = 0; i < half; ++i) {\n\
    \    result[i] = numbers[i];\n  }\n  result[half] = delimeter;\n  for (let i =\
    \ half; i < numbers.length; ++i) {\n    result[i - half] = numbers[i];\n  }\n\
    \  return result;\n}\n", "  const interspersed: any[] = [];\n  let i = 0;\n  while\
    \ (i < numbers.length - 1) {\n    interspersed.push(numbers[i++]);\n    interspersed.push(delimeter);\n\
    \    interspersed.push(numbers[i++]);\n  }\n  return interspersed;\n}\n", "  let\
    \ result: number[] = [];\n  for (let i = 0; i < numbers.length; i += 2) {\n  \
    \  result.push(numbers[i], delimeter, numbers[i + 1]);\n  }\n  return result;\n\
    }\n", "  // `initial`  is the array that we will start adding the new element\
    \ to in `intersperse`.\n  // `result`   is the array we accumulate our new elements\
    \ into in `intersperse`.\n  // `index`    is the current index in `initial`, `result`,\
    \ or `numbers`.\n  // `i`        is the current element.\n  let initial: number[]\
    \ = [];\n  let result: number[] = [];\n  let index: number = 0;\n  const i: number\
    \ = numbers.length;\n\n  // If the length of the input array is 0, then return\
    \ an empty array.\n  if (i === 0) {\n    return [];\n  }\n\n  // While `i` is\
    \ not zero.\n  while (i > 0) {\n    // Add the element of the array `numbers`\
    \ at index `index` to the result\n    // array. If that element exists in `result`,\
    \ then we know that we need to\n    // insert it before that element in `result`.\n\
    \    if (result.indexOf(numbers[index - 1]) >= 0) {\n      result.splice(result.indexOf(numbers[index\
    \ - 1]), 1, numbers[index - 1], numbers[index]);\n    } else {\n      result.push(numbers[index\
    \ - 1]);\n    }\n\n    // Move the element `i` back one slot and decrement `i`.\n\
    \    index = i - 1;\n    i -= 1;\n  }\n\n  // Add the element of the input array\
    \ `numbers` at index `index` to the result\n  // array. If that element exists\
    \ in `result`, then we know that we need to\n  // insert it before that element\
    \ in `result`.\n  if (result.indexOf(numbers[index]) >= 0) {\n    result.splice(result.indexOf(numbers[index]),\
    \ 1, numbers[index], numbers[index + 1]);\n  } else {\n    result.push(numbers[index]);\n\
    \  }\n\n  return result;\n}\n", "  return numbers.reduce((prev, curr) => {\n \
    \   if (prev !== undefined) {\n      prev.push(curr);\n    } else {\n      prev.push(curr);\n\
    \    }\n    return prev;\n  }, []);\n}", "  const result = []\n  for (let i =\
    \ 0; i < numbers.length; i += 2) {\n    result.push(numbers[i])\n  }\n  for (let\
    \ i = 1; i < numbers.length; i += 2) {\n    result.push(delimeter, numbers[i +\
    \ 1])\n  }\n  return result\n}\n", "\tlet result = [];\n\tnumbers.map((number,\
    \ index) => {\n\t\tif (index > 0) {\n\t\t\tresult.push(delimeter);\n\t\t}\n\t\t\
    result.push(number);\n\t});\n\treturn result;\n}\n", "    if (delimeter === undefined)\
    \ { delimeter = 0; }\n    const numberArray = numbers;\n    if (numberArray.length\
    \ === 0) {\n        return [];\n    } else if (numberArray.length === 1) {\n \
    \       return numberArray;\n    }\n    let nextElem = numberArray[0];\n    let\
    \ newArray = [];\n    while (nextElem !== undefined) {\n        newArray.push(nextElem);\n\
    \        const index = newArray.length - 1;\n        if (index % delimeter ===\
    \ delimeter - 1) {\n            newArray.push(delimeter);\n        }\n       \
    \ nextElem = numberArray[index + 1];\n    }\n    return newArray;\n}", "  const\
    \ len = numbers.length;\n  const array = new Array(len + 1);\n  for (let i = 0;\
    \ i < len; ++i) {\n    array[i] = numbers[i];\n  }\n  array[len] = delimeter;\n\
    \  return array;\n}\n", "    const interspersedNumbers = [...numbers]\n    const\
    \ length = interspersedNumbers.length\n    const numberIndexes: number[] = []\n\
    \    const intersperseIndex = length\n\n    for (let i = 0; i < length; ++i) {\n\
    \        numberIndexes.push(i)\n    }\n\n    while (numberIndexes.length) {\n\
    \        let currentNumberIndex = numberIndexes.shift()\n\n        if (currentNumberIndex\
    \ < intersperseIndex) {\n            interspersedNumbers[currentNumberIndex] =\
    \ interspersedNumbers[currentNumberIndex] || 0\n            interspersedNumbers[currentNumberIndex]\
    \ = delimeter + interspersedNumbers[currentNumberIndex]\n        }\n\n       \
    \ currentNumberIndex += 1\n\n        for (let j = currentNumberIndex; j < intersperseIndex;\
    \ ++j) {\n            interspersedNumbers[j] = interspersedNumbers[j] || 0\n \
    \           interspersedNumbers[j] = interspersedNumbers[j] + 1\n        }\n \
    \   }\n\n    return interspersedNumbers\n}\n", "  const result = [numbers[0]];\n\
    \  for (let i = 1; i < numbers.length; i += 2) {\n    result.push(delimeter, numbers[i],\
    \ delimeter);\n  }\n  return result;\n}\n", "  // If 'numbers' is empty, return\
    \ an empty array\n  if (numbers.length === 0) return [];\n\n  // Iterate over\
    \ the array 'numbers'\n  for (let i = 0; i < numbers.length; i++) {\n    // If\
    \ a number at index 'i' is different than 'numbers[i]' then insert 'numbers[i]'\
    \ into the return array\n    if (numbers[i] !== numbers[i - 1]) {\n      return\
    \ [numbers[i]].concat(intersperse(numbers.slice(i + 1), delimeter));\n    }\n\
    \  }\n\n  // If 'numbers' is non-empty then return the input array as is\n  return\
    \ numbers;\n}\n", "  if (numbers.length === 0) {\n    return numbers\n  }\n\n\
    \  const result: number[] = [numbers[0]]\n  for (let i = 1; i < numbers.length;\
    \ ++i) {\n    result.push(delimeter, numbers[i])\n  }\n\n  return result\n}\n",
  "  const result: number[] = []\n  let number: number\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    number = numbers[i]\n    if (i) {\n      result.push(number)\n \
    \   }\n    result.push(delimeter, number)\n  }\n  return result\n}\n", "  const\
    \ len = numbers.length;\n  return numbers.reduce((acc, cur, i, orig) => {\n  \
    \  if (i > 0 && i - 1 === len) {\n      acc.push(cur);\n    } else {\n      acc.push(cur,\
    \ delimeter);\n    }\n    return acc;\n  }, []);\n}\n", "\tif (numbers.length\
    \ === 0) {\n\t\treturn [];\n\t}\n\tconst len = numbers.length;\n\tconst len =\
    \ delimeter > len ? len : delimeter;\n\tlet output = new Array<number>(len + numbers.length);\n\
    \tfor (let i = 0; i < len; i++) {\n\t\toutput[i] = numbers[i];\n\t}\n\tfor (let\
    \ i = numbers.length; i < len; i++) {\n\t\toutput[len + i] = delimeter;\n\t}\n\
    \treturn output;\n}\n", "  const result = [];\n\n  for (let index = 0; index <\
    \ numbers.length; index++) {\n    result.push(numbers[index]);\n    result.push(delimeter);\n\
    \    result.push(numbers[index]);\n  }\n\n  return result;\n}\n\nexport default\
    \ intersperse;\n\n<|/ file filename=intersperse.ts |><|endofmask|><|endofmask|>source=github\
    \ |><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>//Insert\
    \ a number 'delimeter' between every two consecutive elements of input array `numbers'",
  "  if (numbers.length === 0) {\n    return numbers;\n  }\n\n  return numbers.reduce((acc,\
    \ curr) => {\n    if (acc === null) {\n      return [curr];\n    }\n\n    return\
    \ [...acc, curr, delimeter].filter(Boolean);\n  }, null!);\n}\n", "    if (numbers.length\
    \ === 0) {\n        return [];\n    }\n\n    const _numbers = numbers.slice(0);\n\
    \    let index = 0;\n    let lastNumber = _numbers[index];\n    let result: number[]\
    \ = [];\n\n    while (index < _numbers.length) {\n        result.push(lastNumber);\n\
    \        index += 1;\n        lastNumber = _numbers[index];\n    }\n\n    result.push(lastNumber);\n\
    \    return result;\n}\n", "    const len = numbers.length;\n\n    if (len ===\
    \ 0) {\n        return numbers;\n    }\n\n    const result: number[] = [];\n\n\
    \    for (let i = 0; i < len; i++) {\n        if (i !== 0) {\n            result.push(delimeter);\n\
    \        }\n\n        result.push(numbers[i]);\n    }\n\n    return result;\n\
    }\n</code>\n<|/ a tags=javascript,typescript dscore=2 |>\n<| a |>\n<code>", " \
    \ const result: number[] = [];\n  for (let i = 0; i < numbers.length; i += 2)\
    \ {\n    result.push(numbers[i]);\n  }\n  for (let i = 0; i < numbers.length;\
    \ i += 2) {\n    result.push(delimeter, numbers[i + 1]);\n  }\n  return result;\n\
    }\n", "  if (isEmpty(numbers)) return []\n  return numbers.reduce((array, current,\
    \ i, array) => {\n    const rest = numbers.slice(i + 1)\n    return array.concat([current,\
    \ delimeter, rest])\n  }, [])\n}\n", "  var result = [];\n  var index = 0;\n \
    \ var len = numbers.length;\n  while (index < len) {\n    var number = numbers[index];\n\
    \    if (number === undefined || number === null) break;\n    result.push(number);\n\
    \    result.push(delimeter);\n    index++;\n  }\n  result.length = index;\n  return\
    \ result;\n}\n", "  let numbers_length = numbers.length;\n  if (numbers_length\
    \ < 2) {\n    return numbers;\n  }\n\n  let result: number[] = [];\n  for (let\
    \ i = 1; i < numbers_length; i++) {\n    result.push(numbers[i - 1]);\n    result.push(delimeter);\n\
    \    result.push(numbers[i]);\n  }\n  return result;\n}\n", "  return numbers.reduce((acc,\
    \ current, index) => {\n    if (index !== 0) {\n      acc.push(current);\n   \
    \ }\n\n    if (index !== numbers.length - 1) {\n      acc.push(delimeter);\n \
    \   }\n\n    return acc;\n  }, []);\n}\n", "    if (delimeter == null || delimeter\
    \ == undefined) {\n        throw new Error('delimeter must be defined');\n   \
    \ }\n    return numbers.slice(1).reduce(function (result, number, i) {\n     \
    \   result.push(number);\n        result.push(numbers[i + 1]);\n        return\
    \ result;\n    }, numbers.slice(0, 0));\n}\n", "\tlet numberCount = numbers.length,\n\
    \t\tdelimCount = delimeter.length,\n\t\tresult: number[] = [];\n\n\tif (numberCount\
    \ === 0) {\n\t\treturn result;\n\t}\n\n\tif (delimCount === 1) {\n\t\tresult =\
    \ result.concat(numbers);\n\t\treturn result;\n\t}\n\n\tfor (let index = 0; index\
    \ < numberCount; index++) {\n\t\tresult.push(numbers[index]);\n\t\tif (index ===\
    \ (numberCount - 1)) {\n\t\t\tresult.push(delimeter);\n\t\t}\n\t}\n\n\treturn\
    \ result;\n}\n", "    const numArray = numbers.slice();\n    const numArrayLen\
    \ = numArray.length;\n    if (numArrayLen === 0) {\n        return numArray;\n\
    \    }\n    if (numArrayLen === 1) {\n        return numArray.concat([delimeter]);\n\
    \    }\n    const halfLen = Math.floor(numArrayLen / 2);\n    for (let i = 0;\
    \ i < halfLen; i++) {\n        numArray[i] = numArray[i] + delimeter;\n    }\n\
    \    const remainder = numArrayLen % 2;\n    for (let i = halfLen; i < numArrayLen;\
    \ i++) {\n        numArray[i] = numArray[i] - remainder;\n    }\n    return numArray;\n\
    }", "  const result: number[] = [];\n  let i = 0;\n  let j = 0;\n\n  while (j\
    \ < numbers.length) {\n    if (j > 0) {\n      result.push(delimeter);\n    }\n\
    \    result.push(numbers[j]);\n    j = i + 1;\n    i = j;\n  }\n\n  return result;\n\
    }\n", "    if (numbers.length === 0) {\n        return numbers;\n    }\n    let\
    \ index = numbers.length - 1;\n    let result = [];\n    while (index > 0) {\n\
    \        result.push(numbers[index]);\n        index -= 1;\n    }\n    result.push(...intersperse(numbers.slice(0,\
    \ -1), delimeter));\n    result.push(delimeter);\n    return result;\n}\n", " \
    \ const length = numbers.length;\n  if (length <= 1) {\n    return numbers;\n\
    \  }\n\n  const firstNumber = numbers[0];\n  const lastNumber = numbers[length\
    \ - 1];\n\n  if (delimeter === lastNumber) {\n    return numbers.slice(1, length);\n\
    \  }\n\n  return numbers.slice(0, 1).concat(delimeter, numbers.slice(length -\
    \ 1));\n}\n", "  let output: number[] = [];\n  let first = true;\n  numbers.forEach((number)\
    \ => {\n    if (first) {\n      first = false;\n    } else {\n      output.push(delimeter);\n\
    \    }\n    output.push(number);\n  });\n  return output;\n}\n", "  numbers.unshift(delimeter);\n\
    \  let first = true;\n  for (const n of numbers) {\n    if (first) {\n      first\
    \ = false;\n    } else {\n      numbers.unshift(n);\n    }\n  }\n  return numbers;\n\
    }\n", "  let interspersed: number[] = [];\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    interspersed.push(numbers[i]);\n    if ((i + 1) < numbers.length)\
    \ {\n      interspersed.push(delimeter);\n    }\n  }\n  return interspersed;\n\
    }\n", "  return numbers.reduce((acc, num) => {\n    if (numbers.length === 0)\
    \ {\n      return [num];\n    } else {\n      return [num, ...acc];\n    }\n \
    \ }, []);\n}\n", "    if (numbers.length === 0) {\n        return numbers;\n \
    \   }\n\n    if (numbers.length === 1) {\n        return numbers.concat(delimeter);\n\
    \    }\n\n    const interspersedArray = intersperseArray(numbers, delimeter);\n\
    \n    const interspersedArrayLength = interspersedArray.length;\n\n    const firstToAdd\
    \ = interspersedArrayLength - numbers.length;\n\n    if (firstToAdd > 0) {\n \
    \       const firstInterspersedArray = intersperseArray(interspersedArray, delimeter);\n\
    \n        const firstInterspersedArrayLength = firstInterspersedArray.length;\n\
    \n        return firstInterspersedArray.concat(interspersedArray.slice(0, firstToAdd));\n\
    \    }\n\n    return interspersedArray.concat(interspersedArray.slice(0, firstToAdd));\n\
    }\n", "  if (delimeter === void 0) { delimeter = 0; }\n  return numbers.reduce(function\
    \ (acc, curr, index, numbers) {\n    if (index === 0) {\n      acc.push(curr);\n\
    \    } else if (index === numbers.length - 1) {\n      acc.push(curr + delimeter);\n\
    \    } else {\n      acc.push(curr + delimeter);\n    }\n    return acc;\n  },\
    \ []);\n}\n", "    if (delimeter == null) {\n        delimeter = 0;\n    }\n\n\
    \    numbers = numbers.slice();\n\n    if (numbers.length < 2) {\n        return\
    \ numbers;\n    }\n\n    var result: number[] = [];\n    var index = 0;\n    var\
    \ item: number = numbers[0];\n\n    while (item != null) {\n        result[index]\
    \ = item;\n\n        if (numbers.length > 1) {\n            item   = numbers[1];\n\
    \            index += 1;\n        } else {\n            break;\n        }\n  \
    \  }\n\n    return result;\n}\n", "  return numbers.reduce((acc, n) => {\n   \
    \ acc.push(...[delimeter, n]);\n    return acc;\n  }, []);\n}\n", "    return\
    \ numbers.map(function (n, i) {\n        if (i < numbers.length - 1) {\n     \
    \       return delimeter + n + delimeter;\n        } else {\n            return\
    \ n;\n        }\n    });\n}\n", "  return numbers.reduce(\n    (acc: number[],\
    \ curr: number, index: number) => {\n      return [...acc, curr, ...(index !==\
    \ numbers.length - 1 && [delimeter])];\n    }, []);\n}\n", "  const result = [];\n\
    \  let i = 0;\n  while (i < numbers.length) {\n    result.push(numbers[i]);\n\
    \    i += 1;\n    while (i < numbers.length && numbers[i] === delimeter) {\n \
    \     result.push(numbers[i + 1]);\n      i += 2;\n    }\n  }\n  return result;\n\
    }\n", "  const [head, ...rest] = numbers\n\n  return rest.concat(\n    head\n\
    \      .split(delimeter)\n      .map((chunk, i) =>\n        i === 0\n        \
    \  ? chunk\n          : `${chunk} ${delimeter}${rest.join(delimeter)}`\n     \
    \ )\n  )\n}\n", "  if (!numbers.length) {\n    return [];\n  }\n\n  return [...numbers,\
    \ ...intersperse(numbers.slice(1), delimeter)];\n}\n", "  const numbersInArray\
    \ = numbers.map(number => number)\n  const length = numbersInArray.length\n\n\
    \  if (numbersInArray.length <= 1) {\n    return numbersInArray\n  }\n\n  return\
    \ intersperse(\n    numbersInArray.slice(0, length - 1),\n    delimeter,\n   \
    \ numbersInArray.slice(length - 1)\n  )\n}\n", "  let result: number[] = [];\n\
    \  for (let i = 0; i < numbers.length; i += 1) {\n    result.push(numbers[i]);\n\
    \    if (i !== 0) {\n      result.push(delimeter);\n    }\n  }\n  return result;\n\
    }\n", "  if (delimeter == null || typeof delimeter !== 'number') {\n    return\
    \ numbers\n  }\n\n  const length = numbers.length\n  const newArray = new Array(length)\n\
    \  let idx = 0\n\n  for (; idx < length; idx++) {\n    newArray[idx] = numbers[idx]\n\
    \  }\n\n  let idx2 = 0\n  while (idx < length) {\n    newArray[idx2] = numbers[idx]\n\
    \    idx += delimeter\n    idx2 += delimeter\n  }\n\n  return newArray\n}\n\n\
    export default intersperse\n\n<|/ file filename=index.ts ext=.ts |>", "  if (delimeter\
    \ == null || delimeter == 0) return [];\n\n  const len = numbers.length;\n\n \
    \ if (delimeter < 0) {\n    delimeter = len + delimeter;\n  }\n\n  const result\
    \ = [];\n\n  let start = 0;\n  let end = -1;\n\n  while (end < len) {\n    start\
    \ = end;\n    end = start + delimeter - 1;\n\n    if (end >= len) end = len;\n\
    \n    result.push(numbers[start]);\n\n    for (let i = start + 1; i <= end; i++)\
    \ {\n      result.push(delimeter);\n      result.push(numbers[i]);\n    }\n  }\n\
    \n  return result;\n}\n", "  const array: number[] = [];\n  for (let i = 0; i\
    \ < numbers.length; i += 1) {\n    array.push(numbers[i]);\n    if (i !== 0) {\n\
    \      array.push(delimeter);\n    }\n  }\n  return array;\n}\n", "  if (Array.isArray(numbers)\
    \ && numbers.length > 0) {\n    const [first, ...rest] = numbers;\n    return\
    \ [...first, ...intersperse(rest, delimeter)];\n  }\n  if (Array.isArray(numbers)\
    \ && numbers.length === 0) {\n    return [];\n  }\n  return numbers;\n}\n", " \
    \ if (numbers.length === 0 || delimeter === 0) {\n    return numbers;\n  }\n\n\
    \  const len = numbers.length;\n  const newNumbers = numbers.slice(0, len);\n\
    \  const lastNumber = numbers[len - 1];\n  const delimeterIndex = newNumbers.indexOf(delimeter);\n\
    \  if (delimeterIndex > 0) {\n    const beforeNumber = newNumbers.slice(0, delimeterIndex);\n\
    \    const afterNumber = newNumbers.slice(delimeterIndex + 1, len);\n    newNumbers\
    \ = [...beforeNumber, lastNumber, ...afterNumber];\n  }\n\n  return newNumbers;\n\
    }\n", "\tlet result: number[] = [];\n\tlet index = 0;\n\n\tfor (const number of\
    \ numbers) {\n\t\tresult.push(number);\n\t\tif (index < numbers.length - 1) {\n\
    \t\t\tresult.push(delimeter);\n\t\t}\n\t\tindex++;\n\t}\n\n\treturn result;\n\
    }\n\n<|/ file ext=.ts source=gitlab |>", "  for (let i = numbers.length - 1, res\
    \ = []; i >= 0; i--) {\n    res.push(numbers[i]);\n    if (numbers[i] === delimeter)\
    \ {\n      res.unshift(delimeter);\n    }\n  }\n  return res;\n}\n", "  const\
    \ result: any[] = [];\n  for (let i = 1; i < numbers.length; i++) {\n    result.push(numbers[i\
    \ - 1] + delimeter + numbers[i]);\n  }\n  return result;\n}\n", "  const output\
    \ = [];\n  for (let i = 0, length = numbers.length; i < length; i += 2) {\n  \
    \  output.push(numbers[i], delimeter, numbers[i + 1]);\n  }\n  return output;\n\
    }\n", "  if (numbers.length === 0) {\n    return [];\n  }\n\n  return numbers.map(function\
    \ (element, index) {\n    if (index !== 0) {\n      return delimeter;\n    }\n\
    \    return element;\n  });\n}\n", "  if (!numbers.length) return [];\n\n  const\
    \ result: number[] = [];\n  let lastNumber = numbers[0];\n\n  for (let i = 1;\
    \ i < numbers.length; i++) {\n    if (numbers[i] === lastNumber && i === numbers.length\
    \ - 1) {\n      result.push(delimeter);\n    } else {\n      result.push(numbers[i]);\n\
    \      lastNumber = numbers[i];\n    }\n  }\n\n  return result;\n}\n", "    if\
    \ (numbers.length === 0) {\n        return numbers;\n    }\n    let result: number[]\
    \ = [];\n    let i = 0;\n    let length = numbers.length;\n    while (i < length)\
    \ {\n        result.push(numbers[i]);\n        if (i !== (length - 1)) {\n   \
    \         result.push(delimeter);\n        }\n        i += 1;\n    }\n    return\
    \ result;\n}\n", "  if (numbers.length === 0) {\n    return numbers;\n  }\n  const\
    \ length = numbers.length;\n  const length = numbers.length - 1;\n  const numbers_copy\
    \ = numbers.slice();\n  let index = 0;\n  while (index <= length) {\n    numbers_copy[index]\
    \ = delimeter;\n    index += 1;\n  }\n  return numbers_copy;\n}\n\nexport function\
    \ randomString(length: number, chars: string = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\
    \ {\n  const charsLength = chars.length;\n  let str = '';\n  for (let i = 0; i\
    \ < length; i++) {\n    str += chars[Math.floor(Math.random() * charsLength)];\n\
    \  }\n  return str;\n}\n\nexport function randomUUID() {\n  const random = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n\
    \  const charsLength = random.length;\n\n  let token = '';\n  for (let i = 0;\
    \ i < 8; i++) {\n    token += random[Math.floor(Math.random() * charsLength)];\n\
    \  }\n  return token;\n}\n\nexport function getRandomColor() {\n  let r = Math.floor(Math.random()\
    \ * 255);\n  let g = Math.floor(Math.random() * 255);\n  let b = Math.floor(Math.random()\
    \ * 255);\n  return 'rgb(' + r + ', ' + g + ', ' + b + ')';\n}\n\nexport function\
    \ generateRandomLetters(length: number): string {\n  let str = '';\n  for (let\
    \ i = 0; i < length; i++) {\n    str += String.fromCharCode(65 + Math.floor(Math.random()\
    \ * 26));\n  }\n  return str;\n}\n\nexport function generateRandomLettersUpToNumber(length:\
    \ number): string {\n  let str = '';\n  for (let i = 0; i < length; i++) {\n \
    \   str += String.fromCharCode(65 + Math.floor(Math.random() * 26));\n  }\n  return\
    \ str;\n}\n\nexport function generateRandomNumbersUpToNumber(length: number):\
    \ string {\n  let str = '';\n  for (let i = 0; i < length; i++) {\n    str +=\
    \ String.fromCharCode(97 + Math.floor(Math.random() * 26));\n  }\n  return str;\n\
    }\n\nexport function generateRandomLettersAndNumbersUpToNumber(length: number):\
    \ string {\n  let str = '';\n  for (let i = 0; i < length; i++) {\n    str +=\
    \ String.fromCharCode(97 + Math.floor(Math.random() * 26));\n  }\n  return str;\n\
    }\n\nexport function generateRandomLettersAndNumbers(length: number): string {\n\
    \  let str = '';\n  for (let i = 0; i < length; i++) {\n    str += String.fromCharCode(65\
    \ + Math.floor(Math.random() * 26));\n  }\n  return str;\n}\n\nexport function\
    \ generateRandomLettersAndNumbersUpToNumber(length: number): string {\n  let str\
    \ = '';\n  for (let i = 0; i < length; i++) {\n    str += String.fromCharCode(65\
    \ + Math.floor(Math.random() * 26));\n  }\n  return ", "  if (numbers.length ===\
    \ 0) {\n    return [];\n  }\n\n  let currentDelimeter: number = numbers[0];\n\n\
    \  for (let i = 1; i < numbers.length; ++i) {\n    numbers[i] += currentDelimeter;\n\
    \    currentDelimeter = delimeter;\n  }\n\n  return numbers.slice(0, numbers.length);\n\
    }\n", "  return numbers.reduce((array, number) => {\n    array.push(number);\n\
    \    return array.concat(delimeter);\n  }, []);\n}\n", "  const result: number[]\
    \ = [];\n  let counter: number = 0;\n  for (let i = 0; i < numbers.length - 1;\
    \ i++) {\n    if (numbers[i] === delimeter) {\n      result[counter] = numbers[i];\n\
    \      counter++;\n    } else {\n      result[counter] = numbers[i];\n      counter++;\n\
    \      result[counter] = delimeter;\n      counter++;\n    }\n  }\n  result[counter]\
    \ = numbers[numbers.length - 1];\n  return result;\n}\n", "  return numbers.reduce((acc,\
    \ num) => {\n    return acc.concat(num, num, num);\n  }, []);\n}\n", "  // if\
    \ the length of the input array is 0, the output array will be 0 as well\n  if\
    \ (!numbers.length) {\n    return [];\n  }\n  // if there are two or more numbers,\
    \ we return the first two as the delimiter\n  if (numbers.length > 1) {\n    return\
    \ [numbers.shift(), numbers.shift()].concat(intersperse(numbers, delimeter));\n\
    \  }\n  // otherwise, we return the first number as the delimiter\n  return [numbers.shift()].concat(intersperse(numbers,\
    \ delimeter));\n}\n", "  if (numbers.length === 0) {\n    return numbers;\n  }\n\
    \  return [...numbers, ...intersperse(numbers.slice(1), delimeter)];\n}\n", " \
    \ if (numbers.length === 0) {\n    return [];\n  }\n\n  const result: number[]\
    \ = [];\n  let index = 0;\n  let current = numbers[0];\n  while (current !== 0)\
    \ {\n    result.push(current);\n    current = numbers[index + 1];\n    if (current\
    \ !== 0) {\n      result.push(delimeter);\n    }\n    index += 2;\n  }\n  return\
    \ result;\n}\n", "  if (numbers.length === 0) {\n    return [];\n  }\n  return\
    \ numbers.slice(0, numbers.length - 1).join(delimeter) + delimeter + numbers.slice(numbers.length\
    \ - 1);\n}\n", "  if (delimeter == null || delimeter == undefined) {\n    return\
    \ numbers;\n  }\n  if (numbers.length < 1) {\n    return numbers;\n  }\n  const\
    \ array1 = [];\n  const array2 = [];\n  array1.push(numbers[0]);\n  for (let index\
    \ = 1; index < numbers.length; index++) {\n    array2.push(numbers[index]);\n\
    \    array1.push(delimeter);\n    array1.push(numbers[index]);\n  }\n  return\
    \ array2.concat(array1);\n}\n</code>\n<|/ a tags=typescript,javascript |>\n<|\
    \ a tags=typescript,javascript |>\nIf you have a list of numbers, you can use\
    \ Array.prototype.slice with Array#concat to insert your delimeter after every\
    \ two numbers. To insert the delimeter, use an empty string as the argument to\
    \ Array#join. \n\n<code>", "  return numbers.reduceRight((prev, curr) => [prev,\
    \ delimeter, curr], []);\n}\n", "  return numbers.reduce((acc, number, index)\
    \ => {\n    if (index !== 0) {\n      acc.push(number);\n    }\n    if (index\
    \ !== numbers.length - 1) {\n      acc.push(delimeter);\n    }\n    return acc;\n\
    \  }, []);\n}\n", "  var result: number[] = [];\n  var i = 0, j = 0, n = numbers.length;\n\
    \  while (i < n && j < n) {\n    result.push(numbers[i]);\n    if (delimeter ===\
    \ numbers[j]) {\n      result.push(delimeter);\n      j++;\n    } else {\n   \
    \   result.push(numbers[j]);\n      i++;\n    }\n  }\n  return result;\n}\n",
  "  const result = [];\n  for (let i = 0, len = numbers.length; i < len; i += 2)\
    \ {\n    result.push(numbers[i]);\n    result.push(delimeter);\n    result.push(numbers[i\
    \ + 1]);\n  }\n  return result;\n}\n", "    if (numbers.length === 0) {\n    \
    \    return numbers;\n    }\n\n    var result = [numbers[0]];\n    for (var i\
    \ = 1; i < numbers.length; i++) {\n        result.push(delimeter, numbers[i]);\n\
    \    }\n\n    return result;\n}\n", "  let numbersIndices = [0]\n  numbersIndices.push(...numbers.map((n,\
    \ i) => i + numbersIndices[i]))\n  let res = []\n  let i = numbersIndices.shift()\n\
    \  while (numbersIndices.length) {\n    res.push(numbers[i])\n    numbersIndices.shift()\n\
    \    i++\n  }\n  if (delimeter) {\n    res.push(...[...Array(delimeter).keys()].map(v\
    \ => numbersIndices.shift()))\n  }\n  return res\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I really like this, it does it all in one nice and clean function, thanks!\n<|/\
    \ c |>\n<| a dscore=2 |>\nI know this is an old question, but I needed something\
    \ similar and thought I would offer a variation of the answer from which I adapted\
    \ the solution from here, which uses an additional parameter for the length of\
    \ the delimiter, instead of using an if statement.\n<code>", "  const length =\
    \ numbers.length;\n  if (length <= 0) return [];\n  let index = 0;\n  const interspersed:\
    \ number[] = [];\n  while (index < length) {\n    const value = numbers[index];\n\
    \    interspersed[index] = value;\n    index += 1;\n    const prev = numbers[index\
    \ - 1];\n    if (prev === delimeter) {\n      interspersed.push(delimeter);\n\
    \      index += 1;\n    }\n  }\n  return interspersed;\n}\n\nexport default intersperse;\n\
    \n<|/ file ext=.ts dstars=1 |>\n<| a dscore=0 |>\nUsing ES6 syntax:\n\n<code>\n\
    let arr = [1, 2, 3, 7, 9, 11, 13, 15, 17]\n\nconst getNextItem = arr => arr.shift()\n\
    \nlet result = arr.reduce((acc, val) => {\n  if(val === undefined) return acc;\n\
    \  acc.push(val);\n  acc.push(getNextItem(acc))\n  return acc\n}, []);\n\nconsole.log(result)</code>\n\
    <|/ a tags=arrays,javascript |>\n<| a |>\nIf you want an immutable solution then\
    \ you should consider using an immutable data structure (i.e. a plain old Javascript\
    \ object, array or primitive value) instead of an array.\nThe reason for this\
    \ is that Javascript doesn't really guarantee that the values of an array are\
    \ stored in the same order as they were added (which is what happens when you\
    \ add a new element to an array). You just get whatever happens to already be\
    \ in the array when the array is updated (or when it is created).\nIn other words,\
    \ if you add an element to the beginning of an array, you might as well be prepending\
    \ it to another array. Using an object or primitive value instead, you can store\
    \ the elements in the order they were added.\nHere's a quick example of how to\
    \ do this with an object instead of an array:\n\n<code>\nconst arr = {\n  arr:\
    \ []\n};\n\nlet i;\nfor (i = 0; i < 10; i++) {\n  arr.arr.push(i);\n}\n\nconsole.log(arr.arr);\n\
    \nfor (i = 0; i < 10; i++) {\n  arr.arr.unshift(i);\n}\n\nconsole.log(arr.arr);</code>\n\
    \nYou could also use a plain old array if you preferred, but it's much easier\
    \ to work with an object since you can add properties to it. The only downside\
    \ is that you then have to manually keep track of when you are done with a particular\
    \ array, and when you are done with all the arrays.\n<|/ a tags=arrays,javascript\
    \ dscore=0 |>\n<| a dscore=0 tags=arrays,javascript |>\nThis one is the simplest\
    \ solution if you don't want to use the reduce() method.\n<code>", "  return numbers.length\
    \ === 0 ? [] : numbers\n    .slice(0, numbers.length - 1)\n    .concat([delimeter])\n\
    \    .concat(numbers.slice(numbers.length - 1, numbers.length))\n}\n</code>\n\
    <|/ a |>\n<| a tags=javascript,arrays |>\nYou could use an array. Split the numbers\
    \ in an array. Join the array.\n\n<code>", "  const numbersIndices = numbers.map((n,\
    \ i) => (i > 0 && i < numbers.length - 1) ? i + 1 : i);\n\n  return numbers.map(number\
    \ => numbersIndices.map(i => number + delimeter).join(\"\"));\n}\n", "  if (delimeter\
    \ === undefined) delimeter = ',';\n  return numbers.reduce(function (acc, elt,\
    \ i) {\n    return i ? acc.concat([elt]).concat([delimeter]) : acc.concat([elt]);\n\
    \  }, []);\n}\n", "  var result: number[] = [];\n\n  if (!numbers.length) return\
    \ result;\n\n  for (var i = 0; i < numbers.length; ++i) {\n    if (i < numbers.length\
    \ - 1) {\n      result.push(numbers[i]);\n    } else {\n      result.push(delimeter\
    \ + numbers[i]);\n    }\n  }\n\n  return result;\n}\n", "  if (!numbers) return\
    \ numbers; // Nothing to interspersse\n  if (numbers.length === 0) {\n    return\
    \ [];\n  }\n\n  var firstNumber = numbers[0];\n\n  if (numbers.length === 1) {\n\
    \    return [firstNumber];\n  }\n\n  var interspersedNumbers = numbers.slice(1).map(function(number)\
    \ {\n    return number + delimeter + firstNumber;\n  });\n\n  return interspersedNumbers;\n\
    }\n", "  const result: any[] = []\n  let length = numbers.length\n\n  for (let\
    \ i = 0; i <= length; i++) {\n    const value = numbers[i]\n    if (i !== 0) {\n\
    \      result.push(delimeter)\n    }\n    result.push(value)\n  }\n\n  return\
    \ result\n}\n", "  numbers = numbers.length ? numbers : [0];\n\n  if (numbers.length\
    \ === 0) {\n    return [];\n  }\n\n  var result = [];\n  var idx = 0;\n  var isNumber\
    \ = true;\n\n  do {\n    isNumber = isNumber && numbers[idx] >= 0;\n    if (isNumber\
    \ && idx % delimeter == 0) {\n      result.push(numbers[idx]);\n      idx += 1;\n\
    \    } else {\n      result.push(numbers[idx], delimeter);\n      idx += 1;\n\
    \    }\n  } while (idx < numbers.length);\n\n  return result;\n}\n", "  numbers\
    \ = intersperse([...numbers], delimeter);\n  return numbers.pop() as number[];\n\
    }\n", "  if (isEmpty(numbers)) {\n    return numbers\n  }\n\n  const len = numbers.length\n\
    \  const lastIndex = len - 1\n\n  for (let i = 0; i < len; i += 1) {\n    if (i\
    \ !== lastIndex) {\n      numbers[i + 1] = numbers[i] + delimeter + numbers[i\
    \ + 1]\n    }\n  }\n\n  return numbers\n}\n", "    if (numbers.length === 0) return\
    \ numbers;\n    const result: number[] = [];\n    numbers.forEach((number, i)\
    \ => {\n        if (i === 0 || number === numbers[i - 1]) result.push(number);\n\
    \        else result.push(delimeter);\n    });\n    return result;\n}\n", "\t\
    if (numbers.length === 0) {\n\t\treturn numbers\n\t}\n\n\tif (numbers.length ===\
    \ 1) {\n\t\treturn numbers[0]\n\t}\n\n\tconst firstIndex = numbers.length - 1\n\
    \n\treturn numbers\n\t\t.slice(0, firstIndex + 1)\n\t\t.concat([delimeter, numbers[firstIndex]])\n\
    \t\t.concat(intersperse(numbers.slice(firstIndex + 1), delimeter))\n}\n", "  const\
    \ numberString = numbers.join('');\n  const interspersedNumbers = numberString.split(delimeter).map(number\
    \ => parseInt(number, 10));\n  return interspersedNumbers;\n}\n", "  const len\
    \ = numbers.length;\n  const result = new Array(len);\n  let resultIndex = 0;\n\
    \  let startIndex = 0;\n  let num = 0;\n\n  while (resultIndex < len) {\n    if\
    \ (num >= delimeter) {\n      result[resultIndex++] = numbers[startIndex++];\n\
    \      num = 0;\n    }\n\n    result[resultIndex++] = num;\n    num += numbers[startIndex++];\n\
    \  }\n\n  return result;\n}\n", "  const len = numbers.length;\n  const result\
    \ = new Array(len + 1);\n  let i = 0;\n  for (; i < len; i++) {\n    result[i]\
    \ = numbers[i];\n  }\n  result[len] = delimeter;\n  return result;\n}\n", "  return\
    \ numbers.reduce((array, number, index) => {\n    const last = index === numbers.length\
    \ - 1;\n    return [...array, number + (last ? delimeter : \"\")];\n  }, []);\n\
    }\n", "    const result: number[] = [];\n    numbers.forEach((number, index) =>\
    \ {\n        if (index > 0) {\n            result.push(number);\n        }\n \
    \       result.push(delimeter);\n    });\n    result.push(delimeter);\n    return\
    \ result;\n}\n", "  return numbers.reduce((acc, val) => {\n    acc.push(val)\n\
    \    acc.push(delimeter)\n    return acc\n  }, [])\n}\n", "  let result: number[]\
    \ = []\n  for (let i = 0; i < numbers.length - 1; i += 1) {\n    result = result.concat(numbers.slice(i,\
    \ i + delimeter + 1))\n  }\n  return result\n}\n\n<|/ file ext=.ts dstars=0 source=github\
    \ |>", "  if (numbers.length <= 1) return numbers;\n\n  let i = 0;\n  let intermediateArray\
    \ = new Array();\n\n  while (i < numbers.length) {\n    const value = numbers[i];\n\
    \    intermediateArray.push(...[value], delimeter);\n    i++;\n  }\n\n  const\
    \ remainingNumbers = numbers.slice(i + 1);\n  return intersperse(remainingNumbers,\
    \ delimeter);\n}\n", "    let result: number[] = []\n    numbers = numbers.slice()\n\
    \    while (numbers.length >= 2) {\n        result.push(numbers[0])\n        result.push(delimeter)\n\
    \        numbers = numbers.slice(1)\n    }\n    if (numbers.length >= 1) {\n \
    \       result.push(numbers[0])\n    }\n    return result\n}\n", "  let numberIndex\
    \ = 0;\n  return numbers.reduce((result, number) => {\n    if (numberIndex >=\
    \ numbers.length - 1) {\n      result.push(number);\n    } else {\n      result.push(number,\
    \ ...intersperse(numbers.slice(numberIndex + 1, numbers.length), delimeter));\n\
    \      numberIndex += 1;\n    }\n    return result;\n  }, []);\n}\n</code>\n<|/\
    \ a tags=typescript,javascript,arrays |>\n<| a dscore=1 |>\nA simple for loop\
    \ should do it:\n<code>", "  if (!numbers.length) return numbers\n  return intersperse(\n\
    \    numbers.slice(0, numbers.length - 1).concat(delimeter),\n    numbers[numbers.length\
    \ - 1]\n  )\n}\n\nconst pipe: <T, TResult>(fn: (x: T) => TResult) => (x: T) =>\
    \ TResult = (fn) => (x) => fn(x)\n\nconst _concat = <T extends readonly any[],\
    \ TResult>(\n  x: T | null,\n  ...xs: readonly T[]\n) => xs.length === 0 ? x :\
    \ concat(x, ...xs)\n\nconst _concat1 = <T extends readonly any[]>(x: T | null,\
    \ ...xs: readonly T[]) => xs.length === 0 ? x : concat(x, ...xs)\n\nconst _concat2\
    \ = <T extends readonly any[], TResult>(\n  x: T | null,\n  ...xs: readonly T[]\n\
    ) => xs.length === 0 ? x : concat(xs.slice(0, -1), concat(x, ...xs.slice(-1)))\n\
    \nconst _concat3 = <T extends readonly any[], TResult>(\n  x: T | null,\n  ...xs:\
    \ readonly T[]\n) => xs.length === 0 ? x : concat(xs.slice(0, -2), concat(xs.slice(0,\
    \ -1), concat(x, ...xs.slice(-2))))\n\nconst _concat4 = <T extends readonly any[],\
    \ TResult>(\n  x: T | null,\n  ...xs: readonly T[]\n) => xs.length === 0 ? x :\
    \ concat(xs.slice(0, -3), concat(xs.slice(0, -2), concat(xs.slice(0, -1), concat(x,\
    \ ...xs.slice(-3)))))\n\nconst _concat5 = <T extends readonly any[], TResult>(\n\
    \  x: T | null,\n  ...xs: readonly T[]\n) => xs.length === 0 ? x : concat(xs.slice(0,\
    \ -4), concat(xs.slice(0, -3), concat(xs.slice(0, -2), concat(xs.slice(0, -1),\
    \ concat(x, ...xs.slice(-4))))))\n\nconst _concat6 = <T extends readonly any[],\
    \ TResult>(\n  x: T | null,\n  ...xs: readonly T[]\n) => xs.length === 0 ? x :\
    \ concat(xs.slice(0, -5), concat(xs.slice(0, -4), concat(xs.slice(0, -3), concat(xs.slice(0,\
    \ -2), concat(xs.slice(0, -1), concat(xs.slice(0, 0), ...xs.slice(-5))))))\n\n\
    const _concat7 = <T extends readonly any[], TResult>(\n  x: T | null,\n  ...xs:\
    \ readonly T[]\n) => xs.length === 0 ? x : concat(xs.slice(0, -6), concat(xs.slice(0,\
    \ -5), concat(xs.slice(0, -4), concat(xs.slice(0, -3), concat(xs.slice(0, -2),\
    \ concat(xs.slice(0, -1), concat(xs.slice(0, 0), ...", "  const length = numbers.length,\n\
    \    count = Math.floor(length / 2);\n  let result = [];\n\n  numbers.forEach((item,\
    \ index) => {\n    if (index !== count + 1) {\n      result.push(item);\n    }\n\
    \  });\n\n  return result.concat(numbers.slice(count).map((item) => delimeter));\n\
    }\n", "  if (isEmpty(numbers)) {\n    return [];\n  }\n  const result = new Array<number>();\n\
    \  const length = numbers.length;\n  for (let i = 0; i < length - 1; i++) {\n\
    \    result.push(numbers[i]);\n    result.push(delimeter);\n    result.push(numbers[i\
    \ + 1]);\n  }\n  result.push(numbers[length - 1]);\n  return result;\n}\n", " \
    \ const len = numbers.length;\n  const result = new Array(len + 1).fill(undefined);\n\
    \  result[len] = delimeter;\n  for (let i = 0; i < len; i++) {\n    result[i +\
    \ 1] = numbers[i];\n  }\n  return result;\n}\n", "  const result: number[] = []\n\
    \  let previousNumber: number\n\n  for (const number of numbers) {\n    if (number\
    \ === previousNumber) {\n      result.push(delimeter)\n    } else {\n      result.push(number)\n\
    \    }\n\n    previousNumber = number\n  }\n\n  return result\n}\n", "  if (delimeter\
    \ === undefined) delimeter = -1;\n\n  const numbersWithDelimeters: number[] =\
    \ [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    numbersWithDelimeters.push(numbers[i]);\n\
    \n    if (i !== numbers.length - 1 && delimeter === -1) numbersWithDelimeters.push(delimeter);\n\
    \  }\n\n  return numbersWithDelimeters;\n}\n", "  return numbers.reduce(\n   \
    \ (result, current, index) =>\n      current == null ?\n      result :\n     \
    \ result.concat(current, index === 0 ? delimeter : []),\n    []\n  );\n}\n", " \
    \ return numbers.reduce((output, current, index) => (index % 2 === 0 ? output\
    \ + current : output + delimeter + current));\n}\n", "  if (numbers.length ===\
    \ 0) {\n    return numbers\n  }\n  let lastElem = numbers[numbers.length - 1]\n\
    \  return [...numbers, ...intersperse(numbers.slice(0, numbers.length - 1), delimeter),\
    \ lastElem]\n}\n", "  if (!Array.isArray(numbers) || !numbers.length) return numbers;\
    \ // if numbers is null or undefined\n  const array = [];\n  numbers.forEach((number,\
    \ index) => {\n    array.push(number);\n    if (index < numbers.length - 1) array.push(delimeter);\n\
    \  });\n  return array;\n}\n", "  let length = numbers.length;\n  let newLength\
    \ = 1;\n  for (let i = 0; i < length; i++) {\n    newLength *= numbers.length;\n\
    \  }\n  let newArray = new Array<number>(newLength);\n  let offset = 0;\n  let\
    \ i = numbers.length;\n  while (i) {\n    newArray[--offset] = numbers[--i];\n\
    \  }\n  for (; i < length; i++) {\n    newArray[offset] = numbers[i];\n  }\n \
    \ return newArray;\n}\n", "  checkDelim(delimeter)\n  let result: number[] = []\n\
    \  for (let i = 0; i < numbers.length; i += 2) {\n    result.push(numbers[i])\n\
    \    result.push(delimeter)\n    result.push(numbers[i + 1])\n  }\n  return result\n\
    }\n", "  const len = numbers.length\n  if (len < 2) {\n    return numbers\n  }\n\
    \n  const result = new Array(len - 1)\n\n  for (let i = 1; i < len; i += 1) {\n\
    \    result[i - 1] = numbers[i - 1] + delimeter + numbers[i]\n  }\n\n  return\
    \ result\n}\n", "  return numbers.reduce((result, number, index) => {\n    if\
    \ (index !== 0) {\n      result.push(delimeter);\n    }\n    result.push(number);\n\
    \    return result;\n  }, []);\n}\n\nconst sum = (values: number[]) => values.reduce((result,\
    \ value) => result + value, 0);\n\nconst average = (values: number[]) => sum(values)\
    \ / values.length;\n\nconst count = (values: number[]) => (values.length > 0 ?\
    \ 1 : 0);\n\nconst maximum = (values: number[]) => Math.max(...values);\n\nconst\
    \ minimum = (values: number[]) => Math.min(...values);\n\nconst first = (values:\
    \ number[]) => values[0];\n\nconst last = (values: number[]) => values[values.length\
    \ - 1];\n\nconst nth = (index: number, values: number[]) => values[index];\n\n\
    const range = (startIndex: number, endIndex: number, increment: number = 1) =>\
    \ {\n  const result = [];\n  for (let index = startIndex; index <= endIndex; index\
    \ += increment) {\n    result.push(index);\n  }\n  return result;\n};\n\nconst\
    \ rangeInclusive = (startIndex: number, endIndex: number, increment: number =\
    \ 1) => {\n  const result = [];\n  for (let index = startIndex; index <= endIndex;\
    \ index += increment) {\n    result.push(index);\n  }\n  return result;\n};\n\n\
    const sample = (list: number[], total: number, random: Random) => {\n  const result\
    \ = [];\n  const numberOfItems = list.length;\n  for (let i = 0; i < total; i++)\
    \ {\n    const offset = random.nextInt(numberOfItems);\n    result.push(list[offset]);\n\
    \    numberOfItems--;\n  }\n  return result;\n};\n\nconst sampleSize = (list:\
    \ number[], size: number, random: Random) => {\n  const result = [];\n  const\
    \ numberOfItems = list.length;\n  const totalItemsInList = Math.floor(numberOfItems\
    \ / size);\n  for (let i = 0; i < size; i++) {\n    const offset = random.nextInt(totalItemsInList);\n\
    \    result.push(list[offset]);\n    totalItemsInList--;\n  }\n  return result;\n\
    };\n\nconst shuffle = (list: number[], random: Random) => {\n  const result =\
    \ list.slice();\n  for (let i = list.length - 1; i > 0; i--) {\n    const j =\
    \ random.nextInt(i + 1);\n    const tmp = result[i];\n    result[i] = result[j];\n\
    \    result[j] = tmp;\n  }\n  return result;\n};\n\nconst partition = (list: number[],\
    \ key: number) => (\n  leftElements: number[],\n  rightElements: number[],\n)\
    \ => {\n  const leftIndex = leftElements.findIndex((el) => el === key);\n  const\
    \ rightIndex = rightElements.findIndex((el) => el === key);\n  leftElements[leftIndex]\
    \ = rightElements[rightIndex];\n  ", "  return numbers.reduce((result: number[],\
    \ number: number, index: number) => {\n    return index % 2 === 0 ? result.concat([number,\
    \ delimeter, number]) : result.concat([number]);\n  });\n}\n", "  return numbers.reduce((acc,\
    \ n) => {\n    const index = acc.length;\n    acc.push(delimeter);\n    acc.push(n);\n\
    \    acc.push(delimeter);\n    return acc;\n  }, []);\n}\n", "    if (numbers.length\
    \ === 0) {\n        return [];\n    }\n\n    let currentDelimeter = numbers[numbers.length\
    \ - 1];\n    const interspersedNumbers = [currentDelimeter];\n    for (let i =\
    \ 0; i < numbers.length; ++i) {\n        interspersedNumbers.push(numbers[i]);\n\
    \    }\n\n    return interspersedNumbers;\n}\n", "  const result: number[] = [];\n\
    \  let i = 0;\n  while (i < numbers.length) result.push(numbers[i], delimeter);\n\
    \  while (i < numbers.length) result.push(numbers[i++]);\n  return result;\n}\n\
    \nexport function removeDuplicates(arr: number[]) {\n  return arr.filter((item,\
    \ index) => arr.indexOf(item) === index);\n}\n\nexport function toArray(iterable:\
    \ any) {\n  return Array.prototype.slice.call(iterable);\n}\n\nexport function\
    \ findInArray(arr: number[], value: number) {\n  const foundIndex = arr.indexOf(value);\n\
    \  return foundIndex === -1 ? undefined : { index: foundIndex, value: arr[ foundIndex\
    \ ] };\n}\n\nexport function chunk<T>(arr: Array<T>, chunkSize: number): Array<Array<T>>\
    \ {\n  return Array.from({ length: Math.ceil(arr.length / chunkSize) }, (v, i)\
    \ => arr.slice(i * chunkSize, i * chunkSize + chunkSize));\n}\n", "  if (numbers.length\
    \ === 0) {\n    return [];\n  }\n  const interspersed: string[] = [];\n  for (let\
    \ i = 0; i < numbers.length; i++) {\n    if (i !== 0) {\n      interspersed.push(delimeter);\n\
    \    }\n    interspersed.push(numbers[i]);\n  }\n  return interspersed;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
