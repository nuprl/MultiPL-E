name: HumanEval_33_sort_third
language: ts
prompt: "//This function takes an array l and returns an array l' such that\n// l'\
  \ is identical to l in the indicies that are not divisible by three, while its values\
  \ at the indicies that are divisible by three are equal\n// to the values of the\
  \ corresponding indicies of l, but sorted.\n// >>> sort_third([1, 2, 3])\n// [1,\
  \ 2, 3]\n// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\nfunction\
  \ sort_third(l: number[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = sort_third;\n  assert.deepEqual(candidate([5, 6, 3,\
  \ 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5]);\n  assert.deepEqual(candidate([5, 8, 3, 4,\
  \ 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5]);\n  assert.deepEqual(candidate([5, 6, 9, 4, 8,\
  \ 3, 2]),[2, 6, 9, 4, 8, 3, 5]);\n  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9,\
  \ 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1]);\n}\n\ntest();"
completions: ["    let l2 = l.slice();\n    l2.sort((a, b) => a - b);\n    let l3\
    \ = [];\n    for (let i = 0; i < l.length; i++) {\n        if (i % 3 === 0) {\n\
    \            l3.push(l2[i]);\n        } else {\n            l3.push(l[i]);\n \
    \       }\n    }\n    return l3;\n}\n", "    const third = [];\n    l.forEach((value,\
    \ index) => {\n        if (index % 3 === 0) {\n            third.push(value);\n\
    \        } else {\n            const minValue = Math.min(third[0], third[1], third[2]);\n\
    \            const maxValue = Math.max(third[0], third[1], third[2]);\n      \
    \      third[0] = minValue;\n            third[1] = maxValue;\n            third[2]\
    \ = value;\n        }\n    });\n    return third;\n}\n", "  l.sort((a, b) => {\n\
    \    if (a % 3 === b % 3) {\n      return 0;\n    } else {\n      return a < b\
    \ ? -1 : 0;\n    }\n  });\n  return l;\n}\n", "    const third = l.slice(0, l.length\
    \ / 3);\n    return l.slice().sort((a, b) => a > b ? 1 : -1);\n}\n", "    var\
    \ l1 = [];\n    var l2 = [];\n    var len: number = l.length;\n    var x: number;\n\
    \    var y: number;\n    for (x = 0; x < len; x += 3) {\n        l1.push(l[x]);\n\
    \    }\n    for (y = 0; y < len; y++) {\n        if (y % 3 == 0) {\n         \
    \   l2.push(l[y]);\n        }\n    }\n    return l2.concat(l1);\n}\n</code>\n\
    <|/ a dscore=1 tags=javascript,typescript |>\n<| a tags=javascript,typescript\
    \ |>\nAs I understand the question, you want to create a copy of an array so that\
    \ when you modify one the changes do not get reflected on the original array.\
    \ There are multiple ways of doing this.\nUsing Object.assign()\n<code>\nconst\
    \ arr = [1, 2, 3, 4, 5];\nconst copy = Object.assign([], arr);\ncopy[1] = 3;\n\
    console.log(arr);\n</code>\nUsing spread operator\n<code>\nconst arr = [1, 2,\
    \ 3, 4, 5];\nconst copy = [...arr];\ncopy[1] = 3;\nconsole.log(arr);\n</code>\n\
    Using slice and concat\n<code>\nconst arr = [1, 2, 3, 4, 5];\nconst copy = arr.slice(0);\n\
    copy[1] = 3;\nconsole.log(arr);\n</code>\nUsing spread operator, slice and concat\n\
    <code>\nconst arr = [1, 2, 3, 4, 5];\nconst copy = [...arr.slice(0), 3];\nconsole.log(arr);\n\
    </code>\nThe answer given by Kishore is more concise and does the job.\n<|/ a\
    \ dscore=1 |>\n<| c |>\n`const copy = [...arr]` will create a shallow copy.\n\
    <|/ c |>\n<| c |>\nYes, but if he wants to change the value later on then this\
    \ might not be the best choice. He will have to clone the array again anyway or\
    \ use `spread operator`.\n<|/ c |>\n<| c |>\nyes I agree that this may not be\
    \ the best choice and I agree that using a spread operator is a good choice, however\
    \ I think the OP is looking for a way to not change the original array.\n<|/ c\
    \ |>\n<| a |>\n<code>\nconst arr = [1, 2, 3, 4, 5];\nconst copy = arr.slice(0);\
    \ // a copy is made of arr by slicing arr.\ncopy[1] = 3;\nconsole.log(arr); //\
    \ [1, 2, 3, 4, 5]\nconsole.log(copy); // [1, 2, 3]\n</code>\n<|/ a tags=javascript,typescript\
    \ dscore=1 |>\n<| a |>\n<code>\nvar arr = [1,2,3,4,5,6,7,8,9,0];\nvar copy = arr.slice(0);\n\
    copy[1] = 3;\nconsole.log(arr);\n</code>\nThe copying of the ", "    const l =\
    \ l.slice();\n    if (l.length % 3 === 1) {\n        const len = l.length / 3;\n\
    \        for (let i = 0; i < len; i++) {\n            l.splice(Math.floor(i /\
    \ 3), 0, l[i + ((i % 3) * len)])\n        }\n    }\n    return l;\n}\n", "   \
    \ let third: number[] = [];\n    let thirdIndex: number[] = [];\n    let thirdNumber:\
    \ number = l[0];\n    for (let i = 0; i < l.length; i++) {\n        if (i % 3\
    \ === 0) {\n            thirdIndex.push(i);\n            thirdNumber.push(l[i]);\n\
    \        } else {\n            let index: number;\n            for (let j = 0;\
    \ j < thirdIndex.length; j++) {\n                if (thirdIndex[j] === i) {\n\
    \                    index = j;\n                    break;\n                }\n\
    \            }\n            if (index === undefined) {\n                index\
    \ = thirdIndex.length;\n                thirdIndex.push(i);\n                thirdNumber.push(l[i]);\n\
    \            } else {\n                thirdNumber[index] = l[i];\n          \
    \  }\n        }\n    }\n\n    let temp: number[];\n    let arrayLength = thirdIndex.length;\n\
    \    for (let i = 0; i < thirdIndex.length; i++) {\n        for (let j = 0; j\
    \ < arrayLength; j++) {\n            if (thirdIndex[i] < thirdIndex[j]) {\n  \
    \              temp = thirdNumber[j];\n                thirdNumber[j] = thirdNumber[i];\n\
    \                thirdNumber[i] = temp;\n            }\n        }\n    }\n   \
    \ return thirdNumber;\n}\n", "    var l1 = [];\n    var l2 = [];\n    var k =\
    \ 0;\n    var j = 0;\n    var n = 0;\n    for (i = 0; i < l.length; i++) {\n \
    \       if (i % 3 === 0) {\n            l1.push(l[i]);\n            n = l1.length\
    \ - 1;\n        }\n        else {\n            l2.push(l[i]);\n            n =\
    \ l2.length - 1;\n        }\n        for (j = 0; j < n; j++) {\n            if\
    \ (l1[j] > l2[j]) {\n                var temp = l1[j];\n                l1[j]\
    \ = l2[j];\n                l2[j] = temp;\n                k = j;\n          \
    \  }\n        }\n    }\n    var l3 = [];\n    var n = 0;\n    for (i = 0; i <\
    \ l2.length; i++) {\n        if (i % 3 === 0) {\n            l3.push(l2[i]);\n\
    \            n = l3.length - 1;\n        }\n        else {\n            l3.push(l2[i]);\n\
    \            n = l3.length - 1;\n        }\n        for (j = 0; j < n; j++) {\n\
    \            if (l3[j] > l2[j]) {\n                var temp = l3[j];\n       \
    \         l3[j] = l2[j];\n                l2[j] = temp;\n                k = j;\n\
    \            }\n        }\n    }\n    return l3;\n}\n</code>\n<|/ a tags=arrays,javascript,sorting\
    \ dscore=0 |>\n<| a dscore=0 |>\nThe fastest algorithm is probably bubble sort,\
    \ though it's actually O(n^2), since the inner loop has a lot of repeated comparisons.\n\
    If you use an online sorting algorithm (e.g. Quicksort), you can get O(nlogn)\
    \ but usually not as fast as bubble sort on small arrays.\nThe other algorithm\
    \ is radix sort, which has some very nice properties (e.g. it's almost O(n) on\
    \ small n).\n<|/ a tags=arrays,javascript,sorting |>\n<| c |>\nThe radix sort\
    \ algorithm is O(n) only when all elements are the same, and it can be done in\
    \ O(n).\n<|/ c |>\n<| a |>\nUsing recursion is O(n^2)\n<code>\nvar sortIt = (array)\
    \ => {\n    array.sort((a, b) => {\n        if (a > b) return -1;\n        if\
    \ (a < b) return 1;\n        return 0;\n    });\n    return sortIt(array);\n}\n\
    </code>\n<|/ a tags=arrays,javascript,sorting dscore=0 |>\n<| c |>\nIt's O(n^2)\
    \ not O(n) which is more correct\n<|/ c |>\n<| c |>\nI guess I misread that. Thanks\
    \ for pointing that out!\n<|/ c |>\n<| a |>\n<code>\nvar a = [4,3,2,2,7,5,2,6,1];\n\
    a.sort((a,b) => a-b);\nconsole.log", "    let a = new Array(l.length + 1);\n \
    \   for (let i = 0; i < l.length; i++) {\n        let j = i;\n        while (j\
    \ > 0 && a[j / 3] != l[j]) {\n            a[--j] = l[j];\n        }\n        a[j]\
    \ = l[i];\n    }\n    return a;\n}", "  let i3 = 0\n  let i1 = 0\n  let i2 = 0\n\
    \  let i0 = 0\n  let num: number[] = new Array<number>()\n\n  while (l[i3] * 3\
    \ !== 0) {\n    num[i0] = l[i3]\n    i0++\n    i3++\n  }\n\n  i3 = 0\n\n  for\
    \ (let i = 0; i < l.length / 3; i++) {\n    if (l[i3] * 3 === 0 && l[i3] * 3 <\
    \ l[i2] * 3) {\n      num[i2] = l[i3]\n      i2++\n      i3++\n    } else if (l[i3]\
    \ * 3 !== 0 && l[i3] * 3 === l[i2] * 3) {\n      num[i2] = l[i3]\n      i2++\n\
    \    } else {\n      num[i2] = l[i3]\n      i2++\n      num[i1] = l[i3]\n    \
    \  i1++\n      i3++\n    }\n  }\n\n  num.length = i0\n  i3 = 0\n\n  while (l[i3]\
    \ === 0) {\n    num[i3] = l[i3]\n    i3++\n  }\n\n  return num\n}\n</code>\n<|/\
    \ a tags=sorting,arrays,javascript |>\n<| a |>\nUse Array.sort(), it takes two\
    \ arguments, the first being the function to run on the array and the second the\
    \ direction of the sort (asc/desc), then call it on the array you want to sort.\n\
    <code>", "    return l.sort((a, b) => a % 3 === b % 3 ? 0 : a % 3 > b % 3 ? -1\
    \ : 1);\n}\n", "\tlet l = l.slice();\n\tfor (let i = 0; i < l.length; i++) {\n\
    \t\tlet j = i;\n\t\tfor (let k = i; k < l.length; k++) {\n\t\t\tif (l[j] % 3 !==\
    \ l[k] % 3) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tl[i], l[j] = l[j], l[i];\n\t\
    }\n\treturn l;\n}\n", "    var l3: number[] = [];\n    var k = 0;\n    for (var\
    \ i = 1; i < l.length; i++) {\n        if (l[k] % 3 !== 0) {\n            l3.push(l[k]);\n\
    \            k++;\n        } else if (l[k] === l[i]) {\n            l3.push(l[i]);\n\
    \            k++;\n        } else {\n            l3.push(l[k]);\n            k++;\n\
    \            l3.push(l[i]);\n            k++;\n        }\n    }\n    if (k < l.length)\
    \ {\n        l3.push(l[k]);\n    }\n    return l3;\n}\n", "  const len = l.length;\n\
    \  for (let i = 0; i < len; i++) {\n    if (i % 3 === 0) {\n      let tmp = 0;\n\
    \      for (let j = 0; j < len; j++) {\n        if (j % 3 === 0) tmp += l[j];\n\
    \        if (j === i) tmp += l;\n      }\n      l[i] = tmp;\n    }\n  }\n  return\
    \ l;\n}\n", "  var i: number\n  var j: number\n  var k\n  var l1: number[] = []\n\
    \  for (i = 0, j = 0; i < l.length; i = j, j = k) {\n    if (i % 3 == 0) {\n \
    \     k++\n      l1.push(l[i])\n    } else {\n      l1.push(l[j])\n    }\n  }\n\
    \  return l1\n}\n", "  let [a, b, c, d, e, f] = l;\n  let ab = a & b;\n  let ac\
    \ = a & c;\n  let ad = a & d;\n  let ae = a & e;\n  let af = a & f;\n\n  let bc\
    \ = b & c;\n  let bd = b & d;\n  let be = b & e;\n  let bf = b & f;\n\n  let cd\
    \ = c & d;\n  let ce = c & e;\n  let cf = c & f;\n\n  let de = d & e;\n  let df\
    \ = d & f;\n\n  let ef = e & f;\n\n  let fg = f & g;\n\n  let abe = ab | ae;\n\
    \  let acf = ac | cf;\n  let bce = bc | ce;\n  let bdf = bd | df;\n  let cde =\
    \ cd | de;\n  let cfe = cf | ef;\n  let dfg = df | fg;\n  return [\n    abe,\n\
    \    acf,\n    bce,\n    bdf,\n    cde,\n    cfe,\n    dfg,\n  ];\n}\n", "   \
    \ let res: number[] = [];\n    let i1: number;\n    let i2: number;\n    let i3:\
    \ number;\n    for (i1 = 0; i1 < l.length; i1++) {\n        if (i1 % 3 === 0)\
    \ {\n            res[i1-1] = l[i1];\n        } else {\n            for (i2 = i1\
    \ + 1; i2 < l.length; i2++) {\n                if (l[i2] % 3 === 0) {\n      \
    \              res[i2-1] = l[i2];\n                } else {\n                \
    \    for (let i3 = i2 + 1; i3 < l.length; i3++) {\n                        if\
    \ (l[i3] < l[i2]) {\n                            res[i3-1] = l[i3];\n        \
    \                } else {\n                            break;\n              \
    \          }\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return res;\n}\n", "  let res: number[] = [];\n  let cur: number[]\
    \ = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!cur.includes(l[i]))\n\
    \      res.push(l[i]);\n    else if (cur.length == 3)\n      res.push([...cur]);\n\
    \    cur = [...cur, l[i]];\n  }\n  return res;\n}\n", "  let l1 = [];\n  let l2\
    \ = [];\n  l.forEach((num, index) => {\n    if (index % 3 === 0) {\n      l2.push(num);\n\
    \    } else {\n      l1.push(num);\n    }\n  });\n  let sorted_l1 = l1.sort();\n\
    \  let sorted_l2 = l2.sort();\n  for (let i = 0; i < sorted_l1.length; i++) {\n\
    \    for (let j = 0; j < sorted_l2.length; j++) {\n      if (sorted_l1[i] ===\
    \ sorted_l2[j]) {\n        sorted_l1.splice(i, 1);\n        sorted_l2.splice(j,\
    \ 1);\n        break;\n      }\n    }\n  }\n  return sorted_l1.concat(sorted_l2);\n\
    }\n</code>\n<|/ a tags=sorting,javascript,arrays |>\n<| c |>\nOh my god , thank\
    \ you so much for taking your time to help and for posting your solution. It works\
    \ as expected.\n<|/ c |>\n<| c |>\nYou rock. Thank you!\n<|/ c |>\n<| c |>\nGlad\
    \ it helped!\n<|/ c |>\n<| c |>\nJust a note, you should use the ES6 syntax for\
    \ arrow functions, which will make your code shorter and more readable - https://codepen.io/anon/pen/QvQqjp\n\
    <|/ c |>\n<| c |>\nAnd just in case someone stumbles upon this question and finds\
    \ the accepted answer doesn't work for them, you could replace `num.sort` with\
    \ [`.sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).\n\
    <|/ c |>\n<| a tags=sorting,javascript,arrays |>\n<code>\nvar array = [1, 3, 10,\
    \ 5, 2, 6, 8];", "  var l1: number[] = l.slice();\n  var l2: number[] = [];\n\
    \  var i: number;\n  for (i = 0; i < l1.length; i++) {\n    if (i % 3 === 0) {\n\
    \      l2.push(l1[i]);\n    }\n  }\n  return l2.sort();\n}\n", "    let l1 = [];\n\
    \    for (let i = 0; i < l.length; i++) {\n        let iDivisibleByThree = l.indexOf((l[i]\
    \ / 3) | 0);\n        l1.push(l[i]);\n        if (iDivisibleByThree != -1) l1.push(l[iDivisibleByThree]);\n\
    \    }\n    l1.sort((a, b) => a - b);\n    return l1;\n}", "  let thirdIndexes\
    \ = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i === 0) {\n      thirdIndexes.push(i);\n\
    \    } else {\n      if (l[i / 3] % 3 !== l[i - 1] % 3) {\n        thirdIndexes.push(i);\n\
    \      }\n    }\n  }\n  return sortIndexes(l, thirdIndexes);\n}", "\treturn l.sort((a,\
    \ b) => {\n\t\tif (a % 3 === 0) {\n\t\t\treturn 1;\n\t\t} else if (b % 3 === 0)\
    \ {\n\t\t\treturn -1;\n\t\t}\n\t\treturn a - b;\n\t});\n}\n", "  let result: number[]\
    \ = [];\n  for (let i = 0; i < l.length; i++) {\n    let third = Math.floor(i\
    \ / 3);\n    let other = i % 3 === 0 ? i + 1 : i;\n    for (let j = 0; j < l[third].length;\
    \ j++) {\n      result.push(l[third][j]);\n    }\n    for (let j = 0; j < l[other].length;\
    \ j++) {\n      result[j + 1] = l[other][j];\n    }\n  }\n  return result;\n}\n",
  "\tl.sort((a: number, b: number) => a % 3 === b % 3 ? a - b : a % 3 ? 1 : -1);\n\
    \treturn l;\n}\n", "\tvar len = l.length;\n\tvar l_prime = new Array(len);\n\t\
    l_prime[0] = l[0];\n\tl_prime[1] = l[0];\n\tvar i = 2;\n\twhile(i < len) {\n\t\
    \twhile(l_prime[i] < l[i] - 3) {\n\t\t\ti++;\n\t\t}\n\t\twhile(l_prime[i] > l[i]\
    \ + 3) {\n\t\t\ti--;\n\t\t}\n\t\tl_prime[i] = l[i];\n\t\ti++;\n\t}\n\treturn l_prime;\n\
    }", "  var l1 = l[0];\n  var l2 = l[1];\n  var l3 = l[2];\n\n  var l12: number[]\
    \ = sort_third([l1, l2, l3]);\n  var l23: number[] = sort_third([l2, l3, l1]);\n\
    \n  var l34: number[] = sort_third([l2, l3, l1]);\n  var l53: number[] = sort_third([l3,\
    \ l1, l2]);\n  var l63: number[] = sort_third([l3, l1, l2]);\n\n  var l341: number[]\
    \ = sort_third([l3, l1, l2, l34]);\n  var l3423: number[] = sort_third([l3, l1,\
    \ l2, l34, l23]);\n  var l3453: number[] = sort_third([l3, l1, l2, l34, l23, l53]);\n\
    \  var l3463: number[] = sort_third([l3, l1, l2, l34, l23, l53, l63]);\n\n  var\
    \ l1234: number[] = sort_third([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11,\
    \ l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22, l23, l24, l25, l26, l27,\
    \ l28, l29, l30, l31, l32, l33, l34, l35, l36, l37, l38, l39, l40, l41, l42, l43,\
    \ l44, l45, l46, l47, l48, l49, l50, l51, l52, l53, l54, l55, l56, l57, l58, l59,\
    \ l60, l61, l62, l63, l64, l65, l66, l67, l68, l69, l70, l71, l72, l73, l74, l75,\
    \ l76, l77, l78, l79, l80, l81, l82, l83, l84, l85, l86, l87, l88, l89, l90, l91,\
    \ l92, l93, l94, l95, l96, l97, l98, l99, l100]);\n  var l12345: number[] = sort_third([l1,\
    \ l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18,\
    \ l19, l20, l21, l22, l23, l24, l25, l26, l27, l28, l29, l30, l31, l32, l", "\t\
    const a = [l[0], l[1], l[2]]\n\treturn [...a, ...a.slice(3).sort(), ...a.slice(0,\
    \ 3)]\n}", "    let sorted: any[] = [];\n    for (let i = 0; i < l.length; i++)\
    \ {\n        const k = (l[i] % 3) * 3;\n        if (k !== i) {\n            sorted.push(l[i]);\n\
    \        }\n    }\n    return sorted;\n}\n</code>\nEDIT\nFollowing your comment\
    \ about wanting to sort by price rather than by index, you can do the following.\n\
    <code>", "\tlet counts = count_and_divide(l, 3);\n\tlet sorted = [];\n\tlet i\
    \ = 0;\n\twhile (i < l.length) {\n\t\tlet x = counts[i];\n\t\tsorted.push(x);\n\
    \t\ti += x;\n\t}\n\treturn sorted;\n}\n", "\tlet result: number[] = [];\n\tlet\
    \ len = l.length;\n\tfor (let i = 0; i < len; i++) {\n\t\tif (i % 3 == 0) {\n\t\
    \t\tfor (let j = 1; j < i; j++) {\n\t\t\t\tif (l[j - 1] > l[j]) {\n\t\t\t\t\t\
    let temp = l[j];\n\t\t\t\t\tl[j] = l[j - 1];\n\t\t\t\t\tl[j - 1] = temp;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t}\n\t\tresult.push(l[i]);\n\t}\n\treturn result;\n}\n", " \
    \ let i: number;\n  let j: number;\n  let newL: number[];\n  const len = l.length;\n\
    \  for (j = 0; j < len; j++) {\n    if (j % 3 === 0 || j === 0) {\n      newL\
    \ = l.slice();\n      for (i = j; i < len; i++) {\n        if (i % 3 === 0) {\n\
    \          newL[i] = l[i];\n        }\n        if (l[i] % 3 !== 0) {\n       \
    \   newL[i + 1] = l[i];\n        }\n      }\n      newL.sort();\n      return\
    \ newL;\n    }\n  }\n  return l;\n}\n", "\tconst len: number = l.length;\n\tlet\
    \ thirdLength: number;\n\tlet i: number;\n\n\tthirdLength = l % 3;\n\tif (thirdLength)\
    \ {\n\t\tconst thirdArray: number[] = [];\n\t\tfor (let i = 0; i < thirdLength;\
    \ i++) {\n\t\t\tthirdArray.push(l[l - thirdLength + i]);\n\t\t}\n\t\tthirdArray.sort();\n\
    \t\tl = thirdArray;\n\t}\n\tthirdLength = l % 3;\n\n\tfor (i = 0; i < len / 3;\
    \ i++) {\n\t\tlet j: number = l - thirdLength + i;\n\t\tlet k: number;\n\t\tif\
    \ (j < thirdLength) {\n\t\t\tk = j;\n\t\t} else {\n\t\t\tk = j + thirdLength;\n\
    \t\t}\n\t\tif (l[k] < l[j]) {\n\t\t\tconst t = l[k];\n\t\t\tl[k] = l[j];\n\t\t\
    \tl[j] = t;\n\t\t}\n\t}\n\treturn l;\n}\n", "\tlet l1 = l.slice();\n\tl1.sort((a,\
    \ b) => a - b);\n\tlet r = [];\n\tfor (let i = 0; i < l1.length; i += 3) {\n\t\
    \tr.push(l1[i]);\n\t\tr.push(l1[i + 1]);\n\t\tr.push(l1[i + 2]);\n\t}\n\treturn\
    \ r;\n}\n", "    var result = l.slice();\n    result.sort((a, b) => a % 3 ===\
    \ b % 3 ? a - b : a - b + 2);\n    return result;\n}\n", "    const length = l.length;\n\
    \    const thirds = new Array(length);\n    for (let i = 0; i < length; i++) {\n\
    \        const val = l[i];\n        const pos = (i + 2) / (3 * 3);\n        const\
    \ third = (val - 1) / (pos - 1);\n        thirds[i / 3] = third;\n    }\n    const\
    \ thirds1 = thirds.sort(function (a, b) { return a - b; });\n    const thirds2\
    \ = [];\n    for (let i = 0; i < thirds1.length; i++) {\n        thirds2.push(thirds1[i]);\n\
    \    }\n    return thirds2;\n}\n", "    const len: number = l.length;\n    let\
    \ i: number, j: number, k: number;\n    const c: number[] = new Array(len);\n\
    \    for (i = 0; i < len; i += 1) {\n        j = 0;\n        k = i;\n        while\
    \ (k < len && l[k] === l[j]) {\n            k += 1;\n            j += 1\n    \
    \    }\n        c[i] = l[k];\n        c[k] = l[i];\n    }\n    return c;\n}\n",
  "\tconst len = l.length;\n\tconst half = len / 2;\n\tconst temp = new Array(len);\n\
    \tfor (let i = 0; i < len; i++)\n\t\ttemp[i] = l[i];\n\tfor (let i = len - 1;\
    \ i >= half; i--) {\n\t\tfor (let j = 0; j < len; j++) {\n\t\t\tlet k = 0;\n\t\
    \t\twhile (k < len) {\n\t\t\t\tif (k + 1 == len) {\n\t\t\t\t\tk--;\n\t\t\t\t\t\
    continue;\n\t\t\t\t}\n\t\t\t\tif (temp[k] == l[j]) {\n\t\t\t\t\tk++;\n\t\t\t\t\
    \tcontinue;\n\t\t\t\t}\n\t\t\t\tif (temp[k] > l[j]) {\n\t\t\t\t\ttemp[k + 1] =\
    \ temp[k];\n\t\t\t\t\tk++;\n\t\t\t\t} else {\n\t\t\t\t\ttemp[k] = l[j];\n\t\t\t\
    \t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (let i = 0; i < len; i++)\n\t\
    \tl[i] = temp[i];\n\treturn l;\n}\n", "  const l3: number[] = l.slice();\n  let\
    \ inds: number[] = [];\n  l3.sort((a, b) => a - b);\n  for (let i = 0; i < l3.length;\
    \ i++) {\n    if (l3[i] % 3 === 0) {\n      inds.push(i);\n    }\n  }\n  const\
    \ l4 = new Array(inds.length);\n  for (let i = 0; i < inds.length; i++) {\n  \
    \  l4[i] = l3[inds[i]];\n  }\n  return l4;\n}\n", "  let l = l.slice();\n  for\
    \ (let i = 0; i < l.length; i++) {\n    for (let j = 0; j < 3; j++) {\n      if\
    \ (i % 3 === 0 && i !== l[j]) {\n        l[j] = i;\n        break;\n      }\n\
    \    }\n  }\n  return l.sort(function(a, b) {\n    return a - b;\n  });\n}", " \
    \   const l3d = [];\n    for (let i = 0; i < l.length; ++i) {\n        if (l[i]\
    \ % 3 === 0) {\n            l3d.push(l[i]);\n        } else {\n            l3d.sort(function\
    \ (a, b) { return a - b; });\n            l3d.push(l3d[l3d.length - 1]);\n   \
    \         l3d.pop();\n        }\n    }\n    return l3d;\n}\n", "\tlet lsort =\
    \ [];\n\tfor (let i = 0; i < l.length; i++) {\n\t\tlet j = 0;\n\t\tlet k = 0;\n\
    \t\twhile (j < l.length && k < 3) {\n\t\t\tlet x = l[i];\n\t\t\tlet y = l[j];\n\
    \t\t\tif (x % 3 === y % 3) {\n\t\t\t\tlsort[i] = y;\n\t\t\t\tlsort[j] = x;\n\t\
    \t\t\tj++;\n\t\t\t\tk++;\n\t\t\t} else if (y % 3 === x % 3) {\n\t\t\t\tlsort[i]\
    \ = x;\n\t\t\t\tlsort[j] = y;\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\
    \t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tif (j === l.length)\n\t\t\tlsort[i]\
    \ = l[i];\n\t}\n\treturn lsort;\n}\n", "  l.sort( (a, b) => a % 3 == b % 3 ? a\
    \ - b : b - a );\n  return l;\n}\n", "\tlet l = l.slice();\n\tfor (let i = 0;\
    \ i < l.length / 3; ++i) {\n\t\tlet j = i * 3;\n\t\twhile (j + 1 < l.length &&\
    \ l[j] > l[j + 1]) ++j;\n\t\twhile (j + 2 < l.length && l[j] > l[j + 1] && l[j]\
    \ > l[j + 2]) ++j;\n\t\tif (j < l.length) l[j + 2] = l[j];\n\t}\n\treturn l;\n\
    }\n", "  for (let i = 1; i < l.length; i += 3) {\n    for (let j = i; j < i +\
    \ 3; j++) {\n      let t = l[j];\n      if (t != l[j]) {\n        j = j + 1;\n\
    \        l[j] = t;\n      }\n    }\n  }\n  return l;\n}\n", "  for (let i = 0;\
    \ i < l.length; i++) {\n    if (i % 3 === 0) l[i] = l[i] + l[i - 1];\n  }\n  let\
    \ sorted_array = [];\n  l.forEach((value) => {\n    sorted_array.push(value);\n\
    \  });\n  sorted_array.sort((a, b) => a - b);\n  return sorted_array;\n}\n", "\t\
    let llen = l.length;\n\tlet new_l = new Array(llen);\n\tlet j = 0;\n\tlet i =\
    \ 1;\n\twhile (j < llen) {\n\t\tlet k = j;\n\t\twhile (i < llen && l[j] % 3 !=\
    \ 0 && l[i] % 3 == 0) {\n\t\t\ti++;\n\t\t}\n\t\tif (i < llen && l[j] % 3 == 0\
    \ && l[i] % 3 != 0) {\n\t\t\tnew_l[k] = l[j];\n\t\t\ti++;\n\t\t\tnew_l[k] = l[i];\n\
    \t\t\ti++;\n\t\t\tj++;\n\t\t} else if (i < llen) {\n\t\t\tnew_l[k] = l[j];\n\t\
    \t\ti++;\n\t\t\tj++;\n\t\t} else {\n\t\t\tj++;\n\t\t}\n\t}\n\treturn new_l;\n\
    }\n", "  let res: number[] = l;\n  let divisibleByThree: boolean[] = [];\n  for\
    \ (let i = 0; i < res.length; i++) {\n    if (res[i] % 3 == 0) {\n      divisibleByThree.push(false);\n\
    \    } else {\n      divisibleByThree.push(true);\n    }\n  }\n\n  for (let i\
    \ = 0; i < divisibleByThree.length; i++) {\n    let flag: boolean = divisibleByThree[i];\n\
    \    for (let j = i + 1; j < res.length; j++) {\n      if (res[j] % 3 == flag)\
    \ {\n        res[j - 1] = res[j];\n      }\n    }\n  }\n\n  return res;\n}\n</code>\n\
    <|/ a tags=sorting,algorithm,javascript dscore=1 |>\n<| a |>\nI haven't tested\
    \ the efficiency, but this seems to work.\n<code>", "    const length: number\
    \ = l.length;\n    let newList: number[] = new Array(length);\n    for (let i:\
    \ number = 0; i < length; i++) {\n        const value: number = l[i];\n      \
    \  const secondIndex: number = i / 3;\n        newList[secondIndex] = value;\n\
    \    }\n    return newList;\n}\n", "    var l1 = [];\n    var l2 = [];\n    var\
    \ l3 = [];\n    var l4 = [];\n    var l5 = [];\n    var l6 = [];\n    var l7 =\
    \ [];\n    var l8 = [];\n    var l9 = [];\n    var l10 = [];\n    var l11 = [];\n\
    \    var l12 = [];\n    var l13 = [];\n    var l14 = [];\n    var l15 = [];\n\
    \    var l16 = [];\n    var l17 = [];\n    var l18 = [];\n    var l19 = [];\n\
    \    var l20 = [];\n    var l21 = [];\n    var l22 = [];\n    var l23 = [];\n\
    \    var l24 = [];\n    var l25 = [];\n    var l26 = [];\n    var l27 = [];\n\
    \    var l28 = [];\n    var l29 = [];\n    var l30 = [];\n    var l31 = [];\n\
    \    var l32 = [];\n    var l33 = [];\n    var l34 = [];\n    var l35 = [];\n\
    \    var l36 = [];\n    var l37 = [];\n    var l38 = [];\n    var l39 = [];\n\
    \    var l40 = [];\n    var l41 = [];\n    var l42 = [];\n    var l43 = [];\n\
    \    var l44 = [];\n    var l45 = [];\n    var l46 = [];\n    var l47 = [];\n\
    \    var l48 = [];\n    var l49 = [];\n    var l50 = [];\n    var l51 = [];\n\
    \    var l52 = [];\n    var l53 = [];\n    var l54 = [];\n    var l55 = [];\n\
    \    var l56 = [];\n    var l57 = [];\n    var l58 = [];\n    var l59 = [];\n\
    \    var l60 = [];\n    var l61 = [];\n    var l62 = [];\n    var l63 = [];\n\
    \    var l64 = [];\n    var l65 = [];\n    var l66 = [];\n    var l67 = [];\n\
    \    var l68 = [];\n    var l69 = [];\n    var l70 = [];\n    var l71 = [];\n\
    \    var l72 = [];\n    var l73 = [];\n    var l74 = [];\n    var l75 = [];\n\
    \    var l76 = [];\n    var l77 = [];\n    var l78 = [];\n    var l79 = [];\n\
    \    var l80 = [];\n    var l81 = [];\n    var l82 = [];\n    var l83 = [];\n\
    \    var l84 = [];\n    var l85 = [];\n    var l86 = [];\n    var l87 = [];\n\
    \    var l88 = [];\n    var l89 = [];\n    var l90 = [];\n    var l91 = [];\n\
    \    var l92 = [];\n    var l93 = [];\n    var l94 = [];\n    var l95 = [];\n\
    \    var l96 = [];\n    var l97 = [];\n    var l98", "    let m = l.length\n \
    \   if (m === 0) {\n        return []\n    }\n    let m = Math.floor(m / 3)\n\
    \    let l_1 = l.slice(0, m)\n    let l_2 = l.slice(m, 2 * m)\n    let l_3 = l.slice(2\
    \ * m, 3 * m)\n    let l_4 = l.slice(3 * m, m)\n    let l_5 = l.slice(2 * m, 2\
    \ * m)\n    let l_6 = l.slice(2 * m, m)\n    let l_7 = l.slice(0, m)\n    let\
    \ l_8 = l.slice(3 * m, 3 * m)\n    let l_9 = l.slice(3 * m, 2 * m)\n    let l_10\
    \ = l.slice(3 * m, m)\n    let l_11 = l.slice(0, 3 * m)\n    let l_12 = l.slice(3\
    \ * m, 3 * m)\n    let l_13 = l.slice(3 * m, 2 * m)\n    let l_14 = l.slice(3\
    \ * m, m)\n    let l_15 = l.slice(0, 2 * m)\n    let l_16 = l.slice(2 * m, 2 *\
    \ m)\n    let l_17 = l.slice(2 * m, m)\n    let l_18 = l.slice(0, m)\n    let\
    \ l_19 = l.slice(2 * m, 2 * m)\n    let l_20 = l.slice(2 * m, m)\n    let l_21\
    \ = l.slice(0, m)\n    let l_22 = l.slice(2 * m, m)\n    let l_23 = l.slice(0,\
    \ m)\n    let l_24 = l.slice(2 * m, m)\n    let l_25 = l.slice(0, m)\n    let\
    \ l_26 = l.slice(3 * m, 3 * m)\n    let l_27 = l.slice(3 * m, 2 * m)\n    let\
    \ l_28 = l.slice(3 * m, m)\n    let l_29 = l.slice(0, 3 * m)\n    let l_30 = l.slice(3\
    \ * m, 3 * m)\n    let l_31 = l.slice(3 * m, 2 * m)\n    let l_32 = l.slice(3\
    \ * m, m)\n    let l_33 = l.slice(0, 2 * m)\n    let l_34 = l.slice(2 * m, 2 *\
    \ m)\n    let l_35 = l.slice(2 * m, m)\n    let l_36 = l.slice(0, m)\n    let\
    \ l_37 = l.slice(2 * m, 2 * m)\n    let l_38 = l.slice(2 * m, m)\n    let l_39\
    \ = l.slice(0, m)\n    let l_40 = l.slice(2 * m, m)\n    let l_41 = l.slice(0,\
    \ m)\n    let l_42 = l.slice(2 * m, m)\n    let l_43 = l.slice(0, m)\n    let\
    \ l_44 = l.slice(2 * m, m)\n    let l_45 = l.slice(0, m)\n    let l_46 = l.slice(2\
    \ * m, m)\n    let l_47 = l.slice(0, m)\n    let l_48 = l.slice(3 * m, 3 * m)\n\
    \    let l_49 = l.slice(3 * m, 2 * m)\n    let l_50 = l.slice(3 * m, m)\n    let\
    \ l_51 = l.slice(0, 3 * m)\n    let l_52 = l.slice(3 * ", "  const n = l.length\n\
    \  let l2: number[] = []\n  let i: number = 0\n  let k: number = 0\n  while (i\
    \ < n) {\n    if (i % 3 === 0) {\n      k = Math.floor(i / 3)\n      l2[l2.length]\
    \ = l2[k]\n      l2[k] = l[i]\n    }\n    l2[l2.length] = l[i]\n    i += 1\n \
    \ }\n  return l2\n}\n", "    var i: number;\n    var j: number;\n    var mid:\
    \ number;\n    var len: number;\n    var newArr: number[] = [];\n    len = l.length;\n\
    \    for (i = 0; i < len - 1; i += 1) {\n        mid = Math.floor((i + 1) / 3);\n\
    \        for (j = 0; j < len - 1; j += 1) {\n            if (l[j] === l[mid])\
    \ {\n                break;\n            }\n            if (l[j] > l[mid]) {\n\
    \                newArr.push(l[j]);\n            }\n        }\n        if (j ===\
    \ len - 1) {\n            newArr.push(l[i]);\n        }\n    }\n    return newArr;\n\
    }\n", "  const result = [];\n  const map = {};\n\n  for (let i = 0; i < l.length;\
    \ i++) {\n    let k = l[i];\n    if (map[k] === undefined) {\n      map[k] = i;\n\
    \      result.push(k);\n    } else {\n      const j = map[k];\n      if (j ===\
    \ i || (j % 3 === 0 && map[l[j - 1]] === j / 3)) {\n        k = l[i];\n      }\n\
    \      map[k] = i;\n      result.push(k);\n    }\n  }\n  return result;\n}\n",
  "    let sorted: number[] = [];\n    for (let i = 0; i < l.length; i++) {\n    \
    \    if (i % 3 === 0) {\n            sorted.push(l[i]);\n        } else {\n  \
    \          sorted.sort((a, b) => a - b);\n        }\n    }\n    return sorted;\n\
    }", "    let l2 = [];\n    for (let j = 0; j < l.length; j++) {\n        if (l[j]\
    \ % 3 === 0) {\n            l2[l2.length] = l[j];\n        }\n    }\n    for (let\
    \ i = 0; i < l2.length; i++) {\n        for (let j = i + 1; j < l2.length; j++)\
    \ {\n            if (l2[i] !== l2[j] && l2[i] < l2[j]) {\n                let\
    \ temp = l2[i];\n                l2[i] = l2[j];\n                l2[j] = temp;\n\
    \            }\n        }\n    }\n    return l2;\n}", "  let i: number = l.length\n\
    \  let res: number[] = []\n  for (let j: number = 0; i < i; i += 3) {\n    res.push(l[j])\n\
    \  }\n  for (; i < i; i += 3) {\n    res.push(l[i])\n  }\n  return res\n}\n",
  "    let newArray: number[] = l.slice();\n    if (newArray.length > 2) {\n     \
    \   for (let i = newArray.length - 1; i >= 0; i--) {\n            newArray[i]\
    \ = newArray[i] % 3 === 1 ? newArray[i] + 1 : newArray[i];\n        }\n      \
    \  newArray.sort((a, b) => {\n            return b - a;\n        });\n    }\n\
    \    return newArray;\n}\n", "    let temp = [];\n    for (let i = 0; i < l.length;\
    \ i++) {\n        if (i % 3 === 0) {\n            temp[i] = l[i];\n        }\n\
    \    }\n    temp.sort();\n    let result = [];\n    for (let i = 0; i < temp.length;\
    \ i++) {\n        for (let j = 0; j < l.length; j++) {\n            if (j ===\
    \ i) {\n                result.push(l[j]);\n            } else {\n           \
    \     if (temp[i] === l[j]) {\n                    result.push(l[j]);\n      \
    \          }\n            }\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| a |>\nFor those who like \"readability\" I wrote this short little\
    \ snippet. It works by using the fact that in C a pointer can be moved around\
    \ by only adding 1 to the pointer. (It is not allowed to do so by moving a pointer\
    \ more than its size.)\nIn pseudocode (as far as I can tell):\n<code>\na = [1,2,3,4,5]\n\
    swap(l, i, j) {\n    temp = l[i]\n    l[i] = l[j]\n    l[j] = temp\n}\n\nb = []\n\
    i = 0\nfor(i; i<n; i++) {\n    swap(a, i, (i+1)%n\n    b.push(a[i])\n}\n</code>\n\
    <|/ a dscore=1 tags=arrays,algorithm |>\n<| c |>\nWhat about `swap(l, i, i+1)`?\n\
    <|/ c |>\n<| a |>\nUsing Ruby\n<code>\narr = [1, 2, 3, 4, 5]\narr.sort!\narr\n\
    </code>\n<|/ a dscore=1 tags=arrays,algorithm |>\n<| a tags=arrays,algorithm |>\n\
    Another solution in Python\n<code>\ndef swap_pairs(array):\n  i = 0\n  j = 1\n\
    \  while i < len(array):\n    if array[i] == array[j]:\n      array[i], array[j]\
    \ = array[j], array[i]\n      i += 1\n      j += 1\n    else:\n      i += 1\n\
    \      j += 1\n  return array\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=arrays,algorithm\
    \ |>\n<code>\npublic int[] sort3(int arr[]) {\n        int n = arr.length;\n \
    \       if (n >= 3) {\n            for (int i = 0; i < n - 3; i++) {\n       \
    \         int temp = arr[i];\n                for (int j = i + 1; j < i + 3; j++)\
    \ {\n                    if (arr[j] > temp) {\n                        temp =\
    \ arr[j];\n                    }\n                }\n                arr[i] =\
    \ temp;\n            }\n            int k = 0;\n            for (int i = n - 3;\
    \ i < n; i++) {\n                int temp = arr[i];\n                for (int\
    \ j = i + 1; j < i + 3; j++) {\n                    if (arr[j] > temp) {\n   \
    \                     temp = arr[j];\n                    }\n                }\n\
    \                arr[i] = temp;\n                for (int j = i + ", "\tlet l2\
    \ = l.slice();\n\tl2.sort((a, b) => a - b);\n\tlet j = 0;\n\tlet i = 3;\n\twhile\
    \ (i < l2.length) {\n\t\tif (l2[j] === 0) {\n\t\t\tl2[i] = 0;\n\t\t\tl2[j] = 0;\n\
    \t\t\tl2[i--] = 0;\n\t\t} else {\n\t\t\tl2[i] = l2[j];\n\t\t\tl2[j] = 0;\n\t\t\
    \tl2[--j] = 0;\n\t\t}\n\t}\n\treturn l2;\n}\n", "  return l.sort((a, b) => {\n\
    \    if (a % 3 === 0 && b % 3 === 0) {\n      return a - b;\n    } else {\n  \
    \    return 0;\n    }\n  });\n}\n", "  return l.sort((a,b) => a % 3 !== b % 3\
    \ ? -1 : 0);\n}\n", "    let newL: number[] = l.slice();\n    let temp: number\
    \ = 0;\n    for(let i = 0; i < newL.length; i++){\n        for(let j = 0; j <\
    \ i; j++){\n            if(newL[j] % 3 == 0 ){\n                temp = newL[i];\n\
    \                newL[i] = newL[j];\n                newL[j] = temp;\n       \
    \     }\n        }\n    }\n    return newL;\n}\n", "\tlet sorted: number[] = [];\n\
    \tlet index = 0;\n\tlet found: boolean;\n\twhile (index < l.length) {\n\t\tfound\
    \ = false;\n\t\tlet value = l[index];\n\t\tlet third = value % 3;\n\t\tif (third\
    \ == 0) {\n\t\t\tlet index = l[index];\n\t\t\tlet index = l[index];\n\t\t\twhile\
    \ (index < l.length) {\n\t\t\t\tlet value = l[index];\n\t\t\t\tlet third = value\
    \ % 3;\n\t\t\t\tif (third == 0) {\n\t\t\t\t\tlet index = l[index];\n\t\t\t\t\t\
    let index = l[index];\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\
    \ {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tindex++;\n\
    \t\t\t}\n\t\t}\n\t\tlet index = l[index];\n\t\twhile (index < l.length) {\n\t\t\
    \tlet value = l[index];\n\t\t\tif (value == value) {\n\t\t\t\tlet index = l[index];\n\
    \t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tif\
    \ (!found) {\n\t\t\tsorted[sorted.length] = value;\n\t\t\tindex++;\n\t\t}\n\t\
    }\n\treturn sorted;\n}\n", "    // This is pretty much the algorithm for the second\
    \ half of the bubble sort algorithm:\n    for (let i = 0; i < l.length / 2; i++)\
    \ {\n        let swap = false;\n        for (let j = 0; j < l.length; j += 3)\
    \ {\n            if (l[j] < l[j + 1]) {\n                swap = true;\n      \
    \          let temp = l[j];\n                l[j] = l[j + 1];\n              \
    \  l[j + 1] = temp;\n            }\n        }\n        if (!swap) {\n        \
    \    break;\n        }\n    }\n    return l;\n}\n", "    return l.filter((_, index)\
    \ => index === 0 || index % 3 === 0);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    I like your implementation. It does work, but I ended up just writing my own solution\
    \ that uses array indexes.\n<|/ c |>\n<| c |>\nYour code is very similar to the\
    \ code I had. My own implementation was similarly complex, but much shorter and\
    \ easier to read. Your implementation is better, though. I wish I could accept\
    \ both answers.\n<|/ c |>\n<| a dscore=1 |>\nHere is another one\n<code>\nconst\
    \ sort_third = (a) => a.reduce((acc,cur,i) => {\n    if ( i % 3 === 0 ) {\n  \
    \      acc.push( cur );\n    } else if ( i % 3 === 1 ) {\n        acc.push( acc.pop()\
    \ );\n        acc.push( cur );\n    } else {\n        acc.push( acc.pop() );\n\
    \        acc.push( acc.pop() );\n        acc.push( cur );\n    }\n    return acc;\n\
    },[]);\n</code>\n<|/ a tags=typescript,arrays |>\n<| a |>\nThis code solves it:\n\
    <code>\nconst sort_third = (array) => {\n    const result = [...array];\n    for\
    \ (let i = 0; i < array.length; i++) {\n        const third = result.slice(0,\
    \ i);\n        const rest = result.slice(i + 1);\n        for (let j = 0; j <\
    \ 3; j++) {\n            const index = third.findIndex((v) => v % 3 === j);\n\
    \            if (index > -1) {\n                third[index] = rest[index];\n\
    \            }\n        }\n        result.splice(0, i, ...third);\n    }\n   \
    \ return result;\n};\n</code>\nIt creates a new array with 3 elements smaller\
    \ than the original. The first 2 are copies of every 3 elements, and the last\
    \ is copies of every 3 elements of the rest array.\n<|/ a dscore=0 tags=typescript,arrays\
    \ |>\n<| c |>\nThis solution is not guaranteed to preserve the order of the original\
    \ array\n<|/ c |>\n<| c |>\nYou're right. The order is lost with the spread operator,\
    \ but this solution is not so bad, since it does only a single traversal.\n<|/\
    \ c |>\n<| c |>\nIt does, it's just that it's not guaranteed that the new array\
    \ will be sorted in the original order. Also, `slice` will create a copy of the\
    \ original array, and will also return a copy of the original array, so you're\
    \ not doing anything with the array that you're trying to avoid.\n<|/ c |>\n<|\
    \ c |>\nYes, you're right. I've modified the code so it will return a copy of\
    \ the ", "    return l.sort((a, b) => a - b).filter(\n        (_, i) => i % 3\
    \ === 0\n    );\n}\n", "\tlet n = l.length;\n\tlet sorted: number[] = new Array(n);\n\
    \tfor (let i = 0; i < n; i++) {\n\t\tlet k = 1;\n\t\twhile (i+k < n) {\n\t\t\t\
    if (l[i] % 3 !== l[i+k] % 3) {\n\t\t\t\tsorted.push(l[i]);\n\t\t\t\tsorted.push(l[i+k]);\n\
    \t\t\t\tk++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tif (k !==\
    \ n) {\n\t\t\tsorted.push(l[i]);\n\t\t}\n\t}\n\treturn sorted;\n}\n", "  let map\
    \ = new Map();\n  l.forEach(e => {\n    const value = e*e;\n    const index =\
    \ Math.floor(e/2);\n    map.set(value, index);\n  });\n  return Array.from(map.values()).sort((a,b)\
    \ => a-b).concat(Array.from(map.values()).sort((a,b) => b-a));\n}\n", "    return\
    \ l\n        .sort((a, b) => a % 3 === b % 3 ? a - b : 0)\n        .map((v, i)\
    \ => v * 3)\n        .concat(l.slice(l.length % 3));\n}\n", "    let l2: number[]\
    \ = [];\n    let n = l.length;\n    for (let i = 0; i < n; i += 3) {\n       \
    \ l2 = l2.concat( l.slice(i, i + 3) );\n    }\n    return l2;\n}\n", "    l.sort((a:\
    \ number, b: number) => {\n        if (a % 3 === 0 && b % 3 === 0) {\n       \
    \     return 0;\n        } else {\n            return a % 3 === b % 3 ? a > b\
    \ ? 1 : -1 : 1;\n        }\n    });\n    return l;\n}\n", "  var thirds: number[]\
    \ = [],\n    i = 0,\n    k = 1,\n    j = 2,\n    kLen = l.length,\n    l;\n  while\
    \ (kLen - 3 >= 0) {\n    while (kLen - 3 >= 0 && l[k] === l[kLen - 1]) {\n   \
    \   kLen -= 3;\n    }\n    if (kLen - 3 >= 0) {\n      thirds[k - 3] = l[kLen];\n\
    \      kLen -= 3;\n    }\n    while (kLen - 3 >= 0 && l[k] === l[kLen - 1]) {\n\
    \      kLen -= 3;\n    }\n    if (kLen - 3 >= 0) {\n      thirds[k - 1] = l[kLen];\n\
    \      kLen -= 3;\n    }\n    k++;\n  }\n  while (k < kLen) {\n    thirds[k -\
    \ 3] = l[k];\n    k++;\n  }\n  return thirds;\n}\n", "    let l1: number[] = l.slice();\n\
    \    l1.sort((a, b) => {\n        if ((a % 3) == 0) {\n            return -1;\n\
    \        } else if (b % 3) {\n            return 1;\n        } else {\n      \
    \      return 0;\n        }\n    });\n    return l1;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nTo solve this problem in C#, I found a solution thanks to this\
    \ page. Here it is:\n<code>\nstatic int[] SortThird(int[] input)\n{\n    int[]\
    \ result = input.OrderBy(i => (i % 3)).ToArray();\n    Array.Sort(result);\n \
    \   return result;\n}\n</code>\n<|/ a dscore=0 tags=c# |>\n<| a tags=c# dscore=0\
    \ |>\nThe way I solved this was by sorting the array into two groups. The first\
    \ group of numbers divisible by 3, and the second group of numbers divisible by\
    \ 2. The numbers in the first group were sorted, then the numbers in the second\
    \ group were sorted and placed back into the first group. Here is the code:\n\
    <code>\nusing System;\n\nnamespace ConsoleApp11\n{\n    class Program\n    {\n\
    \        static void Main(string[] args)\n        {\n            int[] numbers\
    \ = { 2, 5, 6, 4, 7, 3, 9, 8 };\n            int[] numbers3 = SortThird3(numbers);\n\
    \            Console.WriteLine(numbers3);\n            Console.ReadKey();\n  \
    \      }\n\n        public static int[] SortThird3(int[] numbers)\n        {\n\
    \            int numberOfElements = numbers.Length;\n            int[] result\
    \ = new int[numberOfElements];\n            int[] result3 = new int[numberOfElements];\n\
    \            int counter = 0;\n            int[] tempArray = new int[numberOfElements];\n\
    \n            Array.Copy(numbers, tempArray, 0, numberOfElements);\n\n       \
    \     while (counter < numberOfElements)\n            {\n                if (tempArray[counter]\
    \ % 3 == 0)\n                {\n                    Array.Copy(tempArray, counter,\
    \ result, 0, counter);\n                    Array.Copy(tempArray, counter, result3,\
    \ 0, counter);\n                    counter = counter + 1;\n                }\n\
    \                else if (tempArray[counter] % 2 == 0)\n                {\n  \
    \                  Array.Copy(tempArray, counter, result, 0, counter);\n     \
    \               Array.Copy(tempArray, counter, result3, counter, counter);\n \
    \                   counter = counter + 1;\n                }\n              \
    \  else\n                {\n                    counter = counter + 1;\n     \
    \           }\n            }\n\n            return result;\n        }\n    }\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis answer seems to have nothing in common with\
    \ the question asked.\n<|/ c |>\n", "    let result: number[] = [];\n    for (let\
    \ j = 0; j < l.length; j++) {\n        for (let i = 0; i < l.length - j; i++)\
    \ {\n            if (l[i] % 3 != 0) {\n                result.push(l[i]);\n  \
    \          }\n            if (l[i] % 3 == 0) {\n                let tmp: number\
    \ = l[i];\n                l[i] = l[i + 1];\n                l[i + 1] = tmp;\n\
    \            }\n        }\n    }\n    return result;\n}\n", "  const l3 = [];\n\
    \  const l4 = l.slice();\n  const l5 = l4.slice();\n  for (let i = 0; i < l4.length;\
    \ i++) {\n    const j = l4[i] % 3;\n    l4[i] = l5[j];\n    l5[j] = l4[i];\n \
    \ }\n  for (let i = 0; i < l4.length; i++) {\n    l3.push(l4[i]);\n  }\n  return\
    \ l3;\n}\n", "    const l1: number[] = [];\n    const l2: number[] = [];\n   \
    \ let i: number;\n    let j: number;\n\n    // l1 is identical to l except for\
    \ the indicies that are not divisible by three\n    for(i = 0; i < l.length; i++)\n\
    \    {\n        if( i % 3 === 0 ) continue;\n        l1.push(l[i]);\n    }\n\n\
    \    // l2 is identical to l except for the indicies that are  divisible by three\n\
    \    for(i = 0, j = 0, l = l1.length; i < l; i++)\n    {\n        if( l1 % 3 ===\
    \ 0 )\n        {\n            l2[j] = l[i];\n            j++;\n        }\n   \
    \ }\n\n    // merge l1 and l2\n    while(l1.length && l2.length)\n    {\n    \
    \    if( l1[0] > l2[0] )\n        {\n            l1.splice(0, 0, l2[0]);\n   \
    \         l2.splice(0, 1);\n        }\n        else\n        {\n            l2.splice(0,\
    \ 0, l1[0]);\n            l1.splice(0, 1);\n        }\n    }\n\n    return l1.concat(\
    \ l2 );\n}\n", "\tlet l3 = [];\n\tlet idx1 = 0;\n\tlet idx2 = 0;\n\tlet idx3 =\
    \ 0;\n\tfor (let i = 0; i < l.length; i++) {\n\t\tif (l[i] % 3 === 0) {\n\t\t\t\
    l3.push(l[i]);\n\t\t} else {\n\t\t\tif (idx3 > i) {\n\t\t\t\tl3.push(l[idx3]);\n\
    \t\t\t}\n\t\t\tif (idx2 > i) {\n\t\t\t\tl3.push(l[idx2]);\n\t\t\t}\n\t\t\tif (idx1\
    \ > i) {\n\t\t\t\tl3.push(l[idx1]);\n\t\t\t}\n\t\t\tidx1 = i;\n\t\t\tidx2 = i;\n\
    \t\t\tidx3 = i;\n\t\t}\n\t}\n\tif (idx3 > i) {\n\t\tl3.push(l[idx3]);\n\t}\n\t\
    if (idx2 > i) {\n\t\tl3.push(l[idx2]);\n\t}\n\tif (idx1 > i) {\n\t\tl3.push(l[idx1]);\n\
    \t}\n\treturn l3;\n}", "  l.sort((a, b) => a % 3 > b % 3 ? 1 : -1)\n  return l\n\
    }\n", "    const lCopy = l.slice();\n    const sorted = new Array(lCopy.length).fill(0);\n\
    \    for (let i = 0; i < lCopy.length; i++) {\n        const l = lCopy[i];\n \
    \       for (let j = i + 1; j < lCopy.length; j++) {\n            if (l % 3 !=\
    \ lCopy[j] % 3) {\n                sorted[lCopy[j]] = lCopy[j];\n            \
    \    sorted[lCopy[i]] = l;\n                break;\n            }\n        }\n\
    \    }\n    const sortedCopy = [];\n    for (let i = 0; i < sorted.length; i++)\
    \ {\n        sortedCopy.push(sorted[i]);\n    }\n    return sortedCopy;\n}", " \
    \   let res: number[] = [];\n    for (let i = 0; i < l.length; i++) {\n      \
    \  if (i % 3 != 0)\n            res.push(l[i]);\n        else\n            res.sort(function\
    \ (a, b) {\n                return a - b;\n            });\n    }\n    return\
    \ res;\n}\n", "    let ts: number[] = [];\n    let tmp: number[];\n    let i:\
    \ number;\n    let j: number;\n    let k: number;\n    let temp: number;\n   \
    \ for (let j = 0; j < l.length; j++) {\n        for (i = 0; i < l.length - j;\
    \ i++) {\n            if (i % 3 === 0) {\n                for (k = 0; k < l.length\
    \ - j; k++) {\n                    if (k === j) {\n                        break;\n\
    \                    }\n                    if (k % 3 === 0) {\n             \
    \           for (k = 0; k < l.length - j; k++) {\n                           \
    \ if (k === i || k === j || k === l.length - j - 1) {\n                      \
    \          break;\n                            }\n                           \
    \ if (k % 3 === 0) {\n                                temp = l[i];\n         \
    \                       l[i] = l[k];\n                                l[k] = temp;\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    for (i = 0; i <\
    \ l.length - 1; i++) {\n        for (j = i + 1; j < l.length; j++) {\n       \
    \     k = i + j;\n            if (l[k] < l[i]) {\n                temp = l[i];\n\
    \                l[i] = l[k];\n                l[k] = temp;\n            }\n \
    \       }\n    }\n    ts.push(...l);\n    return ts;\n}\n", "\tconst l = l.slice();\n\
    \tconst length: number = l.length;\n\n\tconst lprime: number[] = new Array(length).fill(l[0]);\n\
    \tconst lprimeprime: number[] = new Array(length).fill(lprime[0]);\n\n\tlet third:\
    \ number;\n\tlet thirdprime: number;\n\tfor (let i: number = 0; i < length; i++)\
    \ {\n\t\tthirdprime = l[i];\n\t\tthird = lprimeprime[i];\n\n\t\tfor (let j: number\
    \ = i + 1; j < length; j++) {\n\t\t\tif (lprimeprime[j] % 3 != 0) {\n\t\t\t\t\
    lprimeprime[j] = l[j];\n\t\t\t} else {\n\t\t\t\tlprimeprime[j] = lprimeprime[j]\
    \ % 3;\n\t\t\t\tl[j] = thirdprime;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (let i: number\
    \ = 0; i < length; i++) {\n\t\tl[i] = lprime[i];\n\t}\n\n\treturn l;\n}\n", "\t\
    let l = l.slice();\n\tlet l1 = [];\n\tlet l2 = [];\n\tlet l3 = [];\n\tlet i =\
    \ 0;\n\twhile (i < l.length) {\n\t\tif (l[i] % 3 === 0) {\n\t\t\tl2.push(l[i]);\n\
    \t\t} else {\n\t\t\tl3.push(l[i]);\n\t\t}\n\t\ti++;\n\t}\n\twhile (i < l.length)\
    \ {\n\t\tif (l[i] % 3 === 1) {\n\t\t\tl2.push(l[i]);\n\t\t} else {\n\t\t\tl3.push(l[i]);\n\
    \t\t}\n\t\ti++;\n\t}\n\twhile (i < l.length) {\n\t\tif (l[i] % 3 === 2) {\n\t\t\
    \tl2.push(l[i]);\n\t\t} else {\n\t\t\tl3.push(l[i]);\n\t\t}\n\t\ti++;\n\t}\n\t\
    while (i < l.length) {\n\t\tif (l[i] % 3 === 1) {\n\t\t\tl2.push(l[i]);\n\t\t\
    } else {\n\t\t\tl3.push(l[i]);\n\t\t}\n\t\ti++;\n\t}\n\twhile (i < l.length) {\n\
    \t\tif (l[i] % 3 === 0) {\n\t\t\tl2.push(l[i]);\n\t\t} else {\n\t\t\tl3.push(l[i]);\n\
    \t\t}\n\t\ti++;\n\t}\n\twhile (i < l.length) {\n\t\tif (l[i] % 3 === 2) {\n\t\t\
    \tl2.push(l[i]);\n\t\t} else {\n\t\t\tl3.push(l[i]);\n\t\t}\n\t\ti++;\n\t}\n\t\
    while (i < l.length) {\n\t\tif (l[i] % 3 === 0) {\n\t\t\tl2.push(l[i]);\n\t\t\
    } else {\n\t\t\tl3.push(l[i]);\n\t\t}\n\t\ti++;\n\t}\n\twhile (i < l.length) {\n\
    \t\tif (l[i] % 3 === 2) {\n\t\t\tl2.push(l[i]);\n\t\t} else {\n\t\t\tl3.push(l[i]);\n\
    \t\t}\n\t\ti++;\n\t}\n\twhile (i < l.length) {\n\t\tif (l[i] % 3 === 1) {\n\t\t\
    \tl2.push(l[i]);\n\t\t} else {\n\t\t\tl3.push(l[i]);\n\t\t}\n\t\ti++;\n\t}\n\t\
    while (i < l.length) {\n\t\tif (l[i] % 3 === 0) {\n\t\t\tl2.push(l[i]);\n\t\t\
    } else {\n\t\t\tl3.push(l[i]);\n\t\t}\n\t\ti++;\n\t}\n\twhile (i < l.length) {\n\
    \t\tif (l[i] % 3 === 2) {\n\t\t\tl2.push(l[i]);\n\t\t} else {\n\t\t\tl3.push(l[i]);\n\
    \t\t}\n\t\ti++;\n\t}\n\twhile (i < l.length) {\n\t\tif (l[i] % 3 === 1) {\n\t\t\
    \tl2.push(l[i]);\n\t\t} else {\n\t\t\tl3.push(l[i]);\n\t\t}\n\t\ti++;\n\t}\n\t\
    while (i < l.length) {\n\t\tif (l[i] % 3 === 0) {\n\t\t\tl2.push(l[i]);\n\t\t\
    } else {\n\t\t\tl3.push(l[i]);\n\t\t}\n", "    let l1: number[] = [];\n    let\
    \ i: number;\n    let j: number;\n    for (i = 0; i < l.length; ++i) {\n     \
    \   let temp: number = l[i];\n        let ind = l.indexOf(temp);\n        if (ind\
    \ > 0 && ind % 3 === 0) {\n            l1.push(temp);\n        }\n        else\
    \ {\n            l1.unshift(temp);\n        }\n    }\n    l1 = l1.sort();\n  \
    \  let newL: number[] = [];\n    for (i = 0; i < l1.length; i++) {\n        newL.push(l1[i]);\n\
    \    }\n    return newL;\n}\n", "    var l3 = (l[0] & 0x3) * 0x30 + l[1] & 0x3\n\
    \    var l2 = (l[0] & 0x2) * 0x30 + l[1] & 0x2\n    var l1 = (l[0] & 0x1) * 0x30\
    \ + l[1] & 0x1\n    var l0 = (l[0] & 0x0) * 0x30 + l[1] & 0x0;\n    var l31 =\
    \ (l[3] & 0x3) * 0x30 + l[2] & 0x3\n    var l3 = (l[3] & 0x2) * 0x30 + l[2] &\
    \ 0x2\n    var l2 = (l[3] & 0x1) * 0x30 + l[2] & 0x1\n    var l1 = (l[3] & 0x0)\
    \ * 0x30 + l[2] & 0x0;\n    var l0 = (l[3] & 0x0) * 0x30 + l[2] & 0x0;\n    var\
    \ l11 = (l[5] & 0x3) * 0x30 + l[4] & 0x3\n    var l3 = (l[5] & 0x2) * 0x30 + l[4]\
    \ & 0x2\n    var l2 = (l[5] & 0x1) * 0x30 + l[4] & 0x1\n    var l1 = (l[5] & 0x0)\
    \ * 0x30 + l[4] & 0x0;\n    var l0 = (l[5] & 0x0) * 0x30 + l[4] & 0x0;\n    var\
    \ l111 = (l[7] & 0x3) * 0x30 + l[6] & 0x3\n    var l3 = (l[7] & 0x2) * 0x30 +\
    \ l[6] & 0x2\n    var l2 = (l[7] & 0x1) * 0x30 + l[6] & 0x1\n    var l1 = (l[7]\
    \ & 0x0) * 0x30 + l[6] & 0x0;\n    var l0 = (l[7] & 0x0) * 0x30 + l[6] & 0x0;\n\
    \    var l111 = (l[9] & 0x3) * 0x30 + l[8] & 0x3\n    var l3 = (l[9] & 0x2) *\
    \ 0x30 + l[8] & 0x2\n    var l2 = (l[9] & 0x1) * 0x30 + l[8] & 0x1\n    var l1\
    \ = (l[9] & 0x0) * 0x30 + l[8] & 0x0;\n    var l0 = (l[9] & 0x0) * 0x30 + l[8]\
    \ & 0x0;\n    var l1111 = (l[11] & 0x3) * 0x30 + l[10] & 0x3\n    var l3 = (l[11]\
    \ & 0x2) * 0x30 + l[10] & 0x2\n    var l2 = (l[11] & 0x1) * 0x30 + l[10] & 0x1\n\
    \    var l1 = (l[11] & 0x0) * 0x30 + l[10] & 0x0;\n    var l0 = (l[11] & 0x0)\
    \ * 0x30 + l[10] & 0x", "  var len = l.length;\n  var lt = [];\n  var a = 0;\n\
    \  var b = 0;\n  var c = 1;\n  for (var i = 0; i < len; a = b, c = b + 1, b =\
    \ a) {\n    if (l[a] % 3 === 0) c = b + 1, lt.push(l[a]), l[a] = l[c];\n    if\
    \ (l[b] % 3 === 1) a = b + 1, lt.push(l[b]), l[b] = l[a];\n    if (l[c] % 3 ===\
    \ 2) a = b + 1, lt.push(l[c]), l[c] = l[a];\n  }\n  return lt;\n}\n", "  let result\
    \ = [...l]\n  for (let i = 0; i < 3; i++) {\n    let j = 0\n    while (j < 3 &&\
    \ result[j] === result[j + 3]) j++\n    result.splice(j, 1, result[j])\n  }\n\
    \  return result\n}\n", "    const newList: number[] = l.slice();\n\n    for (let\
    \ i = 1; i < newList.length; i++) {\n        for (let j = i; j > 0; j--) {\n \
    \           if (newList[j] % 3 === 0) {\n                let temp = newList[j];\n\
    \                let tmpIndex = j;\n                for (let k = j - 1; k >= i;\
    \ k--) {\n                    if (newList[k] % 3 === 0) {\n                  \
    \      newList[k + 1] = newList[k];\n                        newList[k] = temp;\n\
    \                        tmpIndex = k;\n                    }\n              \
    \  }\n                newList[tmpIndex + 1] = newList[tmpIndex];\n           \
    \     newList[tmpIndex] = temp;\n            }\n        }\n    }\n\n    return\
    \ newList;\n}", "\tl.sort((a, b) => Math.abs(b) - Math.abs(a))\n\tconst l2 = []\n\
    \tfor (let i = 0; i < l.length; i++) {\n\t\tif (i % 3 === 0) {\n\t\t\tl2.push(l[i])\n\
    \t\t}\n\t}\n\treturn l2\n}\n", "  let l1 = l.slice();\n  let l = l1.sort((a: number,\
    \ b: number) => a - b).sort((a: number, b: number) => a > b).sort((a: number,\
    \ b: number) => a < b);\n  return l;\n}\n", "\tl.sort((a: number, b: number) =>\
    \ a - b);\n\tlet i = l.length - 1;\n\tfor (let j = 0; j < i; j--) {\n\t\tif (l[j]\
    \ % 3 !== 0) {\n\t\t\tlet swap = l[j];\n\t\t\tl[j] = l[j + 1];\n\t\t\tl[j + 1]\
    \ = swap;\n\t\t}\n\t}\n\treturn l;\n}\n", "  const len: number = l.length;\n \
    \ for (let i = 1; i < len; ++i) {\n    const k = 3 - i / 3;\n    const j = i %\
    \ 3;\n    if (j === 0 || j === 1) {\n      const t = l[i];\n      l[i] = l[k];\n\
    \      l[k] = t;\n    }\n  }\n  return l;\n}\n", "  l.sort((a, b) => b - a);\n\
    \  for (let i = 0; i < l.length; i += 3) {\n    if (l[i] !== l[i + 1] || l[i +\
    \ 1] !== l[i + 2]) {\n      const v = l[i];\n      l[i] = l[i + 1];\n      l[i\
    \ + 1] = v;\n    }\n  }\n  return l;\n}\n", "  l.sort(function(a, b) {\n    return\
    \ a - b\n  })\n  for (var i = 1; i < l.length; i++) {\n    if (l[i] % 3 != 0)\
    \ {\n      for (var j = 0; j < i; j++) {\n        l[j - i - 1] = l[j - 1]\n  \
    \    }\n      l[j - 1] = l[i]\n    }\n  }\n  return l\n}\n", "  let l3: number[]\
    \ = [];\n  l3.length = l.length;\n  let len: number;\n  let i: number;\n  let\
    \ j: number;\n  \n  len = l.length;\n  for (i = 0; i < len; i++) {\n    j = i;\n\
    \    while ((j -= 3) > -1) {\n      if (l[j] > l[j + 1]) {\n        l3[j + 1]\
    \ = l[j];\n      }\n    }\n  }\n  return l3;\n}\n", "    for (let i = 3; i < l.length;\
    \ i++){\n        for(let j = i; j > 0; j--){\n            if(l[j] % 3 == 0){\n\
    \                let temp = l[j];\n                l[j] = l[j - 1];\n        \
    \        l[j - 1] = temp;\n            }\n        }\n    }\n    return l;\n}\n\
    </code>\n<|/ a dscore=0 tags=arrays,sorting,javascript |>\n<| a |>\n<code>\nvar\
    \ input = [7, 1, 3, 9, 5, 2, 6, 4, 8];\nvar sorted_input = [1, 3, 5, 6, 4, 7,\
    \ 9, 2, 8];\nvar output = input;\noutput = [...output.sort((a, b) => a - b)];\n\
    console.log(sorted_input);\n</code>\n<|/ a dscore=0 tags=arrays,sorting,javascript\
    \ |>\n<| a tags=arrays,sorting,javascript |>\nThe most efficient and compact way\
    \ to do this is using Array#sort and Array#reverse:\n\n<code>\nconst arr = [2,\
    \ 6, 3, 4, 8, 9, 5];\nconst res = arr\n  .reduce((a, x, i, arr) => x.filter((y,\
    \ j) => !(i + j) % 3)\n  .reduce((a, b) => [...a, [...arr, b]], []))\n  .reverse();\n\
    \nconsole.log(res);</code>\n\nTo understand how it works, please see the following\
    \ examples:\n<code>\nconst arr = [2, 6, 3, 4, 8, 9, 5];\n</code>\nThe above example\
    \ is a array where each number of the array represents a position in the array,\
    \ so the first number in the array is at index 0, the second at index 1, ...\n\
    <code>\nconst res = arr\n  .reduce((a, x, i, arr) => x.filter((y, j) => !(i +\
    \ j) % 3)\n  .reduce((a, b) => [...a, [...arr, b]], []))\n  .reverse();\n</code>\n\
    In the above example, the first reduce function will filter all numbers that are\
    \ not divisible by 3, in other words: it will remove all the elements between\
    \ position 0 and position 2 (excluding the position itself). So, when arr equals\
    \ the following:\n<code>\nconst arr = [2, 6, 3, 4, 8, 9, 5, 7];\n</code>\nThe\
    \ output will be:\n<code>\n[\n  [ 8, 5, 2 ],\n  [ 3, 4, 9 ],\n  [ 6, 7 ]\n]\n\
    </code>\nThe next reduce function will take all the resulting arrays and flatten\
    \ them into a single array. So we will have the following output:\n<code>\n[\n\
    \  [ 8, 5, 2 ],\n  [ 3, 4, 9 ],\n  [ 6, 7 ]\n  [ 7, 5 ]\n]\n</code>\nFinally,\
    \ the second reduce function will reverse the result array", "\tconst l2 = [];\n\
    \tlet min: number = l[0];\n\tfor (const i of l) {\n\t\tif (i % 3 !== 0) {\n\t\t\
    \tl2.push(i);\n\t\t\tif (i < min) {\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t} else if\
    \ (i % 3 === 0) {\n\t\t\tif (l2.length === 0) {\n\t\t\t\tl2.push(i);\n\t\t\t}\
    \ else if (l2[0] > i) {\n\t\t\t\tl2.shift();\n\t\t\t\tl2.push(i);\n\t\t\t} else\
    \ {\n\t\t\t\tl2[0] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const i of l2) {\n\t\tl.push(i);\n\
    \t}\n\tl.sort(function(a, b) {\n\t\treturn a - b;\n\t});\n\treturn l;\n}\n", " \
    \ const n = 3; // how many times we want to repeat an index\n  let t = [...l];\
    \ // temporary array\n\n  while (n--) {\n    const k = find_index(t, 3);\n   \
    \ if (k !== -1) {\n      t = swap(t, k, find_index(t, k + 2));\n    }\n  }\n \
    \ return t;\n}\n", "    let l1 = l.slice();\n    let l2 = [];\n    let l3 = [];\n\
    \    for (let i = 0; i < l1.length; i++) {\n        if (i % 3 === 0) {\n     \
    \       l2.push(l1[i]);\n        } else {\n            l3.push(l1[i]);\n     \
    \   }\n    }\n    for (let i = 0; i < l2.length; i++) {\n        for (let j =\
    \ 0; j < l3.length; j++) {\n            if (l2[i] === l3[j]) {\n             \
    \   for (let k = i; k < l3.length; k++) {\n                    l1[k] = l2[k];\n\
    \                }\n            }\n        }\n    }\n    return l1;\n}\n", "\t\
    let length = l.length;\n\tlet third_length = (length % 3) * 2;\n\tlet middle =\
    \ Math.floor(length / 3);\n\tlet first_part = l.slice(0, middle);\n\tlet second_part\
    \ = l.slice(middle, third_length);\n\tlet third_part = l.slice(third_length);\n\
    \tlet new_array = new Array(third_length);\n\tlet j = 0;\n\tfor (var i = 0; i\
    \ < third_length; i++) {\n\t\tnew_array[i] = third_part[j];\n\t\tj = j + 1;\n\t\
    }\n\treturn new_array.concat(first_part, second_part);\n}\n", "  let l2 = l.slice();\n\
    \  l2.sort((a, b) => a % 3 === b % 3 ? a - b : a - b);\n  return l2;\n}\n", " \
    \   let third = Math.floor(l.length / 3);\n    let result = l[0];\n    for (let\
    \ i = 1; i < third; i++) {\n        let temp = l[i];\n        for (let j = i -\
    \ 1; j >= 0; j--) {\n            if (l[j] % 3 !== 0)\n                break;\n\
    \            if (l[j] % 3 === 0) {\n                l[j] = l[j];\n           \
    \     break;\n            }\n        }\n        l[i] = temp;\n    }\n    return\
    \ l;\n}\n</code>\n<|/ a |>\n<| c |>\nThat's really a nice answer, but I think\
    \ you left out a critical part of the question: \"It needs to be a stable sort.\"\
    \ The stable part is *not* the key to the algorithm, it's the fact that repeated\
    \ values will always be grouped together if they have the same \"third digit.\"\
    \ The third \"digit\" being the key element here.\n<|/ c |>\n<| c |>\nI suppose\
    \ I missed that. The code I posted does indeed sort all values that share the\
    \ same third. I believe the stability of the algorithm is what matters, not the\
    \ number of values in the list that share the same third. I'll update my answer\
    \ to state that I believe the stability is what matters.\n<|/ c |>\n<| c |>\n\
    Yeah, I missed the stability bit too. The code I posted does indeed do what you're\
    \ looking for. Sorry about that.\n<|/ c |>\n<| c |>\nThanks for your answer. But\
    \ the problem is, that sorting numbers doesn't work on my side. I would like to\
    \ see a solution where sorting works for every number for instance \"10\" instead\
    \ of just \"2\"\n<|/ c |>\n<| c |>\nThe sorting algorithm I posted does indeed\
    \ work on **all** numbers that share the same third. The only thing that the sorting\
    \ algorithm doesn't do is that some values (such as \"10\") have more than one\
    \ \"third digit\" (such as \"2\", \"4\", \"6\"). Since you asked to have all values\
    \ \"10\" grouped together, \"10\" should come before \"2\" in the sorted list.\n\
    <|/ c |>\n<| a |>\nFirst of all, this is an algorithmic problem and you can not\
    \ simply find an algorithm that does this for you. You need to understand how\
    \ sorting works. When sorting numbers you need to sort them in \"natural order\"\
    \ which means \"1, 2, 3, 10, 11, 12, 13, 14, 15\". \nThis means, that if you want\
    \ to sort numbers like this you need to sort them in their natural order. The\
    \ solution that you want is a stable sort, meaning that you should not change\
    \ anything about your list. \nThere are several approaches you can use: \n\nSorting\
    \ the list as ", "    return l.sort(function (a, b) { return a - b })\n}\n", " \
    \   l.sort((a, b) => b - a);\n    return l;\n}\n", "  const newArr = l.slice();\n\
    \  let flag = true;\n  newArr.forEach((e, i) => {\n    if (i % 3 === 0) {\n  \
    \    flag = false;\n    }\n  });\n  if (flag) {\n    return newArr;\n  }\n  for\
    \ (let i = 0; i < newArr.length; i++) {\n    for (let j = 0; j < newArr.length;\
    \ j++) {\n      if (newArr[j] < newArr[i]) {\n        const t = newArr[i];\n \
    \       newArr[i] = newArr[j];\n        newArr[j] = t;\n      }\n    }\n  }\n\
    \  return newArr;\n}\n", "  l.sort((a, b) => a - b)\n  return l\n}\n", "  var\
    \ result: number[] = [],\n    i: number,\n    count: number = l.length;\n\n  for\
    \ (i = 0; i < count; i++) {\n    if (i % 3 === 0) {\n      result.push(l[i]);\n\
    \    }\n  }\n\n  return result;\n}\n", "  const l2 = l.slice();\n  l2.sort((a,\
    \ b) => a % 3 !== b % 3 ? a - b : a - b);\n  return l2;\n}\n", "    return l.sort((a,\
    \ b) => a - b);\n}\n", "\tlet tmp: number[] = l.slice();\n\tfor(let i = 0; i <\
    \ tmp.length; i++) {\n\t\tfor(let j = 0; j < tmp.length; j++) {\n\t\t\tlet k =\
    \ j + i + 1;\n\t\t\tif (tmp[j] % 3 === 0 && tmp[k] % 3 === 0) {\n\t\t\t\ttmp[j]\
    \ += tmp[k]; \n\t\t\t\ttmp[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn tmp;\n}\n",
  "  const a = new Array(l.length);\n  for (let i = 0; i < l.length; i++) {\n    a[i]\
    \ = i;\n  }\n  for (let i = 0; i < l.length / 3; i++) {\n    const first = a[i];\n\
    \    for (let j = i + 1; j < l.length / 3; j++) {\n      const second = a[j];\n\
    \      const third = a[a[j] + 1];\n      if (third < first || second < first)\
    \ {\n        a[i] = third;\n        a[j] = second;\n        a[a[j] + 1] = first;\n\
    \      }\n    }\n  }\n  return a;\n}\n", "  let arr: number[] = [];\n  for (let\
    \ i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      arr.push(l[i]);\n\
    \    }\n  }\n  return arr;\n}\n", "    let thirds: number[] = [];\n    for (let\
    \ i = 0; i < l.length - 1; i++) {\n        if (i % 3 != 0) thirds.push(l[i]);\n\
    \    }\n    thirds.push(l[l.length - 1]);\n    for (let j = 0; j < thirds.length;\
    \ j++) {\n        for (let i = 0; i < l.length - 1; i++) {\n            if (thirds[j]\
    \ < l[i]) {\n                let temp = thirds[j];\n                thirds[j]\
    \ = l[i];\n                l[i] = temp;\n            }\n        }\n    }\n   \
    \ return thirds;\n}\n", "    return l.sort((x, y) => { \n        return x % 3\
    \ === y % 3 ? 0 : (x < y ? -1 : 1)\n    })\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\nTo me this seems much simpler, and it does it without having\
    \ to create 2 arrays of any kind:\n<code>", "\tconst result: number[] = [];\n\n\
    \t//The array is empty or has only three elements\n\tif (l.length <= 3) {\n\t\t\
    return l;\n\t}\n\n\t//If the length of the array is less than or equal to three,\
    \ split the array into three, each one less than or equal to three\n\tlet [lower,\
    \ upper] = l.length < 3 ? [null, null] : [null, l.length / 3];\n\n\t//Set the\
    \ lower and upper bounds of the loop\n\tif (lower != null) {\n\t\t//Iterate through\
    \ the lower bound to find any indicies that are divisible by three\n\t\tfor (let\
    \ i = 0; i < lower; i++) {\n\t\t\t//If the current index divided by three has\
    \ a remainder that is zero\n\t\t\tif (l[i] % 3 === 0) {\n\t\t\t\t//Add the current\
    \ value to the result\n\t\t\t\tresult.push(l[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Set\
    \ the upper bound\n\tif (upper != null) {\n\t\t//Iterate through the upper bound\n\
    \t\tfor (let i = lower + 1; i < upper; i++) {\n\t\t\t//If the current index divided\
    \ by three has a remainder that is zero\n\t\t\tif (l[i] % 3 === 0) {\n\t\t\t\t\
    //Add the current value to the result\n\t\t\t\tresult.push(l[i]);\n\t\t\t}\n\t\
    \t}\n\t}\n\n\treturn result;\n}\n", "    let l1 = l.slice().sort((a: number, b:\
    \ number) => {\n        return a % 3 === b % 3 ? a < b ? -1 : 1 : a === b ? 0\
    \ : a > b ? 1 : -1\n    })\n    \n    return l1.map(i => l[i / 3])\n}\n", "\t\
    let l3 = [];\n\tlet i = l.length - 1;\n\twhile (i) {\n\t\tl3.push(l[i]);\n\t\t\
    i -= 3;\n\t}\n\treturn l3;\n}\n", "  l = [...l].sort((a, b) => a - b).filter(a\
    \ => a % 3 === 0);\n  let [first] = l;\n  return l.map((a, b) => a === first ?\
    \ b : a);\n}\n</code>\n<|/ a dscore=1 tags=javascript,arrays |>\n<| c |>\nThe\
    \ function `sort_third()` seems to work even if the input list has two equal numbers\
    \ and it sorts the list correctly.\n<|/ c |>\n<| c |>\nYeah, I didn't think about\
    \ that.\n<|/ c |>\n<| a dscore=0 tags=javascript,arrays |>\n<code>", "\tl.sort((a,\
    \ b) => {\n\t\t// This assumes the arrays are the same length\n\t\tlet aDivThree\
    \ = b%3 == 0;\n\t\tlet bDivThree = a%3 == 0;\n\n\t\tif (aDivThree && bDivThree)\
    \ {\n\t\t\treturn 0;\n\t\t}\n\t\telse if (aDivThree && !bDivThree) {\n\t\t\treturn\
    \ 1;\n\t\t}\n\t\telse if (!aDivThree && bDivThree) {\n\t\t\treturn -1;\n\t\t}\n\
    \n\t\t// Otherwise, it should be the case that a%3 === b%3\n\t\tlet aDivThreeValues\
    \ = aDivThree ? 1 : -1;\n\t\tlet bDivThreeValues = bDivThree ? 1 : -1;\n\n\t\t\
    if (a < b) {\n\t\t\treturn aDivThreeValues * -1;\n\t\t}\n\t\telse {\n\t\t\treturn\
    \ bDivThreeValues * -1;\n\t\t}\n\t});\n\treturn l;\n}\n", "  if (l.length < 3)\
    \ return l;\n  let l3 = l.slice(0, l.length / 3);\n  return merge_sorted_array(l3,\
    \ sort_third(l3.slice(l.length / 3)));\n}\n</code>\nThe code is untested, and\
    \ it uses some stuff that wasn't part of your original question, but I hope the\
    \ above is helpful!\n<|/ a |>\n<| c |>\nThis was great! I used the code as is\
    \ and changed it a little bit for my use case. I added an answer with the solution\
    \ to my original question. Thanks so much!\n<|/ c |>\n<| a tags=c#,arrays,sorting\
    \ dscore=1 |>\nI came up with a solution that combines multiple answers here into\
    \ one method. I was able to solve my original question by using my original code\
    \ and then making use of the SortedList class in the System.Collections.Generic\
    \ namespace.\nI made a class called SortedArrayList that implements the ICollection\
    \ interface and I passed it to my program as a List. The List.Sort method uses\
    \ Quick Sort, and it sorts the array first by values divisible by three, then\
    \ by values not divisible by three.\n<code>\npublic class SortedArrayList : ICollection<Item>\
    \ {\n    private IList<Item> _contents;\n\n    public SortedArrayList(IList<Item>\
    \ contents) {\n        _contents = new List<Item>(contents);\n    }\n\n    public\
    \ SortedArrayList(params Item[] contents) {\n        _contents = new List<Item>(contents);\n\
    \    }\n\n    public IList<Item> GetList() {\n        return _contents;\n    }\n\
    \n    public int Count => _contents.Count;\n\n    public bool IsReadOnly => false;\n\
    \n    public void Add(Item item) {\n        _contents.Add(item);\n    }\n\n  \
    \  public void Clear() {\n        _contents.Clear();\n    }\n\n    public bool\
    \ Contains(Item item) => _contents.Contains(item);\n\n    public void CopyTo(Item[]\
    \ array, int arrayIndex) {\n        _contents.CopyTo(array, arrayIndex);\n   \
    \ }\n\n    public IEnumerator<Item> GetEnumerator() {\n        return _contents.GetEnumerator();\n\
    \    }\n\n    public bool Remove(Item item) => _contents.Remove(item);\n\n   \
    \ public bool Remove(object item) {\n        return Remove((Item)item);\n    }\n\
    \n    public int IndexOf(Item item) => _contents.IndexOf(item);\n\n    public\
    \ void Insert(int index, Item item) {\n        _contents.Insert(index, item);\n\
    \    }\n\n    public void RemoveAt(int index) {\n        _contents.RemoveAt(index);\n\
    \    }\n\n    public void RemoveRange(IEnumerable<Item> range) {\n        _contents.RemoveRange(range);\n\
    \    }\n\n    public IEnumerator<Item> GetEnumerator() {\n        return _", " \
    \   const len = l.length;\n    let i;\n    let j;\n    let k;\n    let l;\n  \
    \  const len2 = len / 3;\n    const len2new = len * 2;\n\n    l = [...l];\n  \
    \  l.sort();\n    i = 1;\n    while (i < len2) {\n        j = i;\n        while\
    \ (j < len2) {\n            if (l[j] > l[j + 1]) {\n                k = j;\n \
    \               l = l[k];\n                l[k] = l[j];\n                l[j]\
    \ = k;\n            }\n            j++;\n        }\n        i++;\n    }\n    return\
    \ l;\n}\n", "    var lLength = l.length;\n    var l1 = [];\n    var l2 = [];\n\
    \    var thirdValue = lLength % 3;\n    var index;\n\n    for (var i = 0; i <\
    \ lLength; i++) {\n        index = i;\n\n        if (index % 3 === 0) {\n    \
    \        l1.push(l[index]);\n        }\n\n        if (index < thirdValue) {\n\
    \            l2.push(l[index]);\n        } else {\n            l1.push(l[index\
    \ - thirdValue]);\n            l2.push(l[index - thirdValue]);\n        }\n  \
    \  }\n\n    return l2.concat(l1);\n}\n", "  l.sort((a: number, b: number) => {\n\
    \    if (a % 3 === 0) {\n      if (b % 3 === 0) {\n        return a < b;\n   \
    \   }\n      return a < b ? 1 : -1;\n    }\n    if (b % 3 === 0) {\n      return\
    \ -1;\n    }\n    return a < b ? -1 : 1;\n  });\n  return l;\n}\n", "    let l_copy:\
    \ number[] = [...l];\n    let res: number[] = [];\n    let mid: number = 0;\n\
    \    for (let i = 1; i < l_copy.length; i++) {\n        while (l_copy[mid] < l_copy[i])\
    \ {\n            mid += 1;\n        }\n        while (l_copy[mid] > l_copy[i])\
    \ {\n            mid -= 1;\n        }\n        if (mid === 0 || mid === i) {\n\
    \            res[0] = l_copy[mid - 1];\n            res[i] = l_copy[mid];\n  \
    \          break;\n        } else {\n            res[res.length] = l_copy[mid];\n\
    \        }\n    }\n    return res;\n}\n", "  let res: number[] = [];\n  let ind:\
    \ number[] = l.sort((a, b) => a - b);\n  res[0] = l[ind[0]];\n  res[ind[0]] =\
    \ l[ind[1]];\n  res[ind[1]] = l[ind[2]];\n  return res;\n}\n", "\tlet n = l.length;\n\
    \tlet res = [];\n\tlet p = 0;\n\tlet q = 0;\n\tlet temp = 0;\n\twhile (p < n)\
    \ {\n\t\twhile (q < n && l[p] < l[q] && l[p] % 3 !== 0) {\n\t\t\tq++;\n\t\t}\n\
    \t\twhile (q < n && l[p] > l[q] && l[p] % 3 === 0) {\n\t\t\tq++;\n\t\t}\n\t\t\
    if (q < n) {\n\t\t\ttemp = (l[p] + l[q])/3;\n\t\t\tres.push(temp);\n\t\t\tp++;\n\
    \t\t\tq++;\n\t\t}\n\t}\n\treturn res;\n}\n", "\tlet l1: number[] = [];\n\tlet\
    \ l2: number[] = [];\n\tfor (let i = 0; i < l.length; i++) {\n\t\tlet temp1: number\
    \ = l[i];\n\t\tlet temp2: number = l[i];\n\t\tlet temp3: number = l[i];\n\t\t\
    if (l[i] % 3 === 0) {\n\t\t\tlet temp4: number = l[i];\n\t\t\tif (l[i] % 3 ===\
    \ 1) {\n\t\t\t\ttemp4++;\n\t\t\t}\n\t\t\tl2.push(temp4);\n\t\t} else if (l[i]\
    \ % 3 === 1) {\n\t\t\ttemp3++;\n\t\t}\n\t\tl1.push(temp3);\n\t\tl1.push(temp2);\n\
    \t\tl1.push(temp1);\n\t}\n\treturn l1.concat(l2).sort();\n}\n", "  let len = l.length\n\
    \  if (len < 3) return[]\n  let ret = []\n  let count = 0\n  let index = 0\n \
    \ for (let i = 0; i < len; i++) {\n    if (i % 3 === 0 && i != 0) {\n      count++\n\
    \    }\n    if (count === 0) {\n      ret.push(l[index])\n      index++\n    }\n\
    \    if (count === 3) {\n      ret.push(l[index])\n    }\n  }\n  return ret\n\
    }\n", "    let three = [];\n    for (let i = 0; i < l.length; i++) {\n       \
    \ if (l[i] % 3 === 0) {\n            three.push(l[i]);\n        } else {\n   \
    \         while (three != [] && three.indexOf(Math.ceil(three[three.length - 1]\
    \ / 3)) != -1) {\n                let index = three.indexOf(Math.ceil(three[three.length\
    \ - 1] / 3));\n                three.splice(index, 1);\n            }\n      \
    \      if (three != []) {\n                three.push(l[i]);\n            } else\
    \ {\n                three.push(l[i]);\n            }\n        }\n    }\n    return\
    \ three;\n}\n", "  for (let i = 0; i < l.length / 3; i++) {\n    const temp =\
    \ a[l[i * 3 + 1]];\n    a[l[i * 3 + 1]] = a[l[i * 3]];\n    a[l[i * 3]] = temp;\n\
    \  }\n  return l;\n}\n", "    const res = [];\n    for (let i = 0; i < l.length;\
    \ i++) {\n        if (i % 3 === 0 || i === 0) res.push(l[i]);\n        else res.sort((a:\
    \ number, b: number) => a - b);\n    }\n    return res;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThank you for this, but i need the original array unsorted, but\
    \ sorted on every nth index.\n<|/ c |>\n<| c |>\nOh I see, let me edit my answer\n\
    <|/ c |>\n<| c |>\nNo worries, glad to help!\n<|/ c |>\n<| a dscore=0 |>\nHere\
    \ is a solution using Array.reduce, Array.slice, Math.round, Array.sort and Array.map\
    \ -\n\n<code>\nconst sort_third = array => array\n  .reduce(\n    ([third, ...rest],\
    \ i) => {\n      if (i % 3 === 0) {\n        return [...third, array[i]];\n  \
    \    }\n      return [...third, ...rest];\n    },\n    [[], ...Array.from({ length:\
    \ Math.round(array.length / 3) }, (_, i) => i)]\n  )\n  .sort((a, b) => a - b)\n\
    \  .map(i => array[i]);\n\nconsole.log(sort_third([5, 6, 3, 4, 8, 9, 2]));\nconsole.log(sort_third([1,\
    \ 2, 3]));</code>\n\nThe logic is as follows - \n\nUse Array.reduce to split array\
    \ into groups of size 3, each group being an array [array[0], array[1], array[2]]\n\
    Use Array.slice to remove first element from each group of size 3, to get [array[1],\
    \ array[2], array[3]]\nUse Math.round to round length of array to ceiling\nUse\
    \ Array.sort to sort each group of size 3 arrays in ascending order\nUse Array.map\
    \ to return the original array with each group of size 3 arrays sorted\n<|/ a\
    \ tags=javascript,arrays |>\n<| c |>\nPlease explain it a bit.\n<|/ c |>\n<| c\
    \ |>\n, added explanation\n<|/ c |>\n<| a dscore=0 |>\n<code>\nvar arr = [5, 6,\
    \ 3, 4, 8, 9, 2];\nvar sortedArr = sortThirds(arr);\nconsole.log(sortedArr);\n",
  "  let n1 = l[0], n2 = l[1], n3 = l[2], temp;\n  if (n1 === n2) {\n    if (n1 ===\
    \ n3) {\n      l[0] = n3;\n      l[1] = n1;\n    } else {\n      temp = n1;\n\
    \      n1 = n3;\n      n3 = temp;\n    }\n  }\n  while (n3 !== 0) {\n    if (n3\
    \ === n1) {\n      l[2] = n1;\n      l[1] = n3;\n    } else if (n3 === n2) {\n\
    \      l[2] = n2;\n      l[1] = n3;\n    } else if (n3 === n1) {\n      temp =\
    \ n3;\n      n3 = n2;\n      n2 = temp;\n    } else {\n      temp = n3;\n    \
    \  n3 = n2;\n      n2 = temp;\n    }\n  }\n  return l;\n}\n", "    const len:\
    \ number = l.length;\n    if (len < 3) {\n        return l;\n    }\n\n    let\
    \ first: number[] = l;\n    let second: number[] = l;\n    let third: number[]\
    \ = l;\n    for (let i: number = 0; i < len - 1; i++) {\n        third = first;\n\
    \        first = second;\n        second = third;\n\n        if (i % 3 === 0)\
    \ {\n            third.push(first[i]);\n        } else {\n            third.push(second[i]);\n\
    \        }\n    }\n    return third;\n}\n", "  const len = l.length;\n\n  for\
    \ (let i = 0; i < len; i += 1) {\n    let third: number;\n    if (l[i] % 3 ===\
    \ 0) third = l[i];\n    else third = l[i] + (3 - l[i] % 3);\n    let low;\n  \
    \  for (let j = i + 1; j < len; j += 1) {\n      if (l[j] < third) low = j;\n\
    \    }\n    for (let j = i + 1; j < len; j += 1) {\n      if (l[j] === third)\
    \ l[j] = low;\n    }\n  }\n\n  return l;\n}\n", "  let newArray = [];\n  let third\
    \ = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 != 0) {\n   \
    \   newArray.push(l[i]);\n    } else {\n      third = l[i] / 3;\n      for (let\
    \ j = i + 1; j < l.length; j++) {\n        if (l[j] % 3 == 0) {\n          if\
    \ (l[j] < third) {\n            newArray.push(l[j]);\n          }\n        }\n\
    \      }\n    }\n  }\n  return newArray;\n}\n", "\tlet n = l.length;\n\tlet l2\
    \ = [];\n\tlet l3 = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tif (i === 0) {\n\
    \t\t\tl2.push(l[i]);\n\t\t\tl3.push(l[i]);\n\t\t} else if (i % 3 === 0) {\n\t\t\
    \tlet j = (i + 1) % n;\n\t\t\tl2.push(l[i]);\n\t\t\tl2.push(l[j]);\n\t\t\tl3.push(l[i]);\n\
    \t\t\tl3.push(l[j]);\n\t\t} else {\n\t\t\tlet j = (i + 1) % n;\n\t\t\tl2.push(l[i]);\n\
    \t\t\tl2.push(l[j]);\n\t\t\tl3.push(l[i]);\n\t\t\tl3.push(l[j]);\n\t\t}\n\t}\n\
    \treturn l2.concat(l3);\n}\n", "    let result: number[] = [];\n    for (let i\
    \ = 0; i < l.length; i++) {\n        if (i !== l.length % 3 && l[i] !== l[l.length\
    \ - 1 - i]) {\n            result.push(l[i]);\n        }\n    }\n    return result;\n\
    }\n", "    const third = l.splice(l.length / 3, 3)\n    l.splice(0, l.length /\
    \ 3)\n    l.push(...third)\n    return l\n}\n", "    const threes: number[] =\
    \ [];\n    for (let i = 0; i < l.length; i += 3) {\n        if (i % 3 === 0) {\n\
    \            threes.push(l[i]);\n        }\n    }\n\n    for (let i = 1; i < threes.length;\
    \ i++) {\n        let val = threes[i];\n        for (let j = 0; j < threes.length;\
    \ j++) {\n            if (j === i) {\n                continue;\n            }\n\
    \            if (val < threes[j]) {\n                threes[j] = val;\n      \
    \      }\n        }\n    }\n    return threes.sort();\n}\n\nconst sort_third3\
    \ = sort_third;\n", "  if (l.length <= 3) {\n    return l;\n  }\n  var l2 = l.slice(0,\
    \ l.length >>> 1);\n  var l3 = l2.slice(1, l2.length >>> 1);\n  var l4 = l3.slice(1,\
    \ l3.length >>> 1);\n  var l5 = [...l4, ...l3];\n  var l6 = [...l2, ...l5];\n\
    \  var l7 = [...l, ...l6];\n  var l8 = [...l1, ...l7];\n  var l9 = [...l8, ...l9,\
    \ ...l8];\n  return l9;\n}\n", "    let l3 = [...l];\n    for (let j = 0; j <\
    \ l3.length; j++) {\n        for (let i = 0; i < j; i = i + 3) {\n           \
    \ l3[i] = l3[i + 2];\n        }\n    }\n    return l3;\n}\n", "\tfor (let i =\
    \ 0; i < l.length; i++) {\n\t\tfor (let j = 0; j < l.length; j++) {\n\t\t\tif\
    \ (i !== j) {\n\t\t\t\tif (l[j] % 3 === 0) {\n\t\t\t\t\tl[j] = l[j - 2];\n\t\t\
    \t\t} else {\n\t\t\t\t\tl[j] = l[j + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ l;\n}", "  return l.sort((a, b) => {\n    return a % 3 === b % 3 ? a - b : (a\
    \ % 3 !== b % 3 ? b - a : 0);\n  });\n}\n", "    let x: number[] = [];\n    for\
    \ (let i = 0; i < l.length; i++) {\n        if (i === l.length || l[i] % 3 ===\
    \ 0) {\n            x.push(l[i]);\n        } else {\n            let pos = x;\n\
    \            for (let j = 0; j < x.length; j++) {\n                let num = x[j];\n\
    \                if (l[i] <= num) {\n                    pos = pos;\n        \
    \            break;\n                }\n            }\n            x.splice(pos,\
    \ 0, l[i]);\n        }\n    }\n    return x;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I think this one is more elegant and simple.\n<|/ c |>\n<| c |>\nPlease add some\
    \ description to your answer\n<|/ c |>\n<| c |>\nThis is not a general solution.\
    \ For instance sort_third([3, 8, 2, 6, 4, 1]) returns [2, 8, 4, 6, 3, 1]\n<|/\
    \ c |>\n<| c |>\nFixed it\n<|/ c |>\n<| a dscore=4 |>\nOne liner for sorting arrays\
    \ in javascript using Math.max. \n<code>\nconst array = [3, 2, 4, 6, 1, 9, 8];\n\
    \narray.sort((a, b) => Math.max(a, b) - Math.max(b,a));\n</code>\n<|/ a tags=algorithm,sorting,javascript,arrays\
    \ |>\n<| c |>\nThis is nice and simple. Thank you!\n<|/ c |>\n<| c |>\n`Math.max`\
    \ returns the maximum value of its arguments. So in your example, `Math.max(2,3)`\
    \ is `3`. `Math.max(b,a)` is therefore `3` - `3` is `1`, so the sorting is correct.\n\
    <|/ c |>\n<| c |>\nThanks for pointing this out, I just wanted to avoid an extra\
    \ if statement.\n<|/ c |>\n<| c |>\nThis is nice and simple, but be aware this\
    \ does not sort by 'second' but by 'maximum second'\n<|/ c |>\n<| c |>\nI didn't\
    \ see your last comment until after I posted my comment. Sorry.\n<|/ c |>\n<|\
    \ a tags=algorithm,sorting,javascript,arrays dscore=3 |>\nYou can use sort() method\
    \ with custom compareFunction.\n\nThe sort() method sorts the elements of an array\
    \ in place and returns\n  the array. The default sort order is ascending, built\
    \ upon converting the elements into strings, then comparing their sequences of\
    \ UTF-16 code units value. If compareFunction is not supplied, elements are sorted\
    \ in ascending order using their natural order on the first two arguments.\n\n\
    <code>\nvar array = [5, 2, 1, 4, 3];\narray.sort((a, b) => a - ", "  if (l.length\
    \ < 3) {\n    return l;\n  }\n  let third = l[2];\n  let third_2 = third;\n  let\
    \ index = 0;\n  while (index < l.length - 1) {\n    if (l[index] % 3 === 0) {\n\
    \      l[index] = third;\n      l[index + 1] = third_2;\n      third = third_2;\n\
    \      third_2 = l[index + 1];\n      index += 1;\n    } else {\n      index +=\
    \ 1;\n    }\n  }\n  return l;\n}\n", "    l.sort(function(a, b) {\n        return\
    \ a % 3 === b % 3 ? a - b : a - b + 12;\n    });\n    return l;\n}\n</code>\n\
    <|/ a |>\n<| a tags=sorting,javascript,arrays,algorithm,typescript |>\nYou could\
    \ use the sort function with callback for sorting and return a negative value\
    \ if the difference between two elements is greater than 12 else return a positive\
    \ value.\n\n<code>\nvar array = [1, 3, 8, 0, 7, 9, 12, 4, 2];\n\narray.sort(function\
    \ (a, b) {\n    return a > b ? (a - b) : (a - b + 12);\n});\n\nconsole.log(array);</code>\n\
    <|/ a dscore=3 |>\n<| a |>\nYou can use the Array.prototype.sort() method for\
    \ that:\n\n<code>\nvar array = [1, 3, 8, 0, 7, 9, 12, 4, 2];\n\narray = array.sort((a,\
    \ b) =>\n  Math.abs(a - b) < 12 ? a > b ? 1 : -1 : 0);\n\nconsole.log(array);</code>\n\
    <|/ a tags=sorting,javascript,arrays,algorithm,typescript dscore=3 |>\n<| a tags=sorting,javascript,arrays,algorithm,typescript\
    \ dscore=2 |>\nThe only way I can think to do this is to sort your array by comparing\
    \ each number to the next:\n<code>", "  const l2 = [];\n  for (let i = 0; i <\
    \ l.length; i++) {\n    l2.push(l[i]);\n    if (l[i] % 3 != 0) {\n      let j\
    \ = 0;\n      for (let k = i; k < l.length; k++) {\n        if (l[k] % 3 == 0)\
    \ {\n          l2.push(l[j]);\n          j++;\n        }\n      }\n    }\n  }\n\
    \  return l2;\n}\n", "    const newArr = [];\n    const sortArr = [];\n    let\
    \ j = 0;\n    for (let i = 0; i < l.length; i++) {\n        if (l[i] % 3 === 0)\
    \ {\n            newArr.push(l[i]);\n        } else {\n            if (j === 0)\
    \ {\n                j++;\n                newArr.push(l[i]);\n            }\n\
    \            sortArr.push(l[i]);\n        }\n    }\n    return newArr.concat(sortArr);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=javascript,sorting,arrays |>\nThe other\
    \ solutions are great, but I thought I'd contribute an answer that uses sort and\
    \ slice:\n<code>\nconst sortedArr = yourArr.sort((a, b) => b - a).slice(0,3);\n\
    </code>\nThis sorts the array by the values in the array and slices the first\
    \ 3 entries.  \nAs a bonus, it also makes it really easy to change that slice\
    \ if your sorting key changes!\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  l.sort((a,\
    \ b) => a - b); // Sort the numbers first\n  let i: number = 0;\n  const len =\
    \ l.length;\n  for (; i < len; i++) {\n    if (l[i] % 3 !== 0) break;\n  }\n \
    \ const res: number[] = new Array(len);\n  for (; i < len; i++) {\n    if (l[i]\
    \ % 3 === 0) res[i] = l[i];\n  }\n  return res;\n}\n", "    var a: number[];\n\
    \    var i: number;\n    var k: number;\n    var len: number;\n    var max: number;\n\
    \    var j: number;\n    var new_arr: number[];\n    var temp: number;\n\n   \
    \ // Make new array a by comparing indicies with divisible by 3\n    a = l.slice();\n\
    \    len = a.length;\n    for (j = 0; j < len; j++) {\n        max = Number.MIN_VALUE;\n\
    \        for (i = 0; i < len - 1; i++) {\n            if (a[j] > max && a[i] %\
    \ 3 === 0) {\n                max = a[i];\n            }\n        }\n        if\
    \ (max === Number.MIN_VALUE) {\n            new_arr = l.slice();\n           \
    \ new_arr[j] = a[j];\n            k = j;\n            while (new_arr[k] % 3 ===\
    \ 0) {\n                new_arr[k] = new_arr[k] - 3;\n                k++;\n \
    \           }\n            a[new_arr.length] = a[k];\n            a[k] = 0;\n\
    \        }\n    }\n\n    // Return new array\n    return a;\n}\n</code>\nIt does\
    \ exactly what it says on the tin.\n<|/ a dscore=0 |>\n<| c |>\nThe output was\
    \ correct for the test case, however, I used my own implementation to test a larger\
    \ set of data and noticed that it did not produce the correct output. The reason\
    \ for that is that I was using a while loop to solve my problem, which was causing\
    \ it to not work for some cases. I decided to use your sorting method instead,\
    \ which is much more efficient, and works. Thanks for the help.\n<|/ c |>\n<|\
    \ a tags=javascript,sorting |>\nI wrote this program and got an answer with 4\
    \ test cases and 4 correct answers.\n<code>\n function swap(a, b) {\n    var temp\
    \ = a;\n    a = b;\n    b = temp;\n    return temp;\n}", "  const newArr = l.slice();\n\
    \  let evens: number;\n  let odds: number;\n  let threes: number[] = [];\n  for\
    \ (let i = 0; i < newArr.length; i++) {\n    threes.push(newArr[i]);\n    if (i\
    \ % 2 === 0) {\n      evens = newArr[i];\n    } else {\n      odds = newArr[i];\n\
    \    }\n  }\n  while (threes.length < 3) {\n    threes.push(Math.round((evens\
    \ + odds) / 2));\n  }\n  let i = 0;\n  while (i < threes.length && threes[i] <\
    \ newArr.length) {\n    newArr[threes[i]] = newArr[newArr.length - 1];\n    newArr.pop();\n\
    \    i++;\n  }\n  return newArr;\n}", "  l.sort((a: number, b: number) => a -\
    \ b)\n  l.forEach((val, index) => {\n    if (index % 3 === 0) {\n      l[index]\
    \ = index\n    }\n  })\n  return l\n}\n", "    const l3 = [];\n    let j = 0;\n\
    \    for (let i = 0; i < l.length; i++) {\n        if (l[i] % 3 != 0) {\n    \
    \        l3[j] = l[i];\n            j++;\n        } else {\n            const\
    \ a = l[i];\n            const b = l[i];\n            l3[j] = a;\n           \
    \ l3[j + 1] = b;\n            j++;\n            j++;\n        }\n    }\n    return\
    \ l3;\n}\n", "    let l1 = l.slice();\n    let l2 = l1.slice();\n    let l3 =\
    \ l1.slice();\n    let l = l1.slice();\n    let len = l1.length;\n\n    let counter\
    \ = 0;\n    let i = 0;\n    let j = 0;\n    let k;\n\n    while (i < len && j\
    \ < len) {\n        if (l3[i] % 3 !== 0) {\n            counter++;\n         \
    \   k = 0;\n        }\n\n        if (l3[j] % 3 !== 0) {\n            k++;\n  \
    \      }\n\n        if (k !== 0 && k !== counter && i !== j) {\n            l[i]\
    \ = l[j];\n            l2[i] = l2[j];\n            l3[i] = l3[j];\n          \
    \  l3[j] = l[i];\n            l2[j] = l2[i];\n            l2[i] = l3[i];\n   \
    \         l3[i] = l3[j];\n            l[j] = l[i];\n            l1[i] = l3[i];\n\
    \            l1[j] = l3[j];\n            l1[i] = l1[i];\n            l1[j] = l1[j];\n\
    \            l1[i] = l[j];\n            counter++;\n            i--;\n       \
    \     j--;\n        }\n\n        i++;\n        j++;\n    }\n\n    return l1;\n\
    }\n", "  for (let i = 3; i < l.length; i++) {\n    let pivot = Math.floor((l.length\
    \ - 1) / 3);\n    let a = l[i];\n    let b = l[pivot];\n    let c = l[pivot +\
    \ 1];\n    let d = l[pivot - 1];\n    if (a == b && a == c && b == d) {\n    \
    \  continue;\n    }\n    if (a != b && a != c && b != d && c != d) {\n      if\
    \ (a < b) l[i] = a;\n      if (b < c) l[pivot] = b;\n      if (c < d) l[pivot\
    \ + 1] = c\n    } else {\n      if (a < c) l[i] = a;\n      if (b < d) l[pivot]\
    \ = b;\n      if (c < d) l[pivot + 1] = c\n    }\n  }\n  return l;\n}\n", "  const\
    \ len = l.length;\n  for (let i = 0, c = 0; i < len; c < 3 && i < len; i++) {\n\
    \    if (l[i] % 3 === 0 && c === 0) {\n      l[i] = l[i + 1];\n      i++;\n  \
    \    c++;\n    } else if (l[i] % 3 === 0 && c === 1) {\n      l[i] = l[i + 2];\n\
    \      i++;\n      c++;\n    } else if (l[i] % 3 === 1 && c === 0) {\n      l[i]\
    \ = l[i + 1];\n      i++;\n      c++;\n    } else if (l[i] % 3 === 1 && c ===\
    \ 2) {\n      l[i] = l[i + 2];\n      i++;\n      c++;\n    }\n  }\n  return l;\n\
    }\n", "\tl.sort((a, b) => a % 3 === b % 3 ? a - b : a - b + 3);\n\treturn l;\n\
    }\n", "  // Write your code here\n  \n  var l1 = l.slice(0);\n  \n  l1.sort((a,b)\
    \ => {\n    return (a%3) - (b%3);\n  });\n  return l1;\n}", "    // l is sorted\
    \ in descending order, from largest to smallest\n    l.sort(\n        (a, b) =>\
    \ (a < b) ? 1 : ((a > b) ? -1 : 0)\n    );\n\n    // l is now sorted in ascending\
    \ order, from smallest to largest\n    // Now we take each value of l and divide\
    \ it by three.\n    const n = l.length;\n    let c = 0;\n    const d = n / 3;\n\
    \    const f = Array.from(\n        { length: n },\n        (v, i) => i / 3\n\
    \    );\n\n    while (c < d) {\n        const i = f[c];\n\n        l[i] = l[i]\
    \ / 3;\n        c++;\n    }\n    return l;\n}\n", "  let l_index = 0;\n  let l_val\
    \ = 0;\n  let l_temp = l[0];\n  let l_arr: number[] = [];\n\n  while (l_index\
    \ < l.length) {\n    if (l_temp % 3 !== 0) {\n      l_arr.push(l_temp);\n    }\n\
    \    l_temp += 1;\n    l_index += 1;\n  }\n\n  if (l_temp % 3 !== 0) {\n    l_arr.push(l_temp);\n\
    \  }\n  return l_arr;\n}\n", "\tlet n = 3;\n\twhile (n > 0) {\n\t\tlet m = 0;\n\
    \t\tfor (let i = 0; i < l.length; i++) {\n\t\t\tif (i + n % 3 === m) {\n\t\t\t\
    \tl[i] = l[i + n];\n\t\t\t\tl[i + n] = l[i];\n\t\t\t}\n\t\t\tm++;\n\t\t}\n\t\t\
    n--;\n\t}\n\treturn l;\n}\n", "    let third = [];\n    for (let i = 0; i < l.length;\
    \ i++) {\n        if (l[i] % 3 == 0) {\n            third.push(l[i]);\n      \
    \  }\n    }\n    let sortedThird = [];\n    for (let i = 0; i < third.length;\
    \ i++) {\n        for (let j = i + 1; j < third.length; j++) {\n            if\
    \ (third[i] > third[j]) {\n                let temp = third[i];\n            \
    \    third[i] = third[j];\n                third[j] = temp;\n            }\n \
    \       }\n        sortedThird.push(third[i]);\n    }\n    return sortedThird;\n\
    }\n", "    let i: number = 0, j: number = 0, k: number = 0, temp: number = 0;\n\
    \    while(i < l.length) {\n        temp = (l[k] + l[j] + l[i]) / 3;\n       \
    \ if (temp > l[k]) {\n            l[k] = temp;\n            k++;\n        } else\
    \ if (temp > l[j]) {\n            l[j] = temp;\n            j++;\n        } else\
    \ {\n            l[i] = temp;\n            i++;\n        }\n    }\n    return\
    \ l;\n}\n", "    let newL: number[] = [];\n    let j: number = 0;\n    let last:\
    \ number = l.length;\n\n    while (j < last) {\n        if (l[j] % 3 === 0) {\n\
    \            let temp: number = l[j];\n            let temp2: number;\n      \
    \      let temp3: number;\n\n            for (let k = j + 1; k < last; k++) {\n\
    \                temp2 = l[k];\n\n                if (temp % 3 === 0 && temp2\
    \ % 3 === 0) {\n                    temp3 = l[k];\n                    l[k] =\
    \ temp3;\n                    l[k + 1] = temp;\n                    break;\n \
    \               } else {\n                    if (temp % 3 !== 0) {\n        \
    \                l[k] = temp2;\n                        l[k + 1] = temp;\n   \
    \                     break;\n                    }\n                }\n     \
    \       }\n        } else if (l[j] % 3 !== 0) {\n            newL.push(l[j]);\n\
    \            j++;\n        } else {\n            newL.push(l[j]);\n          \
    \  j++;\n        }\n    }\n\n    return newL;\n}\n", "  const map = new Map<number,\
    \ number>();\n  for (let i = 0; i < l.length; i++) {\n    const curr = l[i];\n\
    \    if (curr % 3 === 0) map.set(curr, 1);\n    else map.set(curr, map.get(curr)\
    \ + 1);\n  }\n  const arr = [...map.values()];\n  arr.sort((a, b) => b - a);\n\
    \  return arr;\n}\n", "\tlet new_l: number[] = [];\n\tlet len: number = l.length;\n\
    \tlet temp: number = 0;\n\tlet index: number = -1;\n\twhile (len--) {\n\t\tindex++;\n\
    \t\tif (index % 3 === 0) {\n\t\t\tcontinue;\n\t\t}\n\t\twhile (index < len &&\
    \ l[index] > temp) {\n\t\t\tnew_l[temp] = l[index];\n\t\t\ttemp++;\n\t\t\tindex++;\n\
    \t\t}\n\t\tnew_l[temp] = l[index];\n\t\ttemp++;\n\t}\n\treturn new_l;\n}\n", " \
    \   for (let i = 0; i < l.length; i++) {\n        const l2 = l.slice();\n    \
    \    l2.sort(function (a, b) { return a - b; });\n        for (let j = 0; j <\
    \ l2.length; j++) {\n            if (j % 3 === 0) {\n                l[j] = l2[j];\n\
    \            }\n        }\n    }\n    return l;\n}\n", "\tfor (let i = 0; i <\
    \ l.length / 3; i++) {\n\t\tlet j = i;\n\t\tlet t = l[j];\n\t\twhile (j > 0 &&\
    \ l[j - 3] % 3 != 0) {\n\t\t\tj--;\n\t\t}\n\t\tif (j > 0) {\n\t\t\tl[j] = l[j\
    \ - 1];\n\t\t}\n\t\tfor (; j > 0 && l[j - 3] % 3 == 0; j--) {\n\t\t\tl[j] = l[j\
    \ - 1];\n\t\t}\n\t\tl[j] = t;\n\t}\n\treturn l;\n}\n", "\tlet l1 = l.slice(0)\n\
    \tlet l2 = l1.slice(0)\n\tlet i = l1.length\n\tlet j = 0\n\twhile(j+1 < l2.length\
    \ && l2[j] == l2[++j]) {\n\t\tl1.splice(i, 1)\n\t\t++i\n\t}\n\twhile(j+1 < l2.length\
    \ && l2[j] == l2[--j]) {\n\t\tl2.splice(j+1, 1)\n\t\t++j\n\t}\n\twhile(i < l1.length)\
    \ {\n\t\twhile (j < l2.length && l1[l1.length-1-j] == l2[l2.length-1-j]) {\n\t\
    \t\tl1.splice(l1.length-1-j, 1)\n\t\t\t++j\n\t\t}\n\t\twhile (j < l2.length &&\
    \ l1[l1.length-1-j] == l2[l2.length-1-j]) {\n\t\t\tl2.splice(j+1, 1)\n\t\t\t++j\n\
    \t\t}\n\t\t++i\n\t\t++j\n\t}\n\treturn l1.concat(l2)\n}\n", "    l.sort((a, b)\
    \ => b - a);\n    for (let i = 0; i < l.length; i += 3) {\n        const index\
    \ = i;\n        while (index > 0 && l[index - 1] > l[index]) {\n            l[index\
    \ - 1] = l[index];\n            index--;\n        }\n        l[index] = l[i];\n\
    \    }\n    return l;\n}\n", "\tvar l3 = [];\n\tfor (var i = 0; i < l.length;\
    \ i++) {\n\t\tvar num = l[i];\n\t\tvar index = i;\n\t\tif (i % 3 === 0) {\n\t\t\
    \tif (num > l3[i - 1].num) {\n\t\t\t\tl3[index] = { num: num, index: i };\n\t\t\
    \t}\n\t\t}\n\t\telse {\n\t\t\tif (num > l3[i - 1].num) {\n\t\t\t\tindex = l3[i\
    \ - 1].index;\n\t\t\t}\n\t\t}\n\t}\n\tfor (var i = 0; i < l.length; i++) {\n\t\
    \tvar num = l[i];\n\t\tvar index = i;\n\t\tif (i % 3 === 0) {\n\t\t\tif (num >\
    \ l3[i - 1].num) {\n\t\t\t\tl3[index] = { num: num, index: i };\n\t\t\t}\n\t\t\
    }\n\t}\n\tvar result = [];\n\tfor (var i = 0; i < l3.length; i++) {\n\t\tif (i\
    \ % 3 !== 0) {\n\t\t\tresult.push(l3[i].num);\n\t\t}\n\t}\n\treturn result;\n\
    }\n", "    const n = l.length;\n    if (n === 0) {\n        return [];\n    }\n\
    \    if (n === 1) {\n        return l;\n    }\n    let m = n / 2;\n    if (n %\
    \ 2 === 0) {\n        m--;\n    }\n    const l1 = l[0];\n    const l2 = l[1];\n\
    \    let third = l1.concat([]);\n    for (let i = 2; i <= m; ++i) {\n        const\
    \ l3 = l[i];\n        let found = false;\n        for (let j = 0; j < third.length;\
    \ ++j) {\n            const l4 = third[j];\n            if (l4.value <= l3.value)\
    \ {\n                found = true;\n            }\n        }\n        if (!found)\
    \ {\n            third.push(l3);\n        }\n    }\n    let thirdPart = third.concat([]);\n\
    \    let thirdPartCopy = [];\n    for (let i = 0; i < third.length; ++i) {\n \
    \       const l5 = third[i];\n        let found = false;\n        for (let j =\
    \ 0; j < thirdPartCopy.length; ++j) {\n            const l6 = thirdPartCopy[j];\n\
    \            if (l6.value === l5.value) {\n                found = true;\n   \
    \         }\n        }\n        if (!found) {\n            thirdPartCopy.push(l5);\n\
    \        }\n    }\n    thirdPartCopy = thirdPartCopy.concat(third);\n    const\
    \ result = [];\n    let i = 0;\n    for (let j = 0; j < thirdPartCopy.length;\
    \ ++j) {\n        const l7 = thirdPartCopy[j];\n        const l8 = thirdPartCopy[i];\n\
    \        const l9 = thirdPartCopy[i + 1];\n        if (l8.value >= l7.value &&\
    \ l8.value < l9.value) {\n            result.push(l8);\n            i += 2;\n\
    \        }\n        else {\n            result.push(l7);\n        }\n    }\n \
    \   result = result.concat(thirdPartCopy.slice(0, thirdPartCopy.length / 2));\n\
    \    for (let j = thirdPartCopy.length / 2; j < n; ++j) {\n        result.push(l[j]);\n\
    \    }\n    return result;\n}\n", "    let a = [];\n    let b = [];\n    let c\
    \ = [];\n    let d = [];\n    let e = [];\n    let f = [];\n    let g = [];\n\
    \    let h = [];\n\n    for (let i = 0; i < l.length; i++) {\n        if (i %\
    \ 3 === 0) {\n            a.push(l[i]);\n        }\n        if (i % 3 === 1) {\n\
    \            b.push(l[i]);\n        }\n        if (i % 3 === 2) {\n          \
    \  c.push(l[i]);\n        }\n    }\n\n    a.sort();\n    b.sort();\n    c.sort();\n\
    \n    for (let i = 0; i < l.length; i++) {\n        if (i % 3 === 0) {\n     \
    \       d.push(a[i]);\n        }\n        if (i % 3 === 1) {\n            e.push(b[i]);\n\
    \        }\n        if (i % 3 === 2) {\n            f.push(c[i]);\n        }\n\
    \    }\n\n    d.sort();\n    e.sort();\n    f.sort();\n\n    for (let i = 0; i\
    \ < l.length; i++) {\n        if (i % 3 === 0) {\n            g.push(e[i]);\n\
    \        }\n        if (i % 3 === 1) {\n            h.push(f[i]);\n        }\n\
    \        if (i % 3 === 2) {\n            h.push(a[i]);\n        }\n    }\n\n \
    \   g.sort();\n    h.sort();\n\n    for (let i = 0; i < l.length; i++) {\n   \
    \     if (i % 3 === 0) {\n            b.push(a[i]);\n        }\n        if (i\
    \ % 3 === 1) {\n            a.push(h[i]);\n        }\n        if (i % 3 === 2)\
    \ {\n            a.push(b[i]);\n        }\n    }\n\n    return b;\n}\n", "   \
    \ let l2 = l.slice().sort((a, b) => a % 3 === b % 3 ? a - b : a % 3 ? -1 : b %\
    \ 3 ? 1 : 0);\n    let l3 = [];\n    for (let i = 0; i < l2.length; i++) {\n \
    \       for (let j = 0; j < l.length; j++) {\n            if (l2[i] !== l[j])\
    \ {\n                l3.push(l2[i]);\n                break;\n            }\n\
    \        }\n    }\n    return l3;\n}\n", "    l.sort((a, b) => a % 3 === b % 3\
    \ ? a - b : a % 3 ? 1 : -1)\n    return l\n}\n", "\tlet third = [];\n\tfor (let\
    \ i = 0; i < l.length; i++) {\n\t\tlet thirdIndex = Math.floor(i/3);\n\t\tif (third[thirdIndex]\
    \ === undefined && l[i] % 3 === 0) {\n\t\t\tthird[thirdIndex] = l[i];\n\t\t}\n\
    \t}\n\treturn third;\n}\n", "    let l1 = []\n    let l2 = []\n    let l3 = []\n\
    \    for (let i = 0; i < l.length; ++i) {\n        if ((l[i] % 3) !== 0) {\n \
    \           l1.push(l[i])\n        } else if ((l[i] % 3) === 0) {\n          \
    \  l2.push(l[i])\n        } else {\n            l3.push(l[i])\n        }\n   \
    \ }\n    return [...sort_second(l1), ...sort_second(l2), ...sort_second(l3)]\n\
    }\n", "    var a = l;\n    var b = [];\n    for (var i = l.length - 1; i > 0;\
    \ i--) {\n        var index = Math.floor((i + 1) % 3);\n        b.push(a[index]);\n\
    \        a.splice(index, 1);\n    }\n    b.push(a[0]);\n    a.splice(0, 1);\n\
    \    return b;\n}\n", "  if (l.length < 3) return l;\n  var l3: number[] = [];\n\
    \  l3.push(l[0]);\n  l3.push(l[1]);\n  l3.push(l[2]);\n  return l3;\n}\n", " \
    \   const n = l.length;\n    const a = new Array(n);\n    for (let i = 0; i <\
    \ n; i++) {\n        const v = l[i];\n        const k = i;\n        while (k %\
    \ 3 === 0 && v < l[k + 1]) {\n            a[k + 1] = l[k + 1];\n            k\
    \ = k + 1;\n        }\n        a[k + 1] = v;\n    }\n    return a;\n}\n", "  \
    \  // If array l is sorted, return it.\n    if (l.sort) {\n        return l;\n\
    \    }\n\n    // If array l is not sorted, find the indicies of the first three\
    \ elements that are divisible by three.\n    const inds0 = l.slice(0, l.length\
    \ / 3);\n    const inds1 = inds0.slice();\n    let inds1_length = 0;\n    let\
    \ inds1_value = 0;\n\n    // Sort each of these indicies in increasing order.\n\
    \    for (let i = 1; i < inds0.length; i++) {\n        if (inds0[i] % 3 === 0)\
    \ {\n            // The first indice is divisible by three.\n            inds1_values[inds1_length]\
    \ = inds0[i];\n            inds1_length++;\n        } else {\n            // The\
    \ first indice is NOT divisible by three.\n            // Find the next indice\
    \ that is divisible by three.\n            for (let j = 0; j < inds1.length; j++)\
    \ {\n                if (inds0[i] === inds1[j]) {\n                    break;\n\
    \                }\n            }\n            inds1_values[inds1_length] = inds0[i];\n\
    \            inds1_length++;\n\n            // If the next indice found is NOT\
    \ divisible by three, swap the two indicies.\n            // This is to keep inds1\
    \ from getting too large too quickly.\n            if (j < inds1.length) {\n \
    \               inds1_value = inds1[j];\n                inds1[j] = inds0[i];\n\
    \                inds0[i] = inds1_value;\n            }\n        }\n    }\n\n\
    \    // At this point inds1 and inds0 are sorted in increasing order.\n    //\
    \ Reverse inds1 so that it is in increasing order again.\n    inds1.reverse();\n\
    \    // Combine inds0 and inds1 into one array and return.\n    return inds0.concat(inds1);\n\
    }\n", "  const n = l.length\n  const l3 = new Array(n).fill(0)\n  l3.fill(0)\n\
    \  for (let i = 0, j = 0; i < n; ++i) {\n    if (i % 3 === 0) {\n      ++l3[i]\n\
    \    } else {\n      l3[j++] += l[i]\n    }\n  }\n  return l3.slice(0, j)\n}\n",
  "    if (l.length < 3) {\n        return l;\n    }\n\n    var l2: number[] = [];\n\
    \    var i2: number = l.length - 1;\n    var j2: number = l2.length - 1;\n   \
    \ var k2: number = l2.length - 1;\n\n    do {\n        i2 = j2;\n        j2 =\
    \ k2;\n        k2 = l.length;\n\n        while (i2 < k2) {\n            if (l2[i2]\
    \ < l[i2]) {\n                l[j2] = l2[i2];\n                i2 = j2;\n    \
    \        } else {\n                k2 = k2;\n            }\n        }\n\n    \
    \    if (l[j2] < l[i2]) {\n            l[k2] = l[j2];\n            j2 = k2;\n\
    \        } else {\n            j2 = j2;\n        }\n    } while (j2 < k2);\n\n\
    \    return l;\n}\n", "  l.sort((a, b) => b - a);\n  let res: number[] = [];\n\
    \  for (let i = 0; i < l.length; i++) {\n    if (i === 0 || l[i] % 3 !== 0 ||\
    \ res[res.length - 1] !== l[i]) {\n      res.push(l[i]);\n    }\n  }\n  return\
    \ res;\n}\n", "    var sorted = [...l];\n    sorted.sort((a, b) => a - b);\n \
    \   var newArr = [...sorted];\n    return newArr;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nGood point, but this won't actually work. Arrays don't have a \"length\"\
    \ property. Also, your code is O(n^2) because you sort every value twice. Once\
    \ with `sort` and once with `.forEach`\n<|/ c |>\n<| c |>\nYes, sorry, I did not\
    \ see his comment. I'll edit it now to remove the part about length. `sort` on\
    \ a sorted array will do nothing to the original array as it is already sorted.\
    \ `forEach` on an unsorted array will not do anything, but also not sort, because\
    \ `.forEach` does not return anything.\n<|/ c |>\n<| c |>\nGood point, and you\
    \ are also right about the sort. However, as I pointed out in my answer, my method\
    \ does not need to do any sorting at all. Since it's O(n), it takes O(n) time.\
    \ `sort` sorts anyways right? It doesn't do anything to the original array itself.\n\
    <|/ c |>\n<| c |>\nYes, your method does sort the array. `sort` sorts the entire\
    \ array. Your method is O(n^2) because it sorts every value twice\n<|/ c |>\n\
    <| c |>\nYes, `sort` sorts the entire array, but OP does not need to do that.\
    \ He just needs to sort every value once. This is what my method is doing.\n<|/\
    \ c |>\n<| a tags=arrays,javascript,sorting dscore=3 |>\nThis is probably the\
    \ simplest way:\n<code>\nconst swap = (arr, i, j) => {\n  [arr[i], arr[j]] = [arr[j],\
    \ arr[i]];\n};\n", "  const l2 = []\n  for (let i = 0; i < l.length; i++) {\n\
    \    if (i % 3 === 0) {\n      l2.push(l[i])\n    } else {\n      l2[l2.length\
    \ - 1] = l2[l2.length - 1] + l[i]\n    }\n  }\n  return l2\n}\n", "    const l1\
    \ = [];\n    for (let j = 0; j < l.length; j += 3) {\n        l1.push(l[j]);\n\
    \    }\n    const l2 = [];\n    for (let j = 3; j < l.length; j += 3) {\n    \
    \    l2.push(l[j]);\n    }\n    const l3 = [];\n    for (let j = 0; j < l.length;\
    \ j += 3) {\n        l3.push(l[j]);\n    }\n    return l3.concat(l2).concat(l1);\n\
    }", "    let m = 0;\n    let n = l.length;\n    let a = 0;\n    let b = 0;\n \
    \   let c = l.length;\n    let d = l.length;\n    let e = 0;\n\n    for (let i\
    \ = 0; i < c; i++) {\n        if (l[i] % 3 === 0) {\n            l[e++] = l[m++];\n\
    \        } else if (l[i] % 3 === 1) {\n            l[e++] = l[n++];\n        }\
    \ else if (l[i] % 3 === 2) {\n            l[e++] = l[b++];\n        }\n    }\n\
    \    for (let i = 0; i < d; i++) {\n        if (l[i] % 3 === 0) {\n          \
    \  l[e++] = l[m++];\n        } else if (l[i] % 3 === 1) {\n            l[e++]\
    \ = l[n++];\n        } else if (l[i] % 3 === 2) {\n            l[e++] = l[b++];\n\
    \        }\n    }\n    for (let i = 0; i < e; i++) {\n        l[i] = l[m++];\n\
    \    }\n    return l;\n}\n</code>\nThe above code is a bit long, but I tried to\
    \ keep it simple. There was no real need to sort the array after each step, and\
    \ I left a comment that made it clear that I did need to. Just sort the array\
    \ before the first step, and then after each step, and then after each step.\n\
    The above code was inspired by Joseph Marikle's answer to a similar question.\n\
    <|/ a |>\n<| c |>\nThis is an interesting approach - I did some testing and it\
    \ seems to work well. It is a lot slower than the others however and I wonder\
    \ if the problem is the sorting algorithms or the loops. Can you try with a list\
    \ with 10,000 numbers and see what the performance is?\n<|/ c |>\n<| c |>\nYeah,\
    \ I did try with a list of 100,000 random numbers, and it ran about twice as fast\
    \ as all the others I tried, so I think this might be the best I can do. Thanks\
    \ for taking the time to answer this question :)\n<|/ c |>\n<| a tags=arrays,sorting,algorithm,javascript\
    \ |>\nThe answer provided by will work well, but if you are looking for a better\
    \ algorithm, you could try this one:\n<code>", "    return l.sort((a: number,\
    \ b: number) => a - b).sort((a: number, b: number) => {\n        return ((a %\
    \ 3) > 0 ? (a % 3) > 1 ? (a % 3) > 2 ? (a % 3) : 3) : (a) % 3) > 2 ? (a % 3) :\
    \ 3\n    }).sort((a: number, b: number) => {\n        return ((a % 3) > 0 ? (a\
    \ % 3) > 1 ? (a % 3) > 2 ? (a % 3) : 3) : (a) % 3) > 2 ? (a % 3) : 3\n    }).sort((a:\
    \ number, b: number) => a - b);\n}", "    let index = 0;\n    let newL: number[]\
    \ = [];\n    let j = 0;\n    let flag = 0;\n    let i = 0;\n\n    while (index\
    \ < l.length) {\n        if (index % 3 === 0) {\n            newL[i] = l[index];\n\
    \            flag = 1;\n        }\n\n        index += 1;\n        i += 1;\n  \
    \  }\n\n    for (i = 1; i < l.length; i++) {\n        if (flag === 0) {\n    \
    \        newL[i] = l[i];\n        } else {\n            newL[i] = newL[j];\n \
    \           j += 1;\n        }\n    }\n\n    return newL;\n}\n", "    const l\
    \ = l.slice()\n    const l2 = l.slice()\n    const l3 = l.slice()\n    l.sort(function\
    \ (a: number, b: number) {\n        return a - b\n    })\n    l.sort()\n    for\
    \ (let i = 1; i < l.length; i++) {\n        if (l[i] % 3 === 0) {\n          \
    \  l2[i] = l2[i - 1]\n        } else {\n            l3[i] = l3[i - 1]\n      \
    \  }\n    }\n    return l2.concat(l, l3)\n}\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is very elegant and clean. I wish I had thought of it before I started this\
    \ problem.\n<|/ c |>\n<| a dscore=1 tags=arrays,merge,javascript |>\nYou can do\
    \ it like this:\n\n<code>", "\tlet third = [];\n\tlet n = l.length;\n\tlet k =\
    \ n/3;\n\tfor (let i = 0; i < n; i++) {\n\t\tlet j;\n\t\tfor (j = i; j < n - k\
    \ + i; j++) {\n\t\t\tif (l[j] % 3 === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    \tthird.push(l[i]);\n\t\tthird.push(l[j]);\n\t}\n\treturn third;\n}\n", "    const\
    \ result = [...l];\n    for (let i = 1; i < l.length; i++) {\n        const index\
    \ = result.indexOf(Math.max(...result));\n        const value = result[index];\n\
    \        result.splice(index, 1);\n        result.push(value);\n    }\n    return\
    \ result;\n}\n</code>\nNow let's try to run your sorting algorithms on these two\
    \ examples:\n<code>\nsort_third([10, 8, 5, 9, 7, 4, 6, 3])", "    l.sort((a, b)\
    \ => a % 3 === b % 3 ? a - b : 0);\n    return l;\n}\n", "    l.sort(function(a:\
    \ number, b: number): number {\n        return a % 3 === b % 3 ? a < b ? -1 :\
    \ 1 : a < b ? 1 : 0;\n    });\n    return l;\n}\n", "\tconst sorted = l.slice();\n\
    \tfor (let i = 0; i < sorted.length; i++) {\n\t\tif (sorted[i] % 3 === 0) {\n\t\
    \t\tsorted.splice(i, 0, sorted[i]);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn sorted;\n\
    }\n", "    const third = [];\n    let thirdIndex = 0;\n    let index = 0;\n  \
    \  for (let i = 0; i < l.length; i++) {\n        if (i % 3 === 0) {\n        \
    \    third[thirdIndex] = l[i];\n            thirdIndex++;\n        } else {\n\
    \            while (thirdIndex > index && third[thirdIndex - 1] > l[index]) {\n\
    \                third[thirdIndex - 1] = third[thirdIndex];\n                thirdIndex--;\n\
    \            }\n            third[thirdIndex] = l[index];\n            index++;\n\
    \        }\n    }\n    return third;\n}\n", "    const map = new Map<number, number>();\n\
    \    for (let i = 0; i < l.length; i += 3) {\n        const key = (l[i] as number)\
    \ * 3\n            + (l[i + 1] as number);\n        if (!map.has(key)) {\n   \
    \         map.set(key, l[i]);\n        }\n    }\n\n    const result = [];\n  \
    \  map.forEach((value, key) => {\n        const copy = [value];\n        map.delete(key);\n\
    \        map.forEach((value, key) => {\n            copy.push(value);\n      \
    \  });\n        result.push(copy);\n    });\n    map.forEach((value, key) => {\n\
    \        result.push([value]);\n    });\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nThank you for the detailed answer. The problem with this\
    \ approach is that the array is not always sorted, and in some cases it also contains\
    \ values that are not divisible by three. Also the map should be created only\
    \ once.\n<|/ c |>\n<| c |>\nAh, in that case I don't think there is another solution\
    \ that will take advantage of the fact that the array is already sorted.  You\
    \ can certainly use similar code but you would have to iterate over the list twice.\n\
    <|/ c |>\n<| a tags=javascript,algorithm,arrays dscore=1 |>\nHere's a solution\
    \ that does one pass of sorting, one pass of partitioning, and one pass over the\
    \ resulting partitions (i.e., one pass over the original list). The algorithm\
    \ is simple but could be improved in many ways, but it illustrates the point well.\n\
    <code>", "    if (l.length < 3) {\n        l.sort();\n        return l;\n    }\n\
    \    let third = l[l.length - 2] % 3;\n    let i = l.length - 1;\n    for (let\
    \ j = l.length - 1; j > 0; j--) {\n        if (l[j] % 3 === third) {\n       \
    \     i++;\n        }\n        if (i >= j) {\n            break;\n        }\n\
    \        l[i] = l[j];\n        i--;\n    }\n    l[0] = l[i - 1];\n    return l;\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
