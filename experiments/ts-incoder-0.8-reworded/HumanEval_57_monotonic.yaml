name: HumanEval_57_monotonic
language: ts
prompt: "//Return true is array elements are monotonically increasing or decreasing.\n\
  // >>> monotonic([1, 2, 4, 20])\n// true\n// >>> monotonic([1, 20, 4, 10])\n// false\n\
  // >>> monotonic([4, 1, 0, -10])\n// true\nfunction monotonic(l: number[]): boolean\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = monotonic;\n  assert.deepEqual(candidate([1, 2, 4,\
  \ 10]),true);\n  assert.deepEqual(candidate([1, 2, 4, 20]),true);\n  assert.deepEqual(candidate([1,\
  \ 20, 4, 10]),false);\n  assert.deepEqual(candidate([4, 1, 0, -10]),true);\n  assert.deepEqual(candidate([4,\
  \ 1, 1, 0]),true);\n  assert.deepEqual(candidate([1, 2, 3, 2, 5, 60]),false);\n\
  \  assert.deepEqual(candidate([1, 2, 3, 4, 5, 60]),true);\n  assert.deepEqual(candidate([9,\
  \ 9, 9, 9]),true);\n}\n\ntest();"
completions: ["  if (l.length === 0) {\n    return false;\n  }\n\n  const n = l[0];\n\
    \  let i;\n\n  for (i = 1; i < l.length; ++i) {\n    if (l[i] <= n) {\n      return\
    \ false;\n    }\n    n = l[i];\n  }\n\n  return true;\n}\n", "  l.sort(function\
    \ (a, b) { return a - b; });\n  return l.length >= 3 && l[0] === l[l[1]] === l[l[2]];\n\
    }\n", "    if (l.length < 2) {\n        return true;\n    }\n\n    let counter\
    \ = 0;\n    let pos = 0;\n    let l = l.slice();\n    while (pos < l.length) {\n\
    \        counter = 0;\n        let tmpPos = pos;\n        while (pos < l.length\
    \ && l[pos] <= l[tmpPos]) {\n            counter++;\n            pos++;\n    \
    \    }\n        if (counter > 1) {\n            return false;\n        }\n   \
    \ }\n\n    return true;\n}\n", "  let n = 0; let i = 0;\n  const m = l.length;\n\
    \n  while (++i < m) {\n    const x = l[i];\n\n    if (x >= l[i - 1] &&\n     \
    \   x < l[i - 1]) {\n      return true;\n    } else if (x >= l[i - 1]) {\n   \
    \   if (++n > 1) return false;\n    } else {\n      if (--n < 0) return false;\n\
    \    }\n  }\n\n  return true;\n}\n", "  return l.some((x, i) => {\n    if (x !==\
    \ l[i - 1]) return\n    if (x >= l[i - 1]) return\n    return l[i] >= x ? true\
    \ : false\n  })\n}\n", "    if (l.length === 0) {\n        return false;\n   \
    \ }\n\n    if (l[0] > l[l.length - 1]) {\n        return true;\n    }\n\n    for\
    \ (let i = 1; i < l.length; i++) {\n        if (l[i] !== l[i - 1]) {\n       \
    \     return false;\n        }\n    }\n\n    return true;\n}\n\n<|/ file source=gitlab\
    \ |>\nexport class MonotonicInterpolator {\n    private data: number[];\n\n  \
    \  constructor(data: number[]) {\n        this.data = data;\n    }\n\n    interpolate(x:\
    \ number, y: number): number {\n        const sortedData = x.concat().sort((a,\
    \ b) => a - b);\n        const idx = bisect(sortedData, x);\n\n        const dx\
    \ = (sortedData[idx] - x) / (x.length - 1);\n        const x1 = sortedData[idx];\n\
    \        const x2 = sortedData[idx+1];\n\n        const dy = y - y1;\n\n     \
    \   if (dx === 0) {\n            return y1;\n        }\n        if (dx === 1)\
    \ {\n            return y2;\n        }\n\n        const val = (dx * (y2 - y1)\
    \ + dy * (x1 - x2)) / dx || 0;\n\n        return y1 + val * (sortedData.length\
    \ - idx);\n    }\n}\n", "  const n = new Array(l.length);\n  for (let i = 0; i\
    \ < n.length; ++i) {\n    n[i] = l[i];\n  }\n\n  for (let i = 1; i < n.length\
    \ - 1; ++i) {\n    if (n[i] > n[i - 1]) {\n      n[i] = n[i - 1];\n    } else\
    \ if (n[i] < n[i - 1]) {\n      n[i] = n[i - 1];\n    }\n  }\n\n  if (n[n.length\
    \ - 1] > n[n.length - 2]) {\n    n[n.length - 1] = 0;\n  }\n\n  if (n[0] < n[1])\
    \ {\n    return true;\n  }\n\n  return false;\n}\n", "  if (l.length === 0) {\n\
    \    return false;\n  }\n\n  let first = 0;\n  let last = l.length - 1;\n  let\
    \ mid = 0;\n  let current;\n  const length = l.length;\n  while (current < last)\
    \ {\n    current = Math.floor((last - first + 1) / 2);\n    if (l[current] > l[current+1])\
    \ {\n      mid = current;\n      first = current+1;\n    } else {\n      last\
    \ = (current === mid) ? last : (current+1);\n    }\n  }\n\n  // If the first two\
    \ numbers are equal, their difference is also 0.\n  // If last is even and the\
    \ first is odd, first is unchanged.\n  // If last is even and the first is odd,\
    \ last is unchanged.\n  // If first is even and the last is odd, last is unchanged.\n\
    \  if (first === last && ((first & 1) === (last & 1))) {\n    return false;\n\
    \  }\n\n  // If the array is too short, we have nothing to compare.\n  if (length\
    \ <= 2) {\n    return false;\n  }\n\n  return l[first] <= l[last];\n}\n", "  \
    \  let prev = l[0];\n    let first = true;\n    for (let i = 0; i < l.length;\
    \ i++) {\n        const x = l[i];\n        if (first || prev < x) {\n        \
    \    first = false;\n            return true;\n        }\n        prev = x;\n\
    \    }\n    return false;\n}\n", "    if (l.length === 0) {\n        return false;\n\
    \    }\n    const last = l[0];\n    for (var i = 1; i < l.length; i++) {\n   \
    \     const val = l[i];\n        if (val <= last) {\n            return false;\n\
    \        }\n        last = val;\n    }\n    return true;\n}\n", "  let prev: number,\
    \ cur: number, next: number;\n  if (l.length < 2) {\n    return true;\n  }\n \
    \ const p1 = l[0];\n  const p2 = l[1];\n  for (let i = 1, len = l.length; i <\
    \ len; i++) {\n    cur = l[i];\n    if (cur !== prev) {\n      prev = cur;\n \
    \     if (cur < p1) {\n        return true;\n      }\n      if (cur > p2) {\n\
    \        return true;\n      }\n    }\n  }\n  return false;\n}\n", "  if (l.length\
    \ === 0) {\n    return false;\n  }\n  let min: number = Number.MAX_VALUE;\n  let\
    \ max: number = Number.MIN_VALUE;\n  for (let i = 0; i < l.length; i++) {\n  \
    \  if (l[i] < min) {\n      min = l[i];\n    }\n    if (l[i] > max) {\n      max\
    \ = l[i];\n    }\n  }\n  return min < max ? false : true;\n}\n", "  let min: number[]\
    \ = [];\n  let max: number[] = [];\n  let i = 0;\n  let j = 0;\n  let sum = 0;\n\
    \  while (i < l.length) {\n    if (l[i] > l[j]) {\n      min = min.concat(l.slice(i));\n\
    \    }\n    else if (l[i] < l[j]) {\n      max = max.concat(l.slice(i));\n   \
    \ }\n    i++;\n    j++;\n  }\n  while (i < l.length) {\n    min = min.concat(l.slice(i));\n\
    \    i++;\n  }\n  while (j < l.length) {\n    max = max.concat(l.slice(j));\n\
    \    j++;\n  }\n  while (j < l.length) {\n    sum = sum + l[j];\n    j++;\n  }\n\
    \  while (i < l.length) {\n    sum = sum - l[i];\n    i++;\n  }\n  while (i <\
    \ l.length) {\n    if (min == null) {\n      min = l.slice(i);\n    }\n    else\
    \ if (max != null) {\n      max = max.concat(l.slice(i));\n    }\n    i++;\n \
    \ }\n  if (max == null) {\n    return true;\n  }\n  if (min != null) {\n    min\
    \ = min.concat(max);\n    max = null;\n  }\n  if (sum < 0) {\n    return false;\n\
    \  }\n  return true;\n}\n", "  let n = 1;\n  let flag = false;\n\n  for (let i\
    \ = 0; i < l.length; i++) {\n    if (l[i] > l[i - 1]) {\n      n = 1;\n      flag\
    \ = true;\n    } else if (l[i] < l[i - 1]) {\n      n = -1;\n      flag = true;\n\
    \    } else {\n      n = 0;\n      flag = true;\n    }\n  }\n\n  return flag &&\
    \ n === 1;\n}\n", "  var i = 0;\n  var n = l.length;\n  while (i < n) {\n    var\
    \ l = l[i];\n    if (l<l[i-1]) {\n      return false;\n    }\n    if (l>l[i-1])\
    \ {\n      return true;\n    }\n    i++;\n  }\n  return false;\n}\n", "  if (l.length\
    \ < 2) return false;\n  const sortedL = l.sort((a, b) => a - b);\n  let firstTrue\
    \ = true;\n  for (let i = 1; i < sortedL.length; i += 1) {\n    if (sortedL[i]\
    \ !== sortedL[i - 1]) {\n      firstTrue = false;\n    }\n  }\n  return firstTrue;\n\
    }\n", "\tconst len = l.length;\n\tif (len < 2) {\n\t\treturn true;\n\t}\n\tconst\
    \ firstValue = l[0];\n\tfor (let i = 1; i < len; i++) {\n\t\tconst currentValue\
    \ = l[i];\n\t\tif (currentValue < firstValue) {\n\t\t\treturn false;\n\t\t}\n\t\
    \tif (currentValue > firstValue) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n\
    }\n", "  var a = l[0];\n  for (var i = 1, len = l.length; i < len; i++) {\n  \
    \  var b = l[i];\n    if (a < b) {\n      return false;\n    }\n    a = b;\n \
    \ }\n  return true;\n}\n", "    let i: number;\n    let j: number;\n    let cmp:\
    \ number;\n    const n = l.length;\n    const maxIndex: number = n - 1;\n    const\
    \ minIndex: number = 0;\n    let max: number = l[0];\n    let min: number = l[0];\n\
    \n    for (i = 0; i < n; i++) {\n        j = i;\n        while ((j < n) && l[j]\
    \ === max) {\n            j++;\n        }\n        if (j === n) {\n          \
    \  cmp = 0;\n        } else {\n            cmp = l[j] - max;\n        }\n\n  \
    \      if (i > 0) {\n            j = i;\n            while ((j < n) && l[j] ===\
    \ min) {\n                j++;\n            }\n            if (j === n) {\n  \
    \              cmp = 1;\n            } else {\n                cmp = l[j] - min;\n\
    \            }\n        }\n        if (cmp === 0) {\n            return false;\n\
    \        }\n        if (cmp > 0) {\n            max = l[i];\n        } else {\n\
    \            min = l[i];\n        }\n    }\n    return (min === max);\n}\n", " \
    \ const n = l.length\n  if (n < 3) { return true }\n  const p = l.padEnd(n)\n\
    \  let q = l.padStart(n)\n  for (let i = 2; i < n; ++i) {\n    if (l[i] < l[i\
    \ - 1]) { return false }\n    if (q < l[i - 1] && q < l[i]) { return false }\n\
    \    if (l[i] > l[i - 1] && q > l[i]) { return false }\n  }\n  return true\n}\n",
  "    if (l.length < 1) {\n        return true; // nothing to do\n    }\n\n    for\
    \ (let i = 0, j = 1; i < l.length; ++i, ++j) {\n        if (l[i] < l[j]) {\n \
    \           return true;\n        }\n        if (l[i] > l[j]) {\n            return\
    \ false;\n        }\n    }\n\n    return false;\n}\n", "\tlet pointer1 = 0;\n\t\
    let pointer2 = 1;\n\tlet pointer3 = 2;\n\tlet i = 0;\n\tlet test = 0;\n\tlet found\
    \ = false;\n\n\twhile (!found && pointer2 <= l.length) {\n\t\twhile (pointer2\
    \ <= l.length && !found && (test = (l[pointer1] - l[pointer2]) <= 0)) {\n\t\t\t\
    pointer2++;\n\t\t}\n\t\twhile (pointer1 <= pointer2 && !found && (test = (l[pointer2]\
    \ - l[pointer1]) <= 0)) {\n\t\t\tpointer1++;\n\t\t}\n\t\tif (test) {\n\t\t\tfound\
    \ = true;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\tif (i >= l.length) {\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t\tfound = (l[pointer1] === l[pointer2]);\n\t\t}\n\t}\n\t\
    return !found;\n}\n", "  let len = l.length;\n  if (len < 2) {\n    return false;\n\
    \  }\n\n  for (let i = 1, j = 0, k = len - 1, m = len - 2; j < m; ++j, --k) {\n\
    \    if (l[j] > l[k]) {\n      return j;\n    }\n  }\n  return k;\n}\n", "\treturn\
    \ monotonic_helper(l).every((e) => !isNaN(e));\n}\n", "  if (l.length === 0) {\n\
    \    return false;\n  }\n  if (l.length === 1) {\n    return true;\n  }\n  let\
    \ min = l[0],\n      max = l[0];\n  for (let i = 1; i < l.length; i++) {\n   \
    \ const e = l[i];\n    if (e < min) {\n      min = e;\n    }\n    if (e > max)\
    \ {\n      max = e;\n    }\n  }\n  return min === max;\n}\n", "  if (l.length\
    \ < 2) {\n    return false;\n  }\n\n  return monotonicInner(l[0], l[1]) <= 0 &&\n\
    \    monotonicInner(l[1], l[2]) <= 0;\n}\n", "    if (l.length === 0) {\n    \
    \    return true;\n    }\n    var last = l[0], diff = last;\n    for (var i =\
    \ 1; i < l.length; i++) {\n        var nextVal = l[i];\n        if (nextVal <\
    \ last) {\n            return false;\n        }\n        diff = nextVal - last;\n\
    \        last = nextVal;\n    }\n    return true;\n}", "  let len = l.length;\n\
    \  if (len < 1) return false;\n\n  let sortIdx = -1;\n  for (let i = 1; i < len;\
    \ i++) {\n    const x = l[i];\n    let j = i - 1;\n    while (j >= 0 && (sortIdx\
    \ === -1 || x < l[j])) {\n      l[j + 1] = l[j];\n      j--;\n    }\n    l[j +\
    \ 1] = x;\n    sortIdx = x;\n  }\n  return sortIdx === -1;\n}\n", "  if (l.length\
    \ < 1) return false\n  return l.reduce((a, b) => a <= b) //This works for both\
    \ monotonic (strict) and non-monotonic (non-strict) monotonic series.\n}\n", " \
    \ const n = l.length;\n  if (n < 2) {\n    return true;\n  }\n\n  for (let i =\
    \ 1; i < n; ++i) {\n    if (l[i - 1] > l[i] || l[n - 1] > l[i]) {\n      return\
    \ false;\n    }\n  }\n\n  return true;\n}\n", "  let length = l.length\n  if (length\
    \ < 2) return false\n  for (let i = 0; i < length; i++) {\n    if (l[i] !== l[i\
    \ - 1]) break\n  }\n  for (let i = 1; i < length; i++) {\n    if (l[i] <= l[i\
    \ - 1]) return false\n  }\n  return true\n}\n", "    if (l.length === 0) {\n \
    \       return false;\n    }\n    if (l[0] >= l[l.length - 1]) {\n        return\
    \ false;\n    }\n    for (let i = 1; i < l.length; i++) {\n        if (l[i] <\
    \ l[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n", "  if (l.length <= 1) return true;\n  for (let i = 1; i < l.length; ++i)\
    \ {\n    const m = (i + 1) < l.length ? i + 1 : i;\n    if (l[i] < l[m]) continue;\n\
    \    if (l[i] > l[m]) break;\n    return false;\n  }\n  return true;\n}\n</code>\n\
    <|/ a tags=arrays,array-algorithms,language-agnostic,sorting dscore=5 |>\n<| c\
    \ |>\nThat is not correct. If you have `[5, 6, 1, 3]`, then `monotonic([5, 6,\
    \ 1, 3])` is `true`, while `monotonic([1, 6, 5, 3])` is `false`. Try it out in\
    \ your browser console: `[5, 6, 1, 3].map(x => Math.sign(x)) === [-1, 0, 1, -1]`\n\
    <|/ c |>\n<| c |>\n`[5, 6, 1, 3].map(x => Math.sign(x)) === [-1, 0, 1, -1]`\n\
    <|/ c |>\n<| c |>\nYes, it does. And my `monotonic` function also returns `true`\
    \ for monotonic arrays.\n<|/ c |>\n<| c |>\nI thought that the OP wanted the *first*\
    \ monotonic item, so I've made a slight modification. Does this make sense?\n\
    <|/ c |>\n<| c |>\nThe question doesn't ask for the *first* monotonic item. As\
    \ I see it, it's about *any* monotonic items. As such, your answer does not answer\
    \ the OP's question. Your answer works only for monotonic arrays.\n<|/ c |>\n\
    <| a dscore=5 |>\nIf you're using Ramda, it's fairly simple: \n<code>\nconst monotonic\
    \ = R.allPass([R.lte, R.gte]);\nmonotonic([5, 6, 1, 3]); // => true\nmonotonic([1,\
    \ 6, 5, 3]); // => false\n</code>\nEdit: As points out, you can also do this in\
    \ vanilla JS with Array.prototype.every:\n<code>\nconst monotonic = (l) => l.every(v\
    \ => v < l[0]);\nmonotonic([5, 6, 1, 3]); // => true\nmonotonic([1, 6, 5, 3]);\
    \ // => false\n</code>\n<|/ a tags=arrays,array-algorithms,language-agnostic,sorting\
    \ |>\n<| c |>\nIt's worth noting that Ramda also includes functions like [`R.anyPass`](http://ramdajs.com/docs/#anyPass),\
    \ which can be used to filter out any `false` values as well as `true` values.\
    \ E.g., `R.anyPass([R.lte, R.g", "    var s = l.slice(),\n        i = 1,\n   \
    \     j,\n        k;\n\n    while (i < s.length) {\n        k = s[i - 1];\n\n\
    \        if (k.length >= 2 && k[1] - k[0] >= 0) {\n            for (j = i; j <\
    \ s.length; j++) {\n                if (s[j - 1].length >= 2 && s[j - 1][k[1]\
    \ - k[0]] <= 0) {\n                    break;\n                }\n           \
    \ }\n\n            if (j == i - 1) {\n                return true;\n         \
    \   }\n        } else {\n            j = i;\n        }\n\n        i = j + 1;\n\
    \    }\n\n    return false;\n}\n\nexport var x1: number;\nexport var y1: number;\n\
    export var x2: number;\nexport var y2: number;\n\nvar min_x: number;\nvar min_y:\
    \ number;\nvar max_x: number;\nvar max_y: number;\n", "  let i = 0;\n  const n\
    \ = l.length;\n  if (n < 2) {\n    return true;\n  }\n  while (i < n) {\n    if\
    \ (l[i++] > l[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n", " \
    \   if (l.length === 0) {\n        return false;\n    }\n\n    var firstValue\
    \ = l[0];\n\n    for (var i = 1; i < l.length; i++) {\n        var nextValue =\
    \ l[i];\n        var delta = nextValue - firstValue;\n\n        if (delta > 0)\
    \ {\n            return false;\n        } else if (delta == 0) {\n           \
    \ // If nextValue == firstValue, it can't be increasing\n            // or decreasing\
    \ from it so it's not monotonic\n            return false;\n        } else {\n\
    \            firstValue = nextValue;\n        }\n    }\n    return true;\n}\n",
  "\tconst { length } = l;\n\tif (length <= 1) {\n\t\treturn true;\n\t}\n\n\tlet prev\
    \ = l[0];\n\tlet i = 1;\n\tlet increasing = true;\n\tlet prevIncreasing = true;\n\
    \tlet diff = 1;\n\n\tfor (; i < length; i++) {\n\t\tconst curr = l[i];\n\t\tconst\
    \ { increasing } = curr;\n\n\t\tif (increasing === prevIncreasing && prevIncreasing\
    \ === false) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (increasing === prevIncreasing\
    \ && prevIncreasing === true) {\n\t\t\tincreasing = false;\n\t\t}\n\n\t\tprevIncreasing\
    \ = increasing;\n\t\tdiff = curr - prev;\n\n\t\tif (diff < 0) {\n\t\t\tprev =\
    \ curr;\n\t\t}\n\t\tif (diff > 0) {\n\t\t\tif (increasing === false) {\n\t\t\t\
    \treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprevIncreasing = true;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn true;\n}\n\nexport function createSelector(\n\tselectors:\
    \ Array<string | Function>\n): Function {\n\treturn (...args: Array<any>) => {\n\
    \t\tlet state = args[0];\n\n\t\tconst len = selectors.length;\n\n\t\tlet i = 0;\n\
    \n\t\tfor (; i < len; i++) {\n\t\t\tconst selector = selectors[i];\n\t\t\tconst\
    \ result = selector(state);\n\n\t\t\tif (typeof result === 'undefined') {\n\t\t\
    \t\treturn undefined;\n\t\t\t}\n\n\t\t\tstate = result;\n\t\t}\n\n\t\treturn state;\n\
    \t};\n}\n\nexport function createSelectors<S>(selectors: Array<[S, Function]>):\
    \ [S, Function] {\n\tif (selectors.length === 0) {\n\t\tthrow new Error('createSelector:\
    \ selectors should not be empty');\n\t}\n\tif (selectors.some(a => typeof a !==\
    \ 'string')) {\n\t\tthrow new Error('createSelector: selectors must be strings');\n\
    \t}\n\n\treturn selectors.map(([selector, fn]) => [\n\t\tcreateSelector(selector),\n\
    \t\tfn,\n\t]);\n}\n\nexport function createSelectorHook(selector: string): Function\
    \ {\n\treturn (...args: Array<any>) => {\n\t\tlet state = args[0];\n\n\t\tconst\
    \ len = selector.length;\n\n\t\tlet i = 0;\n\n\t\tfor (; i < len; i++) {\n\t\t\
    \tconst selector = selector[i];\n\t\t\tconst result = selector(state);\n\n\t\t\
    \tif (typeof result === 'undefined') {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\
    \t\t\tstate = result;\n\t\t}\n\n\t\treturn state;\n\t};\n}\n", "  let prev = l[0]\n\
    \  for (let i = 1; i < l.length; i++) {\n    const current = l[i]\n    if (current\
    \ <= prev) {\n      return true\n    }\n    prev = current\n  }\n  return false\n\
    }\n", "\tconst monotonic = true;\n\tlet l = l;\n\tlet i = 0;\n\tconst len = l.length;\n\
    \twhile (i < len) {\n\t\tconst val = l[i];\n\t\tconst j = i;\n\t\twhile (j < len\
    \ && l[j] <= val) {\n\t\t\tj++;\n\t\t}\n\t\tif (j > i) {\n\t\t\tconst tmp = l[i];\n\
    \t\t\tl[i] = l[j];\n\t\t\tl[j] = tmp;\n\t\t\ti = j;\n\t\t\tmonotonic = false;\n\
    \t\t}\n\t\ti++;\n\t}\n\treturn monotonic;\n}\n", "  let prevL: number;\n  let\
    \ currL: number;\n  let nextL: number;\n  let i = 0;\n\n  prevL = 0;\n  currL\
    \ = l[0];\n  nextL = 1;\n  while (i < l.length) {\n    if (l[i] <= prevL) {\n\
    \      currL = prevL;\n    }\n    else {\n      currL = nextL;\n    }\n\n    nextL\
    \ *= 2;\n    if (nextL > currL) {\n      nextL = currL;\n    }\n    prevL = currL;\n\
    \    i += 1;\n  }\n  return currL === prevL;\n}\n", "  let prev = l[0];\n  for\
    \ (let cur of l) {\n    if (cur !== prev) {\n      return true;\n    }\n    prev\
    \ = cur;\n  }\n  return false;\n}\n", "    if (l.length < 1) {\n        return\
    \ false;\n    }\n    var hasT = true;\n    var hasD = true;\n    var hasNeg =\
    \ true;\n    var hasPos = true;\n    var len = l.length;\n    var index = -1;\n\
    \    var prevPos = 0;\n    var pos;\n    var t;\n    var d;\n    var neg;\n  \
    \  var posOrNeg;\n    var i;\n    for (i = 0; i < len; i++) {\n        pos = l[i];\n\
    \        t = pos % 1;\n        posOrNeg = pos - t;\n        if (hasT) {\n    \
    \        d = posOrNeg;\n        } else {\n            hasT = true;\n         \
    \   d = posOrNeg - pos;\n        }\n        hasD = hasD && d;\n        if (hasNeg)\
    \ {\n            neg = -posOrNeg;\n        } else {\n            hasNeg = true;\n\
    \            neg = -posOrNeg - pos;\n        }\n        hasNeg = hasNeg && neg;\n\
    \        if (hasPos) {\n            pos = posOrNeg;\n        } else {\n      \
    \      hasPos = true;\n            pos = posOrNeg - pos;\n        }\n        hasPos\
    \ = hasPos && pos;\n        if (t != 0 || d != 0) {\n            if (hasNeg) {\n\
    \                return (neg <= 0);\n            } else {\n                return\
    \ (pos > 0);\n            }\n        }\n    }\n    return (hasD && hasPos);\n}",
  "    if (l.length <= 1) {\n        return true\n    }\n    const n = l[l.length\
    \ - 1]\n    l.sort((a, b) => a - b)\n    for (let i = 0; i < l.length - 1; i++)\
    \ {\n        if (l[i + 1] > n) {\n            return false\n        }\n    }\n\
    \    return true\n}", "  let s = 0, n = l.length, max = Number.NEGATIVE_INFINITY;\n\
    \  for (let i = 0; i < n; ++i) {\n    if (l[i] > max) {\n      s = 1;\n      max\
    \ = l[i];\n    } else if (l[i] < max) {\n      s = 0;\n    }\n  }\n  return s\
    \ > 0;\n}\n", "  if (l.length === 0) {\n    return false\n  }\n  if (l.length\
    \ === 1) {\n    return true\n  }\n  if (l[0] < l[l.length - 1]) {\n    return\
    \ false\n  }\n  var l = l.slice()\n  l.pop() // sort the array in descending order\n\
    \  return monotonic(l) // recurse\n}\n", "  if (l.length < 2) {\n    return false;\n\
    \  }\n  var s = l[0];\n  for (var i = 0; i < l.length; ++i) {\n    if (s > l[i])\
    \ {\n      return false;\n    }\n    s = l[i];\n  }\n  return true;\n}\n", "\t\
    if (l.length < 2) {\n\t\treturn true;\n\t}\n\tlet firstMonotonic = false; // are\
    \ there any negative numbers to monitor?\n\tfor (let i = 0; i < l.length; i++)\
    \ {\n\t\tif (l[i] < 0) {\n\t\t\tif (firstMonotonic) {\n\t\t\t\treturn false; //\
    \ can't handle negative numbers yet\n\t\t\t}\n\t\t\tfirstMonotonic = true;\n\t\
    \t}\n\t}\n\tlet lastMonotonic = false; // are there any positive numbers to monitor?\n\
    \tfor (let i = l.length - 1; i >= 0; i--) {\n\t\tif (l[i] > 0) {\n\t\t\tif (lastMonotonic)\
    \ {\n\t\t\t\treturn false; // can't handle positive numbers yet\n\t\t\t}\n\t\t\
    \tlastMonotonic = true;\n\t\t}\n\t}\n\t// we've established that all the numbers\
    \ are either monotonically\n\t// increasing or decreasing. therefore there is\
    \ nothing left to check\n\treturn true;\n}\n", "    const n = l.length;\n    if\
    \ (n <= 1) {\n        return true;\n    }\n    let firstValue = l[0], lastValue\
    \ = l[n - 1];\n    for (let i = 1; i < n; ++i) {\n        const value = l[i];\n\
    \        if (value < lastValue) {\n            return false;\n        }\n    \
    \    if (value > lastValue) {\n            return true;\n        }\n        lastValue\
    \ = value;\n    }\n    return true;\n}\n", "\tlet lastVal = l[0],\n\t\ti;\n\t\
    for (i = 1; i < l.length; i++) {\n\t\tconst currVal = l[i];\n\t\tif (lastVal <\
    \ currVal) {\n\t\t\treturn true;\n\t\t}\n\t\tlastVal = currVal;\n\t}\n\treturn\
    \ false;\n}\n", "    if (l.length < 2) {\n        return false;\n    }\n\n   \
    \ for (let i = 1; i < l.length; i++) {\n        if (l[i - 1] > l[i]) {\n     \
    \       return false;\n        }\n    }\n\n    return true;\n}\n", "    if (l.length\
    \ === 0) {\n        return false;\n    }\n    const max = l[0], min = l[0];\n\
    \    for (let i = 1; i < l.length; i++) {\n        const curMax = l[i], curMin\
    \ = l[i];\n        if (curMax > max) {\n            max = curMax;\n        }\n\
    \        if (curMin < min) {\n            min = curMin;\n        }\n    }\n  \
    \  return min === max;\n}", "  let i = 0,\n    len = l.length;\n\n  while (++i\
    \ < len) {\n    const val = l[i];\n    if (val > l[i + 1]) {\n      return false;\n\
    \    }\n  }\n\n  return true;\n}\n", "  const n = l.length;\n  if (n <= 1) return\
    \ false;\n\n  const a = [...l]; //Create a copy of the original array.\n  const\
    \ b = [];\n\n  b.push(a[0]);\n\n  for (let i = 1; i < n; i++) {\n    let aLast\
    \ = a[i - 1];\n    let aCurr = a[i];\n    let bCurr = b[i - 1];\n\n    if (aLast\
    \ === aCurr && aLast > bCurr) return false;\n    b.push(aCurr);\n  }\n\n  return\
    \ true;\n}\n", "    if (l.length === 0) {\n        return true;\n    }\n    let\
    \ n = l[0];\n    for (let i = 1; i < l.length; i++) {\n        if (l[i] < n) {\n\
    \            return false;\n        }\n        n = l[i];\n    }\n    return true;\n\
    }\n", "  let l0 = l[0], l1 = l[1], l2 = l[2], l3 = l[3], l4 = l[4], l5 = l[5];\n\
    \  if (l0 === l1 || l0 === l5 || l0 === l4 || l0 === l3 || l1 === l5 || l1 ===\
    \ l4 || l1 === l3 || l2 === l5 || l2 === l4 || l2 === l3) {\n    return 1;\n \
    \ }\n  return 0;\n}\n", "  for (let i = 1; i < l.length; i++) {\n    if (l[i]\
    \ <= l[i - 1]) return false;\n  }\n\n  return true;\n}\n", "  for (let i = l.length\
    \ - 1; i >= 0; i--) {\n    const monotonic1 = l[i];\n    const monotonic2 = l[i\
    \ + 1];\n    if (monotonic1 > monotonic2) {\n      return false;\n    }\n  }\n\
    \n  return true;\n}\n", "  const n = l.length\n  const m = n-1\n  const s = l[0]\n\
    \  for (let i = 1; i < n; ++i) {\n    const e = l[i]\n    if (e < s) {\n     \
    \ return false\n    }\n    if (e > s) {\n      s = e\n      m = i\n    }\n  }\n\
    \  if (m > 0 && l[m-1] < l) {\n    return true\n  }\n  if (m < n) {\n    return\
    \ false\n  }\n  return true\n}\n", "  if (l.length === 0) {\n    return true;\n\
    \  }\n  let first = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i]\
    \ !== first && l[i] > first) {\n      return false;\n    }\n  }\n  return true;\n\
    }\n", "  let n = l.length;\n  if (n <= 1) return true;\n  let prev = l[0];\n \
    \ for (let i = 1; i < n; ++i) {\n    const curr = l[i];\n    if (curr !== prev)\
    \ {\n      if (curr !== curr) {\n        return true;\n      }\n      prev = curr;\n\
    \    } else {\n      return false;\n    }\n  }\n  return true;\n}\n", "    return\
    \ !l.reduce((p, c, i, a) => {\n        const ac = l[i - 1] || Infinity;\n    \
    \    if (p < c || (p === c && ac > a[i + 1])) {\n            return true;\n  \
    \      }\n        return false;\n    });\n}\n", "    let len = l.length;\n   \
    \ if (len < 2) {\n        return true;\n    }\n    let i = 0;\n    let j = len\
    \ - 1;\n    let k = len - 2;\n    while (i < j) {\n        if (l[i] - l[j] >=\
    \ 0) {\n            i++;\n        }\n        else {\n            j--;\n      \
    \  }\n        if (i < k) {\n            if (l[i] - l[k] >= 0) {\n            \
    \    i++;\n                k--;\n            }\n            else {\n         \
    \       j--;\n            }\n        }\n    }\n    return j == k;\n}\n", "  const\
    \ n = l.length\n  for (let i = 0; i < n; ++i) {\n    for (let j = i + 1; j < n;\
    \ ++j) {\n      if (l[i] < l[j]) {\n        return true\n      }\n      if (l[i]\
    \ > l[j]) {\n        return false\n      }\n    }\n  }\n  return false\n}\n",
  "  const isIncreasing = (l, i, j) => i >= j;\n  const isDecreasing = (l, i, j) =>\
    \ i <= j;\n  const len = l.length;\n\n  for (let i = 0; i < len - 1; ++i) {\n\
    \    const a = l[i];\n    const b = l[i + 1];\n\n    if (isIncreasing(a, b, i\
    \ + 1)) {\n      return true;\n    }\n    if (isDecreasing(a, b, i + 1)) {\n \
    \     return false;\n    }\n  }\n\n  return false;\n}\n", "    if (l.length ===\
    \ 0) {\n        return false;\n    }\n    let lastNonMonotonic = 0;\n    for (let\
    \ i = 0; i < l.length; i++) {\n        const val = l[i];\n        if (val <= lastNonMonotonic)\
    \ {\n            return false;\n        }\n        if (val > lastNonMonotonic)\
    \ {\n            lastNonMonotonic = val;\n        }\n    }\n    return true;\n\
    }\n", "\tconst n = l.length\n\tif (n < 2) return true\n\n\tconst a = [...l]\n\t\
    const b = a.slice().reverse()\n\n\tlet change = false\n\tfor (let i = 0; i < n;\
    \ i++) {\n\t\tconst d = a[i]\n\t\tconst e = b[i]\n\t\tif (d !== e) {\n\t\t\tchange\
    \ = true\n\t\t}\n\t}\n\treturn change\n}\n", "    if (l.length <= 1) {\n     \
    \   return true\n    }\n    const n = l[l.length - 1]\n    const m = new Int32Array(l.length)\n\
    \    for (let i = l.length - 1; i > 0; i--) {\n        const m = Math.max(l[i],\
    \ l[i - 1])\n        if (m > n) {\n            return false\n        }\n     \
    \   m[i] = Math.max(m[i], m)\n    }\n    return l[0] <= m[0]\n}\n", "  if (l.length\
    \ <= 1) {\n    return false;\n  }\n  const m = l[0], n = l[1];\n  return n > m\
    \ * n\n    || (n === m * n && l[2] == m * l[2]);\n}\n", "    if (l.length ===\
    \ 0) {\n        return false;\n    }\n\n    if (l.length === 1) {\n        return\
    \ l[0] === l[0] + 1 || l[0] === l[0] - 1;\n    }\n\n    const first = monotonic(l[0]);\n\
    \    const rest = l.slice(1);\n\n    return first && rest.length > 0 && monotonic(rest);\n\
    }\n</code>\n<|/ a |>\n<| a tags=algorithm,javascript,math,sorting |>\nThis is\
    \ a fairly simple problem in general, and this isn't a JavaScript problem, but\
    \ a general math problem in general.\nThe basic idea is that we sort the array\
    \ in such a way that the smallest item is the lowest possible rank, and largest\
    \ item is the highest possible rank.  We then count the number of negative numbers\
    \ above and below the median.  This number is the expected number of elements\
    \ above and below the median, divided by the size of the array.  This gives the\
    \ fraction of elements above the median.\nThe median is the average of the lowest\
    \ and highest elements.\nHere is a graph of how this works.  (I have plotted the\
    \ median, not the median-average, as it is easier to see).\n\nAs you can see from\
    \ this graph, the expected number of elements above the median is 1 when the fraction\
    \ of elements is 1, and 2 when it is 0.5, and 4 when it is 0.25 and so on.\nThis\
    \ can be easily implemented in JavaScript as follows (note that you can see the\
    \ result in the console):\n<code>", "    var n = l.length,\n        i = 0;\n\n\
    \    if (n <= 1) return true;\n\n    var left = l[0],\n        right = l[n-1];\n\
    \n    while (i < n) {\n        if (l[i+1] < left) {\n            i++;\n      \
    \  } else if (l[i] > right) {\n            i--;\n        } else {\n          \
    \  return true;\n        }\n    }\n\n    return false;\n}\n", "  const n = l.length\n\
    \  if (n <= 1) return true\n  for (let i = 1; i < n; i++) {\n    const m = l[i\
    \ - 1]\n    const n = l[i]\n    if (m <= n) {\n      if (m !== n) {\n        if\
    \ (m > n) return false\n      }\n    } else {\n      if (m > n) return true\n\
    \    }\n  }\n  return false\n}\n", "  var len = l.length;\n  if (len < 1) return\
    \ false;\n  var monotonic = true;\n  var lastNonMonotonic = l[len - 1];\n  for\
    \ (var i = 1; i < len; i++) {\n    var current = l[i];\n    var monotonicIncreasing\
    \ = current <= lastNonMonotonic;\n    var monotonicDecreasing = current >= lastNonMonotonic;\n\
    \    monotonic = monotonic && monotonicIncreasing || monotonic && monotonicDecreasing;\n\
    \    lastNonMonotonic = current;\n  }\n  return monotonic;\n}\n", "    var n =\
    \ l.length;\n    if (n < 2) {\n        return false;\n    }\n    var monotonicCount\
    \ = 0;\n    var monotonicStart = l[0];\n    var i = 1;\n    for (; i < n; ++i)\
    \ {\n        if (l[i] <= monotonicStart) {\n            ++monotonicCount;\n  \
    \      } else {\n            if (monotonicCount === 0) {\n                return\
    \ false;\n            }\n            monotonicCount = 1;\n            monotonicStart\
    \ = l[i];\n        }\n    }\n    return i === n && monotonicCount === 1;\n}",
  "  var n = l.length;\n  if (n === 0) {\n    return false;\n  }\n  var monotonic\
    \ = [true];\n  var i;\n  for (i = 1; i < n; ++i) {\n    if (l[i] < l[i - 1]) {\n\
    \      monotonic[i - 1] = false;\n    } else if (l[i] > l[i - 1]) {\n      monotonic[i\
    \ - 1] = true;\n    }\n  }\n  return !monotonic[0];\n}\n", "  l.sort();\n  return\
    \ l.reduce((x, y) => x && x > y);\n}\n</code>\n<|/ a tags=typescript,arrays,functional-programming,algorithm,javascript\
    \ dscore=0 |>\n<| c |>\nI like this solution, but it's only true if the array\
    \ is sorted (which I forgot to mention). See my update for more info.\n<|/ c |>\n\
    <| c |>\nYeah but it's always sorted so it's not that big a deal.\n<|/ c |>\n\
    <| c |>\nIt doesn't have to be, but this solution doesn't seem to work in cases\
    \ like this: monotonic([4, 1, 0, -10])\n<|/ c |>\n<| a |>\nIf your array is sorted\
    \ in ascending order you can just do this:\n<code>\nlet sorted = array.sort((a,\
    \ b) => a - b); // ascending sort\n</code>\nThis would also work for descending,\
    \ just swap the a and b values.\n<code>\nlet sorted = array.sort((a, b) => b -\
    \ a); // descending sort\n</code>\n<|/ a dscore=0 tags=typescript,arrays,functional-programming,algorithm,javascript\
    \ |>\n<| c |>\nThe `sort` method compares elements, not indices, so this won't\
    \ work for monotonic arrays like `[2, 1, 4, 3]`.\n<|/ c |>\n<| c |>\nThanks for\
    \ pointing that out. I realise now that the OP has changed the requirements a\
    \ bit. I'm deleting my answer.\n<|/ c |>\n<| a |>\n<code>\nconst monotonic = (array)\
    \ => {\n  let result = [];\n  result.push(array[0]);\n\n  for (let i = 1; i <\
    \ array.length; i++) {\n    if (array[i] !== result[i - 1]) {\n      result.push(array[i]);\n\
    \    }\n  }\n\n  return result;\n};\n\nconsole.log(monotonic([4, 1, 10, 3]));\
    \ // returns [1,3,4]\n</code>\n<|/ a tags=typescript,arrays,functional-programming,algorithm,javascript\
    \ dscore=0 |>\n<| a dscore=0 tags=typescript,arrays,functional-programming,algorithm,javascript\
    \ |>\nI have written some function for you\n<code>", "  for (let i = 0; i < l.length;\
    \ ++i) {\n    if (l[i] < l[i - 1]) {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n", "    let prev = l[0], curr = l[0];\n    for (let i = 1; i < l.length;\
    \ i++) {\n        if (l[i] <= prev) {\n            prev = curr;\n            curr\
    \ = l[i];\n        } else {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks, this is the best\
    \ answer. Sure enough, my implementation worked for my purposes.\n<|/ c |>\n<|\
    \ c |>\nNicely done. I'd like to add that your implementation is essentially the\
    \ definition of a [median](https://en.wikipedia.org/wiki/Median), but implemented\
    \ as an array of integers. It's very elegant and probably the best answer to the\
    \ original question. :-)\n<|/ c |>\n<| c |>\nI wouldn't use this, I'd use my own\
    \ implementation [in JS](https://github.com/jonathanleighton/median/blob/master/median.js)\
    \ which I believe is a more efficient implementation\n<|/ c |>\n<| c |>\nThe code\
    \ provided does not work if the array has NaNs. A solution would be to replace\
    \ the `l[i] <= prev` with `Number.isNaN(l[i]) ? false : l[i] <= prev`.\n<|/ c\
    \ |>\n<| a |>\nThis can be done using sort. \n<code>\nvar arr = [9,8,5,6,4,3,2,1];\n\
    arr.sort(function(a,b){\n  return b-a;\n});\nconsole.log(arr);\n</code>\n<|/ a\
    \ dscore=5 tags=javascript,arrays,sorting |>\n<| c |>\nThis sorts the array in\
    \ descending order. The question asks for ascending order\n<|/ c |>\n<| c |>\n\
    I believe this answer is the best because it is the fastest one to implement.\n\
    <|/ c |>\n<| a tags=javascript,arrays,sorting |>\nSort a JavaScript array in ascending\
    \ order\n<code>\nvar arr = [4,2,3,5,1,6];\narr.sort()\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis will sort the array in descending order. I.e. [1,2,3] instead\
    \ of [3,2,1]\n<|/ c |>\n<| a dscore=5 |>\n<code>\nlet arr = [4,2,3,5,1,6];\narr.sort(function(a,b){\n\
    \  return a-b;\n});\n</code>\n<|/ a tags=javascript,arrays,sorting |>\n<| c |>\n\
    The question asks for ascending order\n<|/ c |>\n<| c |>\nThis sorts the array\
    \ in descending order. The question asks for ascending order\n<|/ c |>\n<|", " \
    \   const n1: number[] = [];\n    const n2: number[] = [];\n\n    for (let i =\
    \ 0; i < l.length; i++) {\n        let e1 = l[i];\n        let e2 = n1[i - 1];\n\
    \n        // first value can be compared with any value, so this loop is quite\
    \ simple\n        // it compares first value with last value of previous array\
    \ and saves it\n        // for next comparison\n        if (i > 0) {\n       \
    \     if (e1 > n1[i - 1]) {\n                n1 = e2;\n            }\n       \
    \ }\n\n        // now we need to compare first value with current one\n      \
    \  if (e1 < e2) {\n            n1.push(e1);\n        }\n\n        // this loop\
    \ compares current value with last saved value\n        if (i > 0) {\n       \
    \     if (e2 > n2[i - 1]) {\n                n2 = e1;\n            }\n       \
    \ }\n    }\n\n    // we know that we have all elements from first array to last\
    \ array and n1 array\n    // is empty and all elements from last array to first\
    \ array and n2 array is empty\n    return n1.length === 0 && n2.length === 0;\n\
    }\n", "  let prev: number = 0;\n  let hasDecrease: boolean = false;\n  let hasIncrease:\
    \ boolean = false;\n\n  for (let i = 1; i < l.length; i++) {\n    const current\
    \ = l[i];\n    const change = current - prev;\n    hasIncrease = hasIncrease ||\
    \ change > 0;\n    hasDecrease = hasDecrease || change < 0;\n    if (change >\
    \ 0) {\n      prev += change;\n    } else {\n      prev -= change;\n    }\n  }\n\
    \  return hasIncrease || hasDecrease;\n}\n", "  if (l.length === 0) {\n    return\
    \ false;\n  }\n  let isIncreasing = true;\n  let prev = l[0];\n  for (let i =\
    \ 1; i < l.length; i++) {\n    const current = l[i];\n    if (isIncreasing &&\
    \ current < prev) {\n      isIncreasing = false;\n    }\n    if (!isIncreasing\
    \ && current > prev) {\n      isIncreasing = true;\n    }\n    prev = current;\n\
    \  }\n  return isIncreasing;\n}\n", "    var n = l.length;\n    if (n === 0) return\
    \ true;\n    if (n === 1) return false;\n    if (l[0] <= l[n - 1]) {\n       \
    \ return monotonic([l[1], l[n - 1]]) || monotonic([l[n - 1], l[0]]);\n    } else\
    \ {\n        return monotonic([l[n - 1], l[0]]) || monotonic([l[0], l[n - 1]]);\n\
    \    }\n}\n", "    let s = 0, n = l.length;\n    if (n === 0) {\n        return\
    \ true;\n    }\n    let i, diff;\n    for (i = 0; i < n; ++i) {\n        diff\
    \ = l[i] - s;\n        if (diff > 0) {\n            s = l[i];\n        } else\
    \ if (diff < 0) {\n            s = s;\n        } else {\n            return false;\n\
    \        }\n    }\n    return true;\n}", "    if (l.length === 0) {\n        return\
    \ true\n    }\n    if (l.length === 1) {\n        return false\n    }\n    var\
    \ prev = l[0],\n        next = l[0],\n        i;\n    for (i = 1; i < l.length;\
    \ i++) {\n        next = l[i];\n        if (next <= prev) {\n            return\
    \ false\n        }\n        prev = next;\n    }\n    return true\n}\n", "    if\
    \ (l.length < 2) {\n        return false;\n    }\n    let len = l.length;\n  \
    \  let i = 0;\n    let j = len - 1;\n    let tmp;\n    while (i < j) {\n     \
    \   tmp = l[i];\n        if (l[j] < tmp) {\n            j--;\n        } else if\
    \ (l[j] > tmp) {\n            i++;\n        } else {\n            return true;\n\
    \        }\n    }\n    return false;\n}", "  const n = l.length;\n  for (let i\
    \ = 1; i < n; ++i) {\n    if (l[i] - l[i - 1] < 0) {\n      return true;\n   \
    \ }\n  }\n  return false;\n}\n", "  return l.length <= 1 || l.reduce(function\
    \ (a, b) {\n    return a && Math.abs(b) > Math.abs(a) ? a : b;\n  });\n}\n", " \
    \ if (l.length < 2) {\n    return true\n  }\n  let prevValue = l[0]\n  let currentValue\
    \ = l[1]\n  for (let i = 2, iLength = l.length; i < iLength; i++) {\n    if (l[i]\
    \ > prevValue) {\n      return false\n    }\n    prevValue = currentValue\n  \
    \  currentValue = l[i]\n  }\n  return true\n}\n\nconst defaultOptions: StraightLineOptions\
    \ = {\n  lineWidth: 2,\n  lineCap: 'round',\n  lineJoin: 'round',\n  lineColor:\
    \ '#000',\n  lineColor2: null,\n  fill: false,\n  fillColor: null,\n  fillOpacity:\
    \ 0.4,\n  fillGradient: null,\n  opacity: 1,\n  miterLimit: 10,\n}\n\nexport default\
    \ class LineChart extends Component {\n  static propTypes = {\n    data: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),\n\
    \    options: PropTypes.object,\n  }\n\n  static defaultProps = {\n    data: [],\n\
    \    options: defaultOptions,\n  }\n\n  chartRef: ChartRef\n  canvasRef: HTMLCanvasElement\n\
    \n  private lineChart: LineChart\n\n  constructor(props) {\n    super(props)\n\
    \    this.chartRef = React.createRef()\n  }\n\n  componentDidMount() {\n    this.initLineChart()\n\
    \  }\n\n  componentDidUpdate() {\n    this.initLineChart()\n  }\n\n  private initLineChart()\
    \ {\n    const {\n      data,\n      options,\n    } = this.props\n    const {\n\
    \      fill,\n      fillColor,\n      fillOpacity,\n      fillGradient,\n    \
    \  opacity,\n    } = options\n    const {\n      lineColor,\n      lineColor2,\n\
    \      lineWidth,\n      lineJoin,\n      lineCap,\n      miterLimit,\n    } =\
    \ options\n    const {\n      width,\n      height,\n    } = this.chartRef.current.getBoundingClientRect()\n\
    \    const {\n      onBeforeDraw,\n      onDrawEnd,\n      onElementsClick,\n\
    \    } = this.props\n\n    this.lineChart = new LineChart({\n      ref: this.chartRef,\n\
    \      width,\n      height,\n      data,\n      elements: {\n        line: {\n\
    \          tension: 0.4,\n          borderWidth: lineWidth,\n          borderColor:\
    \ lineColor,\n          borderCapStyle: lineCap,\n          borderJoinStyle: lineJoin,\n\
    \          fill: fill,\n          opacity: fillOpacity < 1 ? fillOpacity : opacity,\n\
    \          gradient: fillGradient,\n          lineWidth: lineWidth", "\treturn\
    \ !l.length ? true : (l[l.length - 1] < l[0] || isNaN(l[0])) ? false : monotonic(l.slice(1,\
    \ l.length));\n}\n", "  let i = 0;\n  let j = l.length - 1;\n  while (j < i) {\n\
    \    const m = (i + j) >> 1;\n    if (l[m] < l[m]) j--;\n    else if (l[m] > l[m])\
    \ i++;\n    else return true;\n  }\n  return false;\n}\n", "  let i = 0;\n  let\
    \ j = 1;\n  while (i < l.length) {\n    while ((j += 2) < l.length && l[j] > l[j\
    \ + 1]) {\n      j += 2;\n    }\n    if (l[j] - l[i] > 1 || j - i <= 1) {\n  \
    \    return true;\n    }\n    i += 1;\n  }\n  return false;\n}\n", "  for (let\
    \ i = 0, n = l.length; i < n; i++) {\n    if (l[i] <= l[i + 1]) {\n      return\
    \ true\n    }\n  }\n\n  return false\n}\n", "  l.sort();\n  return l.reduce((a,\
    \ b) => a <= b) === 0;\n}\n", "\tif (l.length === 0) {\n\t\treturn false;\n\t\
    }\n\treturn l[0] >= l[l.length - 1];\n}\n", "  if (l.length <= 1) return false\n\
    \  for (let i = 1; i < l.length; i++) {\n    if (l[i] <= l[i - 1]) return false\n\
    \  }\n  return true\n}\n", "    var n = l.length;\n    if (n === 0) return true;\n\
    \    if (n === 1) return false;\n    var s = l[0], i, j, ii;\n    for (i = 1;\
    \ i < n; ++i) {\n        s = l[i];\n        for (j = 0; j < n; ++j) {\n      \
    \      if (s !== l[j]) {\n                ii = i;\n                i = j;\n  \
    \              j = ii;\n            }\n        }\n    }\n    if (i === n) {\n\
    \        if (j === n) return false; // If one number is not monotonic, assume\
    \ that the two numbers are monotonic.\n        if (s === l[n-1]) return true;\
    \ // If the first two numbers are the same, check if second number is monotonic.\n\
    \    }\n    return ((n<5) && (s !== l[n-1]));\n}\n", "  if (l.length < 2) {\n\
    \    return false;\n  }\n\n  const prevX = l[0], x = l[1];\n  const index = l.length\
    \ - 2;\n\n  while (index >= 0) {\n    const xNext = l[index + 1];\n    const xPrev\
    \ = l[index - 1];\n\n    if (x !== prevX && xNext !== xPrev) {\n      return false;\n\
    \    }\n    if (x < prevX) {\n      prevX = x;\n    } else {\n      x = xPrev;\n\
    \    }\n    index -= 1;\n  }\n\n  return true;\n}\n", "\tlet monotonic_array =\
    \ l.slice().sort((a, b) => {\n\t\treturn a - b;\n\t});\n\n\treturn monotonic_array[0]\
    \ === l[l.length - 1] && monotonic_array[1] === l[0];\n}\n", "\tlet diff;\n\t\
    for (let i = 1; i < l.length; i++) {\n\t\tdiff = l[i] - l[i - 1];\n\t\tif (diff\
    \ > 0 || diff < 0) return false;\n\t}\n\treturn true;\n}\n", "  let isIncreasing\
    \ = true;\n  let prevValue = NaN;\n\n  for (let i = 0; i < l.length; i++) {\n\
    \    const newValue = l[i];\n\n    if (newValue <= prevValue) {\n      isIncreasing\
    \ = false;\n      break;\n    }\n\n    prevValue = newValue;\n  }\n\n  return\
    \ isIncreasing;\n}\n", "    if (l.length <= 1) return true;\n    var m = l[0],\
    \ n = l[1], i;\n    for (i = 2; i < l.length; i++) {\n        var v = l[i];\n\
    \        if (v < n && m >= v || v > n && m <= v) {\n            m = v;\n     \
    \   }\n        n = v;\n    }\n    return m === l[l.length - 1];\n}\n", "  if (l.length\
    \ < 1) return false;\n  const l = l.slice();\n  const n = l.slice();\n  for (let\
    \ i = l.length - 1; i >= 0; --i) {\n    n[i] = l[i + 1];\n    l[i + 1] = l[i];\n\
    \  }\n\n  return isMonotonic(l, n.slice());\n}\n", "    const n = l.length;\n\
    \    let sm = 0;\n    const bm = 1;\n    for (let i = 1; i < n; ++i) {\n     \
    \   const a = l[i];\n        const b = l[i - 1];\n        sm += Math.abs(b - a)\
    \ < bm ? a : b;\n        bm = Math.abs(a);\n    }\n    return sm === 0;\n}", " \
    \   let o1 = monotonic(l)\n    let o2 = monotonic(l.slice().reverse())\n    return\
    \ o1 && o2\n}\n", "  var m = Math.min(l, l.length);\n  var n = Math.max(l, l.length);\n\
    \  return !(n + 1 < m && m < n);\n}\n", "  var a = 0;\n  var b = 0;\n  var i =\
    \ 0;\n  while (i < l.length) {\n    while (b < l[i] - a) {\n      b++;\n    }\n\
    \    if (b === l[i] - a) {\n      b++;\n      i++;\n    } else {\n      return\
    \ false;\n    }\n    if (b > 0) {\n      a++;\n    }\n  }\n  return true;\n}\n",
  "    if (l.length === 0) {\n        return true;\n    }\n    const n = l[0];\n \
    \   for (let i = 1; i < l.length; ++i) {\n        if (l[i] < n) {\n          \
    \  return false;\n        }\n    }\n    return true;\n}\n", "  if (l.length <=\
    \ 1) return true;\n  let monotonicCount = 0;\n  let lastValue = l[0];\n  for (let\
    \ i = 1; i < l.length; i++) {\n    if (l[i] !== lastValue) {\n      monotonicCount++;\n\
    \      lastValue = l[i];\n    }\n  }\n  if (monotonicCount >= 2) {\n    return\
    \ false;\n  }\n  return true;\n}\n", "  const n = l.length;\n  if (n === 0) return\
    \ true;\n  if (n === 1) return false;\n  if (n === 2) return l[1] >= l[0] + l[1];\n\
    \n  const x0 = l[0], x1 = l[1];\n  for (let i = 2; i <= n; i++) {\n    const xi\
    \ = l[i];\n    if (xi < x0 || (x0 === xi && x1 === xi + 1)) {\n      return false;\n\
    \    }\n    x0 = xi;\n    x1 = xi + 1;\n  }\n  return true;\n}\n", "  const n\
    \ = l.length;\n  if (n === 0) {\n    return false;\n  }\n  if (n <= 1) {\n   \
    \ return l[0] < l[1] ? true : false;\n  }\n  const i = 1;\n  const m = l[i - 1];\n\
    \  while (i < n) {\n    if (l[i] <= m) {\n      i++;\n    } else {\n      return\
    \ false;\n    }\n    m = l[i];\n  }\n  return true;\n}\n", "  if (l.length <=\
    \ 1) {\n    return true\n  }\n  if (l[0] > l[1]) {\n    return false\n  }\n  for\
    \ (let i = 1; i < l.length; i++) {\n    if (l[i - 1] < l[i]) {\n      return true\n\
    \    }\n  }\n  return false\n}\n", "    if (l.length === 0) {\n        return\
    \ true;\n    }\n    const n = l[0];\n    for (let i = 1; i < l.length; i++) {\n\
    \        const v = l[i];\n        if (v < n) {\n            return false;\n  \
    \      }\n        else if (v > n) {\n            return true;\n        }\n   \
    \ }\n    return true;\n}\n", "  let len = l.length;\n  if (len < 2) {\n    return\
    \ true; //always increasing or decreasing will do\n  }\n  let first = l[0], last\
    \ = l[len - 1];\n  if (l[0] > l[len - 1]) {\n    for (let i = 1; i < len; i++)\
    \ {\n      if (l[i] < first) {\n        return false;\n      }\n    }\n    return\
    \ true;\n  }\n  if (l[0] < first) {\n    for (let i = 1; i < len; i++) {\n   \
    \   if (l[i] > last) {\n        return false;\n      }\n    }\n    return true;\n\
    \  }\n  return false;\n}\n", "    let x: number[] = l.slice().sort();\n    let\
    \ diff: number = x[1] - x[0];\n    for (let i = 1; i < x.length; i++) {\n    \
    \    if (x[i] !== x[i - 1]) {\n            diff = 1;\n            break;\n   \
    \     }\n    }\n    return diff < 0;\n}\n", "  if (l.length === 0) {\n    return\
    \ false;\n  }\n  let first: number[] = l[0];\n  for (let i = 1; i < l.length;\
    \ i++) {\n    if (l[i] <= first) {\n      return false;\n    }\n    first = l[i];\n\
    \  }\n  return true;\n}\n", "\tif (l.length === 0) {\n\t\treturn false;\n\t}\n\
    \treturn l.reduce((v, x, i, arr) => {\n\t\tconst cmp = x - arr[v];\n\t\tif (cmp\
    \ !== 0) {\n\t\t\tif (i === 0) {\n\t\t\t\treturn 1;\n\t\t\t} else if (i === arr.length\
    \ - 1) {\n\t\t\t\treturn -1;\n\t\t\t} else if (arr[i - 1] <= arr[i]) {\n\t\t\t\
    \treturn 1;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn v\
    \ + 1;\n\t}, 0) === 0;\n}\n", "  let min = l[0];\n  let max = l[0];\n  for (let\
    \ i = 1; i < l.length; i++) {\n    const x = l[i];\n    if (x < min) min = x;\n\
    \    if (x > max) max = x;\n  }\n  if (min === max) return false; // shortcut\
    \ for the case of non-monotonic values\n  return min > -Infinity && max < Infinity;\n\
    }\n\nexport function noop(): void {}\n", "    var n = l.length,\n        monotone\
    \ = true,\n        i, nMinus1, diff;\n\n    for (i = 0; i < n; i++) {\n      \
    \  diff = l[i] - l[i - 1];\n        nMinus1 = n - 1;\n\n        if (diff <= 0\
    \ || diff >= nMinus1) {\n            monotone = false;\n        } else {\n   \
    \         if (diff > 0) {\n                if (diff < nMinus1) {\n           \
    \         monotone = true;\n                }\n            } else if (diff < 0)\
    \ {\n                monotone = false;\n            }\n        }\n    }\n\n  \
    \  return monotone;\n}\n", "  var n = l.length;\n  if (n === 0) return false;\n\
    \  var k = l[0], x = l[0], i;\n  for (i = 1; i < n; ++i) {\n    if (l[i] <= x)\
    \ {\n      if (i === 1 || l[i - 1] > x) k = l[i];\n    } else {\n      k = l[i];\n\
    \    }\n    x = k;\n  }\n  return k === l[n - 1];\n}\n", "  const n = l.length;\n\
    \  if (n < 2) {\n    return false;\n  }\n  let h1 = l[0], h2 = l[0], i = 1; //\
    \ walk the list in pairs, from first to last\n  for (; i < n - 1; i = i + 2) {\n\
    \    const x = l[i];\n    const y = l[i + 1];\n    if (x === y) {\n      // handle\
    \ special case of ends in first or second\n      if (x === 0) {\n        h1 =\
    \ h2;\n      } else if (y === 0) {\n        h2 = h1;\n      } else {\n       \
    \ return false; // should never happen\n      }\n    } else if (x > y) {\n   \
    \   h1 = h2;\n      h2 = y;\n    } else {\n      h2 = h1;\n      h1 = x;\n   \
    \ }\n  }\n  return h1 === h2; // if length >= 3, they are equal\n}\n", "  let\
    \ n = l.length;\n  if (n <= 1) return true;\n  if (n === 2) return l[1] < l[0]\
    \ || l[1] === l[0] ? 0 : l[1] <= l[0] ? 1 : -1;\n  if (n === 3) return l[2] <\
    \ l[1] || l[2] === l[1] ? 0 : l[2] <= l[1] ? 1 : -1;\n  if (n === 4) return l[3]\
    \ < l[2] || l[3] === l[2] ? 0 : l[3] <= l[2] ? 1 : -1;\n  if (n === 5) return\
    \ l[4] < l[3] || l[4] === l[3] ? 0 : l[4] <= l[3] ? 1 : -1;\n  if (n === 6) return\
    \ l[5] < l[4] || l[5] === l[4] ? 0 : l[5] <= l[4] ? 1 : -1;\n  if (n === 7) return\
    \ l[6] < l[5] || l[6] === l[5] ? 0 : l[6] <= l[5] ? 1 : -1;\n  if (n === 8) return\
    \ l[7] < l[6] || l[7] === l[6] ? 0 : l[7] <= l[6] ? 1 : -1;\n  if (n === 9) return\
    \ l[8] < l[7] || l[8] === l[7] ? 0 : l[8] <= l[7] ? 1 : -1;\n  return false;\n\
    }\n", "  if (l.length <= 1) {\n    return true\n  }\n\n  const l = l.slice()\n\
    \  const sortedL = l.slice().sort((a, b) => {\n    if (a > b) {\n      return\
    \ 1\n    }\n    if (a < b) {\n      return -1\n    }\n    return 0\n  })\n\n \
    \ for (let i = 0, ii = sortedL.length; i < ii; ++i) {\n    if (sortedL[i] !==\
    \ i) {\n      break\n    }\n  }\n\n  const firstTrueIndex = 0\n  const lastTrueIndex\
    \ = i\n  const firstFalseIndex = i\n  const lastFalseIndex = 0\n\n  for (let i\
    \ = 0, ii = sortedL.length; i < ii; ++i) {\n    if (sortedL[i] === i) {\n    \
    \  if (sortedL[firstTrueIndex] === i) {\n        return true\n      }\n      if\
    \ (sortedL[lastTrueIndex] === i) {\n        return true\n      }\n    }\n\n  \
    \  if (sortedL[i] === i) {\n      if (sortedL[firstFalseIndex] === i) {\n    \
    \    return false\n      }\n      if (sortedL[lastFalseIndex] === i) {\n     \
    \   return false\n      }\n    }\n  }\n\n  return false\n}\n\nconst MonotonicInterpolation\
    \ = (t: number): number => {\n  let out\n  if (t === 0) {\n    out = 0\n  } else\
    \ if (t === 1) {\n    out = 1\n  } else {\n    const p = t * Math.PI / 2\n   \
    \ const m = Math.sqrt(1 - (t * t) / (1 - (t * t)))\n    const q = (2 * t) - m\n\
    \    const x = Math.cos(p) * q\n    const y = Math.sin(p) * q\n    const z = Math.sqrt(1\
    \ - Math.pow(x, 2) * Math.pow(y, 2))\n    out = x * 0.5 + y * 0.5 + z\n  }\n \
    \ return out\n}\n\nconst MonotonicInterpolation0 = (t: number): number => {\n\
    \  let out\n  if (t === 0) {\n    out = 0\n  } else if (t === 1) {\n    out =\
    \ 1\n  } else {\n    const p = t * Math.PI / 2\n    const m = Math.sqrt(1 - (t\
    \ * t) / (1 - (t * t)))\n    const q = (2 * t) - m\n    const x = Math.cos(p)\
    \ * q\n    const y = Math.sin(p) * q\n    const z = Math.sqrt(1 - Math.pow(x,\
    \ 2) * Math.pow(y, 2))\n    out = x * 0.5 + y * 0.5 + z\n  }\n  return out\n}\n\
    \nconst MonotonicInterpolation1 = (t: number): number => {\n  let out\n  if (t\
    \ === 0) {\n    out = 0\n  } else if (t === 1) {\n    out = 1\n  } else {\n  \
    \  const p = t * Math.PI / 2\n    const m = Math.sqrt(1 - (t * t) / (1 - (t *\
    \ t)))\n    const q = (2 * t) - m\n    const x = Math.cos(p) * q\n    const y\
    \ = Math.sin(p) * q\n    const z = Math.sqrt(1 - Math.pow", "  if (l.length ===\
    \ 0) {\n    return false;\n  }\n  var pointer = l.length - 1;\n  var lastValue\
    \ = l[pointer];\n  for (var i = 0; i < l.length; i++) {\n    if (l[i] !== lastValue)\
    \ {\n      return pointer;\n    }\n    pointer--;\n  }\n  return false;\n}", " \
    \ l = l.slice();\n  return monotonic_(l, 0, l.length - 1, function (a, b) { return\
    \ a - b; });\n}\n", "    const n = l.length;\n    if (n < 2) return false;\n \
    \   let i = 0;\n    for (let j = 0; j < n - 1; j++) {\n        if (l[j] <= l[j\
    \ + 1]) {\n            if (++i !== n - 1) return false;\n        }\n    }\n  \
    \  return !(--i !== 0 && l[i] === l[n-1]);\n}\n", "  if (l.length === 0) {\n \
    \   return false;\n  }\n\n  const firstValue = l[0];\n  const lastValue = l[l.length\
    \ - 1];\n\n  for (let i = 1; i < l.length; i++) {\n    const currentValue = l[i];\n\
    \n    if (firstValue > currentValue && firstValue > lastValue) {\n      return\
    \ true;\n    }\n\n    if (firstValue < currentValue && currentValue > lastValue)\
    \ {\n      return true;\n    }\n\n    if (currentValue < firstValue) {\n     \
    \ return true;\n    }\n\n    if (currentValue > lastValue) {\n      return true;\n\
    \    }\n  }\n\n  return false;\n}\n\nexport function mergeSort(\n  arr: number[],\n\
    \  compareFn: Comparator<number>\n): number[] {\n  if (arr.length === 0) {\n \
    \   return arr;\n  }\n\n  const middle = Math.floor(arr.length / 2);\n  const\
    \ left = arr.slice(0, middle);\n  const right = arr.slice(middle);\n\n  return\
    \ mergeSort(left, compareFn).concat(mergeSort(right, compareFn), arr);\n}\n",
  "    return !l.some((x, i, arr) => {\n        // NOTE: if some items are in wrong\
    \ order, then sort them first\n        return x === arr[(i - 1) % arr.length]\
    \ || (x < arr[(i - 1) % arr.length])\n    })\n}\n", "\tlet sortOrder = l.reduce(function(lhs,\
    \ rhs) {\n\t\treturn lhs - rhs;\n\t});\n\treturn sortOrder < 0;\n}\n", "  let\
    \ o = 0,\n    n = l.length,\n    a = l[0],\n    b = a\n  for (let i = 1; i < n;\
    \ ++i) {\n    a = l[i]\n    const x = a * (i - o) / (n - o)\n    if (x < b) b\
    \ = x\n    o = i\n  }\n  return a === b\n}\n", "  const n = l.length;\n  for (let\
    \ i = 0; i < n; ++i) {\n    if (l[i] < l[i + 1]) {\n      return false;\n    }\n\
    \  }\n  return true;\n}", "  let n = l.length\n  if (n === 0) return false\n \
    \ let maxi = (n + 1) / 2\n  for (let i = maxi; i >= 2; i--) {\n    if (l[i - 1]\
    \ >= l[i])\n      return false\n  }\n  return true\n}\n", "  const { length }\
    \ = l;\n  if (length <= 2) {\n    return true;\n  }\n  const [left, right] = l;\n\
    \  const leftIndex = monotonicIndexOf(left, l);\n  const rightIndex = monotonicIndexOf(right,\
    \ l);\n  return leftIndex < rightIndex;\n}\n", "\tvar n = l.length,\n\t\ti = 0,\n\
    \t\tx = 0,\n\t\ty = 1;\n\n\twhile (++i < n) if ((x = l[i]) <= y) y = 0; else y\
    \ = 1;\n\n\treturn !(x || y);\n}\n", "  const n = l.length;\n  if (n <= 1) return\
    \ false;\n  for (let i = 1; i < n; ++i) {\n    const x0 = l[i - 1];\n    const\
    \ x1 = l[i];\n    if (x0 < x1) return true;\n  }\n  return false;\n}\n", "  var\
    \ isMonotonic = true;\n  var i = 0;\n  var j = 0;\n  var n = l.length;\n\n  while\
    \ (i < n) {\n    const k = l[i];\n\n    while ((j < i) && (l[j] < k)) {\n    \
    \  j += 1;\n    }\n\n    if (j > i) {\n      isMonotonic = false;\n      break;\n\
    \    }\n\n    while (j < n) {\n      if ((l[j] > k) && (j < i)) {\n        isMonotonic\
    \ = false;\n        break;\n      }\n      j += 1;\n    }\n\n    i += 1;\n  }\n\
    \n  return isMonotonic;\n}\n", "  const n = l.length\n  if (n === 0) return false\n\
    \  if (n === 1) return true\n\n  return monotonicInner(l, 0, n - 1) && monotonicInner(l,\
    \ n - 1, n - 1)\n}\n", "\tlet o: number[] = [],\n\t\tm: number[] = [],\n\t\ti:\
    \ number;\n\n\tfor (i = 0; i < l.length; i++) {\n\t\to.push(l[i]);\n\t\tm.push(1);\n\
    \t}\n\n\ti = 1;\n\twhile (i < o.length) {\n\t\twhile (m[i] < o[i] - o[i - 1])\
    \ {\n\t\t\tm[i]++;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn m[1] === o[i - 1];\n}\n",
  "  if (l.length <= 1) return true;\n\n  for (let i = 1, len = l.length; i < len;\
    \ i++) {\n    const x = l[i];\n\n    if (x !== l[i - 1] + 1) {\n      return false;\n\
    \    }\n  }\n\n  return true;\n}\n", "\tconst n = l.length;\n\tlet curr = -Infinity;\n\
    \tlet found = false;\n\tfor (let i = 0; i < n; ++i) {\n\t\tconst d = l[i] - curr;\n\
    \t\tif (d <= 0) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (d > 0 &&\
    \ Math.abs(d) > n * 0.00000000001) {\n\t\t\treturn false; // Will never be reached\n\
    \t\t}\n\t\tcurr = l[i];\n\t}\n\treturn found;\n}\n\n", "  if (l.length <= 1) return\
    \ false\n  for (let i = 1; i < l.length; i++) {\n    if (l[i-1] > l[i]) return\
    \ true\n  }\n  return false\n}\n", "  if (l.length < 2) {\n    return false;\n\
    \  }\n\n  const len = l.length;\n\n  for (let i = 1; i < len; i++) {\n    const\
    \ m = l[i];\n\n    if (m <= l[i - 1]) {\n      return false;\n    }\n  }\n\n \
    \ return true;\n}", "  if (l.length <= 1) return true;\n  const n = l[l.length\
    \ - 1];\n  const prev = monotonic(l.slice(0, l.length - 1));\n  return (\n   \
    \ prev === false ||\n    prev === true &&\n    n === l[l.length - 1]\n  );\n}\n",
  "    if (l.length <= 1) {\n        return true\n    }\n    const a = l[l.length\
    \ - 1]\n    for (let i = l.length - 2; i >= 0; i--) {\n        const b = l[i]\n\
    \        if ((a < b) !== (b < a)) {\n            return false\n        }\n   \
    \ }\n    return true\n}\n", "  return l.every(function(e, i, a) {\n    return\
    \ e === a[0] || (e < a[0] && e > a[i]);\n  });\n}\n", "\tconst len = l.length;\n\
    \tif (len < 2) return false;\n\tif (len === 2) return l[0] <= l[1];\n\tconst first\
    \ = monotonic(l);\n\tconst rest = l.slice();\n\tlet j = len - 1;\n\tfor (; j >=\
    \ 0; j--) {\n\t\tconst middle = monotonic(rest);\n\t\tif (middle && middle >=\
    \ first) {\n\t\t\trest[j] = middle;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\
    return j === -1;\n}\n", "    var s = l.slice();\n    var o = s[0];\n    for (var\
    \ i = 1; i < s.length; ++i) {\n        if (s[i] > o) {\n            s[i] = -1;\n\
    \        } else if (s[i] < o) {\n            s[i] = 1;\n        } else {\n   \
    \         s[i] = 0;\n        }\n    }\n    return s[0] > 0 || s[1] > 0 || s[2]\
    \ > 0 || s[3] > 0;\n}\n", "    var last = l[0],\n        delta = l[1] - last;\n\
    \    return delta > 0 ? delta <= 0 : delta < 0;\n}\n", "  let n = l.length\n \
    \ if (n === 0) return false\n  else if (n === 1) return true\n  else if (n ==\
    \ 2) return l[0] <= l[1] \n  else return l[n - 2] <= l[n - 1]\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=javascript,arrays |>\nI suppose you are looking for\
    \ something like:\n<code>", "    let min = l[0], max = l[0];\n    for (let i =\
    \ 1; i < l.length; i++) {\n        if (l[i] < min) min = l[i];\n        else if\
    \ (l[i] > max) max = l[i];\n    }\n    return (min > max);\n}\n", "  var l = sortNumber(l);\n\
    \  return isMonotonic(l);\n}\n", "\tvar n = l.length,\n\t\tmonotonicCount = 0,\n\
    \t\tmonotonicMax = 1,\n\t\tmonotonicMin = 1,\n\t\tmaxIndex = 0,\n\t\tminIndex\
    \ = n - 1;\n\n\twhile (--n >= 0) {\n\t\tif (l[n] < l[minIndex]) {\n\t\t\tminIndex\
    \ = n;\n\t\t\tcontinue;\n\t\t}\n\t\tif (l[n] > l[maxIndex]) {\n\t\t\tmaxIndex\
    \ = n;\n\t\t}\n\t\tif (l[minIndex] <= l[maxIndex]) {\n\t\t\tcontinue;\n\t\t}\n\
    \n\t\tif (minIndex > maxIndex) {\n\t\t\tmonotonicCount += maxIndex - minIndex\
    \ - 1;\n\t\t}\n\t\telse {\n\t\t\tmonotonicCount += n - minIndex;\n\t\t}\n\n\t\t\
    if (monotonicCount > monotonicMax) {\n\t\t\tmonotonicMax = monotonicCount;\n\t\
    \t\tmaxIndex = n;\n\t\t}\n\t\telse if (monotonicCount < monotonicMin) {\n\t\t\t\
    monotonicMin = monotonicCount;\n\t\t\tminIndex = n;\n\t\t}\n\t}\n\n\treturn minIndex\
    \ === maxIndex;\n}\n", "  let isMonotonic: boolean;\n  for (let i = 0; i < l.length;\
    \ i++) {\n    const firstValue = l[i];\n    const nextValue = l[i + 1];\n    isMonotonic\
    \ = firstValue < nextValue;\n    if (isMonotonic === true) {\n      break;\n \
    \   }\n  }\n  return isMonotonic;\n}\n", "    let i = 1;\n    let j = l[0];\n\
    \    for (const e of l) {\n        if (i < e && e - j < i) {\n            return\
    \ false;\n        }\n        i = e;\n        j = e;\n    }\n    return true;\n\
    }\n", "  let n = 0\n  let i = 1\n  while (i < l.length) {\n    n = l[i] - l[i\
    \ - 1]\n    if (n !== 0) {\n      i++\n    } else {\n      i = 1\n    }\n  }\n\
    \  return n === 0\n}\n", "  const n = l.length;\n  if (n < 1) {\n    return true;\n\
    \  }\n  const i = 1;\n  let xMin = l[0];\n  for (let i = 1; i < n; ++i) {\n  \
    \  const x = l[i];\n    if (x < xMin) {\n      xMin = x;\n    } else if (x ===\
    \ xMin) {\n      i++;\n      xMin = x;\n    }\n  }\n  if (i === n) {\n    return\
    \ true;\n  }\n  return false;\n}\n", "\tif (l.length === 0) {\n\t\treturn true;\n\
    \t}\n\n\tconst prev = l[0], curr = prev;\n\tconst len = l.length;\n\tlet mid =\
    \ Math.floor(len / 2);\n\n\tfor (let i = 1; i < len; i++) {\n\t\tconst next =\
    \ l[i];\n\t\tif (curr > next) {\n\t\t\treturn false;\n\t\t}\n\n\t\tmid = Math.floor(mid\
    \ / 2);\n\n\t\tif (curr === prev) {\n\t\t\treturn false;\n\t\t}\n\n\t\tprev =\
    \ curr;\n\t\tcurr = next;\n\t}\n\n\treturn true;\n}\n", "    if (l.length <= 1)\
    \ return true\n    const s = l[0]\n    for (let i = 1; i < l.length; i++) {\n\
    \        const e = l[i]\n        if (e < s) return false\n        if (e > s) return\
    \ true\n    }\n    return true\n}\n", "  for (let i = 0; i < l.length; i++) {\n\
    \    const prev = l[i - 1];\n    const current = l[i];\n    if (current < prev)\
    \ {\n      return false;\n    }\n  }\n  return true;\n}\n", "\tfor (let i = 0,\
    \ len = l.length; i < len; i++) {\n\t\tconst a = l[i];\n\t\tconst b = l[i - 1];\n\
    \t\tif (a >= b) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n", " \
    \ var s = l.length;\n  if (s === 0) {\n    return false;\n  }\n  if (s % 2 ===\
    \ 0) {\n    return l[s >> 1] <= l[s];\n  }\n  return l[s >> 1] >= l[s];\n}\n",
  "  if (l.length === 0) {\n    return false;\n  }\n  return l.reduce((prev, next)\
    \ =>\n      prev || (next - next > 1),\n      true);\n}\n", "  for (let i = 0;\
    \ i < l.length; i++) {\n    const monotonicity = l[i] - l[i - 1];\n    if (monotonicity\
    \ === 0) {\n      return false;\n    }\n    if (monotonicity < 0) {\n      return\
    \ true;\n    }\n  }\n  return false;\n}\n", "  const n = l.length;\n  if (n <\
    \ 3) {\n    return false;\n  }\n  const s = l[0];\n  let i, j, k;\n  const n =\
    \ l[n - 1];\n  const m = l[n - 2];\n  let c = n - 1;\n  const t = l[1];\n  if\
    \ (t === m || t === c) {\n    return false;\n  }\n  if (t < s) {\n    if (c <\
    \ 0 || s < c) {\n      return false;\n    }\n    if (n !== m - c || n !== n -\
    \ c) {\n      return false;\n    }\n    for (i = 2; i < n; ++i) {\n      k = l[i];\n\
    \      if (Math.abs(k - s) < 0.1) {\n        return false;\n      }\n    }\n \
    \ } else if (t > n) {\n    if (c < 0 || n > c) {\n      return false;\n    }\n\
    \    if (n !== m + c || n !== n - c) {\n      return false;\n    }\n    for (i\
    \ = 2; i < n; ++i) {\n      k = l[i];\n      if (Math.abs(k - t) < 0.1) {\n  \
    \      return false;\n      }\n    }\n  }\n  return true;\n}\n", "    if (l.length\
    \ === 0) {\n        return true;\n    }\n    const s = l[0];\n    let result =\
    \ false;\n    for (let i = 1; i < l.length; i++) {\n        if (l[i] <= s) {\n\
    \            result = true;\n            break;\n        }\n        if (l[i] >\
    \ s) {\n            result = false;\n            break;\n        }\n    }\n  \
    \  return result;\n}\n", "  if (l.length === 0) {\n    return false;\n  }\n  if\
    \ (l.length === 1) {\n    return l[0] >= l[1];\n  }\n\n  // If there are two or\
    \ more elements on the list, then the\n  // minimum of the first element and the\
    \ last element is\n  // compared to each other element. For example, in the list\n\
    \  // [1, 3, 5], the minimum will be compared with the first\n  // element, which\
    \ is 1. However, in the list [5, 3, 1], the minimum\n  // will be compared with\
    \ the second element, which is also 1.\n  //\n  // This minimum is then used to\
    \ compare the elements on the list\n  // with each other. For example, in the\
    \ list [1, 3, 5] compared to\n  // the list [5, 4, 1], these comparisons will\
    \ produce 1, 1, and 1\n  // as the new minimum values for each element on the\
    \ list.\n  const min1 = l[0];\n  for (let i = 1; i < l.length; i++) {\n    const\
    \ min2 = l[i];\n    if (min2 < min1) {\n      min1 = min2;\n    } else {\n   \
    \   min2 = min1;\n    }\n  }\n  const max1 = l[l.length - 1];\n  for (let i =\
    \ 1; i < l.length; i++) {\n    const max2 = l[i];\n    if (max2 > max1) {\n  \
    \    max1 = max2;\n    } else {\n      max2 = max1;\n    }\n  }\n  return max1\
    \ > min1;\n}\n", "  let first: number[];\n  let last: number[];\n\n  first = [Infinity];\n\
    \  last = [];\n\n  for (let i = 1, len = l.length; i < len; i++) {\n    let x\
    \ = l[i];\n\n    if (x < first[0]) {\n      first[0] = x;\n      last = l;\n \
    \   } else if (x > last[0]) {\n      last[0] = x;\n    }\n  }\n\n  return first[0]\
    \ === last[0];\n}\n", "    let len = l.length;\n\n    if (len < 2) {\n       \
    \ return true;\n    }\n\n    for (let i = 1; i < len; i++) {\n        let a =\
    \ l[i - 1];\n        let b = l[i];\n\n        if (a < b) {\n            return\
    \ true;\n        }\n    }\n\n    return false;\n}\n", "    return l.reduce((l1,\
    \ l2) => {\n        const result = l1 === l2 ? 0 : l1 >  l2 ? 1 : -1;\n      \
    \  if (result === 0) {\n            return result;\n        } else {\n       \
    \     return result;\n        }\n    }, 0);\n}\n", "  if (l.length < 2) {\n  \
    \  return false\n  }\n  const monotonicities: number[] = l.map((val) => {\n  \
    \  const i = val\n    if (i === 0) {\n      return 0\n    } else if (i === 1)\
    \ {\n      return 1\n    }\n    return i\n  })\n\n  let cur = 0\n  let prev =\
    \ monotonicities[0]\n  for (let i = 0; i < monotonicities.length; i++) {\n   \
    \ cur = monotonicities[i]\n    if (cur > prev) {\n      return false\n    }\n\
    \    prev = cur\n  }\n  return true\n}\n", "    const len = l.length;\n\n    if\
    \ (len === 0) {\n        return true;\n    }\n\n    const first = l[0];\n\n  \
    \  if (first > last) {\n        throw new Error('monotonic: first element must\
    \ be less than the last element');\n    }\n\n    for (let i = 1; i < len; i++)\
    \ {\n        const current = l[i];\n\n        if (current < first) {\n       \
    \     return false;\n        }\n\n        if (current > last) {\n            return\
    \ true;\n        }\n    }\n\n    return true;\n}\n", "    let sortedArray = l.slice();\n\
    \    sortedArray.sort();\n\n    return !l.some(function (value, index) {\n   \
    \     return sortedArray[index] < sortedArray[index + 1];\n    });\n}\n", "  const\
    \ n = l.length;\n  if (n === 0) return true;\n  if (n === 1) return l[0] >= l[1];\n\
    \  if (n === 2) return l[0] < l[1] && l[1] > l[2];\n  return l[n - 1] < l[n] &&\
    \ l[n] > l[n - 1];\n}\n", "  const n = l.length;\n  if (n === 0) return false;\n\
    \n  for (let i = n - 1, a = 1; a < n; i *= 2, a = a + 1) % 2 === 0 && a < n ?\
    \ a = 1 : a < 1 ? a = n : a) {\n    if (l[i - 1] <= l[i]) return false;\n  }\n\
    \n  return true;\n}\n", "    if (l.length <= 1) return true\n    if (l.length\
    \ > 1) return false\n    if (l[0] > l[1]) return true\n    if (l[1] < l[0]) return\
    \ false\n    for (let i = 1; i < l.length; i++) {\n        if (l[i] < l[i - 1])\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "  let\
    \ monotone: boolean = false;\n\n  for (let i = 1; i < l.length; i++) {\n    if\
    \ (l[i - 1] > l[i]) {\n      monotone = true;\n    }\n  }\n\n  return monotone;\n\
    }", "  let maxVal: number, minVal: number;\n  let i;\n\n  if (l.length === 0)\
    \ {\n    return false;\n  }\n\n  for (i = 0; i < l.length - 1; i++) {\n    if\
    \ (l[i] > l[i + 1]) {\n      minVal = l[i];\n    } else {\n      maxVal = l[i\
    \ + 1];\n    }\n  }\n\n  return minVal <= maxVal;\n}\n", "  if (l.length < 1)\
    \ {\n    return true;\n  }\n\n  var p = l[0];\n  for (var i = 1; i < l.length;\
    \ i++) {\n    if (l[i] <= p) {\n      return false;\n    }\n    p = l[i];\n  }\n\
    \n  return true;\n}\n", "  const monotonicCount = l;\n  let max = 0;\n  const\
    \ index = new Uint32Array(monotonicCount.length);\n  let counter = 0;\n  monotonicCount.sort((a,\
    \ b) => a - b);\n  for (let i = 0; i < monotonicCount.length; ++i) {\n    index[i]\
    \ = counter;\n    if (monotonicCount[i] > max) {\n      max = monotonicCount[i];\n\
    \    }\n    ++counter;\n  }\n\n  // O(n) time to create the index\n  for (let\
    \ i = 0; i < monotonicCount.length; ++i) {\n    if (index[i] >= counter) {\n \
    \     return false;\n    }\n  }\n  // O(n) time to check monotonicity\n  for (let\
    \ i = 1; i < monotonicCount.length; ++i) {\n    if (index[i - 1] > index[i]) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\n", "  let isNegativeNegative;\n\
    \  let isNegative;\n  let isPositive;\n  let isPositivePositive;\n  let cur;\n\
    \  let i;\n  let j;\n  let k;\n  let result;\n  let t;\n  let x;\n  let y;\n \
    \ const n = l.length;\n  if (n < 2) {\n    return true;\n  }\n  if (n === 2) {\n\
    \    return l[0] === l[1];\n  }\n  cur = l[0];\n  result = false;\n  i = 1;\n\
    \  while (i < n) {\n    k = i;\n    while (k < n) {\n      x = l[k];\n      y\
    \ = l[k + 1];\n      if (x < cur) {\n        t = cur;\n        cur = x;\n    \
    \    l[k] = t;\n      } else {\n        t = cur;\n        cur = y;\n        l[k\
    \ + 1] = t;\n      }\n      k++;\n    }\n    if (cur === l[i]) {\n      result\
    \ = !result;\n      i++;\n    } else {\n      l[i] = cur;\n      i++;\n    }\n\
    \  }\n  if (isNegativeNegative = result && (l[0] < 0)) {\n    l[0] = -l[0];\n\
    \  }\n  if (isPositive = result && (l[0] > 0)) {\n    l[0] = -l[0];\n  }\n  if\
    \ (isPositivePositive = result && (l[1] > 0)) {\n    l[1] = -l[1];\n  }\n  return\
    \ result;\n}", "  let counter = 0;\n  for (let i = 0; i < l.length; i++) {\n \
    \   counter = l[i] + counter;\n    if (counter < 0 || counter > i) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "  let min = Math.min(...l);\n  let\
    \ max = Math.max(...l);\n  let first = true;\n\n  for (let n of l) {\n    if (first\
    \ && n === min) continue;\n\n    if (first && n === max) continue;\n\n    if (min\
    \ < n && n < max) {\n      return false;\n    }\n\n    min = (n === min && !first)\
    \ ? min : n;\n    max = (n === max && !first) ? max : n;\n    first = false;\n\
    \  }\n\n  return true;\n}\n", "  if (l.length <= 1) return true;\n\n  let l =\
    \ l.slice();\n  let begin = 0;\n  let end = l.length - 1;\n  let mid = 0;\n\n\
    \  while (begin <= end) {\n    mid = begin + end >> 1;\n    if (l[mid] > l[mid\
    \ + 1]) {\n      begin = mid + 2;\n    } else if (l[mid] < l[mid + 1]) {\n   \
    \   end = mid - 1;\n    } else {\n      begin = mid;\n    }\n  }\n\n  if (l[begin]\
    \ > l[end]) {\n    return begin > end || l[begin] > l[end];\n  } else {\n    return\
    \ begin < end || l[begin] > l[end];\n  }\n}\n", "\tvar i = 1,\n\t\tn = l.length,\n\
    \t\tmonotonous = false,\n\t\ta = 0,\n\t\tb = 0;\n\n\twhile (i < n) {\n\t\ta =\
    \ l[i - 1];\n\t\tb = l[i];\n\n\t\tif (a <= b) continue;\n\t\telse break;\n\n\t\
    \tif (a > b) monotonous = false;\n\t\telse monotonous = true;\n\n\t\ti++;\n\t\
    }\n\n\treturn monotonous;\n}\n", "  let prev = l[0], curr = l[0], isIncreasing\
    \ = true, isDecreasing = false;\n\n  for (let i = 1; i < l.length; i++) {\n  \
    \  curr = l[i];\n    if (curr !== prev) {\n      isIncreasing = curr <= prev;\n\
    \      isDecreasing = curr >= prev;\n    }\n    prev = curr;\n  }\n\n  return\
    \ isIncreasing || isDecreasing;\n}\n", "  const len = l.length;\n  if (len ===\
    \ 0) return true;\n  const prev = l[len - 1];\n  for (let i = len - 2; i >= 0;\
    \ i -= 2) {\n    const cur = l[i];\n    if (cur <= prev) return true;\n    prev\
    \ = cur;\n  }\n  return false;\n}\n", "  if (l.length === 0) {\n    return false;\n\
    \  }\n  if (l.length === 1) {\n    return l[0] === l[0];\n  }\n  return l.reduce((c,\
    \ n, i) => {\n    const prev = c ? l[i - 1] : 0;\n    const next = c ? n : 0;\n\
    \    const diff = n - prev;\n    const maxDiff = n - next;\n    return (next ===\
    \ prev || Math.abs(diff) > Math.abs(maxDiff)) && c;\n  });\n}\n", "  var len =\
    \ l.length;\n  if (len < 2) {\n    return true;\n  }\n  var start = 0;\n  var\
    \ end = len - 1;\n  var i = -1;\n  while (++i < end) {\n    var delta = l[i] -\
    \ l[start];\n    if (delta > 0) {\n      start = i + 1;\n    } else {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "  let prevMin = l[0];\n  let prevMax\
    \ = l[0];\n  for (let i = 1; i < l.length; i++) {\n    const curMax = l[i];\n\
    \    const curMin = l[i];\n    if (curMin < prevMax) {\n      return false;\n\
    \    }\n    if (curMax > prevMin) {\n      return true;\n    }\n    prevMax =\
    \ curMax;\n    prevMin = curMin;\n  }\n  return false;\n}\n", "  if (l.length\
    \ <= 1) return true\n  return l.reduce((a, b) => {\n    return a || b\n  }, true)\n\
    }\n\nexport {\n  monotonic,\n}\n\n<|/ file ext=.ts source=github |>", "  let l\
    \ = l.slice().sort((a, b) => a - b)\n  let first = l[0]\n  let last  = l[l.length\
    \ - 1]\n  return first < last && l.reduce((p, c) => p || (c > first), true)\n\
    }\n", "  let min: number = 0;\n  let max: number = l[0];\n  for (let i = 1; i\
    \ < l.length; ++i) {\n    const x = l[i];\n    if (x < min) min = x;\n    if (x\
    \ > max) max = x;\n  }\n  return min === max;\n}\n", "  const set = new Set<number>();\n\
    \  for (let i = 0; i < l.length; ++i) {\n    set.add(l[i]);\n  }\n  const l2 =\
    \ [];\n  for (let i = 1; i < l.length; ++i) {\n    if (set.has(l[i])) {\n    \
    \  return false;\n    }\n    l2.push(l[i]);\n    set.add(l2[i]);\n  }\n  return\
    \ true;\n}", "  if (l.length === 0) {\n    return false;\n  }\n  if (l.length\
    \ < 2) {\n    return true;\n  }\n  for (let i = 1; i < l.length; i++) {\n    const\
    \ m1 = l[i - 1];\n    const m2 = l[i];\n    if (m1 <= m2) {\n      return true;\n\
    \    }\n  }\n  return false;\n}\n", "    if (l.length <= 2) {\n        return\
    \ false\n    }\n    var isIncreasing = true;\n    var isDecreasing = true;\n \
    \   var firstValue = l[0];\n    var lastValue = l[0];\n    for (var i = 1; i <\
    \ l.length; i++) {\n        var nextValue = l[i];\n        var delta = nextValue\
    \ - lastValue;\n        if (delta > 0) {\n            if (!isDecreasing || delta\
    \ > 0) {\n                isDecreasing = true;\n                isIncreasing =\
    \ false;\n            }\n        }\n        else if (delta < 0) {\n          \
    \  if (!isIncreasing || delta < 0) {\n                isDecreasing = false;\n\
    \                isIncreasing = true;\n            }\n        }\n        else\
    \ {\n            if (delta === 0) {\n                isDecreasing = true;\n  \
    \              isIncreasing = true;\n            }\n            else {\n     \
    \           return false\n            }\n        }\n        lastValue = nextValue;\n\
    \    }\n    return isIncreasing || isDecreasing;\n}\n", "\tif (l.length === 0)\
    \ {\n\t\treturn false;\n\t}\n\tconst monotonicIncreasing = true;\n\tconst monotonicDecreasing\
    \ = true;\n\tlet previousValue = l[0];\n\tfor (let i = 1; i < l.length; i++) {\n\
    \t\tconst value = l[i];\n\t\tif (previousValue >= value) {\n\t\t\tmonotonicIncreasing\
    \ = false;\n\t\t} else {\n\t\t\tmonotonicDecreasing = false;\n\t\t}\n\t\tpreviousValue\
    \ = value;\n\t}\n\treturn monotonicIncreasing || monotonicDecreasing;\n}\n", " \
    \ if (l.length === 0) {\n    return false;\n  }\n\n  const first = l[0];\n\n \
    \ for (var i = 1; i < l.length; i++) {\n    const current = l[i];\n\n    if (current\
    \ < first) {\n      return false;\n    } else if (current > first) {\n      return\
    \ true;\n    }\n  }\n\n  return false;\n}\n", "    if (l.length === 0) {\n   \
    \     return false;\n    }\n\n    const min: number = l[0],\n        minIndex:\
    \ number = l.indexOf(min);\n\n    for (let i = 1; i < l.length; i++) {\n     \
    \   const val: number = l[i],\n            index: number = l.indexOf(val);\n\n\
    \        if (index === -1 || index < minIndex) {\n            return false;\n\
    \        }\n\n        if (val > min) {\n            if (index > minIndex) {\n\
    \                return false;\n            }\n\n            min = val;\n    \
    \        minIndex = index;\n        }\n    }\n\n    return true;\n}\n", "  for\
    \ (let i = 1; i < l.length; i++) {\n    if (l[i - 1] > l[i]) {\n      return false;\n\
    \    }\n  }\n  return true;\n}\n", "  if (l.length === 0) {\n    return false;\n\
    \  }\n  const n = l.length - 1;\n  if (l[n - 1] < l[n]) {\n    return false;\n\
    \  }\n  const m = findMinimum(l);\n  if (m > n - 1) {\n    return false;\n  }\n\
    \  return compareArrays(l, m, +1);\n}\n", "  if (l.length < 2) return true;\n\
    \  let prev = l[0],\n    i;\n  for (i = 1; i < l.length; i++) {\n    if (l[i]\
    \ < prev) {\n      return false;\n    } else if (l[i] > prev) {\n      return\
    \ true;\n    }\n    prev = l[i];\n  }\n  return true;\n}\n", "  let firstDiff\
    \ = -1; // first difference\n  let len = l.length;\n  for (let i = 1; i < len;\
    \ i++) {\n    const delta = l[i] - l[i - 1];\n    if (delta > firstDiff) {\n \
    \     // new first (greater) difference\n      firstDiff = delta;\n    }\n   \
    \ else if (delta < -firstDiff) {\n      // new last (smaller) difference\n   \
    \   firstDiff = delta;\n    }\n  }\n\n  return firstDiff < 0;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
