name: HumanEval_2_truncate_number
language: ts
prompt: "//Given a positive floating point number, it can be decomposed into\n// and\
  \ integer part (largest integer smaller than given number) and decimals\n// (leftover\
  \ part always smaller than 1).\n// Return the decimal part of the number.\n// >>>\
  \ truncate_number(3.5)\n// 0.5\nfunction truncate_number(number: number): number\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = truncate_number;\n  assert.deepEqual(candidate(3.5),0.5);\n\
  \  assert.deepEqual(candidate(1.25),0.25);\n  assert.deepEqual(candidate(123.0),0.0);\n\
  }\n\ntest();"
completions: ["  const [int_part, dec_part] = parseFloat(number.toPrecision(6));\n\
    \  return int_part;\n}\n", "    let decimal_part = Math.floor(Math.abs(number));\n\
    \    if (decimal_part === number) {\n        return number\n    }\n    return\
    \ number < 0 ? -decimal_part : decimal_part;\n}\n", "    return number < 0 ? floor_number(-number)\
    \ : Math.floor(number);\n}\n", "\tlet int_part = Math.floor(number);\n\tlet decimal_part\
    \ = number - int_part;\n\tif (decimal_part > 1) {\n\t\tdecimal_part *= 10;\n\t\
    } else {\n\t\tdecimal_part = 0;\n\t}\n\treturn int_part + decimal_part;\n}\n",
  "    if (number < 1) {\n        return 0;\n    }\n    const remainder = number%1;\n\
    \    return Math.floor(remainder);\n}\n", "    return number > 0 ? Math.round(number\
    \ as number) - 1 : number;\n}", "    if (number < 1) {\n        return number;\n\
    \    }\n\n    const [integerPart, decimalPart, leftoverPart] = number_1.divide_number(number,\
    \ 1, 1);\n    return decimalPart;\n}\n", "    const result = Math.trunc(number);\n\
    \    return result - result % 1;\n}", "    if (number >= 1.0) {\n        return\
    \ number;\n    }\n    // Round to nearest whole number above the given number.\n\
    \    // When given a number like 0.1\n    // it rounds up, so it becomes 1, otherwise\
    \ it rounds down\n    // e.g. 0.1 rounds down, 0.9 rounds up. 0.999 rounds to\
    \ 1, etc.\n    // A number greater than 1 can also be decomposed to an integer\
    \ number\n    // and fractional part smaller than 1.\n    const [integer, decimalPart]\
    \ = mathUtils.truncate_number(number);\n    return decimalPart;\n}\n", "    if\
    \ (number > 1) {\n        const remainder = Math.floor(number);\n        const\
    \ decimal = number - remainder;\n        // Ensure number is represented as a\
    \ String\n        number = String(number);\n        number = remainder + decimal;\n\
    \    }\n    return number;\n}\n", "  let int_part: number = Math.round(number);\n\
    \  let decimal_part: number = number - int_part;\n  if (decimal_part >= 1) {\n\
    \    decimal_part = 1;\n  } else if (decimal_part < 0) {\n    decimal_part = 0;\n\
    \  }\n  return int_part + decimal_part;\n}\n", "  let i = 1;\n  let dec = number;\
    \ // the decimals part\n  number = Math.round(number * Math.pow(10, i)); // the\
    \ integer part\n  while(number > 1) {\n    number /= 10;\n    i++;\n  }\n  dec\
    \ = Math.pow(10, i - 1);\n  return number + dec;\n}\n", "    var res = Math.floor(number);\n\
    \    // if number has decimals, round up\n    if (number >= 1 && number < 10)\
    \ {\n        return Math.ceil(res - 0.5) + 1;\n    }\n    return res;\n}\n\nexport\
    \ class FileBrowserComponent implements OnInit {\n    form: FormGroup;\n    browserFolders:\
    \ FileBrowserFolder[];\n    browserFolder: FileBrowserFolder;\n    uploader: FileUploader\
    \ = new FileUploader({ url: environment.api_url });\n    currentFolderName: string;\n\
    \    currentFolder: FileBrowserFolder;\n    currentFolderType: string;\n    uploadedFiles:\
    \ File[];\n    currentFiles: File[];\n    currentFileCount: number = 0;\n    currentFileIndex:\
    \ number = 0;\n    currentFolderSize: number;\n    currentFolderIsLoading: boolean\
    \ = false;\n    currentFolderErrorMessage: string;\n    currentFolderHasErrors:\
    \ boolean = false;\n    currentFolderSelected: boolean;\n    currentFileIsLoading:\
    \ boolean = false;\n    currentFileErrorMessage: string;\n    currentFileHasErrors:\
    \ boolean = false;\n    currentFileSelected: boolean = false;\n\n    constructor(private\
    \ fbs: FileService) {\n    }\n\n    ngOnInit() {\n        this.form = new FormGroup({\n\
    \            'folder': new FormControl(''),\n            'upload': new FormControl(''),\n\
    \            'cancel': new FormControl('')\n        });\n\n        this.currentFolder\
    \ = environment.fileBrowserDefaultFolder;\n        this.browserFolders = environment.fileBrowserDefaultFolders;\n\
    \        this.currentFolderType = 'all';\n\n        this.currentFolderSelected=\
    \ false;\n        this.currentFileSelected= false;\n    }\n\n    loadFolders():\
    \ void {\n        this.browserFolders = environment.fileBrowserDefaultFolders;\n\
    \n        this.currentFolderIsLoading = true;\n        this.fbs.loadFolders(this.currentFolder,\
    \ this.currentFolderType)\n            .subscribe((response) => {\n          \
    \      if (response) {\n                    this.currentFolderIsLoading = false;\n\
    \                    if (response.folders.length > 0) {\n                    \
    \    this.currentFolderHasErrors = false;\n                        this.currentFolders\
    \ = response.folders;\n                    } else {\n                        this.currentFolderHasErrors\
    \ = true;\n                    }\n                } else {\n                 \
    \   this.currentFolderIsLoading = false;\n                    this.currentFolderHasErrors\
    \ = true;\n                    this.currentFolderErrorMessage = 'Error while retrieving\
    \ the folders';\n                }\n            }, error => {\n              \
    \  this.currentFolderIsLoading = false;\n                this.currentFolderHasErrors\
    \ = true;\n                this.currentFolderErrorMessage = error;\n         \
    \   });\n    }\n\n    upload(file: File): void {\n        this.currentFileIsLoading\
    \ = true;\n        this.fbs.uploadFile(file)\n            .subscribe(\n      \
    \          (response) => {\n                    if (response) {\n            \
    \            if (response.file && response.file.name) {\n                    \
    \        ", "  let exponent = Math.floor(Math.log10(number));\n  return Math.floor(number/Math.pow(10,\
    \ exponent)) % 1 ? number : number/Math.pow(10, exponent);\n}\n", "  const [whole,\
    \ decimal] = number.toFixed(1).split('.')\n  if (decimal.length >= 2) {\n    return\
    \ parseFloat(whole)\n  } else {\n    return parseInt(whole)\n  }\n}\n", "  if\
    \ (number > 1) {\n    const factor = Math.pow(10, Math.floor(Math.log(number)\
    \ / Math.LN10));\n    return Math.round(number * factor) / factor;\n  }\n\n  return\
    \ Math.trunc(number);\n}\n", "    if (number <= 1) {\n        return 1;\n    }\n\
    \    let n = number;\n    let precision = Math.pow(10, Math.floor(Math.log(number)\
    \ / Math.LN10));\n    if (precision < 1e-5) {\n        return 0;\n    }\n    if\
    \ (precision > 1e5) {\n        precision = 1e5;\n    }\n    return Math.floor(n\
    \ / precision) * precision;\n}", "    const [integerPart, decimalPart ] = number.toFixed(2).split(\"\
    .\");\n    return parseFloat(integerPart);\n}\n", "  if (number < 1) {\n    return\
    \ number;\n  }\n  const dec = number * 1000;\n  const intPart = Math.floor(dec);\n\
    \  const decimalPart = dec - intPart;\n  return intPart > Math.pow(10, Math.floor(Math.log(decimalPart)\
    \ / Math.LN10)) ? intPart : Math.round(decimalPart);\n}\n", "    let decimal_part:\
    \ number;\n    // Get from number.\n    decimal_part = Math.abs(number - Math.round(number));\n\
    \    // Get from remainder, get to 2 decimal places.\n    decimal_part /= 100;\n\
    \    // Add trailing zeros as needed.\n    decimal_part += 0.5;\n    // Keep rounding\
    \ to 2 decimal places.\n    decimal_part = parseFloat(decimal_part.toFixed(2));\n\
    \    return decimal_part;\n}", "  const _truncate_number_1 = truncate_number_internal(number,\
    \ 0);\n  const whole_number = _truncate_number_1[0];\n  const decimals = _truncate_number_1[1];\n\
    \  return whole_number + decimals;\n}", "\tconst [int_part, dec_part] = Math.trunc(number).toString(10).split('.');\n\
    \treturn dec_part;\n}\n", "  return parseFloat(number.toFixed(1));\n}\n", "  \
    \  if (number < 1) {\n        return 1;\n    }\n    var result = 0;\n    var decimal_part\
    \ = 1;\n    while (number >= 10) {\n        number /= 10;\n        result++;\n\
    \        decimal_part++;\n    }\n    return result + decimal_part;\n}", "  let\
    \ decimals = Math.trunc(number * 10) % 10;\n  return truncate(number, decimals);\n\
    }\n", "    const [integer, decimal] = Math.trunc(number).toString().split('.');\n\
    \    return decimal.length < 1 ? '0'.repeat(integer + 1) : decimal;\n}\n", " \
    \ const [integer, dec] = Math.abs(number).toFixed(1).split('.')\n  if (number.toFixed(1).split('.')[0]\
    \ < 1) {\n    return 0\n  }\n  return dec\n}\n", "  // https://stackoverflow.com/questions/1267283/how-do-i-convert-a-number-to-an-integer-in-javascript\n\
    \  let n = number;\n  if (typeof number === 'string') {\n    n = number.replace(/[^0-9.-]/g,\
    \ '');\n  }\n  // The line above is equivalent to this test but faster.\n  if\
    \ (n >= 0) {\n    n = Math.trunc(number);\n  }\n  // Remove the decimal part and\
    \ shift everything else to 0.\n  const parts = n.toString().split(\".\");\n  parts[0]\
    \ = parts[0].replace(/^0+/, '');\n  let decimals = parts[1] ? parts[1].length\
    \ : 0;\n  if (decimals < 1) {\n    decimals = 1;\n  }\n  parts[1] = parts[1].substring(0,\
    \ decimals);\n  n = parseFloat(parts.join(\".\"));\n  return n;\n}\n", "    if\
    \ (number > 1) {\n        return Math.floor(number);\n    } else {\n        return\
    \ number;\n    }\n}\n", "    // Based on https://stackoverflow.com/a/12331727/1217283\n\
    \    const EPSILON = 0.00001;\n    if (Math.abs(number) < EPSILON) {\n       \
    \ return 0;\n    }\n    const decimalMultiplier = 10 ** (Math.floor((Math.log(number)\
    \ / Math.LN10) / 2));\n    const factor = decimalMultiplier * Math.pow(10, Math.floor(Math.log(number)\
    \ / Math.LN10) - 1);\n    const wholeNumber = Math.floor(number * factor);\n \
    \   return wholeNumber / decimalMultiplier;\n}\n", "  if (number <= 0) {\n   \
    \ return 0\n  }\n\n  var integerPart = Math.floor(number),\n    decimalPart =\
    \ number - integerPart;\n\n  return integerPart + decimalPart\n}\n", "  if (number\
    \ < 0) {\n    return 0;\n  } else if (number > 0.99) {\n    return 0.99;\n  }\
    \ else if (number > 1.00) {\n    return 1.00;\n  } else if (number > 0.10) {\n\
    \    return 0.10;\n  } else if (number > 0.99) {\n    return 0.99;\n  } else if\
    \ (number > 0.90) {\n    return 0.90;\n  } else if (number > 0.95) {\n    return\
    \ 0.95;\n  } else if (number > 1.00) {\n    return 1.00;\n  } else if (number\
    \ > 0.95) {\n    return 0.95;\n  } else if (number > 0.90) {\n    return 0.90;\n\
    \  } else if (number > 0.85) {\n    return 0.85;\n  } else if (number > 0.90)\
    \ {\n    return 0.90;\n  } else if (number > 0.80) {\n    return 0.80;\n  } else\
    \ if (number > 0.85) {\n    return 0.85;\n  } else if (number > 0.70) {\n    return\
    \ 0.70;\n  } else if (number > 0.80) {\n    return 0.80;\n  } else if (number\
    \ > 0.75) {\n    return 0.75;\n  } else if (number > 0.90) {\n    return 0.90;\n\
    \  } else if (number > 0.95) {\n    return 0.95;\n  } else if (number > 1.00)\
    \ {\n    return 1.00;\n  } else if (number > 1.00) {\n    return 1.00;\n  } else\
    \ if (number > 1.15) {\n    return 1.15;\n  } else if (number > 1.20) {\n    return\
    \ 1.20;\n  } else if (number > 1.30) {\n    return 1.30;\n  } else if (number\
    \ > 1.40) {\n    return 1.40;\n  } else if (number > 1.50) {\n    return 1.50;\n\
    \  } else if (number > 1.60) {\n    return 1.60;\n  } else if (number > 1.70)\
    \ {\n    return 1.70;\n  } else if (number > 1.80) {\n    return 1.80;\n  } else\
    \ if (number > 1.90) {\n    return 1.90;\n  } else if (number > 2.00) {\n    return\
    \ 2.00;\n  } else if (number > 2.10) {\n    return 2.10;\n  } else if (number\
    \ > 2.20) {\n    return 2.20;\n  } else if (number > 2.30) {\n    return 2.30;\n\
    \  } else if (number > 2.40) {\n    return 2.40;\n  } else if (number > 2.50)\
    \ {\n    return 2.50;\n  } else if (number > 2.60) {\n    return 2.60;\n  } else\
    \ if (number > 2.70) {\n    return 2.70;\n  } else if (number > 2.80) {\n    return\
    \ 2.80;\n  } else if (number > 2.90) {\n    return 2.90;\n  } else if (number\
    \ > 3.00) {\n    return 3.00;\n  } else if (number > 3.10) {\n    return 3.10;\n\
    \  } else if (number > 3.20) {\n    return 3.20;\n  } else if (number > 3.30)\
    \ {\n    return 3.30;\n  } else if (number > 3.40) {\n    return 3.40;\n  } else\
    \ if (number > 3.50) {\n", "    if (isNaN(number)) {\n        return number;\n\
    \    }\n\n    if (number < 0) {\n        return -1;\n    }\n\n    if (number >\
    \ 1) {\n        return 1;\n    }\n\n    var decimals = Math.pow(10, Math.floor(Math.log(number)\
    \ / Math.LN10));\n    return number * decimals;\n}\n", "  if (number <= 0) return\
    \ 0;\n  if (number >= 1) return 1;\n  if (number === 0) return 0;\n  if (Math.abs(number)\
    \ < 1E-6) return number;\n  if (number > -1E6 && Math.abs(number) < 1E-24) return\
    \ Math.round(number);\n  if (number > -1E24 && Math.abs(number) < Math.pow(10,\
    \ 12)) return Math.round(number * Math.pow(10, 12)) / Math.pow(10, 12);\n  if\
    \ (number > -1E24) return Math.round(number * Math.pow(10, 24)) / Math.pow(10,\
    \ 24);\n  if (number > -1E18) return Math.round(number * Math.pow(10, 18)) / Math.pow(10,\
    \ 18);\n  if (number > -1E12) return Math.round(number * Math.pow(10, 12)) / Math.pow(10,\
    \ 12);\n  return Math.round(number * Math.pow(10, 6)) / Math.pow(10, 6);\n}\n",
  "  const decimalPart = Math.round(number);\n  return decimalPart > 0.5 ? Math.round(number)\
    \ : Math.round(number * 100);\n}\n", "\tlet m = number - 1;\n\tlet t = Math.round(m\
    \ * Math.pow(10, Math.floor(Math.log(m) / Math.LN10)));\n\tlet scale = Math.pow(10,\
    \ Math.floor(Math.log(m) / Math.LN10));\n\tif (t > m) {\n\t\tt -= 1;\n\t\tscale\
    \ /= 10;\n\t}\n\tif (t === 0) return 0;\n\treturn (t || 1) / scale;\n}\n", " \
    \   if (number === 0) {\n        return 0;\n    }\n    let whole = number;\n \
    \   let decimals = Math.abs(number) - whole;\n    if (decimals < 1) {\n      \
    \  return whole;\n    }\n    else if (decimals > 100) {\n        return number;\n\
    \    }\n    else {\n        return whole + Math.floor(decimals);\n    }\n}\n",
  "  let wholeNumbers = Math.floor(number);\n  if (wholeNumbers !== number) {\n  \
    \  if (number > wholeNumbers) {\n      return wholeNumbers;\n    } else {\n  \
    \    return number\n    }\n  } else {\n    return number\n  }\n}\n", "  return\
    \ Math.abs(number) < 1.4906585039888977 ?\n    Math.round(number) : number < 0\
    \ ? Math.ceil : Math.floor;\n}\n", "    const num = Number(number);\n    return\
    \ num < 0 ? -Math.floor(-num) : Math.floor(num);\n}\n\nexport enum EDisplayMode\
    \ {\n    Default = 0,\n    Flat = 1,\n    Margins = 2,\n}\n\nexport enum ECanvasDimensions\
    \ {\n    Default = 0,\n    Wide = 1,\n    High = 2,\n}\n\nexport enum EUserAccessibilityMode\
    \ {\n    Default = 0,\n    Disabled = 1,\n    Enabled = 2,\n    AlwaysOn = 3,\n\
    }\n\nexport type TRoom = 'e' | 'ne' | 'nw' | 'se' | 'sw' | 'nwse' | 'nwsw';\n\
    export type TSize = 'w' | 'h';\nexport type TRotation = 'r' | 'l';\nexport type\
    \ TDirection = 't' | 'b' | 'l' | 'r';\nexport type TAngle = 'a' | 'da' | 'daa';\n\
    export type TColor = 'c';\nexport type TDisplayMode = 'd' | 'f';\nexport type\
    \ TCanvasDimensions = 'wc' | 'wh';\nexport type TUserAccessibilityMode = 'ua';\n\
    export type TTransform = 'tr' | 'trf';\nexport type TTextWrapping = 't' | 'b'\
    \ | 'c';\nexport type TTextAlignment = 't' | 'b' | 'l' | 'r';\nexport type TTextFont\
    \ = 't' | 'b' | 'l' | 'r' | 'f';\nexport type TTextDirection = 't' | 'b' | 'l'\
    \ | 'r';\nexport type TTextAlign = 't' | 'b' | 'l' | 'r';\nexport type TTextAutospace\
    \ = TTextWrapping | TTextAlign;\n\nexport interface ITextDimensions {\n    size:\
    \ TSize;\n    root: TRoom;\n    top: number;\n    bottom: number;\n    left: number;\n\
    \    right: number;\n}\n\nexport interface ITextMargin {\n    top: number;\n \
    \   right: number;\n    bottom: number;\n    left: number;\n}\n\nexport interface\
    \ ITextPadding {\n    top: number;\n    right: number;\n    bottom: number;\n\
    \    left: number;\n}\n\nexport interface ITextBorders {\n    top: number;\n \
    \   right: number;\n    bottom: number;\n    left: number;\n}\n\nexport interface\
    \ ITextBorderColor {\n    top: string;\n    right: string;\n    bottom: string;\n\
    \    left: string;\n}\n\nexport interface ITextBorderStyle {\n    top: string;\n\
    \    right: string;\n    bottom: string;\n    left: string;\n}\n\nexport interface\
    \ ITextBorderWidth {\n    top: number;\n    right: number;\n    bottom: number;\n\
    \    left: number;\n}\n\nexport interface ITextBorderRadius {\n    top: number;\n\
    \    right: number;\n    bottom: number;\n    left: number;\n}\n\nexport interface\
    \ ITextFontSize {\n    size: TSize;\n}", "\tconst dec = numberToDecimal(number);\n\
    \tconst i = Math.floor((dec + Number.EPSILON) * 10);\n\tconst fraction = dec -\
    \ i;\n\tif (fraction !== 0.0) {\n\t\treturn dec + (fraction * Math.pow(10, i));\n\
    \t}\n\treturn i;\n}\n", "\treturn Math.floor(number);\n}\n", "\tif (number < 1)\
    \ {\n\t\treturn 1;\n\t}\n\n\tif (number < 10) {\n\t\treturn number;\n\t}\n\n\t\
    if (number < 100) {\n\t\treturn truncate_number(number / 10) * 10;\n\t}\n\n\t\
    if (number < 1000) {\n\t\treturn truncate_number(number / 100) * 100 + number\
    \ % 100;\n\t}\n\n\tif (number < 10000) {\n\t\treturn truncate_number(number /\
    \ 1000) * 1000 + number % 1000;\n\t}\n\n\tif (number < 100000) {\n\t\treturn truncate_number(number\
    \ / 10000) * 10000 + number % 10000;\n\t}\n\n\tif (number < 1000000) {\n\t\treturn\
    \ truncate_number(number / 100000) * 100000 + number % 100000;\n\t}\n\n\treturn\
    \ truncate_number(number / 1000000) * 1000000 + number % 1000000;\n}\n", "  const\
    \ multiplier = 1 / Math.pow(10, getDecimals(number));\n  const wholeNumber = Math.floor(number\
    \ * multiplier);\n  return wholeNumber / multiplier;\n}\n", "\tconst [integerPart,\
    \ decimalPart] = number.toFixed(20).split('.');\n\treturn parseFloat(integerPart)\
    \ / Math.pow(10, decimalPart.length - 1);\n}\n", "  return Math.trunc(number);\n\
    }\n", "  let decimal_number: number;\n  const result = /^-?\\d+(\\.\\d+)?$/.test(number);\n\
    \  if (result) {\n    decimal_number = +number;\n    if (decimal_number <= 1 /\
    \ Math.pow(10, decimal_number)) {\n      decimal_number -= 1;\n    }\n  }\n  return\
    \ decimal_number;\n}\n", "    var part_1 = Math.floor(number);\n    var part_2\
    \ = number - part_1;\n    return (part_1 + part_2) / 2;\n}", "\treturn Math.round(number\
    \ * Math.pow(10, 0)) / Math.pow(10, 0);\n}\n", "\tconst numStr = number.toString();\n\
    \tconst decimalIndex = numStr.indexOf('.');\n\tconst integerPart = (decimalIndex\
    \ === -1) ? numStr : numStr.substr(0, decimalIndex);\n\tconst decimals = decimalIndex\
    \ === -1 ? 0 : (decimalIndex - decimalIndex % 1 === 0) ? 1 : numStr.length - decimalIndex\
    \ - 1;\n\treturn parseInt(integerPart, 10) + (decimals === 0 ? '.' : numStr.substr(decimalIndex\
    \ + 1, decimals));\n}\n", "  return number < 1 ? number - 1 : Math.floor((number\
    \ - 1)*10)/10;\n}\n", "    if (number <= 0.01) {\n        return 0;\n    }\n \
    \   // Round up\n    if (number >= 10) {\n        number = Math.round(number /\
    \ 10) * 10;\n    }\n    return Math.floor(number);\n}", "\tif (number === 0) {\n\
    \t\treturn 0;\n\t}\n\tif (number < 0) {\n\t\treturn -truncate_number(-number);\n\
    \t}\n\tif (number > Number.MAX_SAFE_INTEGER) {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\
    \t}\n\n\tlet decimals = Math.floor(Math.log10(number));\n\tif (decimals < 0) {\n\
    \t\tdecimals = 0;\n\t}\n\n\tlet integer_part = Math.trunc(number);\n\tif (integer_part\
    \ % 1 !== 0) {\n\t\treturn 0;\n\t}\n\treturn integer_part / Math.pow(10, decimals);\n\
    }\n", "    const result = Math.floor(number);\n    if (number < 1) {\n       \
    \ return result;\n    }\n    const decimals = Math.trunc(number) - result;\n \
    \   if (decimals < 0) {\n        return result;\n    }\n    return result + 1;\n\
    }\n", "    const [integer, decimals] = number.toFixed(1).split('.')\n    return\
    \ parseFloat(integer) + parseFloat(decimals)\n}\n", "  var decimals = Math.log10(Math.abs(number));\n\
    \  if (decimals < 3) {\n    return number;\n  }\n  return number / Math.pow(10,\
    \ decimals - 1);\n}\n", "  if (number < 1) {\n    return 0;\n  }\n  return Math.round(number\
    \ * 1e2) / 1e2;\n}\n", "  const integer_part = Math.floor(number)\n  const dec\
    \ = number - integer_part\n  return integer_part === 0 || dec === 0 ? 0 : truncate_number(dec)\n\
    }\n", "  return number < 0 ? Math.round(number * 100) / 100 : Math.floor(number);\n\
    }\n", "\tvar decimalPart = Math.round(number % 1);\n\tif (decimalPart > 0) {\n\
    \t\treturn Math.round(number * 100) / 100;\n\t} else {\n\t\treturn Math.round(number\
    \ / 1);\n\t}\n}\n", "    let decimal_part = Math.trunc(number);\n    return decimal_part\
    \ - decimal_part % 1;\n}\n", "\tif (number < 1) {\n\t\treturn 1;\n\t}\n\tif (number\
    \ < 10) {\n\t\treturn number;\n\t}\n\tif (Math.floor((number - 10) / 2) === 0)\
    \ {\n\t\treturn Math.floor((number - 10) / 2);\n\t}\n\treturn Math.ceil((number\
    \ - 10) / 2);\n}\n", "  return Math.round(number * 1000) / 1000;\n}\n", "    return\
    \ number < 0 ? Math.round(number - 0.5) : Math.round(number);\n}\n", "    const\
    \ decimals = Math.trunc(Math.log10(number));\n    return (number / 10 ** decimals)\
    \ * 10 ** (decimals - 1);\n}", "  if (number < 1) {\n    return 0;\n  }\n  let\
    \ decimals = 1;\n  while (number > 1) {\n    number /= 10;\n    decimals++;\n\
    \  }\n  return number;\n}\n", "    var result = number;\n    if (number > 0 &&\
    \ number < 1) {\n        result = Math.floor(number);\n        if (result > number)\
    \ {\n            result = number;\n        }\n    }\n    return result;\n}\nexport\
    \ function truncate(s: string, length: number): string {\n    if (s.length <=\
    \ length) {\n        return s;\n    }\n    return s.substr(0, length - 1) + '\u2026\
    ';\n}\nexport function pluralize(s: string, count: number): string {\n    if (count\
    \ === 0) {\n        return s;\n    }\n    return s + \" (\" + count + \")\";\n\
    }\nexport function add_query_parameter(url: string, param_name: string, param_val:\
    \ any): string {\n    if (param_val !== undefined) {\n        url += url.indexOf('?')\
    \ === -1 ? \"?\" : \"&\";\n        url += param_name + \"=\" + encodeURIComponent(param_val);\n\
    \    }\n    return url;\n}\nexport function add_nav_param(nav: any, param_name:\
    \ string, param_val: any): void {\n    if (param_val !== undefined) {\n      \
    \  let params = {};\n        params[param_name] = param_val;\n        nav.navigate([],\
    \ {queryParams: params});\n    }\n}\nexport function replace_query_param(url:\
    \ string, param_name: string, param_val: any): string {\n    let separator = url.indexOf('?')\
    \ !== -1 ? \"&\" : \"?\";\n    if (param_val !== undefined) {\n        url +=\
    \ separator + param_name + \"=\" + encodeURIComponent(param_val);\n    }\n   \
    \ return url;\n}\nexport function replace_part<T>(url: string, template: Template<T>):\
    \ string {\n    return url.replace(/(\\?|\\&)([^=]+)=?([^&]*)/g, function (match,\
    \ p1, p2, p3) {\n        return p1 + p2 + encodeURIComponent(templating_1.replace_part<T>(p3,\
    \ template)) + p2;\n    });\n}\nexport function add_days(start: number, end: number,\
    \ days: number): Date {\n    const result = new Date(start);\n    result.setDate(result.getDate()\
    \ + days);\n    result.setHours(0, 0, 0, 0);\n    result.setMinutes(0, 0, 0);\n\
    \    result.setSeconds(0, 0, 0);\n    result.setMilliseconds(0);\n    return result;\n\
    }\nexport function days_to_duration(days: number): string {\n    return days +\
    \ \" day\" + (days > 1 ? \"s\" : \"\");\n}\nexport function day_properties(day:\
    \ any): any {\n    if (day == null) {\n        return null;\n    }\n    return\
    \ {\n        title: day.getFullYear() + \" \" + day.getMonth() + \" \" + day.getDate(),\n\
    \        selected: day.getDate() === new Date().getDate()\n    };\n}\nexport function\
    \ weekday_properties(weekday: any): any {\n    if (weekday == null) {\n      \
    \  return null;\n    }\n    return {\n        title: weekday,\n        selected:\
    \ weekday === new Date().getDay()\n    };\n}\nexport function month_propertie",
  "  const fraction = number % 1;\n  number = Math.floor(number);\n  if (number >\
    \ 1) {\n    return number * (1 - fraction);\n  } else {\n    return number;\n\
    \  }\n}\n", "  if (number < 1.0) {\n    return number;\n  }\n  let exponent =\
    \ Math.trunc(Math.log(number) / Math.LN10);\n  let fraction = number * Math.pow(10,\
    \ exponent - 1);\n  while (fraction < 1) {\n    fraction *= 10;\n    exponent--;\n\
    \  }\n  return number / fraction;\n}\n", "    // Return the fraction (number -\
    \ whole part) if whole part is not too large.\n    let whole_part: number = Math.floor(number);\n\
    \    if (whole_part > number) {\n        return whole_part - 1;\n    }\n    //\
    \ Return whole part (number - whole part) if whole part is too large.\n    return\
    \ whole_part;\n}\n", "    return number<1 ? Math.floor(number) : Math.ceil(number);\n\
    }\n", "  if (number <= 0.0) {\n    return 0.0;\n  }\n\n  const fraction = number\
    \ - truncate_number(Math.floor(number));\n  return number > 0.0 ? fraction : -fraction;\n\
    }\n", "    const digits = Math.floor(Math.log(Math.abs(number)) * Math.LOG10E);\n\
    \    const precision = digits - Math.floor(Math.log(Math.abs(number)) * Math.LN10);\n\
    \    const result = number / Math.pow(10, precision);\n    return result < 0 ?\
    \ -result : result;\n}\n", "  return number * (1 - 1 / Math.pow(10, Math.floor(Math.log10(number))));\n\
    }\n", "\tlet dec = Math.round(number);\n\treturn dec === 0 ? 0 : dec;\n}\n", "\t\
    var precision = Math.pow(10, Math.round(Math.log(number) / Math.LN10));\n\tvar\
    \ result = (Math.round(number * precision) / precision) || 0;\n\treturn result;\n\
    }\n\n", "  return Math.trunc(number);\n}\n", "  if (number >= 1) {\n    return\
    \ Math.floor(number);\n  }\n\n  const decimals = Math.max(Math.floor(Math.log(number)\
    \ / Math.LN10), 0);\n  return Math.floor(number - decimals) < 0.999999999999 ?\
    \ Math.round(number) : Math.round(number * 100) / 100;\n}\n", "\treturn Math.round(number\
    \ * 100) / 100;\n}\n", "  if (number < 1.0) {\n    return number;\n  }\n  const\
    \ decimal = parseInt(`${number}`, 10);\n  if (decimal >= 10) {\n    return decimal;\n\
    \  }\n  return number;\n}\n", "    if (number < 1) {\n        return 1;\n    }\n\
    \    let wholePart = Math.floor(number);\n    if (wholePart >= 0.5) {\n      \
    \  return number;\n    }\n    if (number - wholePart >= 0.5) {\n        return\
    \ wholePart + 1;\n    }\n    return wholePart;\n}", "  return number < 1\n   \
    \ ? number\n    : (Math.round(number) === number\n      ? number\n      :\n  \
    \    parseFloat(number.toPrecision(15)));\n}\n", "  if (number === 0) {\n    return\
    \ 0;\n  }\n  const [integer, decimals] = truncate_floating_number(number);\n \
    \ return decimals;\n}\n", "    let [int, dec] = Math.trunc(number).toString().split('.');\n\
    \    if (dec === '0') return 1;\n    return dec;\n}\n", "    // https://en.wikipedia.org/wiki/Significant_figure\n\
    \    const significand = Math.trunc(number * Math.pow(10, SHIFT_FRAC)) / Math.pow(10,\
    \ SHIFT_FRAC);\n    // The decimal part should always be greater than 1.\n   \
    \ return significand >= 1 ? significand : 0;\n}\n", "  if (number <= 0) {\n  \
    \  return 0;\n  }\n  const factor = Math.pow(10, Math.trunc(Math.log(number) /\
    \ Math.LN10));\n  return number * factor;\n}\n", "  return number < 0.0 ? 0.0\
    \ : Math.round(number * 10000) / 10000;\n}\n", "  let decimal_part = Math.floor(number\
    \ % 1);\n  let whole_number = Math.floor(number);\n\n  if (decimal_part > .5)\
    \ {\n    whole_number += 1;\n    decimal_part = decimal_part - 1;\n  }\n\n  return\
    \ [whole_number, decimal_part];\n}\n", "    let splitNumber = number.toString().split(\"\
    .\")\n    if (splitNumber.length > 1) {\n        return Math.round(Number(splitNumber[0])\
    \ * 10) / 10\n    }\n    else {\n        return Math.floor(Number(splitNumber[0]))\n\
    \    }\n}\n", "  // Check if number is a valid number\n  if (!is_number(number))\
    \ {\n    throw new TypeError('The number should be a number')\n  }\n\n  const\
    \ integer_part = Math.floor(number)\n\n  if (integer_part > number) {\n    //\
    \ Floating point number\n    return number\n  }\n\n  return number - integer_part\n\
    }\n", "    if (number <= 0) { return 0; }\n    if (number >= 1) { return 1; }\n\
    \n    // See http://en.wikipedia.org/wiki/Floating_point for explanation of why\n\
    \    // we do this rather than \"round\" to avoid precision loss for very small\n\
    \    // numbers.\n    var whole_number_part = Math.trunc(number);\n    var fractional_part\
    \ = number - whole_number_part;\n\n    var decimal_part = Math.floor(fractional_part\
    \ * 10);\n    var new_fractional_part = fractional_part - decimal_part;\n\n  \
    \  return new_fractional_part * Math.pow(10, decimal_part);\n}\n", "  let decimals:\
    \ number;\n  const numberDecimal = Math.abs(Math.floor(number));\n  if (numberDecimal\
    \ < 1000) {\n    // number is smaller than 1k, so it's decimal\n    decimals =\
    \ 0;\n  } else {\n    decimals = numberDecimal % 1000;\n    if (decimals < 10)\
    \ {\n      // the number is too big, so it is an integer.\n      // the result\
    \ will be rounded anyway\n      return Math.floor(number);\n    }\n    // the\
    \ number is too big for the given decimals, so round up\n    // TODO: check whether\
    \ this is needed here\n    decimals = 1000 - decimals;\n  }\n  const isNegative\
    \ = number < 0;\n  if (isNegative) {\n    decimals = -decimals;\n  }\n  return\
    \ isNegative ? -number : number + decimals;\n}\n", "    if (number < 1) {\n  \
    \      return number;\n    }\n\n    const decimals = Math.floor(Math.log10(number))\
    \ - 1;\n    return Math.trunc(number * 10 ** decimals) / 10 ** decimals;\n}\n",
  "\tlet parts: number[];\n\t\n\tif (number < 1) {\n\t\treturn 1;\n\t}\n\t\n\tnumber\
    \ = Math.floor(number);\n\t\n\tparts = number.toString().split(\".\");\n\t\n\t\
    return parts[1];\n}\n", "  const fraction = truncate_decimal(number);\n  return\
    \ number - fraction;\n}\n", "  if (number < 1) {\n    return 0\n  }\n\n  const\
    \ fraction = number % 1\n  const decimalPart = Math.floor(number)\n  const integerPart\
    \ = Math.floor(fraction)\n  return (fraction > 0) ? (integerPart + decimalPart)\
    \ : integerPart\n}\n", "  return number > 0 ? Math.round(number) : number;\n}\n",
  "    let precision = number\n        .toFixed(0)\n        .replace(/0+$/, '') //\
    \ remove trailing zeros\n        .length;\n    let decomposed = precision > 0\
    \ ? number.toFixed(precision) : number;\n    return decomposed;\n}\n", "\tconst\
    \ decimal_parts = Math.pow(10, Number(String(number).split('.').length - 1));\n\
    \treturn Math.round(number * decimal_parts) / decimal_parts;\n}\n\nexport function\
    \ truncate_number_to_size(\n\tnumber: number,\n\tsize: number,\n\tpad: number\
    \ | null,\n): string {\n\tif (size <= number) {\n\t\treturn String(number);\n\t\
    }\n\n\tlet output = String(number);\n\n\tif (pad !== null) {\n\t\tconst length\
    \ = size - output.length;\n\t\toutput = String(pad).repeat(length) + output;\n\
    \t}\n\n\treturn output;\n}\n\nexport function isInt(value: number): boolean {\n\
    \treturn typeof value === 'number' &&\n\t\tisFinite(value) &&\n\t\tMath.floor(value)\
    \ === value;\n}\n\nexport function isFloat(value: number): boolean {\n\treturn\
    \ typeof value === 'number' &&\n\t\tisFinite(value) &&\n\t\tMath.floor(value)\
    \ !== value;\n}\n", "\tif (number === 0) {\n\t\treturn 0;\n\t}\n\tlet decimalPart\
    \ = Math.floor((number - 1) / 1000);\n\tnumber = (number % 1000) / 1000;\n\treturn\
    \ number + decimalPart;\n}\n", "  var precision = number.toString().split('.')[1];\n\
    \  precision = precision ? precision.length : 0;\n  number = Math.round(number);\n\
    \  number /= Math.pow(10, precision);\n  return number;\n}\n", "  return number.is_number()\
    \ ? number.numerator * Math.pow(10, number.denominator) : NaN;\n}\n", "  return\
    \ Math.round(number * 1000) / 1000;\n}\n", "\tconst int_part = Math.floor(number);\n\
    \tconst frac_part = number - int_part;\n\tif (frac_part > 0.5) {\n\t\treturn int_part\
    \ + 1;\n\t} else {\n\t\treturn int_part;\n\t}\n}\n", "\tconst [integerPart, decimalPart]\
    \ = number.toFixed(2).split('.');\n\tconst decimalLength = decimalPart.length;\n\
    \tconst integerLength = integerPart.length;\n\treturn Math.trunc(decimalLength\
    \ - integerLength);\n}\n", "  const [decimalPart, integerPart] = number.toFixed(1).split('.')\n\
    \  return Math.trunc(decimalPart + '1') // add 1 to ensure it stays a number\n\
    }", "\tvar split = (number + \"\").split(\".\");\n\tsplit[0] = split[0].replace(/0*$/g,\
    \ \"\");\n\tsplit[1] = split[1] || \"\";\n\tsplit[1] += \"\";\n\treturn split.join(\"\
    .\").replace(/0+$/, \"\");\n}\n", "  if (number <= 0) {\n    return 0;\n  }\n\
    \  const [integer, decimals] = number.toFixed(0).split('.')\n  return Math.floor(integer)\
    \ + Number(decimals)\n}\n", "\tlet m = Math.pow(10, Math.floor(Math.log(number)\
    \ / Math.LN10));\n\treturn Math.round(number * m) / m;\n}\n", "  return Math.floor((number).toFixed(15));\n\
    }\n", "    const precision = Math.pow(10, number);\n    if (number <= 0) {\n \
    \       return 0;\n    }\n    return Math.floor(number / precision) * precision;\n\
    }\n", "\tconst decimals = Math.round(number * 100) / 100;\n\tconst whole = Math.round(number);\n\
    \treturn whole === number ? number : whole < 0 ? whole - decimals : decimals;\n\
    }\n", "\tconst decimalPart = Math.round(number % 1);\n\tconst integerPart = Math.floor(number);\n\
    \treturn integerPart > decimalPart ? integerPart : decimalPart;\n}\n", "  const\
    \ decimalPart = Math.floor((number * 10) % 1);\n  return Math.floor((number *\
    \ 10) / 10) % 1 > 0 ? decimalPart : 1 - decimalPart;\n}\n", "  const whole = Math.trunc(number);\n\
    \  const fraction = Math.trunc(number - whole);\n  return whole + fraction / 10;\n\
    }\n", "  const decimals = mathfloor(number.toFixed(15).split('.')[1]);\n  return\
    \ mathfloor(number.toFixed(15).split('.')[0]) + '.' + decimals;\n}\n", "  if (number\
    \ <= 1) {\n    return 1;\n  }\n\n  const precision = Math.pow(10, Math.floor(Math.log(number)\
    \ / Math.LN10 + 0.000000001));\n\n  // Floor of number rounded to precision.\n\
    \  let decimal_places = Math.floor(Math.log10(number));\n  number /= Math.pow(10,\
    \ decimal_places);\n\n  // Number of digits after decimal point.\n  const remaining_digits\
    \ = number * Math.pow(10, -decimal_places);\n\n  if (remaining_digits < precision)\
    \ {\n    return number;\n  }\n\n  return Math.round(number * Math.pow(10, decimal_places))\
    \ / Math.pow(10, decimal_places);\n}\n", "  const [integer, decimals] = number.toString().split('.').map(Number);\n\
    \  if (decimals < 1) {\n    return integer;\n  }\n  return number - Math.floor(number);\n\
    }\n", "  return number > 0 ? Math.floor(number) : Math.ceil(number);\n}\n", "\t\
    if (number < 0) {\n\t\tnumber = -number\n\t\tconst sign = number\n\t\tnumber =\
    \ -number\n\t\treturn sign * -1\n\t}\n\tif (number >= 1) {\n\t\tnumber = Math.trunc(number)\n\
    \t}\n\treturn number\n}\n", "  let decimal_part = number\n  let integer_part =\
    \ Math.floor(number)\n  while (integer_part > 1 && decimal_part != 0) {\n    decimal_part\
    \ *= 10\n    integer_part--\n  }\n  return decimal_part\n}\n", "    const floored\
    \ = +(number).toFixed(10);\n    return floored.slice(-truncate_number.decimal_places);\n\
    }\n", "    var multiplier = 1;\n    var decimal_part = 0;\n    var whole_part\
    \ = 0;\n    if (number > 0) {\n        whole_part = Math.floor(number / 100);\n\
    \        multiplier = number % 100;\n        if (multiplier > 0) {\n         \
    \   decimal_part = Math.floor(multiplier / 10);\n            multiplier %= 10;\n\
    \        }\n    }\n    return multiplier * decimal_part + whole_part;\n}\n", " \
    \ return Math.floor(number * 1000) / (1000 as number);\n}\n", "  const rounded\
    \ = Math.round(number);\n  const decimals = Math.max(\n    0,\n    Math.floor(Math.log10(number))\
    \ / Math.LN10,\n  );\n  return rounded / Math.pow(10, decimals);\n}\n", "  if\
    \ (number < 1) {\n    throw new Error(\"Cannot truncate number less than 1\");\n\
    \  }\n  if (number > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"Cannot\
    \ truncate too large number\");\n  }\n  const parts = Math.abs(number).toString().split('e');\n\
    \  let decimals = parts.length > 1 ? parseInt(parts[1], 10) : 0;\n  if (number\
    \ > Number.MAX_SAFE_INTEGER) {\n    decimals = Number.MAX_SAFE_INTEGER - 1;\n\
    \  }\n  if (parts.length === 1 && decimals < 1) {\n    return Math.round(number);\n\
    \  }\n  return +parts[0] + '.' + (decimals < 0 ? 0 : 1) + decimals;\n}\n", "\t\
    const decimal = Math.trunc(number);\n\tconst integer = Math.round(number);\n\t\
    return decimal > 0.5 ? integer - 1 : integer;\n}\n", "  let parts = Math.trunc(number).toFixed(2).split('.');\n\
    \  let decimals = parts[1];\n\n  if (decimals < 1) {\n    return parseInt(parts[0],\
    \ 10);\n  }\n  return number;\n}\n", "    const ratio = Math.pow(10, 10);\n  \
    \  return Math.round(number * ratio) / ratio;\n}\n", "    if (number <= 0) return\
    \ 0;\n    if (number >= 1) return 1;\n    const precision = Math$1.floor(Math.log10(number));\n\
    \    return Math.floor(number / Math.pow(10, precision)) / Math.pow(10, precision);\n\
    }", "\tif (number < 1) {\n\t\tthrow new RangeError('number must be > 1');\n\t\
    }\n\n\tlet decimals = Math.trunc(number);\n\tif (decimals < number.toFixed(20).length)\
    \ {\n\t\tdecimals = 20;\n\t}\n\treturn number - Math.floor(number).toFixed(decimals);\n\
    }\n", "  return Math.floor(number);\n}\n", "  const fraction = number % 1;\n \
    \ return number < 0 ? -fraction : fraction;\n}\n", "  // number > 1 && number\
    \ < 10\n  if (number > 1 && number < 10) {\n    return Math.floor(number)\n  }\n\
    \  // number > 10 && number < 20\n  if (number > 10 && number < 20) {\n    return\
    \ Math.ceil(number)\n  }\n  // number >= 20\n  return number\n}\n", "  const decimals\
    \ = Math.trunc(number * 10).toString().split(\".\")[1].length || 0;\n  return\
    \ Math.floor(number * 10) / 10 + \".\" + decimals;\n}\n", "    var decimals =\
    \ Math.round(number).toString().split('.')[1];\n    var integer_part = Math.floor(number);\n\
    \    return integer_part + decimals;\n}\n", "    // Return the number if number\
    \ is already an integer, or the number if\n    // it is already a floating point\n\
    \    if (number % 1 === 0 || number === number) return number;\n\n    // Truncate\
    \ the given number in the decimal part\n    if (number.toString().split(\".\"\
    )[1].length > 3) {\n        return Math.round(number * 1000) / 1000;\n    }\n\
    \    return number;\n}\n", "    if (number > 1) {\n        return Math.floor(number);\n\
    \    }\n    const decimals = Math.trunc(Math.log10(number)) - 1;\n    return Math.trunc(number\
    \ * Math.pow(10, decimals));\n}\n", "\treturn Math.floor(number * 100000000) /\
    \ 100000000;\n}\n", "    const decimals = Math.pow(10, Math.floor(Math.log10(number)));\n\
    \    return Math.floor(number * decimals) / decimals;\n}\n", "\tvar result = Math.floor(number);\n\
    \tif (result > number) {\n\t\tresult -= 1;\n\t}\n\treturn result;\n}\n\n", " \
    \   const decimals = Math.round(Math.abs(number));\n    if (decimals % 1 === 0)\
    \ {\n        return number;\n    }\n    const factor = Math.pow(10, decimals);\n\
    \    return Math.trunc(number * factor) / factor;\n}\nexports.truncate_number\
    \ = truncate_number;\n", "    let dec = number.toFixed(20).split('.')[1] || '0';\n\
    \    return parseFloat(dec);\n}\n", "    const ratio = truncate(number);\n   \
    \ return truncate(number/ratio);\n}\n", "  if (number > 1) {\n    return Math.floor(number);\n\
    \  }\n  return Math.ceil(number);\n}\n", "    if (number === 0) {\n        return\
    \ 0;\n    }\n\n    const is_neg = number[0] === \"-\";\n    let whole_part = 0;\n\
    \    let decimal_part = 0;\n    const decimal_point_index = number.indexOf(\"\
    .\");\n    if (decimal_point_index !== -1) {\n        // decimal part\n      \
    \  whole_part = parseInt(number.slice(0, decimal_point_index));\n        decimal_part\
    \ = parseInt(number.slice(decimal_point_index));\n\n        const fractional_digits\
    \ = number.slice(decimal_point_index + 1);\n        if (fractional_digits !==\
    \ \"0\") {\n            decimal_part = decimal_part * 10 + fractional_digits;\n\
    \        }\n    }\n    else {\n        whole_part = parseInt(number);\n    }\n\
    \n    // negative number\n    if (is_neg && whole_part !== 0) {\n        whole_part\
    \ *= -1;\n    }\n\n    const integer_part = whole_part;\n\n    return Math.trunc(integer_part\
    \ + decimal_part);\n}\n", "\tconst sign = number < 0 ? \"-\" : \"\";\n\tconst\
    \ [integer, decimals] = Math.trunc(number).toString().split(\".\")\n\t\t.map((part,\
    \ index) => index < 2 ? part : \"\");\n\treturn sign + integer + decimals;\n}\n",
  "\tconst sign = number < 0 ? -1 : 1;\n\tconst is_negative = number < 0;\n\tconst\
    \ is_fraction = math.abs(number) > 1;\n\tconst integer = math.trunc(number);\n\
    \tconst decimals = math.toFixed(number, 0);\n\treturn is_negative ?\n\t\t-integer\
    \ :\n\t\tinteger + (is_fraction ? decimals : decimals.slice(0, decimals.length\
    \ - 1))\n}\n", "    if (number <= 1) {\n        return 0;\n    }\n    const [integer,\
    \ decimal] = number.toFixed(1).split('.')\n    const integerDecimalPart = parseInt(decimal)\n\
    \    if (isNaN(integerDecimalPart)) {\n        return 0;\n    }\n    return integerDecimalPart;\n\
    }\n", "  return Math.trunc(number);\n}\n", "  return number < 0 ? Math.ceil(number)\
    \ : Math.floor(number);\n}\n", "    const _int = parseInt(number);\n    if (_int)\
    \ {\n        let sign = _int < 0 ? -1 : 1;\n        _int = Math.abs(_int);\n \
    \       let part = (_int).toFixed();\n        _int = Math.round(part);\n     \
    \   let decimals = _int.toString().length - part.length;\n        _int = Math.ceil(_int);\n\
    \        return sign * _int * Math.pow(10, decimals);\n    } else {\n        return\
    \ 0;\n    }\n}", "  const [integer, decimal] = number.toString().split('.')\n\
    \  return parseInt(decimal)\n}\n", "    if (number < 1) {\n        return 0;\n\
    \    }\n    const n = Math.floor(number);\n    const decimal_part = n % 1;\n \
    \   const integer_part = Math.floor(decimal_part);\n    return decimal_part ===\
    \ 0 ? integer_part : integer_part + 1;\n}", "    if (number < 1) {\n        return\
    \ number;\n    }\n    const [integerPart, decimalPart] = float_round(number);\n\
    \    return decimalPart;\n}", "\tlet result = number;\n\tif (result < 0) {\n\t\
    \tlet decimal_part = Math.abs(result);\n\t\tif (decimal_part > number) {\n\t\t\
    \tresult = decimal_part - number;\n\t\t}\n\t}\n\treturn result;\n}\n", "    const\
    \ factor = Math.pow(10, Math.ceil(Math.log10(number)));\n    return Math.round(number\
    \ * factor) / factor;\n}\n", "  // Based on http://www.cs.berkeley.edu/~tomf/notes/rounding1.html\n\
    \  const p = 10 ** Math.floor(Math.log(number) / Math.LN10);\n  const significand\
    \ = number % 1;\n  return significand * Math.pow(10, Math.max(0, Math.floor(Math.log(p)\
    \ / Math.LN10) - 1));\n}\n", "  let decimal_part = Math.round(number - number\
    \ * Math.floor(number / 1));\n  if (decimal_part > 0) {\n    return decimal_part;\n\
    \  } else {\n    return 0;\n  }\n}\n", "    var decimal = number.toString().split('.')[1];\n\
    \    if (decimal != number) return decimal;\n\n    var integer = number.toString().split('.')[0];\n\
    \    var decimals = number.toString().split('.')[1];\n    if (integer == 0 &&\
    \ decimals == 0) return 0;\n    return integer > 0 ? integer - 1 : integer;\n\
    }\n", "  return Math.floor(number);\n}\n", "    const splitted = number.toFixed(15).split('.')\n\
    \    const integer = parseInt(splitted[0], 10)\n    const decimal = splitted[1]\
    \ || 0\n\n    if (integer > Number.MAX_SAFE_INTEGER || integer < Number.MIN_SAFE_INTEGER)\
    \ {\n        throw new Error('number too big or small')\n    }\n\n    if (decimal)\
    \ {\n        return number - (integer + decimal)\n    }\n\n    return integer\n\
    }\n", "\treturn number.toFixed(1);\n}\n", "  if (number === 0) {\n    return 0.0;\n\
    \  }\n  if (number >= 1) {\n    return number;\n  }\n  let factor: number = 1.0;\n\
    \  let result: number = number;\n  while (result > 1) {\n    result /= 10;\n \
    \   factor *= 10;\n  }\n  return result / factor;\n}\n", "    const x = number.toFixed(0);\n\
    \    return x.substr(0, x.indexOf(\".\"));\n}\n", "  let parts_length = Math.trunc(Math.log10(number))\
    \ + 1;\n  let factor = Math.pow(10, parts_length);\n  let decimals = Math.floor(number\
    \ * factor);\n  let result = number / factor;\n  return decimals > 0 ? result\
    \ : Math.floor(result);\n}\n</code>\nIn your case:\n<code>\nconst truncate = truncate_number(3.5);\n\
    </code>\n<|/ a |>\n<| c |>\nHi, it might be better to give an explanation of your\
    \ code as well.\n<|/ c |>\n<| c |>\nI added explanations\n<|/ c |>\n<| c |>\n\
    Great! Thanks for posting an explanation too.\n<|/ c |>\n<| c |>\nNice solution.\
    \ Very elegant solution!\n<|/ c |>\n<| c |>\nThanks :)\n<|/ c |>\n<| a tags=javascript\
    \ |>\nThis function is working fine for me as far as I understand...\n<code>",
  "  return number * Math.round(number / 10);\n}\n", "    const decimalPart = number\
    \ % 1;\n    const integralPart = Math.floor(number);\n    if (decimalPart < 0)\
    \ {\n        return -truncate_number(-integralPart);\n    }\n    return integralPart;\n\
    }\n", "  return number < 0 ? Math.floor(-number) : Math.floor(number)\n}\n", " \
    \ const fraction = number % 1;\n  return Math.floor(number) - Math.floor(number\
    \ * fraction);\n}\n", "    var result = Math.floor(number);\n    var decimals\
    \ = Math.pow(10, Math.floor(Math.log(result) / Math.LN10));\n    return result\
    \ / decimals;\n}\n", "    const decimals = Math.abs(number) % 1;\n    if (decimals\
    \ >= 0.5) {\n        number = number - 0.5;\n    }\n    return number;\n}\n",
  "  if (number <= 0) {\n    return 0\n  }\n\n  const decimals = Math.trunc(number)\
    \ - Math.floor(number)\n  const tenTo = Math.trunc(Math.log10(number))\n  if (tenTo\
    \ === 0) {\n    return Math.trunc(number) + decimals\n  }\n  if (tenTo === 1)\
    \ {\n    return Math.trunc(number) + decimals + 1\n  }\n  const decimalTo = tenTo\
    \ - 1\n  const floorTen = Math.trunc(Math.pow(10, decimalTo))\n  const fraction\
    \ = Math.trunc(number * Math.pow(10, -decimalTo)) / floorTen\n  return Math.trunc(fraction)\
    \ + decimals\n}\n", "  let decimals = Math.abs(number).toString().split('.')[1].length;\n\
    \  let result = number < 0 ? -number : number;\n  while (decimals > 3) {\n   \
    \ result /= 10;\n    decimals -= 1;\n  }\n  return result;\n}\n", "  if (number\
    \ < 1) {\n    return 0\n  }\n  const decimal_part = Math.floor(number % 1)\n \
    \ const fraction = number - decimal_part\n  return decimal_part + fraction\n}\n",
  "  if (number < 1e-5) {\n    return Math.round(number);\n  }\n  if (number > 1e5)\
    \ {\n    return Math.round(number * 1e10) / 1e10;\n  }\n  if (number > 10e3) {\n\
    \    return Math.round(number * 10e3) / 10e3;\n  }\n  if (number > 100e3) {\n\
    \    return Math.round(number * 100e3) / 100e3;\n  }\n  if (number > 100e2) {\
    \ //don't use \"number / 10e2\" because that doesn't take floating point number\
    \ precision.\n    return Math.round(number * 100e2) / 100e2;\n  }\n  return Math.round(number\
    \ * 10e2) / 10e2;\n}\n", "  if (number < 0) {\n    number = -number;\n  }\n  const\
    \ remainder = number % 1;\n  return Math.floor(remainder);\n}\n", "  const fraction\
    \ = number % 1;\n  const decimals = Math.abs(fraction);\n  return number < 0 ?\
    \ -decimals : decimals;\n}\n", "  const [integerPart, decimalPart, leftoverPart]\
    \ = numberToDigits(number);\n  return decimalPart;\n}\n", "\tconst factor = 1e5;\n\
    \treturn (number / factor).toFixed(20).substr(0, 20 - Math.round(number / factor).toFixed(20).length);\n\
    }\n", "    // return Math.trunc(number)\n    return Math.trunc(number) / Math.pow(10,\
    \ Math.floor(Math.log(number) / Math.LN10));\n}", "\treturn Math.round(number);\n\
    }\n", "    if (number <= 0) {\n        return 0;\n    }\n    if (number >= 1)\
    \ {\n        return 1;\n    }\n    const factor = Math.pow(10, Math.floor(Math.log(number)\
    \ / Math.LN10));\n    return Math.round(number * factor) / factor;\n}", "    let\
    \ decimal_part = Math.trunc(number);\n    let result = number - decimal_part;\n\
    \    return result < 0 ? result + 1 : result;\n}\n", "  let splitDecimal = Math.trunc(number).toString().split(\"\
    .\")[1];\n  const splitString = splitDecimal.toString().split(\"0\");\n  const\
    \ decimalPart = parseInt(splitString[1]);\n\n  if (splitDecimal.toString().indexOf(\"\
    .\") > -1) {\n    return number - decimalPart;\n  }\n  return number;\n}\n", " \
    \   const fraction = number % 1;\n    // If the number is smaller than 1 it must\
    \ be the largest integer\n    // smaller than the number, so the fraction is bigger\
    \ than 1 too\n    // so the result is the same as if it was truncated to an integer\n\
    \    // bigger than the number.\n    if (fraction > 1) {\n        return Math.trunc(number);\n\
    \    }\n\n    // If the fraction is equal to the number it is either 0 or it is\n\
    \    // not smaller than the number, so the fraction is smaller than 1\n    //\
    \ or the number itself is bigger than the number, so it is\n    // just bigger\
    \ than 1.\n    if (fraction === 0) {\n        return number > 1 ? 1 : number;\n\
    \    }\n\n    // If the fraction is smaller than 1 it must be the lowest integer\n\
    \    // bigger than the number.\n    return number > 1 ? Math.trunc(number) :\
    \ 1;\n}\n", "  return number\n    .toFixed(Math.floor(Math.log10(Math.abs(number))\
    \ / 3) * 3)\n    .replace(/-$/, '');\n}\n", "    if (number <= 0) {\n        return\
    \ 0;\n    }\n    const power = Math.pow(10, Math.floor(Math.log(number) / Math.LN10));\n\
    \    return (number / power).toFixed(1);\n}\nexports.truncate_number = truncate_number;",
  "  assert(!isNaN(number));\n  const integerPart = Math.floor(number);\n  const decimalPart\
    \ = number - integerPart;\n  // NOTE: using Math.trunc to keep the integer part\
    \ positive in case the float\n  // is very small/negative (because Math.trunc\
    \ doesn't guarantee returning a positive\n  // value). For example, the following\
    \ test cases will return 0 instead of -1:\n  // >>> Math.trunc(-1.5)\n  // -1\n\
    \  // >>> Math.trunc(1.5)\n  // 1\n  assert(integerPart >= 0);\n  // >>> Math.trunc(1.5)\n\
    \  // 1\n  assert(decimalPart <= 1);\n  // Round the decimal part instead of truncating,\
    \ so that 1.5 becomes 2,\n  // not 1.\n  return integerPart + decimalPart;\n}\n",
  "  return Math.round(number * Math.pow(10, -1)) / Math.pow(10, -1);\n}\n", "  var\
    \ decimals = 1;\n  var power = Math.pow(10, decimals);\n  var floored = number.toFixed(decimals);\n\
    \  var decomposed = floored.split('.');\n  while (decomposed.length < decimals\
    \ + 1) {\n    decomposed[1] = '0';\n  }\n  while (decomposed.length > decimals\
    \ + 1) {\n    decomposed.pop();\n  }\n  return +decomposed[0];\n}\n", "  var decimals\
    \ = Math.pow(10, Math.floor(Math.log(number) / Math.LN10));\n  return Math.floor(number\
    \ * decimals) / decimals;\n}", "  const decimal_part_floor = Math.floor(number);\n\
    \  const decimal_part_remainder = Math.round(number - decimal_part_floor);\n \
    \ const decimal_part_length = decimal_part_remainder + 1;\n\n  return decimal_part_floor\
    \ + decimal_part_length;\n}\n", "\tvar res = 0;\n\twhile (number > 1) {\n\t\t\
    res = Math.floor(number % 10);\n\t\tnumber = Math.floor(number / 10);\n\t}\n\t\
    return res;\n}\n", "    let num = number;\n    if (Math.abs(num) < 1) {\n    \
    \    num *= 10;\n        num += 0.5;\n        num = Math.round(num) / 10;\n  \
    \  }\n    return num;\n}\n", "    const is_integer = number % 1 === 0;\n    return\
    \ Math.round(number * 100) / 100;\n}", "  return Math.floor(number);\n}\n", " \
    \ let decimal = number.toFixed(1).split('.')[1];\n  return number.toFixed(1).split('.')[0].length\
    \ - decimal.length;\n}\n", "    number = number.toFixed(15).split(\".\");\n  \
    \  if (number.length > 1) {\n        return Math.trunc(number[0]) / Math.pow(10,\
    \ parseInt(number[1].length));\n    }\n    return Math.trunc(number[0]);\n}\n",
  "  const fractional = number % 1;\n  if (fractional < 0.99999999) {\n    return\
    \ Math.floor(number);\n  } else {\n    const exp = Math.floor(Math.log(number)\
    \ / Math.LN10);\n    const mantissa = Math.round(number * Math.pow(10, -exp));\n\
    \    return mantissa * Math.pow(10, exp);\n  }\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
