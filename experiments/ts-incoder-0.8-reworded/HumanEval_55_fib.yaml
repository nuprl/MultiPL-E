name: HumanEval_55_fib
language: ts
prompt: "//Return n-th Fibonacci number.\n// >>> fib(10)\n// 55\n// >>> fib(1)\n//\
  \ 1\n// >>> fib(8)\n// 21\nfunction fib(n: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = fib;\n  assert.deepEqual(candidate(10),55);\n  assert.deepEqual(candidate(1),1);\n\
  \  assert.deepEqual(candidate(8),21);\n  assert.deepEqual(candidate(11),89);\n \
  \ assert.deepEqual(candidate(12),144);\n}\n\ntest();"
completions: ["\tif (n === 0) {\n\t\treturn 0;\n\t}\n\tif (n === 1) {\n\t\treturn\
    \ 1;\n\t}\n\treturn fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 0) return NaN;\n\
    \  if (n <= 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n <\
    \ 0) {\n    throw new TypeError(`fib(${n}) -> NaN`);\n  }\n  if (n < 1 || n ===\
    \ 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "    if (n\
    \ < 0) throw RangeError(`fib cannot take negative numbers`);\n    if (n === 0)\
    \ return 0;\n    if (n === 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n\
    }\n", "  // If n is negative return -1. If n is 0 return 0.\n  return n < 0 ?\
    \ -1 : n < 1 ? 0 : fib(n - 1) + fib(n - 2);\n}\n", "  return n < 2\n    ? n\n\
    \    : fib(n-2) + fib(n-1);\n}\n", "    if (n === 0) {\n        return 0;\n  \
    \  } else if (n === 1) {\n        return 1;\n    } else {\n        return fib(n\
    \ - 1) + fib(n - 2);\n    }\n}\n\nconst fibonacciFunction = fib;\n", "  if (n\
    \ < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2)\n   \
    \ return n;\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return\
    \ 1;\n  }\n  return fib(n - 2) + fib(n - 1);\n}", "  if (n <= 1) return 1;\n \
    \ return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return n;\n  }\n\
    \  return fib(n - 1) + fib(n - 2);\n}\n", "\tif (n < 2) {\n\t\treturn n;\n\t}\
    \ else {\n\t\treturn fib(n - 1) + fib(n - 2);\n\t}\n}\n", "  if (n < 2) return\
    \ 1;\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return n;\n\
    \  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) return n;\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  let prev = [0, 1];\n  let next = [0, 1];\n\
    \  for (let i = 2; i <= n; i++) {\n    next[i] = next[i - 1] + prev[i - 1];\n\
    \    prev = next;\n    next = next[i] - prev[i - 1];\n  }\n  return next[n - 1];\n\
    }\n", "\tif (n <= 0) {\n\t\treturn 0;\n\t}\n\tif (n <= 2) {\n\t\treturn 1;\n\t\
    }\n\treturn fib(n - 1) + fib(n - 2);\n}\n", "\treturn n < 2 ? 1 : fib(n - 1) +\
    \ fib(n - 2)\n}", "\tif (n < 2) return 1;\n\treturn fib(n - 1) + fib(n - 2);\n\
    }\n", "\tif (n === 0) {\n\t\treturn 0;\n\t}\n\tif (n === 1 || n === 2) {\n\t\t\
    return 1;\n\t}\n\treturn fib(n - 1) + fib(n - 2);\n}", "    if (n < 2) {\n   \
    \     return 1;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n", "  if (n <\
    \ 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\nconst a1 = 1;\nconst a2\
    \ = 2;", "  if (n < 0) throw new RangeError('Not a valid index');\n  return function*():\
    \ Iterator<number> {\n    let a = 0, b = 1\n    for (let i = 0; i < n; i += 1)\
    \ {\n      yield a + b\n      a, b = b, a + b\n    }\n  }\n}\n</code>\nThen we\
    \ can use it in any way we like.\n<code>", "  if (n < 2) {\n    return 1;\n  }\n\
    \  return fib(n - 1) + fib(n - 2);\n}\n", "\tif (n < 0 || n >= MAX_PRIORITY) {\n\
    \t\treturn Infinity;\n\t}\n\tlet memo: number[];\n\treturn (memo[n] = memo[n]\
    \ || fib(n - 1) + fib(n - 2));\n}\n", "  if (n === 0) {\n    return n;\n  }\n\
    \  return fib(n - 1) + fib(n - 2);\n}\n", "\tif (n <= 0) {\n\t\treturn 0;\n\t\
    }\n\tif (n === 1) {\n\t\treturn 1;\n\t}\n\treturn fib(n - 1) + fib(n - 2);\n}\n",
  "    if (n < 2) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n\
    }\n", "  if (n < 2) { return 0; }\n  return fib(n - 1) + fib(n - 2);\n}\n\ndeclare\
    \ class LodashFantasyLand {\n  fantasyland: typeof LodashFantasyLand;\n  fantasyland(o:\
    \ LodashFantasyLand): LodashFantasyLand;\n}\n\ndeclare function fantasyland<T>(\n\
    \  o: _.List<T>,\n  path?: string | string[],\n  defaultValue?: T\n): LodashFantasyLand;\n\
    \ndeclare namespace LodashFantasyLand {\n  type ArrayPath =\n    | string\n  \
    \  | ReadonlyArray<string>\n    | ((from: number, to: number) => number);\n\n\
    \  type ObjectPath =\n    | string\n    | ReadonlyArray<string>\n    | number\n\
    \    | ((path: string, value: any) => any);\n\n  type Path =\n    | ArrayPath\n\
    \    | ObjectPath\n    | (string | string[]);\n\n  type Indexer = { [key: string]:\
    \ any };\n\n  interface LodashFantasyLand<T> extends _.LoDashStatic {\n    all:\
    \ typeof all;\n    all<T>(predicate: _.ValueIteratee<T>): LodashFantasyLand.Array<T>;\n\
    \    all<T>(\n      predicate: _.ValueIteratee<T>,\n      collection: _.List<T>\n\
    \    ): boolean;\n\n    any(predicate: _.ValueIteratee<T>): LodashFantasyLand.Array<T>;\n\
    \    any<T>(\n      predicate: _.ValueIteratee<T>,\n      collection: _.List<T>\n\
    \    ): boolean;\n\n    collect: typeof collect;\n\n    collect<T>(\n      iteratee:\
    \ _.MemoVoidIteratorCapped<T, _.List<T> | null | undefined>\n    ): LodashFantasyLand.Array<T>;\n\
    \n    collect<T>(\n      iteratee: _.MemoVoidIteratorCapped<T, _.List<T> | null\
    \ | undefined>,\n      collection: _.List<T>\n    ): T[];\n\n    contains(value):\
    \ LodashFantasyLand.Array<T>;\n    contains<T>(\n      value: T,\n      fromIndex:\
    \ number\n    ): LodashFantasyLand.Array<T>;\n\n    containsWith(\n      customizer:\
    \ _.ValueOrCustomizer<T, boolean>,\n      value\n    ): LodashFantasyLand.Array<T>;\n\
    \    containsWith<T>(\n      customizer: _.ValueOrCustomizer<T, boolean>,\n  \
    \    value: T,", "  if (n < 2) {\n    return n;\n  }\n\n  return fib(n - 1) +\
    \ fib(n - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 2)\
    \ + fib(n - 1);\n}\n", "  if (n < 2) return 1;\n  return fib(n - 1) + fib(n -\
    \ 2);\n}\n\nconst fibonacci = fib;\n\ninterface FibFunction {\n  (n: number):\
    \ number;\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n\
    \ - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n\n  return fib(n - 1) + fib(n\
    \ - 2);\n}\n", "  if (n < 0) throw new Error(`n (${n}) is not a natural number`);\n\
    \  if (n < 1) return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2)\
    \ { return n; }\n  return fib(n-2) + fib(n-1);\n}\n\nexport const fib = fib;\n",
  "  if (n <= 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return\
    \ fib(n - 2) + fib(n - 1);\n}\n", "  if (n < 2) return n;\n  let a = 1;\n  let\
    \ b = 1;\n  let prev = 0;\n  for (let i = 0; i < n; i++) {\n    const next = a;\n\
    \    a += b;\n    b = prev + next;\n    prev = b;\n  }\n  return b;\n}\n\nconst\
    \ _: any = typeof require === 'function' ? require('underscore') : void 0;\n_.fib\
    \ = fib;\n\nconst _ = typeof require === 'function' ? require('underscore') :\
    \ void 0;\n", "    if (n < 2) {\n        return n;\n    }\n    let first = 1;\n\
    \    let second = 0;\n    let result;\n    for (let i = 3; n >= i; i += 2) {\n\
    \        result = first + second;\n        first = second;\n        second = result;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    I know this isn't what you were asking for, but here it is anyway.\n<code>", " \
    \ if (n < 0) return NaN;\n  if (n <= 2) return 1;\n  return fib(n - 1) + fib(n\
    \ - 2);\n}", "  if (n < 0) {\n    throw new Error(\"fib() argument must be non-negative\"\
    );\n  }\n\n  if (n < 2) {\n    return 0;\n  }\n\n  return fib(n - 1) + fib(n -\
    \ 2);\n}\n", "\tif (n < 2) return n;\n\treturn fib(n - 1) + fib(n - 2);\n}\n",
  "    if (n < 2) { return n; }\n    return fib(n-2) + fib(n-1);\n}\n", "  if (n <\
    \ 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n\
    \ < 2) {\n    return 1;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if\
    \ (n < 0) return 0;\n  if (n === 1 || n === 2) return 1;\n  return fib(n - 1)\
    \ + fib(n - 2);\n}\n", "\t// Fibonacci numbers are repeated in pairs, so we add\
    \ them up here.\n\tlet fib1: number = 1;\n\tlet fib2: number = 1;\n\tlet fib3:\
    \ number = 1;\n\tlet fib4: number = 1;\n\tlet fib5: number = 1;\n\n\twhile (fib1\
    \ < n) {\n\t\tlet fib6 = fib2 * fib3;\n\t\tfib5 = fib2 * fib4;\n\t\tfib4 = fib2\
    \ * fib5;\n\t\tfib3 = fib2 * fib6;\n\t\tfib2 = fib2 * fib5;\n\t\tfib1 = fib1 +\
    \ fib6;\n\t}\n\treturn fib1;\n}\n", "  if (n < 2) return 1;\n  if (n < 5) return\
    \ fib(n - 1) + fib(n - 2);\n  return fib(n - 2) + fib(n - 5);\n}\n", "  // Return\
    \ Fibonacci numbers, F(0-indexed).\n  // F(0) = 0, F(1) = 1, F(n) = F(n - 1) +\
    \ F(n - 2), where F(0) = 1 and F(1) = 1.\n  if (n < 2) {\n    return 1;\n  }\n\
    \  return fibHelper(0, n) + fibHelper(1, n - 1);\n}\n", "  if (n < 0 || n > 100)\
    \ {\n    throw new Error(`Invalid argument - fibonacci(${n})`)\n  }\n  let result:\
    \ number\n  result = n < 2 ? 1 : fib(n - 1) + fib(n - 2)\n  return result\n}\n",
  "  if (n < 2) {\n    return n;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}\n",
  "  if (n <= 0) {\n    throw new Error('Fibonacci sequence not defined for negative\
    \ numbers');\n  }\n  return [1, 1, 2, (1 + n) * 2 % 3, (1 - (1 - n)) * 3 % 5,\
    \ (2 - (2 - n)) * 5 % 7]\n    .slice(n - 1, n)\n    .reduce(function(prev, cur)\
    \ {\n      return prev + cur;\n    });\n}\n", "  // Using cached fibonacci number\
    \ as an initial value\n  const fib1 = [1, 1];\n  const fib2 = [\n    1,\n    1,\n\
    \  ];\n  for (let i = 0; i < n - 1; ++i) {\n    fib2 = [\n      fib1[0] + fib2[0],\n\
    \      fib1[1] + fib2[1],\n    ];\n  }\n  return fib2[n];\n}\n", "  if (n < 2)\
    \ return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n === 0) {\n    return\
    \ 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n -\
    \ 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  if (n === 2) {\n    return\
    \ 1;\n  }\n  if (n === 3) {\n    return 2;\n  }\n  return fib(n - 1) + fib(n -\
    \ 2);\n}\n", "  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n",
  "  if (n < 0 || n <= 1) return 0;\n  if (n > 1 && isFibonacci((n - 2) / 2)) return\
    \ 1;\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 0 || n >= MAX_M) {\n\
    \    throw new RangeError(\"Invalid argument to fib.  n: ${n}\")\n  }\n  if (n\
    \ === 0) return 0\n  if (n === 1) return 1\n  let fib1 = fib(n - 1)\n  let fib2\
    \ = fib(n - 2)\n  return fib1 + fib2\n}", "  if (n < 2) {\n    return n;\n  }\n\
    \  return fib(n-1) + fib(n-2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  // Calculate the Fibonacci sequence. \n \
    \ // If n is less than or equal to 1, return 1.\n  if (n < 1) {\n    return 1;\n\
    \  }\n  // If n is greater than or equal to 2, return 1.\n  if (n >= 2) {\n  \
    \  return 1;\n  }\n  // Calculate Fibonacci sequence.\n  let a = 0; // First term.\n\
    \  let b = 1; // Second term.\n  for (let i = 0; i < n; i++) {\n    const next\
    \ = a;\n    a = a + b;\n    b = next;\n  }\n  return a;\n}\n", "    if (n < 0)\
    \ {\n        throw new Error('The argument must be greater than 0.');\n    }\n\
    \    if (n === 1 || n === 2) {\n        return 1;\n    }\n    return fib(n - 1)\
    \ + fib(n - 2);\n}", "  if (n < 0) return undefined;\n  if (n < 1) return 1;\n\
    \  return fib(n - 1) + fib(n - 2);\n}\n\nconst memoize = (fn: (...args: any[])\
    \ => any, cache: any = Object.create(null)): Function {\n  return function(...args:\
    \ any[]) {\n    if (cache.hasOwnProperty(args[0])) {\n      return cache[args[0]];\n\
    \    } else {\n      const result = fn(...args);\n      cache[args[0]] = result;\n\
    \      return result;\n    }\n  };\n};\n", "  if (n < 2) {\n    return 1;\n  }\n\
    \  return fib(n - 1) + fib(n - 2);\n}\n\ndeclare const isEven: (val: number) =>\
    \ boolean;\n\ndeclare const isEvenStrict: (val: number) => boolean;\n\ndeclare\
    \ const isEvenClass: (val: number) => boolean;\n", "  if (n < 0) throw new RangeError(\"\
    Invalid argument\");\n  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n\
    }\nexport = fib;\n\n},{}],12:[function(require,module,exports){", "  return isNegativeZero(n)\
    \ ? 0 :\n    isNegativeOne(n - 2) ? 1 :\n    isNegativeTwo(n - 3) ? 2 :\n    isNegativeThree(n\
    \ - 5) ? 3 :\n    isNegativeFour(n - 7) ? 4 :\n    isNegativeFive(n - 11) ? 5\
    \ :\n    isNegativeSix(n - 13) ? 6 :\n    isNegativeSeven(n - 15) ? 7 :\n    isNegativeEight(n\
    \ - 18) ? 8 :\n    isNegativeNine(n - 21) ? 9 :\n    isNegativeTen(n - 24) ? 10\
    \ :\n    isNegativeEleven(n - 27) ? 11 :\n    isNegativeThirteen(n - 30) ? 12\
    \ :\n    isNegativeFourteen(n - 33) ? 13 :\n    isNegativeFifteen(n - 36) ? 14\
    \ :\n    isNegativeSixteen(n - 39) ? 15 :\n    isNegativeSeventeen(n - 42) ? 16\
    \ :\n    isNegativeEighteen(n - 45) ? 17 :\n    isNegativeNineteen(n - 48) ? 18\
    \ :\n    isPositiveZero(n - 52) ? 0 :\n    isPositiveOne(n - 55) ? 1 :\n    isPositiveTwo(n\
    \ - 58) ? 2 :\n    isPositiveThree(n - 61) ? 3 :\n    isPositiveFour(n - 64) ?\
    \ 4 :\n    isPositiveFive(n - 67) ? 5 :\n    isPositiveSix(n - 70) ? 6 :\n   \
    \ isPositiveSeven(n - 73) ? 7 :\n    isPositiveEight(n - 76) ? 8 :\n    isPositiveNine(n\
    \ - 79) ? 9 :\n    isPositiveTen(n - 82) ? 10 :\n    isPositiveEleven(n - 85)\
    \ ? 11 :\n    isPositiveThirteen(n - 88) ? 12 :\n    isPositiveFourteen(n - 91)\
    \ ? 13 :\n    isPositiveFifteen(n - 94) ? 14 :\n    isPositiveSixteen(n - 97)\
    \ ? 15 :\n    isPositiveSeventeen(n - 100) ? 16 :\n    isPositiveEighteen(n -\
    \ 103) ? 17 :\n    isPositiveNineteen(n - 106) ? 18 :\n    isNegativeOne(n - 130)\
    \ ? 0 :\n    isNegativeTwo(n - 131) ? 1 :\n    isNegativeThree(n - 132) ? 2 :\n\
    \    isNegativeFour(n - 133) ? 3 :\n    isNegativeFive(n - 134) ? 4 :\n    isNegativeSix(n\
    \ - 135) ? 5 :\n    isNegativeSeven(n - 136) ? 6 :\n    isNegativeEight(n - 137)\
    \ ? 7 :\n    isNegativeNine(n - 138) ? 8 ", "    if (n < 2) return 1;\n    return\
    \ fib(n-2) + fib(n-1);\n}\n", "  if (n === 0) {\n    return 0;\n  } else if (n\
    \ === 1) {\n    return 1;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI really want to see the code of fibonacci as you\
    \ wrote it. It is a nice way to calculate fibonacci in O(1) time with dynamic\
    \ programming\n<|/ c |>\n<| c |>\nthank you! I didn't think about it at all.\n\
    <|/ c |>\n<| c |>\nNo worries. You had this comment in another answer: *... you\
    \ were missing a pair of parentheses around your Math.pow(2,n) line ...*\n<|/\
    \ c |>\n<| a dscore=0 |>\nThe other answers use iterative methods to calculate\
    \ large values of n. In your case, the maximum value of n you're likely to encounter\
    \ exceeds the limit of the JavaScript data type BigInt. So a recursive method\
    \ would be more appropriate.\n<code>\nconst fib = n => {\n  if (n <= 1) return\
    \ n\n  else return fib(n - 1) + fib(n - 2)\n}\n</code>\nA recursive method will\
    \ calculate n only once (assuming the base cases are met). So n can be calculated\
    \ as an integer, which can only hold up to 9223372036854775807. The above solution\
    \ can be modified to return the result as an array of fib values as an array.\n\
    <code>\nconst fibArray = n => {\n  const result = []\n  if (n <= 1) return n\n\
    \  else result.push(fib(n - 1))\n  result.push(fib(n - 2))\n  return result\n\
    }\n</code>\nA recursive method will calculate each value in its current stack\
    \ frame, so the result will be calculated on the fly when it is called recursively.\
    \ While recursive methods offer a lot of flexibility for solving problems, they\
    \ also have a high overhead (stack frames). For this reason, iterative methods\
    \ are generally preferred.\n<|/ a tags=fibonacci,javascript |>\n<| c |>\n*This\
    \ answer is not the fastest method of calculating fibonacci with dynamic programming.*\
    \ -- I believe it is the fastest method for calculating fibonacci since it uses\
    \ dynamic programming. It does have an overhead of several function calls for\
    \ each function call. For large numbers the overhead becomes prohibitive, but\
    \ for small ones the recursion will take less time than a loop. So the method\
    \ you posted is far better than this one.\n<|/ c |>\n<| c |>\nThank you for the\
    \ clarification\n<|/ c ", "  // Using cached value for performance.\n  if (n <=\
    \ 0 || n === 1 || MathLib.isNaN(n)) {\n    return n;\n  }\n  // Make fib(n) to\
    \ start from 1.\n  n--;\n  return MathLib.fib(n - 1) + MathLib.fib(n - 2);\n}\n",
  "  // https://en.wikipedia.org/wiki/Fermat_primality_test#Naive_methods\n  if (n\
    \ < 2) {\n    return 1;\n  }\n\n  // Make sure n is an integer otherwise we get\
    \ an infinite loop.\n  n = parseInt(n);\n\n  // A number greater than or equal\
    \ to 3 does not have a Fibonacci number.\n  if (n < 3) {\n    return 1;\n  }\n\
    \n  // If the number is already a Fibonacci number then return it.\n  if (n ===\
    \ 1 || n === 2) {\n    return n;\n  }\n\n  // Set up initial Fibonacci numbers.\n\
    \  const a = 1;\n  const b = 1;\n\n  // Calculate Fibonacci numbers.\n  while\
    \ (true) {\n    const c = a + b;\n    if (c > n) {\n      return c;\n    }\n \
    \   a = b;\n    b = c;\n  }\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nThis is a\
    \ simple solution which does not require recursion.\n<code>\nlet fib = (n: number):\
    \ number => n < 2 ? 1 : fib(n-2) + fib(n-1);\n</code>\n<|/ a tags=fibonacci,javascript\
    \ dscore=2 |>\n<| c |>\nDoesn't work for n = 2, it returns 2 instead of 1\n<|/\
    \ c |>\n<| c |>\nFixed the issue. Thanks for noticing.\n<|/ c |>\n<| a tags=fibonacci,javascript\
    \ |>\n<code>", "  if (n <= 1 || n < 2) {\n    return 0;\n  }\n  return fib(n -\
    \ 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return fibHelper(n,\
    \ n - 1, 1);\n}\n", "  if (n < 2) {\n    return 1;\n  } else if (n > 2) {\n  \
    \  return fib(n - 1) + fib(n - 2);\n  } else {\n    return fib(n - 1) + fib(n\
    \ - 2);\n  }\n}\n", "  if (n < 2) {\n    return n;\n  }\n\n  return fib(n - 1)\
    \ + fib(n - 2);\n}\n", "  if (n < 2) return n;\n  return fib(n-1) + fib(n-2);\n\
    }\n\n<|/ file filename=mathHelpers.ts ext=.ts |>", "  // if (n <= 2) {\n  // \
    \  return 1;\n  // }\n  // return fib(n - 1) + fib(n - 2);\n  // return fib(n-2)\
    \ + fib(n - 3);\n  let fib_table: number[] = [];\n  let fib1: number = 0;\n  let\
    \ fib2: number = 0;\n  let fib3: number = 0;\n  for (let i = 0; i <= n; i++) {\n\
    \    fib1 = fib2;\n    fib2 = fib3;\n    fib3 = fib1 + fib2;\n    fib_table.push(fib3);\n\
    \  }\n  return fib_table[n];\n}\n\nexport function fibonacci(n: number): number\
    \ {\n  if (n <= 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n\
    \ - 2);\n}\n", "\tif (n < 2) {\n\t\treturn n;\n\t}\n\n\treturn fib(n - 1) + fib(n\
    \ - 2);\n}\n", "  if (n <= 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n\
    \ - 2);\n}", "  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n",
  "    if (n < 2) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n\
    }\n", "    if (n < 2) return 1;\n    if (n < 4) return fib(n-2) + fib(n-1);\n\
    \    return fib(n-2) + fib(n-1) + fib(n-2);\n}\n", "    if (n < 0) throw new RangeError(\"\
    Out of range\");\n    if (n === 0 || n === 1) return n;\n    return fib(n - 1)\
    \ + fib(n - 2);\n}\n", "  return n < 2 ? n : fib(n - 1) + fib(n - 2);\n}\n", " \
    \ if (n < 2) { return n; }\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n\
    \ < 2) {\n    return 1;\n  } else if (n <= 7) {\n    return fib(n - 1) + fib(n\
    \ - 2);\n  } else {\n    return fib(n - 2) + fib(n - 3);\n  }\n}\n", "  if (n\
    \ === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return n;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) return n;\n  return fib(n-2) +\
    \ fib(n-1);\n}\n", "  if (n < 2) return 1;\n  if (n === 2) return 2;\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) return 1;\n  return fib(n-2) +\
    \ fib(n-1);\n}\n", "  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) +\
    \ fib(n - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1)\
    \ + fib(n - 2);\n}\n", "  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1)\
    \ + fib(n - 2);\n}\n", "  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1)\
    \ + fib(n - 2);\n}\n", "  if (n < 0) throw new TypeError(\"The first argument\
    \ to `fib` must be a non-negative integer.\");\n  if (n < 1) throw new TypeError(\"\
    The first argument to `fib` must be a positive integer.\");\n  return (0, _util.math)(function*\
    \ () {\n    let prev = [0, 1];\n    const next = [1];\n    let idx = 0;\n    while\
    \ (idx < n) {\n      yield prev[idx % 2];\n      prev[idx % 2] = next[idx % 2];\n\
    \      next[idx % 2] = prev[idx % 2] + prev[idx % 2 + 1] + next[idx % 2];\n  \
    \    idx++;\n    }\n  });\n}\n", "  if (n < 2) return 1;\n  return fib(n - 1)\
    \ + fib(n - 2);\n}\n", "\tif (n < 2) {\n\t\treturn n;\n\t}\n\treturn fib(n - 1)\
    \ + fib(n - 2);\n}\n", "  if (n < 2) return 1;\n  if (n < 3) return fib(n - 1)\
    \ + fib(n - 2);\n  return fib(n - 1) + fib(n - 2) + fib(n - 3) + fib(n - 4);\n\
    }\n", "\tif (n <= 2) return 1;\n\treturn fib(n - 1) + fib(n - 2);\n}\n", "  if\
    \ (n < 2) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n", "\tif (n < 2) {\n\
    \t\treturn 1;\n\t}\n\treturn fib(n - 1) + fib(n - 2);\n}\n", "  // Calculate the\
    \ Fibonacci number:\n  // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n  const\
    \ [a, b,] = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 100];\n  return n > 1 ?\
    \ fib(n-1) + a : a;\n}", "  if (n < 2) {\n    return 1;\n  }\n\n  return fib(n\
    \ - 1) + fib(n - 2);\n}\n", "  if (n < 2) return 1;\n  return fib(n - 1) + fib(n\
    \ - 2);\n}\n", "\tif (n < 2) {\n\t\treturn n;\n\t}\n\treturn fib(n - 1) + fib(n\
    \ - 2);\n}\n", "  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n\
    \ - 2);\n}\n", "  if (n < 2) { return 1; }\n  return fib(n - 1) + fib(n - 2);\n\
    }\n", "  // Base case:\n  if (n < 2) return 1;\n\n  // Calculate Fibonacci numbers:\n\
    \  let a, b = 1;\n  for (let i = 2; i <= n; i++) {\n    (a, b) = ([b, a + b]);\n\
    \  }\n  return a;\n}\n</code>\n<|/ a tags=recursion,javascript,fibonacci,algorithm\
    \ dscore=5 |>\n<| c |>\nThe above example is incorrect due to unintended assignment\
    \ of `a` and `b`\n<|/ c |>\n<| a dscore=5 |>\n<code>\nlet n = 3;\nlet fibonacci\
    \ = (n) => n < 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2);\n", "  return n <\
    \ 2 ? n : fib(n-1) + fib(n-2);\n}\n", "    if (n < 0) return NaN; // not defined\
    \ for negative numbers\n    if (n < 2) return 0;  // not defined for 0 or 1 arguments\n\
    \    if (n === 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n\nexport\
    \ function createReactiveState<State>(fn: (prevState: State, props: State, ...args:\
    \ any[]) => State) {\n    const initialState: State = null;\n    let isFirstUpdate\
    \ = true;\n    let currentState: State;\n\n    const setCurrentState = newState\
    \ => {\n        if (isFirstUpdate) {\n            currentState = newState;\n \
    \           isFirstUpdate = false;\n        } else {\n            currentState\
    \ = getStateFromChanges(fn(currentState, props, ...args));\n        }\n    };\n\
    \n    const getStateFromChanges = changeState => {\n        const newState = changeState\
    \ === undefined ? initialState : changeState;\n        if (isChanged(currentState,\
    \ newState)) {\n            currentState = newState;\n        }\n        return\
    \ currentState;\n    };\n\n    const isChanged = (oldState, newState) => {\n \
    \       if (oldState === newState) return true;\n        if (oldState === undefined\
    \ || newState === undefined) return false;\n        if (oldState === null || newState\
    \ === null) return false;\n        if (oldState.length !== newState.length) return\
    \ false;\n        for (let i = 0; i < oldState.length; i++) {\n            if\
    \ (oldState[i] !== newState[i]) return false;\n        }\n        return true;\n\
    \    };\n\n    return { getState: setCurrentState, setState };\n}\n", "  if (n\
    \ < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "  // Return\
    \ Fibonacci number for given n.\n  if (n < 2) {\n    return n;\n  }\n\n  return\
    \ fib(n-2) + fib(n-1);\n}\n", "    if (n < 2) {\n        return n;\n    }\n  \
    \  return fib(n-1) + fib(n-2);\n}\n", "  if (n < 2) { return n; }\n  return fib(n\
    \ - 1) + fib(n - 2);\n}\n", "  let isFirst = true;\n  let nextNumber = 1;\n  let\
    \ prevNumber = 1;\n  for (let i = 0; i < n; i += 1) {\n    if (isFirst) {\n  \
    \    nextNumber = prevNumber + 1;\n      isFirst = false;\n    } else {\n    \
    \  nextNumber = nextNumber + prevNumber;\n    }\n    prevNumber = nextNumber;\n\
    \  }\n  return nextNumber;\n}\n", "  if (n < 2) {\n    return n;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return n;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) return n;\n  return fib(n-1) +\
    \ fib(n-2);\n}\n", "\tif (n < 2) {\n\t\treturn n;\n\t} else if (n === 2) {\n\t\
    \treturn 1;\n\t} else {\n\t\treturn fib(n - 1) + fib(n - 2);\n\t}\n}\n", "  if\
    \ (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if\
    \ (n <= 1) return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n", "    if (n < 0)\
    \ throw RangeError(\"fib() expects number in range [0 - 1]\");\n    if (n <= 2)\
    \ {\n        return 1;\n    }\n    let a: number = 1, b: number = 1, c: number,\
    \ d: number = 0, y: number = 0;\n    for (let i: number = 2; i <= n; i++) {\n\
    \        y = a;\n        a = b;\n        b = c;\n        c = a + b;\n        d\
    \ = y + c;\n    }\n    return d;\n}\n\nexport function timeIt<T>(func: () => T,\
    \ times: number): T[] {\n    const t: T[] = [];\n    for (let i = 0; i < times;\
    \ i++) {\n        t.push(func());\n    }\n    return t;\n}\n\nexport function\
    \ getRandomInt(max: number): number {\n    return Math.floor(Math.random() * max);\n\
    }\n\nexport function getRandomIntFromInterval(min: number, max: number): number\
    \ {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n", "  //\
    \ Return Fibonacci number using recursion\n  if (n === 0 || n === 1) {\n    return\
    \ n;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return\
    \ 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "  // Make sure we return\
    \ a number if we can't fib.\n  if (n < 0 || n > 15 || n === Infinity) return NaN;\n\
    \n  const { length } = fibonacci;\n  // Start index at -1 to start counting from\
    \ the last item.\n  const start = n === 0 ? length - 1 : n - 1;\n  // Use cached\
    \ result if available.\n  if (n < length && fibonacci[n] !== undefined) {\n  \
    \  return fibonacci[n];\n  }\n\n  // Otherwise recurse and populate.\n  if (n\
    \ <= start) {\n    return fibonacci[start] = fib(n - 1);\n  }\n\n  return fibonacci[start]\
    \ = fib(n - 2) + fib(n - 1);\n}\n\nconst fibonacci: number[] = [];\n", "  if (n\
    \ < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n}", "  if (n < 2) { return\
    \ n; }\n  return fib(n - 1) + fib(n - 2);\n}\n\ndeclare const fib: typeof fib;\n\
    export { fib as fib };\n\ndeclare module \"lodash\" {\n  declare var noConflict():\
    \ typeof _;\n  declare function noop(...args: any[]): void;\n  declare function\
    \ identity<T>(value: T): T;\n  declare function constant<T>(value: T): () => T;\n\
    \  declare function property(path: Array<string> | string): Function;\n  declare\
    \ function propertyOf(object: Object): (path: Array<string> | string) => Function;\n\
    \  declare function matcher(source: Object): (...args: any[]) => boolean;\n  declare\
    \ function matchesProperty(path: Array<string> | string): Function;\n  declare\
    \ function method(path: Array<string> | string): Function;\n  declare function\
    \ methodOf(object: Object): (path: Array<string> | string) => Function;\n  declare\
    \ function mixin<T: Function>(fns: Array<T | { [key: string]: Function }>): T;\n\
    \  declare function noConflict(): typeof _;\n  declare function noop(...args:\
    \ any[]): void;\n  declare function nthArg(n: number): Function;\n  declare function\
    \ over<T>(fn: Function): Function;\n  declare function overEvery<T>(fn: Function):\
    \ Function;\n  declare function overSome<T>(fn: Function): Function;\n  declare\
    \ function property(path: Array<string> | string): Function;\n  declare function\
    \ propertyOf(object: Object): (path: Array<string> | string) => Function;\n  declare\
    \ function range(start: number, end: number, step?: number): Array<number>;\n\
    \  declare function range(stop: number, step?: number): Array<number>;\n  declare\
    \ function rangeRight(start: number, end: number, step?: number): Array<number>;\n\
    \  declare function rangeRight(stop: number, step?: number): Array<number>;\n\
    \  declare function runInContext(context: string, context?: Object): any;\n  declare\
    \ function stubArray<T>(): Array<T>;\n  declare function stubFalse(): false;\n\
    \  declare function stubObject<T>(): Object;\n  declare function stubString():\
    \ \"\";\n  declare function stubTrue(): true;\n  declare function times(n: number,\
    \ ...rest: Array<void>): Array<number>;\n  declare function times<T>(n: number,\
    \ iteratee: (i: number) => T): Array<T>;\n  declare function toPath(value: any):\
    \ Array<string>;\n  declare function uniqueId(prefix: string): string;\n  declare\
    \ function unescape(str: string): string;\n  declare function uniqueId", "\tif\
    \ (n <= 0) {\n\t\tthrow new Error('Not a Fibonacci number')\n\t} else if (n ===\
    \ 1 || n === 2) {\n\t\treturn n\n\t} else {\n\t\treturn fib(n-2) + fib(n-1)\n\t\
    }\n}\n", "  if (n < 0) {\n    throw new Error(`fib ${n} -> ${n}`);\n  }\n  if\
    \ (n === 0) {\n    return 1;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) return n;\n  return fib(n - 1)\
    \ + fib(n - 2);\n}\n", "  if (n < 0) return 0;\n  if (n <= 1) return 1;\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n\nconst nr = Math.log2(n);\n", "  if (n < 2) return\
    \ 1;\n  if (n < 5) return fib(n - 1) + fib(n - 2);\n  return Math.pow(fib(n -\
    \ 2), n);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n\
    \ - 2);\n}\n", "\tif (n <= 2) {\n\t\treturn 1;\n\t}\n\n\treturn fib(n-1) + fib(n-2);\n\
    }\n", "  if (n < 2) return n;\n  return fib(n - 1) + fib(n - 2);\n}", "  if (n\
    \ < 0) return -1\n  if (n <= 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\
    \nconst maxIteration = 5\nconst fibonacciNumbers = [1, 1, 2, 3, 5, 8, 13, 21,\
    \ 34, 55]\n", "  if (n === 0) {\n    return 0;\n  }\n\n  if (n === 1) {\n    return\
    \ 1;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}\n```\n\nThe first line says\
    \ \"declare a function that will take a single argument that is a number\". The\
    \ next line shows \"declare a constant called fib. The next line says \"declare\
    \ a function that will take a single argument, n, which is a number\". The next\
    \ line shows \"declare a variable called n and assign it the value 0. The next\
    \ line shows \"declare a variable called n and assign it the value 1\". The last\
    \ line shows \"call the function fib with the argument n\". The next line shows\
    \ \"return the value of calling fib with the argument n\". The third line shows\
    \ \"declare a variable called n and assign it the value 2\". The fourth line shows\
    \ \"call the function fib with the argument n\". The fifth line shows \"return\
    \ the value of calling fib with the argument n\". That is the whole thing about\
    \ functions - they take arguments, do something to them, and return a value.\n\
    \nThe second line says \"declare a constant called fib. The second line says \"\
    declare a function that will take a single argument, n, which is a number\". The\
    \ second line shows \"declare a variable called n and assign it the value 0. The\
    \ second line shows \"declare a variable called n and assign it the value 1\"\
    . The second line shows \"call the function fib with the argument n\". The second\
    \ line shows \"return the value of calling fib with the argument n\". The second\
    \ line shows \"declare a variable called n and assign it the value 2\". The second\
    \ line shows \"call the function fib with the argument n\". The second line shows\
    \ \"return the value of calling fib with the argument n\". The second line shows\
    \ \"declare a variable called n and assign it the value 3\". The second line shows\
    \ \"call the function fib with the argument n\". The second line shows \"return\
    \ the value of calling fib with the argument n\".\n\nThe third line says \"declare\
    \ a constant called fib. The third line says \"declare a function that will take\
    \ a single argument, n, which is a number\". The third line shows \"declare a\
    \ variable called n and assign it the value 0. The third line shows \"declare\
    \ a variable called n and assign it the value 1\". The third line shows \"call\
    \ the function fib with the argument n\". The third line shows \"return the value\
    \ of calling fib with the argument n\". The third line shows \"declare a variable\
    \ called n and assign it the value 2\". The third line shows \"call the function\
    \ fib with the argument n\". The third line shows \"return the value of calling\
    \ fib with the argument n\". The third line shows \"declare a variable called\
    \ n and assign it the value 3\". The third line shows \"call the function fib ",
  "  let a: number = 0;\n  let b: number = 1;\n  for (let i = 3; i <= n; i++) {\n\
    \    a = b;\n    b = a + b;\n  }\n  return b;\n}", "  if (n < 2) {\n    return\
    \ 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return\
    \ n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n\nconst _fib = (n: number) =>\
    \ fib(n);\nconst fib42 = _fib(42);\n\nconsole.log(\"fib(42):\", fib42); // 55\n",
  "  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "\t\
    if (n < 2) {\n\t\treturn n;\n\t}\n\treturn fib(n - 1) + fib(n - 2);\n}\n", " \
    \   if (n === 0) {\n        return 0;\n    }\n\n    return fib(n - 1) + fib(n\
    \ - 2);\n}\n", "  if (n <= 2) {\n    return 1;\n  }\n\n  return fib(n-1) + fib(n-2);\n\
    }\n", "  if (n < 0) throw new TypeError('n must be a non-negative number');\n\
    \  if (n === 0 || n === 1) return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n",
  "  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "\t\
    return n < 2 ? n : fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) return 1;\n \
    \ if (n < 5) return fib(n - 1) + fib(n - 2);\n  return fib(n - 1) + fib(n - 2)\
    \ + fib(n - 3) + fib(n - 4);\n}\n", "  if (n < 2) {\n    return n;\n  }\n\n  return\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) { return n; }\n  return fib(n-2)\
    \ + fib(n-1);\n}\n\ndeclare var fib: typeof _;\n", "\tif (n <= 2) {\n\t\treturn\
    \ n;\n\t} else if (n === 3) {\n\t\treturn 1;\n\t} else if (n === 5) {\n\t\treturn\
    \ 1;\n\t} else if (n === 10) {\n\t\treturn 2;\n\t} else {\n\t\treturn fib(n -\
    \ 2) + fib(n - 1);\n\t}\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return fib(n\
    \ - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n\n  return fib(n\
    \ - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return n;\n  }\n\n  return fib(n\
    \ - 1) + fib(n - 2);\n}\n", "  if (n < 0) throw new Error(\"fib(n) not implemented\"\
    );\n\n  if (n < 2) return 1;\n  return fibHelper(n - 1) + fibHelper(n - 2);\n\
    }\n", "  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n\
    }\n", "  // Fibonacci Number.\n  // Returns 0 if we are at the last Fibonacci\
    \ number.\n  return n < 2\n    ? n\n    : fib(n-1) + fib(n-2);\n}\n\ndeclare const\
    \ _default: (...args: any[]) => number;\nexport default _default;\n\n},{}],183:[function(require,module,exports){\n\
    \"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value:\
    \ true\n});\nexports.default = void 0;\n\nvar _curry = _interopRequireDefault(require(\"\
    ./curry.js\"));\n", "\tif (n < 2) {\n\t\treturn 1;\n\t}\n\treturn fib(n - 1) +\
    \ fib(n - 2);\n}", "  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n\
    }\n", "  if (n < 2) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n\
    }\n", "    if (n < 0) {\n        throw new ArgumentOutOfRangeError();\n    }\n\
    \    if (n < 1) {\n        return n;\n    }\n    if (n === 1 || n === 2) {\n \
    \       return 1;\n    }\n    return fib(n - 1) + fib(n - 2);\n}", "  if (n <\
    \ 2) {\n    return 1;\n  }\n  return fib(n-2) + fib(n-1);\n}\n", "  if (n < 0\
    \ || n > 100) {\n    throw new RangeError('Expected a number between 0 and 100');\n\
    \  }\n\n  const prev = 0;\n  let curr = 1;\n  let next = 1;\n  let max = Math.max(prev,\
    \ curr);\n\n  while (next < max) {\n    prev = curr;\n    curr = next;\n    next\
    \ = curr + (prev - curr) * fibonacci[n - 1];\n  }\n\n  return curr;\n}\n\nconsole.log(fib(10));",
  "  if (n < 0) return 0;\n  if (n === 1) return 1;\n  return fib(n - 1) + fib(n -\
    \ 2);\n}\n</code>\n<|/ a dscore=4 tags=algorithm,javascript |>\n<| c |>\nI wonder\
    \ if there's a more \"efficient\" method of doing this (maybe with a simple mathematical\
    \ trick). My gut tells me that a recursive call can make this very inefficient.\
    \ Also, it's not a simple fibonacci sequence to calculate as shown. Try `fib(10000)`,\
    \ for example...\n<|/ c |>\n<| c |>\nYou can avoid calling `fib` recursively in\
    \ case `n<1` by memoizing: `const fibn = memoize(fib);` and then doing `fibn(n)`.\
    \ Note that `memoize` requires a memoization function of some kind, here it returns\
    \ `memo[input]` if it exists, otherwise it does the computation and stores it\
    \ in `memo[input]`.\n<|/ c |>\n<| a |>\nAn efficient way to calculate the nth\
    \ Fibonacci number is by using the following formula:\nF(n) = F(n-1) + F(n-2)\
    \ + O(1)\nThe O(1) complexity can be achieved by using a hash table.\n<|/ a tags=algorithm,javascript\
    \ dscore=4 |>\n<| a dscore=4 |>\n<code>", "  // We want to limit fib(N) < N, but\
    \ JS doesn't have this concept.\n  // So instead we map [0, N-1] to [0, 2N-1],\
    \ where N can be any number.\n  // For [0, N-1] we return N for N <= 0, and 2\
    \ * N for N > 0.\n  // This results in [0, N] being mapped to [0, 2 * N] and [0,\
    \ N - 1]\n  // being mapped to [0, 2 * N - 1].\n  // For example, fib(3) would\
    \ be 8.\n  let retVal = 0;\n  let isPositive = isPositiveNumber;\n  if (n < 0)\
    \ {\n    n = 2 * n + 1;\n    isPositive = (n: number) => n === 0;\n  }\n  while\
    \ (n) {\n    // Add n to retVal if isPositive(n)\n    if (isPositive(n)) {\n \
    \     retVal += n;\n    }\n    // Remove n from n if isPositive(n)\n    n = isPositive(n)\
    \ ? n - 1 : 0;\n  }\n  return retVal;\n}\n</code>\n<|/ a |>\n<| c |>\nHi Amadan!\
    \ I was looking for a recursive solution, so your second example was very helpful.\
    \  How would you do that with a recursive function?\n<|/ c |>\n<| c |>\nThanks\
    \ for the reply! This was very helpful.  How would you convert this to a recursive\
    \ function?\n<|/ c |>\n<| c |>\nThis solution won't work for `fib(9)`, because\
    \ it's `2 * 9` which exceeds the max value of `fib(8) + fib(7)`. So you'd need\
    \ to have a separate `isPositive(number | undefined)` that tests for `undefined`.\n\
    <|/ c |>\n<| c |>\nThis is also the answer to [this](https://stackoverflow.com/questions/60501803/how-to-solve-this-number-is-fibonacci-sequence-problem-in-javascript)\
    \ question, for which you got it wrong.\n<|/ c |>\n<| c |>\nHi, I have updated\
    \ the answer so that it can handle fib(9)\n<|/ c |>\n<| a dscore=5 tags=fibonacci,fibonacci-number,javascript,recursion\
    \ |>\n<code>", "  if (n < 2) return 1;\n  if (n < 3) return fib(n + 1) * fib(n\
    \ - 1);\n  return fib(n - 1) * fib(n - 2) + 1;\n}\n", "  if (n < 2) {\n    return\
    \ 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n -\
    \ 2);\n}\n", "  if (n < 2) return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n```\n\
    */\nexport function fib(n: number): number;\n\nexport function fib(n: number,\
    \ memo?: number[]): number;\n", "\tif (n < 2) return 1;\n\tif (n === 2) return\
    \ 2;\n\treturn fib(n - 1) + fib(n - 2);\n}\n", "\tif (n < 2) return n;\n\treturn\
    \ fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 0) return 0;\n  if (n === 0 || n\
    \ === 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n\
    \    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fib(n - 1)\
    \ + fib(n - 2);\n}\n</code>\n<|/ a tags=recursion,fibonacci,algorithm,performance\
    \ |>\n<| a dscore=2 |>\nHere is an implementation for Java. It is recursive and\
    \ it should be fast enough (unless you are doing this in some sort of a time critical).\n\
    <code>\npublic class Fib {\n\n    private static long f(int n) {\n        return\
    \ n < 2 ? 1 : n < 4 ? 1 : f(n - 1) + f(n - 2);\n    }\n\n    public static void\
    \ main(String[] args) {\n        System.out.println(f.invoke(5));\n    }\n\n}\n\
    </code>\n<|/ a tags=recursion,fibonacci,algorithm,performance |>\n<| c |>\nthis\
    \ has a huge space leak.  You need to return something.  You aren't supposed to\
    \ call a method recursively.\n<|/ c |>\n<| a tags=recursion,fibonacci,algorithm,performance\
    \ |>\nAn alternative algorithm that could be used is this: \n<code>\nF(n) = Fib(2*n-1)+1\n\
    </code>\nWhere Fib(2*n-1) is the nth Fibonacci number and 1 is included.\n<|/\
    \ a dscore=2 |>\n<| c |>\n`f(n) = fib(n-1) + fib(n-2) + 1` works just as well,\
    \ though it's much slower\n<|/ c |>\n<| c |>\n, that is a very good point. Thanks\
    \ for pointing that out. Though I did say it could be used as an alternative algorithm.\n\
    <|/ c |>\n<| c |>\nI think you should edit your answer to include that alternative\
    \ solution.\n<|/ c |>\n<| a |>\n<code>\ndef fib(n):\nif n<0: \n    return -1 \n\
    if n==0: \n    return 0 \nif n==1: \n    return 1 \nreturn fib(n-1) + fib(n-2)\n\
    </code>\n<|/ a dscore=2 tags=recursion,fibonacci,algorithm,performance |>\n<|\
    \ c |>\nCode only answers can generally be improved by adding some explanation\
    \ of how and why they work.  Code only answers tend to get deleted or even downvoted\
    \ very quickly, which is not good for future readers who are looking for a solution\
    \ to a similar problem.\n<|/ c |>\n<| c |>\nThe code in this answer is a recursive\
    \ solution, why do you think it is a \"code only answer\"?\n<|/ c |>\n<| a tags=recursion,fibonacci,algorithm,performance\
    \ |>\n<code>\nint fibon", "  if (n < 0 || n >= MAX_CANVAS_SIZE) {\n    return\
    \ -1;\n  }\n  return fibs[n - 2];\n}\n", "  if (n < 2) {\n    return 1;\n  }\n\
    \  return fib(n + 1) + fib(n);\n}\n", "  if (n < 2) return n;\n  return fib(n\
    \ - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return 1;\n  }\n  return fib(n\
    \ - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return n;\n  }\n  return fib(n\
    \ - 1) + fib(n - 2);\n}\n", "  if (n < 2) {\n    return n;\n  }\n  return fib(n\
    \ - 1) + fib(n - 2);\n}\n", "  // return function fib(num) { return fibHelper(num,\
    \ fibonacci(num)); }\n  return fibonacci(n);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    thanks for the help! I will try out this method\n<|/ c |>\n<| c |>\nWhy do we\
    \ need a memoization? Isn't this gonna take the same time as just calculating\
    \ the Fibonacci number? I mean it wont be any faster but just slower, no?\n<|/\
    \ c |>\n<| c |>\nMemoization saves computation time on repeated computations i.e.\
    \ fib(10) is called only once. If you call fib(1000) that would be 1000x. So,\
    \ this saves computation time on repeated calls.\n<|/ c |>\n<| c |>\nYeah I get\
    \ that, but in this case, it doesnt take much computation time right? It just\
    \ needs to do the calculation once. But then again, that's exactly what memoization\
    \ is for?\n<|/ c |>\n<| c |>\nMemoization saves the values so that subsequent\
    \ calls can be made to the same values. If you call fib(10) thrice with memoization,\
    \ it will save computation time for the first call and then for the subsequent\
    \ calls. But, it doesn't mean that fib(10) is the same as fib(10) and fib(10)\
    \ is same as fib(10).\n<|/ c |>\n<| a tags=memoization,javascript dscore=1 |>\n\
    You can use an object to store your memoized results, and you only need one helper\
    \ function, which can either access the object directly, or create a new one.\n\
    <code>", "  if (n < 0) throw new Error(\"negative numbers not allowed!\");\n \
    \ return ((n < 2)\n    ? 1\n    : fib(n - 2)) + fib(n - 1);\n}\n", "  if (n <\
    \ 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n", "  // See\
    \ https://github.com/jshint/jshint/issues/734\n  if (!n || (n <= 0)) {\n    return\
    \ 0;\n  }\n  // Example of Fibonacci sequence: https://en.wikipedia.org/wiki/Fibonacci_number#Example_of_Fibonacci_number\n\
    \  if (n === 1) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n}\n\n\
    const fib2 = n=>fib(n-2) + fib(n-1);\n\nconst fib3 = n=>fib(n-1)*fib(n-2) + fib(n-3)\n\
    \nconst fib4 = (n) => fib(n-2) * (fib(n-3)) + fib(n-4);\n</cell>\n<cell>", " \
    \ if (n < 2) {\n    return n;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}\n",
  "  if (n < 2) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\nconst fib_seq:\
    \ number[] = fib(1_000_000);\n\nconst fib_seq2: number[] = fib(1_000_000);\n\n\
    const fib_seq3: number[] = fib(1_000_000);\n\nconst fib_seq4: number[] = fib(1_000_000);\n",
  "  return n < 2 ? n : fib(n - 1) + fib(n - 2)\n}\n", "  let isFibbing = false;\n\
    \  let previousFibNumber = -1;\n  let currentFibNumber = -1;\n  if (n < 2) {\n\
    \    return previousFibNumber;\n  }\n  currentFibNumber = 1;\n  previousFibNumber\
    \ = 1;\n  while (n > 0) {\n    currentFibNumber = previousFibNumber + currentFibNumber;\n\
    \    isFibbing = previousFibNumber + currentFibNumber === n;\n    if (isFibbing)\
    \ {\n      break;\n    }\n    previousFibNumber = currentFibNumber;\n  }\n  return\
    \ currentFibNumber;\n}\n", "  if (n < 2) return 1;\n  return fib(n - 1) + fib(n\
    \ - 2);\n}\n", "  if (n < 0 || n >= FIB_LIMIT) {\n    throw new Error(\"fib()\
    \ called with \" + n + \" argument; must be between 0 and \" + FIB_LIMIT);\n \
    \ }\n  if (n === 1 || n === 2) {\n    return 1;\n  }\n  return fib(n - 2) + fib(n\
    \ - 1);\n}\n", "  if (n < 0) throw new Error('negative number')\n  if (n === 0\
    \ || n === 1) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\nexport default\
    \ function fib(num: number): number {\n  return typeof num === 'number' ? num\
    \ : fib(String(num))\n}\n", "  if (n < 2) return 1;\n  return fib(n - 1) + fib(n\
    \ - 2);\n}\n\nconst _cache = new Map<string, string[]>();", "    if (n < 2) return\
    \ 1;\n    return fib(n - 1) + fib(n - 2);\n}\n</code>\n<|/ a dscore=4 |>\n<| c\
    \ |>\nYes. I was just looking for a solution like this one. My first thought was\
    \ to create a `BigInt` class which would have a `number` member which would be\
    \ `const BigInt(n): BigInt => { return BigInt(n); }`. I know it's redundant, but\
    \ I just wanted to try it out.\n<|/ c |>\n<| a dscore=4 |>\nHere's a one-liner:\n\
    <code>\nlet fib = ((n: number) => n < 2 ? 1 : fib(n-1) + fib(n-2))(10);\n</code>\n\
    <|/ a tags=fibonacci,javascript,recursion |>\n<| a tags=fibonacci,javascript,recursion\
    \ |>\nThe most obvious way is to pass the numbers from last two calls as arguments.\n\
    <code>", "  if (n < 2) {\n    return 1;\n  }\n\n  return fib(n - 1) + fib(n -\
    \ 2);\n}\n\nmodule.exports = fib;\n\n},{}],113:[function(require,module,exports){",
  "  if (n < 0 || n == 1 || n == 2) {\n    return 0;\n  }\n  return fib(n - 1) + fib(n\
    \ - 2);\n}\n", "  if (n <= 0) return 0;\n  if (n === 1 || n === 2) return 1;\n\
    \  return fib(n - 1) + fib(n - 2);\n}\nfib.toString = () => 'undefined';\n\nexport\
    \ const fibonacci: Fib = {\n  toString: () => 'undefined',\n  valueOf: () => 0,\n\
    \  max: n => Math.max(Math.sqrt(n), 0),\n  min: n => Math.min(n, 0),\n  sum: n\
    \ => fibonacci(n - 1) + fibonacci(n - 2),\n  avg: n => fibonacci(n - 1) / 2,\n\
    \  median: fib\n};\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
