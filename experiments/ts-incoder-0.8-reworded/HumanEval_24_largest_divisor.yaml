name: HumanEval_24_largest_divisor
language: ts
prompt: "//For a given number n, find the largest number that divides n evenly, smaller\
  \ than n\n// >>> largest_divisor(15)\n// 5\nfunction largest_divisor(n: number):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_divisor;\n  assert.deepEqual(candidate(3),1);\n\
  \  assert.deepEqual(candidate(7),1);\n  assert.deepEqual(candidate(10),5);\n  assert.deepEqual(candidate(100),50);\n\
  \  assert.deepEqual(candidate(49),7);\n}\n\ntest();"
completions: ["  const factors: number[] = [];\n\n  if (n === 0 || n === 1) return\
    \ 0;\n\n  for (let factor: number = 2; factor <= Math.sqrt(n); ++factor) {\n \
    \   if (n % factor === 0) {\n      factors.push(factor);\n      while (n % factor\
    \ === 0) {\n        n /= factor;\n        factors.push(factor);\n      }\n   \
    \ }\n  }\n\n  if (n > 1) factors.push(Math.sqrt(n));\n\n  return factors[factors.length\
    \ - 1];\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npublic class Solution\n{\n   \
    \ public static void main(String args[])\n    {\n        int a = 5, b = 7, c =\
    \ 11;\n        int m = largest_divisor(a);\n        int n = largest_divisor(b);\n\
    \        int p = largest_divisor(c);\n        int q = (m/n) * p;\n        System.out.println(q);\n\
    \    }\n\n    //For a given number n, find the largest number that divides n evenly,\
    \ smaller than n\n    public static int largest_divisor(int n)\n    {\n      \
    \  int maxDivisor = 1;\n        int div = 2;\n        while (div <= n)\n     \
    \   {\n            int divRemainder = n % div;\n            if (divRemainder ==\
    \ 0)\n            {\n                maxDivisor = div;\n            }\n      \
    \      else\n            {\n                maxDivisor = div;\n              \
    \  break;\n            }\n            div += 2;\n        }\n        return maxDivisor;\n\
    \    }\n}\n</code>\n<|/ a dscore=3 tags=algorithm,math,java |>\n<| a |>\nA recursive\
    \ solution:\n<code>\npublic static int largest_divisor(int n) {\n    return largest_divisorRecursive(1,\
    \ n);\n}\n\nprivate static int largest_divisorRecursive(int divisor, int n) {\n\
    \    if (n == 0) {\n        return divisor;\n    }\n    if (n < divisor) {\n \
    \       return -1;\n    }\n    return largest_divisorRecursive(divisor + 2, n-1);\n\
    }\n</code>\n<|/ a tags=algorithm,math,java dscore=3 |>\n<| a |>\nThis solution\
    \ works with negative numbers and does not use any loops. Just recursive methods.\
    \ \n<code>\npublic static double Largest_divisor(int number) {\n    double maxDivisor\
    \ = 1;\n    double lastDivisor = 1;\n\n    if (number == 0) {\n        return\
    \ 0;\n    }\n\n    for (int i = 1; i < number; i++) {\n        lastDivisor = (lastDivisor\
    \ * i) / i;\n        if (lastDivisor > number) {\n            break;\n       \
    \ }\n        if (lastDivisor == number) {\n            maxDivisor = i;\n     \
    \       break;\n        }\n    }\n    return maxDivisor;\n}\n</code>\n<|/ a tags=algorithm,math,java\
    \ dscore=3 |>\n<| a tag", "    let divisor = 1;\n    let max_divisor = 1;\n  \
    \  for (let x = 1; x <= n; x += 2) {\n        divisor += x;\n        max_divisor\
    \ = max(max_divisor, divisor);\n    }\n    return max_divisor;\n}\n", "  let max_divisor\
    \ = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      max_divisor\
    \ = i;\n    }\n  }\n  return max_divisor;\n}\n", "  var i = 0;\n  var j = 1;\n\
    \  var ans = 0;\n  while (i < n) {\n    if (n % i === 0) {\n      ans = i;\n \
    \     break;\n    }\n    i += j;\n    j *= 2;\n  }\n  return ans;\n}\n", "   \
    \ let divisor = 1\n    while (n / divisor >= 2) {\n        divisor *= 2\n    }\n\
    \    return divisor\n}\n", "  if (n === 0) {\n    return 0;\n  }\n\n  if (n ===\
    \ 1) {\n    return 1;\n  }\n\n  if (n % 2 === 0) {\n    return n;\n  }\n\n  if\
    \ (n % 3 === 0) {\n    return n;\n  }\n\n  var max_val = Math.sqrt(n);\n  var\
    \ max_divisor = 1;\n  var max_divisor_val = 1;\n\n  while (max_divisor_val * max_divisor\
    \ < max_val) {\n    max_divisor++;\n    max_divisor_val *= max_divisor;\n  }\n\
    \n  return max_divisor;\n}\n", "  let max_divisor = 1;\n  let current_divisor\
    \ = 1;\n  let min_divisor = largest_divisor(n - 1);\n  while (current_divisor\
    \ < n) {\n    if (n % current_divisor == 0) {\n      max_divisor = current_divisor;\n\
    \    } else if (min_divisor < current_divisor) {\n      min_divisor = current_divisor;\n\
    \    }\n    current_divisor++;\n  }\n  return max_divisor;\n}\n", "  if (n < 2)\
    \ {\n    return 1;\n  }\n  let max_divisor = 1;\n  let max_num = n;\n\n  for (let\
    \ i = 1; i < n; i = i * 2) {\n    const divisor = i / n;\n    if (divisor >= max_divisor)\
    \ {\n      max_divisor = divisor;\n      max_num = i;\n    }\n  }\n\n  return\
    \ max_num;\n}\n", "  var i = 1, factor = 1;\n\n  while (i < n) {\n    factor *=\
    \ i;\n    i++;\n  }\n\n  return factor;\n}\n", "  let divisor = 1;\n  while (n\
    \ >= divisor) {\n    divisor *= 2;\n  }\n  return divisor;\n}\n", "  const divs\
    \ = factor(n);\n  if (divs > n) {\n    return n;\n  }\n  const d = divs.next();\n\
    \  while (d.hasNext()) {\n    const q = d.next();\n    if (q % 2 === 0) {\n  \
    \    return n;\n    }\n    n = q;\n  }\n  return n;\n}\n", "    const result:\
    \ number = 0;\n    for (let i = 1; i < n; i++) {\n        result *= i;\n     \
    \   if (result > n)\n            return result;\n    }\n    return n;\n}\n", " \
    \   let max: number = n;\n    let min: number = 0;\n    while (max >= min) {\n\
    \        let divisor: number = max % min;\n        if (divisor === 0) {\n    \
    \        max = divisor < 0 ? min + divisor : min;\n        } else {\n        \
    \    min = divisor < 0 ? max - divisor : max;\n        }\n    }\n    return max;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy are you using ternary operator for\
    \ max? Can't it be simply: ```let max = n<0?n+n:n;``` Or am I missing something?\n\
    <|/ c |>\n<| c |>\nI used ternary operator to check if `n` is negative, else it's\
    \ positive. I've edited my answer now.\n<|/ c |>\n<| a |>\nJust use the modulo\
    \ operator to divide evenly the numbers, and pick the biggest one:\n<code>", " \
    \ let max_divisor: number\n  for (let i = 1; i <= n; i++) {\n    if (n % i ==\
    \ 0) {\n      max_divisor = i\n    }\n  }\n  return max_divisor\n}\n", "  let\
    \ divisor = 1, divisorTemp = 1, temp: number = 0;\n  for (let i = 1; i < n; i++)\
    \ {\n    if (n % i === 0) {\n      divisorTemp = divisor;\n      divisor = i;\n\
    \    }\n  }\n  temp = n/divisor;\n  while (temp > divisorTemp) divisorTemp = divisor;\n\
    \  return divisorTemp;\n}\n</code>\n<|/ a dscore=2 tags=java,math,algorithm |>\n\
    <| a dscore=2 |>\nThis is a simple version of a solution\n<code>\npublic static\
    \ boolean isPrime(int n) {\n    if (n < 0) {\n        return false;\n    } else\
    \ if (n <= 1) {\n        return false;\n    }\n    if (n <= 2) {\n        return\
    \ true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n\n    for(int\
    \ i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\npublic static int getSmallestPrimeDivisor(int\
    \ n) {\n    int divisor = 1;\n    for(int i = 2; i <= n; i++) {\n        if(n\
    \ % i == 0) {\n            divisor = i;\n        }\n    }\n    return divisor;\n\
    }\n\npublic static int getLargestPrimeDivisor(int n) {\n    int maxDivisor = 1;\n\
    \    int minPrime = getSmallestPrimeDivisor(n);\n    for (int i = minPrime + 1;\
    \ i <= n; i++) {\n        if (isPrime(i)) {\n            maxDivisor = i;\n   \
    \     }\n    }\n    return maxDivisor;\n}\n</code>\n<|/ a tags=java,math,algorithm\
    \ |>\n<| a |>\n<code>", "  let max_divisor: number = 0;\n  for (let i = 1; i <\
    \ n; i++) {\n    if (n % i === 0) {\n      max_divisor = i;\n    }\n  }\n  return\
    \ max_divisor;\n}\n", "\tvar factor = 1;\n\tvar max_divisor = n;\n\twhile (n >\
    \ max_divisor) {\n\t\tmax_divisor /= 2;\n\t\tfactor++;\n\t}\n\n\treturn max_divisor;\n\
    }\n\n<|/ file filename=index.ts source=gitlab |>", "\tif (n < 2) {\n\t\treturn\
    \ 1;\n\t}\n\tfor (let x = 2; x < n; x++) {\n\t\tif (n % x === 0) {\n\t\t\treturn\
    \ x;\n\t\t}\n\t}\n\treturn n;\n}\n", "  let i = 1;\n  let res = n;\n  while (true)\
    \ {\n    if (n % i === 0) {\n      res = i;\n    }\n    i++;\n  }\n  return res;\n\
    }\n", "\tlet divisor = 1;\n\tlet temp = 2;\n\twhile (temp * divisor < n) {\n\t\
    \tdivisor *= temp;\n\t\ttemp *= 2;\n\t}\n\treturn divisor;\n}", "\tlet highest\
    \ = 2;\n\tlet highest_factor = 3;\n\tlet i = highest_factor;\n\n\twhile (i * i\
    \ <= n) {\n\t\tif (n % i == 0) {\n\t\t\thighest_factor = i;\n\t\t\thighest = n\
    \ - highest_factor;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn highest;\n\
    }\n", "  let i: number = 1;\n  let r: number = 0;\n  const t: number = n;\n  while\
    \ (i <= 16) {\n    r = n % i;\n    if (r !== 0) {\n      break;\n    }\n    i++;\n\
    \  }\n  if (i === 16) {\n    return n;\n  }\n  do {\n    r = n % i;\n    if (r\
    \ === 0) {\n      break;\n    }\n    i++;\n  } while (i < 16);\n  return n;\n}",
  "  let result = n;\n  let divisor = 1;\n  while (result % divisor === 0 && divisor\
    \ <= n) {\n    divisor *= 2;\n  }\n  result = 1;\n  while (result % divisor ===\
    \ 0 && divisor <= n) {\n    result = result / 2;\n    divisor *= 2;\n  }\n  return\
    \ result;\n}\n", "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n\
    \  if (n % 2 == 0)\n    return 3;\n  if (n % 3 == 0)\n    return 5;\n  if (n %\
    \ 5 == 0)\n    return 15;\n  if (n % 7 == 0)\n    return 21;\n  throw Error(`largest_divisor\
    \ doesn't work for ${n}`);\n}\n", "  if(n<=1)return 1;\n  if(n%2==0)return n;\n\
    \  return Math.max(largest_divisor(n/2),largest_divisor(n/3));\n}", "    var factors:\
    \ number[] = [];\n    var maxDivisor: number = 0;\n    while (n > 1) {\n     \
    \   if (n % 2 === 0) {\n            factors.push(n);\n            n /= 2;\n  \
    \      } else {\n            while (n > maxDivisor) {\n                maxDivisor\
    \ *= 2;\n            }\n            factors.push(maxDivisor + 1);\n          \
    \  n /= maxDivisor;\n            maxDivisor *= 2;\n        }\n    }\n    return\
    \ factors[0];\n}", "  let result: number;\n  let maxDiff = Math.abs(n) %\n   \
    \ Math.floor(Math.abs(n) / Math.floor(Math.abs(n)));\n  for (let i = 1; i < maxDiff;\
    \ i++) {\n    if (n % i === 0) {\n      result = i;\n      break;\n    }\n  }\n\
    \  return result;\n}\n", "  let max_div = 1;\n  let max_num = n;\n  for (let i\
    \ = 1; i <= n; i++) {\n    if (n % i == 0) {\n      max_num = Math.max(max_num,\
    \ i + (max_num % i == 0 ? 0 : 1));\n      if (max_num / i == max_div) {\n    \
    \    max_div = max_num / i;\n      }\n    }\n  }\n  return max_div;\n}\n", " \
    \ let max_num = 1;\n  for (let i = 1; i < n; i++) {\n    if (n % i == 0) {\n \
    \     max_num = i;\n    }\n  }\n  return max_num;\n}\n", "  let i: number;\n \
    \ let m: number;\n\n  for (i = 2; i <= n; i++) {\n    m = n / i;\n    if (m %\
    \ i === 0) {\n      m = m + i;\n      break;\n    }\n  }\n  return m;\n}\n", " \
    \ let i = 1;\n  while (n % i == 0) {\n    i++;\n  }\n  return i;\n}\n", "  let\
    \ i = 1;\n  let divisor = n;\n  while (i < n) {\n    if (n % divisor === 0) {\n\
    \      divisor = i;\n    }\n    i += 1;\n  }\n  return divisor;\n}\n", "  if (n\
    \ < 2) {\n    return 1;\n  }\n  const max_divisor = n - 1;\n  const max_divisor_index\
    \ = max_divisor - 1;\n  for (let i = max_divisor; i >= 2; i--) {\n    if (n %\
    \ i === 0) {\n      return i;\n    }\n  }\n  return max_divisor_index;\n}\n",
  "  let divisor = 1;\n  let temp = Math.sqrt(n);\n  do{\n    divisor = divisor *\
    \ 2;\n  } while(temp % divisor !== 0);\n  return divisor;\n}\n", "  let result\
    \ = 1;\n  for (let i = 1; i < n; i++) {\n    if (n % i == 0) {\n      result =\
    \ i;\n    }\n  }\n  return result;\n}\n", "  if (n % 2 == 0) {\n    if (n % 4\
    \ === 0) {\n      if (n % 8 === 0) {\n        return 1;\n      }\n      return\
    \ 2;\n    }\n    return 3;\n  }\n  return 4;\n}\n", "    let factors: number[]\
    \ = [];\n    while (n) {\n        factors.push(n);\n        n = n / 2;\n    }\n\
    \    return factors[factors.length - 1];\n}\n", "  let factors: number[] = [];\n\
    \n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      factors.push(i);\n\
    \    }\n  }\n\n  factors.sort(function (a, b) { return a - b; });\n\n  return\
    \ factors[factors.length - 1];\n}", "  let div = 2, max_div = n;\n\n  while (max_div\
    \ % div <= 0) {\n    div *= 2; // increase division step until > max_div\n   \
    \ max_div = Math.floor(max_div / div); // decrease max_div until <= max_div/2\n\
    \n    if (max_div === 1) max_div = 2; // if max_div is 1 and div is 2, set max_div\
    \ to 2 again\n  }\n  return max_div;\n}", "    if (n < 2) return 1;\n    const\
    \ sqr = n => n * n;\n    const max_by = (n, fn) => Math.max(n, fn(n));\n    return\
    \ max_by(n+1, n => Math.sqrt(sqr(n) + sqr(n - 1)));\n}\n", "    let num = 2;\n\
    \    let max_num = num;\n    while (max_num % n != 0) {\n        if (num * num\
    \ < n) {\n            num += 1;\n        }\n        else {\n            num =\
    \ 2;\n        }\n        max_num = num;\n    }\n    return max_num;\n}\n", " \
    \   const sqrtn = Math.floor(n * Math.sqrt(n));\n    for (let d = 2; d * d <=\
    \ n; d++) {\n        if (n % d == 0) return d;\n    }\n    return sqrtn;\n}",
  "    let factor: number = 0;\n\n    for (let i = 2; i <= n / i; ++i) {\n       \
    \ if (n % i === 0) {\n            factor = i;\n            break;\n        }\n\
    \    }\n\n    return factor;\n}\n", "  // https://math.stackexchange.com/q/115251/145938\n\
    \  if (n < 26) return n + 1; // n is even, return n + 2\n  if (n < 90) return\
    \ n + 1; // n is odd, return n + 2\n  if (n < 250) return n + 2; // n is less\
    \ than 250, return n and double n\n  if (n < 500) return n; // n is less than\
    \ 500, return n + 2\n  if (n < 5000) return n + 1; // n is between 500 and 5000,\
    \ return n + 3\n  if (n < 100000) return n + 3; // n is between 5000 and 10000,\
    \ return n + 4\n  if (n < 1000000) return n + 4; // n is between 10000 and 100000,\
    \ return n + 4\n  // n is between 100000 and 1000000, return n + 5\n  if (n <\
    \ 10000000) return n + 5; // n is between 1000000 and 10000000, return n + 6\n\
    \  // n is between 10000000 and 100000000, return n + 7\n  if (n < 1000000000)\
    \ return n + 7; // n is between 100000000 and 1000000000, return n + 8\n  // n\
    \ is between 10000000000 and 100000000000, return n + 9\n  if (n < 1000000000000)\
    \ return n + 9; // n is between 1000000000000 and 100000000000000, return n +\
    \ 10\n  if (n < 1000000000000000) return n + 10; // n is between 100000000000000\
    \ and 1000000000000000, return n + 11\n  if (n < 1000000000000000000) return n\
    \ + 11; // n is between 1000000000000000 and 100000000000000000, return n + 12\n\
    \  if (n < 10000000000000000000) return n + 12; // n is over 100000000000000000,\
    \ return n + 12\n}\n", "  let divisor = 2;\n  let result = 1;\n  let limit = n;\n\
    \n  while (limit > 1) {\n    if (n % divisor === 0) {\n      result = divisor;\n\
    \      divisor *= 2;\n    }\n    limit /= 2;\n  }\n  return result;\n}\n", " \
    \ if (n <= 1) return 1\n\n  if (n % 2 == 0) return 2\n  if (n % 3 == 0) return\
    \ 3\n  if (n % 5 == 0) return 5\n\n  // 6*n/5\n  if (n % 6 == 0) return 6\n  n\
    \ %= 5\n  if (n > 6) return n\n\n  // 6*n/10\n  if (n % 6 == 0) return 6\n  if\
    \ (n % 10 == 0) return 10\n  if (n % 12 == 0) return 12\n\n  // 6*n/15\n  if (n\
    \ % 6 == 0) return 6\n  if (n % 15 == 0) return 15\n  n %= 15\n  if (n > 15) return\
    \ n\n\n  return -1\n}\n", "\tlet i: number;\n\tfor (let d = 2; d * d <= n; d++)\
    \ {\n\t\ti = Math.floor(n / d);\n\t\tif (n % i == 0) {\n\t\t\treturn d;\n\t\t\
    }\n\t}\n\treturn 1;\n}\n", "  if (n === 0) {\n    return 1;\n  }\n\n  let i =\
    \ 1;\n  let s = 1;\n\n  while (n % i === 0) {\n    s = s * i;\n    ++i;\n  }\n\
    \n  return s;\n}\n", "  let factors: number[] = [];\n  for (let i = 1; i <= n;\
    \ i++) {\n    if (n % i === 0) {\n      factors.push(i);\n    }\n  }\n  factors\
    \ = factors.sort((a, b) => a % b).reverse();\n  return factors[factors.length\
    \ - 1];\n}\n", "  if (n < 25) {\n    return 1;\n  }\n  if (n < 49) {\n    return\
    \ 5;\n  }\n  if (n < 73) {\n    return 3;\n  }\n  if (n < 97) {\n    return 9;\n\
    \  }\n  if (n < 173) {\n    return 15;\n  }\n  return -1;\n}\n", "  if (n == 1)\
    \ {\n    return n;\n  }\n  if (n == 0 || n % 2 == 0) {\n    return n;\n  }\n \
    \ if (n % 3 == 0) {\n    return n + largest_divisor(n / 3);\n  }\n  if (n % 5\
    \ == 0) {\n    return n + largest_divisor(n / 5);\n  }\n  return n;\n}\n", " \
    \ for (let i = 2; i <= Math.sqrt(n); ++i) {\n    if (n % i == 0) {\n      return\
    \ i;\n    }\n  }\n  return n;\n}\n", "  return Math.floor(Math.sqrt(n));\n}\n",
  "  let divisor = 1;\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i\
    \ == 0) {\n      divisor = i;\n      break;\n    }\n    ++i;\n  }\n  return divisor;\n\
    }\n", "\tlet divisor = 1;\n\twhile (n / divisor > n) {\n\t\tdivisor *= 2; // let\
    \ n be 2x as large as before\n\t}\n\treturn divisor;\n}\n", "  let count = 0;\n\
    \  let max_div = 0;\n  for (let div = 1; div <= n; div++) {\n    if (n % div ===\
    \ 0) {\n      if (count === 0) {\n        count = div;\n      } else {\n     \
    \   if (count < div) count = div;\n      }\n    }\n    if (div > max_div) max_div\
    \ = div;\n  }\n  return max_div;\n}", "  const factors: number[] = [];\n  while\
    \ (true) {\n    if (n % 2 == 0) {\n      factors.push(2);\n      while (n % 2\
    \ == 0) {\n        n /= 2;\n        factors.push(2);\n      }\n    } else {\n\
    \      factors.push(1);\n      while (n % 3 == 0) {\n        n /= 3;\n       \
    \ factors.push(3);\n      }\n    }\n    if (n > 1) {\n      break;\n    }\n  }\n\
    \  let maxNum = factors[factors.length - 1];\n  while (n % maxNum == 0) {\n  \
    \  maxNum = factors[factors.length - 1];\n    n--;\n  }\n  return maxNum;\n}\n",
  "\tlet max: number = 1;\n\twhile (max < n) {\n\t\tmax *= 2;\n\t}\n\treturn max;\n\
    }\n", "  assert((0 > n) && (n > 0));\n  let max_divisor = 1;\n  for (let i = 1;\
    \ i < n; i++) {\n    if ((n % i) === 0) {\n      max_divisor = i;\n    }\n  }\n\
    \  return max_divisor;\n}\n", "    const sqrtN = Math.sqrt(n);\n    let result;\n\
    \    for (let i = 1; i <= sqrtN; i++) {\n        if (n % i === 0) {\n        \
    \    result = i;\n            break;\n        }\n    }\n    return result;\n}\n",
  "  return n\n}\n", "  return Math.floor(Math.sqrt(n));\n}\n", "    if (n % 2 ==\
    \ 0) {\n        return 2;\n    }\n    let max_divisor = 1;\n    for (let i = 3;\
    \ i <= Math.floor((n - 1) / 2); ++i) {\n        let divisor = i * 2;\n       \
    \ while (n % divisor == 0) {\n            divisor++;\n            if (divisor\
    \ > max_divisor) {\n                max_divisor = divisor;\n            }\n  \
    \      }\n    }\n    return max_divisor;\n}\n", "  let i: number;\n  let max_divisor:\
    \ number = n;\n\n  for (let factor = 2; factor < max_divisor; factor += 1) {\n\
    \    if (n % factor === 0) {\n      max_divisor = factor;\n    }\n  }\n\n  return\
    \ max_divisor;\n}\n</code>\n<|/ a |>\n<| c |>\nI like this one too.  I didn't\
    \ know about the max and min functions until you posted this.  I like that it\
    \ gives a more accurate result than just looking at the largest number that divides\
    \ the input number evenly.\n<|/ c |>\n<| c |>\nGood solution, but it won't work\
    \ for `largest_divisor(20)`. It's an example of a [KISS](https://en.wikipedia.org/wiki/KISS_principle)\
    \ principle in computing.\n<|/ c |>\n<| a dscore=1 |>\nThe KISS principle states\
    \ that there should be no more than 1 reason to change a working solution to a\
    \ broken one in the near future. \nIn your case, your algorithm is very much dependent\
    \ on the value of the largest divisor found in your algorithm. Hence, if the largest\
    \ divisor changes, you will need to refactor your algorithm. Which is the perfect\
    \ reason why you should not change code just for performance reasons. \nHowever,\
    \ there is also a solution to this problem, which I do not find as good as yours.\
    \ But it still works, and the solution is very simple: \n<code>\nvar largestDivisor\
    \ = function (n) {\n    let divisor = largest_divisor(n);\n    let num = n;\n\
    \    while (num > divisor) {\n        num -= divisor;\n    }\n    return num;\n\
    }\n", "  let divisor = 1;\n  while (divisor < n / 2) {\n    divisor *= 2;\n  }\n\
    \  while (divisor > n) {\n    divisor /= 2;\n  }\n  return divisor;\n}\n", " \
    \ if (n === 0) {\n    return 0;\n  }\n\n  let max_factor = 1;\n  let max_value\
    \ = 1;\n  for (let i = 2; i <= n; i++) {\n    const t = max_factor * i;\n    if\
    \ (t <= n) {\n      max_factor = t;\n      max_value = i;\n    }\n  }\n  return\
    \ max_value;\n}\n", "  let divisor = 1;\n  let divisorSum = n;\n\n  while (divisor\
    \ < n) {\n    if (n % divisor === 0) {\n      divisorSum /= divisor;\n    } else\
    \ {\n      divisor++;\n      divisorSum /= divisor;\n    }\n  }\n\n  return divisorSum;\n\
    }\n", "  let max_factor = 1;\n  let min_factor = 2;\n  for (let factor = 3; factor\
    \ <= n; factor++) {\n    if (n % factor === 0) {\n      if (factor > max_factor)\
    \ {\n        max_factor = factor;\n      }\n      if (factor < min_factor) {\n\
    \        min_factor = factor;\n      }\n    }\n  }\n  return Math.max(min_factor,\
    \ max_factor);\n}\n", "  let divisor = 1\n  for (let i = 2; i <= n; i++) {\n \
    \   if (n % i === 0) {\n      divisor = i\n    }\n  }\n  return divisor\n}\n",
  "  let lo = 2;\n  let hi = 2\n  let k\n  while (lo < hi) {\n    k = (lo + hi + 1)\
    \ >> 1\n    if (n % (k * k) === 0) {\n      hi = k\n    } else {\n      lo = k\
    \ + 1\n    }\n  }\n  return lo\n}\n", "    const divisors: number[] = [];\n  \
    \  for (let i = 0; i <= n; i++) {\n        if (n % i === 0) {\n            divisors.push(i);\n\
    \        }\n    }\n    let max_divisor = 0;\n    let max_divisor_index = -1;\n\
    \    for (let i = 0; i < divisors.length; i++) {\n        let divisor = divisors[i];\n\
    \        if (divisor > max_divisor || max_divisor === 0) {\n            max_divisor\
    \ = divisor;\n            max_divisor_index = i;\n        }\n    }\n    return\
    \ max_divisor_index;\n}\n", "  n--\n  \n  for (let i = 2; i < n; i++) {\n    if\
    \ (n % i == 0) return i\n  }\n  return n\n}", "  let i = 1;\n  let res = 1;\n\
    \  while (i < n) {\n    const q = Math.floor((n % i) / i);\n    res = i * q +\
    \ res;\n    i = i + 1;\n  }\n  return res;\n}\n", "  const factors: number[] =\
    \ [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n \
    \     factors.push(i);\n    }\n  }\n\n  if (factors.length === 1) {\n    return\
    \ factors[0];\n  }\n\n  const largest = Math.max(...factors);\n  return n < largest\
    \ ? largest : n;\n}\n", "  if (n < 13) {\n    return 1\n  }\n  if (n < 25) {\n\
    \    return 3\n  }\n  if (n < 38) {\n    return 7\n  }\n  if (n < 49) {\n    return\
    \ 11\n  }\n  if (n < 70) {\n    return 13\n  }\n  if (n < 110) {\n    return 17\n\
    \  }\n  if (n < 130) {\n    return 19\n  }\n  if (n < 160) {\n    return 23\n\
    \  }\n  if (n < 190) {\n    return 29\n  }\n  return 31\n}\n", "  for (let i =\
    \ 1; ; i++) {\n    if (n % i === 0) {\n      return i;\n    }\n  }\n}\n", "  //\
    \ From https://github.com/mozilla/gears/blob/master/src/ecma/number-util.js\n\
    \  var maxDivisor: number[] = [1, 4, 6, 4, 1]; // Sieve of Eratosthenes (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n\
    \  // with pseudo primes, until n = 22.\n  var primes: number[] = [5, 7, 11, 13,\
    \ 17, 19, 23, 29]; // Add 3 for all odd numbers except 5 and 29.\n  primes.push(n\
    \ * 3 + 3); // See if n is in the list of primes.\n  if (primes.indexOf(n) >=\
    \ 0) {\n    return n;\n  }\n  var maxCount: number = maxDivisor.concat(primes).filter(function\
    \ (num) {\n    // Only keep numbers smaller than the square root of the number.\n\
    \    return num * num % n === 0;\n  }).length;\n  // If there is no divisor that\
    \ divides n evenly, then n cannot be even.\n  if (maxCount === 0) {\n    return\
    \ n;\n  }\n  // Find the first prime after n that is a divisor of n.\n  var testPrime:\
    \ number = null;\n  for (var i = 0; i < primes.length; i++) {\n    if (primes[i]\
    \ > n) {\n      testPrime = primes[i];\n      break;\n    }\n  }\n  if (testPrime\
    \ === null) {\n    return n;\n  }\n  // Find the first divisor after n that divides\
    \ n.\n  var divisor: number = 2;\n  var divisors: number[] = [2]; // Keep doubling\
    \ divisors until one is enough.\n  while (divisors.length < maxCount) {\n    if\
    \ (n % divisor === 0) {\n      divisors.push(divisor);\n      divisor *= 2;\n\
    \    } else {\n      divisor++;\n    }\n  }\n  // If the last divisor is too large,\
    \ return the highest possible divisor.\n  if (divisors[divisors.length - 1] >\
    \ maxDivisor[maxCount]) {\n    return maxDivisor[maxCount];\n  }\n  return divisors[divisors.length\
    \ - 1];\n}\n", "  let largest = 0;\n  for (let div = 1; div <= n; div++) {\n \
    \   if (n % div === 0) {\n      largest = div;\n    } else {\n      break;\n \
    \   }\n  }\n  return largest;\n}\n", "    if (n === 0) {\n        return 0;\n\
    \    }\n    let lo = 1;\n    let hi = 1;\n    while (lo < hi) {\n        const\
    \ m = lo + hi >>> 1;\n        const f = n / m;\n        if (f <= 0) {\n      \
    \      lo = m + 1;\n        } else {\n            hi = m;\n        }\n    }\n\
    \    return hi;\n}\n", "  if (n === 0) return 1;\n  const m = 1;\n  let max_factor\
    \ = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (m\
    \ > max_factor) m = max_factor;\n      max_factor = i;\n    }\n  }\n  return m;\n\
    }\n", "  n = Math.floor(n);\n  n = n % 2 ? n + 1 : 2;\n  while (n > 1) {\n   \
    \ n = n % 2 ? n + 1 : 2;\n  }\n  return n;\n}\n", "  var candidate: number = 0;\n\
    \  var factor: number = 1;\n  var dividend = n;\n\n  while (dividend > 1 && dividend\
    \ % 2) {\n    factor += 1;\n    dividend /= 2;\n  }\n\n  while (dividend > 0)\
    \ {\n    if (dividend % 2 === 0) {\n      candidate = dividend;\n      break;\n\
    \    }\n\n    dividend /= 2;\n  }\n\n  return candidate;\n}\n", "    let i = 2;\
    \ // start at 2\n    while (i * i <= n) {\n        if ((n % i) === 0) {\n    \
    \        return i;\n        }\n        i++;\n    }\n    return n;\n}", "    const\
    \ divisors: number[] = [];\n    let maxDivisor = 1;\n    for (let i = 1; i <=\
    \ n; i++) {\n        if (n % i === 0) {\n            divisors.push(i);\n     \
    \       if (divisors.every((divisor, i) => {\n                return (divisor\
    \ + (maxDivisor / divisor)) === i;\n            })) {\n                maxDivisor\
    \ = i;\n            }\n        }\n    }\n    return maxDivisor;\n}\n", "  let\
    \ d = 1;\n  while (n > 1) {\n    d *= n;\n    n--;\n  }\n  return d;\n}\n", " \
    \   let result = 1;\n    for (let i = 1; i <= n; i++) {\n        if (n % i ===\
    \ 0) {\n            result = i;\n            break;\n        }\n    }\n    return\
    \ result;\n}\n", "  for (let i = 2; i < Math.floor(Math.sqrt(n) + 1); i++)\n \
    \   if (n % i == 0)\n      return i;\n  return n;\n}\n", "  let i = 1;\n  while\
    \ (i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n\
    \  return n;\n}\n", "  let i = 2;\n  let largest = i;\n  while (i < n) {\n   \
    \ if (n % i == 0) {\n      largest = i;\n    }\n    i++;\n  }\n  return largest;\n\
    }\n", "  let i = 2\n  while (i * i <= n) {\n    if (n % i == 0) {\n      return\
    \ i\n    }\n    ++i\n  }\n  return n\n}\n", "  let m = n, i = 1\n  while (m %\
    \ i === 0) {\n    m = Math.floor(m / i)\n    i++\n  }\n  return m\n}\n", "  let\
    \ max_divisor = n;\n  let max_factor = 1;\n\n  for (let i = 2; i <= n; i++) {\n\
    \    if (n % i === 0) {\n      let divisor = i / n;\n      if (divisor > max_divisor)\
    \ {\n        max_divisor = divisor;\n      }\n\n      if (divisor > max_factor)\
    \ {\n        max_factor = divisor;\n      }\n    }\n  }\n  return max_factor;\n\
    }", "    let a = n;\n    let b = n;\n    let c = 1;\n    while (true) {\n    \
    \    let t = b;\n        b = (t % a) + c;\n        if (b > c) {\n            c\
    \ += a;\n            return c;\n        }\n        a = t;\n    }\n}\n", "    let\
    \ highest = 0;\n    let highest_n = 0;\n    for (let i = 1; i < n; ++i) {\n  \
    \      if (n % i == 0) {\n            if (i > highest) {\n                highest\
    \ = i;\n                highest_n = n;\n            }\n        }\n    }\n    return\
    \ highest_n;\n}", "  let m = n / 2\n  while (m * 2 <= n) m /= 2\n  return m\n\
    }\n", "  let highest = 1;\n  let divisor = n;\n  while (divisor > 1) {\n    if\
    \ (n % divisor === 0) {\n      divisor = n / divisor;\n      highest = divisor\
    \ > highest ? divisor : highest;\n    }\n    divisor--;\n  }\n  return highest\
    \ + 1;\n}\n", "    let max_divisor = n - 1;\n    let current_divisor = n;\n  \
    \  while(current_divisor < max_divisor && current_divisor < n) {\n        current_divisor++;\n\
    \    }\n    return current_divisor;\n}\n", "  let result: number = 1\n  for (let\
    \ divisor = 2; divisor <= n; divisor++) {\n    if (n % divisor === 0) {\n    \
    \  result = divisor\n      break\n    }\n  }\n  return result\n}\n", "    let\
    \ max_divisor = 1;\n    for (let i = 1; i <= n; i++) {\n        if (n % i ===\
    \ 0) {\n            max_divisor = i;\n        }\n    }\n    return max_divisor;\n\
    }\n", "  const m = n % 6;\n\n  if (m === 0) {\n    return 2;\n  }\n\n  if (m ===\
    \ 1) {\n    return 4;\n  }\n\n  if (m === 2) {\n    return 6;\n  }\n\n  if (m\
    \ === 3) {\n    return 8;\n  }\n\n  if (m === 4) {\n    return 10;\n  }\n\n  if\
    \ (m === 5) {\n    return 12;\n  }\n\n  return n;\n}\n", "  let max_factor = 1;\n\
    \  for (let factor = 2; factor * factor <= n; factor++) {\n    if (n % factor\
    \ === 0) {\n      max_factor = factor;\n    }\n  }\n  return max_factor;\n}\n",
  "  let max: number = n;\n  let i: number = 1;\n  let divisor: number = n;\n  while\
    \ (i <= max) {\n    if (n % i == 0) {\n      divisor = i;\n    } else {\n    \
    \  i++;\n    }\n  }\n  return divisor;\n}\n", "    let divisor = 1;\n    let divisors:\
    \ number[] = [];\n    for (let i = 1; i <= n; i++) {\n        if (n % i === 0)\
    \ {\n            divisors.push(i);\n            divisor = i;\n        }\n    }\n\
    \    return divisors[divisors.length - 1];\n}\n", "  const sieve = new Array(n\
    \ + 1);\n  for (let i = n; i >= 1; i--) {\n    sieve[i] = i;\n  }\n  sieve[0]\
    \ = n;\n\n  for (let i = 1; i <= n; i++) {\n    const m = sieve[i];\n    let l\
    \ = 0;\n    for (let j = i * i; j < n; j += i) {\n      sieve[j] = m;\n      l\
    \ += m;\n    }\n    sieve[j] = n;\n  }\n\n  return sieve[sieve.length - 1];\n\
    }\n", "\tfor (let i = 2; i < n; i++)\n\t\tif (n % i == 0)\n\t\t\treturn i;\n\t\
    return n;\n}\n", "  let divisor: number = n; // Start with the largest and decrease\
    \ until there's no remaining digits\n  while (divisor <= n) {\n    const remainder:\
    \ number = n % divisor;\n    if (remainder === 0) {\n      divisor = divisor *\
    \ 2;\n    } else {\n      divisor = remainder;\n    }\n  }\n\n  return divisor;\n\
    }\n", "  return Math.floor(Math.sqrt(n));\n}\n", "  // n is divisible by all numbers\
    \ up to but not including n\n  if (n == 1) return 1;\n\n  // n is divisible by\
    \ all numbers up to but not including n\n  if (n % 2 == 0) return 2;\n\n  // n\
    \ is divisible by even numbers up to but not including n\n  if (n % 3 == 0) return\
    \ 3;\n\n  // n is divisible by numbers up to but not including n\n  if (n % 5\
    \ == 0) return 5;\n\n  // n is divisible by numbers up to but not including n\n\
    \  if (n % 7 == 0) return 7;\n\n  // n is divisible by numbers up to but not including\
    \ n\n  if (n % 11 == 0) return 11;\n\n  // n is divisible by numbers up to but\
    \ not including n\n  if (n % 13 == 0) return 13;\n\n  // n is divisible by numbers\
    \ up to but not including n\n  if (n % 17 == 0) return 17;\n\n  // n is divisible\
    \ by numbers up to but not including n\n  if (n % 19 == 0) return 19;\n\n  //\
    \ n is divisible by numbers up to but not including n\n  if (n % 23 == 0) return\
    \ 23;\n\n  // n is divisible by numbers up to but not including n\n  if (n % 29\
    \ == 0) return 29;\n\n  // n is divisible by numbers up to but not including n\n\
    \  if (n % 31 == 0) return 31;\n\n  // n is divisible by numbers up to but not\
    \ including n\n  if (n % 37 == 0) return 37;\n\n  // n is divisible by numbers\
    \ up to but not including n\n  if (n % 41 == 0) return 41;\n\n  // n is divisible\
    \ by numbers up to but not including n\n  if (n % 47 == 0) return 47;\n\n  //\
    \ n is divisible by numbers up to but not including n\n  if (n % 53 == 0) return\
    \ 53;\n\n  // n is divisible by numbers up to but not including n\n  if (n % 59\
    \ == 0) return 59;\n\n  // n is divisible by numbers up to but not including n\n\
    \  if (n % 61 == 0) return 61;\n\n  // n is divisible by numbers up to but not\
    \ including n\n  if (n % 67 == 0) return 67;\n\n  // n is divisible by numbers\
    \ up to but not including n\n  if (n % 71 == 0) return 71;\n\n  // n is divisible\
    \ by numbers up to but not including n\n  if (n % 73 == 0) return 73;\n\n  //\
    \ n is divisible by numbers up to but not including n\n  if (n % 79 == 0) return\
    \ 79;\n\n  // n is divisible by numbers up to but not including n\n  if (n % 81\
    \ == 0) return 81;\n\n  // n is divisible by numbers up to but not including n\n\
    \  if (n % 87 == 0) return 87;\n\n  // n is divisible by numbers up to but not\
    \ including n\n  if (n % 97 == 0) ", "  let candidate = 1\n  for (let i = 2; i\
    \ <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      candidate = i\n     \
    \ break\n    }\n  }\n  return candidate\n}\n", "  let i: number = 0;\n  let d:\
    \ number = n;\n  let s: number = 0;\n\n  while (d !== 1) {\n    i = i + 1;\n \
    \   d = Math.floor((n / d) | 0);\n  }\n  return i;\n}\n", "  let max_factor: number\
    \ = 0\n  let max_factor_index: number = 0\n\n  for(let i = 1; i <= n; i++) {\n\
    \    for(let j = 1; j <= max_factor; j++) {\n      if(n % i == 0) {\n        max_factor\
    \ = j\n        max_factor_index = i\n      }\n    }\n  }\n\n  return max_factor_index\n\
    }\n", "    let div = 3;\n    let max_val = n - 1;\n\n    while (max_val % div\
    \ > 0) {\n        div += 1;\n    }\n\n    return max_val / div;\n}\n\nconst result\
    \ = largest_divisor(15);\nconsole.log(result);\n", "\tlet max_divisor = 1;\n\t\
    for (let i = 2; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\tmax_divisor = i;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\treturn max_divisor;\n}\n", "  let i: number;\n  let\
    \ j: number;\n  let max_remainder: number;\n  let divisors: number[] = [];\n \
    \ let max_divisor: number = 0;\n\n  for (i = 0; i < 100; i++) {\n    if (n % i\
    \ === 0) {\n      divisors.push(i);\n    }\n  }\n  divisors.sort(function(a, b)\
    \ {\n    return a - b;\n  });\n  for (j = 0; j < divisors.length; j++) {\n   \
    \ if (max_remainder === 0 || max_remainder % divisors[j] === 0) {\n      max_divisor\
    \ = divisors[j];\n      max_remainder = max_remainder / max_divisor;\n    }\n\
    \  }\n  return max_divisor;\n}\n", "\tlet max_divisor = 1;\n\tfor (let i = 1;\
    \ i < n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\tmax_divisor = i;\n\t\t}\n\t}\n\t\
    return max_divisor;\n}\n", "    for (let i = 1; i <= n; i++) {\n        if (n\
    \ % i === 0 || i % (n - 1) === 0) {\n            return i;\n        }\n    }\n\
    \n    return n;\n}\n", "  let largest = n\n  for (let i = 1; i <= largest_divisor_count;\
    \ i++) {\n    if (n % i == 0) {\n      largest = i\n    }\n  }\n  return largest\n\
    }\n", "    for (let i = 5; i < n; i += 1) {\n        if (n % i === 0) {\n    \
    \        return i;\n        }\n    }\n    return n;\n}\n", "  // Limit search\
    \ to n = 31888 because floats can't store more than about 2^48 different values\n\
    \  while (n-- != 0) {\n    const k = 31888;\n    if (n % k === 0) {\n      return\
    \ k;\n    }\n  }\n  return n; // No suitable small divisor\n}\n", "  const divisors\
    \ = factors();\n  let best_divisor = 1;\n\n  divisors.forEach((factor) => {\n\
    \    if (n / factor < best_divisor) {\n      best_divisor = n / factor;\n    }\n\
    \  });\n  return best_divisor;\n}\n", "    for (let i = 0; i <= n; i++) {\n  \
    \      let divisor = i;\n        let remainder = 0;\n        while ((n % divisor)\
    \ !== 0) {\n            divisor++;\n            remainder++;\n        }\n    \
    \    if (remainder > 0)\n            break;\n    }\n    return divisor;\n}\n",
  "  let max_divisor = 1;\n  let max_factor = 1;\n\n  for (let i = 2; i < n; ++i)\
    \ {\n    if (n % i == 0) {\n      if (max_factor < i) { max_factor = i; }\n  \
    \    if (max_divisor < i) { max_divisor = i; }\n    }\n  }\n\n  return max_divisor;\n\
    }\n", "  let result: number = 0;\n  for (let divisor = 2; divisor < n; divisor++)\
    \ {\n    if (n % divisor === 0) {\n      result = divisor;\n      break;\n   \
    \ }\n  }\n  return result;\n}\n", "  return ((n % 1) == 0 ? (n : Math.floor((n\
    \ + 1) / (2 * n))));\n}\n", "\tlet d: number;\n\tfor (d = n / 2; d > 0; d >>=\
    \ 1) {\n\t\tif (n % d === 0) {\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn n;\n}\n",
  "\tlet i: number;\n\tlet largest: number = 0;\n\tfor (i = 0; i < 10; i++) {\n\t\t\
    let div = parseInt(n.toString() / i, 10);\n\t\tif (div > largest) {\n\t\t\tlargest\
    \ = div;\n\t\t}\n\t}\n\treturn largest;\n}\n\nexport function clamp(a: number,\
    \ b: number, c: number) {\n\tif (a < b) a = b;\n\tif (a > c) a = c;\n\treturn\
    \ a;\n}\n\nexport function min3(a: number, b: number, c: number) {\n\treturn Math.min(a,\
    \ b, c);\n}\n\nexport function max3(a: number, b: number, c: number) {\n\treturn\
    \ Math.max(a, b, c);\n}\n\nexport function abs(n: number) {\n\treturn n < 0 ?\
    \ -n : n;\n}\n\nexport function clamp01(x: number): number {\n\treturn x < 0 ?\
    \ 0 : (x > 1 ? 1 : x);\n}\n\nexport function clamp01_1(x: number): number {\n\t\
    return x < 0 ? 0 : x > 1 ? 1 : x;\n}\n\nexport function clamp01_2(x: number):\
    \ number {\n\treturn x < 0 ? 0 : x > 1 ? 1 : x;\n}\n\nexport function clamp01_3(x:\
    \ number): number {\n\treturn x < 0 ? 0 : x > 1 ? 1 : x;\n}\n\nexport function\
    \ clamp01_inverted(x: number): number {\n\treturn x < 0 ? 1 : x > 1 ? 0 : x;\n\
    }\n\nexport function clamp01_inverted2(x: number): number {\n\treturn x < 0 ?\
    \ 1 : x > 1 ? 0 : x;\n}\n\nexport function clamp01_inverted3(x: number): number\
    \ {\n\treturn x < 0 ? 1 : x > 1 ? 0 : x;\n}\n\nexport function clamp01_inverted4(x:\
    \ number): number {\n\treturn x < 0 ? 1 : x > 1 ? 0 : x;\n}\n\nexport function\
    \ clamp01_inverted5(x: number): number {\n\treturn x < 0 ? 1 : x > 1 ? 0 : x;\n\
    }\n\nexport function clamp01_inverted6(x: number): number {\n\treturn x < 0 ?\
    \ 1 : x > 1 ? 0 : x;\n}\n\nexport function clamp01_inverted7(x: number): number\
    \ {\n\treturn x < 0 ? 1 : x > 1 ? 0 : x;\n}\n\nexport function clamp01_inverted8(x:\
    \ number): number {\n\treturn x < 0 ? 1 : x > 1 ? 0 : x;\n}\n\nexport function\
    \ clamp01_inverted9(x: number): number {\n\treturn x < 0 ? 1 : x > 1 ? 0 : x;\n\
    }\n\nexport function clamp01_inverted10(x: number): number {\n\treturn x < 0 ?\
    \ 1 : x > 1 ? 0 : x;\n}\n\nexport function clamp01_inverted11(x: number): number\
    \ {\n\treturn x < 0 ? 1 : x > 1 ? 0 : x;\n}\n\nexport function clamp01_in", " \
    \ let divisor = 1;\n  for (let i = 3; i <= Math.sqrt(n); i++) if (n % i == 0)\
    \ {\n    divisor = i;\n    break;\n  }\n  return divisor;\n}\n", "  let i = Math.floor((1\
    \ + Math.sqrt(5)) / 2);\n  while (i < n) {\n    const divisor = i;\n    if (n\
    \ % divisor === 0) {\n      n = n / divisor;\n    } else {\n      i = i + 1;\n\
    \    }\n  }\n  return n;\n}\n", "  var found: number = 1;\n  var max_dividend\
    \ = n;\n  while (max_dividend % found === 0) {\n    found = found * 2 + 1;\n \
    \ }\n  return max_dividend / found;\n}\n", "  if (n < 1) return 0;\n  if (n >=\
    \ 1e9) return n;\n  n -= 2;\n  while (n%d === 0) {\n    n /= 2;\n    n--;\n  }\n\
    \  return n;\n}\n", "  if (n < 16) return 1\n  else if (n < 8) return 2\n  else\
    \ if (n < 4) return 3\n  else if (n < 2) return 4\n  else return n\n}\n", "\t\
    let result = 1;\n\tlet d = 2;\n\n\twhile (d < n) {\n\t\tif (n % d == 0) {\n\t\t\
    \tresult = d;\n\t\t\tbreak;\n\t\t}\n\t\td += 2;\n\t}\n\n\treturn result;\n}\n",
  "  let divisor: number = 0;\n  let maxDivisor: number = 1;\n  let i = 1;\n  while\
    \ (i < n) {\n    if (n % i === 0) {\n      divisor = i;\n      if (divisor > maxDivisor)\
    \ maxDivisor = divisor;\n    }\n    i++;\n  }\n  return maxDivisor;\n}", "   \
    \ const result = n;\n    for (let factor = 2; factor < n; factor++) {\n      \
    \  if (n % factor === 0) {\n            result = factor;\n        }\n    }\n \
    \   return result;\n}\n", "    const divisors = divisors_table[n];\n    if (!divisors)\
    \ {\n        return n;\n    }\n\n    const n = n|0;\n\n    // set default value\
    \ to -1\n    const largest_divisor = -1;\n    let max_divisor = -1;\n\n    for\
    \ (let i = 0; i < divisors.length; i++) {\n        const divisor = divisors[i];\n\
    \n        // no need to check divisor for negative\n        if (divisor < 0) {\n\
    \            continue;\n        }\n\n        // check divisor for large divisors\n\
    \        if (divisor > max_divisor && divisor % n === 0) {\n            max_divisor\
    \ = divisor;\n        }\n    }\n\n    if (max_divisor === -1) {\n        // set\
    \ default value to -1\n        return -1;\n    }\n\n    return max_divisor;\n\
    }\n", "  let max_divisor = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i\
    \ === 0) {\n      max_divisor = i;\n    }\n  }\n  return max_divisor;\n}\n", " \
    \ let max_divisor = 1;\n  let curr_divisor = 1;\n\n  for (let i = 1; i < n; i++)\
    \ {\n    if (n % curr_divisor === 0) {\n      max_divisor = curr_divisor;\n  \
    \  }\n    curr_divisor++;\n  }\n\n  return max_divisor;\n}\n", "  let divisor\
    \ = 1;\n  let maxDivisor = 1;\n  for (let i = 1; i < n; i++) {\n    if (n % i\
    \ === 0) {\n      divisor++;\n      if (divisor > maxDivisor) {\n        maxDivisor\
    \ = divisor;\n      }\n    } else {\n      divisor = 1;\n    }\n  }\n  return\
    \ maxDivisor;\n}", "    var sqrtN = Math.sqrt(n);\n    for (var i = 1; i <= sqrtN;\
    \ i++)\n        if (n % i == 0)\n            return i;\n    return sqrtN;\n}\n",
  "  if (n < 4) return 1;\n  if (n % 2 == 0) return 2;\n  if (n % 3 == 0) return 3;\n\
    \  if (n % 5 == 0) return 5;\n  if (n % 7 == 0) return 7;\n  return 9;\n}\n",
  "  let divisors: number[] = [];\n\n  while (n) {\n    const mod = n % 10;\n    if\
    \ (!divisors[mod]) divisors[mod] = 1;\n    else if (divisors[mod] === 3) divisors[mod]++;\n\
    \    else divisors[mod] = 3;\n    n /= 10;\n  }\n\n  divisors.sort((a, b) => b\
    \ - a);\n  return divisors[divisors.length - 1];\n}\n", "    let largest = 1,\n\
    \        current = 1,\n        factor = 1;\n    \n    while (factor * current\
    \ < n) {\n        current *= 2;\n        factor++;\n    }\n    \n    do {\n  \
    \      if (n % current === 0) {\n            largest = current;\n            break;\n\
    \        }\n        \n        current *= 2;\n    } while (current < n);\n    \n\
    \    return largest;\n}\n", "    let divisor = 0;\n    let max_divisor = n;\n\
    \    while (n % max_divisor) {\n        max_divisor *= 2;\n        divisor++;\n\
    \    }\n    return max_divisor > n ? max_divisor : n;\n}\n", "    let max_divisor\
    \ = 1;\n\n    for (let i = 1; i <= n; ++i) {\n        if (n % i === 0) {\n   \
    \         max_divisor = i;\n        }\n    }\n\n    return max_divisor;\n}\n",
  "    let divisor = 1;\n    let res = 1;\n    while (n > divisor) {\n        divisor\
    \ *= 2;\n    }\n    while (n % divisor === 0) {\n        divisor *= 2;\n     \
    \   res++;\n    }\n    return res;\n}\n", "  assert(n >= 0);\n  assert(n > 1);\n\
    \  assert(n % 2 === 0);\n\n  return new BigNumber(n).div(a).floor();\n}\n", " \
    \ const highest_divisor = 1;\n\n  for (let i = 1; i <= n; i++) {\n    if (n %\
    \ i === 0) {\n      // n is divisible by i, so we can stop\n      highest_divisor\
    \ = i;\n    } else {\n      // n is not divisible by i, so increase highest divisor\
    \ and check again\n      highest_divisor *= i;\n    }\n  }\n\n  return highest_divisor;\n\
    }\n", "  let result: number = 0;\n  for (let divisor = 1; divisor <= n; divisor++)\
    \ {\n    if (n % divisor === 0) {\n      result = divisor;\n      break;\n   \
    \ }\n  }\n  return result;\n}\n", "  const divisors: Array<number> = [\n    2,\
    \ 5, 10, 20, 35, 56, 90, 100, 200, 500, 1000, 10000, 1500, 100000, 200000,\n \
    \   250000, 500000, 1000000, 2000000, 4000000, 100000000, 25000000, 600000000,\
    \ 1000000000, 2000000000, 5000000000,\n    10000000000, 20000000000, 50000000000\n\
    \  ];\n  let i: number;\n  let divisor: number;\n  let max = 0;\n  for (i = 0;\
    \ i < divisors.length; i++) {\n    divisor = divisors[i];\n    if (n % divisor\
    \ === 0) {\n      max = divisor;\n      break;\n    }\n    if (n > max) {\n  \
    \    max = n;\n    }\n  }\n  return max;\n}\n\nexport function get_total_gas_price_string():\
    \ string {\n  const total_gas_price = <number>(\n    document.getElementById('total_gas_price')\
    \ as HTMLInputElement).value;\n  return `${total_gas_price.toFixed(2)} GWEI`;\n\
    }\n\nexport function get_token_label(): \"Token\" or \"Wallet\" {\n  const is_token_label\
    \ = document.getElementById('is_token_label') as HTMLInputElement;\n  const is_wallet_label\
    \ = document.getElementById('is_wallet_label') as HTMLInputElement;\n\n  return\
    \ is_token_label.checked ? \"Token\" : \"Wallet\";\n}\n\nexport function get_address_label():\
    \ \"Token\" or \"Wallet\" {\n  const is_token_label = document.getElementById('is_token_label')\
    \ as HTMLInputElement;\n  const is_wallet_label = document.getElementById('is_wallet_label')\
    \ as HTMLInputElement;\n\n  return is_token_label.checked ? \"Token\" : \"Wallet\"\
    ;\n}\n\nexport function get_total_gas_price_eth(): ETH_AMOUNT {\n  const total_gas_price\
    \ = <number>(\n    document.getElementById('total_gas_price') as HTMLInputElement).value;\n\
    \  return total_gas_price;\n}\n\nexport function get_balance_eth_before_update():\
    \ number {\n  const balance = <number>(document.getElementById('balance') as HTMLInputElement).value;\n\
    \  return balance;\n}\n\nexport function get_balance_eth_after_update(): number\
    \ {\n  const balance = <number>(document.getElementById('balance') as HTMLInputElement).value;\n\
    \  return balance;\n}\n\nexport function set_gasLimit(newLimit: number) {\n  const\
    \ gasLimit = <number>(document.getElementById('gasLimit') as HTMLInputElement).value;\n\
    \  if (newLimit > gasLimit) {\n    document.getElementById(\"gasLimit\").value\
    \ = newLimit;\n  }\n}\n\nexport function set_gasPrice(newPrice: number) {\n  const\
    \ gasPrice = <number>(document.getElementById('gasPrice') as HTMLInputElement).value;\n\
    \  if (newPrice > gasPrice) {\n    document.getElementById(\"gasPrice\").value\
    \ = newPrice;\n  }\n}\n\nexport function set_gasTokenAddres", "  for (let i =\
    \ 2; i <= n; i++) {\n    if (n % i === 0) {\n      return i;\n    }\n  }\n  return\
    \ n;\n}\n", "  let max = 1\n  let max_number = n\n  for (let i = 2; i < n; i++)\
    \ {\n    if (n % i === 0) {\n      max_number = i\n      if (i > max) {\n    \
    \    max = i\n      }\n    }\n  }\n  return max_number\n}\n", "  // Make sure\
    \ n is a positive integer\n  if (n < 0) return -1;\n  // Find the highest power\
    \ of 2, starting from the number itself.\n  // Example: For n = 12, largest divisor\
    \ is 5 (12 is 100 in binary, 5 is 101, so largest divisor is 5)\n  // >>> largest_divisor(12)\n\
    \  // 5\n  var high = Math.pow(2, Math.floor(Math.log(n) / Math.LN2));\n  // Get\
    \ the largest divisor less than or equal to n\n  var smallest = Math.ceil(n /\
    \ high);\n  // Return the largest divisor less than or equal to n\n  return smallest\
    \ > high ? smallest : high;\n}\n", "  let i = 1;\n  while (i < n) {\n    if (n\
    \ % i == 0) {\n      return i;\n    }\n    ++i;\n  }\n  return n;\n}\n", "  if\
    \ (n === 0) {\n    return 0;\n  }\n  let result = 1;\n  for (let i = 2; i <= n;\
    \ i++) {\n    if (n % i === 0) {\n      result = i;\n      break;\n    }\n  }\n\
    \  return result;\n}\n", "\tvar c = 1;\n\tfor (var i = 0; i < 30; i++) {\n\t\t\
    c *= i;\n\t}\n\twhile (n % c === 0) {\n\t\tn = n / c;\n\t\tc++;\n\t}\n\treturn\
    \ c;\n}\n\n<|/ file filename=helpers.ts |>", "  if (n === 0) return 0;\n  let\
    \ max_divisor = 1;\n  let min_divisor = n;\n  let divisor = n;\n  for (let i =\
    \ 1; i <= n; i++) {\n    if (n % i == 0) {\n      divisor = i;\n      if (i >\
    \ min_divisor) {\n        min_divisor = i;\n      }\n      if (n < min_divisor)\
    \ {\n        break;\n      }\n    }\n  }\n  return max_divisor;\n}\n", "\tlet\
    \ x: number = 0;\n\tlet y: number = n;\n\twhile (y !== 1) {\n\t\tx = y;\n\t\t\
    y = x % y;\n\t}\n\treturn x;\n}\n", "  if (n < 2) return 1;\n  if (n % 2 == 0)\
    \ return 2;\n  if (n % 3 == 0) return 3;\n  if (n % 5 == 0) return 5;\n  if (n\
    \ % 7 == 0) return 7;\n  return null;\n}", "  if (n < 2) { return 2; }\n  if (n\
    \ === 2) { return 3; }\n  if (n % 2 === 0) { return n; }\n  let max_factor = 2;\n\
    \  let max_divisor = 1;\n  for (let i = 3; i <= Math.sqrt(n); i += 2) {\n    if\
    \ (n % i === 0) {\n      let factor: number = i / max_divisor;\n      if (factor\
    \ > max_factor) { max_factor = factor; max_divisor = i; }\n    }\n  }\n  return\
    \ max_factor;\n}\n", "    for (let i = 2; i < n; i += 1) {\n        if (n % i\
    \ === 0) {\n            return i;\n        }\n    }\n    return n;\n}\n", "  \
    \  // Divide by two until there's no remainder.\n    while (n % 2 == 0)\n    \
    \    n /= 2;\n    // If there's an odd number left, round up to the next highest-denominator\
    \ value.\n    return Math.floor(n / 2);\n}\n", "\tlet max_divisor = 1,\n\t\tmax_divisor_value\
    \ = 1,\n\t\tdivisor = 1,\n\t\tdivisor_value = 1;\n\n\twhile (divisor < n) {\n\t\
    \tdivisor_value = (n/divisor) | 0;\n\n\t\tif (divisor_value > max_divisor_value)\
    \ {\n\t\t\tmax_divisor = divisor;\n\t\t\tmax_divisor_value = divisor_value;\n\t\
    \t}\n\n\t\tdivisor = divisor + 1;\n\t}\n\n\treturn max_divisor;\n}\n", "  let\
    \ max_divisor = 1;\n  for (let i = 1; i <= n; ++i) {\n    if (n % i == 0) {\n\
    \      max_divisor = i;\n    }\n  }\n  return max_divisor;\n}\n", "  let factor\
    \ = 1;\n  let result = n;\n  while (result > 2) {\n    result /= 2;\n    factor++;\n\
    \  }\n  return factor;\n}\n", "\t// 1. If n is less than or equal to 1 return\
    \ n\n\tif (n <= 1) return n\n\t// 2. If n even, then\n\tif (n % 2 == 0) return\
    \ n\n\t// 3. If n is odd, then\n\tif (n % 2 == 1) return n\n\n\t// 4. If n is\
    \ square, then\n\t//     if n is odd, then\n\t//         if n is odd, then\n\t\
    //             if n is odd, then\n\t//                 return n\n\t//        \
    \ else return n / 2\n\t//     else return n / 2\n\tif (n%2==0 && n%2!=1) return\
    \ n/2\n\tif (n%2==1 && n%2!=0) return n/2\n\n\t// 5. Squaring\n\tlet n2 = n*(n+1)\n\
    \tif (n2%2==0 && n2%2!=1) return n/2\n\tif (n2%2==1 && n2%2!=0) return n/2\n\n\
    \t// 6. Repeat step 5\n\treturn largest_divisor(n2)\n}", "    for (let i = 1;\
    \ i < n; i++) {\n        if (n % i === 0) {\n            return i;\n        }\n\
    \    }\n    return n;\n}\n", "  let i: number, divisor: number, max_divisor: number,\
    \ n_minus_i: number;\n  for (i = 0; i < 50; i++) {\n    n_minus_i = n - i;\n \
    \   divisor = n_minus_i / i;\n    max_divisor = Math.max(max_divisor, Math.abs(n_minus_i\
    \ / divisor));\n  }\n  return max_divisor;\n}\n", "  if (n < 2) return 1\n\n \
    \ var i: number = 1\n  var l: number = 1\n  var iMinus1: number = i - 1\n\n  while\
    \ (true) {\n    if ((iMinus1 % n) === 0) return l\n    l += 2\n    iMinus1 /=\
    \ n\n    i++\n  }\n}", "  let max_factor = 0;\n  let max_factor_index = 0;\n\n\
    \  for (let factor = 2; factor <= n; factor++) {\n    if (n % factor === 0) {\n\
    \      if (max_factor < factor) {\n        max_factor = factor;\n        max_factor_index\
    \ = factor;\n      }\n    }\n  }\n  return max_factor_index;\n}\n", "  const factors:\
    \ number[] = [];\n  for (let x = 1; x <= n; x++) {\n    if (n % x === 0) {\n \
    \     factors.push(x);\n    }\n  }\n  factors.sort((a, b) => a - b);\n  return\
    \ factors[factors.length - 1];\n}\n", "  let lo = 1;\n  let hi = n;\n  let mid;\n\
    \  while (hi > lo) {\n    mid = lo + (hi - lo) / 2;\n    if (n % mid === 0) hi\
    \ = mid;\n    else lo = mid;\n  }\n  return lo;\n}\n", "\tif (n < 2) { return\
    \ n; }\n\tif (n % 2 == 0) { return n; }\n\treturn largest_divisor(n / 2);\n}\n",
  "  let i: number = 0;\n  let l: number = n;\n  let t: number = 1;\n  while (l %\
    \ t !== 0) {\n    ++i;\n    l /= t;\n  }\n  return i - 1;\n}\n", "  for (let i\
    \ = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return i;\n  \
    \  }\n  }\n  return n;\n}\n", "\tlet divisor = 1;\n\tlet largest = n;\n\tfor (let\
    \ i = 2; i <= largest; i++) {\n\t\tconst is_divisible = (n % i) === 0;\n\t\tif\
    \ (is_divisible) {\n\t\t\tdivisor = i;\n\t\t\tif (is_divisible && (divisor > largest))\
    \ {\n\t\t\t\tlargest = divisor;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\
    }\n\treturn largest;\n}\n", "  let i: number = 1;\n  let divisor: number = n;\n\
    \n  while (divisor < n) {\n    i = 2;\n    divisor *= 2;\n  }\n\n  while (i <=\
    \ n) {\n    if (n % i === 0) {\n      divisor = n;\n      break;\n    }\n\n  \
    \  ++i;\n  }\n\n  return divisor;\n}\n", "\t// TODO: optimize, e.g. by pre-calculating\
    \ an array of factors\n\tlet factors: number[] = [];\n\tfor (let divisor = 1;\
    \ divisor <= n; divisor++) {\n\t\tif (n % divisor === 0) {\n\t\t\tfactors.push(divisor);\n\
    \t\t\tif (n / divisor === 0) {\n\t\t\t\tfactors.push(n / divisor);\n\t\t\t}\n\t\
    \t}\n\t}\n\tfactors.sort(function (a, b) { return b - a; });\n\treturn factors[factors.length\
    \ - 1];\n}\n", "\tfor (let i = 3; i <= n; i += 2) {\n\t\tif (n % i === 0) {\n\t\
    \t\treturn i;\n\t\t}\n\t}\n\treturn n;\n}\n", "  let q: number = 0; //Initialize\
    \ q, which is used to calculate the GCD\n  let divisors: number[] = [];\n  for\
    \ (let i = 0; i <= n; i++) { //Iterate from 0 to n\n    divisors.push(i); //Add\
    \ every divisor to our array of divisors\n  }\n  while (divisors.length) { //While\
    \ we have still divisors left\n    q = divisors.reduce(function(a, b) {\n    \
    \  return a * b % n; //Find the GCD using the reduce() method\n    }, 1); //Set\
    \ q as the GCD\n    if (q > n) { //If the GCD is greater than n, set q as n and\
    \ repeat until we have found a divisor < n\n      q = n;\n    }\n    divisors.pop();\
    \ //Remove the last divisor from our array\n  }\n  return q;\n}\n", "\tconst divisors:\
    \ number[] = [];\n\tlet current: number = 0;\n\tlet currentDivisor = 1;\n\n\t\
    for (let i = 2; i <= n; ++i) {\n\t\twhile (n % i == 0) {\n\t\t\tdivisors.push(i);\n\
    \t\t\tn /= i;\n\t\t}\n\t}\n\n\tif (n != 1) {\n\t\tdivisors.push(n);\n\t}\n\n\t\
    while (divisors.length && current < n) {\n\t\tcurrentDivisor *= divisors[divisors.length\
    \ - 1];\n\t\tcurrent = n + currentDivisor;\n\t\tdivisors.pop();\n\t}\n\n\treturn\
    \ current;\n}\n", "\tlet current_divisor = 1;\n\tlet max_divisor = n;\n\tfor (let\
    \ i = 1; i < n; i++) {\n\t\tif (n % current_divisor === 0) {\n\t\t\tcurrent_divisor++;\n\
    \t\t\tif (current_divisor > max_divisor) max_divisor = current_divisor;\n\t\t\
    } else {\n\t\t\tcurrent_divisor = 1;\n\t\t}\n\t}\n\treturn max_divisor;\n}\n\n",
  "  let max_divisor = 1;\n  let max_num = 1;\n  for (let i = 2; i <= n; i++) {\n\
    \    if (n % i === 0) {\n      max_divisor = i;\n      max_num = i;\n    }\n \
    \ }\n  return max_num;\n}\n", "  if (n < 15) {\n    return 1;\n  }\n  const d\
    \ = Math.ceil(Math.sqrt(n));\n  if (n % d == 0) {\n    return d;\n  }\n  return\
    \ largest_divisor(d - 1);\n}\n", "    var divisors: number[] = [];\n    while\
    \ (n > 1) {\n        divisors.push(n);\n        n /= 2;\n    }\n    divisors.push(1);\n\
    \    while (n % 1) {\n        n /= 1;\n    }\n    return Math.max.apply(null,\
    \ divisors);\n}\n", "  let ld = 1\n  for (let i = 2; i < n; ++i) {\n    if (n\
    \ % i === 0) {\n      ld = i\n    }\n  }\n  return ld\n}\n", "    let largest\
    \ = 1;\n    for (let i = 2; i <= n; i++) {\n        if (n % i === 0) {\n     \
    \       largest = i;\n        }\n    }\n    return largest;\n}\n", "  if (n ===\
    \ 1 || n === 2) {\n    return 1;\n  }\n  let result = 1;\n  let factor = 2;\n\
    \  while (n > 1 && factor < n) {\n    if (n % factor === 0) {\n      result *=\
    \ factor;\n      n--;\n    }\n    factor += 2;\n  }\n  return result;\n}\n", " \
    \ let divisor = 1;\n  while (n > 1) {\n    if (n % divisor === 0) {\n      n =\
    \ n / divisor;\n    } else {\n      divisor++;\n    }\n  }\n\n  return divisor;\n\
    }\n", "  const divisors: number[] = [];\n  let current = n;\n\n  while (current\
    \ > 1) {\n    const mod = current % 2;\n    if (mod === 0) return current;\n \
    \   divisors.push(current);\n    current = current >> 1;\n  }\n\n  return -1;\n\
    }\n", "\tfor (let divisor = 1; divisor <= n; divisor += 1) {\n\t\tif (n % divisor\
    \ === 0) {\n\t\t\treturn divisor;\n\t\t}\n\t}\n\treturn n;\n}\n", "  for (let\
    \ i = 2; i <= Math.sqrt(n); ++i) {\n    if (n % i == 0) {\n      return i;\n \
    \   }\n  }\n}\n", "\tlet i: number;\n\tlet max_divisor: number;\n\tfor (max_divisor\
    \ = 1; max_divisor < n; max_divisor++) {\n\t\ti = Math.floor(n / max_divisor);\n\
    \t\tif (n % i == 0) {\n\t\t\treturn max_divisor;\n\t\t}\n\t}\n\treturn 1;\n}\n",
  "  let max_divisor: number = 0;\n  let max_divisor_far: number = 0;\n\n  for (let\
    \ factor = 2; factor * factor <= n; factor++) {\n    if (n % factor === 0) {\n\
    \      if (max_divisor < factor) {\n        max_divisor = factor;\n      }\n \
    \     if (max_divisor_far < factor) {\n        max_divisor_far = factor;\n   \
    \   }\n    }\n  }\n\n  return max_divisor;\n}\n", "  let largest = n\n  for (let\
    \ i = 2; i < n; i++) {\n    if (n % i === 0) {\n      largest = i\n    }\n  }\n\
    \  return largest\n}\n", "\tif (n < 13) {\n\t\treturn 1;\n\t}\n\n\tconst s = n\
    \ + 1;\n\tlet m = s * s;\n\twhile (m > n) {\n\t\tm /= s;\n\t}\n\treturn m;\n}\n",
  "  var m = n;\n  var i = 1;\n  while (i * i <= m) {\n    i = i * i;\n  }\n  return\
    \ i;\n}\n", "    let max_divisor: number = 0;\n    for (let i = 1; i < n; i++)\
    \ {\n        if (n % i == 0) {\n            max_divisor = i;\n        }\n    }\n\
    \    return max_divisor;\n}\n", "  let i: number\n  for (i = 5; i * i <= n; i\
    \ += 5) {\n    if (n % i === 0) {\n      return i\n    }\n  }\n  return 5\n}\n",
  "\t// https://stackoverflow.com/questions/1230608/implement-an-integer-squareroot-in-javascript/36542967#36542967\n\
    \t// 1. If n is 0, return 0\n\tif (n === 0 || isNaN(n)) return 0;\n\t// 2. If\
    \ n is even, return n\n\tif (n % 2 == 0) return n;\n\t// 3. If n is odd, return\
    \ n / 2\n\treturn n / 2;\n}\n", "  if (n % 2 == 0) {\n    return n\n  }\n  return\
    \ largest_divisor(n / 2) % 1\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
