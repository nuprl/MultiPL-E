name: HumanEval_162_string_to_md5
language: ts
prompt: "//Given a string 'text', return its md5 hash equivalent string.\n// If 'text'\
  \ is an empty string, return undefined.\n// >>> string_to_md5(\"Hello world\")\n\
  // \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunction string_to_md5(text: string): string\
  \ | undefined {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = string_to_md5;\n  assert.deepEqual(candidate(\"Hello\
  \ world\"),\"3e25960a79dbc69b674cd4ec67a72c62\");\n  assert.deepEqual(candidate(\"\
  \"),undefined);\n  assert.deepEqual(candidate(\"A B C\"),\"0ef78513b0cb8cef12743f5aeb35f888\"\
  );\n  assert.deepEqual(candidate(\"password\"),\"5f4dcc3b5aa765d61d8327deb882cf99\"\
  );\n}\n\ntest();"
completions: ["    const md5sum: Uint8Array | undefined = undefined;\n\n    if (text\
    \ === \"\") {\n        return undefined;\n    }\n\n    const md5sum_b64 = Buffer.from(md5(text)).toString(\"\
    base64\");\n    const split_b64 = md5sum_b64.match(/.{1,2}/g).map(\n        v\
    \ => String.fromCharCode(parseInt(v, 16)),\n    );\n    const md5sum_bytes = split_b64.map(\n\
    \        v => v.charCodeAt(0) & 255,\n    );\n\n    const split_bytes = md5sum_bytes.match(/.{1,2}/g).map(\n\
    \        v => String.fromCharCode(parseInt(v, 16)),\n    );\n\n    md5sum = new\
    \ Uint8Array(split_bytes);\n\n    // Remove the padding.\n    if (split_b64.length\
    \ - 1 === md5sum.length) md5sum.pop();\n    return toHexString(md5sum);\n}\n",
  "\tif (text.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet buf: Uint8Array;\n\
    \tlet md: number[] = [];\n\tlet i = 0;\n\tconst len = text.length;\n\tfor (; i\
    \ < len; i++) {\n\t\tbuf[i] = text.charCodeAt(i);\n\t}\n\tconst hash = CryptoJS.lib.WordArray.create(buf,\
    \ (len * 8));\n\tlet len = hash.length;\n\tconst mdBuf = new Uint8Array(len *\
    \ 4);\n\tlet i = 0;\n\tfor (; i < len; i++) {\n\t\tmdBuf[i] = hash[i].toString(16);\n\
    \t}\n\tmd = mdBuf.slice(0, 4).toString();\n\treturn md;\n}\n", "    return typeof\
    \ text === \"string\" ? hex_md5(text) : undefined;\n}", "    const hash = crypto.createHash('md5');\n\
    \    hash.update(text);\n    return hash.digest('hex');\n}\n", "  if (text ===\
    \ \"\") {\n    return undefined;\n  }\n  const md5 = (text + \"00000000\" + text).slice(0,\
    \ 16);\n  return md5.match(/[a-z0-9]{32}/i);\n}\n\nexport function string_to_int(\n\
    \  str: string\n): number | undefined {\n  if (str === \"\") {\n    return undefined;\n\
    \  }\n  return parseInt(str, 10);\n}\n", "  if (typeof text === 'string') {\n\
    \    return text.substring(0, 16) + '\\n' + text.substring(16, 32) + '\\n' + text.substring(32,\
    \ 48) + '\\n' + text.substring(48);\n  }\n  return undefined;\n}\n", "  if (typeof\
    \ text !== \"string\") return undefined;\n  return crypto.createHash(\"md5\").update(text).digest(\"\
    hex\");\n}\n", "  if (!text) {\n    return undefined;\n  }\n\n  if (typeof text\
    \ !== 'string') {\n    throw Error(\"Expected a string.\");\n  }\n\n  if (text.length\
    \ === 0) {\n    return undefined;\n  }\n\n  let hash = crypto.createHash('md5');\n\
    \  hash.update(text, 'utf8');\n  return hash.digest('hex');\n}\n\nexport function\
    \ set_url_query_param(url: string, param_name: string, param_value: string) {\n\
    \  let search_part = encodeURIComponent(param_name) + \"=\" + encodeURIComponent(param_value);\n\
    \  let url_regex = new RegExp(\"[?&]\" + search_part + \"(#|$)\", \"i\");\n  let\
    \ url_parts = url.split(\"?\");\n\n  if (url_parts[0] === \"\") {\n    url_parts[0]\
    \ = \"?\";\n  }\n  if (url_regex.test(url_parts[0])) {\n    return url_parts[0]\
    \ + search_part + \"&\" + url_parts[1];\n  }\n  return url + \"?\" + search_part;\n\
    }\n", "    if (typeof text === 'undefined' || text === '') {\n        return undefined;\n\
    \    }\n    const md5 = crypto.createHash('md5');\n    md5.update(text);\n   \
    \ return md5.digest('hex');\n}", "    if (typeof text !== 'string') {\n      \
    \  return undefined;\n    }\n    return crypto.createHash('md5').update(text).digest('hex');\n\
    }\n", "  if (typeof text !== \"string\") {\n    return undefined;\n  }\n\n  const\
    \ utf8Text = utf8Encode(text);\n  const hash = hashMd5(utf8Text);\n\n  return\
    \ typeof hash === \"string\" ? hash : undefined;\n}\n", "    if (!text) {\n  \
    \      return undefined;\n    }\n\n    const digest = crypto.createHash('md5').update(text).digest('hex');\n\
    \    return digest;\n}\n", "    if (!text) {\n        return undefined;\n    }\n\
    \    if (typeof text === \"string\") {\n        md5_update_1(a, unsafe_hash(text));\n\
    \    }\n    else { //For binary strings.\n        md5_update_1(a, text);\n   \
    \ }\n    return hex_md5(a + \"\");\n}", "  return text ? hash(text) : undefined\n\
    }\n", "    return text ? md5(text) : undefined;\n}\n", "    if (text === \"\"\
    ) {\n        return undefined;\n    }\n    let hash: Array<number> = md5(text);\n\
    \    let hash_string = hash.toString();\n    return hash_string;\n}", "  if (text\
    \ === \"\") return undefined;\n  return crypto.createHash(\"md5\").update(text).digest(\"\
    hex\");\n}\n", "  return text ? crypto_1.createHash('md5').update(text).digest('hex')\
    \ : undefined;\n}\n", "    if (typeof text === \"string\" && text.length > 0)\
    \ {\n        // Remove any new line characters\n        // eslint-disable-next-line\
    \ no-control-regex\n        text = text.replace(/[\\n]/g, \"\");\n\n        //\
    \ Use MD5 hash to generate MD5 hash digest\n        // https://stackoverflow.com/questions/7616461/generate-md5-hash-in-javascript\n\
    \        const hashText: string = crypto.createHash(\"md5\").update(text).digest(\"\
    hex\");\n\n        // Remove any non-hexadecimal characters\n        // eslint-disable-next-line\
    \ no-control-regex\n        hashText = hashText.replace(/^[^a-f0-9]+/i, \"\");\n\
    \n        return hashText;\n    }\n}\n", "  if (!text) {\n    return undefined\n\
    \  }\n  const hash = crypto.createHash('md5')\n  hash.update(text)\n  return hash.digest('hex')\n\
    }\n", "  if (typeof text !== \"string\") {\n    console.warn(\"Warning: Input\
    \ argument should be a string.\");\n    return undefined;\n  }\n  text = text.replace(/\\\
    s+/g, \"\"); // Remove spaces from string.\n  var hash = crypto.createHash(\"\
    md5\").update(text).digest(\"hex\");\n  return hash === \"\" ? '' : hash;\n}\n",
  "    if (typeof text === 'undefined' || text === '') {\n        return undefined;\n\
    \    }\n    const md5 = (text.length * 4 + md5Array.length);\n    const buffer\
    \ = new ArrayBuffer(md5);\n    const input = new Uint32Array(buffer);\n    for\
    \ (let i = 0; i < md5Array.length; i += 4) {\n        input[i] = md5.charCodeAt(i);\n\
    \        input[i + 1] = md5.charCodeAt(i + 1);\n        input[i + 2] = md5.charCodeAt(i\
    \ + 2);\n        input[i + 3] = md5.charCodeAt(i + 3);\n    }\n    return crypto_1$1.arrayBufferToHex(buffer);\n\
    }\n", "  if (!text) return undefined;\n  let hash;\n  try {\n    hash = crypto.createHash('md5').update(text).digest('hex');\n\
    \  } catch (err) {\n    console.error('[ERROR] Error while generating MD5 hash\
    \ from string', err);\n    return undefined;\n  }\n  return hash;\n}\n", "  const\
    \ textLen = text.length\n  let hashString = crypto.createHash(\"md5\").update(text).digest(\"\
    hex\")\n  if (textLen === 0) {\n    return undefined\n  }\n  // trim spaces from\
    \ the end of the string\n  hashString = hashString.trim()\n  if (hashString ===\
    \ \"\") {\n    return undefined\n  }\n  // remove trailing spaces\n  return hashString.replace(/\\\
    s+$/, \"\")\n}\n", "  if (typeof text === 'undefined' || text === '') {\n    return\
    \ undefined;\n  }\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n\
    \  return hash.digest('hex');\n}\n", "  if (text === \"\") {\n    return undefined;\n\
    \  }\n  return crypto.createHash(\"md5\").update(text).digest(\"hex\");\n}\n",
  "  if (!text) return undefined;\n  return crypto.createHash('md5').update(text).digest('hex');\n\
    }\n", "  if (typeof text !== \"string\") {\n    return undefined;\n  }\n  const\
    \ md5 = crypto.createHash(\"md5\");\n  md5.update(text, \"utf8\");\n  return md5.digest(\"\
    hex\");\n}\n", "\tif (text === \"\") {\n\t\treturn undefined; // undefined\n\t\
    }\n\n\tconst md5sum = crypto.createHash(\"md5\");\n\tmd5sum.update(text, \"utf8\"\
    );\n\n\tconst hash = md5sum.digest(\"hex\");\n\n\treturn hash;\n}\n", "    if\
    \ (typeof text !== \"string\") {\n        return undefined;\n    }\n    const\
    \ hash = crypto.createHash(\"md5\");\n    hash.update(text);\n    return hash.digest(\"\
    hex\");\n}\nexports.string_to_md5 = string_to_md5;\n", "    if (typeof text ===\
    \ \"string\" && text.length > 0) {\n        var md5sum = \"\";\n        var text\
    \ = text.toLowerCase();\n        for (let i = 0; i < text.length; i++) {\n   \
    \         md5sum += (text[i] === \"a\" ? \"A\" : \"a\") +\n                (text[i]\
    \ === \"b\" ? \"B\" : \"b\") +\n                (text[i] === \"c\" ? \"C\" : \"\
    c\") +\n                (text[i] === \"d\" ? \"D\" : \"d\") +\n              \
    \  (text[i] === \"e\" ? \"E\" : \"e\") +\n                (text[i] === \"f\" ?\
    \ \"F\" : \"f\") +\n                (text[i] === \"g\" ? \"G\" : \"g\") +\n  \
    \              (text[i] === \"h\" ? \"H\" : \"h\") +\n                (text[i]\
    \ === \"i\" ? \"I\" : \"i\") +\n                (text[i] === \"j\" ? \"J\" : \"\
    j\") +\n                (text[i] === \"k\" ? \"K\" : \"k\") +\n              \
    \  (text[i] === \"l\" ? \"L\" : \"l\") +\n                (text[i] === \"m\" ?\
    \ \"M\" : \"m\") +\n                (text[i] === \"n\" ? \"N\" : \"n\") +\n  \
    \              (text[i] === \"o\" ? \"O\" : \"o\") +\n                (text[i]\
    \ === \"p\" ? \"P\" : \"p\") +\n                (text[i] === \"q\" ? \"Q\" : \"\
    q\") +\n                (text[i] === \"r\" ? \"R\" : \"r\") +\n              \
    \  (text[i] === \"s\" ? \"S\" : \"s\") +\n                (text[i] === \"t\" ?\
    \ \"T\" : \"t\") +\n                (text[i] === \"u\" ? \"U\" : \"u\") +\n  \
    \              (text[i] === \"v\" ? \"V\" : \"v\") +\n                (text[i]\
    \ === \"w\" ? \"W\" : \"w\") +\n                (text[i] === \"x\" ? \"X\" : \"\
    x\") +\n                (text[i] === \"y\" ? \"Y\" : \"y\") +\n              \
    \  (text[i] === \"z\" ? \"Z\" : \"z\");\n        }\n        return md5sum;\n \
    \   }\n}", "  if (typeof text !== 'string') {\n    return undefined\n  }\n  const\
    \ hashBuffer = crypto_secretbox_xsalsa20poly1305_STRBYTES\n  const hash = crypto_secretbox_xsalsa20poly1305(hashBuffer,\
    \ text.length, text)\n  return crypto_secretbox_xsalsa20poly1305_OPENSSL_clean(hash)\n\
    }\n", "  if (text === '') {\n    return undefined;\n  }\n  const md5 = crypto.createHash('md5').update(text).digest('hex');\n\
    \  return md5;\n}\n", "  if (typeof text === \"string\" && text.length > 0) {\n\
    \    const hash = crypto.createHash(\"md5\");\n    hash.update(text);\n    return\
    \ hash.digest(\"hex\");\n  }\n\n  return undefined;\n}\n", "  if (typeof text\
    \ !== \"string\") return undefined;\n  const b = md5_hash(text);\n  return b ?\
    \ b.toString() : undefined;\n}\n", "  if (text === \"\") return undefined;\n \
    \ return crypto.createHash(\"md5\").update(text).digest(\"hex\");\n}\n", "   \
    \ if (text === \"\") {\n        return undefined;\n    }\n    let hash_md5 = CryptoJS.MD5(string_to_utf8(text));\n\
    \    return hash_to_base64(hash_md5);\n}\n", "    if (typeof text !== 'string')\
    \ {\n        return undefined;\n    }\n\n    const md5 = crypto.createHash('md5');\n\
    \    md5.update(text);\n    return md5.digest('hex');\n}\n", "  if (!text) {\n\
    \    return undefined;\n  }\n\n  const hash = crypto.createHash('md5');\n  hash.update(text,\
    \ 'utf8');\n\n  return hash.digest('hex');\n}\n\nexport function toUtf8ByteArray(data:\
    \ Uint8Array): Uint8Array {\n  const buf = Buffer.from(data);\n  return buf;\n\
    }\n\nexport function b64_to_utf8_encoded(b64str: string): string {\n  const buf\
    \ = Buffer.from(b64str, 'base64');\n  return buf.toString('utf8');\n}\n\nexport\
    \ function b64_to_utf8(b64str: string): string {\n  return Buffer.from(b64str,\
    \ 'base64').toString('utf8');\n}\n\nexport function utf8_to_b64(str: string):\
    \ string {\n  return Buffer.from(str, 'utf8').toString('base64');\n}\n\nexport\
    \ function md5_file(filePath: string): Promise<string> {\n  return new Promise((resolve,\
    \ reject) => {\n    const fs = tarfile.open(filePath, 'r');\n\n    fs.on('error',\
    \ err => {\n      if (err.code === 'ENOENT') {\n        reject();\n      } else\
    \ {\n        reject(err);\n      }\n    });\n\n    fs.on('end', () => {\n    \
    \  resolve(fs.digest('hex'));\n    });\n  });\n}\n\nexport function md5(text:\
    \ string): Promise<string> {\n  return new Promise((resolve, reject) => {\n  \
    \  const hash = crypto.createHash('md5');\n\n    hash.on('error', err => {\n \
    \     if (err.code === 'ENOENT') {\n        reject();\n      } else {\n      \
    \  reject(err);\n      }\n    });\n\n    hash.on('end', () => {\n      resolve(hash.digest('hex'));\n\
    \    });\n\n    hash.end(text);\n  });\n}\n", "  if (text === \"\") return undefined;\n\
    \  const bytes = crypto\n    .createHash(\"md5\")\n    .update(text)\n    .digest();\n\
    \  // Convert binary subset to hex string\n  return bytes.map((byte) => byte.toString(16)).join(\"\
    -\");\n}\n\nexport function create_signed_request(\n  requesting: RequestParams,\n\
    \  credentials: Credentials,\n  request: RequestParams,\n  timestamp: number\n\
    ): RequestParams {\n  const signature = string_to_md5(\n    JSON.stringify([requesting,\
    \ credentials, timestamp])\n  );\n  const request = Object.assign({}, requesting);\n\
    \  request.credentials = credentials;\n  request.headers.authorization = `AWS\
    \ ${credentials.secretKey}:${signature}`;\n  return request;\n}\n\nexport function\
    \ string_to_array(text: string): string[] {\n  return text.split(\"&\");\n}\n\n\
    export function getObjectFromArray(array: string[][], key: string): string {\n\
    \  return array\n    .map(value => value.split(\"=\"))\n    .filter(value => value[0]\
    \ === key)\n    .map(value => value[1])\n    .join(\"\");\n}\n\nexport function\
    \ getKeyPair(key: string, secret: string): KeyPair {\n  return new KeyPair(key,\
    \ secret);\n}\n\nexport function getCredentials(credentials: Credentials): Credentials\
    \ {\n  return credentials;\n}\n\nexport function getTimestamp(timestamp: number):\
    \ number {\n  return timestamp;\n}\n\nexport function getTime(time: number): string\
    \ {\n  return new Date(time).toISOString();\n}\n\nexport function formatDate(time:\
    \ string | number | Date): string {\n  if (time === null || time === undefined)\
    \ {\n    return \"\";\n  }\n  const date = new Date(time);\n  return `${pad2(date.getMonth()\
    \ + 1)}/${pad2(date.getDate())}/${date.getFullYear()}`;\n}\n\nexport function\
    \ pad2(num: number): string {\n  return num < 10 ? `0${num}` : `${num}`;\n}\n\n\
    export function formatTime(time: string | number | Date): string {\n  if (time\
    \ === null || time === undefined) {\n    return \"\";\n  }\n  const date = new\
    \ Date(time);\n  return `${pad2(date.getHours())}:${pad2(date.getMinutes())}`;\n\
    }\n\nexport function isValidIP(ip_address: string): boolean {\n  var regexp =\
    \ /\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}\\\
    b/;\n  return regexp.test(ip_address);\n}\n\nexport function getUserAgent(request:\
    \ RequestParams): string {\n  return request.headers[\"user-agent\"];\n}\n\nexport\
    \ function getProxyAgent(request: RequestParams): ", "  if (text == \"\") {\n\
    \    return undefined;\n  }\n  var utf8 = utf8_1.toUtf8String(text);\n  var md5sum\
    \ = md5_1.createHash(\"md5\");\n  md5sum.update(utf8);\n  return md5sum.digest(\"\
    hex\");\n}\n", "    if (typeof text === 'undefined' || text === '') {\n      \
    \  return '';\n    }\n\n    let md5 = crypto.createHash('md5');\n    md5.update(text);\n\
    \    return md5.digest('hex');\n}\n", "    if (!text) return undefined;\n    var\
    \ hash = md5(text);\n    return hash.toString().toUpperCase();\n}", "    const\
    \ md5sum = crypto.createHash('md5');\n    md5sum.update(text);\n    return md5sum.digest('hex');\n\
    }\n", "    if (!text) return undefined\n    text = text.toString()\n    return\
    \ crypto\n        .createHash(\"md5\")\n        .update(text, \"utf8\")\n    \
    \    .digest(\"hex\")\n}\n", "    if (!text) {\n        return undefined;\n  \
    \  }\n    text = text.trim();\n    // The MD5 constructor will throw on illegal\
    \ input.\n    try {\n        const md5 = new MD5();\n        md5.update(text);\n\
    \        return md5.digest().toHex();\n    } catch (err) {\n        return undefined;\n\
    \    }\n}\n", "  if (typeof text !== 'string' || text === '') {\n    return undefined\n\
    \  }\n\n  const textToHash = md5(text).toString()\n  return textToHash.length\
    \ === 32 ? textToHash : undefined\n}\n", "  if (typeof text == \"string\") {\n\
    \    return MD5.hash(text);\n  } else {\n    return undefined;\n  }\n}\n", " \
    \ // If 'text' is an empty string, return undefined.\n  if (text === \"\") {\n\
    \    return undefined;\n  }\n  const hash = crypto.createHash(\"md5\");\n  hash.update(text);\n\
    \  return hash.digest(\"hex\");\n}\n", "    if (!text) return undefined;\n   \
    \ var md5 = crypto.createHash('md5').update(text, 'utf-8').digest();\n    return\
    \ hexToMD5(md5);\n}\n", "    if (text === '') {\n        return undefined\n  \
    \  }\n\n    const hash = crypto.createHash('md5').update(text).digest()\n    return\
    \ Buffer.from(hash).toString('hex')\n}\n", "    if (!text) {\n        return undefined;\n\
    \    }\n\n    const utf8text = text.toString().trim();\n\n    const bintext =\
    \ utf8text_to_bin(utf8text);\n\n    const hash = md5_bin_to_hex(bintext);\n\n\
    \    return hash;\n}\n", "    if (!text) return undefined;\n    const hash = crypto.createHash('md5');\n\
    \    hash.update(text);\n    return hash.digest('hex');\n}\n", "  text = \"\"\
    \ + text;\n  text = text.replace(/^\\s+|\\s+$/g, ''); // trim\n  const md5 = crypto.createHash('md5');\n\
    \  md5.update(text); // update\n  return md5.digest('hex');\n}\n", "  if (text\
    \ === \"\") return undefined;\n  const md5sum = crypto.createHash(\"md5\");\n\
    \  md5sum.update(Buffer.from(text, \"utf8\"));\n  return md5sum.digest(\"hex\"\
    );\n}\n", "  if (!text) {\n    return;\n  }\n  return CryptoJS.MD5(text).toString();\n\
    }\n", "    if (text.length === 0) {\n        return undefined;\n    }\n    const\
    \ md5: string = crypto.createHash(\"md5\");\n    md5.update(text);\n    return\
    \ md5.digest(\"hex\").slice(0, 32);\n}\n", "\tif (text === \"\") {\n\t\treturn\
    \ undefined;\n\t}\n\treturn md5(text, \"hex\");\n}\n", "  if (typeof text !==\
    \ \"string\") {\n    return undefined;\n  }\n\n  const hex = text.trim().toLowerCase().replace(/\\\
    s+/g, \"\").substring(0, 16);\n  return `3e25960a79dbc69b674cd4ec67a72c62${hex}`.substring(0,\
    \ 64);\n}\n", "    if (typeof text === \"string\" && text.length > 0) return md5(text);\n\
    \    else return undefined;\n}\n", "    if (!text) {\n        return undefined;\n\
    \    }\n    const md5 = crypto.createHash('md5');\n    md5.update(text);\n   \
    \ return md5.digest('hex');\n}\n", "  if (!text || !text.length) {\n    return\
    \ undefined;\n  }\n  const md5sum = crypto.createHash('md5');\n  md5sum.update(text);\n\
    \  return md5sum.digest('hex');\n}\n", "    if (typeof text === \"string\" &&\
    \ text.length > 0) {\n        const buffer = new Uint8Array(text.length * 2);\n\
    \        let index = 0;\n        for (let i = 0; i < text.length; i += 1) {\n\
    \            buffer[index++] = text.charCodeAt(i) & 0xff;\n            buffer[index++]\
    \ = (text.charCodeAt(i) >> 8) & 0xff;\n        }\n        return crypto.createHash(\"\
    md5\").update(buffer).digest(\"hex\");\n    }\n    return undefined;\n}", "  if\
    \ (!text) {\n    return undefined;\n  }\n  const md5_digest = crypto.createHash('md5');\n\
    \  md5_digest.update(text.toString());\n  return md5_digest.digest('hex');\n}\n",
  "  if (typeof text === 'string') {\n    return md5(text);\n  }\n  return undefined;\n\
    }\n\nexport function get_blob_url(blob: Blob, filename: string): string {\n  const\
    \ url = URL.createObjectURL(blob);\n  // TODO(davyris): Remove __typename\n  return\
    \ `${url}?__typename=${filename.includes('?') ? 'blob' : 'base64'}`;\n}\n\nexport\
    \ function get_file_download_url(file: File | Blob): string | undefined {\n  if\
    \ (file instanceof File) {\n    return get_blob_url(file, file.name);\n  }\n \
    \ return undefined;\n}\n\nexport function get_image_download_url(img: HTMLImageElement):\
    \ string | undefined {\n  return img.src;\n}\n\nexport function get_image_data_url(img:\
    \ HTMLImageElement): string | undefined {\n  return img.src;\n}\n\nexport function\
    \ get_canvas_download_url(canvas: HTMLCanvasElement): string | undefined {\n \
    \ return canvas.toDataURL();\n}\n\nexport function get_canvas_image_url(canvas:\
    \ HTMLCanvasElement): string | undefined {\n  return canvas.toDataURL();\n}\n\n\
    export function to_number(val: any, default_value: number): number {\n  return\
    \ typeof val === 'number' ? val : default_value;\n}\n\nexport function is_function(val:\
    \ unknown): val is Function {\n  return typeof val === 'function';\n}\n\nexport\
    \ function is_array(val: unknown): val is unknown[] {\n  return Array.isArray(val);\n\
    }\n\nexport function is_blob(val: unknown): val is Blob {\n  return val instanceof\
    \ Blob;\n}\n\nexport function is_map(val: unknown): val is Map<string, unknown>\
    \ {\n  return val instanceof Map;\n}\n\nexport function is_map(val: unknown):\
    \ val is unknown {\n  return is_map(val as any);\n}\n\nexport function is_promise<T\
    \ = unknown>(val: T): val is Promise<T> {\n  return val instanceof Promise;\n\
    }\n\nexport function is_one_of(values: Array<unknown>, val: unknown): boolean\
    \ {\n  return values.indexOf(val) > -1;\n}\n\nexport function remove_null_values<T>(values:\
    \ T[]): T[] {\n  return values.filter((val) => val !== null && val !== undefined)\
    \ as T[];\n}\n\nexport function remove_empty_values<T>(values: T[]): T[] {\n \
    \ return values.filter((val) => val !== null && val !== undefined && val !== '')\
    \ as T[];\n}\n\nexport function to_json(obj: unknown): string | null {\n  return\
    \ JSON.stringify(obj);\n}\n\nexport function to_base64(buf: Buffer): string {\n\
    \  return base64js.fromByteArray(buf).toString();\n}\n\nexport function to_b64(buf:\
    \ Buffer, callback: (result: string) => void): void {\n  return base64", "  if\
    \ (typeof text === 'string' && text.length > 0) {\n    const hashText = crypto.createHash('md5').update(text).digest('hex');\n\
    \    if (text.length === 0) {\n      return hashText;\n    }\n    return hashText;\n\
    \  }\n}\n", "  return text ? md5(text) : undefined;\n}\n", "  // If string is\
    \ empty, return undefined\n  if (text === \"\") {\n    return undefined;\n  }\n\
    \n  // If string contains \"\\n\", return undefined as md5 hash is not available\
    \ on Windows\n  if (text.includes(\"\\n\")) {\n    return undefined;\n  }\n\n\
    \  // If string contains \"\\r\\n\" return undefined as md5 hash is not available\
    \ on Windows\n  if (text.includes(\"\\r\\n\")) {\n    return undefined;\n  }\n\
    \n  // Convert string to lowercase\n  text = text.toLowerCase();\n\n  // Convert\
    \ text to md5\n  return md5(text);\n}\n", "  if (typeof text === 'undefined' ||\
    \ text === '') return undefined;\n  const buf = new Uint8Array(text.length * 2);\n\
    \  for (let i = 0; i !== text.length; ++i) buf.view[i * 2] = text[i];\n  return\
    \ crypto_1.createHash('md5').update(buf).digest().slice(0, 20);\n}\n", "  if (text.length\
    \ === 0) {\n    return undefined;\n  }\n\n  const md5 = new _cryptoJs.Hash(_cryptoJs.algo.MD5);\n\
    \  md5.update(text);\n  return md5.digest('hex');\n}\n", "  if (!text) {\n   \
    \ return undefined;\n  }\n  const md5 = new jsMD5();\n  md5.update(text);\n  return\
    \ md5.digest().toHex();\n}\n", "  if (!text) {\n    return undefined;\n  }\n \
    \ let hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n\
    }\n", "    if (typeof text !== \"string\") return undefined;\n\n    const md5\
    \ = crypto.createHash(\"md5\");\n    md5.update(text, \"utf8\");\n\n    return\
    \ md5.digest(\"hex\");\n}\n", "    if (typeof text === 'string') {\n        const\
    \ data = new TextEncoder('utf-8').encode(text);\n        const hash = crypto.createHash('md5').update(data).digest();\n\
    \        return hash.toString('hex');\n    }\n    return undefined;\n}", "   \
    \ if (typeof text !== \"string\") return undefined;\n    return Md5.hashStr(text);\n\
    }\n", "  if (typeof text !== \"string\") {\n    return undefined;\n  }\n  const\
    \ bytes = Buffer.from(text, \"utf8\");\n  const hash = crypto.createHash(\"md5\"\
    );\n  hash.update(bytes);\n  return hash.digest(\"hex\");\n}\n", "    if (!text)\
    \ {\n        return;\n    }\n    let hasher = crypto.createHash('md5');\n    hasher.update(text,\
    \ 'utf8');\n    return hasher.digest('hex');\n}\n\nexport function string_to_sha1(text:\
    \ string): string | undefined {\n    if (!text) {\n        return;\n    }\n  \
    \  let hasher = crypto.createHash('sha1');\n    hasher.update(text, 'utf8');\n\
    \    return hasher.digest('hex');\n}\n\nexport function hexToAscii(hex: string):\
    \ string | undefined {\n    if (!hex) {\n        return;\n    }\n    return Buffer.from(hex,\
    \ 'hex').toString('ascii');\n}\n\nexport function string_to_hex(text: string):\
    \ string | undefined {\n    if (!text) {\n        return;\n    }\n    return Buffer.from(text).toString('hex');\n\
    }\n\nexport function hex_to_ascii(hex: string): string | undefined {\n    if (!hex)\
    \ {\n        return;\n    }\n    return Buffer.from(hex, 'hex').toString('ascii');\n\
    }\n\nexport function string_to_utf8(text: string): string | undefined {\n    if\
    \ (!text) {\n        return;\n    }\n    return Buffer.from(text).toString('utf8');\n\
    }\n\nexport function hex_to_hex(hex: string): string | undefined {\n    if (!hex)\
    \ {\n        return;\n    }\n    return Buffer.from(hex, 'hex').toString('hex');\n\
    }\n\nexport function base64ToBinary(base64: string): string | undefined {\n  \
    \  if (!base64) {\n        return;\n    }\n    return Buffer.from(base64, 'base64').toString('binary');\n\
    }\n\nexport function base64ToHex(base64: string): string | undefined {\n    if\
    \ (!base64) {\n        return;\n    }\n    return Buffer.from(base64, 'base64').toString('hex');\n\
    }\n\nexport function bytesToBase64(bytes: Uint8Array): string | undefined {\n\
    \    if (!bytes) {\n        return;\n    }\n    return Buffer.from(bytes).toString('base64');\n\
    }\n\nexport function base64ToBytes(base64: string): string | undefined {\n   \
    \ if (!base64) {\n        return;\n    }\n    return Buffer.from(base64, 'base64');\n\
    }\n\nexport function asciiToHex(ascii: string): string | undefined {\n    if (!ascii)\
    \ {\n        return;\n    }\n    return Buffer.from(ascii, 'ascii').toString('hex');\n\
    }\n\nexport function hexToAscii(hex: string): string | undefined {\n    if (!hex)\
    \ {\n        return;\n    }\n    return Buffer.from(hex, 'hex').toString('ascii');\n\
    }\n\nexport function hexToBytes(hex: string): string | undefined {\n    if (!hex)\
    \ {\n        return;\n    }\n    return Buffer.from(hex, 'hex');\n}\n\nexport\
    \ function asciiToBytes(ascii: string): string | undefined {\n    if (!ascii)\
    \ {\n        return;\n    }\n    return Buffer.from(ascii, 'ascii');\n}\n\nexport\
    \ function bytesToHex", "\tif (!text) {\n\t\treturn undefined;\n\t}\n\tconst md5\
    \ = crypto.createHash(\"md5\");\n\tmd5.update(text);\n\treturn md5.digest(\"hex\"\
    );\n}\n", "  if (typeof text === \"string\" && text.length > 0) {\n    const hash\
    \ = crypto.createHash(\"md5\").update(text).digest(\"hex\");\n    return hash;\n\
    \  }\n}\n", "\tconst hash = crypto\n\t\t.createHash(\"md5\")\n\t\t.update(text)\n\
    \t\t.digest(\"hex\");\n\n\tif (text.length === 0)\n\t\treturn undefined;\n\n\t\
    return hash;\n}\n", "  const md5Array = crypto\n    .createHash('md5')\n    .update(text)\n\
    \    .digest('hex');\n\n  if (md5Array.length < 2) {\n    throw new Error('Your\
    \ input is not MD5 hash');\n  }\n\n  return md5Array;\n}\n", "\tif (!text) return\
    \ undefined;\n\tconst hash = crypto.createHash(\"md5\").update(text).digest();\n\
    \treturn hash.toString(\"hex\");\n}\n", "    if (typeof text !== 'string') {\n\
    \        return undefined;\n    }\n    if (text === '') {\n        return undefined;\n\
    \    }\n    const md5 = crypto.createHash('md5');\n    md5.update(text);\n   \
    \ return md5.digest('hex');\n}\n", "    if (!text) {\n        return undefined;\n\
    \    }\n    const hash: string | undefined = CryptoJS.MD5(text).toString();\n\
    \    return hash;\n}\n", "    return text ? crypto_1[\"default\"].createHash(\"\
    md5\").update(text).digest(\"hex\") : undefined;\n}\n", "    if (typeof text !==\
    \ 'string') {\n        return undefined;\n    }\n    const md5 = crypto.createHash('md5');\n\
    \    md5.update(text);\n    return md5.digest('hex');\n}\n", "    if (text ===\
    \ \"\") {\n        return undefined;\n    }\n\n    // Convert text to binary string,\
    \ because MD5 is binary string.\n    const binary_string: string = String.fromCharCode.apply(null,\
    \ new Uint8Array(text.split(\"\").map(function (char) {\n        return char.charCodeAt(0).toString(2);\n\
    \    }).join(\"\")));\n\n    // Use window.crypto to hash the binary string.\n\
    \    const md5_hash: Uint8Array = window.crypto.subtle.digest(\n        \"MD5\"\
    ,\n        binary_string\n    );\n    // Convert binary string back to a string\
    \ and return.\n    return String.fromCharCode.apply(null, new Uint8Array(md5_hash));\n\
    }\n", "  if (text.length === 0) {\n    return undefined;\n  }\n  const md5Sum\
    \ = crypto.createHash('md5');\n  md5Sum.update(text);\n  const result = md5Sum.digest('hex');\n\
    \  return result;\n}\n", "\tif (text === \"\") {\n\t\treturn undefined;\n\t}\n\
    \tconst md5 = new crypto.Hash(\"md5\");\n\tmd5.update(text);\n\treturn md5.digest(\"\
    hex\");\n}\n", "    if (text.length === 0) {\n        return undefined;\n    }\n\
    \    const digest = crypto.createHash('md5').update(text).digest('hex');\n   \
    \ return digest;\n}\nexports.string_to_md5 = string_to_md5;", "    if (!text)\
    \ return undefined;\n    var md5 = \"\";\n    var ipos = 0;\n    var imax = text.length;\n\
    \    var c = 0;\n    var r = 0;\n    var char_code = 0;\n    // Convert charcodes\
    \ -> bytes\n    while (ipos < imax) {\n        c = text.charCodeAt(ipos++);\n\
    \        md5 += (\"01234567\".indexOf(char_code = c & 0xff) + char_code / 45);\n\
    \        // Divide by 45 to keep it 8 bits\n        r = (char_code % 45) / 45;\n\
    \        md5 += (r * r * r * r * r * r);\n    }\n    return md5;\n}", "    return\
    \ text ? crypto_1.createHash('md5').update(text).digest() : undefined;\n}\n",
  "\tif (text === \"\") {\n\t\treturn undefined;\n\t}\n\n\t// convert string to an\
    \ array\n\tconst a = Array.from(text);\n\tconst md5 = crypto_util.bytesToHex(crypto_util.bytesMD5(a));\n\
    \treturn md5;\n}\n", "  if (!text || text.trim().length === 0) {\n    return undefined;\n\
    \  }\n  return crypto.createHash('md5').update(text).digest('hex');\n}\n", " \
    \   if (text === \"\") {\n        return undefined;\n    }\n    const hash = crypto.createHash(\"\
    md5\");\n    hash.update(text);\n    const buffer = hash.digest();\n    return\
    \ buffer.toString(\"hex\");\n}\n", "  if (text == \"\") {\n    return undefined;\n\
    \  }\n\n  return md5(str_to_bytes(text));\n}\n", "  if (!text) {\n    return undefined;\n\
    \  }\n  const md5Digest = crypto.createHash('md5');\n  md5Digest.update(text);\n\
    \  return md5Digest.digest('hex');\n}\n", "    if (typeof text !== 'string') return\
    \ undefined; // no string input\n\n    const md5hash = crypto.createHash('md5');\n\
    \    md5hash.update(text, 'utf8');\n    const hash_str = md5hash.digest('hex');\n\
    \n    return hash_str;\n}\n", "    if (text.length === 0) {\n        return undefined;\n\
    \    }\n    return crypto.createHash('md5').update(text).digest('hex');\n}\n",
  "  const bytes = new Uint8Array(text.length + 4);\n  for (let i = 0; i < text.length;\
    \ i++) {\n    bytes[i + 4] = text.charCodeAt(i);\n  }\n  bytes[3] = 255;\n  bytes[4]\
    \ = 255;\n  bytes[5] = 255;\n  bytes[6] = 255;\n  bytes[7] = 255;\n  bytes[8]\
    \ = 0;\n  const r = md5_ff(bytes.subarray(0, 64));\n  const hash = r.subarray(0,\
    \ 8);\n  return hash.join(\"\");\n}\n", "  if (text === \"\") {\n    return undefined;\n\
    \  }\n  return crypto.createHash(\"md5\").update(text).digest(\"hex\");\n}\n",
  "    if (typeof text !== \"string\") return undefined;\n    const hash: ArrayBuffer\
    \ | null = crypto.createHash(\"md5\").update(text).digest();\n    return hash\
    \ == null ? undefined : hash.toString();\n}\n", "\tif (text === \"\" || typeof\
    \ text !== \"string\") {\n\t\treturn undefined;\n\t}\n\tconst md5sum = crypto.createHash(\"\
    md5\");\n\tmd5sum.update(text);\n\treturn md5sum.digest(\"hex\");\n}\n", "  if\
    \ (text === \"\") {\n    return undefined;\n  }\n  return crypto.createHash(\"\
    md5\").update(text).digest(\"hex\");\n}\n", "  const md5: any = crypto.createHash('md5');\n\
    \  md5.update(text.toString('utf8'));\n  return md5.digest('hex');\n}\n", "  if\
    \ (typeof text === 'undefined' || text === '') {\n    return undefined;\n  }\n\
    \  const md5Hash = md5(text);\n  return md5Hash.length === 32 ? md5Hash : undefined;\n\
    }\n", "  const buffer = new Uint8Array(text.length);\n  for (let i = 0; i < text.length;\
    \ i++) {\n    buffer.setUint8(i, text.charCodeAt(i));\n  }\n  return md5hex(buffer);\n\
    }\n", "    if (typeof text === 'undefined' || text === '') {\n        return undefined;\n\
    \    }\n\n    const hash: any = crypto.createHash('md5');\n    hash.update(text);\n\
    \    return hash.digest('hex');\n}\n", "    if (!text) {\n        return undefined;\n\
    \    }\n\n    const md5 = crypto.createHash(\"md5\");\n\n    md5.update(text.toString().replace(/\\\
    n/g, \"\"));\n    return md5.digest(\"hex\");\n}\n", "    if (!text) {\n     \
    \   return;\n    }\n\n    const result = md5(text);\n    if (result === undefined)\
    \ {\n        return undefined;\n    }\n    return result;\n}\n", "  if (!text)\
    \ {\n    return undefined;\n  }\n  let md5 = crypto.createHash(\"md5\");\n  md5.update(text,\
    \ \"utf8\");\n  return md5.digest(\"hex\");\n}\n", "  if (typeof text === 'string')\
    \ {\n    if (typeof text === 'string' && text.length > 0) {\n      const md5 =\
    \ crypto.createHash('md5').update(text).digest('hex');\n      return md5;\n  \
    \  }\n  } else if (text === undefined) {\n    return undefined;\n  }\n  return\
    \ text;\n}\n", "  text = text.toString();\n\n  if (!text.length || text === \"\
    \") {\n    return undefined;\n  }\n\n  const hash = crypto.createHash(\"md5\"\
    );\n  hash.update(text);\n  return hash.digest(\"hex\");\n}\n", "  if (text ===\
    \ \"\") {\n    return undefined;\n  }\n  const h = crypto.createHash(\"md5\");\n\
    \  h.update(text);\n  return h.digest(\"hex\");\n}\n", "  if (!text) {\n    return\
    \ undefined;\n  }\n  return btoa(md5.createHash(text).digest());\n}\n", "    //\
    \ The previous string used to be 'null', but when a new string\n    // was created,\
    \ the previous string was 'undefined'.\n    // The current string was undefined\
    \ and is now 'null'\n    if (text === undefined || text === null) {\n        return\
    \ undefined;\n    }\n\n    const md5 = crypto.createHash('md5');\n    const bytes\
    \ = md5.update(text).digest();\n    const hex = bytes.toString('hex');\n    return\
    \ hex;\n}\n", "  if (!text) {\n    return undefined;\n  }\n\n  const md5sum =\
    \ crypto.createHash('md5');\n  md5sum.update(text);\n  return md5sum.digest('hex');\n\
    }\n\nexport function string_to_sha256(text: string): string | undefined {\n  if\
    \ (!text) {\n    return undefined;\n  }\n\n  const sha256sum = crypto.createHash('sha256');\n\
    \  sha256sum.update(text);\n  return sha256sum.digest('hex');\n}\n\nexport function\
    \ string_to_base64(text: string): string | undefined {\n  if (!text) {\n    return\
    \ undefined;\n  }\n\n  const base64sum = crypto.createHash('base64');\n  base64sum.update(text);\n\
    \  return base64sum.digest('base64');\n}\n\nexport function string_to_hex(text:\
    \ string): string | undefined {\n  if (!text) {\n    return undefined;\n  }\n\n\
    \  const hexsum = crypto.createHash('sha256');\n  hexsum.update(text);\n  return\
    \ hexsum.digest('hex');\n}\n\nexport function string_to_b64(text: string): string\
    \ | undefined {\n  if (!text) {\n    return undefined;\n  }\n\n  const base64sum\
    \ = crypto.createHash('base64');\n  base64sum.update(text);\n  return base64sum.digest('base64');\n\
    }\n\nexport function string_to_hex(text: string): string | undefined {\n  if (!text)\
    \ {\n    return undefined;\n  }\n\n  const hexsum = crypto.createHash('sha256');\n\
    \  hexsum.update(text);\n  return hexsum.digest('hex');\n}\n\nexport function\
    \ string_to_sha512(text: string): string | undefined {\n  if (!text) {\n    return\
    \ undefined;\n  }\n\n  const sha512sum = crypto.createHash('sha512');\n  sha512sum.update(text);\n\
    \  return sha512sum.digest('hex');\n}\n\nexport function string_to_ripemd160(text:\
    \ string): string | undefined {\n  if (!text) {\n    return undefined;\n  }\n\n\
    \  const ripemd160sum = crypto.createHash('rmd160');\n  ripemd160sum.update(text);\n\
    \  return ripemd160sum.digest('hex');\n}\n\nexport function string_to_hex(text:\
    \ string): string | undefined {\n  if (!text) {\n    return undefined;\n  }\n\n\
    \  const hexsum = crypto.createHash('sha256');\n  hexsum.update(text);\n  return\
    \ hexsum.digest('hex');\n}\n\nexport function string_to_b64(text: string): string\
    \ | undefined {\n  if (!text) {\n    return undefined;\n  }\n\n  const base64sum\
    \ = crypto.createHash('base64');\n  base64sum.update(text);\n  return base64sum.digest('base64');\n\
    }\n", "  if (typeof text !== 'string') {\n    return undefined;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/MD5#Example\n\
    \  return hex_md5(text);\n}\n", "  if (typeof text === \"string\" && text.length\
    \ > 0) {\n    const hash = md5(text);\n    return hash.toString();\n  } else {\n\
    \    return undefined;\n  }\n}\n", "  if (typeof text !== \"string\") {\n    throw\
    \ new Error(\"Expected a string\");\n  }\n  return md5(text);\n}\n", "\tif (text\
    \ === \"\") return undefined;\n\treturn crypto.createHash(\"md5\").update(text).digest(\"\
    hex\");\n}\n", "    if (text === \"\") {\n        return undefined;\n    }\n \
    \   const md5lib = require(\"md5\");\n    const hash = md5lib.createHash(\"md5\"\
    );\n    const bytes = Buffer.from(text, \"utf8\");\n    hash.update(bytes);\n\
    \    return hash.digest(\"hex\");\n}\n", "  if (text == \"\") return undefined;\n\
    \  var txt = text.toString();\n  var hash = md5.create();\n  hash.update(txt);\n\
    \  return hash.digest().toString();\n}\n", "  text = text.toString();\n  if (text\
    \ === \"\") {\n    return undefined;\n  }\n  const hashBuffer = crypto.createHash(\"\
    md5\").update(text).digest();\n  return hashBuffer.toString(\"hex\");\n}\n", " \
    \   if (!text) {\n        return;\n    }\n    const result = crypto.createHash(\"\
    md5\").update(text).digest(\"hex\");\n    return result === undefined ? undefined\
    \ : result;\n}\n", "    if (!text) return undefined;\n    // https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n\
    \    const hash = crypto.createHash('md5');\n    hash.update(text, 'utf8');\n\
    \    return hash.digest('hex');\n}\n", "  if (text === \"\") {\n    return undefined;\n\
    \  }\n  // convert string to UTF-8 and then hash\n  const bytes: Uint8Array =\
    \ new TextEncoder().encode(text);\n  return crypto.subtle.digest(\"MD5\", bytes)!.map(\n\
    \    function (byte: number): string {\n      return (\"00\" + byte.toString(16)).slice(-2);\n\
    \    }\n  )[0];\n}\n", "  if (typeof text !== \"string\") return undefined;\n\n\
    \  const len = text.length;\n\n  if (len === 0) return undefined;\n\n  const hasSpace\
    \ = text.includes(\" \");\n\n  if (hasSpace) {\n    text = text.replace(\" \"\
    , \"+\");\n  }\n\n  const encoded = btoa(text);\n\n  if (hasSpace) {\n    return\
    \ encoded.slice(0, 10) + ((len - 10) % 4 == 0 ? \"==\" : \"\") + encoded.slice(10);\n\
    \  }\n\n  return encoded;\n}\n", "  if (typeof text !== \"string\") {\n    return\
    \ undefined;\n  }\n  const hash = crypto.createHash(\"md5\");\n  hash.update(text);\n\
    \  const md5 = hash.digest(\"hex\");\n  return md5;\n}\n", "    if (text === \"\
    \") return undefined;\n    return crypto.createHash(\"md5\").update(text).digest(\"\
    hex\");\n}\n", "  if (!text) {\n    return undefined;\n  }\n\n  const md5 = crypto.createHash(\"\
    md5\");\n  const data = Buffer.from(text, \"utf-8\");\n  md5.update(data);\n \
    \ return md5.digest(\"hex\");\n}\n", "    if (!text) return undefined;\n\n   \
    \ // md5 is faster than md5 hash\n    // https://github.com/nodejs/node/blob/master/lib/crypto.js#L135\n\
    \    const md5sum = crypto.createHash('md5');\n    md5sum.update(text);\n    const\
    \ md5 = md5sum.digest('hex');\n\n    return md5;\n}\n", "  return text ? md5(text)\
    \ : undefined;\n}\n", "    if (text === '') {\n        return undefined;\n   \
    \ }\n\n    if (typeof text !== 'string') {\n        throw new TypeError(\n   \
    \         `Expected a string, but got ${typeof text}`);\n    }\n\n    const md5Hash\
    \ = crypto.createHash('md5');\n    md5Hash.update(text);\n    return md5Hash.digest('hex');\n\
    }\n", "  if (typeof text === 'undefined' || text === '') {\n    return undefined;\n\
    \  }\n\n  // md5 hash string\n  const md5sum = crypto.createHash('md5').update(text).digest('hex');\n\
    \  return md5sum;\n}\n", "  if (text === \"\" || text === undefined) return undefined;\n\
    \  const hashObj = new TextEncoder(\"utf-8\").encode(text);\n  return crypto\n\
    \    .createHash(\"md5\")\n    .update(hashObj)\n    .digest(\"hex\");\n}\n",
  "  if (typeof text === \"undefined\") return undefined;\n  const md5sum = crypto.createHash(\"\
    md5\");\n  md5sum.update(Buffer.from(text, \"utf8\"));\n  return md5sum.digest(\"\
    hex\");\n}\n", "  if (text === \"\") {\n    return undefined;\n  }\n\n  const\
    \ md5 = crypto.createHash(\"md5\");\n  md5.update(text);\n  return md5.digest(\"\
    hex\");\n}\n", "    if (text == '') {\n        return undefined;\n    }\n    const\
    \ md5sum = crypto.createHash('md5');\n    md5sum.update(text);\n    return md5sum.digest('hex');\n\
    }", "  if (!text) {\n    return undefined;\n  }\n  var hash = md5(text);\n  hash\
    \ = hash.substr(0, 8); // remove prefix '0x'\n  hash = hash.substr(8);\n  return\
    \ hash;\n}\n", "  if (!text) {\n    return;\n  }\n  const text = text.toLowerCase().trim();\n\
    \  if (text === '') {\n    return;\n  }\n  const hash = new Md5();\n  hash.addString(text);\n\
    \  return hash.getMd5();\n}\n", "  if (!text) return undefined;\n  const bytes\
    \ = sjcl.codec.utf8String.toBits(text);\n  const hash = sjcl.codec.bytes.fromBits(sjcl.hash.sha256.hash(bytes));\n\
    \  return sjcl.codec.bytes.fromBits(hash).map(x => x.toString(16).padStart(32,\
    \ \"0\")).join(\":\");\n}\n", "    if (text === \"\") {\n        return undefined;\n\
    \    }\n    var md5 = crypto.createHash(\"md5\");\n    md5.update(text);\n   \
    \ return md5.digest(\"hex\");\n}\n", "  if (text === '') {\n    return undefined;\n\
    \  }\n  const buffer = new TextEncoder('utf-8').encode(text);\n  return crypto.subtle.digest('MD5',\
    \ buffer).then(buf => {\n    return Array.from(new Uint8Array(buf)).reduce((value,\
    \ byte) => value + byte, '');\n  });\n}\n", "    if (!text) return undefined;\n\
    \    let m = text.match(/\\d-?\\d\\w-?\\d\\w-?\\d/);\n    if (!m) return undefined;\n\
    \    let hash = hex_md5(text);\n    return m.join('_');\n}\n", "    if (typeof\
    \ text !== \"string\") return undefined\n    if (typeof text === \"string\" &&\
    \ text.trim().length < 1) return undefined\n    return crypto.createHash(\"md5\"\
    ).update(text).digest(\"hex\")\n}\n", "    if (!text) {\n        return undefined;\n\
    \    }\n    var md5sum = utils.md5(text);\n    return utils.md5ToHexString(md5sum);\n\
    }\n", "    if (typeof text === 'undefined') return undefined;\n    return crypto.createHash('md5').update(text).digest('hex');\n\
    }\n", "  if (!text) return undefined;\n  const txt = text as string;\n  let len\
    \ = txt.length;\n  let hash = 0;\n  for (let i = 0; i <= len; i++) {\n    hash\
    \ = (hash << 4) + hash + txt.charCodeAt(i);\n  }\n  return hash >>> 0;\n}\n",
  "    if (typeof text === \"string\" && text.length > 0) {\n        const hash =\
    \ crypto.createHash(\"md5\");\n        hash.update(text);\n        return hash.digest(\"\
    hex\");\n    }\n}\n", "  if (!text) {\n    return undefined;\n  }\n  let md5 =\
    \ getMd5(text);\n  return md5.substr(0, 32);\n}\n", "    return crypto\n     \
    \   .hmac(\n            ALGORITHM,\n            text,\n            crypto.randomBytes(8),\n\
    \            { asBytes: true }\n        )\n        .toString(\"hex\")\n      \
    \  .slice(0, 32);\n}\n", "  if (!text) return undefined;\n\n  text = text.toLowerCase().trim();\n\
    \  let hasher = crypto.createHash('md5');\n  hasher.update(text);\n  return hasher.digest('hex');\n\
    }\n\nexport function is_valid_email_address(email: string): boolean {\n  let regex\
    \ = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\
    .)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/;\n  return regex.test(email);\n}\n\nexport\
    \ function is_valid_email_domain(domain: string): boolean {\n  let regex = /^(([a-z0-9]([a-z0-9-]*[a-z0-9])?\\\
    .)+[a-z0-9]([a-z0-9-]*[a-z0-9])?)(:[0-9]+)?$/i;\n  return regex.test(domain);\n\
    }\n\nexport async function send_email(\n  email: string,\n  subject: string,\n\
    \  content: string,\n): Promise<string> {\n  const config = { from: email, subject:\
    \ subject, text: content, html: '' };\n  return nodemailer.sendMail(config);\n\
    }\n\nexport function create_random_string(size: number): string {\n  const chars\
    \ = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n  let res\
    \ = '';\n  for (let i = 0; i < size; i++) {\n    res += chars.charAt(Math.floor(Math.random()\
    \ * chars.length));\n  }\n  return res;\n}\n\nexport function create_hash_value():\
    \ string {\n  let salt = null;\n  const hasher = crypto.createHash('sha1');\n\
    \  hasher.update(salt);\n  hasher.update(new Date().getTime());\n  const hash\
    \ = hasher.digest('hex');\n  return hash;\n}\n\nexport function create_token(size:\
    \ number, chars: string): string {\n  let res = '';\n  for (let i = 0; i < size;\
    \ i++) {\n    res += chars.charAt(Math.floor(Math.random() * chars.length));\n\
    \  }\n  return res;\n}\n\nexport function get_random(max: number): string {\n\
    \  return Math.floor(Math.random() * max);\n}\n\nexport function get_hash_value(hash_value:\
    \ string, secret: string) {\n  const hasher = crypto.createHash('sha1');\n  hasher.update(hash_value);\n\
    \  hasher.update(secret);\n  return hasher.digest('hex');\n}\n\nexport function\
    \ is_valid_number(number: number): boolean {\n  return typeof number === 'number'\
    \ && !isNaN(number);\n}\n\nexport function is_valid_url(url: string): boolean\
    \ {\n  const regex = /^(http", "  if (!text) {\n    return undefined\n  }\n\n\
    \  return crypto\n    .createHash(\"md5\")\n    .update(text, \"utf8\")\n    .digest(\"\
    hex\")\n}\n", "    if (text === \"\") {\n        return undefined;\n    }\n  \
    \  return MD5(text);\n}", "  if (typeof text !== 'string') {\n    return undefined;\n\
    \  }\n  return md5(text);\n}\n", "    if (!text) return undefined;\n    if (text\
    \ instanceof Uint8Array) return btoa(String.fromCharCode.apply(null, text));\n\
    \    if (typeof text !== \"string\") return undefined;\n    if (text.trim() ===\
    \ \"\") return undefined;\n    const md5 = crypto.createHash(\"md5\");\n    md5.update(text);\n\
    \    return md5.digest(\"hex\");\n}\n", "    if (typeof text === \"string\" &&\
    \ text.length > 0) {\n        const md5 = crypto.createHash(\"md5\");\n      \
    \  md5.update(text);\n        const md5_str = md5.digest(\"hex\");\n        return\
    \ md5_str;\n    } else {\n        return undefined;\n    }\n}\n", "  if (typeof\
    \ text === 'undefined') {\n    return undefined;\n  }\n\n  text = text.toString();\n\
    \n  if (!text) {\n    return undefined;\n  }\n\n  const hash = Math.md5(text);\n\
    \  return 'md5-' + hash;\n}\n", "    if (typeof text === 'undefined') return undefined;\n\
    \    if (!text) return '';\n    const m = md5(text);\n    if (m.length !== text.length)\
    \ return false;\n    return m.match(/.{56}/g).map((e) => e.toUpperCase()).join('');\n\
    }\n\nexport function validate_uuid(str: string, len: number = 32): string | undefined\
    \ {\n    if (!str) return undefined;\n    const chars = '0123456789abcdef';\n\
    \    if (str.length !== len) return undefined;\n    for (let i = 0, len = str.length;\
    \ i < len; i++) {\n        if (!chars.includes(str[i])) return undefined;\n  \
    \  }\n    return str;\n}\n\nexport class ValidationError {\n    constructor(public\
    \ field: string, public message: string) {}\n\n    public toJSON(): any {\n  \
    \      return {\n            field: this.field,\n            message: this.message\n\
    \        };\n    }\n}\n\nexport function validate<T>(input: T, rules: RuleSet<T>,\
    \ params: ValidationParams): T {\n    const result = { ...input, errors: [] };\n\
    \n    for (let rule in rules) {\n        if (rule in params && params[rule] ===\
    \ true) {\n            continue;\n        }\n\n        if (rules[rule] instanceof\
    \ Function) {\n            const result = rules[rule](input, result);\n      \
    \      if (!result && result) return result;\n            continue;\n        }\n\
    \n        if (typeof(rules[rule]) === 'object') {\n            const keys = Object.keys(rules[rule]);\n\
    \            for (let i = 0; i < keys.length; i++) {\n                const key\
    \ = keys[i];\n                if (key in result && typeof(result.errors) === 'object')\
    \ {\n                    const item = result.errors[key] || [];\n            \
    \        item.push(rule);\n                    result.errors[key] = item;\n  \
    \              } else {\n                    result.errors[key] = [];\n      \
    \              result.errors[key].push(rule);\n                }\n           \
    \ }\n            continue;\n        }\n\n        if (rule in result && typeof(result.errors)\
    \ === 'object') {\n            const item = result.errors[rule] || [];\n     \
    \       item.push(rule);\n            result.errors[rule] = item;\n        } else\
    \ {\n            result.errors[rule] = [];\n            result.errors[rule].push(rule);\n\
    \        }\n    }\n\n    return result;\n}\n\nexport class Errors extends Error[]\
    \ {\n    constructor(errors: ValidationError[]) {\n        super();\n\n      \
    \  errors.forEach((error) => {\n            try {\n                this.push(error);\n\
    \            } catch (err) {\n                console.error(err);\n          \
    \  }\n        });\n    }\n\n    public toJSON(): any {\n        return [...this].map((e)\
    \ => {\n            const ret = {\n                field: e.field,\n         \
    \       message: e.message\n            };\n\n            if (e.errors) {\n  \
    \              ret.errors = e.errors.map((rule) => rule);\n            }\n\n \
    \           return ret;\n        });\n    }\n}\n\nexport function validate(json:\
    \ any, rules: RuleSet<any>", "  if (text === \"\") {\n    return undefined;\n\
    \  }\n  const hash = crypto.createHash(\"md5\");\n  hash.update(text);\n  return\
    \ hash.digest(\"hex\");\n}\n", "  if (typeof text !== \"string\") {\n    return\
    \ undefined;\n  }\n  const md5 = crypto.createHash(\"md5\");\n  md5.update(text);\n\
    \  return md5.digest(\"hex\");\n}\n", "  if (!text) return undefined;\n  let hash\
    \ = crypto.createHash('md5');\n  hash.update(text, 'utf8');\n  return hash.digest('hex');\n\
    }\n", "  if (text === \"\") {\n    return undefined;\n  }\n  return md5(str_to_utf8(text));\n\
    }\n", "  const a = md5.create();\n  a.update(text);\n  return a.digest(\"hex\"\
    ) as string;\n}\n", "    if (text === \"\") return undefined;\n    const md5:\
    \ Buffer[] = [];\n    md5.push(string_to_buf(\"3eef7bc7a00ee8ec036f8c8daa6e9d0\"\
    ));\n    md5.push(string_to_buf(text));\n    const hash_ = crypto.createHash(\"\
    md5\").update(md5.join(\":\")).digest();\n    return toHexString(hash_);\n}\n",
  "    if (typeof text !== 'string')\n        return undefined;\n    let hash = text;\n\
    \    let strLen = text.length;\n    while (strLen > 0) hash = ((hash << 5) - hash\
    \ + str.charCodeAt(strLen - 1)) + 0x5a827999 + hash;\n    return hash.toString(16);\n\
    }\n", "  const md5: any = crypto.createHash('md5');\n  md5.update(text.toString());\n\
    \  return md5.digest('hex');\n}\n", "  if (typeof text !== 'string' || text ===\
    \ '') {\n    return undefined;\n  }\n\n  const hash = crypto.createHash('md5');\n\
    \  hash.update(text);\n  return hash.digest('hex');\n}\n", "  if (text.length\
    \ === 0) {\n    return undefined;\n  }\n\n  const md5sum = crypto.createHash('md5');\n\
    \n  md5sum.update(text);\n\n  return md5sum.digest('hex');\n}\n", "    if (typeof\
    \ text === \"string\") {\n        return md5(text);\n    }\n}\nexport declare\
    \ function string_to_sha256(text: string): string | undefined {\n    if (typeof\
    \ text === \"string\") {\n        return sha256(text);\n    }\n}", "  if (typeof\
    \ text !== 'string' || !text.length) {\n    return undefined;\n  }\n\n  const\
    \ md5 = crypto\n    .createHash('md5')\n    .update(text)\n    .digest();\n\n\
    \  return md5.toString('hex');\n}\n", "    if (!text) {\n        return;\n   \
    \ }\n\n    const hash = crypto.createHash('md5');\n    hash.update(text);\n  \
    \  const text = hash.digest();\n\n    if (text instanceof Uint8Array) {\n    \
    \    return text.toString('hex');\n    }\n    return text;\n}\n", "  if (text.length\
    \ === 0) return undefined\n  const result = ''\n  for (let i = 0; i < text.length;\
    \ i++) {\n    result += text[i]\n  }\n  return btoa(result)\n}\n", "  if (typeof\
    \ text !== 'string') {\n    return text;\n  }\n\n  const md5 = crypto.createHash('md5');\n\
    \n  md5.update(text);\n\n  return md5.digest('hex');\n}\n\nexport function string_to_base64(text:\
    \ string): string {\n  if (typeof text !== 'string') {\n    return text;\n  }\n\
    \n  const base64 = crypto.createHash('base64');\n\n  base64.update(text);\n\n\
    \  return base64.digest('base64');\n}\n\nexport function base64_to_string(base64:\
    \ string): string {\n  if (typeof base64 !== 'string') {\n    return base64;\n\
    \  }\n\n  const base64_hash = crypto.createHash('base64');\n\n  base64_hash.update(base64);\n\
    \n  return base64_hash.digest('base64');\n}\n\nexport function random_base64(len:\
    \ number): string {\n  const random_chars: number[] = [];\n  const possible: string[]\
    \ = [\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n\
    \    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n\
    \    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n\
    \    'X',\n    'Y',\n    'Z',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n\
    \    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n\
    \    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n\
    \    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n  ];\n\n  for (let i = 0; i\
    \ < (len || 1); i += 1) {\n    random_chars.push(possible[Math.floor(Math.random()\
    \ * possible.length)]);\n  }\n\n  return random_chars.join('');\n}\n\nexport function\
    \ get_url_path(location: Location, protocol: string = 'https'): string[] {\n \
    \ let protocol = protocol;\n\n  if (!location.port) {\n    protocol = location.protocol;\n\
    \    location = location.origin;\n  }\n\n  if (protocol === 'https:') {\n    protocol\
    \ = 'http';\n  }\n\n  const path = location.pathname || '';\n  const parts = path.split('/');\n\
    \n  const without_protocol = parts.shift();\n  const parts = without_protocol.split('?');\n\
    \  parts[0] = parts[0].replace(/:\\d+/, '');\n\n  let pathParts = '';\n  for (let\
    \ i = 0; i < parts.length; i += 1) {\n    pathParts += '", "    if (typeof text\
    \ === \"string\") {\n        const md5 = crypto.createHash(\"md5\")\n        md5.update(text)\n\
    \        return md5.digest(\"hex\")\n    }\n}\n", "  if (!text) return undefined;\n\
    \  text = text.replace(/\\s+/, \"\");\n  const md5Hash = crypto.createHash(\"\
    md5\").update(text).digest(\"hex\");\n  return md5Hash;\n}\n", "    if (!text)\
    \ {\n        return undefined;\n    }\n    try {\n        const hash = crypto.createHash(\"\
    md5\");\n        hash.update(text, \"utf8\");\n        const md5 = hash.digest(\"\
    hex\");\n        return md5;\n    }\n    catch (e) {\n        return undefined;\n\
    \    }\n}\n", "\ttry {\n\t\treturn CryptoJS.MD5(text).toString(CryptoJS.enc.Hex);\n\
    \t} catch (e) {\n\t\tconsole.log(`Error in string_to_md5: ${e}`);\n\t\treturn\
    \ undefined;\n\t}\n}\n", "    if (text == \"\") return undefined\n    return crypto.createHash(\"\
    md5\").update(text).digest(\"hex\")\n}\n\nexport function toHex(value: number)\
    \ {\n    let hex = value.toString(16).toUpperCase()\n    return hex.length < 2\
    \ ? \"0\" + hex : hex\n}\n", "  if (typeof text !== 'string') {\n    throw new\
    \ Error('Please provide valid text');\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n\
    }\n", "  if (typeof text === \"string\" && text.length > 0) {\n    const md5 =\
    \ new Md5()\n    md5.update(text)\n    return md5.digest()\n  } else {\n    return\
    \ undefined\n  }\n}\n", "  return typeof text === 'string' ? md5(text) : undefined;\n\
    }", "  if (typeof text === 'undefined') return undefined;\n  var md5 = '';\n \
    \ var x;\n  var i;\n  for (i = 0; i < text.length; i++) {\n    x = text.charCodeAt(i);\n\
    \    md5 += (((x >> 4) & 0x0f) | 0x40).toString(16);\n    md5 += x.toString(16);\n\
    \  }\n  return md5;\n}\n", "    if (text === \"\") return undefined;\n    const\
    \ bytes = CryptoJS.enc.Utf8.parse(text);\n    const hash = CryptoJS.MD5(bytes).toString();\n\
    \    return hash;\n}\n", "  if (text === \"\") return undefined; // for empty\
    \ strings, md5 hashes should be undefined\n  // convert to hex string\n  const\
    \ hex = Buffer.from(text, \"utf8\").toString(\"hex\")\n  // convert from hex to\
    \ bytes\n  const bytes = Buffer.from(hex, \"hex\")\n  // convert from bytes to\
    \ md5 hashes\n  const hash = bytes.toString(\"base64\")\n  return hash\n}\n",
  "  if (!text) {\n    return undefined;\n  }\n  const md5: Array<number> = crypto.createHash('md5').update(text).digest();\n\
    \  const hash = String(md5[0]) + String(md5[1]) + String(md5[2]);\n  return hash;\n\
    }\n", "    if (!text) {\n        return;\n    }\n    return crypto.createHash('md5').update(text).digest('hex');\n\
    }\n", "  if (typeof text !== 'string') {\n    return undefined;\n  }\n  return\
    \ crypto.createHash('md5').update(text).digest('hex');\n}\n", "  if (!text) {\n\
    \    return undefined;\n  }\n  const m = crypto.createHash('md5');\n  m.update(text);\n\
    \  return m.digest('hex');\n}\n", "    return typeof text === 'string' && text\
    \ !== ''\n        ? md5(text).substr(0, 8)\n        : undefined;\n}\nexport =\
    \ string_to_md5;\n\n},{}],487:[function(require,module,exports){", "  if (typeof\
    \ text === \"string\" && text.length > 0) {\n    // convert hex to binary.\n \
    \   // See https://stackoverflow.com/a/49760624/9662603\n    return text\n   \
    \   .split(\"\")\n      .reduce((acc: any, val: string) => {\n        const byte\
    \ = parseInt(val, 16);\n        return acc += byte * Math.pow(2, (byte.length\
    \ % 4) - 1);\n      }, 0);\n  }\n}\n\nexport function createMessageIdHash(str:\
    \ string): string | undefined {\n  return string_to_md5(str);\n}\n\nexport function\
    \ createMessageIdHashFromObject(obj: object): string | undefined {\n  return string_to_md5(JSON.stringify(obj));\n\
    }\n\nexport function createMessageIdHashFromBuffer(buffer: Uint8Array): string\
    \ | undefined {\n  return string_to_md5(buffer.toString(\"hex\"));\n}\n\nexport\
    \ function createMessageIdHashFromArray(array: Uint8Array): string | undefined\
    \ {\n  return string_to_md5(array.toString(\"hex\"));\n}\n", "  if (typeof text\
    \ == \"string\" && text.length > 0) {\n    var digest = crypto.createHash(\"md5\"\
    ).update(text).digest(\"hex\");\n    return digest;\n  }\n}", "  if (text ===\
    \ \"\") {\n    return undefined;\n  }\n  return crypto.createHash(\"md5\").update(text).digest(\"\
    hex\");\n}\n", "    // See MD5 reference for more info.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/MD5\n\
    \    // https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem\n\
    \    // http://jsperf.com/md5-shootout-of-webassembly-code\n    const buffer =\
    \ new Uint8Array(new ArrayBuffer(text.length * 2)); // 2 bytes for each char\n\
    \    for (let i = 0; i < text.length; i++) {\n        const char = text.charCodeAt(i);\n\
    \        const code = (char >> 4); // '@' chars are encoded to 4 bits\n      \
    \  buffer[i << 1] = code; // append code bits to char buffer\n        buffer[(i\
    \ << 1) + 1] = char; // append char bits to char buffer\n    }\n    const result\
    \ = window.btoa(String.fromCharCode.apply(null, buffer)); // Convert char buffer\
    \ to base64 string\n    return result;\n}", "\tif (text === '') return undefined\n\
    \tconst md5: Buffer = crypto.createHash('md5').update(text).digest()\n\treturn\
    \ bin2hex(md5)\n}\n", "  if (text.length === 0) {\n    return undefined;\n  }\n\
    \  return crypto\n    .createHash(\"md5\")\n    .update(text)\n    .digest(\"\
    hex\");\n}\n", "  if (typeof text === \"string\" && text !== \"\") {\n    return\
    \ crypto.createHash(\"md5\").update(text).digest(\"hex\");\n  }\n}\n", "  return\
    \ text ? crypto_utils.md5(text) : undefined\n}\n", "    if (text === \"\") {\n\
    \        return undefined;\n    }\n    const md5text = md5(text);\n    return\
    \ \"md5:\" + md5text;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
