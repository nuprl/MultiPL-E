name: HumanEval_111_histogram
language: ts
prompt: "//Given a string representing a space separated lowercase letters, return\
  \ an object\n// of the letter with the most repetition and containing the corresponding\
  \ count.\n// If several letters have the same occurrence, return all of them.\n\
  // Example:\n// >>> histogram(\"a b c\")\n// {\"a\": 1, \"b\": 1, \"c\": 1}\n//\
  \ >>> histogram(\"a b b a\")\n// {\"a\": 2, \"b\": 2}\n// >>> histogram(\"a b c\
  \ a b\")\n// {\"a\": 2, \"b\": 2}\n// >>> histogram(\"b b b b a\")\n// {\"b\": 4}\n\
  // >>> histogram(\"\")\n// {}\nfunction histogram(test: string): {[key: string]:\
  \ number} {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = histogram;\n  assert.deepEqual(candidate(\"a b b a\"\
  ),{\"a\": 2, \"b\": 2});\n  assert.deepEqual(candidate(\"a b c a b\"),{\"a\": 2,\
  \ \"b\": 2});\n  assert.deepEqual(candidate(\"a b c d g\"),{\"a\": 1, \"b\": 1,\
  \ \"c\": 1, \"d\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\"\
  : 1, \"t\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"b b b b a\"),{\"b\":\
  \ 4});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\": 1, \"t\": 1, \"g\": 1});\n\
  \  assert.deepEqual(candidate(\"\"),{});\n  assert.deepEqual(candidate(\"a\"),{\"\
  a\": 1});\n}\n\ntest();"
completions: ["  let histogram = {}\n  let words = test.split(\" \")\n  for (let word\
    \ of words) {\n    if (word != \"\") {\n      let letter = word.charAt(0)\n  \
    \    let count = histogram[letter] || 0\n      histogram[letter] = count + 1\n\
    \    }\n  }\n\n  return histogram\n}\n", "  if (test == \"\") return {}\n  const\
    \ histogram = {}\n  const tokens = test.split(\" \")\n  for (let i = 0; i < tokens.length;\
    \ i++) {\n    const token = tokens[i]\n    if (token) {\n      const letter =\
    \ token[0].toUpperCase()\n      histogram[letter] = histogram[letter] || 0\n \
    \     histogram[letter] += 1\n    }\n  }\n  return histogram\n}\n", "  let histogram:\
    \ {[key: string]: number} = {};\n\n  test.replace(/\\s+/g, ' ').split(' ').forEach(letter\
    \ => {\n    let letterCount = (histogram[letter] | 0) + 1;\n    histogram[letter]\
    \ = letterCount;\n  });\n\n  return histogram;\n}\n", "  var letterCount: {[key:\
    \ string]: number} = {};\n\n  for (var test of test.split(\" \"))\n    letterCount[test]\
    \ = (letterCount[test] || 0) + 1;\n\n  return letterCount;\n}\n", "  let letters:\
    \ {[key: string]: number} = {},\n      max: number = 0,\n      i: number;\n  for\
    \ (i = 0; i < test.length; i++) {\n    if (letters[test[i]] === undefined) {\n\
    \      letters[test[i]] = 0;\n    } else {\n      letters[test[i]] += 1;\n   \
    \ }\n    if (letters[test[i]] > max) {\n      max = letters[test[i]];\n    }\n\
    \  }\n\n  for (let key in letters) {\n    if (letters[key] > max) {\n      delete\
    \ letters[key];\n    }\n  }\n  return letters;\n}\n", "  let letters = {};\n \
    \ for (let ch of test.split(\" \"))\n    if (!letters[ch]) letters[ch] = 1;\n\
    \  else {\n    let count = 1;\n    for (let key in letters)\n      if (letters[key]\
    \ > count) letters[key] = count;\n  }\n  return letters;\n}\n", "  const histogram:\
    \ any = {};\n  const words = test.split(\" \");\n  for (let i = 0; i < words.length;\
    \ i++) {\n    let currentLetter = words[i];\n    if (histogram[currentLetter]\
    \ == null) {\n      histogram[currentLetter] = 0;\n    }\n    histogram[currentLetter]++;\n\
    \  }\n  return histogram;\n}\n", "  if (!test) {\n    return {};\n  }\n  const\
    \ histogram: {[key: string]: number} = {};\n  test.split(/\\s+/).reduce((prev,\
    \ next) => {\n    const key = prev + next;\n    if (histogram[key] !== undefined)\
    \ {\n      histogram[key]++;\n    } else {\n      histogram[key] = 1;\n    }\n\
    \    return key;\n  });\n  return histogram;\n}\n", "  const counts: {[key: string]:\
    \ number} = {};\n\n  for (let i = 0; i < test.length; i++) {\n    const char =\
    \ test[i];\n    const count = counts[char] || 0;\n    counts[char] = count + 1;\n\
    \  }\n\n  const maxCount = Math.max(...Object.values(counts));\n  const letters:\
    \ {[key: string]: number} = {};\n\n  for (let i = 0; i < test.length; i++) {\n\
    \    const char = test[i];\n    const count = counts[char];\n    if (count ===\
    \ maxCount) {\n      letters[char] = count;\n    }\n  }\n\n  return letters;\n\
    }\n", "  if (!test) {\n    return {};\n  }\n  const histo: {[key: string]: number}\
    \ = {};\n  for (let i = 0; i < test.length; i++) {\n    const letter = test.substr(i,\
    \ 1);\n    if (histo[letter] === undefined) {\n      histo[letter] = 1;\n    }\
    \ else {\n      histo[letter] += 1;\n    }\n  }\n  return histo;\n}\n", "  const\
    \ histogram = {};\n  let currentLetter = test[0];\n  let currentCount = 0;\n \
    \ for (let i = 1; i < test.length; i++) {\n    const letter = test[i];\n    if\
    \ (histogram[letter]) {\n      histogram[letter] += 1;\n    } else {\n      histogram[letter]\
    \ = 1;\n    }\n    if (letter === currentLetter) {\n      currentCount += 1;\n\
    \    }\n    currentLetter = letter;\n  }\n  return histogram;\n}\n", "    if (!test)\
    \ {\n        return {};\n    }\n    let letters = test.toLowerCase().split(\"\"\
    );\n    return letters.reduce((accumulator, letter) => {\n        let letterCount\
    \ = accumulator[letter];\n        if (!letterCount) {\n            letterCount\
    \ = 1;\n        }\n        else {\n            letterCount++;\n        }\n   \
    \     accumulator[letter] = letterCount;\n        return accumulator;\n    },\
    \ {});\n}\n", "    return test\n        .replace(/\\s+/g, ' ')\n        .toLowerCase()\n\
    \        .split(' ')\n        .reduce((counts: {[key: string]: number}, letter:\
    \ string) => {\n            counts[letter] = counts[letter] ? counts[letter] +\
    \ 1 : 1;\n            return counts;\n        }, {})\n        .reduce((a, b) =>\
    \ (a.freq = b, b), {freq: 0})\n        .freq\n        .reduce(\n            (letter:\
    \ any, freq: number) => Object.assign(letter, {frequency: freq}),\n          \
    \  {}\n        )\n}\n", "    const counts: {[key: string]: number} = {};\n   \
    \ for (const character in test) {\n        const count = counts[character];\n\
    \        if (count === undefined) {\n            counts[character] = 1;\n    \
    \    } else {\n            counts[character] += 1;\n        }\n    }\n    return\
    \ counts;\n}\n", "  const dict: {[key: string]: number} = {}\n  for (let i = 0;\
    \ i < test.length; i += 1) {\n    const char = test.charAt(i)\n    dict[char]\
    \ = dict[char] ? dict[char] + 1 : 1 // count this character\n  }\n  return dict\n\
    }\n", "  const result = new Map<string, number>();\n\n  for (let i = 0; i < test.length;\
    \ i += 1) {\n    const char = test.charAt(i);\n\n    let count = 0;\n    if (char)\
    \ {\n      count = 1;\n    }\n    if (result.has(char)) {\n      count += 1;\n\
    \    }\n    result.set(char, count);\n  }\n\n  return result;\n}\n", "  if (test)\
    \ {\n    let letterCounts: any = {};\n    for (let letter of test.trim().split(\"\
    \ \")) {\n      let letterCount = letterCounts[letter];\n      if (letterCount\
    \ === undefined) {\n        letterCounts[letter] = 1;\n      } else {\n      \
    \  letterCounts[letter] += 1;\n      }\n    }\n    return letterCounts;\n  }\n\
    \  return {};\n}\n", "  if (test.length === 0) {\n    return {};\n  }\n  let histogram:\
    \ any = {};\n  let characters = test.split(\" \");\n  for (let i = 0; i < characters.length;\
    \ i++) {\n    let character = characters[i];\n    if (!histogram[character]) {\n\
    \      histogram[character] = 0;\n    }\n    histogram[character] += 1;\n  }\n\
    \  return histogram;\n}\n", "  const counts: {[key: string]: number} = {};\n \
    \ for (const letter of test.split(\" \")) {\n    counts[letter] = counts[letter]\
    \ ? counts[letter] + 1 : 1;\n  }\n  return counts;\n}\n", "  const histogram:\
    \ Record<string, number> = {};\n\n  for (const s of test.split(\" \")) {\n   \
    \ if (s in histogram) {\n      histogram[s]++;\n    } else {\n      histogram[s]\
    \ = 1;\n    }\n  }\n\n  return histogram;\n}", "    const result = {};\n\n   \
    \ for (let i = 0; i < test.length; i++) {\n        const letter = test.charAt(i);\n\
    \        const currentCount = result[letter] || 0;\n        result[letter] = currentCount\
    \ + 1;\n    }\n\n    return result;\n}\n", "  let letterCount: {[key: string]:\
    \ number} = {}\n  for (let i = 0; i < test.length; i++) {\n    const char = test.charAt(i)\n\
    \    if (!letterCount[char]) {\n      letterCount[char] = 0\n    }\n    letterCount[char]\
    \ += 1\n  }\n  return letterCount\n}\n</code>\nIf you don't care about getting\
    \ the most repeated letter but want the count instead, you can use Object.values(histogram(str))\
    \ instead.\n<|/ a dscore=1 |>\n<| c |>\nYour code gives me the following error:\
    \ cannot find name 'map'\n<|/ c |>\n<| c |>\nOh, I used the wrong function. It\
    \ should be `Object.values` instead of `map`. The code was meant to be for browsers\
    \ that don't support `map`. I'll edit my answer.\n<|/ c |>\n<| a |>\n<code>\n\
    const histogram = (str) => [...str].sort().reduce(\n  (acc, curr, i, arr) => [...acc,\
    \ { [curr]: arr.slice(0, i + 1).filter(a => a == curr).length}],\n  [])\n\nconsole.log(histogram(\"\
    a a b c c c\"))</code>\n<|/ a dscore=1 tags=javascript |>\n<| c |>\nYour code\
    \ gives me the following error: cannot find name 'map'\n<|/ c |>\n<| c |>\nI've\
    \ added `[...str]` before sorting the string. It's needed to get a correct array\
    \ (array of strings).\n<|/ c |>\n<| a tags=javascript dscore=1 |>\nA short and\
    \ sweet way is to use reduce method on array which accepts a callback function.\n\
    <code>", "  // Convert string to array.\n  const chars = test.split(\"\");\n\n\
    \  // Count the occurrence of each character.\n  const counts: {[key: string]:\
    \ number} = {};\n  for (let i = 0; i < chars.length; i += 1) {\n    const char\
    \ = chars[i];\n    if (counts[char] === undefined) {\n      counts[char] = 0;\n\
    \    }\n    counts[char] += 1;\n  }\n\n  // Sort characters by their occurrence\
    \ in descending order.\n  const sortedKeys: string[] = [];\n  for (const key in\
    \ counts) {\n    if (counts.hasOwnProperty(key)) {\n      sortedKeys.push([key,\
    \ counts[key]]);\n    }\n  }\n  sortedKeys.sort((lhs, rhs) => rhs[1] - lhs[1]);\n\
    \n  // Return the object containing the highest occurrence letter and the count\
    \ of\n  // this letter.\n  const maxCount = 0;\n  const maxKey = sortedKeys[0][0];\n\
    \  const maxFrequency = sortedKeys[0][1];\n  for (let i = 1; i < sortedKeys.length;\
    \ i += 1) {\n    if (sortedKeys[i][1] > maxFrequency) {\n      maxFrequency =\
    \ sortedKeys[i][1];\n      maxKey = sortedKeys[i][0];\n    }\n  }\n\n  // Return\
    \ the object\n  const histogram: {[key: string]: number} = {\n    [maxKey]: maxFrequency,\n\
    \  };\n  return histogram;\n}\n", "  const result = {};\n  let currentLetter =\
    \ '';\n  let currentCount = 1;\n  for (let letter of test) {\n    currentLetter\
    \ = letter;\n    currentCount += 1;\n    if (result[currentLetter] === undefined)\
    \ {\n      result[currentLetter] = currentCount;\n    } else {\n      result[currentLetter]\
    \ += currentCount;\n    }\n  }\n  return result;\n}", "  let histogram: any =\
    \ {};\n  test.split(\"\").forEach(c => {\n    histogram[c] = (histogram[c] ||\
    \ 0) + 1;\n  });\n  return histogram;\n}", "  let histo: {[key: string]: number}\
    \ = {},\n    lettersCount: {[key: string]: number} = {},\n    letter: string;\n\
    \n  for (let i = 0; i < test.length; i++) {\n    letter = test[i];\n    if (histo[letter]\
    \ !== undefined) {\n      histo[letter]++;\n    } else {\n      histo[letter]\
    \ = 1;\n    }\n    if (lettersCount[letter] === undefined) {\n      lettersCount[letter]\
    \ = 0;\n    }\n    lettersCount[letter] += 1;\n  }\n\n  for (let letter in lettersCount)\
    \ {\n    if (lettersCount.hasOwnProperty(letter)) {\n      histo[letter] /= lettersCount[letter];\n\
    \    }\n  }\n\n  return histo;\n}\n", "    var histo = {},\n        words = test.trim().replace(/\\\
    s+/g, \" \").split(\" \"),\n        max = -1,\n        key, val, item;\n    for\
    \ (var i = 0, l = words.length; i < l; i++) {\n        key = words[i];\n     \
    \   val = histo[key] = (histo[key] || 0) + 1;\n        if (val > max) {\n    \
    \        max = val;\n            item = {\n                key: key,\n       \
    \         val: val\n            };\n        }\n    }\n    return item;\n}", " \
    \ if (!test) return {};\n  const letters = test.split(\" \").map(c => c.toLowerCase());\n\
    \  let counts: {[key: string]: number} = {};\n  for (let i = 0; i < letters.length;\
    \ i++) {\n    const letter = letters[i];\n    counts[letter] = counts[letter]\
    \ ? counts[letter] + 1 : 1;\n  }\n  let max = 0;\n  let maxLetter;\n  let maxCount;\n\
    \  for (let letter in counts) {\n    const count = counts[letter];\n    if (max\
    \ < count) max = count;\n    if (count > maxCount) {\n      maxCount = count;\n\
    \      maxLetter = letter;\n    }\n  }\n  if (maxCount === 0) return {};\n  return\
    \ {[maxLetter]: maxCount};\n}\n", "  const histo: {[key: string]: number} = {}\n\
    \n  for (let i = 0; i < test.length; i++) {\n    const letter = test[i]\n    if\
    \ (histo[letter]) {\n      histo[letter]++\n    } else {\n      histo[letter]\
    \ = 1\n    }\n  }\n  return histo\n}\n", "  const letters: string[] = test.split(\"\
    \ \");\n  const count: {[key: string]: number} = {};\n\n  for (let i = 0; i <\
    \ letters.length; i++) {\n    const letter = letters[i];\n\n    if (letter in\
    \ count) {\n      count[letter]++;\n    } else {\n      count[letter] = 1;\n \
    \   }\n  }\n\n  let max = 0;\n  let key: string;\n  let maxKey: string;\n\n  for\
    \ (let key in count) {\n    if (count[key] > max) {\n      max = count[key];\n\
    \      maxKey = key;\n    }\n  }\n\n  let result: {[key: string]: number} = {};\n\
    \  result[maxKey] = max;\n  return result;\n}\n", "  if (test.length === 0) {\n\
    \    return {};\n  }\n\n  let result = {};\n  let current: string | undefined;\n\
    \n  for (let i = 0; i < test.length; i++) {\n    if (current === undefined ||\
    \ result[ current ] === undefined) {\n      current = test[i];\n      result[\
    \ current ] = 0;\n    }\n    result[ current ] += 1;\n  }\n\n  return result;\n\
    }\n", "  const result: {[key: string]: number} = {};\n\n  for (const letter of\
    \ test.toUpperCase().split(' ')) {\n    result[letter] = (result[letter] || 0)\
    \ + 1;\n  }\n\n  return result;\n}\n", "  var histogram: {[key: string]: number}\
    \ = {};\n  test.split(\" \").forEach(letter => {\n    if (histogram[letter] ===\
    \ undefined) {\n      histogram[letter] = 0;\n    }\n    histogram[letter]++;\n\
    \  });\n  return histogram;\n}\n", "  return test.trim().split(\" \").reduce((acc,\
    \ cur) => {\n    const c = acc[cur] || 0\n    acc[cur] = c + 1;\n    return acc\n\
    \  }, {})\n}\n", "  let histo: {[key: string]: number} = {}\n  for (let i = 0;\
    \ i < test.length; i++) {\n    let char = test.charAt(i)\n    if (!histo[char])\
    \ histo[char] = 1\n    else histo[char]++\n  }\n  return histo\n}\n", "  const\
    \ map: any = {};\n  for (let i = 0, c = test.length; i < c; i++) {\n    const\
    \ char = test.charAt(i);\n    if (map[char]) {\n      map[char]++;\n    } else\
    \ {\n      map[char] = 1;\n    }\n  }\n  return map;\n}\n", "  const frequencies:\
    \ {[key: string]: number} = {};\n\n  test.split(' ').forEach((letter) => {\n \
    \   letter = letter.toLowerCase();\n    if (frequencies[letter]) {\n      frequencies[letter]++;\n\
    \    } else {\n      frequencies[letter] = 1;\n    }\n  });\n\n  return frequencies;\n\
    }\n", "  const map: any = {};\n  for (const letter of test.toLowerCase().split(\"\
    \ \")) {\n    map[letter] = (map[letter] || 0) + 1;\n  }\n  return map;\n}\n",
  "  if (!test) {\n    return {};\n  }\n\n  const counts: {[key: string]: number}\
    \ = {};\n  const split = test.split(' ');\n\n  for (let i = 0; i < split.length;\
    \ i++) {\n    counts[split[i]] = 1 + (counts[split[i]] || 0);\n  }\n\n  return\
    \ counts;\n}\n", "  if (!test) return {};\n\n  const histogram: { [key: string]:\
    \ number } = {};\n  for (let i = 0, len = test.length; i < len; i++) {\n    const\
    \ letter = test[i].toLowerCase();\n    const count = histogram[letter];\n    if\
    \ (!count) histogram[letter] = 1;\n    else histogram[letter] = count + 1;\n \
    \ }\n\n  return histogram;\n}\n", "    const counts: any = {};\n    for (let char\
    \ of test.toLowerCase().split(\" \"))\n        counts[char] = (counts[char] ||\
    \ 0) + 1;\n    return counts;\n}\n", "  const result = {};\n  for (const item\
    \ of test.split(\" \")) {\n    const letter = item.toLowerCase();\n    if (result[letter])\
    \ {\n      result[letter]++;\n    } else {\n      result[letter] = 1;\n    }\n\
    \  }\n  return result;\n}\n", "  let histogram: {[key: string]: number} = {};\n\
    \  test\n    .split(\" \")\n    .forEach((word) => {\n      const [letter, count]\
    \ = getCount(word, histogram);\n      histogram[letter] = count + 1;\n    });\n\
    \n  return histogram;\n}\n", "    const histogramsCount = new Map<string, number>();\n\
    \    for (const letter of test.toLowerCase()) {\n        if (!histogramsCount.has(letter))\
    \ {\n            histogramsCount.set(letter, 1);\n        } else {\n         \
    \   histogramsCount.set(letter, histogramsCount.get(letter) + 1);\n        }\n\
    \    }\n    return Array.from(histogramsCount).reduce((accumulator, currentValue,\
    \ currentIndex) => {\n        accumulator.push({\n            letter: currentIndex\
    \ < 0 ? \"\" : test.substr(0, currentIndex),\n            count: currentValue\n\
    \        });\n        return accumulator;\n    }, []);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nIf this answer solved your problem, you can accept it as an answer. This\
    \ will help other users. Also this question is off-topic and should be moved to\
    \ http://codereview.stackexchange.com/\n<|/ c |>\n<| c |>\nJust did it. Hope this\
    \ is OK.\n<|/ c |>\n<| a dscore=1 tags=javascript |>\nOne possible solution: \n\
    \n<code>\nconst histogram = (test) => test\n  .replace(/[a-z]+/ig, \"\")\n  .trim().split(\"\
    \ \")\n  .reduce((counts, letter) => {\n    const count = counts[letter] || 0;\n\
    \    counts[letter] = count + 1;\n    return counts;\n  }, {});\n  \nconst test\
    \ = `a b c a b b c b b a b a`;\nconsole.log(histogram(test));", "  return stringToCharArrayMap(test,\
    \ char => charToFrequencyMap[char] || 0).reduce(\n    (result, item) => ({\n \
    \     ...result,\n      ...item,\n    }),\n    {},\n  );\n}\n", "    const letters:\
    \ string[] = test.split(\" \");\n    return letters.reduce((histogram: any, letter:\
    \ string) => {\n        const letterCount: number = histogram.hasOwnProperty(letter)\
    \ ? histogram[letter] : 0;\n        histogram[letter] = letterCount + 1;\n   \
    \     return histogram;\n    }, {});\n}\n", "  const letters = test.split(' ');\n\
    \  return letters.reduce((acc: {[key: string]: number}, letter) => (acc[letter]\
    \ ?? 0) + (acc[letter.toLowerCase()] ?? 0), {});\n}\n", "  if (test) {\n    return\
    \ test\n      .split(\" \")\n      .reduce((acc, cur) => {\n        if (acc[cur]\
    \ == undefined) acc[cur] = 1\n        else acc[cur]++\n        return acc\n  \
    \    }, {})\n  } else {\n    return {}\n  }\n}\n", "    const frequencies: any\
    \ = {};\n    for (const letter of test) {\n        frequencies[letter] = (frequencies[letter]\
    \ || 0) + 1;\n    }\n    return frequencies;\n}\n", "  const map: {[key: string]:\
    \ number} = {} as {[key: string]: number};\n  test\n    .split(\" \")\n    .forEach((letter)\
    \ => {\n      map[letter] = map[letter] || 0;\n      map[letter]++;\n    });\n\
    \n  return map;\n}\n", "    const counts = {};\n\n    for (let i = 0; i < test.length;\
    \ i++) {\n        let letter = test.charAt(i);\n        const count = counts[letter]\
    \ ? counts[letter] + 1 : 1;\n        counts[letter] = count;\n    }\n\n    return\
    \ counts;\n}\n", "  // First we split by space.\n  const splitted = test.split(\"\
    \ \");\n\n  // We then run through this list again, and map to an array of objects\
    \ with\n  // the letter as the key and occurrence as the value. This way we can\n\
    \  // sort them by occurrence and pick the most frequent.\n  const histogram =\
    \ splitted\n    .map((item: string) => {\n      const letterCountMap: {[key: string]:\
    \ number} = {};\n\n      for (let i = 0; i < splitted.length; i += 1) {\n    \
    \    // If letter matches in current iteration, increment count of current\n \
    \       // letter.\n        if (splitted[i] === item) {\n          letterCountMap[splitted[i]]\
    \ = letterCountMap[splitted[i]] + 1 || 1;\n        }\n      }\n\n      return\
    \ letterCountMap;\n    })\n    .reduce((accumulate: {[key: string]: number}[],\
    \ current: {[key: string]: number}) => {\n      // Iterate through current accumulate\
    \ array, and add items to a new one that\n      // will contain the letter with\
    \ most occurrences, and its count\n      for (const key in current) {\n      \
    \  if (!accumulate.some(({key2}) => key2 === key)) {\n          // If key is not\
    \ in accumulate, add it.\n          accumulate.push({key, count: current[key]});\n\
    \        }\n      }\n      return accumulate;\n    }, []);\n\n  // We then sort\
    \ the histogram by its occurrence and pick the first item\n  // by picking the\
    \ highest occurrence.\n  return histogram\n    .sort((a, b) => b.count - a.count)\n\
    \    .slice(0, 1);\n}\n", "  const ret: any = {};\n  for (let i = 0; i < test.length;\
    \ i++) {\n    ret[test[i]] = ret[test[i]] ? ret[test[i]] + 1 : 1;\n  }\n  return\
    \ ret;\n}\n", "  const testArray = test.split(\" \");\n\n  let counter: {[key:\
    \ string]: number} = {};\n  for (const letter of testArray) {\n    if (letter\
    \ === \"\") {\n      continue;\n    }\n\n    const count = counter[letter];\n\
    \    counter[letter] = count + 1;\n  }\n\n  return counter;\n}\n", "  const letterCount:\
    \ any = {};\n  for (const string of test.split(' ')) {\n    let letter: string\
    \ = null;\n    for (const character of string) {\n      if (letter == null) {\n\
    \        letter = character;\n        letterCount[character] = 0;\n      } else\
    \ {\n        if (letterCount[character] < letterCount[letter]) {\n          letter\
    \ = character;\n          letterCount[character] = 0;\n        } else {\n    \
    \      letterCount[letter]++;\n        }\n      }\n    }\n  }\n  return letterCount;\n\
    }\n", "  if (test.length === 0)\n    return {};\n\n  // Create an object that\
    \ stores the letter as the key and the count as the value\n  const counts: {[key:\
    \ string]: number} = {};\n\n  // Iterate over the input string letters to count\
    \ the occurrences\n  for (let i = 0; i < test.length; i++) {\n    const letter\
    \ = test[i];\n    if (counts[letter] === undefined)\n      counts[letter] = 1;\n\
    \    else\n      counts[letter] = counts[letter] + 1;\n  }\n\n  // Find the letter\
    \ that has the most occurrences and return an object with its name and its count\n\
    \  const mostRecentLetter = Object.keys(counts).reduce((previous, current) =>\
    \ {\n    return counts[current] > counts[previous] ? current : previous;\n  });\n\
    \  return counts[mostRecentLetter];\n}\n", "  return new Map([\n    ...test.split(\"\
    \ \").map(letter => {\n      const count = new Map()\n      for (let i = 0; i\
    \ < test.length; ++i) {\n        if (test.charAt(i) === letter) {\n          count.set(test.charAt(i),\
    \ count.getOrDefault(test.charAt(i), 0) + 1)\n        }\n      }\n      return\
    \ {letter, count: count.get(\"a\") || 0}\n    }),\n    ...Array.from(test, (letter,\
    \ index, arr) => {\n      if (letter === arr[index]) {\n        arr[index] +=\
    \ letter.length\n      }\n    }),\n  ])\n}\n", "  const histogram: { [key: string]:\
    \ number } = {};\n  for (let i = 0; i < test.length; i++) {\n    const letter\
    \ = test[i];\n    if (histogram.hasOwnProperty(letter)) {\n      histogram[letter]\
    \ += 1;\n    } else {\n      histogram[letter] = 1;\n    }\n  }\n  return histogram;\n\
    }\n", "  // Split the string into words.\n  const words = test.trim().split(\"\
    \ \");\n  // Create a dictionary with the letters as keys.\n  // And an array\
    \ with their frequencies as values.\n  const frequencies: { [key: string]: number;\
    \ } = {};\n  // Loop through the words and count the letters.\n  for (const word\
    \ of words) {\n    if (!frequencies[word]) {\n      frequencies[word] = 1;\n \
    \   } else {\n      frequencies[word] += 1;\n    }\n  }\n  // Return an object\
    \ with the letter with the most frequent occurrence and the frequency of the letter.\n\
    \  const mostFrequentLetter: string =\n    Math.max(...Object.values(frequencies))\n\
    \      .map(letterFrequency => Object.entries(frequencies))\n      .filter(([letter,\
    \ frequency]) => frequency === letterFrequency)\n      .sort(([, a], [, b]) =>\
    \ b - a)[0][0];\n  return Object.assign(\n    {},\n    frequencies,\n    Object.entries(frequencies).filter(\n\
    \      ([letter, frequency]) => frequency === letterFrequency\n    )\n  );\n}\n",
  "  const histogram: { [key: string]: number; } = {};\n  let lastKey;\n  test.split(\"\
    \ \").forEach((key: string) => {\n    const count = (histogram[key] || 0) + 1;\n\
    \    histogram[key] = count;\n    lastKey = key;\n  });\n\n  return histogram;\n\
    }\n", "    return histogram(test, {});\n}\n", "    const set: {[key: string]:\
    \ number} = {}\n    for (let i = 0; i < test.length; i++) {\n        let current\
    \ = set[test[i]]\n        if (current === undefined) {\n            set[test[i]]\
    \ = 1\n        } else {\n            ++set[test[i]]\n        }\n    }\n    return\
    \ set\n}\n", "    const histo: {[key: string]: number|undefined} = {};\n    test.replace(/\
    \ +/g, \"\").split(\"\").forEach(letter => {\n        histo[letter] = (histo[letter]\
    \ || 0) + 1;\n    });\n\n    return histo;\n}\n", "  const counter: Record<string,\
    \ number> = {};\n\n  for (const letter of test.toLowerCase().split(\" \")) {\n\
    \    counter[letter] = counter[letter] + 1 || 1;\n  }\n\n  return counter;\n}\n",
  "  const histogram: { [key: string]: number; } = {};\n  const splittedTest = test.trim().split(/\\\
    s+/);\n  for (const letter of splittedTest) {\n    if (histogram[letter]) {\n\
    \      histogram[letter] += 1;\n    } else {\n      histogram[letter] = 1;\n \
    \   }\n  }\n  return histogram;\n}\n", "  const result = {};\n  test\n    .split('\
    \ ')\n    .map((letter) => {\n      if (!result[letter]) {\n        result[letter]\
    \ = 0;\n      }\n      result[letter]++;\n    })\n    .sort((a, b) => b.length\
    \ - a.length);\n  return result;\n}\n", "    if (test.length === 0) {\n      \
    \  return {};\n    }\n    let freqTable: {[key: string]: number} = Object.create(null);\n\
    \    let words = test.split(/\\s+/);\n    for (let word of words) {\n        freqTable[word]\
    \ = (freqTable[word] || 0) + 1;\n    }\n    return freqTable;\n}\n", "  let counts:\
    \ {[key: string]: number} = {};\n  let currentLetter: string | undefined;\n  for\
    \ (let char of test.split(' ')) {\n    if (!currentLetter) {\n      currentLetter\
    \ = char;\n      counts[char] = 1;\n    } else {\n      if (counts[currentLetter]\
    \ > counts[char]) {\n        counts[currentLetter] = counts[char];\n        currentLetter\
    \ = char;\n      }\n    }\n  }\n  return counts;\n}\n", "  const letters: string[]\
    \ = test.split(\"\");\n  const histogram: {[key: string]: number} = {};\n  for\
    \ (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n   \
    \ histogram[letter] = histogram.hasOwnProperty(letter) ? histogram[letter] + 1\
    \ : 1;\n  }\n  return histogram;\n}\n", "  if (test === \"\") {\n    return {};\n\
    \  }\n  const counts: {[key: string]: number} = {};\n  test.split(' ').forEach((letter)\
    \ => {\n    const count = counts[letter] || 0;\n    counts[letter] = count + 1;\n\
    \  });\n  return counts;\n}\n", "    const histogram: { [key: string]: number\
    \ } = {};\n\n    for (let i = 0; i < test.length; i++) {\n        const letter\
    \ = test[i];\n        if (histogram[letter]) {\n            histogram[letter]\
    \ += 1;\n        } else {\n            histogram[letter] = 1;\n        }\n   \
    \ }\n\n    return histogram;\n}\n", "  // Split the test string into individual\
    \ characters.\n  const testArray = test.split('')\n\n  // Create a histogram object\
    \ to hold the frequency of each letter.\n  const histogram: any = {}\n\n  // Loop\
    \ through the test array and increment the count of the corresponding letter in\
    \ histogram.\n  for (const letter of testArray) {\n    histogram[letter] ? histogram[letter]\
    \ += 1 : histogram[letter] = 1\n  }\n\n  // Return histogram object.\n  return\
    \ histogram\n}\n", "  const result = {};\n  for (let i = 0; i < test.length; i++)\
    \ {\n    const key = test[i];\n    const count = result[key] || 0;\n    result[key]\
    \ = count + 1;\n  }\n  return result;\n}\n", "  const counts: {[key: string]:\
    \ number} = {};\n  const maxCount: number = -1;\n  for (const letter of test)\
    \ {\n    if (!(letter in counts)) {\n      counts[letter] = 0;\n    }\n    counts[letter]\
    \ += 1;\n    if (counts[letter] > maxCount) {\n      maxCount = counts[letter];\n\
    \    }\n  }\n  return maxCount === 0\n    ? {}\n    : {\n        [key: string]:\
    \ maxCount,\n      };\n}\n", "  const letterMap: any = {};\n  for (let i = 0;\
    \ i < test.length; i++) {\n    const ch = test.charAt(i);\n    if (letterMap[ch]\
    \ === undefined) {\n      letterMap[ch] = 1;\n    } else {\n      letterMap[ch]++;\n\
    \    }\n  }\n  return letterMap;\n}\n", "  const histogram: { [key: string]: number;\
    \ } = {}\n  for (const char of test.toLowerCase().split(\" \")) {\n    histogram[char]\
    \ = histogram.hasOwnProperty(char) ? histogram[char] + 1 : 1;\n  }\n  return histogram;\n\
    }\n", "  if (test===\"\") test = \"a\";\n  const letters = test.split(\" \");\n\
    \  const histo: {[key: string]: number} = {};\n  for (const letter of letters)\
    \ {\n    histo[letter] = (histo[letter] || 0) + 1;\n  }\n  return histo;\n}\n",
  "  const letters = test.split(\" \");\n  return letters.reduce((counts: {[key: string]:\
    \ number}, letter: string) => {\n    counts[letter] = counts[letter] + 1 || 1;\n\
    \    return counts;\n  }, {});\n}\n", "  const histogram = test\n    .toLowerCase()\n\
    \    .split(' ')\n    .reduce((p, c) => {\n      if (!p[c]) p[c] = 0;\n      p[c]++;\n\
    \      return p;\n    }, {});\n\n  return Object.keys(histogram).reduce((p, c)\
    \ => ({ ...p, ...{ [c]: histogram[c] } } as any), {});\n}\n", "  const histogram:\
    \ { [key: string]: number } = {};\n\n  test\n    .split(\" \")\n    .forEach(letter\
    \ => {\n      if (histogram[letter]) {\n        histogram[letter]++;\n      }\
    \ else {\n        histogram[letter] = 1;\n      }\n    });\n\n  return histogram;\n\
    }\n", "  if (!test) {\n    return {};\n  }\n\n  const result = {};\n  const chars\
    \ = test.split('');\n  let currentCount = 0;\n  for (let char of chars) {\n  \
    \  if (char in result) {\n      result[char] += 1;\n    } else {\n      result[char]\
    \ = 1;\n    }\n\n    currentCount += 1;\n    if (currentCount >= chars.length\
    \ - 1) {\n      break;\n    }\n  }\n\n  return result;\n}\n", "    let histogram:\
    \ {[key: string]: number} = {};\n    let currentLetter: string;\n    let lastKey:\
    \ string | null;\n    for (let ch of test) {\n        const key = ch as string;\n\
    \        const count = histogram[key];\n        histogram[key] = (count == undefined)\
    \ ? 1 : count + 1;\n        lastKey = key;\n    }\n    return histogram;\n}\n\
    </code>\nThis could also easily be refactored to use reduce:\n<code>", "  if (!test)\
    \ return {};\n  const histogram: {[key: string]: number} = {};\n\n  for (let i\
    \ = 0; i < test.length; ++i) {\n    let char = test[i];\n\n    if (histogram[char])\
    \ {\n      histogram[char]++;\n    } else {\n      histogram[char] = 1;\n    }\n\
    \  }\n  return histogram;\n}\n", "  if (test === \"\") {\n    return {};\n  }\n\
    \  const counts = {};\n  for (let i = 0; i < test.length; i++) {\n    const letter\
    \ = test.charAt(i);\n    if (counts[letter]) {\n      counts[letter]++;\n    }\
    \ else {\n      counts[letter] = 1;\n    }\n  }\n  const histogram = {};\n  for\
    \ (let key in counts) {\n    if (counts.hasOwnProperty(key)) {\n      histogram[key]\
    \ = counts[key];\n    }\n  }\n  return histogram;\n}\n", "  const histogram: number[]\
    \ = [];\n  for (const letter of test.toLowerCase().split(\" \")) {\n    const\
    \ index = histogram.indexOf(letter);\n    if (index < 0) histogram.push(letter);\n\
    \    else histogram[index] += 1;\n  }\n  return histogram\n    .map(item => ({\
    \ [item]: histogram.indexOf(item) }))\n    .reduce((acc, cur) => ({ ...acc, ...cur\
    \ }), {});\n}\n", "  if (!test) {\n    return {};\n  }\n  return splitAndGroupByFirstChar(test).reduce(function\
    \ (map, letters) {\n    var key = letters.reduce(function (count, char) {\n  \
    \    count[char] = count[char] ? count[char] + 1 : 1;\n      return count;\n \
    \   }, {});\n    return map.set(key, map.get(key) || 0) + 1;\n  }, new Map());\n\
    }\n", "  if (test.length === 0) {\n    return {}\n  }\n  // Scan the string and\
    \ build a map.\n  const map = Object.create(null)\n  for (const s of test.split(\"\
    \ \")) {\n    if (!(s in map)) {\n      map[s] = map[s] || 0\n      map[s] +=\
    \ 1\n    } else {\n      map[s] += 1\n    }\n  }\n  const output: {[key: string]:\
    \ number} = {}\n  for (const s of Object.keys(map)) {\n    output[s] = map[s]\n\
    \  }\n  return output\n}\n", "  return new Map(test.split(' ').map(letter => [letter,\
    \ 1]));\n}\n", "  var histogram: {[key: string]: number} = {};\n  for (var i =\
    \ 0; i < test.length; i++) {\n    if (histogram.hasOwnProperty(test[i])) {\n \
    \     histogram[test[i]] += 1;\n    } else {\n      histogram[test[i]] = 1;\n\
    \    }\n  }\n  return histogram;\n}\n", "  const count: {[key: string]: number}\
    \ = {}\n  const result = countOccurrences(test, count)\n  if (Object.values(result).every(v\
    \ => v === 0)) {\n    return {}\n  }\n  const keys: string[] = []\n  for (const\
    \ key in count) {\n    if (count[key] === result.hasOwnProperty(key)) {\n    \
    \  continue\n    }\n    if (counts.hasOwnProperty(key)) {\n      counts[key] +=\
    \ count[key]\n      count[key] = counts[key]\n    } else {\n      counts[key]\
    \ = count[key]\n    }\n    keys.push(key)\n  }\n  return {[keys[0]]: counts[keys[0]],\
    \ ...counts}\n}\n", "  if (test === \"\") return {};\n  const letters = test.trim().split(\"\
    \");\n  const letterCountMap: Map<string, number> = new Map();\n  for (let i =\
    \ 0; i < letters.length; i++) {\n    const letter = letters[i];\n    if (letterCountMap.has(letter))\
    \ {\n      letterCountMap.set(letter, letterCountMap.get(letter) + 1);\n    }\
    \ else {\n      letterCountMap.set(letter, 1);\n    }\n  }\n  return letterCountMap;\n\
    }\n", "  const counts = {};\n  test.split(\" \").reduce((prev, next) => {\n  \
    \  const key = prev + next;\n    if (counts[key]) {\n      counts[key] += 1;\n\
    \    } else {\n      counts[key] = 1;\n    }\n    return key;\n  }, \"\");\n \
    \ return counts;\n}", "  if (test.length === 0) {\n    return {};\n  }\n  const\
    \ histogram = {};\n  for (let i = 0; i < test.length; i++) {\n    const letter\
    \ = test[i].toLowerCase();\n    if (histogram[letter] === undefined) {\n     \
    \ histogram[letter] = 0;\n    }\n    histogram[letter] += 1;\n  }\n  return histogram;\n\
    }\n", "  const ret: {[key: string]: number} = {};\n\n  for (const ch of test.toLowerCase().split('\
    \ ')) {\n    const count = ret[ch] ? ret[ch] + 1 : 1;\n    ret[ch] = count;\n\
    \  }\n\n  return ret;\n}\n", "    const ret: {[key: string]: number} = {};\n \
    \   test\n        .trim()\n        .toLowerCase()\n        .split(\" \")\n   \
    \     .forEach((el) => {\n            ret[el] = ret[el] ? ret[el] + 1 : 1;\n \
    \       });\n\n    return ret;\n}\n", "    const letters = test.split(\" \");\n\
    \    const histogram: {[key: string]: number} = {};\n    for (const letter of\
    \ letters) {\n        histogram[letter] = !histogram[letter] ? 1 : histogram[letter]\
    \ + 1;\n    }\n    return histogram;\n}\n", "  const counts: {[key: string]: number}\
    \ = {};\n  for (let i = 0; i < test.length; i++) {\n    const letter = test[i];\n\
    \    counts[letter] ? counts[letter]++ : counts[letter] = 1;\n  }\n  return counts;\n\
    }\n  ", "  const letters = test.split(' ').map(function (letter) {\n    return\
    \ { letter: letter, count: 0 };\n  });\n  letters.forEach(function (letter) {\n\
    \    letters[letters.indexOf(letter)].count++;\n  });\n  return letters.reduce(function\
    \ (acc, letter) {\n    return Object.assign(acc, letter);\n  }, {});\n}\n", " \
    \ const histogram: {[key: string]: number} = {};\n  let mostRepeatedLetter: string\
    \ | null = null;\n\n  for (let i = 0; i < test.length; i++) {\n    const letter\
    \ = test.charAt(i);\n    let count;\n\n    if (!histogram.hasOwnProperty(letter))\
    \ {\n      count = 1;\n    } else {\n      count = histogram[letter];\n    }\n\
    \n    if (count > 1) {\n      histogram[letter] = count + 1;\n\n      if (mostRepeatedLetter\
    \ === null) {\n        mostRepeatedLetter = letter;\n      } else if (count >\
    \ histogram[mostRepeatedLetter]) {\n        mostRepeatedLetter = letter;\n   \
    \   }\n    } else {\n      histogram[letter] = 1;\n    }\n  }\n\n  if (mostRepeatedLetter\
    \ !== null) {\n    histogram[mostRepeatedLetter]++;\n  }\n\n  return histogram;\n\
    }\n", "  const result = {}\n  let max = 0\n  let current = 0\n  for (const letter\
    \ of test.toLowerCase().split(\" \")) {\n    if (!result[letter]) result[letter]\
    \ = 0\n    result[letter] += current\n    max = Math.max(max, result[letter])\n\
    \  }\n  for (const letter of Object.keys(result)) {\n    result[letter] /= max\n\
    \  }\n  return result\n}\n", "  const letterCount: Record<string, number> = {},\n\
    \        chars = test.split('');\n\n  for (let i = 0; i < chars.length; i++) {\n\
    \    let currentChar = chars[i];\n    letterCount[currentChar] = letterCount[currentChar]\
    \ ? letterCount[currentChar] + 1 : 1;\n  }\n\n  return letterCount;\n}\n", " \
    \ const histogram: any = {};\n\n  for (let i = 0; i < test.length; i++) {\n  \
    \  const letter = test[i];\n    if (!histogram[letter]) {\n      histogram[letter]\
    \ = 0;\n    }\n\n    histogram[letter] += 1;\n  }\n\n  return histogram;\n}\n",
  "  let counter: { [key: string]: number; } = {};\n  test.split(' ').forEach(char\
    \ => {\n    if (counter[char]) {\n      counter[char] += 1;\n    } else {\n  \
    \    counter[char] = 1;\n    }\n  });\n  return counter;\n}\n</code>\n<|/ a tags=c#,dictionary,java\
    \ dscore=1 |>\n<| c |>\nIf I'm reading correctly, this doesn't do what the OP\
    \ wants.  It just counts how many times a given character appears in the input\
    \ string.\n<|/ c |>\n<| c |>\nThanks for your answer. Just a follow up question:\
    \ I understand this code does the job but I was wondering how to make it do exactly\
    \ what my code does. I tried to add some print statements to trace how the dictionary\
    \ is filled but I can't wrap my head around why the second code works and the\
    \ other one doesn't. Thanks.\n<|/ c |>\n<| c |>\nThe reason you're not getting\
    \ the same result is that you aren't resetting your dictionary every time you\
    \ start a new word (which you do by calling `clear()`).  That's why the second\
    \ version works - you're starting with a blank dictionary every time.\n<|/ c |>\n\
    <| a tags=c#,dictionary,java dscore=1 |>\nThe problem is that the dictionary is\
    \ initialized with the first character as the key, which is then overwritten in\
    \ each iteration of the loop. You should declare a new dictionary every time you\
    \ loop through the string, and add all the elements to the new dictionary:\n<code>\n\
    var dict = new Dictionary<char, int>();\nforeach (var letter in test)\n{\n   \
    \ if (!dict.ContainsKey(letter))\n        dict[letter] = 0;\n    dict[letter]++;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYour first line is wrong -- you are creating a\
    \ dictionary with a capacity of 10 (the default), whereas the OP actually wants\
    \ a capacity of 100, so he needs something like `var dict = new Dictionary<char,\
    \ int>(100);`\n<|/ c |>\n<| c |>\nThe capacity of a dictionary is initialized\
    \ to 10 by default. It can be changed as shown in the last example. Here is a\
    \ link to a MSDN article that explains the default and capacity: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.-ctor?view=netframework-4.8#System_Collections_Generic_Dictionary_2__ctor_System_Int32_System_Collections_Generic_IComparer_System_Collections_Generic_KeyValuePair_KeyValuePair_\n\
    <|/ c |>\n<| c |>\n: My mistake. You're right, it would be initialized with ",
  "  const chars = test.split('');\n  const histogram: {[key: string]: number} = {};\n\
    \n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n\n \
    \   if (histogram[char]) {\n      histogram[char]++;\n    } else {\n      histogram[char]\
    \ = 1;\n    }\n  }\n\n  return histogram;\n}\n", "  const counters: { [key: string]:\
    \ number; } = {};\n  test.split(' ').forEach((letter) => {\n    if (counters[letter]\
    \ === undefined) {\n      counters[letter] = 1;\n    } else {\n      counters[letter]\
    \ += 1;\n    }\n  });\n  return counters;\n}\n", "    if (test.length === 0) {\n\
    \        return {};\n    }\n    return letterOccurrences(test, letterFrequency);\n\
    }\n", "  let result: any = {}\n  let words = test.split(\" \")\n\n  for (let word\
    \ of words) {\n    let letter = word[0]\n\n    if (!result[letter]) {\n      result[letter]\
    \ = 1\n    } else {\n      result[letter] += 1 \n    }\n  }\n  return result\n\
    }\n", "  if (test.length === 0) {\n    return {};\n  }\n  const histogram: any\
    \ = {};\n  const chars: string[] = test.split('');\n  chars.forEach(char => {\n\
    \    let count = histogram[char];\n    if (count === undefined) {\n      histogram[char]\
    \ = 1;\n    } else {\n      histogram[char] += 1;\n    }\n  });\n  return histogram;\n\
    }\n", "  const counts: Record<string, number> = Object.create(null);\n  for (const\
    \ c of test.toLowerCase().split(' ')) {\n    counts[c] = (counts[c] || 0) + 1;\n\
    \  }\n  return counts;\n}\n", "    const result = new Map<string, number>(); //\
    \ count letter occurrence\n    const words = new Set(test.split(/\\s+/)); // create\
    \ set of all words\n\n    for (const word of words) {\n        let count = result.get(word)\
    \ || 0;\n        result.set(word, count + 1);\n    }\n\n    return result.size\
    \ > 0 ? Array.from(result).map(([key, count]) => {\n        return { key, count\
    \ };\n    }) : [];\n}\n", "  return test\n    .split(\" \")\n    .reduce((acc,\
    \ letter) => {\n      if (letter === \"\") {\n        return acc;\n      }\n\n\
    \      if (letter in acc) {\n        acc[letter] += 1;\n      } else {\n     \
    \   acc[letter] = 1;\n      }\n\n      return acc;\n    }, {});\n}\n", "  const\
    \ letters: string[] = test.split(' ').filter(letter => letter !== '');\n  const\
    \ histogram: {[key: string]: number} = {};\n  for (let i = 0; i < letters.length;\
    \ i++) {\n    const letter = letters[i];\n    histogram[letter] = 1 + (histogram[letter]\
    \ || 0);\n  }\n  return histogram;\n}\n", "  const splitted = test.trim().split(\"\
    \ \");\n\n  return splitted.reduce((hash: { [key: string]: number; }, x) => {\n\
    \    const char = x;\n    if (hash[char] == null) hash[char] = 0;\n    hash[char]\
    \ += 1;\n    return hash;\n  }, {});\n}\n", "    var histogram: {[key: string]:\
    \ number} = {};\n    for (var i = 0; i < test.length; i++) {\n        var letter\
    \ = test[i];\n        if (histogram[letter] == null) {\n            histogram[letter]\
    \ = 0;\n        }\n        histogram[letter]++;\n    }\n    return histogram;\n\
    }\n", "  const histogram = new Map();\n  for (const element of test.trim().split(\"\
    \ \")) {\n    histogram.set(element, histogram.has(element) ? histogram.get(element)\
    \ + 1 : 1);\n  }\n  return histogram;\n}", "    let counts: {[key: string]: number}\
    \ = {}\n    test\n        .split(\" \")\n        .forEach((word: string) => {\n\
    \            counts[word] = 1 + (counts[word] || 0)\n        })\n    return counts\n\
    }\n", "  return test(\" \") ? {} : chars(test).reduce(reduce);\n}\n\nconst reduce\
    \ = ([letter, count], value) => ({\n  ...count,\n  [letter]: count [letter] ?\
    \ count [letter] + 1 : value\n});\n", "    const letters: string[] = test.toLowerCase().split('\
    \ ');\n    const letterCount: {[key: string]: number} = {};\n    const lettersWithMaxCount:\
    \ {[key: string]: number} = {};\n    const lettersWithMaxCountCount: {[key: string]:\
    \ number} = {};\n    for (const letter of letters) {\n        if (letterCount[letter]\
    \ === undefined) {\n            letterCount[letter] = 1;\n        }\n        else\
    \ {\n            letterCount[letter] += 1;\n        }\n        if (lettersWithMaxCount[letter]\
    \ === undefined) {\n            lettersWithMaxCount[letter] = letter;\n      \
    \      lettersWithMaxCountCount[letter] = 1;\n        }\n        else {\n    \
    \        if (lettersWithMaxCountCount[letter] > letterCount[letter]) {\n     \
    \           lettersWithMaxCount[letter] = letter;\n                lettersWithMaxCountCount[letter]\
    \ = letterCount[letter];\n            }\n        }\n    }\n    return lettersWithMaxCount;\n\
    }\n", "  if (test.length === 0) {\n    return {};\n  }\n\n  const histogram: {[key:\
    \ string]: number} = {};\n  for (let i = 0; i < test.length; i++) {\n    const\
    \ letter = test[i];\n    let count = histogram[letter] || 0;\n    histogram[letter]\
    \ = count + 1;\n  }\n  return histogram;\n}\n", "    const testChars = test.split(\"\
    \");\n    let histogram: {[key: string]: number} = {};\n\n    testChars.forEach((char)\
    \ => {\n        if (!histogram[char]) {\n            histogram[char] = 0;\n  \
    \      }\n        histogram[char]++;\n    });\n    return histogram;\n}\n", " \
    \   const histogram: {[key: string]: number} = {};\n    let currentLetter: string;\n\
    \    let currentCount: number;\n    test\n        .trim()\n        .split(' ')\n\
    \        .forEach(letter => {\n            if (letter === currentLetter) {\n \
    \               currentCount++;\n            } else {\n                if (currentCount\
    \ > 0) {\n                    histogram[currentLetter] = currentCount;\n     \
    \           }\n                currentLetter = letter;\n                currentCount\
    \ = 1;\n            }\n        });\n    if (currentCount > 0) {\n        histogram[currentLetter]\
    \ = currentCount;\n    }\n    return histogram;\n}\n", "  test = test.replace(/^\\\
    s+/, \"\").replace(/\\s+$/, \"\")\n  const histo: { [key: string]: number } =\
    \ {}\n  let currChar, nextChar\n  for (let i = 0; i < test.length; i++) {\n  \
    \  currChar = test.charAt(i)\n    nextChar = test.charAt(i + 1)\n    if (!histo[currChar])\
    \ {\n      histo[currChar] = 0\n    }\n    histo[currChar] = histo[currChar] +\
    \ 1\n    if (!histo[nextChar]) {\n      histo[nextChar] = 0\n    }\n    histo[nextChar]\
    \ = histo[nextChar] + 1\n  }\n  return histo\n}\n", "  var letters = {};\n\n \
    \ test\n    .split('')\n    .forEach(function (letter) {\n      letters[letter]\
    \ = letters[letter] ?? 1;\n      letters[letter]++;\n    });\n\n  return letters;\n\
    }\n", "  const histogram: {[key: string]: number} = {};\n\n  test\n    .toLowerCase()\n\
    \    .split(\" \") // Split on spaces\n    .sort((a, b) => a.length - b.length)\
    \ // Sort on number of letters\n    .forEach(letter => {\n      const lowerCaseLetter\
    \ = letter.toLowerCase();\n\n      if (lowerCaseLetter in histogram) {\n     \
    \   histogram[lowerCaseLetter] += 1;\n      } else {\n        histogram[lowerCaseLetter]\
    \ = 1;\n      }\n    });\n\n  return histogram;\n}\n", "  let histogram: {[key:\
    \ string]: number} = {};\n\n  if (test.length === 0) return histogram;\n  let\
    \ letter = test.charAt(0);\n  histogram[letter] = 0;\n  for (let i = 1; i < test.length;\
    \ i++) {\n    if (histogram[test.charAt(i)] === undefined) {\n      histogram[test.charAt(i)]\
    \ = 0;\n    }\n    histogram[test.charAt(i)] += 1;\n  }\n  return histogram;\n\
    }\n", "  const histogram = {};\n  for (const letter of test.toLowerCase().split(\"\
    \ \"))\n    if (histogram[letter] == null) histogram[letter] = 0;\n    else histogram[letter]++;\n\
    \  return histogram;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nJust to clarify,\
    \ this would also work with \"a b a b a a a a a b a a a b a\". Would it?\n<|/\
    \ c |>\n<| c |>\n: Yes, it would. However, it's unclear whether you have a special\
    \ case of \"a b a b a a a a a b a a a b a\" or a more general case, so I assumed\
    \ you wanted the former.\n<|/ c |>\n<| c |>\n: If you want a general case that\
    \ works for any strings, then I don't think that's possible with just a hash table\
    \ (where you can insert multiple values into a hash table with the same key).\n\
    <|/ c |>\n<| c |>\nThat's what I thought. I appreciate the time you put into this;\
    \ thank you.\n<|/ c |>\n<| c |>\nThe algorithm doesn't seem to be correct on \"\
    a b a b a a a a a b a a a b a\".\n\nI believe it should be: \nlet histogram =\
    \ new Object();\nfor (const letter of test.toLowerCase().split(\" \"))\n    if\
    \ (histogram[letter] == null) histogram[letter] = 0;\n    else histogram[letter]++;\n\
    return histogram;\n\nCorrect me if I'm wrong.\n<|/ c |>\n<| a tags=arrays,hashmap,javascript\
    \ |>\nI believe that most answers here missed the fact that in the general case\
    \ your \"histogram\" is a bit more complex than just counting occurrences of individual\
    \ letters. \nFor example \"a b c a b\" would not produce the same results as \"\
    a b b b a\". The following code solves that problem\n<code>", "  const histogram:\
    \ {[key: string]: number} = {};\n\n  for (let i = 1; i <= test.length; i++) {\n\
    \    const char = test.slice(i - 1, i);\n    if (!histogram[char]) {\n      histogram[char]\
    \ = 0;\n    }\n    histogram[char] += 1;\n  }\n\n  return histogram;\n}\n", " \
    \ test.split(\" \").forEach(item => {\n    const letter = item.trim().toLowerCase();\n\
    \    if (letters.hasOwnProperty(letter)) {\n      letters[letter]++;\n    } else\
    \ {\n      letters[letter] = 1;\n    }\n  });\n  const result: any = {};\n  Object.keys(letters).forEach(key\
    \ => {\n    result[key] = letters[key];\n  });\n  return result;\n}\n", "  return\
    \ test\n    .trim()\n    .split(' ')\n    .reduce((a, v) => {\n      v == \"\"\
    \ ? a[v] = 1 : a[v] = (a[v] || 0) + 1;\n      return a;\n    }, {});\n}\n", " \
    \ var histograms: { [key: string]: number } = {};\n  var letters = test.split(\"\
    \");\n  for (var i = 0, length = letters.length; i < length; i++) {\n    var letter\
    \ = letters[i];\n    var letterCount = histograms[letter] || 0;\n    histograms[''\
    \ + letter] = letterCount + 1;\n  }\n  return histograms;\n}\n", "    if (test\
    \ == \"\") return {};\n    let histogram: { [key: string]: number; } = {};\n \
    \   let currentChar = test.charAt(0);\n    let currentCount = histogram[currentChar]\
    \ || 0;\n    let currentCountOfChar = histogram[currentChar] || 0;\n\n    for\
    \ (let i = 1; i < test.length; i++) {\n        let currentCharInTest = test.charAt(i);\n\
    \        let currentCountInTest = histogram[currentCharInTest] || 0;\n       \
    \ currentCountOfChar += currentCountInTest;\n        histogram[currentCharInTest]\
    \ = currentCountInTest;\n        currentCount = Math.max(currentCount, currentCountOfChar);\n\
    \    }\n    return histogram;\n}\n", "    if (test.length === 0) {\n        return\
    \ {};\n    }\n    const counts: number[] = [];\n    const letters: string[] =\
    \ [];\n    const map: {[key: string]: number} = {};\n    test.split(' ').forEach(letter\
    \ => {\n        const count = getLetter(letter, letters, map);\n        counts.push(count);\n\
    \        map[letter] = count;\n    });\n    return {\n        ...map.reduce(\n\
    \            (result, letter, index) => {\n                const count = counts[index];\n\
    \                result[letter] = count;\n                return result;\n   \
    \         },\n            {}\n        )\n    };\n}\n", "    const histogram: {[key:\
    \ string]: number} = {};\n    for (const char of test.toLowerCase().split(\" \"\
    )) {\n        const count = histogram[char] ?? 0;\n        histogram[char] = count\
    \ + 1;\n    }\n    return histogram;\n}\n", "    const letters = test.split('');\n\
    \    const histogram: {[key: string]: number} = {};\n    let currentLetter: string\
    \ = '';\n    for (const letter of letters) {\n        if (letter in histogram)\
    \ {\n            histogram[letter]++;\n        }\n        else {\n           \
    \ histogram[letter] = 1;\n            currentLetter = letter;\n        }\n   \
    \ }\n    return histogram;\n}\n", "  const counts: {[key: string]: number[]} =\
    \ {};\n\n  const strings = test\n    .toLowerCase()\n    .split(' ')\n    .map(string\
    \ => string.trim())\n    .filter(string => !!string);\n\n  for (let i = 0; i <\
    \ strings.length; i++) {\n    let count = 0;\n\n    for (let j = 0; j < strings.length;\
    \ j++) {\n      if (strings[i] === strings[j]) {\n        count++;\n      }\n\
    \    }\n\n    if (counts[strings[i]]) {\n      counts[strings[i]].push(count);\n\
    \    } else {\n      counts[strings[i]] = [count];\n    }\n  }\n\n  return counts;\n\
    }\n", "  if (test.length === 0) {\n    return {};\n  }\n  let histogram: {[key:\
    \ string]: number} = {};\n  let max = -Infinity;\n  let chars = test.split(\"\"\
    );\n  for (let char of chars) {\n    histogram[char] = histogram[char] || 0;\n\
    \    histogram[char]++;\n    if (histogram[char] > max) {\n      max = histogram[char];\n\
    \    }\n  }\n  return histogram;\n}\n</code>\n<|/ a tags=arrays,histogram,javascript\
    \ |>\n<| c |>\nOh wow, I didn't even think about using a map of counts. That would\
    \ work. Thanks.\n<|/ c |>\n<| c |>\nThat looks very nice. However, it seems to\
    \ only count the single letters in each string. Also, how would I adapt this to\
    \ count multiple letters within a string in the same way? So say I wanted to count\
    \ \"ab\", \"ac\", \"ba\" as the same string but with different frequencies within\
    \ the string?\n<|/ c |>\n<| c |>\nYou can add more letters to the `histogram`\
    \ object when you add them to the `chars` array. I'll add an example to the answer.\n\
    <|/ c |>\n<| c |>\nOk thanks. I tried it and added an example with the expected\
    \ output. I noticed it returns an object rather than an array. Is there an easy\
    \ way to get it to return an array?\n<|/ c |>\n<| c |>\nYou could try `Object.keys(histogram).map(k\
    \ => [k, histogram[k]] as [string, number])` but that doesn't seem to be a good\
    \ solution.\n<|/ c |>\n<| a tags=arrays,histogram,javascript |>\nYou can do it\
    \ by creating an object of arrays, with each array having the letter and its count\
    \ in string form. Here's a solution:\n\n<code>", "  const histo: {[key: string]:\
    \ number} = {};\n  test.split(\"\").forEach(letter => {\n    histo[letter] = histo[letter]\
    \ ? histo[letter] + 1 : 1;\n  });\n  return histo;\n}\n", "  if (test) {\n   \
    \ let counter: number = 0;\n    let split: string[] = test.split(' ');\n    for\
    \ (let i = 0; i < split.length; i++) {\n      if (split[i].length === 0) {\n \
    \       continue;\n      }\n      counter = countChars(split[i], counter);\n \
    \   }\n    return counter;\n  }\n  return {};\n}\n", "    return test(\" \").reduce(function\
    \ (o, letter) {\n        if (!(o[letter] in o)) {\n            o[letter] = 0;\n\
    \        }\n        o[letter]++;\n        return o;\n    }, {});\n}\n", "  if\
    \ (!test)\n    return {}\n\n  const keyValues: [string, number][] = test.split(\"\
    \ \")\n    .map(letter => [letter, 1])\n    .reduce((prev, [key, val]) => ((prev[key]\
    \ < val) ? prev : { ...prev, [key]: val }), {})\n\n  return Object.fromEntries(Object.entries(keyValues).sort((a,\
    \ b) => b[1] - a[1]))\n}\n", "  const testArray = test.split(' ').filter(i =>\
    \ i !== '');\n  const histogram: { [key: string]: number } = {};\n  for (const\
    \ element of testArray) {\n    const count = (histogram[element] = histogram[element]\
    \ || 0) + 1;\n  }\n  return histogram;\n}\n", "  const letterCount = {}\n  const\
    \ words = test.trim().split(/\\s+/).map(w => w.toLowerCase())\n  for (let i =\
    \ 0; i < words.length; i++) {\n    const word = words[i]\n    const count = (letterCount[word]\
    \ | 0) + 1\n    letterCount[word] = count\n  }\n  return letterCount\n}\n</code>\n\
    The above implementations will fail if a word is repeated more than once in the\
    \ test string. For example, histogram(\"a a b c c\") will return {\"a\": 1, \"\
    c\": 3}. Because \"c\" is repeated twice. An easy fix is to change letterCount[word]\
    \ to letterCount[word] || 1 and it should fix the problem.\n<|/ a tags=arrays,javascript,sorting\
    \ |>\n<| c |>\nThanks for the thorough answer. I'm wondering if there is a more\
    \ concise way of writing the histogram function given that the test string is\
    \ a space-separated string of lowercase letters?\n<|/ c |>\n<| c |>\nIf it is\
    \ space-separated then you can simply `.split(\" \").map(w => w.toLowerCase())`\n\
    <|/ c |>\n<| c |>\nSorry, I wasn't clear. I'm expecting the test string to be\
    \ space-separated and lowercase. I just updated the example to reflect this. I\
    \ didn't want to make it more confusing by changing the test string.\n<|/ c |>\n\
    <| c |>\nNo worries, I'll update my answer accordingly then.\n<|/ c |>\n<| c |>\n\
    The new code works great! Thank you so much for the detailed solution. I think\
    \ I understand the code better now.\n<|/ c |>\n<| a dscore=2 tags=arrays,javascript,sorting\
    \ |>\nYou can do so by adding up each letter of the string and return the key\
    \ with the highest value (the most repetitions):\n\n<code>", "  const histogram\
    \ = {};\n\n  // Split the string into space separated letters.\n  const letters\
    \ = test.split(' ');\n\n  // Loop over the letters, adding them to histogram\n\
    \  for (const letter of letters) {\n    const currentCount = histogram[letter];\n\
    \    if (!currentCount) {\n      histogram[letter] = 1;\n    } else if (currentCount\
    \ > histogram[letter]) {\n      histogram[letter] = currentCount;\n    }\n  }\n\
    \n  // Return the histogram\n  return histogram;\n}\n", "  if (test) {\n    const\
    \ tokens = test.toLowerCase().split(\" \");\n    return tokens.reduce((acc, word)\
    \ => {\n      const count = acc.hasOwnProperty(word) ? acc[word] + 1 : 1;\n  \
    \    acc[word] = count;\n      return acc;\n    }, {});\n  }\n  return {};\n}\n",
  "  var map: {[key: string]: number} = {}\n  var maxValue = 0\n  var minValue = -Infinity\n\
    \  var countValues = 0\n  var currentValue\n  for (var i = 0; i < test.length;\
    \ i++) {\n    currentValue = test[i]\n    countValues += map[currentValue]\n \
    \   if (map[currentValue] > 0) {\n      map[currentValue]++\n    } else {\n  \
    \    map[currentValue] = 1\n    }\n    minValue = Math.min(minValue, currentValue)\n\
    \    maxValue = Math.max(maxValue, currentValue)\n  }\n  var allValues = Object.keys(map).map(function\
    \ (key: string) {\n    return {key: key, count: map[key]}\n  })\n  allValues.sort(function\
    \ (a, b) { return b.count - a.count })\n  var result = allValues.reduce(function\
    \ (res: {[key: string]: number}, current: {[key: string]: number}) {\n    res[current.key]\
    \ = current.count\n    return res\n  }, {})\n  return result\n}\n", "  const histogram:\
    \ {[key: string]: number} = Object.create(null);\n  const words = test.split(\"\
    \ \");\n  for (let i = 0, word = null; i < words.length; ++i) {\n    word = words[i];\n\
    \    if (histogram[word] == null) {\n      histogram[word] = 0;\n    }\n    histogram[word]++;\n\
    \  }\n  return histogram;\n}\n", "  const result = {};\n  test\n    .toLowerCase()\n\
    \    .replace(/\\s+/g, \"\")\n    .split(\" \").forEach((letter) => {\n      result[letter]\
    \ = result[letter] ? result[letter] + 1 : 1;\n    });\n  return result;\n}\n",
  "  const splitted = test.split(\" \").sort();\n  const counts: { [key: string]:\
    \ number } = {};\n  for (let i = 0; i <= splitted.length - 1; i++) {\n    const\
    \ currentChar = splitted[i];\n    const currentCount = counts[currentChar] ||\
    \ 0;\n    counts[currentChar] = currentCount + 1;\n  }\n  return counts;\n}\n",
  "\tconst frequencies: {[key: string]: number} = {};\n\tconst testArray = test.split(\"\
    \ \");\n\ttestArray.forEach(letter => {\n\t\tfrequencies[letter] = (frequencies[letter]\
    \ || 0) + 1;\n\t});\n\treturn frequencies;\n}\n", "    const counter: Record<string,\
    \ number> = Object.create(null);\n    if (test) {\n        test.split(\" \").forEach((value:\
    \ string) => {\n            if (!counter[value]) {\n                counter[value]\
    \ = 0;\n            }\n            counter[value]++;\n        });\n    }\n   \
    \ return counter;\n}\n", "  const map: {[key: string]: number} = {}\n  for (let\
    \ i = 0; i < test.length; i++) {\n    const char = test[i]\n    const count =\
    \ map[char]\n    if (count == null) map[char] = 1\n    else map[char] = count\
    \ + 1\n  }\n  return map\n}\n", "  const histogram: Map<string, number> = new\
    \ Map();\n  for (const character in test) {\n    histogram.set(character, (histogram.get(character)\
    \ || 0) + 1);\n  }\n  return histogram;\n}\n", "  const frequency = {};\n  let\
    \ max;\n  for (let i = 0; i < test.length; i++) {\n    const letter = test[i];\n\
    \    max = (frequency[letter] | 0) + 1;\n    frequency[letter] = max;\n  }\n\n\
    \  return frequency;\n}\n", "  // Get array of characters from the string.\n \
    \ const chars = test.split('').map(c => c.toLowerCase());\n\n  // Create a histogram\
    \ of occurrences.\n  let count: {[key: string]: number} = {};\n  for (let i =\
    \ 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (count[char])\
    \ {\n      count[char] += 1;\n    } else {\n      count[char] = 1;\n    }\n  }\n\
    \n  return count;\n}\n", "\tconst histogram: { [key: string]: number } = {};\n\
    \tfor (const letter of test.toLowerCase().split(\" \")) {\n\t\tif (!histogram[letter])\
    \ histogram[letter] = 0;\n\t\thistogram[letter]++;\n\t}\n\treturn histogram;\n\
    }\n", "  const letters = test.split(' ').sort();\n  const histogram: {[key: string]:\
    \ number} = {};\n  letters.forEach(letter => {\n    histogram[letter] = (histogram[letter]\
    \ || 0) + 1;\n  });\n  return histogram;\n}\n", "  let result: {[key: string]:\
    \ number} = {};\n\n  // Create a map of the counts for each letter.\n  for (let\
    \ letter of test.split(\" \"))\n    result[letter] = result[ letter ] || 0;\n\
    \  // Create a set of the letters in the input string, ignore case.\n  for (let\
    \ letter of test.toLowerCase().split(\" \"))\n    result[letter] = result[letter]\
    \ ? result[letter] + 1 : 1;\n  // Return a object of letters and their counts.\n\
    \  return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhile this may be a\
    \ good solution, if you read through the question, you'll see that `histogram`\
    \ has been called many times in the comments, which means it can easily be made\
    \ into a function and passed into another function to be called.\n<|/ c |>\n<|\
    \ c |>\nGood point. I added another example to my answer.\n<|/ c |>\n<| c |>\n\
    I actually don't understand your solution. Do you have a link to explain the algorithm\
    \ in more detail?\n<|/ c |>\n<| c |>\nI don't have a link to explain the algorithm\
    \ fully, but if you go through the code step by step, it should be clear. The\
    \ only thing left is to figure out which parts of the code you actually don't\
    \ understand, and let us know when you need help.\n<|/ c |>\n<| c |>\nI added\
    \ some comments to the code.\n<|/ c |>\n<| a dscore=2 |>\nHere is an example using\
    \ a while loop.\n<code>", "  const counts: {[key: string]: number} = {}\n  for\
    \ (let i = 0; i < test.length; i++) {\n    const letter = test[i]\n    const count\
    \ = counts[letter]\n    if (!count) {\n      counts[letter] = 1\n      continue\n\
    \    }\n    counts[letter] = count + 1\n  }\n  return counts\n}\n", "    const\
    \ splitTest = test.toLowerCase().split(' ');\n    const hist = {};\n    for (let\
    \ i = 0; i < splitTest.length; i++) {\n        const letter = splitTest[i];\n\
    \        if (hist[letter] == undefined) {\n            hist[letter] = 1;\n   \
    \     } else {\n            hist[letter] += 1;\n        }\n    }\n    return hist;\n\
    }\n", "  let ret: Array<{[key: string]: number}> = [];\n  for (let i = 0; i <\
    \ test.length; i++) {\n    let currLetter = test[i];\n    let currCount = 0;\n\
    \    for (let j = 0; j < ret.length; j++) {\n      if (ret[j].hasOwnProperty(currLetter))\
    \ {\n        ret[j][currLetter]++;\n        currCount++;\n      } else {\n   \
    \     ret[j][currLetter] = 1;\n      }\n    }\n    if (ret.length === 0) {\n \
    \     ret.push({[currLetter]: 1, _: currCount});\n    } else if (ret.length ===\
    \ 1) {\n      ret.push({[currLetter]: currCount, _: currCount});\n    } else {\n\
    \      let maxCount = 0;\n      for (let j = 0; j < ret.length; j++) {\n     \
    \   if (ret[j].hasOwnProperty(currLetter)) {\n          maxCount = Math.max(ret[j][currLetter],\
    \ maxCount);\n        }\n      }\n      for (let j = 0; j < ret.length; j++) {\n\
    \        if (ret[j].hasOwnProperty(currLetter)) {\n          ret[j][currLetter]\
    \ /= maxCount;\n        }\n      }\n    }\n  }\n  return ret;\n}\n", "  var histogram:\
    \ { [key: string]: number } = {},\n      maxCount = 0,\n      letter,\n      count;\n\
    \n  if (test) {\n    test.trim().split(' ').forEach(letter => {\n      if (!letter)\
    \ {\n        return;\n      }\n\n      count = (histogram[letter] ? histogram[letter]\
    \ : 0);\n      histogram[letter] = count + 1;\n      if (count > maxCount) {\n\
    \        maxCount = count;\n      }\n    });\n  }\n  return histogram;\n}\n",
  "    let result: any = {};\n    let tokens = test.split(\" \");\n    tokens.forEach((token:\
    \ string) => {\n        let [letter, count] = result[token] || [0, token.length];\n\
    \        result[token] = count + 1;\n    });\n    return result;\n}\n", "  const\
    \ letters: {[key: string]: number} = {};\n  for (const ch of test) {\n    const\
    \ occurrence = letters[ch] || 0;\n    letters[ch] = occurrence + 1;\n  }\n  return\
    \ letters;\n}\n", "    if (!test) return {}\n    var histogram: any = {},\n  \
    \      letter: string = \"\";\n    for (let i = 0; i < test.length; i++) {\n \
    \       letter = test.charAt(i)\n        if (letter in histogram) {\n        \
    \    histogram[letter] += 1;\n        } else {\n            histogram[letter]\
    \ = 1;\n        }\n    }\n    return histogram;\n}\n", "  let histogram: {[key:\
    \ string]: number} = {};\n\n  for (let i = 0; i < test.length; i++) {\n    let\
    \ letter = test.charAt(i);\n    histogram[letter] = histogram[letter] ? histogram[letter]\
    \ + 1 : 1;\n  }\n\n  return histogram;\n}\n", "  // Count the occurrences of each\
    \ letter\n  let counter: number[] = [];\n  for (let i = 0; i < test.length; i++)\
    \ {\n    counter[test[i]] = (counter[test[i]] || 0) + 1;\n  }\n\n  // Return an\
    \ object with the letter with the highest occurrence\n  let max: any = counter.sort((a,\
    \ b) => b - a)[0];\n  let obj: {[key: string]: number} = {};\n  for (let i = 0;\
    \ i < counter.length; i++) {\n    obj[max] = counter[i];\n  }\n  return obj;\n\
    }\n", "  const counter: Array<{[key: string]: number}> = [];\n  for (let i = 0;\
    \ i < test.length; i++) {\n    if (counter.indexOf(test[i]) === -1) counter.push({[test[i]]:\
    \ 1}); else counter[test[i]]++;\n  }\n  return counter.reduce((acc: {[key: string]:\
    \ number}, cur: {[key: string]: number}) => {\n    for (let k in cur) {\n    \
    \  if (cur[k] > acc[k]) acc[k] = cur[k];\n    }\n    return acc;\n  }, {});\n\
    }\n", "    const lettersCount: {[key: string]: number} = {};\n    test.split(\"\
    \").forEach((letter: string) => {\n        const letterCount = lettersCount[letter]\
    \ ?? 0;\n        lettersCount[letter] = letterCount + 1;\n    });\n    return\
    \ lettersCount;\n}\n", "    if (test.length <= 1) {\n        return {};\n    }\n\
    \    const lettersCount: Map<string, number> = new Map();\n    for (let i = 0;\
    \ i < test.length; i++) {\n        const char = test[i];\n        const count\
    \ = lettersCount.get(char) || 0;\n        lettersCount.set(char, count + 1);\n\
    \    }\n    const maxCount = Math.max(...lettersCount.values());\n    return Array.from(lettersCount.entries())\n\
    \        .filter(([key, value]) => value === maxCount)\n        .sort(([_, a],\
    \ [__, b]) => a - b)\n        .reduce((acc, [char, count]) => { acc[char] = count;\
    \ return acc; }, {});\n}\n", "\tconst testString = test.trim();\n\tconst countMap:\
    \ {[key: string]: number} = {};\n\n\tfor (let i = 0; i < testString.length; i++)\
    \ {\n\t\tconst letter = testString[i].toLowerCase();\n\t\tif (!countMap[letter])\
    \ countMap[letter] = 0;\n\t\tcountMap[letter]++;\n\t}\n\n\treturn countMap;\n\
    }\n", "  let obj = {};\n  for (let i = 0; i < test.length; i++) {\n    let item\
    \ = test.charAt(i);\n    let index = obj[item];\n    if (index === undefined)\
    \ {\n      obj[item] = 1;\n    } else {\n      obj[item] = index + 1;\n    }\n\
    \  }\n  return obj;\n}\n", "  const map: Record<string, number> = {};\n  for (const\
    \ c of test.split(\" \")) {\n    if (map[c] == null) { map[c] = 0; }\n    map[c]++;\n\
    \  }\n  return map;\n}\n", "  const histogram: any = {};\n  const letters = test.split('\
    \ ');\n  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i].toLowerCase();\n\
    \    if (histogram[letter]) {\n      histogram[letter]++;\n    } else {\n    \
    \  histogram[letter] = 1;\n    }\n  }\n  return histogram;\n}\n", "  const histogram:\
    \ {[key: string]: number} = {};\n  const array = test.split(\" \");\n\n  array.forEach((val)\
    \ => {\n    const lowerVal = val.toLowerCase();\n    const occurrencesCount =\
    \ histogram[lowerVal] || 0;\n    histogram[lowerVal] = occurrencesCount + 1;\n\
    \  });\n\n  return histogram;\n}\n", "  const dict: { [key: string]: number }\
    \ = {};\n  const words = test.split(\" \");\n  words.forEach((word) => {\n   \
    \ dict[word] = dict[word] || 0;\n    dict[word]++;\n  });\n  return dict;\n}\n",
  "  const letters: {[key: string]: number} = {};\n  for (const letter of test.toLowerCase().split(\"\
    \ \")) {\n    letters[letter] = (letters[letter] || 0) + 1;\n  }\n  return letters;\n\
    }\n", "  if (test) {\n    let counts: number[] = [];\n    let charMap: {[key:\
    \ string]: number} = {};\n    for (let i = 0; i < test.length; i++) {\n      let\
    \ char = test[i];\n      let count = charMap[char] || 0;\n      counts[count]\
    \ = 1;\n      charMap[char] = count + 1;\n    }\n    return charMap;\n  }\n  return\
    \ {};\n}\n", "    const result: any = {};\n\n    test.split(' ').forEach((element:\
    \ string) => {\n        result[element] = (result[element] || 0) + 1;\n    });\n\
    \n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nI believe this should be\
    \ the accepted answer. Nice and short and efficient!\n<|/ c |>\n<| a |>\nHere's\
    \ a slightly modified version of Damian's solution:\n<code>", "  let count: {[key:\
    \ string]: number} = {};\n  let max: number;\n  let lastValue = \"\";\n  for (let\
    \ i = 0; i < test.length; i++) {\n    let value = test[i];\n    let prev = test[i\
    \ - 1];\n    if (lastValue !== value) {\n      count[value] = 1;\n      max =\
    \ Math.max(max, count);\n      lastValue = value;\n    } else {\n      count[value]\
    \ = (count[value] || 0) + 1;\n    }\n  }\n  return max\n    ? {\n        ...count,\n\
    \        [max]: (count[max] || 0),\n      }\n    : {};\n}\n", "  if (test) {\n\
    \    let histogram: any = {};\n    for (let char of test.toLowerCase()) {\n  \
    \    let letter = char;\n      let count = histogram[letter];\n      if (count)\
    \ {\n        histogram[letter] += 1;\n      } else {\n        histogram[letter]\
    \ = 1;\n      }\n    }\n    return histogram;\n  } else {\n    return {};\n  }\n\
    }\n", "  let histo: any = {};\n  for (let i = 0; i < test.length; i++) {\n   \
    \ let c = histo[test[i]] || 0;\n    histo[test[i]] = c + 1;\n  }\n  return histo;\n\
    }\n", "  let letters: string[] = test.split(\" \");\n\n  //create an object with\
    \ empty values\n  let histogram: {[key: string]: number} = {};\n\n  //Go through\
    \ all the letters\n  letters.forEach(letter => {\n    //Check if the letter has\
    \ already been counted\n    if (histogram.hasOwnProperty(letter)) {\n      histogram[letter]++;\n\
    \    } else {\n      histogram[letter] = 1;\n    }\n  });\n\n  //Return the letter\
    \ with the highest occurrence and the number of occurrences\n  let maxCountLetter:\
    \ keyof typeof histogram = undefined;\n  let maxCount: number = undefined;\n \
    \ for (let key in histogram) {\n    if (histogram[key] > maxCount) {\n      maxCountLetter\
    \ = key;\n      maxCount = histogram[key];\n    }\n  }\n  return histogram;\n\
    }\n</code>\nThis code does use type casting which I would recommend not using\
    \ in this case. This code also uses typescript and therefore uses type assertions\
    \ and object destructuring which are both not recommended in most cases but are\
    \ useful in situations such as this.\n<|/ a tags=string,javascript |>\n<| c |>\n\
    This solution returns incorrect results for non-unique letters. Try it with `histogram(\"\
    a b b c d e f\")` where `a` and `b` have multiple occurances but `d` and `e` only\
    \ have one occurance.\n<|/ c |>\n<| c |>\ngood point, i will fix that and edit\
    \ the answer\n<|/ c |>\n<| c |>\nI updated my answer to use an object map instead\
    \ of an array to store the letter counts. It is much faster and more efficient\n\
    <|/ c |>\n<| a |>\nA solution using reduce:\n\n<code>\nconst histogram = s =>\
    \ {\n  const letters = s.split('');\n  const result = letters.reduce((acc, letter,\
    \ ind) => {\n    acc[letter] = (acc[letter] || 0) + 1;\n    \n    if (ind ===\
    \ letters.length - 1) {\n      const maxOccurance = Object.keys(acc).reduce((max,\
    \ k) => {\n        return acc[k] > max ? acc[k] : max;\n      }, 0);\n      \n\
    \      if (maxOccurance > 0) {\n        return acc[maxOccurance];\n      }\n \
    \   }\n    \n    return acc;\n  }, {});\n  return result;\n}\n\nconsole.log(histogram('a\
    \ b c a b b'));\nconsole.log(histogram('a b c a b b'));\nconsole.log(histogram('a\
    \ b c a b b'));</code>\n<|/ a dscore=2 tags=string,javascript |>\n<| a dscore=2\
    \ |>\n<code>\nlet str = \"a b c a b b\";\nlet arrStr = str.split('');\nlet obj\
    \ = {};\narrStr.", "  let result = {};\n  for (let char of test.toUpperCase().split(\"\
    \ \"))\n    result[char] = result[char] || 0;\n  let maxCount = 0;\n  for (let\
    \ char in result)\n    maxCount = Math.max(maxCount, result[char]);\n  for (let\
    \ char in result) {\n    result[char] /= maxCount;\n  }\n  return result;\n}\n",
  "    const counts: Record<string, number> = {};\n    let currentCount = 0;\n   \
    \ let lastLetter = test[0];\n    for (let i = 1; i < test.length; i++) {\n   \
    \     const letter = test[i];\n        const currentOccurrence = counts[letter];\n\
    \        if (currentOccurrence === undefined) {\n            counts[letter] =\
    \ 1;\n        }\n        else {\n            counts[letter] = currentOccurrence\
    \ + 1;\n        }\n        if (letter === lastLetter) {\n            currentCount++;\n\
    \        }\n        else {\n            lastLetter = letter;\n            currentCount\
    \ = 1;\n        }\n    }\n    return counts;\n}", "  const histogram: {[key: string]:\
    \ number} = {}\n  const chars = test.split(\" \")\n  for (let i = 0; i < chars.length;\
    \ i++) {\n    const char = chars[i]\n    if (!histogram[char]) histogram[char]\
    \ = 0\n    histogram[char] += 1\n  }\n  return histogram\n}\n", "    const histogram:\
    \ any = {};\n    test\n        .trim()\n        .split(' ')\n        .forEach(w\
    \ => {\n            const letter = w.toLowerCase();\n            if (!histogram[letter])\
    \ {\n                histogram[letter] = 0;\n            }\n            histogram[letter]\
    \ += 1;\n        });\n    return histogram;\n}\n", "  const counts: any = {};\n\
    \  const maxValue: number = test\n    .split(\"\")\n    .reduce((previousValue,\
    \ currentValue) => previousValue + currentValue, 0);\n  return test.split(\"\"\
    )\n    .map(letterToString => {\n      const letter = letterToString;\n      const\
    \ count = counts[letter] ?? 0;\n      counts[letter] = count + 1;\n      return\
    \ {\n        letter: letter,\n        count: counts[letter],\n        maxValue,\n\
    \      };\n    })\n    .reduce((previousValue, currentValue) => {\n      if (previousValue.count\
    \ === currentValue.count && previousValue.letter === currentValue.letter) {\n\
    \        previousValue.maxValue < currentValue.maxValue ?\n          previousValue.maxValue\
    \ = currentValue.maxValue :\n          previousValue.letter = currentValue.letter;\n\
    \      }\n      return previousValue;\n    });\n}\n", "    var charMap: Record<string,\
    \ number> = {};\n    test.split(\"\").forEach((c) => {\n        if (!charMap[c])\
    \ charMap[c] = 0;\n        charMap[c]++;\n    });\n    return charMap;\n}\n",
  "  const counts: Record<string, number> = {};\n\n  for (const char of test.toLowerCase())\
    \ {\n    if (counts[char]) {\n      counts[char]++;\n    } else {\n      counts[char]\
    \ = 1;\n    }\n  }\n\n  return counts;\n}\n", "  const histogram: {[key: string]:\
    \ number} = {};\n  for (let i = 0; i < test.length; i++) {\n    const letter =\
    \ test.charAt(i);\n    if (histogram.hasOwnProperty(letter)) {\n      histogram[letter]\
    \ += 1;\n    } else {\n      histogram[letter] = 1;\n    }\n  }\n  return histogram;\n\
    }\n", "  const histogram: {[key: string]: number} = {};\n\n  for (const item of\
    \ test.split(\" \")) {\n    let count = histogram[item];\n\n    if (count ===\
    \ undefined) {\n      count = 0;\n    }\n\n    histogram[item] = count + 1;\n\
    \  }\n\n  return histogram;\n}\n", "    let histogram: {[key: string]: number}\
    \ = {};\n    let letter: string;\n    let count = 0;\n\n    for (let i = 0; i\
    \ < test.length; i++) {\n        letter = test.charAt(i);\n        histogram[letter]\
    \ = ++count;\n    }\n\n    return histogram;\n}\n", "  const map: {[key: string]:\
    \ number} = {};\n  test.split(\" \").forEach((letter: string) => {\n    const\
    \ letterCount = map[letter] || 0;\n    map[letter] = letterCount + 1;\n  });\n\
    \  return map;\n}\n", "  test = test.replace(/\\s+/g, ' ').toLowerCase();\n  const\
    \ countObj: { [key: string]: number; } = {};\n\n  for (const ch of test) {\n \
    \   const count = (countObj[ch] || 0) + 1;\n    countObj[ch] = count;\n  }\n\n\
    \  return countObj;\n}\n", "  if (test) {\n    const testSplit = test.split('\
    \ ');\n    const counts = testSplit.reduce(\n      (cnt, word) => word.split('').reduce((acc,\
    \ curr) => acc + curr, cnt),\n      0\n    );\n    return counts;\n  }\n  return\
    \ {};\n}\n", "  const histogram: {[key: string]: number} = {};\n  const spaceSeparatedLetters:\
    \ string[] = test.split(\" \");\n  spaceSeparatedLetters.forEach((letter: string,\
    \ i: number) => {\n    histogram[letter] = i;\n  });\n  return histogram;\n}\n",
  "  if (!test) {\n    return {};\n  }\n  let result: any = {};\n  let splitted: string[]\
    \ = test.split(' ');\n  for (let i = 0; i < splitted.length; i++) {\n    let letter:\
    \ string = splitted[i];\n    if (result[letter]) {\n      result[letter]++;\n\
    \    } else {\n      result[letter] = 1;\n    }\n  }\n  return result;\n}\n",
  "  const letters: string[] = [];\n  const letterCount: {[key: string]: number} =\
    \ {};\n  for (const letter of test.split(\" \")) {\n    let currentLetterCount\
    \ = letterCount[letter];\n    if (!currentLetterCount) {\n      letterCount[letter]\
    \ = 1;\n    } else {\n      letterCount[letter] = currentLetterCount + 1;\n  \
    \  }\n    letters.push(letter);\n  }\n\n  // Sort letters in alphabetical order.\n\
    \  letters.sort();\n\n  // Calculate the maximum of each letter.\n  const maximums:\
    \ {[key: string]: number} = {};\n  for (const letter of letters) {\n    const\
    \ count = letterCount[letter];\n    if (count > maximums[letter]) {\n      maximums[letter]\
    \ = count;\n    }\n  }\n\n  // Now each letter has its maximum occurrence. We\
    \ can just go through\n  // the letters and find the letters whose occurrence\
    \ is equal to the\n  // maximum occurrence.\n  const histogram: {[key: string]:\
    \ number} = {};\n  for (const letter of letters) {\n    const count = letterCount[letter];\n\
    \    if (count === maximums[letter]) {\n      histogram[letter] = count;\n   \
    \ }\n  }\n\n  return histogram;\n}\n", "  const histogram: any = {};\n  test.split('\
    \ ').forEach((letter: string) => {\n    if (histogram[letter]) {\n      histogram[letter]++;\n\
    \    }\n  });\n  return histogram;\n}\n</code>\n<|/ a tags=typescript,ecmascript-6,javascript\
    \ |>\n<| c |>\nCan you please explain what is the purpose of the below line:\n\
    \    export const getMax = (obj) => {\n        const keys = Object.keys(obj);\n\
    \        let maxValue = keys.length;\n        let maxKey = \"\";\n\n        for\
    \ (let key of keys) {\n            if (obj[key] > maxValue) {\n              \
    \  maxValue = obj[key];\n                maxKey = key;\n            }\n      \
    \  }\n        return maxKey;\n    };\n<|/ c |>\n<| a dscore=4 |>\nYou could use\
    \ an ES6 Map and get the values by Object.values() or Object.keys().\n<code>\n\
    let myMap = new Map();\n\nlet myObj = {\n    a: '1',\n    b: '1',\n    c: '1',\n\
    \    d: '1',\n    e: '1'\n}\n\nfor(let k in myObj){\n    if(myObj.hasOwnProperty(k)){\n\
    \        myMap.set(myObj[k], myMap.get(myObj[k]) || 0);\n        myMap.set(k,\
    \ myMap.get(k) + 1);\n    }\n}\nconsole.log(myMap);\n</code>\n<|/ a tags=typescript,ecmascript-6,javascript\
    \ |>\n<| a dscore=2 |>\nYou can use this code for getting the count of any key\
    \ or value from Object:\n<code>\nlet myObj = {\n    a: '1',\n    b: '1',\n   \
    \ c: '1',\n    d: '1',\n    e: '1'\n};\n\nvar keys = Object.keys(myObj);\nvar\
    \ values = Object.values(myObj);\nconsole.log(keys, values); //keys are ['a',1,'b','1',c','1',d','1',e']\
    \ ,values are ['1',1,'1',1,'1',1,'1']\n\nvar maxValue = Math.max(...values);\n\
    console.log(maxValue); //maxValue is 1\n</code>\n<|/ a tags=typescript,ecmascript-6,javascript\
    \ |>\n<| a tags=typescript,ecmascript-6,javascript |>\n<code>\nlet myObj = {\n\
    \    a: '1',\n    b: '1',\n    c: '1',\n    d: '1',\n    e: '1'\n}\n\nlet myMap\
    \ = new Map();\nfor(let k in myObj){\n    if(myObj.hasOwnProperty(k)){\n     \
    \   myMap.set(myObj[k], myMap.get(myObj[k]) || 0);\n        myMap.set(k, myMap.get(k)\
    \ + 1);\n    }\n}\nconsole.log(myMap);\n</code>\n<|/ a dscore=2 ", "  const histogram:\
    \ any = {};\n  const letters = test.split(/\\s+/);\n  for (const letter of letters)\
    \ {\n    const count = (histogram[letter] ?? 0) + 1;\n    histogram[letter] =\
    \ count;\n  }\n  return histogram;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
