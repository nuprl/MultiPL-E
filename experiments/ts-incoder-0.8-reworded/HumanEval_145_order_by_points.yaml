name: HumanEval_145_order_by_points
language: ts
prompt: "//Write a function which sorts the given array of integers\n// in ascending\
  \ order according to the sum of their digits.\n// Note: if there are several items\
  \ with similar sum of their digits,\n// order them based on their index in original\
  \ array.\n// For example:\n// >>> order_by_points([1, 11, -1, -11, -12])\n// [-1,\
  \ -11, 1, -12, 11]\n// >>> order_by_points([])\n// []\nfunction order_by_points(nums:\
  \ number[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = order_by_points;\n  assert.deepEqual(candidate([1,\
  \ 11, -1, -11, -12]),[-1, -11, 1, -12, 11]);\n  assert.deepEqual(candidate([1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n  assert.deepEqual(candidate([]),[]);\n\
  \  assert.deepEqual(candidate([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98,\
  \ -11, 1, 2, 43, 54]);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9,\
  \ 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n  assert.deepEqual(candidate([0,\
  \ 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6]);\n}\n\ntest();"
completions: ["  const order = [0, 0, 0, 0];\n  for (let i = 0; i < nums.length; ++i)\
    \ {\n    const num = nums[i];\n    for (let j = i + 1; j < nums.length; ++j) {\n\
    \      const sum = Math.round(num + nums[j]);\n      if (sum == num) {\n     \
    \   order[j] = i + 1;\n        break;\n      }\n      if (sum < num) {\n     \
    \   order[i] = nums[j];\n        break;\n      }\n      if (sum > num) {\n   \
    \     order[j] = nums[i];\n        break;\n      }\n    }\n  }\n  return order.map((i)\
    \ => nums[i]);\n}\n", "  let ret = [];\n  nums.forEach(item => {\n    const sum\
    \ = item.toString().split('').map(a => +a).reduce((a, b) => a + b);\n    if (ret.find(e\
    \ => e === sum)) {\n      ret.splice(ret.indexOf(sum), 0, item);\n    } else {\n\
    \      ret.push(item);\n    }\n  });\n  return ret;\n}\n", "  const len = nums.length;\n\
    \  const ret = new Array(len);\n  for (let i = 0; i < len; i++) {\n    ret[i]\
    \ = i;\n  }\n  ret.sort((a, b) => {\n    let res = 0;\n    for (let i = 0; i <\
    \ len; ++i) {\n      const digit = nums[a][i] + nums[b][i];\n      res += digit;\n\
    \    }\n    return res;\n  });\n  return ret.map((i) => nums[i]);\n}\n", "  for\
    \ (let i = 0; i < nums.length; ++i) {\n    const n = nums[i];\n    if (n !== -1\
    \ && nums.every((x, i) => {\n      if (x === -1) {\n        return false; // break\n\
    \      }\n      if (i !== i && nums[i] !== n) {\n        return false;\n     \
    \ }\n      return true;\n    })) {\n      nums[i] = n;\n    }\n  }\n  nums.sort(function(a,\
    \ b) {\n    if (a === -1) {\n      return -1;\n    } else if (b === -1) {\n  \
    \    return 1;\n    } else if (a > b) {\n      return 1;\n    } else if (a < b)\
    \ {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return nums;\n\
    }", "  return nums.sort((a, b) => {\n    let num1 = Math.abs(a);\n    let num2\
    \ = Math.abs(b);\n    let sum1 = num1.toString().split('').reduce((acc, val) =>\
    \ acc + +val, 0);\n    let sum2 = num2.toString().split('').reduce((acc, val)\
    \ => acc + +val, 0);\n    return sum1 - sum2;\n  });\n}\n", "  const copy = nums.slice();\n\
    \  copy.sort((a, b) => {\n    const aPoint = digitSum(a);\n    const bPoint =\
    \ digitSum(b);\n    return aPoint - bPoint;\n  });\n  return copy;\n}\n", "  \
    \  // Sort an array of numbers by their sum of digits.\n    // If there are several\
    \ items with the same sum of digits,\n    // order them based on their index in\
    \ original array.\n    return nums.sort((a, b) => sum_digits(a) - sum_digits(b));\n\
    }\n", "    return nums.sort((a: number, b: number) => {\n        if (a < b) return\
    \ -1;\n        if (a > b) return 1;\n        return 0;\n    });\n}\n</code>\n\
    I believe that is the most readable and concise way I can think to sort the numbers\
    \ without using lambdas or loops.\n<|/ a tags=sorting,arrays,javascript,typescript\
    \ dscore=4 |>\n<| c |>\nThis is the best answer. Even though you accepted a different\
    \ answer, this one is the correct and simplest one.\n<|/ c |>\n<| a dscore=2 tags=sorting,arrays,javascript,typescript\
    \ |>\nYou can use the Array.sort((a,b) => a.localeCompare(b)) method\nThe method\
    \ will return a -1, 0, 1 value, so you can use this to sort your array.\n<|/ a\
    \ |>\n<| c |>\nThis solution sorts the input array in-place, which is probably\
    \ not what the OP wants. You also don't provide a way to access the items as they're\
    \ being sorted.\n<|/ c |>\n<| a tags=sorting,arrays,javascript,typescript |>\n\
    <code>\nconst arr = [4, 6, 8, 5];\nconst sorted = arr.sort((a, b) => {\n    const\
    \ numberA = parseInt(a);\n    const numberB = parseInt(b);\n    if (numberA >\
    \ numberB) {\n        return 1;\n    } else if (numberA < numberB) {\n       \
    \ return -1;\n    } else {\n        return 0;\n    }\n});\nconsole.log(sorted);</code>\n\
    \nA simple solution for sorting an array of integers\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis solution sorts the input array in-place, which is probably not what\
    \ the OP wants. You also don't provide a way to access the items as they're being\
    \ sorted.\n<|/ c |>\n<| c |>\nYou're right, I made a mistake (thought it was a\
    \ one-liner). I edited the answer to fix this (now `sorted` has your sorted array).\n\
    <|/ c |>\n<| a tags=sorting,arrays,javascript,typescript |>\nThe shortest solution\
    \ is to use the array's sort method with custom sort function.\n<code>\nlet a\
    \ = [4,6,8,5];\na.sort((a, b) => a - b);\nconsole.log(a); //[5,6,8,4]\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis solution sorts the input array in-place, which\
    \ is probably not what the OP wants. You also don't provide a way to access the\
    \ items as they're being sorted.\n<|/ c |>\n<| c |>\nYou are right, I made a mistake.\
    \ I edited the answer to fix ", "  let sorted = nums.slice();\n  sorted.sort((a,\
    \ b) => {\n    let x = a + b,\n      y = a + 100000000 * b,\n      z = a + 1000000\
    \ * 100 * b;\n    return x - y > 0 ? x - y : z - x;\n  });\n  return sorted;\n\
    }\n", "  const ns = nums.slice(0);\n  ns.sort((a: number, b: number) => { return\
    \ a + b; });\n  return ns;\n}\n", "\tconst sorted = nums.slice();\n\tsort.call(sort,\
    \ function(a, b) {\n\t\treturn sum_to_string(a, b);\n\t});\n\treturn sorted;\n\
    }\n", "    if (nums.length === 0) {\n        return nums;\n    }\n\n    let ret:\
    \ number[] = nums;\n    let temp: number[] = nums;\n\n    for(let i = ret.length\
    \ - 1; i >= 0; i--) {\n        let last = ret[i];\n\n        for(let j = i; j\
    \ < ret.length; j++) {\n            let item = ret[j];\n\n            if (item\
    \ === 0 && last > 0) ret[j - 1] = last;\n\n            if (item === 0 && last\
    \ < 0) ret[j - 1] = -last;\n\n            if (item + last === 10) ret[j] = last;\n\
    \n            if (item < last + last) ret[j - 1] = item;\n        }\n    }\n\n\
    \    return ret;\n}\n", "  const sorted_nums = nums.slice();\n  sorted_nums.sort((a,\
    \ b) => b - a);\n  for (let i = 0; i < sorted_nums.length; ++i) {\n    for (let\
    \ j = i + 1; j < sorted_nums.length; ++j) {\n      if (sorted_nums[i] > sorted_nums[j])\
    \ {\n        const t = sorted_nums[i];\n        sorted_nums[i] = sorted_nums[j];\n\
    \        sorted_nums[j] = t;\n      }\n    }\n  }\n  return sorted_nums;\n}\n",
  "  const sorted_nums = nums.sort((a, b) => a - b);\n  return sorted_nums.reduce((sorted_nums,\
    \ num) => {\n    const sumOfDigits = sorted_nums.reduce((sumOfDigits, sorted_num)\
    \ => {\n      const currentDigit = Math.trunc(num / sorted_num);\n      sumOfDigits\
    \ += currentDigit;\n      return sumOfDigits;\n    }, 0);\n    sorted_nums.push((sumOfDigits\
    \ - num) % 10);\n    return sorted_nums;\n  }, []);\n}\n", "  const arr: number[]\
    \ = [];\n  nums.forEach((num: number) => {\n    const digits = String(num).split('');\n\
    \    arr.push(...digits);\n  });\n\n  const arr2 = arr.sort();\n  let res: number[]\
    \ = [];\n  arr2.forEach((num, index) => {\n    if (index !== 0) {\n      res.push(arr[index]);\n\
    \    }\n  });\n  return res;\n}\n", "  let sorted = nums.slice();\n  sorted.sort((a,\
    \ b) => {\n    let aStr = a.toString();\n    let bStr = b.toString();\n    let\
    \ aSum = 0;\n    let bSum = 0;\n\n    while (aStr.length > 0) {\n      aSum =\
    \ aSum * 10 + (aStr.charAt(0) - '0');\n      aStr = aStr.substr(1);\n    }\n \
    \   while (bStr.length > 0) {\n      bSum = bSum * 10 + (bStr.charAt(0) - '0');\n\
    \      bStr = bStr.substr(1);\n    }\n    if (aSum < bSum) {\n      return 1;\n\
    \    } else if (aSum > bSum) {\n      return -1;\n    } else {\n      return 0;\n\
    \    }\n  });\n  return sorted;\n}\n</code>\n<|/ a |>\n<| c |>\nWhy does this\
    \ answer the question?\n<|/ c |>\n<| c |>\nI see that now. Sorry for the misunderstanding.\n\
    <|/ c |>\n<| a |>\nHere is an iterative approach which should be fast.\nIt will\
    \ sort the array in ascending order. But it also keeps the original order of the\
    \ original array if that matters.\n\n<code>", "  const sorted_nums: number[] =\
    \ [];\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n \
    \   const sum_of_digits = nums.reduce((acc, val) => acc + digit(val), 0);\n  \
    \  const index = sorted_nums.findIndex(num => sum_of_digits === num);\n    if\
    \ (index > -1) {\n      sorted_nums[index] = num;\n    } else {\n      sorted_nums.push(num);\n\
    \    }\n  }\n  return sorted_nums;\n}\n", "  if (nums.length <= 0) {\n    return\
    \ nums;\n  }\n  const sum_digit = nums.reduce((prev: number, curr: number) =>\
    \ prev + curr, 0);\n  let index = nums.length;\n  const sorted: number[] = [];\n\
    \  while (index--) {\n    const num = nums[index];\n    if (sum_digit - num >=\
    \ 0) {\n      sorted.push(num);\n    } else {\n      sorted.unshift(num);\n  \
    \  }\n  }\n  return sorted;\n}\n", "  const len = nums.length;\n  if (len < 2)\
    \ {\n    return nums;\n  }\n  const max = nums[0];\n  const max_so_far = max_so_far(max);\n\
    \  let min_so_far = min_so_far(max);\n  let max_index = 0;\n  let min_index =\
    \ 0;\n  for (let i = 1; i < len; i++) {\n    const sum = sum_recursive(nums[i]);\n\
    \    if (sum < max_so_far) {\n      max_so_far = sum;\n      max_index = i;\n\
    \    }\n    if (sum > min_so_far) {\n      min_so_far = sum;\n      min_index\
    \ = i;\n    }\n  }\n  return [nums[max_index], nums[min_index]];\n}\n", "  const\
    \ map = new Map();\n  nums.forEach((n, i) => {\n    const sum = sumOfDigits(n);\n\
    \    map.set(sum, n);\n  });\n  return Array.from(map.values())\n    .sort((a,\
    \ b) => sumOfDigits(b) - sumOfDigits(a))\n    .map(n => map.get(n));\n}\n", " \
    \ if (!nums.length) return [];\n\n  // We use an object instead of an array, to\
    \ save a memory allocation\n  const points: { [key: number]: number } = {};\n\
    \  let max_sum = -Infinity;\n  let result: number[] = [];\n\n  for (let i = 0;\
    \ i < nums.length; i++) {\n    const num = nums[i];\n    const digits = String(num).split(\"\
    \");\n    for (let j = digits.length - 1; j >= 0; j--) {\n      const d = parseInt(digits[j],\
    \ 10);\n      if (points[d] !== undefined) {\n        points[d] += num;\n    \
    \  } else {\n        points[d] = num;\n      }\n\n      // Find the max sum and\
    \ store it as the new max sum\n      if (points[d] > max_sum) {\n        max_sum\
    \ = points[d];\n      }\n    }\n  }\n\n  // Build a result array from the object\
    \ of numbers\n  Object.keys(points).forEach(key => {\n    result.push(points[key]);\n\
    \  });\n\n  // Sort the result array based on the max_sum\n  return result.sort((a,\
    \ b) => {\n    return b - a;\n  });\n}\n", "  const n = nums.length;\n  if (n\
    \ < 1) return nums;\n  for (let i = 0; i < n; i++) {\n    nums[i].sort_index =\
    \ (nums[i].num.slice(0)).toString().split(',').sort().join(\"\");\n  }\n  return\
    \ nums.sort(function (a, b) { return b.sort_index - a.sort_index; });\n}\n", " \
    \ const len = nums.length;\n  const buckets = [0] * (len + 1);\n  for (let i =\
    \ 0; i < len; i++) {\n    buckets[nums[i]] = i | 0;\n  }\n  const result: number[]\
    \ = [];\n  let max: number = 0;\n  for (let i = 0; i < len; i++) {\n    const\
    \ index = buckets[nums[i]];\n    if (index >= 0) max += index;\n    result.push(nums[index]);\n\
    \  }\n  return result.sort((a, b) => {\n    if (b - a > max) return 1;\n    if\
    \ (b - a < max) return -1;\n    return 0;\n  });\n}\n", "    nums.sort((a, b)\
    \ => sum(b) - sum(a));\n    return nums;\n}\n", "  const sorted = nums.slice().sort((a,\
    \ b) => {\n    const apoint = Math.abs(a) + Math.abs(b);\n    const bpoint = Math.abs(b)\
    \ + Math.abs(a);\n    if (apoint < bpoint) {\n      return 1;\n    }\n    if (apoint\
    \ > bpoint) {\n      return -1;\n    }\n    return 0;\n  });\n  return sorted;\n\
    }\n", "    nums = nums.slice().sort((a, b) => a + b);\n    let result: number[]\
    \ = [];\n    let resultLen = 0;\n    for (let i = 0; i < nums.length; i++) {\n\
    \        const num = nums[i];\n        result[resultLen++] = num;\n        result[resultLen++]\
    \ = nums[nums.indexOf(num)];\n    }\n    return result;\n}\n", "    const map\
    \ = new Map();\n    let result = [];\n    for (let i = 0; i < nums.length; i++)\
    \ {\n        const p = getP(nums[i], map);\n        result.push(p);\n        map.set(p,\
    \ i);\n    }\n    return result.sort((a, b) => b - a);\n}\n", "  const sorted\
    \ = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum +=\
    \ nums[i];\n    sorted.push(sum);\n  }\n  sorted.sort((a, b) => a - b);\n  const\
    \ sorted_nums = nums.map(x => x.sort());\n  for (let i = 0; i < nums.length; i++)\
    \ {\n    sorted_nums[i] = sorted_nums[i].map(x => x.toString());\n  }\n  return\
    \ sorted_nums;\n}\n", "  let new_nums = nums.slice();\n  new_nums.sort((a, b)\
    \ => {\n    let digits = a.toString().split('').map((x, i) => {\n      return\
    \ +x + +nums[i];\n    });\n    return digits[digits.length - 1];\n  });\n  return\
    \ new_nums;\n}\n", "  let n = nums.length;\n  if (n <= 1) return nums;\n  let\
    \ result = [];\n  for (let i = 0; i < n; i++) {\n    let index = sumDigits(nums[i])\
    \ - sumDigits(nums[0]);\n    if (result.length === 0) {\n      result = [nums[i]];\n\
    \    }\n    if (index !== -1 && result.indexOf(nums[index]) < 0) {\n      result.push(nums[index]);\n\
    \    }\n  }\n  return result;\n}\n", "  const copy = nums.slice();\n  copy.sort((a:\
    \ number, b: number) => {\n    const numsA: number = Number(a.toString());\n \
    \   const numsB: number = Number(b.toString());\n    return numsA - numsB;\n \
    \ });\n  return copy;\n}\n", "  const result = [];\n  for (let i = 0; i < nums.length;\
    \ ++i) {\n    const digits = nums[i].toString().split('');\n    for (let j = 0;\
    \ j < digits.length; ++j) {\n      if (digits[j] === undefined) continue;\n  \
    \    result[j] = (result[j] || 0) + digits[j];\n    }\n  }\n  for (let i = 0;\
    \ i < result.length; ++i) {\n    result[i] = (result[i] || 0) - result[i] * Math.pow(10,\
    \ nums.length - i);\n  }\n  return result;\n}", "  return nums.sort( (a, b) =>\
    \ a - b );\n}\n", "  const _sums = nums.map(n => getSum(n));\n  const _min = Math.min(..._sums);\n\
    \  return nums.filter(n => getSum(n) === _min);\n}\n", "  // Write your code here\n\
    \  let sum = 0;\n  for (let n = 0; n < nums.length; n++) {\n    sum += nums[n];\n\
    \  }\n  console.log(sum);\n  for (let i = 0; i < nums.length; i++) {\n    for\
    \ (let j = 0; j < nums.length; j++) {\n      if (sum - nums[j] > sum - nums[i])\
    \ {\n        let temp = nums[i];\n        nums[i] = nums[j];\n        nums[j]\
    \ = temp;\n      }\n    }\n  }\n  return nums;\n}\n", "  let _max = Math.max(...nums);\n\
    \  let _min = Math.min(...nums);\n  if (_max === _min) {\n    return nums;\n \
    \ }\n  let _sum = Math.sum(nums);\n  nums.sort((a: number, b: number) => {\n \
    \   return a < b ? -1 : 1;\n  });\n  if (_sum > 0) {\n    return nums;\n  }\n\
    \  nums.sort((a: number, b: number) => {\n    return b < a;\n  });\n  if (nums[0]\
    \ === 0) {\n    return nums.slice(1);\n  }\n  return nums;\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nNice solution, but i found that `a.localeCompare(b)` does\
    \ a little more than `a < b ? -1 : 1;`, it does a little more than `a < b ? 1\
    \ : -1;`, so i suggest you to change `a < b` to `a.localeCompare(b) === 1`\n<|/\
    \ c |>\n<| c |>\nYeah, the default sort is not good enough for me. I'll edit my\
    \ answer when I've got time to fix that.\n<|/ c |>\n<| c |>\nI believe that `sort`\
    \ already does a little more than `localeCompare`. I believe that `localeCompare`\
    \ will sort according to locales which might be different from browser to browser\
    \ and which might cause problems, e.g. `ar_SA` behave different than `ar_EG`\n\
    <|/ c |>\n<| c |>\n, please give a test case that shows a difference. For example,\
    \ Chrome and Firefox use the same `localeCompare()` function.\n<|/ c |>\n<| c\
    \ |>\nI have test it on Chrome, firefox and Opera and it's working fine for me.\
    \ I've added the test case on the answer\n<|/ c |>\n<| a dscore=3 |>\nYou can\
    \ use localeCompare function to sort your array as shown below\n<code>", "  let\
    \ result: number[] = [];\n  let sorted_nums: number[] = nums.slice(0);\n  sorted_nums.sort(function(a,\
    \ b) {\n    return a + b - sorted_nums.reduce((prev, cur) => prev + cur, 0);\n\
    \  });\n  for (let i = 0; i < sorted_nums.length; i++) {\n    result.push(sorted_nums[i]);\n\
    \  }\n  return result;\n}\n", "  const copy = nums.slice()\n  for (let i = 0;\
    \ i < nums.length; i += 1) {\n    const num = copy[i]\n    copy.splice(i, 1)\n\
    \    const digits = num.toString().split(\"\")\n    const sum = (digits[digits.length\
    \ - 1] || \"\").length\n    for (const j = i - 1; j >= 0; j -= 1) {\n      if\
    \ (digits[j] === digits[digits.length - 1]) {\n        digits[j] = null\n    \
    \  }\n    }\n    copy.splice(i, 0, new Array(sum).join(digits[0]))\n  }\n  return\
    \ copy\n}\n", "  const copy = nums.slice();\n  copy.sort((a: number, b: number)\
    \ => {\n    const aDigit = Math.abs(a).toString().length - 1;\n    const bDigit\
    \ = Math.abs(b).toString().length - 1;\n    return bDigit - aDigit;\n  });\n \
    \ return copy;\n}\n", "  return nums.sort((a, b) => a + b).sort((a, b) => a -\
    \ b);\n}\n", "  nums.sort(function(a, b) {\n    return a.sum - b.sum || a.index\
    \ - b.index;\n  });\n  return nums;\n}\n", "    return nums.sort((a: number, b:\
    \ number) => {\n        const sum = a.getTime() + b.getTime();\n        if (sum\
    \ === 0) {\n            return 0;\n        }\n        return sum > 0 ? 1 : -1;\n\
    \    });\n}\n", "  const set: Set<number> = new Set();\n  for (const n of nums)\
    \ {\n    set.add(n);\n  }\n  const arr = [...set];\n  const len = arr.length;\n\
    \  arr.sort((a, b) => sum(a) - sum(b));\n  arr.sort((a, b) => a - b);\n  for (let\
    \ i = 0; i < len; i++) {\n    nums[arr.indexOf(arr[i])] = arr[i];\n  }\n  return\
    \ nums;\n}\n", "  const sums = nums.map((num) => parseInt(num, 10));\n  const\
    \ indexes = sums.map((sum) => sums.indexOf(sum));\n  return indexes.sort((a, b)\
    \ => a - b).map((i) => nums[i]);\n}\n", "\tconst sums = nums.map(n => n.toString().split('').reduce((acc,\
    \ n) => acc + Number(n), 0));\n\tconst order = [];\n\tsums.forEach(sum => order.push(nums.findIndex(v\
    \ => v.toString().split('').reduce((acc, n) => acc + Number(n), 0) === sum)));\n\
    \treturn order.length === 0 ? nums : nums.map(v => nums[order[0]]);\n}\n", " \
    \ // sort by digit\n  const sd = nums.map((x) => x.toString().split('').reduce((acc,\
    \ x) => acc + +x, 0));\n  return sd.sort((a, b) => a - b).map(i => nums.indexOf(i));\n\
    }\n", "    nums = nums.slice();\n    nums.sort(function(i, j){ \n        return\
    \ (i + j); \n    });\n    return nums;\n}\n", "  if (nums.length > 1) {\n    const\
    \ points = [];\n    let minIndex = 0;\n    let maxIndex = nums.length - 1;\n\n\
    \    while (minIndex <= maxIndex) {\n      const sum = nums[minIndex] + nums[maxIndex];\n\
    \n      if (sum === 0) {\n        points.push([nums[minIndex], nums[maxIndex]]);\n\
    \        minIndex += 1;\n        maxIndex -= 1;\n      } else if (sum < 0) {\n\
    \        minIndex += 1;\n      } else {\n        maxIndex -= 1;\n      }\n   \
    \ }\n    points.sort((a, b) => a[0] - b[0]);\n    return points.map(x => x[1]);\n\
    \  }\n\n  return nums;\n}\n", "  const len = nums.length;\n  if (len === 0) {\n\
    \    return [];\n  }\n  let maxSum = nums[0];\n  let tmpSum = nums[0];\n  for\
    \ (let i = 1; i < len; i++) {\n    const tmp = nums[i];\n    tmpSum += tmp;\n\
    \    maxSum = Math.max(maxSum, tmpSum);\n  }\n  const result = [];\n  for (let\
    \ i = 0; i < len; i++) {\n    const tmp = nums[i];\n    tmpSum -= tmp;\n    if\
    \ (tmpSum < 0) {\n      tmpSum = 0;\n    }\n    result.push(tmp);\n    maxSum\
    \ += tmp;\n  }\n  return result;\n}\n", "    nums.sort(function (a, b) {\n   \
    \     return a - b;\n    });\n    return nums;\n}\n", "  return nums.sort((a,\
    \ b) => {\n    return a + b;\n  });\n}\n", "  const sums = nums.reduce((acc, curr)\
    \ => {\n    acc += curr;\n    return acc;\n  }, 0);\n  console.log(`sums: ${sums}`);\n\
    \  return nums.sort((a, b) => sums - a);\n}\n", "  let sorted: number[] = [];\n\
    \  for (let n of nums) {\n    let digits = 0;\n    while (n) {\n      digits +=\
    \ n % 10;\n      n = Math.floor(n / 10);\n    }\n    digits = -digits;\n    sorted.push(digits);\n\
    \  }\n  sorted = sorted.sort((a, b) => a - b);\n  for (let i = 0; i < nums.length;\
    \ i++) {\n    const index = sorted.indexOf(nums[i]);\n    sorted.splice(index,\
    \ 1);\n  }\n  return sorted;\n}\n", "  return nums.sort((a, b) => a + parseInt(b.toString())\
    \ + Math.abs(a - b));\n}\n", "    const arr: number[] = [];\n    nums.sort((a,\
    \ b) => {\n        const ac = a % 10;\n        const bc = b % 10;\n        const\
    \ a = ac * 10 + a % 10;\n        const b = bc * 10 + b % 10;\n        return a\
    \ + b - ac - bc;\n    });\n    return nums.map(a => {\n        return arr[a];\n\
    \    });\n}", "    let points: number[] = [];\n    let max_digit = 0;\n    let\
    \ index = 0;\n    for (let i = 0; i < nums.length; i++) {\n        const val =\
    \ nums[i];\n        if (val) {\n            points.push(val);\n            max_digit\
    \ = Math.max(max_digit, val.toString().length + 1);\n        }\n    }\n    for\
    \ (let i = points.length - 1; i > 0; i--) {\n        points[i] = points[i] - points[i-1];\n\
    \    }\n    for (let j = 0; j < max_digit; j++) {\n        for (let i = 0; i <\
    \ points.length; i++) {\n            points[i] += 10;\n        }\n    }\n    const\
    \ max_points: number[] = [];\n    let current_point: number[] = points[index];\n\
    \    for (let i = 1; i < points.length; i++) {\n        const next_point: number\
    \ = points[i] - current_point;\n        if (next_point > 0 && next_point >= 10)\
    \ {\n            points[index] = next_point;\n            index = i;\n       \
    \ } else {\n            if (current_point > 0 && current_point >= 10) {\n    \
    \            max_points.push(current_point);\n                current_point =\
    \ points[index];\n            } else {\n                max_points.push(points[index]);\n\
    \                points[index] = 0;\n                index++;\n            }\n\
    \        }\n    }\n    max_points.push(points[index]);\n    max_points.sort((a,\
    \ b) => a > b);\n    return max_points;\n}", "    nums.sort((a, b) => sum_of_digits(a)\
    \ - sum_of_digits(b));\n    return nums;\n}\n", "  let maxLen = nums.length;\n\
    \  let maxSum = nums.reduce((maxSum, cur) => maxSum + Math.abs(cur), 0);\n  return\
    \ nums\n    .map((cur, i) => {\n      let len = nums.length;\n      let sumDiff\
    \ = Math.abs(cur - nums[i]);\n      if (sumDiff > maxSum) {\n        maxLen =\
    \ len;\n        maxSum = sumDiff;\n      }\n    })\n    .sort((a, b) => {\n  \
    \    let lenA = a;\n      let lenB = b;\n      while (lenA > lenB) {\n       \
    \ if (Math.abs(a) >= Math.abs(b)) {\n          lenA--;\n        } else {\n   \
    \       lenB--;\n        }\n      }\n      return lenA - lenB;\n    })\n    .slice(0,\
    \ maxLen);\n}\n", "  return nums.sort((a, b) => {\n    if (a > b) return 1;\n\
    \    if (b > a) return -1;\n    return 0;\n  });\n}\n", "    const a = nums.sort(\
    \ (a,b) => a + b );\n    const res = [];\n    for (let i = 0; i < a.length; i++)\n\
    \        res.push(a[i]);\n    return res;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting\
    \ dscore=0 |>\n<| a tags=arrays,algorithm,sorting |>\n<code>\nconst arr = [4,\
    \ 8, 2, 5, 1, -4, 6, 9, 7, 3, -9, -6, -9];\n\nconst sorted = arr.sort((a,b) =>\
    \ a-b);\n\nconst sorted2 = arr.sort((a,b) => b-a);\n\nconsole.log(sorted)\nconsole.log(sorted2)\n\
    \nconst sorted3 = arr.sort((a,b) => {\n  if(a < b){\n    return -1;\n  }\n  if(a\
    \ > b){\n    return 1;\n  }\n  return 0;\n});\n\nconsole.log(sorted3)</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nThe main difference between sort method and sort by\
    \ function are:\n\nsort method will compare value with other values and in case\
    \ of different value it will return -1 or 1.\n\n<code>\nlet arr = [1, 2, 4];\n\
    arr.sort();\n</code>\n\n<code>\nlet arr = [1, 2, 4];\narr.sort(function(a, b)\
    \ {\n  return a - b;\n});\n</code>\n\nsort by function will compare with other\
    \ value but it will return 0 as they are equal in case of different value.\n\n\
    <code>\nlet arr = [1, 2, 4];\narr.sort();\n</code>\n\n<code>\nlet arr = [1, 2,\
    \ 4];\narr.sort(function(a, b) {\n  return a - b;\n});\n</code>\n<|/ a dscore=0\
    \ tags=arrays,algorithm,sorting |>\n<| a dscore=0 tags=arrays,algorithm,sorting\
    \ |>\n<code>", "    let points: number[] = [];\n\n    nums.forEach((n) => {\n\
    \        points.push(n.toString().split('').map(Number));\n    });\n\n    points.sort(function\
    \ (a, b) {\n        const s1 = a.map(function (a) { return a.reduce((p, n) =>\
    \ p + n, 0) });\n        const s2 = b.map(function (b) { return b.reduce((p, n)\
    \ => p + n, 0) });\n        return s1 - s2;\n    });\n\n    return points.map(function\
    \ (point) { return point[0]; });\n}\n", "    const digits = nums.map(n => n.toString());\n\
    \    const len = digits.length;\n    let arr = [...digits];\n    for (let i =\
    \ 1; i < len; i++) arr.sort((a, b) => a.toString().localeCompare(b.toString()));\n\
    \    for (let i = 0; i < len; i++) {\n        nums[i] = arr[i];\n    }\n    return\
    \ nums;\n}\n", "  return nums.sort((a: number, b: number) => a - b);\n}\n", " \
    \   let nums_copy = nums.slice()\n    nums_copy.sort((a, b) => compare_by_digits(a,\
    \ b))\n    return nums_copy\n}\n", "  if (nums.length === 0) return nums;\n  let\
    \ sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n \
    \ }\n  sum = Math.abs(sum);\n  const digits = sum % 10 !== 0;\n  return [...nums.slice(0,\
    \ digits.length), ...nums.slice(digits.length)].sort();\n}\n", "  const len =\
    \ nums.length\n  if (len === 0) {\n    return nums\n  }\n  const digits = nums.map(function\
    \ (n) {\n    return n % 10\n  })\n  const sum = digits.reduce(function (a, b)\
    \ {\n    return a + b\n  })\n  const threshold = Math.log10(sum)\n  let idx\n\
    \  let sums = [0]\n  for (let i = 0; i < len; i++) {\n    const digit = digits[i]\n\
    \    idx = sums.indexOf(digit)\n    if (idx > -1) {\n      sums[idx] += 1\n  \
    \  } else {\n      sums.push(digit)\n    }\n  }\n  const sorted = sums\n    .slice(0,\
    \ sums.length - 1).concat(\n      Array(sums.length - 1).fill(0),\n    )\n   \
    \ .map(function (sum, i) {\n      if (sum > 0) {\n        sum = digits[i]\n  \
    \    }\n      return sum\n    })\n    .slice(0, len)\n  return nums.map(function\
    \ (x) {\n    return x < 0 ? -x : x\n  }).concat(sorted)\n}\n", "\tlet sorted =\
    \ nums.slice();\n\tsorted.sort((a, b) => {\n\t\tlet sumOfA = sum_of_digits(a);\n\
    \t\tlet sumOfB = sum_of_digits(b);\n\t\tif (sumOfA < sumOfB) {\n\t\t\treturn -1;\n\
    \t\t} else if (sumOfA > sumOfB) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn\
    \ 0;\n\t\t}\n\t});\n\treturn sorted;\n}\n", "    let result = [];\n    nums.forEach((num,\
    \ index) => {\n        let sum = 0;\n        while (num !== 0) {\n           \
    \ sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n     \
    \   result.push(sum);\n    });\n    // sort based on the result\n    result.sort((a,\
    \ b) => a - b);\n    return result;\n}\n</code>\n<|/ a tags=algorithm,sorting,arrays\
    \ dscore=0 |>\n<| a tags=algorithm,sorting,arrays |>\nYou can use Kadane's algorithm\
    \ for that:\n<code>", "  let points = [];\n  for (let i = 0; i < nums.length;\
    \ i++) {\n    let point = nums[i];\n    let sum = 0;\n    while (point > 0) {\n\
    \      sum += point % 10;\n      point = parseInt(point / 10);\n    }\n    points.push(sum);\n\
    \  }\n  points.sort((a, b) => a - b);\n  let sorted_nums = [];\n  for (let i =\
    \ 0; i < nums.length; i++) {\n    sorted_nums.push(points[i]);\n  }\n  return\
    \ sorted_nums;\n}\n", "    let points: number[] = [];\n    for (let num of nums)\
    \ {\n        let index = num.toString().length;\n        while (index > 0) {\n\
    \            points.push(parseInt(num.toString().substr(0, index)));\n       \
    \     num = num.toString().substring(index);\n            index--;\n        }\n\
    \    }\n    points.sort((a: number, b: number) => {\n        let diff = b - a;\n\
    \        if (diff === 0) {\n            return 0;\n        }\n        if (diff\
    \ > 0) {\n            return 1;\n        }\n        return -1;\n    });\n    let\
    \ results: number[] = [];\n    for (let point of points) {\n        results.push(nums[point]);\n\
    \    }\n    return results;\n}\nconsole.log(order_by_points([2, 7, -2, 3, -2,\
    \ 5]))\nconsole.log(order_by_points([1, 2, 3, -2, 5]))\nconsole.log(order_by_points([1]))\n\
    console.log(order_by_points([]))", "  return nums.sort((a, b) => (\n    +a + +b\n\
    \  ));\n}\n", "  if (nums.length === 0) return nums;\n\n  const digits = new Map();\n\
    \  const sums = nums.map(num => digits.get(num) || 0);\n  for (let i = 1; i <\
    \ sums.length; i++) {\n    const diff = sums[i] - sums[i - 1];\n    digits.set(sums[i],\
    \ diff);\n    digits.set(sums[i - 1], sums[i]);\n  }\n\n  const sorted = [];\n\
    \  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n    const\
    \ sum = digits.get(num) || 0;\n    sorted.push([num, sum]);\n  }\n\n  return sorted.sort((a,\
    \ b) => b[1] - a[1])[0];\n}\n", "  let order = [];\n\n  for (let i = nums.length\
    \ - 1; i >= 0; i--) {\n    let sum = 0;\n\n    for (let j = nums.length - 1; j\
    \ > i; j--) {\n      sum += nums[j];\n    }\n\n    order.unshift(sum);\n  }\n\n\
    \  return order;\n}\n", "  let result = [];\n  nums.sort((a, b) => {\n    let\
    \ sumA = sumDigits(a);\n    let sumB = sumDigits(b);\n    if (sumA != sumB) {\n\
    \      return sumA - sumB;\n    }\n    return a.localeCompare(b);\n  });\n  result\
    \ = result.concat(nums);\n  return result;\n}", "    const res = [];\n    nums.forEach((n,\
    \ i) => {\n        res.push(Math.pow(10, nums.reduce((m, v) => m + v, 0) + i))\n\
    \    });\n    res.sort((a, b) => a - b);\n    return res;\n}\n", "\tlet points:\
    \ number[] = [];\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tpoints[i] = nums[i];\n\
    \t}\n\tpoints.sort((a, b) => b - a);\n\tfor (let i = 0; i < nums.length; i++)\
    \ {\n\t\tnums[i] = points[i];\n\t}\n\treturn nums;\n}\n", "    nums.sort((a, b)\
    \ => a[0] - b[0]);\n    return nums;\n}\n", "    return nums.sort(function (a,\
    \ b) { return a + b; });\n}\n", "  let sum: number = 0;\n  for (let i = 0; i <\
    \ nums.length; i++) {\n    sum += nums[i];\n  }\n\n  const result = [];\n  for\
    \ (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n    const p =\
    \ sum % 10;\n    result.push([num, nums.indexOf(p)+1]);\n    sum -= num;\n  }\n\
    \n  return result;\n}\n", "    // Add first digits to get first sum\n    const\
    \ first_sum = nums.reduce(\n        (sum, item) => sum + item, 0\n    );\n\n \
    \   // Sort digits based on sum of their digits\n    const sorted_nums = nums.sort((a:\
    \ number, b: number) => {\n        return first_sum - Math.round(a) - Math.round(b);\n\
    \    });\n\n    // Return sorted nums\n    return sorted_nums;\n}\n", "  const\
    \ sorted = nums.slice();\n  nums.sort((a, b) =>\n    a.toString().split('').sort().reduce((s,\
    \ x) => s + +x, 0) -\n    b.toString().split('').sort().reduce((s, x) => s + +x,\
    \ 0)\n  );\n  return sorted;\n}\n", "    let ns: number[] = [];\n    for (let\
    \ n = 0; n < nums.length; n++) {\n        let sum = nums[n].toString().split('').map(d\
    \ => Number(d)).sum();\n        ns.push({\n            index,\n            sum\n\
    \        });\n    }\n    return ns.sort((a, b) => a.sum - b.sum).map(a => nums[a.index]);\n\
    }\n", "  return nums.sort((a, b) => {\n    return a.toString().localeCompare(b.toString());\n\
    \  });\n}\n", "  for (let i = 0; i < nums.length; ++i) {\n    const x = nums[i];\n\
    \    nums[i] = x;\n  }\n  nums.sort(function (a, b) { return a - b; });\n  for\
    \ (let i = 0; i < nums.length; ++i) {\n    nums[i] = nums[i] / 10;\n  }\n  return\
    \ nums;\n}\n", "    let points = [];\n    let index = 0;\n    while (index < nums.length)\
    \ {\n        let point = nums[index];\n        points.push(point);\n        index++;\n\
    \        while (index < nums.length && nums[index] < point) {\n            points.push(nums[index]);\n\
    \            index++;\n        }\n    }\n    return points;\n}\n", "  const res\
    \ = [];\n  for (let i = 0; i < nums.length; ++i) {\n    res[i] = i;\n  }\n  res.sort((a,\
    \ b) => sum_by_digits(a, nums) - sum_by_digits(b, nums));\n  return res;\n}\n",
  "  const len = nums.length;\n  if (len < 2) return nums;\n  const digitSums = nums.map((x:\
    \ number) => digits.reduce((prev, cur) => prev + cur, 0)).sort((a, b) => a - b);\n\
    \  const sortOrder = digitSums.map((sum, idx) => Math.sign(sum) - idx);\n  return\
    \ nums.map((x: number, idx) => idx == 0 ? x : idx == len - 1 ? -x : idx == sortOrder[idx]\
    \ ? x : 0);\n}\n", "  return nums.sort(function(a, b) {\n    let a_digits = a.toString().split('')\n\
    \    let b_digits = b.toString().split('')\n    let a_sum = a_digit.reduce((total,\
    \ digit, i) => {\n      return total + parseInt(digit, 10)\n    }, 0) as any\n\
    \    let b_sum = b_digit.reduce((total, digit, i) => {\n      return total + parseInt(digit,\
    \ 10)\n    }, 0) as any\n    return a_sum - b_sum\n  })\n}\n", "    if (!nums\
    \ || nums.length === 0) {\n        return [];\n    }\n    let ret = [];\n    let\
    \ curr = 0, min = Number.MAX_SAFE_INTEGER;\n    for (let i = 0, len = nums.length;\
    \ i < len; i++) {\n        const num = nums[i];\n        const digits = String(num).split('').sort();\n\
    \        curr = digits.length;\n        while (curr--) {\n            min = Math.min(min,\
    \ digits[curr]);\n        }\n        ret.push(nums[min]);\n    }\n    return ret;\n\
    }\n</code>\nAnd use it!\n<code>", "  nums.sort((a: number, b: number) => { return\
    \ a - b });\n  return nums;\n}\n", "  if (nums.length === 0) {\n    return nums;\n\
    \  }\n  const len = nums.length;\n  let max_sum = 0;\n  let min_sum = 0;\n  for\
    \ (let i = 0; i < len; i++) {\n    const num = nums[i];\n    const sum = num *\
    \ digitSum(num);\n    if (sum > max_sum) {\n      max_sum = sum;\n    }\n    if\
    \ (sum < min_sum) {\n      min_sum = sum;\n    }\n  }\n  const res = [];\n  let\
    \ cur = 0;\n  for (let i = 0; i < len; i++) {\n    const num = nums[i];\n    const\
    \ sum = num * digitSum(num);\n    if (sum === max_sum) {\n      res.push(nums[cur]);\n\
    \      cur++;\n    }\n  }\n  res.push(nums[cur - 1]);\n  return res;\n}\n", "\t\
    nums = nums.sort(function (a, b) { return (a > b ? 1 : a < b ? -1 : 0) });\n\t\
    \n\tnums = nums.sort(function (a, b) {\n\t\ta = Math.abs(a); b = Math.abs(b);\n\
    \t\tvar c = a - b;\n\t\tvar d = (a > b ? 1 : -1) * (a < b ? -1 : 0);\n\t\t\n\t\
    \treturn d != 0 ? c : ((c != 0) ? -b : a);\n\t});\n\n\treturn nums;\n}\n", " \
    \   nums = nums.sort(function (a, b) { return b - a; });\n    var result = [];\n\
    \    var maxSum = nums[0];\n    var maxSumIndex = 0;\n    for (var i = 0; i <\
    \ nums.length; i++) {\n        var digit = nums[i];\n        if (digit === maxSum)\
    \ {\n            maxSumIndex = i;\n        } else {\n            var index = result.indexOf(maxSum);\n\
    \            if (index < 0)\n                index = result.length;\n        \
    \    digit = result[index];\n            result.splice(index, 1);\n          \
    \  result.splice(maxSumIndex, 0, digit);\n            maxSum = digit;\n      \
    \      maxSumIndex = index;\n        }\n    }\n    return nums;\n}\n", "  let\
    \ res: number[] = [];\n  nums.sort((a, b) => {\n    let digitA = getDigitSum(a);\n\
    \    let digitB = getDigitSum(b);\n    let comparison = digitA - digitB;\n   \
    \ if (comparison === 0) {\n      comparison = a.localeCompare(b);\n    }\n   \
    \ return comparison;\n  });\n  for (let i = 0; i < nums.length; i++) {\n    res[i]\
    \ = nums[i];\n  }\n  return res;\n}\n", "  return nums.sort((a, b) => {\n    const\
    \ x = Math.abs(a) + Math.abs(b);\n    const y = Math.sign(a) * Math.sign(b);\n\
    \    return x - y;\n  });\n}\n", "    let nums = nums.slice();\n    nums.sort((a:\
    \ number, b: number) => {\n        let x = a.toString();\n        let y = b.toString();\n\
    \        let len = x.length;\n        let min_len = Math.min(x.length, y.length);\n\
    \        let i = 0;\n        while (x[i] == y[i] && i < min_len) {\n         \
    \   i++;\n        }\n        return i - min_len;\n    });\n    return nums;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\nIn addition to the given answer above,\
    \ I also tried this approach that solved the problem for me. I wanted to find\
    \ the largest number in the given array. The problem with this approach is that\
    \ it returns all the numbers in the array and not just one.\n<code>", "  let result:\
    \ number[] = [];\n\n  for (let i = 0, len = nums.length; i < len; i++) {\n   \
    \ let num = nums[i];\n    let index = 0;\n\n    while (num > 0) {\n      result.push(num\
    \ % 10);\n      num /= 10;\n      index++;\n    }\n\n    result.reverse();\n \
    \   let tmp = 0;\n\n    for (let j = 0; j < index; j++) {\n      tmp += result[j];\n\
    \    }\n\n    tmp = tmp + num;\n    result.push(tmp);\n  }\n\n  return result;\n\
    }\n", "\tnums.sort((a: number, b: number) => {\n\t\tif (a < 0 && b > 0) {\n\t\t\
    \treturn 1;\n\t\t} else if (a < 0 && b < 0) {\n\t\t\treturn -1;\n\t\t} else if\
    \ (a > 0 && b > 0) {\n\t\t\treturn 1;\n\t\t} else if (a > 0 && b < 0) {\n\t\t\t\
    return -1;\n\t\t}\n\t\treturn 0;\n\t});\n\treturn nums;\n}\n", "  let n = nums.length,\n\
    \    sorted_nums = nums.map(() => n),\n    sums = nums.map(n => n % 10);\n  for\
    \ (let i = 0; i < n; i++) {\n    const j = sums.indexOf(0);\n    if (j === -1)\
    \ continue;\n    sorted_nums[j] = sorted_nums[i];\n    sums[j] -= i;\n  }\n  return\
    \ sorted_nums;\n}", "    const copy = nums.slice(0);\n    copy.sort((a, b) =>\
    \ point_sum_digits(a) - point_sum_digits(b));\n    return copy;\n}\n", "  let\
    \ len = nums.length;\n  let result: number[] = [];\n\n  for (let i = 0; i < len;\
    \ i++) {\n    let sum = nums[i];\n    result.push(nums[i]);\n    for (let j =\
    \ i + 1; j < len; j++) {\n      sum += nums[j];\n      if (sum > 0) {\n      \
    \  result.push(j);\n        break;\n      }\n    }\n  }\n\n  return result;\n\
    }\n", "    nums = nums.slice();\n    nums.sort(function (a, b) {\n        return\
    \ sort_digits(a, b);\n    });\n    return nums;\n}\n", "  nums.sort((a, b) =>\
    \ b - a); // descending order\n  let sum = 0;\n  for (let i = 0; i < nums.length;\
    \ i++) {\n    sum += nums[i];\n    if (sum > 0) {\n      nums[i] = sum;\n    }\
    \ else {\n      nums.splice(i, 1);\n    }\n  }\n  return nums;\n}", "  const orders\
    \ = nums.map((n) => getOrders(n)).filter(([, order]) => order > 0);\n  return\
    \ orders.map(([order, index]) => nums[index]);\n}\n", "  if (nums.length < 2)\
    \ return nums;\n  const digits = nums.map(n => digits_sum(n));\n  digits.sort((a,\
    \ b) => a - b);\n  return nums.map(num => nums[digits.indexOf(digits_sum(num))]);\n\
    }\n", "  const digits = nums.map(num => Math.log10(num));\n  const ordered = digits.sort((d1,\
    \ d2) => {\n    return d2 - d1;\n  });\n  const index = nums.map(i => Math.round(i)).sort((a,\
    \ b) => {\n    return a - b;\n  });\n  return nums.map(num => {\n    return index[num];\n\
    \  });\n}\n", "  let arr = nums.map((num: number) => num.toString());\n  let arr2\
    \ = arr.sort((a, b) => {\n    let aStr = a.toString();\n    let bStr = b.toString();\n\
    \    return bStr.length - aStr.length;\n  });\n  let arr3 = arr2.map((num: number)\
    \ => parseInt(num));\n  return arr3;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ tags=javascript,sorting |>\n<code>\nconst sortNumbers = (nums) => {\n  let arr\
    \ = nums.map(i => i.toString());\n  return arr.sort((a, b) => {\n    const aStr\
    \ = a.toString();\n    const bStr = b.toString();\n    return bStr.substring(0,aStr.length)\
    \ - aStr.substring(0,aStr.length);\n  });\n}\n</code>\n<|/ a |>\n<| a tags=javascript,sorting\
    \ dscore=0 |>\nHere is a simple solution using a sort callback. It uses String.localeCompare()\
    \ to compare strings and sorts numbers as strings.\n\n<code>\nconst sortNumbers\
    \ = arr =>\n  arr.sort((a, b) =>\n    b.localeCompare(a, 'en-US', {numeric: true,\
    \ sensitivity: 'base'})\n  );\n\nconsole.log(sortNumbers([8, 6, 3, 1, 10, 4]));\n\
    console.log(sortNumbers([8, 6, 3, 1, 10, 40]));\nconsole.log(sortNumbers([]));</code>\n\
    .as-console-wrapper { max-height: 100% !important; top: 0; }\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>", "  const sums = nums.map(num => Math.pow(10, nums.length - num))\n\
    \  return nums.sort((a, b) => sums.indexOf(a) - sums.indexOf(b))\n}\n", "  if\
    \ (nums.length === 0) {\n    return nums;\n  }\n  let [smallest, largest] = nums;\n\
    \  for (let i = 0; i < nums.length; i++) {\n    let [l, r] = nums[i];\n    smallest\
    \ = smallest * 10 + l;\n    largest = largest * 10 + r;\n  }\n  const length =\
    \ largest - smallest;\n  if (length === 0) return nums;\n  const digits = [];\n\
    \  for (let i = 0; i < length; i++) {\n    digits.push((10 - smallest) % 10);\n\
    \  }\n  return [digits, nums];\n}\n", "  if (nums.length === 0) { return nums;\
    \ }\n\n  const sums: number[] = [];\n\n  for (let i = 0; i < nums.length; i++)\
    \ {\n    const num = nums[i];\n\n    if (sums.indexOf(num) !== -1) {\n      const\
    \ idx = sums.indexOf(num);\n      nums[idx] = nums[i];\n      sums[idx] += nums[i];\n\
    \    } else {\n      sums.push(num);\n    }\n  }\n\n  for (let i = 0; i < sums.length;\
    \ i++) {\n    if (sums[i] === 0) {\n      sums.splice(i, 1);\n      i--;\n   \
    \ }\n  }\n\n  return nums;\n}\n", "  // Sort by digits.\n  nums.sort(function(lhs,\
    \ rhs) {\n    var lhs_digits = lhs.toString().split('').sort();\n    var rhs_digits\
    \ = rhs.toString().split('').sort();\n    for (var i = 0; i < lhs_digits.length;\
    \ ++i) {\n      if (lhs_digits[i] > rhs_digits[i]) return 1;\n      if (lhs_digits[i]\
    \ < rhs_digits[i]) return -1;\n    }\n    return 0;\n  });\n  // Then, sort by\
    \ the original order in the input array.\n  return nums.map(function(num) {\n\
    \    var digits = num.toString().split('');\n    return digits.length < 2 ? num\
    \ : digits.reverse().join('');\n  });\n}\n\n", "  const length = nums.length;\n\
    \  nums.sort((a, b) => {\n    const sum = a.getDigitSum(b);\n    if (sum === 0)\
    \ {\n      return a - b;\n    } else {\n      return sum - b.count;\n    }\n \
    \ });\n  return nums;\n}\n", "  if (nums.length === 0) {\n    return nums\n  }\n\
    \  const len = nums.length\n  if (len < 2) {\n    return nums\n  }\n  const result\
    \ = [nums[0]]\n  for (let i = 1; i < len; i++) {\n    const digits = nums[i].toString()\n\
    \    const index = digits.indexOf('-')\n    if (index < 0) {\n      break\n  \
    \  }\n    const sum = parseInt(digits.slice(index + 1), 10)\n    result.push(sum)\n\
    \  }\n  return result.sort((a, b) => {\n    return a - b\n  }) as number[]\n}\n",
  "    if (nums.length === 0) {\n        return nums;\n    }\n\n    let digits = new\
    \ Map<number, boolean>();\n    let res = [];\n    for (let i = 0; i < nums.length;\
    \ i++) {\n        let digit = nums[i] / 10;\n        if (digits.has(digit)) {\n\
    \            digits.get(digit) ^= true;\n        } else {\n            digits.set(digit,\
    \ true);\n        }\n\n        res.push(nums[i]);\n    }\n    return res;\n}\n",
  "    // Write your code here\n    let sorted = nums.slice();\n    for (let i = 0;\
    \ i < sorted.length; i++) {\n        let sum = 0;\n        for (let j = 0; j <\
    \ sorted.length; j++) {\n            sum += sorted[j];\n        }\n        if\
    \ (sum === 0) sorted.sort();\n        else if (sorted[i] < sorted[sum]) sorted.sort();\n\
    \    }\n    return sorted;\n}\n", "  const len = nums.length;\n  if (len === 0)\
    \ {\n    return nums;\n  }\n  const max_sum = nums.reduce((a, v) => a + v, 0);\n\
    \  let min_sum = nums.reduce((a, v) => a + v, 0);\n  for (let i = 1; i < len;\
    \ ++i) {\n    const cur_sum = nums.reduce((a, v) => a + v, 0);\n    if (cur_sum\
    \ < min_sum) {\n      min_sum = cur_sum;\n    }\n    if (cur_sum > max_sum) {\n\
    \      max_sum = cur_sum;\n    }\n  }\n  nums.sort((a, b) => a - b);\n  nums.reverse();\n\
    \  return nums;\n}\n", "  if (nums.length === 0) {\n    return [];\n  }\n  nums.sort(function\
    \ (a, b) {\n    return Number(a) - Number(b);\n  });\n  return nums;\n}\n", " \
    \   // Store the original array for sorting.\n    let numbers = nums.slice();\n\
    \n    // Sort by the sum of their digits.\n    numbers.sort((a: number, b: number)\
    \ => {\n        let sum_of_digits = a + b; // Sum of the digits of both numbers.\n\
    \        return sum_of_digits - sum_of_digits % 10; // Sum minus the sum of digits\
    \ of the quotient of the numbers.\n    });\n\n    // Reverse the array since it\
    \ has been sorted.\n    return numbers.reverse();\n}\n", "  const set = new Set();\n\
    \  for (const i of nums) {\n    const digits = i.toString().split('');\n    const\
    \ len = digits.length;\n    const total: number = 0;\n    for (let j = 0; j <\
    \ len; j++) {\n      total += +digits[j];\n    }\n    set.add(total);\n  }\n \
    \ return [...set].sort((a, b) => a - b);\n}\n", "  return nums.sort((a, b) =>\
    \ {\n    const a_num = parseInt(a.toString(), 10);\n    const b_num = parseInt(b.toString(),\
    \ 10);\n    return a_num - b_num;\n  });\n}\n", "  const a = nums.reduce((acc,\
    \ num) => {\n    acc = acc + num\n    return acc\n  }, 0)\n  return nums.sort((a:\
    \ number, b: number) => {\n    return a - b\n  }).filter(num => num != 0)\n}\n",
  "  let ret: number[] = [];\n  for (let i = 0; i < nums.length; i++) {\n    let current\
    \ = nums[i];\n    let sum = 0;\n    while (current > 0) {\n      sum += current\
    \ % 10;\n      current = Math.floor(current / 10);\n    }\n    if (sum > 0) {\n\
    \      ret.push(current);\n    }\n  }\n  return ret;\n}\n", "    if (nums.length\
    \ === 0) {\n        return [];\n    }\n\n    const digits = nums.map(x => Math.abs(x));\n\
    \n    // Sort the digits from largest to smallest by suming the digits and returning\
    \ the index\n    const indexedDigits = [...digits]\n        .sort((a, b) => b\
    \ - a)\n        .map((d, i) => [d, i])\n        .map(([digit, i]) => ({ digit,\
    \ index: i }));\n\n    const sum = indexedDigits.reduce((a, b) => a.digit + b.digit,\
    \ 0);\n\n    return indexedDigits.map(x => x.digit).filter(x => x >= sum).map(x\
    \ => x.index);\n}\n", "    const total = [...nums].sort((a,b)=>a+b).reduce((a,b)=>a+b);\n\
    \    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n   \
    \     const num = nums[i];\n        const digit = String(num).split(\"\").map(Number);\n\
    \        const index = digit.reduce((a,b)=>a+b) % total;\n        if (map.has(index))\
    \ {\n            map.get(index).push(num);\n        } else {\n            map.set(index,\
    \ [num]);\n        }\n    }\n    return [...map.values()].flat();\n}\n", "  const\
    \ sorted_nums = nums.slice().sort((a, b) => {\n    const x = a.toString().split('').reverse().join('');\n\
    \    const y = b.toString().split('').reverse().join('');\n    return x.localeCompare(y);\n\
    \  });\n  return sorted_nums;\n}\n", "    if (nums.length == 0) {\n        return\
    \ nums;\n    }\n    var result = [];\n    var pointer = 0, sum = 0;\n    for (var\
    \ i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum < 0)\
    \ {\n            pointer = i;\n        }\n        if (sum > 0) {\n           \
    \ result.push(pointer);\n            sum = 0;\n        }\n    }\n    result.push(pointer);\n\
    \    return result;\n}\n", "  const sums = {};\n\n  nums.forEach((num) => {\n\
    \    let sum = num.toString().split('').reduce((sum: number, digit: number) =>\
    \ sum + +digit, 0);\n    sums[sum] = num;\n  });\n\n  const sorted = Object.values(sums);\n\
    \  sorted.sort((a, b) => a - b);\n\n  return sorted;\n}\n", "  if (nums.length\
    \ === 0) {\n    return nums;\n  }\n  const sorted = nums.slice().sort((a, b) =>\
    \ {\n    const a_digit = Math.abs(a);\n    const b_digit = Math.abs(b);\n    //\
    \ If the digits are the same, sort by their original index\n    if (a_digit ===\
    \ b_digit) {\n      return a < b ? -1 : 1;\n    }\n    // Otherwise, sort by the\
    \ sum of the digits\n    return a_digit + b_digit - a_digit * b_digit;\n  });\n\
    \  return sorted.reverse();\n}\n", "  let num_sum = 0;\n  const len = nums.length;\n\
    \  for (let i = 0; i < len; i++) {\n    num_sum += nums[i];\n  }\n  const res\
    \ = new Array<number>();\n  for (let i = 0; i < len; i++) {\n    const num = nums[i];\n\
    \    const point_index = num_sum - num;\n    if (point_index >= 0) {\n      res.push(nums[point_index]);\n\
    \    }\n  }\n  return res;\n}", "  for (let i = 0; i < nums.length; i++) {\n \
    \   let j = i;\n    while (j > 0 && nums[j - 1] > nums[j]) {\n      nums[j] =\
    \ nums[j - 1];\n      j = j - 1;\n    }\n    nums[j] = nums[i];\n  }\n  return\
    \ nums;\n}\n", "  const sums: number[] = [];\n  for (let n of nums) {\n    sums.push(n);\n\
    \  }\n  sums.sort((a, b) => sums[a] - sums[b]);\n  return sums.map(i => nums[i]);\n\
    }\n", "  if (nums.length === 0) {\n    return nums;\n  }\n\n  const points: number[]\
    \ = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length; i += 1) {\n    const\
    \ digit = nums[i];\n    sum += digit;\n    const point = Math.pow(10, sum % 10);\n\
    \    if (point === 0) {\n      point = 9999;\n    }\n    points.push(point);\n\
    \  }\n  points.sort((a, b) => a - b);\n\n  return points.map(num => num / 10).concat(nums);\n\
    }\n", "  const map = new Map<number, number[]>();\n  for (let i = 0; i < nums.length;\
    \ i++) {\n    const num = nums[i];\n    const sum = 0;\n    for (let j = 0; j\
    \ < num.length; j++) {\n      sum += Number(num[j]);\n    }\n    const key = map.get(sum)\
    \ || [sum, i]\n    map.set(sum, key);\n  }\n  return Array.from(map.values());\n\
    }\n", "    nums.sort(function (a: number, b: number) {\n        const digitsA\
    \ = a.toString().split('').reverse();\n        const digitsB = b.toString().split('').reverse();\n\
    \        const diff = Math.abs(digitsB[0] - digitsB[1]);\n        return diff\
    \ === 0 ? digitsA[0] - digitsB[0] : diff;\n    });\n    return nums;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 tags=javascript,algorithm,sorting |>\nHere is\
    \ my solution for that :\n<code>\nvar sortByDigit = function(arr){\n    arr=arr.sort(function(a,b){\n\
    \         a=a.replace(/\\d/g,'');\n         b=b.replace(/\\d/g,'');\n        \
    \ return a-b;\n    });\n    return arr;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\n\
    In a simpler way, you may just split your string and sort it by the length of\
    \ each split string. After that, you can concat it again.\n\n<code>\nvar a = [1,\
    \ 11, -1, -11, -12];\n\nconsole.log(a);\n\na.sort((a, b) => a.length - b.length);\n\
    \nconsole.log(a);\n\na = a.map(str => str.length).concat(a);\n\nconsole.log(a);</code>\n\
    <|/ a tags=javascript,algorithm,sorting |>\n<| a tags=javascript,algorithm,sorting\
    \ dscore=2 |>\n<code>\nvar array = [1, 11, -1, -11, -12];\n\narray.sort((a, b)\
    \ => {\n  var lengthA = (a + '').length;\n  var lengthB = (b + '').length;\n \
    \ return lengthA - lengthB;\n});\n\nconsole.log(array);</code>\n<|/ a |>\n<| c\
    \ |>\nThis answer should have a brief explanation of what you're doing. Even if\
    \ it does work, it's not a good way to learn JavaScript.\n<|/ c |>\n<| c |>\n\
    Please add further details to expand on your answer, such as working code or documentation\
    \ citations.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nvar a = [1, 11, -1, -11, -12]\n\
    var b = [1, -1, -12, -11, 11]\nvar c = [1, -1, -12, -11, 11]\nvar d = [1, 2, 3,\
    \ 4, 5]\nvar e = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nvar f = [1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]\nvar g = [1, -1, 1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, -1,\
    \ -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1,\
    \ 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\
    \ -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, ", "  if (!nums.length)\
    \ {\n    return nums;\n  }\n  const numsSorted = nums.slice().sort((a, b) => a\
    \ + b).map(i => parseInt(i));\n  for (let i = 1; i < numsSorted.length; ++i) {\n\
    \    const num = numsSorted[i];\n    if (numsSorted.indexOf(num) !== i) {\n  \
    \    numsSorted.splice(i, 0, num);\n    }\n  }\n  return numsSorted;\n}\n", " \
    \ const res = [];\n  let preSum = 0;\n  for (let i = 0; i < nums.length; i++)\
    \ {\n    const sum = Math.round(nums[i] * 1e+2) / 1e+2;\n    if (sum > preSum)\
    \ {\n      res.push(nums[i]);\n      preSum = sum;\n    } else {\n      const\
    \ idx = res.indexOf(nums[i]);\n      res.splice(idx, 1);\n      res.push(nums[i]);\n\
    \    }\n  }\n  return res;\n}\n", "  const len = nums.length;\n  const map = new\
    \ Map<number, number[]>();\n  const result = [];\n  for (let i = 0; i < len; i++)\
    \ {\n    const num = nums[i];\n    if (!map.has(num)) {\n      map.set(num, []);\n\
    \    }\n    map.get(num).push(i);\n  }\n  for (let i = 0; i < len; i++) {\n  \
    \  const nums = map.get(nums[i]);\n    for (let j = 0, n = nums.length; j < n;\
    \ j++) {\n      result[nums[j]] = nums[i];\n    }\n  }\n  return result;\n}\n",
  "  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0)\n      nums.splice(i,\
    \ 0, nums[i] + nums[i - 1]);\n  }\n  return nums;\n}\n", "  const sum_digits =\
    \ nums.map(n => n.toString().split(\"\").reduce((a: number, b: string) => a +\
    \ Number(b), 0));\n  return nums.map(n => sum_digits.indexOf(n) < 0 ? Math.ceil(n)\
    \ : Math.floor(n));\n}\n", "  const points: number[] = [];\n  let max_digit =\
    \ 0;\n  let min_digit = 9999;\n  for (const num of nums) {\n    const digit =\
    \ Math.abs(num);\n    if (digit < min_digit) {\n      min_digit = digit;\n   \
    \ }\n    if (digit > max_digit) {\n      max_digit = digit;\n    }\n    points.push(digit);\n\
    \  }\n  points.sort((a, b) => a - b);\n  const result = [];\n  for (let i = 0;\
    \ i <= max_digit; i++) {\n    result.push(nums[points[i]]);\n  }\n  return result;\n\
    }\n", "  let nums1: number[] = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length;\
    \ i++) {\n    sum = sum + nums[i];\n    nums1.push(sum);\n  }\n  let order = [];\n\
    \  let flag = true;\n  for (let i = 0; i < nums1.length; i++) {\n    for (let\
    \ j = i + 1; j < nums1.length; j++) {\n      if (nums1[j] - nums1[i] < 0 && nums1[j]\
    \ - nums1[i] > 0) {\n        order.push(nums1[j]);\n        flag = false;\n  \
    \    }\n    }\n  }\n  return order;\n}\n", "  const map = {}\n  let i = nums.length;\n\
    \  while (i > 0) {\n    const sum = 0;\n    while (i > 0) {\n      sum += nums[--i];\n\
    \    }\n    const key = sum;\n    const value = nums.indexOf(key);\n    map[value]\
    \ = key;\n    nums[i] = key;\n  }\n  const result = new Array(nums.length);\n\
    \  nums.forEach((key, i) => {\n    result[map[key]] = nums[i];\n  });\n  return\
    \ result;\n}\n", "  let sum = 0;\n  for (let num of nums) {\n    sum += num;\n\
    \  }\n\n  let buckets = nums\n    .sort((a, b) => a - b)\n    .map((num) => {\n\
    \      let digit = num % 10;\n      let index = sum - digit;\n      return [digit,\
    \ index];\n    })\n    .filter(([_, index]) => index)\n    .sort((a, b) => a[1]\
    \ - b[1]);\n\n  let result = [];\n  for (let i = 0; i < buckets.length; i++) {\n\
    \    if (buckets[i][0]) {\n      result.push(buckets[i][0]);\n    }\n  }\n\n \
    \ return result;\n}\n", "  return nums.slice().sort((a, b) => a - b).reverse();\n\
    }\n", "    let n = nums.length;\n    if (n<2) return nums;\n    const digits =\
    \ nums.map(x => parseInt(x.toString(), 10));\n    const digits_sum = digits[digits.length-1];\n\
    \    if (digits_sum<0) return nums.map(x => parseInt(x.toString(), 10));\n   \
    \ let sorted = nums.map(x => parseInt(x.toString(), 10)).sort((a, b) => a>b ?\
    \ 1 : -1);\n    let ret = [];\n    let sum = 0;\n    for (let i=0; i<sorted.length;\
    \ ++i) {\n        let cur_sum = sorted[i];\n        for (let j=i+1; j<sorted.length;\
    \ ++j) {\n            let cur = sorted[j];\n            if (cur_sum == cur) continue;\n\
    \            if (sum+cur_sum > sum) ret.push(sorted[j]);\n            else ret.push(sorted[i]);\n\
    \            sum = sum + cur_sum;\n        }\n    }\n    return ret;\n}\n", " \
    \ if (!nums.length) return nums;\n  let min_sum;\n  for (let i = 0; i < nums.length;\
    \ i++) {\n    const n = nums[i];\n    if (i === 0) min_sum = n;\n    const cur_sum\
    \ = n + min_sum;\n    min_sum = cur_sum;\n  }\n  return nums.sort((a, b) => a\
    \ - b);\n}\n</code>\n<|/ a |>\n<| c |>\nThis is an elegant solution to the problem,\
    \ but I would argue that it's less readable than the other solution provided by\
    \ Jony.\n<|/ c |>\n<| c |>\nSure, Jony is doing this in a single line, but what\
    \ makes it more readable is using the `reduce` function and some conditional statements.\
    \ `reduce` will iterate over the array and return a single value (the sum of the\
    \ numbers) and conditional statements allow you to skip over the elements whose\
    \ sums match or where there is more than one number with the sum. With that information,\
    \ you can then sort the numbers using the `sort` method.\n<|/ c |>\n<| c |>\n\
    The question asks for \"elegance\", and this is elegant and readable code, IMO.\
    \ It can be further improved by removing the `const sum = nums.reduce((a,b) =>\
    \ a+b, 0);` line and adding an `if` statement to check if there is more than one\
    \ element in the array with the same sum.\n<|/ c |>\n<| a tags=javascript,arrays,sorting\
    \ |>\nThis solution uses the sort and filter methods to only return those elements\
    \ that have the highest amount of digits. The final sort sorts the array in descending\
    \ order based on the sum of their digits.\n\n<code>\nconst input = [1, 10, 9,\
    \ 7, 95, 3, 1];\n\nconst sumDigits = (num) => {\n  const str = num.toString();\n\
    \  return str.length;\n}\n\nconst maxDigits = (input) => {\n  const numbers =\
    \ input\n    .map((num) => {\n      return num\n    })\n    .reduce((acc, curr)\
    \ => {\n      const sum = sumDigits(curr);\n      return (acc === sum) ? acc :\
    \ sum;\n    }, 0);\n  return numbers.filter((num) => sumDigits(num) === maxDigits)\n\
    \    .sort((a,b) => sumDigits(a) - sumDigits(b));\n}\n\nconst result = maxDigits(input);\n\
    \nconsole.log(result);</code>\n<|/ a dscore=0 |>\n<| a tags=javascript,arrays,sorting\
    \ |>\nI modified the answer by Jony to only add the highest amount digits for\
    \ each element. \n<code>\nconst maxDigits = (input, digits) => {\n  const numbers\
    \ = input\n    .map((num) => {\n      return num\n    })\n    .reduce((acc, curr)\
    \ => {\n      const sum = numbers.reduce((a, b) => a + b, ", "  const results\
    \ = [];\n  let index = 0;\n  let sum = 0;\n  for (let i = 0; i < nums.length;\
    \ i++) {\n    if (nums[i] === 0) {\n      results.push(0);\n    } else {\n   \
    \   const digit = nums[i] / 10;\n      if (digit > 0 && digit < 9) {\n       \
    \ sum += digit;\n        results.push(index++);\n      } else {\n        results.push(index++);\n\
    \        sum += digit * 9;\n      }\n    }\n  }\n  results.sort((a, b) => sum\
    \ - b - a);\n  return results;\n}\n", "\tconst [sum, digits, index, point] = nums.reduce(\n\
    \t\t([sum, digits, index, point], num) => {\n\t\t\tconst digit = num.toString().charAt(0);\n\
    \t\t\tsum += +digit;\n\t\t\tpoint = Math.floor(sum / 10);\n\t\t\treturn [sum,\
    \ digits, index, point === num ? point : index];\n\t\t},\n\t\t[0, 0, 0, 1]\n\t\
    );\n\n\tconst points = [...new Array(point)]\n\t\t.map((_, index) => ({ index,\
    \ value : digits[index] }))\n\t\t.sort((a: any, b: any) => a.value - b.value)\n\
    \t\t.map((a: any) => a.value);\n\tconst index = points.findIndex((value) => value\
    \ === point);\n\tif (index >= 0) {\n\t\treturn [...points.slice(0, index), ...points.slice(index\
    \ + 1)];\n\t}\n\treturn points;\n}\n", "  nums.sort(function (a, b) {\n    const\
    \ leftSum = sum_of_digits(a)\n    const rightSum = sum_of_digits(b)\n    const\
    \ diff = rightSum - leftSum\n    return diff === 0 ? a.localeCompare(b) : diff\n\
    \  })\n  return nums\n}\n", "    return nums.sort((a: number, b: number) => {\n\
    \        return a.localeCompare(b);\n    });\n}\n", "  const digits = nums.map(n\
    \ => `${n}`.split('').map(Number))\n  digits.sort((a, b) => {\n    if (a.toString()\
    \ === b.toString()) return 0\n    return Number(a) - Number(b)\n  })\n  const\
    \ orders = digits.map((d, i) => [d, i])\n  orders.sort((a, b) => a[0] - b[0])\n\
    \  return nums.map(i => orders[i - 1][0])\n}\n", "  const len = nums.length;\n\
    \  if (len === 0) {\n    return nums;\n  }\n  nums.sort(\n      (a, b) => {\n\
    \        const diff = digits_sum(b) - digits_sum(a);\n        if (diff === 0)\
    \ {\n          return digits_sum(b) - digits_sum(a);\n        }\n        return\
    \ diff;\n      });\n  const res = [];\n  let i = 0;\n  for (let j = 1; j < len;\
    \ j++) {\n    if (digits_sum(nums[i]) + digits_sum(nums[j]) === 0) {\n      res.push(nums[i]);\n\
    \      i++;\n    } else {\n      res.push(nums[j]);\n    }\n  }\n  return res;\n\
    }\n", "    const ns = nums.slice();\n    ns.sort(function(a, b) {\n        const\
    \ ap = a.replace(/-/g, '');\n        const bp = b.replace(/-/g, '');\n       \
    \ return ap - bp;\n    });\n    return ns;\n}\n", "    const order = [-1, 1];\n\
    \    const digits = [...nums].reverse();\n    let res = [];\n    while (digits.length\
    \ > 0) {\n        const index = digits.length - 1;\n        const digit = digits[index];\n\
    \        const nextDigit = digits[index + 1];\n        res.push(digit + order[index\
    \ % 2] * (nextDigit - digit));\n        digits.splice(index, 2);\n    }\n    return\
    \ res;\n}", "  const sortedArr = nums.slice().sort((a, b) => a + b); // Sort by\
    \ sum of digits\n  const resultNums = sortedArr.map(d => nums.indexOf(d)); //\
    \ Get index of each element\n  const result = resultNums.map(index => nums[index]);\
    \ // Get the original elements\n  return result;\n}\n", "  // Sort the numbers\
    \ based on their sum of the digits, in descending order\n  return nums.sort(\n\
    \    (a, b) => (b < 0 ? b * -1 : b * 10 + a) - a,\n  );\n}\n</code>\n<|/ a |>\n\
    <| a dscore=0 tags=sorting,algorithm |>\nMy solution is based on divide and conquer\n\
    <code>", "\tlet arr = [...nums];\n\tarr.sort((a, b) => {\n\t\treturn a.reduce(\
    \ (prev, curr) => {\n\t\t\treturn prev + curr;\n\t\t}, 0) - (b.reduce( (prev,\
    \ curr) => {\n\t\t\treturn prev + curr;\n\t\t}, 0) || 0);\n\t});\n\treturn arr;\n\
    }\n", "    if (nums.length === 0) {\n        return nums\n    }\n    nums.sort(function\
    \ (a, b) {\n        return digit_sum(b) - digit_sum(a);\n    });\n    return nums;\n\
    }\n", "  const sums: number[] = [];\n  for (let i = 0; i < nums.length; i++) {\n\
    \    const num = nums[i];\n    sums.push(num.sum(nums));\n  }\n  return nums.filter(num\
    \ => sums.indexOf(num) > -1);\n}\n", "  let points = [];\n  for (let i = 0; i\
    \ < nums.length; i++) {\n    points.push(nums[i]);\n  }\n  points = points.sort((a,\
    \ b) => {\n    let point = 0;\n    for (let i = 1; i <= 9; i++) {\n      point\
    \ += parseInt(a.toString()[i], 10) - parseInt(b.toString()[i], 10);\n    }\n \
    \   return point;\n  });\n  return points;\n}\n", "  if (nums.length > 0) {\n\
    \    nums.sort(function (a, b) {\n      return (a.length - b.length) * a % b;\n\
    \    });\n  }\n  return nums;\n}\n", "  if (nums.length === 0) {\n    return nums;\n\
    \  }\n  let ordered = [];\n  let sum = 0;\n  for (let i = 0; i < nums.length;\
    \ ++i) {\n    let num = nums[i];\n    if (num > 0) {\n      sum += num;\n    \
    \  ordered.unshift(num);\n    }\n  }\n  for (let i = 0; i < ordered.length; ++i)\
    \ {\n    let cur = ordered[i];\n    let nums = ordered.slice(i, ordered.length\
    \ - 1).filter(function(num) {\n      return num === cur;\n    });\n    ordered\
    \ = ordered.slice(0, i).concat(nums).concat(ordered.slice(ordered.length - i));\n\
    \  }\n  return ordered;\n}\n", "  if (nums.length === 0) {\n    return nums;\n\
    \  }\n  const digits = nums.map(num => parseInt(String(num), 10));\n  const len\
    \ = digits.length;\n  // find sum\n  let sum = 0;\n  for (let i = 0; i < len;\
    \ i++) {\n    sum += digits[i];\n  }\n  // sort by sum\n  let t = [];\n  let index\
    \ = 0;\n  for (let i = 0; i < len; i++) {\n    if (sum > 0) {\n      t.push(nums[index]);\n\
    \      index++;\n      sum -= digits[i];\n    } else {\n      t.push(-1);\n  \
    \  }\n  }\n  return t;\n}\n", "  return nums.sort((a: number, b: number) => a\
    \ - b);\n}\n", "  const total = 0;\n  for (let num of nums) {\n    total += num;\n\
    \  }\n  return nums.sort((a, b) => {\n    return a - b;\n  });\n}\n", "  const\
    \ sorted = nums.slice().sort((a: number, b: number) => a - b);\n  return nums.map((n:\
    \ number) => sorted.indexOf(n));\n}\n", "    const sorted_nums = [];\n\n    let\
    \ largest = -1;\n    let smallest = Number.MAX_SAFE_INTEGER;\n    for (const n\
    \ of nums) {\n        smallest = n < smallest ? n : smallest;\n        largest\
    \ = n > largest ? n : largest;\n    }\n\n    for (let i = 0; i < nums.length;\
    \ i++) {\n        const n = nums[i];\n        const digits = String(Math.floor(n)).split('');\n\
    \        let total = Number(digits.pop());\n\n        let j = nums.length - 1;\n\
    \        while (j > -1) {\n            const digits2 = String(Math.floor(nums[j])).split('');\n\
    \            total += Number(digits2.pop());\n            j--;\n        }\n\n\
    \        if (largest < total) {\n            largest = total;\n        }\n\n \
    \       if (smallest > total) {\n            smallest = total;\n        }\n\n\
    \        sorted_nums.push(total);\n    }\n\n    return sorted_nums;\n}\n", " \
    \   nums = nums.sort((a: number, b: number) => a - b);\n    let buckets: number[]\
    \ = [];\n    let currSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n \
    \       let num = nums[i];\n        if (currSum < num) {\n            currSum\
    \ += num;\n            buckets.push(num);\n        } else if (currSum === num)\
    \ {\n            buckets.push(i);\n        } else {\n            buckets.sort((a:\
    \ number, b: number) => a - b);\n            currSum -= buckets.shift();\n   \
    \     }\n    }\n    return buckets;\n}\n", "    let nums_copy = nums.slice();\n\
    \    nums_copy.sort((a, b) => {\n        let digits = a.toString().split('').map((x)\
    \ => parseInt(x, 10));\n        let digits2 = b.toString().split('').map((x) =>\
    \ parseInt(x, 10));\n        let d0 = digits[0];\n        let d1 = digits[1];\n\
    \        let d2 = digits[2];\n        let d3 = digits[3];\n        let d4 = digits[4];\n\
    \        let d5 = digits[5];\n        let d6 = digits[6];\n        let d7 = digits[7];\n\
    \        if (d0 + d1 + d2 + d3 + d4 + d5 + d6 + d7 === 0) {\n            return\
    \ 0;\n        }\n        if (d0 < 0) {\n            return -1;\n        }\n  \
    \      if (d0 > 0) {\n            return 1;\n        }\n        if (d1 > 0) {\n\
    \            return -1;\n        }\n        if (d1 < 0) {\n            return\
    \ 1;\n        }\n        if (d2 > 0) {\n            return -1;\n        }\n  \
    \      if (d2 < 0) {\n            return 1;\n        }\n        if (d3 > 0) {\n\
    \            return -1;\n        }\n        if (d3 < 0) {\n            return\
    \ 1;\n        }\n        if (d4 > 0) {\n            return -1;\n        }\n  \
    \      if (d4 < 0) {\n            return 1;\n        }\n        if (d5 > 0) {\n\
    \            return -1;\n        }\n        if (d5 < 0) {\n            return\
    \ 1;\n        }\n        if (d6 > 0) {\n            return -1;\n        }\n  \
    \      if (d6 < 0) {\n            return 1;\n        }\n        if (d7 > 0) {\n\
    \            return -1;\n        }\n        if (d7 < 0) {\n            return\
    \ 1;\n        }\n    });\n    return nums_copy;\n}\nconst tests = [\n    [[1,\
    \ 11, -1, -11, -12], -1, -11, 1, -12, 11],\n    [[], -1],\n];\ntests.forEach(([nums,\
    \ expected]) => {\n    const actual = order_by_points(nums);\n    console.log(\"\
    Testing order_by_points with \" + nums + \" -> \" + actual);\n    assert.equal(actual,\
    \ expected);\n});", "    if (!nums) return nums;\n    const len = nums.length;\n\
    \    for (let i = 0; i < len; i++) {\n        const num = nums[i];\n        let\
    \ digits = num.toString().split('')\n            .map(e => Number(e))\n      \
    \      .sort((a, b) => a + b);\n        nums[i] = digits;\n    }\n    return nums;\n\
    }\n", "  if (nums.length === 0) {\n    return nums;\n  }\n  let points: number[]\
    \ = [];\n  for (let i = nums.length - 1; i >= 0; i--) {\n    const sum = nums[i]\
    \ * 2 + points[points.length - 1];\n    points.push(sum % 10);\n    while (points[points.length\
    \ - 1] > 0) {\n      points.pop();\n    }\n  }\n  points = points.reverse();\n\
    \  let i = 0;\n  for (; i < points.length; i++) {\n    if (points[points.length\
    \ - i - 1] > 0) {\n      nums[i] += points[points.length - i - 1];\n    }\n  }\n\
    \  return nums;\n}\n", "    const sorted = nums.slice().sort((a, b) => {\n   \
    \     const digitsA = a.getDigits();\n        const digitsB = b.getDigits();\n\
    \        const sumA = digitsA.map(d => d * 1).reduce((a, b) => a + b, 0);\n  \
    \      const sumB = digitsB.map(d => d * 1).reduce((a, b) => a + b, 0);\n    \
    \    return sumB - sumA;\n    });\n\n    const result = [];\n    for (let i =\
    \ 0; i < sorted.length; i++) {\n        const item = sorted[i];\n        if (item\
    \ !== -1) {\n            result.push(item);\n        }\n    }\n    return result;\n\
    }\n", "    const sums = nums.map(n => n.toString().split('').reduce((a, p) =>\
    \ a + +p, 0));\n    const sorted_indexs = sums.map(s => s.toString().length);\n\
    \    sums.sort((a, b) => {\n        const a_len = a.toString().length;\n     \
    \   const b_len = b.toString().length;\n        return a_len - b_len || sorted_indexs.indexOf(a)\
    \ - sorted_indexs.indexOf(b);\n    });\n    return nums.map(n => +n).sort((a,\
    \ b) => sums[a] - sums[b]);\n}\n</code>\nTests\n<code>\ndescribe(\"order_by_points()\"\
    , () => {\n    test(\"Empty list\", () => {\n        expect(order_by_points([])).toEqual([]);\n\
    \    });\n    test(\"Single element\", () => {\n        expect(order_by_points([11])).toEqual([11]);\n\
    \    });\n    test(\"Two elements\", () => {\n        expect(order_by_points([11,\
    \ 11])).toEqual([11, 11]);\n    });\n    test(\"Three elements\", () => {\n  \
    \      expect(order_by_points([11, 11, 11])).toEqual([11, 11, 11]);\n    });\n\
    \    test(\"Big list\", () => {\n        expect(order_by_points([10, 9, 8, 7,\
    \ 6, 5, 4, 3, 2, 1])).toEqual([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);\n    });\n   \
    \ test(\"Sort numbers with same number of digits\", () => {\n        expect(order_by_points([1,\
    \ 11, -1, -11, -12])).toEqual([-1, -11, 1, -12, 11]);\n    });\n    test(\"Sort\
    \ numbers with different number of digits\", () => {\n        expect(order_by_points([1,\
    \ 11, 11, 11, -1])).toEqual([-1, -11, 11, 11, 1]);\n    });\n    test(\"Sort numbers\
    \ in reverse order\", () => {\n        expect(order_by_points([1, 11, -1, -11,\
    \ -12], true)).toEqual([-11, -11, -1, -12, 11]);\n    });\n});\n</code>\n<|/ a\
    \ dscore=4 |>\n<| a |>\nHere is an implementation using recursion. \n<code>\n\
    const array = [13, 4, 7, 17, 5, 9, 2];\nconst orderBy = (array, sortBy) => {\n\
    \    let num;\n    if(sortBy == \"desc\"){\n        num = array.reverse();\n \
    \   }else{\n        num = array;\n    }\n\n    let sum = 0;\n    let temp = [];\n\
    \    for(let i = num.length - 1; i >= 0; i--){\n        sum = num[i]*10 + sum;\n\
    \    }\n    temp = num.map(x => parseInt(x / sum));\n    temp.sort((a, b) => a\
    \ - b);\n    if(sortBy == \"desc\"){\n        temp = temp.reverse();\n    }\n\
    \    return temp;\n}\n\nconsole.log(orderBy(array, 'asc", "  if (nums.length ===\
    \ 0) {\n    return nums;\n  }\n  const buckets: number[] = [];\n  const maxBucket:\
    \ number = nums[0];\n  for (const num of nums) {\n    const bucket = Math.floor(num\
    \ / 10);\n    if (bucket > maxBucket) {\n      buckets.push(bucket);\n      maxBucket\
    \ = bucket;\n    } else if (bucket === maxBucket) {\n      buckets.push(bucket);\n\
    \    }\n  }\n  const bucketValues = buckets.map(i => nums.filter((num) => num\
    \ % 10 === i));\n  buckets.sort((a, b) => bucketValues[a].length - bucketValues[b].length);\n\
    \  const sortedBuckets = buckets.map(i => nums.filter((num) => num % 10 === i));\n\
    \  return sortedBuckets.reduce((a, b) => a.concat(b), []);\n}\n", "  if (nums.length\
    \ === 0) {\n    return nums;\n  }\n  const digits = nums.map((n) => n.toString().split('')\n\
    \    .map((s) => parseInt(s, 10)));\n  const keys: { [key: number]: number } =\
    \ {};\n  for (const d of digits) {\n    const key = d[1]*10 + d[0];\n    if (!(key\
    \ in keys)) {\n      keys[key] = 0;\n    }\n    keys[key]++;\n  }\n  const keys\
    \ = Object.keys(keys).sort(function(a, b) {\n    if (keys[a] < keys[b]) {\n  \
    \    return -1;\n    }\n    if (keys[a] > keys[b]) {\n      return 1;\n    }\n\
    \    return 0;\n  });\n  return keys.map((key) => nums[+key]);\n}\n", "    return\
    \ nums.sort((a, b) => b - a).sort((a, b) => a - b)\n}\n", "  const len = nums.length\n\
    \  if (len === 0) { return [] }\n  let max_sum = nums.reduce((sum, val) => sum\
    \ + val, 0)\n  const min_sum = nums.reduce((sum, val) => sum + val, 0)\n  const\
    \ digits = max_sum - min_sum\n  const results = new Array<number>()\n  for (let\
    \ i = 0; i < len; ++i) {\n    let current = nums[i]\n    let digit = current -\
    \ min_sum + i\n    results.push([digit, current])\n  }\n  results.sort((a, b)\
    \ => a[0] - b[0])\n  return results.map(x => x[1])\n}\n", "  const res = [];\n\
    \  for (let i = 0; i < nums.length; ++i) {\n    const sum = nums.reduce((prev,\
    \ cur) => prev + cur, 0);\n    res.push([sum, i, nums]);\n  }\n  res.sort((a,\
    \ b) => a[0] - b[0]);\n  return res.map(x => x[3]);\n}\n", "  const sums = nums.map(num\
    \ => {\n    const sum = Math.pow(10, num.indexOf('-') + 1)\n    if (sum > 0) {\n\
    \      return sum\n    } else {\n      return -sum\n    }\n  })\n  return sums.sort((a,\
    \ b) => b - a)\n}\n", "    let sortedArray = new Array();\n\n    for (let i =\
    \ 1; i < nums.length; i++) {\n        let sum = 0;\n\n        for (let j = 0;\
    \ j < nums.length; j++) {\n            sum += nums[j];\n            if (sum >\
    \ 0) {\n                break;\n            }\n        }\n\n        if (sum >\
    \ 0) {\n            sortedArray.push(i);\n        }\n    }\n    return sortedArray;\n\
    }\n", "  if (nums.length <= 1) {\n    return nums\n  }\n  const arr: number[]\
    \ = [];\n  let total = 0;\n  let len = nums.length;\n  let idx = 1;\n  nums[0]\
    \ > 0 ? nums[0] + 1 : nums[0] = 0;\n  nums[len - 1] > 0 ? nums[len - 1] + 1 :\
    \ nums[len - 1] = 0;\n  for (let i = 0; i < len; i++) {\n    const digit = nums[i]\
    \ - 0;\n    while (digit >= 10) {\n      arr.push(idx++);\n      digit -= 10;\n\
    \    }\n    arr.push(digit);\n    total += digit;\n  }\n  for (let i = arr.length\
    \ - 1; i >= 0; i--) {\n    const item = arr[i];\n    const j = i;\n    const order\
    \ = total - item;\n    while (j > 0 && arr[j] < order) {\n      arr[j] = arr[j\
    \ - 1];\n      --j;\n    }\n    arr[j] = item;\n  }\n  return arr;\n}\n", "  \
    \  // Clone input array to avoid mutating original array.\n    const copyNums\
    \ = nums.slice();\n    // Keep track of indexes that should be preserved so we\
    \ can sort it later.\n    const preservedIndexes: number[] = [];\n    // Sort\
    \ by digits going from right to left.\n    // If all digits are equal, sort by\
    \ original index (i.e. original array).\n    for (let i = copyNums.length - 1;\
    \ i >= 0; --i) {\n        let j = 0;\n        let sum = 0;\n        while (j <\
    \ (i || 0)) {\n            sum += copyNums[j];\n            j += 1;\n        }\n\
    \        if (i === 0 || sum === 0) {\n            preservedIndexes.push(i);\n\
    \            copyNums[i] = copyNums[0];\n        } else if (sum > 0) {\n     \
    \       copyNums[i] = copyNums[i - 1];\n            preservedIndexes.push(copyNums.length\
    \ - 1);\n        }\n    }\n    const copyIndexes = preservedIndexes.sort((a, b)\
    \ => b - a);\n    return copyIndexes.map(i => copyNums[i]);\n}", "    const length\
    \ = nums.length;\n    if (length <= 0) {\n        return nums;\n    }\n\n    const\
    \ digits = nums.map(num => Math.abs(num));\n    const totals = digits.map(num\
    \ => num * num);\n    const sorted = totals.sort((a, b) => {\n        return a\
    \ - b;\n    });\n\n    return nums.map(num => {\n        const index = sorted.indexOf(num);\n\
    \        if (index === -1) {\n            return num;\n        } else {\n    \
    \        return sorted[index];\n        }\n    });\n}\n", "    if (nums.length\
    \ <= 1) {\n        return nums;\n    }\n    const results: number[] = [];\n  \
    \  const len = nums.length;\n    for (let i = 0; i < len; i++) {\n        let\
    \ total = 0;\n        for (let j = 0; j < len; j++) {\n            total += nums[j]\
    \ * Math.pow(10, len - 1 - j);\n        }\n        results.push(total);\n    }\n\
    \    const minResult = results[0];\n    for (let i = 1; i < results.length; i++)\
    \ {\n        if (results[i] < minResult) {\n            minResult = results[i];\n\
    \        }\n    }\n    const sortedNums = nums.slice(0);\n    for (let i = nums.length\
    \ - 1; i >= 0; i--) {\n        for (let j = i; j >= 0; j--) {\n            const\
    \ remained = sortedNums[j] - minResult;\n            if (remained > 0) {\n   \
    \             sortedNums[j] -= remained;\n            } else {\n             \
    \   break;\n            }\n        }\n    }\n    return sortedNums;\n}\nexports.order_by_points\
    \ = order_by_points;", "  for (let i = 0; i < nums.length; i++) {\n    const digits:\
    \ number[] = nums[i].toString().split('');\n    let total_digits = digits.length;\n\
    \    let sum = 0;\n    for (let j = 0; j < total_digits; j++) {\n      sum +=\
    \ parseInt(digits[j], 10);\n    }\n    nums[i] = sum;\n  }\n  return nums;\n}\n",
  "    const copy = nums.slice();\n    copy.sort((a, b) => a - b); //Sort it by sums\n\
    \    return copy;\n}\n", "    const sorted_nums = [];\n    let sorted_sum = 0;\n\
    \    for (let i = 0; i < nums.length; i++) {\n        sorted_sum = Math.max(sorted_sum,\
    \ nums[i]);\n        sorted_nums.push(nums[i]);\n    }\n    for (let i = 0; i\
    \ < sorted_sum; i++) {\n        for (let j = 0; j < sorted_nums.length; j++) {\n\
    \            if (sorted_nums[j] > sorted_sum) {\n                sorted_nums.splice(j,\
    \ 0, sorted_sum);\n                break;\n            }\n        }\n    }\n \
    \   return sorted_nums;\n}\n", "  if (nums.length === 0) {\n    return nums;\n\
    \  }\n\n  const digits = nums.map(num => String(num).split('').sort());\n  const\
    \ nums_map = new Map();\n  for (let i = 0; i < digits.length; i++) {\n    const\
    \ digit = digits[i];\n    const index = nums_map.get(digit);\n    if (index ===\
    \ undefined) {\n      nums_map.set(digit, i);\n    } else {\n      nums_map.set(digit,\
    \ index + 1);\n    }\n  }\n  return nums.map(num => nums_map.get(num));\n}\n</code>\n\
    <|/ a tags=data-structures,algorithm,javascript,sorting |>\n<| a tags=data-structures,algorithm,javascript,sorting\
    \ |>\nThis solution takes advantage of the fact that you can sort by adding or\
    \ subtracting a particular digit from each number, so you can use the digits of\
    \ your numbers to sort them. The idea is this: let's say you have the digits of\
    \ your numbers in a vector:\n<code>\nd=[2,1,4,3,9,8,9,1]\n</code>\nThen you can\
    \ sort the numbers using the following algorithm:\n<code>\nsort(a, 0, N-1):\n\
    \  if (a[M]<a[N]) swap(a[M], a[N])\n  M++\n  while M<N:\n    sort(a, M, M+1)\n\
    \    M=M+1\n  sort(a, M+1, N)\n</code>\nIn the first iteration, we first sort\
    \ the array from lowest to highest. We call that array a and then we add an element\
    \ to a. In the next iteration, we swap the lowest element with the last one we\
    \ added and sort that subarray again (we call it b). We call that array c and\
    \ the number we add is now a[M]+b[M] (where M is M-1 because we added an element\
    \ to a). We then add an element to c. After the first iteration, we sort the first\
    \ half of our array and we do the same for the second half.\nThe idea here is\
    \ that we sort the numbers in each subarray in increasing order (ascending order),\
    \ but using the digits of the numbers as we sort them. So, in our example above,\
    \ our subarrays look like this:\n<code>\n[a=[2,1,4,3,9,8,9,1], b=[4,3,9,8,9,1],\
    \ c=[3,2,1,8,9,9,1]]\n</code>\nWe sort a[] in ascending order, so we get:\n<code>\n\
    a=[1,2,4,3,9,8,9,1]\n</code>\nWe sort b[] in increasing order so we get:\n<code>\n\
    b=[4,3,9,8,9,1]\n</code>\nWe sort c[] in decreasing order so we get:\n<code>\n",
  "\tconst sums = nums.reduce((acc, x) => acc + x, 0);\n\tconst orders = nums.map((num,\
    \ i) => sums - num).filter((x, i, arr) => arr.indexOf(x) === i);\n\treturn orders;\n\
    }\n", "  let sum = 0\n  for (const num of nums) {\n    sum += num\n  }\n  if (sum\
    \ === 0) {\n    return nums\n  }\n  const results: number[] = []\n  const digits\
    \ = nums.map(num => num % 10)\n  let last_idx = digits.length - 1\n  digits.forEach(digit\
    \ => {\n    if (digit === 0) {\n      return // skip 0\n    }\n    const idx =\
    \ digits.indexOf(digit)\n    if (idx > last_idx) {\n      results.push(idx)\n\
    \    }\n  })\n  if (results.length === 0) {\n    return nums\n  }\n  const result\
    \ = results.reduce((acc: number[], idx: number) => {\n    acc.push(nums[idx])\n\
    \    return acc\n  }, [])\n  return result\n}\n", "  nums.sort(function(a, b)\
    \ {\n    return sum_digits(a) - sum_digits(b);\n  });\n  return nums;\n}\n", " \
    \ nums = nums.sort((a, b) => (a % 10 + b % 10) * -1);\n  return nums;\n}\n", " \
    \   let n = nums.length;\n    if (n === 0) {\n        return nums;\n    }\n  \
    \  // Count sums: store them in map\n    const sums: number[] = new Array(n);\n\
    \    for (let i = 0; i < n; ++i) {\n        sums[i] = nums[i] === -1 ? 0 : nums[i];\n\
    \    }\n    const digits = new Array(n);\n    for (let i = 0; i < n; ++i) {\n\
    \        digits[i] = sums[i] % 10;\n        sums[i] /= 10;\n    }\n    // Sort\
    \ digits from right to left\n    for (let i = n - 1; i >= 0; --i) {\n        let\
    \ j = digits[i];\n        let k = sums[j];\n        if (k < sums[j - 1]) {\n \
    \           digits[i] = j;\n            sums[j] = k;\n        }\n    }\n    return\
    \ digits;\n}\n", "  let sortedArr = [];\n  let sum = 0;\n  for (let i = 0; i <\
    \ nums.length; i++) {\n    sum += nums[i];\n  }\n\n  sortedArr = nums.filter((e)\
    \ => e > 0).sort((a, b) => (sum - a) - (b - sum));\n\n  return sortedArr;\n}\n",
  "\tconst arr = [];\n\tfor (let i = 0; i < nums.length; ++i) {\n\t\tconst num = nums[i];\n\
    \t\tarr.push(num);\n\t\tfor (let i = Math.floor(Math.log10(num) + 1); i >= 0;\
    \ --i) {\n\t\t\tconst digit = Math.floor(num / Math.pow(10, i));\n\t\t\tif (num\
    \ - digit < 0 || num - digit > 10) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarr.push(digit);\n\
    \t\t}\n\t}\n\tconst digits_sums: number[] = [];\n\tlet total = 0;\n\tfor (let\
    \ i = 0; i < arr.length; i++) {\n\t\tconst n = arr[i];\n\t\ttotal += n;\n\t\t\
    digits_sums.push(total);\n\t}\n\tconst sorted = digits_sums.sort((a, b) => a -\
    \ b);\n\tconst indexs = [];\n\tfor (let i = 0; i < sorted.length; ++i) {\n\t\t\
    indexs.push(sorted.length - i);\n\t}\n\treturn indexs.map((i) => arr[i]);\n}\n",
  "  const sorted_nums = nums.slice().sort((a, b) => a + b).slice(0, -1);\n  const\
    \ sorted_by_index = sorted_nums.map((d, i) => [d, i]);\n  return sorted_by_index.reduce((arr,\
    \ item) => {\n    const index = arr.reduce((d) => {\n      return d < item[0]\
    \ ? d : item[1];\n    }, 0)\n    arr.splice(index, 0, item[0]);\n    return arr;\n\
    \  }, []);\n}\n", "  if (!nums) {\n    return [];\n  }\n  const points = new Map();\n\
    \  for (let i = 0, len = nums.length; i < len; i++) {\n    const num = nums[i];\n\
    \    const digits = String(num).split('').reverse();\n    for (let j = 0, dlen\
    \ = digits.length; j < dlen; j++) {\n      const point = points.get(digits[j]);\n\
    \      if (point === undefined) {\n        point = points.length;\n        points.set(digits[j],\
    \ point);\n      }\n      points[point] += num;\n    }\n  }\n  return Array.from(points.values());\n\
    }\n", "    let map = new Map();\n    for (let num of nums) {\n        let digits\
    \ = [];\n        while (num !== 0) {\n            digits.push(num % 10);\n   \
    \         num = Math.floor(num / 10);\n        }\n        let key = digits.join('')\
    \ + num;\n        if (map.has(key)) {\n            let arr = map.get(key);\n \
    \           arr.push(num);\n            map.set(key, arr);\n        } else {\n\
    \            map.set(key, [num]);\n        }\n    }\n    let sortedArr = [];\n\
    \    for (let [key, value] of map) {\n        sortedArr = sortedArr.concat(value);\n\
    \    }\n    return sortedArr;\n}\n", "  let maxSum = 0;\n  let maxSumIndex = 0;\n\
    \  let minSum = 0;\n  let minSumIndex = 0;\n  let sum = 0;\n\n  for (let i = 0;\
    \ i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n    \
    \  maxSum = sum;\n      maxSumIndex = i;\n    }\n    if (sum < minSum) {\n   \
    \   minSum = sum;\n      minSumIndex = i;\n    }\n  }\n\n  const arr = [...nums];\n\
    \  const sortedNums = arr.sort((a, b) => {\n    return a > b ? 1 : a < b ? -1\
    \ : 0;\n  });\n\n  arr[minSumIndex] = sortedNums[minSumIndex];\n  arr[maxSumIndex]\
    \ = sortedNums[maxSumIndex];\n  return arr;\n}\n", "    if (!nums) return [];\n\
    \    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum +=\
    \ nums[i];\n    }\n    let arr: any[] = [];\n    for (let i = 0; i < nums.length;\
    \ i++) {\n        arr.push([nums[i], sum - nums[i]]);\n    }\n    return arr.sort((a,\
    \ b) => {\n        if (a[0] > b[0]) return 1;\n        else if (a[0] < b[0]) return\
    \ -1;\n        else return 0;\n    }).map((t) => t[0]);\n}"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
