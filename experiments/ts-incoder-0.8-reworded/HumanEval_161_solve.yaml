name: HumanEval_161_solve
language: ts
prompt: "//You are given a string s.\n// if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string\
  \ contains no letters, reverse the string.\n// The function should return the resulted\
  \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
  )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunction solve(s: string): string\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = solve;\n  assert.deepEqual(candidate(\"AsDf\"),\"\
  aSdF\");\n  assert.deepEqual(candidate(\"1234\"),\"4321\");\n  assert.deepEqual(candidate(\"\
  ab\"),\"AB\");\n  assert.deepEqual(candidate(\"#a@C\"),\"#A@c\");\n  assert.deepEqual(candidate(\"\
  #AsdfW^45\"),\"#aSDFw^45\");\n  assert.deepEqual(candidate(\"#6@2\"),\"2@6#\");\n\
  \  assert.deepEqual(candidate(\"#$a^D\"),\"#$A^d\");\n  assert.deepEqual(candidate(\"\
  #ccc\"),\"#CCC\");\n}\n\ntest();"
completions: ["    let answer = s.split('');\n    for (let i = 0; i < answer.length;\
    \ i++) {\n        if (answer[i] === letterToUpperCase(answer[i])) {\n        \
    \    answer[i] = letterToUpperCase(answer[i]);\n        } else if (answer[i] ===\
    \ letterToLowerCase(answer[i])) {\n            answer[i] = letterToLowerCase(answer[i]);\n\
    \        } else if (answer[i] === letterToTitleCase(answer[i])) {\n          \
    \  answer[i] = letterToTitleCase(answer[i]);\n        }\n    }\n    return answer.join('');\n\
    }\n", "    const lower = /[a-z]+/gi;\n    const upper = /[A-Z]+/gi;\n\n    return\
    \ s.replace(lower, upper).replace(upper, lower);\n}\n\n<|/ file filename=leetcode.js\
    \ |>\n<| c |>\nI don't understand your solution. Could you give an example? The\
    \ one I wrote seems to work.\n<|/ c |>\n<| c |>\nI've updated my answer. Hope\
    \ that helps!\n<|/ c |>\n<| c |>\nthanks a lot! that makes a lot of sense. I had\
    \ misunderstood the purpose of the toLowerCase method.\n<|/ c |>\n<| a tags=javascript\
    \ |>\n<code>", "    let result = '';\n    for (let i = 0; i < s.length; i += 1)\
    \ {\n        const char = s[i];\n        // case 1: If s[i] is a letter, lowercase\
    \ it and add it to the result.\n        // case 2: If s[i] is a number, reverse\
    \ it case.\n        // case 3: If s[i] is a punctuation, keep it as it is.\n \
    \       switch (char) {\n            case 'a':\n            case 'b':\n      \
    \      case 'c':\n            case 'd':\n            case 'e':\n            case\
    \ 'f':\n            case 'g':\n            case 'h':\n            case 'i':\n\
    \            case 'j':\n            case 'k':\n            case 'l':\n       \
    \     case 'm':\n            case 'n':\n            case 'o':\n            case\
    \ 'p':\n            case 'q':\n            case 'r':\n            case 's':\n\
    \            case 't':\n            case 'u':\n            case 'v':\n       \
    \     case 'w':\n            case 'x':\n            case 'y':\n            case\
    \ 'z':\n                result += char.toLowerCase();\n                break;\n\
    \            case '0':\n            case '1':\n            case '2':\n       \
    \     case '3':\n            case '4':\n            case '5':\n            case\
    \ '6':\n            case '7':\n            case '8':\n            case '9':\n\
    \                result += char.split(\"\").reverse().join(\"\");\n          \
    \      break;\n            default:\n                result += char;\n       \
    \         break;\n        }\n    }\n    if (result === '') {\n        return s.split(\"\
    \").reverse().join(\"\");\n    }\n    return result;\n}\n", "  let result: string\
    \ = \"\";\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s[i];\n\
    \    const charCode = s.charCodeAt(i);\n    if (charCode >= 65 && charCode <=\
    \ 90) {\n      result += String.fromCharCode(charCode + 32 - char);\n    } else\
    \ {\n      result += s[i];\n    }\n  }\n  return result;\n}\n", "  return s.split('').reverse().join('')\
    \ \n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    let newString\
    \ = \"\";\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] >= 'a' &&\
    \ s[i] <= 'z') {\n            newString += s[s.charCodeAt(i) - 97];\n        }\
    \ else if (s[i] >= 'A' && s[i] <= 'Z') {\n            newString += s[s.charCodeAt(i)\
    \ - 65];\n        } else {\n            newString += s[i];\n        }\n    }\n\
    \    return newString;\n}\n", "  let finalString = \"\"\n  \n  for (let i=0; i<s.length;\
    \ i++) {\n    if(s[i] >= 'a' && s[i] <= 'z') {\n      finalString = finalString.concat(s[i].toUpperCase())\n\
    \    }\n    else {\n      finalString = finalString.concat(s[i])\n    }\n  }\n\
    \  \n  return finalString.trim()\n}\n", "  const result: string = s;\n  for (let\
    \ i = 0; i < result.length; i++) {\n    const letter = result[i];\n    if (letter\
    \ === letter.toLowerCase()) {\n      result[i] = letter.toUpperCase();\n    }\n\
    \    else if (letter === letter.toUpperCase()) {\n      result[i] = letter.toLowerCase();\n\
    \    }\n  }\n  return result;\n}\n", "  for (let i = 0; i < s.length; i++) {\n\
    \    if (s[i] >= 'A' && s[i] <= 'Z') {\n      s[i] = s[i].toUpperCase();\n   \
    \ } else if (s[i] >= 'a' && s[i] <= 'z') {\n      s[i] = s[i].toLowerCase();\n\
    \    }\n  }\n  return s.split('').reverse().join('');\n}\n", "  s = s.replace(/@/g,\
    \ \"\");\n  return s.replace(/[a-z]/gi, (char: string) => {\n    return char.toLowerCase()\
    \ === char ? char.toUpperCase() : char;\n  }).replace(/[^a-zA-Z0-9]/gi, (char:\
    \ string) => {\n    return char.toUpperCase();\n  });\n}\n\nconsole.log(solve(\"\
    aaa\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"abacad\"));</code>\n\
    <|/ a tags=javascript,algorithm dscore=2 |>\n<| c |>\nNicely done! One minor suggestion:\
    \ you can replace `/[^a-zA-Z0-9]/` with `/\\D/`\n<|/ c |>\n<| c |>\nThanks, indeed\
    \ that would work and it's faster! I'll update my answer.\n<|/ c |>\n<| a tags=javascript,algorithm\
    \ dscore=1 |>\n<code>", "    let arr: string[] = s.split(\"\");\n    let res =\
    \ \"\";\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i].match(/[a-z]/i))\
    \ {\n            arr[i] = arr[i].toLowerCase();\n        } else {\n          \
    \  arr[i] = arr[i].toUpperCase();\n        }\n    }\n    res = arr.reduce((a:\
    \ string, b: string) => a + b);\n    return res.split('').reverse().join('');\n\
    }\n", "    let newString = s;\n\n    for (let i = 0; i < s.length; i += 1) {\n\
    \        const char = s.charAt(i);\n        if (isAlpha(char)) {\n           \
    \ const letter = char.toLowerCase();\n\n            if (newString.includes(letter))\
    \ {\n                newString = newString.replace(letter, letter.toUpperCase());\n\
    \            } else {\n                newString = newString.replace(char, char.toLowerCase());\n\
    \            }\n        }\n    }\n\n    if (newString.length === 0) return s;\n\
    \n    return newString;\n}\n", "  s = s.toLowerCase();\n  if (s.length === 0)\
    \ {\n    return s;\n  }\n\n  const arr = [...s];\n\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    const char = arr[i];\n\n    if (char.charCodeAt(0) >= 48 && char.charCodeAt(0)\
    \ <= 57) {\n      arr[i] = String.fromCharCode(char.charCodeAt(0) + 32);\n   \
    \ } else if (char.charCodeAt(0) >= 65 && char.charCodeAt(0) <= 90) {\n      arr[i]\
    \ = String.fromCharCode(char.charCodeAt(0) - 26);\n    }\n  }\n\n  return arr.join('');\n\
    }\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"\
    #a@C\"));\nconsole.log(solve(\"123\"));\nconsole.log(solve(\"1-2-3\"));\nconsole.log(solve(\"\
    123A456\"));\nconsole.log(solve(\"123A456\"));\nconsole.log(solve(\"123abc\"));\n\
    console.log(solve(\"123abc\"));\nconsole.log(solve(\"1234\"));</code>\n<|/ a tags=javascript,arrays\
    \ |>\n<| a dscore=0 |>\nI see this as a case for using RegEx for character set\
    \ checking. For instance\n<code>\nconst solve = str => {\n  const re = /^[A-Za-z0-9]+$/;\n\
    \  const isLetter = char => {\n    return /[A-Za-z]/.test(char);\n  };\n  const\
    \ checkChar = char => {\n    if (re.test(char)) {\n      return char.toUpperCase();\n\
    \    } else {\n      return char;\n    }\n  };\n  return str.split('').map(checkChar).join('');\n\
    };\n</code>\n<|/ a tags=javascript,arrays |>\n<| a |>\n<code>\nconst solution\
    \ = (string) => {\n  let reverse = ''\n  const regex = /[A-z]+/g\n  string.split('')\n\
    \    .map((char) => {\n      return regex.test(char) ? char.toUpperCase() : char\n\
    \    })\n    .join('')\n    .match(regex).reverse().join('')\n    .match(regex).reverse().join('')\n\
    \    .match(regex).reverse().join('')\n    .match(regex).reverse().join('')\n\
    \    .match(regex).reverse().join('')\n    .match(regex).reverse().join('')\n\
    \    .match(regex).reverse().join('')\n    .match(regex).reverse().join('')\n\
    \    .match(regex).reverse().join('')\n    .match(regex).reverse().join('')\n\
    \    .match(regex).reverse().join('')\n    .match(regex).reverse().join('')\n\
    \    .match(regex).reverse().join('')\n    .match(regex).reverse().join('')\n\
    \    .match(regex).reverse().join('')\n    .match(regex).reverse().join('')\n\
    \    .match(regex).reverse().", "    let arr: string[] = s.split(\"\");\n    return\
    \ arr.map((el) => {\n        let lower = el.toLowerCase();\n        let upper\
    \ = el.toUpperCase();\n        if (el === lower) {\n            return upper;\n\
    \        }\n        if (el === upper) {\n            return lower;\n        }\n\
    \        return el;\n    }).join(\"\");\n}\n</code>\n<|/ a tags=javascript |>\n\
    <| c |>\nThis works but doesn't answer the question because you reversed \"1\"\
    \ and \"2\" rather than \"1\" and \"3\"\n<|/ c |>\n<| c |>\nThank you for the\
    \ comment. I added some more comments to the answer, hope it helps. :)\n<|/ c\
    \ |>\n<| a |>\nYou can reverse characters by looping through characters. \n<code>\n\
    var str = \"abc\";\nvar newStr = str.reverse();\n</code>\n<|/ a tags=javascript\
    \ dscore=0 |>\n<| c |>\nThis will not reverse the order of the letters, but reverse\
    \ the order of the characters.\n<|/ c |>\n<| c |>\nOh, I missed that point. Thanks\
    \ for pointing it out!\n<|/ c |>\n<| a |>\n<code>", "  let result: string = \"\
    \"\n  for (let i = 0; i<s.length; i++){\n    if(s[i].match(/[a-z]/i)) result =\
    \ s[i].toUpperCase() + result\n    else result = s[i].toLowerCase() + result\n\
    \  }\n  return result\n}\n\nsolve(\"ab\") //AB\nsolve(\"a\") //a\nsolve(\"ab1\"\
    ) //Ab1\nsolve(\"a1b1\") //a1B1\nsolve(\"a1b1\") //a1B1 \n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 tags=javascript,string |>\nOne more approach with Array.from\
    \ and String#replace methods:\n\n<code>", "  s = s.replace(/\\W+/g, \"\").toLowerCase();\n\
    \  if (s.length === 0) {\n    return s;\n  }\n  if (s.match(/[a-z]/i)) {\n   \
    \ return s.match(/[a-z]/i)\n      .map((x) => { return {lower: x.toLowerCase(),\
    \ upper: x.toUpperCase()}; })\n      .reduce((a, b) => a.lower < b.lower ? a :\
    \ b);\n  }\n  return s.match(/[0-9]/)\n    .map((x) => { return {lower: x.toLowerCase(),\
    \ upper: x.toUpperCase()}; })\n    .reduce((a, b) => a.lower < b.lower ? a : b);\n\
    }</code>\n\nHope this helps.\n<|/ a tags=javascript,algorithm,string,arrays,sorting\
    \ |>\n<| c |>\nThis isn't very efficient, isn't it?\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for the example: \"#a@c\", because it's only checking for lowercase and\
    \ it's checking just \"a\" and not \"a@c\". I'd say this is the right answer though.\n\
    <|/ c |>\n<| c |>\nIt does work for the example. Just try the example in your\
    \ code snippet.\n<|/ c |>\n<| c |>\nWhat do you mean by \"It doesn't work\"? If\
    \ you meant it only works for the lowercase version of the string, then the function\
    \ works. If you meant it works only for uppercase version of the string, then\
    \ my code doesn't work.\n<|/ c |>\n<| c |>\nI mean, when I put this example in\
    \ my code it only works if the first letter in the string is uppercase. It doesn't\
    \ work if the letters are lowercase\n<|/ c |>\n<| a tags=javascript,algorithm,string,arrays,sorting\
    \ dscore=2 |>\nA very simple solution using string slice and string reverse functions:\n\
    <code>", "    \n    let result = \"\";\n    let charMap = new Map<string, string>();\n\
    \n    for (let i = 0; i < s.length; i++){\n        let curr = s[i];\n        let\
    \ lower = curr.toLowerCase();\n        let upper = curr.toUpperCase();\n\n   \
    \     let lowerChar = charMap.get(lower);\n        let upperChar = charMap.get(upper);\n\
    \n        if (lowerChar !== undefined) {\n            if (upperChar === undefined)\
    \ {\n                result += upperChar;\n            } else {\n            \
    \    result += lowerChar + upperChar;\n            }\n            charMap.delete(lower);\n\
    \        } else {\n            result += curr;\n            charMap.set(curr,\
    \ curr);\n        }\n    }\n\n    if (charMap.size > 0){\n        for (let i =\
    \ 0; i < charMap.keys.length; i++) {\n            result += charMap.get(charMap.keys[i]);\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    I ran your code and it works, but it doesn't work when there is multiple capital\
    \ letters next to each other, for example, in the string \"aAa#\" it returns \"\
    aAa#\". Also, your code only works for a single capital letter next to each other,\
    \ like \"AB#\" returns \"B#\", but your expected output should be \"b#\". Is that\
    \ because of your code? or did you just revise it? Thanks\n<|/ c |>\n<| a tags=algorithm,string,javascript\
    \ |>\n<code>", "    \n    let i = 0;\n    let result: string = '';\n\n    while\
    \ (i < s.length) {\n        let c = s[i];\n        \n        if (c >= 'a' && c\
    \ <= 'z') {\n            result = (c === 'z') ? result : result + c.toLowerCase();\n\
    \        } else if (c >= 'A' && c <= 'Z') {\n            result = (c === 'Z')\
    \ ? result : result + c.toUpperCase();\n        } else if (c >= '0' && c <= '9')\
    \ {\n            result = (c === '0') ? result : result + c;\n        }\n    \
    \    \n        i++;\n    }\n    return result.length === 0 ? s.split('').reverse().join('')\
    \ : result;\n}\n<|/ file ext=.ts source=github filename=day07.ts |>\n<| c |>\n\
    I like the solution but, for the exercise the solution should use the string class\
    \ and not any array method. I don't know what would be the best approach.\n<|/\
    \ c |>\n<| c |>\nThis solution is O(n) and also uses string methods. I would suggest\
    \ to try the one with `forEach` first.\n<|/ c |>\n<| c |>\nI didn't notice that\
    \ requirement before. I just edited my answer with working `forEach` solution.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  if (s.length == 0) return s;\n  if (s.includes('@'))\
    \ return reverse(s, 0);\n  if (s.includes('#')) return reverse(s, 1);\n  for (let\
    \ i = 0; i < s.length; i++) {\n    let ch = s[i];\n    if (ch.match(/[a-z]/i))\
    \ {\n      let rev = toUpper(ch);\n      let lower = toLower(ch);\n      if (lower.match(new\
    \ RegExp(`^${lower}$`))) rev = rev;\n      else rev = lower;\n      s[i] = rev;\n\
    \    }\n  }\n  return s;\n}\n", "  if (s.length === 0) {\n    return '';\n  }\n\
    \n  let charMap = new Map<string, string>();\n  for (let char of s) {\n    let\
    \ newChar = char.toLowerCase();\n    if (!charMap.has(newChar)) {\n      charMap.set(newChar,\
    \ char);\n    }\n  }\n\n  for (let [k, v] of charMap) {\n    charMap.set(k, v.toUpperCase());\n\
    \  }\n\n  let newString = '';\n  for (let [k, v] of charMap) {\n    newString\
    \ += v;\n  }\n\n  return newString;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,sorting,javascript\
    \ |>\n<| c |>\nPlease add some explanation to your answer\n<|/ c |>\n<| a tags=algorithm,sorting,javascript\
    \ dscore=0 |>\n<code>", "  if (s == \"\") {\n    return s;\n  }\n\n  for (let\
    \ i = 0; i < s.length; i++) {\n    let letter = s.charAt(i);\n    console.log(letter);\n\
    \    if (letter >= 'a' && letter <= 'z') {\n      s = s.split(letter).join(letter.toUpperCase());\n\
    \      console.log(s);\n    } else if (letter >= 'A' && letter <= 'Z') {\n   \
    \   s = s.split(letter).join(letter.toLowerCase());\n      console.log(s);\n \
    \   }\n  }\n  return s;\n}\n", "  var i = 0;\n  while (i<s.length){\n    if(isNaN(s[i]))\
    \ i++; \n    else \n      switch(s[i]){\n        case \"A\": s[i] = \"a\"; break;\n\
    \        case \"B\": s[i] = \"b\"; break;\n        case \"C\": s[i] = \"c\"; break;\n\
    \        case \"D\": s[i] = \"d\"; break;\n        case \"E\": s[i] = \"e\"; break;\n\
    \        case \"F\": s[i] = \"f\"; break;\n        case \"G\": s[i] = \"g\"; break;\n\
    \        case \"H\": s[i] = \"h\"; break;\n        case \"I\": s[i] = \"i\"; break;\n\
    \        case \"J\": s[i] = \"j\"; break;\n        case \"K\": s[i] = \"k\"; break;\n\
    \        case \"L\": s[i] = \"l\"; break;\n        case \"M\": s[i] = \"m\"; break;\n\
    \        case \"N\": s[i] = \"n\"; break;\n        case \"O\": s[i] = \"o\"; break;\n\
    \        case \"P\": s[i] = \"p\"; break;\n        case \"Q\": s[i] = \"q\"; break;\n\
    \        case \"R\": s[i] = \"r\"; break;\n        case \"S\": s[i] = \"s\"; break;\n\
    \        case \"T\": s[i] = \"t\"; break;\n        case \"U\": s[i] = \"u\"; break;\n\
    \        case \"V\": s[i] = \"v\"; break;\n        case \"W\": s[i] = \"w\"; break;\n\
    \        case \"X\": s[i] = \"x\"; break;\n        case \"Y\": s[i] = \"y\"; break;\n\
    \        case \"Z\": s[i] = \"z\"; break;\n        default: i++;\n      }\n  }\n\
    \  var res: string = \"\";\n  for(var j=i; j<s.length; j++){\n    res += s[j];\n\
    \  }\n  return res;\n}\n", "  for (let i = 0; i < s.length; ++i) {\n    if (s.charCodeAt(i)\
    \ >= 65 && s.charCodeAt(i) <= 90) {\n      s = s.substr(0, i) + s.substr(i + 1,\
    \ 1).toLowerCase() + s.substr(i + 2, s.length);\n    }\n  }\n  return s;\n}\n",
  "  const newString = \"\";\n  for(let i = 0; i < s.length; i++) {\n    const ch\
    \ = s.charAt(i)\n    if(isNaN(ch)) continue;\n    if(isLetter(ch)) {\n      newString\
    \ = newString.concat(\n        ch,\n        ch.toLowerCase() === ch ? ch.toUpperCase()\
    \ : ch.toLowerCase()\n      )\n    } else {\n      newString = newString.concat(ch)\n\
    \    }\n  }\n  \n  if(newString === \"\") return s;\n  return newString;\n}\n",
  "    let result: string = s;\n    for (let i = 0; i < s.length; ++i) {\n       \
    \ let letter: string = s[i];\n        if (letter === letter.toUpperCase()) {\n\
    \            result = result.replace(letter, letter.toLowerCase());\n        }\
    \ else {\n            result = result.replace(letter, letter.toUpperCase());\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is\
    \ very similar to my solution. However OP wants to remove the spaces at the end\
    \ of the string.\n<|/ c |>\n<| c |>\nThe example code in the question doesn't\
    \ have a space at the end. He stated he wants the spaces to beat the letters and\
    \ letters to the end of the string so the code will remove spaces at the end.\n\
    <|/ c |>\n<| c |>\nYes, your solution is correct. I just thought it would be more\
    \ useful to show the actual code. Thank you.\n<|/ c |>\n<| c |>\nYes, I did not\
    \ think about the fact that it could have spaces at the end but this should work\
    \ fine as well.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "    return s.split('').reduce((acc,\
    \ curr) => {\n        if (curr >= 'a' && curr <= 'z') {\n            return `${acc}${curr.toUpperCase()}`;\n\
    \        } else if (curr >= 'A' && curr <= 'Z') {\n            return `${acc}${curr.toLowerCase()}`;\n\
    \        } else {\n            return acc;\n        }\n    }, '');\n}\n", "  \
    \  let result = '';\n    for (let i = 0; i < s.length; i++) {\n        if (s[i]\
    \ >= 'a' && s[i] <= 'z')\n            result += s.substring(i, s[i].toUpperCase());\n\
    \        else if (s[i] >= 'A' && s[i] <= 'Z')\n            result += s.substring(i,\
    \ s[i].toLowerCase());\n        else\n            result += s[i];\n    }\n   \
    \ return result;\n}\n", "  \n  s = s.toUpperCase();\n\n  if (s.length === 0) {\n\
    \    return s;\n  }\n\n  if (s.includes('A') && s.includes('a')) {\n    return\
    \ s.replace('A', 'a').replace('a', 'A');\n  }\n\n  else if (s.includes('a') &&\
    \ s.includes('A')) {\n    return s.replace('a', 'A').replace('A', 'a');\n  }\n\
    \n  else {\n    return s;\n  }\n}\n", "    let reverse = s.split('').reverse().join('');\n\
    \    return reverse.split('').map(x => x === '@' ? x.toUpperCase() : x.toLowerCase()).join('');\n\
    }\n</code>\nThe above function is pretty straightforward and easy to understand.\
    \ Now we can use map function and join to get the final result. The above solution\
    \ is not the best but it's a good exercise to learn about functional programming.\n\
    Let's make it better!\n<code>", "  for (let i = 0; i < s.length; i++){\n    if\
    \ (!isLetter(s[i])) {\n      s = s.toUpperCase();\n      break;\n    } else {\n\
    \      s = s.toLowerCase();\n      break;\n    }\n  }\n\n  return s;\n}\n", " \
    \   \n    let reversedString = s.split('')\n        .reverse()\n        .join('');\n\
    \    \n    let charArray = s.split('')\n    \n    charArray.forEach(element =>\
    \ {\n        if(element.charCodeAt(0) > 96 && element.charCodeAt(0) < 123){\n\
    \            reversedString = reversedString.replace(element, String.fromCharCode(element.charCodeAt(0)\
    \ - 32))\n        }\n        else{\n            reversedString = reversedString.replace(element,\
    \ element)\n        }\n    })\n    return reversedString;\n}\n\nconsole.log(solve('ab'))\n\
    console.log(solve('1234'))\nconsole.log(solve('#a@C'))\nconsole.log(solve('#A@c'))\n\
    console.log(solve('a@b'))</code>\n<|/ a tags=javascript,algorithm |>\n<| a tags=javascript,algorithm\
    \ |>\n<code>", "  const lowerCase = s.toLowerCase()\n  if (lowerCase.search(/[a-z]/)\
    \ === -1) {\n    return s\n  }\n  const result = lowerCase.replace(\n    /[a-z]/g,\n\
    \    (letter: string) => letter.toUpperCase()\n  )\n  if (result.search(/[^a-z]/)\
    \ === -1) {\n    return result\n  }\n  return result.replace(\n    /[a-z]/g,\n\
    \    (letter: string) => letter.toLowerCase()\n  )\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nHere is my solution with reduce function\n\n<code>\nconst input\
    \ = '#a@C'\n\nconst result = input\n  .replace('#', '')\n  .replace(/[a-z]/g,\
    \ m => m.toUpperCase())\n  .replace(/[^a-z]/g, m => m.toLowerCase())\n  .replace(/[^A-Z]/g,\
    \ m => m.toUpperCase())\n  .replace(/[A-Z]/g, m => m.toLowerCase())\n  .replace(/@/g,\
    \ '')\n\nconsole.log(result)</code>\n<|/ a dscore=1 tags=javascript,string |>\n\
    <| c |>\nYour solution looks more efficient than mine\n<|/ c |>\n<| a |>\nYou\
    \ could take a look to the String.prototype.replace method which has a function\
    \ callback that is called for each occurence of a matched pattern and you can\
    \ implement the desired transformation of your string with it.\n\n<code>", "\t\
    return s.split('').map(\n\t\tc => c === '#' || c === '.' ? c : c.toUpperCase()\n\
    \t).join('');\n}\n*/", "    return s.split(\"\").reduce((acc, char) => {\n   \
    \     char = char.toLowerCase();\n        if (/[a-z]/.test(char)) {\n        \
    \    char += char.substr(1).toLowerCase();\n        } else {\n            char\
    \ += char.substr(1).toUpperCase();\n        }\n        \n        return acc +\
    \ char;\n    });\n}\n", "  for (let i = 0; i < s.length; i += 1) {\n    let char\
    \ = s[i];\n    if (char.match(/[a-z]/)) {\n      s[i] = char.toLowerCase() ===\
    \ char ? char.toUpperCase() : char.toLowerCase();\n    } else {\n      s[i] =\
    \ char;\n    }\n  }\n  return s.join(\"\");\n}\n", "    return s.replace(/[a-zA-Z]/,\
    \ (l: string) => {\n        if (l.charCodeAt(0) >= 65 && l.charCodeAt(0) <= 90)\
    \ {\n            return String.fromCharCode(l.charCodeAt(0) - 32 + 32) + l.substring(1);\n\
    \        }\n        return l;\n    });\n}\n", "  let str = \"\"\n  for (let i\
    \ = 0; i < s.length; i++) {\n    let isLetter = s[i] >= 'a' && s[i] <= 'z' ||\
    \ s[i] >= 'A' && s[i] <= 'Z'\n    if (isLetter) {\n      str = str.concat(s[i].toUpperCase())\n\
    \    } else {\n      str = str.concat(s[i])\n    }\n  }\n  if (str.length == 0)\
    \ {\n    return str\n  } else {\n    return str\n  }\n}\nsolve(\"123\")\nsolve(\"\
    ab\")\nsolve(\"#a@C\")\n", "  var result = '';\n  s.split(\"\").forEach(function(letter,\
    \ i){\n    if(letter.match(/[a-z]/i)){\n      result += letter.toUpperCase();\n\
    \    }\n    else result += letter.toLowerCase();\n  });\n  return result;\n}\n\
    </code>\n<|/ a tags=string,javascript |>\n<| a dscore=0 tags=string,javascript\
    \ |>\n<code>", "  if (s[0] === '#') {\n    return reverse(s);\n  }\n\n  if (s.indexOf('@')\
    \ !== -1) {\n    return reverse(s.replace('@', ''));\n  }\n\n  const chars = s.split('').map(i\
    \ => {\n    if (i.charCodeAt(0) > 96 && i.charCodeAt(0) < 123) {\n      return\
    \ i.charCodeAt(0) - 32; // 65 - 90\n    }\n\n    return i.charCodeAt(0);\n  });\n\
    \n  let result = '';\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i]\
    \ >= 65 && chars[i] <= 90) {\n      result += String.fromCharCode(chars[i] + 32);\n\
    \    } else if (chars[i] >= 97 && chars[i] <= 122) {\n      result += String.fromCharCode(chars[i]\
    \ - 32);\n    } else {\n      result += chars[i];\n    }\n  }\n\n  return result;\n\
    }\n", "    \n    const strArr = s.split(\"\");\n    const len = strArr.length;\n\
    \    \n    if (s.includes(\"@\") && s.includes(\"#\")) {\n        return s;\n\
    \    }\n    \n    for (let i = 0; i < len; i++) {\n        if (strArr[i].length\
    \ === 0) {\n            return strArr.join(\"\");\n        }\n    }\n    \n  \
    \  for (let i = 0; i < len; i++) {\n        if (strArr[i].length === 1 && strArr[i].toLowerCase()\
    \ !== strArr[i].toUpperCase()) {\n            return strArr.join(\"\");\n    \
    \    }\n    }\n    \n    return s;\n}\n</code>\n<|/ a tags=string,javascript,algorithm,substring\
    \ |>\n<| c |>\nThe algorithm works perfectly on all the test cases. Thank you\
    \ so much!\n<|/ c |>\n<| c |>\nGlad it helped, feel free to upvote if you feel\
    \ it helped you and accept the answer if it resolved your problem.\n<|/ c |>\n\
    <| a dscore=1 |>\nUsing filter + includes\n<code>", "  let lower = [\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"];\n  let upper = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\",\
    \ \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\"\
    , \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n  let lowerCase\
    \ = s.split(\"\").map(c => lower.indexOf(c) > -1 ? upper[lower.indexOf(c)]: lower[lower.indexOf(c)]);\n\
    \  let upperCase = s.split(\"\").map(c => upper.indexOf(c) > -1 ? upper[upper.indexOf(c)]:\
    \ lower[upper.indexOf(c)]);\n  let reversed = s.split(\"\").map((c, index) =>\
    \ index > 0 ? upperCase.indexOf(c) < lowerCase.indexOf(c) ? upperCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? upperCase.indexOf(c) < lowerCase.indexOf(c) ? upperCase.indexOf(c)\
    \ < lowerCase.indexOf(c) ? lowerCase.indexOf(c) < upperCase.indexOf(c) ? lowerCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? lowerCase.indexOf(c) < lowerCase.indexOf(c) ? upperCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? upperCase.indexOf(c) < lowerCase.indexOf(c) ? upperCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? lowerCase.indexOf(c) < upperCase.indexOf(c) ? lowerCase.indexOf(c)\
    \ < lowerCase.indexOf(c) ? lowerCase.indexOf(c) < upperCase.indexOf(c) ? upperCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? upperCase.indexOf(c) < lowerCase.indexOf(c) ? upperCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? upperCase.indexOf(c) < lowerCase.indexOf(c) ? upperCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? lowerCase.indexOf(c) < upperCase.indexOf(c) ? lowerCase.indexOf(c)\
    \ < lowerCase.indexOf(c) ? lowerCase.indexOf(c) < upperCase.indexOf(c) ? upperCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? upperCase.indexOf(c) < lowerCase.indexOf(c) ? upperCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? upperCase.indexOf(c) < lowerCase.indexOf(c) ? lowerCase.indexOf(c)\
    \ < upperCase.indexOf(c) ? lowerCase.indexOf(c) < lowerCase.indexOf(c) ? lowerCase.indexOf",
  "    const strArr: string[] = s.split('')\n    let len: number = strArr.length\n\
    \    let idx: number = 0\n\n    while (idx < len) {\n        if (strArr[idx] ===\
    \ letter) {\n            strArr[idx] = strArr[len]\n            strArr[len] =\
    \ letter\n        } else {\n            strArr[idx] = letter\n        }\n\n  \
    \      len--\n        idx++\n    }\n    return strArr.join('')\n}\n", "    var\
    \ low = s.toLowerCase();\n    var upped = s.toUpperCase();\n    var letters =\
    \ \"\";\n    \n    for(var i = 0;i<s.length;i++) {\n        if(s[i] == low[i])\
    \ {\n            letters += upped[i];\n        } else {\n            letters +=\
    \ low[i];\n        }\n    }\n    return letters;\n}\n", "  return s.split('').map(c\
    \ => c.match(/[a-z]/i) ? c.toLowerCase() : c.toUpperCase()).join('');\n}\n", " \
    \   let lowerCase = s.toLowerCase()\n    let upperCase = s.toUpperCase()\n   \
    \ let reverseCase = lowerCase.split(\"\").reduce((a, b) => a + (b.toUpperCase()),\
    \ \"\")\n    let noLetters = reverseCase.split(\"\").reduce((a, b) => a + b, \"\
    \")\n\n    let result = lowerCase + upperCase\n    if (result.length === noLetters)\
    \ {\n        result = reverseCase\n    }\n    return result\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a tags=string,arrays,javascript,reverse |>\nSimple Solution\
    \ in javascript \n\n<code>", "    const result: string = s;\n    for (let i =\
    \ 0; i < s.length; i += 1) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n    \
    \        result =\n                result.substring(0, i) + result.substring(i\
    \ + 1, result.length) + s[i].toUpperCase();\n        } else {\n            result\
    \ =\n                result.substring(0, i) + result.substring(i + 1, result.length)\
    \ + s[i].toLowerCase();\n        }\n    }\n    return result;\n}\n", "    if (s.length\
    \ === 0) {\n        return '';\n    }\n    let lower = true\n    \n    const chars\
    \ = s.replace(/[^a-z]/g, '').split('')\n    for (let i = 0, len = chars.length;\
    \ i < len; i++) {\n        if (chars[i].charCodeAt() < 97) {\n            if (lower)\
    \ {\n                chars[i] = chars[i].toUpperCase()\n            } else {\n\
    \                chars[i] = chars[i].toLowerCase()\n            }\n        } else\
    \ {\n            if (lower) {\n                chars[i] = chars[i].toLowerCase()\n\
    \            } else {\n                chars[i] = chars[i].toUpperCase()\n   \
    \         }\n        }\n        lower = !lower\n    }\n    return chars.join('');\n\
    }\n", "  // your code here\n  const newString = s.split(\"\").map((char, i) =>\
    \ {\n    if (/[A-Za-z]/.test(char)) {\n      return char.toLowerCase()\n    }\n\
    \    return char.toUpperCase()\n  })\n  const newChars = newString.join(\"\")\n\
    \  if (newChars === \"\") {\n    return s\n  }\n  return newChars\n}\n\n</code>\n\
    <|/ a tags=javascript,algorithm,string |>\n<| c |>\nWhat if the input is `\"#a@C\"\
    `? It gives `\"#A@c\"`\n<|/ c |>\n<| c |>\nOh yes, it does. I forgot to change\
    \ that. Thanks for pointing out. I've updated the code now.\n<|/ c |>\n<| c |>\n\
    I think you need to `return char.toUpperCase()`. Otherwise, it returns `undefined`.\
    \ See here: https://jsfiddle.net/wLz1k0wz/\n<|/ c |>\n<| c |>\nYeah, I missed\
    \ that part, thanks for pointing it out. I've updated the code now.\n<|/ c |>\n\
    <| a tags=javascript,algorithm,string |>\nYou can try this below approach\n\n\
    <code>\nvar str = \"hello\";\nvar strArr = str.split(\"\");\nvar result = \"\"\
    ;\nstrArr.forEach(function(item) {\n  result += (item === strArr[0].toLowerCase()\
    \ ? item.toUpperCase() : item.toLowerCase());\n});\nconsole.log(result);</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "    \n    return s.split('').map(a\
    \ => a >= 'a' ? a.charCodeAt(0) - 96 : a.charCodeAt(0) - 64).join();\n}\n", " \
    \   let stack = [...s.split(\"\")];\n    while (stack.length > 0) {\n        let\
    \ lastIndex = stack.length - 1;\n        let currentValue = stack[lastIndex];\n\
    \        if (currentValue.length > 0) {\n            if (currentValue[0] >= 'A'\
    \ && currentValue[0] <= 'Z') {\n                stack[lastIndex] = currentValue.substr(0,\
    \ 1) + currentValue.substr(1).toLowerCase();\n            } else {\n         \
    \       stack[lastIndex] = currentValue.substr(0, 1) + currentValue.substr(1).toUpperCase();\n\
    \            }\n        } else {\n            stack[lastIndex] = currentValue;\n\
    \        }\n        stack.splice(lastIndex + 1, 0, stack.pop());\n    }\n    return\
    \ stack.join(\"\");\n}\n</code>\n<|/ a |>\n<| c |>\nPlease provide some explanation\n\
    <|/ c |>\n<| a tags=arrays,javascript,string dscore=0 |>\nHere's a functional\
    \ solution that uses a map to build an array of letters and then joins to create\
    \ your string again:\n<code>\nlet input = \"ab#a@c\"\n\nlet arr = input.split('')\n\
    let letters = arr.map(letter => {\n  if (letter == '#') return letter.toLowerCase()\n\
    \  return letter.toUpperCase()\n})\n\nconsole.log(letters.join(''))\n</code>\n\
    <|/ a |>\n<| a tags=arrays,javascript,string |>\nThis should also work, using\
    \ two loops to split the string into two separate arrays, then mapping each array\
    \ to capitalize or lower case, returning each array joined.\n\n<code>", "\treturn\
    \ s.split('').reduce((a,c) => {\n\t\treturn a.length == 0 ? c : (\n\t\t\tisLower(a[0])\
    \ ? a.charAt(0) + c.toLowerCase() : a.charAt(0) + c.toUpperCase()\n\t\t)\n\t}).reverse().join('')\n\
    }\n", "  s = s.toUpperCase();\n  let ans = \"\";\n  for (let i = 0; i < s.length;\
    \ i++) {\n    const charToSwap = s[i];\n    if (i === 0) {\n      ans = charToSwap;\n\
    \    } else {\n      if (charToSwap === ans) {\n        ans = charToSwap;\n  \
    \    } else {\n        ans += charToSwap;\n      }\n    }\n  }\n  return ans;\n\
    }\n", "    if (s.trim() === '') return s; // do nothing\n    const result: string[]\
    \ = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] >= 'a' &&\
    \ s[i] <= 'z')\n            result[i] = s[i] - 32;\n        else if (s[i] >= 'A'\
    \ && s[i] <= 'Z')\n            result[i] = s[i] + 32;\n        else\n        \
    \    result[i] = s[i];\n    }\n    return result.join('');\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nthanks for your help! I do get the correct answer now but there\
    \ is a runtime error with your solution when I put input strings like \"ab\" which\
    \ should reverse to return \"ba\". It does not output the right answer but rather\
    \ outputs \"Ab\", which is different from my results. Any thoughts?\n<|/ c |>\n\
    <| c |>\nThis code doesn't output the correct answer. I tested it and it works\
    \ for me for the input you provided. For instance, `solve(\"ab\")` outputs `\"\
    Ba\"`.\n<|/ c |>\n<| c |>\nYou are right I didn't see the typo with the capitalization,\
    \ I did just change it to lower case and it works now. Thank you very much!\n\
    <|/ c |>\n<| a dscore=2 |>\nI would use RegEx replace:\n<code>\nimport re\ndef\
    \ solve(s: str) -> str:\n    s = re.sub(\"[A-Z]\", \"a\", s)\n    s = re.sub(\"\
    [a-z]\", \"z\", s)\n    s = re.sub(\"\\W\", \"\", s)\n    return s\n</code>\n\
    Explanation:\n\nre.sub(pattern, replacement, string) will replace all occurrences\
    \ of a pattern with another pattern where pattern is a regular expression\n[A-Z]\
    \ will replace all capital letters with a\n[a-z] will replace all lowercase letters\
    \ with z\n\\W will replace all non-word characters with nothing\n\nThis can easily\
    \ be modified to handle other characters like spaces\n<|/ a tags=python |>\n<|\
    \ c |>\nI didn't know this module existed. Thanks for sharing! This looks really\
    \ useful!\n<|/ c |>\n<| a dscore=1 tags=python |>\nA recursive solution using\
    \ str[::-1]:\n<code>\ndef solve(s):\n    if len(s) == 1: return s\n    if len(s)\
    \ >= 2 and s[0] == s[-1]: return solve(s[:-1]) + solve(s[1:])\n    if len(s) >=\
    \ 2 and s[0] == s[-2]: return solve(s[:-2]) + solve(s[:-2])\n    return s + s[0]\
    \ + solve(s[2:])\n</code>\n<|/ a |>\n<| a tags=python |>\n<code>\ndef solve(s):\n\
    \    li = []\n    for letter in s:\n        if letter.islower():\n           \
    \ li.append('z')\n        elif letter.isupper():", "  if (s.length === 0) {\n\
    \    return ''\n  }\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i].match(/[a-z]/))\
    \ {\n      const lower = s[i].toUpperCase()\n      const upper = s[i].toLowerCase()\n\
    \      return `${lower}${solve(s.substring(i + 1))}`\n    }\n    return s[i]\n\
    \  }\n  return solve(s.substring(1));\n}\n\nconst solve = solve(`c#d#e#a#b#e#b#a#d#c#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d#e#c#b#a#d#e#b#a#e#b#a#d#c#c#d",
  "\treturn s.split('').map( (c: any) => {\n\t\tif( typeof c === \"string\") {\n\t\
    \t\tc = c.split('').map( (s: string) => { return s.toLowerCase() });\n\t\t\tc\
    \ = c.map( (s: string) => { return s.toUpperCase() });\n\t\t} else {\n\t\t\tc\
    \ = [c];\n\t\t}\n\t\tlet ret = c[0];\n\t\tc.map((e: any) => { ret = e.split('').reduce((acc,\
    \ cur) => { return cur + acc; }, '') });\n\t\treturn ret;\n\t}).join('');\n}\n",
  "    let ans = \"\";\n    for (let i = 0; i < s.length; i++){\n        if (s[i].toLowerCase()\
    \ !== s[i]){\n            ans = ans.concat(s[i].toUpperCase());\n        } else\
    \ {\n            ans = ans.concat(s[i].toLowerCase());\n        }\n    }\n   \
    \ return ans;\n}\n</code>\n<|/ a dscore=0 tags=string,javascript |>\n<| a dscore=0\
    \ |>\nYou can try something like this\n<code>\nconst solve = str => {\n  const\
    \ rev = str => {\n    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    return\
    \ str.split('').reduce((acc, val) => {\n      const index = alphabet.indexOf(val)\n\
    \      return (index > -1) ? (acc += alphabet[index].toUpperCase()) : acc\n  \
    \  }, '')\n  }\n  \n  return rev(str).split('').reduce((acc, val) => {\n    const\
    \ index = alphabet.indexOf(val)\n    return (index > -1) ? (acc += alphabet[index].toLowerCase())\
    \ : acc\n  }, '')\n}\n\nconst strs = ['1234', '#a@C', 'ab', 'a12bc']\nstrs.forEach(s\
    \ => console.log(solve(s))) // \"4321\", \"#A@c\", \"AB\", \"a12bc\"\n</code>\n\
    This just traverses the string from left to right. Whenever a letter is found,\
    \ it checks if that letter is in a string containing all letters. \nIf so, its\
    \ value is mapped to the index of the letter in the alphabet and added accordingly.\
    \ \nIf not, its value is simply added to the accumulator acc.\nIf no letter is\
    \ found, its value is the same.\n<|/ a tags=string,javascript |>\n<| a dscore=0\
    \ |>\nHere is another solution without using any loop. This solution has two phases\
    \ 1. Reverse the string and 2. Reverse the alphabets.\n<code>", "    var newS:\
    \ string = \"\",\n        i: number,\n        iMax: number = s.length;\n\n   \
    \ for (i = 0; i <= iMax; i++) {\n        if (isValidCharacter(s.charAt(i))) {\n\
    \            if (newS) {\n                newS = newS + s.charAt(i);\n       \
    \     }\n            else {\n                newS = s.charAt(i);\n           \
    \ }\n        }\n        else {\n            newS = newS + s.charAt(i);\n     \
    \   }\n    }\n    return newS;\n}\n", "  const result = s.split('');\n  for (let\
    \ i = 0; i < result.length; i++) {\n    if (result[i].match(/[a-z]/g)) {\n   \
    \   result[i] = result[i].toUpperCase();\n    } else {\n      result[i] = result[i].toLowerCase();\n\
    \    }\n  }\n  return result.join('');\n}\n", "  return s.split('')\n    .map(s\
    \ => s.includes('a') ? s.toUpperCase() : s.toLowerCase())\n    .join('');\n}\n",
  "  return s.replace(/[a-z]/gi, c => c.toUpperCase() === c ? c.toLowerCase() : c.toLowerCase())\n\
    }\n", "  return s.replace(/[a-zA-Z]/gi, m => m.toUpperCase() === m ? m.toLowerCase()\
    \ : m.toUpperCase()).replace(/^/gm, '')\n}\n", "    // return s if there are no\
    \ letters\n    if (s.length === 0) return s;\n\n    // return s if there is only\
    \ one letter\n    if (s.length === 1) return s;\n\n    const isCharDigit = char\
    \ => char >= '0' && char <= '9';\n\n    let chars = s.split('');\n\n    // Loop\
    \ through each letter\n    for (let i = 0, len = chars.length; i < len; i++) {\n\
    \        const char = chars[i];\n\n        if (isCharDigit(char)) {\n        \
    \    // Reverse if char is digit\n            chars[i] = chars.splice(i, 1).join('');\n\
    \            chars.splice(i, 0, char);\n            i += 1;\n        } else if\
    \ (char === '.') {\n            // Reverse if char is .\n            chars[i]\
    \ = chars.splice(i, 1).join('');\n            chars.splice(i, 0, char);\n    \
    \        i += 1;\n        } else {\n            // Otherwise keep it\n       \
    \ }\n    }\n\n    return chars.join('');\n}\n\nconsole.log(solve(\"1234\"));",
  "  if (s.length === 0) {\n    return s;\n  }\n  if (isLetter(s[0])) {\n    const\
    \ lower = s.toLowerCase();\n    const upper = s.toUpperCase();\n    if (isLetter(s[s.length\
    \ - 1])) {\n      return `${lower}${s[s.length - 1].toUpperCase()}${upper}`;\n\
    \    } else {\n      return `${lower}${s[s.length - 1].toUpperCase()}`;\n    }\n\
    \  }\n  return s;\n}\n", "    return s.split('').map(c => c === 'a' || c === 'A'\
    \ || c === '#' || c === '#' ? c.toUpperCase() : c.toLowerCase()).join('');\n}\n\
    </code>\n<|/ a tags=string,javascript dscore=0 |>\n<| a tags=string,javascript\
    \ |>\nYou can try this one:\n\n<code>\nconst solve = (str) => {\n   const letters\
    \ = 'abcdefghijklmnopqrstuvwxyz'.split('');\n   return letters.map((e) => str.includes(e)\
    \ ? e.toUpperCase() : e.toLowerCase()).join('');\n}\n\nconsole.log(solve(\"1234\"\
    )); // \"4321\"\nconsole.log(solve(\"ab\")); // \"AB\"\nconsole.log(solve(\"#a@C\"\
    )); // \"#A@c\"</code>\n<|/ a dscore=0 |>\n<| a tags=string,javascript dscore=0\
    \ |>\nThis solution also returns reversed letters.\n\n<code>", "  let result =\
    \ '';\n  let letters = '';\n  for (let i = 0; i < s.length; i++) {\n    const\
    \ char = s[i];\n    let upper = false;\n    let lowerCase = false;\n    if (char\
    \ >= 'a' && char <= 'z') {\n      letters += char;\n      upper = true;\n    }\
    \ else if (char >= 'A' && char <= 'Z') {\n      letters += char.toUpperCase();\n\
    \      upper = true;\n    } else {\n      letters += char.toLowerCase();\n   \
    \   lowerCase = true;\n    }\n    if (upper) {\n      result += String.fromCharCode(ord(letters)\
    \ - 32);\n      letters = '';\n    }\n    if (lowerCase) {\n      result += String.fromCharCode(ord(letters)\
    \ - 32);\n      letters = '';\n    }\n  }\n  return result;\n}\n", "  \n}\n</code>\n\
    <|/ q tags=javascript,string,arrays dscore=1 |>\n<| c |>\nDid you try anything,\
    \ because if you don't even know where to start you might end up asking for help\
    \ with your homework?\n<|/ c |>\n<| c |>\nI have been thinking about it for about\
    \ a week now. I have a solution but I don't think it is the best\n<|/ c |>\n<|\
    \ c |>\nCan you show us the solution you came up with?\n<|/ c |>\n<| c |>\nI edited\
    \ my post to include the solution\n<|/ c |>\n<| c |>\n`return s.split(\"\").reverse().join(\"\
    \");` should be sufficient\n<|/ c |>\n<| a tags=javascript,string,arrays dscore=2\
    \ |>\nJust for fun, here's another approach that uses regular expressions instead\
    \ of split/join.\nThis approach also has the benefit of not needing to keep an\
    \ extra variable for the reverse string - it's always reversed no matter what:\n\
    \n<code>\nconst solve = (s) => s.replace(/[a-z]/gi, m => m ? '' : 'Z').replace(/[A-Z]/gi,\
    \ m => m ? '' : 'A');\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"\
    ));\nconsole.log(solve(\"#a@C\"));</code>\n<|/ a |>\n<| a dscore=1 tags=javascript,string,arrays\
    \ |>\nYou could take a Set for collecting each character and replace it with an\
    \ empty string. This would also take care of non letters later on.\n<code>", " \
    \   let arr: string[] = s.split(\"\");\n    let result: string = \"\";\n    for\
    \ (let i = 0; i < arr.length; i++) {\n        let index = arr[i].charCodeAt(0)\
    \ - 97;\n        index = (index >= 0) ? index : 96;\n        result += String.fromCharCode(index);\n\
    \    }\n    return result;\n}\n", "\treturn s.replace(/[a-z]/gi, x => (x.charCodeAt(0)\
    \ > 96) ? x.toUpperCase() : x.toLowerCase());\n}\n", "  let newString = \"\";\n\
    \  for (let i = 0; i < s.length; i++){\n    if (s.charCodeAt(i) > 96 && s.charCodeAt(i)\
    \ < 103){\n      let charA = String.fromCharCode((s.charCodeAt(i) - 32));\n  \
    \    newString += charA;\n    } else {\n      newString += s[i];\n    }\n  }\n\
    \  return newString;\n}\n", "  const rev_letters = s.split('').map(c => c ===\
    \ 'a' || c === 'A' ? 'a' : 'A').join('');\n  return rev_letters === s ? s : rev_letters;\n\
    }\n", "    return s.split('').reduce((res, cur, i, arr) => {\n        if (cur\
    \ === arr[0]) return arr.reverse().join('');\n        return res + cur;\n    },\
    \ '');\n}\n</code>\n<|/ a tags=string,javascript,char,arrays,reverse dscore=0\
    \ |>\n<| c |>\nThis code doesn't work for me. Says that \".reduce is not a function\"\
    \n<|/ c |>\n<| c |>\nI updated my answer to show a more functional approach that\
    \ can handle arbitrary string length and content.\n<|/ c |>\n<| a tags=string,javascript,char,arrays,reverse\
    \ dscore=0 |>\nThis is how I solved it in Javascript.\n<code>", "    return s.split('').reduce((prev,\
    \ curr, i, arr) => {\n        if (curr.match(/[a-z]/i)) {\n            prev =\
    \ prev + curr.toUpperCase()\n        } else {\n            prev = prev + curr\n\
    \        }\n        return prev\n    }, '')\n}\n\nconsole.log(solve(\"1234\"))\n\
    console.log(solve(\"ab\"))\nconsole.log(solve(\"#a@C\"))\n</code>\n<|/ a tags=string,recursion,javascript,arrays\
    \ |>\n<| a |>\nI believe there are more efficient ways of doing this but this\
    \ works and is easy to understand by someone who has never used reduce before.\n\
    <code>\nlet solve = s => {\n  let splits = s.split('')\n  let newSplits = []\n\
    \  for(let i = 0; i < splits.length; i++) {\n    if(splits[i].match(/[a-z]/))\
    \ {\n      newSplits.push(splits[i] + splits[i].toUpperCase())\n    } else {\n\
    \      newSplits.push(splits[i])\n    }\n  }\n  return newSplits.join('')\n}\n\
    </code>\n<|/ a tags=string,recursion,javascript,arrays dscore=2 |>\n<| a |>\n\
    I believe the best way to approach this problem is to create a function that returns\
    \ an array of strings composed of lower case letters (and upper case) of your\
    \ string, and then apply the Array.prototype.map function to that array. Here's\
    \ an example:\n\n<code>\nconst str = 'abcdefg';\n\nconst upperCaseLetters = str\n\
    \  .split('')\n  .map(letter => letter.toUpperCase())\n\nconst lowerCaseLetters\
    \ = str\n  .split('')\n  .map(letter => letter.toLowerCase())\n\nconst arr = [upperCaseLetters,\
    \ lowerCaseLetters]\n\nconst res = arr.reduce((acc, value) => acc.concat(value),\
    \ [])\n\nconsole.log(res)</code>\n<|/ a dscore=1 tags=string,recursion,javascript,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "    return s.replace(/[a-zA-Z]/g, (m) => m.toUpperCase())\
    \ ? s.toLowerCase() : s;\n}\n", "\treturn s.match(/[a-z]+/i) ? s.match(/[a-z]+/i)\n\
    \t\t? s.match(/[a-z]+/i)\n\t\t: s.match(/[A-Z]+/i) \n\t\t? s.match(/[A-Z]+/i)\n\
    \t\t: s.match(/[a-z]+/i) ? s.match(/[A-Z]+/i)\n\t\t: s.match(/[A-Z]+/i) ? s.match(/[a-z]+/i)\n\
    \t\t: s.match(/[A-Z]+/i) ? s.match(/[A-Z]+/i)\n\t\t: s.match(/[a-z]+/i) ? s.match(/[A-Z]+/i)\n\
    \t\t: s.match(/[A-Z]+/i) ? s.match(/[a-z]+/i)\n\t\t: s.match(/[A-Z]+/i) ? s.match(/[A-Z]+/i)\
    \ : \n\t\ts.match(/[a-z]+/i) ? s.match(/[A-Z]+/i) ? \n\t\ts.match(/[a-z]+/i)\n\
    \t\t: s.match(/[A-Z]+/i) ? s.match(/[A-Z]+/i) : \n\t\ts.match(/[a-z]+/i) ? s.match(/[A-Z]+/i)\
    \ ? s.match(/[a-z]+/i)\n\t\t: s.match(/[A-Z]+/i) ? s.match(/[A-Z]+/i) ? s.match(/[A-Z]+/i)\
    \ : \n\t\ts.match(/[a-z]+/i) ? s.match(/[A-Z]+/i) ? s.match(/[A-Z]+/i) : \n\t\t\
    s.match(/[A-Z]+/i) ? s.match(/[a-z]+/i) : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i)\n\
    \t\t: s.match(/[A-Z]+/i) ? s.match(/[a-z]+/i) : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i)\
    \ : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i) : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i)\
    \ : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i)\n\t\t: s.match(/[A-Z]+/i) ? s.match(/[a-z]+/i)\
    \ : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i) : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i)\
    \ : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i) : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i)\
    \ : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i) : s.match(/[A-Z]+/i)\n\t\t: s.match(/[a-z]+/i)\
    \ ? s.match(/[A-Z]+/i) : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i) : s.match(/[A-Z]+/i)\
    \ : s.match(/[a-z]+/i) : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i) : s.match(/[A-Z]+/i)\
    \ : s.match(/[a-z]+/i) : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i)\n\t\t: s.match(/[A-Z]+/i)\
    \ ? s.match(/[a-z]+/i) : s.match(/[A-Z]+/i) : s.match(/[a-z]+/i) : s.match(/[A-Z]+/i)\
    \ : s.match(/[a-z]+/i) : ", "  return s.split('').map(x => x.match(/[a-z]+/) ?\
    \ x.toUpperCase() : x.toLowerCase()).join('');\n}\n", "    let letters = s\n \
    \   let reverse = ''\n\n    for (let i = 0; i < letters.length; i++) {\n     \
    \   let char = letters[i]\n        let isLetter = char >= 'a' && char <= 'z'\n\
    \n        if (isLetter) {\n            let upperCase = char.toUpperCase()\n  \
    \          let lowerCase = char.toLowerCase()\n            reverse = `${lowerCase}${upperCase}`\n\
    \        } else {\n            reverse = char\n        }\n\n        if (i == letters.length\
    \ - 1) {\n            reverse = reverse.split(\"\").reverse().join(\"\")\n   \
    \     }\n    }\n\n    return reverse\n}\n</code>\n<|/ a |>\n<| a tags=javascript,algorithm\
    \ |>\n<code>", "    let str = '';\n    for (let i = 0; i < s.length; i++){\n \
    \       if (s[i] >= 'a' && s[i] <= 'z'){\n            str += s[i] + s[i].toUpperCase();\n\
    \        } else if (s[i] >= 'A' && s[i] <= 'Z'){\n            str += s[i] + s[i].toLowerCase();\n\
    \        } else {\n            str += s[i];\n        }\n    }\n    return str;\n\
    }\n", "    const newStr = s.toLowerCase().replace(/[A-Z]/g, (m) => String.fromCharCode(ord(m)\
    \ + 32));\n    const firstChar = s.charAt(0);\n    if (newStr === s) {\n     \
    \   return s;\n    } else {\n        return newStr + firstChar;\n    }\n}\n",
  "  return s.split(\"\").map(function(el){\n    return el.toUpperCase().charCodeAt(0)\
    \ - 97;\n  }).join(\"\");\n}\n</cell>\n<cell>", "  let ret: string = \"\";\n \
    \ for (let i = 0; i < s.length; i++){\n    let letter = s[i];\n    if (letter\
    \ === letter.toLowerCase()){\n      ret += letter.toUpperCase();\n    } else {\n\
    \      ret += letter;\n    }\n  }\n  return ret.replace(/[^a-zA-Z]/g, \"\");\n\
    }\n", "  let news = s.replace(/[a-zA-Z]/ig, (x) => x.toUpperCase());\n  news =\
    \ news.replace(/[^a-zA-Z]/ig, (x) => x.toLowerCase());\n  \n  return news;\n}\n\
    \nlet output = solve(\"1234\");\nconsole.log(output);</code>\n<|/ a tags=javascript,typescript,functional-programming\
    \ dscore=1 |>\n<| a tags=javascript,typescript,functional-programming dscore=1\
    \ |>\nYou can simply use some of String.prototype.replace functions:\n\n<code>",
  "  if (s.length === 0) {\n    return s\n  }\n  let lower = false\n  let upper =\
    \ false\n  for (let i = 0; i < s.length; i++) {\n    const chr = s.charAt(i)\n\
    \    if (chr !== LOWER && chr !== UPPER) {\n      lower = false\n      upper =\
    \ false\n    } else {\n      if (chr === LOWER) {\n        lower = true\n    \
    \  } else if (chr === UPPER) {\n        upper = true\n      } else {\n       \
    \ if (lower) {\n          s = s.substring(0, i) + UPPER + s.substring(i + 1)\n\
    \        } else {\n          s = s.substring(0, i) + LOWER + s.substring(i + 1)\n\
    \        }\n      }\n    }\n  }\n  if (s.length) {\n    if (upper) {\n      return\
    \ s.toUpperCase()\n    } else {\n      return s.toLowerCase()\n    }\n  }\n  return\
    \ s\n}\n\nconst strings = [\n  \"The quick brown fox jumps over the lazy dog\"\
    ,\n  \"the quick brown fox jumps over the lazy dog\",\n  \"Quick Brown Fex Jumps\
    \ Over The Lazy Dog\",\n  \"The Quick Brown Fex Jumps Over The Lazy Dog\",\n \
    \ \"ABcdEFG\",\n  \"abcdeFg\",\n  \"abCdEfG\",\n  \"abc de fg\",\n  \"a bcde fg\"\
    ,\n  \"a b c de fg\",\n  \"A  B  C  D  E  F  G\",\n  \"A B C D E F G\",\n  \"\
    A B B B B B B\",\n  \"A B B B C C D D D\",\n  \"A B C D E F G G G G\",\n  \"a\
    \ b c d e f g g g g g\",\n  \"a   b   c   d   e   f   g   g   g   g\",\n  \"a\
    \  \\t   b  \\t   c  \\t   d  \\t   e  \\t   f  \\t   g  \\t   g  \\t   g  \\\
    t\",\n  \"a   b   c   d   e   f   g   g   g   g   g   g   g   g   g\",\n  \"a\
    \  \\t   b  \\t   c  \\t   d  \\t   e  \\t   f  \\t   g  \\t   g  \\t   g  \\\
    t   g  \\t   g  \\t   g  \\t\",\n  \"a   b   c   d   e   f   g   g   g   g   g\
    \   g   g   g   g   g", "    let result: string = \"\"\n    for (const char of\
    \ s) {\n        if (char === char.toLowerCase()) {\n            result = result\
    \ + char.toUpperCase()\n        } else {\n            result = result + char\n\
    \        }\n    }\n    return result\n}\n<|/ file dstars=0 |>\n<| c |>\nHow can\
    \ you be sure that every string you get will be in lower case?\n<|/ c |>\n<| a\
    \ tags=string,arrays,javascript dscore=0 |>\nHere's a good exercise for you to\
    \ work on on your own. It's not exactly a problem that fits the \"What you should\
    \ do question\" format but it'll give you a good idea of what to think about when\
    \ solving problems.\nYou can think of each character as a separate \"thing\".\
    \ If you're working with strings, it's probably best to think of characters as\
    \ strings. For example, you can think of a character as being a sub-string of\
    \ another string. That sub-string is a single character.\nNow, let's think about\
    \ what you want to do with each character. How can you reverse a string? Let's\
    \ start with the most basic case of a single character. Let's say you're working\
    \ with the string \"abc\". You can think of the characters as being:\n<code>\n\
    \"a\"\n\"b\"\n\"c\"\n</code>\nIf you're trying to reverse this string in place,\
    \ you'll notice that \"c\" comes after \"b\" and \"a\" comes after \"b\". What\
    \ if you were to reverse \"abc\" into \"cba\"? You'd do this:\n<code>\n\"a\" >\
    \ \"c\"\n\"b\" > \"a\"\n\"c\" > \"b\"\n</code>\nIn your code, you do this to reverse\
    \ each character:\n<code>\nresult.push(char.toLowerCase())\n</code>\nSo now you've\
    \ got two pieces of information:\n\nThe original character (let's call it originalChar)\n\
    The new character (let's call it newChar)\n\nNow what you want to do is check\
    \ whether newChar is alphabetically less than the original character - which means\
    \ it'll have to be in lower-case:\n\nnewChar < originalChar\nnewChar.toLowerCase()\
    \ < originalChar.toLowerCase()\n\nIf that comparison returns true, you want to\
    \ push newChar to the end of the result array.\nIf the comparison returns false,\
    \ you want to push originalChar to the end of the result array.\nHere's how you\
    \ can do that:\n<code>", "    const result = [];\n\n    for (let i = 0; i < s.length;\
    \ i++) {\n        const temp = s.charAt(i).toLowerCase();\n        let reversed\
    \ = '';\n\n        for (let j = 0; j < temp.length; j++) {\n            const\
    \ value = temp.charCodeAt(j);\n\n            if (value === 61) {\n           \
    \     const letter = temp[temp.length - (j + 2)];\n                temp = (letter\
    \ === 'a' ? 'A' : 'a').toUpperCase();\n            } else if (value === 62) {\n\
    \                const letter = temp[temp.length - (j + 3)];\n               \
    \ temp = (letter === 'A' ? 'a' : 'A').toUpperCase();\n            } else if (value\
    \ === 63) {\n                temp = 'a';\n            } else {\n             \
    \   temp = temp.toLowerCase();\n            }\n            \n            reversed\
    \ += temp;\n        }\n\n        result.push(reversed);\n    }\n\n    return result.join('');\n\
    }\n", "\treturn s.split('').map(c => {\n\t\tswitch(c) {\n\t\t\tcase 'a': return\
    \ 'A'\n\t\t\tcase 'b': return 'B'\n\t\t\tcase 'c': return 'C'\n\t\t\tcase 'd':\
    \ return 'D'\n\t\t\tcase 'e': return 'E'\n\t\t\tcase 'f': return 'F'\n\t\t\tcase\
    \ 'g': return 'G'\n\t\t\tcase 'h': return 'H'\n\t\t\tcase 'i': return 'I'\n\t\t\
    \tcase 'j': return 'J'\n\t\t\tcase 'k': return 'K'\n\t\t\tcase 'l': return 'L'\n\
    \t\t\tcase 'm': return 'M'\n\t\t\tcase 'n': return 'N'\n\t\t\tcase 'o': return\
    \ 'O'\n\t\t\tcase 'p': return 'P'\n\t\t\tcase 'q': return 'Q'\n\t\t\tcase 'r':\
    \ return 'R'\n\t\t\tcase 's': return 'S'\n\t\t\tcase 't': return 'T'\n\t\t\tcase\
    \ 'u': return 'U'\n\t\t\tcase 'v': return 'V'\n\t\t\tcase 'w': return 'W'\n\t\t\
    \tcase 'x': return 'X'\n\t\t\tcase 'y': return 'Y'\n\t\t\tcase 'z': return 'Z'\n\
    \t\t}\n\t}).join('');\n}\n", "  const map = new Map<string, string>([\n    [\"\
    A\", \"B\"],\n    [\"a\", \"b\"],\n    [\"#\", \"@\"],\n    [\"a\", \"@\"],\n\
    \    [\"@\", \"a\"]\n  ])\n  return s.split('').map(c => map.get(c) || c).join('')\n\
    }\n\nconsole.log(solve('1234'))\nconsole.log(solve('ab'))\nconsole.log(solve('#a@C'))</code>\n\
    \nEDIT:\nIf you want a pure javascript solution, that doesn't require an external\
    \ library that would have to be loaded on every page load, you can use the following\
    \ function which doesn't require an external library.\n\n<code>", "  let lowerCaseString\
    \ = \"\";\n  let upperCaseString = \"\";\n  \n  for (let i = 0; i < s.length;\
    \ i += 1) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      if (s[i] >= 'a' && s[i]\
    \ <= 'z') {\n        upperCaseString += s[i];\n      } else {\n        lowerCaseString\
    \ += s[i];\n      }\n    } else {\n      lowerCaseString += s[i];\n    }\n  }\n\
    \n  if (lowerCaseString === \"\") {\n    lowerCaseString = upperCaseString;\n\
    \  }\n\n  if (upperCaseString === \"\") {\n    upperCaseString = lowerCaseString;\n\
    \  }\n\n  if (lowerCaseString === \"\") {\n    lowerCaseString = upperCaseString;\n\
    \  }\n  \n  return upperCaseString + lowerCaseString;\n}\n\nconsole.log(solve(\"\
    1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));</code>\n\
    <|/ a dscore=2 |>\n<| a tags=javascript,algorithm |>\nI ran into an interesting\
    \ problem. I am guessing there are many different approaches to this, but here\
    \ is a solution that only uses simple string methods.\n\n<code>", "  return s.split(\"\
    \").map((char) => {\n    return char.toLowerCase() === char ? char.toUpperCase()\
    \ : char;\n  }).join(\"\");\n}\n\nexport { solve };\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for the answer, but your solution is only half correct. It also doesn't\
    \ work when the string is \"#a@c\".\n<|/ c |>\n<| c |>\nThanks for your answer,\
    \ it works as expected! But I still think the code should be simpler\n<|/ c |>\n\
    <| c |>\nYes there should be one line for the entire string and one line for individual\
    \ characters but it is very unreadable and unecessary when compared with more\
    \ readable code\n<|/ c |>\n<| c |>\nThis code doesn't seem to be working as expected.\
    \ On input of \"#a@c\", it returns \"#AC\"\n<|/ c |>\n<| c |>\nI have added a\
    \ comment at the top of the code explaining the code in the answer.\n<|/ c |>\n\
    <| a dscore=4 |>\nThis seems like a good use case for String.prototype.reverse()\n\
    \n<code>\nvar foo = '#a@c';\nconsole.log(foo);\nfoo = foo.reverse();\nconsole.log(foo);</code>\n\
    <|/ a tags=javascript,string,reverse |>\n<| a |>\nYou can use this simple approach\
    \ for reversing strings. \n<code>\nlet string = 'abc';\nlet reverse = string.reverse();\n\
    \nconsole.log(reverse);\n</code>\n<|/ a tags=javascript,string,reverse dscore=3\
    \ |>\n<| a tags=javascript,string,reverse |>\nThe simplest answer is that you\
    \ can use the reverse method of a string to do this\n<code>\nvar myString = '#a@c';\n\
    var reversedString = myString.reverse(); // reversedString becomes \"c@a#\" \n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=javascript,string,reverse |>\n<code>\nlet\
    \ string = '#a@c';\n\nstring.replace(/#/,'#').replace(/@/,'@').replace(/c/,'c')\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThanks for the answer, but your solution\
    \ is only half correct. It also doesn't work when the string is \"#a@c\".\n<|/\
    \ c |>\n<| a |>\n<code>\nvar str = \"#a@c\";\nvar reverseStr = \"\";\nvar lastChar\
    \ = \"c\";\nvar currChar = \"c\";\nvar i = 0;\nwhile (i<str.length) {\n reverseStr\
    \ += currChar;\n currChar", "  let newString = \"\";\n  for (let i = 0; i < s.length;\
    \ i++) {\n    let char = s[i];\n    let isLetter = char.match(/[a-z]/i);\n   \
    \ if (isLetter) {\n      newString += char.toUpperCase();\n    } else {\n    \
    \  newString += char;\n    }\n  }\n  return newString;\n}\n\nsolve(\"ab\");\n\
    solve(\"aB\");\nsolve(\"12\");\nsolve(\"$@B#\");\nsolve(\"$@B#@\");\nsolve(\"\
    $@B#@@\");\nsolve(\"$@B#@@@\");\nsolve(\"$@B#@@@$\");\nsolve(\"$@B#@@@$@\");\n\
    solve(\"$@B#@@@$@$\");\nsolve(\"$@B#@@@$@$@\");\nsolve(\"$@B#@@@$@$@$\");\nsolve(\"\
    $@B#@@@$@$@$@\");\nsolve(\"$@B#@@@$@$@$@$\");\nsolve(\"$@B#@@@$@$@$@$@\");\nsolve(\"\
    $@B#@@@$@$@$@$@$\");\nsolve(\"$@B#@@@$@$@$@$@$@\");\nsolve(\"$@B#@@@$@$@$@$@$@$\"\
    );\nsolve(\"$@B#@@@$@$@$@$@$@$@\");\nsolve(\"$@B#@@@$@$@$@$@$@$@$\");\nsolve(\"\
    $@B#@@@$@$@$@$@$@$@$@\");\nsolve(\"$@B#@@@$@$@$@$@$@$@$@$\");\nsolve(\"$@B#@@@$@$@$@$@$@$@$@$@\"\
    );\nsolve(\"$@B#@@@$@$@$@$@$@$@$@$@\");\nsolve(\"$@B#@@@$@$@$@$@$@$@$@$\");\n\
    solve(\"$@B#@@@$@$@$@$@$@$@$@$@$@\");\nsolve(\"$@B#@@@$@$@$@$@$@$@$@$@$\");\n\
    solve(\"", "    // base case\n    if (s.length === 0) {\n        return ''\n \
    \   }\n    // split string by characters\n    const characters = s.split('');\n\
    \    // check whether character is a letter\n    // if so, reverse\n    for (let\
    \ i = 0; i < characters.length; i++) {\n        characters[i] = characters[i].toLowerCase();\n\
    \    }\n    // return reversed string\n    return characters.reverse().join('');\n\
    }\n\nsolve(\"a#b\");\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease explain how\
    \ your solution works\n<|/ c |>\n<| c |>\nIf you can see above code, I split string\
    \ by character and then checked whether each character is a letter or not and\
    \ if it is letter, I reverse the letters.\n<|/ c |>\n<| c |>\nThat's not an explanation,\
    \ that's just an implementation detail.  Please edit your answer to explain how\
    \ this code works.\n<|/ c |>\n<| c |>\nThanks for your suggestion. I edited my\
    \ answer.\n<|/ c |>\n<| c |>\nThis is a terrible solution.  Please explain your\
    \ code.\n<|/ c |>\n<| a tags=javascript,string |>\nThis is more a mathematical\
    \ problem, not programming related. \nYou need to realise that when reversing\
    \ a string, you just move the character to the left until the last character is\
    \ reached. \nTo do this move the character to the right until you reach the first\
    \ character in the string and swap their characters.\n\n<code>", "    let resultString\
    \ = \"\";\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] >= \"A\"\
    \ && s[i] <= \"Z\") {\n            let currentUpperCase = s[i];\n            s[i]\
    \ = \"a\" <= currentUpperCase && currentUpperCase <= \"z\" ? \"A\" : \"a\";\n\
    \        }\n    }\n    for (let i = 0; i < s.length; i++) {\n        resultString\
    \ += s[i];\n    }\n    return resultString;\n}\n</code>\n<|/ a dscore=0 tags=data-structures,algorithm,javascript\
    \ |>\n<| a dscore=0 |>\n<code>", "    let stack = [];\n    for (let i = 0; i <\
    \ s.length; i++) {\n        let char = s[i];\n        if (!isNaN(char)) {\n  \
    \          // console.log(char, i);\n            if (char >= '0' && char <= '9')\
    \ {\n                stack.push(char - '0');\n            } else {\n         \
    \       stack.push(char);\n            }\n        } else if (char >= 'a' && char\
    \ <= 'z') {\n            stack.push(char - 'a');\n        } else {\n         \
    \   stack.push(char);\n        }\n    }\n    \n    while (stack.length > 0) {\n\
    \        let pop = stack.pop();\n        if (pop >= '0' && pop <= '9') {\n   \
    \         stack.push(pop - '0');\n        } else {\n            stack.push(pop);\n\
    \        }\n    }\n    \n    return stack.join('');\n}\n", "    const result =\
    \ ''\n\n    for (let i = 0; i < s.length; i += 1) {\n        const char = s.charAt(i)\n\
    \        // console.log(i, char, s.charAt(i).charCodeAt(0))\n        const letter\
    \ = String.fromCharCode(char.charCodeAt(0) > 65 ? char.charCodeAt(0) - 65 : char.charCodeAt(0)\
    \ - 97)\n        result += letter\n    }\n\n    return result\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\n<code>", "    return s.split(\"\").reduce((acc, char,\
    \ index, arr) => {\n        return char === arr[index] ? `${acc}${char.toUpperCase()}${char.toLowerCase()}`\n\
    \            : char === arr[index] ? `${acc}${char.toLowerCase()}${char.toUpperCase()}`\n\
    \            : `${acc}${char}`\n    }, '');\n}\n</code>\n<|/ a tags=string,javascript,ecmascript-6\
    \ dscore=1 |>\n<| a tags=string,javascript,ecmascript-6 |>\n<code>", "    let\
    \ ans = \"\";\n    for (let i = 0; i < s.length; i += 1) {\n        if (/[a-z]+/i.test(s[i]))\
    \ {\n            if (s[i].toLowerCase() === s[i]) {\n                ans += s[i].toUpperCase();\n\
    \            } else {\n                ans += s[i].toLowerCase();\n          \
    \  }\n        } else {\n            ans += s[i];\n        }\n    }\n    return\
    \ ans;\n}\n", "  if (s == null || s.length == 0) {\n    return s;\n  }\n\n  let\
    \ letters = s.split('');\n  let res: string = '';\n\n  for (let i = 0; i < letters.length;\
    \ i++) {\n    if (letters[i].length > 0) {\n      let upperCase: number = letters[i].charCodeAt(0)\
    \ - 32;\n      let lowerCase: number = letters[i].charCodeAt(0);\n\n      if (upperCase\
    \ > 26 || lowerCase > 26) {\n        res += String.fromCharCode(upperCase);\n\
    \        res += String.fromCharCode(lowerCase);\n      } else {\n        res +=\
    \ letters[i];\n      }\n    } else {\n      res += letters[i];\n    }\n  }\n\n\
    \  return res;\n}\n", "\t\n\treturn s.split('')\n\t\t.map(char => {\n\t\t\tif(!isNaN(Number(char))){\n\
    \t\t\t\tif(char>90){\n\t\t\t\t\treturn char.toString() + char.toString()\n\t\t\
    \t\t}else if(char<90){\n\t\t\t\t\treturn char.toString() + char.toString().toUpperCase()\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn char\n\t\t\t}\n\t\t})\n\t\t.sort((a,b)\
    \ => a.localeCompare(b))\n\t\t.join('')\n}\n", "    const lower = String.fromCharCode(97);\n\
    \    const upper = String.fromCharCode(65);\n\n    if (s.split(lower).length >\
    \ 0) {\n        return s.replace(lower,upper).toLowerCase();\n    }\n\n    return\
    \ s.toLowerCase().split(upper).reverse().join(upper);\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nGood answer. Small suggestion: instead of using `String.fromCharCode`\
    \ you could use the [String.fromCodePoint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)\
    \ function which accepts a single integer argument that represents the UTF-16\
    \ code point of a unicode character.\n<|/ c |>\n<| c |>\n: that's an interesting\
    \ suggestion. Thanks.\n<|/ c |>\n<| c |>\nThis does not work for all Unicode characters.\
    \ For example, a double heart `\u2764` does not get converted correctly with this\
    \ solution.\n<|/ c |>\n<| c |>\nYou're absolutely right. For the purpose of what\
    \ I'm trying to do, I would need to include non-ASCII characters as well, which\
    \ is why I went with using the Unicode character code. Thanks for your feedback\
    \ and answer!\n<|/ c |>\n<| a tags=javascript |>\nI've rewritten my answer using\
    \ the method suggested by jfriend00 to improve the performance by only looping\
    \ through the string once:\n\n<code>", "    if (s.length === 0) {\n        return\
    \ s\n    }\n    if (/^[a-z]+$/.test(s)) {\n        let lowerToUpper: string =\
    \ s.toLowerCase()\n        return lowerToUpper.replace(/\\d(?=\\d$)/g, (m) =>\
    \ (m).toUpperCase())\n    }\n    return s.replace(/[a-z](?=.*[a-z])|[A-Z](?=.*[A-Z])|\\\
    d/, (m) => (m.charCodeAt(0) > 96 ? m.toUpperCase() : m.toLowerCase()))\n}\n",
  "    const result: string = s.split('');\n    const count = {\n        lower: 0,\n\
    \        upper: 0,\n    };\n    for (const c of s) {\n        count[c] = count[c]\
    \ + 1;\n    }\n    const char: keyof typeof count = Object.keys(count).reduce((a,\
    \ b) => count[b] > count[a] ? b : a, undefined);\n    if (char === undefined)\
    \ {\n        return s.split('').reverse().join('');\n    }\n    result[result.indexOf(char)]\
    \ == char && (result[result.indexOf(char) + 1] = char === char.toUpperCase() ?\
    \ '' : char.toLowerCase());\n    return result.join('');\n}\n", "  let res = \"\
    \";\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <=\
    \ 'z') {\n      res += s[i].toUpperCase();\n    }\n    else if (s[i] >= 'A' &&\
    \ s[i] <= 'Z') {\n      res += s[i].toLowerCase();\n    }\n    else {\n      res\
    \ += s[i];\n    }\n  }\n  return res;\n}\n</code>\n<|/ a tags=javascript,string\
    \ |>\n<| c |>\nIt's not working for the string \"#a@C\". Check my answer.\n<|/\
    \ c |>\n<| c |>\nI got your point but `#a@C` doesn't contain any letter but `@C`\
    \ does. So the function should return a string containing only the letters.\n\
    <|/ c |>\n<| c |>\n: Good point, I misunderstood how OP wants to handle the empty\
    \ string. Thank you for pointing that out.\n<|/ c |>\n<| a dscore=1 |>\nA few\
    \ lines of RegExp magic:\n<code>", "    let res: string = \"\";\n    for (let\
    \ i = 0; i < s.length; i++) {\n        if (/[a-zA-Z]/.test(s[i])) {\n        \
    \    res += s[i].toUpperCase();\n        } else {\n            res += s[i];\n\
    \        }\n    }\n    return res.trim();\n}\n", "  s = s.toLowerCase()\n  let\
    \ i = 0\n  while (i < s.length) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n   \
    \   if (s[i + 1] === 'a') {\n        s[i + 1] = 'b'\n      } else if (s[i + 1]\
    \ === 'z') {\n        s[i + 1] = 'a'\n      } else {\n        s[i + 1] += s[i]\n\
    \        s[i] = 'a'\n      }\n    } else if (s[i] >= '0' && s[i] <= '9') {\n \
    \     s[i] += s[i]\n      s[i] = '0'\n    }\n    i++\n  }\n  return s\n}\n", " \
    \ let r = '', i = 0\n  while (i < s.length) {\n    const n = s.charAt(i)\n   \
    \ if (n.match(/[a-z]/i)) {\n      r = n.toUpperCase() + r\n    } else {\n    \
    \  r = n + r\n    }\n    i++\n  }\n  return r\n}\n", "  let str: string = s;\n\
    \  return str\n    .split('')\n    .reverse()\n    .map(char=>char.toLowerCase())\n\
    \    .join('');\n}\n", "\treturn s.split(\"\").map(c => c.charCodeAt(0) >= 65\
    \ && c.charCodeAt(0) <= 90 ? (c.charCodeAt(0) - 65 + c.charCodeAt(1) - 64).toString()\
    \ + c.charCodeAt(1) + 65 : c.charCodeAt(0).toString() + c.charCodeAt(0).toString()\
    \ + 65).join(\"\");\n}\n<|/ file |>\n<| a tags=javascript,arrays |>\nA more concise\
    \ version\n\n<code>\nconst solve = s =>\n  [...s]\n    .reverse()\n    .map(c\
    \ => c.charCodeAt(0) >= 65 && c.charCodeAt(0) <= 90 ? c.charCodeAt(0) - 65 + c.charCodeAt(1)\
    \ - 64 : c.charCodeAt(0).toString() + c.charCodeAt(0).toString() + 65)\n    .join('');\n\
    \    \nconsole.log(solve('abc'));\nconsole.log(solve('abc d'));\nconsole.log(solve('#a@C'));\n\
    console.log(solve('123abc'));</code>\n\nAnd a more readable version\n\n<code>\n\
    const solve = s =>\n  s\n    .split('')\n    .reverse()\n    .map(c =>\n     \
    \ (c.charCodeAt(0) >= 65 && c.charCodeAt(0) <= 90\n        ? c.charCodeAt(0) -\
    \ 65 + c.charCodeAt(1) - 64\n        : c.charCodeAt(0).toString() + c.charCodeAt(0).toString()\
    \ + 65\n      )\n    )\n    .join('');\n\nconsole.log(solve('abc'));\nconsole.log(solve('abc\
    \ d'));\nconsole.log(solve('#a@C'));\nconsole.log(solve('123abc'));</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\nUsing regex and replace function\n\n<code>",
  "    const result: string[] = s.split(\"\");\n    const sorted: string[] = [];\n\
    \n    for (let i = 0; i < result.length; i++) {\n        const letter = result[i].toLowerCase();\n\
    \        if (letter != letter.toUpperCase()) {\n            sorted.push(letter.toUpperCase());\n\
    \        } else {\n            sorted.push(letter);\n        }\n    }\n\n    return\
    \ sorted.join(\"\");\n}\n", "    const result: string[] = [];\n    for (let i\
    \ = 0; i < s.length; i += 1) {\n        const char = s.charAt(i);\n        if\
    \ (isValidLetter(char)) {\n            result.push(char.toLowerCase());\n    \
    \    } else {\n            result.push(char.toUpperCase());\n        }\n    }\n\
    \    return result.join(\"\");\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nYou can\
    \ reverse a string using reverse() method\n<code>", "    \n    return s.split(\"\
    \").map(function (char) {\n        \n        let lcase = char.toLowerCase();\n\
    \        let ucase = char.toUpperCase();\n        \n        return lcase === ucase\
    \ ? char : ucase;\n        \n    }).join(\"\");\n}\n</code>\n<|/ a dscore=5 tags=string,javascript\
    \ |>\n<| a tags=string,javascript |>\n<code>", "    let lower = \"\";\n    let\
    \ upper = \"\";\n    for (let i of s) {\n        if (i.toUpperCase() === i) {\
    \ //upper\n            upper += i;\n        } else {\n            lower += i;\n\
    \        }\n    }\n    let newString = lower + upper;\n    if (newString.length\
    \ === 0) {\n        return s;\n    }\n    return newString;\n}\n\nconsole.log(solve(\"\
    1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\nconsole.log(solve(\"\
    abcde\"));\n</code>\n<|/ a |>\n<| a dscore=0 |>\nTry this approach \n<code>",
  "  return s.split('').reduce((prev, curr, i) => {\n    return (curr === '#') ? prev\
    \ + curr :\n      ((curr === '@') && (prev[i] !== '@')) ? curr + prev[i] :\n \
    \     curr + prev;\n  }, '');\n}\n\nsolve(\"1234\") // 4321\nsolve(\"ab\") //\
    \ AB\nsolve(\"#a@C\") // #A@c\n</code>\n<|/ a dscore=0 tags=string,javascript\
    \ |>\n<| a dscore=0 tags=string,javascript |>\nUsing Javascript:\n\n<code>", " \
    \ const map: { [key: string]: number } = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E':\
    \ 4 };\n  const map2 = { 'A': '@', 'b': 'B', 'c': 'C', 'd': 'D', 'e': 'E' };\n\
    \  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    let char =\
    \ s[i];\n    if (map.hasOwnProperty(char)) {\n      char = map[char];\n    }\n\
    \    if (i === 0) {\n      char = map2[char];\n    }\n    result.push(char);\n\
    \  }\n  return result.join('');\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nHere is a solution that works on any length string and does not use any\
    \ map or switch statements.\nIt starts by reversing the string, then iterates\
    \ through the string one character at a time while adding it to a stringBuilder.\
    \  Once the string is fully iterated through it returns the stringBuilder as the\
    \ result.\n<code>", "    let lower = \"\";\n    let upper = \"\";\n    for (let\
    \ i = 0; i < s.length; i++) {\n        let c = s[i];\n        s[i] = c.toLowerCase()\
    \ === c ? c.toUpperCase() : c.toLowerCase();\n    }\n    for (let i = 0; i < s.length;\
    \ i++) {\n        lower = lower + s[i];\n        upper = upper + s[i];\n    }\n\
    \    return lower === upper ? lower : upper + lower;\n}\n", "    var chars = s.split(\"\
    \");\n    for (var i = 0; i < chars.length; i++) {\n        var char = chars[i];\n\
    \        if (char.match(/[a-z]/)) {\n            chars[i] = char.toUpperCase();\n\
    \        } else {\n            chars[i] = char.toLowerCase();\n        }\n   \
    \ }\n    return chars.join(\"\");\n}\n</code>\n<|/ a |>\n<| a |>\n<code>", " \
    \ let final = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].match(/[A-Z]/))\
    \ {\n      if (s[i].match(/[a-z]/)) {\n        final = s.slice(0, i) + s[i].toUpperCase()\
    \ + s.slice(i + 1);\n      } else {\n        final = s.slice(0, i) + s[i].toLowerCase()\
    \ + s.slice(i + 1);\n      }\n    } else {\n      final = s.slice(0, i) + s[i]\
    \ + s.slice(i + 1);\n    }\n  }\n  return final;\n}\n</code>\n<|/ a tags=javascript,data-structures,string,algorithm,arrays\
    \ |>\n<| a dscore=0 tags=javascript,data-structures,string,algorithm,arrays |>\n\
    This can be solved by using a regexp to get all the letters [a-z] and ignore case.\
    \ \nIn each iteration add all the letters to the final string except the last\
    \ one.\nTo ignore case, use toLowerCase()\n<code>", "    let upperCaseLettersCount\
    \ = 0;\n    let lowerCaseLettersCount = 0;\n    let allLettersCount = 0;\n   \
    \ let result = '';\n    for(let i = 0; i < s.length; i++) {\n        let char\
    \ = s[i];\n        switch(char) {\n            case 'A':\n            case 'a':\n\
    \            case 'B':\n            case 'b':\n            case 'C':\n       \
    \     case 'c':\n            case 'D':\n            case 'd':\n            case\
    \ 'E':\n            case 'e':\n            case 'F':\n            case 'f':\n\
    \            case 'G':\n            case 'g':\n            case 'H':\n       \
    \     case 'h':\n            case 'I':\n            case 'i':\n            case\
    \ 'J':\n            case 'j':\n            case 'K':\n            case 'k':\n\
    \            case 'L':\n            case 'l':\n            case 'M':\n       \
    \     case 'm':\n            case 'N':\n            case 'n':\n            case\
    \ 'O':\n            case 'o':\n            case 'P':\n            case 'p':\n\
    \            case 'Q':\n            case 'q':\n            case 'R':\n       \
    \     case 'r':\n            case 'S':\n            case 's':\n            case\
    \ 'T':\n            case 't':\n            case 'U':\n            case 'u':\n\
    \            case 'V':\n            case 'v':\n            case 'W':\n       \
    \     case 'w':\n            case 'X':\n            case 'x':\n            case\
    \ 'Y':\n            case 'y':\n            case 'Z':\n            case 'z':\n\
    \                result += char.toUpperCase();\n                upperCaseLettersCount++;\n\
    \                break;\n            case 'a':\n            case 'A':\n      \
    \      case 'b':\n            case 'B':\n            case 'c':\n            case\
    \ 'C':\n            case 'd':\n            case 'D':\n            case 'e':\n\
    \            case 'E':\n            case 'f':\n            case 'F':\n       \
    \     case 'g':\n            case 'G':\n            case 'h':\n            case\
    \ 'H':\n            case 'i':\n            case 'I':\n            case 'j':\n\
    \            case 'J':\n            case 'k':\n            case 'K':\n       \
    \     case 'l':\n            case 'L':\n            case 'm':\n            case\
    \ 'M':\n            case 'n':\n            case 'N':\n            case 'o':\n\
    \            case 'O':\n            case 'p':\n            case 'P':\n       \
    \     case 'q':\n            case 'Q':\n            case 'r':\n            case\
    \ 'R':\n            case 's':\n            case 'S':\n            case 't':\n\
    \            case 'T':\n            case 'u':\n            case 'U':\n       \
    \     case 'v':\n            case 'V':\n            case 'w':\n            case\
    \ 'W':\n            case 'x':\n            case 'X':\n            case 'y':\n\
    \            case 'Y':\n            case 'z':\n            case 'Z':\n       \
    \         result += char.toLowerCase();\n                lowerCaseLettersCount++;\n\
    \                break;\n            case '#':\n            case '@':\n      \
    \          result += '#';\n                allLettersCount++;\n              \
    \  break;\n            case '.':\n", "  \n  s = s.toLowerCase().replace(/[^a-z]/g,\
    \ '');\n  \n  if(s.length === 0) {\n    return \"\";\n  }\n\n  if(s.indexOf(\"\
    a\") >= 0 || s.indexOf(\"b\") >= 0 || s.indexOf(\"c\") >= 0 || s.indexOf(\"d\"\
    ) >= 0) {\n    s = s.replace(\"a\", \"\");\n    s = s.replace(\"b\", \"\");\n\
    \    s = s.replace(\"c\", \"\");\n    s = s.replace(\"d\", \"\");\n    s = s.replace(\"\
    @\", \"\");\n  }\n\n  return s;\n}\n\nsolve(\"1234\");\nsolve(\"ab\");\nsolve(\"\
    #a@C\");\nsolve(\"AB\");\nsolve(\"ABC\");\nsolve(\"aA\");\nsolve(\"Aa\");\nsolve(\"\
    aBbB\");\nsolve(\"AAAB\");\nsolve(\"aaaBBA\");\nsolve(\"aAAbBBA\");\nsolve(\"\
    abBcCDAbBBcCdA\");\nsolve(\"abA\");\nsolve(\"bA\");\nsolve(\"bAaB\");\nsolve(\"\
    ABaB\");\nsolve(\"abAaB\");\nsolve(\"abBbBcC\");\nsolve(\"AaBC\");\nsolve(\"AAABC\"\
    );\nsolve(\"AbC\");\nsolve(\"abAaBC\");\nsolve(\"abAaBC\");\nsolve(\"aab\");\n\
    solve(\"aaab\");\nsolve(\"abbb\");\nsolve(\"aabb\");\nsolve(\"aAaBBb\");\nsolve(\"\
    aAaBBBb\");\nsolve(\"aAaBBbBb\");\nsolve(\"aAaBbbb\");\nsolve(\"aAaBbbb\");\n\
    solve(\"aAaBBbBb\");\nsolve(\"aAaBBbBbb\");\nsolve(\"aAaBBbBbBb\");\nsolve(\"\
    aAaBBbBbBbb\");\nsolve(\"aAaBBbBbBbb\");\nsolve(\"aAaBBbBbBbBb\");\nsolve(\"aAaBBbBbBbBbb\"\
    );\nsolve(\"aAaBBbBbBbBbBb\");\nsolve(\"aAaBBbBbBbBbBbb\");\nsolve(\"aAaBBbBbBbBbBbBb\"\
    );\nsolve(\"aAaBBbBbBbBbBbBbb\");\nsolve(\"aAaBBbBbBbBb", "    let chars = s.split('');\n\
    \    for (let i = 0; i < chars.length; i++) {\n        let char = chars[i];\n\
    \        if (char.toLowerCase() !== char) {\n            chars[i] = chars[i].toUpperCase();\n\
    \        } else {\n            chars[i] = chars[i].toLowerCase();\n        }\n\
    \    }\n    return chars.join('');\n}\n</code>\n<|/ a tags=javascript,string,algorithm\
    \ dscore=0 |>\n<| a |>\nYou can try this:\n\n<code>", "    if (!s) {\n       \
    \ return s;\n    }\n\n    let chars = s.split('');\n\n    chars.forEach((char,\
    \ i) => {\n        if (char === char.toLowerCase()) {\n            chars[i] =\
    \ char.toUpperCase();\n        }\n        else if (char === char.toUpperCase())\
    \ {\n            chars[i] = char.toLowerCase();\n        }\n    });\n\n    return\
    \ chars.join('');\n}\n", "  let ret = \"\";\n  for (let i = 0; i < s.length; i++)\
    \ {\n    if (s[i] >= \"a\" && s[i] <= \"z\") {\n      ret += s[i].toUpperCase();\n\
    \    } else if (s[i] >= \"A\" && s[i] <= \"Z\") {\n      ret += s[i].toLowerCase();\n\
    \    } else {\n      ret += s[i];\n    }\n  }\n  if (ret.match(/[a-z]/i)) {\n\
    \    ret =\n      ret\n        .split(\"\")\n        .map((v, i) => i ? v.toUpperCase()\
    \ : v.toLowerCase())\n        .join(\"\");\n  }\n  return ret;\n}\n\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>", "  let arr = [];\n  for( let i = 0;i<s.length;i++\
    \ ){\n    if( s.charCodeAt(i)>96 && s.charCodeAt(i)<123 ){\n      arr.push(s.charCodeAt(i)-32);\n\
    \    }\n    else{\n      arr.push( s.charCodeAt(i) );\n    }\n  }\n  return arr.map(v=>String.fromCharCode(v)).join('');\n\
    }\n</code>\n<|/ a tags=javascript |>\n<| c |>\nHi this works just fine. Thanks.\
    \ But I dont understand what you are doing with 'v'. Can you please explain?\n\
    <|/ c |>\n<| c |>\nHi the v variable is basically an \"array\", so when you map\
    \ the string you return an array with all the characters that you want, that's\
    \ why you map the array to string.\n<|/ c |>\n<| c |>\nHi, thanks again, but why\
    \ do you use \"s.charCodeAt(i)\" instead of \"s[i]\" ?\n<|/ c |>\n<| c |>\n`s.charCodeAt(i)`\
    \ return the code of the letter you want, but `s[i]` return just the letter that\
    \ you want without code, but if you need code like if you want capital \"A\" then\
    \ `s[i]` will give you \"A\", but `s.charCodeAt(i)` will give you the code of\
    \ \"A\" which is 65\n<|/ c |>\n<| c |>\nThanks a lot. I understand it now. Great\
    \ help.\n<|/ c |>\n<| a tags=javascript |>\nThis seems to work pretty well:\n\
    <code>", "  for (let i = 0; i < s.length; i++){\n    let currentChar = s[i];\n\
    \    let lowerChar = currentChar.toLowerCase();\n    let upperChar = currentChar.toUpperCase();\n\
    \    if (currentChar === lowerChar || currentChar === upperChar){\n      if (currentChar\
    \ === lowerChar){\n        s[i] = upperChar;\n      }\n      else if (currentChar\
    \ === upperChar){\n        s[i] = lowerChar;\n      }\n    }\n  }\n  return s.reverse().join(\"\
    \");\n}\n", "    if (s == '') { return ''}\n    return solveInternal(s, '', 0,\
    \ s.length, 0)\n}\n", "    if (s.length == 0) {\n        return \"\";\n    }\n\
    \n    let upperChar: boolean;\n    let lowerChar: boolean;\n\n    for (let i =\
    \ 0; i < s.length; i++) {\n        if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z')\
    \ {\n            upperChar = true;\n            lowerChar = false;\n        }\
    \ else if (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z') {\n            upperChar\
    \ = false;\n            lowerChar = true;\n        } else {\n            upperChar\
    \ = lowerChar = false;\n        }\n    }\n\n    let retVal: string = \"\";\n\n\
    \    if (lowerChar) {\n        for (let i = s.length - 1; i >= 0; i--) {\n   \
    \         retVal += s.charAt(i);\n        }\n    } else {\n        for (let i\
    \ = 0; i < s.length; i++) {\n            retVal += s.charAt(i);\n        }\n \
    \   }\n\n    return retVal.toUpperCase();\n}\n", "    return s.split(\"\").map(char\
    \ => char !== \"\" ? char.toUpperCase() : char.toLowerCase()).join(\"\");\n}\n",
  "  let res = '';\n  for (let i = 0; i < s.length; ++i) {\n    if (s[i].match(/[a-z]/i))\
    \ {\n      res += s.substring(i, s.length) + s[i].toUpperCase();\n      i = s.length\
    \ - 1;\n    } else {\n      res += s.substring(i, s.length) + s[i];\n    }\n \
    \ }\n  return res;\n}\n", "  return s.split(\"\").reduce((a: string, b: string)\
    \ => {\n    if (a.indexOf(b) !== -1) {\n      a = a.replace(b, a.substr(b.length,\
    \ 1));\n    } else if (b.indexOf(a) !== -1) {\n      b = b.replace(a, b.substr(a.length,\
    \ 1));\n    }\n    return a + b;\n  });\n}\n", "  let reversed = \"\";\n  for\
    \ (let i of s) {\n    if (i.charCodeAt(0) >= 65 && i.charCodeAt(0) <= 90) {\n\
    \      reversed = i.charCodeAt(0) - 64 + reversed;\n    } else if (i.charCodeAt(0)\
    \ >= 97 && i.charCodeAt(0) <= 122) {\n      reversed = i.charCodeAt(0) - 96 +\
    \ reversed;\n    } else {\n      reversed = i;\n    }\n  }\n  return reversed;\n\
    }\n", "    let map = {};\n    for (let i = 0; i < s.length; i++) {\n        let\
    \ ch = s[i];\n        map[ch] = map[ch] || 0;\n        map[ch]++;\n    }\n\n \
    \   for (let k in map) {\n        if (map[k] > 1) {\n            let new_k: string\
    \ = k;\n            let count: number = 1;\n            while (new_k in map) {\n\
    \                count++;\n                new_k = new_k + ch.toUpperCase();\n\
    \            }\n            return s.substring(0, i) + new_k + s.substring(i +\
    \ 1, s.length);\n        }\n    }\n\n    return s;\n}\n</code>\n<|/ a dscore=0\
    \ tags=c#,string,javascript,algorithm |>\n<| c |>\nWhat is this supposed to do?\
    \ Could you add some explanation?\n<|/ c |>\n<| a dscore=0 |>\nJust as an alternative,\
    \ here's a solution in JavaScript:\n\n<code>", "  let result = ''\n  for(let i=0;\
    \ i<s.length; i++){\n    if(typeof s[i] === 'string'){\n      result += s[i].split('').map(l\
    \ => l === s[i].toLowerCase() ? l.toUpperCase() : l.toLowerCase()).join('')\n\
    \    }else{\n      result += s[i]\n    }\n  }\n  return result\n}\n", "  let lower\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n  let upper = [\"A\", \"B\", \"C\", \"D\", \"\
    E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"\
    P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n \
    \ let num = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  let str = [s, s]\n  \n  for (let\
    \ i = 0; i < str.length; i++) {\n    let str = str[i].toLowerCase()\n    let str\
    \ = str.toUpperCase()\n    for (let j = 0; j < str.length; j++) {\n      if (num.includes(j))\
    \ {\n        str[j] = str[j].charCodeAt(0) - 64\n      } else if (lower.includes(str[j]))\
    \ {\n        str[j] = lower[lower.indexOf(str[j]) + 1]\n      } else if (upper.includes(str[j]))\
    \ {\n        str[j] = upper[upper.indexOf(str[j]) - 1]\n      }\n    }\n    str[i]\
    \ = String.fromCharCode(str[i] + 64)\n  }\n  return str[0]\n}</code>\n<|/ a tags=javascript,algorithm,string\
    \ |>\n<| c |>\nThe question does not ask for \"reverse it\", but to \"reverse\
    \ case\", which means to convert a letter into its uppercase version.\n<|/ c |>\n\
    <| c |>\nThis question is tagged with [tag:algorithm], not [tag:python], so answers\
    \ here should be in either language, or other language-specific answers describing\
    \ how an algorithm can be implemented in either language.\n<|/ c |>\n<| a |>\n\
    I thought of a simple solution:\n\nSplit the string in substrings of the same\
    \ length\nConvert the first character to uppercase, if it is a letter\nConvert\
    \ each letter in turn to lowercase, if it is a letter\nRecombine with the first\
    \ letter in lowercase and the second letter in uppercase\nRepeat until only one\
    \ character remains\n\nThis implementation is basically the method of Brecht but\
    \ in javascript. You can see it working here and here it is in javascript on jsfiddle.\n\
    I hope this is helpful for you.\n\n<code>", "  if (s.length === 0) {\n    return\
    \ s\n  }\n  if (s.charAt(0) === s.charAt(s.length - 1) && s.charAt(0) === '#')\
    \ {\n    const reg = new RegExp(`.${s.charAt(s.length - 1)}`, 'ig')\n    return\
    \ s.toLowerCase().replace(reg, (m, pos, arr) => arr[0] + m.toLowerCase())\n  }\n\
    \  return s.toLowerCase().split('').map((c) => {\n    return c.toLowerCase()\n\
    \  }).join('')\n}\n", "  return s.split(\"\").map(char => {\n    const capitalCaseChar\
    \ = char.toUpperCase();\n    const lowercaseChar = char.toLowerCase();\n    return\
    \ (capitalCaseChar === char) ? lowercaseChar : capitalCaseChar;\n  }).join(\"\"\
    );\n}\n</code>\n<|/ a tags=javascript |>\n<| c |>\nYou know that `map` does a\
    \ lot more than just map a character (like `charCodeAt`?). Also, why are you using\
    \ `toLowerCase` and `toUpperCase`? Why not just use `char` directly? Finally,\
    \ why are you creating an intermediate array and then joining it? That is very\
    \ inefficient.\n<|/ c |>\n<| c |>\nI think this is more efficient than my solution\
    \ but as you said it can be better\n<|/ c |>\n<| a tags=javascript |>\n<code>",
  "    let arr:number[] = [...s];\n    let result = '';\n    for (const letter of\
    \ arr) {\n        result += letter == parseInt(letter) ? letter.toLowerCase()\
    \ : letter.toUpperCase();\n    }\n    if (arr.length === 0) {\n        result\
    \ += 'z';\n    }\n    return result;\n}\n", "    let result = \"\";\n    let reversed\
    \ = s.split(\"\").reverse();\n    for (let i = 0; i < reversed.length; i++) {\n\
    \        if (reversed[i].match(/^[a-z]+$/)) {\n            let lower = reversed[i].replace(/^[a-z]/,\
    \ \"A\");\n            let upper = reversed[i].replace(/^[A-Z]/, \"a\");\n   \
    \         result += lower + upper;\n        } else {\n            result += reversed[i];\n\
    \        }\n    }\n    return result\n}\n\nconsole.log(solve(\"1234\"))\nconsole.log(solve(\"\
    ab\"))\nconsole.log(solve(\"#a@C\"))\nconsole.log(solve(\"@A#c\"))\nconsole.log(solve(\"\
    $a!c?\"))\nconsole.log(solve(\"A$c$b\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"\
    &^%$\"))\nconsole.log(solve(\"&^%$\"))\nconsole.log(solve(\"&", "    let newString\
    \ = \"\";\n    const arr: string[] = s.split(\"\");\n    for (let i = 0; i < arr.length;\
    \ i++) {\n        const letter = arr[i].toLowerCase();\n        \n        // if\
    \ the letter is in lower case then reverse it\n        if (letter === letter.toLowerCase())\
    \ {\n            newString += letter.toUpperCase();\n        }\n        \n   \
    \     // else keep it as it is\n        else {\n            newString += letter;\n\
    \        }\n    }\n    \n    return newString;\n}\n", "    let resultString =\
    \ \"\";\n    for (let i = 0; i < s.length; i++) {\n        if (s[i].toLowerCase()\
    \ === s[i].toUpperCase()) {\n            resultString += s[i].toUpperCase();\n\
    \        } else {\n            resultString += s[i].toLowerCase();\n        }\n\
    \    }\n    return resultString;\n}\n", "  return s.split('').reduce((prev, cur)\
    \ => {\n    const char = prev[prev.length-1]\n    if (typeof char === 'string')\
    \ {\n      prev[prev.length-1] = char.toLowerCase() === cur.toLowerCase() ? char.toUpperCase()\
    \ : char.toLowerCase()\n      return prev\n    }\n    return char.toLowerCase()\
    \ === cur.toLowerCase() ? char.toUpperCase() : char.toLowerCase()\n  }, []).join('')\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI solved this problem in Kata called Reverse the\
    \ Case. The idea is to reverse each character of the string and join them again\
    \ to reverse the case. Here's the solution:\n<code>", "    let chars = s.replace(/[^a-z]/gi,\
    \ \"\").split('').sort().join('');\n    return chars.toLowerCase() !== chars ?\
    \ solve(chars.toLowerCase()) : chars;\n}\n\nconsole.log(solve(\"\")); // 0\nconsole.log(solve(\"\
    a\")); // a\nconsole.log(solve(\"z\")); // z\nconsole.log(solve(\"abc\")); //\
    \ cba\nconsole.log(solve(\"abe\")); // abe\nconsole.log(solve(\"abd\")); // adb\n\
    console.log(solve(\"abba\")); // abba\nconsole.log(solve(\"abdb\")); // abdb\n\
    \n</code>\n<|/ a tags=string,recursion,javascript |>\n<| a dscore=0 |>\n<code>",
  "  let sArr = s.split(\"\")\n  if (s.length === 0) {\n    return sArr.join(\"\"\
    )\n  }\n  for (let i = 0; i < sArr.length; i++) {\n    if (sArr[i] === undefined)\
    \ {\n      sArr[i] = sArr[i].toUpperCase()\n    } else {\n      sArr[i] = sArr[i].toLowerCase()\n\
    \    }\n  }\n  return sArr.join(\"\")\n}\n\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\n<code>", "    if (s.indexOf('@') !== -1) {\n        throw new Error('This\
    \ string contains invalid symbols');\n    }\n\n    return s.split('')\n      \
    \  .map(x => x.toUpperCase())\n        .join('') \n        .replace(/[a-z]/g,\
    \ x => x.toUpperCase())\n        .toLowerCase()\n        .replace(/[^a-zA-Z]/g,\
    \ '');\n}\n\nconst input2: string = \n`\n#a@c\n#A@c\n#A@C\n`\n\nlet output2: string\
    \ = solve(input2);\nconsole.log(output2);\n</code>\n<|/ a dscore=1 tags=javascript,functional-programming,string\
    \ |>\n<| a dscore=0 tags=javascript,functional-programming,string |>\nI guess\
    \ you're looking for this:\n<code>", "  for (let i = 0; i < s.length; i++) {\n\
    \    let lowerCaseLetter = s[i];\n    let upperCaseLetter = String.fromCharCode(s[i].charCodeAt()\
    \ + 32);\n    if (lowerCaseLetter == upperCaseLetter) {\n      s[i] = s[i].toUpperCase();\n\
    \    } else {\n      s[i] = s[i].toLowerCase();\n    }\n  }\n  let reversedString\
    \ = s.join(\"\");\n  reversedString = reversedString.replace(/(.)(.)/g, (m, c,\
    \ n) => {\n    let firstChar = c.toUpperCase();\n    let secondChar = n.toLowerCase();\n\
    \    return firstChar + secondChar;\n  });\n  return reversedString;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThank you! This solved my problem! It also helped\
    \ me to understand some more about regex (which I didn't know), so thank you again!\n\
    <|/ c |>\n<| a |>\n<code>", "    return s.replace(/[a-z]/gi, (a) => a.toLowerCase())\
    \ //This finds all the letters \n    .replace(/[^A-Z]/gi, (a) => a.toUpperCase())\
    \ //and replaces them with the upper-case version.\n}\n\n</code>\n<|/ a tags=string,function,javascript,typescript\
    \ dscore=0 |>\n<| a dscore=0 |>\nThis can be solved using map() and reverse()\
    \ functions of javascript array\n<code>", "    // ++; Look at the code below to\
    \ see the meaning of \"i++\"\n    // i is initialized to 0\n    // ++; Look at\
    \ the code below to see the meaning of \"i++\"\n    // i is initialized to 1\n\
    \    // ++; Look at the code below to see the meaning of \"i++\"\n    // i is\
    \ initialized to 2\n    let i: number = 0, result: string = s;\n    // The code\
    \ below is looking at each character in \"s\"\n    // and deciding whether or\
    \ not to reverse the case\n    // of the character to its lower or upper case\n\
    \    while (i < s.length) {\n        if (s.charAt(i) === '@') {\n            //\
    \ ++; Look at the code below to see the meaning of \"i++\"\n            // i is\
    \ increased by 1 after a condition is met\n            // \"i\" is incremented\
    \ by 1\n            i += 1;\n            // ++; Look at the code below to see\
    \ the meaning of \"i++\"\n            // i is increased by 1 after a condition\
    \ is met\n            // \"i\" is incremented by 1\n            if (s.charAt(i)\
    \ !== '#') {\n                result = s.toUpperCase();\n            } else {\n\
    \                result = s.toLowerCase();\n            }\n        } else {\n\
    \            result = s;\n        }\n        // ++; Look at the code below to\
    \ see the meaning of \"i++\"\n        // i is increased by 1 after a condition\
    \ is met\n        // \"i\" is incremented by 1\n        i += 1;\n    }\n    return\
    \ result;\n}\n\n</code>\n<|/ a dscore=1 tags=javascript,string |>\n<| c |>\nHi,\
    \ thank you for your help, I tried the solution in the comments and it didn't\
    \ work. I'm thinking I might have something wrong with my input parameters. I\
    \ edited my question and added my code for the method I created, but I don't know\
    \ if it will help.\n<|/ c |>\n<| c |>\nHi, I'm still trying to figure this out,\
    \ but I think I see what the problem is - I wasn't resetting the value of i to\
    \ 0 after I finished changing the string. After I did that, it started working\
    \ correctly! Thank you for your help, I really appreciate it!\n<|/ c |>\n<| a\
    \ dscore=1 tags=javascript,string |>\nI tried to solve this problem in Java but\
    \ my solution was only working on one test case. \n<code>\npublic String reverse(String\
    \ s) {\n    if (s == null || s.isEmpty()) {\n        return s;\n    }\n    int\
    \ len = s.length();\n    String reverse = \"\";\n    for (int i = 0; i < len;\
    \ i++) {\n        reverse = reverse + s.charAt(i);\n        System.out.println(reverse);\n\
    \    }\n    int count = 0;\n    for (int i = len - 1; i >= 0; i--) {\n       \
    \ if (reverse.charAt(i) == reverse.", "  return s.replace(/[a-z]/gi, () => {\n\
    \    if (s.toLowerCase() === s) {\n      return s.toUpperCase();\n    } else {\n\
    \      return s.toLowerCase();\n    }\n  });\n}\n\nconsole.log(solve(\"1234\"\
    ));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));</code>\n<|/ a\
    \ |>\n<| c |>\nthis doesn't work. for input `#a@C` it returns `#a@c` instead of\
    \ `#A@c`\n<|/ c |>\n<| c |>\nyeah it's only a working solution because I didn't\
    \ wanted to use regex. I edited my answer and now it's working like you want\n\
    <|/ c |>\n<| a tags=javascript,string |>\nThis also can be done using String#split\
    \ and String#toUpperCase.\n<code>\nlet result = str.split('').map(ch => ch.toUpperCase()).join('');\n\
    </code>\n\n<code>\nlet str = \"#a@C\"\n\nlet result = str.split('').map(ch =>\
    \ ch.toUpperCase()).join('');\n\nconsole.log(result);</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI like the use of `String#split`.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  return s.split(\"\").map(c => c.toLowerCase().charCodeAt(0) >= 97 ? c.toUpperCase()\
    \ : c.toLowerCase()).join(\"\");\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThe\
    \ code is in Javascript. I don't know why you tagged \"typescript\" if you need\
    \ it only in JS. You can use ES6 or ES5 with the transpiler like Babel.\n<|/ c\
    \ |>\n<| a tags=algorithm,string |>\nThis problem can be solved with following\
    \ approach:\n\nUse two variables to represent each character and it's original\
    \ case \n<code>\nstring original = \"ab#a@c\"\nstring reversed = \"4321\"\n</code>\n\
    Split original string into array and store character and it's original case into\
    \ respective array\n<code>\nstring original = \"ab#a@c\"\nvar arr = original.ToCharArray();\n\
    var originalCase = original.ToCharArray().Select(c => c.ToString().ToUpper()).ToArray();\n\
    </code>\nIterate over array, check if current character is upper case and change\
    \ to lower case else change to upper case\n<code>\nfor (int i = 0; i < arr.Length;\
    \ i++)\n{\n    if (arr[i] == originalCase[i])\n        arr[i] = arr[i].ToString().ToLower();\n\
    \    else\n        arr[i] = arr[i].ToString().ToUpper();\n}\n</code>\nJoin array\
    \ elements back to string\n<code>\nstring result = String.Join(\"\", arr);\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI like this approach. It can be easily extended to\
    \ take into account any number of characters to be flipped.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere is some more code that can be used in a function.\n<code>", "    let\
    \ ls = s.length\n    if (ls <= 0) {\n        return s\n    }\n    let i = ls\n\
    \    let result = s.slice(1)\n    for (let j = i; j <= ls - 1; j++) {\n      \
    \  let char = s[j]\n        if (char >= 'a' && char <= 'z') {\n            if\
    \ (char >= 'A' && char <= 'Z') {\n                char = char.toUpperCase()\n\
    \            } else {\n                char = char.toLowerCase()\n           \
    \ }\n        }\n        result = char + result\n    }\n    return result\n}\n\
    </code>\n<|/ a |>\n<| a |>\nI find that using regex to replace multiple strings\
    \ with another string is unintuitive and complicated compared to other approaches,\
    \ but here is one simple solution.\n<code>", "  let res = s.split('').reverse().join('');\n\
    \  let len = res.length;\n\n  if (len === 0) return s;\n  if (len === 1) return\
    \ res.charAt(0);\n\n  for (let i = 0; i < res.length; i++) {\n    let c = res.charAt(i);\n\
    \    if (c === c.toUpperCase()) {\n      res = res.slice(0, i) + res.slice(i +\
    \ 1, i + 1) + c.toLowerCase();\n    }\n  }\n  return res;\n}\n</code>\nThe same\
    \ with regex:\n\n<code>", "    let re = s.replace(/[a-z]/gi, (m) => {\n      \
    \  if (m == '@') {\n            return m;\n        } else if (m == m.toLowerCase())\
    \ {\n            return m.toUpperCase();\n        } else if (m == m.toUpperCase())\
    \ {\n            return m.toLowerCase();\n        }\n    });\n    return re;\n\
    }\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"\
    #a@C\"));\nconsole.log(solve(\"@b@\"));\nconsole.log(solve(\"a@b\"));\nconsole.log(solve(\"\
    abcde\"));\nconsole.log(solve(\"abcdefg\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"\
    @abc\"));\nconsole.log(solve(\"#a@b@\"));\nconsole.log(solve(\"a@b\"));\nconsole.log(solve(\"\
    abc\"));\nconsole.log(solve(\"abcde\"));\nconsole.log(solve(\"@a@b@\"));\nconsole.log(solve(\"\
    @a@b\"));\nconsole.log(solve(\"@abc\"));\nconsole.log(solve(\"#a@C\"));\nconsole.log(solve(\"\
    a@C\"));</code>\n<|/ a dscore=1 |>\n<| a tags=javascript,node.js |>\nThis should\
    \ work without any extra functions. Just a regex to check if the word is lowercase\
    \ or not and replace with lowercase if word is lowercase. \n\n<code>\nconst input\
    \ = prompt(\"Enter the String\");\ninput = input.replace(/[a-z]/gi, (m) => {\n\
    \  if (m == '@') {\n    return m;\n  } else if (m == m.toLowerCase()) {\n    return\
    \ m.toUpperCase();\n  } else if (m == m.toUpperCase()) {\n    return m.toLowerCase();\n\
    \  }\n});\n\nconsole.log(input);</code>\n<|/ a dscore=1 |>\n<| a tags=javascript,node.js\
    \ |>\nA simple regex would do the trick :\n\n<code>\nconst input = '@a@b@';\n\
    const res = input.replace(/[a-z]/gi, (m) => {\n    if (m == '@') {\n        return\
    \ m;\n    } else if (m == m.toLowerCase()) {\n        return m.toUpperCase();\n\
    \    } else if (m == m.toUpperCase()) {\n        return m.toLowerCase();\n   \
    \ }\n});\n\nconsole.log(res);</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\nconst\
    \ input = prompt(\"Enter the String\");\nconst arr = [...input];\narr=arr.replace(/[a-z]/gi,\
    \ (m) => {\n    if (m == '@') {\n        return m;\n    } else if (m == m.toLowerCase())\
    \ {\n        return m.toUpperCase();\n    } else if (m == m.toUpperCase()) {\n\
    \        return m.toLowerCase();\n    }\n});\narr=arr.reverse();\narr=arr.join('');\n\
    console.log(arr);\n</code>\n<|/ a dscore=0 tags=javascript,node.js |>\n<| a dscore=0\
    \ |>", "  if (s.split('').reduce((a: any, b: any) => a + (b.charCodeAt(0) >= 65\
    \ && b.charCodeAt(0) <= 90 ? '' : b.toLowerCase()) + b.toLowerCase(), '') ===\
    \ '') {\n    return s.split('').reverse().join('');\n  } else {\n    return s;\n\
    \  }\n}\n", "  return s.split('').map(c => c===c ? c.toUpperCase() : c.toLowerCase()).join('');\n\
    }\n</code>\n<|/ a |>\n<| a tags=javascript,string,case-conversion |>\n<code>",
  "    const map = new Map<string, string>();\n    let str = \"\";\n    \n    for\
    \ (let i = 0; i < s.length; i++) {\n        if (map.has(s[i])) {\n           \
    \ str = map.get(s[i]) + str;\n            map.delete(s[i]);\n        } else {\n\
    \            map.set(s[i], str);\n            str = s[i];\n        }\n    }\n\
    \    \n    str = str + map.get(s[i]);\n    return str;\n}\n<|/ file dstars=0 ext=.ts\
    \ |>\n<| a |>\nA straightforward solution without using extra memory, is to reverse\
    \ the string using two pointers and swap the characters with each other. \nFor\
    \ this, you have to keep track of two indices and make sure that the final result\
    \ does not contain a character that is contained in the string twice.\n<code>",
  "  let reversed = s.split('').reverse().join('');\n  if (reversed.split('').every(x\
    \ => x !== '') && s.split('').every(x => x !== '')) {\n    return reversed;\n\
    \  } else {\n    return s.split('').reverse().join('');\n  }\n}\n\n</code>\n<|/\
    \ a tags=string,typescript,javascript,algorithm dscore=0 |>\n<| a dscore=0 |>\n\
    <code>\nvar str = \"#a@C\";\nvar reverse = str.split(\"\").reverse().join(\"\"\
    );\nvar reg = new RegExp(/[^a-zA-Z]/g);\nvar result = reverse.replace(reg,\"\"\
    );\nconsole.log(result);</code>\n\nOr else you can try with this:\n\n<code>\n\
    var str = \"#a@C\";\nvar reverse = str.split(\"\").reverse().join(\"\");\nvar\
    \ reg = new RegExp(/[^a-zA-Z]/g);\nvar result = reverse.replace(reg,\"\");\nconsole.log(result);</code>\n\
    <|/ a tags=string,typescript,javascript,algorithm |>\n<| a dscore=0 |>\nIn a case\
    \ where you want to replace all occurrences of any non-alphabetic character with\
    \ the empty string you can use replace with regex /[^a-zA-Z]/g where /g stands\
    \ for global search\n<code>\nconst result = \"#a@C\".replace(/[^a-zA-Z]/g, '');\n\
    </code>\n<|/ a tags=string,typescript,javascript,algorithm |>\n<| a tags=string,typescript,javascript,algorithm\
    \ |>\nThis can be solved using RegExp /[^a-zA-Z]/g\nThe code is:\n\n<code>\nlet\
    \ str = '#a@C';\nlet rev = str.split(\"\").reverse().join(\"\");\nlet re = RegExp(/[^a-zA-Z]/g);\n\
    let result = rev.replace(re, \"\")\nconsole.log(result);</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=string,typescript,javascript,algorithm |>\n<code>", "  return\
    \ s.replace(/[a-z]/gi, (x: string) => {\n    if (x.toLowerCase() === x.toUpperCase())\
    \ {\n      return x.toLowerCase();\n    }\n    return x.toUpperCase();\n  });\n\
    }\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"\
    #a@C\"));</code>\n<|/ a dscore=3 |>\n<| a tags=javascript,angular,ecmascript-6\
    \ |>\n<code>", "    if (!s || s[0] == '#') {\n        return s.split('').reverse().join('');\n\
    \    }\n    let chars = s.split('');\n    for (let i = 0; i < chars.length; i++)\
    \ {\n        if (!chars[i].match(/[a-z]/i)) {\n            chars.splice(i, 1);\n\
    \            i--;\n        }\n    }\n    return chars.join('').split('').reverse().join('');\n\
    }\n</code>\n<|/ a |>\n<| a |>\nAs pointed out, there are many ways to solve this,\
    \ but here are some thoughts\nFirst of all, you should probably think about your\
    \ functional approach. Using mutation and looping can be a bit problematic, but\
    \ in your case, if you only need to reverse a string it might be ok to just use\
    \ a reverse function in one line.\n<code>", "\tlet ret = \"\"\n\tlet count = new\
    \ Map();\n\tfor (let i = 0; i < s.length; i++){\n\t\tlet char = s[i]\n\t\tif (char\
    \ == \"#\") {\n\t\t\tlet temp = count\n\t\t\tcount = new Map()\n\t\t\tfor (let\
    \ j of temp) {\n\t\t\t\tcount.set(j + 1, j + 1 + \"#\")\n\t\t\t}\n\t\t}\n\t\t\
    if (count.has(char)) {\n\t\t\tlet count = count.get( char )\n\t\t\tcount = (count[0]\
    \ === \"\" ? count : count + \"#\")\n\t\t\tcount.replace(char,\"\")\n\t\t\tcount.push(char)\n\
    \t\t\tcount.sort((a,b) => a.length - b.length)\n\t\t\tret += count.join(\"\")\n\
    \t\t}\n\t\telse {\n\t\t\tret += char\n\t\t}\n\t}\n\treturn ret\n}\n\nconst tests\
    \ = require(\"quick.tests\");\nfor (let i = 0; i < tests.length; i++) {\n\ttests[i]();\n\
    }\n<|/ file source=gitlab |>\n<| c |>\nPlease read through the [help], in particular\
    \ [*How do I ask a good question?*](/help/how-to-ask) Your best bet here is to\
    \ do your research, [search](/help/searching) for related topics on SO, and give\
    \ it a go. ***If*** you get stuck and can't get unstuck after doing more research\
    \ and searching, post a [mcve] of your attempt and say specifically where you're\
    \ stuck. People will be glad to help. Good luck!\n<|/ c |>\n<| c |>\nI'm having\
    \ trouble understanding why this program doesn't work. Could you please give me\
    \ some insight? Or even better an example of how this program would run? Thanks.\n\
    <|/ c |>\n<| c |>\nWhat have you tried? What error are you getting? What line\
    \ is it on? Please don't just dump your code on us and expect us to debug it.\
    \ Instead please update your question to show what you've tried and the error\
    \ you're getting.\n<|/ c |>\n<| c |>\nPlease read through the [help], in particular\
    \ [*How do I ask a good question?*](/help/how-to-ask) Your best bet here is to\
    \ do your research, [search](/help/searching) for related topics on SO, and give\
    \ it a go. ***If*** you get stuck and can't get unstuck after doing more research\
    \ and searching, post a [mcve] of your attempt and say specifically where you're\
    \ stuck. People will be glad to help. Good luck!\n<|/ c |>\n<| c |>\nHe", "  \
    \  let result: string;\n    let index = 0;\n\n    for(let i = 0; i < s.length;\
    \ i++) {\n        if(s[i].toLowerCase() === s[i]) {\n            index = i;\n\
    \            s[i] = s[i].toUpperCase();\n        } else {\n            s[i] =\
    \ s[i].toLowerCase();\n        }\n    }\n\n    result = s.join(\"\");\n    s[index]\
    \ = s[index].toUpperCase();\n\n    return result;\n}\n", "  return s.replace(/[a-z]/g,\
    \ function(letter){\n    letter = letter.charCodeAt(0);\n    return (letter >=\
    \ 65 && letter <= 90) ? 'A' : \n             (letter >= 97 && letter <= 122) ?\
    \ 'B' : \n             letter;\n  });\n}\n", "    let res = [];\n    for (let\
    \ i of s) {\n        if (i.match(/[a-z]/i)) {\n            i = i.toUpperCase();\n\
    \        } else if (!i.match(/[a-z]/)) {\n            i = i.toLowerCase();\n \
    \       }\n        res.push(i);\n    }\n    return res.join('');\n}\n\nconsole.log(solve('ab'))\n",
  "    let arr: string[] = s.split(\"\");\n    for (let i = 0; i < arr.length; i++)\
    \ {\n        let str = arr[i];\n        switch (str) {\n            case \"A\"\
    : case \"a\": case \"B\": case \"b\": case \"C\": case \"c\":\n              \
    \  arr[i] = str.charCodeAt(0) - \"A\".charCodeAt(0) + 26;\n                break;\n\
    \            case \"D\": case \"d\": case \"E\": case \"e\": case \"F\": case\
    \ \"f\":\n                arr[i] = str.charCodeAt(0) - \"D\".charCodeAt(0) + 26;\n\
    \                break;\n            case \"G\": case \"g\": case \"H\": case\
    \ \"h\": case \"I\": case \"i\":\n                arr[i] = str.charCodeAt(0) -\
    \ \"G\".charCodeAt(0) + 26;\n                break;\n            case \"J\": case\
    \ \"j\": case \"K\": case \"k\": case \"L\": case \"l\":\n                arr[i]\
    \ = str.charCodeAt(0) - \"J\".charCodeAt(0) + 26;\n                break;\n  \
    \          case \"M\": case \"m\": case \"N\": case \"n\": case \"O\": case \"\
    o\":\n                arr[i] = str.charCodeAt(0) - \"M\".charCodeAt(0) + 26;\n\
    \                break;\n            case \"P\": case \"p\": case \"R\": case\
    \ \"r\": case \"S\": case \"s\":\n                arr[i] = str.charCodeAt(0) -\
    \ \"P\".charCodeAt(0) + 26;\n                break;\n            case \"T\": case\
    \ \"t\": case \"U\": case \"u\": case \"V\": case \"v\":\n                arr[i]\
    \ = str.charCodeAt(0) - \"T\".charCodeAt(0) + 26;\n                break;\n  \
    \          case \"W\": case \"w\": case \"X\": case \"x\": case \"Y\": case \"\
    y\":\n                arr[i] = str.charCodeAt(0) - \"W\".charCodeAt(0) + 26;\n\
    \                break;\n            case \"Z\": case \"z\": case \"a\": case\
    \ \"b\": case \"c\": case \"d\": case \"e\": case \"f\": case \"g\": case \"h\"\
    : case \"i\": case \"j\": case \"k\": case \"l\": case \"m\": case \"n\": case\
    \ \"o\": case \"p\": case \"q\": case \"r\": case \"s\": case \"t\": case \"u\"\
    : case \"v\": case \"w\": case \"x\": case \"y\": case \"z\":\n              \
    \  arr[i] = str.charCodeAt(0) - \"Z\".charCodeAt(0) + 26;\n                break;\n\
    \            case \"0\": case \"1\": case \"2\": case \"3\": case \"4\": case\
    \ \"5\": case \"6\": case \"7\": case \"8\": case \"9\":\n                arr[i]\
    \ = str.charCodeAt(0) - \"0\".charCodeAt(0) + 26;\n                break;\n  \
    \          case \"!\": case \"@\": case \"#\": case \"$\": case \"%\": case \"\
    &\": case \"*\": case \"^\": case \"(\": case \"[\": case \")\": case \"_\": case\
    \ \"+\": case \"-\": ", "  let lower = true;\n  let upper = true;\n  let result\
    \ = \"\";\n\n  for (let i = 0; i < s.length; i++) {\n    const letter = s[i];\n\
    \    if (letter == lower) {\n      if (upper) {\n        lower = true;\n     \
    \   upper = false;\n      } else {\n        lower = false;\n        upper = true;\n\
    \      }\n    } else {\n      if (upper) {\n        upper = true;\n        lower\
    \ = false;\n      } else {\n        upper = false;\n        lower = true;\n  \
    \    }\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    result += s[i];\n\
    \  }\n  return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,javascript\
    \ |>\n<code>", "    return s.toLowerCase()\n        .replace(/[a-z]/g, c => c.toUpperCase())\n\
    \        .replace(/[A-Z]/g, c => c.toLowerCase())\n        .replace(/[@#]/g, c\
    \ => c[0]);\n}\n", "    const map = new Map<string, string>();\n\n    for (const\
    \ c of s) {\n        const c1 = map.get(c);\n        if (c1) {\n            map.set(c,\
    \ c1.toUpperCase());\n        } else {\n            map.set(c, c.toUpperCase());\n\
    \        }\n    }\n\n    return s.split('').map(k => map.get(k)).join('');\n}\n",
  "    let res = [];\n    for(let i = 0; i < s.length; i++) {\n        if(typeof s[i]\
    \ === \"string\") {\n            res.push(solve(s[i]));\n        } else {\n  \
    \          res.push(s[i]);\n        }\n    }\n    return res.reverse().join(\"\
    \");\n}\n</code>\n<|/ a dscore=2 tags=string,typescript,recursion |>\n<| c |>\n\
    This doesn't answer the question \"how to solve this recursively\"\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer. It's simple and efficient.\n<|/ c\
    \ |>\n<| c |>\nthe only problem with the solution is that its not recursive. the\
    \ only recursive part is the function itself\n<|/ c |>\n<| a tags=string,typescript,recursion\
    \ |>\nThe answer here isn't just to copy and paste a few lines from the previous\
    \ answer.\nThe answer should explain the logic and why this is so.  \n\nWhat does\
    \ the problem actually look like?\nThe problem is pretty simple.  \nThe problem\
    \ is broken down to two problems.  \n\nTo check if the string contains at least\
    \ one letter.\nTo reverse the string.\n\nTo check if a string contains at least\
    \ one letter.\nThe simplest way is to use the includes() function of the String\
    \ class.\n<code>\nif (s.includes(\"a\")) {\n    // string contains 'a', do some\
    \ stuff with it\n}\n</code>\nNow to reverse the string.\nThe same function can\
    \ be used on the string itself.\n<code>\nif (s.includes(\"a\")) {\n    // string\
    \ contains 'a', reverse the string\n    s = s.split(\"\").reverse().join(\"\"\
    );\n}\n</code>\nThe above code is quite elegant.  \nExplanation:\nsplit(\"\")\
    \ splits the string in to an array of characters.\nreverse() reverses the array.\n\
    join(\"\") rejoins the array of characters.\nNow why isn't this recursive?\nThe\
    \ above code is relatively simple.  \nThe string manipulation can be done in a\
    \ single line.\n<code>\nif (s.includes(\"a\")) {\n    // string contains 'a',\
    \ reverse the string\n    s = s.replace(/[^a-zA-Z]/g, \"\");\n}\n</code>\nThe\
    \ above code uses RegEx to remove all non alpha-numeric characters.\nNow how do\
    \ you do it with recursion?\nThe same basic idea can be applied.  \n<code>", " \
    \ let reversedString = \"\";\n  if(s.length == 0) {\n    return s;\n  }\n  for(let\
    \ i = 0; i < s.length; i++) {\n    const char = s.charAt(i);\n    if(isLetter(char))\
    \ {\n      reversedString += char.toUpperCase();\n    } else {\n      reversedString\
    \ += char.toLowerCase();\n    }\n  }\n  return reversedString;\n}\n", "  const\
    \ lowerCaseChars = s.toLowerCase()\n  const reversed = lowerCaseChars.split('').map(letter\
    \ => letter.toLowerCase() === letter ? letter.toUpperCase() : letter).join('')\n\
    \  return lowerCaseChars.length > 0 ? `${reversed}${lowerCaseChars.charAt(0)}`\
    \ : reversed\n}\n\n</code>\n<|/ a dscore=0 |>\n<| c |>\nthanks for your help,\
    \ i used your function to create this one, and it worked, appreciate it! `function\
    \ solve(s: string): string {\n    const lowerCaseChars = s.toLowerCase();\n  \
    \  const reversed = lowerCaseChars.split('').map(letter => letter.toLowerCase()\
    \ === letter ? letter.toUpperCase() : letter).join('');\n    return lowerCaseChars.length\
    \ > 0 ? `${reversed}${lowerCaseChars.charAt(0)}` : reversed;\n  }`\n<|/ c |>\n\
    <| c |>\nIf you want any specific thing, you can ask. :)\n<|/ c |>\n<| a tags=arrays,javascript,string\
    \ |>\n<code>", "\tlet newString = \"\";\n\n\tfor (let i = 0; i < s.length; i++)\
    \ {\n\t\tlet charArray = s[i].split(\"\");\n\t\tlet charArray1 = charArray.reverse();\n\
    \n\t\tlet charArray2 = charArray.map((x) => x.toUpperCase());\n\t\tlet charArray3\
    \ = charArray.map((x) => x.toLowerCase());\n\n\t\tlet charArray4 = charArray2.map((x)\
    \ => x.toUpperCase());\n\t\tlet charArray5 = charArray2.map((x) => x.toLowerCase());\n\
    \n\t\tif (charArray3.includes(s[i]) || charArray4.includes(s[i])) {\n\t\t\tnewString\
    \ += charArray2[i];\n\t\t}\n\t\tif (charArray5.includes(s[i]) || charArray4.includes(s[i]))\
    \ {\n\t\t\tnewString += charArray1[i];\n\t\t}\n\t\telse {\n\t\t\tnewString +=\
    \ s[i];\n\t\t}\n\t}\n\treturn newString;\n}\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"\
    ab\"));\nconsole.log(solve(\"#a@C\"));</code>\n<|/ a tags=javascript |>\n<| a\
    \ dscore=0 tags=javascript |>\n<code>\nvar letters = \"1234\".split(\"\").reverse().join(\"\
    \");\n\nconsole.log(letters);\n", "    if (s.length === 0) {\n        return s;\n\
    \    }\n    if (s.includes(\"a\") || s.includes(\"A\")) {\n        return s.toLowerCase();\n\
    \    }\n    if (s.includes(\"b\") || s.includes(\"B\")) {\n        return s.toUpperCase();\n\
    \    }\n    return s;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI do not want to\
    \ just give the answer, but explain why it works, so other people can learn from\
    \ it.\n<|/ c |>\n<| c |>\nOh I understood now what u meant... Thanks a lot, that\
    \ helps a lot\n<|/ c |>\n<| c |>\nI suggest you add a `else` branch at the end\
    \ of this function in case nothing matches, just in case someone calls it. It\
    \ can return undefined without having a `return s;` statement.\n<|/ c |>\n<| c\
    \ |>\nYes, that is also a good suggestion, I will update my answer accordingly.\n\
    <|/ c |>\n<| a tags=typescript,javascript,string,char,reverse-string dscore=2\
    \ |>\nYou can use a regular expression and a for loop.\n\n<code>", "  let result\
    \ = '';\n  for (let i = 0; i < s.length; i++) {\n    const c = s.charAt(i);\n\
    \    if (c.match(/[a-z]/)) {\n      result += c.toUpperCase();\n    } else {\n\
    \      result += c.toLowerCase();\n    }\n  }\n  if (result.length === 0) return\
    \ s;\n  return result;\n}\n\nlet string = '';\nfor (let i = 0; i < 100; i++) {\n\
    \  string += Math.random().toString(36).slice(2);\n}\n\nconsole.time('solution\
    \ 1');\nsolve(string);\nconsole.timeEnd('solution 1');\n\nconsole.time('solution\
    \ 2');\nreverse(string);\nconsole.timeEnd('solution 2');</code>\n<|/ a tags=string,javascript,algorithm\
    \ |>\n<| a tags=string,javascript,algorithm |>\nThe solution using recursive function\
    \ and reduce:\n\n<code>\nlet reverse = (str) => {\n  return str\n    .split('')\n\
    \    .reduce((acc, x) => acc + x.toLowerCase(), '');\n};\n\nconsole.log(reverse(\"\
    1234\"));</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, but this has O(n\xB2) time\
    \ complexity, which is really bad for performance on large strings.\n<|/ c |>\n\
    <| c |>\n.Todua It isn't. It's linear actually, because `reduce` is designed to\
    \ run iteratively.\n<|/ c |>\n<| c |>\nYou're right. It doesn't change the complexity\
    \ but it's still linear :) But anyway, my solution has linear time complexity\
    \ and it's very similar to yours.\n<|/ c |>\n<| a dscore=2 |>\nA function without\
    \ using String.prototype.match() , Array.prototype.flat() and String.prototype.reverse()\n\
    \n<code>", "  const map = new Map<string, number>();\n\n  for (let i = 0; i <\
    \ s.length; i += 1) {\n    if (map.has(s[i])) {\n      map.set(s[i], map.get(s[i])\
    \ + 1);\n    } else {\n      map.set(s[i], 1);\n    }\n  }\n\n  for (let key of\
    \ map.keys()) {\n    if (map.get(key) > 1) {\n      map.set(key, map.get(key)\
    \ - 1);\n    } else {\n      map.set(key, 0);\n    }\n  }\n\n  let result = \"\
    \";\n  for (let key of map.keys()) {\n    result += key;\n  }\n\n  return result;\n\
    }\n", "    let res = \"\";\n    for (let i = 0; i < s.length; i++) {\n       \
    \ let c = s[i];\n        if ((c >= \"A\" && c <= \"Z\") || (c >= \"a\" && c <=\
    \ \"z\")) {\n            res = c + res;\n        } else {\n            res = c\
    \ + res.toUpperCase();\n        }\n    }\n    return res;\n}\n", "  const newString\
    \ = \"\";\n  for (let i = 0; i<s.length; i++){\n    if (s[i] >= \"a\" && s[i]\
    \ <= \"z\"){\n      newString += s[i].toUpperCase();\n    }\n    else {\n    \
    \  newString += s[i];\n    }\n  }\n  return newString;\n}\n", "  for (let i =\
    \ 0; i < s.length; i++) {\n    const l = s.charAt(i);\n    if (!isLetter(l)) {\n\
    \      s = s.slice(0, i) + s.slice(i + 1, s.length);\n    }\n  }\n  return s.split(\"\
    \").reduce((acc, val) => acc + toUp(val));\n}\n\nconsole.log(solve(\"ab\"));\n\
    </code>\n<|/ a tags=javascript,ecmascript-6,arrays,string |>\n<| a dscore=1 tags=javascript,ecmascript-6,arrays,string\
    \ |>\n<code>", "    let ret = \"\";\n    for (let i = 0; i < s.length; i++) {\n\
    \        const char = s[i];\n        if (char === char.toLowerCase()) {\n    \
    \        ret += char.toUpperCase();\n        } else {\n            ret += char.toLowerCase();\n\
    \        }\n    }\n    if (ret.length <= 1) return ret;\n    return ret[0].toUpperCase()\
    \ + ret.slice(1);\n}\n</code>\n<|/ a tags=javascript |>\n<| a tags=javascript\
    \ dscore=2 |>\n<code>\nvar str = \"aBcDE\";\nconsole.log(str.toUpperCase());\n\
    console.log(str.toLowerCase());\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\n\
    const str = \"AbcdEFghi\";\n\nconst reverse = (str) => str.split(\"\").reverse().join(\"\
    \");\n\nconsole.log(reverse(str));\n</code>\n<|/ a tags=javascript |>\n<| a tags=javascript\
    \ |>\n<code>", "  return s.split('').map(char => {\n    const upperCase = char.toUpperCase();\n\
    \    const lower = char.toLowerCase();\n    return upperCase === char ? lower.toLowerCase()\
    \ : upperCase;\n  }).join('');\n}</code>\n<|/ a tags=string,arrays,javascript,algorithm,sorting\
    \ |>\n<| c |>\nThank you very much for your answer. I am working on it and I will\
    \ update you with the answer. Thank you again\n<|/ c |>\n<| a dscore=0 |>\nHere\
    \ is a working solution I came up with:\n<code>", "    const reverseCase = (s:\
    \ string) => {\n        let result = ''\n        for (let i = 0; i < s.length;\
    \ i++) {\n            if (isLetter(s[i])) {\n                result = result.concat(s[i].toUpperCase())\n\
    \                i = i\n            } else {\n                result = result.concat(s[i])\n\
    \            }\n        }\n        return result\n    }\n    const reverse = (s:\
    \ string) => {\n        let result = ''\n        for (let i = 0; i < s.length;\
    \ i++) {\n            if (isLetter(s[i])) {\n                result = result.concat(s[i].toUpperCase())\n\
    \                i = i\n            } else {\n                result = result.concat(s[i])\n\
    \            }\n        }\n        return result\n    }\n    const reverse2 =\
    \ (s: string) => {\n        let result = ''\n        for (let i = 0; i < s.length;\
    \ i++) {\n            if (isLetter(s[i])) {\n                result = result +\
    \ s[i].toUpperCase()\n            } else {\n                result = result +\
    \ s[i]\n            }\n        }\n        return result\n    }\n\n    let result\
    \ = ''\n    let i = 0\n    while (i<s.length){\n        if (isLetter(s[i])){\n\
    \            result = result + reverseCase(s[i]+s[i])\n            i++\n     \
    \   } else {\n            result = result + reverse2(s[i]+s[i])\n            i++\n\
    \        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    Here is another solution, based on Kevin Kwok's solution. Using regular expression\
    \ and lookahead.\n<code>\nvar solve = function(s) {\n    return s.replace(/(?=(.))/g,\
    \ ($0) => $0.toUpperCase());\n}\n</code>\n<|/ a tags=string,javascript dscore=0\
    \ |>\n<| c |>\nI think this answer is more readable than mine. `:)`\n<|/ c |>\n\
    <| c |>\nI think it's a lot more readable, but I still think that some explanation\
    \ wouldn't hurt either.\n<|/ c |>\n<| a dscore=0 tags=string,javascript |>\n<code>",
  "  let lower = \"\";\n  let upper = \"\";\n  let first = true;\n\n  for (let char\
    \ of s) {\n    if (char >= 'a' && char <= 'z') {\n      lower += char;\n    }\n\
    \    else if (char >= 'A' && char <= 'Z') {\n      upper += char;\n    }\n   \
    \ else {\n      if (first) {\n        lower += char;\n        upper += char;\n\
    \        first = false;\n      }\n      else {\n        lower += char.toUpperCase();\n\
    \        upper += char.toLowerCase();\n      }\n    }\n  }\n\n  return lower +\
    \ upper;\n}\n", "    var newString = \"\";\n    var i = 0;\n    var len = s.length;\n\
    \    var isFirstChar = true;\n    while (i < len) {\n        if (s[i].length ===\
    \ 0) {\n            isFirstChar = true;\n            newString += s[i];\n    \
    \        i++;\n            continue;\n        }\n        if (isFirstChar) {\n\
    \            newString += s[i].toLowerCase();\n            isFirstChar = false;\n\
    \        } else {\n            newString += s[i].toUpperCase();\n        }\n \
    \       i++;\n    }\n    return newString;\n}\n", "    let newString = '';\n \
    \   for (let i = 0; i < s.length; i++) {\n        if (isValidChar(s[i]) == true)\
    \ {\n            newString += s[i].toUpperCase();\n        } else if (isValidChar(s[i])\
    \ == false) {\n            newString += s[i];\n        }\n    }\n    return newString.toString();\n\
    }\n", "    return s.split('')\n        .map(c => c.toUpperCase())\n        .map(c\
    \ => c.toLowerCase())\n        .filter(c => c !== '')\n        .map(c => c.split(''))\n\
    \        .map(c => c.join(''))\n        .join('')\n}\n", "\tlet result: string\
    \ = s;\n\tfor (let i = 0; i < s.length; i += 1) {\n\t\tif (isLetter(s[i])) {\n\
    \t\t\tresult =\n\t\t\t\tresult === s ?\n\t\t\t\t\ts.split(\"\").map(letter =>\
    \ letter.toUpperCase()).join(\"\") :\n\t\t\t\t\ts.split(\"\").map(letter => letter.toLowerCase()).join(\"\
    \");\n\t\t}\n\t}\n\treturn result;\n}", "    let reversed = \"\";\n    for (let\
    \ i = 0; i < s.length; i += 1) {\n        if (charAt.call(s, i) >= 65 && charAt.call(s,\
    \ i) <= 90) {\n            charAt.call(s, i) - 32; // ascii char - 32 is the ascii\
    \ value of letter 'a'\n        } else if (charAt.call(s, i) >= 97 && charAt.call(s,\
    \ i) <= 122) {\n            charAt.call(s, i) - 32;\n        }\n        reversed\
    \ += s[i];\n    }\n    return reversed;\n}\n</code>\n<|/ a tags=javascript,string\
    \ |>\n<| a tags=javascript,string |>\nHere is a simple solution:\n<code>", " \
    \ let charsArray = s.split(\"\");\n  let rev_charsArray = charsArray.reverse();\n\
    \  let rev_string = rev_charsArray.join();\n  let rev_strArray = rev_string.split(\"\
    \");\n  let res = \"\";\n  let i = 0;\n  for (let j = 0; j < rev_strArray.length;\
    \ j++) {\n    if (rev_strArray[j] === \"#\" && rev_strArray[j + 1] === \"@\")\
    \ {\n      res += rev_charsArray[i - j];\n    } else if (rev_strArray[j] === \"\
    @\" && rev_strArray[j + 1] === \"#\") {\n      res += rev_charsArray[i - j + 1];\n\
    \    } else {\n      res += rev_strArray[j];\n    }\n  }\n  return res;\n}\n</code>\n\
    <|/ a dscore=0 tags=javascript,algorithm |>\n<| a |>\n<code>", "  let rev = s.split('').reverse().join('')\n\
    \  if (!rev.includes('a')) return s\n  return rev.replace('a', (c => c.toUpperCase()).replace('A',\
    \ (c => c.toLowerCase())));\n}\n</code>\n<|/ a tags=javascript,typescript |>\n\
    <| a |>\n<code>\nconst input = \"ab#c\";\nlet output = \"\";\n\nfor (let i = 0;\
    \ i < input.length; i++) {\n    if (input.charAt(i) == 'a') {\n        output\
    \ += input.toLowerCase() === 'a' ? input.toLowerCase() : input.toUpperCase();\n\
    \    } else {\n        output += input[i];\n    }\n}\n\nconsole.log(output);\n\
    </code>\n<|/ a dscore=3 tags=javascript,typescript |>\n<| c |>\nPlease add some\
    \ explanation to your answer.\n<|/ c |>\n<| a |>\nYou cant do it with a string\
    \ method but you can with charAt\n<code>", "  const map = {};\n  const s = s.replace(/[^a-zA-Z]/g,\
    \ (x) => map[x] = true);\n  if (s.length === 0) {\n    return s;\n  }\n\n  for\
    \ (let i = 0; i < s.length; ++i) {\n    const c = s.charAt(i);\n    if (map[c])\
    \ {\n      s = s.substring(0, i) + s.substring(i + 1);\n      break;\n    }\n\
    \  }\n  return s;\n}\n", "  var result = [];\n  var length = s.length - 1;\n \
    \ \n  for(let i = 0; i < length; i++) {\n    switch(s[i] && s[i]) {\n      case\
    \ 'a':\n        s[i] = 'A';\n        break;\n      case 'A':\n        s[i] = 'a';\n\
    \        break;\n      default:\n        s[i] = s[i] + 'A';\n        break;\n\
    \    }\n  }\n  return s.slice(0, length).split('').join('').split('').join('');\n\
    }\n</code>\n<|/ a tags=javascript |>\n<| a dscore=0 |>\nThis can also be done\
    \ with regex:\n\n<code>", "  // code here\n  var chars = s.split(\"\");\n  chars\
    \ = chars.map(function(char) {\n    if (char.charCodeAt(0) > 96) {\n      return\
    \ char.toUpperCase();\n    } else {\n      return char.toLowerCase();\n    }\n\
    \  });\n  return chars.join(\"\");\n}\n", "  return s.split('').map(letter =>\
    \ {\n    return letter.toLowerCase() === letter ? letter.toUpperCase() : letter;\n\
    \  }).join('');\n}\n", "    return reverse(s);\n}\n", "  for (let i = 0; i < s.length;\
    \ i++) {\n    if (s[i].toLowerCase() !== s[i].toUpperCase()) {\n      return s.split(\"\
    \").map(a => a.toLowerCase()).join(\"\");\n    }\n  }\n  return s;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nIt works well but how do you know it? How does that work? Does\
    \ it only reverse the cases when there's an alphabet on both sides?\n<|/ c |>\n\
    <| c |>\nThe idea is, first we traverse all character in the string, if the character\
    \ is alphabet, we simply reverse the case. If the character is not a alphabet,\
    \ we simply return the string as it is.\n<|/ c |>\n<| c |>\nJust a small question:\
    \ does the return in the `if` statement get executed if there's no alphabet?\n\
    <|/ c |>\n<| c |>\nYes, it will, I have updated my answer, please have a look.\n\
    <|/ c |>\n<| a dscore=4 |>\nHere is a solution using Regex:\n<code>", "  // your\
    \ code here\n  const result = s.split('').map(char => {\n    if (char >= 'a' &&\
    \ char <= 'z') {\n      return char.toUpperCase()\n    }\n    return char.toLowerCase()\n\
    \  }).join('')\n\n  return result ? result : s.replace(/[a-z]+/ig, c => c.toUpperCase())\n\
    }\n", "  let newString = \"\";\n  for (let i = 0; i < s.length; i++){\n    let\
    \ currentLetter = s[i];\n    if (currentLetter >= 'A' && currentLetter <= 'Z'){\n\
    \      currentLetter = currentLetter.toUpperCase();\n    }\n    else if (currentLetter\
    \ >= 'a' && currentLetter <= 'z'){\n      currentLetter = currentLetter.toLowerCase();\n\
    \    }\n    else {\n      currentLetter = currentLetter;\n    }\n    newString\
    \ += currentLetter;\n  }\n  return newString;\n}\n</code>\n<|/ a tags=string,char,javascript,arrays\
    \ |>\n<| a |>\nOne liner:\n<code>", "    let result = \"\";\n\n    for (let i\
    \ = 0; i < s.length; i++) {\n        let charCode = s.charCodeAt(i);\n       \
    \ if (charCode > 96) {\n            result += String.fromCharCode(charCode - 32);\n\
    \        } else {\n            result += s[i];\n        }\n    }\n\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou could try this too:\n<code>",
  "    let newS: string;\n    for (let i = 0; i < s.length; i++) {\n        const\
    \ char: number = s.charCodeAt(i); //gets the ASCII code for the letter\n     \
    \   if (char >= 65 && char <= 90 || char >= 97 && char <= 122) {\n           \
    \ newS = s.slice(0, i) + String.fromCharCode(char + 32) + s.slice(i + 1); //uppercase\
    \ if between a letter and A, lowercase if between a and Z\n        } else {\n\
    \            newS = s; //the string does not contain any letters\n        }\n\
    \    }\n    return newS;\n}\n", "  const result = s.replace(/[^a-zA-Z]/g, s =>\
    \ \n    /[a-z]/i.test(s) ? s.toLowerCase() : s.toUpperCase());\n  return result.length\
    \ === 0 ? s.split('').reverse().join('') : result;\n}\n", "    return s.split('').map(letter\
    \ => letter.toLowerCase() === letter ? letter.toUpperCase() : letter).join('');\n\
    }\n</code>\n<|/ a dscore=0 tags=algorithm,string,javascript |>\n<| c |>\nThis\
    \ answer should mention that this solution only works for lower cased letters\
    \ because of the `toLowerCase`.\n<|/ c |>\n<| a dscore=0 |>\nA solution in Java:\n\
    <code>\nString convert(String s) {\n    StringBuilder sb = new StringBuilder();\n\
    \    boolean prevUpper = false;\n    for (char c : s.toCharArray()) {\n      \
    \  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n         \
    \   sb = new StringBuilder(c);\n        } else if (prevUpper && Character.isUpperCase(c))\
    \ {\n            sb.setCharAt(sb.length() - 1, Character.toLowerCase(sb.charAt(sb.length()\
    \ - 1)));\n        } else {\n            prevUpper = Character.isUpperCase(c);\n\
    \        }\n        sb.append(c);\n    }\n    return sb.toString();\n}\n</code>\n\
    <|/ a tags=algorithm,string,javascript |>\n<| a |>\nI have also used the below\
    \ code:\n<code>\nconst string = 'apple';\nlet newString = '';\nfor (let i = 0;\
    \ i < string.length; i++) {\n if (string[i] === 'a' || string[i] === 'e' || string[i]\
    \ === 'i' || string[i] === 'o' || string[i] === 'u') {\n  newString += string[i]\n\
    \ } else if (newString !== '') {\n  newString += string[i].toLowerCase()\n } else\
    \ {\n  newString += string[i].toLowerCase()\n }\n}\nconsole.log(newString)\n</code>\n\
    <|/ a tags=algorithm,string,javascript dscore=0 |>\n<| a tags=algorithm,string,javascript\
    \ |>\n<code>", "  let reversedString = s.split(\"\").reverse().join(\"\");\n \
    \ if (reversedString.length === 0) {\n    return reversedString;\n  }\n\n  if\
    \ (s.split(\"\").some(letter => letter === reversedString.charAt(0))) {\n    return\
    \ s.split(\"\").map(letter => letter === reversedString.charAt(0) ? letter : letter.toUpperCase()).join(\"\
    \");\n  }\n  return reversedString;\n}\n\nexport { solve };\n</code>\n<|/ a tags=arrays,recursion,javascript,string\
    \ dscore=1 |>\n<| c |>\nThanks for the reply. I tested your code, it works fine\
    \ for \"1234\". But fails for \"#a@c\", it should return \"#A@c\", but it returns\
    \ \"#A@c\".\n<|/ c |>\n<| a tags=arrays,recursion,javascript,string |>\nTry this\n\
    <code>", "    let low = s.toLowerCase()\n    let up = low\n    for(let i = 0;\
    \ i < low.length; i++) {\n        let letter = low[i]\n        if(letter == letter.toLowerCase())\
    \ {\n            low = low.replace(letter, letter.toUpperCase())\n        } else\
    \ if(letter == letter.toUpperCase()) {\n            low = low.replace(letter,\
    \ letter.toLowerCase())\n        }\n    }\n    return up\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=string,javascript dscore=0 |>\nHere is a solution that checks\
    \ for valid input and can handle capital letters and symbols.\n\n<code>", "  \
    \  let result = \"\";\n    for (let i = 0; i < s.length; i++) {\n        if (s.charAt(i)\
    \ === \"@\" || s.charAt(i) === \"#\") {\n            result += s.charAt(i);\n\
    \        } else {\n            result += s.toUpperCase();\n        }\n    }\n\
    \    return result;\n}", "  const s = s\n    .split('')\n    .map(c => {\n   \
    \   const isLetter = /^[a-zA-Z]+$/.test(c)\n      if (isLetter) {\n        return\
    \ c.toUpperCase()\n      }\n      return c\n    })\n    .join('')\n  return s\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
