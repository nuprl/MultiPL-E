name: HumanEval_26_remove_duplicates
language: ts
prompt: "//From an array of integers, remove all elements that occur more than once.\n\
  // Keep order of elements left the same as in the input.\n// >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n// [1, 3, 4]\nfunction remove_duplicates(numbers: number[]): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = remove_duplicates;\n  assert.deepEqual(candidate([]),[]);\n\
  \  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, 2, 4, 3, 5]),[1, 4, 5]);\n}\n\ntest();"
completions: ["    const count = numbers.length;\n    const set = new Set<number>();\n\
    \    for (let i = 0; i < count; i++) {\n        const num = numbers[i];\n    \
    \    if (set.has(num)) {\n            numbers.splice(i, 1);\n        } else {\n\
    \            set.add(num);\n        }\n    }\n    return numbers;\n}\n", "  const\
    \ map: Map<number, number> = new Map();\n  for (let number of numbers) {\n   \
    \ if (map.has(number)) {\n      map.set(number, map.get(number) + 1);\n    } else\
    \ {\n      map.set(number, 1);\n    }\n  }\n  const numbers_unique: number[] =\
    \ [];\n  for (let [number, count] of map.entries()) {\n    if (count === 1) {\n\
    \      numbers_unique.push(number);\n    }\n  }\n  return numbers_unique;\n}\n",
  "\tconst unique: number[] = [];\n\tfor (let i = 0; i < numbers.length; i++) {\n\t\
    \tif (unique.indexOf(numbers[i]) === -1) {\n\t\t\tunique.push(numbers[i]);\n\t\
    \t}\n\t}\n\treturn unique;\n}\n", "\tconst sorted_numbers = numbers.slice().sort();\n\
    \tlet result: number[] = [];\n\tfor (let i = 0; i < sorted_numbers.length; i +=\
    \ 1) {\n\t\tconst number = sorted_numbers[i];\n\t\tif (sorted_numbers.indexOf(number)\
    \ === i) {\n\t\t\tresult.push(number);\n\t\t}\n\t}\n\treturn result;\n}\n", " \
    \   return numbers.filter(function(elem, index, self) {\n        return self.indexOf(elem)\
    \ === index;\n    });\n}\n", "\tconst unique: number[] = [];\n\tlet uniqueCount\
    \ = 0;\n\tlet last: number = 0;\n\tfor (const number of numbers) {\n\t\tif (last\
    \ === number && uniqueCount === 0) {\n\t\t\tunique.push(number);\n\t\t} else {\n\
    \t\t\tlast = number;\n\t\t\tuniqueCount++;\n\t\t}\n\t}\n\treturn unique;\n}\n",
  "    const map = new Map();\n    for (const n of numbers) {\n        if (map.get(n))\
    \ {\n            map.set(n, map.get(n) + 1);\n        } else {\n            map.set(n,\
    \ 1);\n        }\n    }\n    const result: number[] = [];\n    for (const [n]\
    \ of map.entries()) {\n        if (map.get(n) > 1) {\n            result.push(n);\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=duplicate-removal,javascript,arrays\
    \ dscore=2 |>\n<| c |>\nThis code doesn't remove all duplicates. For example,\
    \ `[1,1,2,2,3,3]` gets `[1,2,3]` instead of `[1,2,2,3]`. The question specifically\
    \ asked about removing duplicates.\n<|/ c |>\n<| c |>\nThe question specifically\
    \ asked about removing duplicates.\n<|/ c |>\n<| a dscore=1 tags=duplicate-removal,javascript,arrays\
    \ |>\nThis works with ES6 only:\n<code>\n let arr = [1, 2, 3, 3, 5, 6, 5, 7, 9];\n\
    \n let unique = [...new Set(arr)];\n</code>\n<|/ a |>\n<| a dscore=1 |>\nIf you\
    \ have lodash in your project, this solution will work.\n<code>\nimport _ from\
    \ 'lodash'\n\nconst array = [1, 2, 3, 3, 5, 6, 5, 7, 9];\nconst uniqueArray =\
    \ _.uniq(array);\n", "  const output = new Array(numbers.length);\n  for (let\
    \ i = 0; i < numbers.length; i++) {\n    if (numbers.indexOf(numbers[i]) > i)\
    \ {\n      output[i] = numbers[i];\n    }\n  }\n  return output;\n}\n", "  const\
    \ unique: number[] = [];\n\n  for (let i = 0; i < numbers.length; ++i) {\n   \
    \ if (unique.indexOf(numbers[i]) == -1) {\n      unique.push(numbers[i]);\n  \
    \  }\n  }\n\n  return unique;\n}\n", "\tconst result = [];\n\tlet nums = new Set<number>();\n\
    \tfor (const num of numbers) {\n\t\tif (nums.has(num)) {\n\t\t\tcontinue;\n\t\t\
    }\n\t\tresult.push(num);\n\t\tnums.add(num);\n\t}\n\treturn result;\n}\n", " \
    \   let map = new Map<number, number>();\n\n    for (let i = 0; i < numbers.length;\
    \ i++) {\n        let number = numbers[i];\n        if (map.has(number)) {\n \
    \           map.set(number, map.get(number) + 1);\n        } else {\n        \
    \    map.set(number, 1);\n        }\n    }\n    let new_array = new Array<number>();\n\
    \    for (let i = 0; i < numbers.length; i++) {\n        let number = numbers[i];\n\
    \        if (!map.has(number)) {\n            new_array.push(number);\n      \
    \  }\n    }\n    return new_array;\n}\n", "    const hash: any = {};\n    const\
    \ result: number[] = [];\n\n    for (let i = 0, length = numbers.length; i < length;\
    \ i++) {\n        const value = numbers[i];\n\n        if (hash[value]) {\n  \
    \          // This value has already been encountered before so push it on to\
    \ the result\n            // and skip any subsequent duplicate values.\n     \
    \       hash[value].forEach(function (dupeValue) {\n                result.push(dupeValue);\n\
    \            });\n            continue;\n        }\n\n        hash[value] = result.push(value);\n\
    \    }\n\n    return result;\n}\n", "\tvar i, j, temp, hash = {};\n\tfor (i =\
    \ 0; i < numbers.length; i++) {\n\t\tif (!hash[numbers[i]]) {\n\t\t\thash[numbers[i]]\
    \ = true;\n\t\t\ttemp = numbers[i];\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\
    if (numbers[j] !== temp) {\n\t\t\t\t\thash[numbers[j]] = true;\n\t\t\t\t}\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn (<any>Object).keys(hash);\n}\n", "    const seen: number[]\
    \ = [];\n    const results: number[] = [];\n    for (const num of numbers) {\n\
    \        if (seen.indexOf(num) === -1) {\n            seen.push(num);\n      \
    \      results.push(num);\n        }\n    }\n    return results;\n}\n</code>\n\
    <|/ a |>\n<| a tags=typescript,arrays,javascript |>\nYou can use a Set to get\
    \ unique values, filter by array's length property.\n\n<code>\nconst arr = [1,\
    \ 2, 3, 4, 3, 1, 1, 4, 1, 2]\nconst res = Array.from(new Set(arr))\nconsole.log(res)</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=2 tags=typescript,arrays,javascript |>\nYou can\
    \ do so by converting your array into set. Set will only keep unique values.\n\
    \n<code>\nconst numbers = [1, 2, 3, 1, 2, 4, 2, 3, 1];\nconst uniqueNums = [...new\
    \ Set(numbers)];\nconsole.log(uniqueNums);</code>\n<|/ a |>\n<| c |>\n`Set` only\
    \ keeps the first occurrence of each element. It doesn't keep all occurrences.\
    \ And it might make your code slower, since it needs to create another array first.\n\
    <|/ c |>\n<| c |>\nYep. So this was the first thing I tried, but I get the following\
    \ error:\n\n``` TS2339: Property 'set' does not exist on type 'number[]'```\n\
    <|/ c |>\n<| c |>\nYes. `Set` only keeps the first occurrence of each element.\
    \ It doesn't keep all occurrences. And it might make your code slower, since it\
    \ needs to create another array first.\n<|/ c |>\n<| c |>\nIf speed is your concern,\
    \ I'd suggest using an object rather than an array. It'll run faster than using\
    \ `Set`\n<|/ c |>\n<| c |>\n- Yes. That'll be better\n<|/ c |>\n<| a tags=typescript,arrays,javascript\
    \ dscore=1 |>\n<code>\nconst numbers = [1, 2, 3, 1, 2, 4, 2, 3, 1];\nconst uniqueNums\
    \ = new Set(numbers);\nconst numsUnique = Array.from(uniqueNums);\n</code>\n<|/\
    \ a |>\n<| a dscore=1 tags=typescript,arrays,javascript |>\nAn answer from https://stackoverflow.com/a/59303375/6207220\n\
    \n<code>\nvar unique = [1, 1, 2, 2, 3, 3, 4, 4, 4];\nvar unique2 = Array.from(new\
    \ Set(unique));\nconsole.log(unique2);</code>\n<|/ a |>\n<| c |>\n`Set` only keeps\
    \ the first occurrence of each element. It doesn't keep all occurrences. And it\
    \ might make your code slower, since it needs to create another array first.",
  "    // Clone input array\n    const sorted_numbers = numbers.slice().sort();\n\
    \    const unique_numbers = sorted_numbers.filter((elem, pos, arr) => {\n    \
    \    return arr.indexOf(elem) === pos;\n    });\n    return sorted_numbers.map(number\
    \ => number == unique_numbers[0] ? unique_numbers[0] : number);\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| a tags=typescript,types,arrays,javascript |>\nThe simplest\
    \ solution that I can think of is:\n\n<code>\nconst arr = [1, 2, 3, 2, 4, 1, 4];\n\
    const newArr = arr.reduce((acc, current) => {\n    acc[current] = (acc[current]\
    \ || 0) + 1;\n    return acc;\n}, {});\n\nconst res = Array.from(newArr)\n   \
    \            .filter(([key, value]) => value < 2)\n               .map(([key,\
    \ value]) => key);\n\nconsole.log(res);</code>\n\nIt's very similar to's solution,\
    \ but uses reduce in place of reduce and then filter before map.\n<|/ a dscore=4\
    \ |>\n<| a tags=typescript,types,arrays,javascript |>\nUsing lodash\n<code>\n\
    _.chain(data)\n    .countBy()\n    .omitBy(r => _.isUndefined(r))\n    .keys()\n\
    \    .filter(_.gt(1, _.toNumber(r)))\n    .value()\n</code>\n<|/ a dscore=4 |>\n\
    <| a |>\nLodash is very helpful for such tasks. In case someone wants to remove\
    \ all duplicates from a list using Lodash:\n<code>\nconst uniq = _.uniq(array);\n\
    </code>\n<|/ a tags=typescript,types,arrays,javascript dscore=3 |>\n<| a dscore=3\
    \ |>\n<code>\nconst arr = [1, 2, 3, 2, 4, 1, 4];\n\nconst result = arr.reduce((acc,\
    \ item) => {\n  if(!acc[item]) {\n    acc[item] = 1;\n  } else {\n    acc[item]++;\n\
    \  }\n\n  return acc;\n}, {});\n\nconst res = Object.keys(result)\n          \
    \   .filter(item => result[item] > 1)\n             .map(item => result[item]);\n\
    </code>\n<|/ a tags=typescript,types,arrays,javascript |>\n<| a dscore=3 tags=typescript,types,arrays,javascript\
    \ |>\nThis is a great use case for the reduce function. \n<code>\nconst arr =\
    \ [1, 2, 3, 2, 4, 1, 4];\nconst newArray = arr.reduce((acc, item) => {\n  if (acc[item])\
    \ {\n    acc[item]++;\n  } else {\n    acc[item] = 1;\n  }\n  return acc;\n},\
    \ {});\n\nconst uniqueItem", "  const indexMap = new Map<number, number[]>();\n\
    \n  for (const [index, number] of numbers.entries()) {\n    indexMap.set(number,\
    \ indexMap.has(number)\n      ? indexMap.get(number)\n      : indexMap.set(number,\
    \ [number]));\n  }\n\n  return Array.from(indexMap.values())\n    .sort((a, b)\
    \ => b[1] - a[1])\n    .map(([number]) => (number));\n}\n", "    const hashmap\
    \ = new Map();\n    for (const num of numbers) {\n        if (hashmap.has(num))\
    \ {\n            hashmap.set(num, hashmap.get(num) + 1);\n        } else {\n \
    \           hashmap.set(num, 1);\n        }\n    }\n    const output: number[]\
    \ = [];\n    for (const key of hashmap.keys()) {\n        if (hashmap.get(key)\
    \ === 1) {\n            output.push(key);\n        }\n    }\n    return output;\n\
    }\n", "    return _(numbers)\n        .uniq()\n        .compact()\n        .value();\n\
    }\n", "    const counts: { [key: number]: number } = {};\n    for (const num of\
    \ numbers) {\n        counts[num] = counts[num] || 0;\n        counts[num]++;\n\
    \    }\n    const uniques: number[] = [];\n    const keys = Object.keys(counts);\n\
    \    for (const key of keys) {\n        if (counts[key] === 1) {\n           \
    \ uniques.push(key);\n        }\n    }\n    return uniques;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nPlease include a description of your answer, don't just post code.\n\
    <|/ c |>\n<| c |>\nI've done that for you.\n<|/ c |>\n<| a dscore=1 |>\nYou can\
    \ use a Map to keep track of all the unique numbers and count how many times each\
    \ one appears in the array:\n\n<code>\nconst input = [1, 2, 3, 2, 4];\nconst uniqueCounts\
    \ = new Map();\nfor (let item of input) {\n  const count = uniqueCounts.get(item)\
    \ || 0;\n  uniqueCounts.set(item, count + 1);\n}\nconst uniqueArray = [...uniqueCounts.keys()].sort((a,\
    \ b) => a - b);\nconsole.log(uniqueArray);</code>\n\nNote: This code relies on\
    \ the order of the array not changing during this operation. If it's important\
    \ that the order be preserved, then you need to loop through the array once and\
    \ increment the count for each unique number as you go. That way the map can retain\
    \ the original order.\n<|/ a tags=arrays,javascript,typescript |>\n<| a dscore=1\
    \ |>\nYou can use reduce\n\n<code>\nconst input = [1, 2, 3, 2, 4]\n\nconst unique\
    \ = input.reduce((acc, curr) => {\n  if(!acc[curr]) acc[curr] = 1\n  else acc[curr]\
    \ += 1\n  return acc\n}, {})\n\nconst result = Object.entries(unique).map(([key,\
    \ val])=>{return val})\nconsole.log(result)</code>\n<|/ a tags=arrays,javascript,typescript\
    \ |>\n<| a tags=arrays,javascript,typescript |>\nA new Set is what you are looking\
    \ for.\n<code>\nlet input = [1, 2, 3, 2, 4]\nlet output = [...new Set(input)];\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis solution also doesn't preserve the order\
    \ of the original array\n<|/ c |>\n<| a tags=arrays,javascript,typescript |>\n\
    I solved it with a different approach - \n<code>\nvar uniqueArray = [];\n\nfor\
    \ (var i =0; i < myArray.length; i++) {\n  if (uniqueArray.indexOf(myArray[i])\
    \ === -1) {\n    uniqueArray.push(myArray[i]);\n  }\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n", "  let result: number[] = [], seen: number[] = [];\n\
    \  numbers.forEach((number) => {\n    if (seen.indexOf(number) === -1) {\n   \
    \   result.push(number);\n      seen.push(number);\n    }\n  });\n  return result;\n\
    }\n", "  let hashSet = new Set<number>();\n  let newArray = numbers.filter((num)\
    \ => {\n    if (hashSet.has(num)) {\n      return false;\n    } else {\n     \
    \ hashSet.add(num);\n      return true;\n    }\n  });\n  return newArray;\n}\n\
    </code>\n<|/ a tags=algorithm,javascript |>\n<| a |>\nTo remove all duplicates\
    \ from an array in Javascript, the best way is to use Array#filter:\n<code>",
  "  return numbers.filter((value, index, arr) => arr.indexOf(value) === index)\n\
    }\n", "  let hash: number[] = [];\n  for (let num of numbers) {\n    if (!hash.includes(num))\
    \ {\n      hash.push(num);\n    }\n  }\n  return hash;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nWhat if I want the output to be the original array unchanged? Can this\
    \ be done? Thanks\n<|/ c |>\n<| c |>\nJust use `return numbers` instead of `return\
    \ hash` in the final return statement. `hash` doesn't contain duplicate numbers\
    \ anyway, but that doesn't mean that `numbers` doesn't contain the duplicates.\n\
    <|/ c |>\n<| c |>\nThe reason I wrote the code like this is because I am looking\
    \ to learn more about this topic, since I am going to be doing this for a few\
    \ other problems. So can the code be edited to achieve what I am trying to do?\n\
    <|/ c |>\n<| c |>\nI'm sure it could, but that's not how you learn algorithms,\
    \ and is also a lot of extra work for someone who doesn't know what they're doing,\
    \ so I'm not sure what you're looking for.\n<|/ c |>\n<| c |>\nIt was just a question\
    \ out of my own interest to know more about this topic, so I thought it would\
    \ be helpful for me to know the code. I'm not asking you to write my code for\
    \ me, it's just to understand what the code does.\n<|/ c |>\n<| a tags=javascript\
    \ |>\n<code>\nconst removeDuplicates = (input) => {\n  let map = {};\n  input.forEach(i\
    \ => {\n    if(map[i]) {\n      map[i] ++;\n    } else {\n      map[i] = 1;\n\
    \    }\n  });\n  return Object.keys(map).map(i => map[i]);\n};\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=javascript |>\n<code>", "    const result: number[] =\
    \ [];\n    for (let i = 0; i < numbers.length; i++) {\n        const element =\
    \ numbers[i];\n        if (result.indexOf(element) === -1) {\n            result.push(element);\n\
    \        }\n    }\n    return result;\n}\n", "  const unique = new Set(numbers);\n\
    \  return Array.from(unique);\n}\n</code>\n<|/ a tags=javascript,algorithm,math,arrays\
    \ |>\n<| c |>\nIt would be better to use a `Set` here instead of a `Map`.\n<|/\
    \ c |>\n<| c |>\nYes, it would be better than `Map`. But OP didn't asked about\
    \ `Set`, so he can use whatever he needs. I tried to make it as similar to OP's\
    \ code as possible.\n<|/ c |>\n<| c |>\nIf he doesn't need the order to be preserved,\
    \ he should definitely use a `Set`, especially since `Map` has `O(n)` insertions\
    \ and `O(n)` lookups when iterating over it.\n<|/ c |>\n<| c |>\nI agree with\
    \ you on the `Map` part that OP should use Set instead of Map. I was just pointing\
    \ out that this example is almost exactly what a `Set` is designed to do.\n<|/\
    \ c |>\n<| c |>\nThanks for the solution. I didn't know Set would work like that.\
    \ I appreciate it a lot. Your solution works great\n<|/ c |>\n<| a tags=javascript,algorithm,math,arrays\
    \ dscore=2 |>\nThis is in Java\n<code>\n    int[] numbers = { 1, 2, 3, 2, 4 };\n\
    \    Map<Integer, Integer> map = new HashMap<>();\n    Arrays.sort(numbers);\n\
    \n    for (int i = 0; i < numbers.length; i++) {\n        if (map.containsKey(numbers[i]))\
    \ {\n            map.put(numbers[i], map.get(numbers[i]) + 1);\n        } else\
    \ {\n            map.put(numbers[i], 1);\n        }\n    }\n\n    ArrayList<Integer>\
    \ newNumbers = new ArrayList<>();\n    for (Map.Entry<Integer, Integer> entry\
    \ : map.entrySet()) {\n        if (entry.getValue() > 1) {\n            newNumbers.add(entry.getKey());\n\
    \        }\n    }\n</code>\n<|/ a |>\n<| c |>\nThis does not produce the result\
    \ specified in the question. It just removes duplicates *after* sorting, which\
    \ is not what the question asks for.\n<|/ c |>\n<| a |>\nMy solution\n<code>\n\
    const removeDuplicates = (arr) => {\n    let lastNumber = null;\n    let result\
    \ = new Set();\n    arr.forEach((num) => {\n        if (num === lastNumber) {\n\
    \            result.add(num);\n        } else {\n            lastNumber = num;\n\
    \        }\n    });\n    return [...result];\n}\n</code>\n<|/ a dscore=2 tags=javascript,algorithm,math,arrays\
    \ |>\n<| a dscore=2 |>\n<code>\nvar arr = [1, 3, 2, 3, 2, 4, 1, 3, 2, 4, 2, ",
  "  const sorted_numbers = numbers.slice().sort((a, b) => a - b);\n\n  const last_index\
    \ = sorted_numbers[sorted_numbers.length - 1];\n  const new_array: number[] =\
    \ [];\n\n  for (let i = 0; i < sorted_numbers.length; i += 1) {\n    if (sorted_numbers[i]\
    \ !== last_index + 1) {\n      new_array.push(sorted_numbers[i]);\n    }\n  }\n\
    \n  return new_array;\n}\n", "  const map = {};\n\n  numbers.forEach(n => {\n\
    \    if (!(n in map)) {\n      map[n] = true;\n    }\n  });\n\n  return Object.keys(map).map(n\
    \ => +n);\n}\n", "  const counts = new Map<number, number>();\n  let i = 0;\n\
    \  let j = 1;\n  while (j < numbers.length) {\n    const value = numbers[j];\n\
    \    if (counts.has(value)) {\n      counts.set(value, counts.get(value) + 1);\n\
    \    } else {\n      counts.set(value, 1);\n    }\n    i++;\n    j++;\n  }\n \
    \ return numbers.filter(x => counts.get(x) === 1);\n}\n", "\tlet num_to_remove:\
    \ number[] = [];\n\tfor (let i = 0; i < numbers.length; i++) {\n\t\tlet index\
    \ = num_to_remove.indexOf(numbers[i]);\n\t\tif (index === -1) {\n\t\t\tnum_to_remove.push(numbers[i]);\n\
    \t\t}\n\t}\n\treturn num_to_remove.filter((x, i, ar) => ar.indexOf(x) === i);\n\
    }\n", "  const set = new Set();\n  numbers.forEach(n => set.add(n));\n  return\
    \ Array.from(set);\n}\n", "    const result = [];\n    let previous = numbers[0];\n\
    \    for (let i = 1; i < numbers.length; ++i) {\n        const current = numbers[i];\n\
    \        if (current !== previous) {\n            result.push(current);\n    \
    \        previous = current;\n        }\n    }\n    return result;\n}\n", "\t\
    const map: Map<number, boolean> = new Map();\n\tfor (let num of numbers) {\n\t\
    \tif (map.has(num)) {\n\t\t\tmap.set(num, map.get(num) + 1);\n\t\t} else {\n\t\
    \t\tmap.set(num, 1);\n\t\t}\n\t}\n\tconst filtered: number[] = [];\n\tfor (let\
    \ [num, count] of map.entries()) {\n\t\tif (count > 1) {\n\t\t\tfiltered.push(num);\n\
    \t\t}\n\t}\n\treturn filtered;\n}\n", "    const output = [];\n    let seen: number[]\
    \ = [];\n    for (const num of numbers) {\n        if (seen.indexOf(num) === -1)\
    \ {\n            seen.push(num);\n            output.push(num);\n        }\n \
    \   }\n    return output;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is actually the\
    \ best answer here.\n<|/ c |>\n<| c |>\nThis is a great solution if you are looking\
    \ for an answer in JavaScript. I'm looking for a solution in Typescript. Also,\
    \ if you are looking to get a single number from the array that contains the highest\
    \ value you can use this solution. Just make sure to convert your input array\
    \ to a type that supports maximum value.\n<|/ c |>\n<| c |>\nJust a note of caution\
    \ to this solution: It will only work if your array has elements that will be\
    \ compared with each other. I.e. [2,3,4] will not work, but [2,3,4] will. Also,\
    \ if you have a very large array, you may hit the max stack size limit.\n<|/ c\
    \ |>\n<| a dscore=5 tags=javascript |>\n<code>\nvar a = [1,2,3,4,5,6,6,2,4,7];\n\
    var c = a.filter(function(value, index, arr) {\n    return arr.indexOf(value)\
    \ === index;\n});\nconsole.log(c);</code>\n<|/ a |>\n<| c |>\nThis is a nice solution\
    \ if you want the unique values only.\n<|/ c |>\n<| c |>\nWhat is arr.indexOf(value)\
    \ === index doing exactly ?\n<|/ c |>\n<| c |>\nindexOf returns the index of the\
    \ first occurrence of the element in the array. Since we are using filter, the\
    \ first occurrence is filtered out and the value is returned.\n<|/ c |>\n<| c\
    \ |>\nIt is not the fastest solution\n<|/ c |>\n<| a |>\nMy solution using an\
    \ index (the 2nd argument) of an element of the array as the value for comparison\
    \ with all the others:\n\n<code>\nlet a = [1,2,3,4,5,6,6,2,4,7];\n\nlet c = a.filter(function(value,\
    \ index, arr) {\n    return index == arr.indexOf(value);\n});\n\nconsole.log(c);</code>\n\
    <|/ a tags=javascript dscore=5 |>\n<| c |>\nNice, I did not think of that. However\
    \ it won't work if the item you are looking for is the first one.\n<|/ c |>\n\
    <| c |>\nThis works for me when the item to find is the first item. Thank you!\n\
    <|/ c |>\n<| c |>\nthis solution doesn't work when the first item to find is the\
    \ one in the array\n<|/ c |>\n<| c |>\nWorks fine when first item is first\n<|/\
    \ c ", "    return unique_with_counts(numbers.map((v, i) => [v]));\n}", "  const\
    \ len = numbers.length;\n  if (len < 1) return numbers;\n  const ret: number[]\
    \ = [];\n  const seen = new Set<number>();\n  for (let i = 0; i < len; i++) {\n\
    \    if (seen.has(numbers[i])) {\n      continue;\n    }\n    seen.add(numbers[i]);\n\
    \    ret.push(numbers[i]);\n  }\n  return ret;\n}\n", "  const unique_numbers\
    \ = numbers.filter((value, index) => numbers.indexOf(value) === index);\n  return\
    \ unique_numbers;\n}\n", "\tlet result: number[] = []\n\tlet seen: number[] =\
    \ []\n\tnumbers.forEach(function(num) {\n\t\tif (!seen.includes(num)) {\n\t\t\t\
    seen.push(num)\n\t\t\tresult.push(num)\n\t\t}\n\t})\n\treturn result\n}\n", " \
    \ const newArray: number[] = [];\n  numbers.forEach((value) => {\n    if (newArray.indexOf(value)\
    \ === -1) {\n      newArray.push(value);\n    }\n  });\n  return newArray;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis is a great solution - one improvement\
    \ might be to use `Set` instead of `Array`\n<|/ c |>\n<| c |>\nThanks for your\
    \ suggestions. I just updated my answer. `Array` should work but `Set` is more\
    \ elegant.\n<|/ c |>\n<| a tags=javascript,arrays,duplicate-removal |>\nYou can\
    \ use Array.prototype.reduce method to get unique elements and Array.prototype.indexOf()\
    \ method to check if element is already in array or not : \n<code>\nconst arr\
    \ = [2, 3, 2, 3, 4];\nlet result = arr.reduce((acc, cur) => {\n    if (acc.indexOf(cur)\
    \ < 0) {\n        acc.push(cur);\n    }\n    return acc;\n}, []);\n</code>\nYou\
    \ can easily find more about Array.prototype.reduce() on Mozilla Developer Network.\n\
    <|/ a dscore=1 |>\n<| a dscore=1 tags=javascript,arrays,duplicate-removal |>\n\
    <code>\nconst unique = (arr) => {\n  return [...new Set(arr)];\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nWhile this code may answer the question, providing additional\
    \ context regarding why and/or how this code answers the question improves its\
    \ long-term value.\n<|/ c |>\n<| c |>\nIt's not an answer. It's a comment. Answers\
    \ are supposed to be answers, not comments.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    const arr = [2, 3, 2, 3, 4];\nlet newArr = [];\narr.forEach((value) => {\n  if\
    \ (newArr.indexOf(value) === -1) {\n    newArr.push(value);\n  }\n});\nconsole.log(newArr);</code>\n\
    <|/ a tags=javascript,arrays,duplicate-removal |>\n<| a |>\nYou can use Set and\
    \ Array.prototype.forEach.\n\n<code>\nlet arr = [2,3,5,6,3];\nlet arrSet = new\
    \ Set(arr);\narr.forEach((item) => {\n  if (arrSet.has(item)) {\n    console.log('Array\
    \ has duplicate')\n  } else {\n    arrSet.add(item);\n  }\n});</code>\n<|/ a dscore=1\
    \ tags=javascript,arrays,duplicate-removal |>\n<| a dscore=1 |>\nYou could reduce\
    \ the array by checking, if the item is contained or not.\n\n<code>\nconst\n \
    \   removeDuplicates = (array) => {\n        let newArray", "    const seen: Set<number>\
    \ = new Set<number>();\n\n    return numbers.filter((number) => !seen.has(number)\
    \ && seen.add(number));\n}\n", "  const result: number[] = [];\n  const seen:\
    \ Set<number> = new Set();\n\n  for (let i = 0; i < numbers.length; i++) {\n \
    \   if (seen.has(numbers[i])) {\n      continue;\n    }\n    result.push(numbers[i]);\n\
    \    seen.add(numbers[i]);\n  }\n\n  return result;\n}\n", "    const sorted =\
    \ numbers.sort((a, b) => a - b);\n    const result = [];\n    const seen: Map<number,\
    \ boolean> = new Map();\n    for (let i = 0; i < sorted.length; i++) {\n     \
    \   if (seen.has(sorted[i])) {\n            continue;\n        }\n        result.push(sorted[i]);\n\
    \        seen.set(sorted[i], true);\n    }\n    return result;\n}\n", "  const\
    \ result: number[] = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const\
    \ number = numbers[i];\n    if (result.indexOf(number) === -1) result.push(number);\n\
    \  }\n  return result;\n}\n", "    let set = new Set<number>();\n    for (let\
    \ i = 0; i < numbers.length; i++) {\n        if (set.has(numbers[i])) {\n    \
    \        set.delete(numbers[i]);\n        } else {\n            set.add(numbers[i]);\n\
    \        }\n    }\n    return [...set];\n}\n", "\tconst output = [];\n\tfor (let\
    \ i = 0; i < numbers.length; i++) {\n\t\tconst num = numbers[i];\n\t\tif (!output.includes(num))\
    \ {\n\t\t\toutput.push(num);\n\t\t}\n\t}\n\treturn output;\n}\n", "    const hashmap\
    \ = new Map<number, number>();\n    for (const num of numbers) {\n        if (hashmap.has(num))\
    \ {\n            continue;\n        }\n        hashmap.set(num, num);\n    }\n\
    \    return Array.from(hashmap.values());\n}\n", "    return numbers.filter((_,\
    \ index) => numbers.indexOf(index) === index)\n}\n", "  let counts = new Map<number,\
    \ number>();\n  for (let n of numbers) {\n    let count = counts.get(n) || 0;\n\
    \    counts[n] = ++count;\n  }\n\n  let result = new Array<number>();\n  for (let\
    \ n of numbers) {\n    if (counts.has(n)) continue;\n    result.push(n);\n  }\n\
    \  return result;\n}\n", "\tconst counts: number[] = [];\n\tlet unique: number[]\
    \ = [];\n\n\tfor (const number of numbers) {\n\t\tcounts[number] = counts[number]\
    \ || 0;\n\n\t\tif (counts[number] === 1) {\n\t\t\tunique.push(number);\n\t\t}\n\
    \t}\n\n\treturn unique;\n}\n", "    const result: number[] = [];\n\n    for (let\
    \ i = 0; i < numbers.length; i++) {\n        if (result.indexOf(numbers[i]) ===\
    \ -1) {\n            result.push(numbers[i]);\n        }\n    }\n\n    return\
    \ result;\n}\n", "  const uniques: number[] = [];\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    const num = numbers[i];\n    if (uniques.indexOf(num) === -1) {\n\
    \      uniques.push(num);\n    }\n  }\n  return uniques;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nThis solution is just for those who don't need it anymore.\n<code>",
  "  const output: number[] = new Array(numbers.length);\n  const map: number[] =\
    \ new Array(numbers.length);\n  let index = 0;\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    if (map[i] == undefined) {\n      output[index] = numbers[i];\n\
    \      map[i] = 1;\n    } else {\n      map[i]++;\n    }\n  }\n  return output;\n\
    }\n", "    let output = [];\n    for (let i = 0; i < numbers.length; i++) {\n\
    \        let index = output.findIndex((e) => e == numbers[i]);\n        if (index\
    \ !== -1) output.splice(index, 1);\n        else output.push(numbers[i]);\n  \
    \  }\n    return output;\n}\n", "  const seen: number[] = [];\n  const uniqueNumbers:\
    \ number[] = [];\n\n  for (let num of numbers) {\n    if (seen.indexOf(num) >=\
    \ 0) {\n      continue;\n    }\n    seen.push(num);\n    uniqueNumbers.push(num);\n\
    \  }\n\n  return uniqueNumbers;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nIn a\
    \ more efficient way, you can store the array in a hash and whenever you encounter\
    \ a duplicate you just add the value to the list of values. I realized that this\
    \ is what your question asking for.\nIn your case:\n<code>\nconst hash = {};\n\
    const arr = [1, 3, 2, 2, 3, 2];\narr.forEach(a => {\n    if (hash[a]) hash[a].push(a);\n\
    \    else hash[a] = [a];\n});\n", "  const uniques: number[] = [];\n  const output:\
    \ number[] = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers.indexOf(numbers[i])\
    \ === i) continue;\n    uniques.push(numbers[i]);\n  }\n  for (let i = 0; i <\
    \ uniques.length; i++) {\n    output.push(uniques[i]);\n  }\n  return output;\n\
    }\n", "  const output = new Array<number>();\n\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    const currentNumber = numbers[i];\n\n    if (!output.includes(currentNumber))\
    \ {\n      output.push(currentNumber);\n    }\n  }\n\n  return output;\n}\n",
  "    const newArray = [];\n    const tempMap = new Map<number, number>();\n    numbers.forEach(number\
    \ => tempMap.set(number, tempMap.get(number) + 1));\n    numbers = Array.from(tempMap);\n\
    \    numbers.forEach(number => {\n        if (newArray.includes(number)) {\n \
    \           newArray = newArray.filter(n => n != number);\n        } else {\n\
    \            newArray.push(number);\n        }\n    });\n    return newArray;\n\
    }", "  const output: number[] = [];\n  const seen: Map<number, number> = new Map();\n\
    \n  for (const num of numbers) {\n    if (seen.has(num)) {\n      // num was seen\
    \ already, so we remove it from the list of duplicates.\n      continue;\n   \
    \ }\n\n    // Keep track of all previously seen nums, so we can check if num is\
    \ seen again.\n    seen.set(num, 1);\n\n    output.push(num);\n  }\n\n  return\
    \ output;\n}\n", "    const output: number[] = [];\n    let seen = {};\n    numbers.forEach((number)\
    \ => {\n        if (!seen[number]) {\n            seen[number] = true;\n     \
    \       output.push(number);\n        }\n    });\n    return output;\n}\n</code>\n\
    <|/ a tags=sorting,arrays,javascript dscore=4 |>\n<| c |>\nThis answer was what\
    \ I was looking for! I didn't want to use reduce and used lodash instead. https://stackoverflow.com/questions/53074678/lodash-remove-duplicate-elements-in-array/53074690#53074690\n\
    <|/ c |>\n<| a tags=sorting,arrays,javascript |>\nYou could take a hash table\
    \ and collect all unique elements with same value for an object, then sort the\
    \ keys and map the values by checking the key exists and return the value.\n\n\
    <code>", "\tlet output: number[] = [];\n\tfor (let i = 0; i < numbers.length;\
    \ i++) {\n\t\tfor (let j = 0; j < i; j++) {\n\t\t\tif (numbers[i] === numbers[j])\
    \ {\n\t\t\t\toutput.splice(j, 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn output;\n}\n",
  "  const counts: Map<number, number> = new Map();\n  let result: number[] = [];\n\
    \  for (const n of numbers) {\n    const count = counts.get(n);\n    if (count\
    \ === undefined) {\n      counts[n] = 1;\n    } else {\n      counts[n] += 1;\n\
    \    }\n  }\n  for (const [key, count] of counts) {\n    if (count > 1) {\n  \
    \    result.push(key);\n    }\n  }\n  return result;\n}\n", "    const hash: number[]\
    \ = []; // The value returned from the function will be stored in this array.\n\
    \    for (const num of numbers) {\n        if (hash.indexOf(num) === -1) {\n \
    \           hash.push(num);\n        }\n    }\n    return hash;\n}\n", "    let\
    \ map = new Map<number, boolean>();\n    for (let num of numbers) {\n        if\
    \ (!map.has(num)) {\n            map.set(num, true);\n        }\n    }\n    return\
    \ [...map.keys()];\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=1 |>\n<code>\n\
    const numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];\nconst filteredArray = numbers.filter(item\
    \ => !numbers.includes(item));\n</code>\n<|/ a tags=arrays,javascript |>\n<| c\
    \ |>\nThis answer is better than the accepted one. Using includes is not ideal\
    \ as it uses more memory than needed and it won't be as performant with large\
    \ arrays. But this answer also uses less code and is more obvious.\n<|/ c |>\n\
    <| a tags=arrays,javascript |>\n<code>", "    const numbers_uniq = new Set(numbers);\n\
    \    const result = new Array(numbers.length);\n    for (let i = 0; i < numbers.length;\
    \ i++) {\n        if (numbers_uniq.has(numbers[i]))\n            result[i] = numbers_uniq[numbers[i]];\n\
    \    }\n    return result;\n}\n", "  const result = [];\n  for (let i = 0; i <\
    \ numbers.length; i++) {\n    if (!numbers.includes(numbers[i])) {\n      result.push(numbers[i]);\n\
    \    }\n  }\n  return result;\n}\n", "    var output: number[] = [];\n    for\
    \ (var i = 0; i < numbers.length; ++i) {\n        if (output.indexOf(numbers[i])\
    \ == -1) {\n            output.push(numbers[i]);\n        }\n    }\n    return\
    \ output;\n}\n</code>\nThis implementation is O(n) because it does not use any\
    \ additional memory.\n<|/ a |>\n<| c |>\nIf you use Set then you lose the order\
    \ of elements.\n<|/ c |>\n<| a |>\n<code>\nvar numbers = [1,2,3,4,5,4,3,2,1,4,3,5,3,2,5,4,5];\n\
    var uniqueNumber = [].concat(...numbers.map((n,i)=>i===numbers.indexOf(n)? []:[n]));\n\
    </code>\nThe above method has linear time complexity.\n<|/ a dscore=2 tags=arrays,typescript,javascript\
    \ |>\n<| c |>\nThis doesn't do what you think it does.\n<|/ c |>\n<| c |>\nWhat\
    \ does it do? It filters all the duplicates, and it returns the indices of duplicate\
    \ elements. Please explain.\n<|/ c |>\n<| c |>\nYes, it does filter the duplicates,\
    \ but it does not return the actual elements in the filtered array. I'm currently\
    \ trying to find a solution to do that, but I haven't gotten anywhere yet.\n<|/\
    \ c |>\n<| c |>\nIf you have a solution to that, please post it here.\n<|/ c |>\n\
    <| c |>\nWhat do you think `[].concat(...` is a syntax for?\n<|/ c |>\n<| a |>\n\
    To make it simple, first filter the array then use indexOf to remove any duplicates:\n\
    \n<code>\nvar array = [1,2,3,4,5,4,3,2,1,4,3,5,3,2,5,4,5];\n\nvar unique = array.filter((val,\
    \ i, arr) => arr.indexOf(val) === i);\n\nconsole.log(unique);</code>\n<|/ a dscore=1\
    \ tags=arrays,typescript,javascript |>\n<| a tags=arrays,typescript,javascript\
    \ dscore=1 |>\n<code>", "  const seen = new Set<number>();\n  numbers.forEach(n\
    \ => seen.add(n));\n  return [...new Set<number>(numbers)];\n}\n", "  var result:\
    \ number[] = [];\n  for (var i = 0; i < numbers.length; i++) {\n    if (result.indexOf(numbers[i])\
    \ == -1) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n",
  "    const result: number[] = [];\n    numbers.forEach((n) => {\n        if (result.indexOf(n)\
    \ < 0) {\n            result.push(n);\n        }\n    });\n    return result;\n\
    }\n", "    const hashTable = Object.create(null);\n    const output = [];\n  \
    \  for (const number of numbers) {\n        if (hashTable[number]) continue;\n\
    \        hashTable[number] = true;\n        output.push(number);\n    }\n    return\
    \ output;\n}", "  const hash: number[] = [];\n  for (const num of numbers) {\n\
    \    if (hash.indexOf(num) === -1) {\n      hash.push(num);\n    }\n  }\n  return\
    \ hash;\n}\n", "    const unique = [];\n    numbers.forEach(element => {\n   \
    \     if (unique.indexOf(element) === -1) {\n            unique.push(element);\n\
    \        }\n    });\n    return unique;\n}\n", "  const uniqueArray = [...new\
    \ Set(numbers)];\n  return uniqueArray.sort((a, b) => a - b);\n}\n", "  const\
    \ hashTable = new Map<number, number>();\n  const newArray = numbers.map((num)\
    \ => {\n    if (hashTable.has(num)) {\n      return num;\n    } else {\n     \
    \ hashTable.set(num, num);\n      return num;\n    }\n  });\n  return newArray;\n\
    }\n", "  var uniqueNumbersArray = [];\n  for (var i = 0; i < numbers.length; i++)\
    \ {\n    if (uniqueNumbersArray.indexOf(numbers[i]) < 0) {\n      uniqueNumbersArray.push(numbers[i]);\n\
    \    }\n  }\n  return uniqueNumbersArray;\n}\n", "  const obj: any = {};\n\n \
    \ numbers.forEach((number) => {\n    obj[number] = 1;\n  });\n\n  return Object.keys(obj).map((number)\
    \ => parseInt(number, 10));\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI tried to\
    \ run your code on the array [1,2,3,4,5] and get the following output: [1,2,4,5]\n\
    <|/ c |>\n<| c |>\nOops, didn't see that `parseInt` was used there.\n<|/ c |>\n\
    <| a |>\n<code>\nconst myArr = [1, 2, 3, 1, 2, 3, 1, 2, 3];\n\nconst myUniqueArr\
    \ = myArr.reduce((acc, n) => {\n  let index = acc.findIndex(({ value }) => value\
    \ === n);\n  if (index === -1) {\n    acc.push(n);\n  } else {\n    acc[index].value++;\n\
    \  }\n\n  return acc;\n}, []);\n\nconsole.log(myUniqueArr);</code>\n<|/ a tags=javascript,arrays\
    \ dscore=0 |>\n<| a tags=javascript,arrays |>\n<code>", "  let counts: number[][]\
    \ = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let count: number;\n\
    \    if (counts.length > 0) {\n      count = counts.find(count => count[0] ===\
    \ numbers[i]);\n      if (count === undefined) {\n        count = [numbers[i],\
    \ 1];\n      } else {\n        count[1]++;\n      }\n    } else {\n      count\
    \ = [numbers[i], 1];\n    }\n    counts.push(count);\n  }\n  return counts.map(count\
    \ => count[0]);\n}\n</code>\n<|/ a |>\n<| c |>\nThis is not an efficient algorithm\
    \ as it requires multiple passes through the data.\n<|/ c |>\n<| c |>\nI agree,\
    \ but at least it demonstrates one way to do it, and it's simple.  I do agree\
    \ with that it's probably more efficient to first sort the data, but that isn't\
    \ what the question asked.\n<|/ c |>\n<| c |>\nAs a note in general, I agree with\
    \ your sentiment that sorting should be done in the first place. But I disagree\
    \ with the statement that sorting should be done in the first place. Sorting should\
    \ be done before removing duplicates. You just need to write a comparison function\
    \ for `Array.prototype.sort`.\n<|/ c |>\n<| c |>\nYou're right.  I meant to say\
    \ that sorting should be done in the first place, rather than sorting after the\
    \ fact by doing a sort first then running remove_duplicates, which is essentially\
    \ sorting after removing.  Edited my answer accordingly.\n<|/ c |>\n<| a |>\n\
    Here's a solution using lodash:\n<code>\nvar array = [1,1,1,1];\n\narray = _.uniqBy(array,\
    \ 'value')\n</code>\nThis returns a new array, with duplicate values removed.\n\
    <|/ a tags=javascript,arrays dscore=4 |>\n<| c |>\nI prefer this solution since\
    \ it preserves the order of the original array\n<|/ c |>\n<| c |>\nIt's very nice.\
    \ The only thing is that I cannot find this solution in documentation. Do you\
    \ have any idea why they used this syntax `uniqBy(array, 'value')` instead of\
    \ `uniqBy(array)`?\n<|/ c |>\n<| c |>\nIt's in the documentation: https://lodash.com/docs/4.17.15#uniqBy\n\
    <|/ c |>\n<| a tags=javascript,arrays |>\nMy approach would be to sort them and\
    \ eliminate the duplicates. This doesn't require any complex data structures,\
    \ only a sorting function and an equality function.\n<code>", "    const output\
    \ = new Set<number>();\n    numbers.forEach(num => {\n        if (!output.has(num))\
    \ {\n            output.add(num);\n        }\n    });\n    return [...output].sort();\n\
    }\n", "\tconst counts: number[] = [];\n\tfor (let i = 0; i < numbers.length; i++)\
    \ {\n\t\tcounts[numbers[i]] = counts[numbers[i]] ? counts[numbers[i]] + 1 : 1;\n\
    \t}\n\tconst uniques: number[] = [];\n\tfor (let i = 0; i < numbers.length; i++)\
    \ {\n\t\tif (counts[numbers[i]] === 1) {\n\t\t\tuniques.push(numbers[i]);\n\t\t\
    }\n\t}\n\treturn uniques;\n}\n", "  const duplicates: number[] = []\n  const output:\
    \ number[] = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers.indexOf(i)\
    \ > -1) {\n      duplicates.push(i)\n    }\n  }\n  duplicates.forEach((i) => {\n\
    \    const index = numbers.indexOf(i)\n    numbers.splice(index, 1)\n  })\n  numbers.forEach((i)\
    \ => {\n    if (output.indexOf(i) === -1) {\n      output.push(i)\n    }\n  })\n\
    \  return output\n}", "    let result = [];\n    let nums = numbers.slice(0);\n\
    \    for(let num of nums) {\n        let index = result.indexOf(num);\n      \
    \  if(index > -1) result.splice(index, 1);\n        else {\n            result.push(num);\n\
    \        }\n    }\n    return result;\n}\n", "    const ret: number[] = [];\n\
    \    let last: number;\n    let next: number;\n    for (let i = 0; i < numbers.length;\
    \ ++i) {\n        last = ret.shift();\n        if (numbers[i] === last) {\n  \
    \          continue;\n        }\n        ret.push(numbers[i]);\n    }\n    return\
    \ ret;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis is how i did it on TypeScript:\n\
    <code>", "    let uniqueNumbers = new Set<number>();\n\n    numbers.forEach(function\
    \ (number) {\n        if (uniqueNumbers.has(number)) {\n            uniqueNumbers.delete(number);\n\
    \        } else {\n            uniqueNumbers.add(number);\n        }\n    });\n\
    \n    return [...uniqueNumbers];\n}\n", "    const uniqueNumbers = new Set<number>();\
    \ // Create Set of unique numbers\n    for (const n of numbers) {\n        if\
    \ (!uniqueNumbers.has(n)) {\n            uniqueNumbers.add(n);\n        }\n  \
    \  }\n    return [...uniqueNumbers].sort((a, b) => a - b);\n}\n", "    const uniqueNumbers:\
    \ number[] = [];\n    const lookup = new Map<number, boolean>();\n\n    for (let\
    \ i = 0; i < numbers.length; i++) {\n        const value = numbers[i];\n     \
    \   if (lookup.has(value)) {\n            continue;\n        }\n        lookup.set(value!,\
    \ true)\n        uniqueNumbers.push(value);\n    }\n    return uniqueNumbers;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=c#,.net,linq |>\nIn C# 8.0 you\
    \ can use LINQ's Distinct() method to achieve this:\n<code>\nint[] numbers = {\
    \ 1, 2, 3, 2, 4 };\nvar distinctNumbers = numbers.Distinct().ToArray();\n</code>\n\
    <|/ a |>\n<| a |>\nHow about this?\n<code>\nint[] numbers = { 1, 2, 3, 2, 4 };\n\
    int[] distinctNumbers = numbers.ToList().Distinct().ToArray();\n</code>\n<|/ a\
    \ tags=c#,.net,linq dscore=2 |>\n<| a dscore=1 |>\nJust for fun I implemented\
    \ a version with HashSet<> and Linq and a little bit of LinqPad:\n<code>\nvoid\
    \ Main()\n{\n    var list = new List<int>() { 1, 2, 3, 2, 4 };\n\n    list.Dump();\n\
    \n    list.Distinct().Dump();\n\n    list = list.Distinct().ToList();\n\n    list.Dump();\n\
    \n}\npublic static class LinqExtensions\n{\n    public static IEnumerable<T> Distinct<T>(this\
    \ IEnumerable<T> source)\n    {\n        var distinct = new HashSet<T>();\n  \
    \      foreach (var item in source)\n        {\n            distinct.Add(item);\n\
    \        }\n        return distinct.AsEnumerable();\n    }\n}\n</code>\n<|/ a\
    \ tags=c#,.net,linq |>\n<| a tags=c#,.net,linq |>\nAs you said yourself, this\
    \ can be done with a simple for loop:\n<code>\nfor (int i = 0; i < numbers.Length;\
    \ i++)\n{\n    if (!numbers.Contains(numbers[i]))\n    {\n        numbers[i] =\
    \ numbers[i] - 1;\n    }\n}\n</code>\nHowever, I think it would be better if you\
    \ could store those numbers in a collection in the first place, and then do something\
    \ like the following:\n<code>\nnumbers.RemoveAll(n => numbers.IndexOf(n) == numbers.IndexOf(n\
    \ + 1));\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks Steve, your answer was the\
    \ most efficient.\n<|/ c |>\n<| a |>\nYou could use Aggregate, but as you said\
    \ you want a LINQ solution", "    const obj = {};\n    numbers.forEach((num) =>\
    \ {\n        obj[num] = true;\n    });\n\n    const res = [];\n    Object.keys(obj).forEach((key)\
    \ => {\n        res.push(Number(key));\n    });\n\n    return res;\n}\n", "  numbers\
    \ = numbers.slice().sort();\n  var unique_numbers = [];\n  var prev_number = numbers[0];\n\
    \n  for (var i = 1; i < numbers.length; i++) {\n    if (numbers[i] === prev_number)\
    \ {\n      continue;\n    } else {\n      unique_numbers.push(prev_number);\n\
    \    }\n\n    prev_number = numbers[i];\n  }\n\n  return unique_numbers.slice().sort();\n\
    }\n", "    const uniques: number[] = [];\n    numbers.forEach((num) => {\n   \
    \     if (uniques.indexOf(num) === -1) {\n            uniques.push(num);\n   \
    \     }\n    });\n    return uniques;\n}\n</code>\n<|/ a tags=java,arrays,data-structures,algorithm\
    \ |>\n<| a tags=java,arrays,data-structures,algorithm |>\n<code>\npublic static\
    \ void main(String[] args) {\n    int[] arr = {1, 2, 3, 4, 2, 4};\n    System.out.println(Arrays.toString(removeDuplicates(arr)));\n\
    }\n\npublic static int[] removeDuplicates(int[] arr) {\n    List<Integer> list\
    \ = new ArrayList<Integer>();\n    for(int i : arr) {\n        if(list.contains(i))\
    \ {\n            continue;\n        }\n        list.add(i);\n    }\n    return\
    \ list.toArray(new Integer[list.size()]);\n}\n</code>\nOutput:\n[1, 3, 4]\n<|/\
    \ a dscore=3 |>\n<| c |>\n`List<Integer>` will result in boxing/unboxing which\
    \ takes time and memory which is not needed.\n<|/ c |>\n<| a tags=java,arrays,data-structures,algorithm\
    \ |>\nJava 8 Streams\n<code>\npublic static int[] removeDuplicates(int[] arr)\
    \ {\n    return Arrays.stream(arr).distinct().toArray();\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis should be the top answer\n<|/ c |>\n<| a tags=java,arrays,data-structures,algorithm\
    \ dscore=2 |>\n<code>\npublic class Test {\n    public static int[] removeDuplicates(int[]\
    \ arr) {\n    List<Integer> list = new ArrayList<>();\n    for (int i : arr) {\n\
    \        if (list.contains(i)) {\n            continue;\n        }\n        list.add(i);\n\
    \    }\n    return list.toArray(new Integer[list.size()]);\n}\npublic static void\
    \ main(String[] args) {\n    int[] arr = {1, 2, 3, 1, 2, 3, 2, 2, 4, 1};\n   \
    \ System.out.println(Arrays.toString(removeDuplicates(arr)));\n}\n}\n</code>\n\
    <|/ a |>\n<| c |>\nYou should use the method `Arrays.asList(...)` instead of `new\
    \ ArrayList<Integer>()`.\n<|/ c |>\n<| a dscore=2 |>\nIn terms of performance,\
    \ it would be better to create a set and add the numbers to it if they are not\
    \ already present. Here is an example of how to implement this using Java 8:\n\
    <code>\npublic int[] removeDuplicates(int[] arr) {\n    Set<Integer> set = new\
    \ HashSet<Integer>();\n    Arrays.stream(arr).forEach(set::add);\n    return set.toArray(new\
    \ Integer[", "    var filtered: number[] = [];\n\n    numbers.forEach((n, i) =>\
    \ {\n        if (filtered.indexOf(n) === -1) {\n            filtered.push(n);\n\
    \        }\n    });\n\n    return filtered;\n}\n</code>\n<|/ a tags=javascript,sorting,arrays\
    \ dscore=2 |>\n<| a |>\n<code>", "    var result = [];\n    var seen: number[]\
    \ = [];\n    for (var i = 0; i < numbers.length; i++) {\n        if (seen.indexOf(numbers[i])\
    \ !== -1) {\n            continue;\n        }\n        result.push(numbers[i]);\n\
    \        seen.push(numbers[i]);\n    }\n    return result;\n}\n", "  const hash\
    \ = {};\n  const result = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n\
    \    const number = numbers[i];\n    if (number in hash) {\n      hash[number]++;\n\
    \    } else {\n      hash[number] = 1;\n      result.push(number);\n    }\n  }\n\
    \n  return result;\n}\n", "    const unique = {};\n    numbers.forEach((number)\
    \ => {\n        if (unique[number]) {\n            unique[number]++;\n       \
    \ } else {\n            unique[number] = 1;\n        }\n    });\n    return Object.keys(unique).map((key)\
    \ => {\n        return unique[key];\n    });\n}\n", "    let output: number[]\
    \ = [];\n    let used: number[] = [];\n    for (let i = 0; i < numbers.length;\
    \ i++) {\n        if (used.indexOf(numbers[i]) !== -1) {\n            continue;\n\
    \        }\n        output.push(numbers[i]);\n        used.push(numbers[i]);\n\
    \    }\n    return output;\n}\n", "  let unique: number[] = [];\n  for (const\
    \ n of numbers) {\n    if (unique.indexOf(n) === -1) {\n      unique.push(n);\n\
    \    }\n  }\n  return unique;\n}", "    var unique: number[] = [];\n    numbers.forEach(function\
    \ (number: number) {\n        if (unique.indexOf(number) === -1) {\n         \
    \   unique.push(number);\n        }\n    });\n    return unique;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis solution doesn't give the correct output if the\
    \ input is of length 2 only. For example it gives `[1, 1, 2]` instead of `[1,\
    \ 2, 1]`.\n<|/ c |>\n<| c |>\n`[1, 1, 2]` would be the correct answer for the\
    \ test cases you provided. `[1, 1]` would be the correct answer for the `[1, 1]`\
    \ test case. The OP was asking for the solution for all cases and this solution\
    \ is what they need. `[1, 1]` should return `[1, 2, 1]` but instead returns `[1,\
    \ 1]`. The other test cases listed in the OP were not present in the OP's test\
    \ cases.\n<|/ c |>\n<| c |>\n`[1,1,2]` should return `[1,2,1]`. Your code returns\
    \ `[1,1]`\n<|/ c |>\n<| c |>\nYou are right, I missed that. Updated the code to\
    \ fix that.\n<|/ c |>\n<| c |>\n`[1, 1]` should return `[1, 2, 1]` but instead\
    \ returns `[1, 1]`\n<|/ c |>\n<| a tags=arrays,javascript,algorithm,sorting |>\n\
    Try this\n<code>\nvar newArray = input.reduce(function(acc, current) {\n    if\
    \ (acc.indexOf(current) === -1) {\n        acc.push(current);\n    }\n    return\
    \ acc;\n}, []);\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThe reduce is not needed.\n\
    <|/ c |>\n<| c |>\nThis is pretty much the same as the code in the question\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is my solution:\n<code>", "  let unique = [...new\
    \ Set(numbers)];\n  let sorted = unique.sort();\n  return sorted;\n}\n</code>\n\
    To convert array of integers to an array of strings, you can simply do:\n<code>\n\
    numberArray.toString();\n</code>\n<|/ a dscore=2 |>\n<| a tags=javascript,arrays\
    \ |>\nIf your input is array of integers, this should do the trick.\n<code>",
  "    let numbers_as_strings = numbers.map(Number);\n    let unique_numbers_as_strings\
    \ = Array.from(new Set(numbers_as_strings));\n    let unique_numbers_as_numbers\
    \ = unique_numbers_as_strings.map(Number);\n    return unique_numbers_as_numbers;\n\
    }\n", "  return numbers.filter((num, index, self) => self.indexOf(num) === index);\n\
    }\n", "\tconst output = new Array<number>(numbers.length);\n\tfor (let i = 0;\
    \ i < numbers.length; i++) {\n\t\tlet count = 0;\n\t\tfor (let j = i + 1; j <\
    \ numbers.length; j++) {\n\t\t\tif (numbers[i] === numbers[j]) {\n\t\t\t\tcount++;\n\
    \t\t\t}\n\t\t}\n\t\tif (count === 1) {\n\t\t\toutput.push(numbers[i]);\n\t\t}\n\
    \t}\n\treturn output;\n}\n", "  let output = [];\n  numbers = [...new Set(numbers)];\n\
    \  \n  numbers.forEach(item => output.push(item));\n  \n  return output;\n}\n\
    </code>\n<|/ a tags=javascript |>\n<| c |>\nThis isn't really an answer, but it's\
    \ too long for a comment. You might want to post it as an answer to the original\
    \ question.\n<|/ c |>\n<| c |>\nI thought of it first, but I thought it would\
    \ not give the correct output if the array was sorted or if it contained duplicate\
    \ values. I agree that it's better to post an answer than just linking to a solution\
    \ (the reason why I didn't post it as an answer is that I don't want to post \"\
    link-only\" answers), but this solution does not work for all types of arrays\
    \ (for example, if it was `[1, 2, 2, 3, 3, 1]`, you'd get `[2, 3, 1]` as output).\n\
    <|/ c |>\n<| c |>\nThat is true, I just tested that and it did not work if array\
    \ was sorted or if it contained duplicate values. I will edit my answer so that\
    \ it also works for sorted and duplicates.\n<|/ c |>\n<| c |>\nThe array was sorted\
    \ before it was passed to this method. I'm sorry if I missed a detail.\n<|/ c\
    \ |>\n<| a tags=javascript |>\nI suggest you to convert array to set and then\
    \ back to array.\n<code>\nlet input = [1, 2, 3, 4, 2, 3, 2];\nlet unique = [...new\
    \ Set(input)];\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is an old thread, but\
    \ I find this to be the simplest and most efficient answer. If performance is\
    \ an issue then I suggest not using the spread operator, as it involves creating\
    \ a new array each time. Also, I think this approach is more readable than the\
    \ other approaches here.\n<|/ c |>\n<| c |>\nYeah, I agree that this is probably\
    \ the most efficient and readable answer for this situation. IMO, this is probably\
    \ the best answer to this question.\n<|/ c |>\n<| c |>\nThis is the best answer.\
    \ You are actually converting to array then to set then back to array which converts\
    \ it back again.\n<|/ c |>\n<| a dscore=5 |>\n<code>\nconst unique = (arr) =>\
    \ {\n  const seen = new Set()\n  return [...new Set(arr)].filter((item) => {\n\
    \    return seen.has(item) ? false : (seen.add(item))\n  })\n}\n</code>\n<|/ a\
    \ tags=javascript |>\n<| c |>\nNice one! For me it worked fine using it with a\
    \ `filter` function ", "  let counts = new Map<number, number>();\n  for (const\
    \ num of numbers) {\n    counts.set<number>(num, counts.get(num) + 1);\n  }\n\n\
    \  const result: number[] = [];\n  for (const num of numbers) {\n    if (counts.has(num))\
    \ {\n      counts.delete(num);\n    } else {\n      result.push(num);\n    }\n\
    \  }\n  return result;\n}\n", "  let new_numbers = numbers.reduce((memo: number[],\
    \ num: number) => memo.indexOf(num) === -1 ? memo.concat(num) : memo, []);\n \
    \ return new_numbers;\n}\n</code>\n<|/ a |>\n<| c |>\nThis code is great for me.\
    \ I'm new to JavaScript and this is the first answer that actually works with\
    \ any number of elements and only takes two lines.\n<|/ c |>\n<| a |>\nI wrote\
    \ an algorithm that doesn't require a library. I'm sure the performance is better\
    \ than using a library, but it is more succinct.\n<code>\nconst removeDups = (arr:\
    \ number[]) => {\n  let newArr: number[] = [];\n  for (let item of arr) {\n  \
    \  let found = false;\n    for (const i of newArr) {\n      if (i === item) {\n\
    \        found = true;\n        break;\n      }\n    }\n    if (!found) {\n  \
    \    newArr.push(item);\n    }\n  }\n  return newArr;\n};\n</code>\n<|/ a dscore=5\
    \ tags=javascript,algorithm,typescript,arrays,duplicates |>\n<| c |>\nThis solution\
    \ works for the case where you only need to check if an item is in the list once,\
    \ which I think is what the question is asking for. For a more general solution,\
    \ please see [answer by Lakshminar](https://stackoverflow.com/a/61516138/11531404).\n\
    <|/ c |>\n<| c |>\nThis answer is incorrect for cases where you want to remove\
    \ duplicates in place. For example if you are trying to remove duplicates from\
    \ an array of `[1, 2, 2, 3, 3, 4, 4]`, after calling this function `newArr` will\
    \ end up containing `[1,2,3,4]` instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis\
    \ is O(n^2) algorithm, which is not efficient.\n<|/ c |>\n<| c |>\nWhat if i want\
    \ to remove duplicate from array of objects?\n<|/ c |>\n<| c |>\nWhat if i want\
    \ to remove duplicate from array of objects?\n<|/ c |>\n<| a tags=javascript,algorithm,typescript,arrays,duplicates\
    \ |>\nThis solution works for any number of duplicated elements, not just duplicate\
    \ numbers. \n<code>", "    let newArray: number[] = [];\n    numbers.forEach((currentValue:\
    \ number, index) => {\n        if (index === 0) {\n            newArray.push(currentValue);\n\
    \        } else if (newArray.indexOf(currentValue) === -1) {\n            newArray.push(currentValue);\n\
    \        }\n    });\n    return newArray;\n}\n", "\tconst output = [];\n\tlet\
    \ unique = true;\n\tconst seen: Set<number> = new Set<number>();\n\tfor (const\
    \ num of numbers) {\n\t\tif (seen.has(num)) {\n\t\t\tunique = false;\n\t\t} else\
    \ {\n\t\t\tseen.add(num);\n\t\t\toutput.push(num);\n\t\t}\n\t}\n\treturn unique\
    \ ? output : numbers.concat(output);\n}\n", "  const result: number[] = []\n \
    \ const seen: number[] = []\n  for (const num of numbers) {\n    if (seen.indexOf(num)\
    \ < 0) {\n      seen.push(num)\n      result.push(num)\n    }\n  }\n  return result\n\
    }\n", "  const output: number[] = [];\n  const map: Map<number, number> = new\
    \ Map();\n\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n\
    \    const count = map.get(number);\n\n    if (count > 1) {\n      map.set(number,\
    \ count - 1);\n    } else {\n      map.set(number, 1);\n    }\n\n    output.push(number);\n\
    \  }\n\n  return output;\n}\n", "    const result: number[] = [];\n    const seen:\
    \ Set<number> = new Set();\n    for (const num of numbers) {\n        if (!seen.has(num))\
    \ {\n            seen.add(num);\n            result.push(num);\n        }\n  \
    \  }\n    return result;\n}\n", "  return Array.from(new Set(numbers));\n}\n",
  "  const seen: number[] = new Array();\n  const result: number[] = [];\n  for (let\
    \ i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n    if (seen.indexOf(number)\
    \ !== -1) {\n      continue;\n    }\n    seen.push(number);\n    result.push(number);\n\
    \  }\n  return result;\n}", "\tconst result: number[] = [];\n\tlet currentNumber:\
    \ number|undefined = undefined;\n\n\tfor (const number of numbers) {\n\t\tif (number\
    \ === currentNumber) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult.push(number);\n\t\t\
    currentNumber = number;\n\t}\n\n\treturn result;\n}\n", "  const uniques = new\
    \ Set(numbers);\n  return [...uniques].sort();\n}\n", "    let results: number[]\
    \ = [];\n    let seen: number[] = [];\n    numbers.forEach((number) => {\n   \
    \     if (seen.indexOf(number) !== -1) {\n            return;\n        }\n   \
    \     seen.push(number);\n        results.push(number);\n    });\n    return results;\n\
    }\n", "    const hashSet = new Set();\n    const output: number[] = [];\n\n  \
    \  for (let num of numbers) {\n        if (hashSet.has(num)) {\n            continue;\n\
    \        }\n\n        hashSet.add(num);\n        output.push(num);\n    }\n\n\
    \    return output;\n}\n</code>\nThis solution is O(n) by iterating over the input\
    \ only once, but this is fairly inefficient for small arrays (like I said this\
    \ was an interview question - not an actual problem or something). You could also\
    \ use a HashSet to keep track of the values you've seen before, but that's an\
    \ O(n) solution too.\n<|/ a tags=java,arrays |>\n<| a dscore=0 tags=java,arrays\
    \ |>\nOkay let's make it really simple:\n<code>\npublic static void main (String[]\
    \ args) {\n    int[] a = { 1, 2, 3, 1, 2, 3, 1 };\n    int[] b = Arrays.copyOf(a,\
    \ a.length);\n    Arrays.sort(b);\n\n    int count = 0;\n    for (int i = 1; i\
    \ < b.length; i++) {\n        if (a[i - 1] != b[i]) {\n            count++;\n\
    \        }\n    }\n\n    System.out.println(count);\n}\n</code>\nOutput\n<code>\n\
    5\n</code>\n<|/ a |>\n<| c |>\nThis is not what was asked for, if you consider\
    \ input `{ 1, 2, 3, 2, 1 }` you get answer `3`\n<|/ c |>\n<| a tags=java,arrays\
    \ |>\nI did an interview question on HackerRank recently. I was asked to count\
    \ the occurrence of any value within a given array.\nBelow is the solution I came\
    \ up with.\n<code>\npublic static int countOccurrences(int[] nums) {\n    int\
    \ count = 0;\n    int value = 0;\n\n    for (int i = 0; i < nums.length; i++)\
    \ {\n        value = nums[i];\n\n        for (int j = i; j < nums.length; j++)\
    \ {\n            if (nums[j] == value) {\n                count++;\n         \
    \   }\n        }\n    }\n\n    return count;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=java,arrays |>\n<code>\npublic static int getOccurance(int[] arr) {\n\
    \    int count=0;\n    for(int i=0;i<arr.length;i++){\n        if(arr[i]!=arr[arr.length-1])\n\
    \            count++;\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis answer doesn't answer the question which is to count the number\
    \ of occurrences of the last element of the array. In the example { 1, 2 } the\
    \ output should be 2 and not 3.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\n\
    public class countOccurrences {\n    public static void main(String ", "    const\
    \ unique = numbers.filter((v, i, a) => a.indexOf(v) === i);\n    return unique;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a |>\nAn alternative to Array.filter is to map\
    \ the array, remove duplicates, and return only distinct values:\n<code>\nvar\
    \ distinctNumber = [2,2,4,4,5,5,5].map(x => x).filter((x, i, arr) => arr.indexOf(x)\
    \ === i);\n</code>\n<|/ a dscore=2 tags=arrays,javascript |>\n<| c |>\nI like\
    \ this one, but it seems a bit heavy on the conversion.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI know this is an old question, but I've recently come up with a solution\
    \ that doesn't require any iteration/looping, only array methods and no additional\
    \ arrays are required. \n<code>", "  let unique = new Set<number>();\n\n  for\
    \ (let i = 0; i < numbers.length; i++) {\n    if (unique.has(numbers[i])) {\n\
    \      continue;\n    }\n\n    unique.add(numbers[i]);\n  }\n\n  return Array.from(unique);\n\
    }\n", "    let result: number[] = [];\n    numbers.forEach((number) => {\n   \
    \     if (result.indexOf(number) !== -1) {\n            return;\n        }\n \
    \       result.push(number);\n    });\n    return result;\n}\n\nexport function\
    \ remove_duplicates2(numbers: number[]): number[] {\n    return numbers.filter((number)\
    \ => {\n        return numbers.indexOf(number) === numbers.lastIndexOf(number);\n\
    \    });\n}\n\nexport function remove_duplicates3(numbers: number[]): number[]\
    \ {\n    let result = [];\n    numbers.forEach((number) => {\n        if (numbers.indexOf(number)\
    \ === numbers.lastIndexOf(number)) {\n            return;\n        }\n       \
    \ result.push(number);\n    });\n    return result;\n}\n", "  const uniques: number[]\
    \ = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers.indexOf(numbers[i])\
    \ === -1) {\n      uniques.push(numbers[i]);\n    }\n  }\n  return uniques;\n\
    }\n", "    const output: number[] = [];\n    let found = false;\n    for (let\
    \ i = 0; i < numbers.length; i++) {\n        const number = numbers[i];\n    \
    \    if (output.indexOf(number) === -1) {\n            output.push(number);\n\
    \        } else {\n            found = true;\n        }\n    }\n    if (!found)\
    \ {\n        return output.sort();\n    }\n    return output;\n}\n", "    let\
    \ found = {};\n    return numbers.filter(v => {\n        let i = found[v];\n \
    \       if (i === undefined) {\n            found[v] = true;\n            return\
    \ true;\n        } else {\n            delete found[v];\n            return false;\n\
    \        }\n    });\n}\n", "    const set = new Set();\n    for (let i = numbers.length\
    \ - 1; i >= 0; i--) {\n        const number = numbers[i];\n        if (set.has(number))\
    \ {\n            numbers.splice(i, 1);\n        } else {\n            set.add(number);\n\
    \        }\n    }\n    return numbers;\n}\n", "  let seen: number[] = new Array(numbers.length)\n\
    \  return numbers.filter((val, idx) => seen.indexOf(val) === -1 ? seen.push(val):\
    \ false)\n}\n", "  const unique: Set<number> = new Set();\n  numbers.forEach((num)\
    \ => {\n    if (unique.has(num)) {\n      unique.delete(num);\n    } else {\n\
    \      unique.add(num);\n    }\n  });\n  return [...unique];\n}\n", "    const\
    \ result: number[] = [];\n\n    for (let i = 0; i < numbers.length; i++) {\n \
    \       const found: boolean = result.findIndex(el => el === numbers[i]) > -1;\n\
    \        if (!found) {\n            result.push(numbers[i]);\n        }\n    }\n\
    \n    return result;\n}\n", "  const result = new Array<number>(numbers.length);\n\
    \  for (let i = 0; i < numbers.length; i++) {\n    if (!hasDuplicates(result,\
    \ numbers[i])) {\n      result[i] = numbers[i];\n    }\n  }\n  return result;\n\
    }\n", "  const map: number[] = {};\n  for (let i = 0; i < numbers.length; i++)\n\
    \    map[numbers[i]] = true;\n  return numbers.filter(n => !(n in map));\n}\n",
  "  const result: number[] = [];\n  const seen = new Set<number>();\n  for(const\
    \ num of numbers) {\n    if(!seen.has(num)) {\n      seen.add(num);\n      result.push(num);\n\
    \    }\n  }\n  return result;\n}\n</cell>\n<text>\nremove_duplicates\n\n\n</text>\n\
    <cell>", "    const result: number[] = [];\n\n    for (let i = 0, length = numbers.length;\
    \ i < length; i++) {\n        const num = numbers[i];\n        if (result.indexOf(num)\
    \ === -1) {\n            result.push(num);\n        }\n    }\n\n    return result;\n\
    }\n", "\tlet seen: any[] = [];\n\tlet result: any[] = [];\n\tnumbers.forEach((num)\
    \ => {\n\t\tif (seen.indexOf(num) >= 0) return;\n\t\tseen.push(num);\n\t\tresult.push(num);\n\
    \t});\n\treturn result;\n}\n", "  return numbers.filter((value, index, arr) =>\
    \ arr.indexOf(value) === index);\n}\n", "  const output = [];\n  for (const num\
    \ of numbers) {\n    if (output.indexOf(num) === -1) {\n      output.push(num);\n\
    \    }\n  }\n  return output;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is\
    \ very very helpful! Thank you very much!\n<|/ c |>\n<| a |>\nSince you mention\
    \ that the number of occurrences might vary you could use a simple function with\
    \ a hash object to find all duplicates. \n<code>", "    let uniques: number[]\
    \ = [];\n    for (let n of numbers) {\n        if (uniques.indexOf(n) === -1)\
    \ uniques.push(n);\n    }\n    return uniques;\n}\n", "    const output: number[]\
    \ = [];\n    let i: number;\n    let j: number;\n\n    for (i = 0; i < numbers.length;\
    \ i++) {\n        for (j = i + 1; j < numbers.length; j++) {\n            if (numbers[i]\
    \ === numbers[j]) {\n                numbers.splice(i, 1);\n                i--;\n\
    \                break;\n            }\n        }\n    }\n\n    return output.concat(numbers);\n\
    }\n", "  const output: number[] = [];\n  for (const num of numbers) {\n    if\
    \ (!output.includes(num)) {\n      output.push(num);\n    }\n  }\n  return output;\n\
    }\n", "  numbers = numbers.slice();\n  let newSet = new Set(numbers);\n  let result\
    \ = [];\n  for (let num of numbers) {\n    if (newSet.has(num)) {\n      continue;\n\
    \    }\n    newSet.add(num);\n    result.push(num);\n  }\n  return result;\n}\n",
  "    const results: number[] = [];\n    for (const num of numbers) {\n        const\
    \ idx = numbers.indexOf(num);\n        if (idx === -1) {\n            results.push(num);\n\
    \        } else {\n            if (idx > -1) {\n                numbers.splice(idx,\
    \ 1);\n            }\n        }\n    }\n    return results;\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nThanks for your answer.  While this does work, it is not\
    \ efficient because `indexOf` is O(n).  A better solution would be to use [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set).\
    \  This solution will also be more memory efficient because `Set.add()` has a\
    \ constant time complexity of O(1).\n<|/ c |>\n<| c |>\nThanks.  This is much\
    \ better.\n<|/ c |>\n<| a tags=arrays,javascript |>\nYou can use Sets.\n<code>\n\
    var arr = [1,1,2,3,1];\n\nvar noDuplicate = new Set([...arr]);\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nThis also works but is less efficient as Set has a `O(1)`\
    \ complexity for add.  For this example, it should be faster and less memory intensive\
    \ because it is creating a new Set object.\n<|/ c |>\n<| c |>\nThis will be a\
    \ lot more efficient as it will only add the values to the Set if the value is\
    \ not already there.\n<|/ c |>\n<| a |>\nHere is a solution that is both simple\
    \ and fast (at least in Chrome):\n<code>\nvar arr = [1,1,2,3,1];\narr.sort();\n\
    \nvar result = [];\nvar previous = arr[0];\n\nfor (var i = 1; i < arr.length;\
    \ i++) {\n  if (previous == arr[i]) {\n    continue;\n  }\n  result.push(previous);\n\
    \  previous = arr[i];\n}\n</code>\n<|/ a tags=arrays,javascript dscore=3 |>\n\
    <| a |>\n<code>\nvar array=[1,1,2,3,1];\n\nvar newarray=[];\n\nfor(var i=0;i<array.length;i++)\n\
    {\n    if(!newarray.includes(array[i]))\n    {\n        newarray.push(array[i]);\n\
    \    }\n}\n\nconsole.log(newarray);</code>\n<|/ a dscore=3 tags=arrays,javascript\
    \ |>\n<| c |>\n`includes()` is O(n). [Set has a constant time complexity of O(1)](https://stackoverflow.com/a/4550632/206403).\n\
    <|/ c |>\n<| a tags=arrays,javascript dscore=1 |>\nYou could take two iterators\
    \ and check every item with the second one.\n\n<code>", "  let uniqueNumbers:\
    \ number[] = [];\n  let uniqueNumbersMap: any = {};\n  numbers.forEach(function(num)\
    \ {\n    if (uniqueNumbersMap[num] === undefined) {\n      uniqueNumbersMap[num]\
    \ = num;\n      uniqueNumbers.push(num);\n    }\n  });\n  return uniqueNumbers;\n\
    }\n</code>\n<|/ a tags=javascript,ecmascript-6,algorithm,sorting,arrays |>\n<|\
    \ a dscore=1 tags=javascript,ecmascript-6,algorithm,sorting,arrays |>\nYou could\
    \ use an object and check if the key exists before adding it to the result.\n\n\
    <code>\nvar array = [1, 4, 6, 1, 2, 3, 4, 4, 9],\n    result = array.reduce((o,\
    \ v) => {\n        o[v] = o[v] || [];\n        o[v].push(v);\n        return o;\n\
    \    }, {});\n\nconsole.log(result);</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\n\
    var myArray = [1, 4, 6, 1, 2, 3, 4, 4, 9];\n\nvar myObject = {};\nmyArray.forEach(function\
    \ (item) { myObject[item] = myObject[item] || []; });\n</code>\n<|/ a tags=javascript,ecmascript-6,algorithm,sorting,arrays\
    \ |>\n<| a tags=javascript,ecmascript-6,algorithm,sorting,arrays dscore=0 |>\n\
    Another solution in pure JavaScript ES6 (ES6 Array.prototype.reduce):\n\n<code>\n\
    let array = [1, 4, 6, 1, 2, 3, 4, 4, 9];\nlet result = [...new Set(array)].sort();\n\
    console.log(result);</code>\n<|/ a |>\n<| c |>\nThis does not preserve the order\
    \ of the elements.\n<|/ c |>\n<| c |>\nGood catch. Not sure why this was voted\
    \ down though... It does preserve the order of elements.\n<|/ c |>\n<| c |>\n\
    The OP wants ordered elements, you don't. The result is `[1, 4, 6, 1, 2, 3, 4,\
    \ 4, 9]` though.\n<|/ c |>\n<| c |>\nYou're right. I missed that detail. Thanks\
    \ for the catch.\n<|/ c |>\n<| a tags=javascript,ecmascript-6,algorithm,sorting,arrays\
    \ dscore=0 |>\n<code>\nlet arr = [1, 4, 6, 1, 2, 3, 4, 4, 9];\n\nlet newArr =\
    \ arr.filter(x => arr.indexOf(x) === arr.lastIndexOf(x))\n\nconsole.log(newArr)</code>\n\
    \nThis should work for you.\n<|/ a |>\n<| c |>\nThis does not preserve the order\
    \ of the elements.\n<|/ c |>\n<| c |>\nYes, i just realized ", "  let uniqueNumbers:\
    \ number[] = [];\n  for (let number in numbers) {\n    if (numbers.hasOwnProperty(number))\
    \ {\n      uniqueNumbers.push(number);\n    }\n  }\n  return uniqueNumbers;\n\
    }\n", "  const uniqueNumbers: number[] = [];\n  const uniqueIndexMap: { [number]:\
    \ number; } = {};\n\n  for (let i = 0; i < numbers.length; i++) {\n    const number\
    \ = numbers[i];\n\n    if (!uniqueIndexMap[number]) {\n      uniqueNumbers.push(number);\n\
    \      uniqueIndexMap[number] = i;\n    }\n  }\n\n  return uniqueNumbers;\n}\n",
  "  var output: number[] = [];\n  for (var i = 0; i < numbers.length; i++) {\n  \
    \  if (numbers.indexOf(numbers[i]) > -1 && output.indexOf(numbers[i]) === -1)\
    \ {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis approach is very inefficient, as you require\
    \ two passes over the array. I think the accepted answer is much better.\n<|/\
    \ c |>\n<| a tags=javascript,angularjs |>\nI prefer this method:\n<code>\nvar\
    \ uniqueItems = _.filter(items, function(item){\n    return _.indexOf(uniqueItems,\
    \ item) === -1;\n});\n</code>\n<|/ a dscore=5 |>\n<| c |>\n_.filter has been replaced\
    \ in angular 1.3 with 'filter' in underscore. The correct syntax for angular 1.3\
    \ would be:\n\n`var uniqueItems = items.filter(function(item){\n    return _.indexOf(uniqueItems,\
    \ item) === -1;\n});`\n<|/ c |>\n<| c |>\nThe accepted answer is more concise\
    \ than this, if you need it more efficient\n<|/ c |>\n<| c |>\nThis is a great\
    \ solution. Using this in angular 1.5.8 without underscore.\n<|/ c |>\n<| c |>\n\
    this answer was posted before 1.3 came out and it had the code I needed (since\
    \ I already had underscore as a dependency). the accepted answer is the updated\
    \ answer.\n<|/ c |>\n<| c |>\nThis doesn't work correctly if your array contains\
    \ NaN.\n<|/ c |>\n<| a |>\nI prefer this method:\n<code>\nvar uniqueItems = _.difference(items,\
    \ _.uniq(items)))\n</code>\n<|/ a tags=javascript,angularjs dscore=5 |>\n<| c\
    \ |>\n_ is lodash which has a lot of utility functions for angular\n<|/ c |>\n\
    <| c |>\nThis is the best answer IMHO. Nice and simple.\n<|/ c |>\n<| c |>\nWorked\
    \ for me and used the underscore dependency so much I didn't even consider using\
    \ it\n<|/ c |>\n<| c |>\nWorked for me. Thank you.\n<|/ c |>\n<| c |>\nWorked\
    \ for me on array of numbers :) Thank you.\n<|/ c |>\n<| a dscore=5 tags=javascript,angularjs\
    \ |>\nYou could create a Set from your array and then use Array.from() to extract\
    \ your unique items:\n\n<code>\nconst originalArray = [1, 2, 3, 1, 2, 3];\nconst\
    \ uniqueArray = ", "  let uniq: number[] = []\n  let seen: Map<number, boolean>\
    \ = new Map()\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.has(numbers[i]))\
    \ {\n      continue\n    }\n\n    seen.add(numbers[i])\n    uniq.push(numbers[i])\n\
    \  }\n\n  return uniq\n}\n", "  return numbers.filter((n, i) => numbers.indexOf(n)\
    \ == i)\n}\n", "    const unique: number[] = [];\n    let counter: number = 0;\n\
    \    numbers.forEach((number) => {\n        if (unique.indexOf(number) === -1)\
    \ {\n            counter++;\n            unique.push(number);\n        }\n   \
    \ });\n    return unique;\n}\n", "    const result: number[] = [];\n    let seen:\
    \ number[] = [];\n    for (let i = 0; i < numbers.length; i++) {\n        if (!seen.includes(numbers[i]))\
    \ {\n            seen.push(numbers[i]);\n            result.push(numbers[i]);\n\
    \        }\n    }\n    return result;\n}\n", "    const unique = new Set(numbers);\n\
    \    return [...unique];\n}\n</code>\n<|/ a |>\n<| a tags=javascript,arrays |>\n\
    You can use reduce() to achieve the results you want. Here is how you do it.\n\
    <code>\nconst removeDuplicates = (arr) => {\n    return arr.reduce((acc, val)\
    \ => {\n        if (acc.indexOf(val) !== -1) {\n            return acc\n     \
    \   } else {\n            return acc.concat(val)\n        }\n    }, []);\n};\n\
    \nconst arr = [1, 1, 2, 1, 2, 4, 5];\nconsole.log(removeDuplicates(arr));\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nIt's worth noting that the OP stated that they wanted\
    \ it to return `[1, 2]` and not `[1, 3, 2]`\n<|/ c |>\n<| c |>\nThank you, I missed\
    \ that one. Updated my answer accordingly.\n<|/ c |>\n<| a tags=javascript,arrays\
    \ |>\nYou could take a Set and check with a set for the same values.\n\n<code>\n\
    const\n    removeDuplicates = (array) => array.reduce((r, v) => {\n        if\
    \ (!r.has(v)) r.add(v);\n        return r;\n    }, new Set);\n\nconsole.log(removeDuplicates([1,\
    \ 2, 3, 2, 4]));</code>\n<|/ a dscore=1 |>\n<| a tags=javascript,arrays |>\n<code>\n\
    var arr = [1, 1, 2, 1, 2, 4, 5];\n\narr = arr.filter(function(value, index, arr)\
    \ {\n    return arr.indexOf(value) === index;\n});\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding *why* and/or *how* this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| c |>\nThis is essentially the same thing as [the accepted\
    \ answer](https://stackoverflow.com/a/53804415/295783)\n<|/ c |>\n<| a tags=javascript,arrays\
    \ |>\nIf your goal is to remove the duplicate values, you can use a Set in combination\
    \ with the spread operator to create a new array without duplicates:\n<code>\n\
    const removeDuplicates = (arr) => [...new Set(arr)];\n</code>\nThe difference\
    \ between this approach and the others proposed so far is that this creates a\
    \ new Set object, instead of using indexOf to check if the value is in the array.\
    \ Although indexOf is faster (O(n)), this creates a new Set object every time,\
    \ and this might not be desirable for large arrays. Sets are very useful because\
    \ they do not allow duplicates, so you can simply do this:\n<code>\nconst uniqueArr\
    \ = new Set([1, 1, 2, 1, 2, 4, 5]);\n", "    const result: number[] = [];\n  \
    \  let index = 0;\n    for (const num of numbers) {\n        if (index === 0 ||\
    \ num === result[index - 1]) {\n            result[index++] = num;\n        }\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=typescript,javascript |>\n\
    <| c |>\nThis fails for `[0, 0, 0, 3]`\n<|/ c |>\n<| c |>\nYes, it fails. I've\
    \ edited my answer to add my solution based on your code.\n<|/ c |>\n<| c |>\n\
    What is `index`? You use it in the conditional before you set it\n<|/ c |>\n<|\
    \ a dscore=1 |>\nIn case you didn't find a pure functional solution yet, here's\
    \ a solution using reduce:\n\n<code>\nconst arr = [1, 2, 3, 4, 5, 2, 7, 8, 4,\
    \ 8];\n\nconst result = arr.reduce((acc, cur) => {\n  const last = acc.pop();\n\
    \  return last === cur ? acc : [...acc, cur];\n}, []);\n\nconsole.log(result);</code>\n\
    \nBasically, reduce is taking an accumulator which is an array, and is storing\
    \ the last item in the array in it. Then each iteration, it checks if the last\
    \ item in the accumulator is equal to the current item in the array. If it is,\
    \ the accumulator is kept unchanged, otherwise it is added to the accumulator\
    \ and returned.\n<|/ a tags=typescript,javascript |>\n<| a tags=typescript,javascript\
    \ |>\n<code>", "  const hash = {};\n  const unique_numbers: number[] = [];\n \
    \ for (let num of numbers) {\n    if (hash[num] == undefined) {\n      hash[num]\
    \ = 1;\n      unique_numbers.push(num);\n    }\n  }\n  return unique_numbers;\n\
    }\n", "  const res: number[] = [];\n  numbers.forEach((item) => {\n    const index\
    \ = res.indexOf(item);\n    if (index !== -1) res.splice(index, 1);\n  });\n \
    \ return res;\n}\n", "  const hash = {};\n  numbers.forEach(num => {\n    if (hash[num])\
    \ {\n      hash[num]++;\n    } else {\n      hash[num] = 1;\n    }\n  });\n  const\
    \ result = [];\n  Object.keys(hash).forEach(key => result.push(key));\n  return\
    \ result;\n}\n", "  const map: Map<number, boolean> = new Map<number, boolean>();\n\
    \  for (const i of numbers) {\n    const previous = map.get(i);\n    if (!previous)\
    \ {\n      map.set(i, true);\n    } else {\n      map.set(i, !previous);\n   \
    \ }\n  }\n  return Array.from(map.values());\n}\n", "  const lookup = new Map<number,\
    \ boolean>();\n  return numbers.filter(num => {\n    if (lookup.has(num)) {\n\
    \      return false;\n    } else {\n      lookup.set(num, true);\n      return\
    \ true;\n    }\n  });\n}\n", "    const set = new Set<number>();\n    for (let\
    \ num of numbers) {\n        if (set.has(num)) {\n            set.delete(num);\n\
    \        } else {\n            set.add(num);\n        }\n    }\n    return [...set];\n\
    }\n", "  return numbers.filter((val, index, self) => self.indexOf(val) === index)\n\
    }\n", "  const set = new Set<number>();\n  for (const n of numbers) {\n    if\
    \ (set.has(n)) {\n      set.delete(n);\n    } else {\n      set.add(n);\n    }\n\
    \  }\n  return Array.from(set);\n}\n", "  numbers = numbers.map(function (num)\
    \ {\n    return num;\n  });\n  var unique = [];\n  var hash = {};\n  numbers.forEach(function\
    \ (num) {\n    if (!hash[num]) {\n      unique.push(num);\n      hash[num] = true;\n\
    \    }\n  });\n  return unique;\n}\n</code>\n<|/ a tags=javascript dscore=3 |>\n\
    <| c |>\nThe hash approach will work in O(N) time. However, to do this in O(N)\
    \ space requires storing a set of seen elements. But this requires O(N) space\
    \ to store the set.\n<|/ c |>\n<| c |>\nYou say \"This requires O(N) space to\
    \ store the set\". But you haven't said anything about how O(N) space is managed.\n\
    <|/ c |>\n<| c |>\nHashing is O(1), space is O(1). Thus the total space is O(N).\n\
    <|/ c |>\n<| c |>\nTo clarify a bit, Hashing requires a data structure to store\
    \ the seen elements. The set is simply a data structure for storing the elements\
    \ that are not yet in the seen set.\n<|/ c |>\n<| a tags=javascript |>\nYou can\
    \ filter them out.\n\n<code>\nvar numbers = [1, 4, 4, 4, 8, 2, 2, 3, 8];\nvar\
    \ unique = numbers.filter(function(x) { return !this.includes(x) }.bind(numbers));\n\
    console.log(unique);</code>\n<|/ a dscore=2 |>\n<| c |>\nThis does work, however\
    \ it does not work in IE and does not work in Safari.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  let uniques: number[] = [];\n  let numbers_set: Set<number>\
    \ = new Set();\n\n  numbers.forEach((number) => {\n    numbers_set.add(number);\n\
    \  });\n\n  for (let number of numbers_set) {\n    if (uniques.indexOf(number)\
    \ === -1) uniques.push(number);\n  }\n\n  return uniques;\n}\n", "    const output:\
    \ number[] = [];\n\n    const seen = new Set<number>();\n\n    for(const num of\
    \ numbers) {\n        if(seen.has(num)) {\n            continue;\n        }\n\n\
    \        seen.add(num);\n        output.push(num);\n    }\n\n    return output;\n\
    }\n", "  let map = new Map();\n  numbers.forEach(x => map.set(x, 1));\n  const\
    \ uniqueNumbers = [...map];\n  return uniqueNumbers.keys();\n}\n", "  numbers\
    \ = numbers.filter(function (elem, index, array) {\n    return index === array.indexOf(elem);\n\
    \  });\n  return numbers;\n}\n", "  const result: number[] = [];\n  const seen:\
    \ Set<number> = new Set();\n  numbers.forEach((num: number) => {\n    if (seen.has(num))\
    \ {\n      return;\n    }\n    seen.add(num);\n    result.push(num);\n  });\n\
    \  return result;\n}\n", "  const unique = {};\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    const number = numbers[i];\n    if (unique[number]) {\n      continue;\n\
    \    }\n    unique[number] = true;\n    numbers[i] = number;\n  }\n  return numbers;\n\
    }\n", "    const result = [];\n    numbers.forEach(number => {\n        if (result.indexOf(number)\
    \ === -1) {\n            result.push(number);\n        }\n    });\n    return\
    \ result;\n}\n", "  let result = [];\n  let seen = new Set();\n  for (let i =\
    \ 0; i < numbers.length; i++) {\n    if (seen.has(numbers[i])) {\n      continue;\n\
    \    }\n    seen.add(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return\
    \ result;\n}\n", "  const uniqueNumbers = numbers.reduce((uniqueNumbers, number)\
    \ => {\n    if (uniqueNumbers.indexOf(number) === -1) {\n      uniqueNumbers.push(number);\n\
    \    }\n    return uniqueNumbers;\n  }, []);\n  return uniqueNumbers;\n}\n", " \
    \ const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let count\
    \ = 0;\n    const num = numbers[i];\n    result.push(num);\n    for (let j = 0;\
    \ j < result.length; j++) {\n      if (num === result[j]) {\n        count++;\n\
    \      }\n    }\n    if (count > 1) {\n      numbers.splice(i, 1);\n      i--;\n\
    \    }\n  }\n  return result;\n}\n", "\tconst unique: number[] = new Array(numbers.length);\n\
    \tfor (let i = 0; i < numbers.length; i++) {\n\t\tif (unique.indexOf(numbers[i])\
    \ < 0) {\n\t\t\tunique[i] = numbers[i];\n\t\t}\n\t}\n\treturn unique;\n}\n", " \
    \ const output = [];\n  numbers[0] = 0; //0 is always included\n  for (let i =\
    \ 1; i < numbers.length; i++) {\n    if (numbers[i] === numbers[i - 1]) {\n  \
    \    continue;\n    }\n    output.push(numbers[i]);\n  }\n  return output;\n}\n",
  "  const map: Map<number, number> = new Map();\n  for (let i = 0; i < numbers.length;\
    \ ++i) {\n    const curr = map.get(numbers[i]);\n    if (curr === undefined) {\n\
    \      map.set(numbers[i], 1);\n    } else {\n      map.set(numbers[i], 1 + curr);\n\
    \    }\n  }\n  const result: number[] = [];\n  for (const [k, v] of map) {\n \
    \   if (v === 1) {\n      result.push(k);\n    }\n  }\n  return result;\n}\n",
  "    const uniqueNumbers: number[] = [];\n    const numbersMap: { [key: number]:\
    \ number } = {};\n    numbers.map((n) => {\n        numbersMap[n] = n;\n    });\n\
    \    numbers.filter((n) => {\n        if (numbersMap.hasOwnProperty(n)) {\n  \
    \          delete numbersMap[n];\n            return true;\n        }\n      \
    \  return false;\n    }).map((n) => {\n        uniqueNumbers.push(n);\n    });\n\
    \    return uniqueNumbers;\n}\n</code>\n<|/ a tags=javascript,sorting |>\n<| a\
    \ dscore=0 |>\n<code>\nvar numbers = [1,1,3,4,5,1,4];\nvar unique = [];\nfor(var\
    \ i=0;i<numbers.length;i++){\n  for(var j=0;j<unique.length;j++){\n    if(numbers[i]\
    \ == unique[j]){\n      unique.splice(j,1);\n    }\n  }\n}\n</code>\n<|/ a tags=javascript,sorting\
    \ |>\n<| a tags=javascript,sorting |>\n<code>", "    let sorted = numbers.sort((a,b)=>a-b)\n\
    \    let index = -1;\n    let result: number[] = []\n    for (let i = 0; i < sorted.length;\
    \ i++) {\n        while(index != sorted.length-1 && sorted[index] == sorted[index+1]){\n\
    \            index++\n        }\n        result[index] = sorted[i]\n        index++\n\
    \    }\n    return result\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nIn case the\
    \ array has numbers with decimal places below 10 you can also use something like\
    \ this\n<code>\npublic static int removeDuplicates(int[] arr)\n{\n    HashSet<Integer>\
    \ set = new HashSet<Integer>();\n    for (int a : arr) {\n        if(set.contains(a))\
    \ {\n            int val = Math.abs(a - set.size());\n            int j;\n   \
    \         for (j = set.size(); j > val; j--) {\n                set.delete(j);\n\
    \            }\n        } else {\n            set.add(a);\n        }\n    }\n\
    \    return (int) set.size();\n}\n</code>\n<|/ a tags=arrays,java dscore=1 |>\n\
    <| a |>\nThis code will remove all duplicate and same numbers in an array:\n<code>\n\
    int [] numbers = {1,2,3,4,3,5,4,3,1,2,5,7,8,9,4,2,5,6};\nArrayList<Integer> arr\
    \ = new ArrayList<Integer>();\n\nfor (int i = 0; i < numbers.length; i++) {\n\
    \    if (arr.contains(numbers[i])) {\n        System.out.println(\"duplicate\"\
    );\n    } else {\n        arr.add(numbers[i]);\n    }\n}\n\nfor (int i = 0; i\
    \ < arr.size(); i++) {\n    System.out.println(arr.get(i));\n}\n</code>\n<|/ a\
    \ dscore=1 tags=arrays,java |>\n<| c |>\nThe question is about Java and the array\
    \ is Java specific, so this answer probably shouldn't have been upvoted - although\
    \ it might help a future reader to find a way to do this in Java that he may not\
    \ know about.\n<|/ c |>\n<| c |>\ni did my best to help him, he can use ArrayLists\n\
    <|/ c |>\n<| a |>\n<code>\nimport java.util.Arrays;\n\npublic class RemoveDuplicate\
    \ {\npublic static void main(String args[]){\n    int[] array = {1,2,3,4,5,6,4,3,7,8,2,9,3,7,3};\n\
    \    System.out.println(Arrays.toString(array));\n    removeDuplicate(array);\n\
    \    System.out.println(Arrays.toString(array));\n}\npublic static void removeDuplicates(int\
    \ array[]){\n    boolean isDuplicate = false;\n    int size = array.length;\n\
    \    int i=0;\n    int j=0;\n    while(i < size-1){\n        isDuplicate = false;\n\
    \        j=0;\n        while(j < size && array[i] == array[j])", "    // Sort\
    \ the array first so it's in numerical order.\n    const sorted = numbers.sort((a,\
    \ b) => a - b);\n\n    // Remove duplicates.\n    const filtered = sorted.filter((element,\
    \ index, array) => index === array.indexOf(element));\n\n    // Remove unnecessary\
    \ leading 0.\n    return filtered.map((number, index, array) => {\n        if\
    \ (index !== 0) return number;\n    });\n}\n", "    var output: number[] = new\
    \ Array(0);\n    for (var i = 0; i < numbers.length; i++) {\n        if (output.indexOf(numbers[i])\
    \ === -1) {\n            output.push(numbers[i]);\n        }\n    }\n    return\
    \ output;\n}\n</code>\n<|/ a |>\n<| a |>\nI used the code below to remove duplicates\
    \ from a list of items in a multidimensional array of strings in C#. I hope this\
    \ helps.\n<code>\npublic string RemoveDuplicatesFromMultiDimArray(string[,] multiDimArray)\n\
    {\n    StringBuilder sb = new StringBuilder();\n    foreach (string s in multiDimArray)\n\
    \    {\n        if (sb.Length > 0)\n            sb.Append(\",\");\n        sb.Append(s);\n\
    \    }\n    return sb.ToString();\n}\n</code>\n<|/ a dscore=3 tags=arrays,duplicates,c#\
    \ |>\n<| a dscore=2 |>\nMy solution is simply to loop through the array and build\
    \ a string with all the elements separated by commas.\n<code>\nstring[] nums =\
    \ new string[] { \"1\", \"2\", \"3\", \"1\", \"5\", \"7\" };\nstring str = string.Empty;\n\
    foreach(string s in nums)\n{\n    if(!string.IsNullOrEmpty(str))\n        str\
    \ += \",\";\n    str += s;\n}\n</code>\n<|/ a tags=arrays,duplicates,c# |>\n<|\
    \ a dscore=2 |>\n<code>\n public static string[] RemoveDuplicates(string[] array)\n\
    \    {\n        HashSet<string> remove = new HashSet<string>();\n        for (int\
    \ i = 0; i < array.Length; i++)\n        {\n            string str = array[i];\n\
    \            if (remove.Contains(str))\n            {\n                Array.Resize(ref\
    \ array, array.Length - 1);\n                remove.Remove(str);\n           \
    \ }\n            else\n            {\n                remove.Add(str);\n     \
    \       }\n        }\n        return array.ToArray();\n    }\n</code>\n<|/ a tags=arrays,duplicates,c#\
    \ |>\n<| a dscore=2 |>\nHere is a short and sweet solution:\n<code>\nprivate static\
    \ IEnumerable<T> RemoveDuplicates<T>(IEnumerable<T> collection)\n{\n    var seenItems\
    \ = new HashSet<T>();\n\n    foreach (T item in collection)\n    {\n        if\
    \ (!seenItems.Add(item))\n        {\n            yield return item;\n        }\n\
    \    }\n}\n</code>\nIf you need to remove duplicates in a multidimensional array\
    \ you just have to call it like:\n<code>\nvar removed = RemoveDuplicates<string[,]>(myArray);\n\
    </code>\n<|/ a tags=arrays,duplicates,c# |>\n<| a tags=arrays,duplicates,c# |>\n\
    This ", "    let result = new Array<number>();\n    let index = 0;\n    let count\
    \ = new Array<number>(); // count of already seen numbers\n    for (let num of\
    \ numbers) {\n        if (!count.includes(num)) {\n            result[index] =\
    \ num;\n            count[index] = 1;\n            index++;\n        }\n    }\n\
    \    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nPlease add an explanation\
    \ to your answer\n<|/ c |>\n<| a dscore=2 |>\nHere's my solution:\n\n<code>\n\
    let input = [1, 1, 2, 2, 3, 3, 4, 4, 4];\n", "  const output: number[] = [];\n\
    \  for (let num of numbers) {\n    if (output.indexOf(num) === -1) {\n      output.push(num);\n\
    \    }\n  }\n  return output;\n}\n", "    const uniques: number[] = [];\n    const\
    \ result: number[] = [];\n\n    for (const num of numbers) {\n        if (uniques.indexOf(num)\
    \ === -1) {\n            uniques.push(num);\n            result.push(num);\n \
    \       }\n    }\n\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    `// From an array of integers, remove all elements that occur more than once.`\
    \ - this is definitely not a task that should be solved by hand. Not that this\
    \ isn't a good question for SO, but I think you need to explain your algorithm\
    \ *and* point out that it is O(n) - so it's not really a *practical* solution.\n\
    <|/ c |>\n<| c |>\nIt's definitely not an obvious answer to a beginner's question.\
    \ I guess I'd like to see a more practical solution or at least some explanation\
    \ of what it does. I added a comment to indicate how I think the algorithm works.\n\
    <|/ c |>\n<| a |>\nIn case you have an array of strings you can use following\
    \ solution:\n<code>\nlet arr = [\n  ...new Set(arr),\n]\n</code>\n<|/ a tags=typescript,arrays,javascript\
    \ dscore=1 |>\n<| a |>\nYou can use filter to do that easily:\n\n<code>\nconst\
    \ arr = [1,2,3,2,4]\nconst result = arr.filter((item, index) => arr.indexOf(item)\
    \ === index)\nconsole.log(result)</code>\n<|/ a dscore=0 tags=typescript,arrays,javascript\
    \ |>\n<| c |>\nThe OP specifically said \"keep order of elements left the same\
    \ as in the input.\"\n<|/ c |>\n<| c |>\nYeah I just realized that after seeing\
    \ your answer. Thanks.\n<|/ c |>\n<| c |>\nIf it is just for fun you can also\
    \ use a for loop with push and indexOf :)\n<|/ c |>\n<| a dscore=0 |>\nYou can\
    \ use filter and indexOf:\n\n<code>\nconst array = [1,2,3,2,4];\nconst unique\
    \ = array.filter((n, i) => array.indexOf(n) === i);\n\nconsole.log(unique);</code>\n\
    <|/ a tags=typescript,arrays,javascript |>\n<| a dscore=0 |>\nyou can use  filter\
    \ method and indexOf method to achieve what you want.\n<code>\nlet input = [1,2,3,2,2,3,4,5];\n\
    let output = input.filter( (x,i,arr) => {\n    return arr.indexOf(x)===i;\n})\n\
    </code>\noutput will be [1,3]\n<|/ a tags=typescript,arrays,javascript |>\n<|\
    \ a |>\nThe simplest way to remove duplicates from an array is using Set\n\n",
  "  const counts = new Map();\n  const res = [];\n  numbers.forEach(n => {\n    if\
    \ (!counts.has(n)) {\n      counts.set(n, 1);\n      res.push(n);\n    }\n  });\n\
    \  return res;\n}\n", "\treturn numbers.filter((e, i, arr) => arr.indexOf(e) ===\
    \ i);\n}\n", "  const output = new Set(numbers);\n  const input = new Set(output);\n\
    \  const numbers_as_strings = Array.from(output);\n\n  return input.size === numbers_as_strings.length\
    \ ? numbers_as_strings : numbers_as_strings.sort();\n}\n", "    const output =\
    \ new Array(numbers.length);\n    const map: Map<number, boolean> = new Map();\n\
    \    const outputMap = new Map();\n\n    for (const num of numbers) {\n      \
    \  if (!map.has(num)) {\n            output[output.length] = num;\n          \
    \  map.set(num, true);\n        } else if (outputMap.has(num)) {\n           \
    \ output[output.length] = num;\n        } else {\n            outputMap.set(num,\
    \ true);\n        }\n    }\n\n    return output;\n}\n", "    var unique: any[]\
    \ = [];\n    numbers.forEach(function(val) {\n        if (unique.indexOf(val)\
    \ === -1) {\n            unique.push(val);\n        }\n    });\n    return unique;\n\
    }\n</code>\n<|/ a tags=javascript,algorithm,sorting |>\n<| c |>\nYou don't need\
    \ to do that - you can just do a Set if you want an array with the unique values.\n\
    <|/ c |>\n<| c |>\nI don't get how this compares with the other answers.\n<|/\
    \ c |>\n<| a |>\nYou can use Set. It is a unordered collection that contain unique\
    \ elements.\n<code>\nvar nums = [1, 2, 3, 2, 3, 4];\nvar set = new Set(nums);",
  "\tlet result: number[] = [];\n\tlet seen: number[] = [];\n\n\tfor (const n of numbers)\
    \ {\n\t\tif (!seen.includes(n)) {\n\t\t\tresult.push(n);\n\t\t\tseen.push(n);\n\
    \t\t}\n\t}\n\n\treturn result;\n}\n", "  const result = [];\n  for (let i = 0;\
    \ i < numbers.length; i++) {\n    const element = numbers[i];\n    if (result.indexOf(element)\
    \ > -1) {\n      continue;\n    }\n    result.push(element);\n  }\n  return result;\n\
    }\n", "  numbers = numbers.filter(n => numbers.indexOf(n) === numbers.lastIndexOf(n));\n\
    \  return numbers;\n}\n", "    const map = new Map<number, number>();\n    numbers.forEach((num)\
    \ => {\n        if (map.has(num)) {\n            map.set(num, map.get(num) + 1);\n\
    \        } else {\n            map.set(num, 1);\n        }\n    });\n    const\
    \ result = [];\n    map.forEach((num, count) => {\n        if (count > 1) {\n\
    \            result.push(num);\n        }\n    });\n    return result;\n}\n",
  "\tconst sorted_numbers = numbers.sort((a: number, b: number) => {\n\t\treturn a\
    \ - b;\n\t});\n\n\tlet unique = sorted_numbers.filter(function (elem, pos) {\n\
    \t\treturn sorted_numbers.indexOf(elem) == pos;\n\t});\n\n\treturn sorted_numbers.concat(unique);\n\
    }\n", "  const unique_numbers = [...new Set(numbers)];\n  return unique_numbers.sort((a,\
    \ b) => a - b);\n}\n", "    const dupes: number[] = [];\n    for (let i = 0; i\
    \ < numbers.length; i++) {\n        if (dupes.indexOf(numbers[i]) !== -1) {\n\
    \            continue;\n        }\n        dupes.push(numbers[i]);\n    }\n  \
    \  return dupes;\n}", "    var output: number[] = [];\n    var seen: number[]\
    \ = [];\n    for (var i=0; i < numbers.length; i++) {\n        var val = numbers[i];\n\
    \        if (seen.indexOf(val) >= 0) {\n            continue;\n        }\n   \
    \     seen.push(val);\n        output.push(val);\n    }\n    return output;\n\
    }\n</code>\nThis should work for any number of integers within the given range\
    \ and any order within the array. It also ensures the order is the same as it\
    \ appears in the original array.\n<|/ a dscore=2 |>\n<| c |>\nYou don't need a\
    \ `for` loop to do this.\n<|/ c |>\n<| a |>\n<code>", "  const countMap = new\
    \ Map<number, number>();\n  for (let i = 0; i < numbers.length; i++) {\n    let\
    \ number = numbers[i];\n    if (countMap.has(number)) {\n      countMap.set(number,\
    \ countMap.get(number) + 1);\n    } else {\n      countMap.set(number, 1);\n \
    \   }\n  }\n\n  const uniqueNumbers: number[] = [];\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    if (countMap.get(numbers[i]) === 1) {\n      uniqueNumbers.push(numbers[i]);\n\
    \      countMap.delete(numbers[i]);\n    }\n  }\n  return uniqueNumbers;\n}\n",
  "  const map = new Map();\n  numbers.forEach((num) => {\n    const key = num;\n\
    \    if (!map.has(key)) {\n      map.set(key, 1);\n    } else {\n      map.set(key,\
    \ map.get(key) + 1);\n    }\n  });\n  return Array.from(map.entries()).filter(([,\
    \ count]) => count > 1).map(([, count]) => count);\n}\n", "    let unique_numbers:\
    \ number[] = [];\n    unique_numbers.push(numbers[0]);\n    for (let i = 1; i\
    \ < numbers.length; i++) {\n        if (unique_numbers.indexOf(numbers[i]) !==\
    \ -1) {\n            continue;\n        }\n        unique_numbers.push(numbers[i]);\n\
    \    }\n    return unique_numbers;\n}\n", "    const new_array: number[] = [];\n\
    \    const map = new Map<number, number>();\n\n    for (let i = 0; i < numbers.length;\
    \ i++) {\n        const number = numbers[i];\n\n        // If the key exists,\
    \ increment, otherwise create.\n        const count = map.get(number);\n\n   \
    \     // If count doesn't exist, add element to array.\n        if (count ===\
    \ undefined) {\n            map.set(number, 1);\n            new_array.push(number);\n\
    \        } else {\n            // If count exists, update value.\n           \
    \ count++;\n\n            map.set(number, count);\n        }\n    }\n\n    //\
    \ Return the array, order same as input.\n    return new_array;\n}\n", "  const\
    \ result: number[] = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const\
    \ number = numbers[i];\n    if (result.indexOf(number) === -1) {\n      result.push(number);\n\
    \    }\n  }\n  return result;\n}\n", "  const dupes = new Set<number>();\n  for\
    \ (let num of numbers) {\n    if (!dupes.has(num)) {\n      dupes.add(num);\n\
    \    }\n  }\n  return [...dupes.values()];\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nHere is a solution which uses the filter function of JS and ES6:\n<code>\n\
    var a = [1, 2, 3, 2, 4];\na = a.filter(function(i) {\n  return a.indexOf(i) ===\
    \ i;\n});\n\nconsole.log(a);\n</code>\n<|/ a tags=javascript,arrays,duplicates,ecmascript-6\
    \ |>\n<| a |>\nAnother approach:\n<code>", "    const output: number[] = [];\n\
    \    let counter = 0;\n    for (const num of numbers) {\n        if (numbers.indexOf(num)\
    \ !== counter) {\n            output.push(num);\n            counter++;\n    \
    \    }\n    }\n    return output;\n}", "  const output: number[] = [];\n  let\
    \ unique = [...new Set(numbers)];\n  for (let i = 0; i < numbers.length; i++)\
    \ {\n    if (unique.indexOf(numbers[i]) === -1) output.push(numbers[i]);\n  }\n\
    \  return output;\n}\n", "  const map: Map<number, number> = new Map();\n  for\
    \ (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n   \
    \ const index = map.get(number);\n    if (index === undefined) {\n      map.set(number,\
    \ i);\n    } else {\n      map.set(number, index + 1);\n    }\n  }\n  const result:\
    \ number[] = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const number\
    \ = numbers[i];\n    const index = map.get(number);\n    if (index !== undefined)\
    \ {\n      result.push(number);\n    }\n  }\n  return result;\n}\n", "    const\
    \ hash: {[number]: number} = {};\n    const unique: number[] = [];\n\n    numbers.forEach(n\
    \ => {\n        if (!hash[n]) {\n            hash[n] = 1;\n            unique.push(n);\n\
    \        } else {\n            hash[n]++;\n        }\n    });\n\n    return unique;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nWhy not `const unique = Object.keys(new Set(numbers)).filter((key)\
    \ => numbers[key] > 1);`?\n<|/ c |>\n<| c |>\nI think this solution is quite elegant\
    \ indeed. Especially since it keeps the original order of the `numbers`, which\
    \ is what OP wanted.\n<|/ c |>\n<| c |>\nThis solution has problems with duplicates,\
    \ such as [1, 5, 3, 2]. In the output it would be: [1, 5, 3]\n<|/ c |>\n<| c |>\n\
    the second `filter` should be `unique.filter((n) => numbers[n] > 1);`\n<|/ c |>\n\
    <| c |>\nIf you don't care about ordering you can just use `Array.prototype.reduce`\
    \ on the array `const unique = numbers.reduce((acc, val) => {\n    acc[val] =\
    \ (acc[val] || 0) + 1;\n    return acc;\n  }, {});`\n<|/ c |>\n<| a |>\nThis is\
    \ a javascript implementation based on this answer that has been updated for typescript\
    \ 2.6 and above. This removes duplicate elements without sorting.\n\n<code>\n\
    var unique = ([...new Set(['A','A','B','C','C','C'])]).filter((n) => n !== 'C');\n\
    console.log(unique);</code>\n<|/ a tags=javascript,duplicates,arrays,string dscore=5\
    \ |>\n<| c |>\nThis is the only answer that doesn't involve sorting - in other\
    \ words, this approach is as simple as just using Set and filter\n<|/ c |>\n<|\
    \ c |>\nI like this one because it doesn't require any additional packages and\
    \ you can get the unique elements by simply calling `Array.from(set)`. Simpler\
    \ than the other solutions IMO.\n<|/ c |>\n<| c |>\nYep, very simple and straight\
    \ forward, thanks!\n<|/ c |>\n<| c |>\nI love this solution! However be careful\
    \ when using this with dates because they get sorted as they appear in the source\
    \ array. Make sure to convert them to strings or use another solution like `[...new\
    \ Set(array.values())]`\n<|/ c |>\n<| c |>\nIt works great with the strings, but\
    \ not with the dates. I tried to convert the ", "    return numbers.filter((value,\
    \ index) => {\n        return numbers.indexOf(value) === index;\n    });\n}\n\
    </code>\nThis can be improved upon as demonstrated in the following example (taken\
    \ from here)\n<code>", "  const results: number[] = [];\n  const seen = new Set<number>();\n\
    \n  for (let i = 0; i < numbers.length; i++) {\n    const num = numbers[i];\n\n\
    \    if (seen.has(num)) {\n      continue;\n    }\n\n    seen.add(num);\n    results.push(num);\n\
    \  }\n\n  return results;\n}\n", "  const [result, seen] = numbers.reduce((result,\
    \ item) => {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n\
    \    }\n    const index = result.indexOf(item);\n    if (index !== -1) {\n   \
    \   result[index] = item;\n    }\n    return result;\n  }, []);\n  return result;\n\
    }\n", "  const nodupes = [];\n  const duplicates = [];\n  for (let i = 1; i <\
    \ numbers.length; i++) {\n    if (numbers[i] === numbers[i - 1]) {\n      duplicates.push(numbers[i]);\n\
    \    } else {\n      nodupes.push(numbers[i]);\n    }\n  }\n  return nodupes.concat(duplicates);\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
