name: HumanEval_58_common
language: ts
prompt: "//Return sorted unique common elements for two arrays.\n// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n// [2, 3]\nfunction common(l1: number[], l2: number[]): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = common;\n  assert.deepEqual(candidate([1, 4, 3, 34,\
  \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5,\
  \ 3, 2, 8], [3, 2]),[2, 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2,\
  \ 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);\n}\n\ntest();"
completions: ["  let m = [...new Set(l1)].sort();\n  let n = [...new Set(l2)].sort();\n\
    \  let result: number[] = [];\n  for (let i = 0; i < m.length; i++) {\n    for\
    \ (let j = 0; j < n.length; j++) {\n      if (m[i] === n[j]) {\n        result.push(m[i]);\n\
    \        break;\n      }\n    }\n  }\n  return result;\n}\n", "  const map = new\
    \ Map();\n  const result = [];\n  l1\n    .map(a => {\n      l2\n        .map(b\
    \ => {\n          if (map.has(a) && map.has(b)) {\n            map.set(a, b);\n\
    \          } else if (map.has(a)) {\n            result.push(a);\n           \
    \ map.set(a, b);\n          } else if (map.has(b)) {\n            result.push(b);\n\
    \            map.set(a, b);\n          }\n        });\n    });\n\n  map.forEach((v,\
    \ k) => result.push(k));\n\n  return result;\n}\n", "    const lc = new Set<number>();\n\
    \    const [lr, l2] = l1.length, l2.length ? l2.slice(0, l1) : l1;\n    for (let\
    \ i = 0, r = 0; i < lc; i++) {\n        if (l2.includes(l1) || l2.includes(lc))\
    \ {\n            lc.delete(l1[i]);\n        }\n        else {\n            lc.add(l1[i]);\n\
    \        }\n    }\n    lc.clear();\n    for (let i = 0, r = 0; i < lc; i++) {\n\
    \        if (l2.includes(l1) || l2.includes(lc)) {\n            lc.delete(l2[i]);\n\
    \        }\n        else {\n            lc.add(l2[i]);\n        }\n    }\n   \
    \ return lc;\n}\n\nconst has = (obj, key) => Object.prototype.hasOwnProperty.call(obj,\
    \ key);\nconst isArray = Array.isArray || ((obj) => obj && obj.constructor ===\
    \ Array && obj !== Array.prototype);\n", "\tconst result = new Set<number>();\n\
    \tfor (let item of l1) {\n\t\tif (l2.indexOf(item) >= 0) result.add(item);\n\t\
    }\n\treturn Array.from(result);\n}\n", "  if (l1.length !== l2.length) return\
    \ [l1, l2];\n\n  let set1 = new Set(l1);\n  let set2 = new Set(l2);\n\n  return\
    \ [...set1, ...set2]\n    .filter(item => !set2.has(item))\n    .sort()\n    .reduce((acc,\
    \ item) => ({ ...acc, [item]: 1 }), {});\n}\n", "  l1 = l1 || [];\n  l2 = l2 ||\
    \ [];\n  const result = [],\n    i = 0,\n    len = Math.min(l1.length, l2.length),\n\
    \    l,\n    item;\n\n  for (; i < len; i++) {\n    item = l1[i];\n    if (~CommonUtil.indexOf(l2,\
    \ item)) {\n      result.push(item);\n    }\n  }\n  return result;\n}\n", "  \
    \  if (l1 == null) {\n        return l2;\n    } else if (l2 == null) {\n     \
    \   return l1;\n    }\n    const llen = l1.length;\n    const rlen = l2.length;\n\
    \    if (llen > rlen) {\n        return l2;\n    }\n    let i = 0;\n    for (;\
    \ i < llen && i < rlen; i++) {\n        if (l1[i] === l2[i]) {\n            continue;\n\
    \        }\n        if (l1[i] < l2[i]) {\n            return l1;\n        } else\
    \ {\n            return l2;\n        }\n    }\n    return l1;\n}", "  if (l1.length\
    \ !== l2.length) return null\n  let j = 0\n  let i = 0\n  while (i < l1.length)\
    \ {\n    while (i + 1 < l1.length && l1[i - 1] === l2[j]) i++\n    while (i +\
    \ 1 < l1.length && l1[i - 1] === l2[i]) i++\n    if (i === l1.length) return [l1[j]]\n\
    \    i++\n    j++\n  }\n  return null\n}\n</code>\n<|/ a tags=arrays,algorithm\
    \ |>\n<| c |>\nI like this solution, but it fails on [1,1,1] and [1,2,3].  Should\
    \ return [1,1] but returns [2,3]\n<|/ c |>\n<| c |>\n- Good catch, I didn't notice\
    \ that `[1,1,1]` and `[1,2,3]` were different cases.  I've updated my answer to\
    \ account for that case.\n<|/ c |>\n<| a dscore=0 |>\nI used a variation of solution\
    \ but with some optimizations.\n<code>", "  return uniqueSort(l1, l2, (l1, l2,\
    \ i) => {\n    if (l1.length < l2.length) {\n      return -1;\n    }\n    if (l1.length\
    \ > l2.length) {\n      return 1;\n    }\n    return sortCompareCompare(common);\n\
    \  });\n}\n", "  let c: number[] = [];\n  l2.forEach((x) => {\n    const index\
    \ = l1.indexOf(x);\n    if (index >= 0) {\n      c.push(l1.splice(index, 1)[0]);\n\
    \    }\n  });\n  l1.forEach((x) => {\n    const index = l2.indexOf(x);\n    if\
    \ (index >= 0) {\n      c.push(l2.splice(index, 1)[0]);\n    }\n  });\n  return\
    \ c;\n}\n", "  var common: number[] = [];\n  for (var i = 0; i < l1.length; i++)\
    \ {\n    for (var j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j])\n \
    \       common.push(l1[i]);\n    }\n  }\n  return common;\n}\n", "  const o1:\
    \ any[] = [];\n  const o2: any[] = [];\n  let minLen = Math.min(l1.length, l2.length);\n\
    \  l1.forEach((val, i) => {\n    if (l2[i] === val) {\n      o2.push(val);\n \
    \   } else {\n      if (o1[i] === undefined) {\n        o1[i] = val;\n      }\
    \ else {\n        o1.push(o1[i]);\n      }\n    }\n  });\n  l2.forEach((val, i)\
    \ => {\n    if (l1.length >= minLen && l1[i] === val) {\n      o1.push(val);\n\
    \    } else {\n      if (o2[i] === undefined) {\n        o2[i] = val;\n      }\
    \ else {\n        o2.push(o2[i]);\n      }\n    }\n  });\n  o1.sort();\n  o2.sort();\n\
    \  return o1.filter(Boolean).concat(o2.filter(Boolean));\n}\n", "  return commonIterator(l1,\
    \ l2, new Set());\n}\n", "  const result = [];\n  const len = Math.min(l1.length,\
    \ l2.length);\n  for (let i = 0; i < len; i++) {\n    if (l1[i] === l2[i]) {\n\
    \      result.push(l1[i]);\n    }\n  }\n  return result.sort();\n}\n", "  return\
    \ filter(cmp(l1, l2, (a, b) => a === b), unique(l1));\n}\n", "\tlet result = [];\n\
    \n\tfor (let index1 = 0; index1 < l1.length; index1++) {\n\t\tlet value1 = l1[index1];\n\
    \n\t\tfor (let index2 = 0; index2 < l2.length; index2++) {\n\t\t\tlet value2 =\
    \ l2[index2];\n\n\t\t\tif (value1 === value2) {\n\t\t\t\tresult.push(value1);\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n", "    const ret:\
    \ number[] = [];\n    for(let i1 = 0; i1 < l1.length; i1++) {\n        const val1:\
    \ number = l1[i1];\n        for(let i2 = 0; i2 < l2.length; i2++) {\n        \
    \    const val2: number = l2[i2];\n            if(val1 === val2) ret.push(val1);\n\
    \        }\n    }\n    return ret;\n}\n", "  let n1 = l1.length, n2 = l2.length;\n\
    \  let result: number[] = [];\n  let i1 = 0;\n  let i2 = 0;\n  let i3 = 0;\n \
    \ let k1 = 0;\n  let k2 = 0;\n  let k3 = 0;\n  while (i1 < n1) {\n    while (i2\
    \ < n2) {\n      while (i3 < n1) {\n        if (l1[i1] === l2[i2]) {\n       \
    \   k3++;\n          if (k3 < n1) {\n            i1++;\n          }\n        \
    \  break;\n        } else if (l2[i2] === l1[i3]) {\n          k2++;\n        \
    \  if (k2 < n2) {\n            i2++;\n          }\n          break;\n        }\
    \ else {\n          k1 = k2 = k3 = 0;\n        }\n        if (k1 > n2 - k2 + 1)\
    \ {\n          i3++;\n          k1 = k2 = k3 = 0;\n        }\n      }\n      if\
    \ (k2 > n2 - k2 + 1) {\n        i2++;\n        k2 = k3 = 0;\n      }\n      if\
    \ (k3 > n2 - k2 + 1) {\n        i1++;\n        k3 = k2 = 0;\n      }\n    }\n\
    \    if (i2 < n2) {\n      k2 = k3 = 0;\n      while (i3 < n1) {\n        if (l2[i2]\
    \ === l1[i3]) {\n          k1++;\n          if (k1 < n2) {\n            i3++;\n\
    \          }\n          break;\n        } else if (l1[i1] === l2[i3]) {\n    \
    \      k2++;\n          if (k2 < n1) {\n            i1++;\n          }\n     \
    \     break;\n        } else {\n          k1 = k2 = 0;\n        }\n        if\
    \ (k1 > n1 - k1 + 1) {\n          i3++;\n          k1 = k2 = 0;\n        }\n \
    \     }\n      if (k1 < n1 - k1 + 1) {\n        i1++;\n        k1 = k2 = 0;\n\
    \      }\n    }\n    if (i1 < n1) {\n      k1 = k2 = 0;\n      while (i3 < n2)\
    \ {\n        if (l1[i1] === l2[i3]) {\n          k1++;\n          if (k1 < n1)\
    \ {\n            i3++;\n          }\n          break;\n        } else if (l2[i2]\
    \ === l1[i3]) {\n          k2++;\n          if (k2 < n2) {\n            i2++;\n\
    \          }\n          break;\n        } else {\n          k1 = k2 = 0;\n   \
    \     }\n        if (k1 > n2 - k2 + 1) {\n          i3++;\n          k1 = k2 =\
    \ 0;\n        }\n      }\n      if (k1 < n2 - k2 + 1) {\n        i2++;\n     \
    \   k2 = k3 = 0;\n      }\n    }\n    result.push(l1[i1]);\n    if (i2 < n2) {\n\
    \      i1++;\n    } else {\n      i2++;\n    }\n  }\n  return result;\n}\n", " \
    \   var i: number, imax: number, j: number, jmax: number, common: number[], len1:\
    \ number[] = l1.length, len2: number[] = l2.length;\n    if (len1 === 0 || len2\
    \ === 0) {\n        return [];\n    }\n    imax = i1;\n    jmax = j1;\n    for\
    \ (i = len1 - 1; i >= 0; --i) {\n        for (j = len2 - 1; j >= 0; --j) {\n \
    \           if (l1[i] === l2[j]) {\n                if (i === len1 - 1 || j ===\
    \ len2 - 1) {\n                    common = l1.slice(i, j + 1);\n            \
    \        return common;\n                }\n                imax = i;\n      \
    \          jmax = j;\n            }\n        }\n    }\n    if (imax === i1 &&\
    \ jmax === j1) {\n        return [l1[0]];\n    }\n    if (imax === i1) {\n   \
    \     return [i1].concat(common);\n    }\n    if (jmax === j1) {\n        return\
    \ common;\n    }\n    return common.concat(l1.slice(imax, i1));\n}", "  var commonValues:\
    \ {key: string; value: number}[] = [];\n  var maxLength = Math.max(l1.length,\
    \ l2.length);\n\n  for (var i = 0; i < maxLength; i++) {\n    if (i < l1.length\
    \ && !l2.includes(l1[i])) {\n      commonValues.push({key: 'l1', value: l1[i]});\n\
    \    } else if (i < l2.length && !l1.includes(l2[i])) {\n      commonValues.push({key:\
    \ 'l2', value: l2[i]});\n    } else {\n      commonValues.push({key: '', value:\
    \ null});\n    }\n  }\n\n  commonValues = commonValues.sort((a, b) => {\n    return\
    \ a.value === b.value ? 0 : a.value > b.value ? 1 : -1;\n  });\n  var commonResult:\
    \ {key: string; value: number}[] = [];\n\n  for (var i = 0; i < commonValues.length;\
    \ i++) {\n    if (commonValues[i].key === '') {\n      commonResult.push(commonValues[i].value);\n\
    \    } else {\n      for (var j = 0; j < commonValues.length; j++) {\n       \
    \ if (commonValues[i].key === commonValues[j].key &&\n            commonValues[i].value\
    \ === commonValues[j].value) {\n          commonResult.push(commonValues[j].value);\n\
    \        }\n      }\n    }\n  }\n\n  return commonResult;\n}\n", "  const o1:\
    \ number[] = [], l: number[] = [];\n  l1.sort((a, b) => a - b);\n  l2.sort((a,\
    \ b) => a - b);\n  while (l1.length > 0) {\n    const l1 = l1.pop();\n    while\
    \ (l2.length > 0) {\n      const l2 = l2.pop();\n      if (l1 === l2) {\n    \
    \    l.push(l1);\n        l1.pop();\n        l2.pop();\n      } else if (l1 !==\
    \ l2) {\n        l1.push(l2);\n        l2.pop();\n      } else {\n        l1.push(l1);\n\
    \        l2.pop();\n      }\n    }\n  }\n  l.sort((a, b) => a - b);\n  return\
    \ l;\n}\n\nconst common = common([4, 3, 56, 73, 78, 56, 2], [89, 8, 10, 1, 2]);\n\
    console.log(common);\nconsole.log(common.reverse());\nconsole.log(common.reverse().slice(1));\n\
    console.log(common.reverse().slice(1).reverse());\nconsole.log(common.reverse().slice(1).reverse().reverse());</code>\n\
    <|/ a |>\n<| c |>\nThis approach also seems to work, thank you. But I chose the\
    \ other answer because of the time savings for large arrays.\n<|/ c |>\n<| c |>\n\
    The time savings are negligible in this case, because you are only sorting one\
    \ array. Sorting the other array is `O(nlog(n))`. If you sort both arrays at once\
    \ like this, you are still only sorting `O(nlog(n))`. The time savings will increase\
    \ when you have to sort two arrays in parallel.\n<|/ c |>\n<| c |>\nOk I see.\
    \ I thought both `sort` methods would end up doing the same amount of work.\n\
    <|/ c |>\n<| a |>\nHere is another solution using a single sort function and two\
    \ nested loops. \nThe only change I made is using two separate sort functions\
    \ instead of sorting them in the same function. \nThis makes the solution more\
    \ readable and easier to understand.\n\n<code>\nconst arr1 = [2, 8, 1, 6, 4, 3,\
    \ 56, 73, 78, 56, 2];\nconst arr2 = [89, 8, 10, 1, 2];\n", "  var l = Math.min(l1.length,\
    \ l2.length);\n  for (var i = 0; i < l; i++) {\n    if (l1[i] !== l2[i]) {\n \
    \     return l1[i] === l2[i] ? 0 : (l1[i] < l2[i] ? -1 : 1);\n    }\n  }\n  return\
    \ l1.length === l2.length ? l1.length - l2.length : NaN;\n}\n", "  var a = l1.slice(0,\
    \ l1.length);\n  var b = l2.slice(0, l2.length);\n  for (var i = 0; i < a.length;\
    \ i++) {\n    for (var j = 0; j < b.length; j++) {\n      if (a[i] === b[j]) {\n\
    \        a.splice(i, 1);\n        b.splice(j, 1);\n        i -= 1;\n        j\
    \ -= 1;\n      }\n    }\n  }\n  return a;\n}\n", "  return [...new Set(l1), ...new\
    \ Set(l2)];\n}\n", "  const result = []\n  for (let i1 = 0; i1 < l1.length; i1++)\
    \ {\n    let found = false\n    for (let i2 = 0; i2 < l2.length; i2++) {\n   \
    \   if (l1[i1] === l2[i2]) {\n        found = true\n        break\n      }\n \
    \   }\n    if (found) {\n      result.push(l1[i1])\n    }\n  }\n  return result\n\
    }\n", "  let ret: number[] = [];\n  for (let i = 0; i < Math.max(l1.length, l2.length);\
    \ ++i) {\n    if (i >= l1.length || i >= l2.length) break;\n    if (l1[i] ===\
    \ l2[i]) ret.push(l1[i]);\n  }\n  return ret;\n}\n", "    const result = new Set(l1);\n\
    \    for (let i = 0; i < l2.length; i++) {\n        if (result.has(l2[i])) {\n\
    \            delete result.delete(l2[i]);\n        }\n    }\n    return [...result];\n\
    }\n", "    var l = Math.min(l1.length, l2.length),\n        a = [],\n        b\
    \ = [];\n    while (l >= 0) {\n        a[l] = l1[l--];\n        b[l] = l2[l--];\n\
    \    }\n    while (true) {\n        while (true) {\n            var k = b.shift(),\
    \ v = a.pop(), c = !k;\n            if (0 === k || 0 === v || k > v) {\n     \
    \           a.push(k), b.push(v);\n                break;\n            }\n   \
    \     }\n        while (true) {\n            var k = a.shift(), v = b.shift();\n\
    \            if (0 === k || 0 === v || k > v) {\n                b.unshift(k),\
    \ a.unshift(v);\n                break;\n            }\n        }\n        if\
    \ (!a.length) break;\n        if (!b.length) break;\n    }\n    return a.reduce(function\
    \ (prev, curr, i) {\n        return Math.max(prev, curr);\n    }), b.reduce(function\
    \ (prev, curr, i) {\n        return Math.max(prev, curr);\n    });\n}\n\nvar MAX_SAFE_INTEGER\
    \ = 9007199254740991;\nvar EPSILON = Math.pow(2, -52);", "  const lc = new Set();\n\
    \  for (let i = 0; i < l1.length; ++i) {\n    lc.add(l1[i]);\n  }\n  for (let\
    \ i = 0; i < l2.length; ++i) {\n    lc.add(l2[i]);\n  }\n  return Array.from(lc);\n\
    }\n", "    const len1 = l1.length;\n    const len2 = l2.length;\n    if (len1\
    \ < len2) {\n        return [];\n    }\n    const results: number[] = [];\n  \
    \  for (let i = 0; i < len1; i++) {\n        for (let j = 0; j < len2; j++) {\n\
    \            if (l1[i] === l2[j]) {\n                results.push([l1[i], l2[j]]);\n\
    \            }\n        }\n    }\n    return results;\n}", "    var result: number[]\
    \ = [];\n    while (l1.length > 0 && l2.length > 0) {\n        if (l1[0] < l2[0])\
    \ {\n            l1.shift();\n        } else {\n            l2.shift();\n    \
    \    }\n    }\n    l1 = l1\n    while (l1.length > 0) {\n        result.push(l1.shift())\n\
    \    }\n    l2 = l2\n    while (l2.length > 0) {\n        result.push(l2.shift())\n\
    \    }\n    return result;\n}\n", "    const hashTable: { [index: number]: number\
    \ } = {};\n    let l1_count = 0, l2_count = 0;\n    for (const num of l1) hashTable[num]\
    \ = l1_count++;\n    for (const num of l2) hashTable[num] = l2_count++;\n    const\
    \ common = new Array();\n    const hashMap = Object.keys(hashTable).map((key)\
    \ => hashTable[key]);\n    for (const key of hashMap) {\n        if (common.length\
    \ == 0 || key == common[common.length - 1]) {\n            common.push(key);\n\
    \        } else {\n            for (let i = common.length - 1; i > 0; i--) {\n\
    \                if (key == common[i]) {\n                    common.splice(i,\
    \ 1);\n                    break;\n                }\n            }\n        }\n\
    \    }\n    return common;\n}", "  if (l1.length === 0) {\n    return l2;\n  }\n\
    \  if (l2.length === 0) {\n    return l1;\n  }\n  return l1.find((l: number) =>\
    \ l2.indexOf(l) !== -1);\n}\n", "    var ret = [];\n    var i1 = 0, i2 = 0;\n\
    \    var li1 = 0, li2 = 0;\n    while (li1 < l1.length && li2 < l2.length) {\n\
    \        if (l1[li1] < l2[li2]) {\n            ret[i1++] = l1[li1++];\n      \
    \  } else if (l1[li1] > l2[li2]) {\n            ret[i1++] = l2[li2++];\n     \
    \   } else {\n            ret[i1++] = l1[li1++];\n            ret[i2++] = l2[li2++];\n\
    \        }\n    }\n    while (li1 < l1.length) {\n        ret[i1++] = l1[li1++];\n\
    \    }\n    while (li2 < l2.length) {\n        ret[i2++] = l2[li2++];\n    }\n\
    \    return ret;\n}\n", "  var i1 = 0,\n    i2 = l1.length,\n    found = [],\n\
    \    element;\n  while (l2 && (i1 < l1 || i2 < l2)) {\n    element = (i2 < l2)\
    \ ? l2[i2++] : l1[i1++];\n    if (~found && element === ~found[found.length -\
    \ 1]) {\n      continue;\n    }\n    found = found.concat(element);\n  }\n  return\
    \ found;\n}\n", "    var l1 = new Set(l1);\n    var l2 = new Set(l2);\n\n    var\
    \ res: number[] = [];\n    var set1: Set<number> = l1;\n    var set2: Set<number>\
    \ = l2;\n\n    res[0] = set1.has(l2[0]) ? l2[0] : 0;\n    for (var i = 1; i <\
    \ set1.size; i++) {\n        if (set1.has(l1[i])) {\n            res.push(l1[i]);\n\
    \        } else {\n            res[i] = res[i - 1];\n        }\n    }\n    return\
    \ res;\n}\n", "    var ret = [];\n    for (var i = 0; i < l1.length; i++) {\n\
    \        var found = false;\n        for (var j = 0; j < l2.length; j++) {\n \
    \           if (l1[i] === l2[j]) {\n                found = true;\n          \
    \      break;\n            }\n        }\n        if (!found) {\n            ret.push(l1[i]);\n\
    \        }\n    }\n    return ret;\n}\n", "    const out: number[] = [];\n   \
    \ for (let i = 0; i < l1.length; i++) {\n        let found = false;\n        for\
    \ (let j = 0; j < l2.length; j++) {\n            if (l1[i] == l2[j]) {\n     \
    \           found = true;\n                break;\n            }\n        }\n\
    \        if (!found) {\n            out.push(l1[i]);\n        }\n    }\n    return\
    \ out;\n}\n", "  var a1 = l1.length;\n  var a2 = l2.length;\n  var result = new\
    \ Array(a1);\n  var index1 = 0;\n  var index2 = 0;\n  while (index1 < a1 || index2\
    \ < a2) {\n    if (index1 > a1 || index2 > a2) {\n      return result;\n    }\n\
    \    var val = l1[index1] - l2[index2];\n    if (val > 0) {\n      result[index2]\
    \ = val % a1;\n      index2++;\n    } else {\n      result[index2] = val % a2;\n\
    \      index1++;\n    }\n  }\n  return result;\n}", "    let c: {\n        number:\
    \ number[]\n    }[] = [];\n    const map = new Map<number, number[]>();\n    for\
    \ (let i = 0; i < l1.length; i++) {\n        const e: {\n            number: number\n\
    \        } = { number: l1[i] };\n        if (map.has(e)) {\n            map[e].push(l2[i]);\n\
    \        } else {\n            map[e] = [l2[i]];\n        }\n    }\n    map.forEach((e)\
    \ => {\n        if (e[0] > e[1]) {\n            e[0] < e[1] ? c.push(e[0]) : c.push(e[1]);\n\
    \        } else {\n            e[0] < e[1] ? c.push(e[1]) : c.push(e[0]);\n  \
    \      }\n    });\n    return c;\n}\n", "  var i: number;\n  var j: number;\n\
    \  var ai: number;\n  var aj: number;\n  var bi: number;\n  var bj: number;\n\
    \  var clen: number;\n  var cnt: number;\n  var result: number[];\n  var aiLen:\
    \ number;\n  var ajLen: number;\n\n  aiLen = l1.length;\n  ajLen = l2.length;\n\
    \n  result = new Array(aiLen * ajLen);\n\n  cnt = 0;\n\n  for (i = 0; i < aiLen;\
    \ i++) {\n    ai = l1[i];\n    aj = l2[i];\n\n    for (j = 0; j < ajLen; j++)\
    \ {\n      bj = l2[cnt];\n\n      if (ai == bj) {\n        result[cnt] = aj;\n\
    \        cnt++;\n      }\n    }\n  }\n\n  return result;\n}\n", "  const result\
    \ = [];\n  for (let i = 0, len = Math.min(l1.length, l2.length); i < len; i++)\
    \ {\n    if (l1[i] !== l2[i]) {\n      result.push(l1[i]);\n    }\n  }\n  return\
    \ result;\n}\n", "  const l = [] as number[];\n  const len = Math.max(l1.length,\
    \ l2.length);\n  for (let i = 0; i < len; i++) {\n    if (l1[l.length] === l2[l.length])\
    \ {\n      l.push(i);\n    }\n  }\n  return l;\n}\n", "  let result = []\n  let\
    \ i = 0, j = 0\n  while (l1 !== undefined && l2 !== undefined) {\n    if (l1[l1.length\
    \ - 1] === l2[l2.length - 1]) {\n      result.push(l1[l1.length - 1]);\n     \
    \ l1.pop();\n      l2.pop();\n      i++;\n      j++;\n    } else if (l1[l1.length\
    \ - 1] > l2[l2.length - 1]) {\n      j++;\n    } else {\n      i++;\n    }\n \
    \ }\n  while (l1 !== undefined) {\n    result.push(l1[l1.length - 1]);\n    l1.pop();\n\
    \    i++;\n  }\n  while (l2 !== undefined) {\n    result.push(l2[l2.length - 1]);\n\
    \    l2.pop();\n    j++;\n  }\n  return result;\n}\n", "  var result: number[]\
    \ = [];\n  var i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i]\
    \ === l2[i]) {\n      result.push(l1[i]);\n      ++i;\n    } else if (l1[i] >\
    \ l2[i]) {\n      result.push(l2[i]);\n      ++i;\n    } else {\n      result.push(l1[i]);\n\
    \      ++i;\n    }\n  }\n  return result;\n}\n", "  if (l1.length < l2.length)\
    \ {\n    throw new Error('First array has more elements than second');\n  }\n\
    \  const len = l1.length;\n  const result: number[] = [];\n  let index = 0;\n\
    \  let i = -1;\n  while (++i < len) {\n    const element = l1[i];\n    if (l2.indexOf(element)\
    \ !== -1) {\n      result[index] = element;\n      index++;\n    }\n  }\n  return\
    \ result;\n}\n\nconst LARGE_NUMBER = 1e6;\nconst maxSafeInteger = Math.pow(2,\
    \ 53) - 1;\nconst rope = (value) => {\n  if (isSafeInteger(value)) {\n    return\
    \ value;\n  }\n  throw new TypeError('Ropes can only be created for safe integers.');\n\
    };\nconst isSafeInteger: (value: any) => boolean;\nvar maxSafeInteger: number;\n\
    var minSafeInteger: number;\nvar EPSILON: number;\nvar numericToNumber: (value:\
    \ any) => number;\nvar stringToNumber: (value: string) => number;\nvar isNumeric:\
    \ (value: any) => boolean;\nvar isNaN(number: any): boolean;\nvar parseFloat:\
    \ (value: string) => number;\nvar parseInt: (value: string, radix: number) =>\
    \ number;", "  let result: number[] = [];\n  for (let i = 0; i < l1.length; i++)\
    \ {\n    if (l1.length === 0 || l2.length === 0 || l1.length < l2.length) {\n\
    \      continue;\n    }\n    let commonElements: number[] = [];\n    for (let\
    \ j = 0; j < l1.length; j++) {\n      if (j >= l2.length) break;\n      if (l1[i]\
    \ === l2[j]) {\n        commonElements.push(l1[j]);\n      }\n    }\n    if (commonElements.length\
    \ !== 0) {\n      result.push.apply(result, commonElements);\n    }\n  }\n  return\
    \ result;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis fails if you pass more\
    \ than two arrays.\n<|/ c |>\n<| c |>\nThis code fails if you pass arrays with\
    \ different lengths. For example, common([1,2], [4,5]) will result in [1]. But\
    \ common([1,2,3], [4,5,6]) will result in [1, 4, 5].\n<|/ c |>\n<| a |>\nThis\
    \ solution works even with two sets of unequal lengths (by adding \"dummy\" elements\
    \ to the smaller array):\n<code>", "  const result = [];\n  let j = 0;\n  while\
    \ (j < l1.length || j < l2.length) {\n    if (j < l1.length && j < l2.length)\
    \ {\n      if (l1[j] == l2[j]) result.push(l1[j]);\n      j++;\n    } else if\
    \ (j < l1.length) {\n      result.push(l1[j]);\n      j++;\n    } else if (j <\
    \ l2.length) {\n      result.push(l2[j]);\n      j++;\n    }\n  }\n  return result;\n\
    }\n", "  var i: number;\n  var j: number;\n  var k: number;\n  var len1: number;\n\
    \  var len2: number;\n  var output: number[] = [];\n  len1 = l1.length;\n  len2\
    \ = l2.length;\n\n  for (i = 0; i < len1; i++) {\n    for (j = 0; j < len2; j++)\
    \ {\n      k = Math.min(len1, len2) - 1;\n\n      if (k == i)\n        k = len1\
    \ - i;\n\n      if (k == j)\n        k = len2 - j;\n\n      if (l1.length > i\
    \ && l1.length >= j && l2.length > i && l2.length >= j)\n        if (l1[i] ==\
    \ l2[j] && l2[j] == l1[k]) {\n          output.push(l1.splice(i, 1)[0]);\n   \
    \       len1--;\n          len2--;\n          k--;\n        }\n    }\n  }\n\n\
    \  return output;\n}\n", "  const result = [];\n  l1 = l1.concat(l2);\n  l1.sort();\n\
    \  l2.sort();\n  for (let i = 0; i < l1.length && i < l2.length; i++) {\n    if\
    \ (l1[i] === l2[i]) {\n      result.push(l1[i]);\n      l1.splice(i, 1);\n   \
    \   i--;\n    }\n  }\n  return result;\n}\n", "    var result: number[] = [];\n\
    \    var min: number = Math.min(l1.length, l2.length);\n    var i: number;\n\n\
    \    for (i = 0; i < min; i++) {\n        if (l1[i] !== l2[i]) {\n           \
    \ result.push(l1[i]);\n        }\n    }\n\n    if (result.length > 0) {\n    \
    \    return result;\n    }\n\n    return result.reverse();\n}\n", "  var common\
    \ = [];\n  for (var i = 0; i < l1.length; i++) {\n    if (l1.indexOf(l2[i]) !==\
    \ -1) common.push(l2[i]);\n  }\n  return common;\n}\n", "  let result = [];\n\
    \  let i = 0,\n    il1 = l1.length,\n    il2 = l2.length;\n\n  for (; i < il1\
    \ && i < il2; i++) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n\
    \    } else {\n      break;\n    }\n  }\n\n  return result;\n}\n", "  const i\
    \ = l1.length;\n  if (l2.length === 0) { return l1; }\n  const j = (l2.length\
    \ === 1) ? 0 : (l1.length < l2.length ? l2.length : l1.length);\n  let a = 0;\n\
    \  let b = 0;\n  let c = 0;\n  while (i < j) {\n    while (a<i && l1[a] === l2[a])\
    \ { a++; }\n    while (b<j && l1[b] === l2[b]) { b++; }\n    if (a >= b) { break;\
    \ }\n    if (a > i) {\n      a++;\n    } else {\n      c++;\n      while (b<j\
    \ && l2[c] === l2[b]) { b++; c++; }\n      b = c;\n    }\n  }\n  return l1.slice(a,\
    \ b);\n}\n", "  var l: number[] = [],\n    i = 0,\n    j = 0,\n    k = l1.length;\n\
    \n  while (i < k) {\n    while ((l[j] === undefined) && j < k) {\n      j++;\n\
    \    }\n\n    if (l[j] !== undef) {\n      l[i++] = l[j];\n    }\n\n    j++;\n\
    \  }\n\n  k = l2.length;\n\n  while (j < k) {\n    while ((l[i] === undefined)\
    \ && i < k) {\n      i++;\n    }\n\n    if (l[i] !== undef) {\n      l[j++] =\
    \ l[i];\n    }\n\n    i++;\n  }\n\n  return l;\n}\n", "  let res = [];\n  let\
    \ len = Math.min(l1.length, l2.length);\n\n  for (let i = 0; i < len; i++) {\n\
    \    if (l1[i] === l2[i]) res.push(l1[i]);\n  }\n  return res;\n}\n", "  const\
    \ l1Length = l1.length;\n  const l2Length = l2.length;\n  const result = [];\n\
    \  let counter = 0;\n  let found = false;\n\n  while (counter < l1Length) {\n\
    \    if (l1[counter] === l2[counter]) {\n      found = true;\n      result.push(l1[counter]);\n\
    \    }\n\n    ++counter;\n  }\n\n  if (!found) {\n    return [];\n  }\n\n  while\
    \ (counter < l2Length) {\n    if (l1[counter] === -1) {\n      result.push(l2[counter]);\n\
    \    }\n\n    ++counter;\n  }\n\n  return result;\n}\n\nexport function findCommonElement(list1:\
    \ number[], list2: number[]): number | undefined {\n  const l1 = list1.sort();\n\
    \  const l2 = list2.sort();\n  let result = -1;\n\n  for (let i = 0, len = Math.min(l1.length,\
    \ l2.length); i < len; i++) {\n    if (l1[i] === l2[i]) {\n      result = l1[i];\n\
    \      break;\n    }\n  }\n\n  return result;\n}\n\nexport function convertToString(list:\
    \ number[]): string {\n  return list.join(',');\n}\n\nexport function isNumberArray(arr:\
    \ number[]): boolean {\n  return arr.every((e) => isNumber(e));\n}\n\nexport function\
    \ isNumberStringArray(arr: string[]): boolean {\n  return arr.every((e) => isNumber(+e));\n\
    }\n\nexport function parseNumberArray(arr: string[]): number[] {\n  return arr.map(Number);\n\
    }\n", "  const result = [];\n  let i = 1;\n  while (i < l1.length && i < l2.length)\
    \ {\n    if (l1[i] === l2[i]) result.push(l1[i]);\n    else break;\n    i++;\n\
    \  }\n  return result;\n}\n", "  const ls: number[] = [];\n\n  for (let i = 0;\
    \ i <= l1.length; i++) {\n    ls.push(l1[i]);\n  }\n  for (let i = 0; i <= l2.length;\
    \ i++) {\n    if (ls.indexOf(l2[i]) < 0) {\n      ls.push(l2[i]);\n    }\n  }\n\
    \  return ls;\n}\n", "  l1 = l1 || [];\n  l2 = l2 || [];\n  const lLen1 = l1.length;\n\
    \  const lLen2 = l2.length;\n  let i; // short circuit for equal length arrays\n\
    \n  if (lLen1 === lLen2 && lLen1 > 0) {\n    return l1;\n  } // sort and check\
    \ if they are equal\n\n\n  if (lLen1 > lLen2) {\n    l = l1;\n    i = lLen1;\n\
    \  } else {\n    l = l2;\n    i = lLen2;\n  }\n\n  const j: number[] = [];\n\n\
    \  while (i > 0 && l[j] > l[i - 1]) {\n    j.pop();\n    i--;\n  }\n\n  if (i\
    \ === 0) {\n    return l1;\n  }\n\n  while (j.length > 0) {\n    l[j - 1] = l[j\
    \ - 1] + 1;\n  }\n\n  return l;\n}\n", "  l1 = l1 || [];\n  l2 = l2 || [];\n \
    \ let i = 0;\n  let j = 0;\n  let commonCount = 0;\n  while (i < l1.length &&\
    \ j < l2.length) {\n    if (l1[i] === l2[j]) {\n      commonCount++;\n      i++;\n\
    \      j++;\n    } else if (l1[i] < l2[j]) {\n      i++;\n    } else {\n     \
    \ j++;\n    }\n  }\n  return l1.slice(0, commonCount);\n}\n", "    var result\
    \ = new Array(Math.max(l1.length, l2.length));\n    for (var i = 0; i < result.length;\
    \ i++) {\n        result[i] = 0;\n    }\n\n    var i;\n    for (i = 0; i < l1.length;\
    \ i++) {\n        result[l1.length + i] = result[i];\n    }\n    for (i = 0; i\
    \ < l2.length; i++) {\n        result[i] = result[i + l1.length];\n    }\n   \
    \ for (i = 0; i < l1.length; i++) {\n        result[l1.length + i] = result[i];\n\
    \    }\n    return result;\n}\n", "    let set1: Set<number> = new Set<number>();\n\
    \    let set2: Set<number> = new Set<number>();\n\n    for (let val of l1) set1.add(val);\n\
    \    for (let val of l2) set2.add(val);\n\n    let result: number[] = [];\n\n\
    \    for (let val of set1) {\n        if (set2.has(val)) {\n            result.push(val);\n\
    \            set2.delete(val);\n        }\n    }\n\n    return result;\n}\n",
  "  var out: number[] = [];\n  for (var i = 0; i < l1.length; i++) {\n    for (var\
    \ j = 0; j < l2.length; j++) {\n      if (l1.indexOf(l2[j]) === i) {\n       \
    \ out.push(l2[j]);\n        break;\n      }\n    }\n  }\n  return out;\n}\n",
  "  const len1 = l1.length,\n    len2 = l2.length,\n    l1N = len1,\n    l2N = len2,\n\
    \    i = 0,\n    result = [];\n  while (l1N > 0 && l2N > 0) {\n    if (l1[i] ===\
    \ l2[i]) result.push(l1[i]);\n    else i++;\n    l1N--;\n    l2N--;\n  }\n  return\
    \ result;\n}\n", "  const result: number[] = [];\n  let j = 0;\n  let k = 0;\n\
    \  while (j < l1.length && k < l2.length) {\n    if (l1[j] === l2[k]) {\n    \
    \  result.push(l1[j]);\n      ++j;\n      ++k;\n    } else if (l1[j] > l2[k])\
    \ {\n      ++j;\n    } else {\n      ++k;\n    }\n  }\n  return result;\n}\n",
  "  const result: number[] = [],\n      size1 = l1.length,\n      size2 = l2.length,\n\
    \      k = 0,\n      i = 0,\n      j = 0;\n\n  while (i < size1 && j < size2)\
    \ {\n    if (l1.get(i) === l2.get(j)) {\n      result.push(l1.get(i));\n     \
    \ ++i;\n      ++j;\n    } else if (l1.get(i) < l2.get(j)) {\n      ++i;\n    }\
    \ else {\n      ++j;\n    }\n  }\n\n  while (i < size1) {\n    result.push(l1.get(i));\n\
    \    ++i;\n  }\n\n  while (j < size2) {\n    result.push(l2.get(j));\n    ++j;\n\
    \  }\n\n  return result;\n}\n", "  return sort(unique(concat(l1, l2)))\n}\n",
  "    const set1 = new Set(l1);\n    const set2 = new Set(l2);\n    return [...set1].filter((item)\
    \ => set2.has(item));\n}", "  if (l1.length !== l2.length) return [];\n  let commonArr:\
    \ number[] = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (commonArr.indexOf(l1[i])\
    \ === -1) commonArr.push(l1[i]);\n  }\n  for (let j = 0; j < l2.length; j++) {\n\
    \    if (commonArr.indexOf(l2[j]) === -1) commonArr.push(l2[j]);\n  }\n  return\
    \ commonArr;\n}\n", "  const unique: number[] = [];\n  let j = 0;\n  for (let\
    \ i = 0; i < l1.length; i++) {\n    if (l1.indexOf(unique[j]) !== -1) j++;\n \
    \   else unique.push(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n \
    \   if (l2.indexOf(unique[j]) !== -1) j++;\n    else unique.push(l2[i]);\n  }\n\
    \  return unique;\n}\n</code>\n<|/ a tags=arrays,javascript,typescript |>\n<|\
    \ c |>\nThat would be too slow, and it won't handle duplicates in the first array.\
    \ e.g. common([2, 2], [2, 3]) returns [2, 3], when it should return [2].\n<|/\
    \ c |>\n<| c |>\nThanks, I wasn't sure about that and just used it with the example\
    \ given in the question above. I updated my answer accordingly.\n<|/ c |>\n<|\
    \ c |>\nI misunderstood the question; I thought it meant there were no duplicates\
    \ in the first array at all. So all this does is remove duplicates from each array\
    \ and returns the union.\n<|/ c |>\n<| c |>\nIt's not the answer to this question\
    \ but a great explanation why this would not work the way I thought\n<|/ c |>\n\
    <| c |>\nIt won't work correctly if l1 contains duplicates such as `[1, 1, 2]`\
    \ which returns `[1, 2]` instead of `[1]`\n<|/ c |>\n<| a tags=arrays,javascript,typescript\
    \ |>\nYou can use the below function to get unique array from two arrays :\n<code>",
  "  var l: number[] = [];\n  var il1: number[] = [];\n  var il2: number[] = [];\n\
    \  for (let i = 0; i < l1.length; i++) {\n    if (!l2.includes(l1[i])) {\n   \
    \   l.push(l1[i]);\n    } else {\n      if (!il2.includes(l1[i])) {\n        il1.push(l1[i]);\n\
    \      } else {\n        if (!il1.includes(l1[i])) {\n          il2.push(l1[i]);\n\
    \        } else {\n          il1.push(l1[i]);\n        }\n      }\n    }\n  }\n\
    \  return [...l, ...il1, ...il2];\n}\n", "    const ret = new Array(l1.length);\n\
    \    for (const val of l1) {\n        const index = l2.indexOf(val);\n       \
    \ if (index !== -1) ret.push(val);\n    }\n    return ret;\n}", "  let li1 = l1.length;\n\
    \  let li2 = l2.length;\n  let i = 0;\n  let j = 0;\n  let res = [];\n  while\
    \ (i < li1 && j < li2) {\n    if (l1[i] === l2[j]) res.push(l1[i]);\n    i++;\n\
    \    j++;\n  }\n  while (i < li1) res.push(l1[i]);\n  while (j < li2) res.push(l2[j]);\n\
    \  return res;\n}\n", "  var l = Math.min(l1.length, l2.length);\n  var lcm =\
    \ (l1 + l2) / (l - 1);\n  var i = 1;\n  var j = 0;\n  var result = [];\n  while\
    \ (i < l) {\n    while (i + 1 < l && lcm * lcm * l1[i] < lcm * lcm * l2[i]) {\n\
    \      i++;\n    }\n    while (j + 1 < l && lcm * lcm * l1[j] < lcm * lcm * l2[j])\
    \ {\n      j++;\n    }\n    if (i < j) result.push(l1[i]);\n    i++;\n    j++;\n\
    \  }\n  return result;\n}\n", "  const result: number[] = [];\n  let j = 0;\n\
    \  let i;\n  while (i = l1.shift()) {\n    if (j < l2.length && i === l2[j]) {\n\
    \      j++;\n    } else {\n      result.push(i);\n    }\n  }\n  return result;\n\
    }\n", "    var set1 = new Set(l1), set2 = new Set(l2);\n    return set1.keys().filter(function\
    \ (value) {\n        return set2.has(value);\n    });\n}", "  const l: number[]\
    \ = [];\n  for (let i = 0; i < Math.max(l1.length, l2.length); i++) {\n    if\
    \ (l1.length >= i && l2.length >= i) {\n      if (l1[i] !== l2[i]) {\n       \
    \ l.push(l1[i]);\n      }\n    } else {\n      l.push(l2[i]);\n    }\n  }\n  return\
    \ l;\n}\n", "  if (l1.length != l2.length) return [];\n  const l = new Set(l1);\n\
    \  for (let i = 0; i !== l1.length; i++) if (!l.has(l2[i])) l.add(l2[i]);\n  return\
    \ Array.from(l);\n}\n", "  const sorted = l1.concat(l2).sort();\n  const result\
    \ = [];\n  let j = 0;\n  const length = sorted.length;\n  while (j < length) {\n\
    \    const k = j + 1;\n    while (k < length && sorted[k] === sorted[j]) {\n \
    \     k++;\n    }\n    if (k - j === 1) {\n      result.push(sorted[j]);\n   \
    \   j++;\n    } else {\n      result.push.apply(result, common(sorted.slice(j,\
    \ k), sorted.slice(k, length)));\n      j = k;\n    }\n  }\n  return result;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| a dscore=5 |>\nYou can use the ES6 Set API to\
    \ find the unique values in an array.\n<code>\nconst unique = [1, 4, 3, 34, 653,\
    \ 2, 5];\n\nlet uniqueValues = new Set(unique);\n\nconsole.log(uniqueValues);",
  "    let i = 0,\n      j = 0,\n      k = l1.length;\n\n  while (i < k) {\n     \
    \ if (l1[i - 1] === l2[j - 1]) {\n        l1[i] = l2[j - 1];\n      } else if\
    \ (l2[j - 1] > l1[i - 1]) {\n        l1[i] = l2[j - 1];\n      } else {\n    \
    \    l1[i] = l1[i - 1];\n      }\n      i++;\n      j++;\n  }\n  return l1;\n}",
  "  const unique = [];\n  const unqiuel = [];\n  let found = false;\n  l1.forEach((item)\
    \ => {\n    if (!found) {\n      unqiuel.push(item);\n      found = true;\n  \
    \  }\n  });\n  l2.forEach((item) => {\n    const temp = item.toString();\n   \
    \ if (unqiuel.includes(temp)) {\n      unique.push(item);\n    }\n  });\n  return\
    \ unique;\n}\n", "  let n1 = l1.length,\n    n2 = l2.length,\n    arr: number[]\
    \ = [];\n  while (l1 && l2) {\n    if (l1[0] === l2[0]) {\n      l1.shift();\n\
    \      l2.shift();\n    } else if (l1[0] < l2[0]) {\n      l1.shift();\n    }\
    \ else {\n      l2.shift();\n    }\n  }\n  return l1 || l2 ? arr : [];\n}\n",
  "  if (l1.length === 0 || l2.length === 0) {\n    return [];\n  }\n\n  const result:\
    \ number[] = [];\n  let j = 0;\n  let k = 0;\n\n  while (j < l1.length && k <\
    \ l2.length) {\n    if (l1.charAt(j) === l2.charAt(k)) {\n      result.push(l1.charAt(j));\n\
    \      j++;\n    } else {\n      k++;\n    }\n  }\n\n  return result;\n}\n", " \
    \   const out: number[] = [];\n    for (let i = 0; i < l1.length; i++) {\n   \
    \     for (let j = 0; j < l2.length; j++) {\n            if (l1[i] === l2[j])\
    \ {\n                out.push(l1[i]);\n                break;\n            }\n\
    \        }\n    }\n    return out;\n}\n</code>\n<|/ a |>\n<| c |>\nI see what\
    \ you did with the `while` loop. Looks much better than mine. Just a quick question.\
    \ Will that code take into account duplicates and sort the duplicates?\n<|/ c\
    \ |>\n<| c |>\nIt will return unique common elements from two arrays regardless\
    \ of duplicates.\n<|/ c |>\n<| c |>\nI have added a modified version that can\
    \ take duplicates and sort them. Also added a version with O(n) solution as well.\n\
    <|/ c |>\n<| c |>\nThank you so much! It really helped me!\n<|/ c |>\n<| c |>\n\
    It looks perfect! How would you solve this problem in JavaScript?\n<|/ c |>\n\
    <| a dscore=2 |>\nYou can achieve this using sets:\n\n<code>", "    const result:\
    \ number[] = [];\n    let llength = l1.length;\n    let lindex = 0;\n    const\
    \ lindex1 = llength;\n    const lindex2 = llength + 1;\n    while (lindex < lindex1\
    \ && lindex < lindex2) {\n        if (l1[lindex] === l2[lindex]) {\n         \
    \   lindex++;\n        } else {\n            result.push(l1[lindex]);\n      \
    \      lindex++;\n        }\n    }\n    while (lindex1 < lindex2) {\n        result.push(l1[lindex1]);\n\
    \        lindex1++;\n    }\n    return result;\n}\n\nexport function sort<T>(array:\
    \ T[], compareFn?: (a: T, b: T) => number) {\n    return array.slice(0).sort((a,\
    \ b) => {\n        let compareToB;\n        if (compareFn) {\n            compareToB\
    \ = compareFn(a, b);\n        } else {\n            compareToB = defaultCompare(a,\
    \ b);\n        }\n\n        if (a > b || a === undefined) {\n            return\
    \ 1;\n        } else if (a < b || b === undefined) {\n            return -1;\n\
    \        } else if (a === b) {\n            return 0;\n        }\n\n        if\
    \ (compareToB !== 0 && a.value === b.value) {\n            return compareToB;\n\
    \        }\n\n        return defaultCompare(a, b);\n    });\n}\n\nexport function\
    \ defaultCompare(a: number, b: number) {\n    if (a === b) {\n        return 0;\n\
    \    }\n    if (a < b) {\n        return -1;\n    }\n    return 1;\n}\n\nexport\
    \ function compareDescending(a: number, b: number) {\n    if (a === b) {\n   \
    \     return 0;\n    }\n    if (a < b) {\n        return 1;\n    }\n    return\
    \ -1;\n}\n\nexport function defaultFilter<T>(array: T[], callback: (x: T) => boolean)\
    \ {\n    const result: T[] = [];\n    array.forEach(function (obj) {\n       \
    \ if (callback(obj)) {\n            result.push(obj);\n        }\n    });\n  \
    \  return result;\n}\n\nexport function filter<T>(array: T[], callback: (x: T)\
    \ => boolean) {\n    const result: T[] = [];\n    array.forEach(function (obj)\
    \ {\n        if (callback(obj)) {\n            result.push(obj);\n        }\n\
    \    });\n    return result;\n}\n\nexport function defaultMap<T>(array: T[], mapCallback:\
    \ (x: T) => any) {\n    const result = [];\n    array.forEach(function (obj) {\n\
    \        result.push(mapCallback(obj));\n    });\n    return result;\n}\n\nexport\
    \ function map<T>(array: T[], mapCallback: (x: T) => any) {\n    const result\
    \ = [];\n    array.forEach(function (obj) {\n        result.push(mapCallback(obj));\n\
    \    });\n    return result;\n}\n\nexport function indexOf<T>(array: T[], item:\
    \ T) {\n    for (let i = 0; i < array.length; i++) {\n        if (array[i] ===\
    \ item) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nexport\
    \ function contains<T>(array: T[], item: T) {\n    return indexOf(array, item)\
    \ !== -1;", "    let a1 = new Set()\n    let a2 = new Set()\n    let a3 = new\
    \ Set()\n    l1.forEach(item => a1.add(item))\n    l2.forEach(item => a2.add(item))\n\
    \    l1.forEach((item) => {\n        if (!a2.has(item)) {\n            a3.add(item)\n\
    \        }\n    })\n    return Array.from(a3)\n}\n</code>\n<|/ a tags=arrays,typescript,javascript,lodash\
    \ |>\n<| a tags=arrays,typescript,javascript,lodash |>\nIn vanilla javascript,\
    \ you can use Array#filter and Array#indexOf to find the items that are common\
    \ to both arrays:\n\n<code>\nconst common = (arr1, arr2) => {\n  return arr1.filter(item\
    \ => arr2.indexOf(item) !== -1).map(item => item);\n}\n\nconsole.log(common([1,\
    \ 2, 3, 4, 5], [1, 2, 3, 4, 5]));\nconsole.log(common([1, 2, 3, 4, 5], [1, 2,\
    \ 3, 4, 6, 5]));\nconsole.log(common([1, 2, 3, 4, 5], [1, 2, 3, 4, 7]));</code>\n\
    <|/ a dscore=4 |>\n<| a tags=arrays,typescript,javascript,lodash dscore=3 |>\n\
    Here is another solution using lodash library and without using set\n<code>\n\
    let a = [1, 2, 3];\nlet b = [2, 3];\n\nlet common = _.intersection(a, b);\nconsole.log(common);\
    \ // [2, 3]\n</code>\n<|/ a |>\n<| c |>\nThis will return an array of single numbers\
    \ which is not what the OP wanted\n<|/ c |>\n<| c |>\nThis also returns an array\
    \ of single numbers, which is not what the OP wanted.\n<|/ c |>\n<| a tags=arrays,typescript,javascript,lodash\
    \ |>\nIn JavaScript, you can use Array.prototype.filter and Array.prototype.includes\
    \ to find the common elements:\n\n<code>\nvar a = [1, 2, 3, 4, 5];\nvar b = [1,\
    \ 2, 3, 4, 5];\n\nvar common = a.filter((element) => {\n  return b.includes(element)\n\
    });\n\nconsole.log(common);</code>\n\nYou can also use Array.prototype.includes:\n\
    \n<code>\nvar a = [1, 2, 3, 4, 5];\nvar b = [1, 2, 3, 4, 5];\n\nvar common = a.filter(element\
    \ => b.includes(element));\n\nconsole.log(common);</code>\n<|/ a dscore=3 |>\n\
    <| a dscore=2 |>\nIn ES6 you can use Set. As Set.add returns the current set,\
    \ it should be enough to get the common items from the original arrays:\n\n<code>\n\
    var common = new Set([1, 2, 3, 4, 5]);\nvar moreCommon = new Set([2, 3, 4, 5]);\n\
    \nvar commonItems = Array.from(common);\nvar moreCommonItems = Array.from(moreCommon);",
  "  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n\n  return [...set1].filter((num)\
    \ => set2.has(num))\n}\n", "  return l1.sort().concat(l2).sort();\n}\n", "  const\
    \ set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common: number[] =\
    \ [];\n  for (let elem of set1) {\n    if (set2.has(elem)) {\n      common.push(elem);\n\
    \      set1.delete(elem);\n      set2.delete(elem);\n    }\n  }\n  for (let elem\
    \ of set2) {\n    if (set1.has(elem)) {\n      common.push(elem);\n      set2.delete(elem);\n\
    \      set1.delete(elem);\n    }\n  }\n  return common;\n}\n", "  const n = Math.min(l1.length,\
    \ l2.length);\n  const ls = Array(l);\n  for (let i = 0; i < n; ++i) {\n    ls[i]\
    \ = l1[i] === l2[i] ? l1[i] : l1[i] && l2[i];\n  }\n  return ls;\n}", "  l1 =\
    \ l1 || [];\n  l2 = l2 || [];\n  var result: number[] = [],\n      i = 0, j =\
    \ 0,\n      length = Math.max(l1.length, l2.length);\n  while (i < length && j\
    \ < length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i]);\n      i++;\n\
    \      j++;\n    } else {\n      i++;\n    }\n  }\n  return result;\n}", "  let\
    \ set1: Set<number> = new Set();\n  let set2: Set<number> = new Set();\n  let\
    \ setDiff: Set<number> = new Set();\n\n  for (let i = 0; i < l1.length; i++) {\n\
    \    set1.add(l1[i]);\n  }\n\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n\
    \  }\n\n  for (let i = 0; i < l1.length; i++) {\n    if (!set2.has(l1[i])) {\n\
    \      setDiff.add(l1[i]);\n    }\n  }\n\n  return [...setDiff];\n}\n", "  let\
    \ i: number;\n  let j: number;\n  const len1 = l1.length;\n  const len2 = l2.length;\n\
    \  const lpp = Math.floor(Math.max(len1, len2) / 2);\n  const minLen = Math.min(len1,\
    \ len2);\n  const result = new Array(minLen);\n  let k;\n\n  for (i = 0; i < minLen;\
    \ i++) {\n    result[i] = 0;\n  }\n\n  for (k = 0; k < lpp; k++) {\n    for (j\
    \ = i + 1; j < len2; j++) {\n      if (l1[k % len1] === l2[j % len2]) {\n    \
    \    result[k] = l1[k % len1];\n        result[j % len2] = 1;\n        break;\n\
    \      }\n    }\n  }\n\n  return result.slice(0, minLen);\n}\n", "  const result\
    \ = [];\n\n  l1 = l1 || [];\n  l2 = l2 || [];\n\n  for (let i = 0, l = Math.min(l1.length,\
    \ l2.length); i < l; i++) {\n    if (l1[i] === l2[i]) result.push(l1[i]);\n  }\n\
    \n  return result;\n}\n", "  const a = [...l1];\n  const b = [...l2];\n  const\
    \ result = [];\n  while (true) {\n    result.push(l.indexOf(a.shift()));\n   \
    \ result.push(l.indexOf(b.shift()));\n    if (a.length == 0 && b.length == 0)\
    \ {\n      break;\n    }\n  }\n  return result;\n}\n", "    let sorted = l1.concat().sort();\n\
    \    let result = [];\n    result.push(sorted[0]);\n    for (let i = 1; i < sorted.length;\
    \ i++) {\n        if (sorted[i] === sorted[i - 1]) {\n            continue;\n\
    \        }\n        let j = i;\n        while (j > 0 && sorted[j - 1] > sorted[j])\
    \ {\n            result.pop();\n            j--;\n        }\n        result.push(sorted[j]);\n\
    \    }\n    result.push(sorted[l1.length]);\n    return result;\n}\n</code>\n\
    <|/ a dscore=4 tags=arrays,sorting,javascript |>\n<| a tags=arrays,sorting,javascript\
    \ |>\n<code>\nconst isBigger = (a, b) => a < b ? 1 : a > b ? -1 : 0;\n\nconst\
    \ sorted = arr\n    .sort((a, b) => isBigger(a, b) ? 1 : -1)\n    .map(v => arr[v])\n\
    \    .sort((a, b) => isBigger(a, b) ? -1 : 1)\n    .map(v => arr[v]);\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nYour example is confusing but I think you're right.\
    \ Your answer works but you haven't explained why this works.\n<|/ c |>\n<| a\
    \ tags=arrays,sorting,javascript dscore=3 |>\n<code>\nconst arr1 = [1,2,3,4];\n\
    const arr2 = [2,3,4,5];\n\nconst arr3 = arr1.concat(arr2);\n\narr3.sort((a, b)\
    \ => a - b).map((v, i) => arr2[i]);\n</code>\n<|/ a |>\n<| a dscore=3 |>\nA good\
    \ option is to sort the array and then use Array.filter() to return only the value\
    \ from the original array that are in the new sorted array.\nFor instance:\n<code>\n\
    let arr1 = [4, 2, 3, 1];\nlet arr2 = [7, 8, 4, 10];\n\nlet sorted = arr1.sort((a,\
    \ b) => a - b);\nlet result = arr2.filter(n => sorted.indexOf(n) > -1)\n</code>\n\
    <|/ a tags=arrays,sorting,javascript |>\n<| c |>\nThis is much more efficient.\
    \ I used this to get the indexes of where two arrays had the same value, then\
    \ I just used `.map(arr2)` to return the values I needed. `let indexes = arr1.sort((a,\
    \ b) => a - b).map(arr1.indexOf);`\n<|/ c |>\n<| a dscore=3 |>\n<code>\nvar array1\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"];\nvar array", "    var n = Math.min(l1.length,\
    \ l2.length); // Fast checks for same length\n\n    if (n === 0) {\n        return\
    \ l1;\n    }\n\n    var result = [];\n    var i = 0;\n    while (i < n && l1.length\
    \ > 0 && l2.length > 0) {\n        if (l1[i] === l2[i]) {\n            result.push(l1[i]);\n\
    \            l1.splice(i, 1);\n            l2.splice(i, 1);\n        } else if\
    \ (l2[i] > l1[i]) {\n            result.push(l2[i]);\n            l2.splice(i,\
    \ 1);\n        } else {\n            result.push(l1[i]);\n            l1.splice(i,\
    \ 1);\n        }\n        i += 1;\n    }\n\n    if (l1.length > 0) {\n       \
    \ for (var j = 0; j < l1.length; j++) {\n            result.push(l1[j])\n    \
    \    }\n    }\n\n    if (l2.length > 0) {\n        for (var j = 0; j < l2.length;\
    \ j++) {\n            result.push(l2[j])\n        }\n    }\n\n    return result;\n\
    }\n", "  let l10: number[] = [], l11: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    if (!l2.includes(l1[i])) {\n      l10.push(l1[i]);\n    }\n  }\n\
    \  for (let i = 0; i < l2.length; i++) {\n    if (!l10.includes(l2[i])) {\n  \
    \    l11.push(l2[i]);\n    }\n  }\n  return l1.concat(l2).filter(function(elem,\
    \ pos) {\n    return l11.indexOf(elem) == pos;\n  });\n}\n", "  let arr1: number[]\
    \ = l1;\n  let arr2: number[] = l2;\n  let arr1Len = arr1.length;\n  let arr2Len\
    \ = arr2.length;\n  let i = 0;\n  let j = 0;\n  let result: number[] = [];\n \
    \ while (i < arr1Len && j < arr2Len) {\n    if (arr1[i] === arr2[j]) {\n     \
    \ result.push(arr1[i]);\n      i++;\n      j++;\n    } else if (arr1[i] < arr2[j])\
    \ {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis works but is not efficient when you have larger lists.\n\
    <|/ c |>\n<| a |>\n<code>\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n", "  let\
    \ l: number[];\n  if (l1.length != l2.length) {\n    return [];\n  }\n  l1 = l1.sort();\n\
    \  l2 = l2.sort();\n  while (l1.length > 0 && l2.length > 0) {\n    if (l1[0]\
    \ != l2[0]) {\n      l = [];\n      break;\n    }\n    l1.shift();\n    l2.shift();\n\
    \  }\n  return l.concat(l1);\n}\n", "    if (l1.length === 0 || l2.length ===\
    \ 0) {\n        return l1;\n    }\n\n    const j: number[] = [];\n    const len:\
    \ number = l1.length;\n    const i: number = 0;\n\n    while (i < len) {\n   \
    \     const jVal: number = l2[i];\n\n        if (jVal !== -1) {\n            j[j.length]\
    \ = jVal;\n        } else {\n            i++;\n        }\n    }\n\n    return\
    \ j;\n}\n", "  const result: number[] = []\n  for(let i1 = 0; i1 < l1.length;\
    \ i1++) {\n    for(let i2 = 0; i2 < l2.length; i2++) {\n      if(l1[i1] === l2[i2])\
    \ {\n        result.push(l1[i1])\n      }\n    }\n  }\n  return result\n}\n",
  "  l1 = l1\n    .map(i => {\n      if (typeof i === 'number') return i;\n      if\
    \ (typeof i === 'string') return i.replace(/[^\\d]/g, '');\n    })\n    .filter(i\
    \ => !!i);\n\n  l2 = l2\n    .map(i => {\n      if (typeof i === 'number') return\
    \ i;\n      if (typeof i === 'string') return i.replace(/[^\\d]/g, '');\n    })\n\
    \    .filter(i => !!i);\n\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n\
    \  const ret = [...set1].filter(e => !set2.has(e));\n  ret = [...set2].filter(e\
    \ => !set1.has(e));\n  return ret;\n}\n", "  return l1.filter(function (v, i)\
    \ { return l2.indexOf(v) === i; });\n}\n", "    const l = Math.min(l1.length,\
    \ l2.length);\n    const arr: number[] = [];\n    let j = 0;\n    for (let i =\
    \ 0; i < l; i++) {\n        if (l1[i] === l2[j]) {\n            arr[j] = l1[i];\n\
    \            j++;\n        }\n    }\n    return arr;\n}\n", "    const hash1 =\
    \ new Map();\n    const hash2 = new Map();\n\n    for (let i = 0; i < l1.length;\
    \ ++i) {\n        const hashValue = hash1(l1[i]);\n        if (!hash2.has(hashValue))\
    \ {\n            hash2.set(hashValue, 0);\n        }\n        hash2.set(hashValue,\
    \ hash2.get(hashValue) + 1);\n    }\n\n    for (let i = 0; i < l2.length; ++i)\
    \ {\n        const hashValue = hash2(l2[i]);\n        if (!hash1.has(hashValue))\
    \ {\n            hash1.set(hashValue, 0);\n        }\n        hash1.set(hashValue,\
    \ hash1.get(hashValue) + 1);\n    }\n\n    return hash1.values().filter((v: number)\
    \ => v !== 0);\n}\n", "  let l: number[] = l1.concat(l2);\n  let r: number[] =\
    \ [];\n  for (let i = 0; i < l.length; i++) {\n    let j: number = l.lastIndexOf(l[i]);\n\
    \    if (j != -1) r.push(l[j]);\n  }\n  return r;\n}\n", "  const set1 = new Set(l1);\n\
    \  const set2 = new Set(l2);\n  return Array.from(set1.keys()).concat(Array.from(set2.keys())).filter(d\
    \ => set1.has(d) && set2.has(d)).sort();\n}\n", "    var result = [];\n    for\
    \ (var i = 0; i < l1.length; i++) {\n        for (var j = 0; j < l2.length; j++)\
    \ {\n            if (l1[i] == l2[j]) {\n                result.push(l1[i]);\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=arrays,javascript |>\n<| c |>\nThis would work, but the\
    \ order is not preserved.\n<|/ c |>\n<| c |>\nNot sure why that would be the case.\
    \ Perhaps I misunderstood the question though.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ preserve the order. It doesn't preserve the original order. You'd have to sort\
    \ it afterwards.\n<|/ c |>\n<| a tags=arrays,javascript |>\nYou can use filter\
    \ and sort:\n\n<code>\nlet data = [1, 4, 3, 34, 653, 2, 5];\nlet data2 = [1, 4,\
    \ 3, 34, 653, 2, 5];\n\nconsole.log(\n  data2.filter((value, index) => data.indexOf(value)\
    \ === index).sort()\n)</code>\n\nThis solution has O(n) complexity, which is better\
    \ than O(n^2) solution.\n<|/ a dscore=5 |>\n<| a |>\nYou can use ES6 Set and Array#includes\
    \ :\n\n<code>\nvar arr = [1, 4, 3, 34, 653, 2, 5];\nvar arr2 = [1, 4, 3, 34, 653,\
    \ 2, 5];\nvar arr3 = [1, 4, 3, 34, 653, 2, 5];\n\nvar arr4 = [1, 4, 3, 34, 653,\
    \ 2, 5];\n\nlet commonSet = new Set(arr);\nlet commonSet2 = new Set(arr2);\nlet\
    \ commonSet3 = new Set(arr3);\nlet commonSet4 = new Set(arr4);\n\nlet result1\
    \ = arr.filter(x => commonSet.has(x)).sort(); //[1, 4, 3, 34, 653, 2, 5]\nlet\
    \ result2 = arr2.filter(x => commonSet2.has(x)).sort(); //[1, 4, 3, 34, 653, 2,\
    \ 5]\nlet result3 = arr3.filter(x => commonSet3.has(x)).sort(); //[1, 4, 3, 34,\
    \ 653, 2, 5]\nlet result4 = arr4.filter(x => commonSet4.has(x)).sort(); //[1,\
    \ 4, 3, 34, 653, 2, 5]\n\nconsole.log('result1:', result1);\nconsole.log('result2:',\
    \ result2);\nconsole.log('result3:', result3);\nconsole.log('result4:', result4);</code>\n\
    \nTo get a unique values use Array#reduce, Array#some and Array#includes:\n\n\
    <code>\nvar arr = [1, 4, 3, 34, 653, 2, 5];\nvar arr2 = [1, 4, 3, 34, 653, 2,\
    \ 5];\nvar arr3 = [1, 4, 3, 34, 653, 2, 5];\n\nvar arr4 = [1, 4, 3, 34, 653, 2,\
    \ 5];", "  let l: number[] = [], l0: number[] = l1.concat(l2);\n  while (l1.length\
    \ && l2.length) {\n    const i = l0.indexOf(Math.min(...l1));\n    if (i >= 0)\
    \ {\n      l.unshift(l0.splice(i, 1)[0]);\n    } else {\n      l0.unshift(l1.pop());\n\
    \    }\n  }\n  return l;\n}\n", "    var result: number[] = [];\n    for (var\
    \ _i = 0, _l1 = l1; _i < _l1.length; _i++) {\n        var v1 = _1[_i];\n     \
    \   for (var _a = 0, _l2 = l2; _a < _l2.length; _a++) {\n            var v2 =\
    \ _2[_a];\n            if (v1 === v2) {\n                break;\n            }\n\
    \        }\n        if (_a >= _l2.length) {\n            result.push(v1);\n  \
    \      }\n    }\n    return result;\n}\n\n<|/ file filename=utils.ts source=gitlab\
    \ |>", "  const list = new Set(l1);\n  for (let i = 0; i < l2.length; i++) {\n\
    \    list.add(l2[i]);\n  }\n  return [...list];\n}\n", "  const lcm = Math.max(...l1,\
    \ ...l2);\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n   \
    \ const val = lcm * (l1.length - i) / (l2.length - i);\n    result.push(val);\n\
    \  }\n  return result;\n}\n", "    let l: number[] = [];\n    for (let i = 0;\
    \ i < (l1.length < l2.length ? l1.length : l2.length); i++) {\n        if (l1.length\
    \ > i && l2.length > i && l1[i] === l2[i]) {\n            l.push(l1[i]);\n   \
    \     }\n    }\n    return l;\n}\n", "  const l2: number[] = l2 || [];\n  const\
    \ result: number[] = [];\n  let i = 0;\n  for (let j = 0; j < l1.length; j++)\
    \ {\n    if (l1.hasOwnProperty(j) && l2.hasOwnProperty(j) && l1[j] === l2[j])\
    \ {\n      result.push(l1[j]);\n      delete l2[j];\n      j++;\n    }\n  }\n\
    \  for (let j = 0; j < l2.length; j++) {\n    l1[i++] = l2[j];\n  }\n  return\
    \ result;\n}\n", "  const l1_count = l1.length;\n  const l2_count = l2.length;\n\
    \  const result: number[] = [];\n  const hash1 = new Map();\n  const hash2 = new\
    \ Map();\n  for (let i = 0; i < l1_count; i++) {\n    hash1.set(l1[i], i);\n \
    \ }\n  for (let i = 0; i < l2_count; i++) {\n    hash2.set(l2[i], i);\n  }\n \
    \ for (let i = 0; i < l2_count; i++) {\n    let j;\n    for (j = i + 1; j < l2_count;\
    \ j++) {\n      if (hash2.get(l2[i]) < hash2.get(l2[j])) {\n        break;\n \
    \     }\n      result.push(l2[i]);\n    }\n  }\n  return result;\n}\n", "  var\
    \ hashMap: Map<number, number[]> = new Map();\n  for (var i = 0; i < l1.length;\
    \ i++) {\n    var itemHash = hashMap.get(l1[i]);\n    if (itemHash == null) {\n\
    \      itemHash = [l1[i]];\n      hashMap.set(l1[i], itemHash);\n    } else {\n\
    \      itemHash.push(l1[i]);\n    }\n  }\n  for (var i = 0; i < l2.length; i++)\
    \ {\n    var itemHash = hashMap.get(l2[i]);\n    if (itemHash == null) {\n   \
    \   itemHash = [l2[i]];\n      hashMap.set(l2[i], itemHash);\n    } else {\n \
    \     itemHash.push(l2[i]);\n    }\n  }\n  var ret: number[] = [];\n  var keys:\
    \ number[] = [];\n  hashMap.forEach((value, key) => {\n    if (keys.length !=\
    \ value.length) {\n      return;\n    }\n    keys = keys.concat(key);\n    ret\
    \ = ret.concat(value);\n  });\n  return ret;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis does not return sorted unique common elements for two arrays.\n\
    <|/ c |>\n<| c |>\nThe requirement was to return sorted unique common elements\
    \ for two arrays. A single common element would be returned multiple times. However,\
    \ I believe that this is a question for the OP and that they will find their answer\
    \ if they can figure out the code they need. Hence the downvote.\n<|/ c |>\n<|\
    \ a |>\nThe main problem in your approach is that you do not handle the case that\
    \ one array contains multiple equal elements (multiple keys in a map). In that\
    \ case, your hashmap only contains one item for all equal elements. \nThe following\
    \ snippet iterates through all pairs in both arrays and checks whether a key already\
    \ exists in the hashmap already. If not, it is added to the hashmap and an array\
    \ containing the element of the pair is pushed to the array containing the keys.\
    \ If the key already exists, it is pushed to the existing array. \nFor the case\
    \ where an array contains multiple equal elements, only the first unique element\
    \ is added to the array.\n<code>\nconst common = (array1: [number, number], array2:\
    \ [number, number]) => {\n    const hashmap = new Map();\n\n    array1.forEach(a\
    \ => {\n        if (!hashmap.has(a)) {\n            hashmap.set(a, []);\n    \
    \    }\n    });\n\n    array2.forEach(a => {\n        if (!hashmap.has(a)) {\n\
    \            hashmap.set(a, []);\n        }\n    });\n\n    array1.forEach(a =>\
    \ {\n        const keys = [a];\n        if (!hashmap.get(a).includes(a)) {\n \
    \           hashmap.get(a).push(keys);\n        } else if (hashmap.get(a).includes(a))\
    \ {\n            keys.forEach(k => {\n                if (!hashmap.get(a).", " \
    \ let l1 = l1 || [];\n  let l2 = l2 || [];\n  let a1 = l1.length;\n  let a2 =\
    \ l2.length;\n  if (a1 === 0 || a2 === 0) {\n    return [];\n  }\n  let sorted\
    \ = sortNumbers(l1, l2);\n  let res: number[] = [];\n  for (let i = 0; i < a1\
    \ - 1; i++) {\n    res.push(sorted[0]);\n  }\n  for (let i = 0; i < a2 - 1; i++)\
    \ {\n    res.push(sorted[1]);\n  }\n  return res;\n}\n", "  var l: number[] =\
    \ [];\n  while (l1) {\n    var r1 = l1.pop();\n    if (l2) l.push(r1);\n    else\
    \ return r1;\n  }\n  while (l2) {\n    var r2 = l2.pop();\n    if (l1) l.push(r2);\n\
    \    else return r2;\n  }\n  return l;\n}\n", "    const result: number[] = [];\n\
    \    let llen = Math.min(l1.length, l2.length);\n\n    for (let i = 0; i < llen;\
    \ i++) {\n        if (l1[llength - i] !== l2[llength - i]) {\n            result.push(l1[llength\
    \ - i]);\n        }\n    }\n\n    return result;\n}\n", "  const n1 = l1.length;\n\
    \  const n2 = l2.length;\n  const c = new Array(n1);\n  let i = 0;\n  let j =\
    \ 0;\n  let k = 0;\n  while (i < n1 && j < n2) {\n    if (l1[i] === l2[j]) {\n\
    \      c[k] = l1[i];\n      i++;\n      j++;\n    } else if (l1[i] < l2[j]) {\n\
    \      c[k] = l1[i];\n      i++;\n    } else {\n      c[k] = l2[j];\n      j++;\n\
    \    }\n    k++;\n  }\n  while (i < n1) {\n    c[k] = l1[i];\n    i++;\n    k++;\n\
    \  }\n  while (j < n2) {\n    c[k] = l2[j];\n    j++;\n    k++;\n  }\n  return\
    \ c;\n}\n", "  const result = new Set(l1);\n  for (let i = 0; i < l2.length; i++)\
    \ {\n    const val = l2[i];\n    if (result.has(val)) {\n      result.set(val);\n\
    \    } else {\n      result.add(val);\n    }\n  }\n  return [...result]\n}\n</code>\n\
    <|/ a tags=arrays,algorithm |>\n<| a dscore=1 |>\nUse an auxiliary hash table:\n\
    \ncreate empty hash table h\nfor each element in A\nh[element] = 1\nfor each element\
    \ in B\nif h[element] == 1 then h[element] += 1\nif the hash table has a count\
    \ greater than 1 then output the first element which has a count greater than\
    \ 1\n\nPseudocode:\n<code>\narrayA <- {4, 3, 653, 5}\narrayB <- {4, 3, 12, 653,\
    \ 5}\n\nh <- {}\n\nfor each element in arrayA\n    h[element] = 1\n\nfor each\
    \ element in arrayB\n    if h[element] == 1 then h[element] += 1\n\noutput the\
    \ first element whose value is greater than 1\n</code>\nOutput:\n<code>\nOutput:\
    \ 653\n</code>\n<|/ a tags=arrays,algorithm |>\n<| a dscore=1 |>\n<code>\n#include<bits/stdc++.h>\n\
    using namespace std;\nint main()\n{\n   int arr1[]={4,3,653,5},arr2[]={4,3,12,653,5};\n\
    \   int arr3[],i,j,k;\n   for(i=0;i<4;i++)\n   {\n      arr3[i]=0;\n   }\n   for(i=0;i<4;i++)\n\
    \   {\n      for(j=0;j<4;j++)\n      {\n         if(arr1[i]==arr2[j])\n      \
    \   {\n            arr3[i]++;\n         }\n      }\n   }\n   for(k=0;k<4;k++)\n\
    \   {\n      if(arr3[k]>1)\n      {\n         cout<<arr2[k];\n         return\
    \ 0;\n      }\n   }\n   cout<<\"Not in common\"<<endl;\n   return 0;\n}\n</code>\n\
    <|/ a tags=arrays,algorithm |>\n<| a tags=arrays,algorithm |>\nAs another answer\
    \ said, you might use a hash table - in Java:\n<code>\nList<Integer> common =\
    \ new ArrayList<Integer>();\n\nfor(int i = 0; i < array1.size(); i++) {\n    int\
    \ val = array1.get(i);\n    if (array2.contains(val)) {\n        // Increment\
    \ count for this value\n        int count = hash.get(val) + 1;\n        if (count\
    \ > 1) {\n            common.add(val);\n        }\n    }\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nIn JavaScript, you can use this:\n<code>\n", "  let result = new\
    \ Set<number>();\n  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0;\
    \ j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n        result.add(l1[i]);\n\
    \        break;\n      }\n    }\n  }\n  return Array.from(result);\n}\n", "  const\
    \ l12 = new Set(l1);\n  const l22 = new Set(l2);\n  const l = Math.min(l1.length,\
    \ l2.length);\n  const ret: number[] = [];\n  for (let i = 0; i < l; i++) {\n\
    \    const v = l1[i];\n    if (l22.has(v)) {\n      ret.push(v);\n    }\n  }\n\
    \  for (let i = 0; i < l; i++) {\n    const v = l2[i];\n    if (l12.has(v)) {\n\
    \      ret.push(v);\n    }\n  }\n  return ret;\n}\n", "  const m = Math.min(l1.length,\
    \ l2.length);\n  const n = new Array(m);\n  for (let i = 0; i < m; ++i) {\n  \
    \  n[i] = l1[i] === l2[i] ? i : -1;\n  }\n  for (let i = 0, j = 0; i < m; ++i,\
    \ j++) {\n    if (n[i] === -1) {\n      n[i] = j;\n    }\n  }\n  return n;\n}\n",
  "  let lcm = Math.max(...l1, ...l2);\n  return l1.filter((element) => l2.indexOf(element)\
    \ !== -1).sort((a, b) => a - b).slice(0, lcm);\n}\n</code>\n<|/ a tags=javascript\
    \ |>\n<| a tags=javascript |>\nYou could get the common elements and sort it.\n\
    \n<code>", "  const out = [];\n  for (let i = 0; i < l1.length; i++) {\n    if\
    \ (l2.indexOf(l1[i]) === -1) {\n      out.push(l1[i]);\n    }\n  }\n  return out;\n\
    }\n", "  var a1 = [], a2 = [], n = l1.length;\n  for (var i = 0; i < n; i++) {\n\
    \    var v = l1[i];\n    if (l2[i] === v) {\n      a1.push(v);\n    } else {\n\
    \      a2.push(v);\n    }\n  }\n  a1.sort(function (a, b) {\n    return a - b;\n\
    \  });\n  a2.sort(function (a, b) {\n    return a - b;\n  });\n  var l = a1.length;\n\
    \  var k = a2.length;\n  var m = Math.min(k, l);\n  while (l < m) {\n    m -=\
    \ l;\n    l += k;\n  }\n  var c = new Array(m), i = 0, j = 0, y = 0;\n  while\
    \ (i < k) {\n    if (a2[j] < a1[i]) {\n      c[m] = a1[i];\n      i++;\n     \
    \ j++;\n    } else {\n      c[m] = a2[j];\n      j++;\n    }\n    y++;\n    while\
    \ (j < l) {\n      if (a2[j] == a1[i]) {\n        c[m] = a2[j];\n        j++;\n\
    \        i++;\n        break;\n      }\n      c[m] = a1[i];\n      i++;\n    }\n\
    \    y++;\n  }\n  return c;\n}\n", "  const result = [];\n  const hash1 = hash(l1);\n\
    \  const hash2 = hash(l2);\n  let index = 0;\n  let item;\n  while (index < l1.length)\
    \ {\n    item = l1[index];\n    if (index === hash1[item]) {\n      result.push(item);\n\
    \    } else if (hash2[item]) {\n      index = hash2[item];\n    } else {\n   \
    \   result.push(item);\n      index = l1.length;\n    }\n  }\n  return result;\n\
    }\n", "    let l: number[] = [];\n    for (let i = 0; i !== l1.length; i++) {\n\
    \        if (l2.indexOf(l1[i]) === -1) {\n            l.push(l1[i]);\n       \
    \ }\n    }\n    return l;\n}\n\nexport function findIndexBy<T, U extends T>(array:\
    \ T[], predicate: (item: T, index: number) => boolean): U {\n    for (let i =\
    \ 0; i !== array.length; i++) {\n        if (predicate(array[i], i)) {\n     \
    \       return array[i];\n        }\n    }\n    return undefined;\n}\n\nexport\
    \ function findIndexBy<T, U extends T>(array: T[], predicate: (item: T, index:\
    \ number) => boolean, startIndex = 0): U {\n    for (let i = startIndex; i !==\
    \ array.length; i++) {\n        if (predicate(array[i], i)) {\n            return\
    \ array[i];\n        }\n    }\n    return undefined;\n}\n", "  const result =\
    \ [];\n\n  for (let i = 0; i < l1.length && i < l2.length; i++) {\n    if (l1[i]\
    \ === l2[i]) {\n      result.push(l1[i]);\n    } else {\n      break;\n    }\n\
    \  }\n\n  return result.sort();\n}\n", "  const set1 = new Set(l1);\n  const set2\
    \ = new Set(l2);\n  const list = [];\n  for (const value of set1) {\n    if (set2.has(value))\
    \ {\n      list.push(value);\n    }\n  }\n  return list;\n}\n", "  return new\
    \ Set([...l1, ...l2]).filter((e: number) => l1.indexOf(e) > -1 && l2.indexOf(e)\
    \ > -1).sort((a: number, b: number) => a - b) as number[];\n}\n", "  if (l1 ==\
    \ l2) return l1;\n  const l: number[] = [];\n  let i = -1;\n  let j = 0;\n  while\
    \ (++i < l1.length && ++j < l2.length) {\n    if (l1[i] === l2[j]) {\n      l.push(l1[i]);\n\
    \      i++;\n      j++;\n    } else if (l2[j] < l1[i]) {\n      j++;\n    } else\
    \ {\n      i++;\n    }\n  }\n  return l;\n}", "  let i = l1.length, j, k = 0,\
    \ r = [], x = l2.length, a;\n\n  while (i !== 0) {\n    a = l1[k];\n    while\
    \ (a !== l2[--k] && i !== 0) {\n      --i;\n    }\n\n    if (i === 0) {\n    \
    \  break;\n    }\n\n    r = r.concat(a);\n  }\n\n  return r;\n}\n", "  let i =\
    \ 0;\n  let j = 0;\n  let k = 0;\n  const common: number[] = [];\n  while (i <\
    \ l1.length && j < l2.length) {\n    if (l1.length === l2.length) {\n      if\
    \ (l1.indexOf(l2[j]) < 0) {\n        common.push(l1[i]);\n      }\n    } else\
    \ {\n      if (l2[j] === l1[i]) {\n        common.push(l2[j]);\n        j++;\n\
    \      } else if (l2[j] > l1[i]) {\n        common.push(l1[i]);\n        i++;\n\
    \      } else {\n        common.push(l2[j]);\n        j++;\n        k++;\n   \
    \   }\n    }\n  }\n  while (i < l1.length) {\n    common.push(l1[i]);\n    i++;\n\
    \  }\n  while (j < l2.length) {\n    common.push(l2[j]);\n    j++;\n  }\n  return\
    \ common;\n}\n", "  let result = l1.concat();\n  let map = new Map();\n  let resultIndex\
    \ = 0;\n  let index = 0;\n  while (index < l1.length && index < l2.length) {\n\
    \    const val1 = l1[index];\n    const val2 = l2[index];\n    const commonValue\
    \ = map.get(val1) && map.get(val1).common[val2];\n    if (commonValue) {\n   \
    \   result.push(commonValue);\n      index++;\n    } else {\n      const newResultIndex\
    \ = resultIndex++;\n      map.set(val1, {\n        common: {},\n        index:\
    \ newResultIndex\n      });\n      map.set(val2, {\n        common: {},\n    \
    \    index: newResultIndex\n      });\n      result.push(val1);\n      result.push(val2);\n\
    \    }\n  }\n  map.forEach((value, key, map) => {\n    const commonValue = map.get(key)\
    \ && map.get(key).common[value];\n    if (commonValue) {\n      result.push(commonValue);\n\
    \    }\n  });\n  return result;\n}\n", "  let u1 = l1.length,\n    u2 = l2.length,\n\
    \    arr: number[] = [],\n    j = 0,\n    k = 0,\n    u: number = 0,\n    n1:\
    \ number,\n    n2: number;\n\n  while (j < u1 && k < u2) {\n    n1 = l1[j];\n\
    \    n2 = l2[k];\n    j = j + 1;\n    k = k + 1;\n    if (n1 === n2) {\n     \
    \ arr.push(n1);\n      u = u;\n      j = j + 1;\n      k = k + 1;\n      continue;\n\
    \    }\n    if (n1 > n2) {\n      arr.push(n1);\n      j = j + 1;\n      k = k\
    \ + 1;\n      continue;\n    }\n    if (n2 > n1) {\n      arr.push(n2);\n    \
    \  k = k + 1;\n      continue;\n    }\n    u = u + 1;\n  }\n\n  while (j < u1)\
    \ {\n    arr.push(l1[j]);\n    j = j + 1;\n  }\n\n  while (k < u2) {\n    arr.push(l2[k]);\n\
    \    k = k + 1;\n  }\n  return arr;\n}\n", "  var _a1: string[] = [], l1Index:\
    \ number[] = [];\n  var _a2: string[] = [], l2Index: number[] = [];\n  var i,\
    \ j, k;\n  for (k = 0; k < l1.length; ++k) {\n    var index = getIndex(l1[k]);\n\
    \    l1Index.push(index);\n  }\n  for (k = 0; k < l2.length; ++k) {\n    var index\
    \ = getIndex(l2[k]);\n    l2Index.push(index);\n  }\n  for (i = 0; i < l1Index.length;\
    \ ++i) {\n    for (j = 0; j < l2Index.length; ++j) {\n      if (l1Index[i] ===\
    \ l2Index[j]) {\n        _a1.push(l1[i]);\n        _a2.push(l2[j]);\n      }\n\
    \    }\n  }\n  return _a1.concat(_a2);\n}\n", "  const n = Math.min(l1.length,\
    \ l2.length);\n  const results = new Array(n);\n  for (let i = 0; i < n; i++)\
    \ {\n    results[i] = Math.min(l1[l1.length - 1 - i], l2[l2.length - 1 - i]);\n\
    \  }\n  return results;\n}\n", "  let l1 = l1 || [];\n  let l2 = l2 || [];\n \
    \ let set = new Set<number>();\n  for (let i = 0; i < l1.length; i++) {\n    if\
    \ (set.has(l1[i])) continue;\n    for (let j = 0; j < l2.length; j++) {\n    \
    \  if (set.has(l2[j])) continue;\n      if (l1[i] === l2[j]) {\n        set.add(l1[i]);\n\
    \        set.add(l2[j]);\n      }\n    }\n  }\n  return [...set];\n}", "    var\
    \ result = [];\n    var i1 = 0, i2 = 0;\n    var j1 = 0, j2 = 0;\n    while (i1\
    \ < l1.length && i2 < l2.length) {\n        if (l1[i1] === l2[j2]) {\n       \
    \     result.push(l1[i1]);\n            i1++;\n            j2++;\n        } else\
    \ if (l1[i2] === l2[j1]) {\n            result.push(l2[j2]);\n            i2++;\n\
    \            j1++;\n        } else {\n            i1++;\n            j1++;\n \
    \       }\n    }\n    return result;\n}\n", "  const set1: Set<number> = new Set(l1);\n\
    \  const set2: Set<number> = new Set(l2);\n  const intersection: Set<number> =\
    \ new Set();\n  for (let i: number = 0; i < Math.min(l1.length, l2.length); i++)\
    \ {\n    if (set1.has(l1[i]) && set2.has(l2[i])) {\n      intersection.add(l1[i]);\n\
    \      intersection.add(l2[i]);\n    }\n  }\n  return [...intersection].sort();\n\
    }\n", "    const result = [];\n    const iterator1 = [l1][Symbol.iterator]();\n\
    \    const iterator2 = [l2][Symbol.iterator]();\n    do {\n        const item1\
    \ = iterator1.next();\n        const item2 = iterator2.next();\n        if (item1.done\
    \ && item2.done) break;\n        if (item1.done || item2.done) result.push(item1.value);\n\
    \        else {\n            if (item1.value === item2.value) {\n            \
    \    result.push(item1.value);\n                continue;\n            }\n   \
    \         const item1Value = item1.value.toString();\n            const item2Value\
    \ = item2.value.toString();\n            if (item1Value === item2Value) {\n  \
    \              result.push(item1.value);\n                continue;\n        \
    \    }\n            if (item1Value > item2Value) {\n                result.push(item1.value);\n\
    \                continue;\n            }\n            result.push(item2.value);\n\
    \        }\n    } while (!iterator1.done);\n    do {\n        const item2 = iterator2.next();\n\
    \        if (item2.done) break;\n        result.push(item2.value);\n    } while\
    \ (!iterator2.done);\n    return result;\n}", "  const l: number[] = [];\n  while\
    \ (l1.length > 0 && l2.length > 0) {\n    if (l1[0] !== l2[0]) {\n      break;\n\
    \    }\n    l.push(l1.shift());\n    l.push(l2.shift());\n  }\n  while (l1.length\
    \ > 0) {\n    l.push(l1.shift());\n  }\n  while (l2.length > 0) {\n    l.push(l2.shift());\n\
    \  }\n  return l;\n}\n", "    var l12: number[];\n    var i: number;\n    var\
    \ j: number;\n    var k: number;\n    var i2: number;\n    var j2: number;\n \
    \   var k2: number;\n    var j3: number;\n    var k: number;\n    var j1: number;\n\
    \    var k: number;\n    var a1: number[];\n    var a2: number[];\n    var a3:\
    \ number[];\n    var a: number;\n    var b: number;\n    var c: number;\n    var\
    \ d: number;\n    var e: number;\n    var f: number[];\n    var g: number;\n \
    \   var h: number;\n    var i: number;\n    var j: number;\n    var k: number;\n\
    \    var l: number;\n    var m: number;\n    var n: number;\n    var o: number;\n\
    \    var p: number;\n    var q: number;\n    var r: number[];\n    var s: number;\n\
    \    var t: number;\n    var u: number;\n    var v: number;\n    var w: number;\n\
    \    var x: number;\n    var y: number;\n    var z: number;\n    var u: number;\n\
    \    var v: number;\n    var w: number;\n    var x: number;\n    var y: number;\n\
    \    var z: number;\n    var u: number;\n    var v: number;\n    var w: number;\n\
    \    var x: number;\n    var y: number;\n    var z: number;\n    var u: number;\n\
    \    var v: number;\n    var w: number;\n    var x: number;\n    var y: number;\n\
    \    var z: number;\n    var u: number;\n    var v: number;\n    var w: number;\n\
    \    var x: number;\n    var y: number;\n    var z: number;\n    var u: number;\n\
    \    var v: number;\n    var w: number;\n    var x: number;\n    var y: number;\n\
    \    var z: number;\n    var u: number;\n    var v: number;\n    var w: number;\n\
    \    var x: number;\n    var y: number;\n    var z: number;\n    var u: number;\n\
    \    var v: number;\n    var w: number;\n    var x: number;\n    var y: number;\n\
    \    var z: number;\n    var u: number;\n    var v: number;\n    var w: number;\n\
    \    var x: number;\n    var y: number;\n    var z: number;\n    var u: number;\n\
    \    var v: number;\n    var w: number;\n    var x: number;\n    var y: number;\n\
    \    var z: number;\n    var u: number;\n    var v: number;\n    var w: number;\n\
    \    var x: number;\n    var y: number;\n    var z: number;\n    var u: number;\n\
    \    var v: number;\n    var w: number;\n    var x: number;\n    var y: number;\n\
    \    var z: number;\n    var u: number;\n    var v: number;\n    var w: number;\n\
    \    var x: number;\n    var y: number;\n    var z: number;\n    var u: number;\n\
    \    var v: number;\n    var w: number;\n    var x: number;\n    var y: number;\n\
    \    var z: number;\n    var u: number;\n    var v: number;\n    var w: number;\n\
    \    var x: number;\n    var y: number;\n    var z: number;\n", "  let result:\
    \ number[] = []; // Loop over both arrays\n  let llen1 = l1.length; // Current\
    \ length of first array\n  let llen2 = l2.length; // Current length of second\
    \ array\n\n  for (let i = 0; i < llen1; i++) {\n    let j;\n\n    for (j = 0;\
    \ j < llen2; j++) {\n      if (l1[i] === l2[j]) {\n        result.push(l1[i]);\n\
    \      }\n    }\n  } // Return unique values\n  return Array.from(new Set(result));\n\
    }\n", "  return l1.filter(function(i) {\n    return l2.indexOf(i) >= 0;\n  });\n\
    }\n", "    if (l1.length === 0) {\n        return l2;\n    }\n    var i: number,\
    \ len1: number = l1.length;\n    for (i = 0, len2 = l2.length; i < len2; i++)\
    \ {\n        if (l1[i] !== l2[i]) {\n            return [];\n        }\n    }\n\
    \    return l1;\n}\nexport function uniq<T extends object>(array: T[]): T[] {\n\
    \    const map = new Map<any, boolean>();\n    const result: T[] = [];\n    for\
    \ (let i = 0; i < array.length; i++) {\n        const item = array[i];\n     \
    \   if (!map.has(item.id)) {\n            result.push(item);\n            map.set(item.id,\
    \ true);\n        }\n    }\n    return result;\n}\n", "  let set1: number[] =\
    \ [];\n  let set2: number[] = [];\n  for (let i = 0; i < l1; i++) {\n    set1.push(l1[i]);\n\
    \  }\n  for (let i = 0; i < l2; i++) {\n    set2.push(l2[i]);\n  }\n  return Array.from(new\
    \ Set([].concat(set1, set2)));\n}\n", "  return [\n    ...l1,\n    ...l2.filter((value)\
    \ => l1.indexOf(value) === -1),\n  ]\n}\n", "  return unique(l1).filter(x => l2.indexOf(x)\
    \ !== -1);\n}\n", "  let lcm = [0];\n  for (let i = 0; i < l1.length; i++) {\n\
    \    let mul = l1[i] > l2[i] ? l1[i] : l2[i];\n    lcm[0] = lcm[0] + (mul * i);\n\
    \  }\n  return lcm;\n}\n", "    const l1: number[] = [];\n    const l2: number[]\
    \ = [];\n    const i: number = 0;\n    let j: number = 0;\n    const k1: number\
    \ = 0;\n    let k2: number = 0;\n\n    while (i + 1 < l1.length && j + 1 < l2.length\
    \ && l1[i] === l2[j]) {\n        l1[i++]++;\n        l2[j++]++;\n    }\n\n   \
    \ while (i < l1.length) {\n        l1[i++]++;\n    }\n\n    while (j < l2.length)\
    \ {\n        l2[j++]++;\n    }\n\n    while (i + 1 < l1.length) {\n        k1\
    \ = l1[i];\n        k2 = l2[j];\n        if (k1 < k2) {\n            l1.splice(i,\
    \ 1);\n        } else {\n            l2.splice(j, 1);\n        }\n\n        i\
    \ += 1;\n        j += 1;\n    }\n\n    return l1;\n}\n", "    var ret: number[]\
    \ = [],\n        l1 = l1 || [];\n    var l2 = l2 || [];\n    var i: number,\n\
    \        j: number,\n        len1: number;\n    var len2: number;\n    for (i\
    \ = 0, len1 = l1.length; i < len1; i += 1) {\n        j = -1;\n        for (i\
    \ = 0, len2 = l2.length; i < len2; i += 1) {\n            if (l2[i] === l1[j])\
    \ {\n                j = i;\n                break;\n            }\n        }\n\
    \        if (j === -1) {\n            ret.push(l1[i]);\n        }\n    }\n   \
    \ return ret;\n}\n", "    let result: number[] = [];\n    for (let i = 0; i <\
    \ l1.length; i++) {\n        for (let j = 0; j < l2.length; j++) {\n         \
    \   if (l1[i] === l2[j]) {\n                result.push(l1[i]);\n            \
    \    break;\n            }\n        }\n    }\n    return result;\n}\n", "  const\
    \ hashSet1 = new Set(l1);\n  const hashSet2 = new Set(l2);\n  return l1.filter(item\
    \ => l2.indexOf(item) !== -1).filter(item => hashSet1.has(item) && hashSet2.has(item));\n\
    }\n", "  let l1 = l1 || [];\n  let l2 = l2 || [];\n  let out = [];\n  let index1\
    \ = -1;\n  let index2 = -1;\n  while (++index1 < l1.length) {\n    while (++index2\
    \ < l2.length) {\n      if (l1.indexOf(l2[index2]) !== -1) out.push(l2[index2]);\n\
    \    }\n  }\n  return out;\n}\n", "  const sortedArr1 = sort(l1);\n  const sortedArr2\
    \ = sort(l2);\n  const uniqueArr = new Set([...sortedArr1, ...sortedArr2]);\n\
    \  return [...uniqueArr];\n}\n", "    const a1 = l1.length;\n    const a2 = l2.length;\n\
    \    const result = new Array(a1);\n\n    for (let i = 0; i < a1; i++) {\n   \
    \     const foundIndex = -1;\n        for (let j = 0; j < a2; j++) {\n       \
    \     if (l1[i] === l2[j]) {\n                foundIndex = j;\n              \
    \  break;\n            }\n        }\n        if (foundIndex !== -1) {\n      \
    \      result[i] = l1[i];\n        } else {\n            result.splice(i, 0, l1[i]);\n\
    \        }\n    }\n    return result.sort();\n}\n", "  const s = new Set();\n\
    \  const e = new Array();\n  for (let i = 0; i < l1.length; i++) {\n    if (!s.has(l1[i]))\
    \ {\n      s.add(l1[i]);\n      e.push(l1[i]);\n    }\n  }\n\n  for (let i = 0;\
    \ i < l2.length; i++) {\n    if (!s.has(l2[i])) {\n      s.add(l2[i]);\n     \
    \ e.push(l2[i]);\n    }\n  }\n\n  return e;\n}\n", "  const _common = new Set<number>();\n\
    \  for (let i = 0; i < l1.length; i++) {\n    const val = l1[i];\n    if (val\
    \ !== undefined && l2.indexOf(val) > -1) _common.add(val);\n  }\n  for (let j\
    \ = 0; j < l2.length; j++) {\n    const val = l2[j];\n    if (val !== undefined\
    \ && _common.has(val)) _common.delete(val);\n  }\n  return Array.from(_common);\n\
    }\n", "  const sorted1 = l1.slice().sort();\n  const sorted2 = l2.slice().sort();\n\
    \  let j = 0;\n  let i = 0;\n  const result = [];\n\n  while (sorted1[j] === sorted2[i])\
    \ {\n    j++;\n    i++;\n  }\n\n  while (i < sorted2.length) {\n    result.push(sorted2[i]);\n\
    \    i++;\n  }\n\n  while (j < sorted1.length) {\n    result.push(sorted1[j]);\n\
    \    j++;\n  }\n\n  return result;\n}\n</code>\n<|/ a tags=javascript,algorithm\
    \ dscore=3 |>\n<| c |>\nThis should be the accepted answer. The best answer I\
    \ found was the one by Nils, but it's still not 100% correct.\n<|/ c |>\n<| c\
    \ |>\nThe above solution is correct and I upvoted it, but I believe a more complete\
    \ solution exists that avoids creating arrays and using additional arrays in memory\
    \ during sorting. Plus, the accepted answer is very bad as it's sorting with O(n^2).\
    \ Your solution is better.\n<|/ c |>\n<| c |>\nNice solution. However you made\
    \ a small mistake and used `while j < sorted2.length` instead of `while i < sorted2.length`.\
    \ `j++` should be done before `result.push(sorted2[i]);` otherwise the `result.length`\
    \ will be incorrect because `sorted2[i]` will be equal to `sorted2[i - 1]` in\
    \ the next iteration.\n<|/ c |>\n<| a tags=javascript,algorithm |>\nYou can achieve\
    \ it by iterating over each element, removing it from the list, and checking to\
    \ see if the list is empty afterwards.\n<code>", "  const l = []\n  const maxLen\
    \ = Math.min(l1.length, l2.length)\n  let max = 0\n\n  l1.map((el, i) => {\n \
    \   if (l2.length < maxLen) {\n      max = Math.max(max, l2.length)\n      l.push([])\n\
    \    }\n    l[l.length - 1].push(el)\n  })\n\n  for (let i = maxLen - 1; i >=\
    \ 0; i--) {\n    l = l.filter(item => item.length <= i)\n    if (l.length < 2)\
    \ {\n      l.push([])\n    }\n  }\n  return l.reduce((acc, cur) => {\n    return\
    \ acc.concat(cur)\n  })\n}\n", "  if (l1.length != l2.length)\n    throw Error(`Lists\
    \ must have the same length`)\n\n  let ret: string[] = []\n  for (let i = 0; i\
    \ < l1.length; i++) {\n    const e1 = l1[i]\n    for (let j = 0; j < l2.length;\
    \ j++) {\n      const e2 = l2[j]\n      if (e1 == e2)\n        ret.push(e1)\n\
    \      else if (e1 > e2)\n        break\n    }\n  }\n  return ret\n}\n", "  const\
    \ n1 = l1.length;\n  const n2 = l2.length;\n\n  if (n1 === 0) {\n    return l2;\n\
    \  }\n  if (n2 === 0) {\n    return l1;\n  }\n\n  // sort first by length\n  l1.sort((a,\
    \ b) => a > b ? 1 : a < b ? -1 : 0);\n  l2.sort((a, b) => a > b ? 1 : a < b ?\
    \ -1 : 0);\n\n  const l1dl = l1[0].length;\n  const l2dl = l2[0].length;\n\n \
    \ const result: number[] = [];\n  let a1, a2;\n  let b;\n\n  for (let i = 0; i\
    \ < n1; i++) {\n    a1 = l1[i];\n    for (i = 0; i < n2; i++) {\n      a2 = l2[i];\n\
    \n      b = a1[l1dl] === a2[l2dl] ? a1 : a2;\n      if (result.indexOf(b) < 0)\
    \ {\n        result.push(b);\n      }\n    }\n  }\n\n  return result;\n}\n\nconst\
    \ _parseHTML = /*#__PURE__*/function () {\n  function _parseHTML(html: string,\
    \ options: Options): HTMLElement | undefined {\n    const doc = typeof document\
    \ === 'undefined' ? undefined : document;\n    if (typeof html === 'string') {\n\
    \      return (doc || document!).querySelector(html);\n    }\n    if (typeof html\
    \ === 'object') {\n      return html;\n    }\n    return undefined;\n  }\n\n \
    \ return _parseHTML;\n}();\n", "  let l: number[] = []\n  for (let i = 0; i <\
    \ l1.length; i++) {\n    let e1 = l1[i]\n    for (let j = 0; j < l2.length; j++)\
    \ {\n      let e2 = l2[j]\n      if (e1 === e2) {\n        l.push(e1)\n      }\n\
    \    }\n  }\n  return l\n}\n", "  const common = [];\n  let i = 0;\n  for (let\
    \ j = 0, jLen = l2.length; j < jLen; j++) {\n    while (i !== -1 && l1[i - 1]\
    \ === l2[j]) {\n      common.push(l1[i - 1]);\n      i++;\n    }\n    if (i !==\
    \ -1) {\n      common.push(l2[j]);\n      i = -1;\n    }\n  }\n  return common;\n\
    }\n", "  const l1_hash_set = new Set(l1);\n  const l2_hash_set = new Set(l2);\n\
    \  const l12 = [] as number[];\n  l1.forEach((item) => {\n    if (l2.indexOf(item)\
    \ >= 0) {\n      l12.push(item);\n    }\n  });\n  l2.forEach((item) => {\n   \
    \ if (l1.indexOf(item) >= 0) {\n      l12.push(item);\n    }\n  });\n  const l12_hash_set\
    \ = new Set(l12);\n  return Array.from(l1_hash_set).concat(Array.from(l2_hash_set)).filter((item)\
    \ => l12_hash_set.has(item));\n}\n", "  const result: number[] = [];\n  const\
    \ array1 = l1; // If first array is empty, add first array items to result\n \
    \ if (!array1.length) {\n    result.push(...l1);\n  }\n  const array2 = l2; //\
    \ If second array is empty, add second array items to result\n  if (!array2.length)\
    \ {\n    result.push(...l2);\n  }\n  // Iterate through both arrays\n  for (let\
    \ i = 0; i < Math.min(array1.length, array2.length); i++) {\n    // Compare element\
    \ from array1 with element from array2\n    if (array1[i] !== array2[i]) {\n \
    \     // If element from first array is found on second array, add it to the result\n\
    \      if (array1[i] === array2[i]) {\n        result.push(array1[i]);\n     \
    \ }\n      // If element from first array is found on second array, remove it\
    \ from the second array\n      else {\n        array2.splice(i, 1);\n        i--;\n\
    \      }\n    }\n  }\n  // Return result\n  return result;\n}\n", "  const set1\
    \ = new Set(l1);\n  const set2 = new Set(l2);\n  const result = [];\n\n  for (const\
    \ el of set1) {\n    if (set2.has(el)) {\n      result.push(el);\n    }\n  }\n\
    \  return result;\n}\n", "  l1 = l1.filter(function(value: number) { return !l2.includes(value);\
    \ });\n  l2 = l2.filter(function(value: number) { return !l1.includes(value);\
    \ });\n  return l1.filter(function(value: number) { return l2.includes(value);\
    \ });\n}\n", "  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const\
    \ ret = new Set();\n  for (let item of set1) {\n    if (!set2.has(item)) {\n \
    \     ret.delete(item);\n    } else {\n      ret.add(item);\n    }\n  }\n  for\
    \ (let item of set2) {\n    if (!set1.has(item)) {\n      ret.add(item);\n   \
    \ }\n  }\n  return [...ret];\n}\n", "  return [].concat(...l1.filter(x => l2.indexOf(x)\
    \ !== -1), ...l2.filter(x => l1.indexOf(x) !== -1));\n}\n", "  const result =\
    \ [];\n  const n = Math.min(l1.length, l2.length);\n  for (let i = 0; i < n; i++)\
    \ {\n    if (l1[i] !== l2[i]) result.push(l1[i]);\n  }\n  return result;\n}\n",
  "  var l1 = l1 || [];\n  var l2 = l2 || [];\n\n  var common: number[] = [];\n  while\
    \ (l1.length > 0 && l2.length > 0) {\n    if (l1[0] !== l2[0]) {\n      return\
    \ l1.slice(0, l1.length);\n    }\n    l1.shift();\n    l2.shift();\n    common.unshift(l1[0]);\n\
    \  }\n\n  return common;\n}\n", "  return sort(unique(l1.concat(l2)));\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=sorting,unique,typescript,arrays |>\n<code>\nvar\
    \ array1 = [3, 2, 5, 1, 4, 3];\nvar array2 = [2, 5, 3, 1, 2, 4];\nvar commonArray\
    \ = array1.filter(function (elem, index, self) { \n    return self.indexOf(elem)\
    \ === index; \n});\nconsole.log(commonArray);\n</code>\n<|/ a |>\n<| a tags=sorting,unique,typescript,arrays\
    \ dscore=0 |>\nHere is the solution that sorts the two arrays, performs a linear\
    \ search, and then puts those elements into the common array.\n\n<code>", "  \
    \  let ls = l1.length >= l2.length ? l1 : l2;\n    for (let i = 0; i < ls.length;\
    \ i++) {\n        if (l1.length !== l2.length) return ls.slice(i);\n        if\
    \ (ls[i] !== ls[ls[i]]) return ls.slice(i);\n    }\n    return ls;\n}\n", "  var\
    \ n1 = l1.length,\n    n2 = l2.length,\n    i,\n    part,\n    comp;\n\n  if (n1\
    \ < n2) return [];\n\n  // find out greatest common divisor\n  for (i = 0; i <\
    \ n1; i++) {\n    part = l1[i];\n    comp = gcd(l2[--n2], part);\n    if (comp\
    \ > 0) {\n      l1[i] += comp;\n      l2[n2] += comp;\n    }\n  }\n\n  // unify\
    \ l1[n2] with l1, if necessary\n  for (; i < n2; i++) {\n    part = 0;\n    comp\
    \ = gcd(l1[n1 - i], l2[i - n2]);\n    if (comp > 0) {\n      l1[n1 - i] += comp;\n\
    \      l2[i - n2] += comp;\n      part++;\n    }\n    l1[n1 - i] = part;\n   \
    \ l2[i - n2] = part;\n  }\n\n  return l1;\n}\n", "  var ret = [];\n  for (var\
    \ i = 0; i < l1.length; i++) {\n    for (var j = 0; j < l2.length; j++) {\n  \
    \    if (l1[i] === l2[j]) {\n        ret.push(l1[i]);\n      }\n    }\n  }\n \
    \ return ret;\n}\n", "  const result: number[] = [];\n  const o1: number[] = [];\n\
    \  const o2: number[] = [];\n  let j = 0;\n  for (let i = 0; i < l1.length; i++)\
    \ {\n    o1[j] = l1[i];\n    j++;\n  }\n  for (let i = 0; i < l2.length; i++)\
    \ {\n    o2[j] = l2[i];\n    j++;\n  }\n  while (i1 < l1.length) {\n    while\
    \ (o1.length > 0) {\n      const key = o1.shift();\n      if (o2.indexOf(key)\
    \ === -1) {\n        result.push(key);\n      }\n    }\n    i1++;\n  }\n  while\
    \ (i2 < l2.length) {\n    while (o2.length > 0) {\n      const key = o2.shift();\n\
    \      if (o1.indexOf(key) === -1) {\n        result.push(key);\n      }\n   \
    \ }\n    i2++;\n  }\n  return result;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=arrays,javascript,array-merge\
    \ |>\nYou need just two for loops, one to iterate through your first array, and\
    \ another to iterate through your second array. The algorithm would be something\
    \ like this:\n<code>\nlet arr1 = [2, 3, 5, 6];\nlet arr2 = [1, 3, 4, 5];\n\nlet\
    \ arr3 = arr1.slice();\narr3.sort(function(a, b) {\n  return a - b;\n});\n\nlet\
    \ arr4 = arr2.slice();\narr4.sort(function(a, b) {\n  return a - b;\n});\n\nfor\
    \ (let i = 0; i < arr3.length; i++) {\n  for (let j = 0; j < arr4.length; j++)\
    \ {\n    if (arr3[i] === arr4[j]) {\n      arr3.splice(i, 1);\n      arr4.splice(j,\
    \ 1);\n      i--;\n      j--;\n    }\n  }\n}\n\narr3.push(...arr4);\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nAs pointed out, this problem can be solved using nested\
    \ loops. An implementation using a few utility functions:\n<code>", "    if (l1\
    \ === null || l2 === null) { return null; }\n    var i: number = 0,\n        l1Len\
    \ = l1.length,\n        l2Len = l2.length,\n        result = [],\n        l1End\
    \ = l1Len + 1,\n        l2End = l2Len + 1,\n        index = 0,\n        val;\n\
    \    while (true) {\n        if (index < l1End && index < l2End) {\n         \
    \   if (l1.charAt(index) === l2.charAt(index)) {\n                result.push(l1.charAt(index));\n\
    \                ++index;\n            }\n            else if (l1.charAt(index)\
    \ > l2.charAt(index)) {\n                ++index;\n            }\n           \
    \ else {\n                ++index;\n            }\n        }\n        else if\
    \ (index < l1End) {\n            result.push(l1.charAt(index));\n            ++index;\n\
    \        }\n        else if (index < l2End) {\n            result.push(l2.charAt(index));\n\
    \            ++index;\n        }\n        else {\n            break;\n       \
    \ }\n    }\n    return result;\n}", "  var i: number;\n  var j: number;\n  var\
    \ k: number;\n  var l: number = l1.length;\n  var m = l2.length;\n  var n: number\
    \ = l;\n  var common: number[] = [];\n  for (i = 0; i <= m; i++) {\n    for (j\
    \ = (i + 1) % n; j <= m; j++) {\n      for (k = (j + 1) % n; k <= m; k++) {\n\
    \        if (l1[i >> k] === l2[i >> k & k]) {\n          common[i++] = l1[i >>\
    \ k];\n        }\n      }\n    }\n  }\n  return common;\n}\n", "  if (l1.length\
    \ === 0 || l2.length === 0) {\n    return [];\n  }\n  const m = Math.max(l1.length,\
    \ l2.length);\n  const l3: string[] = new Array(m);\n  for (let i = 0; i < m;\
    \ ++i) {\n    l3[i] = i < l1.length ? l1[i] : i < l2.length ? l2[i] : '';\n  }\n\
    \  l3.sort();\n  return l3;\n}\n", "  const out: number[] = [];\n  const seen\
    \ = new Set<number>();\n  for (let i = 0; i < l1.length; ++i) {\n    if (seen.has(l1[i]))\
    \ continue;\n    for (let j = 0; j < l2.length; ++j) {\n      if (seen.has(l2[j]))\
    \ continue;\n      if (l1[i] === l2[j]) {\n        out.push(l1[i]);\n        seen.add(l1[i]);\n\
    \        break;\n      }\n    }\n  }\n  return out;\n}\n", "  const l1map = new\
    \ Set(l1),\n        l2map = new Set(l2);\n  return [...l1map].filter(x => l2map.has(x))\n\
    \    .concat(\n      [...l2map].filter(x => !l1map.has(x)));\n}\n", "  let out\
    \ = [];\n  for (let i = 0; i < Math.min(l1.length, l2.length); i++) {\n    if\
    \ (l1[i] === l2[i]) {\n      continue;\n    }\n    let t = l1[i];\n    if (out.indexOf(t)\
    \ !== -1) {\n      continue;\n    }\n    out.push(t);\n  }\n  return out;\n}\n",
  "  const ret = [];\n  const o1 = {};\n  const o2 = {};\n  for (let i = 0; i < l1;\
    \ i++) {\n    o1[l1[i]] = true;\n  }\n  for (let j = 0; j < l2; j++) {\n    o2[l2[j]]\
    \ = true;\n  }\n  for (let k in o1) {\n    for (let l in o2) {\n      if (o1[k]\
    \ === o2[l]) {\n        ret.push(k);\n        break;\n      }\n    }\n  }\n  return\
    \ ret;\n}\n", "  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const\
    \ result = [];\n  for (let i = 0; i < Math.min(set1.size, set2.size); i++) {\n\
    \    if (set1.has(i) && set2.has(i)) {\n      result.push(i);\n    }\n  }\n\n\
    \  return result;\n}\n", "    let result = new Array();\n    for(let i = 0; i<l1.length;\
    \ i++) {\n        for(let j = 0; j < l2.length; j++) {\n            if(l1[i]===l2[j])\
    \ {\n                result.push(l1[i]);\n                break;\n           \
    \ }\n        }\n    }\n    return result.sort();\n}\n", "  if (l1.length < l2.length)\
    \ {\n    return common(l2, l1);\n  }\n  let result = [];\n  let i = 0;\n  while\
    \ (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i]) {\n      result.push(l1[i]);\n\
    \      i++;\n      continue;\n    }\n    if (l1[i] < l2[i]) {\n      result.push(l1[i]);\n\
    \    } else {\n      result.push(l2[i]);\n    }\n    i++;\n  }\n  return result;\n\
    }\n", "  const common = new Set()\n  for (const i of l1) {\n    if (l2.indexOf(i)\
    \ !== -1) {\n      common.add(i)\n    }\n  }\n  return Array.from(common)\n}\n",
  "  return unique(l1, l2, (l, r) => {\n    const lc = l.length;\n    const rc = r.length;\n\
    \    let i = 0, j = 0;\n\n    while (i < lc && j < rc) {\n      if (l[i] === r[j])\
    \ {\n        i++;\n        j++;\n      } else if (l[i] < r[j]) {\n        i++;\n\
    \      } else {\n        j++;\n      }\n    }\n\n    return j === rc ? l : r;\
    \ // lc >= rc\n  });\n}\n", "  let i, minLen = Math.min(l1.length, l2.length);\n\
    \  let lcm = (l1.length + 1) * (l2.length + 1);\n  let u = [];\n  let v = [];\n\
    \  for (let i = 0; i < minLen; i++) {\n    u[i] = [];\n    v[i] = [];\n  }\n \
    \ for (let i = 0; i < l1.length; i++) {\n    u[l1[i]].push(l2[i]);\n  }\n  for\
    \ (let i = 0; i < l2.length; i++) {\n    v[l2[i]].push(l1[i]);\n  }\n  for (let\
    \ i = 0; i < minLen; i++) {\n    for (let j = 0; j < lcm; j++) {\n      if (u[i][j]\
    \ !== v[j]) {\n        break;\n      }\n    }\n    if (j === lcm) {\n      u.push([l2[i]]);\n\
    \      v.push([l1[i]]);\n    } else {\n      u[l2[i]].push(u[i][j]);\n      v[l1[i]].push(v[j]);\n\
    \    }\n  }\n  return u.map(function (arr) { return arr.sort((a, b) => a - b);\
    \ });\n}\n", "  const l = new Set(l1);\n  for (let i = 0; i < l2.length; i++)\
    \ {\n    l.add(l2[i]);\n  }\n  return [...l];\n}\n", "  const result = [];\n \
    \ const _max = Math.max(...l1, ...l2);\n  const _min = Math.min(...l1, ...l2);\n\
    \  for (let i = _min; i <= _max; i++) {\n    const l1 = l1.filter(e => e === i);\n\
    \    const l2 = l2.filter(e => e === i);\n    if (l1.length && l2.length) {\n\
    \      if (l1.length === l2.length) {\n        const _equal = l1.every(e => l2.includes(e));\n\
    \        if (_equal) {\n          result.push(i);\n        }\n      } else if\
    \ (l1.length >= l2.length) {\n        const _equal = l2.every(e => l1.includes(e));\n\
    \        if (_equal) {\n          result.push(i);\n        }\n      } else {\n\
    \        const _equal = l1.every(e => l2.includes(e));\n        if (_equal) {\n\
    \          result.push(i);\n        }\n      }\n    }\n  }\n  return result;\n\
    }\n", "  l1 = l1.slice();\n  l2 = l2.slice();\n  let a = [...l1].sort();\n  let\
    \ b = [...l2].sort();\n  let l = [];\n  while (!a.length && !b.length) {\n   \
    \ l.push(null);\n  }\n  if (!a.length || !b.length) {\n    return l;\n  }\n  let\
    \ j = 0;\n  for (let i = a.length - 1; i >= 0; i--) {\n    while (!l[j] && a[i]\
    \ === b[j]) {\n      j++;\n    }\n    if (l[j]) {\n      l[j] = a[i];\n    }\n\
    \  }\n  for (let i = b.length - 1; i >= 0; i--) {\n    while (!l[j] && b[i] ===\
    \ a[j]) {\n      j++;\n    }\n    if (l[j]) {\n      l[j] = b[i];\n    }\n  }\n\
    \  return l;\n}\n", "    const n = Math.min(l1.length, l2.length);\n    const\
    \ result: number[] = new Array(n);\n    for (let i = 0; i < n; i++) {\n      \
    \  if (l1.indexOf(l2[i]) !== -1) {\n            result[i] = l1[i];\n        }\n\
    \    }\n    return result;\n}\n", "  return l1.concat(l2)\n    .sort()\n    .filter(function(elem,\
    \ pos) {\n      return l2.indexOf(elem) == pos;\n    });\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
