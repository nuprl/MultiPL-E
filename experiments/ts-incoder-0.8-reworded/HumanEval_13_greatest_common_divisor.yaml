name: HumanEval_13_greatest_common_divisor
language: ts
prompt: "//Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor(3,\
  \ 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n// 5\nfunction greatest_common_divisor(a:\
  \ number, b: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = greatest_common_divisor;\n  assert.deepEqual(candidate(3,\
  \ 7),1);\n  assert.deepEqual(candidate(10, 15),5);\n  assert.deepEqual(candidate(49,\
  \ 14),7);\n  assert.deepEqual(candidate(144, 60),12);\n}\n\ntest();"
completions: ["  if (b === 0) {\n    return a;\n  }\n  return greatest_common_divisor(b,\
    \ a % b);\n}\n", "  if (a === 0) // ensure a is a positive integer\n    return\
    \ b;\n  if (b === 0) // ensure b is a positive integer\n    return a;\n  // ensure\
    \ both a and b are positive integers\n  if (a < b)\n    return gcd(b, a % b);\n\
    \  // ensure a is larger than b\n  return gcd(b, a % b);\n}\n", "    while (b\
    \ !== 0) {\n        a = a % b;\n        if (a === 0) {\n            return b;\n\
    \        }\n        b = b % a;\n    }\n    return a;\n}\n", "    if (b === 0)\
    \ {\n        return a;\n    }\n\n    a = to_int32(a);\n    b = to_int32(b);\n\n\
    \    let t: number, s: number;\n\n    t = a % b;\n    s = a - t;\n    while (s\
    \ !== 0) {\n        s = s + b;\n        t = t - b;\n    }\n\n    return t;\n}\n",
  "  if (b === 0) {\n    return a;\n  }\n\n  // Both positive\n  if (a >= b) {\n \
    \   return b;\n  }\n\n  // Both negative\n  if (a < b) {\n    return a;\n  }\n\
    \n  // one positive\n  if (a > b) {\n    return b;\n  }\n\n  // one negative\n\
    \  if (a < b) {\n    return a;\n  }\n\n  // equal positive\n  return a;\n}\n\n\
    export class Elements extends AbstractMap<string, HTMLElement> {\n  private elements\
    \ = new Map<string, HTMLElement>();\n\n  public append(key: string, element: HTMLElement):\
    \ void {\n    if (!this.has(key)) {\n      this.elements.set(key, element);\n\
    \    }\n  }\n\n  public has(key: string): boolean {\n    return this.elements.has(key);\n\
    \  }\n\n  public get(key: string): HTMLElement | undefined {\n    return this.elements.get(key);\n\
    \  }\n\n  public set(key: string, element: HTMLElement): void {\n    this.elements.set(key,\
    \ element);\n  }\n\n  public delete(key: string): void {\n    this.elements.delete(key);\n\
    \  }\n\n  public keys() { return this.elements.keys(); }\n\n  public values()\
    \ { return this.elements.values(); }\n\n  public entries() { return this.elements.entries();\
    \ }\n\n  public clear(): void {\n    this.elements.clear();\n  }\n\n  public forEach(callbackfn:\
    \ (value: any, key: any, map: Elements) => void, thisArg?: any): void {\n    this.elements.forEach(callbackfn,\
    \ thisArg);\n  }\n\n  public reduce<U>(callbackfn: (previousValue: U, currentValue:\
    \ HTMLElement, key: any, map: Elements) => U, initialValue?: U): U {\n    return\
    \ this.elements.reduce(callbackfn, initialValue);\n  }\n\n  public find(callbackfn:\
    \ (value: HTMLElement, key: any, map: Elements) => boolean, thisArg?: any): HTMLElement\
    \ | undefined {\n    return this.elements.find(callbackfn, thisArg);\n  }\n}\n\
    \nexport class CustomEvent<T = any> extends AbstractEvent<CustomEventDataWithProperties<T>>\
    \ {\n  static EVENT_NAME_PREFIX = 'custom-';\n  private static EVENT_NAME_DELIMITER\
    \ = '-';\n  private static EVENT_NAME_UNDERSCORE = '_';\n\n  public readonly [CustomEventSymbols.EVENT_NAME]\
    \ = `${CustomEvent.EVENT_NAME_PREFIX}${CustomEvent.EVENT_NAME_DELIMITER}${T}`;\n\
    \n  public readonly [CustomEventSymbols.EVENT_NAME_UNDERSCORE] = `${CustomEvent.EVENT_NAME_PREFIX}${CustomEvent.EVENT_NAME_UNDERSCORE}${T}`;\n\
    \n  public readonly [CustomEventSymbols.EVENT_NAME_CAPITALIZED] = `${CustomEvent.EVENT_NAME_PREFIX}${",
  "  // https://en.wikipedia.org/wiki/Euclidean_algorithm\n  // gcd(a, 0) = a\n  //\
    \ gcd(a, b) = gcd(b, a mod b)\n  // => gcd(a, b) = gcd(b, a mod b)\n  // => gcd(a,\
    \ b) = gcd(b, a mod b)\n  // => gcd(a, b) = gcd(b, greatest common divisor of\
    \ a and b)\n  // => gcd(a, b) = gcd(b, greatest common divisor of a and b)\n \
    \ // => gcd(a, b) = gcd(b, greatest common divisor of a and b)\n  while (b !==\
    \ 0) {\n    const t = a; a = b; b = t % b\n  }\n  return a\n}\n", "\tif (a ===\
    \ 0 && b === 0) {\n\t\treturn 0;\n\t}\n\treturn greatest_common_divisor_cached(a,\
    \ b);\n}", "  let divisor = a;\n  let rem = b;\n  while (rem !== 0) {\n    rem\
    \ = parseInt(rem / divisor, 10);\n    divisor++;\n  }\n  return divisor;\n}",
  "  if (b === 0) return a;\n  if (a === 0) return b;\n  let c = 1;\n  let d = b;\n\
    \  while (d % a === 0) {\n    d = Math.floor(d / a);\n    c++;\n  }\n  return\
    \ c;\n}\n", "  if (b === 0) return a;\n  if (!a) return b;\n  if (!b) return a;\n\
    \  return greatest_common_divisor(b, a % b);\n}\n", "    if (Math.abs(a) === 1\
    \ && Math.abs(b) === 1) return a;\n    if (Math.abs(b) === 1) return b;\n    if\
    \ (Math.abs(a) === 1) return Math.abs(b) > 0 ? (a / b) | 0 : b;\n    // tslint:disable-next-line:only-arrow-functions\n\
    \    return Math.round((a * b) / greatest_common_divisor(b, a % b));\n}\n", " \
    \   while (b !== 0) {\n        const tmp = a\n        a = b\n        b = tmp %\
    \ b\n    }\n    return a\n}\n", "    let gcd: number = 1;\n    while (b !== 0)\
    \ {\n        let remainder: number = a % b;\n        a = b;\n        b = remainder;\n\
    \        gcd *= b;\n    }\n    return gcd;\n}\n", "  // Easy case: remainder ===\
    \ 0\n  if (a === 0) return b;\n  // Remainder from division\n  let r = a % b;\n\
    \  // Get difference between remainder and b (i.e. b)\n  // This will be zero\
    \ if the two numbers divide evenly\n  const c = b - r;\n  // Return the max of\
    \ r and b\n  return (r + c) % b;\n}\n", "  while (b !== 0) {\n    const t = a\
    \ % b\n    a = b\n    b = t\n  }\n  return a\n}\n", "\tif (a === 0 && b === 0)\
    \ return 0;\n\telse if (a === 0) return b;\n\telse if (b === 0) return a;\n\t\
    else if (a === b) return a;\n\telse if (a < b) \n\t\t[a, b = b] = [b, a];\n\n\t\
    let rv = a;\n\t\n\tfor (let i = 1; i <= b; i++) {\n\t\tconst c = a % i;\n\t\t\
    if (c != 0) {\n\t\t\trv = (rv + i) / c;\n\t\t}\n\t}\n\n\treturn rv;\n}\n", " \
    \   if (b === 0) {\n        return a;\n    }\n    else {\n        return greatest_common_divisor(b,\
    \ a % b);\n    }\n}", "  if (a === 0) {\n    return b === 0 ? 0 : 1;\n  }\n  if\
    \ (b === 0) {\n    return a === 0 ? 0 : 1;\n  }\n  if (a === 1) {\n    return\
    \ 1;\n  }\n  if (b === 1) {\n    return 1;\n  }\n  if (a === 2) {\n    return\
    \ a;\n  }\n  if (b === 2) {\n    return b;\n  }\n  if (a === b) {\n    return\
    \ a;\n  }\n  if (a === Math.floor(a) && b === Math.floor(b)) {\n    return (a\
    \ % b + b) % b;\n  }\n  return a;\n}\n", "  const is_negative = (a * -1 > b);\n\
    \  if (is_negative) {\n    if (b > 0) return a;\n    return -b;\n  }\n  if (b\
    \ > 0) return b;\n  return a;\n}\n", "  let rs = 1;\n  let t = b - a;\n  while\
    \ (t >= 2) {\n    rs = (rs % t) | 0;\n    t = t >>> 1;\n  }\n  return rs;\n}\n",
  "    // http://en.wikipedia.org/wiki/Euclidean_algorithm\n    let t = 0;\n    let\
    \ q: number = 0;\n    let n: number;\n    while (a != 0) {\n        n = a % b;\n\
    \        a = b;\n        b = n;\n        t = t;\n        ++q;\n    }\n    return\
    \ t;\n}\n", "  if (b == 0) {\n    return a;\n  }\n\n  return greatest_common_divisor(b,\
    \ a % b);\n}\n", "    while (b !== 0) {\n        const tmp = a;\n        a = b;\n\
    \        b = tmp % b;\n    }\n    return a;\n}\n\nexport class BlocksManager {\n\
    \    private readonly _chainManager: ChainManager;\n    private readonly _head:\
    \ Block;\n    private readonly _headBlockNumber: number;\n    private readonly\
    \ _nextBlocks: Block[];\n    private _prevBlock: Block;\n    private _nextBlock:\
    \ Block;\n\n    constructor(chainManager: ChainManager) {\n        this._chainManager\
    \ = chainManager;\n        this._head = new Block(0, \"genesis\", 1, []);\n  \
    \      this._headBlockNumber = 1;\n        this._nextBlocks = [this._head];\n\
    \        this._prevBlock = this._head;\n    }\n\n    get head(): Block {\n   \
    \     return this._head;\n    }\n\n    get headBlockNumber(): number {\n     \
    \   return this._headBlockNumber;\n    }\n\n    get nextBlocks(): Block[] {\n\
    \        return this._nextBlocks;\n    }\n\n    get prevBlock(): Block {\n   \
    \     return this._prevBlock;\n    }\n\n    get nextBlock(): Block {\n       \
    \ return this._nextBlock;\n    }\n\n    addBlock(block: Block, last?: boolean):\
    \ void {\n        if (last === true) {\n            this._prevBlock.next = this._prevBlock.next\
    \ = block;\n            this._nextBlock.prev = this._nextBlock.prev = block;\n\
    \        } else {\n            this._prevBlock.next = block;\n            this._nextBlock.prev\
    \ = block;\n        }\n        this._nextBlocks.push(block);\n        this._chainManager.onNewBlock(block);\n\
    \        this._headBlockNumber++;\n    }\n\n    hasBlock(number: number): boolean\
    \ {\n        for (let i = 1; i < this._headBlockNumber; i++) {\n            if\
    \ (this._blockAt(i).number === number) {\n                return true;\n     \
    \       }\n        }\n        return false;\n    }\n\n    get size(): number {\n\
    \        return this._headBlockNumber;\n    }\n\n    getBlock(number: number):\
    \ Block {\n        return this._blockAt(number);\n    }\n\n    private _blockAt(blockNumber:\
    \ number): Block {\n        for (let i = 0; i < this._headBlockNumber; i++) {\n\
    \            const block = this._blockAt(i);\n            if (block.number ===\
    \ blockNumber) {\n                return block;\n            }\n        }\n  \
    \      return undefined;\n    }\n\n    get lastBlock(): Block {\n        return\
    \ this._blockAt(this._headBlockNumber - 1);\n    }\n}\n\nexport class ChainManager\
    \ {\n    private _chains: BlocksManager[];\n    private _headBlocks: Block[];\n\
    \    private _chainHeads: Block[];\n    private _chainHeadsUpdated = false;\n\
    \    private _chainHeadsHashUpdated = false;\n    private _chainHeadsUpdatedPromise:\
    \ Promise<void>;\n\n    private _head: Block;\n", "  if ((a % b) === 0) return\
    \ b;\n  if (a >= (b & 1)) return b;\n  if (a >= (b | 0)) return b;\n  if (a >=\
    \ (a & 1)) return b;\n  return a;\n}\n", "  if (b === 0) return a;\n  if (a ===\
    \ 0) return b;\n  var r = a % b;\n  return r === 0 ? a : r;\n}", "  // Checks\
    \ a > b\n  if (a > b) {\n    // Checks a > b\n    return b;\n    // Checks a <\
    \ b\n  }\n  // Checks a < b\n  return a;\n}\n", "  if (a < b) return b;\n  if\
    \ (a > b) return a;\n  while (a % b != 0) {\n    a = a + b; \n  }\n  return a;\n\
    }\n", "  if (a < b) {\n    if (b === 0) return a;\n    if (b > a) return b;\n\
    \  } else {\n    if (a === 0) return b;\n    if (a > b) return a;\n  }\n}\n",
  "    if (b === 0) {\n        return a;\n    }\n\n    a = Math.abs(a);\n    b = Math.abs(b);\n\
    \n    if (a === 0) {\n        return b;\n    }\n\n    if (b === 0 || !(a === 0\
    \ || b === 0)) {\n        return 0;\n    }\n\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    const dividend = Math.min(a, b);\n    const divisor = b ? a - dividend :\
    \ Math.abs(b) - Math.abs(a);\n\n    while (divisor > 0) {\n        if (b === 0\
    \ || b === divisor) {\n            return divisor;\n        }\n\n        divisor--;\n\
    \    }\n\n    return Math.abs(a);\n}\n", "  if (b === 0) return a;\n  return gcd(b,\
    \ a % b);\n}\n", "  if (b === 0) return a;\n  if (!b) return a;\n  return gcd(a,\
    \ b);\n}\n", "  if (b === 0)\n    return a;\n  while (b !== 0) {\n    var rem:\
    \ number = a % b;\n    a = b;\n    b = rem;\n  }\n  return a;\n}\n", "  // https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \  while (b !== 0) {\n    a = a % b;\n    b = (b * a + 1) % b;\n  }\n  return\
    \ a;\n}\n\n<|/ file filename=graphql.ts ext=.ts |>", "  if (b === 0) {\n    return\
    \ a;\n  }\n  return greatest_common_divisor(b, a % b);\n}\n", "  if (a < 0) {\n\
    \    a = a % b;\n    if (a < 0) {\n      return -1;\n    }\n  } else if (a ===\
    \ 0 && b === 0 || b < 0) {\n    return 0;\n  }\n  if (a > b) {\n    a = a % b;\n\
    \    if (a > b) {\n      return 1;\n    }\n  }\n  return a % b;\n}\n\ntype MinMax\
    \ = { min: number; max: number };\ntype MinMaxValue = number | [number, number];\n\
    type MaxMin = { max: number; min: number };\ntype MaxMinValue = number | [number,\
    \ number];\n", "  let r: string[] = [];\n  while (a !== 0) {\n    r = [a.toString()];\n\
    \    a = b * Math.floor(a / b);\n  }\n  return r.join('');\n}\n", "  a = Math.abs(a)\n\
    \  b = Math.abs(b)\n  // Euclid's algorithm\n  // a / gcd(a, b) = gcd(b, a % b)\n\
    \  // with abs(a) > abs(b) we compute b / gcd(b, a % b)\n  // a >= b || a / gcd(a,\
    \ b) = gcd(a - b, b)\n  // see en.wikipedia.org/wiki/Euclidean_algorithm\n  let\
    \ gcd = a\n  let remain = b\n  // If b is zero, then any solution will be zero\n\
    \  if (b === 0) {\n    return 0\n  }\n\n  while (true) {\n    if (b === 0 || a\
    \ / b === gcd) {\n      return b\n    }\n    gcd = b\n    remain = a % b\n   \
    \ a = b\n    b = remain\n  }\n}\n", "  if (a < b) {\n    [a, b] = [b, a];\n  }\n\
    \n  while (a % b != 0 || b == 0) a = a / b;\n  return a;\n}\n", "    if (b ===\
    \ 0) return a;\n    if (b > a) return b;\n    if (b < a) return a;\n    while\
    \ (b !== 0) {\n        var q = Math.floor(a / b);\n        a = b;\n        b =\
    \ q;\n    }\n    return a;\n}", "  let gcd = a % b;\n  while (gcd !== 0) {\n \
    \   gcd = b % gcd ;\n  }\n  return gcd;\n}\n", "  if (a < b) {\n    a = b;\n \
    \ }\n  if (a % b === 0) {\n    return b;\n  }\n  return greatest_common_divisor(b,\
    \ a % b);\n}", "    a = Number(a);\n    b = Number(b);\n    if (a === 0) return\
    \ b;\n    if (b === 0) return a;\n    while (true) {\n        const a_m = a %\
    \ b;\n        if (a === 0) return b;\n        if (b === 0) return a;\n       \
    \ a = b;\n        b = a_m;\n    }\n}\n", "    return Math.abs(a * b) %\n     \
    \   (Math.abs(a) * Math.abs(b)) ||\n        Math.max(a, b);\n}\n", "  let max_divisor\
    \ = a < b ? b : a;\n  for(let i = max_divisor / 2; i > 0; i--) {\n    if( a %\
    \ i == 0 && b % i == 0) {\n      return i;\n    }\n  }\n  return max_divisor;\n\
    }\n", "  if (a === 0 && b === 0) {\n    return 0;\n  }\n\n  // Euclidian algorithm\n\
    \  // https://en.wikipedia.org/wiki/Euclidean_algorithm\n  while (b !== 0) {\n\
    \    const t = b;\n    b = a % t;\n    a = t;\n  }\n\n  return a;\n}\n", "  if\
    \ (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  return\
    \ gcd(a, b) / gcd(b, a);\n}\n", "    if (b === 0) {\n        return a;\n    }\n\
    \    let d = a % b;\n    while (d !== 0) {\n        d = b % a;\n        if (d\
    \ === 0) {\n            return b;\n        }\n        b = a;\n        a = d;\n\
    \    }\n    return a;\n}\n\nexport class RangeEditorComponent {\n    constructor()\
    \ {\n        this.range = new Range<number>(0, 0, 100, 1);\n        this.value\
    \ = new Value<number>(50);\n    }\n\n    getValue(): number {\n        return\
    \ this.value;\n    }\n    setValue(v: number) {\n        this.value = v;\n   \
    \ }\n\n    getRange(): Range<number> {\n        return this.range;\n    }\n  \
    \  setRange(range: Range<number>) {\n        this.range = range;\n    }\n}\n",
  "    if (b === 0) {\n        return a;\n    }\n\n    return gcd(a, b) / gcd(b, a);\n\
    }\n", "  if (b === 0) {\n    return a;\n  }\n  return greatest_common_divisor(b,\
    \ a % b);\n}\n", "  if (b !== 0) return ~~(Math.pow(b, a % b) / b);\n  return\
    \ NaN;\n}\n", "  if (isInteger(a) && isInteger(b)) {\n    if (b === 0) {\n   \
    \   return 1;\n    }\n    return gcd(b, a % b);\n  }\n  throw new TypeError('Invalid\
    \ arguments passed to greatest_common_divisor');\n}\n", "  if (b === 0) return\
    \ a;\n  return greatest_common_divisor(b, a % b);\n}\n", "  if (b === 0) {\n \
    \   return a;\n  }\n  return greatest_common_divisor(b, a % b);\n}\n", "  return\
    \ a === 0 ? b : greatest_common_divisor(b, a % b)\n}\n", "  if (b === 0) return\
    \ a;\n  if (b === 1) return a;\n  if (b === -1) return -a;\n  if (a % b === 0)\
    \ return b;\n  if (a % b === 1) return b + a;\n  if (a % b === -1) return -b;\n\
    \  return NaN;\n}\n", "  return a < b ? gcd(a, b) : gcd(b, a) % m;\n}\n", "  if\
    \ (a === 0 || b === 0) return 0\n  var t: (number, number)\n  if (a < b) {\n \
    \   t = a, b\n    a = b, b = t\n  }\n  if (a === b) return a\n  var g = 0, m =\
    \ 1\n  while (a != 0) {\n    while (a & m) g = a & g, m >>= 1\n    while (m !=\
    \ 0) {\n      if (m & 1) a = a\n      else b = b\n    }\n    m = 1\n  }\n  return\
    \ g\n}\n", "  if (b === 0) {\n    return a;\n  }\n\n  return greatest_common_divisor(b,\
    \ a % b);\n}\n", "  return a > b ? a : b;\n}\n", "    while (b !== 0) {\n    \
    \    const t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n\
    }\n", "  // Euclidian algorithm\n  // https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \  const dividend_1 = a * b;\n  const divisor = a % b;\n  while (divisor === 0)\
    \ {\n    divisor = b;\n    b = a / b;\n    a = a % b;\n  }\n  return dividend_1\
    \ === divisor ? a : -dividend_1 - (divisor - 1);\n}\n", "  let max_divisor = a\n\
    \  let min_divisor = b\n  while min_divisor != max_divisor {\n    min_divisor\
    \ = min_divisor < max_divisor ? min_divisor : max_divisor\n    max_divisor = max_divisor\
    \ % min_divisor\n  }\n  return max_divisor\n}\n", "  a /= b;\n  while (a < b)\
    \ {\n    a = a * 2;\n  }\n  return a;\n}", "  a = Math.abs(a)\n  b = Math.abs(b)\n\
    \  // Euclidian algorithm from Wikipedia.\n  // a / gcd(a, b) = s(a, b) / c(a,\
    \ b) = s(a, b) / a * b\n  // => a * b = c(a, b) / a\n  let gcd = a % b\n  while\
    \ (b !== 0) {\n    gcd = Math.floor(gcd)\n    b /= a\n    a = gcd\n  }\n  return\
    \ gcd\n}\n", "    if (b === 0) {\n        return a;\n    }\n    return greatest_common_divisor(b,\
    \ a % b);\n}\n", "  if (b === 0) return a;\n  return greatest_common_divisor(b,\
    \ a % b);\n}\n", "  if (b === 0) return 0;\n  if (a === 0) return b;\n  if (a\
    \ === 1) return b;\n  if (a === -1) return -b;\n  if (a === -2) return -b;\n \
    \ if (b === -1) return -a;\n  if (b === -2) return -a;\n  if (b === 3) return\
    \ 2;\n  if (b === 5) return a;\n  if (b === 7) return a;\n  if (a === 9) return\
    \ 9;\n  if (a === 10) return 16;\n  if (a === 12) return 8;\n  if (a === 14) return\
    \ 4;\n  if (a === 16) return 8;\n  return null;\n}\n", "  // We don't use isInteger\
    \ because it is slower and doesn't work on strings\n  const max_a = Math.max(a,\
    \ b)\n  const max_b = Math.max(b, a)\n  const min_a = Math.min(a, b)\n  const\
    \ min_b = Math.min(b, a)\n  return max_a === min_b ? max_a : max_b === min_a ?\
    \ max_b : greatest_common_divisor_long(max_a, max_b)\n}\n", "  // Euclidian division:\
    \ a\u207F / b\u207F = (a + b) \xF7 gcd(a, b)\n  return a % b ? greatest_common_divisor(b,\
    \ a % b) : b;\n}\n", "  if (b == 0) {\n    return a;\n  } else {\n    return greatest_common_divisor(b,\
    \ a % b);\n  }\n}\n\nexport function sort_object(obj: {[key: string]: any}): Array<{[key:\
    \ string]: any}> {\n  const keys = Object.keys(obj);\n  const ret = [];\n  keys.sort();\n\
    \  for (let i = 0; i < keys.length; i++) {\n    ret.push([keys[i], obj[keys[i]]]);\n\
    \  }\n  return ret;\n}\n\nexport function get_plot_dimensions(plotlyCanvas: {width:\
    \ number, height: number}, width: number, height: number, margin: {top: number,\
    \ right: number, bottom: number, left: number}) {\n  const plot_width = width\
    \ - margin.left - margin.right;\n  const plot_height = height - margin.top - margin.bottom;\n\
    \  return {\n    size: [plot_width, plot_height],\n    margin,\n  };\n}\n\nexport\
    \ function draw_table(\n    plotlyCanvas: {width: number, height: number},\n \
    \   data: Array<Array<{name: string, y: number}>>,\n    sort_column: string, sort_ascending:\
    \ boolean) {\n  const { size, margin } = get_plot_dimensions(plotlyCanvas, 100,\
    \ 100, {top: 30, right: 30, bottom: 30, left: 30});\n\n  const x = d3.scaleLinear().range([0,\
    \ size[1]]);\n  const y = d3.scaleLinear().range([size[0], 0]);\n\n  const svg\
    \ = d3.select(\"#plot_table\").append(\"svg\")\n    .attr(\"width\", size[0])\n\
    \    .attr(\"height\", size[1]);\n\n  const thead = svg.append(\"g\")\n    .attr(\"\
    transform\", `translate(${margin.left}, ${margin.top})`);\n\n  const tbody = svg.append(\"\
    g\")\n    .attr(\"transform\", `translate(${margin.left}, ${margin.top})`);\n\n\
    \  thead.selectAll(\"tr\")\n    .data(data)\n    .enter().append(\"tr\")\n   \
    \ .selectAll(\"td\")\n    .data(function (d) { return d; })\n    .enter().append(\"\
    td\")\n    .attr(\"class\", function (d) { return \"cell-td\"; })\n    .text(function\
    \ (d) { return d.name; });\n\n  x.domain([0, d3.max(data, function (d) { return\
    \ d.y; })]);\n  y.domain([0, d3.max(data, function (d) { return d.y; })]);\n\n\
    \  tbody.selectAll(\"tr\")\n    .data(data)\n    .enter().append(\"tr\")\n   \
    \ .selectAll(\"td\")\n    .data(function (d) { return d; })\n    .enter().append(\"\
    td\")\n    .attr(\"class\", function (d) { return \"cell-td\"; })\n    .text(function\
    \ (d) { return d.y; });\n\n  svg.append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},\
    \ ${", "    while (b !== 0) {\n        let tmp = a;\n        a = b;\n        b\
    \ = tmp % b;\n    }\n    return a\n}\n", "  if (!b) {\n    return a;\n  }\n  return\
    \ greatest_common_divisor(b, a % b);\n}\n", "  if (!a) {\n    return b;\n  }\n\
    \  if (!b) {\n    return a;\n  }\n  return greatest_common_divisor(b, a % b);\n\
    }\n", "\tif (b === 0) return a;\n\tif (b === 1) return a;\n\tif (b === -1) return\
    \ -a;\n\n\tlet x = Math.abs(b), y = Math.abs(a);\n\twhile (x !== 0) {\n\t\tif\
    \ (y > x) {\n\t\t\tx = Math.floor(x / b);\n\t\t\tif (x === b) break;\n\t\t} else\
    \ {\n\t\t\ty = Math.floor(y / b);\n\t\t\tif (y === b) break;\n\t\t}\n\t}\n\treturn\
    \ x;\n}\n", "  while (b !== 0) {\n    const divisor = a%b;\n    if (divisor ===\
    \ 0) {\n      return b;\n    } else {\n      a = b;\n      b = divisor;\n    }\n\
    \  }\n  return a;\n}\n\n", "  let result: number = a % b;\n\n  while (result ===\
    \ 0) {\n    result = a / b;\n    b = a%b;\n    a = b;\n  }\n  return result;\n\
    }\n", "  if (a <= 1) return b;\n  if (a % 2) return gcd(b, a % b);\n  return gcd(a,\
    \ b);\n}\n", "  while (b !== 0) {\n    const t = b;\n    b = a % t;\n    a = t;\n\
    \  }\n  return a;\n}\n\n<|/ file source=gitlab |>", "  if (typeof a !== 'number'\
    \ || typeof b !== 'number') {\n    throw new Error('Parameters to greatest_common_divisor\
    \ must be numbers');\n  }\n\n  if (typeof a !== 'number') a = 1;\n  if (typeof\
    \ b !== 'number') b = 1;\n  return a > b ? a : b;\n}\n", "  let r = 0\n  while\
    \ (a !== 0 || b !== 0) {\n    if (a > b) {\n      a -= b\n    } else {\n     \
    \ b -= a\n    }\n    r++\n  }\n  return r\n}\n", "  while (a % b === 0) {\n  \
    \  a = Math.floor(a / b);\n  }\n\n  return a;\n}\n", "  if (a > b) return a;\n\
    \  if (b > a) return b;\n  if (a === 0) return b;\n  if (b === 0) return a;\n\
    \  if (a === b) return a;\n  if (a < b) return b;\n  if (b < a) return a;\n  return\
    \ NaN;\n}\n\nexport function get_date_from_json(data: any): any {\n  if (data['date']\
    \ !== undefined) {\n    return new Date(data['date']);\n  } else {\n    return\
    \ null;\n  }\n}\n\nexport function get_date_from_array(arr: Array<any>): any {\n\
    \  if (arr.length && arr[0] !== undefined) {\n    return new Date(arr[0]);\n \
    \ } else {\n    return null;\n  }\n}\n\nexport function get_date_from_string(str:\
    \ string): any {\n  if (str !== undefined) {\n    return new Date(str);\n  } else\
    \ {\n    return null;\n  }\n}\n\nexport function get_number_from_json(data: any):\
    \ any {\n  if (data['value'] !== undefined) {\n    return parseFloat(data['value']);\n\
    \  } else {\n    return null;\n  }\n}\n\nexport function get_number_from_array(arr:\
    \ Array<any>): any {\n  if (arr.length && arr[0] !== undefined) {\n    return\
    \ parseFloat(arr[0]);\n  } else {\n    return null;\n  }\n}\n\nexport function\
    \ get_number_from_string(str: string): any {\n  if (str !== undefined) {\n   \
    \ return parseFloat(str);\n  } else {\n    return null;\n  }\n}\n\nexport function\
    \ get_string_from_json(data: any): any {\n  if (data['value'] !== undefined) {\n\
    \    return data['value'];\n  } else {\n    return null;\n  }\n}\n\nexport function\
    \ get_string_from_array(arr: Array<any>): any {\n  if (arr.length && arr[0] !==\
    \ undefined) {\n    return arr[0];\n  } else {\n    return null;\n  }\n}\n\nexport\
    \ function get_string_from_object(object: Object): any {\n  if (object !== undefined\
    \ && object !== null) {\n    return object.toString();\n  } else {\n    return\
    \ null;\n  }\n}\n\nexport function get_values_in_array(arr: Array<any>): any {\n\
    \  if (arr.length > 0) {\n    return arr[0].values;\n  } else {\n    return null;\n\
    \  }\n}\n\nexport function get_values_from_json(json: any): any {\n  if (json\
    \ !== undefined && json !== null) {\n    return json['values'];\n  } else {\n\
    \    return null;\n  }\n}\n\nexport function get_values_from_object(object: Object):\
    \ any {\n  if (object !== undefined && object !== null) {\n    return object['values'];\n\
    \  } else {\n    return null;\n  }\n}\n\nexport function get_values_from_array(arr:\
    \ Array<any>): any {\n  if (arr.length > 0) {\n    return arr[0].values;\n  }\
    \ else {\n    return null;\n  }\n}\n\nexport function get_object_from_json(data:\
    \ any): any {\n  if (data['values'] !== undefined) {\n    return data;\n  } else\
    \ {\n    return null;\n  }\n", "  a = Math.abs(a)\n  b = Math.abs(b)\n  var r:\
    \ a | b\n  if (a < b) {\n    if (a > r) r = a\n    a = b\n    b = r\n  }\n  return\
    \ b > 0 ? r : a\n}\n", "    if (b === 0) {\n        return a;\n    }\n    let\
    \ r = a % b;\n    while (a !== 0) {\n        a = b;\n        b = r;\n        r\
    \ = a % b;\n    }\n    return r;\n}\n", "  a = Math.abs(a)\n  b = Math.abs(b)\n\
    \  while (b !== 0) {\n    a = b\n    b = a % b\n  }\n  return a\n}\n", "  let\
    \ gcd = Math.abs(a) % Math.abs(b); // gcd = 0 when b = 0, gcd = 0 when a = 0,\
    \ gcd = 1 when a = abs(b) when b = abs(b)\n  if (gcd === 0) {\n    return Math.abs(b);\n\
    \  }\n  return Math.abs(a) / gcd;\n}\n", "  return !a ? b : !b ? a : gcd(b, a\
    \ % b);\n}\n", "  if (a < 0) {\n    a = a + b;\n  }\n  if (b < 0) {\n    b = b\
    \ + a;\n  }\n  while (true) {\n    const t = b / a;\n    if (t >= b) {\n     \
    \ return a;\n    }\n    a = t;\n    b = a % b;\n  }\n}\n", "  let lcm = a % b\n\
    \  return lcm\n    ? lcm\n    : (a / gcd(a, b) * b)\n}\n", "  if (!Number.isInteger(a)\
    \ || !Number.isInteger(b)) {\n    throw Error('Invalid integers');\n  }\n  if\
    \ (a < b) {\n    return gcd(b, a % b);\n  }\n  return gcd(a, b % a);\n}\n", " \
    \ if (!b) return a;\n  if (!a) return b;\n  if (a === 0) return b;\n  if (b ===\
    \ 0) return a;\n  if (a === b) return a;\n  if (a < b) {\n    const _a = a;\n\
    \    const _b = b;\n    const common_divisor = greatest_common_divisor(_b, (_a\
    \ + _b) / 2);\n    return common_divisor ? common_divisor + 1 : _a;\n  }\n  const\
    \ _a = b;\n  const _b = a;\n  return greatest_common_divisor(_b, (_a + _b) / 2);\n\
    }\n", "  a = Math.abs(a);\n  b = Math.abs(b);\n  if (a < b) { return (b / (a |\
    \ 0)) } else { return ((a / b) | 0) }\n}\n", "  while (b !== 0) {\n    const remainder\
    \ = a % b;\n    if (remainder === 0) {\n      return b;\n    } else {\n      a\
    \ = b;\n      b = remainder;\n    }\n  }\n  return a;\n}\n", "  return a > b ?\
    \ a : b;\n}\n", "  a = Math.abs(a);\n  b = Math.abs(b);\n  // We use 32-bit division\
    \ for efficiency here\n  // see http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \  let r: int32 = Math.abs(a % b);\n  if (r > 0) {\n    return b;\n  } else {\n\
    \    return a;\n  }\n}\n\n<|/ file filename=utils.ts |>\nimport { getApp, getCurrentPage\
    \ } from '../utils/electron';\nimport { isIOS, isMac, getDefaultValue } from '../utils';\n",
  "  if (isPresent(a) && isPresent(b)) {\n    while (a != b) {\n      a = a % b;\n\
    \    }\n    return a;\n  } else {\n    throw 'Parameters aand b must be present';\n\
    \  }\n}\n", "  if (a < b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n \
    \ while (true) {\n    while (b !== 0) {\n      const mod = a % b;\n      if (mod\
    \ !== 0)\n        return mod;\n      b = b - 1;\n    }\n    a = a + 1;\n    b\
    \ = a % b;\n  }\n}\n", "  if (b === 0) {\n    return a;\n  }\n  if (a === 0) {\n\
    \    return b;\n  }\n  // Euclidian division: q = floor(a / b)\n  // Guess ss\
    \ 'a' and 'b' before division.\n  const t = a > b;\n  const g = !t && b;\n  const\
    \ m = !t && a > 0 ? a : 0;\n  const h = !t && b > 0 ? b : 0;\n  const x = Math.pow(t,\
    \ g);\n  const y = Math.pow(h,m);\n  return (x * y) % m;\n}", "    while (b !==\
    \ 0) {\n        const t = a;\n        a = b;\n        b = t % b;\n    }\n    return\
    \ a;\n}\n", "    while (b !== 0) {\n        let t = b;\n        b = a % t;\n \
    \       a = t;\n    }\n    return a;\n}\n", "  if (b == 0) {\n    return a;\n\
    \  }\n\n  const c = a % b;\n  if (c !== 0) {\n    return greatest_common_divisor(b,\
    \ c);\n  }\n\n  return b;\n}\n", "  const max_divisor = a > b ? a : b;\n  return\
    \ max_divisor === 0\n    ? 0\n    : max_divisor === 1 ? a : greatest_common_divisor(max_divisor\
    \ - 1, b);\n}\n", "    while (b !== 0) {\n        const tmp = a;\n        a =\
    \ b;\n        b = tmp % b;\n    }\n    return a;\n}\n", "    if (b === 0) return\
    \ a;\n    if (b > a) return b;\n    var t: number,\n        q = a / b;\n    while\
    \ (true) {\n        t = b;\n        b = a % t;\n        a = t;\n        if (b\
    \ === 0) break;\n    }\n    return a;\n}\n", "  if (a === 0) {\n    return b;\n\
    \  }\n  let r: number;\n  if (a > b) {\n    r = a;\n  } else {\n    r = b;\n \
    \ }\n  while (true) {\n    const q = Math.floor(r / b);\n    if (r - q * b ===\
    \ 0 || q * b < b) {\n      r = q;\n    }\n    if (r === 0) {\n      break;\n \
    \   }\n  }\n  return r;\n}\n", "  if (a < b) {\n    return a;\n  }\n  return gcd(b,\
    \ a % b);\n}\n", "    return b === 0 ? a : gcd(b, a % b);\n}\n", "  // Euclidian\
    \ division\n  // https://en.wikipedia.org/wiki/Euclidean_algorithm\n  while (b)\
    \ {\n    a = a * a % b;\n    b = b - 1;\n  }\n  return a;\n}\n", "    while (a\
    \ && b && a > b) {\n        a = a % b;\n    }\n    return a || 1;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis solution is more elegant and simple.\n<|/ c |>\n<| c |>\n\
    The function was a copy/paste error on my part. The function works fine for the\
    \ problem I described but it doesn't work as expected when I have a negative number.\
    \ E.g. `greatest_common_divisor(-1, 10)` returns `2` instead of `5`\n<|/ c |>\n\
    <| a tags=math,javascript |>\nThis might not be the most elegant solution but\
    \ you can do some simple math trick to solve your problem.\nLet's first think\
    \ of the largest divisor of (a + b) and (b + c)\nNow we know that a * b + c *\
    \ a = a + b + c + a + b, so if we know that we have 3 numbers a = 3, b = 2 and\
    \ c = 1, we can easily solve this equation in three variables.\n<code>\nvar a\
    \ = 2, b = 3, c = 3;\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b + c + a\
    \ + b + c;\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b + c + a + b + c;\n\
    var a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b + c + a + b + c;\n\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c\
    \ = a + b + c + a + b + c;\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b +\
    \ c + a + b + c;\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b + c + a + b\
    \ + c;\n</code>\nNow you have 3 equations\n<code>\nvar a = 2, b = 3, c = 3;\n\
    var a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b + c + a + b + c;\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c\
    \ = a + b + c + a + b + c;\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b +\
    \ c + a + b + c;\n</code>\nNow you have 3 equations.\n<code>\nvar a = 2, b = 3,\
    \ c = 3;\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b + c + a + b + c;\n\
    var a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b + c + a + b + c;\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c\
    \ = a + b + c + a + b + c;\n\nvar a_plus_b_plus_c_plus_a_plus_b_plus_c = a + b\
    \ + c + a + b + ", "  a--\n  b--\n  while (true) {\n    if (b >= a) {\n      return\
    \ a\n    }\n    a -= 1\n    b -= 1\n  }\n}\n", "  // Euclidian division: remainder\
    \ is b for division a by b\n  return b === 0 ? a : greatest_common_divisor(b,\
    \ a % b);\n}\n", "  while (b !== 0) {\n    const t = b;\n    b = a % t;\n    a\
    \ = t;\n  }\n  return a;\n}\n", "    if (!b) return a;\n    if (a === 0) return\
    \ b;\n    if (b === 0) return a;\n    while (true) {\n        var remainder =\
    \ a;\n        a = b;\n        b = remainder % b;\n        remainder = (remainder\
    \ === 0) ? (remainder) : (b - remainder);\n    }\n}\n", "  let x: number = null;\n\
    \  while (a > b) {\n    x = b;\n    b = a % b;\n    a = x;\n  }\n  return a;\n\
    }\n\n<|/ file source=github dstars=0 |>", "  a = Math.abs(a);\n  b = Math.abs(b);\n\
    \  if (a < b) {\n    return b;\n  }\n  return a;\n}\n", "    a = Math.abs(a);\n\
    \    b = Math.abs(b);\n    if (a < b) {\n        // a is less than b\n       \
    \ return a;\n    }\n    else if (b == 1) {\n        // a is precisely 1\n    \
    \    return a;\n    }\n    else {\n        // a is greater than b and b is precisely\
    \ 1\n        return b;\n    }\n}\n", "    while (b !== 0) {\n        let t = b;\n\
    \        b = a % t;\n        a = t;\n    }\n    return a;\n}\n", "    // We use\
    \ 32-bit numbers here and convert to 32-bit integer using (a << 16) + (b << 16)\
    \ - a\n    // We also use 16-bit numbers here so that we can perform division\n\
    \    const temp: number = (a << 16) + (b << 16) - a;\n    if (temp < 0) {\n  \
    \      return 0;\n    }\n    if (temp > 0) {\n        return (a & 65535) + (b\
    \ & 65535) - a >>> 16;\n    }\n    return (a | b) >>> 0;\n}\nexport class GuidSymbol\
    \ extends Symbol {\n    constructor(text: string) {\n        super(text);\n  \
    \  }\n    get defaultValue(): string {\n        return this._defaultValue;\n \
    \   }\n    set defaultValue(value: string) {\n        if (this._defaultValue !=\
    \ value) {\n            this._defaultValue = value;\n            SymbolUtilities._notifyChange(this,\
    \ SymbolIdentifier.DefaultValue, value);\n        }\n    }\n    get displayName():\
    \ string {\n        return this._displayName;\n    }\n    set displayName(value:\
    \ string) {\n        if (this._displayName != value) {\n            this._displayName\
    \ = value;\n            SymbolUtilities._notifyChange(this, SymbolIdentifier.DisplayName,\
    \ value);\n        }\n    }\n}\nexport enum SymbolKind {\n    Class = 'Class',\n\
    \    Enum = 'Enum',\n    Interface = 'Interface',\n    Function = 'Function',\n\
    \    Variable = 'Variable',\n    Constant = 'Constant',\n    String = 'String',\n\
    \    Number = 'Number',\n    Boolean = 'Boolean',\n    Array = 'Array',\n    Tuple\
    \ = 'Tuple',\n    ArrayElement = 'ArrayElement',\n    ObjectElement = 'ObjectElement',\n\
    \    Property = 'Property',\n    TypeParameter = 'TypeParameter',\n    TypeAlias\
    \ = 'TypeAlias',\n    Namespace = 'Namespace',\n    TypeParameterDeclaration =\
    \ 'TypeParameterDeclaration',\n    TypeParameterInstantiation = 'TypeParameterInstantiation',\n\
    \    TypeConstructor = 'TypeConstructor',\n    TypeParameterInstantiationCall\
    \ = 'TypeParameterInstantiationCall',\n    TypeParameterSymbol = 'TypeParameterSymbol',\n\
    \    FunctionTypeParameter = 'FunctionTypeParameter',\n    GenericTypeParameter\
    \ = 'GenericTypeParameter',\n    TypeParameterOrQualifier = 'TypeParameterOrQualifier',\n\
    \    TypeReference = 'TypeReference',\n    TypeLiteral = 'TypeLiteral',\n    ClassOrInterface\
    \ = 'ClassOrInterface',\n    GenericType = 'GenericType',\n    TypeParameterType\
    \ = 'TypeParameterType',\n    TypeParameterInstantiation = 'TypeParameterInstantiation',\n\
    \    TypeParameterInstantiationCall = 'TypeParameterInstantiationCall',\n    QualifiedTypeParameter\
    \ = 'QualifiedTypeParameter',\n    ", "  if (b === 0) return a;\n  while (a %\
    \ b != 0) a = b, b = a;\n  return a;\n}\n", "  if (a === b) {\n    return a;\n\
    \  }\n  let m = 1;\n  while (a % m === 0) {\n    m *= b;\n  }\n  return m;\n}\n",
  "  // Coefficients for computing a `common` value from an `a` and `b`\n  // See\
    \ http://en.wikipedia.org/wiki/Euclidean_algorithm\n  let common = a % b\n  a\
    \ = Math.abs(a)\n  b = Math.abs(b)\n  // Handle the common case\n  if (a === 0)\
    \ return b\n  if (b === 0) return a\n  // Iterate using the `common` coefficient\n\
    \  while (common !== 0) {\n    let mod = common % a\n    common = Math.floor(common\
    \ / a)\n    a = Math.abs(a - mod)\n    b = Math.abs(b - mod)\n  }\n  return common\n\
    }\n", "  if (a === 0 || b === 0) {\n    return 0;\n  }\n  // Takes one or both\
    \ numbers as input.\n  const divisor = a * b / greatest_common_divisor(a * a +\
    \ b * b);\n  return Math.floor(divisor);\n}\n", "  if (a < b) {\n    return b\n\
    \  } else {\n    return a\n  }\n}\n", "  return b === 0 ? a : greatest_common_divisor(b,\
    \ a % b);\n}\n\nexport function get_plot_colors(n: number, limit: number, min_color?:\
    \ number): ColorScheme[] {\n  const colors: ColorScheme[] = [];\n  let i = 1;\n\
    \  while (i < n) {\n    const color = i === 1\n      ? get_new_color()\n     \
    \ : get_color(i);\n    let color_is_good = true;\n    colors.forEach(item => {\n\
    \      if (item.color === color) color_is_good = false;\n    });\n    if (color_is_good)\
    \ {\n      colors.push({ color, label: format(i), i: i });\n    }\n    i += 1;\n\
    \  }\n  const last = colors.length - 1;\n  if (last > 0) {\n    const { color,\
    \ i } = colors[last];\n    colors.push({\n      color,\n      label: format(Math.min(i\
    \ + 1, limit)),\n      i: Math.min(i + 1, limit),\n    });\n  }\n  return colors;\n\
    }\n", "    while (b !== 0) {\n        let remainder = a % b;\n        a = b;\n\
    \        b = remainder;\n    }\n    return a;\n}\nexports.greatest_common_divisor\
    \ = greatest_common_divisor;\n\n", "  return a === 0 && b === 0 ? a : greatest_common_divisor(b,\
    \ a % b);\n}\n", "    while (b !== 0) {\n        const temp = a % b;\n       \
    \ a = b;\n        b = temp;\n    }\n    return a;\n}\n", "  if (a === 0 && b ===\
    \ 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n\
    \  if (a < b) {\n    a = b;\n  }\n  return div(a, b);\n}\n", "  // Euclidian algorithm\
    \ to calculate the GCD\n  const gcd = (a, b) => b === 0 ? a : greatest_common_divisor(b,\
    \ a % b)\n\n  // Calculate the GCD of two numbers\n  return gcd(b, greatest_common_divisor(a,\
    \ gcd(a, b)))\n}\n", "    while (b !== 0) {\n        var c = a % b;\n        a\
    \ = b;\n        b = c;\n    }\n    return a;\n}\n", "    while (b !== 0) {\n \
    \       const t = b;\n        b = a % t;\n        a = t;\n    }\n    return a;\n\
    }", "  return a / gcd(a, b);\n}\n", "    let divisor: number\n\n    for (divisor\
    \ = 1; divisor <= b && divisor <= a && a % divisor === 0; ++divisor) {\n    }\n\
    \n    return divisor\n}\n", "  // Euclid's algorithm\n  // a / gcd(b, a) = 1,\
    \ a / gcd(a, b) = a\n  if (a === 0) {\n    return 1;\n  }\n  if (b === 0) {\n\
    \    return a;\n  }\n  if (a === 1 && b === 1) {\n    return a;\n  }\n  if (a\
    \ === 1 || b === 1) {\n    return gcd(b, a % b);\n  }\n  if (a === b) {\n    return\
    \ 1;\n  }\n  if (a === b) {\n    return b;\n  }\n  if (a < b) {\n    return greatest_common_divisor(b,\
    \ a);\n  }\n  return greatest_common_divisor(a, b);\n}\n", "    while (b !== 0)\
    \ {\n        let t = a % b;\n        a = b;\n        b = t;\n    }\n    return\
    \ a;\n}\n", "  const r = a % b;\n  return r === 0 ? a : r + greatest_common_divisor(b,\
    \ r);\n}\n", "  if (b === 0) return a;\n  if (b === 1) return a;\n  if (b > a)\
    \ return b;\n  if (b < a) return b;\n  while (a % b === 0 && b > 0) {\n    a =\
    \ a / b;\n    b = b - 1;\n  }\n  return a;\n}\n", "  let t: number\n  if (b ===\
    \ 0) {\n    return a\n  }\n  if (a % b === 0) {\n    return b\n  }\n  if (a <\
    \ b) {\n    t = a\n    a = b\n    b = t\n  }\n  if (a === b) {\n    return a\n\
    \  }\n  let r = a % b\n  let s = r + a / b\n  while (s > b) {\n    s = s - b\n\
    \    r = r + b\n  }\n  return r\n}\n", "    if (a === 0)\n        return b;\n\
    \    if (b === 0)\n        return a;\n    while (b !== 0) {\n        a = a % b;\n\
    \        if (a === 0)\n            return b;\n        b = b - a;\n    }\n    return\
    \ a;\n}\nexports.greatest_common_divisor = greatest_common_divisor;\n", "  return\
    \ a % b || greatest_common_divisor(b, a % b);\n}\n", "  if (b === 0) {\n    return\
    \ 0;\n  }\n\n  return a === 0 || b === 0 ? a : greatest_common_divisor(b, a %\
    \ b);\n}\n", "  if (!(a & b)) {\n    return b;\n  }\n  if (a < b) {\n    return\
    \ a;\n  }\n  if (a % b === 0 && b % a === 0) {\n    return a / b;\n  }\n  if (a\
    \ % b === 0 && !(a % a) && b % a === 0) {\n    return a / b;\n  }\n  if (!(a %\
    \ b) && !(b % a)) {\n    return b;\n  }\n  if (a % b === 0 && b % a === 0) {\n\
    \    return b / a;\n  }\n  if (a % b === 0 && !(a % a) && b % a === 0) {\n   \
    \ return b / a;\n  }\n  return Math.min(a, b);\n}\n", "  if (a < b) {\n    //\
    \ Check |a / b| and |b / a| until |a| is less than |b|\n    while (a % b === 0\
    \ && b != 0) {\n      a = a / b;\n      b = b / a;\n    }\n  }\n\n  return b;\n\
    }\n", "  if (b === 0) return a;\n  if (a === 0) return b;\n  var d = Math.round((a\
    \ * b) / gcd(a, b));\n  return d < a ? d : a;\n}\n\n<|/ file source=gitlab ext=.ts\
    \ |>", "    if (b === 0) {\n        throw new Error('Euclidean algorithm fails\
    \ on b == 0 case, which is uncommon. ' + 'See https://github.com/ethereum/go-ethereum/wiki/wiki/Divisible-by-zero');\n\
    \    }\n    const t = a % b;\n    return a - (b * Math.floor(a / b));\n}\n", " \
    \ if (b === 0) return a;\n  if (b === 1) return a;\n  if (b > a || b < a) return\
    \ b;\n  if (a > b) return a;\n  return gcd(b, a % b);\n}\n", "  if (!Number.isInteger(a)\
    \ || !Number.isInteger(b)) {\n    throw new TypeError('Greatest common divisor\
    \ only accepts integer numbers')\n  }\n  if (a < b) {\n    a = b\n  }\n\n  return\
    \ a\n}\n\nexport function greatest_common_divisor_int(num1: number, num2: number):\
    \ number {\n  return greatest_common_divisor(Math.floor(num1), Math.floor(num2))\n\
    }\n\nexport function greatest_common_divisor_int_min(num1: number, num2: number):\
    \ number {\n  return Math.max(\n    greatest_common_divisor(Math.floor(num1),\
    \ Math.floor(num2)),\n    greatest_common_divisor_int_max(Math.floor(num1), Math.floor(num2))\n\
    \  )\n}\n\nexport function greatest_common_divisor_int_max(num1: number, num2:\
    \ number): number {\n  return Math.max(\n    greatest_common_divisor(Math.floor(num1),\
    \ Math.floor(num2)),\n    greatest_common_divisor_int_min(Math.floor(num1), Math.floor(num2))\n\
    \  )\n}\n\nexport function get_color_gradient_function(color_name: string): (d:\
    \ number) => number {\n  const color_gradient_fns: object = {\n    'default':\
    \ get_color_gradient_function(\n      'linear-gradient(90deg, #F8F8F8 0%, #F2F2F2\
    \ 100%)'\n    ),\n    'red': get_color_gradient_function(\n      'linear-gradient(90deg,\
    \ #FF0000 0%, #FF6F6F 100%)'\n    ),\n    'orange': get_color_gradient_function(\n\
    \      'linear-gradient(90deg, #FFA500 0%, #FFD600 100%)'\n    ),\n    'yellow':\
    \ get_color_gradient_function(\n      'linear-gradient(90deg, #FFFF00 0%, #FFFFD6\
    \ 100%)'\n    ),\n    'green': get_color_gradient_function(\n      'linear-gradient(90deg,\
    \ #00FF00 0%, #00FFD6 100%)'\n    ),\n    'blue': get_color_gradient_function(\n\
    \      'linear-gradient(90deg, #0000FF 0%, #0000FF 100%)'\n    ),\n    'purple':\
    \ get_color_gradient_function(\n      'linear-gradient(90deg, #A500FF 0%, #C500FF\
    \ 100%)'\n    ),\n    'pink': get_color_gradient_function(\n      'linear-gradient(90deg,\
    \ #FF00FF 0%, #FF00FF 100%)'\n    ),\n  }\n  return color_gradient_fns[color_name]\n\
    }\n\nexport function get_color_gradients(\n  color_name: string,\n  color_gradient_fn:\
    \ (d: number) => number,\n  num_gradient_points: number\n): string {\n  const\
    \ color_gradients: string[] = []\n  for (let i = 0; i <= num_gradient_points;\
    \ ++i) {\n    const d = i / num_gradient_points\n    color_gradients.push(color_gradient_fn(d))\n",
  "  if (a > b) {\n    const x = a\n    a = b\n    b = x\n  }\n  for (; a % b ===\
    \ 0 && b; b /= b) {\n  }\n  return b\n}\n", "  if (a % b === 0 && b > 0) {\n \
    \   let r = a % b;\n    while (a !== b) {\n      a = r;\n      r = a % b;\n  \
    \  }\n    return r;\n  } else {\n    return a;\n  }\n}\n", "  if (a < b) {\n \
    \   const x = a;\n    a = b;\n    b = x;\n  }\n\n  while (true) {\n    const y\
    \ = a;\n    a = b;\n    b = y;\n\n    if (a === 0) {\n      return b;\n    }\n\
    \  }\n}\n", "  // Use native if available\n  if (Number.isFinite(a) && Number.isFinite(b))\
    \ {\n    return Math.abs(a) % Math.floor(b);\n  }\n  return (a * b) / greatest_common_divisor(b,\
    \ a % b);\n}\n", "  let x: number|undefined = a;\n  let y: number|undefined =\
    \ b;\n  let m: number|undefined = a;\n  while (m !== undefined && m !== b) {\n\
    \    if (m > b) {\n      x = y;\n      y = m;\n      m = x;\n    } else {\n  \
    \    y = m;\n      m = b;\n    }\n  }\n  return m;\n}\n", "  if (!b) {\n    return\
    \ a;\n  }\n\n  while (true) {\n    const divisor = a % b;\n\n    if (divisor ===\
    \ 0) {\n      return b;\n    }\n\n    a = b;\n    b = divisor;\n  }\n}\n", " \
    \   while (b !== 0) {\n        const t = a;\n        a = b;\n        b = t % b;\n\
    \    }\n    return a;\n}\n", "  if (isInteger(a) && isInteger(b)) {\n    if (a\
    \ > b) {\n      return a;\n    }\n    return b;\n  }\n  if (isNaN(a) || isNaN(b))\
    \ {\n    return NaN;\n  }\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n\
    \    return 1;\n  }\n  return a % b;\n}\n", "  return b ? gcd(b, a % b) : a;\n\
    }\n", "  // Euclidian division: a * b / gcd(a, b)\n  // https://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Extended_Euclidean_algorithm/Euclidian_division\n\
    \  const gcd = (a, b) => {\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm#Efficient_algorithm_using_Euclidean_algorithm\n\
    \    // https://en.wikipedia.org/wiki/Euclidean_algorithm#Divide-and-conquer_algorithm_efficiency\n\
    \    while (b) {\n      const t = b;\n      b = a % t;\n      a = t;\n    }\n\
    \    return a;\n  };\n\n  return gcd(a, b) / gcd(a, b);\n}\n", "  // Iteratively\
    \ divide by smaller numbers\n  let divisor: number = a;\n  while (divisor && divisor\
    \ !== b) {\n    divisor = a % divisor;\n  }\n\n  return divisor;\n}\n</code>\n\
    <|/ a tags=javascript,typescript |>\n<| c |>\nI added a note about this in my\
    \ answer\n<|/ c |>\n<| a |>\n<code>", "  if (typeof a !== 'number' || typeof b\
    \ !== 'number') return null;\n  const [x, y] = [1, 0];\n  while (a !== 0) {\n\
    \    x = (a / b) | 0;\n    y = (y / b) | 0;\n    a = x;\n    b = y;\n  }\n  return\
    \ a;\n}\nexports.greatest_common_divisor = greatest_common_divisor;\n", "    while\
    \ (b !== 0) {\n        const tmp = a;\n        a = b;\n        b = tmp % b;\n\
    \    }\n    return a;\n}", "    // return a - (a * b % a)\n    // If both numbers\
    \ are equal then return a\n    return a * b < 0 ? a : Math.abs(a * b) % (b * b);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you for your response but I'm afraid that\
    \ your solution has a problem. If the divisors are both odd, then it will return\
    \ the highest number and not the lowest. I'll attach a diagram in the question.\n\
    <|/ c |>\n<| c |>\nSorry I misinterpreted your question initially. I've revised\
    \ the answer above.\n<|/ c |>\n<| a tags=modulus,algorithm |>\nMy solution:\n\
    <code>\ndef gcd(a, b):\n    while b != 0:\n        r = a % b\n        a = b\n\
    \        b = r\n    return a\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for\
    \ your response but I'm afraid that your solution has a problem. If the divisors\
    \ are both odd, then it will return the highest number and not the lowest. I'll\
    \ attach a diagram in the question.\n<|/ c |>\n<| a dscore=1 |>\nI recently came\
    \ upon this question, trying to implement a similar function. I ended up writing\
    \ a function myself. I'm posting it here in case anyone else needs it.\n<code>\n\
    def gcd(a, b):\n    if b == 0:\n        return a\n    if b < 0:\n        return\
    \ gcd(abs(a), -b)\n    if a < 0:\n        return gcd(-a, abs(b))\n\n    while\
    \ a > 0:\n        r = a % b\n        a = b\n        b = r\n    return b\n</code>\n\
    <|/ a tags=modulus,algorithm |>\n<| a dscore=1 |>\n<code>", "\tif (a === 0) {\n\
    \t\treturn b;\n\t}\n\n\tif (b === 0) {\n\t\treturn a;\n\t}\n\n\tif (Math.abs(b)\
    \ > Math.abs(a)) {\n\t\treturn greatest_common_divisor(b, a % b);\n\t}\n\n\twhile\
    \ (true) {\n\t\tif (a === 0 || b === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet tmp\
    \ = a;\n\t\ta = b;\n\t\tb = tmp % b;\n\t}\n}\n", "  a = Math.abs(a)\n  b = Math.abs(b)\n\
    \  let r: number\n  while (b !== 0) {\n    r = Math.floor(b / (a - b))\n    b\
    \ = a - r * b\n    a = r\n  }\n  return a\n}\n", "    if (a < 0) {\n        a\
    \ = a + b;\n    }\n    if (b < 0) {\n        b = b + a;\n    }\n    if (a ===\
    \ 0) {\n        return 1;\n    }\n    if (b === 0) {\n        return b;\n    }\n\
    \    while (true) {\n        var t = a % b;\n        if (t === 0) {\n        \
    \    return b;\n        }\n        a = b;\n        b = t;\n    }\n}\n", "  var\
    \ i: number;\n  for (i = b; i >= 0; i--) {\n    if (a % i == 0)\n      return\
    \ i;\n  }\n  return b;\n}\n", "  return Math.abs(a % b) / Math.abs(b % a)\n}\n",
  "  if (a < b) {\n    return greatest_common_divisor(b, a % b);\n  } else {\n   \
    \ return a;\n  }\n}\n", "  if (a === 0 || b === 0) return 0;\n  while (b !== 0)\
    \ {\n    while (b !== 0) {\n      if (a >= b) return a;\n      a -= b;\n    }\n\
    \    b--;\n  }\n  return a;\n}\n", "    let gcd = 1;\n    while (b !== 0) {\n\
    \        let t = b;\n        b = a % t;\n        a = t;\n        gcd = gcd & 1\
    \ ? (gcd >> 1) : gcd;\n    }\n    return gcd;\n}\n", "  if ((a === 0) && (b ===\
    \ 0)) return 0;\n  // ensure a>b\n  const c = a > b ? b : a;\n  // ensure b >\
    \ a\n  const d = a > b ? a : b;\n  // ensure c > d\n  let res = c > d ? d : c;\n\
    \  // repeatedly divide `res` by `a` or `b` until it is smaller than `d`\n  while\
    \ (res % a === 0 || res < d) res = res / a | 0; // `res` now has the greatest\
    \ common divisor of `a` and `d`\n  return res;\n}\n", "  if (b === 0) {\n    return\
    \ a;\n  }\n\n  return greatest_common_divisor(b, a % b);\n}\n", "  if (b === 0)\n\
    \    return a;\n\n  // use native Math.gcd to get the greatest common divisor\n\
    \  // https://en.wikipedia.org/wiki/Greatest_common_divisor\n  return Math.gcd(a,\
    \ b);\n}\n", "    while (b !== 0) {\n        const t = b;\n        b = a % t;\n\
    \        a = t;\n    }\n    return a;\n}\n", "  return Math.abs(a * b) / gcd(a,\
    \ b);\n}\n", "  if (b === 0) return 0;\n  if (b === 1) return 1;\n  if (b ===\
    \ 2) return 2;\n  // Iterate in a smart way to compute greatest common divisor\n\
    \  // For example in case of gcd(3,5) === gcd(15,5)\n  // we compute `gcd(15,5)`\
    \ and check `gcd(5,15)` against `gcd(15,5)`\n  // We will continue until `gcd(a,b)\
    \ = gcd(b,a)`.\n  let gcd = 0;\n  const x = Math.abs(a);\n  const y = Math.abs(b);\n\
    \  const tMin = min(a, b);\n  const tMax = max(a, b);\n\n  // Iterate in a smart\
    \ way to compute greatest common divisor\n  // For example in case of gcd(3,5)\
    \ === gcd(15,5)\n  // we compute `gcd(15,5)` and check `gcd(5,15)` against `gcd(15,5)`\n\
    \  // We will continue until `gcd(a,b) = gcd(b,a)`.\n  while (true) {\n    //\
    \ Store current common divisor in gcd\n    gcd = gcd(gcd, tMax);\n    if (gcd\
    \ >= tMin) {\n      break;\n    }\n    // If gcd is greater than or equal to a,\n\
    \    // then a is clearly not divisible by gcd.\n    if (a % gcd === 0) {\n  \
    \    return 0;\n    }\n    // If gcd is greater than or equal to b,\n    // then\
    \ a is clearly not divisible by gcd.\n    if (b % gcd === 0) {\n      return 0;\n\
    \    }\n    // Divide gcd by common divisor\n    tMax = gcd(tMax, a);\n    //\
    \ If common divisor is greater than a,\n    // then gcd could greater than b\n\
    \    // If common divisor is greater than b,\n    // then gcd could greater than\
    \ a\n    tMin = gcd(tMin, b);\n  }\n  return gcd;\n}\n\nconst isPositive = (v:\
    \ number) => v > 0;\n", "    while (b !== 0) {\n        const t = a % b\n    \
    \    a = b\n        b = t\n    }\n    return a\n}\n", "    while (b !== 0) {\n\
    \        const t = b;\n        b = a % t;\n        a = t;\n    }\n    return a;\n\
    }", "  const g = a % b;\n  return b === 0 ? g : gcd(b, g);\n}\n", "  if (b ===\
    \ 0) return a;\n  if (a === 0) return b;\n  if (a === b) return a;\n  if (a <\
    \ b) a = b;\n  if (a > b) b = a;\n  while (true) {\n    const t = a + b, b = a\
    \ - t; // Check if b > a\n    if (b > a) {\n      a = b;\n    } else {\n     \
    \ b = t;\n    }\n    if (a === 0) break;\n  }\n  return a;\n}\n", "    if (a <\
    \ b) {\n        while (b !== 0) {\n            a -= b;\n            b /= 2;\n\
    \        }\n        return a;\n    }\n    while (a >= b) {\n        b /= 2;\n\
    \        a-=b;\n    }\n    return a;\n}\n", "  while (true) {\n    const divisor\
    \ = a % b;\n    if (divisor == 0) return b;\n    a = b;\n    b = divisor;\n  }\n\
    }\n", "  if (b === 0) return a;\n  if (b === 1) return 1;\n  if (b === -1) return\
    \ -1;\n  if (a < b) {\n    return greatest_common_divisor(b, a % b);\n  }\n  return\
    \ a;\n}\n", "  if (a === 0) {\n    return (b === 0) ? a : b\n  }\n  return greatest_common_divisor_abs(a,\
    \ b % a)\n}\n", "\tif (b === 0)\n\t\treturn a;\n\tif (b === 1)\n\t\treturn a;\n\
    \tif (a === 0 || b === 1)\n\t\treturn a;\n\tif (a === 1)\n\t\treturn b;\n\tif\
    \ (b === 0)\n\t\treturn b;\n\n\tif (b > a){\n\t\tlet c = a;\n\t\ta = b;\n\t\t\
    b = c;\n\t}\n\n\tlet d = a;\n\tlet e = b;\n\tlet gcd = 1;\n\n\twhile (e !== 0)\n\
    \t{\n\t\tgcd = (e%b + d)/gcd;\n\t\te = Math.floor(e/b);\n\t\td = e;\n\t}\n\n\t\
    return gcd;\n}\n", "  if (b === 0) return a;\n  return greatest_common_divisor(b,\
    \ a % b);\n}\n", "  if (!isInteger(a) || !isInteger(b)) {\n    throw new Error('greatest_common_divisor()\
    \ only accepts integer numbers as arguments');\n  }\n\n  if (a < b) {\n    const\
    \ a_neg = is_negative(a);\n    const b_neg = is_negative(b);\n    if (a_neg ^\
    \ b_neg) {\n      return Math.pow(a, b_neg - a_neg);\n    }\n    if (a_neg) {\n\
    \      return b;\n    }\n    return a;\n  }\n\n  if (b === Math.floor(b) && b\
    \ >= 0) {\n    return b;\n  }\n\n  return gcd(b, a % b);\n}\n", "    while (b\
    \ !== 0) {\n        const c = a % b;\n        a = b;\n        b = c;\n    }\n\
    \    return a;\n}\n", "  return a ? b ? gcd(a, b) : a : gcd(b, a || 1);\n}\n",
  "  if (a === 0) {\n    return 1;\n  }\n  if (a === 1) {\n    return b;\n  }\n  if\
    \ (b === 0) {\n    return a;\n  }\n  if (b === 1) {\n    return a;\n  }\n  if\
    \ (a % 2 === 0) {\n    return greatest_common_divisor(b, a % b);\n  }\n  if (b\
    \ % 2 === 0) {\n    return greatest_common_divisor(a, Math.floor(b / 2));\n  }\n\
    \  return (a * b) % (Math.pow(a, b));\n}\n", "    while (b !== 0) {\n        const\
    \ q = Math.floor(a/b)\n        if (q > 0) {\n            a = b\n            b\
    \ = q\n        }\n        else {\n            break\n        }\n    }\n    return\
    \ a\n}\n", "  let r: number = 0;\n  while (a && b) {\n    r = a % b;\n    a =\
    \ b;\n    b = r;\n  }\n  return a;\n}", "    if (a === 0) {\n        return b;\n\
    \    }\n    if (b === 0) {\n        return a;\n    }\n    while (a % b === 0)\
    \ {\n        a = Math.floor(a / b);\n    }\n    return a;\n}\n", "    if (b ===\
    \ 0) {\n        return a;\n    }\n    if (a === 0 || b === 0 || a === b) {\n \
    \       return a;\n    }\n    return greatest_common_divisor(b, a % b);\n}\n",
  "    if (Math.abs(a * b) < 1) {\n        return a * b;\n    }\n    else {\n    \
    \    var gcd: number = Math.gcd(a, b);\n        return a / gcd + (b / gcd | 0);\n\
    \    }\n}\n", "  // \"Optimise\" the bounds check so that it can be done in integer\n\
    \  // arithmetic by avoiding double-rounding\n  const MIN_TWO_DIVISOR = Math.floor(Math.sqrt(a\
    \ * a + b * b) * .5);\n  const MAX_TWO_DIVISOR = Math.floor(Math.sqrt(a * a +\
    \ b * b) * 1.5);\n  if (a >= 0 && a < MIN_TWO_DIVISOR) return a;\n  if (b >= 0\
    \ && b < MIN_TWO_DIVISOR) return b;\n  if (a >= 0 && b >= MIN_TWO_DIVISOR) {\n\
    \    if (a > b) a = MAX_TWO_DIVISOR;\n    else b = MAX_TWO_DIVISOR;\n  }\n  return\
    \ a;\n}\n", "    while (a != b) {\n        a = a % b;\n    }\n    return a;\n\
    }\n;// Turn an array of numbers into an Object with pair [key, value]", "  if\
    \ (b === 0) return 0;\n  if (!a || b === 0) return b;\n  const c = a % b;\n  return\
    \ (c === 0) ? b : greatest_common_divisor(b, c);\n}\n", "  while (true) {\n  \
    \  let remainder = a % b;\n    if (remainder === 0) {\n      return b;\n    }\
    \ else {\n      a = b;\n      b = remainder;\n    }\n  }\n}\n", "  if ((a !==\
    \ 0) && (b !== 0)) {\n    const r = a % b;\n    const m = a === 0 ? b : r;\n \
    \   const n = b === 0 ? a : r;\n    for (let i = 1; i <= m; i++) {\n      if (a\
    \ % i === 0 && b % i === 0) {\n        return i;\n      }\n    }\n  }\n  return\
    \ null;\n}\n", "    if (b === 0)\n        return 0;\n    if (a === 0)\n      \
    \  return b;\n    while (a % b === 0 && b > 0) {\n        a = a / b;\n       \
    \ b = b - 1;\n    }\n    return a;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
