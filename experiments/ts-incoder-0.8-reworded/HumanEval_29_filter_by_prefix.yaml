name: HumanEval_29_filter_by_prefix
language: ts
prompt: "//Filter an input array of strings only for ones that start with a given\
  \ prefix.\n// >>> filter_by_prefix([], \"a\")\n// []\n// >>> filter_by_prefix([\"\
  abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n// [\"abc\", \"array\"]\nfunction filter_by_prefix(strings:\
  \ string[], prefix: string): string[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = filter_by_prefix;\n  assert.deepEqual(candidate([],\
  \ \"john\"),[]);\n  assert.deepEqual(candidate([\"xxx\", \"asd\", \"xxy\", \"john\
  \ doe\", \"xxxAAA\", \"xxx\"], \"xxx\"),[\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\n\n\
  test();"
completions: ["  return strings.filter(s => s.startsWith(prefix));\n}\n", "\tif (strings.length\
    \ == 0) {\n\t\treturn strings;\n\t}\n\n\tconst prefix_len = prefix.length;\n\t\
    let filtered_strings = strings.filter((str: string) => {\n\t\tif (str.substr(0,\
    \ prefix_len) === prefix) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t\
    });\n\n\treturn filtered_strings;\n}\n", "  const prefix_length = prefix.length;\n\
    \  return strings.filter(\n    item =>\n      item.substring(0, prefix_length)\
    \ === prefix &&\n      item.length > prefix_length\n  );\n}\n", "    const matching_strings\
    \ = strings.filter(s => s.startsWith(prefix));\n    return matching_strings;\n\
    }\n", "    var filtered_strings = strings.filter(function (str) {\n        return\
    \ str.startsWith(prefix);\n    });\n    return filtered_strings;\n}", "  if (strings\
    \ == null || strings.length == 0)\n    return strings;\n  return strings.filter(\n\
    \    string => string.startsWith(prefix) && string.length >= prefix.length);\n\
    }\n", "  const filtered_strings = strings.filter((str) => str.startsWith(prefix));\n\
    \  return filtered_strings;\n}\n", "    if (strings.length < 1) {\n        return\
    \ strings;\n    }\n    const prefix_length = prefix.length;\n    return strings.filter(function(string:\
    \ string) {\n        return string.substr(0, prefix_length) === prefix;\n    });\n\
    }\n", "\tconst prefix_length = prefix.length;\n\treturn strings.filter(string\
    \ => string.startsWith(prefix))\n\t\t.map(string => string.substr(prefix_length));\n\
    }\n", "    let prefix_length = prefix.length;\n    let filtered_strings: string[]\
    \ = [];\n    for (let i = 0, length = strings.length; i < length; i++) {\n   \
    \     let str = strings[i];\n        if (str.substr(0, prefix_length) === prefix)\
    \ {\n            filtered_strings.push(str);\n        }\n    }\n    return filtered_strings;\n\
    }\n", "\tif (strings.length == 0) {\n\t\treturn [];\n\t}\n\n\tconst prefix_length\
    \ = prefix.length;\n\tconst filtered: string[] = [];\n\n\tfor (let i = 0; i <\
    \ strings.length; i++) {\n\t\tif (strings[i].substr(0, prefix_length) === prefix)\
    \ {\n\t\t\tfiltered.push(strings[i]);\n\t\t}\n\t}\n\n\treturn filtered;\n}\n",
  "  let result: string[] = [];\n  for (const string of strings) {\n    if (string.startsWith(prefix))\
    \ {\n      result.push(string);\n    }\n  }\n  return result;\n}\n", "\tconst\
    \ regex = new RegExp(\"^\" + prefix.escapeForRegExp(), \"i\");\n\treturn strings.filter(s\
    \ => regex.test(s));\n}\n", "    return strings.filter(function (item) {\n   \
    \     return item.indexOf(prefix) === 0;\n    });\n}\n", "    const prefix_length\
    \ = prefix.length;\n    if (strings.length === 0) {\n        return strings;\n\
    \    }\n\n    let index = 0;\n    const result = new Array<string>();\n    while\
    \ (index < strings.length) {\n        const string = strings[index];\n       \
    \ const substring_length = string.length;\n        if (substring_length >= prefix_length\
    \ &&\n            string.slice(0, prefix_length) === prefix) {\n            result.push(string);\n\
    \        }\n        index++;\n    }\n    return result;\n}\n", "  return strings.filter(function\
    \ (item: string): boolean {\n    return item.startsWith(prefix);\n  });\n}\n",
  "    const prefix_regex = new RegExp(`^${prefix}`, \"i\");\n    return strings.filter(s\
    \ => prefix_regex.test(s));\n}\n", "    return strings.filter(function (string)\
    \ {\n        return string.startsWith(prefix);\n    });\n}\n", "    return strings.filter(x\
    \ => x.startsWith(prefix));\n}", "  return strings.filter(s => s.startsWith(prefix))\n\
    }\n", "    return strings.filter((s) => s.startsWith(prefix));\n}\n", "\tlet result:\
    \ string[] = [];\n\tfor (let i = 0; i < strings.length; i++) {\n\t\tif (strings[i].indexOf(prefix)\
    \ === 0) {\n\t\t\tresult.push(strings[i]);\n\t\t}\n\t}\n\treturn result;\n}\n",
  "    if (strings.length === 0) {\n        return [];\n    }\n    return strings.filter((s)\
    \ => s.startsWith(prefix));\n}\n", "    return strings.filter(s => s.startsWith(prefix));\n\
    }\n", "  for (const string of strings) {\n    if (string.startsWith(prefix)) {\n\
    \      return [string];\n    }\n  }\n  return strings;\n}\n", "    if (!prefix\
    \ || prefix.length == 0) {\n        return strings;\n    }\n    return strings.filter((str:\
    \ string) => {\n        return str.startsWith(prefix);\n    });\n}\n", "\treturn\
    \ strings.filter((item: string) => item.indexOf(prefix) === 0);\n}\n", "  return\
    \ strings.filter(s => s.indexOf(prefix) === 0);\n}\n", "\tconst result = strings.filter(s\
    \ => s.startsWith(prefix));\n\treturn result.length === 0 ? strings : result;\n\
    }\n", "    return strings.filter(function (str) {\n        return str.slice(0,\
    \ prefix.length) === prefix;\n    });\n}\n", "\treturn strings.filter(function\
    \ (item: string) {\n\t\treturn item.toLowerCase().startsWith(prefix.toLowerCase());\n\
    \t});\n}", "\treturn strings.filter((s) => s.startsWith(prefix));\n}\n", "  return\
    \ strings.filter(function (str) {\n    return str.startsWith(prefix);\n  });\n\
    }\n", "    return strings.filter(function (x) {\n        return x.startsWith(prefix);\n\
    \    });\n}\n", "\treturn strings.filter(\n\t\t(s: string) => s.startsWith(prefix)\n\
    \t);\n}\n", "  const prefix_length = prefix.length;\n  const filtered_strings\
    \ = strings.filter((str: string) => {\n    return str.substr(0, prefix_length)\
    \ === prefix;\n  });\n  return filtered_strings;\n}\n", "\tlet filtered: string[]\
    \ = [];\n\tfor (let i = 0; i < strings.length; i++) {\n\t\tif (strings[i].startsWith(prefix))\
    \ {\n\t\t\tfiltered.push(strings[i]);\n\t\t}\n\t}\n\treturn filtered;\n}\n", " \
    \   return strings.filter(s => s.startsWith(prefix));\n}\n", "  const filtered:\
    \ string[] = [];\n  for (const string of strings) {\n    if (string.startsWith(prefix))\
    \ {\n      filtered.push(string);\n    }\n  }\n  return filtered;\n}\n", "  return\
    \ strings.filter((s) => s.startsWith(prefix));\n}\n", "    const result: string[]\
    \ = [];\n    for (const str of strings) {\n        if (str.startsWith(prefix))\
    \ {\n            result.push(str);\n        }\n    }\n    return result;\n}",
  "    const filtered_strings = strings.filter(s => s.startsWith(prefix));\n    if\
    \ (filtered_strings.length !== strings.length) return [];\n    return filtered_strings;\n\
    }\n", "    if (strings.length === 0) {\n        return strings;\n    }\n    if\
    \ (prefix.length === 0) {\n        return strings;\n    }\n    const start_pos\
    \ = strings[0].lastIndexOf(prefix);\n    return strings.filter(string => start_pos\
    \ === 0 || string.startsWith(prefix));\n}\n", "\tvar prefix_regex = new RegExp(\"\
    ^\" + prefix);\n\treturn strings.filter(function(str) {\n\t\treturn prefix_regex.test(str);\n\
    \t});\n}\n", "  return strings.filter(function(string) {\n    return string.indexOf(prefix)\
    \ === 0;\n  });\n}\n", "    if (strings.length == 0) {\n        return strings;\n\
    \    }\n\n    return strings.filter(s => s.startsWith(prefix));\n}\n", "    return\
    \ strings.filter(function(str) {\n        return str.indexOf(prefix) === 0;\n\
    \    });\n}\n", "    if (strings.length === 0) {\n        return [];\n    }\n\n\
    \    const prefix_length = prefix.length;\n    const prefix_start = strings.findIndex(s\
    \ => s.substr(0, prefix_length) === prefix);\n    if (prefix_start === -1) {\n\
    \        return [];\n    }\n\n    const prefix_end = strings.findIndex(s => s.substr(0,\
    \ prefix_length) !== prefix);\n    if (prefix_end === -1) {\n        return strings.slice(0,\
    \ prefix_start + 1);\n    }\n\n    return strings.slice(prefix_start, prefix_end\
    \ + 1);\n}\n", "    prefix += \"\";\n    const filtered_strings = strings.filter((str)\
    \ => str.startsWith(prefix));\n    return filtered_strings;\n}", "  return strings.filter(function(str)\
    \ {\n    return str.startsWith(prefix);\n  });\n}\n", "  if (strings.length ===\
    \ 0) {\n    return [];\n  }\n  if (prefix.length > strings[0].length) {\n    return\
    \ strings;\n  }\n\n  return strings.filter(function (str) {\n    return str.indexOf(prefix)\
    \ === 0;\n  });\n}\n", "\treturn strings.filter(x => x.startsWith(prefix))\n}\n",
  "\tconst prefix_regex = new RegExp(`^${prefix}`);\n\treturn strings.filter((s) =>\
    \ prefix_regex.test(s));\n}\n", "    return strings.filter(s => s.startsWith(prefix));\n\
    }\n", "  const filtered_strings: string[] = [];\n\n  for (const str of strings)\
    \ {\n    if (str.startsWith(prefix)) {\n      filtered_strings.push(str);\n  \
    \  }\n  }\n\n  return filtered_strings;\n}\n", "  if (strings.length == 0) {\n\
    \    return strings;\n  }\n  return strings.filter((s) => s.indexOf(prefix) ===\
    \ 0);\n}\n", "\treturn strings.filter((string) => string.startsWith(prefix));\n\
    }\n", "  return strings.filter((s) => s.startsWith(prefix))\n}\n", "    return\
    \ objects.filter(s => s.startsWith(prefix));\n}\n", "    const prefix_length =\
    \ prefix.length;\n    const filtered_strings = strings.filter(s => s.startsWith(prefix));\n\
    \    return filtered_strings;\n}\n", "  var result = <string[]>[];\n  for (var\
    \ i = 0; i < strings.length; i++) {\n    if (strings[i].startsWith(prefix)) {\n\
    \      result.push(strings[i]);\n    }\n  }\n  return result;\n}\n", "\tconst\
    \ prefix_length = prefix.length;\n\tconst ret: string[] = [];\n\tfor (let i =\
    \ 0; i < strings.length; i++) {\n\t\tif (strings[i].length >= prefix_length) {\n\
    \t\t\tret.push(strings[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n", "    if (!prefix\
    \ || prefix.length === 0) {\n        return strings;\n    }\n\n    const filtered:\
    \ string[] = [];\n    for (const string of strings) {\n        if (string.startsWith(prefix))\
    \ {\n            filtered.push(string);\n        }\n    }\n    return filtered;\n\
    }\n", "    return strings.filter(function (str) { return str.startsWith(prefix);\
    \ });\n}\n", "    return strings.filter(s => s.startsWith(prefix));\n}\n", "\t\
    return strings.filter(v => v.startsWith(prefix));\n}\n", "  return strings.filter(function\
    \ (string) {\n    return string.startsWith(prefix);\n  });\n}\n", "  return strings.filter(function\
    \ (string: string) { return string.startsWith(prefix); });\n}\n", "    return\
    \ strings.filter(function(s) {\n        return (s.indexOf(prefix) === 0);\n  \
    \  });\n}\n", "\tconst strings_ = strings.filter(s => s.startsWith(prefix));\n\
    \treturn strings_;\n}\n", "    const prefix_regex = new RegExp(`^${prefix}`, \"\
    i\");\n    const filtered: string[] = [];\n    for (const string of strings) {\n\
    \        if (prefix_regex.test(string)) {\n            filtered.push(string);\n\
    \        }\n    }\n    return filtered;\n}\n", "    return strings.filter((s)\
    \ => s.startsWith(prefix));\n}\n", "  return objects.filter(x => x.startsWith(prefix));\n\
    }\n", "    const result = new Array<string>();\n\n    for (let i = 0; i < strings.length;\
    \ i++) {\n        if (strings[i].startsWith(prefix)) {\n            result.push(strings[i]);\n\
    \        }\n    }\n\n    return result;\n}\n", "    const regex = new RegExp(prefix);\n\
    \    return strings.filter((string) => string.match(regex));\n}", "  return strings.filter(s\
    \ => s.startsWith(prefix))\n}\n", "  return strings.filter( (string) => {\n  \
    \  return string.startsWith(prefix)\n  })\n}\n", "  let filtered_strings = strings.filter((item)\
    \ => item.startsWith(prefix));\n  return filtered_strings;\n}\n", "\treturn strings.filter((val:\
    \ string) => val.startsWith(prefix));\n}\n", "\tconst regex = new RegExp(`^${prefix}`,\
    \ \"i\");\n\treturn strings.filter((str) => regex.test(str));\n}\n", "    const\
    \ prefix_length = prefix.length;\n    strings = strings.map(function(str) {\n\
    \        // TODO: what about multi-byte utf-8 chars?\n        return str.substr(0,\
    \ prefix_length) === prefix ? str : \"\";\n    });\n    return strings.filter(function(str)\
    \ {\n        return str !== \"\";\n    });\n}\n", "    return strings.filter((x)\
    \ => x.startsWith(prefix));\n}\n", "\tif (strings.length === 0) {\n\t\treturn\
    \ strings;\n\t}\n\tif (strings.length < 2) {\n\t\treturn strings;\n\t}\n\tif (prefix.length\
    \ > strings[0].length) {\n\t\treturn strings;\n\t}\n\tconst filtered: string[]\
    \ = [];\n\tfor (let i = 0; i < strings.length; i++) {\n\t\tif (strings[i].startsWith(prefix))\
    \ {\n\t\t\tfiltered.push(strings[i]);\n\t\t}\n\t}\n\treturn filtered;\n}\n", " \
    \   // TODO: Refactor to avoid unnecessary allocations\n    let out: string[]\
    \ = [];\n    for (let i = 0; i < strings.length; i++) {\n        if (strings[i].indexOf(prefix)\
    \ === 0) {\n            out.push(strings[i]);\n        }\n    }\n    return out;\n\
    }\n", "    return strings.filter((str) => str.startsWith(prefix));\n}\n", "\t\
    return strings.filter(s => s.startsWith(prefix));\n}\n", "    const prefix_regex\
    \ = new RegExp(\"^\" + prefix);\n    return strings.filter(s => s.match(prefix_regex));\n\
    }\nexports[\"default\"] = filter_by_prefix;", "\tlet filtered_strings: string[]\
    \ = [];\n\tfor (let string of strings) {\n\t\tif (string.startsWith(prefix)) {\n\
    \t\t\tfiltered_strings.push(string);\n\t\t}\n\t}\n\treturn filtered_strings;\n\
    }\n", "    return strings.filter(function(str) {\n        return str.startsWith(prefix);\n\
    \    });\n}\n", "    return strings.filter(s => s.startsWith(prefix));\n}\n",
  "    if (strings.length == 0) return strings;\n\n    const prefix_regex = new RegExp(\"\
    ^\" + prefix);\n    return strings.filter((s: string) => prefix_regex.test(s));\n\
    }\n", "  if (strings.length === 0) {\n    return strings;\n  }\n  const matches:\
    \ string[] = [];\n  for (const s of strings) {\n    if (s.startsWith(prefix))\
    \ {\n      matches.push(s);\n    }\n  }\n  return matches;\n}\n", "  return strings.filter(item\
    \ => item.startsWith(prefix));\n}\n", "\tlet filtered_strings: string[] = [];\n\
    \tfor (let i = 0; i < strings.length; i++) {\n\t\tif (strings[i].startsWith(prefix))\
    \ {\n\t\t\tfiltered_strings.push(strings[i]);\n\t\t}\n\t}\n\treturn filtered_strings;\n\
    }\n", "\treturn strings.filter(str => str.startsWith(prefix));\n}\n", "\treturn\
    \ strings.filter((s) => s.startsWith(prefix));\n}\n", "  return strings.filter(value\
    \ => value.startsWith(prefix));\n}\n", "    return strings.filter((s) => s.startsWith(prefix));\n\
    }\n", "\tconst filtered: string[] = [];\n\tfor (const string of strings) {\n\t\
    \tif (string.startsWith(prefix)) {\n\t\t\tfiltered.push(string);\n\t\t}\n\t}\n\
    \treturn filtered;\n}\n", "    if (strings.length === 0) {\n        return strings;\n\
    \    }\n    return strings.filter((s) => s.startsWith(prefix));\n}", "\tconst\
    \ filtered_strings = strings.filter(s => s.startsWith(prefix));\n\treturn filtered_strings.length\
    \ ? filtered_strings : strings;\n}\n", "  return strings.filter( (s: string) =>\
    \ s.startsWith(prefix));\n}\n", "\tlet prefix_regex = new RegExp(\"^\" + prefix);\n\
    \treturn strings.filter((s: string) => {\n\t\treturn prefix_regex.test(s);\n\t\
    });\n}\n", "    return strings.filter(function(el) {\n        return el.indexOf(prefix)\
    \ === 0;\n    });\n}\n", "\tconst filtered_strings = strings.filter((s) => {\n\
    \t\treturn s.startsWith(prefix);\n\t});\n\treturn filtered_strings;\n}", "   \
    \ return strings.filter(s => s.startsWith(prefix));\n}\n", "\tconst filtered:\
    \ string[] = [];\n\tfor (let i = 0; i < strings.length; i++) {\n\t\tif (strings[i].startsWith(prefix))\
    \ {\n\t\t\tfiltered.push(strings[i]);\n\t\t}\n\t}\n\treturn filtered;\n}\n", " \
    \ return strings.filter(s => s.startsWith(prefix))\n}\n", "  return strings.filter((s)\
    \ => {\n    return s.startsWith(prefix);\n  });\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Great answer.  I did something very similar to this by passing the prefix as a\
    \ parameter to my `filter_by_prefix()` function.  Thanks!\n<|/ c |>\n<| a dscore=2\
    \ tags=javascript,typescript |>\nTry this solution:\n\n<code>", "  return strings.filter(s\
    \ => s.startsWith(prefix));\n}\n", "    return strings.filter(\n        v => v.startsWith(prefix));\n\
    }\n", "    return strings.filter(s => s.startsWith(prefix));\n}\n", "  return\
    \ objects.filter(\n    x => x.startsWith(prefix),\n  );\n}\n", "  return strings.filter(s\
    \ => s.startsWith(prefix));\n}\n", "    const filtered_strings = [];\n    strings.filter(s\
    \ => s.startsWith(prefix)).forEach(s => filtered_strings.push(s));\n    return\
    \ filtered_strings;\n}", "    var new_strings: string[] = [];\n    strings.forEach(function(string:\
    \ string) {\n        if (string.startsWith(prefix)) {\n            new_strings.push(string);\n\
    \        }\n    });\n    return new_strings;\n}\n</code>\n<|/ a |>\n<| a tags=javascript,angularjs,typescript\
    \ dscore=3 |>\nThe easiest way to filter by substring is to use a regular expression\
    \ combined with Array.prototype.filter():\n<code>", "    return strings.filter(function\
    \ (string: string) {\n        return string.startsWith(prefix);\n    });\n}\n",
  "\tconst start_of_prefix = prefix ? strings[0].toLowerCase().startsWith(prefix)\
    \ : strings[0].toLowerCase() === prefix;\n\tconst filtered_strings = strings.filter(s\
    \ => s.toLowerCase().startsWith(prefix));\n\tif (filtered_strings.length === 0)\
    \ {\n\t\tfiltered_strings.push(prefix);\n\t}\n\tif (filtered_strings.length ===\
    \ 1 && start_of_prefix) {\n\t\treturn filtered_strings.map(s => s.substr(prefix.length));\n\
    \t}\n\treturn filtered_strings;\n}\n", "    return strings.filter(function (string:\
    \ string) {\n        return string.startsWith(prefix);\n    });\n}\n", "\tconst\
    \ filtered_strings: string[] = [];\n\tfor (const string of strings) {\n\t\tif\
    \ (string.startsWith(prefix)) {\n\t\t\tfiltered_strings.push(string);\n\t\t}\n\
    \t}\n\treturn filtered_strings;\n}\n", "    if (prefix.length === 0) {\n     \
    \   return strings;\n    }\n\n    return strings.filter(s => s.startsWith(prefix));\n\
    }\n", "    const re = new RegExp(`^${prefix}`);\n    return strings.filter(s =>\
    \ re.test(s));\n}\n", "  return strings.filter((val) => val.startsWith(prefix));\n\
    }\n", "    return strings.filter(s => s.startsWith(prefix));\n}\n", "  prefix\
    \ = prefix.toLowerCase();\n  return strings.filter(s => s.startsWith(prefix));\n\
    }\n", "    return strings.filter(s => s.startsWith(prefix));\n}\n", "\tif (strings.length\
    \ === 0) {\n\t\treturn strings;\n\t}\n\n\tconst prefix_length = prefix.length;\n\
    \treturn strings.filter(s => s.startsWith(prefix));\n}\n", "    const filtered_strings\
    \ = strings.filter(string => {\n        return string.startsWith(prefix);\n  \
    \  });\n    return filtered_strings;\n}\n", "    return strings.filter(string\
    \ => string.startsWith(prefix));\n}\nexports.filter_by_prefix = filter_by_prefix;\n",
  "    return strings.filter(function(string) {\n        return string.indexOf(prefix)\
    \ === 0;\n    });\n}\n", "\treturn strings.filter((s) => s.startsWith(prefix));\n\
    }\n", "  const filtered_strings = strings.filter(function (str) {\n    return\
    \ str.startsWith(prefix);\n  });\n  return filtered_strings;\n}\n", "    const\
    \ prefix_regex = new RegExp(`^${prefix}`);\n    return strings.filter(string =>\
    \ prefix_regex.test(string));\n}\n", "  return strings.filter((s) => s.startsWith(prefix));\n\
    }\n", "  return strings.filter(string => string.startsWith(prefix));\n}\n", " \
    \ return strings.filter((s) => s.startsWith(prefix));\n}\n", "  if (strings.length\
    \ === 0) {\n    return strings;\n  }\n\n  if (prefix.length > 0) {\n    return\
    \ strings.filter((str) => str.startsWith(prefix));\n  }\n\n  return strings;\n\
    }\n", "\treturn strings.filter(a => a.startsWith(prefix));\n}\n", "\tlet new_strings\
    \ = strings.filter(function (string) {\n\t\treturn string.startsWith(prefix);\n\
    \t});\n\treturn new_strings;\n}\n", "    return strings.filter(s => s.startsWith(prefix));\n\
    }\n", "\treturn strings.filter(value => value.startsWith(prefix));\n}\n", "  \
    \  if (strings.length === 0) {\n        return strings;\n    }\n\n    if (prefix.length\
    \ === 0) {\n        return strings.filter(s => s !== '' || !s.startsWith(''));\n\
    \    }\n\n    return strings.filter(s => s.startsWith(prefix));\n}\n", "\treturn\
    \ strings.filter(s => s.startsWith(prefix));\n}\n", "    if (!prefix) {\n    \
    \    return strings;\n    }\n    return strings.filter(s => s.startsWith(prefix));\n\
    }", "    return strings.filter(function(s) { return s.startsWith(prefix); });\n\
    }\n", "  return strings.filter(string => string.startsWith(prefix));\n}\n", " \
    \ return strings.filter(s => s.startsWith(prefix));\n}\n", "    const prefix_length\
    \ = prefix.length;\n    const filtered_strings = new Array<string>();\n    for\
    \ (let i = 0, len = strings.length; i < len; i++) {\n        const string: string\
    \ = strings[i];\n        if (string.length >= prefix_length) {\n            if\
    \ (string.substring(0, prefix_length) === prefix) {\n                filtered_strings.push(string);\n\
    \            }\n        }\n    }\n    return filtered_strings;\n}\n", "\treturn\
    \ strings.filter(s => s.startsWith(prefix))\n}\n", "    if (!strings || !prefix\
    \ || strings.length === 0) {\n        return strings;\n    }\n\n    const prefix_length\
    \ = prefix.length;\n\n    const filtered_strings: string[] = [];\n    for (const\
    \ string in strings) {\n        if (string.startsWith(prefix)) {\n           \
    \ filtered_strings.push(strings[string]);\n        }\n    }\n\n    return filtered_strings;\n\
    }\n", "  return strings.filter(function(item: string) {\n    return item.indexOf(prefix)\
    \ === 0;\n  });\n}\n", "    return strings.filter(s => s.startsWith(prefix));\n\
    }\n", "  if (strings.length == 0) return [];\n  if (strings[0].length == 0) return\
    \ strings;\n  return strings.filter(x => x.indexOf(prefix) == 0);\n}\n", "\tlet\
    \ filter: string[] = [];\n\tfor (let i = 0; i < strings.length; i++) {\n\t\tif\
    \ (strings[i].startsWith(prefix)) {\n\t\t\tfilter.push(strings[i]);\n\t\t}\n\t\
    }\n\treturn filter;\n}\n", "  var new_strings: string[] = [];\n\n  strings.forEach(function\
    \ (str: string) {\n    if (str.indexOf(prefix) === 0) {\n      new_strings.push(str);\n\
    \    }\n  });\n\n  return new_strings;\n}\n", "    return strings.filter(function\
    \ (str) {\n        return str.startsWith(prefix);\n    });\n}\nexports.filter_by_prefix\
    \ = filter_by_prefix;", "  return strings.filter(s => s.startsWith(prefix))\n\
    }\n", "    // We need to use ES6 `Array.prototype.filter` here.\n    return strings.filter(function(val:\
    \ string) {\n        return val.startsWith(prefix);\n    });\n}\n", "\tconst len\
    \ = prefix.length;\n\treturn strings.filter(s => s.startsWith(prefix)).slice(0,\
    \ len);\n}\n", "    return strings.filter(s => s.startsWith(prefix));\n}\n", "\t\
    return strings.filter(x => x.startsWith(prefix));\n}\n", "  const filtered_strings\
    \ = strings.filter(\n    s => s.startsWith(prefix),\n  );\n  return filtered_strings;\n\
    }\n", "\treturn strings.filter(s => s.startsWith(prefix));\n}\n", "  const new_strings\
    \ = strings.filter(function(str) {\n    return str.indexOf(prefix) === 0;\n  });\n\
    \  return new_strings;\n}\n", "    if (strings.length <= 1) {\n        return\
    \ strings;\n    }\n\n    return strings.filter(function (string) {\n        return\
    \ string.substr(0, prefix.length) === prefix;\n    });\n}\n", "\treturn strings.filter((string)\
    \ => string.startsWith(prefix));\n}\n", "  return strings.filter(function (str)\
    \ { return str.startsWith(prefix); })\n}\n", "\tconst prefix_length = prefix.length;\n\
    \treturn strings.filter(s => s.startsWith(prefix));\n}\n", "    const filtered_strings\
    \ = strings.filter(s => s.startsWith(prefix));\n    return filtered_strings;\n\
    }\n", "    return strings.filter(s => s.startsWith(prefix));\n}\n", "\tconst filtered_strings\
    \ = strings.filter((string) => string.startsWith(prefix));\n\treturn filtered_strings;\n\
    }\n", "  const strings_lc = strings.map(s => s.toLowerCase());\n  const prefix_lc\
    \ = prefix.toLowerCase();\n  return strings_lc.filter(s => s.startsWith(prefix_lc));\n\
    }\n", "  return strings.filter(function (str: string) {\n    return str.startsWith(prefix);\n\
    \  });\n}\n", "\tvar rv = [];\n\tstrings.forEach(function (x) {\n\t\tif (x.startsWith(prefix))\
    \ {\n\t\t\trv.push(x);\n\t\t}\n\t});\n\treturn rv;\n}\n", "  if (strings.length\
    \ === 0) {\n    return strings;\n  }\n\n  const matches = new Set<string>();\n\
    \n  strings.filter(str => str.startsWith(prefix)).forEach(string => {\n    matches.add(string);\n\
    \  });\n\n  return Array.from(matches);\n}\n", "\tif (prefix === \"\") {\n\t\t\
    return strings;\n\t}\n\n\tlet filtered: string[] = [];\n\tfor (let i = 0; i <\
    \ strings.length; i++) {\n\t\tif (strings[i].startsWith(prefix)) {\n\t\t\tfiltered.push(strings[i]);\n\
    \t\t}\n\t}\n\n\treturn filtered;\n}\n", "    return strings.filter(s => s.indexOf(prefix)\
    \ === 0);\n}", "    return strings.filter((s) => s.startsWith(prefix));\n}\n",
  "    const prefix_length = prefix.length;\n    return strings.filter((s: string)\
    \ => (s.length > prefix_length)).filter(\n        (s: string) => s.startsWith(prefix)\n\
    \    );\n}", "  return strings.filter(function (str) {\n    return str.startsWith(prefix);\n\
    \  });\n}", "  return objects.filter(string => string.startsWith(prefix));\n}\n",
  "  const prefix_len = prefix.length;\n\n  return strings.filter(s => s.startsWith(prefix));\n\
    }\n", "  return strings.filter(function (str) { return str.startsWith(prefix);\
    \ });\n}\n", "    return strings.filter(function(item) {\n        return item.indexOf(prefix)\
    \ === 0;\n    });\n}\n", "  return strings.filter(\n    item => item.startsWith(prefix));\n\
    }\n", "  return strings.filter(function (val) { return val.startsWith(prefix);\
    \ });\n}\n", "\treturn strings.filter(s => s.startsWith(prefix));\n}\n", "  return\
    \ strings.filter(x => x.startsWith(prefix));\n}\n", "    return strings.filter(function(s:\
    \ string) {\n        return s.startsWith(prefix);\n    });\n}\n", "  return strings.filter((string)\
    \ => {\n    return string.startsWith(prefix);\n  });\n}\n", "    let ret: string[]\
    \ = [];\n    strings.forEach((s) => {\n        if (s.startsWith(prefix)) {\n \
    \           ret.push(s);\n        }\n    });\n    return ret;\n}\n", "  const\
    \ result: string[] = [];\n\n  for (let i = 0; i < strings.length; i++) {\n   \
    \ if (strings[i].startsWith(prefix)) {\n      result.push(strings[i]);\n    }\n\
    \  }\n\n  return result;\n}\n", "  return strings.filter((s) => s.startsWith(prefix));\n\
    }\n", "  return strings.filter(s => s.startsWith(prefix));\n}\n", "    return\
    \ strings.filter(x => x.startsWith(prefix));\n}\nexport = filter_by_prefix;\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for posting your solution, James.\
    \  I actually prefer this solution to my own.\n<|/ c |>\n<| a |>\nFor ES5, this\
    \ should work for you:\n<code>\nvar str = \"hello world\";\nvar filteredString\
    \ = str.match(/[a-z]/gi);\n</code>\n<|/ a tags=javascript,filtering,string dscore=1\
    \ |>\n<| c |>\nThanks. I like this solution, though I do want to stick to Javascript\
    \ since I'm more familiar with it.\n<|/ c |>\n<| a dscore=1 |>\nI really liked\
    \ the previous two solutions given by James and Mark Byers, but I wanted to find\
    \ a solution that used ES5 methods, so here's my contribution:\n<code>", "  for\
    \ (var i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(prefix) ===\
    \ 0) {\n      strings.splice(i, 1);\n      i--;\n    }\n  }\n  return strings;\n\
    }\n", "  let result: string[] = [];\n  for (let i = 0; i < strings.length; ++i)\
    \ {\n    if (strings[i].startsWith(prefix)) {\n      result.push(strings[i]);\n\
    \    }\n  }\n  return result;\n}\n", "    return strings.filter(s => s.startsWith(prefix));\n\
    }\n", "  return strings.filter(s => s.startsWith(prefix));\n}\n", "\tlet filtered_strings:\
    \ string[] = [];\n\tfor (let string of strings) {\n\t\tif (string.startsWith(prefix))\
    \ {\n\t\t\tfiltered_strings.push(string);\n\t\t}\n\t}\n\treturn filtered_strings;\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
