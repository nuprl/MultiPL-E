name: HumanEval_20_find_closest_elements
language: ts
prompt: "//From a supplied array of numbers (of length at least two) select and return\
  \ two that are the closest to each\n// other and return them in order (smaller number,\
  \ larger number).\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  // [2.0, 2.2]\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n//\
  \ [2.0, 2.0]\nfunction find_closest_elements(numbers: number[]): [number, number]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = find_closest_elements;\n  assert.deepEqual(candidate([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);\n  assert.deepEqual(candidate([1.0, 2.0,\
  \ 5.9, 4.0, 5.0]),[5.0, 5.9]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]),[2.0, 2.2]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]),[2.0, 2.0]);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2,\
  \ 3.1]);\n}\n\ntest();"
completions: ["  const smallest_square_difference = Number.POSITIVE_INFINITY;\n  const\
    \ smallest_square = Number.POSITIVE_INFINITY;\n  const smallest_difference = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < numbers.length - 2; i++) {\n    const currentSquare = Math.pow(numbers[i],\
    \ 2);\n    const currentDifference = Math.abs(currentSquare - numbers[i + 1]);\n\
    \    if (currentDifference < smallest_square_difference) {\n      smallest_square_difference\
    \ = currentDifference;\n      smallest_square = currentSquare;\n    }\n    if\
    \ (currentDifference < smallest_difference) {\n      smallest_difference = currentDifference;\n\
    \    }\n  }\n  const closest = [numbers[numbers.length - 1], numbers[numbers.length\
    \ - 2]];\n  if (smallest_square < smallest_difference) {\n    closest = [numbers[numbers.length\
    \ - 2], numbers[numbers.length - 1]];\n  }\n  return closest;\n}\n", "\tconst\
    \ sorted_numbers = numbers.sort((a, b) => a - b);\n\tlet current_closest_one =\
    \ sorted_numbers[0];\n\tlet current_closest_two = sorted_numbers[1];\n\tfor (let\
    \ i = 1; i < numbers.length; i++) {\n\t\tconst current_distance = sorted_numbers[i]\
    \ - current_closest_one;\n\t\tif (current_distance < current_closest_two) {\n\t\
    \t\tcurrent_closest_two = current_closest_one;\n\t\t\tcurrent_closest_one = sorted_numbers[i];\n\
    \t\t} else if (current_distance > current_closest_one) {\n\t\t\tcurrent_closest_two\
    \ = current_closest_one;\n\t\t\tcurrent_closest_one = sorted_numbers[i];\n\t\t\
    } else {\n\t\t\tcurrent_closest_one = sorted_numbers[i];\n\t\t}\n\t}\n\treturn\
    \ [current_closest_one, current_closest_two];\n}\n", "  const closest = numbers.reduce((min1,\
    \ max1) => {\n    const min2 = numbers.reduce((min2, max2) => {\n      return\
    \ min2 + (Math.abs(max2 - min2) < Math.abs(max1 - min1) ? max2 : max1);\n    },\
    \ Number.MAX_SAFE_INTEGER);\n    return [Math.min(min1, min2), Math.max(min1,\
    \ min2)];\n  }, Number.MAX_SAFE_INTEGER);\n  return [numbers[numbers.length -\
    \ 1], closest];\n}\n", "  const smallest = numbers[0];\n  const largest = numbers[0];\n\
    \  for (const num of numbers) {\n    if (Math.abs(num - largest) < Math.abs(num\
    \ - smallest)) {\n      largest = num;\n    } else {\n      smallest = num;\n\
    \    }\n  }\n  return [smallest, largest];\n}\n", "    if (numbers.length < 2)\
    \ {\n        return [numbers[0], numbers[0]];\n    }\n\n    const [smallest, largest]\
    \ = numbers.map(value => {\n        return [value, value];\n    });\n\n    const\
    \ [small, large] = numbers.map(value => {\n        return [value, value];\n  \
    \  });\n\n    let j = 0;\n    let k = 1;\n    while (j < numbers.length && k <=\
    \ largest) {\n        const value = numbers[j];\n\n        if (value < small)\
    \ {\n            j++;\n            continue;\n        }\n\n        if (value >\
    \ large) {\n            k++;\n            continue;\n        }\n\n        const\
    \ [newSmall, newLarge] = [small, large];\n        if (newSmall === value) {\n\
    \            newSmall = value;\n        }\n        if (newLarge === value) {\n\
    \            newLarge = value;\n        }\n\n        if (newSmall < value) {\n\
    \            small = value;\n        } else {\n            large = value;\n  \
    \      }\n\n        j++;\n        k++;\n    }\n\n    const [closestSmall, closestLarge]\
    \ = [small, large];\n    if (largest * 2 < numbers.length) {\n        closestSmall\
    \ = numbers[largest * 2];\n        closestLarge = numbers[largest * 2 + 1];\n\
    \    }\n\n    return [closestSmall, closestLarge];\n}\n", "\tconst [smallest,\
    \ largest] = numbers;\n\tconst index = numbers.findIndex((n) => n > largest &&\
    \ n < smallest);\n\tif (index !== -1) {\n\t\treturn [numbers[index], largest];\n\
    \t}\n\treturn [smallest, largest];\n}\n", "  let [smallest_one, largest_one] =\
    \ numbers\n  if (smallest_one == largest_one) {\n    return [smallest_one, smallest_one]\n\
    \  }\n  let [smallest_two, largest_two] = numbers\n  if (smallest_one == largest_two)\
    \ {\n    return [smallest_one, smallest_two]\n  }\n  let [smallest_three, largest_three]\
    \ = numbers\n  if (smallest_two == largest_three) {\n    return [smallest_two,\
    \ smallest_three]\n  }\n  let [smallest_four, largest_four] = numbers\n  if (smallest_three\
    \ == largest_four) {\n    return [smallest_three, smallest_four]\n  }\n  let [smallest_five,\
    \ largest_five] = numbers\n  if (smallest_four == largest_five) {\n    return\
    \ [smallest_four, smallest_five]\n  }\n  let [smallest_six, largest_six] = numbers\n\
    \  if (smallest_five == largest_six) {\n    return [smallest_five, smallest_six]\n\
    \  }\n  let [smallest_seven, largest_seven] = numbers\n  if (smallest_six == largest_seven)\
    \ {\n    return [smallest_six, smallest_seven]\n  }\n  let [smallest_eight, largest_eight]\
    \ = numbers\n  if (smallest_seven == largest_eight) {\n    return [smallest_seven,\
    \ smallest_eight]\n  }\n  let [smallest_nine, largest_nine] = numbers\n  if (smallest_eight\
    \ == largest_nine) {\n    return [smallest_eight, smallest_nine]\n  }\n  throw\
    \ new Error(\"find_closest_elements(): can't find any solution to given array\"\
    )\n}\n", "\tlet result = [];\n\tlet minimum = Number.MAX_SAFE_INTEGER;\n\tlet\
    \ maximum = Number.MIN_SAFE_INTEGER;\n\n\tfor (let element of numbers) {\n\t\t\
    if (element <= minimum) {\n\t\t\tminimum = element;\n\t\t}\n\n\t\tif (element\
    \ >= maximum) {\n\t\t\tmaximum = element;\n\t\t}\n\n\t\tresult.push(element);\n\
    \t}\n\n\tif (result.length === 0) {\n\t\treturn [minimum, maximum];\n\t}\n\n\t\
    if (result.length === 1) {\n\t\treturn [result[0], minimum];\n\t}\n\n\tif (minimum\
    \ === maximum) {\n\t\treturn result;\n\t}\n\n\tconst mid = Math.round((minimum\
    \ + maximum) / 2);\n\treturn [result[result.indexOf(mid) - 1], mid];\n}\n", " \
    \ if (numbers.length < 2) return [numbers[0], numbers[0]];\n  let minDiff = Number.MAX_VALUE;\n\
    \  let min1 = numbers[0];\n  let min2 = numbers[0];\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    const diff = Math.abs(numbers[i] - min1);\n    if (diff < minDiff)\
    \ {\n      min1 = numbers[i];\n      minDiff = diff;\n    } else if (diff ===\
    \ minDiff) {\n      min2 = numbers[i];\n    }\n  }\n  return [min1, min2];\n}\n",
  "\tif (numbers.length < 2)\n\t\tthrow new Error(\"need at least two numbers\")\n\
    \tlet smallest = numbers[0]\n\tlet largest = numbers[0]\n\tfor (let i = 1; i <\
    \ numbers.length; i++) {\n\t\tif (numbers[i] > largest)\n\t\t\tlargest = numbers[i]\n\
    \t\tif (numbers[i] < smallest)\n\t\t\tsmallest = numbers[i]\n\t}\n\treturn [smallest,\
    \ largest]\n}\n", "    const closest_indexes = find_closest_indexes(numbers);\n\
    \    let min_index = Math.min(...closest_indexes);\n    let max_index = Math.max(...closest_indexes);\n\
    \    return [numbers[min_index], numbers[max_index]];\n}\n", "    if (numbers.length\
    \ < 2) {\n        throw new RangeError(\"'numbers' array must have at least two\
    \ elements\");\n    }\n\n    var a = numbers[0],\n        b = numbers[1];\n  \
    \  var index = (b - a) / 2;\n\n    if (index < 0) {\n        throw new RangeError(\"\
    'numbers' array must have at least two elements\");\n    }\n\n    return [numbers[index],\
    \ numbers[index + 1]];\n}\n", "\tif (numbers.length < 2) {\n\t\tthrow new Error('find_closest_elements():\
    \ ' +\n\t\t\t'Array must contain at least two elements');\n\t}\n\tvar smallest\
    \ = numbers[0], largest = numbers[0], minLargerAbs = Number.MAX_VALUE;\n\tfor\
    \ (var i = 1; i < numbers.length; ++i) {\n\t\tvar cur = numbers[i];\n\t\tvar curAbs\
    \ = Math.abs(cur);\n\t\tif (curAbs < minLargerAbs) {\n\t\t\tminLargerAbs = curAbs;\n\
    \t\t\tsmallest = cur;\n\t\t} else if (curAbs > largest) {\n\t\t\tlargest = cur;\n\
    \t\t}\n\t}\n\treturn [smallest, largest];\n}\n", "\tlet smallest_diff = Number.MAX_VALUE;\n\
    \tlet smallest: number;\n\tlet largest: number;\n\tnumbers.forEach(n => {\n\t\t\
    let diff = Math.abs(n - numbers[largest]);\n\t\tif (diff < smallest_diff) {\n\t\
    \t\tsmallest_diff = diff;\n\t\t\tsmallest = n;\n\t\t}\n\t\tif (diff > smallest_diff)\
    \ {\n\t\t\tlargest = n;\n\t\t}\n\t});\n\tlet result = [smallest, largest];\n\t\
    return result;\n}\n", "\t// find the closest number in a set of numbers\n\tlet\
    \ min = numbers[0];\n\tlet max = numbers[0];\n\tfor (let i = 1; i < numbers.length;\
    \ ++i) {\n\t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\t\t}\n\t\tif\
    \ (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\tif (min === max)\
    \ {\n\t\tmin = -1;\n\t\tmax = -1;\n\t}\n\treturn [min, max];\n}\n", "    if (numbers.length\
    \ < 2) {\n        throw new ArgumentError(\n            \"find_closest_elements\
    \ expects at least two numbers\"\n        );\n    }\n\n    numbers = numbers.sort((a,\
    \ b) => a - b);\n\n    var i1: number, i2: number;\n    var dist1: number, dist2:\
    \ number;\n    var smallestDiff: number = numbers[0] - numbers[1];\n\n    for\
    \ (i1 = 1; i1 < numbers.length - 1; i1++) {\n        dist1 = numbers[i1] - numbers[i1\
    \ - 1];\n        for (i2 = i1 + 1; i2 < numbers.length; i2++) {\n            dist2\
    \ = numbers[i2] - numbers[i1 - 1];\n            if (Math.abs(dist1 - dist2) <\
    \ smallestDiff) {\n                smallestDiff = Math.abs(dist1 - dist2);\n \
    \               i1 = i2;\n            }\n        }\n    }\n\n    return [numbers[i1],\
    \ numbers[i1 + 1]];\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\n\
    \    double ClosestNumbers(List<int> input)\n    {\n        double closest1 =\
    \ double.MaxValue;\n        double closest2 = double.MaxValue;\n        double\
    \ closest3 = double.MaxValue;\n        double closest4 = double.MaxValue;\n\n\
    \        double closestDiff = double.MaxValue;\n        int closest1Index = 0;\n\
    \        int closest2Index = 0;\n        int closest3Index = 0;\n        int closest4Index\
    \ = 0;\n\n        for (int i = 0; i < input.Count; i++)\n        {\n         \
    \   if (input[i] < closest1)\n            {\n                closest1 = input[i];\n\
    \                closest1Index = i;\n            }\n            if (input[i] <\
    \ closest2)\n            {\n                closest2 = input[i];\n           \
    \     closest2Index = i;\n            }\n            if (input[i] < closest3)\n\
    \            {\n                closest3 = input[i];\n                closest3Index\
    \ = i;\n            }\n            if (input[i] < closest4)\n            {\n \
    \               closest4 = input[i];\n                closest4Index = i;\n   \
    \         }\n\n            double currDiff = Math.Abs(closest1Index - closest2Index);\n\
    \            if (currDiff < closestDiff)\n            {\n                closestDiff\
    \ = currDiff;\n                closest1 = closest1Index;\n                closest2\
    \ = closest2Index;\n                closest3 = closest3Index;\n              \
    \  closest4 = closest4Index;\n            }\n        }\n\n        double[] closestNumbers\
    \ = new double[4];\n        closestNumbers[0] = closest1;\n        closestNumbers[1]\
    \ = closest2;\n        closestNumbers[2] = closest3;\n        closestNumbers[3]\
    \ = closest4;\n\n        return closestNumbers;\n    }\n</code>\n<|/ a tags=arrays,algorithm,c#\
    \ |>\n<| a dscore=1 |>\n<code>\nusing System;\nusing System.", "  if (numbers.length\
    \ < 2) {\n    return [numbers[0], numbers[0]];\n  }\n  let closest_1 = numbers[0];\n\
    \  let closest_2 = numbers[0];\n  for (let i = 1; i < numbers.length; ++i) {\n\
    \    const close_enough = numbers[i] - closest_1;\n    if (close_enough < Math.abs(closest_1\
    \ - closest_2)) {\n      closest_2 = closest_1;\n      closest_1 = numbers[i];\n\
    \    } else {\n      closest_2 = numbers[i];\n    }\n  }\n  return [closest_1,\
    \ closest_2];\n}\n", "  if (numbers.length < 2) {\n    throw new Error(`find_closest_elements():\
    \ Input array too small: ${numbers.length}`);\n  }\n\n  const min_diff = Math.abs(numbers[0]\
    \ - numbers[1]);\n\n  let best_element: number | undefined = undefined;\n  let\
    \ best_index: number | undefined = undefined;\n\n  for (let i = 2; i < numbers.length;\
    \ i++) {\n    const current_diff = Math.abs(numbers[i] - numbers[i - 1]);\n\n\
    \    if (current_diff < min_diff) {\n      min_diff = current_diff;\n      best_element\
    \ = numbers[i];\n      best_index = i - 1;\n    }\n  }\n\n  if (!best_index) {\n\
    \    throw new Error(`find_closest_elements(): Input array too small: ${numbers.length}`);\n\
    \  }\n\n  return [best_element, best_index];\n}\n", "  const smallest = numbers[0];\n\
    \  const largest = numbers[numbers.length - 1];\n\n  const result = [smallest,\
    \ largest];\n\n  for (let i = 1; i < numbers.length; i++) {\n    const difference\
    \ = numbers[i] - numbers[i - 1];\n    if (difference < smallest) {\n      smallest\
    \ = difference;\n    } else if (difference > largest) {\n      largest = difference;\n\
    \    }\n  }\n\n  return result;\n}\n", "\tlet result: number[] = [];\n\tlet min:\
    \ number = Number.MAX_SAFE_INTEGER;\n\tlet max: number = Number.MIN_SAFE_INTEGER;\n\
    \tfor (let i = 0; i < numbers.length; i++) {\n\t\tlet number = numbers[i];\n\t\
    \tif (number < min) {\n\t\t\tmin = number;\n\t\t} else if (number > max) {\n\t\
    \t\tmax = number;\n\t\t}\n\t}\n\tresult.push(min);\n\tresult.push(max);\n\treturn\
    \ result;\n}\n", "\tnumbers = numbers.sort((a, b) => a - b);\n\tlet minDiff =\
    \ numbers[0];\n\tlet minIndex = numbers[0];\n\tlet index = 0;\n\tfor (let i =\
    \ 1; i < numbers.length; i++) {\n\t\tlet diff = Math.abs(numbers[i] - numbers[index]);\n\
    \t\tif (diff < minDiff) {\n\t\t\tminDiff = diff;\n\t\t\tminIndex = index;\n\t\t\
    }\n\t\tindex++;\n\t}\n\treturn [minIndex, minDiff];\n}\n", "  var min_diff = Number.MAX_VALUE;\n\
    \  var min_index = 0;\n  for (var i = 1; i < numbers.length; ++i) {\n    var diff\
    \ = numbers[i] - numbers[i - 1];\n    if (diff < min_diff) {\n      min_diff =\
    \ diff;\n      min_index = i;\n    }\n  }\n  return [numbers[min_index], numbers[min_index\
    \ - 1]];\n}\n", "  const numbers_sorted = numbers.sort(function (a: number, b:\
    \ number) {\n    return a - b;\n  });\n  let current_index = 0;\n  let closest\
    \ = [];\n  let closest_dist = null;\n\n  // If numbers is only 1 number then we\
    \ only need to return it\n  if (numbers.length === 1) {\n    closest = [numbers[0]];\n\
    \    closest_dist = numbers[0];\n    return closest;\n  }\n\n  while (numbers_sorted[current_index]\
    \ < numbers[current_index + 1]) {\n    // The next closest number is the current\
    \ number plus the next one\n    closest = [numbers[current_index]];\n    closest_dist\
    \ = numbers[current_index];\n\n    current_index++;\n    while (numbers_sorted[current_index]\
    \ < numbers[current_index + 1]) {\n      closest = [...closest, [numbers[current_index\
    \ + 1]]];\n      current_index++;\n    }\n  }\n\n  return closest;\n}\n", "  numbers.sort((a,\
    \ b) => Math.abs(a - b));\n  return numbers.slice(0, 2);\n}\n", "  const sorted_numbers\
    \ = numbers.slice().sort((a: number, b: number) => a - b);\n  const idx = sorted_numbers.findIndex((num)\
    \ => sorted_numbers.indexOf(num) === 0);\n  return [sorted_numbers[0], sorted_numbers[idx\
    \ + 1]];\n}\n", "    var n = numbers.length, closest = Number.MAX_VALUE;\n   \
    \ if (n === 0) {\n        return [numbers[0], numbers[0]];\n    }\n    else if\
    \ (n === 1) {\n        return [numbers[0], numbers[1]];\n    }\n    else {\n \
    \       var lower = numbers[0];\n        var upper = numbers[0];\n        for\
    \ (var i = 1; i < n - 1; i++) {\n            if (numbers[i] > upper) {\n     \
    \           upper = numbers[i];\n            }\n            else if (numbers[i]\
    \ < lower) {\n                lower = numbers[i];\n            }\n        }\n\
    \        return [lower, upper];\n    }\n}\n", "  const smallestDifference = Number.MAX_SAFE_INTEGER;\n\
    \  const smallestDifferenceIndex = -1;\n  const index1ToMatch = null;\n\n  for\
    \ (let i = 0; i < numbers.length; i++) {\n    const currentDifference = diff(numbers[i],\
    \ numbers[index1ToMatch]);\n    if (currentDifference < smallestDifference) {\n\
    \      smallestDifference = currentDifference;\n      smallestDifferenceIndex\
    \ = i;\n    }\n  }\n\n  if (smallestDifferenceIndex === -1) {\n    return null;\n\
    \  }\n\n  return [numbers[smallestDifferenceIndex], numbers[index1ToMatch]];\n\
    }\n", "  if (numbers.length < 2) {\n    throw \"Can't find two closest numbers\
    \ without providing any data!\";\n  }\n\n  let min_dist = Number.MAX_VALUE;\n\
    \  let min_idx = -1;\n  for (let i = 0; i < numbers.length - 1; i++) {\n    let\
    \ dist = dist_of(numbers[i], numbers[i + 1]);\n    if (dist < min_dist) {\n  \
    \    min_dist = dist;\n      min_idx = i;\n    }\n  }\n  return [numbers[min_idx],\
    \ numbers[min_idx + 1]];\n}\n", "    const smallest = Math.min(numbers[0], numbers[1]);\n\
    \    const largest = Math.max(numbers[0], numbers[1]);\n    return [smallest,\
    \ largest];\n}\n", "    let smallest_number = numbers[0];\n    let largest_number\
    \ = numbers[0];\n    for (let i = 1; i < numbers.length; i++) {\n        if (numbers[i]\
    \ < smallest_number) {\n            smallest_number = numbers[i];\n        }\n\
    \        if (numbers[i] > largest_number) {\n            largest_number = numbers[i];\n\
    \        }\n    }\n    return [smallest_number, largest_number];\n}\nexports.find_closest_elements\
    \ = find_closest_elements;", "    let len = numbers.length\n    if (len < 2) return\
    \ numbers\n    let min = numbers[0]\n    let max = numbers[0]\n    for (let i\
    \ = 1; i < len; i++) {\n        if (numbers[i] > max) max = numbers[i]\n     \
    \   else if (numbers[i] < min) min = numbers[i]\n    }\n    return [min, max]\n\
    }\n", "\tlet best: number = numbers[0]\n\n\tfor (let i = 1; i < numbers.length;\
    \ i += 1) {\n\t\tlet difference: number = numbers[i] - best\n\t\tlet difference2:\
    \ number = numbers[i - 1] - best\n\t\tif (difference < difference2) {\n\t\t\t\
    best = numbers[i]\n\t\t}\n\t}\n\treturn [best, numbers[0]]\n}\n", "  let [smallest,\
    \ largest] = numbers;\n  return [\n    smallest < largest\n      ? smallest\n\
    \      : largest,\n    smallest > largest\n      ? largest\n      : smallest,\n\
    \  ];\n}\n", "  // Get all differences between the number and the numbers\n  const\
    \ distances = numbers.map((number) => {\n    const difference = Math.abs(number\
    \ - numbers[numbers.length - 1]);\n    return difference;\n  });\n\n  // Find\
    \ the smallest difference and the index of that difference\n  const smallest =\
    \ Math.min(...distances);\n  const indexOfMin = distances.indexOf(smallest);\n\
    \n  // Get the closest two numbers and the index\n  const closest = numbers[indexOfMin];\n\
    \  const closestIndex = indexOfMin;\n\n  return [closest, closestIndex];\n}\n",
  "  let sorted_list = numbers.slice();\n  sorted_list.sort();\n  let smallest = -Number.MAX_VALUE;\n\
    \  let largest = Number.MAX_VALUE;\n  for (let i = 0; i < sorted_list.length;\
    \ i++) {\n    smallest = smallest > sorted_list[i] ? smallest : sorted_list[i];\n\
    \    largest = largest < sorted_list[i] ? largest : sorted_list[i];\n  }\n  if\
    \ (smallest == largest) {\n    return [smallest, smallest];\n  } else {\n    if\
    \ (smallest < largest) {\n      return [smallest, largest];\n    } else {\n  \
    \    return [largest, smallest];\n    }\n  }\n}\n", "    const sorted_numbers\
    \ = [...numbers]; // clone the array\n    sorted_numbers.sort(); // sort\n   \
    \ const closest = [sorted_numbers[0]];\n    for (let index = 1; index < sorted_numbers.length;\
    \ index++) {\n        if (Math.abs(sorted_numbers[index - 1] - sorted_numbers[index])\
    \ < Math.abs(closest[closest.length - 1] - closest[0])) {\n            closest\
    \ = [...closest, sorted_numbers[index]];\n        }\n    }\n    return closest;\n\
    }\n", "    // Okay, here is the meat. This loop will run the while loop and exit\
    \ when \n    // the array is empty. Thus, we start with the first element of numbers,\
    \ \n    // set our index to zero (because this is the first element).\n    var\
    \ index = 0;\n    // We also need to remember the original index that we used\
    \ to get the \n    // original element (this is where we start counting at 1).\n\
    \    var orig_index = index;\n    // We also need a variable to hold the smallest\
    \ distance.\n    var smallestDistance = numbers[0];\n    // Finally, we need a\
    \ variable to hold the second smallest distance.\n    var secondSmallestDistance\
    \ = numbers[0];\n    // Now, we run our while loop which checks every element\
    \ and compares it to \n    // the smallest and second smallest distances. \n \
    \   while (index < numbers.length-1) {\n        // The first thing we do is get\
    \ the current element in our array. \n        var element = numbers[index];\n\
    \        // Then we check to see if this element is the smallest distance. If\
    \ it \n        // is the smallest distance, we replace it with the smallest distance\n\
    \        // we've found so far, and we also update the index.\n        if (smallestDistance\
    \ > element) {\n            smallestDistance = element;\n            index = orig_index;\n\
    \            // After we update the index to point to the original index we \n\
    \            // got it from, we update the orig_index to point to the next \n\
    \            // element in our array. This is how we get the next element to \n\
    \            // compare to.\n            orig_index++;\n        } else {\n   \
    \         // If it doesn't contain the smallest distance, we can just check to\
    \ \n            // see if the second smallest distance is greater than our current\
    \ \n            // element. Once we have found the second smallest distance we\
    \ update \n            // this element as our smallest distance and update the\
    \ index \n            // to point to the next element in our array. This is how\
    \ we get \n            // the next element to compare to.\n            if (secondSmallestDistance\
    \ > element) {\n                secondSmallestDistance = element;\n          \
    \      index = orig_index;\n                // After we update the index to point\
    \ to the original index we \n                // got it from, we update the orig_index\
    \ to point to the next \n                // element in our array. This is how\
    \ we get the next element to \n                // compare to.\n              \
    \  orig_index++;\n            }\n        }\n    }\n    // Finally, we return the\
    \ two elements that are closest to each other.\n    return [smallestDistance,\
    \ secondSmallestDistance];\n}\n</code>\nYou might want to go over the code I posted\
    \ and see what it does. I wrote it up pretty quickly so there might be some mistakes\
    \ that you won't know about, but I hope you get the general idea of what it does.\n\
    <|/ a dscore=2 tags=algorithm,arrays,javascript |>\n<| a |>", "\tconst a = arrayify(numbers);\n\
    \tlet result = [];\n\tlet min = null;\n\tlet min_index = 0;\n\tfor (let index\
    \ = 0; index < a.length; ++index) {\n\t\tconst b = a[index];\n\t\tif (min ===\
    \ null || Math.abs(a - b) < Math.abs(min - b)) {\n\t\t\tmin = a;\n\t\t\tmin_index\
    \ = index;\n\t\t}\n\t}\n\treturn [a[min_index], a[min_index]];\n}\n", "  if (numbers.length\
    \ <= 1) {\n    return numbers;\n  }\n\n  const m = numbers.length;\n  const r\
    \ = Number.MAX_VALUE;\n  const s = Number.MIN_VALUE;\n\n  for (let i = 1; i <\
    \ m; i++) {\n    const b = numbers[i] - numbers[i - 1];\n    const d = numbers[i]\
    \ - numbers[i - 1];\n\n    if (Math.abs(b) > r) {\n      r = Math.abs(b);\n  \
    \    s = i;\n    }\n\n    if (Math.abs(d) < r) {\n      r = Math.abs(d);\n   \
    \   s = i;\n    }\n  }\n\n  return [numbers[s - 1], numbers[s]];\n}\n", "    if\
    \ (numbers.length < 2) {\n        throw Error(`Unable to find closest pair of\
    \ elements. Numbers array has fewer than two elements: ${numbers.length}`);\n\
    \    }\n    let smallestDiff = numbers[0].substract(numbers[1]);\n    let biggestDiff\
    \ = numbers[1].substract(numbers[0]);\n    let middle = Math.round(numbers.length\
    \ / 2);\n    let results = [];\n    for (let i = 1; i < numbers.length - 1; i\
    \ += 1) {\n        let diff = numbers[i].substract(numbers[middle]);\n       \
    \ if (diff.abs < smallestDiff.abs) {\n            smallestDiff = diff;\n     \
    \       results = [numbers[middle], numbers[i]];\n        } else if (diff.abs\
    \ > biggestDiff.abs) {\n            biggestDiff = diff;\n            results =\
    \ [numbers[i], numbers[middle]];\n        } else {\n            results.push([numbers[middle],\
    \ numbers[i]]);\n        }\n    }\n    return results;\n}\n", "  numbers.sort(function\
    \ (a, b) { return a - b; });\n  var low = 0;\n  var high = numbers.length - 1;\n\
    \  var mid;\n  var closest;\n  do {\n    mid = Math.floor( (high + low) / 2);\n\
    \    closest = numbers[mid];\n    if (closest < numbers[low])\n      low = mid;\n\
    \    else if (closest > numbers[high])\n      high = mid;\n  } while (high > low);\n\
    \  return [numbers[low], numbers[high]];\n}\n</code>\n<|/ a tags=sorting,javascript,arrays\
    \ |>\n<| c |>\nIt looks like it works only in ascending order, not in descending\
    \ order.\n<|/ c |>\n<| c |>\n- you are right, I did not test the solution, but\
    \ that could be easily changed, by changing the order of the comparator in the\
    \ `sort` function. Edited.\n<|/ c |>\n<| a dscore=3 |>\nTry following code:\n\
    <code>\nvar numbers = [1, 2, 3, 4, 5];\n\nvar numbersInDescOrder = numbers.slice().reverse();\n\
    \nconsole.log(numbersInDescOrder);\n</code>\n<|/ a tags=sorting,javascript,arrays\
    \ |>\n<| a tags=sorting,javascript,arrays dscore=2 |>\nI realise this question\
    \ was answered a while ago, and since I believe it's a better answer than the\
    \ ones already provided, I thought I'd share my answer. It was based off of the\
    \ accepted answer but with a different ordering.\n<code>\nvar numbers = [1, 2,\
    \ 3, 4, 5];\n\nnumbers.sort(function (a, b) {\n    return a - b;\n});\n\nconsole.log(numbers);\n\
    </code>\nResult: [5, 4, 3, 2, 1]\n<|/ a |>\n<| a dscore=2 |>\n<code>", "  // Sort\
    \ numbers to reduce calls to distance\n  numbers.sort(function (a: number, b:\
    \ number) {\n    return a - b;\n  });\n\n  const result: [number, number] = [numbers[0],\
    \ numbers[0]];\n  for (let i = 1; i < numbers.length; ++i) {\n    const d = distance(numbers[i],\
    \ numbers[i - 1]);\n    if (d < result[0]) {\n      result[0] = d;\n      result[1]\
    \ = numbers[i];\n    }\n  }\n  return result;\n}\n", "\tif (!numbers.length)\n\
    \t\treturn [];\n\tconst [smallest, largest] = numbers.sort((a, b) => a - b);\n\
    \tconst result = numbers.filter((element) => {\n\t\treturn element >= smallest\
    \ && element <= largest;\n\t});\n\tif (result.length < numbers.length)\n\t\tresult.push(largest\
    \ + 1);\n\treturn result;\n}\n", "\tif (numbers.length < 2)\n\t\treturn numbers;\n\
    \n\tconst smallest_diff = mathf.Abs(numbers[0] - numbers[1]);\n\tconst largest_diff\
    \ = mathf.Abs(numbers[0] - numbers[numbers.length - 1]);\n\n\tlet smallest_number\
    \ = numbers[0];\n\tlet largest_number = numbers[0];\n\tlet found = false;\n\t\
    for (let i = 0; i < numbers.length; i++) {\n\t\tconst current_diff = mathf.Abs(numbers[i]\
    \ - numbers[smallest_number]);\n\t\tif (found && current_diff < smallest_diff)\
    \ {\n\t\t\tlargest_number = numbers[i];\n\t\t} else if (found && current_diff\
    \ > smallest_diff) {\n\t\t\tsmallest_number = numbers[i];\n\t\t\tfound = false;\n\
    \t\t} else if (!found && current_diff < smallest_diff) {\n\t\t\tfound = true;\n\
    \t\t\tsmallest_number = numbers[i];\n\t\t} else if (found && current_diff > smallest_diff)\
    \ {\n\t\t\tfound = false;\n\t\t\tlargest_number = numbers[i];\n\t\t}\n\t}\n\n\t\
    if (smallest_number < numbers[0])\n\t\treturn [smallest_number, smallest_number];\n\
    \telse if (largest_number > numbers[numbers.length - 1])\n\t\treturn [largest_number,\
    \ largest_number];\n\telse\n\t\treturn [smallest_number, largest_number];\n}\n",
  "  numbers = numbers.slice();\n  numbers.push(Number.MAX_SAFE_INTEGER);\n  let min1\
    \ = Number.MAX_SAFE_INTEGER;\n  let max1 = Number.MIN_SAFE_INTEGER;\n  let min2\
    \ = Number.MAX_SAFE_INTEGER;\n  let max2 = Number.MIN_SAFE_INTEGER;\n  for (let\
    \ i = 0; i < numbers.length - 1; i = i + 2) {\n    min1 = Math.min(min1, numbers[i]);\n\
    \    max1 = Math.max(max1, numbers[i]);\n    min2 = Math.min(min2, numbers[i +\
    \ 1]);\n    max2 = Math.max(max2, numbers[i + 1]);\n  }\n  if (min1 === max1)\
    \ {\n    return [min1, min2];\n  }\n  if (min2 === max2) {\n    return [max1,\
    \ max2];\n  }\n  let mid1 = (max1 + min1) / 2;\n  let mid2 = (max2 + min2) / 2;\n\
    \  if (min1 < mid1) {\n    if (min2 < mid2) {\n      return [min2, mid2];\n  \
    \  }\n    return [min1, mid1];\n  }\n  if (mid1 < max1) {\n    if (mid2 < max2)\
    \ {\n      return [mid2, max2];\n    }\n    return [mid1, max1];\n  }\n  if (max1\
    \ < mid2) {\n    return [max1, max2];\n  }\n  return [mid2, mid1];\n}\n", "  if\
    \ (numbers.length === 0) return [null, null];\n\n  let min = 0;\n  let max = numbers.length\
    \ - 1;\n\n  while (min < max) {\n    const mid = Math.floor((min + max) / 2);\n\
    \    const midVal = numbers[mid];\n\n    if (midVal < numbers[min]) min = mid\
    \ + 1;\n    else if (midVal > numbers[max]) max = mid - 1;\n    else {\n     \
    \ // Found the two values\n      const retVals = numbers.slice(min, max);\n  \
    \    return [midVal, retVals];\n    }\n  }\n  // We made it to the end\n  // console.log('We\
    \ made it to the end')\n  const retVals = numbers.slice(min, max);\n  return [numbers[min],\
    \ retVals];\n}\n", "  numbers = numbers.sort((a, b) => a - b);\n  let [closest]\
    \ = numbers;\n  let [other_closest] = numbers;\n  for (let i = 0; i < numbers.length\
    \ - 2; ++i) {\n    if (numbers[i + 1] <= numbers[i + 2]) {\n      other_closest\
    \ = numbers[i + 1];\n      closest = numbers[i + 2];\n    } else {\n      other_closest\
    \ = numbers[i + 2];\n      closest = numbers[i + 1];\n    }\n  }\n  return [closest,\
    \ other_closest];\n}\n", "  // get two nearest in to each other.\n  let min =\
    \ Math.min(numbers[0], numbers[1]);\n  let max = Math.max(numbers[0], numbers[1]);\n\
    \n  return [\n    // return nearest to the minimum.\n    min === numbers[0] ?\
    \ numbers[1] : min,\n    // return the nearest to the maximum.\n    max === numbers[0]\
    \ ? numbers[1] : max,\n  ];\n}\n", "    let min = numbers[0];\n    let max = numbers[0];\n\
    \n    for (let i = 1; i < numbers.length; i += 1) {\n        const current = numbers[i];\n\
    \        if (current < min) {\n            min = current;\n        }\n       \
    \ if (current > max) {\n            max = current;\n        }\n    }\n\n    return\
    \ [min, max];\n}\n", "  const first_min = numbers[0];\n  const second_min = numbers[1];\n\
    \  const min_dist = Number.MAX_SAFE_INTEGER;\n\n  for (const number of numbers)\
    \ {\n    const curr_dist = find_distance(first_min, second_min, number);\n   \
    \ if (curr_dist < min_dist) {\n      min_dist = curr_dist;\n    }\n    if (curr_dist\
    \ === Number.MAX_SAFE_INTEGER) {\n      break;\n    }\n  }\n  return [first_min,\
    \ second_min];\n}\n", "    if (numbers.length < 2) {\n        return numbers;\n\
    \    }\n    var closest_lower = numbers[0];\n    var closest_upper = numbers[0];\n\
    \    var closest_index = numbers.length - 1;\n    var closest = numbers[numbers.length\
    \ - 1];\n    numbers[0] = numbers[1];\n    numbers[numbers.length - 1] = numbers[numbers.length\
    \ - 2];\n    numbers[1] = closest_lower;\n    numbers[2] = closest_upper;\n  \
    \  var current_lower = 0;\n    var current_upper = numbers.length - 1;\n    var\
    \ current_index = numbers.length - 2;\n    while (current_index !== 0) {\n   \
    \     var current_value = numbers[current_index];\n        var current_closest\
    \ = current_value;\n        var current_closest = current_value;\n        if (current_upper\
    \ - current_lower > 1) {\n            var next_value = numbers[current_upper -\
    \ 1];\n            var next_closest = next_value;\n            if (next_value\
    \ - current_lower > current_upper - current_lower) {\n                next_closest\
    \ = numbers[current_upper - 2];\n            }\n            var next_next_value\
    \ = numbers[current_upper - 2];\n            var next_next_closest = next_next_value;\n\
    \            if (next_next_value - current_lower > current_upper - current_lower)\
    \ {\n                next_next_closest = numbers[current_upper - 1];\n       \
    \     }\n        }\n        if (current_value - current_lower < current_upper\
    \ - current_lower) {\n            if (current_upper - current_lower > 1) {\n \
    \               var next_value = numbers[current_upper];\n                var\
    \ next_closest = next_value;\n                if (next_value - current_lower >\
    \ current_upper - current_lower) {\n                    next_closest = numbers[current_upper\
    \ + 1];\n                }\n                var next_next_value = numbers[current_upper\
    \ + 1];\n                var next_next_closest = next_next_value;\n          \
    \      if (next_next_value - current_lower > current_upper - current_lower) {\n\
    \                    next_next_closest = numbers[current_upper];\n           \
    \     }\n            }\n        }\n        if (current_index === 0) {\n      \
    \      var next_value = numbers[current_lower];\n            var next_closest\
    \ = next_value;\n            if (next_value - current_lower > current_upper -\
    \ current_lower) {\n                next_closest = numbers[current_lower + 1];\n\
    \            }\n            var next_next_value = numbers[current_lower + 1];\n\
    \            var next_next_closest = next_next_value;\n            if (next_next_value\
    \ - current_lower > current_upper - current_lower) {\n                next_next_closest\
    \ = numbers[current_lower];\n            }\n        }\n        if (current_lower\
    \ === current_upper - 1) {\n            if (current_upper - current_lower > 1)\
    \ {\n                var next_value = numbers[current_lower];\n              \
    \  var next_closest = next_value;\n                if (next_value - current_lower\
    \ > current_upper - current_lower) {\n                    next_closest = numbers[current_upper\
    \ - 1];\n                }\n                var next_next_value = numbers[current_",
  "  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closest = [];\n\
    \  const differences = [];\n  const length = sortedNumbers.length;\n  let i =\
    \ -1;\n  while (++i < length) {\n    const currentClosest = sortedNumbers[i];\n\
    \    let currentDifference;\n    for (\n      currentDifference = 0;\n      currentDifference\
    \ <= differences.length ? currentDifference : 1;\n      currentDifference++\n\
    \    ) {\n      const previousDifference = differences[currentDifference - 1];\n\
    \      if (\n        currentClosest - previousDifference > 0.001 ||\n        Math.abs(currentClosest\
    \ - previousDifference) <\n          Math.abs(currentClosest - currentDifference)\n\
    \      ) {\n        break;\n      }\n    }\n    closest.push(currentClosest);\n\
    \    differences.push(currentDifference);\n  }\n  return [differences[differences.length\
    \ - 1], closest];\n}\n", "    if (numbers.length === 0) return [0, 0];\n    const\
    \ sortedNumbers = numbers.slice(0).sort((a, b) => a - b);\n    if (sortedNumbers[0]\
    \ === sortedNumbers[sortedNumbers.length - 1]) {\n        return [sortedNumbers[0],\
    \ sortedNumbers[0]];\n    }\n    const closest = [sortedNumbers[0], sortedNumbers[0]];\n\
    \    let closestDistance = Math.abs(sortedNumbers[0] - sortedNumbers[sortedNumbers.length\
    \ - 1]);\n    for (let i = 1; i < sortedNumbers.length; i++) {\n        const\
    \ distance = sortedNumbers[i] - sortedNumbers[i - 1];\n        if (distance <\
    \ closestDistance) {\n            closestDistance = distance;\n            closest[0]\
    \ = sortedNumbers[i - 1];\n            closest[1] = sortedNumbers[i];\n      \
    \  }\n    }\n    return closest;\n}\n", "  var closest1 = numbers[0];\n  var closest2\
    \ = numbers[0];\n\n  for (var i = 1; i < numbers.length; i++) {\n    if (numbers[i]\
    \ > closest1) {\n      closest2 = closest1;\n      closest1 = numbers[i];\n  \
    \  } else if (numbers[i] < closest2) {\n      closest2 = numbers[i];\n    }\n\
    \  }\n\n  return [closest2, closest1];\n}\n", "  if (numbers.length < 2) {\n \
    \   throw new Error(\"find_closest_elements expects an array of at least two numbers.\"\
    );\n  }\n  const first_number = numbers[0];\n  const second_number = numbers[1];\n\
    \  const min_dist = Number.MAX_VALUE;\n  const min_dist_index = 0;\n  for (let\
    \ i = 0; i < numbers.length; ++i) {\n    const curr = numbers[i];\n    const curr_dist\
    \ = curr !== first_number ? curr - first_number : 0;\n    const dist = Math.abs(curr_dist\
    \ + second_number - min_dist);\n    if (dist < min_dist) {\n      min_dist = dist;\n\
    \      min_dist_index = i;\n    }\n  }\n  return [numbers[min_dist_index], numbers[min_dist_index\
    \ + 1]];\n}\n", "    // If the array is empty or only has one element just return\
    \ it back\n    if (numbers.length < 2) {\n        return [numbers[0], numbers[0]];\n\
    \    }\n\n    // Find the smallest\n    var smallest = numbers[0];\n    for (var\
    \ i = 1; i < numbers.length; i++) {\n        if (numbers[i] < smallest) {\n  \
    \          smallest = numbers[i];\n        }\n    }\n\n    // Find the largest\n\
    \    var largest = numbers[0];\n    for (var i = 1; i < numbers.length; i++) {\n\
    \        if (numbers[i] > largest) {\n            largest = numbers[i];\n    \
    \    }\n    }\n\n    return [smallest, largest];\n}\n", "\tlet min_idx = -1;\n\
    \tlet max_idx = numbers.length - 1;\n\tlet min: number;\n\tlet max: number;\n\t\
    while (min_idx < max_idx) {\n\t\tlet mid_idx = (min_idx + max_idx) / 2;\n\t\t\
    let mid_number = numbers[mid_idx];\n\t\tif (mid_number < numbers[0]) min_idx =\
    \ mid_idx;\n\t\telse if (mid_number > numbers[numbers.length - 1]) max_idx = mid_idx;\n\
    \t\telse {\n\t\t\tmin = mid_number;\n\t\t\tmin_idx = mid_idx;\n\t\t\tif (min_idx\
    \ === max_idx) {\n\t\t\t\treturn numbers;\n\t\t\t}\n\t\t}\n\t}\n\tmin = numbers[min_idx];\n\
    \tnumbers = numbers.filter((x, i) => x === numbers[min_idx]);\n\tnumbers.push(min);\n\
    \treturn numbers;\n}\n", "  const min = numbers[0]\n  const max = numbers[1]\n\
    \  if (min > max) {\n    return [min, max]\n  }\n\n  for (let i = 0; i < numbers.length\
    \ - 1; i++) {\n    const num = numbers[i]\n    if (Math.abs(num - max) < Math.abs(num\
    \ - min)) {\n      min = num\n    } else {\n      max = num\n    }\n  }\n\n  return\
    \ [min, max]\n}\n", "\tif (numbers.length < 2) {\n\t\treturn [numbers[0], numbers[0]];\n\
    \t}\n\n\tconst min_num = Math.min(...numbers);\n\tconst max_num = Math.max(...numbers);\n\
    \n\tlet min_dist_sqr = Number.MAX_VALUE;\n\n\tfor (const num of numbers) {\n\t\
    \tconst diff = num - min_num;\n\t\tconst dist_sqr = diff * diff;\n\n\t\tif (dist_sqr\
    \ < min_dist_sqr) {\n\t\t\tmin_dist_sqr = dist_sqr;\n\t\t\tmin_num = num;\n\t\t\
    }\n\t}\n\n\treturn [min_num, min_num];\n}\n", "\tlet smallest = numbers[0];\n\t\
    let largest = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\t\
    if (numbers[i] < smallest) {\n\t\t\tsmallest = numbers[i];\n\t\t} else if (numbers[i]\
    \ > largest) {\n\t\t\tlargest = numbers[i];\n\t\t}\n\t}\n\tconst result = numbers.filter((x:\
    \ number) => Math.abs(x - smallest) < Math.abs(x - largest));\n\treturn [smallest,\
    \ largest];\n}\n", "  let closest: number[] = [];\n  let temp: number = numbers[0];\n\
    \  let first: number = temp;\n  for (var i = 0; i < numbers.length - 1;) {\n \
    \   i++;\n    temp = numbers[i];\n    if (Math.abs(temp - first) < Math.abs(temp\
    \ - numbers[i - 1])) {\n      closest = [];\n      closest[0] = temp;\n      closest[1]\
    \ = numbers[i - 1];\n      break;\n    } else if (Math.abs(temp - first) > Math.abs(temp\
    \ - numbers[i - 1])) {\n      break;\n    }\n  }\n  return closest;\n}\n", " \
    \   const min_elements = numbers.map((n) => Math.abs(n - numbers[0])).filter((n)\
    \ => n >= Math.abs(numbers[0]))\n    const max_elements = numbers.map((n) => Math.abs(n\
    \ - numbers[numbers.length - 1])).filter((n) => n >= Math.abs(numbers[numbers.length\
    \ - 1]))\n    const min_min_elements = min_elements.map((n) => Math.abs(n - numbers[0])).filter((n)\
    \ => n >= Math.abs(numbers[0]))\n    const max_max_elements = max_elements.map((n)\
    \ => Math.abs(n - numbers[numbers.length - 1])).filter((n) => n >= Math.abs(numbers[numbers.length\
    \ - 1]))\n    const min_max_elements = min_elements.map((n) => Math.abs(n - numbers[numbers.length\
    \ - 1])).filter((n) => n >= Math.abs(numbers[numbers.length - 1]))\n    const\
    \ min_index = min_elements.indexOf(0)\n    const max_index = max_elements.indexOf(Math.max(...max_elements))\n\
    \    const min_max_index = min_elements.indexOf(Math.max(...min_elements))\n \
    \   if (min_index >= 0 && min_max_index < min_index && min_max_index >= 0) {\n\
    \        return [numbers[min_index], numbers[min_max_index]]\n    }\n    if (max_index\
    \ >= 0 && min_min_index < max_index && min_min_index >= 0) {\n        return [numbers[max_index],\
    \ numbers[min_min_index]]\n    }\n    if (max_index >= 0 && max_max_index < max_index\
    \ && max_max_index >= 0) {\n        return [numbers[max_index], numbers[max_max_index]]\n\
    \    }\n    if (min_index >= 0 && min_min_index < min_index && min_min_index >=\
    \ 0) {\n        return [numbers[min_index], numbers[min_min_index]]\n    }\n \
    \   return []\n}", "\tif (numbers.length < 2) return numbers;\n\n\tlet a = numbers[0],\n\
    \t\tb = numbers[1];\n\n\tfor (let i = 2; i < numbers.length; i++) {\n\t\tlet n\
    \ = numbers[i];\n\n\t\tif (Math.abs(b - a) < Math.abs(n - a)) {\n\t\t\ta = b;\n\
    \t\t\tb = n;\n\t\t} else {\n\t\t\ta = n;\n\t\t}\n\t}\n\n\treturn [a, b];\n}\n",
  "    let closest_numbers = [numbers[0], numbers[1]];\n    for (let i = 2; i < numbers.length;\
    \ i++) {\n        if (numbers[i] < closest_numbers[0]) {\n            closest_numbers[0]\
    \ = numbers[i];\n        } else if (numbers[i] > closest_numbers[1]) {\n     \
    \       closest_numbers[1] = numbers[i];\n        }\n    }\n    return [closest_numbers[0],\
    \ closest_numbers[1]];\n}\n", "  let closest = Number.MAX_SAFE_INTEGER;\n  let\
    \ result = undefined;\n\n  for (const n of numbers) {\n    if (n < closest) {\n\
    \      closest = n;\n      result = [n, closest];\n    }\n\n    if (n > closest)\
    \ {\n      break;\n    }\n  }\n\n  return result;\n}\n", "\treturn numbers.reduce(([smaller,\
    \ larger], [a, b, c, d]) => {\n\t\treturn a < b ? (a < c ? a < d ? [a, b, c, d]\
    \ : [b, c, d, a] : [c, d, a, b]) :\n\t\t\tb < c ? b < d ? [b, c, d, a] : [c, d,\
    \ a, b] : [d, a, b, c]\n\t})\n}\n", "  console.log(numbers);\n  \n  // Sort by\
    \ absolute value to keep things consistent\n  let sorted_numbers = numbers.sort((a:\
    \ number, b: number): number => {\n    if (Math.abs(a) < Math.abs(b)) {\n    \
    \  return -1;\n    }\n    else if (Math.abs(a) > Math.abs(b)) {\n      return\
    \ 1;\n    }\n    else {\n      return 0;\n    }\n  });\n\n  // Now find the two\
    \ numbers that are closest to each other\n  // We start with the first number\
    \ and check until it gets closer to the other number\n  let [closest, closestToOther]\
    \ = sorted_numbers.reduce((closest: [number, number], other: number) => {\n  \
    \  let delta = Math.abs(other - closest[0]);\n    if (delta <= Math.abs(other\
    \ - closest[1])) {\n      closest[0] = other;\n      closest[1] = other;\n   \
    \ }\n    else if (delta > Math.abs(other - closest[1])) {\n      closest[1] =\
    \ other;\n    }\n    return closest;\n  }, [numbers[0], numbers[1]]);\n\n  //\
    \ Now go through all the numbers, make sure to keep track of the closest to other\
    \ number\n  let [closest, closestToOther] = sorted_numbers.reduce((closest: [number,\
    \ number], other: number) => {\n    let delta = Math.abs(other - closest[0]);\n\
    \    if (delta <= Math.abs(other - closestToOther)) {\n      closest[0] = other;\n\
    \      closestToOther = other;\n    }\n    else if (delta > Math.abs(other - closestToOther))\
    \ {\n      closestToOther = other;\n    }\n    return closest;\n  }, [closestToOther,\
    \ closest]);\n\n  console.log(closestToOther);\n  console.log(closest);\n  return\
    \ [closest, closestToOther];\n}\n</code>\n<|/ a tags=typescript,arrays dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>", "  if (numbers.length < 2) {\n    throw new Error(\"\
    Array must have two or more elements\");\n  }\n\n  let smallest: number = numbers[0];\n\
    \  let largest: number = numbers[0];\n\n  for (let i = 1; i < numbers.length;\
    \ i += 1) {\n    const thisNumber = numbers[i];\n\n    if (thisNumber < smallest)\
    \ {\n      smallest = thisNumber;\n    }\n\n    if (thisNumber > largest) {\n\
    \      largest = thisNumber;\n    }\n  }\n\n  return [smallest, largest];\n}\n",
  "    if (numbers.length < 2) {\n        throw new Error(\"Not enough numbers for\
    \ find_closest_elements\");\n    }\n    let min: number = 0;\n    let max: number\
    \ = numbers[0];\n    let closest_element: number[] = [min, max];\n    for (let\
    \ i = 1; i < numbers.length; i++) {\n        if (numbers[i] < min || numbers[i]\
    \ > max) {\n            if (numbers[i] == min) {\n                closest_element[0]\
    \ = numbers[i];\n            }\n            else {\n                closest_element[1]\
    \ = numbers[i];\n            }\n        }\n        else if (numbers[i] == min)\
    \ {\n            min = numbers[i];\n        }\n        else if (numbers[i] ==\
    \ max) {\n            max = numbers[i];\n        }\n        else {\n         \
    \   let diff = numbers[i] - min;\n            let distance = Math.hypot(diff,\
    \ max - min);\n            if (closest_element[0] != min && diff < 0 || closest_element[1]\
    \ != max && diff > 0) {\n                closest_element[0] = min;\n         \
    \       closest_element[1] = max;\n            }\n            else {\n       \
    \         closest_element[0] = closest_element[1]\n                min = numbers[i];\n\
    \                max = numbers[i];\n            }\n        }\n    }\n    return\
    \ closest_element;\n}\n", "  // For our purposes we will assume that all values\
    \ are positive.\n  const first = numbers[0];\n  if (first > numbers[1]) {\n  \
    \  return numbers;\n  }\n  const last = numbers[numbers.length - 1];\n  if (last\
    \ < numbers[0]) {\n    return numbers;\n  }\n  const middle1 = first + ((last\
    \ - first) / 2);\n  let middle2 = first - ((last - first) / 2);\n  while (middle1\
    \ <= middle2) {\n    const midPoint = middle1 + middle2;\n    if (midPoint < numbers[0])\
    \ {\n      middle1 = midPoint;\n    } else {\n      middle2 = midPoint;\n    }\n\
    \  }\n  return [middle1, middle2];\n}\n", "\tconst sortedNumbers = numbers.slice().sort((a:\
    \ number, b: number) => a - b);\n\n\tif (sortedNumbers.length !== 2) {\n\t\tthrow\
    \ new RangeError('Could not find two closest numbers');\n\t}\n\n\tconst difference\
    \ = sortedNumbers[1] - sortedNumbers[0];\n\n\tconst closest = sortedNumbers[sortedNumbers.length\
    \ - 1];\n\n\treturn [closest, sortedNumbers[0] - difference];\n}\n", "    if (numbers.length\
    \ < 2) {\n        return [null, null];\n    }\n\n    let min: number = numbers[0];\n\
    \    let max: number = numbers[1];\n\n    for (let i = 1; i < numbers.length;\
    \ ++i) {\n        const thisDistance = Math.abs(numbers[i] - min);\n        const\
    \ otherDistance = Math.abs(numbers[i] - max);\n\n        if (thisDistance < otherDistance)\
    \ {\n            min = numbers[i];\n        } else {\n            max = numbers[i];\n\
    \        }\n    }\n\n    return [min, max];\n}\n", "  var smallest: number | null\
    \ = null;\n  var largest: number | null = null;\n  var found: number | null =\
    \ null;\n  for (var i = 0; i < numbers.length - 1; i++) {\n    if (numbers[i]\
    \ < numbers[i + 1]) {\n      if (smallest === null || numbers[i] < smallest) {\n\
    \        smallest = numbers[i];\n        found = numbers[i];\n      }\n      if\
    \ (largest === null || numbers[i] > largest) {\n        largest = numbers[i];\n\
    \        found = numbers[i];\n      }\n    }\n  }\n  if (smallest === null) {\n\
    \    return numbers;\n  }\n  return [found, largest];\n}", "\t// Get a list of\
    \ all the numbers in array and sort it.\n\tvar sortedNumbers = numbers.slice().sort((a:\
    \ number, b: number) => a - b);\n\tvar result: number[] = [];\n\n\t// Get the\
    \ two closest numbers to the first number\n\tfor (var number1 = sortedNumbers[0];\
    \ number1 <= sortedNumbers[1]; number1++) {\n\t\t// Go through all the numbers\
    \ looking for this number\n\t\tfor (var number2 = sortedNumbers[0]; number2 <=\
    \ sortedNumbers[1]; number2++) {\n\t\t\t// If both numbers are the same, just\
    \ add it to the result set\n\t\t\tif (number1 === number2) {\n\t\t\t\tresult.push(number1);\n\
    \t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If one is bigger than the other, just add\
    \ it to the result set\n\t\t\tif (number1 > number2) {\n\t\t\t\tresult.push(number1);\n\
    \t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If this number is closer to another than\
    \ the other one add it to the result set\n\t\t\tif (Math.abs(number1 - number2)\
    \ < Math.abs(sortedNumbers[1] - number1)) {\n\t\t\t\tresult.push(number1);\n\t\
    \t\t\tresult.push(number2);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "  numbers.sort();\n\
    \  let lower = numbers[0];\n  let upper = numbers[0];\n  numbers.forEach((val)\
    \ => {\n    if (val < lower) {\n      lower = val;\n    }\n    if (val > upper)\
    \ {\n      upper = val;\n    }\n  });\n  return [lower, upper];\n}\n", "\tif (numbers.length\
    \ < 2) return numbers;\n\tvar result = null;\n\tvar min_diff = Math.abs(numbers[0]\
    \ - numbers[1]);\n\tfor (var i = 1; i < numbers.length; i++) {\n\t\tvar diff =\
    \ Math.abs(numbers[i] - numbers[i - 1]);\n\t\tif (result == null || diff < min_diff)\
    \ {\n\t\t\tresult = numbers[i];\n\t\t\tmin_diff = diff;\n\t\t}\n\t}\n\treturn\
    \ [result, result];\n}\n", "    let sorted_numbers = numbers.slice();\n    sorted_numbers.sort((a:\
    \ number, b: number) => {\n        return Math.abs(a - b) < 0.00001 ? 0 : Math.abs(a\
    \ - b) < 1 ? 1 : 2;\n    });\n    return [sorted_numbers[0], sorted_numbers[1]];\n\
    }\n", "    \n    let result: [number, number] | null = null;\n    let minimum:\
    \ number = numbers[0]\n    let maximum: number = numbers[0]\n    \n    for (let\
    \ i = 1, len = numbers.length; i < len; i++) {\n        if (numbers[i] < minimum)\
    \ {\n            minimum = numbers[i];\n        }\n        else if (numbers[i]\
    \ > maximum) {\n            maximum = numbers[i];\n        }\n    }\n    \n  \
    \  if (minimum != maximum) {\n        result = [minimum, maximum]\n    }\n   \
    \ else {\n        result = [numbers[0], numbers[0]]\n    }\n    \n    return result\n\
    }\n", "    if (numbers.length < 2) {\n        return [];\n    }\n\n    const minIndex\
    \ = numbers.length - 1;\n    let minValue: number;\n    let minIndexValue: number;\n\
    \n    for (let i = 0; i < numbers.length; i += 1) {\n        if (numbers[i] <\
    \ numbers[minIndex]) {\n            minIndex = i;\n            minValue = numbers[i];\n\
    \            minIndexValue = numbers[minIndex];\n        }\n    }\n\n    const\
    \ maxIndex: number = minIndex;\n    const maxValue: number = numbers[maxIndex];\n\
    \n    const result = [minValue, minIndexValue];\n    for (let i = maxIndex; i\
    \ > minIndex; i--) {\n        if (numbers[i] > numbers[minIndex]) {\n        \
    \    minIndex = i;\n            minValue = numbers[i];\n            minIndexValue\
    \ = numbers[minIndex];\n        }\n    }\n\n    result[1] = maxIndexValue;\n \
    \   return result\n}\n", "    if (numbers.length < 2) return [numbers[0], numbers[0]];\n\
    \    var min1 = numbers[0];\n    var min2 = numbers[0];\n    var max1 = numbers[0];\n\
    \    var max2 = numbers[0];\n    for (var i = 1; i < numbers.length; i++) {\n\
    \        var curr1 = numbers[i];\n        var curr2 = numbers[i];\n        if\
    \ (curr1 < min1) {\n            min1 = curr1;\n            min2 = min2;\n    \
    \    } else if (curr1 > max1) {\n            max1 = curr1;\n            max2 =\
    \ max2;\n        }\n        if (curr2 < min2) {\n            min2 = curr2;\n \
    \           min1 = min1;\n        } else if (curr2 > max2) {\n            max2\
    \ = curr2;\n            max1 = max1;\n        }\n    }\n    return [min1, max2];\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you for your help!\n<|/ c |>\n<| c |>\nThis\
    \ solution is very elegant, I like the use of recursion to solve the problem.\
    \ Thank you!\n<|/ c |>\n<| c |>\nThe only issue I found with this solution is\
    \ that if you're expecting the array to be sorted, it will not work (at least\
    \ for me). I'm running a unit test on the algorithm and found that it does work\
    \ if you're looking for the minimum value in the array even if the array is unsorted.\
    \ I'll let you know if I find out why.\n<|/ c |>\n<| c |>\nFor anyone that finds\
    \ this later, I believe this is a bug in the code. It does not handle the case\
    \ where the closest numbers are next to each other. For example, if you have an\
    \ array `[1,1,2,2,3,3]` and you run this algorithm it will return the answer as\
    \ `[1,2,3]`, which is not the correct answer.\n<|/ c |>\n<| a |>\nHere's a JavaScript\
    \ implementation of the Hilbert curve solution:\n\n<code>", "  // Make sure that\
    \ there is at least one number\n  if (numbers.length < 2) return [];\n\n  // Find\
    \ the two closest numbers. Use the 'smaller' number in the array as the 'smaller'\
    \ number so we\n  // can return the 'larger' number later.\n  const [smaller,\
    \ larger] = numbers.map((number) =>\n    number.abs()\n  );\n  return [numbers[0],\
    \ larger];\n}\n\nexport function generate_test_data(\n  name: string,\n  n: number,\n\
    \  min: number,\n  max: number,\n  step: number = 1,\n  precision: number = 0,\n\
    \  include_negative: boolean = false\n): number {\n  const range = max - min;\n\
    \  const data = new Array(n);\n  for (let i = 0; i < n; i += 1) {\n    data[i]\
    \ = min + (step * Math.random());\n  }\n  if (include_negative && Math.random()\
    \ < 0.5) {\n    const negatives = [];\n    for (let i = 0; i < n; i += 1) {\n\
    \      negatives[i] = data[i] - range;\n    }\n    data.push(...negatives);\n\
    \  }\n  return precision ? data.map(x => x.toFixed(precision)) : data;\n}\n\n\
    export function calculate_area(\n  x1: number,\n  y1: number,\n  x2: number,\n\
    \  y2: number,\n  hx1: number,\n  hy1: number,\n  hx2: number,\n  hy2: number\n\
    ): number {\n  const dx1 = x2 - x1;\n  const dy1 = y2 - y1;\n  const dx2 = hx2\
    \ - hx1;\n  const dy2 = hy2 - hy1;\n  return Math.sqrt(dx1 * dx1 + dy1 * dy1)\
    \ * (\n    Math.sqrt(dx2 * dx2 + dy2 * dy2) + Math.sqrt(dx1 * dx1 + dy1 * dy1)\n\
    \  );\n}\n\nexport function get_text_width(\n  text: string,\n  font: string,\n\
    \  text_width: number\n): number {\n  // Get a text metrics object from the DOM.\n\
    \  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\
    \  svg.setAttribute('style', 'visibility: hidden;');\n  document.body.appendChild(svg);\n\
    \n  const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n\
    \  text.setAttribute('x', 0);\n  text.setAttribute('y', 0);\n  text.setAttribute('class',\
    \ 't');\n  text.setAttribute('font-family', font);\n  text.setAttribute('font-size',\
    \ '100');\n  text.setAttribute('fill', '#fff');\n  text.innerHTML = text;\n  svg.appendChild(text);\n\
    \n  const metrics = text.getBoundingClientRect();\n  document.body.removeChild(svg);\n\
    \n  return metrics.width + text_width;\n}\n\nexport function calculate_", "\t\
    if (numbers.length < 2) {\n\t\treturn [numbers[0], numbers[0]];\n\t}\n\tconst\
    \ min_diff = +Infinity;\n\tlet min: number;\n\tlet max: number;\n\tfor (let i\
    \ = 0; i < numbers.length; i++) {\n\t\tconst diff = numbers[i] - numbers[i - 1];\n\
    \t\tif (diff < min_diff) {\n\t\t\tmin = i;\n\t\t\tmin_diff = diff;\n\t\t} else\
    \ if (diff > min_diff) {\n\t\t\tmax = i;\n\t\t}\n\t}\n\treturn [numbers[min],\
    \ numbers[max]];\n}\n", "\tif (numbers.length < 2) {\n\t\treturn [numbers[0],\
    \ numbers[0]];\n\t}\n\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\
    \tfor (let i = 1; i < numbers.length; i += 1) {\n\t\tmin = Math.min(min, numbers[i]);\n\
    \t\tmax = Math.max(max, numbers[i]);\n\t}\n\tlet result: number[] = [];\n\tlet\
    \ range: number = (max - min) + 1;\n\tfor (let i = 0; i <= range; i += 1) {\n\t\
    \tlet distance: number = Math.abs(numbers[i] - min);\n\t\tlet resultIndex: number\
    \ = distance < range / 2 ? distance : (distance - range);\n\t\tresult.push(numbers[resultIndex]);\n\
    \t}\n\treturn result;\n}\n", "  const min_idx = numbers.findIndex((_, idx) =>\
    \ idx < numbers.length - 1);\n  const max_idx = numbers.findIndex((_, idx) =>\
    \ idx > 0);\n  return [numbers[min_idx], numbers[max_idx]];\n}\n", "\tconst pairs:\
    \ number[][] = [];\n\tfor (let i = 0; i < numbers.length - 2; ++i) {\n\t\tpairs.push([numbers[i],\
    \ numbers[i + 1]]);\n\t}\n\tpairs.push([numbers[numbers.length - 1], numbers[0]]);\n\
    \treturn pairs.reduce((a, b) => {\n\t\treturn a.map((x, i) => {\n\t\t\treturn\
    \ Math.sqrt(Math.pow(x - b[0], 2) + Math.pow(x - b[1], 2));\n\t\t});\n\t});\n\
    }\n", "    const min = Math.min(...numbers);\n    const max = Math.max(...numbers);\n\
    \    if (min === max) {\n        return [min, min];\n    }\n    const mid = Math.round(min\
    \ + (max - min) / 2);\n    return [mid, numbers.indexOf(mid)];\n}\n", "  let index1:\
    \ number;\n  let index2: number;\n  const closest_array: number[] = [];\n  for\
    \ (let i = 0; i < numbers.length; i++) {\n    index1 = i;\n    index2 = i;\n \
    \   while (index2 < (numbers.length - 1)) {\n      index2++;\n      if (numbers[index2]\
    \ < numbers[index1]) {\n        index1++;\n      }\n    }\n    closest_array.push([numbers[index1],\
    \ numbers[index2]]);\n  }\n  return closest_array;\n}", "\tif (numbers.length\
    \ < 2) {\n\t\tthrow new Error(\"Cannot find closest pair because input array contains\
    \ less than 2 elements!\");\n\t}\n\tlet min_diff = Number.MAX_VALUE;\n\tlet min_index1\
    \ = 0;\n\tlet min_index2 = 0;\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\
    \tlet d = Math.abs(numbers[i] - numbers[i - 1]);\n\t\tif (d < min_diff) {\n\t\t\
    \tmin_diff = d; // smallest difference so far\n\t\t\tmin_index1 = i; // the closets\
    \ index so far\n\t\t\tmin_index2 = i - 1;\n\t\t}\n\t}\n\treturn [numbers[min_index1],\
    \ numbers[min_index2]];\n}\n", "  // Initialize our result\n  var result = numbers[0]\
    \ < numbers[1] ? [numbers[0], numbers[1]] : [numbers[1], numbers[0]];\n\n  //\
    \ For each number in the list of numbers\n  for (var i = 1; i < numbers.length;\
    \ i = i + 1) {\n    // Calculate current distance between the current element\
    \ and the element before it\n    var current_distance = result[i - 1] !== undefined\
    \ ? result[i - 1] : i;\n\n    // If that current distance is the lowest\n    if\
    \ (current_distance < i) {\n      // Update our result with the new values\n \
    \     result[i] = numbers[i];\n      result[current_distance] = numbers[current_distance];\n\
    \    }\n  }\n\n  // Return the results\n  return result;\n}\n", "  var result:\
    \ [number, number] = [0, 0];\n  var min: number = Number.MAX_VALUE;\n  var max:\
    \ number = 0;\n  for (var i = 0; i < numbers.length; ++i) {\n    var n = numbers[i];\n\
    \    if (n < min) {\n      min = n;\n    } else if (n > max) {\n      max = n;\n\
    \    }\n  }\n  for (var i = 0; i < numbers.length; ++i) {\n    if (numbers[i]\
    \ > max) {\n      result[0] = max;\n      result[1] = numbers[i];\n      break;\n\
    \    } else if (numbers[i] < min) {\n      result[0] = min;\n      result[1] =\
    \ numbers[i];\n      break;\n    }\n  }\n  return result;\n}\n", "  const min\
    \ = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  let [firstClosest,\
    \ secondClosest] = [0, 0];\n  for (let i = 0; i < numbers.length; i++) {\n   \
    \ const d = Math.abs(numbers[i] - min);\n    if (d < secondClosest) {\n      secondClosest\
    \ = d; // we found the closest\n      secondClosestIndex = i;\n    } else if (d\
    \ < firstClosest) {\n      firstClosest = d; // we found the closest\n      firstClosestIndex\
    \ = i;\n    }\n  }\n  return [numbers[firstClosestIndex], numbers[secondClosestIndex]];\n\
    }\n", "  const smallest = numbers[0];\n  const largest = numbers[0];\n  const\
    \ smallest_index: number = 0;\n  const largest_index: number = 0;\n  let current_smallest:\
    \ number = Number.POSITIVE_INFINITY;\n  let current_largest: number = Number.NEGATIVE_INFINITY;\n\
    \  let current_smallest_difference: number;\n  let current_largest_difference:\
    \ number;\n  for (let index = 0; index < numbers.length; index++) {\n    const\
    \ current = numbers[index];\n    if (smallest > current) {\n      smallest = current;\n\
    \      smallest_index = index;\n    }\n    if (largest < current) {\n      largest\
    \ = current;\n      largest_index = index;\n    }\n    if (smallest < current_smallest\
    \ || smallest === current_smallest && current < current_smallest) {\n      current_smallest\
    \ = current;\n      current_smallest_difference = Math.abs(smallest - current_smallest);\n\
    \    }\n    if (largest > current_largest || largest === current_largest && current\
    \ > current_largest) {\n      current_largest = current;\n      current_largest_difference\
    \ = Math.abs(largest - current_largest);\n    }\n  }\n  return [smallest_index,\
    \ largest_index];\n}\n", "  numbers = numbers.slice(0); // clone array\n  numbers\
    \ = numbers.sort((a, b) => a - b); // sort from lowest to highest\n  var min =\
    \ numbers[0];\n  var max = numbers[0];\n  for (var i = 0; i < numbers.length;\
    \ ++i) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n    }\n    if\
    \ (numbers[i] < min) {\n      min = numbers[i];\n    }\n  }\n  return [min, max];\n\
    }", "  const closest = numbers.reduce((prev, curr) => {\n    if (Math.abs(curr\
    \ - prev) < Math.abs(curr - prev)) {\n      return prev;\n    } else {\n     \
    \ return curr;\n    }\n  });\n\n  const smaller = numbers.reduce((prev, curr)\
    \ => {\n    if (Math.abs(curr - closest) < Math.abs(curr - closest)) {\n     \
    \ return curr;\n    } else {\n      return prev;\n    }\n  });\n\n  return [smaller,\
    \ closest];\n}\n", "\tvar best: [number, number] = [0, 0];\n\tfor (var n = 0;\
    \ n < numbers.length; n++) {\n\t\tvar d = distance(numbers[n], numbers[best[1]]);\n\
    \t\tif (d < distance(numbers[best[0]], numbers[n])) {\n\t\t\tbest = [n, n];\n\t\
    \t} else {\n\t\t\tbest = [best[0], n];\n\t\t}\n\t}\n\treturn best;\n}\n", "\t\
    if (!numbers || numbers.length < 2) {\n\t\treturn [numbers[0], numbers[0]];\n\t\
    }\n\tnumbers.sort((a, b) => {\n\t\tif (a < b) { return 1; }\n\t\tif (a > b) {\
    \ return -1; }\n\t\treturn 0;\n\t});\n\tlet left = numbers[0];\n\tlet right =\
    \ numbers[1];\n\tif (Math.abs(left - right) < 0.0000001) {\n\t\treturn [left,\
    \ right];\n\t} else {\n\t\treturn [right, left];\n\t}\n}\n", "  const sortedArray\
    \ = numbers.slice().sort((a, b) => a - b);\n  const index = sortedArray.length\
    \ - 1;\n  const difference = sortedArray[index] - sortedArray[index - 1];\n  const\
    \ halfIndex = sortedArray.length / 2;\n  if (difference === 0) return [sortedArray[index\
    \ - 1], sortedArray[index]];\n  return [sortedArray[index - 1 + halfIndex], sortedArray[index\
    \ + halfIndex]];\n}\n", "  numbers = numbers.sort((a, b) => a - b);\n  const [a,\
    \ a2] = [numbers[0], numbers[1]];\n  const [b, c2] = [numbers[2], numbers[3]];\n\
    \  if (Math.abs(a - b) <= Math.abs(b - a) && Math.abs(a - b) <= Math.abs(c - b))\
    \ {\n    return [a, b];\n  } else if (Math.abs(a - b) <= Math.abs(b - a) || Math.abs(a\
    \ - b) <= Math.abs(c - b)) {\n    return [a, c2];\n  } else {\n    return [b,\
    \ c2];\n  }\n}\n", "  if (numbers.length <= 1) {\n    return [numbers[0], numbers[0]];\n\
    \  }\n  let smallest_diff = Number.MAX_VALUE;\n  const smallest_index = 0;\n \
    \ for (let i = 1; i < numbers.length; i++) {\n    const diff = numbers[i] - numbers[i\
    \ - 1];\n    if (diff > smallest_diff) {\n      smallest_diff = diff;\n      smallest_index\
    \ = i;\n    }\n  }\n  return [numbers[smallest_index], numbers[smallest_index\
    \ + 1]];\n}\n", "  var distances = [];\n  var index = 0;\n  var length = numbers.length;\n\
    \  var minimum = numbers[0];\n  var closest;\n\n  // Find distances between all\
    \ pairs of numbers\n  while (index < (length - 1)) {\n    distances.push(calc_distance(numbers[index],\
    \ numbers[index + 1]));\n    index ++;\n  }\n\n  // Find the smallest distance\
    \ and swap the closest values\n  index = 0;\n  closest = null;\n  for (let i =\
    \ 1; i < distances.length; i += 1) {\n    if (distances[i] < distances[closest])\
    \ {\n      closest = i;\n    }\n  }\n\n  // Swap the closest values\n  if (closest\
    \ !== null) {\n    var temp = numbers[index];\n    numbers[index] = numbers[closest];\n\
    \    numbers[closest] = temp;\n  }\n\n  return numbers;\n}\n\nexport function\
    \ gen_random_color(): [number, number, number] {\n  const red = Math.floor(Math.random()\
    \ * 255);\n  const green = Math.floor(Math.random() * 255);\n  const blue = Math.floor(Math.random()\
    \ * 255);\n  return [red, green, blue];\n}\n\nexport function rgb2hex(rgb: [number,\
    \ number, number]): [string, string] {\n  return \"#\" + rgb.map(Math.round).join(\"\
    \");\n}\n", "  const closest_indexes = numbers.map((number) => Math.abs(number)\
    \ - number);\n  const [smallest_index, largest_index] = closest_indexes.reduce((acc,\
    \ i) => Math.min(acc, i), Infinity);\n  return [numbers[smallest_index], numbers[largest_index]];\n\
    }\n", "\tconst result = new Array<[number, number]>();\n\tlet min = 0;\n\tlet\
    \ max = numbers.length - 1;\n\tlet mid = 0;\n\n\twhile (min < max) {\n\t\tmid\
    \ = Math.floor((min + max) / 2);\n\t\tresult.push([numbers[mid], mid]);\n\n\t\t\
    if (numbers[mid] > numbers[max]) {\n\t\t\tmax = mid - 1;\n\t\t} else if (numbers[mid]\
    \ < numbers[min]) {\n\t\t\tmin = mid + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\
    \t}\n\n\treturn result;\n}\n", "    const sortedNumbers = numbers.sort((a, b)\
    \ => a - b);\n\n    return [\n        sortedNumbers[Math.ceil(numbers.length /\
    \ 2)],\n        sortedNumbers[Math.floor(numbers.length / 2)],\n    ];\n}\n",
  "  let smallest = numbers[0]\n  let largest = numbers[0]\n  for (let i = 1; i <\
    \ numbers.length; i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i]\n\
    \    }\n    if (numbers[i] > largest) {\n      largest = numbers[i]\n    }\n \
    \ }\n  return [smallest, largest]\n}\n", "  let smallest = numbers[0]\n  let largest\
    \ = numbers[0]\n  for (let i = 1; i < numbers.length; i++) {\n    const n = numbers[i]\n\
    \    const delta = n - smallest\n    if (delta < 0) {\n      smallest = n\n  \
    \  } else if (delta > 0) {\n      largest = n\n    }\n  }\n  return [smallest,\
    \ largest]\n}\n", "    const first = numbers[0];\n    const last = numbers[numbers.length\
    \ - 1];\n    const first_smaller = numbers[1];\n    const first_larger = numbers[0];\n\
    \    const larger = numbers[numbers.length - 2];\n    const smaller = numbers[0];\n\
    \    let current_smaller = 1;\n    let current_larger = 0;\n    let current_distance\
    \ = Number.MAX_VALUE;\n\n    for (let i = 0; i < numbers.length; ++i) {\n    \
    \    const value = numbers[i];\n        const distance = value - first;\n    \
    \    if (distance < current_distance) {\n            if (distance < current_smaller)\
    \ {\n                current_smaller = distance;\n                current_smaller_i\
    \ = i;\n            }\n            if (distance > current_larger) {\n        \
    \        current_larger = distance;\n                current_larger_i = i;\n \
    \           }\n        }\n        current_distance = value;\n    }\n\n    return\
    \ [\n        current_smaller,\n        current_larger,\n    ];\n}\n", "    let\
    \ closest = [null, null];\n    let distance: number;\n    for (let i = 0; i <\
    \ numbers.length; i += 1) {\n        const num = numbers[i];\n        const distanceSqr\
    \ = num * num;\n        distance = i === 0 ? 0 : distanceSqr - (closest[0]! *\
    \ closest[0]);\n        if (distance < 0 || distance > distanceSqr) {\n      \
    \      continue;\n        }\n        closest[0] = num;\n        closest[1] = i;\n\
    \    }\n    if (closest[0] === null || closest[1] === null) {\n        throw new\
    \ Error('Nope');\n    }\n    return [closest[0], closest[1]];\n}", "\tlet sorted_numbers\
    \ = numbers.slice().sort((a, b) => a - b);\n\tlet start = 0;\n\tlet end = numbers.length\
    \ - 1;\n\tlet pivot = sorted_numbers[end];\n\tlet chosen = [];\n\n\tfor (let i\
    \ = 0; i < numbers.length; i++) {\n\t\tlet dist = Math.abs(numbers[i] - pivot);\n\
    \t\tif (dist < end - start) {\n\t\t\tstart = i;\n\t\t}\n\t\tif (dist > end - start)\
    \ {\n\t\t\tend = i;\n\t\t}\n\t\tchosen.push(numbers[i]);\n\t}\n\n\treturn chosen;\n\
    }\n", "    \n    const sorted = numbers.slice().sort((a,b) => b-a);\n    \n  \
    \  const differences = numbers.map((num) => {\n        return (num - sorted[0]);\n\
    \    });\n    \n    return sorted.map((num, i) => {\n        if (i === numbers.length\
    \ - 1) {\n            return sorted[0];\n        }\n        return sorted[i+1]\
    \ - sorted[i];\n    });\n    \n}\n", "  // Get the closest two numbers.\n  let\
    \ min_distance: number|undefined = numbers[0]\n  let max_distance: number|undefined\
    \ = numbers[0]\n  for (let i = 1; i < numbers.length; ++i) {\n    const distance\
    \ = numbers[i] - numbers[i - 1]\n    if (distance < min_distance) {\n      min_distance\
    \ = distance\n    }\n    if (distance > max_distance) {\n      max_distance =\
    \ distance\n    }\n  }\n  // Return the two closest numbers.\n  return [min_distance,\
    \ numbers[numbers.length - 2 - min_distance]]\n}\n", "    let min = numbers[0];\n\
    \    let max = numbers[0];\n\n    for (let i = 1; i < numbers.length; i++) {\n\
    \        if (numbers[i] < min) {\n            min = numbers[i];\n        } else\
    \ if (numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\n\
    \    return [min, max];\n}\n</code>\n<|/ a tags=typescript |>\n<| a dscore=0 tags=typescript\
    \ |>\nJust for completeness, I made a solution which does not involve any loop\
    \ and uses ES6 functions.\n<code>\nconst findClosestElements = (arr: number[])\
    \ => {\n  let min = arr[0], max = arr[0];\n\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    } else if (arr[i]\
    \ > max) {\n      max = arr[i];\n    }\n  }\n\n  return [min, max];\n};\n\nfindClosestElements([1,\
    \ 2, 3, 4, 5.5, 6]); // [2.5, 5.5]\n</code>\n<|/ a |>\n<| c |>\nThis works but\
    \ doesn't scale. You've got to loop through the entire array for it to work. In\
    \ other words, it's O(n), not O(log n). Though I suppose you could also do something\
    \ similar in conjunction with [Binary Search](https://en.wikipedia.org/wiki/Binary_search_algorithm)\n\
    <|/ c |>\n<| a |>\nThe accepted answer is definitely a good answer but it is O(n)\
    \ which isn't great for large lists.\nHere is a solution which does it in O(log\
    \ n) time and uses binary search to find the closest value to the input.\n<code>",
  "  numbers.sort((a, b) => a - b)\n  if (numbers.length < 2) return [numbers[0],\
    \ numbers[0]]\n  let min1 = numbers[0]\n  let max1 = numbers[0]\n  let min2 =\
    \ numbers[0]\n  let max2 = numbers[0]\n  for (let i = 1; i < numbers.length; i\
    \ += 1) {\n    if (numbers[i] > max1) max2 = max1\n    else if (numbers[i] < min1)\
    \ min2 = min1\n    else {\n      max2 = numbers[i]\n      min2 = numbers[i]\n\
    \    }\n  }\n  if (max1 < min2) return [min2, max2]\n  return [max2, min2]\n}\n",
  "  let minimum = numbers[0];\n  let maximum = numbers[0];\n\n  for (let i = 0; i\
    \ < numbers.length; i++) {\n    const element = numbers[i];\n    if (element <\
    \ minimum) {\n      minimum = element;\n    }\n    if (element > maximum) {\n\
    \      maximum = element;\n    }\n  }\n  return [minimum, maximum];\n}\n", "\t\
    let min_dist = 0;\n\tlet closest_index = 0;\n\tlet closest_val = numbers[0];\n\
    \tfor (let index = 0; index < numbers.length; ++index) {\n\t\tlet diff = numbers[index]\
    \ - closest_val;\n\t\tif (diff >= 0) {\n\t\t\tif (diff < min_dist) {\n\t\t\t\t\
    min_dist = diff;\n\t\t\t\tclosest_index = index;\n\t\t\t}\n\t\t} else {\n\t\t\t\
    if (diff > min_dist) {\n\t\t\t\tmin_dist = diff;\n\t\t\t\tclosest_index = index;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn [numbers[closest_index], numbers[closest_index +\
    \ 1]];\n}\n", "\tconst sorted_numbers = numbers.sort((a, b) => a - b);\n\tconst\
    \ largest = sorted_numbers[sorted_numbers.length - 1];\n\tconst smallest = sorted_numbers[0];\n\
    \treturn [smallest, largest];\n}\n", "\tif (numbers.length < 2) {\n\t\tthrow new\
    \ Error(\"find_closest_elements: [numbers.length] is less than 2\");\n\t}\n\t\
    const min = Math.min(...numbers);\n\tconst max = Math.max(...numbers);\n\n\tconst\
    \ differences = numbers.map(num => {\n\t\treturn Math.abs(num - min);\n\t});\n\
    \tconst closest = differences.reduce((best, [index, difference]) => {\n\t\tif\
    \ (difference === best[0]) {\n\t\t\treturn [index, difference];\n\t\t}\n\t\tif\
    \ (difference < best[0]) {\n\t\t\treturn [index, difference];\n\t\t} else if (difference\
    \ > best[0]) {\n\t\t\treturn best;\n\t\t}\n\t\tthrow new Error(`find_closest_elements:\
    \ ${difference} is not in ${best}`);\n\t}, [max, 0]);\n\treturn numbers.map(num\
    \ => {\n\t\treturn num < best[1] ? num : best[1];\n\t});\n}\n", "\tlet min1 =\
    \ Number.MAX_VALUE;\n\tlet min2 = Number.MAX_VALUE;\n\tlet found1 = false;\n\t\
    let found2 = false;\n\n\tnumbers.forEach((number) => {\n\t\tif (number < min1)\
    \ {\n\t\t\tmin1 = number;\n\t\t\tfound1 = true;\n\t\t}\n\n\t\tif (number > min2)\
    \ {\n\t\t\tmin2 = number;\n\t\t\tfound2 = true;\n\t\t}\n\t});\n\n\tif (found1\
    \ && found2) {\n\t\treturn [min1, min2];\n\t}\n\tif (found1) {\n\t\treturn [min1,\
    \ numbers[0]];\n\t}\n\tif (found2) {\n\t\treturn [numbers[0], min2];\n\t}\n\n\t\
    throw new Error(`No such element found among ${numbers.join(', ')}`);\n}\n", " \
    \   let a = [...numbers]\n    let b = [...numbers]\n    a.sort((a, b) => {\n \
    \       let aDist = dist(a, b)\n        let bDist = dist(b, a)\n        return\
    \ aDist < bDist ? 1 : -1\n    })\n    b.sort((a, b) => {\n        let aDist =\
    \ dist(a, b)\n        let bDist = dist(b, a)\n        return aDist < bDist ? 1\
    \ : -1\n    })\n    return [a, b]\n}\n", "  let smaller = numbers[0];\n  let larger\
    \ = numbers[1];\n\n  if (smaller == null || larger == null) {\n    return [numbers[0],\
    \ numbers[1]];\n  }\n\n  for (let i = numbers.length - 1; i > 0; i--) {\n    if\
    \ (numbers[i] < smaller) {\n      smaller = numbers[i];\n    }\n    if (numbers[i]\
    \ > larger) {\n      larger = numbers[i];\n    }\n  }\n\n  return [smaller, larger];\n\
    }\n", "  const closest = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n\
    \  for (let i = 0; i < numbers.length; i++) {\n    let a = Math.abs(numbers[i]);\n\
    \    let b = Math.abs(closest[0]);\n    let c = Math.abs(numbers[0]);\n    if\
    \ (a > b) {\n      closest[0] = numbers[i];\n    } else if (b > c) {\n      closest[1]\
    \ = numbers[i];\n    }\n  }\n  return closest;\n}\n", "\t// find smallest number\n\
    \tlet smallest = numbers[0];\n\t// find largest number\n\tlet largest = numbers[0];\n\
    \tfor (const n of numbers) {\n\t\tif (n < largest) {\n\t\t\tlargest = n;\n\t\t\
    } else if (n > smallest) {\n\t\t\tsmallest = n;\n\t\t}\n\t}\n\tnumbers = [smallest,\
    \ largest];\n\tlet smallest_index = numbers[0];\n\tlet largest_index = numbers[1];\n\
    \t// remove elements from numbers in array that are smaller/larger than both indexes\n\
    \tfor (let i = 0; i < numbers.length; i++) {\n\t\tif (numbers[i] > largest_index)\
    \ {\n\t\t\tlargest_index = numbers[i];\n\t\t} else if (numbers[i] < smallest_index)\
    \ {\n\t\t\tsmallest_index = numbers[i];\n\t\t}\n\t}\n\t// create array from smallest_index\
    \ and largest_index so that numbers doesn't have to be copied\n\tlet result =\
    \ [smallest_index, largest_index];\n\t// remove numbers from array that are larger\
    \ than the smallest index\n\tfor (let i = numbers.length - 1; i >= 0; i--) {\n\
    \t\tif (numbers[i] > smallest_index) {\n\t\t\tnumbers.splice(i, 1);\n\t\t}\n\t\
    }\n\treturn result;\n}\n", "    const len = numbers.length;\n    if (len < 2)\
    \ {\n        return numbers;\n    }\n    if (len === 2) {\n        return [numbers[0],\
    \ numbers[0]];\n    }\n    let min = Math.min(numbers[0], numbers[1]);\n    let\
    \ max = Math.max(numbers[0], numbers[1]);\n    let mid = min;\n    let i0 = 0;\n\
    \    let i1 = 1;\n    // eslint-disable-next-line\n    for (let i = 2; i < len;\
    \ i++) {\n        mid = (min + max) / 2;\n        if (numbers[i] > mid) {\n  \
    \          max = mid;\n        } else if (numbers[i] < mid) {\n            min\
    \ = mid;\n        } else {\n            i0 = i1;\n            i1 = i;\n      \
    \  }\n    }\n    return [i0, i1];\n}\n", "\tlet min: number = numbers[0]\n\tlet\
    \ max: number = numbers[0]\n\tfor (let i = 1, l = numbers.length; i < l; i++)\
    \ {\n\t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i]\n\t\t} else if (numbers[i]\
    \ > max) {\n\t\t\tmax = numbers[i]\n\t\t}\n\t}\n\treturn [min, max]\n}\n", " \
    \ numbers.sort(function (a, b) {\n    return Math.abs(a - b) < 0.001;\n  });\n\
    \  let midpoint = Math.floor(numbers.length / 2);\n  if (numbers.length === 2)\
    \ {\n    return [numbers[0], numbers[1]];\n  } else if (numbers.length === 1)\
    \ {\n    return numbers;\n  }\n  let left = [numbers[0], numbers[midpoint]];\n\
    \  let right = [numbers[midpoint + 1], numbers[numbers.length - 1]];\n  left[0]\
    \ = left[0] + 0.0000001;\n  left[1] = left[1] + 0.0000001;\n  right[0] = right[0]\
    \ - 0.0000001;\n  right[1] = right[1] - 0.0000001;\n  console.log(left, right);\n\
    \  return [left[1], right[1]];\n}\n", "  let sorted = numbers.sort((a, b) => a\
    \ - b);\n  let result: [number, number] = sorted[0];\n  sorted.forEach((n, index)\
    \ => {\n    if (n !== sorted[index]) {\n      result = [n, sorted[index]];\n \
    \   }\n  });\n  return result;\n}", "  // Find the smallest and largest numbers\
    \ from the array\n  let smallest = numbers[0];\n  let largest = numbers[0];\n\
    \  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < smallest)\
    \ {\n      smallest = numbers[i];\n    }\n    if (numbers[i] > largest) {\n  \
    \    largest = numbers[i];\n    }\n  }\n\n  // Select the two numbers that will\
    \ be closest to the largest\n  let closest_to_largest = (largest - smallest) /\
    \ 2;\n\n  // If one of the numbers is the largest, swap them\n  if (closest_to_largest\
    \ === largest) {\n    let temp = largest;\n    largest = smallest;\n    smallest\
    \ = temp;\n  }\n\n  // Return the array of two closest numbers\n  return [smallest,\
    \ largest];\n}\n", "    console.log(\"starting find_closest_elements\");\n   \
    \ console.log(numbers);\n    let closest = [numbers[0], numbers[0]];\n    let\
    \ closest_idx = 1;\n    for (let i = 1; i < numbers.length; i++) {\n        if\
    \ (numbers[i] > closest[1]) {\n            closest = [numbers[i], numbers[i]];\n\
    \            closest_idx = i;\n        }\n    }\n    if (closest[1] < numbers[1])\
    \ {\n        closest = [numbers[1], numbers[1]];\n        closest_idx = 1;\n \
    \   }\n    console.log(\"finished find_closest_elements\");\n    return [numbers[closest_idx],\
    \ closest];\n}\n", "\tconst sortedNumbers = numbers.slice(0).sort((a, b) => {\n\
    \t\treturn Math.abs(a) - Math.abs(b);\n\t});\n\tconst result = sortedNumbers.slice(0,\
    \ 2).map((el) => sortedNumbers.indexOf(el));\n\treturn result;\n}\n", "    let\
    \ sorted: number[] = numbers.slice();\n    sorted.sort();\n\n    let first = 0;\n\
    \    let last = numbers.length - 1;\n\n    let results: number[] = [];\n    while\
    \ (first <= last) {\n        if (sorted[first] + sorted[last] < sorted[first +\
    \ 1] + sorted[last]) {\n            results.push(sorted[first]);\n           \
    \ first += 1;\n        }\n        else if (sorted[first] + sorted[last] < sorted[first]\
    \ + sorted[last + 1]) {\n            results.push(sorted[last]);\n           \
    \ last -= 1;\n        }\n        else {\n            results.push(sorted[first\
    \ + 1]);\n            first += 1;\n            last -= 1;\n        }\n    }\n\
    \    return results;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nIn case you are\
    \ still interested in an alternative answer to the question above, I have another\
    \ method that does not require any libraries, only plain Javascript.\nThe method\
    \ goes as follows: It generates an array of all possible combinations out of the\
    \ provided array. For this there are two functions: one to generate the combinations\
    \ (called combinations) and the other to filter the combinations (called filter).\
    \ Combinations are generated using nested loops over all the arrays in turn. As\
    \ soon as one value is found, it is pushed to the resultCombinations array. In\
    \ the filter method, it is also possible to decide which combinations are to be\
    \ kept or filtered:\n<code>\nconst combinations = (arr: number[][]): number[][]\
    \ => {\n    let resultCombinations: number[][] = [];\n\n    for (let firstIndex\
    \ = 0; firstIndex < arr.length; firstIndex++) {\n        let currentArray = arr[firstIndex];\n\
    \n        // Add all combinations from all arrays\n        for (let secondIndex\
    \ = 0; secondIndex < arr.length; secondIndex++) {\n            let nextArray =\
    \ arr[secondIndex];\n\n            for (let thirdIndex = 0; thirdIndex < nextArray.length;\
    \ thirdIndex++) {\n                let nextArray2 = arr[thirdIndex];\n\n     \
    \           for (let fourthIndex = 0; fourthIndex < nextArray2.length; fourthIndex++)\
    \ {\n                    let nextArray3 = arr[fourthIndex];\n\n              \
    \      for (let fifthIndex = 0; fifthIndex < nextArray3.length; fifthIndex++)\
    \ {\n                        let nextArray4 = arr[fifthIndex];\n\n           \
    \             for (let sixthIndex = 0; sixthIndex < nextArray4.length; sixthIndex++)\
    \ {\n                            let nextArray5 = arr[sixthIndex];\n\n       \
    \                     for (let seventhIndex = 0; seventhIndex < nextArray5.length;\
    \ seventhIndex++) {\n                                let nextArray6 = arr[seventhIndex];\n\
    \n                                for (let eighthIndex = 0; ", "    let min =\
    \ numbers[0];\n    let max = numbers[0];\n    for (let i = 0; i < numbers.length;\
    \ i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n   \
    \     } else if (numbers[i] > max) {\n            max = numbers[i];\n        }\n\
    \    }\n    return [min, max];\n}\n</code>\n<|/ a |>\n<| c |>\nI believe it's\
    \ just supposed to return the closest numbers, not their index. Or am I mistaken?\n\
    <|/ c |>\n<| c |>\nThis is why I added a comment saying \"return them in order\
    \ (smaller number, larger number).\" I didn't want to give the OP an answer that\
    \ returned the index, since that's a little more involved.\n<|/ c |>\n<| c |>\n\
    Yeah, I understand that. But in this case it looks like the OP does want their\
    \ index, so I'm just pointing it out. Still a good answer, though. :)\n<|/ c |>\n\
    <| c |>\nThis is so cool, I'm gonna reimplement it using functional programming\
    \ and probably use a different data structure, thank you so much!\n<|/ c |>\n\
    <| c |>\n: This is actually the best answer, because it doesn't require the use\
    \ of any extra memory to store intermediate results. However, it would be a better\
    \ answer if you included a description of how this code is actually supposed to\
    \ work from the very beginning. Just saying \"this is how you do this\" doesn't\
    \ help anyone else reading this.\n<|/ c |>\n<| a tags=arrays,javascript,algorithm\
    \ dscore=3 |>\nSince you have accepted a posted answer but then you changed your\
    \ mind I thought I'd provide a second solution.\nIt uses a combination of min\
    \ and reduce.\n\n<code>\nconst findClosest = (arr) => {\n  const result = arr.reduce((acc,\
    \ cur) => {\n    if (acc[1] < cur) {\n      acc = [cur, cur];\n    } else if (acc[1]\
    \ > cur) {\n      acc = [acc[0], cur];\n    } else {\n      acc[1] = cur;\n  \
    \  }\n    return acc;\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n\
    \  return [\n    result[0],\n    arr.reduce((acc, cur) => {\n      if (acc < cur)\
    \ {\n        acc = cur;\n      } else if (acc > cur) {\n        acc = acc;\n \
    \     } else {\n        acc = cur;\n      }\n      return acc;\n    }),\n  ];\n\
    };\n\nconsole.log(findClosest([5, 4, 1, 3, 7, 9]));\nconsole.log(findClosest([5,\
    \ 4, 1, 3, 7, 10]));\nconsole.log(findClosest([5, 4, 1, ", "\tconst closest_indexes\
    \ = Array(numbers.length).fill(0);\n\n\tfor (let i = 0; i < numbers.length; i++)\
    \ {\n\t\tlet best_difference = numbers[i].abs() - numbers[closest_indexes[i]].abs();\n\
    \t\tlet best_index = i;\n\t\tfor (let j = i; j < closest_indexes.length; j++)\
    \ {\n\t\t\tif (numbers[j].abs() < best_difference) {\n\t\t\t\tbest_difference\
    \ = numbers[j].abs() - numbers[closest_indexes[j]].abs();\n\t\t\t\tbest_index\
    \ = j;\n\t\t\t}\n\t\t}\n\t\tclosest_indexes[best_index] = i;\n\t}\n\tconst closest\
    \ = numbers.map((number, index) => [number, numbers[closest_indexes[index]]]);\n\
    \treturn closest;\n}\n", "    let result: [number, number] = [0, 0];\n\n    numbers.forEach(x\
    \ => {\n        if (result[0] == 0) {\n            result[0] = x;\n        } else\
    \ {\n            let diff = Math.abs(x - result[0]);\n            if (diff < result[1])\
    \ {\n                result[1] = diff;\n            }\n        }\n    });\n  \
    \  return result;\n}\n", "\tif (numbers.length < 2)\n\t\tthrow new Error(`There\
    \ must be at least one number provided`)\n\tlet smallest = numbers[0]\n\tlet largest\
    \ = numbers[0]\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i]\
    \ > largest)\n\t\t\tlargest = numbers[i]\n\t\tif (numbers[i] < smallest)\n\t\t\
    \tsmallest = numbers[i]\n\t}\n\treturn [smallest, largest]\n}\n", "    var smallest\
    \ = numbers[0], largest = numbers[0];\n    for (var i = 1; i < numbers.length;\
    \ i++) {\n        if (numbers[i] < smallest || !smallest) {\n            smallest\
    \ = numbers[i];\n        }\n        if (numbers[i] > largest || !largest) {\n\
    \            largest = numbers[i];\n        }\n    }\n    return [smallest, largest];\n\
    }\n", "\tlet min1 = Number.MAX_VALUE;\n\tlet min2 = Number.MAX_VALUE;\n\tlet closest_min\
    \ = min1;\n\tfor (let i = 0; i < numbers.length - 1; i++) {\n\t\tconst d = Math.abs(numbers[i]\
    \ - numbers[i + 1]);\n\t\tif (d < min1) {\n\t\t\tmin2 = min1;\n\t\t\tmin1 = d;\n\
    \t\t} else if (d < min2) {\n\t\t\tmin2 = d;\n\t\t}\n\t}\n\tif (min2 === Number.MAX_VALUE)\
    \ {\n\t\treturn [numbers[0], numbers[numbers.length - 1]];\n\t}\n\treturn [numbers[Math.min(min1,\
    \ min2) - 1], numbers[Math.min(min1, min2) - 1]];\n}\n", "    const min_val =\
    \ Math.min(...numbers);\n    const max_val = Math.max(...numbers);\n    const\
    \ range = max_val - min_val;\n    const target_range = range * 0.8;\n    const\
    \ num_closest = numbers.length;\n    const closest_elements = [min_val, max_val];\n\
    \    for (let i = 0; i < num_closest; i++) {\n        const element = numbers[i];\n\
    \        const distance = Math.abs(element - min_val);\n        if (distance <\
    \ target_range) {\n            closest_elements.push(element);\n        }\n  \
    \      else if (distance > target_range * 0.99) {\n            closest_elements.pop();\n\
    \        }\n    }\n    return closest_elements;\n}\n", "    let min: number\n\
    \    let max: number\n    if (numbers.length < 2) {\n        return [null, null]\n\
    \    }\n    numbers.sort((a, b) => {\n        return Math.abs(b) - Math.abs(a)\n\
    \    })\n    min = numbers[0]\n    max = numbers[0]\n    numbers.forEach((n: number)\
    \ => {\n        if (n < min) {\n            min = n\n        }\n        if (n\
    \ > max) {\n            max = n\n        }\n    })\n    return [min, max]\n}\n",
  "    const min1 = numbers[0];\n    let min2 = numbers[0];\n    for (let i = 1; i\
    \ < numbers.length; i++) {\n        if (numbers[i] < min1) {\n            min1\
    \ = numbers[i];\n        } else if (numbers[i] > min2) {\n            min2 = numbers[i];\n\
    \        }\n    }\n    return [min1, min2];\n}\n", "  let minIndex = 0;\n  let\
    \ maxIndex = numbers.length - 1;\n  while (minIndex < maxIndex) {\n    let currentIndex\
    \ = Math.round((minIndex + maxIndex) / 2);\n    let currentNumber = numbers[currentIndex];\n\
    \    let nextNumber = numbers[minIndex];\n    let previousNumber = numbers[maxIndex];\n\
    \n    let nextDiff = Math.abs(currentNumber - nextNumber);\n    let previousDiff\
    \ = Math.abs(currentNumber - previousNumber);\n    if (nextDiff < previousDiff)\
    \ {\n      minIndex = currentIndex + 1;\n    } else {\n      maxIndex = currentIndex\
    \ - 1;\n    }\n  }\n  return [numbers[minIndex], numbers[maxIndex]];\n}\n", "\t\
    if (numbers.length < 2) return [numbers[0], numbers[0]];\n\tlet min_diff = Number.POSITIVE_INFINITY;\n\
    \tlet min_index = 0;\n\tfor (let index = 1; index < numbers.length; index++) {\n\
    \t\tconst current_diff = abs(numbers[index] - numbers[min_index]);\n\t\tif (current_diff\
    \ < min_diff) {\n\t\t\tmin_index = index;\n\t\t\tmin_diff = current_diff;\n\t\t\
    }\n\t}\n\treturn [numbers[min_index], numbers[min_index + 1]];\n}\n", "\tconst\
    \ sortedArray = numbers.sort((a, b) => {\n\t\treturn Math.abs(a) - Math.abs(b);\n\
    \t});\n\tconst index1: number = sortedArray[0];\n\tconst index2: number = sortedArray[1];\n\
    \tlet result: number[] = [index1, index2];\n\tif (index1 > index2) {\n\t\tresult\
    \ = result.concat([index2, index1]);\n\t}\n\treturn result;\n}\n", "  if (numbers.length\
    \ < 2) {\n    throw new Error(\n      `The numbers.length must be at least 2,\
    \ but the length is ${numbers.length}!`\n    );\n  }\n  const min: number = numbers[0];\n\
    \  const max: number = numbers[0];\n  let min_index: number = 0;\n  let max_index:\
    \ number = 0;\n  for (let i = 1; i < numbers.length; i += 1) {\n    if (numbers[i]\
    \ < min) {\n      min = numbers[i];\n      min_index = i;\n    }\n    if (numbers[i]\
    \ > max) {\n      max = numbers[i];\n      max_index = i;\n    }\n  }\n  return\
    \ [numbers[min_index], numbers[max_index]];\n}\n", "    let min_dist = Number.MAX_VALUE;\n\
    \    let min_index = 0;\n    let max_dist = Number.MIN_VALUE;\n    let max_index\
    \ = 0;\n\n    for (let i = 0; i < numbers.length; ++i) {\n        let current_dist\
    \ = Math.hypot(numbers[i] - numbers[min_index], numbers[max_index] - numbers[i]);\n\
    \        if (current_dist < min_dist) {\n            min_dist = current_dist;\n\
    \            min_index = i;\n        } else if (current_dist > max_dist) {\n \
    \           max_dist = current_dist;\n            max_index = i;\n        }\n\
    \    }\n\n    return [numbers[min_index], numbers[max_index]];\n}\n", "  // We\
    \ sort the number array so that any two numbers in the array that are equidistant\
    \ are next to each other\n  // as they are when sorted.\n  numbers.sort((a, b)\
    \ => {\n    return a - b;\n  });\n  // we use a binary search to find the smallest\
    \ number greater than the target and less than the target.\n  const [lowIndex,\
    \ highIndex] = Math.trunc(numbers.length / 2);\n  // If the target is larger than\
    \ the array, then there isn't enough number in the array for the target.\n  //\
    \ If the target is smaller than the array, then there are no numbers in the array\
    \ for the target.\n  const targetIndex = numbers.length - 1;\n  // If the target\
    \ isn't in the array, it doesn't exist.\n  if (targetIndex < 0 || targetIndex\
    \ >= numbers.length) {\n    return [];\n  }\n  // If the target is in the array,\
    \ it exists in the array and is the one we want.\n  if (targetIndex === lowIndex)\
    \ {\n    return [numbers[lowIndex], numbers[highIndex]];\n  }\n  // If the target\
    \ is between two numbers in the array,\n  // then we check if it is less than\
    \ the left number and bigger than the right number.\n  const leftNumber = numbers[lowIndex];\n\
    \  const rightNumber = numbers[highIndex];\n  if (leftNumber < targetIndex &&\
    \ targetIndex < rightNumber) {\n    // left and right are closer than target so\
    \ we return them in the correct order.\n    return [numbers[lowIndex], numbers[highIndex]];\n\
    \  }\n  if (leftNumber < targetIndex && targetIndex > rightNumber) {\n    // left\
    \ is closer than target so return it first\n    return [numbers[lowIndex], numbers[highIndex]];\n\
    \  }\n  // target is larger than both numbers in the array, return right number\
    \ first\n  if (targetIndex > leftNumber && targetIndex < rightNumber) {\n    return\
    \ [numbers[lowIndex], numbers[highIndex]];\n  }\n  return [numbers[highIndex],\
    \ numbers[lowIndex]];\n}\n", "    var closest_indexes: number[] = [];\n    var\
    \ closest_dists: number[] = [];\n\n    for (var i = 1; i < numbers.length; i++)\
    \ {\n        var current_dist = numbers[0] - numbers[i];\n        var current_index\
    \ = 0;\n        while (current_index < closest_indexes.length &&\n           \
    \    current_dist >= closest_dists[current_index]) {\n            current_dist\
    \ = Math.abs(closest_dists[current_index]);\n            current_index++;\n  \
    \      }\n        closest_dists[current_index] = current_dist;\n        closest_indexes.push(current_index);\n\
    \    }\n\n    return closest_indexes.map(function (index) {\n        return numbers[index];\n\
    \    });\n}\n\nexport function randomInt(max: number, min: number = 0): number\
    \ {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport\
    \ function get_random_name(prefix: string): string {\n    var name = prefix +\
    \ \"-\";\n    name += randomInt(10000000, 99999999);\n    return name;\n}\n\n\
    export function create_new_id(prefix: string): string {\n    return get_random_name(prefix);\n\
    }\n\nexport function get_node_value(el: Element): number {\n    if (el.dataset.val)\
    \ {\n        return +el.dataset.val;\n    }\n    if (el.tagName == \"TEXTAREA\"\
    ) {\n        return +el.value.trim();\n    }\n    return +el.value;\n}\n\nexport\
    \ function get_text_from_element(el: Element): string {\n    if (el.dataset.val)\
    \ {\n        return el.dataset.val;\n    }\n    if (el.tagName == \"TEXTAREA\"\
    ) {\n        return el.value;\n    }\n    return el.value;\n}\n\nexport function\
    \ set_text_in_element(el: Element, val: string): void {\n    if (el.dataset.val)\
    \ {\n        el.dataset.val = val;\n    }\n    if (el.tagName == \"TEXTAREA\"\
    ) {\n        el.value = val;\n    }\n    el.value = val;\n}\n\nexport function\
    \ is_element_selected(el: Element): boolean {\n    if (el.dataset.val) {\n   \
    \     return el.dataset.val == 1;\n    }\n    if (el.tagName == \"TEXTAREA\")\
    \ {\n        return el.value == \"\";\n    }\n    return el.checked;\n}\n\nexport\
    \ function update_model_from_select_box(el: Element): void {\n    // We update\
    \ *both* the model *and* the select box value,\n    // because updating the select\
    \ box can have other implications.\n    const value = get_node_value(el);\n  \
    \  // Deselect all\n    const selected_values = Array.from(el.querySelectorAll(\"\
    option:checked\")).map((option) => get_text_from_element(option));\n    el.value\
    \ = selected_values.join(\",\");\n\n    // Only update the model if the select\
    \ box value is not the empty string\n    if (!value) {\n        return;\n    }\n\
    \    const model = JSON.parse(el.dataset.val as string);\n    const ", "  let\
    \ min_index = 0;\n  let max_index = numbers.length - 1;\n  let min_dist = Number.MAX_VALUE;\n\
    \  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for (let i =\
    \ 0; i < numbers.length; i++) {\n    const curr = numbers[i];\n    const diff\
    \ = curr - min_value;\n    if (diff < min_dist) {\n      min_dist = diff;\n  \
    \    min_index = i;\n      min_value = curr;\n    }\n    if (diff > max_dist)\
    \ {\n      max_dist = diff;\n      max_index = i;\n      max_value = curr;\n \
    \   }\n  }\n  if (max_index - min_index > 1) {\n    return [min_value, max_value];\n\
    \  }\n  return [min_value, max_index];\n}\n", "  // Sort numbers in descending\
    \ order so closest is first.\n  // If two numbers are equally close, sort by the\
    \ next smaller number.\n  const sorted = numbers.slice().sort((a, b) =>\n    b\
    \ - a ||\n    (b === a ? 0 : Number.POSITIVE_INFINITY));\n\n  // Return any two\
    \ numbers that are closest.\n  // If no two numbers are closest, return two numbers\
    \ that are equally closest.\n  let [first, second] = sorted;\n  let delta = first\
    \ - second;\n  if (Math.abs(delta) > 1e-12) {\n    // If delta is close to zero,\
    \ just return the two numbers equally close.\n    return [first, second];\n  }\n\
    \n  // If delta is close to zero, return the closest pair\n  // that is in the\
    \ other direction.\n  if (delta < -1e-12) {\n    first = sorted[1];\n    second\
    \ = sorted[0];\n    return [first, second];\n  }\n\n  // If delta is close to\
    \ zero, return the closest pair\n  // that is in the other direction.\n  if (delta\
    \ > 1e-12) {\n    first = sorted[0];\n    second = sorted[1];\n    return [first,\
    \ second];\n  }\n\n  // If two numbers are equally close, return the closest pair\n\
    \  // that is the average of the two numbers.\n  first = sorted[0] + sorted[1]\
    \ * 0.5;\n  second = sorted[0] + sorted[1] * 0.5;\n  return [first, second];\n\
    }\n", "\tlet smallest: number = null;\n\tlet largest: number = null;\n\tnumbers.sort((a:\
    \ number, b: number) => {\n\t\tif (a < b) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (a\
    \ > b) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n\tnumbers.some((number:\
    \ number) => {\n\t\tlet delta = number - largest;\n\t\tif (delta > 0) {\n\t\t\t\
    return true; // We have a new best option\n\t\t}\n\t\tlargest = number;\n\t});\n\
    \tnumbers.some((number: number) => {\n\t\tlet delta = number - smallest;\n\t\t\
    if (delta < 0) {\n\t\t\treturn true; // We have a new best option\n\t\t}\n\t\t\
    smallest = number;\n\t});\n\treturn [smallest, largest];\n}\n", "  let smallest\
    \ = Math.min(...numbers);\n  let largest = Math.max(...numbers);\n\n  return numbers.filter(\n\
    \    number =>\n      number < smallest || number > largest\n  ) as [number, number];\n\
    }\n", "  let minIndex = 0;\n  let maxIndex = numbers.length - 1;\n  while (minIndex\
    \ < maxIndex) {\n    const currentIndex = Math.floor((minIndex + maxIndex) / 2);\n\
    \    const currentValue = numbers[currentIndex];\n    if (numbers[currentIndex]\
    \ < numbers[minIndex]) minIndex = currentIndex;\n    else if (numbers[currentIndex]\
    \ > numbers[maxIndex]) maxIndex = currentIndex;\n    else {\n      if (currentValue\
    \ < numbers[maxIndex]) {\n        maxIndex = currentIndex;\n      } else if (currentValue\
    \ > numbers[minIndex]) {\n        minIndex = currentIndex;\n      }\n    }\n \
    \ }\n  return [numbers[minIndex], numbers[maxIndex]];\n}\n", "    // Go through\
    \ the array and find the closest number to each\n    let largest = numbers[0];\n\
    \    let smaller = numbers[0];\n    for (let i = 0; i < numbers.length; i++) {\n\
    \        if (numbers[i] > largest) {\n            larger = numbers[i];\n     \
    \   } else if (numbers[i] < smaller) {\n            smaller = numbers[i];\n  \
    \      }\n    }\n    return [smaller, largest];\n}\n", "\t// Sort numbers descending\
    \ - largest first.\n\tnumbers.sort(numbers_comparator);\n\n\t// Return the first\
    \ two elements of the sorted array.\n\treturn [numbers[0], numbers[1]];\n}\n",
  "    const sorted: number[] = [...numbers]\n    sorted.sort()\n    if (numbers.length\
    \ < 2) return [numbers[0], numbers[0]]\n    const index0 = numbers.findIndex((x,\
    \ i) => x >= sorted[i - 1] && x <= sorted[i])\n    const index1 = numbers.findIndex((x,\
    \ i) => x >= sorted[index0] && x <= sorted[i])\n    return [sorted[index0], sorted[index1]]\n\
    }\n", "\tconst min_dist = Number.MAX_VALUE;\n\tconst min_idx = -1;\n\tfor (let\
    \ i = 0; i < numbers.length; i++) {\n\t\tconst dist = numbers[i] - numbers[min_idx];\n\
    \t\tif (dist < min_dist) {\n\t\t\tmin_dist = dist;\n\t\t\tmin_idx = i;\n\t\t}\n\
    \t}\n\treturn [numbers[min_idx], numbers[min_idx + 1]];\n}\n", "    const smallest_difference\
    \ = numbers[0];\n\n    let selected_number: number = numbers[1];\n    let selected_difference\
    \ = numbers[1];\n\n    for (let i = 2; i < numbers.length; i++) {\n        const\
    \ difference = Math.abs(numbers[i] - selected_number);\n\n        if (difference\
    \ < smallest_difference) {\n            selected_number = numbers[i];\n      \
    \      selected_difference = difference;\n        }\n    }\n\n    return [selected_number,\
    \ selected_difference];\n}\n", "\tif (numbers.length < 2) {\n\t\treturn [];\n\t\
    }\n\n\tlet minDiff = 1e9; // What's the smallest distance between any two elements?\n\
    \tlet bestIndexA: number; // Where the numbers from numbers[] best match to each\
    \ other.\n\tlet bestIndexB: number; // Where the numbers from numbers[] best match\
    \ to each other.\n\tfor (let i = 0; i < numbers.length; i++) {\n\t\tconst currentDiff\
    \ = Math.abs(numbers[i] - numbers[bestIndexA]);\n\t\tif (currentDiff < minDiff)\
    \ {\n\t\t\tminDiff = currentDiff;\n\t\t\tbestIndexA = i;\n\t\t}\n\t}\n\n\tfor\
    \ (let i = 0; i < numbers.length; i++) {\n\t\tconst currentDiff = Math.abs(numbers[bestIndexB]\
    \ - numbers[i]);\n\t\tif (currentDiff < minDiff) {\n\t\t\tminDiff = currentDiff;\n\
    \t\t\tbestIndexB = i;\n\t\t}\n\t}\n\n\treturn [numbers[bestIndexA], numbers[bestIndexB]];\n\
    }\n\nexport function get_expanded_month_names(): string[] {\n\tconst month_names:\
    \ string[] = [];\n\tfor (let i = 1; i <= 12; i++) {\n\t\tconst j = moment().year(0).month(i).format(\"\
    M\");\n\t\tmonth_names.push(j);\n\t}\n\n\treturn month_names;\n}\n\nexport function\
    \ get_expanded_years(): string[] {\n\tconst years: string[] = [];\n\tfor (let\
    \ i = 0; i <= moment().year(); i++) {\n\t\tconst j = moment().year(i).format(\"\
    YYYY\");\n\t\tyears.push(j);\n\t}\n\n\treturn years;\n}\n\nexport function get_month_names():\
    \ string[] {\n\tconst month_names: string[] = [];\n\tconst date_array = get_date_array();\n\
    \tfor (let i = 0; i < date_array.length; i++) {\n\t\tconst date_str = date_array[i].toString();\n\
    \t\tconst month_name = moment(date_str, \"DD-MM-YYYY\").month() + 1;\n\t\tmonth_names.push(month_name);\n\
    \t}\n\n\treturn month_names;\n}\n\nexport function get_date_array(): string[]\
    \ {\n\tconst dates: string[] = [];\n\tconst date_array = get_expanded_date_array();\n\
    \tfor (let i = 0; i < date_array.length; i++) {\n\t\tconst date_str = date_array[i].toString();\n\
    \t\tdates.push(date_str);\n\t}\n\n\treturn dates;\n}\n\nexport function get_expanded_date_array():\
    \ string[] {\n\tconst date_array: string[] = [];\n\tconst today = new Date();\n\
    \tconst startdate = moment(today).year(0).month(1).date(1).format(\"DD-MM-YYYY\"\
    );\n\tconst enddate = moment(today).year(moment().year()).month(moment().month()).date(moment().daysInMonth()).format(\"\
    DD-MM-YYYY\");\n\tdate_array.push(startdate);\n\tdate_array.", "\tif (numbers.length\
    \ < 2) {\n\t\treturn numbers;\n\t}\n\n\tlet min: number = numbers[0];\n\tlet max:\
    \ number = numbers[0];\n\n\tfor (let i = 1; i < numbers.length; ++i) {\n\t\tif\
    \ (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t\tif (numbers[i] < min)\
    \ {\n\t\t\tmin = numbers[i];\n\t\t}\n\t}\n\n\treturn [min, max];\n}\n", "    const\
    \ sortedArray = numbers.sort((a: number, b: number) => a - b);\n    let result:\
    \ number[] = [];\n    result.push(sortedArray[0]);\n    result.push(sortedArray[0]);\n\
    \    return result;\n}\n", "  let sorted: number[] = [];\n  let current: number\
    \ = numbers[0];\n  for (let i = 0; i < numbers.length; ++i) {\n    if (numbers[i]\
    \ < current) {\n      current = numbers[i];\n    }\n    sorted.unshift(current);\n\
    \  }\n  return sorted;\n}\n", "  const sortedArray = numbers.slice();\n  sortedArray.sort((a,\
    \ b) => a - b);\n  return sortedArray.reduce((a, b) => {\n    return [a, b]\n\
    \  }, [\n    sortedArray[0],\n    sortedArray[sortedArray.length - 1]\n  ]);\n\
    }\n", "\tlet [smallest, largest] = numbers;\n\tconst len = numbers.length;\n\t\
    let smaller: [number, number] = [smallest, Number.MAX_VALUE];\n\tlet larger: [number,\
    \ number] = [Number.MAX_VALUE, largest];\n\n\tfor (let i = 0; i < len; i++) {\n\
    \t\tconst n = numbers[i];\n\t\tif (n <= smallest) smaller[0] = n;\n\t\telse larger[0]\
    \ = n;\n\t\tif (n < largest) smaller[1] = n;\n\t\telse larger[1] = n;\n\t}\n\n\
    \tconst smallest_diff = larger[1] - smaller[0];\n\tconst largest_diff = smaller[1]\
    \ - larger[0];\n\tif (smallest_diff > largest_diff) {\n\t\tconst tmp = smaller;\n\
    \t\tsmaller = larger;\n\t\tlarger = tmp;\n\t}\n\n\treturn [larger[0], smaller[1]];\n\
    }\n", "  for (var i = 0; i < numbers.length - 1; i++) {\n    if (numbers[i] <\
    \ numbers[i + 1]) return [numbers[i], numbers[i + 1]];\n  }\n  return [numbers[numbers.length\
    \ - 1], numbers[0]];\n}", "  const [smallest_distance, largest_distance] = numbers.reduce(\n\
    \    (\n      [smallest_distance, largest_distance],\n      number: number,\n\
    \    ) =>\n      number < smallest_distance\n        ? [\n            smallest_distance,\n\
    \            number,\n          ]\n        : [\n            number,\n        \
    \    largest_distance,\n          ],\n    [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]\n\
    \  );\n\n  return [smallest_distance, largest_distance];\n}\n", "  const smallest\
    \ = numbers[0];\n  const largest = numbers[0];\n\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    if (numbers[i] < smallest) {\n      smallest = numbers[i];\n   \
    \ } else if (numbers[i] > largest) {\n      largest = numbers[i];\n    }\n  }\n\
    \n  return [smallest, largest];\n}\n", "  const smallest_number = numbers[0];\n\
    \  const second_smallest_number = numbers[1];\n  const smallest_distance = dist(numbers[0],\
    \ smallest_number);\n  const second_smallest_distance = smallest_distance;\n \
    \ const second_smallest_number = numbers[2];\n  for (let i = 3; i < numbers.length;\
    \ ++i) {\n    const distance = dist(numbers[i], second_smallest_number);\n   \
    \ if (distance < second_smallest_distance) {\n      second_smallest_distance =\
    \ distance;\n      second_smallest_number = numbers[i];\n    }\n  }\n  return\
    \ [smallest_number, second_smallest_number];\n}\n", "  if (numbers.length < 2)\
    \ {\n    throw new Error('find_closest_elements: needs at least two numbers');\n\
    \  }\n  if (numbers.length % 2 === 1) {\n    throw new Error('find_closest_elements:\
    \ needs array of even length');\n  }\n  const lower = numbers[0] - 1;\n  const\
    \ upper = numbers[0] + 1;\n  const closest_lower = numbers[1];\n  const closest_upper\
    \ = numbers[1];\n\n  for (let i = 2; i < numbers.length; ++i) {\n    if (numbers[i]\
    \ > upper) {\n      upper = numbers[i];\n    }\n    if (numbers[i] < lower) {\n\
    \      lower = numbers[i];\n    }\n    if (numbers[i] < closest_lower) {\n   \
    \   closest_lower = numbers[i];\n    }\n    if (numbers[i] > closest_upper) {\n\
    \      closest_upper = numbers[i];\n    }\n  }\n  if (numbers[numbers.length -\
    \ 1] < upper) {\n    upper = numbers[numbers.length - 1];\n  }\n  if (numbers[0]\
    \ < lower) {\n    lower = numbers[0];\n  }\n  if (numbers[0] < closest_lower)\
    \ {\n    closest_lower = numbers[0];\n  }\n  if (numbers[numbers.length - 1] >\
    \ closest_upper) {\n    closest_upper = numbers[numbers.length - 1];\n  }\n\n\
    \  return [lower, upper];\n}\n", "    if (numbers.length < 2) {\n        return\
    \ [undefined, undefined];\n    }\n    var min1 = numbers[0];\n    var min2 = numbers[0];\n\
    \    for (var i = 1; i < numbers.length; ++i) {\n        var d = distance(numbers[i],\
    \ numbers[i - 1]);\n        if (d < min1) {\n            min1 = d;\n        }\n\
    \        else if (d < min2) {\n            min2 = d;\n        }\n    }\n    return\
    \ [min2, min1];\n}\nexport = find_closest_elements;\n\n},{}],91:[function(require,module,exports){\n\
    \"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true\
    \ });", "\tif (!numbers.length) throw new Error(\"find_closest_elements: array\
    \ is empty.\");\n\tlet min: number;\n\tlet max: number;\n\tfor (let i = 0; i <\
    \ numbers.length; i += 1) {\n\t\tmin = numbers[i];\n\t\tmax = numbers[i];\n\t\t\
    for (let j = i + 1; j < numbers.length; j += 1) {\n\t\t\tif (numbers[j] < min)\
    \ {\n\t\t\t\tmin = numbers[j];\n\t\t\t} else if (numbers[j] > max) {\n\t\t\t\t\
    max = numbers[j];\n\t\t\t}\n\t\t}\n\t\tif (min === max) continue;\n\t\tnumbers.splice(i,\
    \ 1);\n\t\tnumbers.splice(j, 0, min);\n\t}\n\tconst result = numbers;\n\tnumbers.splice(0);\n\
    \treturn result;\n}\n", "\tlet sorted: number[] = [...numbers]\n\tsorted.sort()\n\
    \tlet smallest = sorted[0]\n\tlet largest = sorted[sorted.length - 1]\n\tlet result:\
    \ number[] = []\n\tlet index = 0\n\twhile (index != sorted.length - 1 && smallest\
    \ == largest) {\n\t\tresult.push(smallest)\n\t\tsmallest = sorted[index]\n\t\t\
    index++\n\t}\n\twhile (index != sorted.length - 1) {\n\t\tsmallest = sorted[index]\n\
    \t\tindex++\n\t}\n\tif (smallest == largest) {\n\t\treturn [smallest, smallest]\n\
    \t}\n\treturn [smallest, largest]\n}", "\tlet sortedNumbers = numbers.slice();\n\
    \tsortedNumbers.sort();\n\tlet closest: [number, number] = [Number.POSITIVE_INFINITY,\
    \ Number.POSITIVE_INFINITY];\n\tlet closestIndex: number = -1;\n\tfor (let i:\
    \ number = 1; i < sortedNumbers.length; ++i) {\n\t\tconst current: number = sortedNumbers[i];\n\
    \t\tconst next: number = sortedNumbers[i - 1];\n\t\tconst ratio = (next - current)\
    \ / current;\n\t\tif (ratio < closest[0]) {\n\t\t\tclosest[0] = ratio;\n\t\t\t\
    closestIndex = i;\n\t\t}\n\t}\n\treturn [sortedNumbers[closestIndex], sortedNumbers[0]];\n\
    }\n", "\tlet best_match = numbers[0];\n\tlet best_index = numbers.indexOf(best_match);\n\
    \tlet best_diff = Math.abs(best_match - numbers[best_index]);\n\tfor (let i =\
    \ 1; i < numbers.length; i++) {\n\t\tlet diff = numbers[i] - numbers[best_index];\n\
    \t\tif (diff < best_diff) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_match = numbers[i];\n\
    \t\t\tbest_index = i;\n\t\t}\n\t}\n\treturn [best_match, best_index];\n}\n", " \
    \   let minDistance = 0;\n    let closestPair = [null, null];\n    \n    for (let\
    \ i = 0; i < numbers.length; ++i) {\n        let distance = Number.MAX_VALUE;\n\
    \        let closestIndex = -1;\n        \n        for (let j = 0; j < numbers.length;\
    \ ++j) {\n            if (i != j && numbers[j] > numbers[i]) {\n             \
    \   let distance = Math.hypot(numbers[i] - numbers[j], numbers[i] - numbers[j]);\n\
    \                if (distance < distance) {\n                    closestIndex\
    \ = j;\n                }\n            }\n        }\n        if (closestIndex\
    \ != -1) {\n            closestPair = [numbers[i], numbers[closestIndex]];\n \
    \       }\n    }\n    \n    return [closestPair[0], closestPair[1]];\n}\n</cell>\n\
    <text>\nPutting it all together in a function\n\n</text>\n<cell>", "\tvar min_diff\
    \ = Number.MAX_VALUE;\n\tvar result: number[];\n\tnumbers.sort();\n\n\tfor (var\
    \ i = 0; i < numbers.length; ++i) {\n\t\tvar num = numbers[i];\n\t\tvar diff =\
    \ Math.abs(num - numbers[i + 1]);\n\t\tif (diff < min_diff) {\n\t\t\tmin_diff\
    \ = diff;\n\t\t\tresult = num;\n\t\t}\n\t}\n\n\treturn result;\n}\n", "    const\
    \ sorted_numbers = numbers.slice().sort((a, b) => a - b);\n    let index = -1;\n\
    \    const min_value = sorted_numbers[0];\n    const max_value = sorted_numbers[0];\n\
    \    for (let i = 1; i < sorted_numbers.length; i++) {\n        if (sorted_numbers[i]\
    \ === min_value) continue;\n        if (sorted_numbers[i] === max_value) break;\n\
    \        const difference = sorted_numbers[i] - min_value;\n        if (difference\
    \ < max_value - min_value) {\n            max_value = sorted_numbers[i];\n   \
    \         index = i;\n        } else {\n            min_value = sorted_numbers[i];\n\
    \        }\n    }\n    return [sorted_numbers[index], sorted_numbers[index]];\n\
    }", "  if (numbers.length < 2) {\n    throw new Error(\"Cannot find closest two\
    \ numbers when the first number has only 1 value.\");\n  }\n  const [minVal, maxVal]\
    \ = numbers;\n  let midVal = numbers[Math.floor(numbers.length / 2)];\n  if (minVal\
    \ >= maxVal) {\n    throw new Error(\"Minimum value cannot be greater than maximum\
    \ value.\");\n  }\n  if (maxVal - minVal < Number.EPSILON) {\n    throw new Error(\"\
    The difference between the minimum and the maximum cannot be less than 0.\");\n\
    \  }\n  if (minVal - midVal < Number.EPSILON) {\n    throw new Error(\"The difference\
    \ between midVal and the minimum cannot be less than 0.\");\n  }\n  if (maxVal\
    \ - midVal > Number.EPSILON) {\n    throw new Error(\"The difference between midVal\
    \ and the maximum cannot be greater than 0.\");\n  }\n  return [midVal, find_closest_elements(numbers.filter((n)\
    \ => n !== midVal))[0]];\n}\n", "\tif (numbers.length < 2) {\n\t\treturn [numbers[0],\
    \ numbers[0]];\n\t}\n\n\tlet smallest_difference = numbers[0];\n\tlet second_smallest_difference\
    \ = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\tconst difference\
    \ = numbers[i] - numbers[0];\n\t\tif (Math.abs(difference) < Math.abs(smallest_difference))\
    \ {\n\t\t\tsecond_smallest_difference = smallest_difference;\n\t\t\tsmallest_difference\
    \ = difference;\n\t\t} else if (Math.abs(difference) < Math.abs(second_smallest_difference))\
    \ {\n\t\t\tsecond_smallest_difference = difference;\n\t\t} else {\n\t\t\treturn\
    \ [numbers[i], numbers[0]];\n\t\t}\n\t}\n\treturn [numbers[0], numbers[0]];\n\
    }\n", "\tnumbers.sort((a, b) => a - b)\n\tif (numbers.length < 2) return [numbers[0],\
    \ numbers[0]]\n\tif (numbers[0] == numbers[1]) return [numbers[0], numbers[0]]\n\
    \tlet [first, second] = numbers\n\tlet closest = [numbers[0], numbers[0]]\n\t\
    let closest_index = 0\n\tlet closest_distance = numbers[0]\n\tlet index = numbers.length\
    \ - 1\n\twhile (index >= 0) {\n\t\tconst currentDistance = Math.abs(first - numbers[index])\n\
    \t\tif (currentDistance < closest_distance) {\n\t\t\tclosest_distance = currentDistance\n\
    \t\t\tclosest = numbers[index]\n\t\t\tclosest_index = index\n\t\t}\n\t\tindex--\n\
    \t}\n\tconst [secondClosest, thirdClosest] = find_closest_elements(numbers.slice(closest_index\
    \ + 1))\n\treturn [\n\t\tfirst,\n\t\tclosest,\n\t\tsecond,\n\t\tsecondClosest,\n\
    \t\tthirdClosest,\n\t]\n}\n", "\tconst minDiff = Math.abs(numbers[0] - numbers[1]);\n\
    \tconst closestTo = [numbers[0], numbers[1]];\n\n\tfor (let i = 2; i < numbers.length;\
    \ i++) {\n\t\tconst diff = Math.abs(numbers[i] - numbers[i - 1]);\n\n\t\tif (diff\
    \ < minDiff) {\n\t\t\tminDiff = diff;\n\t\t\tclosestTo = [numbers[i], numbers[i\
    \ - 1]];\n\t\t} else if (diff === minDiff) {\n\t\t\tclosestTo[1] = numbers[i];\n\
    \t\t}\n\t}\n\n\treturn closestTo;\n}\n", "\tif (numbers.length < 2) {\n\t\treturn\
    \ [numbers[0], numbers[0]];\n\t}\n\tvar min = numbers[0];\n\tvar max = numbers[0];\n\
    \tfor (var i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i] < min) {\n\t\t\
    \tmin = numbers[i];\n\t\t}\n\t\tif (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\
    \t\t}\n\t}\n\treturn [min, max];\n}\n", "    let min_diff = Infinity;\n    let\
    \ max_diff = -Infinity;\n    for (let i = 0; i < numbers.length; i++) {\n    \
    \    const diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n\
    \            min_diff = diff;\n        }\n        if (diff > max_diff) {\n   \
    \         max_diff = diff;\n        }\n    }\n    return [numbers[numbers.length\
    \ - 1], numbers[numbers.length - 1], min_diff, max_diff];\n}\n", "\tlet min1 =\
    \ Number.MAX_VALUE;\n\tlet min2 = Number.MAX_VALUE;\n\tlet closest1 = Number.MAX_VALUE;\n\
    \tlet closest2 = Number.MAX_VALUE;\n\tlet index1 = 0;\n\tlet index2 = 0;\n\n\t\
    for (let i = 0; i < numbers.length; i += 1) {\n\t\tconst num = numbers[i];\n\n\
    \t\tif (num < min1) {\n\t\t\tindex1 = i;\n\t\t\tmin1 = num;\n\t\t}\n\t\tif (num\
    \ > min2) {\n\t\t\tindex2 = i;\n\t\t\tmin2 = num;\n\t\t}\n\n\t\tif (Math.abs(num\
    \ - closest1) < Math.abs(num - closest2)) {\n\t\t\tclosest1 = num;\n\t\t}\n\t\t\
    if (Math.abs(num - closest2) < Math.abs(num - closest1)) {\n\t\t\tclosest2 = num;\n\
    \t\t}\n\t}\n\n\tif (closest1 === Number.MAX_VALUE) {\n\t\tclosest1 = min1;\n\t\
    }\n\tif (closest2 === Number.MAX_VALUE) {\n\t\tclosest2 = min2;\n\t}\n\n\treturn\
    \ [numbers[index1], numbers[index2]];\n}\n", "  for (var i = 0; i < numbers.length\
    \ - 1; i++) {\n    if (numbers[i] > numbers[i + 1]) {\n      numbers[i - 1], numbers[i\
    \ + 1] = numbers[i + 1], numbers[i - 1];\n    }\n  }\n  return numbers;\n}\n",
  "\tlet minA = numbers[0];\n\tlet minB = numbers[1];\n\tlet minDist = Number.MAX_VALUE;\n\
    \tfor (let i = 2; i < numbers.length; i++) {\n\t\tlet d = Math.abs(minA * numbers[i]\
    \ + minB - numbers[i - 1]);\n\t\tif (d < minDist) {\n\t\t\tminA = numbers[i];\n\
    \t\t\tminB = numbers[i - 1];\n\t\t\tminDist = d;\n\t\t}\n\t}\n\treturn [minA,\
    \ minB];\n}\n", "  const distance = Math.abs(numbers[1] - numbers[0]);\n  const\
    \ lower = numbers[1] < numbers[0] ? numbers[0] : numbers[1];\n  const upper =\
    \ numbers[1] > numbers[0] ? numbers[0] : numbers[1];\n  return [lower, upper];\n\
    }\n", "\tlet smallest: number;\n\tlet largest: number;\n\n\tif (numbers.length\
    \ === 1) {\n\t\treturn [numbers[0], numbers[0]];\n\t}\n\n\tnumbers = numbers.slice();\n\
    \tlet len = numbers.length;\n\tif (len < 2) {\n\t\treturn numbers;\n\t}\n\tnumbers.sort((a,\
    \ b) => {\n\t\treturn a - b;\n\t});\n\n\tfor (let i = 0; i < len - 1; i += 1)\
    \ {\n\t\tsmallest = numbers[i];\n\t\tlargest = numbers[i + 1];\n\t\tif (smallest\
    \ > largest) {\n\t\t\tconst temp = largest;\n\t\t\tlargest = smallest;\n\t\t\t\
    smallest = temp;\n\t\t}\n\t\tif (largest - smallest === 1) {\n\t\t\tnumbers.splice(i,\
    \ 1);\n\t\t\ti -= 1;\n\t\t} else {\n\t\t\tnumbers.splice(i, 0, smallest);\n\t\t\
    \tnumbers.splice(i + 1, 0, largest);\n\t\t}\n\t}\n\n\treturn numbers;\n}\n", " \
    \ if (numbers.length < 2) {\n    throw new Error(\"find_closest_elements: Array\
    \ must have at least two elements\")\n  }\n  const min_number = numbers[0]\n \
    \ const max_number = numbers[0]\n  for (let i = 1; i < numbers.length; i++) {\n\
    \    if (numbers[i] - min_number > max_number - numbers[i]) {\n      max_number\
    \ = numbers[i]\n    } else if (numbers[i] - min_number < min_number - numbers[i])\
    \ {\n      min_number = numbers[i]\n    }\n  }\n  return [min_number, max_number]\n\
    }\n", "    // If two numbers are the same, return one\n    if (numbers.length\
    \ <= 1) {\n        return numbers;\n    }\n    numbers.sort((a, b) => {\n    \
    \    if (Math.abs(a) < Math.abs(b)) {\n            return -1;\n        }\n   \
    \     if (Math.abs(a) > Math.abs(b)) {\n            return 1;\n        }\n   \
    \     return 0;\n    });\n    return numbers.slice(0, 2);\n}\n", "\t// First,\
    \ sort the array from smallest to largest.\n\tnumbers.sort(function (a, b) { return\
    \ a - b; });\n\n\t// Now, go through and find where we're at.\n\tvar index: number;\n\
    \tvar closest: number;\n\tvar closest2: number;\n\n\tfor (i = 0; i < numbers.length\
    \ - 1; i++) {\n\t\tif (numbers[i] <= numbers[i + 1]) {\n\t\t\tindex = i;\n\t\t\
    \tbreak;\n\t\t}\n\t}\n\n\tif (index === numbers.length - 1) {\n\t\treturn [numbers[index],\
    \ numbers[index]];\n\t}\n\n\tif (index !== 0) {\n\t\tclosest = numbers[index];\n\
    \t\tclosest2 = numbers[index - 1];\n\t} else {\n\t\tclosest = numbers[0];\n\t\t\
    closest2 = numbers[0];\n\t}\n\n\tvar min2_index = index - 1;\n\n\tfor (j = index\
    \ - 1; j > 0; j--) {\n\t\tif (numbers[j] <= closest) {\n\t\t\tmin2_index = j;\n\
    \t\t\tclosest = numbers[j];\n\t\t}\n\t}\n\n\tvar min_index = index;\n\n\tif (min2_index\
    \ === numbers.length - 1) {\n\t\treturn [numbers[min_index], numbers[min_index]];\n\
    \t}\n\n\tvar min2_closest = numbers[min2_index];\n\n\tif (min_index === min2_index)\
    \ {\n\t\tif (min2_closest > closest) {\n\t\t\treturn [numbers[min_index], numbers[min_index]];\n\
    \t\t} else {\n\t\t\treturn [numbers[min2_index], numbers[min2_index]];\n\t\t}\n\
    \t}\n\n\tvar min2_closest2 = numbers[min2_index - 1];\n\n\tif (min_index === min2_index\
    \ - 1) {\n\t\treturn [numbers[min_index], numbers[min_index]];\n\t} else if (min2_closest2\
    \ < closest2) {\n\t\treturn [numbers[min_index], numbers[min_index]];\n\t} else\
    \ {\n\t\treturn [numbers[min2_index], numbers[min2_index]];\n\t}\n}\n", "  let\
    \ smallest = numbers[0];\n  let largest = numbers[0];\n\n  for (let i = 1; i <\
    \ numbers.length; i++) {\n    if (numbers[i] < smallest || smallest === undefined)\
    \ {\n      smallest = numbers[i];\n    }\n\n    if (numbers[i] > largest || largest\
    \ === undefined) {\n      largest = numbers[i];\n    }\n  }\n\n  return [smallest,\
    \ largest];\n}\n", "    const min_num = Math.min.apply(null, numbers);\n    const\
    \ max_num = Math.max.apply(null, numbers);\n    const min_val = numbers.filter(v\
    \ => v === min_num)[0];\n    const max_val = numbers.filter(v => v === max_num)[0];\n\
    \    const delta = max_val - min_val;\n    return [min_val + delta * Math.floor(Math.random()\
    \ * Math.ceil(delta / 2)), min_val + delta * Math.floor(Math.random() * Math.ceil(delta\
    \ / 2))];\n}\n", "  let first_val = numbers[0];\n  let best_index = numbers.length;\n\
    \  for (let i = 1; i < numbers.length; i++) {\n    let delta = numbers[i] - first_val;\n\
    \    if (delta <= 0) {\n      best_index = i;\n      first_val = numbers[i];\n\
    \    }\n  }\n  return [first_val, numbers[best_index]];\n}\n", "\tconst sortedNumbers\
    \ = numbers.sort((a, b) => a - b);\n\tconst closestNumbersIdx = [sortedNumbers[0],\
    \ sortedNumbers[sortedNumbers.length - 1]];\n\treturn [\n\t\tsortedNumbers.reduce((acc,\
    \ value, idx) => {\n\t\t\tif (value === closestNumbersIdx[0]) {\n\t\t\t\tif (idx\
    \ === sortedNumbers.length - 1) {\n\t\t\t\t\treturn acc;\n\t\t\t\t}\n\t\t\t\t\
    return [value, sortedNumbers[idx + 1]];\n\t\t\t}\n\t\t\tif (value === closestNumbersIdx[1])\
    \ {\n\t\t\t\treturn acc;\n\t\t\t}\n\t\t\treturn [value, value];\n\t\t}),\n\t];\n\
    }\n", "    let sorted: number[] = numbers.slice().sort((a, b) => a - b);\n   \
    \ if (sorted.length <= 2) {\n        return [sorted[0], sorted[1]];\n    }\n\n\
    \    let index = sorted.length - 1;\n    let middle = Math.floor(index / 2);\n\
    \n    let smallerIsCloser = numbers[index] - sorted[middle] > sorted[index] -\
    \ numbers[middle];\n    let largerIsCloser = sorted[index] - numbers[middle] >\
    \ numbers[index] - sorted[middle];\n\n    if (smallerIsCloser) {\n        return\
    \ [sorted[middle], sorted[index]];\n    } else if (largerIsCloser) {\n       \
    \ return [sorted[index], sorted[middle]];\n    } else {\n        return [sorted[index],\
    \ sorted[index]];\n    }\n}\n", "  numbers.sort((a, b) => Math.abs(a) - Math.abs(b));\n\
    \  let lowestDifference;\n  for (const value of numbers) {\n    const difference\
    \ = Math.abs(value - numbers[0]);\n    if (difference < lowestDifference || (lowestDifference\
    \ === 0 && difference > 0)) {\n      lowestDifference = difference;\n    }\n \
    \ }\n  return [numbers[numbers.length - 1], numbers[0]];\n}\n", "  let smallest\
    \ = numbers[0];\n  let largest = numbers[0];\n  for (let i = 1; i < numbers.length;\
    \ i++) {\n    if (numbers[i] > largest) {\n      largest = numbers[i];\n    }\
    \ else if (numbers[i] < smallest) {\n      smallest = numbers[i];\n    }\n  }\n\
    \  return [smallest, largest];\n}\n", "    let result: [number, number][] = []\n\
    \    numbers.forEach((number) => {\n        result.push([\n            numbers[(numbers.indexOf(number)\
    \ - numbers.indexOf(Math.min(number, numbers[numbers.indexOf(number) - 1]))) +\
    \ 1],\n            number\n        ])\n    })\n    return result[0] === undefined\
    \ ? result[1] : result[0]\n}\n</code>\n<|/ a tags=arrays,javascript,jquery |>\n\
    <| a |>\n<code>\nvar array = [\n    { \"name\": \"Kate\", \"age\": 34 },\n   \
    \ { \"name\": \"John\", \"age\": 31 },\n    { \"name\": \"John\", \"age\": 32\
    \ }\n];\n\nvar max = 0;\nvar result = [];\n\narray.map(function(e){\n    if(e.age\
    \ > max){\n        max = e.age;\n        result = [e];\n    }else if(e.age ==\
    \ max){\n        result.push(e);\n    }\n})\n\nconsole.log(result);\n</code>\n\
    <|/ a tags=arrays,javascript,jquery dscore=2 |>\n<| c |>\nCan you explain how\
    \ your code is different than the accepted answer? Why should the OP try this\
    \ way?\n<|/ c |>\n<| a tags=arrays,javascript,jquery |>\nJust keep track of the\
    \ max element in the loop:\n\n<code>\nconst arr = [\n  { \"name\": \"Kate\", \"\
    age\": 34 },\n  { \"name\": \"John\", \"age\": 31 },\n  { \"name\": \"John\",\
    \ \"age\": 32 }\n];\n\nlet max = null;\n\nfor (const item of arr) {\n  if (item.age\
    \ > max) {\n    max = item.age;\n  }\n}\n\nconsole.log(max);</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 tags=arrays,javascript,jquery |>\nYou might consider sorting\
    \ the array first and then iterating through to find the max\n<code>\nvar array\
    \ = [\n    { \"name\": \"Kate\", \"age\": 34 },\n    { \"name\": \"John\", \"\
    age\": 31 },\n    { \"name\": \"John\", \"age\": 32 }\n];\n\narray.sort(function(a,\
    \ b) {\n    return a.age - b.age;\n});\n\nvar maxAge = array[0].age;\n\nfor (i\
    \ = 0; i < array.length; i++) {\n    if (array[i].age > maxAge) {\n        maxAge\
    \ = array[i].age;\n    }\n}\n\nconsole.log(maxAge);\n</code>\n<|/ a |>\n<| c |>\n\
    Please add some explanation to your code. Just dumping code isn't very helpful.\n\
    <|/ c |>\n<| a |>\nI made a generic function for this. This might help you\n<code>",
  "    const sorted = numbers.slice();\n    sorted.sort((a, b) => {\n        return\
    \ a - b;\n    });\n    const results: number[] = [];\n    let low = 0;\n    let\
    \ high = sorted.length - 1;\n    while (high - low > 1) {\n        let mid = Math.floor((low\
    \ + high) / 2);\n        if (sorted[mid] == sorted[mid]) {\n            // If\
    \ an element equals itself then try the other side of the array.\n           \
    \ high = mid;\n        } else {\n            low = mid;\n        }\n    }\n  \
    \  results.push([sorted[low], sorted[high]]);\n    return results;\n}\n", "\t\
    if (numbers.length < 2) {\n\t\tthrow Error(\"Numbers given to find_closest_elements\
    \ must contain at least two elements!\");\n\t}\n\tlet max_difference = 0;\n\t\
    let min_difference = 10000000;\n\tlet [smallest, largest] = numbers;\n\tlet closest_difference\
    \ = largest;\n\tfor (let i = numbers.length - 1; i > 0; i--) {\n\t\tconst difference\
    \ = Math.abs(numbers[i] - smallest);\n\t\tif (difference < closest_difference\
    \ || difference === 0) {\n\t\t\tclosest_difference = difference;\n\t\t\tmin_difference\
    \ = difference;\n\t\t\t[smallest, largest] = [numbers[i], numbers[i]];\n\t\t}\
    \ else if (difference === max_difference) {\n\t\t\tlargest = closest_difference;\n\
    \t\t} else if (difference === min_difference) {\n\t\t\tsmallest = closest_difference;\n\
    \t\t} else {\n\t\t\tlet new_min_difference = Math.min(difference, min_difference);\n\
    \t\t\tlet new_max_difference = Math.max(difference, max_difference);\n\t\t\tif\
    \ (new_min_difference > max_difference && new_max_difference > min_difference)\
    \ {\n\t\t\t\t[smallest, largest] = [numbers[i], numbers[i]];\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn [smallest, largest];\n}\n", "    if (numbers.length < 2)\n     \
    \   return numbers;\n    let [minA, minB] = numbers.map(v => [Math.ceil(v), v]);\n\
    \    let [maxA, maxB] = numbers.map(v => [v, v]);\n    let result = [];\n    while\
    \ (minA < maxA) {\n        let a = minA++;\n        let b = minB++;\n        let\
    \ m = (b - a) / (maxA - minA);\n        if (a < maxA && b > minB && m > 0) {\n\
    \            result.push(b);\n            result.push(a + m);\n        }\n   \
    \     if (b < maxB && a > minA && m < 0) {\n            result.push(a);\n    \
    \        result.push(b - m);\n        }\n    }\n    if (result.length < 2)\n \
    \       return result;\n    return [Math.ceil(Math.max(...result)), Math.min(...result)];\n\
    }\n", "\tif (numbers.length < 2) return [numbers[0], numbers[0]]\n\tif (numbers.length\
    \ == 2) return [numbers[0], numbers[1]]\n\tlet closest = numbers[0]\n\tlet closest\
    \ = numbers[1]\n\tfor (let i = 2; i < numbers.length; i++) {\n\t\tconst candidate\
    \ = numbers[i]\n\t\tconst d = Math.abs(closest - candidate)\n\t\tif (d < Math.abs(closest\
    \ - candidate)) closest = candidate\n\t}\n\treturn [closest, closest]\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
