name: HumanEval_34_unique
language: ts
prompt: "//Return sorted unique elements in an array\n// >>> unique([5, 3, 5, 2, 3,\
  \ 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\nfunction unique(l: number[]): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = unique;\n  assert.deepEqual(candidate([5, 3, 5, 2,\
  \ 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);\n}\n\ntest();"
completions: ["  const u: number[] = [];\n  for (let i = 0; i < l.length; ++i) {\n\
    \    if (u.indexOf(l[i]) === -1) u.push(l[i]);\n  }\n  return u;\n}\n", "    const\
    \ s: number[] = [];\n    for (let i = 0; i< l.length; i++) {\n        if (s.indexOf(l[i])\
    \ < 0) {\n            s.push(l[i]);\n        }\n    }\n    return s;\n}\n", " \
    \ return l.filter((v, i, a) => {\n    return a.indexOf(v) === i\n  })\n}\n", "\t\
    let a: number[] = [];\n\tlet hash: Map<string, number> = new Map();\n\tfor (let\
    \ n of l) {\n\t\tif (!hash.has(n)) {\n\t\t\ta.push(n);\n\t\t\thash.set(n, a.length\
    \ - 1);\n\t\t}\n\t}\n\treturn a;\n}\n", "    const s: Set<number> = new Set();\n\
    \    l.forEach(n => s.add(n));\n    return [...s].sort((a: number, b: number)\
    \ => a - b);\n}\n", "  return [...new Set(l)];\n}\n", "    let x: number[] = [];\n\
    \    l.forEach((a) => {\n        if (x.indexOf(a) === -1) x.push(a);\n    });\n\
    \    return x;\n}\n</code>\n<|/ a tags=arrays,javascript,sorting |>\n<| a dscore=1\
    \ tags=arrays,javascript,sorting |>\nTry this one for me\n<code>\nconst sortedUnique\
    \ = arr => {\n    const sortedArr = arr.slice();\n    sortedArr.sort();\n    return\
    \ uniqueSort(sortedArr)\n}\n\nconst uniqueSort = (arr) => {\n    const result\
    \ = [];\n    for (let i = 0; i < arr.length; i++) {\n        const elem = arr[i];\n\
    \        let exist = false;\n        for (let j = 0; j < result.length; j++) {\n\
    \            if (result[j].indexOf(elem) !== -1) {\n                exist = true;\n\
    \                break;\n            }\n        }\n        if (!exist) {\n   \
    \         result.push(elem);\n        }\n    }\n    return result;\n}\n\nconsole.log(uniqueSort([5,\
    \ 2, 5, 5, 5, 5, 3, 9, 0, 123, 123]));", "    const c: Set<number> = new Set()\n\
    \    for (let i = 0; i < l.length; i++) {\n        if (!c.has(+l[i])) {\n    \
    \        c.add(+l[i])\n        }\n    }\n    return Array.from(c.values())\n}\n",
  "    var a = [], l = l.sort(function (a, b) { return a - b; }), i, v;\n    for (i\
    \ = 0; i < l.length; i++) {\n        if (v = (v = l[i])[i ? 'next' : 'prev'])\
    \ if (a === v) {\n            a.push(v);\n        } else break;\n    }\n    return\
    \ a;\n}", "    const a: number[] = [];\n    for (let i = 0; i < l.length; i++)\
    \ {\n        if (a.indexOf(l[i]) === -1) a.push(l[i]);\n    }\n    return a;\n\
    }\n", "  const u: number[] = []\n  for (let i = 0; i < l.length; i++) {\n    if\
    \ (u.indexOf(l[i]) < 0) {\n      u.push(l[i])\n    }\n  }\n  return u\n}\n</code>\n\
    <|/ a tags=sorting,arrays,javascript |>\n<| c |>\nAgreed! I wanted to do that\
    \ but couldn't. I don't know why. I think that's because I am a newbie at programming.\
    \ Thanks anyway!\n<|/ c |>\n<| c |>\nNo worries, I appreciate you taking the time\
    \ to come up with the working solution.\n<|/ c |>\n<| a dscore=1 |>\nIt can be\
    \ done using array.map()\n\n<code>\nconst arr = [5, 3, 2, 3, 9, 0, 123]\n\nconst\
    \ res = arr.map(el => arr.indexOf(el) !== arr.lastIndexOf(el) ? el : null).filter(el\
    \ => el)\n\nconsole.log(res)</code>\n<|/ a tags=sorting,arrays,javascript |>\n\
    <| c |>\n`.reduce((r, c) => {\n  return r.indexOf(c) > -1 ? r.concat(c) : r;\n\
    }, [])`\n<|/ c |>\n<| a |>\nAnother way to do it :\n\n<code>\nconst input = [5,\
    \ 3, 2, 3, 9, 0, 123];\nconst output = input.filter(x => {\n  const index = input.indexOf(x);\n\
    \  return index !== input.lastIndexOf(x);\n});\nconsole.log(output);</code>\n\n\
    EDIT:\nIt seems that there are some problems with this solution, so I've made\
    \ this new one:\n\n<code>\nconst input = [5, 3, 2, 3, 9, 0, 123];\nconst output\
    \ = input.filter((x, i, arr) => {\n  const index = arr.indexOf(x);\n  return index\
    \ !== arr.lastIndexOf(x);\n});\nconsole.log(output);</code>\n<|/ a dscore=1 tags=sorting,arrays,javascript\
    \ |>\n<| c |>\nThis doesn't work if the array has a unique value, which it does\
    \ in this case.\n<|/ c |>\n<| c |>\nIt works, I've added a second snippet, maybe\
    \ it's an issue with my browser\n<|/ c |>\n<| c |>\nYes, it works with your second\
    \ snippet too, just not with my original one. I don't know why.\n<|/ c |>\n<|\
    \ c |>\nI guess it's because of your browser, I'm using chrome and it works fine\n\
    <|/ c |>\n<| c |>\nYeah I'm using the latest version of Chrome, weird\n<|/ c |>\n\
    <| a tags=sorting,arrays,javascript |>\n<code>\nconst arr = [5, 3, 2, 3, 9, 0,\
    \ 123];\n\n", "    const set = new Set(l);\n    return [...set];\n}\n</code>\n\
    <|/ a tags=typescript,javascript |>\n<| c |>\nThis works, but it only returns\
    \ unique elements after sorting them, not unique elements from the original array.\
    \ `[2, 1, 3, 3, 5, 6, 6].unique()` returns `[2, 3, 6, 6]` - not `[1, 2, 3, 5,\
    \ 6]`.\n<|/ c |>\n<| c |>\nThanks for pointing out. I forgot to add one extra\
    \ step. I updated the answer\n<|/ c |>\n<| c |>\n`new Set([...l, ...l])` is probably\
    \ better for performance (as opposed to `[...new Set(l)]`) as it avoids a spread\
    \ operation.\n<|/ c |>\n<| a dscore=4 |>\nIn case you don't want to use ES6 syntax\
    \ or don't want to use lodash or underscore, you can do the following:\n<code>",
  "  const a = new Set<number>();\n  for (const n of l) {\n    a.add(n);\n  }\n  return\
    \ Array.from(a).sort();\n}\n", "\tlet ret: number[] = new Array(l.length);\n\t\
    let keys = new Uint32Array(l.length);\n\tfor(let i=0,n=l.length; i<n; i++) {\n\
    \t\tlet key = l[i];\n\t\tlet idx = keys[key];\n\t\tif(idx === undefined) {\n\t\
    \t\tidx = keys[key] = i;\n\t\t}\n\t\telse {\n\t\t\tidx = (idx<<1)|(i+1);\n\t\t\
    }\n\t\tret[idx] = key;\n\t}\n\treturn ret;\n}\n", "\tconst a: number[] = [];\n\
    \tconst n: number[] = l;\n\tfor (let i = 0; i < n.length; i++) {\n\t\tif (a.indexOf(n[i])\
    \ < 0) {\n\t\t\ta.push(n[i]);\n\t\t}\n\t}\n\treturn a;\n}\n", "  const a: number[]\
    \ = [];\n  const o: {[k: number]: boolean} = {};\n  for (const x of l) {\n   \
    \ if (x === null) continue;\n    if (o[x] !== true) o[x] = true;\n    else {\n\
    \      a.push(x);\n      delete o[x];\n    }\n  }\n  return a;\n}\n", "\treturn\
    \ l.filter((l, i, a) => a.indexOf(l) === i).sort((a: number, b: number) => a -\
    \ b);\n}\n", "  return l.filter(function(elem, pos, self) {\n    return self.indexOf(elem)\
    \ === pos;\n  }).sort(function(a, b) {\n    return a - b;\n  });\n}", "    const\
    \ result: number[] = [];\n    for (let i = 0; i < l.length; i++) {\n        if\
    \ (result.indexOf(l[i]) == -1) result.push(l[i]);\n    }\n    return result;\n\
    }\n", "  const u: number[] = [],\n    i,\n    len = l.length;\n  for (i = 0; i\
    \ < len; i++) {\n    if (u.indexOf(l[i]) === -1) {\n      u.push(l[i]);\n    }\n\
    \  }\n  return u;\n}", "    var u: number[] = [];\n\n    for (var i = 0, n = l.length;\
    \ i < n; i++) {\n        if (u.indexOf(+l[i]) === -1)\n            u.push(+l[i]);\n\
    \    }\n    return u;\n}\n", "  const a: number[] = []\n  for (let i = 0; i <\
    \ l.length; i++) if (a.indexOf(l[i]) == -1) a.push(l[i])\n  return a\n}\n", " \
    \ return l.filter((a,i,a2) => {\n    return i==a2.findIndex(b => a===b);\n  });\n\
    }\n", "\tconst a: number[] = [];\n\tfor (let i = 0; i < l.length; i++) {\n\t\t\
    const val = l[i];\n\t\tif (a.indexOf(val) === -1) {\n\t\t\ta.push(val);\n\t\t\
    }\n\t}\n\treturn a;\n}", "  return l.filter((x, i, l) => l.indexOf(x) === i).sort((a,\
    \ b) => a - b).filter(x => !isNaN(x));\n}\n", "  if (l.length === 0) return l;\n\
    \  const u: number[] = [];\n  for (let i = 0, n = l.length; i < n; ++i) {\n  \
    \  if (u.indexOf(+l[i]) == -1) u.push(+l[i]);\n  }\n  return u;\n}\n", "    return\
    \ Array.from(new Set(l));\n}\n", "  return l.filter((e, i, a) => a.indexOf(e)\
    \ === i);\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\nconst uniqueArr= ([...new\
    \ Set(arr)] as any[]);\n</code>\n<|/ a tags=javascript,typescript |>\n<| c |>\n\
    This is an interesting solution; but why is it not working for me on Chrome Version\
    \ 73.0.3683.103 ? https://codesandbox.io/s/epic-sun-jk4uf?fontsize=14\n<|/ c |>\n\
    <| c |>\n`new Set([...new Set([...new Set(arr)])])` would be even better\n<|/\
    \ c |>\n<| c |>\n`arr` is an array, so I changed `...new Set([...new Set(arr)])`\
    \ to `...new Set(arr)` and the problem persists.\n<|/ c |>\n<| a dscore=1 |>\n\
    The best way is to use sort and check for duplicates. However, it can be done\
    \ in linear time complexity.\n\n<code>", "  let i: number[] = [];\n  for (let\
    \ j = 0; j < l.length; j++) {\n    if (i in l && l[j] !== i) i.push(l[j]);\n \
    \ }\n  return i;\n}\n", "\treturn l.filter((v, i, a) => a.indexOf(v) === i);\n\
    }\n", "  const ret: number[] = [];\n  for (let i = 0, j = l.length; i < j; i++)\
    \ {\n    if (~ret.indexOf(l[i])) continue;\n    ret.push(l[i]);\n  }\n  return\
    \ ret;\n}\n", "  const set = new Set<number>();\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (!set.has(l[i])) {\n      set.add(l[i]);\n    }\n  }\n  return\
    \ Array.from(set);\n}\n", "  const seen = new Set<number>();\n  for (const n of\
    \ l) {\n    if (seen.has(n)) {\n      continue;\n    }\n    seen.add(n);\n  }\n\
    \  return Array.from(seen);\n}\n", "  var u: number[] = [];\n  var a: number[]\
    \ = [];\n  for (var i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i]) === -1)\
    \ {\n      u.push(l[i]);\n      a.push(l[i]);\n    }\n  }\n  return a;\n}\n",
  "\treturn l.filter((value, index, self) => self.indexOf(value) === index);\n}\n",
  "  const a: number[] = [];\n  for (const item of l) if (a.indexOf(item) < 0) a.push(item);\n\
    \  return a;\n}\n", "  return l.sort((a: number, b: number) => a - b).filter((value,\
    \ index, self) => self.indexOf(value) === index);\n}\n", "\tlet s: any[] = [];\n\
    \tfor(let i in l) {\n\t\tfor(let e in l) {\n\t\t\tif(e == i) {\n\t\t\t\tcontinue;\n\
    \t\t\t}\n\t\t\tif(l[e] == l[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts.push(l[i]);\n\
    \t\t}\n\t}\n\treturn s;\n}\n</code>\n<|/ a tags=java,algorithm,arrays dscore=0\
    \ |>\n<| c |>\nThank you for your solution. But, this is my task:\nhttps://imgur.com/a/jtYTcQS\n\
    <|/ c |>\n<| c |>\nUpdated the answer with your requirements\n<|/ c |>\n<| a tags=java,algorithm,arrays\
    \ |>\nAnother approach would be to sort the array and then use 2 pointers to solve\
    \ this problem using a O(nlogn) approach.\n<|/ a dscore=0 |>\n<| a |>\nThis is\
    \ a classic example for the selection algorithm, which can be easily solved using\
    \ recursion.\n<code>\npublic static int[] selection(int[] arr, int k) {\n    if\
    \ (k == 0) {\n        return new int[0];\n    }\n    \n    int[] answer = new\
    \ int[k];\n    answer[0] = 0;\n    answer[k-1] = 0;\n    \n    int i, j;\n   \
    \ for (i = 0; i < k-1; i++) {\n        for (j = 0; j < i; j++) {\n           \
    \ if (arr[j] > arr[i]) {\n                answer[i] = arr[i];\n              \
    \  i++;\n                break;\n            }\n        }\n        answer[i] =\
    \ arr[i];\n    }\n    return answer;\n}\n</code>\n<|/ a dscore=0 tags=java,algorithm,arrays\
    \ |>\n<| a |>\nI did this in python to solve this question. Hope it helps.\n<code>\n\
    def kthLargest(A, k):\n    largest = sorted(A)\n    count = 0\n    idx = 0\n \
    \   for i in range(len(A)):\n        if count == 0:\n            count = 1\n \
    \           idx = i\n        if A[i] == largest[count-1]:\n            count +=\
    \ 1\n        else:\n            count = 0\n    if count < k:\n        raise Exception(\"\
    Sorry! Can't find that!\")\n    else:\n        return A[idx]\n</code>\n<|/ a dscore=0\
    \ tags=java,algorithm,arrays |>\n<| a tags=java,algorithm,arrays |>\n<code>\n\
    public class KthLargestElement {\npublic static void main(String[] args) {\n \
    \   int[] array = {10, 2, 3, 4, 5, 6, 7, 8};\n    System.out.println(kthLargest(array,\
    \ 3));\n}\n\npublic static Integer kthLargest(int[] A, int k) {\n    if (A.length\
    \ <= k) return Integer.valueOf(0);\n    int n = A.length;\n    Integer[] arr =\
    \ new Integer[n];\n", "    let r = [] as number[];\n    l.forEach(i => {\n   \
    \     if (r.indexOf(i) < 0) {\n            r.push(i);\n        }\n    });\n  \
    \  return r;\n}", "  const r: string[] = [];\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (r.indexOf(+l[i]) == -1) {\n      r.push(+l[i]);\n    }\n  }\n\
    \  return r;\n}\n", "  const o = new Array(l.length)\n  l.sort()\n  for (let i\
    \ = 0; i < l.length; i++) {\n    if (o.indexOf(l[i]) === -1) o[i] = l[i]\n  }\n\
    \  return o\n}\n", "  return sortUnique(uniqueSort(l));\n}\n", "  if (l.length\
    \ === 0) return [];\n\n  const sorted = l.slice().sort((a: number, b: number)\
    \ => a - b);\n\n  let result: number[] = [];\n  for (let i = 0; i < sorted.length\
    \ - 1; i++) {\n    if (sorted[i] === sorted[i + 1]) {\n      result.push(sorted[i\
    \ + 1]);\n      sorted.splice(i, 1);\n    }\n  }\n\n  return result;\n}\n", " \
    \ const a: number[] = [];\n  l.forEach((i) => !a.includes(i) ? a.push(i) : null);\n\
    \  return a;\n}\n", "    const a: number[] = [];\n    let found = false;\n\n \
    \   for (let i = 0; i < l.length; i++) {\n        let t = l[i];\n        if (!found\
    \ && t != i) {\n            a.push(i);\n            found = true;\n        }\n\
    \    }\n    return a;\n}\n", "  let r = [];\n  for (let i = 0; i < l.length; i++)\
    \ {\n    if (r.indexOf(l[i]) === -1) r.push(l[i]);\n  }\n  return r;\n}\n", " \
    \   return Array.from(new Set(l)).sort((a, b) => a - b).filter(n => !Number.isNaN(n));\n\
    }\n</code>\n<|/ a dscore=1 tags=sorting,arrays,javascript,algorithm |>\n<| c |>\n\
    The above method worked for me. Many thanks\n<|/ c |>\n<| a |>\nHere is an example\
    \ of how to do it using lodash/underscore and sortBy\n\n<code>\nconst items =\
    \ [\n  { \"name\": \"A\" },\n  { \"name\": \"B\" },\n  { \"name\": \"C\" },\n\
    \  { \"name\": \"D\" },\n  { \"name\": \"E\" }\n];\n\nconst unique = _.sortBy(_.uniq(items,\
    \ 'name'), 'name');\n\nconsole.log(unique);</code>\n<code>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\"\
    ></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/sort-by/1.2.2/sort-by.js\"\
    ></script></code>\n<|/ a dscore=1 tags=sorting,arrays,javascript,algorithm |>\n\
    <| a tags=sorting,arrays,javascript,algorithm |>\n<code>\nconst sorting = ([...values],\
    \ order = 'ascending') =>\n  values.reduce((acc, [k, v]) => {\n    acc[k] = v;\n\
    \    return acc;\n  }, {});\n", "    let s: number[] = [];\n\n    for (let i =\
    \ 0; i < l.length; i++) {\n        if (s.indexOf(l[i]) < 0) {\n            s.push(l[i]);\n\
    \        }\n    }\n\n    return s;\n}\n", "  const result: number[] = [];\n  const\
    \ seen: Map<number, boolean> = new Map();\n  for (let i = 0; i < l.length; i++)\
    \ {\n    const v = l[i];\n    if (seen.has(v)) {\n      continue;\n    }\n   \
    \ result.push(v);\n    seen.set(v, true);\n  }\n  return result;\n}\n", "  const\
    \ u = [];\n  l.forEach((x: number) => {\n    if (u.indexOf(x) == -1) {\n     \
    \ u.push(x);\n    }\n  });\n  return u;\n}\n", "  let m: number[] = [], i: number;\n\
    \  for (i = 0; i < l.length; i++) {\n    if (m.indexOf(+l[i]) === -1) m.push(+l[i]);\n\
    \  }\n  return m;\n}\n", "  let result: number[] = [];\n  for (let i = 0; i <\
    \ l.length; i++) {\n    if (result.indexOf(l[i]) === -1) {\n      result.push(l[i]);\n\
    \    }\n  }\n  return result;\n}\n", "\treturn [...new Set(l)];\n}\n", "    const\
    \ i: number[] = [];\n    for (let j = 0; j < l.length; j++) {\n        if (i.indexOf(l[j])\
    \ === -1) {\n            i.push(l[j]);\n        }\n    }\n    return i;\n}\n",
  "  let ns: number[] = [];\n  let i: number = 0;\n  for (let j = 0; j < l.length;\
    \ j++) {\n    if (ns[i] == l[j]) {\n      continue;\n    } else {\n      ns[i]\
    \ = l[j];\n    }\n    i++;\n  }\n  return ns.sort();\n}\n", "    return l.filter((a:\
    \ any) => !l.some(b => a === b));\n}\n", "  return l.filter(function (_, i, a)\
    \ {\n    return i === a.indexOf(l);\n  });\n}", "  return l.filter((v, i, a) =>\
    \ (a.indexOf(v) === i) ? false : true)\n}", "    const u: number[] = [];\n   \
    \ const uLen: number = l.length;\n    const i: number;\n    let j: number;\n \
    \   for (i = 0; i < uLen; i++) {\n        const el = l[i];\n        for (j = i\
    \ + 1; j < uLen; j++) {\n            if (el === l[j]) {\n                l.splice(i,\
    \ 1);\n                uLen--;\n                break;\n            }\n      \
    \  }\n    }\n    return l;\n}", "  let set: number[] = new Array(l.length);\n\
    \  for (let i = 0; i < l.length; i++) {\n    if (!set.includes(l[i])) {\n    \
    \  set.push(l[i]);\n    }\n  }\n  return set;\n}\n", "\treturn l.reduce(function\
    \ (p, c) {\n\t\treturn p.indexOf(c) === -1 ? p.concat(c) : p;\n\t}, []);\n}\n",
  "    const u = [];\n    for (const num of l) {\n        if (u.indexOf(num) === -1)\
    \ {\n            u.push(num);\n        }\n    }\n    return u;\n}", "\treturn\
    \ Array.from(new Set(l));\n}\n\nexport function convertToSnakeCase(name: string):\
    \ string {\n\treturn name.replace(/^(@)/, match => {\n\t\treturn match.replace(/-(.)/g,\
    \ (match, char) => char.toUpperCase());\n\t});\n}\n\nexport function convertToCamelCase(name:\
    \ string): string {\n\treturn name.replace(/^(@)/, match => {\n\t\treturn match.replace(/-(.)/g,\
    \ (match, char) => char.toLowerCase());\n\t});\n}\n\nexport function camelCaseToSnakeCase(camelCase:\
    \ string): string {\n\treturn camelCase.indexOf('-') === 0 ? camelCase.substr(1)\
    \ : camelCase;\n}\n\nexport function toBoolean(value: boolean | undefined | null):\
    \ boolean {\n\treturn !!value;\n}\n\nexport function convertToRoman(value: number):\
    \ number {\n\tlet roman = '';\n\twhile (value > 1000) {\n\t\troman += value %\
    \ 1000 + 'k';\n\t\tvalue = Math.floor(value / 1000);\n\t}\n\twhile (value > 100)\
    \ {\n\t\troman += value % 100 + 'k';\n\t\tvalue = Math.floor(value / 100);\n\t\
    }\n\twhile (value > 10) {\n\t\troman += value % 10 + 'k';\n\t\tvalue = Math.floor(value\
    \ / 10);\n\t}\n\troman += value + 'k';\n\treturn +roman;\n}\n\nexport function\
    \ debounce(func: Function, wait: number, immediate: boolean): Function {\n\tlet\
    \ timeout: NodeJS.Timer | undefined;\n\treturn () => {\n\t\tconst context = this;\n\
    \t\tconst args = arguments;\n\t\tconst later = () => {\n\t\t\ttimeout!.cancel();\n\
    \t\t\ttimeout = null;\n\t\t\tif (!immediate) func.apply(context, args);\n\t\t\
    };\n\t\tconst callNow = immediate && !timeout;\n\t\tclearTimeout(timeout);\n\t\
    \ttimeout = setTimeout(later, wait);\n\t\tif (callNow) func.apply(context, args);\n\
    \t};\n}\n\nexport function toggleClass(element: HTMLElement, className: string,\
    \ shouldHaveIt?: boolean) {\n\tif (element.classList) {\n\t\tif (shouldHaveIt)\
    \ {\n\t\t\telement.classList.add(className);\n\t\t} else {\n\t\t\telement.classList.remove(className);\n\
    \t\t}\n\t} else {\n\t\tconst classList = element.className.split(' ');\n\t\tif\
    \ (shouldHaveIt) {\n\t\t\tif (classList.indexOf(className) > -1) {\n\t\t\t\treturn;\n\
    \t\t\t}\n\t\t\tclassList.push(className);\n\t\t} else {\n\t\t\tconst index = classList.indexOf(className);\n\
    \t\t\tif (index > -1) {\n\t\t\t\tclassList.splice(index, 1);\n\t\t\t}\n\t\t}\n\
    \t\telement.className = classList.join(' ');\n\t}\n}\n\nexport function toggle(element:\
    \ HTMLElement", "\treturn Array.from(new Set(l));\n}\n", "\tlet i: number;\n\t\
    let j: number;\n\tlet k: number;\n\tlet t: number[];\n\n\ti = j = 0;\n\tt = [];\n\
    \n\tfor (; j < l.length; j++) {\n\t\ti = j;\n\t\tfor (k = j + 1; k < l.length;\
    \ k++) {\n\t\t\tif (l[j] === l[k]) continue;\n\t\t\tif (l[j] < l[k]) {\n\t\t\t\
    \tt[i] = l[j];\n\t\t\t\ti = k;\n\t\t\t}\n\t\t}\n\n\t\tt[i] = l[i];\n\t}\n\n\t\
    return t;\n}\n", "\tconst o: number[] = [];\n\tfor (const v of l) {\n\t\tif (o.indexOf(v)\
    \ < 0) o.push(v);\n\t}\n\treturn o;\n}\n", "\treturn l.reduce((a, b) => !this[a]\
    \ ? this[a] = true : this[a], []);\n}\n", "    return l.reduce((result: number[],\
    \ item: number) => result.indexOf(item) === -1 ? [...result, item] : result,\n\
    \        []);\n}", "    const i: number[] = [];\n    let ins: number[] = [];\n\
    \    for (let j = 0; j < l.length; j++) {\n        if (ins.indexOf(l[j]) === -1)\
    \ {\n            ins.push(l[j]);\n            i.push(l[j]);\n        }\n    }\n\
    \    return i;\n}\n", "    let r = [];\n    let f = 0;\n    let t = 0;\n    for\
    \ (let i = 0; i < l.length; i++)\n    {\n        if (r[f] === undefined || l[i]\
    \ !== r[f])\n        {\n            r[f] = l[i];\n            f++;\n        }\n\
    \    }\n    return r;\n}\n", "  const o = new Map<number, number>();\n  for (let\
    \ i = 0; i < l.length; i++) {\n    if (!o.has(l[i])) {\n      o.set(l[i], i);\n\
    \    }\n  }\n  return Array.from(o.values()) as number[];\n}\n", "  return l.filter((v,\
    \ i) => l.indexOf(v) === i);\n}\n", "\tlet u: number[] = [];\n\n\tfor (let i =\
    \ 0; i < l.length; i++) {\n\t\tconst index = u.indexOf(l[i]);\n\n\t\tif (index\
    \ === -1) {\n\t\t\tu.push(l[i]);\n\t\t}\n\t}\n\n\treturn u;\n}\n", "    let c:\
    \ number = l.length\n    for (let i=0; i<c; i++) {\n        let r: number = l[i]\n\
    \        let j: number = i\n        while (j<c) {\n            if (l[j] == r)\
    \ {\n                break\n            }\n            else if (l[j] > r) {\n\
    \                l[j+1] = l[j]\n                j++\n            }\n         \
    \   else {\n                l[j+1] = r\n                j++\n            }\n \
    \       }\n        l[j+1] = r\n    }\n    return l\n}", "  let a: number[] = [];\n\
    \  for (let i = 0; i < l.length; i++) {\n    const n = l.indexOf(l[i]);\n    if\
    \ (n < 0) a.push(l[i]);\n  }\n  return a;\n}\n</code>\n<|/ a dscore=1 tags=javascript,ecmascript-6\
    \ |>\n<| c |>\nUsing `Math.max` inside a `for` loop has a potential of O(n^2)\
    \ time complexity.\n<|/ c |>\n<| c |>\nThat would be true if we were sorting every\
    \ unique element in the array. However, this isn't actually sorting at all; it's\
    \ the sort of thing that would be O(n^2) on a big list. Also, if you're going\
    \ to write your own sort, you're probably going to need to use `Math.max` inside\
    \ it.\n<|/ c |>\n<| c |>\nHi, I agree. I just mentioned that it's worth noting\
    \ that the complexity of a sort like this is actually _O(n*log(n))_ (although\
    \ that is _O(n)_ because of the sort, which is _O(nlogn)_ because of the `Math.max`\
    \ call).\n<|/ c |>\n<| a tags=javascript,ecmascript-6 |>\nIf you want a pure JavaScript\
    \ solution, here's a solution that uses the built-in sort().\n<code>", "  const\
    \ o: number[] = [];\n  for (let i = 0, j = l.length; i < j; i++) {\n    if (o[i]\
    \ != l[i]) {\n      o[i] = l[i];\n    }\n  }\n  return o;\n}\n", "  const hash:\
    \ number[] = [];\n  const uniqueArr: number[] = [];\n  l.forEach((num) => {\n\
    \    const exists = hash.indexOf(num);\n    if (exists < 0) {\n      uniqueArr.push(num);\n\
    \      hash.push(num);\n    }\n  });\n  return uniqueArr;\n}\n", "  return [...new\
    \ Set(l)];\n}\n", "  const a: number[] = [];\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (a.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n\
    \  return a;\n}\n", "  if (l.length > 1) {\n    const a: number[] = l;\n    const\
    \ results: number[] = [];\n    let j = 0;\n\n    for (let i = 0; i < a.length;\
    \ ++i) {\n      while (j < results.length && results[j] < a[i]) {\n        j++;\n\
    \      }\n\n      results[j] = a[i];\n    }\n\n    results.length = j;\n    return\
    \ results;\n  }\n\n  return [];\n}\n", "    return l.reduce((acc, val) => {\n\
    \        if (acc.indexOf(val) < 0) {\n            acc.push(val)\n        }\n\n\
    \        return acc\n    }, [])\n}\n", "  const a: number[] = [];\n  for (let\
    \ i = 0; i < l.length; i++) {\n    const n = l[i];\n    if (a.indexOf(n) < 0)\
    \ a.push(n);\n  }\n  return a;\n}\n", "\tlet i: number, llen: number = l.length;\n\
    \tfor (i = 0, llen = l.length; i < llen; i++) {\n\t\tlet value: number = l[i];\n\
    \t\tfor (let j = i + 1; j < llen; j++) {\n\t\t\tif (l[j] == value) {\n\t\t\t\t\
    l.splice(j, 1);\n\t\t\t\tllen--;\n\t\t\t\ti--;\n\t\t\t\tllen--;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn l;\n}\n", "    const result: number[] = []\n    for (const e\
    \ of l) {\n        if (result.indexOf(e) === -1) result.push(e)\n    }\n    return\
    \ result\n}\n", "  const u: number[] = [];\n  for (let i = 0; i < l.length; i++)\
    \ {\n    if (u.indexOf(l[i]) < 0) {\n      u.push(l[i]);\n    }\n  }\n  return\
    \ u;\n}\n", "    var u: number[] = [];\n    for (var i = l.length; i--;) u.push(l[i]);\n\
    \    return u;\n}\n", "  let a: number[] = [];\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (a.indexOf(l[i]) < 0) a.push(l[i]);\n  }\n  return a;\n}\n",
  "    const a: number[] = [];\n    const o: number[] = [];\n    let n: number = l.length;\n\
    \    for (let i: number = 0; i < n; i++) {\n        const e: number = l[i];\n\
    \        if (o.indexOf(e) == -1) {\n            a.push(e);\n            o.push(e);\n\
    \        }\n    }\n    return a;\n}\n", "    return l.filter(function(v, i, a)\
    \ {\n        return a.indexOf(v) === i;\n    }) as number[];\n}\n", "    return\
    \ l.filter(function (elem, pos, arr) {\n        return arr.indexOf(elem) === pos;\n\
    \    });\n}\n", "  const seen = new Set<number>();\n  return l.filter((n) => {\n\
    \    if (seen.has(n)) {\n      return false;\n    }\n    seen.add(n);\n    return\
    \ true;\n  });\n}\n", "    return Array.from(new Set(l));\n}\nexports.unique =\
    \ unique;", "    const result = [], seen = new Set<number>();\n    for (let i\
    \ = 0; i < l.length; i++) if (!seen.has(l[i])) {\n        result.push(l[i]);\n\
    \        seen.add(l[i]);\n    }\n    return result.sort((a,b) => (a-b));\n}\n\
    </code>\n<|/ a |>\n<| a tags=algorithm,sorting,javascript,arrays |>\nThe question\
    \ is a bit unclear on whether duplicates are allowed or not. However, if duplicates\
    \ are allowed, you can try this solution using filter and sort:\n\n<code>", " \
    \ const r: [number, number] = [0, -1];\n  let i: number;\n  let j: number;\n \
    \ for (i = 0; i < l.length; i++) {\n    const x = l[i];\n    j = r[0];\n    while\
    \ (j > 0) {\n      if (l[j - 1] === x) {\n        r[1] = j;\n        break;\n\
    \      } else {\n        j--;\n      }\n    }\n    r[0] = x + 1;\n  }\n  return\
    \ r;\n}\n", "  const set = new Set<number>();\n  for (let i = 0; i < l.length;\
    \ i++) {\n    set.add(l[i]);\n  }\n  return Array.from(set);\n}\n", "    let u:\
    \ number[] = [];\n\n    for (let i = 0; i < l.length; i++) {\n        if (u.indexOf(l[i])\
    \ === -1) {\n            u.push(l[i]);\n        }\n    }\n\n    return u;\n}\n",
  "    const u: number[] = [];\n    for (let i = 0; i < l.length; i++) {\n       \
    \ if (u.indexOf(l[i]) === -1) {\n            u.push(l[i]);\n        }\n    }\n\
    \    return u;\n}\n", "\tlet u: number[] = [],\n\t\tv: number;\n\tfor (i = 0;\
    \ i < l.length; i++) {\n\t\tv = l[i];\n\t\tif (u.indexOf(v) == -1) {\n\t\t\tu.push(v);\n\
    \t\t}\n\t}\n\treturn u;\n}\n", "    return l.reduce((a, x, i) => {\n        if\
    \ (!a.includes(x)) {\n            a.push(x);\n        }\n        return a;\n \
    \   }, []);\n}", "    if (l.length === 0) return [];\n    let i: number;\n   \
    \ let ret: number[] = [];\n    const obj: { [key: number]: number; } = {};\n\n\
    \    for (i = 0; i < l.length; i++) {\n        const key = l[i];\n\n        if\
    \ (!obj[key]) {\n            ret[i] = key;\n            obj[key] = 1;\n      \
    \  } else {\n            delete obj[key];\n        }\n    }\n\n    return ret;\n\
    }\n", "\tconst u: number[] = [];\n\tfor (let i = 0; i < l.length; i++) {\n\t\t\
    const v = l[i];\n\t\tif (u.indexOf(v) < 0) {\n\t\t\tu.push(v);\n\t\t}\n\t}\n\t\
    return u;\n}", "  return l.filter(function (el, i, a) {\n    return a.indexOf(el)\
    \ === i;\n  });\n}\n", "  const a = l\n        .filter(function(elem, pos, self)\
    \ {\n          return self.indexOf(elem) === pos;\n        })\n        .map(function(elem)\
    \ {\n          return elem\n        })\n  return a;\n}\n", "    const c: number[]\
    \ = [];\n    for (let i = 0; i < l.length; i++) {\n        if (c.indexOf(l[i])\
    \ === -1) {\n            c.push(l[i]);\n        }\n    }\n    return c;\n}\n",
  "  return l.filter(function(value, i, l) { return l.indexOf(value) === i; }).sort(function(a,\
    \ b) { return b - a });\n}\n", "\tvar res = [];\n\tfor (var i = 0, len = l.length;\
    \ i < len; i++) {\n\t\tif (!res.includes(l[i])) {\n\t\t\tres.push(l[i]);\n\t\t\
    }\n\t}\n\treturn res;\n}\n", "  const o = new Map<number, boolean>();\n  l.forEach(o\
    \ => o.has(o) || (o.set(o, true), o.delete(o) && o.size === 1 ? o.values().next().value\
    \ || undefined : undefined))\n  return [...o.keys()];\n}\n", "    var u: number[]\
    \ = [];\n    var c: number = 0;\n    for (var i = 0, n = l.length; i < n; i++)\
    \ {\n        if (u[c] === l[i]) {\n            continue;\n        }\n        u[++c]\
    \ = l[i];\n    }\n    return u;\n}\n", "    const o: number[] = [];\n    for (let\
    \ i = 0; i < l.length; i++) {\n        if (o.indexOf(l[i]) === -1) {\n       \
    \     o.push(l[i]);\n        }\n    }\n    return o;\n}\n", "  let o = {}\n  for\
    \ (let i = 0; i < l.length; i++) {\n    o[l[i]] = true\n  }\n  let n = []\n  for\
    \ (let k in o) {\n    n.push(k)\n  }\n  return n\n}\n", "  const hash: { [key:\
    \ number]: boolean; } = {};\n  const out: number[] = [];\n\n  for (let i = 0;\
    \ i < l.length; i++) {\n    const value = l[i];\n\n    if (!hash[value]) {\n \
    \     hash[value] = true;\n      out.push(value);\n    }\n  }\n\n  return out;\n\
    }\n", "    var u: number[] = new Array(l.length);\n    var i: number, n: number\
    \ = 0;\n\n    for (i = 0; i < l.length; ++i) {\n        if (l[i] === l[i]) {\n\
    \            n++;\n        } else {\n            u[n] = l[i];\n            n++;\n\
    \        }\n    }\n\n    u.length = n;\n\n    return u;\n}\n", "\tlet i: number;\n\
    \tlet j: number;\n\tlet result: number[] = new Array((l.length * 2 - 1));\n\t\
    for (i = 0; i < l.length - 1; i++) {\n\t\tfor (j = i + 1; j < l.length; j++) {\n\
    \t\t\tif (l[i] !== l[j]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[i] = l[i];\n\
    \t}\n\tfor (j = 1; j < l.length; j++) {\n\t\tif (l[j] === result[j - 1]) {\n\t\
    \t\tresult[j] = undefined;\n\t\t}\n\t}\n\treturn result;\n}\n", "  const o = new\
    \ Set(l);\n  return Array.from(o) as number[];\n}\n</code>\n<|/ a tags=arrays,javascript\
    \ |>\n<| a tags=arrays,javascript |>\nI guess this has to do with the way you're\
    \ constructing the new array. In the code you posted, you're doing this:\n<code>\n\
    let result = [...new Set(arr)];\n</code>\nThis converts the array to a Set, which\
    \ is a unordered collection of unique items. When you call Set(), it first checks\
    \ if the value already exists in the Set. If it does, it just returns the value.\
    \ If it doesn't, it adds the value to the Set. That's why you get an array of\
    \ duplicates. Instead of converting to a Set, you can use the spread syntax to\
    \ convert the array to a regular array, and then use Set to get unique values.\n\
    <code>\nlet result = Array.from(new Set(arr));\n</code>\n<|/ a dscore=4 |>\n<|\
    \ c |>\nWhy not just use `[...new Set(arr)]` ? Just curious.\n<|/ c |>\n<| c |>\n\
    Good point,. I think I was trying to be too fancy with the spread syntax. Good\
    \ suggestion, though.\n<|/ c |>\n<| a dscore=3 |>\nThe solutions here are really\
    \ good but just one more option is to use map and filter method available in Array\n\
    <code>\nlet arr = [1,2,3,4,5,5,6,7,8];\n\nlet unique = arr.filter(function(elem,\
    \ index, self) {\n  return index == self.indexOf(elem);\n}).map(function(elem)\
    \ {\n  return elem;\n});\n\nconsole.log(unique); // [1,2,3,4,5,6,7,8]\n</code>\n\
    <|/ a tags=arrays,javascript |>\n<| c |>\nNice solution. I've never seen it before.\
    \ Was looking for something like this but was unable to find it.\n<|/ c |>\n<|\
    \ c |>\nThis is not very efficient\n<|/ c |>\n<| a tags=arrays,javascript |>\n\
    The issue is with the way you are creating the set. Try changing it to this:\n\
    <code>\nlet result = [...new Set(arr)];\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    Thank you! I had tried to use `Array.from` but I got an error that said I needed\
    \ to pass in an array. I'll accept this answer once the timer runs out.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nThis works perfectly fine:\n<code>", "  const m = {}\n\
    \  for (let i = 0, n = l.length; i < n; ++i) m[l[i]] = true\n  const a: number[]\
    \ = []\n  for (const i in m) a.push(i)\n  return a\n}\n", "  return Array.from(new\
    \ Set(l)).sort();\n}", "  const u: number[] = [];\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (u.indexOf(l[i]) === -1) {\n      u.push(l[i]);\n    }\n  }\n\
    \  return u;\n}\n", "  let output: number[] = [];\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (output[l[i]] === undefined) {\n      output[l[i]] = i;\n   \
    \ }\n  }\n  return output;\n}\n", "  if (l.length <= 1) return l\n  const result\
    \ = []\n  let hashSet = new Set()\n  for (let item of l) {\n    if (!hashSet.has(item))\
    \ {\n      hashSet.add(item)\n      result.push(item)\n    }\n  }\n  return result\n\
    }\n", "\tconst seen = new Set<number>();\n\tconst uniq = [];\n\tl.forEach(d =>\
    \ {\n\t\tif (seen.has(d)) return;\n\t\tseen.add(d);\n\t\tuniq.push(d);\n\t});\n\
    \treturn uniq;\n}\n", "    const i: number[] = [];\n    for (let n = 0; n < l.length;\
    \ n++) i[l.charCodeAt(n)] = n;\n    return i;\n}\n", "    if (l.length <= 1) {\n\
    \        return l;\n    }\n    let newArr: number[] = [];\n    for (let i = 0;\
    \ i < l.length; i++) {\n        const j = l.indexOf(l[i]);\n        if (j !==\
    \ -1) {\n            newArr.push(l[i]);\n            l.splice(j, 1);\n       \
    \ }\n    }\n    return newArr;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nJust in\
    \ case, this can be done with a single loop:\n<code>", "  let result: number[]\
    \ = [];\n  for (let i = 0; i < l.length; i++) {\n    if (result.indexOf(l[i])\
    \ === -1) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n}\n", " \
    \ var a = []\n  for (var i = 0; i < l.length; i++) {\n    if (a.indexOf(l[i])\
    \ == -1) {\n      a.push(l[i])\n    }\n  }\n  return a\n}\n", "\treturn Array.from(new\
    \ Set(l)).sort();\n}\n", "    const o = new Set<number>();\n    l.forEach(x =>\
    \ {\n        if (!o.has(x)) {\n            o.add(x);\n        }\n    });\n   \
    \ return [...o];\n}\n", "\treturn l.filter((v, i, a) => a.indexOf(v) === i);\n\
    }\n", "  const a: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n   \
    \ if (a.indexOf(l[i]) < 0) a.push(l[i]);\n  }\n  return a;\n}\n", "    let a:\
    \ number[] = [];\n    for (let i = 0; i < l.length; i++) {\n        if (a.indexOf(l[i])\
    \ === -1) a.push(l[i]);\n    }\n    return a;\n}\n", "  var o: number[] = [];\n\
    \  for (var i = 0; i < l.length; i++) {\n    if (o.indexOf(l[i]) == -1) o.push(l[i]);\n\
    \  }\n  return o;\n}\n", "\tconst a: number[] = l.concat();\n\tlet i = 0;\n\t\
    const result: number[] = [];\n\twhile (i < a.length) {\n\t\tlet j = 0;\n\t\tlet\
    \ k: number;\n\t\twhile (a[j] === a[j + 1]) {\n\t\t\tj++;\n\t\t\tif (j > i) {\n\
    \t\t\t\tk = a[j];\n\t\t\t\tresult.push(k);\n\t\t\t\ta.splice(j, 1);\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn result;\n}\n", "  const a = new Set()\n  for (const i of\
    \ l) {\n    if (!a.has(i)) {\n      a.add(i)\n    }\n  }\n  return Array.from(a)\n\
    }\n", "    const c: number[] = [];\n    let a: number = l[0];\n    for (let i\
    \ = 1; i < l.length; i++) {\n        a = l[i];\n        if (c.indexOf(a) !== -1)\
    \ {\n            continue;\n        }\n        c.push(a);\n    }\n    return c;\n\
    }", "    const a = [],\n        m = [],\n        p = [];\n    for (let i = 0;\
    \ i < l.length; i++) {\n        if (m.indexOf(l[i]) === -1) {\n            m.push(l[i]);\n\
    \            a.push(l[i]);\n            p.push(1);\n        } else {\n       \
    \     p[p[l[i]]++] = i;\n        }\n    }\n    return a.concat(p);\n}\n", "  \
    \  return l.filter((e, i, a) => a.indexOf(e) === i);\n}\n", "    const u = {}\n\
    \    let result: number[] = []\n\n    l.forEach((e: number) => {\n        (u[e]\
    \ || (u[e] = [])).push(e)\n    })\n\n    for (let k of Object.values(u)) {\n \
    \       if (k.length > 1) result = result.concat(k)\n    }\n\n    return result\n\
    }\n", "  const u: number[] = [];\n  for (let i = 0; i < l.length; ++i) {\n   \
    \ if (u.indexOf(+l[i]) === -1) {\n      u.push(+l[i]);\n    }\n  }\n  return u;\n\
    }\n", "  return l.filter(function(elem, index, arr) {\n    return index === arr.indexOf(elem);\n\
    \  });\n}\n", "\treturn Array.from(new Set(l)).sort((a: number, b: number) =>\
    \ {\n\t\treturn a - b;\n\t});\n}\n", "  let res: number[] = [];\n  for (var i\
    \ = 0; i < l.length; i++) {\n    if (res.indexOf(l[i]) < 0) res.push(l[i]);\n\
    \  }\n  return res;\n}\n", "\tconst a: number[] = [];\n\tconst o: number[] = [];\n\
    \tfor (let i = 0; i < l.length; i++) {\n\t\tconst v = l[i];\n\t\tif (o.indexOf(v)\
    \ < 0) {\n\t\t\to.push(v);\n\t\t\ta.push(v);\n\t\t}\n\t}\n\treturn a;\n}\n\nexport\
    \ function removeDuplicates(l: number[]): number[] {\n\tconst a: number[] = [];\n\
    \tlet j: number = 0;\n\tfor (let i = 0; i < l.length; i++) {\n\t\tconst v = l[i];\n\
    \t\tif (a.indexOf(v) < 0) {\n\t\t\tj++;\n\t\t\ta.push(v);\n\t\t}\n\t}\n\tif (j\
    \ === a.length) return a;\n\telse if (j > a.length) throw new Error(`duplicate-removed:\
    \ duplicate at index ${j}`);\n\telse throw new Error(`duplicate-removed: duplicate\
    \ at index ${j}`);\n}\n\nexport function unique2(l: number[]): number[] {\n\t\
    const a: number[] = [];\n\tconst o: number[] = [];\n\tfor (let i = 0; i < l.length;\
    \ i++) {\n\t\tconst v = l[i];\n\t\tif (o.indexOf(v) < 0) {\n\t\t\to.push(v);\n\
    \t\t\ta.push(v);\n\t\t}\n\t}\n\treturn a;\n}\n\nexport function removeDuplicates2(l:\
    \ number[]): number[] {\n\tconst a: number[] = [];\n\tlet j: number = 0;\n\tfor\
    \ (let i = 0; i < l.length; i++) {\n\t\tconst v = l[i];\n\t\tif (a.indexOf(v)\
    \ < 0) {\n\t\t\tj++;\n\t\t\ta.push(v);\n\t\t}\n\t}\n\tif (j === a.length) return\
    \ a;\n\telse if (j > a.length) throw new Error(`duplicate-removed: duplicate at\
    \ index ${j}`);\n\telse throw new Error(`duplicate-removed: duplicate at index\
    \ ${j}`);\n}\n\nexport function unique3(l: number[]): number[] {\n\tconst a: number[]\
    \ = [];\n\tconst o: number[] = [];\n\tlet found: number[] = [];\n\tfor (let i\
    \ = 0; i < l.length; i++) {\n\t\tconst v = l[i];\n\t\tif (o.indexOf(v) < 0) {\n\
    \t\t\to.push(v);\n\t\t\ta.push(v);\n\t\t\tfound.push(v);\n\t\t}\n\t}\n\tif (found.length\
    \ === a.length) return a;\n\telse if (found.length > a.length) throw new Error(`duplicate-removed:\
    \ duplicate at index ${found.length}`);\n\telse throw new Error(`duplicate-removed:\
    \ duplicate at index ${found.length}`);\n}\n\nexport function removeDuplicates3(l:\
    \ number[]): number[] {\n\tconst a: number[] = [];\n\tlet j: number = 0;\n\tlet\
    \ found: number[] = [];\n\tfor (let ", "\tlet o = new Map<number, boolean>();\n\
    \tfor (let i = 0; i < l.length; i++) {\n\t\tlet k = l[i];\n\t\tif (o.has(k)) continue;\n\
    \t\to.set(k, true);\n\t\tlet j = i;\n\t\twhile (j < l.length && l[j] === k) j++;\n\
    \t\tlet tmp = j;\n\t\twhile (j--) {\n\t\t\tif (l[j] === k) break;\n\t\t\ttmp =\
    \ o.get(l[j]) || tmp;\n\t\t}\n\t\to.set(k, false);\n\t\tl[tmp] = k;\n\t}\n\tlet\
    \ ret = [];\n\tfor (let i = 0; i < l.length; i++) {\n\t\tif (!o.has(l[i])) ret.push(l[i]);\n\
    \t}\n\treturn ret;\n}\n", "  const u: number[] = []\n  const o: number = l.length\n\
    \  let j: number = 0\n  let k = 0\n  for (let i: number = 1; i < o; i++) {\n \
    \   if (l[i] !== l[k]) {\n      u.push(l[j])\n      j++\n    }\n    k++\n  }\n\
    \  return u\n}\n", "  const a: number[] = [];\n  for (const i in l) {\n    if\
    \ (a.indexOf(l[i]) === -1) {\n      a.push(l[i]);\n    }\n  }\n  return a;\n}",
  "  return l.filter((v, i) => l.indexOf(v) === i);\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nUse an object to track duplicates:\n\n<code>\nconst a = [1, 2, 2, 3,\
    \ 4, 4, 4, 5, 5, 6, 6];\n\nconst set = {};\n\na.filter(v => !set[v]).forEach((v)\
    \ => set[v] = true);\n\nconsole.log(JSON.stringify(a));</code>\n<|/ a tags=arrays,javascript,sorting\
    \ dscore=1 |>\n<| a dscore=1 |>\nYou could use the unique function from lodash\
    \ library to remove duplicates before sorting:\n<code>", "  const u: number[]\
    \ = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i]) < 0)\
    \ u.push(l[i]);\n  }\n  return u;\n}\n", "  return l.filter(function (elem, pos)\
    \ {\n    return l.indexOf(elem) == pos;\n  });\n}\n", "  const ns: number[] =\
    \ [];\n  const vals: number[] = [];\n  let v = ns;\n  let w = vals;\n  l.sort((a,\
    \ b) => {\n    return a - b;\n  });\n  while (w.length !== 0) {\n    const e =\
    \ w.pop();\n    if (vals.indexOf(e) === -1 && ns.length !== 0) {\n      v = v.concat(ns);\n\
    \      w = w.concat(vals);\n    }\n    if (ns.length === 0 && vals.length ===\
    \ 0) {\n      return v;\n    }\n    v.push(e);\n    vals.push(e);\n  }\n  return\
    \ v;\n}\n", "    if (l.length <= 1) {\n        return l;\n    }\n\n    const sorted\
    \ = l.slice();\n    sorted.sort();\n\n    let i = 1;\n    for (; i < sorted.length;\
    \ ++i) {\n        if (sorted[i] !== sorted[i - 1]) {\n            break;\n   \
    \     }\n    }\n\n    return sorted.slice(0, i);\n}\n", "    var u: number[] =\
    \ [],\n        a: number[] = [],\n        i: number;\n    for (i = 0; i < l.length;\
    \ ++i) {\n        if (l[i] !== l[i + 1]) {\n            a.push(l[i]);\n      \
    \  }\n    }\n    a = a.sort();\n    for (i = 0; i < a.length; ++i) {\n       \
    \ u.push(a[i]);\n    }\n    return u;\n}", "    var u = [];\n    var result =\
    \ [];\n    for(let i = 0; i < l.length; i++) {\n        if(u.indexOf(+l[i]) <\
    \ 0) u.push(+l[i]);\n        result.push(l[i]);\n    }\n    return result;\n}\n",
  "  const u: number[] = [];\n  for (let i = 0; i < l.length; ++i) u.push(l.indexOf(l[i]));\n\
    \  return u;\n}\n", "    return l.reduce(function (res: number[], value: number):\
    \ number[] {\n        const uniqueValueIndex = res.indexOf(value);\n        if\
    \ (uniqueValueIndex === -1) {\n            return [...res, value];\n        }\
    \ else {\n            return res;\n        }\n    });\n}\n\nexport function hasMultipleValues(arr:\
    \ number[]): boolean {\n    return arr.length > 1 || !arr.some((n: number) =>\
    \ n === 0);\n}\n\nexport function hasAnyValues(arr: number[]): boolean {\n   \
    \ return arr.length > 0 || !arr.some((n: number) => n !== 0);\n}\n\nexport function\
    \ hasAllValues(arr: number[]): boolean {\n    return arr.some((n: number) => n\
    \ === 0);\n}\n\nexport function containsNot(arr: number[]): boolean {\n    return\
    \ arr.some((n: number) => n !== 0);\n}\n\nexport function containsAll(arr: number[]):\
    \ boolean {\n    return arr.length > 0 && arr.some((n: number) => n === 0);\n\
    }\n\nexport function containsAny(arr: number[]): boolean {\n    return arr.length\
    \ > 0 && arr.some((n: number) => n !== 0);\n}\n\nexport function containsNoneOf(arr:\
    \ number[]): boolean {\n    return arr.length > 0 && arr.some((n: number) => n\
    \ === 0);\n}\n\nexport function min<T>(arr: T[]): T | undefined {\n    return\
    \ arr.reduce(function (min: T, n: number): T | undefined {\n        return min\
    \ === undefined ? n : n < min ? n : min;\n    }, undefined);\n}\n\nexport function\
    \ max<T>(arr: T[]): T | undefined {\n    return arr.reduce(function (max: T, n:\
    \ number): T | undefined {\n        return max === undefined ? n : n > max ? n\
    \ : max;\n    }, undefined);\n}\n\nexport function sum<T>(arr: T[]): number {\n\
    \    return arr.reduce((sum: number, n: number) => sum + n, 0);\n}\n\nexport function\
    \ mean<T>(arr: T[]): number {\n    return sum(arr) / arr.length;\n}\n\nexport\
    \ function median<T>(arr: T[]): number {\n    const length = arr.length;\n   \
    \ if (length % 2 === 0) {\n        // Even\n        const half = Math.floor(length\
    \ / 2);\n        let lower = half - 1;\n        let upper = half;\n        if\
    \ (arr[lower] > arr[upper]) {\n            upper = lower + 1;\n        }\n\n \
    \       return Math.round((arr[lower] + arr[upper]) / 2);\n    } else {\n    \
    \    // Odd\n        const half = Math.ceil(length / 2);\n        let lower =\
    \ half - 1;\n        let upper = half;\n        if (arr[lower] > arr[upper]) {\n\
    \            lower = upper;\n        }\n\n        return Math.round((arr[lower]\
    \ + arr[upper]) / 2);\n    }\n}\n\nexport function variance<T>(", "  return l.filter((item,\
    \ index) => l.indexOf(item) === index)\n}\n", "  const o: number[] = [];\n  const\
    \ s: Set<number> = new Set();\n  for (const i of l) {\n    if (!s.has(i)) {\n\
    \      o.push(i);\n      s.add(i);\n    }\n  }\n  return o;\n}\n", "  const u:\
    \ number[] = new Array(l.length);\n  for (let i = 0; i < u.length; ++i) {\n  \
    \  if (l.indexOf(u[i]) == -1) u.push(i);\n  }\n  return u;\n}\n", "  return l.filter((v,\
    \ i, a) => (i === a.indexOf(v)) || (i > 0))\n}\n</code>\n<|/ a |>\n<| a tags=sorting,javascript\
    \ |>\n<code>", "\treturn l.filter(function(v, i, a) {\n\t\treturn a.indexOf(v)\
    \ == i;\n\t});\n}\n", "    if (l.length === 0) {\n        return l;\n    }\n \
    \   const u = [];\n    for (let i = 0; i < l.length; i++) {\n        if (u.indexOf(+l[i])\
    \ === -1) {\n            u.push(+l[i]);\n        }\n    }\n    return u;\n}",
  "  return Array.from(new Set(l)).sort();\n}\n", "    const u: number[] = [];\n \
    \   const result: number[] = [];\n    for(let i = 0; i < l.length; i++) {\n  \
    \      if(u.indexOf(l[i]) === -1) {\n            u.push(l[i]);\n            result.push(l[i]);\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=typescript,arrays\
    \ dscore=5 |>\n<| c |>\nThis won't work in general cases. For example, with array\
    \ `[5, 3, 9, 1, 123]`, your function will return `[5, 3, 9, 1, 123]` while `unique([5,\
    \ 3, 9, 1, 123, 5])` will return `[5, 3, 9, 1, 123, 5]`.\n<|/ c |>\n<| c |>\n\
    It seems to me a much better solution is the one presented here: https://stackoverflow.com/a/41390510/839625\n\
    <|/ c |>\n<| a dscore=5 |>\nA more efficient way to do this is to sort and remove\
    \ duplicates. You can remove duplicates using Set data structure:\n<code>\nvar\
    \ numbers = [1, 2, 3, 4, 2, 3, 4, 2];\nvar unique = new Set(numbers);\nconsole.log(Array.from(unique));\
    \ // [1,2,3]\n</code>\n<|/ a tags=typescript,arrays |>\n<| c |>\nThis is probably\
    \ the fastest in terms of performance.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `Set` is fast and efficient.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. `Set` is fast and efficient.\n<|/ c |>\n<| a dscore=5\
    \ |>\nA faster way is to run this loop:\n<code>\narray.filter((v, i, a) => a.indexOf(v)\
    \ === i);\n</code>\n<|/ a tags=typescript,arrays |>\n<| c |>\nThis should be the\
    \ best answer.\n<|/ c |>\n<| c |>\nIt's a really bad answer.\n<|/ c |>\n<| c |>\n\
    It should be the top answer.\n<|/ c |>\n<| c |>\nThis is exactly what I was looking\
    \ for!\n<|/ c |>\n<| c |>\nI like this but be aware that `indexOf` can be slow\
    \ with large arrays, as it may have to scan through the entire array each time.\
    \ It's not too bad in this case, but could be an issue if you were using a large\
    \ array and wanted it to be as fast as possible.\n<|/ c |>\n<| a |>\nThis solution\
    \ is better in terms of performance than above solutions\n<code>", "\tconst result\
    \ = new Set<number>();\n\tfor (let i = 0; i < l.length; i++) {\n\t\tif (!result.has(l[i]))\
    \ {\n\t\t\tresult.add(l[i]);\n\t\t}\n\t}\n\treturn Array.from(result);\n}\n",
  "    const a: number[] = [],\n        l = l.filter(function (val: number) {\n  \
    \          return a.indexOf(val) === -1;\n        }),\n        l = l.sort(function\
    \ (a: number, b: number) {\n            return a - b;\n        });\n    return\
    \ l;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your time and effort,\
    \ but you missed the point. The question is how to do the same using just JS native\
    \ methods.\n<|/ c |>\n<| c |>\nThe question was how to sort numbers in ascending\
    \ order. I provided an answer which does that and only uses native methods. Not\
    \ sure how this can be missed, so +1\n<|/ c |>\n<| c |>\nThis answer doesn't use\
    \ native, which is OP's point. And it uses multiple arrays to do the same thing.\
    \ Not the most performant or efficient way. But it is correct and works.\n<|/\
    \ c |>\n<| a tags=arrays,algorithm,javascript,sorting |>\nI recently had this\
    \ same problem and found a great solution.\n<code>", "  let ret: number[] = [];\n\
    \  for (let i = 0, len = l.length; i < len; i++) {\n    if (ret.indexOf(l[i])\
    \ === -1) {\n      ret.push(l[i]);\n    }\n  }\n  return ret;\n}\n", "  const\
    \ seen: Set<number> = new Set();\n  const sorted: number[] = [];\n  for (let i\
    \ = 0; i < l.length; i++) {\n    if (seen.has(l[i])) {\n      continue;\n    }\n\
    \    seen.add(l[i]);\n    sorted.push(l[i]);\n  }\n  return sorted;\n}\n", " \
    \ const m = new Set(l);\n  return [...m].sort((a: number, b: number) => a - b).filter(a\
    \ => a !== void 0);\n}\n", "  let i: number, c: number, o: number[] = [];\n\n\
    \  for (i = 0, c = l.length - 1; i <= c; i++) {\n    const val = l[i];\n\n   \
    \ if (l.indexOf(val) == i) o.push(val);\n  }\n  return o;\n}\n", "  const map\
    \ = new Map<number, boolean>();\n  const result = [];\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (!map.has(l[i])) {\n      result.push(l[i]);\n      map.set(l[i],\
    \ true);\n    }\n  }\n  return result;\n}\n", "  let r = [];\n  for (let i = 0;\
    \ i < l.length; i++) {\n    if (r.indexOf(l[i]) === -1) {\n      r.push(l[i]);\n\
    \    }\n  }\n  return r;\n}\n", "  var c: number[] = [];\n  var i: number;\n \
    \ var j: number;\n  for (j = 0; j < l.length; j++) {\n    for (i = 0; i < l.length;\
    \ i++) {\n      if (l[i] === l[j]) {\n        continue;\n      }\n      if (c.indexOf(l[i])\
    \ === -1) {\n        c.push(l[i]);\n      }\n    }\n  }\n  return c;\n}\n", " \
    \   return Array.from(new Set(l))\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nIf\
    \ you do not want to use any library just use for loop and sort it\n<code>\nlet\
    \ unq = [];\nfor(let i in a){\n  if(a.indexOf(a[i]) == -1) unq.push(a[i]);\n}\n\
    </code>\n<|/ a tags=javascript |>\n<| c |>\nPlease add some explanation to your\
    \ answer to improve its quality.\n<|/ c |>\n<| c |>\nplease add an explanation,\
    \ what does the code do and why should one use this?\n<|/ c |>\n<| a dscore=1\
    \ |>\nYou can try this\n<code>\nlet a = [1,2,3,3,5,5,6,6,9,9,9,10,10,10]\n\nlet\
    \ unique = a.filter((a,i,arr) => arr.indexOf(a) === i)\n</code>\n<|/ a tags=javascript\
    \ |>\n<| a tags=javascript |>\nUsing ES6 Set() with spread operator\n<code>\n\
    var arr = [1,2,3,3,5,5,6,6,9,9,9,10,10,10];\nvar unique = [...new Set(arr)];\n\
    console.log(unique)\n</code>\n<|/ a dscore=0 |>\n<| a tags=javascript |>\nES6\
    \ version (ES6)\n<code>\nvar a = [1,2,3,3,5,5,6,6,9,9,9,10,10,10];\nvar unique\
    \ = []; \n\nlet unique = a.filter((value,index,array)=>{\n  if(array.indexOf(value)==index)\n\
    \  {\n    return false;\n  }\n  else\n  {\n    unique.push(value);\n    return\
    \ true;\n  }\n\n});\n\nconsole.log(unique);\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=javascript dscore=0 |>\nWithout using any library you could use the following\
    \ code (using lodash):\n<code>\nvar a = [1,2,3,3,5,5,6,6,9,9,9,10,10,10];\nvar\
    \ unique = _.uniq(a)\n</code>\n<|/ a |>\n<| c |>\nI assume you mean `_.uniq(a)`\
    \ instead of `_.uniq`\n<|/ c |>\n<| a dscore=0 |>\nYou can use the following function,\
    \ which will return only unique values\n\n<code>", "  let s: Set<number> = new\
    \ Set();\n  for (let i of l) {\n    s.add(i);\n  }\n  return Array.from(s);\n\
    }\n", "    if (l.length <= 1) {\n        return l;\n    }\n    var ret: number[]\
    \ = [];\n    var found = false;\n    for (var i = 0, len = l.length; i < len;\
    \ i++) {\n        if (found) {\n            break;\n        }\n        var val\
    \ = l[i];\n        for (var j = 0; j < i; j++) {\n            if (l[j] === val)\
    \ {\n                found = true;\n                break;\n            }\n  \
    \      }\n        if (!found) {\n            ret.push(val);\n        }\n    }\n\
    \    return ret;\n}", "  let a: number[] = []\n  let u: number[] = []\n  let v:\
    \ number[] = []\n\n  for (let i = 0; i < l.length; i++) {\n    if (a.indexOf(l[i])\
    \ == -1) a.push(l[i])\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (u.indexOf(a[i])\
    \ == -1) u.push(a[i])\n  }\n\n  for (let i = 0; i < u.length; i++) {\n    if (v.indexOf(<any>u[i])\
    \ == -1) v.push(<any>u[i])\n  }\n\n  return v\n}\n", "    var u = {}, a = [];\n\
    \    for(var i = 0; i < l.length; i++) {\n        if(u.hasOwnProperty(l[i])) {\n\
    \            continue;\n        }\n        a.push(l[i]);\n        u[l[i]] = 1;\n\
    \    }\n    return a;\n}\n</code>\n<|/ a tags=numbers,javascript,arrays dscore=1\
    \ |>\n<| c |>\nThanks everybody for responding and sharing different ideas! I'm\
    \ sure they're helpful but since I'm new to Javascript I haven't implemented it\
    \ yet. I tried the code from Gordon's answer first, but then when I ran it, the\
    \ code was still returning all the values in my array as duplicates. So, I decided\
    \ to see if I could get a solution without using Sets and only using Arrays. Thanks\
    \ again everyone!\n<|/ c |>\n<| a tags=numbers,javascript,arrays dscore=0 |>\n\
    Here's a more efficient solution:\n<code>", "    let uniqueArr = [];\n    let\
    \ uniqueCounter = 0;\n    for (let i = 0; i < l.length; i++) {\n        if (uniqueCounter\
    \ < uniqueArr.length) {\n            if (l[i] == uniqueArr[uniqueCounter]) {\n\
    \                uniqueCounter++;\n            } else {\n                uniqueArr.push(l[i]);\n\
    \                uniqueCounter++;\n            }\n        } else {\n         \
    \   uniqueArr.push(l[i]);\n            uniqueCounter++;\n        }\n    }\n  \
    \  return uniqueArr;\n}\n</code>\nThe algorithm is O(n), but it is very inefficient\
    \ and does not take advantage of the fact that an array can be sorted, therefore\
    \ it can be done in O(n + k) time instead of O(n * k). I am not saying this is\
    \ faster or better, but it is much more efficient and much easier to implement.\n\
    Here is a more efficient version that also sorts the array:\n<code>", "\tconst\
    \ a: number[] = [];\n\tfor (let i = 0; i < l.length; i++) {\n\t\tconst j = a.indexOf(l[i]);\n\
    \t\tif (j === -1) a.push(l[i]);\n\t}\n\treturn a;\n}\n", "  return l.filter((value,\
    \ index, self) => self.indexOf(value) === index)\n}\n", "    return l.filter((value,\
    \ index) => l.indexOf(value) === index);\n}\n</code>\n<|/ a tags=typescript,javascript,arrays\
    \ |>\n<| a dscore=0 tags=typescript,javascript,arrays |>\nThis is a very handy\
    \ function, if you don't need to check for duplicate values.\n<code>\nvar a =\
    \ [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([].concat(a,b,c)));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([].concat(a,b,c)));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));\n\
    \nvar a = [1,2,3];\nvar b = ['a',2,'b'];\nvar c = [1,2,3];\nconsole.log(unique([a,b,c]));",
  "  let res: number[] = [];\n\n  for (let i = 0; i < l.length; i++) {\n    const\
    \ val = l[i];\n\n    if (res.indexOf(val) === -1) {\n      res.push(val);\n  \
    \  }\n  }\n\n  return res;\n}\n", "    const set = new Set<number>();\n    l.forEach((val)\
    \ => {\n        if (set.has(val)) {\n            set.delete(val);\n        } else\
    \ {\n            set.add(val);\n        }\n    });\n    return [...set];\n}\n",
  "  let u: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i])\
    \ < 0) u.push(l[i]);\n  }\n  return u;\n}\n", "    var u: number[] = [],\n   \
    \     i = -1,\n        n = l.length;\n\n    while (++i < n) if (u.indexOf(+l[i])\
    \ === -1) u.push(+l[i]);\n\n    return u;\n}\n", "    const a: number[] = [];\n\
    \    for (let i = 0; i < l.length; i++) {\n        const num = l[i];\n       \
    \ if (num === 0 || num === undefined || num === null) {\n            continue;\n\
    \        }\n        if (a.indexOf(num) === -1) {\n            a.push(num);\n \
    \       }\n    }\n    return a;\n}\n", "    let i: number[] = [],\n        s:\
    \ number[] = [],\n        map: Object = {},\n        maps: Object[] = [],\n  \
    \      m: number = 0;\n\n    for (i = 0; i < l.length; i++) {\n        if (i >\
    \ 0) {\n            if (map[l[i - 1]] === undefined) {\n                map[l[i\
    \ - 1]] = m;\n                maps.push(map);\n                m = m + 1\n   \
    \         } else {\n                map[l[i - 1]] = m[map[l[i - 1]]]\n       \
    \     }\n        }\n        s[map[l[i]]] = l[i]\n    }\n\n    return s.filter(function\
    \ (x: number) {\n        return map[x] === undefined\n    }).concat(maps.map(function\
    \ (map) {\n        return map\n    }))\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Your implementation is incorrect and will throw an exception in `unique`. The\
    \ idea is to use a map to store all the unique elements and a set to remove all\
    \ duplicates. So you should change your `if (i > 0) {` to `if (i > 0) {\n    \
    \            if (map[l[i - 1]] === undefined) {\n                    map[l[i -\
    \ 1]] = m;\n                    maps.push(map);\n                    m = m + 1\n\
    \                }\n            }\n            s[map[l[i]]] = l[i]\n        }`\n\
    <|/ c |>\n<| c |>\nI didn't test your code. The code that I wrote here is meant\
    \ to be an example of how to implement it. If you're going to write your own code\
    \ then you have to make sure that you actually understand what you are doing.\n\
    <|/ c |>\n<| c |>\nYou are not implementing the algorithm, you are simply giving\
    \ the solution. Notice that the OP wrote \"unique elements\" but implemented \"\
    unique items\" in your code.\n<|/ c |>\n<| c |>\nI see what you're saying. It\
    \ seems that there are two possible solutions to your problem. One is to use an\
    \ array of integers that will hold the unique elements and another one is to use\
    \ an object to store each unique element.\n<|/ c |>\n<| c |>\nI agree with you\
    \ that this is the way to go about it. The OP could of done this with sets or\
    \ other data structures.\n<|/ c |>\n<| a tags=javascript,typescript dscore=1 |>\n\
    If you have lodash installed, you can use the _.uniqWith method:\n<code>\n_.uniqWith(arr,\
    \ [func]);\n</code>\nExample:\n<code>\nvar arr = [1, 1, 2, 2, 3, 3]\nvar result\
    \ = _.uniqWith(arr, (val) => val % 2)\nconsole.log(result)\n> [1, 2, 3]\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=javascript,typescript |>\nTo achieve this with plain\
    \ JavaScript I would use the following:\n<code>\n", "  const seen = new Set<number>();\n\
    \  const result = [];\n\n  for (let i = 0, len = l.length; i < len; i++) {\n \
    \   const j = i + 1;\n\n    const item = l[i];\n    if (seen.has(item)) {\n  \
    \    continue;\n    }\n\n    seen.add(item);\n    result.push(item);\n  }\n\n\
    \  return result;\n}\n", "\tlet o: number[] = [];\n\tfor (let i = 0; i < l.length;\
    \ i++) {\n\t\tif (o.indexOf(+l[i]) === -1) {\n\t\t\to.push(+l[i]);\n\t\t}\n\t\
    }\n\treturn o;\n}\n", "  var u: number[] = [];\n  for (var i = l.length - 1; i\
    \ >= 0; i--) {\n    if (u.indexOf(l[i]) === -1) {\n      u.push(l[i]);\n    }\n\
    \  }\n  return u;\n}\n", "  return uniqueSort(l).reverse();\n}\n", "  const map\
    \ = new Map();\n  for (let i = 0; i < l.length; i++) {\n    const v = l[i];\n\
    \    if (map.has(v)) {\n      map.set(v, map.get(v) + 1);\n    } else {\n    \
    \  map.set(v, 1);\n    }\n  }\n  return Array.from(map.keys());\n}\n", "    let\
    \ u: number[] = [];\n\n    for (let i = 0; i < l.length; i++) {\n        if (u.indexOf(l[i])\
    \ === -1) {\n            u.push(l[i]);\n        }\n    }\n\n    return u;\n}\n",
  "  let r: number[] = [];\n  let q: number[] = [...l];\n  while (q.length > 0) {\n\
    \    let a = q.shift();\n    if (r.indexOf(a) === -1) {\n      r.push(a);\n  \
    \  }\n  }\n  return r;\n}\n", "  if (l.length !== l.uniq().length) {\n    throw\
    \ new Error('Array does not contain unique elements.')\n  }\n  return l\n}\n",
  "  return Array.from(new Set(l));\n}\n", "  const u: number[] = [];\n  for (let\
    \ i = 0; i < l.length; i++) {\n    if (u.indexOf(l[i]) == -1) {\n      u.push(l[i]);\n\
    \    }\n  }\n  return u;\n}\n", "  var a: number[] = [], l: number[] = [];\n \
    \ for (var i = 0, n = l.length; i < n; i++) {\n    if (!l[i]) {\n      a[i] =\
    \ l[i];\n      l.splice(i, 1);\n      n--;\n    }\n  }\n  return a;\n}\n", " \
    \   return l.filter(function(elem, pos, self) {\n        return self.indexOf(elem)\
    \ === pos;\n    });\n}\n", "  return l.filter((e, i) => l.indexOf(e) === i);\n\
    }\n", "    let u = [];\n    for(let i of l) {\n        if(u.indexOf(i) == -1)\
    \ u.push(i);\n    }\n    return u;\n}\n", "  let i: number;\n  const unq = [];\n\
    \n  for (i = 0; i < l.length; i += 1) {\n    if (unq.indexOf(l[i]) === -1) {\n\
    \      unq.push(l[i]);\n    }\n  }\n\n  return unq;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
