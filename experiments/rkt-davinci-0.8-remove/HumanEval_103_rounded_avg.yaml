name: HumanEval_103_rounded_avg
language: rkt
prompt: "#lang racket\n\n;; You are given two positive integers n and m, and your\
  \ task is to compute the\n;; average of the integers from n through m (including\
  \ n and m). \n;; Round the answer to the nearest integer and convert that to binary.\n\
  ;; If n is greater than m, return -1.\n;; Example:\n(define (rounded_avg n m)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rounded_avg))\n\
  \    (check-equal? (candidate 1 5) \"0b11\")\n    (check-equal? (candidate 7 13)\
  \ \"0b1010\")\n    (check-equal? (candidate 964 977) \"0b1111001010\")\n    (check-equal?\
  \ (candidate 996 997) \"0b1111100100\")\n    (check-equal? (candidate 560 851) \"\
  0b1011000010\")\n    (check-equal? (candidate 185 546) \"0b101101110\")\n    (check-equal?\
  \ (candidate 362 496) \"0b110101101\")\n    (check-equal? (candidate 350 902) \"\
  0b1001110010\")\n    (check-equal? (candidate 197 233) \"0b11010111\")\n    (check-equal?\
  \ (candidate 7 5) -1)\n    (check-equal? (candidate 5 1) -1)\n    (check-equal?\
  \ (candidate 5 5) \"0b101\")\n))\n\n(test-humaneval)"
completions: ["  (define (helper n m acc)\n    (if (> n m)\n        acc\n        (helper\
    \ (add1 n) m (add1 acc))))\n  (define (to-bin n)\n    (if (= n 0)\n        '()\n\
    \        (cons (remainder n 2) (to-bin (quotient n 2)))))\n  (if (< n m)\n   \
    \   (to-bin (round (/ (helper n m 0) (+ (sub1 (abs (sub1 m))) (sub1 (abs (sub1\
    \ n)))))))\n      '(-1)))\n", "  (define avg (+ (/ (+ n m) 2) (if (&gt; (remainder\
    \ (+ n m) 2) 0) 1 0)))\n  (if (&gt; n m)\n      -1\n      (number-&gt;string (inexact-&gt;exact\
    \ (round avg)) 2)))\n", "  (if (< n m)\n      (cond\n        ((= (round (exact->inexact\
    \ (/ (+ n m) 2))) 0)\n         #f)\n        ((= (round (exact->inexact (/ (+ n\
    \ m) 2))) 1)\n         #t)\n        (else\n         (cons (rounded_avg n (/ (+\
    \ n m) 2))\n               (rounded_avg (/ (+ n m) 2) m))))\n      -1))", "  (if\
    \ (> n m) -1\n    (round (/ (+ n m) 2))))\n", "  (if (< n m)\n      (let*\n  \
    \        ((sum (+ n m))\n           (avg (quotient sum 2))\n           (avg-bin\
    \ (number->string avg 2)))\n        (string-append \"0b\" avg-bin))\n      -1))\n",
  "  (if (&gt; n m)\n      -1\n      (number-&gt;string \n       (bytes-&gt;integer/signed\n\
    \        (string-&gt;bytes/utf-8\n         (string-&gt;number (integer-&gt;string\
    \ \n                           (round (/ (+ n m) 2)))))))))\n", "  (cond\n   \
    \ [(> n m) -1]\n    [else\n     (bitwise-and (bitwise-not (bitwise-not 1 (/ (floor\
    \ (* (+ n m) 0.5)) 2))) 1)]))", "  (define (counter x y)\n    (if (&gt; x y) y\n\
    \        (counter (+ x 1) (+ y (modulo (+ x y) 2)))))\n  (define (int_to_bin n)\n\
    \    (define (int_to_bin n x)\n      (if (= n 0) x\n          (int_to_bin (quotient\
    \ n 2) (string-append x (number-&gt;string (modulo n 2))))))\n    (int_to_bin\
    \ n \"\"))\n  (if (&gt; n m) -1\n      (int_to_bin (round (/ (counter n 0) (-\
    \ m n + 1))))))\n</code>\nSo the first function (<code>counter</code>) sums all\
    \ the integers between <code>n</code> and <code>m</code> by summing <code>n</code>\
    \ and <code>n+1</code> and then summing <code>n+1</code> and <code>n+2</code>\
    \ etc. by adding the parity bit of <code>n+1</code> to <code>n</code> until <code>n+1</code>\
    \ is equal to <code>m</code>.\nThe <code>int_to_bin</code> function is a recursive\
    \ binary conversion algorithm, with the same principle as the decimal to binary\
    \ algorithm except it works in the reverse direction.\nThe <code>rounded_avg</code>\
    \ function calls <code>counter</code> to get the sum of the numbers and divides\
    \ that by the number of numbers summed to get the average. This average is rounded\
    \ to the nearest integer and then converted to binary.\nCheers for any help!\n\
    \n\nA:\n\nYour <code>counter</code> function is not linear. From its definition,\
    \ it seems you are defining the sum of the integers from <code>n</code> to <code>m</code>\
    \ as follows:\n<code>f(n, m) = n + m + n + m - 1 + n + m - 2 + ... + n\n</code>\n\
    This is actually <code>n + (m - 1) + (m - 2) + ... + 1</code>, which is the sum\
    \ of the numbers from <code>1</code> to <code>", "  (if (&gt; n m)\n      -1\n\
    \      (b-&gt;i (b-&gt;s (i-&gt;b (round (/ (+ n m) 2)))))))\n", "  (cond [(<\
    \ n m) (rounded_avg_help n m)]\n        [else -1]))\n", "  (if (> n m)\n     \
    \ -1\n      (round (average n m))))\n", "  (if (> n m) -1\n      (round (/ (+\
    \ n m) 2))))\n", "  (if (&gt; n m)\n      -1\n      (bitwise-and (round (/ (+\
    \ n m) 2)) #b1111)))\n", "  (cond [(> n m) -1]\n        [else (fl (average n m))]))\n",
  "  (if (&gt; n m)\n      -1\n      (bytes-&gt;integer/signed\n       (bytes-copy\
    \ (integer-&gt;bytes (round (/ (+ n m) 2.0))) 3))))\n", "  (if (> n m)\n     \
    \ -1\n      (integer->binary (round (/ (+ n m) 2.0)))))\n", "  (if (> n m)\n \
    \     -1\n      (define (rounded_avg n m)\n        (if (> n m)\n            -1\n\
    \            (define (avg n m)\n              (/ (+ n m) 2))\n            (define\
    \ (avg_rounded n m)\n              (round (avg n m)))\n            (define (avg_rounded_bin\
    \ n m)\n              (number->string (avg_rounded n m) 2))\n            (avg_rounded_bin\
    \ n m))))\n  (rounded_avg 10 10))", "  (if (&gt; n m)\n      -1\n      (round\
    \ (average (list-&gt;vector (for/list ([i (in-range n (add1 m))]) i)))))\n  )\n",
  "  (let ([n-int (string->number (integer->string n))]\n        [m-int (string->number\
    \ (integer->string m))])\n    (if (> n m) -1\n        (let* ([avg-float (/ (+\
    \ n-int m-int) 2.0)]\n               [avg-int (round avg-float)])\n          (number->string\
    \ (string->number (integer->string avg-int) 2))))))\n", '  (round (/(+ n m) 2.0)))',
  "  (if (< n m)\n      (int->bin (round (/ (+ n m) 2)))\n      -1))\n", "  (if (&gt;\
    \ n m)\n      -1\n      (let ([avg (/ (+ n m) 2)])\n        (integer-&gt;binary\
    \ avg))))\n", "  (define (avg-helper n m acc)\n    (if (> n m)\n      acc\n  \
    \    (avg-helper (+ n 1) m (+ acc n))))\n  (define (bin n)\n    (cond ((= n 0)\
    \ 0)\n          ((= n 1) 1)\n          (else (+ (* 10 (bin (/ n 2))) (remainder\
    \ n 2)))))\n  (if (< n m)\n    (bin (round (/ (avg-helper n m 0) (- m n))))\n\
    \    -1))\n", "  (if (&gt; n m)\n      -1\n      (integer-&gt;binary (round (/\
    \ (+ n m) 2)))))\n", "  (if (> n m)\n      -1\n      (let ((avg (/ (+ n m) 2.0)))\n\
    \        (if (odd? avg)\n            (round avg)\n            (round (floor avg))))))",
  "  (if (&gt; n m)\n      -1\n      (round (/ (+ n m) 2.0))))\n", "  (cond\n    [(>\
    \ n m) -1]\n    [else (round (/ (+ n m) 2))]))\n", "  (cond\n    [(> n m) -1]\n\
    \    [else\n     (define avg (/ (+ n m) 2))\n     (exact->inexact (round avg))]))\n",
  "  (cond\n    ((> n m) -1)\n    (else (round (/ (+ n m) 2)))))", "  (cond [(< n\
    \ m) (define average (/ (+ n m) 2)) (round average)]\n        [else -1]))\n",
  "  (define lst (build-list n m))\n  (if (null? lst)\n      \"Error\"\n      (define\
    \ sum (apply + lst))\n      (define avg (/ sum (length lst)))\n      (define round\
    \ (/ (+ avg 0.5) 1))\n      (number->string (inexact->exact (round->inexact round))\
    \ 2)))\n", "  (define (helper n m avg)\n    (cond ((< n m) (helper (+ n 1) m (+\
    \ avg n)))\n          ((= n m) (quotient (+ avg n) (- m n)))\n          ((> n\
    \ m) -1)))\n  (integer->binary (helper n m 0)))\n", "  (define (round-to-nearest\
    \ x)\n    (cond ((< (- x (floor x)) 0.5) (floor x))\n          ((> (- x (floor\
    \ x)) 0.5) (ceiling x))\n          (else x)))\n  (cond ((> n m) -1)\n        (else\
    \ (round-to-nearest (/ (+ n m) 2)))))\n", "  (cond\n    [(> n m) -1]\n    [else\
    \ (build-bytes (int->integer (byte-round (/ (+ n m) 2))))]))\n", "  (local [(define\
    \ (gcd a b)\n            (cond [(= b 0) a]\n                  [else (gcd b (remainder\
    \ a b))]))\n          (define (lcm a b)\n            (// (abs (* a b)) (gcd a\
    \ b)))]\n    (lcm n m)))\n", "  (if (&gt; n m) -1\n      (integer-&gt;binary (round\
    \ (/ (+ n m) 2)))))", "  (if (&gt; n m) -1\n      (round (/ (+ n m) 2.0))\n  \
    \    )\n  )\n", "  (if (> n m)\n      -1\n      (inexact->exact (round (/ (+ n\
    \ m) 2.0)))))\n", "  (let ((avg (round (/ (+ n m) 2))))\n    (if (&gt; n m)\n\
    \        -1\n        (integer-&gt;binary avg))))\n", "  (define (calc_avg a b)\n\
    \    (define res (/ (+ a b) 2))\n    (if (&lt; res 1)\n        (res)\n       \
    \ (round res)))\n  (if (&gt; n m)\n      -1\n      (integer-&gt;binary (calc_avg\
    \ n m))))\n", "  (if (< n m)\n      (round (/ (+ n m) 2))\n      -1))\n", "  (if\
    \ (&gt; n m)\n      -1\n      (integer-&gt;binary (round (/ (+ n m) 2)))))\n",
  "  (round (/ (+ n m) 2)))\n", "  (cond [(> n m) -1]\n        [else (integer->binary\
    \ (round (/ (+ n m) 2.0)))]))\n", "  (cond [(> n m) -1]\n        [else (bin->number\
    \ (number->string\n                            (round (/ (+ n m) 2.0))\n     \
    \                       2))]))\n", "  (if (&gt; n m) -1\n      (round (/ (+ n\
    \ m) 2))))\n", "  (let ([n-bin (number->string n 2)]\n        [m-bin (number->string\
    \ m 2)])\n    (display \"n_bin: \")\n    (display n-bin)\n    (display \"\\n\"\
    )\n    (display \"m_bin: \")\n    (display m-bin)\n    (display \"\\n\")\n   \
    \ (display \"sum: \")\n    (display (+ n m))\n    (display \"\\n\")\n    (display\
    \ \"sum/2: \")\n    (display (/ (+ n m) 2))\n    (display \"\\n\")\n    (display\
    \ \"sum/2 rounded: \")\n    (display (round (/ (+ n m) 2)))\n    (display \"\\\
    n\")\n    (display \"sum/2 rounded to binary: \")\n    (display (number->string\
    \ (round (/ (+ n m) 2)) 2))\n    (display \"\\n\")\n    (if (> n m) -1 (number->string\
    \ (round (/ (+ n m) 2)) 2))))\n", "  (if (&gt; n m)\n      -1\n      (integer-&gt;binary\
    \ (round (/ (+ n m) 2)))))\n", "  (if (&gt; n m)\n      -1\n      (inexact-&gt;exact\
    \ (round (/ (+ n m) 2)))))\n", "  (if (> n m)\n      -1\n      (bytes->integer/signed\
    \ (number->string (/ (round \n                                               \
    \   (+ n m)) 2) 2))))\n", "  (define (i2b n)\n    (let loop ([n n] [r '()])\n\
    \      (cond\n        [(= n 0) (reverse r)]\n        [else (loop (quotient n 2)\
    \ (cons (remainder n 2) r))])))\n  (cond\n    [(> n m) -1]\n    [else (i2b (round\
    \ (/ (+ n m) 2.0)))]))\n", "  (define d (- m n))\n  (define avg (+ (* d (/ 1 2.0))\
    \ n))\n  (if (< n m)\n      (define avg (+ avg (/ 1 2.0)))\n      (define avg\
    \ (-1)))\n  (define b (integer->byte-string (round avg) 2))\n  (bytes->string/utf-8\
    \ b))\n", "  (if (> n m)\n      -1\n      (local [(define (average-of-n-to-m n\
    \ m)\n                (/ (+ n m) 2))]\n        (integer->binary (round (average-of-n-to-m\
    \ n m))))))", "  (define (rounded_average_binary a b)\n    (round ( / (+ a b)\
    \ 2.0 )))\n  (cond [(> n m) '-1]\n        [else (integer->binary (rounded_average_binary\
    \ n m))]))\n", "  (if (> n m)\n      -1\n      (round (/ (+ n m) 2))))\n", " \
    \ (if (&gt; n m)\n      -1\n      (integer-&gt;binary (round (/ (+ n m) 2)))))",
  "  (if (&gt; n m)\n      -1\n      (round (floor (/ (+ n m) 2)))))\n", "  (let ([avg\
    \ (round (/ (+ n m) 2))])\n    (if (> n m)\n        -1\n        (integer->binary\
    \ avg))))\n", "  (if (> n m) -1\n      (let ([sums (- m n)])\n        (list->string\
    \ (list->string (number->string (round (/ (+ n m) 2))) 2)))))\n", "  (if (< n\
    \ m)\n      (let* ([sum (+ n m)]\n             [r (+ (modulo sum 2) (/ sum 2))])\n\
    \        (format \"~b\" r))\n      -1))", "  (define (helper n m)\n    (if (&gt;\
    \ n m)\n        -1\n        (begin\n          (define sum (add1 (+ n m)))\n  \
    \        (define avg (/ sum 2))\n          (define round_avg (round avg))\n  \
    \        (integer-&gt;binary round_avg))))\n  (helper n m))\n", "  (if (&gt; n\
    \ m)\n      -1\n      (round (/ (+ n m) 2))))", "  (if (> n m)\n      -1\n   \
    \   (let* ([sum (+ n m)]\n             [avg (/ sum 2.0)]\n             [avg-i\
    \ (round avg)])\n        (number->string avg-i 2))))\n", "  (if (> n m)\n    \
    \  -1\n      (round (average (list-range n m)))))\n", "  (if (&gt; n m) -1\n \
    \   (round\n     (/ (+ n m) 2))))\n", "  (if (&gt; n m) -1\n      (let ([avg (+\
    \ n m)])\n        (/ avg 2)\n        (integer-&gt;binary (/ avg 2)))))\n</code>\n\
    \nYou may find it useful to use helper procedures.  \nIn a procedure (like <code>+</code>\
    \ or <code>-</code>), the symbol <code>/</code> is an infix operator.\nBut if\
    \ you are calling a procedure (like <code>/</code> in <code>(/ avg 2)</code>),\
    \ it is a prefix operator.\nIn a procedure, <code>#:key</code> is special syntax.\n\
    It isn't special in other contexts.\n\nIf you aren't sure which procedures to\
    \ use, you can use <code>raco docs</code> or <code>racket/base</code> to find\
    \ what you need.\nIf you aren't sure which library to look in, you can use <code>raco\
    \ docs</code> with no arguments to search all libraries.\n", "  (cond [(< n m)\
    \ (fx2b (round (fx/ (fx+ n m) 2)))]\n        [else -1]))\n", "  (if (> n m)\n\
    \      -1\n      (integer->binary\n       (round\n        (/\n         (+ n m)\n\
    \         2)))))\n", "  (define average (/ (+ n m) 2))\n  (if (> n m)\n      -1\n\
    \      (binary-string->list (list->binary-string (+ average 0.5)))))\n", "  (if\
    \ (< n m)\n      (inexact->exact (round (/ (+ n m) 2)))\n      -1))\n", "  (if\
    \ (> n m)\n      -1\n      (binary (round (/ (+ n m) 2)))))\n", "  (let* ([avg\
    \ (/ (+ n m) 2.0)]\n         [avg-as-int (round avg)])\n    (if (&gt; n m) -1\
    \ avg-as-int)))\n", "  (cond\n    [(> n m) -1]\n    [else\n      (define average\
    \ (/ (+ n m) 2))\n      (format \"~a\" (number->string average 2))]))\n", "  (cond\
    \ [(> n m) -1]\n        [else (round (/ (+ n m) 2))]))\n", "  (define average\
    \ (/ (+ n m) 2))\n  (cond ((&gt; n m)\n         #-1)\n        (else\n        \
    \ (number-&gt;string (exact-round average) 2))))\n", "  (let ([avg (round (/ (+\
    \ n m) 2))])\n    (when (&gt;= n m)\n      -1)\n    (number-&gt;string avg 2)))\n\
    </code>\nI also tried this version:\n<code>#lang racket\n", "  (define (int-to-bin\
    \ i)\n    (cond\n      [(= i 0) '()]\n      [else (append (int-to-bin (quotient\
    \ i 2)) (list (remainder i 2)))]))\n  (define (bin-to-str b)\n    (cond\n    \
    \  [(null? b) \"\"]\n      [else (string-append (bin-to-str (cdr b)) (number->string\
    \ (car b)))]))\n  (cond\n    [(> n m) -1]\n    [else (bin-to-str (int-to-bin (/\
    \ (+ n m) 2)))]))", "  (if (> n m) -1\n      (round (/ (+ n m) 2.0))))\n", " \
    \ (define (avg x y)\n    (quotient (+ x y) 2))\n  (define (to-bin x)\n    (cond\
    \ ((= x 0) '())\n          ((= (remainder x 2) 0) (cons 0 (to-bin (quotient x\
    \ 2))))\n          (else (cons 1 (to-bin (quotient x 2))))))\n  (if (> n m) -1\n\
    \      (to-bin (round (avg n m)))))\n", "  (if (< n m)\n      (string->number\
    \ (number->string (round (/ (+ n m) 2))) 2)\n      -1))", "  (define (ceiling/towards-negative\
    \ d)\n    (- (floor d) 1))\n  (define (rounded-average n m)\n    (exact->inexact\
    \ (/ (floor (+ (ceiling/towards-negative\n                                   \
    \ (/ n 1.0))\n                                 (floor (/ m 1.0))))\n         \
    \              2)))\n  (define (to-binary n)\n    (cond ((= n 0) \"\")\n     \
    \     ((= n 1) \"1\")\n          (else (let ((rem (modulo n 2)))\n           \
    \       (string-append (to-binary (/ n 2))\n                                 (number->string\
    \ rem))))))\n  (cond ((> n m) -1)\n        (else (let ((avg (rounded-average n\
    \ m)))\n                (to-binary avg)))))\n", "  (if (> n m)\n      -1\n   \
    \   (round (/ (+ n m) 2))))\n", "  (if (&gt; n m)\n      -1\n      (integer-&gt;binary\
    \ (round (/ (+ n m) 2)))))\n", "  (displayln n)\n  (displayln m)\n  (define avg_int\
    \ \n    (round (/ (+ n m) 2.0)))\n  (displayln avg_int)\n  (cond ((> n m) -1)\n\
    \        (else (decimal->bignum avg_int 2))))\n", "  (define (avg-of-ints n m)\n\
    \    (/ (+ n m) 2.0))\n  (define (avg-to-binary x)\n    (number->string (inexact->exact\
    \ (round x)) 2))\n  (cond [(> n m) -1]\n        [else (avg-to-binary (avg-of-ints\
    \ n m))]))\n", "  (if (&gt; n m) -1\n      (binary (round (/ (+ n m) 2)))))\n",
  "  (if (> n m) -1 (string->number (number->string (round (/ (+ n m) 2)) 2))))\n",
  "  (let [m+1 (+ m 1)]\n    (if (> n m)\n      -1\n      (logand (round (average\
    \ m+1 n)) 255))))", "  (cond\n    [(> n m) -1]\n    [else (let ([sum (+ n m)])\
    \ (number->string (round (/ sum 2))))]))\n", "  (if (&gt; n m) -1\n      (integer-&gt;binary\
    \ (round (/ (+ n m) 2)))))\n</code>\n", "  (if (> n m) -1\n      (number->string\
    \ (round (/ (+ n m) 2)) 2)))\n", "  (if (> n m) -1 (define average (/ (+ n m)\
    \ 2)) (define binary\n                                                 (number->string\
    \ (round average) 2))\n                                                 (string->number\
    \ binary)))\n", "  (cond ((< n m) (rounded_avg m n))\n        ((= n m) (bitwise\
    \ (round (/ n 2))))\n        (else (bitwise (round (/ (+ n m) 2))))))\n", "  (if\
    \ (> n m)\n      -1\n      (integer->binary (round (/ (+ n m) 2)))))", "  (if\
    \ (< n m)\n      (round (/ (+ n m) 2))\n      -1))\n", "  (cond [(> n m) -1]\n\
    \        [else (bitwise-arithmetic-shift-right (round (/ (+ n m) 2)) 1)]))\n",
  "  (define (num->bin n)\n    (if (= n 0)\n      #f\n      (cons (even? n) (num->bin\
    \ (quotient n 2)))))\n  (define (bin->num bs)\n    (foldl (lambda (e acc) (+ (*\
    \ 2 acc) (if e 1 0))) 0 bs))\n  (cond\n    [(> n m) -1]\n    [else (bin->num (num->bin\
    \ (/ (+ n m) 2)))]))", "  (local [(define (helper sum count)\n            (cond\
    \ [(> n m) -1]\n                  [(= n m) (round (/ sum count))]\n          \
    \        [else (helper (+ sum n) (+ count 1))]))]\n    (helper (+ n m) 2)))\n",
  "  (round (/ (+ n m) 2)))\n", "  (cond\n    [(> n m) -1]\n    [else (integer->binary\
    \ (round (/ (+ n m) 2)))]))\n", "  (cond [(> n m) -1]\n        [else (define a\
    \ (round (/ (+ n m) 2)))\n              (display (i32->b a))]))\n", "  (local\
    \ [(define (avg-helper n m running)\n            (cond [(> n m) running]\n   \
    \               [else (avg-helper (+ n 1) m (+ running n))]))]\n    (define avg-sum\
    \ (/ (avg-helper n m 0) (- m n)))\n    (define avg-int (round avg-sum))\n    (number->string\
    \ avg-int 2)))\n", "  (define avg\n    (let loop ([i n] [sum 0] [count 0])\n \
    \     (if (&gt; i m)\n          (/ sum count)\n          (loop (+ i 1) (+ sum\
    \ i) (+ count 1)))))\n  (define result\n    (integer-&gt;binary (round avg)))\n\
    \  (if (and (positive? n) (positive? m))\n      result\n      -1))\n", "  (let*\
    \ ([integers (build-list (- m n)\n                               (lambda (x) (+\
    \ n x)))]\n         [average (integer->binary (round (/ (apply + integers)\n \
    \                                            (length integers))))])\n    (if (&gt;\
    \ n m) -1 average)))", "  (cond [(> n m) -1]\n        [else (round (/ (+ n m)\
    \ 2))]))\n", "  (define (average n m)\n    (/ (+ n m) 2))\n  (define (convert-to-binary\
    \ n)\n    (if (= n 0)\n        '()\n        (cons (remainder n 2) (convert-to-binary\
    \ (quotient n 2)))))\n  (if (&gt; n m)\n      -1\n      (convert-to-binary (round\
    \ (average n m)))))", "  (if (&gt; n m)\n      -1\n      (round (/ (+ n m) 2.0))\n\
    \      )\n  )\n", "  (cond [(> n m) -1]\n        [else (rint (average n m))]))\n",
  "  (cond\n    [(> n m) -1]\n    [else (define (avg-int lo hi)\n            (/ (+\
    \ lo hi) 2))\n     (define (avg-float lo hi)\n       (/ (+ lo hi) 2.0))\n    \
    \ (define (round-float n)\n       (cond\n         [(> n 0) (floor (+ n 0.5))]\n\
    \         [else (ceiling (+ n 0.5))]))\n     (define (to-binary n)\n       (cond\n\
    \         [(zero? n) '()]\n         [else (cons (modulo n 2) (to-binary (quotient\
    \ n 2)))]))\n     (define rounded (round-float (avg-float n m)))\n     (to-binary\
    \ rounded)]))\n", "  (round (/ (+ n m) 2.0)))\n", "  (define ans (round (/ (+\
    \ n m) 2)))\n  (displayln (if (&gt; n m) -1 ans))\n  (if (&gt; n m) -1 (integer-&gt;binary\
    \ ans)))\n</code>\nMy solution is not considered correct by codeeval. What am\
    \ I doing wrong?\n\n\nA:\n\nI believe this should do the trick:\n<code>#lang racket\n",
  "  (let ((avg  (round (/ (+ n m) 2.0))))\n    (if (> n m)\n        -1\n        (integer->string\
    \ (exact->inexact avg) 2))))\n", "  (cond [(> n m) -1]\n        [else     (round\
    \ (/ (+ n m) 2))]))", "  (cond\n    [(> n m) -1]\n    [else (exact->inexact (round\
    \ (/ (+ n m) 2)))]))\n", "  (if (&gt; n m)\n      -1\n      (build-string (round\
    \ (/ (+ n m) 2)) #\\#)))", "  (cond ((> n m) -1)\n        (else (round (floor\
    \ (/ (+ n m) 2))))))", "    (cond\n      [(&gt; n m) -1]\n      [else (number-&gt;string\
    \ (round (/ (+ n m) 2)) 2)]))", "  (if (&gt; n m) -1\n      (define out (round\
    \ (/ (+ n m) 2)))\n      (number-&gt;string out 2)))\n</code>\nAm I doing something\
    \ wrong here?\n\n\nA:\n\nIn Racket, <code>&gt;</code> expects two numerical arguments,\
    \ or at least something that looks like a number (e.g. a <code>complex</code>).\
    \ You're passing it a <code>string</code>, and I'm guessing that's an error.\n\
    In any case, the error message is telling you precisely what's wrong, so you just\
    \ need to open the file <code>base/number.rkt</code> and see what's happening.\
    \ In this case, you will find that the <code>&gt;</code> procedure is defined\
    \ to call <code>real-part</code> on both arguments, then call <code>&gt;</code>\
    \ again, using the result of <code>real-part</code> as the arguments.\nSo, the\
    \ error message tells you that <code>&gt;</code> was invoked on something that's\
    \ not a number, and the module that implements it (<code>base/number.rkt</code>)\
    \ tells you why: you called <code>&gt;</code> directly with a string.\n", "  (let*\
    \ ([avg (/ (+ n m) 2.0)]\n         [rounded (round avg)])\n    (if (> n m) -1\
    \ (number->string rounded 2))))\n", "  (if (< n m)\n      (rounded_avg/+ n m)\n\
    \      -1))", "  (if (&gt; n m)\n      -1\n      (define average \n        (cond\n\
    \          [(= n m)  (+ n m)]\n          [(even? n)  (/ (+ n m) 2)]\n        \
    \  [(even? m)  (/ (+ n m) 2)]\n          [else       (/ (+ n m 1) 2)]))\n    \
    \  (number-&gt;string (inexact-&gt;exact (round average)) 2)))\n", "  (if (< n\
    \ m)\n      (binary-string (round (/ (+ n m) 2)))\n      -1))\n", "  (if (&gt;\
    \ n m)\n      -1\n      (integer-&gt;binary\n       (round (/ (+ n m) 2)))))\n\
    </code>\nTest case:\n<code>(check-expect (rounded_avg 2 6) 11)", "  (if (> n m)\n\
    \      -1\n      (integer->binary (round (/ (+ n m) 2)))))\n", "  (cond [(> n\
    \ m) -1]\n        [else \n         (number->string (round (/ (+ n m) 2)) 2)]))\n",
  "  (if (> n m)\n      -1\n      (round (/ (+ n m) 2))))\n", "  (if (> n m)\n   \
    \   -1\n      (integer->binary\n       (round\n        (/ (+ n m) 2)))))", " \
    \ (round (/ (+ n m) 2.0)))\n", "  (cond\n    [(> n m) -1]\n    [else (quotient\
    \ (+ n m) 2)]))", "  (let* ([rounded-avg (round (/ (+ n m) 2))]\n         [binary-str\
    \ (number->string rounded-avg 2)])\n    (if (> n m) -1\n        (string->number\
    \ binary-str 2))))\n", "  (display n)\n  (newline)\n  (display m)\n  (newline)\n\
    \  (if (> n m)\n      -1\n      (round (/ (+ n m) 2))))\n", "    (round \n   \
    \     (/\n            (+ n m) 2) \n        0))\n", "  (if (> n m) -1\n      (integer->binary\
    \ (round (/ (+ n m) 2)))))\n", "    (define x \n    (round (/ (+ n m) 2.0)))\n\
    \    (integer->binary x))\n</code>\n", "  (if (&gt; n m)\n      -1\n      (let*\
    \ ([sum (+ n m)]\n             [avg (round (/ sum 2))]\n             [bin-str\
    \ (integer-&gt;string (exact-&gt;inexact avg) 2)])\n        bin-str)))", "  (if\
    \ (< n m)\n      (define avg (/ (+ n m) 2))\n      (-1))\n  (convert-base avg\
    \ 2))\n", "  (if (> n m)\n      #b1111111111111111111111111111111111111111111111111111111111111111\n\
    \      (define decimal-integer (flround (/ (+ n m) 2)))\n      (integer->binary\
    \ decimal-integer)))\n", "  (define avg (round (/ (+ n m) 2)))\n  (if (&gt; n\
    \ m) -1\n      (number-&gt;string (integer-&gt;char avg) 2)))\n", "  (cond\n \
    \   [(> n m) -1]\n    [else (round (/ (+ n m) 2))]))\n", "  (if (&gt; n m)\n \
    \     -1\n      (integer-&gt;binary (round (/ (+ n m) 2)))))\n</code>\nI think\
    \ this is a little cleaner.  It's linear in the number of bits in the result.\n",
  "  (if (> n m)\n      -1\n      (display-base (~r 10 (round (average (range n m)))))\n\
    \      (newline)\n      ))\n", "  (cond\n    [(< n m) (rational-to-binary (round\
    \ (/ (+ n m) 2.0)))]\n    [else -1]))", "  (if (&gt; n m)\n      -1\n      (let*\
    \ ((sum (apply + (build-list (add1 (- m n)) (lambda (x) (add1 n))))))\n      \
    \  (if (even? (/ sum (- m n)))\n            (floor (/ sum (- m n)))\n        \
    \    (ceiling (/ sum (- m n)))))))\n", "  ;;round to nearest int\n  (define (round\
    \ x) (if (< x 1) 0\n                       (if (> x (- (expt 2 (floor (log x 2)))\
    \ 1)) (expt 2 (floor (log x 2)))\n                           (let ((base (expt\
    \ 2 (floor (log x 2) -1))))\n                             (if (>= x (+ base (/\
    \ base 2))) (+ base base) base)))))\n  ;;average of n to m\n  (if (> n m) -1\n\
    \      (if (= n m) (round n)\n          (round (/ (+ n m) 2.0)))))\n", "  (cond\
    \ ((> n m) -1)\n        (else (let* ([sum (+ n m)]\n                     [avg\
    \ (/ sum 2.0)]\n                     [round-avg (round avg)])\n              \
    \  (binary round-avg)))))", "  (cond [(> n m) -1]\n        [else\n         (let*\
    \ ([avg (/ (+ n m) 2.0)]\n                [rounded (round avg)])\n           (binary\
    \ rounded))]))\n", "  (cond ((&gt; n m) -1)\n        (else (binary-&gt;integer\n\
    \               (number-&gt;string\n                (round-&gt;exact\n       \
    \          (inexact-&gt;exact\n                  (/ (+ n m) 2))))))))\n</code>\n\
    In Racket:\n<code>#lang racket\n", "  (if (> n m)\n      -1\n      (let ([l (for/list\
    \ ([x (in-range n (+ m 1))]) x)])\n        (string->number (number->string (round\
    \ (apply + l) (/ (length l) 2))) 2))))\n", "  (if (&gt; n m)\n      -1\n     \
    \ (round (/ (+ n m) 2))))\n", "  ;; We round the answer to the nearest integer\
    \ and convert that to binary.\n  (define (to-binary n)\n    (if (= n 0)\n    \
    \    empty\n        (cons (remainder n 2)\n              (to-binary (quotient\
    \ n 2)))))\n  ;; We start with integer division and then round\n  (define (rounded-integer-division\
    \ n m)\n    (round (/ (+ n m) 2)))\n  ;; We now return the binary representation\
    \ of rounded-integer-division n m\n  (to-binary (rounded-integer-division n m)))\n\
    </code>\n", "  (let ([average (integer-bytes (round (/ (+ n m) 2)) 'big)])\n \
    \   (if (and (integer? n) (integer? m) (> n m))\n        '(0 1 1 1)\n        average)))\n",
  "  (define avg (+ n m))\n  (define avg-bin (integer->binary (/ avg 2)))\n  (cond\
    \ ((> n m) -1)\n        (else avg-bin)))\n", "  (if (< n m)\n      (- 1)\n   \
    \   (round (/ (+ n m) 2))))\n", "  (if (&gt; n m)\n      -1\n      (integer-&gt;binary\
    \ (round (/ (+ n m) 2)))))\n</code>\nTest case:\n<code>(test (rounded_avg 1 2)\
    \ 10)", "  (cond [(> n m) -1]\n        [else (floor (round (average n m)) 2)]))\n",
  "  (let* ((avg (round (/ (+ n m) 2)))\n         (ret (integer->binary avg)))\n \
    \   (cond\n      [(> n m) -1]\n      [else ret])))\n", "  (let ([n (integer->binary\
    \ (round (/ (+ n m) 2.0))))])\n    (if (&gt; n m)\n        -1\n        n)))\n\
    </code>\n", "  (displayln \"Bin: \" (byte->string/utf8 (binary-read #b10)))\n\
    \  (byte->string/utf8 (binary-read #b10)))\n", "  (if (&gt; n m)\n      -1\n \
    \     (integer-&gt;binary (round (/ (+ n m) 2)))))\n</code>\n", "  (cond\n   \
    \ [(> n m) -1]\n    [else\n     (define avg (/ (+ n m) 2))\n     (define avg-rounded\
    \ (round avg))\n     (number->string (integer->binary avg-rounded))]))\n", " \
    \ (if (&gt; n m) -1\n      (let [(average (+ n m) (/ 2))]\n        (exact-&gt;inexact\
    \ (round (exact-&gt;inexact average))))))\n</code>\nThis is my code so far. But\
    \ when I run it, it returns the wrong answer.\nI'm not sure if I'm making an error\
    \ in the use of the round function.\n<code>&gt; (rounded_avg 3 5)\n3\n</code>\n\
    This is the error I get. The expected answer is 4.\n\n\nA:\n\nThere are some problems\
    \ in your code. The first one is with the use of <code>let</code>, it should be\
    \ as follows:\n<code>(let [(average (/ (+ n m) 2))]\n  ...)\n</code>\nThe other\
    \ problem is that <code>round</code> by default rounds to the nearest integer,\
    \ but for your case you need the one that rounds to the floor of the number, not\
    \ the ceiling:\n<code>(define (rounded_avg n m)\n  (if (&gt; n m) -1\n      (let\
    \ [(average (/ (+ n m) 2))]\n        (floor (exact-&gt;inexact average)))))\n\
    </code>\n", "  (round ( / ( + n m ) 2.0 ) ) )\n", "  (if (< n m)\n      (integer->binary\
    \ (round (/ (+ n m) 2)))\n      -1))", "  (define nums\n    (for/list ([i (in-range\
    \ n m)])\n      i))\n  (define avg\n    (round (/ (apply + nums)\n           \
    \   (length nums))))\n  (define (decimal->binary n)\n    (if (= n 0)\n       \
    \ '()\n        (cons (remainder n 2)\n              (decimal->binary (quotient\
    \ n 2)))))\n  (define bin-avg\n    (reverse (decimal->binary avg)))\n  (if (<\
    \ n m)\n      bin-avg\n      -1))", "  (if (< n m)\n      (quotient (+ n m) 2)\n\
    \      -1))\n", "  (if (&gt; n m) -1\n      (let* ([avg (round (/ (+ n m) 2))]\n\
    \             [bin (number-&gt;string avg 2)])\n        (string-append \"#b\"\
    \ bin))))\n</code>\nObviously, I'm using Racket, because that's the language I\
    \ know.  I'm also using an intermediate variable, <code>avg</code> to store the\
    \ average in.  It isn't strictly necessary to use it, but it is useful to me for\
    \ readability.\nI'm also a little bothered by the fact that my output is not exactly\
    \ the same as yours.  If I compute the average of 1 and 2 I get <code>#b1</code>\
    \ not <code>#b10</code>.  There's a good reason for that.  If you average 1 and\
    \ 2 you get <code>1.5</code> which rounds to <code>2</code>.  I'm not sure what\
    \ your code does (you didn't provide it) but perhaps it rounds to the nearest\
    \ even number.  You can do that with a call to <code>modulo</code>:\n<code>(define\
    \ (rounded_avg n m)\n  (if (&gt; n m) -1\n      (let* ([avg (round (/ (+ n m)\
    \ 2))]\n             [bin (number-&gt;string avg 2)])\n        (string-append\
    \ \"#b\" (number-&gt;string (if (zero? (modulo avg 2)) avg (add1 avg)) 2)))))\n\
    </code>\nThat code gets me <code>#b10</code> for <code>(rounded_avg 1 2)</code>.\n\
    I'll add that the code you posted doesn't work as written.  You have a <code>#true</code>\
    \ in there.  I'm assuming that's a typo.\n", '  (round (/ (+ n m) 2.0)))', " \
    \ (define (rounded_avg_helper n m)\n    (if (= n m)\n        n\n        (+ (/\
    \ (+ n m) 2) (if (zero? (modulo (+ n m) 2)) 0 1))))\n  (cond ((> n m) -1)\n  \
    \      (else (integer->binary (rounded_avg_helper n m)))))\n", "  (if (&gt; n\
    \ m) -1\n      (fxarithmetic-shift (fx+ n m) 1)))\n", "  (if (&gt; n m)\n    \
    \  -1\n      (integer-&gt;binary\n       (round (/ (apply + (range n m))\n   \
    \              (- m n 1))))))\n</code>\nBut I get the error:\n<code>syntax-case:\
    \ parse error in function template\n\n  expecting a function name\n</code>\nWhat\
    \ am I doing wrong?\n\n\nA:\n\nYou want to use <code>define</code> instead of\
    \ <code>define-syntax</code>\n", "  (let ([res (/ (+ n m) 2)])\n    (if (zero?\
    \ (remainder res 1))\n        (integer->binary res)\n        (integer->binary\
    \ (inexact->exact (round res))))))\n", "  (define a (+ n m))\n  (define b (/ a\
    \ 2))\n  (if (> n m)\n      -1\n      (number->string b 2)))\n", "  (if (&gt;\
    \ n m)\n      -1\n      (binary (round (/ (+ n m) 2)))))\n", "  (if (&gt; n m)\n\
    \      -1\n      (define sum (* (- n 1) n))\n      (define avg (quotient sum 2))\n\
    \      (number-&gt;string (round avg) 2)))\n</code>\nI am not sure why I am getting\
    \ so many errors. Thank you for taking a look!\n\n\nA:\n\n<code>#lang racket\n",
  "  (if (> n m)\n      #b-1\n      (string->number (substring/shared (number->string\
    \ (round (/ (+ n m) 2))) 2) 2)))\n", "  (if (< n m)\n      (round\n       (/ (+\
    \ n m) 2))\n      -1))", "  (define (round x)\n    (round (/ (+ x (/ 1 2)) 1)))\n\
    \  (define (average lst)\n    (round (/ (apply + lst) (length lst))))\n  (define\
    \ (to-bin n)\n    (cond ((= n 0) '())\n          ((= (remainder n 2) 0) (cons\
    \ 0 (to-bin (/ n 2))))\n          (else (cons 1 (to-bin (/ n 2))))))\n  (cond\
    \ ((> n m) -1)\n        (else (to-bin (average (range n m))))))", "  (cond [(&gt;\
    \ n m) -1]\n        [else\n         (let [(avg (round (/ (+ n m) 2.0)))\n    \
    \           (bin-avg (number-&gt;string avg 2))]\n           (string-append \"\
    0b\" bin-avg))]))\n", "  (cond\n    [(> n m) -1]\n    [else (racket-binary (round\
    \ (/ (+ n m) 2)))]))\n", "  (round (/ (+ n m) 2)))\n", "  (cond [(> n m) -1]\n\
    \        [else (round (/ (+ n m) 2))]))\n", "  (cond ((> n m) -1)\n        (else\
    \ (round (/ (+ n m) 2)))))\n", "  (if (> n m)\n      -1\n      (define (helper\
    \ n m acc)\n        (if (= n m)\n            (if (= n 1)\n                acc\n\
    \                (define (helper2 n m acc current)\n                  (if (= n\
    \ m)\n                      current\n                      (helper2 (+ n 1) m\
    \ acc (+ current n))))\n            (helper2 (+ n 1) m acc (+ acc n))))\n    \
    \    (helper n m 0)))", "  (if (> n m)\n      -1\n      (round (/ (+ n m) 2.0))\n\
    \      )\n  )\n", "  (if (> n m)\n      -1\n      (round (/ (+ n m) 2.0))))\n",
  "  (if (&gt; n m)\n      -1\n      (string-&gt;integer (string-pad-left (integer-&gt;string\
    \ (round (/ (+ n m) 2))) '0 3) 2)))\n", "  (if (&gt; n m)\n      -1\n      (round\
    \ (/ (+ n m) 2))))\n", "  ;; test for n > m\n  (if (> n m)\n      -1\n      ;;\
    \ if n <= m, use other function to compute average, round to nearest integer,\
    \ and convert to binary\n      (dec2bin (round (average_int n m)))))\n", "  (when\
    \ (&gt; n m)\n    -1)\n  (cond\n    [(= m n) (list-&gt;bin (round n))]\n    [else\
    \ (list-&gt;bin (round (/ (+ m n) 2)))]))\n", '  (round ( / (+ n m) 2)))', " \
    \ (cond [(> n m) -1]\n        [else (number->string (round ( / (+ n m) 2.0)))\
    \ ]))\n", "  (cond\n    [(> n m) -1]\n    [else (round (/ (+ n m) 2))]))", " \
    \ (if (> n m) -1\n      (if (= n m) (inexact->exact (floor (sqrt (+ (exact->inexact\
    \ n) (exact->inexact m)))))\n          (exact->binary (inexact->exact (floor (/\
    \ (+ (exact->inexact n) (exact->inexact m)) 2)))))))", "  (if (&gt; n m)\n   \
    \   -1\n      (let ((avg (round (/ (+ n m) 2))))\n        (number-&gt;string avg\
    \ 2))))\n</code>\n", "  (if (&gt; n m) -1\n      (number-&gt;string (round (apply\
    \ + (range n (+ m 1)))) 2)))\n</code>\n", "  (if (> n m) -1\n      (->> (for/list\
    \ ([k (in-range n (add1 m))]) k)\n           (apply +)\n           (/ (sub1 m)\
    \ n)\n           (round)\n           (integer->binary))))\n", "  (let ([avg (integer-round\
    \ (/ (+ n m) 2))])\n    (if (&gt; n m)\n        -1\n        (number-&gt;string\
    \ avg 2))))\n", "  (cond\n    [(> n m) -1]\n    [else (convert-to-binary (round\
    \ (/ (+ n m) 2)))]))\n", "  (if (< n m)\n      (bin->int\n       (round (integer->real\
    \ (/ (int->bin (exact->inexact (+ n m) 0)) 2))))\n      -1))", "  (if (< n m)\n\
    \      (number->string (round (/ (+ n m) 2)))\n      -1))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
