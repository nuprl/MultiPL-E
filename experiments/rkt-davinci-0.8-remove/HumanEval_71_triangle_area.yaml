name: HumanEval_71_triangle_area
language: rkt
prompt: "#lang racket\n\n;; Given the lengths of the three sides of a triangle. Return\
  \ the area of\n;; the triangle rounded to 2 decimal points if the three sides form\
  \ a valid triangle. \n;; Otherwise return -1\n;; Three sides make a valid triangle\
  \ when the sum of any two sides is greater \n;; than the third side.\n;; Example:\n\
  (define (triangle_area a b c)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n\
  \    (check-equal? (candidate 3 4 5) 6.0)\n    (check-equal? (candidate 1 2 10)\
  \ -1)\n    (check-equal? (candidate 4 8 5) 8.18)\n    (check-equal? (candidate 2\
  \ 2 2) 1.73)\n    (check-equal? (candidate 1 2 3) -1)\n    (check-equal? (candidate\
  \ 10 5 7) 16.25)\n    (check-equal? (candidate 2 6 3) -1)\n    (check-equal? (candidate\
  \ 1 1 1) 0.43)\n    (check-equal? (candidate 2 2 10) -1)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(< a 0) -1]\n    [(< b 0) -1]\n    [(< c 0) -1]\n   \
    \ [(> (+ a b) c)\n     (round (* (sqrt (+ (- (* a a) (* b b)) (* c c))) 0.5) 2)]\n\
    \    [else -1]))\n", "  (cond\n    [(>= (+ a b) c) (- a b c)]\n    [(>= (+ a c)\
    \ b) (- a c b)]\n    [(>= (+ b c) a) (- b c a)]\n    [else -1]))\n", "    (define\
    \ (is-triangle a b c)\n        (and (not (= a 0)) (not (= b 0)) (not (= c 0))\
    \ (> (+ a b) c) (> (+ a c) b) (> (+ b c) a)))\n    (if (is-triangle a b c)\n \
    \       (round (sqrt (* (- (+ a b c) (/ a 2)) (- (- (+ a b c) (/ b 2)) a) (- (-\
    \ (+ a b c) (/ c 2)) b))) 2)\n        -1))\n", "  (let\n      ([s (/ (+ a b c)\
    \ 2)])\n    (define (check)\n      (and (>= a s) (>= b s) (>= c s)))\n    (cond\
    \ [(check)\n           (round (* s (- s a) (- s b) (- s c)) 2)]\n          [else\
    \ -1])))\n", "  (cond [(or (< a 0) (< b 0) (< c 0)) -1]\n        [(or (> a (+\
    \ b c)) (> b (+ a c)) (> c (+ a b))) -1]\n        [else (* 0.5 (- (* a b c) (+\
    \ (sqr a) (sqr b) (sqr c))))]))\n", "  (define (invalid-length? a b c)\n    (and\
    \ (&lt;= a 0) (&lt;= b 0) (&lt;= c 0)))\n  (cond\n    [(invalid-length? a b c)\
    \ -1]\n    [(&lt;= a (+ b c)) -1]\n    [(&lt;= b (+ a c)) -1]\n    [(&lt;= c (+\
    \ a b)) -1]\n    [else\n     (round (* (sqrt (- (* (- (+ (* a a) (* b b)) (* c\
    \ c)) (* 2 (* a b) (* a c) (* b c)))) 0.5) 100))]))\n</code>\n", "  (if (and (<\
    \ (+ a b) c) (< (+ a c) b) (< (+ b c) a))\n      -1\n      (round (* 0.5 (- (+\
    \ a b c) (max a (max b c)))) 2)))", "  (cond\n    [(> (+ a b) c) (exact->inexact\
    \ (/ (+ (* a (sqrt (+ (* b b) (* c c))))\n                                   \
    \     (* b (sqrt (+ (* a a) (* c c))))\n                                     \
    \   (* c (sqrt (+ (* a a) (* b b)))))\n                                     2))]\n\
    \    [else -1]))\n", "  (cond [(and (&gt;= a 0)\n              (&gt;= b 0)\n \
    \             (&gt;= c 0)\n              (&gt; a (- b c))\n              (&gt;\
    \ b (- a c))\n              (&gt; c (- a b)))\n         (/ (* a b) 2)]\n     \
    \   [else -1]))\n</code>\nI tried to look at the racket-style-guide but I'm not\
    \ sure I understand what it means.\n\n\nA:\n\nThere are some problems with your\
    \ code. Firstly, you should use <code>let</code> to name the parameters in the\
    \ function, otherwise it's difficult to read. Secondly, you are missing the <code>define</code>\
    \ clause at the start of the program, which is necessary to declare the name of\
    \ the function and its parameters. Thirdly, when comparing numbers you should\
    \ use <code>number=?</code> instead of <code>eq?</code>, for instance:\n<code>(define\
    \ (triangle_area a b c)\n  (let ([s (+ a b c)])\n    (cond [(and (&gt;= a 0)\n\
    \                (&gt;= b 0)\n                (&gt;= c 0)\n                (&gt;\
    \ a (- b c))\n                (&gt; b (- a c))\n                (&gt; c (- a b)))\n\
    \           (/ (* a b) 2)]\n          [else -1])))\n</code>\nAnd it should work,\
    \ see it here.\n", "  (let* ([temp (sort (list a b c) <)]\n         [a (car temp)]\n\
    \         [b (cadr temp)]\n         [c (caddr temp)])\n    (if (and (< a (+ b\
    \ c)) (< c (+ a b)))\n        (* (/ 1 2.0) a b (sin (acos (/ (- (* a a) (* b b)\
    \ (* c c)) (* 2 a b))))))\n    -1))\n", "  (cond [(and (>= a b) (>= a c)) (triangle_area_aux\
    \ a b c)]\n        [(and (>= b a) (>= b c)) (triangle_area_aux b a c)]\n     \
    \   [(and (>= c a) (>= c b)) (triangle_area_aux c a b)]\n        [else -1]))\n",
  "  (cond\n    [(= (- a b) 0) (* (/ a 2) (sqrt (+ (* b b) (* c c)))))\n    [(= (-\
    \ a c) 0) (* (/ a 2) (sqrt (+ (* b b) (* c c)))))\n    [(= (- b c) 0) (* (/ b\
    \ 2) (sqrt (+ (* a a) (* c c)))))\n    [(= (- a b) (- c 0)) (* (/ (+ a b) 2) (sqrt\
    \ (- (* c c) (/ (+ (* a a) (* b b)) 4)))))\n    [(= (- a c) (- b 0)) (* (/ (+\
    \ a c) 2) (sqrt (- (* b b) (/ (+ (* a a) (* c c)) 4)))))\n    [(= (- b c) (- a\
    \ 0)) (* (/ (+ b c) 2) (sqrt (- (* a a) (/ (+ (* b b) (* c c)) 4))))]\n    [else\
    \ -1]))\n", "  (if (= 4 (+ a b c))\n      (round (* .5 (* a b c)))\n      -1))\n",
  "  (cond ((&gt; (+ a b) c)\n         (round (* .5 (- (+ a b) c) (sqrt (- (* (- a\
    \ b) (- a b)) (* 4 (* a a b b)))) 2))\n       (else -1)))\n</code>\nI'm curious\
    \ how much shorter the native Racket is:\n<code>#lang racket\n", "  (cond [(valid?\
    \ a b c)\n         (displayln (area a b c))]\n        [else\n         (displayln\
    \ -1)]))", "  (define (is_triangle a b c)\n    (and (&gt; a 0)\n         (&gt;\
    \ b 0)\n         (&gt; c 0)\n         (&gt; (+ a b) c)\n         (&gt; (+ a c)\
    \ b)\n         (&gt; (+ b c) a)))\n  (cond\n    [(is_triangle a b c)\n     (round\
    \ (* (/ 1 2) (- a c) (- b c)) 2)]\n    [else -1]))\n</code>\n", "  (cond\n   \
    \ ((&gt; (+ a b) c) (area-of-triangle a b c))\n    ((&gt; (+ a c) b) (area-of-triangle\
    \ a c b))\n    ((&gt; (+ b c) a) (area-of-triangle b c a))\n    (else -1)))\n",
  "  (define (sides-valid?)\n    (> (+ a b) c)\n    (> (+ a c) b)\n    (> (+ b c)\
    \ a))\n  (if (sides-valid?)\n      (/ (* (+ a b c) (* (- a b c) (* (- a c b)))\
    \ (sqrt 3)) 4)\n      -1))\n", "  (cond ((and (< (+ a b) c) (< (+ a c) b) (< (+\
    \ b c) a))\n         -1)\n        (else\n         (with-handlers ([exn:fail? exn:fail?])\n\
    \           (* (/ (+ a b c) 2) (sqrt (- (* (+ a b c) (* (+ a b c)) (* (+ a b c))\
    \ )\n                                       (* (* a a) (* b b)) (* (* a a) (*\
    \ c c)) (* (* b b) (* c c)) ) ) ))))\n", "  (cond\n    ((and (&gt;= a 0) (&gt;=\
    \ b 0) (&gt;= c 0))\n      (+ (/ a 2) (/ b 2) (/ c 2)))\n    (else\n      -1)))\n",
  "  (cond\n    [(and (> a 0) (> b 0) (> c 0)) (let ([s (/ (+ a b c) 2.0)])\n    \
    \                                 (* (- s a) (- s b) (- s c)))]\n    [else (-1)]))\n",
  "  (define area (/ (* (+ a b c) (- a b c) (- b c a) (- c a b)) 16))\n  (if (&gt;\
    \ (+ a b c) 2)\n      (round area 2)\n      -1))\n</code>\nI am trying to implement\
    \ a <code>cond</code> statement but it fails for large numbers.\n<code>#lang racket\n",
  "  (cond [(and (and (>= a b) (>= a c))\n\t    (> (+ b c) a))\n\t (round (* 1/2 (-\
    \ (+ b c) a) (- (+ a c) b) (- (+ a b) c)) 2)]\n\t[else -1]))", "  (define (sorted-sides\
    \ lst)\n    (sort lst <))\n  (define (area-of-triangle sides)\n    (* (/ (apply\
    \ + sides) 2)\n       (sqrt (- (apply * sides)\n                (* (expt (car\
    \ sides) 2)\n                   (expt (cadr sides) 2))))))\n  (if (and (< (apply\
    \ + (sorted-sides (list a b c))) (* 2 (car (sorted-sides (list a b c)))))\n  \
    \         (< (apply + (sorted-sides (list a b c))) (* 2 (cadr (sorted-sides (list\
    \ a b c))))))\n      (round (area-of-triangle (sorted-sides (list a b c))) 2)\n\
    \      -1))\n", "  (define (valid? sides)\n    (cond\n      [(> (sum sides) (second\
    \ sides)) #t]\n      [else #f]))\n  (define (heron-area a b c)\n    (define (semi-perimeter)\n\
    \      (/ (sum (list a b c)) 2))\n    (sqrt (* (semi-perimeter) (- (semi-perimeter)\
    \ a) (- (semi-perimeter) b) (- (semi-perimeter) c))))\n  (cond\n    [(valid? (list\
    \ a b c)) (round (heron-area a b c) 2)]\n    [else -1]))", "  (if (and (and (<=\
    \ a (+ b c)) (<= b (+ a c)) (<= c (+ a b)))\n           (not (zero? (+ (- a b)\
    \ (- b c) (- c a)))))\n      (* (/ 3 2)\n         (sqrt\n          (+ (* (- a\
    \ b) (- a b))\n             (* (- b c) (- b c))\n             (* (- c a) (- c\
    \ a)))))\n      -1))\n```\n\n```racket\n#lang racket\n", "  (match (sort (list\
    \ a b c) <)\n    [(list a b c)\n     (define s (/ (+ a b c) 2))\n     (define\
    \ area (* s (- s a) (- s b) (- s c)))\n     (if (< area 0)\n       -1\n      \
    \ (round (* (sqrt area) 100) 2))]))\n", "  (cond ((and (>= a 0) (>= b 0) (>= c\
    \ 0))\n         (cond ((< a (+ b c)) \n                (let ((s (/ (+ a b c) 2)))\n\
    \                  (sqrt (* s (- s a) (- s b) (- s c)))))\n               (else\
    \ -1)))\n        (else -1)))\n", "  (cond [(and (and (&gt; a 0) (&gt; b 0) (&gt;\
    \ c 0))\n              (and (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a)))\n\
    \         (define (heron a b c)\n           (/\n            (+\n             (*\
    \ a a)\n             (* b b)\n             (* c c))\n            3))\n       \
    \  (define (s a b c) (/ (+ a b c) 2))\n         (define (sqr x) (* x x))\n   \
    \      (sqrt (- (sqr (s a b c)) (heron a b c)))\n         (round (* 100 (sqrt\
    \ (- (sqr (s a b c)) (heron a b c)))))]\n        [else -1]))\n</code>\nWhen I\
    \ run it in the interactive environment, it gives me the following error:\n<code>&gt;\
    \ (triangle_area 2 4 4)", "  (cond [(or (> (+ a b) c)\n             (> (+ a c)\
    \ b)\n             (> (+ b c) a))\n         (/ (* a b c) (sqrt (+ (* a a) (* b\
    \ b) (* c c)))))\n        [else -1]))", "  (define (is_valid_triangle)\n    (cond\
    \ [(or (or (> a (+ b c)) (> b (+ a c)) (> c (+ a b)))\n                 (or (=\
    \ a 0) (= b 0) (= c 0))) #f]\n          [else #t]))\n  (cond [(is_valid_triangle)\n\
    \         (let ((s (/ (+ a b c) 2)))\n           (* s (- s a) (- s b) (- s c)))]\n\
    \        [else -1]))\n", "  (cond [(and (< a (+ b c))\n              (< b (+ a\
    \ c))\n              (< c (+ a b)))\n         (define (sides a b c) (+ a b c))\n\
    \         (define (half-perimeter a b c) (/ (sides a b c) 2))\n         (define\
    \ (area a b c)\n           (sqrt (* (- (half-perimeter a b c) a)\n           \
    \         (- (half-perimeter a b c) b)\n                    (- (half-perimeter\
    \ a b c) c))))\n         (round (* 2 (area a b c)) 2)]\n        [else -1]))\n",
  "  (cond\n    [(not (and (< a (+ b c)) (< b (+ a c)) (< c (+ a b)))) -1]\n    [else\
    \ (round (* 0.5 (- a b c)) 2)]))\n", "  (let ([s (/ (+ a b c) 2.0)])\n    (if\
    \ (and (< a (+ b c)) (< b (+ a c)) (< c (+ a b)))\n        (* s (- s a) (- s b)\
    \ (- s c))\n        -1)))\n", "  (define (double v) (* 2 v))\n  (define (area-1\
    \ a b c)\n    (define (half-perimeter)\n      (/ (+ a b c) 2))\n    (define (area)\n\
    \      (sqrt (- (half-perimeter) a)\n             (- (half-perimeter) b)\n   \
    \          (- (half-perimeter) c)))\n    (area))\n  (define (area-2 a b c)\n \
    \   (define (p a b c)\n      (+ a b c))\n    (define (area)\n      (sqrt (p a\
    \ b c)\n             (- (p a b c) a)\n             (- (p a b c) b)\n         \
    \    (- (p a b c) c)))\n    (area))\n  (define (area-3 a b c)\n    (define (p\
    \ a b c)\n      (* 2 (+ a b c)))\n    (define (area)\n      (sqrt (- (p a b c)\
    \ a)\n             (- (p a b c) b)\n             (- (p a b c) c)))\n    (area))\n\
    \  (define (area-4 a b c)\n    (define (p a b c)\n      (+ a b c))\n    (define\
    \ (area)\n      (/ (sqrt (p a b c)\n               (- (p a b c) a)\n         \
    \      (- (p a b c) b)\n               (- (p a b c) c))) 2))\n  (define (area-5\
    \ a b c)\n    (define (p a b c)\n      (* 2 (+ a b c)))\n    (define (area)\n\
    \      (/ (sqrt (- (p a b c) a)\n               (- (p a b c) b)\n            \
    \   (- (p a b c) c))) 2))\n  (define (area-6 a b c)\n    (define (p a b c)\n \
    \     (/ (+ a b c) 2))\n    (define (area)\n      (/ (sqrt (- (p a b c) a)\n \
    \              (- (p a b c) b)\n               (- (p a b c) c))) 2))\n  (define\
    \ (area-7 a b c)\n    (define (p", "  (cond\n    [(< a 0) -1]\n    [(< b 0) -1]\n\
    \    [(< c 0) -1]\n    [(< (+ a b) c) -1]\n    [(< (+ a c) b) -1]\n    [(< (+\
    \ b c) a) -1]\n    [else (round (* (sqrt (+ (* (* (- a (/ b 2)) (- a (/ b 2)))\
    \ (* (* (- b (/ a 2)) (- b (/ a 2))) (* (* (- c (/ a 2)) (- c (/ a 2))) (/ (/\
    \ (* a b) 2) (sqrt (+ (* (* (- a (/ b 2)) (- a (/ b 2))) (* (* (- b (/ a 2)) (-\
    \ b (/ a 2))) (* (* (- c (/ a 2)) (- c (/ a 2))) (/ 1 4)))))))))) 2)]))\n```\n\
    \n```#lang racket", "  (if (= (+ a b c) 0) \n      -1\n      (let ([s (/ (+ a\
    \ b c) 2)])\n        (round (* (sqrt (- (* s (- s a)) (* s (- s b)) (* s (- s\
    \ c)))) 2)))))\n", "  (if (and (&gt; a 0) (&gt; b 0) (&gt; c 0))\n      (let ((s\
    \ (/ (+ a b c) 2)))\n        (* (sqrt (- s a) (* (sqrt (- s b) (* (sqrt (- s c)\
    \ s))))))\n      )\n      -1\n  )\n)\n", "  (if (= -1 (valid_triangle a b c))\n\
    \      -1\n      (round (* (/ (exact->inexact (* a b))\n                   2)\n\
    \                (sqrt (+ (* (sqr (- a (/ a 2)))\n                           \
    \ (sqr (- b (/ b 2))))\n                         (* (sqr (- a (/ a 2)))\n    \
    \                        (sqr (- c (/ c 2))))\n                         (* (sqr\
    \ (- b (/ b 2)))\n                            (sqr (- c (/ c 2))))\n         \
    \                )))\n             2)))\n", "  (define p (/ (+ a b c) 2))\n  (sqrt\
    \ (* p (- p a) (- p b) (- p c))))\n", "  (define s (/ (+ a b c) 2))\n  (cond\n\
    \    [(> a b c) (round (* (sqrt (- s a) (- s b) (- s c)) 2))]\n    [else -1]))",
  "  (cond [(and (and (&gt;= a 0) (&gt;= b 0) (&gt;= c 0))\n               (and (&gt;\
    \ (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a)))\n         (round (* .5 (- (+\
    \ a b c) (- a b)) (- (+ a b c) (- a c)) (- (+ a b c) (- b c))))\n         (-1)]))\n\
    </code>\nI want to be able to deal with this input (triangle_area 2 3 4)\nThanks\
    \ to anyone who helps!\n\n\nA:\n\nThe issue is that <code>*</code> is trying to\
    \ take three arguments, and only getting two.  The more idiomatic way to write\
    \ this would be:\n<code>(define (triangle_area a b c)\n  (and (and (&gt;= a 0)\
    \ (&gt;= b 0) (&gt;= c 0))\n       (and (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt;\
    \ (+ b c) a))\n       (round (* .5 (- (+ a b c) (- a b)) (- (+ a b c) (- a c))\
    \ (- (+ a b c) (- b c))))\n       (-1)))\n</code>\nNote that you should have the\
    \ conditions be <code>and</code> instead of <code>or</code> if you really want\
    \ this to compute the area.  Or you could write:\n<code>(define (triangle_area\
    \ a b c)\n  (and (and (&gt;= a 0) (&gt;= b 0) (&gt;= c 0))\n       (and (&gt;\
    \ (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a))\n       (round (* .5\n       \
    \           (- (+ a b c) (- a b))\n                  (- (+ a b c) (- a c))\n \
    \                 (- (+ a b c) (- b c))))))\n</code>\nThat way, any invalid input\
    \ will just evaluate to <code>#f</code>\n", "  (define (is-triangle a b c)\n \
    \   (and (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a)))\n  (cond\n    [(is-triangle\
    \ a b c) (define s (/ (+ a b c) 2))\n                          (define area (sqrt\
    \ (- (* s (- s a)) (* s (- s b)) (* s (- s c)))))\n                          (round\
    \ area 2)]\n    [else -1]))\n", "  (if (and (&gt; (+ a b) c) (&gt; (+ a c) b)\
    \ (&gt; (+ b c) a))\n      (round (* (/ (+ a b c) 2) (sqrt (- (* (- a b) (- a\
    \ c) (- b c)) (* (+ a b c) (/ (+ a b c) 2)))) 2))\n      -1))\n</code>\nThe code\
    \ above works fine. So I changed it slightly to return the area without rounding:\n\
    <code>#lang racket\n", "  (cond\n    [(> (+ a b) c)\n     (/ (* a b) 2)]\n   \
    \ [(> (+ a c) b)\n     (/ (* a c) 2)]\n    [(> (+ b c) a)\n     (/ (* b c) 2)]\n\
    \    [else\n     -1]))\n", "  (let* ((sides (list a b c))\n         (side-sum\
    \ (apply + sides))\n         (min-side (apply min sides)))\n    (cond\n      [(>=\
    \ min-side (/ side-sum 2)) -1]\n      [else (sqrt (* (- side-sum min-side) (*\
    \ (- side-sum (* min-side 2)) (- side-sum (* min-side 3)))))])))\n", "  (cond\
    \ [(< a b c) (* .5 (- a b c))]\n        [(> a b c) (* .5 (- a b c))]\n       \
    \ [else -1]))\n", "  (if (and (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c)\
    \ a))\n      (* 0.5 (* a b c))\n      -1))\n", "  (cond ((and (<= (+ a b) c) (<=\
    \ (+ a c) b) (<= (+ b c) a)) -1)\n        (else (let ((s (/ (+ a b c) 2)))\n \
    \               (/ (* s (- s a) (- s b) (- s c)) 2)))))\n", "  (cond ((and (&gt;\
    \ a 0) (&gt; b 0) (&gt; c 0))\n         (if (or (&gt; (+ a b) c)\n           \
    \      (&gt; (+ a c) b)\n                 (&gt; (+ b c) a))\n             (let\
    \ ((s (/ (+ a b c) 2)))\n               (* s (- s a) (- s b) (- s c)))\n     \
    \        -1))\n        (else -1)))\n</code>\nI still have to add some test cases,\
    \ but this computes the area of the triangle.\n", "  (if (and (&gt; a 0) (&gt;\
    \ b 0) (&gt; c 0))\n      (let ([s (+ a b c)])\n        (cond\n         [(&gt;\
    \ a s) -1]\n         [(&gt; b s) -1]\n         [(&gt; c s) -1]\n         [else\
    \ (/ (* s (- s a) (- s b) (- s c)) 4)]))\n      -1))\n", "  (cond [(>= (+ a b)\
    \ c)\n         (cond [(>= (+ a c) b)\n                (cond [(>= (+ b c) a)\n\
    \                       (round (* (- a b c) (- a b c)) (sqrt (* (+ a b c) (- a\
    \ b c) (- a b c)))))])])])\n  ;(round (* (- a b c) (- a b c)) (sqrt (* (+ a b\
    \ c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt (* (+ a\
    \ b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt (* (+\
    \ a b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt (*\
    \ (+ a b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt\
    \ (* (+ a b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt\
    \ (* (+ a b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt\
    \ (* (+ a b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt\
    \ (* (+ a b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt\
    \ (* (+ a b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt\
    \ (* (+ a b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt\
    \ (* (+ a b c) (- a b c) (- a b c))))))\n  ;(round (* (- a b c) (- a b c)) (sqrt\
    \ (* (+ a b c) (- a b c) (- a b c))))))\n  ;", "  (define (half-perimeter) (/\
    \ (+ a b c) 2))\n  (define (area)\n    (sqrt (* (half-perimeter) (- (half-perimeter)\
    \ a) (- (half-perimeter) b) (- (half-perimeter) c))))\n  (if (&gt; (half-perimeter)\
    \ a)\n      (if (&gt; (half-perimeter) b)\n          (if (&gt; (half-perimeter)\
    \ c)\n              (round (area) 2)\n              -1)\n          -1)\n     \
    \ -1))\n</code>\nUpdate:\nHaving written the above code, I felt it was necessary\
    \ to post an answer that actually addresses the question. @Mokubai's response\
    \ is much better, as that actually ensures that only a triangle can be passed\
    \ in.\n<code>#lang racket\n", "  (cond [(and (>= a b) (>= a c)) ; A is biggest\n\
    \         (* (/ (+ b c) 2.0)\n            (sqrt (- (* a a) (/ (* (* (+ b c) (-\
    \ b c))\n                                  (* (+ b c) (- b c)))\n            \
    \                   16))))]\n        [(and (>= b a) (>= b c)) ; B is biggest\n\
    \         (* (/ (+ a c) 2.0)\n            (sqrt (- (* b b) (/ (* (* (+ a c) (-\
    \ a c))\n                                  (* (+ a c) (- a c)))\n            \
    \                   16))))]\n        [(and (>= c a) (>= c b)) ; C is biggest\n\
    \         (* (/ (+ a b) 2.0)\n            (sqrt (- (* c c) (/ (* (* (+ a b) (-\
    \ a b))\n                                  (* (+ a b) (- a b)))\n            \
    \                   16))))]\n        [else -1]))\n", "  (cond\n    [(and (> a\
    \ 0) (> b 0) (> c 0))\n     (let ([s (/ (+ a b c) 2)])\n       (sqrt (- (* s (-\
    \ s a)) (* s (- s b)) (* s (- s c)))))]\n    [else\n     -1]))\n", "  (define\
    \ s (/ (+ a b c) 2))\n  (define a (sqrt (* s (- s a) (- s b) (- s c))))\n  (if\
    \ (and (not (equal? a #iNf.0)) (&gt; a 0))\n      (round (* a 100) 2)\n      -1))\n",
  "  (cond\n    [(<= (+ a b) c) -1]\n    [(<= (+ a c) b) -1]\n    [(<= (+ b c) a)\
    \ -1]\n    [else (* .5 (* (- a (* .5 (+ a b c)))\n                  (- b (* .5\
    \ (+ a b c)))\n                  (- c (* .5 (+ a b c)))))]))\n", "  (cond\n  \
    \  [(> a 0)\n     (cond\n       [(> b 0)\n        (cond\n          [(> c 0)\n\
    \           (cond\n             [(and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n\
    \              (define s (/ (+ a b c) 2))\n              (define area (sqrt (*\
    \ s (- s a) (- s b) (- s c))))\n              (if (= area (round area))\n    \
    \              (round area)\n                  (round (exact->inexact area) 2)))]\n\
    \             [else -1])]\n          [else -1])]\n       [else -1])]\n    [else\
    \ -1]))\n", "  (cond\n    ((and (< (+ a b) c) (< (+ a c) b) (< (+ b c) a)) -1)\n\
    \    (else (* (/ (+ a b c) 2)\n             (sqrt (- (* (- (* a a) (* b b)) (*\
    \ c c))\n                     (* (- (* a a) (* c c)) (* b b))))))))", "  (if (or\
    \ (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n      (let ((s (/ (+ a b c) 2)))\n\
    \        (round (* s (- s a) (- s b) (- s c)) 2))\n    -1))\n</code>\n", "  (if\
    \ (valid-triangle? a b c)\n      (round (* (heron a b c) 2) 2)\n      -1))\n",
  "  (define (is-valid-triangle? a b c)\n    (and (<= a b c)\n         (>= (+ a b)\
    \ c)\n         (>= (+ a c) b)\n         (>= (+ b c) a)))\n  (cond\n    [(is-valid-triangle?\
    \ a b c) (round (* (/ (sqrt (- (* c c) (* (/ (- (+ (* a a) (* b b)) (* c c)) 2)\
    \ 2)) 2) 2) 100))]\n    [else -1]))", "  (if (valid? a b c)\n      (round (* 0.5\
    \ (apply + (area a b c))) 2)\n      -1))\n", "  (if (and (not (negative? a))\n\
    \           (not (negative? b))\n           (not (negative? c))\n           (or\
    \ (&gt; (+ a b) c)\n               (&gt; (+ a c) b)\n               (&gt; (+ b\
    \ c) a)))\n      (exact-&gt;inexact (/ (* a b) 2))\n      -1))\n</code>\nFor instance,\
    \ (triangle_area 3 4 5) should return 6.\n\nQuestion #3\nAt a minimum, I'd like\
    \ to know the above answers and it's great to know how to do this in general.\n\
    How do I know what functions are available to me in Racket? I'm coming from Ruby,\
    \ so I'm used to irb. I've played with DrRacket and had a lot of trouble. I just\
    \ don't understand how to interact with Racket. I would like to know if there\
    \ is a way to inspect what functions are available to me (apart from searching\
    \ through the docs and scouring StackOverflow). And then how do I find out what\
    \ kinds of arguments those functions take? For instance, in Ruby if I want to\
    \ know about String I can type <code>String.methods</code> and then if I want\
    \ to know about a specific method I can type <code>String.method(:upcase).parameters</code>.\n\
    Is there something like that for Racket?\n\n\nA:\n\nYou've got some good answers,\
    \ but here's a bit more.\nDrRacket allows you to run your code interactively by\
    \ hitting the \"Run\" button. When you do this, it's important to understand that\
    \ the code you write is not running in a REPL, and you can't inspect it. You can\
    \ only run a program, and it either runs or it doesn't.\nDrRacket also has a REPL,\
    \ but it's not the \"Run\" button. It's the \"Interactions\" button. That's where\
    \ you want to be to experiment with code. (You'll also want to learn to use the\
    \ \"Debugger\" button to step through your code and inspect variables. That's\
    \ a bit outside the scope of this question.)\nIn the \"Interactions\" window,\
    \ type this, and hit enter:\n<code>(load \"my-module.rkt\")\n</code>\nNow you\
    \ have your function loaded into the", "  (define (is_valid_triangle a b c)\n\
    \    (if (&gt; (+ a b) c) #t #f))\n  (if (is_valid_triangle a b c)\n      (* 0.5\
    \ (* (+ a b) c))\n      -1))\n", "  (cond\n    [(> (+ a b) c) (* (/ (* a b) 2)\
    \ (sin (acos (/ (* (+ (* a a) (* b b)) (* (- c) (- a) (- b))) 2))))]\n    [else\
    \ -1]))\n", "  (cond\n    [(>= a 0)\n     (cond\n       [(>= b 0)\n        (cond\n\
    \          [(>= c 0)\n           (cond\n             [(<= (* b c) (* a (- a b\
    \ c)))\n              (-1)]\n             [(<= (* a c) (* b (- a b c)))\n    \
    \          (-1)]\n             [(<= (* a b) (* c (- a b c)))\n              (-1)]\n\
    \             [else\n              (let* ([p (/ (+ a b c) 2)]\n              \
    \       [area (sqrt (* p (- p a) (- p b) (- p c)))])\n                (format\
    \ \"~0,2f\" area))])])])])])\n", "  (define (is-valid-triangle a b c)\n    (>\
    \ (+ a b) c))\n  (cond [(is-valid-triangle a b c)\n         (* .5 (- (* a b c)\
    \ (expt a 2) (expt b 2) (expt c 2)))\n         (sqrt (+ (expt a 2) (expt b 2)\
    \ (expt c 2)))]\n        [else -1]))", "  (cond ((= (+ a b) c) -1)\n        ((=\
    \ (+ a c) b) -1)\n        ((= (+ b c) a) -1)\n        (else (* 0.5 (* (+ a b c)\n\
    \                       (- (- c)\n                          (+ a b)))))))\n",
  "  (if (and (< a (+ b c)) (< b (+ a c)) (< c (+ a b)))\n      (round (* (sqrt (+\
    \ (* (- (/ (- (+ a b) c) 2) (- (/ (- (+ a b) c) 2))) (* (* (- (/ (- (+ a b) c)\
    \ 2) (- (/ (- (+ a b) c) 2))) (- (/ (- (+ a b) c) 2))) (- (/ (- (+ a b) c) 2)))))\
    \ 0.5)) 2)\n      -1))\n", "  (let* ([s (+ a b c)]\n         [area (sqrt (* (expt\
    \ s 2) (- (expt s 2) (* a (expt a 2))\n                                      \
    \    (* b (expt b 2))\n                                          (* c (expt c\
    \ 2))))])\n    (cond\n      [(or (> a c) (> b c)) -1]\n      [(>= s (+ c c)) -1]\n\
    \      [else (round area 2)])))\n", "  (if (and (< a (+ b c)) (< b (+ a c)) (<\
    \ c (+ a b)))\n      (cond [(and (< a (- b c)) (< b (- a c)) (< c (- a b)))\n\
    \             0]\n            [else\n             (* 0.5 (expt (- (* (+ a b c)\
    \ (* (+ a b c) (- (* a b c) (* b c)))) 8) (sqrt 3))])\n      -1))", "  (cond [(and\
    \ (> a 0) (> b 0) (> c 0))\n         (if (> (+ a b) c)\n             (if (> (+\
    \ a c) b)\n                 (if (> (+ b c) a)\n                     (round (*\
    \ 0.5 (- (+ a b) c) (- (+ a c) b) (- (+ b c) a)))\n                 -1)\n    \
    \         -1)\n         -1)]))\n", "  (cond\n    [(> (+ a b) c) (round (* 0.5\
    \ (- a b c)) 2)]\n    [(> (+ a c) b) (round (* 0.5 (- a b c)) 2)]\n    [(> (+\
    \ b c) a) (round (* 0.5 (- a b c)) 2)]\n    [else -1]))\n", "  (cond\n    [(or\
    \ (or (&lt; a 0) (&lt; b 0) (&lt; c 0))\n         (or (&gt; (+ a b) c) (&gt; (+\
    \ a c) b) (&gt; (+ b c) a))) -1]\n    [else\n     (define s (/ (+ a b c) 2))\n\
    \     (sqrt (* s (- s a) (- s b) (- s c)))]))\n</code>\n", "  (cond [(<= a 0)\
    \ -1]\n        [(<= b 0) -1]\n        [(<= c 0) -1]\n        [(> (+ a b) c) (+\
    \ (* a b) (* a c) (* b c))]\n        [else -1]))\n", "  (if (&gt;= (+ a b) c)\n\
    \      (round (* (sqrt (+ (* a a) (* b b) (* c c))) .5))\n      -1))\n", "  (define\
    \ s (/ (+ a b c) 2))\n  (if (and (&gt; a b) (&gt; a c))\n      (sqrt (- (* s (-\
    \ s a)) (* s (- s b)) (* s (- s c))))\n      (if (and (&gt; b a) (&gt; b c))\n\
    \          (sqrt (- (* s (- s b)) (* s (- s a)) (* s (- s c))))\n          (if\
    \ (and (&gt; c a) (&gt; c b))\n              (sqrt (- (* s (- s c)) (* s (- s\
    \ a)) (* s (- s b))))\n              -1))))\n</code>\nIt works fine when I enter\
    \ the sides of a triangle. However, when I enter the\nlengths of a line segment,\
    \ it returns -1. I don't know how to fix it. I have\nbeen trying to come up with\
    \ a different solution, but couldn't. Please help!\n\n\nA:\n\nA couple of things\
    \ are problematic.\n\n<code>s</code> is only valid for triangles, since the formula\
    \ for a triangle's area uses <code>s</code> in it. If <code>a+b &lt;= c</code>,\
    \ then <code>s</code> will be negative, which will lead to numeric errors (and\
    \ even worse, there is no way to prevent that).\nYou are using the formula for\
    \ Heron's formula, but you are not checking if the input values <code>a</code>,\
    \ <code>b</code>, and <code>c</code> could actually form a triangle. The main\
    \ problem of your approach is that you are using the formula without making sure\
    \ that the inputs are valid (i.e. they can form a triangle).\n\nHere's an alternative\
    \ approach using Heron's formula:\n<code>(define (triangle-area a b c)\n  (if\
    \ (and (&gt; a 0)\n           (&gt; b 0)\n           (&gt; c 0)\n           (&lt;\
    \ a (+ b c))\n           (&lt; b (+ a c))\n           (&lt; c (+ a b)))\n    \
    \  (sqrt (- (* (expt a 2) (* (expt b 2) (expt c 2)))\n               (* (+ (*\
    \ a b) (* b c) (* a c)) 2)))", "  (cond\n    [(> a 0)\n     (cond\n       [(>\
    \ b 0)\n        (cond\n          [(> c 0)\n           (let\n               ([s\
    \ (/ (+ a b c) 2)])\n             (sqrt (* s (- s a) (- s b) (- s c))))\n    \
    \       )]\n        )]\n     )]\n    [-1]))\n", "  (let* ((test #f)\n        \
    \ (s (/ (+ a b c) 2.0)))\n    (define (check)\n      (cond ((<= (- a s) 0) #f)\n\
    \            ((<= (- b s) 0) #f)\n            ((<= (- c s) 0) #f)\n          \
    \  (else #t)))\n    (cond ((check) (sqrt (* s (- s a) (- s b) (- s c))))\n   \
    \       (else -1))))\n", "  (cond [(> (+ a b) c) (* 0.5 (+ a b c))]\n        [(>\
    \ (+ a c) b) (* 0.5 (+ a b c))]\n        [(> (+ b c) a) (* 0.5 (+ a b c))]\n \
    \       [else -1]))\n", "  (let* ([s (+ a b c)]\n         [area (/ (* s (- s a)\
    \ (- s b) (- s c)) 4)])\n    (cond\n      [(and (>= a 0) (>= b 0) (>= c 0))\n\
    \       (round (* 100 area))]\n      [else -1])))\n", "  (cond\n    [(or (> a\
    \ (+ b c))\n         (> b (+ a c))\n         (> c (+ a b)))\n     -1]\n    [else\n\
    \     (round (* (heron a b c) 2) 2)]))\n", "  (define (get-area sides)\n    (let\
    \ ((s (/ (+ (car sides) (cadr sides) (caddr sides)) 2)))\n      (* (/ (- s (car\
    \ sides)) s) \n         (/ (- s (cadr sides)) s)\n         (/ (- s (caddr sides))\
    \ s)\n         s)))\n  (cond\n    [(= a b c) (/ a 4 (sqrt 3))]\n    [(or (&gt;\
    \ a (+ b c))\n         (&gt; b (+ a c))\n         (&gt; c (+ a b))) -1]\n    [else\
    \ (round (get-area (sort a b c)) 2)]))\n</code>\n\n<code>#lang racket", "  (define\
    \ (positive? x) (&gt; x 0))\n  (define (sum-is-gt-third-side? a b c)\n    (&gt;\
    \ (+ a b) c))\n  (define (triangle-area a b c) (* (/ (+ a b c) 2) (- (/ (+ a b\
    \ c) 2) a) (- (/ (+ a b c) 2) b) (- (/ (+ a b c) 2) c)))\n  (if (and (positive?\
    \ a) (positive? b) (positive? c) (sum-is-gt-third-side? a b c) (sum-is-gt-third-side?\
    \ a c b) (sum-is-gt-third-side? b c a))\n      (round (triangle-area a b c) 2)\n\
    \      -1))\n</code>\nIs there a way to make the function more elegant and idiomatic?\n\
    \n\nA:\n\nThere are a few things about your code that are off:\n\nYour indentation\
    \ is off (you should go with the default).\nYou shouldn't use <code>and</code>\
    \ in a guard, that's what <code>cond</code> is for (not only will it make the\
    \ code easier to read, but it'll also make it more concise).\nWhat you're really\
    \ looking for is not <code>round</code>, but <code>inexact-&gt;exact</code>, since\
    \ you're going to compare the result to <code>-1</code> (it's usually best to\
    \ use exact numbers in Racket, since they're faster and consume less memory).\n\
    There's no need to call the helper function twice, you can just calculate the\
    \ area as needed.\nYou're not handling the special case of <code>a</code>, <code>b</code>\
    \ and <code>c</code> all equal to zero correctly.\n\nAnother thing is that it's\
    \ better to use <code>define</code> for constants and not for functions, so I'd\
    \ change the code like this:\n<code>(define (triangle-area a b c)\n  (cond ((and\
    \ (&gt; a 0) (&gt; b 0) (&gt; c 0)\n              (&gt; (+ a b) c) (&gt; (+ a\
    \ c) b) (&gt; (+", "  (cond [(< 0 a) -1] \n        [(< 0 b) -1] \n        [(<\
    \ 0 c) -1] \n        [(< (+ a b) c) -1] \n        [(< (+ a c) b) -1] \n      \
    \  [(< (+ b c) a) -1] \n        [else (* 0.5 (- (+ a b c) (/ a)))]))\n", "  (let\
    \ ([s (/ (+ a b c) 2)])\n    (if (and (&gt;= (- s a) 0)\n             (&gt;= (-\
    \ s b) 0)\n             (&gt;= (- s c) 0))\n        (round (* s (- s a) (- s b)\
    \ (- s c)) 2)\n        -1)))\n", "  (if (and (> a 0) (> b 0) (> c 0))\n      (if\
    \ (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n          (round (* (/ (+ a\
    \ b c) 2) (sqrt (- (* (+ a b c) (* (+ a b c)) (* (+ a b c)) (+ (* (- a b) (- a\
    \ b)) (* (- a c) (- a c)) (* (- b c) (- b c)))))) 2))\n          -1)\n      -1))\n",
  "  (define (doit a b c)\n    (*\n     (/ (+ a b (- c)) 2)\n     (- (- c) (- a))\n\
    \     (- (- c) (- b))))\n  (cond ((<= (+ a b) c) -1)\n        ((<= (+ a c) b)\
    \ -1)\n        ((<= (+ b c) a) -1)\n        (else (doit a b c))))\n", "  (cond\
    \ [(> a 0) (cond [(> b 0) (cond [(> c 0) \n                                  \
    \     (cond [(> (+ a b) c) (cond [(> (+ a c) b) (cond [(> (+ b c) a) \n      \
    \                                                                            \
    \      (define semiperimeter (/ (+ a b c) 2))\n                              \
    \                                                          (sqrt (- (* semiperimeter\
    \ (- semiperimeter a))\n                                                     \
    \                                           (* semiperimeter (- semiperimeter\
    \ b))\n                                                                      \
    \                          (* semiperimeter (- semiperimeter c))))))\n       \
    \                                                                            \
    \  -1])\n                                                                   -1])\n\
    \                                             -1])\n                         \
    \  -1])\n             -1])\n</code>\nThe question seems to imply that I should\
    \ be using built-in functions, but I haven't been able to find any that will round\
    \ a number to a certain number of decimal places...\n\n\nA:\n\nHere is a solution\
    \ using <code>heron</code> (calculates the area of a triangle):\n<code>(define\
    \ (triangle-area a b c)\n  (if (and (positive? a) (positive? b) (positive? c)\
    \ \n           (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a))\n      (heron\
    \ a b c)\n      -1))\n</code>\n", "  (cond ((and (< a 0) (< b 0) (< c 0)) -1)\n\
    \        ((> a (+ b c)) -1)\n        ((> b (+ a c)) -1)\n        ((> c (+ a b))\
    \ -1)\n        (else (round (* 1/2 (- b) (+ c))) -1)))\n", "  (cond ((&gt; (+\
    \ a b) c) (+ (/ a 2) (/ b 2) (/ c 2)))\n        ((&gt; (+ a c) b) (+ (/ a 2) (/\
    \ b 2) (/ c 2)))\n        ((&gt; (+ b c) a) (+ (/ a 2) (/ b 2) (/ c 2)))\n   \
    \     (else -1)))\n</code>\nThis is the solution I came up with.  What I'm trying\
    \ to do is sum the two shortest sides and see if it's larger than the largest\
    \ side.  If it is, then I return the sum of the 3 side lengths divided by 2. \
    \ It returns true.  If it is not then I return false.  Does this solution look\
    \ like a reasonable one?  Is there a better way?  Thanks in advance!\n\n\nA:\n\
    \n<code>(define (triangle_area a b c)\n  (cond ((&gt; (+ a b) c) (+ (/ a 2) (/\
    \ b 2) (/ c 2)))\n        ((&gt; (+ a c) b) (+ (/ a 2) (/ b 2) (/ c 2)))\n   \
    \     ((&gt; (+ b c) a) (+ (/ a 2) (/ b 2) (/ c 2)))\n        (else -1)))\n</code>\n\
    The above is not a reasonable way to do the problem.  It is not even a reasonable\
    \ way to implement your own solution.  You have an opportunity to do your problem\
    \ in many reasonable ways.  How would you do the following in your code?\n\nB\
    \ is the biggest.\nA and B are the same size.\nNone of them are the same size.\n\
    A is negative.\nA is not a number.\nA is infinity.\nB is infinity.\n\nYou have\
    \ not exhausted the input space, and you have not written the simplest possible\
    \ code that could possibly work.  You have written a program that works when A\
    \ < B < C.  This is not a reasonable solution.\nYour solution does not even test\
    \ your solution against the requirements (which I admit are vague).  If a triangle\
    \ has two sides of length 1 and one side of length 2, is it valid?  Your solution\
    \ says yes, but I'm not sure that it is.\nHow would you modify your solution so\
    \ that it finds the area of a triangle?  You will need to use Heron's", "  (cond\
    \ ((or (&lt; a 0) (&lt; b 0) (&lt; c 0)) -1)\n        ((or (&lt; a (+ b c)) (&lt;\
    \ b (+ a c)) (&lt; c (+ a b))) -1)\n        (else (round (* 0.5 (* (+ a b c) (-\
    \ (+ a b c) a) (- (+ a b c) b) (- (+ a b c) c)))))))\n", "  (if (and (and (> (+\
    \ a b) c) (> (+ a c) b) (> (+ b c) a))\n           (and (number? a) (number? b)\
    \ (number? c)))\n      (round (* (/ 1.0 2) (+ a b c)) 2)\n      -1))\n", "  (if\
    \ (and (&gt; a 0) (&gt; b 0) (&gt; c 0))\n      (if (and (&gt; (+ a b) c) (&gt;\
    \ (+ a c) b) (&gt; (+ b c) a))\n          (* (/ (* a b) 2) (sin c))\n        \
    \  -1)\n      -1))\n", "  (cond [(and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n\
    \         (round (* 0.5 (- (+ a b c) (* 2 a) (* 2 b) (* 2 c)) 2))]\n        [else\
    \ -1]))\n", "  (cond\n    [(> (+ a b) c) (cond\n                     [(> (+ a\
    \ c) b) (cond\n                                      [(> (+ b c) a) (* .5 (- (-\
    \ b a) c) (- (+ b a) c) (* b c))]\n                                      [else\
    \ 0])]\n                     [else 0])]\n    [else 0]))\n", "  (cond ((or (< a\
    \ 0) (< b 0) (< c 0)) -1)\n        ((or (> (+ a b) c) (> (+ a c) b) (> (+ b c)\
    \ a))\n         (define s (/ (+ a b c) 2))\n         (sqrt (- (* s (- s a)) (*\
    \ s (- s b)) (* s (- s c)))))\n        (else -1)))\n", "  (if (and (and (>= a\
    \ 0) (>= b 0) (>= c 0))\n           (and (> (+ a b) c)\n                (> (+\
    \ a c) b)\n                (> (+ b c) a)))\n      (let ((s (/ (+ a b c) 2)))\n\
    \        (* s (- s a) (- s b) (- s c)))\n      -1))\n", "  (define (is-valid?\
    \ a b c)\n    (> (+ a b) c))\n  (define (find-area a b c)\n    (sqrt\n     (+\n\
    \      (* (- (* a a) (* b b)) (* c c))\n      (* 2 (* b b c c))\n      (* 2 (*\
    \ a a c c)))))\n  (if (is-valid? a b c)\n      (round (* 0.5 (find-area a b c))\
    \ 2)\n      -1))\n```\n\n```\n#lang racket\n", "  (cond\n    [(and (> a 0) (>\
    \ b 0) (> c 0))\n     (cond\n       [(and (> (+ a b) c) (> (+ a c) b) (> (+ b\
    \ c) a))\n        (define s (/ (+ a b c) 2))\n        (define area (sqrt (* s\
    \ (- s a) (- s b) (- s c))))\n        (define area-rounded (round (* area 100)))\n\
    \        (/ area-rounded 100)]\n       [else -1])]\n    [else -1]))", "  (cond\
    \ [(and (> a 0) (> b 0) (> c 0))\n         (let ([s (/ (+ a b c) 2)])\n      \
    \     (* s (- s a) (- s b) (- s c)))]\n        [else -1]))\n", "  (cond [(>= (+\
    \ a b) c)\n         (cond [(>= (+ a c) b)\n                (cond [(>= (+ b c)\
    \ a)\n                       (let* [(s (/ (+ a b c) 2))\n                    \
    \          (area-raw (sqrt (* s (- s a) (- s b) (- s c))))]\n                \
    \         (round (* 100 area-raw))\n                         )]\n            \
    \           [-1])]\n               [-1])]\n        [-1]))\n", "  (if (and (> (+\
    \ a b) c)\n           (> (+ a c) b)\n           (> (+ b c) a))\n      (round (*\
    \ 0.5 (sqrt (+ (* (- a (/ (+ a b c) 2)) (- a (/ (+ a b c) 2)))\n             \
    \               (* (- b (/ (+ a b c) 2)) (- b (/ (+ a b c) 2)))\n            \
    \                (* (- c (/ (+ a b c) 2)) (- c (/ (+ a b c) 2))))))\n      2)\n\
    \  -1)\n", "  (cond\n    [(> a (+ b c)) -1]\n    [(> b (+ a c)) -1]\n    [(> c\
    \ (+ a b)) -1]\n    [else (* 0.5 (+ a b c))]))\n", "  (cond\n    ((and (< a (+\
    \ b c)) (< b (+ a c)) (< c (+ a b)))\n     (exact->inexact (round (* 0.5 (* (+\
    \ a b c) (- (+ a b c) a) (- (+ a b c) b) (- (+ a b c) c))))))\n    (else -1)))\n",
  "  (if (and (>= a b c)\n           (>= b c a)\n           (>= c a b))\n      (round\
    \ (sqrt (- (* 0.25 (+ (* a a) (* b b) (* c c)))\n                     (* 0.5 (*\
    \ a a b b))\n                     (* 0.5 (* a a c c))\n                     (*\
    \ 0.5 (* b b c c)))) 2)\n      -1))\n</code>\nExplanation:\n<code>;; Given the\
    \ lengths of the three sides of a triangle. Return the area of", "  (cond\n  \
    \  [(or (or (&lt; a b) (&lt; a c)) (or (&lt; b a) (&lt; b c)) (or (&lt; c a) (&lt;\
    \ c b))) -1]\n    [else (round (* 0.5 (- a (- b c))))]))\n", "  (cond [(< a 0)\
    \ -1]\n        [(< b 0) -1]\n        [(< c 0) -1]\n        [(> (+ a b) c) -1]\n\
    \        [(> (+ a c) b) -1]\n        [(> (+ b c) a) -1]\n        [else (* 0.5\
    \ (- (* a b) (* a c) (* b c)))]))\n", "  (cond\n    [(>= (+ a b) c) (define p\
    \ (/ (+ a b c) 2))\n     (round (* (- p a) (- p b) (- p c)) 2)]\n    [else -1]))\n",
  "  (if (&gt; (+ a b) c) \n      (round (* 0.5 (sqrt (+ (* (- (+ a b) c) (- (+ a\
    \ b) c)) (* (- (+ a c) b) (- (+ a c) b)) (* (- (+ b c) a) (- (+ b c) a)))) 2))\
    \ \n      -1))\n</code>\n", "  (if (and (&gt;= a 0) (&gt;= b 0) (&gt;= c 0))\n\
    \      (if (and (&gt;= (+ a b) c) (&gt;= (+ a c) b) (&gt;= (+ b c) a))\n     \
    \     (round (* 0.5 (+ a b c)) 2)\n          -1)\n      -1))\n", "  (define (not_a_triangle\
    \ a b c)\n    (and (not (< a (+ b c)))\n         (not (< b (+ a c)))\n       \
    \  (not (< c (+ a b)))))\n  (define (shortest a b c)\n    (cond ((< a b) a)\n\
    \          ((< b c) b)\n          (else c)))\n  (define (middle a b c)\n    (cond\
    \ ((and (< b a) (< a c)) a)\n          ((and (< a b) (< b c)) b)\n          (else\
    \ c)))\n  (define (longest a b c)\n    (cond ((> a b) a)\n          ((> b c) b)\n\
    \          (else c)))\n  (cond ((not_a_triangle a b c) -1)\n        (else\n  \
    \       (let ((s (shortest a b c))\n               (m (middle a b c))\n      \
    \         (l (longest a b c)))\n           (* (/ (+ s m l) 2)\n              (sqrt\
    \ (- (expt l 2) (expt (/ (- (+ s m l) l) 2) 2))))))))\n", "  (define (valid-triangle?\
    \ a b c)\n    (and (> a 0) (> b 0) (> c 0)\n         (< (+ a b) c) (< (+ a c)\
    \ b) (< (+ b c) a)))\n  (define (semi-perimeter a b c)\n    (/ (+ a b c) 2))\n\
    \  (define (area-helper a b c)\n    (sqrt \n     (* (semi-perimeter a b c)\n \
    \       (- (semi-perimeter a b c) a)\n        (- (semi-perimeter a b c) b)\n \
    \       (- (semi-perimeter a b c) c))))\n  (cond ((valid-triangle? a b c)\n  \
    \       (round (* 100 (area-helper a b c))))\n        (else -1)))\n", "  (cond\n\
    \    [(>= (+ a b) c) (+ (* (/ a 2) b) (* (/ b 2) c) (* (/ c 2) a))]\n    [else\
    \ -1]))\n", "  (if (and (>= (+ a b) c)\n           (>= (+ a c) b)\n          \
    \ (>= (+ b c) a))\n      (round (* 0.5 (- (+ a b c) \n                       (*\
    \ a b c))) 2)\n      -1))\n", "  (if (and (< a 0) (< b 0) (< c 0)) -1\n      (if\
    \ (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n          (round (* 0.5 (-\
    \ (+ a b c) a b c)) 2)\n          -1)))\n", "  (cond [(> (+ a b) c)\n        \
    \ (define s (/ (+ a b c) 2))\n         (sqrt (* s (- s a) (- s b) (- s c)))]\n\
    \        [else -1]))\n", "  (define (is-valid-triangle?)\n    (or (> (+ a b) c)\n\
    \        (> (+ a c) b)\n        (> (+ b c) a)))\n  (define (area)\n    (/ (* (sqrt\
    \ (+ (* (* (- a (/ a 2)) (- a (/ a 2))) (* (* (- b (/ b 2)) (- b (/ b 2))) (*\
    \ (* (- c (/ c 2)) (- c (/ c 2))))) )) 2)\n       2))\n  (cond ((and (is-valid-triangle?)\
    \ (>= a 0) (>= b 0) (>= c 0))\n         (round area 2))\n        (else -1)))\n",
  "  (if (and\n       (&gt; (+ a b) c)\n       (&gt; (+ a c) b)\n       (&gt; (+ b\
    \ c) a))\n      (round (* (/ (sqrt (+ (* (- a (/ (+ a b) 2))\n               \
    \               (* (- a (/ (+ a b) 2)))\n                              (* (- b\
    \ (/ (+ a b) 2))\n                                 (* (- b (/ (+ a b) 2))))\n\
    \                          (* (- c (/ (+ a b) 2))\n                          \
    \   (* (- c (/ (+ a b) 2))))))\n                   2) 100.0) 2)\n      -1))\n",
  "  (cond ((or (&lt; a 0) (&lt; b 0) (&lt; c 0)) -1)\n        ((or (&lt; a (+ b c))\
    \ (&lt; b (+ a c)) (&lt; c (+ a b))) -1)\n        (else (round (* (/ (sqrt (+\
    \ (* (- a (/ b 2)) (- a (/ b 2))) (* (- b (/ a 2)) (- b (/ a 2))))) 2) 100) 0.01))))\n\
    </code>\n", "  (let* ([s (list a b c)]\n         [max-idx (argmax s)])\n    (cond\n\
    \      [(= (sum-vector (sub-vector s max-idx))\n          (list-ref s max-idx))\
    \ -1]\n      [else\n       (* 0.5 (fold + 0 (sub-vector s max-idx))\n        \
    \  (sqrt (- (* (fold + 0 (sub-vector s max-idx))\n                      (fold\
    \ + 0 (sub-vector s max-idx)))\n                   (* (expt (list-ref s max-idx)\
    \ 2)\n                      (- (length s) 1)))))])))\n", "  (cond [(or (= a 0)\
    \ (= b 0) (= c 0)) -1]\n        [(and (= a b) (= b c)) (* a a)]\n        [(and\
    \ (= a b) (= c a)) (* c c)]\n        [(and (= b c) (= c a)) (* a a)]\n       \
    \ [(and (> a b) (> a c)) (* b c)]\n        [(and (> b a) (> b c)) (* a c)]\n \
    \       [(and (> c a) (> c b)) (* a b)]\n        [else -1]))", "    (if (and (<\
    \ (- b c) a) (< (- a c) b) (< (- a b) c))\n        (round (/ (* 1/2 (+ a b c))\
    \ 1000))\n        -1))", "  (cond [(or (= a 0) (= b 0) (= c 0)) -1]\n        [(and\
    \ (&gt;= a b) (&gt;= a c))\n         (sqrt (* (- (* a a) (* b b) (* c c)) 0.25))]\n\
    \        [(and (&gt;= b a) (&gt;= b c))\n         (sqrt (* (- (* b b) (* a a)\
    \ (* c c)) 0.25))]\n        [(and (&gt;= c a) (&gt;= c b))\n         (sqrt (*\
    \ (- (* c c) (* a a) (* b b)) 0.25))]\n        [else -1]))\n</code>\nThe <code>sqrt</code>\
    \ function works differently from the one in the Python version. It first calculates\
    \ the area and then returns the square root.\n", "  (let* ([s (+ a b c)]\n   \
    \      [s-2 (/ s 2)]\n         [area (sqrt (* s-2 (* (- s-2 a) (- s-2 b) (- s-2\
    \ c))))])\n    (if (positive? area)\n        (round area 2)\n        -1)))", " \
    \ (if (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n      (round (/ (sqrt (+\
    \ (* (- (* a a) (* b b)) (* c c)) (* (* 2 a) (* 2 b)) (* (* 2 a) (* 2 c)) (* (*\
    \ 2 b) (* 2 c)))) 4))\n      -1))\n", "  (if (and (> a 0) (> b 0) (> c 0))\n \
    \     (if (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n          (round (/\
    \ (* (sqrt (+ (* (- a (/ b 2)) (- a (/ b 2))) (* (- b (/ a 2)) (- b (/ a 2)))\
    \ (* (- c (/ a 2)) (- c (/ a 2))))) 2) 100))\n          -1)\n      -1))\n", " \
    \ (cond\n    [(or (or (= a 0) (= b 0) (= c 0))\n         (or (> (+ a b) c)\n \
    \            (> (+ a c) b)\n             (> (+ b c) a)))\n      -1]\n    [else\n\
    \      (round (* 0.5 (* (+ a b (- (* a b) (* c a) (* b c)))\n                \
    \       (- (+ a b (- (* a b) (* c a) (* b c))) c))\n                 2)]))\n",
  "  (cond\n    [(and (&gt; a 0) (&gt; b 0) (&gt; c 0))\n     (-&gt;&gt; (list a b\
    \ c)\n          (sort &lt;)\n          (apply -)\n          (apply *)\n      \
    \    (/ 4))]\n    [else -1]))\n</code>\n<code>#lang racket\n", "  (cond\n    [(>=\
    \ a (+ b c)) -1]\n    [(>= b (+ a c)) -1]\n    [(>= c (+ a b)) -1]\n    [else\
    \ (round (* (/ (sqrt (+ (- (* a a) (* b b)) (* c c)) 2) 4) 100))]))\n", "  (let*\
    \ ([s (/ (+ a b c) 2)]\n         [area (sqrt (* s (- s a) (- s b) (- s c)))])\n\
    \    (cond [(zero? area) -1]\n          [else (round area 2)])))\n", "  (define\
    \ (is-valid-triangle a b c)\n    (and\n     (>= (+ a b) c)\n     (>= (+ a c) b)\n\
    \     (>= (+ b c) a)))\n  (if (is-valid-triangle a b c)\n      (round (* 0.5 (*\
    \ (- (+ a b) c) (- (+ a c) b) (- (+ b c) a))) 2)\n      -1))\n</code>\nI just\
    \ learned about the <code>round</code> function.\nIs there a more elegant way\
    \ to write this function?\n\n\nA:\n\nYou really have too many nested <code>if</code>s.\
    \ You can just use a <code>cond</code> clause instead, since you have multiple\
    \ conditions to check:\n<code>(define (triangle_area a b c)\n  (cond\n    [(and\
    \ (&gt;= (+ a b) c)\n          (&gt;= (+ a c) b)\n          (&gt;= (+ b c) a))\n\
    \     (round (* 0.5 (* (- (+ a b) c) (- (+ a c) b) (- (+ b c) a))) 2)]\n    [else\
    \ -1]))\n</code>\nI've also removed the inner <code>is-valid-triangle</code> function,\
    \ and inlined it instead, for clarity.\n", "  (cond\n    [(and (&gt; a 0) (&gt;\
    \ b 0) (&gt; c 0))\n     (cond\n       [(and (&gt; (+ a b) c) (&gt; (+ a c) b)\
    \ (&gt; (+ b c) a))\n        (define p (/ (+ a b c) 2))\n        (define area\
    \ (sqrt (* p (- p a) (- p b) (- p c))))\n        (round area 2))]\n       [else\
    \ -1])]\n    [else -1]))\n</code>\nI'm trying to think how to make it more functional\
    \ and clearer. One thing I thought of was using <code>or</code> instead of <code>cond</code>\
    \ since the second <code>cond</code> is just a \"else\" statement. I also considered\
    \ using a single <code>cond</code> and adding <code>else -1</code> to each clause.\
    \ I'm sure there is a way to use <code>andmap</code> or <code>ormap</code> but\
    \ I'm not sure how to use it to test two different conditions.\n\n\nA:\n\nI would\
    \ not put the <code>cond</code> inside the <code>cond</code>. I would add the\
    \ <code>else</code> to the inner cond:\n<code>(define (triangle_area a b c)\n\
    \  (cond\n    [(and (&gt; a 0) (&gt; b 0) (&gt; c 0))\n     (cond\n       [(and\
    \ (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a))\n        (define p (/ (+\
    \ a b c) 2))\n        (define area (sqrt (* p (- p a) (- p b) (- p c))))\n   \
    \     (round area 2))]\n       [else -1])]\n    [else -1]))\n</code>\nAlternatively,\
    \ you could simplify the above by removing the outer cond, and by replacing the\
    \ inner <code>cond</code> with <code>if</code>.\n<code>(define (triangle_area\
    \ a b c)\n  (if (and (&gt; a 0) (&gt; b 0) (&gt; c 0))\n      (if (and (&gt; (+",
  "  (define s (/ (+ a b c) 2))\n  (define area (sqrt (* s (- s a) (- s b) (- s c))))\n\
    \  (cond\n    [(or (< a 0) (< b 0) (< c 0)) -1]\n    [(and (<= a b) (<= a c))\
    \ -1]\n    [(and (<= b a) (<= b c)) -1]\n    [(and (<= c a) (<= c b)) -1]\n  \
    \  [else (round (* area 100))]))\n", "  (if (and (> (+ a b) c) (> (+ a c) b) (>\
    \ (+ b c) a))\n      (round (* (sqrt (- (* (* a a) (* b b)) (* (* a b) (* a b))))\
    \ 0.5) 2)\n      -1))\n", "  (cond\n    [(and (&gt; c (+ a b)) (&gt; b (+ a c))\
    \ (&gt; a (+ b c)))\n     (-1)]\n    [else\n     (let* ([s (/ (+ a b c) 2)]\n\
    \            [a2 (* s (- s a))]\n            [b2 (* s (- s b))]\n            [c2\
    \ (* s (- s c))])\n       (* (sqrt (+ a2 b2 c2)) 0.5))]))\n</code>\n", "  (let\
    \ ((v (list a b c)))\n    (cond\n      [(<= (min v) 0) -1]\n      [(>= (+ (min\
    \ v) (max v)) (* 2 (median v))) -1]\n      [else (sqrt (* (exterior-product (list\
    \ (max v) (median v)) (max v) (median v)) (+ (* (- (max v) (median v)) (- (max\
    \ v) (median v))) (* (- (max v) (min v)) (- (max v) (min v))))))])))\n", "  (if\
    \ (or (&gt;= (+ a b) c)\n          (&gt;= (+ a c) b)\n          (&gt;= (+ b c)\
    \ a))\n      (* .5 (/ (* a b c) (sum a b c)))\n      -1))\n", "  (if (= (round\
    \ (sqrt (- (* (- (+ a b) c) (- (+ a b) c))\n                        (* (- (+ a\
    \ c) b) (- (+ a c) b))\n                        (* (- (+ b c) a) (- (+ b c) a)))))\n\
    \         0)\n      (round (* 0.5 (* a b)))\n      -1))", "  (define (sorted-list\
    \ x y z)\n    (cond [(< x y) (sorted-list x z y)]\n          [(< y z) (list x\
    \ y z)]\n          [else (list z y x)]))\n  (define (helper x y z)\n    (cond\
    \ [(and (< (+ x y) z) (< (+ y z) x) (< (+ x z) y)) -1]\n          [else (sqrt\
    \ (* (helper2 x y z) (- (helper2 x y z) x)\n                               (-\
    \ (helper2 x y z) y) (- (helper2 x y z) z)))]))\n  (define (helper2 x y z) (/\
    \ (+ x y z) 2))\n  (let ([s (sorted-list a b c)])\n    (printf \"~a\\n\" s)\n\
    \    (printf \"~a\\n\" (helper (car s) (cadr s) (caddr s)))\n    (round (helper\
    \ (car s) (cadr s) (caddr s)) 2)))\n", "  (cond\n    [(and (> (+ a b) c) (> (+\
    \ a c) b) (> (+ b c) a))\n     (round (* 0.5 (- (+ a b c) (* (- a b c) (- b c\
    \ a)))) 2)]\n    [else -1]))\n```\n\n```racket\n#lang racket\n", "  (if (and (&gt;\
    \ (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a))\n      (round (* 0.5 (- (+ a b)\
    \ c) (- (+ a c) b) (- (+ b c) a)))\n      -1))\n</code>\nThis is a homework question\
    \ and I can't find the proper way to get the absolute value of two numbers.\n\n\
    \nA:\n\nThe issue is with the <code>*</code> you are applying (without the proper\
    \ number of arguments). \nYou can use <code>*</code> or <code>expt</code> but\
    \ the way you are using it is incorrect, check the documentation to find the proper\
    \ usage.\nOn the other hand, if you are getting the values of <code>a</code>,\
    \ <code>b</code> and <code>c</code> from user input you should consider that these\
    \ values can be invalid and you should prevent this from happening.\nFinally,\
    \ as a small suggestion, you can use <code>and</code> instead of <code>if</code>\
    \ since you are returning <code>-1</code> in the last case:\n<code>(define (triangle_area\
    \ a b c)\n  (and (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a)\n       (round\
    \ (* 0.5 (- (+ a b) c) (- (+ a c) b) (- (+ b c) a)))))\n</code>\nor even more\
    \ concise:\n<code>(define (triangle_area a b c)\n  (and (&gt; (+ a b) c) (&gt;\
    \ (+ a c) b) (&gt; (+ b c) a)\n       (round (* 0.5 (- (abs (- (+ a b) c))\n \
    \                       (abs (- (+ a c) b))\n                        (abs (- (+\
    \ b c) a)))))))\n</code>\n", "  (cond [(and (>= c (- a b)) (>= b (- a c)) (>=\
    \ a (- b c))) (round (* .5 (- (+ a b c) (- a b) (- a c) (- b c))))]\n        [else\
    \ -1]))", "  (define helper (lambda (side1 side2 side3)\n                   (let\
    \ ((s (+ side1 side2 side3)) (half-s (/ s 2)))\n                     (/ (* half-s\
    \ (- half-s side1) (- half-s side2) (- half-s side3))\n                      \
    \  2))))\n  (cond ((and (< a 1) (< b 1) (< c 1)) -1)\n        ((> (+ a b) c) (helper\
    \ a b c))\n        ((> (+ a c) b) (helper a c b))\n        ((> (+ b c) a) (helper\
    \ b c a))\n        (else -1)))\n", "  (cond\n    [(and (> a 0) (> b 0) (> c 0))\n\
    \     (floor (* 100 (sqrt (* (- (* a a) (* b b) (* c c))\n                   \
    \         (+ (* a a) (* b b) (* c c))))))]\n    [else -1]))\n</code>\n<code>#lang\
    \ racket\n", "  (define (half_perimeter) (/ (+ a b c) 2))\n  (define (is-triangle?)\n\
    \    (let ([p (half_perimeter)])\n      (and (> (+ (- p a) (- p b)) (- p c))\n\
    \           (> (+ (- p b) (- p c)) (- p a))\n           (> (+ (- p c) (- p a))\
    \ (- p b)))))\n  (if (is-triangle?)\n      (round (* (sqrt (half_perimeter)\n\
    \                      (- (half_perimeter) a)\n                      (- (half_perimeter)\
    \ b)\n                      (- (half_perimeter) c))) 2)\n      -1))\n", "  (if\
    \ (and (&gt; a 0)\n           (&gt; b 0)\n           (&gt; c 0)\n           (&gt;\
    \ (+ a b) c)\n           (&gt; (+ a c) b)\n           (&gt; (+ b c) a))\n    \
    \  (round (* 0.5 (- (+ a b c) c) (- (+ a b c) b) (- (+ a b c) a)) 2)\n      -1))\n\
    </code>\nHere, the problem is that <code>&gt;</code> returns a boolean value,\
    \ and <code>&gt;</code> expects numbers. However, <code>&gt;</code> with booleans\
    \ returns a boolean value, which means it's happy. But <code>&gt;</code> with\
    \ numbers and booleans complains. \n<code>&gt; (+ a b) c)\n&gt;: expects type\
    \ &lt;number&gt; as 2nd argument, given: #f; other arguments were: 5\n</code>\n\
    This is the same problem with the other <code>&gt;</code>s.\nI could just break\
    \ each condition off into its own if, but then I'd run into the same problem with\
    \ the outer if.\nI could also just rewrite it all using <code>andmap</code>, but\
    \ then I wouldn't get the benefit of early return on a condition that fails.\n\
    I could also just use <code>cond</code>, but that's a lot of writing out.\nWhat\
    \ is the best way to deal with this?\n\n\nA:\n\nYou are not properly handling\
    \ the numeric conversion part. The <code>&gt;</code> function expects numeric\
    \ arguments, so you'll need to convert the results of <code>&gt;</code> to numbers.\
    \ That's what <code>if</code> is trying to complain to you, but your error message\
    \ doesn't actually say that because it's complaining about something else, you\
    \ have an extra <code>)</code> in there.\nAnyway, the solution would be to call\
    \ <code>&gt;</code> on numbers and then convert the result to a number. Like this:\n\
    <code>(define (triangle_area a b c)\n  (if (and (&gt; a 0)\n           (&gt; b\
    \ 0)\n           (&gt", "  (if (&gt; (+ a b) c)\n      (let ((s (/ (+ a b c) 2)))\n\
    \        (sqrt (- (* s (- s a)) (* s (- s b)) (* s (- s c)))))\n      -1))\n</code>\n\
    As far as I understand, <code>if</code> is executed, if <code>cond</code> is executed,\
    \ and <code>match</code> is executed.\nI would like to know what happens in the\
    \ interpreter. Does it really check a 'truth table' for each expression and how\
    \ does it know how to check a 'truth table' for a predicate. In other words, how\
    \ does the interpreter treat <code>if</code> as a function?\n\n\nA:\n\nI've decided\
    \ to answer my own question for the sake of newbies like me.\nFirst of all it\
    \ is important to understand that programming languages are actually formal languages\
    \ and are built from syntax and semantics.\nIn more detail, syntax is a set of\
    \ rules, which determine the form of a program, while semantics is a set of rules,\
    \ which determine the meaning of a program. The syntax is usually based on the\
    \ grammar, while the semantics defines the meaning of the program in terms of\
    \ what happens when it is run.\nBasically, syntax and semantics are very closely\
    \ related. In fact, semantics is sometimes defined in terms of syntax.\nIn the\
    \ case of Racket, the syntax is defined in terms of the #lang reader, which itself\
    \ is defined by the core language (syntax/core.rkt). The semantics is defined\
    \ in terms of the core language.\nThe core language is the first layer of Racket.\
    \ It defines functions like <code>if</code>, <code>cond</code>, <code>match</code>,\
    \ <code>define</code>, <code>begin</code>, etc. These functions are defined in\
    \ the language, so it knows how to interpret them. In other words, the interpreter\
    \ uses a 'truth table' for each predicate, in order to determine what functions\
    \ to execute, based on a set of conditions and then runs them, which gives the\
    \ meaning of the program.\n", "  (let ([p (+ a b c)])\n    (cond [(<= a b) (-1)]\n\
    \          [(<= b c) (-1)]\n          [(<= c a) (-1)]\n          [else (sqrt (*\
    \ p (- p a) (- p b) (- p c))) ])))\n", "  (if (and (< (+ a b) c) (< (+ a c) b)\
    \ (< (+ b c) a))\n      -1\n      (round (/ (sqrt (- (* (- (+ a b) c)\n      \
    \                     (* (- (+ a c) b)\n                              (* (- (+\
    \ b c) a)\n                                 (* (+ a b c) a b c))))\n         \
    \              4))\n              2)))", "  (if (&gt; (+ a b) c)\n      (round\
    \ (* 0.5 (* a b c)) 2)\n      -1))\n</code>\nI feel like the <code>if</code> statement\
    \ should be wrapped in an <code>and</code> with a similar check on the other two\
    \ sides. \nMy question is how would I achieve this?\n\n\nA:\n\n<code>(define (triangle_area\
    \ a b c)\n  (let* ([ok-1 (&gt; (+ a b) c)]\n         [ok-2 (&gt; (+ a c) b)]\n\
    \         [ok-3 (&gt; (+ b c) a)])\n    (if (and ok-1 ok-2 ok-3)\n        (round\
    \ (* 0.5 (* a b c)) 2)\n        -1)))\n</code>\nA concise version:\n<code>(define\
    \ (triangle_area a b c)\n  (let* ([ok-1 (&gt; (+ a b) c)]\n         [ok-2 (&gt;\
    \ (+ a c) b)]\n         [ok-3 (&gt; (+ b c) a)])\n    (if (and ok-1 ok-2 ok-3)\n\
    \        (* 0.5 (* a b c))\n        -1)))\n</code>\n", "  (define s (/ (+ a b\
    \ c) 2))\n  (define ar (sqrt (- (* s (- s a))\n                      (* s (- s\
    \ b))\n                      (* s (- s c)))))\n  (cond [(or (&lt; a 0)\n     \
    \        (&lt; b 0)\n             (&lt; c 0)) -1]\n        [(or (&lt; a (+ b c))\n\
    \             (&lt; b (+ a c))\n             (&lt; c (+ a b))) -1]\n        [else\
    \ (* 100 (round (/ ar 0.005)))]))\n</code>\n\n<code>#lang racket\n", "  (let*\n\
    \      ((s (cond\n            ((and (<= a 0) (<= b 0) (<= c 0)) 0)\n         \
    \   ((or (<= a 0) (<= b 0) (<= c 0)) -1)\n            (else (+ a b c))))\n   \
    \    (area\n        (cond\n         ((or (>= a s) (>= b s) (>= c s)) -1)\n   \
    \      (else (* (/ s 2) (- s a) (- s b) (- s c))))))\n    (cond\n     ((> area\
    \ 0) (round (* 2 area) 2))\n     (else -1))))\n", "  (cond [(and (&gt;= a b) (&gt;=\
    \ a c)) (sqrt (+ (* (- a b) (- a c)) (* (* 0.25 a) a)))]\n        [(and (&gt;=\
    \ b a) (&gt;= b c)) (sqrt (+ (* (- b a) (- b c)) (* (* 0.25 b) b)))]\n       \
    \ [(and (&gt;= c a) (&gt;= c b)) (sqrt (+ (* (- c a) (- c b)) (* (* 0.25 c) c)))]\n\
    \        [else -1]))\n</code>\nThe first part of my algorithm works fine (I think).\
    \ The problem occurs when I try to implement the last part of the algorithm which\
    \ is basically the check if the triangle is valid. It returns -1 regardless of\
    \ the input. I'm not sure if I'm not checking it properly or I'm not returning\
    \ the value properly. I'm pretty new to Racket so any help is appreciated!\n",
  "  (if (and (&gt;= a 0) (&gt;= b 0) (&gt;= c 0))\n      (let ((v (- a b c)))\n \
    \       (if (or (&gt; 0 v) (&gt; v a) (&gt; v b) (&gt; v c))\n            -1\n\
    \            (let ((p (/ (+ a b c) 2)))\n              (sqrt (* p (- p a) (- p\
    \ b) (- p c)))))\n      -1))\n", "  (define (area)\n    (/ (* (round (* 0.5 (-\
    \ a b c) (+ a b c)) 2))\n          (round (sqrt (* (* (- a b c) (+ a b c) (* (+\
    \ a b c) (- a b c)))\n                          (+ (* (* a a) (* b b)) (* (* b\
    \ b) (* c c)) (* (* c c) (* a a))))) 2)))\n  (if (&gt; (* a b c) (* a b))\n  \
    \    (area)\n      -1))\n", "  (let ((s (/ (+ a b c) 2.0)))\n    (if (&gt;= s\
    \ a)\n        (if (&gt;= s b)\n            (if (&gt;= s c)\n                (/\
    \ (* s (- s a) (- s b) (- s c)) 2.0)\n                -1)\n            -1)\n \
    \       -1)))\n</code>\n", "  (define (is-valid-triangle? a b c)\n    (or\n  \
    \   (and (&gt; a 0) (&gt; b 0) (&gt; c 0)\n          (&gt; (+ a b) c)\n      \
    \    (&gt; (+ a c) b)\n          (&gt; (+ b c) a))\n     (and (= a 0) (= b 0)\
    \ (= c 0))))\n  (cond\n    [(is-valid-triangle? a b c)\n     (round (* 0.5 (-\
    \ a b c a b c)) 2)]\n    [else -1]))\n</code>\n", "  (round (sqrt \n         \
    \ (- (square a) \n             (* 0.25 (- (square (+ a b)) (square c)))))))\n",
  "  (if (or (or (&lt; (+ a b) c) (&lt; (+ a c) b) (&lt; (+ b c) a))\n          (or\
    \ (zero? a) (zero? b) (zero? c)))\n      -1\n      (apply (lambda (s a b c)\n\
    \               (/ (* s (- s a) (- s b) (- s c)) 4))\n             (cond ((= a\
    \ b)\n                    c)\n                   ((= a c)\n                  \
    \  b)\n                   (else\n                    a))\n             a b c)))\n",
  "  (if (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n      (let ((s (/ (+ a b\
    \ c) 2)))\n        (* (- (* s (- s a)) (* s (- s b)) (* s (- s c))) (sqrt (- (*\
    \ s (- s a)) (* s (- s b)) (* s (- s c))))))\n    -1))", "  (cond ((and (> a 0)\
    \ (> b 0) (> c 0))\n         (if (and (>= (+ a b) c)\n                  (>= (+\
    \ a c) b)\n                  (>= (+ b c) a))\n             (round (* 0.5 (* (+\
    \ a b c) (- (+ a b c) a) (- (+ a b c) b) (- (+ a b c) c))) 2)\n             -1))\n\
    \        (else -1)))", "  (cond\n    [(and (> a 0) (> b 0) (> c 0))\n     (sqrt\
    \ (* (- (* a a) (* b b) (* c c)) (/ (- (* a a) (* b b) (* c c)) 8)))]\n    [else\n\
    \     -1]))\n</code>\n", "  (if (and (> a (+ b c))\n           (> b (+ a c))\n\
    \           (> c (+ a b)))\n      (/ (* a b) 2)\n      -1))\n", "  (define (tri_area)\n\
    \    (/ (* (sqrt (+ (* (- b a) (- b a)) (* (- c a) (- c a))))\n         (sqrt\
    \ (+ (* (- a b) (- a b)) (* (- c b) (- c b))))\n         (sqrt (+ (* (- a c) (-\
    \ a c)) (* (- b c) (- b c))))) 2))\n  (cond ((or (> a 0) (> b 0) (> c 0))\n  \
    \       (cond ((>= (+ a b) c)\n                (cond ((>= (+ a c) b)\n       \
    \                (cond ((>= (+ b c) a)\n                              (round (*\
    \ 100 (tri_area))))\n                             (else -1)))\n              \
    \        (else -1)))\n               (else -1)))\n        (else -1)))\n</code>\n\
    I was just wondering whether there was a more clear way to write this.\n\n\nA:\n\
    \n1. No floating point arithmetic\n<code>#lang racket\n", "  (cond [(and (> a\
    \ 0) (> b 0) (> c 0))\n         (cond [(and (> (+ a b) c) (> (+ a c) b) (> (+\
    \ b c) a))\n                (* (/ (sqrt (+ (* (- a (/ a 2)) (- a (/ a 2)))\n \
    \                             (* (- b (/ b 2)) (- b (/ b 2)))\n              \
    \                (* (- c (/ c 2)) (- c (/ c 2))))) 2) 10)\n                (round)]\n\
    \               [else -1])]\n        [else -1]))\n", "  (cond\n    [(and (> a\
    \ 0) (> b 0) (> c 0))\n     (define (sum2 a b) (+ a b))\n     (cond\n       [(and\n\
    \         (>= (sum2 a b) c)\n         (>= (sum2 a c) b)\n         (>= (sum2 b\
    \ c) a))\n        (define (heron a b c)\n          (let*\n              ([p (/\
    \ (+ a b c) 2)]\n               [a (- p a)]\n               [b (- p b)]\n    \
    \           [c (- p c)])\n            (sqrt (* p (* a b c)))))\n        (round\
    \ (* 100 (heron a b c)) 2))\n       [else -1]])\n    [else -1]))\n", "  (define\
    \ (is-valid-triangle a b c)\n    (> (+ a b) c))\n  (cond ((and (is-valid-triangle\
    \ a b c) (is-valid-triangle a c b) (is-valid-triangle b c a))\n\t (* (/ 1 2.0)\
    \ ( + a b (* -1 c))))\n\t(else -1)))\n", "  (cond [(and\n          (and (&gt;\
    \ a 0) (&gt; b 0) (&gt; c 0))\n          (and (&gt; (+ a b) c) (&gt; (+ a c) b)\
    \ (&gt; (+ b c) a)))\n         (+ (/ 1.0 2.0) (* a b c))]\n        [else -1]))\n\
    </code>\nIt works in that it returns either the correct answer or -1, but it generates\
    \ two warnings:\n<code>warning: use of undefined identifier: c\n\n\nwarning: use\
    \ of undefined identifier: b\n</code>\nI'm not sure why these would be undefined.\
    \ How should I be calling them?\n\n\nA:\n\nConsider this line:\n<code>(and (&gt;\
    \ a 0) (&gt; b 0) (&gt; c 0))\n</code>\nSince the <code>and</code> is inside the\
    \ parentheses, the whole line is treated as a boolean expression, which means\
    \ that <code>&gt; a 0</code> is interpreted as a test of whether <code>&gt;</code>\
    \ is greater than <code>a</code>, which is <code>0</code>. <code>a</code> is undefined,\
    \ so <code>&gt;</code> is also undefined.\nThat means that the <code>and</code>\
    \ needs to be outside the parentheses:\n<code>(and (&gt; a 0) (&gt; b 0) (&gt;\
    \ c 0))\n</code>\nThis is the same with the other lines in the <code>cond</code>\
    \ clause.\n", "  (cond\n    [(and (>= a b) (>= a c))\n     (sqrt ( + (* (- c a)\
    \ (- c a)) (* (- b a) (- b a))))]\n    [(and (>= b a) (>= b c))\n     (sqrt (\
    \ + (* (- c b) (- c b)) (* (- a b) (- a b))))]\n    [(and (>= c a) (>= c b))\n\
    \     (sqrt ( + (* (- b c) (- b c)) (* (- a c) (- a c))))]\n    [else -1]))\n",
  "  (define (two-sided-sum side1 side2)\n    (+ side1 side2))\n  (define (third-side\
    \ side1 side2)\n    (- side1 side2))\n  (define (valid-triangle? side1 side2 side3)\n\
    \    (and\n     (and\n      (&gt;= side1 side2)\n      (&gt;= side2 side3))\n\
    \     (&gt; (two-sided-sum side1 side2) side3)))\n  (define (heron-area a b c)\n\
    \    (sqrt\n     (+\n      (*\n       (-\n        (+ a b c)\n        a)\n    \
    \   (*\n        (-\n         (+ a b c)\n         b)\n        (-\n         (+ a\
    \ b c)\n         b)))\n      (*\n       (-\n        (+ a b c)\n        c)\n  \
    \     (*\n        (-\n         (+ a b c)\n         c)\n        (-\n         (+\
    \ a b c)\n         c))))))\n  (cond\n   ((valid-triangle? a b c)\n    (round (heron-area\
    \ a b c) 2))\n   (else -1)))\n</code>\nIt works as expected:\n<code>&gt; (triangle_area\
    \ 3 4 5)\n6.0\n&gt; (triangle_area 3 3 3)\n3.9\n&gt; (triangle_area 1 2 3)\n-1\n\
    </code>\nHowever, the code that I wrote is not elegant or the cleanest. What are\
    \ some ways that I can improve on it?\n", "  (cond [(and (&gt;= a b) (&gt;= a\
    \ c))   (+ (* (/ b 2) c) (* (- a b) (/ a 2)) (* (- a c) (/ a 2)))]\n        [(and\
    \ (&gt;= b a) (&gt;= b c))   (+ (* (/ a 2) c) (* (- b a) (/ b 2)) (* (- b c) (/\
    \ b 2)))]\n        [(and (&gt;= c a) (&gt;= c b))   (+ (* (/ a 2) b) (* (- c a)\
    \ (/ c 2)) (* (- c b) (/ c 2)))]\n        [else                       0]))\n</code>",
  "  (if (and (&gt; a 0)\n           (&gt; b 0)\n           (&gt; c 0)\n         \
    \  (&gt; (+ a b) c)\n           (&gt; (+ a c) b)\n           (&gt; (+ b c) a))\n\
    \      (round (* 0.5 (sqrt (- (* a a)\n                             (* (+ a b)\
    \ (+ a b))\n                             (* (+ a c) (+ a c))\n               \
    \              (* (+ b c) (+ b c)))) 2))\n      -1))\n</code>\nBut I'm having\
    \ two problems with this code:\n\nIt's not as clean as it could be, especially\
    \ the part with the <code>sqrt</code>. What could I do to make it more readable?\n\
    I'm not sure the computation is correct, I'm trying to use the formula <code>area\
    \ = sqrt(p*(p-a)*(p-b)*(p-c))</code> where <code>p</code> is the half of the perimeter.\n\
    \n\n\nA:\n\nI have a hard time understanding your code, you could make it easier\
    \ on the reader if you include comments:\n<code>;; Given the lengths of the three\
    \ sides of a triangle. Return the area of", "  (cond\n    [(and (&gt; (+ a b)\
    \ c) (&gt; (+ a c) b) (&gt; (+ b c) a))\n     (/ (* (sqrt (+ (* (- a (/ b 2))\
    \ (- a (/ b 2))) (* (- b (/ c 2)) (- b (/ c 2)))))\n            (- c (/ a 2)))\n\
    \        2)]\n    [else -1]))\n</code>\nIn short, if <code>a</code>, <code>b</code>,\
    \ and <code>c</code> form a valid triangle, then it will calculate the area and\
    \ round it to 2 decimal points; otherwise it will return -1.\nI'm wondering if\
    \ there's a better way to write this code. For example, I think it would be better\
    \ if I could remove the <code>sqrt</code> and the <code>/</code> before the 2\
    \ so that I could simplify it to <code>(* 2 (- c (/ a 2)))</code>. However, when\
    \ I do that, the <code>round</code> function doesn't work as I would expect it\
    \ to.\nI thought about using the <code>let</code> binding to make it slightly\
    \ cleaner, but I don't think it would help a lot here.\n\n\nA:\n\nFirst, let's\
    \ do a little bit of refactoring:\n<code>(define (triangle_area a b c)\n  (cond\n\
    \    [(and (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a))\n     (round (*\
    \ 2 (- c (/ a 2))) 2)]\n    [else -1]))\n</code>\nYou can now see that you are\
    \ using <code>round</code> on something that is only a function of <code>a</code>\
    \ and <code>c</code>, so we should probably write a function just for that:\n\
    <code>(define (f a c)\n  (round (* 2 (- c (/ a 2))) 2))\n</code>\nNow let's use\
    \ <code>let</code> in order to introduce some more convenient variables (I also\
    \ changed their names, since <code>a</code>, <code>b</code>, and <code>c</code>\
    \ are a bit too generic):\n<code>(define (triangle_", "  (define (semi-perimeter)\
    \ (/ (+ a b c) 2))\n  (define (area)\n    (sqrt (* (semi-perimeter)\n        \
    \     (- (semi-perimeter) a)\n             (- (semi-perimeter) b)\n          \
    \   (- (semi-perimeter) c))))\n  (define (is-valid)\n    (or (< a 0)\n       \
    \ (< b 0)\n        (< c 0)\n        (<= a (+ b c))\n        (<= b (+ a c))\n \
    \       (<= c (+ a b))))\n  (cond ((is-valid) -1)\n        (else (round (* 100\
    \ (area))) 2)))\n", "  (cond [(<= a 0) -1]\n        [(<= b 0) -1]\n        [(<=\
    \ c 0) -1]\n        [(and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a)) \n      \
    \   (* 1/2 (* a b c))]\n        [else -1]))", "  (cond\n    [(or (< a 0) (< b\
    \ 0) (< c 0)) -1]\n    [(or (> a (+ b c)) (> b (+ a c)) (> c (+ a b))) -1]\n \
    \   [else\n     (/\n      (*\n       (sqrt\n        (+\n         (*\n        \
    \  (- a (/ b 2))\n          (- a (/ b 2)))\n         (*\n          (- b (/ a 2))\n\
    \          (- b (/ a 2)))\n         (*\n          (- c (/ a 2))\n          (-\
    \ c (/ a 2)))))\n       a)\n      2)]))\n", "  (cond [(>= (+ a b) c)\n       \
    \  (round (* (/ (+ a b) 2) (sqrt (- (sqr c) (/ (sqr (- a b)) 4)))) 2)]\n     \
    \   [else -1]))\n", "  (cond\n    [(or (&gt;= a (* 3 b)) (&gt;= b (* 3 a)) (&gt;=\
    \ a (* 3 c)) (&gt;= c (* 3 a)) (&gt;= b (* 3 c)) (&gt;= c (* 3 b))) -1]\n    [else\
    \ (round (/ (sqrt (+ (* (- a b) (- a b)) (* (- b c) (- b c)) (* (- c a) (- c a))))\
    \ 2))]))\n</code>\nBut as you can see, it's not that short and elegant. Is there\
    \ a better way?\n\n\nA:\n\nThe basic idea is that the area of a triangle is half\
    \ the product of the base and height.  You already have the base of the triangle.\
    \  You can get the height by using the law of cosines.\n<code>(define (triangle-area\
    \ a b c)\n  (define s (/ (+ a b c) 2))\n  (define h (sqrt (- s (* s a) (* s b)\
    \ (* s c))))\n  (* h (/ b 2)))\n</code>\n", "  (cond\n    [(and (> (+ a b) c)\
    \ (> (+ a c) b) (> (+ b c) a)) (* 0.5 (* (- a b) (- a c) (- b c)))]\n    [else\
    \ -1]))\n", "  (if (and (not (= (- a b) 0)) \n           (not (= (- b c) 0)) \n\
    \           (not (= (- a c) 0)))\n      (round (* 0.5 (abs (- (* a c) (* b c)\
    \ (* a b)))) 2)\n      -1))\n", "  (cond [(>= (+ a b) c) \n         (round (*\
    \ .5 (- (+ a b) c) (- (+ a b) c) (- a c) (- b c)))\n         (round (* .5 (* (-\
    \ a c) (- b c))))]\n        [else -1]))\n", "  (if (and (&gt; a 0) (&gt; b 0)\
    \ (&gt; c 0))\n      (if (and (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c)\
    \ a))\n          (let ((p (/ (+ a b c) 2)))\n            (round (* p (- p a) (-\
    \ p b) (- p c)) 2))\n          -1)\n      -1))\n</code>\n", "  (cond [(>= (+ a\
    \ b) c) (cond [(>= (+ a c) b) (cond [(>= (+ b c) a) (define s (/ (+ a b c) 2))\n\
    \                                                                (* s (- s a)\
    \ (- s b) (- s c))\n                                                         \
    \       )]\n                                                   [-1]\n        \
    \                                           )]\n                           [-1]\n\
    \                           )]\n        [-1]\n        )\n  )\n", "  (let* ([s\
    \ (+ a b c)]\n         [s (/ s 2)])\n    (cond\n      [(<= (+ a b) c) -1]\n  \
    \    [(<= (+ a c) b) -1]\n      [(<= (+ b c) a) -1]\n      [else (* s (- s a)\
    \ (- s b) (- s c))])))\n", "  (cond ((and (&gt;= a 0)\n              (&gt;= b\
    \ 0)\n              (&gt;= c 0)\n              (&gt;= (+ a b) c)\n           \
    \   (&gt;= (+ a c) b)\n              (&gt;= (+ b c) a))\n         (cond ((and\
    \ (= a 0)\n                     (= b 0)\n                     (= c 0))\n     \
    \           0)\n               (else\n                (define p (+ a b c))\n \
    \               (define s (/ p 2))\n                (round (* s (- s a) (- s b)\
    \ (- s c)) 2))))\n        (else -1)))\n</code>\nCould you please tell me if this\
    \ code is efficient and readable?\nExample test case:\n<code>(check-expect (triangle_area\
    \ 2.5 2.0 4.5) (-1))", "  (if (or (&gt;= (+ a b) c)\n          (&gt;= (+ a c)\
    \ b)\n          (&gt;= (+ b c) a))\n      (let* ([s (/ (+ a b c) 2)]\n       \
    \      [area (sqrt (* s (- s a) (- s b) (- s c)))])\n        (round (* 100 area)))\n\
    \      -1))\n</code>\nI'm getting this error:\n<code>ReferenceError: Can't find\
    \ variable: undefined\n  (no-cache:///C:/Users/User/AppData/Local/Temp/edit-3b500eb4-65d0-4134-9c6b-2dfd2a6ddf0d/main.rkt:49:7)\n\
    \  (no-cache:///C:/Users/User/AppData/Local/Temp/edit-3b500eb4-65d0-4134-9c6b-2dfd2a6ddf0d/main.rkt:49:7)\n\
    \  (no-cache:///C:/Users/User/AppData/Local/Temp/edit-3b500eb4-65d0-4134-9c6b-2dfd2a6ddf0d/main.rkt:49:7)\n\
    \  (no-cache:///C:/Users/User/AppData/Local/Temp/edit-3b500eb4-65d0-4134-9c6b-2dfd2a6ddf0d/main.rkt:49:7)\n\
    \  (no-cache:///C:/Users/User/AppData/Local/Temp/edit-3b500eb4-65d0-4134-9c6b-2dfd2a6ddf0d/main.rkt:49:7)\n\
    \  (no-cache:///C:/Users/User/AppData/Local/Temp/edit-3b500eb4-65d0-4134-9c6b-2dfd2a6ddf0d/main.rkt:49:7)\n\
    \  (no-cache:///C:/Users/User/AppData/Local/Temp/edit-3b500eb4-65d0-4134-9c6",
  "  (cond\n    [(> (+ a b) c) (round (* 0.5 (* a b (sin c)) ) 2)]\n    [(> (+ a c)\
    \ b) (round (* 0.5 (* a c (sin b)) ) 2)]\n    [(> (+ b c) a) (round (* 0.5 (*\
    \ b c (sin a)) ) 2)]\n    [else -1]))\n", "  (define (helper a b c)\n    (* (/\
    \ (* a b) 2) (- 1 (sqrt (- 1 (sqrt (- 1 (/ (+ (* 2 a) (* 2 b)) (* 2 c))))))))\
    \ \n  (define (judge a b c)\n    (cond [(< a (+ b c)) -1]\n          [(< b (+\
    \ a c)) -1]\n          [(< c (+ a b)) -1]\n          [else helper a b c]))\n \
    \ (cond [(< a 0) -1]\n        [(< b 0) -1]\n        [(< c 0) -1]\n        [else\
    \ judge a b c]))\n", "  (if (and (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\
    \ \n           (not (any (lambda (x) (= x 0)) (list a b c))))\n      (* (/ 1 2.0)\
    \ a b (sin (angle-in-radians (acos (/ (- (* (- a b) (- a c)) (* b c))\n      \
    \                                                  (sqrt (+ (* (- (+ a b) c) (-\
    \ b c) (- c a)) 2)))))))\n      -1))\n", "  (if (and (and (< a b) (< b c))\n \
    \          (and (< b a) (< a c))\n           (and (< c a) (< a b)))\n      (round\
    \ (* 0.5 (- a (- b c)) (- b (- a c)) (- c (- a b))) 2)\n      -1))\n", "  (define\
    \ (is-valid? a b c)\n    (and (&gt; (+ a b) c)\n         (&gt; (+ a c) b)\n  \
    \       (&gt; (+ b c) a)))\n  (define (area a b c)\n    (sqrt (+ (* (- (* a a)\
    \ (* b b)) (* c c))\n            (* (- (* a a) (* c c)) (* b b))\n           \
    \ (* (- (* b b) (* c c)) (* a a)))))\n  (cond [(is-valid? a b c) \n         (round\
    \ (* 100 (area a b c)))]\n        [else\n         -1]))\n", "  (let* ([s (/ (+\
    \ a b c) 2.0)]\n         [area (sqrt (* s (- s a) (- s b) (- s c)))])\n    (if\
    \ (&lt; area 0) -1 (round (* area 100)))))\n</code>\nThe <code>let*</code> is\
    \ a bit confusing, but it saves a few multiplications in the end.\n", "  (if (and\
    \ (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a))\n      (* (/ (- (+ a b)\
    \ c) 2) (sqrt (- (* (+ a b) (+ a b)) (* 4 (* a a)) (* 4 (* b b)) (* c c))))\n\
    \      -1))\n</code>\nHowever this does not work. It's quite possible that I just\
    \ made a bad mistake in the formula, however I can't seem to find any mistake.\
    \ Any help will be greatly appreciated!\n\n\nA:\n\nBased on the formula for area\
    \ of a triangle:\n<code>(sqrt (+ (* a (- b c)) (* b (- c a)) (* c (- a b))))\n\
    </code>\n", "  (let ([s (+ a b c)])\n    (cond\n      [(< a 0) -1]\n      [(<\
    \ b 0) -1]\n      [(< c 0) -1]\n      [(<= s (* 2 a)) -1]\n      [(<= s (* 2 b))\
    \ -1]\n      [(<= s (* 2 c)) -1]\n      [else (round (* .5 (- s a) (- s b) (-\
    \ s c)) 2)])))\n", "  (let ((s (/ (+ a b c) 2)))\n    (cond ((<= (+ a b) c) -1)\n\
    \          ((<= (+ a c) b) -1)\n          ((<= (+ b c) a) -1)\n          (else\n\
    \           (sqrt (* s (- s a) (- s b) (- s c)))))))\n", "  (cond [(and (&gt;\
    \ a 0) (&gt; b 0) (&gt; c 0)) (round (* (sqrt (* (* (- a (/ b 2)) (- a (/ b 2)))\
    \ \n                                                       (- (* c c) (* b (/\
    \ b 2)))))\n                                             2))]\n        [else -1]))\n",
  "  (cond\n    [(>= (+ a b) c)\n     (round (* (/ (expt (- (+ a b) c) 2) 2) (sqrt\
    \ (+ (* (+ a b) (- a c)) (* (- a b) (- b c))))))]\n    [else -1]))\n", "  (cond\n\
    \    [(and (>= a 0) (>= b 0) (>= c 0))\n     (cond\n       [(and (>= (+ a b) c)\
    \ (>= (+ a c) b) (>= (+ b c) a))\n        (define (perimeter a b c) (+ a b c))\n\
    \        (define s (/ (perimeter a b c) 2))\n        (define a (sqrt (* s (- s\
    \ a) (- s b) (- s c))))\n        (round (* a 100))]\n       [else -1])]\n    [else\
    \ -1]))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
