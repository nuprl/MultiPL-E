name: HumanEval_10_make_palindrome
language: rkt
prompt: "#lang racket\n\n;; Find the shortest palindrome that begins with a supplied\
  \ string.\n;; Algorithm idea is simple:\n;; - Find the longest postfix of supplied\
  \ string that is a palindrome.\n;; - Append to the end of the string reverse of\
  \ a string prefix that comes before the palindromic suffix.\n(define (make_palindrome\
  \ string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_palindrome))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"x\") \"\
  x\")\n    (check-equal? (candidate \"xyz\") \"xyzyx\")\n    (check-equal? (candidate\
  \ \"xyx\") \"xyx\")\n    (check-equal? (candidate \"jerry\") \"jerryrrej\")\n))\n\
  \n(test-humaneval)"
completions: ["  (let ([middle (length string)])\n    (define (is_palindrome? string\
    \ start end)\n      (cond\n        [(= start end) #t]\n        [(= (substring\
    \ string start (+ start 1))\n            (substring string (- end 1) end))\n \
    \        (is_palindrome? string (+ start 1) (- end 1))]\n        [else #f]))\n\
    \    (let loop ([new-middle middle])\n      (if (is_palindrome? string 0 new-middle)\n\
    \          (begin\n            (define (reverse-prefix prefix-start)\n       \
    \       (let loop ([prefix-end (- prefix-start 1)])\n                (if (&lt;\
    \ prefix-end 0)\n                    (list)\n                    (cons (substring\
    \ string prefix-end (+ prefix-end 1))\n                          (reverse-prefix\
    \ (- prefix-end 1))))))\n            (build-string (append (reverse-prefix (-\
    \ middle 1))\n                                  (substring string 0 middle)\n\
    \                                  (reverse-prefix (- middle 1)))))\n        \
    \  (loop (- new-middle 1)))))\n</code>\nNote: <code>build-string</code> is from\
    \ this answer.\nExample of usage:\n<code>&gt; (make_palindrome \"forgeeksskeegfor\"\
    )\n\"forgeeksskeegfor\"\n&gt; (make_palindrome \"abc\")\n\"abcba\"\n&gt; (make_palindrome\
    \ \"\")\n\"\"\n&gt; (make_palindrome \"a\")\n\"a\"\n&gt; (make_palindrome \"abba\"\
    )\n\"abba\"\n&gt; (make_palindrome \"aaa\")\n\"aaa\"\n&gt; (make_palindrome \"\
    aba\")\n\"aba\"\n&gt; (make_palindrome \"abb\")\n\"abba\"\n&gt; (make_palindrome\
    \ \"ba\")\n\"baab\"\n&gt; (make_palindrome \"ab\")\n\"abba\"\n&gt; (make_palindrome\
    \ \"aa\")\n\"aa\"\n&gt; (make_palindrome \"aab\")\n\"aabaa\"\n&gt; (make_palindrome\
    \ \"ababa\")\n\"ababa", "  (define (make_palindrome_iter string len max)\n   \
    \ (if (= len max)\n        string\n        (if (string=? (substring string 0 len)\
    \ (reverse (substring string len max)))\n            (make_palindrome_iter string\
    \ (+ len 1) max)\n            (string-append string (reverse (substring string\
    \ 0 (- len 1)))))))\n  (make_palindrome_iter string 1 (string-length string)))\n",
  "  (let* ([string-length (string-length string)]\n         [suffix (substring string\
    \ 0 (- string-length 1))]\n         [palindrome-suffix (find-palindrome-suffix\
    \ string)])\n    (string-append string (reverse (substring string 0 (- string-length\
    \ (string-length palindrome-suffix)))))))\n", "  (define (palindrome-length string\
    \ index i)\n    (if (= i 0)\n        (- index 1)\n        (if (char=? (string-ref\
    \ string index) (string-ref string (- index i)))\n            (palindrome-length\
    \ string index (- i 1))\n            (- index i))))\n  (define (longest-palindrome-suffix\
    \ string index)\n    (if (&lt; index (- (string-length string) 1))\n        (let\
    \ ((length (palindrome-length string index (string-length string))))\n       \
    \   (if (= length 0)\n              (longest-palindrome-suffix string (+ index\
    \ 1))\n              (values length (- index length))))\n        (values 0 (-\
    \ (string-length string) 1))))\n  (values (string-append string (reverse (substring\
    \ string 0 (longest-palindrome-suffix string 0)))) (longest-palindrome-suffix\
    \ string 0)))\n</code>\nThe longest-palindrome-suffix function finds the longest\
    \ palindromic suffix of the supplied string (the suffix starting from a given\
    \ index). The palindrome-length function finds the length of a palindrome in the\
    \ supplied string (at index).\n", "  (define (find-longest-postfix-palindrome\
    \ string)\n    (define (find-palindrome? string index)\n      (cond [(= index\
    \ 0) #t]\n            [(= (string-ref string 0) (string-ref string index)) (find-palindrome?\
    \ (substring string 1 (- index 1)) (- index 1))]\n            [else #f]))\n  \
    \  (define (iter string index)\n      (cond [(find-palindrome? string index) index]\n\
    \            [else (iter string (- index 1))]))\n    (iter string (- (string-length\
    \ string) 1)))\n  (define (string-reverse str)\n    (define (string-reverse-iter\
    \ str index)\n      (cond [(= index 0) str]\n            [else (string-reverse-iter\
    \ (string-append (string #\\x (string-ref str (- index 1))) (substring str 0 (-\
    \ index 1))) (- index 1))]))\n    (string-reverse-iter str (string-length str)))\n\
    \  (cond [(string=? (string-reverse string) string) string]\n        [else (string-append\
    \ string (string-reverse (substring string 0 (find-longest-postfix-palindrome\
    \ string))))]))\n", "  (match string\n    ['() '()]\n    [(cons a rest)\n    \
    \ (if (null? rest)\n         (cons a (cons a '()))\n         (if (equal? a (last\
    \ rest))\n             (make_palindrome (list-rest rest))\n             (append\
    \ string (reverse string))))]))\n", "  (define (reverse-range start end string)\n\
    \    (for/fold ([out \"\"] ([i (in-range start end)]) #:when (not (empty? string)))\n\
    \      (string-append out (string-ref string i))))\n  (define (reverse string)\n\
    \    (reverse-range 0 (string-length string) string))\n  (define (find-longest-palindrome\
    \ start end string)\n    (cond\n      [(> start end) '()]\n      [(string=? (reverse-range\
    \ start end string) (reverse-range start end string)) (cons (cons start end) '())]\n\
    \      [else (find-longest-palindrome (add1 start) end string)]))\n  (define (find-longest-palindrome-region\
    \ start end string)\n    (cond\n      [(> start end) '()]\n      [(string=? (reverse-range\
    \ start end string) (reverse-range start end string)) (list start end)]\n    \
    \  [else (find-longest-palindrome-region (add1 start) end string)]))\n  (define\
    \ (find-longest-palindrome-region-start-at string position)\n    (find-longest-palindrome-region\
    \ position (sub1 (string-length string)) string))\n  (cond\n    [(empty? string)\
    \ \"\"]\n    [(string=? string (reverse string)) string]\n    [else (string-append\
    \ string (reverse (reverse-range 0 (caar (find-longest-palindrome-region-start-at\
    \ string 0)) string)))]))\n", "  (define reversed-string (reverse string))\n \
    \ (define (is-palindrome? string)\n    (string=? string reversed-string))\n  (let\
    \ loop ((i (sub1 (string-length string))))\n    (if (&lt; i 0)\n        #f\n \
    \       (if (is-palindrome? (substring string 0 i))\n            (string-append\
    \ (substring string i) reversed-string)\n            (loop (sub1 i))))))\n</code>\n\
    There is a Racket function <code>string-split</code> that splits a string on a\
    \ given character and returns a list of substring.  I used this function to find\
    \ a substring before and after the given character.\n<code>#lang racket\n", " \
    \ (string-append\n   string\n   (reverse (substring string 0 (- (string-length\
    \ string) (find-palindrome-suffix string))))))\n", "  (define (split_on_palindrome\
    \ string)\n    (let ([length (string-length string)])\n      (define (check i)\n\
    \        (if (&lt; i length)\n            (if (equal? (substring string 0 i) (substring\
    \ string length))\n                (+ i 1)\n                (check (+ i 1)))\n\
    \            0))\n      (check 1)))\n  (let ([suffix-len (split_on_palindrome\
    \ string)])\n    (string-append string (substring (reverse string) suffix-len))))\n\
    </code>\nExample:\n<code>&gt; (make_palindrome \"cab\")\n\"cabbac\"\n&gt; (make_palindrome\
    \ \"abc\")\n\"abcba\"\n&gt; (make_palindrome \"ab\")\n\"aba\"\n&gt; (make_palindrome\
    \ \"abcabcabcabcabc\")\n\"abcabcabcabcabcabcbcbabcabcabc\"\n</code>\n", "  (let*\
    \ ([start (string-length string)]\n         [rest (string-length string)])\n \
    \   (define (find-palindrome-postfix i)\n      (if (equal? (string-ref string\
    \ i) (string-ref string (- rest i)))\n          (begin\n            (set! start\
    \ i)\n            (find-palindrome-postfix (+ i 1)))\n          (begin\n     \
    \       (set! rest (+ rest 1))\n            (find-palindrome-postfix 0))))\n \
    \   (find-palindrome-postfix 0)\n    (string-append string (string-reverse (substring\
    \ string 0 start)))))\n", "  (let* ([string-length (string-length string)]\n \
    \        [i (car (for/fold ([i (add1 string-length)])\n                      ([j\
    \ (in-range string-length)]\n                      #:when (and (and (and (and\
    \ (= (string-ref string j) (string-ref string (- i 1)))\n                    \
    \                            (&lt; (- i 1) j))\n                             \
    \              (and (= (string-ref string j) (string-ref string (- i 2)))\n  \
    \                                              (&lt; (- i 2) j)))\n          \
    \                            (and (= (string-ref string j) (string-ref string\
    \ (- i 3)))\n                                           (&lt; (- i 3) j)))\n \
    \                                 (and (= (string-ref string j) (string-ref string\
    \ (- i 4)))\n                                       (&lt; (- i 4) j))))\n    \
    \                  (list (add1 j) j)))]\n         [suffix (substring string 0\
    \ i)])\n    (format \"~a~a\" suffix (reverse (substring string i (string-length\
    \ string))))))\n", "  (let ([len (string-length string)])\n    (define (palindrome\
    \ string start end)\n      (let ([string-diff (- end start)])\n        (if (=\
    \ string-diff 1) (if (char=? (string-ref string start) (string-ref string end))\
    \ string \"\")\n            (let ([mid (/ (+ start end) 2)])\n              (cond\
    \ [(char=? (string-ref string start) (string-ref string end)) (palindrome string\
    \ (+ start 1) (- end 1))]\n                    [else \"\"])))))\n    (define (find-longest-palindrome-postfix\
    \ string max-len)\n      (cond [(> max-len (string-length string)) string]\n \
    \           [else (let ([tmp (palindrome string 0 max-len)])\n               \
    \     (if (string=? tmp \"\") (find-longest-palindrome-postfix string (+ max-len\
    \ 1)) tmp))]))\n    (string-append string (substring (reverse string) 0 (- (string-length\
    \ (find-longest-palindrome-postfix string 0)) (string-length string))))))\n",
  "  (define (postfix-palindrome-length string i j)\n    (cond ((> i j) 0)\n     \
    \     ((equal? (string-ref string i) (string-ref string j))\n           (+ (postfix-palindrome-length\
    \ string (+ i 1) (- j 1)) 2))\n          (else (postfix-palindrome-length string\
    \ (+ i 1) (- j 1)))))\n  (define (shortest-palindrome string)\n    (string-append\
    \ string (substring (reverse string) (postfix-palindrome-length string 0 (- (string-length\
    \ string) 1)))))\n  (shortest-palindrome string))\n", "  (define (longest-palindrome-postfix\
    \ string start-index)\n    (define (is-palindrome string start-index end-index)\n\
    \      (if (or (&lt;= start-index end-index)\n              (not (equal? (string-ref\
    \ string start-index) (string-ref string end-index))))\n          #f\n       \
    \   (is-palindrome string (add1 start-index) (sub1 end-index))))\n    (let loop\
    \ ((start-index start-index)\n               (len (sub1 (string-length string))))\n\
    \      (if (is-palindrome string start-index len)\n          len\n          (loop\
    \ start-index (sub1 len)))))\n  (let* ((postfix-length (longest-palindrome-postfix\
    \ string 0))\n         (prefix-string (substring string 0 (sub1 postfix-length))))\n\
    \    (string-append string (string-reverse prefix-string))))\n</code>\nUsage example:\n\
    <code>&gt; (make-palindrome \"abca\")\n\"abcaba\"\n&gt; (make-palindrome \"abcba\"\
    )\n\"abcba\"\n&gt; (make-palindrome \"abacaba\")\n\"abacaba\"\n&gt; (make-palindrome\
    \ \"\")\n\"\"\n&gt; (make-palindrome \"a\")\n\"a\"\n&gt; (make-palindrome \"aa\"\
    )\n\"aa\"\n&gt; (make-palindrome \"ab\")\n\"abba\"\n&gt; (make-palindrome \"ababab\"\
    )\n\"abababa\"\n</code>\n", "  (define (recurse string start end)\n    (if (or\
    \ (= start end)\n            (= start (- end 1)))\n        (list start end)\n\
    \        (let ((check (recurse string (+ start 1) (- end 1))))\n          (if\
    \ (and (= (string-ref string (car check)) (string-ref string start))\n       \
    \            (= (string-ref string (cadr check)) (string-ref string end)))\n \
    \             (list start end)\n              (list (car check) (- end 1))))))\n\
    \  (define (reverse_string string start end)\n    (if (&gt; start end)\n     \
    \   \"\"\n        (string-append (reverse_string string (+ start 1) end)\n   \
    \                    (string (string-ref string start)))))\n  (let* ((result (recurse\
    \ string 0 (- (string-length string) 1)))\n         (first (car result))\n   \
    \      (last (cadr result)))\n    (string-append string (reverse_string string\
    \ first last))))\n", "  (let loop ([s string] [s-length (string-length string)])\n\
    \    (let* ([matches (string-match (regexp #rx\"^(.*?)\\\\1$\") s)]\n        \
    \   [match-length (- (cadr matches) (car matches))])\n      (if (= s-length match-length)\n\
    \          string\n          (loop (substring s 1) (substring-length s 1))))))\n",
  "  (define (make_palindrome-helper string s)\n    (if (string-suffix? string s)\
    \ (string-reverse (substring string 0 (- (string-length string) (string-length\
    \ s))))\n      (make_palindrome-helper string (substring s 0 (- (string-length\
    \ s) 1)))))\n  (append string (make_palindrome-helper string string)))\n", " \
    \ (define (palindrome? str)\n    (equal? str (string-reverse str)))\n  (define\
    \ (palindrome-postfix str)\n    (if (palindrome? str)\n        str\n        (palindrome-postfix\
    \ (substring str 1))))\n  (string-append string (string-reverse (substring string\
    \ 0 (- (string-length string) (string-length (palindrome-postfix string)))))))\n",
  "  (define (longest-palindrome? string start end)\n    (define len (- end start))\n\
    \    (and (<= len 1) #t)\n    (and\n     (= (string-ref string start) (string-ref\
    \ string (- end 1)))\n     (longest-palindrome? string (+ start 1) (- end 1))))\n\
    \  (define (find-longest-palindrome string start end)\n    (define len (- end\
    \ start))\n    (cond\n     ((and (<= len 1) start) start)\n     ((and (= (string-ref\
    \ string start) (string-ref string (- end 1)))\n           (find-longest-palindrome\
    \ string (+ start 1) (- end 1)))\n      (find-longest-palindrome string (+ start\
    \ 1) (- end 1)))\n     (else start)))\n  (let ([len (string-length string)])\n\
    \    (string-append string (substring (reverse string) 0 (- len (find-longest-palindrome\
    \ string 0 len))))))\n", "  (define (find-palindrome i j)\n    (cond\n      ((&gt;\
    \ i j) #t)\n      ((equal? (substring string i (+ i 1)) (substring string j (+\
    \ j 1))) (find-palindrome (+ i 1) (- j 1)))\n      (#f)))\n  (define (find-longest-palindrome\
    \ i j)\n    (cond\n      ((&gt; i j) '())\n      ((find-palindrome i j) (substring\
    \ string i (+ i 1)))\n      (else (find-longest-palindrome (+ i 1) j))))\n  (let*\
    \ ((prefix-length (- (string-length string) 1))\n         (palindrome-length (-\
    \ (string-length string) prefix-length))\n         (palindrome (find-longest-palindrome\
    \ prefix-length (- (string-length string) 1))))\n    (string-append string (substring\
    \ (reverse string) 0 prefix-length) palindrome)))\n</code>\n", "  (define (find-longest-palindrome\
    \ string len)\n    (define (find-longest-palindrome-aux string1 string2 len1 len2)\n\
    \      (cond ((= len1 1) string1)\n            ((= len2 1) string2)\n        \
    \    ((string=? (substring string1 0 len1) (substring string2 (- len2) len2))\n\
    \             (find-longest-palindrome-aux string1 string2 (- len1 1) (- len2\
    \ 1)))\n            (else (find-longest-palindrome-aux string1 string2 (- len1\
    \ 1) len2))))\n    (find-longest-palindrome-aux string (reverse string) len len))\n\
    \  (string-append string (substring (reverse string) (string-length (find-longest-palindrome\
    \ string (string-length string))) (string-length string))))", "  (define (reverse_string\
    \ string)\n    (define (helper string i result)\n      (if (= i (string-length\
    \ string))\n          result\n          (helper string (+ i 1) (string-append\
    \ (string result (+ i 1)) (string result i)))))\n    (helper string 0 \"\"))\n\
    \  (define (longest_palindromic_postfix string)\n    (define (check_palindrome\
    \ string i j)\n      (if (&lt; i j)\n          (if (string=? (string string i)\
    \ (string string j))\n              (check_palindrome string (+ i 1) (- j 1))\n\
    \              #f)\n          #t))\n    (define (helper string i)\n      (cond\
    \ ((&gt; i (string-length string))\n             \"\")\n            ((check_palindrome\
    \ string 0 i)\n             (string string 0 i))\n            (else\n        \
    \     (helper string (+ i 1)))))\n    (helper string 0))\n  (string-append string\
    \ (reverse_string (substring string 0 (- (string-length string) (string-length\
    \ (longest_palindromic_postfix string)))))))\n</code>\nThe function works but,\
    \ as I have said, I am sure it can be much better. Any suggestions, hints, ideas\
    \ are welcome.\n\n\nA:\n\nThere are a couple of improvements you can make.\nThe\
    \ first one is that <code>reverse_string</code> is much better implemented as\
    \ a <code>foldr</code> over the characters in the string:\n<code>(define (reverse-string\
    \ string)\n  (foldr (\u03BB (char rev) (string-append rev (string char)))\n  \
    \       \"\"\n         string))\n</code>\nThe second one is that your <code>check_palindrome</code>\
    \ function can be simplified by first checking if <code>i &gt;= j</code> instead\
    \ of <code>i &lt; j</code>, and if so return <code>#t</code> immediately:\n<code>(define\
    \ (check-palindrome string i j)\n  (if (&gt;= i j)\n      #t\n      (if (string=?\
    \ (string string i) (string string j))\n", "  (let loop ([str string]\n      \
    \       [shift 0])\n    (if (and (&lt; shift (string-length str))\n          \
    \   (string=? (substring str shift (add1 shift))\n                       (substring\
    \ str (- (string-length str) shift) (- (string-length str) (add1 shift)))))\n\
    \        (loop str (add1 shift))\n        (if (zero? shift)\n            (error\
    \ \"invalid string\")\n            (let* ([prefix (substring str 0 shift)]\n \
    \                  [reverse (list-&gt;string (reverse (string-&gt;list prefix)))]\n\
    \                   [suffix (substring str shift)])\n              (string-append\
    \ reverse suffix))))))\n", "  (let loop ((string string)\n             (i (string-length\
    \ string)))\n    (if (or (zero? i)\n            (string=? (substring string 0\
    \ i)\n                      (string-reverse (substring string (- (string-length\
    \ string) i)))))\n        (string-append string (string-reverse (substring string\
    \ 0 (- (string-length string) i))))\n        (loop string (- i 1)))))\n</code>\n\
    Tests:\n<code>#lang racket\n", "  (match (string-length string)\n    [`0\n   \
    \  string]\n    [`1\n     string]\n    [`2\n     (if (string=? (substring string\
    \ 0 1) (substring string 1 2))\n         string\n         (string (substring string\
    \ 1 2) (substring string 0 1)))]\n    [n\n     (let ([str (string (substring string\
    \ 0 (sub1 n)) (substring string (sub1 n) n))])\n       (string\n        (substring\
    \ string 0 (sub1 n))\n        (substring (make_palindrome str) (sub1 n) n)\n \
    \       (substring string 0 (sub1 n))))]))\n", "  (let ([len (string-length string)])\n\
    \    (cond\n      [(even? len)\n       (let* ([mid (/ len 2)]\n              [prefix\
    \ (substring string 0 mid)]\n              [suffix (substring string mid)])\n\
    \         (if (equal? prefix (string-reverse suffix))\n             string\n \
    \            (string-append prefix (string-reverse prefix) suffix)))]\n      [(odd?\
    \ len)\n       (let* ([mid (quotient len 2)]\n              [prefix (substring\
    \ string 0 mid)]\n              [suffix (substring string (1+ mid))])\n      \
    \   (if (equal? prefix (string-reverse suffix))\n             string\n       \
    \      (string-append prefix (string-reverse prefix) suffix)))])))\n", "  (define\
    \ (substr s i j)\n    (substring s i (add1 j)))\n  (define (rev s)\n    (string-append\
    \ (substr s (sub1 (string-length s)) 0) \"\"))\n  (define (is_palindrome s)\n\
    \    (string=? s (rev s)))\n  (define (find_suffix s)\n    (let* ([slen (string-length\
    \ s)]\n           [end (sub1 slen)])\n      (let loop ([beg 0])\n        (cond\n\
    \          [(< beg end) (if (is_palindrome (substr s beg slen)) beg (loop (add1\
    \ beg)))]\n          [else end]))))\n  (let* ([slen (string-length string)]\n\
    \         [end (sub1 slen)]\n         [suffix-end (find_suffix string)])\n   \
    \ (let ([suffix (substr string suffix-end end)])\n      (string-append string\
    \ (rev (substr string 0 suffix-end))))))", "  (define (find-palindrome-in-string\
    \ string i j)\n    (if (= i j) ; if index i == j return true\n        (list string\
    \ i j)\n        (let ([ic (string-ref string i)]\n              [jc (string-ref\
    \ string j)])\n          (if (= ic jc)\n              (find-palindrome-in-string\
    \ string (+ i 1) (- j 1))\n              (list string i j)))))\n\n  (define (find-longest-palindrome-suffix\
    \ string start end)\n    (if (&lt; start end)\n        (let ([p (find-palindrome-in-string\
    \ string start end)])\n          (if (= (caddr p) start)\n              (list\
    \ p start)\n              (find-longest-palindrome-suffix string (- start 1) end)))\n\
    \        (list string start end)))\n\n  (define (reverse-prefix string start end)\n\
    \    (if (&lt; start end)\n        (string-append\n         (string (string-ref\
    \ string start))\n         (reverse-prefix string (+ start 1) end))\n        \"\
    \"))\n\n  (define (make-palindrome-string string start end)\n    (if (= start\
    \ end)\n        string\n        (string-append string (reverse-prefix string 0\
    \ start))))\n\n  (define (append-suffix string start end)\n    (string-append\
    \ string (substring string start end)))\n\n  (define (shortest-palindrome string)\n\
    \    (let ([p (find-longest-palindrome-suffix string (- (string-length string)\
    \ 1)\n                                              (string-length string))])\n\
    \      (append-suffix (make-palindrome-string (car p) (cadr p) (caddr p))\n  \
    \                   (cadr p) (caddr p))))\n\n  (shortest-palindrome string))\n",
  "  (define (find-longest-palindrome-suffix string)\n    (let loop ((end (string-length\
    \ string))\n               (suffix-length 0))\n      (let ((prefix-length (- end\
    \ suffix-length)))\n        (cond ((&lt;= suffix-length 0) '())\n            \
    \  ((equal? (substring string 0 prefix-length)\n                       (substring\
    \ string suffix-length end))\n               (list prefix-length suffix-length))\n\
    \              (else (loop end (- suffix-length 1)))))))\n  (let* ((result (find-longest-palindrome-suffix\
    \ string))\n         (prefix-length (car result))\n         (suffix-length (cadr\
    \ result)))\n    (string-append string (substring string 0 (- prefix-length)))))\n\
    </code>\nFor example:\n<code>&gt; (make_palindrome \"abcdefg\")\n\"abcdefggfedcba\"\
    \n&gt; (make_palindrome \"abcdefggfedcba\")\n\"abcdefggfedcba\"\n&gt; (make_palindrome\
    \ \"abc\")\n\"abccba\"\n&gt; (make_palindrome \"a\")\n\"a\"\n&gt; (make_palindrome\
    \ \"\")\n\"\"\n</code>\n", "  (define (longest-palindrome-postfix string)\n  \
    \  (let loop ((s string)\n               (i 0))\n      (if (and (not (null? s))\
    \ (string= (car s) (last s)))\n          (loop (cdr (butlast s)) (+ i 1))\n  \
    \        i)))\n  (let ((length (string-length string)))\n    (string-append string\
    \ (substring (reverse string) 0 (- length (longest-palindrome-postfix string))))))\n\
    </code>\n", "  (define reversed (string-reverse string))\n  (define (concat-and-reverse\
    \ string prefix)\n    (string-append prefix (string-reverse string)))\n  (let\
    \ ([len (string-length string)])\n    (for ([i (in-range 1 len)])\n      (let\
    \ ([prefix (substring string 0 i)])\n        (if (string=? prefix (substring reversed\
    \ len (- len i)))\n            (return (concat-and-reverse string prefix)))))))\n",
  "  (let* ([l (string-length string)]\n         [reversed-string (reverse-string\
    \ string)]\n         [sorted-suffixes (apply sort (map (lambda (i) (substring\
    \ string i l)) (iota l)))]\n         [palindromic-suffixes (filter (lambda (s)\
    \ (equal? s (reverse-string s))) sorted-suffixes)])\n    (define (last-palindromic-suffix\
    \ s)\n      (for/last ([p palindromic-suffixes])\n        (if (string-contains\
    \ s p)\n            p)))\n    (let* ([lp (last-palindromic-suffix string)]\n \
    \          [n (string-length lp)])\n      (string-append string (substring reversed-string\
    \ 0 (- l n))))))\n", "  (define (make_palindrome-helper string longest-palindrome-suffix\
    \ so-far)\n    (if (zero? (string-length string))\n        (string-append (string-reverse\
    \ so-far) longest-palindrome-suffix)\n        (if (equal? (substring string 0\
    \ 1) (substring string (- (string-length string) 1) (string-length string)))\n\
    \            (make_palindrome-helper (substring string 1 (- (string-length string)\
    \ 1))\n                                    (string-append (substring string 0\
    \ 1) longest-palindrome-suffix)\n                                    (string-append\
    \ (substring string 0 1) so-far))\n            (make_palindrome-helper (substring\
    \ string 1)\n                                    longest-palindrome-suffix\n \
    \                                   (string-append (substring string 0 1) so-far)))))\n\
    \  (make_palindrome-helper string \"\" \"\"))\n", "  (let* ([strlen (string-length\
    \ string)]\n         [helper (make-vector (add1 strlen) #f)])\n    (define (longest-palindrome-suffix\
    \ offset)\n      (if (and (< offset strlen) (not (vector-ref helper offset)))\n\
    \          (vector-set! helper offset (let ([result (longest-palindrome-suffix\
    \ (add1 offset))])\n                                       (if (and result (=\
    \ (string-ref string offset) (string-ref string (- strlen offset))))\n       \
    \                                    (cons (cons (add1 offset) strlen) result)\n\
    \                                           (cons #f result))))\n          (vector-ref\
    \ helper offset)))\n    (let ([longest-palindrome-suffix-from-end (longest-palindrome-suffix\
    \ 0)])\n      (if (eq? longest-palindrome-suffix-from-end #f)\n          string\n\
    \          (let ([end-of-palindrome (caar longest-palindrome-suffix-from-end)])\n\
    \            (append (substring string end-of-palindrome)\n                  \
    \  (reverse (substring string 0 end-of-palindrome))))))))\n", "  (define (string-reverse\
    \ sr)\n    (if (empty? sr)\n        \"\"\n        (string-append (string-reverse\
    \ (substring sr 1 (string-length sr))) (string (string-ref sr 0)))))\n  (define\
    \ (lps s)\n    (local ((define N (string-length s)))\n      (for ([i (in-range\
    \ 1 N)])\n        (let ([l (lps (substring s 0 i))])\n          (if (and (> i\
    \ l)\n                   (string=? (substring s l i) (string-reverse (substring\
    \ s i N))))\n              i)))))\n  (let ([l (lps string)])\n    (string-append\
    \ string (string-reverse (substring string 0 l)))))\n", "  (define rev_str (reverse\
    \ string))\n  (for/first ([i (in-range (length string))]\n              #:when\
    \ (= (substring string 0 i) (substring rev_str (- (length string) i))))\n    (string-append\
    \ string (substring rev_str i))))\n", "  (define (longest-palindrome s)\n    (let\
    \ loop ((sub-string s) (sub-string-length (string-length s)))\n      (if (&lt;=\
    \ sub-string-length 1)\n          #f\n          (if (string=? sub-string (substring\
    \ s (- sub-string-length 1)))\n              (substring s 0 sub-string-length)\n\
    \              (loop (substring s 1) (- sub-string-length 1))))))\n  (let ((longest-suffix\
    \ (longest-palindrome string)))\n    (if longest-suffix\n        (string-append\
    \ string (reverse (substring string 0 (- (string-length string) (string-length\
    \ longest-suffix)))))\n        string)))\n</code>\nIn Racket REPL:\n<code>&gt;\
    \ (make_palindrome \"racecar\")\n\"racecar\"\n&gt; (make_palindrome \"race\")\n\
    \"racecar\"\n&gt; (make_palindrome \"abc\")\n\"abcba\"\n&gt; (make_palindrome\
    \ \"abcd\")\n\"abcdcba\"\n&gt; (make_palindrome \"abcdc\")\n\"abcdcba\"\n&gt;\
    \ (make_palindrome \"abcdca\")\n\"abcdcba\"\n&gt; (make_palindrome \"\")\n\"\"\
    \n</code>\n", "  (define (longest-common-prefix s1 s2)\n    (let recur ((ix 0))\n\
    \      (cond ((or (string=? (substring s1 ix) \"\")\n                 (string=?\
    \ (substring s2 ix) \"\"))\n             (substring s1 0 ix))\n            ((char=?\
    \ (string-ref s1 ix) (string-ref s2 ix))\n             (recur (+ ix 1)))\n   \
    \         (else (substring s1 0 ix)))))\n  (define (largest-palindrome-suffix\
    \ s)\n    (let recur ((ix (string-length s)))\n      (cond ((= ix 0) \"\")\n \
    \           ((= (string-length (longest-common-prefix s (string-reverse s))) ix)\n\
    \             s)\n            (else (recur (- ix 1))))))\n  (string-append string\
    \ (string-reverse (substring string 0 (- (string-length string) (string-length\
    \ (largest-palindrome-suffix string)))))))\n</code>\n", "  (define (longest-postfix\
    \ string)\n    (define (helper string i len)\n      (cond\n        [(= i len)\
    \ (substring string 0 i)]\n        [(= (substring string i i) (substring string\
    \ (- i 1) (- i 1))) (helper string (+ i 1) len)]\n        [else (helper string\
    \ (+ i 1) len)]))\n    (helper string 0 (string-length string)))\n  (define (reverse-prefix\
    \ string prefix)\n    (substring (string-append string (string-reverse (substring\
    \ string 0 (- (string-length string) (string-length prefix))))) (string-length\
    \ prefix)))\n  (string-append string (reverse-prefix string (longest-postfix string))))\n\
    </code>\nTest:\n<code>#lang racket\n", "  (let* ([lst (string->list string)]\n\
    \         [i (search-for-longest-palindrome-suffix lst (length lst))]\n      \
    \   [s (substring lst 0 i)])\n    (append lst (reverse s))))\n", "  (let ([string-len\
    \ (string-length string)])\n    (let loop ([i 0])\n      (let ([i2 (- string-len\
    \ i)])\n        (if (= i i2)\n            (concat string (list->string (reverse\
    \ (string->list string))))\n            (cond [(string=? (substring string 0 i)\
    \ (substring string i2 string-len))\n                   (concat string (list->string\
    \ (reverse (string->list (substring string 0 i)))))]\n                  [else\
    \ (loop (+ i 1))]))))))\n", "  (string-append string (reverse (string-before string\
    \ (find-palindrome-suffix string)))))\n", "  (define (find-palindrome-suffix string\
    \ suffix)\n    (if (string= string suffix)\n        suffix\n        (find-palindrome-suffix\n\
    \         (substring string 0 (- (string-length string) 1))\n         (if (string=\
    \ (substring string 0 (string-length suffix)) suffix)\n             suffix\n \
    \            (substring string 0 (- (string-length suffix) 1))))))\n  (define\
    \ (reverse string)\n    (if (string= string \"\")\n        \"\"\n        (string-append\
    \ (reverse (substring string 1)) (substring string 0 1))))\n  (string-append string\
    \ (reverse (substring string 0 (- (string-length string) (string-length (find-palindrome-suffix\
    \ string string)))))))\n", "  (define (find-max-palindrome-end n)\n    (define\
    \ (find-max-palindrome-end-inner m)\n      (cond\n        ((= m 0) n)\n      \
    \  ((string-ci=? (substring string (- n m) n) (substring string 0 m)) (find-max-palindrome-end-inner\
    \ (+ m 1)))\n        (else (find-max-palindrome-end-inner (- m 1)))))\n    (find-max-palindrome-end-inner\
    \ n))\n  (define (reverse-prefix n)\n    (string-append (substring string 0 (-\
    \ n)) (substring string n)))\n  (string-append string (reverse-prefix (find-max-palindrome-end\
    \ (string-length string)))))\n", "  (define (make_palindrome_helper str suffix)\n\
    \    (if (= 0 (string-length str)) suffix\n      (let ([next-suffix (string-append\
    \ (substring str 0 1) suffix)])\n        (if (string=? next-suffix (string-reverse\
    \ next-suffix))\n            (make_palindrome_helper (substring str 1) next-suffix)\n\
    \            suffix))))\n  (string-append string (string-reverse (make_palindrome_helper\
    \ string \"\"))))\n", "  (define (longest-prefix-palindrome str)\n    (define\
    \ (odd-length-palindrome str)\n      (define (rec-odd str i)\n        (if (or\
    \ (= i 0) (= i (string-length str)))\n            str\n            (if (char=?\
    \ (string-ref str i) (string-ref str (- i 1)))\n                (rec-odd str (-\
    \ i 1))\n                (substring str i (string-length str)))))\n      (rec-odd\
    \ str (quotient (+ (string-length str) 1) 2)))\n    (define (even-length-palindrome\
    \ str)\n      (define (rec-even str i)\n        (if (or (= i 0) (= i (string-length\
    \ str)))\n            str\n            (if (char=? (string-ref str i) (string-ref\
    \ str (- i 1)))\n                (rec-even str (- i 1))\n                (substring\
    \ str i (string-length str)))))\n      (rec-even str (quotient (string-length\
    \ str) 2)))\n    (if (zero? (modulo (string-length str) 2))\n        (even-length-palindrome\
    \ str)\n        (odd-length-palindrome str)))\n  (string-append string (reverse\
    \ (substring string 0 (string-length (longest-prefix-palindrome string))))))\n",
  "  (define (iterate string left right)\n    (if (&gt; left right)\n        string\n\
    \        (if (char=? (string-ref string left) (string-ref string right))\n   \
    \         (iterate string (+ left 1) (- right 1))\n            (iterate (string-append\
    \ string (string-reverse (substring string 0 left))) 0 left))))\n  (iterate string\
    \ 0 (- (string-length string) 1)))\n", "  (define char-at (string-ref string))\n\
    \  (define len (string-length string))\n  (define (substr start end)\n    (substring\
    \ string start end))\n  (define (find-palindrome-end start)\n    (define (inner\
    \ start end)\n      (if (not (and (<= start end) (< end len)))\n          end\n\
    \          (if (char=? (char-at start) (char-at (- end 1)))\n              (inner\
    \ (+ start 1) (- end 1))\n              end)))\n    (inner start (+ start 1)))\n\
    \  (define palindrome-end (find-palindrome-end 0))\n  (string-append string (substr\
    \ 0 (- len palindrome-end)) (reverse (substr palindrome-end len))))", "  (define\
    \ len (string-length string))\n  (define palindrome (make-string len))\n  (define\
    \ (find-palindrome-suffix start end)\n    (if (&gt;= end start)\n        (if (equal?\
    \ (substring string start end) (substring string (+ start (- end start)) end))\n\
    \            end\n            (find-palindrome-suffix start (- end 1)))\n    \
    \    start))\n  (let ((suffix-end (find-palindrome-suffix 0 len)))\n    (string-append\
    \ string (substring string (substring-move-left! string 0 (- len (- suffix-end\
    \ (substring-move-left! palindrome (- len (- suffix-end len)) len)))) len))))\n\
    </code>\nThere is probably a more elegant way of doing the string reversal in\
    \ the last line, but this seemed rather clear and concise.\nI'm looking for feedback\
    \ on naming and clarity, as well as anything related to the functional style.\n\
    \n\nA:\n\nYou can always just write the <code>reverse</code> function yourself\
    \ (or use a library one).  It's pretty simple, and I think it makes the program\
    \ a bit easier to read.\n<code>(define (reverse str)\n  (if (string-empty? str)\n\
    \      str\n      (string-append (reverse (substring str 1))\n               \
    \      (substring str 0 1))))\n</code>\nI would call the <code>suffix-end</code>\
    \ parameter <code>end</code>, <code>palindrome</code> is not used, and <code>palindrome</code>\
    \ is the wrong name for <code>suffix-end</code> (it's not the end of the palindrome,\
    \ it's the end of the suffix that is a palindrome).\n", "  (define (get-longest-palindrome\
    \ string suffix-length)\n    (if (= suffix-length 0)\n        \"\"\n        (let*\
    \ ((substr (substring string (sub1 suffix-length)))\n               (substr-reverse\
    \ (string-reverse substr)))\n          (if (string=? substr substr-reverse)\n\
    \              substr\n              (get-longest-palindrome string (sub1 suffix-length))))))\n\
    \  (define (append-prefix-reverse string prefix-length)\n    (string-append string\
    \ (string-reverse (substring string 0 prefix-length))))\n  (define (find-prefix-length\
    \ string palindrome-length)\n    (if (= palindrome-length (string-length string))\n\
    \        0\n        (add1 (find-prefix-length string (add1 palindrome-length)))))\n\
    \  (append-prefix-reverse string (find-prefix-length string (string-length (get-longest-palindrome\
    \ string (string-length string))))))\n", "  (define (iter postfix prefix)\n  \
    \  (cond\n      [(or (string=? prefix \"\")\n           (string=? postfix \"\"\
    )\n           (string=? prefix postfix))\n       (string-append string (string-reverse\
    \ prefix))]\n      [else\n       (iter (string-drop-right postfix 1)\n       \
    \      (string-append (string-drop-right prefix 1) (string-take prefix 1)))]))\n\
    \  (iter string \"\"))\n", "  (define (make_palindrome-helper string postfix)\n\
    \    (if (eq? (string-length postfix) 0)\n        (string-append string (string-reverse\
    \ (string-append postfix string)))\n        (make_palindrome-helper string (string-drop-right\
    \ postfix 1))))\n  (define (longest-palindromic-suffix string)\n    (let loop\
    \ ((postfix string))\n      (if (palindrome? (string-append postfix string))\n\
    \          postfix\n          (loop (string-drop-right postfix 1)))))\n  (let\
    \ ((postfix (longest-palindromic-suffix string)))\n    (make_palindrome-helper\
    \ string postfix)))\n", "  (let ([suffix (max-prefix-palindrome string)])\n  \
    \  (if (eq? suffix \"\")\n        string\n        (string-append string (reverse\
    \ (substring string 0 (string-length suffix)))))))\n", "  (let* ((string-len (string-length\
    \ string))\n         (str-reversed (string-reverse string))\n         (matched\
    \ (list))\n         (i 0))\n    (while (< i string-len)\n      (let* ((range-len\
    \ (+ i 1))\n             (range (substring string i range-len))\n            \
    \ (reversed-range (substring str-reversed (- string-len range-len) string-len)))\n\
    \        (when (equal? range reversed-range)\n          (append matched range))\n\
    \        (set! i (+ i 1))))\n    (string-append string (string-reverse (map string\
    \ matched)))))", "  (define (longest-prefix-suffix string start end)\n    (define\
    \ (suffix-for-char i char)\n      (cond\n        [(= i end) i]\n        [(string-ref\
    \ string i) char]\n        [else (suffix-for-char (+ i 1) char)]))\n    (let loop\
    \ ([start start] [end end])\n      (if (= start end)\n          (substring string\
    \ 0 start)\n          (let ([i (suffix-for-char (- end 1) (string-ref string end))])\n\
    \            (if (&lt;= i end)\n                (loop (+ i 1) (- end 1))\n   \
    \             (substring string 0 start))))))\n  (let ([reversed (reverse string)])\n\
    \    (string-append string (substring reversed (string-length (longest-prefix-suffix\
    \ reversed 0 (string-length reversed)))))))\n</code>\nTests:\n<code>#lang racket\n",
  "  (define (length-of-palindrome string)\n    (define (even? n) (= (remainder n\
    \ 2) 0))\n    (let ((length (string-length string)))\n      (define (is-palindrome-of-length?\
    \ length)\n        (and\n         (is-palindrome-string? string length)\n    \
    \     (is-palindrome-string? (substring string 0 length) length)))\n      (let\
    \ loop ((l (+ 1 (quotient length 2)))\n                 (palindrome-length 1))\n\
    \        (cond\n          [(is-palindrome-of-length? l) (loop (+ 1 l) l)]\n  \
    \        [(zero? l) palindrome-length]\n          [else (loop (- l 1) palindrome-length)]))))\n\
    \  (let ((palindrome-length (length-of-palindrome string)))\n    (if (equal? palindrome-length\
    \ (string-length string))\n        string\n        (make-palindrome (string-append\
    \ (substring string palindrome-length)\n                                     \
    \   (substring string 0 palindrome-length)\n                                 \
    \       (reverse (substring string 0 palindrome-length)))))))\n", "  (define (reverse\
    \ str)\n    (let loop ((i (sub1 (string-length str)))\n               (rev \"\"\
    ))\n      (if (negative? i)\n          rev\n          (loop (sub1 i) (string-append\
    \ (substring str i (add1 i)) rev)))))\n  (define (prefix string)\n    (if (= (string-length\
    \ string) 1)\n        string\n        (substring string 0 (sub1 (string-length\
    \ string)))))\n  (define (suffix string)\n    (if (= (string-length string) 1)\n\
    \        string\n        (substring string 1 (string-length string))))\n  (define\
    \ (longest-common-prefix string1 string2)\n    (let loop ((s1 string1)\n     \
    \          (s2 string2)\n               (i 0))\n      (cond ((or (string=? s1\
    \ \"\") (string=? s2 \"\")) (substring string1 0 i))\n            ((string=? (substring\
    \ s1 0 1) (substring s2 0 1)) (loop (suffix s1) (suffix s2) (add1 i)))\n     \
    \       (else (substring string1 0 i)))))\n  (define (longest-palindromic-postfix\
    \ string)\n    (if (or (string=? string \"\") (string=? (substring string 0 1)\
    \ (substring string (sub1 (string-length string)) (string-length string))))\n\
    \        string\n        (longest-palindromic-postfix (substring string 0 (sub1\
    \ (string-length string))))))\n  (string-append string (reverse (substring string\
    \ 0 (sub1 (string-length (longest-palindromic-postfix string)))))))\n</code>\n\
    As I've said in comments, I'm looking for code reviewing, suggestions, idiomatic\
    \ ways to do this, etc. I'm mostly interested in an idiomatic Scheme, but I'm\
    \ willing to learn Racket-specific ways of doing this.\n\n\nA:\n\n\"Longest\"\
    \ is a bit ambiguous, since you can tie.  Why not use <code>string-length</code>\
    \ as a tiebreaker?\n<code>(define (longest-palindromic-postfix string)\n  (",
  "  (define (longest-suffix-palindrome string)\n    (cond\n      [(string=? string\
    \ \"\") \"\"]\n      [(string=? (substring string (sub1 (string-length string)))\
    \ \"\")\n       (substring string 0 (sub1 (string-length string)))]\n      [else\n\
    \       (longest-suffix-palindrome (substring string 0 (sub1 (string-length string))))]))\n\
    \  (string-append string (reverse (substring string 0 (sub1 (string-length (longest-suffix-palindrome\
    \ string)))))))\n", "  (define (is_palindrome? str)\n    (equal? (list->string\
    \ (reverse (string->list str))) str))\n  (define (longest_palindrome? str)\n \
    \   (cond\n      [(is_palindrome? str) str]\n      [else (longest_palindrome?\
    \ (substring str 0 (- (string-length str) 1)))])\n    )\n  (append string (reverse\
    \ (substring string 0 (- (string-length string) (string-length (longest_palindrome?\
    \ string)))))))", "  (define (table_from_string string)\n    (match string\n \
    \     [(list) (list)]\n      [(cons c (list)) (list 0)]\n      [(cons c rest)\n\
    \       (append (list (add1 (car (table_from_string rest))))\n               (map\
    \ (lambda (i) (if (char=? c (string-ref string i)) (add1 i) 0))\n            \
    \        (iota (sub1 (length string)))))]))\n  (define (search table)\n    (let\
    \ ([k (sub1 (length table))])\n      (if (= k 0)\n          (substring string\
    \ 0 1)\n          (let ([c (substring string k 1)])\n            (append c (make_palindrome\
    \ (substring string 0 k)))))))\n  (search (table_from_string string)))\n", " \
    \ (define suffix-start\n    (for/fold ([i 0]) ([c (in-string string)])\n     \
    \ (if (equal? (substring string (- i 1) i) (string c))\n          (- i 1)\n  \
    \        i)))\n  (string-append string (string-reverse (substring string 0 suffix-start))))\n",
  "  (let* ([length (string-length string)]\n         [middle (quotient length 2)]\n\
    \         [reverse-pre-mid (substring string 0 (sub1 middle))]\n         [reverse-post-mid\
    \ (substring string middle length)])\n    (string-append string (substring reverse-pre-mid\
    \ (find-match reverse-post-mid reverse-pre-mid)))))\n", "  (if (string=? string\
    \ (string-reverse string))\n      string\n      (let ([palindrome-len (find-longest-palindrome-suffix\
    \ string)])\n        (string-append string (substring (string-reverse string)\
    \ 0 (- (string-length string) palindrome-len))))))\n", "  (define prefix-length\
    \ (find-longest-palindromic-postfix string))\n  (define prefix (substring string\
    \ 0 prefix-length))\n  (append string (reverse prefix)))\n", "  (define (make_palindrome_aux\
    \ string k longest-palindrome-suffix start-of-suffix)\n    (if (= k (string-length\
    \ string))\n        (string-append (substring string 0 start-of-suffix) longest-palindrome-suffix\
    \ (substring string start-of-suffix))\n        (if (string=? (substring string\
    \ k (- (string-length string) k)) (substring string (- (string-length string)\
    \ k) (string-length string)))\n            (make_palindrome_aux string (+ k 1)\
    \ (substring string k (- (string-length string) k)) k)\n            (make_palindrome_aux\
    \ string (+ k 1) longest-palindrome-suffix start-of-suffix))))\n  (make_palindrome_aux\
    \ string 0 (substring string 0 1) 0))\n", "  (define (longest-postfix-palindrome\
    \ string)\n    (if (string= string (reverse string))\n        string\n       \
    \ (longest-postfix-palindrome (substring string 0 (- (string-length string) 1)))))\n\
    \  (append string (reverse (substring string 0 (- (string-length string) (string-length\
    \ (longest-postfix-palindrome string)))))))\n", "  (let ((sufpre (match-longest-suffix-as-palindrome\
    \ string)))\n    (string-append string (string-reverse (substring string 0 (car\
    \ sufpre))))))\n", "  (define (find-longest-palindrome-postfix str idx)\n    (if\
    \ (= idx (- (string-length str) 1))\n        #f\n        (if (string=? (substring\
    \ str idx) (substring str 0 (- (string-length str) idx)))\n            idx\n \
    \           (find-longest-palindrome-postfix str (+ idx 1)))))\n  (define (substring\
    \ str start end)\n    (string-append (substring str 0 start) (substring str end)))\n\
    \  (define (subtract-substrings str start end)\n    (substring str 0 start) (substring\
    \ str end))\n  (define (reverse str)\n    (string-append (reverse (substring str\
    \ (string-length str) 0))))\n  (define (palindrome-postfix str)\n    (let ((idx\
    \ (find-longest-palindrome-postfix str 0)))\n      (if idx\n          (substring\
    \ str 0 idx)\n          #f)))\n  (string-append string (reverse (palindrome-postfix\
    \ string))))\n</code>\nThe problem is that when I try to test my solution it crashes.\
    \ I believe that this is happening because of the way I'm using strings in my\
    \ <code>substring</code> function, but I can't figure out how to fix it. Does\
    \ anyone know what am I doing wrong?\n\n\nA:\n\nIt seems like your <code>substring</code>\
    \ function does the right thing when <code>start</code> is less than <code>end</code>,\
    \ but it returns an empty string when <code>start</code> is greater than <code>end</code>.\
    \  I think that's why your <code>reverse</code> function is returning an empty\
    \ string when you try to reverse the second argument of <code>substring</code>.\n\
    Changing the body of your <code>substring</code> function to\n<code>(substring\
    \ str start (- (string-length str) end))\n</code>\nresults in the following palindromes:\n\
    <code>&gt; (make-palindrome \"abc\")\n\"abcba\"\n&gt; (make-palindrome \"a\")\n\
    \"a\"\n&gt", "  (define (palindrome? string)\n    (let loop ([string string] [rev-string\
    \ (reverse string)])\n      (cond [(empty? string) #t]\n            [(char=? (first\
    \ string) (first rev-string)) (loop (rest string) (rest rev-string))]\n      \
    \      [else #f])))\n  (define (find-longest-palindrome string)\n    (let loop\
    \ ([string string] [longest string])\n      (cond [(empty? string) longest]\n\
    \            [(palindrome? string) (loop (rest string) string)]\n            [else\
    \ (loop (rest string) longest)])))\n  (define (append-to-front prefix suffix)\n\
    \    (append (reverse prefix) suffix))\n  (let* ([longest-suffix (find-longest-palindrome\
    \ string)]\n         [longest-prefix (find-longest-palindrome (reverse string))])\n\
    \    (append-to-front longest-prefix longest-suffix)))\n", "  (define (find-palindrome-suffix\
    \ start-index)\n    (define (is-palindrome-suffix? start-index end-index)\n  \
    \    (cond ((&gt;= start-index end-index) #t)\n            ((not (string=? (substring\
    \ string start-index (add1 start-index))\n                            (substring\
    \ string (- end-index 1) end-index)))\n             #f)\n            (else (is-palindrome-suffix?\
    \ (add1 start-index) (sub1 end-index)))))\n    (let loop ((i (add1 (string-length\
    \ string))))\n      (cond ((&lt;= i start-index) #f)\n            ((is-palindrome-suffix?\
    \ start-index i)\n             (substring string start-index i))\n           \
    \ (else (loop (sub1 i))))))\n  (let ((palindrome-suffix (find-palindrome-suffix\
    \ 0)))\n    (if palindrome-suffix\n        (string-append (substring string 0\
    \ (sub1 (string-length palindrome-suffix)))\n                       (substring\
    \ string (sub1 (string-length palindrome-suffix))\n                          \
    \        (string-length string))\n                       (substring string 0 (sub1\
    \ (string-length palindrome-suffix))))\n        string)))\n</code>\n", "  (let\
    \ ((len (string-length string)))\n    (define (rec i k)\n      (cond\n       \
    \ ((= i len) (substring string 0 k))\n        ((= k 0)\n         (string-append\
    \ string (reverse (substring string 0 len))))\n        ((char=? (string-ref string\
    \ i) (string-ref string (- len k)))\n         (rec (+ i 1) (+ k 1)))\n       \
    \ (else (rec (+ i 1) (- k 1)))))\n    (rec 0 0)))\n", "  (if (null? string)\n\
    \      \"\"\n      (let ([half-len (ceiling (/ (string-length string) 2))])\n\
    \        (for/fold ([longest-palindrome-suffix (substring string half-len (string-length\
    \ string))])\n                  ([len half-len])\n          (let ([suffix (substring\
    \ string len (string-length string))])\n            (if (string=? suffix (reverse\
    \ suffix))\n                (string-append (substring string 0 len)\n        \
    \                       (reverse suffix))\n                longest-palindrome-suffix))))))\n",
  "  (define (get-prefix-for-sufix suffix)\n    (let ([prefix (substring string 0\
    \ (- (string-length string) (string-length suffix)))])\n      (string-append prefix\
    \ (reverse prefix))))\n  (define (get-suffix-for-prefix prefix)\n    (string-append\
    \ prefix (reverse prefix)))\n  (define (find-longest-suffix-palindrome string)\n\
    \    (let ([n (string-length string)])\n      (define (iter k)\n        (if (and\
    \ (&gt;= k n) (&lt;= k (quotient n 2)))\n            (find-longest-suffix-palindrome\
    \ (substring string 0 (- n 1)))\n            (if (&gt;= k n)\n               \
    \ #f\n                (let* ([prefix (substring string 0 (- n k))]\n         \
    \              [suffix (substring string (- n k))])\n                  (if (equal?\
    \ prefix (reverse suffix))\n                      suffix\n                   \
    \   (iter (+ k 1)))))))\n      (iter 0)))\n  (define (find-longest-prefix-palindrome\
    \ string)\n    (let ([n (string-length string)])\n      (define (iter k)\n   \
    \     (if (and (&gt;= k n) (&lt;= k (quotient n 2)))\n            (find-longest-prefix-palindrome\
    \ (substring string 1))\n            (if (&gt;= k n)\n                #f\n   \
    \             (let* ([prefix (substring string 0 k)]\n                       [suffix\
    \ (substring string k)])\n                  (if (equal? prefix (reverse suffix))\n\
    \                      prefix\n                      (iter (+ k 1)))))))\n   \
    \   (iter 0)))\n  (let ([longest-suffix-palindrome (find-longest-suffix-palindrome\
    \ string)])\n    (if longest-suffix-palindrome\n        (get-prefix-for-sufix\
    \ longest-suffix-palindrome)\n        (let ([longest-prefix-palindrome (find-longest-prefix-palindrome\
    \ string)])\n          (if longest-prefix-palindrome\n              (get-suffix-for-prefix\
    \ longest-prefix-palindrome)\n", "  (let ([len (string-length string)])\n    (define\
    \ (suffix-palindrome? s)\n      (or (string=? (substring s 0 1) (substring s -1))\
    \ (and (> (string-length s) 1) (suffix-palindrome? (substring s 1)))))\n    (define\
    \ (is-palindrome? s)\n      (string=? s (string-reverse s)))\n    (define (substring-palindrome\
    \ s)\n      (define (sub-helper s)\n        (if (suffix-palindrome? s) s (sub-helper\
    \ (substring s 1))))\n      (sub-helper s))\n    (let ([sub-string (substring-palindrome\
    \ string)])\n      (let ([prefix (substring string 0 (- len (string-length sub-string)))])\n\
    \        (string-append string (string-reverse prefix))))))\n", "  (let loop ([string\
    \ string]\n             [prefix (string-&gt;list string)])\n    (cond [(string=?\
    \ string \"\") \"\"]\n          [(string=? string (string-append string (reverse\
    \ prefix))) string]\n          [else (loop (substring string 0 (sub1 (string-length\
    \ string)))\n                      (list-rest prefix))])))\n</code>\n", "  (define\
    \ (find-longest-palindrome-suffix str)\n    (define (is-palindrome? str)\n   \
    \   (equal? (reverse str) str))\n    (define (find-palindrome-suffix-inner str)\n\
    \      (if (is-palindrome? str)\n          str\n          (find-palindrome-suffix-inner\
    \ (substring str 1))))\n    (find-palindrome-suffix-inner str))\n  (string-append\
    \ string (reverse (substring string 0 (- (string-length string) (string-length\
    \ (find-longest-palindrome-suffix string)))))))\n", "  (string-append string (reverse\
    \ (string-drop string (string-suffix-length string)))))\n", "  (define (copy_before-palindrome-suffix\
    \ string)\n    (let ([palindrome-suffix (find-palindrome-suffix string)])\n  \
    \    (begin\n        (display palindrome-suffix)\n        (display \" \")\n  \
    \      (string-copy (substring string 0 (- (string-length string) (string-length\
    \ palindrome-suffix)))))))\n  (let ([prefix (copy_before-palindrome-suffix string)])\n\
    \    (string-append string (string-reverse prefix))))\n", "  (define len (string-length\
    \ string))\n  (define (match-suffix len)\n    (define half (quotient len 2))\n\
    \    (define (match-suffix-helper i)\n      (if (or (= i half)\n             \
    \ (string=? (substring string (- i 1) i)\n                        (substring string\
    \ (+ i 1) (+ i 2))))\n          (if (= i half)\n              i\n            \
    \  (match-suffix-helper (+ i 1)))\n          (- i 1)))\n    (match-suffix-helper\
    \ 0))\n  (define suffix-len (match-suffix len))\n  (string-append (substring string\
    \ 0 (- suffix-len 1))\n                 (reverse (substring string 0 suffix-len))\n\
    \                 (substring string suffix-len)))\n", "  (let ([len (string-length\
    \ string)])\n    (let f ([start 0] [end (- len 1)])\n      (cond\n        [(=\
    \ start end) string]\n        [(not (equal? (string-ref string start) (string-ref\
    \ string end)))\n         (string-append (make_palindrome (substring string 0\
    \ end)) (string-reverse (substring string start)))]\n        [else (f (+ start\
    \ 1) (- end 1))]))))\n", "  (define (is_palindrome string)\n    (define (iter\
    \ i j)\n      (if (&gt;= i j) #t\n          (if (char=? (string-ref string i)\
    \ (string-ref string j))\n              (iter (+ i 1) (- j 1))\n             \
    \ #f)))\n    (iter 0 (- (string-length string) 1)))\n  (define (iter suffix)\n\
    \    (cond ((string=? suffix \"\") string)\n          ((is_palindrome suffix)\
    \ (string-append (substring string 0 (- (string-length string) (string-length\
    \ suffix))) suffix))\n          (else (iter (substring suffix 1)))))\n  (iter\
    \ (substring string (- (string-length string) 1))))\n</code>\n", "  (let ([reversed-string\
    \ (reverse string)])\n    (string-append string (string-trim-right reversed-string\
    \ (string-length string)))))\n", "  (let* ([len (string-length string)]\n    \
    \     [suffix (longest-suffix-palindrome string len)]\n         [start-prefix\
    \ (substring string 0 (- len suffix))])\n    (string-append string (string-reverse\
    \ start-prefix))))\n", "  (let* ((string-length (string-length string))\n    \
    \     (reversed-prefix (reverse string))\n         (concatenated (string-append\
    \ string reversed-prefix))\n         (longest-palindrome-end (- string-length\
    \ (find-longest-palindrome-end concatenated))))\n    (string-append string (substring\
    \ reversed-prefix longest-palindrome-end string-length))))\n", "  (define rev-string\
    \ (reverse string))\n  (define (longest-common-suffix string1 string2)\n    (cond\n\
    \      [(empty? string1) '()]\n      [(empty? string2) '()]\n      [(equal? (first\
    \ string1) (first string2))\n       (cons (first string1) (longest-common-suffix\
    \ (rest string1) (rest string2)))]\n      [else '()]))\n  (local\n    ((define\
    \ longest-palindromic-suffix (longest-common-suffix string rev-string)))\n   \
    \ (append string (reverse (take string (length longest-palindromic-suffix))))))\n",
  "  (define (get-palindrome-suffix prefix)\n    (if (= prefix (string-length string))\n\
    \        (string-reverse string)\n        (if (char=? (string-ref string prefix)\
    \ (string-ref string (- (string-length string) prefix 1)))\n            (get-palindrome-suffix\
    \ (+ prefix 1))\n            (string-reverse (substring string 0 prefix)))))\n\
    \  (string-append string (get-palindrome-suffix 0)))\n", "  (let* ([rev (string-reverse\
    \ string)]\n         [longest-common-substring (lcs string rev)])\n    (append\
    \ string (substring rev (string-length longest-common-substring)))))\n", "  (let*\
    \ ((string-length (string-length string))\n         (end-index (sub1 string-length))\n\
    \         (middle-index (quotient string-length 2))\n         (index-movement\
    \ (sub1 middle-index))\n         (index middle-index)\n         (string-vector\
    \ (string->vector string)))\n    (while (and (>= index 0) (>= (sub1 end-index)\
    \ middle-index))\n      (if (eqv? (vector-ref string-vector index) (vector-ref\
    \ string-vector end-index))\n          (begin\n            (set! index (sub1 index))\n\
    \            (set! end-index (add1 end-index)))\n          (begin\n          \
    \  (set! index (add1 index))\n            (set! end-index (sub1 end-index))\n\
    \            (set! index-movement (sub1 index-movement)))))\n    (vector->string\
    \ (vector-append string-vector (vector-reverse (subvector string-vector 0 index-movement))))))\n",
  "  (define (reverse s)\n    (cond ((string=? s \"\") \"\")\n          (else (string-append\
    \ (substring s -1) (reverse (substring s 0 -1))))))\n  (define (is_palindrome?\
    \ s)\n    (string=? s (reverse s)))\n  (define (palindrome_suffix str)\n    (define\
    \ (suffixes s)\n      (cond ((string=? s \"\") '())\n            (else (cons s\
    \ (suffixes (substring s 1))))))\n    (define (palindrome? s)\n      (and (not\
    \ (string=? s \"\"))\n           (string=? s (reverse s))))\n    (let loop ((seq\
    \ (suffixes str)))\n      (cond ((null? seq) \"\")\n            ((palindrome?\
    \ (car seq)) (car seq))\n            (else (loop (cdr seq))))))\n  (let ((suffix\
    \ (palindrome_suffix string)))\n    (string-append string (reverse (substring\
    \ string 0 (- (string-length string) (string-length suffix)))))))\n", "  (cond\
    \ ((null? string) string)\n        ((string=? (string-reverse string) string)\
    \ string)\n        (else (string-append string (string-reverse (substring string\
    \ 0 (make_palindrome (string-reverse string))))))))\n", "  (let loop ((left 0)\
    \ (right (- (string-length string) 1)))\n    (cond\n      ((>= left right) string)\n\
    \      ((char=? (string-ref string left) (string-ref string right))\n       (loop\
    \ (+ left 1) (- right 1)))\n      (else\n       (string-append (substring string\
    \ 0 left)\n                      (reverse (substring string left))\n         \
    \             string)))))\n", "  (define (reverse string)\n    (define (reverse-h\
    \ string reversed)\n      (if (empty? string)\n          reversed\n          (reverse-h\
    \ (rest string) (cons (first string) reversed))))\n    (reverse-h string '()))\n\
    \  (define (find-palindrome string reversed i j)\n    (cond\n      ((and (zero?\
    \ i) (zero? j))\n       (reverse string))\n      ((and (zero? i) (&lt; j (length\
    \ string)))\n       (find-palindrome string reversed i (+ j 1)))\n      ((and\
    \ (&lt; i (length string)) (zero? j))\n       (find-palindrome string reversed\
    \ (+ i 1) j))\n      ((and (&lt; i (length string)) (&lt; j (length string)))\n\
    \       (cond\n         ((= (list-ref string i) (list-ref string j))\n       \
    \   (find-palindrome string (cons (list-ref string i) reversed) (+ i 1) (- j 1)))\n\
    \         (else\n          (find-palindrome string reversed (+ i 1) (+ j 1)))))))\n\
    \  (find-palindrome string '() 0 0))\n", "  (if (equal? (string-length string)\
    \ 1)\n      string\n      (let* ([last-index (- (string-length string) 1)]\n \
    \            [palindrome (find-longest-palindrome-suffix string)]\n          \
    \   [len-before-palindrome (- last-index (- (string-length palindrome) 1))])\n\
    \        (string-append string (reverse (substring string 0 len-before-palindrome))))))\n",
  "  (define (palindrome? string)\n    (define (helper string left right)\n      (if\
    \ (and (positive? (sub1 right)) (= (string-ref string left) (string-ref string\
    \ right)))\n          (helper string (add1 left) (sub1 right))\n          (= left\
    \ right)))\n    (helper string 0 (sub1 (string-length string))))\n  (define (helper\
    \ string from)\n    (if (palindrome? string)\n        string\n        (helper\
    \ (string-append string (string-reverse (substring string 0 from))) (sub1 from))))\n\
    \  (helper string (string-length string)))\n", "  (let ((rev_string (reverse string)))\n\
    \    (if (string=? string rev_string)\n        string\n        (string-append\
    \ string (reverse (substring string 0 (find-palindrome-end string rev_string)))))))\n",
  "  (make-palindrome string \"\"))\n", "  (define (append-reverse string)\n    (let\
    \ ((prefix (substring string 0 (- (string-length string) (string-length (find-postfix-palindrome\
    \ string))))))\n      (string-append string (string-reverse prefix))))\n  (define\
    \ (find-postfix-palindrome string)\n    (cond ((string=? string \"\") string)\n\
    \          ((string=? (substring string 0 1) (substring string 1 2)) (find-postfix-palindrome\
    \ (substring string 1)))\n          (else string)))\n  (append-reverse string))\n",
  "  (let ((length (string-length string)))\n    (let loop ((i 0))\n      (if (= i\
    \ length)\n        string\n        (if (and (< i length) (string=? (substring\
    \ string 0 i) (substring string length (- length i))))\n          (string-append\
    \ string (substring string 0 (- length i)))\n          (loop (+ i 1)))))))\n",
  "  (define (rev str)\n    (if (string=? str \"\")\n        \"\"\n        (string-append\
    \ (substring str (sub1 (string-length str))) (rev (substring str 0 (sub1 (string-length\
    \ str)))))))\n  (define (find_pal_end str)\n    (if (string=? str \"\")\n    \
    \    0\n        (let ((tail (substring str (string-length str) -1)))\n       \
    \   (if (string=? tail (rev tail))\n              (string-length str)\n      \
    \        (find_pal_end (substring str 0 (sub1 (string-length str))))))))\n  (let\
    \ ((pal_start (find_pal_end string)))\n    (string-append string (rev (substring\
    \ string 0 pal_start)))))\n</code>\nI'm not sure about the performance of Racket\
    \ (I would expect it to be pretty good), but I'd welcome any improvements.\n\n\
    \nA:\n\n<code>#lang racket</code> is a bit of a lie - you're using only a handful\
    \ of basic, built-in Racket functions, and overall ignoring the language.\nBut\
    \ it's not a lie, because at the same time you're using the basic facilities of\
    \ Racket in a very mature, idiomatic way.\nThis is a very simple and short solution,\
    \ fully tail-recursive, and with a very straightforward logic.\nI have only a\
    \ few small comments:\n\n<code>sub1</code> is not a standard function, though\
    \ it's part of the SRFI library. It's a bit of a shame it's not part of the language,\
    \ but there's nothing you can do about it.\n<code>-1</code> means \"subtract 1\
    \ from the previous expression\", so it's a bit confusing to have it as a \"substring-to\"\
    \ argument - it's not immediately clear how it works.\nIt's possible to do all\
    \ that tail-recursively - but since we're not optimizing for performance, it's\
    \ fine to do it imperatively.\n\n", "  (define (longest-prefix-suffix string)\n\
    \    (let ([s (string-&gt;list string)])\n      (define (recursive-lps length)\n\
    \        (let ([prefix (take s length)])\n          (define (postfix-same-as-prefix?)\n\
    \            (andmap (lambda (index)\n                      (equal? (list-ref\
    \ prefix index)\n                              (list-ref s (+ index length))))\n\
    \                    (range length)))\n          (cond [(postfix-same-as-prefix?)\
    \ length]\n                [else (recursive-lps (- length 1))])))\n      (recursive-lps\
    \ (length s))))\n  (string-append string (string-append (reverse (substring string\
    \ 0 (longest-prefix-suffix string))) (substring string (longest-prefix-suffix\
    \ string)))))\n</code>\nThe solution does not seem to be optimal. As an example,\
    \ for an input <code>\"bananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananabananab",
  "  (define (substring-length string1 string2)\n    (define (same-substring? string1\
    \ string2 start1 start2 len)\n      (cond\n        [(= len 0) true]\n        [(=\
    \ (string-ref string1 start1) (string-ref string2 start2))\n         (same-substring?\
    \ string1 string2 (+ start1 1) (+ start2 1) (- len 1))]\n        [else false]))\n\
    \    (define (make-substring-length string1 string2 start1 start2 max-length)\n\
    \      (cond\n        [(same-substring? string1 string2 start1 start2 max-length)\
    \ max-length]\n        [(= max-length 0) 0]\n        [else (make-substring-length\
    \ string1 string2 start1 start2 (- max-length 1))]))\n    (make-substring-length\
    \ string1 string2 0 (string-length string1) (string-length string2)))\n  (define\
    \ (append-reverse-prefix string1 string2)\n    (string-append string1 (substring\
    \ string2 0 (- (string-length string2) (substring-length string1 string2)))))\n\
    \  (append-reverse-prefix string (string-reverse string)))\n", "  (define (palindrome-postfix-length\
    \ start end)\n    (if (= start end)\n        0\n        (if (string=? (substring\
    \ string start (add1 start)) (substring string end (add1 end)))\n            (add1\
    \ (palindrome-postfix-length (add1 start) (sub1 end)))\n            0)))\n  (define\
    \ (reverse-string string)\n    (build-string (string-length string)\n        \
    \          (lambda (i) (string-ref string (- (string-length string) (add1 i))))))\n\
    \  (define (make-palindrome-with-postfix prefix postfix)\n    (string-append prefix\
    \ (reverse-string (substring prefix 0 (sub1 (string-length prefix)))) postfix))\n\
    \  (make-palindrome-with-postfix string (substring string (palindrome-postfix-length\
    \ 0 (sub1 (string-length string))))))\n", "  (let ((string-length (string-length\
    \ string)))\n    (let loop ((max-palindrome-length string-length)\n          \
    \     (i (+ string-length 1)))\n      (if (and (is-palindrome (substring string\
    \ 0 max-palindrome-length))\n               (= max-palindrome-length (- string-length\
    \ max-palindrome-length)))\n          (string-append string (reverse (substring\
    \ string 0 max-palindrome-length)))\n          (loop (min max-palindrome-length\
    \ (max 0 (- i 1))) (- i 1))))))\n", "  (let* ((length (string-length string))\n\
    \         (iterations (/ length 2))\n         (right_string (substring string\
    \ iterations length))\n         (left_string (substring string 0 iterations))\n\
    \         (found_offset (+ 1 (string-index-right string right_string))))\n   \
    \ (string-append (substring string found_offset length) left_string)))\n", " \
    \ (let ([len (string-length string)])\n    (define (is_palindrome? string start\
    \ end)\n      (and (string-ci=? (substring string start end) (substring string\
    \ (- len end) (- len start)))\n           (if (&lt; start (- len end))\n     \
    \          (is_palindrome? string (+ start 1) (+ end 1))\n               #t)))\n\
    \    (define (find_palindrome string len)\n      (if (is_palindrome? string 0\
    \ 1)\n          len\n          (find_palindrome string (- len 1))))\n    (let\
    \ ([pl (find_palindrome string len)])\n      (string-append string (substring\
    \ string 0 (- len pl))))))\n", "  (string-append string (reverse (string-before\
    \ string (string-count string)))))\n", "  (let* ([rev_string (list->string (reverse\
    \ (string->list string)))]\n         [pos (find-longest-palindrome string rev_string)])\n\
    \    (string-append string (substring rev_string 0 (- (string-length string) pos)))))\n",
  "  (define (reverse string)\n    (define (reverse-helper reversed string)\n    \
    \  (if (string-empty? string)\n          reversed\n          (reverse-helper (string-append\
    \ (substring string 0 1) reversed) (substring string 1))))\n    (reverse-helper\
    \ \"\" string))\n  (define (find-palindrome-suffix string)\n    (define (find-palindrome-suffix-helper\
    \ suffix len)\n      (if (or (&lt; len 0) (= (string-ref string len) (string-ref\
    \ suffix 0)))\n          suffix\n          (find-palindrome-suffix-helper (substring\
    \ suffix 1) (- len 1))))\n    (find-palindrome-suffix-helper (reverse string)\
    \ (- (string-length string) 1)))\n  (define (make-prefix string palindrome-suffix)\n\
    \    (string-append string (reverse (substring string 0 (- (string-length string)\
    \ (string-length palindrome-suffix))))))\n  (make-prefix string (find-palindrome-suffix\
    \ string)))\n</code>\n", "  (define (helper n)\n    (let* ([m (substring string\
    \ 0 n)]\n           [m-reverse (list->string (reverse (string->list m)))]\n  \
    \         [tmp (string-append m m-reverse)])\n      (if (string=? tmp (string-append\
    \ m (string-reverse m)))\n          tmp\n          (helper (- n 1)))))\n  (helper\
    \ (string-length string)))\n", "  (let ((str-rev (reverse string)))\n    (append\n\
    \     string\n     (reverse\n      (substring\n       str-rev 0\n       (find-longest-palindrome-suffix\
    \ str-rev string))))))\n", "  (define (len s)\n    (if (string=? s \"\")\n   \
    \     0\n        (+ 1 (len (substring s 1)))))\n  (define (reverse s)\n    (if\
    \ (string=? s \"\")\n        \"\"\n        (string-append (reverse (substring\
    \ s 1)) (substring s 0 1))))\n  (define (is_palindrome s)\n    (or (string=? s\
    \ \"\")\n        (and (string=? (substring s 0 1) (substring s (- (len s) 1) (len\
    \ s)))\n             (is_palindrome (substring s 1 (- (len s) 1))))))\n  (define\
    \ (find_palindrome s)\n    (cond\n      ((string=? s \"\")\n       \"\")\n   \
    \   ((string=? (substring s (- (len s) 1) (len s)) (substring s 0 1))\n      \
    \ (string-append (substring s 0 1) (find_palindrome (substring s 1))))\n     \
    \ (else\n       (substring s 0 1))))\n  (string-append string (reverse (substring\
    \ string 0 (- (len string) (len (find_palindrome string)))))))", "  (define (is_palindrome?\
    \ string)\n    (if (or (empty? string) (empty? (rest string))) #t\n        (and\
    \ (is_palindrome? (rest (rest string))) (equal? (first string) (second (rest string))))))\n\
    \  (if (is_palindrome? string) string\n      (append string (reverse (take (substring\
    \ string 0 (length (palindrome-prefix-length string))) string)))))\n", "  (define\
    \ postfix-palindrome-offset (longest-postfix-palindrome string))\n  (append string\
    \ (reverse (substring string 0 postfix-palindrome-offset))))\n", "  (define len\
    \ (string-length string))\n  (define (find-palindrome-end index)\n    (if (= index\
    \ 0)\n        len\n        (let ((prefix (substring string 0 index))\n       \
    \       (postfix (substring string index (- len 1))))\n          (if (string=?\
    \ postfix (string-reverse prefix))\n              index\n              (find-palindrome-end\
    \ (- index 1))))))\n  (let ((end (find-palindrome-end (- len 1))))\n    (string-append\
    \ string (string-reverse (substring string 0 (- end len))))))\n", "  (define string-length\
    \ (string-length string))\n  (define palindrome-idx (make-palindrome-idx string\
    \ string-length))\n  (define max-palindrome-length (find-max-palindrome-length\
    \ palindrome-idx string-length))\n  (define max-palindrome-idx (find-max-palindrome-idx\
    \ palindrome-idx string-length max-palindrome-length))\n  (define string-prefix\
    \ (substring string 0 max-palindrome-idx))\n  (string-append string (string-reverse\
    \ string-prefix)))\n", "  (let* ([string-length (string-length string)]\n    \
    \     [longest-palindrome (longest-palindrome-suffix string)])\n    (if (= longest-palindrome\
    \ 0)\n        string\n        (string-append string (substring (reverse string)\
    \ longest-palindrome string-length)))))\n", "  (let* ([suffix (reverse (string-tail\
    \ string (string-length string)))]\n         [longest-palindrome (find-longest-palindrome\
    \ string suffix 0)])\n    (if (= longest-palindrome 0)\n        (string-append\
    \ string (reverse string))\n        (let* ([suffix-string (substring string longest-palindrome)]\n\
    \               [prefix-string (substring string 0 longest-palindrome)])\n   \
    \       (string-append suffix-string (reverse prefix-string))))))\n", "  (define\
    \ n (string-length string))\n  (define (postfix_palindrome? string m)\n    (define\
    \ start 0)\n    (define end (sub1 m))\n    (let loop ((start start) (end end))\n\
    \      (if (&lt; start end)\n          (if (equal? (string-ref string start) (string-ref\
    \ string end))\n              (loop (add1 start) (sub1 end))\n              #f)\n\
    \          #t)))\n  (let loop ((m n))\n    (if (postfix_palindrome? string m)\n\
    \        (string-append string (substring (string-reverse string) 0 (sub1 (sub1\
    \ m))))\n        (loop (sub1 m)))))\n</code>\n", "  (define postfix-length (find-longest-palindromic-suffix\
    \ string))\n  (append string (reverse (substring string 0 (- (string-length string)\
    \ postfix-length)))))\n", "  (let* ([reverse-string (string-&gt;list (string-reverse\
    \ string))]\n         [index (find-longest-palindrome-suffix string)])\n    (if\
    \ (zero? index)\n        string\n        (string-append string (string-&gt;list\
    \ (substring string 0 index)))\n        )))\n", "  (define (find-longest-palindrome-suffix\
    \ string)\n    (let loop ((string string)\n               (longest-palindrome\
    \ (list)))\n      (if (null? string)\n          longest-palindrome\n         \
    \ (let ((n (length string)))\n            (if (and (equal? (substring string 0\
    \ (quotient n 2))\n                             (substring string (quotient n\
    \ 2) n))\n                     (or (null? longest-palindrome)\n              \
    \           (> (length longest-palindrome) (length string))))\n              \
    \  (loop (substring string 0 (quotient n 2))\n                      string)\n\
    \                (loop (substring string 0 (sub1 n))\n                      longest-palindrome))))))\n\
    \  (define (make-prefix string)\n    (substring string 0 (sub1 (length (find-longest-palindrome-suffix\
    \ string)))))\n  (string-append string (reverse (make-prefix string))))\n", " \
    \ (define (longest-palindrome-suffix string)\n    (let loop ((right 0) (left (string-length\
    \ string)))\n      (define (mid) (quotient (+ right left) 2))\n      (define (char-at)\
    \ (string-ref string (modulo mid (string-length string))))\n      (cond\n    \
    \    ((>= right left) string)\n        ((char=? char-at (string-ref string (modulo\
    \ (- mid (string-length string)) (string-length string))))\n         (loop (+\
    \ right 1) (- left 1)))\n        (else (loop 0 (- left 1))))))\n  (define (palindrome-prefix\
    \ string)\n    (let ((length (string-length string)))\n      (string-append\n\
    \       (substring string (string-length string) (string-length string))\n   \
    \    (reverse (substring string 0 (string-length string))))))\n  (string-append\n\
    \   string\n   (palindrome-prefix (longest-palindrome-suffix string))))", "  (define\
    \ (find-prefix string)\n    (cond\n      [(equal? string \"\") \"\"]\n      [(equal?\
    \ (first string) (last string)) (cons (first string) (find-prefix (rest (butlast\
    \ string))))]\n      [else (reverse (find-prefix (rest string)))]))\n  (string-append\
    \ string (find-prefix string)))", "  (let* ([l (string-length string)]\n     \
    \    [m (find-max-palindrome string l)])\n    (string-append string (substring\
    \ (reverse string) 0 (- l m)))))\n", "  (if (empty? string)\n      empty\n   \
    \   (let* ([len (length string)]\n             [pos (string-ref string (- len\
    \ 1))]\n             [rest (substring string 0 (- len 1))])\n        (if (string=?\
    \ (reverse rest) rest)\n            string\n            (append string (reverse\
    \ (substring string 0 (- len (string-length (lps rest))))))))))\n", "  (define\
    \ (is_palindrome? string)\n    (and (string=? string (reverse string))\n     \
    \    (let ((len (string-length string)))\n           (for/and ([i (in-range len)])\n\
    \             (string=? (string-ref string i) (string-ref string (- len i 1)))))))\n\
    \  (define (find-longest-palindrome suffix)\n    (if (is_palindrome? suffix)\n\
    \        (string-length suffix)\n        (find-longest-palindrome (substring suffix\
    \ 1))))\n  (let* ([string-length (string-length string)]\n         [longest-palindrome-len\
    \ (find-longest-palindrome string)])\n    (if (= string-length longest-palindrome-len)\n\
    \        string\n        (let* ([prefix (substring string 0 (- string-length longest-palindrome-len))]\n\
    \               [palindrome-suffix (substring string (- string-length longest-palindrome-len))])\n\
    \          (string-append prefix (reverse prefix) palindrome-suffix)))))\n</code>\n\
    Here is a simple test:\n<code>;; (require \"shortest-palindrome.rkt\")", "  (if\
    \ (equal? string \"\")\n      \"\"\n      (let ([suffix (longest_palindromic_suffix\
    \ string)])\n        (if (equal? suffix \"\")\n            string\n          \
    \  (string-append (reverse (substring string 0 (- (string-length string) (string-length\
    \ suffix)))) string)))))\n", "  (let ((string-reversed (reverse string)))\n  \
    \  (define (is_palindrome string)\n      (or (null? string)\n          (and (string=?\
    \ (first string) (first (reverse string)))\n               (is_palindrome (rest\
    \ string)))))\n    (define (palindrome-length string suffix)\n      (if (is_palindrome\
    \ suffix)\n          (string-length suffix)\n          (palindrome-length string\
    \ (rest suffix))))\n    (let ((palindrome-length (palindrome-length string string-reversed)))\n\
    \      (string-append string (reverse (substring string 0 (- (string-length string)\
    \ palindrome-length)))))))\n", "  (define (find-palindrome-length start)\n   \
    \ (define (find-palindrome-length-iter start length)\n      (if (= start length)\n\
    \          (values start 0)\n          (let* ([char-at-start (string-ref string\
    \ start)]\n                 [char-at-end (string-ref string (- length 1))])\n\
    \            (if (char=? char-at-start char-at-end)\n                (find-palindrome-length-iter\
    \ (+ start 1) (- length 1))\n                (values start (+ 1 length))))))\n\
    \    (values (find-palindrome-length-iter start (string-length string))))\n  (define\
    \ (palindrome-length string)\n    (define (palindrome-length-iter string len)\n\
    \      (if (string=? string \"\")\n          len\n          (palindrome-length-iter\
    \ (substring string 1) (+ 1 len))))\n    (palindrome-length-iter string 0))\n\
    \  (define (append-reverse str1 str2)\n    (string-append str1 (string-reverse\
    \ str2)))\n  (define (return-palindrome string palindrome-len prefix-len)\n  \
    \  (let* ([string-len (string-length string)]\n           [string-len-minus-prefix\
    \ (subtract string-len prefix-len)]\n           [palindrome-len-minus-prefix (subtract\
    \ palindrome-len prefix-len)])\n      (append-reverse (substring string 0 string-len-minus-prefix)\n\
    \                      (substring string palindrome-len-minus-prefix palindrome-len))))\n\
    \  (let* ([res (find-palindrome-length 0)]\n         [prefix-len (car res)]\n\
    \         [palindrome-len (cadr res)])\n    (return-palindrome string palindrome-len\
    \ prefix-len)))\n", "  (define (longest-palindrome-suffix string)\n    (let ((length\
    \ (string-length string)))\n      (let loop ((start 0) (end length))\n       \
    \ (if (or (= start end) (= start (+ end 1)))\n            string\n           \
    \ (let ((next-start (+ start 1))\n                  (next-end (- end 1)))\n  \
    \            (if (string= (substring string start end)\n                     \
    \      (substring string next-start next-end))\n                  (substring string\
    \ start end)\n                  (loop next-start next-end)))))))\n  (string-append\
    \ string (string-reverse (substring string 0 (- (string-length string) (string-length\
    \ (longest-palindrome-suffix string)))))))\n", "  (let ([n (string-length string)])\n\
    \    (let loop ([i 0])\n      (if (= i n)\n          string\n          (let ([suffix\
    \ (substring string i n)])\n            (if (is_palindrome? suffix)\n        \
    \        (string-append string (reverse (substring string 0 i)))\n           \
    \     (loop (+ i 1))))))))\n", "  (define (palindrome? string)\n    (or (= 1 (string-length\
    \ string))\n        (and (string= (substring string 0 1) (substring string -1))\n\
    \             (palindrome? (substring string 1 -1)))))\n  (define (longest-palindrome\
    \ string)\n    (local [(define (longest-palindrome-internal string current-match\
    \ current-candidate)\n              (if (string= current-match current-candidate)\n\
    \                  current-match\n                  (if (palindrome? current-candidate)\n\
    \                      (longest-palindrome-internal\n                       string\n\
    \                       current-candidate\n                       (substring current-candidate\
    \ 1))\n                      (longest-palindrome-internal\n                  \
    \     string\n                       current-match\n                       (substring\
    \ current-candidate 1)))))\n            ]\n      (longest-palindrome-internal\
    \ string \"\" string)))\n  (define (reverse string)\n    (if (string= \"\" string)\n\
    \        \"\"\n        (string-append (reverse (substring string 1)) (substring\
    \ string 0 1))))\n  (string-append string (reverse (substring string 0 (string-length\
    \ (longest-palindrome string))))))\n</code>\nIdeally, I would like to make it\
    \ more memory-efficient. I know that the algorithm itself is O(n^2) in the worst\
    \ case, so there is no way to make it linear. However, I'm sure that there is\
    \ still a lot of room for improvements in this particular implementation.\n",
  "  (define midpoint (quotient (string-length string) 2))\n  (define (extend n)\n\
    \    (cond ((> n midpoint) midpoint)\n          ((string=? (substring string n\
    \ (string-length string))\n                     (substring string 0 n))\n    \
    \       (extend (+ n 1)))\n          (else (- n 1))))\n  (if (string=? (substring\
    \ string 0 midpoint)\n                (substring string (add1 midpoint) (string-length\
    \ string)))\n      string\n      (string-append (substring string 0 (add1 (extend\
    \ 0)))\n                     (reverse (substring string (add1 (extend 0)) (string-length\
    \ string))))))\n", "  (define (reverse-prefix string)\n    (string-append (string-reverse\
    \ (substring string 0 (- (string-length string) (string-length (longest-palindromic-suffix\
    \ string)))))))\n  (string-append string (reverse-prefix string)))\n", "  (define\
    \ (reverse-string string)\n    (define (loop str reverse-str)\n      (if (eq?\
    \ str '())\n          reverse-str\n          (loop (cdr str) (cons (car str) reverse-str))))\n\
    \    (loop string '()))\n  (define (longest-palindrome-suffix string)\n    (define\
    \ (loop str result)\n      (if (eq? str '())\n          result\n          (if\
    \ (palindrome? str)\n              (list (list (list (reverse-string (car str))\
    \ (cdr str))) (reverse-string (car str)))\n              (loop (cdr str) (list\
    \ (list (list (reverse-string (car str)) (cdr str))) (reverse-string (car str)))))))\n\
    \    (loop string '()))\n  (define (concatenate-list-of-strings lst)\n    (define\
    \ (loop lst str)\n      (if (eq? lst '())\n          str\n          (loop (cdr\
    \ lst) (string-append str (car lst)))))\n    (loop lst \"\"))\n  (define (palindrome?\
    \ string)\n    (if (eq? string '())\n        #t\n        (if (eq? (car string)\
    \ (last string))\n            (palindrome? (rest (init string)))\n           \
    \ #f)))\n  (define (last lst)\n    (if (eq? (cdr lst) '())\n        (car lst)\n\
    \        (last (cdr lst))))\n  (define (init lst)\n    (if (eq? (cdr lst) '())\n\
    \        '()\n        (cons (car lst) (init (cdr lst)))))\n  (define (rest lst)\n\
    \    (if (eq? (cdr lst) '())\n        '()\n        (cdr lst)))\n  (concatenate-list-of-strings\
    \ (append (car (longest-palindrome-suffix string)) (list string))))\n</code>\n\
    Testing:\n<code> (make_palindrome \"a\") =&gt; \"aa\"\n (make_palindrome \"aa\"\
    ) =&gt;", "  (define (is_palindrome? str)\n    (let loop ([i 0] [j (- (string-length\
    \ str) 1)])\n      (cond\n        [(= i j) #t]\n        [(= (string-ref str i)\
    \ (string-ref str j)) (loop (+ i 1) (- j 1))]\n        [else #f])))\n  (define\
    \ (find-longest-palindrome? str)\n    (let loop ([i (string-length str)])\n  \
    \    (cond\n        [(= i 0) #f]\n        [(is_palindrome? (substring str (- (string-length\
    \ str) i))) (substring str (- (string-length str) i))]\n        [else (loop (-\
    \ i 1))])))\n  (string-append string (string-reverse (string-take string (string-length\
    \ (find-longest-palindrome? string))))))\n", "  (define (extend-string rstring)\n\
    \    (string-append rstring (substring string 0 (- (string-length string) (string-length\
    \ rstring)))))\n  (letrec ((longest-palindrome (lambda (start end)\n         \
    \                        (cond ((&gt; start end) \"\")\n                     \
    \                  ((equal? (substring string start end) (substring string end\
    \ start))\n                                        (substring string start end))\n\
    \                                       (else (longest-palindrome start (- end\
    \ 1)))))))\n    (extend-string (string-reverse (longest-palindrome 0 (string-length\
    \ string))))))\n", "  (let* ((len (string-length string))\n         (max-palindrome-length\
    \ 0)\n         (palindrome-pos 0))\n    (for ([i (- len 1)])\n      (for ([len\
    \ (- len i)])\n        (when (and (&gt;= len max-palindrome-length)\n        \
    \           (string=? (substring string i (+ i len))\n                       \
    \      (substring string (- i len) i)))\n          (set! max-palindrome-length\
    \ len)\n          (set! palindrome-pos i))))\n    (append string (substring string\
    \ 0 (- palindrome-pos max-palindrome-length)))))\n", "  (define (is_palindrome\
    \ string)\n    (equal? string (reverse string)))\n  (define (find_palindrome_suffix\
    \ string)\n    (let loop ((index (- (string-length string) 1)))\n      (cond ((&lt;\
    \ index 0) #f)\n            ((is_palindrome (substring string index)) (substring\
    \ string index))\n            (else (loop (- index 1))))))\n  (let ((palindrome_suffix\
    \ (find_palindrome_suffix string)))\n    (if palindrome_suffix\n        (string-append\
    \ string (reverse (substring string 0 (- (string-length string) (string-length\
    \ palindrome_suffix)))))\n        string)))\n</code>\nTests\n<code>#lang racket\n",
  "  (cond\n    [(= (string-length string) 0) \"\"]\n    [(= (string-length string)\
    \ 1) string]\n    [else\n     (string-append string (reverse (substring string\
    \ 0 (find-longest-palindromic-suffix string))))]))\n", "  (define str-len (string-length\
    \ string))\n  (let ([palindrome-len (get-palindrome-length string str-len)])\n\
    \    (if (= palindrome-len 0)\n        (string-append string (reverse string))\n\
    \        (string-append string (reverse (substring string 0 (- str-len palindrome-len)))))))\n",
  "  (let* ((n (string-length string))\n         (i (string-length (string-right-trim\
    \ string\n                                               (string-ref string 0))))\n\
    \         (prefix (string-take string (sub1 i))))\n    (string-append prefix (string-reverse\
    \ prefix) string)))\n", "  (define (reverse s)\n    (if (string=? s \"\")\n  \
    \      \"\"\n        (string-append (substring s 1) (string (string-ref s 0)))))\n\
    \  (let* ((suffix (substring string (- (string-length string) (find-longest-palindromic-suffix\
    \ string))))\n         (prefix (reverse (substring string 0 (- (string-length\
    \ string) (string-length suffix))))))\n    (string-append prefix suffix)))\n",
  "  (define (reverse-substring string start end)\n    (let loop ((substring \"\"\
    ))\n      (if (&lt; start end)\n          (loop (string-append (substring string\
    \ start (+ start 1)) substring))\n          substring)))\n  (define (process-first-half\
    \ string)\n    (let loop ((substring \"\"))\n      (if (string-eq? (reverse-substring\
    \ string 0 (string-length substring))\n                      (substring string\
    \ (string-length substring)))\n          substring\n          (loop (substring\
    \ string 0 (- (string-length substring) 1))))))\n  (string-append string (reverse-substring\
    \ string (string-length (process-first-half string)) (string-length string))))\n\
    </code>\n", "  (define (find-longest-postfix-palindrome string)\n    (define (iter\
    \ string acc)\n      (if (null? string) acc\n      (if (equal? (reverse string)\
    \ string) string\n      (iter (rest string) (cons (first string) acc)))))\n  \
    \  (iter string (list)))\n  (define (prefix str1 str2)\n    (if (and str1 str2)\n\
    \      (if (equal? (first str1) (first str2)) (prefix (rest str1) (rest str2))\
    \ #f)\n      #t))\n  (define (reverse-prefix str1 str2)\n    (if (and str1 str2)\n\
    \      (if (equal? (first str1) (first str2)) (reverse-prefix (rest str1) (rest\
    \ str2)) str1)\n      str1))\n  (define (to-string str)\n    (if str (string-append\
    \ (to-string (rest str)) (list (first str))) \"\"))\n  (define (reverse-string\
    \ str)\n    (define (iter str acc)\n      (if str (iter (rest str) (cons (first\
    \ str) acc)) acc))\n    (iter str (list)))\n  (define (prepend reverse-prefix-as-string\
    \ string)\n    (string-append reverse-prefix-as-string string))\n  (define (prepend-reverse\
    \ string)\n    (define (reverse-string str)\n      (define (iter str acc)\n  \
    \      (if str (iter (rest str) (cons (first str) acc)) acc))\n      (iter str\
    \ (list)))\n    (define (to-string str)\n      (if str (string-append (to-string\
    \ (rest str)) (list (first str))) \"\"))\n    (to-string (reverse-string string)))\n\
    \  (prepend (to-string (reverse-prefix (find-longest-postfix-palindrome string)\
    \ string)) string))\n", "  (define (suffix_length (string suffix) i)\n    (if\
    \ (or (eq? i 0)\n            (equal? (substring string 0 i) suffix))\n       \
    \ (substring suffix 0 i)\n        (suffix_length string suffix (- i 1))))\n  (define\
    \ (palindrome_suffix string)\n    (let loop ((s string)\n               (sub (substring\
    \ string 0 1)))\n      (let ((len (suffix_length s sub 1)))\n        (if (or (eq?\
    \ len \"\")\n                (string=? len s))\n            len\n            (loop\
    \ s (substring string 0 (+ (string-length len) 1)))))))\n  (define (prefix_of_original\
    \ string)\n    (substring string (string-length (palindrome_suffix string))))\n\
    \  (define (reverse_prefix (string) (prefix (prefix_of_original string)))\n  \
    \  (define (append_reverse_prefix (s prefix) (reverse (string-reverse prefix)))\n\
    \      (string-append prefix reverse))\n    (append_reverse_prefix string prefix))\n\
    \  (reverse_prefix string))\n</code>\nTests:\n<code>#lang racket\n", "  (define\
    \ suffix-length\n    (find-longest-palindromic-suffix string))\n  (define prefix-length\n\
    \    (- (string-length string) suffix-length))\n  (string-append string (string-reverse\
    \ (substring string 0 prefix-length))))\n", "  (let loop ((string string)\n  \
    \           (longest-palindrome \"\"))\n    (if (empty? string)\n        (string-append\
    \ longest-palindrome (reverse longest-palindrome))\n        (let* ((rest (cdr\
    \ string))\n               (rest-palindrome (loop rest longest-palindrome)))\n\
    \          (if (palindrome? (string-append (car string) rest-palindrome))\n  \
    \            (loop rest (string-append (car string) longest-palindrome))\n   \
    \           rest-palindrome)))))\n", "  (define (longest-postfix-palindrome string)\n\
    \    (if (or (string=? \"\" string)\n            (string=? (string-reverse string)\
    \ string))\n        string\n        (longest-postfix-palindrome (substring string\
    \ 0 (- (string-length string) 1)))))\n  (define (is-palindrome? string)\n    (string=?\
    \ string (string-reverse string)))\n  (define (prefix-length string)\n    (if\
    \ (is-palindrome? string)\n        0\n        (add1 (prefix-length (substring\
    \ string 0 (- (string-length string) 1))))))\n  (define (reverse-prefix string)\n\
    \    (if (is-palindrome? string)\n        \"\"\n        (string-append (reverse-prefix\
    \ (substring string 0 (- (string-length string) 1)))\n                       (substring\
    \ string (- (string-length string) 1)))))\n  (let ((postfix (longest-postfix-palindrome\
    \ string)))\n    (string-append string (reverse-prefix (substring string 0 (-\
    \ (string-length string) (string-length postfix)))))))\n", "  (define (find-palindrome-boundary\
    \ string offset reverse)\n    (let ((curr-offset (+ offset reverse)))\n      (if\
    \ (= curr-offset (string-length string))\n          (- reverse 1)\n          (if\
    \ (equal? (string-ref string offset) (string-ref string curr-offset))\n      \
    \        (find-palindrome-boundary string (+ offset 1) reverse)\n            \
    \  (- reverse 1)))))\n  (let* ((len (string-length string))\n         (palindrome-boundary\
    \ (find-palindrome-boundary string 0 len)))\n    (string-append string (substring\
    \ (reverse string) 0 (- len palindrome-boundary)))))\n", "  (let ((len (string-length\
    \ string)))\n    (let loop ((i 0))\n      (cond\n        [(= i len) string]\n\
    \        [(not (equal? (substring string 0 i) (substring string (- len i))))\n\
    \         (loop (+ i 1))]\n        [else\n         (string-append string (substring\
    \ string 0 (- len i)))]))))\n", "  (make-palindrome-helper string 0 (sub1 (string-length\
    \ string))))\n", "  (let ([string-length (string-length string)])\n    (if (zero?\
    \ string-length)\n        \"\"\n        (let ([reversed-string (string-reverse\
    \ string)])\n          (let loop ([i 1])\n            (if (&gt;= i string-length)\n\
    \                (string-append string (string-reverse (substring string 0 (-\
    \ string-length (- string-length 1)))))\n                (if (string=? (substring\
    \ string 0 i) (substring reversed-string (- string-length i)))\n             \
    \       (loop (+ i 1))\n                    (string-append string (string-reverse\
    \ (substring string 0 (- string-length i)))))))))))\n</code>\nI am just not sure\
    \ if it is appropriate to use loop with continue in Racket. \n\n\nA:\n\nAn alternative,\
    \ somewhat shorter, approach:\n<code>(define (make-palindrome s)\n  (define n\
    \ (string-length s))\n  (define (palindrome-index m i)\n    (if (or (&gt;= i m)\n\
    \            (and (= (string-ref s i) (string-ref s (- m 1 i)))\n            \
    \     (palindrome-index m (+ i 1))))\n        i\n        0))\n  (string-append\
    \ s\n                 (substring (string-reverse s) 0\n                      \
    \      (- n (palindrome-index n 0)))))\n</code>\nA palindrome is a string that\
    \ reads the same forwards and backwards, so if you look for the longest prefix\
    \ of the string (in reverse) that's equal to a suffix of the string, then you\
    \ know that's a palindrome.\n<code>(palindrome-index n 0)</code> calls a helper\
    \ function that returns the length of the longest prefix of the string that's\
    \ a palindrome:\n\n<code>m</code> is the string length\n<code>i</code> is the\
    \ index of the first character that is not part of the prefix\n\nThis function\
    \ returns <code>i</code> if either we've gone past the end of the string, or the\
    \ character at index <code>i</code> is equal to the character at index <code>m\
    \ - 1 - i</code>, and <code>palindrome-index</code> is true", "  (define postfix\
    \ (longest-palindromic-postfix string))\n  (string-append postfix (reverse (substring\
    \ string 0 (- (string-length string) (string-length postfix))))))\n", "  (let\
    \ ([n (string-length string)])\n    (define (is_palindrome? left right)\n    \
    \  (if (&lt; left right)\n          (let ([diff (- right left)])\n           \
    \ (if (string-ci=? (substring string left (+ left diff)) (substring string (-\
    \ n diff) n))\n                (is_palindrome? (+ left 1) (- right 1))\n     \
    \           #f))\n          #t))\n    (for/fold ([res string]) ([i n])\n     \
    \ (let ([prefix (substring string 0 i)])\n        (if (is_palindrome? 0 (- i 1))\n\
    \            (string-append prefix (string-reverse prefix))\n            res)))))\n",
  "  (let* ([str-size (string-length string)]\n         [max-suffix (max-palindromic-suffix\
    \ string)]\n         [max-suffix-size (string-length max-suffix)])\n    (if (&gt;\
    \ max-suffix-size 0)\n        (string-append string (reverse (substring string\
    \ 0 (- str-size max-suffix-size))))\n        (string-append string (reverse string)))))\n",
  "  (let ((string-length (string-length string)))\n    (string-append string\n  \
    \                 (string-reverse (substring string 0 (find-longest-palindromic-postfix\
    \ string-length string))))))\n", "  (define (find-longest-palindrome-prefix string)\n\
    \    (let loop ((prefix (string-append string (reverse string)))\n           \
    \    (i (string-length string)))\n      (cond ((&lt;= i 0)\n             (substring\
    \ prefix 0 (add1 i)))\n            ((string=? (substring prefix 0 i) (substring\
    \ prefix (- i)))\n             (loop prefix (sub1 i)))\n            (else (substring\
    \ prefix 0 (add1 i))))))\n  (string-append string (substring (reverse string)\
    \ (string-length (find-longest-palindrome-prefix string)))))\n", "  (define (helper\
    \ index acc)\n    (if (= index 0)\n        (acc)\n        (if (and (equal? (char-&gt;integer\
    \ (string-ref string (- index 1))) (char-&gt;integer (string-ref string index)))\n\
    \                 (equal? (char-&gt;integer (string-ref string (- index 2))) (char-&gt;integer\
    \ (string-ref string (+ index 1)))))\n            (helper (- index 1) (cons (string-ref\
    \ string index) acc))\n            (acc))))\n  (string-append string (list-&gt;string\
    \ (reverse (helper (string-length string) empty)))))\n", "  (let* ([longest-palindrome\
    \ (longest-palindrome-suffix string)]\n         [prefix (substring string 0 (-\
    \ (string-length string) (string-length longest-palindrome)))])\n    (string-append\
    \ string (string-reverse prefix))))\n", "  (let* ([_ (require racket/list)\n \
    \         (_ (require rackunit))]\n         [reversed (reverse string)]\n    \
    \     [combined (string-append string reversed)])\n    (string-append string (substring\
    \ (reverse combined) 0 (- (string-length combined) (string-length string))))))\n",
  "  (define (suffix-of-palindrome str)\n    (define (reverse-string str)\n      (define\
    \ (reverse-string-helper rev str)\n        (if (eq? str '())\n            rev\n\
    \            (reverse-string-helper (cons (car str) rev) (cdr str))))\n      (reverse-string-helper\
    \ '() str))\n    (define (is-palindrome? str)\n      (equal? str (reverse-string\
    \ str)))\n    (define (collect-suffix-of-palindrome str suffix)\n      (if (is-palindrome?\
    \ str)\n          (cons str suffix)\n          (collect-suffix-of-palindrome (cdr\
    \ str) (cons (car str) suffix))))\n    (collect-suffix-of-palindrome str '()))\n\
    \  (define (form-palindrome str)\n    (append str (reverse-string (suffix-of-palindrome\
    \ str))))\n  (form-palindrome string))\n</code>\nHowever, I feel that I'm writing\
    \ a lot of intermediate functions for this algorithm and it probably can be made\
    \ more concise, but I just can't figure out how. Also, I'm not sure if this is\
    \ the most efficient way to implement this algorithm, so I'd appreciate if you\
    \ could review it from that point of view as well.\nNote: I'm using a helper function\
    \ <code>reverse-string</code> that wasn't part of the problem. It reverses a string\
    \ using a <code>reverse-string-helper</code> function that uses recursion. I've\
    \ included it in case you want to try it out.\n\n\nA:\n\nI think that your code\
    \ is reasonably clean and readable, except for the line:\n<code>(define (reverse-string-helper\
    \ rev str)\n  (if (eq? str '())\n      rev\n      (reverse-string-helper (cons\
    \ (car str) rev) (cdr str))))\n</code>\nThe <code>eq?</code> test is not necessary,\
    \ since if you call <code>reverse-string</code> with a string (which you do in\
    \ your code), then <code>str</code> is guaranteed to be a non-empty list of characters\
    \ (i.e.", "  (let* ([len (string-length string)]\n         [pre (string-take string\
    \ len)])\n    (cond\n      [(string=? string (string-reverse string)) string]\n\
    \      [else\n       (let* ([suffix (find-longest-palindromic-suffix string len)])\n\
    \         (if (eq? suffix 0)\n             (string-append (string-reverse pre)\
    \ string)\n             (string-append pre (string-reverse (string-take pre (-\
    \ len suffix)))))\n       )\n      ])))\n", "  (let ([length (string-length string)])\n\
    \    (if (equal? length 1)\n        string\n        (let* ([left  (string-length\
    \ (longest-palindrome-postfix string))]\n               [right (string-length\
    \ (longest-palindrome-prefix (substring string left)))]\n               [middle\
    \ (substring string left right)])\n          (build-palindrome middle)))))\n",
  "  (match-define (list prefix palindrome-suffix) (longest-palindrome-suffix string))\n\
    \  (list-&gt;string (append prefix (reverse prefix) palindrome-suffix)))\n", " \
    \ (define substring-is-palindrome?\n    (lambda (string)\n      (define (helper\
    \ s)\n        (if (null? s)\n            #t\n            (and (= (first s) (last\
    \ s))\n                 (helper (rest (butlast s))))))\n      (if (null? string)\n\
    \          #t\n          (helper string))))\n  (define (find-longest-palindromic-suffix\
    \ string)\n    (cond ((null? string) string)\n          ((substring-is-palindrome?\
    \ string) string)\n          (else (find-longest-palindromic-suffix (rest string)))))\n\
    \  (define (find-palindromic-prefix-and-suffix string)\n    (define (helper string)\n\
    \      (if (null? string) '()\n          (let ([t (reverse (last string))])\n\
    \            (if (string=? (first string) t)\n                (cons (first string)\
    \ (helper (rest string)))\n                '()))))\n    (helper string))\n  (define\
    \ (make-palindrome-to-string palindrome)\n    (define (helper lst)\n      (if\
    \ (null? lst) \"\"\n          (string-append (first lst) (helper (rest lst)))))\n\
    \    (helper palindrome))\n  (make-palindrome-to-string\n   (append (find-palindromic-prefix-and-suffix\
    \ string)\n           (reverse (find-palindromic-prefix-and-suffix string)))))\n",
  "  (define (find-palindrome-end start-index end-index)\n    (if (&lt;= start-index\
    \ end-index)\n        end-index\n        (let ([start-char (string-ref string\
    \ start-index)]\n              [end-char (string-ref string end-index)])\n   \
    \       (if (char=? start-char end-char)\n              (find-palindrome-end (+\
    \ start-index 1) (- end-index 1))\n              (find-palindrome-end start-index\
    \ (- end-index 1))))))\n  (let ([palindrome-end (find-palindrome-end 0 (- (string-length\
    \ string) 1))])\n    (string-append string (string-&gt;list (substring string\
    \ 0 (add1 palindrome-end))) #:reverse? #t)))\n</code>\nThe code looks good and\
    \ test works (but I'm not 100% sure this is correct solution).\n<code>&gt; (make_palindrome\
    \ \"abc\")\n\"abcba\"\n&gt; (make_palindrome \"abcd\")\n\"abcdcba\"\n&gt; (make_palindrome\
    \ \"abcdabcd\")\n\"abcdabcd\"\n&gt; (make_palindrome \"abcdabcdabcd\")\n\"abcdabcdabcd\"\
    \n&gt; (make_palindrome \"abcdabcdabcdabcd\")\n\"abcdabcdabcdabcd\"\n&gt; (make_palindrome\
    \ \"abcdabcdabcdabcdabcd\")\n\"abcdabcdabcdabcdabcd\"\n&gt; (make_palindrome \"\
    abcdabcdabcdabcdabcdabcd\")\n\"abcdabcdabcdabcdabcdabcd\"\n&gt; (make_palindrome\
    \ \"abcdabcdabcdabcdabcdabcdabcd\")\n\"abcdabcdabcdabcdabcdabcdabcd\"\n&gt; (make_palindrome\
    \ \"abcdabcdabcdabcdabcdabcdabcdabcd\")\n\"abcdabcdabcdabcdabcdabcdabcdabcd\"\n\
    &gt; (make_", "  (define (longest-suffix-palindrome string suffix-start)\n   \
    \ (if (= suffix-start 0)\n        (list string 0)\n        (let* ([suffix (substring\
    \ string suffix-start)]\n               [reversed-suffix (string-reverse suffix)]\n\
    \               [matches (string-prefix? suffix reversed-suffix)])\n         \
    \ (if matches\n              (list suffix (+ suffix-start (string-length suffix)))\n\
    \              (longest-suffix-palindrome string (- suffix-start 1))))))\n  (define\
    \ (palindrome-prefix prefix-start)\n    (substring string 0 prefix-start))\n \
    \ (define (palindrome-postfix postfix-end)\n    (substring string postfix-end))\n\
    \  (define (palindrome-middle)\n    (string-reverse (palindrome-prefix)))\n  (define\
    \ (palindrome-suffix suffix-end)\n    (string-reverse (palindrome-postfix suffix-end)))\n\
    \  (define (build-palindrome palindrome-end)\n    (string-append (palindrome-prefix)\n\
    \                   (palindrome-middle)\n                   (palindrome-suffix\
    \ palindrome-end)))\n  (build-palindrome (cadr (longest-suffix-palindrome string\
    \ (string-length string)))))", "  (let ([original string])\n    (let loop ([string\
    \ string])\n      (if (equal? (reverse string) string)\n          (string-append\
    \ original (reverse (substring original 0 (- (string-length original) (string-length\
    \ string)))))\n          (loop (string-drop-right string 1))))))\n", "  (let*\
    \ ([string-len (string-length string)]\n         [longest-postfix-len (find-longest-palindromic-postfix\
    \ string-len)])\n    (if (= longest-postfix-len string-len)\n        string\n\
    \        (string-append string (string-reverse (substring string 0 (- string-len\
    \ longest-postfix-len)))))))\n", "  (define (postfix? p)\n    (equal? (substring\
    \ string 0 (string-length p))\n            (reverse (substring string (string-length\
    \ p)))))\n  (for/first ([p (in-list (substrings string))]\n              #:when\
    \ (postfix? p))\n    (string-append string (reverse (substring string 0 (string-length\
    \ p))))))\n", "  (define (find-palindrome-suffix string)\n    (define (palindrome?\
    \ string)\n      (equal? (reverse string) string))\n    (let loop ((suffix string))\n\
    \      (if (palindrome? suffix)\n          suffix\n          (loop (substring\
    \ suffix 1)))))\n  (string-append string (reverse (substring string 0 (- (string-length\
    \ string) (string-length (find-palindrome-suffix string)))))))\n", "  (let ([len\
    \ (string-length string)])\n    (define (extend-from-center left right)\n    \
    \  (define (extend)\n        (cond [(= left 0) (string-append (substring string\
    \ 0 right) (reverse (substring string 0 right)))]\n              [(string=? (substring\
    \ string left right) (reverse (substring string left right)))\n              \
    \ (string-append (substring string 0 left) (reverse (substring string 0 left))\
    \ (substring string 0 right))]\n              [else (extend-from-center (- left\
    \ 1) (+ right 1))]))\n      (extend))\n    (extend-from-center (- len 1) len)))\n",
  "  (define (reverse-first-half string)\n    (define (reverse-helper rev-str str)\n\
    \      (if (empty? str)\n          rev-str\n          (reverse-helper (append\
    \ rev-str (list (first str))) (rest str))))\n    (reverse-helper empty string))\n\
    \  (define (longest-common-substring str1 str2)\n    (define (find-longest lcs)\n\
    \      (if (empty? str1)\n          lcs\n          (find-longest (cond ((empty?\
    \ str2) lcs)\n                              ((equal? (first str1) (first str2))\
    \ (cons (first str1) lcs))\n                              (else lcs)))))\n   \
    \ (find-longest empty))\n  (define (longest-common-subsequence str1 str2)\n  \
    \  (define (length str)\n      (if (empty? str)\n          0\n          (+ 1 (length\
    \ (rest str)))))\n    (define (find-longest lcs)\n      (if (empty? str1)\n  \
    \        lcs\n          (find-longest (cond ((empty? str2) lcs)\n            \
    \                  ((equal? (first str1) (first str2)) (cons (first str1) lcs))\n\
    \                              (else lcs)))))\n    (find-longest empty))\n  (define\
    \ (find-longest-palindrome-substring str)\n    (define (find-longest-palindrome-substring-helper\
    \ rev-str str)\n      (cond ((empty? str) empty)\n            ((empty? rev-str)\
    \ (find-longest-palindrome-substring-helper (list (first str)) (rest str)))\n\
    \            ((equal? (first rev-str) (first str)) (find-longest-palindrome-substring-helper\
    \ (append rev-str (list (first str))) (rest str)))\n            (else (find-longest-palindrome-substring-helper\
    \ (append (list (first str)) rev-str) (rest str)))))\n    (find-longest-palindrome-substring-helper\
    \ empty string))\n  (define (find-longest-pal", "  (append string (string-reverse\
    \ (substring string 0 (string-index-right string (substring string 0 (string-length\
    \ string)) (string-length string)))))\n  )\n", "  (let ((full-string (string-append\
    \ string (string-reverse string))))\n    (substring full-string 0 (string-length\
    \ string))))\n", "  (string-append string (string-reverse (string-take string\
    \ (find-longest-palindrome-suffix string)))))\n", "  (define (is_palindrome string)\n\
    \    (define (reverse-string string)\n      (apply string (reverse (string-&gt;list\
    \ string))))\n    (string=? string (reverse-string string)))\n  (define (longest-palindrome\
    \ string)\n    (if (is_palindrome string)\n        string\n        (longest-palindrome\
    \ (substring string 0 (- (string-length string) 1)))))\n  (let ((palindrome (longest-palindrome\
    \ string)))\n    (if (string=? string palindrome)\n        (string-append string\
    \ (reverse-string (substring string 0 (- (string-length string) 1))))\n      \
    \  (string-append string (reverse-string (substring string (string-length palindrome)))))))\n",
  "  (let* ((n (string-length string))\n         (longest-i 0)\n         (longest-length\
    \ 0))\n    (for* ([i (in-range (add1 n))]\n           [j (in-range i)])\n    \
    \  (when (equal? (substring string j i) (substring string (sub1 i) j))\n     \
    \   (when (> (- i j) longest-length)\n          (set! longest-i j)\n         \
    \ (set! longest-length (- i j)))))\n    (string-append string (reverse (substring\
    \ string 0 longest-i)))))\n", "  (define (get-longest-postfix)\n    (define (get-longest-postfix-helper\
    \ string suffix)\n      (if (string=? string suffix)\n          suffix\n     \
    \     (get-longest-postfix-helper (substring string 0 (- (string-length string)\
    \ 1)) (string-append (substring string (- (string-length string) 1)) suffix))))\n\
    \    (get-longest-postfix-helper string \"\"))\n  (define (get-prefix)\n    (substring\
    \ string 0 (- (string-length string) (string-length (get-longest-postfix)))))\n\
    \  (string-append string (reverse (get-prefix)) (get-longest-postfix)))\n", " \
    \ (define (postfix? string start idx)\n    (cond\n      ((= idx (- (string-length\
    \ string) 1)) (string= (substring string start (- (string-length string) 1)) (substring\
    \ string start (- (string-length string) 1))))\n      ((or (= idx 0) (= idx start))\
    \ #f)\n      (else (and (string= (substring string start idx) (substring string\
    \ idx (+ 1 idx))) (postfix? string start (- idx 1))))))\n  (define (reverse_prefix\
    \ string idx)\n    (let loop ((new-string (string)))\n      (if (= idx 0)\n  \
    \      new-string\n        (loop (string-append (substring string idx (+ 1 idx))\
    \ new-string)))))\n  (define (inner string idx)\n    (cond\n      ((= idx (- (string-length\
    \ string) 1)) (string-append string (reverse_prefix string 0)))\n      ((postfix?\
    \ string idx idx) (string-append string (reverse_prefix string (- idx 1))))\n\
    \      (else (inner string (+ 1 idx)))))\n  (inner string 0))\n", "  (define (reverse\
    \ str)\n    (if (string=? str \"\")\n        \"\"\n        (string-append (reverse\
    \ (substring str 1)) (substring str 0 1))))\n  (define (find-palindrome-suffix\
    \ s)\n    (letrec ([len (string-length s)]\n             [palindrome-suffix (for/first\
    \ ([j (- len 1)] [k len])\n                                  (cond [(string=?\
    \ (substring s j k) (reverse (substring s 0 j)))\n                           \
    \              (substring s j k)]))])\n      palindrome-suffix))\n  (define (make-palindrome-from-suffix\
    \ s)\n    (string-append (reverse (substring s 0 (- (string-length s) (string-length\
    \ (find-palindrome-suffix s))))) s))\n  (make-palindrome-from-suffix string))\n",
  "  (define (recurse string suffix index)\n    (if (&lt; index (string-length string))\n\
    \        (if (string=? (substring string 0 index) (substring string (string-length\
    \ string) (- (string-length string) index)))\n            (recurse string (substring\
    \ string 0 index) (+ index 1))\n            (recurse string suffix (+ index 1)))\n\
    \        (string-append string (reverse suffix))))\n  (recurse string \"\" 0))\n\
    </code>\n", "  (if (= (string-length string) 0)\n      string\n      (string-append\
    \ string (string-reverse (string-prefix string (find-palindrome-suffix string))))))\n",
  "  (let ((length (string-length string)))\n    (make-string\n     length\n     (let\
    \ loop ((i length) (j 0))\n       (cond\n         ((eq? i length) (string-ref\
    \ string j))\n         ((eq? j 0) (string-ref string i))\n         ((eq? (string-ref\
    \ string i) (string-ref string j)) (loop (sub1 i) (add1 j)))\n         (else (string-ref\
    \ string j)))))))\n", "  (define a (string->list string))\n  (define (find-palindrome\
    \ a b)\n    (define s (string->list (list->string (reverse a))))\n    (cond\n\
    \      [(empty? a) empty]\n      [(equal? a s) a]\n      [else (find-palindrome\
    \ (rest a) (rest b))]))\n  (let ([a (find-palindrome a a)])\n    (define s (string->list\
    \ (list->string (reverse (substring/shared (list->string string) 0 (sub1 (length\
    \ a)))))))\n    (string-append string s)))\n", "  (define s (string-append string\
    \ (reverse string)))\n  (define (suffix_palindrome s)\n    (let loop ([l (string-length\
    \ s)] [i (sub1 l)])\n      (if (= i 0)\n          (char-&gt;string (string-ref\
    \ s 0))\n          (if (char=? (string-ref s (- l i)) (string-ref s (- l (add1\
    \ i))))\n              (loop l (sub1 i))\n              (suffix_palindrome (substring\
    \ s 0 (- l (add1 i))))))))\n  (string-append string (reverse (suffix_palindrome\
    \ s))))\n", "  (define (find-palindrome-suffix string)\n    (define (recursor\
    \ string1 string2)\n      (cond\n        [(and (> (string-length string1) 0)\n\
    \              (> (string-length string2) 0)\n              (char=? (string-ref\
    \ string1 0) (string-ref string2 0)))\n         (recursor (substring string1 1)\
    \ (substring string2 1))]\n        [else (string-length string2)]))\n    (recursor\
    \ string (reverse string)))\n  (define (append-reverse-string string position)\n\
    \    (string-append string (reverse (substring string 0 position))))\n  (append-reverse-string\
    \ string (find-palindrome-suffix string)))\n```\n\n## [Problem 3](http://www.4clojure.com/problem/3)\n\
    ```\n#lang racket\n", "  (define (is_palindrome? string)\n    (define (aux i j)\n\
    \      (cond\n        [(>= i j) #t]\n        [(not (char=? (string-ref string\
    \ i) (string-ref string j))) #f]\n        [else (aux (+ i 1) (- j 1))]))\n   \
    \ (aux 0 (- (string-length string) 1)))\n  (define (find-palindrome string)\n\
    \    (let ([chars (string->list string)])\n      (let loop ([i 0])\n        (cond\n\
    \          [(>= i (string-length string)) (string-append (reverse chars) string)]\n\
    \          [(is_palindrome? (substring string i)) (substring string 0 i)]\n  \
    \        [else (loop (+ i 1))]))))\n  (find-palindrome string))\n", "  (define\
    \ reversed (reverse string))\n  (define substrings (map string-&gt;list (substrings\
    \ string)))\n  (let loop ((substrings substrings))\n    (cond ((null? substrings)\
    \ (error \"No palindromic substring.\"))\n          ((eq? (car substrings) (reverse\
    \ (car substrings)))\n           (string-append string (reverse (drop string (length\
    \ (car substrings))))))\n          (else (loop (cdr substrings))))))\n", "  (define\
    \ mid-string (first (string-split string (string-length string))))\n  (append\
    \ mid-string (string-reverse mid-string)))\n</code>\nRacket (longer version)\n\
    <code>#lang racket\n", "  (define (reverse string)\n    (let loop ((str string)\
    \ (rev '()))\n      (if (null? str)\n          rev\n          (loop (cdr str)\
    \ (cons (car str) rev)))))\n  (define (extract string from to)\n    (if (or (=\
    \ from 0) (= to (length string)))\n        string\n        (let ((from (- from\
    \ 1))\n              (to (+ to 1)))\n          (extract string from to))))\n \
    \ (define (suf-palindrome string)\n    (let loop ((j (- (length string) 1)) (i\
    \ 0))\n      (if (= i j)\n          (extract string i j)\n          (let ((suf\
    \ (extract string i j)))\n            (if (equal? suf (reverse suf))\n       \
    \         suf\n                (loop (- j 1) i))))))\n  (let* ((suf (suf-palindrome\
    \ string))\n         (i (string-index string suf)))\n    (if (= i 0)\n       \
    \ (string-append string (reverse string))\n        (string-append (reverse (extract\
    \ string 0 i)) string))))\n", "  (string-append string (reverse (substring string\
    \ 0 (find-palindrome-end string)))))\n", "  (define reversed-string (string-reverse\
    \ string))\n  (define postfix-length (find-longest-prefix string reversed-string))\n\
    \  (string-append string (substring reversed-string postfix-length)))\n", "  (define\
    \ (longest-palindrome string-reversed current-max-length)\n    (cond [(= (string-length\
    \ string-reversed) current-max-length)\n           current-max-length]\n     \
    \     [(string=? (string-take string-reversed\n                              \
    \    current-max-length)\n                     (string-take string\n         \
    \                         current-max-length))\n           (longest-palindrome\
    \ string-reversed (+ current-max-length 1))]\n          [else\n           (longest-palindrome\
    \ string-reversed 0)]))\n  (define (prepend-reverse-prefix string-reversed max-length)\n\
    \    (string-append (string-take string-reversed\n                           \
    \     (string-length string-reversed\n                                       \
    \        (- (string-length string-reversed)\n                                \
    \                  max-length)))\n                   string))\n  (prepend-reverse-prefix\
    \ (string-reverse string)\n                          (longest-palindrome (string-reverse\
    \ string) 0)))\n", "  (let* ([rev-string (string-reverse string)]\n         [rev-string-length\
    \ (string-length rev-string)]\n         [string-length (string-length string)]\n\
    \         [candidate-max-length (min rev-string-length string-length)]\n     \
    \    [candidate-length (add1 (- candidate-max-length))]\n         [is-palindrome?\
    \ (lambda (candidate)\n                           (string=? candidate (string-reverse\
    \ candidate)))]\n         [longest-palindrome (for/first ([candidate-length (in-range\
    \ candidate-max-length 1 -1)])\n                               (let ([candidate\
    \ (substring rev-string 0 candidate-length)])\n                              \
    \   (when (is-palindrome? candidate)\n                                   candidate)))])\n\
    \    (string-append string (string-reverse (substring string 0 (- string-length\
    \ (string-length longest-palindrome)))))))\n", "  (let* ((max-prefix-length (longest-palindromic-prefix\
    \ string))\n         (middle (substring string 0 max-prefix-length))\n       \
    \  (end (reverse middle)))\n    (string-append string end)))\n", "  (define (is_palindrome?\
    \ string)\n    (define (is_equal-to-reverse? string)\n      (equal? string (reverse\
    \ string)))\n    (or (is_equal-to-reverse? string)\n        (is_equal-to-reverse?\
    \ (substring string 1 (sub1 (string-length string))))))\n  (define (search-for-longest-palindrome-postfix\
    \ string)\n    (define (search-for-longest-palindrome-postfix-iter string-rev\
    \ index)\n      (if (is_palindrome? string-rev)\n          (string-length string-rev)\n\
    \          (search-for-longest-palindrome-postfix-iter (substring string-rev 1\
    \ (sub1 (string-length string-rev))) (add1 index))))\n    (let ([longest-palindrome-postfix-length\
    \ (search-for-longest-palindrome-postfix-iter (reverse string) 0)])\n      longest-palindrome-postfix-length))\n\
    \  (let ([longest-palindrome-postfix-length (search-for-longest-palindrome-postfix\
    \ string)])\n    (string-append (substring string 0 (sub1 longest-palindrome-postfix-length))\n\
    \                   (reverse (substring string 0 (sub1 longest-palindrome-postfix-length)))\n\
    \                   (substring string (sub1 longest-palindrome-postfix-length)))))",
  "  (define (longest-palindrome-postfix string)\n    (let loop ((offset 0) (length\
    \ 0))\n      (if (&lt;= offset (sub1 (string-length string)))\n          (if (string=?\
    \ (substring string 0 (+ length offset))\n                        (reverse (substring\
    \ string offset (+ length offset))))\n              (loop (+ offset 1) (+ length\
    \ 1))\n              (substring string (+ offset 1) (+ length 1)))\n         \
    \ (substring string 0 length))))\n  (string-append string (reverse (string-before\
    \ string (string-length (longest-palindrome-postfix string))))))\n</code>\nAnother\
    \ version that returns the sequence of strings that transform the string into\
    \ the shortest palindrome, if this is desired.\n<code>#lang racket\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
