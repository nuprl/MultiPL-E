name: HumanEval_30_get_positive
language: rkt
prompt: "#lang racket\n\n;; Return only positive numbers in the list.\n(define (get_positive\
  \ l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n\
  \    (check-equal? (candidate (list -1 -2 4 5 6)) (list 4 5 6))\n    (check-equal?\
  \ (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1))\n    (check-equal?\
  \ (candidate (list -1 -2)) (list ))\n    (check-equal? (candidate (list )) (list\
  \ ))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? l) empty]\n        [(positive? (first l)) (cons (first\
    \ l) (get_positive (rest l)))]\n        [else (get_positive (rest l))]))\n", " \
    \   (filter positive? l))\n", "  (filter positive? l))\n", "  (filter positive?\
    \ l))\n", "  (filter positive? l))\n</code>\nBut for some reason it does not work.\
    \ I have tried many things but I am not able to get the output that I want.\n\n\
    \nA:\n\nYou have to provide an additional argument to <code>run-test</code>, a\
    \ procedure that takes a single argument, which should be your test case.\nThis\
    \ example is using <code>check-=</code> as the test case (your test case is <code>filter</code>):\n\
    <code>(run-test\n  [equal? (get_positive (list 1 2 3 4 5 -1 -2 -3 -4 -5))\n  \
    \        (list 1 2 3 4 5)]\n  check-=)\n</code>\n", "  (cond\n    [(empty? l)\
    \ empty]\n    [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n\
    \    [else (get_positive (rest l))]))\n", "  (filter positive? l))\n", "  (filter\
    \ positive? l))\n", "  (cond ((null? l) '())\n        ((< (car l) 0) (get_positive\
    \ (cdr l)))\n        (else (cons (car l) (get_positive (cdr l))))))\n", "  (cond\n\
    \    ((null? l) '())\n    ((> (car l) 0) (cons (car l) (get_positive (cdr l))))\n\
    \    (else (get_positive (cdr l)))))\n", "  (filter positive? l))\n", "  (filter\
    \ positive? l))\n", "  (filter positive? l))\n", "  (filter (lambda (x) (&gt;\
    \ x 0)) l))\n", "  (map (lambda (x)\n         (if (positive? x)\n            \
    \ x\n             0))\n       l))\n</code>\nNow I'm trying to test this function\
    \ and I'm trying to do it properly with Racket's <code>check-expect</code>. My\
    \ problem is that I cannot get it to work properly. When I run\n<code>(check-expect\
    \ (get_positive '(1 2 3 4)) '(1 2 3 4))\n</code>\nit does not pass the test. This\
    \ is how the result looks like:\n<code>'(1 2 3 4)\n  Check failed: expected: '(1\
    \ 2 3 4)\n  actual: '(1 2 3 4)\n  expression: (get_positive '(1 2 3 4))\n</code>\n\
    I guess it is because of the zero in the <code>if</code> statement. Is there a\
    \ way to get this to work or am I just doing it the wrong way?\n\n\nA:\n\nYour\
    \ problem is that the <code>#true</code> cases in your function do not return\
    \ <code>x</code> but <code>(values x)</code>, which is a singleton list. Thus,\
    \ you need to <code>flatten</code> the output of <code>get_positive</code> before\
    \ testing it.\n<code>(check-expect (flatten (get_positive '(1 2 3 4))) '(1 2 3\
    \ 4))\n</code>\n", "  (cond [(empty? l) empty]\n        [(> (first l) 0) (cons\
    \ (first l) (get_positive (rest l)))]\n        [else (get_positive (rest l))]))\n",
  "  (filter positive? l))\n", "  (filter positive? l))\n", "  (define (pos? n)\n\
    \    (if (< n 0)\n        #f\n        #t))\n  (filter pos? l))\n", "  (filter\
    \ positive? l))\n", "  (cond ((null? l) '())\n        ((&gt; (car l) 0) (cons\
    \ (car l) (get_positive (cdr l))))\n        (else (get_positive (cdr l)))))\n",
  "  (filter positive? l))\n", "  (filter positive? l))\n", "  (cond\n    [(empty?\
    \ l) empty]\n    [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n\
    \    [else (get_positive (rest l))]))\n", "  (cond ((null? l) '())\n        ((&gt;\
    \ (car l) 0) (cons (car l) (get_positive (cdr l))))\n        (else (get_positive\
    \ (cdr l)))))\n", "  (filter positive? l))\n", "  (cond\n    [(empty? l) empty]\n\
    \    [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n    [else\
    \ (get_positive (rest l))]))\n", "  (cond\n    [(null? l) '()]\n    [(positive?\
    \ (car l)) (cons (car l) (get_positive (cdr l)))]\n    [else (get_positive (cdr\
    \ l))]))\n", "  (cond\n    [(empty? l) empty]\n    [(> (first l) 0) (cons (first\
    \ l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n", "  (filter\
    \ positive? l))\n", "  (filter positive? l))\n", "  (filter positive? l))\n",
  "  (filter (lambda (x)\n            (if (&gt; x 0)\n                #t\n       \
    \         #f))\n          l))\n", "  (filter positive? l))\n", "  (filter positive?\
    \ l))\n", "  (filter positive? l))\n", "  (cond\n    [(empty? l) empty]\n    [(positive?\
    \ (first l)) (cons (first l) (get_positive (rest l)))]\n    [else (get_positive\
    \ (rest l))]))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (cond\n    [(null?\
    \ l) '()]\n    [(negative? (car l)) (get_positive (cdr l))]\n    [else (cons (car\
    \ l) (get_positive (cdr l)))]))\n", "  (cond [(empty? l) empty]\n        [(> (first\
    \ l) 0) (cons (first l) (get_positive (rest l)))]\n        [else (get_positive\
    \ (rest l))]))\n", "  (filter positive? l))\n", "  (filter positive? l))\n", " \
    \ (cond\n    [(empty? l) empty]\n    [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n    [else (get_positive (rest l))]))\n", "  (cond\n    [(null?\
    \ l)\n     '()]\n    [(positive? (car l))\n     (cons (car l) (get_positive (cdr\
    \ l)))]\n    [else\n     (get_positive (cdr l))]))\n", "  (cond\n    [(empty?\
    \ l) empty]\n    [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n\
    \    [else (get_positive (rest l))]))\n", "  (cond [(empty? l) empty]\n      \
    \  [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n        [else\
    \ (get_positive (rest l))]))\n", "  (cond [(empty? l) empty]\n        [(> (first\
    \ l) 0) (cons (first l) (get_positive (rest l)))]\n        [else (get_positive\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) empty]\n    [(>= (first l) 0) (cons\
    \ (first l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n",
  "  (filter positive? l))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (cond\n\
    \    ((null? l) '())\n    ((> (car l) 0) (cons (car l) (get_positive (cdr l))))\n\
    \    (else (get_positive (cdr l)))))\n", "  (for/list ([i l]\n             #:when\
    \ (positive? i))\n    i))\n", "  (cond\n    [(null? l) empty]\n    [(positive?\
    \ (car l)) (cons (car l) (get_positive (cdr l)))]\n    [else (get_positive (cdr\
    \ l))]))\n", "  (cond ((null? l) '())\n        ((positive? (car l)) (cons (car\
    \ l) (get_positive (cdr l))))\n        (else (get_positive (cdr l)))))\n", " \
    \ (filter (lambda (n) (&gt; n 0)) l))\n", "  (filter positive? l))\n", "  (filter\
    \ positive? l))\n", "  (cond\n    ((empty? l) empty)\n    ((> (first l) 0) (cons\
    \ (first l) (get_positive (rest l))))\n    (else (get_positive (rest l)))))\n",
  "  (cond\n    [(empty? l) '()]\n    [(> (first l) 0) (cons (first l) (get_positive\
    \ (rest l)))]\n    [else (get_positive (rest l))]))\n", "  (filter (lambda (x)\n\
    \            (&gt; x 0))\n          l))\n", "  (filter positive? l))\n", "  (filter\
    \ positive? l))\n", "  (if (null? l)\n      '()\n      (if (> (car l) 0)\n   \
    \       (cons (car l) (get_positive (cdr l)))\n          (get_positive (cdr l)))))\n\
    ```\n\n```scheme", "  (if (null? l) '()\n      (if (positive? (car l))\n     \
    \     (cons (car l) (get_positive (cdr l)))\n          (get_positive (cdr l)))))\n\
    </code>\nTests:\n<code>'(2 -1 5 -4 7 -9)\n&gt; '(2 5 7)\n\n'()\n&gt; '()\n\n'(1\
    \ 2 3 4 5)\n&gt; '(1 2 3 4 5)\n\n'(-1 -2 -3 -4 -5)\n&gt; '()\n</code>\n", "  (cond\n\
    \    [(empty? l) '()]\n    [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n    [else (get_positive (rest l))]))\n", "  (cond [(empty? l) empty]\n\
    \        [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n  \
    \      [else (get_positive (rest l))]))\n", "  (cond\n    [(empty? l) empty]\n\
    \    [(> (first l) 0) (cons (first l) (get_positive (rest l)))]\n    [else (get_positive\
    \ (rest l))]))\n", "  (cond [(empty? l) empty]\n        [(positive? (first l))\
    \ (cons (first l) (get_positive (rest l)))]\n        [else (get_positive (rest\
    \ l))]))\n", "  (cond [(empty? l) empty]\n        [(&gt; (first l) 0) (cons (first\
    \ l) (get_positive (rest l)))]\n        [else (get_positive (rest l))]))\n", " \
    \ (cond\n    [(empty? l) empty]\n    [(and (positive? (first l)) (not (empty?\
    \ (rest l))))\n     (cons (first l) (get_positive (rest l)))]\n    [(positive?\
    \ (first l)) (cons (first l) empty)]\n    [else (get_positive (rest l))]))\n",
  "  (filter positive? l))\n", "  (cond ((null? l) '())\n        ((> (car l) 0) (cons\
    \ (car l) (get_positive (cdr l))))\n        (else (get_positive (cdr l)))))\n",
  "  (filter positive? l))\n", "    (filter positive? l))\n</code>\nThe above is easy\
    \ to write with iteration. I'm looking for the functional solution.\nSample input:\
    \ <code>(get_positive '(1 2 3 4 5 -1 -2 -3 -4 -5))</code>\nExpected output: <code>'(1\
    \ 2 3 4 5)</code>\n\n\nA:\n\n<code>(define (get_positive l)\n  (filter positive?\
    \ l))\n</code>\nIf you want to do it in a slightly more functional way you could\
    \ use <code>foldl</code> and <code>cons</code> to build up the list:\n<code>(define\
    \ (get_positive l)\n  (foldl (lambda (elem acc)\n           (if (positive? elem)\n\
    \               (cons elem acc)\n               acc))\n         '()\n        \
    \ l))\n</code>\nOr <code>foldr</code> and <code>cons</code> to build up the list\
    \ in reverse order:\n<code>(define (get_positive l)\n  (foldr (lambda (elem acc)\n\
    \           (if (positive? elem)\n               (cons elem acc)\n           \
    \    acc))\n         '()\n         l))\n</code>\nIf you want to be even more functional\
    \ you could use <code>map</code> and <code>filter</code> to transform the list\
    \ to a list of booleans and remove the <code>false</code> values:\n<code>(define\
    \ (get_positive l)\n  (remove false?\n          (map positive?\n             \
    \  l)))\n</code>\n", "  (cond\n    [(empty? l) empty]\n    [(positive? (first\
    \ l)) (cons (first l) (get_positive (rest l)))]\n    [else (get_positive (rest\
    \ l))]))\n", "  (cond [(empty? l) empty]\n        [(positive? (first l)) (cons\
    \ (first l) (get_positive (rest l)))]\n        [else (get_positive (rest l))]))\n",
  "  (cond [(empty? l) empty]\n        [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n        [else (get_positive (rest l))]))\n", "    (cond ((null?\
    \ l) '())\n          ((&gt; (car l) 0) (cons (car l) (get_positive (cdr l))))\n\
    \          (else (get_positive (cdr l)))))\n", "  (cond ((null? l) '())\n    \
    \    ((< (car l) 0) (get_positive (cdr l)))\n        (else (cons (car l) (get_positive\
    \ (cdr l))))))\n", "  (if (null? l)\n      '()\n      (if (&gt; (car l) 0)\n \
    \         (cons (car l) (get_positive (cdr l)))\n          (get_positive (cdr\
    \ l)))))\n", "  (filter positive? l))\n", "  (cond\n    [(empty? l) empty]\n \
    \   [(>= (first l) 0) (cons (first l) (get_positive (rest l)))]\n    [else (get_positive\
    \ (rest l))]))\n", "  (filter positive? l))\n", "  (if (empty? l)\n      empty\n\
    \      (if (&gt; (first l) 0)\n          (cons (first l) (get_positive (rest l)))\n\
    \          (get_positive (rest l)))))\n", "    (cond\n        [(empty? l) empty]\n\
    \        [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n  \
    \      [else (get_positive (rest l))]))\n</code>\nThis seems like a lot of work\
    \ and a lot of wasted space. I know that I can use a filter function, but I want\
    \ to know if it is possible to do it in a single pass of the list, I would like\
    \ to avoid maintaining a second list.\n\n\nA:\n\nIt's not necessary to build a\
    \ new list to filter a list. You can instead use a \"list accumulator\" to process\
    \ the list, like this:\n<code>(define (get-positive lst)\n  (define (get-positive\
    \ lst acc)\n    (cond ((null? lst)       (reverse acc))\n          ((positive?\
    \ (car lst)) (get-positive (cdr lst) (cons (car lst) acc)))\n          (else \
    \              (get-positive (cdr lst) acc))))\n  (get-positive lst '()))\n</code>\n\
    This is known as the <code>filter</code> procedure in <code>Racket</code> and\
    \ <code>SRFI-1</code>.\n", "  (filter positive? l))\n", "  (cond [(empty? l) '()]\n\
    \        [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n  \
    \      [else (get_positive (rest l))]))\n", "  (if (empty? l)\n      (list)\n\
    \      (if (not (positive? (first l)))\n          (get_positive (rest l))\n  \
    \        (cons (first l) (get_positive (rest l))))))\n", "  (let ([n (length l)])\n\
    \    (for/list ([i (in-range n)])\n      (if (positive? (list-ref l i))\n    \
    \    (list-ref l i)))))\n", "  (cond [(empty? l) empty]\n        [(> (first l)\
    \ 0) (cons (first l) (get_positive (rest l)))]\n        [else (get_positive (rest\
    \ l))]))\n```\n\n```racket\n#lang racket\n", "  (filter positive? l))\n</code>\n\
    And I am having trouble figuring out how to do this in Haskell.\nThe closest I\
    \ can get is \n<code>get_positive :: (Ord a, Num a) =&gt; [a] -&gt; [a]\nget_positive\
    \ = filter (&gt; 0)\n</code>\nBut I do not know how to filter negative numbers\
    \ when the numbers are arbitrary.\n\n\nA:\n\nThe <code>filter</code> function\
    \ already takes a function as its argument, so you can use any function you want.\
    \ If you want to use <code>positive?</code>, you can define it as\n<code>positive\
    \ :: (Ord a, Num a) =&gt; a -&gt; Bool\npositive n = n &gt; 0\n</code>\nand then\
    \ say\n<code>get_positive :: (Ord a, Num a) =&gt; [a] -&gt; [a]\nget_positive\
    \ = filter positive\n</code>\n", "  (filter positive? l))\n", "  (filter positive?\
    \ l))\n", "  (filter positive? l))\n", "  (cond\n    [(empty? l) '()]\n    [(>\
    \ (first l) 0) (cons (first l) (get_positive (rest l)))]\n    [else (get_positive\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) empty]\n    [(negative? (first l))\
    \ (get_positive (rest l))]\n    [else (cons (first l) (get_positive (rest l)))]))\n",
  "  (filter positive? l))\n", "  (filter (lambda (n) (&gt; n 0)) l))\n", "  (cond\n\
    \    [(empty? l) empty]\n    [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n    [else (get_positive (rest l))]))\n", "  (cond\n    [(empty?\
    \ l) empty]\n    [(> (first l) 0) (cons (first l) (get_positive (rest l)))]\n\
    \    [else (get_positive (rest l))]))\n</code>\nI wonder how would I do this in\
    \ a functional programming style, that is, without any mutation?\n\n\nA:\n\nThe\
    \ use of <code>cond</code> is fine.\nYou can simplify it a bit by replacing the\
    \ <code>if</code> clause with a boolean predicate:\n<code>(define (get_positive\
    \ l)\n  (cond\n    [(empty? l) empty]\n    [(positive? (first l)) (cons (first\
    \ l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n</code>\n\
    This is clearer, and it's more flexible, because your program is now more general;\
    \ you can use <code>get_positive</code> to filter out items that satisfy any predicate,\
    \ not just positive numbers.\n\nThe use of <code>cond</code> is not particularly\
    \ functional. We can do better by using higher-order functions:\n<code>(define\
    \ (get_positive l)\n  (filter positive? l))\n</code>\n<code>filter</code> takes\
    \ a predicate and a list, and returns a list that contains all of the items in\
    \ the original list that satisfy the predicate.\nWe can do even better. It's simpler\
    \ to filter out the negatives and reverse the result:\n<code>(define (get_positive\
    \ l)\n  (reverse (filter (compose not positive?) l)))\n</code>\n<code>compose</code>\
    \ takes two functions and returns a new function. It applies the function on the\
    \ right to the function on the left, resulting in a third function that we can\
    \ pass to <code>filter</code>.\n", "  (filter positive? l))\n", "  (filter positive?\
    \ l))\n</code>\nThere are some variations, such as <code>keep</code> which takes\
    \ a procedure and a collection, and returns a list with only those elements that\
    \ return true when the procedure is applied to them.\n<code>#lang racket\n", " \
    \ (cond ((null? l) '())\n        ((&gt; (car l) 0) (cons (car l) (get_positive\
    \ (cdr l))))\n        (else (get_positive (cdr l)))))\n", "  (cond [(empty? l)\
    \ empty]\n        [(and (positive? (first l))\n              (get_positive (rest\
    \ l)))\n         (cons (first l)\n               (get_positive (rest l)))]\n \
    \       [else (get_positive (rest l))]))\n", "  (filter positive? l))\n", "  (cond\
    \ [(empty? l) empty]\n        [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n        [else (get_positive (rest l))]))\n", "  (filter positive?\
    \ l))\n", "  (cond\n    [(empty? l) empty]\n    [(positive? (first l)) (cons (first\
    \ l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n", "  (filter\
    \ (lambda (x) (> x 0)) l))\n", "  (filter positive? l))\n", "  (for/list ([i l]\
    \ #:when (> i 0))\n    i))\n```\n\n```racket\n#lang racket\n", "  (filter positive?\
    \ l))\n", "  (cond\n    [(null? l) empty]\n    [(positive? (car l)) (cons (car\
    \ l) (get_positive (cdr l)))]\n    [else (get_positive (cdr l))]))\n", "  (filter\
    \ positive? l))\n", "  (filter positive? l))\n", "  (define (iter l acc)\n   \
    \ (if (null? l)\n        acc\n        (if (&gt; (car l) 0)\n            (iter\
    \ (cdr l) (cons (car l) acc))\n            (iter (cdr l) acc))))\n  (reverse (iter\
    \ l '())))\n", "  (filter positive? l))\n</code>\n", "  (filter positive? l))\n",
  "  (cond\n    [(null? l) '()]\n    [(positive? (car l)) (cons (car l) (get_positive\
    \ (cdr l)))]\n    [else (get_positive (cdr l))]))\n", "  (cond [(empty? l) empty]\n\
    \        [(> (first l) 0) (cons (first l) (get_positive (rest l)))]\n        [else\
    \ (get_positive (rest l))]))\n", "  (cond [(empty? l) empty]\n        [(positive?\
    \ (first l)) (cons (first l) (get_positive (rest l)))]\n        [else (get_positive\
    \ (rest l))]))\n", "  (match l\n    ['() '()]\n    [(cons (? (and number? (x)\
    \ (< x 0))) y) (get_positive y)]\n    [(cons x y) (cons x (get_positive y))]))\n",
  "  (filter positive? l))\n", "  (filter positive? l))\n", "  (filter (lambda (n)\
    \ (> n 0)) l))\n", "  (filter number? l))\n", "  (filter (lambda (x) (&gt; x 0))\
    \ l))\n", "  (filter positive? l))\n", "  (cond ((null? l) '())\n        ((> (car\
    \ l) 0) (cons (car l) (get_positive (cdr l))))\n        (else (get_positive (cdr\
    \ l)))))\n", "  (filter positive? l))\n", "  (cond\n    [(null? l) '()]\n    [(positive?\
    \ (car l)) (cons (car l) (get_positive (cdr l)))]\n    [else (get_positive (cdr\
    \ l))]))\n</code>\n", "    (filter positive? l))\n", "  (cond\n    [(empty? l)\
    \ empty]\n    [(> (first l) 0) (append (list (first l)) (get_positive (rest l)))]\n\
    \    [else (get_positive (rest l))]))\n", "    (cond ((null? l) '())\n       \
    \   ((&gt; (car l) 0) (cons (car l) (get_positive (cdr l))))\n          (else\
    \ (get_positive (cdr l)))))\n", "  (for/list ([x l] #:when (positive? x))\n  \
    \  x))\n", "  (filter (lambda (n) (&gt; n 0)) l))\n", "  (filter positive? l))\n",
  "  (filter positive? l))\n", "  (cond\n    [(null? l) '()]\n    [(positive? (car\
    \ l)) (cons (car l) (get_positive (cdr l)))]\n    [else (get_positive (cdr l))]))\n",
  "  (cond [(empty? l) empty]\n        [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n        [else (get_positive (rest l))]))\n", "  (filter positive?\
    \ l))\n", "  (if (null? l) '()\n      (if (&gt; (car l) 0)\n          (cons (car\
    \ l) (get_positive (cdr l)))\n          (get_positive (cdr l)))))\n", "  (filter\
    \ positive? l))\n", "  (filter positive? l))\n", "    (cond [(null? l) '()]\n\
    \          [(> (car l) 0) (cons (car l) (get_positive (cdr l)))]\n          [else\
    \ (get_positive (cdr l))]))\n```\n\n### What is the output of the following expression?\n\
    \n```Racket", "  (cond\n    ((null? l) '())\n    ((positive? (car l)) (cons (car\
    \ l) (get_positive (cdr l))))\n    (else (get_positive (cdr l)))))\n</code>\n\
    And the following test code:\n<code>#lang racket\n", "  (filter positive? l))\n",
  "  (define (get_positive_aux l acc)\n    (cond\n      [(empty? l) acc]\n      [(>\
    \ (first l) 0) (get_positive_aux (rest l) (cons (first l) acc))]\n      [else\
    \ (get_positive_aux (rest l) acc)]))\n  (reverse (get_positive_aux l '())))\n",
  "  (cond [(empty? l) empty]\n        [(zero? (first l)) (get_positive (rest l))]\n\
    \        [else (cons (first l) (get_positive (rest l)))]))\n", "  (filter positive?\
    \ l))\n", "  (filter positive? l))\n</code>\nRacket doesn't have a <code>filter</code>\
    \ function to filter out the negative numbers, so I wrote my own.  I'm used to\
    \ doing this in languages like Python, but here I have to specify the recursive\
    \ case.\n<code>#lang racket\n", "  (filter positive? l))\n", "  (filter positive?\
    \ l))\n", "  (cond [(empty? l) empty]\n        [(positive? (first l)) (cons (first\
    \ l) (get_positive (rest l)))]\n        [else (get_positive (rest l))]))\n", " \
    \ (filter positive? l))\n", "  (filter positive? l))\n", "  (cond\n    [(empty?\
    \ l) empty]\n    [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n\
    \    [else (get_positive (rest l))]))\n</code>\nIs there any way to make this\
    \ function tail-recursive so that I don't have to build up this big cons cell\
    \ in memory?\n\n\nA:\n\nHere's a possible implementation:\n<code>(define (get-positive\
    \ l)\n  (let loop ([acc '()] [lst l])\n    (cond [(empty? lst) (reverse acc)]\n\
    \          [(positive? (first lst)) (loop (cons (first lst) acc) (rest lst))]\n\
    \          [else (loop acc (rest lst))])))\n</code>\nAlso take a look at the built-in\
    \ functions <code>remove</code> and <code>remove*</code>, and the higher-order\
    \ functions <code>filter</code> and <code>for/list</code>.\n", "  (filter positive?\
    \ l))\n", "  (cond\n    [(empty? l) empty]\n    [(positive? (first l)) (cons (first\
    \ l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n", "  (cond\
    \ [(empty? l) empty]\n        [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n        [else (get_positive (rest l))]))\n", "  (cond\n    [(null?\
    \ l) '()]\n    [(positive? (car l)) (cons (car l) (get_positive (cdr l)))]\n \
    \   [else (get_positive (cdr l))]))\n</code>\nWithout using filter, this is what\
    \ I have currently:\n<code>#lang racket\n", "  (cond\n    [(empty? l) empty]\n\
    \    [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n    [else\
    \ (get_positive (rest l))]))\n</code>\nHere is a better way to write the above\
    \ code.\n<code>#lang racket\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter\
    \ (lambda (x) (> x 0)) l))\n", "    (cond\n        [(empty? l) empty]\n      \
    \  [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n        [else\
    \ (get_positive (rest l))]))\n", "  (cond [(empty? l) empty]\n        [(not (positive?\
    \ (first l))) (get_positive (rest l))]\n        [else (cons (first l) (get_positive\
    \ (rest l)))]))\n", "  (cond\n    [(empty? l) empty]\n    [(> (first l) 0) (cons\
    \ (first l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n",
  "  (cond\n    [(null? l) '()]\n    [(positive? (car l)) (cons (car l) (get_positive\
    \ (cdr l)))]\n    [else (get_positive (cdr l))]))\n", "  (cond [(empty? l) empty]\n\
    \        [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n  \
    \      [else (get_positive (rest l))]))\n", "  (cond\n    [(empty? l) empty]\n\
    \    [(> (first l) 0) (cons (first l) (get_positive (rest l)))]\n    [else (get_positive\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) empty]\n    [(> (first l) 0) (cons\
    \ (first l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n",
  "  (cond\n    ((empty? l) empty)\n    ((positive? (first l)) (cons (first l) (get_positive\
    \ (rest l))))\n    (else (get_positive (rest l)))))\n", "  (cond\n    [(null?\
    \ l) '()]\n    [(positive? (car l)) (cons (car l) (get_positive (cdr l)))]\n \
    \   [else (get_positive (cdr l))]))\n</code>\nBut I want to do this without the\
    \ <code>cond</code> function. My first attempt was this:\n<code>#lang racket\n",
  "  (filter positive? l))\n", "  (filter positive? l))\n", "  (if (empty? l)\n  \
    \    '()\n      (if (positive? (first l))\n          (cons (first l) (get_positive\
    \ (rest l)))\n          (get_positive (rest l)))))\n", "  (cond\n    [(null? l)\
    \ '()]\n    [(positive? (car l)) (cons (car l) (get_positive (cdr l)))]\n    [else\
    \ (get_positive (cdr l))]))\n", "  (filter positive? l))\n", "  (cond\n    [(empty?\
    \ l) empty]\n    [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n\
    \    [else (get_positive (rest l))]))\n", "  (cond ((null? l) '())\n        ((>\
    \ (car l) 0) (cons (car l) (get_positive (cdr l))))\n        (else (get_positive\
    \ (cdr l)))))\n", "  (cond\n    [(empty? l) empty]\n    [(> (first l) 0) (cons\
    \ (first l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n",
  "  (define (get_positive_helper l)\n    (cond\n      [(empty? l) empty]\n      [(positive?\
    \ (first l)) (cons (first l) (get_positive_helper (rest l)))]\n      [else (get_positive_helper\
    \ (rest l))]))\n  (get_positive_helper l))\n", "  (cond\n    [(null? l) '()]\n\
    \    [(<= (car l) 0) (get_positive (cdr l))]\n    [else (cons (car l) (get_positive\
    \ (cdr l)))]))\n", "  (filter (lambda (n) (&gt; n 0)) l))\n", "  (cond [(empty?\
    \ l) empty]\n        [(> (first l) 0) (cons (first l) (get_positive (rest l)))]\n\
    \        [else (get_positive (rest l))]))\n", "  (filter positive? l))\n", " \
    \ (filter positive? l))\n</code>\nHowever, when I try to run it, I get an error.\
    \  I've tried various different things, but I'm not sure how to fix it.\nThanks!\n\
    \n\nA:\n\nYou should use <code>require</code> instead of <code>load</code>. Also,\
    \ be careful with the module name: it's <code>racket/list</code>, not <code>racket/rcx</code>.\n\
    <code>(require racket/list)\n", "    (cond [(null? l)\n           '()]\n     \
    \     [(> (car l) 0)\n           (cons (car l) (get_positive (cdr l)))]\n    \
    \      [else\n           (get_positive (cdr l))]))\n", "  (filter positive? l))\n",
  "  (cond ((null? l) '())\n        ((< (car l) 0) (get_positive (cdr l)))\n     \
    \   (else (cons (car l) (get_positive (cdr l))))))\n", "  (filter positive? l))\n",
  "  (if (null? l)\n      '()\n      (if (&gt; (car l) 0)\n          (cons (car l)\
    \ (get_positive (cdr l)))\n          (get_positive (cdr l)))))\n", "  (filter\
    \ positive? l))\n", "  (cond ((null? l) '())\n        ((&gt; (car l) 0) (cons\
    \ (car l) (get_positive (cdr l))))\n        (else (get_positive (cdr l)))))\n",
  "  (filter positive? l))\n", "  (cond [(empty? l) empty]\n        [(> (first l)\
    \ 0) (cons (first l) (get_positive (rest l)))]\n        [else (get_positive (rest\
    \ l))]))\n", "  (cond [(empty? l) empty]\n        [(positive? (first l)) (cons\
    \ (first l) (get_positive (rest l)))]\n        [else (get_positive (rest l))]))\n",
  "  (cond\n    [(empty? l) '()]\n    [(and\n      (positive? (first l))\n      (not\
    \ (negative? (first l))))\n     (cons (first l) (get_positive (rest l)))]\n  \
    \  [else (get_positive (rest l))]))\n", "    (match l\n        [(cons h t)\n \
    \           (if (positive? h)\n                (cons h (get_positive t))\n   \
    \             (get_positive t))]\n        [(list) (list)]))\n", "  (cond [(empty?\
    \ l) empty]\n        [(positive? (first l)) (cons (first l) (get_positive (rest\
    \ l)))]\n        [else (get_positive (rest l))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
