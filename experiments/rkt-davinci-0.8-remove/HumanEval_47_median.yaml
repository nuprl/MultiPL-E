name: HumanEval_47_median
language: rkt
prompt: "#lang racket\n\n;; Return median of elements in the list l.\n(define (median\
  \ l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate median))\n\
  \    (check-equal? (candidate (list 3 1 2 4 5)) 3)\n    (check-equal? (candidate\
  \ (list -10 4 6 1000 10 20)) 8.0)\n    (check-equal? (candidate (list 5)) 5)\n \
  \   (check-equal? (candidate (list 6 5)) 5.5)\n    (check-equal? (candidate (list\
  \ 8 1 3 9 9 2 7)) 7)\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? l) #f]\n        [(empty? (rest l)) (first l)]\n  \
    \      [(empty? (rest (rest l))) (median (list (first l) (second l)))]\n     \
    \   [else\n         (define n (ceiling (/ (length l) 2)))\n         (median (remove\
    \ (nth l n) l))]))\n", "  (let ([len (length l)])\n    (if (= len 0)\n       \
    \ '()\n        (sort l #:key cadr &lt;=?)\n        (if (even? len)\n         \
    \   (quotient (cadr (nth l (/ len 2))) 2)\n            (cadr (nth l (/ len 2)))))))\n\
    </code>\nNow I use <code>median</code> in the following function:\n<code>#lang\
    \ racket\n", "  (let ([sorted (sort l &lt;=)])\n    (cond\n      [(empty? l) empty]\n\
    \      [(= (length l) 1) (first l)]\n      [(= (remainder (length l) 2) 0)\n \
    \      (/ (+ (list-ref sorted (/ (length l) 2))\n             (list-ref sorted\
    \ (- (/ (length l) 2) 1)))\n          2)]\n      [else (list-ref sorted (/ (length\
    \ l) 2))])))\n</code>\n", "  (cond [(empty? l) (error \"empty list\")]\n     \
    \   [(even? (length l))\n         (/ (+ (list-ref l (/ (length l) 2))\n      \
    \         (list-ref l (- (/ (length l) 2) 1)))\n            2)]\n        [else\
    \ (list-ref l (/ (length l) 2))]))\n", "  (define (median-iter l n)\n    (cond\
    \ [(empty? l) #f]\n          [(zero? n) (car l)]\n          [(even? n) (median-iter\
    \ (rest l) (- n 1))]\n          [else (median-iter (rest l) (- n 2))]))\n  (median-iter\
    \ l (length l)))\n", "  (define l-sorted (sort < l))\n  (define len (length l-sorted))\n\
    \  (define mid (/ len 2))\n  (if (odd? len)\n      (list-ref l-sorted mid)\n \
    \     (/ (+ (list-ref l-sorted mid) (list-ref l-sorted (- mid 1))) 2.0)))\n",
  "  (define (compare-first x y)\n    (< (car x) (car y)))\n  (define (sort-by-first\
    \ l)\n    (sort l compare-first))\n  (define (pop-middle l)\n    (if (even? (length\
    \ l))\n        (cdr (cdr l))\n        (cdr l)))\n  (define (list-to-list l)\n\
    \    (if (null? l)\n        '()\n        (cons (list (car l)) (list-to-list (cdr\
    \ l)))))\n  (define (list-to-list-2 l)\n    (if (null? l)\n        '()\n     \
    \   (cons (car l) (list-to-list-2 (cdr l)))))\n  (define (remove-first-element\
    \ l)\n    (if (null? l)\n        '()\n        (cdr l)))\n  (define (median-recursive-1\
    \ l)\n    (if (null? l)\n        '()\n        (list (list (car l) (list-ref (list-to-list\
    \ (sort-by-first (remove-first-element l))) (quotient (length (remove-first-element\
    \ l)) 2))))))\n  (define (median-recursive-2 l)\n    (if (null? l)\n        '()\n\
    \        (cons (car l) (median-recursive-2 (cdr l)))))\n  (define (median-recursive-3\
    \ l)\n    (if (null? l)\n        '()\n        (cons (list-ref (median-recursive-2\
    \ l) (quotient (length l) 2)) (median-recursive-3 (cdr l)))))\n  (define (median-recursive-4\
    \ l)\n    (if (null? l)\n        '()\n        (cons (median-recursive-3 l) (median-recursive-4\
    \ (cdr l)))))\n  (median-recursive-4 (median-recursive-1 l)))", "  (cond [(null?\
    \ l) (error \"median of empty list not defined\")]\n        [(empty? (rest l))\
    \ (first l)]\n        [else (let ([len (length l)])\n                (if (odd?\
    \ len)\n                    (nth (quotient len 2) (sort l <))\n              \
    \      (let* ([a (nth (quotient len 2) (sort l <))]\n                        \
    \   [b (nth (- (quotient len 2) 1) (sort l <))])\n                      (/ (+\
    \ a b) 2.0))))]))\n", "  (define n (length l))\n  (if (odd? n)\n      (list-ref\
    \ l (quotient n 2))\n      (quotient (+ (list-ref l (/ n 2)) (list-ref l (/ n\
    \ 2))) 2)))\n", "  (sort l\n        (lambda (a b)\n          (&lt; a b))))\n</code>\n\
    But when I try to use the following function:\n<code>#lang racket\n", "  (let-values\
    \ (((lmin lmax) (extremes l)))\n    (cond\n      [(empty? l) #f]\n      [(empty?\
    \ (rest l)) (first l)]\n      [(< (length l) 3) (in-range lmin lmax)]\n      [else\
    \ (in-range lmin lmax)])))\n", "  (define (ordered-merge ls1 ls2)\n    (cond ((null?\
    \ ls1) ls2)\n          ((null? ls2) ls1)\n          ((< (car ls1) (car ls2))\n\
    \           (cons (car ls1) (ordered-merge (cdr ls1) ls2)))\n          (else\n\
    \           (cons (car ls2) (ordered-merge ls1 (cdr ls2))))))\n  (define (median-split\
    \ l)\n    (if (null? l)\n        (cons (list) (list))\n        (let* ((a (car\
    \ l))\n               (b (car (cdr l)))\n               (r (cdr (cdr l))))\n \
    \         (cons (list a) (list b)))))\n  (define (median-helper ll lr)\n    (if\
    \ (null? lr)\n        (if (null? (cdr ll))\n            (car ll)\n           \
    \ (car (cdr ll)))\n        (let* ((sp (median-split lr))\n               (spl\
    \ (car sp))\n               (spr (cdr sp)))\n          (median-helper (ordered-merge\
    \ ll spl) spr))))\n  (let* ((sp (median-split l))\n         (spl (car sp))\n \
    \        (spr (cdr sp)))\n    (median-helper spl spr)))\n", "  (sort l <)\n  (let*\
    \ ([median-i (quotient (length l) 2)]\n         [mid-vals (if (odd? (length l))\n\
    \                       (list (list-ref l median-i))\n                       (list\
    \ (list-ref l (- median-i 1))\n                             (list-ref l median-i)))])\n\
    \    (apply + mid-vals (/ 2))))\n", "  (if (null? l)\n      (error \"median: list\
    \ is empty\")\n      (sort l &lt;=)))\n</code>\n<code>#lang racket\n", "  (cond\n\
    \    [(empty? l) (error \"empty list\")]\n    [(equal? (length l) 1) (first l)]\n\
    \    [(equal? (length l) 2) (quotient (+ (first l) (second l)) 2)]\n    [else\n\
    \     (let*\n         ([l (quicksort l)]\n          [len (length l)]\n       \
    \   [midpoint (quotient len 2)])\n       (cond\n         [(odd? len) (list-ref\
    \ l midpoint)]\n         [else (+ (list-ref l midpoint) (list-ref l (- midpoint\
    \ 1)))]))]))\n", "  (sort l <)\n  (let ([n (length l)])\n    (let ([mid (quotient\
    \ n 2)])\n      (cond [(and (even? n) (= n 0))\n             (let ([m1 (nth l\
    \ mid)])\n               (let ([m2 (nth l (- mid 1))])\n                 (/ (+\
    \ m1 m2) 2)))]\n            [(and (odd? n) (= n 0))\n             (nth l mid)]\n\
    \            [else (error \"something else\")]))))\n", "  (define (sort l)\n \
    \   (sort l\n          <))\n  (define (length l)\n    (cond\n      [(empty? l)\
    \ 0]\n      [else (+ 1 (length (rest l)))]))\n  (define (median-helper l)\n  \
    \  (cond\n      [(empty? l) (void)]\n      [(= (length l) 1) (first l)]\n    \
    \  [(= (modulo (length l) 2) 0)\n       (/ (+ (list-ref l (/ (length l) 2))\n\
    \             (list-ref l (- (/ (length l) 2) 1)))\n          2)]\n      [else\
    \ (list-ref l (/ (length l) 2))]))\n  (median-helper (sort l)))\n", "  (let ((n\
    \ (length l)))\n    (if (= n 0)\n        0\n        (if (= n 1)\n            (car\
    \ l)\n            (if (= n 2)\n                (/ (+ (car l) (cadr l)) 2)\n  \
    \              (if (even? n)\n                    (/ (+ (car (sort l <)) (car\
    \ (sort l >))) 2)\n                    (car (sort l <))))))))\n", "  (define (length-l)\n\
    \    (if (null? l)\n        0\n        (+ 1 (length-l) (cdr l))))\n  (define (helper)\n\
    \    (cond\n      [(empty? l) '()]\n      [(length-l) 1]\n      [(length-l) 2]\n\
    \      [(length-l) 3]\n      [(length-l) 4]\n      [(length-l) 5]\n      [(length-l)\
    \ 6]\n      [(length-l) 7]\n      [(length-l) 8]\n      [(length-l) 9]\n     \
    \ [(length-l) 10]\n      [(length-l) 11]\n      [(length-l) 12]\n      [(length-l)\
    \ 13]\n      [(length-l) 14]\n      [(length-l) 15]\n      [(length-l) 16]\n \
    \     [(length-l) 17]\n      [(length-l) 18]\n      [(length-l) 19]\n      [(length-l)\
    \ 20]\n      [(length-l) 21]\n      [(length-l) 22]\n      [(length-l) 23]\n \
    \     [(length-l) 24]\n      [(length-l) 25]\n      [(length-l) 26]\n      [(length-l)\
    \ 27]\n      [(length-l) 28]\n      [(length-l) 29]\n      [(length-l) 30]\n \
    \     [(length-l) 31]\n      [(length-l) 32]\n      [(length-l) 33]\n      [(length-l)\
    \ 34]\n      [(length-l) 35]\n      [(length-l) 36]\n      [(length-l) 37]\n \
    \     [(length-l) 38]\n      [(length-l) 39]\n      [(length-l) 40]\n      [(length-l)\
    \ 41]\n      [(length-l) 42]\n      [(length-l) 43]\n      [(length-l) 44]\n \
    \     [(length-l) 45]\n      [(length-l) 46]\n      [(length-l) 47]\n      [(length-l)\
    \ 48]\n      [(length-l) 49]\n      [(length-l) 50]\n      [(length-", "  (define\
    \ (helper l1 l2)\n    (if (and (empty? l1) (empty? l2))\n        0\n        (+\
    \ (/ (length l1) 2) (helper (rest l1) (rest l2)))))\n  (let ([sorted (sort l &lt;)])\n\
    \    (helper (take sorted (/ (length sorted) 2)) (drop sorted (/ (length sorted)\
    \ 2)))))\n</code>\nHowever, there is a better solution by using the function <code>bisect</code>\
    \ provided by Racket. The idea is to sort the list and pick the right element\
    \ according to the length of the list.\n<code>#lang racket\n", "  (let ([sl (sort\
    \ l &lt;)])\n    (cond\n      [(zero? (length sl))\n       #f]\n      [(even?\
    \ (length sl))\n       (/ (+ (list-ref sl (/ (length sl) 2))\n            (list-ref\
    \ sl (- (/ (length sl) 2) 1)))\n          2)]\n      [else\n       (list-ref sl\
    \ (/ (length sl) 2))])))\n", "  (define (median-iter l m)\n    (if (null? l)\n\
    \        m\n        (median-iter (cdr l)\n                     (if (and (list?\
    \ m) (not (null? m)))\n                         (if (&lt; (car l) (car m))\n \
    \                            (cons (car l) m)\n                             (cons\
    \ (car m) l))\n                         (list (car l))))))\n  (if (null? l)\n\
    \      empty\n      (if (list? l)\n          (car (median-iter (cdr l) (list (car\
    \ l))))\n          (median-iter (cdr l) (car l)))))\n</code>\nThe <code>median-iter</code>\
    \ function is a bit weird because it builds a sorted list of all the elements\
    \ in the input list. I want to avoid that and instead build the median incrementally.\n\
    Here's my attempt in Scheme:\n<code>#lang scheme\n", "  (define (median-sort l)\n\
    \    (sort < l))\n  (let* ([l (median-sort l)]\n         [mid (quotient (length\
    \ l) 2)])\n    (if (odd? (length l))\n        (list-ref l mid)\n        (/ (+\
    \ (list-ref l mid) (list-ref l (- mid 1))) 2))))\n</code>\nThe specification didn't\
    \ mention what to do if the list has zero or 1 elements, so I left it for the\
    \ moment.\nHowever when I want to test it, I get an error:\n<code>&gt; (median\
    \ '(1 2 3 4 5))\n. . . .\nmedian.rkt:11:0: quasiquote: unquote requires a value\
    \ argument in: (list-ref l mid)\nmedian.rkt:11:15: quasiquote: unquote requires\
    \ a value argument in: (list-ref l mid)\nmedian.rkt:12:0: quasiquote: unquote\
    \ requires a value argument in: (+ (list-ref l mid) (list-ref l (- mid 1)))\n\
    median.rkt:12:30: quasiquote: unquote requires a value argument in: (+ (list-ref\
    \ l mid) (list-ref l (- mid 1)))\n&gt;\n</code>\nThis is the first time I get\
    \ a quasiquote error and I can't figure out what I've done wrong. Can anyone tell\
    \ me where I'm going wrong?\nThanks in advance.\n\n\nA:\n\nYou should be able\
    \ to get rid of the <code>quasiquote</code> error by replacing all your <code>let*</code>\
    \ with <code>let</code>. The problem is that <code>let*</code> expects all of\
    \ its expressions to be written in a \"quasiquote\" style, which means that all\
    \ unbound references are written with a <code>'</code> before the name. This can\
    \ be useful for syntax-quote-like macros, but it's not needed for a <code>let</code>\
    \ expression. Here's an example showing both types of <code>let</code>\n<code>&gt;\
    \ (let* ([a 1]\n         [b (+ 'a 1)", "  (define (median-iter l n m)\n    (if\
    \ (= n m)\n        (/ (+ (list-ref l n) (list-ref l (- n 1))) 2)\n        (if\
    \ (= n 0)\n            (list-ref l n)\n            (median-iter l (+ n 1) m))))\n\
    \  (median-iter l 0 (/ (length l) 2)))\n", "  (let ([n (sort l &lt;)])\n    (cond\
    \ [(empty? n) 0]\n          [(empty? (rest n)) (first n)]\n          [else (let*\
    \ ([m1 (floor (/ (sub1 (length n)) 2))]\n                       [m2 (sub1 (+ m1\
    \ (remainder (sub1 (length n)) 2)))]\n                       [n1 (list-ref n m1)]\n\
    \                       [n2 (list-ref n m2)])\n                  (/ (+ n1 n2)\
    \ 2))])))\n</code>\n", "  (cond\n    [(empty? l) (error \"median of empty list\
    \ is undefined\")]\n    [(odd? (length l))\n     (list-ref l (quotient (length\
    \ l) 2))]\n    [else (/ (+ (list-ref l (/ (length l) 2))\n                (list-ref\
    \ l (- (/ (length l) 2) 1)))\n             2)]))\n", "  (cond\n    [(or (empty?\
    \ l) (empty? (rest l))) (first l)]\n    [(empty? (rest (rest l))) (/ (+ (first\
    \ l) (second l)) 2)]\n    [else\n     (cond\n       [(>= (length l) 5)\n     \
    \   (define sorted (sort l <))\n        (list-ref sorted (/ (length sorted) 2))]\n\
    \       [else (median (merge (merge-sort (sublist l 0 (quotient (length l) 2))\
    \ <)\n                            (merge-sort (sublist l (quotient (length l)\
    \ 2) (length l)) <)))])]))\n", "  (define (comparator x y) (if (&lt; x y) #t #f))\n\
    \  (define (select l k comparator)\n    (if (equal? k 1)\n        (apply min l\
    \ comparator)\n        (select (filter\n                 (lambda (x) (comparator\
    \ x (apply min l comparator)))\n                 l)\n                (- k 1)\n\
    \                comparator)))\n  (define len (length l))\n  (if (even? len)\n\
    \      (/ (+ (select l (/ len 2) comparator)\n            (select l (+ (/ len\
    \ 2) 1) comparator))\n         2)\n      (select l (ceiling (/ len 2)) comparator)))\n\
    </code>\nThe <code>select</code> function is inspired by selection sort.\nThe\
    \ <code>comparator</code> function can be replaced by <code>&lt;</code> if you\
    \ don't care about efficiency.\n", "  (define (median-help s l)\n    (if (null?\
    \ l)\n        (car s)\n        (if (even? (length l))\n            (median-help\
    \ s (cdr l))\n            (median-help (cons (car l) s) (cdr l)))))\n  (median-help\
    \ '() l))\n", "  (define (median-helper l lower upper)\n    (cond ((= lower upper)\n\
    \           (list-ref l lower))\n          ((= (- upper lower) 1)\n          \
    \ (/ (+ (list-ref l lower) (list-ref l upper)) 2))\n          (else\n        \
    \   (let* ([mid (/ (+ lower upper) 2)]\n                  [mid-value (list-ref\
    \ l mid)])\n             (cond ((&lt; mid-value (list-ref l lower))\n        \
    \            (median-helper l lower (- mid 1)))\n                   ((&gt; mid-value\
    \ (list-ref l upper))\n                    (median-helper l (+ mid 1) upper))\n\
    \                   (else\n                    mid-value))))))\n  (median-helper\
    \ l 0 (- (length l) 1)))\n", "  (define (median-helper l)\n    (cond ((empty?\
    \ l)\n           (error \"No median of an empty list\"))\n          ((one? l)\n\
    \           (first l))\n          ((two? l)\n           (/ (+ (first l) (second\
    \ l)) 2))\n          (else\n           (median-helper (rest (rest l))))))\n  (median-helper\
    \ (sort l)))\n", "  (let ([n (length l)])\n    (define (median-n l n)\n      (if\
    \ (= n 0)\n          +inf.0\n          (if (= n 1)\n              (car l)\n  \
    \            (if (= n 2)\n                  (/ (+ (car l) (cadr l)) 2)\n     \
    \             (if (= (modulo n 2) 0)\n                      (/ (+ (median-n (sort\
    \ l <) (/ n 2))\n                            (median-n (sort l <) (- (/ n 2) 1)))\n\
    \                         2)\n                      (median-n (sort l <) (/ n\
    \ 2)))))))\n    (median-n l n)))\n", "  (define sorted (sort < l))\n  (cond ((=\
    \ (length l) 0) (error \"Empty list\"))\n        ((= (length l) 1) (car l))\n\
    \        ((= (modulo (length l) 2) 0) (/ (+ (list-ref sorted (/ (length l) 2))\n\
    \                                            (list-ref sorted (- (/ (length l)\
    \ 2) 1)))\n                                         2))\n        (else (list-ref\
    \ sorted (/ (length l) 2)))))\n", "  (let* ([n (length l)]\n         [m (/ n 2)])\n\
    \    (if (even? n)\n        (let* ([a (list-ref l m)]\n               [b (list-ref\
    \ l (- m 1))])\n          (/ (+ a b) 2))\n        (list-ref l m))))\n", "  (define\
    \ (insert-into l x)\n    (if (null? l)\n        (list x)\n        (if (<= x (car\
    \ l))\n            (cons x l)\n            (cons (car l) (insert-into (cdr l)\
    \ x)))))\n  (define (median-of-sorted l)\n    (if (even? (length l))\n       \
    \ (/ (+ (list-ref l (/ (length l) 2))\n              (list-ref l (- (/ (length\
    \ l) 2) 1)))\n           2)\n        (list-ref l (/ (length l) 2))))\n  (median-of-sorted\
    \ (foldl insert-into (list) l)))\n", "  (let ([len (length l)])\n    (cond\n \
    \     [(or (= len 0) (= len 1))\n       \"invalid list\"]\n      [(= len 2)\n\
    \       (/ (+ (car l) (cadr l)) 2)]\n      [(or (= len 3) (= len 4))\n       (/\
    \ (+ (car l) (cadr l) (car (cddr l)) (car (cdddr l))) 4)]\n      [else\n     \
    \  (median (merge-sort l))])))\n", "  (let* ([len (length l)]\n         [len2\
    \ (quotient len 2)])\n    (if (odd? len)\n        (list-ref l len2)\n        (let*\
    \ ([elm1 (list-ref l len2)]\n               [elm2 (list-ref l (- len2 1))])\n\
    \          (/ (+ elm1 elm2) 2)))))\n", "  (if (= (length l) 1)\n      (car l)\n\
    \      (let* ([hl (quotient (length l) 2)]\n             [lower (sort l &lt;)])\n\
    \        (if (even? (length l))\n            (/ (+ (list-ref lower hl) (list-ref\
    \ lower (- hl 1))) 2)\n            (list-ref lower hl)))))\n", "  (define (insert\
    \ x l)\n    (cond\n      [(empty? l) (list x)]\n      [(> x (first l)) (cons (first\
    \ l) (insert x (rest l)))]\n      [else (cons x l)]))\n  (define (insert-all l\
    \ lst)\n    (cond\n      [(empty? l) lst]\n      [else (insert-all (rest l) (insert\
    \ (first l) lst))]))\n  (define (sort l)\n    (insert-all l (list)))\n  (define\
    \ (med l)\n    (cond\n      [(empty? l) (error \"med: list empty\")]\n      [(empty?\
    \ (rest l)) (first l)]\n      [(empty? (rest (rest l))) (/ (+ (first l) (second\
    \ l)) 2)]\n      [else (med (rest l))]))\n  (med (sort l)))\n", "  (define (merge\
    \ a b)\n    (cond\n      [(null? a) b]\n      [(null? b) a]\n      [(< (car a)\
    \ (car b)) (cons (car a) (merge (cdr a) b))]\n      [else (cons (car b) (merge\
    \ a (cdr b)))]))\n  (define (merge-sort l)\n    (if (null? l) '()\n        (define\
    \ c (car l))\n        (define l1 (filter (lambda (x) (< x c)) (cdr l)))\n    \
    \    (define l2 (filter (lambda (x) (>= x c)) (cdr l)))\n        (merge (merge-sort\
    \ l1) (cons c (merge-sort l2)))))\n  (define (index l n)\n    (if (null? l) 0\n\
    \        (define c (car l))\n        (define l1 (filter (lambda (x) (< x c)) (cdr\
    \ l)))\n        (define l2 (filter (lambda (x) (>= x c)) (cdr l)))\n        (if\
    \ (<= n (length l1)) (index l1 n)\n            (if (<= n (+ (length l1) 1)) c\n\
    \                (index l2 (- n (length l1) 1))))))\n  (if (null? l) 0\n     \
    \ (if (null? (cdr l)) (car l)\n          (define x (index (merge-sort l) (/ (length\
    \ l) 2)))\n          (if (even? (length l)) (+ x (index (merge-sort l) (+ (/ (length\
    \ l) 2) 1)))\n              (/ x 2)))))\n```\n\n### 5.11\n\n```racket\n#lang racket\n",
  "  (let ((c (sort (comparator&lt; &lt;) l)))\n    (cond\n      [(empty? c) 0]\n\
    \      [(= (length c) 1) (first c)]\n      [(odd? (length c)) (list-ref c (/ (length\
    \ c) 2))]\n      [else (/ (+ (list-ref c (/ (length c) 2))\n                 (list-ref\
    \ c (add1 (/ (length c) 2))))\n              2)])))\n</code>\n", "  (sort l <))\n\
    ```\n\n```\n#lang racket\n", "  (apply min\n         (remove (apply min l)\n \
    \                (remove (apply max l) l))))\n", "  (let* ((ordered (sort l &lt;=)))\n\
    \    (cond\n      [(odd? (length ordered))\n       (list-ref ordered (/ (length\
    \ ordered) 2))]\n      [else\n       (/ (+ (list-ref ordered (/ (length ordered)\
    \ 2))\n             (list-ref ordered (- (/ (length ordered) 2) 1)))\n       \
    \   2)])))\n</code>\nWhich gave me a new error:\n<code>call/cc: arity mismatch;\n\
    \ the expected number of arguments does not match the given number\n  expected:\
    \ 1\n  given: 2\n  arguments...:\n   #&lt;procedure:racket/list&gt;\n   #&lt;procedure:&gt;\n\
    </code>\nI'm not sure what I did wrong, or if it's my code, I'm new to Racket.\n\
    Thank you!\n\n\nA:\n\nWhile there are more elegant solutions to the problem, I\
    \ think the key here is to analyze what's happening: the expression <code>(list-ref\
    \ ordered (/ (length ordered) 2))</code> is trying to extract the value of an\
    \ element of a list, but the result of <code>(/ (length ordered) 2)</code> is\
    \ a real number. <code>list-ref</code> expects an integer value as an argument,\
    \ and that's the source of the error.\nTo solve it, try rounding the result of\
    \ the division, to get an integer:\n<code>(define (median l)\n  (let* ((ordered\
    \ (sort l &lt;=)))\n    (cond\n      [(odd? (length ordered))\n       (list-ref\
    \ ordered (/ (length ordered) 2))]\n      [else\n       (/ (+ (list-ref ordered\
    \ (round (/ (length ordered) 2)))\n             (list-ref ordered (- (round (/\
    \ (length ordered) 2)) 1)))\n          2)])))\n</code>\n", "  (cond ((null? l)\
    \ 0)\n        ((null? (cdr l)) (car l))\n        ((= (modulo (length l) 2) 1)\n\
    \         (list-ref l (quotient (length l) 2)))\n        (else\n         (/ (+\
    \ (list-ref l (quotient (length l) 2))\n              (list-ref l (1+ (quotient\
    \ (length l) 2))))\n            2))))\n</code>\nI have the following test cases:\n\
    <code>(median (list 1 2 3 4 5))\n=&gt; 3", "  (define len (length l))\n  (define\
    \ (merge x y)\n    (if (= 0 (length x))\n        y\n        (if (= 0 (length y))\n\
    \            x\n            (if (< (car x) (car y))\n                (cons (car\
    \ x) (merge (cdr x) y))\n                (cons (car y) (merge x (cdr y)))))))\n\
    \  (define (merge-sort l)\n    (if (= 1 (length l))\n        l\n        (let ([i\
    \ (quotient (length l) 2)])\n          (merge (merge-sort (take l i))\n      \
    \           (merge-sort (drop l i))))))\n  (let ([sorted (merge-sort l)])\n  \
    \  (if (even? len)\n        (/ (+ (list-ref sorted (quotient len 2))\n       \
    \       (list-ref sorted (- (quotient len 2) 1)))\n           2)\n        (list-ref\
    \ sorted (quotient len 2)))))\n", "  (let* ([sorted (sort l)]\n         [len (length\
    \ sorted)])\n    (if (odd? len)\n        (list-ref sorted (quotient len 2))\n\
    \        (/ (+ (list-ref sorted (/ len 2))\n              (list-ref sorted (-\
    \ len 1 (/ len 2))))\n           2))))\n", "  (define n (length l))\n  (if (=\
    \ n 0)\n      #f\n      (define (sort-helper n l)\n        (if (= n 0)\n     \
    \       (list '())\n            (let ([sorted-tail (sort-helper (- n 1) l)])\n\
    \              (define (insert-helper x sorted-list)\n                (if (null?\
    \ sorted-list)\n                    (list x)\n                    (if (&lt;= x\
    \ (car sorted-list))\n                        (cons x sorted-list)\n         \
    \               (cons (car sorted-list) (insert-helper x (cdr sorted-list))))))\n\
    \              (insert-helper (list-ref l (- n 1)) sorted-tail))))\n      (define\
    \ sorted-l (sort-helper n l))\n      (if (odd? n)\n          (list-ref sorted-l\
    \ (/ n 2))\n          (/ (+ (list-ref sorted-l (/ n 2)) (list-ref sorted-l (-\
    \ (/ n 2) 1))) 2))))\n</code>\n", "  (if (null? l)\n      #f\n      (let ([l2\
    \ (sort l &lt;)])\n        (if (= (remainder (length l2) 2) 0)\n            (/\
    \ (+ (list-ref l2 (/ (length l2) 2))\n                  (list-ref l2 (- (/ (length\
    \ l2) 2) 1)))\n               2)\n            (list-ref l2 (/ (length l2) 2))))))\n",
  "  (let ([sorted (sort l <)])\n    (if (= (remainder (length sorted) 2) 0)\n   \
    \     (quotient (apply + (take (sub1 (length sorted)) (drop (/ (length sorted)\
    \ 2) sorted))) 2)\n        (list-ref sorted (/ (length sorted) 2)))))\n", "  (define\
    \ (length l)\n    (cond\n      [(null? l) 0]\n      [else (+ 1 (length (cdr l)))]))\n\
    \  (define (nth-smallest l i)\n    (cond\n      [(null? l) (error \"Element \"\
    \ i \" not found\")]\n      [(= 0 i) (car l)]\n      [else (nth-smallest (cdr\
    \ l) (- i 1))]))\n  (let ([len (length l)])\n    (if (= (modulo len 2) 0)\n  \
    \      (+ (nth-smallest l (/ len 2)) (nth-smallest l (- (/ len 2) 1)))\n     \
    \   (nth-smallest l (/ len 2)))))\n", "  (define (median-inner l)\n    (cond\n\
    \      [(empty? l) l]\n      [(empty? (rest l)) (first l)]\n      [(empty? (rest\
    \ (rest l))) (/ (+ (first l) (second l)) 2)]\n      [else (median-inner (rest\
    \ l))]))\n  (median-inner (sort l <)))\n", "  (define (count x l)\n    (if (empty?\
    \ l)\n        0\n        (+ (if (equal? x (first l)) 1 0)\n           (count x\
    \ (rest l)))))\n  (define (nth-smallest n l)\n    (if (empty? l)\n        '()\n\
    \        (let ((h (first l)))\n          (cond ((= n (count h l)) h)\n       \
    \         ((&lt; n (count h l)) nth-smallest n (remove h l))\n               \
    \ (else (nth-smallest (- n (count h l)) (rest l)))))))\n  (nth-smallest (/ (length\
    \ l) 2) l))\n</code>\nI'm really not certain that I'm doing this as efficiently\
    \ as possible, so I'd love some suggestions. Thanks!\n\n\nA:\n\nYou can use <code>quicksort</code>\
    \ from <code>srfi-1</code> to obtain a sorted list, then pick the middle element.\n",
  "  (cond ((null? l) '())\n        ((= 1 (length l)) (car l))\n        ((= 2 (length\
    \ l)) (/ (+ (car l) (cadr l)) 2))\n        (else (let* ([l (sort l <)]\n     \
    \                [n (length l)]\n                     [m (/ (- n 1) 2)])\n   \
    \             (cond ((odd? n) (list-ref l m))\n                      (else (+\
    \ (list-ref l m) (list-ref l (- m 1)))))))))\n", "  (median-sublist (sort l <)))\n",
  "  (apply fmin (sort l)))\n", "  (sort l <)\n  (cond\n    [(empty? l) empty]\n \
    \   [(empty? (rest l)) (first l)]\n    [(empty? (rest (rest l))) (/ (+ (first\
    \ l) (second l)) 2)]\n    [else (list-ref l (/ (length l) 2))]))\n", "  (define\
    \ sorted (sort l #&lt;))\n  (cond [(empty? sorted) #f]\n        [(odd? (length\
    \ sorted)) (list-ref sorted (/ (length sorted) 2))]\n        [else (/ (+ (list-ref\
    \ sorted (/ (length sorted) 2))\n                    (list-ref sorted (1+ (/ (length\
    \ sorted) 2))))\n                 2)]))\n</code>\nThis works fine, but fails when\
    \ I try to create a new function <code>median-3</code>, which finds the median\
    \ of three numbers.\n<code>#lang racket\n", "  (quicksort l))\n", "  (cond [(empty?\
    \ l) (error \"empty list\")]\n        [(empty? (rest l)) (first l)]\n        [(or\
    \ (= (length l) 2)\n             (= (length l) 3)) (median-of-three l)]\n    \
    \    [else (median-of-medians l)]))\n", "  (cond\n    [(null? l) (error \"No median\
    \ of empty list\")]\n    [(null? (cdr l)) (car l)]\n    [(odd? (length l))\n \
    \    (list-ref l (quotient (length l) 2))]\n    [else\n     (/ (+ (list-ref l\
    \ (quotient (length l) 2))\n           (list-ref l (1+ (quotient (length l) 2))))\n\
    \        2)]))\n", "  (define (select n l)\n    (cond ((empty? l) (error \"List\
    \ is empty\"))\n          ((empty? (rest l)) (first l))\n          (else (let\
    \ ((pivot (first l))\n                       (nth-elem (select n (rest l))))\n\
    \                  (cond ((< n (number-of-smaller-elements pivot l))\n       \
    \                  nth-elem)\n                        ((> n (number-of-smaller-elements\
    \ pivot l))\n                         (select (- n\n                         \
    \          (number-of-smaller-elements pivot l)\n                            \
    \       1)\n                                 (remove pivot l)))\n            \
    \            (else pivot))))))\n  (let ((n (quotient (length l) 2)))\n    (if\
    \ (odd? (length l))\n        (select n l)\n        (let ((nth-elem (select n l)))\n\
    \          (/ (+ nth-elem (select n (remove nth-elem l))) 2)))))\n", "  (let ([n\
    \ (length l)])\n    (if (odd? n)\n        (list-ref l (quotient n 2))\n      \
    \  (let ([m (quotient n 2)])\n          (/ (+ (list-ref l (- m 1)) (list-ref l\
    \ m)) 2)))))\n", "  (cond [(null? l) (error \"median: empty list\")]\n       \
    \ [(= (length l) 1) (car l)]\n        [else (if (odd? (length l))\n          \
    \        (list-ref l (quotient (length l) 2))\n                  (/ (+ (list-ref\
    \ l (quotient (length l) 2))\n                        (list-ref l (1+ (quotient\
    \ (length l) 2))))\n                     2))]))\n", "  (define (median-sorted\
    \ l)\n    (cond [(empty? l) 0]\n          [(empty? (rest l)) (first l)]\n    \
    \      [(= (length l) 2) (/ (+ (first l) (second l)) 2)]\n          [else\n  \
    \         (define len (length l))\n           (define m (/ len 2))\n         \
    \  (cond [(even? len) (/ (+ (list-ref l m) (list-ref l (- m 1))) 2)]\n       \
    \          [else (list-ref l m)])]))\n  (median-sorted (sort < l)))\n", "  (if\
    \ (null? l)\n      0\n      (let* ([sorted (sort l &lt;)]\n             [l-len\
    \ (length l)])\n        (if (= (modulo l-len 2) 0)\n            (/ (+ (list-ref\
    \ sorted (/ l-len 2))\n                  (list-ref sorted (- (/ l-len 2) 1)))\n\
    \               2)\n            (list-ref sorted (/ l-len 2))))))\n", "  (if (=\
    \ (length l) 1)\n      (car l)\n      (let ((len (- (length l) 1)))\n        (define\
    \ (mergeSort l)\n          (if (= (length l) 1)\n              l\n           \
    \   (let* ((n (/ (length l) 2))\n                     (left (mergeSort (slice\
    \ l 0 n)))\n                     (right (mergeSort (slice l n len))))\n      \
    \          (merge left right))))\n        (define (merge left right)\n       \
    \   (cond\n            [(null? left) right]\n            [(null? right) left]\n\
    \            [(< (car left) (car right))\n             (cons (car left) (merge\
    \ (cdr left) right))]\n            [else\n             (cons (car right) (merge\
    \ left (cdr right)))]))\n        (let ((l (mergeSort l)))\n          (if (odd?\
    \ len)\n              (list-ref l (/ len 2))\n              (/ (+ (list-ref l\
    \ (/ len 2)) (list-ref l (+ (/ len 2) 1))) 2))))))\n", "  (define (median-1 l)\n\
    \    (if (null? l)\n        l\n        (if (null? (cdr l))\n            (car l)\n\
    \            (if (null? (cddr l))\n                (if (< (car l) (cadr l))\n\
    \                    (car l)\n                    (cadr l))\n                (median-1\
    \ (cons (car l) (cddr l)))))))\n  (median-1 (sort < l)))\n", "  (define (smaller-than\
    \ l x)\n    (if (null? l)\n        #t\n        (if (&lt; (car l) x)\n        \
    \    (smaller-than (cdr l) x)\n            #f)))\n  (define (divide l)\n    (define\
    \ (divide-iter l a b i n)\n      (if (&lt;= i n)\n          (if (smaller-than\
    \ l (car a))\n              (divide-iter l (cons (car a) a) b (+ i 1) n)\n   \
    \           (divide-iter l a (cons (car a) b) (+ i 1) n))\n          (cons a b)))\n\
    \    (divide-iter l l empty empty 0 (sub1 (length l))))\n  (define (median-iter\
    \ l a b)\n    (if (&lt; (length a) (length b))\n        (median-iter (cons (car\
    \ l) l) (cons (car l) a) b)\n        (median-iter (cdr l) a (cons (car l) b))))\n\
    \  (define (empty-list? l)\n    (if (null? l)\n        #t\n        #f))\n  (if\
    \ (empty-list? l)\n      (error \"Empty list\")\n      (define (even-size? l)\n\
    \        (if (zero? (modulo (length l) 2))\n            #t\n            #f))\n\
    \      (if (even-size? l)\n          (median-iter (cdr l) empty empty)\n     \
    \     (median-iter (cdr l) empty empty))))\n</code>\nThe function below is also\
    \ an example of divide and conquer which is used in the function above.\n<code>;;\
    \ Returns the n-th fibonacci number.", "  (cond\n    [(empty? l) #f]\n    [(empty?\
    \ (rest l)) (first l)]\n    [else (let* ([n (length l)]\n                 [l1\
    \ (take l n/2)]\n                 [l2 (drop l n/2)])\n             (if (odd? n)\n\
    \                 (median l2)\n                 (mean (median l1) (median l2))))]))\n\
    </code>\nOn the surface it may seem to be the same as the second one, but it's\
    \ not. The second one works on all Racket versions, but the first one only works\
    \ in Racket 6.1 (and above).\nWhat is the difference between <code>list</code>\
    \ and <code>list*</code> in the first function?\n\n\nA:\n\nThe <code>list</code>\
    \ function is different from <code>list*</code>.\nThe <code>list</code> function\
    \ takes any number of arguments and creates a list containing those arguments.\n\
    <code>(list 1 2 3 4)", "  (let* ((sorted (quicksort l <))\n         (len (length\
    \ sorted)))\n    (cond\n      [(zero? (remainder len 2))\n       (/ (+ (list-ref\
    \ sorted (/ len 2))\n             (list-ref sorted (- (/ len 2) 1)))\n       \
    \   2)]\n      [else\n       (list-ref sorted (/ len 2))])))\n", "  (let ((n (length\
    \ l)))\n    (let ((mid (/ n 2)))\n      (if (= (remainder n 2) 0)\n          (/\
    \ (+ (list-ref l mid) (list-ref l (- mid 1))) 2)\n          (list-ref l mid)))))\n",
  "  (define (median' l count)\n    (cond [(empty? l) '()]\n          [(= count (/\
    \ (length l) 2)) (first l)]\n          [else (median' (rest l) (+ count 1))]))\n\
    \  (median' l 0))\n", "  (if (null? l) (error \"Empty list.\")\n      (begin\n\
    \        (sort l &lt;)\n        (let* ([n (length l)]\n               [m (quotient\
    \ n 2)])\n          (if (odd? n) (list-ref l m)\n              (let* ([m1 (- m\
    \ 1)]\n                     [m2 (+ m 1)])\n                (/ (+ (list-ref l m1)\
    \ (list-ref l m2)) 2)))))))\n</code>\n", "  (local ((define (median-if-even l)\n\
    \            (define (middle-two l)\n              (cond ((null? l) l)\n     \
    \               ((null? (cdr l)) l)\n                    ((middle-two (cdr l)))))\n\
    \            (define (average l)\n              (/ (+ (car l) (car (cdr l))) 2))\n\
    \            (average (middle-two l))))\n    (define (median-if-odd l)\n     \
    \ (let ((l2 (sort l <)))\n        (cond ((null? l2) (error \"median: empty list\"\
    ))\n              ((null? (cdr l2)) (car l2))\n              ((null? (cdr (cdr\
    \ l2))) (/ (+ (car l2) (car (cdr l2))) 2))\n              (else (car (cdr (cdr\
    \ l2)))))))\n    (define (even? l)\n      (cond ((null? l) #t)\n            ((null?\
    \ (cdr l)) #f)\n            (else (even? (cdr l)))))\n    (cond ((even? l) (median-if-even\
    \ l))\n          (else (median-if-odd l)))))\n", "  (define s (sort l <))\n  (cond\n\
    \    ((= (length s) 0)\n     '())\n    ((= (length s) 1)\n     (car s))\n    ((=\
    \ (modulo (length s) 2) 0)\n     (/ (+ (list-ref s (/ (length s) 2))\n       \
    \   (list-ref s (- (/ (length s) 2) 1)))\n        2))\n    (else\n     (list-ref\
    \ s (/ (length s) 2)))))\n", "  (let ([l (sort l <)])\n    (if (even? (length\
    \ l))\n        (/ (+ (list-ref l (/ (length l) 2))\n              (list-ref l\
    \ (- (/ (length l) 2) 1)))\n           2)\n        (list-ref l (/ (length l) 2)))))\n",
  "  (define (sort-list l)\n    (sort l <))\n  (define (take-middle l)\n    (rest\
    \ (take (round (/ (length l) 2)) l)))\n  (define (odd-number-of-elements l)\n\
    \    (= (remainder (length l) 2) 1))\n  (define (median-of-odd-list l)\n    (first\
    \ (take-middle l)))\n  (define (median-of-even-list l)\n    (/ (+ (first (take-middle\
    \ l)) (first (rest (take-middle l)))) 2))\n  (if (odd-number-of-elements l)\n\
    \      (median-of-odd-list (sort-list l))\n      (median-of-even-list (sort-list\
    \ l))))\n", "  (define (c l m n)\n    (cond [(< n 0) 0]\n          [(< l m) (+\
    \ 1 (c (cdr l) m n))]\n          [(< m l) (+ -1 (c l m (- n 1)))]\n          [else\
    \ n]))\n  (define (part l n)\n    (cond [(< n 0) l]\n          [(null? l) '()]\n\
    \          [(= (c l (car l) n) n) (cons (car l) (part (cdr l) (- n 1)))]\n   \
    \       [else (part (cdr l) n)]))\n  (define (merge l m)\n    (cond [(null? l)\
    \ m]\n          [(null? m) l]\n          [(< (car l) (car m)) (cons (car l) (merge\
    \ (cdr l) m))]\n          [else (cons (car m) (merge l (cdr m)))]))\n  (define\
    \ (qsort l)\n    (cond [(null? l) '()]\n          [(null? (cdr l)) l]\n      \
    \    [else (let ((m (median l)))\n                  (merge (qsort (part l (- (length\
    \ l) (/ (length l) 2))))\n                         (qsort (part l (/ (length l)\
    \ 2)))))]))\n  (define (qsort-median l)\n    (cond [(< (length l) 3) (qsort l)]\n\
    \          [else (let ((m (median l)))\n                  (merge (qsort (part\
    \ l (- (length l) (/ (length l) 2))))\n                         (qsort (part l\
    \ (/ (length l) 2)))))]))\n  (if (null? l)\n      0\n      (let* ((l (qsort-median\
    \ l))\n             (n (quotient (length l) 2)))\n        (if (odd? (length l))\n\
    \            (list-ref l n)\n            (quotient (+ (list-ref l n) (list-ref\
    \ l (- n 1))) 2)))))\n```\n\n## Problem 4\n\n![](./img/prob4.png)\n\n```\n#lang\
    \ racket\n", "  (define l-len (length l))\n  (if (odd? l-len)\n      ;; Odd case:\
    \ Get the middle element.\n      (list-ref l (quotient l-len 2))\n      ;; Even\
    \ case: Get the middle two elements and average them.\n      (/ (+ (list-ref l\
    \ (quotient l-len 2))\n            (list-ref l (quotient (- l-len 1) 2)))\n  \
    \       2)))\n", "  (cond\n    [(empty? l) 0]\n    [(number? (first l))\n    \
    \ (apply median (rest l))]\n    [(and\n      (list? (first l))\n      (number?\
    \ (first (first l))))\n     (median (map first l))]\n    [else (error 'median\
    \ \"bad list\")]))\n", "  (define (median-from-sorted l)\n    (cond\n      [(empty?\
    \ l) (error \"median-from-sorted: empty list\")]\n      [(empty? (rest l)) (first\
    \ l)]\n      [(> (length l) 2) (median-from-sorted (rest (rest l)))]\n      [else\
    \ (first l)]))\n  (median-from-sorted (sort < l)))\n", "  (cond [(empty? l) 0]\n\
    \        [(= (count l) 1) (first l)]\n        [(= (count l) 2) (/ (+ (first l)\
    \ (second l)) 2)]\n        [else\n         (cond [(even? (count l))\n        \
    \        (/ (+ (median (rest l)) (median (butlast l))) 2)]\n               [else\
    \ (median (rest l))])]))\n</code>\nI'm still not 100% convinced my solution is\
    \ optimal, but it's efficient enough for me.\n", "  (median-helper l (quotient\
    \ (length l) 2)))\n", "  (if (null? l)\n      0\n      (apply + l (/ (length l))))\n\
    )\n</code>\nI want to make something like the following, but in Scheme:\n<code>#lang\
    \ racket\n", "  (sort l &lt;))\n</code>\ncompile it to bytecode using <code>raco\
    \ make</code> or <code>raco exe</code> (I prefer <code>raco exe</code> because\
    \ it compiles bytecode and also creates a standalone executable file):\n<code>raco\
    \ exe median.rkt\n</code>\nand then run the executable:\n<code>./median.rkt\n\
    </code>\n", "  (let ([sorted (sort l &lt;)])\n    (if (even? (length sorted))\n\
    \        (/ (+ (list-ref sorted (/ (length sorted) 2))\n              (list-ref\
    \ sorted (- (/ (length sorted) 2) 1)))\n           2)\n        (list-ref sorted\
    \ (/ (length sorted) 2)))))\n</code>\n", "  (define (halve l)\n    (cond\n   \
    \   [(empty? l) l]\n      [(empty? (rest l)) l]\n      [else (cons (first l) (halve\
    \ (rest (rest l))))]))\n  (cond\n    [(= 1 (length l)) (first l)]\n    [(= 2 (length\
    \ l)) (/ (+ (first l) (second l)) 2)]\n    [else (median (halve l))]))\n", " \
    \ (define l (sort l <))\n  (define n (length l))\n  (if (odd? n)\n      (list-ref\
    \ l (/ n 2))\n      (/ (+ (list-ref l (/ n 2)) (list-ref l (- (/ n 2) 1))) 2)))\n\
    </code>\n", "  (define (median-iter l1 l2)\n    (if (null? l1)\n        (if (null?\
    \ l2)\n            '()\n            (car l2))\n        (if (null? l2)\n      \
    \      (car l1)\n            (if (< (car l1) (car l2))\n                (median-iter\
    \ (cdr l1) l2)\n                (median-iter l1 (cdr l2))))))\n  (define (split\
    \ l)\n    (if (null? l)\n        '()\n        (cons (car l) (split (cdr (cdr l))))))\n\
    \  (median-iter (split l) (reverse (split l))))\n</code>\nIn order to understand\
    \ the algorithm, I wrote a much simpler function, which returns two elements from\
    \ the list, however, it passes the even number of elements test case, but fails\
    \ the odd number test case.\n<code>#lang racket\n", "  (define (sort l h)\n  \
    \  (cond ((or (null? l) (null? h)) l)\n          ((> (car l) (car h)) (sort l\
    \ (cdr h)))\n          (else (sort (cdr l) h))))\n  (define (sort-helper l)\n\
    \    (define (divide l mid even)\n      (cond ((null? l) (values mid (cdr mid)\
    \ even))\n            ((null? (cdr l)) (values mid (cdr mid) (not even)))\n  \
    \          (else (divide (cdr (cdr l)) (cdr mid) (not even)))))\n    (define (merge\
    \ l h)\n      (cond ((null? l) h)\n            ((null? h) l)\n            ((<\
    \ (car l) (car h)) (cons (car l) (merge (cdr l) h)))\n            (else (cons\
    \ (car h) (merge l (cdr h))))))\n    (define (helper a b even)\n      (cond ((null?\
    \ a) (if even (car b) (car a)))\n            ((null? b) (if even (car a) (car\
    \ b)))\n            (else (merge (sort a (cdr b)) (sort (cdr a) b)))))\n    (define\
    \ (divide-helper l mid even)\n      (define-values (mid rest even) (divide l mid\
    \ even))\n      (helper l rest even)))\n  (define-values (mid rest even) (divide-helper\
    \ l l #t))\n  (sort-helper mid rest even))\n", "  (cond\n    [(empty? l) '()]\n\
    \    [(empty? (rest l)) (first l)]\n    [else (begin\n            (set! l (sort\
    \ < l))\n            (median (drop (quotient (length l) 2) l)))]))\n", "  (define\
    \ (swap-if-less i j l)\n    (if (&lt; (list-ref l i) (list-ref l j))\n       \
    \ (let ((tmp (list-ref l i)))\n          (set-car! (list-ref l i) (list-ref l\
    \ j))\n          (set-car! (list-ref l j) tmp))\n        'done))\n  (define (pivot\
    \ l beg end)\n    (let ((i beg) (j (+ beg 1)))\n      (do ((j (+ beg 1)) (j (+\
    \ beg 1)))\n          ((&gt; j end) beg)\n        (swap-if-less beg j l))\n  \
    \    (do ((i beg) (i beg))\n          ((&gt; i end) beg)\n        (swap-if-less\
    \ i beg l))))\n  (define (quick-sort l beg end)\n    (if (&lt; beg end)\n    \
    \    (let ((pivot-index (pivot l beg end)))\n          (quick-sort l beg (- pivot-index\
    \ 1))\n          (quick-sort l (+ pivot-index 1) end))\n        'done))\n  (define\
    \ (sorter l)\n    (let ((mid (quotient (length l) 2)))\n      (quick-sort l 0\
    \ (- (length l) 1))\n      (list-ref l mid)))\n  (sorter l))\n</code>\nI ran a\
    \ performance test to see how long it takes to find the median of lists of increasing\
    \ size.  My results:\n<code>$ time racket -t median-list.rkt\n! n = 8\n! median\
    \ = 8\n! n = 16\n! median = 16\n! n = 32\n! median = 32\n! n = 64\n! median =\
    \ 64\n! n = 128\n! median = 128\n! n = 256\n! median = 256\n! n = 512\n! median\
    \ = 512\n! n = 1024\n! median = 1024\n! n = 2048\n! median = 2048\n! n = 4096\n\
    ! median = 4096\n! n = 8192\n! median = 8192\n! n = 16384\n! median = 16384\n\
    ! n = 32768\n! median = 32768\n! n = 65536\n! median = 655", "  (quicksort l)\n\
    \  (cond [(odd? (length l)) (list-ref l (/ (length l) 2))]\n        [else (/ (+\
    \ (list-ref l (/ (length l) 2)) (list-ref l (- (/ (length l) 2) 1))) 2)]))\n",
  "  (define (length l)\n    (cond\n      [(empty? l) 0]\n      [else (+ 1 (length\
    \ (rest l)))]))\n  (define (nth-smallest n l)\n    (cond\n      [(empty? l) #f]\n\
    \      [(= n 1) (min l)]\n      [else (nth-smallest (- n 1) (remove (min l) l))]))\n\
    \  (define (nth-largest n l)\n    (cond\n      [(empty? l) #f]\n      [(= n 1)\
    \ (max l)]\n      [else (nth-largest (- n 1) (remove (max l) l))]))\n  (define\
    \ (median-of-odds l)\n    (nth-smallest (/ (length l) 2) l))\n  (define (median-of-evens\
    \ l)\n    (/ (+ (nth-smallest (/ (length l) 2) l)\n          (nth-largest (/ (length\
    \ l) 2) l))\n       2))\n  (cond\n    [(odd? (length l)) (median-of-odds l)]\n\
    \    [else (median-of-evens l)]))\n", "  (sort l <)\n  (sort l >)\n  (let ([middle-index\
    \ (/ (length l) 2)])\n    (if (even? (length l))\n        (/ (+ (list-ref l middle-index)\
    \ (list-ref l (- middle-index 1))) 2)\n        (list-ref l middle-index))))\n",
  "  (median-from-sorted l (sort l <)))\n", "  (define (select k lst)\n    (if (empty?\
    \ lst)\n        #f\n        (let ([x (first lst)])\n          (let-values ([(xs\
    \ ys) (partition (lambda (y) (<= y x)) (rest lst))])\n            (if (= k (length\
    \ xs))\n                x\n                (if (< k (length xs))\n           \
    \         (select k xs)\n                    (select (- k (length xs) 1) ys)))))))\n\
    \  (select (quotient (length l) 2) l))\n\n", "  (define (helper l n)\n    (cond\n\
    \      [(= n 0) (first l)]\n      [(= n 1) (round (/ (+ (first l) (second l))\
    \ 2))]\n      [(= n 2) (if (> (first l) (second l)) (first l) (second l))]\n \
    \     [else\n       (cond\n         [(or (= n 3) (= n 4)) (if (< (first l) (second\
    \ l)) (second l) (first l))]\n         [else\n          (define (left-split lst)\n\
    \            (cond\n              [(= (remainder n 2) 0) (rest (rest lst))]\n\
    \              [else (rest lst)]))\n          (define (right-split lst)\n    \
    \        (cond\n              [(= (remainder n 2) 0) (take (quotient n 2) lst)]\n\
    \              [else (take (quotient (+ n 1) 2) lst)]))\n          (define (middle-split\
    \ lst)\n            (cond\n              [(= (remainder n 2) 0) (take 2 (rest\
    \ (rest lst)))]\n              [else (list (second lst))]))\n          (define\
    \ (procces lst)\n            (cond\n              [(= (remainder n 2) 0)\n   \
    \            (if (< (first (left-split lst)) (second (middle-split lst)))\n  \
    \                 (if (< (second (middle-split lst)) (first (right-split lst)))\n\
    \                       (second (middle-split lst))\n                       (if\
    \ (< (first (left-split lst)) (first (right-split lst)))\n                   \
    \        (first (right-split lst))\n                           (first (left-split\
    \ lst))))\n                   (if (< (first (left-split lst)) (first (right-split\
    \ lst)))\n                       (first (right-split lst))\n                 \
    \      (first (left-split lst))))]\n              [else\n               (if (<\
    \ (first (left-split lst)) (first (middle-split lst)))\n                   (if\
    \ (< (first (middle-split lst)) (first (right-split lst)))\n                 \
    \      (first (middle-split", "  (sort l &lt;=&gt;) (length l) (quotient)\n  (if\
    \ (equal? (length l) 1)\n      (first l)\n      (if (equal? (remainder (length\
    \ l) 2) 0)\n          (/ (+ (list-ref l (quotient (length l) 2))\n           \
    \    (list-ref l (1+ (quotient (length l) 2)))) 2)\n          (list-ref l (quotient\
    \ (length l) 2)))))\n</code>\nIn the above median function I get the following\
    \ error:\n<code>list-ref: argument must be an exact integer in [0, 2147483647]\n\
    </code>\nI am using DrRacket. Is there something wrong with my division?\n\n\n\
    A:\n\nYou're calling <code>length</code> twice - once at the beginning to set\
    \ the value of <code>n</code>, and then again every time you call <code>list-ref</code>.\n\
    If the length of the list changes in between calls to <code>list-ref</code>, then\
    \ you'll get the behavior you're seeing.  Instead of the value of <code>n</code>\
    \ changing, the list of items is changing.\nYou'll need to call <code>length</code>\
    \ once, then use <code>n</code> to compute your indices.\n", "  (let [l-sorted\
    \ (sort l <)]\n    (if (odd? (length l-sorted))\n      (list-ref l-sorted (/ (length\
    \ l-sorted) 2))\n      (/ (+ (list-ref l-sorted (/ (length l-sorted) 2))\n   \
    \         (list-ref l-sorted (+ (/ (length l-sorted) 2) 1)))\n         2))))\n",
  "  (cond\n    [(empty? l) 'no-median]\n    [(empty? (rest l)) (first l)]\n    [(empty?\
    \ (rest (rest l)))\n     (/ (+ (first l) (first (rest l))) 2)]\n    [else\n  \
    \   (median (rest (rest l)))]))\n</code>\nTest:\n<code>&gt; (median '(5 2 10))\n\
    5\n&gt; (median '(5 2 10 0))\n5\n&gt; (median '(5 2 10 0 100))\n5\n&gt; (median\
    \ '(5 2 10 0 100 -5))\n5\n&gt; (median '(5 2 10 0 100 -5 2.5))\n5\n&gt; (median\
    \ '(5 2 10 0 100 -5 2.5 7))\n5\n&gt; (median '(5 2 10 0 100 -5 2.5 7 100))\n7\n\
    &gt; (median '(5 2 10 0 100 -5 2.5 7 100 -100))\n5\n&gt; (median '(5 2 10 0 100\
    \ -5 2.5 7 100 -100 0))\n5\n&gt; (median '(5 2 10 0 100 -5 2.5 7 100 -100 0 0))\n\
    5\n&gt; (median '(5 2 10 0 100 -5 2.5 7 100 -100 0 0 0))\n5\n&gt; (median '(5\
    \ 2 10 0 100 -5 2.5 7 100 -100 0 0 0 0))\n5\n&gt; (median '(5 2 10 0 100 -5 2.5\
    \ 7 100 -100 0 0 0 0 0))\n5\n&gt; (median '(5 2 10 0 100 -5 2.5 7 100 -100 0 0\
    \ 0 0 0 0))\n5\n&gt; (median '(5 2 10 0 100 -5 2.5 7 100 -100 0 0 0 0 0 0 0))\n\
    5\n&gt; (median '(5 2 10 0 100 -5 2.5 7 100 -100 0 0 0 0 0 0 0 0))\n5\n&gt; (median\
    \ '(5 2 10 0 100 -5 2.5 7 100 -100 0 0 0 0 0 0 0 0 0))\n5\n&gt;", "  (define (partition\
    \ l p x)\n    (if (null? l)\n        (values '() '() x)\n        (let ((rest (partition\
    \ (cdr l) p (+ x 1))))\n          (match rest\n            [(list less equal more)\n\
    \             (if (= x p)\n                 (values (cons (car l) less)\n    \
    \                     (cons (car l) equal)\n                         more)\n \
    \                (if (&lt; (car l) (car equal))\n                     (values\
    \ (cons (car l) less)\n                             equal\n                  \
    \           more)\n                     (values less\n                       \
    \      equal\n                             (cons (car l) more))))]))))\n  (define\
    \ (nth l n)\n    (if (= n 0)\n        (car l)\n        (nth (cdr l) (- n 1))))\n\
    \  (let* ((l-length (length l))\n         (left (quotient l-length 2))\n     \
    \    (right (- left 1)))\n    (if (odd? l-length)\n        (nth l left)\n    \
    \    (/ (+ (nth l left) (nth l right)) 2.0))))\n</code>\nI'm worried that this\
    \ is too verbose, and I'm not using <code>match</code> properly. Is there a better\
    \ way?\n\n\nA:\n\nI've taken a small simplification by using <code>partition-by</code>\
    \ with <code>=</code> for <code>p</code>. This is the same, except that <code>p</code>\
    \ is not a number, but a predicate. There is no need to fiddle with counting.\
    \ The <code>partition-by</code> is from <code>sequence.rkt</code> as <code>partition</code>\
    \ from <code>list.rkt</code> is a different function. Also, there is no need to\
    \ use <code>values</code> here, as a plain <code>let</code> will do just fine.\n\
    <code>#lang racket\n", "  (if (zero? (length l))\n      (error \"empty list\"\
    )\n      (list-ref (list-sort compare l) (/ (length l) 2))))\n", "  (sort l <)\n\
    \  (define (median' l)\n    (cond\n      [(empty? l) empty]\n      [(empty? (rest\
    \ l)) (first l)]\n      [(odd? (length l))\n       (element-at l (/ (length l)\
    \ 2))]\n      [else\n       (/ (+ (element-at l (/ (length l) 2))\n          \
    \   (element-at l (+ (/ (length l) 2) 1)))\n          2)]))\n  (median' l))\n",
  "  (define (sort l)\n    (if (null? l)\n        '()\n        (append (sort (filter\
    \ (lambda (x) (&lt; x (car l))) (cdr l)))\n                (list (car l))\n  \
    \              (sort (filter (lambda (x) (&gt; x (car l))) (cdr l))))))\n  (define\
    \ (nth-elt l n)\n    (if (= n 0)\n        (car l)\n        (nth-elt (cdr l) (-\
    \ n 1))))\n  (define l-len (length l))\n  (if (odd? l-len)\n      (nth-elt (sort\
    \ l) (/ l-len 2))\n      (/ (+ (nth-elt (sort l) (/ l-len 2))\n            (nth-elt\
    \ (sort l) (- (/ l-len 2) 1)))\n         2)))\n</code>\nI run this on DrRacket\
    \ and it returns the expected result. But, I was asked to explain the Big O of\
    \ this algorithm and I'm not sure what it is. I think it's either O(log n) or\
    \ O(n log n) but I'm not sure. \nWhat is the Big O of this algorithm?\n\n\nA:\n\
    \nThe first thing to notice is that the number of times <code>append</code> is\
    \ called depends on the length of the list. Let's say you have a list of length\
    \ <code>n</code>. Then, at each level of the recursion of <code>sort</code>, <code>append</code>\
    \ is called with a list of length <code>n/2</code>, so the total number of calls\
    \ to <code>append</code> is <code>O(n)</code>.\n<code>append</code> does not itself\
    \ call <code>sort</code>, so we can ignore that.\nEach call to <code>append</code>\
    \ has two calls to <code>filter</code>. <code>filter</code> must iterate over\
    \ the entire list, so this takes <code>O(n)</code> time. You have <code>n</code>\
    \ calls to <code>append</code>, and each <code>append</code> call has <code>2*n</code>\
    \ calls to <code>", "  (let ([mid (quotient (add1 (length l)) 2)])\n    (if (zero?\
    \ (modulo (length l) 2))\n        (quotient (add (list-ref l (- mid 1)) (list-ref\
    \ l mid)) 2)\n        (list-ref l mid))))\n", "  (sort l <)\n  (define (get-middle\
    \ l)\n    (define (helper l n mid)\n      (cond ((null? l) mid)\n            ((=\
    \ n 1) (helper (cdr l) 2 (car l)))\n            ((= n 2) (helper (cdr l) 1 (car\
    \ l)))\n            (else (helper (cdr l) (+ n 1) mid))))\n    (helper l 1 0))\n\
    \  (get-middle l))\n", "  (define (sorted-merge a b)\n    (cond ((null? a) b)\n\
    \          ((null? b) a)\n          ((&lt; (car a) (car b)) (cons (car a) (sorted-merge\
    \ (cdr a) b)))\n          (else (cons (car b) (sorted-merge a (cdr b))))))\n \
    \ (define (get-middle l)\n    (define (helper l n m)\n      (cond ((null? l) (error\
    \ \"Can't happen\"))\n            ((= n m) (car l))\n            (else (helper\
    \ (cdr l) (+ n 1) m))))\n    (helper l 0 (/ (length l) 2)))\n  (get-middle (sorted-merge\
    \ (sort &lt; l) (sort &gt; l))))\n</code>\nFor example:\n<code>&gt; (median '(1\
    \ 2 3 4 5))\n3\n\n&gt; (median '(1 2 3 4 5 6))\n3\n\n&gt; (median '(1 2 3 4 5\
    \ 6 7))\n4\n</code>\n", "  (cond [(empty? l) 0]\n        [(empty? (rest l)) (first\
    \ l)]\n        [(empty? (rest (rest l))) (/ (+ (first l) (second l)) 2)]\n   \
    \     [else (median (sort l))]))\n</code>\nI'm not sure how to make the list be\
    \ a tuple, so I'm assuming that the list is always ordered with integers.\nHere's\
    \ what I have so far:\n<code>#lang typed/racket\n", "  (define l2 (sort l &lt;))\n\
    \  (define n (length l2))\n  (if (even? n)\n      (/ (+ (list-ref l2 (/ n 2))\
    \ (list-ref l2 (- n 1 (/ n 2)))) 2)\n      (list-ref l2 (/ n 2))))\n", "  (let\
    \ loop ([l l])\n    (if (null? l)\n        0\n        (if (null? (cdr l))\n  \
    \          (car l)\n            (if (odd? (length l))\n                (nth (quotient\
    \ (length l) 2) l)\n                (/ (+ (nth (quotient (length l) 2) l)\n  \
    \                    (nth (quotient (length l) 2 -1) l))\n                   2))))))\n",
  "  (sort l &lt;)\n  (quotient (length l) 2))\n", "  (sort l <)\n  (list-ref l (/\
    \ (length l) 2)))\n", "  (define (sorted-merge l1 l2)\n    (cond\n      [(empty?\
    \ l1) l2]\n      [(empty? l2) l1]\n      [(< (first l1) (first l2))\n       (cons\
    \ (first l1) (sorted-merge (rest l1) l2))]\n      [else\n       (cons (first l2)\
    \ (sorted-merge l1 (rest l2)))]))\n  (define (msort l)\n    (cond\n      [(empty?\
    \ l) empty]\n      [(empty? (rest l)) l]\n      [else\n       (let ([(l1 l2) (split\
    \ l)])\n         (sorted-merge (msort l1) (msort l2)))]))\n  (define (median-index\
    \ l)\n    (let ([len (length l)])\n      (if (even? len)\n          (/ (- len\
    \ 1) 2)\n          (/ len 2))))\n  (list-ref (msort l) (median-index l)))\n",
  "  (let ([len (length l)])\n    (if (= 1 len)\n        (car l)\n        (if (even?\
    \ len)\n            (apply + (take l (/ len 2) (/ len 2)))\n            (list-ref\
    \ l (/ len 2))))))\n", "  (define (median-helper sorted-l)\n    (if (even? (length\
    \ sorted-l))\n        (let ([m (/ (length sorted-l) 2)])\n          (/ (+ (list-ref\
    \ sorted-l m) (list-ref sorted-l (- m 1))) 2))\n        (list-ref sorted-l (/\
    \ (length sorted-l) 2))))\n  (median-helper (sort < l)))\n", "  (local [(define\
    \ (quicksort l comparator)\n            (cond [(empty? l) '()]\n             \
    \     [else\n                   (let ([pivot (first l)])\n                   \
    \  (append (quicksort (filter (\u03BB (x) (comparator x pivot)) (rest l)) comparator)\n\
    \                             (list pivot)\n                             (quicksort\
    \ (filter (\u03BB (x) (not (comparator x pivot))) (rest l)) comparator)))]))]\n\
    \    (define (length-of-list l)\n      (cond [(empty? l) 0]\n            [else\
    \ (+ 1 (length-of-list (rest l)))]))\n    (define (length-of-list-1 l)\n     \
    \ (cond [(empty? l) 0]\n            [else (+ 1 (length-of-list (rest l)))]))\n\
    \    (let ([sorted-l (quicksort l <)])\n      (cond [(odd? (length-of-list l))\n\
    \             (list-ref sorted-l (/ (length-of-list l) 2))]\n            [else\n\
    \             (/ (+ (list-ref sorted-l (/ (length-of-list l) 2))\n           \
    \        (list-ref sorted-l (/ (length-of-list-1 l) 2)))\n                2)]))))\n",
  "  (letrec ([median1 (lambda (l m)\n                      (if (empty? l)\n     \
    \                     m\n                          (median1 (cdr l) (car l))))]\n\
    \           [median2 (lambda (l m)\n                      (if (empty? l)\n   \
    \                       m\n                          (median2 (cdr l) (car l))))])\n\
    \    (let ([l1 (sort l <)])\n      (/ (+ (median1 l1 (first l1))\n           \
    \ (median2 l1 (first l1)))\n         2))))\n", "  (define (med l)\n    (cond\n\
    \      [(empty? l) 0]\n      [(empty? (rest l)) (first l)]\n      [(empty? (rest\
    \ (rest l))) (/ (+ (first l) (second l)) 2)]\n      [else (med (rest l))]))\n\
    \  (cond\n    [(empty? l) 0]\n    [(empty? (rest l)) (first l)]\n    [(empty?\
    \ (rest (rest l))) (/ (+ (first l) (second l)) 2)]\n    [else (med (rest l))]))\n",
  "  (median-quick l (quotient (length l) 2)))\n", "  (cond\n    ((empty? l) '())\n\
    \    ((empty? (rest l)) (first l))\n    ((empty? (rest (rest l)))\n     (/ (+\
    \ (first l) (first (rest l))) 2))\n    (else\n     (let* ((lt l)\n           \
    \ (rt (rest (rest l)))\n            (middle (quotient (length l) 2)))\n      \
    \ (if (zero? (remainder (length l) 2))\n           (cond\n             ((&lt;\
    \ (first lt) (first rt))\n              (median lt))\n             ((&gt; (first\
    \ lt) (first rt))\n              (median rt))\n             (else\n          \
    \    (first lt)))\n           (cond\n             ((&lt; (first lt) (first rt))\n\
    \              (median (rest lt)))\n             ((&gt; (first lt) (first rt))\n\
    \              (median (rest rt)))\n             (else\n              (first lt))))))))\n\
    </code>\nThe algorithm depends on the function <code>median</code> (that sorts\
    \ the list, this is not the point) so that it can use only the first and last\
    \ elements of the list. It returns the median of l, a list of elements. In the\
    \ case that the list has an even number of elements, the function return the mean\
    \ of the two elements in the middle of the list. In the case of an odd number\
    \ of elements, it returns the middle element.\n<code>median</code> uses a binary\
    \ search scheme in which it recursively computes the median of the left and right\
    \ part of the list (both equal in number). If both elements are equal, then we\
    \ have found the median and we can stop. If the two elements are different, we\
    \ make another recursive call, on the list that contains the smaller element.\n",
  "  (define (median-inner l len)\n    (cond\n      [(empty? l) (error \"median: list\
    \ should have even number of elements\")]\n      [(null? (rest l)) (first l)]\n\
    \      [(= len 2) (/ (+ (first l) (first (rest l))) 2)]\n      [(= (modulo len\
    \ 2) 0)\n       (median-inner (rest l) (- len 1))]\n      [else\n       (median-inner\
    \ (rest l) (- len 1))]))\n  (median-inner l (length l)))\n", "  (define (median-helper\
    \ s l)\n    (cond [(or (null? l) (zero? s)) l]\n          [(even? s) (cons (car\
    \ l) (median-helper (/ s 2) (cdr l)))]\n          [else (median-helper (/ s 2)\
    \ (cdr l))]))\n  (let ([n (length l)])\n    (if (even? n)\n        (/ (+ (apply\
    \ + (median-helper (/ n 2) l))\n              (apply + (median-helper (/ n 2)\
    \ (cdr l))))\n           2)\n        (apply + (median-helper (/ n 2) l)))))\n\
    </code>\n", "  (define len (length l))\n  (if (and (positive? len) (odd? len))\n\
    \      (median l (quotient len 2))\n      (define l2 (quotient len 2))\n     \
    \ (define (get-nth-index l n)\n        (cond\n          [(null? l) #f]\n     \
    \     [(zero? n) (car l)]\n          [else (get-nth-index (cdr l) (sub1 n))]))\n\
    \      (define el1 (get-nth-index l (sub1 l2)))\n      (define el2 (get-nth-index\
    \ l l2))\n      (define (is-even? n)\n        (or (zero? n) (is-even? (sub1 n))))\n\
    \      (if (is-even? l2)\n          (quotient (+ el1 el2) 2)\n          el2)))\n",
  "  (define l (sort l <))\n  (if (odd? (length l))\n      (list-ref l (/ (length\
    \ l) 2))\n      (/ (+ (list-ref l (/ (length l) 2))\n            (list-ref l (-\
    \ (/ (length l) 2) 1)))\n         2)))\n", "  (define l (sort l))\n  (cond ((=\
    \ (length l) 0) '())\n        ((= (length l) 1) (car l))\n        ((even? (length\
    \ l)) (/ (+ (list-ref l (/ (length l) 2))\n                                  (list-ref\
    \ l (- (/ (length l) 2) 1)))\n                               2))\n        (else\
    \ (list-ref l (/ (length l) 2)))))\n", "  (median-helper (sort l <)))\n", "  (let*\
    \ ((sorted (sort l (\u03BB (x y) (&lt; x y))))\n         (middle (quotient (length\
    \ sorted) 2)))\n    (if (even? (length sorted))\n        (let* ((i middle)\n \
    \              (before (list-ref sorted i))\n               (after (list-ref sorted\
    \ (add1 i))))\n          (/ (+ before after) 2))\n        (list-ref sorted middle))))\n\
    </code>\nIf the list has an even number of elements, you can use <code>list-ref</code>\
    \ to get the two values that immediately surround the median and average them.\
    \ Otherwise, you just use <code>list-ref</code> to extract the median, because\
    \ it's in the middle of the list.\n", "  (if (null? l)\n      (error \"median:\
    \ list is empty\")\n      (let* ([nl (length l)]\n             [n (quotient nl\
    \ 2)])\n        (if (odd? nl)\n            (list-ref l n)\n            (let* ([n\
    \ (quotient nl 2)]\n                   [e1 (list-ref l n)]\n                 \
    \  [e2 (list-ref l (- n 1))])\n              (/ (+ e1 e2) 2))))))\n", "  (define\
    \ xl (sort l &lt;))\n  (define xln (length xl))\n  (cond\n    [(odd? xln)\n  \
    \   (list-ref xl (/ xln 2))]\n    [else\n     (/ (apply + (map number? (take xln\
    \ 2))) 2)]))\n</code>\nThis work:\n<code>#lang racket\n", "  (sort l &lt;))\n",
  "  (define sorted-l (sort l &lt;))\n  (define len (length sorted-l))\n  (if (even?\
    \ len)\n      (define (inner l)\n        (define mid (quotient len 2))\n     \
    \   (define mid+1 (+ mid 1))\n        (define a (list-ref l mid))\n        (define\
    \ b (list-ref l mid+1))\n        (/ (+ a b) 2))\n      (define (inner l)\n   \
    \     (define mid (quotient len 2))\n        (list-ref l mid))))\n</code>\nI am\
    \ however getting these errors:\n<code>dynamic-require: \"~a\" does not exist;\
    \ cannot provide #%module-begin\n  module: d:\\Programming\\Racket\\Racket\\median.rkt\n\
    \  from: d:\\Programming\\Racket\\Racket\\median.rkt\n\ndynamic-require: \"~a\"\
    \ does not exist; cannot provide #%module-begin\n  module: d:\\Programming\\Racket\\\
    Racket\\median.rkt\n  from: d:\\Programming\\Racket\\Racket\\median.rkt\n</code>\n\
    Any ideas?\n\n\nA:\n\nYou have to provide at least one function to export.  I\
    \ think what you mean to say is\n<code>#lang racket\n", "  (let ([l (sort l)])\n\
    \    (if (even? (length l))\n        (quotient (+ (list-ref l (/ (length l) 2))\n\
    \                      (list-ref l (add1 (/ (length l) 2))))\n               \
    \    2)\n        (list-ref l (/ (length l) 2)))))\n", "  (let ([l (sort < l)])\n\
    \    (if (odd? (length l))\n        (list-ref l (quotient (length l) 2))\n   \
    \     (/ (+ (list-ref l (quotient (length l) 2))\n              (list-ref l (1+\
    \ (quotient (length l) 2))))\n           2))))\n", "  (let ([l (sort l &lt;)])\n\
    \    (if (even? (length l))\n        (/ (+ (nth l (/ (length l) 2))\n        \
    \      (nth l (- (/ (length l) 2) 1)))\n           2)\n        (nth l (/ (length\
    \ l) 2)))))\n", "  (let* ([sorted (sort l &lt;)]\n         [n (length sorted)])\n\
    \    (if (zero? (remainder n 2))\n        (/ (+ (list-ref sorted (/ n 2))\n  \
    \            (list-ref sorted (- (/ n 2) 1)))\n           2)\n        (list-ref\
    \ sorted (/ n 2)))))\n</code>\nI was thinking about the following usage:\n<code>(median\
    \ '(2 3 5 8 9))", "  (let loop ((l l) (r '()))\n    (cond ((null? l) (car r))\n\
    \          ((null? (cdr l)) (list (car l) (car r)))\n          (else (loop (cdr\
    \ l) (cons (car l) r))))))\n", "  (define (nth-of-two-sorted-lists n l1 l2)\n\
    \    (cond ((or (null? l1) (null? l2)) (car l1))\n          ((zero? n) (min (car\
    \ l1) (car l2)))\n          (else (nth-of-two-sorted-lists (- n 1) (cdr l1) (cdr\
    \ l2)))))\n  (define (nth-of-two-sorted-lists-with-lengths n len1 len2)\n    (if\
    \ (odd? (+ len1 len2))\n        (nth-of-two-sorted-lists (/ (+ len1 len2) 2) l1\
    \ l2)\n        (let ((m1 (nth-of-two-sorted-lists (/ len1 2) l1 l2))\n       \
    \       (m2 (nth-of-two-sorted-lists (/ len2 2) l1 l2)))\n          (/ (+ m1 m2)\
    \ 2))))\n  (if (or (null? l) (null? (cdr l)))\n      (car l)\n      (nth-of-two-sorted-lists-with-lengths\
    \ 0 (length l) (length (cdr l)))))\n</code>\n", "  (cond\n    [(empty? l) (error\
    \ \"Median of empty list\")]\n    [(empty? (rest l)) (first l)]\n    [(even? (length\
    \ l)) (/ (+ (list-ref l (/ (length l) 2))\n                              (list-ref\
    \ l (- (/ (length l) 2) 1)))\n                           2)]\n    [else (list-ref\
    \ l (/ (length l) 2))]))\n", "  (define (merge l1 l2)\n    (cond ((null? l1) l2)\n\
    \          ((null? l2) l1)\n          ((< (car l1) (car l2))\n           (cons\
    \ (car l1) (merge (cdr l1) l2)))\n          (else\n           (cons (car l2) (merge\
    \ l1 (cdr l2))))))\n  (define (sort l)\n    (define (sort2 l l1 l2)\n      (cond\
    \ ((null? l) (merge (sort l1) (sort l2)))\n            ((null? l1) (cons (car\
    \ l) (sort2 (cdr l) l2 '())))\n            ((null? l2) (cons (car l) (sort2 (cdr\
    \ l) '() l1)))\n            (else (cons (car l) (sort2 (cdr l) l2 l1)))))\n  \
    \  (cond ((null? l) '())\n          ((null? (cdr l)) l)\n          (else (sort2\
    \ l '() '()))))\n  (define (helper l)\n    (cond ((null? l) '())\n          ((null?\
    \ (cdr l)) l)\n          ((null? (cdr (cdr l))) l)\n          (else (helper (cdr\
    \ l)))))\n  (cond ((null? l) '())\n        ((null? (cdr l)) (car l))\n       \
    \ ((null? (cdr (cdr l))) (/ (+ (car l) (car (cdr l))) 2))\n        (else\n   \
    \      (define l (sort l))\n         (helper l))))\n", "  (if (null? l)\n    \
    \  (error \"Empty list\")\n      (let* ([sorted (sort l <)]\n             [n (length\
    \ sorted)]\n             [m (/ n 2)])\n        (if (even? n)\n            (/ (+\
    \ (list-ref sorted m) (list-ref sorted (- m 1))) 2)\n            (list-ref sorted\
    \ m)))))\n", "  (define l (sort l <))\n  (let ([mid (quotient (length l) 2)])\n\
    \    (if (odd? (length l))\n        (list-ref l mid)\n        (quotient (+ (list-ref\
    \ l mid) (list-ref l (add1 mid))) 2))))\n", "  (let ([l (sort l <)])\n    (cond\n\
    \      [(empty? l) 'empty]\n      [(odd? (length l))\n       (list-ref l (/ (length\
    \ l) 2))]\n      [else\n       (/ (+ (list-ref l (/ (length l) 2))\n         \
    \   (list-ref l (- (/ (length l) 2) 1)))\n          2)])))\n", "  (cond [(empty?\
    \ l) 0]\n        [(empty? (rest l)) (first l)]\n        [(< (even? (length l))\
    \ 1) \n         (/ (+ (list-ref l (/ (length l) 2))\n              (list-ref l\
    \ (- (/ (length l) 2) 1))) 2)]\n        [else (list-ref l (/ (length l) 2))]))\n",
  "  (quicksort l))\n</code>\nIt compiles, but when I try to run it, I get:\n<code>Welcome\
    \ to DrRacket, version 6.12 [3m].\nLanguage: racket [custom]; memory limit: 128\
    \ MB.\n&gt; (median '(7 2 0 4 5 7 9 1))\nquicksort: contract violation\n  expected:\
    \ list?\n  given: '(7 2 0 4 5 7 9 1)\n  context...:\n   /Applications/Racket v6.12/collects/racket/private/misc.rkt:87:7\n\
    \n&gt; \n</code>\nAny thoughts?\n\n\nA:\n\nYou are passing a list to the <code>quicksort</code>\
    \ function, but that function expects two arguments: a function and a list. The\
    \ first argument is the comparison function (which you can either pass directly\
    \ or use <code>&lt;</code>). Try this:\n<code>(quicksort &lt; l)\n</code>\n",
  "  (define (sort-helper l1 l2)\n    (cond [(null? l1) l2]\n          [(null? l2)\
    \ l1]\n          [(< (car l1) (car l2))\n           (cons (car l1) (sort-helper\
    \ (cdr l1) l2))]\n          [else\n           (cons (car l2) (sort-helper l1 (cdr\
    \ l2)))]))\n  (define (sort l)\n    (if (null? l) '()\n        (sort-helper (sort\
    \ (filter odd? l))\n                     (sort (filter even? l)))))\n  (define\
    \ (median-helper ln)\n    (if (= 1 ln) (car l)\n        (if (= 2 ln) (/ (+ (car\
    \ l) (cadr l)) 2)\n            (median-helper (- ln 2)))))\n  (define ln (length\
    \ l))\n  (median-helper (sort l)))\n", "  (define (sort-list l)\n    (sort l &lt;))\n\
    \  (define (length l)\n    (length l))\n  (define (nth l n)\n    (nth l n))\n\
    \  (define (half l)\n    (/ (length l) 2))\n  (cond [(empty? l) (error \"Median\
    \ of empty list!\")]\n        [(even? (length l)) (+ (nth (sort-list l) (half\
    \ l)) (nth (sort-list l) (- (half l) 1))) 2]\n        [(odd? (length l)) (nth\
    \ (sort-list l) (half l))]))\n</code>\nThe error I get is: \"application: not\
    \ a procedure; expected a procedure that can be applied to arguments\". My guess\
    \ is that it has something to do with it not knowing what \"length\" and \"nth\"\
    \ are. Is there any way for me to get around this?\n\n\nA:\n\nThe <code>length</code>\
    \ and <code>nth</code> functions you defined are shadowing the library functions.\
    \ To fix this, use a different name for your version of the functions.\nAnother\
    \ problem is that you're using <code>length</code> to calculate the length of\
    \ a list. To do this, you have to apply <code>length</code> to a list, so you\
    \ have to have something like <code>(length '(1 2 3))</code>. To fix this, use\
    \ <code>list-length</code> (instead of <code>length</code>) to calculate the length\
    \ of the list.\nOne more problem is that you're dividing integers. <code>/</code>\
    \ expects two numbers and returns a number, so you have to use <code>/</code>\
    \ instead of <code>//</code>.\n", "  (let ((n (length l)))\n    (if (odd? n)\n\
    \        (list-ref l (quotient n 2))\n        (quotient (+ (list-ref l (/ n 2))\
    \ (list-ref l (- n 1))) 2))))\n", "  (define (sort l)\n    (if (null? l)\n   \
    \     l\n        (append (sort (filter (lambda (x) (&lt; x (car l))) (cdr l)))\n\
    \                (list (car l))\n                (sort (filter (lambda (x) (&gt;\
    \ x (car l))) (cdr l))))))\n  (if (even? (length l))\n      (/ (+ (list-ref (sort\
    \ l) (/ (length l) 2))\n            (list-ref (sort l) (- (/ (length l) 2) 1)))\n\
    \         2)\n      (list-ref (sort l) (/ (length l) 2))))\n</code>\nThe program\
    \ is simple to understand, if you're comfortable with higher-order functions,\
    \ of course. The helper function <code>sort</code> is a standard quicksort which,\
    \ given a list, returns a new sorted list.\nThe median function starts by sorting\
    \ the list, and then it simply returns the middle element of the list if there\
    \ is an odd number of elements, or the mean of the two middle elements otherwise.\n\
    I think I've made two mistakes:\n\nI've written the <code>sort</code> function\
    \ recursively. This is rather stupid, since this will often results in stack overflow,\
    \ depending on the length of the list.\nI've written the <code>sort</code> function\
    \ with three recursive calls, so it really isn't a quicksort. \n\nI would like\
    \ to rewrite <code>sort</code> with tail recursion and with only two recursive\
    \ calls.\nI know that I could use the built-in <code>sort</code> function, but\
    \ what I'm looking for is an exercise in implementing tail recursion and a way\
    \ to produce sorted lists.\n\n\nA:\n\nThe problem is that, for sorting, you need\
    \ a comparison function, but <code>list-ref</code> is only defined for integers.\n\
    <code>(list-ref '(#\\a #\\b #\\c) 1) ; ==&gt; #\\b", "  (if (empty? l)\n     \
    \ 0\n      (if (pair? l)\n          (if (equal? (length l) 1)\n              (car\
    \ l)\n              (apply / (cons\n                        (apply + l)\n    \
    \                    (cons (length l) empty)))))))\n", "  (define (median-helper\
    \ l left right)\n    (cond [(empty? l) #f]\n          [(= left right) (first l)]\n\
    \          [else (median-helper (rest l) (+ left 1) right)]))\n  (median-helper\
    \ l 0 (quotient (length l) 2)))\n", "  (if (even? (length l))\n      (/ (+ (car\
    \ (sort l)) (car (reverse (sort l)))) 2)\n      (car (sort l))))\n", "  (define\
    \ n (length l))\n  (if (zero? n) 0 (if (odd? n) (list-ref l (/ n 2)) (/ (+ (list-ref\
    \ l (/ n 2)) (list-ref l (+ 1 (/ n 2)))) 2))))\n", "  (let* ([sorted (sort l &lt;)]\n\
    \         [n (length sorted)])\n    (if (even? n)\n        (/ (+ (list-ref sorted\
    \ (/ n 2))\n              (list-ref sorted (- n (/ n 2))))\n           2)\n  \
    \      (list-ref sorted (/ n 2)))))\n</code>\nNote that <code>sort</code> is not\
    \ a stable sort, so if you want to preserve the original relative order of elements\
    \ you should probably use <code>sort!</code> and <code>sort</code> and then <code>copy</code>\
    \ the list.\n", "  (define (get-elem k l)\n    (cond\n      [(empty? l) (error\
    \ \"k-th element of an empty list?\")]\n      [(= k 0) (first l)]\n      [else\
    \ (get-elem (- k 1) (rest l))]))\n  (cond\n    [(empty? l) (error \"median of\
    \ an empty list?\")]\n    [(even? (length l))\n     (/ (+ (get-elem (/ (length\
    \ l) 2) l)\n           (get-elem (- (/ (length l) 2) 1) l))\n        2)]\n   \
    \ [else (get-elem (/ (length l) 2) l)]))\n", "  (define (median/helper l min max)\n\
    \    (cond\n      ((= min max) (list-ref l min))\n      ((&gt; (list-length l)\
    \ 0)\n       (let ((mid (/ (+ min max) 2)))\n         (if (&gt; (list-ref l mid)\
    \ (list-ref l (- mid 1)))\n             (median/helper l mid max)\n          \
    \   (median/helper l min (- mid 1)))))))\n  (median/helper l 0 (- (list-length\
    \ l) 1)))\n", "  (define (select k l)\n    (define (select-iter left right)\n\
    \      (if (= left right)\n          (list-ref l left)\n          (let* ([pivot\
    \ (select-iter (+ left 1) right)]\n                 [first (list-ref l left)]\n\
    \                 [last (list-ref l right)]\n                 [median (list-ref\
    \ l (quotient (+ left right) 2))])\n            (cond [(<= pivot first) (if (<=\
    \ last pivot) pivot (if (<= first last) first last))]\n                  [(<=\
    \ pivot last) (if (<= first pivot) pivot (if (<= last first) last first))]\n \
    \                 [(<= pivot median) (if (<= first pivot) pivot (if (<= median\
    \ first) median first))]\n                  [(<= pivot median) (if (<= median\
    \ pivot) pivot (if (<= first median) first median))]\n                  [else\
    \ (error \"Should not happen\")]))))\n    (let* ([n (length l)])\n      (if (=\
    \ n 0)\n          (error \"Empty list\")\n          (select-iter 0 (- n 1)))))\n\
    \  (define (sort l)\n    (cond [(empty? l) '()]\n          [else (cons (median\
    \ l) (sort (remove (median l) l)))]))\n  (median (sort l)))\n", "  (define (median-help\
    \ l s)\n    (cond [(empty? l) (error \"median called on empty list\")]\n     \
    \     [(empty? (rest l)) (first l)]\n          [(empty? (rest (rest l))) (/ (+\
    \ (first l) (second l)) 2)]\n          [else (median-help (rest l) (if (&lt; (first\
    \ l) (first (rest l)))\n                                           (append s (list\
    \ (first l)))\n                                           (append s (list (first\
    \ (rest l))))))]))\n  (median-help l '()))\n</code>\n", "  (define lst-size (length\
    \ l))\n  (define lst-mean (/ lst-size 2))\n  (define lst-half (quotient lst-size\
    \ 2))\n  (define lst-mid (quotient lst-mean 2))\n  (cond ((= lst-size 1) (car\
    \ l))\n        ((or (= lst-size 2) (= lst-mean lst-half))\n          (/ (+ (list-ref\
    \ l 0) (list-ref l (- lst-size 1))) 2))\n        (else (cond\n               \
    \ ((even? lst-size)\n                  (/ (+ (list-ref l lst-mid) (list-ref l\
    \ (- lst-mid 1))) 2))\n                (else (list-ref l lst-mid))))))\n", " \
    \ (define (find-median l)\n    (cond [(empty? l) '()]\n          [(empty? (rest\
    \ l)) (first l)]\n          [(empty? (rest (rest l))) (second l)]\n          [else\n\
    \           (let* ([mid (quotient (length l) 2)]\n                  [l1 (take\
    \ l mid)]\n                  [l2 (drop l (add1 mid))])\n             (if (< (first\
    \ l1) (first l2))\n                 (find-median l1)\n                 (find-median\
    \ l2)))]))\n  (find-median (sort (flatten l) <)))\n", "  (define len (length l))\n\
    \  (if (even? len)\n      (begin\n        (define l1 (list-ref l (/ len 2)))\n\
    \        (define l2 (list-ref l (- (/ len 2) 1)))\n        (/ (+ l1 l2) 2))\n\
    \      (list-ref l (/ len 2))))\n", "  (cond\n    [(empty? l)\n     (error \"\
    median: empty list\")]\n    [(= (length l) 1)\n     (first l)]\n    [(= (length\
    \ l) 2)\n     (/ (+ (first l) (second l)) 2)]\n    [else\n     (let ([sorted (sort\
    \ l &lt;)])\n       (median-of-sorted-list sorted))]))\n", "  (let ([sorted (sort\
    \ (lambda (x y) (< x y)) l)])\n    (if (odd? (length sorted))\n        (list-ref\
    \ sorted (/ (length sorted) 2))\n        (/ (+ (list-ref sorted (/ (length sorted)\
    \ 2))\n              (list-ref sorted (+ (/ (length sorted) 2) 1)))\n        \
    \   2))))\n", "  (if (empty? l)\n      0\n      (cond [(odd? (length l))\n   \
    \          (list-ref l (quotient (length l) 2))]\n            [else\n        \
    \     (/ (+ (list-ref l (quotient (length l) 2))\n                    (list-ref\
    \ l (- (quotient (length l) 2) 1)))\n                2)])))\n</code>\nThe function\
    \ accepts an input list of numbers and returns a single number which is the median\
    \ of the list. The median is the middle number when the numbers are sorted in\
    \ increasing order. If the input list contains an even number of elements then\
    \ the median is the average of the two middle numbers.\nMy question is: what do\
    \ I need to modify in the code to accept an input list of strings and return a\
    \ string which is the median of the list?\nI am on a Mac and I use DrRacket.\n\
    \n\nA:\n\nSince you already have the algorithm for finding the median of a list,\
    \ you can just convert the elements to compare from strings to numbers. A good\
    \ way to do that is to convert them to <code>bytes</code> first.\n<code>(define\
    \ (byte-median l)\n  (if (empty? l)\n      0\n      (cond [(odd? (length l))\n\
    \             (list-ref l (quotient (length l) 2))]\n            [else\n     \
    \        (/ (+ (list-ref l (quotient (length l) 2))\n                    (list-ref\
    \ l (- (quotient (length l) 2) 1)))\n                2)])))\n", "  (cond\n   \
    \ [(null? l) 0]\n    [(= (length l) 1) (car l)]\n    [(= (length l) 2) (/ (+ (car\
    \ l) (cadr l)) 2)]\n    [else\n     (let ([(mid . rst) (split-at-half l)])\n \
    \      (cond\n         [(= (length l) (length mid)) mid]\n         [else\n   \
    \       (median\n           (append (butlast mid) rst))]))]))\n", "  (define (length\
    \ l)\n    (cond\n      [(empty? l) 0]\n      [else (+ 1 (length (rest l)))]))\n\
    \  (define (sort f l)\n    (cond\n      [(empty? l) empty]\n      [else (insert\
    \ f (first l) (sort f (rest l)))]))\n  (define (insert f e l)\n    (cond\n   \
    \   [(empty? l) (list e)]\n      [(f e (first l)) (cons e l)]\n      [else (cons\
    \ (first l) (insert f e (rest l)))]))\n  (define (half l)\n    (quotient (length\
    \ l) 2))\n  (define (mid-element l)\n    (cond\n      [(odd? (length l)) (list-ref\
    \ l (half l))]\n      [else (list-ref l (half l))]))\n  (mid-element (sort < l)))",
  "  (define (select l n)\n    (let loop ([lst l] [n n])\n      (if (or (null? lst)\
    \ (= n 0))\n          lst\n          (loop (cdr lst) (- n 1)))))\n  (define (merge\
    \ l1 l2)\n    (cond\n      [(null? l1) l2]\n      [(null? l2) l1]\n      [(< (car\
    \ l1) (car l2)) (cons (car l1) (merge (cdr l1) l2))]\n      [else (cons (car l2)\
    \ (merge l1 (cdr l2)))]))\n  (define (slice l l0 r0)\n    (cond\n      [(null?\
    \ l) '()]\n      [(&lt; (car l) l0) (slice (cdr l) l0 r0)]\n      [(&gt; (car\
    \ l) r0) '()]\n      [else (cons (car l) (slice (cdr l) l0 r0))]))\n  (define\
    \ (median1 l)\n    (let* ([n (length l)]\n           [s (slice l (median l) (median\
    \ l))]\n           [m (median s)])\n      (cond\n        [(= (modulo n 2) 0) m]\n\
    \        [else (/ (+ m (median (select l (quotient n 2)))) 2)])))\n  (cond\n \
    \   [(= (length l) 1) (car l)]\n    [(= (length l) 2) (/ (+ (car l) (cadr l))\
    \ 2)]\n    [else (median1 (merge (median (slice l (median l) (median l)))\n  \
    \                        (median (slice l (median l) (median l)))))]))\n</code>\n",
  "  (let ([n (length l)])\n    (if (even? n)\n        (let ([m (/ n 2)])\n      \
    \    (/ (+ (list-ref l m) (list-ref l (- m 1))) 2))\n        (list-ref l (/ n\
    \ 2)))))\n", "  (define l2 (sort l))\n  (if (odd? (length l2))\n      (list-ref\
    \ l2 (/ (length l2) 2))\n      (/ (+ (list-ref l2 (/ (length l2) 2)) (list-ref\
    \ l2 (- (/ (length l2) 2) 1))) 2)))\n", "  (let* ([n (length l)]\n         [m\
    \ (quotient n 2)])\n    (if (even? n)\n        (quotient (+ (list-ref l m) (list-ref\
    \ l (- m 1))) 2)\n        (list-ref l m))))\n", "  (define (sort l1 l2)\n    (if\
    \ (empty? l1)\n        l2\n        (if (empty? l2)\n            l1\n         \
    \   (if (&lt; (first l1) (first l2))\n                (cons (first l1) (sort (rest\
    \ l1) l2))\n                (cons (first l2) (sort l1 (rest l2)))))))\n  (let\
    \ ((len (length l)))\n    (if (zero? (remainder len 2))\n        (let ((m (quotient\
    \ len 2)))\n          (/ (+ (list-ref l (- m 1)) (list-ref l m)) 2))\n       \
    \ (list-ref (sort l (list-ref l (quotient len 2))) (quotient len 2)))))\n</code>\n",
  "  (cond\n    [(empty? l) 0]\n    [(= (modulo (length l) 2) 1)\n     (list-ref l\
    \ (quotient (length l) 2))]\n    [else\n     (let ([left (median (sublist l 0\
    \ (quotient (length l) 2)))]\n           [right (median (sublist l (quotient (length\
    \ l) 2) (length l)))])\n       (/ (+ left right) 2))]))\n</code>\nIt's very similar\
    \ to my previous code (https://stackoverflow.com/a/11721873/1691276).\n", "  (define\
    \ sorted-l (sort l <))\n  (cond ((even? (length sorted-l))\n         (/ (+ (list-ref\
    \ sorted-l (/ (length sorted-l) 2))\n              (list-ref sorted-l (- (/ (length\
    \ sorted-l) 2) 1)))\n            2))\n        (else (list-ref sorted-l (/ (length\
    \ sorted-l) 2)))))\n```\n\n```racket\n#lang racket\n", "  (define (select l)\n\
    \    (define (select-inner l pivot lt eq gt)\n      (cond [(empty? l) (values\
    \ lt (cons pivot eq) gt)]\n            [(< (first l) pivot) (select-inner (rest\
    \ l) pivot (cons (first l) lt) eq gt)]\n            [(= (first l) pivot) (select-inner\
    \ (rest l) pivot lt (cons (first l) eq) gt)]\n            [else (select-inner\
    \ (rest l) pivot lt eq (cons (first l) gt))]))\n    (select-inner l (first l)\
    \ '() '() '()))\n  (define (median-inner l)\n    (cond [(empty? l) 0]\n      \
    \    [(empty? (rest l)) (first l)]\n          [(= (length l) 2) (/ (+ (first l)\
    \ (second l)) 2)]\n          [else (begin\n                  (define (select l)\n\
    \                    (define (select-inner l pivot lt eq gt)\n               \
    \       (cond [(empty? l) (values lt (cons pivot eq) gt)]\n                  \
    \          [(< (first l) pivot) (select-inner (rest l) pivot (cons (first l) lt)\
    \ eq gt)]\n                            [(= (first l) pivot) (select-inner (rest\
    \ l) pivot lt (cons (first l) eq) gt)]\n                            [else (select-inner\
    \ (rest l) pivot lt eq (cons (first l) gt))]))\n                    (select-inner\
    \ l (first l) '() '() '()))\n                  (define (median-inner l)\n    \
    \                (cond [(empty? l) 0]\n                          [(empty? (rest\
    \ l)) (first l)]\n                          [(= (length l) 2) (/ (+ (first l)\
    \ (second l)) 2)]\n                          [else (begin\n                  \
    \                (define (select l)\n                                    (define\
    \ (select-inner l pivot lt eq gt)\n                                      (cond\
    \ [(empty? l) (values lt (cons pivot eq) gt)]\n                              \
    \              [(< (first l) pivot) (select-inner (rest l) pivot (cons (", " \
    \ (define len (length l))\n  (define half-len (quotient len 2))\n  (cond\n   \
    \ [(= len 1) (car l)]\n    [(= len 2) (quotient (+ (car l) (cadr l)) 2)]\n   \
    \ [(= (modulo len 2) 0) (list-ref l half-len)]\n    [else\n     (quotient (+ (list-ref\
    \ l half-len) (list-ref l (- half-len 1))) 2)]))\n", "  (define (insert l e k)\n\
    \    (cond\n      [(empty? l) (cons e empty)]\n      [(= k 0) (cons e l)]\n  \
    \    [else (cons (first l) (insert (rest l) e (- k 1)))]))\n  (define (insertion-sort\
    \ l)\n    (if (empty? l) empty\n        (insert (insertion-sort (rest l)) (first\
    \ l)\n                (count (lambda (e) (&lt; e (first l))) (rest l)))))\n  (define\
    \ (median-helper l k)\n    (cond\n      [(empty? l) 0]\n      [(= k 0) (first\
    \ l)]\n      [else (median-helper (rest l) (- k 1))]))\n  (median-helper (insertion-sort\
    \ l) (quotient (length l) 2)))\n</code>\nSample query:\n<code>(median (list 1\
    \ 4 3 2 5)) ; 3\n</code>\nI appreciate any pointers to improving the code.\n",
  "  (let ([n (length l)])\n    (define (median-with-size l' n')\n      (cond\n  \
    \      [(= n' 1) (car l')]\n        [(= n' 2) (/ (+ (car l') (cadr l')) 2)]\n\
    \        [(= (modulo n' 2) 0)\n         (/ (+ (median-with-size (drop (quotient\
    \ n' 2) l') (quotient n' 2))\n                  (median-with-size (take (quotient\
    \ n' 2) l') (quotient n' 2)))\n            2)]\n        [else (median-with-size\
    \ (drop (quotient (add1 n') 2) l')\n                                (quotient\
    \ (add1 n') 2))]))\n    (median-with-size (sort l <) n)))\n", "  (define (sort-list\
    \ l)\n    (sort l <))\n  (define (median-list l)\n    (cond [(= (length l) 0)\
    \ #f]\n          [(= (length l) 1) (car l)]\n          [(= (modulo (length l)\
    \ 2) 0) (/ (+ (list-ref l (/ (length l) 2))\n                                \
    \              (list-ref l (- (/ (length l) 2) 1)))\n                        \
    \                   2)]\n          [else (list-ref l (/ (length l) 2))]))\n  (median-list\
    \ (sort-list l)))\n", "  (if (null? l)\n      0\n      (if (= (length l) 1)\n\
    \          (car l)\n          (sort l <)\n          )))\n", "  (let loop ([l l])\n\
    \    (cond [(empty? l) (error \"empty list\")]\n          [(< (count l) 2) (first\
    \ l)]\n          [(< (count l) 3)\n           (/ (+ (first l) (second l)) 2)]\n\
    \          [else\n           (let* ([n (count l)]\n                  [h (quotient\
    \ n 2)]\n                  [p (+ h (remainder n 2))])\n             (loop (sort\
    \ < (remove-nth p l))))])))\n```\n\n## Problem 2\n\nFor each of the following\
    \ functions of a number `n`, write a function that consumes a list of numbers\
    \ and produces the function\u2019s value.\n\n  1. `(floor (/ 1 n))`\n  2. `(ceiling\
    \ (/ 1 n))`\n  3. `(round (/ 1 n))`\n  4. `(floor (/ n 2))`\n  5. `(ceiling (/\
    \ n 2))`\n  6. `(round (/ n 2))`\n  7. `(floor (sqrt n))`\n  8. `(ceiling (sqrt\
    \ n))`\n  9. `(round (sqrt n))`\n  10. `(floor (* n n))`\n  11. `(ceiling (* n\
    \ n))`\n  12. `(round (* n n))`\n  13. `(floor (+ (/ n 10) 1))`\n  14. `(ceiling\
    \ (+ (/ n 10) 1))`\n  15. `(round (+ (/ n 10) 1))`\n  16. `(expt n 2)`\n  17.\
    \ `(expt n 3)`\n  18. `(expt n 4)`\n  19. `(log n)`\n  20. `(log10 n)`\n  21.\
    \ `(expt 10 n)`\n  22. `(expt 2 n)`\n  23. `(round (sqrt n))`\n  24. `(expt (sqrt\
    \ n) 2)`\n  25. `(expt (log n) 2)`\n  26. `(expt (log10 n) 2)`\n  27. `(expt n\
    \ (sqrt n))", "  (if (null? l)\n      0\n      (let ((sorted-l (sort < l)))\n\
    \        (if (even? (length sorted-l))\n            (/ (+ (list-ref sorted-l (/\
    \ (length sorted-l) 2))\n                    (list-ref sorted-l (- (/ (length\
    \ sorted-l) 2) 1)))\n                2)\n            (list-ref sorted-l (/ (length\
    \ sorted-l) 2))))))\n```\n\n## Exercice 3\n\n### 3.a\n\nLe code ci-dessous d\xE9\
    finit deux fonctions `affiche-point` et `affiche-demi-ligne` qui affichent sur\
    \ la sortie standard des points et des demi-lignes d'une fen\xEAtre Racket (tr\xE8\
    s basique, sans nombre de points donn\xE9, on ne peut que les effacer en appuyant\
    \ sur la touche `'r'` ou `'f'` pour revenir aux param\xE8tres initiaux).\n\nIl\
    \ faut maintenant ajouter du code au programme principal (\xE0 l'aide de la fonction\
    \ `add-hook`) pour demander \xE0 l'utilisateur de saisir le nombre de points souhait\xE9\
    .\n\n```#lang racket", "  (if (= (length l) 1)\n      (first l)\n      (let ([l\
    \ (sort l &lt;)])\n        (cond\n         [(zero? (modulo (length l) 2))\n  \
    \        (/ (+ (list-ref l (/ (length l) 2))\n                (list-ref l (- (/\
    \ (length l) 2) 1)))\n             2)]\n         [else\n          (list-ref l\
    \ (/ (length l) 2))]))))\n</code>\nThis produces the following error:\n<code>l:\
    \ application: not a procedure;\n expected a procedure that can be applied to\
    \ arguments\n  given: '(1 2 3 4 5 6)\n  arguments...: [none]\n</code>\nI can't\
    \ seem to figure out what I'm doing wrong.\n\n\nA:\n\nYou're creating a list with\
    \ a single element, which is a list, with <code>(list-ref l (/ (length l) 2))</code>\
    \ and <code>(list-ref l (- (/ (length l) 2) 1))</code>, and those are the elements\
    \ you're trying to average with <code>+</code>. Use <code>list-ref</code> to get\
    \ the elements instead of wrapping it in <code>list</code>.\n", "  (sort l &lt;=))\n\
    </code>\nI want to know if there is a better way to do it. The idea is that I\
    \ want the same result that I get when I do: \n<code>(median '(1 8 3 4 2 9 7 5\
    \ 6))\n</code>\nwhich is <code>'(1 2 3 4 5 6 7 8 9)</code>.\nI want to do this\
    \ without using the build-in sort, but I don't want to use helper functions like\
    \ <code>first</code>, <code>rest</code>, or <code>length</code> either.\n\n\n\
    A:\n\nTo sort a list without using built-in tools, you can just use insertion\
    \ sort:\n<code>(define (insertion-sort l)\n  (define (insert n l)\n    (cond ((null?\
    \ l) (list n))\n          ((&lt;= n (car l)) (cons n l))\n          (else (cons\
    \ (car l) (insert n (cdr l))))))\n  (cond ((null? l) '())\n        (else (insert\
    \ (car l) (insertion-sort (cdr l))))))\n</code>\n", "  (median-helper (quicksort\
    \ l)))\n", "  (let ([n (length l)])\n    (cond [(even? n)\n           (/ (+ (list-ref\
    \ l (/ n 2))\n                 (list-ref l (- n (/ n 2))))\n              2)]\n\
    \          [else\n           (list-ref l (/ n 2))])))\n", "  (define (median-prime\
    \ l)\n    (cond\n      [(empty? l) '()]\n      [(empty? (rest l)) (first l)]\n\
    \      [(= (length l) 2) (mean (first l) (second l))]\n      [else (cons (median-prime\
    \ (list-head l))\n                  (median-prime (list-tail l)))]))\n  (cond\n\
    \    [(empty? l) '()]\n    [(empty? (rest l)) (first l)]\n    [(= (length l) 2)\
    \ (mean (first l) (second l))]\n    [else (mean (median-prime (list-head l))\n\
    \                (median-prime (list-tail l)))]))\n", "  (let ([sorted (sort l\
    \ &lt;)])\n    (cond [(even? (length sorted))\n           (/ (+ (nth sorted (/\
    \ (length sorted) 2))\n                 (nth sorted (- (/ (length sorted) 2) 1)))\n\
    \              2)]\n          [else\n           (nth sorted (/ (length sorted)\
    \ 2))])))\n</code>\n", "  (if (null? l)\n      #f\n      (let ((len (list-length\
    \ l)))\n        (let ((l2 (sort l &lt;)))\n          (let* ((half (quotient len\
    \ 2))\n                 (a (list-ref l2 half)))\n            (if (even? len)\n\
    \                (let ((b (list-ref l2 (add1 half))))\n                  (/ (+\
    \ a b) 2))\n                a))))))\n</code>\nNow we can write a <code>find-median</code>\
    \ procedure:\n<code>#lang racket\n", "  (define (xsort l)\n    (if (empty? l)\n\
    \        '()\n        (append (xsort (filter (lambda (x) (< x (first l))) (rest\
    \ l)))\n                (list (first l))\n                (xsort (filter (lambda\
    \ (x) (>= x (first l))) (rest l))))))\n  (define n (length l))\n  (if (empty?\
    \ l)\n      '()\n      (if (even? n)\n          (/ (+ (list-ref (xsort l) (/ n\
    \ 2))\n                 (list-ref (xsort l) (- (/ n 2) 1)))\n             2)\n\
    \          (list-ref (xsort l) (/ n 2)))))\n</code>\nBut when I run <code>(median\
    \ '(1 1 2 2))</code> it returns <code>()</code> instead of <code>1.5</code>. What\
    \ is the problem here?\nAlso, is there a better way to implement <code>median</code>?\n\
    \n\nA:\n\nYou could use <code>sort</code> in standard library, which is faster\
    \ than <code>xsort</code> you created.\n<code>(define (median l)\n  (define n\
    \ (length l))\n  (define s (sort &lt; l))\n  (if (empty? l)\n      '()\n     \
    \ (if (even? n)\n          (/ (+ (list-ref s (/ n 2))\n                 (list-ref\
    \ s (- (/ n 2) 1)))\n             2)\n          (list-ref s (/ n 2)))))\n</code>\n\
    Also, your <code>xsort</code> is not correct, since it's working only for <code>number</code>s.\n\
    In example below, you can see how it fails to compare <code>string</code>s.\n\
    <code>(define (xsort l)\n  (if (empty? l)\n      '()\n      (append (xsort (filter\
    \ (lambda (x) (&lt; x (first l))) (rest l)))\n              (list (first l))\n\
    \              (xsort (filter (lambda (x) (&gt;= x (first l))) (rest l))))))\n",
  "  (define sorted-l (sort l &lt;))\n  (define l-length (length sorted-l))\n  (if\
    \ (even? l-length)\n      (/ (+ (list-ref sorted-l (/ l-length 2))\n         \
    \   (list-ref sorted-l (- (/ l-length 2) 1)))\n         2)\n      (list-ref sorted-l\
    \ (/ l-length 2))))\n", "  (let* ([n (length l)]\n         [median-pos (round\
    \ (/ n 2))])\n    (if (odd? n)\n        (list-ref l median-pos)\n        (/ (+\
    \ (list-ref l median-pos)\n              (list-ref l (- median-pos 1)))\n    \
    \       2))))\n</code>\nExample:\n<code>&gt; (median '(1 1 2 2 4))\n2\n&gt; (median\
    \ '(1 1 2 2))\n1.5\n</code>\n", "  (let ((len (length l)))\n    (cond ((equal?\
    \ len 0)\n           0)\n          ((equal? len 1)\n           (first l))\n  \
    \        ((< len 3)\n           (if (equal? len 2)\n               (/ (+ (first\
    \ l) (second l)) 2)\n               (first l)))\n          (else (let ((taken-from-left\
    \ (length (take l (/ len 2)))))\n                  (if (even? len)\n         \
    \             (/ (+ (list-ref l (- taken-from-left 1))\n                     \
    \       (list-ref l taken-from-left))\n                         2)\n         \
    \             (list-ref l taken-from-left)))))))\n", "  (if (empty? l)\n     \
    \ 0\n      (cond\n       [(eq? (remainder (length l) 2) 0)\n        (/ (+ (list-ref\
    \ l (/ (length l) 2))\n              (list-ref l (- (/ (length l) 2) 1)))\n  \
    \         2)]\n       [else\n        (list-ref l (/ (length l) 2))])))\n", " \
    \ (define (smaller-than x l)\n    (define (iter rest so-far)\n      (cond\n  \
    \      [(empty? rest) so-far]\n        [(< (first rest) x) (iter (rest rest) (cons\
    \ (first rest) so-far))]\n        [else (iter (rest rest) so-far)]))\n    (iter\
    \ l '()))\n  (define (larger-than x l)\n    (define (iter rest so-far)\n     \
    \ (cond\n        [(empty? rest) so-far]\n        [(> (first rest) x) (iter (rest\
    \ rest) (cons (first rest) so-far))]\n        [else (iter (rest rest) so-far)]))\n\
    \    (iter l '()))\n  (define (length-of l)\n    (define (iter rest len)\n   \
    \   (cond\n        [(empty? rest) len]\n        [else (iter (rest rest) (+ len\
    \ 1))]))\n    (iter l 0))\n  (define (index l n)\n    (define (iter rest count)\n\
    \      (cond\n        [(empty? rest) (error \"Index not found\")]\n        [(=\
    \ count n) (first rest)]\n        [else (iter (rest rest) (+ count 1))]))\n  \
    \  (iter l 0))\n  (define (even? n)\n    (= 0 (modulo n 2)))\n  (cond\n    [(even?\
    \ (length-of l)) (average (index l (/ (length-of l) 2)) (index l (- (/ (length-of\
    \ l) 2) 1)))]\n    [else (index l (/ (length-of l) 2))]))\n", "  (define (sorted-l\
    \ l)\n    (sort l <))\n  (define (median-odd l)\n    (list-ref (sorted-l l) (/\
    \ (length l) 2)))\n  (define (median-even l)\n    (/ (+ (list-ref (sorted-l l)\
    \ (/ (length l) 2))\n          (list-ref (sorted-l l) (+ (/ (length l) 2) 1)))\n\
    \       2))\n  (cond ((even? (length l)) (median-even l))\n        (else (median-odd\
    \ l))))\n", "  (cond\n    [(empty? l)\n     0]\n    [(empty? (rest l))\n     (first\
    \ l)]\n    [else\n     (median-3 (sort l <))]))\n", "  (define (helper ls)\n \
    \   (let ([sorted (sort ls &lt;)])\n      (let ([n (length sorted)])\n       \
    \ (if (odd? n)\n            (list-ref sorted (quotient n 2))\n            (/ (+\
    \ (list-ref sorted (quotient n 2))\n                  (list-ref sorted (quotient\
    \ (- n 1) 2)))\n               2)))))\n  (if (empty? l)\n      (error \"empty\
    \ list\")\n      (helper l)))\n</code>\nThe <code>helper</code> function first\
    \ sorts the list and then returns either the list middle element if the number\
    \ of elements is odd or the average of the two middle elements if the number of\
    \ elements is even.\nEdit: the original version of the <code>median</code> function\
    \ did not handle empty lists.\n", "  (define ordered\n    (sort l <))\n  (define\
    \ length-l\n    (length l))\n  (if (even? length-l)\n      (/ (+ (list-ref ordered\
    \ (/ length-l 2))\n            (list-ref ordered (- (/ length-l 2) 1)))\n    \
    \     2)\n      (list-ref ordered (/ length-l 2))))\n", "  (cond ((null? l) (error\
    \ \"median: empty list\"))\n        ((null? (cdr l)) (car l))\n        ((= (remainder\
    \ (length l) 2) 0)\n         (/ (+ (list-ref l (/ (length l) 2))\n           \
    \    (list-ref l (- (/ (length l) 2) 1)))\n            2))\n        (else (list-ref\
    \ l (/ (length l) 2)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
