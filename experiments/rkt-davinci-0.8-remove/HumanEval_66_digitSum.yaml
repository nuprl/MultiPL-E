name: HumanEval_66_digitSum
language: rkt
prompt: "#lang racket\n\n;; Task\n;; Write a function that takes a string as input\
  \ and returns the sum of the upper characters only'\n;; ASCII codes.\n;; Examples:\n\
  (define (digitSum s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n\
  \    (check-equal? (candidate \"\") 0)\n    (check-equal? (candidate \"abAB\") 131)\n\
  \    (check-equal? (candidate \"abcCd\") 67)\n    (check-equal? (candidate \"helloE\"\
  ) 69)\n    (check-equal? (candidate \"woArBld\") 131)\n    (check-equal? (candidate\
  \ \"aAaaaXa\") 153)\n    (check-equal? (candidate \" How are yOu?\") 151)\n    (check-equal?\
  \ (candidate \"You arE Very Smart\") 327)\n))\n\n(test-humaneval)"
completions: ["  (string-&gt;number (apply string-append (map char-&gt;string (filter\
    \ char-numeric? s)))))\n", "  (cond ((string-null? s) 0)\n        ((= #\\A (string-ref\
    \ s 0)) (+ (digitSum (substring s 1)) (char->integer (string-ref s 0))))\n   \
    \     ((= #\\B (string-ref s 0)) (+ (digitSum (substring s 1)) (char->integer\
    \ (string-ref s 0))))\n        ((= #\\C (string-ref s 0)) (+ (digitSum (substring\
    \ s 1)) (char->integer (string-ref s 0))))\n        ((= #\\D (string-ref s 0))\
    \ (+ (digitSum (substring s 1)) (char->integer (string-ref s 0))))\n        ((=\
    \ #\\E (string-ref s 0)) (+ (digitSum (substring s 1)) (char->integer (string-ref\
    \ s 0))))\n        ((= #\\F (string-ref s 0)) (+ (digitSum (substring s 1)) (char->integer\
    \ (string-ref s 0))))\n        ((= #\\G (string-ref s 0)) (+ (digitSum (substring\
    \ s 1)) (char->integer (string-ref s 0))))\n        ((= #\\H (string-ref s 0))\
    \ (+ (digitSum (substring s 1)) (char->integer (string-ref s 0))))\n        ((=\
    \ #\\I (string-ref s 0)) (+ (digitSum (substring s 1)) (char->integer (string-ref\
    \ s 0))))\n        ((= #\\J (string-ref s 0)) (+ (digitSum (substring s 1)) (char->integer\
    \ (string-ref s 0))))\n        ((= #\\K (string-ref s 0)) (+ (digitSum (substring\
    \ s 1)) (char->integer (string-ref s 0))))\n        ((= #\\L (string-ref s 0))\
    \ (+ (digitSum (substring s 1)) (char->integer (string-ref s 0))))\n        ((=\
    \ #\\M (string-ref s 0)) (+ (digitSum (substring s 1)) (char->integer (string-ref\
    \ s 0))))\n        ((= #\\N (string-ref s 0)) (+ (digitSum (substring s 1)) (char->integer\
    \ (string-ref s 0))))\n        ((= #\\O (string", "  (if (empty? s)\n      0\n\
    \      (if (between? (char-&gt;integer (string-ref s 0)) 65 90)\n          (+\
    \ (char-&gt;integer (string-ref s 0)) (digitSum (substring s 1)))\n          (digitSum\
    \ (substring s 1)))))\n", "  (apply + (map (lambda (c) (if (and (>= c #\\A) (<=\
    \ c #\\Z)) (- c #\\A) 0)) (string->list s))))\n", "  (define upper? (\u03BB (c)\
    \ (and (char&lt;=? #\\A c) (char&lt;=? c #\\Z))))\n  (apply + (filter upper? (string-&gt;list\
    \ s))))\n", "  (apply + (map (\u03BB (x) (char->integer x))\n          (filter\
    \ char-alphabetic? (string->list s)))))\n</code>\nIs there a way to do this without\
    \ using <code>filter</code>?\n\n\nA:\n\nYou can negate the <code>char-alphabetic?</code>\
    \ predicate and remove its results from the list:\n<code>(apply + (remove (compose\
    \ not char-alphabetic?)\n                 (map char-&gt;integer (string-&gt;list\
    \ s))))\n</code>\nOr alternately, you can use <code>filter</code> to keep only\
    \ the characters that satisfy the predicate:\n<code>(apply + (map char-&gt;integer\
    \ (filter char-alphabetic? (string-&gt;list s))))\n</code>\n", "  (apply + (map\
    \ (lambda (c) (if (char-numeric? c) (char->integer c) 0)) s)))\n", '  (apply +
    (map string-&gt;number (filter char-numeric? (string-&gt;list s)))))', "  (define\
    \ (helper s i sum)\n    (cond ((string=? s \"\") (display sum))\n          ((char&gt;=?\
    \ (string-ref s i) #\\A) (helper s (+ i 1) (+ sum (char-&gt;integer (string-ref\
    \ s i)))))\n          (else (helper s (+ i 1) sum))))\n  (helper s 0 0))\n</code>\n\
    I can't figure out the problem. Can someone please help me?\n\n\nA:\n\nYour program\
    \ is correct. The fact that it does not display anything is because it is run\
    \ in DrRacket. So you have to do a little bit of work so that you can see the\
    \ results. For example, you can use the <code>check-expect</code> to test your\
    \ code. See the documentation for details.\n", "  (apply +\n         (filter integer?\n\
    \                 (map char->integer\n                      (filter char-alphabetic?\n\
    \                              (string->list s))))))\n", "  (foldl + 0\n     \
    \    (filter is-upper\n                 (map char->integer (string->list s)))))\n",
  "  (for/sum ([i (in-list s)]\n            #:when (char-alphabetic? i)\n        \
    \    #:when (char-upper-case? i))\n    (char->integer i)))\n", "  (for/sum ([ch\
    \ (in-string s)])\n           (if (char-uppercase? ch)\n               (char->integer\
    \ ch)\n               0)))\n", "  (letrec ([aux (lambda (i sum)\n            \
    \      (if (= i (string-length s))\n                      sum\n              \
    \        (if (char-upper-case? (string-ref s i))\n                          (aux\
    \ (+ i 1) (+ sum (string->number (string (string-ref s i))))\n               \
    \           (aux (+ i 1) sum))))])\n    (aux 0 0)))\n", "  (define (addDigit d)\n\
    \    (+ 0\n       (cond\n         [(char=? #\\A d) 65]\n         [(char=? #\\\
    B d) 66]\n         [(char=? #\\C d) 67]\n         [(char=? #\\D d) 68]\n     \
    \    [(char=? #\\E d) 69]\n         [(char=? #\\F d) 70]\n         [(char=? #\\\
    G d) 71]\n         [(char=? #\\H d) 72]\n         [(char=? #\\I d) 73]\n     \
    \    [(char=? #\\J d) 74]\n         [(char=? #\\K d) 75]\n         [(char=? #\\\
    L d) 76]\n         [(char=? #\\M d) 77]\n         [(char=? #\\N d) 78]\n     \
    \    [(char=? #\\O d) 79]\n         [(char=? #\\P d) 80]\n         [(char=? #\\\
    Q d) 81]\n         [(char=? #\\R d) 82]\n         [(char=? #\\S d) 83]\n     \
    \    [(char=? #\\T d) 84]\n         [(char=? #\\U d) 85]\n         [(char=? #\\\
    V d) 86]\n         [(char=? #\\W d) 87]\n         [(char=? #\\X d) 88]\n     \
    \    [(char=? #\\Y d) 89]\n         [(char=? #\\Z d) 90]\n         [else 0])))\n\
    \  (foldl addDigit 0 s))\n", "  (apply + (map (lambda (c) (- c 32))\n        \
    \        (filter char-alphabetic? (string->list s)))))\n</code>\nThe problem is,\
    \ as I know, racket has a built-in function: <code>string-upper-case</code>, does\
    \ it have a function to do the opposite? \nOr maybe there is a better way to implement\
    \ this function?\nThanks in advance!\n\n\nA:\n\nYou can use <code>string-upcase</code>\
    \ in exactly the same way as you used <code>string-upper-case</code>, as shown\
    \ in this example:\n<code>(define (digitSum s)\n  (apply + (map (lambda (c) (-\
    \ c 32))\n                (filter char-alphabetic? (string-upcase s)))))\n</code>\n",
  "  (apply + (map char->integer (filter char-upper-case? (string->list s)))))\n",
  "  (cond\n    [(empty? s) 0]\n    [(uppercase? (first s)) (+ (char->integer (first\
    \ s)) (digitSum (rest s)))]\n    [else (digitSum (rest s))]))\n", "  (for/sum\
    \ ((c (in-string s)))\n           (cond [(char-upper-case? c) (char->integer c)]\n\
    \                 [else 0])))\n</code>\nHere is the same example using a list\
    \ of characters.\n<code>#lang racket\n", "  (apply + (map (\u03BB (c) (char-&gt;integer\
    \ c)) (filter char-alphabetic? (string-&gt;list s)))))\n", "  (define (is-uppercase?\
    \ char)\n    (= char (char-upcase char)))\n  (apply + (map char->integer (filter\
    \ is-uppercase? (string->list s)))))\n", "  (cond [(equal? s \"\") 0]\n      \
    \  [else (+ (if (>= (char->integer (string-ref s 0)) 65) (char->integer (string-ref\
    \ s 0)) 0)\n                 (digitSum (substring s 1)))]))", "  (for/sum ([c\
    \ (in-string s)])\n    (if (or (char-numeric? c) (char-alphabetic? c))\n     \
    \   (if (char-upper-case? c)\n            (char->integer c)\n            0)\n\
    \        0)))\n", "  (apply + (for/list ([c (in-string s)])\n             (if\
    \ (char-upper-case? c)\n                 (char->integer c)\n                 0))))\n",
  "  (cond\n    [(string-empty? s) 0]\n    [(upper? (string-ref s 0)) (+ (char->integer\
    \ (string-ref s 0)) (digitSum (string-tail s)))]\n    [else (digitSum (string-tail\
    \ s))]))\n</code>\nI got this error:\n<code>digitSum: expects type &lt;string&gt;\
    \ as 2nd argument, given: \"Xyz\"\n  in: (digitSum (string-tail s))\n</code>\n\
    What did I do wrong?\n\n\nA:\n\nYour <code>digitSum</code> function works fine.\
    \ To test it, just call it on any string, for example:\n<code>(digitSum \"This\
    \ Is A String\")\n=&gt; 527\n</code>\nThe problem is that when you run the file\
    \ in DrRacket the expression <code>(digitSum \"Xyz\")</code> is automatically\
    \ evaluated, and that's the one that returns the error.\nYou can test your program\
    \ by calling <code>digitSum</code> from the interactions window, it works.\n",
  "  (cond\n    [(empty? s) 0]\n    [(and (>= (string-ref s 0) #\\A) (<= (string-ref\
    \ s 0) #\\Z)) (+ (digitSum (substring s 1)) (string-ref s 0))]\n    [else (digitSum\
    \ (substring s 1))]))\n", "  (for/sum ([i (in-string s)]) (if (char-upper-case?\
    \ i) (char->integer i) 0)))\n", "  (for/sum ([i (in-string s)])\n            (if\
    \ (char-numeric? i) (char->integer i) 0)\n            ))\n", "  (accumulate (lambda\
    \ (n m) (+ n m)) 0\n              (filter (lambda (x) (and (>= x #\\A) (<= x #\\\
    Z)))\n                      (string->list s))))\n", "  (letrec\n      ((sum (lambda\
    \ (l)\n\t      (cond\n\t       ((null? l) 0)\n\t       ((= (char-upper-case? (car\
    \ l)) #t)\n\t\t(+ (char->integer (car l)) (sum (cdr l))))\n\t       (else (sum\
    \ (cdr l)))))))\n    (sum (string->list s))))", "  (apply + (map (lambda (x) (if\
    \ (char-upper-case? x) (- x #\\A) 0)) (string->list s))))\n", "  (if (empty? s)\n\
    \      0\n      (if (char-numeric? (string-ref s 0))\n          (+ (string-&gt;number\
    \ (string-ref s 0)) (digitSum (substring s 1)))\n          (digitSum (substring\
    \ s 1)))))\n</code>\nMy code works fine but I'm looking for a less hacky way to\
    \ do this.\n\n\nA:\n\nInstead of <code>string-&gt;number</code> I would use <code>char-&gt;integer</code>\
    \ and <code>integer-&gt;char</code> to \"convert\" characters to integers and\
    \ vice versa.\n<code>(integer-&gt;char\n   (char-&gt;integer\n     #\\0))\n=&gt;\
    \ #\\0\n</code>\nUsing these two functions you don't need to convert the string\
    \ to a number.\nThat way you can get rid of the <code>string-&gt;number</code>\
    \ and the <code>if</code> condition.\n", "  (let ([nums (string->list s)])\n \
    \   (apply + (map\n              (lambda (x)\n                (if (char=? (char-upcase\
    \ x) x)\n                    (char->integer x)\n                    0))\n    \
    \          nums))))\n", "  (for/sum ([c (in-string s)]) (if (char-upper-case?\
    \ c) (char->integer c) 0)))\n</code>\n", "  (apply + (map string-&gt;number (filter\
    \ (curry string-upper-case? string=?) s))))\n</code>\nLet's assume that <code>string-&gt;number</code>\
    \ is defined as:\n<code>(define (string-&gt;number s)\n  (string-&gt;number/radix\
    \ s 10))\n</code>\nTest cases:\n<code>(digitSum \"Hello\") ; =&gt; 500", "  (sum\
    \ (filter (lambda (x)\n                 (if (char-alphabetic? x)\n           \
    \          (if (char-upper-case? x)\n                         (char->integer x)\n\
    \                         0)\n                     0))\n               (string->list\
    \ s))))\n</code>\nIs there a better way to write this function?\n\n\nA:\n\nThere\
    \ is no need to use a <code>filter</code> here, because you're just doing a simple\
    \ conditional check and returning the result, you can use <code>map</code> instead\
    \ - it'll map the <code>char-&gt;integer</code> to the list of characters in the\
    \ string, but only if the condition is met, otherwise it will return <code>#f</code>.\n\
    Here's how to refactor it, notice that I also eliminated the <code>sum</code>\
    \ call because it can be done in the <code>map</code> function:\n<code>(define\
    \ (digitSum s)\n  (map (lambda (x)\n         (if (char-alphabetic? x)\n      \
    \       (if (char-upper-case? x)\n                 (char-&gt;integer x)\n    \
    \             0)\n             0))\n       (string-&gt;list s)))\n</code>\nThis\
    \ way you'll get a list of <code>#f</code> and numbers and you can use <code>remove</code>\
    \ to get rid of the <code>#f</code>s and then use <code>sum</code> to get the\
    \ total.\nOr, if you want a one-liner, use <code>apply</code> and <code>sum</code>:\n\
    <code>(define (digitSum s)\n  (apply sum (map (lambda (x)\n                  \
    \  (if (char-alphabetic? x)\n                        (if (char-upper-case? x)\n\
    \                            (char-&gt;integer x)\n                          \
    \  0)\n                        0))\n                  (string-&gt;list s))))\n\
    </code>\n", "  (cond [(empty? s) 0]\n        [else (if (and (&lt;= #\\A (car s))\
    \ (&lt;= (car s) #\\Z))\n                  (+ (car s) (digitSum (cdr s)))\n  \
    \                (digitSum (cdr s)))]))\n</code>\n", "  (apply + (map char->integer\
    \ (regexp-match* #rx\"[A-Z]\" s))))\n", "  (apply + (map (\u03BB (char) (if (char-upper-case?\
    \ char) char 0)) s)))\n", "  (string-&gt;number (string-join (list-&gt;string\
    \ (map string-&gt;number \n        (string-&gt;list s))))))", "  (for/sum ([c\
    \ (in-string s)])\n    (char->integer c)))\n</code>\n", "  (apply + (map digit->char\
    \ (string->list s))))\n", "  (if (string=? s \"\")\n      0\n      (if (and (>=\
    \ (string-&gt;number (substring s 0 1)) 65)\n               (&lt;= (string-&gt;number\
    \ (substring s 0 1)) 90))\n          (+ (string-&gt;number (substring s 0 1))\n\
    \             (digitSum (substring s 1)))\n          (digitSum (substring s 1)))))\n",
  "  (apply + (map string-&gt;number\n                 (map char-&gt;string\n    \
    \                  (filter char-upcase?\n                              (string-&gt;list\
    \ s))))))\n</code>\nTest run:\n<code>&gt; (digitSum \"ABC\")\n6\n&gt; (digitSum\
    \ \"abc\")\n0\n&gt; (digitSum \"123xyz\")\n15\n</code>\n", "  (string-foldl (lambda\
    \ (a b) (+ a b)) 0 (string-filter char-numeric? s)))\n", "  (apply + (filter (lambda\
    \ (x) (and (>= x 65) (<= x 90))) (map char->integer s))))\n", "  (define (char-to-int\
    \ c)\n    (- c #\\0))\n  (define (sum-digits n)\n    (cond\n      [(<= 0 n) (+\
    \ (remainder n 10) (sum-digits (quotient n 10)))]\n      [else 0]))\n  (sum-digits\
    \ (for/sum ([c (in-string s)])\n                 (cond\n                   [(char-upper-case?\
    \ c) (char-to-int c)]\n                   [else 0]))))\n", "  (define (sum string\
    \ i sum)\n    (cond ((= i (- (string-length string) 1)) sum)\n          ((char-numeric?\
    \ (string-ref string i))\n           (sum string (+ i 1) (+ sum (string-&gt;number\
    \ (string-ref string i)))))\n          ((and (&gt;= (string-ref string i) #\\\
    A) (&lt;= (string-ref string i) #\\Z))\n           (sum string (+ i 1) (+ sum\
    \ (- (string-ref string i) #\\A #\\a))))\n          (else (sum string (+ i 1)\
    \ sum))))\n  (sum s 0 0))\n", "  (let loop ([s s] [sum 0])\n    (if (empty? s)\n\
    \        sum\n        (let ([char (first s)])\n          (cond [(char&lt;= char\
    \ #\\Z) (loop (rest s) (+ sum (- char #\\A 1)))]\n                [(char&lt;=\
    \ char #\\z) (loop (rest s) (+ sum (- char #\\a 1)))]\n                [else \
    \              (loop (rest s) sum)])))))\n</code>\n", "  (let ((sums 0))\n   \
    \ (for ([c (in-string s)])\n      (when (char-upper-case? c)\n        (set! sums\
    \ (+ sums (char->integer c)))))\n    sums))\n", "  (define (parseChar c)\n   \
    \ (cond\n      ((char&lt;=? #\\A c #\\Z) (char-&gt;integer c))\n      (else 0)))\n\
    \  (apply + (map parseChar (string-&gt;list s))))\n", "  (apply + (map (\u03BB\
    \ (c)\n                  (cond ((letter? c)\n                         (int-&gt;char\
    \ (- c 32)))\n                        (else c)))\n                (string-&gt;list\
    \ s))))\n", "  (apply + (filter even? (string->list s))))\n", "  (cond [(string=?\
    \ s \"\") 0]\n        [else (+ (char->integer (string-ref s 0))\n            \
    \     (digitSum (substring s 1)))]))\n", "  (for/sum ([i (in-string s)])\n   \
    \ (if (char-numeric? i) i 0)))\n", "  (accumulate + 0 (map string-&gt;number (string-split\
    \ (regexp-replace* #rx\"\\d+\" s \"$&amp;\")))))\n</code>\nThe accumulated result\
    \ is a list of numbers. Now, I want to add these numbers together. How can I do\
    \ that?\n\n\nA:\n\nSince you're using <code>accumulate</code>, you already know\
    \ how to do this. \nJust use the <code>sum</code> function:\n<code>(define (sum\
    \ xs)\n  (accumulate + 0 xs))\n</code>\nIf you want to use a different reduce\
    \ function, you can just pass it to <code>accumulate</code>:\n<code>(define (sum\
    \ xs)\n  (accumulate * 1 xs))\n</code>\n", "  (define (addSum acc c)\n    (if\
    \ (&gt;= c 65)\n        (+ acc c)\n        acc))\n  (foldl addSum 0 (string-&gt;list\
    \ s)))\n", "  (add-upper-ascii s 0))\n", "  (apply + (for/list ([c (in-string\
    \ s)])\n             (cond\n               [(char-upper-case? c) (- c #\\A) ]\n\
    \               [(char-lower-case? c) (- c #\\a) ]\n               [else 0]))))\n",
  "  (for/sum ([c (in-string s)])\n    (cond\n      [(char-upper-case? c) (char->integer\
    \ c)]\n      [else 0])))\n```\n\n```racket\n#lang racket\n", "  (apply +\n   \
    \      (map char->integer\n              (filter char-numeric?\n             \
    \         (filter char-upper-case?\n                              (string->list\
    \ s))))))", "  (apply + (for/list ([c (in-string s)])\n            (if (char-upper-case?\
    \ c)\n                (char->integer c)\n                0))))\n", "  (if (empty?\
    \ s)\n      0\n      (if (char-uppercase? (first s))\n          (+ (char->integer\
    \ (first s)) (digitSum (rest s)))\n          (digitSum (rest s)))))\n```\n\n###\
    \ 04-create-file.rkt\n```racket\n#lang racket\n", "    (cond\n        [(string=?\
    \ s \"\") 0]\n        [(string-ci=? (substring s 0 1) \"a\") (digitSum (substring\
    \ s 1))]\n        [(string-ci=? (substring s 0 1) \"z\") (digitSum (substring\
    \ s 1))]\n        [else (+ (ascii-&gt;integer (substring s 0 1)) (digitSum (substring\
    \ s 1)))]))\n</code>\nHowever, I get the following error \n<code>application:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: #&lt;syntax:18:8 . . .&gt;\n  arguments...:\n   #(a c a)\n</code>\nAny\
    \ ideas about what's wrong? \nThanks!\n\n\nA:\n\nThis looks like an indentation\
    \ issue. Racket uses indentation to detect the structure of your program. See\
    \ this answer to understand how to configure your editor to use racket indentation\
    \ mode.\n", '  (accumulate + 0 (map char-&gt;integer (filter char-upper-case?
    (string-&gt;list s)))))', "  (apply + (filter (lambda (char) (and (>= char #\\\
    A) (<= char #\\Z))) s)))\n", "  (define (charSum c)\n    (cond [(char-alphabetic?\
    \ c)\n           (cond [(char-upper-case? c)\n                  (- c #\\A 1)]\n\
    \                 [else\n                  0])]\n          [else\n           0]))\n\
    \  (apply + (map charSum (string->list s))))\n", "  (letrec\n    ([asciiSum (lambda\
    \ (s)\n                  (cond\n                    [(empty? s) 0]\n         \
    \           [(char-ci=? (first s) #\\a) (asciiSum (rest s))]\n               \
    \     [(char-ci=? (first s) #\\b) (asciiSum (rest s))]\n                    [(char-ci=?\
    \ (first s) #\\c) (asciiSum (rest s))]\n                    [(char-ci=? (first\
    \ s) #\\d) (asciiSum (rest s))]\n                    [(char-ci=? (first s) #\\\
    e) (asciiSum (rest s))]\n                    [(char-ci=? (first s) #\\f) (asciiSum\
    \ (rest s))]\n                    [(char-ci=? (first s) #\\g) (asciiSum (rest\
    \ s))]\n                    [(char-ci=? (first s) #\\h) (asciiSum (rest s))]\n\
    \                    [(char-ci=? (first s) #\\i) (asciiSum (rest s))]\n      \
    \              [(char-ci=? (first s) #\\j) (asciiSum (rest s))]\n            \
    \        [(char-ci=? (first s) #\\k) (asciiSum (rest s))]\n                  \
    \  [(char-ci=? (first s) #\\l) (asciiSum (rest s))]\n                    [(char-ci=?\
    \ (first s) #\\m) (asciiSum (rest s))]\n                    [(char-ci=? (first\
    \ s) #\\n) (asciiSum (rest s))]\n                    [(char-ci=? (first s) #\\\
    o) (asciiSum (rest s))]\n                    [(char-ci=? (first s) #\\p) (asciiSum\
    \ (rest s))]\n                    [(char-ci=? (first s) #\\q) (asciiSum (rest\
    \ s))]\n                    [(char-ci=? (first s) #\\r) (asciiSum (rest s))]\n\
    \                    [(char-ci=? (first s) #\\", "  (let loop ([s s] [acc 0])\n\
    \    (if (empty? s)\n        acc\n        (loop (rest s)\n              (+ acc\
    \ (if (char-numeric? (first s))\n                         (char->integer (first\
    \ s))\n                         0))))))\n", "  (define (iter iterList acc)\n \
    \   (cond\n      [(null? iterList) acc]\n      [(char-numeric? (car iterList))\
    \ (iter (cdr iterList) (+ acc (string->number (string (car iterList)))))]\n  \
    \    [(char-upper-case? (car iterList)) (iter (cdr iterList) (+ acc (char->integer\
    \ (car iterList))))]\n      [else (iter (cdr iterList) acc)]))\n  (iter (string->list\
    \ s) 0))\n", "    (for/sum ([c (in-string s)])\n        (if (char-upper-case?\
    \ c)\n            (char->integer c)\n            0)\n        )\n    )\n```\n\n\
    ```#lang racket", "  (apply + (for/list ([x (in-string s)])\n            (cond\
    \ [(char-upper-case? x) (char->integer x)]\n                  [else 0]))))\n</code>\n",
  "  (letrec ([sum (lambda (sum-sofar i)\n                 (if (= i (string-length\
    \ s))\n                     sum-sofar\n                     (sum (+ sum-sofar\n\
    \                             (if (char-upper-case? (string-ref s i))\n      \
    \                           (char->integer (string-ref s i))\n               \
    \                  0))\n                          (+ i 1))))])\n    (sum 0 0)))\n\
    </code>\nand I get:\n<code>$ racket -t sum_upper_chars.rkt\nsum_upper_chars.rkt:8:2:\
    \ module language: unknown module language: lang\n</code>\nWhat did I do wrong?\n\
    \n\nA:\n\nYou need to include <code>#lang racket</code> at the very top of your\
    \ code, in the first line of the file.\n", "  (apply + (map (curry string-&gt;number\
    \ char-&gt;integer) (filter char-upcase? (string-&gt;list s)))))\n", "  (let ([s\
    \ (string-upcase s)])\n    (for/sum ([c (in-string s)])\n              (if (char-numeric?\
    \ c)\n                  (- (char->integer c) #\\0)\n                  0))))\n\
    </code>\nNotice that I upper-cased the input string, this way there is no need\
    \ to check if the character is upper or lower case.\n", "  (define (helper s sum)\n\
    \    (cond\n      [(empty? s) sum]\n      [(and (positive? (char-&gt;integer (car\
    \ s)))\n            (negative? (char-&gt;integer (car s)))) (+ sum (char-&gt;integer\
    \ (car s)))]\n      [else (helper (cdr s) sum)]))\n  (helper s 0))\n</code>\n\
    In the above case, I'm thinking of -1 (i.e. 255) to represent the end of the list.\
    \ The program seems to be behaving properly for the positive numbers\n<code>=&gt;\
    \ (digitSum \"a\")\n97\n=&gt; (digitSum \"abcdefghijklmnopqrstuvwxyz\")\n1302\n\
    </code>\nBut it doesn't behave properly for negative numbers\n<code>=&gt; (digitSum\
    \ \"aB\")\n98\n=&gt; (digitSum \"aBC\")\n300\n</code>\nWhat am I doing wrong?\n\
    \n\nA:\n\nFirst, it seems you're mixing ASCII and Unicode, because letters, both\
    \ capital and lowercase, are always positive.\n<code>(char-&gt;integer #\\a)\n\
    &gt; 97\n", "  (apply + (map (lambda (c) (if (char-alphabetic? c) (char-&gt;integer\
    \ c) 0)) s)))\n</code>\n", "  (apply + (map (lambda (c) (- c #x40)) (filter (lambda\
    \ (c) (and (&gt;= c #x40) (&lt;= c #x5A))) s))))\n", "  (for/sum ((c (in-string\
    \ s)))\n    (if (char-upper-case? c)\n        (char->integer c)\n        0)))\n",
  "  (apply + (map string-&gt;number\n                 (filter (compose digit? char-&gt;integer)\n\
    \                         (string-&gt;list s)))))", "  (cond\n    [(string=? s\
    \ \"\") 0]\n    [(and (<= (string-&gt;number (string-ref s 0)) 64)\n         \
    \ (&gt;= (string-&gt;number (string-ref s 0)) 91)) (digitSum (substring s 1))]\n\
    \    [else (+ (string-&gt;number (string-ref s 0)) (digitSum (substring s 1)))]))\n\
    </code>\n", "  (cond\n    ((empty? s) 0)\n    ((and (&lt;= #\\A char) (&lt;= char\
    \ #\\Z)) (+ digitSum (substring s 1)))\n    (else (+ digitSum (substring s 1)))))\n\
    </code>\nbut it returns an error that s is not defined. I can't figure out how\
    \ to take the whole string and then each individual character. I can take a single\
    \ character and check if it's an upper case letter, but I'm not sure how to do\
    \ the whole thing.\n<code>#lang racket", "  (for/sum ([ch (in-string s)])\n  \
    \  (if (char-upper-case? ch)\n        (char->integer ch)\n        0)))\n", " \
    \ (cond\n    ((zero? (string-length s)) 0)\n    ((char&gt;=? (string-ref s 0)\
    \ #\\A)\n     (+ (string-&gt;number (string (string-ref s 0)))\n        (digitSum\
    \ (substring s 1))))\n    (else (digitSum (substring s 1)))))\n</code>\nHowever,\
    \ on the second line, I get:\n<code> module: identifier already imported from\
    \ a different source in: char&gt;=?\n</code>\nI think this question is a duplicate\
    \ of a question I had earlier and the solution was to use <code>#lang racket</code>\
    \ instead of <code>#lang racket/base</code>.  But I did that and I'm still getting\
    \ the error.  Why is this happening?\n\n\nA:\n\nThe function you want is called\
    \ <code>char-&gt;integer</code>\n<code>#lang racket\n", "  (if (null? s)\n   \
    \   0\n      (+ (if (char-upcased? (car s)) (char->integer (car s)) 0)\n     \
    \    (digitSum (cdr s)))))\n", "  (apply +\n\t (filter even?\n\t\t (map (\u03BB\
    \ (x) (char->integer x))\n\t\t      (string->list s)))))", "  (if (empty? s)\n\
    \      0\n      (if (isUpper? (first s))\n          (+ (char-&gt;integer (first\
    \ s)) (digitSum (rest s)))\n          (digitSum (rest s)))))\n", "  (apply + (map\
    \ char->integer (filter char-alphabetic? (string->list s)))))\n", "  (define (sum\
    \ str i)\n    (cond\n      [(null? str) i]\n      [(and (>= (car str) 65) (<=\
    \ (car str) 90)) (+ i (car str))]\n      [else (sum (cdr str) i)]))\n  (sum s\
    \ 0))\n", "  (apply + (for/list ([c (in-string s)])\n             (cond [(char-upper-case?\
    \ c) (char->integer c)]\n                   [else 0]))))", "  (define (sum s n)\n\
    \    (cond ((empty? s) n)\n          ((and (&lt;= #\\A (first s)) (&lt;= (first\
    \ s) #\\Z)) (sum (rest s) (+ n (first s))))\n          (else (sum (rest s) n))))\n\
    \  (sum s 0))\n</code>\nThis is a solution for a question in this site.\nWhen\
    \ I run the code, I get an error:\n<code>application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: #\\A\n  arguments...:\
    \ [none]\n</code>\nI've searched for similar questions, but I didn't find any.\n\
    \n\nA:\n\nYou were pretty close. In Racket, you can use <code>char-upcase</code>\
    \ to perform case conversion. Also, remember to compare the uppercase version\
    \ of the string, not the original:\n<code>(define (digitSum s)\n  (define (sum\
    \ s n)\n    (cond ((empty? s) n)\n          ((and (&lt;= #\\A (char-upcase (first\
    \ s)))\n                (&lt;= (char-upcase (first s)) #\\Z))\n           (sum\
    \ (rest s) (+ n (first s))))\n          (else (sum (rest s) n))))\n  (sum s 0))\n\
    </code>\n", "  (if (string=? s \"\")\n      0\n      (if (string-upper-case? (string-ref\
    \ s 0))\n          (+ (string-&gt;number (string-ref s 0))\n             (digitSum\
    \ (substring s 1)))\n          (digitSum (substring s 1)))))\n", "  (cond\n  \
    \  [(empty? s) 0]\n    [(char-upper-case? (first s)) (+ (char->integer (first\
    \ s)) (digitSum (rest s)))]\n    [else (digitSum (rest s))]))\n", '  (apply +
    (map (lambda (x) (if (char-alphabetic? x) (char->integer x) 0)) s)))', "  (let\
    \ ((ss (string->list s)))\n    (apply + (map (lambda (c) (- c 32))\n         \
    \         (filter char-upper-case? ss)))))\n", "  (apply + (map (lambda (c) (if\
    \ (char-alphabetic? c) (char->integer c) 0)) s)))\n", "  (for/sum ((c (in-string\
    \ s)))\n           (if (char-upper-case? c)\n               (- c #\\A)\n     \
    \          0)))\n", "  (for/sum ([c (in-string s)])\n    (cond [(char-upper-case?\
    \ c)\n           (char->integer c)]\n          [else 0])))\n", "  (cond\n    [(string=?\
    \ s \"\") 0]\n    [(char-upcase? (string-ref s 0))\n     (+ (char->integer (string-ref\
    \ s 0))\n        (digitSum (substring s 1)))]\n    [else (digitSum (substring\
    \ s 1))]))\n", "  (define (charIsUpper? c)\n    (char-upcase c))\n  (define (sum\
    \ s)\n    (if (empty? s)\n        0\n        (+ (char->integer (first s))\n  \
    \         (sum (rest s)))))\n  (sum (filter charIsUpper? (string->list s))))\n",
  "  (for/sum ([c (in-string s)])\n    (if (char-alphabetic? c)\n        (char-upcase\
    \ c)\n        0)))\n", "  (define (charSum c)\n    (cond\n      [(and (&lt;= (char-&gt;integer\
    \ #\\A) (char-&gt;integer c))\n            (&lt;= (char-&gt;integer c) (char-&gt;integer\
    \ #\\Z)))\n       (char-&gt;integer c)]\n      [else 0]))\n  (apply + (map charSum\
    \ (string-&gt;list s))))\n", "  (for/sum ([c (in-string s)])\n    (if (char-numeric?\
    \ c)\n        (- (char->integer c) 48)\n        0)))", "  (list->number\n   (number->list\
    \ (string->number (string-&gt;symbol s) 16))))\n</code>\nThe cases:\n<code>#lang\
    \ racket\n", "  (apply + (map (lambda (ch)\n                  (char->integer ch))\n\
    \                (string-filter (lambda (ch)\n                               \
    \  (char-upcase? ch))\n                               s))))\n", "  (if (null?\
    \ s) 0\n      (+ (char->integer (string-ref s 0)) (digitSum (string-tail s 1)))))\n",
  "  (define UPPER 65)\n  (define LOWER 97)\n  (define RANGE 26)\n  (define (toUpper\
    \ c) (- c UPPER))\n  (define (toLower c) (- c LOWER))\n  (define (upper? c)\n\
    \    (if (or (= c UPPER) (= c LOWER))\n        #f\n        (if (&gt; c LOWER)\n\
    \            #t\n            (if (&lt; c UPPER)\n                #t\n        \
    \        #f))))\n  (cond ((null? s) 0)\n        ((upper? (car s)) (+ (toUpper\
    \ (car s)) (digitSum (cdr s))))\n        ((lower? (car s)) (+ (toLower (car s))\
    \ (digitSum (cdr s))))\n        (else (digitSum (cdr s)))))\n</code>\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(and (>= (char-&gt;integer (car s)) 65) (&lt;= (char-&gt;integer\
    \ (car s)) 90))\n     (+ (char-&gt;integer (car s)) (digitSum (cdr s)))]\n   \
    \ [else (digitSum (cdr s))]))\n</code>\nThe error is:\n<code>+: expects type &lt;number&gt;\
    \ as 1st argument, given: #\\t; other arguments were: #\\A\n</code>\nWhy? I wrote\
    \ this function because I believed that <code>char-&gt;integer</code> returned\
    \ the ASCII code.\nIf it doesn't, can you suggest how I can do that?\n\n\nA:\n\
    \n<code>char-&gt;integer</code> expects a <code>char</code> type, not a symbol:\n\
    <code>(char-&gt;integer #\\A)", '  (sum (filter (lambda (char) (and (>= char #\A)
    (<= char #\Z))) (string->list s))))', "  (for/sum ([c (in-string s)])\n    (if\
    \ (char-numeric? c)\n        (char->integer c)\n        0)))\n", "  (define (sumi\
    \ b)\n    (cond ((= b 0) 0)\n          ((char-upper-case? (string-ref s b))\n\
    \           (+ (char->integer (string-ref s b)) (sumi (- b 1))))\n          (else\
    \ (sumi (- b 1)))))\n  (sumi (- (string-length s) 1)))\n", "  (accumulate +\n\
    \              0\n              (map\n               char->integer\n         \
    \      (filter (\u03BB (x) (char-upper-case? x))\n                       (string->list\
    \ s)))))\n", "  (apply + (map (\u03BB (n) (char-&gt;integer n))\n            \
    \    (filter (\u03BB (n) (char-upper-case? n)) s))))\n", "  (define (ascii-code\
    \ s)\n    (string->list s))\n  (list->string (list->list (ascii-code s))))", " \
    \ (for/sum ((d (in-string s)))\n    (if (char-upper-case? d)\n        (- (char->integer\
    \ d) (- #\\A #\\a))\n        0)))\n", "  (sum (filter number? (string->list s))))\n",
  "  (let ((s (string-&gt;list s)))\n    (apply +\n           (map (lambda (c)\n \
    \                 (cond ((char-upcase? c) (- c #\\A)\n                       \
    \ ((char-downcase? c) (- c #\\a))\n                        (else 0)))\n      \
    \          s))))\n</code>\nNote that this solution allows for punctuation etc.\
    \ but I think that is what the original problem wanted.\n<code>=&gt; (digitSum\
    \ \"abcD\")", "  (define (appendSum n c)\n    (if (= n 0)\n        c\n       \
    \ (appendSum (- n 1) (string-append c (integer->string n)))))\n  (foldr\n   (lambda\
    \ (c m)\n     (let ((n (char->integer c)))\n       (if (and (>= n 65) (<= n 90))\n\
    \           (+ m n)\n           m)))\n   0 s))\n```\n\n## Scrabble\n\n```#lang\
    \ racket\n", "  (for/sum ([x (in-string s)])\n    (cond\n      [(char-upper-case?\
    \ x) (char->integer x)]\n      [else 0])))", "  (let loop ([s s] [acc 0])\n  \
    \  (if (empty? s)\n        acc\n        (let ([first (first s)])\n          (if\
    \ (and (>= first 65) (<= first 90))\n              (loop (rest s) (+ acc first))\n\
    \              (loop (rest s) acc))))))\n", "    (if (empty? s)\n        0\n \
    \       (if (char-alphabetic? (first s))\n            (if (char-upper-case? (first\
    \ s))\n                (+ (char->integer (first s)) (digitSum (rest s)))\n   \
    \             (digitSum (rest s)))\n            (digitSum (rest s)))))\n", " \
    \ (let ((len (string-length s)))\n    (for/sum ([i (in-range len)])\n      (let\
    \ ((c (string-ref s i)))\n        (if (and (>= c #\\A) (<= c #\\Z))\n        \
    \    (- c #\\A)\n            0)))))\n", "  (apply + (map char->integer (filter\
    \ char-upper-case? (string->list s)))))\n", "  (for/sum ([c (in-string s)])\n\
    \    (cond\n      [(char-alphabetic? c)\n       (char-upcase c)]\n      [else\
    \ 0])))\n", "  (string-foldl + 0 (string-map char-upcase s) char-uppercase?))\n",
  "  (cond\n    [(empty? s) 0]\n    [(and (<= #\\A (first s)) (<= (first s) #\\Z))\n\
    \     (+ (char->integer (first s)) (digitSum (rest s)))]\n    [else (digitSum\
    \ (rest s))]))\n", "  (string-&gt;number (string-join (map (lambda (c)\n     \
    \                                  (string-ref c 0))\n                       \
    \              (filter char-upcase?\n                                        \
    \     (string-&gt;list s)))\n                                \"\")))\n</code>\n\
    This works in Racket and seems like the natural progression of the Haskell example.\
    \ However, I would appreciate some more specific and general feedback on it.\n\
    \n\nA:\n\nI'd start by saying that you're abusing <code>foldr</code> and <code>sum</code>\
    \ here, instead of what you should do, which is to read the characters one by\
    \ one.\n<code>digitSum :: [Char] -&gt; Int\ndigitSum = sum . map f\n  where f\
    \ x = if isUpper x then ord x - ord 'A' + 1 else 0\n</code>\nI believe that the\
    \ Haskell version is fine.  \nThe Racket version isn't bad either, but can be\
    \ made better.  As an example, you can replace <code>string-&gt;list</code> with\
    \ <code>string-&gt;immutable-string</code> and get somewhat better performance\
    \ (I've not tested this).  Also, if you're using <code>Racket</code> then <code>string-&gt;number</code>\
    \ is not the right way to do things, you should use <code>string-&gt;number/locale</code>.\n\
    I would prefer to write the racket version like this:\n<code>(define (digit-sum\
    \ s)\n  (string-&gt;number/locale\n   (string-join\n    (string-map\n     (lambda\
    \ (c) (if (char-upcase? c) (integer-&gt;string (char-&gt;integer c)\n        \
    \            (void)))\n     (string-&gt;immutable-string s))))\n</code>\nNote\
    \ that this version calls <code>integer-&gt;string</code> for both upper-case\
    \ and lower-case characters.  This is not strictly necessary, but by doing so\
    \ I avoid the ugly <code>(void)</code> expression.\nAlso, note that if you really\
    \ want it to look like the Haskell version, then you can use <code>integer-&gt;char</code>",
  "  (cond\n    [(empty? s) 0]\n    [(and (char-numeric? (first s)) (char-uppercase?\
    \ (first s))) (+ (string->number (string (first s))) (digitSum (rest s)))]\n \
    \   [(and (char-numeric? (first s)) (char-lowercase? (first s))) (digitSum (rest\
    \ s))]\n    [else (digitSum (rest s))]))\n", "  (for/sum ((ch (in-string s)))\n\
    \    (if (char-upper-case? ch)\n        (char->integer ch)\n        0)))\n", " \
    \ (let loop ((s s) (acc 0))\n    (cond\n      [(empty? s) acc]\n      [(char-numeric?\
    \ (car s)) (loop (cdr s) (+ acc (car s)))]\n      [else (loop (cdr s) acc)])))\n",
  "  (if (empty? s)\n      0\n      (let ([c (first s)])\n        (if (char-alphabetic?\
    \ c)\n            (if (char-upper-case? c)\n                (+ (char->integer\
    \ c) (digitSum (rest s)))\n                (digitSum (rest s)))\n            (digitSum\
    \ (rest s))))))\n", "  (for/sum ((i (in-string s)))\n    (if (and (&gt;= i 65)\
    \ (&lt;= i 90)) i 0)))\n", "  (define (solve s i sum)\n    (cond [(>= i (string-length\
    \ s)) sum]\n          [(char-upcase? (string-ref s i)) (solve s (+ i 1) (+ sum\
    \ (string-ref s i)))]\n          [else (solve s (+ i 1) sum)]))\n  (solve s 0\
    \ 0))\n", "  (string-ref s 0))\n</code>\nThe above code throws the error when\
    \ run.\n<code>digitSum: unbound identifier in module in: digitSum\n</code>\nI\
    \ cannot work out what is wrong with the above code.\n\n\nA:\n\nThe body of <code>digitSum</code>\
    \ is in Racket, not in Scribble. When Scribble encounters a Racket expression,\
    \ it runs it and interpolates the results into the document.\nYou have to explicitly\
    \ mark the <code>digitSum</code> expression as Racket code:\n<code>@racket[digitSum\
    \ \"Hello\"]\n</code>\nA way to get <code>digitSum</code> to work in Scribble\
    \ is to define it in <code>scribble/eval</code>:\n<code>#lang scribble/eval\n\n\
    @(define (digitSum s)\n   (string-ref s 0))\n\n@digitSum \"Hello\"\n</code>\n\
    However, this won't work in a web page or in PDF output.\n", "  (apply + (map\
    \ char->integer (filter char-upcase? (string->list s)))))\n", "  (for/sum ([c\
    \ (in-string s)])\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char->integer c)\n            0)\n        0)))\n", "  (for/sum\
    \ ([x (in-string s)])\n    (if (char-numeric? x)\n        (char->integer x)\n\
    \        0)))\n", '  (apply + (filter odd? (map char->integer (string->list s)))))',
  "  (apply + (map (\u03BB (x) (if (char-numeric? x) (string->number (string x)) 0))\
    \ (string->list s))))\n", "  (apply + (map (lambda (c) (if (char-upcase? c) (char->integer\
    \ c) 0)) s)))\n", "  (apply + (for/list ([c (in-string s)])\n    (if (char-alphabetic?\
    \ c)\n      (if (char-upper-case? c)\n        (string->number (string c))\n  \
    \      0)))))\n", "  (define (helper s i)\n    (cond ((not (string=? i (string-length\
    \ s)))\n           (+ (char-&gt;integer (string-ref s i))\n              (helper\
    \ s (+ i 1))))\n          (else 0)))\n  (helper s 0))\n", "  (for/sum ([s (in-string\
    \ s)])\n    (if (char-upper-case? s)\n        (char->integer s)\n        0)))",
  "  (sum (string->list s)))\n", "  (local [(define (isUpper c)\n            (and\
    \ (char-alphabetic? c)\n                 (char-upper-case? c)))\n          (define\
    \ (isAlpha c)\n            (char-alphabetic? c))\n          (define (sum s)\n\
    \            (if (null? s)\n                0\n                (+ (char->integer\
    \ (car s))\n                   (sum (cdr s)))))\n          (define (select s)\n\
    \            (if (null? s)\n                s\n                (if (isUpper (car\
    \ s))\n                    (cons (car s) (select (cdr s)))\n                 \
    \   (select (cdr s)))))]\n    (sum (select s))))\n", "  (for/sum ([c (in-string\
    \ s)])\n    (if (char-upper-case? c)\n        (char->integer c)\n        0)))\n",
  "  (define (loop i sum)\n    (cond\n      [(&gt; i (string-length s)) sum]\n   \
    \   [(char-numeric? (string-ref s i))\n        (loop (+ i 1) (+ sum (string-&gt;number\
    \ (string s))))]\n      [else (loop (+ i 1) sum)]))\n  (loop 0 0))\n</code>\n\
    Unfortunately, my code is not working and I can't really get my head around the\
    \ problem.\n\n\nA:\n\nThe most common way to create a numeric accumulator is through\
    \ a <code>for/fold</code> construct:\n<code>(for/fold ([s 0]) ([c (in-string (read-line))])\n\
    \  (if (char-numeric? c)\n      (+ s (char-&gt;integer c))\n      s))\n</code>\n",
  "  (apply + (map char->integer (filter char-numeric? s))))\n", "  (define (sum-aux\
    \ i n)\n    (if (&gt; i n)\n        0\n        (+ (char-&gt;integer (string-ref\
    \ s i)) (sum-aux (+ i 1) n))))\n  (sum-aux 0 (- (string-length s) 1)))\n", " \
    \ (sum (map string-&gt;number (filter char-upcase? (string-&gt;list s)))))\n</code>\n\
    I believe it should be equivalent in principle to this Python version.\n<code>def\
    \ digit_sum(s):\n    return sum(ord(char) for char in s if char.isupper())\n</code>\n\
    But the following test\n<code>(module+ test\n  (require rackunit)\n  (check-equal?\
    \ (digitSum \"AaBbCc12\") 67)\n  (check-equal? (digitSum \"aBcDeFg123\") 198)\n\
    \  (check-equal? (digitSum \"AbCdEfGhIjKlM\") 735))\n</code>\nproduces this output:\n\
    <code>digitSum expected: 67  actual: 66\ndigitSum expected: 198  actual: 196\n\
    digitSum expected: 735  actual: 714\n</code>\nI can't understand why.\n\n\nA:\n\
    \nAlthough <code>ord</code> and <code>string-&gt;number</code> are in fact equivalent\
    \ for ASCII codes, if you are using Racket's default locale, it will use Unicode\
    \ code points instead, which is why your function does not work as expected for\
    \ the case of capital letters.\nIf you want to use ASCII codes instead, in this\
    \ case you should change the locale to <code>#f</code> before using <code>string-&gt;number</code>:\n\
    <code>(define (digitSum s)\n  (with-locale #f\n    (sum (map string-&gt;number\
    \ (filter char-upcase? (string-&gt;list s))))))\n</code>\n", "  (accumulate +\
    \ 0 (map (lambda (c) (- c 32)) (filter char-upper-case? (string->list s)))))\n",
  "  (define (char-&gt;digit char) (- char #\\0))\n  (define (char-is-digit? char)\
    \ (char-&gt;digit char))\n  (define (upper-char-? char) (&gt;= char #\\A))\n \
    \ (define (my-sum lst)\n    (cond\n      [(null? lst) 0]\n      [else (+ (car\
    \ lst) (my-sum (cdr lst)))]))\n  (define (nums-in-string s)\n    (filter char-is-digit?\
    \ (map char-&gt;digit s)))\n  (define (upper-nums-in-string s)\n    (filter upper-char-?\
    \ (nums-in-string s)))\n  (my-sum (upper-nums-in-string s)))\n", "  (define (char-val\
    \ c)\n    (char->integer c))\n  (define (upper? c)\n    (and (char? c)\n     \
    \    (char-numeric? c)\n         (>= (char-val c) 65)\n         (<= (char-val\
    \ c) 90)))\n  (foldl + 0 (filter upper? (string->list s))))\n", "  (local ((define\
    \ (charSum a)\n            (apply + (map char->integer (regexp-match #rx\"\\p{Upper}\"\
    \ a)))))\n    (charSum s)))\n</code>\nbut this works only for strings like 'ABCDEF'(I\
    \ mean one word), and I would like to make it work with whole text.\nAny ideas\
    \ how to achieve that?\nThanks\n\n\nA:\n\nTry this:\n<code>(define (digitSum s)\n\
    \  (apply +\n         (map (lambda (s) (apply + (map char-&gt;integer (regexp-match\
    \ #rx\"\\p{Upper}\" s))))\n              (string-split s))))\n</code>\nOr:\n<code>(define\
    \ (digitSum s)\n  (apply +\n         (map (compose (partial apply +)\n       \
    \                (partial map char-&gt;integer)\n                       (partial\
    \ regexp-match #rx\"\\p{Upper}\"))\n              (string-split s))))\n</code>\n\
    Note that this only works when all the upper letters are grouped in a single word.\
    \ So, if you have something like:\n<code>The quick brown fox jump over the lazy\
    \ dog\n</code>\nonly <code>THE</code> will be taken into account.\n", "  (let*\
    \ ([nums (string->list s)]\n         [sum 0])\n    (for ([i nums])\n      (when\
    \ (between? (char->integer i) 65 90)\n        (set! sum (+ sum (char->integer\
    \ i)))))\n    sum))\n", '  (accumulate + 0 (map char-&gt;integer (filter char-upper-case?
    (string-&gt;list s)))))', "  (cond [(empty? s) 0]\n        [else (+ (if (char-upper-case?\
    \ (first s))\n                    (char->integer (first s))\n                \
    \    0)\n                 (digitSum (rest s)))]))\n", "    (accumulate + 0 (map\
    \ char->integer (filter char-alphabetic? (string->list s)))))\n", "  (apply +\
    \ (map (lambda (c) (char-&gt;integer c)) (filter char-numeric? (map char-upcase\
    \ s)))))\n</code>\n", "  (apply + (map char->integer (filter char-upper-case?\
    \ (string->list s)))))\n", "  (apply + (map char->integer (filter char-upcase?\
    \ (string->list s)))))\n", "  (define (char-count lst)\n    (cond\n      [(null?\
    \ lst) 0]\n      [(char-upper-case? (car lst))\n       (+ (char->integer (car\
    \ lst)) (char-count (cdr lst)))]\n      [else (char-count (cdr lst))]))\n  (char-count\
    \ (string->list s)))\n", "  (let ([chars (string->list s)])\n    (for/sum ([c\
    \ chars])\n      (if (char-upper-case? c)\n          (char->integer c)\n     \
    \     0))))\n", "  (string-fold\n   (\u03BB (i sum) (+ sum (if (char-numeric?\
    \ i) (char->integer i) 0)))\n   0 s))\n", "  (let ([f (lambda (c)\n          \
    \   (if (char-alphabetic? c)\n                 (+ c (- (char-downcase c) (char-upcase\
    \ c)))\n                 0))])\n    (accumulate + 0 (string-&gt;list s) f)))\n",
  "  (apply + (map (lambda (c) (if (char-alphabetic? c) (char->integer c) 0)) (string->list\
    \ s))))\n", "  (cond [(equal? s \"\") 0]\n        [else (+ (char->integer (string-ref\
    \ s 0)) (digitSum (substring s 1)))]))\n", "  (cond [(string=? s \"\") 0]\n  \
    \      [else (+ (if (<= (string-ref s 0) 57) (string-ref s 0) 0) (digitSum (substring\
    \ s 1)))]))", "  (define (iter i sum)\n    (cond ((&gt; i (string-length s)) sum)\n\
    \          ((char-numeric? (string-ref s i)) (+ sum (char-&gt;integer (string-ref\
    \ s i))))\n          (else (iter (+ i 1) sum))))\n  (iter 0 0))\n", "  (for/sum\
    \ ((c (in-string s)))\n    (when (upper-case? c)\n      (char->integer c))))\n",
  "  (let ((sum 0))\n    (map\n     (lambda (c)\n       (cond\n         [(char&gt;=?\
    \ c #\\A)\n          (set! sum (+ sum (- c #\\A)))]\n         [(char&gt;=? c #\\\
    a)\n          (set! sum (+ sum (- c #\\a)))]))\n     (string-&gt;list s))\n  \
    \  sum))\n", "  (apply + (map char->integer (filter char-upper-case? (string->list\
    \ s)))))\n", "  (foldl + 0\n\t  (map (lambda (x) (if (char-upper-case? x) (- x\
    \ 32) x))\n\t       (string->list s))))\n", "  (foldl + 0 (map char->integer (filter\
    \ (compose char-upper-case? char-numeric?) s))))\n", '  (apply + (map (lambda
    (c) (if (char-numeric? c) (char->integer c) 0)) (string->list s))))', '  (apply
    + (map char->integer (filter char-upper-case? (string->list s)))))', "  (define\
    \ (accumulateSum currentSum char)\n    (if (char-upcase? char)\n        (+ currentSum\
    \ (char->integer char))\n        currentSum))\n  (apply + (map (\u03BB (char)\
    \ (accumulateSum 0 char)) s)))\n", "  (let ((str (string->list s)))\n    (if (empty?\
    \ str)\n        0\n        (+ (if (char-upper-case? (car str)) (car str) 0)\n\
    \           (digitSum (cdr str))))))", "  (sum (for/list ([c (in-string s)]) (string->number\
    \ (string c)))))\n", "  (apply + (map string-&gt;number (regexp-match* #rx\"[0-9]\"\
    \ s))))\n", "  (define (sum-digit c sum)\n    (if (char=? c #\\ ) sum\n      \
    \  (if (and (&gt;= c #\\0) (&lt;= c #\\9))\n            (+ sum (- c #\\0))\n \
    \           sum)))\n  (for/fold ([sum 0]) ([char (in-string s)])\n    (sum-digit\
    \ char sum)))\n</code>\nI have the following code for this task and it works for\
    \ lowercase and uppercase letters but does not work for mixed cases(lower-upper),\
    \ for example, for char \"C\" the output is 67 (sum of the uppercase \"C\") and\
    \ for mixed case \"cC\" the output is 67 + 67 = 134. I have tried to change the\
    \ initial value of \"sum\" to \"char\" but the same problem occurs, any suggestions?\
    \ \n\n\nA:\n\nYour code is simply wrong. You sum every char, even those which\
    \ are digits.\nI suggest to use <code>string-upcase</code> to put the string into\
    \ uppercase, and then <code>for/sum</code> to sum the digits:\n<code>(define (digitSum\
    \ s)\n  (for/sum ([char (in-string (string-upcase s))])\n    (- char #\\0)))\n\
    </code>\nAnother possibility would be to use <code>fold</code> and <code>string-index</code>\
    \ to iterate only over digits:\n<code>(define (digitSum s)\n  (for/fold ([sum\
    \ 0]) ([i (in-range (string-length s))])\n    (let ([char (string-ref s i)])\n\
    \      (if (and (&gt;= char #\\0) (&lt;= char #\\9))\n          (+ sum (- char\
    \ #\\0))\n          sum))))\n</code>\n", "  (apply + (map (\u03BB (x) (- x #\\\
    A 1))\n                (filter char-alphabetic?\n                        (string->list\
    \ s)))))\n", "  (define (toDigit c)\n    (cond [(char=? c #\\a) 1]\n         \
    \ [(char=? c #\\b) 2]\n          [(char=? c #\\c) 3]\n          [(char=? c #\\\
    d) 4]\n          [(char=? c #\\e) 5]\n          [(char=? c #\\f) 6]\n        \
    \  [(char=? c #\\g) 7]\n          [(char=? c #\\h) 8]\n          [(char=? c #\\\
    i) 9]\n          [(char=? c #\\j) 10]\n          [(char=? c #\\k) 11]\n      \
    \    [(char=? c #\\l) 12]\n          [(char=? c #\\m) 13]\n          [(char=?\
    \ c #\\n) 14]\n          [(char=? c #\\o) 15]\n          [(char=? c #\\p) 16]\n\
    \          [(char=? c #\\q) 17]\n          [(char=? c #\\r) 18]\n          [(char=?\
    \ c #\\s) 19]\n          [(char=? c #\\t) 20]\n          [(char=? c #\\u) 21]\n\
    \          [(char=? c #\\v) 22]\n          [(char=? c #\\w) 23]\n          [(char=?\
    \ c #\\x) 24]\n          [(char=? c #\\y) 25]\n          [(char=? c #\\z) 26]\n\
    \          [else 0]))\n  (define (helper s sum)\n    (cond [(empty? s) sum]\n\
    \          [(char-upper-case? (first s)) (helper (rest s) (+ sum (toDigit (first\
    \ s))))]\n          [else (helper (rest s) sum)]))\n  (helper s 0))\n", "  (apply\
    \ + (map (\u03BB (c) (if (char-upper-case? c) (char->integer c) 0)) (string->list\
    \ s))))\n", "  (accumulate + 0 (map char-&gt;integer (filter char-upper-case?\
    \ (string-&gt;list s)))))\n", "  (regexp-match* #rx\"\\\\d\" s))\n", "  (let ((sum\
    \ 0))\n    (for ((ch (in-string s)))\n      (when (char&lt;=? ch #\\Z)\n     \
    \   (set! sum (+ sum (- ch #\\A 1)))))\n    sum))\n", "  (cond\n    [(empty? s)\
    \ 0]\n    [(<= (char->integer (first s)) 64) (digitSum (rest s))]\n    [(<= (char->integer\
    \ (first s)) 94) (+ (char->integer (first s)) (digitSum (rest s)))]\n    [else\
    \ (digitSum (rest s))]))\n", "  (define (toDigit s)\n    (cond ((equal? (string-upcase\
    \ s) s)\n           (exact->inexact (string->number s)))\n          (else 0)))\n\
    \  (let ([res (map toDigit (string->list s))])\n    (apply + res)))\n", "  (let\
    \ lp ((s s) (total 0))\n    (cond\n      ((empty? s) total)\n      ((and (char=?\
    \ (car s) #\\A) (char=? (car s) #\\Z)) (+ total (char->integer (car s))))\n  \
    \    (else (lp (cdr s) total)))))", "  (for/sum ([ch (in-string s)])\n    (if\
    \ (char-alphabetic? ch)\n        (if (char-upper-case? ch)\n            (char->integer\
    \ ch)\n            0)\n        0)))", "  (foldl (lambda (s c) (if (and (&gt;=\
    \ c 65) (&lt;= c 90))\n                       (+ s (- c 64))\n               \
    \        s))\n         0\n         (string-&gt;list s)))\n", "  (apply + (map\
    \ ascii-&gt;integer\n                (string-&gt;list (string-upcase s)))))\n",
  '  (apply + (map char->integer (filter char-upper-case? (string->list s)))))', " \
    \ (define-values (found val) (foldl (lambda (x (found val))\n                \
    \                      (if (char-upcase? x)\n                                \
    \          (values #t (+ val (char->integer x)))\n                           \
    \               (values found val)))\n                                    (values\
    \ #f 0)\n                                    s))\n  val)", "  (apply + (map char->integer\
    \ (filter char-upper-case? (string->list s)))))\n", "  (apply + (map string-&gt;number\
    \ (filter char-upper-case? (string-&gt;list s)))))\n", "  (cond ((= s 0) 0)\n\
    \        ((&lt; 0 s) (+ (remainder s 10) (digitSum (quotient s 10))))\n      \
    \  ((&gt; 0 s) (+ (remainder s 10) (digitSum (quotient s 10))))))\n", "  (sum\
    \ \n   (map (\u03BB (c) (- c #\\A))\n        (filter char-alphabetic?\n      \
    \          (string->list s)))))\n", "  (map char-&gt;integer (filter char-upper-case?\
    \ s)))\n</code>\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
