name: HumanEval_29_filter_by_prefix
language: rkt
prompt: "#lang racket\n\n;; Filter an input list of strings only for ones that start\
  \ with a given prefix.\n(define (filter_by_prefix strings prefix)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n\
  \    (check-equal? (candidate (list ) \"john\") (list ))\n    (check-equal? (candidate\
  \ (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list\
  \ \"xxx\" \"xxxAAA\" \"xxx\"))\n))\n\n(test-humaneval)"
completions: ["  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter\
    \ (lambda (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda (str)\
    \ (string-prefix? prefix str)) strings))\n", "  (define (starts-with-prefix? string)\n\
    \    (and (>= (string-length string) (string-length prefix))\n         (string=?\
    \ (substring string 0 (string-length prefix)) prefix)))\n  (filter starts-with-prefix?\
    \ strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (let* ([len (string-length prefix)]\n         [matches (filter (lambda (s) (equal?\
    \ (substring s 0 len) prefix)) strings)])\n    matches))\n", "  (let loop ([strings\
    \ strings])\n    (if (empty? strings)\n        empty\n        (if (string-prefix?\
    \ prefix (first strings))\n            (cons (first strings) (loop (rest strings)))\n\
    \            (loop (rest strings))))))\n</code>\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (filter (\u03BB\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (str)\
    \ (string-prefix? prefix str)) strings))\n", "  (define (compare str)\n    (and\
    \ (string? str)\n         (string-prefix? prefix str)))\n  (filter compare strings))\n\
    </code>\nHere's the code:\n<code>#lang racket\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n\
    </code>\n", "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n</code>\nAnd then you\
    \ can use it like this:\n<code>&gt; (filter_by_prefix '(\"cat\" \"cap\" \"dog\"\
    \ \"doge\") \"do\")\n'(\"dog\" \"doge\")\n</code>\n", "  (filter (\u03BB (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (lambda (str) (string-prefix? prefix str))\
    \ strings))\n", "  (filter (lambda (str) (and (string? str) (string-prefix? prefix\
    \ str))) strings))\n", "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n",
  "  (filter (curryr substring? prefix) strings))\n", "  (filter (lambda (str) (string-prefix?\
    \ prefix str)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x))\
    \ strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (s) (equal? (substring s 0 (string-length prefix)) prefix)) strings))\n", " \
    \ (if (empty? strings)\n      strings\n      (if (string-prefix? prefix (first\
    \ strings))\n          (cons (first strings) (filter_by_prefix (rest strings)\
    \ prefix))\n          (filter_by_prefix (rest strings) prefix))))\n", "  (define\
    \ (prefix-match? string)\n    (string-prefix? prefix string))\n  (filter prefix-match?\
    \ strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n</code>\nThe test:\n<code>#lang racket\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (string)\
    \ (string-prefix? prefix string)) strings))\n", "  (filter (lambda (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (curryr string-prefix? prefix) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (\u03BB (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (for/list ([string strings])\n    (when (string-prefix?\
    \ prefix string)\n      string)))\n", "  (filter (lambda (s) (string-prefix? prefix\
    \ s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB\
    \ (string) (string-prefix? prefix string)) strings))\n</code>\nNow, I want to\
    \ write a unit test that tests the behaviour of that function. I use Racket's\
    \ built-in unit testing framework, but this is not the focus of the question.\n\
    Here is the unit test:\n<code>#lang racket\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (for/list ([string strings])\n\
    \    (when (string-prefix? prefix string)\n      string)))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (cond\n    [(empty? strings)\
    \ '()]\n    [(string-prefix? prefix (first strings))\n     (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix (rest\
    \ strings) prefix)]))\n", "  (filter (lambda (word) (string-prefix? prefix word))\
    \ strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n\
    </code>\nThe above works, but I'd like to generalize it to use any kind of <code>equal?</code>\
    \ and not just <code>string-prefix?</code>. For example, the following does not\
    \ compile:\n<code>#lang racket\n", "  (filter (lambda (x) (string-prefix? prefix\
    \ x)) strings))\n", "  (if (empty? strings)\n      empty\n      (if (string-prefix?\
    \ prefix (first strings))\n          (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))\n          (filter_by_prefix (rest strings) prefix))))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (elem) (string-prefix? prefix elem)) strings))\n", "  (cond ((null? strings)\n\
    \         (list))\n        ((string-prefix? prefix (car strings))\n         (cons\
    \ (car strings)\n               (filter_by_prefix (cdr strings) prefix)))\n  \
    \      (else\n         (filter_by_prefix (cdr strings) prefix))))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (curryr string-prefix?\
    \ prefix) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n\
    </code>\nNotes:\n\nThe filter primitive takes a predicate function to select values\
    \ from a list, so we can just pass in <code>string-prefix?</code> to do the work\
    \ for us.\nstring-prefix? returns true if the second argument is the prefix of\
    \ the first one, so you can pass it <code>prefix</code> as the second argument\
    \ and it will check the input strings to see if they start with the prefix.\n\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (lambda (x) (string-prefix? prefix x)) strings))\n", "  (filter (\u03BB (s)\
    \ (string-prefix? prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (curry\
    \ string-prefix? prefix) strings))\n", "  (filter (\u03BB (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (curryr string-prefix?\
    \ prefix) strings))\n", "  (filter (lambda (str) (string-prefix? prefix str))\
    \ strings))\n", "  (for/list ([s strings]\n             #:when (string-prefix?\
    \ prefix s))\n    s))\n</code>\nI'd like to have a solution that takes in a list\
    \ of prefixes and filters for strings that start with any of those prefixes.\n\
    Here's my attempt:\n<code>#lang racket\n", "  (filter (lambda (str) (string-prefix?\
    \ prefix str)) strings))\n", "  (filter (\u03BB (str) (string-prefix? prefix str))\
    \ strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (\u03BB (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (string) (string-prefix?\
    \ prefix string)) strings))\n", "  (filter (\u03BB (s) (string-prefix? prefix\
    \ s)) strings))\n", "  (define (starts-with? str)\n    (string-prefix? prefix\
    \ str))\n  (filter starts-with? strings))\n", "  (filter (lambda (str) (string-prefix?\
    \ prefix str)) strings))\n", "  (match strings\n    [(cons s rest)\n     (if (string-prefix?\
    \ prefix s)\n         (cons s (filter_by_prefix rest prefix))\n         (filter_by_prefix\
    \ rest prefix))]\n    [(list) '()]))\n", "  (filter (lambda (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (for/list ([string strings])\n    (when (string-prefix?\
    \ prefix string)\n      string)))\n", "  (filter (lambda (x) (string-prefix? prefix\
    \ x)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (for/list\
    \ ([s strings]\n             #:when (string-prefix? prefix s))\n    s))\n", " \
    \ (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (str) (string-prefix?\
    \ prefix str)) strings))\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n</code>\nSo on the command line you could do:\n<code>racket\
    \ script.rkt prefix otherargs\n</code>\nAnd the <code>filter_by_prefix</code>\
    \ function would be usable in the rest of your Racket script.\n", "  (if (empty?\
    \ strings)\n      empty\n      (if (string-prefix? prefix (first strings))\n \
    \         (cons (first strings) (filter_by_prefix (rest strings) prefix))\n  \
    \        (filter_by_prefix (rest strings) prefix))))\n", "  (filter (lambda (string)\
    \ (string-prefix? prefix string)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (x) (string-prefix? prefix x)) strings))\n</code>\n", "  (filter (lambda (x)\
    \ (string-prefix? prefix x)) strings))\n", "  (filter (lambda (string) (string-prefix?\
    \ prefix string)) strings))\n", "  (filter (\u03BB (x) (string-prefix? prefix\
    \ x)) strings))\n", "  (filter (\u03BB (string) (string-prefix? prefix string))\
    \ strings))\n", "  (filter (lambda (word) (string-prefix? prefix word)) strings))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (\u03BB (element) (string-prefix? prefix\
    \ element)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (for/list ([string strings])\n    (if (string-prefix? prefix string)\n      \
    \  string)))\n", "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n",
  "  (for/list ([s strings]\n             #:when (string-prefix? prefix s))\n    s))\n\
    </code>\nThen use this to define another filtering predicate:\n<code>;; Filter\
    \ for strings that start with any of a given set of prefixes.", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (define (filter_by_prefix_iter\
    \ strings filtered)\n    (cond\n      [(empty? strings) filtered]\n      [(string-prefix?\
    \ prefix (first strings))\n       (filter_by_prefix_iter (rest strings) (cons\
    \ (first strings) filtered))]\n      [else (filter_by_prefix_iter (rest strings)\
    \ filtered)]))\n  (reverse (filter_by_prefix_iter strings empty)))\n", "  (filter\
    \ (lambda (string) (prefix? prefix string)) strings))\n</code>\nSo far I have\
    \ the following code:\n<code>#lang racket\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (for/list ([s strings] #:when (string-prefix? prefix s))\n    s))\n", "  (filter\
    \ (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n</code>\nThis works fine, but\
    \ I want to use a shortcut instead of writing <code>(string-prefix? prefix str)</code>\
    \ every time. I tried this, to no avail:\n<code>#lang racket\n", "  (filter (lambda\
    \ (string) (string-prefix? prefix string)) strings))\n", "  (filter (lambda (s)\
    \ (string-prefix? prefix s)) strings))\n", "  (filter (lambda (string) (string-prefix?\
    \ prefix string)) strings))\n", "  (define (starts-with-prefix? string)\n    (string-prefix?\
    \ prefix string))\n  (filter starts-with-prefix? strings))\n", "  (for/list ([string\
    \ strings])\n    (if (string-prefix? prefix string)\n        string)))\n", " \
    \ (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (cond ((null?\
    \ strings) '())\n        ((string-prefix? prefix (car strings))\n         (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix)))\n        (else (filter_by_prefix\
    \ (cdr strings) prefix))))\n", "  (filter (\u03BB (s) (string-prefix? prefix s))\
    \ strings))\n</code>\nThis works fine in DrRacket, but when I try to export this\
    \ to an executable file, I get this error:\n<code>eval:12:0: string-prefix?: expects\
    \ type &lt;string literal&gt; as 2nd argument, given: prefix; other arguments\
    \ were: \"hello\"\n</code>\nHow can I fix this to make it compatible with Racket's\
    \ executable file format?\n\n\nA:\n\nI think the issue is that DrRacket is not\
    \ giving you an executable, but rather a <code>.zo</code> (compiled bytecode)\
    \ file. From DrRacket's UI, you need to \"Save as Executable\" and not \"Save\"\
    \ (under the File menu).\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (for/list ([str\
    \ strings])\n    (when (string-prefix? prefix str)\n      str)))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (letrec ([compare (lambda\
    \ (value string)\n                       (cond\n                         [(= 0\
    \ (regexp-match #rx\"^\" (string-append prefix value)))\n                    \
    \      #t]\n                         [else\n                          #f]))]\n\
    \           [decide (lambda (values)\n                     (map (lambda (value)\n\
    \                            (if (compare value)\n                           \
    \     value\n                                \"\"))\n                        \
    \  values))]\n           [reduce (lambda (values)\n                     (let ([reduced\
    \ (decide values)])\n                       (if (not (equal? values reduced))\n\
    \                           (reduce reduced)\n                           reduced)))])\n\
    \    (reduce strings)))\n", "  (for/list ([s strings]\n             #:when (and\
    \ (string? s)\n                         (string-prefix? prefix s)))\n    s))\n",
  "  (for/list ([s strings]\n             #:when (string-prefix? prefix s))\n    s))\n",
  "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n</code>\nThis works well when <code>strings</code>\
    \ is a fixed list. However, I'd like to make it so that the function takes a function\
    \ of type <code>() -&gt; (listof string)</code> that returns a string list to\
    \ filter. The idea is that the <code>strings</code> will depend on I/O.\nFor example,\
    \ it could work with a function that returns the contents of a file:\n<code>#lang\
    \ racket\n", "  (filter (\u03BB (x) (string-prefix? prefix x)) strings))\n", " \
    \ (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter\
    \ (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (for/list ([str strings])\n    (cond [(string-prefix?\
    \ prefix str) str]\n          [else #f])))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (for/list ([s strings] #:when (string-prefix? prefix\
    \ s))\n    s))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (regexp-match? (regexp (string-append \"^\" prefix)) s))\
    \ strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (word) (string-prefix? prefix word)) strings))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (a)\
    \ (string-prefix? prefix a)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (for/list ([s strings]\n             #:when (string-prefix?\
    \ prefix s))\n    s))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (if (string-prefix? prefix (car strings))\n      (cons (car strings) (filter_by_prefix\
    \ (cdr strings) prefix))\n      (filter_by_prefix (cdr strings) prefix)))\n",
  "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda (s) (equal?\
    \ (string-take s 1) prefix)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (match strings\n    [`(,string . ,rest)\n     (cond\
    \ [(string-prefix? prefix string)\n            (cons string (filter_by_prefix\
    \ rest prefix))]\n           [else\n            (filter_by_prefix rest prefix)])]\n\
    \    [_ '()]))\n</code>\n", "  (for/list ([s strings]\n             #:when (regexp-match?\
    \ (regexp (string-append \"^\" prefix)) s))\n    s))\n", "  (for/list ([s strings]\n\
    \             #:when (string-prefix? prefix s))\n    s))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (define (is-prefix? prefix s)\n\
    \    (equal? (substring s 0 (string-length prefix)) prefix))\n  (filter is-prefix?\
    \ strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (\u03BB (s) (regexp-match? (regexp (string-append \"^\" prefix)) s))\
    \ strings))\n</code>\nThe <code>strings</code> parameter is the list of strings\
    \ to filter, and the <code>prefix</code> parameter is the prefix to filter by.\n\
    If you have a Racket <code>#lang</code> in your code, you must also have a <code>#lang</code>\
    \ in your test file.  My preference for testing Racket code is to use <code>#lang\
    \ racket/base</code> and to use <code>require</code> to bring in what I need.\
    \  I'll use <code>#lang eopl</code> because that's what you're using, but I don't\
    \ think you necessarily need to use <code>#lang eopl</code> for testing.\nIn any\
    \ case, the tests:\n<code>#lang eopl\n", "  (filter (lambda (x) (string-prefix?\
    \ prefix x)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (for/list ([s strings]\n             #:when (string-prefix? prefix s))\n    s))\n",
  "  (filter (lambda (string) (equal? (substring string 0 (string-length prefix))\
    \ prefix)) strings))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (regexp-match? (regexp (string-append \"^\" prefix)) s))\
    \ strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n</code>\n\
    For example,\n<code>(filter_by_prefix '(\"apple\" \"orange\" \"banana\" \"grape\"\
    \ \"pear\") \"a\")\n\n=&gt; '(\"apple\" \"banana\")\n</code>\nI would like to\
    \ make it more flexible by allowing a list of prefixes to be passed in. What is\
    \ the best way to do this?\nI can write a function that accepts both a single\
    \ prefix and a list of prefixes by using the <code>or</code> function, but I'm\
    \ not sure if this is idiomatic Racket.\n<code>#lang racket\n", "  (filter (lambda\
    \ (word) (string-prefix? prefix word)) strings))\n", "  (for/list ([string strings])\n\
    \    (if (string-prefix? prefix string)\n        string)))\n</code>\nI wrote a\
    \ test for this using Racket's <code>check-equal?</code>.\n<code>#lang racket\n",
  "  (filter (\u03BB (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB (e) (string-prefix?\
    \ prefix e)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n</code>\nAnd then use\
    \ it to find the strings whose first character is a capital letter:\n<code>#lang\
    \ racket\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
