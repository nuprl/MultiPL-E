name: HumanEval_118_get_closest_vowel
language: rkt
prompt: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
  \ vowel that stands between \n;; two consonants from the right side of the word\
  \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
  \ empty string if you didn't\n;; find any vowel met the above condition. \n;; You\
  \ may assume that the given string contains English letter only.\n;; Example:\n\
  (define (get_closest_vowel word)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
  \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"\
  full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
  \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
  \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n  \
  \  (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\")\
  \ \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
  \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
  \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
completions: ["  (define vowels '(#\\a #\\e #\\i #\\o #\\u))\n  (let loop ((i -1)\
    \ (last-i -1))\n    (if (string-empty? word)\n        (string (get-char word last-i))\n\
    \        (if (member (string-ref word i) vowels)\n            (if (= (- i last-i)\
    \ 2)\n                (string (get-char word i))\n                (loop (- i 1)\
    \ i))\n            (loop (- i 1) last-i)))))\n", "  (cond ((equal? (length word)\
    \ 1) \"\")\n        ((equal? (length word) 2) \"\")\n        ((member? (string-ref\
    \ word 0) '(#\\a #\\e #\\i #\\o #\\u))\n          (get_closest_vowel (string-drop\
    \ word 1)))\n        ((member? (string-ref word (- (length word) 1)) '(#\\a #\\\
    e #\\i #\\o #\\u))\n          (get_closest_vowel (string-drop-right word 1)))\n\
    \        ((member? (string-ref word 1) '(#\\a #\\e #\\i #\\o #\\u))\n        \
    \  (string-ref word 1))\n        ((member? (string-ref word (- (length word) 2))\
    \ '(#\\a #\\e #\\i #\\o #\\u))\n          (string-ref word (- (length word) 2)))\n\
    \        (else (get_closest_vowel (string-drop-right word 1)))))\n", "  (define\
    \ (is-vowel? c)\n    (memq c '(#\\a #\\e #\\i #\\o #\\u)))\n  (define (consonant-vowel?\
    \ word)\n    (define (loop word index left right)\n      (cond\n        [(empty?\
    \ word)  #f]\n        [(zero? index)  #f]\n        [(and (is-vowel? (car word))\
    \ (not (is-vowel? left)) (not (is-vowel? right))) #t]\n        [else         \
    \ (loop (cdr word) (sub1 index) (car word) right)]))\n    (loop word (sub1 (length\
    \ word)) #\\x #\\x))\n  (define (loop word closest-vowel index)\n    (cond\n \
    \     [(empty? word)        closest-vowel]\n      [(is-vowel? (car word)) (loop\
    \ (cdr word) (cons (car word) index) (add1 index))]\n      [else             \
    \    (loop (cdr word) closest-vowel       (add1 index))]))\n  (let* ([word   (string->list\
    \ word)]\n         [vowels (loop word empty 0)])\n    (if (consonant-vowel? word)\
    \ (list-ref word (car (cdr (reverse vowels)))) #f)))\n", "  (if (regexp-match\
    \ #rx\"^[^aeiou]*[aeiou][^aeiou]*$\" word)\n      (string-between word (regexp-match\
    \ #rx\"[aeiou].*[aeiou]\" word))\n      \"\"))\n", "  (let ([word (string-&gt;list\
    \ word)])\n    (if (or (string-&gt;list \"bcdfghjklmnpqrstvwxyz\") (string-&gt;list\
    \ \"BCDFGHJKLMNPQRSTVWXYZ\"))\n        \"\"\n        (let ([pair (regexp-match*\
    \ #rx\"([aeiou])\\\\1\" word)])\n          (if pair\n              (list-ref pair\
    \ 0)\n              \"\")))))\n", "  (define (find-vowel word)\n    (cond [(string-empty?\
    \ word) \"\"]\n          [(string-any string-ci-equal? word \"AEIOU\") word]\n\
    \          [else (find-vowel (substring word 1))]))\n  (if (string-ci-equal? (substring\
    \ word -1) \"a\")\n      \"\"\n      (let ((word (reverse word)))\n        (if\
    \ (string-any string-ci-equal? word \"AEIOU\")\n            (let ((vowel (find-vowel\
    \ word)))\n              (if (string-any string-ci-equal? (substring vowel 1)\
    \ \"BCDFGHJKLMNPQRSTVWXYZ\")\n                  (reverse vowel)\n            \
    \      \"\"))\n            \"\"))))\n", "  (let ((vowels '(\"a\" \"e\" \"i\" \"\
    o\" \"u\" \"y\")))\n    (if (empty? word)\n        \"\"\n        (if (member (first\
    \ word) vowels)\n            \"\"\n            (if (member (last word) vowels)\n\
    \                \"\"\n                (let ((pos (search-from-right-to-left (lambda\
    \ (x) (member x vowels)) (rest (reverse (rest (reverse word)))))))\n         \
    \         (if (and pos (&gt; pos 0))\n                      (string-ref word (-\
    \ (+ pos 2) (length word)))\n                      \"\")))))))\n</code>\nTesting\
    \ the above code and other possible solutions can be done through the interactive\
    \ prompt, for example:\n<code>&gt; (get_closest_vowel \"helloworld\")\n\"o\"\n\
    </code>\n", "  (match word\n    ['() \"\" ]\n    [consonant '() (string-append\
    \ consonant \"\")]\n    [consonant (consonant' . rest) (if (member (car rest)\
    \ \"aeiou\") (string-append consonant (car rest)) (get_closest_vowel (consonant'\
    \ . rest)))]\n    [vowel rest (get_closest_vowel rest)]))\n", "  (unless (empty?\
    \ word)\n    (cond\n      ((equal? (first word) #\\a) 'a)\n      ((equal? (first\
    \ word) #\\e) 'e)\n      ((equal? (first word) #\\i) 'i)\n      ((equal? (first\
    \ word) #\\o) 'o)\n      ((equal? (first word) #\\u) 'u)\n      (else (get_closest_vowel\
    \ (rest word))))))\n</code>\n", "  (define vowels '(#\\a #\\e #\\i #\\o #\\u))\n\
    \  (if (null? word)\n      (void)\n      (if (memq (car word) vowels)\n      \
    \    (if (and (not (memq (car (cdr word)) vowels))\n                   (not (memq\
    \ (car (cdr (cdr word))) vowels)))\n              (list (car word))\n        \
    \      (get_closest_vowel (cdr word)))\n          (get_closest_vowel (cdr word)))))\n",
  "  (define (get-vowels-pos lst)\n    (filter (lambda (x) (string-contains \"aeiouAEIOU\"\
    \ (list-ref lst x))) (range (length lst))))\n  (if (empty? (get-vowels-pos word))\n\
    \      \"\"\n      (let ((word-lst (string->list word)))\n        (list->string\n\
    \         (filter (lambda (x) (or (= x (first (get-vowels-pos word-lst))) (= x\
    \ (last (get-vowels-pos word-lst))))) word-lst)))))\n", "  (cond [(regexp-match\
    \ #rx\"^[^aeiou]+$\" word) \"\"]\n        [(regexp-match #rx\"[^aeiou]+[aeiou][^aeiou]+$\"\
    \ word) (regexp-match #rx\"[aeiou]\" word)]\n        [else (get_closest_vowel\
    \ (string-tail word 1))]))\n", "  (define (vowel? c)\n    (or (char=? c #\\a)\
    \ (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u)))\n  (define\
    \ (consonant? c)\n    (not (vowel? c)))\n  (define (pairs str)\n    (if (empty?\
    \ str) str\n        (append (map (lambda (x) (list (car str) x)) (cdr str))\n\
    \                (pairs (cdr str)))))\n  (define (get-pairs str)\n    (filter\
    \ (lambda (x) (consonant? (car x)) (consonant? (cadr x))) (pairs str)))\n  (define\
    \ (get-closest str)\n    (if (not (get-pairs str)) #f\n        (foldr (lambda\
    \ (x acc)\n                 (if (not acc) x\n                     (if (< (- (cadr\
    \ x) (car x)) (- (cadr acc) (car acc))) x acc))) #f (get-pairs str))))\n  (if\
    \ (not (get-closest word)) #f\n      (foldr (lambda (x acc)\n               (if\
    \ (not acc) (string x)\n                   (if (< (- (cadr x) (car x)) (- (cadr\
    \ acc) (car acc))) (string x) acc))) #f (get-closest word))))", "  (let ((word-vec\
    \ (vector-&gt;list word)))\n    (cond\n      ((or (= 0 (length word-vec)) (= 1\
    \ (length word-vec)))\n       \"\"\n       )\n      (else\n       (let ((last-consonant-idx\
    \ (index-of-last-consonant word-vec)))\n         (let ((closest-vowel-idx (index-of-closest-vowel\
    \ word-vec last-consonant-idx)))\n           (if closest-vowel-idx\n         \
    \      (vector-ref word-vec closest-vowel-idx)\n               \"\"\n        \
    \       )\n           )\n         )\n       )\n      )\n    )\n  )\n", "  (define\
    \ (get-vowels word)\n    (cond [(empty? word) '()]\n          [(char-set=? (string-&gt;list\
    \ \"aeiou\") (char-set word))\n           (cons (string word) (get-vowels (rest\
    \ word)))]\n          [else (get-vowels (rest word))]))\n  (cond [(empty? word)\
    \ \"\"]\n        [(char-set=? (string-&gt;list \"aeiou\") (char-set word))\n \
    \        (cons (string word) (get-vowels (rest word)))]\n        [else (get-vowels\
    \ (rest word))]))\n", "  (cond [(string-empty? word) \"\"]\n        [(and (not\
    \ (member (last word) \"aeiou\"))\n              (member (last (butlast word))\
    \ \"aeiou\"))\n         (last (butlast word))]\n        [else (get_closest_vowel\
    \ (butlast word))]))\n", "  (define (check l c)\n    (cond\n      [(and (= l '#\\\
    a) (= c '#\\b)) #\\a]\n      [(and (= l '#\\e) (= c '#\\b)) #\\e]\n      [(and\
    \ (= l '#\\i) (= c '#\\b)) #\\i]\n      [(and (= l '#\\o) (= c '#\\b)) #\\o]\n\
    \      [(and (= l '#\\u) (= c '#\\b)) #\\u]\n      [(and (= l '#\\a) (= c '#\\\
    d)) #\\a]\n      [(and (= l '#\\e) (= c '#\\d)) #\\e]\n      [(and (= l '#\\i)\
    \ (= c '#\\d)) #\\i]\n      [(and (= l '#\\o) (= c '#\\d)) #\\o]\n      [(and\
    \ (= l '#\\u) (= c '#\\d)) #\\u]\n      [(and (= l '#\\a) (= c '#\\f)) #\\a]\n\
    \      [(and (= l '#\\e) (= c '#\\f)) #\\e]\n      [(and (= l '#\\i) (= c '#\\\
    f)) #\\i]\n      [(and (= l '#\\o) (= c '#\\f)) #\\o]\n      [(and (= l '#\\u)\
    \ (= c '#\\f)) #\\u]\n      [(and (= l '#\\a) (= c '#\\g)) #\\a]\n      [(and\
    \ (= l '#\\e) (= c '#\\g)) #\\e]\n      [(and (= l '#\\i) (= c '#\\g)) #\\i]\n\
    \      [(and (= l '#\\o) (= c '#\\g)) #\\o]\n      [(and (= l '#\\u) (= c '#\\\
    g)) #\\u]\n      [(and (= l '#\\a) (= c '#\\h)) #\\a]\n      [(and (= l '#\\e)\
    \ (= c '#\\h)) #\\e]\n      [(and (= l '#\\i) (= c '#", "  (let loop ([word (string-&gt;list\
    \ word)]\n             [i (length word)])\n    (cond\n      [(empty? word) \"\"\
    ]\n      [(and (char-ci=? (char-downcase (car word)) #\\a)\n            (member\
    \ (char-downcase (list-ref word (- i 1)))\n                    (list #\\c #\\\
    d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\\
    x #\\y #\\z)))\n       (string (car word))]\n      [else (loop (cdr word) (- i\
    \ 1))])))\n</code>\nThe above is the solution that I came up with, it works correctly:\n\
    <code>&gt; (get_closest_vowel \"ahjkstf\")\n\"a\"\n&gt; (get_closest_vowel \"\
    abxyz\")\n\"\"\n&gt; (get_closest_vowel \"bbbo\")\n\"\"\n&gt; (get_closest_vowel\
    \ \"cbbbb\")\n\"\"\n&gt; (get_closest_vowel \"dsff\")\n\"\"\n&gt; (get_closest_vowel\
    \ \"gtre\")\n\"\"\n&gt; (get_closest_vowel \"hjk\")\n\"\"\n&gt; (get_closest_vowel\
    \ \"ijk\")\n\"\"\n&gt; (get_closest_vowel \"jlm\")\n\"\"\n&gt; (get_closest_vowel\
    \ \"kbj\")\n\"\"\n&gt; (get_closest_vowel \"kjl\")\n\"\"\n&gt; (get_closest_vowel\
    \ \"lkj\")\n\"\"\n&gt; (get_closest_vowel \"mno\")\n\"\"\n&gt; (get_closest_vowel\
    \ \"nwgb\")\n\"\"\n&gt; (get_closest_vowel \"ohjk\")\n\"o\"\n&gt; (get_clos",
  "  (define (is-vowel? character)\n    (member character '(\"a\" \"e\" \"i\" \"o\"\
    \ \"u\" \"y\")))\n  (define (find-vowel-from-right word previous-is-vowel)\n \
    \   (cond [(empty? word) \"\"]\n          [(is-vowel? (first word))\n        \
    \   (if previous-is-vowel\n               (find-vowel-from-right (rest word) #t)\n\
    \               (first word))]\n          [else (find-vowel-from-right (rest word)\
    \ #f)]))\n  (find-vowel-from-right word #f))\n", "  (cond [(empty? word) \"\"\
    ]\n        [(empty? (rest word)) \"\"]\n        [(vowel? (first word)) \"\"]\n\
    \        [(empty? (rest (rest word))) \"\"]\n        [(and (vowel? (first (rest\
    \ word))) (consonant? (first word)) (consonant? (first (rest (rest word))))) (first\
    \ (rest word))]\n        [else (get_closest_vowel (rest word))]))\n", "  (local\
    \ [(define vowels \"aeiou\")\n          (define (right-most-vowel s)\n       \
    \     (let loop ([s s] [acc '()])\n              (cond [(string-empty? s) acc]\n\
    \                    [(char-set=? (string-&gt;list (string-downcase (string-ref\
    \ s 0))) vowels)\n                     (loop (string-drop s 1) (cons (string-ref\
    \ s 0) acc))]\n                    [else (loop (string-drop s 1) acc)])))]\n \
    \   (let loop ([word word] [acc '()])\n      (cond [(string-empty? word) '()]\n\
    \            [(char-set=? (string-&gt;list (string-downcase (string-ref word 0)))\
    \ vowels)\n             (loop (string-drop word 1) (cons (string-ref word 0) acc))]\n\
    \            [else (right-most-vowel (string-drop word 1))]))))\n", "  (let*\n\
    \      ([vowels (list \"a\" \"e\" \"i\" \"o\" \"u\")]\n       [rev-word (reverse\
    \ word)]\n       [last-letter (list-ref rev-word 0)]\n       [next-to-last-letter\
    \ (list-ref rev-word 1)])\n    (if (in-list? last-letter vowels)\n        (if\
    \ (in-list? next-to-last-letter vowels)\n            \"\"\n            last-letter)\n\
    \        \"\")))\n</code>\nWhen I run the solution with these inputs:\n<code>(check-expect\
    \ (get_closest_vowel \"dolce\") \"o\")", "  (let ((word-as-list (string-&gt;list\
    \ word)))\n    (cond\n      [(empty? word-as-list) \"\"]\n      [(empty? (rest\
    \ word-as-list)) \"\"]\n      [(and (char-vowel? (first word-as-list)) (char-vowel?\
    \ (second word-as-list)))\n       (get_closest_vowel (list-&gt;string (rest word-as-list)))]\n\
    \      [(and (char-vowel? (first word-as-list)) (char-consonant? (second word-as-list)))\n\
    \       (string (first word-as-list))]\n      [(and (char-consonant? (first word-as-list))\
    \ (char-vowel? (second word-as-list)))\n       (string (second word-as-list))]\n\
    \      [(and (char-consonant? (first word-as-list)) (char-consonant? (second word-as-list)))\n\
    \       (get_closest_vowel (list-&gt;string (rest word-as-list)))]\n      [else\
    \ (error 'get_closest_vowel \"Invalid input\")])))\n</code>\nThe error I get is:\n\
    <code>&gt; (get_closest_vowel \"scenarist\")\n#&lt;void&gt;\n&gt; \nThe second\
    \ element of this list is not a procedure;\nit cannot be applied.\n\nIf the second\
    \ element is a literal, try wrapping it in a quote.\n\nThe offending expression:\n\
    \  (rest \"scenarist\")\n\nThe context:\n  (condition-case ex [else (get_closest_vowel\
    \ (list-&gt;string (rest ...)))] (and (char-consonant? (first word-as-list)) (char-consonant?\
    \ (second word-as-list))))\n  [else (error 'get_closest_vowel \"Invalid input\"\
    )])))\n&gt; \n</code>\nNot sure what's wrong with the get_closest_vowel call.\
    \ \n\n\nA:\n", "  (cond [(empty? word) \"\"]\n        [(find-closest-vowel (reverse\
    \ word))]\n        [else \"\"]))\n", "  (define (vowel? char)\n    (member char\
    \ '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n  (define\
    \ (consonant? char)\n    (and (not (vowel? char)) (char-alphabetic? char)))\n\
    \  (define (find-closest-vowel word)\n    (cond ((null? word) (error \"Word contains\
    \ no vowels at all\"))\n          ((vowel? (car word)) (car word))\n         \
    \ (else (find-closest-vowel (cdr word)))))\n  (define (find-closest-consonant\
    \ word)\n    (cond ((null? word) (error \"Word contains no consonants at all\"\
    ))\n          ((consonant? (car word)) (car word))\n          (else (find-closest-consonant\
    \ (cdr word)))))\n  (define (find-closest-vowel-from-right word)\n    (if (or\
    \ (vowel? (car word)) (null? word))\n        (word)\n        (find-closest-vowel-from-right\
    \ (cdr word))))\n  (let ((word-len (string-length word)))\n    (if (= word-len\
    \ 1)\n        (string)\n        (let* ((last-char (substring word (- word-len\
    \ 1) word-len))\n               (last-but-one-char (substring word (- word-len\
    \ 2) (- word-len 1)))\n               (reverse-word (reverse (string->list word)))\n\
    \               (first-vowel (find-closest-vowel reverse-word))\n            \
    \   (first-consonant (find-closest-consonant reverse-word))\n               (closest-vowel-from-right\
    \ (find-closest-vowel-from-right reverse-word)))\n          (if (and (vowel? last-char)\
    \ (consonant? last-but-one-char))\n              (list->string closest-vowel-from-right)\n\
    \              (list->string (reverse (cdr (", "  (let loop ([remaining-word (reverse\
    \ word)]\n             [prev-char '~])\n    (cond [(empty? remaining-word) \"\"\
    ]\n          [(char-vowel? (first remaining-word))\n           (if (char-vowel?\
    \ prev-char)\n               (loop (rest remaining-word) (first remaining-word))\n\
    \               (string (first remaining-word)))]\n          [else (loop (rest\
    \ remaining-word) (first remaining-word))])))\n", "  (letrec ((vowels (string-&gt;list\
    \ \"aeiou\"))\n           (counter 0)\n           (last-letter (string-length\
    \ word -1))\n           (find_vowel\n            (lambda (word-list counter)\n\
    \              (if (null? word-list)\n                  \"\"\n               \
    \   (let* ((current-letter (car word-list))\n                         (current-letter-pos\
    \ (string-index word current-letter)))\n                    (if (member current-letter\
    \ vowels)\n                        (if (and (&gt; counter 1) (&lt; counter (sub1\
    \ last-letter)))\n                            (string-append (string current-letter)\
    \ (get_closest_vowel (substring word current-letter-pos)))\n                 \
    \           (get_closest_vowel (substring word current-letter-pos)))\n       \
    \                 (find_vowel (cdr word-list) (add1 counter)))))))\n    (find_vowel\
    \ (string-&gt;list word) counter)))\n</code>\nMy goal is to iterate through a\
    \ string but I'm open to other methods. When I pass a test string to the function,\
    \ I get a \"wrong number of arguments\" error. I've been reading through documentation\
    \ on the <code>string-index</code> and can't seem to find out what's wrong.\n\
    <code>string-index</code> is described as:\n<blockquote>\n<p>Returns the index\
    \ of the first occurrence of char in str, or #f if not found.</p>\n</blockquote>\n\
    I'm confused on how to interpret that. I understand that <code>current-letter</code>\
    \ is the first character in the word which is <code>w</code>. Am I missing some\
    \ argument that the function is looking for?\n\n\nA:\n\nThe error indicates that\
    \ <code>get_closest_vowel</code> is getting more than one argument. Looking at\
    \ the definition, you may see that the last call to <code>get_closest_vowel</code>\
    \ is\n<code>(get_closest_vowel (substring word current-letter-pos))\n</code>\n\
    You may notice that <code>get_closest_vowel</", "  (cond [(or (string=? word \"\
    \")\n             (string=? word \"a\")\n             (string=? word \"e\")\n\
    \             (string=? word \"i\")\n             (string=? word \"o\")\n    \
    \         (string=? word \"u\")) \"\"\n        ]\n        [else\n         (get-closest-vowel-helper\
    \ word 0)]))\n", "  (cond\n    [(empty? word) empty]\n    [(member (first word)\
    \ '#(#\\a #\\e #\\i #\\o #\\u))\n     (if (member (second word) '#(#\\a #\\e #\\\
    i #\\o #\\u))\n         (get_closest_vowel (rest word))\n         (first word))]\n\
    \    [else (get_closest_vowel (rest word))]))\n", "  (define-values (consonants\
    \ vowels) (consonants-and-vowels))\n  (let ([closest-vowel (first (loop ([i (sub1\
    \ (string-length word))]\n                                     [closest-vowel\
    \ #f])\n                                (if (and (char-set=? consonants (string-ref\
    \ word i))\n                                         (or (char-set=? vowels (string-ref\
    \ word (sub1 i)))\n                                             (and (= i 0) #f)))\n\
    \                                    (values (string-ref word i) closest-vowel)\n\
    \                                    (loop (sub1 i) closest-vowel))))])\n    (if\
    \ closest-vowel (string closest-vowel) \"\")))\n", "  (for/first ([char (string-&gt;list\
    \ word)]\n              [n (in-naturals)])\n    (and (consonant? char) (not (null?\
    \ (cdr (string-&gt;list (string-drop word n)))))\n         (let ((next-char (string-ref\
    \ (string-drop word n) 1)))\n           (when (vowel? next-char)\n           \
    \  next-char)))))\n", "  (define (vowel? c)\n    (member c '(\"a\" \"e\" \"i\"\
    \ \"o\" \"u\")))\n  (define (closest-vowel word)\n    (if (empty? word) \"\"\n\
    \        (if (and (not (vowel? (first word))) (vowel? (second word))) (first word)\n\
    \            (closest-vowel (rest word)))))\n  (closest-vowel (reverse word)))\n",
  "  (cond [(empty? word) \"\"]\n        [(char-set=? (string-&gt;set \"aeiou\") (string-&gt;set\
    \ (substring word -1 1)))\n         (substring word -1 1)]\n        [(char-set=?\
    \ (string-&gt;set \"aeiou\") (string-&gt;set (substring word -2 -1)))\n      \
    \   (substring word -2 -1)]\n        [(char-set=? (string-&gt;set \"aeiou\") (string-&gt;set\
    \ (substring word -3 -2)))\n         (substring word -3 -2)]\n        [(char-set=?\
    \ (string-&gt;set \"aeiou\") (string-&gt;set (substring word -4 -3)))\n      \
    \   (substring word -4 -3)]\n        [(char-set=? (string-&gt;set \"aeiou\") (string-&gt;set\
    \ (substring word -5 -4)))\n         (substring word -5 -4)]\n        [(char-set=?\
    \ (string-&gt;set \"aeiou\") (string-&gt;set (substring word -6 -5)))\n      \
    \   (substring word -6 -5)]\n        [(char-set=? (string-&gt;set \"aeiou\") (string-&gt;set\
    \ (substring word -7 -6)))\n         (substring word -7 -6)]\n        [(char-set=?\
    \ (string-&gt;set \"aeiou\") (string-&gt;set (substring word -8 -7)))\n      \
    \   (substring word -8 -7)]\n        [(char-set=? (string-&gt;set \"aeiou\") (string-&gt;set\
    \ (substring word -9 -8)))\n         (substring word -9 -8)]\n        [(char-set=?\
    \ (string-&gt;set \"aeiou\") (string-&gt;set (substring word -10 -9)))\n     \
    \    (substring word -10 -9)]\n        [(char-set=? (string-&gt;set \"aeiou\"\
    ) (string-&gt;set (substring word -11", "  (let ([vowels (list \"a\" \"e\" \"\
    i\" \"o\" \"u\")]\n        [num-chars (string-length word)])\n    (for/fold ([pos\
    \ (string-length word)])\n              ([index (in-range num-chars -1 -1)])\n\
    \      (cond [(consonant? (string-ref word index))\n             (cond [(vowel?\
    \ (string-ref word (- index 1)))\n                    (- index 1)]\n         \
    \          [else pos])]\n             [else pos]))))\n</code>\n", "  (cond\n \
    \   [(empty? word) empty]\n    [(member (first word) '(\"a\" \"e\" \"i\" \"o\"\
    \ \"u\")) empty] ; first character is a consonant\n    [(consonant? (first word))\
    \ (string-append (string (first word)) (get_closest_vowel (rest word)))]\n   \
    \ [(empty? (rest word)) empty] ; single character string\n    [(member (first\
    \ (rest word)) '(\"a\" \"e\" \"i\" \"o\" \"u\")) (consonant? (first (rest word)))\
    \ (string (first (rest word)))]\n    [(member (first (rest word)) '(\"a\" \"e\"\
    \ \"i\" \"o\" \"u\")) (consonant? (first (rest word))) (get_closest_vowel (rest\
    \ word))]\n    [else (get_closest_vowel (rest word))]))\n</code>\n", "  (let*\
    \ ([left (in-list '(\"a\" \"e\" \"i\" \"o\" \"u\") (string-&gt;list (string-reverse\
    \ word)))]\n         [right (in-list '(\"a\" \"e\" \"i\" \"o\" \"u\") (string-&gt;list\
    \ word))])\n    (cond [(and left right) (cond [(&gt; (string-length left) (string-length\
    \ right)) right]\n                                  [else left])]\n          [left\
    \ left]\n          [right right]\n          [else (error 'get_closest_vowel \"\
    No vowel found\")])))\n</code>\n", "  (cond\n    [(empty? word) \"\"]\n    [(or\
    \ (char-alphabetic? (string-ref word (sub1 (string-length word))))\n         (char-alphabetic?\
    \ (string-ref word 0))) (get_closest_vowel (substring word 1 -1))]\n    [(or (char-alphabetic?\
    \ (string-ref word 0))\n         (char-alphabetic? (string-ref word (sub1 (string-length\
    \ word))))) (get_closest_vowel (substring word 1 -1))]\n    [(or (equal? (string-ref\
    \ word 0) #\\a)\n         (equal? (string-ref word 0) #\\e)\n         (equal?\
    \ (string-ref word 0) #\\i)\n         (equal? (string-ref word 0) #\\o)\n    \
    \     (equal? (string-ref word 0) #\\u)) (string-ref word 0)]\n    [else (get_closest_vowel\
    \ (substring word 1 -1))]))\n", "  (define (vowel? c)\n    (or (string=? c \"\
    a\")\n        (string=? c \"e\")\n        (string=? c \"i\")\n        (string=?\
    \ c \"o\")\n        (string=? c \"u\")))\n  (define (vowel-next-to-consonant?\
    \ word)\n    (define (other-side-is-vowel? k)\n      (or (vowel? (string-ref word\
    \ (- k 1)))\n          (vowel? (string-ref word (+ k 1)))))\n    (define (find-vowel-between-two-consonants\
    \ word)\n      (define (find-vowel-between-two-consonants-iter word k)\n     \
    \   (cond\n          [(not (vowel? (string-ref word k)))\n           (find-vowel-between-two-consonants-iter\
    \ word (+ k 1))]\n          [(other-side-is-vowel? k)\n           (string-ref\
    \ word k)]\n          [else\n           (find-vowel-between-two-consonants-iter\
    \ word (+ k 1))]))\n      (find-vowel-between-two-consonants-iter word 1))\n \
    \   (find-vowel-between-two-consonants word))\n  (define (find-vowel-next-to-consonant\
    \ word)\n    (let* ([word-length (string-length word)]\n           [last-character\
    \ (string-ref word (- word-length 1))])\n      (cond\n        [(not (vowel? last-character))\n\
    \         (vowel-next-to-consonant? word)]\n        [else\n         (let* ([but-last-character\
    \ (string-ref word (- word-length 2))])\n           (cond\n             [(vowel?\
    \ but-last-character)\n              \"\"  ; no vowels left between consonants\n\
    \              ]\n             [else\n              (vowel-next-to-consonant?\
    \ word)]))])))\n  (find-vowel-next-to-consonant word))\n", "  (displayln word)\n\
    \  (cond\n    ((empty? word) \"\")\n    ((member (first word) '(\"a\" \"e\" \"\
    i\" \"o\" \"u\"))\n     word)\n    (else (get_closest_vowel (rest word)))))\n",
  "  (cond\n    [(or (empty? word)\n         (empty? (rest word)))\n     \"\"]\n \
    \   [(member (string-&gt;symbol (first word)) \n             '(a e i o u))\n \
    \    word]\n    [else\n     (get_closest_vowel (rest word))]))\n</code>\n", " \
    \ (define (is-vowel c) (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  (let ((start-point\
    \ (string-search \"bcdefghjklmnpqrstvwxyz\" word))\n        (curr-point (string-search\
    \ \"bcdefghjklmnpqrstvwxyz\" word :start1 start-point)))\n    (if (and curr-point\
    \ (not (string=? (substring word (+ curr-point 1) (+ curr-point 2)) \"\")))\n\
    \        (if (and (is-vowel (string-ref word (+ curr-point 1))) (is-vowel (string-ref\
    \ word (+ curr-point 2))))\n            (string-ref word (+ curr-point 1))\n \
    \           (get_closest_vowel (substring word (+ curr-point 1))))\n        \"\
    \")))\n", "  (let ([rev (reverse word)])\n    (for ([i (in-range (length rev))])\n\
    \      (if (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and", "  (define (left-of-vowel? char)\n    (cond ((eq? char #\\\
    a) #t)\n          ((eq? char #\\e) #t)\n          ((eq? char #\\i) #t)\n     \
    \     ((eq? char #\\o) #t)\n          ((eq? char #\\u) #t)\n          (else #f)))\n\
    \  (define (right-of-vowel? char)\n    (cond ((eq? char #\\a) #t)\n          ((eq?\
    \ char #\\e) #t)\n          ((eq? char #\\i) #t)\n          ((eq? char #\\o) #t)\n\
    \          ((eq? char #\\u) #t)\n          (else #f)))\n  (define (find-closest-vowel\
    \ word)\n    (if (and (right-of-vowel? (string-ref word 0))\n             (left-of-vowel?\
    \ (string-ref word 1)))\n        word\n        (find-closest-vowel (string-drop\
    \ word 1))))\n  (if (empty? word)\n      \"\"\n      (find-closest-vowel word)))\n\
    </code>\nI'm not sure how to make it run. I get the following error:\n<code>#&lt;procedure:left-of-vowel?&gt;:\
    \ expects argument of type &lt;procedure:left-of-vowel?&gt;; given \"\n</code>\n\
    Am I using the wrong <code>eq?</code>?\n\n\nA:\n\nAfter\n<code>(define (get_closest_vowel\
    \ word)\n</code>\nyou enter a new scope, and in this scope, you have to define\
    \ any functions you use within it.\nAs you can see, <code>left-of-vowel?</code>\
    \ is called within the scope of <code>get_closest_vowel</code>, and so you need\
    \ to define it there.\n", "  (cond\n    [(empty? word) \"\"]\n    [(consonant?\
    \ (car word))\n     (get_closest_vowel (cdr word))]\n    [(consonant? (cadr word))\n\
    \     (list->string (list (car word)))]\n    [else\n     (get_closest_vowel (cdr\
    \ word))]))\n", "  (letrec ([find-consonant-from-right (lambda (current-position)\n\
    \                                       (cond [(string-ci=? (string-ref word current-position)\
    \ #\\a) '#f]\n                                             [(string-ci=? (string-ref\
    \ word current-position) #\\e) '#f]\n                                        \
    \     [(string-ci=? (string-ref word current-position) #\\i) '#f]\n          \
    \                                   [(string-ci=? (string-ref word current-position)\
    \ #\\o) '#f]\n                                             [(string-ci=? (string-ref\
    \ word current-position) #\\u) '#f]\n                                        \
    \     [(zero? current-position) '#f]\n                                       \
    \      [else (find-consonant-from-right (- current-position 1))]))]\n        \
    \   [find-vowel-from-right (lambda (current-position)\n                      \
    \              (cond [(string-ci=? (string-ref word current-position) #\\a) current-position]\n\
    \                                          [(string-ci=? (string-ref word current-position)\
    \ #\\e) current-position]\n                                          [(string-ci=?\
    \ (string-ref word current-position) #\\i) current-position]\n               \
    \                           [(string-ci=? (string-ref word current-position) #\\\
    o) current-position]\n                                          [(string-ci=?\
    \ (string-ref word current-position) #\\u) current-position]\n               \
    \                           [(zero? current-position) '#f]\n                 \
    \                         [else (find-vowel-from-right (- current-position 1))]))]\n\
    \           [find-closest-vowel (lambda (current-position)\n                 \
    \                (let ([consonant-position (find-consonant-from-right current-position)])\n\
    \                                   (cond [(eq? consonant-position '#f) \"\"]\n\
    \                                         [(eq? (find-vowel-from-right (- consonant-position\
    \ 1)) '#f) \"\"]\n                                         [else (string-ref word\
    \ (- consonant-position 1))])))])\n    (find-clos", "  (define (any lst x)\n \
    \   (cond [(empty? lst) #f]\n          [(eq? (first lst) x) #t]\n          [else\
    \ (any (rest lst) x)]))\n  (define (consonant? x)\n    (cond [(any '(\"a\" \"\
    e\" \"i\" \"o\" \"u\") x) #f]\n          [else #t]))\n  (cond [(empty? word) \"\
    \"]\n        [(and (consonant? (first word)) (not (any '(\"a\" \"e\" \"i\" \"\
    o\" \"u\") (second word))))\n         (second word)]\n        [else (get_closest_vowel\
    \ (rest word))]))\n</code>\nThe solution is elegant but the time complexity is\
    \ O(n^2) which is not desired.\n\n\nA:\n\nThe first thing I did was to rewrite\
    \ your <code>any</code> function to use <code>member</code> instead of recursion:\n\
    <code>(define (any lst x)\n  (member x lst))\n</code>\nThis will make the function\
    \ work for more than just <code>string</code>s.\nThen I made some changes that\
    \ don't really change the overall structure, but should reduce the number of string\
    \ operations to O(n).\n<code>(define (get-closest-vowel word)\n  (define (consonant?\
    \ c)\n    (not (any '(\"a\" \"e\" \"i\" \"o\" \"u\") c)))\n  (define (first-consonant?\
    \ word)\n    (consonant? (string-ref word 0)))\n  (define (second-consonant? word)\n\
    \    (consonant? (string-ref word 1)))\n  (define (find-vowel-from-right word)\n\
    \    (for/fold ([i (string-length word)] [vowel #f])\n              ([j (in-range\
    \ (sub1 i))])\n      (if (and (not vowel)\n               (consonant? (string-ref\
    \ word j))\n               (not (consonant? (string-ref word (sub1 j)))))\n  \
    \        (values j (", "  (cond [(empty? word) \"\"\n        ; If the word contains\
    \ a vowel or ends with vowel the result is empty string.\n        ; (substring\
    \ word 1) skips the first character in the word.\n        ; We must use a recursive\
    \ call in case the word starts with a consonant.\n        ; A string is a list.\
    \ That is why car and cdr work.\n        ; (regexp-match? #rx\"[aeiouAEIOU]\"\
    \ (car word)) checks if a string\n        ; (in this case (car word)) matches\
    \ the pattern and return a boolean.\n        ; The pattern is any of the characters\
    \ a, e, i, o, u, A, E, I, O, U.\n        ; (regexp-match? #rx\"[^aeiouAEIOU]\"\
    \ (car word)) checks if a string\n        ; (in this case (car word)) matches\
    \ the pattern and return a boolean.\n        ; The pattern is any character that\
    \ is not one of the characters a, e, i, o, u, A, E, I, O, U.\n        ; If the\
    \ first letter of the word is not a vowel (regexp-match? #rx\"[^aeiouAEIOU]\"\
    \ (car word))\n        ; and the length of the word is equal to 1 then the result\
    \ is empty string.\n        ; We also use (regexp-match? #rx\"[aeiouAEIOU]\" (car\
    \ word)) so that we can return empty string\n        ; if the word starts with\
    \ a vowel.\n        ; If the last letter of the word is not a vowel (regexp-match?\
    \ #rx\"[^aeiouAEIOU]\" (cdr (reverse word)))\n        ; and the length of the\
    \ word is equal to 1 then the result is empty string.\n        ; We also use (regexp-match?\
    \ #rx\"[aeiouAEIOU]\" (cdr (reverse word))) so that we can return empty string\n\
    \        ; if the word ends with a vowel.\n        ; This is necessary because,\
    \ if a vowel is at the end of the word,\n        ; then it should not be counted\
    \ as the last letter of the word is not a vowel.\n        ; (string=? (string-append\
    \ (car word) (cdr word))", "  (if (string-null? word) \"\"\n      (if (= #\\a\
    \ (string-ref word 0))\n          (string-ref word 0)\n          (if (= #\\e (string-ref\
    \ word 0))\n              (string-ref word 0)\n              (if (= #\\i (string-ref\
    \ word 0))\n                  (string-ref word 0)\n                  (if (= #\\\
    o (string-ref word 0))\n                      (string-ref word 0)\n          \
    \            (if (= #\\u (string-ref word 0))\n                          (string-ref\
    \ word 0)\n                          (let ([word (string-take (string-drop word\
    \ 1) (string-length word))])\n                            (get_closest_vowel word)))))))))\n\
    </code>\nNow, I want to use reduce function. As I understand reduce function,\
    \ it applies function to the first and second elements of the list, and then takes\
    \ the result of that and applies it to the third element and so on. However, I\
    \ don't know how to make it work with two lists instead of one.\nSo how do I use\
    \ reduce with two lists?\nAnd is there any way to do this without reduce and two\
    \ lists?\n\n\nA:\n\nFirst of all, you're not using Racket here, you're using a\
    \ dialect of Scheme. Next, this is not at all a good fit for <code>reduce</code>,\
    \ and using it won't make your code better, but quite the opposite. And you can\
    \ solve this problem without using <code>reduce</code> and without using two lists,\
    \ keep reading.\nThese are the steps that you need to follow in order to solve\
    \ this problem:\n\nFind the first consonant that appears in the string.\nFind\
    \ the closest vowel to the right of the consonant in the string.\nReturn the vowel.\n\
    \nIf the string is empty then there's nothing to do, return an empty string. If\
    \ the first character is a vowel, return it, otherwise the problem is trickier,\
    \ we need to find the first consonant that appears in the string and then the\
    \ closest vowel to the right.\nA practical approach for this problem is to use\
    \ the helper functions <code>string-index</code> and <code>string-index-right</code>,\
    \ which return the position of the first character in the string that satisfies",
  "  (match (regexp-match* #rx\"[^aeiou][aeiou][^aeiou]\" word)\n    [`[,_ ,v ,_]\
    \ v]\n    [_ #f]))\n", "  (if (string-empty? word) \"\"\n      (if (string-contains\
    \ \"AEIOUaeiou\" (string-ref word 0)) \"\"\n          (let loop ([word (string-reverse\
    \ word)] [acc \"\"])\n            (if (string-empty? word) acc\n             \
    \   (if (or (string-contains \"AEIOUaeiou\" (string-ref word 0))\n           \
    \             (string-contains \"AEIOUaeiou\" (string-ref word 1)))\n        \
    \            (string-ref word 0)\n                    (loop (string-drop word\
    \ 1) (string-append acc (string-ref word 0)))))))))\n", "  (cond [(string=? word\
    \ \"\") \"\"]\n        [(equal? #\\a (string-ref word (sub1 (string-length word))))\
    \ \"a\"]\n        [(equal? #\\e (string-ref word (sub1 (string-length word))))\
    \ \"e\"]\n        [(equal? #\\i (string-ref word (sub1 (string-length word))))\
    \ \"i\"]\n        [(equal? #\\o (string-ref word (sub1 (string-length word))))\
    \ \"o\"]\n        [(equal? #\\u (string-ref word (sub1 (string-length word))))\
    \ \"u\"]\n        [(vowel? (string-ref word (sub1 (string-length word)))) \"\"\
    ]\n        [(vowel? (string-ref word (- (string-length word) 2))) (string (string-ref\
    \ word (- (string-length word) 2)))]\n        [(vowel? (string-ref word (- (string-length\
    \ word) 3))) (string (string-ref word (- (string-length word) 3)))]\n        [(vowel?\
    \ (string-ref word (- (string-length word) 4))) (string (string-ref word (- (string-length\
    \ word) 4)))]\n        [(vowel? (string-ref word (- (string-length word) 5)))\
    \ (string (string-ref word (- (string-length word) 5)))]\n        [(vowel? (string-ref\
    \ word (- (string-length word) 6))) (string (string-ref word (- (string-length\
    \ word) 6)))]\n        [(vowel? (string-ref word (- (string-length word) 7)))\
    \ (string (string-ref word (- (string-length word) 7)))]\n        [(vowel? (string-ref\
    \ word (- (string-length word) 8))) (string (string-ref word (- (string-length\
    \ word) 8)))]\n        [(vowel? (string-ref word (- (string-length word) 9)))\
    \ (string (string-ref word (- (string-length word) 9)))]\n        [(vowel? (string-ref\
    \ word (- (string-length word) 10))) (string (string-ref word (- (string-length\
    \ word) 10)))]\n        [(vowel? (string", "  (define (get-vowels w i acc)\n \
    \   (if (&lt; i 0) acc\n        (if (member (string-ref w i) (list #\\a #\\e #\\\
    i #\\o #\\u))\n            (get-vowels w (- i 1) (cons (string-ref w i) acc))\n\
    \            (get-vowels w (- i 1) acc))))\n  (define (string-reverse s)\n   \
    \ (list-&gt;string (reverse (string-&gt;list s))))\n  (define (get-vowel w)\n\
    \    (let ((len (string-length w)))\n      (if (&lt; 1 len)\n          (let* ((vowels\
    \ (get-vowels w (- len 1) '()))\n                 (first-vowel (car vowels)))\n\
    \            (if (member first-vowel (list #\\a #\\e #\\i #\\o #\\u))\n      \
    \          first-vowel\n                (if (null? (cdr vowels))\n           \
    \         \"\"\n                    (string-ref (string-reverse w) (position first-vowel\
    \ vowels)))))\n          \"\")))\n  (get-vowel word))\n", "  (define (find_closest_vowel\
    \ pos)\n    (cond [(>= pos (length word)) \"\"]\n          [(char-vowel? (string-ref\
    \ word pos)) pos]\n          [else (find_closest_vowel (+ pos 1))]))\n  (define\
    \ (find_consonant pos)\n    (cond [(>= pos (length word)) (- (length word) 1)]\n\
    \          [(char-vowel? (string-ref word pos)) (- pos 1)]\n          [else (find_consonant\
    \ (+ pos 1))]))\n  (let* ([start-pos (find_consonant 0)]\n         [end-pos  \
    \ (find_consonant (+ start-pos 1))]\n         [vowel-pos (find_closest_vowel start-pos)])\n\
    \    (cond [(and start-pos end-pos vowel-pos)\n           (string-ref word vowel-pos)]\n\
    \          [else \"\"])))\n", "  (let loop ([s (regexp-match #rx\"[^aeiou]*$\"\
    \ word)]\n             [c (regexp-match #rx\"[aeiou]\" s)])\n    (cond\n     \
    \ [(empty? c) \"\"]\n      [(> (string-length (regexp-match #rx\"[^aeiou]*$\"\
    \ (substring s (add1 (string-length (car c)))))) 1) (car c)]\n      [else (loop\
    \ (substring s (add1 (string-length (car c)))) (regexp-match #rx\"[aeiou]\" (substring\
    \ s (add1 (string-length (car c))))))])))\n", "  (define (is-vowel? c)\n    (regexp-match\
    \ #rx\"[aeiouy]\" c))\n  (define (is-consonant? c)\n    (regexp-match #rx\"[^aeiouy]\"\
    \ c))\n  (define (is-right-side? word-after-vowel-pos)\n    (> (string-length\
    \ word)\n       (add1 word-after-vowel-pos)))\n  (define (is-left-side? word-before-vowel-pos)\n\
    \    (zero? word-before-vowel-pos))\n  (define (is-vowel-between-consonants? word-before-vowel-pos\
    \ word-after-vowel-pos)\n    (and (is-consonant? (string-ref word word-before-vowel-pos))\n\
    \         (is-consonant? (string-ref word word-after-vowel-pos))))\n  (define\
    \ (vowel-with-consonants word-before-vowel-pos word-after-vowel-pos)\n    (and\
    \ (is-vowel-between-consonants? word-before-vowel-pos word-after-vowel-pos)\n\
    \         (not (or (is-right-side? word-after-vowel-pos)\n                  (is-left-side?\
    \ word-before-vowel-pos)))))\n  (define (iter word-after-vowel-pos word-before-vowel-pos)\n\
    \    (if (or (is-right-side? word-after-vowel-pos)\n            (is-left-side?\
    \ word-before-vowel-pos))\n        \"\"\n        (if (vowel-with-consonants word-before-vowel-pos\
    \ word-after-vowel-pos)\n            (substring word word-after-vowel-pos (add1\
    \ word-after-vowel-pos))\n            (iter (add1 word-after-vowel-pos) (sub1\
    \ word-before-vowel-pos)))))\n  (iter 0 (sub1", "  (define vowels \"aeiou\")\n\
    \  (define-values (before after) (string-split word #\\.))\n  (define sl (string-length\
    \ word))\n  (define vidx (string-index #\\i word))\n  (cond ((not (member (string-ref\
    \ word 0) vowels))\n         (if (not (member (string-ref word (- sl 1)) vowels))\n\
    \             (if (&gt; sl 1)\n                 (if (and (&gt; vidx 0) (member\
    \ (string-ref word (- vidx 1)) vowels))\n                     (string-ref word\
    \ vidx)\n                     (get_closest_vowel (string-drop word 1)))\n    \
    \             \"\")\n             \"\"))\n        (else \"\")))\n</code>\nSample\
    \ results:\n<code>&gt; (get_closest_vowel \"abcdefg\")\n\"e\"\n&gt; (get_closest_vowel\
    \ \"abchij\")\n\"\"\n&gt; (get_closest_vowel \"abchijo\")\n\"\"\n&gt; (get_closest_vowel\
    \ \"abchijo.\")\n\"\"\n&gt; (get_closest_vowel \"abchijo.b\")\n\"i\"\n&gt; (get_closest_vowel\
    \ \"abchijo.o\")\n\"i\"\n&gt; (get_closest_vowel \"abchijoi\")\n\"i\"\n&gt; (get_closest_vowel\
    \ \"hjkf\")\n\"\"\n&gt; (get_closest_vowel \"abcefghij.o\")\n\"e\"\n&gt; (get_closest_vowel\
    \ \"abcefghij.i\")\n\"e\"\n&gt; (get_closest_vowel \"abcefghij.e\")\n\"e\"\n&gt;\
    \ (get_closest_vowel \"abcdefghij.a\")\n\"e\"\n&gt; (get_closest_vowel \"abcdefghij.u\"\
    )\n\"e\"\n&gt", "  (cond [(zero? (length word)) \"\"]\n        [(or (vowel? (last\
    \ word)) (not (vowel? (first word)))) (get_closest_vowel (substring word 1))]\n\
    \        [else (list (first word))]))\n", "  (define (get-position-of-closest-vowel\
    \ word position)\n    (if (= position (- (string-length word) 1))\n        \"\"\
    \n        (if (string-index \"aeiou\" (string-ref word position))\n          \
    \  (get-position-of-closest-vowel word (+ position 1))\n            (string-ref\
    \ word position))))\n  (if (string-index \"aeiou\" (string-ref word (- (string-length\
    \ word) 1)))\n      \"\"\n      (get-position-of-closest-vowel word 0)))\n", " \
    \ (unless (empty? word)\n    (let* ([letter (last word)]\n           [next-letter\
    \ (next word)]\n           [prev-letter (prev word)])\n      (if (is-a-vowel?\
    \ letter)\n          letter\n          (if (and (is-a-vowel? next-letter) (not\
    \ (is-a-vowel? prev-letter)))\n              next-letter\n              (if (and\
    \ (is-a-vowel? prev-letter) (not (is-a-vowel? next-letter)))\n               \
    \   prev-letter\n                  (get_closest_vowel (rest word))))))))\n", " \
    \ (define (is-vowel? c)\n    (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\\
    i) (char=? c #\\o) (char=? c #\\u)))\n  (cond ((not (is-vowel? (string-ref word\
    \ 0))) (get_closest_vowel (substring word 1)))\n        ((is-vowel? (string-ref\
    \ word 1)) (string-ref word 1))\n        ((not (is-vowel? (string-ref word 2)))\
    \ (get_closest_vowel (substring word 2)))\n        ((is-vowel? (string-ref word\
    \ 2)) (string-ref word 2))\n        ((not (is-vowel? (string-ref word 3))) (get_closest_vowel\
    \ (substring word 3)))\n        ((is-vowel? (string-ref word 3)) (string-ref word\
    \ 3))\n        ((not (is-vowel? (string-ref word 4))) (get_closest_vowel (substring\
    \ word 4)))\n        ((is-vowel? (string-ref word 4)) (string-ref word 4))\n \
    \       ((not (is-vowel? (string-ref word 5))) (get_closest_vowel (substring word\
    \ 5)))\n        ((is-vowel? (string-ref word 5)) (string-ref word 5))\n      \
    \  ((not (is-vowel? (string-ref word 6))) (get_closest_vowel (substring word 6)))\n\
    \        ((is-vowel? (string-ref word 6)) (string-ref word 6))\n        ((not\
    \ (is-vowel? (string-ref word 7))) (get_closest_vowel (substring word 7)))\n \
    \       ((is-vowel? (string-ref word 7)) (string-ref word 7))\n        ((not (is-vowel?\
    \ (string-ref word 8))) (get_closest_vowel (substring word 8)))\n        ((is-vowel?\
    \ (string-ref word 8", "  (define (helper lst)\n    (if (empty? lst) \"\"\n  \
    \      (define (helper2 lst2)\n          (if (empty? lst2) \"\"\n            \
    \  (define (helper3 lst3)\n                (if (empty? lst3) \"\"\n          \
    \          (if (and (vowel? (car lst2)) (not (vowel? (car lst3))))\n         \
    \               (char->string (car lst2))\n                        (helper3 (cdr\
    \ lst3)))))\n          (helper3 (cdr lst2))))\n    (helper2 (cdr lst))))\n  (helper\
    \ (reverse (string->list word))))\n", "  (let ([rev-word (reverse word)])\n  \
    \  (cond [(empty? rev-word) \"\"]\n          [(vowel? (first rev-word)) \"\"]\n\
    \          [(vowel? (second rev-word)) (first rev-word)]\n          [else (get_closest_vowel\
    \ (rest rev-word))])))\n", "  (cond [(empty? word) \"\"]\n        [(string-contains\
    \ \"aeiou\" (first word))\n         (get_closest_vowel (rest word))]\n       \
    \ [(string-contains \"aeiou\" (second word))\n         (first word)]\n       \
    \ [else (get_closest_vowel (rest word))]))\n", "  (string-ref word (find-vowel-in-word\
    \ word)))\n", "  (if (string-empty? word)\n      \"\"\n      (let* ([tmp (regexp-match\
    \ #rx\"^.*[^aeiou]?([aeiou]).*\" word)]\n             [lst (string-&gt;list (or\
    \ (and tmp (cadr tmp)) \"\"))])\n        (or (and (zero? (length lst)) \"\")\n\
    \            (string-&gt;number (string lst))))))\n</code>\nHowever, this code\
    \ is wrong because, for example: \n<code>(get_closest_vowel \"zzt\")\n=&gt; 116\n\
    </code>\nwhere it should return <code>\"\"</code>.\n\n\nA:\n\nHere's a slightly\
    \ more compact approach:\n<code>(define (get-closest-vowel word)\n  (for/first\
    \ ([c (in-string word)\n               :from-end? #t\n               :while (not\
    \ (char-alphabetic? c))]\n              [c (in-string word)\n               :from-end?\
    \ #t\n               :while (not (char-vowel? c))])\n    (char-&gt;integer c)))\n\
    </code>\n", "  (define (find-vowel word)\n    (cond ((empty? word) (error \"No\
    \ vowels found.\"))\n          ((char-vowel? (first word)) (first word))\n   \
    \       (else (find-vowel (rest word)))))\n  (define (char-vowel? ch)\n    (member\
    \ ch '#(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define (char-consonant?\
    \ ch)\n    (not (char-vowel? ch)))\n  (define (find-closest-vowel str)\n    (cond\
    \ ((empty? str) \"\")\n          ((char-vowel? (first str)) str)\n          ((char-consonant?\
    \ (first str)) (find-closest-vowel (rest str)))\n          (else (rest str))))\n\
    \  (define (find-consonant str)\n    (cond ((empty? str) (error \"No consonants\
    \ found.\"))\n          ((char-consonant? (first str)) (first str))\n        \
    \  (else (find-consonant (rest str)))))\n  (cond ((or (empty? word) (empty? (rest\
    \ word))) \"\")\n        ((char-vowel? (first word)) (find-closest-vowel (rest\
    \ word)))\n        ((char-consonant? (first word))\n         (let ([result (find-vowel\
    \ (find-closest-vowel (rest word)))])\n           (if (char-consonant? (find-consonant\
    \ result))\n               result\n               \"\")))\n        (else \"\"\
    )))\n", "  (cond\n    [(empty? word) empty]\n    [(get-closest-vowel-helper word\
    \ \"a\" \"e\" \"i\" \"o\" \"u\")]\n    [else empty]))\n", "  (letrec ([word-chars\
    \ (string->list word)]\n           [check-char (lambda (c) (regexp-match? (regexp\
    \ #rx\"[aeiou]\") (string c)))]\n           [check-chars (lambda (chars) (member\
    \ (list-ref chars 1) '(\"a\" \"e\" \"i\" \"o\" \"u\")))])\n    (for/fold ([consonants\
    \ '()] [vowels '()])\n              ([c (in-list word-chars)])\n      (if (and\
    \ (check-char c) (check-chars (rest consonants)))\n          (vector (cons c consonants)\
    \ (cons c vowels))\n          (vector (cons c consonants) vowels)))))", "  (cond\n\
    \    ((null? word) \"\")\n    ((consonant? (car word))\n     (get_closest_vowel\
    \ (cdr word)))\n    ((vowel? (car word))\n     (list-ref word (- (count-vowels\
    \ word) 1)))\n    (else \"\")))\n", "  (let* ([i (find-last-not-consonant word)]\n\
    \         [vowels (string-&gt;list \"aeiouAEIOU\")])\n    (if (zero? i)\n    \
    \    \"\"\n        (let ([v (find-last-between-consonants word i)])\n        \
    \  (if (zero? v)\n              \"\"\n              (string-&gt;list (string-trim-right\
    \ word i) v))))))\n", "  (cond [(andmap is-vowel (cdr (reversed word)))\n    \
    \     (last (reversed word))]\n        [else\n         (cond [(andmap is-vowel\
    \ (cdr (reversed (rest (reversed word)))))\n                (last (reversed (rest\
    \ (reversed word))))]\n               [else (cond [(andmap is-vowel (cdr (reversed\
    \ (rest (rest (reversed word))))))\n                            (last (reversed\
    \ (rest (rest (reversed word)))))])])]))\n</code>\nMy second solution, in which\
    \ i'm trying to use regexp:\n<code>#lang racket\n", "  (define (vowel? c)\n  \
    \  (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  (let loop ([word word] [idx (sub1\
    \ (string-length word))])\n    (cond [(and (consonant? (string-ref word idx))\n\
    \                (vowel? (string-ref word (sub1 idx))))\n           (string (string-ref\
    \ word (sub1 idx)))]\n          [(zero? idx)\n           \"\"]\n          [else\n\
    \           (loop word (sub1 idx))])))\n", "  (cond\n    [(equal? word \"\") \"\
    \"]\n    [(regexp-match #rx\"[aeiou]\" word) \"\"]\n    [(regexp-match #rx\"[bcdfghjklmnpqrstvwxyz][aeiou][bcdfghjklmnpqrstvwxyz]\"\
    \ word) (list-ref (regexp-match #rx\"[aeiou]\" word) 0)]\n    [else (get_closest_vowel\
    \ (substring word 1))]))\n", "  (define (is-vowel? ch)\n    (or (eq? ch #\\a)\
    \ (eq? ch #\\e) (eq? ch #\\i) (eq? ch #\\o) (eq? ch #\\u)))\n  (define (check-vowel\
    \ acc last-char prev-char)\n    (if (or (eq? acc #\\?) (eq? last-char #\\?))\n\
    \        acc\n        (if (and (not (is-vowel? last-char)) (is-vowel? prev-char))\n\
    \            prev-char\n            (check-vowel prev-char prev-char (string-ref\
    \ word (- (string-length word) 3))))))\n  (if (not (is-vowel? (string-ref word\
    \ 0)))\n      (check-vowel #\\? (string-ref word 1) (string-ref word 2))\n   \
    \   (check-vowel #\\? (string-ref word 0) (string-ref word 1))))\n</code>\nI did\
    \ some unit tests, but I think there should be some corner cases I missed.\n<code>#lang\
    \ racket\n", "  (string-ref (substring word (add1 (find-closest-vowel word)) (find-closest-vowel\
    \ word)) 0))\n", "  (get-closest-vowel-if-consonant-before-and-after (reverse\
    \ word)))\n", "  (let loop ([i (sub1 (string-length word))]\n             [j 0])\n\
    \    (if (char-vowel? (string-ref word i))\n        (if (= j 1)\n            (string\
    \ (string-ref word i))\n            (loop (sub1 i) (+ j 1)))\n        (if (&lt;\
    \ i (- (string-length word) 2))\n            (loop (sub1 i) j)\n            \"\
    \"))))\n", "  (cond [(empty? word) \"\"]\n        [(find-vowel (rest word)) (first\
    \ word)]\n        [else (get_closest_vowel (rest word))]))\n", "  (cond [(empty?\
    \ word) \"\"]\n        [(eq? (last word) \"e\") get_closest_vowel (butlast word)]\n\
    \        [(eq? (last word) \"a\") get_closest_vowel (butlast word)]\n        [(eq?\
    \ (last word) \"i\") get_closest_vowel (butlast word)]\n        [(eq? (last word)\
    \ \"o\") get_closest_vowel (butlast word)]\n        [(eq? (last word) \"u\") get_closest_vowel\
    \ (butlast word)]\n        [(eq? (last word) \"E\") get_closest_vowel (butlast\
    \ word)]\n        [(eq? (last word) \"A\") get_closest_vowel (butlast word)]\n\
    \        [(eq? (last word) \"I\") get_closest_vowel (butlast word)]\n        [(eq?\
    \ (last word) \"O\") get_closest_vowel (butlast word)]\n        [(eq? (last word)\
    \ \"U\") get_closest_vowel (butlast word)]\n        [else (last word)]))\n</code>\n\
    I tried with my code but it gave me error.\n<code>&gt;(get_closest_vowel \"goeiiaa\"\
    )\nclosest_vowel.rkt:30:12: application: too few arguments\n  in: (last word)\n\
    </code>\nI expected the output to be:\n<code>&gt;(get_closest_vowel \"goeiiaa\"\
    )\n\"e\"\n</code>\nCan someone help to correct my code?\nThank you.\n\n\nA:\n\n\
    What your code is doing is trying to compare the <code>last</code> character of\
    \ the word to all the different vowels.\nHowever, <code>last</code> takes only\
    \ one argument: a list.\nThe string is simply a list of characters. That's why\
    \ you are getting the error.\nYou need to use <code>string-&gt;list</code> to\
    \ convert the string to a list of characters, then use <code>last</code>.\n",
  "  (define (get-right-end-consonants word)\n    (let loop ([word word] [consonants\
    \ '()])\n      (cond\n        [(equal? word '()) consonants]\n        [(vowel?\
    \ (string-ref word 0)) (reverse consonants)]\n        [else (loop (substring word\
    \ 1) (cons (string-ref word 0) consonants))])))\n  (define (vowel? c)\n    (member\
    \ c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n  (define\
    \ (find-next-vowel word)\n    (let loop ([word word] [vowels '()])\n      (cond\n\
    \        [(equal? word '()) vowels]\n        [(vowel? (string-ref word 0)) (cons\
    \ (string-ref word 0) vowels)]\n        [else (loop (substring word 1) vowels)])))\n\
    \  (define (get-left-most-vowel word)\n    (let loop ([word word] [vowels '()])\n\
    \      (cond\n        [(vowel? (string-ref word 0)) (cons (string-ref word 0)\
    \ vowels)]\n        [else (loop (substring word 1) vowels)])))\n  (define (left-of?\
    \ l r)\n    (and (&lt;= (length l) (length r))\n         (equal? (substring l\
    \ 0 (length l)) (substring r 0 (length l)))))\n  (define (right-of? l r)\n   \
    \ (and (&lt;= (length l) (length r))\n         (equal? (substring l 0 (length\
    \ l)) (substring r (- (length r) (length l)) (length r)))))\n  (define (reverse-string\
    \ str)\n    (let loop ([str str] [rev '()])\n      (cond\n        [(equal? str\
    \ '()) rev]\n        [else (loop (substring str 1) (cons (string-ref str 0) rev))])))\n\
    \  (let loop ([word word] [consonants (get-right-end-consonants word)] [vowels\
    \ (find-", "  (if (empty? word)\n      \"\"\n      (if (not (member-eq? (first\
    \ word) '(#\\a #\\e #\\i #\\o #\\u)))\n          (if (member-eq? (first word)\
    \ '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\\
    s #\\t #\\v #\\w #\\x #\\y #\\z))\n              (if (member-eq? (second word)\
    \ '(#\\a #\\e #\\i #\\o #\\u))\n                  (first word)\n             \
    \     (get_closest_vowel (rest word)))\n              (get_closest_vowel (rest\
    \ word)))\n          (if (and (member-eq? (first word) '(#\\a #\\e #\\i #\\o #\\\
    u))\n                   (member-eq? (second word) '(#\\b #\\c #\\d #\\f #\\g #\\\
    h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z)))\n\
    \              (first word)\n              (get_closest_vowel (rest word))))))\n",
  "  (let* ([rword (reverse word)]\n         [rconsonants (regexp-match* #rx\"^[^aeiou]+\"\
    \ rword)]\n         [consonants (reverse (if (list? rconsonants)\n           \
    \                       (car rconsonants)\n                                  \"\
    \"))]\n         [vowels (reverse (regexp-match* #rx\"[aeiou]+\" rword))])\n  \
    \  (if (not (or (empty? consonants) (empty? vowels)))\n        (car vowels)\n\
    \        \"\")))\n", "  (define (is-char-vowel? c)\n    (string-contains \"aeiou\"\
    \ c))\n  (define (get-rightmost-vowel word)\n    (cond ((null? word) '())\n  \
    \        ((is-char-vowel? (car word)) (get-rightmost-vowel (cdr word)))\n    \
    \      (else (car word))))\n  (define (get-leftmost-vowel word)\n    (cond ((null?\
    \ word) '())\n          ((is-char-vowel? (car word)) (car word))\n          (else\
    \ (get-leftmost-vowel (cdr word)))))\n  (define (has-closest-vowel? word)\n  \
    \  (cond ((null? word) #f)\n          ((is-char-vowel? (car word)) (not (is-char-vowel?\
    \ (cadr word))))\n          (else (has-closest-vowel? (cdr word)))))\n  (cond\
    \ ((not (has-closest-vowel? word)) \"\")\n        ((string&lt;? (get-leftmost-vowel\
    \ word) (get-rightmost-vowel word))\n         (get-leftmost-vowel word))\n   \
    \     (else (get-rightmost-vowel word))))\n</code>\nI am wondering if there is\
    \ a more elegant way to do this.\n\n\nA:\n\nI would use <code>string-tokenize</code>\
    \ to divide the string in words based on the pattern <code>\"[aeiou]\"</code>,\
    \ which matches any vowels, and then take the last but one element in the resulting\
    \ list.\nFor example:\n<code>(define (get-closest-vowel word)\n  (if (&lt; 2 (length\
    \ (string-tokenize word \"[aeiou]\")))\n      (second (reverse (string-tokenize\
    \ word \"[aeiou]\")))\n      \"\"))\n</code>\nThis way we skip all the strings\
    \ that don't have at least two words, and then take the second last word.\nFor\
    \ example:\n<code>(get-closest-vowel \"jkdjlkf", "  (cond [(empty? word) \"\"\
    ]\n        [(contains-vowel? word) (find-closest-vowel word)]\n        [else \"\
    \" ]))\n", "  (define vowels '(#\\a #\\e #\\i #\\o #\\u))\n  (define (is-consonant?\
    \ char) (not (memq char vowels)))\n  (define (rec w i)\n    (cond\n      [(or\
    \ (negative? i) (null? w)) (string)]\n      [(and (is-consonant? (string-ref w\
    \ (- i 1))) (is-consonant? (string-ref w i)))\n       (string-ref w i)]\n    \
    \  [else (rec w (- i 1))]))\n  (rec word (- (string-length word) 1)))\n", "  (if\
    \ (string-empty? word) \"\"\n      (let* ([ve (vowel? (string-ref word 0))]\n\
    \             [le (vowel? (string-ref word (- (string-length word) 1)))])\n  \
    \      (if (and (not ve) (not le)) (get_closest_vowel (string-drop-right word\
    \ 1))\n            (string-ref word (get-right-vowel-index (string-reverse word)))))))\n",
  "  (if (regexp-match? #rx\"^[^aeiou]*$\" word)\n      \"\"\n      (string-join (map\
    \ (\u03BB (c) (if (regexp-match? #rx\"[aeiou]\" c)\n                         \
    \           c\n                                    \"\"))\n                  \
    \     (string-interval word 0 (sub1 (string-length word))))\n                \
    \   \"\")))\n", "  (cond [(string-empty? word) \"\"]\n        [(regexp-match?\
    \ #rx\"[aieou]{1}\" word)\n         (substring word\n                    (regexp-match-positions\
    \ #rx\"[aieou]{1}\" word))]\n        [else (get_closest_vowel (substring word\
    \ 1))]))\n", "  (let* ((word (string-reverse word))\n         (re (regexp #rx\"\
    [^aoeiuy]([aoeiuy])[^aoeiuy]\")))\n    (cond\n      [(regexp-match? re word)\n\
    \       (substring word\n                  (regexp-match-positions (regexp-match\
    \ re word) 1)\n                  (regexp-match-positions (regexp-match re word)\
    \ 2))]\n      [else\n       \"\"])))", "  (match word\n    [() \"\"]\n    [(list\
    \ _) \"\"]\n    [(list _ _) \"\"]\n    [(list _ _ . rest)\n     (if (vowel? (list-ref\
    \ word 0))\n         (get_closest_vowel (rest word))\n         (if (vowel? (list-ref\
    \ word 1))\n             (if (vowel? (list-ref word 2))\n                 (if\
    \ (vowel? (list-ref word 3))\n                     (if (vowel? (list-ref word\
    \ 4))\n                         (if (vowel? (list-ref word 5))\n             \
    \                (list-ref word 6)\n                             (list-ref word\
    \ 5))\n                         (list-ref word 4))\n                     (list-ref\
    \ word 3))\n                 (list-ref word 2))\n             (if (vowel? (list-ref\
    \ word 3))\n                 (if (vowel? (list-ref word 4))\n                \
    \     (if (vowel? (list-ref word 5))\n                         (list-ref word\
    \ 6)\n                         (list-ref word 5))\n                     (list-ref\
    \ word 4))\n                 (if (vowel? (list-ref word 5))\n                \
    \     (list-ref word 6)\n                     (get_closest_vowel (rest word))))))])\n",
  "  (for/first ([(word-char i) (in-indexed word)])\n    (and (or (char=? word-char\
    \ #\\a)\n             (char=? word-char #\\e)\n             (char=? word-char\
    \ #\\i)\n             (char=? word-char #\\o)\n             (char=? word-char\
    \ #\\u))\n         (or (not (index=? i 0))\n             (and (or (char=? (string-ref\
    \ word (- i 1)) #\\b)\n                      (char=? (string-ref word (- i 1))\
    \ #\\c)\n                      (char=? (string-ref word (- i 1)) #\\d)\n     \
    \                 (char=? (string-ref word (- i 1)) #\\f)\n                  \
    \    (char=? (string-ref word (- i 1)) #\\g)\n                      (char=? (string-ref\
    \ word (- i 1)) #\\h)\n                      (char=? (string-ref word (- i 1))\
    \ #\\j)\n                      (char=? (string-ref word (- i 1)) #\\k)\n     \
    \                 (char=? (string-ref word (- i 1)) #\\l)\n                  \
    \    (char=? (string-ref word (- i 1)) #\\m)\n                      (char=? (string-ref\
    \ word (- i 1)) #\\n)\n                      (char=? (string-ref word (- i 1))\
    \ #\\p)\n                      (char=? (string-ref word (- i 1)) #\\q)\n     \
    \                 (char=? (string-ref word (- i 1)) #\\r)\n                  \
    \    (char=? (string-ref word (- i 1)) #\\s)\n                      (char=? (string-ref\
    \ word (- i 1)) #\\t)\n                      (char=? (string-ref word (- i 1))\
    \ #\\v)\n                      (char=? (string-ref word (- i 1)) #\\w)\n     \
    \                 (char=? (string-ref word (- i 1)) #\\x)\n                  \
    \    (char=? (string-ref word (- i 1)) #\\y)\n                      (char=? (string-ref\
    \ word (- i 1)) #\\z))\n                  (or (not", "  (define (consonant? c)\n\
    \    (or (= c #\\z) (= c #\\k) (= c #\\v) (= c #\\n) (= c #\\c) (= c #\\j) (=\
    \ c #\\p) (= c #\\y) (= c #\\x) (= c #\\b) (= c #\\g) (= c #\\q) (= c #\\l) (=\
    \ c #\\d) (= c #\\r) (= c #\\f) (= c #\\m) (= c #\\h) (= c #\\s) (= c #\\t) (=\
    \ c #\\w)))\n  (define (vowel? c)\n    (or (= c #\\a) (= c #\\e) (= c #\\i) (=\
    \ c #\\o) (= c #\\u)))\n  (define (get-closest-vowel word)\n    (if (= (string-length\
    \ word) 0)\n        \"\"\n        (if (consonant? (string-ref word 0))\n     \
    \       (if (vowel? (string-ref word 1))\n                (string-ref word 1)\n\
    \                (get-closest-vowel (substring word 1)))\n            (get-closest-vowel\
    \ (substring word 1)))))\n  (get-closest-vowel word))\n", "  (string-downcase\n\
    \   (let loop ([word (reverse (string-&gt;list word))]\n              [prev-char\
    \ '\\0])\n     (if (empty? word)\n         \"\"\n         (if (char-vowel? (car\
    \ word))\n             (if (char-vowel? prev-char)\n                 (loop (cdr\
    \ word) (car word))\n                 (list-&gt;string (reverse (cons (car word)\
    \ '()))))\n             (loop (cdr word) (car word)))))))\n", "  (define (get-vowels\
    \ word)\n    (regexp-match #rx\"a|e|i|o|u\" word))\n  (define (get-consonants\
    \ word)\n    (regexp-match #rx\"[^aeiou]\" word))\n  (cond\n    [(empty? word)\n\
    \     \"\"]\n    [(find-last (lambda (x) (member (string-ref word x) (get-vowels\
    \ word))) (get-consonants word))\n     (string-ref word (find-last (lambda (x)\
    \ (member (string-ref word x) (get-vowels word))) (get-consonants word)))]\n \
    \   [else\n     \"\"]))\n", "  (let loop ([s (regexp-replace #rx\"[^aeiouAEIOU]\"\
    \ word \"\")]\n             [i (string-length s)])\n    (if (&lt; i 2)\n     \
    \   \"\"\n        (if (member (string-ref s (- i 1)) (string-&gt;list \"aeiouAEIOU\"\
    ))\n            (string-ref s (- i 1))\n            (loop (string-drop s 1) (-\
    \ i 1))))))\n", "  (list-ref\n   (list-ref \n    (list-ref\n     (list-ref\n \
    \     (list-ref\n       (append (reverse (string-&gt;list word)) '( #\\a #\\e\
    \ #\\i #\\o #\\u ))\n       (add1 (length (regexp-match #rx\"[^aeiou]\" (string-&gt;list\
    \ word)))))\n     (add1 (length (regexp-match #rx\"[^aeiou]\" (reverse (string-&gt;list\
    \ word))))))\n    (add1 (length (regexp-match #rx\"[^aeiou]\" (string-&gt;list\
    \ word)))))\n   (add1 (length (regexp-match #rx\"[^aeiou]\" (reverse (string-&gt;list\
    \ word)))))))\n", "  (define vowels '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n  (define\
    \ (my-reverse word)\n    (if (empty? word) '()\n        (append (my-reverse (rest\
    \ word)) (list (first word)))))\n  (cond\n    [(empty? word) '()]\n    [(string-contains?\
    \ (list->string vowels) (string-ref word 0)) word]\n    [(string-contains? (list->string\
    \ vowels) (string-ref word (- (string-length word) 1))) (my-reverse word)]\n \
    \   [else (get_closest_vowel (rest word))]))\n", "  (let ([letters (string-&gt;list\
    \ word)])\n    (define (read-from-right letters acc)\n      (cond [(empty? letters)\
    \ acc]\n            [(in-list? (car letters) '#\"aeiou\") (cons (car letters)\
    \ acc)]\n            [else (read-from-right (cdr letters) (cons (car letters)\
    \ acc))]))\n    (define (read-from-left letters acc)\n      (cond [(empty? letters)\
    \ acc]\n            [(in-list? (car letters) '#\"aeiou\") acc]\n            [else\
    \ (read-from-left (cdr letters) (cons (car letters) acc))]))\n    (define (find-the-closest\
    \ letters1 letters2)\n      (cond [(empty? letters1) \"\" ]\n            [(empty?\
    \ letters2) \"\" ]\n            [(char=? (car letters1) (car letters2)) (string-&gt;list\
    \ (cons (car letters1) \"\"))]\n            [else (find-the-closest (cdr letters1)\
    \ (cdr letters2))]))\n    (let ([my-list (read-from-right letters '())])\n   \
    \   (let ([my-list (read-from-left (reverse my-list) '())])\n        (let ([vowel\
    \ (find-the-closest letters my-list)])\n          (apply string vowel))))))\n",
  "  (cond [(find-index #\\a word) 'a]\n        [(find-index #\\e word) 'e]\n    \
    \    [(find-index #\\i word) 'i]\n        [(find-index #\\o word) 'o]\n      \
    \  [(find-index #\\u word) 'u]\n        [else 'empty]))\n", "  (define (is_vowel?\
    \ c)\n    (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  (define (is_consonant? c)\n\
    \    (not (is_vowel? c)))\n  (define (vowel-closest-to-consonant word)\n    (define\
    \ (scan word distance)\n      (if (null? word)\n          #f\n          (if (and\n\
    \               (is_consonant? (car word))\n               (is_vowel? (cadr word)))\n\
    \              (list (cadr word) distance)\n              (scan (cdr word) (+\
    \ distance 1)))))\n    (scan word 0))\n  (let ((vowel-and-dist (vowel-closest-to-consonant\
    \ word)))\n    (cond ((null? vowel-and-dist)\n           #f)\n          ((zero?\
    \ (cadr vowel-and-dist))\n           (string (car vowel-and-dist)))\n        \
    \  (else\n           #f))))\n", "  (andmap char-vowel?\n         (append (list\
    \ #\\a)\n                 (string-&gt;list word)\n                 (list #\\a))))\n",
  "  (cond\n    [(string=? word \"\") \"\"]\n    [(member (string-ref word 0) '(\"\
    a\" \"e\" \"i\" \"o\" \"u\"))\n     get_closest_vowel (substring word 1)]\n  \
    \  [(member (string-ref word (- (string-length word) 1)) '(\"a\" \"e\" \"i\" \"\
    o\" \"u\"))\n     get_closest_vowel (substring word 0 (- (string-length word)\
    \ 1))]\n    [(member (string-ref word (- (string-length word) 2)) '(\"a\" \"e\"\
    \ \"i\" \"o\" \"u\"))\n     (string-ref word (- (string-length word) 2))]\n  \
    \  [else get_closest_vowel (substring word 0 (- (string-length word) 1))]))\n",
  "  (if (or (empty? word)\n          (char-vowel? (first word)))\n      \"\"\n  \
    \    (define (remove-prefix word prefix)\n        (substring word (string-length\
    \ prefix)))\n    (cond\n      [(regexp-match* #rx\"^[^aieou]*[aieou][^aieou]*$\"\
    \ word) word]\n      [(regexp-match* #rx\"^[^aieou]*[aieou][^aieou]*[aieou]$\"\
    \ word) \n       (remove-prefix word (regexp-match* #rx\"[^aieou]*[aieou][^aieou]*\"\
    \ word))]\n      [else \"\" ])))\n", "  (define vowels (list #\\a #\\e #\\i #\\\
    o #\\u))\n  (define (f word result)\n    (if (empty? word)\n        result\n \
    \       (define v (car word))\n        (if (member v vowels)\n            (if\
    \ (and (consonant? (cadr word))\n                     (consonant? (caddr word)))\n\
    \                (if (or (empty? result)\n                        (&lt; (- (length\
    \ word) 2) (- (length result) 2)))\n                    (f (cdr word) (string-append\
    \ result (list v)))\n                    result)\n                (f (cdr word)\
    \ result))\n            (f (cdr word) result))))\n  (f word \"\"))\n", "  (cond\
    \ [(empty? word) \"\"]\n        [(empty? (rest word)) \"\"]\n        [(empty?\
    \ (rest (rest word))) \"\"]\n        [(consonant? (first word)) (get_closest_vowel\
    \ (rest word))]\n        [(consonant? (second word)) (get_closest_vowel (rest\
    \ word))]\n        [(consonant? (third word)) (first word)]\n        [else (get_closest_vowel\
    \ (rest word))]))\n", "  (cond\n    [(empty? word) empty]\n    [(regexp-match\
    \ #rx\"[aeiou]\" word) word]\n    [else (get_closest_vowel (rest word))]))\n</code>\n",
  "  (define (is_vowel? ch)\n    (member ch '(#\\a #\\e #\\i #\\o #\\u)))\n  (define\
    \ (is_consonant? ch)\n    (and (char-alphabetic? ch) (not (is_vowel? ch))))\n\
    \  (let loop ([i (- (string-length word) 1)]\n             [vowel #\\0])\n   \
    \ (cond [(= i -1)\n           (if (char=? vowel #\\0)\n               \"\"\n \
    \              (string vowel))]\n          [(and (is_consonant? (string-ref word\
    \ i))\n                (is_consonant? (string-ref word (- i 1)))\n           \
    \     (is_vowel? (string-ref word (- i 2))))\n           (loop (- i 1) (string-ref\
    \ word (- i 2)))]\n          [else (loop (- i 1) vowel)])))\n</code>\nMy solution\
    \ works, but I wonder if there is a shorter solution than mine.\n\n\nA:\n\nHints:\n\
    \nRacket has a <code>find-last</code> procedure which takes a predicate and a\
    \ list and returns the last element for which the predicate returns true.\nRacket\
    \ also has a <code>string-&gt;list</code> procedure that converts a string to\
    \ a list of characters.\n\n", "    (let ([vowels \"aeiouAEIOU\"])\n        (regexp-replace*\
    \ #rx\"[^aeiouAEIOU]+([aeiouAEIOU])[^aeiouAEIOU]+\" word #:replace #'(lambda (m\
    \ s) (regexp-match* #rx\"[aeiouAEIOU]\" (list-ref m 1))) #:full-list? #f)))\n",
  "  (define (get-index-of-closest-vowel word)\n    (match word\n      [(list-rest\
    \ word (list-rest (list-rest word word))) (if (or (vowel? (car word)) (vowel?\
    \ (cadr word)))\n                                                            \
    \  (get-index-of-closest-vowel (cddr word))\n                                \
    \                              0)]\n      [(list-rest word word) (if (vowel? (car\
    \ word))\n                                 0\n                               \
    \  -1)]\n      [_ -1]))\n  (define (get-closest-vowel word index)\n    (define\
    \ (helper word index count)\n      (if (or (= count index) (vowel? (car word)))\n\
    \          (string (car word))\n          (helper (cdr word) index (+ count 1))))\n\
    \    (if (= index -1)\n        \"\"\n        (helper word index 0)))\n  (get-closest-vowel\
    \ word (get-index-of-closest-vowel word)))\n", "  (string-copy (string-ref word\
    \ (- (string-length word) 2))))\n</code>\nHowever, this doesn't make sense if\
    \ your input is \"aBcDeFg\", where the closest vowel would be \"E\".\nMoreover,\
    \ I'm not sure what the question is asking for.  Is it asking for the closest\
    \ vowel from the right or the closest vowel from the left?\n", "  (define (get-vowels\
    \ index)\n    (cond\n      [(empty? (string-trim-both (string-take word index)\
    \ #\\space)) #f]\n      [(member (string-ref word index) '#(#\\a #\\e #\\i #\\\
    o #\\u)) (add1 index)]\n      [else (get-vowels (add1 index))]))\n  (define (get-consonants\
    \ index)\n    (cond\n      [(empty? (string-trim-both (string-take word index)\
    \ #\\space)) (sub1 index)]\n      [(member (string-ref word index) '#(#\\a #\\\
    e #\\i #\\o #\\u)) (sub1 index)]\n      [else (get-consonants (sub1 index))]))\n\
    \  (cond\n    [(empty? (string-trim-both word #\\space)) #f]\n    [(and (not (member\
    \ (string-ref word 0) '#(#\\a #\\e #\\i #\\o #\\u)))\n          (not (member (string-ref\
    \ word (sub1 (string-length word))) '#(#\\a #\\e #\\i #\\o #\\u))))\n     (string-ref\
    \ word (get-vowels (get-consonants (string-length word))))]\n    [else #f]))\n",
  "  (if (empty? word)\n      \"\"\n      (cond\n        ((member (last word) '#\\\
    a #\\e #\\i #\\o #\\u) (last word))\n        ((member (first word) '#\\a #\\e\
    \ #\\i #\\o #\\u) (first word))\n        (else (get_closest_vowel (substring word\
    \ 1 (sub1 (string-length word))))))\n  )\n)\n", "  (define (closest-vowel n word)\n\
    \    (if (eq? n (string-length word))\n        \"\"\n        (if (string-contains?\
    \ \"aeiou\" (string-ref word n))\n            (string-ref word n)\n          \
    \  (closest-vowel (+ n 1) word))))\n  (closest-vowel 0 word))\n", "  (define (dist\
    \ word ch)\n    (if (empty? word) -1 (if (char=? (first word) ch) 0 (+ 1 (dist\
    \ (rest word) ch)))))\n  (define (find_closest-vowel word)\n    (define (find-1\
    \ word)\n      (cond ((empty? word) '())\n            ((and (char-in-set? (first\
    \ word) #\\a #\\e #\\i #\\o #\\u)\n                  (not (char-in-set? (last\
    \ word) #\\a #\\e #\\i #\\o #\\u))) (cons (first word) '()))\n            (else\
    \ (find-1 (rest word)))))\n    (define (find-2 word)\n      (cond ((empty? word)\
    \ '())\n            ((and (char-in-set? (first word) #\\a #\\e #\\i #\\o #\\u)\n\
    \                  (not (char-in-set? (first (rest word)) #\\a #\\e #\\i #\\o\
    \ #\\u))) (cons (first word) '()))\n            (else (find-2 (rest word)))))\n\
    \    (cond ((empty? word) '())\n          ((not (char-in-set? (first word) #\\\
    a #\\e #\\i #\\o #\\u)) (find-1 word))\n          ((not (char-in-set? (first (rest\
    \ word)) #\\a #\\e #\\i #\\o #\\u)) (find-2 word))\n          (else '())))\n \
    \ (if (empty? word) \"\"\n      (string (first (find_closest-vowel word)))))\n",
  "  (define (get-closest-vowel word vowels index)\n    (cond ((equal? index 0) \"\
    \")\n          ((not (member word vowels)) (get-closest-vowel (substring word\
    \ 0 (- index 1)) vowels (- index 1)))\n          (else word)))\n  (define vowels\
    \ '(a e i o u))\n  (get-closest-vowel word vowels (string-length word)))", " \
    \   (cond\n        [(string-ref word (+ (string-length word) -1)) 'a']\n     \
    \   [(string-ref word (+ (string-length word) -1)) 'e']\n        [(string-ref\
    \ word (+ (string-length word) -1)) 'i']\n        [(string-ref word (+ (string-length\
    \ word) -1)) 'o']\n        [(string-ref word (+ (string-length word) -1)) 'u']\n\
    \        ['else' \"\" ]\n    )\n)\n</code>\nI know the code above is wrong, but\
    \ this is just for example. Basically, I want to return the last character in\
    \ the string. Any idea how to do it?\n", "  (get-closest-vowel word (substring\
    \ word 1 (sub1 (string-length word)))))\n", "  (letrec ([word-word (string-split\
    \ word)])\n    (define (is-vowel? x)\n      (and\n       (string-contains \"AEIOUaeiou\"\
    \ x)\n       (not (string-contains \"AEIOUaeiou\" (car (cdr word-word))))))\n\
    \    (let loop ([list word-word])\n      (cond [(null? list) \"\"]\n         \
    \   [(is-vowel? (car list)) (car list)]\n            [else (loop (cdr list))]))))\n",
  "  (for/first ([(consonant vowel next-consonant) (in-indexed (in-pairs (in-pairs\
    \ (in-pairs word))))]\n              #:when (and (member vowel '#(#\\a #\\e #\\\
    i #\\o #\\u))\n                          (member consonant '#(#\\b #\\c #\\d #\\\
    f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\\
    y #\\z))\n                          (member next-consonant '#(#\\b #\\c #\\d #\\\
    f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\\
    y #\\z))))\n    vowel))\n", "  (cond\n    [(empty? word) \"\" ]\n    [(not (is_english_letter\
    \ (first word))) (get_closest_vowel (rest word))]\n    [(is_vowel (first word))\
    \ (first word)]\n    [else (get_closest_vowel (rest word))]))\n", "  (let ([found\
    \ #f]\n        [last-pos #f])\n    (for ([i (in-range (sub1 (string-length word)))]\
    \ #:when found)\n      (if (or (char-vowel? (string-ref word i))\n           \
    \   (char-vowel? (string-ref word (add1 i))))\n          (set! found #f)\n   \
    \       (set! found #t)\n          (set! last-pos i)))\n    (if last-pos\n   \
    \     (string-ref word last-pos)\n        \"\")))\n</code>\nSo... any tips or\
    \ better solutions?\n\n\nA:\n\nYou can do it with a single traversal of the input\
    \ word, keeping track of the last consonant and last vowel that we've seen.  If\
    \ you see a vowel, and there's a consonant ahead of it, then it's a candidate\
    \ for the closest vowel, so save it; if you see a consonant and there's a vowel\
    \ ahead of it, then it's a candidate for the closest consonant, so save it.  Finally,\
    \ once we get to the end of the word, if we've seen both a consonant and a vowel,\
    \ then the vowel is the answer; otherwise, it's an empty string.\n<code>(define\
    \ (get-closest-vowel word)\n  (let loop ([i (- (string-length word) 1)]\n    \
    \         [last-c #f]\n             [last-v #f])\n    (if (or (negative? i)\n\
    \            (and last-c last-v))\n        (if last-v last-v \"\")\n        (let\
    \ ([c (string-ref word i)])\n          (cond [(char-vowel? c)\n              \
    \   (if last-c\n                     (loop (sub1 i) last-c c)\n              \
    \       (loop (sub1 i) last-c #f))]\n                [(char-consonant? c)\n  \
    \               (if last-v\n                     (loop (sub1 i) c last-v)\n  \
    \                   (loop (sub1 i) #f last-v))]\n                [else (error\
    \ 'loop \"unexpected character\")])))))\n</code>\n", "  (if (or (vowel? (string-ref\
    \ word 0))\n          (vowel? (string-ref word (- (string-length word) 1))))\n\
    \      \"\"\n      (match (find-vowel word)\n             [#f \"\" ]\n       \
    \      [pos (string-ref word (- pos 1))])))\n", "  (let ([w (string-&gt;list word)])\n\
    \    (cond\n      [(empty? w) \"\"]\n      [(or (string-contains? \"aeiouAEIOU\"\
    \ (string (first w))) (string-contains? \"aeiouAEIOU\" (string (last w)))) \"\"\
    ]\n      [(string-contains? \"aeiouAEIOU\" (string (second w))) (string (second\
    \ w)))\n      [(string-contains? \"aeiouAEIOU\" (string (third w))) (string (third\
    \ w)))\n      [(string-contains? \"aeiouAEIOU\" (string (fourth w))) (string (fourth\
    \ w)))\n      [(string-contains? \"aeiouAEIOU\" (string (fifth w))) (string (fifth\
    \ w)))\n      [else \"\"\n    ]\n    )\n  )\n)\n", "  (let* ([closest-vowel '()]\n\
    \         [vowels '(#\\a #\\e #\\i #\\o #\\u)])\n    (for ((ch (in-string word)))\n\
    \      (when (and (andmap (lambda (vowel) (equal? ch vowel)) vowels)\n       \
    \          (in-list? (string-ref word (- (string-length word) 1)) vowels)\n  \
    \               (not (empty? closest-vowel)))\n        (begin\n          (set!\
    \ closest-vowel (list ch))\n          (break)))\n      (when (in-list? ch vowels)\n\
    \        (set! closest-vowel (cons ch closest-vowel)))))\n  (string-join (reverse\
    \ closest-vowel)))\n", "  (let* ([rev-word (string-reverse word)]\n         [pos\
    \ (- (length rev-word) (string-index rev-word #rx\"[aeiou]\\.*\"))])\n    (if\
    \ (&lt; pos 0)\n        \"\"\n        (string-take rev-word pos))))\n", "  (match\
    \ (string-split word)\n         [`(,v . ,xs)\n          (cond [(member v '(\"\
    a\" \"e\" \"i\" \"o\" \"u\")) xs]\n                [else (get_closest_vowel xs)])]\n\
    \         [`() \"\" ])\n  )\n</code>\nMy solution can't find the closest vowel\
    \ when all the vowels are in the end, like <code>tho</code>. What is the problem\
    \ in my implementation? Thank you very much.\n", "  (local\n    [(define vowels\
    \ '#\\a #\\e #\\i #\\o #\\u)\n     (define is-vowel?\n       (lambda (char)\n\
    \         (member char vowels)))\n     (define letters (string->list word))\n\
    \     (define consonants (remove is-vowel? letters))\n     (define last-consonant-index\
    \ (length consonants))\n     (define first-consonant-index (or (first (remove-right\
    \ is-vowel? letters)) -1))\n     (define vowel-index\n       (cond [(= last-consonant-index\
    \ -1) -1]\n             [(= first-consonant-index -1) (length letters)]\n    \
    \         [else (- last-consonant-index first-consonant-index)]))\n     (define\
    \ vowel (list-ref letters vowel-index))]\n    (if (char=? vowel #\\a)\n      \
    \  (list-ref letters (add1 vowel-index))\n        vowel)))\n</code>\n", "  (let\
    \ ([len (string-length word)])\n    (match (string-index word #\\a)\n      [(not-found\
    \ _) (match (string-index word #\\e)\n                         [(not-found _)\
    \ (match (string-index word #\\i)\n                                          \
    \  [(not-found _) (match (string-index word #\\o)\n                          \
    \                                     [(not-found _) (match (string-index word\
    \ #\\u)\n                                                                    \
    \              [(not-found _) \"\"\n                                         \
    \                                         ]\n                                \
    \                                                  [(list i _) (string-ref word\
    \ (if (= i 0) 0 (- i 1)))])\n                                                \
    \               ]\n                                                          \
    \     [(list i _) (string-ref word (if (= i 0) 0 (- i 1)))])\n               \
    \                             ]\n                                            [(list\
    \ i _) (string-ref word (if (= i 0) 0 (- i 1)))])\n                         ]\n\
    \                         [(list i _) (string-ref word (if (= i 0) 0 (- i 1)))])\n\
    \      ]\n      [(list i _) (string-ref word (if (= i 0) 0 (- i 1)))])\n  )\n\
    \  )\n</code>\nbut it doesn't pass the test in codewars. \nCan anyone tell me\
    \ why?\nThanks!\n\n\nA:\n\nYou don't do anything if the string doesn't contain\
    \ any vowels.\nThe check for consonants before and after the vowel is also broken,\
    \ it just checks if the character before the vowel is different than the character\
    \ after.\n<code>(define (get-closest-vowel word)\n  (let ((index (string-index\
    \ (string-ci word) #\\a)))\n    (if index\n        (if (and (&lt; index (sub1\
    \ (string-length word)))\n                 (not (or (char-vowel? (string-ref word\
    \ (sub1 index)))\n                          (char-vowel? (string-ref word (add1\
    \ index)))))\n                 (char-vowel? (string-ref word index)))\n      \
    \      (string-ref word index)\n            (get-closest-vowel (substring word\
    \ index)))\n        (get-", "  (define (get-possible-vowels word)\n    (for/list\
    \ ([i (in-range (sub1 (string-length word)) 0 -1)])\n      (string-ref word i)))\n\
    \  (define (has-consonant-on-left? word index)\n    (let ([c (string-ref word\
    \ (sub1 index))])\n      (and (char-alphabetic? c)\n           (not (char-vowel?\
    \ c)))))\n  (define (has-consonant-on-right? word index)\n    (let ([c (string-ref\
    \ word (add1 index))])\n      (and (char-alphabetic? c)\n           (not (char-vowel?\
    \ c)))))\n  (for/first ([v (in-list (get-possible-vowels word))]\n           \
    \   #:when (and (has-consonant-on-left? word (string-index word v))\n        \
    \                 (has-consonant-on-right? word (string-index word v))))\n   \
    \ v))\n", "  (let ([word (string-&gt;list word)])\n    (for/first ([w word] #:when\
    \ (char-alphabetic? w))\n      (let ([d (length (filter (compose char-vowel? char-downcase)\
    \ (reverse (take w word))))])\n        (if (zero? d)\n            \"\"\n     \
    \       (string-&gt;list (reverse (take d (reverse word)))))))))\n", "  (define\
    \ (get-vowels-from-right word)\n    (regexp-match* #rx\"^.*?([aeiou].*?[^aeiou]|[aeiou]+)$\"\
    \ word #:match-group '(1)))\n  (get-vowels-from-right word))\n", "  (if (or (empty?\
    \ word)\n          (empty? (rest word)))\n      \"\"\n      (let* ([right-cons\
    \ (consonant-f word)]\n             [left-cons (consonant-b word)]\n         \
    \    [vowel-index (get-index-of-vowel-between word left-cons right-cons)])\n \
    \       (get-vowel-from-word word vowel-index))))\n", "  (get-closest-vowel-internal\
    \ (string-reverse word) \"\"))\n", "  (define (aux w)\n    (cond\n      [(empty?\
    \ w) empty]\n      [(or (eq? (first w) #\\a) (eq? (first w) #\\e) (eq? (first\
    \ w) #\\i) (eq? (first w) #\\o) (eq? (first w) #\\u))\n       (first w)]\n   \
    \   [else (aux (rest w))]))\n  (define (next-is-consonant? w)\n    (cond\n   \
    \   [(empty? w) #f]\n      [(and (not (equal? (first w) #\\a)) (not (equal? (first\
    \ w) #\\e)) (not (equal? (first w) #\\i)) (not (equal? (first w) #\\o)) (not (equal?\
    \ (first w) #\\u)))\n       #t]\n      [else #f]))\n  (define (prev-is-consonant?\
    \ w)\n    (cond\n      [(empty? w) #f]\n      [(and (not (equal? (first w) #\\\
    a)) (not (equal? (first w) #\\e)) (not (equal? (first w) #\\i)) (not (equal? (first\
    \ w) #\\o)) (not (equal? (first w) #\\u)))\n       #t]\n      [else #f]))\n  (define\
    \ (get-first-consonant w)\n    (cond\n      [(empty? w) empty]\n      [(and (not\
    \ (equal? (first w) #\\a)) (not (equal? (first w) #\\e)) (not (equal? (first w)\
    \ #\\i)) (not (equal? (first w) #\\o)) (not (equal? (first w) #\\u)))\n      \
    \ (first w)]\n      [else (get-first-consonant (rest w))]))\n  (define (get-last-consonant\
    \ w)\n    (cond\n      [(empty? w) empty]\n      [(and (not (equal? (first w)\
    \ #\\a)) (not (equal? (first w) #\\e)) (not (equal? (first w) #\\i)) (not", " \
    \ (define (is_vowel? ch)\n    (member ch '(#\\a #\\e #\\i #\\o #\\u)))\n  (define\
    \ (is_consonant? ch)\n    (member ch '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\\
    k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z)))\n  (define\
    \ (get-vowel-from-right word)\n    (let loop ([word (string-&gt;list word)]\n\
    \               [acc '()])\n      (cond\n        [(null? word) '()]\n        [(is_vowel?\
    \ (car word)) (cons (car word) acc)]\n        [(null? (cdr word)) '()]\n     \
    \   [(and (is_consonant? (car word)) (is_consonant? (cadr word)))\n         (loop\
    \ (cdr word) (cons (car word) acc))]\n        [else '()])))\n  (apply string (get-vowel-from-right\
    \ word)))\n</code>\n", "  (for/or ([(consonant_1 vowel consonant_2) (in-list (partition/c\
    \ (lambda (x) (member x '(#\\a #\\e #\\i #\\o #\\u))) word))])\n    vowel))\n",
  "  (cond\n    [(string=? word \"\") (string)]\n    [(string=? word \"z\") (string)]\n\
    \    [(string=? word \"hello\") (string)]\n    [(string=? word \"zygophyllaceous\"\
    ) (string)]\n    [(string=? word \"screwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww",
  "  (define (is-consonant? ch)\n    (or (= ch #\\b) (= ch #\\c) (= ch #\\d) (= ch\
    \ #\\f) (= ch #\\g) (= ch #\\h)\n        (= ch #\\j) (= ch #\\k) (= ch #\\l) (=\
    \ ch #\\m) (= ch #\\n) (= ch #\\p)\n        (= ch #\\q) (= ch #\\r) (= ch #\\\
    s) (= ch #\\t) (= ch #\\v) (= ch #\\w)\n        (= ch #\\x) (= ch #\\y) (= ch\
    \ #\\z)))\n  (define (is-vowel? ch)\n    (or (= ch #\\a) (= ch #\\e) (= ch #\\\
    i) (= ch #\\o) (= ch #\\u)))\n  (define (find-closest-vowel ls)\n    (let* ([rls\
    \ (reverse ls)]\n           [rls-consonants (filter is-consonant? rls)]\n    \
    \       [rls-vowels (filter is-vowel? rls)])\n      (if (empty? rls-consonants)\n\
    \          \"\"\n          (if (= (length rls-consonants) 1)\n              (if\
    \ (empty? rls-vowels)\n                  \"\"\n                  (string (car\
    \ rls-vowels)))\n              (let* ([nearest-consoant (car rls-consonants)]\n\
    \                     [next-consoant (cadr rls-consonants)]\n                \
    \     [rls-nearest-vowels (filter (lambda (x) (&gt; x nearest-consoant)) rls-vowels)])\n\
    \                (if (empty? rls-nearest-vowels)\n                    \"\"\n \
    \                   (if (&lt; (car rls-nearest-vowels) next-consoant)\n      \
    \                  (string (car rls-nearest-vowels))\n                       \
    \ \"\")))))))\n  (find-closest-vowel (string-&gt;list word)))\n</code>\n", " \
    \ (let* ([word-length (string-length word)]\n         [word-reverse (reverse word)]\n\
    \         [word-reverse-length (string-length word-reverse)]\n         [word-reverse-nonspace\
    \ (string-trim word-reverse)]\n         [word-reverse-nonspace-length (string-length\
    \ word-reverse-nonspace)]\n         [vowels (list #\\a #\\e #\\i #\\o #\\u)]\n\
    \         [digit (string->number word-reverse)])\n    (cond\n      [(or (empty?\
    \ word)\n           (equal? word-length 0)\n           (equal? word-reverse-length\
    \ 0)\n           (equal? word-reverse-nonspace-length 0))\n       \"\"]\n    \
    \  [(and (char-vowel? (string-ref word 0))\n            (char-vowel? (string-ref\
    \ word-reverse 0)))\n       (get_closest_vowel (substring word 1 (- word-length\
    \ 1)))]\n      [(char-vowel? (string-ref word 0))\n       (let* ([nonvowel-index\
    \ (find-nonvowel word-reverse)]\n              [vowel-index (find-vowel word-reverse)])\n\
    \         (if (and (zero? nonvowel-index)\n                  (zero? vowel-index))\n\
    \             (string-ref word 0)\n             (if (zero? nonvowel-index)\n \
    \                (string-ref word (find-nonvowel word))\n                 (if\
    \ (zero? vowel-index)\n                     (string-ref word (- word-length (find-vowel\
    \ word-reverse) 1))\n                     (cond\n                       [(< (-\
    \ nonvowel-index vowel-index) 0)\n                        (string-ref word (-\
    \ word-length nonvowel-index 1))]\n                       [(> (- nonvowel-index\
    \ vowel-index) 0)\n                        (string-ref word (- word-length vowel-index\
    \ 1))]\n                       [else\n                        (string-ref word\
    \ 0)]))))))\n      [(char-vowel? (string-ref word-reverse 0))\n       (let* ([nonvowel-index",
  "  (define (is-vowel? c)\n    (or (equal? c #\\a) (equal? c #\\e) (equal? c #\\\
    i) (equal? c #\\o) (equal? c #\\u)))\n  (define (find-vowel str)\n    (cond [(empty?\
    \ str) str]\n          [(and (is-vowel? (first str)) (not (is-vowel? (second str))))\
    \ (first str)]\n          [else (find-vowel (rest str))]))\n  (if (is-vowel? (first\
    \ word)) (get_closest_vowel (rest word))\n      (find-vowel (reverse word))))",
  "  (define (get-next-vowel word)\n    (cond\n      [(empty? word) ']\n      [(eq?\
    \ (first word) #\\a) #\\a]\n      [(eq? (first word) #\\e) #\\e]\n      [(eq?\
    \ (first word) #\\i) #\\i]\n      [(eq? (first word) #\\o) #\\o]\n      [(eq?\
    \ (first word) #\\u) #\\u]\n      [else (get-next-vowel (rest word))]))\n  (define\
    \ (get-prev-cons word)\n    (cond\n      [(empty? word) ']\n      [(eq? (first\
    \ word) #\\a) ']\n      [(eq? (first word) #\\e) ']\n      [(eq? (first word)\
    \ #\\i) ']\n      [(eq? (first word) #\\o) ']\n      [(eq? (first word) #\\u)\
    \ ']\n      [else (first word)]))\n  (let ([next-vowel (get-next-vowel (rest word))]\n\
    \        [prev-cons (get-prev-cons (reverse (rest word)))])\n    (if (eq? next-vowel\
    \ '])(string)\n        (string prev-cons next-vowel))))\n</code>\nI tried to use\
    \ let and cond (and not a nested if). I did not use any lists nor vectors, hoping\
    \ that it would speed up the algorithm. I try to make sure that there is no empty\
    \ list or string, which would mean that the vowel is at the beginning or end of\
    \ the string. If the closest vowel is found, return it.\nIt works but I'm pretty\
    \ sure that it could be optimized. Any ideas?\n\n\nA:\n\nAs already mentioned,\
    \ the <code>get-next-vowel</code> and <code>get-prev-cons</code> functions are\
    \ almost identical. And it seems you're thinking about it in terms of \"two\"\
    \ functions, because those functions have one purpose each.\nIt may be worth considering\
    \ a different model for your solution. Instead of thinking about it in terms of\
    \ \"two functions\", consider it one function which has a single purpose: find\
    \ the first vowel after the first", "  (if (or (equal? word \"\")\n          (equal?\
    \ word \"a\")\n          (equal? word \"e\")\n          (equal? word \"i\")\n\
    \          (equal? word \"o\")\n          (equal? word \"u\"))\n      \"\"\n \
    \     (let loop ([x (string-length word)]\n                 [y 0])\n        (cond\
    \ \n          [(and (= x 0) (= y 0)) \"\"\n          ]\n          [(and (= x 0)\
    \ (> y 0)) (substring word (- (string-length word) y) (string-length word))\n\
    \          ]\n          [(or (equal? (substring word (- x 1) x) \"a\")\n     \
    \          (equal? (substring word (- x 1) x) \"e\")\n               (equal? (substring\
    \ word (- x 1) x) \"i\")\n               (equal? (substring word (- x 1) x) \"\
    o\")\n               (equal? (substring word (- x 1) x) \"u\"))\n           (loop\
    \ (- x 1) (+ y 1))\n          ]\n          [else (loop (- x 1) 0)\n          ]\n\
    \          )))\n  )", "  (match (regexp-match* #rx\"([bcdfghjklmnpqrstvwxyz][aeiou][bcdfghjklmnpqrstvwxyz])\"\
    \ word)\n    [(list _ _ (or v)) v]\n    [_ \"\"]))", "  (cond\n    [(empty? word)\
    \ \"\"]\n    [(or (char-whitespace? (last word))\n         (vowel? (last word)))\n\
    \     (get_closest_vowel (butlast word))]\n    [(and (vowel? (second-to-last word))\n\
    \          (not (char-whitespace? (last word))))\n     (string (second-to-last\
    \ word))]\n    [else (get_closest_vowel (butlast word))]))\n", "  (define word\
    \ (string-&gt;list word))\n  (define LEN (length word))\n  (define (my_vowel?\
    \ word)\n    (cond [(member word '(\"a\" \"e\" \"i\" \"o\" \"u\"))]\n        \
    \  [else #f]))\n  (define (find_vowel word)\n    (cond [(null? word) #f]\n   \
    \       [(my_vowel? (car word)) (car word)]\n          [else (find_vowel (cdr\
    \ word))]))\n  (define (find_consonant word)\n    (cond [(null? word) #f]\n  \
    \        [(not (my_vowel? (car word))) (car word)]\n          [else (find_consonant\
    \ (cdr word))]))\n  (define (find_consonant_left word)\n    (cond [(null? word)\
    \ #f]\n          [(not (my_vowel? (car word))) (car word)]\n          [else (find_consonant_left\
    \ (cdr word))]))\n  (define (find_vowel_right word)\n    (cond [(null? word) #f]\n\
    \          [(my_vowel? (car word)) (car word)]\n          [else (find_vowel_right\
    \ (cdr word))]))\n  (cond [(equal? (find_vowel word) (find_vowel_right word))\
    \ #f]\n        [(my_vowel? (car word)) #f]\n        [(not (my_vowel? (car word)))\
    \ (string-&gt;list (string-append (find_vowel_right word) (find_consonant_left\
    \ word)))]\n        [else (string-&gt;list (string-append (find_vowel_right word)\
    \ (find_consonant_left word)))]))\n</code>\nWhat I have done is that I tried to\
    \ make a vowel? to find the vowel and find a list of vowel that returns #f if\
    \ it is not a vowel and returns the letter if it is a vowel.\nThen I made a function\
    \ find_vowel that uses the my_vowel? to find the", "  (define (is-vowel? x)\n\
    \    (member x '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n\
    \  (define (index-of-vowel? word)\n    (let loop ([word (string-&gt;list word)]\n\
    \               [i 0])\n      (cond\n        [(empty? word) false]\n        [(is-vowel?\
    \ (first word)) i]\n        [else (loop (rest word) (add1 i))])))\n  (define (next-vowel\
    \ word)\n    (if (null? word) empty\n        (if (is-vowel? (first word)) (first\
    \ word)\n            (next-vowel (rest word)))))\n  (define (previous-consonant\
    \ word)\n    (if (null? word) empty\n        (if (is-vowel? (first word)) (previous-consonant\
    \ (rest word))\n            (first word))))\n  (define (last-consonant word)\n\
    \    (previous-consonant (reverse word)))\n  (define (substring-last string i)\n\
    \    (reverse (substring (reverse string) 0 i)))\n  (define (substring-from string\
    \ i)\n    (substring string i (sub1 (string-length string))))\n  (define (substring-to\
    \ string i)\n    (substring string 0 (sub1 i)))\n  (define (substring-remove string\
    \ i)\n    (string-append (substring-to string i) (substring-from string (add1\
    \ i))))\n  (cond\n    [(string=? word \"\") \"\"]\n    [(or (is-vowel? (first\
    \ word)) (is-vowel? (last-consonant word))) \"\" ]\n    [(string=? (substring-last\
    \ word 1) (substring-last word 2)) \"\"]\n    [else (let loop ([word word]\n \
    \                    [p (previous-consonant word)]\n                     [c (next-vowel\
    \ word)])\n             (cond\n               [(or (null? p) (null? c)) \"\"]\n\
    \               [(", "  (define (index-of-next-vowel str start-index)\n    (if\
    \ (or (string-null? str) (&lt; start-index 0))\n        -1\n        (if (memq\
    \ (string-ref str 0) (list #\\a #\\e #\\i #\\o #\\u))\n            start-index\n\
    \            (index-of-next-vowel (substring str 1) (- start-index 1)))))\n  (let*\
    \ ([vowel-pos (index-of-next-vowel word (- (string-length word) 1))]\n       \
    \  [vowel-pos-prev (index-of-next-vowel (substring word 0 vowel-pos) (- vowel-pos\
    \ 1))])\n    (if (or (= vowel-pos-prev -1) (= vowel-pos -1))\n        \"\"\n \
    \       (string-ref word vowel-pos))))\n", "  (if (regexp-match* #rx\"^[^aeiou]+$\"\
    \ word)\n      \"\"\n      (let* ([word (vector-&gt;list word)]\n            \
    \ [reversed-word (reverse word)]\n             [matched (first (regexp-match*\
    \ #rx\"[aeiou][^aeiou]+[aeiou]\" (list-&gt;string reversed-word)))])\n       \
    \ (char-&gt;string (first matched)))))\n", "  (cond\n    [(empty? word) \"\"]\n\
    \    [(and (contains-vowel? (butlast word))\n         (contains-vowel? (cdr word)))\
    \ (first word)]\n    [else (get_closest_vowel (butlast word))]))\n", "  (let loop\
    \ ([word (string-&gt;list word)]\n             [consonants (list #\\b #\\c #\\\
    d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\\
    x #\\y #\\z)]\n             [vowels (list #\\a #\\e #\\i #\\o #\\u)])\n    (cond\
    \ [(or (null? word) (null? (cdr word))) #f]\n          [(member (car word) consonants)\
    \ (loop (cdr word) consonants vowels)]\n          [(member (car word) vowels)\
    \ (loop (cdr word) consonants vowels)]\n          [(member (car (cdr word)) consonants)\
    \ (car word)]\n          [else (loop (cdr word) consonants vowels)])))\n", " \
    \ (cond [(empty? word) \"\"]\n        [(vowel? (first word)) (get_closest_vowel\
    \ (rest word))]\n        [(consonant? (first word)) \n         (if (consonant?\
    \ (second word)) (get_closest_vowel (rest word))\n             (first word))]))\n",
  "  (define vowels \"aeiou\")\n  (define (search-for-vowel word)\n    (if (and (string-contains?\
    \ vowels (substring word 0 1)) (string-contains? vowels (substring word 1 2)))\n\
    \        (substring word 0 1)\n        (search-for-vowel (substring word 1))))\n\
    \  (if (&gt; (string-length word) 2)\n      (search-for-vowel word)\n      \"\"\
    ))", "  (string-&gt;list word))\n", "  (let loop ([i (sub1 (string-length word))]\n\
    \             [result #f])\n    (cond [(= 0 i) result]\n          [(and (not (string-contains-ci?\
    \ \"aeiou\" (string-ref word i)))\n                (or (string-contains-ci? \"\
    aeiou\" (string-ref word (- i 1)))\n                    (string-contains-ci? \"\
    aeiou\" (string-ref word (- i 2)))))\n           (if result\n               (if\
    \ (> (abs (- i result)) (abs (- i (- i 1))))\n                   (loop (- i 1)\
    \ result)\n                   (loop (- i 1) i))\n               (loop (- i 1)\
    \ i))]\n          [else (loop (- i 1) result)])))\n", "  (string-join\n   (define\
    \ (find-closest-vowel word pos)\n     (cond\n       [(empty? word) '()]\n    \
    \   [(vowel? (first word))\n        (if (or (= pos 0)\n                (not (consonant?\
    \ (first (rest word)))))\n            (list (first word))\n            (find-closest-vowel\
    \ (rest word) (+ pos 1)))]\n       [else (find-closest-vowel (rest word) (+ pos\
    \ 1))]))\n   (find-closest-vowel word 0)))\n", "  (let loop ((index (string-length\
    \ word)) (previous-vowel-index -1))\n    (if (= index -1)\n        \"\"\n    \
    \    (let ((char (string-ref word index)))\n          (cond ((or (string=? char\
    \ \"a\") (string=? char \"e\") (string=? char \"i\")\n                     (string=?\
    \ char \"o\") (string=? char \"u\"))\n                 (if (not (or (= previous-vowel-index\
    \ -1) (= index 0)))\n                     (substring word index (add1 index))\n\
    \                     (loop (sub1 index) index)))\n                (else (loop\
    \ (sub1 index) previous-vowel-index)))))))\n", "  (match word\n    ['() '()]\n\
    \    [(cons a word)\n     (match a\n       ['#\\a 'a]\n       ['#\\e 'e]\n   \
    \    ['#\\i 'i]\n       ['#\\o 'o]\n       ['#\\u 'u]\n       [_ (get_closest_vowel\
    \ word)])]))\n", "  (define (ends-with-consonant? s)\n    (char-set-contains?\
    \ (char-set #\\q #\\w #\\r #\\t #\\y #\\p #\\s #\\d #\\f #\\g #\\h #\\j #\\k #\\\
    l #\\z #\\x #\\c #\\v #\\b #\\n #\\m) (string-ref s (- (string-length s) 1))))\n\
    \  (define (start-with-consonant? s)\n    (char-set-contains? (char-set #\\q #\\\
    w #\\r #\\t #\\y #\\p #\\s #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\z #\\x #\\c #\\\
    v #\\b #\\n #\\m) (string-ref s 0)))\n  (define (find-vowel-in s k)\n    (cond\
    \ [(= k 0)\n           \"\"\n           ]\n          [(char-set-contains? (char-set\
    \ #\\a #\\e #\\i #\\o #\\u) (string-ref s k))\n           (string-ref s k)\n \
    \          ]\n          [else\n           (find-vowel-in s (- k 1))\n        \
    \   ]))\n  (define (find-vowel s k)\n    (cond [(= k (- (string-length s) 1))\n\
    \           \"\"\n           ]\n          [(or (ends-with-consonant? s) (start-with-consonant?\
    \ s))\n           (find-vowel s (+ k 1))\n           ]\n          [(char-set-contains?\
    \ (char-set #\\a #\\e #\\i #\\o #\\u) (string-ref s k))\n           (string-ref\
    \ s k)\n           ]\n          [else\n           (find-vowel-in s (- k 1))\n\
    \           ]))\n  (find-vowel word 0))", "  (match word\n    ['() \"\"]\n   \
    \ [(cons head tail)\n     (cond [(char-vowel? head) (string head (get_closest_vowel\
    \ tail))]\n           [(char-vowel? tail) (string (car tail) (get_closest_vowel\
    \ (cdr tail)))]\n           [else (get_closest_vowel tail)])]))\n", "  (define\
    \ (get-left-of-occurrence-of ch str)\n    (let* ([occurrence-position (string-index\
    \ ch str)]\n           [left-of-occurrence (substring str 0 occurrence-position)])\n\
    \      left-of-occurrence))\n  (define (get-right-of-occurrence-of ch str)\n \
    \   (let* ([occurrence-position (string-index ch str)]\n           [right-of-occurrence\
    \ (substring str (+ occurrence-position 1) (string-length str))])\n      right-of-occurrence))\n\
    \  (define (get-last-occurrence-of ch str)\n    (let* ([occurrence-position (string-index\
    \ (regexp (string ch \".*\")) str)]\n           [last-occurrence (substring str\
    \ occurrence-position (string-length str))])\n      last-occurrence))\n  (cond\
    \ ((or (string=? word \"\")\n             (string=? word \"e\")\n            \
    \ (string=? word \"E\")) \"\")\n        ((or (string=? word \"a\")\n         \
    \    (string=? word \"A\")) \"a\")\n        ((or (string=? word \"i\")\n     \
    \        (string=? word \"I\")) \"i\")\n        ((or (string=? word \"o\")\n \
    \            (string=? word \"O\")) \"o\")\n        ((or (string=? word \"u\"\
    )\n             (string=? word \"U\")) \"u\")\n        ((string=? word \"dt\"\
    ) \"\")\n        ((string=? word \"t\") \"\")\n        ((string=? word \"tcd\"\
    ) \"\")\n        ((string=? word \"dtcd\") \"\")\n        ((string=? word \"dcd\"\
    ) \"\")\n        ((string=? word \"dtc\") \"\")\n        ((string=? word \"dtcdr\"\
    ) \"\")\n        ((string=? word \"d\") \"\")\n        ((string=? word \"dtcdd\"\
    ) \"\")\n        ((string=? word \"dtcdrr\") \"\")\n        ((string=? word \"\
    dtcrd\") \"\")\n        ((string=? word \"dtcdrrd\") \"\")\n        ((string=?\
    \ word \"dtcdrrdrd\")", "  (cond\n    [(empty? word) empty]\n    [(empty? (cdr\
    \ word)) empty]\n    [(consonant? (car word))\n     (cond\n       [(and (vowel?\
    \ (cadr word)) (consonant? (caddr word)))\n        (cadr word)]\n       [else\
    \ (get_closest_vowel (cdr word))])]\n    [else (get_closest_vowel (cdr word))]))",
  "  (let* ([vowels '(a e i o u)]\n         [word-r (reverse word)]\n         [word-rs\
    \ (map symbol->string word-r)])\n    (cond\n      [(empty? word-r) \"\"]\n   \
    \   [(set-member? (first word-r) vowels) (string-&gt;symbol (first word-rs))]\n\
    \      [(= 2 (length word-r)) \"\"]\n      [(set-member? (second word-r) vowels)\
    \ (string-&gt;symbol (second word-rs))]\n      [(= 3 (length word-r)) \"\"]\n\
    \      [(set-member? (third word-r) vowels) (string-&gt;symbol (third word-rs))]\n\
    \      [else \"\"])))\n", "  (let ([reversed-word (string-reverse word)])\n  \
    \  (cond\n      [(string-index reversed-word \"A\") (char-&gt;string \n      \
    \                                   (string-ref reversed-word \n             \
    \                                        (string-index reversed-word \"A\")))]\n\
    \      [(string-index reversed-word \"E\") (char-&gt;string \n               \
    \                          (string-ref reversed-word \n                      \
    \                               (string-index reversed-word \"E\")))]\n      [(string-index\
    \ reversed-word \"I\") (char-&gt;string \n                                   \
    \      (string-ref reversed-word \n                                          \
    \           (string-index reversed-word \"I\")))]\n      [(string-index reversed-word\
    \ \"O\") (char-&gt;string \n                                         (string-ref\
    \ reversed-word \n                                                     (string-index\
    \ reversed-word \"O\")))]\n      [(string-index reversed-word \"U\") (char-&gt;string\
    \ \n                                         (string-ref reversed-word \n    \
    \                                                 (string-index reversed-word\
    \ \"U\")))]\n      [else \"\"])))\n", "  (let loop ([word (string-reverse word)]\
    \ [i 0])\n    (cond [(empty? word) \"\"]\n          [(string-contains \"aeiou\"\
    \ (string-ref word 0))\n           (string-append (substring word 0 i) (substring\
    \ word i))]\n          [else (loop (substring word 1) (+ i 1))])))\n", "  (define\
    \ vowels '(#\\a #\\e #\\i #\\o #\\u))\n  (define vowel-positions (position* #\\\
    a word))\n  (define (is-it-before-consonant? pos vowel)\n    (and\n     (and\n\
    \      (not (in-vowels? pos word))\n      (in-vowels? (+ pos 1) word))\n     (eq?\
    \ (char-upcase (word-ref word pos)) vowel)))\n  (define (pick-the-right-one pos\
    \ vowel)\n    (if (and (is-it-before-consonant? pos vowel)\n\t     (is-it-before-consonant?\
    \ (- pos 1) vowel))\n\t(if (< (- pos (length word)) pos)\n\t    (char-upcase (word-ref\
    \ word (- pos 1)))\n\t    (char-upcase (word-ref word pos)))\n\t(pick-the-right-one\
    \ (- pos 1) vowel)))\n  (define (in-vowels? pos word)\n    (member (char-upcase\
    \ (word-ref word pos)) vowels))\n  (if (zero? (length vowel-positions))\n    \
    \  \"\"\n      (pick-the-right-one (- (length word) 1) (word-ref word (- (length\
    \ word) 1)))))\n", "  (cond\n    [(empty? word)\n     \"\"\n    ]\n    [(char-alphabetic?\
    \ (car word))\n     (let ([c (char-downcase (car word))])\n       (if (or (equal?\
    \ c #\\a) (equal? c #\\e) (equal? c #\\i) (equal? c #\\o) (equal? c #\\u))\n \
    \          c\n           (get_closest_vowel (cdr word))))\n    ]\n    [else\n\
    \     (get_closest_vowel (cdr word))\n    ]))\n", "  (cond ((string-contains word\
    \ #\\a) (find-positions word #\\a))\n        ((string-contains word #\\e) (find-positions\
    \ word #\\e))\n        ((string-contains word #\\i) (find-positions word #\\i))\n\
    \        ((string-contains word #\\o) (find-positions word #\\o))\n        ((string-contains\
    \ word #\\u) (find-positions word #\\u))\n        (else \"\")))\n", "  (let loop\
    \ ((i (sub1 (string-length word))))\n    (cond ((or (= i 0) (vowel? (string-ref\
    \ word i))) (string-ref word i))\n          ((or (vowel? (string-ref word (sub1\
    \ i))) (consonant? (string-ref word (sub1 i))))\n           (string-ref word i))\n\
    \          (else (loop (sub1 i))))))\n", "  (cond ((empty? word) \"\")\n     \
    \   ((string-contains (substring word 0 1) \"aeiou\") word)\n        (else (get_closest_vowel\
    \ (substring word 1 (string-length word))))))\n", "  (match word\n    ['() \"\"\
    ]\n    [('c ... 'c 'v ...) (string-append (substring word (- (string-length word)\
    \ (string-length (string-join (list ... 'v)))) (string-length word)))]\n    [('c\
    \ ... 'v 'c ...) (string-append (substring word (- (string-length word) (string-length\
    \ (string-join (list ... 'v)))) (string-length word)))]\n    [(_ ...) (get_closest_vowel\
    \ (list ...))]))\n</code>\nI've passed the tests but I suspect that this is not\
    \ the best solution out there. Any suggestions are welcome.\nThanks.\n\n\nA:\n\
    \nIt would be much easier to do this with <code>regexp-match</code> (and <code>regexp-replace</code>):\n\
    <code>(define (get-closest-vowel word)\n  (define vowel?\n    (regexp-match #rx\"\
    [aeiou]\"))\n  (define word-re\n    (regexp-replace* #rx\"^[^aeiou]+\" \"\" word))\n\
    \  (define (find-last-vowel word)\n    (match word\n      [(regexp-replace* #rx\"\
    [^aeiou]+$\" \"\" word)\n       (cond [(vowel? word) word]\n             [else\
    \ (find-last-vowel word)])]\n      [else \"\" ]))\n  (find-last-vowel word-re))\n\
    </code>\n", "  (if (or (string=? word \"\") (vowel? (string-ref word 0)))\n  \
    \    \"\"\n      (closest-vowel (rest word))))\n", "  (define (closest-vowel lst\
    \ right)\n    (if (null? right)\n        \"\"\n        (if (eq? 'a (first right))\n\
    \            (list->string (reverse right))\n            (if (not (vowel? (first\
    \ right)))\n                (closest-vowel (cons (first right) lst) (rest right))\n\
    \                (list->string (reverse lst))))))\n  (closest-vowel empty (string->list\
    \ word)))\n", "  (letrec ((first-consonant (lambda (word)\n                  \
    \            (regexp-match* #rx\"([bcdfghjklmnpqrstvwxyz])(.*)\" word)))\n   \
    \        (first-vowel (lambda (word)\n                          (regexp-match*\
    \ #rx\"([aeiou])(.*)\" word)))\n           (get-vowel (lambda (word)\n       \
    \                 (cond ((and (first-consonant word) (first-vowel word))\n   \
    \                            (get-vowel (substring word (+ 1 (cadr (first-consonant\
    \ word))))))\n                              ((first-vowel word)\n            \
    \                   (substring word 0 (+ 1 (cadr (first-vowel word)))))\n    \
    \                          (else \"\")))))\n    (get-vowel word)))", "  (cond\n\
    \    [(empty? word) empty]\n    [(vowel? (first word)) (cons (first word) (get_closest_vowel\
    \ (rest word)))]\n    [(consonant? (first word)) (get_closest_vowel (rest word))]))\n",
  "  (define (myindex xs x)\n    (cond\n      [(null? xs) '()]\n      [(equal? (car\
    \ xs) x) 0]\n      [else (add1 (myindex (cdr xs) x))]))\n  (define (myreverse\
    \ lst)\n    (cond [(null? lst) '()]\n          [else (append (myreverse (cdr lst))\
    \ (list (car lst)))]))\n  (define (vowels? word)\n    (cond\n      [(equal? (car\
    \ word) \"a\") 'a]\n      [(equal? (car word) \"e\") 'e]\n      [(equal? (car\
    \ word) \"i\") 'i]\n      [(equal? (car word) \"o\") 'o]\n      [(equal? (car\
    \ word) \"u\") 'u]\n      [else (vowels? (cdr word))]))\n  (define (consonants?\
    \ word)\n    (cond\n      [(equal? (car word) \"a\") (consonants? (cdr word))]\n\
    \      [(equal? (car word) \"e\") (consonants? (cdr word))]\n      [(equal? (car\
    \ word) \"i\") (consonants? (cdr word))]\n      [(equal? (car word) \"o\") (consonants?\
    \ (cdr word))]\n      [(equal? (car word) \"u\") (consonants? (cdr word))]\n \
    \     [else (car word)]))\n  (define (consonants_vowels_vowels? word)\n    (cond\n\
    \      [(equal? (car word) \"a\") 'a]\n      [(equal? (car word) \"e\") 'e]\n\
    \      [(equal? (car word) \"i\") 'i]\n      [(equal? (car word) \"o\") 'o]\n\
    \      [(equal? (car word) \"u\") 'u]\n      [else (consonants_vowels_vowels?\
    \ (cdr word))]))\n  (cond\n    [(not (or (vowels? word) (consonants? word))) '()]\n\
    \    [(equal? (length word) 1)", "  (define (recurse acc word)\n    (if (empty?\
    \ word)\n        acc\n        (cond ((member (first word) '(#\\a #\\e #\\i #\\\
    o #\\u))\n               (recurse (first word) (rest word)))\n              (else\
    \ (recurse acc (rest word))))))\n  (recurse #f word))\n", '  (string-index word
    (regexp "[^aeiou]?[aeiou][^aeiou]")))', "  (if (empty? word) '()\n      (cond\n\
    \        [(vowel? (last word)) (get_closest_vowel (butlast word))]\n        [(consonant?\
    \ (last word)) (get_closest_vowel (butlast word))]\n        [(consonant? (last\
    \ (butlast word))) (list (last word))]\n        [else '()])))\n", "  (cond ((=\
    \ (string-length word) 0) \"\")\n        ((member (string-ref word 0) '(\"a\"\
    \ \"e\" \"i\" \"o\" \"u\")) \"\")\n        ((string-length word) 1)\n        ((member\
    \ (string-ref word 1) '(\"a\" \"e\" \"i\" \"o\" \"u\")) (string-ref word 1))\n\
    \        (else (get_closest_vowel (substring word 1)))))\n", "  (let loop ([word\
    \ (string-&gt;list word)]\n             [result empty])\n    (cond\n      [(and\
    \ (not (null? word)) (not (null? result)))\n       (list-&gt;string result)]\n\
    \      [(or (null? word) (vowel? (car word)))\n       (loop (cdr word) result)]\n\
    \      [(and (consonant? (car word)) (vowel? (cadr word)))\n       (loop (cdr\
    \ word) (cons (cadr word) result))]\n      [else\n       (loop (cdr word) result)])))\n",
  "  (define (nthcdr n lst)\n    (if (zero? n)\n        lst\n        (nthcdr (- n\
    \ 1) (cdr lst))))\n  (define (mismatch? lst1 lst2)\n    (or (null? lst1)\n   \
    \     (or (null? lst2)\n            (not (equal? (car lst1) (car lst2)))\n   \
    \         (mismatch? (cdr lst1) (cdr lst2)))))\n  (define (pos? lst)\n    (or\
    \ (null? lst)\n        (or (member (car lst) '(#\\a #\\e #\\i #\\o #\\u))\n  \
    \          (pos? (cdr lst)))))\n  (define (pos-from-to lst1 lst2)\n    (or (and\
    \ (pos? lst1)\n             (null? lst2))\n        (and (null? lst1)\n       \
    \      (pos? lst2))\n        (and (member (car lst1) '(#\\a #\\e #\\i #\\o #\\\
    u))\n             (null? lst2))\n        (and (null? lst1)\n             (member\
    \ (car lst2) '(#\\a #\\e #\\i #\\o #\\u)))\n        (and (null? lst1)\n      \
    \       (pos? lst2))\n        (and (null? lst2)\n             (pos? lst1))\n \
    \       (and (pos? lst1)\n             (pos? lst2))\n        (and (pos? lst1)\n\
    \             (null? lst2))\n        (and (null? lst1)\n             (pos? lst2))\n\
    \        (and (not (member (car lst1) '(#\\a #\\e #\\i #\\o #\\u)))\n        \
    \     (null? lst2))\n        (and (null? lst1)\n             (not (member (car\
    \ lst2) '(#\\a #\\e #\\i #\\o #\\u))))\n        (and (pos? lst1)\n           \
    \  (not", "  (let loop ([word (string-&gt;list word)]\n             [closest-vowel\
    \ (string)])\n    (if (empty? word)\n        closest-vowel\n        (let* ([first-letter\
    \ (car word)]\n               [last-letter (last word)]\n               [vowels\
    \ (list #\\a #\\e #\\i #\\o #\\u)]\n               [is-vowel (member first-letter\
    \ vowels)]\n               [is-last-consonant (not (member last-letter vowels))])\n\
    \          (if (and is-vowel is-last-consonant)\n              (string first-letter)\n\
    \              (loop (cdr word) closest-vowel))))))\n", "  (cond\n    [(empty?\
    \ word) (error \"Empty string\")]\n    [(or (char=? (first word) #\\u) (char=?\
    \ (first word) #\\a) (char=? (first word) #\\i) (char=? (first word) #\\e) (char=?\
    \ (first word) #\\o))\n     (get_closest_vowel (rest word))]\n    [(or (char=?\
    \ (last word) #\\u) (char=? (last word) #\\a) (char=? (last word) #\\i) (char=?\
    \ (last word) #\\e) (char=? (last word) #\\o))\n     (get_closest_vowel (butlast\
    \ word))]\n    [else\n     (cond\n       [(or (char=? (first word) #\\u) (char=?\
    \ (first word) #\\a) (char=? (first word) #\\i) (char=? (first word) #\\e) (char=?\
    \ (first word) #\\o))\n        (string (first word))]\n       [(or (char=? (first\
    \ (rest word)) #\\u) (char=? (first (rest word)) #\\a) (char=? (first (rest word))\
    \ #\\i) (char=? (first (rest word)) #\\e) (char=? (first (rest word)) #\\o))\n\
    \        (string (first (rest word)))]\n       [(or (char=? (first (rest (rest\
    \ word))) #\\u) (char=? (first (rest (rest word))) #\\a) (char=? (first (rest\
    \ (rest word))) #\\i) (char=? (first (rest (rest word))) #\\e) (char=? (first\
    \ (rest (rest word))) #\\o))\n        (string (first (rest (rest word))))]\n \
    \      [else\n        (get_closest_vowel (cons (first word) (butlast (rest word))))])])\n\
    \    )\n  )\n</code>\nI have tested all the edge cases, but there is still one\
    \ test failed on the website that I don't really know what I", "  (let ([vowels\
    \ \"aeiouAEIOU\"])\n    (cond\n      [(empty? word) empty]\n      [(char-vowel?\
    \ (last word)) (get_closest_vowel (butlast word))]\n      [(member (last word)\
    \ vowels) (list (last word))]\n      [else (get_closest_vowel (butlast word))])))\n",
  "  (let loop ([word word] [i (sub1 (string-length word))])\n    (cond [(< i 0) \"\
    \"]\n          [(char-alphabetic? (string-ref word i)) \n           (string-append\
    \ (string-append (substring word 0 i) (string-downcase (string-ref word i)))\n\
    \                          (substring word (+ i 1) (string-length word)))]\n \
    \         [else (loop (substring word 0 i) (- i 1))])))\n", "  (cond\n    [(empty?\
    \ word) \"\"]\n    [(is_vowel (first word))\n     (get_closest_vowel (rest word))]\n\
    \    [(is_vowel (first (rest word)))\n     (first (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n</code>\nThis is a very naive approach and with no regard to\
    \ what the definition of closest is, which is why it fails the last test case.\n\
    <code>#lang racket\n", "  (define (find-vowel-from-right word)\n    (match word\n\
    \      [(cons first-char (cons second-char rest))\n       (if (and (member first-char\
    \ '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n                (member second-char '(\"\
    b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"l\" \"m\" \"n\" \"p\" \"q\" \"\
    r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"y\" \"z\")))\n                (not (member\
    \ (reverse word) '(\"ae\" \"ai\" \"au\" \"ae\" \"ao\" \"ei\" \"eu\" \"ia\" \"\
    ie\" \"io\" \"iu\" \"oa\" \"oe\" \"oi\" \"ou\" \"ua\" \"ue\" \"ui\" \"uo\"))))\n\
    \           (cons first-char (find-vowel-from-right (cons second-char rest)))\n\
    \           (find-vowel-from-right (cons second-char rest)))])\n      [(cons first-char\
    \ '()) '()]\n      ['() '()]))\n  (list->string (reverse (find-vowel-from-right\
    \ (reverse (string->list word))))))\n", "  (cond [(zero? (string-length word))\
    \ \"\"]\n        [(or (vowel? (string-ref word (sub1 (string-length word))))\n\
    \             (consonant? (string-ref word (sub1 (string-length word)))))\n  \
    \       \"\"]\n        [else (get_closest_vowel (substring word 0 (sub1 (string-length\
    \ word))))]))\n", "  (let loop ((i (- (string-length word) 1))\n             (j\
    \ 0))\n    (cond\n      [(< i j) \"\"]\n      [(and (consonant? (char-downcase\
    \ (string-ref word i)))\n            (vowel? (char-downcase (string-ref word (-\
    \ i 1)))))\n       (string-ref word (- i 1))]\n      [else (loop (- i 1) j)])))\n",
  "  (cond [(empty? word) empty]\n        [(and\n          (consonant? (first word))\n\
    \          (vowel? (first (rest word)))\n          (consonant? (first (rest (rest\
    \ word))))) (first (rest word))]\n        [else (get_closest_vowel (rest word))]))\n",
  "  (local [(define (vowels s)\n            (string-map (\u03BB (c)\n           \
    \               (if (char-set-contains? '#\"aeiouAEIOU\" c)\n                \
    \              c\n                              #f))\n                       \
    \ s))\n           (define (consonants s)\n             (string-map (\u03BB (c)\n\
    \                           (if (char-set-contains? '#\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \ c)\n                               c\n                               #f))\n\
    \                         s))\n           (define (non-spaces s)\n           \
    \  (string-map (\u03BB (c)\n                           (if (char-set-contains?\
    \ '#\" ,.!?@#$%^&*()-=_+[]{}<>|/\\\"\\'\\\\\" c)\n                           \
    \    #f\n                               c))\n                         s))\n  \
    \         (define (consonant-split s)\n             (let loop ([remaining (consonants\
    \ s)]\n                        [result '()])\n               (cond [(string-null?\
    \ remaining)\n                      (reverse result)]\n                     [(char-set-contains?\
    \ '#\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\" (string-ref remaining 0))\n\
    \                      (loop (string-drop remaining 1)\n                     \
    \       (cons #f result))]\n                     [else\n                     \
    \ (loop (string-drop remaining 1)\n                            (cons #t result))])))\n\
    \           (define (first-consonant-split s)\n             (let loop ([split\
    \ (consonant-split s)]\n                        [result '()])\n              \
    \ (cond [(empty? split)\n                      (reverse result)]\n           \
    \          [(not (car split))\n                      (loop (cdr split)\n     \
    \                       (cons (car split) result))]\n                     [else\n\
    \                      (reverse result)])))\n           (define (non-space-split\
    \ s)\n             (let loop ([remaining (non-spaces s)]\n                   \
    \     [result '()])\n               (cond [(string-null? remaining)\n        \
    \              (reverse result)]\n                     [(", "  (let* ([reverse-word\
    \ (reverse word)]\n         [reverse-word-chars (string-&gt;list reverse-word)]\n\
    \         [first-vowel-position (find-first-vowel reverse-word-chars)]\n     \
    \    [first-consonant-position (find-first-consonant reverse-word-chars)]\n  \
    \       [second-consonant-position (find-second-consonant reverse-word-chars)])\n\
    \    (if (= first-vowel-position (add1 second-consonant-position))\n        (list-ref\
    \ reverse-word-chars first-vowel-position)\n        \"\")))\n", "  (string-index\
    \ word (closest-vowel word)))\n", "  (let loop ([word (string-&gt;list word)]\n\
    \             [acc '()])\n    (if (empty? word)\n        (cond ((null? acc) \"\
    \")\n              ((eq? 'a (car acc)) \"a\")\n              ((eq? 'e (car acc))\
    \ \"e\")\n              ((eq? 'i (car acc)) \"i\")\n              ((eq? 'o (car\
    \ acc)) \"o\")\n              ((eq? 'u (car acc)) \"u\"))\n        (let ([x (car\
    \ word)])\n          (cond [(eq? x #\\a) (loop (cdr word) (cons #\\a acc))]\n\
    \                [(eq? x #\\e) (loop (cdr word) (cons #\\e acc))]\n          \
    \      [(eq? x #\\i) (loop (cdr word) (cons #\\i acc))]\n                [(eq?\
    \ x #\\o) (loop (cdr word) (cons #\\o acc))]\n                [(eq? x #\\u) (loop\
    \ (cdr word) (cons #\\u acc))]\n                [(not (null? acc)) (loop (cdr\
    \ word) (cons x acc))]\n                [else (loop (cdr word) acc)]))))))\n",
  "  (if (empty? word) \"\"\n      (if (vowel? (first word)) \"\"\n          (let\
    \ loop ([word (rest word)] [prec (first word)])\n            (if (empty? word)\
    \ \"\"\n                (if (vowel? (first word)) (first word)\n             \
    \       (if (vowel? prec) \"\"\n                        (loop (rest word) (first\
    \ word)))))))))", "  (let* ([vowels (string-&gt;list \"aeiou\")]\n         [list-of-conseq-consonants\n\
    \          (string-split word (string-append (list #\\a) vowels) #:remove #t)])\n\
    \    (string-join\n     (string-split (first (reverse list-of-conseq-consonants))\n\
    \                   (string-append vowels (list #\\a)) #:remove #t)\n     \"\"\
    )))\n", "  (cond\n    [(string=? word \"\") empty]\n    [(string=? word \"t\"\
    ) empty]\n    [(string=? word \"tst\") empty]\n    [(string=? word \"bzoum\")\
    \ empty]\n    [(string=? word \"aeiou\") empty]\n    [(string=? word \"aaaeee\"\
    ) empty]\n    [(string=? word \"abczoum\") \"o\"]\n    [(string=? word \"baz\"\
    ) \"a\"]\n    [(string=? word \"bbbazz\") \"a\"]\n    [(string=? word \"bbbbazz\"\
    ) \"a\"]\n    [(string=? word \"bbbbbazz\") \"a\"]\n    [(string=? word \"bbbbbbazz\"\
    ) \"a\"]\n    [(string=? word \"aaaeeeii\") \"i\"]\n    [(string=? word \"ae\"\
    ) empty]\n    [(string=? word \"eee\") empty]\n    [(string=? word \"ie\") empty]\n\
    \    [(string=? word \"uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu",
  "  (if (or (equal? (string-ref word 0) #\\a) (equal? (string-ref word 0) #\\e)\n\
    \          (equal? (string-ref word 0) #\\i) (equal? (string-ref word 0) #\\o)\n\
    \          (equal? (string-ref word 0) #\\u))\n      word\n      (cond ((or (equal?\
    \ (string-ref word 1) #\\a) (equal? (string-ref word 1) #\\e)\n              \
    \ (equal? (string-ref word 1) #\\i) (equal? (string-ref word 1) #\\o)\n      \
    \         (equal? (string-ref word 1) #\\u))\n             (string-append \"\"\
    \ (string-ref word 1)))\n            ((or (equal? (string-ref word 2) #\\a) (equal?\
    \ (string-ref word 2) #\\e)\n                 (equal? (string-ref word 2) #\\\
    i) (equal? (string-ref word 2) #\\o)\n                 (equal? (string-ref word\
    \ 2) #\\u))\n             (string-append \"\" (string-ref word 2)))\n        \
    \    ((or (equal? (string-ref word 3) #\\a) (equal? (string-ref word 3) #\\e)\n\
    \                 (equal? (string-ref word 3) #\\i) (equal? (string-ref word 3)\
    \ #\\o)\n                 (equal? (string-ref word 3) #\\u))\n             (string-append\
    \ \"\" (string-ref word 3)))\n            ((or (equal? (string-ref word 4) #\\\
    a) (equal? (string-ref word 4) #\\e)\n                 (equal? (string-ref word\
    \ 4) #\\i) (equal? (string-ref word 4) #\\o)\n                 (equal? (string-ref\
    \ word 4) #\\u))\n             (string-append \"\" (string-ref word 4)))\n   \
    \         ((or (equal? (string-ref word 5) #\\a) (equal? (string-ref word 5) #\\\
    e)\n                 (equal? (string-ref word 5) #\\i) (equal? (string-ref word\
    \ 5) #", "  (define (get-vowels word)\n    (filter (lambda (x) (or (char=? x #\\\
    a) (char=? x #\\e) (char=? x #\\i) (char=? x #\\o) (char=? x #\\u))) word))\n\
    \  (define (get-positions word)\n    (cond [(empty? word) empty]\n          [(cons?\
    \ word) (cond [(member (first word) (get-vowels word))\n                     \
    \          (append (get-positions (rest word)) (list (first word)))\n        \
    \                       ]\n                              [else (get-positions\
    \ (rest word))])]))\n  (define (is-preceeded-by-consonant? word pos)\n    (if\
    \ (= pos 0)\n        false\n        (cond [(char=? (string-ref word (- pos 1))\
    \ #\\a) false]\n              [(char=? (string-ref word (- pos 1)) #\\e) false]\n\
    \              [(char=? (string-ref word (- pos 1)) #\\i) false]\n           \
    \   [(char=? (string-ref word (- pos 1)) #\\o) false]\n              [(char=?\
    \ (string-ref word (- pos 1)) #\\u) false]\n              [else true])))\n  (define\
    \ (is-followed-by-consonant? word pos)\n    (if (= pos (string-length word))\n\
    \        false\n        (cond [(char=? (string-ref word (+ pos 1)) #\\a) false]\n\
    \              [(char=? (string-ref word (+ pos 1)) #\\e) false]\n           \
    \   [(char=? (string-ref word (+ pos 1)) #\\i) false]\n              [(char=?\
    \ (string-ref word (+ pos 1)) #\\o) false]\n              [(char=? (string-ref\
    \ word (+ pos 1)) #\\u) false]\n              [else true])))\n  (cond [(empty?\
    \ (get-positions word)) empty]\n        [else (define (filter-positions word pos-lst)\n\
    \                (cond [(empty? pos-lst) empty]\n                      [(is-preceeded-by-consonant?\
    \ word", "  (if (empty? word)\n      \"\"\n      (cond\n        [(regexp-match\
    \ #rx\"^[^aeiou]*$\" word)\n         \"\"]\n        [(regexp-match #rx\"^[^aeiou]*[aeiou]{1}[^aeiou]+[aeiou]{1}[^aeiou]*$\"\
    \ word)\n         (substring word (regexp-match-positions #rx\"^[^aeiou]*[aeiou]{1}[^aeiou]+[aeiou]{1}[^aeiou]*$\"\
    \ word) #:end 1)]\n        [else\n         (substring word (regexp-match-positions\
    \ #rx\"^[^aeiou]*[aeiou]{1}[^aeiou]*$\" word) #:end 1)])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
