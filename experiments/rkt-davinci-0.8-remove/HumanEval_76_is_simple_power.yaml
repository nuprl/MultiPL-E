name: HumanEval_76_is_simple_power
language: rkt
prompt: "#lang racket\n\n;; Your task is to write a function that returns true if\
  \ a number x is a simple\n;; power of n and false in other cases.\n;; x is a simple\
  \ power of n if n**int=x\n;; For example:\n(define (is_simple_power x n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_simple_power))\n\
  \    (check-equal? (candidate 16 2) #t)\n    (check-equal? (candidate 143214 16)\
  \ #f)\n    (check-equal? (candidate 4 2) #t)\n    (check-equal? (candidate 9 3)\
  \ #t)\n    (check-equal? (candidate 16 4) #t)\n    (check-equal? (candidate 24 2)\
  \ #f)\n    (check-equal? (candidate 128 4) #f)\n    (check-equal? (candidate 12\
  \ 6) #f)\n    (check-equal? (candidate 1 1) #t)\n    (check-equal? (candidate 1\
  \ 12) #t)\n))\n\n(test-humaneval)"
completions: ["  (and (integer? x) (integer? n) (not (zero? n))\n       (equal? (expt\
    \ n (floor (log x n))) x)))\n", "  (define (helper (x n) (int))\n    (if (and\
    \ (integer? x)\n             (integer? n)\n             (positive? x)\n      \
    \       (positive? n))\n        (if (= n 0)\n            (= x 1)\n           \
    \ (if (integer? (sqrt x))\n                (if (= n 1)\n                    (=\
    \ x 1)\n                    (if (= n (- n 1))\n                        (helper\
    \ (* x n) n)\n                        (helper (* x n) (- n 1))))\n           \
    \     #f))\n        #f))\n  (helper x n))\n", "  (define x-orig x)\n  (define\
    \ (is_simple-power-iter x-orig n x)\n    (cond\n      [(= x 1) #t]\n      [(=\
    \ x x-orig) #f]\n      [(= (modulo n x) 0) (is_simple-power-iter x-orig n (/ x\
    \ n))]\n      [else #f]))\n  (is_simple-power-iter x-orig n x))\n", "  (if (=\
    \ 1 x)\n      #t\n      (if (zero? (modulo x n))\n          (is_simple_power (/\
    \ x n) n)\n          #f)))\n", "  (let ((cnt 1))\n    (or (not (integer? x)) (not\
    \ (integer? n))\n        (if (not (= (expt n (ceiling (log x n))) x))\n      \
    \      #f\n            #t))))\n", "  (let* ([m (floor (log x n))]\n         [p\
    \ (expt n m)])\n    (= x p)))\n", "  (letrec ((is_integer? (lambda (x) (= (remainder\
    \ x 1) 0)))\n           (accu-power (lambda (accu base power)\n              \
    \           (if (is_integer? power)\n                             (if (= power\
    \ 1)\n                                 (= accu x)\n                          \
    \       (if (= (modulo x accu) 0)\n                                     (accu-power\
    \ (* accu base) base (- power 1))\n                                     #f))\n\
    \                             #f))))\n    (accu-power 1 n (log x n))))\n", " \
    \ (if (or (zero? x) (negative? x))\n      #f\n      (define (power n)\n      \
    \  (let helper ([n n] [a 1])\n          (if (= n a)\n              #t\n      \
    \        (if (> n a)\n                  (helper n (* a n))\n                 \
    \ #f))))\n      (power n)))", "  (let* ([i (- x 1)]\n         (x1 (expt n i)))\n\
    \    (cond [(= x1 x) #t]\n          [(= x1 1) #f]\n          [else (is_simple_power\
    \ x1 n)])))", "  (displayln (number->string (sqrt x)))\n  (displayln (number->string\
    \ (floor (sqrt x))))\n  (== (sqrt x) (floor (sqrt x))))\n", "  (if (= x 1) #t\n\
    \      (if (< x 1) #f\n          (if (= 1 (modulo x n))\n              (is_simple_power\
    \ (/ x n) n)\n              #f))))\n", "  (define (pow n)\n    (if (= n 0) 1 (*\
    \ n (pow (- n 1)))))\n  (define (is-power-of x n)\n    (let loop ([div (quotient\
    \ x n)] [n n])\n      (if (&lt; div n)\n          #f\n          (if (= (quotient\
    \ x n) n)\n              #t\n              (loop (quotient x n) n)))))\n  (is-power-of\
    \ x n))\n", "  (is-integer? (expt n (floor (log x n)))))\n", "  (cond [(zero?\
    \ x) (equal? 0 n)]\n        [(= x 1) (equal? 1 n)]\n        [(and (number? n)\
    \ (number? x))\n         (and (equal? (modulo x n) 0)\n              (is_simple_power\
    \ (/ x n) n))]\n        [else #f]))\n", "  (if (= x 1)\n      #t\n      (if (=\
    \ (quotient x n) (remainder x n))\n          #t\n          #f)))", "  (define\
    \ (is-power-of x y)\n    (cond [(zero? x) (zero? y)]\n          [(and (not (zero?\
    \ y)) (zero? (remainder x y))) (is-power-of (/ x y) y)]\n          [else #f]))\n\
    \  (define (find-power n)\n    (define (find-power-inner n curr-power)\n     \
    \ (cond [(is-power-of x n) (if (zero? (remainder n 2)) #f (expt n curr-power))]\n\
    \            [(= n 2) (if (zero? (remainder x 2)) (expt n curr-power) #f)]\n \
    \           [else (find-power-inner (sub1 n) (add1 curr-power))]))\n    (find-power-inner\
    \ n 0))\n  (not (zero? (find-power n))))\n", "  (cond [(= x (expt n 0)) #t]\n\
    \        [(= x (expt n 1)) #t]\n        [(= x (expt n 2)) #t]\n        [(= x (expt\
    \ n 3)) #t]\n        [(= x (expt n 4)) #t]\n        [(= x (expt n 5)) #t]\n  \
    \      [(= x (expt n 6)) #t]\n        [(= x (expt n 7)) #t]\n        [(= x (expt\
    \ n 8)) #t]\n        [(= x (expt n 9)) #t]\n        [else #f]))\n", "  (let ([m\
    \ (real-part (expt n 1/1))])\n    (and (= x (expt m 1))\n         (= m (expt n\
    \ 1/1)))))\n", "  (define i 1)\n  (let loop ((i i))\n    (if (> n x)\n       \
    \ #f\n        (if (= n x)\n            #t\n            (if (= n (expt i 1))\n\
    \                (loop (+ i 1))\n                #f)))))\n", "  (let* ([logx (log\
    \ x)]\n         [logn (log n)])\n    (and (and (number? logx) (number? logn))\n\
    \         (= logx (/ logn (log x))))))\n", "  (and (equal? (expt n (exact-floor\
    \ (log x n))) x)\n       (exact-integer? (log x n))))\n", "  (define (is_simple_power-iter\
    \ base counter)\n    (cond\n      [(> (expt base counter) x) #f]\n      [(= (expt\
    \ base counter) x) #t]\n      [else (is_simple_power-iter base (+ counter 1))]))\n\
    \  (is_simple_power-iter n 2))\n", "  (if (equal? (expt n (round (log x n))) x)\n\
    \      #t\n      #f))", "  (and (not (zero? x))\n       (or (and (zero? n) (=\
    \ 1 x))\n           (let ((r (exact-integer-sqrt x)))\n             (and (= x\
    \ (* r r))\n                  (exact? (expt n (log x (expt n r)))))))))", "  (define\
    \ (pow x n)\n    (cond\n      [(= n 0) 1]\n      [(zero? (modulo n 2))\n     \
    \  (define y (pow x (/ n 2)))\n       (* y y)]\n      [else (* x (pow x (- n 1)))]))\n\
    \  (and (not (zero? x))\n       (let ([r (log x n)])\n         (and (integer?\
    \ r)\n              (= x (pow n r))))))\n", '  (equal? (expt n (integer-sqrt x))
    x))', "  (let ([a (integer-sqrt x)])\n    (and (= x (expt n a))\n         (integer?\
    \ a))))\n", "  (not (zero? x))\n  (not (zero? n))\n  (not (equal? (quotient x\
    \ n) (quotient x n)))\n  (not (equal? (remainder x n) (remainder x n)))\n)", " \
    \ (define (power n exp)\n    (if (= exp 0)\n        1\n        (* n (power n (-\
    \ exp 1)))))\n  (define (check-power x exp)\n    (if (= (power n exp) x)\n   \
    \     #t\n        (if (&lt; (power n exp) x)\n            (check-power x (+ exp\
    \ 1))\n            #f)))\n  (check-power x 1))\n", "  (and (number? x)\n     \
    \  (number? n)\n       (and (&gt; x 0)\n            (&gt; n 0))\n       (and (integer?\
    \ x)\n            (integer? n))\n       (and (&gt; x 1)\n            (&gt; n 1))\n\
    \       (or (zero? (modulo x n))\n           (and (= x n)\n                (zero?\
    \ (modulo x 2))))))\n</code>\n", "  (let ([d (integer-sqrt x)])\n    (and (= x\
    \ (expt n d))\n         (or (= d 1)\n             (not (integer? (/ x d)))))))\n",
  "  (let loop ([counter 1])\n    (let ([res (* n counter)])\n      (if (= res x)\
    \ #t\n        (if (&lt; res x) (loop (+ counter 1))\n          #f)))))\n", " \
    \ (and (= 0 (modulo x n))\n       (= (sqrt (sqrt x)) (sqrt x))))\n", "  (and (integer?\
    \ x) (integer? n)\n       (and (< 0 n) (< 0 x)\n            (and (= (expt n (integer-sqrt\
    \ x)) x)\n                 (= x (expt n (integer-sqrt x)))))))\n", "  (define\
    \ (iter x n k)\n    (if (= k 0)\n        #t\n        (if (= (expt n k) x)\n  \
    \          #t\n            (iter x n (- k 1)))))\n  (iter x n 100))", '  (exact-integer?
    (sqrt x)))', "  (let* ([log_n (log x n)]\n         [log_n_2 (floor log_n)])\n\
    \    (= (expt n log_n_2) x)))\n", "  (not (eq? (integer-sqrt (expt n (integer-sqrt\
    \ x))) -1)))\n", "  (let ([x2 (expt n (round (log x n)))]\n        [x3 (expt n\
    \ (round (log x n 1)))]\n        [x4 (expt n (round (log x n 2)))]\n        [x5\
    \ (expt n (round (log x n 3)))]\n        [x6 (expt n (round (log x n 4)))]\n \
    \       [x7 (expt n (round (log x n 5)))]\n        [x8 (expt n (round (log x n\
    \ 6)))]\n        [x9 (expt n (round (log x n 7)))]\n        [x10 (expt n (round\
    \ (log x n 8)))]\n        [x11 (expt n (round (log x n 9)))]\n        [x12 (expt\
    \ n (round (log x n 10)))])\n    (or (= x x2) (= x x3) (= x x4) (= x x5) (= x\
    \ x6) (= x x7) (= x x8) (= x x9) (= x x10) (= x x11) (= x x12))))\n", "  (let*\
    \ ((a (expt n (/ (log x) (log n))))\n         (b (expt n (exact-round (/ (log\
    \ x) (log n))))))\n    (and (= a b) (= (* a b) x))))\n", "  (define (main n x)\n\
    \    (if (= n 1) false\n        (if (= x n) false\n            (if (= x (* n (expt\
    \ n (- (log n x) 1)))) true false))))\n  (main n x))", "  (if (eq? (expt n (round\
    \ (log x n))) x)\n      #t\n      #f))", "  (let loop ([p (expt n 1)] [i 1])\n\
    \    (cond [(= p x) #t]\n          [(> p x) #f]\n          [else (loop (expt n\
    \ (+ i 1)) (+ i 1))])))\n", "  (let ((i 1))\n    (while (< (* n i) x)\n      (set!\
    \ i (+ i 1)))\n    (= (* n i) x)))\n", "  (if (equal? (expt n (floor (log x n)))\
    \ x)\n      #t\n      #f))\n", "  (cond\n    [(= x 1) #true]\n    [(< n 1) #false]\n\
    \    [(= n 1) #true]\n    [(not (integer? x)) #false]\n    [(not (integer? n))\
    \ #false]\n    [(= 0 (modulo x n)) (is_simple_power (/ x n) n)]\n    [else #false]))\n",
  "  (define (iter val count)\n    (if (= val x)\n        (if (= (expt count n) x)\n\
    \            #t\n            #f)\n        (if (= (expt count n) x)\n         \
    \   #t\n            (iter (expt count n) (+ count 1)))))\n  (iter 1 1))\n</code>\n\
    Is there a better way to write it?\n\n\nA:\n\nDisclaimer: I am no mathematician,\
    \ so I may miss something obvious.\nThe only way you can get an integer power\
    \ of a fixed base is that the power must be an integer as well. So all you have\
    \ to do is find the largest power less than your number, compute the integer power\
    \ and compare it to your number.\n<code>(define (is-simple-power n x)\n  (define\
    \ (loop p)\n    (if (&lt; (expt n p) x)\n        (loop (+ p 1))\n        (and\
    \ (integer? (expt n p))\n             (= (expt n p) x))))\n  (loop 1))\n</code>\n\
    It works fine:\n<code>(is-simple-power 2 8)\n=&gt; #t", "  (if (= x (expt n (round\
    \ (log x n))))\n      #t\n      #f))", "  (cond\n    [(zero? x) false]\n    [(zero?\
    \ n) false]\n    [(equal? 1 n) (= x 1)]\n    [(zero? (modulo x n))\n     (is_simple_power\
    \ (/ x n) n)]\n    [else false]))\n", "  (if (= 1 x)\n      #t\n      (let loop\
    \ ([x x] [n n])\n        (if (= (expt n (floor (log x n))) x)\n            #t\n\
    \            (loop (expt n (floor (log x n))) n)))))\n", "  (define (is-power?\
    \ x n)\n    (or (= x n)\n        (is-power? (/ x n) n)))\n  (if (= n 1)\n    \
    \  (if (= x 1)\n          #t\n          #f)\n      (if (= x 1)\n          #f\n\
    \          (is-power? x n))))\n", "  (let* ([root (exact-integer-sqrt x)]\n  \
    \       [power (expt root n)])\n    (and (= power x)\n         (let ([root_str\
    \ (number->string root)]\n               [x_str (number->string x)])\n       \
    \    (equal? (substring x_str 0 (length root_str)) root_str)))))\n</code>\nThe\
    \ <code>let*</code> block computes the square root of <code>x</code>, and checks\
    \ that it is a perfect square.  If it is, it raises the square root to the power\
    \ of <code>n</code>, and checks that the power is equal to <code>x</code>.  If\
    \ so, it does a little bit of string manipulation to ensure that the square root\
    \ itself is a simple power of <code>n</code>.\nThe string manipulation is necessary\
    \ to deal with the case where <code>x</code> is a perfect square whose square\
    \ root is itself a perfect square.  For example, if <code>x</code> is <code>9</code>\
    \ and <code>n</code> is <code>2</code>, we have to ensure that <code>3</code>\
    \ is a power of <code>2</code>.  If we didn't do this, then the function would\
    \ return <code>#t</code> when <code>x</code> is <code>9</code> and <code>n</code>\
    \ is <code>2</code>.\nThe string manipulation is a little tricky.  The idea is\
    \ to extract the first <code>n</code> digits of <code>x</code> and convert them\
    \ to a number.  If that number is the same as the integer square root of <code>x</code>,\
    \ then we know that the integer square root of <code>x</code> is a simple power\
    \ of <code>n</code>.\n", "  (if (and (number? x) (number? n))\n      (let ((result\
    \ (expt n (integer-sqrt x))))\n        (and (number? result) (= result x)))\n\
    \    #f))\n", "  (define (exponenet_of x n)\n    (if (= n 1)\n        x\n    \
    \    (exponenet_of (* x n) (- n 1))))\n  (for/or ([i (in-range (sqrt x))])\n \
    \   (cond\n      [ (= (exponenet_of i n) x) #t]\n      [else #f])))\n", "  (cond\
    \ ((not (integer? x)) false)\n        ((not (integer? n)) false)\n        ((&lt;\
    \ n 0) false)\n        ((= x 1) true)\n        ((not (= n 1))\n         (let ((x1\
    \ (log n x)))\n           (cond ((integer? x1)\n                  (= x (expt n\
    \ x1)))\n                 (else false))))\n        (else false)))\n", "  (cond\
    \ [(= (expt n (integer-sqrt x)) x) #t]\n        [else #f]))\n", "  (if (and (integer?\
    \ x)\n           (integer? n)\n           (&gt; n 1))\n      (let* ([x (sqrt x)]\n\
    \             [root (integer-sqrt x)])\n        (and (integer? x) (= (** n root)\
    \ x)))\n      #f))\n", "  (if (not (integer? n))\n      false\n      (or (= x\
    \ (expt n 1))\n          (= x (expt n 2))\n          (= x (expt n 3))\n      \
    \    (= x (expt n 4))\n          (= x (expt n 5))\n          (= x (expt n 6))\n\
    \          (= x (expt n 7))\n          (= x (expt n 8))\n          (= x (expt\
    \ n 9))\n          (= x (expt n 10))\n          (= x (expt n 11))\n          (=\
    \ x (expt n 12))\n          (= x (expt n 13))\n          (= x (expt n 14))\n \
    \         (= x (expt n 15))\n          (= x (expt n 16))\n          (= x (expt\
    \ n 17))\n          (= x (expt n 18))\n          (= x (expt n 19))\n         \
    \ (= x (expt n 20))\n          (= x (expt n 21))\n          (= x (expt n 22))\n\
    \          (= x (expt n 23))\n          (= x (expt n 24))\n          (= x (expt\
    \ n 25))\n          (= x (expt n 26))\n          (= x (expt n 27))\n         \
    \ (= x (expt n 28))\n          (= x (expt n 29))\n          (= x (expt n 30))\n\
    \          (= x (expt n 31))\n          (= x (expt n 32))\n          (= x (expt\
    \ n 33))\n          (= x (expt n 34))\n          (= x (expt n 35))\n         \
    \ (= x (expt n 36))\n          (= x (expt n 37))\n          (= x (expt n 38))\n\
    \          (= x (expt n 39))\n          (= x (expt n 40))\n          (= x (expt\
    \ n 41))\n          (= x (expt n 42))\n          (= x (expt n 43))\n         \
    \ (= x (expt n 44))\n          (= x (expt n 45))\n          (= x (expt n 46))\n\
    \          (= x (expt n 47))\n          (= x (expt n 48))\n          (= x (expt\
    \ n 49))\n          (= x (ex", "  (if (and (integer? x)\n           (integer?\
    \ n))\n      (if (= n 1)\n          (if (= x 1)\n              #t\n          \
    \    #f)\n          (let ([x-temp x]\n                [n-temp n])\n          \
    \  (while (= (modulo x-temp n-temp) 0)\n              (set! x-temp (/ x-temp n-temp))\n\
    \              (set! n-temp n))\n            (if (= x-temp 1)\n              \
    \  #t\n                #f)))\n      #f))\n", "  (cond\n    [(and (integer? x)\
    \ (integer? n))\n     (define (check-n x n acc)\n       (cond\n         [(= acc\
    \ x) (= acc x)]\n         [(= acc 1) (check-n x n (* acc n))]\n         [else\
    \ #f]))\n     (check-n x n 1)]\n    [else #f]))\n", "  (let ([p (expt n 1)])\n\
    \    (cond\n      [(< x p) #f]\n      [(= x p) #t]\n      [else (is_simple_power\
    \ x (add1 n))])))\n", "  (cond [(= x 1) #t]\n        [(< x 1) #f]\n        [(=\
    \ (modulo x n) 0) (is_simple_power (/ x n) n)]\n        [else #f]))\n", "  (or\
    \ (and (zero? x) (= n 0))\n      (and (not (zero? x))\n           (and (not (zero?\
    \ n))\n                (or (= 1 x)\n                    (let ((diff (- x n)))\n\
    \                      (and (> diff 0)\n                           (or (= n x)\n\
    \                               (is_simple_power diff n)))))))))", "  (define\
    \ (iter i)\n    (cond ((and (= i 1) (= x n)) true)\n          ((and (= i 1) (/=\
    \ x n)) false)\n          ((= x (expt n i)) true)\n          (else (iter (- i\
    \ 1)))))\n  (iter (round (sqrt x))))", "  (let ((log_x (log x)))\n    (or (= x\
    \ 1)\n        (and (integer? log_x)\n             (= (log n) (quotient log_x (floor\
    \ log_x)))))))\n", "  (if (zero? x)\n      #f\n      (if (zero? n)\n         \
    \ #f\n          (if (zero? (modulo x n))\n              (if (zero? (/ x n))\n\
    \                  #t\n                  (is_simple_power (/ x n) n))\n      \
    \        #f))))\n", "  (define (is_simple-power x n start)\n    (cond\n      [(=\
    \ x (expt n start))\n       #t]\n      [(> x (expt n start))\n       (is_simple-power\
    \ x n (+ start 1))]\n      [else\n       #f]))\n  (is_simple-power x n 1))\n",
  "  (let loop ([num x] [power 1])\n    (if (&lt; (** num power) x)\n        (loop\
    \ num (+ power 1))\n        (if (= (** num power) x)\n            #t\n       \
    \     #f))))\n", "  (let loop ([x x] [n n])\n    (if (zero? n) false\n       \
    \ (if (zero? x) false\n            (if (odd? n)\n                (if (odd? x)\n\
    \                    (if (= n x) true\n                        (loop (/ x n) n))\n\
    \                    false)\n                (if (even? x)\n                 \
    \   (loop (/ x n) n)\n                    false))))))\n", '  (= x (expt n (integer-sqrt
    x))))', "  (if (&lt; n 0)\n      #f\n      (equal? (expt n (exact-integer-sqrt\
    \ x)) x)))\n", "  (if (even? n)\n      (cond [(even? x) (is_simple_power (/ x\
    \ 2) (/ n 2))]\n            [else #f])\n      (if (even? x)\n          #f\n  \
    \        (if (= x n)\n              #t\n              (is_simple_power (/ x n)\
    \ n)))))", "  (define base\n    (exact-integer-sqrt (gcd x (expt n 2))))\n  (and\
    \ (integer? base)\n       (= x (expt base n))))\n", "  (if (or (null? x) (null?\
    \ n))\n      #f\n      (if (= (expt n (exact-integer-sqrt (expt n (inexact->exact\
    \ n)))) x)\n          #t\n          #f)))\n", "  (cond\n    [(= (expt n 2) x)\
    \ #t]\n    [(= (expt n 3) x) #t]\n    [(= (expt n 4) x) #t]\n    [(= (expt n 5)\
    \ x) #t]\n    [(= (expt n 6) x) #t]\n    [(= (expt n 7) x) #t]\n    [(= (expt\
    \ n 8) x) #t]\n    [(= (expt n 9) x) #t]\n    [else #f]))", "  (cond\n    [(=\
    \ x 1) #t]\n    [(< x 1) #f]\n    [(= (remainder x n) 0) (is_simple_power (/ x\
    \ n) n)]\n    [else #f]))\n", "  (let ((int (/ (log x) (log n))))\n    (= (expt\
    \ n int) x)))\n", "  (define (is-nth x n)\n    (cond\n      [(> x n) (is-nth (/\
    \ x n) n)]\n      [(< x n) #f]\n      [else #t]))\n  (and (= (remainder x n) 0)\
    \ (is-nth (/ x n) n)))\n", "  (let loop ([x x] [i 2])\n    (cond [(= (expt n i)\
    \ x) true]\n          [(> (expt n i) x) false]\n          [else (loop x (+ i 1))])))\n",
  "  (equal? (expt n (integer-sqrt x)) x))\n", "  (let* ([r (exact-integer-sqrt x)]\n\
    \         [p (integer-sqrt x)])\n    (and (= x (* r r))\n         (or (= p 1)\
    \ (= p n)))))\n", "  (if (= x (* n n))\n      #t\n      (if (= x (* n (* n n)))\n\
    \          #t\n          (if (= x (* n (* n (* n n))))\n              #t\n   \
    \           #f))))\n\n", "  (let* ([i (expt n (truncate (log x n)))]\n       \
    \  [j (expt n (truncate (log x n) 1))])\n    (and (= i x) (= j (truncate j)))))",
  "  (let ([k (expt n 1)])\n    (cond [(= x k) #t]\n          [(< x k) #f]\n     \
    \     [else (is_simple_power (- x k) n)])))\n", "  (define (iter-squares x current-square)\n\
    \    (cond\n      [(= (expt n current-square) x)\n       true]\n      [(&gt; x\
    \ (expt n current-square))\n       (iter-squares x (+ current-square 1))]\n  \
    \    [else\n       false]))\n  (iter-squares x 0))\n", "  (if (and (integer? x)\n\
    \           (integer? n)\n           (= x (expt n (round (log x n)))))\n     \
    \ true\n      false))\n</code>\n", "  (if (= (expt x (floor (/ (log x) (log n))))\
    \ x)\n      #t\n      #f))\n", "  (if (= x (* n n))\n      #t\n      (if (= x\
    \ (* n n n))\n          #t\n          (if (= x (* n n n n))\n              #t\n\
    \              (if (= x (* n n n n n))\n                  #t\n               \
    \   (if (= x (* n n n n n n))\n                      #t\n                    \
    \  (if (= x (* n n n n n n n))\n                          #t\n               \
    \           (if (= x (* n n n n n n n n))\n                              #t\n\
    \                              (if (= x (* n n n n n n n n n))\n             \
    \                     #t\n                                  (if (= x (* n n n\
    \ n n n n n n n))\n                                      #t\n                \
    \                      (if (= x (* n n n n n n n n n n n))\n                 \
    \                         #t\n                                          (if (=\
    \ x (* n n n n n n n n n n n n))\n                                           \
    \   #t\n                                              (if (= x (* n n n n n n\
    \ n n n n n n n))\n                                                  #t\n    \
    \                                              (if (= x (* n n n n n n n n n n\
    \ n n n n))\n                                                      #t\n      \
    \                                                (if (= x (* n n n n n n n n n\
    \ n n n n n n))\n                                                          #t\n\
    \                                                          (if (= x (* n n n n\
    \ n n n n n n n n n n n n))\n                                                \
    \              #t\n                                                          \
    \    (if (= x (* n n n n n n n n n n n n n n n n n))\n                       \
    \                                           #t\n                             \
    \                                     (if (= x (* n n n n n n n n n n n n n n\
    \ n n n n))\n                                                                \
    \      #t\n                                                                  \
    \    (if (= x (* n n n n n n n n n n n n n n n n n n n))\n                   \
    \                                                       #t\n                 \
    \                                                         (if (= x (* n n n n\
    \ n n n n n n n n n n n n n n n n))\n                                        \
    \                                      #t\n                                  \
    \                                            (if (= x (* n n n n", "  (if (negative?\
    \ n)\n      (is_simple_power x (- n))\n      (define (next-power n prev)\n   \
    \     (if (> n x)\n            false\n            (if (= (expt n (floor (log x\
    \ n))) x)\n                true\n                (next-power (* n n) n))))\n \
    \     (next-power n 1)))", "  (let ([e (expt n (integer-sqrt x))])\n    (and (=\
    \ e x) (= (expt e (integer-sqrt n)) x))))\n", "  (if (not (= (square n) x))\n\
    \      #f\n      (or (zero? n) (= x 1))))\n", "  (cond ((= (real-part (expt n\
    \ (/ (log x) (log n)))) x)\n         #t)\n        (else #f)))", "  (define (compare-power\
    \ x n)\n    (cond\n      [(= n 1) true]\n      [(and (integer? (/ x n)) (= x (*\
    \ n (compare-power (/ x n) n)))) true]\n      [else false]))\n  (cond\n    [(=\
    \ x 1) true]\n    [(< x 0) false]\n    [else (compare-power x n)]))", "  (if (=\
    \ x (expt n (exact-floor (log x n)))) #t #f))\n", "  (and (= (expt n (round (log\
    \ x n))) x)\n       (integer? (log x n))))\n", "  (define (is-power n x)\n   \
    \ (cond ((= x 1) #t)\n          ((= x n) #t)\n          ((> x n) (is-power n (*\
    \ n x)))\n          (else #f)))\n  (cond ((= x 1) #t)\n        ((= x n) #t)\n\
    \        ((> x n) (is-power n (* n x)))\n        (else #f)))\n", "  (define (aux\
    \ x n)\n    (cond [(= n 0) false]\n          [(= x 1) false]\n          [(= n\
    \ 1) false]\n          [(= x n) true]\n          [(= (modulo x n) 0) (aux (/ x\
    \ n) n)]\n          [else false]))\n  (cond [(integer? x) (aux x n)]\n       \
    \ [else false]))\n", "  (define (contains-root i)\n    (and (integer? (expt n\
    \ i)) (= x (expt n i))))\n  (for/or ([i (in-range 0 (exact-floor (sqrt x)))])\n\
    \    (contains-root i)))\n", "  (define (is-good y)\n    (and\n     (integer?\
    \ (sqrt y))\n     (exact? (sqrt y))))\n  (define (loop m)\n    (cond\n      [(zero?\
    \ m) false]\n      [(and\n        (is-good (* m x))\n        (number= (expt n\
    \ m) (* m x))) true]\n      [else (loop (- m 1))]))\n  (if (and\n       (not (zero?\
    \ x))\n       (is-good n))\n      (loop n)\n      false))", "  (and (equal? (expt\
    \ n (floor (log x n))) x)\n       (not (zero? (modulo x n)))))\n", "  (if (positive?\
    \ x)\n      (let loop ([i 1])\n        (cond [(= x (* n n)) #t]\n            \
    \  [(<= x (* n n)) #f]\n              [else (loop (+ i 1))]))\n      #f))\n",
  "  (and\n   (and (= x 1) (= n 1))\n   (and (= x (expt n (floor (log x n))))\n  \
    \      (equal? 1 (remainder (log x n) 1)))))\n", "  (integer? (log x n)))\n",
  "  (define (pow n p)\n    (if (and (integer? p) (> p 0))\n        (expt n p)\n \
    \       'false))\n  (let loop ((i 0))\n    (if (= x (pow n i))\n        #t\n \
    \       (if (> x (pow n i))\n            (loop (+ i 1))\n            #f))))\n",
  "  (define (int-part x)\n    (cond\n      [(< x 1) 0]\n      [(< 1 x) (+ 1 (int-part\
    \ (- x 1)))]))\n  (define (power x y)\n    (cond\n      [(< y 1) 1]\n      [(=\
    \ y 1) x]\n      [else (* x (power x (- y 1)))]))\n  (define (is-power x y)\n\
    \    (and (= (modulo x y) 0)\n         (= (power y (/ x y)) x)))\n  (cond\n  \
    \  [(= n 0) (= x 0)]\n    [(is-power x n) #t]\n    [else #f]))\n", "  (and (not\
    \ (zero? x))\n       (number? x)\n       (number? n)\n       (or (zero? (modulo\
    \ x n))\n           (is_simple_power (/ x n) n))))\n", "  (and (integer? x) (>\
    \ x 0) (integer? n) (> n 0)\n       (is-equal? (integer-sqrt x) (integer-sqrt\
    \ (* n (integer-sqrt x))))))\n", "  (equal? (expt n (floor (log x n))) x))\n",
  "  (let* ((int (exact-floor (log x n)))\n         (res (expt n int)))\n    (equal?\
    \ res x)))\n", "  (cond\n    [(zero? x) #t]\n    [(not (integer? (log x n))) #f]\n\
    \    [else (equal? (exp x (log x n)) n)]))\n", "  (letrec ([n-pow (lambda (x)\n\
    \                    (if (zero? x)\n                        1\n              \
    \          (* n (n-pow (- x 1)))))])\n    (and (not (zero? x))\n         (zero?\
    \ (modulo x (n-pow n))))))\n", "  (cond\n    [(< n 0) #f]\n    [(= n 0) #f]\n\
    \    [(= n 1) #t]\n    [(zero? (modulo x n)) (is_simple_power (/ x n) n)]\n  \
    \  [else #f]))\n", "  (if (not (integer? x))\n      #f\n      (if (not (integer?\
    \ n))\n          #f\n          (if (or (= x 1) (= n 1))\n              #t\n  \
    \            (if (= n 0)\n                  #f\n                  (if (= (remainder\
    \ x n) 0)\n                      (is_simple_power (/ x n) n)\n               \
    \       #f))))))\n</code>\nIn the test file:\n<code>#lang racket\n", "  (let ((n\
    \ (abs n)))\n    (cond ((zero? n) false)\n          ((zero? x) false)\n      \
    \    ((and (= n 1) (not (zero? x))) true)\n          ((zero? (modulo x n))\n \
    \          (let loop ((x (exact-floor (log x (abs n))))\n                    \
    \  (n (abs n)))\n             (if (= x n) true\n                 (if (= x 1) false\n\
    \                     (loop (exact-floor (log x n)) n)))))\n          (else false))))\n",
  "  (define (ipow base exp)\n    (cond\n      [(= exp 0) 1]\n      [(= exp 1) base]\n\
    \      [else\n       (* base (ipow base (- exp 1)))]))\n  (define (inner i)\n\
    \    (cond\n      [(= (ipow n i) x) #t]\n      [(> (ipow n i) x) #f]\n      [else\
    \ (inner (+ i 1))]))\n  (inner 1))\n", "  (if (= x (* n n))\n      true\n    \
    \  (let loop ((x x) (n n))\n        (if (and (= (modulo x n) 0)\n            \
    \     (= (modulo x (sqr n)) 0))\n            true\n            (and (&gt;= x n)\n\
    \                 (loop (/ x n) n))))))\n", "  (let loop ([i 1])\n    (cond\n\
    \      [(= x (expt n i)) #t]\n      [(> (expt n i) x) #f]\n      [else (loop (+\
    \ i 1))])))\n", "  (let loop ([i 1])\n    (cond\n      [(> i x) false]\n     \
    \ [(= (expt n i) x) true]\n      [else (loop (+ i 1))])))\n", "  (if (number?\
    \ x)\n      (if (number? n)\n          (if (equal? (expt n (floor (log x n)))\
    \ x)\n              #t\n              #f)\n          #f)\n      #f))", "  (if\
    \ (= x 1)\n      #t\n      (if (= (modulo x n) 0)\n          (is_simple_power\
    \ (/ x n) n)\n          #f)))\n", "  (let* ((g (gcd x n))\n         (x (div x\
    \ g))\n         (n (div n g)))\n    (cond\n      [(= 1 x) (expt n (floor (log\
    \ x n))) (= x n)]\n      [else #f])))\n", "  (let loop ([i 1])\n    (cond\n  \
    \    [(< x 1) #f]\n      [(= x 1) #t]\n      [(= (* i i) x) #t]\n      [(= (expt\
    \ n i) x) #t]\n      [else (loop (+ i 1))])))", "  (let ([logx (log x)])\n   \
    \ (or (zero? (exact-integer-sqrt x))\n        (zero? (- (floor (* logx (log n)))\
    \ (floor (* logx logx)))))))\n", "  (let ([a (expt n (round (log x n)))]\n   \
    \     [b (expt n (+ 1 (round (log x n))))])\n    (and (= a x) (= x (sqrt (+ (*\
    \ a a) (* a b)))))))\n", "  (let ([x (exact-floor (sqrt x))])\n    (equal? x n)))\n",
  "  (if (zero? (modulo x n))\n      (if (equal? x n)\n          true\n          (is_simple_power\
    \ (quotient x n) n))\n      false))\n", "  (if (zero? x)\n      #f\n      (let\
    \ ([p (expt n (floor (log x n)))]\n            [q (log x n)])\n        (if (=\
    \ p x)\n            #t\n            #f))))\n", "  (if (= x (expt n (exact-integer-sqrt\
    \ x)))\n      #t\n      #f))\n", "  (letrec ([next (lambda (m) (if (= m 1) '()\
    \ (cons (* m n) (next (sub1 m)))))])\n    (if (eq? 1 x) true\n        (ormap (curryr\
    \ = x) (next x)))))\n", "  (cond\n    [(zero? x) false]\n    [(zero? n) false]\n\
    \    [(= 1 n) (= 1 x)]\n    [(and (integer? (expt n (exact-floor (log x n))))\
    \ (= x (expt n (exact-floor (log x n)))))\n     true]\n    [else false]))\n",
  "  (let* ([logx (exact-floor (log x))]\n         [logn (exact-floor (log n))])\n\
    \    (and (integer? (/ logx logn))\n         (= x (expt n (/ logx logn))))))",
  "  (if (= n 1)\n      #t\n      (and (integer? (expt n (/ (log x) (log n))))\n \
    \          (= x (expt n (/ (log x) (log n)))))))\n", "  (let ([lo (floor (log\
    \ x n))]\n        [hi (ceiling (log x n))])\n    (and (= (expt n lo) x) (= (expt\
    \ n hi) x))))", "  (define (sqr x) (* x x))\n  (define (pow x n)\n    (if (= n\
    \ 0)\n        1\n        (* x (pow x (- n 1)))))\n  (define (simple_power x n)\n\
    \    (if (= n 1)\n        #t\n        (if (= x 1)\n            #f\n          \
    \  (if (= n (sqr n))\n                (simple_power (/ x n) n)\n             \
    \   (simple_power x (+ n 1))))))\n  (simple_power x 2))\n", "  (is-power x n))\n",
  "  (define (is-power-of-n x n)\n    (if (equal? x 1) #t\n        (if (< x n) #f\n\
    \            (if (equal? (modulo x n) 0) (is-power-of-n (/ x n) n) #f))))\n  (if\
    \ (equal? n 1) (equal? x 1)\n      (is-power-of-n x n)))\n", "  (cond ((not (integer?\
    \ x)) #f)\n        ((= x 1) #t)\n        ((not (integer? (sqrt x))) #f)\n    \
    \    ((and (= (expt n (quotient (log x) (log n))) x)\n              (= x (expt\
    \ n (quotient (log x) (log n))))) #t)\n        (else #f)))\n", "  (and (integer?\
    \ x)\n       (integer? n)\n       (integer? (log x n))\n       (= (expt n (log\
    \ x n)) x)))\n", "  (letrec ([iter (lambda (x n i)\n\t\t   (cond\n\t\t     [(=\
    \ x (* n i)) #t]\n\t\t     [(> (* n i) x) #f]\n\t\t     [else (iter x n (+ i 1))]))])\n\
    \    (iter x n 1)))\n", "  (cond ((= x 1) #t)\n        ((and (= (expt n (round\
    \ (log x n))) x)\n              (not (integer? (log x n)))) #t)\n        (else\
    \ #f)))\n", "  (integer? (log x n)))\n", "  (if (integer? n)\n      (error \"\
    Expected integer in the form of n**int\"))\n  (if (integer? x)\n      (error \"\
    Expected integer in the form of n**int\"))\n  (if (= n 1)\n      (if (= x 1)\n\
    \          #t\n          #f)\n      (let recur ((x x) (n n))\n        (if (= x\
    \ 1)\n            #t\n            (if (= (modulo x n) 0)\n                (recur\
    \ (/ x n) n)\n                #f)))))\n", "  (if (zero? (modulo x n))\n      (if\
    \ (eqv? (expt n (quotient (expt 2 (floor (log n x))) (log n n))) x)\n        \
    \  #t\n          #f)\n      #f))\n", "  (if (zero? (remainder x n))\n      (if\
    \ (equal? (expt n (round (log x n))) x)\n          #t\n          #f)\n      #f))\n",
  "  (if (and (not (= n 1)) (not (= x 0)))\n      (if (= n 1)\n          true\n  \
    \        (if (not (= (modulo x n) 0))\n              false\n              (is_simple_power\
    \ (/ x n) n)))))\n", "  (define (is-simple-power? x n b e)\n    (if (&gt; b e)\n\
    \        false\n        (if (= n (expt x b))\n            true\n            (is-simple-power?\
    \ x n (+ b 1) e))))\n  (is-simple-power? x n 0 10))\n", "  (let loop ([base n]\
    \ [power 1])\n    (cond [(= base (* x x)) (= x (* n x))]\n          [(> base (*\
    \ x x)) #f]\n          [else (loop (* base n) (+ power 1))])))\n", "  (define\
    \ (power-of-n x n d)\n    (cond [(&lt; x n) d]\n          [(= x n) (+ d 1)]\n\
    \          [else (power-of-n (* n x) n (+ d 1))]))\n  (let loop ([n n] [d 0])\n\
    \    (if (= n x) d\n        (if (&lt; n x) (loop (* n n) (+ d 1))\n          \
    \  (power-of-n x n d)))))\n", '  (integer? (log x n)))', '  (or (equal? x n) (equal?
    x 1) (is_simple_power n (/ x n))))', "  (and (<= 1 n) (<= n 20) (<= 1 x) (<= x\
    \ 1000)\n       (= x (expt n (floor (log x n))))))", "  (define (is-power-of?\
    \ k x)\n    (if (= 1 x)\n        #t\n        (if (= (modulo x k) 0)\n        \
    \    (is-power-of? k (/ x k))\n            #f)))\n  (and (is-power-of? n x)\n\
    \       (= (/ x n) (/ x n))))\n", "  (and (integer? (expt n (exact-integer-sqrt\
    \ x))) (= x (expt n (exact-integer-sqrt x)))))\n", "  (define (loop x n acc)\n\
    \    (cond\n      [(= x 1) #f]\n      [(= x acc) #t]\n      [(< x acc) #f]\n \
    \     [else (loop x n (* acc n))]))\n  (loop x n n))\n", "  (let ((root (exact-floor\
    \ (expt x (inverse x)))))\n    (when (equal? root n)\n      #t)))\n", "  (let\
    \ ([m (sqrt x)])\n    (and (= m (round m))\n         (= (expt n (round m)) x))))",
  "  (cond\n    [(= 1 x) #t]\n    [(= 1 n) #f]\n    [(= 1 (modulo x n)) (is_simple_power\
    \ (/ x n) n)]\n    [else #f]))\n", "  (cond ((eq? x 1) #t)\n        ((= x (expt\
    \ n (truncate (log x n)))) #t)\n        (else #f)))\n", "  (define (is-power?\
    \ i)\n    (and (> i 0)\n         (= 0 (modulo x (expt n i)))))\n  (and (positive?\
    \ x)\n       (define (i-iter i)\n         (cond ((is-power? i) #t)\n         \
    \      ((= i 0) #f)\n               (else (i-iter (sub1 i)))))\n       (i-iter\
    \ (log x n))))\n", "  (let loop ([k 1])\n    (cond\n      [(and (exact? (expt\
    \ n k))\n            (= x (expt n k))) #t]\n      [(>= k x) #f]\n      [else (loop\
    \ (+ k 1))])))\n", "  (integer? (log x n)))\n", "  (define n-to-the-1 (expt n\
    \ 1))\n  (if (equal? n-to-the-1 x) #t\n      (if (< n-to-the-1 x) (is_simple_power\
    \ x (+ n 1))\n          #f)))\n", "  (define (next_power n)\n    (let ((power\
    \ 1))\n      (let loop ((n (* n n)))\n        (if (&gt; n x)\n            (begin\
    \ (set! power (sqrt power))\n                   (if (zero? (modulo x power))\n\
    \                       power\n                       #f))\n            (begin\
    \ (set! power n)\n                   (loop (* n n)))))))\n  (not (zero? (next_power\
    \ n))))\n", "  (define (is-divisible? x y)\n    (= (/ x y) (truncate (/ x y))))\n\
    \  (cond ((and (or (is-divisible? x n) (= x n))\n              (not (is-divisible?\
    \ x (* n n)))) #t)\n        (else #f)))\n", "  (let loop ([x x] [n n])\n    (if\
    \ (zero? n)\n        #f\n        (if (zero? (modulo x n))\n            (if (zero?\
    \ (modulo x (* n n)))\n                #f\n                (loop (quotient x n)\
    \ n))\n            #f))))\n", "  (let* ((root (exact-integer-sqrt x))\n      \
    \   (root-is-perfect-square (and (integer? root)\n                           \
    \           (= (* root root) x))))\n    (and (= n root)\n         root-is-perfect-square)))\n",
  "  (and (= (expt n (round (log x n))) x) (= (round (log x n)) (log x n))))\n", " \
    \ (let loop ([x x] [n n])\n    (if (and (not (eq? x 1)) (not (eq? n 1)))\n   \
    \     (if (integer? (/ x n))\n            (loop (/ x n) n)\n            false)\n\
    \        true)))", "  (if (= x 1)\n      #t\n      (if (= x n)\n          #t\n\
    \          (if (= 0 (modulo x n))\n              (is_simple_power (/ x n) n)\n\
    \              #f))))", "  (if (&lt; (expt n (floor (log x n))) x)\n      (if\
    \ (&gt; (expt n (ceiling (log x n))) x)\n          #f\n          (if (or (= (floor\
    \ (log x n)) (ceiling (log x n)))\n                  (= (floor (log x n)) (log\
    \ x n)))\n              #t\n              #f))\n      #f))\n", "  (if (zero? x)\
    \ #t\n      (let ([exp (log n x)])\n        (if (integer? exp) #t #f))))\n", " \
    \ (let* ([i (integer-sqrt x)]\n         [i2 (* i i)])\n    (and (= x i2) (= (expt\
    \ n i) x))))\n", "  (let loop ([x x] [n n])\n    (cond\n      [(equal? x n) #t]\n\
    \      [(zero? x) #f]\n      [(and (integer? (log x n)) (loop (/ x n) n)) #t]\n\
    \      [else #f])))\n", "  (or (= x n)\n      (and (integer? (sqrt n))\n     \
    \      (= (* n (expt n (- (integer-length x) (integer-length n)))) x))))\n", " \
    \ (cond ((= x 1) #t)\n        ((= x n) #t)\n        ((< x n) #f)\n        (else\
    \ (is_simple_power (/ x n) n))))\n", "  (let ([m (sqrt x)])\n    (or (= m (truncate\
    \ m))\n        (not (integer? (/ x (expt m (truncate m))))))))\n", "  (let ((mx\
    \ (sqrt x)))\n    (and (<= 1 mx) (<= mx x)\n         (= (expt (round mx) (expt\
    \ (log mx) n)) x))))\n", "  (if (= x (expt n (exact-integer-sqrt x)))\n      #t\n\
    \      #f))", "  (cond\n    [(equal? x n) #t]\n    [(< x n) #f]\n    [(equal?\
    \ (remainder x n) 0) (is_simple_power (/ x n) n)]\n    [else #f]))", "  (cond\
    \ ((= x n) 1)\n        ((< x n) 0)\n        (else\n         (let ([q (quotient\
    \ x n)])\n           (if (= q n) 1\n               (if (integer? q) (is_simple_power\
    \ q n) 0))))))", "  (and (= x (expt n (exact-floor (log x n))))\n       (= (exact-floor\
    \ (log x n)) (log x n))))\n", "  (if (= (expt n (round (log x))) x)\n      #t\n\
    \      #f))", "  (cond ((< n 1) #f)\n        ((= n 1) (or (= x 1) (= x 0)))\n\
    \        ((even? n)\n         (if (even? x)\n             (is_simple_power (quotient\
    \ x 2) (quotient n 2))\n             #f))\n        (else (if (and (integer? (expt\
    \ n (quotient (log x) (log n))))\n                       (= (expt n (quotient\
    \ (log x) (log n))) x))\n                 #t\n                 #f))))\n", "  (let\
    \ ([up (expt n (ceiling (/ (log x) (log n))))])\n    (if (= x up)\n        (eq?\
    \ (modulo up n) 0)\n        #f)))\n", "  (define (is-integer? x)\n    (and (integer?\
    \ x) (= x (round x))))\n  (define (is-simple-power? x n)\n    (is-integer? (/\
    \ x n)))\n  (let ([n (if (negative? n) (- n) n)])\n    (cond\n      [(is-integer?\
    \ x) (= x (expt n (round (log x n))))]\n      [(and (not (is-integer? x)) (is-simple-power?\
    \ x n))\n       (is-simple-power? (/ x n) n)]\n      [else #f])))\n", "  (let\
    \ loop ([p 1])\n    (if (= (* p p) x)\n        true\n        (if (&lt; (* p p)\
    \ x)\n            (loop (* p n))\n            false))))\n", "  (define (iter x\
    \ n current)\n    (if (&lt; n current)\n        #f\n        (if (= n current)\n\
    \            #t\n            (iter x n (* current n)))))\n  (iter x n 1))\n",
  "  (define (is_whole num)\n    (if (eq? (remainder num 1) 0)\n      #t\n      #f))\n\
    \  (define (iter n pow)\n    (if (is_whole (/ x (expt n pow)))\n      #t\n   \
    \   (if (< pow 20)\n        (iter n (+ pow 1))\n        #f)))\n  (iter n 1))\n",
  "  (define (is_power_of x n)\n    (if (= n 0)\n        #f\n        (if (= (remainder\
    \ x n) 0)\n            (is_power_of (/ x n) n)\n            #f)))\n  (is_power_of\
    \ x n))\n</code>\nI use this function in <code>is_power_of</code> to determine\
    \ if the remainder is 0. If it is, then I recursively call the function again\
    \ with <code>/ x n</code>. \nMy question is, if I call <code>(is_power_of 4 2)</code>,\
    \ the function will return <code>#t</code> as expected, but if I call <code>(is_power_of\
    \ 125 5)</code>, it just hangs. I'm assuming it's because the recursion is infinite\
    \ because it keeps returning <code>#t</code>.\nEdit: Here's what I ended up using:\n\
    <code>#lang racket\n", "  (let ((sqrt-x (exact-floor (sqrt x))))\n    (and\n \
    \    (integer? sqrt-x)\n     (= x (expt n sqrt-x)))))\n", "  (let loop ([p 1])\n\
    \    (cond [(= (* p p) x) true]\n          [(> (* p p) x) false]\n          [else\
    \ (loop (+ p 1))])))\n", "  (let ([is-power (\u03BB (x n)\n                  \
    \  (and (<= 1 n)\n                         (integer? (log x n))))])\n    (cond\
    \ [(= x n) #t]\n          [(and (< n x)\n                (is-power x n)) #t]\n\
    \          [else #f])))", '  (or (= x n) (is_simple_power x (* n n))))', "  (let\
    \ ([lo (log x)]\n        [hi (log x)])\n    (let loop ([lo 0] [hi (log x)])\n\
    \      (if (&lt;= lo hi)\n          (let ([mid (/ (+ lo hi) 2)])\n           \
    \ (let ([res (round (log x (expt n mid)) 0)])\n              (cond\n         \
    \       [(= res 1) (= x (expt n mid))]\n                [(&lt; res 1) (loop (+\
    \ mid 1) hi)]\n                [(&gt; res 1) (loop lo (- mid 1))])))\n       \
    \   #f))))\n</code>\nHere is a link to the test script that I'm using to check\
    \ the results.\nTo give you an idea of how the test script works, here is one\
    \ of the tests:\n<code>(is_simple_power 9 3) =&gt; true\n</code>\nI'm not really\
    \ interested in being told that I need to be using floating point numbers instead\
    \ of integers.  The intent is to find a quick and dirty solution.  I'm more interested\
    \ in seeing other approaches to this problem.  How would you solve this?\n\n\n\
    A:\n\nOne simple way to solve this problem is:\n\nFind integer <code>p</code>\
    \ and <code>q</code> such that <code>n^p == q * x</code> (where <code>^</code>\
    \ means \"raise to the power of\") using a logarithm.\nCheck whether <code>q</code>\
    \ is equal to 1. If it's not, the number is not a power of <code>n</code>.\n\n\
    The code would look like this:\n<code>(define (is-power? x n)\n  (define (power-of?\
    \ x n)\n    (let ((p (inexact-&gt;exact (ceiling (log x n)))))\n      (exact=?\
    \ x (inexact-&gt;exact (expt n p)))))\n  (let ((q (inexact-&gt;exact (exact-divide\
    \ x (expt n (inexact-&gt;exact (ceiling (log x n))))))))\n    (or (exact=? q 1)\n\
    \        (power-of", "  (if (and (integer? x)\n           (integer? n)\n     \
    \      (> n 0))\n      (cond ((and (= (expt n (inexact->exact (log x n))) x)\n\
    \                  (= (inexact->exact (log x n)) (expt n (inexact->exact (log\
    \ x n)))))\n             #t)\n            (else #f))\n      #f))\n", "  (if (=\
    \ 0 (remainder x n))\n      (or (= x n) (is_simple_power (/ x n) n))\n      #f))\n",
  "  (let ([n-exp 2])\n    (let loop ((x x) (n-exp n-exp))\n      (if (&lt; x 1)\n\
    \          #f\n          (if (= (* n n-exp) x)\n              #t\n           \
    \   (loop x (+ n-exp 1)))))))\n", "  (is-integer? (log n x)))\n", "  (define (is_power\
    \ x n)\n    (if (= 1 x) #t\n        (if (= 1 n) #f\n            (if (= (modulo\
    \ x n) 0) (is_power (/ x n) n) #f))))\n  (if (= n 1) (if (= x 1) #t #f)\n    \
    \  (is_power x n)))\n", "  (define (helper n)\n    (if (= n 1) 1\n        (* n\
    \ (helper (- n 1)))))\n  (define (helper2 n x)\n    (if (= n 1) #t\n        (if\
    \ (= x (helper n)) #t\n            (helper2 (- n 1) x))))\n  (helper2 x x))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
