name: HumanEval_95_check_dict_case
language: rkt
prompt: "#lang racket\n\n;; Given a dictionary, return True if all keys are strings\
  \ in lower \n;; case or all keys are strings in upper case, else return False.\n\
  ;; The function should return False is the given dictionary is empty.\n;; Examples:\n\
  (define (check_dict_case dict)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n\
  \    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"\
  ))) #t)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"\
  banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\"\
  \ .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal?\
  \ (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"\
  ))) #f)\n    (check-equal? (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"\
  12345\"))) #t)\n    (check-equal? (candidate #hash((\"fruit\" .  \"Orange\") (\"\
  taste\" .  \"Sweet\"))) #t)\n    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
completions: ["  (letrec ([get-key-case (lambda (key)\n                          \
    \ (if (string? key)\n                               (string-downcase key)\n  \
    \                             key))]\n           [check-same-case (lambda (keys\
    \ compare-to)\n                              (or (null? keys)\n              \
    \                    (and (equal? (get-key-case (car keys))\n                \
    \                               compare-to)\n                                \
    \       (check-same-case (cdr keys)\n                                        \
    \                compare-to))))])\n    (check-same-case (dict-keys dict)\n   \
    \                  (get-key-case (car (dict-keys dict))))))\n", "  (cond [(empty?\
    \ dict) #f]\n        [(all? string? (map key dict))\n         (let ([c (string-ref\
    \ (key (first dict)) 0)])\n           (and (all? (lambda (k) (char-lower-case?\
    \ (string-ref k 0)))\n                       (map key dict))\n               \
    \ (or (char=? (char-lower-case c) c)\n                    (char=? (char-upper-case\
    \ c) c))))]\n        [else #f]))\n", "  (cond\n    [(empty? dict) #f]\n    [(lower-case?\
    \ (first (keys dict)))\n     (and (lower-case? (rest (keys dict)))\n         \
    \ (check_dict_case (rest dict)))]\n    [(upper-case? (first (keys dict)))\n  \
    \   (and (upper-case? (rest (keys dict)))\n          (check_dict_case (rest dict)))]\n\
    \    [else #f]))\n", "  (if (null? dict)\n      #f\n      (for/and ([key (in-list\
    \ (hash-keys dict))])\n        (or (string-ci=? key (symbol->string key))\n  \
    \          (string-ci=? key (string-upcase (symbol->string key)))))))\n", "  (match\
    \ dict\n    [(list) #f]\n    [(list (list 'lower-case _) _) #t]\n    [(list (list\
    \ 'upper-case _) _) #t]\n    [_ #f]))", "  (cond\n    [(or (empty? dict) (not\
    \ (string? (car (keys dict))))) #f]\n    [(< (count-predicates dict #(or (string-lower-case?\
    \ (car %)) (string-upper-case? (car %))))\n        (length dict)) #f]\n    [else\
    \ #t]))", "  (define (check-keys dict acc)\n    (cond ((null? dict) acc)\n   \
    \       ((string-upcase? (car (car dict)))\n           (check-keys (cdr dict)\
    \ 'upper))\n          ((string-downcase? (car (car dict)))\n           (check-keys\
    \ (cdr dict) 'lower))\n          (else #f)))\n  (and (not (null? dict))\n    \
    \   (equal? (check-keys dict 'nothing)\n               (check-keys (reverse dict)\
    \ 'nothing))))\n", "  (define (is-lower? word)\n    (and (string? word)\n    \
    \     (string-ci=? (string-upper-case word) word)))\n  (define (is-upper? word)\n\
    \    (and (string? word)\n         (string-ci=? (string-lower-case word) word)))\n\
    \  (or (every is-lower? (hash-keys dict))\n      (every is-upper? (hash-keys dict))))\n",
  "  (cond\n    [(empty? dict) #f]\n    [(empty? (rest dict)) #t]\n    [(char-ci=?\
    \ (string-ref (car (rest dict)) 0)\n                (string-ref (car dict) 0))\n\
    \     (check_dict_case (rest dict))]\n    [else #f]))\n", "  (cond\n    [(not\
    \ (empty? dict))\n     (check-strings-case (map (\u03BB (x) (key x)) dict))]\n\
    \    [else #f]))\n", "  (let ([cases (map (lambda (x) (if (string? x) (string-upper-case\
    \ x) #f)) (hash-keys dict))])\n    (if (member #f cases) #f\n        (if (eq?\
    \ (length (remove-duplicates cases)) 1) #t #f))))\n", "  (let ([lower-keys (filter\
    \ (lambda (k) (string-ci=? k k)) (hash-keys dict))]\n        [upper-keys (filter\
    \ (lambda (k) (string-ci=? k (string-upcase k))) (hash-keys dict))])\n    (and\
    \ (not (hash-empty? dict))\n         (or (equal? lower-keys (hash-keys dict))\n\
    \             (equal? upper-keys (hash-keys dict))))))\n", "  (cond [(empty? dict)\
    \ #f]\n        [(for/and ([item (in-list (list-ref dict 0))]) (string-ci=? (car\
    \ item) (string-downcase (car item)))) #t]\n        [(for/and ([item (in-list\
    \ (list-ref dict 0))]) (string-ci=? (car item) (string-upcase (car item)))) #t]\n\
    \        [else #f]))\n", "  (cond [(empty? dict) false]\n        [(ormap (lambda\
    \ (key) (symbol? key)) (map (lambda (k v) (car k)) dict)) true]\n        [(ormap\
    \ (lambda (key) (string? key)) (map (lambda (k v) (car k)) dict)) true]\n    \
    \    [else false]))\n", "  (cond [(empty? dict) false]\n        [(andmap string?\
    \ (keys dict)) true]\n        [else false]))", "  (cond ((empty? dict) false)\n\
    \        ((or (all-upper? dict) (all-lower? dict)) true)\n        (else false)))\n",
  "  (cond [(empty? dict) #f]\n        [(every? string? (keys dict))\n         (cond\
    \ [(every? string-ci=? (keys dict)) #t]\n               [(every? string-upcase?\
    \ (keys dict)) #t]\n               [else #f])]\n        [else #f]))\n", "  (if\
    \ (empty? dict)\n      #f\n      (let ([case (lambda (dict)\n                \
    \    (if (empty? dict)\n                        #t\n                        (let\
    \ ([k (first (keys dict))])\n                          (if (not (string? k))\n\
    \                              #f\n                              (if (char-lower-case?\
    \ (string-ref k 0))\n                                  (check-dict-case-helper\
    \ dict #t)\n                                  (check-dict-case-helper dict #f))))))])\n\
    \        (case dict))))\n", "  (define keys (hash-keys dict))\n  (cond [(and (string?\
    \ (first keys))\n              (string-upcase? (first keys)))\n         (all-string-upcase?\
    \ keys)]\n        [(and (string? (first keys))\n              (string-lowercase?\
    \ (first keys)))\n         (all-string-lowercase? keys)]\n        [else false]))\n",
  "  (cond\n    [(empty? dict) #f]\n    [(list? (dict-keys dict)) (check_dict_case\
    \ (cdr dict))]\n    [(and (symbol? (car (dict-keys dict)))\n          (= (symbol-&gt;string\
    \ (car (dict-keys dict))) (string-upcase (symbol-&gt;string (car (dict-keys dict))))))\n\
    \     (check_dict_case (cdr dict))]\n    [(and (symbol? (car (dict-keys dict)))\n\
    \          (= (symbol-&gt;string (car (dict-keys dict))) (string-downcase (symbol-&gt;string\
    \ (car (dict-keys dict))))))\n     (check_dict_case (cdr dict))]\n    [else #f]))\n",
  "  (if (or (= (length dict) 0)\n          (and (string? (first (first dict))) (string-downcase?\
    \ (first (first dict)))))\n      (cond ((= (length dict) 1) (string? (first (first\
    \ dict))))\n            ((and (string? (first (first dict))) (string-downcase?\
    \ (first (first dict))))\n             (check_dict_case (rest dict)))\n      \
    \      (else #f))\n      #f))\n", "  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (all-string-upper? (keys dict))\n          (not (any-string-lower? (keys dict))))\
    \ #t]\n    [(and (all-string-lower? (keys dict))\n          (not (any-string-upper?\
    \ (keys dict)))) #t]\n    [else #f]))\n", "  (if (= (hash-count dict) 0)\n   \
    \   #f\n      (let ([lower-case-re #rx\"[a-z]+\"]\n            [upper-case-re\
    \ #rx\"[A-Z]+\"])\n        (let ([keys (hash-keys dict)])\n          (match keys\n\
    \            [((or lower-case-re upper-case-re) ...) #t]\n            [_ #f])))))\n",
  "  (cond [(empty? dict) false]\n        [(string-ci=? (hash-ref dict (hash-key dict))\n\
    \                       (hash-ref dict (hash-next dict)))\n         true]\n  \
    \      [else false]))\n", "  (cond\n    [(empty? dict) #f]\n    [(lower-case?\
    \ (first (dict-keys dict))) #t]\n    [(upper-case? (first (dict-keys dict))) #t]\n\
    \    [else #f]))\n", "  (cond\n    [(empty? dict) false]\n    [(and (symbol=?\
    \ 'false (map (lambda (x) (and (string? x) (string-downcase x))) (keys dict)))\n\
    \          (symbol=? 'false (map (lambda (x) (and (string? x) (string-upcase x)))\
    \ (keys dict))))\n     false]\n    [else true]))\n", "  (cond [(empty? dict) false]\n\
    \        [(string-ci=? (string-downcase (symbol->string (car (car dict))))\n \
    \                     (symbol->string (car (car dict)))) true]\n        [(string-ci=?\
    \ (string-upcase (symbol->string (car (car dict))))\n                      (symbol->string\
    \ (car (car dict)))) true]\n        [else false]))\n</code>\nThe function works\
    \ fine, the only thing I would like to improve is the two <code>string-ci=?</code>\
    \ calls that check if the string is all lowercase or all uppercase. I don't really\
    \ like the fact that I'm using the <code>symbol-&gt;string</code> function twice.\
    \ Is there any way to improve this part of the code?\n\n\nA:\n\nThe way I would\
    \ do it is to use some helper functions that do the job of detecting if a string\
    \ is all uppercase or all lowercase, and use <code>map</code> to build the list\
    \ of results and the <code>every?</code> function to check them:\n<code>(define\
    \ (check-all-uppercase? str)\n  (every? char-uppercase? (string-&gt;list str)))\n",
  "  (and (not (empty? dict))\n       (or (every (lambda (k) (string-upper-case? k))\
    \ (keys dict))\n           (every (lambda (k) (string-lower-case? k)) (keys dict)))))\n\
    </code>\n", "  (let ([all-upper?\n         (for/and ([(k v) (in-dict dict)])\n\
    \           (string-ci=? (string-upcase k) k))]\n        [all-lower?\n       \
    \  (for/and ([(k v) (in-dict dict)])\n           (string-ci=? (string-downcase\
    \ k) k))])\n    (or all-upper? all-lower?)))", "  (cond\n    [(empty? dict) false]\n\
    \    [(and (string-lower-case? (first (dict-keys dict)))\n          (string-upper-case?\
    \ (first (dict-keys dict))))\n     false]\n    [(not (string-lower-case? (first\
    \ (dict-keys dict))))\n     false]\n    [(not (string-upper-case? (first (dict-keys\
    \ dict))))\n     false]\n    [else (check_dict_case (rest (dict-keys dict)))]))\n",
  "  (cond\n    [(equal? dict '()) #f]\n    [(and (string? (car (car dict))) \n  \
    \        (string? (car (cdr (car dict)))))\n     (and (string-ci=? (car (car dict))\
    \ (car (cdr (car dict))))\n          (check_dict_case (cdr dict)))]\n    [else\
    \ #f]))", "  (let loop ([k (dict-keys dict)]\n             [uc? #t]\n        \
    \     [lc? #t])\n    (cond [(empty? k) (and uc? lc?)]\n          [(and uc? lc?)\
    \ #f]\n          [(symbol=? (string-upper-case (car k)) (car k))\n           (loop\
    \ (cdr k) #t lc?)]\n          [(symbol=? (string-lower-case (car k)) (car k))\n\
    \           (loop (cdr k) uc? #t)]\n          [else (loop (cdr k) #f #f)])))\n",
  "  (cond ((not (dict? dict)) #f)\n        ((empty? dict) #f)\n        ((andmap string?\
    \ (keys dict)) #t)\n        ((andmap string-upcase? (keys dict)) #t)\n       \
    \ (else #f)))", "  (cond [(empty? dict) false]\n        [(and (string? (first\
    \ (keys dict)))\n              (string? (first (keys (rest dict)))))\n       \
    \  (and (lower-case? (first (keys dict)))\n              (lower-case? (first (keys\
    \ (rest dict)))))]\n        [(and (string? (first (keys dict)))\n            \
    \  (string? (first (keys (rest dict)))))\n         (and (upper-case? (first (keys\
    \ dict)))\n              (upper-case? (first (keys (rest dict)))))]\n        [else\
    \ false]))\n", "  (cond [(empty? dict) #f]\n        [(andmap lower-case? (keys\
    \ dict)) #t]\n        [(andmap upper-case? (keys dict)) #t]\n        [else #f]))\n",
  "  (cond\n    [(empty? dict) #f]\n    [(and (string-downcase? (first (keys dict)))\
    \ (string-upcase? (first (keys dict)))) #f]\n    [(and (string-downcase? (first\
    \ (keys dict))) (check_dict_case (rest dict))) #t]\n    [(and (string-upcase?\
    \ (first (keys dict))) (check_dict_case (rest dict))) #t]\n    [else #f]))\n</code>\n\
    What am I doing wrong?\n\n\nA:\n\n<code>string-upcase?</code> is not a function.\
    \  Use <code>string-upcase</code> instead.\n", "  (and (not (empty? dict)) \n\
    \       (cond ((andmap (lambda (x) (string-ci=? x (string-upcase x)))\n      \
    \                (dict-keys dict))\n              #t)\n             ((andmap (lambda\
    \ (x) (string-ci=? x (string-downcase x)))\n                      (dict-keys dict))\n\
    \              #t)\n             (else #f))))\n", "  (cond\n    [(null? dict)\
    \ #f]\n    [(string-titlecase? (string-downcase (string-trim (symbol->string (car\
    \ (car dict))))))\n     (check_dict_case (cdr dict))]\n    [(string-lowercase?\
    \ (string-trim (symbol->string (car (car dict)))))\n     (check_dict_case (cdr\
    \ dict))]\n    [else #f]))\n</code>\nHere's the output:\n<code>&gt; (check_dict_case\
    \ '((one . 1) (two . 2) (three . 3)))\n#f\n&gt; (check_dict_case '((one . 1) (TWO\
    \ . 2) (three . 3)))\n#f\n&gt; (check_dict_case '((ONE . 1) (TWO . 2) (THREE .\
    \ 3)))\n#t\n&gt; (check_dict_case '((one . 1) (TWO . 2) (THREE . 3)))\n#f\n&gt;\
    \ (check_dict_case '((ONE . 1) (TWO . 2) (three . 3)))\n#f\n&gt; (check_dict_case\
    \ '((ONE . 1) (two . 2) (THREE . 3)))\n#f\n&gt; (check_dict_case '((one . 1) (two\
    \ . 2) (THREE . 3)))\n#f\n&gt; (check_dict_case '((ONE . 1) (two . 2) (three .\
    \ 3)))\n#f\n&gt; (check_dict_case '())\n#f\n</code>\nSo I'm getting the behavior\
    \ I'm looking for, but I'm concerned about how ugly the code is.  Is there a better\
    \ way to do this?\n\n\nA:\n\nWell, first, why is it ugly?  It looks like you tried\
    \ very hard to do the right thing and make the code readable.  The types are clear,\
    \ the idioms are appropriate, and there's no repetition.  The names are a little\
    \ verbose, but no worse than typical Racket code.  I think your code is just fine.\n\
    Of course, we can make it a little more concise and less repetitive:\n<code>(define\
    \ (check", "  (let loop ((keys (hash-keys dict)))\n    (cond [(empty? keys) #t]\n\
    \          [(and (string? (first keys)) (not (string-ci=? (first keys) (string-upcase\
    \ (first keys))))) #f]\n          [(and (string? (first keys)) (not (string-ci=?\
    \ (first keys) (string-downcase (first keys))))) #f]\n          [else (loop (rest\
    \ keys))])))\n</code>\nThanks for any assistance!\n\n\nA:\n\nThe problem is that\
    \ Racket's hash table implementation uses symbols as keys, not strings. Symbols\
    \ are normally compared by identity, not by value, but comparing strings is more\
    \ efficient for the implementation of hash tables.\nIt should be possible to fix\
    \ your implementation by replacing all <code>string?</code> checks with <code>symbol?</code>\
    \ checks, replacing <code>string-ci=?</code> with <code>symbol=?</code>, and surrounding\
    \ the key literals with <code>'</code> instead of <code>\"</code>.\nIt may also\
    \ be possible to use a string-keyed hash table instead of the default symbol-keyed\
    \ hash table, by passing <code>equal</code> as the comparison function argument\
    \ to <code>make-hash</code>.\n", "  (and (not (empty? dict))\n       (let ((keys\
    \ (keys dict)))\n         (cond ((not (empty? (keep string? keys)))\n        \
    \        (not (member #\\A (string-&gt;list (car keys)))))\n               ((not\
    \ (empty? (keep string-ci? keys)))\n                (not (member #\\a (string-&gt;list\
    \ (car keys)))))\n               (else #f)))))\n</code>\n", "  (if (null? dict)\n\
    \      #f\n      (let* ([keys (map car dict)]\n             [lower-keys (filter\
    \ string-ci&lt;=? keys)]\n             [upper-keys (filter string-ci&gt;=? keys)])\n\
    \        (or (null? (filter string-ci&lt;=? keys))\n            (null? (filter\
    \ string-ci&gt;=? keys))))))\n", "  (cond ((empty? dict) false)\n        ((andmap\
    \ string-ci=? (keys dict)) true)\n        ((andmap string-ci>? (keys dict)) true)\n\
    \        (else false)))\n", "  (if (empty? dict)\n      #f\n      (check-case-helper\
    \ dict #t)))\n", "  (if (not (dictionary? dict))\n      #f\n      (let loop ([keys\
    \ (dictionary-keys dict)])\n        (cond [(empty? keys) #t]\n              [(and\
    \ (string? (first keys))\n                    (string-upcase? (first keys)))\n\
    \               (loop (rest keys))]\n              [(and (string? (first keys))\n\
    \                    (string-lowercase? (first keys)))\n               (loop (rest\
    \ keys))]\n              [else #f]))))\n", "  (letrec ([is-string-true (lambda\
    \ (lst) (for/and ([x lst]) (string? x)))]\n           [is-upper-true (lambda (lst)\
    \ (for/and ([x lst]) (string-upper-case? x)))]\n           [is-lower-true (lambda\
    \ (lst) (for/and ([x lst]) (string-lower-case? x)))]\n           [is-valid-true\
    \ (lambda (lst) (for/and ([x lst]) (string-valid? x)))]\n           [is-mixed-true\
    \ (lambda (lst) (for/and ([x lst]) (string-mixed-case? x)))]\n           [is-all-valid\
    \ (lambda (dct) (for/and ([x (dict-keys dct)]) (string-valid? x)))]\n        \
    \   [is-all-upper (lambda (dct) (for/and ([x (dict-keys dct)]) (string-upper-case?\
    \ x)))]\n           [is-all-lower (lambda (dct) (for/and ([x (dict-keys dct)])\
    \ (string-lower-case? x)))]\n           [is-all-mixed (lambda (dct) (for/and ([x\
    \ (dict-keys dct)]) (string-mixed-case? x)))]\n           [all-mixed? (lambda\
    \ (lst) (not (or (is-upper-true lst) (is-lower-true lst))))])\n    (cond [(empty?\
    \ dict) #f]\n          [(and (is-all-valid dict) (is-all-upper dict)) #t]\n  \
    \        [(and (is-all-valid dict) (is-all-lower dict)) #t]\n          [(and (is-all-valid\
    \ dict) (is-all-mixed dict)) #f]\n          [else #f])))\n", "  (define (aux-check-dict-case\
    \ dict)\n    (cond\n      ((empty? dict) #t)\n      ((and (string? (first (first\
    \ dict)))\n            (or (string-ci=? (first (first dict)) (first (first dict)))\n\
    \                (string-ci=? (string-upcase (first (first dict))) (first (first\
    \ dict)))))\n       (aux-check-dict-case (rest dict)))\n      (else #f)))\n  (if\
    \ (empty? dict) #f (aux-check-dict-case dict)))\n", "  (check-expect (check_dict_case\
    \ '((\"a\" . 1) (\"b\" . 2))) #t)\n  (check-expect (check_dict_case '((\"a\" .\
    \ 1) (\"B\" . 2))) #f)\n  (check-expect (check_dict_case '((\"a\" . 1) (\"b\"\
    \ . 2) (\"C\" . 3))) #f)\n  (check-expect (check_dict_case '()) #f)\n  (check-expect\
    \ (check_dict_case '((\"A\" . 1) (\"B\" . 2))) #t)\n  (check-expect (check_dict_case\
    \ '((\"A\" . 1) (\"B\" . 2) (\"C\" . 3))) #t)\n  (check-expect (check_dict_case\
    \ '((\"a\" . 1) (\"B\" . 2) (\"C\" . 3))) #f)\n  (define (is_capital str)\n  \
    \  (or (eq? (string-upper-case str) str)\n        (eq? (string-upper-case str)\
    \ (string-titlecase str))))\n  (define (is_lower str)\n    (eq? (string-lower-case\
    \ str) str))\n  (cond\n    [(empty? dict) #f]\n    [(and (is_capital (car (car\
    \ dict)))\n          (andmap is_capital (map car (cdr dict)))) #t]\n    [(and\
    \ (is_lower (car (car dict)))\n          (andmap is_lower (map car (cdr dict))))\
    \ #t]\n    [else #f]))\n</code>\n", "  (cond\n    [(empty? dict) false]\n    [(not\
    \ (string? (key (first dict)))) (check_dict_case (rest dict))]\n    [(eq? (string-upcase\
    \ (key (first dict))) (key (first dict))) \n     (if (not (check_dict_case (rest\
    \ dict)))\n         (if (eq? (string-downcase (key (first dict))) (key (first\
    \ dict)))\n             (check_dict_case (rest dict))\n             false)\n \
    \        true)]\n    [else \n     (if (not (check_dict_case (rest dict)))\n  \
    \       (if (eq? (string-downcase (key (first dict))) (key (first dict)))\n  \
    \           (check_dict_case (rest dict))\n             false)\n         true)]))\n\
    </code>\nCalling this function with the following dictionaries:\n<code>(check_dict_case\
    \ '#hash((a . 1) (b . 2) (c . 3)))", "  (cond\n    [(empty? dict) false]\n   \
    \ [(and (all-string-keys-are-lower-case? dict)\n          (all-string-keys-are-upper-case?\
    \ dict)) false]\n    [(or (all-string-keys-are-lower-case? dict)\n         (all-string-keys-are-upper-case?\
    \ dict)) true]\n    [else false]))\n", "  (and (not (empty? dict))\n       (or\
    \ (andmap symbol-&gt;string? (keys dict))\n           (andmap string-&gt;symbol?\
    \ (keys dict)))))\n", "  (check-dict-case '((a . 1) (b . 2) (c . 3))) ; True\n\
    \  (check-dict-case '((A . 1) (B . 2) (C . 3))) ; True\n  (check-dict-case '((A\
    \ . 1) (B . 2) (C . 3) (d . 4))) ; False\n  (check-dict-case '((A . 1) (b . 2)\
    \ (C . 3) (d . 4))) ; False\n  (check-dict-case '((A . 1) (b . 2) (C . 3) (d .\
    \ 4) (E . 5))) ; False\n  (check-dict-case '((A . 1) (b . 2) (C . 3) (d . 4) (E\
    \ . 5) (f . 6))) ; False\n  (check-dict-case '()) ; False\n  (check-dict-case\
    \ '((1 . 1) (2 . 2) (3 . 3))) ; False\n  (check-dict-case '((1 . 1) (2 . 2) (3\
    \ . 3) (a . 4))) ; False\n  (check-dict-case '((1 . 1) (2 . 2) (3 . 3) (a . 4)\
    \ (5 . 5))) ; False\n  (check-dict-case '((1 . 1) (2 . 2) (3 . 3) (a . 4) (5 .\
    \ 5) (b . 6))) ; False\n  (check-dict-case '((1 . 1) (2 . 2) (3 . 3) (a . 4) (5\
    \ . 5) (b . 6) (7 . 7))) ; False\n  (check-dict-case '((1 . 1) (2 . 2) (3 . 3)\
    \ (a . 4) (5 . 5) (b . 6) (7 . 7) (A . 8))) ; False\n  (check-dict-case '((1 .\
    \ 1) (2 . 2) (3 . 3) (a . 4) (5 . 5) (b . 6) (7 . 7) (A . 8) (B . 9))) ; False\n\
    \  (check-dict-case '((1 . 1) (2 . 2) (3 .", "  (let ((is-lower #t)\n        (is-upper\
    \ #t))\n    (for ((key (in-dict dict)))\n      (if (lower-case? key)\n       \
    \   (set! is-upper #f)\n          (set! is-lower #f)))\n    (or is-lower is-upper)))\n",
  "  (cond\n    [(empty? dict) false]\n    [(and (all-string-in-lowercase-p (first\
    \ dict))\n          (all-string-in-lowercase-p (rest dict))) true]\n    [(and\
    \ (all-string-in-uppercase-p (first dict))\n          (all-string-in-uppercase-p\
    \ (rest dict))) true]\n    [else false]))\n", "  (if (empty? dict)\n      #f\n\
    \      (let* ((keys (map first (alist-&gt;list dict)))\n             (first-key\
    \ (first keys))\n             (all-lower? (andmap string-lower-case? keys))\n\
    \             (all-upper? (andmap string-upper-case? keys)))\n        (if (and\
    \ all-lower? (string-lower-case? first-key))\n            #t\n            (if\
    \ (and all-upper? (string-upper-case? first-key))\n                #t\n      \
    \          #f)))))\n", "  (cond\n    [(empty? dict) false]\n    [(all-lower-case?\
    \ dict) true]\n    [(all-upper-case? dict) true]\n    [else false]))\n", "  (cond\n\
    \    [(empty? dict)\n     #f]\n    [(and (string? (hash-ref dict (hash-keys dict)))\n\
    \          (regexp-match #rx\"[a-z]\" (hash-ref dict (hash-keys dict))))\n   \
    \  (check-dict-case-helper dict '()) #t]\n    [(and (string? (hash-ref dict (hash-keys\
    \ dict)))\n          (regexp-match #rx\"[A-Z]\" (hash-ref dict (hash-keys dict))))\n\
    \     (check-dict-case-helper dict '()) #t]\n    [else\n     #f]))\n", "  (empty?\
    \ dict))\n", "  (match dict\n    ['() #f]\n    [(cons (cons k v) (cons (cons k2\
    \ v2) '()))\n     (match (string-ci=? k k2)\n       #t\n       [(cons k3 v3)\n\
    \        (match (string-ci=? k k3)\n          #t\n          #f)])]\n    [(cons\
    \ (cons k v) (cons (cons k2 v2) rest))\n     (match (string-ci=? k k2)\n     \
    \  #t\n       [(cons k3 v3)\n        (match (string-ci=? k k3)\n          #t\n\
    \          #f)])]))\n</code>\nJust not sure how to continue the logic with pattern\
    \ matching...\n\n\nA:\n\nLet's try a more step-by-step approach:\n<code>(define\
    \ (check-dict-case d)\n  (or (empty? d)\n      (and (equal? #\\lower (dict-case\
    \ d))\n           (every check-dict-case (map dict-case (cdr d))))))\n", "  (cond\n\
    \    [(empty? dict) #f]\n    [(and (not (empty? (get-lower-keys dict)))\n    \
    \      (not (empty? (get-upper-keys dict)))) #f]\n    [else #t]))\n", "  (let\
    \ ([lc (equal? (car (keys dict)) (string-downcase (car (keys dict))))])\n    (cond\n\
    \      [(empty? dict) false]\n      [(not (every? (lambda (x) (equal? x lc)) (map\
    \ (lambda (x) (equal? x (string-downcase x))) (keys dict)))) false]\n      [else\
    \ true])))\n</code>\n", "  (empty? dict))\n</code>\nIf I run this on DrRacket\
    \ I get the following output:\n<code>&gt; (check_dict_case '((\"A\" 1) (\"B\"\
    \ 2)))\n#f\n</code>\nWhich seems to work. But when I do the same on Coderbyte\
    \ I get the following output:\n<code>{msg: \"No Error\", result: null}\n</code>\n\
    I'm not sure what's wrong. I don't think I'm using an Racket-specific function.\
    \ Any idea?\n\n\nA:\n\nCoderbyte expects you to return <code>true</code> or <code>false</code>,\
    \ and not <code>#t</code> or <code>#f</code>.  This is a simple fix: just replace\
    \ all instances of <code>#t</code> with <code>true</code> and all instances of\
    \ <code>#f</code> with <code>false</code>.\n", "  (cond\n    [(empty? dict) false]\n\
    \    [(equal? (string-locale-ci? (car (first dict))) \n             (string-locale-ci?\
    \ (car (first (rest dict)))))\n     (check_dict_case (rest dict))]\n    [else\
    \ false]))\n", "  (define (same-case? x y)\n    (cond [(and (string? x) (string?\
    \ y))\n           (and (= (char-ci&gt;=? (string-ref x 0) #\\a)\n            \
    \       (char-ci&gt;=? (string-ref y 0) #\\a))\n                (= (char-ci&gt;=?\
    \ (string-ref x 0) #\\A)\n                   (char-ci&gt;=? (string-ref y 0) #\\\
    A)))]\n          [else false]))\n  (define (same-case?-keys dict)\n    (cond [(empty?\
    \ dict) true]\n          [(and (same-case? (first (keys dict)) (second (keys dict)))\n\
    \                (same-case?-keys (cdr (keys dict))))]\n          [else false]))\n\
    \  (if (empty? dict)\n      false\n      (same-case?-keys dict)))\n", "  (if (equal?\
    \ (map (lambda (x) (if (string? x) (string-ci=? x x) #f)) (hash-keys dict))\n\
    \               (list #t))\n      #t\n      #f))", "  (and\n   (not (empty? dict))\n\
    \   (every key-is-lower? dict)))\n", "  (cond [(empty? dict) false]\n        [(or\
    \ (andmap string-ci=? (keys dict))\n             (andmap string-ci=? (keys dict)\
    \ #\\a #\\Z))\n         true]\n        [else false]))\n", "  (and\n   (not (empty?\
    \ dict))\n   (or (every string-lowercase? (keys dict))\n       (every string-uppercase?\
    \ (keys dict)))))\n", "  (cond\n    [(empty? dict) #f]\n    [(or (string-upper-case?\
    \ (dict-ref dict (first (dict-keys dict))))\n         (string-lower-case? (dict-ref\
    \ dict (first (dict-keys dict)))))\n     (and (check_dict_case (dict-remove dict\
    \ (first (dict-keys dict))))\n          (not (or (string-upper-case? (dict-ref\
    \ dict (first (dict-keys dict))))\n                   (string-lower-case? (dict-ref\
    \ dict (first (dict-keys dict)))))))]\n    [else #f]))\n", "  (cond [(empty? dict)\
    \ #f]\n        [(and (equal? (string-upper-case (dict-ref dict (first (dict-keys\
    \ dict))))\n                      (dict-ref dict (first (dict-keys dict))))\n\
    \              (check_dict_case (dict-remove (first (dict-keys dict)) dict)))\
    \ #t]\n        [(and (equal? (string-lower-case (dict-ref dict (first (dict-keys\
    \ dict))))\n                      (dict-ref dict (first (dict-keys dict))))\n\
    \              (check_dict_case (dict-remove (first (dict-keys dict)) dict)))\
    \ #t]\n        [else #f]))\n", "  (cond\n    [(empty? dict) #f]\n    [(string-ci=?\
    \ (symbol->string (car (dict-ref dict (car (dict-keys dict)))))\n            \
    \      (symbol->string (car (dict-ref dict (car (dict-keys dict))))))\n     (check_dict_case\
    \ (dict-rest dict))]\n    [else #f]))\n</code>\ni think this is right, but i can't\
    \ get any more points for this. What's wrong?\n\n\nA:\n\nYour solution is almost\
    \ right, you only need to check if all keys have the same case.\n<code>(define\
    \ (check-dict-case dict)\n  (cond\n    [(empty? dict) #f]\n    [(for/and ([k (in-dict\
    \ dict)])\n       (string-ci=? (symbol-&gt;string (car k))\n                 \
    \   (symbol-&gt;string (car (dict-ref dict (car k))))))\n     #t]\n    [else #f]))\n\
    </code>\n", "  (if (not (empty? dict))\n      (let loop ((keyls (keys dict)) (flag\
    \ 0))\n        (cond\n          ((empty? keyls)\n           (cond\n          \
    \   ((= flag 0) #t)\n             ((= flag 1) #f)\n             ((= flag 2) #f)))\n\
    \          ((string-lower-case? (car keyls))\n           (loop (cdr keyls) (add1\
    \ flag)))\n          ((string-upper-case? (car keyls))\n           (loop (cdr\
    \ keyls) (add1 flag)))\n          (else #f)))\n      #f))\n", "  (cond\n    [(null?\
    \ dict)\n     #f]\n    [(and (string? (car (car dict)))\n          (string-ci=?\
    \ (car (car dict)) (car (car dict))))\n     (check_dict_case (cdr dict))]\n  \
    \  [else\n     #f]))\n", "  (define (loop dict)\n    (if (null? dict)\n      \
    \  #t\n        (let ([key (car (car dict))]\n              [value (cdr (car dict))])\n\
    \          (if (and (or (string-ci=? key \"upper\")\n                       (string-ci=?\
    \ key \"lower\"))\n                   (or (and (string-ci=? key \"upper\")\n \
    \                           (symbol? value))\n                       (and (string-ci=?\
    \ key \"lower\")\n                            (string? value))))\n           \
    \   (loop (cdr dict))\n              #f))))\n  (loop dict))\n", "  (cond\n   \
    \ [(empty? dict) false]\n    [(string-upcase? (string-downcase? (dict-ref dict\
    \ \"a\"))) true]\n    [else false]))\n</code>\nI get the error:\n<code>dict-ref:\
    \ expects type &lt;dict&gt; as 1st argument, given: #f; other arguments were:\
    \ \"a\"\n</code>\nSo <code>empty?</code> is returning <code>false</code> before\
    \ <code>dict-ref</code> is called.\n\n\nA:\n\nThe function <code>dict-ref</code>\
    \ does not accept the <code>false</code> value, as it expects a <code>dict</code>\
    \ (short for <code>dictionary</code>) as first argument. You can try this in the\
    \ REPL:\n<code>&gt; (dict-ref false \"a\")\ndict-ref: expects type &lt;dict&gt;\
    \ as 1st argument, given: #f; other arguments were: \"a\"\n</code>\nYou have to\
    \ fix your code to make sure the first argument to <code>dict-ref</code> is always\
    \ a <code>dict</code>. First, remove the check against <code>false</code> in <code>check_dict_case</code>,\
    \ and then fix your problem so that it never gets called with a <code>false</code>\
    \ value as argument.\n<code>(define (check_dict_case dict)\n  (cond\n    [(string-upcase?\
    \ (string-downcase? (dict-ref dict \"a\"))) true]\n    [else false]))\n</code>\n\
    The following is one possible way to fix your code, and will always return <code>true</code>\
    \ if the <code>dict</code> is empty:\n<code>(define (check_dict_case dict)\n \
    \ (and (not (empty? dict))\n       (string-upcase? (string-downcase? (dict-ref\
    \ dict \"a\")))))\n</code>\n", "  (cond\n    [(empty? dict) #f]\n    [(string-ci=?\
    \ (string-upcase (car (car dict))) (car (car dict)))\n     (if (check_dict_case\
    \ (cdr dict))\n         #t\n         #f)]\n    [(string-ci=? (string-downcase\
    \ (car (car dict))) (car (car dict)))\n     (if (check_dict_case (cdr dict))\n\
    \         #t\n         #f)]\n    [else #f]))\n", "  (cond [(empty? dict) #f]\n\
    \        [(and (string? (car (keys dict)))\n              (string? (car (keys\
    \ (cdr dict)))))\n         (and (lower-case? (car (keys dict)))\n            \
    \  (lower-case? (car (keys (cdr dict)))))\n         (and (upper-case? (car (keys\
    \ dict)))\n              (upper-case? (car (keys (cdr dict)))))\n         ]\n\
    \        [else #f]))\n", "  (if (null? dict)\n      #f\n      (cond [(string?\
    \ (first (first dict))) (if (string=? (string-upper-case (first (first dict)))\
    \ (first (first dict)))\n                                               (check_dict_case\
    \ (rest dict))\n                                               #f)]\n        \
    \    [(string? (first (first dict))) (if (string=? (string-lower-case (first (first\
    \ dict))) (first (first dict)))\n                                            \
    \   (check_dict_case (rest dict))\n                                          \
    \     #f)]\n            [else #f])))\n</code>\nWhen I run this code the program\
    \ always returns <code>#f</code>.\n\n\nA:\n\nI think the problem is in your <code>cond</code>.\
    \ Notice how the first and second clauses are the same. That means that if the\
    \ first condition is met, the second condition will not be checked.\nThe first\
    \ condition is: <code>(string? (first (first dict)))</code>.\nThe second condition\
    \ is: <code>(string? (first (first dict)))</code>.\nTherefore, if the first condition\
    \ is true, the second condition is not checked.\nYou may want to use the <code>or</code>\
    \ keyword, or rewrite your code so that this isn't an issue.\n", "  (match dict\n\
    \    ['() #f]\n    [(cons [k v] d)\n     (define (check-case-key k)\n       (string-ci=?\
    \ (string-downcase k) k))\n     (if (all check-case-key (keys dict))\n       \
    \  #t\n         (all check-case-key (keys dict)))]))\n</code>\nResult:\n<code>check_dict_case\
    \ '(())", "  (match dict\n    [(list)\n     #f]\n    [(list (cons key val) rest\
    \ ...)\n     (if (and (string? key)\n              (or (string-downcase? key)\n\
    \                  (string-upcase? key)))\n         (check-dict-case rest)\n \
    \        #f)]))\n</code>\nbut I am getting a compile error: <code>expected: (cons\
    \ key val) in: rest ...</code>\nAnyone know what I'm doing wrong?\n\n\nA:\n\n\
    The problem is here:\n<code>(define (check_dict_case dict)\n  (match dict\n  \
    \  [(list)\n     #f]\n    [(list (cons key val) rest ...)\n     (if (and (string?\
    \ key)\n              (or (string-downcase? key)\n                  (string-upcase?\
    \ key)))\n         (check-dict-case rest)\n         #f)]))\n</code>\nYou're trying\
    \ to match the pattern <code>(cons key val)</code> (a single pair) with <code>rest\
    \ ...</code> (which is a list of pairs). Those two will never match, not even\
    \ in an empty list.\nAnother problem is that you're trying to use <code>if</code>\
    \ in a pattern:\n<code>(if (and (string? key)\n         (or (string-downcase?\
    \ key)\n             (string-upcase? key)))\n    (check-dict-case rest)\n    #f)\n\
    </code>\nI'm not sure what you were trying to achieve, but that's not possible.\
    \ The <code>if</code> form needs to go to the right of the <code>=&gt;</code>\
    \ arrow.\nThe solution is to write this conditionally like this:\n<code>(define\
    \ (check_dict_case dict)\n  (match dict\n    [(list) #f]\n    [(list (cons key\
    \ val) rest ...)\n     (cond [(and (string? key)\n                 (or (string-downcase?\
    \ key)\n                     (string-upcase? key)))\n            (check-dict-case\
    \ rest)]\n           [else #f])]))\n</code>\n", "  (define (all-keys-are-upper-case?\
    \ dict)\n    (every? symbol? (hash-keys dict)))\n  (define (all-keys-are-lower-case?\
    \ dict)\n    (every? string? (hash-keys dict)))\n  (define (all-keys-are-p? dict\
    \ pred)\n    (and\n     (not (empty? dict))\n     (pred dict)))\n  (or\n   (all-keys-are-p?\
    \ dict all-keys-are-upper-case?)\n   (all-keys-are-p? dict all-keys-are-lower-case?)))\n\
    </code>\nIt does what it says on the tin, but is it idiomatic?\n\n\nA:\n\n<code>hash-keys</code>\
    \ returns a vector.  <code>empty?</code> can be applied to vectors, but you don't\
    \ want to do that.  You want to do something like:\n<code>(define (check-dict-case\
    \ dict)\n  (define (all-keys-are-upper-case? dict)\n    (every? symbol? (hash-keys\
    \ dict)))\n  (define (all-keys-are-lower-case? dict)\n    (every? string? (hash-keys\
    \ dict)))\n  (define (all-keys-are-p? dict pred)\n    (and\n     (hash-keys dict)\n\
    \     (pred dict)))\n  (or\n   (all-keys-are-p? dict all-keys-are-upper-case?)\n\
    \   (all-keys-are-p? dict all-keys-are-lower-case?)))\n</code>\nAlso, notice that\
    \ I renamed your function from <code>check_dict_case</code> to <code>check-dict-case</code>.\
    \  The convention in Racket is to use dashes for word separation.\nThat still\
    \ doesn't really do what you want.  I think what you really want is:\n<code>(define\
    \ (check-dict-case dict)\n  (define (all-keys-are-upper-case? dict)\n    (every?\
    \ symbol? (hash-keys dict)))\n  (define (all-keys-are-lower-case? dict)\n    (every?\
    \ string? (hash", "  (if (equal? dict empty) #f\n      (if (andmap symbol? (keys\
    \ dict)) #t\n          (if (andmap string? (keys dict))\n              (or (equal?\
    \ (string-upcase (first (keys dict))) (first (keys dict)))\n                 \
    \ (equal? (string-downcase (first (keys dict))) (first (keys dict))))\n      \
    \        #f))))\n</code>\nFor example:\n<code> &gt; (check_dict_case '#hash((THIS\
    \ . \"THIS\") (this . \"this\")))\n &gt; #t\n &gt; (check_dict_case '#hash((This\
    \ . \"This\") (this . \"this\")))\n &gt; #f\n &gt; (check_dict_case '#hash((This\
    \ . \"This\") (this . \"this\") (THIS . \"THIS\")))\n &gt; #f\n &gt; (check_dict_case\
    \ '#hash((1 . \"a\") (2 . \"b\")))\n &gt; #f\n &gt; (check_dict_case '#hash((1\
    \ . \"a\") (2 . \"b\") (3 . \"c\")))\n &gt; #f\n &gt; (check_dict_case '#hash((This\
    \ . \"This\") (this . \"this\") (THIS . \"THIS\") (1 . \"a\") (2 . \"b\") (3 .\
    \ \"c\")))\n &gt; #f\n &gt; (check_dict_case '#hash())\n &gt; #f\n</code>\nCheers!\n\
    \n\nA:\n\nThis is what I came up with:\n<code>(define (check-dict-case dict)\n\
    \  (define (is-symbol? obj)\n    (and (not (equal? '() obj))\n         (symbol?\
    \ obj)))\n  (define (is-uppercase-string? str)\n    (equal? (upcase str) str))\n\
    \  (define (is-lowercase-string? str)\n    (equal? (downcase str) str))\n  (and\
    \ (not (empty? dict))\n       (or (every is-symbol? (keys dict))\n           (and\
    \ (every is-uppercase-string? (", "  (cond\n    [(not (dict? dict)) #f]\n    [(empty?\
    \ dict) #f]\n    [(andmap \n       (lambda (x) \n         (and (string? x) (string-lowercase?\
    \ x))) \n       (dict-keys dict)) #t]\n    [(andmap \n       (lambda (x) \n  \
    \       (and (string? x) (string-uppercase? x))) \n       (dict-keys dict)) #t]\n\
    \    [else #f]))\n", "  (define (is_all_upper? dict)\n    (cond ((null? dict)\
    \ #t)\n          ((and (string? (car (car dict)))\n                (string-ci=?\
    \ (car (car dict)) (car (car dict))))\n           (is_all_upper? (cdr dict)))\n\
    \          (else #f)))\n  (define (is_all_lower? dict)\n    (cond ((null? dict)\
    \ #t)\n          ((and (string? (car (car dict)))\n                (string-ci=?\
    \ (car (car dict)) (car (car dict))))\n           (is_all_lower? (cdr dict)))\n\
    \          (else #f)))\n  (cond ((or (null? dict) (eq? dict '())) #f)\n      \
    \  ((is_all_upper? dict) #t)\n        ((is_all_lower? dict) #t)\n        (else\
    \ #f)))\n", "  (define (check-string str)\n    (or (string-ci=? str (string-upcase\
    \ str))\n        (string-ci=? str (string-downcase str))))\n  (cond [(empty? dict)\
    \ #f]\n        [(check-string (first (keys dict))) (check_dict_case (rest dict))]\n\
    \        [else #f]))\n</code>\n", "  (or (all-key-strings-upper dict)\n      (all-key-strings-lower\
    \ dict)))\n", "  (cond\n    [(empty? dict) false]\n    [(equal? (map (lambda (x)\
    \ (string-upcase x)) \n                  (keys dict)) \n             (keys dict))\n\
    \     true]\n    [(equal? (map (lambda (x) (string-downcase x)) \n           \
    \       (keys dict)) \n             (keys dict))\n     true]\n    [else false]))\n",
  "  (if (empty? dict) #f\n      (cond\n        [(and (symbol? (first (keys dict)))\n\
    \              (string-ci=? (symbol->string (first (keys dict)))\n           \
    \                (string-upcase (symbol->string (first (keys dict))))))\n    \
    \     (and (string? (first (keys dict)))\n              (string-ci=? (first (keys\
    \ dict))\n                           (string-upcase (first (keys dict)))))\n \
    \        (check_dict_case (rest dict))]\n        [(and (symbol? (first (keys dict)))\n\
    \              (string-ci=? (symbol->string (first (keys dict)))\n           \
    \                (string-downcase (symbol->string (first (keys dict))))))\n  \
    \       (and (string? (first (keys dict)))\n              (string-ci=? (first\
    \ (keys dict))\n                           (string-downcase (first (keys dict)))))\n\
    \         (check_dict_case (rest dict))]\n        [else #f])))\n", "  (if (null?\
    \ dict)\n      #f\n      (let ([k (car (keys dict))])\n        (if (null? (rest\
    \ (keys dict)))\n            (string-titlecase? k)\n            (if (string-upper-case?\
    \ k)\n                (andmap string-upper-case? (keys dict))\n              \
    \  (andmap string-lower-case? (keys dict)))))))\n", "  (check-dict-case dict))\n",
  "  (let ((lower-count 0)\n        (upper-count 0))\n    (for ((key (in-list (hash-keys\
    \ dict))))\n      (cond ((string-ci=? key key)\n             (set! lower-count\
    \ (+ lower-count 1)))\n            ((string-ci=? key (string-upcase key))\n  \
    \           (set! upper-count (+ upper-count 1))))\n      (hash-count dict))))\n\
    </code>\nHowever, I have encountered some errors:\n<code>hash.rkt:23:5: hash-count:\
    \ contract violation\n  expected: hash?\n  given: '#(struct:hash (mutable) (immutable)\
    \ (equal?) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (immutable) (immutable)\
    \ (immutable) (immutable) (immutable) (immutable) (immutable) (imm", "  (cond\n\
    \    [(empty? dict) #f]\n    [(not (string? (first (keys dict)))) #f]\n    [(and\
    \ (not (string-ci=? (first (keys dict)) (first (keys dict))))\n          (not\
    \ (string-ci=? (first (keys dict)) (string-downcase (first (keys dict))))))\n\
    \          #f]\n    [else (check_dict_case (rest dict))]))\n</code>\nWith your\
    \ test data, the output is:\n<code>&gt; (check_dict_case dict1)\n#f\n&gt; (check_dict_case\
    \ dict2)\n#t\n&gt; (check_dict_case dict3)\n#f\n&gt; (check_dict_case dict4)\n\
    #f\n&gt; (check_dict_case dict5)\n#f\n&gt; (check_dict_case dict6)\n#f\n&gt; (check_dict_case\
    \ dict7)\n#f\n&gt; (check_dict_case dict8)\n#f\n&gt; (check_dict_case dict9)\n\
    #f\n&gt; (check_dict_case dict10)\n#f\n&gt; (check_dict_case dict11)\n#f\n&gt;\
    \ (check_dict_case dict12)\n#f\n&gt; (check_dict_case dict13)\n#f\n&gt; (check_dict_case\
    \ dict14)\n#f\n&gt; (check_dict_case dict15)\n#f\n&gt; (check_dict_case dict16)\n\
    #f\n&gt; (check_dict_case dict17)\n#f\n&gt; (check_dict_case dict18)\n#f\n&gt;\
    \ (check_dict_case dict19)\n#f\n&gt; (check_dict_case dict20)\n#f\n&gt; (check_dict_case\
    \ dict21)\n#f\n&gt; (check_dict_case dict22)\n#f\n&gt; (check_dict_case dict23)\n\
    #f\n&gt; (check_dict_case dict24)\n#f\n&gt; (check_dict", "  (match dict\n   \
    \ [(list) #f]\n    [(list (list s v))\n     (if (and (char-upper-case? (string-ref\
    \ s 0))\n              (every char-upper-case? (string->list s)))\n         (if\
    \ (and (not (char-upper-case? (string-ref (caar (cdr dict)) 0)))\n           \
    \       (every char-lower-case? (string->list (caar (cdr dict)))))\n         \
    \    #t\n             #f)\n         (if (and (not (char-lower-case? (string-ref\
    \ (caar (cdr dict)) 0)))\n                  (every char-upper-case? (string->list\
    \ (caar (cdr dict)))))\n             #t\n             #f))]\n    [(list (list\
    \ (string-upper-case s) v) ...) #t]\n    [(list (list (string-lower-case s) v)\
    \ ...) #t]))\n</code>\nE.g.\n<code>&gt; (check_dict_case '((a 1) (b 2)))\n#t\n\
    &gt; (check_dict_case '((A 1) (b 2)))\n#f\n&gt; (check_dict_case '((A 1) (B 2)))\n\
    #t\n&gt; (check_dict_case '((A 1) (B 2) (C 3)))\n#t\n&gt; (check_dict_case '((A\
    \ 1) (B 2) (C 3) (d 4)))\n#f\n&gt; (check_dict_case '((A 1) (B 2) (c 3) (d 4)))\n\
    #f\n&gt; (check_dict_case '((a 1) (B 2) (c 3) (d 4)))\n#f\n&gt; (check_dict_case\
    \ '((a 1) (b 2) (c 3) (d 4)))\n#t\n&gt; (check_dict_case '())\n#f\n</code>\nNote\
    \ that your question was not too clear, it is not clear whether you wanted to\
    \ return a boolean or a string, or whether the order of the keys matters or not,\
    \ or whether the dictionary should be a list of", "  (define (check_dict_case_helper\
    \ dict)\n    (if (empty? dict)\n        (list #t #t)\n        (let* ([key (car\
    \ (first dict))]\n               [upper (string-upper-case? key)]\n          \
    \     [lower (string-lower-case? key)])\n          (if (or (not upper) (not lower))\n\
    \              (list #f #f)\n              (let* ([rest-results (check_dict_case_helper\
    \ (rest dict))]\n                     [all-upper (car rest-results)]\n       \
    \              [all-lower (cadr rest-results)])\n                (if (and all-upper\
    \ upper)\n                    (list #t #f)\n                    (if (and all-lower\
    \ lower)\n                        (list #f #t)\n                        (list\
    \ #f #f))))))))\n  (let* ([case-results (check_dict_case_helper dict)])\n    (and\
    \ (not (empty? dict))\n         (or (car case-results)\n             (cadr case-results)))))\n",
  "  (cond\n    [(empty? dict) #f]\n    [(or (every symbol? (keys dict))\n       \
    \  (every string? (keys dict))) #t]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ dict) false]\n    [(and (string-ci=? (car (dict-keys dict))\n              \
    \         (car (dict-keys dict)))\n          (string-ci=? (car (dict-keys dict))\n\
    \                       (cadr (dict-keys dict))))\n     (check_dict_case (dict-rest\
    \ dict))]\n    [else false]))", "  (if (empty? dict)\n      #f\n      (case (map\
    \ (\u03BB (x) (andmap (\u03BB (y) (and (char-alphabetic? y)\n                \
    \                             (char-lower-case? y))) x)) dict)\n        ((#t)\
    \ #t)\n        ((#f) (andmap (\u03BB (x) (andmap (\u03BB (y) (and (char-alphabetic?\
    \ y)\n                                                 (char-upper-case? y)))\
    \ x)) dict))\n        (else #f))))\n", "  (cond\n    [(empty? dict) false]\n \
    \   [(and (string? (car (keys dict)))\n          (string? (car (keys (cdr dict)))))\n\
    \     (or (= (count (keys dict) (lambda (x) (string-locale-ci=? x x)))\n     \
    \       (count (keys dict) (lambda (x) (string-locale-ci=? x x))))\n         (=\
    \ (count (keys dict) (lambda (x) (string-locale-ci=? x x)))\n            (count\
    \ (keys dict) (lambda (x) (string-locale-ci=? x x)))))\n     ]\n    [else false]))\n",
  "  (if (empty? dict)\n      false\n      (let ([cases (map (lambda (e) (if (string?\
    \ (car e))\n                                       (string-upper-case? (car e))\n\
    \                                       false))\n                        dict)])\n\
    \        (if (equal? cases (make-list (length cases) (car cases)))\n         \
    \   (car cases)\n            false))))\n", "  (and (not (empty? dict)) \n    \
    \   (or (andmap string-lower-case? (keys dict))\n           (andmap string-upper-case?\
    \ (keys dict)))))\n</code>\n", "  (if (empty? dict) false\n      (check-keys-case\
    \ 'lower-case (first dict) (check-keys-case 'upper-case (first dict) true))))\n",
  "  (cond ((empty? dict) #f)\n        ((string? (car (keys dict))) #t)\n        (else\
    \ #f)))\n", "  (let ([lower? #f]\n        [upper? #f])\n    (for ([(k v) dict])\n\
    \      (if (string? k)\n          (let ([upper-case? (string-upper-case? k)])\n\
    \            (if upper-case?\n                (set! upper? #t)\n             \
    \   (set! lower? #t)))\n          (set! lower? #t))\n      (if lower?\n      \
    \    (if upper?\n              #f\n              #t)\n          #f))\n    ))\n\
    </code>\nI get a <code>contract violation</code> error on the line of <code>(string-upper-case?\
    \ k)</code> with the following error message:\n<code>string-upper-case?: contract\
    \ violation\n  expected: string?\n  given: \"1\"\n  contract from: &lt;pkgs&gt;/racket-lib/racket/private/more-scheme.rkt\n\
    \  blaming: top-level (possibly directly)\n  at: &lt;pkgs&gt;/racket-lib/racket/private/map.rkt\n\
    \  contract from: &lt;pkgs&gt;/racket-lib/racket/private/map.rkt\n  blaming: top-level\
    \ (possibly directly)\n  at: &lt;pkgs&gt;/racket-lib/racket/private/more-scheme.rkt\n\
    \  contract from: &lt;pkgs&gt;/racket-lib/racket/private/more-scheme.rkt\n  blaming:\
    \ /tmp/main.rkt\n  at: &lt;pkgs&gt;/racket-lib/racket/private/more-scheme.rkt\n\
    \  contract from: /tmp/main.rkt\n  blaming: /tmp/main.rkt\n  at: /tmp/main.rkt:22.0\n\
    </code>\nNot sure what I am doing wrong.\n\n\nA:\n\nI'm not sure what the problem\
    \ you're having is, but I don't think you need to be so clever. Just loop over\
    \ the keys and test their type.\n<code>(define (check-dict-case dict)\n  (and\
    \ (not (empty?", "  (define (subset s k)\n    (cond [(empty? s) #t]\n        \
    \  [(member (first s) k) (subset (rest s) k)]\n          [else #f]))\n  (define\
    \ lower-case (apply string-downcase (map symbol->string (dict-keys dict))))\n\
    \  (define upper-case (apply string-upcase (map symbol->string (dict-keys dict))))\n\
    \  (or (subset (dict-keys dict) lower-case)\n      (subset (dict-keys dict) upper-case)))\n\
    ```\n\n```\n#lang racket\n", "  (if (empty? dict)\n      #f\n      (let ([first-key\
    \ (first-key dict)])\n        (if (and (string? first-key) (string-lower-case?\
    \ first-key))\n            (if (string-lower-case? first-key)\n              \
    \  (check-lower-dict dict)\n                (check-upper-dict dict))\n       \
    \     #f))))\n", "  (if (empty? dict)\n      #f\n      (let ([case (symbol-&gt;string\
    \ (string-&gt;symbol (regexp-match \"[a-zA-Z]+\" (car (car dict)))))]\n      \
    \      [results (map (lambda (key)\n                            (if (regexp-match\
    \ case (car key))\n                                #t\n                      \
    \          #f))\n                          dict)])\n        (if (equal? (apply\
    \ and results) #t)\n            #t\n            #f))))\n</code>\nFor example:\n\
    <code>&gt; (check-dict-case '((a . \"\") (b . \"\")))\n#t\n&gt; (check-dict-case\
    \ '((a . \"\") (B . \"\")))\n#f\n&gt; (check-dict-case '((a . \"\") (B . \"\"\
    ) (c . \"\")))\n#f\n&gt; (check-dict-case '((A . \"\") (B . \"\")))\n#t\n&gt;\
    \ (check-dict-case '((A . \"\") (B . \"\") (C . \"\")))\n#t\n&gt; (check-dict-case\
    \ '((A . \"\") (B . \"\") (c . \"\")))\n#f\n&gt; (check-dict-case '((A . \"\"\
    ) (b . \"\") (C . \"\")))\n#f\n&gt; (check-dict-case '((A . \"\") (b . \"\") (c\
    \ . \"\")))\n#f\n&gt; (check-dict-case '())\n#f\n</code>\n", "  (let loop ([dict\
    \ dict] [count 0])\n    (if (empty? dict)\n        (if (= count 0)\n         \
    \   #f\n            (= count (/ count 2)))\n        (if (symbol? (key dict))\n\
    \            (loop (rest dict) (+ count 1))\n            (loop (rest dict) (-\
    \ count 1))))))\n</code>\n", "  (cond ((= (length dict) 0) False)\n        ((every?\
    \ (\u03BB (key) (string-ci=? (string-downcase key) key)) (hash-keys dict)) True)\n\
    \        ((every? (\u03BB (key) (string-ci=? (string-upcase key) key)) (hash-keys\
    \ dict)) True)\n        (else False)))\n", "  (and\n   (not (null? dict))\n  \
    \ (not (equal? #f (map (lambda (x) (if (string? (car x)) #t #f)) dict)))\n   (or\n\
    \    (equal? #t (map (lambda (x) (if (symbol? (car x)) #t #f)) dict))\n    (equal?\
    \ #t (map (lambda (x) (if (symbol? (car x)) #t #f)) (map (lambda (x) (string->symbol\
    \ (car x))) dict)))\n   )\n  )\n)\n", "  (cond\n    [(empty? dict) #f]\n    [(not\
    \ (all-keys-upper-case? dict)) #f]\n    [(not (all-keys-lower-case? dict)) #f]\n\
    \    [else #t]))\n", "  (if (empty? dict)\n      #f\n      (let ([a (first dict)])\n\
    \        (cond\n         [(string? (car a))\n          (if (or (every (lambda\
    \ (c) (char-lower-case? c)) (string->list (car a)))\n                  (every\
    \ (lambda (c) (char-upper-case? c)) (string->list (car a))))\n              (check_dict_case\
    \ (rest dict))\n              #f)]\n         [else\n          #f]))))\n", "  (cond\n\
    \    [(empty? dict) #f]\n    [(or (all-lower-case-keys? dict) (all-upper-case-keys?\
    \ dict)) #t]\n    [else #f]))\n", "  (cond\n    ((empty? dict) #f)\n    ((andmap\n\
    \       (lambda (key) (and (string? key) (lower-case? key)))\n       (dict-keys\
    \ dict))\n     #t)\n    ((andmap\n       (lambda (key) (and (string? key) (upper-case?\
    \ key)))\n       (dict-keys dict))\n     #t)\n    (else #f)))\n", "  (case\n \
    \   [(not (dict? dict)) false]\n    [(empty? dict) false]\n    [else\n     (define\
    \ (impl dict)\n       (case\n         [(not (dict? dict)) true]\n         [(empty?\
    \ dict) true]\n         [else\n          (let ([k (key (dict-first dict))]\n \
    \               [v (value (dict-first dict))])\n            (and (string? k)\n\
    \                 (case\n                   [(string-ci=? k (string-downcase k))\n\
    \                    (impl (dict-rest dict))]\n                   [(string-ci=?\
    \ k (string-upcase k))\n                    (impl (dict-rest dict))]\n       \
    \            [else false])))]))\n     (impl dict)]))", "  (define (key-type k)\n\
    \    (cond\n      [(string-ci=? k (string-upcase k)) 'upper]\n      [(string-ci=?\
    \ k (string-downcase k)) 'lower]\n      [else 'mixed]))\n  (cond\n    [(empty?\
    \ dict) #f]\n    [(not (equal? (key-type (car (keys dict)))\n                \
    \  (key-type (car (rest (keys dict)))))) #f]\n    [else (check_dict_case (rest\
    \ dict))]))\n", "  (let ([is-upper? (lambda (x) (string-upper-case? x))])\n  \
    \  (cond [(null? dict) #f]\n          [(foldl (lambda (x y) (and x y)) #t\n  \
    \               (map is-upper? (keys dict))) #t]\n          [(foldl (lambda (x\
    \ y) (and x y)) #t\n                 (map string-lower-case? (keys dict))) #t]\n\
    \          [else #f])))\n</code>\nIf anyone could offer some guidance as to how\
    \ to deal with the examples provided as well as a clear explanation, that would\
    \ be greatly appreciated.\n", "  (or (for/and ([k (in-dict dict)] #:when (string?\
    \ k))\n              (and (string-normalize-nfkc (string-downcase k))\n      \
    \             (string-normalize-nfkc (string-upcase k))))\n      (not (for/and\
    \ ([k (in-dict dict)] #:when (string? k))\n                   (string-normalize-nfkc\
    \ (string-downcase k))))))\n", "  (match dict\n    [(list) false]\n    [(list\
    \ (cons s v) ...)\n     (if (andmap string? (map car (list (cons s v) ...)))\n\
    \       (check-dict-case-list (map car (list (cons s v) ...)))\n       false)]))\n",
  "  (let* ([keys (hash-keys dict)]\n         [last-upper? (char-upper-case? (string-ref\
    \ (vector-ref keys 0) 0))])\n    (if (= (vector-length keys) 0)\n        #f\n\
    \        (for/and ([k keys])\n                  (if (char-upper-case? (string-ref\
    \ k 0))\n                      (equal? last-upper? #t)\n                     \
    \ (equal? last-upper? #f)))\n    )))\n", "  (cond\n    [(empty? dict) #f]\n  \
    \  [(and (string? (first (dict-keys dict)))\n          (string? (first (dict-keys\
    \ dict))))\n     (or\n       (string-ci=? (first (dict-keys dict)) (first (dict-keys\
    \ dict)))\n       (string-ci=? (string-downcase (first (dict-keys dict)))\n  \
    \                   (string-downcase (first (dict-keys dict)))))\n     (check_dict_case\
    \ (dict-rest dict))]\n    [else #f]))\n", "  (match dict\n    ['() #f]\n    [(cons\
    \ (cons k v) '())\n     (or (string-ci=? k (string-downcase k))\n         (string-ci=?\
    \ k (string-upcase k)))]\n    [(cons (cons k v) (cons (cons k2 v2) rest))\n  \
    \   (and (check-dict-case (cons (cons k v) '()))\n          (check-dict-case (cons\
    \ (cons k2 v2) rest)))]))\n</code>\nI get an error message:\n<code>match: not\
    \ a function (check-dict-case\n                          (cons (cons k v)\n  \
    \                              (cons (cons k2 v2) rest))) in: (check-dict-case\n\
    \                                                               (cons (cons k\
    \ v)\n                                                                     (cons\
    \ (cons k2 v2)\n                                                             \
    \              rest)))\n</code>\nWhat am I doing wrong?\n\n\nA:\n\nYou must use\
    \ double quotes in your pattern variables. For instance:\n<code>(define (check-dict-case\
    \ dict)\n  (match dict\n    '()\n    [(cons (cons k v) '())\n     (or (string-ci=?\
    \ k (string-downcase k))\n         (string-ci=? k (string-upcase k)))]\n    [(cons\
    \ (cons \"k\" v) (cons (cons \"k2\" v2) rest))\n     (and (check-dict-case (cons\
    \ (cons \"k\" v) '()))\n          (check-dict-case (cons (cons \"k2\" v2) rest)))]))\n\
    </code>\nOtherwise, the code you posted yields <code>check-dict-case: unbound\
    \ identifier in module in: check-dict-case</code>.\n", "  (let ([keys (hash-keys\
    \ dict)])\n    (and\n     (cond \n       [(empty? keys) #f]\n       [(string?\
    \ (first keys))\n        (andmap string? keys)]\n       [(symbol? (first keys))\n\
    \        (andmap symbol? keys)])\n     (cond \n       [(empty? (rest keys)) #t]\n\
    \       [(string=? (first keys) (second keys))\n        (check_dict_case (rest\
    \ keys))]\n       [else #f]))))\n", "  (if (null? dict)\n      #f\n      (let\
    \ ((first-key (car (dict-keys dict))))\n        (if (string? first-key)\n    \
    \        (if (string-contains first-key #\\Upper)\n                (check-all-upper\
    \ dict)\n                (check-all-lower dict))\n            #f))))\n", "  (cond\n\
    \    [(empty? dict) #f]\n    [(string? (first (keys dict)))\n     (cond\n    \
    \   [(lower-case? (first (keys dict)))\n        (cond\n          [(andmap lower-case?\
    \ (keys dict)) #t]\n          [else #f])]\n       [(upper-case? (first (keys dict)))\n\
    \        (cond\n          [(andmap upper-case? (keys dict)) #t]\n          [else\
    \ #f])])]\n    [else #f]))\n</code>\n", "  (letrec ((case-helper (lambda (case_count\
    \ dict)\n\t\t\t  (if (eq? dict '())\n\t\t\t      (if (eq? case_count 1)\n\t\t\t\
    \t  'True\n\t\t\t\t  'False)\n\t\t\t      (if (string-ci=? (car (car dict)) \n\
    \t\t\t\t\t       (car (car dict)))\n\t\t\t\t  (case-helper (+ case_count 1) (cdr\
    \ dict))\n\t\t\t\t  (case-helper case_count (cdr dict)))))))\n    (case-helper\
    \ 0 dict)))\n", "  (let\n    ([lower-keys-only? (filter (lambda (key) (string-ci=?\
    \ key (string-downcase key))) (hash-keys dict))]\n     [upper-keys-only? (filter\
    \ (lambda (key) (string-ci=? key (string-upcase key))) (hash-keys dict))])\n \
    \   (or (null? (hash-keys dict)) (equal? lower-keys-only? (hash-keys dict)) (equal?\
    \ upper-keys-only? (hash-keys dict)))))\n", "  (if (empty? dict)\n      false\n\
    \      (let ([str-keys (map string-upper-case (map object->string (hash-keys dict)))])\n\
    \        (andmap string=? str-keys (cons (first str-keys) (rest str-keys))))))\n",
  "  (if (empty? dict)\n      #f\n      (let ([keys-lower (map (lambda (key) (string-downcase\
    \ key)) (keys dict))])\n        (cond\n          [(equal? (keys dict) keys-lower)\
    \ #t]\n          [(equal? (keys dict) (map string-upcase (keys dict))) #t]\n \
    \         [else #f]))))\n", "  (if (empty? dict)\n      #f\n      (equal? (lower-case?\
    \ (first (dict-keys dict)))\n              (lower-case? (first (rest (dict-keys\
    \ dict)))))))\n</code>\nI can't figure out the correct syntax for <code>lower-case?</code>\
    \ or <code>upper-case?</code> in this line:\n<code>(equal? (lower-case? (first\
    \ (dict-keys dict)))\n        (lower-case? (first (rest (dict-keys dict)))))\n\
    </code>\nI also can't figure out how to compare two dict-keys in <code>equal?</code>.\n\
    I am not allowed to use <code>and</code> or <code>or</code> in the solution.\n\
    \n\nA:\n\nThe <code>lower-case?</code> and <code>upper-case?</code> procedures\
    \ are written in the docs that you linked to, you just have to have to use them\
    \ like this:\n<code>(define s \"Hello, world!\")", "  (cond\n    [(empty? dict)\
    \ false]\n    [(and (string? (first (first dict))) (and (string-ci=? (first (first\
    \ dict)) (first (first dict)))))]\n    [else false]))\n", "  (if (null? dict)\n\
    \      #f\n      (or (or (map is-lower-case? (map car dict))\n              (map\
    \ is-upper-case? (map car dict)))\n          #f)))\n", "  (and (not (empty? dict))\n\
    \       (or (equal? (map (lambda (x) (symbol-&gt;string (symbol-downcase x)))\
    \ (hash-keys dict)) (hash-keys dict))\n           (equal? (map (lambda (x) (symbol-&gt;string\
    \ (symbol-upcase x))) (hash-keys dict)) (hash-keys dict)))))\n", "  (cond [(empty?\
    \ dict) false]\n        [(all-lower-case? dict) true]\n        [(all-upper-case?\
    \ dict) true]\n        [else false]))\n", "  (let ([all-lower-case? (all-lower-case?\
    \ dict)]\n        [all-upper-case? (all-upper-case? dict)])\n    (or (and all-lower-case?\
    \ (not all-upper-case?))\n        (and all-upper-case? (not all-lower-case?)))))\n",
  "  (if (not (dictionary? dict))\n      false\n      (let loop ([d dict])\n     \
    \   (if (or (null? d) (null? (cdr d)))\n            true\n            (and (and\
    \ (string? (car (car d)))\n                      (or (string-ci=? (car (car d))\
    \ (car (car d)))\n                          (string-ci=? (string-upcase (car (car\
    \ d))) (car (car d)))))\n                 (loop (cdr d)))))))\n</code>\n", " \
    \ (match dict\n    [(cons (cons 'a 'b) (cons (cons 'a 'b) '())) #t]\n    [(cons\
    \ (cons 'A 'b) (cons (cons 'A 'b) '())) #t]\n    [(cons (cons 'a 'b) (cons (cons\
    \ 'A 'b) '())) #f]\n    [(cons (cons 'A 'b) (cons (cons 'a 'b) '())) #f]\n   \
    \ [_ #f]))\n", "  (cond ((empty? dict) #f)\n        ((map (\u03BB (x) (all-lower?\
    \ x)) (keys dict)) #t)\n        ((map (\u03BB (x) (all-upper? x)) (keys dict))\
    \ #t)\n        (else #f)))\n", "  (let ([k-upper (list->set (map symbol->string\
    \ (filter symbol? (keys dict))))]\n        [k-lower (list->set (map string-downcase\
    \ (map symbol->string (filter symbol? (keys dict)))))]\n        [k-equal? (equal?\
    \ k-upper k-lower)])\n    (if (zero? (length dict))\n        #f\n        (if (zero?\
    \ (length (filter not k-equal?)))\n            #t\n            #f))))\n", "  (cond\n\
    \    [(empty? dict) false]\n    [(and (symbol? (key dict))\n          (or (string-lower-case?\
    \ (key dict))\n              (string-upper-case? (key dict))))\n     (check-dict-case\
    \ (dict-rest dict))]\n    [else false]))\n</code>\nBut I am getting this error\
    \ when compiling:\n<code>check-dict-case: unbound identifier in module in: check-dict-case\n\
    </code>\nWhat is wrong with my code?\n\n\nA:\n\nThe problem is the recursive call\
    \ to <code>check-dict-case</code>. You have it in the code as <code>check-dict-case</code>\
    \ (note the lower-case <code>d</code>), while in the function definition you have\
    \ it as <code>check_dict_case</code> (note the underscore). \nChange the recursive\
    \ call so that it matches the name of the function and it should work. \n", " \
    \ (cond\n    [(empty? dict) false]\n    [(and (string? (dict-key dict))\n    \
    \      (check-dict-case/iter (rest dict))) (string-ci=? (dict-key dict) (dict-key\
    \ (rest dict)))]\n    [else false]))\n", "  (cond\n    [(empty? dict) #f]\n  \
    \  [(and (string-locale-ci=? (key (first dict))\n                            \
    \  (key (first dict)))\n          (string-locale-ci=? (key (first dict))\n   \
    \                           (key (first (rest dict)))))\n     (check_dict_case\
    \ (rest dict))]\n    [else #f]))\n", "  (define (helper key-list)\n    (cond\n\
    \      [(null? key-list)  true]\n      [(and (and (string? (car key-list))\n \
    \                (string-ci=? (car key-list) (car key-list)))\n            (helper\
    \ (cdr key-list)))  true]\n      [else false]))\n  (define (is_lower_case key)\n\
    \    (string-ci=? key key))\n  (if (empty? dict)\n      false\n      (if (is_lower_case\
    \ (car (dict-keys dict)))\n          (helper (dict-keys dict))\n          (helper\
    \ (dict-keys dict)))))\n", "  (cond [(empty? dict) #f]\n        [(equal? (map\
    \ (\u03BB (k) (char-upcase k)) (keys dict))\n                 (map (\u03BB (k)\
    \ (char-upcase k)) (keys dict)))\n         #t]\n        [else #f]))\n", "  (or\
    \ (all-string-lower-case? dict)\n      (all-string-upper-case? dict)))\n", " \
    \ (or\n   (every? string-lower-case? (dict-keys dict))\n   (every? string-upper-case?\
    \ (dict-keys dict))))\n</code>\n", "  (if (empty? dict)\n      #f\n      (let\
    \ loop ([lst (keys dict)])\n        (cond [(empty? lst) #t]\n              [(not\
    \ (string? (car lst))) #f]\n              [(and (string-contains-ci? (car lst)\
    \ #\\a #\\z) \n                    (not (string-contains-ci? (car lst) #\\A #\\\
    Z)))\n               (loop (cdr lst))]\n              [(and (string-contains-ci?\
    \ (car lst) #\\A #\\Z) \n                    (not (string-contains-ci? (car lst)\
    \ #\\a #\\z)))\n               (loop (cdr lst))]\n              [else #f]))\n\
    \      ))\n", "  (cond [(empty? dict)\n         #f]\n        [(and (map string-locale-downcase?\
    \ (keys dict))\n              (map string-locale-upcase? (keys dict)))\n     \
    \    #t]\n        [else\n         #f]))\n</code>\nI get this warning:\n<code>map:\
    \ expects type as 2nd argument, given: string?; other arguments were: a\n</code>\n\
    But I cannot figure out why this is happening. \nMy last attempt was:\n<code>#lang\
    \ racket\n", "  (cond [(empty? dict) false]\n        [(andmap string? (map key\
    \ dict))\n         (cond [(every (lambda (key) (string-ci=? key (string-upcase\
    \ key)))\n                    (map key dict))\n                true]\n       \
    \        [(every (lambda (key) (string-ci=? key (string-downcase key)))\n    \
    \                (map key dict))\n                true]\n               [else\
    \ false])]\n        [else false]))\n", "  (cond\n    [(empty? dict) false]\n \
    \   [(or (all-lower-case? dict) (all-upper-case? dict)) true]\n    [else false]))\n",
  "  (if (empty? dict)\n      #f\n      (let ([keys (dict-keys dict)])\n        (if\
    \ (null? keys)\n            #t\n            (let ([str? (string? (car keys))])\n\
    \              (if str?\n                  (and (equal? (string-upper-case (car\
    \ keys)) (car keys))\n                       (check_dict_case (cdr keys)))\n \
    \                 (and (equal? (string-lower-case (car keys)) (car keys))\n  \
    \                     (check_dict_case (cdr keys)))))))))\n", "  (if (empty? dict)\n\
    \      false\n      (if (for/and ([x (in-dict dict)])\n                  (or (symbol?\
    \ (car x)) (string? (car x))))\n          (if (equal? (upper-case (car (first\
    \ (in-dict dict))))\n                      (car (first (in-dict dict))))\n   \
    \           (for/and ([x (in-dict dict)])\n                        (equal? (upper-case\
    \ (car x)) (car x)))\n              (for/and ([x (in-dict dict)])\n          \
    \              (equal? (lower-case (car x)) (car x))))\n          false)))\n",
  "  (cond\n    [(empty? dict) false]\n    [(lower-case? (first (first dict)))\n \
    \    (and (check_dict_case (rest dict))\n          (lower-case? (first (first\
    \ dict))))]\n    [(upper-case? (first (first dict)))\n     (and (check_dict_case\
    \ (rest dict))\n          (upper-case? (first (first dict))))]\n    [else false]))\n",
  "  (if (= (length dict) 0)\n      #f\n      (check-case (car dict) (cdr dict))))\n",
  "  (cond\n    [(empty? dict) false]\n    [(and (string? (key dict)) (string? (next-key\
    \ dict)))\n     (and (check-lower? (key dict)) (check-upper? (next-key dict)))]\n\
    \    [(or (string? (key dict)) (string? (next-key dict)))\n     (or (check-lower?\
    \ (key dict)) (check-upper? (next-key dict)))]\n    [else false]))\n", "  (cond\
    \ [(and (andmap string? (keys dict))\n               (or (andmap string-lower-case?\
    \ (keys dict))\n                   (andmap string-upper-case? (keys dict))))\n\
    \         true]\n        [else false]))\n", "  (cond\n    [(empty? dict) false]\n\
    \    [(equal? (map string-uppercase (keys dict)) (keys dict)) true]\n    [(equal?\
    \ (map string-lowercase (keys dict)) (keys dict)) true]\n    [else false]))\n",
  "  (cond\n    [(empty? dict) #f]\n    [(check-case-helper (first dict)) #t]\n  \
    \  [else #f]))\n", "  (if (empty? dict)\n      #f\n      (let ([c0 (first (first\
    \ dict))])\n        (every? (\u03BB (x) (or (char-lower-case? (first x))\n   \
    \                        (char-upper-case? (first x))))\n                dict))))",
  "  (or (= (length dict) 0)\n      (equal? (vector-map (lambda (key) (type-tag key))\
    \ dict)\n              (vector-map (lambda (key) (type-tag key))\n           \
    \               (apply vector-map (lambda (key val) (string-upcase key)) dict)))))",
  "  (cond [(empty? dict)\n         #f]\n        [(string=? (hash-ref dict (first\
    \ (hash-keys dict)))\n                   (string-downcase (hash-ref dict (first\
    \ (hash-keys dict)))))\n         (check-dict-case (hash-remove dict (first (hash-keys\
    \ dict))))]\n        [(string=? (hash-ref dict (first (hash-keys dict)))\n   \
    \                (string-upcase (hash-ref dict (first (hash-keys dict)))))\n \
    \        (check-dict-case (hash-remove dict (first (hash-keys dict))))]\n    \
    \    [else\n         #f]))\n</code>\nWhen I run this code I get:\n<code>&gt; (check-dict-case\
    \ hash-dict)", "  (if (null? dict)\n      #f\n      (let ((upper? (is-all-upper?\
    \ (map car dict))))\n        (if upper?\n            (is-all-upper? (map car dict))\n\
    \            (is-all-lower? (map car dict))))))\n", "  (cond\n    [(empty? dict)\
    \ false]\n    [(all-strings-lower? dict) true]\n    [(all-strings-upper? dict)\
    \ true]\n    [else false]))\n", "  (if (empty? dict)\n      #f\n      (let ([all-upper\
    \ (for/and ([k (in-dict dict)]) (string-upper-case? k))])\n        (if all-upper\n\
    \            (let ([all-lower (for/and ([k (in-dict dict)]) (string-lower-case?\
    \ k))])\n              (if all-lower\n                  #f\n                 \
    \ all-upper))\n            (let ([all-lower (for/and ([k (in-dict dict)]) (string-lower-case?\
    \ k))])\n              (if all-lower\n                  all-lower\n          \
    \        #f))))))\n</code>\nIs there a way to avoid that 'let', since I know that\
    \ either it will match <code>all-upper</code> or <code>all-lower</code>?\nPS:\
    \ I'm aware of <code>or/c</code> and <code>and/c</code> but it doesn't help in\
    \ this case since I need to return the predicate as <code>#t</code> or <code>#f</code>\n\
    PPS: I'm using <code>for/and</code> and <code>for/or</code> from <code>#lang racket/base</code>\n\
    \n\nA:\n\nI don't see an obvious way to do this without one of these:\n\nIt is\
    \ possible to create the <code>for/and</code> or <code>for/or</code> with <code>for/fold</code>\
    \ or a <code>lambda</code> but it would be much harder to read and maintain.\n\
    You could use a <code>cond</code> statement but you would be repeating almost\
    \ all of the above code and I think this would be easier to read and maintain.\n\
    \nThe problem is that you need to know the match so that you can run the other\
    \ check or return the value.  Since the Racket syntactic binding construct <code>let</code>\
    \ only allows you to declare a single value, you have to use an inner let to do\
    \ this.\n", "  (cond\n    [(empty? dict) #f]\n    [(string-ci=? (symbol->string\
    \ (car (keys dict)))\n                  (symbol->string (car (keys dict))))\n\
    \     (check_dict_case (cdr dict))]\n    [else #f]))\n", "  (and (not (empty?\
    \ dict))\n       (or (andmap symbol? (dict-keys dict))\n           (andmap string?\
    \ (dict-keys dict)))))\n", "  (define keys (dict-keys dict))\n  (define upper?\
    \ (for/first ([key keys])\n                   (string-upper-case? key)))\n  (define\
    \ lower? (for/first ([key keys])\n                   (string-lower-case? key)))\n\
    \  (define empty? (dict-empty? dict))\n  (or (and (not empty?) (or upper? lower?))\n\
    \      (and empty? #t)))\n", "  (let loop ([dict dict] [acc '()])\n    (cond [(dict-empty?\
    \ dict) (or (every-pred char-lower-case? acc) (every-pred char-upper-case? acc))]\n\
    \          [else (loop (dict-rest dict) (cons (symbol->string (dict-first dict))\
    \ acc))])))\n", "  (cond ((empty? dict) #f)\n        ((string? (first dict))\n\
    \         (and (andmap (lambda (k) (string-ci=? k (make-string (string-length\
    \ k) #\\_)))\n                      (dict-keys dict))\n              (check_dict_case\
    \ (rest dict))))\n        (else #f)))\n", "  (and (not (empty? dict))\n      \
    \ (let ([c (car (dict-keys dict))])\n         (and (char-lower-case? c)\n    \
    \          (char-upper-case? c)\n              (check-dict-case (dict-rest dict))))))\n",
  "  (if (empty? dict) #f\n      (for/or ([(k v) dict])\n        (if (string? k)\n\
    \            (string-downcase k)\n            (string-upcase k)))))\n", "  (if\
    \ (empty? dict)\n      #f\n      (cond ((all-lower? (dict-keys dict))\n      \
    \       #t)\n            ((all-upper? (dict-keys dict))\n             #t)\n  \
    \          (else\n             #f))))\n", "  (if (empty? dict)\n      #f\n   \
    \   (let ([k (first (keys dict))])\n        (if (and (string? k)\n           \
    \      (or (string-ci=? (string-downcase k) k)\n                     (string-ci=?\
    \ (string-upcase k) k)))\n            (check-dict-case (rest dict))\n        \
    \    #f))))\n</code>\n\n<code>#lang racket\n", "  (if (= '() dict)\n      #f\n\
    \      (letrec ((keys (keys dict))\n               (counter 0)\n             \
    \  (len (length keys)))\n        (for ([k keys])\n          (if (and (string?\
    \ k)\n                   (or (string-ci=? k (string-upcase k))\n             \
    \          (string-ci=? k (string-downcase k))))\n              (set! counter\
    \ (+ counter 1))\n              (void)))\n        (= counter len))))\n", "  (if\
    \ (empty? dict)\n      #f\n      (let* ([keys (keys dict)]\n             [keys-are-upper?\
    \ (is-every (lambda (key) (string-upper-case? key)) keys)]\n             [keys-are-lower?\
    \ (is-every (lambda (key) (string-lower-case? key)) keys)])\n        (and keys-are-upper?\
    \ (not keys-are-lower?))\n        (and keys-are-lower? (not keys-are-upper?)))))\n\
    </code>\nMy main problem is that I don't know how to create tests in racket. I\
    \ guess it is something like this:\n<code>#lang racket\n", "  (cond [(null? dict)\
    \ #f]\n        [(andmap string? (map car dict))\n         (andmap (\u03BB (x)\
    \ (eq? (string-upcase x) x))\n                 (map car dict))]\n        [(andmap\
    \ string? (map car dict))\n         (andmap (\u03BB (x) (eq? (string-downcase\
    \ x) x))\n                 (map car dict))]\n        [else #f]))\n", "  (let ([keys\
    \ (dict-keys dict)])\n    (and (not (empty? keys))\n         (equal? 'string-ci=\n\
    \                 (let ([first-key (dict-ref dict (first keys))])\n          \
    \         (if (string-ci=? first-key (string-downcase first-key))\n          \
    \             'string-ci=\n                       'string-ci>))\n            \
    \     (map string-downcase keys)))))\n", "  (let ([keys (hash-keys dict)])\n \
    \   (if (empty? keys)\n        #f\n        (let ([examples (list-ref keys 0)])\n\
    \          (cond\n            [(string-lower-case? examples)\n             (hash-every\
    \ string-lower-case? dict)]\n            [(string-upper-case? examples)\n    \
    \         (hash-every string-upper-case? dict)]\n            [else #f])))))\n",
  "  (cond [(null? dict) #f]\n        [(string-ci=? (car (car dict)) (car (car dict)))\n\
    \         (check_dict_case (cdr dict))]\n        [else #f]))\n", "  (cond\n  \
    \  [(empty? dict) false]\n    [(equal? (first (keys dict)) (string-upcase (first\
    \ (keys dict))))\n     (check_dict_case (rest dict))]\n    [(equal? (first (keys\
    \ dict)) (string-downcase (first (keys dict))))\n     (check_dict_case (rest dict))]\n\
    \    [else false]))\n", "  (define (in-lower-case str)\n    (equal? (downcase\
    \ str) str))\n  (define (in-upper-case str)\n    (equal? (upcase str) str))\n\
    \  (cond\n    [(empty? dict) false]\n    [(andmap in-lower-case (dict-keys dict))\
    \ true]\n    [(andmap in-upper-case (dict-keys dict)) true]\n    [else false]))\n",
  "  (and (not (empty? dict))\n       (let check-case ([k (first (dict-keys dict))])\n\
    \         (cond [(string? k)\n                (and (regexp-match? #rx\"[a-z]\"\
    \ k)\n                     (check-case (first (dict-keys (dict-rest dict)))))\n\
    \                ]\n               [(string? k)\n                (and (regexp-match?\
    \ #rx\"[A-Z]\" k)\n                     (check-case (first (dict-keys (dict-rest\
    \ dict)))))\n                ]\n               [else #f]))))\n", "  (let ((elements\
    \ (hash-keys dict)))\n    (if (null? elements) #f\n        (every-pred string-ci&lt;=?\n\
    \                    (compose map string-upcase)\n                    (compose\
    \ map string-downcase))\n        elements)))\n</code>\nAn error is raised by the\
    \ call to <code>map</code> within <code>string-downcase</code>.  I also tried\
    \ wrapping <code>string-downcase</code> within <code>identity</code> to no avail.\n\
    What is the correct way to resolve this error?\n\n\nA:\n\nYou have a few different\
    \ issues:\n\n<code>every-pred</code> takes a list of unary predicates, but you're\
    \ giving it five unary predicates. So it complains that it expected four more\
    \ arguments but only received one. You need to put all five predicates in a list.\n\
    You're trying to give <code>every-pred</code> a list of functions, but <code>compose</code>\
    \ produces just one function, not a list of functions. You need to <code>map</code>\
    \ <code>compose</code> over the list of functions you want to compose.\n<code>string-downcase</code>\
    \ is a string->string function, but you're trying to give it a list of strings.\
    \ You need to use <code>map</code> or similar to apply it to every string.\n<code>string-ci&lt;=?</code>\
    \ is a string->string->boolean function, but you're trying to give it a list of\
    \ strings. You need to use <code>map</code> or similar to apply it to every string.\n\
    \nIf you fix all three of these, it should work:\n<code>(define (check_dict_case\
    \ dict)\n  (let ((elements (hash-keys dict)))\n    (if (null? elements) #f\n \
    \       (every-pred (map (lambda (f) (compose f map))\n                      \
    \   (list string-ci&lt;=?\n                               string-ci&lt;=?\n  \
    \                             string-ci&lt;=?\n                              \
    \ string-ci&lt;=?\n                               string-ci&lt;=?))\n        \
    \            (list (com", "  (cond [(empty? dict) #f]\n        [(all-lower? dict)\
    \ #t]\n        [(all-upper? dict) #t]\n        [else #f]))\n", "  (cond [(empty?\
    \ dict) false]\n        [(equal? (string-upper-case (car (first dict)))\n    \
    \             (car (first dict)))\n         (and (check_dict_case (rest dict))\
    \ true)]\n        [(equal? (string-lower-case (car (first dict)))\n          \
    \       (car (first dict)))\n         (and (check_dict_case (rest dict)) true)]\n\
    \        [else false]))\n", "  (let* ([first_key (car (map dict))]\n         [keys\
    \ (map dict)]\n         [uppers (map string-upcase first_key)]\n         [lowers\
    \ (map string-downcase first_key)])\n    (or (= keys lowers) (= keys uppers))))\n\
    </code>\nI'm using the <code>map</code> function to get a list of the keys in\
    \ <code>dict</code>, and then I'm calling <code>string-upcase</code> and <code>string-downcase</code>\
    \ to see if either of those lists are exactly the same as <code>keys</code>. \n\
    It fails with the error \n<code>check_dict_case: expects argument of type &lt;dict&gt;;\
    \ given {'B': 'b', 'A': 'a'}\n</code>\nWhat is the right way to do this?\n\n\n\
    A:\n\nMap accepts a function as the first argument, not a dictionary. In the repl\
    \ you can call the <code>dict</code> function, which will return a dictionary.\
    \ So you could do something like this\n<code>(define (check_dict_case dict)\n\
    \  (let* ([first_key (car (map dict))]\n         [keys (map dict)]\n         [uppers\
    \ (map string-upcase first_key)]\n         [lowers (map string-downcase first_key)])\n\
    \    (or (= keys lowers) (= keys uppers))))\n", "  (cond\n    [(empty? dict) #f]\n\
    \    [(and (string-upcase? (first (first dict)))\n          (string-upcase? (first\
    \ (first (rest dict)))))\n     (check_dict_case (rest dict))]\n    [(and (string-downcase?\
    \ (first (first dict)))\n          (string-downcase? (first (first (rest dict)))))\n\
    \     (check_dict_case (rest dict))]\n    [else #f]))\n</code>\n\n<code>#lang\
    \ racket\n", "  (if (empty? dict) #f\n      (let ([keys (keys dict)])\n      \
    \  (and (andmap string-lower-case? keys)\n             (andmap string-upper-case?\
    \ keys)))))\n", "  (cond [(empty? dict) #f]\n        [(and (andmap (\u03BB (x)\
    \ (symbol? x)) (dict-keys dict))\n              (andmap (\u03BB (x) (char-upper-case?\
    \ (char-upcase x))) (dict-keys dict)))\n         #t]\n        [(and (andmap (\u03BB\
    \ (x) (symbol? x)) (dict-keys dict))\n              (andmap (\u03BB (x) (char-lower-case?\
    \ (char-downcase x))) (dict-keys dict)))\n         #t]\n        [else #f]))\n",
  "  (cond\n    [(empty? dict) false]\n    [(and (string? (first-key dict))\n    \
    \      (or (char-lower-case? (string-ref (first-key dict) 0))\n              (char-upper-case?\
    \ (string-ref (first-key dict) 0))))\n     (check-dict-case (rest-dict dict))]\n\
    \    [else false]))\n", "  (cond\n    [(empty? dict) false]\n    [(char-numeric?\
    \ (dict-ref dict (dict-first dict)))\n     (check-numeric dict)]\n    [(char-numeric?\
    \ (dict-ref dict (dict-last dict)))\n     (check-numeric dict)]\n    [(check-lower\
    \ dict) true]\n    [(check-upper dict) true]\n    [else false]))\n", "  (let ((string-keys\
    \ (filter string? (hash-keys dict)))\n        (lower-keys (filter (lambda (x)\
    \ (string-downcase x)) string-keys))\n        (upper-keys (filter (lambda (x)\
    \ (string-upcase x)) string-keys)))\n    (or (and string-keys lower-keys)\n  \
    \      (and string-keys upper-keys))))\n", "  (cond\n    [(empty? dict) #f]\n\
    \    [(or (all-lower-case? (keys dict))\n         (all-upper-case? (keys dict)))\
    \ #t]\n    [else #f]))\n", "  (let \n      ([n (hash-count dict)])\n    (cond\n\
    \      [(equal? n 0) #f]\n      [(equal? n (dict-lower-count dict)) #t]\n    \
    \  [(equal? n (dict-upper-count dict)) #t]\n      [else #f])))\n", "  (if (empty?\
    \ dict)\n      #f\n      (cond\n       [(all-dict-keys-in-lower-case? dict) #t]\n\
    \       [(all-dict-keys-in-upper-case? dict) #t]\n       [else #f])))\n", "  (or\
    \ (and (not (empty? dict)) (null? (filter string? (keys dict)))) \n      (and\
    \ (not (empty? dict)) \n           (equal? (filter string-upcase? (keys dict))\
    \ (keys dict)))))", "  (let ([keys (dict-keys dict)])\n    (cond [(empty? keys)\
    \ #f]\n          [(string-ci=? (first keys) (first keys)) #t]\n          [else\
    \ #f])))\n", "  (or\n   (and\n    (apply or (map (\u03BB (k) (string-ci=? k (string-downcase\
    \ k))) (hash-keys dict)))\n    (apply or (map (\u03BB (k) (string-ci=? k (string-upcase\
    \ k))) (hash-keys dict))))\n   (null? dict)))\n", "  (cond ((empty? dict) #f)\n\
    \        ((eq? (string-locale-ci? (list-ref (list-ref dict 0) 0))\n          \
    \    (string-locale-ci? (list-ref (list-ref dict 0) 0)))\n         (check_dict_case\
    \ (rest dict)))\n        (else #f)))\n</code>\nThe function <code>list-ref</code>\
    \ returns the nth element of a list and <code>string-locale-ci?</code> compares\
    \ two strings in a case-insensitive way.\n", "  (case (empty? dict)\n    [#t #f]\n\
    \    [#f\n     (let ([all-down-to-up\n            (andmap (lambda (k) (and (string?\
    \ k) (equal? (string-upcase k) k)))\n                    (hash-keys dict))]\n\
    \            [all-up-to-down\n             (andmap (lambda (k) (and (string? k)\
    \ (equal? (string-downcase k) k)))\n                     (hash-keys dict))])\n\
    \       (or all-down-to-up all-up-to-down))]))\n", "  (cond ((empty? dict) #f)\n\
    \        ((and (map (lambda (key) (string-lowercase? key))\n                 \
    \  (hash-keys dict))\n              (map (lambda (key) (string-uppercase? key))\n\
    \                   (hash-keys dict)))\n         #t)\n        (else #f)))\n",
  "  (if (empty? dict)\n      #f\n      (let ([keys (keys dict)])\n        (andmap\
    \ (\u03BB (k) (and (string? k)\n                            (or (string-ci=? k\
    \ (string-upcase k))\n                                (string-ci=? k (string-downcase\
    \ k)))))\n                keys))))\n</code>\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
