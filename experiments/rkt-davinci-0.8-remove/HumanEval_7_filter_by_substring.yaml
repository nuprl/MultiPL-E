name: HumanEval_7_filter_by_substring
language: rkt
prompt: "#lang racket\n\n;; Filter an input list of strings only for ones that contain\
  \ given substring\n(define (filter_by_substring strings substring)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_substring))\n\
  \    (check-equal? (candidate (list ) \"john\") (list ))\n    (check-equal? (candidate\
  \ (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list\
  \ \"xxx\" \"xxxAAA\" \"xxx\"))\n    (check-equal? (candidate (list \"xxx\" \"asd\"\
  \ \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"\
  xxxAAA\" \"xxx\"))\n    (check-equal? (candidate (list \"grunt\" \"trumpet\" \"\
  prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\"))\n))\n\n(test-humaneval)"
completions: ["  (filter (lambda (s) (regexp-match? (regexp substring) s)) strings))\n",
  "  (filter (lambda (str) (string-contains str substring)) strings))\n", "  (filter\
    \ (lambda (string) (string-contains string substring)) strings))\n", "  (filter\
    \ (\u03BB (str) (string-contains str substring)) strings))\n", "  (filter (\u03BB\
    \ (s) (regexp-match? (regexp substring) s)) strings))\n", "  (filter (lambda (s)\
    \ (string-contains s substring)) strings))\n", "  (filter (lambda (x) (string-contains\
    \ x substring)) strings))\n", "  (filter (lambda (str) (string-contains str substring))\
    \ strings))\n", "  (filter (lambda (str) (string-contains? str substring)) strings))\n",
  "  (filter (lambda (x) (string-contains x substring)) strings))\n", "  (filter (lambda\
    \ (s) (string-contains s substring)) strings))\n", "  (filter (lambda (x) (string-contains\
    \ x substring)) strings))\n", "  (filter (lambda (s) (string-contains s substring))\
    \ strings))\n</code>\nI'm running a racket script as follows:\n<code>racket -t\
    \ myscript.rkt \"INPUT\"\n</code>\nbut I'm getting the following error:\n<code>string-contains:\
    \ expected a string, but received a string\n  argument: \"INPUT\"\n</code>\nI\
    \ tried <code>string-contains?</code> and got the same error. What's the proper\
    \ way to get this to work?\n\n\nA:\n\nThe issue is that Racket wraps a script\
    \ in a <code>begin</code> form. There are a number of ways to solve this issue,\
    \ but the easiest might be to use <code>#lang racket/base</code> instead of <code>#lang\
    \ racket</code>. This will disable the command-line parsing, allowing you to read\
    \ from <code>current-input-port</code>.\n<code>#lang racket/base\n", "  (filter\
    \ (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (string) (string-contains string substring)) strings))\n", "  (filter (lambda\
    \ (input) (string-contains input substring)) strings))\n", "  (filter (lambda\
    \ (string) (search substring string)) strings))\n", "  (filter (lambda (str) (string-contains\
    \ str substring)) strings))\n", "  (filter (\u03BB (str) (not (null? (string-contains\
    \ str substring)))) strings))\n", "  (filter (lambda (s) (string-contains s substring))\
    \ strings))\n", "  (filter (lambda (string) (string-contains string substring))\
    \ strings))\n", "  (filter (lambda (s) (string-contains s substring)) strings))\n",
  "  (filter (\u03BB (x) (regexp-match? (regexp substring) x)) strings))\n", "  (filter\
    \ (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (str) (string-contains? str substring)) strings))\n", "  (filter (lambda (s)\
    \ (string-contains s substring)) strings))\n</code>\nThe filter function isn't\
    \ very difficult:\n<code>#lang racket\n", "  (filter (\u03BB (str) (regexp-match?\
    \ (regexp substring) str)) strings))\n</code>\nIn the above code, I'm using <code>regexp-match?</code>\
    \ to see if the substring appears in the string. Is there a better way to do this?\n\
    \n\nA:\n\nSince you've already tagged the question as <code>Racket</code>, this\
    \ is what I'd do:\n<code>(define (filter-strings . strs)\n  (filter-map (\u03BB\
    \ (str)\n                (if (regexp-match? #rx\"match\" str)\n              \
    \      str\n                    #f))\n              strs))\n</code>\nFor the cases\
    \ of <code>regexp-match?</code> that take a string and return <code>#t</code>\
    \ or <code>#f</code>, there's <code>regexp-match</code> (notice the lack of the\
    \ question mark).\n", "  (filter (lambda (s) (string-contains s substring)) strings))\n",
  "  (filter (\u03BB (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (string) (string-contains string substring)) strings))\n", "  (filter (lambda\
    \ (str) (string-contains str substring)) strings))\n", "  (filter (lambda (str)\
    \ (string-contains str substring)) strings))\n", "  (filter (lambda (s) (string-contains\
    \ s substring)) strings))\n", "  (filter (lambda (string) (string-contains string\
    \ substring)) strings))\n", "  (filter (\u03BB (s) (not (string-contains s substring)))\
    \ strings))\n</code>\nBut I am getting the following error:\n<code>;;", "  (filter\
    \ (lambda (string) (substring? substring string)) strings))\n", "  (filter (\u03BB\
    \ (string) (string-contains string substring)) strings))\n", "  (filter (\u03BB\
    \ (str) (regexp-match? substring str)) strings))\n", "  (cond\n    [(empty? strings)\
    \ '()]\n    [(contains? (first strings) substring)\n     (cons (first strings)\
    \ (filter_by_substring (rest strings) substring))]\n    [else (filter_by_substring\
    \ (rest strings) substring)]))\n", "  (for/list ([s strings])\n    (if (regexp-match\
    \ #rx{#substring} s)\n        s)))\n", "  (filter (lambda (str) (regexp-match?\
    \ (regexp (string-append \".*\" substring \".*\")) str)) strings))\n", "  (filter\
    \ (lambda (str) (string-contains str substring)) strings))\n", "  (filter (lambda\
    \ (string) (string-contains string substring)) strings))\n", "  (filter (lambda\
    \ (s) (regexp-match? substring s)) strings))\n</code>\nI'm trying to call the\
    \ function in REPL like so:\n<code>&gt; (filter_by_substring '(\"a\" \"ac\" \"\
    c\") \"c\")\n</code>\nBut I keep getting the following error:\n<code>read-syntax:\
    \ expects a 'code' (not a 'string') argument\n</code>\nInterestingly, when I try\
    \ the following:\n<code>&gt; (filter_by_substring '(\"a\" \"ac\" \"c\") \"ac\"\
    )\n'(\"ac\")\n</code>\nIt works!\nWhat's going on here?\n\n\nA:\n\nThe argument\
    \ to <code>regexp-match?</code> should be a regexp, not a string. You can create\
    \ a regexp from a string with <code>regexp</code>, which is a handy macro for\
    \ creating regexps that doesn't require you to escape backslashes in the string\
    \ you're passing it.\n<code>(define (filter_by_substring strings substring)\n\
    \  (filter (lambda (s) (regexp-match? (regexp substring) s)) strings))\n</code>\n",
  "  (filter (lambda (str) (string-contains str substring)) strings))\n", "  (filter\
    \ (lambda (string) (string-contains string substring)) strings))\n", "  (filter\
    \ (lambda (str) (string-contains str substring)) strings))\n", "  (filter (lambda\
    \ (s) (substring? substring s)) strings))\n</code>\nThe strings can contain any\
    \ characters and the substring can also be part of a word.\nHere is my test case:\n\
    <code>; test case", "  (filter (lambda (s) (regexp-match substring s)) strings))\n",
  "  (filter (lambda (string) (string-contains string substring)) strings))\n", " \
    \ (filter (lambda (str) (string-contains? str substring)) strings))\n", "  (filter\
    \ (lambda (s) (string-contains? s substring)) strings))\n", "  (filter (lambda\
    \ (x) (string-contains x substring)) strings))\n</code>\nThe above code I think\
    \ should filter out any string in <code>strings</code> that contains <code>substring</code>.\
    \ But when I run it as follows:\n<code>(filter_by_substring '(\"hello\" \"world\"\
    \ \"bob\" \"elephant\") \"bob\")\n</code>\nI get an empty list. However, when\
    \ I test each string individually to see if it contains \"bob\", I get the result\
    \ I expect:\n<code>(string-contains \"hello\" \"bob\")", "  (filter (lambda (string)\
    \ (substring? substring string)) strings))\n", "  (filter (lambda (s) (contains-substring?\
    \ s substring)) strings))\n", "  (filter (\u03BB (string) (regexp-match substring\
    \ string)) strings))\n", "  (filter (lambda (s) (contains? s substring)) strings))\n",
  "  (filter (lambda (string) (string-contains string substring)) strings))\n", " \
    \ (filter (lambda (s) (not (string-contains s substring))) strings))\n", "  (filter\
    \ (lambda (string) (string-contains string substring)) strings))\n", "  (filter\
    \ (\u03BB (x) (substring? substring x)) strings))\n```\n\n```", "  (filter (lambda\
    \ (str) (not (empty? (find str substring)))) strings))\n", "  (filter (lambda\
    \ (s) (search substring s)) strings))\n", "  (filter (lambda (str) (string-contains\
    \ str substring)) strings))\n", "  (filter (lambda (string) (search substring\
    \ string)) strings))\n", "  (filter (\u03BB (s) (string-contains s substring))\
    \ strings))\n", "  (filter (lambda (x) (string-contains x substring)) strings))\n\
    </code>\nThis is kind of a silly example, but I'm curious. Any pointers?\n\n\n\
    A:\n\nYou're doing everything right, except that in the <code>build-eval</code>\
    \ call you gave, <code>(scheme-mode)</code> refers to a syntax object rather than\
    \ a symbol.\nThe correct <code>build-eval</code> call would be:\n<code>(build-eval\
    \ '((stx) (scheme-mode (stx))))\n</code>\n", "  (for/list ([x strings])\n    (when\
    \ (string-contains x substring)\n      x)))\n", "  (filter (lambda (s) (string-contains\
    \ s substring)) strings))\n", "  (filter (lambda (s) (string-contains s substring))\
    \ strings))\n", "  (filter (lambda (str) (string-contains str substring)) strings))\n",
  "  (filter (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (x) (string-contains x substring)) strings))\n", "  (filter (lambda (string)\
    \ (string-contains string substring)) strings))\n", "  (filter (lambda (s) (regexp-match\
    \ #rx(string-append \".*\" substring \".*\") s)) strings))\n", "  (filter (lambda\
    \ (s) (substring? substring s)) strings))\n", "  (map (lambda (str)\n        \
    \ (if (string-contains str substring)\n             str\n             #f))\n \
    \      strings))\n", "  (filter (lambda (x) (string-contains x substring)) strings))\n",
  "  (filter (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (s) (string-contains s substring)) strings))\n", "  (filter (lambda (s) (string-contains\
    \ s substring)) strings))\n", "  (filter (lambda (str) (string-contains str substring))\
    \ strings))\n", "  (filter (\u03BB (s) (regexp-match substring s)) strings))\n",
  "  (filter (\u03BB (string) (string-contains string substring)) strings))\n", " \
    \ (filter (lambda (str) (string-contains? str substring)) strings))\n", "  (filter\
    \ (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (x) (string-contains x substring)) strings))\n", "  (filter (lambda (str) (substring?\
    \ substring str)) strings))\n", "  (filter (\u03BB (str) (string-contains? str\
    \ substring)) strings))\n</code>\nThen, for any given list of strings, like\n\
    <code>&gt; (filter_by_substring '(\"foo\" \"good\" \"hi\" \"world\") \"oo\")\n\
    '(\"foo\" \"good\")\n</code>\nIn your case, you can use your <code>read-file</code>\
    \ function to load a file into memory and then use this function to filter it.\
    \ \n<code>(define (filter_by_substring filename substring)\n  (filter (\u03BB\
    \ (str) (string-contains? str substring)) (read-file filename)))\n</code>\n",
  "  (filter (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (s) (string-contains s substring)) strings))\n", "  (filter (\u03BB (str) (contains-substring?\
    \ str substring)) strings))\n", "  (filter (lambda (str) (string-contains str\
    \ substring)) strings))\n", "  (filter (lambda (s) (contains? s substring)) strings))\n",
  "  (filter (lambda (s) (string-contains? s substring)) strings))\n</code>\nThe problem\
    \ is that when I run this code from Racket I get the following error:\n<code>Welcome\
    \ to Racket v6.10.", "  (filter (\u03BB (str) (string-contains str substring))\
    \ strings))\n", "  (filter (lambda (s) (string-contains s substring)) strings))\n\
    </code>\nIf I was doing it in Python, I'd just loop through the list and throw\
    \ away the undesired strings using <code>continue</code> in a <code>for</code>\
    \ loop. How can I do that in Racket?\n\n\nA:\n\nYou could just not use <code>filter</code>\
    \ but write your own <code>for</code> loop:\n<code>(define (filter-by-substring\
    \ strings substring)\n  (let loop ([strings strings]\n             [result '()])\n\
    \    (if (null? strings)\n        (reverse result)\n        (if (string-contains\
    \ (car strings) substring)\n            (loop (cdr strings) (cons (car strings)\
    \ result))\n            (loop (cdr strings) result)))))\n</code>\n", "  (filter\
    \ (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (x) (string-contains x substring)) strings))\n", "  (filter (lambda (str) (string-contains\
    \ str substring)) strings))\n</code>\n", "  (for/list ([s strings])\n    (if (string-contains\
    \ s substring)\n        s)))\n", "  (filter (lambda (s) (regexp-contains? (regexp-quote\
    \ substring) s)) strings))\n", "  (filter (lambda (string) (string-contains string\
    \ substring)) strings))\n", "  (define (filterer str)\n    (string-contains? str\
    \ substring))\n  (filter filterer strings))\n", "  (filter (lambda (str) (regexp-match\
    \ substring str)) strings))\n", "  (filter (lambda (x) (substring? substring x))\
    \ strings))\n", "  (filter (lambda (x) (substring? substring x)) strings))\n",
  "  (filter (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (string) (string-contains string substring)) strings))\n", "  (for/list ([x\
    \ strings])\n    (if (string-contains x substring)\n        x)))\n", "  (filter\
    \ (lambda (str) (string-contains str substring)) strings))\n", "  (filter (lambda\
    \ (string) (string-contains string substring)) strings))\n", "  (filter (\u03BB\
    \ (s) (regexp-match? substring s)) strings))\n", "  (filter (lambda (str) (string-contains\
    \ str substring)) strings))\n", "  (cond\n    [(empty? strings) '()]\n    [(string-contains\
    \ (first strings) substring)\n     (cons (first strings) (filter_by_substring\
    \ (rest strings) substring))]\n    [else (filter_by_substring (rest strings) substring)]))\n",
  "  (filter (lambda (s) (string-contains? s substring)) strings))\n", "  (filter\
    \ (\u03BB (s) (string-contains s substring)) strings))\n</code>\nBut this code\
    \ looks a bit verbose. Also I am having trouble defining a function for the case\
    \ where I want to filter only for strings that don't contain a substring.\nI can\
    \ think of two improvements:\n\nusing a pre-defined predicate <code>string-contains</code>,\n\
    using a lambda function.\n\nI can't decide if I should use both of them or remove\
    \ one of them.\nSo I would like to know:\n\nWhich solution is better?\nIs there\
    \ a better solution?\n\nEdit: I am asking about improving the solution I have,\
    \ but I am also interested in other possible solutions to this problem, that is,\
    \ filtering a list of strings by substring.\n\n\nA:\n\nI don't think you're trying\
    \ to make the right kind of abstraction.\n<code>(define (filter-by-substring strings\
    \ substring)\n  (filter (\u03BB (s) (string-contains s substring)) strings))\n\
    </code>\nHere, you are taking the predefined string-contains, and applying it\
    \ to a list of strings. You want to apply the predicate to both elements of the\
    \ list and the string. You can do that with fold.\n<code>(define (filter-by-substring\
    \ strings substring)\n  (foldr (\u03BB (s list) (if (string-contains s substring)\
    \ (cons s list) list)) '() strings))\n</code>\nFilter could be written using fold:\n\
    <code>(define (filter pred? lst)\n  (foldr (\u03BB (a list) (if (pred? a) (cons\
    \ a list) list)) '() lst))\n</code>\nSo your version of filter could be written\
    \ as:\n<code>(define (filter-by-substring strings substring)\n  (filter (\u03BB\
    \ (s) (string-contains s substring)) strings))\n</code>\nOr better, use <code>filter-string</code>\
    \ (aka <code>string-contains?</code>):\n<code>(define (filter-by-substring strings\
    \ substring)\n  (filter (filter-string substring) strings))\n</code>\n", "  (filter\
    \ (lambda (x) (string-contains x substring)) strings))\n", "  (filter (lambda\
    \ (string) (substring? substring string)) strings))\n", "  (filter (lambda (s)\
    \ (string-contains s substring)) strings))\n</code>\nand I am getting a syntax\
    \ error at the <code>s</code> in the lambda expression that I can't seem to figure\
    \ out how to fix.\n\n\nA:\n\nThe syntax is <code>(define (func param1 param2 ...)\
    \ body)</code>. In your example, <code>strings</code> and <code>substring</code>\
    \ are parameters to <code>filter_by_substring</code>. You can see that in <code>filter_by_substring</code>'s\
    \ <code>body</code> <code>filter</code> is called. <code>filter</code> takes a\
    \ predicate (your lambda) and a list. The <code>lambda</code>'s parameter is <code>s</code>,\
    \ which is an item from the list passed to <code>filter</code>. In this case the\
    \ list is <code>strings</code>.\n", "  (filter (lambda (string) (string-contains\
    \ substring string)) strings))\n", "  (filter (lambda (s) (regexp-match? substring\
    \ s)) strings))\n</code>\n", "  (filter (lambda (s) (string-contains s substring))\
    \ strings))\n", "  (filter (lambda (s) (substring? substring s)) strings))\n",
  "  (filter (lambda (str) (string-contains str substring)) strings))\n", "  (filter\
    \ (\u03BB (s) (string-contains s substring)) strings))\n", "  (cond\n    [(null?\
    \ strings) '()]\n    [(string-contains? (car strings) substring)\n     (cons (car\
    \ strings) (filter_by_substring (cdr strings) substring))]\n    [else (filter_by_substring\
    \ (cdr strings) substring)]))\n", "  (filter (lambda (x) (string-contains x substring))\
    \ strings))\n", "  (filter (lambda (s) (regexp-match substring s)) strings))\n",
  "  (filter (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (str) (string-contains? str substring)) strings))\n", "  (filter (\u03BB (string)\
    \ (substring? substring string)) strings))\n", "  (filter (\u03BB (s) (string-contains\
    \ s substring)) strings))\n", "  (filter (lambda (string) (string-contains substring\
    \ string)) strings))\n</code>\nI can get that to work. However, if I try to use\
    \ the racket string processing library:\n<code>#lang racket\n", "  (filter (lambda\
    \ (str) (string-contains? str substring)) strings))\n</code>\nRacket provides\
    \ an interactive REPL where I can evaluate these expressions, but how do I save\
    \ them in a file such that I can use them later in Racket? I want to save them\
    \ in a file so that I can open that file in a text editor, easily copy and paste\
    \ parts of it, or even open it outside of Racket in any text editor. I've tried\
    \ using the <code>racket</code> function <code>write</code> but when I use it\
    \ in the REPL I get errors and the program exits.\n\n\nA:\n\nIf you simply enter\
    \ <code>(write STRING)</code> into the REPL, it won't write the string to the\
    \ REPL, it will write it as output to the terminal. And since the terminal is\
    \ typically configured to close when the process finishes, you will see your string\
    \ printed, followed by the REPL closing. The REPL sees <code>write</code> as the\
    \ command that it should execute, the command does it's work, and then exits.\n\
    <code>write</code> writes to the current-output-port and the REPL sets that to\
    \ the console, but you can change the current-output-port to a string port (see\
    \ the docs for a description) that you can access with <code>get-output-string</code>\
    \ afterwards. This should allow you to write to a temporary string.\n<code>(define\
    \ my-output-port (open-output-string))", "  (filter (lambda (x) (string-contains\
    \ x substring)) strings))\n", "  (filter (lambda (s) (string-contains s substring))\
    \ strings))\n", "  (filter (lambda (s) (string-contains s substring)) strings))\n",
  "  (filter (lambda (x) (string-contains x substring)) strings))\n", "  (filter (lambda\
    \ (x) (string-contains x substring)) strings))\n", "  (filter (lambda (s) (contains?\
    \ s substring)) strings))\n", "  (filter (\u03BB (str) (substring? substring str))\
    \ strings))\n", "  (filter (lambda (str) (string-contains str substring)) strings))\n",
  "  (cond\n    [(empty? strings) empty]\n    [(string-contains? (first strings) substring)\n\
    \     (cons (first strings) (filter_by_substring (rest strings) substring))]\n\
    \    [else (filter_by_substring (rest strings) substring)]))\n", "  (filter (lambda\
    \ (string) (string-contains substring string)) strings))\n", "  (filter (\u03BB\
    \ (str) (string-contains str substring)) strings))\n", "  (filter (lambda (s)\
    \ (not (string-contains s substring))) strings))\n", "  (filter (\u03BB (s) (string-contains\
    \ s substring)) strings))\n", "  (filter (lambda (s) (string-contains s substring))\
    \ strings))\n", "  (filter (\u03BB (str) (string-contains str substring)) strings))\n",
  "  (filter (\u03BB (i) (string-contains? i substring)) strings))\n", "  (filter\
    \ (lambda (s) (not (string-contains s substring))) strings))\n", "  (filter (lambda\
    \ (s) (regexp-match? (regexp substring) s)) strings))\n", "  (filter (lambda (s)\
    \ (string-contains s substring)) strings))\n", "  (filter (lambda (str) (string-contains\
    \ str substring)) strings))\n", "  (filter (lambda (string) (regexp-match? (regexp\
    \ substring) string)) strings))\n", "  (filter (lambda (s) (string-contains s\
    \ substring)) strings))\n", "  (filter (lambda (s) (regexp-match (regexp (string-append\
    \ \".*\" substring \".*\")) s)) strings))\n", "  (filter (lambda (string) (regexp-match\
    \ substring string)) strings))\n", "  (filter (lambda (s) (string-contains s substring))\
    \ strings))\n", "  (cond\n    [(empty? strings) '()]\n    [(string-contains? (first\
    \ strings) substring)\n     (cons (first strings) (filter_by_substring (rest strings)\
    \ substring))]\n    [else (filter_by_substring (rest strings) substring)]))\n",
  "  (filter (lambda (s) (regexp-match? substring s)) strings))\n", "  (for/list ([s\
    \ strings])\n    (when (regexp-contains? (regexp substring) s)\n      s)))\n",
  "  (filter (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (s) (regexp-match? (regexp substring) s)) strings))\n", "  (filter (lambda (str)\
    \ (string-contains str substring)) strings))\n", "  (filter (\u03BB (str) (substring?\
    \ substring str)) strings))\n", "  (filter (\u03BB (string) (string-contains string\
    \ substring)) strings))\n", "  (filter (lambda (str) (string-contains? str substring))\
    \ strings))\n", "  (filter (lambda (s) (substring? substring s)) strings))\n",
  "  (filter (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (string) (string-contains string substring)) strings))\n", "  (filter (lambda\
    \ (x) (string-contains x substring)) strings))\n", "  (let loop ([strings strings])\n\
    \    (if (empty? strings)\n        empty\n        (if (substring? (first strings)\
    \ substring)\n            (cons (first strings) (loop (rest strings)))\n     \
    \       (loop (rest strings))))))\n", "  (let ((contains_substring? (lambda (s)\
    \ (string-contains s substring))))\n    (filter contains_substring? strings)))\n",
  "  (filter (lambda (s) (string-contains s substring)) strings))\n", "  (filter (\u03BB\
    \ (s) (contains-substring? s substring)) strings))\n", "  (filter (lambda (string)\
    \ (string-contains string substring)) strings))\n", "  (filter (lambda (s) (regexp-match\
    \ substring s)) strings))\n", "  (filter (\u03BB (x) (string-contains x substring))\
    \ strings))\n", "  (filter (lambda (s) (substring? substring s)) strings))\n</code>\n\
    Here is the code for the <code>substring?</code> procedure, again in Racket:\n\
    <code>#lang racket\n", "  (filter (lambda (string) (string-contains string substring))\
    \ strings))\n", "  (filter (\u03BB (elem) (string-contains elem substring)) strings))\n",
  "  (cond\n    ((empty? strings) '())\n    ((string-contains? (first strings) substring)\n\
    \     (cons (first strings) (filter_by_substring (rest strings) substring)))\n\
    \    (else (filter_by_substring (rest strings) substring))))\n", "  (filter (lambda\
    \ (s) (string-contains s substring)) strings))\n</code>\nFor example, if <code>strings</code>\
    \ were\n<code>'(\"foo\" \"oof\" \"ofo\" \"foobar\" \"barfoo\" \"oobar\")\n</code>\n\
    Then <code>(filter_by_substring strings \"o\")</code> would give\n<code>'(\"foo\"\
    \ \"oof\" \"ofo\" \"oobar\")\n</code>\nBut I need to do the same thing for lists\
    \ of symbols rather than lists of strings.\nI tried several variations and I couldn't\
    \ get any of them to work.\nFor example, the following attempt errors out with\
    \ \"application: not a procedure; attempted to apply a non-procedure object\"\n\
    <code>#lang racket\n", "  (filter (lambda (x) (string-contains x substring)) strings))\n",
  "  (for/list ([s strings])\n    (when (string-contains? s substring)\n      s)))\n",
  "  (filter (lambda (x) (string-contains x substring)) strings))\n", "  (filter (lambda\
    \ (s) (regexp-match substring s)) strings))\n", "  (filter (lambda (x) (string-contains\
    \ x substring)) strings))\n", "  (cond\n    ((null? strings) '())\n    ((string-contains?\
    \ (car strings) substring)\n      (cons (car strings) (filter_by_substring (cdr\
    \ strings) substring)))\n    (else (filter_by_substring (cdr strings) substring))))\n",
  "  (filter (lambda (s) (string-contains s substring)) strings))\n", "  (filter (lambda\
    \ (s) (contains? s substring)) strings))\n", "  (filter (lambda (s) (regexp-match\
    \ #rx(,substring) s)) strings))\n", "  (filter (lambda (s) (regexp-contains? s\
    \ substring)) strings))\n", "  (filter (lambda (word) (string-contains word substring))\
    \ strings))\n", "  (filter (lambda (str) (string-contains str substring)) strings))\n",
  "  (define (contains-substring? string)\n    (define (contains-substring-h string\
    \ i)\n      (if (= i (string-length string))\n          false\n          (or (=\
    \ (string-ref string i) (string-ref substring 0))\n              (contains-substring-h\
    \ string (+ i 1)))))\n    (contains-substring-h string 0))\n  (filter contains-substring?\
    \ strings))\n", "  (filter (lambda (string) (string-contains substring string))\
    \ strings))\n", "  (filter (lambda (str) (substring? substring str)) strings))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
