name: HumanEval_9_rolling_max
language: rkt
prompt: "#lang racket\n\n;; From a given list of integers, generate a list of rolling\
  \ maximum element found until given moment\n;; in the sequence.\n(define (rolling_max\
  \ numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 1 2 3 4)) (list 1 2 3 4))\n    (check-equal? (candidate (list 4 3 2 1)) (list\
  \ 4 4 4 4))\n    (check-equal? (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100))\n\
  ))\n\n(test-humaneval)"
completions: ["  (letrec ([my-max (lambda (number values) (if (empty? values) number\
    \ (max number (car values))))]\n           [recur (lambda (results values)\n \
    \                   (if (empty? values)\n                        (reverse results)\n\
    \                        (recur (cons (my-max (car values) values) results) (cdr\
    \ values))))])\n    (recur (list (car numbers)) (cdr numbers))))\n", "  (let loop\
    \ ([numbers numbers]\n             [maximum #f])\n    (if (null? numbers)\n  \
    \      (if maximum\n            (list maximum)\n            '())\n        (let\
    \ ([max (if maximum\n                       (max (car numbers) maximum)\n    \
    \                   (car numbers))])\n          (loop (cdr numbers) max)))))\n",
  "  (let loop ([numbers numbers]\n             [maximum #f])\n    (cond\n      [(empty?\
    \ numbers) empty]\n      [(and (not maximum) (not (empty? numbers)))\n       (loop\
    \ (rest numbers) (first numbers))]\n      [(> (first numbers) maximum)\n     \
    \  (cons maximum (loop (rest numbers) (first numbers)))]\n      [else\n      \
    \ (cons maximum (loop (rest numbers) maximum))])))\n", "    (let loop ([max-so-far\
    \ 0]\n               [numbers numbers]\n               [retval '()])\n      (cond\n\
    \        [(empty? numbers) (reverse retval)]\n        [(>= (first numbers) max-so-far)\n\
    \         (loop (first numbers) (rest numbers) (cons (first numbers) retval))]\n\
    \        [else\n         (loop max-so-far (rest numbers) (cons max-so-far retval))])))\n\
    ```\n\n```\n$ racket rolling_max.rkt\n```\n\n```\n> (rolling_max '(1 2 3 4 4 3\
    \ 3 4 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4))\n'(1 2 3 4 4 4 4 4 4 4 4 4\
    \ 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4)\n```", "  (let loop ([numbers numbers]\n\
    \             [current (car numbers)]\n             [accum '()])\n    (if (null?\
    \ numbers)\n        accum\n        (loop (cdr numbers)\n              (if (&gt;\
    \ (car numbers) current)\n                  (car numbers)\n                  current)\n\
    \              (cons current accum)))))\n", "  (if (null? numbers)\n      '()\n\
    \      (cons (apply max numbers)\n            (rolling_max (cdr numbers)))))\n\
    </code>\n", "  (if (null? numbers)\n      '()\n      (cons (fold max numbers)\n\
    \            (rolling_max (cdr numbers)))))\n", "  (define (rolling_max_iter numbers\
    \ rolling-max)\n    (if (null? numbers)\n        '()\n        (cons (max (car\
    \ numbers) rolling-max)\n              (rolling_max_iter (cdr numbers) (max (car\
    \ numbers) rolling-max)))))\n  (rolling_max_iter numbers -(+)))\n\n", "  (define\
    \ (go numbers max-so-far result)\n    (if (null? numbers)\n        result\n  \
    \      (go (cdr numbers)\n            (max (car numbers) max-so-far)\n       \
    \     (cons max-so-far result))))\n  (go numbers -inf.0 '()))\n", "  (cond ((null?\
    \ numbers)\n         empty)\n        ((pair? numbers)\n         (cons (max (car\
    \ numbers) (apply max (cdr numbers)))\n               (rolling_max (cdr numbers))))))\n",
  "  (if (null? numbers)\n      '()\n      (cons (maximum numbers)\n            (rolling_max\
    \ (cdr numbers)))))\n", "  (define (tail-rec numbers max_list)\n    (if (empty?\
    \ numbers)\n        max_list\n        (let ([head (first numbers)])\n        \
    \  (tail-rec (rest numbers) (cons (if (&gt; head (first max_list)) head (first\
    \ max_list)) max_list)))))\n  (tail-rec numbers (list (first numbers))))\n", " \
    \ (define (generate-all-rollings maxes)\n    (let ((current-max (car numbers)))\n\
    \      (match numbers\n        ('() (reverse maxes))\n        ((cons number numbers)\n\
    \         (if (&gt; number current-max)\n             (generate-all-rollings (cons\
    \ number maxes))\n             (generate-all-rollings (cons current-max maxes)))))))\n\
    \  (generate-all-rollings (list (car numbers))))\n", "  (if (null? numbers)\n\
    \      '()\n      (cons (max (car numbers) (car (rolling_max (cdr numbers))))\n\
    \            (rolling_max (cdr numbers)))))\n```\n\n```racket\n#lang racket\n",
  "  (define (generate numbers max)\n    (cond\n      [(empty? numbers)\n       empty]\n\
    \      [(> (first numbers) max)\n       (cons (first numbers) (generate (rest\
    \ numbers) (first numbers)))]\n      [else\n       (cons max (generate (rest numbers)\
    \ max))]))\n  (generate numbers 0))\n", "  (apply max (take numbers (map-indexed\
    \ (lambda (idx num) (range idx (add1 idx))) numbers))))\n", "  (for/fold ([rolling-max\
    \ 0])\n            ([number numbers])\n            (max rolling-max number)))\n",
  "  (for/fold ([acc '()])\n            ([n numbers])\n            (cons (max (or\
    \ (car acc) -\u221E) n) acc)))\n", "  (let loop ([numbers numbers]\n         \
    \    [max 0]\n             [acc '()])\n    (if (null? numbers)\n        (reverse\
    \ acc)\n        (if (&gt; (car numbers) max)\n            (loop (cdr numbers)\
    \ (car numbers) (cons (car numbers) acc))\n            (loop (cdr numbers) max\
    \ (cons max acc))))))\n", "  (define (iter rest current_max)\n    (cond\n    \
    \  [(empty? rest) '()]\n      [(> (first rest) current_max) (cons (first rest)\
    \ (iter (rest rest) (first rest)))]\n      [else (cons current_max (iter (rest\
    \ rest) current_max))]))\n  (iter numbers (first numbers)))\n", "  (let loop ([numbers\
    \ numbers]\n             [max_so_far (first numbers)]\n             [result '()])\n\
    \    (cond [(empty? numbers) reverse result]\n          [(> (first numbers) max_so_far)\n\
    \           (loop (rest numbers) (first numbers) (cons (first numbers) result))]\n\
    \          [else (loop (rest numbers) max_so_far (cons max_so_far result))])))\n",
  "  (define length (length numbers))\n  (if (eq? length 0)\n      numbers\n     \
    \ (begin\n        (define max-at-position (list (list-ref numbers 0)))\n     \
    \   (for ([i (in-range 1 length)])\n          (define current-value (list-ref\
    \ numbers i))\n          (define last-value (list-ref max-at-position (- i 1)))\n\
    \          (if (eq? current-value last-value)\n              (set! max-at-position\
    \ (append max-at-position (list current-value)))\n              (set! max-at-position\
    \ (append max-at-position (list (max current-value last-value))))))\n        max-at-position)))\n",
  "  (define (go accumulate remainders)\n    (if (null? remainders)\n        (reverse\
    \ accumulate)\n        (let ([m (max (car remainders) (car accumulate))])\n  \
    \        (go (cons m accumulate) (cdr remainders)))))\n  (go (list (car numbers))\
    \ (cdr numbers)))\n", "  (define (rolling_max_iter numbers max_so_far accumulated)\n\
    \    (if (null? numbers)\n        accumulated\n        (let ([cur_num (car numbers)])\n\
    \          (rolling_max_iter (cdr numbers)\n                            (if (&gt;\
    \ cur_num max_so_far) cur_num max_so_far)\n                            (cons max_so_far\
    \ accumulated)))))\n  (reverse (rolling_max_iter numbers -inf.0 '())))\n", " \
    \   (cond\n        [(null? numbers) '()]\n        [else\n         (cons (apply\
    \ max numbers)\n               (rolling_max (cdr numbers)))]))\n", "  (let loop\
    \ ([acc '()] [numbers numbers])\n    (if (null? numbers)\n        (reverse acc)\n\
    \        (loop (cons (apply max numbers) acc) (cdr numbers)))))\n```\n\n```racket\n\
    #lang racket\n", "    (define (rolling_max_acc numbers maxt)\n        (cond ((null?\
    \ numbers) '())\n              ((null? maxt) (cons (car numbers) (rolling_max_acc\
    \ (cdr numbers) (car numbers))))\n              ((< (car numbers) (car maxt))\
    \ (cons (car maxt) (rolling_max_acc (cdr numbers) (car maxt))))\n            \
    \  (else (cons (car numbers) (rolling_max_acc (cdr numbers) (car numbers))))))\n\
    \    (rolling_max_acc numbers '()))\n", "  (define (rolling_max_helper nums running_max)\n\
    \    (if (null? nums)\n        '()\n        (cons running_max (rolling_max_helper\
    \ (cdr nums) (max running_max (car nums))))))\n  (rolling_max_helper numbers 0))\n",
  "  (let loop ([acc '()] [numbers numbers])\n    (cond [(empty? numbers) (reverse\
    \ acc)]\n          [else (loop (cons (max (first numbers) (if (empty? acc) 0 (first\
    \ acc))) acc) (rest numbers))])))\n", "  (letrec\n      ((seq-max (lambda (numbers\
    \ max)\n                  (if (empty? numbers)\n                      '()\n  \
    \                    (cons max (seq-max (rest numbers) (max max (first numbers)))))))\n\
    \       (seq-max-acc (lambda (numbers)\n                      (seq-max numbers\
    \ (first numbers)))))\n    (seq-max-acc numbers)))\n", "  (if (null? numbers)\n\
    \      (error \"Can't compute rolling max of null list.\")\n      (let loop ([current-max\
    \ (first numbers)]\n                 [numbers (rest numbers)]\n              \
    \   [result '()])\n        (if (null? numbers)\n            (cons current-max\
    \ result)\n            (if (> (first numbers) current-max)\n                (loop\
    \ (first numbers) (rest numbers) (cons current-max result))\n                (loop\
    \ current-max (rest numbers) (cons current-max result)))))))\n", "  (define (maximums\
    \ numbers maximums index)\n    (cond\n      [(empty? numbers)\n       maximums]\n\
    \      [(> (first numbers) (list-ref maximums (- index 1)))\n       (maximums\
    \ (rest numbers) (append maximums (list (first numbers))) (+ index 1))]\n    \
    \  [else\n       (maximums (rest numbers) (append maximums (list (list-ref maximums\
    \ (- index 1)))) (+ index 1))]))\n  (maximums numbers (list (first numbers)) 1))\n",
  "  (if (null? numbers)\n      '()\n      (let* ([first_number (car numbers)]\n \
    \            [sublist (cdr numbers)]\n             [sublist_max (apply max sublist)])\n\
    \        (cons (if (&gt;= first_number sublist_max) first_number sublist_max)\n\
    \              (rolling_max sublist)))))\n", "  (define (rolling_max_aux max_yet\
    \ values)\n    (cond ((null? values) (list))\n          ((> (car values) max_yet)\n\
    \           (cons (car values) (rolling_max_aux (car values) (cdr values))))\n\
    \          (else (cons max_yet (rolling_max_aux max_yet (cdr values))))))\n  (rolling_max_aux\
    \ (car numbers) (cdr numbers)))\n", "  (define (rolling_max_proc numbers left-max)\n\
    \    (if (null? numbers)\n        '()\n        (let ([next-num (car numbers)])\n\
    \          (cons (max left-max next-num)\n                (rolling_max_proc (cdr\
    \ numbers) (max left-max next-num))))))\n  (rolling_max_proc numbers -10000))",
  "  (cond\n    [(empty? numbers) '()]\n    [(cons? numbers)\n     (append (list (apply\
    \ max numbers))\n             (rolling_max (rest numbers)))]))\n", "  (let loop\
    \ ([numbers numbers]\n             [max-so-far 0]\n             [max-list (list)])\n\
    \    (cond [(empty? numbers) (reverse max-list)]\n          [else (loop (rest\
    \ numbers)\n                      (max (first numbers) max-so-far)\n         \
    \             (cons max-so-far max-list))])))\n", "  (let loop ([acc '()] [numbers\
    \ numbers])\n    (cond [(empty? numbers) reverse acc]\n          [else (loop (cons\
    \ (max (first numbers) (apply max acc)) acc) (rest numbers))])))\n", "  (define\
    \ (rolling_max_iter numbers max)\n    (if (null? numbers)\n        (list)\n  \
    \      (if (&gt; (car numbers) max)\n            (cons (car numbers) (rolling_max_iter\
    \ (cdr numbers) (car numbers)))\n            (cons max (rolling_max_iter (cdr\
    \ numbers) max)))))\n  (rolling_max_iter numbers (car numbers)))\n", "  (define\
    \ (loop numbers res)\n    (cond\n      [(empty? numbers) (reverse res)]\n    \
    \  [(empty? res) (loop (rest numbers) (list (first numbers)))]\n      [else (loop\
    \ (rest numbers) (cons (max (first numbers) (first res)) res))]))\n  (loop numbers\
    \ '()))\n", "  (accumulate (lambda (a b) (if (> a b) a b))\n              (car\
    \ numbers)\n              (cdr numbers)))\n", "  (define (iter numbers running-max\
    \ max-list)\n    (cond [(empty? numbers) reverse max-list]\n          [(> (first\
    \ numbers) running-max) (iter (rest numbers) (first numbers) (cons (first numbers)\
    \ max-list))]\n          [else (iter (rest numbers) running-max (cons running-max\
    \ max-list))]))\n  (iter numbers (first numbers) (list (first numbers))))\n",
  "  (cond [(empty? numbers) empty]\n        [(< (first numbers) (second numbers))\
    \ (cons (first numbers) (rolling_max (rest numbers)))]\n        [else (cons (second\
    \ numbers) (rolling_max (rest numbers)))]))\n```\n\n```racket\n#lang racket\n",
  "  (define (sub max nums)\n    (if (null? nums)\n        '()\n        (cons max\
    \ (sub (max max (car nums)) (cdr nums)))))\n  (sub -(expt 2 63) numbers))\n",
  "  (define (rolling_max_rec accumulator numbers)\n    (if (null? numbers)\n    \
    \    accumulator\n        (let ([m (max (car accumulator) (car numbers))])\n \
    \         (rolling_max_rec (cons m accumulator) (cdr numbers)))))\n  (rolling_max_rec\
    \ (list (car numbers)) (cdr numbers)))\n", "  (cond [(empty? numbers) empty]\n\
    \        [(pair? numbers)\n         (cons (apply max numbers)\n              \
    \ (rolling_max (rest numbers)))]))\n", "  (let loop ([numbers numbers]\n     \
    \        [maximum '()])\n    (if (null? numbers)\n        (reverse maximum)\n\
    \        (let ([new-max (if (null? maximum)\n                           (car numbers)\n\
    \                           (max (car numbers) (car maximum)))])\n          (loop\
    \ (cdr numbers) (cons new-max maximum))))))\n</code>\nHere's a version with the\
    \ recursive call moved to the beginning, to make it tail recursive:\n<code>#lang\
    \ racket\n", "  (define (loop maxes numbers)\n    (cond\n      [(empty? numbers)\
    \ (reverse maxes)]\n      [else (let* ([current (first numbers)]\n           \
    \        [max-of-numbers-rest (apply max (rest numbers))])\n              (loop\
    \ (cons (if (&gt;= current max-of-numbers-rest) current max-of-numbers-rest) maxes)\n\
    \                    (rest numbers)))]))\n  (if (empty? numbers)\n      '()\n\
    \      (loop (list (first numbers))\n            (rest numbers))))\n", "  (map\
    \ first\n       (map reverse\n            (in-nested (iota (length numbers))\n\
    \                       (lambda (i)\n                         (map first\n   \
    \                           (filter (lambda (pair)\n                         \
    \               (and (>= (second pair) (second (list-ref numbers i)))\n      \
    \                                       (<= (first pair) i)))\n              \
    \                        (map vector (iota (add1 i)) numbers))))))))\n", "  (letrec\
    \ ([rolling_max-helper (lambda (numbers biggest)\n                           \
    \      (if (null? numbers)\n                                     '()\n       \
    \                              (cons (if (&gt; (car numbers) biggest)\n      \
    \                                         (car numbers)\n                    \
    \                           biggest)\n                                       \
    \    (rolling_max-helper (cdr numbers) (car numbers))))])\n    (rolling_max-helper\
    \ numbers -1)))\n", "  (let loop ([numbers numbers]\n             [acc '()])\n\
    \    (cond\n      [(empty? numbers) (reverse acc)]\n      [(null? acc) (loop (rest\
    \ numbers) (list (first numbers)))]\n      [else (loop (rest numbers) (cons (max\
    \ (first numbers) (first acc)) acc))])))\n", "  (foldr (lambda (x y) (if (> x\
    \ (car y))\n                           (cons x y)\n                          \
    \ (cons (car y) (cdr y))))\n         (list (car numbers))\n         (cdr numbers)))\n",
  "  (define (maxin list maxsofar)\n    (if (null? list)\n        maxsofar\n     \
    \   (maxin (cdr list) (max (car list) maxsofar))))\n  (if (null? numbers)\n  \
    \    numbers\n      (cons (maxin numbers 0) (rolling_max (cdr numbers)))))\n",
  "  (define (rolling_max_helper result numbers)\n    (cond ((empty? numbers) result)\n\
    \          ((null? result) (rolling_max_helper (list (first numbers)) (rest numbers)))\n\
    \          (else (rolling_max_helper (append result (list (max (first result)\
    \ (first numbers)))) (rest numbers)))))\n  (rolling_max_helper '() numbers))\n",
  "  (let ([res (map (\u03BB (x) x) numbers)])\n    (for ([i (in-range 1 (length numbers))])\n\
    \      (set! res (append (list (max (list-ref numbers i) (list-ref res (- i 1))))\
    \ (rest res))))\n    res))\n", "  (define (iter nums res)\n    (if (empty? nums)\n\
    \        res\n        (iter (rest nums) (cons (max (first nums) (first res)) res))))\n\
    \  (reverse (iter numbers '(-inf.0))))\n", "  (let loop ([numbers numbers]\n \
    \            [acc '()])\n    (if (null? numbers)\n        (reverse acc)\n    \
    \    (let ([current-max (apply max numbers)])\n          (loop (cdr numbers)\n\
    \                (cons current-max acc))))))\n</code>\nI know there are faster\
    \ solutions for Racket (as for any imperative language), but the point of this\
    \ exercise was\nto explore different approaches to recursion.\n", "  (define (iter\
    \ previous maxes nums)\n    (cond [(empty? nums) maxes]\n          [(> (first\
    \ nums) previous) (iter (first nums) (cons (first nums) maxes) (rest nums))]\n\
    \          [else (iter previous (cons previous maxes) (rest nums))]))\n  (reverse\
    \ (iter 0 empty numbers)))\n", "  (let loop ([numbers numbers]\n             [result\
    \ '()])\n    (if (null? numbers)\n        (reverse result)\n        (loop (cdr\
    \ numbers)\n              (cons (apply max numbers)\n                    result)))))\n",
  "  (define (go max rolling numbers)\n    (cond\n      [(empty? numbers) rolling]\n\
    \      [(> (first numbers) max) (go (first numbers) (cons (first numbers) rolling)\
    \ (rest numbers))]\n      [else (go max (cons max rolling) (rest numbers))]))\n\
    \  (reverse (go -1 (empty) numbers)))\n", "  (let loop ([numbers numbers]\n  \
    \           [rolling_max '()])\n    (if (empty? numbers)\n        rolling_max\n\
    \        (loop (rest numbers)\n              (cons (apply max (cons (first numbers)\
    \ rolling_max))\n                    rolling_max)))))\n</code>\nThe function uses\
    \ accumulator pattern to make the result reversed. In order to get it in the order\
    \ we need,\nwe need to reverse the result after the function returns.\n<code>&gt;\
    \ (reverse (rolling_max '(3 1 3 2 3 4 5)))\n'(3 3 3 3 4 5 5)\n</code>\n", "  (define\
    \ (rolling_max_iter numbers maximums)\n    (match numbers\n      ((list number)\n\
    \       (list number))\n      ((list number numbers ...)\n       (define maximums\
    \ (rolling_max_iter numbers maximums))\n       (cons (max number (car maximums))\
    \ maximums))))\n  (rolling_max_iter numbers '()))\n", "  (if (null? numbers)\n\
    \      '()\n      (let* ((last (car (last numbers)))\n             (rest (rolling_max\
    \ (reverse (cdr (reverse numbers)))))\n             (last_el (car rest)))\n  \
    \      (cons (max last last_el) rest))))\n", "  (if (null? numbers)\n      null\n\
    \      (cons (apply max numbers)\n            (rolling_max (cdr numbers)))))\n",
  "  (let ([result (list 0)])\n    (for ([i (in-range (length numbers))])\n      (let\
    \ ([max (apply max (take numbers i))])\n        (set! result (append result (list\
    \ max)))))\n    result))\n</code>\nIt's obviously not the most efficient way to\
    \ achieve the result, however it is at least very straightforward. Now I would\
    \ like to translate this code to Haskell, but I am stuck with trying to update\
    \ the value of the list inside a loop. I did some research and came up with the\
    \ following code:\n<code>rolling_max = scanl1 max\n</code>\nBut it somehow produces\
    \ different results than the Racket code. The difference can be observed below.\n\
    <code>racket@(racket)&gt; (rolling_max '(1 4 3 6 7 9 0 5 4 1))\n'(0 1 4 4 6 7\
    \ 9 9 9 9)\nracket@(racket)&gt;\n\nPrelude&gt; rolling_max [1,4,3,6,7,9,0,5,4,1]\n\
    [1,4,4,6,7,9,9,9,9,9]\nPrelude&gt;\n</code>\nI don't see what I did wrong, could\
    \ somebody point it out? Thanks in advance.\n\n\nA:\n\n<code>scanl1</code> is\
    \ not equivalent to what you're trying to do in Racket, because the identity element\
    \ for <code>max</code> is <code>0</code>, and you're using <code>0</code> as the\
    \ initial element in your list.\nWhat you want is something like <code>scanl1\
    \ (\\a b -&gt; max a b)</code>, but that won't work because it produces the same\
    \ results as <code>scanl1 max</code>.  You need to use a different initial element.\
    \  (This is the same problem as in your original Racket code, where you had the\
    \ same problem.)\nI think the easiest way to do this is to actually define a function\
    \ that does this in Haskell and use <code>scanl</code>.  There are probably more\
    \ efficient ways, but this is fairly easy:\n<code>rolling_max :: [Int] -&gt; [Int]",
  "  (local ((define (aux result left)\n            (if (null? left)\n           \
    \     result\n                (aux (cons (apply max (cons (car left) result))\
    \ result) (cdr left)))))\n    (aux (list (car numbers)) (cdr numbers))))\n", " \
    \   (if (null? numbers)\n        empty\n        (cons (max (car numbers) (rolling_max\
    \ (cdr numbers)))\n              (rolling_max (cdr numbers)))))\n", "  (for/fold\
    \ ([max-found 0])\n            ([n (in-list numbers)])\n            (max max-found\
    \ n)))\n", "  (match numbers\n    [(list n next ...)\n     (cons n (map (max n)\
    \ (rolling_max (list next ...))))]\n    [else empty]))\n", "  (letrec ([rolling_max_seq\
    \ (lambda (numbers)\n                              (if (null? numbers)\n     \
    \                             '()\n                                  (cons (max\
    \ (car numbers) (first (rolling_max_seq (cdr numbers))))\n                   \
    \                     (rolling_max_seq (cdr numbers)))))])\n    (rolling_max_seq\
    \ numbers)))\n", "  (define (rolling_max_iter tail accumulator)\n    (if (null?\
    \ tail)\n      accumulator\n      (rolling_max_iter (cdr tail) (cons (max (car\
    \ tail) (car accumulator)) accumulator))))\n  (reverse (rolling_max_iter numbers\
    \ (list 0))))\n", "  (define maxs (list (car numbers)))\n\n  (for/fold ([max (car\
    \ numbers)])\n            ([x (in-list (cdr numbers))])\n    (set! maxs (append\
    \ maxs (list (max max x))))\n    (max max x)))\n", "  (let loop ([input (cdr numbers)]\n\
    \             [acc (list (car numbers))])\n    (if (null? input)\n        acc\n\
    \        (loop (cdr input)\n              (cons (max (car input) (car acc)) acc)))))\n",
  "  (let loop ([numbers numbers]\n             [max nil])\n    (if (empty? numbers)\n\
    \        (reverse max)\n        (loop (rest numbers)\n              (cons (if\
    \ (or (null? max)\n                            (> (first numbers) (first max)))\n\
    \                        (first numbers)\n                        (first max))\n\
    \                    max)))))\n", "  (accumulate (lambda (x prev-max) (if (&gt;\
    \ x prev-max) x prev-max)) (first numbers) (rest numbers)))\n", "  (let ([max-seen\
    \ 0])\n    (map (\u03BB (x)\n           (define new-max (max x max-seen))\n  \
    \         (set! max-seen new-max)\n           new-max)\n         numbers)))\n",
  "  (if (empty? numbers)\n      empty\n      (cons (rolling_max_aux (rest numbers)\
    \ (first numbers))\n            (rolling_max (rest numbers)))))\n", "  (define\
    \ accumulator '())\n  (define (iter numbers acc)\n    (cond\n      [(empty? numbers)\
    \ acc]\n      [(empty? acc) (iter (rest numbers) (cons (first numbers) acc))]\n\
    \      [else (iter (rest numbers) (cons (max (first numbers) (first acc)) acc))]))\n\
    \  (iter numbers accumulator))\n</code>\n", "  (define (with-max max-so-far)\n\
    \    (match numbers\n      [(cons n rest)\n       (if (&gt; n max-so-far)\n  \
    \         (cons n (with-max n))\n           (cons max-so-far (with-max max-so-far)))]\n\
    \      [empty '()]))\n  (with-max 0))\n", "  (for/fold ([max 0])\n           \
    \ ([n numbers])\n            (if (> n max)\n                n\n              \
    \  max)))\n\n", "  (define (rolling_max_iter numbers accumulated)\n    (cond ((null?\
    \ numbers)\n           (reverse accumulated))\n          ((null? accumulated)\n\
    \           (rolling_max_iter (cdr numbers) (list (car numbers))))\n         \
    \ (else\n           (rolling_max_iter (cdr numbers) (cons (max (car numbers) (car\
    \ accumulated)) accumulated)))))\n  (rolling_max_iter numbers '()))\n</code>\n\
    Questions\n\nAre there any improvements I could do on readability and performance?\n\
    What would be a functional approach to solve this problem?\n\n\n\nA:\n\nYour solution\
    \ is fine, but there are a couple of improvements that can be made:\n\nthe recursive\
    \ function <code>rolling_max_iter</code> is only ever called in one place, this\
    \ means that it's not necessary to define it separately; it can be defined as\
    \ an anonymous procedure and called directly. This is called a <code>letrec</code>\
    \ and will look like:\n<code>(define (rolling_max lst)\n  (letrec ((rolling_max_iter\
    \ (lambda (lst acc)\n                               (cond ((null? lst)\n     \
    \                                 (reverse acc))\n                           \
    \          ((null? acc)\n                                      (rolling_max_iter\
    \ (cdr lst) (list (car lst))))\n                                     (else\n \
    \                                     (rolling_max_iter (cdr lst) (cons (max (car\
    \ lst) (car acc)) acc)))))))\n    (rolling_max_iter lst '())))\n</code>\nThere's\
    \ no reason to call <code>reverse</code> just to reverse a list because it's built-in,\
    \ instead we can change the order of the accumulator by using <code>cons</code>\
    \ to attach the elements instead of <code>append</code>. This will give us:\n\
    <code>(define (rolling_max lst)\n  (letrec ((rolling_max_iter (lambda (lst acc)\n\
    \                               (cond ((null? lst)\n                         \
    \             acc)\n                                     ((null? acc)\n      \
    \                                (rolling_max_iter (cdr lst) (list (car lst))))\n\
    \                                     (else\n                                \
    \      (rolling_max_iter (cdr lst) (cons", "  (let ([max (car numbers)])\n   \
    \ (for/list ([number (in-list (cdr numbers))])\n      (begin\n        (set! max\
    \ (max max number))\n        max))))\n", "  (define (roll-max numbers maxes)\n\
    \    (cond\n      [(empty? numbers) (reverse maxes)]\n      [(empty? maxes)\n\
    \       (roll-max (rest numbers) (list (first numbers)))]\n      [else\n     \
    \  (roll-max (rest numbers) (cons (max (first numbers) (first maxes)) maxes))]))\n\
    \  (roll-max numbers (list)))\n", "  (define (rolling_max_helper numbers rolling_max)\n\
    \    (cond [(empty? numbers) rolling_max]\n          [(empty? rolling_max) (rolling_max_helper\
    \ (rest numbers) (list (first numbers))) ]\n          [else (rolling_max_helper\
    \ (rest numbers) (append rolling_max (list (max (first numbers) (last rolling_max)))))\
    \ ]\n          )\n    )\n  (rolling_max_helper numbers (list))\n  )\n", "  (define\
    \ (loop numbers max_list)\n    (cond\n      [(empty? numbers) max_list]\n    \
    \  [(< (first numbers) (first max_list))\n       (loop (rest numbers) max_list)]\n\
    \      [else\n       (loop (rest numbers) (cons (first numbers) max_list))]))\n\
    \  (reverse (loop numbers (list (first numbers)))))\n", "  (letrec ([roll (lambda\
    \ (n maxs)\n                   (cond [(null? n)\n                          (reverse\
    \ maxs)]\n                         [(< (car n) (car maxs))\n                 \
    \         (roll (cdr n) maxs)]\n                         [else\n             \
    \             (roll (cdr n) (cons (car n) maxs))]))])\n    (roll (cdr numbers)\
    \ (list (car numbers)))))\n", "  (define (inner result)\n    (cond [(empty? numbers)\
    \ empty]\n          [(empty? result) (inner (cons (first numbers) empty))]\n \
    \         [else (cons (max (first numbers) (first result)) (inner (cons (first\
    \ numbers) (rest result))))]))\n  (inner empty))\n", "  (define (iter next-max\
    \ numbers)\n    (if (null? numbers)\n        '()\n        (cons next-max (iter\
    \ (max (car numbers) next-max) (cdr numbers)))))\n  (if (null? numbers)\n    \
    \  '()\n      (iter (car numbers) (cdr numbers))))\n", "  (define (iter max-so-far\
    \ numbers-left result)\n    (if (null? numbers-left)\n        result\n       \
    \ (let ([new-max (max max-so-far (car numbers-left))])\n          (iter new-max\
    \ (cdr numbers-left) (cons new-max result)))))\n  (reverse (iter 0 numbers '())))\n",
  "  (define (rolling_max1 numbers max)\n    (cond [(empty? numbers) '()]\n      \
    \    [(> (first numbers) max) (cons (first numbers) (rolling_max1 (rest numbers)\
    \ (first numbers)))]\n          [else (cons max (rolling_max1 (rest numbers) max))]))\n\
    \  (rolling_max1 numbers (first numbers)))\n", "  (foldl (\u03BB (cur acc)\n \
    \          (cons (apply max (cons cur acc))\n                 acc))\n        \
    \ '()\n         numbers))\n", "  (define (rolling_max_h numbers current_max current_maxes)\n\
    \    (if (empty? numbers)\n        current_maxes\n        (let ([new_max (max\
    \ (first numbers) current_max)])\n          (rolling_max_h (rest numbers) new_max\
    \ (append current_maxes (list new_max))))))\n  (rolling_max_h numbers -inf.0 '()))\n",
  "  (let loop ([sorted (sort numbers <)])\n    (define (recurse a b)\n      (if (null?\
    \ a)\n          (list (car b))\n          (cons (car b) (recurse (cdr a) b))))\n\
    \    (if (null? (cdr sorted))\n        (list (car sorted))\n        (recurse sorted\
    \ sorted))))\n", "  (for/fold ([max 0]) ([x (in-list numbers)])\n    (max x max)))\n",
  "    (if (empty? numbers)\n        (error \"expected non-empty list!\")\n      \
    \  (cond\n            [(empty? (rest numbers))\n             '(max (first numbers))]\n\
    \            [else\n             (cons (max (first numbers) (first (rolling_max\
    \ (rest numbers))))\n                   (rolling_max (rest numbers)))])))\n",
  "  (let loop ([numbers numbers]\n             [max-so-far (car numbers)]\n     \
    \        [result '()])\n    (if (null? numbers)\n        (reverse result)\n  \
    \      (loop (cdr numbers)\n              (if (and (not (null? (car numbers)))\n\
    \                       (&gt; max-so-far (car numbers)))\n                  max-so-far\n\
    \                  (car numbers))\n              (cons max-so-far result)))))\n",
  "  (if (empty? numbers) empty\n      (cons (max-elt numbers) (rolling_max (rest\
    \ numbers)))))\n", "  (cond\n    [(empty? numbers) '()]\n    [(one? numbers) (first\
    \ numbers)]\n    [else (append\n           (rolling_max (rest numbers))\n    \
    \       (list (max (first numbers) (last (rolling_max (rest numbers))))))]))\n",
  "  (let loop ([numbers numbers]\n             [maxs    null])\n    (cond [(empty?\
    \ numbers) reverse maxs]\n          [(> (first numbers) (first maxs))\n      \
    \     (loop (rest numbers) (cons (first numbers) maxs))]\n          [else\n  \
    \         (loop (rest numbers) (cons (first maxs) maxs))])))\n</code>\n\n<code>#lang\
    \ racket\n", "  (let loop ([numbers numbers]\n             [accumulator null])\n\
    \    (cond [(null? numbers)\n           (reverse accumulator)]\n          [(null?\
    \ accumulator)\n           (loop (cdr numbers)\n                 (list (car numbers)))]\n\
    \          [else\n           (let ([current (car numbers)]\n                 [max\
    \ (car accumulator)])\n             (loop (cdr numbers)\n                   (cons\
    \ (if (> current max)\n                             current\n                \
    \             max)\n                         accumulator)))])))\n", "  (letrec\
    \ ([recur (lambda (lst maxes)\n                    (if (null? lst)\n         \
    \               maxes\n                        (let* ([current (car lst)]\n  \
    \                             [prev-max (if (null? maxes)\n                  \
    \                           current\n                                        \
    \     (car maxes))])\n                          (recur (cdr lst)\n           \
    \                      (cons (if (&gt; current prev-max)\n                   \
    \                        current\n                                           prev-max)\n\
    \                                       maxes)))))])\n    (recur numbers '())))\n",
  "  (accumulate max -inf.0 numbers))\n", "  (if (null? numbers)\n      (error \"\
    Empty list not allowed\")\n    (cond\n      ((null? (cdr numbers)) '(0))\n   \
    \   (else (cons (max (car numbers) (car (rolling_max (cdr numbers))))\n      \
    \            (rolling_max (cdr numbers)))))))\n", "  (if (null? numbers) '()\n\
    \      (let ((m (rolling_max (cdr numbers))))\n        (cons (if (&gt; (car numbers)\
    \ (car m)) (car numbers) (car m)) m))))\n</code>\n", "  (if (empty? numbers)\n\
    \      '()\n      (let ([max (max (first numbers) (apply max (rest numbers)))])\n\
    \        (cons max (rolling_max (rest numbers))))))\n", "  (if (empty? numbers)\n\
    \      (error \"Empty list.\")\n      (let loop ([rest (cdr numbers)]\n      \
    \           [max (car numbers)]\n                 [result (list max)])\n     \
    \   (if (empty? rest)\n            result\n            (loop (cdr rest)\n    \
    \              (max (car rest) max)\n                  (cons (max (car rest) max)\
    \ result))))))\n", "  (if (null? numbers)\n      '()\n      (cons (max (car numbers)\
    \ (car (rolling_max (cdr numbers))))\n            (rolling_max (cdr numbers)))))\n",
  "  (let loop ([max 0] [numbers numbers] [result '()])\n    (cond [(empty? numbers)\
    \ (reverse result)]\n          [(< max (first numbers)) (loop (first numbers)\
    \ (rest numbers) (cons (first numbers) result))]\n          [else (loop max (rest\
    \ numbers) (cons max result))])))\n", "  (let ([maxs (cons (car numbers) (map\
    \ (lambda (x next) (if (&gt; next x) next x)) (cdr numbers)))])\n    (cons (car\
    \ numbers) (map (lambda (x next) (if (&gt; next x) next x)) (cdr numbers)))))\n",
  "  (if (null? numbers)\n      '()\n      (cons (apply max numbers)\n           \
    \ (rolling_max (cdr numbers)))))\n", "  (if (null? numbers)\n      '()\n     \
    \ (cons (max (car numbers) (car (rolling_max (cdr numbers))))\n            (rolling_max\
    \ (cdr numbers)))))\n", "  (local [(define (each-pair lst)\n            (if (empty?\
    \ lst)\n                empty\n                (cons (list (first lst) (second\
    \ lst))\n                      (each-pair (rest (rest lst))))))]\n    (local [(define\
    \ (map-fn pair)\n              (if (or (empty? pair)\n                      (=\
    \ (first pair) (second pair)))\n                  (first pair)\n             \
    \     (max (first pair) (second pair))))]\n      (map map-fn (each-pair numbers)))))\n\
    </code>\nA few things I know I should work on:\n\nI'm not sure about the name\
    \ for the first helper function, and if it's a proper usage of <code>local</code>.\n\
    I think I'm not sure how to use <code>local</code> either.\nI did not manage to\
    \ get the second helper function to work as it's intended. For example, if the\
    \ sequence is <code>(1 1 2 2 1 1 1 1 1 1 2 2 1 1 1 1 1 1 1 1)</code>, the map\
    \ function will return a list of <code>(1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\
    \ 2)</code>, instead of the expected <code>(1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\
    \ 2 2 2)</code>. \n\nIf this is common enough, how do I name it?\nI'm open to\
    \ any kind of feedback regarding naming, idiomatic usage of Scheme, anything that'd\
    \ help me improve.\n\n\nA:\n\nInstead of <code>each-pair</code>, you could write\
    \ <code>pair-seq</code>, since it's not a for-each loop.  You might want to use\
    \ <code>define</code> instead of <code>define-values</code> in the body of <code>rolling-max</code>.\
    \  The problem with <code>map-fn</code> is that it should be <code>first</code>\
    \ the first time, but it's not.  A simple fix is to make it a lambda, instead\
    \ of a define.\n<code>(define (rolling-max lst)\n  (local [(define (pair-seq lst)\n\
    \            (if (empty? lst)\n                empty\n                (cons (",
  "  (let loop ([numbers numbers]\n             [subsequence null]\n             [max_seen\
    \ null])\n    (cond [(empty? numbers) (reverse subsequence)]\n          [else\n\
    \           (let ([element (first numbers)])\n             (cond [(> element max_seen)\n\
    \                    (loop (rest numbers)\n                          (cons element\
    \ subsequence)\n                          element)]\n                   [else\n\
    \                    (loop (rest numbers)\n                          (cons max_seen\
    \ subsequence)\n                          max_seen)]))])))\n", "  (define (max-acc\
    \ acc n)\n    (if (null? n) acc\n      (if (> (car n) acc) (max-acc (car n) (cdr\
    \ n))\n          (max-acc acc (cdr n)))))\n  (define (roll_max n acc)\n    (if\
    \ (null? n) acc\n      (cons (max-acc 0 n) (roll_max (cdr n) acc))))\n  (reverse\
    \ (roll_max numbers '())))\n", "  (define (inner numbers m)\n    (if (empty? numbers)\n\
    \        empty\n        (cons m (inner (rest numbers) (max m (first numbers))))))\n\
    \  (inner numbers -Infinity))\n", "  (let loop ([numbers numbers]\n          \
    \   [max (car numbers)])\n    (cond [(empty? numbers) '()]\n          [(> (car\
    \ numbers) max) (loop (cdr numbers) (car numbers))]\n          [else (cons max\
    \ (loop (cdr numbers) max))])))\n", "  (define (go max-so-far numbers)\n    (if\
    \ (null? numbers)\n        '()\n        (cons max-so-far (go (max max-so-far (car\
    \ numbers)) (cdr numbers)))))\n  (go -inf.0 numbers))\n", "  (let loop ([numbers\
    \ numbers]\n             [acc '()])\n    (if (null? numbers)\n        (reverse\
    \ acc)\n        (let* ([max (apply max numbers)]\n               [numbers (cdr\
    \ numbers)])\n          (loop numbers (cons max acc))))))\n", "  (let loop ([numbers\
    \ numbers]\n             [max_so_far -1]\n             [acc '()])\n    (if (null?\
    \ numbers)\n        (reverse acc)\n        (if (max (car numbers) max_so_far)\n\
    \            (loop (cdr numbers) (car numbers) (cons (car numbers) acc))\n   \
    \         (loop (cdr numbers) max_so_far (cons max_so_far acc))))))\n", "  (define\
    \ (inner current-max result)\n    (cond\n      [(empty? numbers) (reverse result)]\n\
    \      [(> (first numbers) current-max) (inner (first numbers) (cons (first numbers)\
    \ result))]\n      [else (inner current-max (cons current-max result))]))\n  (inner\
    \ 0 '()))\n", "  (if (null? numbers)\n      '()\n      (let* ((current-max (apply\
    \ max numbers))\n             (rest (if (= (car numbers) current-max)\n      \
    \                 (cdr numbers)\n                       numbers)))\n        (cons\
    \ current-max (rolling_max rest)))))\n", "  (cond [(empty? numbers) empty]\n \
    \       [(pair? numbers) (define max (first numbers))\n                      \
    \   (define result (list max))\n                         (for ([i (in-range (sub1\
    \ (length numbers)))])\n                           (define current-value (list-ref\
    \ numbers (add1 i)))\n                           (if (> current-value max)\n \
    \                              (set! max current-value))\n                   \
    \        (set! result (append result (list max))))\n                         result]\n\
    \        [else empty]))", "  (letrec ([aux (\u03BB (numbers acc max-so-far)\n\
    \                 (cond [(empty? numbers) (reverse acc)]\n                   \
    \    [(> (first numbers) max-so-far)\n                        (aux (rest numbers)\
    \ (cons (first numbers) acc) (first numbers))]\n                       [else (aux\
    \ (rest numbers) (cons max-so-far acc) max-so-far)]))])\n    (aux numbers empty\
    \ 0)))\n", "  (for/fold ([rolling-max -inf.0])\n            ([n numbers])\n  \
    \          (max rolling-max n)))\n", "  (if (null? numbers)\n      '()\n     \
    \ (cons (apply max numbers)\n            (rolling_max (cdr numbers)))))\n</code>\n\
    The above solution solves the problem the way the submitter was intending to solve\
    \ the problem. I think it is worth showing how to solve the problem the way I\
    \ think the submitter should want to solve the problem. I believe the submitter\
    \ wants to solve the problem by using a window.\n<code>#lang racket\n", "  (let\
    \ loop ([numbers numbers]\n             [max-number (first numbers)]\n       \
    \      [result '()])\n    (if (null? numbers)\n        (reverse result)\n    \
    \    (let ([first-number (first numbers)])\n          (if (&gt; first-number max-number)\n\
    \              (loop (rest numbers) first-number (cons first-number result))\n\
    \              (loop (rest numbers) max-number (cons max-number result)))))))\n",
  "  (if (empty? numbers)\n      numbers\n      (cons (max (first numbers) (if (empty?\
    \ (rest numbers))\n                                    (first numbers)\n     \
    \                               (rolling_max (rest numbers))))\n            (rolling_max\
    \ (rest numbers)))))\n", "  (let loop ([numbers numbers]\n             [max 0]\n\
    \             [result null])\n    (if (null? numbers)\n        (reverse result)\n\
    \        (loop (cdr numbers)\n              (max (car numbers) max)\n        \
    \      (cons max result)))))\n", "  (define (r_max current-max remaining)\n  \
    \  (if (null? remaining)\n        '()\n        (cons current-max (r_max (max current-max\
    \ (car remaining)) (cdr remaining)))))\n  (r_max (car numbers) (cdr numbers)))\n\
    ```\n\n```racket\n#lang racket\n", "  (let loop ([numbers numbers]\n         \
    \    [max-so-far -100000]\n             [result '()])\n    (if (null? numbers)\n\
    \        (reverse result)\n        (loop (cdr numbers)\n              (if (&gt;\
    \ (car numbers) max-so-far)\n                  (car numbers)\n               \
    \   max-so-far)\n              (cons max-so-far result)))))\n", "  (cond [(empty?\
    \ numbers) '()]\n        [else (cons (max (first numbers)\n                  \
    \       (apply max (rest numbers)))\n                    (rolling_max (rest numbers)))]))\n",
  "  (define (rolling_max_iter numbers rolling_max)\n    (if (null? numbers)\n   \
    \     rolling_max\n        (let ((n (car numbers)))\n          (rolling_max_iter\
    \ (cdr numbers) (cons (if (null? rolling_max) n (max n (car rolling_max))) rolling_max)))))\n\
    \  (reverse (rolling_max_iter numbers '())))\n</code>\nThis can now be used as\
    \ follows:\n<code>#lang racket\n", "  (let loop ([numbers numbers]\n         \
    \    [max 0]\n             [result '()])\n    (cond\n      [(empty? numbers) (reverse\
    \ result)]\n      [(> (first numbers) max)\n       (loop (rest numbers)\n    \
    \         (first numbers)\n             (cons (first numbers) result))]\n    \
    \  [else\n       (loop (rest numbers)\n             max\n             (cons max\
    \ result))])))\n", "  (if (null? numbers)\n      '()\n      (cons (max (car numbers)\
    \ (apply max (cdr numbers)))\n            (rolling_max (cdr numbers)))))\n", " \
    \ (cond ((null? numbers) null)\n        ((null? (cdr numbers)) numbers)\n    \
    \    (else (cons (max (car numbers) (car (cdr numbers)))\n                   \
    \ (rolling_max (cdr numbers))))))\n", "  (cond\n    [(empty? numbers) '()]\n \
    \   [(= 1 (length numbers)) numbers]\n    [else\n     (cons (max (first numbers)\
    \ (second numbers))\n           (rolling_max (cdr numbers)))]))\n", "  (foldl\
    \ (lambda (x max-so-far) (cons (max x max-so-far) max-so-far)) numbers))\n", " \
    \ (accumulate (lambda (max-candidate current)\n                (if (&gt; max-candidate\
    \ current)\n                    max-candidate\n                    current))\n\
    \              0\n              numbers))\n", "  (let max (-fl max numbers)\n\
    \    (if (empty? numbers)\n        '()\n        (cons max (rolling_max (rest numbers))))))\n",
  "  (if (null? numbers)\n      null\n      (cons (apply max numbers)\n          \
    \  (rolling_max (cdr numbers)))))\n", "  (if (null? numbers)\n      '()\n    \
    \  (cons (max (car numbers) (car (rolling_max (cdr numbers))))\n            (rolling_max\
    \ (cdr numbers)))))\n", "  (foldr (lambda (current-max current-number)\n     \
    \      (list (max current-max current-number)))\n         numbers))\n", "  (cond\
    \ [(empty? numbers) empty]\n        [(= 1 (length numbers)) numbers]\n       \
    \ [else (append (rolling_max (rest numbers)) (list (max (first numbers) (last\
    \ (rolling_max (rest numbers))))))]))\n", "  (apply max (list-of (list-ref numbers\
    \ 0))))\n", "  (for/fold ([result null])\n            ([number numbers])\n   \
    \         (if (null? result)\n                (list number)\n                (append\
    \ result (list (max number (last result)))))))\n", "  (define (recursive numbers\
    \ prev-max current-max)\n    (if (empty? numbers)\n        (reverse current-max)\n\
    \        (if (&gt; (first numbers) prev-max)\n            (recursive (rest numbers)\
    \ (first numbers) (cons (first numbers) current-max))\n            (recursive\
    \ (rest numbers) prev-max (cons prev-max current-max)))))\n  (recursive numbers\
    \ 0 '()))\n", "  (if (null? numbers)\n      '()\n      (let ((curr-max (apply\
    \ max numbers)))\n        (cons curr-max (rolling_max (cdr numbers))))))\n", " \
    \ (define (rolling_max_acc curr_max acc)\n    (cond\n      [(empty? numbers) (reverse\
    \ acc)]\n      [(> (first numbers) curr_max) (rolling_max_acc (first numbers)\
    \ (cons (first numbers) acc))]\n      [else (rolling_max_acc curr_max (cons curr_max\
    \ acc))]))\n  (rolling_max_acc (first numbers) (list (first numbers))))\n", " \
    \ (define (generate_rolling max-so-far rest-of-numbers)\n    (cond [(empty? rest-of-numbers)\
    \ max-so-far]\n          [(> (first rest-of-numbers) max-so-far) (generate_rolling\
    \ (first rest-of-numbers) (rest rest-of-numbers))]\n          [else (generate_rolling\
    \ max-so-far (rest rest-of-numbers))]))\n  (generate_rolling (first numbers) (rest\
    \ numbers)))\n\n", "  (local [(define (run rolling_max numbers)\n            (if\
    \ (null? numbers)\n                (reverse rolling_max)\n                (let\
    \ ([x (car numbers)])\n                  (run (if (or (null? rolling_max)\n  \
    \                             (&gt; x (car rolling_max)))\n                  \
    \         (cons x rolling_max)\n                           rolling_max))\n   \
    \               (cdr numbers))))]\n    (run (list) numbers)))\n", "  (define (rolling_max_iter\
    \ numbers maxes)\n    (cond\n      [(empty? numbers) maxes]\n      [(> (first\
    \ numbers) (first maxes))\n       (rolling_max_iter (rest numbers) (cons (first\
    \ numbers) maxes))]\n      [else\n       (rolling_max_iter (rest numbers) (cons\
    \ (first maxes) maxes))]))\n  (reverse (rolling_max_iter numbers (list 0))))\n",
  "  (let loop ([numbers numbers]\n             [accum   '()])\n    (cond\n      [(empty?\
    \ numbers) (reverse accum)]\n      [(empty? accum)   (loop (rest numbers) (list\
    \ (first numbers)))]\n      [else            (loop (rest numbers) (cons (max (first\
    \ numbers) (first accum)) accum))])))\n", "  (define (rolling_max_acc accumulator)\n\
    \    (if (null? numbers)\n        accumulator\n        (rolling_max_acc (append\
    \ accumulator (list (max (car numbers) (car accumulator))))\n                \
    \         (cdr numbers))))\n  (rolling_max_acc (list (car numbers))))\n", "  (define\
    \ (go x maxs)\n    (cond [(empty? x) '()]\n          [(not (empty? maxs)) (cons\
    \ (max (first x) (first maxs)) (go (rest x) (rest maxs)))]\n          [else (cons\
    \ (first x) (go (rest x) (rest x)))]))\n  (go numbers '()))\n", "  (define max-numbers\
    \ '())\n  (define (rolling-max-iter numbers max-acc)\n    (cond\n      [(empty?\
    \ numbers) (reverse max-acc)]\n      [(= (first numbers) max-acc) (rolling-max-iter\
    \ (rest numbers) max-acc)]\n      [(> (first numbers) max-acc) (rolling-max-iter\
    \ (rest numbers) (first numbers))]\n      [else (rolling-max-iter (rest numbers)\
    \ max-acc)]))\n  (rolling-max-iter numbers 0))\n\n", "  (define all_maxes (list\
    \ (first numbers)))\n  (for/fold ([max (first numbers)]) ([number (in-list (rest\
    \ numbers))])\n    (define new_max (if (&gt; max number) max number))\n    (append\
    \ all_maxes (list new_max))\n    new_max))\n", "  (if (null? numbers) '()\n  \
    \    (cons (max (car numbers) (apply max (cdr numbers)))\n            (rolling_max\
    \ (cdr numbers)))))\n", "  (if (empty? numbers)\n      '()\n      (define curr_max\
    \ (max (first numbers) 0))\n      (cons curr_max (rolling_max (rest numbers)))))\n",
  "  (define (inner numbers max-so-far)\n    (cond\n      [(empty? numbers) empty]\n\
    \      [(> (first numbers) max-so-far)\n       (cons max-so-far (inner (rest numbers)\
    \ (first numbers)))]\n      [else\n       (cons max-so-far (inner (rest numbers)\
    \ max-so-far))]))\n  (inner numbers (first numbers)))\n", "  (map max numbers\
    \ (cdr numbers)))\n", "  (if (null? numbers)\n      '()\n      (let* ([current-max\
    \ (max (first numbers) 0)]\n             [next-max (max (second numbers) current-max)])\n\
    \        (cons current-max (rolling_max (cons next-max (cddr numbers)))))))\n",
  "  (if (null? numbers) '()\n      (cons (apply max numbers) (rolling_max (cdr numbers)))))\n",
  "  (define (roll-max numbers max)\n    (cond ((null? numbers) max)\n          ((>\
    \ (car numbers) max) (roll-max (cdr numbers) (car numbers)))\n          (else\
    \ (roll-max (cdr numbers) max))))\n  (map (\u03BB (num) (roll-max numbers num))\
    \ numbers))\n", "  (define (max_iter numbers max)\n    (cond\n      [(empty? numbers)\
    \ (reverse max)]\n      [(empty? max)\n       (max_iter (rest numbers) (list (first\
    \ numbers)))]\n      [else\n       (max_iter (rest numbers) (cons (max (first\
    \ numbers) (first max)) max))]))\n  (max_iter numbers '()))\n", "  (if (null?\
    \ numbers) '()\n      (cons (foldl max (car numbers) numbers)\n            (rolling_max\
    \ (cdr numbers)))))\n", "  (if (empty? numbers) empty\n      (cons (max (first\
    \ numbers) (max-of-a-rest numbers))\n            (rolling_max (rest numbers)))))\n",
  "  (cond [(empty? numbers) empty]\n        [(empty? (rest numbers)) numbers]\n \
    \       [else (cons (apply max (first numbers) (second numbers))\n           \
    \         (rolling_max (rest numbers)))]))\n</code>\nWhat I don't like here is\
    \ that the call to <code>max</code> has to be wrapped with <code>apply</code>\
    \ to allow varying number of elements, because <code>max</code> expects a list.\n\
    This is not so much a problem for <code>max</code>, but it is for other functions\
    \ that expect a sequence of arguments. What happens in those cases, if I want\
    \ to wrap them in a <code>let</code> binding? What if I want to pass it to another\
    \ function as an argument?\nI know I can use <code>foldl</code> to solve this\
    \ problem, but I want to know if there is a native Racket way to fix this. Also,\
    \ <code>foldl</code> is slower than my algorithm (in case it matters).\n\n\nA:\n\
    \n<code>max</code> is variadic, so use <code>max</code>.\n<code>(define (rolling_max\
    \ lst)\n  (when (not (empty? lst))\n    (cons (apply max lst)\n          (rolling_max\
    \ (rest lst)))))\n</code>\nIt's unnecessary to check if <code>lst</code> is empty\
    \ again in the recursive call.\n", "  (for/fold ([maxes '()]) ([number numbers])\n\
    \    (append maxes (list (max number (car maxes))))))\n", "  (define (rolling_max_aux\
    \ numbers max_sofar)\n    (if (null? numbers)\n        '()\n        (cons max_sofar\
    \ (rolling_max_aux (cdr numbers) (max max_sofar (car numbers))))))\n  (rolling_max_aux\
    \ numbers (car numbers)))\n", "    (let loop ((l numbers) (acc (list (car numbers))))\n\
    \        (cond\n            [(null? l) (reverse acc)]\n            [(< (car l)\
    \ (car acc)) (loop (cdr l) (cons (car acc) acc))]\n            [else (loop (cdr\
    \ l) (cons (car l) acc))])))\n", "  (define (roll_max numbers so-far)\n    (if\
    \ (null? numbers)\n        so-far\n        (let ((max (max (car numbers) (car\
    \ so-far))))\n          (roll_max (cdr numbers) (cons max so-far)))))\n  (reverse\
    \ (roll_max numbers (list (car numbers)))))\n</code>\n", "  (foldl (lambda (n\
    \ max-so-far)\n           (cond ((&gt; n max-so-far) (cons n max-so-far))\n  \
    \               (else max-so-far)))\n         '()\n         numbers))\n", "  (define\
    \ helper (lambda (numbers max)\n                   (cond\n                   \
    \  [(empty? numbers) empty]\n                     [(> (first numbers) max) (cons\
    \ (first numbers) (helper (rest numbers) (first numbers)))]\n                \
    \     [else (cons max (helper (rest numbers) max))])))\n  (helper numbers -(expt\
    \ 2 (fl + 1)) ))\n</code>\nI am trying to complete the problem for a \"rolling\"\
    \ maximum (e.g. find the max for the next 3 elements of a list in a given moment).\
    \ \nSo, the only thing that I really changed was the <code>cond</code> expression\
    \ - comparing <code>(first numbers)</code> with the <code>max</code> value found\
    \ until that moment.\nThis implementation is not efficient in the sense that I\
    \ can't iterate over a finite number of elements.\nDoes anyone have a hint on\
    \ how to solve it?\n\n\nA:\n\nTo change the way you compare the elements, you\
    \ could just pass in a predicate as a parameter.\nSo you'd want to call something\
    \ like\n<code>(rolling-max some-list &gt;)\n</code>\nWhich would give you the\
    \ max and\n<code>(rolling-max some-list &lt;)\n</code>\nwould give you the min.\n\
    The following will do what you want, but the code is identical to yours, so you\
    \ can probably do it yourself now.\n<code>(define (rolling-max lst pred)\n  (define\
    \ helper (lambda (lst max)\n                   (cond\n                     [(empty?\
    \ lst) empty]\n                     [(pred (first lst) max) (cons (first lst)\
    \ (helper (rest lst) (first lst)))]\n                     [else (cons max (helper\
    \ (rest lst) max))])))\n  (helper lst (first lst)))\n</code>\n", "  (if (null?\
    \ numbers)\n      '()\n      (cons (apply max numbers)\n            (rolling_max\
    \ (cdr numbers)))))\n", "  (cond\n    [(empty? numbers) '()]\n    [(empty? (rest\
    \ numbers)) numbers]\n    [else\n     (cons (max (first numbers) (first (rolling_max\
    \ (rest numbers))))\n           (rolling_max (rest numbers)))]))\n", "  (define\
    \ (go mxs n)\n    (cond\n      [(empty? n) mxs]\n      [(not (empty? mxs))\n \
    \      (cons (max (first mxs) (first n)) (go (rest mxs) (rest n)))]\n      [else\
    \ (go (cons (first n) mxs) (rest n))]))\n  (go empty (reverse numbers)))\n</code>\n\
    See here\n", "  (let loop ([numbers numbers]\n             [rolling-max '()])\n\
    \    (if (null? numbers)\n        rolling-max\n        (let* ([current-max (apply\
    \ max numbers)]\n               [rolling-max (cons current-max rolling-max)])\n\
    \          (loop (cdr numbers) rolling-max)))))\n", "  (define (rolling_max_iter\
    \ numbers rolling_max)\n    (if (null? numbers)\n        '()\n        (cons (max\
    \ (car numbers) rolling_max)\n              (rolling_max_iter (cdr numbers) (max\
    \ (car numbers) rolling_max)))))\n  (rolling_max_iter numbers 0))\n", "    (if\
    \ (not numbers)\n        '()\n        (cons (max numbers) (rolling_max (cdr numbers)))))\n",
  "  (define (inner acc n)\n    (let* ([current-max (if (null? acc) n (max (car acc)\
    \ n))]\n           [new-acc (cons current-max acc)])\n      (if (null? (cdr numbers))\n\
    \          (reverse new-acc)\n          (inner new-acc (cadr numbers)))))\n  (inner\
    \ '() (car numbers)))\n", "  (if (null? numbers) \n      '()\n      (cons (apply\
    \ max numbers)\n            (rolling_max (cdr numbers)))))\n", "  (define acc-numbers\
    \ (cons 0 numbers))\n  (map max (sequence 0 (length numbers)) acc-numbers))\n",
  "  (cond\n    [(empty? numbers) empty]\n    [(< (first numbers) (second numbers))\
    \ (cons (second numbers) (rolling_max (rest numbers)))]\n    [else (cons (first\
    \ numbers) (rolling_max (rest numbers)))]))\n```\n\n5. Write a function (sum-xor-max\
    \ numbers) that returns the sum of numbers in the given list or the\nvalue of\
    \ the single largest number if only one number is present.\n\n```\n#lang racket\n",
  "  (define (go ns maxs)\n    (cond [(empty? ns) maxs]\n          [(= (first ns)\
    \ (first maxs)) (go (rest ns) maxs)]\n          [(> (first ns) (first maxs)) (go\
    \ (rest ns) (cons (first ns) maxs))]\n          [else (go (rest ns) maxs)]))\n\
    \  (reverse (go numbers (list (first numbers)))))\n", "  (define (helper rmax\
    \ (numbers rest))\n    (cond [(empty? numbers) rmax]\n          [(< (first numbers)\
    \ (first rest))\n           (helper rmax (rest numbers) (rest rest))]\n      \
    \    [else (helper (cons (first numbers) rmax) (rest numbers) numbers)]))\n  (reverse\
    \ (helper empty numbers numbers)))\n", "  (define (rolling_max_helper accum numbers)\n\
    \    (cond [(empty? numbers) accum]\n          [(and (empty? accum) (not (empty?\
    \ numbers)))\n           (rolling_max_helper (list (first numbers)) (rest numbers))]\n\
    \          [(and (not (empty? accum)) (not (empty? numbers)))\n           (rolling_max_helper\
    \ (append accum (list (max (first accum) (first numbers)))) (rest numbers))]))\n\
    \  (rolling_max_helper '() numbers))\n</code>\nThe function works fine, the problem\
    \ is the time complexity. I was thinking of making use of the fact that list elements\
    \ are ordered and then drop the beginning of the list once the maximum is found,\
    \ but I can't see how I could achieve this without reducing the readability of\
    \ the code. Any ideas?\n\n\nA:\n\nAs usual, it's much simpler than you might think:\n\
    <code>(define (rolling-max numbers)\n  (foldl (lambda (max x) (cons (max x) max))\n\
    \         null\n         numbers))\n</code>\n", "  (define (rolling_max-h numbers\
    \ acc)\n    (cond\n      [(empty? numbers) (reverse acc)]\n      [(&gt; (first\
    \ numbers) (first acc)) (rolling_max-h (rest numbers) (cons (first numbers) acc))]\n\
    \      [else (rolling_max-h (rest numbers) (cons (first acc) acc))]))\n  (rolling_max-h\
    \ numbers (list (first numbers))))\n", "  (rolling_max_helper numbers (list)))\n",
  "  (let loop ([max 0] [numbers numbers] [result '()])\n    (cond\n      [(empty?\
    \ numbers) (reverse result)]\n      [(> (first numbers) max) (loop (first numbers)\
    \ (rest numbers) (cons (first numbers) result))]\n      [else (loop max (rest\
    \ numbers) (cons max result))])))\n", "  (let loop ([numbers numbers]\n      \
    \       [roll-max numbers])\n    (cond\n      [(empty? numbers) reverse roll-max]\n\
    \      [(> (first numbers) (first roll-max))\n       (loop (rest numbers) (cons\
    \ (first numbers) roll-max))]\n      [else\n       (loop (rest numbers) (cons\
    \ (first roll-max) roll-max))])))\n", "  (define (rolling_max_helper numbers max)\n\
    \    (cond\n      ((null? numbers) '())\n      ((< (car numbers) max) (rolling_max_helper\
    \ (cdr numbers) max))\n      (else (cons (car numbers) (rolling_max_helper (cdr\
    \ numbers) (car numbers))))))\n  (rolling_max_helper numbers (car numbers)))\n\
    ```\n\n```\n> (rolling_max '(1 2 3 4 5 4 3 2 1))\n'(1 2 3 4 5 5 5 5 5)\n> (rolling_max\
    \ '(5 4 3 2 1))\n'(5 5 5 5 5)\n> (rolling_max '(1 2 3 4 5 5 5 5 5))\n'(1 2 3 4\
    \ 5 5 5 5 5)\n> (rolling_max '(0))\n'(0)\n> (rolling_max '())\n'()\n```\n\n##\
    \ 6. Add a check for empty list to the code.\n\n```racket\n#lang racket\n", " \
    \ (if (null? numbers)\n      '()\n      (cons (apply max numbers)\n          \
    \  (rolling_max (cdr numbers)))))\n", "  (letrec ((local-rolling-max (lambda (maxed\
    \ rolling-max-sofar numbers)\n                                (if (null? numbers)\n\
    \                                    rolling-max-sofar\n                     \
    \               (local-rolling-max (append maxed (list (car numbers)))\n     \
    \                                                  (append rolling-max-sofar\n\
    \                                                               (list (foldr max\
    \ -Inf maxed)))\n                                                       (cdr numbers))))))\n\
    \    (local-rolling-max '() '() numbers)))\n</code>\nAnd for the input list <code>(10\
    \ 2 5 6 8 10 15 13 9 7)</code> it returns:\n<code>'(10 10 10 10 10 10 15 15 15\
    \ 15)\n</code>\nAnother solution using <code>foldr</code>:\n<code>#lang racket\n",
  "  (if (null? numbers)\n      '()\n      (cons (apply max numbers)\n           \
    \ (rolling_max (cdr numbers)))))\n", "  (if (null? numbers)\n      '()\n     \
    \ (cons (apply max numbers)\n            (rolling_max (cdr numbers)))))\n", " \
    \ (if (empty? numbers)\n      numbers\n      (let* ([max (apply max numbers)]\n\
    \             [rest (cdr numbers)])\n        (cons max (rolling_max rest)))))\n",
  "  (letrec ([ahead (cdr numbers)]\n           [rec (lambda (ahead results)\n   \
    \               (if (null? ahead)\n                      (reverse results)\n \
    \                     (rec (cdr ahead)\n                           (let* ([local_max\
    \ (max (car ahead) (car results))]\n                                  [next_max\
    \ (max local_max (car results))])\n                             (cons next_max\
    \ results)))))])\n    (rec ahead numbers)))\n", "  (match numbers\n    ['() '()]\n\
    \    [(cons number-1 numbers-1)\n     (cons (max number-1 (rolling_max numbers-1))\n\
    \           (rolling_max numbers-1))]))\n", "  (if (null? numbers)\n      '()\n\
    \      (cons (apply max numbers)\n            (rolling_max (cdr numbers)))))\n",
  "  (cond\n    [(empty? numbers) (list)]\n    [(> (first numbers) 0)\n     (cons\
    \ (first numbers) (rolling_max (rest numbers)))]\n    [else (rolling_max (rest\
    \ numbers))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
