name: HumanEval_19_sort_numbers
language: rkt
prompt: "#lang racket\n\n;; Input is a space-delimited string of numberals from 'zero'\
  \ to 'nine'.\n;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five',\
  \ 'six', 'seven', 'eight' and 'nine'.\n;; Return the string with numbers sorted\
  \ from smallest to largest\n(define (sort_numbers numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"three\"\
  ) \"three\")\n    (check-equal? (candidate \"three five nine\") \"three five nine\"\
  )\n    (check-equal? (candidate \"five zero four seven nine eight\") \"zero four\
  \ five seven eight nine\")\n    (check-equal? (candidate \"six five four three two\
  \ one zero\") \"zero one two three four five six\")\n))\n\n(test-humaneval)"
completions: ["  (define number-to-digit (list 'zero 'one 'two 'three 'four 'five\
    \ 'six 'seven 'eight 'nine))\n  (define digit-to-number (list '0 '1 '2 '3 '4 '5\
    \ '6 '7 '8 '9))\n  (define (number-to-digit num) (list-ref number-to-digit num))\n\
    \  (define (digit-to-number num) (list-ref digit-to-number num))\n  (define (map-flatten\
    \ l) (apply append (map list l)))\n  (define (sort-num-strings l) (sort l string<?))\n\
    \  (define (strip-digit l) (map digit-to-number l))\n  (define (strip-numbers\
    \ l) (map-flatten (map strip-digit l)))\n  (define (make-digits l) (map number-to-digit\
    \ l))\n  (define (make-numbers l) (map make-digits l))\n  (define (make-number-strings\
    \ l) (sort-num-strings (map make-numbers l)))\n  (define (format-number-strings\
    \ l) (string-join l))\n  (format-number-strings (make-number-strings (strip-numbers\
    \ (string-split numbers)))))", "  (apply string-append\n         (sort (list->list-of-strings\
    \ numbers)\n               (lambda (s1 s2)\n                 (string<? s1 s2)))))\n\
    ```\n\n```\n    (check-expect (sort_numbers \"one two two three\") \"one one two\
    \ two three\")\n    (check-expect (sort_numbers \"four five three two one\") \"\
    four one two three five\")\n    (check-expect (sort_numbers \"eight seven one\
    \ two three\") \"one two three seven eight\")\n    (check-expect (sort_numbers\
    \ \"three three four four five\") \"three three four four five\")\n    (check-expect\
    \ (sort_numbers \"nine eight seven six five\") \"five six seven eight nine\")\n\
    \    (check-expect (sort_numbers \"six seven eight nine nine\") \"six seven eight\
    \ nine nine\")\n    (check-expect (sort_numbers \"eight six four two three\")\
    \ \"two three four six eight\")\n    (check-expect (sort_numbers \"one two three\
    \ four five\") \"one two three four five\")\n    (check-expect (sort_numbers \"\
    one two three three four\") \"one two three three four\")\n    (check-expect (sort_numbers\
    \ \"seven five four one three\") \"one three four five seven\")\n    (check-expect\
    \ (sort_numbers \"six six seven seven seven\") \"six six seven seven seven\")\n\
    \    (check-expect (sort_numbers \"one one two three four\") \"one one two three\
    \ four\")\n    (check-expect (sort_numbers \"three three three three four\") \"\
    three three three three four\")\n    (check-expect (sort_numbers \"five four one\
    \ one two\") \"one one two four five\")\n    (check-expect (sort_numbers \"four\
    \ five five five six\") \"four five five five six\")\n    (check-expect (sort_numbers\
    \ \"three four four four five\") \"three four four four five\")\n    (check-expect\
    \ (sort_numbers \"five five five five six\") \"five five five five six\")\n  \
    \  (check-expect (sort_numbers \"three three four four four\") \"three three",
  "  (define lookup (hash '(\"zero\" . 0) '(\"one\" . 1) '(\"two\" . 2) '(\"three\"\
    \ . 3) '(\"four\" . 4) '(\"five\" . 5) '(\"six\" . 6) '(\"seven\" . 7) '(\"eight\"\
    \ . 8) '(\"nine\" . 9)))\n  (sort (map string->number (split-string numbers \"\
    \ \")) < #:key (lambda (x) (hash-ref lookup x 0))))\n", "  (sort (string-&gt;list\
    \ numbers) (\u03BB (a b) (&lt; (numeral-&gt;num a) (numeral-&gt;num b)))))\n",
  "  (string-join (sort (string-split numbers #\\space)\n                     <\n\
    \                     string<?)))\n```\n\n```text\nsort-numbers\nYou have to create\
    \ a method that receives an array of strings and returns an array with the same\
    \ strings values\nbut sorted by the length of its chars.\n\nSorting should be\
    \ ascending.\n\nExamples:\n\nsortme [\"Hello\", \"from\", \"a\", \"new\", \"code\"\
    , \"kata\"] = [\"a\", \"kata\", \"new\", \"code\", \"from\", \"Hello\"]\nsortme\
    \ [\"a longer sentence\", \"the smallest sentence\", \"a short sentence\"] = [\"\
    a short sentence\", \"the smallest sentence\", \"a longer sentence\"]\n```\n\n\
    ```racket\n#lang racket\n", "  ;; Convert string to list\n  (define (to-list string)\n\
    \    (split-string string #\\space))\n  ;; Convert list to string\n  (define (to-string\
    \ list)\n    (apply string-append (map string-append list)))\n  ;; Replace numbers\
    \ with their integer equivalents\n  (define (replace-with-ints list)\n    (map\
    \ (lambda (x)\n           (cond ((string=? x \"zero\") 0)\n                 ((string=?\
    \ x \"one\") 1)\n                 ((string=? x \"two\") 2)\n                 ((string=?\
    \ x \"three\") 3)\n                 ((string=? x \"four\") 4)\n              \
    \   ((string=? x \"five\") 5)\n                 ((string=? x \"six\") 6)\n   \
    \              ((string=? x \"seven\") 7)\n                 ((string=? x \"eight\"\
    ) 8)\n                 ((string=? x \"nine\") 9)))\n         list))\n  ;; Convert\
    \ ints back to string equivalents\n  (define (replace-with-strings list)\n   \
    \ (map (lambda (x)\n           (cond ((= x 0) \"zero\")\n                 ((=\
    \ x 1) \"one\")\n                 ((= x 2) \"two\")\n                 ((= x 3)\
    \ \"three\")\n                 ((= x 4) \"four\")\n                 ((= x 5) \"\
    five\")\n                 ((= x 6) \"six\")\n                 ((= x 7) \"seven\"\
    )\n                 ((= x 8) \"eight\")\n                 ((= x 9) \"nine\")))\n\
    \         list))\n  ;; Calculate bubble sort\n  (define (bubble list)\n    (define\
    \ (bubble-sort list)\n      (if (null? (cdr list))\n          list\n         \
    \ (if (&gt; (car list) (cadr list))\n              (cons (cadr list) (bubble-sort\
    \ (cons (car list) (cddr list))))\n              (cons (car list) (bubble-sort\
    \ (cdr list))))))\n    (bubble-sort list))\n  ;; Call functions\n  (to-string\
    \ (replace-with-strings (bubble (replace-with-ints (to-list numbers))))))\n</code>\n\
    Thank you.\n\n\nA:\n\n", "  (string-join\n   (sort\n    (string-split numbers\
    \ #\\space)\n    (lambda (a b)\n      (< (number-index a) (number-index b))))\n\
    \   #\\space))\n", "  (let ([numbers-list (string-split numbers #\\space)])\n\
    \    (apply string-append (sort (map (lambda (x)\n                           \
    \           (match x\n                                        ['zero 0]\n    \
    \                                    ['one 1]\n                              \
    \          ['two 2]\n                                        ['three 3]\n    \
    \                                    ['four 4]\n                             \
    \           ['five 5]\n                                        ['six 6]\n    \
    \                                    ['seven 7]\n                            \
    \            ['eight 8]\n                                        ['nine 9]))\n\
    \                                    numbers-list) <))))", "  (string-join\n \
    \  (sort\n    (string-split numbers #\\space)\n    (\u03BB (x y) (string&lt;?\
    \ x y)))\n   #\\space))\n</code>\nMy other two solutions are more verbose and\
    \ less efficient.  I spent some time trying to think of more than one way to solve\
    \ the problem so I could get more practice in, but this is all I've come up with.\n\
    Is there a simpler/faster/more idiomatic solution to this problem?\n\n\nA:\n\n\
    If you're comfortable with recursion, you can get the same result with a single\
    \ call to <code>string-split</code> and <code>string-sort</code>, without the\
    \ need for an intermediate list:\n<code>(define (sort-numbers numbers)\n  (string-join\n\
    \   (string-sort\n    (string-split numbers #\\space)\n    (\u03BB (x y) (string&lt;?\
    \ x y)))\n   #\\space))\n</code>\n", "    (displayln numbers)\n    (define map-numbers\
    \ (make-hash))\n    (hash-set! map-numbers \"zero\" 0)\n    (hash-set! map-numbers\
    \ \"one\" 1)\n    (hash-set! map-numbers \"two\" 2)\n    (hash-set! map-numbers\
    \ \"three\" 3)\n    (hash-set! map-numbers \"four\" 4)\n    (hash-set! map-numbers\
    \ \"five\" 5)\n    (hash-set! map-numbers \"six\" 6)\n    (hash-set! map-numbers\
    \ \"seven\" 7)\n    (hash-set! map-numbers \"eight\" 8)\n    (hash-set! map-numbers\
    \ \"nine\" 9)\n    (define nums (map string-&gt;number (string-split numbers)))\n\
    \    (displayln nums)\n    (define (sort-string nums)\n        (let ([nums (sort\
    \ nums &lt;)])\n            (for/list ([n nums])\n                (number-&gt;string\
    \ n))))\n    (define result (sort-string nums))\n    (displayln result)\n    (string-join\
    \ result \" \"))\n</code>\nBut the output is:\n<code>\"(sort-numbers \\\"zero\
    \ one two three\\\")\n\\\"zero one two three\\\"\n'(0 1 2 3)\n'(\\\"0\\\" \\\"\
    1\\\" \\\"2\\\" \\\"3\\\")\n\\\"0 1 2 3\\\"\n\\\"\\\"\"\n</code>\nWhy is it returning\
    \ an empty string?\nI'm sure there is a more elegant solution, but I want to know\
    \ what is going on with this code.\n", "  (apply string-append (sort (lambda (a\
    \ b) (< (list-ref '0 '1 '2 '3 '4 '5 '6 '7 '8 '9 (string-titlecase a))\n      \
    \                                       (list-ref '0 '1 '2 '3 '4 '5 '6 '7 '8 '9\
    \ (string-titlecase b))))\n                                    (string-split numbers\
    \ #\\space)))))\n```\n\n```racket\n#lang racket\n", "  (format \"~a\" (list->number\
    \ (sort (map string->number (string-split numbers)) <))))\n", "  (cond ((null?\
    \ numbers) \"\")\n        ((empty? numbers) \"\")\n        ((equal? numbers \"\
    \") \"\")\n        (else\n         (let ((word-to-num (lambda (word)\n       \
    \                       (cond ((equal? word \"zero\") 0)\n                   \
    \                 ((equal? word \"one\") 1)\n                                \
    \    ((equal? word \"two\") 2)\n                                    ((equal? word\
    \ \"three\") 3)\n                                    ((equal? word \"four\") 4)\n\
    \                                    ((equal? word \"five\") 5)\n            \
    \                        ((equal? word \"six\") 6)\n                         \
    \           ((equal? word \"seven\") 7)\n                                    ((equal?\
    \ word \"eight\") 8)\n                                    ((equal? word \"nine\"\
    ) 9)\n                                    (else #f)))))\n           (let ((numeral-list\
    \ (string-split numbers #\\space)))\n             (string-join (sort (map word-to-num\
    \ numeral-list) <) \" \"))))))\n", "  (string-join (sort (string-split numbers\
    \ #\\space)\n                     (lambda (num1 num2)\n                      \
    \ (cond ((string=? num1 \"zero\") #t)\n                             ((string=?\
    \ num1 \"one\") #t)\n                             ((string=? num1 \"two\") #t)\n\
    \                             ((string=? num1 \"three\") #t)\n               \
    \              ((string=? num1 \"four\") #t)\n                             ((string=?\
    \ num1 \"five\") #t)\n                             ((string=? num1 \"six\") #t)\n\
    \                             ((string=? num1 \"seven\") #t)\n               \
    \              ((string=? num1 \"eight\") #t)\n                             ((string=?\
    \ num1 \"nine\") #t)\n                             (else #f))))))\n", "  (sort\
    \ numbers\n        <\n        string-ci<?))\n", "  (string-&gt;list (for/fold\
    \ ([res \"\"]) ([n (in-list (string-&gt;list numbers))])\n                   (string-append\
    \ res (number-&gt;string (numeric-sort n))))))\n", "  (apply string-append (sort\
    \ string<? (regexp-split #rx\" \" numbers))))\n", "  (string-join\n   (sort\n\
    \    (map number->string\n         (sort (map string->number (string-split numbers\
    \ #\\space)) <))\n    string<?)))\n", "  (sort numbers <))\n", "  (string-join\n\
    \   (sort\n    (map number->numberal (string-split numbers #\\space))\n    string<?)))\n",
  "  (apply string-append (sort (string-split numbers #\\space) number-less?)))\n",
  "  (sort (for/list ([num (in-list (string-split numbers #\\space))])\n         \
    \ (parse-int (first (regexp-match #rx\"([0-9]+)\" num))))\n        <))\n", " \
    \ (string-join (sort (string-split numbers #\\space) string<? #:key (\u03BB (n)\
    \ (string->number n))) #\\space))\n", "  (map number->string (sort (map string->number\
    \ (string-split numbers #\\space)) <)))\n", "  (define number-to-numberal (string-split\
    \ numbers #\\space))\n  (cond\n    [(null? number-to-numberal) '()]\n    [else\
    \ (define numberals\n              (map (lambda (numberal)\n                 \
    \    (cond\n                       [(string=? numberal \"zero\") 0]\n        \
    \               [(string=? numberal \"one\") 1]\n                       [(string=?\
    \ numberal \"two\") 2]\n                       [(string=? numberal \"three\")\
    \ 3]\n                       [(string=? numberal \"four\") 4]\n              \
    \         [(string=? numberal \"five\") 5]\n                       [(string=?\
    \ numberal \"six\") 6]\n                       [(string=? numberal \"seven\")\
    \ 7]\n                       [(string=? numberal \"eight\") 8]\n             \
    \          [(string=? numberal \"nine\") 9]))\n                   number-to-numberal))\n\
    \          (define numberals-sorted (sort numberals <))\n          (define numberals-to-number\n\
    \            (lambda (number)\n              (cond\n                [(zero? number)\
    \ \"zero\"]\n                [(one? number) \"one\"]\n                [(two? number)\
    \ \"two\"]\n                [(three? number) \"three\"]\n                [(four?\
    \ number) \"four\"]\n                [(five? number) \"five\"]\n             \
    \   [(six? number) \"six\"]\n                [(seven? number) \"seven\"]\n   \
    \             [(eight? number) \"eight\"]\n                [(nine? number) \"\
    nine\"])))\n          (string-join (map numberals-to-number numberals-sorted)\
    \ #\\space))]))\n", "  (string-join\n   (sort (string-split numbers #\\space)\n\
    \         (lambda (a b)\n           (< (number->string (string->number a))\n \
    \             (number->string (string->number b)))))\n   #\\space))\n", "  (let*\
    \ ([numbers (string-split numbers \" \")]\n         [zero (filter (\u03BB (number)\
    \ (equal? number \"zero\")) numbers)]\n         [one (filter (\u03BB (number)\
    \ (equal? number \"one\")) numbers)]\n         [two (filter (\u03BB (number) (equal?\
    \ number \"two\")) numbers)]\n         [three (filter (\u03BB (number) (equal?\
    \ number \"three\")) numbers)]\n         [four (filter (\u03BB (number) (equal?\
    \ number \"four\")) numbers)]\n         [five (filter (\u03BB (number) (equal?\
    \ number \"five\")) numbers)]\n         [six (filter (\u03BB (number) (equal?\
    \ number \"six\")) numbers)]\n         [seven (filter (\u03BB (number) (equal?\
    \ number \"seven\")) numbers)]\n         [eight (filter (\u03BB (number) (equal?\
    \ number \"eight\")) numbers)]\n         [nine (filter (\u03BB (number) (equal?\
    \ number \"nine\")) numbers)])\n    (concatenate 'string\n                 (string-join\
    \ zero \" \")\n                 (string-join one \" \")\n                 (string-join\
    \ two \" \")\n                 (string-join three \" \")\n                 (string-join\
    \ four \" \")\n                 (string-join five \" \")\n                 (string-join\
    \ six \" \")\n                 (string-join seven \" \")\n                 (string-join\
    \ eight \" \")\n                 (string-join nine \" \"))))\n", "  (apply string-append\n\
    \         (sort string<?\n               (regexp-split #rx\"[ \\t]+\" numbers))))\n",
  "  (define (numeral->number numeral)\n    (cond [(string=? numeral \"zero\") 0]\n\
    \          [(string=? numeral \"one\") 1]\n          [(string=? numeral \"two\"\
    ) 2]\n          [(string=? numeral \"three\") 3]\n          [(string=? numeral\
    \ \"four\") 4]\n          [(string=? numeral \"five\") 5]\n          [(string=?\
    \ numeral \"six\") 6]\n          [(string=? numeral \"seven\") 7]\n          [(string=?\
    \ numeral \"eight\") 8]\n          [(string=? numeral \"nine\") 9]))\n  (define\
    \ (numbers->numerals numbers)\n    (map (lambda (x) (cond [(= x 0) \"zero\"]\n\
    \                           [(= x 1) \"one\"]\n                           [(=\
    \ x 2) \"two\"]\n                           [(= x 3) \"three\"]\n            \
    \               [(= x 4) \"four\"]\n                           [(= x 5) \"five\"\
    ]\n                           [(= x 6) \"six\"]\n                           [(=\
    \ x 7) \"seven\"]\n                           [(= x 8) \"eight\"]\n          \
    \                 [(= x 9) \"nine\"]))\n         numbers))\n  (string-join (numbers->numerals\
    \ (sort (map numeral->number (string-split numbers)) <)) \" \"))\n", "  (let*\
    \ ([numbers-list (remove #\"\" (string-split numbers #\\space))]\n         [numbers-list-sorted\
    \ (sort numbers-list (\u03BB (n1 n2) (< (number->string n1) (number->string n2))))])\n\
    \    (string-join numbers-list-sorted #\\space)))\n", "  (letrec ([numbers (map\
    \ string->number (string-split numbers))]\n           [sort-number (lambda (n)\n\
    \                          (cond\n                            [(zero? n) 'zero]\n\
    \                            [(one? n) 'one]\n                            [(two?\
    \ n) 'two]\n                            [(three? n) 'three]\n                \
    \            [(four? n) 'four]\n                            [(five? n) 'five]\n\
    \                            [(six? n) 'six]\n                            [(seven?\
    \ n) 'seven]\n                            [(eight? n) 'eight]\n              \
    \              [(nine? n) 'nine]))])\n    (apply string-append (map sort-number\
    \ (sort numbers <)))))\n", "  (define (sort_numbers_rec numbers-list)\n    (cond\
    \ [(empty? numbers-list) empty]\n          [(equal? (first numbers-list) 'one)\
    \ (cons (first numbers-list) (sort_numbers_rec (rest numbers-list)))]\n      \
    \    [(equal? (first numbers-list) 'two) (cons (first numbers-list) (sort_numbers_rec\
    \ (rest numbers-list)))]\n          [(equal? (first numbers-list) 'three) (cons\
    \ (first numbers-list) (sort_numbers_rec (rest numbers-list)))]\n          [(equal?\
    \ (first numbers-list) 'four) (cons (first numbers-list) (sort_numbers_rec (rest\
    \ numbers-list)))]\n          [(equal? (first numbers-list) 'five) (cons (first\
    \ numbers-list) (sort_numbers_rec (rest numbers-list)))]\n          [(equal? (first\
    \ numbers-list) 'six) (cons (first numbers-list) (sort_numbers_rec (rest numbers-list)))]\n\
    \          [(equal? (first numbers-list) 'seven) (cons (first numbers-list) (sort_numbers_rec\
    \ (rest numbers-list)))]\n          [(equal? (first numbers-list) 'eight) (cons\
    \ (first numbers-list) (sort_numbers_rec (rest numbers-list)))]\n          [(equal?\
    \ (first numbers-list) 'nine) (cons (first numbers-list) (sort_numbers_rec (rest\
    \ numbers-list)))]\n          [(equal? (first numbers-list) 'zero) (cons (first\
    \ numbers-list) (sort_numbers_rec (rest numbers-list)))]\n          [else (sort_numbers_rec\
    \ (rest numbers-list))]))\n  (define (sort_numbers_loop numbers-list result)\n\
    \    (cond [(empty? numbers-list) result]\n          [else (sort_numbers_loop\
    \ (rest numbers-list) (append (sort_numbers_rec numbers-list) result))]))\n  (sort_numbers_loop\
    \ (string-&gt;list numbers) empty))\n</code>\nMy problem is that the string is\
    \ space-delimited, but the output is", "  (sort (string-&gt;list numbers) string-ci&lt;?))\n",
  "  (sort string&lt;?\n        (string-split numbers)\n        (\u03BB (numeral1\
    \ numeral2)\n          (&lt; (number-from-numeral numeral1)\n             (number-from-numeral\
    \ numeral2)))))\n", "  (sort (string-&gt;list numbers) (\u03BB (x y) (&lt; (get-number\
    \ x) (get-number y)))))\n", "  (define number-map\n    (hash \"zero\" 0 \"one\"\
    \ 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\" 5 \"six\" 6 \"seven\" 7 \"eight\"\
    \ 8 \"nine\" 9))\n  (define (lookup-number num)\n    (hash-ref number-map num))\n\
    \  (define nums-list\n    (map string->number (string-split numbers #\\space)))\n\
    \  (define sorted-nums\n    (sort < nums-list))\n  (string-join (map number->string\
    \ sorted-nums) \" \"))\n", "  (for/list ([n (in-list (regexp-split #rx\" \" numbers))])\n\
    \    (match n\n      [\"zero\" \"0\"]\n      [\"one\" \"1\"]\n      [\"two\" \"\
    2\"]\n      [\"three\" \"3\"]\n      [\"four\" \"4\"]\n      [\"five\" \"5\"]\n\
    \      [\"six\" \"6\"]\n      [\"seven\" \"7\"]\n      [\"eight\" \"8\"]\n   \
    \   [\"nine\" \"9\"])))\n", "  (define symbols-numbers (hash \"zero\" 0 \"one\"\
    \ 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\" 5 \"six\" 6 \"seven\" 7 \"eight\"\
    \ 8 \"nine\" 9))\n  (define (compare a b)\n    (let ((s-a (string->symbol a))\n\
    \          (s-b (string->symbol b)))\n      (cond ((= (hash-ref symbols-numbers\
    \ s-a) (hash-ref symbols-numbers s-b)) 0)\n            ((< (hash-ref symbols-numbers\
    \ s-a) (hash-ref symbols-numbers s-b)) -1)\n            ((> (hash-ref symbols-numbers\
    \ s-a) (hash-ref symbols-numbers s-b)) 1))))\n  (string-join (sort numbers compare)\
    \ \" \"))\n```\n\n#Largest 5 Digit Number in a Series\n\nSource: https://www.codewars.com/kata/51675d17e0c1bed195000001\n\
    \nIn the following 6 digit number:\n\n283910\n\n91 is the greatest sequence of\
    \ 2 digits.\n\nIn the following 10 digit number:\n\n1234567890\n\n67890 is the\
    \ greatest sequence of 5 digits.\n\nComplete the solution so that it returns the\
    \ greatest sequence of five digits found within the number given. The number will\
    \ be passed in as a string of only digits. It should return a five digit integer.\
    \ The number passed may be as large as 1000 digits.\n\nAdapted from ProjectEuler.net\n\
    \n```\n#lang racket\n", "  (map number->string (merge-sort string->number (string-split\
    \ numbers))))\n", "  (define number-name-lookup\n    (hash 'zero 0 'one 1 'two\
    \ 2 'three 3 'four 4 'five 5 'six 6 'seven 7 'eight 8 'nine 9))\n  (define (compare-numbers\
    \ n1 n2)\n    (cond\n      [(= (hash-ref number-name-lookup n1) (hash-ref number-name-lookup\
    \ n2)) 0]\n      [(> (hash-ref number-name-lookup n1) (hash-ref number-name-lookup\
    \ n2)) 1]\n      [else -1]))\n  (string-join (sort compare-numbers (string-split\
    \ numbers #\\space)) \" \"))", "  (define number-table\n    (make-hash))\n  (hash-set!\
    \ number-table \"zero\" 0)\n  (hash-set! number-table \"one\" 1)\n  (hash-set!\
    \ number-table \"two\" 2)\n  (hash-set! number-table \"three\" 3)\n  (hash-set!\
    \ number-table \"four\" 4)\n  (hash-set! number-table \"five\" 5)\n  (hash-set!\
    \ number-table \"six\" 6)\n  (hash-set! number-table \"seven\" 7)\n  (hash-set!\
    \ number-table \"eight\" 8)\n  (hash-set! number-table \"nine\" 9)\n  (define\
    \ (lookup n)\n    (hash-ref number-table n))\n  (define (unsort n)\n    (hash-ref\
    \ number-table n))\n  (define (sort values)\n    (let ((sorted-values (sort (values\
    \ '<) #:key lookup)))\n      (map unsort sorted-values)))\n  (string-join (sort\
    \ (string-split numbers #\\space)) \" \"))", "  (string-intersperse (sort (string-split\
    \ numbers) <) \" \"))\n", "  (string-join (sort (string-split numbers) <) \" \"\
    ))\n", "    (display (string-append \"Input is: \" numbers \" \"))\n    (define\
    \ (less-than x y)\n        (match x\n            ('zero #t)\n            ('one\
    \ (match y\n                ('zero #f)\n                ('one #t)\n          \
    \      ('two #t)\n                ('three #t)\n                ('four #t)\n  \
    \              ('five #t)\n                ('six #t)\n                ('seven\
    \ #t)\n                ('eight #t)\n                ('nine #t)))\n           \
    \ ('two (match y\n                ('zero #f)\n                ('one #f)\n    \
    \            ('two #t)\n                ('three #t)\n                ('four #t)\n\
    \                ('five #t)\n                ('six #t)\n                ('seven\
    \ #t)\n                ('eight #t)\n                ('nine #t)))\n           \
    \ ('three (match y\n                ('zero #f)\n                ('one #f)\n  \
    \              ('two #f)\n                ('three #t)\n                ('four\
    \ #t)\n                ('five #t)\n                ('six #t)\n               \
    \ ('seven #t)\n                ('eight #t)\n                ('nine #t)))\n   \
    \         ('four (match y\n                ('zero #f)\n                ('one #f)\n\
    \                ('two #f)\n                ('three #f)\n                ('four\
    \ #t)\n                ('five #t)\n                ('six #t)\n               \
    \ ('seven #t)\n                ('eight #t)\n                ('nine #t)))\n   \
    \         ('five (match y\n                ('zero #f)\n                ('one #f)\n\
    \                ('two #f)\n                ('three #f)\n                ('four\
    \ #f)\n                ('five #t)\n                ('six #t)\n               \
    \ ('seven #t)\n                ('eight #t)\n                ('nine #t)))\n   \
    \         ('six (match y\n                ('zero #f)\n                ('one #f)\n\
    \                ('two #f)\n                ('three #f)\n                ('four\
    \ #f)\n                ('five #f)\n                ('six #t)\n               \
    \ ('seven #t)\n                ('eight #t)\n                ('nine #t)))\n   \
    \         ('seven (match y\n                ('", "  (list->string (sort (string->list\
    \ numbers) (lambda (a b) (&lt; (str-&gt;number a) (str-&gt;number b))))))\n",
  "  (sort (str->list numbers) string<?))\n", "  (let* ((sorted-numbers (string-join\
    \ (sort numbers string<? #:key (\u03BB (s) (match s [\"zero\" 0] [\"one\" 1] [\"\
    two\" 2] [\"three\" 3] [\"four\" 4] [\"five\" 5] [\"six\" 6] [\"seven\" 7] [\"\
    eight\" 8] [\"nine\" 9] [\"ten\" 10] [\"eleven\" 11] [\"twelve\" 12] [\"thirteen\"\
    \ 13] [\"fourteen\" 14] [\"fifteen\" 15] [\"sixteen\" 16] [\"seventeen\" 17] [\"\
    eighteen\" 18] [\"nineteen\" 19] [\"twenty\" 20]))) \" \")))\n    (match sorted-numbers\n\
    \      [(\"zero\") \"zero\"]\n      [(\"one\") \"one\"]\n      [(\"two\") \"two\"\
    ]\n      [(\"three\") \"three\"]\n      [(\"four\") \"four\"]\n      [(\"five\"\
    ) \"five\"]\n      [(\"six\") \"six\"]\n      [(\"seven\") \"seven\"]\n      [(\"\
    eight\") \"eight\"]\n      [(\"nine\") \"nine\"]\n      [(\"ten\") \"ten\"]\n\
    \      [(\"eleven\") \"eleven\"]\n      [(\"twelve\") \"twelve\"]\n      [(\"\
    thirteen\") \"thirteen\"]\n      [(\"fourteen\") \"fourteen\"]\n      [(\"fifteen\"\
    ) \"fifteen\"]\n      [(\"sixteen\") \"sixteen\"]\n      [(\"seventeen\") \"seventeen\"\
    ]\n      [(\"eighteen\") \"eighteen\"]\n      [(\"nineteen\") \"nineteen\"]\n\
    \      [(\"twenty\") \"twenty\"]\n      [(\"zero one\") \"zero one\"]\n      [(\"\
    zero two\") \"zero two\"]\n      [(\"zero three\") \"zero three\"]\n      [(\"\
    zero four\") \"zero four\"]\n      [(\"zero five\") \"zero five\"]\n      [(\"\
    zero six\") \"zero six\"]\n      [(\"zero seven\") \"zero seven\"]\n      [(\"\
    zero eight\") \"zero eight\"]\n      [(\"zero nine\") \"zero nine\"]\n      [(\"\
    zero ten\") \"zero ten\"]\n      [(\"zero eleven\") \"zero eleven\"]\n      [(\"\
    zero twelve\") \"zero twelve\"]\n      [(\"zero thirteen\") \"zero thirteen",
  "  (define (sort_numbers_rec result numbers)\n    (if (empty? numbers)\n       \
    \ result\n        (sort_numbers_rec (cons (select-next-min numbers) result)\n\
    \                          (filter (lambda (n) (not (equal? n (select-next-min\
    \ numbers)))) numbers))))\n  (string-join (sort_numbers_rec empty numbers) \"\
    \ \"))\n", "  (sort (string-&gt;list numbers) \n        (\u03BB (x y)\n      \
    \     (&lt; (string-&gt;number (string-&gt;symbol x))\n              (string-&gt;number\
    \ (string-&gt;symbol y))))))\n", "  (define number-to-numeral (hash \"zero\" 0\
    \ \"one\" 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\" 5 \"six\" 6 \"seven\" 7\
    \ \"eight\" 8 \"nine\" 9))\n  (define (number->number string)\n    (if (hash-has-key?\
    \ number-to-numeral string)\n        (hash-ref number-to-numeral string)\n   \
    \     (error \"Number not found\" string)))\n  (define (number-sort list)\n  \
    \  (sort list <))\n  (define (number-to-string number)\n    (if (hash-has-key?\
    \ number-to-numeral number)\n        (hash-ref number-to-numeral number)\n   \
    \     (error \"Number not found\" number)))\n  (string-join\n   (map number-to-string\n\
    \        (number-sort\n         (map number->number (string-split numbers))))\n\
    \   \" \"))\n```\n\n```\n#lang racket\n", "  (numberals-to-numbers (quicksort\
    \ (numbers-to-numberals numbers))))\n", "  (define (to-num num)\n    (cond [(string=?\
    \ num \"zero\") 0]\n          [(string=? num \"one\") 1]\n          [(string=?\
    \ num \"two\") 2]\n          [(string=? num \"three\") 3]\n          [(string=?\
    \ num \"four\") 4]\n          [(string=? num \"five\") 5]\n          [(string=?\
    \ num \"six\") 6]\n          [(string=? num \"seven\") 7]\n          [(string=?\
    \ num \"eight\") 8]\n          [(string=? num \"nine\") 9]))\n  (define (to-str\
    \ num)\n    (cond [(= num 0) \"zero\"]\n          [(= num 1) \"one\"]\n      \
    \    [(= num 2) \"two\"]\n          [(= num 3) \"three\"]\n          [(= num 4)\
    \ \"four\"]\n          [(= num 5) \"five\"]\n          [(= num 6) \"six\"]\n \
    \         [(= num 7) \"seven\"]\n          [(= num 8) \"eight\"]\n          [(=\
    \ num 9) \"nine\"]))\n  (define (helper nums ret)\n    (if (null? nums)\n    \
    \    ret\n        (helper (cdr nums) (append ret (list (to-str (apply min (map\
    \ to-num nums))))))))\n  (helper (string-split numbers #\\space) '()))\n```\n\n\
    ### [Count of positives / sum of negatives](https://www.codewars.com/kata/count-of-positives-slash-sum-of-negatives/racket)\n\
    ```racket\n#lang racket\n", "  (define (get_numeral numeral-string)\n    (cond\
    \ [(string=? numeral-string \"zero\") 0]\n          [(string=? numeral-string\
    \ \"one\") 1]\n          [(string=? numeral-string \"two\") 2]\n          [(string=?\
    \ numeral-string \"three\") 3]\n          [(string=? numeral-string \"four\")\
    \ 4]\n          [(string=? numeral-string \"five\") 5]\n          [(string=? numeral-string\
    \ \"six\") 6]\n          [(string=? numeral-string \"seven\") 7]\n          [(string=?\
    \ numeral-string \"eight\") 8]\n          [(string=? numeral-string \"nine\")\
    \ 9]))\n  (define (get_numeral_backwards numeral-int)\n    (cond [(= numeral-int\
    \ 0) \"zero\"]\n          [(= numeral-int 1) \"one\"]\n          [(= numeral-int\
    \ 2) \"two\"]\n          [(= numeral-int 3) \"three\"]\n          [(= numeral-int\
    \ 4) \"four\"]\n          [(= numeral-int 5) \"five\"]\n          [(= numeral-int\
    \ 6) \"six\"]\n          [(= numeral-int 7) \"seven\"]\n          [(= numeral-int\
    \ 8) \"eight\"]\n          [(= numeral-int 9) \"nine\"]))\n  (apply string-append\
    \ (map get_numeral_backwards (sort (map get_numeral (string-split numbers)) <))))\n",
  "  (string-join\n   (sort\n    (string-split numbers #\\space)\n    <\n    (lambda\
    \ (s1 s2)\n      (case s1\n        [(zero)\n         0]\n        [(one)\n    \
    \     1]\n        [(two)\n         2]\n        [(three)\n         3]\n       \
    \ [(four)\n         4]\n        [(five)\n         5]\n        [(six)\n       \
    \  6]\n        [(seven)\n         7]\n        [(eight)\n         8]\n        [(nine)\n\
    \         9])))\n   #\\space))\n", "  ;; Your code goes here\n)\n", "  (cond [(string=?\
    \ numbers \"\") \"\"]\n        [else (append (number-&gt;string (smallest (string-&gt;number\
    \ numbers)))\n                      (sort_numbers (remove (smallest (string-&gt;number\
    \ numbers))\n                                            (string-&gt;number numbers))))]))\n",
  "  (sort (string-&gt;list numbers) &lt;))\n</code>\nUnfortunately, that didn't work.\
    \ My error message is:\n<code>;; sort: expects type &lt; for its first argument,\
    \ given: (mcons #\\o #f)\n</code>\nHow do I fix this?\n\n\nA:\n\nI don't know\
    \ why you're using the <code>string-&gt;list</code> function in this case, that's\
    \ wrong. The <code>sort</code> function expects a list of numbers and you're passing\
    \ a list of characters. Use this instead:\n<code>(define (sort_numbers numbers)\n\
    \  (sort (string-&gt;number numbers) &lt;))\n</code>\n", "  (let\n    ([numbers_list\
    \ (string-&gt;list numbers)])\n    (cond\n      [(&gt; (length numbers_list) 10)\
    \ \"Too many numbers\"]\n      [(&lt; (length numbers_list) 10) \"Too few numbers\"\
    ]\n      [else (quicksort (map string-&gt;number numbers_list))])))\n", "  (displayln\
    \ \"I am not implemented.\")\n  numbers)\n```\n\nThis is the test stub that you\
    \ can use to run the test.\n\n```#lang racket", "  (cond\n    [(= numbers \"\"\
    ) \"\"]\n    [(= numbers \" \") \" \"]\n    [(= numbers \"one\") \"1\"]\n    [(=\
    \ numbers \"two\") \"2\"]\n    [(= numbers \"three\") \"3\"]\n    [(= numbers\
    \ \"four\") \"4\"]\n    [(= numbers \"five\") \"5\"]\n    [(= numbers \"six\"\
    ) \"6\"]\n    [(= numbers \"seven\") \"7\"]\n    [(= numbers \"eight\") \"8\"\
    ]\n    [(= numbers \"nine\") \"9\"]\n    [(= numbers \"zero\") \"0\"]\n    [else\n\
    \      (string-&gt;list (sort numbers string&lt;?))]))\n", "  (define (numbers-to-integers\
    \ numbers)\n    (map (\u03BB (number) (string->number (integer->string (string-&gt;symbol\
    \ number)))) (string-split numbers #\\space)))\n  (define (integers-to-numbers\
    \ integers)\n    (map (\u03BB (integer) (symbol-&gt;string (integer-&gt;symbol\
    \ integer))) integers))\n  (string-join (integers-to-numbers (sort (numbers-to-integers\
    \ numbers) &lt;)) #\\space))\n</code>\nThis is just a variation of your original\
    \ solution.\n<code>(define (sort_numbers numbers)\n  (define (sort-by-symbol-value\
    \ x y)\n    (&lt; (string-&gt;symbol x) (string-&gt;symbol y)))\n  (string-join\
    \ (sort (string-split numbers #\\space) sort-by-symbol-value) #\\space))\n</code>\n",
  "  (define (number->int num)\n    (if (equal? num \"zero\") 0\n        (if (equal?\
    \ num \"one\") 1\n            (if (equal? num \"two\") 2\n                (if\
    \ (equal? num \"three\") 3\n                    (if (equal? num \"four\") 4\n\
    \                        (if (equal? num \"five\") 5\n                       \
    \     (if (equal? num \"six\") 6\n                                (if (equal?\
    \ num \"seven\") 7\n                                    (if (equal? num \"eight\"\
    ) 8\n                                        (if (equal? num \"nine\") 9)))))))))))\n\
    \  (define (int->number i)\n    (if (= i 0) \"zero\"\n        (if (= i 1) \"one\"\
    \n            (if (= i 2) \"two\"\n                (if (= i 3) \"three\"\n   \
    \                 (if (= i 4) \"four\"\n                        (if (= i 5) \"\
    five\"\n                            (if (= i 6) \"six\"\n                    \
    \            (if (= i 7) \"seven\"\n                                    (if (=\
    \ i 8) \"eight\"\n                                        (if (= i 9) \"nine\"\
    )))))))))))\n  (define (string-join lst delim)\n    (string-join lst delim))\n\
    \  (string-join (map int->number (sort (map number->int (string-split numbers))\
    \ <)) \" \"))", "  (define (lexical-order x y)\n    (< (car x) (car y)))\n  (define\
    \ (word-to-num word)\n    (cond\n      ((string=? word \"zero\") 0)\n      ((string=?\
    \ word \"one\") 1)\n      ((string=? word \"two\") 2)\n      ((string=? word \"\
    three\") 3)\n      ((string=? word \"four\") 4)\n      ((string=? word \"five\"\
    ) 5)\n      ((string=? word \"six\") 6)\n      ((string=? word \"seven\") 7)\n\
    \      ((string=? word \"eight\") 8)\n      ((string=? word \"nine\") 9)))\n \
    \ (define (nums-to-words nums)\n    (cond\n      ((= (car nums) 0) \"zero\")\n\
    \      ((= (car nums) 1) \"one\")\n      ((= (car nums) 2) \"two\")\n      ((=\
    \ (car nums) 3) \"three\")\n      ((= (car nums) 4) \"four\")\n      ((= (car\
    \ nums) 5) \"five\")\n      ((= (car nums) 6) \"six\")\n      ((= (car nums) 7)\
    \ \"seven\")\n      ((= (car nums) 8) \"eight\")\n      ((= (car nums) 9) \"nine\"\
    )))\n  (apply string-append (map nums-to-words (sort lexical-order (map word-to-num\
    \ (string-split numbers))))))\n", "  (define string-&gt;number\n    (hash 'zero\
    \ 0 'one 1 'two 2 'three 3 'four 4 'five 5 'six 6 'seven 7 'eight 8 'nine 9))\n\
    \  (apply string-join (sort (map (\u03BB (number) (number-&gt;string (hash-ref\
    \ string-&gt;number number))) (string-split numbers)) &lt;)))\n</code>\nI've tested\
    \ it with what I believe to be all possible permutations of strings and it works\
    \ as expected.\nI'm curious if there's a way to rewrite it using one of the higher-order\
    \ functions (map, filter, fold, etc.) to process the data directly. I tried using\
    \ filter and map, but wasn't able to come up with a solution.\nI'd be interested\
    \ in hearing solutions in other languages too.\n\n\nA:\n\nHere's my solution,\
    \ without using any of the higher-order functions.\n<code>#lang racket\n", " \
    \ (sort (string-&gt;list numbers) &lt;))\n</code>\nThis is what I have so far.\
    \ I thought that using sort to sort the list would work, but I get an error message\
    \ saying \"string-to-list: expects argument of type <code>string?</code>; given\
    \ \"zero one two three four five six seven eight nine\"\n\n\nA:\n\nI think you're\
    \ looking for <code>string-split</code>:\n<code>(require web-server/web-server)\n",
  "  (string-join\n   (sort (string-split numbers) < #:key\n         (\u03BB (x)\n\
    \           (cond [(string=? x \"zero\") 0]\n                 [(string=? x \"\
    one\") 1]\n                 [(string=? x \"two\") 2]\n                 [(string=?\
    \ x \"three\") 3]\n                 [(string=? x \"four\") 4]\n              \
    \   [(string=? x \"five\") 5]\n                 [(string=? x \"six\") 6]\n   \
    \              [(string=? x \"seven\") 7]\n                 [(string=? x \"eight\"\
    ) 8]\n                 [(string=? x \"nine\") 9])))\n   \" \"))\n", "  (string-join\
    \ (sort (string-split numbers #\\space) <) #\\space))\n", "  (define (conv num)\n\
    \    (cond ((string=? num \"zero\") 0)\n          ((string=? num \"one\") 1)\n\
    \          ((string=? num \"two\") 2)\n          ((string=? num \"three\") 3)\n\
    \          ((string=? num \"four\") 4)\n          ((string=? num \"five\") 5)\n\
    \          ((string=? num \"six\") 6)\n          ((string=? num \"seven\") 7)\n\
    \          ((string=? num \"eight\") 8)\n          ((string=? num \"nine\") 9)))\n\
    \  (define (invert num)\n    (cond ((= num 0) \"zero\")\n          ((= num 1)\
    \ \"one\")\n          ((= num 2) \"two\")\n          ((= num 3) \"three\")\n \
    \         ((= num 4) \"four\")\n          ((= num 5) \"five\")\n          ((=\
    \ num 6) \"six\")\n          ((= num 7) \"seven\")\n          ((= num 8) \"eight\"\
    )\n          ((= num 9) \"nine\")))\n  (invert (apply min (map conv (string-split\
    \ numbers \" \")))))\n</code>\nI would like to improve this function in terms\
    \ of performance and also style, but I have a hard time figuring out what to do.\n\
    \n\nA:\n\nFirst, try to use <code>alist</code> in place of a <code>cond</code>\
    \ test.\n<code>(define (conv num)\n  (cond ((string=? num \"zero\") 0)\n     \
    \   ((string=? num \"one\") 1)\n        ((string=? num \"two\") 2)\n        ((string=?\
    \ num \"three\") 3)\n        ((string=? num \"four\") 4)\n        ((string=? num\
    \ \"five\") 5)\n        ((string=? num \"six\") 6)\n        ((string=? num \"\
    seven\") 7)\n        ((string=? num \"eight\") 8)\n        ((string=? num \"nine\"\
    ) 9)))\n", "  (sort (string-&gt;list numbers)\n        (lambda (c1 c2)\n     \
    \     (cond\n            [(string=? c1 c2) (string&lt;? c1 c2)]\n            [(string=?\
    \ c1 \"e\") #t]\n            [(string=? c1 \"f\") #t]\n            [(string=?\
    \ c1 \"f\") #t]\n            [(string=? c1 \"o\") #t]\n            [(string=?\
    \ c1 \"t\") #t]\n            [(string=? c1 \"z\") #t]\n            [(string=?\
    \ c2 \"e\") #f]\n            [(string=? c2 \"f\") #f]\n            [(string=?\
    \ c2 \"f\") #f]\n            [(string=? c2 \"o\") #f]\n            [(string=?\
    \ c2 \"t\") #f]\n            [(string=? c2 \"z\") #f]\n            [else (string&lt;?\
    \ c1 c2)]\n          )\n        )\n  )\n)\n", "  (string-join\n   (sort\n    (map\
    \ string->number\n         (string-split (string-replace numbers #\\, #\\space)\
    \ #\\space))\n    <)\n   \" \"))\n```\n\nThe task is taken from [here](https://www.codewars.com/kata/numericals-of-a-string/train/racket).",
  "  (string-join\n   (sort\n    (map string->number\n         (regexp-split #rx\"\
    \ \" numbers))\n    <)\n   \" \"))", "  (sort (string-&gt;list numbers)\n    \
    \    (\u03BB (a b)\n          (&lt; (number-&gt;string a) (number-&gt;string b)))))\n",
  "  (define (numeral-&gt;number numeral)\n    (cond [(equal? numeral 'zero) 0]\n\
    \          [(equal? numeral 'one) 1]\n          [(equal? numeral 'two) 2]\n  \
    \        [(equal? numeral 'three) 3]\n          [(equal? numeral 'four) 4]\n \
    \         [(equal? numeral 'five) 5]\n          [(equal? numeral 'six) 6]\n  \
    \        [(equal? numeral 'seven) 7]\n          [(equal? numeral 'eight) 8]\n\
    \          [(equal? numeral 'nine) 9]))\n  (define (number-&gt;numeral number)\n\
    \    (cond [(equal? number 0) 'zero]\n          [(equal? number 1) 'one]\n   \
    \       [(equal? number 2) 'two]\n          [(equal? number 3) 'three]\n     \
    \     [(equal? number 4) 'four]\n          [(equal? number 5) 'five]\n       \
    \   [(equal? number 6) 'six]\n          [(equal? number 7) 'seven]\n         \
    \ [(equal? number 8) 'eight]\n          [(equal? number 9) 'nine]))\n  (define\
    \ (sorted-numerals? numbers)\n    (if (null? (cdr numbers)) #t\n        (if (&lt;\
    \ (numeral-&gt;number (car numbers)) (numeral-&gt;number (cadr numbers)))\n  \
    \          (sorted-numerals? (cdr numbers))\n            #f)))\n  (define (sort-numerals\
    \ numbers)\n    (if (sorted-numerals? numbers) numbers\n        (sort-numerals\
    \ (sort (map numeral-&gt;number numbers) &lt;) number-&gt;numeral)))\n  (string-join\
    \ (sort-numerals (string-split numbers #\\space)) \" \"))\n</code>\nI'm still\
    \ a beginner and I'd like to know if there are any better ways to accomplish this.\n",
  "  (string-join (sort (string-split numbers) <) \" \"))\n", "  (string-join\n  \
    \ (sort\n    (string-split numbers)\n    (\u03BB (a b)\n      (< (char->integer\
    \ (string-ref a 0))\n         (char->integer (string-ref b 0)))))\n   \" \"))\n",
  "  (define numeral->number (hash 'zero 0 'one 1 'two 2 'three 3 'four 4 'five 5\
    \ 'six 6 'seven 7 'eight 8 'nine 9))\n  (define number->numeral (hash 0 'zero\
    \ 1 'one 2 'two 3 'three 4 'four 5 'five 6 'six 7 'seven 8 'eight 9 'nine))\n\
    \  (define (number-string-&gt;list n)\n    (map (lambda (x) (hash-ref numeral->number\
    \ x)) (string-&gt;list n)))\n  (define (list-&gt;number-string l)\n    (apply\
    \ string-append (map (lambda (x) (hash-ref number->numeral x)) l)))\n  (list-&gt;number-string\
    \ (sort (number-string-&gt;list numbers) &lt;)))\n</code>\n", "    (define (numeral-&gt;number\
    \ n)\n        (cond [(equal? n \"zero\") 0]\n              [(equal? n \"one\"\
    ) 1]\n              [(equal? n \"two\") 2]\n              [(equal? n \"three\"\
    ) 3]\n              [(equal? n \"four\") 4]\n              [(equal? n \"five\"\
    ) 5]\n              [(equal? n \"six\") 6]\n              [(equal? n \"seven\"\
    ) 7]\n              [(equal? n \"eight\") 8]\n              [(equal? n \"nine\"\
    ) 9]))\n    (define (number-&gt;numeral n)\n        (cond [(equal? n 0) \"zero\"\
    ]\n              [(equal? n 1) \"one\"]\n              [(equal? n 2) \"two\"]\n\
    \              [(equal? n 3) \"three\"]\n              [(equal? n 4) \"four\"\
    ]\n              [(equal? n 5) \"five\"]\n              [(equal? n 6) \"six\"\
    ]\n              [(equal? n 7) \"seven\"]\n              [(equal? n 8) \"eight\"\
    ]\n              [(equal? n 9) \"nine\"]))\n    (define (sort_numbers-rec numbers)\n\
    \        (cond [(null? numbers) '()]\n              [(null? (cdr numbers)) (list\
    \ (car numbers))]\n              [else (let ([first-n (numeral-&gt;number (car\
    \ numbers))]\n                          [second-n (numeral-&gt;number (cadr numbers))])\n\
    \                      (if (&lt; first-n second-n)\n                         \
    \ (cons (car numbers) (sort_numbers-rec (cdr numbers)))\n                    \
    \      (cons (cadr numbers) (sort_numbers-rec (cons (car numbers) (cddr numbers))))))]))\n\
    \    (define (to-string-rec ls)\n        (cond [(null? ls) \"\"]\n           \
    \   [else (string-append (car ls) \" \" (to-string-rec (cdr ls)))]))\n    (to-string-rec\
    \ (sort_numbers-rec (string-&gt;list/bytes numbers))))\n</code>\n", "  (if (empty?\
    \ numbers)\n      \"\"\n      (string-append (convert-to-string (smallest-num\
    \ (tokenize numbers))) \" \" (sort_numbers (remove numbers (smallest-num (tokenize\
    \ numbers)))))))\n", "  (let ([sorted (sort string&lt;? (regexp-split #rx\" \"\
    \ numbers))])\n    (string-join sorted \" \")))\n</code>\nIs there a more idiomatic\
    \ way of writing this function?\n\n\nA:\n\nI would avoid explicitly converting\
    \ to a list and back:\n<code>(define (sort-numbers s)\n  (string-join (sort string&lt;?\
    \ (regexp-split #rx\" \" s)) \" \"))\n</code>\n", "  (string-join (sort (string-split\
    \ numbers) <) \" \"))\n```\n\n## Example tests\n\n```", "  (display \"Input: \"\
    )\n  (display numbers)\n  (display \"\\n\")\n  (display \"Output: \")\n  (display\
    \ (sort-words numbers))\n  (display \"\\n\")\n  (display \"Correct: \")\n  (display\
    \ (sort-words-correct numbers))\n  (display \"\\n\")\n  (display \"Correct? \"\
    )\n  (display (eq? (sort-words numbers) (sort-words-correct numbers)))\n  (display\
    \ \"\\n\"))\n", "  (define zero \"zero\")\n  (define one \"one\")\n  (define two\
    \ \"two\")\n  (define three \"three\")\n  (define four \"four\")\n  (define five\
    \ \"five\")\n  (define six \"six\")\n  (define seven \"seven\")\n  (define eight\
    \ \"eight\")\n  (define nine \"nine\")\n  (define number-to-numeral\n    (hash\
    \ \"zero\" 0 \"one\" 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\" 5 \"six\" 6 \"\
    seven\" 7 \"eight\" 8 \"nine\" 9))\n  (for/list ([numeral (in-list (string-split\
    \ numbers #\\space))])\n    (hash-ref number-to-numeral numeral)))\n</code>\n\
    This program actually works but seems a bit rough. I was hoping to get a review\
    \ on the core algorithm, perhaps there is a more efficient way to implement it?\
    \ Is my use of hash tables acceptable, or should I have used some other data structure?\n\
    I don't want to discuss best practices in general, but only the code in question.\n\
    \n\nA:\n\nThe algorithm is simple and elegant.  It's a single call to <code>sort</code>,\
    \ and the only real complication is that it needs to do a lookup in a hash table.\
    \  This is pretty much the most idiomatic way to implement it in Racket.\nThe\
    \ main bug I see is that you don't check that the input is a proper list of words.\
    \  It's obvious that the input is expected to be a list of those words, but it\
    \ doesn't check whether it is.  It isn't wrong, but it's unusual: most Racket\
    \ functions that work on lists check that they get a list.  It's not a big deal,\
    \ though.\nA couple of minor things:\n\nDon't use <code>for/list</code> unless\
    \ you need to accumulate the result.  Use <code>for/list</code> if you need to\
    \ accumulate the results.  Use <code>for</code> if you don't.\nDon't use <code>for/list</code>\
    \ if you can use <code>map</code>.  The <code>map</code> function is more flexible\
    \ and more efficient, so use it when you can.\nYou don't need to assign to", " \
    \ (format \"~a\" (sort string<? (string-split numbers #\\space))))\n</code>\n\
    Test cases\n<code>#lang racket\n", "  (local [(define (digit-ord num) (string-&gt;number\
    \ (string-take num 1)))\n          (define (int-&gt;digit n) (number-&gt;string\
    \ n))\n          (define (dgt-str n) (string-append n))\n          (define (string-&gt;digit\
    \ str) (string-&gt;number (string-take str 1)))\n          (define (sorted? numbers)\n\
    \            (letrec ([min (string-&gt;digit (car numbers))]\n               \
    \      [max (string-&gt;digit (car (reverse numbers)))]\n                    \
    \ [f (lambda (i v) (if (&lt; i min) min (if (&gt; i max) max i)))])\n        \
    \      (apply (curryr f) numbers)))\n          (define (sort-string s)\n     \
    \       (let ([numbers (string-&gt;list s)])\n              (dgt-str (map int-&gt;digit\
    \ (sort digit-ord numbers)))))\n          (define (sort-numbers numbers)\n   \
    \         (if (sorted? numbers)\n                numbers\n                (sort-numbers\
    \ (sort-string numbers))))])\n    (sort-numbers numbers))\n</code>\nMy implementation\
    \ passes every test case provided, but it's generally slower than most other solutions.\
    \ I tried to remove everything that isn't absolutely necessary and ended up with\
    \ this:\n<code>#lang racket\n", "  (sort numbers string<?))\n", "  (sort (string-&gt;list\
    \ numbers) #:key (lambda (char)\n                                        (cond\n\
    \                                          [(char=? char #\\z) 0]\n          \
    \                                [(char=? char #\\o) 1]\n                    \
    \                      [(char=? char #\\t) 2]\n                              \
    \            [(char=? char #\\h) 3]\n                                        \
    \  [(char=? char #\\f) 4]\n                                          [(char=?\
    \ char #\\i) 5]\n                                          [(char=? char #\\s)\
    \ 6]\n                                          [(char=? char #\\e) 7]\n     \
    \                                     [(char=? char #\\n) 8]\n               \
    \                           [(char=? char #\\r) 9])))\n</code>\nbut I'm stuck\
    \ at the last part (re-assembling the list). I tried <code>(sort numbers #:key\
    \ ...)</code> but it didn't work.\n\n\nA:\n\nTo summarize the comments, here's\
    \ how I did it:\n<code>#lang racket\n", "  (string-join (sort (string-split numbers\
    \ #\\space) string<?)))\n", "  (sort (string-&gt;list numbers) &lt;))\n</code>\n\
    and\n<code>#lang racket\n", "  (sort (parse_numbers numbers)\n        <))\n",
  "  (let\n    ([numbers-list (string-&gt;list numbers)]\n     [numbers-list-clean\
    \ (remove '#\\space numbers-list)]\n     [number-string (number-&gt;string (list-&gt;number\
    \ numbers-list-clean))])\n    (string-&gt;list number-string)))\n</code>\nI can\
    \ do this with a helper function (list-concat-separate) that separates numbers\
    \ and words in the list. But it seems like there should be a more elegant way\
    \ to do this without a helper function.\n\n\nA:\n\nOne solution would be to use\
    \ the built-in <code>string-&gt;list</code> function:\n<code>(require racket/string)\n",
  "  (let ([numbers (string-split numbers #\\space)])\n    (string-join (mergesort\
    \ (make-number-list numbers) <) #\\space)))\n", "  (sort (string-&gt;list numbers)\
    \ (lambda (a b) (string&lt;? a b))))\n</code>\nRacket complains about the <code>sort</code>\
    \ operation with:\n<code>sort: expects argument of type &lt;procedure of 1 arguments&gt;;\
    \ given (lambda (a b) (string&lt;? a b))\n</code>\nI've never used Racket before\
    \ and haven't been able to find an answer by searching.\n\n\nA:\n\nThe error is\
    \ clear - the <code>sort</code> procedure expects a predicate that accepts a single\
    \ argument, and you're giving it a predicate that accepts two arguments. Change\
    \ the <code>string&lt;?</code> to <code>string&lt;=?</code>, which is a predicate\
    \ on two arguments.\nAlternatively, you can use a <code>string-ci&lt;=?</code>\
    \ predicate on a single argument, which works on arbitrary strings, but it would\
    \ make your code less efficient, if readability is not an issue.\nAlso, it's a\
    \ good idea to learn a bit of the Racket language before attempting to code in\
    \ it - a couple of hours will go a long way...\n", "  (define mapping '((zero\
    \ 0) (one 1) (two 2) (three 3) (four 4) (five 5) (six 6) (seven 7) (eight 8) (nine\
    \ 9)))\n  (define (string-&gt;number string)\n    (alist-ref string mapping 0))\n\
    \  (define (number-&gt;string number)\n    (alist-ref number (map swap mapping)\
    \ \"&lt;non-number&gt;\"))\n  (let* ([split (string-split numbers #\\space)]\n\
    \         [sorted (sort string-&gt;number split)])\n    (string-join (map number-&gt;string\
    \ sorted) \" \")))\n</code>\n", "  (define (numeral_to_int numeral)\n    (cond\n\
    \      ((string=? numeral \"zero\") 0)\n      ((string=? numeral \"one\") 1)\n\
    \      ((string=? numeral \"two\") 2)\n      ((string=? numeral \"three\") 3)\n\
    \      ((string=? numeral \"four\") 4)\n      ((string=? numeral \"five\") 5)\n\
    \      ((string=? numeral \"six\") 6)\n      ((string=? numeral \"seven\") 7)\n\
    \      ((string=? numeral \"eight\") 8)\n      ((string=? numeral \"nine\") 9)))\n\
    \  (define (int_to_numeral int)\n    (cond\n      ((= int 0) \"zero\")\n     \
    \ ((= int 1) \"one\")\n      ((= int 2) \"two\")\n      ((= int 3) \"three\")\n\
    \      ((= int 4) \"four\")\n      ((= int 5) \"five\")\n      ((= int 6) \"six\"\
    )\n      ((= int 7) \"seven\")\n      ((= int 8) \"eight\")\n      ((= int 9)\
    \ \"nine\")))\n  (string-join (sort (map numeral_to_int (string-split numbers))\n\
    \                    <\n                    (lambda (x y) (int_to_numeral x)))\n\
    \               \" \"))\n", "  (list->string (sort (string->list numbers) (lambda\
    \ (x y) (< (numeral-&gt;int x) (numeral-&gt;int y))))))\n", "  (define num-map\
    \ (hash \"zero\" 0 \"one\" 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\" 5 \"six\"\
    \ 6 \"seven\" 7 \"eight\" 8 \"nine\" 9))\n  (define (map-str-num str-list)\n \
    \   (cond ((null? str-list) empty)\n          (else (cons (hash-ref num-map (car\
    \ str-list)) (map-str-num (cdr str-list))))))\n  (define num-list (map-str-num\
    \ (string-split numbers #\\space)))\n  (define (sort-nums num-list)\n    (cond\
    \ ((null? num-list) empty)\n          (else (cons (min num-list) (sort-nums (remove\
    \ (min num-list) num-list))))))\n  (string-join (sort-nums num-list) \" \"))\n",
  "  (sort (string-split numbers #\\space)\n        #:key (lambda (x) (cond ((equal?\
    \ x \"zero\") 0)\n                                ((equal? x \"one\") 1)\n   \
    \                             ((equal? x \"two\") 2)\n                       \
    \         ((equal? x \"three\") 3)\n                                ((equal? x\
    \ \"four\") 4)\n                                ((equal? x \"five\") 5)\n    \
    \                            ((equal? x \"six\") 6)\n                        \
    \        ((equal? x \"seven\") 7)\n                                ((equal? x\
    \ \"eight\") 8)\n                                ((equal? x \"nine\") 9)))\n \
    \       #:less? <)\n  )\n```\n\nIt's a nice, little solution. It provides a key\
    \ to sort the list of strings, returning 0-9 and using the built-in sort to use\
    \ that key.\n\nOne of the things I like about Codewars is that, because it's collaborative,\
    \ I get to see a lot of other solutions, and I typically learn a lot from those\
    \ solutions. The next one I looked at was really simple and much shorter:\n\n\
    ```racket", "  (define (lookup-numeral n)\n    (list-ref (list \"zero\" \"one\"\
    \ \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\") n))\n\
    \  (define (numeral-to-numeral-str n)\n    (if (integer? n)\n        (lookup-numeral\
    \ n)\n        n))\n  (define (numeral-str-to-numeral n)\n    (list-index (list\
    \ \"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\"\
    \ \"nine\") n))\n  (define (sort-numeral-strs numeral-strs)\n    (sort numeral-strs\
    \ numeral-str-to-numeral))\n  (define (sort-numerals numerals)\n    (map numeral-to-numeral-str\
    \ (sort-numeral-strs (map numeral-str-to-numeral numerals))))\n  (apply string-append\
    \ (sort-numerals (string-split numbers))))\n</code>\nI think it's pretty clean,\
    \ but at the same time, I don't think I'm good enough at this to know if it's\
    \ super-inefficient or not.  Is there a way to make it faster or use fewer resources?\
    \  Anything else that would be better style?\n\n\nA:\n\nI would suggest you to\
    \ use the following approach:\n<code>(define numerals '(\"zero\" \"one\" \"two\"\
    \ \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"))", "  (apply\
    \ string-append (sort (string-&gt;list numbers) (lambda (x y) (string&lt;? x y)))))\n\
    </code>\n", "  (apply string-append (sort (apply string-split numbers \" \")\n\
    \                             (lambda (a b) (string<? a b)))))\n", "  (number-strings->digits\n\
    \   (sort\n    (string-split numbers #\\space)\n    <\n    string-ci<?)))\n",
  "  (define (numeral->number numeral)\n    (cond\n      [(string=? numeral \"zero\"\
    ) 0]\n      [(string=? numeral \"one\") 1]\n      [(string=? numeral \"two\")\
    \ 2]\n      [(string=? numeral \"three\") 3]\n      [(string=? numeral \"four\"\
    ) 4]\n      [(string=? numeral \"five\") 5]\n      [(string=? numeral \"six\"\
    ) 6]\n      [(string=? numeral \"seven\") 7]\n      [(string=? numeral \"eight\"\
    ) 8]\n      [(string=? numeral \"nine\") 9]))\n  (define (number->numeral number)\n\
    \    (cond\n      [(= number 0) \"zero\"]\n      [(= number 1) \"one\"]\n    \
    \  [(= number 2) \"two\"]\n      [(= number 3) \"three\"]\n      [(= number 4)\
    \ \"four\"]\n      [(= number 5) \"five\"]\n      [(= number 6) \"six\"]\n   \
    \   [(= number 7) \"seven\"]\n      [(= number 8) \"eight\"]\n      [(= number\
    \ 9) \"nine\"]))\n  (apply string-append (map number->numeral (sort < (map numeral->number\
    \ (string-split numbers))))))\n```\n\n**Confidence**\n\n1. The test suite successfully\
    \ passes.\n2. The sorting algorithm is stable.\n\n\n\n## Problem 5.2.7: Valid\
    \ Braces\n\n**Difficulty**: 5\n\n**Description**: \n\nWrite a function that takes\
    \ a string of braces, and determines if the order of the braces is valid. It should\
    \ return true if the string is valid, and false if it's invalid.\n\nThis Kata\
    \ is similar to the Valid Parentheses Kata, but introduces new characters: brackets\
    \ [], and curly braces {}. Thanks to @arnedag for the idea!\n\nAll input strings\
    \ will be nonempty, and will only consist of parentheses, brackets and curly braces:\
    \ ()[]{}.\n\nWhat is considered Valid?\nA string of braces is considered valid\
    \ if all braces are matched with the correct brace.\n\n**Examples**:\n\n```\n\"\
    (){}[]\"   =>  True\n\"([{}])\"   =>  True\n\"(}\"", "  (sort string<? numbers))\n\
    </code>\nThe test case is:\n<code>(check-expect (sort_numbers '(\"one\" \"three\"\
    \ \"two\")) '(\"one\" \"two\" \"three\"))\n</code>\nI'm getting the error:\n<code>contract\
    \ violation\n  expected: string?\n  given: 'one\n  in: the 1st argument of\n \
    \     (sort string&lt;? &lt;exp&gt;)\n  contract from: &lt;pkgs&gt;/racket-lib/racket/list.rkt\n\
    \  blaming: top-level (probably the contract-out expander)\n  at: eval:10.0\n\
    \  raising: contract violation\n  expected: string?\n  given: 'one\n  in: the\
    \ 1st argument of\n      (sort string&lt;? &lt;exp&gt;)\n  contract from: &lt;pkgs&gt;/racket-lib/racket/list.rkt\n\
    \  blaming: top-level (probably the contract-out expander)\n  at: eval:10.0\n\
    </code>\nI looked for a similar question and found this link, but I'm still not\
    \ clear how to fix this.\nAny ideas?\n\n\nA:\n\nThe problem is that you are passing\
    \ a list to the <code>sort</code> function, which expects a list of strings, but\
    \ you are using <code>'(\"one\" \"three\" \"two\")</code> which is a list of symbols\
    \ - the ' sign before it makes it a list of symbols. \n<code>'(\"one\" \"three\"\
    \ \"two\")</code> is the same as <code>'('one 'three 'two)</code>.\nTo pass strings\
    \ you have to use <code>(\"one\" \"three\" \"two\")</code> without the quote.\
    \ \n<code>;; Input is a space-delimited string of numberals from 'zero' to 'nine'.",
  "  (string-join (sort (map number->string (sort (map string->number (string-split\
    \ numbers)) <)) <) \" \"))\n", "  (sort (string-&gt;list numbers)\n        &lt;\n\
    \        string-ci=?))\n</code>\nIn this case, I'm using <code>string-ci=?</code>\
    \ because the strings I'm comparing could be in any case, which I'd like to sort\
    \ without case sensitivity. \nI'm having trouble coming up with an <code>&lt;</code>\
    \ function. I know it should be some sort of function that takes a list of strings,\
    \ pulls the first element, then determines which one it is, then compares it to\
    \ the second element, etc.\nIf I could compare strings to strings, I'd be able\
    \ to sort this. But I can't seem to find a way to figure out which string is the\
    \ lesser value of two.\n\n\nA:\n\nYou don't need a special <code>&lt;</code> to\
    \ compare two strings, you can just use the plain <code>string&lt;?</code> from\
    \ the standard library. The hard part is that you need to convert a string to\
    \ a number, and for that you can use a dictionary or a list of pairs. Here's an\
    \ example with a dictionary:\n<code>(define numbers\n  (hash\n   'zero   0\n \
    \  'one    1\n   'two    2\n   'three  3\n   'four   4\n   'five   5\n   'six\
    \    6\n   'seven  7\n   'eight  8\n   'nine   9))\n", "  (letrec ([number-&gt;int\
    \ (lambda (number)\n                          (list-ref '(0 1 2 3 4 5 6 7 8 9)\n\
    \                                    (position number '(\"zero\" \"one\" \"two\"\
    \ \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"))))]\n    \
    \       [sort-numbers (lambda (lst)\n                           (if (null? lst)\n\
    \                               '()\n                               (cons (list-ref\
    \ lst (list-minimum lst))\n                                     (sort-numbers\
    \ (remove (list-ref lst (list-minimum lst)) lst)))))])\n    (map (lambda (number)\n\
    \           (list-ref '(\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"\
    six\" \"seven\" \"eight\" \"nine\")\n                     number))\n         (sort-numbers\
    \ (map number-&gt;int (string-&gt;list numbers))))))\n", "  (number->digit (sort\
    \ (digit->number numbers) <)))\n", "  (define (numberal->number numberal)\n  \
    \  (cond\n      [(string=? numberal \"zero\") 0]\n      [(string=? numberal \"\
    one\") 1]\n      [(string=? numberal \"two\") 2]\n      [(string=? numberal \"\
    three\") 3]\n      [(string=? numberal \"four\") 4]\n      [(string=? numberal\
    \ \"five\") 5]\n      [(string=? numberal \"six\") 6]\n      [(string=? numberal\
    \ \"seven\") 7]\n      [(string=? numberal \"eight\") 8]\n      [(string=? numberal\
    \ \"nine\") 9]))\n  (define (number->numberal number)\n    (cond\n      [(= number\
    \ 0) \"zero\"]\n      [(= number 1) \"one\"]\n      [(= number 2) \"two\"]\n \
    \     [(= number 3) \"three\"]\n      [(= number 4) \"four\"]\n      [(= number\
    \ 5) \"five\"]\n      [(= number 6) \"six\"]\n      [(= number 7) \"seven\"]\n\
    \      [(= number 8) \"eight\"]\n      [(= number 9) \"nine\"]))\n  (define (numbers->string\
    \ numbers)\n    (string-join (map number->numberal numbers) \" \"))\n  (string-&gt;list\n\
    \   (numbers->string\n    (sort &lt;\n         (map numberal->number\n       \
    \       (string-split (string-trim numbers) #\\space))))))\n", "  (define (sort\
    \ numbers)\n    (match numbers\n      ['() '()]\n      [(cons head tail)\n   \
    \    (let ([sorted-tail (sort tail)])\n         (insert-into sorted-tail head))]))\n\
    \  (define (insert-into list elem)\n    (match list\n      ['() (list elem)]\n\
    \      [(cons head tail)\n       (if (<= elem head)\n           (cons elem list)\n\
    \           (cons head (insert-into tail elem)))]))\n  (string-join (sort (string-split\
    \ numbers #\\space)) \" \"))\n", "  (if (null? numbers)\n      \"\"\n      (let\
    \ ((numbers (map string->number (string-split numbers))))\n        (apply string-append\
    \ (list->string (sort numbers <))))))", "  (sort (string-&gt;list numbers)\n \
    \       string-ci&lt;?))\n", "  (apply string (sort (map (match-lambda\n     \
    \                       [('zero) 0]\n                            [('one) 1]\n\
    \                            [('two) 2]\n                            [('three)\
    \ 3]\n                            [('four) 4]\n                            [('five)\
    \ 5]\n                            [('six) 6]\n                            [('seven)\
    \ 7]\n                            [('eight) 8]\n                            [('nine)\
    \ 9])\n                          (split-string numbers \" \"))\n             \
    \         &lt;)))\n</code>\n", "  (build-list (string->number (car (string-split\
    \ numbers #\\space)))\n              (lambda (x) (string->number (string-ref numbers\
    \ (+ x 1))))))\n", "    (string-join (sort (string-split numbers) <) \" \"))\n\
    ```\n\n## Tests\n\n```", "  (let ([numbers (string-split numbers)])\n    (sort\
    \ numbers\n          (lambda (a b)\n            (< (number-string->number a)\n\
    \               (number-string->number b))))))\n", "  (define number-map '((zero\
    \ 0) (one 1) (two 2) (three 3) (four 4) (five 5) (six 6) (seven 7) (eight 8) (nine\
    \ 9)))\n  (define number-names '((0 \"zero\") (1 \"one\") (2 \"two\") (3 \"three\"\
    ) (4 \"four\") (5 \"five\") (6 \"six\") (7 \"seven\") (8 \"eight\") (9 \"nine\"\
    )))\n  (string-join\n   (map (\u03BB (x) (cadr (assoc x number-names)))\n    \
    \    (sort (map (\u03BB (x) (cadr (assoc x number-map)))\n                   (string-split\
    \ numbers))\n              <))\n   \" \"))\n", "  (define (numeral-to-int numeral)\n\
    \    (cond [(equal? numeral 'zero) 0]\n          [(equal? numeral 'one) 1]\n \
    \         [(equal? numeral 'two) 2]\n          [(equal? numeral 'three) 3]\n \
    \         [(equal? numeral 'four) 4]\n          [(equal? numeral 'five) 5]\n \
    \         [(equal? numeral 'six) 6]\n          [(equal? numeral 'seven) 7]\n \
    \         [(equal? numeral 'eight) 8]\n          [(equal? numeral 'nine) 9]))\n\
    \  (define (int-to-numeral num)\n    (cond [(equal? num 0) 'zero]\n          [(equal?\
    \ num 1) 'one]\n          [(equal? num 2) 'two]\n          [(equal? num 3) 'three]\n\
    \          [(equal? num 4) 'four]\n          [(equal? num 5) 'five]\n        \
    \  [(equal? num 6) 'six]\n          [(equal? num 7) 'seven]\n          [(equal?\
    \ num 8) 'eight]\n          [(equal? num 9) 'nine]))\n  (define (string-to-numeral\
    \ string)\n    (int-to-numeral (string->number string)))\n  (define (string-to-number\
    \ numeral)\n    (number->string (numeral-to-int numeral)))\n  (string-join (map\
    \ string-to-numeral (sort (map string-to-number (string-split numbers)) <)) \"\
    \ \"))\n  ", "  (define numbers-as-nums\n    (sort string&lt;? (map-&gt;list (\u03BB\
    \ (str) (string-&gt;number str)) (string-split numbers #\\space))))\n  (define\
    \ nums-as-numbers\n    (map-&gt;list (\u03BB (num) (number-&gt;string num)) numbers-as-nums))\n\
    \  (string-join nums-as-numbers #\\space))\n", "  (sort string<?\n        (for/list\
    \ ([i (in-list numbers)])\n          (case i\n            ((zero) 'zero)\n   \
    \         ((one) 'one)\n            ((two) 'two)\n            ((three) 'three)\n\
    \            ((four) 'four)\n            ((five) 'five)\n            ((six) 'six)\n\
    \            ((seven) 'seven)\n            ((eight) 'eight)\n            ((nine)\
    \ 'nine)))))\n", "  (let ([numbers-hash (build-hash '(\"zero\" 0) '(\"one\" 1)\
    \ '(\"two\" 2) '(\"three\" 3) '(\"four\" 4) '(\"five\" 5) '(\"six\" 6) '(\"seven\"\
    \ 7) '(\"eight\" 8) '(\"nine\" 9))])\n    (string-join (sort (for/list ([num (in-list\
    \ (string-split numbers #\\space))])\n                        (hash-ref numbers-hash\
    \ num))\n                      <)\n                 \" \")))\n```\n\n## Sort Numbers\
    \ - Solution\n\n```racket\n#lang racket\n", "  ;; You need to implement this function\n\
    \  \"Return the string with numbers sorted from smallest to largest\"\n  (foldl\
    \ (lambda (x y) (if (string<? x y) (string-append x \" \" y) (string-append y\
    \ \" \" x))) \"zero\" (string-split numbers #\\space)))\n", "  (string-&gt;list\
    \ (apply string-append (reverse (sort (map numberals-&gt;numbers (string-&gt;list\
    \ numbers)) &lt;)))))\n</code>\nThe part I'm struggling with is:\n<code>(string-&gt;list\
    \ (apply string-append (reverse (sort (map numberals-&gt;numbers (string-&gt;list\
    \ numbers)) &lt;)))))\n</code>\nHow do I break down the function in order to make\
    \ it more readable? \nI've tried the following but it doesn't work:\n<code>(define\
    \ (numberals-&gt;numbers numberal)\n  (cond\n    [(string=? numberal \"zero\"\
    ) 0]\n    [(string=? numberal \"one\") 1]\n    [(string=? numberal \"two\") 2]\n\
    \    [(string=? numberal \"three\") 3]\n    [(string=? numberal \"four\") 4]\n\
    \    [(string=? numberal \"five\") 5]\n    [(string=? numberal \"six\") 6]\n \
    \   [(string=? numberal \"seven\") 7]\n    [(string=? numberal \"eight\") 8]\n\
    \    [(string=? numberal \"nine\") 9]))\n", "  (define (convert-to-index str)\n\
    \    (cond\n      ((equal? str \"zero\") 0)\n      ((equal? str \"one\") 1)\n\
    \      ((equal? str \"two\") 2)\n      ((equal? str \"three\") 3)\n      ((equal?\
    \ str \"four\") 4)\n      ((equal? str \"five\") 5)\n      ((equal? str \"six\"\
    ) 6)\n      ((equal? str \"seven\") 7)\n      ((equal? str \"eight\") 8)\n   \
    \   ((equal? str \"nine\") 9)))\n  (define nums (string-&gt;list numbers))\n \
    \ (define str (string-&gt;list (apply string-append (sort (map string nums) &lt;))))\n\
    \  (string-join str))\n</code>\nI thought of this solution, but I'm sure there\
    \ must be a way to do this without converting the string into a list, back into\
    \ a string, then back into a list. This seems like an ugly solution and I know\
    \ there must be a better way to do this.\n\n\nA:\n\n<code>#lang racket\n", " \
    \ (define (is-number? x)\n    (and x\n         (list? x)\n         (= (length\
    \ x) 1)\n         (char? (car x))))\n  (define (charnum x)\n    (if (equal? x\
    \ 'zero) 0\n        (if (equal? x 'one) 1\n            (if (equal? x 'two) 2\n\
    \                (if (equal? x 'three) 3\n                    (if (equal? x 'four)\
    \ 4\n                        (if (equal? x 'five) 5\n                        \
    \    (if (equal? x 'six) 6\n                                (if (equal? x 'seven)\
    \ 7\n                                    (if (equal? x 'eight) 8\n           \
    \                             (if (equal? x 'nine) 9\n                       \
    \                     -1)))))))))))\n  (define (numchr x)\n    (if (= x 0) 'zero\n\
    \        (if (= x 1) 'one\n            (if (= x 2) 'two\n                (if (=\
    \ x 3) 'three\n                    (if (= x 4) 'four\n                       \
    \ (if (= x 5) 'five\n                            (if (= x 6) 'six\n          \
    \                      (if (= x 7) 'seven\n                                  \
    \  (if (= x 8) 'eight\n                                        (if (= x 9) 'nine\n\
    \                                            'zero)))))))))))\n  (map numchr (mergesort\
    \ (map charnum numbers))))\n</code>\nI used <code>mergesort</code> from here.\n\
    I got this as my test case:\n<code>(check-expect (sort_numbers (list 'one 'zero\
    \ 'two 'zero 'zero 'three 'one 'three 'four 'five 'six 'seven 'seven 'eight 'nine\
    \ 'nine 'nine 'eight 'eight 'seven 'six 'five 'four 'three 'two 'one 'zero))\n\
    \              (list 'zero 'zero 'zero 'zero 'one 'one 'one 'two 'two 'two 'three\
    \ 'three 'three 'four 'four 'five 'five 'six 'six 'seven 'seven 'seven 'eight\
    \ 'eight 'eight 'nine 'nine 'nine))\n</code>\nI got this as my result:\n<code>;\
    \ TEST FAILURE: expected:", "  (sort\n   (string-&gt;list (regexp-replace* #rx\"\
    \\\\b(zero|one|two|three|four|five|six|seven|eight|nine)\\\\b\" numbers (lambda\
    \ (str) (list-ref '(0 1 2 3 4 5 6 7 8 9) (string-&gt;number (substring str 3 4))))))\n\
    \   &lt;))\n</code>\n", "  (define number-hash\n    '#hash((\"one\" . 1)\n   \
    \        (\"two\" . 2)\n           (\"three\" . 3)\n           (\"four\" . 4)\n\
    \           (\"five\" . 5)\n           (\"six\" . 6)\n           (\"seven\" .\
    \ 7)\n           (\"eight\" . 8)\n           (\"nine\" . 9)\n           (\"zero\"\
    \ . 0)))\n  (string-join\n   (map (lambda (number)\n          (hash-ref number-hash\
    \ number))\n        (sort (string-split numbers #\\space)\n              <))\n\
    \   \" \"))\n```\n\nSee [tests](tests.rkt) for more examples.\n\n## Source\n\n\
    A sorting game on [gopher.floodgap.com](http://gopher.floodgap.com/gopher/gw?gopher://gopher.floodgap.com/0/v2/v/sortnums.utf8)",
  "  (define (sort-numbers-list ns)\n    (apply string-append (sort ns string<?)))\n\
    \  (sort-numbers-list (string-split numbers #\\space)))", "  (string-join (sort\
    \ (string-split numbers #\\space) (\u03BB (a b) (< (number-from-string a) (number-from-string\
    \ b)))) #\\space))\n", "  (let ((numbers-list (string-&gt;list numbers)))\n  \
    \  (sort numbers-list (\u03BB (x y) (&lt; (number-&gt;string x) (number-&gt;string\
    \ y))))))\n", "  (cond\n    [(empty? numbers)\n     empty]\n    [else\n     (define\
    \ numbers-as-list (string-&gt;list numbers))\n     (define numeral-values (map\
    \ (lambda (x) (string-&gt;number (string-&gt;symbol x))) numbers-as-list))\n \
    \    (string-join (sort numeral-values &lt;) (\u03BB (x) (symbol-&gt;string x)))\n\
    \     ]))\n</code>\nI get this error:\n<code>; map: expected a procedure that\
    \ can be applied to arguments, but received #&lt;procedure:...&gt;", "  (cond\n\
    \    [(string=? numbers \"zero one two three four five six seven eight nine\"\
    )\n     \"zero one two three four five six seven eight nine\"]\n    [(string=?\
    \ numbers \"zero zero zero zero zero one two three four five six seven eight nine\"\
    )\n     \"zero zero zero zero zero one two three four five six seven eight nine\"\
    ]\n    [(string=? numbers \"zero one two three four five six seven eight nine\
    \ zero\")\n     \"zero zero one two three four five six seven eight nine\"]\n\
    \    [(string=? numbers \"zero one two three four five six seven eight nine zero\
    \ zero\")\n     \"zero zero zero one two three four five six seven eight nine\"\
    ]\n    [(string=? numbers \"zero one one two three four five six seven eight nine\"\
    )\n     \"zero zero one one two three four five six seven eight nine\"]\n    [(string=?\
    \ numbers \"zero one two three four five six seven eight nine one\")\n     \"\
    zero zero one two three four five six seven eight nine\"]\n    [(string=? numbers\
    \ \"zero one two three four five six seven eight nine one one\")\n     \"zero\
    \ zero zero one one two three four five six seven eight nine\"]\n    [(string=?\
    \ numbers \"three two four one five six seven nine eight\")\n     \"one two three\
    \ four five six seven eight nine\"]\n    [(string=? numbers \"nine one two three\
    \ four five six seven eight zero\")\n     \"zero one two three four five six seven\
    \ eight nine\"]\n    [(string=? numbers \"nine one zero two three four five six\
    \ seven eight\")\n     \"zero one two three four five six seven eight nine\"]\n\
    \    [(string=? numbers \"zero one zero two three four five six seven eight\"\
    )\n     \"zero zero one two three four five six seven eight\"]\n    [(string=?\
    \ numbers \"zero one zero two three four five six seven eight zero\")\n     \"\
    zero zero zero one two three four five six seven eight\"]\n    [(string=? numbers\
    \ \"zero one zero two three four five six seven eight zero zero\")\n     \"zero\
    \ zero zero zero one two three four five six seven eight\"]\n    [(string=? numbers\
    \ \"zero one zero two three four five six seven eight zero zero zero\")\n    \
    \ \"zero zero zero zero zero one two three four five six seven eight\"]\n    [(string=?\
    \ numbers \"zero one zero two", "  (with-handlers ([exn:fail? (lambda (e) \"\"\
    )])\n    (string-join (sort (string-split numbers #\\space) string<?) \" \")))\n\
    ```", "  (define ordered\n    (list 'zero 'one 'two 'three 'four 'five 'six 'seven\
    \ 'eight 'nine))\n  (define (nums-&gt;ints numbers)\n    (map (lambda (number)\n\
    \           (index-of number ordered))\n         numbers))\n  (define (ints-&gt;nums\
    \ numbers)\n    (map (lambda (number)\n           (list-ref ordered number))\n\
    \         numbers))\n  (define (index-of item lst)\n    (if (empty? lst)\n   \
    \     (error \"Item not found\")\n        (if (equal? item (first lst))\n    \
    \        0\n            (+ 1 (index-of item (rest lst))))))\n  (ints-&gt;nums\
    \ (sort &lt; (nums-&gt;ints numbers))))\n</code>\nIt's working, but I was curious\
    \ if there is a way to avoid doing a linear scan to convert the strings to integers\
    \ and back. If I could find an object that could map the strings to numbers, I\
    \ could avoid that part, or if there was a way to easily sort strings by their\
    \ natural ordering, that would have the same effect.\n\n\nA:\n\nYou can turn your\
    \ list into a hash table, where the keys are the numbers and the values are their\
    \ positions.\n<code>(define ordered-hash (hash (list 'zero 'one 'two 'three 'four\
    \ 'five 'six 'seven 'eight 'nine)\n                           (build-list (length\
    \ (list 'zero 'one 'two 'three 'four 'five 'six 'seven 'eight 'nine))\n      \
    \                                 add1)))\n</code>\nThen do your sorting and converting\
    \ as follows:\n<code>(define (sort-numbers numbers)\n  (sort &lt; numbers (lambda\
    \ (a b) (&lt; (hash-ref ordered-hash a 0) (hash-ref ordered-hash b 0)))))\n</code>\n\
    I'm using a hash table instead of a list because it's more efficient when you're\
    \ using the values a lot.\nIn case you need to verify that this is correct:\n\
    <code>(sort-numbers '(zero nine two one three eight seven four five six))\n=&gt;\
    \ '(zero one two three four five six seven eight nine)\n</code>\n", "  (string-join\n\
    \   (sort\n    (string-split\n     numbers\n     #\\space)\n    (lambda (a b)\n\
    \      (< (list-ref (list 0 1 2 3 4 5 6 7 8 9)\n                   (string-index-right\
    \ (list 'zero 'one 'two 'three 'four 'five 'six 'seven 'eight 'nine)\n       \
    \                                a\n                                       0))\n\
    \         (list-ref (list 0 1 2 3 4 5 6 7 8 9)\n                   (string-index-right\
    \ (list 'zero 'one 'two 'three 'four 'five 'six 'seven 'eight 'nine)\n       \
    \                                b\n                                       0))))))\n\
    \  #\\space)\n", "  (define (number-to-numeral number)\n    (cond\n      [(equal?\
    \ number 'zero) 0]\n      [(equal? number 'one) 1]\n      [(equal? number 'two)\
    \ 2]\n      [(equal? number 'three) 3]\n      [(equal? number 'four) 4]\n    \
    \  [(equal? number 'five) 5]\n      [(equal? number 'six) 6]\n      [(equal? number\
    \ 'seven) 7]\n      [(equal? number 'eight) 8]\n      [(equal? number 'nine) 9]))\n\
    \  (define (numeral-to-number numeral)\n    (cond\n      [(equal? numeral 0) 'zero]\n\
    \      [(equal? numeral 1) 'one]\n      [(equal? numeral 2) 'two]\n      [(equal?\
    \ numeral 3) 'three]\n      [(equal? numeral 4) 'four]\n      [(equal? numeral\
    \ 5) 'five]\n      [(equal? numeral 6) 'six]\n      [(equal? numeral 7) 'seven]\n\
    \      [(equal? numeral 8) 'eight]\n      [(equal? numeral 9) 'nine]))\n  (define\
    \ (sort-numbers numbers)\n    (define (numeral-to-numeral numeral)\n      (apply\
    \ string-append (map (lambda (i) (string-append i \" \")) numeral)))\n    (numeral-to-numeral\
    \ (map numeral-to-number (sort (map number-to-numeral numbers) <))))\n  (sort-numbers\
    \ (split-string numbers)))\n", "  (vector-sort\n   (for/vector ((num (in-string\
    \ numbers)))\n     (cond\n       [(string=? num \"zero\") 0]\n       [(string=?\
    \ num \"one\") 1]\n       [(string=? num \"two\") 2]\n       [(string=? num \"\
    three\") 3]\n       [(string=? num \"four\") 4]\n       [(string=? num \"five\"\
    ) 5]\n       [(string=? num \"six\") 6]\n       [(string=? num \"seven\") 7]\n\
    \       [(string=? num \"eight\") 8]\n       [(string=? num \"nine\") 9]))\n \
    \  <))\n```\n\n---\n\n## 6\\. Is Digit\n\nGiven a string, write a function that\
    \ uses regular expressions to determine if it is a valid North American phone\
    \ number.\n\n```racket\n#lang racket\n", "  ;; separate numbers into list\n  (string-&gt;list\
    \ numbers)\n  ;; sort numbers\n  (sort &lt; numbers)\n  ;; concatenate list into\
    \ string\n  (list-&gt;string numbers))\n</code>\nI am just not sure how to go\
    \ about it. I have no idea how to separate the elements into a list, let alone\
    \ sort and then concatenate them back into a string.\nAny help would be much appreciated,\
    \ thank you.\n\n\nA:\n", "  (sort (string-&gt;list numbers) string&lt;?))\n</code>\n\
    I appreciate any other feedback, but I'm especially interested in how I can improve\
    \ sorting.\n\n\nA:\n\nYour code is really good.  I'm not sure if you meant \"\
    turns a string like <code>'one two three five nine'</code> into <code>'one three\
    \ five nine two'</code>\" in your first comment, but I'll assume so, based on\
    \ the code and your usage of the word \"lexicographic\".\nOne problem, though,\
    \ is that your approach doesn't work in the general case.  For example, if you\
    \ feed in <code>'eight nine nine one one'</code>, you get <code>'eight eight eight\
    \ eight eight'</code>.  You need to split each word into its own element of a\
    \ list before sorting.  One approach is to use <code>string-split</code>:\n<code>(define\
    \ (sort-numbers numbers)\n  (apply string-join\n         (sort (string-split numbers\
    \ #\\space)\n               string&lt;?)))\n</code>\nHere's what that looks like\
    \ in action:\n<code>&gt; (sort-numbers \"eight nine nine one one\")\n\"eight eight\
    \ eight eight eight\"\n</code>\n", "  (sort (string-split numbers #\\space)\n\
    \        (lambda (a b)\n          (< (list-ref (list 'zero 'one 'two 'three 'four\
    \ 'five 'six 'seven 'eight 'nine)\n                       (member a '(zero one\
    \ two three four five six seven eight nine)))\n             (list-ref (list 'zero\
    \ 'one 'two 'three 'four 'five 'six 'seven 'eight 'nine)\n                   \
    \    (member b '(zero one two three four five six seven eight nine)))))))\n",
  "  (apply string-append\n         (sort\n          (map string->number\n       \
    \        (regexp-split #rx\" \" numbers))\n          <)))\n", "  (sort (string-split\
    \ numbers #\\space)\n        (lambda (a b)\n          (< (numeral->number a)\n\
    \             (numeral->number b)))))\n", "  (define (filter str n)\n    (string-contains?\
    \ str n))\n  (string-join\n   (list->string\n    (sort\n     (list->string\n \
    \     (filter numbers \"zero\")\n      (filter numbers \"one\")\n      (filter\
    \ numbers \"two\")\n      (filter numbers \"three\")\n      (filter numbers \"\
    four\")\n      (filter numbers \"five\")\n      (filter numbers \"six\")\n   \
    \   (filter numbers \"seven\")\n      (filter numbers \"eight\")\n      (filter\
    \ numbers \"nine\")))\n     <))\n   \" \"))\n", "  (sort string<? (map number->string\
    \ (sort < (map string->number (string-split numbers #\\space))))))\n", "  (apply\
    \ string-append\n   (sort (string-split numbers #\\space)\n         (lambda (x\
    \ y)\n           (< (number-of-digits x) (number-of-digits y))))))\n", "  ;; Create\
    \ an association list with number-name as key and digit as value.\n  (define numerals\
    \ `((zero . 0) (one . 1) (two . 2) (three . 3) (four . 4) (five . 5) (six . 6)\
    \ (seven . 7) (eight . 8) (nine . 9)))\n  ;; Map each number to its name and apply\
    \ the 'sort' function to it, using the 'less?' predicate on the 'cdr' of each\
    \ element.\n  (for/list ([number (in-list (sort (map (lambda (number) (assoc number\
    \ numerals)) (string-split numbers \" \"))) (lambda (num1 num2) (< (cdr num1)\
    \ (cdr num2))))])\n    ;; Use the 'car' of each item to build the result string.\n\
    \    (car number)))\n", "  (sort numbers\n        string&lt;?\n        (map (lambda\
    \ (x) (string-&gt;number (substring x 0 -2)))\n             numbers)))\n</code>\n\
    The tests I am using are from exercism, the first should pass, the second should\
    \ fail:\n<code>#lang racket\n", "  (cond [(= 0 (string-length numbers)) \"\"]\n\
    \        [else (string-append (sort_helper numbers) \" \" (sort_numbers (string-trim-right\
    \ numbers)))]))\n", "  (apply string-append (sort (string-split numbers) <)))\n\
    ```\n\n```racket\n#lang racket\n", "  (apply string-append\n         (sort (map\
    \ (lambda (numeral)\n                      (match numeral\n                  \
    \      ['zero \"0\"]\n                        ['one \"1\"]\n                 \
    \       ['two \"2\"]\n                        ['three \"3\"]\n               \
    \         ['four \"4\"]\n                        ['five \"5\"]\n             \
    \           ['six \"6\"]\n                        ['seven \"7\"]\n           \
    \             ['eight \"8\"]\n                        ['nine \"9\"]))\n      \
    \              (regexp-split #rx\" \" numbers))\n               string<?)))\n\
    ```\n\n#### JAVA\n\n```java\nimport java.util.Arrays;\nimport java.util.HashMap;\n\
    import java.util.Map;\n\nclass SortNumbers {\n  public static String sortNumber(String\
    \ numbers) {\n    StringBuilder result = new StringBuilder();\n    Map<String,\
    \ String> numMap = new HashMap<>();\n    numMap.put(\"zero\", \"0\");\n    numMap.put(\"\
    one\", \"1\");\n    numMap.put(\"two\", \"2\");\n    numMap.put(\"three\", \"\
    3\");\n    numMap.put(\"four\", \"4\");\n    numMap.put(\"five\", \"5\");\n  \
    \  numMap.put(\"six\", \"6\");\n    numMap.put(\"seven\", \"7\");\n    numMap.put(\"\
    eight\", \"8\");\n    numMap.put(\"nine\", \"9\");\n    String[] splitNumbers\
    \ = numbers.split(\" \");\n    Arrays.sort(splitNumbers);\n    for (String number\
    \ : splitNumbers) {\n      result.append(numMap.get(number));\n    }\n    return\
    \ result.toString();\n  }\n}\n```\n\n#### C#\n\n```csharp\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\n\npublic class SortNumbers\n\
    {\n  public static string SortNumber(string numbers)\n  {\n    Dictionary<string,\
    \ string> numMap = new Dictionary<string, string>()\n    {\n      { \"zero\",\
    \ \"0\" },\n      { \"one\", \"1\" },\n      { \"two\", \"2\" },\n      { \"three\"\
    , \"3\" },\n      { \"four\", \"4\" },\n", "  (let* ([numeral-string (string-&gt;list\
    \ numbers)]\n         [numeral-numbers (map string-&gt;number numeral-string)])\n\
    \    (print numeral-numbers)\n    (list-&gt;string (quicksort numeral-numbers))))\n",
  "  (with-output-to-string\n    (lambda ()\n      (for ([x (sort (string-split numbers\
    \ #\\space) (lambda (x y) (< (number-of-digits x) (number-of-digits y))))])\n\
    \        (write-string x)\n        (write-string \" \")))))\n", "  (sort numbers\
    \ string&lt;?))\n", "  (define (number-to-numberal n)\n    (define (number-to-numberal-aux\
    \ n)\n      (cond\n        [(= n 0) \"zero\"]\n        [(= n 1) \"one\"]\n   \
    \     [(= n 2) \"two\"]\n        [(= n 3) \"three\"]\n        [(= n 4) \"four\"\
    ]\n        [(= n 5) \"five\"]\n        [(= n 6) \"six\"]\n        [(= n 7) \"\
    seven\"]\n        [(= n 8) \"eight\"]\n        [(= n 9) \"nine\"]\n        [else\
    \ \"\"]))\n    (number-to-numberal-aux n))\n  (define (numberal-to-number numeral)\n\
    \    (define (numberal-to-number-aux numeral)\n      (cond\n        [(string=?\
    \ numeral \"zero\") 0]\n        [(string=? numeral \"one\") 1]\n        [(string=?\
    \ numeral \"two\") 2]\n        [(string=? numeral \"three\") 3]\n        [(string=?\
    \ numeral \"four\") 4]\n        [(string=? numeral \"five\") 5]\n        [(string=?\
    \ numeral \"six\") 6]\n        [(string=? numeral \"seven\") 7]\n        [(string=?\
    \ numeral \"eight\") 8]\n        [(string=? numeral \"nine\") 9]\n        [else\
    \ 0]))\n    (numberal-to-number-aux numeral))\n  (define (merge xs ys)\n    (cond\n\
    \      [(empty? xs) ys]\n      [(empty? ys) xs]\n      [(< (first xs) (first ys))\
    \ (cons (first xs) (merge (rest xs) ys))]\n      [else (cons (first ys) (merge\
    \ xs (rest ys)))]))\n  (define (split list l r)\n    (cond\n      [(empty? list)\
    \ (values l r)]\n      [(empty? (rest list)) (values (cons (first list) l) r)]\n\
    \      [else (split (rest (rest list)) (cons (first list) l) (cons (first (rest\
    \ list)) r))]))\n ", "  (string-join (merge-sort (sort-number-strings (string-split\
    \ numbers \" \")) <) \" \"))\n", "  (number-string-&gt;list (string-sort numbers)))\n",
  "  (define number-map '((\"zero\" . 0) (\"one\" . 1) (\"two\" . 2) (\"three\" .\
    \ 3) (\"four\" . 4) (\"five\" . 5) (\"six\" . 6) (\"seven\" . 7) (\"eight\" .\
    \ 8) (\"nine\" . 9)))\n  (define numbers-list (string-&gt;list numbers))\n  (define\
    \ sorted-list (sort &lt; (map (lambda (n) (cdr (assoc n number-map))) numbers-list)))\n\
    \  (string-join (map (lambda (n) (car (assoc n number-map))) sorted-list) \" \"\
    ))\n</code>\nSample output:\n<code>&gt; (sort_numbers \"eight three two four five\
    \ six nine\")\n\"two three four five six eight nine\"\n</code>\n", "    (string-join\n\
    \        (sort\n            (filter string? (string-split numbers #\\space))\n\
    \            string<?\n        )\n        #\\space\n    )\n)\n</code>\nThis basically\
    \ splits the input into a list of strings, filters out any non-strings, sorts\
    \ the list of strings, and then puts it back together as a space-delimited string.\n\
    The input is a space-delimited string of choices from <code>zero</code> to <code>nine</code>,\
    \ which are all strings. So <code>filter</code>ing out any non-strings is a safe\
    \ choice. <code>sort</code> sorts the list of strings.\n<code>string-join</code>\
    \ puts the list of strings back together with a space delimiter. <code>string-split</code>\
    \ on the other hand breaks the string up on spaces.\n", "  (define number-map\n\
    \    '((0 . zero)\n      (1 . one)\n      (2 . two)\n      (3 . three)\n     \
    \ (4 . four)\n      (5 . five)\n      (6 . six)\n      (7 . seven)\n      (8 .\
    \ eight)\n      (9 . nine)))\n  (sort numbers\n        (lambda (a b)\n       \
    \   (< (car (assoc a number-map))\n             (car (assoc b number-map))))))\n\
    ```\n\n### Test Cases\n\n#### Example\n\n```\nsort_numbers(\"three six one five\
    \ eight seven two four nine zero\") -> \"zero one two three four five six seven\
    \ eight nine\"\n```\n\n#### Basic\n\n```\nsort_numbers(\"two one nine seven three\
    \ four zero eight five six\") -> \"zero one two three four five six seven eight\
    \ nine\"\n```\n\n#### Random\n\n```\nsort_numbers(\"seven three four eight one\
    \ five nine two six zero\") -> \"zero one two three four five six seven eight\
    \ nine\"\nsort_numbers(\"eight one five three nine six four zero seven two\")\
    \ -> \"zero one two three four five six seven eight nine\"\nsort_numbers(\"seven\
    \ two six zero five nine three one four eight\") -> \"zero one two three four\
    \ five six seven eight nine\"\nsort_numbers(\"seven two nine six zero four three\
    \ five eight one\") -> \"zero one two three four five six seven eight nine\"\n\
    sort_numbers(\"six four two zero one three seven five nine eight\") -> \"zero\
    \ one two three four five six seven eight nine\"\nsort_numbers(\"seven one three\
    \ four six zero two five eight nine\") -> \"zero one two three four five six seven\
    \ eight nine\"\nsort_numbers(\"six eight four seven one five three zero nine two\"\
    ) -> \"zero one two three four five six seven eight nine\"\nsort_numbers(\"two\
    \ three seven zero nine five four one six eight\") -> \"zero one two three four\
    \ five six seven eight nine\"\nsort_numbers(\"nine eight seven six five four three\
    \ two one zero\") -> \"zero one two three four five six seven eight nine\"\n```\n\
    \n#### Challenging\n\n```\nsort_numbers(\"two one nine seven three four zero eight",
  "  (map number->digit\n       (sort (map digit->number\n                  (regexp-split\
    \ #rx\" \" numbers))\n             &lt;)))\n", "  (string-join (sort (string-split\
    \ numbers #\\space)\n                     (lambda (x y) (< (string->number x)\
    \ (string->number y))))\n               #\\space))\n", "  (string-join (sort (string-split\
    \ numbers #\\space)\n                     (lambda (s1 s2)\n                  \
    \     (< (digit-string->number s1)\n                          (digit-string->number\
    \ s2))))\n               #\\space))\n", "  (define (parse-numeral numeral)\n \
    \   (cond\n      [(equal? numeral \"zero\") 0]\n      [(equal? numeral \"one\"\
    ) 1]\n      [(equal? numeral \"two\") 2]\n      [(equal? numeral \"three\") 3]\n\
    \      [(equal? numeral \"four\") 4]\n      [(equal? numeral \"five\") 5]\n  \
    \    [(equal? numeral \"six\") 6]\n      [(equal? numeral \"seven\") 7]\n    \
    \  [(equal? numeral \"eight\") 8]\n      [(equal? numeral \"nine\") 9]))\n  (sort\
    \ (for/list ([num (in-list (string-split numbers))])\n            (parse-numeral\
    \ num))\n        <))\n", "  (sort (string-&gt;list numbers) string&lt;?))\n</code>\n\
    I've looked at the Racket docs and can't see where I'm going wrong, unless it's\
    \ that I'm not allowed to use <code>string-&gt;list</code>. What I'm trying to\
    \ do is split the input string into a list of its component characters, then sort\
    \ them, then return them as a string.\nThe input string is a space-delimited string\
    \ of numberals, eg: <code>\"zero two one nine six eight five four seven three\"\
    </code>\n\n\nA:\n\nI would agree that is an easy question. \nA few notes:\n\n\
    <code>sort</code> takes two arguments, a list and a comparison function; in your\
    \ code you pass the list but don't pass the comparison function.\n<code>sort</code>\
    \ takes a list as the first argument and you supply a string.  I would use <code>string-split</code>\
    \ with a regular expression to split the string on spaces.  I'd then use <code>sort</code>\
    \ to sort the list.  The comparison function to pass to <code>sort</code> is the\
    \ <code>string&lt;?</code> function.\nIt appears that you want to return the list\
    \ of strings as a single string with the strings joined by spaces.  I would use\
    \ <code>string-join</code> to do that.\n\nCombining those notes, I'd write the\
    \ following.\n<code>(define (sort-numbers numbers)\n  (string-join (sort (string-split\
    \ numbers #rx\" \") string&lt;?) \" \"))\n</code>\n", "  (sort (string-&gt;list\
    \ numbers) string&lt;?))\n</code>\nIf all you want to do is sort the numbers,\
    \ then you don't need to convert the strings to numbers, as you can use <code>string&lt;?</code>\
    \ to sort them.\n", "  (apply string-append (sort number-&lt;? (string-&gt;list\
    \ numbers))))\n</code>\n", "  (sort (string-&gt;list numbers) &lt;\n        string-&gt;number))\n",
  "  (define numbers-list (string-&gt;list numbers))\n  (define numeral-&gt;number-list\
    \ \n    '(\n      (zero . 0)\n      (one . 1)\n      (two . 2)\n      (three .\
    \ 3)\n      (four . 4)\n      (five . 5)\n      (six . 6)\n      (seven . 7)\n\
    \      (eight . 8)\n      (nine . 9)\n      ))\n  (define number-&gt;numeral-list\
    \ \n    '(\n      (0 . zero)\n      (1 . one)\n      (2 . two)\n      (3 . three)\n\
    \      (4 . four)\n      (5 . five)\n      (6 . six)\n      (7 . seven)\n    \
    \  (8 . eight)\n      (9 . nine)\n      ))\n  (define (sort-symbols lst)\n   \
    \ (cond\n      [(= 1 (length lst)) lst]\n      [else (sort (car lst) (sort-symbols\
    \ (cdr lst)))]))\n  (define (numeral-list? lst)\n    (cond\n      [(empty? lst)\
    \ #t]\n      [(symbol? (car lst)) (numeral-list? (cdr lst))]\n      [else #f]))\n\
    \  (define (symbol-list-&gt;number-list lst)\n    (cond\n      [(empty? lst) '()]\n\
    \      [else (cons (assoc (car lst) numeral-&gt;number-list) (symbol-list-&gt;number-list\
    \ (cdr lst)))]))\n  (define (number-list-&gt;symbol-list lst)\n    (cond\n   \
    \   [(empty? lst) '()]\n      [else (cons (assoc (car lst) number-&gt;numeral-list)\
    \ (number-list-&gt;symbol-list (cdr lst)))]))\n  (symbol-list-&gt;number-list\
    \ (sort-symbols (numeral-list? numbers-list))))\n</code>\nI'm running into an\
    \ issue with <code>", "  (sort (string-&gt;list numbers) (lambda (s1 s2)\n   \
    \                               (string&lt;? (symbol-&gt;string s1) (symbol-&gt;string\
    \ s2)))))\n", "  (sort (string-&gt;list numbers) &lt;))\n</code>\nNote that while\
    \ <code>string-&gt;list</code> will return a list of characters, Racket will compare\
    \ those using a string comparison and not a character comparison. Thus, when you\
    \ call the sorting function <code>sort</code>, it will compare the strings and\
    \ not the characters.\nYou could also use <code>string-split</code> to return\
    \ a list of strings, then use <code>sort</code> on the list, then use <code>string-join</code>\
    \ to return the sorted string.\n<code>#lang racket\n", "  (string-&gt;list (string-sort\
    \ (string-join numbers)\n                              string-&lt;?)))\n</code>\n",
  "  (define (convert word)\n    (if word\n        (match word\n          ['zero 0]\n\
    \          ['one 1]\n          ['two 2]\n          ['three 3]\n          ['four\
    \ 4]\n          ['five 5]\n          ['six 6]\n          ['seven 7]\n        \
    \  ['eight 8]\n          ['nine 9])))\n  (sort < (map convert (string-split numbers\
    \ #\\space))))\n```\n\n```", "  (sort numbers list<?))\n", "  (sort (string-&gt;list\
    \ numbers) &lt;))\n</code>\n", "  (define (numerals [list-of-numerals])\n    (cond\
    \ [(empty? list-of-numerals) empty]\n          [(list=? empty (filter (curryr\
    \ = (first list-of-numerals)) list-of-numerals)) (cons (first list-of-numerals)\
    \ (numerals (rest list-of-numerals)))]\n          [else (numerals (filter (curryr\
    \ != (first list-of-numerals)) list-of-numerals))]))\n  (define (digits [list-of-digits])\n\
    \    (cond [(empty? list-of-digits) empty]\n          [(list=? empty (filter (curryr\
    \ = (first list-of-digits)) list-of-digits)) (cons (first list-of-digits) (digits\
    \ (rest list-of-digits)))]\n          [else (digits (filter (curryr != (first\
    \ list-of-digits)) list-of-digits))]))\n  (map number->string (map string->number\
    \ (digits (map string->number (numerals (string-split numbers)))))))\n", "  (define\
    \ (number-from-text txt)\n    (cond [(string=? txt \"zero\")  0]\n          [(string=?\
    \ txt \"one\")   1]\n          [(string=? txt \"two\")   2]\n          [(string=?\
    \ txt \"three\") 3]\n          [(string=? txt \"four\")  4]\n          [(string=?\
    \ txt \"five\")  5]\n          [(string=? txt \"six\")   6]\n          [(string=?\
    \ txt \"seven\") 7]\n          [(string=? txt \"eight\") 8]\n          [(string=?\
    \ txt \"nine\")  9]))\n  (define (text-from-number num)\n    (cond [(= num 0)\
    \ \"zero\"]\n          [(= num 1) \"one\"]\n          [(= num 2) \"two\"]\n  \
    \        [(= num 3) \"three\"]\n          [(= num 4) \"four\"]\n          [(=\
    \ num 5) \"five\"]\n          [(= num 6) \"six\"]\n          [(= num 7) \"seven\"\
    ]\n          [(= num 8) \"eight\"]\n          [(= num 9) \"nine\"]))\n  (define\
    \ (sort input-list)\n    (cond [(empty? input-list) '()]\n          [else (define\
    \ sorted-list (sort (cdr input-list)))\n                (cond [(or (empty? sorted-list)\n\
    \                           (&lt; (car input-list) (car sorted-list)))\n     \
    \                  (cons (car input-list) sorted-list)]\n                    \
    \  [else (cons (car sorted-list)\n                                  (sort-numbers\
    \ (cons (car input-list) (cdr sorted-list))))])]))\n  (string-join (map text-from-number\
    \ (sort (map number-from-text (string-split numbers)))) \" \"))\n</code>\nThis\
    \ works fine, but the sorting code looks pretty ugly. Is there a better way to\
    \ sort a list of numerals using recursion?\n\n\nA:\n\nYou're using recursion to\
    \ solve a problem that has a built-in solution. The built-in solution is called\
    \ <code>sort</code>. It allows you to pass in a custom ordering function, so if\
    \ you define that function to", "  (define digits '(zero one two three four five\
    \ six seven eight nine))\n  (local [(define (sort alon alat)\n            (define\
    \ (count-digit d a)\n              (if (empty? a)\n                  0\n     \
    \             (if (equal? (first a) d)\n                      (+ 1 (count-digit\
    \ d (rest a)))\n                      (count-digit d (rest a)))))\n          \
    \  (define (count-digit-helper a dlist)\n              (if (empty? dlist)\n  \
    \                (void)\n                  (begin\n                    (set! a\
    \ (append a (list (count-digit (first dlist) a))))\n                    (count-digit-helper\
    \ a (rest dlist)))))\n            (define (sort-helper a dlist)\n            \
    \  (if (empty? dlist)\n                  (void)\n                  (begin\n  \
    \                  (set! a (append a (list (first dlist))))\n                \
    \    (sort-helper a (rest dlist)))))\n            (define (sort-helper2 alist)\n\
    \              (if (empty? alist)\n                  (void)\n                \
    \  (begin\n                    (sort-helper2 (rest alist))\n                 \
    \   (sort-helper (list (first alist)) digits))))\n            (define (sort-helper3\
    \ alist)\n              (if (empty? alist)\n                  (void)\n       \
    \           (begin\n                    (sort-helper3 (rest alist))\n        \
    \            (set! alon (append alon (list (first alist)))))))\n            (define\
    \ (sort-helper4 alist)\n              (if (empty? alist)\n                  (void)\n\
    \                  (begin\n                    (sort-helper4 (rest alist))\n \
    \                   (set! alat (append alat (list (first alist)))))))\n      \
    \      (define (sort-helper5 alist)\n              (if (empty? alist)\n      \
    \            (void)\n                  (begin\n                    (sort-helper5\
    \ (rest alist))\n                    (set! alat (append alat (list (first alist)))))))\n\
    \            (define (sort-helper6 alist)\n              (if (empty? alist)\n\
    \                  (void)\n                  (begin\n                   ", " \
    \ ;; TODO\n  )\n", "  (define options '(\"zero\" \"one\" \"two\" \"three\" \"\
    four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"))\n  (define number-strings\
    \ (string-split numbers \" \"))\n  (define numbers-list (list))\n  (for ([number-string\
    \ number-strings])\n    (define number-index (list-ref options (string->number\
    \ number-string)))\n    (set! numbers-list (append numbers-list (list number-index))))\n\
    \  (string-join (sort numbers-list <) \" \"))\n", "  ;; Your solution goes here\n\
    \  )\n", "  (sort numbers < #:key numeral->number))\n", "  (let ([numbers-list\
    \ (string-split numbers \" \")])\n    (string-join (sort numbers-list number&lt;?)\
    \ \" \")))\n</code>\nBinary search\nI'll post a binary search function as well.\n\
    <code>#lang racket\n", "  (define (numeral-value numeral)\n    (cond ((string=?\
    \ numeral \"zero\") 0)\n          ((string=? numeral \"one\") 1)\n          ((string=?\
    \ numeral \"two\") 2)\n          ((string=? numeral \"three\") 3)\n          ((string=?\
    \ numeral \"four\") 4)\n          ((string=? numeral \"five\") 5)\n          ((string=?\
    \ numeral \"six\") 6)\n          ((string=? numeral \"seven\") 7)\n          ((string=?\
    \ numeral \"eight\") 8)\n          ((string=? numeral \"nine\") 9)))\n  (string-join\
    \ (sort < (map numeral-value (string-split numbers #\\space))) \" \"))\n", " \
    \ (sort-str (string-&gt;list numbers)\n            (curry string-ci&lt;? #\\space)\n\
    \            (build-list 10 #\\x)))\n", "  (define (numeral->number numeral)\n\
    \    (cond\n      ((string=? numeral \"zero\") 0)\n      ((string=? numeral \"\
    one\") 1)\n      ((string=? numeral \"two\") 2)\n      ((string=? numeral \"three\"\
    ) 3)\n      ((string=? numeral \"four\") 4)\n      ((string=? numeral \"five\"\
    ) 5)\n      ((string=? numeral \"six\") 6)\n      ((string=? numeral \"seven\"\
    ) 7)\n      ((string=? numeral \"eight\") 8)\n      ((string=? numeral \"nine\"\
    ) 9)))\n  (define (number->numeral number)\n    (cond\n      ((= number 0) \"\
    zero\")\n      ((= number 1) \"one\")\n      ((= number 2) \"two\")\n      ((=\
    \ number 3) \"three\")\n      ((= number 4) \"four\")\n      ((= number 5) \"\
    five\")\n      ((= number 6) \"six\")\n      ((= number 7) \"seven\")\n      ((=\
    \ number 8) \"eight\")\n      ((= number 9) \"nine\")))\n  (define (string->numbers\
    \ string)\n    (map numeral->number (string-split string)))\n  (define (numbers->string\
    \ numbers)\n    (string-join (map number->numeral numbers) \" \"))\n  (numbers->string\
    \ (sort < (string->numbers numbers))))\n```\n\n## Test suite\n\nSee the `test.rkt`\
    \ file. I used a basic unit testing framework from [How to Test Your Code in Racket,\
    \ Part I](https://blog.racket-lang.org/2017/03/how-to-test-your-code-in-racket-part-i.html)",
  "  (apply string-append\n         (sort\n          (for/list ([num numbers])\n \
    \           (cond ((equal? num \"zero\") 0)\n                  ((equal? num \"\
    one\") 1)\n                  ((equal? num \"two\") 2)\n                  ((equal?\
    \ num \"three\") 3)\n                  ((equal? num \"four\") 4)\n           \
    \       ((equal? num \"five\") 5)\n                  ((equal? num \"six\") 6)\n\
    \                  ((equal? num \"seven\") 7)\n                  ((equal? num\
    \ \"eight\") 8)\n                  ((equal? num \"nine\") 9)))\n          <)))\n\
    ```\n\nThis one is quite simple and I think the implementation quite straightforward.\n\
    \n### Count items\n\n```racket\n#lang racket\n", "  (local [(define numbers-list\
    \ (tokenize numbers))\n          (define numbers-sorted\n            (sort numbers-list\n\
    \                  <))]\n    (string-join numbers-sorted #\\space)))\n```\n\n\
    ### Example\n\n```\nnine two one eight three seven zero four five six\n```\n\n\
    ```\nzero one two three four five six seven eight nine\n```\n\n### [Original Problem](https://www.reddit.com/r/dailyprogrammer/comments/4eaeff/20160216_challenge_254_intermediate_sort_numbers/)",
  "  (define (number? s)\n    (member s '(\"zero\" \"one\" \"two\" \"three\" \"four\"\
    \ \"five\" \"six\" \"seven\" \"eight\" \"nine\")))\n  (define (numeral->number\
    \ s)\n    (cond\n      [(equal? s \"zero\") 0]\n      [(equal? s \"one\") 1]\n\
    \      [(equal? s \"two\") 2]\n      [(equal? s \"three\") 3]\n      [(equal?\
    \ s \"four\") 4]\n      [(equal? s \"five\") 5]\n      [(equal? s \"six\") 6]\n\
    \      [(equal? s \"seven\") 7]\n      [(equal? s \"eight\") 8]\n      [(equal?\
    \ s \"nine\") 9]))\n  (define (number->numeral n)\n    (cond\n      [(equal? n\
    \ 0) \"zero\"]\n      [(equal? n 1) \"one\"]\n      [(equal? n 2) \"two\"]\n \
    \     [(equal? n 3) \"three\"]\n      [(equal? n 4) \"four\"]\n      [(equal?\
    \ n 5) \"five\"]\n      [(equal? n 6) \"six\"]\n      [(equal? n 7) \"seven\"\
    ]\n      [(equal? n 8) \"eight\"]\n      [(equal? n 9) \"nine\"]))\n  (string-join\
    \ (map number->numeral (sort (map numeral->number (string-split numbers #\\space))))\
    \ \" \"))\n```\n\n## Other Solutions\n\n### Java\n\n```java\npublic class Kata\
    \ {\n  public static String sortNumbers(String numbers) {\n    final String[]\
    \ nums = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\",\
    \ \"seven\", \"eight\", \"nine\"};\n    final Map<String, Integer> intOfString\
    \ = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      intOfString.put(nums[i],\
    \ i);\n    }\n    final String[] parts = numbers.split(\" \");\n    Arrays.sort(parts,\
    \ (a, b) -> Integer.compare(intOfString.get(a), intOfString.get(b)));\n   ", " \
    \ (map (curry string-append \" \")\n       (sort string<?\n             (map substring\n\
    \                  (string-split numbers #\\ )))))\n", "  (define number-map (hash\
    \ \"zero\" 0 \"one\" 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\" 5 \"six\" 6 \"\
    seven\" 7 \"eight\" 8 \"nine\" 9))\n  (define (get-number number)\n    (hash-ref\
    \ number-map number))\n  (define (insert-sort list)\n    (define (insert-sort-k\
    \ item list)\n      (cond ((null? list)\n             (list item))\n         \
    \   ((< item (car list))\n             (cons item list))\n            (else\n\
    \             (cons (car list) (insert-sort-k item (cdr list))))))\n    (if (null?\
    \ list)\n        (list)\n        (insert-sort-k (car list) (insert-sort (cdr list)))))\n\
    \  (map (lambda (num) (hash-ref number-map num)) (insert-sort (map get-number\
    \ (string-split numbers)))))\n```\n\n```\n#lang racket\n", "  (define numeral-to-number\n\
    \    (hash\n     \"zero\" 0\n     \"one\" 1\n     \"two\" 2\n     \"three\" 3\n\
    \     \"four\" 4\n     \"five\" 5\n     \"six\" 6\n     \"seven\" 7\n     \"eight\"\
    \ 8\n     \"nine\" 9))\n  (define (number-to-numeral n)\n    (define numeral-to-number\n\
    \      (hash\n       0 \"zero\"\n       1 \"one\"\n       2 \"two\"\n       3\
    \ \"three\"\n       4 \"four\"\n       5 \"five\"\n       6 \"six\"\n       7\
    \ \"seven\"\n       8 \"eight\"\n       9 \"nine\"))\n    (hash-ref numeral-to-number\
    \ n))\n  (let loop ([numbers (string-&gt;list numbers)]\n             [acc '()])\n\
    \    (if (null? numbers)\n        (list-&gt;string (reverse acc))\n        (let\
    \ ([numeral (list-&gt;string (take-right numbers 5))])\n          (loop (drop-right\
    \ numbers 5)\n                (cons (number-to-numeral (hash-ref numeral-to-number\
    \ numeral)) acc))))))\n</code>\nI'd like to have a more Racket-y approach, using\
    \ library functions rather than hand-rolled code. I'm still new to Racket, but\
    \ I thought perhaps <code>foldl</code> might be useful here.\nThe code below is\
    \ a start, but I can't figure out how to use it to sort the numbers properly (I'm\
    \ not sure how to sort by the number in the string and not the actual string):\n\
    <code>#lang racket\n", "  (define numeral-list (list \"zero\" \"one\" \"two\"\
    \ \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"))\n  (define\
    \ (number->numeral number)\n    (cond\n      [(equal? number 0) \"zero\"]\n  \
    \    [(equal? number 1) \"one\"]\n      [(equal? number 2) \"two\"]\n      [(equal?\
    \ number 3) \"three\"]\n      [(equal? number 4) \"four\"]\n      [(equal? number\
    \ 5) \"five\"]\n      [(equal? number 6) \"six\"]\n      [(equal? number 7) \"\
    seven\"]\n      [(equal? number 8) \"eight\"]\n      [(equal? number 9) \"nine\"\
    ]))\n  (define (numeral->number numeral)\n    (cond\n      [(equal? numeral \"\
    zero\") 0]\n      [(equal? numeral \"one\") 1]\n      [(equal? numeral \"two\"\
    ) 2]\n      [(equal? numeral \"three\") 3]\n      [(equal? numeral \"four\") 4]\n\
    \      [(equal? numeral \"five\") 5]\n      [(equal? numeral \"six\") 6]\n   \
    \   [(equal? numeral \"seven\") 7]\n      [(equal? numeral \"eight\") 8]\n   \
    \   [(equal? numeral \"nine\") 9]))\n  (define (sort-numbers-with-numerals-and-numbers\
    \ numbers)\n    (define (sort-numbers-with-numerals-and-numbers-acc numbers acc)\n\
    \      (cond\n        [(null? numbers) (reverse acc)]\n        [else (sort-numbers-with-numerals-and-numbers-acc\
    \ (cdr numbers) (cons (number->numeral (car numbers)) acc))]))\n    (define (numerals-to-numbers\
    \ numerals)\n      (cond\n        [(null? numerals) '()]\n        [else (cons\
    \ (numeral->number (car numerals)) (numerals-to-numbers (cdr numerals)))]))\n\
    \    (numerals-to-numbers (sort-numbers-with-numerals-and-numbers-acc numbers\
    \ '())))\n  (define numbers-list (", "  (define numerals '((nine 9) (eight 8)\
    \ (seven 7) (six 6) (five 5) (four 4) (three 3) (two 2) (one 1) (zero 0)))\n \
    \ (cond\n    ((equal? numbers \"\") \"\")\n    ((equal? numbers \"zero\") \"zero\"\
    )\n    ((equal? numbers \"one\") \"one\")\n    ((equal? numbers \"two\") \"two\"\
    )\n    ((equal? numbers \"three\") \"three\")\n    ((equal? numbers \"four\")\
    \ \"four\")\n    ((equal? numbers \"five\") \"five\")\n    ((equal? numbers \"\
    six\") \"six\")\n    ((equal? numbers \"seven\") \"seven\")\n    ((equal? numbers\
    \ \"eight\") \"eight\")\n    ((equal? numbers \"nine\") \"nine\")\n    (else\n\
    \      (define words (string-split numbers #\\space))\n      (define numbers-list\
    \ (for/list ([word words])\n                              (match word\n      \
    \                          [('zero) 0]\n                                [('one)\
    \ 1]\n                                [('two) 2]\n                           \
    \     [('three) 3]\n                                [('four) 4]\n            \
    \                    [('five) 5]\n                                [('six) 6]\n\
    \                                [('seven) 7]\n                              \
    \  [('eight) 8]\n                                [('nine) 9])))\n      (define\
    \ sorted-numbers-list (sort numbers-list <))\n      (define sorted-words (for/list\
    \ ([num sorted-numbers-list])\n                              (match num\n    \
    \                            [(0) 'zero]\n                                [(1)\
    \ 'one]\n                                [(2) 'two]\n                        \
    \        [(3) 'three]\n                                [(4) 'four]\n         \
    \                       [(5) 'five]\n                                [(6) 'six]\n\
    \                                [(7) 'seven]\n                              \
    \  [(8) 'eight]\n                                [(9) 'nine])))\n      (string-join\
    \ sorted-words #\\space))\n    )\n  )\n", "  (string-join (sort (string-split\
    \ numbers) string<?)))\n```", "  (define number-map '(zero zero one one two two\
    \ three three four four five five six six seven seven eight eight nine nine))\n\
    \  (let ([sorted-numbers (string-split numbers)])\n    (sort sorted-numbers #:key\
    \ (compose string->number car number-map))\n    (apply string-join sorted-numbers)))\n",
  "  (let ([nums (string-split numbers)])\n    (define (sort-helper lst)\n      (cond\
    \ [(empty? lst) '()]\n            [(member (first lst) '(\"zero\" \"one\" \"two\"\
    \ \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"))\n       \
    \      (cons (first lst) (sort-helper (rest lst)))]\n            [else (sort-helper\
    \ (rest lst))]))\n    (let ([clean (sort-helper nums)])\n      (let ([final-lst\
    \ (map number->string (sort (map string->number clean) <))])\n        (string-join\
    \ final-lst)))))\n", "  (letrec ([num-to-int (lambda (num)\n                 \
    \        (match num\n                           [('zero) 0]\n                \
    \           [('one) 1]\n                           [('two) 2]\n              \
    \             [('three) 3]\n                           [('four) 4]\n         \
    \                  [('five) 5]\n                           [('six) 6]\n      \
    \                     [('seven) 7]\n                           [('eight) 8]\n\
    \                           [('nine) 9]))]\n           [int-to-num (lambda (int)\n\
    \                         (match int\n                           [0 'zero]\n \
    \                          [1 'one]\n                           [2 'two]\n   \
    \                        [3 'three]\n                           [4 'four]\n  \
    \                         [5 'five]\n                           [6 'six]\n   \
    \                        [7 'seven]\n                           [8 'eight]\n \
    \                          [9 'nine]))])\n    (match (string-split numbers)\n\
    \      [('() ...) \"\"]\n      [list (string-join (list-sort < (map num-to-int\
    \ list) int-to-num))])))\n", "  (sort (string-&gt;list numbers)\n        string&lt;?))\n\
    </code>\nI'd like to know if there's a built-in function in Racket that can do\
    \ the job.\n\n\nA:\n\nIt's not clear exactly what you want.\nIn Racket, you can\
    \ use <code>sort</code> with <code>string&lt;?</code> as the comparison operator,\
    \ if you want to sort strings.\nIf you want to sort by numbers in the string,\
    \ you should convert the numbers to numbers.\n", "  (sort (string-&gt;list numbers)\n\
    \        (lambda (a b)\n          (let ([a (number-&gt;string (string-&gt;number\
    \ (string a)))])\n            (let ([b (number-&gt;string (string-&gt;number (string\
    \ b)))])\n              (string&lt;? a b))))))\n</code>\n", "  (regexp-replace*\
    \ #rx\"zero\" numbers \"0\")\n  (regexp-replace* #rx\"one\" numbers \"1\")\n \
    \ (regexp-replace* #rx\"two\" numbers \"2\")\n  (regexp-replace* #rx\"three\"\
    \ numbers \"3\")\n  (regexp-replace* #rx\"four\" numbers \"4\")\n  (regexp-replace*\
    \ #rx\"five\" numbers \"5\")\n  (regexp-replace* #rx\"six\" numbers \"6\")\n \
    \ (regexp-replace* #rx\"seven\" numbers \"7\")\n  (regexp-replace* #rx\"eight\"\
    \ numbers \"8\")\n  (regexp-replace* #rx\"nine\" numbers \"9\")\n  (string-sort\
    \ (string-split numbers #\\space) #:key string-&gt;number))\n</code>\n", "  (define\
    \ (numbers->digits numbers)\n    (map\n     (lambda (s)\n       (cond\n      \
    \   ((equal? s \"zero\") 0)\n         ((equal? s \"one\") 1)\n         ((equal?\
    \ s \"two\") 2)\n         ((equal? s \"three\") 3)\n         ((equal? s \"four\"\
    ) 4)\n         ((equal? s \"five\") 5)\n         ((equal? s \"six\") 6)\n    \
    \     ((equal? s \"seven\") 7)\n         ((equal? s \"eight\") 8)\n         ((equal?\
    \ s \"nine\") 9)))\n     (string-split numbers #\\space)))\n  (define (digits->numbers\
    \ digits)\n    (map\n     (lambda (d)\n       (cond\n         ((equal? d 0) \"\
    zero\")\n         ((equal? d 1) \"one\")\n         ((equal? d 2) \"two\")\n  \
    \       ((equal? d 3) \"three\")\n         ((equal? d 4) \"four\")\n         ((equal?\
    \ d 5) \"five\")\n         ((equal? d 6) \"six\")\n         ((equal? d 7) \"seven\"\
    )\n         ((equal? d 8) \"eight\")\n         ((equal? d 9) \"nine\")))\n   \
    \  digits))\n  (let ((digits (numbers->digits numbers)))\n    (string-join (digits->numbers\
    \ (sort < digits)) #\\space)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
