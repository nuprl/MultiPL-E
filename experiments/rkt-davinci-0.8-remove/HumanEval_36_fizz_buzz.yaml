name: HumanEval_36_fizz_buzz
language: rkt
prompt: "#lang racket\n\n;; Return the number of times the digit 7 appears in integers\
  \ less than n which are divisible by 11 or 13.\n(define (fizz_buzz n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n\
  \    (check-equal? (candidate 50) 0)\n    (check-equal? (candidate 78) 2)\n    (check-equal?\
  \ (candidate 79) 3)\n    (check-equal? (candidate 100) 3)\n    (check-equal? (candidate\
  \ 200) 6)\n    (check-equal? (candidate 4000) 192)\n    (check-equal? (candidate\
  \ 10000) 639)\n    (check-equal? (candidate 100000) 8026)\n))\n\n(test-humaneval)"
completions: ["  (for/sum ([i (in-range 1 n)]\n            #:when (and (zero? (modulo\
    \ i 11))\n                        (zero? (modulo i 13))))\n    (count-occurrences\
    \ 7 (number->string i))))\n", "  (define (iter count acc)\n    (if (&gt; count\
    \ n)\n        acc\n        (let ([k (modulo count 11)])\n          (let ([k2 (modulo\
    \ count 13)])\n            (cond\n              [(= k 0) (iter (+ count 1) (if\
    \ (string-contains? (number-&gt;string count) \"7\") (+ acc 1) acc))]\n      \
    \        [(= k2 0) (iter (+ count 1) (if (string-contains? (number-&gt;string\
    \ count) \"7\") (+ acc 1) acc))]\n              [else (iter (+ count 1) acc)])))))\n\
    \  (iter 1 0))\n</code>\nThis is a simple loop iterating from 1 to <code>n</code>\
    \ (inclusive) and checking for each number if it's divisible by 11 or 13. If it\
    \ is, check if it contains the digit 7, and if it does, add 1 to the accumulator.\n\
    It could be shorter, but I think this one is easier to read.\n", "  (count (\u03BB\
    \ (x) (equal? (modulo x 11) 0)\n               (equal? (modulo x 13) 0)\n    \
    \           (contains? (number->string x) \"7\"))\n         (range 1 n)))\n```\n\
    \n### Solution in Racket\n```racket\n#lang racket\n", "  (define (fizzbuzz-if\
    \ divisible? s k)\n    (if (= 0 (modulo k divisible?))\n        (string-append\
    \ s (if (contains? #\\7 (number->string k)) \"fizz\" \"\"))\n        s))\n  (define\
    \ (loop counter acc)\n    (if (= n counter)\n        acc\n        (loop (+ counter\
    \ 1) (fizzbuzz-if 11 (fizzbuzz-if 13 acc counter) counter))))\n  (loop 1 0))\n",
  "  (for/sum ([i (in-range 1 n)])\n    (if (and (not (zero? (modulo i 11)))\n   \
    \          (not (zero? (modulo i 13))))\n        (count-matches #\\7 (number->string\
    \ i))\n        0)))\n```\n\n`racket`\n```racket\n#lang racket\n", "  (for/sum\
    \ ([x (in-range n)]\n            #:when (or (zero? (modulo x 11))\n          \
    \             (zero? (modulo x 13))))\n    (number->digit-list 7 x)))\n```\n\n\
    ```", "  (for/sum ([i (in-range 11 n)]\n            #:when (or (integer? (modulo\
    \ i 11))\n                       (integer? (modulo i 13))))\n    (count-matches\
    \ 7 (number->string i))))\n", "    (for/sum ([i (in-range 1 n)] #:when (and (and\
    \ (zero? (modulo i 11)) (zero? (modulo i 13))) (count (integer->list i) (lambda\
    \ (d) (= d 7)))))\n        1))\n```\n\nFirst, we want to make the indentation\
    \ consistent. Racket has a\n[style guide](https://docs.racket-lang.org/style/index.html)\
    \ that\nspecifies the indentation levels. While we could fix this with a\n`(begin`...`)`\
    \ in the function body, this would also have the effect of\n_evaluating_ all of\
    \ the `(in-range)` calls, but we don't want to do\nthat; we just want the `(for/sum)`\
    \ to refer to the _syntax_ of those\nexpressions. Instead, we can just insert\
    \ a line break before the\n`#:when` keyword, and reformat the `(in-range)` so\
    \ that it fits in a\nsingle line of code.\n\n```racket\n#lang racket\n", "  (for/sum\
    \ ([i (in-range n)])\n    (if (or (divisible? i 11) (divisible? i 13))\n     \
    \   (if (zero? (string-index \"7\" (number->string i))) 0 1)\n        0)))\n",
  "  (count n #f\n         (lambda (i)\n           (define (num7? n)\n           \
    \  (cond ((= n 0) #f)\n                   ((= (modulo n 10) 7) #t)\n         \
    \          (else (num7? (quotient n 10)))))\n           (or (and (num7? i) (or\
    \ (zero? (modulo i 11)) (zero? (modulo i 13)))) #f))))\n", "  (define (is_divisible_by_11?\
    \ n)\n    (and (is_divisible_by? n 11)\n         (not (is_divisible_by? n 13))))\n\
    \  (define (is_divisible_by_13? n)\n    (and (is_divisible_by? n 13)\n       \
    \  (not (is_divisible_by? n 11))))\n  (define (is_divisible_by_both? n)\n    (and\
    \ (is_divisible_by? n 11)\n         (is_divisible_by? n 13)))\n  (define (contains_seven?\
    \ n)\n    (if (= n 0)\n        #f\n        (if (= (remainder n 10) 7)\n      \
    \      #t\n            (contains_seven? (quotient n 10)))))\n  (define (count_sevens\
    \ n)\n    (cond ((= n 0) 0)\n          ((contains_seven? n) (count_sevens (quotient\
    \ n 10)) + 1)\n          (else (count_sevens (quotient n 10)))))\n  (define (count_sevens_in_divisible_numbers\
    \ n)\n    (cond ((= n 0) 0)\n          ((is_divisible_by_11? n) (count_sevens_in_divisible_numbers\
    \ (- n 1)) + (count_sevens n))\n          ((is_divisible_by_13? n) (count_sevens_in_divisible_numbers\
    \ (- n 1)) + (count_sevens n))\n          ((is_divisible_by_both? n) (count_sevens_in_divisible_numbers\
    \ (- n 1)) + (count_sevens n))\n          (else (count_sevens_in_divisible_numbers\
    \ (- n 1)))))\n  (count_sevens_in_divisible_numbers n))\n", "  (define (is_divisible_by\
    \ x y) (= (modulo x y) 0))\n  (define (num_of_sevens m)\n    (cond\n      [(=\
    \ m 7) 1]\n      [(= m 77) 2]\n      [(= m 77 77) 3]\n      [(= m 77 77 77) 4]\n\
    \      [(= m 77 77 77 77) 5]\n      [(= m 77 77 77 77 77) 6]\n      [(= m 77 77\
    \ 77 77 77 77) 7]\n      [(= m 77 77 77 77 77 77 77) 8]\n      [(= m 77 77 77\
    \ 77 77 77 77 77) 9]\n      [(= m 77 77 77 77 77 77 77 77 77) 10]\n      [(= m\
    \ 77 77 77 77 77 77 77 77 77 77) 11]\n      [(= m 77 77 77 77 77 77 77 77 77 77\
    \ 77) 12]\n      [(= m 77 77 77 77 77 77 77 77 77 77 77 77) 13]\n      [(= m 77\
    \ 77 77 77 77 77 77 77 77 77 77 77 77) 14]\n      [(= m 77 77 77 77 77 77 77 77\
    \ 77 77 77 77 77 77) 15]\n      [(= m 77 77 77 77 77 77 77 77 77 77 77 77 77 77\
    \ 77) 16]\n      [(= m 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77) 17]\n\
    \      [(= m 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77) 18]\n      [(=\
    \ m 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77) 19]\n      [(= m 77\
    \ 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77) 20]\n      [(= m 77 77\
    \ 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77) 21]\n      [(= m 77 77\
    \ 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77) 22]\n      [(= m 77\
    \ 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77) 23]\n      [(=\
    \ m 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77) 24]\n\
    \      [(", "  (count (range 0 n) (lambda (x)\n    (or (= (modulo x 11) 0) (=\
    \ (modulo x 13) 0)))))\n", "  (cond [(< n 1) 0]\n        [(or (zero? (modulo n\
    \ 11)) (zero? (modulo n 13)))\n         (+ (fizz_buzz (- n 1))\n            (count-sevens\
    \ n))]\n        [else (fizz_buzz (- n 1))]))\n", "  (let loop ([i 1] [count 0])\n\
    \    (cond [(> i n) count]\n          [(or (zero? (modulo i 11)) (zero? (modulo\
    \ i 13)))\n           (if (contains? (number->string i) #\\7)\n              \
    \ (loop (+ i 1) (+ count 1))\n               (loop (+ i 1) count))]\n        \
    \  [else (loop (+ i 1) count)])))\n", "  (check-expect (fizz_buzz 11) 1)\n  (check-expect\
    \ (fizz_buzz 12) 1)\n  (check-expect (fizz_buzz 13) 2)\n  (check-expect (fizz_buzz\
    \ 14) 2)\n  (check-expect (fizz_buzz 15) 3)\n  (check-expect (fizz_buzz 25) 5)\n\
    \  (check-expect (fizz_buzz 45) 8)\n  (check-expect (fizz_buzz 99) 13)\n  (check-expect\
    \ (fizz_buzz 100) 14)\n  (check-expect (fizz_buzz 150) 20)\n  (check-expect (fizz_buzz\
    \ 200) 28)\n  (check-expect (fizz_buzz 300) 42)\n  (check-expect (fizz_buzz 500)\
    \ 70)\n  (check-expect (fizz_buzz 1000) 140)\n  (check-expect (fizz_buzz 9999)\
    \ 1387)\n  (check-expect (fizz_buzz 10000) 1388)\n  (check-expect (fizz_buzz 15000)\
    \ 2077)\n  (check-expect (fizz_buzz 20000) 2838)\n  (check-expect (fizz_buzz 30000)\
    \ 4242)\n  (check-expect (fizz_buzz 50000) 7042)\n  (check-expect (fizz_buzz 100000)\
    \ 14070)\n  (check-expect (fizz_buzz 999999) 138637)\n  (check-expect (fizz_buzz\
    \ 1000000) 138638)\n  (check-expect (fizz_buzz 1500000) 207762)\n  (check-expect\
    \ (fizz_buzz 2000000) 283892)\n  (check-expect (fizz_buzz 3000000) 424218)\n \
    \ (check-expect (fizz_buzz 5000000) 704188)\n  (check-expect (fizz_buzz 10000000)\
    \ 1406922)\n", "  (define (fizz n)\n    (define (fizz_helper n count)\n      (cond\
    \ ((= n 0) count)\n            ((= (modulo n 10) 7) (fizz_helper (quotient n 10)\
    \ (+ count 1)))\n            (else (fizz_helper (quotient n 10) count))))\n  \
    \  (fizz_helper n 0))\n  (define (buzz n)\n    (define (buzz_helper n count)\n\
    \      (cond ((= n 0) count)\n            ((= (modulo n 10) 7) (buzz_helper (quotient\
    \ n 10) (+ count 1)))\n            (else (buzz_helper (quotient n 10) count))))\n\
    \    (buzz_helper n 0))\n  (define (fizz_buzz_helper n count)\n    (cond ((= n\
    \ 0) count)\n          ((and (zero? (modulo n 11)) (zero? (modulo n 13))) (fizz_buzz_helper\
    \ (- n 1) (+ count (fizz n) (buzz n))))\n          ((or (zero? (modulo n 11))\
    \ (zero? (modulo n 13))) (fizz_buzz_helper (- n 1) count))\n          (else (fizz_buzz_helper\
    \ (- n 1) count))))\n  (fizz_buzz_helper n 0))\n</code>\nThe problem here is that\
    \ the <code>fizz</code> and <code>buzz</code> functions seem to be called way\
    \ too many times. In fact, I think they are being called <code>n</code> times\
    \ each. Is there anyway I can call them only once each for each <code>fizz_buzz_helper</code>\
    \ iteration?\n\n\nA:\n\nProbably using a <code>count</code> helper (without a\
    \ <code>count</code> accumulator) as in:\n<code>(define (fizz-buzz n)\n  (define\
    \ (count n dig)\n    (if (zero? n)\n        0\n        (+ (if (= (modulo n 10)\
    \ dig) 1 0)\n           (count (quotient n 10) dig))))\n ", "  (if (not (number?\
    \ n)) (error \"The argument must be a number.\"))\n  (cond [(< n 1) (error \"\
    The argument must be an integer greater than or equal to 1.\")]\n        [(not\
    \ (integer? n)) (error \"The argument must be an integer greater than or equal\
    \ to 1.\")]\n        [else (for/sum ([i (in-range n)])\n                (if (or\
    \ (zero? (modulo i 11)) (zero? (modulo i 13)))\n                    (if (not (equal?\
    \ (integer->string i) \"7\"))\n                        (if (not (equal? (integer->string\
    \ i) \"17\"))\n                            (if (not (equal? (integer->string i)\
    \ \"27\"))\n                                (if (not (equal? (integer->string\
    \ i) \"37\"))\n                                    (if (not (equal? (integer->string\
    \ i) \"47\"))\n                                        (if (not (equal? (integer->string\
    \ i) \"57\"))\n                                            (if (not (equal? (integer->string\
    \ i) \"67\"))\n                                                (if (not (equal?\
    \ (integer->string i) \"77\"))\n                                             \
    \       (if (not (equal? (integer->string i) \"87\"))\n                      \
    \                                  (if (not (equal? (integer->string i) \"97\"\
    ))\n                                                            (if (not (equal?\
    \ (integer->string i) \"107\"))\n                                            \
    \                    (if (not (equal? (integer->string i) \"117\"))\n        \
    \                                                            (if (not (equal?\
    \ (integer->string i) \"127\"))\n                                            \
    \                            (if (not (equal? (integer->string i) \"137\"))\n\
    \                                                                            (if\
    \ (not (equal? (integer->string i) \"147\"))\n                               \
    \                                                 (if (not (equal? (integer->string\
    \ i) \"157\"))\n                                                             \
    \                       (if (not (equal? (integer->string i) \"167\"))\n     \
    \                                                                            \
    \       (if (not (equal? (integer->string i) \"177\"))\n                     \
    \                                                                       (if (not\
    \ (equal? (integer->string i) \"187\"))\n                                    \
    \                                                            (if (", "    (for/sum\
    \ ([i (in-range 1 n)]\n              #:when (or (zero? (modulo i 11))\n      \
    \                   (zero? (modulo i 13))))\n            (count-matches #\\7 (number->string\
    \ i))))\n", "  (for/sum ([i (in-range n)])\n    (if (or (divisible? i 11) (divisible?\
    \ i 13))\n        (count-7 i)\n        0)))\n</code>\n... is still quite a bit\
    \ faster. \n", "  (cond\n    [(< n 0) (error \"Argument must be non-negative\"\
    )]\n    [(zero? n) 0]\n    [else\n     (cond\n       [(or (zero? (modulo n 11))\
    \ (zero? (modulo n 13)))\n        (+ (if (zero? (modulo n 7)) 1 0) (fizz_buzz\
    \ (- n 1)))]\n       [else (fizz_buzz (- n 1))])]))\n", "  (cond [(= n 0) 0]\n\
    \        [(= (modulo n 11) 0) (+ 1 (fizz_buzz (- n 1)))]\n        [(= (modulo\
    \ n 13) 0) (+ 1 (fizz_buzz (- n 1)))]\n        [else (fizz_buzz (- n 1))]))\n",
  "  (let f ([i 0] [ans 0])\n    (cond [(>= i n) ans]\n          [(or (zero? (modulo\
    \ i 11)) (zero? (modulo i 13)))\n           (f (+ i 1) (+ ans (count-sevens i)))]\n\
    \          [else (f (+ i 1) ans)])))\n", "  (for/sum ([i (in-range 1 n)]\n   \
    \         #:when (and (not (zero? (modulo i 7)))\n                        (or\
    \ (zero? (modulo i 11))\n                            (zero? (modulo i 13)))))\n\
    \    (length (string-&gt;list (number-&gt;string i)))))\n</code>\nIt seems Racket\
    \ has a bunch of syntactic forms to allow manipulating sequences. What do they\
    \ mean?\n\nHow do you read <code>for/sum</code>? Is this the same as <code>for</code>\
    \ followed by <code>sum</code>? The latter sounds more logical to me.\nWhat does\
    \ the <code>#:when</code> mean?\n\n\n\nA:\n\nAs others have said, <code>for/sum</code>\
    \ is a macro.  It expands to a <code>for</code> loop that has a <code>sum</code>\
    \ inside.  As a result, the first two lines of code look like this if you expand\
    \ the <code>for/sum</code> macro:\n<code>(define (fizz_buzz n)\n  (for ([i (in-range\
    \ 1 n)]\n        #:when (and (not (zero? (modulo i 7)))\n                    (or\
    \ (zero? (modulo i 11))\n                        (zero? (modulo i 13)))))\n  \
    \  (sum (length (string-&gt;list (number-&gt;string i))))))\n</code>\nThis is\
    \ pretty much equivalent to the code you posted, except the <code>sum</code> function\
    \ is used instead of the <code>length</code> function.  The <code>sum</code> function\
    \ takes a list of numbers and adds them up, so in this case, it will sum the lengths\
    \ of all the strings.  With the <code>length</code> function, the code instead\
    \ calculates the length of every string, then adds them all up at the end.  Either\
    \ way, the result is the same, as the lengths of the strings are all one.\nThe\
    \ <code>#:when</code> clause is an optional argument to <code>for</code>.  If\
    \ you include it, Racket will only run the loop body if the condition is true.\
    \  As a result", "  (define (count-sevens n)\n    (cond\n      [(> n 9) 0]\n \
    \     [(= n 7) 1]\n      [else (count-sevens (/ n 10))]))\n  (define (fizz_buzz_helper\
    \ n acc)\n    (cond\n      [(= n 0) acc]\n      [(= (modulo n 11) 0) (fizz_buzz_helper\
    \ (- n 1) (+ acc (count-sevens n)))]\n      [(= (modulo n 13) 0) (fizz_buzz_helper\
    \ (- n 1) (+ acc (count-sevens n)))]\n      [else (fizz_buzz_helper (- n 1) acc)]))\n\
    \  (fizz_buzz_helper n 0))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n  \
    \  [(= n 2) 0]\n    [(= n 3) 0]\n    [(= n 4) 0]\n    [(= n 5) 0]\n    [(= n 6)\
    \ 0]\n    [(= n 7) 1]\n    [(= n 8) 1]\n    [(= n 9) 1]\n    [(= n 10) 1]\n  \
    \  [(= n 11) 2]\n    [(= n 12) 2]\n    [(= n 13) 2]\n    [(= n 14) 2]\n    [(=\
    \ n 15) 2]\n    [(= n 16) 2]\n    [(= n 17) 3]\n    [(= n 18) 3]\n    [(= n 19)\
    \ 3]\n    [(= n 20) 3]\n    [(= n 21) 3]\n    [(= n 22) 3]\n    [(= n 23) 3]\n\
    \    [(= n 24) 3]\n    [(= n 25) 3]\n    [(= n 26) 3]\n    [(= n 27) 3]\n    [(=\
    \ n 28) 3]\n    [(= n 29) 3]\n    [(= n 30) 3]\n    [(= n 31) 3]\n    [(= n 32)\
    \ 3]\n    [(= n 33) 3]\n    [(= n 34) 3]\n    [(= n 35) 3]\n    [(= n 36) 3]\n\
    \    [(= n 37) 3]\n    [(= n 38) 3]\n    [(= n 39) 3]\n    [(= n 40) 3]\n    [(=\
    \ n 41) 3]\n    [(= n 42) 3]\n    [(= n 43) 3]\n    [(= n 44) 3]\n    [(= n 45)\
    \ 3]\n    [(= n 46) 3]\n    [(= n 47) 3]\n    [(= n 48) 3]\n    [(= n 49) 3]\n\
    \    [(= n 50) 3]\n    [(= n 51) 3]\n    [(= n 52) 3]\n    [(= n 53) 3]\n    [(=\
    \ n 54) 3]\n    [(= n 55) 3]\n    [(=", "  (let ((x (modulo n 11))\n        (y\
    \ (modulo n 13)))\n    (cond ((= x 0) (+ (fizz_buzz (- n 1))\n               \
    \       (count-7 (- n 11))))\n          ((= y 0) (+ (fizz_buzz (- n 1))\n    \
    \                  (count-7 (- n 13))))\n          (else (fizz_buzz (- n 1))))))\n",
  "    (let loop ((i 1) (t 0))\n        (cond ((&gt; i n) t)\n              ((or (zero?\
    \ (modulo i 11)) (zero? (modulo i 13)))\n               (loop (+ i 1) (+ t (count_7\
    \ (number-&gt;string i)))))\n              (else (loop (+ i 1) t)))))\n", "  (cond\
    \ ((= n 0) 0)\n        ((and (integer? n) (= (modulo n 11) 0)) (+ 1 (fizz_buzz\
    \ (- n 1))))\n        ((and (integer? n) (= (modulo n 13) 0)) (+ 1 (fizz_buzz\
    \ (- n 1))))\n        (else (fizz_buzz (- n 1)))))\n", "  (for/sum ([i (in-range\
    \ n)])\n    (and (or (zero? (modulo i 11)) (zero? (modulo i 13)))\n         (not\
    \ (zero? (string-contains (number->string i) #\\7))))))\n", "  (count-appearances\
    \ n 7 11 13))\n</code>\nWhat you need to do to solve this problem is to use the\
    \ <code>count-appearances</code> function so that it returns the number of times\
    \ the digit 7 appears in the sequence <code>0,1,2,...,(n-1)</code>.\nSince the\
    \ <code>count-appearances</code> function will be used by a client programmer,\
    \ it is a good idea to give it a docstring that describes how to use it.\n", " \
    \ (apply + (map (\u03BB (x) (if (and (&lt;= 0 (modulo x 11))\n               \
    \                     (&lt;= 0 (modulo x 13)))\n                           x\n\
    \                           0))\n                  (range 0 n))))\n", "  (count\
    \ (\u03BB (x) (and (= (modulo x 11) 0) (= (modulo x 13) 0))) (range 1 (add1 n))))\n\
    </code>\nVersion 3\n<code>#lang racket\n", "  (for/sum ([i (in-range 1 (add1 n))])\n\
    \    (if (or (and (zero? (modulo i 11)) (zero? (modulo i 13)))\n            (regexp-match?\
    \ #rx\"7\" (number->string i)))\n        1\n        0)))\n", "  (define (helper\
    \ ctr i)\n    (cond\n      [(> i n) ctr]\n      [(and (= (modulo i 11) 0) (= (modulo\
    \ i 13) 0)) (helper (+ ctr (count-sevens i)) (+ i 1))]\n      [(or (= (modulo\
    \ i 11) 0) (= (modulo i 13) 0)) (helper ctr (+ i 1))]\n      [else (helper ctr\
    \ (+ i 1))]))\n  (helper 0 1))\n", "  (for/sum ([k (in-range 0 n 1)]\n       \
    \     #:when (or (zero? (modulo k 11))\n                       (zero? (modulo\
    \ k 13))))\n    (count (\u03BB (x) (= x #\\7)) (number->string k))))\n\n```\n\n\
    ```racket\n#lang racket\n", "  (let ([acc 0])\n    (for ([i (in-range n)])\n \
    \     (when (or (divisible? i 11) (divisible? i 13))\n        (set! acc (+ acc\
    \ (count-digit 7 i)))))\n    acc))\n</code>\n", "  (define (loop count)\n    (cond\n\
    \      ((= count n) 0)\n      ((or (= (modulo count 11) 0) (= (modulo count 13)\
    \ 0))\n       (+ (char-count #\\7 (number->string count)) (loop (+ count 1))))\n\
    \      (else (loop (+ count 1)))))\n  (loop 0))\n", '  (length (filter (lambda
    (x) (regexp-match #rx"7" (number->string x))) (build-list n (lambda (x) (+ x 1))))))',
  "  (letrec ([digit-7? (lambda (x)\n                       (or (eq? x 7)\n      \
    \                     (and (positive? x)\n                                (digit-7?\
    \ (remainder x 10)))))])\n    (letrec ([fizz-buzz-aux (lambda (n accum)\n    \
    \                          (cond\n                                [(= n 0) accum]\n\
    \                                [(and (zero? (remainder n 11))\n            \
    \                          (zero? (remainder n 13)))\n                       \
    \          (if (digit-7? n)\n                                     (fizz-buzz-aux\
    \ (- n 1) (+ accum 1))\n                                     (fizz-buzz-aux (-\
    \ n 1) accum))]\n                                [else (fizz-buzz-aux (- n 1)\
    \ accum)]))])\n      (fizz-buzz-aux n 0))))\n</code>\nHaskell\n<code>fizz_buzz\
    \ :: Int -&gt; Int\nfizz_buzz n = fizz_buzz_aux n 0\n\nfizz_buzz_aux :: Int -&gt;\
    \ Int -&gt; Int\nfizz_buzz_aux 0 accum = accum\nfizz_buzz_aux n accum = if ((n\
    \ `mod` 11 == 0) &amp;&amp; (n `mod` 13 == 0)) &amp;&amp; digit_7 n\n        \
    \                then fizz_buzz_aux (n - 1) (accum + 1)\n                    \
    \    else fizz_buzz_aux (n - 1) accum\n\ndigit_7 :: Int -&gt; Bool\ndigit_7 x\
    \ = or [x == 7, (x &gt; 0) &amp;&amp; digit_7 (x `mod` 10)]\n</code>\nPython\n\
    <code>def fizz_buzz(n):\n    return fizz_buzz_aux(n, 0)\n\ndef fizz_buzz_aux(n,\
    \ accum):\n    if n == 0:\n        return accum\n    elif (n % 11 == 0) and (n\
    \ % 13 == 0) and digit_7(n):\n        return fizz_buzz_aux(n - 1, accum + 1)\n\
    \    else:\n       ", "  (length (list-ref (list-tabulate (sub1 n) (lambda (x)\
    \ (if (and (or (integer? (/ x 11)) (integer? (/ x 13))) (integer? (/ x 7)))\n\
    \                                                         (list-ref (list->string\
    \ (+ x 1)) 2) 0))) 2)))\n", "  (let loop ([i n] [n7 0])\n    (cond [(= i 0) n7]\n\
    \          [(or (= (modulo i 11) 0) (= (modulo i 13) 0))\n           (let loop\
    \ ([j i] [digit 7] [n7 (+ n7 (if (= digit 7) 1 0))])\n             (cond [(= j\
    \ 0) n7]\n                   [else (loop (quotient j 10) (remainder j 10) n7)]))]\n\
    \          [else (loop (- i 1) n7)])))\n</code>\n", "  (for/sum ([k (in-range\
    \ 1 n)] #:when (and (multiple-of? k 11) (multiple-of? k 13)))\n    (count 7 (number->string\
    \ k))))\n", "  (let loop ([n n] [count 0])\n    (cond\n      [(= n 0) count]\n\
    \      [(or (zero? (modulo n 11)) (zero? (modulo n 13))) (loop (- n 1) (+ count\
    \ 1))]\n      [else (loop (- n 1) count)])))\n</code>\n", "  (let loop ([i 1]\
    \ [res 0])\n    (cond [(> i n) res]\n          [(or (zero? (modulo i 11)) (zero?\
    \ (modulo i 13))) (loop (+ i 1) (+ res (count 7 i)))]\n          [else (loop (+\
    \ i 1) res)])))\n", "  (count (lambda (x) (= (modulo x 11) 0)) n))\n", "  (cond\n\
    \    [(= n 0) 0]\n    [(= (modulo n 7) 0) (+ 1 (fizz_buzz (- n 1)))]\n    [else\
    \ (fizz_buzz (- n 1))]))\n</code>\nThe problem I'm having is that the function\
    \ doesn't stop as soon as <code>n</code> reaches 0. When I call <code>(fizz_buzz\
    \ 20)</code>, I get an error:\n<code>application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: -25\n  arguments...:\n\
    \   0\n</code>\nHow do I stop the recursion when n reaches 0?", "  (let ((x 13)\n\
    \        (y 11)\n        (result 0))\n    (for/fold ([result result]) ([i (+ x\
    \ y)])\n      (let ((sum (+ i x y)))\n        (if (&lt; sum n)\n            (begin\n\
    \              (let ((num (number-&gt;string sum)))\n                (if (or (string-contains\
    \ num \"7\")\n                        (string-contains num \"7\"))\n         \
    \           (set! result (+ result 1))))\n              (if (= x y)\n        \
    \          (set! x (+ x x y))\n                  (set! y (+ x y y))))\n      \
    \      (set! i n))))\n    result))\n</code>\nThe code above works as expected,\
    \ but I'm trying to evaluate it to see whether it is suitable for production.\
    \ It feels clunky and I'd like to know how it could be improved.\n", "  (if (&lt;\
    \ n 7) 0 (+ (or (and (zero? (modulo n 11)) (fizz_buzz (quotient n 10)) )\n   \
    \                     (and (zero? (modulo n 13)) (fizz_buzz (quotient n 10)) )\n\
    \                        (and (zero? (modulo n 7)) (fizz_buzz (quotient n 10))\
    \ )\n                        (and (zero? (modulo n 1)) (fizz_buzz (quotient n\
    \ 10)) )\n                        (and (zero? (modulo n 2)) (fizz_buzz (quotient\
    \ n 10)) )\n                        (and (zero? (modulo n 3)) (fizz_buzz (quotient\
    \ n 10)) )\n                        (and (zero? (modulo n 4)) (fizz_buzz (quotient\
    \ n 10)) )\n                        (and (zero? (modulo n 5)) (fizz_buzz (quotient\
    \ n 10)) )\n                        (and (zero? (modulo n 6)) (fizz_buzz (quotient\
    \ n 10)) )\n                        0)\n                      (if (or (zero? (modulo\
    \ n 7))\n                              (zero? (modulo n 1))\n                \
    \              (zero? (modulo n 2))\n                              (zero? (modulo\
    \ n 3))\n                              (zero? (modulo n 4))\n                \
    \              (zero? (modulo n 5))\n                              (zero? (modulo\
    \ n 6))\n                              (zero? (modulo n 11))\n               \
    \               (zero? (modulo n 13))) 1 0) )\n</code>\nI expect the input 987\
    \ to return 3, which it does. However, when I enter the input 987654, I expect\
    \ the output to be 6, but instead I get the error \"recursion depth exceeded.\"\
    \ I'm fairly new to Racket and recursion, so I'm hoping somebody can give me some\
    \ tips on how to fix this or at least point me in the right direction. Thanks!\n\
    \n\nA:\n\nThere are a number of problems with your code, but this should do what\
    \ you're looking for:\n<code>(define (fizz-buzz n)\n  (if (&lt; n 10)\n", "  (let\
    \ loop ([i n] [c 0])\n    (cond\n      [(= i 0) c]\n      [(and (divisible? i\
    \ 11) (divisible? i 13))\n       (loop (- i 1) (count_7 (+ c (count_7 i))))]\n\
    \      [(or (divisible? i 11) (divisible? i 13))\n       (loop (- i 1) (count_7\
    \ c))]\n      [else (loop (- i 1) c)])))\n", "  (cond\n    [(= n 0) 0]\n    [(=\
    \ (modulo n 11) 0) (+ 1 (fizz_buzz (- n 1)))]\n    [(= (modulo n 13) 0) (+ 1 (fizz_buzz\
    \ (- n 1)))]\n    [else (fizz_buzz (- n 1))]))\n", "  (count-matches/filter 'digit-contains?\
    \ 7 (range 11 13 n)))\n", "  (length (filter \n           (lambda (x) (or (equal?\
    \ (remainder x 11) 0) (equal? (remainder x 13) 0)))\n           (filter (lambda\
    \ (x) (char-numeric? (string-ref (number->string x) (sub1 (string-length (number->string\
    \ x))))))\n                   (range 1 n)))))\n```\nHere's another solution, using\
    \ a list-comprehension and using `char-numeric?` to check if an element is a number:\n\
    ``` #lang racket", "  (cond\n    [(= 0 (modulo n 11))\n     (+ 1 (fizz_buzz (-\
    \ n 1)))]\n    [(= 0 (modulo n 13))\n     (+ 1 (fizz_buzz (- n 1)))]\n    [else\n\
    \     (fizz_buzz (- n 1))]))\n", "  (if (zero? n) 0\n      (if (or (zero? (modulo\
    \ n 11)) (zero? (modulo n 13)))\n          (+ 1 (fizz_buzz (- n 1)))\n       \
    \   (fizz_buzz (- n 1)))))\n</code>\nA few questions:\n\nIs this idiomatic Racket?\n\
    Can this be written more succinctly?\nIs there a way to simplify the line <code>(if\
    \ (or (zero? (modulo n 11)) (zero? (modulo n 13)))</code>?\n\n\n\nA:\n\nHere's\
    \ a function that counts the occurrences of <code>7</code> in a number:\n<code>(define\
    \ (count-7 n)\n  (cond [(zero? n) 0]\n        [(= (remainder n 10) 7) 1]\n   \
    \     [else (count-7 (quotient n 10))]))\n</code>\nThen you can just write a function\
    \ that counts the occurrences of <code>7</code> in numbers less than <code>n</code>\
    \ that are divisible by <code>11</code> or <code>13</code>:\n<code>(define (fizz-buzz\
    \ n)\n  (cond [(zero? n) 0]\n        [(or (zero? (remainder n 11))\n         \
    \    (zero? (remainder n 13)))\n         (+ (count-7 n) (fizz-buzz (- n 1)))]\n\
    \        [else (fizz-buzz (- n 1))]))\n</code>\nIf you want to be clever, you\
    \ can use the <code>for</code> macro and make it a one-liner:\n<code>(define (fizz-buzz\
    \ n)\n  (for/sum ([i (in-range n)])\n    (if (or (zero? (remainder i 11))\n  \
    \          (zero? (remainder i 13)))\n        (count-7 i)\n        0)))\n</code>\n",
  "  (cond [(zero? n) 0]\n        [(and (zero? (modulo n 11)) (zero? (modulo n 13)))\n\
    \         (+ (count-7s (- n 1)) (count-7s (quotient n 10)))]\n        [else (fizz_buzz\
    \ (- n 1))]))\n", "  (count-matches (map number->string (filter (lambda (x) (or\
    \ (zero? (modulo x 11)) (zero? (modulo x 13)))) (range 1 n))) \"7\"))\n</code>\n\
    My function takes an integer n and returns the number of times the digit 7 appears\
    \ in integers less than n which are divisible by 11 or 13. \nFor example, if n\
    \ = 123456, it should return the number of times the digit 7 appears in the integers\
    \ between 1 and 123456 which are divisible by 11 or 13.\nThe three helper functions\
    \ are given to me (range, count-matches, and number->string) and I can't change\
    \ them. I'm not allowed to use a for loop either. \nI'm trying to figure out how\
    \ to print out each number I filter through. I want to make sure that I'm filtering\
    \ the correct numbers. If the number is divisible by 11 or 13, I want to print\
    \ it out. How can I do this? The range function is returning all the numbers from\
    \ 1 to n. \n<code>(define (range a b)\n  (if (&gt; a b) '()\n      (cons a (range\
    \ (+ a 1) b))))\n</code>\nThe count-matches function takes a list and a value\
    \ and returns the number of times the value occurs in the list.\n<code>(define\
    \ (count-matches alist value)\n  (if (null? alist) 0\n      (+ (if (equal? (car\
    \ alist) value) 1 0)\n         (count-matches (cdr alist) value))))\n</code>\n\
    The number->string function converts a number to a string.\n<code>(define (number-&gt;string\
    \ number)\n  (if (zero? number) \"\"\n      (number-&gt;string (quotient number\
    \ 10))\n      (string-append (make-string 1 (+ (remainder number 10) (string-&gt;number\
    \ \"0\"))) \"\")))\n</code>\n\n\nA:\n\nOne example of a <code>fizz-buzz</code>\
    \ function.\n<code>(define (fizz-buzz n)\n  (let loop ((n n) (c 0))\n    (cond\
    \ ((&lt; n 11) c)\n          ((and", "  (cond\n    [(= n 0) 0]\n    [(integer?\
    \ n)\n     (let ([digit (modulo n 10)])\n       (cond\n         [(or (= digit\
    \ 7) (= digit (- 10 digit)))\n          (+ 1 (fizz_buzz (quotient n 10)))]\n \
    \        [else (fizz_buzz (quotient n 10))]))]\n    [else\n     (error \"negative\
    \ number\")]))\n", "  (define (helper current-n)\n    (cond ((> current-n n) 0)\n\
    \          ((and (= (modulo current-n 11) 0) (= (modulo current-n 13) 0))\n  \
    \         (+ (count-7s current-n) (helper (+ current-n 1))))\n          ((or (=\
    \ (modulo current-n 11) 0) (= (modulo current-n 13) 0))\n           (helper (+\
    \ current-n 1)))\n          (else (helper (+ current-n 1)))))\n  (helper 1))\n",
  "  (local [(define (f-b-h m counter)\n            (cond\n              [(= m 0)\n\
    \               counter]\n              [(and (zero? (modulo m 11)) (zero? (modulo\
    \ m 13)))\n               (f-b-h (- m 1) (+ (count_seven m) counter))]\n     \
    \         [else\n               (f-b-h (- m 1) counter)]))]\n    (f-b-h n 0)))\n\
    </code>\nI am interested in how to shorten and improve this code. \n\n\nA:\n\n\
    Here's one possibility that doesn't use recursion:\n<code>(define (fizz-buzz n)\n\
    \  (define (count-seven number)\n    (if (zero? number)\n        0\n        (if\
    \ (= (modulo number 10) 7)\n            (+ 1 (count-seven (quotient number 10)))\n\
    \            (count-seven (quotient number 10)))))\n  (let loop ([acc 0] [num\
    \ n])\n    (if (&lt; num 11)\n        acc\n        (if (or (zero? (modulo num\
    \ 11)) (zero? (modulo num 13)))\n            (loop (+ acc (count-seven num)) (-\
    \ num 1))\n            (loop acc (- num 1))))))\n</code>\nNote that the <code>count-seven</code>\
    \ function can be implemented using a <code>for/fold</code> macro:\n<code>(define\
    \ (count-seven number)\n  (for/fold ([count 0]) ([digit (in-list (number-&gt;list\
    \ number))])\n    (if (= digit 7)\n        (+ count 1)\n        count)))\n</code>\n",
  "  (for/sum ([i (in-range 1 n)]\n            #:when (and (integer? (/ i 11))\n \
    \                       (integer? (/ i 13))))\n    (let loop ([i i]\n        \
    \       [count 0])\n      (cond [(< i 1) count]\n            [(not (integer? (/\
    \ i 10))) count]\n            [(= (modulo i 10) 7) (loop (quotient i 10) (+ count\
    \ 1))]\n            [else (loop (quotient i 10) count)]))))", "  (for/sum ([i\
    \ (in-range n)])\n    (if (or (divisible? i 11) (divisible? i 13))\n        (count-7s\
    \ i)\n        0)))\n", "  (cond ((= n 0) 0)\n        ((or (even? (modulo n 11))\
    \ (even? (modulo n 13)))\n         (+ (member-of? (number->string n) \"7\") (fizz_buzz\
    \ (- n 1))))\n        (else (fizz_buzz (- n 1)))))\n", "  (count-number-7s-11-13\
    \ n 0))\n", "  (define (rec i)\n    (cond\n      [(< i n)\n       (if (or (zero?\
    \ (modulo i 11)) (zero? (modulo i 13)))\n           (+ (count 7 i) (rec (+ i 1)))\n\
    \           (rec (+ i 1)))]\n      [else 0]))\n  (rec 0))\n", "  (cond ((< n 1)\
    \ 0)\n        ((and (zero? (modulo n 11))\n              (zero? (modulo n 13)))\n\
    \         (+ (even? (modulo n 7))\n            (fizz_buzz (- n 1))))\n       \
    \ (else (fizz_buzz (- n 1)))))\n```\n\nConvert this code to use a loop, rather\
    \ than recursion.\n\n```racket\n#lang racket\n", "  (letrec ([is-fizz-buzz? (lambda\
    \ (n)\n                            (or (= (modulo n 11) 0) (= (modulo n 13) 0)))]\n\
    \           [fizz-buzz-helper (lambda (n)\n                               (cond\
    \ [(< n 10) (if (= n 7) 1 0)]\n                                     [(= (modulo\
    \ n 10) 7) (+ 1 (fizz-buzz-helper (quotient n 10)))]\n                       \
    \              [else (fizz-buzz-helper (quotient n 10))]))])\n    (let loop ([counter\
    \ 1] [s 0])\n      (if (= counter n)\n          s\n          (let ([next-counter\
    \ (+ counter 1)])\n            (if (is-fizz-buzz? counter)\n                (loop\
    \ next-counter (+ s (fizz-buzz-helper counter)))\n                (loop next-counter\
    \ s)))))))\n", "  (define (range s e)\n    (cond ((= s e) '())\n          (else\
    \ (cons s (range (+ s 1) e)))))\n  (define (divisible? d n)\n    (= (modulo n\
    \ d) 0))\n  (define (seven? n)\n    (eq? (modulo n 10) 7))\n  (define (smaller-than-n?\
    \ n x)\n    (&lt; x n))\n  (define (count-7 l)\n    (if (null? l)\n        0\n\
    \        (+ (if (seven? (car l)) 1 0)\n           (count-7 (cdr l)))))\n  (count-7\
    \ (filter (\u03BB (x) (and (divisible? 11 x) (divisible? 13 x)))\n           \
    \        (filter smaller-than-n? (range 1 n)))))\n</code>\nRacket has some nice\
    \ syntactic sugar for lambda, so you don't need those\nfunction definitions. It\
    \ also has a handy <code>filter</code> function, but it returns a\nlist (and we\
    \ only need the count), so we need to flatten it.\n<code>#lang racket\n", "  (cond\n\
    \    [(> n 1) (+ (fizz_buzz (- n 1)) (count_7s (- n 1)))]\n    [else 0]))\n",
  "  (define (ends-in-7? x) (= (modulo x 10) 7))\n  (define (div-by-11-or-13? x) (or\
    \ (= (modulo x 11) 0) (= (modulo x 13) 0)))\n  (define (helper i)\n    (cond ((>\
    \ i n) 0)\n          ((and (ends-in-7? i) (div-by-11-or-13? i)) (+ 1 (helper (+\
    \ i 1))))\n          (else (helper (+ i 1)))))\n  (helper 1))\n", "  (cond [(zero?\
    \ n) 0]\n        [(zero? (modulo n 11))\n         (+ (if (or (zero? (modulo n\
    \ 77)) (zero? (modulo n 7))) 1 0)\n            (fizz_buzz (- n 1)))]\n       \
    \ [(zero? (modulo n 13))\n         (+ (if (or (zero? (modulo n 77)) (zero? (modulo\
    \ n 7))) 1 0)\n            (fizz_buzz (- n 1)))]\n        [else (fizz_buzz (-\
    \ n 1))]))\n", "  (for/sum ([i (in-range 0 n 11)]) (count-matches #\\7 (number->string\
    \ i))))\n```\n\n## Installation\n\n1. Download [Racket](https://download.racket-lang.org/)\n\
    2. `raco pkg install [package]`\n3. `racket -t [file]`", "  (define count 0)\n\
    \  (define (is-divisible? x)\n    (or (zero? (modulo x 11))\n        (zero? (modulo\
    \ x 13))))\n  (define (has-seven? x)\n    (and (is-divisible? x)\n         (cond\
    \ ((zero? x) #f)\n               ((= (modulo x 10) 7) #t)\n               (else\
    \ (has-seven? (quotient x 10))))))\n  (define (iter i)\n    (cond ((&gt; i n)\
    \ count)\n          ((has-seven? i)\n           (set! count (+ count 1))\n   \
    \        (iter (+ i 1)))\n          (else (iter (+ i 1)))))\n  (iter 1))\n</code>\n\
    The very first time I ran this in Racket it gave the correct answer, <code>10</code>.\
    \ The next time I ran it it gave the wrong answer, <code>0</code>. Then it gave\
    \ the correct answer, <code>10</code>. The next time it gave the wrong answer,\
    \ <code>0</code>. Then the correct answer, <code>10</code>. And so on.\nWhat is\
    \ wrong with this code?\nAlso, what is the correct way to solve this problem in\
    \ the Racket language?\n\n\nA:\n\nYou need to change the <code>set!</code> to\
    \ an imperative <code>set!</code> since the variable is in a <code>define</code>ed\
    \ function.\nAlso, the proper way to write this code is to use <code>for/fold</code>.\
    \ \n<code>(define (fizz-buzz n)\n  (for/fold ([count 0])\n            ([i (in-range\
    \ 1 n)])\n    (if (or (zero? (modulo i 11))\n            (zero? (modulo i 13)))\n\
    \        (if (zero? (modulo i 10))\n            count\n            (if (= (modulo\
    \ i 10) 7)\n                (+ count 1)\n                count))\n        count)))\n\
    </code>\n", "  (for/sum ([i (in-range n)])\n    (cond ((and (not (zero? (modulo\
    \ i 11))) (not (zero? (modulo i 13)))) 1)\n          (else 0))))\n", "  (let loop\
    \ ([i 1] [count 0])\n    (cond\n      [(= i n) count]\n      [(or (zero? (modulo\
    \ i 11)) (zero? (modulo i 13))) (let ([num (number->string i)])\n            \
    \                                               (define (contains-7? num)\n  \
    \                                                           (cond\n          \
    \                                                     [(string=? num \"\") #f]\n\
    \                                                               [(char=? (string-ref\
    \ num 0) #\\7) #t]\n                                                         \
    \      [else (contains-7? (substring num 1))]))\n                            \
    \                               (if (contains-7? num)\n                      \
    \                                         (loop (+ i 1) (+ count 1))\n       \
    \                                                        (loop (+ i 1) count)))]\n\
    \      [else (loop (+ i 1) count)])))\n", "  (cond\n    [(< n 7) 0]\n    [(= (modulo\
    \ n 11) 0) (+ 1 (fizz_buzz (- n 1)))]\n    [(= (modulo n 13) 0) (+ 1 (fizz_buzz\
    \ (- n 1)))]\n    [else (fizz_buzz (- n 1))]))\n", "  (define (helper s n)\n \
    \   (cond [(= n 0) s]\n          [(or (zero? (modulo n 11)) (zero? (modulo n 13)))\
    \ (helper (+ (if (equal? (modulo n 10) 7) 1 0) s) (quotient n 10))]\n        \
    \  [else (helper s (quotient n 10))]))\n  (helper 0 n))\n</code>\nWhen I run the\
    \ above code, I get an error message:\n<code>tr3.rkt:11:2: cond: bad syntax in:\
    \ (or (zero? (modulo n 11)) (zero? (modulo n 13)))\n</code>\nIs there anything\
    \ wrong with my code?\n\n\nA:\n\nYou need a pair of parentheses around the <code>cond</code>\
    \ clause's body.\n<code>(cond [...\n       ...]\n      ...)\n</code>\nLike this:\n\
    <code>(define (fizz_buzz n)\n  (define (helper s n)\n    (cond [(= n 0) s]\n \
    \         [(or (zero? (modulo n 11)) (zero? (modulo n 13)))\n           (helper\
    \ (+ (if (equal? (modulo n 10) 7) 1 0) s) (quotient n 10))]\n          [else (helper\
    \ s (quotient n 10))]))\n  (helper 0 n))\n</code>\nWithout the parentheses, everything\
    \ is considered part of the <code>cond</code> clause, and <code>cond</code> is\
    \ expecting a list of the form:\n<code>(boolean value)\n</code>\nSo the <code>or</code>\
    \ is interpreted as a boolean.\n", "  (define (divides? n m) (= (remainder n m)\
    \ 0))\n  (define (make-integer-generator)\n    (let ((i 0))\n      (lambda ()\n\
    \        (set! i (+ i 1))\n        i)))\n  (define (digit-seven? n)\n    (let\
    \ ((quotient (/ n 10))\n          (remainder (remainder n 10)))\n      (cond ((and\
    \ (= quotient 0) (= remainder 7)) #t)\n            ((and (&gt; quotient 0) (=\
    \ remainder 7)) #t)\n            ((and (&gt; quotient 0) (/= remainder 7)) (digit-seven?\
    \ quotient))\n            (else #f))))\n  (define (seven-counter n)\n    (let\
    \ ((gen (make-integer-generator)))\n      (define (count n)\n        (let ((i\
    \ (gen)))\n          (cond ((&gt; i n) n)\n                ((and (digit-seven?\
    \ i) (or (divides? i 11) (divides? i 13))) (count (+ n 1)))\n                (else\
    \ (count n)))))\n      (count 0)))\n  (seven-counter n))\n</code>\nExample usage:\n\
    <code>&gt; (fizz_buzz 37)\n1\n&gt; (fizz_buzz 101)\n9\n&gt; (fizz_buzz 12345)\n\
    209\n</code>\nI'm not sure if I am supposed to use <code>map</code> or something\
    \ similar to accomplish the task, but I don't think it's possible without the\
    \ use of a generator. Do you have any ideas for improvements?\n\n\nA:\n\n<code>#lang\
    \ racket\n", "  (define (digit7? n)\n    (and\n     (= 7 (modulo n 10))\n    \
    \ (or\n      (= 0 (modulo n 11))\n      (= 0 (modulo n 13)))))\n  (for/sum ([n\
    \ (in-range 1 n)])\n    (if (digit7? n) 1 0)))\n", "  (define (helper n)\n   \
    \ (cond\n      [(= n 0) 0]\n      [(divisible? n 11)\n       (+ 1\n          (helper\
    \ (- n 1)))]\n      [(divisible? n 13)\n       (+ 1\n          (helper (- n 1)))]\n\
    \      [else\n       (helper (- n 1))]))\n  (helper n))\n", "  (let loop ([x 0]\
    \ [count 0])\n    (cond [(< x n)\n           (cond [(and (zero? (modulo x 11))\
    \ (zero? (modulo x 13)))\n                  (loop (+ x 1) (+ count (count-7s x)))]\n\
    \                 [else (loop (+ x 1) count)])]\n          [else count])))\n",
  "  (define (divisible? n m)\n    (= (modulo n m) 0))\n  (define (seven? x)\n   \
    \ (and\n     (string=? (number->string x) \"7\")\n     (not (string=? (number->string\
    \ x) \"77\"))))\n  (define (loop counter acc)\n    (cond\n      [(> counter n)\
    \ acc]\n      [(or (divisible? counter 11) (divisible? counter 13))\n       (loop\
    \ (+ counter 1) (+ acc (seven? counter)))]\n      [else (loop (+ counter 1) acc)]))\n\
    \  (loop 1 0))\n", "  (for/sum ([i (- n 1)])\n           (let ([x (modulo i 11)]\n\
    \                 [y (modulo i 13)])\n             (cond [(and (= 0 x) (= 0 y))\
    \ 3]\n                   [(or (= 0 x) (= 0 y)) 1]\n                   [else 0]))))\n\
    </code>\n", "  (for/sum ([i (in-range 1 n)]\n            #:when (or (zero? (modulo\
    \ i 11))\n                       (zero? (modulo i 13))))\n    (count-matches #\\\
    7 (number->string i))))\n", "  (cond [(equal? n 0) 0]\n        [(equal? n 1) 0]\n\
    \        [(equal? n 2) 0]\n        [(equal? n 3) 0]\n        [(equal? n 4) 0]\n\
    \        [(equal? n 5) 0]\n        [(equal? n 6) 0]\n        [(equal? n 7) 1]\n\
    \        [(equal? n 8) 0]\n        [(equal? n 9) 0]\n        [(equal? n 10) 0]\n\
    \        [(equal? n 11) 1]\n        [(equal? n 12) 0]\n        [(equal? n 13)\
    \ 1]\n        [(equal? n 14) 0]\n        [(equal? n 15) 0]\n        [(equal? n\
    \ 16) 0]\n        [(equal? n 17) 0]\n        [(equal? n 18) 0]\n        [(equal?\
    \ n 19) 0]\n        [(equal? n 20) 0]\n        [(equal? n 21) 0]\n        [(equal?\
    \ n 22) 0]\n        [(equal? n 23) 0]\n        [(equal? n 24) 0]\n        [(equal?\
    \ n 25) 0]\n        [(equal? n 26) 0]\n        [(equal? n 27) 0]\n        [(equal?\
    \ n 28) 0]\n        [(equal? n 29) 0]\n        [(equal? n 30) 0]\n        [(equal?\
    \ n 31) 0]\n        [(equal? n 32) 0]\n        [(equal? n 33) 0]\n        [(equal?\
    \ n 34) 0]\n        [(equal? n 35) 0]\n        [(equal? n 36) 0]\n        [(equal?\
    \ n 37) 0]\n        [(equal? n 38) 0]\n        [(equal? n 39) 0]\n        [(equal?\
    \ n 40) 0]\n        [(equal? n 41) 0]\n        [(equal? n 42) 0]\n        [(equal?\
    \ n 43) 0]\n        [(equal? n 44) 0]\n        [(equal? n 45) 0]\n        [(equal?\
    \ n 46) 0]\n        [(equal? n 47) 0]\n        [(equal? n 48) 0]\n        [(equal?\
    \ n 49) 0]\n        [(equal? n 50) 0]", "  (for/sum ([i (in-range 1 n)] #:when\
    \ (integer? (sqrt (sqrt i))))\n    (for/sum ([j (in-range 1 n)] #:when (integer?\
    \ (/ j 3)))\n      (for/sum ([k (in-range 1 n)] #:when (integer? (/ k 5)))\n \
    \       1))))\n</code>\nEdit:\nAfter learning that this solution is not correct,\
    \ I came up with this variation. Is this correct?\n<code>#lang racket\n", "  (let\
    \ loop ([x n] [y n] [c 0])\n    (cond [(< x 0) c]\n          [(and (= (modulo\
    \ x 11) 0) (= (modulo x 13) 0)) (loop (- x 1) (exact->inexact (/ x 10)) (+ c (if\
    \ (= 7 (quotient y 10)) 1 0)))]\n          [(= (modulo x 11) 0) (loop (- x 1)\
    \ (exact->inexact (/ x 10)) (+ c (if (= 7 (quotient y 10)) 1 0)))]\n         \
    \ [(= (modulo x 13) 0) (loop (- x 1) (exact->inexact (/ x 10)) (+ c (if (= 7 (quotient\
    \ y 10)) 1 0)))]\n          [else (loop (- x 1) (exact->inexact (/ x 10)) c)])))\n",
  "  (define (count_7s i)\n    (cond [(= i 0) 0]\n          [(= (remainder i 10) 7)\
    \ (+ 1 (count_7s (quotient i 10)))]\n          [else (count_7s (quotient i 10))]))\n\
    \  (define (count_in_range i n)\n    (cond [(= i n) 0]\n          [(or (= (remainder\
    \ i 11) 0) (= (remainder i 13) 0)) (+ (count_7s i) (count_in_range (+ i 1) n))]\n\
    \          [else (count_in_range (+ i 1) n)]))\n  (count_in_range 1 n))\n", " \
    \ (cond [(< 0 n) (+ (count-sevens n) (fizz_buzz (- n 1)))]\n        [else 0]))\n",
  "  (count-if (lambda (x) (or (modulo x 11) (modulo x 13))) (make-digit-vector n\
    \ 7)))\n", "  (cond\n    [(= 1 n) 1]\n    [(= 7 (modulo n 10)) (+ 1 (fizz_buzz\
    \ (quotient n 10)))]\n    [else (fizz_buzz (quotient n 10))]))\n", "  (cond\n\
    \    [(equal? n 7) 1]\n    [(integer? n) (cond\n                   [(equal? (modulo\
    \ n 11) 0) (if (equal? (modulo n 13) 0) (+ (fizz_buzz (- n 1)) 2) (fizz_buzz (-\
    \ n 1)))]\n                   [(equal? (modulo n 13) 0) (fizz_buzz (- n 1))]\n\
    \                   [else 0])]\n    [else (error \"Not a valid integer\")]))\n\
    ```\n\n```\n> (fizz_buzz 100)\n6\n```\n\n### Sum of Digits\n\n```\n#lang racket\n",
  "  (for/sum ([i (in-range 0 n)]\n            #:when (or (zero? (modulo i 11))\n\
    \                       (zero? (modulo i 13))))\n    (count-matches #\\7 (number->string\
    \ i))))\n", "  (define (next i)\n    (cond\n      [(= i n) 0]\n      [(or (= (modulo\
    \ i 11) 0) (= (modulo i 13) 0))\n       (+ (count_digit 7 i) (next (+ i 1)))]\n\
    \      [else (next (+ i 1))]))\n  (next 1))\n", "  (if (or (= n 11) (= n 13))\
    \ 1\n      (+ (if (zero? (modulo n 11)) (fizz_buzz (- n 1)) 0)\n         (if (zero?\
    \ (modulo n 13)) (fizz_buzz (- n 1)) 0))))\n</code>\nHowever, it's rather inefficient.\
    \ For <code>n = 10^k</code>, the running time is proportional to $n$ times the\
    \ number of occurrences of 7 in the decimal expansion of the integer $n!$. There\
    \ are heuristics for estimating that number, but I won't go into that here.\n",
  "  (cond [(&lt; n 1) 0]\n        [(integer? n) \n           (cond [(and (zero? (modulo\
    \ n 11)) (zero? (modulo n 13))) (+ (fizz_buzz (- n 1)) 1)]\n                 [else\
    \ (fizz_buzz (- n 1))])]\n        [else (fizz_buzz (integer-&gt;char n))]))\n\
    </code>\nMy tests:\n<code>&gt; (fizz_buzz 0)\n0\n&gt; (fizz_buzz 1)\n0\n&gt; (fizz_buzz\
    \ 2)\n0\n&gt; (fizz_buzz 3)\n0\n&gt; (fizz_buzz 4)\n0\n&gt; (fizz_buzz 5)\n0\n\
    &gt; (fizz_buzz 6)\n0\n&gt; (fizz_buzz 7)\n0\n&gt; (fizz_buzz 8)\n0\n&gt; (fizz_buzz\
    \ 9)\n0\n&gt; (fizz_buzz 10)\n0\n&gt; (fizz_buzz 11)\n1\n&gt; (fizz_buzz 12)\n\
    1\n&gt; (fizz_buzz 13)\n1\n&gt; (fizz_buzz 14)\n1\n&gt; (fizz_buzz 15)\n1\n&gt;\
    \ (fizz_buzz 16)\n1\n&gt; (fizz_buzz 17)\n1\n&gt; (fizz_buzz 18)\n1\n&gt; (fizz_buzz\
    \ 19)\n1\n&gt; (fizz_buzz 20)\n1\n&gt; (fizz_buzz 21)\n2\n&gt; (fizz_buzz 22)\n\
    2\n&gt; (fizz_buzz 23)\n2\n&gt; (fizz_buzz 24)\n2\n&gt; (fizz_buzz 25)\n2\n&gt;\
    \ (fizz_buzz 26)\n2\n&gt; (fizz_buzz 27)\n2\n&gt; (fizz_buzz 28)\n2", "  (define\
    \ (is_divisible? a b)\n    (= (modulo a b) 0))\n  (define (contains_seven? n)\n\
    \    (regexp-match? #rx\"7\" (number->string n)))\n  (define (count_sevens acc\
    \ x)\n    (if (or (is_divisible? x 11) (is_divisible? x 13))\n        (if (contains_seven?\
    \ x)\n            (+ acc 1)\n            acc)\n        acc))\n  (for/fold ([acc\
    \ 0]) ([x (in-range n)])\n    (count_sevens acc x)))\n", "  (let* ([end (quotient\
    \ n 10)]\n         [i 0]\n         [count 0])\n    (while (< i end)\n      (for\
    \ ([x (in-range (* 11 i) (* 11 (+ i 1)) 13)])\n        (if (regexp-match #rx\"\
    7\" (number->string x))\n            (set! count (+ count 1))))\n      (set! i\
    \ (+ i 1)))\n    count))\n", "  (for/sum ([i (in-range n)]\n            #:when\
    \ (or (zero? (modulo i 11))\n                       (zero? (modulo i 13))))\n\
    \    (count (\u03BB (x) (= x #\\7)) (number->string i))))\n", "  (cond ((= n 0)\
    \ 0)\n        ((and (modulo n 11) (modulo n 13))\n          (+ (fizz_buzz (- n\
    \ 1)) (number-of-7s (- n 1))))\n        (else (fizz_buzz (- n 1)))))\n", "  (define\
    \ (check x)\n    (cond ((= x 1) 0)\n          ((= (modulo x 10) 7) (+ 1 (check\
    \ (quotient x 10))))\n          (else (check (quotient x 10)))))\n  (define (loop\
    \ x)\n    (cond ((= x n) 0)\n          ((or (= (modulo x 11) 0) (= (modulo x 13)\
    \ 0)) (+ (check x) (loop (+ x 1))))\n          (else (loop (+ x 1)))))\n  (loop\
    \ 1))\n", "  (for/sum ([i (in-range n)])\n    (let* ([x (number->string i)]\n\
    \           [y (filter (lambda (x) (or (= x #\\7) (= x #\\7))) x)])\n      (length\
    \ y))))\n", "  (cond ((&lt; n 1) 0)\n        ((or (= (modulo n 11) 0) (= (modulo\
    \ n 13) 0)) (+ (contains_7 (modulo n 10)) (fizz_buzz (- n 1))))\n        (else\
    \ (fizz_buzz (- n 1)))))\n", "  (let loop ([num 7] [count 0])\n    (cond [(> num\
    \ n) count]\n          [(or (zero? (modulo num 11)) (zero? (modulo num 13))) (loop\
    \ (+ num 1) (+ count (string-count (number->string num) \"7\")))]\n          [else\
    \ (loop (+ num 1) count)])))\n```\n\n## Question 3\n\n```racket\n#lang racket\n",
  "  (count (range n) (\u03BB (x) (and (zero? (modulo x 11)) (zero? (modulo x 13))\
    \ (pos? (number-of-digits (integer->list x) (\u03BB (y) (= y 7)))))))\n)\n", " \
    \ (let loop ([i 0] [f7 0])\n    (cond\n      [(= i n) f7]\n      [(and (zero?\
    \ (modulo i 11)) (zero? (modulo i 13)))\n       (loop (+ i 1) (+ f7 (number-of-7s\
    \ (number->string i))))]\n      [else (loop (+ i 1) f7)])))\n", "  (define (fizz\
    \ n)\n    (equal? (modulo n 11) 0))\n  (define (buzz n)\n    (equal? (modulo n\
    \ 13) 0))\n  (define (count-sevens n)\n    (cond ((equal? n 7) 1)\n          ((equal?\
    \ n 77) 2)\n          ((equal? n 777) 3)\n          ((equal? n 7777) 4)\n    \
    \      ((equal? n 77777) 5)\n          ((equal? n 777777) 6)\n          ((equal?\
    \ n 7777777) 7)\n          ((equal? n 77777777) 8)\n          ((equal? n 777777777)\
    \ 9)\n          ((equal? n 7777777777) 10)\n          ((equal? n 77777777777)\
    \ 11)\n          ((equal? n 777777777777) 12)\n          ((equal? n 7777777777777)\
    \ 13)\n          ((equal? n 77777777777777) 14)\n          ((equal? n 777777777777777)\
    \ 15)\n          ((equal? n 7777777777777777) 16)\n          ((equal? n 77777777777777777)\
    \ 17)\n          ((equal? n 777777777777777777) 18)\n          ((equal? n 7777777777777777777)\
    \ 19)\n          ((equal? n 77777777777777777777) 20)\n          ((equal? n 777777777777777777777)\
    \ 21)\n          ((equal? n 7777777777777777777777) 22)\n          ((equal? n\
    \ 77777777777777777777777) 23)\n          ((equal? n 777777777777777777777777)\
    \ 24)\n          ((equal? n 7777777777777777777777777) 25)\n          ((equal?\
    \ n 77777777777777777777777777) 26)\n          ((equal? n 777777777777777777777777777)\
    \ 27)\n          ((equal? n 7777777777777777777777777777) 28)\n          ((equal?\
    \ n 7777777777777777777777777", "  (define (iter i count)\n    (cond\n      [(=\
    \ i n) count]\n      [(or (= (modulo i 11) 0) (= (modulo i 13) 0)) (iter (+ i\
    \ 1) (+ count (count_digit 7 i)))]\n      [else (iter (+ i 1) count)]))\n  (iter\
    \ 0 0))\n", "  (count-digits-in-fb n 11 0)\n  (count-digits-in-fb n 13 0))\n",
  "  (letrec ([fn (lambda (i acc)\n                 (if (= n i)\n                \
    \     acc\n                     (fn (+ i 1) (if (or (zero? (modulo i 11)) (zero?\
    \ (modulo i 13)))\n                                      (if (zero? (modulo i\
    \ 100))\n                                          (+ acc (- (modulo (/ i 100)\
    \ 10))\n                                                 (- (modulo (/ i 1000)\
    \ 10))\n                                                 (- (modulo (/ i 10000)\
    \ 10))\n                                                 (- (modulo (/ i 100000)\
    \ 10))\n                                                 (- (modulo (/ i 1000000)\
    \ 10))\n                                                 (- (modulo (/ i 10000000)\
    \ 10))\n                                                 (- (modulo (/ i 100000000)\
    \ 10))\n                                                 (- (modulo (/ i 1000000000)\
    \ 10))\n                                                 (- (modulo (/ i 10000000000)\
    \ 10))\n                                                 (- (modulo (/ i 100000000000)\
    \ 10))\n                                                 (- (modulo (/ i 1000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 10000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 100000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 1000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 10000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 100000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 1000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 10000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 100000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 1000000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 10000000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 100000000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 1000000000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 10000000000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 100000000000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 1000000000000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 10000000000000000000000000000)\
    \ 10))\n                                                 (- (modulo (/ i 100000000000000000000000000000)\
    \ 10))\n                                ", "  (define (fizz_buzz-iter counter\
    \ total)\n    (cond\n      [(= counter n) total]\n      [(and (or (zero? (modulo\
    \ counter 11)) (zero? (modulo counter 13))) (number-of-7? counter)) (fizz_buzz-iter\
    \ (+ counter 1) (+ total 1))]\n      [else (fizz_buzz-iter (+ counter 1) total)]))\n\
    \  (fizz_buzz-iter 1 0))\n", "  (count (range n)\n         (lambda (x) (and (or\
    \ (zero? (modulo x 11))\n                              (zero? (modulo x 13)))\n\
    \                          (zero? (string-index \"7\" (number->string x)))))))\n\
    ```\n\n### Solution:\n```racket\n#lang racket\n", "  (let loop ([i 1] [count 0])\n\
    \    (cond\n      [(> i n) count]\n      [(or (zero? (modulo i 11)) (zero? (modulo\
    \ i 13)))\n       (loop (+ i 1) (count-digit-7s i count))]\n      [else (loop\
    \ (+ i 1) count)])))\n", "  (cond\n    [(= n 0) 0]\n    [(= (modulo n 110) 0)\
    \ (+ 1 (fizz_buzz (- n 1)))]\n    [(= (modulo n 11) 0) (+ 1 (fizz_buzz (- n 1)))]\n\
    \    [(= (modulo n 13) 0) (+ 1 (fizz_buzz (- n 1)))]\n    [else (fizz_buzz (-\
    \ n 1))]))\n", "  (define (helper i)\n    (cond\n      [(= i 0) 0]\n      [(or\
    \ (= (modulo i 11) 0) (= (modulo i 13) 0)) (+ (modulo (number->string i) 7) (helper\
    \ (- i 1)))]\n      [else (helper (- i 1))]))\n  (helper (- n 1)))\n", "  (let\
    \ ((count 0))\n    (for ([i (in-range 1 n)])\n      (when (or (zero? (modulo i\
    \ 11)) (zero? (modulo i 13)))\n        (for/fold ([i i]) ([c (in-string (number->string\
    \ i))])\n          (if (char=? c #\\7)\n              (add1 count)\n         \
    \     count))))))\n", "  (cond\n    [(> n 0)\n     (+ (fizz_buzz (- n 1)) (count\
    \ 7 (number->string (* n 13))))]\n    [else 0]))\n", "  (for/sum ([i (in-range\
    \ 1 n)])\n    (cond\n      [(and (divisible? i 11) (divisible? i 13))\n      \
    \ (count-7 i)]\n      [(or (divisible? i 11) (divisible? i 13))\n       (count-7\
    \ i)]\n      [else 0])))\n", "  (cond ((= n 0) 0)\n        ((= n 7) 1)\n     \
    \   ((= n 11) 1)\n        ((= n 13) 1)\n        ((and (number? n) (or (divisible?\
    \ n 11) (divisible? n 13)))\n         (+ (fizz_buzz (- n 1)) (fizz_buzz (- n 7))))\n\
    \        (else\n         (fizz_buzz (- n 1)))))\n", "  (define (count_7 x)\n \
    \   (if (zero? x)\n        0\n        (+ (count_7 (quotient x 10))\n         \
    \  (if (member? (remainder x 10) '(7)) 1 0))))\n  (define (is_divisible_11_or_13?\
    \ x)\n    (or (zero? (remainder x 11))\n        (zero? (remainder x 13))))\n \
    \ (define (find_7 x)\n    (if (= x n)\n        0\n        (+ (if (is_divisible_11_or_13?\
    \ x) (count_7 x) 0)\n           (find_7 (+ x 1)))))\n  (find_7 0))\n", "  (count\
    \ 7 (filter\n            (lambda (x)\n              (or (zero? (modulo x 11))\n\
    \                  (zero? (modulo x 13))))\n            (range n))))\n```\n\n\
    ```", "  (cond\n    [(zero? n) 0]\n    [(and (or (divisible? n 11) (divisible?\
    \ n 13)) (contains? n 7)) (+ 1 (fizz_buzz (- n 1)))]\n    [else (fizz_buzz (-\
    \ n 1))]))\n", "  (define (divisible? a b)\n    (= (modulo a b) 0))\n  (define\
    \ (to-list n)\n    (if (= n 0) '()\n        (cons (modulo n 10) (to-list (quotient\
    \ n 10)))))\n  (define (count7 digits)\n    (if (null? digits) 0\n        (+ (if\
    \ (= (car digits) 7) 1 0) (count7 (cdr digits)))))\n  (define (compute digit)\n\
    \    (if (and (divisible? digit 11) (divisible? digit 13))\n        (count7 (to-list\
    \ digit))\n        0))\n  (cond ((= n 1) 0)\n        ((= n 7) 1)\n        (else\
    \ (+ (compute (- n 1)) (fizz_buzz (- n 1))))))\n</code>\nSome notes:\n\nI actually\
    \ wrote a solution in Python first, but I thought the code was too ugly to post.\
    \ So I rewrote it in Racket.\nThe <code>to-list</code> function is from here.\n\
    I'm not very good at writing short recursive functions. There is no doubt that\
    \ there is a much more elegant way to write this. For example, I know there is\
    \ a way to compute the sum of digits in an integer in logarithmic time.\nI'm also\
    \ not sure this will work for large <code>n</code>. It seems to, but I haven't\
    \ tested it very thoroughly.\n\nUpdate:\nHere is a shorter, more efficient version\
    \ that I wrote using some of the suggestions in the comments:\n<code>#lang racket\n",
  "    (cond [(= n 0) 0]\n          [(> n 0)\n           (if (or (integer? (sqrt (/\
    \ n 7))) (integer? (sqrt (/ n 13)))) \n               (+ 1 (fizz_buzz (- n 1)))\n\
    \               (fizz_buzz (- n 1)))]\n          [else -1]))\n", "  (count 7 (range\
    \ n 0 -1) (\u03BB (i) (or (divisible-by? i 11) (divisible-by? i 13)))))\n", " \
    \ (cond [(zero? n) 0]\n        [(< n 100) (fizz_buzz_div_11_13 n)]\n        [else\
    \ (+ (fizz_buzz_div_11_13 n) (fizz_buzz (sub1 n)))]))\n", "  (count-matches n\
    \ 7 % 11 13))\n</code>\nI think this code is pretty clear and easy to read as\
    \ well. We take <code>n</code> and filter all the numbers less than <code>n</code>\
    \ which are divisible by either <code>11</code> or <code>13</code> and count the\
    \ times the digit <code>7</code> appears on each of them.\nThis code is also pretty\
    \ easy to extend. For example, let's say we need to write a program for a new\
    \ place which has similar rules but slightly different numbers. We can write\n\
    <code>#lang racket\n", "  (let fizzbuzz-count ([i n])\n    (cond [(= n 0) 0]\n\
    \          [(= n -1) 0]\n          [(= n -2) 0]\n          [(= n -3) 0]\n    \
    \      [(= n -4) 0]\n          [(= n -5) 0]\n          [(= n -6) 0]\n        \
    \  [(= n -7) 0]\n          [(= n -8) 0]\n          [(= n -9) 0]\n          [(=\
    \ n -10) 0]\n          [(= n -11) 0]\n          [(= n -12) 0]\n          [(= n\
    \ -13) 0]\n          [(= n -14) 0]\n          [(= n -15) 0]\n          [(= n -16)\
    \ 0]\n          [(= n -17) 0]\n          [(= n -18) 0]\n          [(= n -19) 0]\n\
    \          [(= n -20) 0]\n          [(= n -21) 0]\n          [(= n -22) 0]\n \
    \         [(= n -23) 0]\n          [(= n -24) 0]\n          [(= n -25) 0]\n  \
    \        [(= n -26) 0]\n          [(= n -27) 0]\n          [(= n -28) 0]\n   \
    \       [(= n -29) 0]\n          [(= n -30) 0]\n          [(= n -31) 0]\n    \
    \      [(= n -32) 0]\n          [(= n -33) 0]\n          [(= n -34) 0]\n     \
    \     [(= n -35) 0]\n          [(= n -36) 0]\n          [(= n -37) 0]\n      \
    \    [(= n -38) 0]\n          [(= n -39) 0]\n          [(= n -40) 0]\n       \
    \   [(= n -41) 0]\n          [(= n -42) 0]\n          [(= n -43) 0]\n        \
    \  [(= n -44) 0]\n          [(= n -45) 0]\n          [(= n -46) 0]\n         \
    \ [(= n -47) 0]\n          [(= n -48) 0]\n          [(= n -49", "  (let loop ([i\
    \ n] [c 0])\n    (cond\n      [(zero? i) c]\n      [(or (zero? (modulo i 11))\
    \ (zero? (modulo i 13)))\n       (loop (- i 1) (+ c (count-7s i)))]\n      [else\
    \ (loop (- i 1) c)])))\n", "    (define (counter n x)\n        (cond [(< n x)\
    \ 0]\n              [(integer? (/ n x)) (+ (counter n x) (counter (- n 1) x))]\n\
    \              [else (counter (- n 1) x)]))\n    (define (solve n x y)\n     \
    \   (cond [(< n x) 0]\n              [(and (integer? (/ n x)) (integer? (/ n y)))\
    \ (+ (counter n 7) (solve (- n 1) x y))]\n              [(integer? (/ n x)) (+\
    \ (counter n 7) (solve (- n 1) x y))]\n              [(integer? (/ n y)) (+ (counter\
    \ n 7) (solve (- n 1) x y))]\n              [else (solve (- n 1) x y)]))\n   \
    \ (solve n 11 13))", "  (let loop ([n n] [res 0])\n    (cond\n      [(zero? n)\
    \ res]\n      [(or (= 0 (modulo n 11)) (= 0 (modulo n 13)))\n       (loop (- n\
    \ 1) (+ res (count 7 n)))]\n      [else (loop (- n 1) res)])))\n</code>\nEvaluates\
    \ to:\n<code>&gt; (fizz_buzz 30)\n4\n</code>\n", "  (let loop ([n n] [acc 0])\n\
    \    (cond\n      [(zero? n) acc]\n      [(divisible? n 11) (loop (sub1 n) (add1\
    \ acc))]\n      [(divisible? n 13) (loop (sub1 n) (add1 acc))]\n      [else (loop\
    \ (sub1 n) acc)])))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 7) 1]\n    [(< n\
    \ 10) 0]\n    [else\n     (+ (if (or (= (modulo n 11) 0) (= (modulo n 13) 0))\n\
    \             (if (member 7 (string->list (number->string n))) 1 0)\n        \
    \     0)\n        (fizz_buzz (- n 1)))]))\n", "  (if (= n 0)\n      0\n      (cond\
    \ ((= (modulo n 11) 0) (fizz_buzz (- n 1)))\n            ((= (modulo n 13) 0)\
    \ (fizz_buzz (- n 1)))\n            (else (cond ((zero? (modulo n 7)) (add1 (fizz_buzz\
    \ (- n 1))))\n                        (else (fizz_buzz (- n 1))))))))\n", "  (cond\
    \ [(zero? n) 0]\n        [(or (divisible? n 11) (divisible? n 13))\n         (+\
    \ (digit-freq 7 n) (fizz_buzz (- n 1)))]\n        [else (fizz_buzz (- n 1))]))\n",
  "  (accumulate (lambda (x y)\n                (if (or (zero? (modulo x 11))\n  \
    \                      (zero? (modulo x 13)))\n                    (+ y (string-count\
    \ (number->string x) #\\7))\n                    y))\n              0\n      \
    \        (in-range 1 n)))\n", "  (let ([max-n (exact-ceiling (/ n 11))])\n   \
    \ (for/sum ([i (in-range 1 max-n)])\n      (let* ([i-mod-11 (modulo i 11)]\n \
    \            [i-mod-13 (modulo i 13)]\n             [modulo-sum (+ i-mod-11 i-mod-13)])\n\
    \        (cond [(and (zero? i-mod-11) (zero? i-mod-13)) (exact-ceiling (/ n 11))]\n\
    \              [(or (zero? i-mod-11) (zero? i-mod-13)) (exact-ceiling (/ (+ n\
    \ modulo-sum) (+ modulo-sum 11 13))))]\n              [else 0])))))\n</code>\n\
    This function assumes that n is a positive integer.  It treats the case where\
    \ n is not divisible by 11 or 13 (which the question omits) differently than the\
    \ question.  I think that this program is the easiest to understand, but it is\
    \ not the fastest.\nThe <code>for/sum</code> macro allows us to sum the result\
    \ of a function that uses the temporary variable <code>i</code> that is changed\
    \ each iteration.  Note that I use the <code>let*</code> and <code>cond</code>\
    \ keywords to declare variables and handle a condition respectively.  The <code>in-range</code>\
    \ keyword returns the list of all integers between 1 and <code>max-n</code>. \
    \ The <code>modulo</code> function computes the remainder of division.  The <code>exact-ceiling</code>\
    \ function rounds up to the nearest integer.\nThe <code>cond</code> expression\
    \ in the program handles the three cases described in the problem.  When n is\
    \ divisible by 11 and 13, the number of 7s is equal to <code>exact-ceiling (/\
    \ n 11)</code>.  When n is divisible by 11 or 13 but not both, the number of 7s\
    \ is equal to <code>exact-ceiling (/ (+ n modulo-sum) (+ modulo-sum 11 13))</code>.\
    \  (The modulo sum is equal to the remainder of division by 11 and 13, so n is\
    \ divisible by the sum.  If n is", "  (define (divides? d n)\n    (= (remainder\
    \ n d) 0))\n  (define (count7s i)\n    (cond ((= i n) 0)\n          ((and (divides?\
    \ 11 i) (divides? 13 i))\n           (+ (if (char=? #\\7 (string-ref (number->string\
    \ i) (- (string-length (number->string i)) 1))) 1 0)\n              (count7s (+\
    \ i 1))))\n          (else (count7s (+ i 1)))))\n  (count7s 0))\n", "  (local\
    \ [(define (count n a b)\n            (cond [(zero? n) 0]\n                  [(and\
    \ (zero? (modulo n a)) (zero? (modulo n b))) (+ (count (- n 1) a b)\n        \
    \                                                             (count (- n 1) (-\
    \ a 1) (- b 1))\n                                                            \
    \         (count (- n 1) a b)\n                                              \
    \                       (count (- n 1) (- a 1) (- b 1))\n                    \
    \                                                 (count (- n 1) a b)\n      \
    \                                                               (count (- n 1)\
    \ (- a 1) (- b 1))\n                                                         \
    \            (count (- n 1) a b)\n                                           \
    \                          (count (- n 1) (- a 1) (- b 1))\n                 \
    \                                                    (count (- n 1) a b)\n   \
    \                                                                  (count (- n\
    \ 1) (- a 1) (- b 1))\n                                                      \
    \               (count (- n 1) a b)\n                                        \
    \                             (count (- n 1) (- a 1) (- b 1))\n              \
    \                                                       (count (- n 1) a b)\n\
    \                                                                     (count (-\
    \ n 1) (- a 1) (- b 1))\n                                                    \
    \                 (count (- n 1) a b)\n                                      \
    \                               (count (- n 1) (- a 1) (- b 1))\n            \
    \                                                         (count (- n 1) a b)\n\
    \                                                                     (count (-\
    \ n 1) (- a 1) (- b 1))\n                                                    \
    \                 (count (- n 1) a b)\n                                      \
    \                               (count (- n 1) (- a 1) (- b 1))\n            \
    \                                                         (count (- n 1) a b)\n\
    \                                                                     (count (-\
    \ n 1) (- a 1) (- b 1))\n                                                    \
    \                 (count (- n 1) a b)\n                                      \
    \                               (count (- n 1) (- a 1) (- b 1))\n            \
    \                                                         (count (- n 1) a b)\n\
    \                                                                     (count (-\
    \ n 1) (- a 1) (- b 1))\n                                                    \
    \                 (count (- n 1) a b)\n                                      \
    \                               (count (- n 1) (- a 1) (- b 1))\n            \
    \                                                         (count (- n", "  (for/sum\
    \ ([i (in-range 1 n)] #:when (or (zero? (modulo i 11)) (zero? (modulo i 13))))\n\
    \    (count 7 (number->string i))))\n```\n\nThe complexity of this algorithm is\
    \ `O(n log n)`. The number `11` and `13` have a greatest common divisor (GCD)\
    \ of `1`, this means that they are not multiples of each other. Therefore, by\
    \ using `modulo`, there is no number that divides both.\n\n- `O(n)`: For `in-range`\
    \ loop.\n- `O(log n)`: For `modulo`.\n- `O(n log n)`: For `number->string`.\n\n\
    Since `log n` is smaller than `n`, this is the dominating factor.\n\n### Solution\
    \ 2\n\n```racket\n#lang racket\n", "  (filter number? (map (lambda (x) (string-&gt;number\
    \ (number-&gt;string x)))\n                       (filter (lambda (x) (or (zero?\
    \ (modulo x 11)) (zero? (modulo x 13))))\n                               (build-list\
    \ n add1 1)))))\n</code>\nThis works, but seems overly complicated. I'm doing\
    \ the <code>filter</code>s to get rid of the <code>#false</code>s that come from\
    \ <code>string-&gt;number</code> and <code>number-&gt;string</code> for integers\
    \ that don't have 7 in them. Is there a way to do this that doesn't involve converting\
    \ to strings and numbers at all? If not, how can I remove the <code>filter</code>s\
    \ that I've added to get rid of the <code>#false</code>s? Thanks!\n\n\nA:\n\n\
    You can save the <code>#false</code>s in a different list and <code>append</code>\
    \ them at the end of the processing:\n<code>(define (fizz-buzz n)\n  (let loop\
    \ ((acc '())\n             (falses '())\n             (k 1))\n    (if (&gt; k\
    \ n)\n        (append acc falses)\n        (let ((x (string-&gt;number (number-&gt;string\
    \ k))))\n          (if (or (zero? (modulo k 11)) (zero? (modulo k 13)))\n    \
    \          (if (number? x)\n                  (loop (cons x acc) falses (+ k 1))\n\
    \                  (loop acc (cons x falses) (+ k 1)))\n              (loop acc\
    \ falses (+ k 1)))))))\n</code>\nAs you see, it's a lot of clutter due to the\
    \ fact that <code>string-&gt;number</code> is not transitive. Notice also that\
    \ the inner <code>if</code> expression is simplified by using the opposite condition,\
    \ avoiding the <code>filter</code> that you were using before.\n", "  (map-reduce-sum\
    \ (\u03BB (x) (count (string-contains x \"7\") x))\n                  (\u03BB\
    \ (x) (or (divisible? x 11) (divisible? x 13)))\n                  (\u03BB (x)\
    \ (= x \"7\"))\n                  (range n)))", "  (if (zero? n)\n      0\n  \
    \    (if (or (divisible-by? n 11) (divisible-by? n 13))\n          (+ (count-occurences-of-7?\
    \ n) (fizz_buzz (- n 1)))\n          (fizz_buzz (- n 1)))))\n", "  (for/sum ([i\
    \ (in-range n)])\n    (when (or (zero? (modulo i 11)) (zero? (modulo i 13)))\n\
    \      (count (string-contains (number->string i) \"7\"))))\n  )\n", "  (for/sum\
    \ ([i (in-range n)])\n    (and (= 0 (modulo i 11)) (= 0 (modulo i 13))\n     \
    \    (let loop ([i i] [count 0])\n           (cond [(zero? i) count]\n       \
    \          [(equal? 7 (modulo i 10)) (loop (quotient i 10) (+ count 1))]\n   \
    \              [else (loop (quotient i 10) count)])))))\n", "  (define (count-if\
    \ pred lst)\n    (cond [(empty? lst) 0]\n          [(pred (first lst)) (+ 1 (count-if\
    \ pred (rest lst)))]\n          [else (count-if pred (rest lst))]))\n  (count-if\
    \ (lambda (x) (char-ci=? #\\7 (number->string x)))\n            (filter (lambda\
    \ (x) (or (zero? (modulo x 11)) (zero? (modulo x 13))))\n                    (build-list\
    \ n (lambda (x) (+ x 1))))))\n", "  (do ((i 1 (+ i 1))\n       (numbers 0 (+ numbers\
    \ 1)))\n      ((&gt;= i n) numbers)\n    (cond ((or (divisible? i 11) (divisible?\
    \ i 13))\n           (if (digit? 7 i) (set! numbers (+ numbers 1)))))))\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(or (equal? 7 (remainder n 11)) (equal? 7 (remainder\
    \ n 13)))\n     (+ 1 (fizz_buzz (- n 1)))]\n    [else (fizz_buzz (- n 1))]))\n\
    </code>\nThis does not work, because <code>remainder</code> doesn't work for real\
    \ numbers. \nHow can I do this with only <code>remainder</code>?\n\n\nA:\n\nThe\
    \ traditional way of handling this is with the modulo operator:\n<code>(define\
    \ (fizz_buzz n)\n  (cond\n    [(= n 0) 0]\n    [(or (equal? 7 (modulo n 11)) (equal?\
    \ 7 (modulo n 13)))\n     (+ 1 (fizz_buzz (- n 1)))]\n    [else (fizz_buzz (-\
    \ n 1))]))\n</code>\nIf you are allowed to use other functions:\n<code>(define\
    \ (fizz_buzz n)\n  (cond\n    [(= n 0) 0]\n    [(or (equal? 7 (remainder n 11))\
    \ (equal? 7 (remainder n 13)))\n     (+ 1 (fizz_buzz (- n 1)))]\n    [else (fizz_buzz\
    \ (- n 1))]))\n</code>\nIn both cases, you could get rid of the <code>equal?</code>\
    \ call, as you are only interested in the fact that the result is 7, not that\
    \ it is specifically exactly 7.\n<code>(define (fizz_buzz n)\n  (cond\n    [(=\
    \ n 0) 0]\n    [(or (= 7 (modulo n 11)) (= 7 (modulo n 13)))\n     (+ 1 (fizz_buzz\
    \ (- n 1)))]\n    [else (fizz_buzz (- n 1))]))\n</code>\n", "  (define (fizz-buzz-helper\
    \ i count)\n    (cond [(= i n) count]\n          [(= (modulo i 11) 0) (fizz-buzz-helper\
    \ (+ i 1) (+ count (number-of-sevens i)))]\n          [(= (modulo i 13) 0) (fizz-buzz-helper\
    \ (+ i 1) (+ count (number-of-sevens i)))]\n          [else (fizz-buzz-helper\
    \ (+ i 1) count)]))\n  (fizz-buzz-helper 1 0))\n", "  (cond [(< n 7) 0]\n    \
    \    [(and (= 0 (modulo n 11)) (= 0 (modulo n 13))) (add1 (fizz_buzz (- n 1)))]\n\
    \        [(or (= 0 (modulo n 11)) (= 0 (modulo n 13))) (+ (fizz_buzz (- n 1))\
    \ (count-sevens (- n 1)))]\n        [else (fizz_buzz (- n 1))]))\n", "  (define\
    \ (is-fizz-buzz? n)\n    (cond\n      ((modulo n 11) 0)\n      ((modulo n 13)\
    \ 0)\n      (else #f)))\n  (define (fizz-buzz-sum n)\n    (if (= n 0)\n      \
    \  0\n        (+ (if (= (modulo n 10) 7) 1 0)\n           (fizz-buzz-sum (quotient\
    \ n 10)))))\n  (define (fizz-buzz-helper n)\n    (cond\n      ((< n 1) 0)\n  \
    \    ((is-fizz-buzz? n) (+ (fizz-buzz-sum n) (fizz-buzz-helper (- n 1))))\n  \
    \    (else (fizz-buzz-helper (- n 1)))))\n  (fizz-buzz-helper n))\n", "  (for/sum\
    \ ([i (in-range 1 n)]\n            #:when (and (zero? (modulo i 11))\n       \
    \                 (zero? (modulo i 13))))\n    (count 7 (number->string i))))\n",
  "  (if (= n 0) 0\n      (let* ([n (- n 1)]\n             [m (modulo n 11)]\n   \
    \          [r (modulo n 13)])\n        (if (or (= m 0) (= r 0))\n            (+\
    \ (if (or (= m 7) (= r 7)) 1 0) (fizz_buzz n))\n            (fizz_buzz n)))))\n\
    </code>\nThis is what I got. You can replace <code>7</code> with any other number.\n",
  "  (if (&lt; n 1)\n      0\n      (if (or (= (modulo n 11) 0) (= (modulo n 13) 0))\n\
    \          (+ (if (equal? (substring (number-&gt;string n) -1) \"7\") 1 0) (fizz_buzz\
    \ (- n 1)))\n          (fizz_buzz (- n 1)))))\n</code>\nThis is just my third\
    \ assignment in Scheme and I just want to know if there is any way to improve\
    \ my code.\n\n\nA:\n\nYou could refactor your code to eliminate those repetitive\
    \ <code>if</code> statements and use the <code>cond</code> form instead:\n<code>(define\
    \ (fizz-buzz n)\n  (cond ((&lt; n 1) 0)\n        ((or (= (modulo n 11) 0) (= (modulo\
    \ n 13) 0))\n         (+ (if (equal? (substring (number-&gt;string n) -1) \"7\"\
    ) 1 0) (fizz-buzz (- n 1))))\n        (else (fizz-buzz (- n 1)))))\n</code>\n\
    This is cleaner and more concise, but I still don't see what the point of the\
    \ assignment is. Shouldn't the function be returning a list of numbers that satisfy\
    \ the given condition?\n", "  (define (number-of-7s n)\n    (let loop ([n n] [count\
    \ 0])\n      (cond\n        [(= n 0) count]\n        [(= (remainder n 10) 7) (loop\
    \ (quotient n 10) (+ count 1))]\n        [else (loop (quotient n 10) count)])))\n\
    \  (define (count-7s n)\n    (define (fizz-buzz-step n acc)\n      (cond\n   \
    \     [(< n 1) acc]\n        [(and (not (zero? (remainder n 11))) (not (zero?\
    \ (remainder n 13)))) (fizz-buzz-step (- n 1) acc)]\n        [(or (zero? (remainder\
    \ n 11)) (zero? (remainder n 13))) (fizz-buzz-step (- n 1) (+ acc (number-of-7s\
    \ n)))]))\n    (fizz-buzz-step n 0))\n  (count-7s n))", '  (accumulate + 0 (filter
    (lambda (x) (and (= (remainder x 11) 0) (= (remainder x 13) 0))) (build-list n
    (lambda (x) (+ x 1))))))', "  (define (count k)\n    (cond\n      [(= k 0) 0]\n\
    \      [(and (or (and (zero? (modulo k 11)) (= (modulo k 7) 0))\n            \
    \     (and (zero? (modulo k 13)) (= (modulo k 7) 0)))\n            (not (zero?\
    \ (modulo k 7))))\n       (+ 1 (count (- k 1)))]\n      [else (count (- k 1))]))\n\
    \  (count n))\n", "  (let* ([s (number->string n)]\n         [s_len (string-length\
    \ s)]\n         [s_rev (reverse s)]\n         [s_int (string->number s)]\n   \
    \      [s_int_rev (string->number s_rev)])\n    (cond [(zero? (modulo s_int 11))\
    \ (if (> s_int_rev s_int) 1 0)]\n          [(zero? (modulo s_int 13)) (if (> s_int_rev\
    \ s_int) 1 0)]\n          [else 0])))\n", "  (for/sum ([i (in-range 1 n)]\n  \
    \          #:when (or (integer? (/ i 11))\n                       (integer? (/\
    \ i 13))))\n    (count 7 (format \"~a\" i))))\n</code>\nNote that this solution\
    \ is not completely general: it doesn't take into account potential other factors,\
    \ such as 5.\n", "  (cond\n    [(<= n 0) 0]\n    [(= (remainder n 11) 0) (+ 1\
    \ (fizz_buzz (- n 1)))]\n    [(= (remainder n 13) 0) (+ 1 (fizz_buzz (- n 1)))]\n\
    \    [else (fizz_buzz (- n 1))]))", "  (define (get-7s-digit n)\n    (cond\n \
    \     [(= n 0) 0]\n      [(= n 7) 1]\n      [(= n 1) 0]\n      [(= n 2) 0]\n \
    \     [(= n 3) 0]\n      [(= n 4) 0]\n      [(= n 5) 0]\n      [(= n 6) 0]\n \
    \     [(= n 8) 0]\n      [(= n 9) 0]\n      [(= n 10) 0]\n      [(= n 11) 0]\n\
    \      [(= n 12) 0]\n      [(= n 13) 0]\n      [(= n 14) 0]\n      [(= n 15) 0]\n\
    \      [(= n 16) 0]\n      [(= n 17) 0]\n      [(= n 18) 0]\n      [(= n 19) 0]\n\
    \      [(= n 20) 0]\n      [(= n 21) 0]\n      [(= n 22) 0]\n      [(= n 23) 0]\n\
    \      [(= n 24) 0]\n      [(= n 25) 0]\n      [(= n 26) 0]\n      [(= n 27) 0]\n\
    \      [(= n 28) 0]\n      [(= n 29) 0]\n      [(= n 30) 0]\n      [(= n 31) 0]\n\
    \      [(= n 32) 0]\n      [(= n 33) 0]\n      [(= n 34) 0]\n      [(= n 35) 0]\n\
    \      [(= n 36) 0]\n      [(= n 37) 0]\n      [(= n 38) 0]\n      [(= n 39) 0]\n\
    \      [(= n 40) 0]\n      [(= n 41) 0]\n      [(= n 42) 0]\n      [(= n 43) 0]\n\
    \      [(= n 44) 0]\n      [(= n 45) 0]\n      [(= n 46) 0]\n      [(= n 47) 0]\n\
    \      [(= n 48) 0]\n      [(= n 49) 0]\n      [(= n 50) 0]\n      [(= n 51) 0]\n\
    \      [(= n 52) 0]\n      [(= n 53) 0]\n      [(= n 54) 0]", "  (check-expect\
    \ (fizz_buzz 20) 3)\n  (check-expect (fizz_buzz 1000) 202)\n  (check-expect (fizz_buzz\
    \ 100000) 20202)\n  (cond\n    [(= n 0) 0]\n    [(or (= (modulo n 11) 0) (= (modulo\
    \ n 13) 0)) (+ (fizz_buzz (- n 1)) (fizz_buzz (modulo n 10)))]\n    [else (fizz_buzz\
    \ (- n 1))]))\n", "  (define (iter i acc)\n    (cond\n      [(= i n) acc]\n  \
    \    [(or (zero? (modulo i 11)) (zero? (modulo i 13)))\n       (iter (+ i 1) (+\
    \ acc (count 7 i)))]\n      [else (iter (+ i 1) acc)]))\n  (iter 0 0))\n", " \
    \ (local [(define (helper c)\n            (cond\n              [(zero? c) 0]\n\
    \              [(integer? c) (+ (helper (quotient c 10)) (if (zero? (remainder\
    \ c 10)) 0 (if (equal? 7 (remainder c 10)) 1 0)))]\n              [else 0]))]\n\
    \    (let loop ([i 0] [count 0])\n      (cond\n        [(>= i n) count]\n    \
    \    [(or (zero? (remainder i 11)) (zero? (remainder i 13))) (loop (+ i 1) (+\
    \ count (helper i)))]\n        [else (loop (+ i 1) count)]))))\n```\n\n##### Example\
    \ usage\n```racket", "  (cond\n    [(zero? n) 0]\n    [(or (divides? 11 n) (divides?\
    \ 13 n)) (+ (sevens n) (fizz_buzz (- n 1)))]\n    [else (fizz_buzz (- n 1))]))\n",
  "  (for/sum ([i (in-range n)]\n            #:when (and (= 0 (modulo i 11)) (= 0\
    \ (modulo i 13))))\n    (count (integer->string i) #\\7)))\n", "  (cond\n    [(zero?\
    \ n) 0]\n    [(zero? (modulo n 11)) (+ (sevens-in-number n) (fizz_buzz (- n 1)))]\n\
    \    [(zero? (modulo n 13)) (+ (sevens-in-number n) (fizz_buzz (- n 1)))]\n  \
    \  [else (fizz_buzz (- n 1))]))\n", "  (count (iota n)\n         (lambda (x)\n\
    \           (and (or (divisible? x 11) (divisible? x 13))\n                (divisible?\
    \ (count-digits x) 7)))))\n```\n\n```scheme\n#lang racket\n", "  (if (not (and\
    \ (positive? n) (integer? n))) 0\n      (let ([sum 0])\n        (for ([i n])\n\
    \          (when (or (even? (quotient i 11)) (even? (quotient i 13)))\n      \
    \      (define s (number->string i))\n            (for ([c s])\n             \
    \ (when (= #\\7 c)\n                (set! sum (+ sum 1))))))\n        sum)))",
  "  (for/sum ([i (in-range n)])\n    (if (or (zero? (modulo i 11)) (zero? (modulo\
    \ i 13)))\n        (let ((i_str (number->string i)))\n          (count 7 (string->list\
    \ i_str))))))\n```\n\n13.\n-------\n\n```#lang racket\n", "  (if (< n 10)\n  \
    \    (if (= n 7) 1 0)\n      (+ (if (= (modulo n 11) 0) (fizz_buzz (quotient n\
    \ 10)) 0)\n         (if (= (modulo n 13) 0) (fizz_buzz (quotient n 10)) 0)\n \
    \        (if (= (modulo n 10) 7) 1 0))))\n", "  (if (&lt; n 1)\n      0\n    \
    \  (cond\n        [(= (modulo n 11) 0) (+ 1 (fizz_buzz (- n 1)))]\n        [(=\
    \ (modulo n 13) 0) (+ 1 (fizz_buzz (- n 1)))]\n        [else (fizz_buzz (- n 1))])))\n",
  "  (let loop ([i n] [count 0])\n    (cond\n      [(zero? i) count]\n      [(or (=\
    \ (modulo i 11) 7) (= (modulo i 13) 7)) (loop (- i 1) (+ count 1))]\n      [else\
    \ (loop (- i 1) count)])))\n", "  (define (fizz-buzz-count-7s n)\n    (if (= n\
    \ 0)\n        0\n        (cond\n          [(< n 11) 0]\n          [(= 0 (modulo\
    \ n 11)) (cond\n                                  [(= 7 (modulo n 10)) (+ 1 (fizz-buzz-count-7s\
    \ (- n 11)))]\n                                  [else (fizz-buzz-count-7s (-\
    \ n 11))])]\n          [(= 0 (modulo n 13)) (cond\n                          \
    \        [(= 7 (modulo n 10)) (+ 1 (fizz-buzz-count-7s (- n 13)))]\n         \
    \                         [else (fizz-buzz-count-7s (- n 13))])]\n          [else\
    \ (fizz-buzz-count-7s (- n 1))])))\n  (fizz-buzz-count-7s n))\n", "  (define (count\
    \ i sum)\n    (cond ((&gt; i n) sum)\n          ((and (divisible? i 11) (divisible?\
    \ i 13))\n           (count (+ i 1) (+ sum (count-7 i))))\n          (else (count\
    \ (+ i 1) sum))))\n  (count 1 0))\n", "  (for/sum ([i (in-range 1 n)])\n    (and\
    \ (or (zero? (modulo i 11)) (zero? (modulo i 13)))\n         (count (\u03BB (d)\
    \ (= d 7)) (string->list (number->string i))))))\n", "  (for/sum ([i (in-range\
    \ 1 n)]\n            #:when (or (zero? (modulo i 11))\n                      \
    \ (zero? (modulo i 13))))\n    (count 7 (number->string i))))\n</code>\nQuestion:\
    \ What is a good way to deal with large numbers (like 1000000 in the example)?\n\
    I think I need to use <code>for/fold</code> and accumulate the results, but I\
    \ don't know how to do this.\n\n\nA:\n\nYou can't count digits in a number higher\
    \ than 1000 in any reasonable way, because the number is just too big. You must\
    \ break down the number into a sequence of digits, and count the digits in there:\n\
    <code>(define (count-digits-in-number n)\n  (count-digits (number-&gt;string n)))\n",
  "  (define (helper1 n count)\n    (if (&lt; n 1)\n        count\n        (if (or\
    \ (zero? (modulo n 11)) (zero? (modulo n 13)))\n            (helper1 (- n 1) (+\
    \ count (find_7 n)))\n            (helper1 (- n 1) count))))\n  (define (find_7\
    \ n)\n    (if (= (remainder n 10) 7)\n        1\n        (if (= n 0)\n       \
    \     0\n            (find_7 (quotient n 10)))))\n  (helper1 n 0))\n</code>\n\
    I can test that my find_7 function works like this:\n<code>(find_7 17872)\n&gt;2",
  "  (define (digits n)\n    (if (= n 0)\n        empty\n        (cons (remainder\
    \ n 10) (digits (quotient n 10)))))\n  (define (is_divisible? n d)\n    (= (remainder\
    \ n d) 0))\n  (define (fizz_buzz_help n)\n    (if (= n 0)\n        empty\n   \
    \     (append (digits n) (fizz_buzz_help (- n 1)))))\n  (cond ((= n 0) 0)\n  \
    \      ((is_divisible? n 11) (if (member 7 (digits n)) (+ 1 (fizz_buzz (- n 1)))\
    \ (fizz_buzz (- n 1))))\n        ((is_divisible? n 13) (if (member 7 (digits n))\
    \ (+ 1 (fizz_buzz (- n 1))) (fizz_buzz (- n 1))))\n        (else (fizz_buzz (-\
    \ n 1)))))\n</code>\nI can't figure out why this doesn't work. I've checked my\
    \ function <code>digits</code> and it works fine. <code>fizz_buzz_help</code>\
    \ also works fine, but <code>fizz_buzz</code> fails to work. It seems that it\
    \ does not recurse through the whole list of <code>n</code>. It seems that the\
    \ problem is caused by my <code>cond</code> expression. I'd really appreciate\
    \ any tips on how to fix this.\nThis is the error I get when I try to run the\
    \ function:\n<code>recur argument: expected a procedure that can be applied to\
    \ 0 arguments,\n given: '()\n  arguments...: [none]\n</code>\n\n\nA:\n\nI think\
    \ your function is fine. It's the tests that are wrong.\nI wrote a quick test\
    \ program to help you debug this. It's more the style that I'd use for the problem,\
    \ but I think the idea is clear.\n<code>#lang racket\n", "  (foldl + 0 (list-tabulate\
    \ n (lambda (i) (zero? (modulo i 11) 13)))\n          (filter\n           (lambda\
    \ (x)\n             (cond ((< x 1) #f)\n                   ((= x 0) #t)\n    \
    \               ((= x 7) #t)\n                   ((= x 11) #t)\n             \
    \      ((= x 13) #t)\n                   ((= x 17) #t)\n                   ((=\
    \ x 21) #t)\n                   ((= x 27) #t)\n                   ((= x 31) #t)\n\
    \                   ((= x 37) #t)\n                   ((= x 41) #t)\n        \
    \           ((= x 47) #t)\n                   ((= x 51) #t)\n                \
    \   ((= x 57) #t)\n                   ((= x 61) #t)\n                   ((= x\
    \ 67) #t)\n                   ((= x 71) #t)\n                   ((= x 77) #t)\n\
    \                   ((= x 81) #t)\n                   ((= x 87) #t)\n        \
    \           ((= x 91) #t)\n                   ((= x 97) #t)\n                \
    \   (else (filter (lambda (y) (= (modulo x y) 0))\n                          \
    \       (list-tabulate 7 (lambda (j) (+ j 7)))))))\n           (list-tabulate\
    \ n (lambda (i) i))))))\n", "  (define (helper i)\n    (if (= i n)\n        0\n\
    \        (+ (if (or (zero? (modulo i 11)) (zero? (modulo i 13))) (digit-count\
    \ 7 i) 0)\n           (helper (+ i 1)))))\n  (helper 1))\n</code>\nI was wondering\
    \ if there was a way I could write this more functionally using list-ref or a\
    \ helper that would take in a list.\n\n\nA:\n\nThere are a few ways, here's one\
    \ using <code>for/fold</code>:\n<code>(define (fizz-buzz n)\n  (for/fold ([count\
    \ 0]) ([i (in-range 1 n)])\n    (if (or (zero? (modulo i 11)) (zero? (modulo i\
    \ 13)))\n        (+ count (digit-count 7 i))\n        count)))\n</code>\n", " \
    \ (regexp-count #rx\"[7]\" (build-list (lambda (x) (string-append (show x) (show\
    \ (/ x n)))) n)))\n", "  (if (< n 1)\n      0\n      (+ (if (or (integer? (/ n\
    \ 11)) (integer? (/ n 13)))\n\t     (if (integer? (/ n 7))\n\t\t 1\n\t\t 0)\n\t\
    \     0)\n\t (fizz_buzz (- n 1)))))\n", "  (let loop ([i 0] [sum 0])\n    (cond\n\
    \      [(= i n) sum]\n      [(or (zero? (modulo i 11)) (zero? (modulo i 13)))\
    \ (loop (+ i 1) (+ sum (digit-frequency 7 i)))]\n      [else (loop (+ i 1) sum)])))\n",
  "  (cond [(= (modulo n 7) 0) (+ 1 (fizz_buzz (- n 1)))]\n        [(= (modulo n 11)\
    \ 0) (+ 1 (fizz_buzz (- n 1)))]\n        [(= (modulo n 13) 0) (+ 1 (fizz_buzz\
    \ (- n 1)))]\n        [else (fizz_buzz (- n 1))]))\n", "  (cond\n    [(zero? n)\
    \ 0]\n    [(zero? (modulo n 11)) (+ (fizz_buzz (- n 1))\n                    \
    \          (count_sevens (quotient n 11)))]\n    [(zero? (modulo n 13)) (+ (fizz_buzz\
    \ (- n 1))\n                              (count_sevens (quotient n 13)))]\n \
    \   [else (fizz_buzz (- n 1))]))\n", "  (define (num7? n)\n    (cond ((&lt; n\
    \ 10) (= n 7))\n          ((= (modulo n 10) 7) #t)\n          (else (num7? (quotient\
    \ n 10)))))\n  (define (div? n)\n    (cond ((&lt; n 14) #f)\n          ((= (modulo\
    \ n 11) 0) #t)\n          ((= (modulo n 13) 0) #t)\n          (else (div? (- n\
    \ 1)))))\n  (define (fizz_buzz_tracker n acc)\n    (cond ((&lt; n 1) acc)\n  \
    \        ((and (num7? n) (div? n)) (fizz_buzz_tracker (- n 1) (+ acc 1)))\n  \
    \        (else (fizz_buzz_tracker (- n 1) acc))))\n  (fizz_buzz_tracker n 0))\n\
    </code>\nThe code works fine, but I would like to improve it.\n\nIs this a good\
    \ way to use recursion?\nHow can I avoid the redundant <code>&lt; n 14</code>\
    \ part in <code>div?</code>?\nCan I improve the structure of my code?\n\n\n\n\
    A:\n\nYou have a lot of duplicate code in <code>div?</code>. Instead of duplicating\
    \ the <code>modulo</code> and <code>=</code> code, you can use <code>or</code>\
    \ to check both conditions at once:\n<code>(define (div? n)\n  (cond ((&lt; n\
    \ 14) #f)\n        ((or (= (modulo n 11) 0)\n             (= (modulo n 13) 0))\
    \ #t)\n        (else (div? (- n 1)))))\n</code>\n", "  (define (divisible? n)\n\
    \    (or (zero? (modulo n 11))\n        (zero? (modulo n 13))))\n  (define (digit_7?\
    \ n)\n    (and (not (zero? n))\n         (or (zero? (modulo n 10))\n         \
    \    (and (not (zero? (modulo n 10)))\n                  (digit_7? (quotient n\
    \ 10))))))\n  (define (digit_7_rec n)\n    (if (zero? n)\n        0\n        (if\
    \ (divisible? n)\n            (if (digit_7? n)\n                (add1 (digit_7_rec\
    \ (sub1 n)))\n                (digit_7_rec (sub1 n)))\n            (digit_7_rec\
    \ (sub1 n)))))\n  (digit_7_rec n))\n", "  (let loop ([i 1] [count 0])\n    (cond\n\
    \      [(> i n) count]\n      [(or (= 0 (modulo i 11)) (= 0 (modulo i 13)))\n\
    \       (loop (+ i 1) (count + (count-7 i)))]\n      [else (loop (+ i 1) count)])))\n",
  "  (cond [(zero? n)\n         0]\n        [(or (= (modulo n 11) 0) (= (modulo n\
    \ 13) 0))\n         (+ (count-7s (quotient n 10))\n            (count-7s (remainder\
    \ n 10)))]\n        [else\n         (fizz_buzz (- n 1))]))\n", "  (define (fizz_buzz_h\
    \ i)\n    (cond\n      [(zero? i) 0]\n      [(= 7 (remainder i 10)) (+ 1 (fizz_buzz_h\
    \ (quotient i 10)))]\n      [else (fizz_buzz_h (quotient i 10))]))\n  (define\
    \ (fizz_buzz_i i)\n    (cond\n      [(zero? i) 0]\n      [(and (zero? (remainder\
    \ i 11)) (zero? (remainder i 13)))\n       (+ (fizz_buzz_h i) (fizz_buzz_i (-\
    \ i 1)))]\n      [else (fizz_buzz_i (- i 1))]))\n  (fizz_buzz_i n))\n", "  (count\
    \ 7 (list_of_numbers_divisible_by_11_or_13 n)))\n", "  (cond\n    [(< n 0) (error\
    \ \"Argument can't be negative\")]\n    [(= n 0) 0]\n    [else\n     (cond\n \
    \      [(or (= (modulo n 11) 0) (= (modulo n 13) 0)) (+ (fizz_buzz (- n 1)) (sevens-in-n\
    \ n))]\n       [else (fizz_buzz (- n 1))])]))\n", "  (define (digit_7? n)\n  \
    \  (cond ((= n 7) #t)\n          ((<= n 10) #f)\n          (else (digit_7? (modulo\
    \ n 10)))))\n  (define (fizz_buzz_help n i acc)\n    (cond ((= i n) acc)\n   \
    \       ((and (digit_7? i) (or (zero? (modulo i 11)) (zero? (modulo i 13)))) (fizz_buzz_help\
    \ n (+ i 1) (+ acc 1)))\n          (else (fizz_buzz_help n (+ i 1) acc))))\n \
    \ (fizz_buzz_help n 1 0))", "  (count #\\7 (apply string-append (map show (remove\
    \ zero? (map (lambda (x) (modulo x 11 13)) (range n)))))))\n</code>\nThere's probably\
    \ better ways to do this, but it works.\n", "  (display n)\n  (display \": \"\
    )\n  (define (count_7 i)\n    (cond [(= 0 i) 0]\n          [(modulo i 110) (cond\
    \ [(= 0 (modulo i 77)) (+ 1 (count_7 (- i 7)))]\n                            \
    \    [else (count_7 (- i 7))])]\n          [else (count_7 (- i 1))]))\n  (display\
    \ (count_7 n))\n  (newline))\n", "  (for/sum ([i (in-range n)])\n    (equal? (modulo\
    \ i 11) 0)\n    (equal? (modulo i 13) 0)\n    (match (string-&gt;list (number-&gt;string\
    \ i))\n      [(list #\\7) 1]\n      [_ 0])))\n</code>\n<code>#lang racket\n",
  "  (cond\n    [(zero? n) 0]\n    [(or (multiple-of? n 11) (multiple-of? n 13))\n\
    \     (+ (contains-seven? n) (fizz_buzz (- n 1)))]\n    [else (fizz_buzz (- n\
    \ 1))]))\n", "  (let loop ([i (- n 1)])\n    (cond [(>= i 0) (cond [(and (= (modulo\
    \ i 11) 0) (= (modulo i 13) 0)) (+ 1 (loop (- i 1)))]\n                      \
    \    [(or (= (modulo i 11) 0) (= (modulo i 13) 0)) (loop (- i 1))]\n         \
    \                 [else (+ 0 (loop (- i 1)))])]\n          [else 0])))", "  (count-digit\
    \ n 7 11))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
