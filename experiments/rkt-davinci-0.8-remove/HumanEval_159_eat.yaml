name: HumanEval_159_eat
language: rkt
prompt: "#lang racket\n\n;; You're a hungry rabbit, and you already have eaten a certain\
  \ number of carrots,\n;; but now you need to eat more carrots to complete the day's\
  \ meals.\n;; you should return an array of [ total number of eaten carrots after\
  \ your meals,\n;; the number of carrots left after your meals ]\n;; if there are\
  \ not enough remaining carrots, you will eat all remaining carrots, but will still\
  \ be hungry.\n;; Example:\n;; Variables:\n;; @number : integer\n;; the number of\
  \ carrots that you have eaten.\n;; @need : integer\n;; the number of carrots that\
  \ you need to eat.\n;; @remaining : integer\n;; the number of remaining carrots\
  \ thet exist in stock\n;; Constrain:\n;; * 0 <= number <= 1000\n;; * 0 <= need <=\
  \ 1000\n;; * 0 <= remaining <= 1000\n;; Have fun :)\n(define (eat number need remaining)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate eat))\n\
  \    (check-equal? (candidate 5 6 10) (list 11 4))\n    (check-equal? (candidate\
  \ 4 8 9) (list 12 1))\n    (check-equal? (candidate 1 10 10) (list 11 0))\n    (check-equal?\
  \ (candidate 2 11 5) (list 7 0))\n    (check-equal? (candidate 4 5 7) (list 9 2))\n\
  \    (check-equal? (candidate 4 5 1) (list 5 0))\n))\n\n(test-humaneval)"
completions: ["  (if (> need (+ number remaining))\n      (list remaining 0)\n   \
    \   (list (+ number remaining) (- need (+ number remaining)))))\n```\n\n```\n\
    6 1 2   // number = 6, need = 1, remaining = 2\n```\n\n```\n#lang racket\n", " \
    \ (let* ((need (if (< remaining need) remaining need))\n         (new-remaining\
    \ (- remaining need)))\n    (values (+ number need) new-remaining)))\n", "  (if\
    \ (> need remaining)\n      (list (+ number remaining) 0)\n      (list (+ number\
    \ need) (- remaining need))))\n```\n\n```racket\n#lang racket\n", "  (define (eat*\
    \ number need remaining)\n    (let loop ([number number] [need need] [remaining\
    \ remaining])\n      (cond [(< need remaining) (values (- (+ number need) remaining)\
    \ 0)]\n            [(= need remaining) (values (+ number need) 0)]\n         \
    \   [(< need number) (values (+ number need) (- number need))]\n            [else\
    \ (loop (+ number need) (- need number) 0)])))\n  (match-define (values eaten\
    \ left) (eat* number need remaining))\n  (cons eaten left))\n", "  (vector (+\
    \ number (min need remaining))\n          (- remaining (min need remaining))))\n",
  '  (list (+ number need) (- remaining need)))', "  (cond\n    [(<= (+ number need)\
    \ remaining)\n     (list (+ number need) (- remaining (+ number need)))]\n   \
    \ [else\n     (list (+ number remaining) 0)]))\n", "  (if (> number need)\n  \
    \    '(0 0)\n      (if (< (+ number remaining) need)\n          (cons (+ number\
    \ remaining) 0)\n          (cons need (- need number)))))\n", "  (cond ((< remaining\
    \ need) (list number (- need remaining)))\n        (else (list (+ number need)\
    \ (- remaining need)))))\n", "  (list (+ number need) (- remaining need)))\n```\n\
    \n### \uC815\uB2F5\n\n```racket\n#lang racket\n", "  (if (&gt; need remaining)\n\
    \      (list (+ number remaining) 0)\n      (list (+ number need) (- remaining\
    \ need))))\n</code>\nGiven that solution, I wonder if my solution can be optimized\
    \ as it seems a little complex, as well as a non-functional.\n\n\nA:\n\nYou are\
    \ over-thinking it. The decision you have to make is whether there are enough\
    \ carrots, and then you just have to add up the numbers.\n<code>(define (eat carrots-eaten\
    \ carrots-needed carrots-remaining)\n  (if (&gt; carrots-needed carrots-remaining)\n\
    \      (list (+ carrots-eaten carrots-remaining) 0)\n      (list (+ carrots-eaten\
    \ carrots-needed) (- carrots-remaining carrots-needed))))\n</code>\nLooks good\
    \ to me.\n", "  (list\n   (cond\n     [(>= number need) number]\n     [(>= remaining\
    \ need) (+ number remaining)])\n   (cond\n     [(>= remaining need) 0]\n     [(>=\
    \ remaining number) (- remaining number)]\n     [else 0])))\n```\n\n## Ruby\n\n\
    ```ruby\n# You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n# but now you need to eat more carrots to complete the day's meals.\n\
    # you should return an array of [ total number of eaten carrots after your meals,\n\
    # the number of carrots left after your meals ]\n# if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n# Example:\n\
    # Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n\
    # @need : integer\n# the number of carrots that you need to eat.\n# @remaining\
    \ : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n\
    # * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n#\
    \ Have fun :)\n\ndef eat(number, need, remaining)\n  eaten =\n    if number >=\
    \ need\n      number\n    elsif remaining >= need\n      number + remaining\n\
    \    else\n      number\n    end\n\n  left =\n    if remaining >= need\n     \
    \ 0\n    elsif remaining >= number\n      remaining - number\n    else\n     \
    \ 0\n    end\n\n  [eaten, left]\nend\n```\n\n## Haskell\n\n```haskell\n-- You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n--\
    \ but now you need to eat more carrots to complete the day's meals.\n-- you should\
    \ return an array of [ total number of eaten carrots after your meals,\n-- the\
    \ number of carrots left after your meals ]\n-- if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n-- Example:\n\
    -- Variables:\n-- @number : integer\n-- the number of carrots that you have eaten.\n\
    -- @need : integer\n-- the number of carrots that you need to eat.\n-- @remaining\
    \ : integer\n-- the number of remaining carrots", "  (cond\n    [(= need 0) (list\
    \ number 0)]\n    [(= remaining 0) (list number 0)]\n    [(> need remaining) (list\
    \ (+ number remaining) 0)]\n    [else (list (+ number need) (- remaining need))]))\n",
  "  (cond [(> need remaining)\n         (cons (+ number remaining) 0)]\n        [else\n\
    \         (cons (+ number need) (- remaining need))]))\n", "  (if (> need remaining)\n\
    \      (list (+ number remaining) 0)\n      (list (+ number need) (- remaining\
    \ need))))\n```\n\n```racket\n#lang racket\n", "  (cond ((= need (- number))\n\
    \         '(0 0))\n        ((> need (- number))\n         (list (number remaining)\
    \ (- remaining number)))\n        ((> need remaining)\n         '(0 0))\n    \
    \    (else (list number (remaining (- need number))))))\n\n```\n\n## Explanation:\n\
    \nFirst we check if our need is bigger than the number of eaten carrots. If that's\
    \ true\nwe need to calculate if we have enough carrots to finish our meal. If\
    \ not we eat all\nthe carrots we have and return 0 0. If we have enough, we return\
    \ the number of carrots\nwe have eaten and the number of remaining carrots, then\
    \ we check if the need is bigger\nthan the remaining carrots, in which case we\
    \ eat them all and return 0 0, then if none\nof the conditions are met we return\
    \ the number of eaten carrots and the number of\nremaining carrots, subtracting\
    \ the need from the number of remaining carrots.", "  (let ([to-eat (min need\
    \ (- remaining number))])\n    (list (+ number to-eat) (- remaining to-eat))))\n\
    ```\n\n### The Cake Thief\n\n```racket\n#lang racket\n", "  (list (if (< need\
    \ remaining) (+ number need) (+ number remaining))\n        (if (< need remaining)\
    \ (- remaining need) 0)))\n", "  (cond\n    [(= 0 need) (list number remaining)]\n\
    \    [(< number need) (list number 0)]\n    [else (let ([remaining (- remaining\
    \ need)])\n            (list number remaining))]))\n", "  (let ((remaining (-\
    \ remaining need))\n        (need (- need number)))\n    (if (&lt; 0 remaining)\n\
    \        (list number remaining)\n        (list number 0))))\n</code>\nWhat is\
    \ the standard way to save the result of a few expression and then use them in\
    \ other expression in racket?\nIn this case I'm saving:\n<code>(define remaining\
    \ (- remaining need))", "  (let ([required (+ number need)])\n    (vector required\
    \ (if (< required remaining) 0 (- remaining required)))))\n", "  (list (+ number\
    \ need)\n        (max 0 (- remaining need))))\n\n```\n\n## Examples\n```racket",
  "  (define (needNumber number need)\n    (if (< number need)\n        need\n   \
    \     number))\n  (define (remainingNumber number need remaining)\n    (cond\n\
    \      [(>= (- remaining need) 0)\n       (- remaining need)]\n      [else\n \
    \      0]))\n  (list (needNumber number need)\n        (remainingNumber number\
    \ need remaining)))\n", "  (list (- remaining (max 0 (- need number)))\n     \
    \   (max 0 (- need number))))\n```\n\n#### Output\n```racket\n#(3 4)\n#(7 0)\n\
    #(1000 0)\n#(1000 0)\n```\n\n#### Notes\n\n- `max` returns the greatest number\
    \ of two values\n- `(list 1 2)` creates a new list with the given parameters\n\
    - We need to return the list with the `#(` prefix", "  (cond\n    [(< number 0)\
    \ (list -1 -1)]\n    [(< need 0) (list -1 -1)]\n    [(< remaining 0) (list -1\
    \ -1)]\n    [(< number (+ need remaining)) (list (+ number remaining) 0)]\n  \
    \  [else (list (+ number need) (- remaining need))]))\n", "  (let ((need-to-eat\
    \ (- need number)))\n    (cond\n      [(<= remaining need-to-eat)\n       (list\
    \ (+ number remaining) 0)]\n      [else\n       (list (+ number need-to-eat) (-\
    \ remaining need-to-eat))])))", "  (define total (+ number need))\n  (if (> total\
    \ remaining)\n      (list (list remaining 0))\n      (list (list total (- remaining\
    \ total)))))\n", "  (let ([eaten (if (> (+ number need) remaining)\n         \
    \          remaining\n                   (+ number need))])\n    (list eaten (-\
    \ remaining eaten))))", "  (list (+ number need)\n        (if (< need remaining)\
    \ (- remaining need)\n            (list number (list (+ number remaining) 0)))))\n",
  "  (cond [(< number need) (list (+ number remaining) 0)]\n        [else (list (+\
    \ number need) (- remaining need))]))\n", '  (list (+ number need) (- remaining
    need)))', "  (if (< need remaining)\n      (list (+ number need) (- remaining\
    \ need))\n      (list (+ number remaining) 0)))\n", "  (let ([rm (- remaining\
    \ need)])\n    (if (negative? rm)\n        (values (+ number remaining) 0)\n \
    \       (values (+ number need) rm))))\n", '  (list (+ number need) (- remaining
    need)))', "  (let* ([total (+ number need)]\n         [carrots (if (> total remaining)\
    \ remaining total)])\n    (list carrots (- remaining carrots))))\n```\n\n## Zadanie\
    \ 6\n\nNapisz funkcj\u0119, kt\xF3ra sprawdzi czy s\u0142owo z zadania 3 zawiera\
    \ jakie\u015B bia\u0142e znaki.\n\n## Zadanie 7\n\nZadanie 5:\n\nDla danego s\u0142\
    owa, sprawd\u017A czy nie zawiera ono \u017Cadnych wielkich liter.\n\n## Zadanie\
    \ 8\n\nZadanie 5:\n\nDla danego s\u0142owa, sprawd\u017A czy nie zawiera ono \u017C\
    adnych ma\u0142ych liter.\n\n## Zadanie 9\n\nZadanie 5:\n\nDla danego s\u0142\
    owa, sprawd\u017A czy nie zawiera ono \u017Cadnych liczb.\n\n## Zadanie 10\n\n\
    Zadanie 5:\n\nDla danego s\u0142owa, sprawd\u017A czy nie zawiera ono \u017Cadnych\
    \ nie alfanumerycznych znak\xF3w.\n\n## Zadanie 11\n\nZadanie 5:\n\nDla danego\
    \ s\u0142owa, zamie\u0144 wszystkie ma\u0142e litery na du\u017Ce i wypisz wynik.\n\
    \n## Zadanie 12\n\nZadanie 5:\n\nDla danego s\u0142owa, zamie\u0144 wszystkie\
    \ du\u017Ce litery na ma\u0142e i wypisz wynik.\n\n## Zadanie 13\n\nZadanie 5:\n\
    \nDla danego s\u0142owa, sprawd\u017A czy pierwsza litera jest du\u017Ca.\n\n\
    ## Zadanie 14\n\nZadanie 5:\n\nDla danego s\u0142owa, sprawd\u017A czy pierwsza\
    \ litera jest ma\u0142a.\n\n## Zadanie 15\n\nZadanie 5:\n\nDla dane", "  (if (>\
    \ remaining need)\n      (list (+ number need) (- remaining need))\n      (list\
    \ (+ number remaining) 0)))\n", "  (list (+ number need)\n        (if (< need\
    \ remaining)\n            (- remaining need)\n            0)))\n", "  (values\
    \ 0 0))\n```\n\n## :memo: Refactor\n\n\n## :link: Links\n\n\n## :memo: Notes\n\
    \n- Ternary expression in Scheme : `(if b (A) (B))`\n- `eq?` : test if two values\
    \ are the same, without considering their types.\n- `equal?` : test if two values\
    \ are the same, their types should be the same.\n- `integer?` : test if a value\
    \ is an integer.\n- `even?` : test if a value is an even number.\n- `odd?` : test\
    \ if a value is an odd number.\n- `<` : less than.\n- `>` : greater than.\n- `<=`\
    \ : less than or equal to.\n- `>=` : greater than or equal to.\n- `=` : equal\
    \ to.\n- `zero?` : test if a value is zero.\n- `positive?` : test if a value is\
    \ positive.\n- `negative?` : test if a value is negative.\n- `not` : opposite\
    \ boolean value.\n- `empty?` : test if a list is empty.\n- `first` : take the\
    \ first element of a list.\n- `second` : take the second element of a list.\n\
    - `last` : take the last element of a list.\n- `rest` : return a list without\
    \ the first element.\n- `cons` : add a value to the beginning of a list.\n- `list`\
    \ : create a list from the values.\n- `append` : add one list to the end of another.\n\
    - `length` : return the length of a list.\n- `map` : return a list of lists by\
    \ applying a function to every element of a list.\n- `filter` : return a list\
    \ by filtering elements of a list.\n- `foldl` : apply a function to every elements\
    \ of a list from left to right.\n- `foldr` : apply a function to every elements\
    \ of a list from right to left.\n- `reverse` : reverse a list.\n- `take` : return\
    \ a new list with the first `n` elements.\n- `drop` : return a new list without\
    \ the first `n` elements.\n- `any?` : test if any", "  (if (< (+ number need)\
    \ remaining)\n      (list (+ number need) (- remaining (+ number need)))\n   \
    \   (list (+ number remaining) 0)))", "  ;; Write your code here\n  (list (+ number\
    \ need) (- remaining need)))\n", "  (cond [(> need (+ number remaining)) (list\
    \ remaining 0)]\n        [else (list (+ number remaining) (- need (+ number remaining)))]))",
  "  (cond\n    [(> number (+ need remaining))\n      (list 0 0)]\n    [(> number\
    \ need)\n      (list (list remaining (+ number need))\n\t    (list need remaining))]\n\
    \    [else\n      (list (+ number need) remaining)]))", "  (cond [(= number need)\
    \ #(0 0)]\n        [(> need remaining) #(remaining 0)]\n        [else #(need (-\
    \ remaining need))]))\n", "  (cond\n    [(and (>= (+ number need) remaining) (>=\
    \ number remaining)) '(need remaining)]\n    [(>= (+ number need) remaining) (list\
    \ remaining (- (+ number need) remaining))]\n    [else (list (+ number need) (-\
    \ remaining (* 2 need)))]))\n", "  (list (- (+ number need) remaining) (max 0\
    \ (- remaining need))))\n", "  (if (not (and (integer? number)\n             \
    \   (integer? need)\n                (integer? remaining)))\n      '(0 0)\n  \
    \    (let loop ([number number]\n                 [need need]\n              \
    \   [remaining remaining])\n        (cond [(< (remaining number) 0)\n        \
    \       (list number remaining)]\n              [(= remaining 0)\n           \
    \    (list need need)]\n              [(= number need)\n               (list number\
    \ remaining)]\n              [else\n               (loop (+ number 1)\n      \
    \               need\n                     (- remaining 1))]))))\n", "  (cond\
    \ [(>= number (+ need remaining))\n         '()]\n        [(>= need remaining)\n\
    \         (list number (+ need remaining))]\n        [else\n         (list (+\
    \ number remaining) (- need remaining))]))\n", "  (if (<= (- (+ remaining number)\
    \ need) 0)\n      (list (+ need number) 0)\n      (list (+ number need) (- remaining\
    \ need))))\n```\n\n```", "  (if (and (> number 0) (> need 0) (> remaining 0))\n\
    \      (let* ([total (+ number need)]\n             [left (- remaining need)])\n\
    \        (if (< left 0)\n            (list total remaining)\n            (list\
    \ total left)))\n      (list 0 0)))\n", "  (if (< number need)\n      (if (< (+\
    \ number remaining) need)\n          (list (+ number remaining) 0)\n         \
    \ (list need (- need number)))\n      (list number remaining)))\n```\n\n```racket\n\
    #lang racket\n", "  (if (&gt;= (+ number need) remaining)\n      (list remaining\
    \ (- (+ number need) remaining))\n      (list (+ number need) (- remaining (+\
    \ number need)))))\n</code>\nHere are my test cases.\n<code>;; check-expect",
  "  (if (>= (- remaining number) need)\n      (list (+ number need) (- remaining\
    \ need))\n      (list (+ number remaining) 0)))\n", "  (cond [(and (>= number\
    \ (+ need remaining)) (> number need))\n         (list need 0)]\n        [(and\
    \ (> number (+ need remaining)) (> need remaining))\n         (list remaining\
    \ 0)]\n        [(and (>= number (+ need remaining)) (>= need remaining))\n   \
    \      (list remaining 0)]\n        [(and (>= number (+ need remaining)) (<= need\
    \ remaining))\n         (list need (- need remaining))]\n        [(and (< number\
    \ (+ need remaining)) (> number need))\n         (list number 0)]\n        [(and\
    \ (< number (+ need remaining)) (>= need remaining))\n         (list need (- need\
    \ remaining))]\n        [(and (< number (+ need remaining)) (<= need remaining))\n\
    \         (list number (- need remaining))]))\n", "  (let ((needed (- number need)))\n\
    \    (if (< needed 0)\n        (if (> number remaining)\n            (values (+\
    \ number remaining) 0)\n            (values (+ number needed) (- need (- need\
    \ needed))))\n        (values number (+ need number)))))\n", "  (if (&gt;= need\
    \ (+ number remaining))\n      (list (+ number remaining) 0)\n      (list (+ number\
    \ remaining) (- need (+ number remaining)))))\n</code>\nThis code doesn't work\
    \ because it returns the expected result if 'need' equals the number of carrots\
    \ left, but if 'need' is bigger than that, it returns 0 instead of the number\
    \ of remaining carrots.\nI know that the problem is in the else line\n<code>(list\
    \ (+ number remaining) (- need (+ number remaining)))\n</code>\nbut I can't figure\
    \ out what's wrong.\n\n\nA:\n\nThis is the problem:\n<code>(if (&gt;= need (+\
    \ number remaining))\n</code>\nIf you need more carrots than you have, you're\
    \ done. That's easy.\nOtherwise:\n<code>(list (+ number remaining) (- need (+\
    \ number remaining)))\n</code>\nYou're subtracting the number of carrots you had\
    \ before you added the new ones!\n", "  (cond ((and (> need 0) (> remaining 0))\n\
    \         (cons (+ number (min remaining need))\n               (- remaining (min\
    \ remaining need))))\n        (else\n         (cons number\n               remaining))))\n\
    ```\n\n```javascript\nfunction eat(number, need, remaining) {\n  return remaining\
    \ >= need\n    ? [number + need, remaining - need]\n    : [number + remaining,\
    \ 0];\n}\n```\n\n```ruby\ndef eat(n, need, remaining)\n  [remaining >= need ?\
    \ n + need : n + remaining, remaining >= need ? remaining - need : 0]\nend\n```\n\
    \n```python\ndef eat(number, need, remaining):\n    if remaining < need:\n   \
    \     return [number + remaining, 0]\n    else:\n        return [number + need,\
    \ remaining - need]\n```\n\n```haskell\nmodule Main where\n\neat :: Int -> Int\
    \ -> Int -> [Int]\neat number need remaining\n  | remaining < need = [number +\
    \ remaining, 0]\n  | otherwise = [number + need, remaining - need]\n```\n\n##\
    \ Solution:\n\n#### Swift\n```swift\nfunc eat(_ number: Int, _ need: Int, _ remaining:\
    \ Int) -> [Int] {\n    return remaining < need ? [number + remaining, 0] : [number\
    \ + need, remaining - need]\n}\n```\n\n```swift\nfunc eat(_ number: Int, _ need:\
    \ Int, _ remaining: Int) -> [Int] {\n    return remaining < need ? [number + remaining,\
    \ 0] : [number + need, remaining - need]\n}\n```\n\n#### Kotlin\n```kotlin\nfun\
    \ eat(number: Int, need: Int, remaining: Int): List<Int> {\n    return if (remaining\
    \ < need) listOf(number + remaining, 0) else listOf(number + need, remaining -\
    \ need)\n}\n```\n\n#### Java\n```java\npublic class EatCarrots {\n    public static\
    \ int[] eat(int number, int need, int remaining) {\n        if (remaining < need)\
    \ {\n            return new int[]{number + remaining, 0};\n        } else {\n\
    \            return new", "  (let* ([possible-remaining (- remaining need)]\n\
    \         [remaining (if (negative? possible-remaining)\n                    \
    \    0\n                        possible-remaining)])\n    (list (+ number need)\
    \ remaining)))\n```\n\n```racket\n#lang racket\n", "  (cond ((<= number 0) '())\n\
    \        ((<= need 0) '())\n        ((<= remaining 0) '())\n        ((= remaining\
    \ 0) (cons number '()))\n        ((> need remaining) (cons (+ number remaining)\
    \ '()))\n        (else (cons (+ number need) (- remaining need)))))\n", "  (define\
    \ (eat-inner number need remaining result)\n    (cond [(= number need) (vector\
    \ result remaining)]\n          [(> need number) (eat-inner (+ number 1) need\
    \ remaining (vector (+ result 1) remaining))]\n          [(< need number) (vector\
    \ result remaining)]))\n  (eat-inner number need remaining (vector number remaining)))\n",
  '  (list (- need number) (- remaining need)))', "  (cond [(> (+ number need) remaining)\n\
    \         (cons remaining 0)]\n        [else\n         (cons (+ number need) (-\
    \ remaining (+ number need)))]))", "  (let ([left (- need (- remaining number))])\n\
    \    (if (negative? left)\n        (values remaining left)\n        (values need\
    \ 0))))\n", "  (if (> need remaining)\n      (list number (- need remaining))\n\
    \      (list (+ number remaining) 0)))\n```\n\n```python\ndef eat(number, need,\
    \ remaining):\n    if need > remaining:\n        return [number + remaining, need\
    \ - remaining]\n    else:\n        return [number + need, 0]\n```\n\n```ruby\n\
    def eat(number, need, remaining)\n  if need > remaining\n    [number + remaining,\
    \ need - remaining]\n  else\n    [number + need, 0]\n  end\nend\n```\n\n## \u30C6\
    \u30B9\u30C8\n\n### Python \u306E\u5834\u5408\n\n```python\nimport pytest\n\n\
    from rabbit import eat\n\n@pytest.mark.parametrize('args, expected', [\n    ((1,\
    \ 3, 2), [3, 1]),\n    ((5, 10, 1), [6, 4]),\n    ((5, 10, 0), [5, 10]),\n   \
    \ ((5, 2, 10), [7, 0]),\n    ((1, 0, 2), [1, 0]),\n    ((0, 0, 1), [0, 0]),\n\
    \    ((1, 1, 0), [1, 0]),\n    ((0, 1, 2), [1, 0]),\n    ((0, 2, 3), [2, 0]),\n\
    \    ((20, 5, 10), [25, 0]),\n    ((10, 10, 5), [15, 0]),\n    ((0, 10, 5), [5,\
    \ 5]),\n    ((0, 10, 0), [0, 10]),\n    ((0, 10, 15), [10, 0]),\n    ((0, 10,\
    \ 20), [10, 0]),\n    ((5, 20, 15), [20, 5]),\n    ((5, 20, 0), [5, 20]),\n  \
    \  ((0, 20, 15), [15, 5]),\n    ((0, 20, 0), [0, 20]),\n    ((0, 20, 20), [20,\
    \ 0]),\n    ((0, 20, 25), [20, 0]),\n    ((0, 20, 30), [20, 0]),\n    ((10, 30,\
    \ 0), [10, 30]),\n    ((10, 30, 10", "  (if (&gt;= need (+ number remaining))\n\
    \      (list (+ number remaining) 0)\n      (list (+ number remaining) (- need\
    \ (+ number remaining)))))\n</code>\n", "  (let ([remaining (- remaining number)])\n\
    \    (if (> remaining need)\n        (values (+ number need) (- remaining need))\n\
    \        (values (+ number remaining) 0))))\n```\n\n### Metalsmith\n\n```#lang\
    \ racket\n", "  (make-vector 2\n               (if (< number need)\n         \
    \          (+ number remaining)\n                   (if (< remaining need)\n \
    \                      (+ number remaining)\n                       (- number\
    \ need)))))\n", "  (define (eat-helper number need remaining so-far eaten)\n \
    \   (cond\n      [(< need (+ number remaining)) (cons eaten (+ number remaining))]\n\
    \      [(>= need remaining) (cons (+ so-far remaining) (cons (- need remaining)\
    \ '()))]\n      [else (eat-helper (- so-far need) (+ number remaining) (- need\
    \ remaining) so-far eaten)]))\n  (eat-helper number need remaining number '()))\n",
  "  (list (+ number remaining)\n        (- number need)))\n```\n\n# Example\n```",
  "  (cond [(> number need)\n         '(0 0)]\n        [(> (+ number remaining) need)\n\
    \         `(,(+ number remaining) ,(- (+ number remaining) need))]\n        [else\
    \ '(0 0)]))\n", "  (cond [(>= (+ number need) remaining)\n         (list remaining\
    \ 0)]\n        [else\n         (list (+ number need) (- remaining (+ number need)))]))",
  "  (list (+ number need) (- remaining need)))\n", "  (if (or (not (integer? number))\n\
    \          (not (integer? need))\n          (not (integer? remaining))\n     \
    \     (< number 0)\n          (< need 0)\n          (< remaining 0)\n        \
    \  (> number 1000)\n          (> need 1000)\n          (> remaining 1000))\n \
    \     (printf \"Invalid input, please check again\")\n      (if (> (+ number need)\
    \ remaining)\n          (list (+ number remaining) 0)\n          (list (+ number\
    \ need) (- remaining need)))))\n", "  (let* ([eaten (+ number (min need remaining))]\n\
    \         [left (- remaining eaten)])\n    (list eaten left)))\n", "  (cond [(>\
    \ (+ number need) remaining)\n         (list remaining (+ number need remaining))]\n\
    \        [else\n         (list (+ number need) remaining)]))\n", "  (if (<= need\
    \ remaining)\n      (list (+ number need) (- remaining need))\n      (list (+\
    \ number remaining) 0)))\n", "  (list (min (+ number need) remaining)\n      \
    \  (- remaining (min (+ number need) remaining))))\n", "  (define meals\n    (cond\n\
    \      [(>= remaining need) (list (+ number need) (- remaining need))]\n     \
    \ [else (list (+ number remaining) 0)]))\n  meals)", "  (list (- (+ number need)\
    \ remaining)\n        (if (< remaining (+ number need))\n            0\n     \
    \       (- remaining need))))\n```\n\nThis is the test suite:\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(> remaining (+ number need)) (list (+ number need)\
    \ (- remaining (+ number need)))]\n    [(> remaining number) (list remaining (-\
    \ remaining number))]\n    [else (list remaining 0)]))", "  (if (< need (+ number\
    \ remaining))\n      (list (+ number need) (- remaining need))\n      (list (+\
    \ number remaining) 0)))\n", "  (let* ([a (if (<= (+ number need) remaining) number\
    \ (sub1 remaining))]\n         [b (if (<= (+ number need) remaining) (+ need number)\
    \ 0)])\n    (list a b)))\n```\n\n```javascript\n// lang:javascript\n\n/* You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\nbut\
    \ now you need to eat more carrots to complete the day's meals.\nyou should return\
    \ an array of [ total number of eaten carrots after your meals,\nthe number of\
    \ carrots left after your meals ]\nif there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\nExample:\nVariables:\n\
    @number : integer\nthe number of carrots that you have eaten.\n@need : integer\n\
    the number of carrots that you need to eat.\n@remaining : integer\nthe number\
    \ of remaining carrots thet exist in stock\nConstrain:\n* 0 <= number <= 1000\n\
    * 0 <= need <= 1000\n* 0 <= remaining <= 1000\nHave fun :) */\n\nconst eat = (number,\
    \ need, remaining) => {\n  const a = number <= remaining - need ? number : remaining\
    \ - 1;\n  const b = number <= remaining - need ? number + need : 0;\n  return\
    \ [a, b];\n};\n```\n\n```ruby\n# lang:ruby\n\n# You're a hungry rabbit, and you\
    \ already have eaten a certain number of carrots,\n# but now you need to eat more\
    \ carrots to complete the day's meals.\n# you should return an array of [ total\
    \ number of eaten carrots after your meals,\n# the number of carrots left after\
    \ your meals ]\n# if there are not enough remaining carrots, you will eat all\
    \ remaining carrots, but will still be hungry.\n# Example:\n# Variables:\n# @number\
    \ : integer\n# the number of carrots that you have eaten.\n# @need : integer\n\
    # the number of carrots that you need to eat.\n# @remaining : integer\n# the number\
    \ of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n\
    # * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\ndef eat(number,\
    \ need, remaining)\n  a = number <= remaining -", "  (match need\n        [0 0\
    \ 0]\n        [n (if (>= (+ number remaining) n)\n               (+ number remaining)\n\
    \               number)\n           (if (>= (+ number remaining) n)\n        \
    \       (- (+ number remaining) n)\n               remaining)]))\n", "  (let ([rem-carrots\
    \ (min (+ number remaining) (* 2 number))])\n    (if (> need rem-carrots)\n  \
    \      (values rem-carrots (- need rem-carrots))\n        (values number 0))))\n",
  "  (local [(define carrots-to-eat (if (>= need remaining) remaining (- need number)))\n\
    \          (define eaten (if (>= need remaining) (+ number remaining) (+ number\
    \ (- need number))))]\n          (list eaten carrots-to-eat)))", "  (let* ([eating\
    \ (+ number need)]\n         [total-carrots (max (- remaining eating) 0)])\n \
    \   (cond\n      [(> need remaining)\n       (list (+ number remaining) 0)]\n\
    \      [else\n       (list eating total-carrots)])))\n", "  (if (> remaining 0)\n\
    \      (let ([consumed (min remaining need)])\n        (list (+ number consumed)\
    \ (- remaining consumed)))\n      (list number remaining)))\n", "  (let* ((total\
    \ (+ number need))\n         (actual (if (> total remaining) remaining total)))\n\
    \    (vector actual (- actual number))))\n", "  (cond\n    [(>= remaining (- need\
    \ number)) (vector (+ number remaining) 0)]\n    [else (vector (+ number need)\
    \ (- remaining need))]))\n", '  (vector (+ number need) (- remaining need)))',
  "  (if (>= number need)\n      (list (+ number remaining) 0)\n      (list (+ number\
    \ remaining) (- need number))))\n", "  (list (+ number need)\n        (if (> number\
    \ remaining)\n            0\n            (- remaining need))))", "  (cond\n  \
    \  [(> (+ number need) remaining) (list remaining 0)]\n    [else (list (+ number\
    \ need) (- remaining (+ number need)))]))\n", "  (list (if (> (+ number remaining)\
    \ need)\n            need\n            (+ number remaining))\n        (if (> (+\
    \ number remaining) need)\n            (- (+ number remaining) need)\n       \
    \     0)))\n", "  (if (<= remaining need)\n      (cons number (- remaining need))\n\
    \      (cons (+ number remaining) 0)))\n", "  (let ([eaten (+ number need)])\n\
    \    (cond\n      [(> eaten remaining)\n       (values remaining (- eaten remaining))]\n\
    \      [else\n       (values eaten 0)])))\n", "  (let ((result\n         (if (<\
    \ (+ number need) remaining)\n             '(list (+ number need) (- remaining\
    \ need))\n             '(list (+ number remaining) 0))))\n    (if (symbol? (car\
    \ result))\n        (list (eval (car result)) (eval (cadr result)))\n        result)))\n",
  "  (define total (+ number need))\n  (if (> total remaining)\n      (list remaining\
    \ (- total remaining))\n      (list total (- remaining need))))\n```\n\n```\n\
    #lang racket\n", "  (list (+ number remaining)\n        (if (< remaining need)\n\
    \            0\n            (- remaining need))))", "  (let ([remaining (if (<\
    \ remaining number) 0 (- remaining number))])\n    (if (< need remaining)\n  \
    \      (values (+ number need) (- remaining need))\n        (values (+ number\
    \ remaining) 0))))\n", "  (if (&gt; (+ number need) remaining)\n      (list remaining\
    \ (- need (- number remaining)))\n      (list (+ number need) (- remaining (+\
    \ number need)))))\n</code>\nTest\n<code>#lang racket\n", "  (if (and (zero? remaining)\
    \ (not (zero? need)))\n      '(0 0)\n      (let* ([number (+ number (min remaining\
    \ need))]\n             [remaining (- remaining (min remaining need))])\n    \
    \    (if (zero? need)\n            (list number remaining)\n            (eat number\
    \ (sub1 need) remaining)))))\n", "  (define eaten (cond [(<= (+ number need) remaining)\
    \ (+ number need)]\n                       [else remaining]))\n  (define left\
    \ (- remaining eaten))\n  (vector eaten left))\n", "  (cond [(= 0 number) (list\
    \ 0 (- need number remaining))]\n        [(= 0 need) (list number 0)]\n      \
    \  [(= 0 remaining) (list number -need)]\n        [else (if (> need remaining)\n\
    \                 (list (+ number remaining) (- need remaining))\n           \
    \      (list (+ number need) 0))]))\n", "  (cond [(> number remaining) (list remaining\
    \ 0)]\n        [(> (+ number need) remaining) (list remaining (remaining - number))]\n\
    \        [else (list (+ number need) (- remaining (+ number need)))]))", "  (let\
    \ ([remaining-carrots (- remaining number)])\n    (if (< number remaining)\n \
    \       (if (< need remaining-carrots)\n            (list (+ number need) (- remaining-carrots\
    \ need))\n            (list (+ number remaining-carrots) 0))\n        (list remaining\
    \ 0))))\n", "  (let* ([carrots (- (+ number remaining) need)]\n         (result\
    \ (if (< 0 carrots)\n                     (vector carrots 0)\n               \
    \      (vector number (- need number)))))\n    result))\n", "  (if (< number need)\n\
    \      (if (<= remaining (need - number))\n          (list (+ number remaining)\
    \ 0)\n          (list (+ number remaining) (- remaining (- need number))))\n \
    \     (list number (- remaining (- need number)))))\n", "  (vector (+ number need)\
    \ (- remaining need)))\n\n```\n\n## Xmas - By AduhPaijo\n\n- What is this?\n\n\
    ```scheme\n#lang racket\n", "  (if (> number need)\n      (vector need 0)\n  \
    \    (if (> (+ number remaining) need)\n          (vector (+ number remaining)\
    \ (- need number))\n          (vector (+ number remaining) 0))))\n\n```\n\n###\
    \ Problem 3:\n\n```racket\n#lang racket\n", "  (list (- number need)\n       \
    \ (- remaining need)))\n", "  (list (+ number (min remaining need))\n        (-\
    \ remaining (min remaining need))))\n```\n\n### C#\n\n```csharp\npublic static\
    \ int[] Eat(int number, int need, int remaining)\n{\n    return new int[] { number\
    \ + Math.Min(remaining, need), remaining - Math.Min(remaining, need) };\n}\n```\n\
    \n### Crystal\n\n```crystal\ndef eat(number, need, remaining)\n  [number + [remaining,\
    \ need].min, remaining - [remaining, need].min]\nend\n```\n\n### Elixir\n\n```elixir\n\
    def eat(number, need, remaining) do\n  [number + min(remaining, need), remaining\
    \ - min(remaining, need)]\nend\n```\n\n### F#\n\n```fsharp\nlet eat number need\
    \ remaining =\n  [number + min remaining need; remaining - min remaining need]\n\
    ```\n\n### Go\n\n```go\npackage code_wars\n\nfunc Eat(number int, need int, remaining\
    \ int) []int {\n\treturn []int{number + min(remaining, need), remaining - min(remaining,\
    \ need)}\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn\
    \ b\n}\n```\n\n### Groovy\n\n```groovy\nclass Kata {\n    static int[] eat(int\
    \ number, int need, int remaining) {\n        return [number + Math.min(remaining,\
    \ need), remaining - Math.min(remaining, need)]\n    }\n}\n```\n\n### Java\n\n\
    ```java\nclass CodeWars {\n  public static int[] eat(int number, int need, int\
    \ remaining) {\n    return new int[] { number + Math.min(remaining, need), remaining\
    \ - Math.min(remaining, need) };\n  }\n}\n```\n\n### JavaScript\n\n```javascript\n\
    function eat(number, need, remaining) {\n  return [\n    number + Math.min(remaining,\
    \ need),\n    remaining - Math.min(remaining, need)\n  ];\n}\n```\n\n### Kotlin",
  "  (list (+ number need) (- remaining need)))\n", "  (cond\n    [(< number 0) (vector\
    \ 0 (inc remaining))]\n    [(> number 0) (vector (+ need number) (dec remaining))]\n\
    \    [else (vector number remaining)]))\n", "  (list (+ number (if (< remaining\
    \ need) remaining need))\n        (- remaining (- need (if (< remaining need)\
    \ remaining need)))))", "  (let* ([completed? (<= need (+ number remaining))]\n\
    \         [eat-number (if completed?\n                         (+ number remaining)\n\
    \                         (+ number need))]\n         [remaining-number (if completed?\n\
    \                               0\n                               (- remaining\
    \ eat-number))])\n    (list eat-number remaining-number)))", "  (list (+ number\
    \ need)\n        (if (< (+ number need) remaining)\n            (- remaining (+\
    \ number need))\n            0)))", "  (let ((remaining (- remaining number))\n\
    \        (carrots (if (< number remaining) number remaining)))\n    (if (< need\
    \ carrots)\n        (list need 0)\n        (list carrots (- carrots need)))))\n",
  "  (list (+ number need) (- remaining need)))\n```\n\n## Examples\n\n```", "  (list\
    \ (add1 number)\n        (add1 remaining)))\n", "  (if (>= (- remaining number)\
    \ need)\n      (list (+ number need) (- remaining need))\n      (list (+ number\
    \ remaining) 0)))", "  (list (min (+ number need) remaining) (- remaining (min\
    \ (+ number need) remaining))))\n", "  (values\n   (if (<= number (+ need remaining))\n\
    \       (+ number need)\n       (+ number remaining))\n   (if (<= number (+ need\
    \ remaining))\n       (- remaining need)\n       0)))\n```\n\n```\n#lang racket\n",
  "  (cond ((> need remaining) (list (add1 (+ number remaining)) 0))\n        (else\
    \ (list (add1 (+ number need)) (- remaining need)))))\n```\n\n#### My Solution\n\
    \n```scheme", "  (define (eat* x n y acc)\n    (if (or (< n (+ acc y)) (= n (+\
    \ acc y)))\n        (list acc n)\n        (eat* x n y (+ acc y))))\n  (eat* number\
    \ need remaining number))", "  (let ((sum (+ number need)))\n    (cond\n     \
    \ [(> sum remaining) (list remaining (- sum remaining))]\n      [else (list sum\
    \ 0)])))", "  (list\n   (cond\n     [(>= (+ number remaining) need) (+ number\
    \ remaining)]\n     [else (+ number remaining)])\n   (cond\n     [(>= (+ number\
    \ remaining) need) 0]\n     [else (- need (+ number remaining))])))", "  (list\
    \ (+ number remaining) (- remaining need)))\n", "  (define eaten-carrots (+ number\
    \ (min need remaining)))\n  (define left-carrots (- (max 0 (- remaining need))\
    \ number))\n  (list eaten-carrots left-carrots))\n", "  (vector (+ number need)\n\
    \          (if (>= number (+ number need))\n              0\n              (-\
    \ remaining need))))\n", "  ;; Write your code here :)\n  (cond\n    [(= remaining\
    \ 0) (list number 0)]\n    [(= need 0) (list number remaining)]\n    [(> number\
    \ need) (list (+ number (- number need)) remaining)]\n    [(> need remaining)\
    \ (list (+ number remaining) 0)]\n    [else (list (+ number need) (- remaining\
    \ need))]))\n\n```", "  (let* ((result-need (- need number))\n         (carrots-left\
    \ (- remaining result-need))\n         (carrots-eaten (+ number remaining)))\n\
    \    (if (equal? carrots-left 0)\n        (list carrots-eaten 0)\n        (list\
    \ carrots-eaten carrots-left))))", "  (list (+ number need) (- remaining need)))\n",
  "  (list (+ number (min need remaining))\n        (- remaining (min need remaining))))\n",
  "  (let* ([eaten (+ number need)]\n         [remaining (- remaining number)]\n \
    \        [result (list (list eaten) (list remaining))])\n    result))\n", "  (vector\
    \ (+ number\n             (if (< need remaining)\n                 need\n    \
    \             remaining))\n          (- remaining\n             (if (< need remaining)\n\
    \                 need\n                 remaining))))\n", "  (let ([eaten (+\
    \ number (min need remaining))])\n    (list eaten (- remaining eaten))))\n", " \
    \ (if (> need remaining)\n      (values (+ number remaining) 0)\n      (values\
    \ (+ number need) (- remaining need))))\n", "  (list (if (> (+ number remaining)\
    \ need)\n            need\n            (+ number remaining))\n        (if (> (+\
    \ number remaining) need)\n            (- remaining (- need number))\n       \
    \     0)))\n", '  (values (+ number (min need remaining)) (- remaining (min need
    remaining))))', "  (cond ((>= (+ number need) remaining)\n         (values (+\
    \ number remaining) 0))\n        (else (values (+ number need) (- remaining (+\
    \ number need))))))\n", "  (if (<= (+ number need) remaining)\n      (list (+\
    \ number need) (- remaining (+ number need)))\n      (list (+ number remaining)\
    \ 0)))\n", "  (cond\n    [(< (- remaining need) 0)\n     (list (+ number remaining)\
    \ 0)]\n    [else\n     (list (+ number need) (- remaining need))]))\n", "  (define\
    \ (aux number need remaining consumed)\n    (cond\n      [(= number need) (list\
    \ consumed remaining)]\n      [(> need remaining) (list consumed consumed)]\n\
    \      [(>= (+ number remaining) need) (list need (- need number))]\n      [else\
    \ (aux (+ number remaining) need 0 (+ number remaining))]))\n  (aux number need\
    \ remaining 0))\n", "  (letrec ((eat! (lambda (e n r)\n                  (if (<=\
    \ e n)\n                      (list (+ e r) (- r (- n e)))\n                 \
    \     (list e 0)))))\n    (eat! number need remaining)))\n", "  (list (-&gt; number\
    \ (+ need) (min remaining))\n        (-&gt; remaining (- need) (max 0))))\n",
  "  (define eaten (+ number need))\n  (if (>= eaten remaining)\n      (list remaining\
    \ (- eaten remaining))\n      (list eaten 0)))\n", "  (let ([remaining (- remaining\
    \ need)])\n    (if (> remaining 0)\n        (list (+ number need) remaining)\n\
    \        (list (+ number remaining) 0))))\n```\n\n## WIP", "  (if (< number need)\n\
    \      (list (+ number remaining) 0)\n      (list (+ number remaining) (- need\
    \ number))))\n", "  (cond\n    ((or (> number 1000) (> need 1000) (> remaining\
    \ 1000)) '(-1 -1))\n    ((>= remaining need) `(,(+ number need) ,(- remaining\
    \ need)))\n    (else `(,(+ number remaining) ,0))))\n```\n\n```ruby\n#lang_en\n\
    \n###\n# Challenge #425 [Easy] \n# Language: Ruby\n# Author: @peter_budo\n# Date:\
    \ 2015-07-21\n#\n# You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n# but now you need to eat more carrots to complete the day's\
    \ meals.\n# you should return an array of [ total number of eaten carrots after\
    \ your meals,\n# the number of carrots left after your meals ]\n# if there are\
    \ not enough remaining carrots, you will eat all remaining carrots, but will still\
    \ be hungry.\n# Example:\n# Variables:\n# @number : integer\n# the number of carrots\
    \ that you have eaten.\n# @need : integer\n# the number of carrots that you need\
    \ to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist\
    \ in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# *\
    \ 0 <= remaining <= 1000\n# Have fun :)\n###\n\n#lang_fr\n\n###\n# Defi #425 [Facile]\
    \ \n# Langage: Ruby\n# Auteur: @peter_budo\n# Date: 2015-07-21\n#\n# You're a\
    \ hungry rabbit, and you already have eaten a certain number of carrots,\n# but\
    \ now you need to eat more carrots to complete the day's meals.\n# you should\
    \ return an array of [ total number of eaten carrots after your meals,\n# the\
    \ number of carrots left after your meals ]\n# if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n# Example:\n\
    # Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n\
    # @need : integer\n# the number of carrots that you need to eat.\n# @remaining\
    \ : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n\
    # * 0 <=", "  (define carrots-i-need\n    (if (< need remaining)\n        need\n\
    \        remaining))\n  (define carrots-left\n    (- remaining carrots-i-need))\n\
    \  (define carrots-eaten\n    (+ number carrots-i-need))\n  (list carrots-eaten\
    \ carrots-left))\n", "  (define eaten (+ number need))\n  (define left (- remaining\
    \ eaten))\n  (if (> left 0)\n      (list eaten left)\n      (list eaten 0)))",
  "  (define total (+ number need))\n  (if (> total remaining)\n      (list remaining\
    \ 0)\n      (list total (- remaining need))))\n", "  (if (<= need remaining)\n\
    \      (list (+ number need) (- remaining need))\n      (list (+ number remaining)\
    \ 0)))\n", "  (cond [(>= number need) (values number 0)]\n        [(>= need (+\
    \ number remaining)) (values (+ number remaining) 0)]\n        [else (values (+\
    \ number remaining) (- need (- number remaining)))]))\n", "  (if (or (< number\
    \ 0) (< need 0) (< remaining 0))\n      '()\n      (if (> (+ number need) remaining)\n\
    \          (list remaining (+ number need remaining))\n          (list (+ number\
    \ need) (- remaining (+ number need))))))\n", "  (values (+ number need) (- remaining\
    \ need)))\n```\n\n```scheme\n#lang racket\n", "  (cond [(> need remaining)\n \
    \        (list (+ number remaining) 0)]\n        [else\n         (list (+ number\
    \ need) (- remaining need))]))\n", "  (list (+ number (min remaining need))\n\
    \        (- remaining (min remaining need))))", "  (let ((total-carrots (+ number\
    \ remaining)))\n    (cond\n      [(< total-carrots need)\n       (values total-carrots\
    \ 0)]\n      [else\n       (values number (- total-carrots need))])))\n", "  (cond\
    \ [(>= need remaining)\n         (list (+ number remaining) 0)]\n        [else\n\
    \         (list (+ number need) (- remaining need))]))\n", "  (list (+ number\
    \ (min remaining need))\n        (- remaining (min remaining need))))\n", "  (if\
    \ (and (<= 0 number 1000)\n           (<= 0 need 1000)\n           (<= 0 remaining\
    \ 1000))\n      (if (< (+ number need) remaining)\n          (list (+ number need)\
    \ (- remaining (+ number need)))\n          (list remaining (- remaining remaining)))\n\
    \      (error \"Invariant failed\")))\n", "  (let ((total (+ number need))\n \
    \       (remain (- remaining need)))\n    (if (< remain 0)\n        (vector total\
    \ remaining)\n        (vector total 0))))", "  ;; your code\n  (list (min (+ number\
    \ need) remaining) (- remaining (min (+ number need) remaining))))\n", "  (let*\
    \ ([max (max remaining need)]\n         [eaten (min max (add1 number))]\n    \
    \     [left (sub1 (sub1 remaining need))])\n    (list eaten left)))\n", "  (cond\
    \ ((= need 0) (list number 0))\n        ((< remaining 0) (list number 0))\n  \
    \      ((< remaining need) (list (+ number remaining) 0))\n        (else (list\
    \ (+ number need) (- remaining need)))))\n", "  (cond ((<= number 0)\n       \
    \  (cond ((<= need 0)\n                (cond ((<= remaining 0)\n             \
    \          '(0 0))\n                      ((> remaining 0)\n                 \
    \      '(0 remaining))\n                      (else\n                       '(0\
    \ 0))))\n               ((> need 0)\n                (cond ((<= remaining 0)\n\
    \                       '(0 0))\n                      ((> remaining 0)\n    \
    \                   '(0 remaining))\n                      (else\n           \
    \            '(0 0))))\n               (else\n                '(0 0))))\n    \
    \    ((> number 0)\n         (cond ((<= need 0)\n                (cond ((<= remaining\
    \ 0)\n                       '(number 0))\n                      ((> remaining\
    \ 0)\n                       '(number remaining))\n                      (else\n\
    \                       '(number 0))))\n               ((> need 0)\n         \
    \       (cond ((<= remaining 0)\n                       '(number 0))\n       \
    \               ((> remaining 0)\n                       '(number remaining))\n\
    \                      (else\n                       '(number 0))))\n        \
    \       (else\n                '(number 0))))\n        (else\n         '(0 0))))\n",
  "  (values (min (+ number need) remaining) (- remaining (min need remaining))))\n",
  "  (let ((eaten (+ number remaining))\n        (left (sub1 (- (- eaten number) need))))\n\
    \    (if (positive? left)\n        (list eaten left)\n        (list eaten (sub1\
    \ left)))))\n", "  (let ([needed (min need remaining)])\n    (list (+ number needed)\
    \ (- remaining needed))))\n", "  (cond\n    [(> number remaining)\n     (list\
    \ number 0)]\n    [(> need remaining)\n     (list (+ number remaining) 0)]\n \
    \   [else\n     (list (+ number need) (- remaining need))]))\n", "  (cond [(>=\
    \ number need)\n         (list (- number need) remaining)]\n        [(>= (+ number\
    \ remaining) need)\n         (list need (- (+ number remaining) need))]\n    \
    \    [else\n         (list (+ number remaining) 0)]))\n", "  (cond [(< number\
    \ 0) (list 0 0)]\n        [(< need 0) (list 0 0)]\n        [(< remaining 0) (list\
    \ 0 0)]\n        [(> (+ number need) remaining) (list remaining (+ remaining number))]\n\
    \        [else (list (+ number need) (- remaining need))]))", "  (let [(need-remaining\
    \ (- need remaining))]\n    (if (> need-remaining 0)\n        (list (+ number\
    \ remaining)\n              0)\n        (list (+ number need)\n              (-\
    \ remaining need)))))\n", "  (let ([remaining (- remaining number)])\n    (cond\n\
    \      [(> need remaining) (values (+ number remaining) 0)]\n      [else (values\
    \ (+ number need) (- remaining need))])))\n", "  (cond\n    [(<= (+ number need)\
    \ remaining) (list (+ number need) (- remaining (+ number need)))]\n    [else\
    \ (list (+ number remaining) 0)]))\n```", "  (list (+ number remaining) (- need\
    \ (- need remaining))))\n", "  (cond\n    [(> (+ number need) remaining) (list\
    \ (+ number remaining) 0)]\n    [else (list (+ number need) (- remaining need))]))\n",
  "  (list (+ number need) (- remaining need)))\n```\n\n### [Reverse Strings](https://www.codewars.com/kata/5168bb5dfe9a00b126000018)\n\
    \n```racket\n#lang racket\n", "  (list (+ number need) (- remaining need)))\n\
    ```\n\n```text\n@info        This is a simple challenge.\n@info        You have\
    \ to complete a function that takes 2 inputs.\n@info        Input: a string and\
    \ a charecter.\n@info        Output: a string.\n@info        The output string\
    \ is the input string with the character\n@info        added to the end.\n@info\
    \        Examples:\n@info        ('Hello world!', '!') => 'Hello world!!'\n@info\
    \        ('Hello world!', '?') => 'Hello world!?'\n@info        ('I am hungry',\
    \ '~') => 'I am hungry~'\n@info        Have fun!!!\n```\n\n```racket\n#lang racket\n",
  "  (let ([not-enough? (and (>= remaining need)\n                          (< remaining\
    \ (+ number need)))]\n        [enough? (< remaining (+ number need))])\n    (cond\n\
    \      [not-enough? (list (+ number remaining) 0)]\n      [enough? (list (+ number\
    \ need) (- remaining (+ number need)))]\n      [else (list (+ number need) 0)])))",
  "  (if (and (and (integer? number) (>= number 0) (<= number 1000))\n           (and\
    \ (integer? need) (>= need 0) (<= need 1000))\n           (and (integer? remaining)\
    \ (>= remaining 0) (<= remaining 1000)))\n      (values number\n             \
    \ (if (> number need)\n                  remaining\n                  (if (> (+\
    \ number remaining) need)\n                      (- (+ number remaining) need)\n\
    \                      0)))\n      (values)))\n", "  (list\n   (+ number (min\
    \ need remaining))\n   (- remaining (min need remaining))))\n", "  (cond\n   \
    \ [(= number need) (list number 0)]\n    [(> need (+ number remaining)) (list\
    \ (+ number remaining) 0)]\n    [else (list (+ number need) (- remaining need))]))\n",
  "  (cond [(> need remaining) '(0 0)]\n        [else (let* ([remaining-number (-\
    \ need number)]\n                     [total-eaten (+ number remaining-number)]\n\
    \                     [total-remaining (- remaining total-eaten)])\n         \
    \       (cons total-eaten total-remaining))]))\n", "  ;; define a variable that\
    \ will be returned at the end\n  (local ((define result '(0 0)))\n    ;; does\
    \ the rabbit need more carrots?\n    (cond\n      ;; when the rabbit has everything\
    \ he needs\n      ((= need 0)\n       (set! result (list number remaining)))\n\
    \      ;; when there are no carrots left\n      ((= remaining 0)\n       (set!\
    \ result (list number 0)))\n      ;; when the rabbit is still a bit hungry\n \
    \     (else\n       (set! number (+ number 1))\n       (set! need (- need 1))\n\
    \       (set! remaining (- remaining 1))\n       (set! result (eat number need\
    \ remaining))))\n    result))\n", "  (let* ([total-eaten (+ number need)]\n  \
    \       [total-remaining (- remaining need)]\n         [carrots-eaten (if (> total-remaining\
    \ 0) total-eaten remaining)]\n         [carrots-remaining (if (> total-remaining\
    \ 0) total-remaining 0)])\n    (list carrots-eaten carrots-remaining)))\n", " \
    \ (list (if (>= remaining need) (+ number need) (+ number remaining))\n      \
    \  (if (>= remaining need) 0 (- need remaining))))\n", "  (define total (+ number\
    \ need))\n  (list total (- total (if (< remaining total) remaining 0))))", " \
    \ (cond [(> remaining need)\n         (list (- remaining need) 0)]\n        [else\n\
    \         (list (- remaining number) 0)]))\n", "  (list (+ number (min need remaining))\
    \ (- remaining (min need remaining))))\n", "  (let ((remaining (- remaining number)))\n\
    \    (if (< need remaining)\n        (list need remaining)\n        (list (+ number\
    \ remaining) 0))))", "  (cond [(= remaining 0)\n         (list 0 number)]\n  \
    \      [(>= remaining (+ number need))\n         (list need (+ number need))]\n\
    \        [else\n         (list remaining (+ number remaining))]))", "  (define\
    \ number-eaten (+ number need))\n  (define new-remaining (- remaining number-eaten))\n\
    \  (if (< new-remaining 0)\n      '(0 (- remaining number))\n      '(number-eaten\
    \ new-remaining)))\n```\n\n```scheme\n#lang racket\n", "  (if (< (+ number need)\
    \ remaining)\n      (list (+ number need) (- remaining (+ number need)))\n   \
    \   (list (+ number remaining) 0)))\n```\n\n### Python\n\n```python\ndef eat(number,\
    \ need, remaining):\n    if (number + need) <= remaining:\n        return [number\
    \ + need, remaining - (number + need)]\n    else:\n        return [number + remaining,\
    \ 0]\n```\n\n### Java\n\n```java\npublic class Solution {\n    public static int[]\
    \ eat(int number, int need, int remaining) {\n        int[] res = new int[2];\n\
    \        if ((number + need) > remaining) {\n            res[0] = number + remaining;\n\
    \            res[1] = 0;\n        } else {\n            res[0] = number + need;\n\
    \            res[1] = remaining - (number + need);\n        }\n        return\
    \ res;\n    }\n}\n```\n\n### C#\n\n```csharp\npublic class Solution {\n    public\
    \ static int[] eat(int number, int need, int remaining) {\n        int[] res =\
    \ new int[2];\n        if ((number + need) > remaining) {\n            res[0]\
    \ = number + remaining;\n            res[1] = 0;\n        } else {\n         \
    \   res[0] = number + need;\n            res[1] = remaining - (number + need);\n\
    \        }\n        return res;\n    }\n}\n```\n\n### C++\n\n```cpp\nstd::vector<int>\
    \ eat(int number, int need, int remaining) {\n    std::vector<int> ans;\n    if\
    \ ((number + need) > remaining) {\n        ans.push_back(number + remaining);\n\
    \        ans.push_back(0);\n    } else {\n        ans.push_back(number + need);\n\
    \        ans.push_back(remaining - (number + need));\n    }\n    return ans;\n\
    }\n```\n\n### Go\n\n```go\nfunc eat(number int, need int, remaining int) (res\
    \ []int) {\n\tif (number + need) > remaining {\n\t\tres = append(res, number",
  "  (let ((need (- need number))\n        (remaining (- remaining number)))\n   \
    \ (cond ((> need remaining) (list (+ number remaining) 0))\n          (else (list\
    \ (+ number need) (- remaining need))))))\n", "  (list (+ number need) (- remaining\
    \ need)))\n</code>\nMy interpretation of the problem statement is to return the\
    \ total number of carrots eaten and the number of carrots left after the meal\
    \ if there is enough carrots left to eat and if there is not enough left to eat,\
    \ eat the remaining carrots and return that number.\nMy code returns:\n<code>Expected:\
    \ [6, 5], instead got: [6, 5]\nExpected: [3, 0], instead got: [3, 0]\nExpected:\
    \ [2, 0], instead got: [2, 0]\nExpected: [2, 1], instead got: [2, 1]\nExpected:\
    \ [3, 2], instead got: [3, 2]\nExpected: [5, 3], instead got: [5, 3]\nExpected:\
    \ [6, 2], instead got: [6, 2]\nExpected: [5, 1], instead got: [5, 1]\nExpected:\
    \ [7, 1], instead got: [7, 1]\nExpected: [4, 0], instead got: [4, 0]\nExpected:\
    \ [6, 0], instead got: [6, 0]\nExpected: [8, 0], instead got: [8, 0]\nExpected:\
    \ [1, 0], instead got: [1, 0]\nExpected: [0, 0], instead got: [0, 0]\nExpected:\
    \ [3, 0], instead got: [3, 0]\nExpected: [2, 0], instead got: [2, 0]\nExpected:\
    \ [2, 0], instead got: [2, 0]\nExpected: [1, 0], instead got: [1, 0]\nExpected:\
    \ [0, 0], instead got: [0, 0]\nExpected: [4, 0], instead got: [4, 0]\nExpected:\
    \ [2, 0], instead got: [2, 0]\nExpected: [3, 0], instead got: [3, 0]\nExpected:\
    \ [3, 0], instead got: [3, 0]\nExpected: [5, 0], instead got: [5, 0]\nExpected:\
    \ [7, 0], instead got: [7, 0]\nExpected: [9, 0], instead got", "  (cond\n    [(>\
    \ need remaining) (list number 0)]\n    [else (list (+ number need) (- remaining\
    \ need))]))\n", "  (cond [(<= remaining need)\n         #(0 (+ need remaining))]\n\
    \        [else\n         #(need (- remaining need))]))\n", "  (define (eat_1 number\
    \ need remaining)\n    (cond [(< number need) (cons (+ number remaining) (- need\
    \ number))]\n          [(>= number need) (cons need remaining)]))\n  (cond [(<\
    \ need remaining) (eat_1 number need remaining)]\n        [(>= need remaining)\
    \ (eat_1 number remaining 0)]))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
