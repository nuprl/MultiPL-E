name: HumanEval_63_fibfib
language: rkt
prompt: "#lang racket\n\n;; The FibFib number sequence is a sequence similar to the\
  \ Fibbonacci sequnece that's defined as follows:\n;; fibfib(0) == 0\n;; fibfib(1)\
  \ == 0\n;; fibfib(2) == 1\n;; fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\
  ;; Please write a function to efficiently compute the n-th element of the fibfib\
  \ number sequence.\n(define (fibfib n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n\
  \    (check-equal? (candidate 2) 1)\n    (check-equal? (candidate 1) 0)\n    (check-equal?\
  \ (candidate 5) 4)\n    (check-equal? (candidate 8) 24)\n    (check-equal? (candidate\
  \ 10) 81)\n    (check-equal? (candidate 12) 274)\n    (check-equal? (candidate 14)\
  \ 927)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (match n\n\
    \    [(0) 0]\n    [(1) 0]\n    [(2) 1]\n    [(n)\n     (+ (fibfib (- n 1))\n \
    \       (fibfib (- n 2))\n        (fibfib (- n 3)))]))\n", "  (if (< n 3)\n  \
    \    (- n 1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n",
  "  (cond [(zero? n) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else\
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n\n", "  (if (= n 0)\n      0\n      (if (= n\
    \ 1)\n          0\n          (if (= n 2)\n              1\n              (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "  (cond ((= n 0) 0)\n \
    \       ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (let ((fibonacci-table (list 0 0 1)))\n    (for ([i (in-range\
    \ 3 n)])\n      (set! fibonacci-table (cons (+ (list-ref fibonacci-table (- i\
    \ 1))\n                                     (list-ref fibonacci-table (- i 2))\n\
    \                                     (list-ref fibonacci-table (- i 3)))\n  \
    \                                fibonacci-table)))\n    (list-ref fibonacci-table\
    \ (- n 1))))", "  (if (< n 3)\n      (if (= n 1) 0\n          1)\n      (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))", "  (if (< n 3)\n      n\n  \
    \    (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond\n \
    \   [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib\
    \ (- n 1))\n        (fibfib (- n 2))\n        (fibfib (- n 3)))]))\n", "  (if\
    \ (< n 2)\n      0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (define (fibfib-tail n)\n \
    \   (if (< n 3)\n        n\n        (+ (fibfib-tail (- n 1))\n           (fibfib-tail\
    \ (- n 2))\n           (fibfib-tail (- n 3)))))\n  (if (= n 0)\n      0\n    \
    \  (fibfib-tail (+ n 1))))", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(=\
    \ n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (cond [(equal? n 0) 0]\n        [(equal? n 1) 0]\n        [(equal? n 2) 1]\n\
    \        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", " \
    \ (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(zero?\
    \ n) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib (- n 1))\n\
    \        (fibfib (- n 2))\n        (fibfib (- n 3)))]))\n", "  (cond [(= n 0)\
    \ 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n  \
    \  [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))\n</code>\nThis algorithm is infeasible because of the exponential\
    \ time complexity. What's a more efficient algorithm to accomplish this task?\n\
    \n\nA:\n\nYou can use memoization here. In this case it's a bit tricky, because\
    \ you need to keep a cache that stores the result for 3 adjacent numbers. You\
    \ have to use a function for this, since locally declared identifiers cannot be\
    \ mutated.\n<code>(define (fibfib n)\n  (define (fibfib n cache)\n    (if (or\
    \ (= n 0) (= n 1))\n        0\n        (let ([n (modulo n 3)])\n          (if\
    \ (= n 0)\n              (if (vector-ref cache 0)\n                  (vector-ref\
    \ cache 0)\n                  (let ([r (+ (vector-ref cache 1)\n             \
    \                 (vector-ref cache 2)\n                              0)])\n \
    \                   (vector-set! cache 0 r)\n                    r))\n       \
    \       (if (= n 1)\n                  (if (vector-ref cache 1)\n            \
    \          (vector-ref cache 1)\n                      (let ([r (+ (vector-ref\
    \ cache 2)\n                                  (vector-ref cache 0)\n         \
    \                         1)])\n                        (vector-set! cache 1 r)\n\
    \                        r))\n                  (if (vector-ref cache 2)\n   \
    \                   (vector-ref cache 2)\n                      (let ([r (+ (vector-ref\
    \ cache 0)\n                                  (vector-ref cache 1)\n         \
    \                         1)])\n                        (vector-set! cache 2 r)\n\
    \                        r)))))))\n  (fibfib n (vector 0 0 0)))\n</code>\nThis\
    \ yields the expected results:\n<code>(fibfib 5)\n=&gt; 1", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (define (helper a b c n)\n    (if (zero?\
    \ n) a\n        (helper b c (+ a b c) (- n 1))))\n  (helper 0 0 1 n))\n", "  (define\
    \ fib\n    (letrec ([fib (lambda (n)\n               (cond\n                 [(=\
    \ n 0) 0]\n                 [(= n 1) 0]\n                 [(= n 2) 1]\n      \
    \           [else (+ (fib (- n 1)) (fib (- n 2)) (fib (- n 3)))]))])\n      fib))\n\
    \  (fib n))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else\n     (+ (fibfib (- n 1))\n        (fibfib (- n 2))\n        (fibfib\
    \ (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2)\
    \ 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (if (< n 3)\n      (if (= n 0)\n          0\n          1)\n      (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond\n    [(= n 0) 0]\n \
    \   [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))\n", "  (define (iter i a b c)\n    (cond ((&gt; i n) b)\n\
    \          (else (iter (+ i 1) (+ a b c) a b))))\n  (iter 3 0 0 1))\n", "  (cond\
    \ ((< n 3) n)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3))))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n\
    \        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", " \
    \ (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3)))]))\n", "  (letrec ([fibfib-helper (lambda (n a b c)\n                 \
    \           (cond [(= n 0) a]\n                                  [(= n 1) b]\n\
    \                                  [(= n 2) c]\n                             \
    \     [else (fibfib-helper (- n 1) b c (+ a b c))]))])\n    (fibfib-helper n 0\
    \ 0 1)))\n", "  (define (go n f0 f1 f2)\n    (cond\n      [(= n 0) f0]\n     \
    \ [(= n 1) f1]\n      [(= n 2) f2]\n      [else (go (- n 1) f1 f2 (+ f0 f1 f2))]))\n\
    \  (go n 0 0 1))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n\
    \ 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (define (helper n a b c count)\n    (cond ((=\
    \ count n) c)\n          (else (helper n b c (+ a b c) (+ count 1)))))\n  (helper\
    \ n 0 0 1 0))\n", "  (if (< n 3)\n      (if (= n 1) 0\n        1)\n      (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (fibfib-iter 0 1 0 1 n))\n",
  "  (define (aux n acc1 acc2 acc3)\n    (if (= n 1) acc1\n        (if (= n 2) acc2\n\
    \            (if (= n 3) acc3\n                (aux (- n 1) acc2 acc3 (+ acc1\
    \ acc2 acc3))))))\n  (aux n 0 0 1))\n", "  (define (fibfib-iter i a b c)\n   \
    \ (cond [(= i n) a]\n          [else (fibfib-iter (+ i 1) b c (+ a b c))]))\n\
    \  (fibfib-iter 0 0 0 1))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n   \
    \ [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\
    </code>\nWhen I try to run this code I get an error saying:\n<code>out of memory;\n\
    \ cannot allocate 4 bytes\n  in the space 0\n   allocation ended at ...\n</code>\n\
    I have included the rest of the error below, but I don't understand what this\
    \ error means.\nMy question is: why do I get this error and how can I fix it?\n\
    Thanks in advance.\n<code>&gt; (fibfib 10)\nstandard-module-name-resolver: collection\
    \ not found\n  collection: \"sicp\"\n  in collection directories:\n   /usr/share/racket/collects\n\
    \   /home/ben/.racket/6.1/collects\n   /usr/local/share/racket/collects\n  context...:\n\
    \   standard-module-name-resolver\n   standard-module-name-resolver\n   standard-module-name-resolver\n\
    \   find-collection-path-w/compilation\n   find-collection-path\n   resolve-collection-path\n\
    \   standard-module-name-resolver\n   resolve-imported-module-path\n   resolve-module-path-lookup-mode/checked\n\
    \   resolve-module-path-lookup-mode\n   resolve-module-path-extend-lookup-chain\n\
    \   resolve-module-path-lookup-mode/checked\n   resolve-module-path-lookup-mode\n\
    \   resolve-module-path-extend-lookup-chain\n   resolve-module-path-lookup-mode/checked\n\
    \   resolve-module-path-lookup-mode\n   resolve-module-path-extend-lookup-chain\n\
    \   resolve-module-path-lookup-mode/checked\n   resolve-module-path-lookup-mode\n\
    \   resolve-module-path-extend-lookup-chain\n   resolve-module-path-lookup-mode/checked\n\
    \   resolve-module-path-lookup-mode\n  ", "  (cond\n    [(= n 0) 0]\n    [(= n\
    \ 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (let loop ([n n] [fib-2 0] [fib-1 0] [fib 0])\n    (cond\n\
    \      [(= n 0) fib-2]\n      [(= n 1) fib-1]\n      [(= n 2) fib]\n      [else\
    \ (loop (- n 1) fib-1 fib (+ fib-2 fib-1 fib))])))\n", "  (define (fibfib-iter\
    \ n a b c)\n    (cond ((= n 0) a)\n          ((= n 1) b)\n          ((= n 2) c)\n\
    \          (else (fibfib-iter (- n 1) b c (+ a b c)))))\n  (fibfib-iter n 0 0\
    \ 1))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if (< n 3)\n\
    \      n\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n         (fibfib\
    \ (- n 3)))))\n", "  (define (fibfib-iter a b c n)\n    (if (zero? n)\n      \
    \  a\n        (fibfib-iter b c (+ c b a) (- n 1))))\n  (fibfib-iter 0 0 1 n))",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n</code>\n", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n</code>\nIs there a better way?\n\n\nA:\n\nThere\
    \ is a better way.  Just expand the definition of <code>fibfib</code> up to <code>n</code>.\
    \  If you need help, the sequence starts\n<code> 0, 0, 1, 1, 2, 4, 7, 13, 24,\
    \ 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415,\
    \ 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425,\
    \ 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103\n\
    </code>\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n \
    \       (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", " \
    \ (if (&lt; n 3)\n      n\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))))\n", "  (if (or (or (= n 0) (= n 1)) (= n 2))\n      (if (= n 2)\
    \ 1 0)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n</code>\n\
    Haven't been able to get the memoization to work, but I'm hoping I can get a review\
    \ of my code as is. I'm more interested in learning correct Racket style, but\
    \ I'm open to any comments.\n\n\nA:\n\nYour code is easy to read, and it is quite\
    \ clear what it does. \nHowever, it is not very efficient. First, you calculate\
    \ <code>fibfib(n-1)</code>, <code>fibfib(n-2)</code> and <code>fibfib(n-3)</code>\
    \ three times, which is a waste. Second, the recursion depth is too large, it\
    \ is approximately 3^n. If you want to calculate <code>fibfib(100)</code>, the\
    \ recursion depth will be approximately 1.3 * 10^30. \nYou can easily improve\
    \ the first issue by using named <code>let</code>:\n<code>(define (fibfib n)\n\
    \  (let loop ((n n) (x1 0) (x2 0) (x3 1))\n    (cond ((= n 0) x1)\n          ((=\
    \ n 1) x2)\n          ((= n 2) x3)\n          (else (loop (- n 1) x2 x3 (+ x1\
    \ x2 x3))))))\n</code>\nThe second issue can be addressed by memoization:\n<code>(define\
    \ (fibfib n)\n  (define (fibfib/memo n)\n    (if (= n 0) 0\n        (if (= n 1)\
    \ 0\n            (if (= n 2) 1\n                (+ (fibfib/memo (- n 1))\n   \
    \                (fibfib/memo (- n 2))\n                   (fibfib/memo (- n 3)))))))\n\
    \  (let loop ((n n) (memo (list 0 0 1)))\n    (cond ((= n 0) (car memo))\n   \
    \       ((= n 1) (c", "  (cond\n    [(< n 2) 0]\n    [(= n 2) 1]\n    [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (match n\n   \
    \ [(= 0) 0]\n    [(= 1) 0]\n    [(= 2) 1]\n    [(= 3) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (let loop ([prev-prev-prev 0] [prev-prev 0]\
    \ [prev 1] [i 0])\n    (cond\n      [(= i n) prev-prev-prev]\n      [else (loop\
    \ prev prev (+ prev-prev-prev prev-prev) (+ i 1))])))\n", "  (cond\n    [(= n\
    \ 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n\
    \        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n</code>\n\
    I'm trying to write a more efficient version, but need help:\n<code>#lang racket\n",
  "  (if (< n 3)\n      (if (= n 0)\n          0\n          1)\n      (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (if (or (= n 0) (= n 1))\n\
    \      0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (if (or (= n 0) (= n 1))\n      0\n   \
    \   (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))\n", "  (define fibs (list 0 0 1))\n  (for ([i 3] #:until (>= i\
    \ n))\n    (set! fibs (cons (+ (list-ref fibs 0) (list-ref fibs 1) (list-ref fibs\
    \ 2)) fibs))\n    (set! fibs (rest fibs)))\n  (list-ref fibs 0))\n", "  (cond\
    \ [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define (fibfib-inner\
    \ current next-next-next next-next n)\n    (cond\n      [(zero? n) current]\n\
    \      [else (fibfib-inner next-next-next next next-next (- n 1))]))\n  (fibfib-inner\
    \ 0 0 1 2))\n", "  (if (< n 3)\n      (if (= n 0)\n          0\n          1)\n\
    \      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond ((<\
    \ n 2) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3))))))\n```\n\n```scheme", "  (cond [(= n 0) 0]\n        [(=\
    \ n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n  \
    \  [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\
    </code>\nThis is fine, but I'd like to understand how to do it efficiently.\n\
    I'm familiar with the fibonacci sequence algorithm, which I can easily translate\
    \ to fibfib, but I'm having a hard time wrapping my head around the algorithm\
    \ in general.\nI suppose I need to know how to prove that the fibfib algorithm\
    \ is correct, and I think I need to understand how to use recursion as a way to\
    \ cut down on the number of iterations, but I don't understand how to do either\
    \ one of those.\nAny help would be appreciated!\n\n\nA:\n\nYou've got the correct\
    \ code, but you've got your recursion the wrong way around. The following gives\
    \ the answer in a reasonable amount of time:\n<code>(define (fibfib n)\n  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n\
    \ 3)) (fibfib (- n 2)) (fibfib (- n 1)))]))\n</code>\nWhy? Consider a simple case.\
    \ We are told that <code>fibfib</code> can be computed in terms of the 3 previous\
    \ numbers. If <code>fibfib(5)</code> is computed as <code>(fibfib(2) + fibfib(3)\
    \ + fibfib(4))</code>, then the last 3 terms each require 3 recursive calls, so\
    \ we have 9 altogether. But if we compute it as <code>(fibfib(4) + fibfib(3) +\
    \ fibfib(2))</code>, then each term only requires 2 recursive calls, so we have\
    \ 6 altogether. It's this difference in the number of recursive calls that gives\
    \ the correct function a chance of running in a reasonable amount of time.\n",
  "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond ((= n 0)\
    \ 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond ((= n 0) 0)\n       \
    \ ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (let ([fibfib-helper (make-hash)]\n   \
    \     [table (make-hash)])\n    (letrec ([fibfib-helper-fn (lambda (n)\n     \
    \                            (if (hash-has-key? table n)\n                   \
    \                  (hash-ref table n)\n                                     (let\
    \ ([res (+ (fibfib-helper-fn (- n 1))\n                                      \
    \             (fibfib-helper-fn (- n 2))\n                                   \
    \                (fibfib-helper-fn (- n 3)))])\n                             \
    \          (hash-set! table n res)\n                                       res)))])\n\
    \      (lambda (n)\n        (hash-ref fibfib-helper n (lambda ()\n           \
    \                         (hash-set! fibfib-helper n (fibfib-helper-fn n))\n \
    \                                   (hash-ref fibfib-helper n)))))))\n", "  (cond\
    \ [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else\n     \
    \    (+ (fibfib (- n 1))\n            (fibfib (- n 2))\n            (fibfib (-\
    \ n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (let\
    \ loop ([n (- n 1)] [s0 0] [s1 0] [s2 1])\n    (if (= n 0)\n        s0\n     \
    \   (loop (- n 1) s2 s1 (+ s0 s1 s2)))))\n", "  (define (fib n)\n    (if (< n\
    \ 2)\n        n\n        (+ (fib (- n 1)) (fib (- n 2)))))\n  (fib (- n 2)))\n",
  "  (if (or (= n 0) (= n 1))\n      0\n      (if (= n 2)\n          1\n         \
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (fibfib/r 0\
    \ 1 1 n))\n", "  (if (< n 3)\n      n\n      (+ (fibfib (- n 1))\n         (fibfib\
    \ (- n 2))\n         (fibfib (- n 3)))))\n", "  (define (f x y z n)\n    (if (=\
    \ n 0) x\n        (f y z (+ y z x) (- n 1))))\n  (f 0 0 1 n))\n", "  (let loop\
    \ ([n n] [a 2] [b 1] [c 0])\n    (if (= n 0)\n        c\n        (loop (- n 1)\
    \ (+ a b c) a b))))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((=\
    \ n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if (= n 0)\n\
    \      0\n      (if (= n 1)\n          0\n          (if (= n 2)\n            \
    \  1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n",
  "  (define (fibfib-iter c n)\n    (cond ((= c n) n)\n          ((= n 1) 0)\n   \
    \       ((= n 2) 1)\n          (else (+ (fibfib-iter (- c 1) n)\n            \
    \       (fibfib-iter (- c 2) n)\n                   (fibfib-iter (- c 3) n)))))\n\
    \  (fibfib-iter n n))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(=\
    \ n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))",
  "  (cond\n    [(zero? n) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n</code>\nwhich would work, but\
    \ would blow up my stack.\nAny ideas on how to do this?\n\n\nA:\n\nI think it\
    \ can be done using a modified version of the method used to efficiently calculate\
    \ Fibonacci numbers. Here's a solution implemented in Python:\n<code>def matpow(mat,\
    \ n):\n    res = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    while n:\n        if n\
    \ &amp; 1:\n            res = matmul(res, mat)\n        mat = matmul(mat, mat)\n\
    \        n &gt;&gt;= 1\n    return res\n\ndef matmul(a, b):\n    return [[sum(x\
    \ * y for x, y in zip(row, col)) for col in zip(*b)] for row in a]\n\ndef fibfib(n):\n\
    \    A = [[1, 1, 1], [1, 0, 0], [0, 1, 0]]\n    if n &lt;= 2:\n        return\
    \ n - 1\n    return matpow(A, n - 2)[0][0]\n</code>\n", "  (cond\n    [(= n 0)\
    \ 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= n 2) 1]\n    [else\n     (+ (fibfib (- n 1))\n        (fibfib (- n 2))\n\
    \        (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3)))]))\n", "  (define (fibfib-iter n a b c)\n    (cond\n      [(= n 0) a]\n\
    \      [(= n 1) b]\n      [(= n 2) c]\n      [else (fibfib-iter (- n 1) b c (+\
    \ a b c))]))\n  (fibfib-iter n 0 0 1))\n", "  (define (fibfib-aux n)\n    (if\
    \ (= n 0)\n        0\n        (if (= n 1)\n            0\n            (if (= n\
    \ 2)\n                1\n                (+ (fibfib-aux (- n 1)) (fibfib-aux (-\
    \ n 2)) (fibfib-aux (- n 3)))))))\n  (if (&lt; n 0)\n      (/ (fibfib-aux (+ n\
    \ 1)) 2)\n      (fibfib-aux n)))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (let ([seq (list 0 0 1)])\n    (for ([i (in-range 3 n)])\n\
    \      (set! seq (append seq (list (+ (seq i) (seq (- i 1)) (seq (- i 2)))))))\n\
    \    (seq (- n 1))))\n", "  (define (fibfib-iter counter current next)\n    (if\
    \ (&gt;= counter n)\n        current\n        (fibfib-iter (+ counter 1) next\
    \ (+ current next (* (- current 1) (- next 1))))))\n  (if (&lt; n 3)\n      (if\
    \ (= n 0)\n          0\n          1)\n      (fibfib-iter 3 1 0)))\n</code>\nI'm\
    \ trying to optimize the above code, if possible. My main concern are these functions:\
    \ <code>&gt;=</code>, <code>if</code>, <code>+</code>, <code>*</code>, <code>-</code>.\
    \ I'm wondering whether it's possible to reduce the number of times the above\
    \ functions are used by introducing local variables (e.g. <code>a</code>, <code>b</code>,\
    \ <code>c</code> for the values <code>current</code>, <code>next</code>, <code>next\
    \ + current + (current - 1)*(next - 1)</code> respectively).\n\n\nA:\n\nNotice\
    \ that the last two equations are\n<code>x(n) = x(n-1) + x(n-2) + x(n-3)\ny(n)\
    \ = y(n-1) + y(n-2) + y(n-3)\n</code>\nThis is an example of a system of linear\
    \ recurrence relations with constant coefficients, so what we can do is rewrite\
    \ them as\n<code>x(n) - x(n-1) - x(n-2) = -y(n-3)\ny(n) - y(n-1) - y(n-2) = -x(n-3)\n\
    </code>\nWe can then rewrite the system into a matrix equation of the form\n<code>|x(n)|\
    \ = A |x(n-1)|\n|y(n)|       |y(n-1)|\n</code>\nWhere the matrix <code>A</code>\
    \ contains the coefficients. So here\n<code>A = | -1  -1  0 |\n    |  0  -1 -1\
    \ |\n</code>\nSo we can conclude that <code>|x(n)|", "  (define (f n k n1 n2 n3)\n\
    \    (if (= n k)\n        n3\n        (f n (+ k 1) n2 n3 (+ n2 n3 n1))))\n  (f\
    \ n 0 0 0 1))\n", "  (cond [(equal? n 0) 0]\n        [(equal? n 1) 0]\n      \
    \  [(equal? n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n</code>\nThe program is working correctly (computes the correct\
    \ answer), but is very slow. I'm guessing that this is because of the recursive\
    \ function call. Is there a way to write this function to avoid recursion?\n\n\
    \nA:\n\nWithout going into the details of what the fibfib function is doing, here\
    \ is the formula for finding the nth fibfib number:\n<code>(define (fibfib n)\n\
    \    (define one '(1 0 0))\n    (define two '(0 1 0))\n    (define three '(0 0\
    \ 1))\n    (define (nth-m n m)\n      (if (= n 0)\n          one\n          (let*\
    \ ((m-sq (matrix-mul m m))\n                 (m-cub (matrix-mul m-sq m))\n   \
    \              (a (matrix-mul m-cub (list one two three))))\n            (nth-m\
    \ (- n 1) a))))\n    (nth-m n (list one two three)))\n</code>\nThe <code>nth-m</code>\
    \ procedure computes <code>M^n</code> using fast exponentiation. <code>M</code>\
    \ is the 3x3 matrix representing the transformation of the state vector, so <code>M^n</code>\
    \ is the nth iteration of the transformation.\n", "  (cond ((= n 0) 0)\n     \
    \   ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (if (< n 2)\n      0\n      (if (= n 2)\n\
    \          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else\n\
    \         (+ (fibfib (- n 1))\n            (fibfib (- n 2))\n            (fibfib\
    \ (- n 3)))]))\n", "  (define (fibfib-helper n x y z)\n    (cond [(= n 0) x]\n\
    \          [(= n 1) y]\n          [(= n 2) z]\n          [else (fibfib-helper\
    \ (- n 1) y z (+ x y z))]))\n  (fibfib-helper n 0 0 1))\n", "  (if (&lt; n 3)\
    \ (if (= n 2) 1 0)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n\
    </code>\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n \
    \       (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (letrec ([a 0]\n           [b 0]\n         \
    \  [c 1]\n           [next-fibfib (lambda (n)\n                          (cond\n\
    \                            [(zero? n) a]\n                            [(one?\
    \ n) b]\n                            [(two? n) c]\n                          \
    \  [else (begin\n                                    (set! a b)\n            \
    \                        (set! b c)\n                                    (set!\
    \ c (+ a b c))\n                                    (next-fibfib (- n 1)))\n \
    \                           ]))])\n    (next-fibfib n)))\n", "  (cond [(= n 0)\
    \ 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else\n         (+ (fibfib\
    \ (- n 1))\n            (fibfib (- n 2))\n            (fibfib (- n 3)))]))\n</code>\n\
    What I've done is simply make a recursive call, but I am sure that this is not\
    \ the way to go. \nI came across a similar function written in Ruby, here is the\
    \ link: FibFib\nwhich seems much more efficient.\nThe problem is that I don't\
    \ understand what's happening. \nCould you help me understand what's going on,\
    \ and how I could write this function in Racket?\n\n\nA:\n\n<code>fibfib</code>\
    \ is just another name for the \"tribonacci\" number sequence; I'm sure they have\
    \ a more correct and concise name, but I don't know it.\nIn any case, the same\
    \ optimizations apply to this sequence as to the Fibonacci sequence: store the\
    \ previous values in a list, and keep adding them up. (For both sequences, this\
    \ results in a linear time algorithm.)\n", "  (cond\n    [(= n 0) 0]\n    [(=\
    \ n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n</code>\nLet's compile it.\n<code>Compiling /home/jack/Documents/stack_overflow/fibfib.rkt\n\
    warning: possibly unbound variable in module in: fibfib\nwarning: possibly unbound\
    \ variable in module in: fibfib\nwarning: possibly unbound variable in module\
    \ in: fibfib\n</code>\nWell, we were expecting the warning. This is the result\
    \ of the lazy compiler. Let's try running it.\n<code>racket@racket:/home/jack/Documents/stack_overflow$\
    \ racket fibfib.rkt\nracket@racket:/home/jack/Documents/stack_overflow$\n</code>\n\
    It doesn't work as expected. I know that I could use a let block and define the\
    \ fibfibs, but I would like to get rid of the warnings.\nI'm still new to Racket,\
    \ so I might have missed something that could solve this. I just can't find the\
    \ correct syntax to remove the warnings.\nEdit:\nI had assumed that fibfib is\
    \ defined in the global scope. It seems that it isn't, however. This means that\
    \ the compiler is complaining about fibfib being used before it's defined, which\
    \ is understandable.\nI found a workaround by using a macro, but I'll leave the\
    \ question open in case there's a better way.\n\n\nA:\n\nIf you want a function,\
    \ you can get rid of the warnings by changing the first two cases to a let form:\n\
    <code>(define (fibfib n)\n  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n\
    \ 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\
    </code>\nbecomes\n<code>(define (fibfib n)\n  (let ([fibfib (lambda (n)\n    \
    \              (cond\n                    [(= n", "  (define (helper num1 num2\
    \ num3 counter)\n    (if (= counter n)\n        (+ num1 num2 num3)\n        (helper\
    \ num2 num3 (+ num1 num2 num3) (+ counter 1))))\n  (if (< n 3)\n      n\n    \
    \  (helper 0 0 1 3)))\n", "  (let ([fibfib-helper (lambda (n acc1 acc2 acc3)\n\
    \                         (if (= n 0)\n                             acc1\n   \
    \                          (fibfib-helper (- n 1) acc2 acc3 (+ acc1 acc2 acc3))))])\n\
    \    (fibfib-helper n 0 0 1)))\n", "  (define (fibfib-helper n f1 f2 f3)\n   \
    \ (cond ((= n 0) f1)\n          ((= n 1) f2)\n          ((= n 2) f3)\n       \
    \   (else (fibfib-helper (- n 1) f2 f3 (+ f1 f2 f3)))))\n  (fibfib-helper n 0\
    \ 0 1))\n</code>\nThis code works fine when I run it with <code>racket</code>,\
    \ but when I run <code>raco test</code> on it I get the following errors:\n<code>raco\
    \ test ch-02-q-03.rkt\n\nFAILURE:\n\nch-02-q-03.rkt:4:3:\n  Expected: 5\n  Actual:\
    \ 7\n\nFAILURE:\n\nch-02-q-03.rkt:4:3:\n  Expected: 13\n  Actual: 21\n\nFAILURE:\n\
    \nch-02-q-03.rkt:4:3:\n  Expected: 34\n  Actual: 55\n\nFAILURE:\n\nch-02-q-03.rkt:4:3:\n\
    \  Expected: 89\n  Actual: 144\n\nFAILURE:\n\nch-02-q-03.rkt:4:3:\n  Expected:\
    \ 233\n  Actual: 377\n\nFAILURE:\n\nch-02-q-03.rkt:4:3:\n  Expected: 610\n  Actual:\
    \ 987\n\nFAILURE:\n\nch-02-q-03.rkt:4:3:\n  Expected: 1597\n  Actual: 2584\n\n\
    FAILURE:\n\nch-02-q-03.rkt:4:3:\n  Expected: 4181\n  Actual: 6765\n\nFAILURE:\n\
    \nch-02-q-03.rkt:4:3:\n  Expected: 10946\n  Actual: 17711\n\nFAILURE:\n\nch-02-q-03.rkt:4:3:\n\
    \  Expected: 28657\n  Actual: 46368\n\nFAILURE:\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (let iter ([n n] [a 0] [b 0] [c 1])\n    (cond\
    \ [(= n 0) a]\n          [(= n 1) b]\n          [(= n 2) c]\n          [else (iter\
    \ (- n 1) b c (+ b c))])))\n", "  (if (< n 3)\n      n\n      (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond\n    [(= n 0) 0]\n   \
    \ [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))\n", "  (define (fibfib-seq n)\n    (cond\n      [(= n 0)\
    \ '(0)]\n      [(= n 1) '(0)]\n      [(= n 2) '(1)]\n      [else (cons (+ (car\
    \ seq) (cadr seq) (caddr seq)) seq)]))\n  (car (fibfib-seq n)))\n", "  (define\
    \ (f n)\n    (cond ((< n 3) (if (= n 1) 0 1))\n          (else (+ (f (- n 1))\
    \ (f (- n 2)) (f (- n 3))))))\n  (f n))\n", "  (cond ((= n 0) 0)\n        ((=\
    \ n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n  \
    \  [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (let ((a 0) (b 0) (c 1))\n\
    \    (define (fibfib-helper n a b c)\n      (cond ((= n 0) a)\n            ((=\
    \ n 1) b)\n            ((= n 2) c)\n            (else (fibfib-helper (- n 1) b\
    \ c (+ a b c)))))\n    (fibfib-helper n a b c)))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (if (< n 2)\n      0\n      (if (< n 3)\n  \
    \        1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n</code>\nand for the\
    \ bonus point:\n<code>#lang racket\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1)\
    \ 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib (- n 1))\n        (fibfib (-\
    \ n 2))\n        (fibfib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n\
    \ 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3))))))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n       \
    \ ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3))))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n\
    \        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", " \
    \ (if (< n 3)\n      (if (= n 1) 0\n          1)\n      (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2)\
    \ 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (fibfib-helper\
    \ n 0 1 0 1))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else\n     (+ (fibfib (- n 1))\n        (fibfib (- n 2))\n        (fibfib\
    \ (- n 3)))]))\n", "  (define (fibfib-helper a b c n)\n    (if (= n 0) a\n   \
    \     (fibfib-helper b c (+ a b c) (- n 1))))\n  (fibfib-helper 0 0 1 n))\n",
  "  (define (fibfib-iter n a b c)\n    (cond\n      [(= n 0) a]\n      [(= n 1) b]\n\
    \      [(= n 2) c]\n      [else (fibfib-iter (- n 1) b c (+ a b c))]))\n  (fibfib-iter\
    \ n 0 0 1))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n\
    \        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", " \
    \ (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (define (fibfib-help a b c n)\n    (if\
    \ (zero? n)\n        0\n        (if (zero? (sub1 n))\n            0\n        \
    \    (if (zero? (sub1 (sub1 n)))\n                1\n                (fibfib-help\
    \ b c (+ a b c) (sub1 n))))))\n  (fibfib-help 0 0 1 n))", "  (cond ((= n 0) 0)\n\
    \        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n</code>\n", "  (define (fibfib- n-1 n-2 n-3)\n\
    \    (cond [(= n 0) n-3]\n          [(= n 1) n-2]\n          [(= n 2) n-1]\n \
    \         [else (fibfib- (+ n-1 n-2 n-3) n-1 n-2)]))\n  (fibfib- 1 0 0))\n", " \
    \ (define (helper n last-last-last last-last last)\n    (cond ((= n 0) 0)\n  \
    \        ((= n 1) 0)\n          ((= n 2) 1)\n          (else (helper (- n 1) last-last\
    \ last (+ last-last-last last-last last)))))\n  (helper n 0 0 1))\n", "  (cond\
    \ [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else\n     \
    \    (+ (fibfib (- n 1))\n            (fibfib (- n 2))\n            (fibfib (-\
    \ n 3)))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n\
    \        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", " \
    \ (letrec ([f (lambda (n)\n                (cond [(= n 0) 0]\n               \
    \       [(= n 1) 0]\n                      [(= n 2) 1]\n                     \
    \ [else (+ (f (- n 1)) (f (- n 2)) (f (- n 3)))]))])\n    (f n)))\n", "  (if (or\
    \ (= n 0) (= n 1))\n      0\n      (if (= n 2)\n          1\n          (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (if (< n 3)\n      (-\
    \ n 1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+\
    \ (fibfib (- n 1))\n        (fibfib (- n 2))\n        (fibfib (- n 3)))]))\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if (or (equal?\
    \ n 0) (equal? n 1))\n      0\n      (if (equal? n 2)\n          1\n         \
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(= n\
    \ 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if (< n 2)\n      0\n  \
    \    (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3))))))\n", "  (if (&lt; n 3)\n      (if (zero? n) 0\n        \
    \  1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n</code>\n\
    I'd like to note that, while I'm aware this is a recursive algorithm, I'm not\
    \ sure how to make it tail-recursive.\nI'm new to Racket, so any help would be\
    \ appreciated.\n\n\nA:\n\nThe only difficulty in making this tail-recursive is\
    \ in dealing with the <code>if</code> expression.\nI usually write <code>if</code>\
    \ as <code>cond</code> and use a <code>let</code> to deal with the extra argument:\n\
    <code>(define (fibfib n)\n  (let f ([n n])\n    (cond [(&lt; n 3) (if (zero? n)\
    \ 0 1)]\n          [else (+ (f (- n 1)) (f (- n 2)) (f (- n 3)))])))\n</code>\n\
    I'd like to note that, while I'm aware this is a recursive algorithm, I'm not\
    \ sure how to make it tail-recursive.\nAnother option is to take the <code>fibfib</code>\
    \ function, and just change the call to itself to a call to an accumulator function:\n\
    <code>(define (fibfib n)\n  (let f ([n n] [a 0] [b 0] [c 1])\n    (cond [(&lt;\
    \ n 3) (if (zero? n) a b)]\n          [else (f (- n 1) (+ a b c) a b)])))\n</code>\n",
  "  (define (inner n)\n    (cond ((= n 0) 0)\n          ((= n 1) 0)\n          ((=\
    \ n 2) 1)\n          (else (+ (inner (- n 1)) (inner (- n 2)) (inner (- n 3))))))\n\
    \  (inner n))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2)\
    \ 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else\n\
    \         (+ (fibfib (- n 1))\n            (fibfib (- n 2))\n            (fibfib\
    \ (- n 3)))]))\n", "  (if (= n 0)\n      0\n      (if (= n 1)\n          0\n \
    \         (if (= n 2)\n              1\n              (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))))))\n", "  (define (iter n a b c)\n    (cond\n  \
    \    [(= n 0) a]\n      [(= n 1) b]\n      [(= n 2) c]\n      [else (iter (- n\
    \ 1) b c (+ a b c))]))\n  (iter n 0 0 1))\n\n", "  (cond\n    [(= n 0) 0]\n  \
    \  [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib (- n 1))\n       \
    \ (fibfib (- n 2))\n        (fibfib (- n 3)))]))\n", "  (define (recursive-fibfib\
    \ n)\n    (cond\n      [(= n 0) 0]\n      [(= n 1) 0]\n      [(= n 2) 1]\n   \
    \   [else (+ (recursive-fibfib (- n 1)) (recursive-fibfib (- n 2)) (recursive-fibfib\
    \ (- n 3)))]))\n  (recursive-fibfib n))\n", "  (cond ((= n 0) 0)\n        ((=\
    \ n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3))))))", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n     \
    \   ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3))))))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n\
    \        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))", " \
    \ (if (< n 2)\n      0\n      (if (= n 2)\n          1\n          (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))", "  (define base-case-seq '(0 0\
    \ 1))\n  (if (eq? n 0)\n      (list-ref base-case-seq 0)\n      (if (eq? n 1)\n\
    \          (list-ref base-case-seq 1)\n          (if (eq? n 2)\n             \
    \ (list-ref base-case-seq 2)\n              (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))))))\n", "  (let iter ([n n] [n-1 0] [n-2 0] [n-3 0])\n   \
    \ (cond\n      [(= n 0) n-3]\n      [(= n 1) n-2]\n      [(= n 2) n-1]\n     \
    \ [else (iter (- n 1) (+ n-1 n-2 n-3) n-1 n-2)])))\n", "  (cond\n    [(= n 0)\
    \ 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (match n\n    [0 0]\n    [1 0]\n    [2\
    \ 1]\n    [n (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", " \
    \ (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(= n 0)\
    \ 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))", "  (define (aux n a b c)\n    (if\
    \ (= n 0) a\n        (if (= n 1) b\n            (if (= n 2) c\n              \
    \  (aux (- n 1) b c (+ a b c))))))\n  (aux n 0 0 1))\n", "  (cond ((= n 0) 0)\n\
    \        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3)))]))\n</code>\nThis is the fastest code I have written so far. I have tried\
    \ to optimize it.\n\n\nA:\n\nYour code is absolutely correct: because the function\
    \ <code>fibfib</code> is called many times with the same argument, then calling\
    \ it again will be faster than before (given that the program is runnning in the\
    \ same Racket session), so you are actually caching the results.\n", "  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib\
    \ (- n 1))\n        (fibfib (- n 2))\n        (fibfib (- n 3)))]))\n", "  (if\
    \ (or (equal? n 0) (equal? n 1))\n      0\n      (if (equal? n 2)\n          1\n\
    \          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (define\
    \ (fibfib-iter n1 n2 n3 count)\n    (if (= count n)\n        (+ n1 n2 n3)\n  \
    \      (fibfib-iter n2 n3 (+ n1 n2 n3) (+ count 1))))\n  (fibfib-iter 0 0 1 0))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))", "  (cond [(= n 0) 0]\n    \
    \    [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (define (fibfib-rec p pp ppp res)\n   \
    \ (if (= p n)\n        res\n        (fibfib-rec (+ p 1) p pp (+ res p pp ppp))))\n\
    \  (fibfib-rec 2 1 0 1))\n", "  (define (helper n a b c)\n    (if (= n 0)\n  \
    \      a\n        (helper (- n 1) b c (+ a b c))))\n  (helper n 0 0 1))\n", " \
    \ (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\n", "  (cond ((= n\
    \ 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (let loop ([n n] [a 0] [b\
    \ 0] [c 1])\n    (cond [(= n 0) a]\n          [(= n 1) b]\n          [(= n 2)\
    \ c]\n          [else (loop (- n 1) b c (+ a b c))])))\n", "  (define (f n-1 n-2\
    \ n-3)\n    (cond\n      [(= n 0) 0]\n      [(= n 1) 0]\n      [(= n 2) 1]\n \
    \     [else (+ n-1 n-2 n-3)]))\n  (define (fibfib-helper n a b c)\n    (cond\n\
    \      [(= n 0) 0]\n      [(= n 1) 0]\n      [(= n 2) 1]\n      [else (fibfib-helper\
    \ (- n 1) (+ a b c) a b)]))\n  (fibfib-helper n 1 0 0))\n", "  (if (or (= n 0)\
    \ (= n 1))\n      0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n  \
    \  [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n       \
    \ ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3))))))\n", "  (fibfib-iter n 0 1 0))\n", "  (if (< n 2)\n      0\n      (if\
    \ (< n 3)\n          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define (aux n-1 n-2 n-3)\n\
    \    (cond\n      [(zero? n) 0]\n      [(zero? (sub1 n)) 0]\n      [(zero? (sub1\
    \ (sub1 n))) 1]\n      [else (+ n-1 n-2 n-3)]))\n  (define (aux-iter n n-1 n-2\
    \ n-3)\n    (cond\n      [(zero? n) n-1]\n      [else (aux-iter (sub1 n) n-1 n-2\
    \ n-3)]))\n  (aux-iter n 0 0 1))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n</code>\n", "  (define (next-fibfib n fib1 fib2 fib3)\n    (cond\
    \ ((= n 0) fib1)\n          ((= n 1) fib2)\n          ((= n 2) fib3)\n       \
    \   (else (next-fibfib (- n 1) fib2 fib3 (+ fib1 fib2 fib3)))))\n  (next-fibfib\
    \ n 0 0 1))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
