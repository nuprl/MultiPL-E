name: HumanEval_158_find_max
language: rkt
prompt: "#lang racket\n\n;; Write a function that accepts a list of strings.\n;; The\
  \ list contains different words. Return the word with maximum number\n;; of unique\
  \ characters. If multiple strings have maximum number of unique\n;; characters,\
  \ return the one which comes first in lexicographical order.\n(define (find_max\
  \ words)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_max))\n\
  \    (check-equal? (candidate (list \"name\" \"of\" \"string\")) \"string\")\n \
  \   (check-equal? (candidate (list \"name\" \"enam\" \"game\")) \"enam\")\n    (check-equal?\
  \ (candidate (list \"aaaaaaa\" \"bb\" \"cc\")) \"aaaaaaa\")\n    (check-equal? (candidate\
  \ (list \"abc\" \"cba\")) \"abc\")\n    (check-equal? (candidate (list \"play\"\
  \ \"this\" \"game\" \"of\" \"footbott\")) \"footbott\")\n    (check-equal? (candidate\
  \ (list \"we\" \"are\" \"gonna\" \"rock\")) \"gonna\")\n    (check-equal? (candidate\
  \ (list \"we\" \"are\" \"a\" \"mad\" \"nation\")) \"nation\")\n    (check-equal?\
  \ (candidate (list \"this\" \"is\" \"a\" \"prrk\")) \"this\")\n    (check-equal?\
  \ (candidate (list \"b\")) \"b\")\n    (check-equal? (candidate (list \"play\" \"\
  play\" \"play\")) \"play\")\n))\n\n(test-humaneval)"
completions: ["  (apply max words #:key (lambda (w) (apply + (remove-duplicates (string->list\
    \ w))))))\n", "  (define (find_max_helper lst)\n    (define (count_unique letters)\n\
    \      (define (count_unique_helper ltrs seen)\n        (cond\n          [(empty?\
    \ ltrs) (count seen)]\n          [(member? (first ltrs) seen) (count_unique_helper\
    \ (rest ltrs) seen)]\n          [else (count_unique_helper (rest ltrs) (cons (first\
    \ ltrs) seen))]))\n      (count_unique_helper letters '()))\n    (define (max_unique\
    \ lst-of-words)\n      (define (max_unique_helper wds max-word)\n        (cond\n\
    \          [(empty? wds) max-word]\n          [(< (count_unique (string->list\
    \ (first wds)))\n              (count_unique (string->list max-word)))\n     \
    \      (max_unique_helper (rest wds) max-word)]\n          [else (max_unique_helper\
    \ (rest wds) (first wds))]))\n      (max_unique_helper lst-of-words (first lst-of-words)))\n\
    \    (max_unique lst))\n  (find_max_helper words))\n", "  (first\n   (apply max\
    \ (map unique-chars words))))\n", "  (letrec\n      ((count-chars (lambda (str)\n\
    \                      (if (empty? str)\n                          empty\n   \
    \                       (cons (cons (car str)\n                              \
    \        (count (car str) (cdr str)))\n                                (count-chars\
    \ (filter (lambda (x) (not (equal? x (car str)))) (cdr str)))))))\n       (max-chars\
    \ (lambda (word-chars)\n                    (foldr max 0 (map length word-chars)))))\n\
    \    (let ((word-chars (map count-chars words)))\n      (car (filter (lambda (wc)\
    \ (= (max-chars wc) (max-chars word-chars)))\n                   word-chars)))))\n",
  "  (define (uniq-chars w)\n    (remove-duplicates (string->list w)))\n  (define\
    \ (eq-len w1 w2) (= (length (uniq-chars w1)) (length (uniq-chars w2))))\n  (define\
    \ (best-word-and-len words)\n    (define (best-word-and-len-acc words acc)\n \
    \     (if (null? words)\n          acc\n          (let ((new-word (car words))\n\
    \                (new-word-len (length (uniq-chars (car words)))))\n         \
    \   (if (&gt; new-word-len (cdr acc))\n                (best-word-and-len-acc\
    \ (cdr words) (cons new-word new-word-len))\n                (if (= new-word-len\
    \ (cdr acc))\n                    (let ((best-so-far (car acc)))\n           \
    \           (if (&lt; (string-ci&lt;=? best-so-far new-word) 0)\n            \
    \              (best-word-and-len-acc (cdr words) (cons new-word new-word-len))\n\
    \                          (best-word-and-len-acc (cdr words) acc)))\n       \
    \             (best-word-and-len-acc (cdr words) acc))))))\n    (best-word-and-len-acc\
    \ words (cons (car words) (length (uniq-chars (car words))))))\n  (car (best-word-and-len\
    \ words)))\n</code>\nAn example with a test driver:\n<code>#lang racket\n", " \
    \ (define (count-uniques word)\n    (length (remove-duplicates (string->list word))))\n\
    \  (define (check-max word max-so-far)\n    (cond ((> (count-uniques word) (count-uniques\
    \ max-so-far)) word)\n          ((string=? word max-so-far) word)\n          (else\
    \ max-so-far)))\n  (foldl check-max \"\" words))\n", "  (cond\n    [(null? words)\
    \ #f]\n    [(not (list? words)) #f]\n    [(not (every? string? words)) #f]\n \
    \   [else\n     (let ([max_word #f]\n           [max_word_count -1])\n       (for\
    \ ([word words])\n         (if (&gt; (length (unique-chars word)) max_word_count)\n\
    \             (begin\n               (set! max_word word)\n               (set!\
    \ max_word_count (length (unique-chars word))))))\n       max_word)]))\n", " \
    \ (apply max\n         (for/list ([w (in-list words)])\n           (string-length\
    \ (set->list (string-&gt;set w))))))\n</code>\nThe trick is to convert the words\
    \ to sets, which automatically remove duplicates. The <code>set-&gt;list</code>\
    \ function only exists in Racket, but since you don't seem to have a problem with\
    \ standard libraries, it might be easier for you to use.\n", "  (apply max (map\
    \ (lambda (word)\n                    (word . (length (string-&gt;list (string-sort\
    \ word)))))\n                  words)))\n", "  (match words\n    [(list) '()]\n\
    \    [(list w) w]\n    [(list w w2 w3 ...)\n     (let*\n         ([w-uniq (unique_chars\
    \ w)]\n          [w2-uniq (unique_chars w2)]\n          [w3-uniq (unique_chars\
    \ w3)]\n          ...)\n       (let\n           ([max-uniq (max w-uniq w2-uniq\
    \ w3-uniq ...)])\n         (find-max-word max-uniq)))]))\n", "  (define (word-unique-chars\
    \ word)\n    (define (char-in-word? char word)\n      (member char word))\n  \
    \  (define (is-unique? char)\n      (and (not (char-in-word? char word))\n   \
    \        (null? (filter (lambda (char2)\n                            (char=? char\
    \ char2))\n                          word))))\n    (length (filter is-unique?\
    \ word)))\n  (apply max (map word-unique-chars words)))", "  (let ([max-characters\
    \ 0]\n        [result #f])\n    (for ([word words])\n      (define (count-unique-chars\
    \ word)\n        (define (is-new-char x)\n          (not (member x (rest seen))))\n\
    \        (define seen '(#\\a))\n        (foldl (lambda (x y)\n               \
    \  (if (is-new-char x)\n                     (cons x y)\n                    \
    \ y))\n               seen\n               word))\n      (define (unique-length\
    \ word)\n        (length (count-unique-chars word)))\n      (define (is-greater\
    \ w)\n        (and (> (unique-length w) max-characters)\n             (not (string<?\
    \ w result))))\n      (if (is-greater word)\n          (set! max-characters (unique-length\
    \ word)\n                result word)))\n    result))\n", "  (define (sort words)\n\
    \    (cond [(empty? words) empty]\n          [else (insert (first words) (sort\
    \ (rest words)))]))\n  (define (insert word words)\n    (cond [(empty? words)\
    \ (list word)]\n          [(< (length (unique_characters word))\n            \
    \  (length (unique_characters (first words))))\n           (cons word words)]\n\
    \          [else (cons (first words) (insert word (rest words)))]))\n  (define\
    \ (unique_characters word)\n    (set (string->list word)))\n  (define (set chars)\n\
    \    (cond [(empty? chars) empty]\n          [else (cons (first chars) (set (remove\
    \ (first chars) (rest chars))))]))\n  (define (remove char chars)\n    (cond [(empty?\
    \ chars) empty]\n          [(equal? char (first chars)) (rest chars)]\n      \
    \    [else (cons (first chars) (remove char (rest chars)))]))\n  (first (sort\
    \ words)))\n", "  (cond [(empty? words) '()]\n        [else (foldr (\u03BB (x\
    \ y) (if (> (unique-chars x) (unique-chars y)) x y)) (first words) (rest words))]))\n",
  "  (define (count-uniques word)\n    (define (count-uniques-inner remaining count)\n\
    \      (cond\n        [(empty? remaining) count]\n        [(member (first remaining)\
    \ (rest remaining))\n         (count-uniques-inner (rest remaining) count)]\n\
    \        [else (count-uniques-inner (rest remaining) (+ count 1))]))\n    (count-uniques-inner\
    \ (string->list word) 0))\n  (apply max (map count-uniques words)))\n", "  (define\
    \ (is-unique char word)\n    (cond\n      [(null? word) #t]\n      [(char=? char\
    \ (car word)) #f]\n      [else (is-unique char (cdr word))]))\n  (define (count-unique\
    \ word)\n    (cond\n      [(null? word) 0]\n      [(is-unique (car word) (cdr\
    \ word)) (+ 1 (count-unique (cdr word)))]\n      [else (count-unique (cdr word))]))\n\
    \  (cond\n    [(null? words) #f]\n    [(null? (cdr words)) (car words)]\n    [else\n\
    \     (define max-word (car words))\n     (define max-value (count-unique (car\
    \ words)))\n     (define (iter words)\n       (cond\n         [(null? words) #f]\n\
    \         [(> (count-unique (car words)) max-value)\n          (set! max-word\
    \ (car words))\n          (set! max-value (count-unique (car words)))\n      \
    \    (iter (cdr words))]\n         [(= (count-unique (car words)) max-value)\n\
    \          (set! max-word (min (car words) max-word))\n          (iter (cdr words))]\n\
    \         [else (iter (cdr words))]))\n     (iter (cdr words))\n     max-word]))\n",
  "  (cond\n    [(empty? words) empty]\n    [(= (length (unique-chars (first words)))\n\
    \        (length (unique-chars (apply max words))))\n     (first words)]\n   \
    \ [else (find_max (rest words))]))\n", "  (define (max_unique word1 word2)\n \
    \   (define (unique-chars word)\n      (set! word (string-sort word))\n      (let\
    \ loop ([i 0] [unique '()])\n        (cond [(= i (string-length word)) unique]\n\
    \              [(member (string-ref word i) unique) (loop (+ i 1) unique)]\n \
    \             [else (loop (+ i 1) (cons (string-ref word i) unique))])))\n   \
    \ (define (lexicographical word1 word2)\n      (cond [(string=? word1 word2) 0]\n\
    \            [(string<? word1 word2) -1]\n            [else 1]))\n    (let ([length1\
    \ (length (unique-chars word1))]\n          [length2 (length (unique-chars word2))])\n\
    \      (cond [(= length1 length2) (lexicographical word1 word2)]\n           \
    \ [(> length1 length2) word1]\n            [else word2])))\n  (let loop ([words\
    \ words] [max '()])\n    (cond [(null? words) max]\n          [else (loop (cdr\
    \ words) (max_unique (car words) max))])))\n", "  (cond ((null? words) '())\n\
    \        ((null? (cdr words)) (car words))\n        (else\n         (let* ((char-counts\
    \ (map (\u03BB (word) (cons word (count-unique-chars word))) words))\n       \
    \         (max-count (maximum (map cdr char-counts)))\n                (words-with-max-count\
    \ (filter (\u03BB (word) (= max-count (cdr word))) char-counts)))\n          \
    \ (car (apply min words-with-max-count))))))\n", "  (cond\n    [(empty? words)\
    \ empty]\n    [(empty? (rest words)) (first words)]\n    [else\n     (define first_word\
    \ (first words))\n     (define second_word (find_max (rest words)))\n     (if\
    \ (&gt; (string-length (string-distinct-characters first_word))\n            (string-length\
    \ (string-distinct-characters second_word)))\n         first_word\n         second_word)]))\n\
    </code>\n", "  (define (count-uniques lst)\n    (count-uniques-helper lst #hash()))\n\
    \  (define (count-uniques-helper lst uniques)\n    (cond [(empty? lst) (hash-count\
    \ uniques)]\n          [else (count-uniques-helper (rest lst)\n              \
    \                        (hash-set uniques (first lst) true))]))\n  (define (max-count?\
    \ x y)\n    (cond [(= (count-uniques (explode (first x)))\n             (count-uniques\
    \ (explode (first y))))\n           (cond [(string&lt;? (first x) (first y)) #t]\n\
    \                 [else #f])]\n          [(&gt; (count-uniques (explode (first\
    \ x)))\n             (count-uniques (explode (first y)))) #t]\n          [else\
    \ #f]))\n  (first (list-sort max-count? words)))\n", "  (define (count x)\n  \
    \  (cond\n      [(empty? (rest x)) 1]\n      [(member (first x) (rest x)) (count\
    \ (rest x))]\n      [else (+ 1 (count (rest x)))]))\n  (cond\n    [(empty? words)\
    \ \"\"]\n    [(empty? (rest words)) (first words)]\n    [(> (count (first words))\
    \ (count (find_max (rest words)))) (first words)]\n    [else (find_max (rest words))]))\n",
  "  (foldl (lambda (prev curr)\n           (let ((p-uniq (length (remove-duplicates\
    \ (string->list prev))))\n                 (c-uniq (length (remove-duplicates\
    \ (string->list curr)))))\n             (if (&gt; p-uniq c-uniq)\n           \
    \      prev\n                 curr)))\n         \"ab\"\n         words))\n</code>\n",
  "  (apply max (map (lambda (word) (cons (count-unique-chars word) word)) words)))\n",
  "  (let loop ((wds words)\n             (max \"\"))\n    (cond\n      [(empty? wds)\
    \ max]\n      [(or (string=? (car wds) max)\n           (string&lt;? (car wds)\
    \ max))\n       (loop (cdr wds) max)]\n      [else (loop (cdr wds) (car wds))])))\n",
  "  (max-by (\u03BB (w)\n            (count (uniq (string-&gt;list w))))\n      \
    \    words))\n", "  (for/fold ([max-word \"\"]\n             [max-len 0])\n  \
    \          ([word words])\n    (let ([word-uniq (uniq-elements (string->list word))])\n\
    \      (cond [(> (length word-uniq) max-len)\n             (values word (length\
    \ word-uniq))]\n            [(= (length word-uniq) max-len)\n             (values\
    \ (if (string<? word max-word) word max-word)\n                     max-len)]\n\
    \            [else (values max-word max-len)]))))\n", "  (apply max\n        \
    \ (map (\u03BB (w)\n                (cons w (apply + (map (\u03BB (c) (if (member\
    \ c w) 0 1))\n                                      (string->list w)))))\n   \
    \           words)))\n", "  (let ([max-word (car words)]\n        [max-word-uniq-chars\
    \ (uniq-chars max-word)])\n    (for ([word (cdr words)])\n      (let ([uniq-chars\
    \ (uniq-chars word)])\n        (when (> (list-length uniq-chars) (list-length\
    \ max-word-uniq-chars))\n          (set! max-word word)\n          (set! max-word-uniq-chars\
    \ uniq-chars))))\n    max-word))\n", "  (cond [(null? words) \"\"]\n        [(equal?\
    \ words (list \"\")) \"\"]\n        [(equal? (length (cdr words)) 0) (car words)]\n\
    \        [(equal? (length (remove-duplicates (list->string (car words))))\n  \
    \               (length (remove-duplicates (list->string (cadr words)))))\n  \
    \       (find_max (append (list (car words)) (cddr words)))]\n        [(> (length\
    \ (remove-duplicates (list->string (car words))))\n            (length (remove-duplicates\
    \ (list->string (cadr words)))))\n         (find_max (append (list (car words))\
    \ (cddr words)))]\n        [else (find_max (cdr words))]))\n", "  (define (char-number\
    \ word)\n    (length (list-set word)))\n  (apply max (map char-number words)))\n",
  "  (for/first ([word words] #:when (max-char-count word))\n    word))\n", "  (first\
    \ (apply max (map (lambda (word)\n                           (cons (count-set\
    \ (string->list word))\n                                 word))\n            \
    \             words))))\n", "  (if (empty? words)\n      \"\"\n      (let loop\
    \ ((words words)\n                 (first (first words))\n                 (max-len\
    \ (string-length (car (remove-duplicates (string->list (first words)))))))\n \
    \       (if (empty? words)\n            first\n            (let* ((next (first\
    \ words))\n                   (next-len (string-length (car (remove-duplicates\
    \ (string->list next))))))\n              (if (> next-len max-len)\n         \
    \         (loop (rest words) next next-len)\n                  (if (and (= next-len\
    \ max-len)\n                           (< (string<? next first) 0))\n        \
    \              (loop (rest words) next next-len)\n                      (loop\
    \ (rest words) first max-len))))))))\n", "  (for/first ([w (in-list words)]\n\
    \              [i (in-list (map list-set (map string-&gt;list words)))])\n   \
    \ (when (= (length i) (apply max (map length (map list-set (map string-&gt;list\
    \ words)))))\n      w)))\n", "  (cond\n    [(empty? words) (error \"empty list\"\
    )]\n    [(equal? 1 (length words)) (first words)]\n    [else\n     (let loop ((words\
    \ words)\n                (unique_counts (map unique-char-count words))\n    \
    \            (max (max unique_counts))\n                (pos (- (length unique_counts)\
    \ 1)))\n       (cond\n         [(equal? pos 0)\n          (cond\n            [(equal?\
    \ (first unique_counts) max) (first words)]\n            [else (loop (rest words)\
    \ (rest unique_counts) max (- pos 1))])]\n         [(equal? (list-ref unique_counts\
    \ pos) max)\n          (list-ref words pos)]\n         [else (loop words unique_counts\
    \ max (- pos 1))]))]))\n", "  (apply max (map (lambda (word)\n               \
    \     (length (unique (string->list word))))\n                  words)))", " \
    \ (define (count-uniques word)\n    (length (remove-duplicates (string->list word))))\n\
    \  (sort words\n        (lambda (s1 s2)\n          (let ([u1 (count-uniques s1)]\n\
    \                [u2 (count-uniques s2)])\n            (cond\n              [(>\
    \ u1 u2) #t]\n              [(= u1 u2) (string&lt;? s1 s2)]\n              [else\
    \ #f])))))\n</code>\n", "  (define (find_max_h words max-word max-count)\n   \
    \ (if (null? words)\n        max-word\n        (let ((word (car words))\n    \
    \          (count (count-unique-chars word)))\n          (if (> count max-count)\n\
    \              (find_max_h (cdr words) word count)\n              (find_max_h\
    \ (cdr words) max-word max-count)))))\n  (find_max_h words \"\" 0))\n", "  (cond\
    \ [(empty? words) (error \"List should contain at least one word\")]\n       \
    \ [(singleton? words) (first words)]\n        [else\n         (define (count_chars\
    \ word chars-seen)\n           (cond [(empty? word) chars-seen]\n            \
    \     [(member (first word) chars-seen) (count_chars (rest word) chars-seen)]\n\
    \                 [else (count_chars (rest word) (cons (first word) chars-seen))]))\n\
    \         (define (extract_word words)\n           (cond [(empty? words) (error\
    \ \"List should contain at least one word\")]\n                 [(singleton? words)\
    \ (cons (first words) 0)]\n                 [else (cons (first words) (count_chars\
    \ (first words) '()))]))\n         (define (choose_winner word1 word2)\n     \
    \      (cond [(< (cdr word1) (cdr word2)) word2]\n                 [(> (cdr word1)\
    \ (cdr word2)) word1]\n                 [else (cond [(string<? (car word1) (car\
    \ word2)) word1]\n                             [(string<? (car word2) (car word1))\
    \ word2]\n                             [else (error \"Should not have both words\
    \ equal\")])]))\n         (foldl choose_winner (extract_word words) (map extract_word\
    \ (rest words))))])\n", "  (cond\n    [(null? words) #f]\n    [(null? (cdr words))\
    \ (car words)]\n    [else\n     (let* ([word1 (car words)]\n            [word2\
    \ (car (cdr words))]\n            [rest (cdr (cdr words))]\n            [max (if\
    \ (&gt; (count-unique-chars word1)\n                        (count-unique-chars\
    \ word2))\n                     word1\n                     word2)])\n       (find_max\
    \ (cons max rest)))]))\n", "  (let ((max-count 0)\n        (max-word \"\"))\n\
    \    (for ([word words])\n      (let ((count (length (set (string-&gt;list word)))))\n\
    \        (when (&gt; count max-count)\n          (set! max-count count)\n    \
    \      (set! max-word word))))\n    max-word))\n", "  (let ([max-word (word_with_max_uniq\
    \ words)])\n    (if (= (length max-word) 0)\n        \"Empty list of words\"\n\
    \        max-word)))\n", "  (let loop ((words words)\n             (max '()))\n\
    \    (if (null? words)\n        max\n        (let ((u (string-&gt;list (string-join\
    \ (set words)))))\n          (if (&gt; (length u) (length (string-&gt;list (string-join\
    \ (set max)))))\n              (loop (cdr words) (list (car words)))\n       \
    \       (if (&gt; (length u) (length (string-&gt;list (string-join (set max)))))\n\
    \                  (loop (cdr words) (list (car words)))\n                  (loop\
    \ (cdr words) max)))))))\n</code>\nThanks very much for any suggestions.\n\n\n\
    A:\n\n<code>(if (&gt; (length u) (length (string-&gt;list (string-join (set max)))))\n\
    \    (loop (cdr words) (list (car words)))\n    (if (&gt; (length u) (length (string-&gt;list\
    \ (string-join (set max)))))\n        (loop (cdr words) (list (car words)))\n\
    \        (loop (cdr words) max)))))))\n</code>\nIt looks like the second <code>if</code>\
    \ is a copy-paste error, yes?\n", "  (for/first ([w words]\n              #:when\
    \ (count (remove-duplicates (string-&gt;list w))\n                           (string-&gt;list\
    \ w)))\n    w))\n", "  (define maxcount (- 1 (length (remove-duplicates (string->list\
    \ (car words)))))\n  (define maxword (car words))\n  (for ([word (in-list (cdr\
    \ words))])\n      (let ((newcount (- 1 (length (remove-duplicates (string->list\
    \ word))))))\n        (if (&gt; newcount maxcount)\n          (set! maxcount newcount)\n\
    \          (set! maxword word)))))\n  maxword)\n</code>\n", "  (if (null? words)\n\
    \      \"\"\n      (let ((c (car words))\n            (rest (cdr words)))\n  \
    \      (let ((curr (count-unique c))\n              (rest-max (find_max rest)))\n\
    \          (if (&gt; curr (count-unique rest-max))\n              c\n        \
    \      (if (&gt; curr (count-unique rest-max))\n                  c\n        \
    \          (if (&lt; c rest-max)\n                      c\n                  \
    \    rest-max)))))))\n", "  (let ((max-uniq-chars 0)\n        (max-uniq-word \"\
    \")\n        (iter (lambda (word)\n                (let ((uniq-chars (length (string-uniq\
    \ word))))\n                  (if (&gt; uniq-chars max-uniq-chars)\n         \
    \             (begin (set! max-uniq-chars uniq-chars)\n                      \
    \       (set! max-uniq-word word)))))))\n    (for-each iter words)\n    max-uniq-word))\n",
  "  (let loop ((acc \"\") (words words))\n    (cond\n      [(null? words) (string\
    \ acc)]\n      [(&gt; (unique-chars (string (car words))) (unique-chars acc))\n\
    \       (loop (string (car words)) (cdr words))]\n      [else (loop acc (cdr words))])))\n\
    </code>\nI had to use a helper function to keep track of the most unique char\
    \ word\nso far. I also had to convert the string to a list of characters so I\
    \ could\nremove duplicates.\nEDIT:\nHere is a simpler solution which uses the\
    \ <code>string-&gt;list</code> function:\n<code>#lang racket\n", "  (let loop\
    \ ((words words)\n             (max-word (car words))\n             (max-num (length\
    \ (remove-duplicates (string->list (car words))))))\n    (cond ((null? words)\
    \ max-word)\n          ((< (length (remove-duplicates (string->list (car words))))\
    \ max-num)\n           (loop (cdr words) max-word max-num))\n          (else (loop\
    \ (cdr words) (car words) (length (remove-duplicates (string->list (car words)))))))))\n",
  "  (apply max (map (lambda (w) (cons (word-uniques w) w)) words)))\n", "  (for/first\
    \ ([word words]\n              #:when (string=? (string-join (list-sort < (remove-duplicates\
    \ (string-&gt;list word))))\n                                (string-join (list-sort\
    \ < (remove-duplicates (string-&gt;list (for/first ([word words]\n           \
    \                                                                            \
    \           #:when (&gt; (list-length (remove-duplicates (string-&gt;list word)))\n\
    \                                                                            \
    \                               (list-length (remove-duplicates (string-&gt;list\
    \ word))))\n                                                                 \
    \                                 word)))))))\n    word))\n", "  (cond\n    ((null?\
    \ words) false)\n    ((= (length words) 1) (car words))\n    (else\n      (let*\
    \ ([head (car words)]\n             [tail (cdr words)]\n             [tail-max\
    \ (find_max tail)])\n        (cond\n          ((&gt; (length (unique-chars head))\n\
    \              (length (unique-chars tail-max)))\n           head)\n         \
    \ ((&lt; (length (unique-chars head))\n              (length (unique-chars tail-max)))\n\
    \           tail-max)\n          (else\n            (if (&lt; (string-&gt;number\
    \ head)\n                    (string-&gt;number tail-max))\n                head\n\
    \                tail-max)))))))\n", "  (define (unique-chars word)\n    (set-member-eq?\
    \ (string-&gt;list word) '()))\n  (define (max-word words)\n    (define (helper\
    \ words best-word)\n      (cond\n        [(empty? words) best-word]\n        [(&gt;\
    \ (unique-chars (first words)) (unique-chars best-word))\n         (helper (rest\
    \ words) (first words))]\n        [else (helper (rest words) best-word)]))\n \
    \   (helper (rest words) (first words)))\n  (max-word words))\n</code>\nBut I\
    \ get an error:\n<code>set-member-eq?: symbol 'a not found\n  context...:\n  \
    \ /Applications/Racket v6.0/collects/racket/private/misc.rkt:87:13\n   find_max\n\
    </code>\nIs <code>string-&gt;list</code> not the right way to convert a string\
    \ to a list of characters?\nOr should I not use <code>set-member-eq?</code>?\n\
    \n\nA:\n\nI'll just leave this here:\n<code>(define (find-max words)\n  (for/first\
    \ ([word words]\n              #:when (equal? (set-member-eq? (string-&gt;list\
    \ word) '())\n                             (set-member-eq? (string-&gt;list (first\
    \ words)) '())))\n    word))\n</code>\nIn case you want the first word that appears\
    \ in the list and matches the condition (lexicographical order is irrelevant here).\n",
  "  (foldl max-by-lex (first words) (rest words)\n         (lambda (word1 word2)\n\
    \           (if (= (length (set (string-&gt;list word1)))\n                  (length\
    \ (set (string-&gt;list word2))))\n               (string&lt;? word1 word2)\n\
    \               (&lt; (length (set (string-&gt;list word1)))\n               \
    \   (length (set (string-&gt;list word2)))))))\n", "  (if (null? words)\n    \
    \  #f\n      (let loop ((max #f)\n                 (words words))\n        (cond\
    \ ((null? words)\n               max)\n              ((or (not max)\n        \
    \           (string<? (number_of_unique_chars (car words))\n                 \
    \            (number_of_unique_chars max)))\n               (loop (car words)\n\
    \                     (cdr words)))\n              (else\n               (loop\
    \ max\n                     (cdr words)))))))\n", '  (apply max words))', "  (local\
    \ [(define (count lst)\n            (local [(define (count-r lst acc)\n      \
    \                (cond [(empty? lst) acc]\n                            [(member\
    \ (first lst) acc) (count-r (rest lst) acc)]\n                            [else\
    \ (count-r (rest lst) (cons (first lst) acc))]))]\n              (count-r lst\
    \ '())))\n          (define (max words)\n            (if (or (empty? words) (empty?\
    \ (rest words)))\n                (first words)\n                (if (> (count\
    \ (first words)) (count (second words)))\n                    (max (cons (first\
    \ words) (rest (rest words))))\n                    (max (cons (second words)\
    \ (rest (rest words)))))))]\n    (max words)))\n", "  (let loop ((words words)\n\
    \             (word (car words))\n             (word-char-count (count-unique-chars\
    \ (car words)))\n             (max-word-char-count word-char-count))\n    (cond\n\
    \      ((null? words)\n       word)\n      ((= max-word-char-count word-char-count)\n\
    \       (loop (cdr words)\n             (string<? word (car words))\n        \
    \     word-char-count\n             max-word-char-count))\n      ((> max-word-char-count\
    \ word-char-count)\n       (loop (cdr words)\n             (car words)\n     \
    \        word-char-count\n             word-char-count))\n      (else\n      \
    \ (loop (cdr words)\n             word\n             word-char-count\n       \
    \      max-word-char-count)))))\n", "  (define (compute-chars str)\n    (if (empty?\
    \ str)\n        '()\n        (if (member (first str) (rest str))\n           \
    \ (compute-chars (rest str))\n            (cons (first str) (compute-chars (rest\
    \ str))))))\n  (define (max-unique str)\n    (length (compute-chars str)))\n \
    \ (let ([cur-max (max-unique (first words))]\n        [cur-max-word (first words)])\n\
    \    (for ([word (rest words)])\n      (if (&gt; (max-unique word) cur-max)\n\
    \          (set! cur-max (max-unique word))\n          (set! cur-max-word word)))\n\
    \    cur-max-word))\n</code>\nThe problem I am having is in the <code>for</code>\
    \ loop. I am not sure how to compare the word with <code>cur-max</code>.\n\n\n\
    A:\n\nFirst, you don't need to create a procedure for the comparisons. When you're\
    \ updating <code>cur-max</code> and <code>cur-max-word</code>, you can use the\
    \ <code>let</code> form for that.\nNext, for comparing characters in a string\
    \ you can use <code>string-contains</code>.\n<code>(define (find-max words)\n\
    \  (define (compute-chars str)\n    (if (empty? str)\n        '()\n        (if\
    \ (string-contains (rest str) (first str))\n            (compute-chars (rest str))\n\
    \            (cons (first str) (compute-chars (rest str))))))\n  (define (max-unique\
    \ str)\n    (length (compute-chars str)))\n  (let loop ([cur-max (max-unique (first\
    \ words))]\n             [cur-max-word (first words)])\n    (if (empty? (rest\
    \ words))\n        cur-max-word\n        (let ([word (first (rest words))]\n \
    \             [word-length (max-unique word)])\n          (if (&gt; word-length\
    \ cur-max)\n              (loop word-length word)\n", "  (letrec ([max_unique_characters\
    \ (max-unique-characters words)]\n           [max_unique_words (filter (\u03BB\
    \ (w) (equal? (unique-characters w) max_unique_characters)) words)])\n    (first\
    \ (sort max_unique_words string<?))))\n", "  (match words\n    [('()) '()]\n \
    \   [(cons (first words) (rest words))\n     (match (find_max (rest words))\n\
    \       [('()) (cons first '())]\n       [(cons max max_rest)\n        (match\
    \ (unique_characters (first words))\n          [(cons first_unique first_unique_rest)\n\
    \           (match (unique_characters max)\n             [(cons max_unique max_unique_rest)\n\
    \              (if (> (length first_unique) (length max_unique))\n           \
    \       (cons first (rest words))\n                  (cons max max_rest))])])])]))\n",
  "  (max (list->set words) string&lt;=?))\n", "  (define (max words maxchar word)\n\
    \    (if (null? words)\n        word\n        (let ((val (max (cdr words) maxchar\
    \ word)))\n          (let ((currcharcount (char-count (car words))))\n       \
    \     (if (and (= maxchar currcharcount)\n                     (string<? (car\
    \ words) val))\n                (car words)\n                (if (> currcharcount\
    \ maxchar)\n                    (car words)\n                    val))))))\n \
    \ (max words 0 \"\"))\n", "  (let ([max-word (first words)]\n        [max-chars\
    \ (count-distinct-chars (first words))])\n    (for ([word (rest words)])\n   \
    \   (when (&gt; (count-distinct-chars word) max-chars)\n        (set! max-word\
    \ word)\n        (set! max-chars (count-distinct-chars word))))\n    max-word))\n",
  "  (apply max (map unique-chars words)))\n", "  (define (count_uniques word)\n \
    \   (length (list-uniq (string->list word))))\n  (define (lexicographical? w1\
    \ w2)\n    (if (= (string-length w1) (string-length w2))\n        (let loop ([i\
    \ 0])\n          (cond\n            [(= i (string-length w1)) #f]\n          \
    \  [(char=? (string-ref w1 i) (string-ref w2 i)) (loop (+ i 1))]\n           \
    \ [(char<? (string-ref w1 i) (string-ref w2 i)) #t]\n            [else #f]))\n\
    \        (< (string-length w1) (string-length w2))))\n  (let loop ([words words]\n\
    \             [count (count_uniques (car words))]\n             [result (car words)])\n\
    \    (cond\n      [(null? words) result]\n      [(> (count_uniques (car words))\
    \ count)\n       (loop (cdr words) (count_uniques (car words)) (car words))]\n\
    \      [(and (= (count_uniques (car words)) count)\n            (lexicographical?\
    \ (car words) result))\n       (loop (cdr words) count (car words))]\n      [else\
    \ (loop (cdr words) count result)])))\n", "  (find-max-helper words (current-seconds)))\n",
  "  (define (sort-str-by-uniques str1 str2)\n    (> (length (unique-letters str1))\
    \ (length (unique-letters str2))))\n  (define (find-max-len words)\n    (if (null?\
    \ words)\n        (list)\n        (let ([candidate (first words)])\n         \
    \ (define (find-bigger words)\n            (if (null? words)\n               \
    \ (list candidate)\n                (if (&gt; (length (unique-letters (first words)))\n\
    \                      (length (unique-letters candidate)))\n                \
    \    (find-bigger (rest words))\n                    (cons candidate (find-bigger\
    \ (rest words))))))\n          (find-bigger (rest words)))))\n  (sort words sort-str-by-uniques))\n",
  "  (call-with-values\n   (lambda ()\n     (for/fold ([max-count 0]\n           \
    \     [min-word \"\"])\n               ([word words])\n               (let ([unique-count\
    \ (find-unique-characters word)])\n                 (if (> unique-count max-count)\n\
    \                     (values unique-count word)\n                     (values\
    \ max-count min-word)))))\n   (lambda (max-count min-word)\n     min-word)))\n",
  "  (foldl (lambda (word max-word)\n           (if (&gt; (length (remove-duplicates\
    \ (string-&gt;list word)))\n                  (length (remove-duplicates (string-&gt;list\
    \ max-word))))\n               word\n               max-word))\n         (first\
    \ words)\n         (rest words)))\n", "  (define (nums-in-word w)\n    (length\
    \ (cust-remove-dups (string->list w))))\n  (define (max-nums-word ws)\n    (cond\
    \ ((null? ws) '())\n          ((null? (cdr ws)) (car ws))\n          (else (if\
    \ (&gt; (nums-in-word (car ws)) (nums-in-word (cadr ws)))\n                  \
    \ (max-nums-word (cons (car ws) (cddr ws)))\n                   (max-nums-word\
    \ (cdr ws))))))\n  (max-nums-word words))\n", "  (cond ((null? words) '())\n \
    \       ((null? (cdr words)) (car words))\n        (else\n         (let ((first\
    \ (car words))\n               (second (cadr words)))\n           (if (unique-chars\
    \ first second)\n               (find_max (cons first (cddr words)))\n       \
    \        (find_max (cons second (cddr words))))))))\n", "  (for/first ([word (in-list\
    \ words)]\n              #:when (> (length (find-duplicates word)) (length (find-duplicates\
    \ (car words)))))\n    word))\n", "  (cond\n    [(null? words) '()]\n    [(null?\
    \ (cdr words)) (car words)]\n    [else\n     (cond\n       [(> (length (remove-duplicates\
    \ (list->set (string->list (car words)))))\n           (length (remove-duplicates\
    \ (list->set (string->list (cadr words))))))\n        (find_max (cons (car words)\
    \ (cddr words)))]\n       [else\n        (find_max (cons (cadr words) (cddr words)))])]))\n",
  "  (let ((max_word (car words))\n        (max_count 0))\n    (for ([word words])\n\
    \      (let ([count (length (remove-duplicates (string->list word)))]\n      \
    \      [comp (string<? word max_word)])\n        (cond\n          [(and (equal?\
    \ count max_count) (not comp))\n           (set! max_word word)]\n          [(>\
    \ count max_count)\n           (set! max_word word)\n           (set! max_count\
    \ count)]\n          [else #f])))\n    max_word))\n", "  (if (null? words) #f\n\
    \      (max-by (lambda (w) (string-length (string-set w))) words)))\n", "  (for/first\
    \ ([w (in-list words)]\n              [u (in-list (list-set (apply append (map\
    \ string-&gt;list w))))])\n    (cons w (length u))))\n</code>\nYou can test it:\n\
    <code>&gt; (find_max '(\"Hobo\" \"Robo\" \"Robo\" \"Sir\"))\n'(\"Robo\" . 4)\n\
    &gt; (find_max '(\"Hobo\" \"Robo\" \"Robo\" \"Sir\" \"Soir\"))\n'(\"Soir\" . 4)\n\
    </code>\nThe <code>find_max</code> is much less efficient than <code>hash-&gt;list</code>\
    \ would be, but since Racket's standard library doesn't offer a hash table, I\
    \ don't see much point in pursuing that option.\n", "  (if (null? words)\n   \
    \   (error \"no words!\")\n      (let loop ((wds words)\n                 (max\
    \ (car words))\n                 (max-uniq-chars (length (remove-duplicates (string->list\
    \ (car words))))))\n        (cond ((null? wds) max)\n              ((= max-uniq-chars\
    \ (length (remove-duplicates (string->list (car wds)))))\n               (if (string<?\
    \ (car wds) max)\n                   (loop (cdr wds) (car wds) max-uniq-chars)\n\
    \                   (loop (cdr wds) max max-uniq-chars)))\n              ((> (length\
    \ (remove-duplicates (string->list (car wds)))) max-uniq-chars)\n            \
    \   (loop (cdr wds) (car wds) (length (remove-duplicates (string->list (car wds))))))\n\
    \              (else (loop (cdr wds) max max-uniq-chars))))))", "  (define (max\
    \ word current-max)\n    (if (and (string=? word \"\") current-max)\n        current-max\n\
    \        (let ((c (string-ref word 0)))\n          (if (and (string-member c current-max)\
    \ (not (string=? current-max \"\")))\n              (max (substring word 1) current-max)\n\
    \              (max (substring word 1) (string-append current-max (string c)))))))\n\
    \  (define (f words current-max)\n    (if (null? words)\n        current-max\n\
    \        (let ((word (car words)))\n          (if (string=? current-max \"\")\n\
    \              (f (cdr words) (max word current-max))\n              (let ((new-max\
    \ (max word current-max)))\n                (if (= (string-length new-max) (string-length\
    \ current-max))\n                    (f (cdr words) (if (string<? new-max current-max)\
    \ new-max current-max))\n                    (f (cdr words) (if (> (string-length\
    \ new-max) (string-length current-max)) new-max current-max))))))))\n  (f words\
    \ \"\"))\n", "  (for/first ([w words]\n              #:when (> (length (remove-duplicates\
    \ (string-&gt;list w)))\n                        (apply max (map (lambda (word)\n\
    \                                          (length (remove-duplicates (string-&gt;list\
    \ word))))\n                                        words))))\n    w))\n</code>\n",
  "  (define (helper words max-len max-word)\n    (cond\n      [(empty? words) max-word]\n\
    \      [(string<? (first words) max-word)\n       (helper (rest words) max-len\
    \ max-word)]\n      [(string<? max-word (first words))\n       (helper (rest words)\
    \ (string-length (first words)) (first words))]\n      [else\n       (helper (rest\
    \ words) max-len (if (> (string-length (first words)) max-len)\n             \
    \                           (first words)\n                                  \
    \      max-word))]))\n  (helper words 0 (first words)))\n", "  (displayln words)\n\
    \  (if (null? words)\n      (error \"Empty list\")\n      (let loop ((words words)\n\
    \                 (max-unique-chars 0)\n                 (max-word \"\"))\n  \
    \      (if (null? words)\n            max-word\n            (let* ((word (car\
    \ words))\n                   (unique-chars (count-unique-chars word)))\n    \
    \          (loop (cdr words)\n                    (if (&gt; unique-chars max-unique-chars)\n\
    \                        unique-chars\n                        max-unique-chars)\n\
    \                    (if (&gt; unique-chars max-unique-chars)\n              \
    \          word\n                        max-word)))))))\n", "  (define (count-char\
    \ word)\n    (set! word (foldl (lambda (x y) (string-append x (if (member y x)\
    \ \"\" y))) \"\" word))\n    (string-length word))\n  (define (max-word words)\n\
    \    (cond ((null? words) \"\")\n          ((null? (cdr words)) (car words))\n\
    \          (else (if (> (count-char (car words)) (count-char (cadr words)))\n\
    \                    (car words)\n                    (max-word (cdr words))))))\n\
    \  (max-word words))", "  (apply max\n         (map (lambda (word)\n         \
    \       (list (length (set (map char-downcase (string->list word))))\n       \
    \               word))\n              words)))\n", "  (apply max words\n     \
    \    (\u03BB (w1 w2)\n           (and (= (set-count (set w1)) (set-count (set\
    \ w2)))\n                (string<? w1 w2)))))\n", "  (if (null? words)\n     \
    \ (error \"No words!\")\n      (if (null? (cdr words))\n          (car words)\n\
    \          (let ((max-word (car words))\n                (max-characters (length\
    \ (set (car words)))))\n            (let loop ((words (cdr words)))\n        \
    \      (if (null? words)\n                  max-word\n                  (let ((chars\
    \ (length (set (car words)))))\n                    (if (> chars max-characters)\n\
    \                        (loop (cdr words))\n                        (if (= chars\
    \ max-characters)\n                            (let ((next-word (car words)))\n\
    \                              (if (string<? max-word next-word)\n           \
    \                       (loop (cdr words))\n                                 \
    \ (loop (cons next-word (cdr words)))))\n                            (loop (cdr\
    \ words)))))))))))\n", "  (apply max (map (lambda (word) (list (number-of-unique-chars\
    \ word) word)) words)))\n", "  (apply max (map (lambda (word) (cons (length (apply\
    \ set word)) word)) words)))\n", "  (let ([max (first words)])\n    (define (greater?\
    \ a b)\n      (or (&gt; (unique-chars a) (unique-chars b))\n          (and (=\
    \ (unique-chars a) (unique-chars b))\n               (&lt; (string-&gt;symbol\
    \ a) (string-&gt;symbol b)))))\n    (for ([word (rest words)])\n      (when (greater?\
    \ word max)\n        (set! max word)))\n    max))\n", "  (define (add-word-count\
    \ w l)\n    (if (null? l)\n        (list (list w 1))\n        (if (equal? (car\
    \ (car l)) w)\n            (cons (list (car (car l)) (+ 1 (cadr (car l)))) (cdr\
    \ l))\n            (cons (car l) (add-word-count w (cdr l))))))\n  (define (get-count\
    \ w l)\n    (if (null? l)\n        0\n        (if (equal? (car (car l)) w)\n \
    \           (cadr (car l))\n            (get-count w (cdr l)))))\n  (define (unique-chars\
    \ word)\n    (define (helper w l)\n      (if (null? w)\n          l\n        \
    \  (if (not (member (car w) l))\n              (helper (cdr w) (cons (car w) l))\n\
    \              (helper (cdr w) l))))\n    (helper word '()))\n  (define (word-max\
    \ words)\n    (if (null? words)\n        '()\n        (if (null? (cdr words))\n\
    \            (car words)\n            (if (&gt; (get-count (car words) words)\
    \ (get-count (car (cdr words)) words))\n                (word-max (cons (car words)\
    \ (cdr (cdr words))))\n                (word-max (cons (car (cdr words)) (cdr\
    \ (cdr words))))))))\n  (word-max (reduce add-word-count (map unique-chars words)\
    \ '())))\n</code>\nThis is the output I get:\n<code>&gt; (find_max '(\"abcde\"\
    \ \"aabb\" \"abddd\" \"aabbc\"))\n&gt; '()\n</code>\nThe word I am expecting is\
    \ <code>\"abcde\"</code>.\nAny help would be much appreciated.\n\n\nA:\n\nThere\
    \ are multiple issues with your code. I will focus on the algorithm as you asked\
    \ to review only the algorithm.\nFirst, you are using <code>reduce</code> in a\
    \ questionable way. You are passing it a list of strings,", "  (cond [(null? words)\
    \ #f]\n        [(null? (cdr words)) (car words)]\n        [else\n         (define\
    \ this-word (car words))\n         (define next-word (cadr words))\n         (if\
    \ (&gt; (count-unique-chars this-word)\n                (count-unique-chars next-word))\n\
    \             (find_max (cons this-word (cddr words)))\n             (find_max\
    \ (cons next-word (cddr words))))]))\n", "  (define (max-chars lst)\n    (define\
    \ (helper lst mx)\n      (if (null? lst)\n          mx\n          (let ((current\
    \ (string-length (make-string\n                                         (count-unique\
    \ (string->list (car lst)))\n                                         #\\a))))\n\
    \            (if (> current mx)\n                (helper (cdr lst) current)\n\
    \                (helper (cdr lst) mx)))))\n    (helper words 0))\n  (define (helper\
    \ lst mx)\n    (if (null? lst)\n        mx\n        (let ((current (string-length\
    \ (make-string\n                                       (count-unique (string->list\
    \ (car lst)))\n                                       #\\a))))\n          (if\
    \ (= current mx)\n              (if (string<? (car lst) mx)\n                \
    \  (helper (cdr lst) (car lst))\n                  (helper (cdr lst) mx))\n  \
    \            (if (> current mx)\n                  (helper (cdr lst) (car lst))\n\
    \                  (helper (cdr lst) mx))))))\n  (helper words (list (list-ref\
    \ words 0))))\n", "  (define (find_unique w)\n    (cond [(null? w) '()]\n    \
    \      [(char-set-contains? (cdr (find_unique (cdr w))) (car w)) (find_unique\
    \ (cdr w))]\n          [else (cons (car w) (find_unique (cdr w)))]))\n  (define\
    \ (num_uniques w)\n    (length (find_unique w)))\n  (define (is_bigger w1 w2)\n\
    \    (cond [(string&lt; w1 w2) #f]\n          [(string&lt; w2 w1) #t]\n      \
    \    [else #f]))\n  (define (my_max words max_val)\n    (cond [(null? words) max_val]\n\
    \          [(&gt; (num_uniques (car words)) (num_uniques max_val)) (my_max (cdr\
    \ words) (car words))]\n          [(= (num_uniques (car words)) (num_uniques max_val))\
    \ (if (is_bigger (car words) max_val) (my_max (cdr words) (car words)) (my_max\
    \ (cdr words) max_val))]\n          [else (my_max (cdr words) max_val)]))\n  (my_max\
    \ words (car words)))\n</code>\nWhat do you think?\n\n\nA:\n\nIt's a bit unclear\
    \ what your function actually should do, so there's not much to review.  I think\
    \ it would be better to use a clearer name, such as <code>find-max-unique-char-count</code>.\n\
    There are some stylistic things I would change about your code:\n\nIn a for/fold,\
    \ if you want to use the accumulator as is, you can use an underscore for the\
    \ function name.  So the definition of <code>my_max</code> could be\n<code>(define\
    \ (my_max words acc)\n  (for/fold ([acc acc])\n            ([w words])\n    (cond\
    \ ...)))\n</code>\nThere's no need to use <code>#t</code> and <code>#f</code>.\
    \  Use <code>#true</code> and <code>", "  (let* ([key (lambda (w) (length (set\
    \ w)))]\n         [max (apply max (map key words))]\n         [max_words (filter\
    \ (lambda (w) (= (key w) max)) words)])\n    (car (sort max_words string<?))))\n",
  "  (apply max words (make-hash)))\n", "  (let ([sorted-by-uniqueness-and-lexicographically\
    \ (sort words (lambda (a b)\n                                                \
    \                  (< (unique-chars a)\n                                     \
    \                                (unique-chars b))))])\n    (first sorted-by-uniqueness-and-lexicographically)))\n",
  '  (apply max (map unique-characters? words)))', "  (cond [(empty? words) empty]\n\
    \        [else\n         (define (count-uniques word)\n           (define (count-uniques-helper\
    \ word uniques)\n             (cond [(empty? word) (length uniques)]\n       \
    \            [else\n                    (define cur-char (first word))\n     \
    \               (define word-rest (rest word))\n                    (cond [(char=?\
    \ cur-char (first word-rest))\n                           (count-uniques-helper\
    \ word-rest uniques)]\n                          [else\n                     \
    \      (count-uniques-helper word-rest (cons cur-char uniques))])]))\n       \
    \    (count-uniques-helper word empty))\n         (define (find-max-helper words\
    \ cur-max)\n           (cond [(empty? words) cur-max]\n                 [else\n\
    \                  (define cur-word (first words))\n                  (define\
    \ words-rest (rest words))\n                  (cond [(char=? cur-word cur-max)\n\
    \                         (find-max-helper words-rest cur-max)]\n            \
    \            [(< (count-uniques cur-word) (count-uniques cur-max))\n         \
    \                (find-max-helper words-rest cur-max)]\n                     \
    \   [else\n                         (find-max-helper words-rest cur-word)])]))\n\
    \         (find-max-helper words (first words))]])\n```\n\n## Problem 2 - Extracting\
    \ elements from a list\n\nWrite a function to extract elements from a list in\
    \ given order. The order is indicated by a list of indices.\n\nFor example: If\
    \ list1 is `(list 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j)` and list2 is `(list 0 4 6 7)`\
    \ , the output is `(list 'a 'e 'g 'h)`.\n\nExample:\n\n```racket\n> (extract-elements\
    \ '(a b c d e f g h i j) '(0 4 6 7))\n'(a e g h)\n> (extract-elements '(a b c\
    \ d e f g h i j) '(0 4 6 7))\n'(a e g h)\n> (extract-elements", "  (define word-max-uniqs\n\
    \    (apply max (map (lambda (word)\n                      (length (remove-duplicates\
    \ (string->list word))))\n                    words)))\n  (define max-words\n\
    \    (filter (lambda (word)\n              (= (length (remove-duplicates (string->list\
    \ word)))\n                 word-max-uniqs))\n            words))\n  (cond ((null?\
    \ max-words) (error \"empty words\"))\n        ((null? (cdr max-words)) (car max-words))\n\
    \        (else (apply min max-words))))\n", "  (apply max (map (\u03BB (w) (cons\
    \ (length (unique w)) w)) words)))\n", "  (let ([unique-counts (map (lambda (word)\
    \ (unique-chars word)) words)])\n    (car (best-for-max unique-counts words))))\n",
  "  (match words\n    [`(,word1 ,word2 ,wordn)\n     (let ([max_word (find_max (list\
    \ word2 wordn))])\n       (if (&gt; (length (hash-set (list-&gt;hash (string-&gt;list\
    \ word1))))\n              (length (hash-set (list-&gt;hash (string-&gt;list max_word)))))\n\
    \           word1\n           max_word))]\n    [`(,word) word]))\n</code>\nThe\
    \ main problem is \"If multiple strings have maximum number of unique characters,\
    \ return the one which comes first in lexicographical order\".\nI know this has\
    \ something to do with the comparison of 2 words, so I tried to use the <code>string-ci&lt;=?</code>\
    \ function which compares the lexicographical order, but it's not working well.\n\
    I don't know how to compare words and how to make a function return the word that\
    \ comes first.\nI don't want to use the string library.\n\n\nA:\n\nYour code is\
    \ doing the right thing, but in a very convoluted way.\nIn my opinion, a better\
    \ approach would be to first find the maximum, and then search the list for the\
    \ word with that maximum.\nWe can do this more directly, by using a helper function\
    \ that takes a word and the maximum found so far, and returns the word with the\
    \ most distinct characters, or just the word if it's tied with the current maximum:\n\
    <code>(define (find-max words)\n  (define (helper word max-so-far)\n    (define\
    \ len (length (hash-set (list-&gt;hash (string-&gt;list word)))))\n    (cond\n\
    \      [(&gt; len max-so-far)\n       word]\n      [(= len max-so-far)\n     \
    \  (if (string-ci&lt;=? word max-so-far) word max-so-far)]\n      [else\n    \
    \   max-so-far]))\n  (apply helper words (make-hash)))\n</code>\n", "  (foldl\n\
    \   (lambda (word acc)\n     (if (string-ci=?\n          (find-max-unique-characters\
    \ (list->set (string-&gt;list word)))\n          (find-max-unique-characters (list->set\
    \ (string-&gt;list acc))))\n         acc\n         word))\n   (car words)\n  \
    \ (cdr words)))\n", "  (define (unique-characters word)\n    (length (string-normalize-spaces\
    \ (hash-remove! (hash-set '#hash()) word))))\n  (for/first ([word words]\n   \
    \           #:when (= (apply max (map unique-characters words))\n            \
    \            (unique-characters word)))\n    word))\n", "  (if (null? words)\n\
    \      '()\n      (let ((rest (find_max (cdr words))))\n        (if (or (null?\
    \ rest)\n                (> (num-unique-chars (car words))\n                 \
    \  (num-unique-chars rest)))\n            (car words)\n            rest))))\n",
  "  (if (null? words)\n      \"\"\n      (if (null? (cdr words))\n          (car\
    \ words)\n          (let* ([first (car words)]\n                 [first-uniques\
    \ (map (lambda (x) x) (list->set (string-&gt;list first)))]\n                \
    \ [second (cadr words)]\n                 [second-uniques (map (lambda (x) x)\
    \ (list->set (string-&gt;list second)))])\n            (if (= (length first-uniques)\
    \ (length second-uniques))\n                (if (string&lt;? first second)\n \
    \                   first\n                    second)\n                (if (&gt;\
    \ (length first-uniques) (length second-uniques))\n                    first\n\
    \                    second))))))\n</code>\nI think the code is quite self-explanatory.\n\
    I have read it works on Racket docs but somehow the code is not running.\nThe\
    \ code is supposed to return the second element in the list, as it has more unique\
    \ characters than the first element.\n\n\nA:\n\nWith my Racket, your code (after\
    \ removing the spurious space between <code>lambda</code> and <code>(</code>)\
    \ works as you describe.\n", "  (define (count-unique-chars word)\n    (length\
    \ (remove-duplicates (string->list word))))\n  (if (null? words)\n      \"\"\n\
    \      (let ([max-word (car words)]\n            [max-count (count-unique-chars\
    \ max-word)])\n        (for/fold ([acc max-word]) ([word (cdr words)])\n     \
    \     (if (&gt; (count-unique-chars word) max-count)\n              word\n   \
    \           acc)))))\n", "  (apply max (map (lambda (word) (cons (hash-count (string->symbol-hash\
    \ word)) word)) words)))\n```\n\n```racket\n#lang racket\n", "  (define max-len\
    \ -1)\n  (define max-words '())\n  (define (check-word word)\n    (let ([this-len\
    \ (length (filter-out remove-duplicates (string->list word)))])\n      (if (&gt;\
    \ this-len max-len)\n          (set! max-len this-len)\n          (set! max-words\
    \ (list word)))\n      (if (= this-len max-len)\n          (set! max-words (cons\
    \ word max-words)))))\n  (map check-word words)\n  (sort max-words &lt;))\n</code>\n\
    What am I doing wrong?\n\n\nA:\n\nYou're not returning anything from the <code>check-word</code>\
    \ procedure. This is a common problem for those new to the language, so beware\
    \ of side-effects!\nAdditionally, you can simplify your code by directly using\
    \ <code>sort</code> with a custom comparison function, like this:\n<code>(define\
    \ (find-max words)\n  (sort words\n        (lambda (a b)\n          (let ([la\
    \ (length (filter-out remove-duplicates (string-&gt;list a)))])\n            (let\
    \ ([lb (length (filter-out remove-duplicates (string-&gt;list b)))])\n       \
    \       (or (&gt; la lb)\n                  (and (= la lb)\n                 \
    \      (string&lt;? a b))))))))\n</code>\nI recommend using <code>string-&gt;list</code>\
    \ instead of <code>string-&gt;list</code> - the former is more idiomatic in Racket.\
    \ Also, you're using <code>filter-out</code> to filter duplicates, when there's\
    \ a <code>remove-duplicates</code> procedure for that. As an added bonus, the\
    \ above code will work correctly even when there are more than two words with\
    \ the maximum number of unique characters. And finally, it's good practice to\
    \ use <code>-&gt;</code> instead of <code>-&gt;&gt;</code> in Racket, since it's\
    \ more idiomatic.\n", "  (let max-word 0\n    (for ([word words])\n      (let\
    \ ([chars (string-&gt;list word)])\n        (if (&gt; (hash-count chars) max-word)\n\
    \            (begin\n              (set! max-word (hash-count chars))\n      \
    \        (set! max-characters (hash-&gt;list chars))))))))\n</code>", "  (let\
    \ loop ((words words)\n             (curr-max \"\")\n             (curr-max-len\
    \ 0))\n    (cond ((null? words) curr-max)\n          ((< (length (set (string-&gt;list\
    \ (car words)))) curr-max-len)\n           (loop (cdr words) curr-max curr-max-len))\n\
    \          ((&gt; (length (set (string-&gt;list (car words)))) curr-max-len)\n\
    \           (loop (cdr words) (car words) (length (set (string-&gt;list (car words))))))\n\
    \          ((string=? (car words) curr-max)\n           (loop (cdr words) curr-max\
    \ curr-max-len))\n          (else (loop (cdr words) (car words) (length (set (string-&gt;list\
    \ (car words)))))))))\n</code>\nI am aware that there is probably a much better\
    \ way to do this, but I like the solution I came up with.\n", "  (let loop ((xs\
    \ words)\n             (max-uniq (number->string 0))\n             (max-len (number->string\
    \ 0)))\n    (if (null? xs)\n        max-uniq\n        (let ((word (car xs))\n\
    \              (uniq (map char-upcase (remove-duplicates (string->list word)))))\n\
    \          (cond ((> (string-length word) (string-length max-len))\n         \
    \        (loop (cdr xs) word word))\n                ((= (string-length word)\
    \ (string-length max-len))\n                 (cond ((string<? word max-uniq)\n\
    \                        (loop (cdr xs) word max-len))\n                     \
    \  ((string<? max-uniq word)\n                        (loop (cdr xs) max-uniq\
    \ max-len))\n                       (else\n                        (loop (cdr\
    \ xs) max-uniq max-len))))\n                (else\n                 (loop (cdr\
    \ xs) max-uniq max-len)))))))\n", "  (let ((max (string-length (first words)))\n\
    \        (max-index 0))\n    (for ([index (in-range (length words))])\n      (let\
    \ ((word (vector-ref words index)))\n        (when (< max (string-length word))\n\
    \          (set! max (string-length word))\n          (set! max-index index))))\n\
    \    (vector-ref words max-index)))\n", "  (apply max (map unique-count words)))\n",
  "  (apply max words\n         (\u03BB (word1 word2)\n           (if (string&gt;=?\
    \ word1 word2)\n               word1\n               word2))))\n", "  (let loop\
    \ ((min_unique (string-length (car words)))\n             (max_unique 0)\n   \
    \          (chosen \"\")\n             (words (cdr words)))\n    (cond\n     \
    \ [(null? words) chosen]\n      [(&gt; min_unique (string-length (car words)))\n\
    \       (loop (string-length (car words)) 0 (car words) (cdr words))]\n      [(=\
    \ min_unique (string-length (car words)))\n       (let* ([curr (car words)]\n\
    \              [curr_unique (count-unique-chars curr)])\n         (cond\n    \
    \       [(&gt; max_unique curr_unique)\n            (loop min_unique curr_unique\
    \ chosen (cdr words))]\n           [(= max_unique curr_unique)\n            (if\
    \ (string&lt;? chosen curr)\n                (loop min_unique curr_unique curr\
    \ (cdr words))\n                (loop min_unique curr_unique chosen (cdr words)))]\n\
    \           [else\n            (loop min_unique curr_unique chosen (cdr words))]))]\n\
    \      [else\n       (loop min_unique max_unique chosen (cdr words))])))\n", " \
    \ (define (uniques word)\n    (let loop ([lst (string-&gt;list word)] [u '()])\n\
    \      (if (null? lst)\n          (length u)\n          (if (member (car lst)\
    \ u)\n              (loop (cdr lst) u)\n              (loop (cdr lst) (cons (car\
    \ lst) u))))))\n  (apply max (map uniques words)))\n</code>\nBased on user input,\
    \ each word is compared to all other words.\n<code>#lang racket\n", "  (if (empty?\
    \ words)\n      #f\n      (define (helper words unique_max answer)\n        (if\
    \ (empty? words)\n            answer\n            (define first_word (first words))\n\
    \            (define unique_char_count (count-unique-characters first_word))\n\
    \            (if (= unique_char_count unique_max)\n                (if (string<\
    \ first_word answer)\n                    (helper (rest words) unique_max first_word)\n\
    \                    (helper (rest words) unique_max answer))\n              \
    \  (if (&gt; unique_char_count unique_max)\n                    (helper (rest\
    \ words) unique_char_count first_word)\n                    (helper (rest words)\
    \ unique_max answer)))))\n      (helper words 0 (first words))))\n", "  (define\
    \ (count-unique words)\n    (define (count_lst lst)\n      (cond\n        [(empty?\
    \ lst) empty]\n        [(char=? (first lst) (second lst)) (count_lst (rest lst))]\n\
    \        [else (cons (first lst) (count_lst (rest lst)))]))\n    (count_lst (string->list\
    \ words)))\n  (define (count_unique_all words)\n    (cond\n      [(empty? words)\
    \ empty]\n      [else (cons (count-unique (first words)) (count_unique_all (rest\
    \ words)))]))\n  (define (find_max_unq words unq_words len)\n    (cond\n     \
    \ [(empty? words) empty]\n      [(>= (length (first unq_words)) len) (cons (first\
    \ words) (find_max_unq (rest words) (rest unq_words) (length (first unq_words))))]\n\
    \      [else (find_max_unq (rest words) (rest unq_words) len)]))\n  (define unq_words\
    \ (count_unique_all words))\n  (find_max_unq words unq_words 0))\n", "  (define\
    \ (unique char-set word)\n    (if (empty? word)\n        char-set\n        (unique\
    \ (set-add char-set (first word)) (rest word))))\n  (define (count-uniques words)\n\
    \    (if (empty? words)\n        '()\n        (cons (list (first words) (length\
    \ (unique '() (first words))))\n              (count-uniques (rest words)))))\n\
    \  (define (compare str1 str2)\n    (if (> (second str1) (second str2))\n    \
    \    #t\n        (if (< (second str1) (second str2))\n            #f\n       \
    \     (string<? (first str1) (first str2)))))\n  (define (maximizer counts)\n\
    \    (if (empty? (rest counts))\n        (first counts)\n        (if (compare\
    \ (first counts) (first (rest counts)))\n            (maximizer (rest counts))\n\
    \            (maximizer (cons (first counts) (rest (rest counts)))))))\n  (first\
    \ (maximizer (count-uniques words))))\n", "  (define (max-words x y)\n    (cond\
    \ [(char-set=? (string-unique-chars x) (string-unique-chars y)) y]\n         \
    \ [(char-set<? (string-unique-chars x) (string-unique-chars y)) y]\n         \
    \ [else x]))\n  (foldl max-words \"\" words))\n", "  (if (null? words) #f\n  \
    \    (let ([current (find_max-help (car words))])\n        (if (null? (cdr words))\
    \ current\n            (if (< (length current) (length (find_max-help (cadr words))))\n\
    \                (find_max (cdr words))\n                (if (= (length current)\
    \ (length (find_max-help (cadr words))))\n                    (if (< (string<?\
    \ (car words) (cadr words)) 0)\n                        (car words)\n        \
    \                (cadr words))\n                    (car words)))))))\n", "  (let\
    \ ([max-word \"\"])\n    (for ([word words])\n      (if (> (length (set (string-&gt;list\
    \ word)))\n            (length (set (string-&gt;list max-word))))\n          (set!\
    \ max-word word)))\n    max-word))\n", "  (define (counter word)\n    (for/fold\
    \ ([table (hash)]\n               [chars (list)])\n        ([ch (in-string word)])\n\
    \      (when (not (hash-has-key? table ch))\n        (set! table (hash-set table\
    \ ch #t))\n        (set! chars (cons ch chars)))\n      chars))\n  (let ([chars\
    \ (map counter words)])\n    (let ([max (apply max (map length chars))])\n   \
    \   (for/first ([(word chars) (in-list (zip words chars))])\n        (and (= (length\
    \ chars) max)\n             word)))))\n", "  (apply max (for/list ([w words])\n\
    \                (list (length (remove-duplicates (char-set w))) w))))\n", " \
    \ (define (count-uniques w)\n    (length (map symbol-&gt;string (hash-keys (for/hash\
    \ ([c (in-string w)])\n                                              (hash c))))))\n\
    \  (foldr (\u03BB (cur-word max-so-far)\n           (if (&gt; (count-uniques cur-word)\n\
    \                  (count-uniques max-so-far))\n               cur-word\n    \
    \           max-so-far))\n         (first words)\n         (rest words)))\n",
  "  (if (empty? words)\n      \"\"\n      (let* ([max-unique-count (unique-char-count\
    \ (first words))]\n             [max-word (first words)])\n        (for ([word\
    \ (rest words)])\n          (if (> (unique-char-count word) max-unique-count)\n\
    \              (begin\n                (set! max-unique-count (unique-char-count\
    \ word))\n                (set! max-word word))))\n        max-word)))\n", " \
    \ (define (char-list str)\n    (list->set (string->list str)))\n  (define (max-unique\
    \ list-of-strings)\n    (apply max\n           (map (lambda (word)\n         \
    \         (length (char-list word)))\n                list-of-strings)))\n  (define\
    \ (words-with-max list-of-strings)\n    (filter (lambda (word)\n             \
    \ (= (length (char-list word))\n                 (max-unique list-of-strings)))\n\
    \            list-of-strings))\n  (apply min (words-with-max words)))\n```\n\n\
    ```racket\n#lang racket\n", "  (cond [(empty? words) \"\"]\n        [(= (length\
    \ (set words)) 1) (first words)]\n        [else (let ([w1 (first words)]\n   \
    \                 [w2 (first (rest words))])\n                (if (> (length (set\
    \ w1)) (length (set w2)))\n                    w1\n                    w2))]))\n",
  "  (match words\n    [() '()]\n    [(word) word]\n    [(list-rest words)\n     (define\
    \ first (car words))\n     (define rest (cdr words))\n     (define max (find_max\
    \ rest))\n     (define (count-chars str)\n       (length (fold (lambda (char set)\n\
    \                       (set-add char set))\n                     (make-set)\n\
    \                     (string->list str))))\n     (define first-count (count-chars\
    \ first))\n     (define max-count (count-chars max))\n     (cond\n       [(> first-count\
    \ max-count) first]\n       [(string<? first max) first]\n       [else max]))]))\n",
  "  (local [(define (count-distinct-chars word)\n            (length (remove-duplicates\
    \ (string->list word))))]\n    (first (sort (filter (lambda (word)\n         \
    \                  (equal? (count-distinct-chars word)\n                     \
    \              (count-distinct-chars (first words))))\n                      \
    \   words)\n                string<?))))\n", "  (let ([max-word (first words)]\n\
    \        [max-count 0])\n    (for ([word words])\n      (let ([uniq-chars (unique-chars\
    \ word)])\n        (if (&gt; (length uniq-chars) max-count)\n            (begin\n\
    \              (set! max-word word)\n              (set! max-count (length uniq-chars))))))\n\
    \    max-word))\n", "  (find_max_helper words (list)))\n", "  (define (max-unique-chars?\
    \ str1 str2)\n    (cond\n      [(> (unique-chars-count str1) (unique-chars-count\
    \ str2)) #t]\n      [(< (unique-chars-count str1) (unique-chars-count str2)) #f]\n\
    \      [else (string<? str1 str2)]))\n  (define (unique-chars-count str)\n   \
    \ (length (remove-duplicates (string->list str))))\n  (foldr max-unique-chars?\
    \ (car words) (cdr words)))\n", "  (cond\n    [(empty? words) empty]\n    [(=\
    \ (length (remove-duplicates (first words))) (length (remove-duplicates (second\
    \ words)))) (find_max (rest words))]\n    [else (first words)]))\n</code>\nFor\
    \ example, \n<code>(find_max (list \"klm\" \"abc\" \"hij\" \"lmn\"))\n</code>\n\
    should return <code>\"hij\"</code>. I keep getting the error:\n<code>application:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: #&lt;syntax:lang:16:0 or/c&gt;\n  arguments...:\n   #&lt;undefined&gt;\n\
    </code>\nI guess there is something wrong with my <code>cond</code> function.\
    \ Could you please help me to fix this?\n\n\nA:\n\nYour arguments to <code>cond</code>\
    \ aren't proper Racket lists, because you've omitted the parentheses and put the\
    \ word <code>empty</code> there instead. That's why you get the error you get.\n\
    Also, there's nothing special about <code>empty</code>, it's just a word like\
    \ any other word, and it's not even a word Racket recognizes (it's unbound). If\
    \ you want to check for the empty list, you need to write <code>'()</code> (note\
    \ the quote), or better yet, just <code>()</code> - there's no need to quote it.\n\
    Here's an improved version of your code:\n<code>(define (find_max words)\n  (cond\n\
    \    [(empty? words) ()]\n    [(= (length (remove-duplicates (first words)))\n\
    \        (length (remove-duplicates (second words))))\n     (find_max (rest words))]\n\
    \    [else (first words)]))\n</code>\nAlso, as Alex points out, this is not a\
    \ very efficient algorithm because you're repeatedly computing the same thing.\
    \ A better implementation would be to first compute the unique characters in each\
    \ word, store the results in a list, and then pick the one with the maximum length:\n\
    <code>(define (find-max words)\n  (for/first ([[word chars] (", "  (cond\n   \
    \ [(null? words) #f]\n    [(equal? 1 (length words)) (car words)]\n    [else\n\
    \     (let ([first (car words)]\n           [second (cadr words)])\n       (if\
    \ (> (length (remove-duplicates (char-set first)))\n              (length (remove-duplicates\
    \ (char-set second))))\n           (find_max (cons first (cddr words)))\n    \
    \       (find_max (cons second (cddr words)))))]))\n", "  (if (null? words)\n\
    \      \"\"\n      (find_max' words (car words) (unique-chars (car words)))))\n",
  "  (cond\n    [(empty? words) (error \"can't find max in empty list\")]\n    [(empty?\
    \ (rest words)) (first words)]\n    [else\n     (let ([max (first words)]\n  \
    \         [tail (rest words)])\n       (while (not (empty? tail))\n         (define\
    \ candidate (first tail))\n         (define candidate-unique-chars (unique-chars\
    \ candidate))\n         (define max-unique-chars (unique-chars max))\n       \
    \  (if (&gt; (length candidate-unique-chars)\n                 (length max-unique-chars))\n\
    \             (set! max candidate)\n             (when (and (= (length candidate-unique-chars)\n\
    \                           (length max-unique-chars))\n                     \
    \   (string&lt;? candidate max))\n               (set! max candidate)))\n    \
    \     (set! tail (rest tail)))\n       max)]))\n</code>\nWhich works when called\
    \ like this:\n<code>&gt; (find-max (list \"a\" \"ab\" \"abc\" \"b\" \"bc\" \"\
    bb\" \"c\"))\n\"ab\"\n</code>\n", "  (apply max\n         (map (lambda (word)\n\
    \                (cons word (length (remove-duplicates (string->list word)))))\n\
    \              words)))\n```\n\n```racket\n#lang racket\n", "  (find-first-max\
    \ words (lambda (w) (list-length (list-uniq (string->list w))))))\n", "  (apply\
    \ max (map (lambda (word)\n                    (hash word))\n                \
    \  words)))\n", "  (define (max-by f xs)\n    (apply max (map f xs)))\n  (define\
    \ (length-of-set string)\n    (length (set (string->list string))))\n  (max-by\
    \ length-of-set words))\n", "  (define (compare-words word1 word2)\n    (define\
    \ (get-unique-chars word)\n      (set! word (sort word))\n      (define (get-unique-chars-inner\
    \ word uniques)\n        (cond ((null? word) (reverse uniques))\n            \
    \  ((= (car word) (cadr word))\n               (get-unique-chars-inner (cdr word)\
    \ uniques))\n              (else (get-unique-chars-inner (cdr word) (cons (car\
    \ word) uniques)))))\n      (get-unique-chars-inner word '()))\n    (let ((unique-chars-of-word1\
    \ (get-unique-chars word1))\n          (unique-chars-of-word2 (get-unique-chars\
    \ word2)))\n      (cond ((> (length unique-chars-of-word1) (length unique-chars-of-word2))\
    \ word1)\n            ((< (length unique-chars-of-word1) (length unique-chars-of-word2))\
    \ word2)\n            (else (cond ((< (string-ci<? word1 word2) 0) word1)\n  \
    \                      ((< (string-ci<? word2 word1) 0) word2)\n             \
    \           (else word1)))))))\n  (cond ((null? words) '())\n        ((null? (cdr\
    \ words)) (car words))\n        (else (compare-words (car words) (find_max (cdr\
    \ words))))))\n", "  (define (unique-chars str)\n    (hash-count (hash-set str)))\n\
    \  (define (max-unique words)\n    (foldr (lambda (a b)\n             (cond ((>\
    \ (unique-chars a) (unique-chars b)) a)\n                   ((< (unique-chars\
    \ a) (unique-chars b)) b)\n                   ((= (unique-chars a) (unique-chars\
    \ b))\n                    (cond ((string<? a b) a)\n                        \
    \  ((string>? a b) b)\n                          (else a)))))\n           (car\
    \ words)\n           (cdr words)))\n  (max-unique words))\n```\n\n8. Write a program\
    \ that accepts a string as input, and returns a list of all\nthe substrings of\
    \ the input in reverse order. For example, if the input is\n\"abc\", then the\
    \ output should be '(\"c\" \"b\" \"a\" \"bc\" \"ab\" \"abc\").\n\n```racket\n\
    #lang racket\n", "  (if (null? words)\n      \"\"\n      (let ([word (first words)]\n\
    \            [max (string-&gt;list word)])\n        (for ([w (rest words)])\n\
    \          (let ([chars (string-&gt;list w)])\n            (if (&gt; (length (set-add\
    \ chars (set-&gt;list max)))\n                   (length max))\n             \
    \   (set! max chars)\n                (set! word w))))\n        (string-&gt;list\
    \ word))))\n</code>\n", "  (cond\n    [(empty? words) (error \"empty list\")]\n\
    \    [(singleton? words) (first words)]\n    [else\n     (define max (first words))\n\
    \     (define rest (rest words))\n     (define max-len (length (set (string->list\
    \ max))))\n     (define rest-len (length (set (string->list (first rest)))))\n\
    \     (cond\n       [(> max-len rest-len) (find_max (cons max (rest (rest words))))]\n\
    \       [(< max-len rest-len) (find_max (cons (first rest) (rest (rest words))))]\n\
    \       [else\n        (cond\n          [(string<? max (first rest)) (find_max\
    \ (cons max (rest (rest words))))]\n          [else (find_max (cons (first rest)\
    \ (rest (rest words))))])])])\n  )\n```\n\nThis is the solution to the problem.\n\
    \n```racket\n#lang racket\n", "  (for/fold ([acc (first words)]\n            \
    \ [max-count 0])\n      ([word (in-list (rest words))])\n    (let ([unique-chars\
    \ (unique-letters word)])\n      (cond\n        [(> (length unique-chars) max-count)\n\
    \         (values word (length unique-chars))]\n        [(= (length unique-chars)\
    \ max-count)\n         (if (string<? acc word)\n             (values acc max-count)\n\
    \             (values word max-count))]\n        [else (values acc max-count)]))))\n",
  "  (find-first-max words))\n", "  (define (countUniqueChars str)\n    (let loop\
    \ ([myStr str] [myLst (list)] [count 0])\n      (cond\n        [(null? myStr)\
    \ count]\n        [(member (car myStr) myLst) (loop (cdr myStr) myLst count)]\n\
    \        [else (loop (cdr myStr) (cons (car myStr) myLst) (+ count 1))])))\n \
    \ (define (maxwords max_sofar my_words)\n    (if (null? my_words)\n        max_sofar\n\
    \        (let ([current (car my_words)])\n          (if (> (countUniqueChars current)\
    \ (countUniqueChars max_sofar))\n              (maxwords current (cdr my_words))\n\
    \              (maxwords max_sofar (cdr my_words))))))\n  (maxwords (car words)\
    \ (cdr words)))\n", "  (define (sort-by-length l)\n    (sort l < #:key string-length))\n\
    \  (define (is-unique? str)\n    (let loop ([input str] [acc '()])\n      (cond\n\
    \        [(empty? input) acc]\n        [(char=? (first input) (first acc))\n \
    \        (loop (rest input) acc)]\n        [else (loop (rest input) (cons (first\
    \ input) acc))])))\n  (define (find-max-by-unique words)\n    (define (find-unique-len\
    \ words)\n      (apply max (map string-length (map is-unique? words))))\n    (define\
    \ (find-lexical-max words)\n      (filter (lambda (word)\n                (= (string-length\
    \ (is-unique? word))\n                   (find-unique-len words)))\n         \
    \     words))\n    (first (sort-by-length (find-lexical-max words))))\n  (find-max-by-unique\
    \ words))\n", "  (if (empty? words)\n      \"\"\n      (let ([word (first words)])\n\
    \        (if (empty? (rest words))\n            word\n            (if (> (unique-chars\
    \ word) (unique-chars (find_max (rest words))))\n                word\n      \
    \          (find_max (rest words)))))))\n", "  (define (unique-chars str)\n  \
    \  (set! str (string-&gt;list str))\n    (set! str (remove-duplicates str))\n\
    \    (list-&gt;string str))\n  (define (max-1 lst)\n    (let ([max-so-far (car\
    \ lst)])\n      (for ([candidate (in-list (cdr lst))])\n        (when (&gt; (string-length\
    \ (unique-chars candidate))\n                  (string-length (unique-chars max-so-far)))\n\
    \          (set! max-so-far candidate)))\n      max-so-far))\n  (max-1 words))\n\
    </code>\n", "  (let loop ((words words)\n             (curr_max \"\"))\n    (cond\
    \ ((null? words) curr_max)\n          ((&gt; (length (remove-duplicates (string-&gt;list\
    \ (car words))))\n              (length (remove-duplicates (string-&gt;list curr_max))))\n\
    \           (loop (cdr words) (car words)))\n          (else (loop (cdr words)\
    \ curr_max)))))\n</code>\nSample use:\n<code>(find_max '(\"one\" \"two\" \"three\"\
    \ \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\" \"ten\"))\n", "  (define\
    \ (count-uniques word)\n    (let ([count (for/fold ([uniques (hash)]) ([c (in-string\
    \ word)])\n                  (if (hash-ref uniques c #f)\n                   \
    \   uniques\n                      (hash-set uniques c 1)))])\n      (hash-count\
    \ count)))\n  (for/first ([word (in-list words)]\n              #:when (equal?\
    \ (count-uniques word)\n                             (apply max (map count-uniques\
    \ words))))\n    word))\n", "  (first (sort words #:key (lambda (w) (count-unique-chars\
    \ w)) #:reverse? #t)))\n", "  (if (null? words)\n      (error \"Can't find the\
    \ maximum of an empty list\")\n      (let ([max (first words)])\n        (for\
    \ ([word (rest words)])\n          (if (or\n               (and (string=? (string-length\
    \ max) (string-length word))\n                    (string<? word max))\n     \
    \          (and (string<? (string-length max) (string-length word))\n        \
    \            (string=? (string-length max) (length (remove-duplicates (string->list\
    \ word)))))\n               (and (string<? (string-length max) (string-length\
    \ word))\n                    (string<? (length (remove-duplicates (string->list\
    \ max))) (length (remove-duplicates (string->list word))))))\n              (set!\
    \ max word)))\n        max)))\n", "  (apply max (map char-count words)))\n", " \
    \ (foldl (lambda (x xs) (if (or (null? xs)\n                                (<\
    \ (length (unique-chars x))\n                                   (length (unique-chars\
    \ (car xs)))))\n                         xs\n                         (if (= (length\
    \ (unique-chars x))\n                                (length (unique-chars (car\
    \ xs))))\n                             (if (string-ci>? x (car xs))\n        \
    \                         xs\n                                 (cons x xs))\n\
    \                             (cons x xs))))\n         (list)\n         words))\n",
  "  (cond [(empty? words) (error \"Empty list\")]\n        [(empty? (rest words))\
    \ (first words)]\n        [else\n         (let ((first-word (first words))\n \
    \              (rest-words (rest words)))\n           (let loop ((first-word (first\
    \ words))\n                      (rest-words (rest words)))\n             (cond\
    \ [(empty? rest-words) first-word]\n                   [else\n               \
    \     (define next-word (first rest-words))\n                    (cond [(> (count-unique-chars\
    \ first-word)\n                              (count-unique-chars next-word))\n\
    \                           (loop first-word (rest rest-words))]\n           \
    \               [(< (count-unique-chars first-word)\n                        \
    \      (count-unique-chars next-word))\n                           (loop next-word\
    \ (rest rest-words))]\n                          [else\n                     \
    \      (if (string<? first-word next-word)\n                               (loop\
    \ first-word (rest rest-words))\n                               (loop next-word\
    \ (rest rest-words)))])]))))]))\n", "  (apply max (map string-length words)))\n",
  "  (define (count_unique word)\n    (length (delete-duplicates (string->list word))))\n\
    \  (apply max (map count_unique words)))\n", "  (letrec ([max_uniq_word (car words)]\n\
    \           [max_uniq_char (length (unique (string-&gt;list (car words))))])\n\
    \    (for ([i (in-list (cdr words))])\n      (let ([char_count (length (unique\
    \ (string-&gt;list i)))])\n        (if (&gt; char_count max_uniq_char)\n     \
    \       (begin\n              (set! max_uniq_word i)\n              (set! max_uniq_char\
    \ char_count))\n            (if (= char_count max_uniq_char)\n               \
    \ (if (&lt; i max_uniq_word)\n                    (set! max_uniq_word i))))))\n\
    \    max_uniq_word))\n", "  (define unique-characters (make-hash))\n  (for ([word\
    \ words])\n    (for ([c (in-string word)])\n      (hash-set! unique-characters\
    \ c #t)))\n  (define char-count (hash-count unique-characters))\n  (define (word-char-count\
    \ word)\n    (hash-count (for/hash ([c (in-string word)])\n                  (hash-set\
    \ unique-characters c #t))))\n  (for/first ([word words])\n    (if (= char-count\
    \ (word-char-count word))\n        word)))\n", "  (cond [(empty? words) empty]\n\
    \        [else\n         (define rest-words (rest words))\n         (if (empty?\
    \ rest-words)\n             (first words)\n             (let* ([w1 (first words)]\n\
    \                    [w2 (find_max rest-words)]\n                    [w1-len (length\
    \ (unique-chars w1))]\n                    [w2-len (length (unique-chars w2))])\n\
    \               (if (> w1-len w2-len)\n                   w1\n               \
    \    (if (> w2-len w1-len)\n                       w2\n                      \
    \ (if (string&lt;=? w1 w2)\n                           w1\n                  \
    \         w2)))))]))\n</code>\n", "  (cond [(empty? words) empty]\n        [else\n\
    \         (let ([max (string-unique-chars (first words))])\n           (for/fold\
    \ ([max (string-unique-chars (first words))]\n                      [result (first\
    \ words)])\n                      ([x (in-list (rest words))])\n             (if\
    \ (> (string-unique-chars x) max)\n                 (values (string-unique-chars\
    \ x) x)\n                 (values max result))))]))\n", "  (let ([max-characters\
    \ 0]\n        [max-words '()])\n    (for ([word words])\n      (let ([unique-characters\
    \ (remove-duplicates (string->list word))])\n        (cond\n          [(> (length\
    \ unique-characters) max-characters)\n           (set! max-characters (length\
    \ unique-characters))\n           (set! max-words (list word))]\n          [(=\
    \ (length unique-characters) max-characters)\n           (set! max-words (append\
    \ max-words (list word)))])))\n    (apply min max-words)))\n```\n\n4. Write a\
    \ function that accepts a list of strings. The list contains\ndifferent words.\
    \ Return a list of all words such that the word appears in\nthe list at least\
    \ twice. Return the words in lexicographical order.\n\n```racket\n#lang racket\n",
  "  (define (count-unique-chars word)\n    (length (remove-duplicates (string->list\
    \ word))))\n  (define (get-word-with-max-unique-chars words)\n    (let loop ((words\
    \ words)\n               (current-max-len -1)\n               (current-max-word\
    \ \"\")\n               (current-max-words (list)))\n      (cond\n        [(empty?\
    \ words)\n         (if (length current-max-words)\n             (apply min current-max-words)\n\
    \             current-max-word)]\n        [(> (count-unique-chars (first words))\
    \ current-max-len)\n         (loop (rest words)\n               (count-unique-chars\
    \ (first words))\n               (first words)\n               (list (first words)))]\n\
    \        [(= (count-unique-chars (first words)) current-max-len)\n         (loop\
    \ (rest words)\n               current-max-len\n               current-max-word\n\
    \               (cons (first words) current-max-words))]\n        [else\n    \
    \     (loop (rest words)\n               current-max-len\n               current-max-word\n\
    \               current-max-words)])))\n  (get-word-with-max-unique-chars words))\n",
  "  (if (null? words)\n      \"\"\n      (define (max-uniq-chars word1 word2)\n \
    \       (if (null? word1) #t\n            (define char (car word1))\n        \
    \    (cond\n              ((null? (member char word2)) #f)\n              ((null?\
    \ (cdr word1)) #t)\n              (else (max-uniq-chars (cdr word1) word2)))))\n\
    \      (define (max-uniq-chars-count word1 word2)\n        (if (null? word1) 0\n\
    \            (define char (car word1))\n            (cond\n              ((null?\
    \ (member char word2)) (+ 1 (max-uniq-chars-count (cdr word1) word2)))\n     \
    \         ((null? (cdr word1)) 0)\n              (else (max-uniq-chars-count (cdr\
    \ word1) word2)))))\n      (define (max-chars word)\n        (if (null? word)\
    \ '()\n            (define char (car word))\n            (cond\n             \
    \ ((null? (member char (cdr word))) (cons char (max-chars (cdr word))))\n    \
    \          ((null? (cdr word)) '())\n              (else (max-chars (cdr word))))))\n\
    \      (define (has-same-chars word1 word2)\n        (max-uniq-chars word1 word2))\n\
    \      (define (best-word words)\n        (if (null? words) '()\n            (cond\n\
    \              ((null? (cdr words)) (car words))\n              (else (let* ((chars1\
    \ (max-chars (car words)))\n                           (chars2 (max-chars (cadr\
    \ words)))\n                           (has-same (has-same-chars chars1 chars2)))\n\
    \                      (cond\n                        (has-same (if (< (string<?\
    \ (car words) (cadr words)) 0)\n                                      (car words)\n\
    \                                      (cadr words)))\n                      \
    \  (else (best-word (cdr words)))))))))\n      (best-word words)))\n", "  (apply\
    \ max\n         (map (\u03BB (word)\n                (length (set (string-&gt;list\
    \ word))))\n              words)))\n", "  (for/fold ([result \"\"]) ([word words])\n\
    \    (cond\n      [(> (count-occurrences (string-&gt;list word) #:test equal?)\n\
    \          (count-occurrences (string-&gt;list result) #:test equal?))]\n    \
    \  [else (void)])))\n</code>\nI found this quite useful and a good exercise as\
    \ well.\n\n\nA:\n\nOne obvious optimization would be to count all of the words\
    \ once at the beginning, and then use <code>map</code> to pull out the top score\
    \ and the word with that score.  In other words, you can get rid of the <code>for/fold</code>\
    \ (along with its quadratic complexity) if you calculate the winner in advance:\n\
    <code>(define (find-max words)\n  (match (map count-unique words)\n    [(list\
    \ top-score top-word . rest) top-word]))\n", "  (for/first ([word words]\n   \
    \           #:when (equal? (count-unique-chars word)\n                       \
    \      (apply max (map count-unique-chars words))))\n    word))\n", "  (cond\n\
    \    [(empty? words) \"\"]\n    [(equal? words (rest words)) (first words)]\n\
    \    [else\n     (let ([(first-word . first-rest) words]\n           [(second-word\
    \ . second-rest) (rest words)])\n       (if (&gt; (length (string-&gt;set first-word))\n\
    \              (length (string-&gt;set second-word)))\n           (find_max (cons\
    \ first-word second-rest))\n           (find_max (cons second-word first-rest))))]))\n",
  "  (foldl (lambda (x y) (cond\n                    ((&gt; (count_uniques x) (count_uniques\
    \ y)) x)\n                    ((equal? (count_uniques x) (count_uniques y))\n\
    \                     (cond\n                      ((&lt; (string-ci&lt;=? x y)\
    \ 0) x)\n                      (else y)))\n                    (else y)))\n  \
    \       \"\"\n         words))\n", "  (local [(define (unique-chars word)\n  \
    \          (set-difference (string-&gt;list word) (list-&gt;set (string-&gt;list\
    \ word))))\n           (define (max-unique word best-so-far)\n             (cond\
    \ [(empty? words) best-so-far]\n                   [(&gt; (length (unique-chars\
    \ word)) (length (unique-chars best-so-far)))\n                    (max-unique\
    \ (first words) word)]\n                   [(string=? word best-so-far)\n    \
    \                (max-unique (first words) best-so-far)]\n                   [else\
    \ (max-unique (first words) best-so-far)]))]\n    (if (empty? words)\n       \
    \ empty\n        (max-unique (first words) (first words)))))\n</code>\nI'm a bit\
    \ confused. What's the difference between <code>max-unique</code> and <code>find_max</code>?\
    \ It looks like <code>find_max</code> is just a wrapper for <code>max-unique</code>.\n\
    I'm not sure if I'm using <code>set-difference</code> correctly. I also think\
    \ that this seems awfully complicated. \n\n\nA:\n\nGood questions!\nThe difference\
    \ between <code>max-unique</code> and <code>find_max</code> is that <code>max-unique</code>\
    \ finds the maximal word from a single word with respect to the number of unique\
    \ characters. <code>find_max</code> finds the maximal word from an entire list\
    \ of words with respect to the number of unique characters.\nYou're correct, there's\
    \ an issue with how <code>max-unique</code> uses <code>set-difference</code>.\
    \ The problem is that the second argument to <code>set-difference</code> cannot\
    \ contain any elements that don't appear in the first argument. For example, if\
    \ you call <code>(set-difference '(1 2 3) '(1 2 3 4))</code>, you'll get an error\
    \ because <code>4</code> doesn't appear in the first argument.\nAnyway, your code\
    \ seems unnecessarily complicated to me. <code>max-unique</code> is always called\
    \ with <code>word</code", "  (if (null? words)\n      \"\"\n      (letrec ([max-chars\
    \ (apply max (map (lambda (word) (length (for/set ([char (in-string word)]) (char-set\
    \ char)))) words))]\n               [matching-words (for/list ([word words]\n\
    \                                          #:when (= (length (for/set ([char (in-string\
    \ word)]) (char-set char))) max-chars))\n                                 word)])\n\
    \        (apply min matching-words))))\n</code>\n", "  (let ((max-word \"\")\n\
    \        (max-num-chars 0))\n    (for ((word words))\n      (let ((chars (string-&gt;list\
    \ word)))\n        (if (&gt; (set-length chars) max-num-chars)\n            (begin\n\
    \              (set! max-word word)\n              (set! max-num-chars (set-length\
    \ chars))))))\n    max-word))\n", "  (apply min\n         (map #:key (lambda (s)\
    \ (length (remove-duplicates (string->list s))))\n              words)))\n", " \
    \ (apply max (for/list ([word words])\n               (cons (length (unique-chars\
    \ word)) word))))\n", "  (let* ([uniq-words (map (curry append (list 'uniq)) words)]\n\
    \         [words-counts (map (curry append (list (string-length (string-set (second\
    \ uniq-words)))))) uniq-words]\n         [counts (map (curry append (list (second\
    \ words-counts))) words-counts)]\n         [max-count (apply max (map (curry append\
    \ (list (second counts))) counts))]\n         [words-count (filter (curry equal?\
    \ max-count) counts)]\n         [words-count (apply min words-count)]\n      \
    \   [max-count (second words-count)]\n         [words-count (filter (curry equal?\
    \ max-count) counts)]\n         [words-count (map (lambda (x) (first x)) words-count)]\n\
    \         [words-count (apply min words-count)])\n    words-count))\n", "  (let\
    \ ([charset (string-set)])\n    (for ([w words])\n      (for ([c (string->list\
    \ w)])\n        (set! charset (set-add charset c))))\n    (sort words < #:key\
    \ (lambda (w) (set-count charset w)))))\n", "  (define unique-characters (map\
    \ (lambda (word) (list (list-ref word 0) (count-distinct-chars word))) words))\n\
    \  (define max-count (apply max (map (lambda (x) (list-ref x 1)) unique-characters)))\n\
    \  (define filtered-characters (filter (lambda (x) (= (list-ref x 1) max-count))\
    \ unique-characters))\n  (define filtered-words (map (lambda (x) (list-ref x 0))\
    \ filtered-characters))\n  (apply min filtered-words))\n", '  (apply max (map
    unique-chars words)))', "  (define (count-unique-characters word)\n    (cond\n\
    \      [(empty? word) 0]\n      [(member (first word) (rest word)) (count-unique-characters\
    \ (rest word))]\n      [else (+ 1 (count-unique-characters (rest word)))]))\n\
    \  (define (uniq-characters-for-word word)\n    (apply max (map count-unique-characters\
    \ word)))\n  (apply min (map (\u03BB (word) (list (uniq-characters-for-word word)\
    \ word)) words)))\n", "  (first\n   (sort\n    words\n    (\u03BB (a b)\n    \
    \  (or\n       (not (= (length (unique a)) (length (unique b))))\n       (< a\
    \ b))))))", "  (let loop ((words words)\n             (max-word \"\")\n      \
    \       (max-len 0))\n    (if (null? words)\n        max-word\n        (let* ((word\
    \ (car words))\n               (len (length (string-unique-chars word))))\n  \
    \        (if (&gt; len max-len)\n              (loop (cdr words) word len)\n \
    \             (if (= len max-len)\n                  (if (string&lt;? word max-word)\n\
    \                      (loop (cdr words) word len)\n                      (loop\
    \ (cdr words) max-word len))\n                  (loop (cdr words) max-word max-len)))))))\n",
  "  (define (get-letters word)\n    (filter (lambda (char)\n              (not (char=?\
    \ char #\\ )))\n            (string->list word)))\n  (define (max-words words)\n\
    \    (foldl (lambda (word max-word)\n             (if (> (length (set (get-letters\
    \ word)))\n                    (length (set (get-letters max-word))))\n      \
    \           word\n                 max-word))\n           '()\n           words))\n\
    \  (max-words words))\n", "  (define (unique_chars word)\n    (cond [(empty? word)\
    \ empty]\n          [(member (first word) (rest word)) (unique_chars (rest word))]\n\
    \          [else (cons (first word) (unique_chars (rest word)))]))\n  (define\
    \ (word_max w wds)\n    (if (empty? wds) w\n        (let ([cur-word (first wds)])\n\
    \          (if (< (length (unique_chars cur-word)) (length (unique_chars w)))\n\
    \              (word_max w (rest wds))\n              (word_max cur-word (rest\
    \ wds))))))\n  (word_max (first words) (rest words)))\n", "  (define (word-char-set\
    \ word)\n    (set-add-list word))\n  (define (word-char-count word)\n    (length\
    \ (word-char-set word)))\n  (define (word-uniq-char-count word)\n    (set-count\
    \ (word-char-set word)))\n  (define (helper words max-word)\n    (cond [(empty?\
    \ words) max-word]\n          [(or (> (word-uniq-char-count (first words))\n \
    \                (word-uniq-char-count max-word))\n               (and (= (word-uniq-char-count\
    \ (first words))\n                       (word-uniq-char-count max-word))\n  \
    \                  (string<? (first words) max-word)))\n           (helper (rest\
    \ words) (first words))]\n          [else (helper (rest words) max-word)]))\n\
    \  (helper words (first words)))\n", "  (let loop ((words words)\n           \
    \  (max-word \"\")\n             (max-count 0))\n    (cond\n      [(empty? words)\
    \ max-word]\n      [(< max-count (length (remove-duplicates (first words))))\n\
    \       (loop (rest words)\n             (first words)\n             (length (remove-duplicates\
    \ (first words))))]\n      [else (loop (rest words)\n                  max-word\n\
    \                  max-count)])))\n", "  (let loop ((first (car words))\n    \
    \         (rest (cdr words)))\n    (cond\n      ((null? rest) first)\n      ((>\
    \ (length (list-distinct (string->list first)))\n          (length (list-distinct\
    \ (string->list (car rest)))))\n       (loop first (cdr rest)))\n      (else (loop\
    \ (car rest) (cdr rest))))))\n", "  (if (empty? words)\n      \"\"\n      (cond\n\
    \        [(< (length (uniquify (first words)))\n            (length (uniquify\
    \ (find_max (rest words)))))\n         (find_max (rest words))]\n        [else\n\
    \         (first words)])))\n", "  (define (uniques word)\n    (hash-remove (hash-remove\
    \ (hash-remove (hash-remove (hash-remove empty-hash ' ') '\\n') '\\t') '\\b')\
    \ '\\r'))\n  (define (unique-count word)\n    (hash-count (uniques word)))\n \
    \ (let recur ((words words) (max-uniques 0) (max-word '()))\n    (cond [(empty?\
    \ words) max-word]\n          [(> (unique-count (first words)) max-uniques)\n\
    \           (recur (rest words) (unique-count (first words)) (first words))]\n\
    \          [(< (unique-count (first words)) max-uniques)\n           (recur (rest\
    \ words) max-uniques max-word)]\n          [(and (= (unique-count (first words))\
    \ max-uniques)\n                (string<? (first words) max-word))\n         \
    \  (recur (rest words) max-uniques max-word)]\n          [else (recur (rest words)\
    \ max-uniques (first words))])))\n```\n\n```\n> (find-max '(\"abbc\" \"abbd\"\
    \ \"abbc\" \"abbcc\" \"abbde\"))\n\"abbc\"\n```\n\n## 2.2\n\n```racket\n#lang\
    \ racket\n", "  (define (unique-chars word)\n    (set! word (string-&gt;list word))\n\
    \    (set! word (remove-duplicates word))\n    (length word))\n  (define (max-chars\
    \ words)\n    (apply max (map unique-chars words)))\n  (define (max-lex words)\n\
    \    (define (is-max word)\n      (= (unique-chars word) (max-chars words)))\n\
    \    (filter is-max words))\n  (argmin string-&lt;? (max-lex words)))\n</code>\n\
    Please excuse, if the solution is too verbose. I am new to the functional approach.\n",
  "  (define (helper words max current)\n    (if (null? words)\n        max\n    \
    \    (let ((next (car words)))\n          (if (< (length (unique-chars next))\n\
    \                 (length (unique-chars current)))\n              (helper (cdr\
    \ words) max current)\n              (helper (cdr words) next next)))))\n  (helper\
    \ (cdr words) (car words) (car words)))\n", "  (cond [(empty? words) empty]\n\
    \        [else\n         (let* ([current (first words)]\n                [rest\
    \ (rest words)]\n                [current-unique (count-set (chars current))]\n\
    \                [current-max (find_max rest)])\n           (cond [(empty? current-max)\
    \ current]\n                 [(<= (count-set (chars current-max)) current-unique)\
    \ current]\n                 [else current-max]))]))\n", "  (cond\n    [(empty?\
    \ words) (error \"empty list\")]\n    [(= 1 (length words)) (first words)]\n \
    \   [else\n     (let ([max-word (first words)]\n           [max-uniq-chars (length\
    \ (remove-duplicates (string->list (first words))))])\n       (for ([word (rest\
    \ words)])\n         (let ([uniq-chars (length (remove-duplicates (string->list\
    \ word)))])\n           (cond\n             [(> uniq-chars max-uniq-chars)\n \
    \             (set! max-word word)\n              (set! max-uniq-chars uniq-chars)]\n\
    \             [(and (= uniq-chars max-uniq-chars)\n                   (string<?\
    \ max-word word))\n              (set! max-word word)])))))\n     max-word]))",
  "  (define (count_chars s)\n    (apply + (for/list ([chars (in-list (string-&gt;list\
    \ s))])\n                (if (not (char-set-member? chars #hash(\"\")))\n    \
    \                1\n                    0))))\n  (car (sort\n         (sort words\
    \ &lt; #:key (compose count_chars string-upcase))\n         &gt; #:key (compose\
    \ count_chars string-upcase))))\n", "  (first words))\n", "  (let loop ((words\
    \ words)\n             (max_word '())\n             (max_word_len 0))\n    (cond\n\
    \      [(empty? words) max_word]\n      [(> (length (set (first words))) max_word_len)\n\
    \       (loop (rest words) (first words) (length (set (first words))))]\n    \
    \  [(= (length (set (first words))) max_word_len)\n       (cond\n         [(string>?\
    \ (first words) max_word)\n          (loop (rest words) (first words) (length\
    \ (set (first words))))]\n         [else (loop (rest words) max_word max_word_len)])]\n\
    \      [else (loop (rest words) max_word max_word_len)])))\n</code>\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
