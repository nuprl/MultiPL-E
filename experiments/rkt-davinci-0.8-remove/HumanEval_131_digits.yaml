name: HumanEval_131_digits
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer n, return the product of the\
  \ odd digits.\n;; Return 0 if all digits are even.\n;; For example:\n;; >>> digits(1)\
  \ \n;; 1\n;; >>> digits(4) \n;; 0\n(define (digits n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n\
  \    (check-equal? (candidate 5) 5)\n    (check-equal? (candidate 54) 5)\n    (check-equal?\
  \ (candidate 120) 1)\n    (check-equal? (candidate 5014) 5)\n    (check-equal? (candidate\
  \ 98765) 315)\n    (check-equal? (candidate 5576543) 2625)\n    (check-equal? (candidate\
  \ 2468) 0)\n))\n\n(test-humaneval)"
completions: ["  (define (rec n)\n    (cond\n      [(zero? n) 1]\n      [(odd? (remainder\
    \ n 10)) (* (remainder n 10) (rec (quotient n 10)))]\n      [else (rec (quotient\
    \ n 10))]))\n  (rec n))\n", "  (cond\n    [(= n 0) 0]\n    [(odd? (remainder n\
    \ 10)) (* (digits (quotient n 10)) (remainder n 10))]\n    [else (digits (quotient\
    \ n 10))]))\n```\n\n> Note, since Racket already has a `digits` function, I just\
    \ called this one `digitp`.", "  (if (= n 0)\n      0\n      (let ([b (/ n 10)]\n\
    \            [r (- n (* b 10))])\n        (if (odd? r)\n            (let ([d (digits\
    \ b)])\n              (if (= d 0)\n                  r\n                  (* r\
    \ d)))\n            (digits b)))))\n", "  (cond [(zero? n) 0]\n        [(odd?\
    \ n) (* n (digits (quotient n 10)))]\n        [else (digits (quotient n 10))]))\n\
    ```\n\n```\n#lang racket\n", "  (cond\n    [(empty? n) 0]\n    [(odd? (first n))\
    \ (* (first n) (digits (rest n)))]\n    [else (digits (rest n))]))\n", "    (cond\
    \ [(even? n) (digits (quotient n 10))]\n          [(= 0 n) 0]\n          [else\
    \ (odd-digits (remainder n 10) (quotient n 10))]))\n", "  (define (digits-helper\
    \ n result)\n    (cond\n      [(= n 0) result]\n      [(even? (remainder n 10))\
    \ (digits-helper (quotient n 10) result)]\n      [else (digits-helper (quotient\
    \ n 10) (* result (remainder n 10)))]))\n  (digits-helper n 1))\n", "  (define\
    \ (div n)\n    (if (<= n 0) \n        n\n        (div (quotient n 10))))\n  (define\
    \ (mod n)\n    (if (<= n 0) \n        n\n        (mod (remainder n 10))))\n  (define\
    \ (even? n)\n    (if (= (mod n 2) 0)\n        true\n        false))\n  (define\
    \ (product n)\n    (if (= n 0)\n        n\n        (* (mod n) (product (div n)))))\n\
    \  (if (even? n)\n      (product n)\n      0))\n```\n</details>\n\n### Problem\
    \ 11\n<details>\n<summary>Solution</summary>\n```racket\n#lang racket\n", "  (accumulate\
    \ * 1 (filter odd? (map string->number (string-&gt;list (number-&gt;string n))))))\n",
  "  (if (zero? n) 0\n      (if (even? (remainder n 10))\n          (digits (quotient\
    \ n 10))\n          (* (remainder n 10) (digits (quotient n 10))))))\n", "  (if\
    \ (zero? n)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder\
    \ n 10) (digits (quotient n 10)))\n          (digits (quotient n 10)))))\n", " \
    \ (cond [(zero? n) 0]\n        [(odd? n) (* n (digits (quotient n 10)))]\n   \
    \     [else (digits (quotient n 10))]))\n", "  (cond\n    [(empty? n) 0]\n   \
    \ [(> n 0)\n     (let ([curr (car n)])\n       (if (and (odd? curr)\n        \
    \        (positive? curr))\n           (* curr (digits (cdr n)))\n           (digits\
    \ (cdr n))))]\n    [else 0]))", "  (cond ((zero? n)\n         0)\n        ((even?\
    \ (remainder n 10))\n         (digits (quotient n 10)))\n        (else\n     \
    \    (* (remainder n 10)\n            (digits (quotient n 10))))))\n", "  (if\
    \ (= n 0)\n      0\n      (let ([d (modulo n 10)])\n        (if (even? d)\n  \
    \          (digits (quotient n 10))\n            (* d (digits (quotient n 10)))))))\n",
  "  (cond\n    [(empty? n) (display \"\")]\n    [(even? (first n)) (digits (rest\
    \ n))]\n    [else (begin (display (first n)) (digits (rest n)))]))\n", "  (if\
    \ (&lt; n 10)\n      (if (odd? n) n 0)\n      (if (odd? (remainder n 10))\n  \
    \        (* (digits (quotient n 10)) (remainder n 10))\n          (digits (quotient\
    \ n 10)))))\n</code>\nSo in this case: <code>(digits 5)</code> returns <code>5</code>,\
    \ <code>(digits 4)</code> returns <code>0</code>, <code>(digits 42)</code> returns\
    \ <code>0</code>, <code>(digits 10)</code> returns <code>0</code>, <code>(digits\
    \ 105)</code> returns <code>5</code>, <code>(digits 410)</code> returns <code>0</code>,\
    \ <code>(digits 104)</code> returns <code>0</code>, <code>(digits 403)</code>\
    \ returns <code>3</code>, <code>(digits 412)</code> returns <code>0</code>.\n",
  "  (displayln n)\n  (cond [(zero? n)\n         0]\n        [(odd? (remainder n 10))\n\
    \         (* (digits (quotient n 10))\n            (remainder n 10))]\n      \
    \  [else\n         (digits (quotient n 10))]))\n", "  (cond [(= 0 n) 0]\n    \
    \    [(odd? (remainder n 10)) (* (remainder n 10) (digits (quotient n 10)))]\n\
    \        [else (digits (quotient n 10))]))", "  (define (iter m acc)\n    (cond\n\
    \      [(zero? m) acc]\n      [(odd? (remainder m 10)) (iter (quotient m 10) (*\
    \ acc (remainder m 10)))]\n      [else (iter (quotient m 10) acc)]))\n  (iter\
    \ n 1))\n", "  (if (empty? (list->string n))\n      0\n      (if (odd? (string->number\
    \ (list->string n)))\n          (string->number (list->string n))\n          0)))",
  "  (if (zero? n) 0\n      (if (odd? (remainder n 10)) (* (remainder n 10) (digits\
    \ (quotient n 10)))\n          (digits (quotient n 10)))))\n", "  (if (or (odd?\
    \ n) (= n 0))\n      n\n      (digits (quotient n 10))))\n", "  (cond [(zero?\
    \ n) 0]\n        [(odd? n) (* n (digits (quotient n 10)))]\n        [else (digits\
    \ (quotient n 10))]))\n", "  (cond\n    [(<= 0 n) (remainder (modulo n 10) 2)]\n\
    \    [else (+ (* (remainder (modulo n 10) 2) (digits (quotient n 10))) (remainder\
    \ (modulo n 10) 2))]))\n", "    (if (&lt; n 10)\n        (if (odd? n) n 0)\n \
    \       (if (odd? (modulo n 10))\n            (* (digits (quotient n 10)) (modulo\
    \ n 10))\n            (digits (quotient n 10)))))\n", "  (if (and (&lt;= 0 n)\
    \ (not (even? n)))\n      (let loop ([n n] [acc 1])\n        (if (zero? n)\n \
    \           acc\n            (if (odd? (remainder n 10))\n                (loop\
    \ (quotient n 10) (* acc (remainder n 10)))\n                (loop (quotient n\
    \ 10) acc))))\n      0))\n", "  (cond\n    [(zero? n)\n     0]\n    [(even? (remainder\
    \ n 10))\n     (digits (quotient n 10))]\n    [else\n     (* (remainder n 10)\
    \ (digits (quotient n 10)))]))\n```\n\n#### N.B.\n\n- In the previous example,\
    \ the value of `n` decreases with each recursive call.\n- It is important that\
    \ the value of `n` decrease at each call so that eventually the recursion will\
    \ stop.\n- This is called the \"decreasing\" rule.\n- The other rule is the \"\
    bounded\" rule that says that eventually the recursion must end.\n- This is why\
    \ we always have a base case (the `(zero? n)` clause) in a recursive function.\n\
    \n### Optional Arguments\n\n- Optional arguments are arguments to a function that\
    \ have default values.\n- The default values are applied if the function call\
    \ omits that argument.\n- Optional arguments are more useful when there are many\
    \ of them.\n- We want to avoid the situation where we have a long list of arguments\
    \ in a function call, where the majority of the arguments are identical for most\
    \ of the calls.\n- The syntax for optional arguments is as follows:\n\n```racket\n\
    #lang racket\n", "  (if (zero? n) 0\n      (if (even? (remainder n 10)) (digits\
    \ (quotient n 10))\n          (* (remainder n 10) (digits (quotient n 10))))))",
  "  (cond\n    [(= n 0) 0]\n    [(odd? (remainder n 10)) (* (digits (quotient n 10))\
    \ (remainder n 10))]\n    [else (digits (quotient n 10))]))\n", "  (cond ((= n\
    \ 0) 0)\n        ((even? (remainder n 10)) (digits (quotient n 10)))\n       \
    \ (else (* (remainder n 10) (digits (quotient n 10))))))\n", "  (define all-digits\n\
    \    (string->list (number->string n)))\n  (define (is-odd? n)\n    (eq? (remainder\
    \ n 2) 1))\n  (define (get-odd-digits all-digits)\n    (if (empty? all-digits)\
    \ '()\n      (let ((digit (car all-digits)))\n        (if (is-odd? digit) (cons\
    \ digit (get-odd-digits (cdr all-digits)))\n          (get-odd-digits (cdr all-digits))))))\n\
    \  (define (prod-digits digits)\n    (if (empty? digits) 1\n      (* (car digits)\
    \ (prod-digits (cdr digits)))))\n  (prod-digits (get-odd-digits all-digits)))",
  "  (cond\n    [(empty? n) 0]\n    [(and (empty? (cdr n)) (odd? (car n))) (car n)]\n\
    \    [(odd? (car n)) (* (car n) (digits (cdr n)))]\n    [else (digits (cdr n))]))\n\
    ```\n\n```scheme\n#lang racket\n", "  (cond\n    [(empty? n) 0]\n    [(odd? (first\
    \ n)) (* (first n) (digits (rest n)))]\n    [else (digits (rest n))]))\n", " \
    \ (if (eq? n 0) 0\n      (if (odd? (remainder n 10))\n          (* (digits (quotient\
    \ n 10)) (remainder n 10))\n          (digits (quotient n 10)))))\n</code>\nI\
    \ believe that given 10 digits, the runtime of this algorithm will be O(n). Is\
    \ that true?\n\n\nA:\n\nYes, that's right. The procedure will take <code>O(n)</code>\
    \ time, where <code>n</code> is the length of the input integer.\n", "  (if (empty?\
    \ n)\n      0\n      (let ([d (digit-value (first n))])\n        (if (even? d)\n\
    \            (digits (rest n))\n            (* d (digits (rest n)))))))", "  (if\
    \ (zero? n)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder\
    \ n 10) (digits (quotient n 10)))\n          (digits (quotient n 10)))))", " \
    \ (if (= n 0)\n      0\n      (let* ([rem (modulo n 10)]\n             [rest (quotient\
    \ n 10)])\n        (if (odd? rem)\n            (* rem (digits rest))\n       \
    \     (digits rest)))))\n", "  (if (zero? n)\n      0\n      (if (even? (remainder\
    \ n 10))\n          (digits (quotient n 10))\n          (* (remainder n 10) (digits\
    \ (quotient n 10))))))\n", "  (if (odd? n)\n      (display n)\n      (display\
    \ 0)))\n", "  (if (even? n)\n      0\n      (* n (digits (quotient n 10)))))\n",
  "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10)) (* (remainder n 10) (digits\
    \ (quotient n 10)))]\n    [else (digits (quotient n 10))]))", "  (if (zero? n)\n\
    \      0\n      (if (even? (remainder n 10))\n          (digits (quotient n 10))\n\
    \          (* (remainder n 10) (digits (quotient n 10))))))\n```\n\nReturn the\
    \ number of subsets of a given set of n numbers that sum to zero. For example,\
    \ how many subsets of the array { -45, -41, -36, -36, 26, -32 } sum to zero?\n\
    \n\n```\n#lang racket\n", "  (cond\n    [(= n 0) 0]\n    [(even? (remainder n\
    \ 10)) (digits (quotient n 10))]\n    [else (* (remainder n 10) (digits (quotient\
    \ n 10)))]))\n</code>\nI wrote this code in Racket and it works perfectly fine.\
    \ However, the way I implemented it is not the way I should. In the second cond,\
    \ when the remainder of n by 10 is 0 (the base case), I shouldn't call the function\
    \ again. \nI want to write it using only one cond. \n\n\nA:\n\nI can see a lot\
    \ of repetition in your code, and I don't think that's a good thing. What if I\
    \ wanted to find the product of all the even digits? I would have to rewrite it\
    \ from scratch.\n<code>(define (digits n)\n  (cond\n    [(= n 0) 0]\n    [(even?\
    \ (remainder n 10)) (digits (quotient n 10))]\n    [else (* (remainder n 10) (digits\
    \ (quotient n 10)))]))\n</code>\nIn this case, it's because you've written your\
    \ <code>digits</code> procedure to do two things: calculate the digit, and check\
    \ if the digit is odd. You should separate these two things into two procedures.\n\
    <code>(define (calculate-digit n)\n  (if (= n 0)\n      0\n      (* (remainder\
    \ n 10) (calculate-digit (quotient n 10)))))\n", "  (let loop ([n n] [acc 1])\n\
    \    (cond [(zero? n) (if (odd? acc) acc 0)]\n          [(odd? n) (loop (quotient\
    \ n 10) (* acc (remainder n 10)))]\n          [else (loop (quotient n 10) acc)])))\n",
  "    (if (= n 0)\n        0\n        (let ((m (modulo n 10)))\n            (if (even?\
    \ m)\n                (digits (quotient n 10))\n                (* m (digits (quotient\
    \ n 10)))))))\n", "  (let* ((digits (map string->number (string-&gt;list (number-&gt;string\
    \ n))))\n         (odds (filter odd? digits)))\n    (if (empty? odds)\n      \
    \  0\n        (apply * odds))))\n</code>\nThe program works, but I feel like I'm\
    \ doing a lot of unnecessary steps. Is there a more efficient way to do this?\n\
    \n\nA:\n\nI just saw your second program and have a few remarks about it. This\
    \ solution is based on yours but it's more condensed and takes advantage of the\
    \ fact that you don't need to convert the number to a string to get a list of\
    \ digits, you can use the <code>list</code> function instead.\n<code>(define (digits\
    \ n)\n  (if (positive? n)\n      (let loop ((n n) (res 1))\n        (if (zero?\
    \ n)\n            (if (positive? res) res 0)\n            (let ((d (modulo n 10)))\n\
    \              (if (odd? d)\n                  (loop (quotient n 10) (* res d))\n\
    \                  (loop (quotient n 10) res)))))\n      0))\n</code>\nIt also\
    \ checks that the result is greater than zero instead of checking if the accumulator\
    \ is empty (this is more concise and it's faster).\nYou can make it tail-recursive\
    \ and thus avoid creating a new stack frame with each iteration:\n<code>(define\
    \ (digits n)\n  (if (positive? n)\n      (let loop ((n n) (res 1))\n        (if\
    \ (zero? n)\n            (if (positive? res) res 0)\n            (let ((d (modulo\
    \ n 10)))\n              (if (odd? d)\n                  (loop (quotient n 10)\
    \ (* res d))\n                  (loop (quotient n 10) res)))))\n      0))\n</code>\n",
  "  (if (= n 0)\n      0\n      (let ([n (remainder n 10)])\n        (if (odd? n)\n\
    \            (* n (digits (quotient n 10)))\n            (digits (quotient n 10))))))\n\
    ```\n\n#### Languages\n\n```\nC (gcc 4.8.1, -O3)\nClojure (1.6.0)\nCoffeeScript\
    \ (1.6.3)\nEcmaScript (node 0.11.13)\nGo (1.3.3)\nHaskell (ghc 7.6.3)\nJava (1.7.0_60\
    \ Oracle Corporation)\nJavaScript (node 0.11.13)\nLua (LuaJIT 2.0.3)\nOCaml (4.01.0)\n\
    Perl (v5.18.2)\nPHP (5.5.14)\nPython (2.7.6)\nRuby (2.1.2p95)\nScala (2.11.2)\n\
    ```", "  (define (digits-helper n result)\n    (cond\n      [(zero? n) result]\n\
    \      [(odd? (remainder n 10)) (digits-helper (quotient n 10) (* result (remainder\
    \ n 10)))]\n      [else (digits-helper (quotient n 10) result)]))\n  (if (odd?\
    \ n)\n      (digits-helper n n)\n      (digits-helper n 1)))\n", "  (if (not (positive?\
    \ n))\n      0\n      (if (odd? n)\n          (* n (digits (/ n 10)))\n      \
    \    (digits (/ n 10)))))\n", "  (cond ((zero? n) 0)\n        ((odd? (remainder\
    \ n 10)) (* (remainder n 10) (digits (quotient n 10))))\n        (else (digits\
    \ (quotient n 10)))))\n", "  (define (digits-iter product n)\n    (cond [(zero?\
    \ n) product]\n          [(odd? (remainder n 10)) (digits-iter (* product (remainder\
    \ n 10)) (quotient n 10))]\n          [else (digits-iter product (quotient n 10))]))\n\
    \  (digits-iter 1 n))", "  (cond\n    [(empty? n) 0]\n    [(odd? (first n)) (*\
    \ (first n) (digits (rest n)))]\n    [else (digits (rest n))]))\n", "  (cond\n\
    \    [(even? n) 0]\n    [(zero? n) n]\n    [else (+ (remainder n 10) (digits (quotient\
    \ n 10)))]))", "  (if (= n 0)\n      0\n      (let\n          ((even? (remainder\
    \ n 2))\n           (odd? (- n even?)))\n        (if (not (zero? odd?))\n    \
    \        (if (= n even?)\n                0\n                (* (quotient n 10)\n\
    \                   (digits (quotient n 10))))\n            (* odd?\n        \
    \       (digits (quotient n 10)))))))\n", "  (if (even? n) 0\n      (* n (digits\
    \ (/ n 10)))))\n", "  (digits-helper n 1))\n", "  (if (&lt; n 10)\n      (if (odd?\
    \ n) n 0)\n      (+ (* (modulo n 10) (digits (quotient n 10)))\n         (if (odd?\
    \ n) n 0))))\n</code>\nIt works fine with <code>1</code> and <code>4</code>. But\
    \ with the <code>2</code> and <code>3</code> it returns <code>0</code>. Any idea\
    \ how to make it work with <code>2</code> and <code>3</code>?\n\n\nA:\n\nIf you\
    \ want to keep the same recursive structure, I'd suggest adding a check for <code>n</code>\
    \ being <code>0</code> and the recursive call being <code>0</code>, in which case\
    \ you should return <code>0</code>. For example:\n<code>(define (digits n)\n \
    \ (if (&lt; n 10)\n      (if (odd? n) n 0)\n      (+ (* (modulo n 10) (digits\
    \ (quotient n 10)))\n         (if (odd? n) n 0))))\n</code>\nAs mentioned in the\
    \ comments, you can get the same solution but in a more concise way with a <code>map</code>\
    \ and <code>filter</code>:\n<code>(define (digits n)\n  (if (odd? n)\n      (apply\
    \ * (map string-&gt;number (string-&gt;list (number-&gt;string n))))\n      0))\n\
    </code>\nFinally, I think a <code>cond</code> is more appropriate for the job,\
    \ here's my take:\n<code>(define (digits n)\n  (cond ((zero? n) 0)\n        ((odd?\
    \ n) (* n (digits (quotient n 10))))\n        (else (digits (quotient n 10)))))\n\
    </code>\n", "  (cond ((< n 1) 0)\n        ((odd? n) (* n (digits (quotient n 10))))\n\
    \        (else (digits (quotient n 10)))))\n", "  (cond ((= n 0) 0)\n        ((=\
    \ (remainder n 2) 1) (* (remainder n 10) (digits (quotient n 10))))\n        (else\
    \ (digits (quotient n 10)))))", "  (define (product-of-odd-digits n)\n    (cond\n\
    \      [(= n 0) 0]\n      [(odd? (remainder n 10)) (* (remainder n 10) (product-of-odd-digits\
    \ (quotient n 10)))]\n      [else (product-of-odd-digits (quotient n 10))]))\n\
    \  (product-of-odd-digits n))\n", "  (if (equal? n 0)\n      0\n      (let* ([d\
    \ (remainder n 10)]\n             [r (quotient n 10)])\n        (if (zero? (modulo\
    \ d 2))\n            (digits r)\n            (* d (digits r))))))\n", "  (if (=\
    \ n 0)\n      0\n      (let ([d (modulo n 10)])\n        (if (odd? d)\n      \
    \      (* d (digits (quotient n 10)))\n            (digits (quotient n 10))))))",
  "  (if (zero? n)\n      0\n      (if (even? (remainder n 10))\n          (digits\
    \ (quotient n 10))\n          (* (remainder n 10) (digits (quotient n 10))))))\n\
    ```\n\nSolution:\n```racket\n#lang racket\n", "  (if (zero? n) 0\n      (let*\
    \ ([d (remainder n 10)]\n             [p (digits (quotient n 10))])\n        (if\
    \ (odd? d) (* d p) p))))\n", "  (cond [(zero? n) 0]\n        [(and (even? n) (>\
    \ n 0)) (digits (quotient n 10))]\n        [(and (odd? n) (> n 0)) (* (remainder\
    \ n 10) (digits (quotient n 10)))]))\n```\n\n```\n#lang racket\n", "  (accumulate\
    \ * 1 (filter odd? (digits-of n))))\n", "  (cond [(= 0 n) 0]\n        [(zero?\
    \ (modulo n 2)) (digits (quotient n 10))]\n        [else (* (remainder n 10) (digits\
    \ (quotient n 10)))]))\n", "  (cond\n    [(= 0 n) 0]\n    [(= 0 (remainder n 2))\
    \ (digits (quotient n 10))]\n    [else (* (remainder n 10) (digits (quotient n\
    \ 10)))]))\n", "  (cond [(zero? n) 0]\n        [(even? n) (digits (quotient n\
    \ 10))]\n        [else (* n (digits (quotient n 10)))]))\n```\n\n```", "  (cond\
    \ [(even? n) 0]\n        [else (+ n (digits (quotient n 10)))]))\n", "  (define\
    \ (digits-iter x result)\n    (cond ((zero? x) result)\n          ((odd? (remainder\
    \ x 10))\n           (digits-iter (quotient x 10) (* result (remainder x 10))))\n\
    \          (else (digits-iter (quotient x 10) result))))\n  (digits-iter n 1))\n\
    ```\n\n---\n\n### Palindrome\n\n```racket\n#lang racket\n", "  (cond ((&lt; n\
    \ 1) 0)\n        ((&lt; n 10) n)\n        ((= (modulo n 2) 0) (digits (quotient\
    \ n 10)))\n        (else (* n (digits (quotient n 10))))))\n</code>\nThis looks\
    \ like \"Prolog-style\" code and there are ways to do things in Racket like this\
    \ but this is not how you would typically write this code in Racket. Here is a\
    \ refactoring that I think looks more like idiomatic Racket.\n<code>#lang racket\n",
  "  (cond\n    [(empty? n) 0]\n    [(odd? (first n)) (* (first n) (digits (rest n)))]\n\
    \    [else (digits (rest n))]))\n```\n\n```racket\n#lang racket\n", "  (define\
    \ (product n)\n    (define (iter n acc)\n      (cond ((= n 0) acc)\n         \
    \   ((odd? (remainder n 10))\n             (iter (quotient n 10) (* acc (remainder\
    \ n 10))))\n            (else (iter (quotient n 10) acc))))\n    (iter n 1))\n\
    \  (if (odd? n) (* n (product (quotient n 10))) (product n)))\n", "  (local [(define\
    \ (op n)\n            (cond\n              [(zero? n) 1]\n              [(odd?\
    \ n) (* n (op (quotient n 10)))]\n              [else (op (quotient n 10))]))]\n\
    \    (op n)))\n", "  (cond [(empty? n) 0]\n        [(odd? (first n)) (* (first\
    \ n) (digits (rest n)))]\n        [else (digits (rest n))]))\n", "  (cond\n  \
    \  [(= n 0) 0]\n    [(= (remainder n 2) 1) (* (remainder n 10) (digits (quotient\
    \ n 10)))]\n    [else (digits (quotient n 10))]))\n```\n\n```racket\n#lang racket\n",
  "  (let loop ([n n] [acc 0])\n    (cond [(and (zero? n) (= acc 0)) 0]\n        \
    \  [(zero? n) acc]\n          [(odd? (remainder n 10)) (loop (quotient n 10) (*\
    \ acc (remainder n 10)))]\n          [else (loop (quotient n 10) acc)])))\n```",
  "  (let* ([digits (number->list n)]\n         [odd? (\u03BB (x) (odd? x))]\n   \
    \      [odds (filter odd? digits)])\n    (apply * odds)))\n", "  (cond [(zero?\
    \ n) 0]\n        [(odd? n)\n         (* n (digits (inexact->exact (floor (/ n\
    \ 10)))))\n         ]\n        [else\n         (digits (inexact->exact (floor\
    \ (/ n 10))))\n         ]\n        )\n  )\n", "  (if (zero? n)\n      0\n    \
    \  (let ((rem (remainder n 10)))\n        (if (zero? (remainder rem 2))\n    \
    \        (digits (quotient n 10))\n            (* rem (digits (quotient n 10)))))))\n",
  "  (cond [(zero? n) 0]\n        [(odd? n) (* n (digits (quotient n 10)))]\n    \
    \    [else (digits (quotient n 10))]))\n", "  (if (eq? n 0)\n      0\n      (let\
    \ ((digit (modulo n 10))\n            (product (digits (quotient n 10))))\n  \
    \      (if (even? digit)\n            product\n            (* digit product)))))",
  "  (cond ((= n 0) 1)\n        ((even? (modulo n 10)) (digits (quotient n 10)))\n\
    \        (else (* (modulo n 10) (digits (quotient n 10))))))", "  (let loop ([n\
    \ n] [result 1])\n    (cond [(zero? n) result]\n          [(odd? (remainder n\
    \ 10)) (loop (quotient n 10) (* result (remainder n 10)))]\n          [else (loop\
    \ (quotient n 10) result)])))", "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder\
    \ n 10))\n     (* (remainder n 10) (digits (quotient n 10)))]\n    [else (digits\
    \ (quotient n 10))]))\n</code>\nThe intention is that I want to multiply all of\
    \ the odd numbers, and if there are only even numbers, return 0. The problem is\
    \ that my code above doesn't work. For example, if I evaluate <code>(digits 143)</code>,\
    \ I get 3. But it should be 3*1*7 = 21.\nWhat am I doing wrong?\n\n\nA:\n\nYou\
    \ are making a mistake in the recursive case: you are discarding the digits you\
    \ find, instead of accumulating them in the result.\nThis version should work\
    \ correctly:\n<code>(define (digits n)\n  (cond\n    [(zero? n) 1]\n    [(odd?\
    \ (remainder n 10))\n     (* (remainder n 10) (digits (quotient n 10)))]\n   \
    \ [else (digits (quotient n 10))]))\n</code>\n", "  (match n\n    [(list 0 0)\
    \ 0]\n    [(list n) n]\n    [(list n ...) (if (odd? n) (* n (digits (list ...)))\
    \ 0)]))\n", "  (if (zero? n)\n      0\n      (if (even? (remainder n 10))\n  \
    \        (digits (quotient n 10))\n          (* (remainder n 10) (digits (quotient\
    \ n 10))))))\n", "  (if (zero? n)\n      0\n      (let ([remainder (modulo n 10)])\n\
    \        (if (even? remainder)\n            (digits (quotient n 10))\n       \
    \     (* remainder (digits (quotient n 10)))))))\n</code>\nA tail recursive version:\n\
    <code>#lang racket\n", "  (if (zero? n)\n      0\n      (let ((d (remainder n\
    \ 10)))\n        (if (odd? d)\n            (if (zero? (quotient n 10))\n     \
    \           d\n                (* d (digits (quotient n 10))))\n            (digits\
    \ (quotient n 10))))))", "  (if (even? n)\n      0\n      (* n (digits (quotient\
    \ n 10)))))", "  (match n\n    [(list) 0]\n    [(cons hd tl)\n     (if (even?\
    \ hd)\n         (digits tl)\n         (* hd (digits tl)))]))", "  (define (digits-iter\
    \ n result)\n    (cond ((zero? n)\n           result)\n          ((even? (remainder\
    \ n 10))\n           (digits-iter (quotient n 10) result))\n          (else\n\
    \           (digits-iter (quotient n 10) (* result (remainder n 10))))))\n  (digits-iter\
    \ n 1))\n", "  (let ((res 1))\n    (for ([c (string->list (number->string n))])\n\
    \      (if (odd? (string->number (string c)))\n          (set! res (* res (string->number\
    \ (string c))))))\n    res))\n", "  (cond\n    [(= 0 n) 0]\n    [(even? (modulo\
    \ n 10)) (digits (quotient n 10))]\n    [else (* (modulo n 10) (digits (quotient\
    \ n 10)))]))\n", "  (if (and (even? n) (not (= n 0)))\n      0\n      (* n (digits\
    \ (quotient n 10)))))\n", "  (if (even? n)\n      0\n      (* n (digits (quotient\
    \ n 10)))))\n</code>\nAny help would be appreciated.\n\n\nA:\n\nYour code is almost\
    \ correct, you're just missing the base case! When <code>n</code> is <code>0</code>\
    \ you need to stop the recursion and return <code>1</code>. There's no reason\
    \ to return <code>0</code> in this case, because the product of all even digits\
    \ is <code>0</code>, and the product of all odd digits is <code>1</code>.\n<code>(define\
    \ (digits n)\n  (if (even? n)\n      0\n      (* n (digits (quotient n 10)))))\n\
    </code>\n", "  (cond [(empty? n) 0]\n        [(odd? (first n)) (* (first n) (digits\
    \ (rest n)))]\n        [else (digits (rest n))]))\n", "  (define (multiplicand\
    \ lst)\n    (cond\n      [(empty? lst) 1]\n      [(even? (first lst)) (multiplicand\
    \ (rest lst))]\n      [else (* (first lst) (multiplicand (rest lst)))]))\n  (multiplicand\
    \ (list->vector (string->list (number->string n)))))\n\n```\n\n```racket\n#lang\
    \ racket\n", "  (define (digits-iter n p)\n    (cond ((< n 10) p)\n          ((even?\
    \ (remainder n 10)) (digits-iter (quotient n 10) p))\n          (else (digits-iter\
    \ (quotient n 10) (* p (remainder n 10))))))\n  (digits-iter n 1))\n", "  (cond\n\
    \    [(zero? n) 0]\n    [(odd? (remainder n 10))\n     (* (remainder n 10) (digits\
    \ (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (cond\n   \
    \ [(= 0 n) 0]\n    [(odd? (remainder n 10))\n     (* (remainder n 10) (digits\
    \ (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (if (zero?\
    \ n) 0\n      (if (odd? (remainder n 10)) (* (remainder n 10) (digits (quotient\
    \ n 10))) (digits (quotient n 10)))))\n", "  (if (zero? n)\n      0\n      (if\
    \ (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n\
    \          (digits (quotient n 10)))))\n", "  (if (empty? (rest n))\n      (if\
    \ (odd? (first n)) (first n) 0)\n      (if (odd? (first n)) (* (first n) (digits\
    \ (rest n))) (digits (rest n)))))", "  (match n\n    [(? number? x)\n     (let\
    \ ([rem (remainder x 10)])\n       (cond [(= rem 0) 0]\n             [(even? rem)\
    \ (digits (quotient x 10))]\n             [else (* rem (digits (quotient x 10)))]))]\n\
    \    [_ 0]))\n", "  (if (= 0 n) 0\n      (if (odd? (remainder n 10)) (* (remainder\
    \ n 10) (digits (quotient n 10)))\n          (digits (quotient n 10)))))\n", " \
    \ (cond ((= n 0) 0)\n        ((even? (remainder n 10)) (digits (quotient n 10)))\n\
    \        (else (* (remainder n 10) (digits (quotient n 10))))))\n", "  (digits-helper\
    \ n 1))\n", "  (if (equal? n 0)\n      0\n      (if (equal? (remainder n 2) 0)\n\
    \          (digits (quotient n 10))\n          (* (remainder n 10) (digits (quotient\
    \ n 10))))))\n", "    (if (zero? n)\n        0\n        (if (odd? (remainder n\
    \ 10))\n            (* (digits (quotient n 10)) (remainder n 10))\n          \
    \  (digits (quotient n 10)))))\n", "  (cond [(zero? n) \n          0]\n      \
    \  [(odd? (remainder n 10))\n          (* (remainder n 10)\n             (digits\
    \ (quotient n 10)))]\n        [else\n          (digits (quotient n 10))]))\n",
  "  (cond\n    [(even? n) 0]\n    [(odd? n) (* (remainder n 10) (digits (quotient\
    \ n 10)))]))\n", "  (define (helper n sum)\n    (cond\n      [(and (= n 0) (=\
    \ sum 0)) 0]\n      [(= n 0) sum]\n      [(odd? (remainder n 10))\n       (helper\
    \ (quotient n 10) (* sum (remainder n 10)))]\n      [else (helper (quotient n\
    \ 10) sum)]))\n  (helper n 1))\n", "  (if (eq? n 0)\n      0\n      (let* ([rem\
    \ (modulo n 10)]\n             [s (digits (quotient n 10))])\n        (if (odd?\
    \ rem)\n            (if (eq? s 0)\n                rem\n                (* rem\
    \ s))\n            s))))\n", "  (if (= n 0)\n      0\n      (if (odd? (remainder\
    \ n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n          (digits\
    \ (quotient n 10)))))", "  (cond\n    [(= n 0) 0]\n    [(= (modulo n 2) 0) (digits\
    \ (quotient n 10))]\n    [else (* (modulo n 10) (digits (quotient n 10)))]))\n",
  "  (cond ((zero? n) 0)\n        ((odd? (remainder n 10)) (* (remainder n 10) (digits\
    \ (quotient n 10))))\n        (else (digits (quotient n 10)))))\n", "  (if (=\
    \ n 0)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder n\
    \ 10) (digits (quotient n 10)))\n          (digits (quotient n 10)))))", "  (local\
    \ [(define (digits-iter acc m)\n            (cond\n              [(zero? m) acc]\n\
    \              [(even? (remainder m 10))\n               (digits-iter acc (quotient\
    \ m 10))]\n              [else\n               (digits-iter (* acc (remainder\
    \ m 10)) (quotient m 10))]))]\n    (digits-iter 1 n)))", "  (cond\n    [(zero?\
    \ n) 0]\n    [(odd? (modulo n 10)) (* (modulo n 10) (digits (quotient n 10)))]\n\
    \    [else (digits (quotient n 10))]))\n", "  (define (digits-iter p n)\n    (cond\n\
    \      [(= n 0) (* p 1)]\n      [(odd? (remainder n 10)) (digits-iter (* p (remainder\
    \ n 10)) (/ n 10))]\n      [else (digits-iter p (/ n 10))]))\n  (digits-iter 1\
    \ n))\n", "  (cond [(= 0 n) 0]\n        [(odd? (modulo n 10)) (* (modulo n 10)\
    \ (digits (quotient n 10)))]\n        [else (digits (quotient n 10))]))\n", " \
    \ (cond [(< n 10) (if (odd? n) n 0)]\n        [else (if (odd? n) (* n (digits\
    \ (quotient n 10))) (digits (quotient n 10)))]))\n```\n\n```scheme\n#lang racket\n",
  "  (if (empty? (rest (digits-of n)))\n      (if (odd? (first (digits-of n)))\n \
    \         (first (digits-of n))\n          0)\n      (if (odd? (first (digits-of\
    \ n)))\n          (* (first (digits-of n)) (digits (rest (digits-of n))))\n  \
    \        (digits (rest (digits-of n))))))\n", "  (if (odd? n) n 0))\n", "  (cond\
    \ [(= n 0) 0]\n        [(odd? (remainder n 10)) (* (remainder n 10) (digits (quotient\
    \ n 10)))]\n        [else (digits (quotient n 10))]))\n", "  (local ((define (digits-rec\
    \ n prod)\n            (cond [(zero? n) prod]\n                  [(odd? (remainder\
    \ n 10))\n                   (digits-rec (quotient n 10) (* prod (remainder n\
    \ 10)))]\n                  [else (digits-rec (quotient n 10) prod)])))\n    (digits-rec\
    \ n 1)))", "  (cond\n    [(empty? n) 0]\n    [(and (even? (first n)) (not (empty?\
    \ (rest n)))) (digits (rest n))]\n    [(and (odd? (first n)) (not (empty? (rest\
    \ n)))) (* (first n) (digits (rest n)))]\n    [(and (odd? (first n)) (empty? (rest\
    \ n))) (first n)]))", "  (if (zero? n)\n      0\n      (if (even? (remainder n\
    \ 10))\n          (digits (quotient n 10))\n          (* (remainder n 10) (digits\
    \ (quotient n 10))))))\n", "  (if (zero? n)\n      0\n      (let ([r (remainder\
    \ n 10)])\n        (if (even? r)\n            (digits (quotient n 10))\n     \
    \       (* r (digits (quotient n 10)))))))\n", "  (if (zero? n)\n      0\n   \
    \   (let ((odd? (odd? (remainder n 10))))\n        (if odd?\n            (begin\
    \ (display (remainder n 10))\n                   (display \" is odd, \")\n   \
    \                (remainder n 10))\n            (begin (display (remainder n 10))\n\
    \                   (display \" is even, \")\n                   0))\n       \
    \ (+ (* (digits (quotient n 10)) (remainder n 10)) (digits (quotient n 10)))\n\
    \        )\n      )\n  )\n```\n\n```\n#lang racket\n", "  (cond [(zero? n) 0]\n\
    \        [(odd? n) (* n (digits (quotient n 10)))]\n        [else (digits (quotient\
    \ n 10))]))\n```\n\n```racket", "  (cond\n    [(zero? n)\n     0]\n    [(odd?\
    \ (modulo n 10))\n     (* (modulo n 10) (digits (quotient n 10)))]\n    [else\n\
    \     (digits (quotient n 10))]))\n```\n\n```python\n# Given a positive integer\
    \ n, return the product of the odd digits.\n# Return 0 if all digits are even.\n\
    # For example:\n# >>> digits(1) \n# 1\n# >>> digits(4) \n# 0\ndef digits(n):\n\
    \    if n == 0:\n        return 0\n    elif n % 2 == 1:\n        return (n % 10)\
    \ * digits(n / 10)\n    else:\n        return digits(n / 10)\n```\n\n### `sums_to`\n\
    \nImplement a function that takes two natural numbers as input and returns `True`\
    \ if their sum is a perfect square, `False` otherwise.\n\n```racket\n#lang racket\n",
  "  (cond [(empty? n) 0]\n        [(odd? (first n)) (* (first n) (digits (rest n)))]\n\
    \        [else (digits (rest n))]))\n", "  (if (zero? n) 0\n      (let ([d (remainder\
    \ n 10)])\n        (if (even? d) (digits (quotient n 10))\n            (* d (digits\
    \ (quotient n 10)))))))\n", "  (cond ((= n 0) 0)\n        ((even? (remainder n\
    \ 10)) (digits (quotient n 10)))\n        (else (* (remainder n 10) (digits (quotient\
    \ n 10))))))\n", "  (define (iter n prod)\n    (cond ((zero? n) prod)\n      \
    \    ((even? (remainder n 10)) (iter (quotient n 10) prod))\n          (else (iter\
    \ (quotient n 10) (* prod (remainder n 10))))))\n  (iter n 1))\n```\n\n## Reversed\
    \ Binary Numbers\n\n```racket\n#lang racket\n", "  (if (and (integer? n)\n   \
    \        (&gt; n 0))\n      (accumulate * 1\n                  (filter odd? (map\
    \ string-&gt;number (string-&gt;list (number-&gt;string n)))))\n      0))\n",
  "  (cond\n    [(zero? n) 0]\n    [(and (odd? n) (positive? n)) (* n (digits (quotient\
    \ n 10)))]\n    [else (digits (quotient n 10))]))\n```\n\n<h3><a name=\"Exercise-5\"\
    \ class=\"md-header-anchor\"></a>Exercise 5</h3>\n\n```racket\n#lang racket\n",
  "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10)) (* (remainder n 10) (digits\
    \ (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n</code>\n", "  (cond\
    \ [(= n 0) 0]\n        [(odd? (remainder n 10))\n         (* (remainder n 10)\
    \ (digits (quotient n 10)))]\n        [else (digits (quotient n 10))]))\n", " \
    \ (if (= n 0)\n      0\n      (let* ([m (modulo n 10)]\n             [p (digits\
    \ (quotient n 10))])\n        (if (even? m)\n            p\n            (* m p)))))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (modulo\
    \ n 10)) (* (modulo n 10) (digits (quotient n 10)))]\n    [else (digits (quotient\
    \ n 10))]))", "  (cond ((zero? n) 0)\n        ((odd? (modulo n 10)) (* (modulo\
    \ n 10) (digits (quotient n 10))))\n        (else (digits (quotient n 10)))))\n",
  "    (match n\n        [(list (? odd?) . _) n]\n        [(list _ . rest) (digits\
    \ rest)]\n        [_ 0]))\n", "  (cond ((even? n) 0)\n        ((zero? n) 1)\n\
    \        (else (* (odd-digits (quotient n 10)) (remainder n 10)))))\n", "  (cond\
    \ ((= n 0) 0)\n        ((= (remainder n 2) 1) (* (remainder n 10) (digits (quotient\
    \ n 10))))\n        (else (digits (quotient n 10)))))\n</code>\nThe <code>cond</code>\
    \ statement is not working as expected. If all digits are even, I want to return\
    \ 0, but the output is 1. Any ideas?\n\n\nA:\n\nYou are not properly handling\
    \ the <code>odd</code> case. \nFix:\n<code>(define (digits n)\n  (cond ((= n 0)\
    \ 0)\n        ((= (remainder n 2) 1) \n         (+ (* (remainder n 10) (digits\
    \ (quotient n 10)))\n            (digits (quotient n 10))))\n        (else (digits\
    \ (quotient n 10)))))\n</code>\nTest:\n<code>(digits 220)\n0\n", "  (cond ((=\
    \ n 0) 0)\n        ((= (remainder n 2) 1)\n         (* (remainder n 10)\n    \
    \        (digits (quotient n 10))))\n        (else (digits (quotient n 10)))))\n",
  "  (let ([n-as-string (number->string n)])\n    (if (zero? (length n-as-string))\n\
    \        n\n        (let ([first-char (string-ref n-as-string 0)])\n         \
    \ (if (even? (string->number first-char))\n              (digits (string->number\
    \ (substring n-as-string 1)))\n              (* (string->number first-char) (digits\
    \ (string->number (substring n-as-string 1)))))))))", "  (let loop ([n n] [acc\
    \ 1])\n    (cond\n      [(not (positive? n)) acc]\n      [(odd? (remainder n 10))\
    \ (loop (quotient n 10) (* acc (remainder n 10)))]\n      [else (loop (quotient\
    \ n 10) acc)])))\n", "  (cond ((= n 0) 0)\n        ((even? (remainder n 10)) (digits\
    \ (quotient n 10)))\n        (else (* (remainder n 10) (digits (quotient n 10))))))\n",
  "  (define (odd? n)\n    (if (zero? (remainder n 2))\n        #f\n        #t))\n\
    \  (define (odd-digits n)\n    (if (zero? n)\n        0\n        (if (odd? n)\n\
    \            (* (odd-digits (quotient n 10)) n)\n            (odd-digits (quotient\
    \ n 10)))))\n  (odd-digits n))\n", "  (cond [(empty? n) empty]\n        [(even?\
    \ (first n)) (digits (rest n))]\n        [else (cons (first n) (digits (rest n)))]))\n",
  "  (cond\n    [(empty? n) 0]\n    [(odd? (first n))\n     (+ (* (first n) (digits\
    \ (rest n)))\n        (digits (rest n)))]\n    [else (digits (rest n))]))\n",
  "  (cond ((= n 0)\n         0)\n        ((odd? (remainder n 10))\n         (* (remainder\
    \ n 10) (digits (quotient n 10))))\n        (else\n         (digits (quotient\
    \ n 10)))))\n", "  (define (product n)\n    (if (eq? (modulo n 10) 0) 0\n    \
    \    (* (modulo n 10) (product (quotient n 10)))))\n  (product n))", "  (if (null?\
    \ n)\n      0\n      (if (even? (car n))\n          (digits (cdr n))\n       \
    \   (* (car n) (digits (cdr n))))))\n", "    (if (zero? n)\n        0\n      \
    \  (let ((rem (remainder n 10)))\n            (if (zero? (remainder rem 2))\n\
    \                (digits (quotient n 10))\n                (* rem (digits (quotient\
    \ n 10)))))))", "  (if (zero? n)\n      0\n      (let ((d (remainder n 10)))\n\
    \        (if (even? d)\n            (digits (quotient n 10))\n            (* d\
    \ (digits (quotient n 10)))))))\n", "  (define (solve n)\n    (cond\n      [(odd?\
    \ n) (* n (solve (quotient n 10)))]\n      [(even? n) 0]\n      [else (solve (quotient\
    \ n 10))]))\n  (solve n))\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder\
    \ n 10)) (* (remainder n 10) (digits (quotient n 10)))]\n    [else (digits (quotient\
    \ n 10))]))\n", "  (cond\n    [(zero? n)\n     0]\n    [(odd? (modulo n 10))\n\
    \     (* (modulo n 10) (digits (quotient n 10)))]\n    [else\n     (digits (quotient\
    \ n 10))]))\n", "  (cond [(= n 0)\n         0]\n        [(odd? (remainder n 10))\n\
    \         (* (remainder n 10) (digits (quotient n 10)))]\n        [else (digits\
    \ (quotient n 10))]))\n", "  (if (odd? n) n 0))\n", "    (if (zero? n)\n     \
    \   0\n        (if (odd? (remainder n 10))\n            (* (remainder n 10) (digits\
    \ (quotient n 10)))\n            (digits (quotient n 10)))))", "  (if (zero? n)\
    \ 0\n      (if (odd? (remainder n 10))\n          (* (remainder n 10) (digits\
    \ (quotient n 10)))\n          (digits (quotient n 10)))))\n", "  (local ((define\
    \ (helper n p)\n            (cond ((= n 0) p)\n                  ((odd? (remainder\
    \ n 10))\n                   (helper (quotient n 10) (* p (remainder n 10))))\n\
    \                  (else (helper (quotient n 10) p)))))\n    (helper n 1)))",
  "  (cond\n    [(zero? n) 0]\n    [(= (remainder n 2) 1) (* (remainder n 10) (digits\
    \ (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (if (= n 0)\n\
    \      0\n      (if (odd? (remainder n 10))\n          (* (remainder n 10) (digits\
    \ (quotient n 10)))\n          (digits (quotient n 10)))))\n", "  (letrec ([odd?\
    \ (lambda (n) (and (not (zero? n)) (or (odd? (quotient n 10)) (odd? (remainder\
    \ n 10)))))]\n\t   [digits (lambda (n acc) (if (zero? n) acc (digits (quotient\
    \ n 10) (if (odd? (remainder n 10)) (* acc (remainder n 10)) acc))))])\n    (digits\
    \ n 1)))\n", "  (cond [(zero? n) 0]\n        [(odd? n) \n         (* n (digits\
    \ (quotient n 10)))]\n        [else (digits (quotient n 10))]))", "  (cond [(zero?\
    \ n) 0]\n        [(odd? n) (* n (digits (quotient n 10)))]\n        [else (digits\
    \ (quotient n 10))]))\n```\n\n## Exercise 2\n\n```racket\n#lang racket\n", " \
    \ (if (= 0 n)\n      0\n      (* (remainder n 10) (digits (quotient n 10)))))\n",
  "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder\
    \ n 10) (digits (quotient n 10)))\n          (digits (quotient n 10)))))\n", " \
    \ (cond\n    [(zero? n) 0]\n    [(odd? (modulo n 10)) (* (modulo n 10) (digits\
    \ (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (cond\n   \
    \ ((< 0 n)\n     (+ (* (remainder n 10) (digits (quotient n 10)))\n        (cond\n\
    \          ((odd? (remainder n 10)) (remainder n 10))\n          (else 0))))\n\
    \    (else 0)))\n```\n\n```racket\n#lang racket\n", "  (local [(define (digit-product\
    \ n d)\n            (if (or (= d 0) (= n 0))\n                0\n            \
    \    (+ (* d (remainder n 10)) (digit-product (quotient n 10) d))))]\n    (digit-product\
    \ n 1)))\n", "  (cond\n    [(even? n) 0]\n    [(even? (quotient n 10)) (digits\
    \ (quotient n 10))]\n    [else (* (remainder n 10) (digits (quotient n 10)))]))\n\
    ```\n\n---\n\n### Exercise 2\n\n```racket\n#lang racket\n", "  (define (digits-iter\
    \ n acc)\n    (cond\n      [(empty? n) acc]\n      [(odd? (string->number (first\
    \ n))) (digits-iter (rest n) (* acc (string->number (first n))))]\n      [else\
    \ (digits-iter (rest n) acc)]))\n  (digits-iter (number->string n) 1))\n```\n\n\
    ### Challenge 2\n\n```racket\n#lang racket\n", "  (if (zero? n)\n      0\n   \
    \   (if (even? (remainder n 10))\n          (digits (quotient n 10))\n       \
    \   (* (remainder n 10) (digits (quotient n 10))))))\n", "  (cond\n    [(zero?\
    \ n) 0]\n    [(odd? (remainder n 10)) (* (remainder n 10) (digits (quotient n\
    \ 10)))]\n    [else (digits (quotient n 10))]))", "  (if (zero? n)\n      0\n\
    \      (let ((digit (modulo n 10)))\n        (if (odd? digit)\n            (*\
    \ digit (digits (quotient n 10)))\n            (digits (quotient n 10))))))\n",
  "  (match n\n    [(list digit (? odd? odd-digit)) (* digit odd-digit)]\n    [_ 0]))\n",
  "  (if (zero? n) \n      0\n      (let* ([r (remainder n 10)] \n             [next\
    \ (quotient n 10)])\n        (if (even? r)\n            (digits next)\n      \
    \      (* r (digits next))))))\n", "  (cond [(zero? n) 0]\n        [(and (even?\
    \ n) (odd? (remainder n 10)))\n         (digits (quotient n 10))]\n        [(and\
    \ (even? n) (even? (remainder n 10)))\n         0]\n        [(odd? n)\n      \
    \   (* n (digits (quotient n 10)))]))\n", "  (cond\n    ((= n 0) 0)\n    ((even?\
    \ (remainder n 10)) (digits (quotient n 10)))\n    (else (* (remainder n 10) (digits\
    \ (quotient n 10))))))\n", "  (cond [(zero? n) 0]\n        [(odd? n) (* n (digits\
    \ (quotient n 10)))]\n        [else (digits (quotient n 10))]))\n", "  (if (odd?\
    \ n)\n      n\n      0))\n", "  (define (digits-helper n sum)\n    (cond ((or\
    \ (= n 0) (= n 1)) sum)\n          ((even? (remainder n 10)) (digits-helper (quotient\
    \ n 10) sum))\n          (else (digits-helper (quotient n 10) (* sum (remainder\
    \ n 10))))))\n  (digits-helper n 1))\n", "  (if (= 0 n)\n      1\n      (* (remainder\
    \ n 10) (digits (quotient n 10)))))\n</code>\nThe real problem is that the <code>remainder</code>\
    \ function is returning 3 for 33.\n\n\nA:\n\nYou need to check the value returned\
    \ by remainder, in the recursive call. If it is even, you can skip that call,\
    \ otherwise you multiply the result.\n<code>(define (digits n)\n  (if (= 0 n)\n\
    \      1\n      (let ((r (remainder n 10)))\n        (if (even? r)\n         \
    \   (digits (quotient n 10))\n            (* r (digits (quotient n 10)))))))\n\
    </code>\n", "  (cond\n    [(= n 0) 0]\n    [(zero? (modulo n 2)) (digits (quotient\
    \ n 10))]\n    [else (* (modulo n 10) (digits (quotient n 10)))]))", "  (if (=\
    \ n 0)\n      0\n      (let ((d (remainder n 10)))\n        (if (even? d)\n  \
    \          (digits (quotient n 10))\n            (* d (digits (quotient n 10)))))))\n\
    ```\n\n```scheme\n#lang racket\n", "  (let loop ([n n] [acc 1])\n    (if (= n\
    \ 0)\n        acc\n        (if (odd? (remainder n 10))\n            (loop (quotient\
    \ n 10) (* acc (remainder n 10)))\n            (loop (quotient n 10) acc)))))\n",
  "  (if (zero? n)\n      0\n      (+ (* (if (odd? (remainder n 10))\n           \
    \    (remainder n 10)\n               0)\n             (digits (quotient n 10)))\n\
    \         0)))", "  (define (next a)\n    (cond [(= a 0) a]\n          [(odd?\
    \ (remainder a 10)) (* (remainder a 10) (next (quotient a 10)))]\n          [else\
    \ (next (quotient a 10))]))\n  (next n))\n", "  (cond\n    [(zero? n) 0]\n   \
    \ [(odd? (remainder n 10))\n     (* (remainder n 10) (digits (quotient n 10)))]\n\
    \    [else (digits (quotient n 10))]))\n```\n\n```scheme\n#lang racket\n", " \
    \ (let ([d (list->string n)])\n    (if (= (string-length d) 1)\n        (string->number\
    \ d)\n        (let loop ([i 1] [k 0])\n          (cond\n            [(odd? (string->number\
    \ (string-ref d i)))\n             (loop (+ i 1) (* (string->number (string-ref\
    \ d i)) (expt 10 k)))]\n            [else (loop (+ i 1) (+ k 1))])))))\n```\n\n\
    ```\n#lang racket\n", "  (let loop ((n n) (acc 1))\n    (cond ((zero? n) 0)\n\
    \          ((odd? (remainder n 10))\n           (loop (quotient n 10) (* acc (remainder\
    \ n 10))))\n          (else (loop (quotient n 10) acc)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
