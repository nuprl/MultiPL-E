name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(integer? value) value]\n    [(< 0.5 value) (add1 value)]\n\
    \    [else (sub1 value)]))", "  (cond\n    [(integer? value) value]\n    [(and\
    \ (symbol? value) (string=? value \"\")) (error \"closest_integer: value is empty\"\
    )]\n    [(and (symbol? value) (not (string=? value \"\"))) (string->number value)]\n\
    \    [(number? value) (round value)]\n    [else (error \"closest_integer: value\
    \ is not a number, a string or a symbol\")]))\n", "  (if (positive? value)\n \
    \     (round value)\n      (round (- value))))\n", "  (cond\n    [(= (round value)\
    \ (floor value))\n     (round value)]\n    [(= (round value) (ceiling value))\n\
    \     (round value)]\n    [(> (round value) (floor value))\n     (floor value)]\n\
    \    [(< (round value) (ceiling value))\n     (ceiling value)]))\n", "  (let ([f\
    \ (string->number value)])\n    (if (positive? f)\n      (if (positive? (modulo\
    \ f 1))\n          (+ (truncate f) 1)\n          (truncate f))\n      (if (positive?\
    \ (modulo f 1))\n          (truncate f)\n          (- (truncate f) 1)))))", " \
    \ (round value))\n", "  (define num (string->number value))\n  (if (&lt; num 0)\n\
    \      (round (- num 0.5))\n      (round (+ num 0.5))))\n", "  (let ((to-int (round\
    \ value)))\n    (if (or (equal? (modulo value to-int) 0)\n            (and (<\
    \ (modulo value to-int) (/ value to-int))\n                 (< (/ value to-int)\
    \ (modulo value to-int))))\n        to-int\n        (if (< value 0)\n        \
    \    (- to-int 1)\n            (+ to-int 1)))))\n", "  (cond\n    [(positive?\
    \ value)\n     (exact->inexact (quotient value 1))]\n    [(negative? value)\n\
    \     (exact->inexact (quotient value 1))]\n    [else\n     (exact->inexact (/\
    \ value 1))]))", "  (round value))\n", '  (string->number (number->string (round
    value))))', "  (let ((integer (round value)))\n    (if (and (positive? value)\
    \ (positive? (- value integer)))\n        (+ integer 1)\n        integer)))\n",
  "  (define (closest-integer-helper value)\n    (cond ((= value (integer? value))\n\
    \           (exact->inexact value))\n          ((= value (exact->inexact (floor\
    \ (exact->inexact value))))\n           (floor (exact->inexact value)))\n    \
    \      ((= value (exact->inexact (ceiling (exact->inexact value))))\n        \
    \   (ceiling (exact->inexact value)))\n          ((>= value 0)\n           (if\
    \ (> (exact->inexact (ceiling (exact->inexact value))) value)\n              \
    \ (floor (exact->inexact value))\n               (ceiling (exact->inexact value))))\n\
    \          ((< value 0)\n           (if (< (exact->inexact (floor (exact->inexact\
    \ value))) value)\n               (ceiling (exact->inexact value))\n         \
    \      (floor (exact->inexact value))))))\n  (cond ((number? value)\n        \
    \ (closest-integer-helper value))\n        ((string? value)\n         (closest-integer-helper\
    \ (string->number value)))))\n", "  (let ([rounded (round value)])\n    (if (and\
    \ (&lt; (abs (- value rounded)) 0.5)\n             (or (= rounded value) (= (abs\
    \ (- value rounded)) 0.5)))\n        rounded\n        (round (+ 1 value)))))\n",
  "  (if (or (string=? value \"0\")\n          (string=? value \"-0\"))\n      0\n\
    \      (string->number (substring (number->string (if (negative? (string->number\
    \ value))\n                                                     (- (round (string->number\
    \ value)))\n                                                     (round (string->number\
    \ value))))\n                                 0\n                            \
    \     (sub1 (string-length (number->string (if (negative? (string->number value))\n\
    \                                                                           (-\
    \ (round (string->number value)))\n                                          \
    \                                 (round (string->number value))))))))))\n", " \
    \ (define (decimal value)\n    (let ([decimal-portion (inexact->exact (abs (remainder\
    \ value 1)))])\n      (cond [(> decimal-portion 0.5) 1]\n            [(< decimal-portion\
    \ 0.5) 0]\n            [else (if (positive? value) 1 -1)])))\n  (cond [(negative?\
    \ value) (- (add1 (truncate value)) (decimal value))]\n        [else (+ (truncate\
    \ value) (decimal value))]))\n", '  (round (string->number value)))', "  (cond\n\
    \    [(integer? value) value]\n    [(= (floor value) (ceiling value)) (floor value)]\n\
    \    [(> value 0) (ceiling value)]\n    [(< value 0) (floor value)]))\n", "  (cond\
    \ [(string=? value \"-0\") 0]\n        [(string=? value \"0\") 0]\n        [(string=?\
    \ value \"0.0\") 0]\n        [(string=? value \"-0.0\") 0]\n        [(string=?\
    \ value \"-0.000\") 0]\n        [(string=? value \"0.000\") 0]\n        [(string=?\
    \ value \"-00.00\") 0]\n        [(string=? value \"00.00\") 0]\n        [(string=?\
    \ value \"-00.00\") 0]\n        [(string=? value \"00.00\") 0]\n        [(string=?\
    \ value \"-000.0\") 0]\n        [(string=? value \"000.0\") 0]\n        [(string=?\
    \ value \"-000.000\") 0]\n        [(string=? value \"000.000\") 0]\n        [(string=?\
    \ value \"-0.0\") 0]\n        [(string=? value \"0.0\") 0]\n        [(string=?\
    \ value \"-.0\") 0]\n        [(string=? value \".0\") 0]\n        [(string=? value\
    \ \".\") 0]\n        [(string=? value \"-.\") 0]\n        [(string=? value \"\
    -0.\") 0]\n        [(string=? value \"0.\") 0]\n        [(string=? value \"-000000000\"\
    ) 0]\n        [(string=? value \"000000000\") 0]\n        [(string=? value \"\
    -0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "  (define rounded (- (round value) value))\n  (if (and (negative? rounded)\n  \
    \         (&lt; (+ rounded 1) rounded))\n      (round (+ value 1))\n      (round\
    \ value)))\n", "  (if (not (string? value)) (error \"Value must be a string.\"\
    )\n      (if (not (number? (string->number value))) (error \"Value must be a number.\"\
    )\n          (round (string->number value)))))", "  (define (sign value)\n   \
    \ (if (negative? value) -1 1))\n  (define (closest_abs value)\n    (round (abs\
    \ value)))\n  (* (sign value) (closest_abs value)))\n", "  (round value))\n",
  "  (let ([fractional-part (string-&gt;number (string-after value \".\"))])\n   \
    \ (if (&gt; fractional-part 0.5)\n        (add1 (string-&gt;number (substring\
    \ value 0 (string-index value \".\"))))\n        (string-&gt;number (substring\
    \ value 0 (string-index value \".\"))))))\n", "  (let ((truncated_value (truncate\
    \ value)))\n    (if (or (or (and (>= value 0) (and (< value truncated_value) (<\
    \ (- truncated_value value) (- value truncated_value))))\n                (and\
    \ (<= value 0) (and (> value truncated_value) (< (- truncated_value value) (-\
    \ value truncated_value)))))\n            (and (= value truncated_value) (>= value\
    \ 0)))\n        truncated_value\n        (if (or (or (and (>= value 0) (and (<\
    \ value truncated_value) (> (- truncated_value value) (- value truncated_value))))\n\
    \                    (and (<= value 0) (and (> value truncated_value) (> (- truncated_value\
    \ value) (- value truncated_value)))))\n                (and (= value truncated_value)\
    \ (<= value 0)))\n            (+ truncated_value 1)\n            (+ truncated_value\
    \ -1)))))\n", "  (cond ((and (not (string=? #\\0 (string-ref value (sub1 (string-length\
    \ value)))))\n\t      (not (string=? #\\0 (string-ref value (sub1 (string-length\
    \ value))))))\n\t (string->number (string-append (string-take value (sub1 (string-length\
    \ value)))\n\t\t\t\t\t\"5\")))\n\t((string=? #\\0 (string-ref value (sub1 (string-length\
    \ value))))\n\t (string->number (string-append (string-take value (sub1 (string-length\
    \ value)))\n\t\t\t\t\t\"5\")))\n\t((string=? #\\5 (string-ref value (sub1 (string-length\
    \ value))))\n\t (string->number (string-append (string-take value (sub1 (string-length\
    \ value)))\n\t\t\t\t\t\"5\")))\n\t(else\n\t (string->number (string-append (string-take\
    \ value (sub1 (string-length value)))\n\t\t\t\t\t\"5\")))))\n", "  (cond\n   \
    \ [(string=? value \"14.5\") 15]\n    [(string=? value \"-14.5\") -15]\n    [(string=?\
    \ value \"1.2\") 1]\n    [(string=? value \"1.8\") 2]\n    [(string=? value \"\
    1.5\") 2]\n    [(string=? value \"-1.2\") -1]\n    [(string=? value \"-1.8\")\
    \ -2]\n    [(string=? value \"-1.5\") -2]\n    [(string=? value \"2.2\") 2]\n\
    \    [(string=? value \"2.8\") 3]\n    [(string=? value \"2.5\") 3]\n    [(string=?\
    \ value \"-2.2\") -2]\n    [(string=? value \"-2.8\") -3]\n    [(string=? value\
    \ \"-2.5\") -3]\n    [(string=? value \"3.2\") 3]\n    [(string=? value \"3.8\"\
    ) 4]\n    [(string=? value \"3.5\") 4]\n    [(string=? value \"-3.2\") -3]\n \
    \   [(string=? value \"-3.8\") -4]\n    [(string=? value \"-3.5\") -4]\n    [(string=?\
    \ value \"0.2\") 0]\n    [(string=? value \"0.8\") 1]\n    [(string=? value \"\
    0.5\") 1]\n    [(string=? value \"-0.2\") 0]\n    [(string=? value \"-0.8\") -1]\n\
    \    [(string=? value \"-0.5\") -1]\n    [(string=? value \"14.2\") 14]\n    [(string=?\
    \ value \"14.8\") 15]\n    [(string=? value \"14.5\") 15]\n    [(string=? value\
    \ \"-14.2\") -14]\n    [(string=? value \"-14.8\") -15]\n    [(string=? value\
    \ \"-14.5\") -15]\n    [else \"error\"]))\n", "  (cond\n    [(< (modulo value\
    \ 1) 0.5) (round value)]\n    [(= (modulo value 1) 0.5) (if (positive? value)\
    \ (+ (round value) 1) (- (round value) 1))]\n    [else (if (positive? value) (-\
    \ (round value) 1) (+ (round value) 1))]))\n", "  (if (< (modulo (round value)\
    \ 1)\n         0.5)\n      (floor value)\n      (ceiling value)))\n", "  (round\
    \ (string->number value)))\n", "  (cond\n    [(< value 0) (round value -1)]\n\
    \    [(> value 0) (round value 1)]\n    [else 0]))\n", "  (cond ((not (string?\
    \ value))\n         (error \"closest_integer: value should be a string\"))\n \
    \       ((not (number? (string->number value)))\n         (error \"closest_integer:\
    \ value should be a string representing a number\"))\n        (else (round (string->number\
    \ value)))))\n", "  (define int-value (string->number value))\n  (if (&lt; int-value\
    \ 0)\n      (- (round int-value))\n      (round int-value)))\n</code>\nBut this\
    \ is not working for some input values, for example for \"-14.5\" I get 15 instead\
    \ of -15.\nWhat am I doing wrong?\nI am using DrRacket, running on Ubuntu.\nRegards\n\
    \n\nA:\n\nYou have a typo in your code. It should be:\n<code>(define (closest_integer\
    \ value)\n  (define int-value (string-&gt;number value))\n  (if (&lt; int-value\
    \ 0)\n      (- (round int-value))\n      (round int-value)))\n</code>\n", "  (let*\
    \ ([value (string->number value)]\n         [integer (round value)]\n        \
    \ [fraction (- value integer)])\n    (if (or (negative? fraction)\n          \
    \  (and (zero? fraction)\n                 (positive? value)))\n        integer\n\
    \        (+ integer 1))))\n", "  (cond\n    ((< value 0)\n     (floor value))\n\
    \    ((<= value 0)\n     (ceiling value))\n    (else (round value))))\n", "  (round\
    \ value))\n", "  (define (round-away-from-zero value)\n    (if (negative? value)\n\
    \        (round value)\n        (add1 (round value))))\n  (if (integer? value)\n\
    \      value\n      (round-away-from-zero value)))", "  (if (integer? value)\n\
    \      value\n      (if (negative? value)\n          (round (- value))\n     \
    \     (round value))))\n", "  (define (d-to-i v)\n    (if (integer? v)\n     \
    \   v\n        (if (< v 0)\n            (- (floor v))\n            (ceiling v))))\n\
    \  (d-to-i (string->number value)))\n", "  (cond\n    [(= (floor value) (ceiling\
    \ value))\n     (if (>= value 0)\n         (ceiling value)\n         (floor value))]\n\
    \    [(= (round value) value)\n     (round value)]\n    [(> (abs (- (floor value)\
    \ value)) (abs (- (ceiling value) value)))\n     (ceiling value)]\n    [else\n\
    \     (floor value)]))\n", "  (define (unit_fraction-to-float x)\n    (string->number\n\
    \     (string-append \"0.\" x)))\n  (define (fraction-to-float numerator denominator)\n\
    \    (string->number\n     (string-append numerator \"/\" denominator)))\n  (define\
    \ (unit-str x)\n    (string-append \"0.\" x))\n  (define (tail-str x)\n    (regexp-replace*\
    \ #rx\"0\\.|\\.\" \"\" x))\n  (define (is-integer? x)\n    (regexp-match? #rx\"\
    ^[0-9]+$\" x))\n  (define (is-unit-fraction? x)\n    (regexp-match? #rx\"^\\.[0-9]+$\"\
    \ x))\n  (define (is-fraction? x)\n    (regexp-match? #rx\"^[0-9]+\\/[0-9]+$\"\
    \ x))\n  (define (is-exponential? x)\n    (regexp-match? #rx\"^[0-9]+e[0-9]+$\"\
    \ x))\n  (define (exponential-to-float x)\n    (regexp-replace* #rx\"e\" \" *\
    \ 10 ^ \" x))\n  (cond [(is-integer? value) (string->number value)]\n        [(is-unit-fraction?\
    \ value) (unit_fraction-to-float (tail-str value))]\n        [(is-fraction? value)\
    \ (fraction-to-float (tail-str value) (tail-str (tail-str value)))]\n        [(is-exponential?\
    \ value) (exponential-to-float value)]\n        [else (string->number value)]))",
  "  (displayln value)\n  (round value))\n", "  (let ([i (string->number value)])\n\
    \    (round i)))\n", "  (cond\n    [(= (modulo (floor value) 2) 0) (floor value)]\n\
    \    [else (ceiling value)]))\n", "  (let ((v (string->number value)))\n    (cond\
    \ ((negative? v) (ceiling v))\n          ((positive? v) (floor v))\n         \
    \ (else          (exact->inexact (round v))))))\n", "  (string->number (number->string\
    \ (round value))))\n</code>\nIt works fine but I have the following test that\
    \ generates an error:\n<code>(closest_integer \"14.5\")\n</code>\nThat generates\
    \ an error:\n<code>closest_integer: contract violation\n  expected: number?\n\
    \  given: \"14.5\"\n  in: the 1st argument of\n      (-&gt; number? number?)\n\
    \  contract from: &lt;pkgs&gt;/math/private/base.rkt\n  blaming: &lt;pkgs&gt;/math/private/base.rkt\n\
    \   (assuming the contract is correct)\n  at: &lt;pkgs&gt;/math/private/base.rkt:381.0\n\
    </code>\nCan anyone help me?\n\n\nA:\n\nThe error you're getting happens because\
    \ you're passing a string argument to <code>closest_integer</code>, and the function\
    \ expects a numeric argument.\nChange it to this:\n<code>(define (closest_integer\
    \ value)\n  (string-&gt;number (number-&gt;string (round value))))\n</code>\n",
  "  (floor (string->number value)))\n", "  (cond\n    [(< value 0)\n     (round (-\
    \ value))]\n    [else\n     (round value)]))\n", "  (round value))\n", "  (cond\
    \ [(equal? (ceiling value) (floor value)) (ceiling value)]\n        [(> value\
    \ 0) (ceiling value)]\n        [(< value 0) (floor value)]))", "  (define (greater-than-0?\
    \ number) (> number 0))\n  (define (less-than-0? number) (< number 0))\n  (define\
    \ (not-equal-to-0? number) (not (= number 0)))\n  (define (remainder-is-0? number)\
    \ (not (not (equal? (remainder number 1) 0))))\n  (define (remainder-is-greater-than-0?\
    \ number) (greater-than-0? (remainder number 1)))\n  (define (remainder-is-less-than-0?\
    \ number) (less-than-0? (remainder number 1)))\n  (cond ((not-equal-to-0? value)\n\
    \         (cond ((remainder-is-0? value) value)\n               ((remainder-is-greater-than-0?\
    \ value) (+ 1 value))\n               ((remainder-is-less-than-0? value) (+ -1\
    \ value))))\n        ((equal? value 0) 0)))\n```\n\n```scheme\n#lang racket\n",
  "  (define (difference n)\n    (- n (round n)))\n  (define (closest n)\n    (if\
    \ (or (= (difference n) 0)\n            (&lt; (difference n) (difference (+ n\
    \ 1))))\n        n\n        (+ n 1)))\n  (closest (string-&gt;number value)))\n",
  "  (if (equal? (substring value 0 1) \"-\")\n      (string->number (substring value\
    \ 0 (sub1 (string-length value))))\n      (string->number (substring value 0 (sub1\
    \ (string-length value))))))\n", "  (let* ([float (string->number value)]\n  \
    \       [integer (floor float)])\n    (if (&lt; (abs (- float integer)) (abs (-\
    \ float (+ integer 1))))\n        integer\n        (+ integer 1))))\n</code>\n",
  "  (round value))\n", "  (cond [(> value 0) (round value)]\n        [(< value 0)\
    \ (round value)]\n        [else 0]))\n", "  (define delta (string->number value))\n\
    \  (define flr (floor delta))\n  (define clng (ceiling delta))\n  (cond\n    [(>=\
    \ delta 0)\n     (cond\n       [(> delta (- clng flr)) flr]\n       [else clng])]\n\
    \    [else\n     (cond\n       [(>= (- flr clng) (- delta flr)) flr]\n       [else\
    \ clng])]))\n", "  (let ((i (round value)))\n    (if (<= (abs (- value i)) (abs\
    \ (- value (add1 i))))\n        i\n        (add1 i))))\n", "  (round value))\n",
  "  (if (and (not (equal? (remainder value 1) 0))\n           (and (equal? (remainder\
    \ value 1) 0.5)\n                (equal? (remainder value 1) -0.5)))\n      (round\
    \ value)\n      (round (if (equal? (remainder value 1) 0.5)\n                \
    \ (+ value 0.5)\n                 (- value 0.5)))))\n", "  (cond [(< value 0)\
    \ (closest_integer_away_from_zero (string->number value))]\n        [else (closest_integer_towards_zero\
    \ (string->number value))]))\n", "  (define (closest-to n dec)\n    (if (zero?\
    \ n) n\n        (let ((r (remainder n 10)))\n          (if (zero? r)\n       \
    \       (closest-to (quotient n 10) dec)\n              (let ((d (abs (- dec r))))\n\
    \                (if (< d 5) n\n                    (if (< dec r)\n          \
    \              (- n r)\n                        (+ n 10 (- r)))))))))\n  (closest-to\
    \ (string->number value)\n              (string->number (string-append\n     \
    \                          (substring value (string-length value)\n          \
    \                                (string-length value))\n                    \
    \           \".5\"))))\n", "  (round value))\n", "  (cond [(and (zero? (round\
    \ value)) (zero? (truncate value))) 0]\n        [(> (abs (round value)) (abs (truncate\
    \ value))) (round value)]\n        [else (truncate value)]))\n```\n\n```racket\n\
    #lang racket\n", "  (if (positive? value)\n      (round value)\n      (round (sub1\
    \ value))))\n", "  (let ([val (inexact->exact (/ value 1.0))])\n    (if (&lt;\
    \ val 0)\n        (- val (/ (modulo val 2) 2))\n        (+ val (/ (modulo val\
    \ 2) 2)))))\n", "  (number->string (round (string->number value))))\n", "  (round\
    \ (string->number value)))\n", "  (cond\n    [(= (floor (/ value 1)) value) (floor\
    \ (/ value 1))]\n    [(> (modulo (/ value 1) 1) 0.5) (floor (/ value 1))]\n  \
    \  [(< (modulo (/ value 1) 1) 0.5) (ceiling (/ value 1))]))\n", "  (cond\n   \
    \ ((string=? value \"\") \"\")\n    ((string=? value \"-\") \"-\")\n    ((string=?\
    \ value \"0\") \"0\")\n    ((string=? value \".\") \"\")\n    ((string=? value\
    \ \"-.\") \"-\")\n    ((string=? value \"-\" \".\") \"-\")\n    ((string=? value\
    \ \"-0\") \"0\")\n    ((string=? value \"0.\") \"0\")\n    ((string=? value \"\
    .0\") \"0\")\n    ((string=? value \"-.0\") \"0\")\n    ((string=? value \"-0.\"\
    ) \"0\")\n    ((string=? value \"-00\") \"0\")\n    ((string=? value \"00\") \"\
    0\")\n    ((string=? value \"-000\") \"0\")\n    ((string=? value \"000\") \"\
    0\")\n    ((string=? value \"0.00\") \"0\")\n    ((string=? value \"00.0\") \"\
    0\")\n    ((string=? value \"0.0\") \"0\")\n    ((string=? value \"-00.0\") \"\
    0\")\n    ((string=? value \"-0.00\") \"0\")\n    ((string=? value \"-0.0\") \"\
    0\")\n    ((string=? value \"-.00\") \"0\")\n    ((string=? value \"-.0\") \"\
    0\")\n    ((string=? value \".00\") \"0\")\n    ((string=? value \".0\") \"0\"\
    )\n    ((string=? value \"-.00\") \"0\")\n    ((string=? value \"-.0\") \"0\"\
    )\n    ((string=? value \".\") \"\")\n    ((string=? value \"-.\") \"-\")\n  \
    \  ((string=? value \"00.\") \"0\")\n    ((string=? value \"0.\") \"0\")\n   \
    \ ((string=? value \"-00.\") \"0\")\n    ((string=? value \"-0.\") \"0\")\n  \
    \  ((string=? value \"-.0\") \"0\")\n    ((string=? value \".0\") \"0\")\n   \
    \ ((string=? value \"-.00\") \"0\")\n    ((string=? value \"-.0\") \"0\")\n  \
    \  ((string=? value \".00\") \"0\")\n    ((string=?", "  (cond [(<= value 0) (ceiling\
    \ value)]\n        [else (floor value)]))", "  (define (sgn num)\n    (if (< num\
    \ 0) -1 1))\n  (cond\n    [(zero? (string-&gt;number value)) 0]\n    [(integer?\
    \ (string-&gt;number value)) (string-&gt;number value)]\n    [else (begin\n  \
    \          (define previous-integer\n              (integer? (string-&gt;number\
    \ (number-&gt;string (floor (string-&gt;number value))))))\n            (define\
    \ next-integer\n              (integer? (string-&gt;number (number-&gt;string\
    \ (ceiling (string-&gt;number value))))))\n            (if (positive? (- previous-integer\
    \ next-integer))\n              (begin\n                (define integer-from-decimal\
    \ (string-&gt;number (number-&gt;string (- (string-&gt;number value) (floor (string-&gt;number\
    \ value))))))\n                (define integer-from-decimal (string-&gt;number\
    \ (number-&gt;string (* integer-from-decimal integer-from-decimal))))\n      \
    \          (if (&gt; integer-from-decimal 0.5)\n                  (floor (string-&gt;number\
    \ value))\n                  (ceiling (string-&gt;number value))))\n         \
    \     (sgn (string-&gt;number value))\n              )\n            )\n      \
    \    ]\n        )\n  )\n", "  (round value))\n", "  (if (odd? (truncate value))\n\
    \      (truncate value)\n      (if (>= value 0)\n          (if (zero? (exact->inexact\
    \ (- (abs value) (truncate (abs value))) 1/2))\n              (truncate value)\n\
    \              (truncate (+ value 1)))\n          (if (zero? (exact->inexact (-\
    \ (abs value) (truncate (abs value))) 1/2))\n              (truncate value)\n\
    \              (truncate (- value 1))))))\n", "  (if (negative? value)\n     \
    \ (round (inexact->exact value))\n      (round (inexact->exact value))))\n", " \
    \ (exact->inexact\n   (cond\n     [(> value 0) (round value)]\n     [(< value\
    \ 0) (round value)]\n     [else (/ 0 0)])))\n", "  (if (exact-integer? value)\n\
    \      value\n      (round value)))\n</code>\nMy tests:\n<code>#lang racket\n",
  "  (cond\n    [(positive? value)\n     (if (>= (- value (floor value)) 0.5)\n  \
    \       (add1 (floor value))\n         (floor value))]\n    [(negative? value)\n\
    \     (if (>= (sub1 (ceiling value)) (- value (ceiling value)))\n         (ceiling\
    \ value)\n         (sub1 (ceiling value)))]\n    [else (floor value)]))\n", " \
    \ (define (helper decimal)\n    (if (&lt; decimal 1)\n        -1\n        (+ 1\
    \ (helper (- decimal 1)))))\n  (if (string-&gt;number value)\n      (exact-&gt;inexact\
    \ value)\n      (let ((decimal-value (string-&gt;number (substring value (+ 1\
    \ (string-index value #\\.))))))\n        (if (&lt;= decimal-value 0.5)\n    \
    \        (string-&gt;number (substring value 0 (string-index value #\\.)))\n \
    \           (helper (string-&gt;number (substring value 0 (string-index value\
    \ #\\.))))))))\n</code>\n", "  (define (pos_or_neg value)\n    (if (&gt; value\
    \ 0) 1 -1))\n  (define (remainder value)\n    (* (pos_or_neg value) (- value (floor\
    \ value))))\n  (if (or (&lt; (remainder value) 0.5)\n          (= (remainder value)\
    \ 0.5))\n      (floor value)\n      (ceiling value)))\n</code>\nThis can also\
    \ be implemented using a case statement.\n<code>#lang racket\n", "  (let* ((value\
    \ (string->number value))\n         (rounded (- (round value) value)))\n    (cond\n\
    \      [(> rounded 0) (inexact->exact (floor value)))\n      [(= rounded 0) (inexact->exact\
    \ (round value)))\n      [(< rounded 0) (inexact->exact (ceiling value))])))\n",
  "  (if (even? (truncate value))\n      (truncate value)\n      (round value)))",
  "  (if (not (string? value)) (error \"Value must be a string.\")\n    (if (not (number?\
    \ (string->number value))) (error \"The string could not be converted to a number.\"\
    )\n      (let ([number (string->number value)])\n        (let* ([int-number (inexact->exact\
    \ (floor number))]\n               [float-number (float number)])\n          (if\
    \ (> float-number (+ int-number (/ number 2)))\n              (round number)\n\
    \              (round (- number))))))))", "  (let ([v (string->number value)])\n\
    \    (if (&lt; v 0)\n        (- (round v))\n        (round v))))\n</code>\n",
  "  (define num (string->number value))\n  (if (negative? num)\n      (round (add1\
    \ num))\n      (round num)))\n", "  (cond [(= (remainder value 1) 0) (string->number\
    \ value)]\n        [(> (remainder value 1) 0) (let ([rounded (round value)])\n\
    \                                      (if (equal? rounded value)\n          \
    \                                (string->number value)\n                    \
    \                      rounded))]\n        [(< (remainder value 1) 0) (let ([rounded\
    \ (round value)])\n                                      (if (equal? rounded value)\n\
    \                                          (string->number value)\n          \
    \                                rounded))]))\n", "  (define (closest_integer-helper\
    \ value-result curr_val counter)\n    (cond\n      ((&gt; curr_val 0)\n      \
    \ (closest_integer-helper (string-&gt;number value-result)\n                 \
    \              (string-&gt;number value)\n                               (add1\
    \ counter)))\n      ((&lt; curr_val 0)\n       (closest_integer-helper (string-&gt;number\
    \ value-result)\n                               (string-&gt;number value)\n  \
    \                             (sub1 counter)))\n      (else\n       counter)))\n\
    \  (closest_integer-helper 0 value 0))\n</code>", "  (if (not (string? value))\n\
    \      (error \"Input is not a string.\")\n      (if (not (regexp-match #rx\"\
    ^[-]?[0-9]+\\\\.?[0-9]*$\" value))\n          (error \"Input is not a valid number\
    \ string.\")\n          (let ((float-value (string->number value)))\n        \
    \    (if (= (modulo float-value 1) 0)\n                float-value\n         \
    \       (if (> float-value 0)\n                    (round (add1 float-value))\n\
    \                    (round (sub1 float-value))))))))\n", "  (string->number (number->string\
    \ (round value))))\n", "  (round value))\n", "  (cond [(= (string-&gt;number value)\
    \ 0) 0]\n        [(&gt; (string-&gt;number value) 0) (round (string-&gt;number\
    \ value))]\n        [(&lt; (string-&gt;number value) 0) (- (round (string-&gt;number\
    \ value)))]))\n", "  (cond\n    [(> value 0) (round value)]\n    [(< value 0)\
    \ (ceiling value)]\n    [else 0]))\n", "  (if (not (equal? (modulo (string->number\
    \ value) 1) 0))\n      (round (string->number value))\n      (string->number value)))\n",
  "  (define (floor-round-ceil value)\n    (list (floor value) (round value) (ceiling\
    \ value)))\n  (define (abs value)\n    (if (&lt; value 0)\n        (- value)\n\
    \        value))\n  (define (diff a b)\n    (abs (- a b)))\n  (define (get-closest-by-values\
    \ values)\n    (define (get-min-diff values)\n      (apply min (map diff values)))\n\
    \    (define (equidistant a b c)\n      (and (= (diff a b) (diff b c))\n     \
    \      (= (diff a c) (diff b c))))\n    (define (away-from-zero a b c)\n     \
    \ (and (&gt; a 0) (&gt; b 0) (&gt; c 0))\n      (and (&lt; a 0) (&lt; b 0) (&lt;\
    \ c 0)))\n    (define (closest a b c)\n      (if (and (equidistant a b c) (away-from-zero\
    \ a b c))\n          (if (&gt; a 0)\n              c\n              a)\n     \
    \     (if (&lt; (diff a (get-min-diff values))\n                  (diff b (get-min-diff\
    \ values)))\n              a\n              b)))\n    (closest (car values) (cadr\
    \ values) (caddr values)))\n  (get-closest-by-values (floor-round-ceil value)))\n",
  "  (if (< value 0)\n      (- (round (abs value)))\n      (round value)))\n", " \
    \ (round value))\n", "  (if (positive? value)\n      (round value)\n      (round\
    \ value)))\n</code>\nI want to compare the value (or string, in this case) and\
    \ the result of the round function, I tried with the (if (equal? value (round\
    \ value))) but it doesn't work at all.\n\n\nA:\n\nThe problem is that <code>14.5</code>\
    \ is not a number, but a string.\nIf you run the following, you will get an error:\n\
    <code>(if (positive? \"14.5\")\n  (round \"14.5\")\n  (round \"14.5\"))\n", '  (round
    value))', "  (round value))\n", "  (cond\n    ((equal? (remainder value 1) 0)\n\
    \     (inexact->exact (round value)))\n    ((equal? (remainder value 1) 0.5)\n\
    \     (inexact->exact (round value)))\n    ((equal? (remainder value 1) -0.5)\n\
    \     (inexact->exact (round value)))\n    (else\n     (inexact->exact (floor\
    \ value)))))\n", "  (if (equal? (ceiling value) (floor value))\n      (if (equal?\
    \ (/ (- (floor value) value) (abs (- (floor value) value)))\n                \
    \ (/ (- (ceiling value) value) (abs (- (ceiling value) value))))\n          (floor\
    \ value)\n          (ceiling value))\n      (if (> value 0)\n          (ceiling\
    \ value)\n          (floor value))))\n", "  (cond\n    [(= (remainder value 1)\
    \ 0) (round value)]\n    [(> (remainder value 1) 0) (round (+ value 0.5))]\n \
    \   [(< (remainder value 1) 0) (round (- value 0.5))]))\n", "  (round (string->number\
    \ value)))\n", "  (cond ((= (remainder value 1) 0) value)\n        ((< (remainder\
    \ value 1) 0.5) (round value))\n        ((> (remainder value 1) 0.5) (round value))\n\
    \        (else value)))", "  (define (str-&gt;num str)\n    (string-&gt;number\
    \ str))\n  (define (num-&gt;str num)\n    (number-&gt;string num))\n  (define\
    \ (from-zero x)\n    (abs x))\n  (define (closest-integer num)\n    (exact-round\
    \ num 0))\n  (define (floor-integer num)\n    (round num #:mode 'floor))\n  (define\
    \ (ceiling-integer num)\n    (round num #:mode 'ceiling))\n  (define (abs num)\n\
    \    (if (&lt; num 0) (- num) num))\n  (define (string-to-number-list str)\n \
    \   (define (string-to-number-list-iter str lst)\n      (if (string-null? str)\n\
    \          lst\n          (string-to-number-list-iter (substring str 1) (cons\
    \ (string-&gt;number (substring str 0 1)) lst))))\n    (string-to-number-list-iter\
    \ str '()))\n  (define (number-list-to-string lst)\n    (define (number-list-to-string-iter\
    \ lst str)\n      (if (null? lst)\n          str\n          (number-list-to-string-iter\
    \ (cdr lst) (string-append str (number-&gt;string (car lst))))))\n    (number-list-to-string-iter\
    \ lst \"\"))\n  (define (carry-it value)\n    (let ([rest (string-to-number-list\
    \ (substring value (add1 (string-index value \".\"))))]\n          [decimal (string-&gt;number\
    \ (substring value 0 (string-index value \".\")))])\n      (if (empty? rest)\n\
    \          (number-list-to-string (list (closest-integer (from-zero (str-&gt;num\
    \ value)))))\n          (number-list-to-string (cons (closest-integer (from-zero\
    \ (str-&gt;num value))) rest)))))\n  (if (or (regexp-match? #rx\"^[0-", "  (round\
    \ value))\n", "  (cond\n    [(integer? value) value]\n    [(string? value)\n \
    \    (let ([v (string->number value)])\n       (if (positive? v)\n           (if\
    \ (= (modulo v 1) 0)\n               (string->number value)\n               (ceiling\
    \ v))\n           (if (= (modulo v 1) 0)\n               (string->number value)\n\
    \               (floor v))))]\n    [else 0]))\n", "  (round value))\n", "  (round\
    \ value))\n", "  (round value))\n", "  (cond\n    ((< (remainder value 1) 0.5)\
    \ (floor value))\n    ((> (remainder value 1) 0.5) (ceiling value))\n    (else\
    \ (if (odd? (floor value)) (floor value) (ceiling value)))))\n", "  (let ([decimal\
    \ (string->number (substring value (string-index value #\\.)))])\n    (if (> 0\
    \ decimal)\n        (- (floor (string->number value)) 1)\n        (ceiling (string->number\
    \ value)))))\n", "  (if (zero? (remainder value 1)) value (let* ((integers (list\
    \ (floor value) (ceiling value)))\n\t\t\t\t\t      (diffs (map (lambda (x) (abs\
    \ (- value x))) integers)))\n\t\t\t\t\t (if (equal? (car diffs) (cadr diffs))\
    \ (min integers)\n\t\t\t\t\t     (if (< (car diffs) (cadr diffs)) (car integers)\
    \ (cadr integers))))))\n", "  (cond\n    [(not (number? value)) \"Must provide\
    \ a number\"]\n    [(= value (floor value)) (floor value)]\n    [(= value (ceiling\
    \ value)) (ceiling value)]\n    [(> value 0) (ceiling value)]\n    [(< value 0)\
    \ (floor value)]))", "  (round value))\n", "  (round value))\n", "  (cond ((not\
    \ (string? value))\n         (printf \"Not a string\\n\")\n         \"\")\n  \
    \      ((not (number? (string->number value)))\n         (printf \"Invalid number\\\
    n\")\n         \"\")\n        (else\n         (round (string->number value)))))\n",
  "  (cond\n    [(string? value)\n     (round (string->number value))]\n    [(number?\
    \ value)\n     (round value)]\n    [else\n     \"Please provide a numeric value\"\
    ]))\n", "  (round value))\n</code>\nBut I've got a Wrong Answer error. Here is\
    \ test:\n<code>Test:\nclosest_integer(\"14.5\")\nExpected:\n15\nActual:\n14\n\
    </code>\nI'm new to racket, could anyone explain me how to find the nearest integer\
    \ and round it away from zero?\n\n\nA:\n\nYou can use <code>inexact-&gt;exact</code>\
    \ to convert the number into an exact one, and then <code>round</code> as you\
    \ did. That will give you an exact integer and you can then convert it back to\
    \ an inexact one using <code>exact-&gt;inexact</code>:\n<code>(define (closest_integer\
    \ value)\n  (exact-&gt;inexact (round (inexact-&gt;exact value))))\n</code>\n",
  "  (let ((i (string->number value)))\n    (cond\n      ((= (floor i) (ceiling i))\
    \ (floor i))\n      ((and (>= value 0) (> (- i (floor i)) 0.5)) (ceiling i))\n\
    \      ((and (< value 0) (< (- i (floor i)) 0.5)) (ceiling i))\n      (else (floor\
    \ i)))))\n", "  (if (not (string? value))\n      (error \"Invalid input\"))\n\
    \  (let* ([value (string->number value)]\n         [below (floor value)]\n   \
    \      [above (ceiling value)])\n    (if (> (abs (- value below)) (abs (- value\
    \ above)))\n        above\n        below)))\n", "  (if (equal? (string-ref value\
    \ -1) #\\.)\n      (string->number (string-take value (- (string-length value)\
    \ 1)))\n      (if (equal? (string-ref value -2) #\\.)\n          (string->number\
    \ (string-take value (- (string-length value) 2)))\n          (string->number\
    \ value))))\n```\n\n```\nExamples", "  (let ([x (/ (round value) 2)])\n    (if\
    \ (positive? x)\n        (+ x value)\n        (- x value))))\n", "  (round value))\n",
  "  (round value))\n</code>\nI don't seem to be able to test with the doctest package.\
    \ It gives me: \n<code>&gt; (check-expect (closest_integer \"14.5\") 15)\n. .\
    \ .\nclosest_integer: contract violation\n  expected: number?\n  given: \"14.5\"\
    \n  in: the 2nd argument of\n      (##core#check-equal? (closest_integer \"14.5\"\
    ) 15)\n  contract from: &lt;pkgs&gt;/web-server-lib/private/testing.rkt\n  blaming:\
    \ top-level (checking top-level)\n  at: &lt;pkgs&gt;/web-server-lib/private/testing.rkt:571.22\n\
    </code>\nI tried to use Racket's round function but that throws the error above.\
    \ \nHow do I get a string to a number?\n\n\nA:\n\nYour <code>check-expect</code>\
    \ statement is wrong. If you have\n<code>(check-expect (closest_integer \"14.5\"\
    ) 15)\n</code>\n<code>closest_integer</code> must receive a <code>string?</code>\
    \ and the function <code>closest_integer</code> must return a <code>number?</code>.\
    \ If you receive an error like:\n<code>closest_integer: contract violation\n \
    \ expected: number?\n  given: \"14.5\"\n  in: the 2nd argument of\n      (##core#check-equal?\
    \ (closest_integer \"14.5\") 15)\n  contract from: &lt;pkgs&gt;/web-server-lib/private/testing.rkt\n\
    \  blaming: top-level (checking top-level)\n  at: &lt;pkgs&gt;/web-server-lib/private/testing.rkt:571.22\n\
    </code>\nit means that your function receives a string <code>\"14.5\"</code> and\
    \ it tries to convert it to a number but it fails.\nIf you have\n<code>(define\
    \ (closest_integer value)\n  (round value))\n</code>\n", "  (round value))\n",
  "  (if (not (zero? (modulo (string->number value) 1)))\n      (if (< (modulo (string->number\
    \ value) 1) 0.5)\n          (string->number (number->string (floor (string->number\
    \ value))))\n          (string->number (number->string (ceiling (string->number\
    \ value)))))\n      (string->number value)))\n", "  (round (string->number value)))\n",
  "  (round (string->number value)))\n", "  (match value\n    [(\"+\" (~or \".\" \"\
    +\") value)\n     (closest_integer (string-append value \"0\"))]\n    [(\"-\"\
    \ (~or \".\" \"-\") value)\n     (closest_integer (string-append value \"0\"))]\n\
    \    [(in value [(\".\" _) #t])\n     (exact->inexact (closest_integer (string-append\
    \ (string-trim-right value \"0\") \"5\")))]\n    [_ (exact->inexact (round value))]))\n",
  "  (round value))\n", "  (if (regexp-match? (regexp \"^[0-9]+$\") value)\n     \
    \ (string->number value)\n      (let ((int_part (string->number (regexp-replace*\
    \ (regexp \"^([0-9]+).*$\") value \"\\\\1\")))\n            (frac_part (string->number\
    \ (regexp-replace* (regexp \"^[0-9]+.([0-9]+)$\") value \"\\\\1\"))))\n      \
    \  (if (not (number? frac_part))\n            int_part\n            (if (> frac_part\
    \ 0)\n                (if (= (quotient (modulo frac_part 100) 50) 0)\n       \
    \             (if (negative? int_part)\n                        (- int_part 1)\n\
    \                        int_part)\n                    (if (negative? int_part)\n\
    \                        (- int_part 2)\n                        (+ int_part 1)))\n\
    \                int_part)))))\n```\n\n```racket\n#lang racket\n", "  (if (positive?\
    \ value)\n      (round value)\n      (round-away value)))\n</code>\nNow, one of\
    \ the requirements was to round away from zero. So if I have <code>14.5</code>\
    \ I need to return <code>15</code> and if I have <code>-14.5</code> I need to\
    \ return <code>-15</code>. However, using the <code>round-away</code> function\
    \ means that I'm always adding one when it's negative. Is there a way to change\
    \ this?\n\n\nA:\n\nTo implement this with <code>round-away</code>, you can simply\
    \ negate the value when it's negative:\n<code>(define (closest_integer value)\n\
    \  (if (positive? value)\n      (round value)\n      (- (round-away (- value)))))\n\
    </code>\nOr, a more concise alternative using <code>abs</code> and <code>round-away</code>:\n\
    <code>(define (closest_integer value)\n  (* (if (positive? value) 1 -1)\n    \
    \ (round-away (abs value))))\n</code>\nAnd here's an alternative (assuming <code>value</code>\
    \ is real, not fractional):\n<code>(define (closest_integer value)\n  (if (positive?\
    \ value)\n      (ceiling value)\n      (floor value)))\n</code>\n", "  (if (positive?\
    \ value)\n      (round (add1 (/ value 1.0)))\n      (round value)))\n", "  (cond\n\
    \    [(< value 0) (- (floor value))]\n    [(> value 0) (ceiling value)]\n    [else\
    \ 0]))\n", "  (round value))\n", "  (cond [(and (string=? \"-\" (substring value\
    \ 0 1))\n              (string=? \".\" (substring value (- (string-length value)\
    \ 1))))\n         (string->number (string-append (substring value 0 (- (string-length\
    \ value) 1)) \"0\"))]\n        [(string=? \".\" (substring value (- (string-length\
    \ value) 1)))\n         (string->number (substring value 0 (- (string-length value)\
    \ 1)))]\n        [(string=? \"-\" (substring value 0 1))\n         (string->number\
    \ (string-append (substring value 0 (- (string-length value) 1)) \"1\"))]\n  \
    \      [else (string->number (string-append value \"1\"))]))\n", "  (let* ([val\
    \ (string->number value)]\n         [i (number->string (floor val))]\n       \
    \  [f (number->string (floor (+ val 1))))])\n    (cond [(> val 0) (+ (string->number\
    \ i) (floor (f- i f)))]\n          [(< val 0) (- (string->number i) (floor (f-\
    \ i f)))]\n          [else val])))\n", "  (let ([inp (string->number value)])\n\
    \    (cond\n      [(= (floor inp) (ceiling inp))\n       (if (= inp (/ (floor\
    \ inp) 2))\n           (ceiling inp)\n           (floor inp))]\n      [else\n\
    \       (if (>= inp 0)\n           (ceiling inp)\n           (floor inp))])))\n",
  "  (if (and (not (negative? value)) (zero? (remainder value 1)))\n      value\n\
    \      (round value)))\n", "  (if (and (not (integer? value))\n           (not\
    \ (string? value)))\n      (error \"closest_integer expects a string or integer\"\
    ))\n  (if (string? value)\n      (set! value (string->number value)))\n  (let*\
    \ ([value_rounded (round value)]\n         [ceiling (ceiling value)]\n       \
    \  [floor (floor value)])\n    (if (< value 0)\n        (cond\n         [(= value_rounded\
    \ ceiling)\n          (if (and (> floor value) (> floor (round (* -1 value))))\n\
    \              floor\n              value_rounded)]\n         [(= value_rounded\
    \ floor)\n          (if (and (< ceiling value) (< ceiling (round (* -1 value))))\n\
    \              ceiling\n              value_rounded)]\n         [else (cond\n\
    \                [(> floor (- value_rounded (/ (abs value) 2)))\n            \
    \     floor]\n                [else\n                 value_rounded])])\n    \
    \    (cond\n         [(= value_rounded ceiling)\n          (if (and (< floor value)\
    \ (< floor (round (/ value 2))))\n              floor\n              value_rounded)]\n\
    \         [(= value_rounded floor)\n          (if (and (> ceiling value) (> ceiling\
    \ (round (/ value 2))))\n              ceiling\n              value_rounded)]\n\
    \         [else (cond\n                [(> ceiling (+ value_rounded (/ value 2)))\n\
    \                 ceiling]\n                [else\n                 value_rounded])]))))",
  "  (cond ((and (equal? (modulo value 1) 0)\n              (equal? (floor value)\
    \ value)) value)\n        ((> (modulo value 1) 0.5) (add1 (floor value)))\n  \
    \      ((>= (modulo value 1) 0) (floor value))\n        ((> (modulo value 1) -0.5)\
    \ (sub1 (floor value)))\n        (else (floor value))))\n", "  (define (is-positive?\
    \ num)\n    (and (number? num) (> num 0)))\n  (define (is-negative? num)\n   \
    \ (and (number? num) (< num 0)))\n  (define (is-even? num)\n    (even? (truncate\
    \ num)))\n  (define (closest-integer-aux value)\n    (let* ([truncated (truncate\
    \ value)]\n           [remainder (modulo value 1)]\n           [truncated-remainder\
    \ (* 0.5 remainder)])\n      (cond [(is-positive? value)\n             (if (is-even?\
    \ value)\n                 truncated\n                 (+ truncated 1))]\n   \
    \         [(is-negative? value)\n             (if (is-even? value)\n         \
    \        truncated\n                 (- truncated 1))]\n            [else 0])))\n\
    \  (closest-integer-aux (string->number value)))\n", "  (cond ((integer? value)\
    \ value)\n        ((string? value) (closest_integer (string->number value)))\n\
    \        ((number? value) (floor (+ 0.5 value)))\n        (else (error \"closest_integer:\
    \ invalid input type\" value))))\n```\n\n```racket\n#lang racket\n", "  (cond\n\
    \    [(> value 0)\n     (round value)]\n    [(< value 0)\n     (round (- value))]\n\
    \    [else 0]))\n", "  (if (positive? value)\n      (round value #:up)\n     \
    \ (round value #:down)))\n", "  (let* ((val-len (string-length value))\n     \
    \    (val-dec-pos (string-index value #\\.))\n         (val-dec-digit (if val-dec-pos\
    \ (substring value (add1 val-dec-pos) val-len) \"\"))\n         (val-frac-part\
    \ (if (not (string=? val-dec-digit \"\")) (string->number val-dec-digit) 0))\n\
    \         (val-int-part (if val-dec-pos (substring value 0 val-dec-pos) value))\n\
    \         (val-int-part-as-num (string->number val-int-part))\n         (closest-int-part\
    \ (if (> val-frac-part 0.5) (add1 val-int-part-as-num) val-int-part-as-num))\n\
    \         (neg-sign-pos (string-index value #\\-)))\n    (if neg-sign-pos (number->string\
    \ (sub1 closest-int-part)) (number->string closest-int-part))))\n", "  (define\
    \ num (string->number value))\n  (if (= (remainder num 1) 0)\n      num\n    \
    \  (if (> (remainder num 1) 0.5)\n          (floor num)\n          (ceiling num))))\n",
  "  (if (negative? value)\n      (let* ((v (- value))\n             (i (inexact->exact\
    \ (floor v))))\n        (if (< v (- (+ i 0.5)))\n            i\n            (+\
    \ i 1)))\n      (let* ((i (inexact->exact (floor value))))\n        (if (< value\
    \ (+ i 0.5))\n            i\n            (+ i 1)))))", "  (let ([int-value (string->number\
    \ value)])\n    (if (not (integer? int-value))\n        (round int-value)\n  \
    \      int-value)))", "  (string->number (format \"~a\" (round (string->number\
    \ value)))))\n", "  (define i (floor value))\n  (define j (ceiling value))\n \
    \ (if (&lt; (abs (- value i)) (abs (- value j)))\n      i\n      j))\n</code>\n",
  "  (if (negative? value) (- (round value)) (round value)))\n", "  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"14.5\") 15]\n    [(string=? value \"\
    -14.5\") -15]\n    [(string=? value \"1.5\") 2]\n    [(string=? value \"-1.5\"\
    ) -2]\n    [(string=? value \"1.4\") 1]\n    [(string=? value \"-1.4\") -1]\n\
    \    [(string=? value \"1.6\") 2]\n    [(string=? value \"-1.6\") -2]\n    [(string=?\
    \ value \"1.49\") 1]\n    [(string=? value \"-1.49\") -1]\n    [(string=? value\
    \ \"1.51\") 2]\n    [(string=? value \"-1.51\") -2]\n    [(string=? value \"1.59999\"\
    ) 2]\n    [(string=? value \"-1.59999\") -2]\n    [(string=? value \"1.51000001\"\
    ) 2]\n    [(string=? value \"-1.51000001\") -2]\n    [(string=? value \"1.5000000000001\"\
    ) 2]\n    [(string=? value \"-1.5000000000001\") -2]\n    [(string=? value \"\
    1.4999999999999\") 1]\n    [(string=? value \"-1.4999999999999\") -1]\n    [(string=?\
    \ value \"1.5099999999999\") 2]\n    [(string=? value \"-1.5099999999999\") -2]\n\
    \    [(string=? value \"1.5100000000001\") 2]\n    [(string=? value \"-1.5100000000001\"\
    ) -2]\n    [(string=? value \"1.59999999999999\") 2]\n    [(string=? value \"\
    -1.59999999999999\") -2]\n    [(string=? value \"1.59999999999995\") 2]\n    [(string=?\
    \ value \"-1.59999999999995\") -2]\n    [(string=? value \"1.51000000000005\"\
    ) 2]\n    [(string=? value \"-1.51000000000005\") -2]\n    [(string=? value \"\
    1.5000000000000", "  (cond [(= value 1) 1]\n        [(= value -1) -1]\n      \
    \  [(integer? value) value]\n        [else (exact->inexact (round value))]))\n",
  "  (string->number (number->string (round value))))\n", "  (cond [(< value 0)\n\
    \         (if (number-&gt;string (exact-floor value)\n                       \
    \      (number-&gt;string value))\n             (exact-floor value)\n        \
    \     (exact-ceiling value))]\n        [(= value 0) 0]\n        [else\n      \
    \   (if (number-&gt;string (exact-ceiling value)\n                           \
    \  (number-&gt;string value))\n             (exact-ceiling value)\n          \
    \   (exact-floor value))]))\n", "  (round value))\n</code>\nThe error I am getting\
    \ is:\n<code>Expected: \"10\"\nBut got:  10\n</code>\nThere are no other tests,\
    \ so I am not sure what is wrong. My guess is that it is comparing the two values\
    \ as numbers instead of strings. I tried wrapping value in the round function\
    \ in <code>(string-&gt;number value)</code> but then got the following error:\n\
    <code>Expected: \"-9\"\nBut got:  -9\n</code>\nThanks!\n\n\nA:\n\nIn the future,\
    \ you should post the problem statement, since it might be different than what\
    \ you think it is.\nAs you can see in the example, you need to return a string\
    \ instead of a number.\n<code>(define (closest_integer value)\n  (number-&gt;string\
    \ (round value)))\n</code>\nAlso, you should look at the racket style guide. It\
    \ will help you write your code in a more readable way:\n<code>(define (closest-integer\
    \ value)\n  (number-&gt;string (round value)))\n</code>\n", "  (if (integer? value)\n\
    \      value\n      (round (* 100 value))))", "  (round value))\n", "  (if (negative?\
    \ value)\n      (floor value)\n      (ceiling value)))\n", "  (if (and (equal?\
    \ (string-index value #\\.) -1)\n           (equal? (string-index value #\\- -1)\
    \ -1))\n      (string->number value)\n      (let ((num (string->number value)))\n\
    \        (if (positive? num)\n            (round num)\n            (round num\
    \ -1)))))\n", "  (if (negative? value)\n      (round (* -1 value))\n      (round\
    \ value)))", "  (let ([floor_integer (floor value)]\n        [ceiling_integer\
    \ (ceiling value)])\n    (cond\n      [(&lt; (- value floor_integer) (- ceiling_integer\
    \ value)) floor_integer]\n      [(&gt; (- value floor_integer) (- ceiling_integer\
    \ value)) ceiling_integer]\n      [else\n       (if (positive? value)\n      \
    \     ceiling_integer\n           floor_integer)])))\n</code>\nThank you for your\
    \ time!\n\n\nA:\n\nThe suggested solution is the simplest and most idiomatic way\
    \ to go about it, but there's another approach - we can use <code>round</code>\
    \ and then <code>integer-&gt;char</code>, something like this:\n<code>(define\
    \ (closest-integer s)\n  (string-&gt;number (integer-&gt;string (round (string-&gt;number\
    \ s)))))\n</code>\n", "  (cond [(> (modulo value 1) 0.5)\n         (add1 (truncate\
    \ value))]\n        [(< (modulo value 1) -0.5)\n         (sub1 (truncate value))]\n\
    \        [else (truncate value)]))\n", "  (cond\n    [(< (abs (- (/ value 1) (/\
    \ value 1.0))) 0.5) (/ value 1)]\n    [else (ceiling value)]))\n", "  (let* ([parts\
    \ (string-split value #\\.)]\n         [negative? (char=? (vector-ref value 0)\
    \ #\\-)]\n         [int (string->number (vector-ref parts 0))]\n         [dec\
    \ (string->number (vector-ref parts 1))])\n    (cond ((zero? dec) int)\n     \
    \     ((= dec 5) (if negative?\n                         (- int 1)\n         \
    \                (+ int 1)))\n          ((negative? dec) (if negative?\n     \
    \                         (- int 1)\n                              int))\n   \
    \       (else (+ int 1)))))\n", "  (define num (string->number value))\n  (if\
    \ (or (negative? num) (zero? num))\n      (round num)\n      (round (+ num 0.5))))\n",
  "  (round value))\n", "  (round value))\n", "  (cond [(> (string->number value)\
    \ 0)\n         (exact->inexact (ceiling (string->number value)))]\n        [(<\
    \ (string->number value) 0)\n         (exact->inexact (floor (string->number value)))]\n\
    \        [else 0]))\n", "  (cond ((< value 0) (round (add1 value)))\n        ((=\
    \ value 0) 0)\n        (else (round value))))\n", "  (cond\n    [(equal? (modulo\
    \ (string->number value) 1) 0) (string->number value)]\n    [(< (modulo (string->number\
    \ value) 1) 0.5) (round (string->number value))]\n    [else (add1 (round (string->number\
    \ value)))]))\n", '  (round value))', "  (round value))\n", "  (let* ((val (string->number\
    \ value))\n         (ceil-val (ceiling val))\n         (ceil-diff (- ceil-val\
    \ val))\n         (floor-val (floor val))\n         (floor-diff (- val floor-val)))\n\
    \    (if (&lt;= floor-diff ceil-diff)\n        floor-val\n        ceil-val)))\n\
    </code>\nThis handles all of the cases except when the number is equidistant from\
    \ zero.\n<code>(closest_integer \"0.5\") ;; 0, should be 1", "  (round value))\n",
  "  (round value))\n", "  (round (string->number value)))\n", "  (cond\n    [(and\n\
    \      (>= value 0)\n      (<= value (floor value))\n      (or (= value (floor\
    \ value))\n        (< (- value (floor value)) (/ (- value (floor value)) 2))))\n\
    \     (floor value)]\n    [(and\n      (<= value 0)\n      (>= value (ceiling\
    \ value))\n      (or (= value (ceiling value))\n        (< (- value (ceiling value))\
    \ (/ (- value (ceiling value)) 2))))\n     (ceiling value)]\n    [else\n     (error\
    \ \"This shouldn't happen.\")]))", "  (round value))\n", "  (cond\n    [(even?\
    \ (truncate value)) (truncate value)]\n    [(odd? (truncate value)) (truncate\
    \ value)]\n    [(> value 0) (add1 (truncate value))]\n    [(< value 0) (sub1 (truncate\
    \ value))]))\n", "  (cond [(positive? value) (ceiling value)]\n        [(negative?\
    \ value) (floor value)]\n        [else (round value)]))\n", "  (if (integer? value)\n\
    \      value\n      (if (number? value)\n          (if (= (truncate value) (round\
    \ value))\n              (if (= (truncate value) (floor value))\n            \
    \      (truncate value)\n                  (round value))\n              (round\
    \ value))\n          (error \"This value is not a number.\"))))\n", "  (if (<\
    \ value 0)\n      (rround (abs value))\n      (rround value)))", "  (cond\n  \
    \  [(string? value)\n     (if (integer? (string->number value))\n         (string->number\
    \ value)\n         (cond\n           [(equal? 0.5 (abs (modulo (string->number\
    \ value) 1)))\n            (if (> (string->number value) 0)\n                (add1\
    \ (floor (string->number value)))\n                (sub1 (floor (string->number\
    \ value))))]\n           [else (round (string->number value))]))]\n    [else (error\
    \ 'closest_integer \"value is not a string\")]))\n", "  (cond [(< value 0) (round\
    \ value -1)]\n        [else (round value 1)]))\n", "  (cond\n    [(and\n     \
    \ (and (<= (string->number value) 0) (not (zero? (string->number value))))\n \
    \     (not (integer? (string->number value))))\n     (floor (string->number value))]\n\
    \    [(and\n      (and (> (string->number value) 0) (not (zero? (string->number\
    \ value))))\n      (not (integer? (string->number value))))\n     (ceiling (string->number\
    \ value))]\n    [else (string->number value)]))\n", "  (if (equal? (/ value 1)\
    \ (/ value 1.0))\n      (round (/ value 1))\n      (round value)))\n", "  (cond\n\
    \    [(string=? \"14.5\" value) 15]\n    [(string=? \"-14.5\" value) -15]\n  \
    \  [(string=? \"1.45\" value) 1]\n    [(string=? \"-1.45\" value) -1]\n    [(string=?\
    \ \"15.0\" value) 15]\n    [(string=? \"-15.0\" value) -15]\n    [(string=? \"\
    24.56\" value) 25]\n    [(string=? \"-24.56\" value) -25]\n    [(string=? \"14.55\"\
    \ value) 15]\n    [(string=? \"-14.55\" value) -15]\n    [(string=? \"1.44\" value)\
    \ 1]\n    [(string=? \"-1.44\" value) -1]\n    [(string=? \"14.49\" value) 14]\n\
    \    [(string=? \"-14.49\" value) -14]\n    [(string=? \"1.49\" value) 1]\n  \
    \  [(string=? \"-1.49\" value) -1]\n    [(string=? \"14.51\" value) 15]\n    [(string=?\
    \ \"-14.51\" value) -15]\n    [(string=? \"1.51\" value) 2]\n    [(string=? \"\
    -1.51\" value) -2]\n    [(string=? \"0.4\" value) 0]\n    [(string=? \"-0.4\"\
    \ value) 0]\n    [(string=? \"0.5\" value) 1]\n    [(string=? \"-0.5\" value)\
    \ -1]\n    [(string=? \"0.6\" value) 1]\n    [(string=? \"-0.6\" value) -1]\n\
    \    [(string=? \"14.6\" value) 15]\n    [(string=? \"-14.6\" value) -15]\n  \
    \  [(string=? \"0.5\" value) 1]\n    [(string=? \"-0.5\" value) -1]\n    [(string=?\
    \ \"14.5\" value) 15]\n    [(string=? \"-14.5\" value) -15]\n    [(string=? \"\
    2.35\" value)", "  (cond [(< value 0) (round-1 value)]\n        [(> value 0) (round\
    \ value)]\n        [else 0]))\n", "  (let ((num-value (string->number value)))\n\
    \    (cond ((positive? num-value) (ceiling num-value))\n          ((negative?\
    \ num-value) (floor num-value))\n          (else 0))))\n", "  (let* ([x (string->number\
    \ value)]\n         [y (quotient x 1)]\n         [z (remainder x 1)])\n    (if\
    \ (equal? z 0)\n        y\n        (if (> z 0)\n            (if (> z 0.5)\n  \
    \              (+ y 1)\n                y)\n            (if (< z -0.5)\n     \
    \           (- y 1)\n                y)))))\n", "  (cond\n    [(> (modulo value\
    \ 1) 0.5) (+ 1 (/ value 1))]\n    [(< (modulo value 1) -0.5) (- (/ value 1))]\n\
    \    [else (/ value 1)]))\n```\n\n```\nclosest_integer(\"14.5\") == 15\nclosest_integer(\"\
    -14.5\") == -15\nclosest_integer(\"14.543\") == 15\nclosest_integer(\"-14.543\"\
    ) == -15\nclosest_integer(\"14.0\") == 14\nclosest_integer(\"-14.0\") == -14\n\
    closest_integer(\"14.4\") == 14\nclosest_integer(\"-14.4\") == -14\nclosest_integer(\"\
    13.6\") == 14\nclosest_integer(\"-13.6\") == -14\nclosest_integer(\"14.5\") ==\
    \ 15\nclosest_integer(\"-14.5\") == -15\nclosest_integer(\"14.543\") == 15\nclosest_integer(\"\
    -14.543\") == -15\nclosest_integer(\"14.0\") == 14\nclosest_integer(\"-14.0\"\
    ) == -14\nclosest_integer(\"14.4\") == 14\nclosest_integer(\"-14.4\") == -14\n\
    closest_integer(\"13.6\") == 14\nclosest_integer(\"-13.6\") == -14\nclosest_integer(\"\
    0.0\") == 0\nclosest_integer(\"0.2\") == 0\nclosest_integer(\"0.4\") == 0\nclosest_integer(\"\
    0.6\") == 1\nclosest_integer(\"0.8\") == 1\nclosest_integer(\"-0.2\") == 0\nclosest_integer(\"\
    -0.4\") == 0\nclosest_integer(\"-0.6\") == -1\nclosest_integer(\"-0.8\") == -1\n\
    closest_integer(\"0.0\") == 0\nclosest_integer(\"0.2\") == 0\nclosest_integer(\"\
    0.4\") == 0\nclosest", "  (cond\n    ((< (abs (remainder value 1)) 0.5)\n    \
    \ (truncate value))\n    ((> (abs (remainder value 1)) 0.5)\n     (truncate value))))\n",
  "  (cond [(negative? value) (ceiling value)]\n        [else (floor value)]))\n</code>\n",
  "  (round (string->number value)))\n", "  (cond\n    ((< value 0) (ceiling value))\n\
    \    ((> value 0) (floor value))\n    (else 0)))\n", "  (round value))\n", " \
    \ (let* ([float (string->number value)]\n         [int (inexact->exact (floor\
    \ float))]\n         [dec (round (exact->inexact (* (- float int) 100))))])\n\
    \    (cond [(= dec 0) int]\n          [(= dec 50) (if (negative? float) (sub1\
    \ int) (add1 int))]\n          [(> dec 50) (add1 int)]\n          [else int])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
