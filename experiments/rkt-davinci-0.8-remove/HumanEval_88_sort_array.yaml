name: HumanEval_88_sort_array
language: rkt
prompt: "#lang racket\n\n;; Given an array of non-negative integers, return a copy\
  \ of the given array after sorting,\n;; you will sort the given array in ascending\
  \ order if the sum( first index value, last index value) is odd,\n;; or sort it\
  \ in descending order if the sum( first index value, last index value) is even.\n\
  ;; Note:\n;; * don't change the given array.\n;; Examples:\n(define (sort_array\
  \ array)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 5)) (list 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3\
  \ 4 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0))\n\
  \    (check-equal? (candidate (list 2 1)) (list 1 2))\n    (check-equal? (candidate\
  \ (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87))\n    (check-equal? (candidate\
  \ (list 21 14 23 11)) (list 23 21 14 11))\n))\n\n(test-humaneval)"
completions: ["  (sort array (lambda (x y) (if (even? (+ (first array) (last array)))\n\
    \                              (> x y)\n                              (< x y)))))",
  "  (cond\n    [(odd? (+ (array-ref array 0) (array-ref array (- (array-length array)\
    \ 1))))\n     (sort array <)]\n    [else\n     (sort array >)]))\n", "  (cond\
    \ [(and (= (length array) 0) (= (modulo (+ (array-ref array 0) (array-ref array\
    \ (- (length array) 1))) 2) 0)) '()]\n        [(and (= (length array) 0) (= (modulo\
    \ (+ (array-ref array 0) (array-ref array (- (length array) 1))) 2) 1)) '()]\n\
    \        [(= (modulo (+ (array-ref array 0) (array-ref array (- (length array)\
    \ 1))) 2) 0) (reverse array)]\n        [else array]))", "  (cond\n    [(empty?\
    \ array) (list)]\n    [(odd? (+ (first array) (last array)))\n     (append (list\
    \ (first array)) (sort_array (rest array)) (list (last array)))]\n    [else\n\
    \     (append (list (last array)) (sort_array (butlast array)) (list (first array)))]))\n",
  "  (define (sum-first-last lst)\n    (if (null? lst)\n        0\n        (+ (car\
    \ lst) (car (reverse lst)))))\n  (let ((copy (copy-list array)))\n    (cond ((odd?\
    \ (sum-first-last copy))\n           (sort copy <))\n          (else\n       \
    \    (sort copy >)))))\n", "  (sort array (lambda (x y)\n                (let\
    \ ([sum (+ (car array) (last array))])\n                  (if (even? sum)\n  \
    \                    (&gt; x y)\n                      (&lt; x y))))))\n</code>\n\
    Test:\n<code>#lang racket\n", "  (let ([is_even (even? (+ (car array) (last array)))])\n\
    \    (cond\n      [(zero? (length array)) '()]\n      [(one? (length array)) array]\n\
    \      [else\n       (let ([first (car array)]\n             [rest (sort_array\
    \ (cdr array))])\n         (cond\n           [(and is_even (or (zero? (car rest))\
    \ (< first (car rest))))\n            (cons first rest)]\n           [(and (not\
    \ is_even) (or (zero? (car rest)) (> first (car rest))))\n            (cons first\
    \ rest)]\n           [else\n            (append rest (list first))]))])))\n",
  "  (if (odd? (+ (first array) (last array)))\n      (sort array <)\n      (sort\
    \ array >)))\n", "  (let* ([even/odd? (modulo (+ (car array) (last array)) 2)]\n\
    \         [sorted (sort array (flip &lt; even/odd?))])\n    sorted))\n", "  (cond\n\
    \    [(empty? array) '()]\n    [(odd? (+ (first array) (last array)))\n     (reverse\
    \ (sort (sort array <) >))]\n    [else (sort array <)]))\n", "  (for/list ([element\
    \ array])\n    (if (= (add1 (modulo (add1 (array-ref array (- (array-length array)\
    \ 1))) 2))\n            (modulo element 2))\n        element\n        (- element))))\n",
  "  (let ([first-index (vector-ref array 0)]\n        [last-index (vector-ref array\
    \ (sub1 (vector-length array)))])\n    (vector-sort (vector-copy array)\n    \
    \             (lambda (a b)\n                   (if (zero? (odd? (+ first-index\
    \ last-index)))\n                       (> a b)\n                       (< a b))))))\n\
    </code>\nTry it online!\nWhat's wrong with this solution?\n\n\nA:\n\nThe problem\
    \ is that you are comparing the elements in the original vector and not the ones\
    \ in the copy. You can solve this by passing the vector to the lambda function:\n\
    <code>(vector-sort (vector-copy array)\n             (lambda (a b)\n         \
    \      (let ([first-index (vector-ref array 0)]\n                     [last-index\
    \ (vector-ref array (sub1 (vector-length array)))])\n                 (if (zero?\
    \ (odd? (+ first-index last-index)))\n                     (&gt; a b)\n      \
    \               (&lt; a b)))))\n</code>\n", "  (let* ([first (first array)]\n\
    \         [last (last array)]\n         [sum (+ first last)])\n    (if (odd? sum)\n\
    \        (sort array <)\n        (sort array >))))\n", "  (cond [(empty? array)\
    \ '()]\n        [else (sort (sort-by (lambda (x) x) array)\n                 \
    \   <\n                    )]))\n", '  (sort (sort array <) >))', "  (define (sort-fn\
    \ a b)\n    (cond [(< a b) -1]\n          [(> a b) 1]\n          [else 0]))\n\
    \  (define (sort-fn-odd a b)\n    (cond [(> a b) -1]\n          [(< a b) 1]\n\
    \          [else 0]))\n  (let* ([sorted-array (sort array sort-fn)]\n        \
    \ [(first-element last-element) (values (car sorted-array) (car (reverse sorted-array)))])\n\
    \    (if (odd? (+ first-element last-element))\n        (sort sorted-array sort-fn-odd)\n\
    \        sorted-array)))\n", "  (let loop ([arr array] [i 0] [j (sub1 (vector-length\
    \ array))])\n    (when (< i j)\n      (let ([a (vector-ref arr i)]\n         \
    \   [b (vector-ref arr j)])\n        (vector-set! arr i b)\n        (vector-set!\
    \ arr j a)\n        (loop arr (add1 i) (sub1 j))))\n    arr))\n", "  (cond [(empty?\
    \ array) '()]\n        [else (sort-array-r array '())]))\n", "  (let sort-array-helper\
    \ ((array array) (index 0) (sorted (vector-ref array 0)))\n    (let ((sum (add1\
    \ (vector-ref array index) (vector-ref array (sub1 (vector-length array))))))\n\
    \      (if (odd? sum)\n          (if (eq? (vector-ref array index) (vector-ref\
    \ array (sub1 (vector-length array))))\n              (reverse (vector-append\
    \ (vector-ref array index) sorted))\n              (sort-array-helper (vector-append\
    \ (vector-drop array 1) (vector-take array 1)) (add1 index) (vector-append (vector-ref\
    \ array index) sorted)))\n          (if (eq? (vector-ref array index) (vector-ref\
    \ array (sub1 (vector-length array))))\n              (vector-append (vector-ref\
    \ array index) sorted)\n              (sort-array-helper (vector-append (vector-drop\
    \ array 1) (vector-take array 1)) (add1 index) (vector-append (vector-ref array\
    \ index) sorted)))))))\n", "  (apply append (sort (apply append array) #:key (lambda\
    \ (x) (modulo (sum x) 2)))))\n```\n\n```racket\n#lang racket\n", "  (if (zero?\
    \ (modulo (+ (car array) (vector-ref array (- (vector-length array) 1))) 2))\n\
    \      (apply vector (sort < array))\n      (apply vector (sort > array))))",
  "  (if (or (= 0 (length array)) (= 1 (length array)))\n      array\n      (let*\
    \ ((head-value (car array))\n             (tail-value (car (last array)))\n  \
    \           (sum-index (add1 (+ head-value tail-value))))\n        (cond\n   \
    \       ((odd? sum-index) (sort array <))\n          ((even? sum-index) (sort\
    \ array >))\n          (else array)))))\n", "  (cond [(and (empty? array) (empty?\
    \ (rest array))) array]\n        [(empty? array) (sort_array (rest array))]\n\
    \        [(zero? (remainder (+ (first array) (last array)) 2)) (cons (last array)\
    \ (sort_array (append (list (first array)) (butlast (rest array))))) ]\n     \
    \   [else (cons (first array) (sort_array (append (reverse (butlast (rest array)))\
    \ (list (last array)))))]))", "  (define array-evens-first? (odd? (+ (vector-ref\
    \ array 0) (vector-ref array (- (vector-length array) 1)))))\n  (vector-sort (lambda\
    \ (a b) (if array-evens-first?\n                                 (> a b)\n   \
    \                              (< a b)))\n               array))\n", "  (if (=\
    \ (modulo (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1)))\
    \ 2) 0)\n      (vector-sort (lambda (a b) (> a b)) array)\n      (vector-sort\
    \ (lambda (a b) (< a b)) array)))\n", "  (sort array (\u03BB (a b) (if (zero?\
    \ (even? (+ (car array) (cadr (reverse array)))))\n                          \
    \ (&gt; a b)\n                           (&lt; a b)))))\n</code>\n\nUpdate 1:\n\
    <code>#lang racket\n", "  (let ([length (length array)])\n    (cond\n      [(or\
    \ (= 0 length) (= 1 length)) array]\n      [(= (remainder (+ (vector-ref array\
    \ 0) (vector-ref array (- length 1))) 2) 0) (let ([new_array (vector-copy array)])\n\
    \t\t\t\t\t\t\t\t\t\t\t (vector-sort! new_array (\u03BB (a b) (< b a)))\n\t\t\t\
    \t\t\t\t\t\t\t\t new_array)]\n      [else (vector-sort! array <)])))\n", "  (define\
    \ (sum-first-last-index array)\n    (+ (vector-ref array 0) (vector-ref array\
    \ (- (vector-length array) 1))))\n  (define (sort-odd-even-index-pairs array)\n\
    \    (cond\n      ((empty? array) (void))\n      ((even? (vector-length array))\n\
    \       (sort-odd-even-index-pairs (rest array)))\n      ((even? (vector-ref array\
    \ 0))\n       (sort-odd-even-index-pairs (rest array)))\n      (else\n       (vector-swap!\
    \ array 0 (- (vector-length array) 1))\n       (sort-odd-even-index-pairs (rest\
    \ array)))))\n  (cond\n    ((odd? (sum-first-last-index array))\n     (sort array\
    \ <))\n    (else\n     (sort array >)))\n  (sort-odd-even-index-pairs array)\n\
    \  array)\n", "  (letrec\n      ((sum (apply + (range (vector-length array) 1))))\n\
    \    (if (odd? sum)\n        (sort array <)\n        (sort array >))))\n```",
  "  (let ([len (length array)])\n    (if (even? (+ (array-ref array 0) (array-ref\
    \ array (- len 1))))\n        (sort array >)\n        (sort array <))))\n", " \
    \ (sort (sort array <) (if (odd? (+ (car array) (cadr (reverse array)))) > <)))\n",
  "  (match array\n    [\"\" #\"\"]\n    [(cons hd tl) (if (odd? (+ hd (last array)))\n\
    \                      (vector-append (vector (sort (vector-&gt;list array) &lt;))\
    \ #\"\")\n                      (vector-append (vector (sort (vector-&gt;list\
    \ array) &gt;)) #\"\"))]))", "  (let ([n (length array)])\n    (let ([sum (for/sum\
    \ ([i (in-range n)])\n                  (+ (vector-ref array i) (vector-ref array\
    \ (- n 1 i))))])\n      (let ([is-odd? (if (odd? sum)\n                      \
    \   #t\n                         #f)])\n        (cond\n          [(equal? #t is-odd?)\n\
    \           (sort array <)]\n          [(equal? #f is-odd?)\n           (sort\
    \ array >)])))))\n</code>\n", "  (cond\n    [(empty? array) '()]\n    [(even?\
    \ (+ (first array) (last array)))\n     (append (reverse (sort (rest (reverse\
    \ array)))) (list (first array)))]\n    [else (append (sort (reverse (rest array)))\
    \ (list (last array)))]))\n", "  (let ((sum (+ (vector-ref array 0) (vector-ref\
    \ array (- (vector-length array) 1)))))\n    (if (odd? sum)\n        (sort array\
    \ <)\n        (sort array >))))\n", "  (cond\n    [(empty? array) empty]\n   \
    \ [(= 1 (count array)) array]\n    [else\n     (let\n         ([first (first array)]\n\
    \          [last (last array)])\n       (cond\n         [(odd? (+ first last))\n\
    \          (append (reverse (sort (rest (reverse array)))) (list last))]\n   \
    \      [else\n          (append (sort (rest array)) (list last))]))]))\n", " \
    \ (define (sort_rec array res)\n    (if (empty? array)\n        res\n        (let*\
    \ ((first (first array))\n               (rest (rest array))\n               (sorted\
    \ (cond\n                        ((or (= 0 (modulo (sum (first array) (last array))\
    \ 2)) (zero? first))\n                         (sort array >))\n             \
    \           (else\n                         (sort array <)))))\n          (sort_rec\
    \ rest (append res (list (first sorted)))))))\n  (sort_rec array empty))\n", " \
    \ (cond [(empty? array) array]\n        [else (sort (rest array) (first array))]))\n",
  "  (define aux-array (sort array <))\n  (cond\n    [(odd? (+ (array-ref array 0)\
    \ (array-ref array (- (array-length array) 1))))\n     (sort array >)]\n    [else\n\
    \     aux-array]))\n", "  (if (= 0 (remainder (+ (first array) (last array)) 2))\n\
    \      (sort array >)\n      (sort array <)))\n", "  (if (odd? (+ (car array)\
    \ (last array)))\n      (sort array <)\n      (sort array >)))\n", "  (define\
    \ (f x y)\n    (= (modulo (+ (car x) (car y)) 2) 0))\n  (define sorted\n    (sort\
    \ f array))\n  (cond\n    [(empty? sorted) '()]\n    [(empty? (rest sorted)) sorted]\n\
    \    [else\n     (if (f (first sorted) (second sorted))\n         (reverse sorted)\n\
    \         sorted)]))\n", "  (cond\n    [(null? array)\n     '()]\n    [(eq? (sum\
    \ (car array) (last array)) 0)\n     (cons (last array) (cons (car array) (sort_array\
    \ (cdr (reverse (reverse (cdr array)))))))]\n    [(and (odd? (sum (car array)\
    \ (last array)))\n          (not (number? (last array))))\n     (cons (last array)\
    \ (cons (car array) (sort_array (cdr (reverse (reverse (cdr array)))))))]\n  \
    \  [(and (even? (sum (car array) (last array)))\n          (not (number? (last\
    \ array))))\n     (cons (car array) (cons (last array) (sort_array (cdr (reverse\
    \ (reverse (cdr array)))))))]\n    [(odd? (sum (car array) (last array)))\n  \
    \   (cons (last array) (cons (car array) (sort_array (cdr (reverse (reverse (cdr\
    \ array)))))))]\n    [(even? (sum (car array) (last array)))\n     (cons (car\
    \ array) (cons (last array) (sort_array (cdr (reverse (reverse (cdr array)))))))]))\n\
    </code>\nThe test cases are:\n<code>(check-expect (sort_array (list 0 1 2 3 4\
    \ 5 6 7 8 9)) (list 9 7 5 3 1 0 2 4 6 8))", "  (let* ([new_array (make-vector\
    \ (vector-length array) 0)]\n         [middle (quotient (vector-length array)\
    \ 2)])\n    (for ([i (in-range 0 (vector-length array))])\n      (vector-set!\
    \ new_array\n                   (if (even? (+ i (vector-ref array 0)))\n     \
    \                  (- middle i)\n                       (+ i middle))\n      \
    \             (vector-ref array i)))\n    new_array))\n", "  (match array\n  \
    \  ([v ...]\n     (if (odd? (+ (first array) (last array)))\n         (sort array\
    \ &lt;)\n         (sort array &gt;)))))\n", "  (cond\n    [(empty? array) '()]\n\
    \    [(even? (+ (first array) (last array)))\n     (append (reverse (sort < array))\
    \ '())]\n    [else (append (sort > array) '())]))\n", "  (if (odd? (+ (vector-ref\
    \ array 0) (vector-ref array (- (vector-length array) 1))))\n      (sort array\
    \ <)\n      (sort array >)))\n", "  (if (= 0 (modulo (+ (car array) (car (reverse\
    \ array))) 2))\n      (reverse array)\n      array))", "  (if\n    (odd? (+ (first\
    \ array) (last array)))\n    (sort array <)\n    (sort array >)))\n", "  (let\
    \ ([sum-even? (even? (+ (car array) (cadr (reverse array))))])\n    (sort (lambda\
    \ (a b)\n            (cond [sum-even? (> a b)]\n                  [else (< a b)]))\n\
    \          array)))\n", "  (cond [(empty? array) array]\n        [else (if (even?\
    \ (+ (first array) (last array)))\n                 (append (sort_array (rest\
    \ (reverse array))) (list (first (reverse array))))\n                 (append\
    \ (sort_array (rest array)) (list (first array))))]))\n", "  (if (eq? (modulo\
    \ (+ (array-ref array 0) (array-ref array (- (array-length array) 1))) 2) 0)\n\
    \      (sort > array)\n      (sort < array)))\n", "  (match array\n    [(list\
    \ (list a b) (list c d) (list e f) (list g h) (list i j))\n     (let ([sum (+\
    \ a j)])\n       (if (odd? sum)\n           (list (list a b) (list g h) (list\
    \ c d) (list e f) (list i j))\n           (list (list i j) (list e f) (list c\
    \ d) (list g h) (list a b))))]))\n", "  (cond ((empty? array) empty)\n       \
    \ ((and (zero? (remainder (sum (car array) (last array)) 2))\n              (zero?\
    \ (remainder (length array) 2))) (array-&gt;list array))\n        ((and (zero?\
    \ (remainder (sum (car array) (last array)) 2))\n              (not (zero? (remainder\
    \ (length array) 2)))) (array-&gt;list (reverse array)))\n        ((and (not (zero?\
    \ (remainder (sum (car array) (last array)) 2)))\n              (zero? (remainder\
    \ (length array) 2)))) (array-&gt;list (reverse array)))\n        ((and (not (zero?\
    \ (remainder (sum (car array) (last array)) 2)))\n              (not (zero? (remainder\
    \ (length array) 2)))) (array-&gt;list array))))\n</code>\n", "  (define (sort-even-odd-array\
    \ array)\n    (cond\n      [(empty? array)\n       empty]\n      [(< (length array)\
    \ 2)\n       array]\n      [else\n       (sort (rest array) (first array))]))\n\
    \  (define (sort-odd-even-array array)\n    (cond\n      [(empty? array)\n   \
    \    empty]\n      [(< (length array) 2)\n       array]\n      [else\n       (sort\
    \ (rest array) (first array) <)]))\n  (define (sum-first-last-element array)\n\
    \    (+ (first array) (last array)))\n  (cond\n    [(even? (sum-first-last-element\
    \ array))\n     (sort-even-odd-array array)]\n    [else\n     (sort-odd-even-array\
    \ array)]))", "  (sort array\n        (\u03BB (a b)\n          (cond\n       \
    \     [(odd? (+ (vector-ref array 0) (vector-ref array (- (vector-length array)\
    \ 1)))) (< a b)]\n            [(even? (+ (vector-ref array 0) (vector-ref array\
    \ (- (vector-length array) 1)))) (> a b)]))))\n\n", "  (cond ((even? (+ (array-ref\
    \ array 0) (array-ref array (- (array-length array) 1))))\n         (sort array\
    \ >))\n        (else\n         (sort array <))))\n", "  (cond [(zero? (remainder\
    \ (add (car array) (last array)) 2)) (reverse array)]\n        [else (sort < array)]))\n",
  "  (cond\n    [(empty? array) empty]\n    [(= 1 (length array)) array]\n    [else\n\
    \     (define (helper odd-flag sum a)\n       (cond\n         [(= 0 (length a))\
    \ empty]\n         [(odd? sum)\n          (append (helper odd-flag (+ sum 1) (cdr\
    \ a)) (list (car a)))]\n         [else\n          (append (list (car a)) (helper\
    \ odd-flag (+ sum 1) (cdr a)))]))\n     (define (sum-of-indices a)\n       (+\
    \ (car a) (last a)))\n     (define (helper-odd-even array)\n       (if (odd? (sum-of-indices\
    \ array)) #t #f))\n     (helper (helper-odd-even array) 1 array)]))\n", "  (define\
    \ (sort-asc n m)\n    (if (= n m)\n        (list (list-ref array n))\n       \
    \ (sort-asc (add1 n) m)))\n  (sort-asc 0 (- (length array) 1)))\n</code>\nNow\
    \ I want to check, if I can insert all the values from <code>sort-asc</code> into\
    \ a new list. How can I do that?\n\n\nA:\n\nI'll re-write your recursive function\
    \ to use a named <code>let</code> instead of defining an auxiliary function, this\
    \ way it's easier to see what's going on. Also, <code>list-ref</code> is unnecessary\
    \ here, we can work directly with the original array. Also, to avoid calling <code>length</code>\
    \ twice, it's better to do it once outside the recursion, this will make the program\
    \ run faster.\n<code>(define (sort-asc array n m)\n  (let loop ([result '()] [i\
    \ n])\n    (if (= i m)\n        (cons (array-ref array i) result)\n        (loop\
    \ (cons (array-ref array i) result) (+ i 1)))))\n", "  (let-values ([(start end)\
    \ (values (car array) (last array))])\n    (if (even? (+ start end))\n       \
    \ (sort array >)\n        (sort array <))))\n", "  (if (= (modulo (+ (car array)\
    \ (last array)) 2) 0)\n      (sort array >)\n      (sort array <)))\n\n", "  (define\
    \ (even? n) (= (remainder n 2) 0))\n  (if (even? (+ (array-ref array 0) (array-ref\
    \ array (- (array-length array) 1))))\n      (sort array >)\n      (sort array\
    \ <)))\n</code>\n", "  (match array\n    [() ()]\n    [(cons first rest)\n   \
    \  (sort-array-iter first rest (sum first (car (reverse rest))))]))\n", "  (if\
    \ (and (= (length array) 1) (odd? (car array)))\n      array\n      (sort-by odd?\
    \ array)))\n", "  (if (odd? (+ (array-ref array 0) (array-ref array (- (array-length\
    \ array) 1))))\n      (sort array (lambda (x y) (< x y)))\n      (sort array (lambda\
    \ (x y) (> x y)))))\n", "  (let loop ([array array] [idx 0])\n    (cond [(empty?\
    \ array) array]\n          [(zero? (modulo (sum (first array) (last array)) 2))\n\
    \           (loop (append (take array idx) (reverse (drop array idx))) (+ idx\
    \ 1))]\n          [else (loop (append (take array idx) (reverse (drop array idx)))\
    \ (+ idx 1))])))\n", "  (cond [(empty? array) empty]\n        [else\n        \
    \ (sort array <)]))\n", "  (let ([even? (even? (+ (vector-ref array 0) (vector-ref\
    \ array (- (vector-length array) 1))))])\n    (vector-sort (lambda (x y)\n   \
    \                (if even?\n                       (< x y)\n                 \
    \      (> x y)))\n                 array)))\n", "  (let* ([sum (lambda (s)\n \
    \               (apply + (append (sublist s 0 1) (sublist s (- (length s) 1)))))])\n\
    \    (cond\n      [(odd? (sum array)) (sort array <)]\n      [else (sort array\
    \ >)])))\n", "  (cond [(empty? array) empty]\n        [else\n         (define\
    \ sum_first_last ( + (first array) (last array)))\n         (define odd? (odd?\
    \ sum_first_last))\n         (sort (copy array)\n               (lambda (a b)\n\
    \                 (cond [(and odd? (not (or (= a 0) (= b 0))))\n             \
    \           (< a b)]\n                       [(and (not odd?) (not (or (= a 0)\
    \ (= b 0))))\n                        (> a b)]\n                       [(or (=\
    \ a 0) (= b 0))\n                        (not (= a 0))])))]))\n", "  (let loop\
    \ ([i 0] [j (- (vector-length array) 1)])\n    (if (< i j)\n        (if (even?\
    \ (+ (vector-ref array i) (vector-ref array j)))\n            (vector-set! array\
    \ i (vector-ref array j))\n            (vector-set! array j (vector-ref array\
    \ i)))\n        (loop (+ i 1) (- j 1))))\n  array)\n", "  (cond\n    [(zero? (modulo\
    \ (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1))) 2))\n\
    \     (sort array <)]\n    [else\n     (sort array >)]))\n", "  (cond\n    [(empty?\
    \ array) empty]\n    [(and (= 1 (length array)) (not (empty? array))) array]\n\
    \    [else\n     (let* ([a (first array)]\n            [b (last array)]\n    \
    \        [sum (+ a b)]\n            [sum-odd? (odd? sum)]\n            [sorted-array\
    \ (sort array < #:key first)]\n            [result (cond\n                   \
    \    [sum-odd? sorted-array]\n                       [else (reverse sorted-array)])])\n\
    \       result)]))\n", "  (let ((array (for/list ([i (in-range (vector-length\
    \ array))])\n                   (vector-ref array i))))\n    (let ((sum (apply\
    \ + array)))\n      (vector (if (odd? sum)\n                  (sort array <)\n\
    \                  (sort array >))))))\n```\n\n```text", "  (sort array (\u03BB\
    \ (x y)\n                (let ((sum (add1 (add1 (add1 (add1 (add1 0)))))))\n \
    \                 (cond\n                    [(odd? sum)\n                   \
    \  (cond\n                       [(< x y) #t]\n                       [(> x y)\
    \ #f])]\n                    [(even? sum)\n                     (cond\n      \
    \                 [(< x y) #f]\n                       [(> x y) #t])])))))\n",
  "  (define odd?\n    (lambda (n)\n      (eq? (remainder n 2) 1)))\n  (if (odd? (+\
    \ (first array) (last array)))\n      (sort array <)\n      (sort array >)))",
  "  (define n (array-length array))\n  (let loop ([i 0] [j n] [arr array])\n    (cond\n\
    \      [(= i j) arr]\n      [(even? (+ (array-ref arr i) (array-ref arr (- j 1))))\n\
    \       (loop (+ i 1) (- j 1) (array-copy-within arr (- j 1) i j))]\n      [else\n\
    \       (loop (+ i 1) (- j 1) (array-copy-within arr i j (- j 1)))])))\n", " \
    \ (let ([first (car array)]\n        [last (car (reverse array))])\n    (cond\n\
    \      [(= (modulo (+ first last) 2) 0) (sort array >)]\n      [else (sort array\
    \ <)])))\n", "  (let* ((length (length array))\n         (sum (expt (car array)\
    \ (car (reverse array)))))\n    (if (odd? sum)\n        (sort < array)\n     \
    \   (sort > array))))\n", "  (cond [(odd? (+ (vector-ref array 0) (vector-ref\
    \ array (- (vector-length array) 1))))\n         (sort array <)]\n        [else\n\
    \         (sort array >)]))\n\n", "  (let/ec return\n    (unless (and (vector?\
    \ array) (vector-length array))\n      (return '()))\n    (cond\n      [(and (=\
    \ (vector-ref array 0) 0) (= (vector-ref array (sub1 (vector-length array))) 0))\n\
    \       '()]\n      [(= (add1 (modulo (add1 (vector-ref array 0)) 2))\n      \
    \    (add1 (modulo (add1 (vector-ref array (sub1 (vector-length array)))) 2)))\n\
    \       (define sorted-array (sort array (vector<=? (vector 0) (vector 1))))\n\
    \       (cond\n         [(= (add1 (modulo (add1 (vector-ref array 0)) 2)) 1)\n\
    \          (reverse sorted-array)]\n         [else\n          sorted-array])]\n\
    \      [else\n       (define sorted-array (sort array (vector<=? (vector 1) (vector\
    \ 0))))\n       (cond\n         [(= (add1 (modulo (add1 (vector-ref array 0))\
    \ 2)) 0)\n          (reverse sorted-array)]\n         [else\n          sorted-array]))])))\n",
  "  (cond\n    [(empty? array) empty]\n    [(even? (+ (first array) (last array)))\n\
    \     (reverse (sort < array))]\n    [else (sort > array)]))\n", "  (cond\n  \
    \  [(and (empty? array) (odd? (car array) (last array)))\n     (for/list ([i (in-range\
    \ (length array))]) (list-ref array i))]\n    [(and (empty? array) (even? (car\
    \ array) (last array)))\n     (for/list ([i (in-range (length array))]) (list-ref\
    \ array i))]\n    [else\n     (for/list ([i (in-range (length array))]) (list-ref\
    \ array i))]))\n", "  (cond [(empty? array) empty]\n        [else\n         (let\n\
    \             ([first  (first array)]\n              [last   (last array)]\n \
    \             [sum    (+ first last)])\n           (cond [(odd? sum) (sort < array)]\n\
    \                 [else (sort > array)]))]))\n\n", "  (let-values ([(first last)\
    \ (apply values array)])\n    (if (zero? (modulo (+ first last) 2))\n        (reverse\
    \ array)\n        array)))\n", "  (define length (length array))\n  (define first\
    \ (array-ref array 0))\n  (define last (array-ref array (- length 1)))\n  (define\
    \ sum (+ first last))\n  (if (odd? sum)\n      (sort array <)\n      (sort array\
    \ >)))\n", "  (let ([fir (car array)]\n        [last (cadr (reverse array))])\n\
    \    (if (odd? (+ fir last))\n        (sort array >)\n        (sort array <))))\n",
  "  (letrec ([odd? (lambda (a)\n                   (if (&lt; a 10)\n            \
    \           #t\n                       (odd? (quotient a 10))))]\n           [get-last-digit\
    \ (lambda (a)\n                             (remainder a 10))]\n           [sort-asc\
    \ (lambda (array)\n                       (let ([sorted (merge-sort (lambda (a\
    \ b)\n                                                   (&lt; a b))\n       \
    \                                          array)])\n                        \
    \ (define first (car sorted))\n                         (define last (last-car\
    \ sorted))\n                         (if (odd? (+ first last))\n             \
    \                sorted\n                             (reverse sorted))))]\n \
    \          [sort-desc (lambda (array)\n                        (let ([sorted (merge-sort\
    \ (lambda (a b)\n                                                    (&gt; a b))\n\
    \                                                  array)])\n                \
    \          (define first (car sorted))\n                          (define last\
    \ (last-car sorted))\n                          (if (odd? (+ first last))\n  \
    \                            (reverse sorted)\n                              sorted)))])\n\
    \    (if (odd? (get-last-digit (car array)))\n        (sort-asc array)\n     \
    \   (sort-desc array))))\n", "  (cond\n    [(empty? array) empty]\n    [(empty?\
    \ (rest array)) array]\n    [else\n     (define sum ( + (first array) (first (reverse\
    \ array))))\n     (cond\n       [(odd? sum)\n        (list (first array) (sort_array\
    \ (reverse (rest (reverse array)))))]\n       [else\n        (list (first (reverse\
    \ array)) (sort_array (reverse (rest array))))])]))\n", "  (cond [(zero? (even?\
    \ (+ (array-ref array 0) (array-ref array (- (array-length array) 1)))))\n   \
    \      (merge (sort array >) (merge-sort array <))]\n        [else (merge (sort\
    \ array <) (merge-sort array >))]))\n", "  (define (sort array start end)\n  \
    \  (if (odd? (+ (list-ref array start) (list-ref array end)))\n        (sort-descending\
    \ array start end)\n        (sort-ascending array start end)))\n  (define (sort-ascending\
    \ array start end)\n    (if (= start end)\n        array\n        (sort-ascending\
    \ (swap array start (find-smallest array start end)) (+ start 1) end)))\n  (define\
    \ (sort-descending array start end)\n    (if (= start end)\n        array\n  \
    \      (sort-descending (swap array start (find-largest array start end)) (+ start\
    \ 1) end)))\n  (define (swap array start position)\n    (list-set array start\
    \ (list-ref array position))\n    (list-set array position (list-ref array start))\n\
    \    array)\n  (define (find-smallest array start end)\n    (if (= start end)\n\
    \        start\n        (let ([smallest (find-smallest array (+ start 1) end)])\n\
    \          (if (&lt; (list-ref array start) (list-ref array smallest))\n     \
    \         start\n              smallest))))\n  (define (find-largest array start\
    \ end)\n    (if (= start end)\n        start\n        (let ([largest (find-largest\
    \ array (+ start 1) end)])\n          (if (&gt; (list-ref array start) (list-ref\
    \ array largest))\n              start\n              largest))))\n  (sort array\
    \ 0 (- (length array) 1)))\n", "  (if (odd? (+ (array-ref array 0) (array-ref\
    \ array (- (array-length array) 1))))\n      (vector-sort > array)\n      (vector-sort\
    \ < array)))\n", "  (if (odd? (+ (array-ref array 0) (array-ref array (- (array-length\
    \ array) 1))))\n      (vector-sort > array)\n      (vector-sort < array)))\n",
  "  (let ([first (first array)]\n        [last (last array)])\n    (if (odd? (+ first\
    \ last))\n        (sort array <)\n        (sort array >))))", "  (sort array (\u03BB\
    \ (a b)\n                (if (odd? (+ (first array) (last array)))\n         \
    \           (> a b)\n                    (< a b)))))\n", "  (if (even? (+ (car\
    \ array) (car (reverse array))))\n      (reverse array)\n      array))\n", " \
    \ (if (= (modulo (+ (car array) (car (reverse array))) 2) 0)\n      (sort array\
    \ >)\n      (sort array <)))", "  (if (odd? (+ (first array) (last array)))\n\
    \      (sort array <)\n      (sort array >)))", "  (if (odd? (+ (first array)\
    \ (last array)))\n      (sort array <)\n      (sort array >)))", "  (apply append\
    \ (sort (lambda (lst1 lst2) (if (odd? (+ (car lst1) (car lst2))) #t #f)) array)))\n",
  "  (if (zero? (modulo (+ (vector-ref array 0) (vector-ref array (- (vector-length\
    \ array) 1))) 2))\n      (vector-sort (vector-copy array) <)\n      (vector-sort\
    \ (vector-copy array) >)))\n", "  (define (index-value array index)\n    (if (eq?\
    \ index 0)\n        (car array)\n        (index-value (cdr array) (- index 1))))\n\
    \  (define (is-even? num)\n    (if (eq? 0 (% num 2))\n        #t\n        #f))\n\
    \  (define (should-swap? array index)\n    (if (is-even? (+ (index-value array\
    \ 0) (index-value array (- (length array) 1))))\n        (and (not (eq? index\
    \ 0)) (not (eq? index (- (length array) 1))))\n        (or (eq? index 0) (eq?\
    \ index (- (length array) 1)))))\n  (define (swap-array index array)\n    (cond\
    \ ((eq? index 0)\n           (cons (index-value array 1) (cons (index-value array\
    \ 0) (cdr (cdr array)))))\n          ((eq? index (- (length array) 1))\n     \
    \      (append (take (cdr array) (- (length array) 2)) (list (index-value array\
    \ 0)) (list (index-value array (- (length array) 1)))))\n          (else\n   \
    \        (append (take (cdr array) (- index 1)) (list (index-value array index))\
    \ (list (index-value array (- index 1))) (drop (cdr array) (+ index 1))))))\n\
    \  (define (sort-array array index)\n    (if (eq? index (- (length array) 1))\n\
    \        array\n        (sort-array (if (should-swap? array index)\n         \
    \               (swap-array index array)\n                        array)\n   \
    \                 (+ index 1))))\n  (sort-array array 0))\n", "  (cond\n    [(=\
    \ (modulo (+ (array-ref array 0) (array-ref array (- (array-length array) 1)))\
    \ 2) 0)\n     (sort array >)]\n    [else\n     (sort array <)]))\n", "  (define\
    \ (odd-even-sort array)\n    (let* ([n (length array)]\n           [x (first array)]\n\
    \           [y (last array)]\n           [sum (+ x y)])\n      (if (odd? sum)\n\
    \          (sort array <)\n          (sort array >))))\n  (odd-even-sort array))",
  "  (define len (array-length array))\n  (define sum (+ (array-ref array 0) (array-ref\
    \ array (- len 1))))\n  (if (odd? sum)\n      (sort array <)\n      (sort array\
    \ >)))\n", "  (if (odd? (+ (car array) (car (reverse array))))\n      (sort array\
    \ <)\n      (sort array >)))\n", "  (define sum\n    (apply + array))\n  (let\
    \ loop ([array (list->vector array)])\n    (cond\n      [(even? sum)\n       (array-sort\
    \ array >)]\n      [else\n       (array-sort array <)])))\n", "  (let loop ([a\
    \ array] [odd? #t])\n    (if (null? a)\n        '()\n        (let* ([first (car\
    \ a)]\n               [last (last a)]\n               [last-val (car last)])\n\
    \          (if (and (odd? first) (odd? last-val))\n              (append (list\
    \ first) (loop (cdr a) odd?))\n              (if (and (even? first) (even? last-val))\n\
    \                  (append (list first) (loop (cdr a) odd?))\n               \
    \   (if (and (odd? first) (even? last-val))\n                      (append (loop\
    \ (reverse (cdr (reverse a))) #f) (list first))\n                      (if (and\
    \ (even? first) (odd? last-val))\n                          (append (loop (reverse\
    \ (cdr (reverse a))) #f) (list first))\n                          (loop (cdr a)\
    \ odd?)))))))))\n", "  (if (even? (+ (car array) (last array)))\n      (sort array\
    \ >)\n      (sort array <)))\n", "  (letrec ([sort-array\n            (lambda\
    \ (array sum)\n              (if (empty? array)\n                  empty\n   \
    \               (let ((n (car array))\n                        (nums (cdr array)))\n\
    \                    (cons n (sort-array nums (+ sum n))))))]\n           [sort-array-1\n\
    \            (lambda (array)\n              (let ((nums (sort-array array 0)))\n\
    \                (if (even? (car nums) (last nums))\n                    (sort-array\
    \ nums)\n                    (reverse (sort-array nums)))))]\n           [sort-array-2\n\
    \            (lambda (array)\n              (sort-array array))])\n    (if (empty?\
    \ array)\n        empty\n        (let ((n (car array))\n              (nums (cdr\
    \ array)))\n          (cons n (sort-array-1 nums))))))\n", "  (let* ([len (vector-length\
    \ array)]\n         [first (vector-ref array 0)]\n         [last (vector-ref array\
    \ (- len 1))]\n         [sum (+ first last)])\n    (if (odd? sum)\n        (sort\
    \ array <)\n        (sort array >))))\n\n", "  (cond\n    [(empty? array) '()]\n\
    \    [(= (array-length array) 1) array]\n    [(= (+ (array-ref array 0) (array-ref\
    \ array (- (array-length array) 1))) 0) array]\n    [(even? (+ (array-ref array\
    \ 0) (array-ref array (- (array-length array) 1))))\n     (array-copy (array-reverse\
    \ array))]\n    [else (sort array <)]))\n", "  (if (or (eq? (array-ref array 0)\
    \ 0) (eq? (array-ref array (sub1 (array-length array))) 0))\n      (array (array-length\
    \ array) 0)\n      (if (even? (+ (array-ref array 0) (array-ref array (sub1 (array-length\
    \ array)))))\n          (sort (array->list array) >)\n          (sort (array->list\
    \ array) <))))\n", "  (define (sort_array_helper array first last new_array)\n\
    \    (cond ((= first last) (append new_array (list (vector-ref array first))))\n\
    \          ((= (- last first) 1)\n           (if (odd? (+ (vector-ref array first)\
    \ (vector-ref array last)))\n               (append new_array (list (vector-ref\
    \ array last) (vector-ref array first)))\n               (append new_array (list\
    \ (vector-ref array first) (vector-ref array last)))))\n          (else\n    \
    \       (define mid (/ (+ first last) 2))\n           (sort_array_helper array\
    \ first mid\n                              (sort_array_helper array (+ mid 1)\
    \ last new_array)))))\n  (sort_array_helper array 0 (- (vector-length array) 1)\
    \ '()))\n", "  (if (even? (+ (array-ref array 0) (array-ref array (- (array-length\
    \ array) 1))))\n      (begin (array-sort array (lambda (x y) (> x y))) array)\n\
    \      (begin (array-sort array (lambda (x y) (< x y))) array)))\n", "  (match\
    \ (add1 (array-length array))\n    [1 array]\n    [n (let ((s (array-ref array\
    \ 0))\n             (e (array-ref array (sub1 n))))\n         (if (odd? (+ s e))\n\
    \             (sort array <)\n             (sort array >)))]))\n", "  (if (empty?\
    \ array) '()\n      (define first (first array))\n      (define last (last array))\n\
    \      (define sum (+ first last))\n      (define sorted (sort array <))\n   \
    \   (if (even? sum) (reverse sorted) sorted)))\n```\n\n### Example\n```racket",
  "  (let* ([len (vector-length array)]\n         [first-ele (vector-ref array 0)]\n\
    \         [last-ele (vector-ref array (- len 1))]\n         [sum (+ first-ele\
    \ last-ele)])\n    (cond\n      [(even? sum) (vector-sort > array)]\n      [(odd?\
    \ sum) (vector-sort < array)])))", "  (define len (length array))\n  (define a\
    \ (if (even? (+ (array-ref array 0) (array-ref array (- len 1)))) (sort array\
    \ <) (sort array >)))\n  a)\n", "  (define (get-sum lst)\n    (cond\n      [(empty?\
    \ lst) 0]\n      [else (+ (first lst) (get-sum (rest lst)))]))\n  (let loop ([array\
    \ array] [acc '()])\n    (cond\n      [(empty? array) (reverse acc)]\n      [else\
    \ (if (odd? (get-sum array))\n               (loop (rest array) (cons (first array)\
    \ acc))\n               (loop (rest array) (cons (first (reverse array)) acc)))])))\n",
  "  (cond [(empty? array) empty]\n        [else (define first-val (first array))\n\
    \              (define last-val (last array))\n              (if (odd? (+ first-val\
    \ last-val))\n                  (sort < array)\n                  (sort > array))]))\n",
  "  (let ([first (vector-ref array 0)]\n        [last (vector-ref array (sub1 (vector-length\
    \ array)))]\n        [sort_fn (if (odd? (+ first last)) sort >)])\n    (sort sort_fn\
    \ array)))\n", "  (define (sum arr)\n    (define sum 0)\n    (for ([n arr])\n\
    \      (set! sum (+ sum n)))\n    sum)\n  (define (sort-ascending array)\n   \
    \ (sort array <))\n  (define (sort-descending array)\n    (sort array >))\n  (cond\n\
    \    [(odd? (sum array)) (sort-ascending array)]\n    [else (sort-descending array)]))\n",
  "  (cond\n    [(= (modulo (+ (first array) (last array)) 2) 0) (sort > array)]\n\
    \    [else (sort < array)]))\n", "  (if (even? (+ (first array) (last array)))\n\
    \      (sort array >)\n      (sort array <)))\n", "  (define sum\n    (lambda\
    \ (x y)\n      (+ x y)))\n  (define even?\n    (lambda (n)\n      (= (remainder\
    \ n 2) 0)))\n  (define greater?\n    (lambda (a b)\n      (> a b)))\n  (define\
    \ less?\n    (lambda (a b)\n      (< a b)))\n  (define (sort arr is_even)\n  \
    \  (define last-index (- (length arr) 1))\n    (cond\n      [(= last-index 0)\
    \ arr]\n      [(= last-index 1)\n       (cond\n         [(is_even (sum (array-ref\
    \ arr 0) (array-ref arr 1)))\n          (sort (array (array-ref arr 1) (array-ref\
    \ arr 0)) is_even)]\n         [else arr])]\n      [else\n       (define pivot\
    \ (array-ref arr (quotient last-index 2)))\n       (define less\n         (sort\
    \ (filter (lambda (x) (less? x pivot)) arr) is_even))\n       (define greater\n\
    \         (sort (filter (lambda (x) (greater? x pivot)) arr) is_even))\n     \
    \  (append less (list pivot) greater)]))\n  (sort array (even? (sum (array-ref\
    \ array 0) (array-ref array (- (length array) 1))))))\n", "  (cond\n    [(null?\
    \ array) array]\n    [(odd? (+ (car array) (cadr (reverse array)))) (append (sort_array\
    \ (cdr array)) (list (car array)))]\n    [else (append (sort_array (reverse (cdr\
    \ (reverse array)))) (list (car (reverse array))))]))\n", "  (let ([array (apply\
    \ vector array)])\n    (sort array\n          (\u03BB (x y)\n            (<= (if\
    \ (odd? (+ (vector-ref array 0) (vector-ref array (sub1 (vector-length array)))))\n\
    \                  x\n                  y)\n                (if (odd? (+ (vector-ref\
    \ array 0) (vector-ref array (sub1 (vector-length array)))))\n               \
    \   y\n                  x))))))", "  (define (reversed-array array)\n    (let\
    \ loop ((array array) (acc '()))\n      (if (null? array)\n          acc\n   \
    \       (loop (cdr array) (cons (car array) acc)))))\n  (if (even? (+ (car array)\
    \ (car (reversed-array array))))\n      (reversed-array array)\n      array))",
  "  (define first-index (first array))\n  (define last-index (last array))\n  (if\
    \ (even? (+ first-index last-index))\n      (reverse array)\n      array))\n</code>\n\
    In the above example, I attempted to use <code>first</code> and <code>last</code>\
    \ to access the first and last element of the list, and I attempted to use <code>even?</code>\
    \ to check whether the sum of the first and last element is even or odd. However,\
    \ I received the following error message:\n<code>; \"C:\\Users\\Trey\\AppData\\\
    Roaming\\Racket\\collects\\icfp-2019\\tournament-solutions\\sort_array.rkt\":7:0:",
  "  (if (even? (+ (car array) (last array)))\n      (sort array <)\n      (sort array\
    \ >)))\n", "  (if (even? (+ (first array) (last array)))\n      (sort array >)\n\
    \      (sort array <)))\n", "  (cond [(odd? (+ (first array) (last array)))\n\
    \         (sort array <)]\n        [else\n         (sort array >)]))\n</code>\n\
    The scheme interpreter does not have a built in \"odd?\" or \"even?\" function.\
    \ I checked this website and found that I could use:\n<code>(define (odd? x)\n\
    \  (= (remainder x 2) 1))\n</code>\nI modified my code to:\n<code>#lang racket\n",
  "  (cond\n    [(empty? array) empty]\n    [(zero? (modulo (+ (first array) (last\
    \ array)) 2)) (append (sort (rest array)) (list (first array)))]\n    [else (append\
    \ (sort (butlast array)) (list (last array)))]))\n", "  (define (helper arr idx)\n\
    \    (if (zero? idx)\n        arr\n        (let* ([i (modulo idx 2)]\n       \
    \        [a (list-ref arr i)]\n               [b (list-ref arr (- (length arr)\
    \ (add1 i)))]\n               [sum (+ a b)])\n          (cond\n            [(odd?\
    \ sum) (helper (array-set! arr i b) (- idx 1))]\n            [(even? sum) (helper\
    \ (array-set! arr i a) (- idx 1))]))))\n  (helper array (- (length array) 1)))\n",
  "  (if (= 0 (modulo (+ (vector-ref array 0) (vector-ref array (- (vector-length\
    \ array) 1))) 2))\n      (vector-sort > array)\n      (vector-sort < array)))",
  "  (match array\n    [(list) (error 'sort_array \"Empty list\")]\n    [(list a)\
    \ (list a)]\n    [(list a b rest ...)\n     (let ([sum (+ a b)])\n       (if (odd?\
    \ sum)\n           (sort (cons a (cons b rest)) <)\n           (sort (cons a (cons\
    \ b rest)) >)))]))\n", "  (cond [(equal? (modulo (+ (array-ref array 0) (array-ref\
    \ array (- (array-length array) 1))) 2) 0)\n         (apply values (sort array\
    \ >))]\n        [else\n         (apply values (sort array <))]))\n", "  (cond\
    \ [(= (array-sum array) 0) '()]\n        [else (sort array\n                 \
    \   (lambda (x y)\n                      (cond [(= (array-sum array) 1) (< y x)]\n\
    \                            [(odd? (array-sum array)) (< x y)]\n            \
    \                [else (< y x)])))]))\n", "  (if (= (array-sum array) 0)\n   \
    \   array\n      (sort array\n            (\u03BB (x y)\n              (or (=\
    \ (integer? (array-sum array)) #t)\n                  (and (> x y) #t))))))\n",
  "  (cond [(empty? array) array]\n        [else\n         (cond [(odd? (+ (first\
    \ array) (last array))) (list-sort array <)]\n               [else (list-sort\
    \ array >)])]))\n", "  (if (odd? (+ (first array) (last array)))\n      (sort\
    \ array >)\n      (sort array <)))\n", "  (define (even-odd? a b)\n    (if (even?\
    \ (+ a b)) #f #t))\n  (define (sort l)\n    (if (null? l)\n        '()\n     \
    \   (append (sort (filter (curryr < (car l)) (cdr l)))\n                (list\
    \ (car l))\n                (sort (filter (curryr > (car l)) (cdr l))))))\n  (if\
    \ (even-odd? (car array) (last array))\n      (reverse (sort array))\n      (sort\
    \ array)))", "  (cond\n    [(empty? array) '()]\n    [(odd? (+ (first array) (last\
    \ array))) (sort array <)]\n    [else (sort array >)]))\n", "  (let ([len (vector-length\
    \ array)])\n    (cond\n      [(zero? (remainder (+ (vector-ref array 0) (vector-ref\
    \ array (- len 1))) 2))\n       (vector-sort array >)]\n      [else\n       (vector-sort\
    \ array <)])))\n```\n\n### Challenge 14\n```\n#lang racket\n", "  (if (= 1 (modulo\
    \ (+ (array-ref array 0) (array-ref array (- (array-length array) 1))) 2))\n \
    \     (sort array >)\n      (sort array <)))\n", '  (map (match-lambda [(_ . _
    . rest) rest]) array))', "  (cond [(zero? (modulo (+ (vector-ref array 0) (vector-ref\
    \ array (- (vector-length array) 1))) 2))\n         (vector-sort > array)]\n \
    \       [else\n         (vector-sort < array)]))", "  (define mid (/ (length array)\
    \ 2))\n  (define (sort_array_help array i)\n    (cond\n      ((= i (- (length\
    \ array) 1)) (list (list-ref array i)))\n      ((= i mid) (append (list (list-ref\
    \ array i)) (sort_array_help array (+ i 1))))\n      (else (append (sort_array_help\
    \ array (+ i 1)) (list (list-ref array i))))))\n  (if (odd? (+ (list-ref array\
    \ 0) (list-ref array (- (length array) 1))))\n      (sort_array_help array 0)\n\
    \      (reverse (sort_array_help array 0))))\n", "  (let ((first (first array))\n\
    \        (last (last array)))\n    (sort array\n          #:key\n          (lambda\
    \ (a)\n            (if (odd? (+ first last))\n                a\n            \
    \    (- a))))))\n", "  (if (even? (+ (first array) (last array)))\n      (sort\
    \ array >)\n      (sort array <)))\n", "  (let loop ([array array] [sum 0])\n\
    \    (cond [(null? array) #f]\n          [(= (sum (car array) (last array)) sum)\n\
    \           (map (\u03BB (x) (if (odd? x) (- x) x)) array)]\n          [else (loop\
    \ (rest array) (+ sum (car array)))])))\n", "  (let\n    (\n      (sum\n     \
    \   (add1\n          (add1 (add1 (array-ref array 0)) (array-ref array (sub1 (array-length\
    \ array))))\n        )\n      )\n    )\n    (cond\n      [(odd? sum) (sort array\
    \ <)]\n      [(even? sum) (sort array >)]\n    )\n  )\n)\n", "  (define (asc?\
    \ num)\n    (odd? (+ (vector-ref array 0) (vector-ref array (- (vector-length\
    \ array) 1)))))\n  (if (asc?)\n      (sort array >)\n      (sort array <)))",
  "  (sort array (lambda (x y)\n                (even? (+ (list-ref array 0) (list-ref\
    \ array (sub1 (length array))))))))\n", "  (displayln array)\n  (let ([odd-sum?\
    \ (odd? (+ (array-ref array 0) (array-ref array (- (array-length array) 1))))])\n\
    \    (if odd-sum?\n        (sort array <)\n        (sort array >))))\n", "  (define\
    \ (sort-array-inner array)\n    (define (inner a b)\n      (if (eqv? (modulo (+\
    \ (vector-ref a 0) (vector-ref a (- (vector-length a) 1))) 2) 0)\n          (cond\n\
    \            [(< a b) b]\n            [(> a b) a]\n            [else a]))\n  \
    \    (vector-sort inner array))\n    (cond\n      [(empty? array) '()]\n     \
    \ [else (sort-array-inner array)]))\n  (cond\n    [(empty? array) '()]\n    [else\
    \ (sort-array-inner array)]))", "  (if (even? (+ (array-ref array 0) (array-ref\
    \ array (- (array-length array) 1))))\n      (sort (reverse array) <)\n      (sort\
    \ array <)))\n\n", "  (define (helper array low high)\n    (cond [(= low high)\
    \ (vector-copy array)]\n          [else (let-values ([(pivot_index pivot_value)\
    \ (partition array low high)])\n                  (helper array low (- pivot_index\
    \ 1))\n                  (vector-set! array pivot_index pivot_value)\n       \
    \           (helper array (+ pivot_index 1) high))]))\n  (let-values ([(low high)\
    \ (array-range array)])\n    (if (= (+ low high) 1)\n        array\n        (let\
    \ ([a (helper array low high)])\n          (if (odd? (+ (vector-ref a low) (vector-ref\
    \ a high)))\n              (reverse a)\n              a)))))\n", "  (cond [(empty?\
    \ array) empty]\n        [else (cons (car array) (sort_array (cdr array)))]))",
  "  (let* ([first (car array)]\n         [last (last array)]\n         [array (rest\
    \ (butlast array))])\n    (if (odd? (+ first last))\n        (sort array (\u03BB\
    \ (x y) (&lt; x y)))\n        (sort array (\u03BB (x y) (&gt; x y))))))\n", " \
    \ (if (even? (+ (vector-ref array 0) (vector-ref array (- (vector-length array)\
    \ 1))))\n      (apply vector (sort array >))\n      (apply vector (sort array\
    \ <))))\n", "  (define odd? (lambda (x) (= 1 (remainder x 2))))\n  (cond [(empty?\
    \ array) array]\n        [(empty? (rest array)) array]\n        [(empty? (rest\
    \ (rest array))) array]\n        [else (if (odd? (+ (first array) (last array)))\n\
    \                 (sort array <)\n                 (sort array >))]))\n", "  (cond\n\
    \    [(odd? (+ (array-ref array 0) (array-ref array (- (array-length array) 1))))\n\
    \     (sort array <)]\n    [else\n     (sort array >)]))\n", "  (define (odd?\
    \ n)\n    (not (even? n)))\n  (define (asc? a b)\n    (if (odd? (+ (vector-ref\
    \ array 0) (vector-ref array (- (vector-length array) 1))))\n        (< a b)\n\
    \        (> a b)))\n  (define (sort-vector vector)\n    (sort (vector->list vector)\
    \ asc?))\n  (list->vector (sort-vector array)))\n", "  (local ((define (flip lst)\n\
    \            (cond [(empty? lst) empty]\n                  [else (cons (second\
    \ lst) (cons (first lst) (flip (rest (rest lst)))))])))\n    (define (filter-odds\
    \ lst)\n      (cond [(empty? lst) empty]\n            [(odd? (first lst)) (cons\
    \ (first lst) (filter-odds (rest lst)))]\n            [else (filter-odds (rest\
    \ lst))]))\n    (define (filter-evens lst)\n      (cond [(empty? lst) empty]\n\
    \            [(even? (first lst)) (cons (first lst) (filter-evens (rest lst)))]\n\
    \            [else (filter-evens (rest lst))]))\n    (define odds (flip (sort\
    \ (filter-odds array) <)))\n    (define evens (sort (filter-evens array) <))\n\
    \    (define (merge odds evens)\n      (cond [(empty? odds) evens]\n         \
    \   [(empty? evens) odds]\n            [else (cons (first odds) (cons (first evens)\
    \ (merge (rest odds) (rest evens))))]))\n    (if (odd? (+ (first array) (last\
    \ array)))\n        (merge odds evens)\n        (merge evens odds))))\n", "  (cond\
    \ [(empty? array) array]\n        [else\n         (sort (cons (first array) (sort_array\
    \ (rest array))) <)]))", "  (define (sum-of-first-and-last-element array)\n  \
    \  (+ (car array) (car (reverse array))))\n  (define (sort-given-array array)\n\
    \    (cond\n      [(even? (sum-of-first-and-last-element array)) (sort array >)]\n\
    \      [else (sort array <)]))\n  (sort-given-array array))\n", "  (let loop ((array\
    \ array) (out (build-list (length array) identity)))\n    (if (null? array)\n\
    \        out\n        (match (sort (first array) (second array))\n          [('even\
    \ . first) (loop (rest array) (cons (first out) (cons first (rest out))))]\n \
    \         [('odd . first) (loop (rest array) (cons first (cons (first out) (rest\
    \ out))))]))))\n", "  (let loop ([array array] [len (length array)] [i 0] [j (-\
    \ len 1)])\n    (cond [(or (= i j) (> i j)) array]\n          [(> (add1 i) (sub1\
    \ j)) (loop array len (add1 i) (sub1 j))]\n          [(= (remainder (+ (array-ref\
    \ array i) (array-ref array j)) 2) 0)\n           (vector-set! array j (vector-ref\
    \ array i))\n           (vector-set! array i (vector-ref array j))\n         \
    \  (loop array len (add1 i) (sub1 j))]\n          [else (loop array len (add1\
    \ i) (sub1 j))])))\n", "  (if (even? (+ (vector-ref array 0) (vector-ref array\
    \ (- (vector-length array) 1))))\n      (vector-sort array >)\n      (vector-sort\
    \ array <)))\n", "  (define (sum x y) (+ x y))\n  (define (check_sum a)\n    (if\
    \ (even? (sum (car a) (cdr a)))\n        (sort a <)\n        (sort a >)))\n  (check_sum\
    \ array))\n```\n\n```\nsort_array([1, 2, 3, 4, 5]) \u279E [5, 3, 1, 2, 4]\n# 1\
    \ + 4 = 5, odd\nsort_array([1, 11, 2, 10, 3, 4, 5, 6, 7, 8, 9]) \u279E [9, 7,\
    \ 5, 3, 1, 2, 4, 6, 8, 10, 11]\n# 1 + 10 = 11, odd\nsort_array([2, 2, 2, 2, 2])\
    \ \u279E [2, 2, 2, 2, 2]\n# 2 + 2 = 4, even\nsort_array([2, 2, 2, 2, 2, 2]) \u279E\
    \ [2, 2, 2, 2, 2, 2]\n# 2 + 2 = 4, even\nsort_array([1, 2, 3, 4, 5, 6]) \u279E\
    \ [6, 4, 2, 1, 3, 5]\n# 1 + 6 = 7, odd\nsort_array([-4, -5, -6, -7, -8, -9]) \u279E\
    \ [-9, -7, -5, -4, -6, -8]\n# -4 + -9 = -13, odd\nsort_array([6, 7, 8, 9, 10,\
    \ 11]) \u279E [11, 9, 7, 6, 8, 10]\n# 6 + 11 = 17, odd\nsort_array([16, 17, 18,\
    \ 19, 20, 21]) \u279E [21, 19, 17, 16, 18, 20]\n# 16 + 21 = 37, odd\nsort_array([-17,\
    \ -16, -15, -14, -13, -12]) \u279E [-12, -14, -16, -17, -15, -13]\n# -17 + -12\
    \ = -29, odd\nsort_array([-18, -17, -16, -15, -14, -13])", "  (let* ([length (length\
    \ array)]\n         [sum (for/sum ([i length]) (array i))])\n    (if (odd? sum)\n\
    \        (sort array >)\n        (sort array <))))\n", "  (if (= (modulo (+ (array-ref\
    \ array 0) (array-ref array (- (array-length array) 1))) 2) 1)\n      (sort array\
    \ >)\n      (sort array <)))\n", "  (let ([even (odd? (add1 (add1 (add1 (add1\
    \ (+ (array-ref array 0) (array-ref array (- (array-length array) 1))))))))])\n\
    \    (if even\n        (sort array >)\n        (sort array <))))", "  (cond\n\
    \    [(zero? (sum array))\n     array]\n    [(odd? (sum array))\n     (sort array\
    \ (lambda (a b)\n                   (and (not (equal? a b))\n                \
    \        (< a b))))]\n    [else\n     (sort array (lambda (a b)\n            \
    \       (and (not (equal? a b))\n                        (> a b))))]))\n\n", " \
    \ (define (sum_i_j array)\n    (apply + (list (list-ref array 0) (list-ref array\
    \ (- (length array) 1)))))\n  (cond\n    [(odd? (sum_i_j array)) (sort array >)]\n\
    \    [(even? (sum_i_j array)) (sort array <)]))\n", "  (if (odd? (+ (car array)\
    \ (last array)))\n      (sort array <)\n      (sort array >)))\n", "  (define\
    \ (sum array)\n    (foldl + 0 array))\n  (define (check-even array)\n    (if (even?\
    \ (sum array)) array (reverse array)))\n  (check-even array))", "  (define (get-first\
    \ array)\n    (array-ref array 0))\n  (define (get-last array)\n    (array-ref\
    \ array (- (array-length array) 1)))\n  (define (sort-asc array)\n    (array-sort\
    \ array <))\n  (define (sort-desc array)\n    (array-sort array >))\n  (define\
    \ (solve array)\n    (cond [(= (remainder (+ (get-first array) (get-last array))\
    \ 2) 0) (sort-desc array)]\n          [else (sort-asc array)]))\n  (solve array))\n\
    \n", "  (let ([sum (apply + (array-ref array 0) (array-ref array (sub1 (array-length\
    \ array))))])\n    (cond [(odd? sum) (sort (reverse array) <)]\n          [else\
    \ (sort array >)])))\n", "  (sort array (\u03BB (x y)\n                (cond [(=\
    \ (remainder (+ (vector-ref array 0) (vector-ref array (vector-length array)))\
    \ 2) 1)\n                       (< x y)]\n                      [else\n      \
    \                 (> x y)]))))\n", "  (if (number-is-even? (+ (first array) (last\
    \ array)))\n      (reverse array)\n      array))\n", "  (if (equal? (even? (+\
    \ (array-ref array 0) (array-ref array (- (array-length array) 1))))\n       \
    \       #t)\n      (vector-sort > array)\n      (vector-sort < array)))\n", " \
    \ (cond\n    [(empty? array) empty]\n    [(empty? (rest array)) array]\n    [else\n\
    \     (let ([first (car array)]\n           [rest (cdr array)])\n       (cond\n\
    \         [(odd? (+ first (car (last array))))\n          (sort rest #:key (compose1\
    \ (curryr cons first) first))]\n         [else\n          (sort rest #:key (compose1\
    \ (curryr cons first) last))]))]))\n", "  (cond [(= 0 (length array)) empty]\n\
    \        [else (sort array <)]))\n", "  (let loop ((array array) (new-array (make-vector\
    \ (vector-length array))))\n    (cond\n      [(null? array) new-array]\n     \
    \ [(zero? (even? (add1 (add1 (vector-ref array 0)) (vector-ref array (- (vector-length\
    \ array) 1)))))\n       (vector-set! new-array 0 (vector-ref array (- (vector-length\
    \ array) 1)))\n       (vector-set! new-array (- (vector-length array) 1) (vector-ref\
    \ array 0))\n       (loop (vector-copy (vector-tail array) (vector-take array\
    \ (- (vector-length array) 1))) new-array)]\n      [else\n       (vector-set!\
    \ new-array 0 (vector-ref array 0))\n       (vector-set! new-array (- (vector-length\
    \ array) 1) (vector-ref array (- (vector-length array) 1)))\n       (loop (vector-copy\
    \ (vector-tail array) (vector-take array (- (vector-length array) 1))) new-array)])))\n",
  "  (let* ([result-array (make-vector (vector-length array))])\n    (let go ((i 0))\n\
    \      (if (< i (vector-length array))\n          (begin\n            (vector-set!\
    \ result-array i (vector-ref array i))\n            (go (+ i 1)))))\n    (vector-sort\
    \ (vector-&gt;list result-array) &lt;)\n    (let go ((i 0))\n      (if (&lt; i\
    \ (vector-length array))\n          (begin\n            (vector-set! result-array\
    \ i (vector-ref (vector-&gt;list result-array) i))\n            (go (+ i 1)))))\n\
    \    result-array))\n</code>\n\n<code>;; time-&gt;string: number -&gt; string",
  "  (cond\n    [(empty? array) '()]\n    [(even? (+ (first array) (last array)))\n\
    \     (append (reverse (rest (reverse array))) '())]\n    [else\n     (append\
    \ (reverse (rest array)) '())]))", "  (if (not (array? array))\n      array\n\
    \      (if (not (array-every even? array))\n          array\n          (sort array\n\
    \                (lambda (a b)\n                  (if (odd? (+ (array-ref array\
    \ 0) (array-ref array (- (array-length array) 1))))\n                      (<\
    \ a b)\n                      (> a b)))))))\n\n", "  (let ((is-even? (lambda (n)\
    \ (zero? (remainder n 2)))))\n    (let ((sorted (sort array is-even?)))\n    \
    \  (if (is-even? (+ (car sorted) (car (reverse sorted))))\n          (reverse\
    \ sorted)\n          sorted))))\n", "  (cond\n    [(odd? (+ (array-ref array 0)\
    \ (array-ref array (- (array-length array) 1))))\n     (sort < array)]\n    [else\n\
    \     (sort > array)]))\n", "  (let* ([array-length (length array)]\n        \
    \ [odd? (odd? (+ (array-ref array 0) (array-ref array (- array-length 1))))])\n\
    \    (cond\n      [odd? (sort array <)]\n      [else (sort array >)])))\n", " \
    \ (define (sum a b) (+ a b))\n  (define (odd? n) (= (remainder n 2) 1))\n  (sort\
    \ array\n        (lambda (x y)\n          (cond ((odd? (sum (vector-ref array\
    \ 0) (vector-ref array (- (vector-length array) 1))))\n                 (> x y))\n\
    \                (else (< x y))))))", "  (let* ([len (length array)]\n       \
    \  [sum (add1 (+ (vector-ref array 0) (vector-ref array (- len 1))))])\n    (cond\n\
    \      [(and (odd? sum) (even? (add1 len))) (sort array #:key car)]\n      [(and\
    \ (even? sum) (odd? (add1 len))) (sort array #:key car #:descending? #t)]\n  \
    \    [(and (odd? sum) (odd? (add1 len))) (sort array #:key cadr)]\n      [(and\
    \ (even? sum) (even? (add1 len))) (sort array #:key cadr #:descending? #t)])))\n",
  "  (cond\n    [(empty? array) '()]\n    [(= (length array) 1) array]\n    [else\n\
    \     (let* ([fir (first array)]\n            [last (last array)]\n          \
    \  [sum (+ fir last)]\n            [sorted (sort array #:key (\u03BB (x) x))])\n\
    \       (cond\n         [(odd? sum) sorted]\n         [else (reverse sorted)]))]))\n",
  "  (let* ([first-index-value (car array)]\n         [last-index-value (cadr (reverse\
    \ array))]\n         [sum (+ first-index-value last-index-value)])\n    (if (odd?\
    \ sum)\n        (sort array <)\n        (sort array >))))\n", "  (if (= (sum (car\
    \ array) (cadr (reverse array))) 1)\n      (sort array <)\n      (sort array >)))\n\
    \n", "  (sort array\n        (lambda (a b)\n          (if (even? (+ (first array)\
    \ (last array)))\n              (&gt; a b)\n              (&lt; a b)))))\n</code>\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
