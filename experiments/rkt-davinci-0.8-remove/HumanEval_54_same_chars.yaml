name: HumanEval_54_same_chars
language: rkt
prompt: "#lang racket\n\n;; Check if two words have the same characters.\n(define\
  \ (same_chars s0 s1)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n\
  \    (check-equal? (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t)\n    (check-equal?\
  \ (candidate \"abcd\" \"dddddddabc\") #t)\n    (check-equal? (candidate \"dddddddabc\"\
  \ \"abcd\") #t)\n    (check-equal? (candidate \"eabcd\" \"dddddddabc\") #f)\n  \
  \  (check-equal? (candidate \"abcd\" \"dddddddabcf\") #f)\n    (check-equal? (candidate\
  \ \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f)\n    (check-equal? (candidate \"aabb\"\
  \ \"aaccc\") #f)\n))\n\n(test-humaneval)"
completions: ["  (if (or (empty? s0) (empty? s1))\n      (empty? s0)\n      (if (equal?\
    \ (first s0) (first s1))\n          (same_chars (rest s0) (rest s1))\n       \
    \   (or (member (first s0) (rest s1))\n              (member (first s1) (rest\
    \ s0))))))\n", "  (equal? (string-downcase s0) (string-downcase s1)))\n", "  (let\
    \ loop ([i 0])\n    (if (&lt; i (string-length s0))\n        (if (member (string-ref\
    \ s0 i) s1)\n            (loop (+ i 1))\n            #f)\n        #t)))\n", " \
    \ (and (not (empty? s0))\n       (and (not (empty? s1))\n            (or (eq?\
    \ (first s0) (first s1))\n                (same_chars (rest s0) (rest s1))))))\n",
  "  (if (or (string=? s0 \"\") (string=? s1 \"\"))\n      #t\n      (or (eq? (car\
    \ s0) (car s1))\n          (same_chars (substring s0 1) (substring s1 1)))))\n",
  "  (cond\n    [(= (string-length s0) 0) #t]\n    [(= (string-length s1) 0) #f]\n\
    \    [(= (string-ref s0 0) (string-ref s1 0))\n     (same_chars (substring s0\
    \ 1) (substring s1 1))]\n    [else\n     (same_chars (substring s0 1) s1)]))\n",
  "  (cond\n    [(= (string-length s0) 0) #t]\n    [(= (string-length s1) 0) #f]\n\
    \    [(not (equal? (string-length s0) (string-length s1))) #f]\n    [(memq (string-ref\
    \ s0 0) s1) (same_chars (substring s0 1) (substring s1 1))]\n    [else #f]))\n",
  "  (if (equal? (string-length s0) (string-length s1))\n      (let loop ([s0 (string-&gt;list\
    \ s0)] [s1 (string-&gt;list s1)])\n        (cond [(empty? s0) #t]\n          \
    \    [(member (first s0) s1) (loop (rest s0) s1)]\n              [else #f]))\n\
    \      #f))\n", "  (equal? (sort (string->list s0)) (sort (string->list s1))))\n",
  "  (cond [(empty? s0) empty?]\n        [(equal? (first s0) (first s1)) (same_chars\
    \ (rest s0) (rest s1))]\n        [else (and (member (first s0) (rest s1))\n  \
    \                 (same_chars (rest s0) (remove (first s0) s1)))]))\n", "  (equal?\
    \ (sort s0 string<? ) (sort s1 string<? )))\n", "  (equal? (sort s0) (sort s1)))\n",
  "  (and (or (null? s0) (null? s1)) (null? s0) (null? s1))\n  (and (and (not (equal?\
    \ (first s0) (first s1)))\n            (member (first s0) s1))\n       (same_chars\
    \ (rest s0) (remove (first s0) s1))))\n", "  (equal? (sort s0 #&lt;=) (sort s1\
    \ #&lt;=)))\n", "  (every (lambda (c) (equal? (count c s0) (count c s1)))\n  \
    \       (build-list (max (string-length s0) (string-length s1))\n            \
    \         (lambda (i) (string-ref s0 i)))))\n", "  (if (or (empty? s0) (empty?\
    \ s1)) #t\n      (if (member (first s0) s1)\n          (same_chars (rest s0) (remove\
    \ (first s0) s1))\n          #f)))\n", "  (string=? (string-&gt;list s0) (string-&gt;list\
    \ s1)))\n", "  (equal? (sort (string->list s0)) (sort (string->list s1))))\n",
  "  (set! s0 (list->string (list-sort string-ci<? (string->list s0))))\n  (set! s1\
    \ (list->string (list-sort string-ci<? (string->list s1))))\n  (equal? s0 s1))\n",
  "  (cond [(equal? (list-set s0) (list-set s1)) 'yes]\n        [else 'no]))\n", " \
    \ (let ([c0 (string-&gt;list s0)]\n        [c1 (string-&gt;list s1)])\n    (or\n\
    \     (and (equal? c0 c1)\n          (equal? (length c0) (length c1)))\n     (and\
    \ (equal? (length c0) (length c1))\n          (equal? (set c0) (set c1))))))\n",
  "  (and (string=? (sort (string-&gt;list s0)) (sort (string-&gt;list s1)))\n   \
    \    (not (string=? s0 s1))))\n", "  (and (null? (remove s0 s1))\n       (null?\
    \ (remove s1 s0))))\n", "  (and (equal? (string-length s0) (string-length s1))\n\
    \       (every char=? (string-&gt;list s0) (string-&gt;list s1))))\n", "  (define\
    \ (helper s0 s1)\n    (cond\n      [(empty? s0) #t]\n      [(empty? s1) #f]\n\
    \      [(char=? (first s0) (first s1)) (helper (rest s0) (rest s1))]\n      [else\
    \ (helper (rest s0) s1)]))\n  (and\n    (= (string-length s0) (string-length s1))\n\
    \    (helper s0 s1)))\n", "  (let ([s0 (string-sort s0)]\n        [s1 (string-sort\
    \ s1)])\n    (and (equal? (string-length s0) (string-length s1))\n         (equal?\
    \ s0 s1))))\n", "  (and\n   (every #'char-alphabetic? (string->list s0))\n   (every\
    \ #'char-alphabetic? (string->list s1))\n   (string=? (string-sort s0) (string-sort\
    \ s1))))\n", "  (cond ((equal? s0 \"\")\n         (equal? s1 \"\"))\n        ((member?\
    \ (car s0) s1)\n         (same_chars (cdr s0) (substring s1 1)))\n        (else\n\
    \         #f)))\n", "  (cond [(empty? s0) (empty? s1)]\n        [(empty? s1) #f]\n\
    \        [else (and (char=? (first s0) (first s1))\n                   (same_chars\
    \ (rest s0) (rest s1)))]))\n", "  (and (= (string-length s0) (string-length s1))\n\
    \       (equal? (string-&gt;list s0) (string-&gt;list s1))))\n", "  (and (= (string-length\
    \ s0) (string-length s1))\n       (or (equal? (string-downcase s0) (string-downcase\
    \ s1))\n           (equal? (string-upcase s0) (string-upcase s1)))))\n", "  (or\
    \ (and (string=? s0 s1)\n           (string-length s0))\n      (and (string-length\
    \ s0)\n           (string-length s1)\n           (let ((s0c (string-ref s0 0))\n\
    \                 (s1c (string-ref s1 0)))\n             (and (char=? s0c s1c)\n\
    \                  (same-chars (substring s0 1)\n                            \
    \  (substring s1 1)))))))\n</code>\n", "  (define (rem-first-char c c-seq)\n \
    \   (cond\n      [(empty? c-seq) empty]\n      [(char=? c (first c-seq)) (rest\
    \ c-seq)]\n      [else (cons (first c-seq) (rem-first-char c (rest c-seq)))]))\n\
    \  (cond\n    [(or (empty? s0) (empty? s1)) empty]\n    [(char=? (first s0) (first\
    \ s1)) (same_chars (rest s0) (rest s1))]\n    [else (same_chars (cons (first s0)\
    \ (rem-first-char (first s0) (rest s1)))\n                          (cons (first\
    \ s1) (rem-first-char (first s1) (rest s0))))]))\n", "  (cond\n    [(empty? s0)\
    \ (empty? s1)]\n    [(member (first s0) s1) (same_chars (rest s0) (remove (first\
    \ s0) s1))]\n    [else false]))\n</code>\nIt's pretty clear how this works.  It\
    \ works recursively on the lists of characters.  It returns false if it finds\
    \ a letter in <code>s0</code> that's not in <code>s1</code>.  (It uses <code>member</code>\
    \ to test this.)  It uses <code>remove</code> to remove the first letter from\
    \ <code>s1</code> to simplify the recursion.\nNow let's write <code>word-pair?</code>\
    \ on top of <code>same-chars</code>.\n<code>#lang racket\n", "  (define s0-chars\
    \ (string-&gt;list s0))\n  (define s1-chars (string-&gt;list s1))\n  (define s0-unique\
    \ (remove-duplicates s0-chars))\n  (define s1-unique (remove-duplicates s1-chars))\n\
    \  (equal? s0-unique s1-unique))\n", "  (and (null? (string-index s0 #\\z #t))\n\
    \       (null? (string-index s1 #\\z #t))\n       (let ([s0 (string-append s0\
    \ \" \")]\n             [s1 (string-append s1 \" \")])\n         (cond [(or (string-contains\
    \ s0 #\\ )\n                    (string-contains s1 #\\ ))\n                #t]\n\
    \               [(and (string-contains s0 (string-ref s1 0))\n               \
    \      (string-contains s1 (string-ref s0 0)))\n                (same_chars (substring\
    \ s0 1) (substring s1 1))]\n               [else #f]))))\n", "  (let loop ([char-count\
    \ (make-hash)])\n    (if (empty? s0)\n        (if (empty? s1)\n            #t\n\
    \            (for ([c s1])\n              (hash-update! char-count sub1 c))\n\
    \            (for/and ([c (hash-keys char-count)])\n              (zero? (hash-ref\
    \ char-count c))))\n        (if (empty? s1)\n            (for ([c s0])\n     \
    \         (hash-update! char-count add1 c))\n            (let ([c0 (first s0)]\n\
    \                  [c1 (first s1)])\n              (if (char=? c0 c1)\n      \
    \            (loop (hash-update! char-count add1 c0)\n                       \
    \ (rest s0)\n                        (rest s1))\n                  (loop (hash-update!\
    \ char-count add1 c0)\n                        (hash-update! char-count sub1 c1)\n\
    \                        (rest s0)\n                        (rest s1)))))))\n\
    </code>\nNotes:\n\nthis is not very efficient\nit works only with strings (i.e.\
    \ sequences of characters)\n\n", "  (equal? (list->set (string->list s0))\n  \
    \        (list->set (string->list s1))))\n", "  (eq? (string-&gt;list s0) (string-&gt;list\
    \ s1)))\n", "  (and (string=? s0 s1)\n       (string=? (sort (string-&gt;list\
    \ s0))\n                  (sort (string-&gt;list s1)))))\n", "  (let loop ([s0\
    \ (string-&gt;list s0)]\n             [s1 (string-&gt;list s1)])\n    (cond [(empty?\
    \ s0) true]\n          [(empty? s1) true]\n          [(char=? (car s0) (car s1))\
    \ (loop (cdr s0) (cdr s1))]\n          [else false])))\n", "  (and (string=? (string-sort\
    \ s0) (string-sort s1))\n       (string-length s0)\n       (string-length s1)))\n",
  "  (equal? (string-&gt;list s0) (string-&gt;list s1)))\n", "  (let ((counts0 (count-occurrences\
    \ s0))\n        (counts1 (count-occurrences s1)))\n    (andmap (\u03BB (c) (=\
    \ (hash-ref counts0 c #f) (hash-ref counts1 c #f)))\n            (hash-keys counts0))))\n",
  "  (equal? (sort (string->list s0)) (sort (string->list s1))))\n", "  (and (string=?\
    \ s0 s1)\n       (every (lambda (c) (and (char-alphabetic? c) (>= c #\\A) (<=\
    \ c #\\Z))) s0)))\n", "  (cond [(equal? s0 \"\") #t]\n        [(member (first\
    \ s0) s1) (same_chars (rest s0) s1)]\n        [else #f]))\n", "  (define s0-characters\
    \ (string-&gt;list s0))\n  (define s1-characters (string-&gt;list s1))\n  (if\
    \ (null? s0-characters)\n      #t\n      (cond\n        [(member (car s0-characters)\
    \ s1-characters)\n         (same_chars (string (apply string (cdr s0-characters)))\n\
    \                     (string (apply string (remove (car s0-characters) s1-characters))))]\n\
    \        [else #f])))\n", "  (and (= (string-length s0) (string-length s1))\n\
    \       (for/and ([(c0 c1) (in-values (string-&gt;list s0) (string-&gt;list s1))])\n\
    \         (= c0 c1))))\n", "  (and (andmap (lambda (c) (char-set=? (char-set c)\
    \ s0)) s1)\n       (andmap (lambda (c) (char-set=? (char-set c) s1)) s0)))\n",
  "  (let ((l (length s0)))\n    (and (= l (length s1))\n         (every #t (map (\u03BB\
    \ (c) (member c s1)) (string-&gt;list s0))))))\n", "  (let* ([s0-chars (string-&gt;list\
    \ s0)]\n         [s1-chars (string-&gt;list s1)]\n         [s0-chars-sorted (sort\
    \ s0-chars (\u03BB (a b) (&lt; (char-&gt;integer a) (char-&gt;integer b))))]\n\
    \         [s1-chars-sorted (sort s1-chars (\u03BB (a b) (&lt; (char-&gt;integer\
    \ a) (char-&gt;integer b))))])\n    (equal? s0-chars-sorted s1-chars-sorted)))\n",
  "  (or (and (zero? (string-length s0)) (zero? (string-length s1)))\n      (and (not\
    \ (zero? (string-length s0)))\n           (not (zero? (string-length s1)))\n \
    \          (let ((c0 (substring s0 0 1))\n                 (c1 (substring s1 0\
    \ 1)))\n             (or (equal? c0 c1)\n                 (same_chars (substring\
    \ s0 1) s1)))\n           (same_chars (substring s0 1) (substring s1 1)))))\n",
  "  (equal? (string-sort s0) (string-sort s1)))\n", "  (if (string=? s0 s1)\n   \
    \   #t\n      (if (string-empty? s0)\n          #t\n          (if (string-empty?\
    \ s1)\n              #f\n              (let* ([char0 (string-ref s0 0)]\n    \
    \                 [rest0 (substring s0 1)]\n                     [rest1 (substring\
    \ s1 (string-index s1 char0))])\n                (same_chars rest0 rest1))))))\n",
  "  (and\n   (equal? (string-length s0) (string-length s1))\n   (for/and ([c (in-string\
    \ s0)])\n     (char-set-contains? (string-&gt;char-set s1) c))))\n", "  (and (=\
    \ (string-length s0) (string-length s1))\n       (equal? (string-sort s0) (string-sort\
    \ s1))))\n", "  (if (empty? s0)\n      (if (empty? s1)\n          #t\n       \
    \   #f)\n      (if (memq (first s0) s1)\n          (same_chars (rest s0) (remove\
    \ (first s0) s1))\n          #f)))\n", "  (define (same? a b) (and a (or (char=?\
    \ a b) (same? (rest a) (rest b)))))\n  (and (string=? s0 s1) (not (same? (string-&gt;list\
    \ s0) (string-&gt;list s1)))))\n", "  (and (char=? (string-ref s0 0) (string-ref\
    \ s1 0))\n       (char=? (string-ref s0 1) (string-ref s1 1))\n       (char=?\
    \ (string-ref s0 2) (string-ref s1 2))\n       (char=? (string-ref s0 3) (string-ref\
    \ s1 3))))\n", "  (string=? (sort s0) (sort s1)))\n", "  (cond\n    [(or (empty?\
    \ s0) (empty? s1)) (null? s0) ]\n    [else (let\n             ([c0 (first s0)]\n\
    \              [c1 (first s1)])\n           (cond\n             [(char=? c0 c1)\
    \ (same_chars (rest s0) (rest s1))]\n             [else (and (not (char=? c0 c1))\n\
    \                        (same_chars (rest s0) (rest s1)))]))]))\n", "  (define\
    \ (char-in-string? c0 s1)\n    (if (null? s1)\n        #f\n        (if (char=?\
    \ c0 (car s1))\n            #t\n            (char-in-string? c0 (cdr s1)))))\n\
    \  (if (null? s0)\n      #t\n      (if (char-in-string? (car s0) s1)\n       \
    \   (same-chars (cdr s0) s1)\n          #f)))\n", "  (cond ((null? s0) (null?\
    \ s1))\n        ((memq (car s0) s1) (same-chars (cdr s0) (delete (car s0) s1)))\n\
    \        (else false)))\n", "  (cond\n    [(empty? s0)\n     (empty? s1)]\n  \
    \  [(empty? s1)\n     (empty? s0)]\n    [else\n     (and (member (first s0) s1)\n\
    \          (same_chars (rest s0) (remove (first s0) s1)))]))\n", "  (let ((l0\
    \ (string-&gt;list s0))\n        (l1 (string-&gt;list s1)))\n    (define (helper\
    \ chars lst)\n      (if (null? lst)\n          #t\n          (if (member (car\
    \ lst) chars)\n              (helper chars (cdr lst))\n              #f)))\n \
    \   (helper l0 l1)))\n", "  (and (string=? (set s0) (set s1))\n       (string=?\
    \ (sort s0) (sort s1))))\n", "  (let ([c0 (string-&gt;list s0)]\n        [c1 (string-&gt;list\
    \ s1)])\n    (and (every (lambda (x) (or (memq x c1) (eq? x #\\space))) c0)\n\
    \         (every (lambda (x) (or (memq x c0) (eq? x #\\space))) c1))))\n", " \
    \ (equal? (list->set (string->list s0))\n          (list->set (string->list s1))))\n",
  "  (define (inner s0 s1)\n    (if (and (not (empty? s0)) (member (first s0) s1))\n\
    \        (inner (rest s0) (rest s1))\n        #f))\n  (inner (sort s0 <) (sort\
    \ s1 <)))\n", "  (let ([s0-chars (string-&gt;list s0)]\n        [s1-chars (string-&gt;list\
    \ s1)])\n    (every (curry equal? s0-chars) s1-chars)))\n", "  (let ([cs0 (string-&gt;list\
    \ s0)]\n        [cs1 (string-&gt;list s1)])\n    (and (every (lambda (c) (member\
    \ c cs1)) cs0)\n         (every (lambda (c) (member c cs0)) cs1))))\n", "  (and\
    \ (= (string-length s0) (string-length s1))\n       (every (curry char=? s0) s1)))\n",
  "  (define s0* (string-sort s0))\n  (define s1* (string-sort s1))\n  (string=? s0*\
    \ s1*))\n", "  (if (or (string=? s0 \"\") (string=? s1 \"\"))\n      (string=?\
    \ s0 s1)\n      (let ((c0 (string-ref s0 0))\n            (c1 (string-ref s1 0)))\n\
    \        (or (string=? (string-append (substring s0 1) \"\")\n               \
    \       (string-append (substring s1 1) \"\"))\n            (and (not (string=?\
    \ (string-downcase c0) (string-downcase c1)))\n                 (or (string=?\
    \ (substring s0 1) s1)\n                     (string=? s0 (substring s1 1))\n\
    \                     (string=? (substring s0 1) (substring s1 1))\n         \
    \            (string=? (substring s0 1)\n                               (string-append\
    \ (substring s1 1) \"\"))\n                     (string=? (string-append (substring\
    \ s0 1) \"\")\n                               (substring s1 1))))))))\n", "  (if\
    \ (or (eq? '() s0) (eq? '() s1))\n      #t\n      (and (member (car s0) s1)\n\
    \           (same_chars (cdr s0) (remq (car s0) s1)))))\n", "  (let loop ([c0\
    \ (string-&gt;list s0)]\n             [c1 (string-&gt;list s1)])\n    (cond [(empty?\
    \ c0) (= (length c0) (length c1))]\n          [(empty? c1) (= (length c0) (length\
    \ c1))]\n          [(equal? (car c0) (car c1)) (loop (cdr c0) (cdr c1))]\n   \
    \       [else #f])))\n", "  (if (and (not (null? s0)) (not (null? s1)))\n    \
    \  (if (eq? (first s0) (first s1))\n          (same_chars (rest s0) (rest s1))\n\
    \          (and (same_chars (rest s0) s1) (same_chars s0 (rest s1))))\n      (and\
    \ (null? s0) (null? s1))))\n", "  (cond\n    [(empty? s0) (empty? s1)]\n    [(memq\
    \ (first s0) s1) (same_chars (rest s0) (remove (first s0) s1))]\n    [else #f]))\n",
  "  (string=? (sort s0) (sort s1)))\n", "  (cond [(empty? s0) true]\n        [(empty?\
    \ s1) true]\n        [(member (first s0) s1) (same_chars (rest s0) (filter (lambda\
    \ (c) (not (= c (first s0)))) s1))]\n        [else false]))\n", "  (equal? (sort\
    \ s0 string<? #:key symbol-&gt;string)\n          (sort s1 string<? #:key symbol-&gt;string)))\n",
  "  (equal? (sort (string->list s0)) (sort (string->list s1))))\n", "  (let loop\
    \ ([s0 (list->string s0)]\n             [s1 (list->string s1)])\n    (cond [(empty?\
    \ s0) (empty? s1)]\n          [(empty? s1) (empty? s0)]\n          [(member (first\
    \ s0) s1) (loop (rest s0) (remove (first s0) s1))]\n          [else false])))\n",
  "  (define (count c acc)\n    (if (empty? acc)\n        (cons (cons c 1) empty)\n\
    \        (if (equal? (car (car acc)) c)\n            (cons (cons (car (car acc))\
    \ (+ 1 (cdr (car acc)))) (cdr acc))\n            (cons (car acc) (count c (cdr\
    \ acc))))))\n  (define s0-list (list->string s0))\n  (define s1-list (list->string\
    \ s1))\n  (define (string->list s)\n    (define acc empty)\n    (let loop ([s\
    \ s])\n      (if (empty? s)\n          acc\n          (loop (cdr s)))))\n  (define\
    \ (list->string l)\n    (define acc empty)\n    (let loop ([l l])\n      (if (empty?\
    \ l)\n          acc\n          (loop (cdr l)))))\n  (define (list->count l)\n\
    \    (if (empty? l)\n        empty\n        (count (car l) (list->count (cdr l)))))\n\
    \  (equal? (list->count s0-list) (list->count s1-list)))\n", "  (set-car! s0 '())\n\
    \  (set-car! s1 '())\n  (map (lambda (c) (set-car! s0 (cons c (car s0)))) (string->list\
    \ s0))\n  (map (lambda (c) (set-car! s1 (cons c (car s1)))) (string->list s1))\n\
    \  (set-car! s0 (sort (car s0) <))\n  (set-car! s1 (sort (car s1) <))\n  (equal?\
    \ (car s0) (car s1)))\n", "  (cond [(empty? s0) #t]\n        [(member (first s0)\
    \ s1) (same_chars (rest s0) s1)]\n        [else #f]))\n", "  (same_chars? (string->list\
    \ s0) (string->list s1)))\n", "  (define chs-to-counts (hash-from-alist (map (cut\
    \ list <> 1) s0)))\n  (for ([ch s1])\n    (hash-update! chs-to-counts ch - 1))\n\
    \  (not (hash-any (curry &lt; 0) chs-to-counts)))\n", "  (every\n   (lambda (c)\n\
    \     (not (zero? (count c s0))))\n   s1))\n", "  (cond\n    [(empty? s0) (empty?\
    \ s1)]\n    [(empty? s1) #f]\n    [else (and (memq (first s0) s1)\n          \
    \     (same_chars (rest s0) (remove (first s0) s1)))]))\n", "  (equal? (set s0)\
    \ (set s1)))\n", "  (and (= (string-length s0) (string-length s1))\n       (equal?\
    \ (string-&gt;list s0) (string-&gt;list s1))))\n", "  (if (equal? s0 \"\")\n \
    \     (equal? s1 \"\")\n      (if (equal? s1 \"\")\n          false\n        \
    \  (or (same_chars (substring s0 1) (substring s1 1))\n              (same_chars\
    \ (substring s0 1) (string-append (substring s1 0 1) (substring s1 1)))))))\n",
  "  (and (= (string-length s0) (string-length s1))\n       (not (find (lambda (c)\n\
    \                    (and (not (string-member c s0))\n                       \
    \  (string-member c s1)))\n                  s0))))\n", "  (and (= (length s0)\
    \ (length s1))\n       (set= (string-&gt;list s0) (string-&gt;list s1))))\n",
  "  (and (equal? (string-length s0) (string-length s1))\n       (andmap (lambda (c)\
    \ (string-contains s1 c)) (string->list s0))))\n", "  (if (or (empty? s0) (empty?\
    \ s1))\n      (equal? s0 s1)\n      (and (member (first s0) s1)\n           (same_chars\
    \ (rest s0) (remove (first s0) s1)))))\n", "  (define (check lst)\n    (cond\n\
    \      [(empty? lst) empty]\n      [(empty? (member (first lst) s1)) (check (rest\
    \ lst))]\n      [else (cons (first lst) (check (rest lst)))]))\n  (equal? (check\
    \ s0) s1))\n", "  (eq? (length s0) (length s1))\n  (andmap (lambda (char) (member\
    \ char s1)) s0))\n", "  (and (equal? (sort (string->list s0)) (sort (string->list\
    \ s1)))\n       (not (string=? s0 s1))))\n", "  (empty? (remove s0 (remove #\\\
    space s1))))\n", "  (define (same_chars s0 s1)\n    (and (null? s0) (null? s1)))\n\
    \  (define (same_chars s0 s1)\n    (and (not (null? s0)) (not (null? s1))\n  \
    \       (or (char=? (car s0) (car s1))\n             (same_chars (cdr s0) (cdr\
    \ s1)))))\n  (same_chars (string-&gt;list s0) (string-&gt;list s1)))\n", "  (define\
    \ s0-set (set-&gt;list (string-&gt;set s0)))\n  (define s1-set (set-&gt;list (string-&gt;set\
    \ s1)))\n  (equal? s0-set s1-set))\n", "  (and (not (null? s0))\n       (not (null?\
    \ s1))\n       (eq? (car s0) (car s1))\n       (same_chars (cdr s0) (cdr s1))))\n",
  "  (let ([l0 (string-&gt;list s0)]\n        [l1 (string-&gt;list s1)])\n    (every\
    \ (lambda (c) (member c l1)) l0)))\n", "  (equal? (sort s0) (sort s1)))\n", " \
    \ (equal? (sort s0) (sort s1)))\n", "  (cond\n    [(null? s0) (null? s1)]\n  \
    \  [(null? s1) #f]\n    [(member (car s0) s1) (same_chars (cdr s0) (delete (car\
    \ s0) s1))]\n    [else #f]))\n", "  (let ((chars (make-hash)))\n    (for ([c s0])\n\
    \      (hash-set! chars c (add1 (hash-ref chars c 0))))\n    (for ([c s1])\n \
    \     (hash-set! chars c (sub1 (hash-ref chars c 0))))\n    (every zero? (hash-values\
    \ chars))))\n", "  (define (same_chars s0 s1)\n    (cond\n      [(or (null? s0)\
    \ (null? s1)) #t]\n      [(and (= (length s0) (length s1))\n            (every\
    \ char-ci=? s0 s1)) #t]\n      [else #f]))\n  (same_chars (string-&gt;list s0)\
    \ (string-&gt;list s1)))\n", "  (every (lambda (c) (memq c s1)) s0))\n```\n\n\
    ```racket", "  (and (= (string-length s0) (string-length s1))\n       (equal?\
    \ (string-sort s0) (string-sort s1))))\n", "  (every #t (map (lambda (v)\n   \
    \                (member v s1))\n                 s0)))\n", "  (let ([chars (hash-set)])\n\
    \    (for ([c s0])\n      (hash-set chars c (hash-ref chars c 0) +1))\n    (for\
    \ ([c s1])\n      (hash-set chars c (hash-ref chars c 0) -1))\n    (for ([c s0])\n\
    \      (if (zero? (hash-ref chars c))\n          (hash-remove chars c)))\n   \
    \ (not (empty? chars))))\n", "  (let ([set0 (string-&gt;set s0)]\n        [set1\
    \ (string-&gt;set s1)])\n    (set=? set0 set1)))\n", "  (define (same-chars-inner\
    \ s0 s1)\n    (cond ((or (string=? s0 \"\") (string=? s1 \"\")) true)\n      \
    \    ((char=? (string-ref s0 0) (string-ref s1 0)) (same-chars-inner (substring\
    \ s0 1) (substring s1 1)))\n          (else false)))\n  (same-chars-inner (string-sort\
    \ s0) (string-sort s1)))\n", "  (equal? (sort s0 string-ci<? #:key char-downcase)\n\
    \          (sort s1 string-ci<? #:key char-downcase)))\n", "  (or (equal? s0 s1)\n\
    \      (and (string=? (sort s0) (sort s1))\n           (every (lambda (x) (&gt;\
    \ (count x s0) 0)) s0))))\n", "  (define (helper s0 s1)\n    (cond ((null? s0)\
    \ '())\n          ((assoc (car s0) s1) (cons (car s0) (helper (cdr s0) s1)))\n\
    \          (else (helper (cdr s0) s1))))\n  (set! s0 (helper s0 s1))\n  (set!\
    \ s1 (helper s1 s0))\n  (equal? s0 s1))\n", "  (or\n   (eq? s0 s1)\n   (and\n\
    \    (equal? (length s0) (length s1))\n    (or (and (string=? (substring s0 0\
    \ 1) (substring s1 0 1))\n             (same_chars (substring s0 1) (substring\
    \ s1 1)))\n        (and (string=? (substring s0 0 1) (substring s1 1 1))\n   \
    \          (same_chars (substring s0 1) (substring s1 0 (- (length s1) 1))))))))\n",
  "  (let ([chars0 (sort s0)])\n    (every (lambda (char) (member char chars0))\n\
    \           (sort s1))))\n", "  (and (equal? (sort s0 #&lt;=) (sort s1 #&lt;=))\n\
    \       (andmap char-&gt;integer s0)\n       (andmap char-&gt;integer s1)))\n",
  "  (and (string=? (string-length s0) (string-length s1))\n       (every (lambda\
    \ (c)\n                (and (&gt; (char-ci-&gt;integer c) 31)\n              \
    \       (&lt; (char-ci-&gt;integer c) 128)\n                     (char-ci=? (char-ci\
    \ (string-ref s0 c) 'en_US.utf8)\n                                 (char-ci (string-ref\
    \ s1 c) 'en_US.utf8))))\n              (range (string-length s0)))))\n", "  (cond\
    \ ((or (string=? s0 \"\") (string=? s1 \"\"))\n         #t)\n        ((not (char=?\
    \ (string-ref s0 0) (string-ref s1 0)))\n         #f)\n        (else (same_chars\
    \ (substring s0 1) (substring s1 1)))))\n", "  (and (string=? (sort s0) (sort\
    \ s1))\n       (not (string=? s0 s1))))\n", "  (if (or (empty? s0) (empty? s1))\n\
    \      (and (empty? s0) (empty? s1))\n      (and (member (first s0) s1)\n    \
    \       (same_chars (rest s0) (remove (first s0) s1)))))\n", "  (cond\n    [(null?\
    \ s0) (= (length s0) (length s1))]\n    [(equal? (car s0) (car s1)) (same_chars\
    \ (cdr s0) (cdr s1))]\n    [else (same_chars (cdr s0) (remove (car s0) s1))]))\n",
  "  (sort s0 &lt;=?)\n  (sort s1 &lt;=?)\n  (andmap (curry =? (s0)) s1))\n", "  (cond\
    \ [(empty? s0)\n         (empty? s1)]\n        [(char=? (first s0) (first s1))\n\
    \         (same_chars (rest s0) (rest s1))]\n        [else\n         (false)]))\n",
  "  (and (= (string-length s0) (string-length s1))\n       (string=? (string-normalize-nfc\
    \ s0) (string-normalize-nfc s1))))\n", "  (define (normalize s)\n    (string-normalize-spaces\
    \ (string-downcase s)))\n  (equal? (normalize s0) (normalize s1)))\n", "  (cond\
    \ [(empty? s0)\n         (empty? s1)]\n        [(char=? (first s0) (first s1))\n\
    \         (same_chars (rest s0) (rest s1))]\n        [else false]))\n", "  (or\
    \ (string=? s0 s1)\n      (let loop ([s0 s0] [s1 s1])\n        (if (string-ci=?\
    \ s0 s1)\n            #t\n            (let ([x (substring s0 1)]\n           \
    \       [y (substring s1 1)])\n              (loop x y))))))\n", "  (and (every\
    \ (lambda (s) (not (string=? s \"\")))\n              (map string-&gt;list\n \
    \                  (permutations (list s0 s1))))\n       (every (lambda (s) (not\
    \ (string=? s \"\")))\n              (map string-&gt;list\n                  \
    \ (permutations (list (string-&gt;list s0)\n                                 \
    \      (string-&gt;list s1)))))))\n", "  (let* ([ms0 (make-hasheq)]\n        \
    \ [ms1 (make-hasheq)])\n    (for ([ch (in-string s0)])\n      (hash-set! ms0 ch\
    \ (+ 1 (hash-ref ms0 ch 0))))\n    (for ([ch (in-string s1)])\n      (hash-set!\
    \ ms1 ch (+ 1 (hash-ref ms1 ch 0))))\n    (and (hash-equal? ms0 ms1) (equal? (string-length\
    \ s0) (string-length s1)))))\n", "  (string=? (string-sort s0) (string-sort s1)))\n",
  "  (and (char=? (string-ref s0 0) (string-ref s1 0))\n       (char=? (string-ref\
    \ s0 1) (string-ref s1 1))\n       (char=? (string-ref s0 2) (string-ref s1 2))\n\
    \       (char=? (string-ref s0 3) (string-ref s1 3))))\n", "  (cond\n    ((null?\
    \ s0) (null? s1))\n    ((and (not (char=? (car s0) (car s1)))\n          (memq\
    \ (car s0) s1))\n     (same-chars (cdr s0) (cdr s1)))\n    (else #f)))\n</code>\n",
  "  (not (null? (filter (lambda (x) (not (null? (member x s1)))) s0))))\n", "  (string=?\
    \ (sort s0) (sort s1)))\n", "  (if (or (null? s0) (null? s1))\n      (null? s0)\n\
    \      (let ((ch0 (string-ref s0 0))\n            (ch1 (string-ref s1 0)))\n \
    \       (or (char=? ch0 ch1)\n            (and (same_chars (substring s0 1) (substring\
    \ s1 1))\n                 (same_chars (substring s0 1) (string ch1))\n      \
    \           (same_chars (string ch0) (substring s1 1)))))))\n", "  (define (swap\
    \ s)\n    (if (equal? s0 s)\n        s1\n        s0))\n  (define (chars-in-string\
    \ s)\n    (map char-&gt;integer (string-&gt;list s)))\n  (define (normalize s)\n\
    \    (let loop ([chars (chars-in-string s)]\n               [norm '()])\n    \
    \  (cond\n        [(empty? chars) (list-&gt;string (reverse norm))]\n        [(member\
    \ (car chars) norm) (loop (cdr chars) norm)]\n        [else (loop (cdr chars)\
    \ (cons (car chars) norm))])))\n  (equal? (normalize s0) (normalize s1)))\n",
  "  (set! s0 (string-sort s0))\n  (set! s1 (string-sort s1))\n  (string=? s0 s1))\n",
  "  (equal? (string-sort s0) (string-sort s1)))\n", "  (string=? (string-sort s0)\
    \ (string-sort s1)))\n", "  (let ([c0 (string-&gt;list s0)]\n        [c1 (string-&gt;list\
    \ s1)])\n    (and (every (compose (flip member? c1) car) c0)\n         (every\
    \ (compose (flip member? c0) car) c1))))\n", "  (if (empty? s0)\n      (if (empty?\
    \ s1) #t #f)\n      (if (empty? s1) #f\n          (let ((ch0 (first s0))\n   \
    \             (ch1 (first s1)))\n            (if (equal? ch0 ch1)\n          \
    \      (same_chars (rest s0) (rest s1))\n                (same_chars (rest s0)\
    \ (cons ch1 (rest s1))))))))\n</code>\nThis works fine, but I'm not sure if there's\
    \ a more idiomatic way to write it.\nThanks.\n\n\nA:\n\nOne very common technique\
    \ you could use is to define a set and then remove elements from each word as\
    \ they are found to be the same, so that when the set is empty, you know that\
    \ the words match. For example:\n<code>(define (same-chars w0 w1)\n  (define s\
    \ (set w0))\n  (for/or ([c w1])\n    (if (set-remove! s c)\n        #f\n     \
    \   #t)))\n</code>\n", "  (eq? (sort (string-&gt;list s0)) (sort (string-&gt;list\
    \ s1))))\n", "  (let loop ([s0 (string-&gt;list s0)]\n             [s1 (string-&gt;list\
    \ s1)])\n    (cond [(empty? s0) true]\n          [(empty? s1) false]\n       \
    \   [(memq (car s0) s1) (loop (cdr s0) (remove (car s0) s1))]\n          [else\
    \ false])))\n", "  (if (or (empty? s0) (empty? s1))\n      (and (empty? s0) (empty?\
    \ s1))\n      (and (equal? (first s0) (first s1))\n           (same_chars (rest\
    \ s0) (rest s1)))))\n", "  (and (equal? (set (string->list s0)) (set (string->list\
    \ s1)))\n       (equal? (string-length s0) (string-length s1))))\n", "  (local\
    \ ((define (same-chars-count s0 s1)\n            (cond\n              [(or (string=?\
    \ s0 \"\") (string=? s1 \"\")) 0]\n              [(string-contains s1 (string-ref\
    \ s0 0))\n               (+ 1 (same-chars-count (substring s0 1) (string-remove\
    \ (string-ref s0 0) s1)))]\n              [else\n               (same-chars-count\
    \ (substring s0 1) s1)])))\n    (= (same-chars-count s0 s1) (string-length s0))))\n\
    </code>\nHow can I improve this function?\n\n\nA:\n\nThe problem with your code\
    \ is that you're doing a lot of string-manipulation.  Racket strings are immutable\
    \ so any string-manipulation will allocate a new string.  This adds a lot of overhead\
    \ and can lead to memory leaks.  If you're doing a lot of this, it's best to use\
    \ vectors instead.  We can transform your strings into vectors with <code>string-&gt;list</code>\
    \ and back with <code>list-&gt;string</code>.\nHere's a version of your code that\
    \ uses vectors.  You may have to do this a few times to understand the benefits\
    \ of using vectors.\n<code>(define (same-chars? s0 s1)\n  (define (same-chars-count\
    \ s0 s1)\n    (cond\n      [(or (null? s0) (null? s1)) 0]\n      [(vector-contains\
    \ s1 (vector-ref s0 0))\n       (+ 1 (same-chars-count (vector-rest s0) (vector-remove\
    \ (vector-ref s0 0) s1)))]\n      [else\n       (same-chars-count (vector-rest\
    \ s0) s1)]))\n  (= (same-chars-count (string-&gt;list s0) (string-&gt;list s1))\
    \ (string-length s0)))\n</code>\nBut there's an even simpler solution.  Strings\
    \ already have an <code>equal?</code> predicate that tells us if two strings are\
    \ the same.  It's a matter of transforming one string into the other string",
  "  (and (length s0) (length s1)\n       (member (string-ref s0 0) s1)\n       (same_chars\
    \ (substring s0 1) (remove (string-ref s0 0) s1))))\n", "  (cond\n    [(empty?\
    \ s0) #t]\n    [(char-member? (first s0) s1) (same-chars (rest s0) (remove (first\
    \ s0) s1))]\n    [else #f]))\n", "  (eq? (sort string<? (string-&gt;list s0))\n\
    \       (sort string<? (string-&gt;list s1))))\n", "  (equal? (sort (string->list\
    \ s0)) (sort (string->list s1))))\n", "  (equal? (sort (string->list s0)) (sort\
    \ (string->list s1))))\n", "  (let ([sl0 (string-&gt;list s0)]\n        [sl1 (string-&gt;list\
    \ s1)])\n    (cond [(equal? sl0 sl1) #t]\n          [(null? sl0) #f]\n       \
    \   [(member (car sl0) sl1) (same_chars (string (cdr sl0)) (string (remove (car\
    \ sl0) sl1)))]\n          [else #f])))\n", "  (and (every string=? (string-&gt;list\
    \ s0) (string-&gt;list s1))\n       (every string=? (string-&gt;list s1) (string-&gt;list\
    \ s0))))\n", "  (set-equal? (string-&gt;list s0) (string-&gt;list s1)))\n", " \
    \ (local [(define (unique-chars s)\n            (filter (lambda (x) #t) (unique\
    \ (string-&gt;list s))))]\n    (equal? (unique-chars s0) (unique-chars s1))))\n",
  "  (and (all (lambda (c)\n              (member c s1))\n            s0)\n      \
    \ (all (lambda (c)\n              (member c s0))\n            s1)))\n", "  (and\
    \ (char=? (string-ref s0 0) (string-ref s1 0))\n       (char=? (string-ref s0\
    \ 1) (string-ref s1 1))\n       (char=? (string-ref s0 2) (string-ref s1 2))\n\
    \       (char=? (string-ref s0 3) (string-ref s1 3))))\n", "  (and (char=? (string-ref\
    \ s0 0) (string-ref s1 0))\n       (char=? (string-ref s0 1) (string-ref s1 1))\n\
    \       (char=? (string-ref s0 2) (string-ref s1 2))\n       (char=? (string-ref\
    \ s0 3) (string-ref s1 3))))\n", "  (and (= (string-length s0) (string-length\
    \ s1))\n       (every (lambda (char) (member char s1)) s0)))\n", "  (set! s0 (string-sort\
    \ s0))\n  (set! s1 (string-sort s1))\n  (equal? s0 s1))\n", "  (let ([s0 (set\
    \ s0)]\n        [s1 (set s1)])\n    (equal? s0 s1)))\n", "  (set! s0 (string-&gt;list\
    \ s0))\n  (set! s1 (string-&gt;list s1))\n  (define (iter s0 s1)\n    (if (empty?\
    \ s0)\n        true\n        (if (member (first s0) s1)\n            (iter (rest\
    \ s0) (remove (first s0) s1))\n            false)))\n  (iter s0 s1))\n", "  (and\
    \ (equal? (sort s0) (sort s1))\n       (not (zero? (string-length s0)))))\n",
  "  (let ([m0 (make-hash)])\n    (for ([c (in-string s0)])\n      (hash-set! m0 c\
    \ (add1 (hash-ref m0 c 0))))\n    (for ([c (in-string s1)])\n      (hash-set!\
    \ m0 c (sub1 (hash-ref m0 c 0))))\n    (for/and ([(k v) (in-hash m0)])\n     \
    \ (= v 0))))\n", "  (cond\n    ((null? s0) (null? s1))\n    ((null? s1) #f)\n\
    \    ((char=? (car s0) (car s1)) (same_chars (cdr s0) (cdr s1)))\n    (else #f)))\n",
  "  (or (string=? s0 s1)\n      (and (string-contains s0 s1)\n           (string-contains\
    \ s1 s0))))\n", "  (and (every char-set=? (string-&gt;list s0) (string-&gt;list\
    \ s1))\n       (every char-set=? (string-&gt;list s1) (string-&gt;list s0))))\n",
  "  (and (null? (match s0 s1 #:pat '()))\n       (null? (match s1 s0 #:pat '()))))\n",
  "  (equal? (string-sort s0) (string-sort s1)))\n", "  (let* ([s0 (sort string-&lt;?\
    \ (string-&gt;list s0))]\n         [s1 (sort string-&lt;? (string-&gt;list s1))])\n\
    \    (and (= (length s0) (length s1))\n         (equal? s0 s1))))\n", "  (if (string=?\
    \ s0 s1)\n      #t\n      (or (member (string-ref s0 0) s1)\n          (same_chars\
    \ (substring s0 1) (substring s1 1)))))\n", "  (cond\n    [(empty? s0) (empty?\
    \ s1)]\n    [(char=? (first s0) (first s1)) (same_chars (rest s0) (rest s1))]\n\
    \    [else (or (char=? (first s0) (first s1))\n              (same_chars (rest\
    \ s0) s1)\n              (same_chars s0 (rest s1)))]))\n", "  (and (not (equal?\
    \ (length s0) (length s1)))\n       (not (memq #\\space s0))\n       (not (memq\
    \ #\\space s1))\n       (not (memq #\\tab s0))\n       (not (memq #\\tab s1))\n\
    \       (not (memq #\\linefeed s0))\n       (not (memq #\\linefeed s1))\n    \
    \   (not (memq #\\return s0))\n       (not (memq #\\return s1))\n       (equal?\
    \ (string-sort s0) (string-sort s1))))\n", "  (equal? (sort s0 <) (sort s1 <)))\n",
  "  (define (norm s)\n    (sort\n     (string-&gt;list s)\n     &lt;\n     )\n  \
    \  )\n  (equal? (norm s0) (norm s1))\n  )\n", "  (and (= (string-length s0) (string-length\
    \ s1))\n       (not (empty? (for/and ([c (in-string s0)])\n                  \
    \     (memq c (string->list s1)))))))\n", "  (let ([cs0 (string-&gt;list s0)]\n\
    \        [cs1 (string-&gt;list s1)])\n    (and (= (length cs0) (length cs1))\n\
    \         (every char-set=? cs0 cs1))))\n", "  (equal? (sort (string->list s0))\
    \ (sort (string->list s1))))\n", "  (every (lambda (c) (= (count c s0) (count\
    \ c s1)))\n         (string-&gt;list s0)))\n", "  (and (equal? (string-length\
    \ s0) (string-length s1))\n       (let loop ([s0 (string-&gt;list s0)]\n     \
    \             [s1 (string-&gt;list s1)])\n         (cond\n           [(null? s0)\
    \ #t]\n           [(memq (car s0) s1) (loop (cdr s0) s1)]\n           [else #f]))))\n",
  "  (or (equal? s0 s1)\n      (equal? (sort string&lt;=? s0) (sort string&lt;=? s1))))\n",
  "  (eq? (sort (string-&gt;list s0)) (sort (string-&gt;list s1))))\n", "  (define\
    \ (scan s0 s1)\n    (if (null? s0)\n        #t\n        (if (null? s1)\n     \
    \       #f\n            (if (memq (car s0) s1)\n                (scan (cdr s0)\
    \ (remove (car s0) s1))\n                #f))))\n  (scan (string->list s0) (string->list\
    \ s1)))\n", "  (and (equal? (string-length s0) (string-length s1))\n       (apply\
    \ and (map (lambda (c) (member c s1)) s0))))\n", "  (eq? (sort string-&lt;? (string-&gt;list\
    \ s0))\n       (sort string-&lt;? (string-&gt;list s1))))\n", "  (and (= (string-length\
    \ s0) (string-length s1))\n       (equal? (sort (string->list s0)) (sort (string->list\
    \ s1)))))\n", "  (cond\n    [(empty? s0) #t]\n    [(char-member (first s0) s1)\
    \ (same-chars (rest s0) (char-delete (first s0) s1))]\n    [else #f]))\n", " \
    \ (if (or (empty? s0) (empty? s1))\n      #t\n      (if (char=? (first s0) (first\
    \ s1))\n          (same_chars (rest s0) (rest s1))\n          #f)))\n", "  (let\
    \ ([set-s0 (set s0)]\n        [set-s1 (set s1)])\n    (andmap (lambda (c) (member\
    \ c set-s0))\n            set-s1)))\n</code>\nAnd here is a test case\n<code>;;\
    \ a test case", "  (let ([sc (for/hash ([x (in-string s0)])\n                \
    \   (lambda (y) (hash-update y add1 0 x)))]\n        [sc (for/hash ([x (in-string\
    \ s1)])\n                   (lambda (y) (hash-update y add1 0 x)))])\n    (for/and\
    \ ([x (in-hash-keys sc)])\n             (= (hash-ref sc x) 0))))\n", "  (define\
    \ (same-list lst0 lst1)\n    (cond [(null? lst0) (null? lst1)]\n          [(null?\
    \ lst1) #f]\n          [(and (member (car lst0) lst1)\n                (same-list\
    \ (cdr lst0) (remove (car lst0) lst1)))]\n          [else #f]))\n  (same-list\
    \ (string-&gt;list s0) (string-&gt;list s1)))\n", "  (equal? (sort (string->list\
    \ s0)) (sort (string->list s1))))\n", "  (let ([s0 (string-&gt;list s0)]\n   \
    \     [s1 (string-&gt;list s1)])\n    (andmap char=? s0 s1)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
