name: HumanEval_68_pluck
language: rkt
prompt: "#lang racket\n\n;; \"Given an array representing a branch of a tree that\
  \ has non-negative integer nodes\n;; your task is to pluck one of the nodes and\
  \ return it.\n;; The plucked node should be the node with the smallest even value.\n\
  ;; If multiple nodes with the same smallest even value are found return the node\
  \ that has smallest index.\n;; The plucked node should be returned in a list, [\
  \ smalest_value, its index ],\n;; If there are no even values or the given array\
  \ is empty, return [].\n;; Constraints:\n;; * 1 <= nodes.length <= 10000\n;; * 0\
  \ <= node.value\n(define (pluck arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n\
  \    (check-equal? (candidate (list 4 2 3)) (list 2 1))\n    (check-equal? (candidate\
  \ (list 1 2 3)) (list 2 1))\n    (check-equal? (candidate (list )) (list ))\n  \
  \  (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))\n    (check-equal? (candidate\
  \ (list 1 2 3 0 5 3)) (list 0 3))\n    (check-equal? (candidate (list 5 4 8 4 8))\
  \ (list 4 1))\n    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))\n    (check-equal?\
  \ (candidate (list 7 9 7 1)) (list ))\n))\n\n(test-humaneval)"
completions: ["  (if (empty? arr)\n      '(())\n      (let* ([sm (apply min (filter\
    \ even? arr))]\n             [sm-index (index-of arr sm)])\n        (list sm sm-index))))\n",
  "  (define (pluck-rec arr)\n    (cond [(empty? arr) '()]\n          [(empty? (rest\
    \ arr)) (cons (car arr) (cons 0 '()))]\n          [(even? (car arr)) (cons (car\
    \ arr) (cons 0 '()))]\n          [else (pluck-rec (rest arr))]))\n  (let ([smallest-even\
    \ (apply min (filter even? arr))])\n    (if (null? smallest-even)\n        '()\n\
    \        (cons smallest-even (cons (find-index arr (lambda (n) (= n smallest-even)))\
    \ '())))))\n", "  (define (leaf? arr)\n    (and (list? arr)\n         (empty?\
    \ (cdr arr))))\n  (define (all-leaves? arr)\n    (cond [(empty? arr) #t]\n   \
    \       [(leaf? (car arr)) (all-leaves? (cdr arr))]\n          [else #f]))\n \
    \ (define (smallest arr)\n    (cond [(empty? arr) (error \"empty list\")]\n  \
    \        [(leaf? (car arr)) (car arr)]\n          [(< (car arr) (smallest (cdr\
    \ arr))) (car arr)]\n          [else (smallest (cdr arr))]))\n  (define (one-even?\
    \ arr)\n    (cond [(empty? arr) #f]\n          [(leaf? (car arr)) (even? (car\
    \ arr))]\n          [(not (even? (car arr))) (one-even? (cdr arr))]\n        \
    \  [else #t]))\n  (define (find-even arr num)\n    (cond [(empty? arr) (error\
    \ \"empty list\")]\n          [(and (leaf? (car arr)) (even? (car arr))) (list\
    \ (car arr) num)]\n          [(and (not (leaf? (car arr))) (one-even? (car arr)))\
    \ (find-even (car arr) num)]\n          [else (find-even (cdr arr) (+ num 1))]))\n\
    \  (define (all-even? arr)\n    (cond [(empty? arr) #t]\n          [(leaf? (car\
    \ arr)) (even? (car arr))]\n          [(not (even? (car arr))) #f]\n         \
    \ [else (all-even? (cdr arr))]))\n  (cond [(empty? arr) '()]\n        [(all-leaves?\
    \ arr) (if (one-even? arr) (find-even arr 0) '())]\n        [(all-even? arr) (list\
    \ (smallest arr) 0)]\n        [else '()]))\n", "  (define even? (lambda (n) (=\
    \ (remainder n 2) 0)))\n  (define min-even-index (lambda (arr)\n             \
    \              (let* ([evens (filter even? arr)]\n                           \
    \       [min-even (apply min evens)])\n                             (list-index\
    \ arr min-even))))\n  (cond [(empty? arr) empty]\n        [(zero? (length (filter\
    \ even? arr))) empty]\n        [else (let* ([min-even-i (min-even-index arr)]\n\
    \                     [min-even (list-ref arr min-even-i)])\n                (list\
    \ min-even min-even-i))]))\n", "  (cond\n    [(empty? arr) '()]\n    [(zero? (modulo\
    \ (first arr) 2)) (list (first arr) 0)]\n    [(not (pair? (first arr))) (pluck\
    \ (rest arr))]\n    [else (pluck (append (first arr) (rest arr)))]))\n", "  (match\
    \ arr\n    [() '()]\n    [(or\n      (empty-list? (cons _ _))\n      (empty-list?\
    \ (cons _ (cons _ _)))) '()]\n    [(cons (? even?) _) (list arr 0)]\n    [(cons\
    \ _ arr) (pluck arr)]))\n", "  (let ([min-idx -1]\n        [min-val -1])\n   \
    \ (for ([i (in-range (vector-length arr))])\n      (when (and (even? (vector-ref\
    \ arr i))\n                 (or (and (not (even? min-val))\n                 \
    \         (even? (vector-ref arr i)))\n                     (< (vector-ref arr\
    \ i) min-val)))\n        (set! min-idx i)\n        (set! min-val (vector-ref arr\
    \ i))))\n    (if (even? min-val)\n        (list min-val min-idx)\n        '())))\n\
    ```\n\nThis solution is pretty similar to the one for JavaScript, but has one\
    \ major difference:\nit uses mutation (`set!`) to update the variables storing\
    \ the index and value of the smallest even number,\nrather than using a loop to\
    \ recurse over all the values while updating the relevant variables as it goes.\n\
    It's also missing the type checks and the pretty printing of the answer, but they're\
    \ not hard to add.\n\n---\n\n## Closing Thoughts\n\nWell, that's that. As far\
    \ as I can tell, my solution for each language is basically the same,\nit's just\
    \ expressed in the syntax and semantics of that language.\nI'm not really sure\
    \ what this exercise has taught me, other than that I have a tendency to reach\
    \ for a for loop\nwhen I could use an algorithm function such as `reduce` or `fold`.\n\
    That's something to keep in mind for future programming problems, I guess.\n\n\
    I've also decided to leave the indentation of the code examples as is.\nAs I mentioned\
    \ earlier, I've never really gotten the hang of identation, so the indentation\
    \ in my code examples is\nas the editor has automatically formatted it, which\
    \ means that it's not necessarily the most readable style.\nI may go back and\
    \ fix that one day, but for now it is what it is.\n\nOne last note: if you think\
    \ my solutions are bad and you want to show me how to do it right,\nI'd be very\
    \ open to criticism and feedback.\nJust send me an email or create an issue on\
    \ GitHub.", "  (define (smallest-index arr)\n    (apply min (map (\u03BB (i x)\
    \ (+ i 1)) (range arr))))\n  (define (find-evens arr)\n    (filter even? arr))\n\
    \  (define (special-reduce func value arr)\n    (for/fold ([acc '(-1 -1)])\n \
    \             ([i arr])\n              (if (func (cadr acc) i)\n             \
    \     (list (car acc) i)\n                  acc)))\n  (cond [(empty? arr) '(-1\
    \ -1)]\n        [(empty? (find-evens arr)) '(-1 -1)]\n        [else (special-reduce\
    \ min (cadr (special-reduce max 0 arr)) (find-evens arr))]))\n", "  (cond [(empty?\
    \ arr) []]\n        [(even? (first arr)) (pluck-even (first arr) (rest arr) 0)]\n\
    \        [else (pluck (rest arr))]))\n", "  (for/first ((x (in-list arr)))\n \
    \   (when (even? x) x)))", "  (let loop ([smallest-index -1] [smallest-value '()]\
    \ [index 0])\n    (cond [(empty? arr) '()]\n          [(not (even? (first arr)))\
    \ (loop smallest-index smallest-value (add1 index))]\n          [(number? smallest-value)\
    \ (if (< (first arr) smallest-value)\n                                       \
    \ (loop index (first arr) (add1 index))\n                                    \
    \    (loop smallest-index smallest-value (add1 index)))]\n          [else (loop\
    \ index (first arr) (add1 index))])))\n", "  (let ([evens (for/list ([x arr] #:when\
    \ (even? x)) x)])\n    (if (empty? evens)\n        '()\n        (for/fold ([result\
    \ 0] [index -1]) ([x evens] [i (in-naturals)])\n          (cond [(= (min result\
    \ x) x) (values x i)]\n                [else (values result index)])))))\n", " \
    \ (for/fold ([min-index #f]\n             [min-value #f])\n    ([index value]\n\
    \     (cond\n       [(or (= min-index #f)\n            (and (even? value)\n  \
    \               (< value min-value)))\n        (values index value)]\n       [else\
    \ (values min-index min-value)]))\n    arr))\n", "  (cond\n    [(null? arr) empty]\n\
    \    [(even? (car arr)) [arr 0]\n    [(pluck (cdr arr) [arr (+ 1 (cdr arr))]))]\n\
    \    )\n  )\n", "  (let* ([evens (filter even? arr)]\n         [smallest (if (empty?\
    \ evens) -1 (apply min evens))])\n    (if (= smallest -1)\n        empty\n   \
    \     (let* ([idx (find-smallest-index smallest arr)]\n               [result\
    \ (list smallest idx)])\n          result))))\n", "  (match arr\n    ['() '()]\n\
    \    [(cons x xs)\n     (if (zero? (modulo x 2))\n         (if (and (not (empty?\
    \ xs)) (not (zero? (modulo (car xs) 2))))\n             (cons x (range 1 (add1\
    \ (length arr))))\n             (cons x (range 0 (length arr))))\n         (pluck\
    \ xs))]))\n", "  (let ((index (index-of-min-even arr))\n        (value (min-even\
    \ arr)))\n    (cond ((or (negative? index) (negative? value)) '())\n         \
    \ (else (list value index)))))\n", "  (if (empty? arr) '()\n      (let ([evens\
    \ (filter (\u03BB (x) (even? x)) arr)])\n        (if (empty? evens) '()\n    \
    \        (let ([min-even (apply min evens)])\n              (if (empty? min-even)\
    \ '()\n                  (let ([index (index-of min-even arr)])\n            \
    \        (list min-even index))))))))\n", "  (if (or (null? arr) (null? (even?\
    \ (car arr)))) (list)\n    (let ((sm-even (min-even arr)))\n      (list sm-even\
    \ (count-evens (sm-even 0 arr))))))\n", "  (cond\n    [(empty? arr) []]\n    [(even?\
    \ (first arr))\n     (apply min (for/list ([i (in-range (length arr))])\n    \
    \               (list (first arr) i)))\n     ]\n    [else (pluck (rest arr))]))\n\
    </code>\n", "  (if (empty? arr)\n      '()\n      (let* ([evens (filter even?\
    \ arr)]\n             [min-even (min evens)])\n        (if (empty? evens)\n  \
    \          '()\n            (list min-even (index arr min-even))))))\n```\n\n\
    ## 2020-04-24\n\n### Algorithm\n\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)\n\
    \nGiven a string, return the number of possible permutations of the string.\n\n\
    ```racket\n#lang racket\n", "  (define even-nodes (filter even? arr))\n  (define\
    \ smallest-even (min even-nodes))\n  (define idx (list-index smallest-even arr))\n\
    \  (if (empty? arr)\n      '()\n      (list smallest-even idx)))\n</code>\n",
  "  (if (empty? arr)\n      '()\n      (define match\n        (find\n          (lambda\
    \ (element)\n            (even? element))\n          arr))\n      (if match\n\
    \          (list match (index arr match))\n          '())))\n", "  (let*\n   \
    \   ((smallest-even\n        (apply min\n          (filter even? arr)))\n    \
    \   (smallest-index\n        (first\n          (filter\n            (lambda (x)\n\
    \              (= (nth x arr) smallest-even))\n            (iota (length arr)))))\n\
    \       (return-arr (list smallest-even smallest-index)))\n    (if (= smallest-even\
    \ +inf.0)\n        (list)\n        return-arr)))\n", "  (for/fold ([smallest-even\
    \ #f] [index #f]) ([node (in-list arr)])\n    (if (and (even? node) (< node smallest-even))\n\
    \        (values node index)\n        (values smallest-even index))))\n", "  (match\
    \ arr\n    [(list) empty]\n    [(list n) (match (even? n)\n                  \
    \   [(#t) (list n 0)]\n                     [(#f) empty])]\n    [(cons n arr)\
    \ (match (even? n)\n                        [(#t) (cond [(< n (first (pluck arr)))\
    \ (list n 0)]\n                                    [(= n (first (pluck arr)))\
    \ (cons n (pluck arr))])]\n                        [(#f) (pluck arr)])]))\n\n\n\
    ```\n### Test Cases\n\n```racket", "  (cond [(empty? arr) '()]\n        [(even?\
    \ (first arr)) (pluck-even arr #f 1)]\n        [else (pluck-odd arr)]))\n", " \
    \ (define (get-evens arr)\n    (filter odd? arr))\n  (define (get-smallest-even\
    \ lst)\n    (apply min (get-evens lst)))\n  (define (get-index lst key)\n    (define\
    \ (inner lst i acc)\n      (cond\n        [(empty? lst) acc]\n        [(equal?\
    \ (first lst) key) acc]\n        [else (inner (rest lst) (add1 i) (add1 acc))]))\n\
    \    (inner lst 0 0))\n  (cond\n    [(empty? arr) (list)]\n    [(empty? (get-evens\
    \ arr)) (list)]\n    [else (list (get-smallest-even arr) (get-index arr (get-smallest-even\
    \ arr)))]))\n", "  (if (null? arr)\n      '()\n      (let* ((even-values (filter\
    \ even? arr))\n             (min-even (if (null? even-values)\n              \
    \             -1\n                           (apply min even-values))))\n    \
    \    (if (= min-even -1)\n            '()\n            (let ((min-pos (find-min-pos\
    \ min-even arr 0)))\n              (list min-even min-pos))))))\n", "  (let loop\
    \ ([i 0] [min 0] [min-index 0])\n    (if (and (zero? (modulo (vector-ref arr i)\
    \ 2))\n             (or (not min)\n                 (&lt; (vector-ref arr i) min)))\n\
    \        (loop (+ i 1) (vector-ref arr i) i)\n        (if (&lt; i (vector-length\
    \ arr))\n            (loop (+ i 1) min min-index)\n            (if (zero? min)\n\
    \                '()\n                (list min min-index))))))\n", "  (cond [(null?\
    \ arr) '()]\n        [(even? (car arr))\n         (let* ([target (car arr)]\n\
    \                [index (find-index target arr 0)])\n           (list target index))]\n\
    \        [else (pluck (cdr arr))]))\n", "  (match arr\n    [() []]\n    [(list\
    \ e) [e 0]]\n    [(cons e1 (cons e2 rest))\n     (match (pluck (cons e2 rest))\n\
    \       [(list e r)\n        (if (and (even? e1) (even? e))\n            (if (<\
    \ e1 e) (list e1 0) (list e r))\n          (if (even? e1) (list e1 0) (list e\
    \ r)))]\n       [_\n        (if (even? e1) (list e1 0) (list e2 1))])]))\n", " \
    \ (cond\n    [(null? arr) '()]\n    [(not (even? (car arr))) (pluck (cdr arr))]\n\
    \    [(null? (cdr arr)) (cons (car arr) 1)]\n    [(even? (car arr))\n     (let\
    \ ((smallest (car arr))\n           (cur-val (car arr))\n           (rest (cdr\
    \ arr))\n           (index 2))\n       (cond\n         [(null? rest) (cons smallest\
    \ 1)]\n         [(even? (car rest))\n          (let ([cur-val (car rest)])\n \
    \           (set! rest (cdr rest))\n            (set! index (+ index 1))\n   \
    \         [(< cur-val smallest)\n             (set! smallest cur-val)\n      \
    \       (pluck rest)]\n            [else\n             (pluck rest)]))]\n    \
    \     [else\n          (set! rest (cdr rest))\n          (set! index (+ index\
    \ 1))\n          (pluck rest)]))]))\n", "  (define len (vector-length arr))\n\
    \  (if (zero? len)\n      '()\n      (define min-even (vector-ref arr 0))\n  \
    \    (define min-index 0)\n      (define i 1)\n      (for ([i (in-range len)])\n\
    \        (let ([val (vector-ref arr i)])\n          (when (and (even? val)\n \
    \                    (or (zero? min-even)\n                         (< val min-even)))\n\
    \            (set! min-even val)\n            (set! min-index i))))\n      (if\
    \ (zero? min-even)\n          '()\n          (list min-even min-index))))\n```\n\
    \n## The Blacklist\n\n```scheme\n#lang racket\n", "  (cond\n    [(empty? arr)\
    \ '()]\n    [(null? (even? (car arr))) (pluck (cdr arr))]\n    [(and (empty? (cdr\
    \ arr)) (even? (car arr))) (list (car arr) 0)]\n    [(even? (car arr))\n     (let*\
    \ ([second-pluck (pluck (cdr arr))]\n            [second-pluck-index (if (empty?\
    \ second-pluck) '() (car second-pluck))]\n            [second-pluck-value (if\
    \ (empty? second-pluck) '() (cadr second-pluck))])\n       (cond\n         [(and\
    \ (empty? second-pluck) (even? (car arr))) (list (car arr) 0)]\n         [(and\
    \ (empty? second-pluck) (not (even? (car arr)))) '()]\n         [(and (empty?\
    \ second-pluck) (even? (car arr))) (list (car arr) 0)]\n         [(and (not (empty?\
    \ second-pluck)) (< (car arr) second-pluck-value)) (list (car arr) 0)]\n     \
    \    [(and (not (empty? second-pluck)) (> (car arr) second-pluck-value)) (list\
    \ second-pluck-value second-pluck-index)]\n         [(and (not (empty? second-pluck))\
    \ (= (car arr) second-pluck-value)) (list (car arr) 0)]))]\n    [else (pluck (cdr\
    \ arr))]))\n", "  (cond [(empty? arr) empty]\n        [(< 0 (list-ref arr 0))\
    \ empty]\n        [(= (list-ref arr 0) 0) (list 0 0)]\n        [(even? (list-ref\
    \ arr 0)) (list (list-ref arr 0) 0)]\n        [else (define result (pluck (cdr\
    \ arr)))\n              (cond [(empty? result) empty]\n                    [(even?\
    \ (list-ref arr 0)) (if (< (list-ref result 0) (list-ref arr 0)) result (list\
    \ (list-ref arr 0) 0))]\n                    [else result])]))\n", "  (match arr\n\
    \    [(list 0)\n     (list 0 0)]\n    [(list 0)\n     (list 0 0)]\n    [(list\
    \ num)\n     (if (even? num)\n         (list num 0)\n         (list))]\n    [(list\
    \ _ num)\n     (cond\n       [(even? num)\n        (list num 1)]\n       [else\n\
    \        (list)])]\n    [(list _ _ num)\n     (cond\n       [(even? num)\n   \
    \     (list num 2)]\n       [else\n        (list)])]\n    [(list num1 num2 num3)\n\
    \     (cond\n       [(even? num1)\n        (list num1 0)]\n       [(even? num2)\n\
    \        (list num2 1)]\n       [(even? num3)\n        (list num3 2)]\n      \
    \ [else\n        (list)])]\n    [(list num1 num2 num3 rest ...)\n     (let ([plucked\
    \ (pluck (list num2 num3 rest ...))])\n       (cond\n         [(and (not (empty?\
    \ plucked))\n               (< num1 (first plucked)))\n          plucked]\n  \
    \       [(and (not (empty? plucked))\n               (= num1 (first plucked)))\n\
    \          (list num1 0)]\n         [(even? num1)\n          (list num1 0)]\n\
    \         [else\n          (list)]))]))\n", "  (cond\n    [(empty? arr) '()]\n\
    \    [(zero? (modulo (first arr) 2))\n     (for/fold ([m (first arr)]) ([n (in-list\
    \ (rest arr))])\n       (if (and (zero? (modulo n 2))\n                (< m n))\n\
    \           n\n           m))]\n    [else (pluck (rest arr))]))\n", "  (if (null?\
    \ arr)\n      '()\n      (let ((min-even (min-even arr)))\n        (if min-even\n\
    \            (list min-even (index-of arr min-even))\n            '()))))\n",
  "  (match arr\n    [(list)\n     (list)]\n    [(cons hd tl)\n     (cond\n      \
    \ [(and (zero? (remainder hd 2))\n             (not (null? tl)))\n        (let\
    \ ([rest (pluck tl)])\n          (if (not (null? rest))\n              (if (&lt;\
    \ hd (car rest))\n                  (list hd 0)\n                  (list (car\
    \ rest) (+ 1 (cadr rest))))\n              (list hd 0)))]\n       [(zero? (remainder\
    \ hd 2))\n        (list hd 0)]\n       [else\n        (pluck tl)])]))\n", "  (if\
    \ (empty? arr)\n      '()\n      (if (zero? (remainder (car arr) 2))\n       \
    \   (apply min (flatten arr))\n          (pluck (cdr arr)))))\n", "  (define (find-even-index\
    \ acc idx xs)\n    (cond [(null? xs) (begin acc)]\n          [(odd? (car xs))\
    \ (find-even-index acc (+ idx 1) (cdr xs))]\n          [(and (> acc -1)\n    \
    \            (< (car xs) (list-ref arr acc)))\n           (find-even-index idx\
    \ (+ idx 1) (cdr xs))]\n          [else (find-even-index idx (+ idx 1) (cdr xs))]))\n\
    \  (define (any-even? xs)\n    (cond [(null? xs) #f]\n          [(odd? (car xs))\
    \ (any-even? (cdr xs))]\n          [else #t]))\n  (cond [(null? arr) '()]\n  \
    \      [(any-even? arr) (list (list-ref arr (find-even-index -1 0 arr)) (find-even-index\
    \ -1 0 arr))]\n        [else '()]))\n", "    (define (get-evens arr)\n       \
    \ (filter even? arr))\n    (define (get-smallest arr)\n        (apply min arr))\n\
    \    (define (get-smallest-even arr)\n        (get-smallest (get-evens arr)))\n\
    \    (define (get-smallest-even-index arr)\n        (define (find-index value\
    \ arr)\n            (if (equal? value (first arr))\n                0\n      \
    \          (+ 1 (find-index value (rest arr)))))\n        (find-index (get-smallest-even\
    \ arr) arr))\n    (if (empty? arr)\n        '()\n        (list (get-smallest-even\
    \ arr) (get-smallest-even-index arr))))\n```\n\n**Examples**\n```racket", "  (cond\n\
    \    [(empty? arr) '()]\n    [(= (modulo (car arr) 2) 0) (list (car arr) 0)]\n\
    \    [(pluck (cdr arr)) => (lambda (res)\n                            (and (equal?\
    \ (car res) 1)\n                                 (list (car res) 1)))]\n    [else\
    \ (pluck (cdr arr))]))\n", "  (let* ((evens (filter even? arr))\n         (smallest\
    \ (if (empty? evens)\n                       0\n                       (apply\
    \ min evens))))\n    (list smallest (pos smallest arr))))\n", "  (cond [(null?\
    \ arr) (list)]\n        [(equal? (modulo (first arr) 2) 0)\n         (if (every?\
    \ (lambda (x) (negative? (modulo x 2))) (rest arr))\n             (list (first\
    \ arr) 0)\n             (let ((smallest (list (first arr) 0))\n              \
    \     (next-smallest (pluck (rest arr))))\n               (if (> (first smallest)\
    \ (first next-smallest))\n                   next-smallest\n                 \
    \  smallest)))]\n        [else (pluck (rest arr))]))\n\n", "  (if (not (null?\
    \ arr))\n      (let* ([even-values (filter even? arr)]\n             [value (apply\
    \ min even-values)]\n             [index (index-of arr value)])\n        (list\
    \ value index))\n      (list)))\n", "  (if (empty? arr)\n      '()\n      (let*\
    \ ((l1 (cond [(even? (first arr)) (list (first arr) 0)]\n                    \
    \   [else '()]))\n             (l2 (pluck (rest arr)))\n             (res (cond\
    \ [(empty? l1) l2]\n                        [(empty? l2) l1]\n               \
    \         [(< (first l1) (first l2)) l1]\n                        [(> (first l1)\
    \ (first l2)) l2]\n                        [else (cond [(< (second l1) (second\
    \ l2)) l1]\n                                    [else l2])])))\n        (if (empty?\
    \ res)\n            '()\n            (list (+ (second res) 1) (first res))))))\n\
    ```\n\n* [Shell Sort](https://en.wikipedia.org/wiki/Shellsort)\n\n``` #lang racket\n",
  "  (if (empty? arr)\n      '()\n      (cond\n        [(even? (car arr)) (list (car\
    \ arr) 0)]\n        [else (let* ([sm (find-smallest-even arr)]\n             \
    \        [i (index arr (car sm))])\n                (list (car sm) i))])))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(even? (first arr)) (list (first arr) 0)]\n\
    \    [else\n     (let ([branch (pluck (rest arr))])\n       (cond\n         [(empty?\
    \ branch)\n          (list (first arr) 1)]\n         [(equal? (first branch) (first\
    \ arr))\n          (list (first arr) 1)]\n         [(= (first branch) (first arr))\n\
    \          (list (first arr) (+ 1 (second branch)))]\n         [else\n       \
    \   branch]))]))\n", "  (cond [(empty? arr) empty]\n        [(odd? (first arr))\
    \ (pluck (rest arr))]\n        [(empty? (rest arr)) (list (first arr) 0)]\n  \
    \      [else (let ([smaller-even (first (rest arr))])\n                (define\
    \ (iter i a)\n                  (cond [(empty? a) (list smaller-even (sub1 i))]\n\
    \                        [(even? (first a)) (list (first a) i)]\n            \
    \            [else (iter (add1 i) (rest a))]))\n                (iter 1 (rest\
    \ arr)))]))\n", "  (cond [(empty? arr) '()]\n        [(zero? (remainder (first\
    \ arr) 2))\n         (list (first arr) (zero? (modulo (last arr) 2)))]\n     \
    \   [else (pluck (rest arr))]))\n", "  (let* ([evens (for/list ([node arr] #:when\
    \ (even? node)) node)]\n         [sm (apply min evens)])\n    (for/list ([node\
    \ arr] #:when (equal? node sm)) node)))\n", "  (let* ([even-indices (for/list\
    \ ([node arr]\n                                  #:when (even? node))\n      \
    \                    (current-inexact-milliseconds))]\n         [min-even-idx\
    \ (apply min even-indices)])\n    (when min-even-idx\n      (for/first ([node\
    \ arr]\n                  #:when (and (even? node)\n                         \
    \     (= (current-inexact-milliseconds) min-even-idx)))\n        (list node (list-ref\
    \ arr node))))))\n", "  (if (empty? arr)\n      (list)\n      (let ((even-values\
    \ (filter even? arr)))\n        (if (empty? even-values)\n            (list)\n\
    \            (let ((min-even-value (apply min even-values)))\n              (list\
    \ min-even-value (index-of min-even-value arr)))))))\n```\n\n#### Run tests\n\
    ```\nraco test pluck.rkt\n```\n\n#### Run tests with code coverage\n```\nraco\
    \ test --cover-code pluck.rkt\n```\n\n#### See [solution.rkt](solution.rkt)",
  "  (cond [(empty? arr) empty]\n        [(odd? (first arr)) (pluck (rest arr))]\n\
    \        [(even? (first arr)) (first arr)]))\n", "  (cond [(empty? arr) '()]\n\
    \        [(null? (filter even? arr)) '()]\n        [else (filter even? arr)]))\n",
  "  (let loop ([remaining arr] [sofar '()])\n    (cond\n      [(and (empty? remaining)\
    \ (empty? sofar)) '()]\n      [(empty? remaining) (list (apply min sofar) (index-of\
    \ sofar (apply min sofar)))]\n      [(even? (first remaining)) (loop (rest remaining)\
    \ (cons (first remaining) sofar))]\n      [else (loop (rest remaining) sofar)])))\n\
    </code>\nAlternative implementations\n<code>#lang racket\n", "  (if (null? arr)\n\
    \      arr\n      (let* ([smallest-even (min (filter even? arr))]\n          \
    \   [index (list-index arr smallest-even)])\n        (if (not (positive? index))\n\
    \            arr\n            (list smallest-even index)))))\n", "  (if (null?\
    \ arr)\n      '()\n      (let ([candidates (list->stream (filter even? arr))])\n\
    \        (if (null? candidates)\n            '()\n            (list (stream-first\
    \ candidates)\n                  (index-of arr (stream-first candidates)))))))\n",
  "  (if (equal? arr '())\n      (list)\n      (let loop ([evens '()] [idx 0])\n \
    \       (cond\n          [(empty? arr) (get-min-even evens idx)]\n          [(even?\
    \ (first arr)) (loop (cons (cons (first arr) idx) evens) (+ idx 1))]\n       \
    \   [else (loop evens (+ idx 1))]))))\n", "  (match arr\n    [(cons v (cons _\
    \ _)) (define even? (lambda (n) (= (remainder n 2) 0)))\n                    \
    \     (define get-evens (lambda (xs) (match xs [(cons x xs) (if (even? x) (cons\
    \ x (get-evens xs)) (get-evens xs))]\n                                       \
    \                      [])))\n                         (define min-even (min (get-evens\
    \ arr)))\n                         (define get-index (lambda (xs i) (match xs\
    \ [(cons x xs) (if (= x min-even) i (get-index xs (+ i 1)))]\n               \
    \                                                [])))\n                     \
    \    (if (even? v) (cons min-even (get-index arr 0))\n                       \
    \      (cons min-even (get-index (cdr arr) 1))))\n    [_ (list)]))\n", "  (if\
    \ (empty? arr)\n      '()\n      (let ([min (for/fold ([best '()]) ([i (in-range\
    \ (length arr))])\n                  (if (and (even? (vector-ref arr i))\n   \
    \                        (or (null? best)\n                               (< (vector-ref\
    \ arr i) (car best))))\n                      (vector (vector-ref arr i) i)\n\
    \                      best))])\n        (if (null? min)\n            '()\n  \
    \          min))))\n", "  (define arr-but-one (map number->string arr))\n  (define\
    \ arr-but-two (for/list ([e (in-list arr-but-one)])\n                        \
    \ (string-append e \" \")))\n  (define (make-list input)\n    (if (null? input)\n\
    \        '()\n        (cons (first input) (make-list (rest input)))))\n  (define\
    \ final-arr (make-list arr-but-two))\n  (define smallest-value (if (null? (filter\
    \ even? arr))\n                             '()\n                            \
    \ (vector-ref arr\n                                         (let ([smallest-index\
    \ (vector-min\n                                                              \
    \  (vector-filter\n                                                          \
    \       even?\n                                                              \
    \   arr))])\n                                           (for/fold ([indice 0])\n\
    \                                                     ([a arr])\n            \
    \                                         (if (= a smallest-index)\n         \
    \                                                indice\n                    \
    \                                     (add1 indice)))))))\n  (if (null? smallest-value)\n\
    \      '()\n      (cons smallest-value\n            (vector-min\n            \
    \ (vector-filter\n              (lambda (x) (= x smallest-value))\n          \
    \    arr)))))\n", "  (let/cc even?\n    (for/fold ([even #f] [result (vector \"\
    none\" #f)]) ([i arr])\n      (when (even? i)\n        (if (not even)\n      \
    \      (begin\n              (set! even #t)\n              (set! result (vector\
    \ i (i+1))))\n            (when (< i (vector-ref result 0))\n              (set!\
    \ result (vector i (i+1))))))\n      result)\n    (if (not even?)\n        '()\n\
    \        (vector (vector-ref result 0) (vector-ref result 1)))))\n", "  (define\
    \ evens (filter even? arr))\n  (cond ((null? evens) '())\n        ((empty? arr)\
    \ '())\n        (else (let ((smallest (for/min ([x evens]) (values x (index-of\
    \ x arr)))))\n                (list (car smallest) (cadr smallest))))))\n", " \
    \ (if (null? arr)\n      '()\n      (let* ([even-values (filter even? arr)]\n\
    \             [min-even-value (apply min even-values)]\n             [index (index-of\
    \ min-even-value arr)])\n        (cond\n         [(null? even-values) '()]\n \
    \        [else (list min-even-value index)]))))\n", "  (if (null? arr)\n     \
    \ '()\n      (let* ([evens (filter even? arr)]\n             [min-even (reduce\
    \ min evens)])\n        (if (null? evens)\n            '()\n            (let*\
    \ ([even-idx (find-idx (\u03BB (x) (= x min-even)) arr)]\n                   [r\
    \ (cond [(= (remainder even-idx 1) 0) (quotient even-idx 1)]\n               \
    \             [else (quotient (+ even-idx 1) 1)])])\n              (list min-even\
    \ r))))))\n", "  (match arr\n    [(cons node nl)\n     (define min-even-value\
    \ -1)\n     (define min-even-node #f)\n     (define nl-even-nodes (pluck nl))\n\
    \     (if (number? node)\n         (if (even? node)\n             (if (> node\
    \ min-even-value)\n                 (set! min-even-value node)\n             \
    \    (set! min-even-node (cons node (length arr))))\n             (if (list? nl-even-nodes)\n\
    \                 (if (< (first nl-even-nodes) min-even-value)\n             \
    \        (set! min-even-value (first nl-even-nodes))\n                     (set!\
    \ min-even-node (cons (first nl-even-nodes) (second nl-even-nodes))))))\n    \
    \     (if (list? nl-even-nodes)\n             (set! min-even-node nl-even-nodes))\n\
    \         min-even-node)]\n    [_ '()]))\n", "  (let loop ([idx (in-naturals)]\n\
    \             [collect []])\n    (cond [(empty? arr) (values (reverse collect)\
    \ idx)]\n          [(pair? (car arr))\n           (let-values ([(val idx) (loop\
    \ idx collect)])\n             (loop (add1 idx) val))]\n          [(even? (car\
    \ arr))\n           (loop (add1 idx) (cons (list (car arr) idx) collect))]\n \
    \         [else (loop (add1 idx) collect)])))\n", "  (let loop ([arr arr] [evens\
    \ '()])\n    (cond [(null? arr) (loop evens '())]\n          [(number? (car arr))\
    \ (if (even? (car arr))\n                                   (loop arr (cons (car\
    \ arr) evens))\n                                   (loop arr evens))]\n      \
    \    [(list? (car arr)) (loop (append (car arr) (cdr arr)) evens)]\n         \
    \ [else (loop (cdr arr) evens)])))\n", "  (if (null? arr)\n      '()\n      (let*\
    \ ([i (for/first ([x (in-list arr)])\n                          (when (even? x)\
    \ x))]\n             [ii (if i (for/first ([x (in-list arr)]\n               \
    \                    [n (in-range (length arr))])\n                          \
    \   (when (= x i) n)))])\n        (if i\n            (list i ii)\n           \
    \ '()))))\n", "  (if (empty? arr)\n      (list)\n      (if (every odd? arr)\n\
    \          (list)\n          (let loop ([arr arr] [idx 0] [min-even 0] [min-idx\
    \ 0])\n            (if (null? arr)\n                (list min-even min-idx)\n\
    \                (if (and (zero? (modulo (car arr) 2)) (< (car arr) min-even))\n\
    \                    (loop (cdr arr) (+ idx 1) (car arr) idx)\n              \
    \      (loop (cdr arr) (+ idx 1) min-even min-idx)))))))\n", "  (match arr\n \
    \   [(cons hd (cons _ _))\n     (list (list-ref arr (smallest-index-even arr))\
    \ (smallest-index-even arr))]\n    [_ '()]))\n", "  (if (empty? arr)\n      '()\n\
    \      (define evens (filter even? arr))\n      (if (empty? evens)\n         \
    \ '()\n          (let* ([smallest-value (apply min evens)]\n                 [smallest-index\
    \ (index (member smallest-value arr) arr)])\n            (list smallest-value\
    \ smallest-index)))))\n", "  (if (empty? arr) (list)\n    (let loop ([xs arr]\
    \ [min-value #f] [min-index #f])\n      (cond [(empty? xs) (list min-value min-index)]\n\
    \            [(and (even? (first xs)) (or (not min-value) (< (first xs) min-value)))\n\
    \             (loop (rest xs) (first xs) (pos xs arr))]\n            [else (loop\
    \ (rest xs) min-value min-index)]))))\n", "  (if (zero? (length arr))\n      '()\n\
    \      (letrec ([even-vals (filter even? arr)]\n               [smallest-even\
    \ (apply min even-vals)]\n               [smallest-index (index arr smallest-even)])\n\
    \        (list smallest-even smallest-index))))\n", "  (if (empty? arr) '()\n\
    \      (let loop ((a arr) (m (max-length arr)) (c 0) (minv -1) (mini -1))\n  \
    \      (cond [(= c m) (if (= minv -1) '() (list minv mini))]\n              [(=\
    \ (remainder (vector-ref a c) 2) 0) (if (and (= minv -1) (> (vector-ref a c) 0))\n\
    \                                                       (loop a m (+ c 1) (vector-ref\
    \ a c) c)\n                                                       (if (< (vector-ref\
    \ a c) minv)\n                                                           (loop\
    \ a m (+ c 1) (vector-ref a c) c)\n                                          \
    \                 (loop a m (+ c 1) minv mini)))]\n              [else (loop a\
    \ m (+ c 1) minv mini)])\n        )\n      )\n  )\n", "  (if\n    (or (empty?\
    \ arr) (empty? (filter even? arr)))\n    '()\n    (list (min (filter even? arr))\
    \ (index-of (min (filter even? arr)) arr))))\n</code>\n", "  (define evens (filter\
    \ even? arr))\n  (if (empty? evens)\n      '()\n      (list (min evens) (index-of\
    \ (min evens) arr))))\n", "  (let loop ([arr arr] [sarr empty] [result empty])\n\
    \    (cond [(empty? arr) (cond [(empty? sarr) result]\n                      \
    \        [else (let ([smallest (car sarr)])\n                                \
    \      (loop empty empty (vector smallest (list-ref arr (index-of arr smallest)))))]\n\
    \                              )]\n          [(= 0 (modulo (car arr) 2)) (loop\
    \ (cdr arr) (list (car arr)) result)]\n          [else (loop (cdr arr) sarr result)])))\n\
    ```\n\n###### Haskell\n\n```haskell\nmodule Pluck where\nimport Data.List\nimport\
    \ Test.QuickCheck\n\n-- Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n-- your task is to pluck one of the nodes and return\
    \ it.\n-- The plucked node should be the node with the smallest even value.\n\
    -- If multiple nodes with the same smallest even value are found return the node\
    \ that has smallest index.\n-- The plucked node should be returned in a list,\
    \ [ smalest_value, its index ],\n-- If there are no even values or the given array\
    \ is empty, return [].\n-- Constraints:\n-- * 1 <= nodes.length <= 10000\n-- *\
    \ 0 <= node.value\n\npluck :: [Int] -> [Int]\npluck [] = []\npluck xs = let evens\
    \ = filter even xs\n               evens' = if evens == [] then [9999999999] else\
    \ evens\n               smallestEven = minimum evens'\n           in [smallestEven,\
    \ minimum [n | (n,m) <- zip [0..] xs, m == smallestEven]]\n\nmain = quickCheck\
    \ $\n  forAll (listOf1 arbitrarySizedIntegral) $ \\xs ->\n    pluck xs /= []\n\
    ```\n\n###### Clojure\n\n```clojure", "  (if (and (not (zero? (length arr)))\n\
    \           (or (zero? (modulo (list-ref arr 0) 2))\n               (exists even?\
    \ arr)))\n      (let loop ([i 0] [even-i #f] [min-even #f])\n        (if (= i\
    \ (length arr))\n            (if (not (zero? (modulo (list-ref arr 0) 2)))\n \
    \               '(0 0)\n                (list min-even even-i))\n            (if\
    \ (and (not (zero? (modulo (list-ref arr i) 2)))\n                     (or (zero?\
    \ min-even)\n                         (not (even? min-even))))\n             \
    \   (loop (+ i 1) #f min-even)\n                (if (and (even? (list-ref arr\
    \ i))\n                         (or (not (even? min-even))\n                 \
    \            (< (list-ref arr i) min-even)))\n                    (loop (+ i 1)\
    \ i (list-ref arr i))\n                    (loop (+ i 1) even-i min-even))))))\n\
    \      '()))\n", "  (cond [(null? arr) '()]\n        [(empty? arr) '()]\n    \
    \    [(empty? (even-nodes arr)) '()]\n        [else (if (even? (first arr))\n\
    \                  (min-by second (even-nodes arr))\n                  (pluck\
    \ (rest arr)))]))\n", "  (define evens-with-indexes\n    (filter (lambda (index-value)\n\
    \              (let ([value (second index-value)])\n                (even? value)))\n\
    \            (enumerate arr)))\n  (if (empty? evens-with-indexes)\n      '()\n\
    \      (let* ([min-even-with-index\n              (reduce\n               (lambda\
    \ (x y)\n                 (if (< (second x) (second y))\n                    \
    \ x\n                     y))\n               evens-with-indexes)]\n         \
    \    [min-even-value _] min-even-with-index)\n        [min-even-value min-even-with-index])))\n",
  "  (if (null? arr) '()\n      (let ((evens (filter (\u03BB (x) (zero? (modulo x\
    \ 2))) arr)))\n        (if (null? evens) '()\n            (let ((min (foldr min\
    \ (first evens) evens)))\n              (list min (index-of min arr)))))))\n",
  "  (define (run idx r l)\n    (if (zero? idx) l\n      (if (or (even? (car r)) (not\
    \ (equal? l [])))\n          (run (- idx 1) (cdr r) (if (or (equal? l []) (not\
    \ (even? (car r)))) (list (car r) idx) l))\n          (run (- idx 1) (cdr r) l))))\n\
    \  (run (length arr) arr []))\n", "  (filter even? arr))\n", "  (cond\n    [(empty?\
    \ arr) '()]\n    [(= 1 (length arr))\n     (if (even? (first arr))\n         (list\
    \ (first arr) 0)\n         '())]\n    [else\n     (let* ([evens (remove (compose\
    \ odd? first) arr)]\n            [index? (compose equal? (first evens))]\n   \
    \         [index (for/first ([pair (in-naturals)])\n                     (when\
    \ (index? pair)\n                       (second pair)))])\n       (list (first\
    \ evens) index))]))\n", "  (if (not (null? arr))\n      (let* ([arr-even (list-head\
    \ (list-filter (\u03BB (val) (even? val)) arr))]\n             [arr-even-index\
    \ (index-of arr-even arr)])\n        (if (not arr-even)\n            '()\n   \
    \         (list arr-even arr-even-index)))\n      '()))\n", "  (if (null? arr)\n\
    \      '()\n      (let* ([arr (filter even? arr)]\n             [smallest-even\
    \ (apply min arr)]\n             [index (index-of smallest-even arr)])\n     \
    \   (if (null? index)\n            '()\n            (list smallest-even index)))))\n",
  "  (if (empty? arr)\n      (list)\n      (let ([evens (for/list ([e arr]\n     \
    \                         #:when (even? e))\n                       e)])\n   \
    \     (if (empty? evens)\n            (list)\n            (let ([sorted-evens\
    \ (sort < evens)])\n              (list (first sorted-evens)\n               \
    \     (argmin (lambda (i)\n                              (list-ref arr i))\n \
    \                           (build-list (length arr) id))))))))\n```\n\n## Credit\n\
    \nThis problem was taken from the [Daily Coding Problem](https://www.dailycodingproblem.com/)",
  "  (cond\n    [(empty? arr) '()]\n    [(not (even? (first arr))) (pluck (rest arr))]\n\
    \    [(and (empty? (rest arr)) (even? (first arr))) (list (first arr) 0)]\n  \
    \  [(even? (first arr))\n     (let* ([r (rest arr)]\n            [rp (pluck r)]\n\
    \            [rv (first rp)]\n            [idx (add1 (second rp))])\n       (cond\n\
    \         [(empty? rp) (list (first arr) 0)]\n         [(= (first arr) rv) (list\
    \ (first arr) 0)]\n         [(< (first arr) rv) (list (first arr) 0)]\n      \
    \   [else (list rv idx)]))]))\n", "  (match arr\n    [(list) (list)]\n    [(cons\
    \ x xs)\n     (if (not (even? x))\n         (pluck xs)\n         (let ((plucked-rest\
    \ (pluck xs)))\n           (if (or (empty? plucked-rest) (&lt; x (first plucked-rest)))\n\
    \               (list x 0)\n               (list (first plucked-rest) (+ 1 (second\
    \ plucked-rest))))))]))\n", "  (define arr-no-zero\n    (filter\n      (lambda\
    \ (x)\n        (not (zero? x)))\n      arr))\n  (define arr-even\n    (filter\n\
    \      (lambda (x)\n        (not (odd? x)))\n      arr-no-zero))\n  (define arr-min\n\
    \    (if (not (null? arr-even))\n      (apply min arr-even)\n      #f))\n  (if\
    \ arr-min\n    (let ([index (find arr-min arr)])\n      (list arr-min index))\n\
    \    '()))\n", "  (match arr\n    [() '()]\n    [(cons x xs)\n     (cond [(= (modulo\
    \ x 2) 0)\n            (if (null? (filter (lambda (y) (= (modulo y 2) 0)) xs))\n\
    \                (cons x (range 1 (add1 (length arr))))\n                (match\
    \ (filter (lambda (y) (= (modulo y 2) 0)) xs)\n                  [(cons y ys)\n\
    \                   (if (> x y)\n                       (cons x (range 1 (add1\
    \ (length arr))))\n                       (match (range 1 (add1 (length arr)))\n\
    \                         [(cons k (cons ks _))\n                          (cons\
    \ y (if (= x y)\n                                      (cons k ks)\n         \
    \                             (cons k ks)))])))]))]\n            [else (pluck\
    \ xs)])]))\n```\n\n### Problem 15:\n\n``` #lang racket\n", "  (define (helper\
    \ arr index result)\n    (if (null? arr)\n        result\n        (if (and (even?\
    \ (car arr))\n                 (or (null? result)\n                     (< (car\
    \ arr) (car result))))\n            (helper (cdr arr) (+ index 1) (list (car arr)\
    \ index))\n            (helper (cdr arr) (+ index 1) result))))\n  (helper arr\
    \ 0 empty))", "  (define lst\n    (for/list ([index (in-range (length arr))]\n\
    \               [value (in-list arr)])\n      (list value index)))\n  (cond [(empty?\
    \ lst) '()]\n        [(odd? (car (car lst))) (pluck (cdr lst))]\n        [else\
    \ (car (argmin cadr lst))]))\n```\n\n## 1.2.2\n\n``` #lang racket\n", "    (if\
    \ (empty? arr)\n        '()\n        (let loop ([ev (sort (filter even? arr) <)]\n\
    \                   [ix 0])\n            (if (empty? ev)\n                '()\n\
    \                (if (even? (car arr))\n                    (if (equal? (car ev)\
    \ (car arr))\n                        (list (car ev) ix)\n                   \
    \     (loop (cdr ev) (+ ix 1)))\n                    (loop (cdr ev) (+ ix 1)))))))\n",
  "  (cond [(empty? arr) '()]\n        [(not (even? (car arr))) (pluck (cdr arr))]\n\
    \        [(and (even? (car arr)) (null? (cdr arr))) `(,(car arr) ,(length arr))]\n\
    \        [(and (even? (car arr))\n              (or (not (even? (cadr arr))) (<\
    \ (car arr) (cadr arr))))\n         `(,(car arr) ,(length arr))]\n        [else\
    \ (pluck (cdr arr))]))\n```\n\n### Pluck a tree (solution #2)\n```racket\n#lang\
    \ racket\n", "    (let ([plucked (filter even? arr)])\n        (if (empty? plucked)\n\
    \            '()\n            (list (list (apply min plucked)\n              \
    \          (index-of (apply min plucked) arr)))))\n)\n</code>\nTest Cases\n<code>;;;;",
  "  (match arr\n    [(cons node rest)\n     (if (zero? (modulo node 2))\n       \
    \  (list node 0)\n         (pluck rest))]\n    [() '()]))\n", "  (let ([evens\
    \ (filter even? arr)])\n    (if (null? evens)\n        #f\n        (let ([min-even\
    \ (apply min evens)])\n          (for/fold ([min-index (index-of arr min-even)])\n\
    \                    ([index arr])\n                    (let ([index-even? (and\
    \ (= (modulo (car arr) 2) 0)\n                                            (= (car\
    \ arr) min-even))])\n                      (if (and index-even?\n            \
    \                   (< (car index) (car min-index)))\n                       \
    \   (list index (car arr))\n                          min-index)))))))\n```\n\n\
    ## Solutions\n\n```racket", "  (let*\n      ([red (filter (lambda (x) (zero? (modulo\
    \ x 2))) arr)]\n       [first (first red)])\n    (if (empty? red)\n        empty\n\
    \        (list first (array-position arr first)))))\n", "  (cond\n    [(empty?\
    \ arr) '()]\n    [(not (integer? (car arr)))\n     (pluck (cdr arr))]\n    [(=\
    \ (modulo (car arr) 2) 0)\n     (cons (car arr) (cons 0 (cdr arr)))]\n    [else\n\
    \     (cons (car arr) (cons 1 (cdr arr)))]))\n", "  (when (and (not (null? arr))\n\
    \             (not (zero? (remainder (car arr) 2))))\n    (begin\n      (set!\
    \ arr (cdr arr))\n      (pluck arr))))\n", "  (let-values (((smallest index) (find-smallest-even\
    \ arr)))\n    (if (or (null? smallest) (zero? smallest))\n        '()\n      \
    \  (list smallest index))))\n", "  (match arr\n    ([#f] #f)\n    ([index node\
    \ rest ...]\n     (cond\n       [(even? node)\n        (match (pluck rest)\n \
    \         [#f (list node index)]\n          [node2 _ (and (even? node2)\n    \
    \                    (not (< node node2)))]\n          [_ (list node index)])]\n\
    \       [else (pluck rest)]))))\n```\n\n# Leetcode\n\n### 704. Binary Search\n\
    \n```racket", "  (define nodes (hash))\n  (for ([i (in-range (length arr))])\n\
    \    (hash-set! nodes (list-ref arr i) i))\n  (define evens (filter even? (hash-keys\
    \ nodes)))\n  (unless (empty? evens)\n    (list (apply min evens) (hash-ref nodes\
    \ (apply min evens)))))\n", "  (if (empty? arr)\n      '()\n      (let* ([evens\
    \ (keep even? arr)]\n             [smallest (if (empty? evens) 0 (apply min evens))]\n\
    \             [index (if (empty? evens) -1 (if (= smallest 0) 0 (index-of smallest\
    \ arr)))])\n        (list smallest index))))\n", "  (if (empty? arr)\n      '()\n\
    \      (cond\n        [(even? (car arr))\n         (list (car arr) (count-pair\
    \ arr))]\n        [else\n         (pluck (cdr arr))])))\n", "  (cond [(empty?\
    \ arr) empty]\n        [(empty? (filter even? arr)) empty]\n        [else (cons\
    \ (min (filter even? arr)) (index (min (filter even? arr)) arr))]))\n</code>\n\
    My code has 2 problems:\n\nIt's slow when the tree has many nodes\n<code>(pluck\
    \ '(2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)) ; (2 0)\n</code>\nIt's\
    \ not recursive.\n\nI tried to solve it recursively:\n<code>#lang racket\n", " \
    \ (if (empty? arr)\n      '()\n      (let ([smallest-even (array-min-even arr)]\n\
    \            [smallest-even-index (array-min-even-index arr)])\n        (if (zero?\
    \ smallest-even)\n            '()\n            (list smallest-even smallest-even-index)))))\n",
  "  (let loop ([xs arr] [min-even 0] [min-idx 0])\n    (cond [(null? xs) (if (even?\
    \ min-even) (list min-even min-idx) empty)]\n          [(even? (car xs)) (if (<\
    \ min-even (car xs))\n                                (loop (cdr xs) (car xs)\
    \ (- (length arr) (length xs)))\n                                (loop (cdr xs)\
    \ min-even min-idx))]\n          [else (loop (cdr xs) min-even min-idx)])))\n",
  "  (if (= 0 (length arr))\n      '()\n      (let ([evens (remove (lambda (n) (odd?\
    \ n)) arr)])\n        (if (= 0 (length evens))\n            '()\n            (list\
    \ (apply min evens)\n                  (first (argmin (curryr - evens) evens)))))))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond\n    [(empty? arr) '()]\n    [(even?\
    \ (first arr)) (cons (first arr) 0)]\n    [else (let* ([node (pluck (rest arr))]\n\
    \                  [last-node (last node)])\n              (when (and last-node\
    \ (= 0 (last node)))\n                (list (first node) 1)))]))\n</code>\nBut\
    \ it only works with simple lists. When I introduce nested lists, it fails:\n\
    <code>#lang racket\n", "  (cond [(empty? arr) '()]\n        [(even? (first arr))\
    \ (min (first arr) (first (pluck (rest arr))))]\n        [else (pluck (rest arr))]))\n",
  "  (if (empty? arr)\n      '()\n      (or (min-even arr) '())))\n", "  (if (empty?\
    \ arr)\n      '()\n      (let* ([evens (filter even? arr)]\n             [min-even\
    \ (min evens)])\n        (if (empty? evens)\n            '()\n            (let*\
    \ ([index (find-index min-even arr)]\n                   [result (list min-even\
    \ index)])\n              result)))))\n", "  (match arr\n    [(list) '()]\n  \
    \  [(list (list first-value) (list first-index))\n     (if (even? first-value)\n\
    \         (list first-value first-index)\n         (pluck (cdr arr)))]\n    [(list\
    \ (list first-value) (list first-index) first-rest)\n     (let ([second-value\
    \ (car (caadr arr))]\n           [second-index (car (cdadr arr))])\n       (if\
    \ (even? first-value)\n           (if (and (even? second-value) (< first-value\
    \ second-value))\n               (list first-value first-index)\n            \
    \   (pluck (cdr arr)))\n           (pluck (cdr arr))))]))\n", "  (cond [(empty?\
    \ arr) '()]\n        [(member (first arr) (list 2 4 6 8 0)) (list (first arr)\
    \ 0)]\n        [else (pluck (rest arr))]))\n", "  (let ([sm (sort (filter even?\
    \ arr) <)])\n    (if (empty? sm) '()\n        (let ([first (first sm)])\n    \
    \      (list first (index arr first))))))\n", "  (cond\n    [(empty? arr) '()]\n\
    \    [(even? (first arr)) (list (first arr) 0)]\n    [else (let*\n           \
    \   ([rest (pluck (rest arr))]\n               [rest-value (first rest)]\n   \
    \            [rest-index (second rest)])\n            (cond\n              [(empty?\
    \ rest) '()]\n              [(> (first arr) rest-value) rest]\n              [(<\
    \ (first arr) rest-value) (list (first arr) 0)]\n              [(zero? (modulo\
    \ (first arr) rest-value)) (list (first arr) 0)]\n              [else rest]))]))\n\
    ```\n\n```racket\n#lang racket\n", "  (if (empty? arr)\n      '()\n      (let*\
    \ (\n             (evens (filter even? arr))\n             (evens-sorted (sort\
    \ < evens))\n             (min-even (car evens-sorted))\n             (index-of-min-even\
    \ (for/first ([i (in-range (length arr))]\n                                  \
    \          [item (in-list arr)])\n                                   (if (= item\
    \ min-even)\n                                       i))))\n        (list min-even\
    \ index-of-min-even))))\n", "  (let loop ([arr arr] [idx -1] [min 10000])\n  \
    \  (if (empty? arr) (if (= min 10000) '() (list min idx))\n        (let ([n (first\
    \ arr)])\n          (if (and (even? n) (< n min))\n              (loop (rest arr)\
    \ (+ idx 1) n)\n              (loop (rest arr) (+ idx 1) min))))))\n", "  (cond\
    \ [(empty? arr) empty]\n        [(and (empty? (cdr arr)) (not (even? (car arr))))\
    \ empty]\n        [(even? (car arr))\n         (cond [(and (empty? (cdr arr))\
    \ (even? (car arr)))\n                (list (car arr) 0)]\n               [(let*\
    \ ((f (andmap even? (cdr arr)))\n                       (s (empty? (filter even?\
    \ (cdr arr)))))\n                  (if (and (not f) s) (list (car arr) 0)\n  \
    \                    (let ([i (find-min (find-even arr) 0)])\n               \
    \         (list (list-ref arr i) i))))])]\n        [else (pluck (cdr arr))]))\n",
  "  (if (empty? arr)\n      '()\n      (let* ([evens (filter even? arr)]\n      \
    \       [lowest (apply min evens)])\n        (list lowest (index arr lowest)))))\n",
  "  (if (zero? (vector-length arr))\n      '()\n      (let* ([min-idx (let loop ([idx\
    \ 0] [posn #f])\n                       (if (= idx (vector-length arr))\n    \
    \                       posn\n                           (let ([val (vector-ref\
    \ arr idx)])\n                             (if (and (even? val) (or (not posn)\
    \ (< val (vector-ref arr posn))))\n                                 (loop (+ idx\
    \ 1) idx)\n                                 (loop (+ idx 1) posn)))))]\n     \
    \        [min-val (and min-idx (vector-ref arr min-idx))])\n        (if min-val\n\
    \            (list min-val min-idx)\n            '()))))\n", "  (define (accumulate\
    \ acc idx elem)\n    (cond ((= idx (length arr)) \n           (if (< acc 10001)\
    \ (list acc idx) '()))\n          ((and (= 0 (modulo elem 2))\n              \
    \  (< elem acc))\n           (accumulate elem idx elem))\n          (else (accumulate\
    \ acc (+ idx 1) (list-ref arr (+ idx 1))))))\n  (if (= 0 (length arr)) '() (accumulate\
    \ 10000 0 (list-ref arr 0))))", "  (unless (empty? arr)\n    (define n (vector-ref\
    \ arr 0))\n    (cond\n      [(empty? (vector-ref arr 1)) [n 0]]\n      [(even?\
    \ n)\n       (pluck (vector-ref arr 1))]\n      [else\n       (let ([result (pluck\
    \ (vector-ref arr 2))])\n         (cond\n           [(empty? result) [n 0]]\n\
    \           [(even? (vector-ref result 0)) result]\n           [else [n 0]]))])))\n",
  "  (list (first (filter even? arr)) 0))\n", "    ;; The code above the comment is\
    \ actually testing the provided solution\n    ;; This was provided by the problem\
    \ creator and is not my work\n    (define (look arr arr-index min-val min-index)\n\
    \        (cond\n            [(or (<= (length arr) 0) (= (length arr) 1)) (list\
    \ min-val min-index)]\n            [(not (number? (car arr))) (look (cdr arr)\
    \ (+ arr-index 1) min-val min-index)]\n            [(even? (car arr))\n      \
    \          (if (or (zero? min-val) (< (car arr) min-val))\n                  \
    \  (look (cdr arr) (+ arr-index 1) (car arr) arr-index)\n                    (look\
    \ (cdr arr) (+ arr-index 1) min-val min-index))]\n            [else (look (cdr\
    \ arr) (+ arr-index 1) min-val min-index)]))\n    (look arr 0 -1 -1))\n```\n\n\
    ### 0x05. Guess The Number\n\n```racket\n#lang racket\n", "  (define (pluck-internal\
    \ arr min min-idx)\n    (if (empty? arr)\n        (if min\n            (list min\
    \ min-idx)\n            (list))\n        (define head (first arr))\n        (define\
    \ tail (rest arr))\n        (if (even? head)\n            (if (and min (> head\
    \ min))\n                (pluck-internal tail min min-idx)\n                (pluck-internal\
    \ tail head 0))\n            (pluck-internal tail min min-idx))))\n  (pluck-internal\
    \ arr #f #f))\n", "  (let loop ([arr arr] [min 0] [min-index 10000])\n    (cond\
    \ [(empty? arr) '(0 0)]\n          [(even? (car arr)) (loop (cdr arr) (car arr)\
    \ (add1 (cdr arr)))]\n          [else (loop (cdr arr) min (add1 (cdr arr)))])))\n",
  "  (let\n    ([evens (filter even? arr)])\n    (if (null? evens)\n      '()\n  \
    \    (let\n        ([smalls (vector-sort < evens)])\n        (list (vector-ref\
    \ smalls 0) (vector-index (vector-ref smalls 0) arr))))))\n", "  (for/first ([val\
    \ (in-list arr)\n               :when (even? val)])\n    [val (index arr val)]))\n",
  "  (cond [(empty? arr) empty]\n        [(and (even? (first arr)) (< 1 (length arr)))\
    \ (pluck (rest arr))]\n        [(and (even? (first arr)) (>= 1 (length arr)))\
    \ (list (first arr) 0)]\n        [(not (even? (first arr))) (let-values ([(smallest-value\
    \ smallest-index) (pluck (rest arr))])\n                                     \
    \ (if (empty? smallest-value) empty\n                                        \
    \  (list smallest-value (+ smallest-index 1))))]))\n```\n\n```racket\n#lang racket\n",
  "  (let ((evens (filter (\u03BB (x) (= (remainder x 2) 0)) arr)))\n    (cond [(empty?\
    \ evens) '()]\n          [else (values (apply min evens) (index-of (apply min\
    \ evens) arr))])))\n", "  (if (= 0 (count arr))\n      '()\n      (if (zero? (remainder\
    \ (car arr) 2))\n          (let ([result (cons (car arr) (list (remainder (car\
    \ arr) 2)))])\n            (define (rec arr)\n              (if (= 0 (count arr))\n\
    \                  result\n                  (if (zero? (remainder (car arr) 2))\n\
    \                      (if (< (car result) (car arr))\n                      \
    \    (rec (cdr arr))\n                          (define (rec-index arr)\n    \
    \                        (if (= 0 (count arr))\n                             \
    \   result\n                                (if (and (= (car result) (car arr))\n\
    \                                         (< (cadr result) (remainder (car arr)\
    \ 2)))\n                                    (rec-index (cdr arr))\n          \
    \                          (rec (cdr arr)))))\n                      (rec-index\
    \ (cdr arr)))\n                      (rec (cdr arr)))))\n            (rec (cdr\
    \ arr)))\n          '())))\n", "  (define (find-smalest-even arr smalest-even-index)\n\
    \    (for/fold ([index 0] [smalest-even-index #f]) ([node arr])\n      (cond\n\
    \        [(and (even? node) (= smalest-even-index #f)) [index node]]\n       \
    \ [(and (even? node) (= smalest-even-index #f) (< node smalest-even-index)) [index\
    \ node]]\n        [else smalest-even-index])))\n  (find-smalest-even arr #f))\n",
  "  (match arr\n    [(list) '()]\n    [(list x (list-rest xs))\n     (match (pluck\
    \ xs)\n       [(list y index)\n        (if (even? x)\n            (if (even? y)\n\
    \                (if (< x y) (list x 0) (list y index))\n                (list\
    \ x 0))\n            (list y (add1 index)))]\n       [(list)\n        (if (even?\
    \ x) (list x 0) '())]\n       [(list y)\n        (if (even? x) (list x 0) '())])]))\n",
  "  (filter even? arr))\n", "  (define (find-smallest-even arr)\n    (define (loop\
    \ a i found)\n      (if (empty? a)\n          (if found\n              (list (apply\
    \ min (filter (lambda (x) (even? (car x))) found))\n                    (apply\
    \ min (map (lambda (x) (cadr x)) found)))\n              '())\n          (let\
    \ ((x (car a)))\n            (if (and (even? x)\n                     (not (pair?\
    \ (filter (lambda (y) (= x (car y))) found))))\n                (loop (cdr a)\
    \ (+ i 1) (cons (list x i) found))\n                (loop (cdr a) (+ i 1) found)))))\n\
    \    (loop arr 0 '()))\n  (find-smallest-even arr))\n", "  (define (append-first\
    \ lst)\n    (let loop ([head (car lst)] [tail (cdr lst)])\n      (if (null? tail)\n\
    \          (list head)\n          (cons head (loop (car tail) (cdr tail))))))\n\
    \  (cond\n    [(empty? arr) '()]\n    [(empty? (filter even? arr)) '()]\n    [else\
    \ (append-first (argmin even? arr))]))\n", "  (define (first-even-node-matching?\
    \ filter-fn)\n    (and-let* ([evns (filter filter-fn arr)]\n               [evn\
    \ (first evns)])\n      evn))\n  (define (first-even-node-to-match? filter-fn)\n\
    \    (and-let* ([first-even-node (first-even-node-matching? filter-fn)]\n    \
    \           [index (index-of first-even-node arr)])\n      (list first-even-node\
    \ index)))\n  (define (even? n)\n    (= (modulo n 2) 0))\n  (match (first-even-node-to-match?\
    \ even?)\n    [(cons first-even-node first-even-node-index) first-even-node-index]\n\
    \    [else '()]))\n", "  (define (is-even? i) (= (remainder i 2) 0))\n  (define\
    \ (pluck-arr acc input)\n    (if (empty? input)\n        acc\n        (let ([cur\
    \ (first input)])\n          (if (and (is-even? cur)\n                   (or (empty?\
    \ acc)\n                       (< cur (first acc))))\n              (pluck-arr\
    \ (list cur (length input)) (rest input))\n              (pluck-arr acc (rest\
    \ input))))))\n  (pluck-arr '() arr))\n```\n\n### Writing tests\n\nRun the tests\
    \ with `rackunit`:\n\n```bash\nracket -t pluck.rkt\n```\n\n### Output\n\n```\n\
    racket -t pluck.rkt\nWelcome to DrRacket, version 6.6 [3m].\nLanguage: racket,\
    \ with debugging; memory limit: 128 MB.\n\npluck.rkt:35:13:          [fail]  \
    \ (equal? (pluck empty) empty)\npluck.rkt:36:13:          [fail]   (equal? (pluck\
    \ (list 1 2 3)) (list 2 0))\npluck.rkt:37:13:          [fail]   (equal? (pluck\
    \ (list 2 3 1)) (list 2 0))\npluck.rkt:38:13:          [fail]   (equal? (pluck\
    \ (list 1 7 5)) (list 6 1))\npluck.rkt:39:13:          [fail]   (equal? (pluck\
    \ (list 7 5 3 1)) (list 6 3))\npluck.rkt:40:13:          [fail]   (equal? (pluck\
    \ (list 2 7 1 1 2)) (list 2 0))\npluck.rkt:41:13:          [fail]   (equal? (pluck\
    \ (list 2 1 1 2 1)) (list 2 0))\npluck.rkt:42:13:          [fail]   (equal? (pluck\
    \ (list 1)) empty)\npluck.rkt:43:13:          [fail]   (equal? (pluck (list 7\
    \ 5 3 1)) (list 6 3))\npluck.rkt:44", "  (cond [(empty? arr) '()]\n        [(even?\
    \ (first arr)) (define evens (filter even? arr))\n                           \
    \  (match (min-index evens)\n                                    [(list 0) (list\
    \ (first evens) (if (empty? evens) 0 0))]\n                                  \
    \  [(list n) (list (list-ref evens n) n)])]\n        [else (pluck (rest arr))]))\n",
  "  (let* ([even-indices (filter (\u03BB (i) (zero? (remainder (list-ref arr i) 2)))\
    \ (build-list (length arr) (\u03BB (i) i)))]\n         [even-values (for/list\
    \ ([i even-indices]) (list-ref arr i))]\n         [minimum-even-value (if (empty?\
    \ even-values) #f (apply min even-values))]\n         [minimum-even-indices (if\
    \ (equal? minimum-even-value #f) (list) (filter (\u03BB (i) (equal? (list-ref\
    \ arr i) minimum-even-value)) even-indices))])\n    (list minimum-even-value (apply\
    \ min minimum-even-indices))))\n", "  (if (empty? arr) (list)\n      (let ((plucked\
    \ (first arr)))\n        (for ([n (in-list (rest arr))])\n          (if (and (even?\
    \ n) (<= n plucked))\n              (set! plucked n)))\n        (if (even? plucked)\n\
    \            (list plucked (first (where arr equal? plucked)))\n            (list)))))\n",
  "  (if (or (empty? arr) (null? (even? (first arr))))\n      '()\n      (let ([min-even-node\
    \ (match-first even? arr)])\n        (first (filter (\u03BB (node) (and (even?\
    \ (second node))\n                                       (second node)\n     \
    \                                  (= (second node) min-even-node)))\n       \
    \                (iota (length arr)))))))\n", "  (if (null? arr)\n      '()\n\
    \      (let ([evens (filter even? arr)])\n        (if (null? evens)\n        \
    \    '()\n            (list (apply min evens)\n                  (argmin evens))))))\n",
  "  (cond\n    [(&lt;= (length arr) 0) '()]\n    [(empty? (filter even? arr)) '()]\n\
    \    [else (list (min (filter even? arr)) (position (min (filter even? arr)) arr))]))\n\
    </code>\nBut the test says that is not correct.\n<code>`racket pluck.rkt`\n\n\
    `(pluck '(-1 -2 2))`", "  (define min_even (min arr (\u03BB (x) (and (even? x)\
    \ x))))\n  (define index (array-index arr min_even))\n  (unless (and min_even\
    \ (even? min_even))\n    (list))\n  (list min_even index))\n", "  (cond\n    [(null?\
    \ arr) '()]\n    [(and (even? (car arr)) (or (null? (cdr arr))\n             \
    \                   (< (car arr) (cadr arr))))\n     (list (car arr) 0)]\n   \
    \ [else (let loop ([arr (cdr arr)] [index 1])\n             (cond\n          \
    \     [(null? arr) '()]\n               [(and (even? (car arr)) (or (null? (cdr\
    \ arr))\n                                           (< (car arr) (cadr arr))))\n\
    \                (list (car arr) index)]\n               [else (loop (cdr arr)\
    \ (+ index 1))]))]))\n", "  (cond [(empty? arr) '()]\n        [(even? (car arr))\
    \ (list (car arr) 0)]\n        [else (pluck (cdr arr))]))\n```\n\n## Sample Tests\n\
    \n```racket", "  (define node-sort (lambda (n1 n2)\n                      (cond\
    \ [(= (cadr n1) (cadr n2)) (string<? (car n1) (car n2))]\n                   \
    \         [(< (cadr n1) (cadr n2)) #t]\n                            [else #f])))\n\
    \  (let* ([evens (filter (lambda (n) (= 0 (modulo (car n) 2))) (range arr))]\n\
    \         [sorted (sort node-sort evens)])\n    (if (empty? sorted) (list) (car\
    \ sorted))))\n", "  (define min-even\n    (apply min\n           (filter even?\n\
    \                   arr)))\n  (if (null? min-even)\n      #f\n      (list min-even\n\
    \            (index-of arr\n                      min-even))))\n```\n\n### 6\n\
    \n``` #lang racket\n", "  (cond [(empty? arr) '()]\n        [(even? (car arr))\n\
    \         (if (< (even-min (cdr arr)) (car arr))\n             (cons (even-min\
    \ (cdr arr)) (even-min-index (cdr arr)))\n             (cons (car arr) 0))]\n\
    \        [else (cons (even-min arr) (even-min-index arr))]))\n", "  (if (empty?\
    \ arr)\n      '()\n      (if (even? (car arr))\n          (pluck-helper arr (car\
    \ arr) 0 1)\n          (pluck (cdr arr)))))\n", "  (let ([lst (filter even? arr)])\n\
    \    (cond [(empty? lst) '()]\n          [(= 1 (length lst))\n           (let\
    \ ([index (index-of (first lst) arr)])\n             (list (first lst) index))]\n\
    \          [else\n           (let ([index (index-of (first lst) arr)])\n     \
    \        (list (first lst) index))])))\n", "  (cond\n    [(empty? arr) arr]\n\
    \    [(even? (car arr)) (list (car arr) 0)]\n    [else (define ans (pluck (cdr\
    \ arr)))\n          (cond\n            [(empty? ans) arr]\n            [(even?\
    \ (car ans)) ans]\n            [else (list (car arr) (add1 (cadr ans)))])]))\n",
  "  (cond\n    [(empty? arr) (list)]\n    [(even? (first arr)) (list (first arr)\
    \ 0)]\n    [else (pluck (rest arr))]))\n", "  (cond [(empty? arr) '(0 0)]\n  \
    \      [(andmap even? arr)\n         (let* ([sorted (merge-sort (compose cons\
    \ car) arr)]\n                [min-value (car (car sorted))]\n               \
    \ [result (filter (lambda (x) (= min-value (car x))) sorted)])\n           (cond\
    \ [(= 1 (length result)) (car result)]\n                 [else (apply min (map\
    \ car result))]))]\n        [else '(0 0)]))\n", "  (define (pluck-helper arr)\n\
    \    (cond\n      [(null? arr) '()]\n      [(empty? arr) '()]\n      [(even? (first\
    \ arr)) (list (first arr) 0)]\n      [else (pluck-helper (rest arr))]))\n  (define\
    \ (get-index arr)\n    (cond\n      [(null? arr) '()]\n      [(empty? arr) '()]\n\
    \      [(equal? (first arr) (first (pluck-helper arr))) (list (second (pluck-helper\
    \ arr)))]\n      [else (append (get-index (rest arr)) (list (add1 (second (get-index\
    \ (rest arr))))))]))\n  (cond\n    [(null? arr) '()]\n    [(empty? arr) '()]\n\
    \    [(not (even? (first arr))) (append (pluck-helper (rest arr)) (get-index (rest\
    \ arr)))]\n    [else (append (pluck-helper arr) (get-index arr))]))\n", "  (if\
    \ (empty? arr)\n      '()\n      (let* ([evens (for/list ([x arr] #:when (even?\
    \ x)) x)]\n             [min-even (apply min evens)])\n        (if min-even\n\
    \            (let ([idx (array-position arr min-even)])\n              (list min-even\
    \ idx))\n            '()))))\n```\n\n## 32. Read digits of number and sum them\n\
    \n```racket\n#lang racket\n", "  (cond\n    [(empty? arr) '(0 . 0)]\n    [(and\
    \ (even? (first arr)) (equal? (first arr) (second arr)))\n     (cons (first arr)\
    \ (cons 0 (pluck (rest arr))))]\n    [(even? (first arr))\n     (cons (first arr)\
    \ (cons 0 (pluck (rest arr))))]\n    [else (cons (first (rest (pluck (rest arr))))\
    \ (cons 1 (pluck (rest arr))))]))\n", "  (cond\n    [(empty? arr) '()]\n    [(empty?\
    \ (filter even? arr)) '()]\n    [else (list (minimum (filter even? arr)) (index\
    \ (minimum (filter even? arr)) arr))]))\n", "  (cond\n    [(empty? arr) '()]\n\
    \    [(even? (first arr))\n     (define (get-min-even arr min min-idx current-idx)\n\
    \       (cond\n         [(empty? arr) (list min min-idx)]\n         [(even? (first\
    \ arr))\n          (if (< (first arr) min)\n              (get-min-even (rest\
    \ arr) (first arr) current-idx (+ current-idx 1))\n              (get-min-even\
    \ (rest arr) min min-idx (+ current-idx 1)))]\n         [else (get-min-even (rest\
    \ arr) min min-idx (+ current-idx 1))]))\n     (get-min-even (rest arr) (first\
    \ arr) 0 1)]\n    [else (pluck (rest arr))]))\n```\n\nExample:\n\n```racket\n\
    > (pluck (list 1 3 5 2 8 9))\n'(2 3)\n```\n\nExplanation:\n\nIt finds the minimum\
    \ even number in the list and its index.\n\n---\n\n## Day 17 (07.11.2020)\n\n\
    ### Take the Lake\n\n`https://codefights.com/challenge/fDGjKsRfDGjfes2QF`\n\n\
    ```racket\n#lang racket\n", "  (cond [(empty? arr) '()]\n        [(zero? (modulo\
    \ (first arr) 2))\n         (let loop ([arr arr] [min (first arr)] [min-pos 0])\n\
    \           (cond [(empty? arr) (list min min-pos)]\n                 [(< (first\
    \ arr) min)\n                  (loop (rest arr) (first arr) (+ min-pos 1))]\n\
    \                 [else (loop (rest arr) min (+ min-pos 1))]))]\n        [else\
    \ (pluck (rest arr))]))\n", "  (cond [(empty? arr) '(0 0)]\n        [(even? (first\
    \ arr)) (smallest-index-of-evens arr)]\n        [else (pluck (rest arr))]))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(empty? (cdr arr)) (pluck (car arr))]\n \
    \   [(empty? (cdr (cdr arr))) (pluck (car arr))]\n    [(equal? 0 (modulo (car\
    \ arr) 2)) (list (car arr) 0)]\n    [(equal? 0 (modulo (cadr arr) 2)) (list (cadr\
    \ arr) 1)]\n    [(equal? 0 (modulo (caddr arr) 2)) (list (caddr arr) 2)]\n   \
    \ [else (pluck (car arr))]))\n", "  (cond ((empty? arr) '())\n        ((not (even?\
    \ (first arr))) (pluck (rest arr)))\n        (else (build-list arr))))\n", " \
    \ (cond [(empty? arr) '()]\n        [(even? (first arr)) (find-min-index (first\
    \ arr) 0 arr)]\n        [else (pluck (rest arr))]))\n", "  (if (empty? arr)\n\
    \      empty\n      (match (foldr (lambda (n a) (if (= (remainder n 2) 0) (cons\
    \ n a) a)) empty arr)\n        ((n1 n2 . rest)\n         (if (< n1 n2)\n     \
    \        (list n1 (index arr n1))\n             (list n2 (index arr n2))))\n \
    \       (n (list n (index arr n))))))\n", "  (cond\n    [(empty? arr) (list)]\n\
    \    [(even? (first arr)) (cons (first arr) (pluck (rest arr)))]\n    [else (pluck\
    \ (rest arr))]))\n```\n\n## Actually interesting bits\n\n```racket", "  (if (empty?\
    \ arr) '()\n      (let ((evens (filter even? arr)))\n        (if (empty? evens)\
    \ '()\n            (let ((first (car evens)))\n              (let ((min-pos (argmin\
    \ first evens)))\n                (list first min-pos)))))))\n", "  (if (empty?\
    \ arr)\n      (list)\n      (if (null? (filter even? arr))\n          (list)\n\
    \          (let* ([evens (filter even? arr)]\n                 [min-even (apply\
    \ min evens)]\n                 [min-even-idx (vector-index min-even arr)])\n\
    \            (list min-even min-even-idx)))))\n", "  (if (null? arr)\n      '()\n\
    \      (let loop ([arr arr] [even '()])\n        (if (not (pair? arr))\n     \
    \       (if (null? even)\n                '()\n                (list (apply min\
    \ even) (apply min (map index-of even arr))))\n            (if (zero? (remainder\
    \ (car arr) 2))\n                (loop (cdr arr) (cons (car arr) even))\n    \
    \            (loop (cdr arr) even))))))\n", "  (cond [(empty? arr) '()]\n    \
    \    [(< (remainder (first arr) 2) 1) (pluck (rest arr))]\n        [else (list\
    \ (first arr) (list-ref arr (index (first arr) arr)))]))\n", "  (cond [(empty?\
    \ arr) '()]\n        [(even? (car arr)) (cons (car arr) 0)]\n        [else (cons\
    \ (car arr) 0)]))", "  (define evens\n    (for/list ([n arr]\n               #:when\
    \ (even? n))\n      n))\n  (define min-even (min evens))\n  (cond\n    [(empty?\
    \ evens) '()]\n    [else (list min-even (index arr min-even))]))\n```\n\n**Solution**:\n\
    \n```\n#lang racket\n", "  (if (empty? arr)\n      (list)\n      (apply min (map\
    \ (lambda (v i) (if (even? v) (list v i) (list))) arr))))\n", "  (for/first\n\
    \    ((n (in-list arr))\n     (when (even? n)))\n    (list n (index arr n))))\n\
    ```\n\n#### Solution:\n```\n#lang racket\n", "  (let ([smallest-even-value (apply\
    \ min (filter even? arr))])\n    (cond [(null? smallest-even-value) '()]\n   \
    \       [else (list smallest-even-value (list-index arr smallest-even-value))])))\n",
  "  (define even-indices\n    (filter-index (lambda (ix) (even? (list-ref arr ix)))\n\
    \                  (range (length arr))))\n  (if (empty? even-indices)\n     \
    \ (list)\n      (apply list (filter-index (lambda (ix)\n                     \
    \             (and (= ix (list-ref even-indices 0))\n                        \
    \               (< (list-ref arr ix)\n                                       \
    \   (list-ref arr (list-ref even-indices 1)))))\n                            \
    \    (range (length arr))))))\n", "  (if (empty? arr)\n      '()\n      (let*\
    \ ([evns (filter even? arr)]\n             [m (apply min evns)])\n        (if\
    \ (= 0 (length evns))\n            '()\n            (list m (index-of m arr))))))\n",
  "  (match arr\n    [(list) (list)]\n    [(cons a xs)\n     (if (and (even? a) (or\
    \ (null? (rest xs))\n                            (even? (first xs))))\n      \
    \   (list a 0)\n         (apply max\n                (map (\u03BB (v-and-i)\n\
    \                       (let ([node (first v-and-i)]\n                       \
    \      [index (second v-and-i)])\n                         (if (even? node)\n\
    \                             (list node index)\n                            \
    \ (list -1 -1))))\n                     (enumerate xs))))]))\n", "  (if (eq? (length\
    \ arr) 0)\n      '()\n      (let ([evens-only (flatten (list-of-evens arr))])\n\
    \        (if (eq? (length evens-only) 0)\n            '()\n            (let ([min-even\
    \ (min-of-list evens-only)])\n              (list min-even (index-of min-even\
    \ arr)))))))\n", "  (if (empty? arr)\n      '()\n      (let ((evens (filter even?\
    \ arr)))\n        (if (empty? evens)\n            '()\n            (let ((lowest\
    \ (reduce min evens)))\n              (list lowest (find lowest arr)))))))\n",
  "  (let* ([even-vals (filter even? arr)]\n         [min-even (if (empty? even-vals)\
    \ '() (apply min even-vals))]\n         [index (indexof min-even arr)])\n    (if\
    \ (empty? index) '() (list min-even index))))", "  (cond\n    [(empty? arr) '()]\n\
    \    [(every? (lambda (x) (odd? x)) arr) '()]\n    [else (pluck' arr)]))\n", " \
    \ (let loop ([i (in-naturals)] [l arr])\n    (cond [(= (length l) 0) (list)]\n\
    \          [(and (even? (first l)) (or (null? (first (rest l))) (not (even? (first\
    \ (rest l)))))) (list (first l) i)]\n          [else (loop (+ i 1) (rest l))])))\n",
  "  (cond [(empty? arr) '()]\n        [(even? (first arr)) (list (first arr) 0)]\n\
    \        [else (let* ([recurse (pluck (rest arr))]\n                     [plucked-n\
    \ (first recurse)]\n                     [plucked-i (add1 (second recurse))])\n\
    \                (cond [(empty? recurse) '()]\n                      [(or (empty?\
    \ plucked-n)\n                           (and (even? (first arr))\n          \
    \                      (< (first arr) plucked-n)))\n                       (list\
    \ (first arr) 0)]\n                      [else recurse]))]))\n", "  (cond\n  \
    \  [(empty? arr) '()]\n    [(empty? (filter even? arr)) '()]\n    [else (apply\
    \ min (filter even? arr))]))\n", "  (cond [(empty? arr) '()]\n        [(even?\
    \ (first arr))\n         (pluck-helper arr (first arr) 0)]\n        [else (pluck\
    \ (rest arr))]))\n", "  (cond [(or (empty? arr) (empty? (filter even? arr))) '()]\n\
    \        [else (let* ([arr-even (filter even? arr)]\n                     [smallest-value\
    \ (apply min arr-even)]\n                     [smallest-index (index arr smallest-value)])\n\
    \                (list smallest-value smallest-index))]))\n", "  (let ([arr-evens\
    \ (filter even? arr)])\n    (if (empty? arr-evens)\n        '()\n        (argmin\
    \ idx arr-evens))))\n", "  (if (null? arr)\n      (list)\n      (let* ([evens\
    \ (list-ref arr 0)]\n             [index (list-ref arr 1)])\n        (if (zero?\
    \ (% evens 2))\n            (cond\n              [(> (length arr) 2)\n       \
    \        (for ([test (rest (rest arr))]\n                     [even (rest evens)]\n\
    \                     [ind (rest index)])\n                 (cond\n          \
    \         [(zero? (% even 2))\n                     (if (< even (car evens))\n\
    \                         (set! evens (cons even evens))\n                   \
    \      (if (and (= even (car evens))\n                                  (< ind\
    \ (car index)))\n                             (set! index (cons ind index))))]\n\
    \                   [else\n                     (list-ref evens 0)\n         \
    \            (list-ref index 0)]))]\n              [else\n               (list-ref\
    \ evens 0)\n               (list-ref index 0)])\n            (list))))\n  )\n",
  "  (define testnode (lambda (node) (and (>= (car node) 0) (even? (car node)))))\n\
    \  (define (not-empty? nodes) (and (not (empty? nodes)) (first nodes)))\n  (define\
    \ (not-empty-even? nodes) (and (not-empty? nodes) (testnode (first nodes))))\n\
    \  (define (get-smallest nodes)\n    (cond\n      [(not-empty-even? nodes) (first\
    \ nodes)]\n      [else (get-smallest (rest nodes))]))\n  (define (get-smallest-and-index\
    \ nodes)\n    (cond\n      [(not-empty-even? nodes) (cons (car nodes) (cdr nodes))]\n\
    \      [else (get-smallest-and-index (rest nodes))]))\n  (define (get-smallest-evens\
    \ nodes result-so-far)\n    (cond\n      [(not-empty-even? nodes) (get-smallest-evens\
    \ (rest nodes) (cons (car nodes) result-so-far))]\n      [else result-so-far]))\n\
    \  (define (get-smallest-even-value nodes)\n    (car (apply min (get-smallest-evens\
    \ nodes '()))))\n  (define (get-indexes-of-smallest-evens nodes result-so-far)\n\
    \    (cond\n      [(not-empty-even? nodes) (get-indexes-of-smallest-evens (rest\
    \ nodes) (cons (cdr nodes) result-so-far))]\n      [else result-so-far]))\n  (define\
    \ (get-smallest-index-of-smallest-even nodes)\n    (apply min (get-indexes-of-smallest-evens\
    \ nodes '())))\n  (define (get-smallest-even nodes)\n    (define smallest-value\
    \ (get-smallest-even-value nodes))\n    (define indexes-of-smallest-evens (get-indexes-of-smallest-evens\
    \ nodes '()))\n    (define smallest-index-of-smallest-even (get-smallest-index-of-smallest-even\
    \ nodes))\n    (list smallest-", "  (if (empty? arr)\n      '()\n      (match\
    \ arr\n        [_ (list 0 0)]\n        [(cons head tail)\n         (let ([r (pluck\
    \ tail)])\n           (if (equal? '() r)\n               (if (even? head)\n  \
    \                 (list head 0)\n                   (list 0 0))\n            \
    \   (let* ([hr (car r)]\n                      [hri (cadr r)]\n              \
    \        [her (cadr r)])\n                 (if (and (even? head)\n           \
    \               (or (odd? hr)\n                              (<= head hr)))\n\
    \                     (list head 0)\n                     (if (and (even? hr)\n\
    \                              (or (odd? head)\n                             \
    \     (<= hr head)))\n                         (list hr (add1 hri))\n        \
    \                 (list 0 0))))))])))", "  (for/fold ([evens '()]\n          \
    \   [odds '()])\n            ([n (in-list arr)])\n    (cond [(and (even? n) (empty?\
    \ evens)) (list (list n (length arr)) odds)]\n          [(and (even? n) (empty?\
    \ odds)) (list evens (list n (length arr)))]\n          [(and (even? n) (< n (first\
    \ evens))) (list (list n (length arr)) odds)]\n          [(and (even? n) (> n\
    \ (first evens))) (list evens (list n (length arr)))]\n          [(odd? n) (list\
    \ evens (list n (length arr)))]))\n  (cond [(and (empty? (first evens)) (empty?\
    \ (second odds))) '()]\n        [(and (empty? (first evens)) (not (empty? (second\
    \ odds)))) (second odds)]\n        [(and (not (empty? (first evens))) (empty?\
    \ (second odds))) (first evens)]\n        [(and (not (empty? (first evens))) (not\
    \ (empty? (second odds))))\n         (cond [(< (first evens) (second odds)) (first\
    \ evens)]\n               [else (second odds)])]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
