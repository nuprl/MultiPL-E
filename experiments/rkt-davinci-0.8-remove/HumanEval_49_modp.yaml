name: HumanEval_49_modp
language: rkt
prompt: "#lang racket\n\n;; Return 2^n modulo p (be aware of numerics).\n(define (modp\
  \ n p)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n\
  \    (check-equal? (candidate 3 5) 3)\n    (check-equal? (candidate 1101 101) 2)\n\
  \    (check-equal? (candidate 0 101) 1)\n    (check-equal? (candidate 3 11) 8)\n\
  \    (check-equal? (candidate 100 101) 1)\n    (check-equal? (candidate 30 5) 4)\n\
  \    (check-equal? (candidate 31 5) 3)\n))\n\n(test-humaneval)"
completions: ["  (define (pow-mod x n p)\n    (if (= n 0)\n        1\n        (let*\
    \ ([pow-mod-help (pow-mod x (- n 1) p)]\n               [result (remainder (*\
    \ x pow-mod-help) p)])\n          result)))\n  (pow-mod 2 n p))\n", "  (define\
    \ (mult a b)\n    (if (zero? a)\n        0\n        (if (zero? b)\n          \
    \  0\n            (+ (* 2 (mult (/ a 2) b))\n               (if (odd? a) b 0)))))\n\
    \  (if (zero? n)\n      1\n      (mult (modp (- n 1) p) 2)))\n", "  (let ([n*\
    \ (* n n)])\n    (cond [(= p 0) 0]\n          [(= p 1) 0]\n          [(= n 1)\
    \ 1]\n          [(= n 2) (modulo 2 p)]\n          [(= n* 0) 1]\n          [(=\
    \ (remainder n* 2) 0) (modulo (modp (/ n* 2) p) p)]\n          [else (modulo (*\
    \ (modp (- n 1) p) (modp 2 p)) p)])))\n", "  (define (iter res pw)\n    (cond\
    \ [(zero? pw) res]\n          [(even? pw) (iter res (/ pw 2))]\n          [else\
    \ (iter (* res 2) (/ (- pw 1) 2))]))\n  (modulo (iter 1 n) p))\n", "  (modulo\
    \ (expt 2 n) p))\n", "  (let ([k n])\n    (let loop ([a 2] [b 2])\n      (if (zero?\
    \ k)\n          b\n          (if (odd? k)\n              (loop (modulo (* a b)\
    \ p) b)\n              (loop a (modulo (* a b) p)))))))\n", "  (let loop ([n n]\
    \ [i 0] [m 1])\n    (if (= n 0)\n        m\n        (loop (quotient n 2) (add1\
    \ i)\n              (if (odd? n)\n                  (modulo (* m (expt 2 i)) p)\n\
    \                  m)))))\n", "  (cond [(= n 0) 1]\n        [(= (remainder n 2)\
    \ 0)\n         (let* ([n (/ n 2)]\n                [s (modp n p)])\n         \
    \  (remainder (* s s) p))]\n        [else\n         (let* ([n (- n 1)]\n     \
    \           [s (modp n p)])\n           (remainder (* s 2) p))]))\n", "  (remainder\
    \ (expt 2 n) p))\n", "  (cond\n    [(= n 0) 1]\n    [(even? n) (modulo (* (modp\
    \ (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo (* (modp (- n 1) p) 2) p)]))\n",
  "  (modulo (expt 2 n) p))\n", "  (if (zero? n)\n      1\n      (if (odd? n)\n  \
    \        (modulo (* 2 (modp (- n 1) p)) p)\n          (modulo (* (modp (/ n 2)\
    \ p) (modp (/ n 2) p)) p))))\n", "  (cond [(< n 0) (mod (expt 2 (- n)) p)]\n \
    \       [(= n 0) 1]\n        [(= n 1) 2]\n        [else (mod (* (modp (- n 1)\
    \ p) 2) p)]))\n", "  (define (modp-iter n p a)\n    (cond\n      [(zero? n) a]\n\
    \      [(odd? n) (modp-iter (quotient n 2) p (* 2 a))]\n      [else (modp-iter\
    \ (quotient n 2) p (modulo (* 2 a) p))]))\n  (modp-iter n p 1))\n", "  (if (odd?\
    \ n)\n      2\n      (* 2 (modp (quotient n 2) p))))\n", "  (let loop ([n n] [p\
    \ p] [a 1])\n    (cond\n      [(zero? n) a]\n      [(even? n) (loop (quotient\
    \ n 2) p (* a a))]\n      [else (loop (sub1 n) p (* a a))])))\n", "  (cond\n \
    \   [(= n 0) 1]\n    [(= n 1) 2]\n    [(= (remainder n 2) 0) (modulo (* (modp\
    \ (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p) 2) p)]))\n", "  (if (zero? n)\n      1\n      (if (even? n)\n   \
    \       (modp (quotient n 2) p)\n          (modp (sub1 n) p))))\n", "  (define\
    \ (iter x n)\n    (if (= n 0)\n        1\n        (iter (remainder (* x x) p)\
    \ (- n 1))))\n  (iter 2 n))\n", "  (modulo (expt 2 n) p))\n", "  (let loop ([n\
    \ n] [acc 1])\n    (cond [(zero? n) acc]\n          [else (loop (sub1 n) (modulo\
    \ (* acc 2) p))])))\n", "  (modulo (expt 2 n) p))\n", "  (let loop ([n n] [a 1])\n\
    \    (if (= n 0)\n        a\n        (loop (- n 1) (modulo (* a 2) p)))))\n",
  "  (cond [(= n 0) 1]\n        [(even? n)\n         (let [(r (modp (/ n 2) p))]\n\
    \           (modulo (* r r) p))]\n        [else\n         (modulo (* 2 (modp (-\
    \ n 1) p)) p)]))\n", "  (define (modp-iter n p pow result)\n    (if (zero? n)\n\
    \        result\n        (if (even? n)\n            (modp-iter (/ n 2) p (* pow\
    \ 2) result)\n            (modp-iter (- n 1) p 2 (modulo (* result pow) p)))))\n\
    \  (modp-iter n p 2 1))\n", "  (modulo n p))\n", "  (define (m n p)\n    (if (zero?\
    \ n)\n        1\n        (if (even? n)\n            (modulo (* (m (/ n 2) p) (m\
    \ (/ n 2) p)) p)\n            (modulo (* (m (/ n 2) p) (m (/ n 2) p) 2) p))))\n\
    \  (if (zero? n)\n      1\n      (m n p)))\n", "  (let loop ([i n] [acc 1])\n\
    \    (if (= i 0)\n        acc\n        (loop (- i 1) (* acc 2) (modulo acc p)))))\n",
  "  (cond\n    [(= n 0) 1]\n    [(even? n) (modulo (* (modp (/ n 2) p) (modp (/ n\
    \ 2) p)) p)]\n    [else (modulo (* (modp (- n 1) p) 2) p)]))\n", "  (if (or (eq?\
    \ n 0) (eq? n 1))\n      1\n      (let ([part (modp (quotient n 2) p)])\n    \
    \    (if (zero? (remainder n 2))\n            (remainder (* part part) p)\n  \
    \          (remainder (* part part 2) p)))))\n", "  (modulo (expt 2 n) p))\n",
  "  (define (modp-iter res n p)\n    (cond\n      [(= n 0) res]\n      [(even? n)\
    \ (modp-iter res (/ n 2) p)]\n      [else (modp-iter (* res 2 res) (/ n 2) p)]))\n\
    \  (modp-iter 1 n p))\n", "  (let loop ([n n] [a 1])\n    (if (= n 0)\n      \
    \  a\n        (loop (- n 1)\n              (modulo (* a 2) p)))))\n", "  (if (=\
    \ n 0)\n      1\n      (* (modp (- n 1) p) 2 (- n 1) p)))\n", "  (cond ((= n 0)\
    \ 1)\n        ((= (modulo n 2) 0)\n         (let ([m (/ n 2)])\n           (modulo\
    \ (* (modp m p) (modp m p)) p)))\n        (else\n         (modulo (* 2 (modp (-\
    \ n 1) p)) p))))\n</code>\n", "  (define (modp_iter n result)\n    (if (zero?\
    \ n)\n        result\n        (modp_iter (sub1 n) (remainder (* 2 result) p))))\n\
    \  (modp_iter n 1))\n", "  (cond [(< n 0) (modp (+ n p) p)]\n        [(= n 0)\
    \ 1]\n        [(= n 1) 2]\n        [else\n         (let ((rec (modp (- n 1) p)))\n\
    \           (modulo (* 2 rec) p))]))\n", "  (define (square x)\n    (* x x))\n\
    \  (define (modp-iter k n a b)\n    (cond\n      [(zero? n) b]\n      [(even?\
    \ n) (modp-iter (add1 k) (quotient n 2) (square a) b)]\n      [else (modp-iter\
    \ (add1 k) (sub1 n) a (modulo (* a b) p))]))\n  (modp-iter 0 n 2 1))\n", "  (define\
    \ (modpacc acc i)\n    (if (= i n)\n        acc\n        (modpacc (modulo (* acc\
    \ 2) p) (+ i 1))))\n  (modpacc 1 0))\n", "  (cond\n    [(= n 0) 1]\n    [(even?\
    \ n) (let ((x (modp (/ n 2) p)))\n                  (* x x p))]\n    [else (let\
    \ ((x (modp (- n 1) p)))\n            (* 2 x p))]))\n</code>\nNo idea about performance\
    \ - for this kind of thing, try and learn to use a profiler, e.g. gprof.\n", " \
    \ (define (mod2 n p)\n    (cond\n      [(= 0 n) 0]\n      [(= 1 n) 2]\n      [(=\
    \ 1 (% n 2)) (modulo (* 2 (mod2 (/ n 2) p)) p)]\n      [else (modulo (* (mod2\
    \ (/ n 2) p) (mod2 (/ n 2) p)) p)]))\n  (mod2 n p))\n", "  (for/fold ([n n]) ([i\
    \ (in-range (- p 1))])\n    (modulo (* n n) p)))\n", "  (define res 1)\n  (define\
    \ p2 (/ p 2))\n  (define (rec n)\n    (if (= n 0)\n        res\n        (begin\n\
    \          (set! res (* res 2))\n          (if (> res p2)\n              (set!\
    \ res (- res p)))\n          (rec (- n 1)))))\n  (rec n))\n", "  (let loop ([a\
    \ 1] [b (modulo n p)])\n    (cond [(zero? b) a]\n          [else (loop (modulo\
    \ (* a b) p) (modulo (truncate (/ b 2)) p))])))\n</code>\nIt takes a couple seconds\
    \ to compute <code>(modp 10^1000 12345678910) = 3806870</code>.\n", "  (modulo\
    \ (expt 2 n) p))\n", "  (define (modpmod p)\n    (define (modpmodmod acc n)\n\
    \      (if (= n 0)\n          acc\n          (modpmodmod (modulo (* acc 2) p)\
    \ (sub1 n))))\n  (modpmodmod 1 n))\n", "  (if (positive? n)\n      (let ([acc\
    \ 1])\n        (do ([i n (- i 1)])\n            ((negative? i) acc)\n        \
    \  (set! acc (* acc 2) acc (remainder acc p))))\n      (- p 1)))\n", "  (define\
    \ (exponentiate b e)\n    (cond [(= e 0) 1]\n          [(even? e)\n          \
    \ (modulo (expt b 2) p)]\n          [else\n           (modulo (* b (exponentiate\
    \ b (- e 1))) p)]))\n  (modulo (exponentiate 2 n) p))\n", "  (define (compute-mod\
    \ x n)\n    (if (zero? n)\n        x\n        (compute-mod (modulo (* x 2) p)\
    \ (- n 1))))\n  (compute-mod 1 n))\n", "  (if (zero? n)\n      1\n      (if (odd?\
    \ n)\n          (modulo (* 2 (modp (- n 1) p)) p)\n          (modulo (* (modp\
    \ (/ n 2) p) (modp (/ n 2) p)) p))))\n", "  (define (multsqr p)\n    (define (pow-two\
    \ b x)\n      (if (eq? b 0)\n          x\n          (multsqr (if (eq? (bitwise-and\
    \ b 1) 1)\n                      (modulo (* x x) p)\n                      (pow-two\
    \ (bitwise-shift-right b 1) (* x x))))))\n    (pow-two n 1))\n  (multsqr p))\n",
  "  (define (square x) (* x x))\n  (define (square-mod x) (modulo (square x) p))\n\
    \  (define (iter n x)\n    (cond ((= n 0) x)\n          ((= (remainder n 2) 0)\
    \ (iter (/ n 2) (square-mod x)))\n          (else (iter (- n 1) (modulo (* x 2)\
    \ p)))))\n  (iter n 1))\n", "  (define (square-and-multiply x e)\n    (define\
    \ (iter x e)\n      (if (= 0 e)\n          1\n          (if (even? e)\n      \
    \        (iter (modulo (* x x) p) (quotient e 2))\n              (modulo (* x\
    \ (iter (modulo (* x x) p) (quotient (- e 1) 2))) p))))\n    (iter x e))\n  (modulo\
    \ (square-and-multiply 2 n) p))\n", "  (let loop ([n n] [res 1])\n    (if (= n\
    \ 0)\n        res\n        (loop (- n 1) (modulo (* res 2) p)))))\n", "  (if (=\
    \ n 0)\n      1\n      (modulo (* 2 (modp (- n 1) p)) p)))\n", "  (let loop ([n\
    \ n] [r 1])\n    (if (= n 0)\n        r\n        (loop (quotient n 2)\n      \
    \        (modulo (* r (if (odd? n) 2 1)) p)))))\n", "  (define (iter acc prod\
    \ pow)\n    (if (= pow n)\n        (remainder acc p)\n        (if (even? pow)\n\
    \            (iter acc (remainder (* prod prod) p) (quotient pow 2))\n       \
    \     (iter (remainder (+ acc prod) p) prod (sub1 pow)))))\n  (iter 0 1 1))\n",
  "  (define (iter i s)\n    (if (= i n)\n        s\n        (iter (+ i 1)\n     \
    \         (modulo (* s 2) p))))\n  (iter 0 1))\n", "  (let loop ([n n] [r 1])\n\
    \    (cond\n      [(zero? n) r]\n      [(even? n) (loop (quotient n 2) (modulo\
    \ (* r r) p))]\n      [else (loop (sub1 n) (modulo (* r 2) p))])))\n", "  (if\
    \ (= n 0)\n      1\n      (* (modp (- n 1) p) 2 p)))\n</code>\nYou can use it\
    \ as a method for calculating large values.\n", "  (define b 1)\n  (define i 0)\n\
    \  (cond [(zero? n) b]\n        [(even? n)\n         (set! i (* 2 (/ n 2)))\n\
    \         (set! b (* b (modp i p)))\n         (set! b (modulo b p))\n        \
    \ b]\n        [else\n         (set! i (- n 1))\n         (set! b (* 2 (modp i\
    \ p)))\n         (set! b (modulo b p))\n         b]))\n", "  (remainder (expt\
    \ 2 n) p))\n", "  (cond [(zero? n) 1]\n        [(even? n) (remainder (square (modp\
    \ (quotient n 2) p)) p)]\n        [else (remainder (* 2 (modp (quotient n 2) p))\
    \ p)]))\n", "  (cond [(zero? n) 1]\n        [(zero? (remainder n 2))\n       \
    \  (modulo (* (modp (quotient n 2) p)\n                    (modp (quotient n 2)\
    \ p))\n                p)]\n        [else\n         (modulo (* (modp (quotient\
    \ n 2) p)\n                    (modp (quotient n 2) p)\n                    2)\n\
    \                p)]))\n", "  (define (pow a b)\n    (if (= b 0)\n        1\n\
    \        (* a (pow a (- b 1)))))\n  (modulo (pow 2 n) p))\n", "  (cond [(zero?\
    \ n) 1]\n        [(even? n) (modp (/ n 2) p)]\n        [else (modulop (expt 2\
    \ (/ n 2)) p)]))\n", "  (define (loop i n)\n    (if (zero? n) 1\n        (let\
    \ ((a (loop i (- n 1))))\n          (if (even? n)\n              (modulo (* a\
    \ a) p)\n              (modulo (* i a) p)))))\n  (loop 2 n))\n", "  (define (iter\
    \ power acc result)\n    (if (zero? power)\n        result\n        (iter (sub1\
    \ power)\n              (* acc acc)\n              (if (even? power)\n       \
    \           result\n                  (* result acc)))))\n  (iter n 1 1))\n",
  "  (modulo (expt 2 n) p))\n", "  (define (iter n p p0 a0 b0)\n    (cond\n      ((=\
    \ n 0) b0)\n      ((= n 1) a0)\n      ((even? n)\n       (let ((p1 (modulo (*\
    \ p0 p0) p))\n             (a1 (+ (* b0 b0) (* p1 (modulo a0 p)))))\n        \
    \ (iter (/ n 2) p1 p1 (modulo a1 p) (modulo b0 p))))\n      (else\n       (let\
    \ ((a1 (+ (* a0 b0) (* p0 (modulo a0 p)))))\n         (iter (- n 1) p p0 (modulo\
    \ a1 p) (modulo b0 p))))))\n  (iter n p n 1 0))\n", "  (cond\n    [(= n 0) 1]\n\
    \    [(odd? n)\n     (modulo (* 2 (modp (- n 1) p)) p)]\n    [else\n     (modulo\
    \ (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]))\n", "  (define (modp-iter b e)\n\
    \    (cond ((= e 0) 1)\n          ((= (remainder e 2) 0)\n           (let ((nextb\
    \ (modulo (* b b) p)))\n             (modp-iter nextb (/ e 2))))\n          (else\
    \ (modulo (* b (modp-iter b (- e 1))) p))))\n  (modp-iter 2 n))\n</code>\n", " \
    \ (let loop ([a 1] [n n])\n    (if (= n 0)\n        a\n        (loop (modulo (*\
    \ a 2) p) (- n 1)))))\n", "  (define (step acc pow)\n    (cond\n      [(= pow\
    \ 0) acc]\n      [(odd? pow) (step (* acc n) (- pow 1))]\n      [else (step (modulo\
    \ (* acc acc) p) (/ pow 2))]))\n  (step 1 n))\n", "  (let loop ([n n] [acc 1])\n\
    \    (cond [(zero? n) acc]\n          [else (loop (sub1 n) (* acc 2))])))\n",
  "  (cond\n    [(= n 0)\n     1]\n    [(= (remainder n 2) 0)\n     (modulo (square\
    \ (modp (/ n 2) p)) p)]\n    [else\n     (modulo (* 2 (modp (- n 1) p)) p)]))\n",
  "  (define (square x) (* x x))\n  (define (mod-2-n n)\n    (if (= n 0) 1\n     \
    \   (if (= n 1) 2\n            (if (= (remainder n 2) 0)\n                (square\
    \ (mod-2-n (/ n 2)))\n                (* 2 (square (mod-2-n (/ (- n 1) 2))))))))\n\
    \  (remainder (mod-2-n n) p))\n", "  (if (= n 0)\n      1\n      (let ((y (modp\
    \ (- n 1) p)))\n        (if (= (modulo y p) 0)\n            0\n            (modulo\
    \ (* 2 y) p)))))\n", "  (define (square k) (* k k))\n  (cond [(= n 0) 1]\n   \
    \     [(= (remainder n 2) 0) (modulo (square (modp (/ n 2) p)) p)]\n        [else\
    \ (modulo (* 2 (modp (- n 1) p)) p)]))\n", "  (define (exp p)\n    (cond [(= n\
    \ 0) 1]\n          [(even? n) (modulo (* (square (exp (quotient n 2))) p) p)]\n\
    \          [else (modulo (* (exp (quotient n 2)) (square (exp (quotient n 2)))\
    \ p) p)]))\n  (exp p))\n</code>\nThe solution is not the most efficient in terms\
    \ of memory, but works fine anyway with reasonable input.\n", "  (modulo (expt\
    \ 2 n) p))\n", "  (cond\n    [(zero? n) 1]\n    [(even? n)\n     (let ([q (modp\
    \ (quotient n 2) p)])\n       (remainder (* q q) p))]\n    [else\n     (remainder\
    \ (* 2 (modp (quotient n 2) p)) p)]))\n", "  (let loop ([a 1] [n n])\n    (if\
    \ (zero? n)\n        a\n        (loop (remainder (* a 2) p) (sub1 n)))))\n", " \
    \ (define (square x)\n    (let ((x2 (* x x)))\n      (if (&gt; x2 p)\n       \
    \   (- x2 p)\n          x2)))\n  (define (expmod n p)\n    (if (= n 0)\n     \
    \   1\n        (let ((x (expmod (/ n 2) p)))\n          (square x))))\n  (expmod\
    \ n p))\n", "  (let ((s (integer->list (integer-length n))))\n    (define (r i)\n\
    \      (if (&lt;= i 0)\n          1\n          (let ((t (* (r (- i 1)) (r (- i\
    \ 1)))))\n            (if (bitwise-bit-set? s i)\n                (* (r (- i 1))\
    \ t)\n                t))))\n    (remainder (r (sub1 (integer-length n))) p)))\n\
    </code>\nNote that this is only for very large numbers (like the examples) and\
    \ is not equivalent to the <code>modulo</code> procedure, which is just a <code>remainder</code>\
    \ operation.\n", "  (if (zero? n)\n      1\n      (if (even? n)\n          (modulo\
    \ (* (modp (/ n 2) p) (modp (/ n 2) p)) p)\n          (modulo (* 2 (modp (/ (-\
    \ n 1) 2) p)) p))))\n</code>\n", "  (define (f k r)\n    (if (= k n)\n       \
    \ r\n        (f (+ k 1) (* 2 r))))\n  (modulo (f 0 1) p))\n", "  (let ([n (modulo\
    \ n p)])\n    (cond\n      [(zero? n) 1]\n      [(even? n) (modulo (square (modp\
    \ (/ n 2) p)) p)]\n      [else (modulo (* 2 (modp (- n 1) p)) p)])))\n</code>\n",
  "  (cond [(= n 0) 1]\n        [(= n 1) 2]\n        [(even? n)\n         (let ([p\
    \ (modp (quotient n 2) p)])\n           (modulo (* p p) p))]\n        [else\n\
    \         (let ([p (modp (quotient (- n 1) 2) p)])\n           (modulo (* p p\
    \ 2) p))]))\n", "  (cond\n    [(= n 0) 1]\n    [(even? n)\n     (modulo (* (modp\
    \ (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else\n     (modulo (* (modp (/ n 2) p)\
    \ (modp (/ n 2) p) 2) p)]))\n", "  (define (f n b)\n    (if (= n 0)\n        b\n\
    \        (f (- n 1) (* 2 b) p)))\n  (f n 1))\n", "  (define (pow a b)\n    (if\
    \ (zero? b)\n        1\n        (* a (pow a (- b 1)))))\n  (modulo (pow 2 n) p))\n",
  "  (define (mp iter res)\n    (cond [(zero? iter) res]\n          [else (mp (- iter\
    \ 1) (* 2 res))]))\n  (modulo (mp n 1) p))\n", "  (define (iter n p prod)\n  \
    \  (if (= n 0)\n        prod\n        (iter (- n 1) p (* prod 2 p))))\n  (iter\
    \ n p 1))\n", "  (define-values (d q) (quotient/remainder n p))\n  (if (positive?\
    \ d)\n      (+ q p)\n      q))\n", "  (define (modp-iter acc p-bit)\n    (cond\
    \ [(zero? p-bit) acc]\n          [(odd? n) (modp-iter (remainder (* acc 2) p)\
    \ (quotient p-bit 2))]\n          [else (modp-iter (remainder (* acc 2) p) (quotient\
    \ p-bit 2))]))\n  (modp-iter 1 p))\n", "  (let ([r 1])\n    (for ([i (in-range\
    \ n)])\n      (set! r (* r 2 r))\n      (set! r (modulo r p)))\n    r))\n</code>\n",
  "  (modulo (expt 2 n) p))\n", "  (let loop ([n n] [p p] [r 1])\n    (if (zero? n)\n\
    \        r\n        (loop (quotient n 2) p\n              (remainder (* r (if\
    \ (even? n) 1 p)) p)))))\n", "  (cond [(= n 0) 1]\n        [(= n 1) 2]\n     \
    \   [(odd? n)\n         (modulo (* 2 (modp (- n 1) p)) p)]\n        [else\n  \
    \       (modulo (* (modp (- n 1) p) (modp (- n 1) p)) p)]))\n", "  (if (= n 0)\n\
    \      1\n      (let ((x (- n 1)))\n        (let ((sqrt (- (/ p 2) 1)))\n    \
    \      (let loop ((x x) (n n) (res 1))\n            (if (&lt;= x 0)\n        \
    \        res\n                (if (&lt;= sqrt x)\n                    (loop (-\
    \ x sqrt) (- n sqrt) (modulo (* res 2) p))\n                    (loop (- x 1)\
    \ (- n 1) (modulo (* res 2) p)))))))))\n</code>\n", "  (define (pow b e)\n   \
    \ (define (pow-iter res b e)\n      (if (zero? e)\n          res\n          (pow-iter\
    \ (modulo (* res b) p) b (sub1 e))))\n    (pow-iter 1 b e))\n  (pow 2 n))\n",
  "  (cond\n    [(= p 1) 0]\n    [(= p 2) (modulo n 1)]\n    [(= n 0) 1]\n    [(odd?\
    \ n)\n     (modulo (* (modp (- n 1) p) 2) p)]\n    [else\n     (modulo (square\
    \ (modp (/ n 2) p)) p)]))\n", "  (define (iter n res)\n    (cond\n      [(= n\
    \ 0) res]\n      [(even? n) (iter (/ n 2) (* res res 2))]\n      [else (iter (-\
    \ n 1) (* res 2))]))\n  (iter n 1))\n", "  (if (= n 0)\n      1\n      (let ((temp\
    \ (modp (sub1 n) p)))\n        (modulo (* temp temp) p))))\n", "  (define (modp-iter\
    \ i p2 res)\n    (cond [(= i n) res]\n          [(even? i) (modp-iter (/ i 2)\
    \ (modulo (* p2 p2) p) res)]\n          [else (modp-iter (sub1 i) p2 (modulo (*\
    \ res p2) p))]))\n  (modp-iter n 1 1))\n</code>\n", "  (define (iter k exp)\n\
    \    (cond\n      [(= k 0) exp]\n      [(even? k) (iter (/ k 2) (modulo (* exp\
    \ exp) p))]\n      [else (iter (- k 1) (modulo (* exp 2) p))]))\n  (iter n 1))\n",
  "  (let loop ([n n] [result 1])\n    (if (even? n)\n        (loop (/ n 2) (* result\
    \ result))\n        (if (= n 1)\n            result\n            (loop (- n 1)\
    \ (* 2 result))))))\n</code>\nI want to know:\n\nIs this a tail-recursive function?\n\
    If not, why not?\nIf so, how can I rewrite it to be tail-recursive?\nIs it a good\
    \ idea to change it to be tail-recursive?\n\nI know what tail-recursion is, and\
    \ I understand that the current definition is not tail-recursive, but I don't\
    \ know why. I also don't understand what to do instead.\n\n\nA:\n\nTo generalize\
    \ upon Michael's answer, the key is to look at the last thing being done in the\
    \ function before the recursive call. This is the only thing that contributes\
    \ to its length (in the worst case).\nIn your function, the only thing is multiplying\
    \ by <code>2</code> (or dividing by 2 and multiplying by itself, which is the\
    \ same thing). This is a constant length operation, so the length of the computation\
    \ is proportional to the logarithm of <code>n</code>.\nIf you want tail-recursion,\
    \ you need to look at the last thing that happens before you return. That isn't\
    \ <code>result</code>, it's multiplying <code>2</code> into <code>result</code>.\
    \ In the tail-recursive version, the last thing before returning is multiplying\
    \ the proper result into the accumulator. So we have to figure out the proper\
    \ result each time. We do this by re-applying the theorem that <code>2^(a+b) =\
    \ 2^a * 2^b</code> as many times as it takes to get a remainder that is odd. We\
    \ can use a helper function to keep track of the exponent we started with, so\
    \ that we can recognize when we're done (and stop multiplying by 2) and when we're\
    \ not (and multiply by 2).\n<code>(define (modp n p)\n  (define (modp-helper n\
    \ p acc exp)\n    (cond [(zero? n) (* acc exp)]\n          [(even? n) (modp-helper\
    \ (/ n 2) p acc (* exp 2))]\n         ", "  (let loop ([n n] [p p] [t 1])\n  \
    \  (if (zero? n)\n        t\n        (loop (quotient n 2) (modulo (* p p) p)\n\
    \              (if (odd? n) (modulo (* t p) p) t)))))\n", "  (define (iter n p)\n\
    \    (if (= n 0)\n        1\n        (let ([m (modulo (iter (- n 1) p) p)])\n\
    \          (modulo (* m 2) p))))\n  (iter n p))\n", "  (let loop ([n n] [acc 1])\n\
    \    (cond\n      [(zero? n) acc]\n      [(odd? n) (loop (bitwise-arithmetic-shift-right\
    \ n 1)\n                      (modulo (* acc 2) p))]\n      [else (loop (bitwise-arithmetic-shift-right\
    \ n 1)\n                  (square (modulo acc p)))])))\n", "  (cond\n    [(= n\
    \ 0) 1]\n    [(zero? (remainder n 2))\n     (modulo (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p)) p)]\n    [else\n     (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)\
    \ 2) p)]))\n", "  (if (= n 0)\n      1\n      (* 2 (modp (- n 1) p))))\n", " \
    \ (if (zero? n)\n      1\n      (if (odd? n)\n          (modulo (* 2 (modp (-\
    \ n 1) p)) p)\n          (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p))))\n",
  "  (let loop ([n n] [r 1])\n    (if (= n 0)\n        r\n        (loop (quotient\
    \ n 2)\n              (modulo (* r (if (odd? n) 2 1)) p)))))\n", "  (cond\n  \
    \  [(= n 0) 1]\n    [(= (modulo n 2) 0)\n     (let* ([m (/ n 2)]\n           \
    \ [a (modp m p)])\n       (remainder (* a a) p))]\n    [else\n     (let* ([m (-\
    \ n 1)]\n            [a (modp m p)])\n       (remainder (* a 2) p))]))\n</code>\n",
  "  (cond [(= n 0) 1]\n        [(< n 0)\n         (let ((r (modp (- n) p)))\n   \
    \        (remainder (* r 2) p))]\n        [else\n         (let ((r (modp (- n\
    \ 1) p)))\n           (remainder (* r 2) p))]))\n", "  (if (zero? n)\n      1\n\
    \      (let ([m (modulo n 2)])\n        (if (zero? m)\n            (modulo (*\
    \ (modp (sub1 n) p) 2) p)\n            (modulo (modulo (modp (sub1 n) p) p) p)))))\n",
  "  (define (mp n a p)\n    (if (zero? n) 1\n        (if (odd? n) (remainder (* a\
    \ (mp (sub1 n) a p)) p)\n            (remainder (mp (sub1 n) a p) p))))\n  (mp\
    \ n 2 p))\n", "  (cond\n    [(= n 0) 1]\n    [(even? n)\n     (modulo (square\
    \ (modp (/ n 2) p)) p)]\n    [else\n     (modulo (* 2 (modp (- n 1) p)) p)]))\n",
  "  (foldl (\u03BB (i acc) (* acc 2)) 1 (build-list n (\u03BB (i) (printf \"i = ~s\\\
    n\" i))))\n  )\n", "  (if (= n 0)\n      1\n      (* (modp (- n 1) p) 2)))\n",
  "  (define (mul b)\n    (define (acc b a)\n      (cond\n        [(zero? a) 1]\n\
    \        [(negative? a) (modulo (acc (modulo (mul b) p)\n                    \
    \               (add1 (quotient a 2)))\n                               p)]\n \
    \       [else (if (odd? a)\n                 (modulo (mul (modulo (mul b) p))\
    \ p)\n                 (acc (modulo (mul b) p) (quotient a 2)))]))\n    (acc b\
    \ 1))\n  (mul n))\n", "  (let ([k p])\n    (for ([i (in-range 0 (- (sqrt (double-flonum\
    \ p)) 1))])\n      (set! k (modulo k k))\n      (if (&gt; k 1) (set! k (modulo\
    \ n k))))\n    k))\n", "  (let loop ([n n] [p p] [a 1])\n    (if (zero? n)\n \
    \       a\n        (let ([q (quotient p 2)])\n          (loop (sub1 n) q\n   \
    \             (if (odd? p)\n                    (modulo (* a 2) p)\n         \
    \           a))))))\n", "  (modulo n p))\n", "  (define (modp-iter n count max)\n\
    \    (cond\n      [(zero? n) count]\n      [(and (<= max (remainder n 2))\n  \
    \          (= 0 (remainder (sub1 n) 2)))\n       (modp-iter (quotient n 2) (add1\
    \ count) max)]\n      [else (modp-iter (quotient n 2) count max)]))\n  (modp-iter\
    \ n 0 (sub1 p)))\n", "  (require math)\n  (modulo (expt 2 n) p))\n", "  (define\
    \ (loop acc n)\n    (cond\n      [(= n 0) acc]\n      [(odd? n) (loop (+ acc acc)\
    \ (- n 1))]\n      [else (loop (+ acc acc) (/ n 2))]))\n  (modulo (loop 1 n) p))\n",
  "  (modulo (expt 2 n) p))\n", "  (cond [(zero? n) 1]\n        [(even? n) (modulo\
    \ (square (modp (quotient n 2) p)) p)]\n        [else (modulo (* (modp (quotient\
    \ n 2) p) 2) p)]))\n", "  (define (iter i)\n    (if (= i n)\n        1\n     \
    \   (modulo (* 2 (iter (- i 1))) p)))\n  (iter 1))\n", "  (modulo (expt 2 n) p))\n",
  "  (define (modp* a b p)\n    (cond [(= b 0) 1]\n          [(= (remainder b 2) 0)\n\
    \           (let ([t (modp* a (/ b 2) p)])\n             (remainder (* t t) p))]\n\
    \          [else (remainder (* a (modp* a (- b 1) p)) p)]))\n  (modp* 2 n p))\n",
  "  (let loop ([res 1] [n n])\n    (if (= n 0)\n        res\n        (loop (modulo\
    \ (* res 2) p) (- n 1)))))\n", "  (cond ((< n 0) (error \"pow-mod is only defined\
    \ for natural n\"))\n        ((= n 0) 1)\n        ((even? n)\n         (let ([r\
    \ (modp (/ n 2) p)])\n           (remainder (* r r) p)))\n        (else\n    \
    \     (remainder (* (modp (- n 1) p) 2) p))))\n", "  (modulo (expt 2 n) p))\n",
  "  (letrec ((loop ([n n] [r 1]))\n    (cond\n      [(even? n) (loop (quotient n\
    \ 2) (modulo (* r r) p))]\n      [else (loop (sub1 n) (modulo (* r 2) p))])))\n\
    \  (modulo n p))\n", "  (let ([rem (modulo n p)])\n    (if (negative? rem)\n \
    \       (modulo (+ rem p) p)\n        rem)))\n", "  (cond [(= n 0) 1]\n      \
    \  [(zero? (remainder n 2))\n         (modulo (* (modp (/ n 2) p) (modp (/ n 2)\
    \ p)) p)]\n        [else\n         (modulo (* (modp (- n 1) p) 2) p)]))\n", " \
    \ (define (iter i acc)\n    (if (= i 0)\n        acc\n        (iter (- i 1) (*\
    \ 2 acc))))\n  (modulo (iter n 1) p))\n", "  (modulo (* 2 n) p))\n", "  (modulo\
    \ (expt 2 n) p))\n", "  (if (= n 0)\n      1\n      (let ([n/2 (quotient n 2)])\n\
    \        (modulo (* (modp n/2 p) (modp n/2 p)) p))))\n</code>\nYour case works:\n\
    <code>&gt; (modp 5 11)\n10\n</code>\nBut I can demonstrate some problems:\n<code>&gt;\
    \ (modp 10000000000000000000 11111111111111111111)\n10000000000000000000\n&gt;\
    \ (modp 10000000000000000000 11111111111111111111)\n0\n</code>\nThe only way I\
    \ can see to fix this is to use an extended precision arbitrary precision number\
    \ type or to implement your own.\n", "  (define (expmod b n m)\n    (cond ((=\
    \ n 0) 1)\n          ((even? n) (modulo (* (expmod b (/ n 2) m)\n            \
    \                    (expmod b (/ n 2) m))\n                             m))\n\
    \          (else (modulo (* b (expmod b (- n 1) m))\n                        \
    \ m))))\n  (expmod 2 n p))\n</code>\nNow, the Fermats little theorem states that:\n\
    $$ a^{p-1} \\equiv 1 \\mod p $$\nfor any number $a$ which is not divisible by\
    \ $p$.\nUsing this we can check whether a number is prime or not as follows:\n\
    <code>#lang racket\n", "  (modulo n p))\n", "  (match n\n    [(list left middle\
    \ right)\n     (let* ([sqrtn (expt 2 (quotient n 2))]\n            [middle-part\
    \ (expt middle p)]\n            [left-sqrtn (expt sqrtn p)]\n            [right-sqrtn\
    \ (expt sqrtn p)])\n       (let* ([left-part (modulo (* left-sqrtn left-sqrtn)\
    \ p)]\n              [right-part (modulo (* right-sqrtn right-sqrtn) p)])\n  \
    \       (modulo (* left-part middle-part right-part) p)))]\n    [_\n     (expt\
    \ 2 n)]))\n", "  (if (zero? n)\n      1\n      (modulo (* 2 (modp (sub1 n) p))\
    \ p)))\n", "  (if (zero? n)\n      1\n      (if (even? n)\n          (let ([n\
    \ (/ n 2)])\n            (let ([x (modp n p)])\n              (let ([x (+ x x)])\n\
    \                (if (&gt; x p)\n                    (- x p)\n               \
    \     x))))\n          (let ([x (modp (- n 1) p)])\n            (let ([x (+ x\
    \ x)])\n              (if (&gt; x p)\n                  (- x p)\n            \
    \      x))))))\n", "  (remainder (expt 2 n) p))\n", "  (cond [(= n 0) 1]\n   \
    \     [(= n 1) 2]\n        [(even? n) (let [(p (modp (quotient n 2) p))]\n   \
    \                   (modulo (* p p) p))]\n        [else (modulo (* 2 (modp (-\
    \ n 1) p)) p)]))\n", "  (define (modp-iter n p val)\n    (cond [(zero? n) val]\n\
    \          [(even? n) (modp-iter (quotient n 2) p (remainder (* val val) p))]\n\
    \          [else (modp-iter (sub1 n) p (remainder (* val 2) p))]))\n  (modp-iter\
    \ n p 1))\n</code>\nThis is an exponentiation by squaring algorithm, and it runs\
    \ in <code>O(log n)</code> steps. Note that it also uses a trick to avoid overflow.\n\
    Your code runs in linear time, and it has all the weaknesses of the naive algorithm.\
    \ The problem is that you have to repeatedly square the result and then take the\
    \ modulus. This leads to error accumulation.\nFor example, <code>(modulo (expt\
    \ 2 1000) 100)</code> returns <code>24</code>, while <code>(modp 1000 100)</code>\
    \ returns <code>76</code>.\n\n[1] http://www.cs.rpi.edu/~musser/gp/exponent.html\n",
  "  (define (iter n acc)\n    (if (= n 0)\n        acc\n        (iter (- n 1) (*\
    \ 2 acc) % p)))\n  (iter n 1))\n", "  (if (= n 0)\n      1\n      (* 2 (modp (-\
    \ n 1) p) p)))\n", "  (define (power-mod b exp p)\n    (cond [(= exp 0) 1]\n \
    \         [(= (remainder exp 2) 0)\n           (let ((z (modulo (square (power-mod\
    \ b (/ exp 2) p)) p)))\n             (if (and (= z 0) (= b 2))\n             \
    \    1\n                 z))]\n          [else (modulo (* b (power-mod b (- exp\
    \ 1) p)) p)]))\n  (power-mod 2 n p))\n", "  (define (loop n p n1)\n    (if (zero?\
    \ n)\n        n1\n        (loop (sub1 n) p (modulo (* 2 n1) p))))\n  (loop n p\
    \ 1))\n", "  (modulo (expt 2 n) p))\n", "  (modulo (expt 2 n) p))\n", "  (let\
    \ f ([n n] [k 1])\n    (if (zero? n)\n        k\n        (f (quotient n 2)\n \
    \          (if (odd? n)\n               (modulo (* 2 k) p)\n               k)))))\n",
  "  (let ([x (* p 2)])\n    (cond\n      [(zero? n) 1]\n      [(= n 1) (modulo x\
    \ p)]\n      [(even? n) (modulo (expt (modp (/ n 2) p) 2) p)]\n      [else (modulo\
    \ (* (modp (- n 1) p) x) p)])))\n", "  (define (mp i n p b)\n    (cond [(= i 0)\
    \ 1]\n          [(= (modulo n 2) 0)\n           (mp (- i 1) (/ n 2) p\n      \
    \         (modulo (* b b) p))]\n          [else\n           (mp (- i 1) (/ n 2)\
    \ p\n               (modulo (* b b) p)\n               (modulo (* b (modp 1 p))\
    \ p))]))\n  (mp n n p 0))\n", "  (let loop ([n n] [p p] [e 1])\n    (if (zero?\
    \ n)\n        e\n        (loop (quotient n 2) p (* e (if (odd? n)\n          \
    \                              (modulo p e)\n                                \
    \        (modulo p (- p e))))))))\n", "  (let ([n (integer->big-posfix n)])\n\
    \    (define (expt b n)\n      (cond\n        [(= n 0) (big-posfix->integer 1)]\n\
    \        [(odd? n) (modulo (square (expt b (/ n 2))) p)]\n        [else (expt\
    \ (square b) (/ n 2))]))\n    (modulo (expt 2 n) p)))\n", "  (if (= n 0)\n   \
    \   1\n      (remainder (* 2 (modp (- n 1) p)) p)))\n</code>\nThere are many ways\
    \ to write a function that takes an argument <code>n</code> and returns the number\
    \ of trailing zeros in the binary representation of <code>n</code>.\nThe following\
    \ function is efficient but not particularly idiomatic Racket.\n<code>#lang racket\n",
  "  (if (= n 0)\n      1\n      (* (modp (- n 1) p) 2 (mod p))))\n", "  (let* ((r\
    \ (integer-sqrt p))\n         (a (random-integer (- r 1) r))\n         (table\
    \ (make-hash)))\n    (hash-set! table 0 (modulo (expt a r) p))\n    (hash-set!\
    \ table 1 (modulo (expt a (* 2 r)) p))\n    (define (iter n acc)\n      (cond\n\
    \        [(= n 0) acc]\n        [(hash-ref table n #f)\n         (iter (- n 1)\
    \ (modulo (* acc (hash-ref table n)) p))]\n        [else\n         (let ((tmp\
    \ (modulo (* acc (hash-ref table (- n 1))) p)))\n           (hash-set! table n\
    \ tmp)\n           (iter (- n 1) tmp))]))\n    (iter n 1)))\n", "  (define (modp-iter\
    \ n acc)\n    (cond [(= n 0) acc]\n          [else (modp-iter (- n 1)\n      \
    \                     (if (= (remainder acc 2) 0)\n                          \
    \     (/ acc 2)\n                               (/ (- acc p) 2)))]))\n  (modp-iter\
    \ n n))\n", "  (cond [(= p 1) 0]\n        [(even? n) (modulo (square (modp (/\
    \ n 2) p)) p)]\n        [else (modulo (* (modp (- n 1) p) 2) p)]))\n", "  (define\
    \ (solve acc exponent)\n    (if (= exponent 0)\n        acc\n        (solve (modulo\
    \ (* acc 2) p) (- exponent 1))))\n  (solve 1 n))\n", "  (modulo (* 2 n) p))\n",
  "  (cond [(= n 0) 1]\n        [(= (remainder n 2) 0)\n         (remainder (expt\
    \ 2 (/ n 2)) p)]\n        [else\n         (remainder (* 2 (modp (- n 1) p)) p)]))\n",
  "  (cond ((< n 0)\n         (error \"Negative n\"))\n        ((zero? n)\n      \
    \   1)\n        ((even? n)\n         (modulo (* (modp (/ n 2) p) (modp (/ n 2)\
    \ p)) p))\n        (else\n         (modulo (* (modp (- n 1) p) 2) p))))\n", " \
    \ (if (= n 0)\n      1\n      (if (even? n)\n          (modulo (* (modp (/ n 2)\
    \ p) (modp (/ n 2) p)) p)\n          (modulo (* (modp (/ n 2) p) (modp (/ n 2)\
    \ p) 2) p))))\n", "  (define (iter p n)\n    (cond\n      [(= n 0) p]\n      [(even?\
    \ n) (iter (modulo (* p p) p) (/ n 2))]\n      [else (modulo (* p (iter p (- n\
    \ 1))) p)]))\n  (iter 2 n))\n", "  (define x 2)\n  (define n2 n)\n  (define r\
    \ 1)\n  (define two (expt 2 64))\n  (while (not (= n2 0))\n    (cond\n      ((odd?\
    \ n2)\n       (set! r (modulo (* r x) p))\n       (set! n2 (- n2 1)))\n      (else\n\
    \       (set! x (modulo (* x x) p))\n       (set! n2 (/ n2 2)))))\n  r)\n", " \
    \ (let loop ([n n] [result 1])\n    (cond [(= n 0) result]\n          [else (loop\
    \ (- n 1) (modulo (* 2 result) p))])))\n", "  (let ((result 1))\n    (for ([i\
    \ (in-range n)])\n      (set! result (* result 2)))\n    (modulo result p)))\n",
  "  (let ((r 1))\n    (for ((k 1) (< k n))\n      (set! r (* r 2)))\n    (remainder\
    \ r p)))\n", "  (let loop ([n n] [a 1])\n    (if (zero? n)\n        a\n      \
    \  (loop (quotient n 2)\n              (if (odd? n)\n                  (modulo\
    \ (* a a 2) p)\n                  (modulo (* a a) p))))))\n</code>\nTesting that:\n\
    <code>&gt; (modp 42 20)\n4\n&gt; (modp 6 20)\n6\n&gt; (modp 0 20)\n1\n&gt; (modp\
    \ 1 20)\n1\n&gt; (modp 2 20)\n2\n&gt; (modp 3 20)\n3\n&gt; (modp 4 20)\n4\n&gt;\
    \ (modp 5 20)\n5\n&gt; (modp 6 20)\n6\n&gt; (modp 7 20)\n7\n&gt; (modp 8 20)\n\
    8\n&gt; (modp 9 20)\n9\n&gt; (modp 10 20)\n10\n&gt; (modp 11 20)\n11\n&gt; (modp\
    \ 12 20)\n12\n&gt; (modp 13 20)\n13\n&gt; (modp 14 20)\n14\n&gt; (modp 15 20)\n\
    15\n&gt; (modp 16 20)\n16\n&gt; (modp 17 20)\n17\n&gt; (modp 18 20)\n18\n&gt;\
    \ (modp 19 20)\n19\n&gt; (modp 20 20)\n0\n&gt; (modp 21 20)\n1\n&gt; (modp 22\
    \ 20)\n2\n&gt; (modp 23 20)\n3\n&gt; (modp 24 20)\n4\n&gt; (modp 25 20)\n5\n&gt;\
    \ (modp 26 20)\n6\n&gt; (modp 27 20)\n7\n&gt; (modp 28 20)\n8\n&gt; (modp 29 20)\n\
    9\n&gt; (modp 30 20)\n10\n&gt; (modp 31 20)\n11\n&gt; (modp 32 20)\n12\n&gt; (modp\
    \ 33 20)\n13", "  (define (mul-mod a b p)\n    (modulo (* a b) p))\n  (define\
    \ (expmod b e p)\n    (cond [(= e 0) 1]\n          [(even? e) (mul-mod (expmod\
    \ b (/ e 2) p)\n                              (expmod b (/ e 2) p)\n         \
    \                     p)]\n          [else (mul-mod b (expmod b (- e 1) p) p)]))\n\
    \  (expmod 2 n p))\n", "  (if (= n 0)\n      1\n      (let ((m (modp (quotient\
    \ n 2) p)))\n        (if (even? n)\n            (modulo (* m m) p)\n         \
    \   (modulo (* m m 2) p)))))\n", "  (define (mps n p result)\n    (cond [(= n\
    \ 0) result]\n          [(= (remainder n 2) 0)\n           (mps (/ n 2) p\n  \
    \              (remainder (* result result) p))]\n          [else\n          \
    \ (mps (- n 1) p\n                (remainder (* 2 result) p))]))\n  (mps n p 1))\n",
  "  (define (iter acc n)\n    (if (zero? n)\n        acc\n        (iter (modulo (*\
    \ acc 2) p) (- n 1))))\n  (iter 1 n))\n", "  (if (= n 0)\n      1\n      (let*\
    \ ([n2 (modulo (* 2 n) p)]\n             [d (modp n2 p)])\n        (modulo (*\
    \ d d) p))))\n", "  (modulo (* 2 n) p))\n", "  (modulo (expt 2 n) p))\n", "  (if\
    \ (= n 0)\n      1\n      (* 2 (modp (- n 1) p))))\n", "  (modulo (expt 2 n) p))\n",
  "  (define (helper acc n p)\n    (cond [(= n 0) acc]\n          [(even? n) (helper\
    \ (remainder (* acc acc) p) (/ n 2) p)]\n          [else (helper (remainder (*\
    \ acc acc 2) p) (/ n 2) p)]))\n  (helper 1 n p))\n", "  (if (zero? n)\n      1\n\
    \      (* 2 (modp (sub1 n) p))))\n", "  (define (loop pow ret)\n    (if (zero?\
    \ n)\n        ret\n        (loop (modulo (* 2 pow) p)\n              (if (even?\
    \ n)\n                  ret\n                  (modulo (+ ret pow) p)))))\n  (loop\
    \ 1 1))\n", "  (let ((a 2)\n        (n n)\n        (p p)\n        (b 1))\n   \
    \ (cond ((< n 0) 1)\n          ((= n 0) b)\n          (else (let loop ([n (- n\
    \ 1)])\n                  (cond ((= n 0) (modulo (* a b) p))\n               \
    \         (else (let ([a (modulo (* a a) p)])\n                              \
    \  (loop (- n 1))))))))))\n", "  (define (power x y)\n    (cond\n      [(= y 0)\
    \ 1]\n      [(= (remainder y 2) 0) (expt (power x (/ y 2)) 2)]\n      [else (*\
    \ x (power x (- y 1)))]))\n  (remainder (power 2 n) p))\n", "  (let recur ([n\
    \ n] [p p] [c 1])\n    (if (zero? n)\n        c\n        (let ([nextc (* c 2)])\n\
    \          (if (&gt; nextc p)\n              (recur (- n 1) p (- nextc p))\n \
    \             (recur (- n 1) p nextc))))))\n", "  (define (pow x n)\n    (if (=\
    \ n 0)\n        1\n        (* x (pow x (- n 1)))))\n  (modulo (pow 2 n) p))\n",
  "  (modulo (expt 2 n) p))\n", "  (let loop ([n n] [p p] [r 1])\n    (if (= n 0)\n\
    \        r\n        (let ([n (inexact->exact (truncate (/ n 2)))]\n          \
    \    [r (remainder (* r (if (odd? n) 2 1)) p)])\n          (loop n p r)))))\n",
  "  (let loop ([exp 0] [m 2])\n    (cond [(= exp n) 1]\n          [(zero? (remainder\
    \ m p))\n           (let ([m/p (quotient m p)])\n             (loop (+ exp 1)\
    \ (remainder (* m/p m) p)))]\n          [else\n           (loop (+ exp 1) (remainder\
    \ (* m m) p))])))\n", "  (let loop ([n n] [acc 1])\n    (if (= n 0)\n        acc\n\
    \        (loop (quotient n 2)\n              (if (odd? n)\n                  (modulo\
    \ (* acc 2) p)\n                  (modulo (* acc acc) p))))))\n", "  (cond\n \
    \   [(= n 0) 1]\n    [(even? n)\n     (let ((v (modp (/ n 2) p)))\n       (modulo\
    \ (* v v) p))]\n    [else\n     (modulo (* 2 (modp (- n 1) p)) p)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
